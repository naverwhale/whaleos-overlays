diff --git a/Documentation/devicetree/bindings/arm/mediatek/mediatek,mmsys.txt b/Documentation/devicetree/bindings/arm/mediatek/mediatek,mmsys.txt
deleted file mode 100644
index d8c9108c3b4a44915362a92784c196c7c95ffd1e..0000000000000000000000000000000000000000
--- a/Documentation/devicetree/bindings/arm/mediatek/mediatek,mmsys.txt
+++ /dev/null
@@ -1,30 +0,0 @@
-Mediatek mmsys controller
-============================
-
-The Mediatek mmsys system controller provides clock control, routing control,
-and miscellaneous control in mmsys partition.
-
-Required Properties:
-
-- compatible: Should be one of:
-	- "mediatek,mt2701-mmsys", "syscon"
-	- "mediatek,mt2712-mmsys", "syscon"
-	- "mediatek,mt6765-mmsys", "syscon"
-	- "mediatek,mt6779-mmsys", "syscon"
-	- "mediatek,mt6797-mmsys", "syscon"
-	- "mediatek,mt7623-mmsys", "mediatek,mt2701-mmsys", "syscon"
-	- "mediatek,mt8173-mmsys", "syscon"
-	- "mediatek,mt8183-mmsys", "syscon"
-- #clock-cells: Must be 1
-
-For the clock control, the mmsys controller uses the common clk binding from
-Documentation/devicetree/bindings/clock/clock-bindings.txt
-The available clocks are defined in dt-bindings/clock/mt*-clk.h.
-
-Example:
-
-mmsys: syscon@14000000 {
-	compatible = "mediatek,mt8173-mmsys", "syscon";
-	reg = <0 0x14000000 0 0x1000>;
-	#clock-cells = <1>;
-};
diff --git a/Documentation/devicetree/bindings/arm/mediatek/mediatek,mmsys.yaml b/Documentation/devicetree/bindings/arm/mediatek/mediatek,mmsys.yaml
new file mode 100644
index 0000000000000000000000000000000000000000..e5433612e860cf2138531b7982812fce8ea69867
--- /dev/null
+++ b/Documentation/devicetree/bindings/arm/mediatek/mediatek,mmsys.yaml
@@ -0,0 +1,89 @@
+# SPDX-License-Identifier: (GPL-2.0 OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: "http://devicetree.org/schemas/arm/mediatek/mediatek,mmsys.yaml#"
+$schema: "http://devicetree.org/meta-schemas/core.yaml#"
+
+title: MediaTek mmsys controller
+
+maintainers:
+  - Matthias Brugger <matthias.bgg@gmail.com>
+
+description:
+  The MediaTek mmsys system controller provides clock control, routing control,
+  and miscellaneous control in mmsys partition.
+
+properties:
+  $nodename:
+    pattern: "^syscon@[0-9a-f]+$"
+
+  compatible:
+    oneOf:
+      - items:
+          - enum:
+              - mediatek,mt2701-mmsys
+              - mediatek,mt2712-mmsys
+              - mediatek,mt6765-mmsys
+              - mediatek,mt6779-mmsys
+              - mediatek,mt6797-mmsys
+              - mediatek,mt8167-mmsys
+              - mediatek,mt8173-mmsys
+              - mediatek,mt8183-mmsys
+              - mediatek,mt8365-mmsys
+              - mediatek,mt8195-vdosys0
+              - mediatek,mt8195-vdosys1
+          - const: syscon
+      - items:
+          - const: mediatek,mt7623-mmsys
+          - const: mediatek,mt2701-mmsys
+          - const: syscon
+
+  reg:
+    maxItems: 1
+
+  power-domains:
+    description:
+      A phandle and PM domain specifier as defined by bindings
+      of the power controller specified by phandle. See
+      Documentation/devicetree/bindings/power/power-domain.yaml for details.
+
+  mboxes:
+    description:
+      Using mailbox to communicate with GCE, it should have this
+      property and list of phandle, mailbox specifiers. See
+      Documentation/devicetree/bindings/mailbox/mtk-gce.txt for details.
+    $ref: /schemas/types.yaml#/definitions/phandle-array
+
+  mediatek,gce-client-reg:
+    description:
+      The register of client driver can be configured by gce with 4 arguments defined
+      in this property, such as phandle of gce, subsys id, register offset and size.
+      Each subsys id is mapping to a base address of display function blocks register
+      which is defined in the gce header include/include/dt-bindings/gce/<chip>-gce.h.
+    $ref: /schemas/types.yaml#/definitions/phandle-array
+    maxItems: 1
+
+  "#clock-cells":
+    const: 1
+
+  "#reset-cells":
+    const: 1
+
+required:
+  - compatible
+  - reg
+  - "#clock-cells"
+
+additionalProperties: false
+
+examples:
+  - |
+    mmsys: syscon@14000000 {
+        compatible = "mediatek,mt8173-mmsys", "syscon";
+        reg = <0 0x14000000 0 0x1000>;
+        power-domains = <&spm MT8173_POWER_DOMAIN_MM>;
+        #clock-cells = <1>;
+        mboxes = <&gce 0 CMDQ_THR_PRIO_HIGHEST>,
+                 <&gce 1 CMDQ_THR_PRIO_HIGHEST>;
+        mediatek,gce-client-reg = <&gce SUBSYS_1400XXXX 0 0x1000>;
+    };
diff --git a/Documentation/devicetree/bindings/cpufreq/cpufreq-mediatek-hw.yaml b/Documentation/devicetree/bindings/cpufreq/cpufreq-mediatek-hw.yaml
new file mode 100644
index 0000000000000000000000000000000000000000..0f3ad47b59b142000f94e2c88e8b5e867c237fed
--- /dev/null
+++ b/Documentation/devicetree/bindings/cpufreq/cpufreq-mediatek-hw.yaml
@@ -0,0 +1,127 @@
+# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/cpufreq/cpufreq-mediatek-hw.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: MediaTek's CPUFREQ Bindings
+
+maintainers:
+  - Hector Yuan <hector.yuan@mediatek.com>
+
+description:
+  CPUFREQ HW is a hardware engine used by MediaTek
+  SoCs to manage frequency in hardware. It is capable of controlling frequency
+  for multiple clusters.
+
+properties:
+  compatible:
+    const: mediatek,cpufreq-hw
+
+  reg:
+    minItems: 1
+    maxItems: 2
+    description: |
+      Addresses and sizes for the memory of the
+      HW bases in each frequency domain.
+
+  "#performance-domain-cells":
+    description:
+      Number of cells in a performance domain specifier. Typically 0 for nodes
+      representing a single performance domain and 1 for nodes providing
+      multiple performance domains (e.g. performance controllers), but can be
+      any value as specified by device tree binding documentation of particular
+      provider.
+    enum: [ 0, 1 ]
+
+required:
+  - compatible
+  - reg
+  - "#performance-domain-cells"
+
+additionalProperties: true
+
+examples:
+  - |
+    cpus {
+            #address-cells = <1>;
+            #size-cells = <0>;
+
+            cpu0: cpu@0 {
+                device_type = "cpu";
+                compatible = "arm,cortex-a55";
+                enable-method = "psci";
+                performance-domains = <&performance 0>;
+                reg = <0x000>;
+            };
+
+            cpu1: cpu@100 {
+                device_type = "cpu";
+                compatible = "arm,cortex-a55";
+                enable-method = "psci";
+                performance-domains = <&performance 0>;
+                reg = <0x100>;
+            };
+
+            cpu2: cpu@200 {
+                device_type = "cpu";
+                compatible = "arm,cortex-a55";
+                enable-method = "psci";
+                performance-domains = <&performance 0>;
+                reg = <0x200>;
+            };
+
+            cpu3: cpu@300 {
+                device_type = "cpu";
+                compatible = "arm,cortex-a55";
+                enable-method = "psci";
+                performance-domains = <&performance 0>;
+                reg = <0x300>;
+            };
+
+            cpu4: cpu@400 {
+                device_type = "cpu";
+                compatible = "arm,cortex-a55";
+                enable-method = "psci";
+                performance-domains = <&performance 1>;
+                reg = <0x400>;
+            };
+
+            cpu5: cpu@500 {
+                device_type = "cpu";
+                compatible = "arm,cortex-a55";
+                enable-method = "psci";
+                performance-domains = <&performance 1>;
+                reg = <0x500>;
+            };
+
+            cpu6: cpu@600 {
+                device_type = "cpu";
+                compatible = "arm,cortex-a75";
+                enable-method = "psci";
+                performance-domains = <&performance 1>;
+                reg = <0x600>;
+            };
+
+            cpu7: cpu@700 {
+                device_type = "cpu";
+                compatible = "arm,cortex-a75";
+                enable-method = "psci";
+                performance-domains = <&performance 1>;
+                reg = <0x700>;
+            };
+    };
+
+    /* ... */
+
+    soc {
+        #address-cells = <2>;
+        #size-cells = <2>;
+
+        performance: performance-controller@11bc00 {
+            compatible = "mediatek,cpufreq-hw";
+            reg = <0 0x0011bc10 0 0x120>, <0 0x0011bd30 0 0x120>;
+
+            #performance-domain-cells = <1>;
+        };
+    };
diff --git a/Documentation/devicetree/bindings/display/mediatek/mediatek,aal.yaml b/Documentation/devicetree/bindings/display/mediatek/mediatek,aal.yaml
new file mode 100644
index 0000000000000000000000000000000000000000..1599184a4dd1f1e9dbe25dfc07d86ba6d65f4c04
--- /dev/null
+++ b/Documentation/devicetree/bindings/display/mediatek/mediatek,aal.yaml
@@ -0,0 +1,76 @@
+# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/display/mediatek/mediatek,aal.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: mediatek display adaptive ambient light processor
+
+maintainers:
+  - Chun-Kuang Hu <chunkuang.hu@kernel.org>
+  - Philipp Zabel <p.zabel@pengutronix.de>
+
+description: |
+  The mediatek display adaptive ambient light processor, namely AAL,
+  is responsible for backlight power saving and sunlight visibility improving.
+  AAL device node must be siblings to the central MMSYS_CONFIG node.
+  For a description of the MMSYS_CONFIG binding, see
+  Documentation/devicetree/bindings/arm/mediatek/mediatek,mmsys.yaml for details.
+
+properties:
+  compatible:
+    oneOf:
+      - items:
+          - const: mediatek,mt8173-disp-aal
+      - items:
+          - enum:
+              - mediatek,mt2712-disp-aal
+              - mediatek,mt8183-disp-aal
+              - mediatek,mt8195-disp-aal
+          - enum:
+              - mediatek,mt8173-disp-aal
+
+  reg:
+    maxItems: 1
+
+  interrupts:
+    maxItems: 1
+
+  power-domains:
+    description: A phandle and PM domain specifier as defined by bindings of
+      the power controller specified by phandle. See
+      Documentation/devicetree/bindings/power/power-domain.yaml for details.
+
+  clocks:
+    items:
+      - description: AAL Clock
+
+  mediatek,gce-client-reg:
+    description:
+      The register of client driver can be configured by gce with 4 arguments defined
+      in this property, such as phandle of gce, subsys id, register offset and size.
+      Each subsys id is mapping to a base address of display function blocks register
+      which is defined in the gce header include/include/dt-bindings/gce/<chip>-gce.h.
+    $ref: /schemas/types.yaml#/definitions/phandle-array
+    maxItems: 1
+
+required:
+  - compatible
+  - reg
+  - interrupts
+  - power-domains
+  - clocks
+
+additionalProperties: false
+
+examples:
+  - |
+
+    aal@14015000 {
+        compatible = "mediatek,mt8173-disp-aal";
+        reg = <0 0x14015000 0 0x1000>;
+        interrupts = <GIC_SPI 189 IRQ_TYPE_LEVEL_LOW>;
+        power-domains = <&scpsys MT8173_POWER_DOMAIN_MM>;
+        clocks = <&mmsys CLK_MM_DISP_AAL>;
+        mediatek,gce-client-reg = <&gce SUBSYS_1401XXXX 0x5000 0x1000>;
+    };
diff --git a/Documentation/devicetree/bindings/display/mediatek/mediatek,ccorr.yaml b/Documentation/devicetree/bindings/display/mediatek/mediatek,ccorr.yaml
new file mode 100644
index 0000000000000000000000000000000000000000..f9b697604ab9fad037757fe074df342d2cb462a5
--- /dev/null
+++ b/Documentation/devicetree/bindings/display/mediatek/mediatek,ccorr.yaml
@@ -0,0 +1,71 @@
+# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/display/mediatek/mediatek,ccorr.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: mediatek Ddsplay color correction
+
+maintainers:
+  - Chun-Kuang Hu <chunkuang.hu@kernel.org>
+  - Philipp Zabel <p.zabel@pengutronix.de>
+
+description: |
+  The mediatek display color correction, namely CCORR, reproduces correct color
+  on panels with different color gamut.
+  CCORR device node must be siblings to the central MMSYS_CONFIG node.
+  For a description of the MMSYS_CONFIG binding, see
+  Documentation/devicetree/bindings/arm/mediatek/mediatek,mmsys.yaml for details.
+
+properties:
+  compatible:
+    oneOf:
+      - items:
+          - const: mediatek,mt8183-disp-ccorr
+      - items:
+          - const: mediatek,mt8195-disp-ccorr
+
+  reg:
+    maxItems: 1
+
+  interrupts:
+    maxItems: 1
+
+  power-domains:
+    description: A phandle and PM domain specifier as defined by bindings of
+      the power controller specified by phandle. See
+      Documentation/devicetree/bindings/power/power-domain.yaml for details.
+
+  clocks:
+    items:
+      - description: CCORR Clock
+
+  mediatek,gce-client-reg:
+    description:
+      The register of client driver can be configured by gce with 4 arguments defined
+      in this property, such as phandle of gce, subsys id, register offset and size.
+      Each subsys id is mapping to a base address of display function blocks register
+      which is defined in the gce header include/include/dt-bindings/gce/<chip>-gce.h.
+    $ref: /schemas/types.yaml#/definitions/phandle-array
+    maxItems: 1
+
+required:
+  - compatible
+  - reg
+  - interrupts
+  - power-domains
+  - clocks
+
+additionalProperties: false
+
+examples:
+  - |
+
+    ccorr0: ccorr@1400f000 {
+        compatible = "mediatek,mt8183-disp-ccorr";
+        reg = <0 0x1400f000 0 0x1000>;
+        interrupts = <GIC_SPI 232 IRQ_TYPE_LEVEL_LOW>;
+        power-domains = <&spm MT8183_POWER_DOMAIN_DISP>;
+        clocks = <&mmsys CLK_MM_DISP_CCORR0>;
+        mediatek,gce-client-reg = <&gce SUBSYS_1400XXXX 0xf000 0x1000>;
+    };
diff --git a/Documentation/devicetree/bindings/display/mediatek/mediatek,color.yaml b/Documentation/devicetree/bindings/display/mediatek/mediatek,color.yaml
new file mode 100644
index 0000000000000000000000000000000000000000..563755095a4f73725378a9ff45dfdaf846a6638e
--- /dev/null
+++ b/Documentation/devicetree/bindings/display/mediatek/mediatek,color.yaml
@@ -0,0 +1,85 @@
+# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/display/mediatek/mediatek,color.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: mediatek display color processor
+
+maintainers:
+  - Chun-Kuang Hu <chunkuang.hu@kernel.org>
+  - Philipp Zabel <p.zabel@pengutronix.de>
+
+description: |
+  The mediatek color processor, namely COLOR, provides hue, luma and
+  saturation adjustments to get better picture quality and to have one panel
+  resemble the other in their output characteristics.
+  COLOR device node must be siblings to the central MMSYS_CONFIG node.
+  For a description of the MMSYS_CONFIG binding, see
+  Documentation/devicetree/bindings/arm/mediatek/mediatek,mmsys.yaml for details.
+
+properties:
+  compatible:
+    oneOf:
+      - items:
+          - const: mediatek,mt2701-disp-color
+      - items:
+          - const: mediatek,mt8167-disp-color
+      - items:
+          - const: mediatek,mt8173-disp-color
+      - items:
+          - enum:
+              - mediatek,mt7623-disp-color
+              - mediatek,mt2712-disp-color
+          - enum:
+              - mediatek,mt2701-disp-color
+      - items:
+          - enum:
+              - mediatek,mt8183-disp-color
+              - mediatek,mt8195-disp-color
+          - enum:
+              - mediatek,mt8173-disp-color
+  reg:
+    maxItems: 1
+
+  interrupts:
+    maxItems: 1
+
+  power-domains:
+    description: A phandle and PM domain specifier as defined by bindings of
+      the power controller specified by phandle. See
+      Documentation/devicetree/bindings/power/power-domain.yaml for details.
+
+  clocks:
+    items:
+      - description: COLOR Clock
+
+  mediatek,gce-client-reg:
+    description:
+      The register of client driver can be configured by gce with 4 arguments defined
+      in this property, such as phandle of gce, subsys id, register offset and size.
+      Each subsys id is mapping to a base address of display function blocks register
+      which is defined in the gce header include/include/dt-bindings/gce/<chip>-gce.h.
+    $ref: /schemas/types.yaml#/definitions/phandle-array
+    maxItems: 1
+
+required:
+  - compatible
+  - reg
+  - interrupts
+  - power-domains
+  - clocks
+
+additionalProperties: false
+
+examples:
+  - |
+
+    color0: color@14013000 {
+        compatible = "mediatek,mt8173-disp-color";
+        reg = <0 0x14013000 0 0x1000>;
+        interrupts = <GIC_SPI 187 IRQ_TYPE_LEVEL_LOW>;
+        power-domains = <&scpsys MT8173_POWER_DOMAIN_MM>;
+        clocks = <&mmsys CLK_MM_DISP_COLOR0>;
+        mediatek,gce-client-reg = <&gce SUBSYS_1401XXXX 0x3000 0x1000>;
+    };
diff --git a/Documentation/devicetree/bindings/display/mediatek/mediatek,disp.txt b/Documentation/devicetree/bindings/display/mediatek/mediatek,disp.txt
deleted file mode 100644
index 1dff7a05e6e386bd2d48f9cfc5f3a96cd041c244..0000000000000000000000000000000000000000
--- a/Documentation/devicetree/bindings/display/mediatek/mediatek,disp.txt
+++ /dev/null
@@ -1,210 +0,0 @@
-Mediatek display subsystem
-==========================
-
-The Mediatek display subsystem consists of various DISP function blocks in the
-MMSYS register space. The connections between them can be configured by output
-and input selectors in the MMSYS_CONFIG register space. Pixel clock and start
-of frame signal are distributed to the other function blocks by a DISP_MUTEX
-function block.
-
-All DISP device tree nodes must be siblings to the central MMSYS_CONFIG node.
-For a description of the MMSYS_CONFIG binding, see
-Documentation/devicetree/bindings/arm/mediatek/mediatek,mmsys.txt.
-
-DISP function blocks
-====================
-
-A display stream starts at a source function block that reads pixel data from
-memory and ends with a sink function block that drives pixels on a display
-interface, or writes pixels back to memory. All DISP function blocks have
-their own register space, interrupt, and clock gate. The blocks that can
-access memory additionally have to list the IOMMU and local arbiter they are
-connected to.
-
-For a description of the display interface sink function blocks, see
-Documentation/devicetree/bindings/display/mediatek/mediatek,dsi.txt and
-Documentation/devicetree/bindings/display/mediatek/mediatek,dpi.txt.
-
-Required properties (all function blocks):
-- compatible: "mediatek,<chip>-disp-<function>", one of
-	"mediatek,<chip>-disp-ovl"   		- overlay (4 layers, blending, csc)
-	"mediatek,<chip>-disp-ovl-2l"           - overlay (2 layers, blending, csc)
-	"mediatek,<chip>-disp-rdma"  		- read DMA / line buffer
-	"mediatek,<chip>-disp-wdma"  		- write DMA
-	"mediatek,<chip>-disp-ccorr"            - color correction
-	"mediatek,<chip>-disp-color" 		- color processor
-	"mediatek,<chip>-disp-dither"           - dither
-	"mediatek,<chip>-disp-aal"   		- adaptive ambient light controller
-	"mediatek,<chip>-disp-gamma" 		- gamma correction
-	"mediatek,<chip>-disp-merge" 		- merge streams from two RDMA sources
-	"mediatek,<chip>-disp-postmask" 	- control round corner for display frame
-	"mediatek,<chip>-disp-split" 		- split stream to two encoders
-	"mediatek,<chip>-disp-ufoe"  		- data compression engine
-	"mediatek,<chip>-dsi"        		- DSI controller, see mediatek,dsi.txt
-	"mediatek,<chip>-dpi"        		- DPI controller, see mediatek,dpi.txt
-	"mediatek,<chip>-disp-mutex" 		- display mutex
-	"mediatek,<chip>-disp-od"    		- overdrive
-  the supported chips are mt2701, mt7623, mt2712, mt8167, mt8173, mt8183 and mt8192.
-- reg: Physical base address and length of the function block register space
-- interrupts: The interrupt signal from the function block (required, except for
-  merge and split function blocks).
-- clocks: device clocks
-  See Documentation/devicetree/bindings/clock/clock-bindings.txt for details.
-  For most function blocks this is just a single clock input. Only the DSI and
-  DPI controller nodes have multiple clock inputs. These are documented in
-  mediatek,dsi.txt and mediatek,dpi.txt, respectively.
-  An exception is that the mt8183 mutex is always free running with no clocks property.
-
-Required properties (DMA function blocks):
-- compatible: Should be one of
-	"mediatek,<chip>-disp-ovl"
-	"mediatek,<chip>-disp-rdma"
-	"mediatek,<chip>-disp-wdma"
-  the supported chips are mt2701, mt8167 and mt8173.
-- iommus: Should point to the respective IOMMU block with master port as
-  argument, see Documentation/devicetree/bindings/iommu/mediatek,iommu.yaml
-  for details.
-
-Optional properties (RDMA function blocks):
-- mediatek,rdma-fifo-size: rdma fifo size may be different even in same SOC, add this
-  property to the corresponding rdma
-  the value is the Max value which defined in hardware data sheet.
-  mediatek,rdma-fifo-size of mt8173-rdma0 is 8K
-  mediatek,rdma-fifo-size of mt8183-rdma0 is 5K
-  mediatek,rdma-fifo-size of mt8183-rdma1 is 2K
-
-Examples:
-
-mmsys: clock-controller@14000000 {
-	compatible = "mediatek,mt8173-mmsys", "syscon";
-	reg = <0 0x14000000 0 0x1000>;
-	power-domains = <&scpsys MT8173_POWER_DOMAIN_MM>;
-	#clock-cells = <1>;
-};
-
-ovl0: ovl@1400c000 {
-	compatible = "mediatek,mt8173-disp-ovl";
-	reg = <0 0x1400c000 0 0x1000>;
-	interrupts = <GIC_SPI 180 IRQ_TYPE_LEVEL_LOW>;
-	power-domains = <&scpsys MT8173_POWER_DOMAIN_MM>;
-	clocks = <&mmsys CLK_MM_DISP_OVL0>;
-	iommus = <&iommu M4U_PORT_DISP_OVL0>;
-};
-
-ovl1: ovl@1400d000 {
-	compatible = "mediatek,mt8173-disp-ovl";
-	reg = <0 0x1400d000 0 0x1000>;
-	interrupts = <GIC_SPI 181 IRQ_TYPE_LEVEL_LOW>;
-	power-domains = <&scpsys MT8173_POWER_DOMAIN_MM>;
-	clocks = <&mmsys CLK_MM_DISP_OVL1>;
-	iommus = <&iommu M4U_PORT_DISP_OVL1>;
-};
-
-rdma0: rdma@1400e000 {
-	compatible = "mediatek,mt8173-disp-rdma";
-	reg = <0 0x1400e000 0 0x1000>;
-	interrupts = <GIC_SPI 182 IRQ_TYPE_LEVEL_LOW>;
-	power-domains = <&scpsys MT8173_POWER_DOMAIN_MM>;
-	clocks = <&mmsys CLK_MM_DISP_RDMA0>;
-	iommus = <&iommu M4U_PORT_DISP_RDMA0>;
-	mediatek,rdma-fifosize = <8192>;
-};
-
-rdma1: rdma@1400f000 {
-	compatible = "mediatek,mt8173-disp-rdma";
-	reg = <0 0x1400f000 0 0x1000>;
-	interrupts = <GIC_SPI 183 IRQ_TYPE_LEVEL_LOW>;
-	power-domains = <&scpsys MT8173_POWER_DOMAIN_MM>;
-	clocks = <&mmsys CLK_MM_DISP_RDMA1>;
-	iommus = <&iommu M4U_PORT_DISP_RDMA1>;
-};
-
-rdma2: rdma@14010000 {
-	compatible = "mediatek,mt8173-disp-rdma";
-	reg = <0 0x14010000 0 0x1000>;
-	interrupts = <GIC_SPI 184 IRQ_TYPE_LEVEL_LOW>;
-	power-domains = <&scpsys MT8173_POWER_DOMAIN_MM>;
-	clocks = <&mmsys CLK_MM_DISP_RDMA2>;
-	iommus = <&iommu M4U_PORT_DISP_RDMA2>;
-};
-
-wdma0: wdma@14011000 {
-	compatible = "mediatek,mt8173-disp-wdma";
-	reg = <0 0x14011000 0 0x1000>;
-	interrupts = <GIC_SPI 185 IRQ_TYPE_LEVEL_LOW>;
-	power-domains = <&scpsys MT8173_POWER_DOMAIN_MM>;
-	clocks = <&mmsys CLK_MM_DISP_WDMA0>;
-	iommus = <&iommu M4U_PORT_DISP_WDMA0>;
-};
-
-wdma1: wdma@14012000 {
-	compatible = "mediatek,mt8173-disp-wdma";
-	reg = <0 0x14012000 0 0x1000>;
-	interrupts = <GIC_SPI 186 IRQ_TYPE_LEVEL_LOW>;
-	power-domains = <&scpsys MT8173_POWER_DOMAIN_MM>;
-	clocks = <&mmsys CLK_MM_DISP_WDMA1>;
-	iommus = <&iommu M4U_PORT_DISP_WDMA1>;
-};
-
-color0: color@14013000 {
-	compatible = "mediatek,mt8173-disp-color";
-	reg = <0 0x14013000 0 0x1000>;
-	interrupts = <GIC_SPI 187 IRQ_TYPE_LEVEL_LOW>;
-	power-domains = <&scpsys MT8173_POWER_DOMAIN_MM>;
-	clocks = <&mmsys CLK_MM_DISP_COLOR0>;
-};
-
-color1: color@14014000 {
-	compatible = "mediatek,mt8173-disp-color";
-	reg = <0 0x14014000 0 0x1000>;
-	interrupts = <GIC_SPI 188 IRQ_TYPE_LEVEL_LOW>;
-	power-domains = <&scpsys MT8173_POWER_DOMAIN_MM>;
-	clocks = <&mmsys CLK_MM_DISP_COLOR1>;
-};
-
-aal@14015000 {
-	compatible = "mediatek,mt8173-disp-aal";
-	reg = <0 0x14015000 0 0x1000>;
-	interrupts = <GIC_SPI 189 IRQ_TYPE_LEVEL_LOW>;
-	power-domains = <&scpsys MT8173_POWER_DOMAIN_MM>;
-	clocks = <&mmsys CLK_MM_DISP_AAL>;
-};
-
-gamma@14016000 {
-	compatible = "mediatek,mt8173-disp-gamma";
-	reg = <0 0x14016000 0 0x1000>;
-	interrupts = <GIC_SPI 190 IRQ_TYPE_LEVEL_LOW>;
-	power-domains = <&scpsys MT8173_POWER_DOMAIN_MM>;
-	clocks = <&mmsys CLK_MM_DISP_GAMMA>;
-};
-
-ufoe@1401a000 {
-	compatible = "mediatek,mt8173-disp-ufoe";
-	reg = <0 0x1401a000 0 0x1000>;
-	interrupts = <GIC_SPI 191 IRQ_TYPE_LEVEL_LOW>;
-	power-domains = <&scpsys MT8173_POWER_DOMAIN_MM>;
-	clocks = <&mmsys CLK_MM_DISP_UFOE>;
-};
-
-dsi0: dsi@1401b000 {
-	/* See mediatek,dsi.txt for details */
-};
-
-dpi0: dpi@1401d000 {
-	/* See mediatek,dpi.txt for details */
-};
-
-mutex: mutex@14020000 {
-	compatible = "mediatek,mt8173-disp-mutex";
-	reg = <0 0x14020000 0 0x1000>;
-	interrupts = <GIC_SPI 169 IRQ_TYPE_LEVEL_LOW>;
-	power-domains = <&scpsys MT8173_POWER_DOMAIN_MM>;
-	clocks = <&mmsys CLK_MM_MUTEX_32K>;
-};
-
-od@14023000 {
-	compatible = "mediatek,mt8173-disp-od";
-	reg = <0 0x14023000 0 0x1000>;
-	power-domains = <&scpsys MT8173_POWER_DOMAIN_MM>;
-	clocks = <&mmsys CLK_MM_DISP_OD>;
-};
diff --git a/Documentation/devicetree/bindings/display/mediatek/mediatek,dither.yaml b/Documentation/devicetree/bindings/display/mediatek/mediatek,dither.yaml
new file mode 100644
index 0000000000000000000000000000000000000000..b6f57243270c4fef3fc4ee5dd65b8a48fc9a1ddb
--- /dev/null
+++ b/Documentation/devicetree/bindings/display/mediatek/mediatek,dither.yaml
@@ -0,0 +1,75 @@
+# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/display/mediatek/mediatek,dither.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: mediatek display dither processor
+
+maintainers:
+  - Chun-Kuang Hu <chunkuang.hu@kernel.org>
+  - Philipp Zabel <p.zabel@pengutronix.de>
+
+description: |
+  The mediatek display dither processor, namely DITHER, works by approximating
+  unavailable colors with available colors and by mixing and matching available
+  colors to mimic unavailable ones.
+  DITHER device node must be siblings to the central MMSYS_CONFIG node.
+  For a description of the MMSYS_CONFIG binding, see
+  Documentation/devicetree/bindings/arm/mediatek/mediatek,mmsys.yaml for details.
+
+properties:
+  compatible:
+    oneOf:
+      - items:
+          - const: mediatek,mt8183-disp-dither
+      - items:
+          - enum:
+              - mediatek,mt8195-disp-dither
+          - enum:
+              - mediatek,mt8183-disp-dither
+
+  reg:
+    maxItems: 1
+
+  interrupts:
+    maxItems: 1
+
+  power-domains:
+    description: A phandle and PM domain specifier as defined by bindings of
+      the power controller specified by phandle. See
+      Documentation/devicetree/bindings/power/power-domain.yaml for details.
+
+  clocks:
+    items:
+      - description: DITHER Clock
+
+  mediatek,gce-client-reg:
+    description:
+      The register of client driver can be configured by gce with 4 arguments defined
+      in this property, such as phandle of gce, subsys id, register offset and size.
+      Each subsys id is mapping to a base address of display function blocks register
+      which is defined in the gce header include/include/dt-bindings/gce/<chip>-gce.h.
+    $ref: /schemas/types.yaml#/definitions/phandle-array
+    maxItems: 1
+
+required:
+  - compatible
+  - reg
+  - interrupts
+  - power-domains
+  - clocks
+
+additionalProperties: false
+
+examples:
+  - |
+
+    dither0: dither@14012000 {
+        compatible = "mediatek,mt8183-disp-dither";
+        reg = <0 0x14012000 0 0x1000>;
+        interrupts = <GIC_SPI 235 IRQ_TYPE_LEVEL_LOW>;
+        power-domains = <&spm MT8183_POWER_DOMAIN_DISP>;
+        clocks = <&mmsys CLK_MM_DISP_DITHER0>;
+        mediatek,gce-client-reg = <&gce SUBSYS_1401XXXX 0x2000 0x1000>;
+    };
diff --git a/Documentation/devicetree/bindings/display/mediatek/mediatek,dsc.yaml b/Documentation/devicetree/bindings/display/mediatek/mediatek,dsc.yaml
new file mode 100644
index 0000000000000000000000000000000000000000..f26e3010d5f44ae74f8cde4ee55ff4239be1accf
--- /dev/null
+++ b/Documentation/devicetree/bindings/display/mediatek/mediatek,dsc.yaml
@@ -0,0 +1,70 @@
+# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/display/mediatek/mediatek,dsc.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: mediatek display DSC controller
+
+maintainers:
+  - Chun-Kuang Hu <chunkuang.hu@kernel.org>
+  - Philipp Zabel <p.zabel@pengutronix.de>
+
+description: |
+  The DSC standard is a specification of the algorithms used for
+  compressing and decompressing image display streams, including
+  the specification of the syntax and semantics of the compressed
+  video bit stream. DSC is designed for real-time systems with
+  real-time compression, transmission, decompression and Display.
+
+properties:
+  compatible:
+    oneOf:
+      - items:
+          - const: mediatek,mt8195-disp-dsc
+
+  reg:
+    maxItems: 1
+
+  interrupts:
+    maxItems: 1
+
+  clocks:
+    items:
+      - description: DSC Wrapper Clock
+
+  power-domains:
+    description: A phandle and PM domain specifier as defined by bindings of
+      the power controller specified by phandle. See
+      Documentation/devicetree/bindings/power/power-domain.yaml for details.
+
+
+  mediatek,gce-client-reg:
+    description:
+      The register of client driver can be configured by gce with 4 arguments defined
+      in this property, such as phandle of gce, subsys id, register offset and size.
+      Each subsys id is mapping to a base address of display function blocks register
+      which is defined in the gce header include/include/dt-bindings/gce/<chip>-gce.h.
+    $ref: /schemas/types.yaml#/definitions/phandle-array
+    maxItems: 1
+
+required:
+  - compatible
+  - reg
+  - interrupts
+  - power-domains
+  - clocks
+
+additionalProperties: false
+
+examples:
+  - |
+
+    dsc0: disp_dsc_wrap@1c009000 {
+        compatible = "mediatek,mt8195-disp-dsc";
+        reg = <0 0x1c009000 0 0x1000>;
+        interrupts = <GIC_SPI 645 IRQ_TYPE_LEVEL_HIGH 0>;
+        power-domains = <&spm MT8195_POWER_DOMAIN_VDOSYS0>;
+        clocks = <&vdosys0 CLK_VDO0_DSC_WRAP0>;
+        mediatek,gce-client-reg = <&gce1 SUBSYS_1c00XXXX 0x9000 0x1000>;
+    };
diff --git a/Documentation/devicetree/bindings/display/mediatek/mediatek,ethdr.yaml b/Documentation/devicetree/bindings/display/mediatek/mediatek,ethdr.yaml
new file mode 100644
index 0000000000000000000000000000000000000000..64d5349cdf8f4e4a1e26a01d189076ce734b820d
--- /dev/null
+++ b/Documentation/devicetree/bindings/display/mediatek/mediatek,ethdr.yaml
@@ -0,0 +1,144 @@
+# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/display/mediatek/mediatek,ethdr.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: mediatek ethdr Device Tree Bindings
+
+maintainers:
+  - CK Hu <ck.hu@mediatek.com>
+  - Nancy.Lin <nancy.lin@mediatek.com>
+
+description: |
+  ETHDR is designed for HDR video and graphics conversion in the external display path.
+  It handles multiple HDR input types and performs tone mapping, color space/color
+  format conversion, and then combine different layers, output the required HDR or
+  SDR signal to the subsequent display path. This engine is composed of two video
+  frontends, two graphic frontends, one video backend and a mixer.
+
+properties:
+  compatible:
+    items:
+      - const: mediatek,mt8195-disp-ethdr
+  reg:
+    maxItems: 7
+  reg-names:
+    items:
+      - const: mixer
+      - const: vdo_fe0
+      - const: vdo_fe1
+      - const: gfx_fe0
+      - const: gfx_fe1
+      - const: vdo_be
+      - const: adl_ds
+  interrupts:
+    minItems: 1
+  iommus:
+    description: The compatible property is DMA function blocks.
+      Should point to the respective IOMMU block with master port as argument,
+      see Documentation/devicetree/bindings/iommu/mediatek,iommu.yaml for
+      details.
+    minItems: 1
+    maxItems: 2
+  clocks:
+    items:
+      - description: mixer clock
+      - description: video frontend 0 clock
+      - description: video frontend 1 clock
+      - description: graphic frontend 0 clock
+      - description: graphic frontend 1 clock
+      - description: video backend clock
+      - description: autodownload and menuload clock
+      - description: video frontend 0 async clock
+      - description: video frontend 1 async clock
+      - description: graphic frontend 0 async clock
+      - description: graphic frontend 1 async clock
+      - description: video backend async clock
+      - description: ethdr top clock
+  clock-names:
+    items:
+      - const: mixer
+      - const: vdo_fe0
+      - const: vdo_fe1
+      - const: gfx_fe0
+      - const: gfx_fe1
+      - const: vdo_be
+      - const: adl_ds
+      - const: vdo_fe0_async
+      - const: vdo_fe1_async
+      - const: gfx_fe0_async
+      - const: gfx_fe1_async
+      - const: vdo_be_async
+      - const: ethdr_top
+  power-domains:
+    maxItems: 1
+  resets:
+    maxItems: 5
+  mediatek,gce-client-reg:
+    $ref: /schemas/types.yaml#/definitions/phandle-array
+    description: The register of display function block to be set by gce.
+      There are 4 arguments in this property, gce node, subsys id, offset and
+      register size. The subsys id is defined in the gce header of each chips
+      include/include/dt-bindings/gce/<chip>-gce.h, mapping to the register of
+      display function block.
+
+required:
+  - compatible
+  - reg
+  - clocks
+  - clock-names
+  - interrupts
+
+additionalProperties: false
+
+examples:
+  - |
+
+    disp_ethdr@1c114000 {
+            compatible = "mediatek,mt8195-disp-ethdr";
+            reg = <0 0x1c114000 0 0x1000>,
+                  <0 0x1c115000 0 0x1000>,
+                  <0 0x1c117000 0 0x1000>,
+                  <0 0x1c119000 0 0x1000>,
+                  <0 0x1c11A000 0 0x1000>,
+                  <0 0x1c11B000 0 0x1000>,
+                  <0 0x1c11C000 0 0x1000>;
+            reg-names = "mixer", "vdo_fe0", "vdo_fe1", "gfx_fe0", "gfx_fe1",
+                        "vdo_be", "adl_ds";
+            mediatek,gce-client-reg = <&gce1 SUBSYS_1c11XXXX 0x4000 0x1000>,
+                                      <&gce1 SUBSYS_1c11XXXX 0x5000 0x1000>,
+                                      <&gce1 SUBSYS_1c11XXXX 0x7000 0x1000>,
+                                      <&gce1 SUBSYS_1c11XXXX 0x9000 0x1000>,
+                                      <&gce1 SUBSYS_1c11XXXX 0xA000 0x1000>,
+                                      <&gce1 SUBSYS_1c11XXXX 0xB000 0x1000>,
+                                      <&gce1 SUBSYS_1c11XXXX 0xC000 0x1000>;
+            clocks = <&vdosys1 CLK_VDO1_DISP_MIXER>,
+                     <&vdosys1 CLK_VDO1_HDR_VDO_FE0>,
+                     <&vdosys1 CLK_VDO1_HDR_VDO_FE1>,
+                     <&vdosys1 CLK_VDO1_HDR_GFX_FE0>,
+                     <&vdosys1 CLK_VDO1_HDR_GFX_FE1>,
+                     <&vdosys1 CLK_VDO1_HDR_VDO_BE>,
+                     <&vdosys1 CLK_VDO1_26M_SLOW>,
+                     <&vdosys1 CLK_VDO1_HDR_VDO_FE0_DL_ASYNC>,
+                     <&vdosys1 CLK_VDO1_HDR_VDO_FE1_DL_ASYNC>,
+                     <&vdosys1 CLK_VDO1_HDR_GFX_FE0_DL_ASYNC>,
+                     <&vdosys1 CLK_VDO1_HDR_GFX_FE1_DL_ASYNC>,
+                     <&vdosys1 CLK_VDO1_HDR_VDO_BE_DL_ASYNC>,
+                     <&topckgen CLK_TOP_ETHDR_SEL>;
+            clock-names = "mixer", "vdo_fe0", "vdo_fe1", "gfx_fe0", "gfx_fe1",
+                          "vdo_be", "adl_ds", "vdo_fe0_async", "vdo_fe1_async",
+                          "gfx_fe0_async", "gfx_fe1_async","vdo_be_async",
+                          "ethdr_top";
+            power-domains = <&spm MT8195_POWER_DOMAIN_VDOSYS1>;
+            iommus = <&iommu_vpp M4U_PORT_L3_HDR_DS>,
+                     <&iommu_vpp M4U_PORT_L3_HDR_ADL>;
+            interrupts = <GIC_SPI 517 IRQ_TYPE_LEVEL_HIGH 0>; /* disp mixer */
+            resets = <&vdosys1 MT8195_VDOSYS1_SW1_RST_B_HDR_VDO_FE0_DL_ASYNC>,
+                     <&vdosys1 MT8195_VDOSYS1_SW1_RST_B_HDR_VDO_FE1_DL_ASYNC>,
+                     <&vdosys1 MT8195_VDOSYS1_SW1_RST_B_HDR_GFX_FE0_DL_ASYNC>,
+                     <&vdosys1 MT8195_VDOSYS1_SW1_RST_B_HDR_GFX_FE1_DL_ASYNC>,
+                     <&vdosys1 MT8195_VDOSYS1_SW1_RST_B_HDR_VDO_BE_DL_ASYNC>;
+    };
+
+...
diff --git a/Documentation/devicetree/bindings/display/mediatek/mediatek,gamma.yaml b/Documentation/devicetree/bindings/display/mediatek/mediatek,gamma.yaml
new file mode 100644
index 0000000000000000000000000000000000000000..ab1e18da6bed84bbf20a16bd61083b1dfa2823fb
--- /dev/null
+++ b/Documentation/devicetree/bindings/display/mediatek/mediatek,gamma.yaml
@@ -0,0 +1,76 @@
+# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/display/mediatek/mediatek,gamma.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: mediatek display gamma correction
+
+maintainers:
+  - Chun-Kuang Hu <chunkuang.hu@kernel.org>
+  - Philipp Zabel <p.zabel@pengutronix.de>
+
+description: |
+  The mediatek display gamma correction, namely GAMMA, provides a nonlinear operation
+  used to adjust luminance inÂ display system.
+  GAMMA device node must be siblings to the central MMSYS_CONFIG node.
+  For a description of the MMSYS_CONFIG binding, see
+  Documentation/devicetree/bindings/arm/mediatek/mediatek,mmsys.yaml for details.
+
+properties:
+  compatible:
+    oneOf:
+      - items:
+          - const: mediatek,mt8173-disp-gamma
+      - items:
+          - const: mediatek,mt8183-disp-gamma
+      - items:
+          - enum:
+              - mediatek,mt8195-disp-gamma
+          - enum:
+              - mediatek,mt8183-disp-gamma
+
+  reg:
+    maxItems: 1
+
+  interrupts:
+    maxItems: 1
+
+  power-domains:
+    description: A phandle and PM domain specifier as defined by bindings of
+      the power controller specified by phandle. See
+      Documentation/devicetree/bindings/power/power-domain.yaml for details.
+
+  clocks:
+    items:
+      - description: GAMMA Clock
+
+  mediatek,gce-client-reg:
+    description:
+      The register of client driver can be configured by gce with 4 arguments defined
+      in this property, such as phandle of gce, subsys id, register offset and size.
+      Each subsys id is mapping to a base address of display function blocks register
+      which is defined in the gce header include/include/dt-bindings/gce/<chip>-gce.h.
+    $ref: /schemas/types.yaml#/definitions/phandle-array
+    maxItems: 1
+
+required:
+  - compatible
+  - reg
+  - interrupts
+  - power-domains
+  - clocks
+
+additionalProperties: false
+
+examples:
+  - |
+
+    gamma@14016000 {
+        compatible = "mediatek,mt8173-disp-gamma";
+        reg = <0 0x14016000 0 0x1000>;
+        interrupts = <GIC_SPI 190 IRQ_TYPE_LEVEL_LOW>;
+        power-domains = <&scpsys MT8173_POWER_DOMAIN_MM>;
+        clocks = <&mmsys CLK_MM_DISP_GAMMA>;
+        mediatek,gce-client-reg = <&gce SUBSYS_1401XXXX 0x6000 0x1000>;
+    };
diff --git a/Documentation/devicetree/bindings/display/mediatek/mediatek,mdp-rdma.yaml b/Documentation/devicetree/bindings/display/mediatek/mediatek,mdp-rdma.yaml
new file mode 100644
index 0000000000000000000000000000000000000000..3610093848e10df26a0325aad4e0e2c6b3174cb3
--- /dev/null
+++ b/Documentation/devicetree/bindings/display/mediatek/mediatek,mdp-rdma.yaml
@@ -0,0 +1,77 @@
+# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/display/mediatek/mediatek,mdp-rdma.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: mediatek display MDP RDMA
+
+maintainers:
+  - CK Hu <ck.hu@mediatek.com>
+
+description: |
+  The mediatek display MDP RDMA stands for Read Direct Memory Access.
+  It provides real time data to the back-end panel driver, such as DSI,
+  DPI and DP_INTF.
+  It contains one line buffer to store the sufficient pixel data.
+  RDMA device node must be siblings to the central MMSYS_CONFIG node.
+  For a description of the MMSYS_CONFIG binding, see
+  Documentation/devicetree/bindings/arm/mediatek/mediatek,mmsys.yaml for details.
+
+properties:
+  compatible:
+    oneOf:
+      - items:
+          - const: mediatek,mt8195-vdo1-rdma
+
+  reg:
+    maxItems: 1
+
+  interrupts:
+    maxItems: 1
+
+  power-domains:
+    description: A phandle and PM domain specifier as defined by bindings of
+      the power controller specified by phandle. See
+      Documentation/devicetree/bindings/power/power-domain.yaml for details.
+
+  clocks:
+    items:
+      - description: RDMA Clock
+
+  iommus:
+    description:
+      This property should point to the respective IOMMU block with master port as argument,
+      see Documentation/devicetree/bindings/iommu/mediatek,iommu.yaml for details.
+
+  mediatek,gce-client-reg:
+    description:
+      The register of display function block to be set by gce. There are 4 arguments,
+      such as gce node, subsys id, offset and register size. The subsys id that is
+      mapping to the register of display function blocks is defined in the gce header
+      include/include/dt-bindings/gce/<chip>-gce.h of each chips.
+    $ref: /schemas/types.yaml#/definitions/phandle-array
+    maxItems: 1
+
+required:
+  - compatible
+  - reg
+  - power-domains
+  - clocks
+  - iommus
+
+additionalProperties: false
+
+examples:
+  - |
+
+    vdo1_rdma0: vdo1_rdma@1c104000 {
+        compatible = "mediatek,mt8195-vdo1-rdma";
+        reg = <0 0x1c104000 0 0x1000>;
+        interrupts = <GIC_SPI 495 IRQ_TYPE_LEVEL_HIGH 0>;
+        clocks = <&vdosys1 CLK_VDO1_MDP_RDMA0>;
+        power-domains = <&spm MT8195_POWER_DOMAIN_VDOSYS1>;
+        iommus = <&iommu_vdo M4U_PORT_L2_MDP_RDMA0>;
+        mediatek,gce-client-reg = <&gce1 SUBSYS_1c10XXXX 0x4000 0x1000>;
+    };
+
diff --git a/Documentation/devicetree/bindings/display/mediatek/mediatek,merge.yaml b/Documentation/devicetree/bindings/display/mediatek/mediatek,merge.yaml
new file mode 100644
index 0000000000000000000000000000000000000000..5be3715ddc56235270d8e50c607b2ded82c25807
--- /dev/null
+++ b/Documentation/devicetree/bindings/display/mediatek/mediatek,merge.yaml
@@ -0,0 +1,101 @@
+# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/display/mediatek/mediatek,merge.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: mediatek display merge
+
+maintainers:
+  - Chun-Kuang Hu <chunkuang.hu@kernel.org>
+  - Philipp Zabel <p.zabel@pengutronix.de>
+
+description: |
+  The mediatek display merge engine is used to merge two slice-per-line inputs
+  into one side-by-side output.
+  MERGE device node must be siblings to the central MMSYS_CONFIG node.
+  For a description of the MMSYS_CONFIG binding, see
+  Documentation/devicetree/bindings/arm/mediatek/mediatek,mmsys.yaml for details.
+
+properties:
+  compatible:
+    oneOf:
+      - items:
+          - const: mediatek,mt8173-disp-merge
+      - items:
+          - const: mediatek,mt8195-disp-merge
+
+  reg:
+    maxItems: 1
+
+  interrupts:
+    maxItems: 1
+
+  power-domains:
+    description: A phandle and PM domain specifier as defined by bindings of
+      the power controller specified by phandle. See
+      Documentation/devicetree/bindings/power/power-domain.yaml for details.
+
+  clocks:
+    items:
+      - description: MERGE Clock
+      - description: MERGE Async Clock
+          Controlling the synchronous process between MERGE and other display function
+          blocks cross clock domain.
+
+  mediatek,merge-fifo-en:
+    description:
+      The setting of merge fifo is mainly provided for the display latency buffer.
+      to ensure that the back-end panel display data will not be underrun,
+      a little more data is needed in the fifo. According to the merge fifo settings,
+      when the water level is detected to be insufficient, it will trigger RDMA sending
+      ultra and preulra command to SMI to speed up the data rate.
+    type: boolean
+
+  mediatek,merge-mute:
+    description: Support mute function. Mute the content of merge output.
+    type: boolean
+
+  mediatek,gce-client-reg:
+    description:
+      The register of client driver can be configured by gce with 4 arguments defined
+      in this property, such as phandle of gce, subsys id, register offset and size.
+      Each subsys id is mapping to a base address of display function blocks register
+      which is defined in the gce header include/include/dt-bindings/gce/<chip>-gce.h.
+    $ref: /schemas/types.yaml#/definitions/phandle-array
+    maxItems: 1
+
+  resets:
+    description: reset controller
+      See Documentation/devicetree/bindings/reset/reset.txt for details.
+
+required:
+  - compatible
+  - reg
+  - power-domains
+  - clocks
+
+additionalProperties: false
+
+examples:
+  - |
+
+    merge@14017000 {
+        compatible = "mediatek,mt8173-disp-merge";
+        reg = <0 0x14017000 0 0x1000>;
+        power-domains = <&spm MT8173_POWER_DOMAIN_MM>;
+        clocks = <&mmsys CLK_MM_DISP_MERGE>;
+    };
+
+    merge5: disp_vpp_merge5@1c110000 {
+        compatible = "mediatek,mt8195-disp-merge";
+        reg = <0 0x1c110000 0 0x1000>;
+        interrupts = <GIC_SPI 507 IRQ_TYPE_LEVEL_HIGH 0>;
+        clocks = <&vdosys1 CLK_VDO1_VPP_MERGE4>,
+                 <&vdosys1 CLK_VDO1_MERGE4_DL_ASYNC>;
+        clock-names = "merge","merge_async";
+        power-domains = <&spm MT8195_POWER_DOMAIN_VDOSYS1>;
+        mediatek,gce-client-reg = <&gce1 SUBSYS_1c11XXXX 0x0000 0x1000>;
+        mediatek,merge-fifo-en = <1>;
+        resets = <&vdosys1 MT8195_VDOSYS1_SW0_RST_B_MERGE4_DL_ASYNC>;
+    };
diff --git a/Documentation/devicetree/bindings/display/mediatek/mediatek,mutex.yaml b/Documentation/devicetree/bindings/display/mediatek/mediatek,mutex.yaml
new file mode 100644
index 0000000000000000000000000000000000000000..db9db182318d1f68826be80bad05aaa6de6d3c76
--- /dev/null
+++ b/Documentation/devicetree/bindings/display/mediatek/mediatek,mutex.yaml
@@ -0,0 +1,79 @@
+# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/display/mediatek/mediatek,mutex.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: mediatek display mutex
+
+maintainers:
+  - Chun-Kuang Hu <chunkuang.hu@kernel.org>
+  - Philipp Zabel <p.zabel@pengutronix.de>
+
+description: |
+  The mediatek display mutex is used to send the triggers signals called
+  Start Of Frame (SOF)/ Error Of Frame (EOF) to each sub-modules on the
+  display data path.
+  MUTEX device node must be siblings to the central MMSYS_CONFIG node.
+  For a description of the MMSYS_CONFIG binding, see
+  Documentation/devicetree/bindings/arm/mediatek/mediatek,mmsys.yaml for details.
+
+properties:
+  compatible:
+    oneOf:
+      - items:
+          - const: mediatek,mt2701-disp-mutex
+      - items:
+          - const: mediatek,mt2712-disp-mutex
+      - items:
+          - const: mediatek,mt8167-disp-mutex
+      - items:
+          - const: mediatek,mt8173-disp-mutex
+      - items:
+          - const: mediatek,mt8183-disp-mutex
+      - items:
+          - const: mediatek,mt8195-disp-mutex
+
+  reg:
+    maxItems: 1
+
+  interrupts:
+    maxItems: 1
+
+  power-domains:
+    description: A phandle and PM domain specifier as defined by bindings of
+      the power controller specified by phandle. See
+      Documentation/devicetree/bindings/power/power-domain.yaml for details.
+
+  clocks:
+    items:
+      - description: MUTEX Clock
+
+  mediatek,gce-events:
+    description:
+      The event id which is mapping to the specific hardware event signal to gce.
+      The event id is defined in the gce header
+      include/include/dt-bindings/gce/<chip>-gce.h of each chips.
+    $ref: /schemas/types.yaml#/definitions/phandle-array
+
+required:
+  - compatible
+  - reg
+  - interrupts
+  - power-domains
+  - clocks
+
+additionalProperties: false
+
+examples:
+  - |
+
+    mutex: mutex@14020000 {
+        compatible = "mediatek,mt8173-disp-mutex";
+        reg = <0 0x14020000 0 0x1000>;
+        interrupts = <GIC_SPI 169 IRQ_TYPE_LEVEL_LOW>;
+        power-domains = <&spm MT8173_POWER_DOMAIN_MM>;
+        clocks = <&mmsys CLK_MM_MUTEX_32K>;
+        mediatek,gce-events = <CMDQ_EVENT_MUTEX0_STREAM_EOF>,
+                              <CMDQ_EVENT_MUTEX1_STREAM_EOF>;
+    };
diff --git a/Documentation/devicetree/bindings/display/mediatek/mediatek,od.yaml b/Documentation/devicetree/bindings/display/mediatek/mediatek,od.yaml
new file mode 100644
index 0000000000000000000000000000000000000000..d2e957cf1c617bbebdc61869c898284c3689b3fc
--- /dev/null
+++ b/Documentation/devicetree/bindings/display/mediatek/mediatek,od.yaml
@@ -0,0 +1,52 @@
+# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/display/mediatek/mediatek,od.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: mediatek display overdirve
+
+maintainers:
+  - Chun-Kuang Hu <chunkuang.hu@kernel.org>
+  - Philipp Zabel <p.zabel@pengutronix.de>
+
+description: |
+  The mediatek display overdrive, namely OD, increases the transition values
+  of pixels between consecutive frames to make LCD rotate faster.
+  OD device node must be siblings to the central MMSYS_CONFIG node.
+  For a description of the MMSYS_CONFIG binding, see
+  Documentation/devicetree/bindings/arm/mediatek/mediatek,mmsys.yaml for details.
+
+properties:
+  compatible:
+    oneOf:
+      - items:
+          - const: mediatek,mt2712-disp-od
+      - items:
+          - const: mediatek,mt8173-disp-od
+
+  reg:
+    maxItems: 1
+
+  interrupts:
+    maxItems: 1
+
+  clocks:
+    items:
+      - description: OVL Clock
+
+required:
+  - compatible
+  - reg
+  - clocks
+
+additionalProperties: false
+
+examples:
+  - |
+
+    od@14023000 {
+        compatible = "mediatek,mt8173-disp-od";
+        reg = <0 0x14023000 0 0x1000>;
+        clocks = <&mmsys CLK_MM_DISP_OD>;
+    };
diff --git a/Documentation/devicetree/bindings/display/mediatek/mediatek,ovl-2l.yaml b/Documentation/devicetree/bindings/display/mediatek/mediatek,ovl-2l.yaml
new file mode 100644
index 0000000000000000000000000000000000000000..60eb29c79b84e132118fe77c21b8f7c77cc63ade
--- /dev/null
+++ b/Documentation/devicetree/bindings/display/mediatek/mediatek,ovl-2l.yaml
@@ -0,0 +1,86 @@
+# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/display/mediatek/mediatek,ovl-2l.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: mediatek display overlay 2 layer
+
+maintainers:
+  - Chun-Kuang Hu <chunkuang.hu@kernel.org>
+  - Philipp Zabel <p.zabel@pengutronix.de>
+
+description: |
+  The mediatek display overlay provides 2 more layer for OVL.
+  OVL-2L device node must be siblings to the central MMSYS_CONFIG node.
+  For a description of the MMSYS_CONFIG binding, see
+  Documentation/devicetree/bindings/arm/mediatek/mediatek,mmsys.yaml
+  for details.
+
+properties:
+  compatible:
+    oneOf:
+      - items:
+          - const: mediatek,mt8183-disp-ovl-2l
+
+  reg:
+    maxItems: 1
+
+  interrupts:
+    maxItems: 1
+
+  power-domains:
+    description: A phandle and PM domain specifier as defined by bindings of
+      the power controller specified by phandle. See
+      Documentation/devicetree/bindings/power/power-domain.yaml for details.
+
+  clocks:
+    items:
+      - description: OVL-2L Clock
+
+  iommus:
+    description:
+      This property should point to the respective IOMMU block with master port as argument,
+      see Documentation/devicetree/bindings/iommu/mediatek,iommu.yaml for details.
+
+  mediatek,larb:
+    description:
+      This property should contain a phandle pointing to the local arbiter deviceas defined in
+      Documentation/devicetree/bindings/memory-controllers/mediatek,smi-larb.yaml.
+      It must sort according to the local arbiter index, like larb0, larb1, larb2...
+    $ref: /schemas/types.yaml#/definitions/phandle-array
+    minItems: 1
+    maxItems: 32
+
+  mediatek,gce-client-reg:
+    description:
+      The register of client driver can be configured by gce with 4 arguments defined
+      in this property, such as phandle of gce, subsys id, register offset and size.
+      Each subsys id is mapping to a base address of display function blocks register
+      which is defined in the gce header include/include/dt-bindings/gce/<chip>-gce.h.
+    $ref: /schemas/types.yaml#/definitions/phandle-array
+    maxItems: 1
+
+required:
+  - compatible
+  - reg
+  - interrupts
+  - power-domains
+  - clocks
+  - iommus
+
+additionalProperties: false
+
+examples:
+  - |
+
+    ovl_2l0: ovl@14009000 {
+        compatible = "mediatek,mt8183-disp-ovl-2l";
+        reg = <0 0x14009000 0 0x1000>;
+        interrupts = <GIC_SPI 226 IRQ_TYPE_LEVEL_LOW>;
+        power-domains = <&spm MT8183_POWER_DOMAIN_DISP>;
+        clocks = <&mmsys CLK_MM_DISP_OVL0_2L>;
+        iommus = <&iommu M4U_PORT_DISP_2L_OVL0_LARB0>;
+        mediatek,larb = <&larb0>;
+        mediatek,gce-client-reg = <&gce SUBSYS_1400XXXX 0x9000 0x1000>;
+    };
diff --git a/Documentation/devicetree/bindings/display/mediatek/mediatek,ovl.yaml b/Documentation/devicetree/bindings/display/mediatek/mediatek,ovl.yaml
new file mode 100644
index 0000000000000000000000000000000000000000..5008f900d81f67b9e185ecc9a89e5b83d56a5463
--- /dev/null
+++ b/Documentation/devicetree/bindings/display/mediatek/mediatek,ovl.yaml
@@ -0,0 +1,101 @@
+# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/display/mediatek/mediatek,ovl.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: mediatek display overlay
+
+maintainers:
+  - Chun-Kuang Hu <chunkuang.hu@kernel.org>
+  - Philipp Zabel <p.zabel@pengutronix.de>
+
+description: |
+  The mediatek display overlay, namely OVL, can do alpha blending from the memory.
+  OVL device node must be siblings to the central MMSYS_CONFIG node.
+  For a description of the MMSYS_CONFIG binding, see
+  Documentation/devicetree/bindings/arm/mediatek/mediatek,mmsys.yaml
+  for details.
+
+properties:
+  compatible:
+    oneOf:
+      - items:
+          - const: mediatek,mt2701-disp-ovl
+      - items:
+          - const: mediatek,mt8173-disp-ovl
+      - items:
+          - const: mediatek,mt8183-disp-ovl
+      - items:
+          - enum:
+              - mediatek,mt7623-disp-ovl
+              - mediatek,mt2712-disp-ovl
+          - enum:
+              - mediatek,mt2701-disp-ovl
+      - items:
+          - enum:
+              - mediatek,mt8195-disp-ovl
+          - enum:
+              - mediatek,mt8183-disp-ovl
+
+  reg:
+    maxItems: 1
+
+  interrupts:
+    maxItems: 1
+
+  power-domains:
+    description: A phandle and PM domain specifier as defined by bindings of
+      the power controller specified by phandle. See
+      Documentation/devicetree/bindings/power/power-domain.yaml for details.
+
+  clocks:
+    items:
+      - description: OVL Clock
+
+  iommus:
+    description:
+      This property should point to the respective IOMMU block with master port as argument,
+      see Documentation/devicetree/bindings/iommu/mediatek,iommu.yaml for details.
+
+  mediatek,larb:
+    description:
+      This property should contain a phandle pointing to the local arbiter deviceas defined in
+      Documentation/devicetree/bindings/memory-controllers/mediatek,smi-larb.yaml.
+      It must sort according to the local arbiter index, like larb0, larb1, larb2...
+    $ref: /schemas/types.yaml#/definitions/phandle-array
+    minItems: 1
+    maxItems: 32
+
+  mediatek,gce-client-reg:
+    description:
+      The register of client driver can be configured by gce with 4 arguments defined
+      in this property, such as phandle of gce, subsys id, register offset and size.
+      Each subsys id is mapping to a base address of display function blocks register
+      which is defined in the gce header include/include/dt-bindings/gce/<chip>-gce.h.
+    $ref: /schemas/types.yaml#/definitions/phandle-array
+    maxItems: 1
+
+required:
+  - compatible
+  - reg
+  - interrupts
+  - power-domains
+  - clocks
+  - iommu
+
+additionalProperties: false
+
+examples:
+  - |
+
+    ovl0: ovl@1400c000 {
+        compatible = "mediatek,mt8173-disp-ovl";
+        reg = <0 0x1400c000 0 0x1000>;
+        interrupts = <GIC_SPI 180 IRQ_TYPE_LEVEL_LOW>;
+        power-domains = <&scpsys MT8173_POWER_DOMAIN_MM>;
+        clocks = <&mmsys CLK_MM_DISP_OVL0>;
+        iommus = <&iommu M4U_PORT_DISP_OVL0>;
+        mediatek,larb = <&larb0>;
+        mediatek,gce-client-reg = <&gce SUBSYS_1400XXXX 0xc000 0x1000>;
+    };
diff --git a/Documentation/devicetree/bindings/display/mediatek/mediatek,rdma.yaml b/Documentation/devicetree/bindings/display/mediatek/mediatek,rdma.yaml
new file mode 100644
index 0000000000000000000000000000000000000000..806437166e3c862d058c9e16037d151f2d670a46
--- /dev/null
+++ b/Documentation/devicetree/bindings/display/mediatek/mediatek,rdma.yaml
@@ -0,0 +1,112 @@
+# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/display/mediatek/mediatek,rdma.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: mediatek display RDMA
+
+maintainers:
+  - Chun-Kuang Hu <chunkuang.hu@kernel.org>
+  - Philipp Zabel <p.zabel@pengutronix.de>
+
+description: |
+  The mediatek display RDMA stands for Read Direct Memory Access.
+  It provides real time data to the back-end panel driver, such as DSI,
+  DPI and DP_INTF.
+  It contains one line buffer to store the sufficient pixel data.
+  RDMA device node must be siblings to the central MMSYS_CONFIG node.
+  For a description of the MMSYS_CONFIG binding, see
+  Documentation/devicetree/bindings/arm/mediatek/mediatek,mmsys.yaml for details.
+
+properties:
+  compatible:
+    oneOf:
+      - items:
+          - const: mediatek,mt2701-disp-rdma
+      - items:
+          - const: mediatek,mt8173-disp-rdma
+      - items:
+          - const: mediatek,mt8183-disp-rdma
+      - items:
+          - const: mediatek,mt8195-disp-rdma
+      - items:
+          - enum:
+              - mediatek,mt7623-disp-rdma
+              - mediatek,mt2712-disp-rdma
+          - enum:
+              - mediatek,mt2701-disp-rdma
+
+  reg:
+    maxItems: 1
+
+  interrupts:
+    maxItems: 1
+
+  power-domains:
+    description: A phandle and PM domain specifier as defined by bindings of
+      the power controller specified by phandle. See
+      Documentation/devicetree/bindings/power/power-domain.yaml for details.
+
+  clocks:
+    items:
+      - description: RDMA Clock
+
+  iommus:
+    description:
+      This property should point to the respective IOMMU block with master port as argument,
+      see Documentation/devicetree/bindings/iommu/mediatek,iommu.yaml for details.
+
+  mediatek,larb:
+    description:
+      This property should contain a phandle pointing to the local arbiter deviceas defined in
+      Documentation/devicetree/bindings/memory-controllers/mediatek,smi-larb.yaml.
+      It must sort according to the local arbiter index, like larb0, larb1, larb2...
+    $ref: /schemas/types.yaml#/definitions/phandle-array
+    minItems: 1
+    maxItems: 32
+
+  mediatek,rdma-fifo-size:
+    description:
+      rdma fifo size may be different even in same SOC, add this property to the
+      corresponding rdma.
+      The value below is the Max value which defined in hardware data sheet
+      mediatek,rdma-fifo-size of mt8173-rdma0 is 8K
+      mediatek,rdma-fifo-size of mt8183-rdma0 is 5K
+      mediatek,rdma-fifo-size of mt8183-rdma1 is 2K
+    $ref: /schemas/types.yaml#/definitions/uint32
+    enum: [8192, 5120, 2048]
+
+  mediatek,gce-client-reg:
+    description:
+      The register of client driver can be configured by gce with 4 arguments defined
+      in this property, such as phandle of gce, subsys id, register offset and size.
+      Each subsys id is mapping to a base address of display function blocks register
+      which is defined in the gce header include/include/dt-bindings/gce/<chip>-gce.h.
+    $ref: /schemas/types.yaml#/definitions/phandle-array
+    maxItems: 1
+
+required:
+  - compatible
+  - reg
+  - interrupts
+  - power-domains
+  - clocks
+  - iommus
+
+additionalProperties: false
+
+examples:
+  - |
+
+    rdma0: rdma@1400e000 {
+        compatible = "mediatek,mt8173-disp-rdma";
+        reg = <0 0x1400e000 0 0x1000>;
+        interrupts = <GIC_SPI 182 IRQ_TYPE_LEVEL_LOW>;
+        power-domains = <&scpsys MT8173_POWER_DOMAIN_MM>;
+        clocks = <&mmsys CLK_MM_DISP_RDMA0>;
+        iommus = <&iommu M4U_PORT_DISP_RDMA0>;
+        mediatek,larb = <&larb0>;
+        mediatek,rdma-fifosize = <8192>;
+        mediatek,gce-client-reg = <&gce SUBSYS_1400XXXX 0xe000 0x1000>;
+    };
diff --git a/Documentation/devicetree/bindings/display/mediatek/mediatek,split.yaml b/Documentation/devicetree/bindings/display/mediatek/mediatek,split.yaml
new file mode 100644
index 0000000000000000000000000000000000000000..0ab3eaa6d6d8f66efb31785a2ee51b12e5e40ded
--- /dev/null
+++ b/Documentation/devicetree/bindings/display/mediatek/mediatek,split.yaml
@@ -0,0 +1,56 @@
+# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/display/mediatek/mediatek,split.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: mediatek display split
+
+maintainers:
+  - Chun-Kuang Hu <chunkuang.hu@kernel.org>
+  - Philipp Zabel <p.zabel@pengutronix.de>
+
+description: |
+  The mediatek display split engine is used to split stream to two encoders.
+  SPLIT device node must be siblings to the central MMSYS_CONFIG node.
+  For a description of the MMSYS_CONFIG binding, see
+  Documentation/devicetree/bindings/arm/mediatek/mediatek,mmsys.yaml for details.
+
+properties:
+  compatible:
+    oneOf:
+      - items:
+          - const: mediatek,mt8173-disp-split
+
+  reg:
+    maxItems: 1
+
+  interrupts:
+    maxItems: 1
+
+  power-domains:
+    description: A phandle and PM domain specifier as defined by bindings of
+      the power controller specified by phandle. See
+      Documentation/devicetree/bindings/power/power-domain.yaml for details.
+
+  clocks:
+    items:
+      - description: SPLIT Clock
+
+required:
+  - compatible
+  - reg
+  - power-domains
+  - clocks
+
+additionalProperties: false
+
+examples:
+  - |
+
+    split0: split@14018000 {
+        compatible = "mediatek,mt8173-disp-split";
+        reg = <0 0x14018000 0 0x1000>;
+        power-domains = <&spm MT8173_POWER_DOMAIN_MM>;
+        clocks = <&mmsys CLK_MM_DISP_SPLIT0>;
+    };
diff --git a/Documentation/devicetree/bindings/display/mediatek/mediatek,ufoe.yaml b/Documentation/devicetree/bindings/display/mediatek/mediatek,ufoe.yaml
new file mode 100644
index 0000000000000000000000000000000000000000..c50477abfff25ecf67a997331cccfc49ef5c013c
--- /dev/null
+++ b/Documentation/devicetree/bindings/display/mediatek/mediatek,ufoe.yaml
@@ -0,0 +1,59 @@
+# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/display/mediatek/mediatek,ufoe.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: mediatek display UFOe
+
+maintainers:
+  - Chun-Kuang Hu <chunkuang.hu@kernel.org>
+  - Philipp Zabel <p.zabel@pengutronix.de>
+
+description: |
+  The Mediatek display UFOe stands for Unified Frame Optimization engine.
+  UFOe can cut the data rate for DSI port which may lead to reduce power consumption.
+  UFOe device node must be siblings to the central MMSYS_CONFIG node.
+  For a description of the MMSYS_CONFIG binding, see
+  Documentation/devicetree/bindings/arm/mediatek/mediatek,mmsys.yaml for details.
+
+properties:
+  compatible:
+    oneOf:
+      - items:
+          - const: mediatek,mt8173-disp-ufoe
+
+  reg:
+    maxItems: 1
+
+  interrupts:
+    maxItems: 1
+
+  power-domains:
+    description: A phandle and PM domain specifier as defined by bindings of
+      the power controller specified by phandle. See
+      Documentation/devicetree/bindings/power/power-domain.yaml for details.
+
+  clocks:
+    items:
+      - description: UFOe Clock
+
+required:
+  - compatible
+  - reg
+  - interrupts
+  - power-domains
+  - clocks
+
+additionalProperties: false
+
+examples:
+  - |
+
+    ufoe@1401a000 {
+        compatible = "mediatek,mt8173-disp-ufoe";
+        reg = <0 0x1401a000 0 0x1000>;
+        interrupts = <GIC_SPI 191 IRQ_TYPE_LEVEL_LOW>;
+        power-domains = <&scpsys MT8173_POWER_DOMAIN_MM>;
+        clocks = <&mmsys CLK_MM_DISP_UFOE>;
+    };
diff --git a/Documentation/devicetree/bindings/display/mediatek/mediatek,wdma.yaml b/Documentation/devicetree/bindings/display/mediatek/mediatek,wdma.yaml
new file mode 100644
index 0000000000000000000000000000000000000000..ecf9549e0e07475966a36d24d69c4af20572c5a1
--- /dev/null
+++ b/Documentation/devicetree/bindings/display/mediatek/mediatek,wdma.yaml
@@ -0,0 +1,86 @@
+# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/display/mediatek/mediatek,wdma.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: mediatek display WDMA
+
+maintainers:
+  - Chun-Kuang Hu <chunkuang.hu@kernel.org>
+  - Philipp Zabel <p.zabel@pengutronix.de>
+
+description: |
+  The mediatek display WDMA stands for Write Direct Memory Access.
+  It can write the data in display pipeline into DRAM.
+  WDMA device node must be siblings to the central MMSYS_CONFIG node.
+  For a description of the MMSYS_CONFIG binding, see
+  Documentation/devicetree/bindings/arm/mediatek/mediatek,mmsys.yaml for details.
+
+properties:
+  compatible:
+    oneOf:
+      - items:
+          - const: mediatek,mt8173-disp-wdma
+
+  reg:
+    maxItems: 1
+
+  interrupts:
+    maxItems: 1
+
+  power-domains:
+    description: A phandle and PM domain specifier as defined by bindings of
+      the power controller specified by phandle. See
+      Documentation/devicetree/bindings/power/power-domain.yaml for details.
+
+  clocks:
+    items:
+      - description: WDMA Clock
+
+  iommus:
+    description:
+      This property should point to the respective IOMMU block with master port as argument,
+      see Documentation/devicetree/bindings/iommu/mediatek,iommu.yaml for details.
+
+  mediatek,larb:
+    description:
+      This property should contain a phandle pointing to the local arbiter deviceas defined in
+      Documentation/devicetree/bindings/memory-controllers/mediatek,smi-larb.yaml.
+      It must sort according to the local arbiter index, like larb0, larb1, larb2...
+    $ref: /schemas/types.yaml#/definitions/phandle-array
+    minItems: 1
+    maxItems: 32
+
+  mediatek,gce-client-reg:
+    description:
+      The register of client driver can be configured by gce with 4 arguments defined
+      in this property, such as phandle of gce, subsys id, register offset and size.
+      Each subsys id is mapping to a base address of display function blocks register
+      which is defined in the gce header include/include/dt-bindings/gce/<chip>-gce.h.
+    $ref: /schemas/types.yaml#/definitions/phandle-array
+    maxItems: 1
+
+required:
+  - compatible
+  - reg
+  - interrupts
+  - power-domains
+  - clocks
+  - iommus
+
+additionalProperties: false
+
+examples:
+  - |
+
+    wdma0: wdma@14011000 {
+        compatible = "mediatek,mt8173-disp-wdma";
+        reg = <0 0x14011000 0 0x1000>;
+        interrupts = <GIC_SPI 185 IRQ_TYPE_LEVEL_LOW>;
+        power-domains = <&scpsys MT8173_POWER_DOMAIN_MM>;
+        clocks = <&mmsys CLK_MM_DISP_WDMA0>;
+        iommus = <&iommu M4U_PORT_DISP_WDMA0>;
+        mediatek,larb = <&larb0>;
+        mediatek,gce-client-reg = <&gce SUBSYS_1401XXXX 0x1000 0x1000>;
+    };
diff --git a/Documentation/devicetree/bindings/iommu/mediatek,iommu.yaml b/Documentation/devicetree/bindings/iommu/mediatek,iommu.yaml
index 0f26fe14c8e21761a8de9f37ae6377fa9e0eb96c..c528a299afa915630a7b9b8ccbfd3c29370a767a 100644
--- a/Documentation/devicetree/bindings/iommu/mediatek,iommu.yaml
+++ b/Documentation/devicetree/bindings/iommu/mediatek,iommu.yaml
@@ -77,6 +77,9 @@ properties:
           - mediatek,mt8173-m4u  # generation two
           - mediatek,mt8183-m4u  # generation two
           - mediatek,mt8192-m4u  # generation two
+          - mediatek,mt8195-iommu-vdo        # generation two
+          - mediatek,mt8195-iommu-vpp        # generation two
+          - mediatek,mt8195-iommu-infra      # generation two
 
       - description: mt7623 generation one
         items:
@@ -118,6 +121,7 @@ properties:
       dt-binding/memory/mt8173-larb-port.h for mt8173,
       dt-binding/memory/mt8183-larb-port.h for mt8183,
       dt-binding/memory/mt8192-larb-port.h for mt8192.
+      dt-binding/memory/mt8195-memory-port.h for mt8195.
 
   power-domains:
     maxItems: 1
@@ -126,7 +130,6 @@ required:
   - compatible
   - reg
   - interrupts
-  - mediatek,larbs
   - '#iommu-cells'
 
 allOf:
@@ -139,6 +142,8 @@ allOf:
               - mediatek,mt2712-m4u
               - mediatek,mt8173-m4u
               - mediatek,mt8192-m4u
+              - mediatek,mt8195-iommu-vdo
+              - mediatek,mt8195-iommu-vpp
 
     then:
       required:
@@ -149,11 +154,24 @@ allOf:
         compatible:
           enum:
             - mediatek,mt8192-m4u
+            - mediatek,mt8195-iommu-vdo
+            - mediatek,mt8195-iommu-vpp
 
     then:
       required:
         - power-domains
 
+  - if: # The IOMMUs don't have larbs.
+      not:
+        properties:
+          compatible:
+            contains:
+              const: mediatek,mt8195-iommu-infra
+
+    then:
+      required:
+        - mediatek,larbs
+
 additionalProperties: false
 
 examples:
diff --git a/Documentation/devicetree/bindings/media/mediatek,mdp3-ccorr.yaml b/Documentation/devicetree/bindings/media/mediatek,mdp3-ccorr.yaml
new file mode 100644
index 0000000000000000000000000000000000000000..205b91b55806633b9bdb24bbe508380f30202768
--- /dev/null
+++ b/Documentation/devicetree/bindings/media/mediatek,mdp3-ccorr.yaml
@@ -0,0 +1,58 @@
+# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/media/mediatek,mdp3-ccorr.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: Mediatek Media Data Path 3 CCORR Device Tree Bindings
+
+maintainers:
+  - Daoyuan Huang <daoyuan.huang@mediatek.com>
+  - Moudy Ho <moudy.ho@mediatek.com>
+
+description: |
+  One of Media Data Path 3 (MDP3) components used to do color correction with 3X3 matrix.
+
+properties:
+  compatible:
+    items:
+      - enum:
+        - mediatek,mt8183-mdp3-ccorr
+
+  mediatek,mdp3-id:
+    $ref: /schemas/types.yaml#/definitions/uint32
+    maxItems: 1
+    description: |
+      HW index to distinguish same functionality modules.
+
+  reg:
+    description: |
+      Physical base address and length of the function block
+      register space, the number aligns with the component
+      and its own subcomponent.
+
+  mediatek,gce-client-reg:
+    $ref: /schemas/types.yaml#/definitions/phandle-array
+    description: |
+      sub-system id corresponding to the global command engine (GCE)
+      register address.
+      $ref: /schemas/mailbox/mtk-gce.txt
+
+  clocks:
+    minItems: 1
+
+additionalProperties: false
+
+examples:
+  - |
+    #include <dt-bindings/clock/mt8183-clk.h>
+    #include <dt-bindings/gce/mt8183-gce.h>
+
+    mdp3_ccorr: mdp3_ccorr@1401c000 {
+      compatible = "mediatek,mt8183-mdp3-ccorr";
+      mediatek,mdp3-id = <0>;
+      reg = <0x1401c000 0x1000>;
+      mediatek,gce-client-reg = <&gce SUBSYS_1401XXXX 0xc000 0x1000>;
+      clocks = <&mmsys CLK_MM_MDP_CCORR>;
+    };
+
diff --git a/Documentation/devicetree/bindings/media/mediatek-mdp3.yaml b/Documentation/devicetree/bindings/media/mediatek,mdp3-rdma.yaml
old mode 100755
new mode 100644
similarity index 53%
rename from Documentation/devicetree/bindings/media/mediatek-mdp3.yaml
rename to Documentation/devicetree/bindings/media/mediatek,mdp3-rdma.yaml
index e3e10f0544ba8dfc7028f5f1448e5d5ff374cb72..b355d7fe791eee6d4efd19d5483e51d1cafc0e4b
--- a/Documentation/devicetree/bindings/media/mediatek-mdp3.yaml
+++ b/Documentation/devicetree/bindings/media/mediatek,mdp3-rdma.yaml
@@ -1,7 +1,7 @@
 # SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
 %YAML 1.2
 ---
-$id: http://devicetree.org/schemas/media/mediatek-mdp3.yaml#
+$id: http://devicetree.org/schemas/media/mediatek,mdp3-rdma.yaml#
 $schema: http://devicetree.org/meta-schemas/core.yaml#
 
 title: Mediatek Media Data Path 3 Device Tree Bindings
@@ -11,7 +11,9 @@ maintainers:
   - Moudy Ho <moudy.ho@mediatek.com>
 
 description: |
-  Media Data Path 3 (MDP3) is used for scaling and color space conversion.
+  One of Media Data Path 3 (MDP3) components used to do read DMA.
+  RDMA0 is also used to be a controller node containing MMSYS,
+  MUTEX, GCE and SCP settings.
 
 properties:
   compatible:
@@ -27,14 +29,6 @@ properties:
         - enum:
           # read DMA
           - mediatek,mt8183-mdp3-rdma
-          # frame resizer
-          - mediatek,mt8183-mdp3-rsz
-          # write DMA
-          - mediatek,mt8183-mdp3-wdma
-          # write DMA with frame rotation
-          - mediatek,mt8183-mdp3-wrot
-          # color correction with 3X3 matrix
-          - mediatek,mt8183-mdp3-ccorr
 
   mediatek,scp:
     $ref: /schemas/types.yaml#/definitions/phandle
@@ -48,20 +42,37 @@ properties:
     $ref: /schemas/types.yaml#/definitions/uint32
     maxItems: 1
     description: |
-      HW index to distinguish same functionality modules.
+      In MDP3, it can allocate multiple identical modules for
+      different data path selection or multi-pipeline execution.
+      This node is used to indicate the ID of each module.
 
   mdp3-comps:
     $ref: /schemas/types.yaml#/definitions/string-array
-    description: |
-      Subcomponent, the number aligns with
-      mdp_sub_comp_dt_ids[] in mtk-mdp3-comp.c.
+    items:
+        - enum:
+          # MDP direct-link input path selection, create a
+          # component for path connectedness of HW pipe control
+          - mediatek,mt8183-mdp3-dl1
+        - enum:
+          - mediatek,mt8183-mdp3-dl2
+        - enum:
+          # MDP direct-link output path selection, create a
+          # component for path connectedness of HW pipe control
+          - mediatek,mt8183-mdp3-path1
+        - enum:
+          - mediatek,mt8183-mdp3-path2
+        - enum:
+          # Input DMA of ISP PASS2 (DIP) module for raw image input
+          - mediatek,mt8183-mdp3-imgi
+        - enum:
+          # Output DMA of ISP PASS2 (DIP) module for YUV image output
+          - mediatek,mt8183-mdp3-exto
 
   mdp3-comp-ids:
     maxItems: 1
     $ref: /schemas/types.yaml#/definitions/uint32-array
     description: |
-      Index of the modules, the number list in
-      mdp_comp_matches[] in mtk-mdp3-comp.c.
+      Pipeline ID of MDP direct-link or DIP.
 
   reg:
     description: |
@@ -121,13 +132,6 @@ properties:
       register address.
       $ref: /schemas/mailbox/mtk-gce.txt
 
-  mediatek,gce-events:
-    $ref: /schemas/types.yaml#/definitions/uint32-array
-    description: |
-      In use event IDs list, all IDs are defined in
-      'dt-bindings/gce/mt8183-gce.h'.
-      $ref: /schemas/mailbox/mtk-gce.txt
-
 if:
   properties:
     compatible:
@@ -142,7 +146,6 @@ then:
     - mediatek,scp
     - mediatek,mmsys
     - mediatek,mm-mutex
-    - mediatek,gce-events
     - mediatek,mailbox-gce
     - mboxes
     - gce-subsys
@@ -168,14 +171,19 @@ examples:
                    "mediatek,mt8183-mdp3-rdma";
       mediatek,scp = <&scp>;
       mediatek,mdp3-id = <0>;
-      mdp3-comps = "mediatek,mt8183-mdp3-dl", "mediatek,mt8183-mdp3-dl1",
+      mdp3-comps = "mediatek,mt8183-mdp3-dl1", "mediatek,mt8183-mdp3-dl2",
+                   "mediatek,mt8183-mdp3-path1", "mediatek,mt8183-mdp3-path2",
                    "mediatek,mt8183-mdp3-imgi", "mediatek,mt8183-mdp3-exto";
-      mdp3-comp-ids = <0 1 0 1>;
+      mdp3-comp-ids = <0 1 0 1 0 1>;
       reg = <0x14001000 0x1000>,
             <0x14000000 0x1000>,
+            <0x14005000 0x1000>,
+            <0x14006000 0x1000>,
             <0x15020000 0x1000>;
       mediatek,gce-client-reg = <&gce SUBSYS_1400XXXX 0x1000 0x1000>,
                                 <&gce SUBSYS_1400XXXX 0 0x1000>,
+                                <&gce SUBSYS_1400XXXX 0x5000 0x1000>,
+                                <&gce SUBSYS_1400XXXX 0x6000 0x1000>,
                                 <&gce SUBSYS_1502XXXX 0 0x1000>;
       power-domains = <&spm MT8183_POWER_DOMAIN_DISP>;
       clocks = <&mmsys CLK_MM_MDP_RDMA0>,
@@ -196,79 +204,4 @@ examples:
                    <&gce 0x14010000 SUBSYS_1401XXXX>,
                    <&gce 0x14020000 SUBSYS_1402XXXX>,
                    <&gce 0x15020000 SUBSYS_1502XXXX>;
-      mediatek,gce-events = <CMDQ_EVENT_MDP_RDMA0_SOF>,
-                            <CMDQ_EVENT_MDP_RDMA0_EOF>,
-                            <CMDQ_EVENT_MDP_RSZ0_SOF>,
-                            <CMDQ_EVENT_MDP_RSZ1_SOF>,
-                            <CMDQ_EVENT_MDP_TDSHP_SOF>,
-                            <CMDQ_EVENT_MDP_WROT0_SOF>,
-                            <CMDQ_EVENT_MDP_WROT0_EOF>,
-                            <CMDQ_EVENT_MDP_WDMA0_SOF>,
-                            <CMDQ_EVENT_MDP_WDMA0_EOF>,
-                            <CMDQ_EVENT_ISP_FRAME_DONE_P2_0>,
-                            <CMDQ_EVENT_ISP_FRAME_DONE_P2_1>,
-                            <CMDQ_EVENT_ISP_FRAME_DONE_P2_2>,
-                            <CMDQ_EVENT_ISP_FRAME_DONE_P2_3>,
-                            <CMDQ_EVENT_ISP_FRAME_DONE_P2_4>,
-                            <CMDQ_EVENT_ISP_FRAME_DONE_P2_5>,
-                            <CMDQ_EVENT_ISP_FRAME_DONE_P2_6>,
-                            <CMDQ_EVENT_ISP_FRAME_DONE_P2_7>,
-                            <CMDQ_EVENT_ISP_FRAME_DONE_P2_8>,
-                            <CMDQ_EVENT_ISP_FRAME_DONE_P2_9>,
-                            <CMDQ_EVENT_ISP_FRAME_DONE_P2_10>,
-                            <CMDQ_EVENT_ISP_FRAME_DONE_P2_11>,
-                            <CMDQ_EVENT_ISP_FRAME_DONE_P2_12>,
-                            <CMDQ_EVENT_ISP_FRAME_DONE_P2_13>,
-                            <CMDQ_EVENT_ISP_FRAME_DONE_P2_14>,
-                            <CMDQ_EVENT_WPE_A_DONE>,
-                            <CMDQ_EVENT_SPE_B_DONE>;
-    };
-
-    mdp3_rsz0: mdp3_rsz0@14003000 {
-      compatible = "mediatek,mt8183-mdp3-rsz";
-      mediatek,mdp3-id = <0>;
-      reg = <0x14003000 0x1000>;
-      mediatek,gce-client-reg = <&gce SUBSYS_1400XXXX 0x3000 0x1000>;
-      clocks = <&mmsys CLK_MM_MDP_RSZ0>;
-    };
-
-    mdp3_rsz1: mdp3_rsz1@14004000 {
-      compatible = "mediatek,mt8183-mdp3-rsz";
-      mediatek,mdp3-id = <1>;
-      reg = <0x14004000 0x1000>;
-      mediatek,gce-client-reg = <&gce SUBSYS_1400XXXX 0x4000 0x1000>;
-      clocks = <&mmsys CLK_MM_MDP_RSZ1>;
-    };
-
-    mdp3_wrot0: mdp3_wrot0@14005000 {
-      compatible = "mediatek,mt8183-mdp3-wrot";
-      mediatek,mdp3-id = <0>;
-      mdp3-comps = "mediatek,mt8183-mdp3-path";
-      mdp3-comp-ids = <0>;
-      reg = <0x14005000 0x1000>;
-      mediatek,gce-client-reg = <&gce SUBSYS_1400XXXX 0x5000 0x1000>;
-      power-domains = <&spm MT8183_POWER_DOMAIN_DISP>;
-      clocks = <&mmsys CLK_MM_MDP_WROT0>;
-      iommus = <&iommu>;
-    };
-
-    mdp3_wdma: mdp3_wdma@14006000 {
-      compatible = "mediatek,mt8183-mdp3-wdma";
-      mediatek,mdp3-id = <0>;
-      mdp3-comps = "mediatek,mt8183-mdp3-path";
-      mdp3-comp-ids = <1>;
-      reg = <0x14006000 0x1000>;
-      mediatek,gce-client-reg = <&gce SUBSYS_1400XXXX 0x6000 0x1000>;
-      power-domains = <&spm MT8183_POWER_DOMAIN_DISP>;
-      clocks = <&mmsys CLK_MM_MDP_WDMA0>;
-      iommus = <&iommu>;
-    };
-
-    mdp3_ccorr: mdp3_ccorr@1401c000 {
-      compatible = "mediatek,mt8183-mdp3-ccorr";
-      mediatek,mdp3-id = <0>;
-      reg = <0x1401c000 0x1000>;
-      mediatek,gce-client-reg = <&gce SUBSYS_1401XXXX 0xc000 0x1000>;
-      clocks = <&mmsys CLK_MM_MDP_CCORR>;
-    };
-
+    };
\ No newline at end of file
diff --git a/Documentation/devicetree/bindings/media/mediatek,mdp3-rsz.yaml b/Documentation/devicetree/bindings/media/mediatek,mdp3-rsz.yaml
new file mode 100644
index 0000000000000000000000000000000000000000..218f035ad40650e9a2a593e88d6ddc97354c6f9e
--- /dev/null
+++ b/Documentation/devicetree/bindings/media/mediatek,mdp3-rsz.yaml
@@ -0,0 +1,66 @@
+# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/media/mediatek,mdp3-rsz.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: Mediatek Media Data Path 3 Resizer Device Tree Bindings
+
+maintainers:
+  - Daoyuan Huang <daoyuan.huang@mediatek.com>
+  - Moudy Ho <moudy.ho@mediatek.com>
+
+description: |
+  One of Media Data Path 3 (MDP3) components used to do frame resizing.
+
+properties:
+  compatible:
+    items:
+      - enum:
+        - mediatek,mt8183-mdp3-rsz
+
+  mediatek,mdp3-id:
+    $ref: /schemas/types.yaml#/definitions/uint32
+    maxItems: 1
+    description: |
+      HW index to distinguish same functionality modules.
+
+  reg:
+    description: |
+      Physical base address and length of the function block
+      register space, the number aligns with the component
+      and its own subcomponent.
+
+  mediatek,gce-client-reg:
+    $ref: /schemas/types.yaml#/definitions/phandle-array
+    description: |
+      sub-system id corresponding to the global command engine (GCE)
+      register address.
+      $ref: /schemas/mailbox/mtk-gce.txt
+
+  clocks:
+    minItems: 1
+
+additionalProperties: false
+
+examples:
+  - |
+    #include <dt-bindings/clock/mt8183-clk.h>
+    #include <dt-bindings/gce/mt8183-gce.h>
+
+    mdp3_rsz0: mdp3_rsz0@14003000 {
+      compatible = "mediatek,mt8183-mdp3-rsz";
+      mediatek,mdp3-id = <0>;
+      reg = <0x14003000 0x1000>;
+      mediatek,gce-client-reg = <&gce SUBSYS_1400XXXX 0x3000 0x1000>;
+      clocks = <&mmsys CLK_MM_MDP_RSZ0>;
+    };
+
+    mdp3_rsz1: mdp3_rsz1@14004000 {
+      compatible = "mediatek,mt8183-mdp3-rsz";
+      mediatek,mdp3-id = <1>;
+      reg = <0x14004000 0x1000>;
+      mediatek,gce-client-reg = <&gce SUBSYS_1400XXXX 0x4000 0x1000>;
+      clocks = <&mmsys CLK_MM_MDP_RSZ1>;
+    };
+
diff --git a/Documentation/devicetree/bindings/media/mediatek,mdp3-wdma.yaml b/Documentation/devicetree/bindings/media/mediatek,mdp3-wdma.yaml
new file mode 100644
index 0000000000000000000000000000000000000000..93e6f331ada8ee5ae43fbc7a6ad9eeaf77a11e79
--- /dev/null
+++ b/Documentation/devicetree/bindings/media/mediatek,mdp3-wdma.yaml
@@ -0,0 +1,71 @@
+# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/media/mediatek,mdp3-wdma.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: Mediatek Media Data Path 3 Device Tree Bindings
+
+maintainers:
+  - Daoyuan Huang <daoyuan.huang@mediatek.com>
+  - Moudy Ho <moudy.ho@mediatek.com>
+
+description: |
+  One of Media Data Path 3 (MDP3) components used to write DMA.
+
+properties:
+  compatible:
+    items:
+      - enum:
+        - mediatek,mt8183-mdp3-wdma
+
+  mediatek,mdp3-id:
+    $ref: /schemas/types.yaml#/definitions/uint32
+    maxItems: 1
+    description: |
+      HW index to distinguish same functionality modules.
+
+  reg:
+    description: |
+      Physical base address and length of the function block
+      register space, the number aligns with the component
+      and its own subcomponent.
+
+  mediatek,gce-client-reg:
+    $ref: /schemas/types.yaml#/definitions/phandle-array
+    description: |
+      sub-system id corresponding to the global command engine (GCE)
+      register address.
+      $ref: /schemas/mailbox/mtk-gce.txt
+
+  power-domains:
+    maxItems: 1
+
+  clocks:
+    minItems: 1
+
+  iommus:
+    $ref: /schemas/types.yaml#/definitions/phandle
+    description: |
+      Should point to the respective IOMMU block with master
+      port as argument.
+      $ref: /schemas/iommu/mediatek,iommu.yaml
+
+additionalProperties: false
+
+examples:
+  - |
+    #include <dt-bindings/clock/mt8183-clk.h>
+    #include <dt-bindings/gce/mt8183-gce.h>
+    #include <dt-bindings/power/mt8183-power.h>
+    #include <dt-bindings/memory/mt8183-larb-port.h>
+
+    mdp3_wdma: mdp3_wdma@14006000 {
+      compatible = "mediatek,mt8183-mdp3-wdma";
+      mediatek,mdp3-id = <0>;
+      reg = <0x14006000 0x1000>;
+      mediatek,gce-client-reg = <&gce SUBSYS_1400XXXX 0x6000 0x1000>;
+      power-domains = <&spm MT8183_POWER_DOMAIN_DISP>;
+      clocks = <&mmsys CLK_MM_MDP_WDMA0>;
+      iommus = <&iommu>;
+    };
diff --git a/Documentation/devicetree/bindings/media/mediatek,mdp3-wrot.yaml b/Documentation/devicetree/bindings/media/mediatek,mdp3-wrot.yaml
new file mode 100644
index 0000000000000000000000000000000000000000..2993da04c562b3d588ca81dc05d9e5bf5ec4a39d
--- /dev/null
+++ b/Documentation/devicetree/bindings/media/mediatek,mdp3-wrot.yaml
@@ -0,0 +1,71 @@
+# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/media/mediatek,mdp3-wrot.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: Mediatek Media Data Path 3 Device Tree Bindings
+
+maintainers:
+  - Daoyuan Huang <daoyuan.huang@mediatek.com>
+  - Moudy Ho <moudy.ho@mediatek.com>
+
+description: |
+  One of Media Data Path 3 (MDP3) components used to write DMA with frame rotation.
+
+properties:
+  compatible:
+    items:
+      - enum:
+        - mediatek,mt8183-mdp3-wrot
+
+  mediatek,mdp3-id:
+    $ref: /schemas/types.yaml#/definitions/uint32
+    maxItems: 1
+    description: |
+      HW index to distinguish same functionality modules.
+
+  reg:
+    description: |
+      Physical base address and length of the function block
+      register space, the number aligns with the component
+      and its own subcomponent.
+
+  mediatek,gce-client-reg:
+    $ref: /schemas/types.yaml#/definitions/phandle-array
+    description: |
+      sub-system id corresponding to the global command engine (GCE)
+      register address.
+      $ref: /schemas/mailbox/mtk-gce.txt
+
+  power-domains:
+    maxItems: 1
+
+  clocks:
+    minItems: 1
+
+  iommus:
+    $ref: /schemas/types.yaml#/definitions/phandle
+    description: |
+      Should point to the respective IOMMU block with master
+      port as argument.
+      $ref: /schemas/iommu/mediatek,iommu.yaml
+
+additionalProperties: false
+
+examples:
+  - |
+    #include <dt-bindings/clock/mt8183-clk.h>
+    #include <dt-bindings/gce/mt8183-gce.h>
+    #include <dt-bindings/power/mt8183-power.h>
+    #include <dt-bindings/memory/mt8183-larb-port.h>
+
+    mdp3_wrot0: mdp3_wrot0@14005000 {
+      compatible = "mediatek,mt8183-mdp3-wrot";
+      mediatek,mdp3-id = <0>;
+      reg = <0x14005000 0x1000>;
+      mediatek,gce-client-reg = <&gce SUBSYS_1400XXXX 0x5000 0x1000>;
+      power-domains = <&spm MT8183_POWER_DOMAIN_DISP>;
+      clocks = <&mmsys CLK_MM_MDP_WROT0>;
+      iommus = <&iommu>;
+    };
diff --git a/Documentation/devicetree/bindings/media/mediatek-vcodec-comp-decoder.txt b/Documentation/devicetree/bindings/media/mediatek-vcodec-comp-decoder.txt
new file mode 100644
index 0000000000000000000000000000000000000000..91757c1c9ed9c09bfe4b077afc75aed836e30d3a
--- /dev/null
+++ b/Documentation/devicetree/bindings/media/mediatek-vcodec-comp-decoder.txt
@@ -0,0 +1,94 @@
+Mediatek Video Decoder With Component
+
+Mediatek Video Decoder is the video decode hw present in Mediatek SoCs which
+supports high resolution decoding functionalities. Required  master and
+component node properties:
+
+Master properties:
+- compatible(must be one of the following string) :
+  "mediatek,mt8192-vcodec-dec" for MT8192 decoder.
+  "mediatek,mt8195-vcodec-dec" for MT8192 decoder.
+- reg : Physical base address of the video decoder registers and length of
+  memory mapped region.
+- iommus : should point to the respective IOMMU block with master port as
+  argument, see Documentation/devicetree/bindings/iommu/mediatek,iommu.txt
+  for details.
+- mediatek,scp : the node of the SCP unit, if using SCP.
+
+component properties(core and lat):
+- compatible(core) : "mediatek,mtk-vcodec-core" core hardware decoder
+  "mediatek,mtk-vcodec-core" for core hardware decoder.
+- compatible(lat) : "mediatek,mtk-vcodec-lat" lat hardware decoder
+  "mediatek,mtk-vcodec-lat" for lat hardware decoder.
+- reg : Physical base address of the video decoder registers and length of
+  memory mapped region.
+- interrupts : interrupt number to the cpu.
+- clocks : list of clock specifiers, corresponding to entries in
+  the clock-names property.
+- clock-names: decoder must contain "vcodecpll", "univpll_d2",
+  "clk_cci400_sel", "vdec_sel", "vdecpll", "vencpll", "venc_lt_sel",
+  "vdec_bus_clk_src".
+- iommus : should point to the respective IOMMU block with master port as
+  argument, see Documentation/devicetree/bindings/iommu/mediatek,iommu.txt
+  for details.
+- dma-ranges : describes how the physical address space of the IOMMU maps
+  to memory.
+
+vcodec_dec: vcodec_dec@16000000 {
+    compatible = "mediatek,mt8192-vcodec-dec";
+    reg = <0 0x16000000 0 0x1000>;		/* VDEC_SYS */
+    mediatek,scp = <&scp>;
+    iommus = <&iommu0 M4U_PORT_L4_VDEC_MC_EXT>;
+    dma-ranges = <0x1 0x0 0x0 0x40000000 0x0 0xfff00000>;
+  };
+
+vcodec_lat: vcodec_lat@0x16010000 {
+    compatible = "mediatek,mtk-vcodec-lat";
+    reg = <0 0x16010000 0 0x800>;		/* VDEC_MISC */
+    interrupts = <GIC_SPI 426 IRQ_TYPE_LEVEL_HIGH 0>;
+    iommus = <&iommu0 M4U_PORT_L5_VDEC_LAT0_VLD_EXT>,
+         <&iommu0 M4U_PORT_L5_VDEC_LAT0_VLD2_EXT>,
+         <&iommu0 M4U_PORT_L5_VDEC_LAT0_AVC_MV_EXT>,
+         <&iommu0 M4U_PORT_L5_VDEC_LAT0_PRED_RD_EXT>,
+         <&iommu0 M4U_PORT_L5_VDEC_LAT0_TILE_EXT>,
+         <&iommu0 M4U_PORT_L5_VDEC_LAT0_WDMA_EXT>,
+         <&iommu0 M4U_PORT_L5_VDEC_LAT0_RG_CTRL_DMA_EXT>,
+         <&iommu0 M4U_PORT_L5_VDEC_UFO_ENC_EXT>;
+    dma-ranges = <0x1 0x0 0x0 0x40000000 0x0 0xfff00000>;
+    clocks = <&topckgen CLK_TOP_VDEC_SEL>,
+         <&vdecsys_soc CLK_VDEC_SOC_VDEC>,
+         <&vdecsys_soc CLK_VDEC_SOC_LAT>,
+         <&vdecsys_soc CLK_VDEC_SOC_LARB1>,
+         <&topckgen CLK_TOP_MAINPLL_D4>;
+    clock-names = "vdec-sel", "vdec-soc-vdec", "vdec-soc-lat", "vdec-vdec", "vdec-top";
+    assigned-clocks = <&topckgen CLK_TOP_VDEC_SEL>;
+    assigned-clock-parents = <&topckgen CLK_TOP_MAINPLL_D4>;
+    power-domains = <&scpsys MT8192_POWER_DOMAIN_VDEC>;
+  };
+
+vcodec_core: vcodec_core@0x16025000 {
+    compatible = "mediatek,mtk-vcodec-core";
+    reg = <0 0x16025000 0 0x1000>;		/* VDEC_CORE_MISC */
+    interrupts = <GIC_SPI 425 IRQ_TYPE_LEVEL_HIGH 0>;
+    iommus = <&iommu0 M4U_PORT_L4_VDEC_MC_EXT>,
+         <&iommu0 M4U_PORT_L4_VDEC_UFO_EXT>,
+         <&iommu0 M4U_PORT_L4_VDEC_PP_EXT>,
+         <&iommu0 M4U_PORT_L4_VDEC_PRED_RD_EXT>,
+         <&iommu0 M4U_PORT_L4_VDEC_PRED_WR_EXT>,
+         <&iommu0 M4U_PORT_L4_VDEC_PPWRAP_EXT>,
+         <&iommu0 M4U_PORT_L4_VDEC_TILE_EXT>,
+         <&iommu0 M4U_PORT_L4_VDEC_VLD_EXT>,
+         <&iommu0 M4U_PORT_L4_VDEC_VLD2_EXT>,
+         <&iommu0 M4U_PORT_L4_VDEC_AVC_MV_EXT>,
+         <&iommu0 M4U_PORT_L4_VDEC_RG_CTRL_DMA_EXT>;
+    dma-ranges = <0x1 0x0 0x0 0x40000000 0x0 0xfff00000>;
+    clocks = <&topckgen CLK_TOP_VDEC_SEL>,
+         <&vdecsys CLK_VDEC_VDEC>,
+         <&vdecsys CLK_VDEC_LAT>,
+         <&vdecsys CLK_VDEC_LARB1>,
+         <&topckgen CLK_TOP_MAINPLL_D4>;
+    clock-names = "vdec-sel", "vdec-soc-vdec", "vdec-soc-lat", "vdec-vdec", "vdec-top";
+    assigned-clocks = <&topckgen CLK_TOP_VDEC_SEL>;
+    assigned-clock-parents = <&topckgen CLK_TOP_MAINPLL_D4>;
+    power-domains = <&scpsys MT8192_POWER_DOMAIN_VDEC2>;
+ };
diff --git a/Documentation/devicetree/bindings/media/mediatek-vcodec-decoder.txt b/Documentation/devicetree/bindings/media/mediatek-vcodec-decoder.txt
new file mode 100644
index 0000000000000000000000000000000000000000..8905c53606c33218601d742a72521314bc961616
--- /dev/null
+++ b/Documentation/devicetree/bindings/media/mediatek-vcodec-decoder.txt
@@ -0,0 +1,98 @@
+Mediatek Video Decoder
+
+Mediatek Video Decoder is the video decode hw present in Mediatek SoCs which
+supports high resolution decoding functionalities. Required  master and
+component node properties:
+
+Master properties:
+- compatible :
+  "mediatek,mt8173-vcodec-dec" for MT8173 decoder.
+  "mediatek,mt8183-vcodec-dec" for MT8183 decoder.
+- reg : Physical base address of the video decoder registers and length of
+  memory mapped region.
+- mediatek,larb : must contain the local arbiters in the current Socs.
+- iommus : should point to the respective IOMMU block with master port as
+  argument, see Documentation/devicetree/bindings/iommu/mediatek,iommu.txt
+  for details.
+One of the two following nodes:
+- mediatek,vpu : the node of the video processor unit, if using VPU.
+- mediatek,scp : the node of the SCP unit, if using SCP.
+
+component properties(core):
+- compatible : "mediatek,mtk-vcodec-core" core hardware decoder
+  "mediatek,mtk-vcodec-core" for core hardware decoder.
+- reg : Physical base address of the video decoder registers and length of
+  memory mapped region.
+- interrupts : interrupt number to the cpu.
+- mediatek,larb : must contain the local arbiters in the current Socs.
+- clocks : list of clock specifiers, corresponding to entries in
+  the clock-names property.
+- clock-names: decoder must contain "vcodecpll", "univpll_d2",
+  "clk_cci400_sel", "vdec_sel", "vdecpll", "vencpll", "venc_lt_sel",
+  "vdec_bus_clk_src".
+- iommus : should point to the respective IOMMU block with master port as
+  argument, see Documentation/devicetree/bindings/iommu/mediatek,iommu.txt
+  for details.
+One of the two following nodes:
+- mediatek,vpu : the node of the video processor unit, if using VPU.
+- mediatek,scp : the node of the SCP unit, if using SCP.
+
+Example:
+
+vcodec_dec: vcodec@16000000 {
+    compatible = "mediatek,mt8173-vcodec-dec";
+    reg = <0 0x16000000 0 0x100>,	/* VDEC_SYS */
+          <0 0x16021000 0 0x800>,	/* VDEC_LD */
+          <0 0x16021800 0 0x800>,	/* VDEC_TOP */
+          <0 0x16022000 0 0x1000>,	/* VDEC_CM */
+          <0 0x16023000 0 0x1000>,	/* VDEC_AD */
+          <0 0x16024000 0 0x1000>,	/* VDEC_AV */
+          <0 0x16025000 0 0x1000>,	/* VDEC_PP */
+          <0 0x16026800 0 0x800>,	/* VDEC_HWD */
+          <0 0x16027000 0 0x800>,	/* VDEC_HWQ */
+          <0 0x16027800 0 0x800>,	/* VDEC_HWB */
+          <0 0x16028400 0 0x400>;	/* VDEC_HWG */
+    mediatek,larb = <&larb1>;
+    iommus = <&iommu M4U_PORT_HW_VDEC_MC_EXT>;
+    mediatek,vpu = <&vpu>;
+  };
+
+vcodec_core: core@0x16020000 {
+    compatible = "mediatek,mtk-vcodec-core";
+    reg = <0 0x16020000 0 0x1000>;	/* VDEC_MISC */
+    interrupts = <GIC_SPI 204 IRQ_TYPE_LEVEL_LOW>;
+    iommus = <&iommu M4U_PORT_HW_VDEC_MC_EXT>,
+             <&iommu M4U_PORT_HW_VDEC_PP_EXT>,
+             <&iommu M4U_PORT_HW_VDEC_AVC_MV_EXT>,
+             <&iommu M4U_PORT_HW_VDEC_PRED_RD_EXT>,
+             <&iommu M4U_PORT_HW_VDEC_PRED_WR_EXT>,
+             <&iommu M4U_PORT_HW_VDEC_UFO_EXT>,
+             <&iommu M4U_PORT_HW_VDEC_VLD_EXT>,
+             <&iommu M4U_PORT_HW_VDEC_VLD2_EXT>;
+    power-domains = <&scpsys MT8173_POWER_DOMAIN_VDEC>;
+    clocks = <&apmixedsys CLK_APMIXED_VCODECPLL>,
+             <&topckgen CLK_TOP_UNIVPLL_D2>,
+             <&topckgen CLK_TOP_CCI400_SEL>,
+             <&topckgen CLK_TOP_VDEC_SEL>,
+             <&topckgen CLK_TOP_VCODECPLL>,
+             <&apmixedsys CLK_APMIXED_VENCPLL>,
+             <&topckgen CLK_TOP_VENC_LT_SEL>,
+             <&topckgen CLK_TOP_VCODECPLL_370P5>;
+    clock-names = "vcodecpll",
+                  "univpll_d2",
+                  "clk_cci400_sel",
+                  "vdec_sel",
+                  "vdecpll",
+                  "vencpll",
+                  "venc_lt_sel",
+                  "vdec_bus_clk_src";
+    assigned-clocks = <&topckgen CLK_TOP_VENC_LT_SEL>,
+                      <&topckgen CLK_TOP_CCI400_SEL>,
+                      <&topckgen CLK_TOP_VDEC_SEL>,
+                      <&apmixedsys CLK_APMIXED_VCODECPLL>,
+                      <&apmixedsys CLK_APMIXED_VENCPLL>;
+    assigned-clock-parents = <&topckgen CLK_TOP_VCODECPLL_370P5>,
+                             <&topckgen CLK_TOP_UNIVPLL_D2>,
+                             <&topckgen CLK_TOP_VCODECPLL>;
+    assigned-clock-rates = <0>, <0>, <0>, <1482000000>, <800000000>;
+  };
diff --git a/Documentation/devicetree/bindings/media/mediatek-vcodec.txt b/Documentation/devicetree/bindings/media/mediatek-vcodec-encoder.txt
similarity index 51%
rename from Documentation/devicetree/bindings/media/mediatek-vcodec.txt
rename to Documentation/devicetree/bindings/media/mediatek-vcodec-encoder.txt
index ca421faa6634bbe42167264ae99513e1f684648e..f7ee7bc727d47a3493248807751d650f9390b221 100644
--- a/Documentation/devicetree/bindings/media/mediatek-vcodec.txt
+++ b/Documentation/devicetree/bindings/media/mediatek-vcodec-encoder.txt
@@ -1,20 +1,19 @@
-Mediatek Video Codec
+Mediatek Video Encoder
 
-Mediatek Video Codec is the video codec hw present in Mediatek SoCs which
-supports high resolution encoding and decoding functionalities.
+Mediatek Video Encoder is the video encode hw present in Mediatek SoCs which
+supports high resolution encoding functionalities.
 
 Required properties:
 - compatible : must be one of the following string:
   "mediatek,mt8173-vcodec-enc-vp8" for mt8173 vp8 encoder.
   "mediatek,mt8173-vcodec-enc" for mt8173 avc encoder.
   "mediatek,mt8183-vcodec-enc" for MT8183 encoder.
-  "mediatek,mt8173-vcodec-dec" for MT8173 decoder.
-  "mediatek,mt8183-vcodec-dec" for MT8183 decoder.
   "mediatek,mt8192-vcodec-enc" for MT8192 encoder.
   "mediatek,mt8195-vcodec-enc" for MT8195 encoder.
-- reg : Physical base address of the video codec registers and length of
+- reg : Physical base address of the video encodec registers and length of
   memory mapped region.
 - interrupts : interrupt number to the cpu.
+- mediatek,larb : must contain the local arbiters in the current Socs.
 - clocks : list of clock specifiers, corresponding to entries in
   the clock-names property.
 - clock-names: avc encoder must contain "venc_sel", vp8 encoder must
@@ -22,7 +21,7 @@ Required properties:
   "clk_cci400_sel", "vdec_sel", "vdecpll", "vencpll", "venc_lt_sel",
   "vdec_bus_clk_src".
 - iommus : should point to the respective IOMMU block with master port as
-  argument, see Documentation/devicetree/bindings/iommu/mediatek,iommu.yaml
+  argument, see Documentation/devicetree/bindings/iommu/mediatek,iommu.txt
   for details.
 - dma-ranges : describes the dma address range space that the codec hw access.
 One of the two following nodes:
@@ -32,58 +31,6 @@ One of the two following nodes:
 
 Example:
 
-vcodec_dec: vcodec@16000000 {
-    compatible = "mediatek,mt8173-vcodec-dec";
-    reg = <0 0x16000000 0 0x100>,   /*VDEC_SYS*/
-          <0 0x16020000 0 0x1000>,  /*VDEC_MISC*/
-          <0 0x16021000 0 0x800>,   /*VDEC_LD*/
-          <0 0x16021800 0 0x800>,   /*VDEC_TOP*/
-          <0 0x16022000 0 0x1000>,  /*VDEC_CM*/
-          <0 0x16023000 0 0x1000>,  /*VDEC_AD*/
-          <0 0x16024000 0 0x1000>,  /*VDEC_AV*/
-          <0 0x16025000 0 0x1000>,  /*VDEC_PP*/
-          <0 0x16026800 0 0x800>,   /*VP8_VD*/
-          <0 0x16027000 0 0x800>,   /*VP6_VD*/
-          <0 0x16027800 0 0x800>,   /*VP8_VL*/
-          <0 0x16028400 0 0x400>;   /*VP9_VD*/
-    interrupts = <GIC_SPI 204 IRQ_TYPE_LEVEL_LOW>;
-    iommus = <&iommu M4U_PORT_HW_VDEC_MC_EXT>,
-             <&iommu M4U_PORT_HW_VDEC_PP_EXT>,
-             <&iommu M4U_PORT_HW_VDEC_AVC_MV_EXT>,
-             <&iommu M4U_PORT_HW_VDEC_PRED_RD_EXT>,
-             <&iommu M4U_PORT_HW_VDEC_PRED_WR_EXT>,
-             <&iommu M4U_PORT_HW_VDEC_UFO_EXT>,
-             <&iommu M4U_PORT_HW_VDEC_VLD_EXT>,
-             <&iommu M4U_PORT_HW_VDEC_VLD2_EXT>;
-    mediatek,vpu = <&vpu>;
-    power-domains = <&scpsys MT8173_POWER_DOMAIN_VDEC>;
-    clocks = <&apmixedsys CLK_APMIXED_VCODECPLL>,
-             <&topckgen CLK_TOP_UNIVPLL_D2>,
-             <&topckgen CLK_TOP_CCI400_SEL>,
-             <&topckgen CLK_TOP_VDEC_SEL>,
-             <&topckgen CLK_TOP_VCODECPLL>,
-             <&apmixedsys CLK_APMIXED_VENCPLL>,
-             <&topckgen CLK_TOP_VENC_LT_SEL>,
-             <&topckgen CLK_TOP_VCODECPLL_370P5>;
-    clock-names = "vcodecpll",
-                  "univpll_d2",
-                  "clk_cci400_sel",
-                  "vdec_sel",
-                  "vdecpll",
-                  "vencpll",
-                  "venc_lt_sel",
-                  "vdec_bus_clk_src";
-    assigned-clocks = <&topckgen CLK_TOP_VENC_LT_SEL>,
-                      <&topckgen CLK_TOP_CCI400_SEL>,
-                      <&topckgen CLK_TOP_VDEC_SEL>,
-                      <&apmixedsys CLK_APMIXED_VCODECPLL>,
-                      <&apmixedsys CLK_APMIXED_VENCPLL>;
-    assigned-clock-parents = <&topckgen CLK_TOP_VCODECPLL_370P5>,
-                             <&topckgen CLK_TOP_UNIVPLL_D2>,
-                             <&topckgen CLK_TOP_VCODECPLL>;
-    assigned-clock-rates = <0>, <0>, <0>, <1482000000>, <800000000>;
-  };
-
 vcodec_enc_avc: vcodec@18002000 {
     compatible = "mediatek,mt8173-vcodec-enc";
     reg = <0 0x18002000 0 0x1000>;
diff --git a/Documentation/devicetree/bindings/memory-controllers/mediatek,smi-common.yaml b/Documentation/devicetree/bindings/memory-controllers/mediatek,smi-common.yaml
index a08a32340987fb00c17387e795db7b24a6f14ba8..c794959cda967cb53948eb62733693bf702f2130 100644
--- a/Documentation/devicetree/bindings/memory-controllers/mediatek,smi-common.yaml
+++ b/Documentation/devicetree/bindings/memory-controllers/mediatek,smi-common.yaml
@@ -16,7 +16,7 @@ description: |
   MediaTek SMI have two generations of HW architecture, here is the list
   which generation the SoCs use:
   generation 1: mt2701 and mt7623.
-  generation 2: mt2712, mt6779, mt8167, mt8173, mt8183 and mt8192.
+  generation 2: mt2712, mt6779, mt8167, mt8173, mt8183, mt8192 and mt8195.
 
   There's slight differences between the two SMI, for generation 2, the
   register which control the iommu port is at each larb's register base. But
@@ -36,6 +36,9 @@ properties:
           - mediatek,mt8173-smi-common
           - mediatek,mt8183-smi-common
           - mediatek,mt8192-smi-common
+          - mediatek,mt8195-smi-common-vdo
+          - mediatek,mt8195-smi-common-vpp
+          - mediatek,mt8195-smi-sub-common
 
       - description: for mt7623
         items:
@@ -67,6 +70,14 @@ properties:
     minItems: 2
     maxItems: 4
 
+  mediatek,smi:
+    $ref: /schemas/types.yaml#/definitions/phandle
+    description: a phandle to the smi-common node above. Only for sub-common.
+
+  mediatek,smi_sub_common:
+    type: boolean
+    description: Indicate if this is smi-sub-common.
+
 required:
   - compatible
   - reg
@@ -93,6 +104,27 @@ allOf:
             - const: smi
             - const: async
 
+  - if:  # only for sub common
+      properties:
+        compatible:
+          contains:
+            enum:
+              - mediatek,mt8195-smi-sub-common
+    then:
+      required:
+        - mediatek,smi
+        - mediatek,smi_sub_common
+      properties:
+        clock:
+          items:
+            minItems: 3
+            maxItems: 3
+        clock-names:
+          items:
+            - const: apb
+            - const: smi
+            - const: gals0
+
   - if:  # for gen2 HW that have gals
       properties:
         compatible:
@@ -100,6 +132,8 @@ allOf:
             - mediatek,mt6779-smi-common
             - mediatek,mt8183-smi-common
             - mediatek,mt8192-smi-common
+            - mediatek,mt8195-smi-common-vdo
+            - mediatek,mt8195-smi-common-vpp
 
     then:
       properties:
diff --git a/Documentation/devicetree/bindings/memory-controllers/mediatek,smi-larb.yaml b/Documentation/devicetree/bindings/memory-controllers/mediatek,smi-larb.yaml
index 7ed7839ff0a77856ede2761df00e64c838303964..a100283903bd11c3bc14b3d838bdd49399cfc31c 100644
--- a/Documentation/devicetree/bindings/memory-controllers/mediatek,smi-larb.yaml
+++ b/Documentation/devicetree/bindings/memory-controllers/mediatek,smi-larb.yaml
@@ -24,6 +24,7 @@ properties:
           - mediatek,mt8173-smi-larb
           - mediatek,mt8183-smi-larb
           - mediatek,mt8192-smi-larb
+          - mediatek,mt8195-smi-larb
 
       - description: for mt7623
         items:
@@ -75,6 +76,7 @@ allOf:
         compatible:
           enum:
             - mediatek,mt8183-smi-larb
+            - mediatek,mt8195-smi-larb
 
     then:
       properties:
@@ -109,6 +111,7 @@ allOf:
               - mediatek,mt6779-smi-larb
               - mediatek,mt8167-smi-larb
               - mediatek,mt8192-smi-larb
+              - mediatek,mt8195-smi-larb
 
     then:
       required:
diff --git a/Documentation/devicetree/bindings/pci/mediatek-pcie-gen3.yaml b/Documentation/devicetree/bindings/pci/mediatek-pcie-gen3.yaml
index e7b1f9892da435824d36b3a623e1faa14fb9cc22..d5e4a3e63d97e3f9a5a2daf498fb9120372778ad 100644
--- a/Documentation/devicetree/bindings/pci/mediatek-pcie-gen3.yaml
+++ b/Documentation/devicetree/bindings/pci/mediatek-pcie-gen3.yaml
@@ -48,7 +48,9 @@ allOf:
 
 properties:
   compatible:
-    const: mediatek,mt8192-pcie
+    oneOf:
+      - const: mediatek,mt8192-pcie
+      - const: mediatek,mt8195-pcie
 
   reg:
     maxItems: 1
diff --git a/Documentation/devicetree/bindings/power/mediatek,power-controller.yaml b/Documentation/devicetree/bindings/power/mediatek,power-controller.yaml
index 3a2ea00d7fa199a9bac051ee678457ab9a0d9bba..43b1d4ba42d1245bfbd1067c589c13155320e55f 100644
--- a/Documentation/devicetree/bindings/power/mediatek,power-controller.yaml
+++ b/Documentation/devicetree/bindings/power/mediatek,power-controller.yaml
@@ -26,6 +26,7 @@ properties:
       - mediatek,mt8173-power-controller
       - mediatek,mt8183-power-controller
       - mediatek,mt8192-power-controller
+      - mediatek,mt8195-power-controller
 
   '#power-domain-cells':
     const: 1
@@ -62,6 +63,7 @@ patternProperties:
               "include/dt-bindings/power/mt8173-power.h" - for MT8173 type power domain.
               "include/dt-bindings/power/mt8183-power.h" - for MT8183 type power domain.
               "include/dt-bindings/power/mt8192-power.h" - for MT8192 type power domain.
+              "include/dt-bindings/power/mt8195-power.h" - for MT8195 type power domain.
         maxItems: 1
 
       clocks:
diff --git a/Documentation/devicetree/bindings/soc/mediatek/mtk-svs.yaml b/Documentation/devicetree/bindings/soc/mediatek/mtk-svs.yaml
index a855ced410f8fced1970ec9eb7946f41df13e71c..fdd656448454c295a3192861e2f46f079a84b25d 100644
--- a/Documentation/devicetree/bindings/soc/mediatek/mtk-svs.yaml
+++ b/Documentation/devicetree/bindings/soc/mediatek/mtk-svs.yaml
@@ -22,6 +22,8 @@ properties:
   compatible:
     enum:
       - mediatek,mt8183-svs
+      - mediatek,mt8192-svs
+      - mediatek,mt8195-svs
 
   reg:
     maxItems: 1
@@ -51,6 +53,13 @@ properties:
       - const: svs-calibration-data
       - const: t-calibration-data
 
+  resets:
+    maxItems: 1
+
+  reset-names:
+    items:
+      - const: svs_rst
+
 required:
   - compatible
   - reg
diff --git a/Documentation/devicetree/bindings/sound/mt8195-mt6359-rt1011-rt5682.yaml b/Documentation/devicetree/bindings/sound/mt8195-mt6359-rt1011-rt5682.yaml
new file mode 100644
index 0000000000000000000000000000000000000000..d354c30d3377e259fa5a71429d883fc12e20b974
--- /dev/null
+++ b/Documentation/devicetree/bindings/sound/mt8195-mt6359-rt1011-rt5682.yaml
@@ -0,0 +1,47 @@
+# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/sound/mt8195-mt6359-rt1011-rt5682.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: Mediatek MT8195 with MT6359, RT1011 and RT5682 ASoC sound card driver
+
+maintainers:
+  - Trevor Wu <trevor.wu@mediatek.com>
+
+description:
+  This binding describes the MT8195 sound card with RT1011 and RT5682.
+
+properties:
+  compatible:
+    const: mediatek,mt8195_mt6359_rt1011_rt5682
+
+  mediatek,platform:
+    $ref: "/schemas/types.yaml#/definitions/phandle"
+    description: The phandle of MT8195 ASoC platform.
+
+  mediatek,dptx-codec:
+    $ref: "/schemas/types.yaml#/definitions/phandle"
+    description: The phandle of MT8195 Display Port Tx codec node.
+
+  mediatek,hdmi-codec:
+    $ref: "/schemas/types.yaml#/definitions/phandle"
+    description: The phandle of MT8195 HDMI codec node.
+
+additionalProperties: false
+
+required:
+  - compatible
+  - mediatek,platform
+
+examples:
+  - |
+
+    sound: mt8195-sound {
+        compatible = "mediatek,mt8195_mt6359_rt1011_rt5682";
+        mediatek,platform = <&afe>;
+        pinctrl-names = "default";
+        pinctrl-0 = <&aud_pins_default>;
+    };
+
+...
diff --git a/Documentation/devicetree/bindings/spmi/mtk,spmi-mtk-pmif.yaml b/Documentation/devicetree/bindings/spmi/mtk,spmi-mtk-pmif.yaml
new file mode 100644
index 0000000000000000000000000000000000000000..a43b0302d503607afc30a75a15a9480abc1b5662
--- /dev/null
+++ b/Documentation/devicetree/bindings/spmi/mtk,spmi-mtk-pmif.yaml
@@ -0,0 +1,74 @@
+# SPDX-License-Identifier: (GPL-2.0 OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/spmi/mtk,spmi-mtk-pmif.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: Mediatek SPMI Controller Device Tree Bindings
+
+maintainers:
+  - Hsin-Hsiung Wang <hsin-hsiung.wang@mediatek.com>
+
+description: |+
+  On MediaTek SoCs the PMIC is connected via SPMI and the controller allows
+  for multiple SoCs to control a single SPMI master.
+
+allOf:
+  - $ref: "spmi.yaml"
+
+properties:
+  compatible:
+    const: mediatek,mt6873-spmi
+
+  reg:
+    maxItems: 2
+
+  reg-names:
+    items:
+      - const: pmif
+      - const: spmimst
+
+  clocks:
+    minItems: 3
+    maxItems: 3
+
+  clock-names:
+    items:
+      - const: pmif_sys_ck
+      - const: pmif_tmr_ck
+      - const: spmimst_clk_mux
+
+  assigned-clocks:
+    maxItems: 1
+
+  assigned-clock-parents:
+    maxItems: 1
+
+required:
+  - compatible
+  - reg
+  - reg-names
+  - clocks
+  - clock-names
+
+unevaluatedProperties: false
+
+examples:
+  - |
+    #include <dt-bindings/clock/mt8192-clk.h>
+
+    spmi: spmi@10027000 {
+        compatible = "mediatek,mt6873-spmi";
+        reg = <0 0x10027000 0 0x000e00>,
+              <0 0x10029000 0 0x000100>;
+        reg-names = "pmif", "spmimst";
+        clocks = <&infracfg CLK_INFRA_PMIC_AP>,
+                 <&infracfg CLK_INFRA_PMIC_TMR>,
+                 <&topckgen CLK_TOP_SPMI_MST_SEL>;
+        clock-names = "pmif_sys_ck",
+                      "pmif_tmr_ck",
+                      "spmimst_clk_mux";
+        assigned-clocks = <&topckgen CLK_TOP_PWRAP_ULPOSC_SEL>;
+        assigned-clock-parents = <&topckgen CLK_TOP_OSC_D10>;
+    };
+...
diff --git a/Documentation/devicetree/bindings/spmi/spmi.yaml b/Documentation/devicetree/bindings/spmi/spmi.yaml
index 1739409307199bd2a08df59b04864e6cdad23bea..12dbf6567d16685b71f26fc828754568e54852e9 100644
--- a/Documentation/devicetree/bindings/spmi/spmi.yaml
+++ b/Documentation/devicetree/bindings/spmi/spmi.yaml
@@ -25,7 +25,7 @@ properties:
     pattern: "^spmi@.*"
 
   reg:
-    maxItems: 1
+    minItems: 1
 
   "#address-cells":
     const: 2
diff --git a/Documentation/devicetree/bindings/thermal/mediatek-thermal-lvts.yaml b/Documentation/devicetree/bindings/thermal/mediatek-thermal-lvts.yaml
new file mode 100644
index 0000000000000000000000000000000000000000..0c6535abeb8122f788e521989038e0f1d9421c9e
--- /dev/null
+++ b/Documentation/devicetree/bindings/thermal/mediatek-thermal-lvts.yaml
@@ -0,0 +1,81 @@
+# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/thermal/mediatek-thermal-lvts.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: Mediatek SoC LVTS thermal controller (DTS) binding
+
+maintainers:
+  - Yu-Chia Chang <ethan.chang@mediatek.com>
+  - Michael Kao <michael.kao@mediatek.com>
+
+properties:
+  compatible:
+    const: mediatek,mt6873-lvts
+
+  reg:
+    maxItems: 1
+
+  interrupts:
+    maxItems: 1
+
+  clocks:
+    maxItems: 1
+
+  clock-names:
+    items:
+      - const: lvts_clk
+
+  "#thermal-sensor-cells":
+    const: 0
+
+required:
+  - "#thermal-sensor-cells"
+  - compatible
+  - reg
+  - interrupts
+  - clocks
+  - clock-names
+
+additionalProperties: false
+
+examples:
+  - |
+    #include <dt-bindings/thermal/thermal.h>
+    #include <dt-bindings/interrupt-controller/arm-gic.h>
+    #include <dt-bindings/clock/mt8192-clk.h>
+    dts: lvts@1100b000 {
+        compatible = "mediatek,mt6873-lvts";
+        reg = <0x1100b000 0x1000>;
+        clocks = <&infracfg CLK_INFRA_THERM>;
+        clock-names = "lvts_clk";
+        #thermal-sensor-cells = <0>;
+        interrupts = <GIC_SPI 147 IRQ_TYPE_LEVEL_HIGH>;
+    };
+
+    thermal-zones {
+        cpu_thermal: cpu-thermal {
+            polling-delay-passive = <0>;
+            polling-delay = <0>;
+
+            thermal-sensors = <&dts>;
+            trips {
+                cpu_alert1: cpu-alert1 {
+                    temperature = <85000>;
+                    hysteresis = <0>;
+                    type = "passive";
+                };
+
+                cpu_crit: cpu-crit {
+                    temperature = <120000>;
+                    hysteresis = <0>;
+                    type = "critical";
+                };
+            };
+
+            cooling-maps {
+            };
+        };
+    };
+...
diff --git a/README b/README
index 669ac7c32292798644b21dbb5a0dc657125f444d..9e61c76d91a3e5f62f116865497a9d692863ff83 100644
--- a/README
+++ b/README
@@ -16,3 +16,14 @@ several of them using the Restructured Text markup notation.
 Please read the Documentation/process/changes.rst file, as it contains the
 requirements for building and running the kernel, and information about
 the problems which may result by upgrading your kernel.
+driver-clock
+driver-power
+driver-infra
+driver-iommu
+driver-vdosys
+driver-display
+driver-vcodec
+config
+mt8195.dtsi
+mt8195-cherry.dtsi
+cherry TOT
diff --git a/arch/arm64/boot/dts/mediatek/Makefile b/arch/arm64/boot/dts/mediatek/Makefile
index 103adebcc4376194a971d7fb49370578b61728ba..72a240b88c16ac66ef04ad3e86a1e3fbd1570fce 100644
--- a/arch/arm64/boot/dts/mediatek/Makefile
+++ b/arch/arm64/boot/dts/mediatek/Makefile
@@ -46,3 +46,6 @@ dtb-$(CONFIG_ARCH_MEDIATEK) += mt8183-kukui-krane-sku0.dtb
 dtb-$(CONFIG_ARCH_MEDIATEK) += mt8183-kukui-krane-sku176.dtb
 dtb-$(CONFIG_ARCH_MEDIATEK) += mt8516-pumpkin.dtb
 dtb-$(CONFIG_ARCH_MEDIATEK) += mt8192-evb.dtb
+dtb-$(CONFIG_ARCH_MEDIATEK) += mt8195-evb.dtb
+dtb-$(CONFIG_ARCH_MEDIATEK) += mt8195-cherry.dtb
+dtb-$(CONFIG_ARCH_MEDIATEK) += mt8195-tomato.dtb
diff --git a/arch/arm64/boot/dts/mediatek/mt6359.dtsi b/arch/arm64/boot/dts/mediatek/mt6359.dtsi
new file mode 100644
index 0000000000000000000000000000000000000000..4bd85e33a4c9098904dfd4b7b171ba6b0dbca400
--- /dev/null
+++ b/arch/arm64/boot/dts/mediatek/mt6359.dtsi
@@ -0,0 +1,298 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2020 MediaTek Inc.
+ */
+
+&pwrap {
+	pmic: pmic {
+		compatible = "mediatek,mt6359";
+		interrupt-controller;
+		#interrupt-cells = <2>;
+
+		mt6359codec: mt6359codec {
+		};
+
+		mt6359regulator: regulators {
+			mt6359_vs1_buck_reg: buck_vs1 {
+				regulator-name = "vs1";
+				regulator-min-microvolt = <800000>;
+				regulator-max-microvolt = <2200000>;
+				regulator-enable-ramp-delay = <0>;
+				regulator-always-on;
+			};
+			mt6359_vgpu11_buck_reg: buck_vgpu11 {
+				regulator-name = "vgpu11";
+				regulator-min-microvolt = <400000>;
+				regulator-max-microvolt = <1193750>;
+				regulator-ramp-delay = <5000>;
+				regulator-enable-ramp-delay = <200>;
+				regulator-allowed-modes = <0 1 2>;
+			};
+			mt6359_vmodem_buck_reg: buck_vmodem {
+				regulator-name = "vmodem";
+				regulator-min-microvolt = <400000>;
+				regulator-max-microvolt = <1100000>;
+				regulator-ramp-delay = <10760>;
+				regulator-enable-ramp-delay = <200>;
+			};
+			mt6359_vpu_buck_reg: buck_vpu {
+				regulator-name = "vpu";
+				regulator-min-microvolt = <400000>;
+				regulator-max-microvolt = <1193750>;
+				regulator-ramp-delay = <5000>;
+				regulator-enable-ramp-delay = <200>;
+				regulator-allowed-modes = <0 1 2>;
+			};
+			mt6359_vcore_buck_reg: buck_vcore {
+				regulator-name = "vcore";
+				regulator-min-microvolt = <400000>;
+				regulator-max-microvolt = <1300000>;
+				regulator-ramp-delay = <5000>;
+				regulator-enable-ramp-delay = <200>;
+				regulator-allowed-modes = <0 1 2>;
+			};
+			mt6359_vs2_buck_reg: buck_vs2 {
+				regulator-name = "vs2";
+				regulator-min-microvolt = <800000>;
+				regulator-max-microvolt = <1600000>;
+				regulator-enable-ramp-delay = <0>;
+				regulator-always-on;
+			};
+			mt6359_vpa_buck_reg: buck_vpa {
+				regulator-name = "vpa";
+				regulator-min-microvolt = <500000>;
+				regulator-max-microvolt = <3650000>;
+				regulator-enable-ramp-delay = <300>;
+			};
+			mt6359_vproc2_buck_reg: buck_vproc2 {
+				regulator-name = "vproc2";
+				regulator-min-microvolt = <400000>;
+				regulator-max-microvolt = <1193750>;
+				regulator-ramp-delay = <7500>;
+				regulator-enable-ramp-delay = <200>;
+				regulator-allowed-modes = <0 1 2>;
+			};
+			mt6359_vproc1_buck_reg: buck_vproc1 {
+				regulator-name = "vproc1";
+				regulator-min-microvolt = <400000>;
+				regulator-max-microvolt = <1193750>;
+				regulator-ramp-delay = <7500>;
+				regulator-enable-ramp-delay = <200>;
+				regulator-allowed-modes = <0 1 2>;
+			};
+			mt6359_vcore_sshub_buck_reg: buck_vcore_sshub {
+				regulator-name = "vcore_sshub";
+				regulator-min-microvolt = <400000>;
+				regulator-max-microvolt = <1193750>;
+			};
+			mt6359_vgpu11_sshub_buck_reg: buck_vgpu11_sshub {
+				regulator-name = "vgpu11_sshub";
+				regulator-min-microvolt = <400000>;
+				regulator-max-microvolt = <1193750>;
+			};
+			mt6359_vaud18_ldo_reg: ldo_vaud18 {
+				regulator-name = "vaud18";
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-enable-ramp-delay = <240>;
+			};
+			mt6359_vsim1_ldo_reg: ldo_vsim1 {
+				regulator-name = "vsim1";
+				regulator-min-microvolt = <1700000>;
+				regulator-max-microvolt = <3100000>;
+			};
+			mt6359_vibr_ldo_reg: ldo_vibr {
+				regulator-name = "vibr";
+				regulator-min-microvolt = <1200000>;
+				regulator-max-microvolt = <3300000>;
+			};
+			mt6359_vrf12_ldo_reg: ldo_vrf12 {
+				regulator-name = "vrf12";
+				regulator-min-microvolt = <1100000>;
+				regulator-max-microvolt = <1300000>;
+			};
+			mt6359_vusb_ldo_reg: ldo_vusb {
+				regulator-name = "vusb";
+				regulator-min-microvolt = <3000000>;
+				regulator-max-microvolt = <3000000>;
+				regulator-enable-ramp-delay = <960>;
+				regulator-always-on;
+			};
+			mt6359_vsram_proc2_ldo_reg: ldo_vsram_proc2 {
+				regulator-name = "vsram_proc2";
+				regulator-min-microvolt = <500000>;
+				regulator-max-microvolt = <1293750>;
+				regulator-ramp-delay = <7500>;
+				regulator-enable-ramp-delay = <240>;
+				regulator-always-on;
+			};
+			mt6359_vio18_ldo_reg: ldo_vio18 {
+				regulator-name = "vio18";
+				regulator-min-microvolt = <1700000>;
+				regulator-max-microvolt = <1900000>;
+				regulator-enable-ramp-delay = <960>;
+				regulator-always-on;
+			};
+			mt6359_vcamio_ldo_reg: ldo_vcamio {
+				regulator-name = "vcamio";
+				regulator-min-microvolt = <1700000>;
+				regulator-max-microvolt = <1900000>;
+			};
+			mt6359_vcn18_ldo_reg: ldo_vcn18 {
+				regulator-name = "vcn18";
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-enable-ramp-delay = <240>;
+			};
+			mt6359_vfe28_ldo_reg: ldo_vfe28 {
+				regulator-name = "vfe28";
+				regulator-min-microvolt = <2800000>;
+				regulator-max-microvolt = <2800000>;
+				regulator-enable-ramp-delay = <120>;
+			};
+			mt6359_vcn13_ldo_reg: ldo_vcn13 {
+				regulator-name = "vcn13";
+				regulator-min-microvolt = <900000>;
+				regulator-max-microvolt = <1300000>;
+			};
+			mt6359_vcn33_1_bt_ldo_reg: ldo_vcn33_1_bt {
+				regulator-name = "vcn33_1_bt";
+				regulator-min-microvolt = <2800000>;
+				regulator-max-microvolt = <3500000>;
+			};
+			mt6359_vcn33_1_wifi_ldo_reg: ldo_vcn33_1_wifi {
+				regulator-name = "vcn33_1_wifi";
+				regulator-min-microvolt = <2800000>;
+				regulator-max-microvolt = <3500000>;
+			};
+			mt6359_vaux18_ldo_reg: ldo_vaux18 {
+				regulator-name = "vaux18";
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-enable-ramp-delay = <240>;
+				regulator-always-on;
+			};
+			mt6359_vsram_others_ldo_reg: ldo_vsram_others {
+				regulator-name = "vsram_others";
+				regulator-min-microvolt = <500000>;
+				regulator-max-microvolt = <1293750>;
+				regulator-ramp-delay = <5000>;
+				regulator-enable-ramp-delay = <240>;
+			};
+			mt6359_vefuse_ldo_reg: ldo_vefuse {
+				regulator-name = "vefuse";
+				regulator-min-microvolt = <1700000>;
+				regulator-max-microvolt = <2000000>;
+			};
+			mt6359_vxo22_ldo_reg: ldo_vxo22 {
+				regulator-name = "vxo22";
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <2200000>;
+				regulator-always-on;
+			};
+			mt6359_vrfck_ldo_reg: ldo_vrfck {
+				regulator-name = "vrfck";
+				regulator-min-microvolt = <1500000>;
+				regulator-max-microvolt = <1700000>;
+			};
+			mt6359_vrfck_1_ldo_reg: ldo_vrfck_1 {
+				regulator-name = "vrfck";
+				regulator-min-microvolt = <1240000>;
+				regulator-max-microvolt = <1600000>;
+			};
+			mt6359_vbif28_ldo_reg: ldo_vbif28 {
+				regulator-name = "vbif28";
+				regulator-min-microvolt = <2800000>;
+				regulator-max-microvolt = <2800000>;
+				regulator-enable-ramp-delay = <240>;
+			};
+			mt6359_vio28_ldo_reg: ldo_vio28 {
+				regulator-name = "vio28";
+				regulator-min-microvolt = <2800000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+			mt6359_vemc_ldo_reg: ldo_vemc {
+				regulator-name = "vemc";
+				regulator-min-microvolt = <2900000>;
+				regulator-max-microvolt = <3300000>;
+			};
+			mt6359_vemc_1_ldo_reg: ldo_vemc_1 {
+				regulator-name = "vemc";
+				regulator-min-microvolt = <2500000>;
+				regulator-max-microvolt = <3300000>;
+			};
+			mt6359_vcn33_2_bt_ldo_reg: ldo_vcn33_2_bt {
+				regulator-name = "vcn33_2_bt";
+				regulator-min-microvolt = <2800000>;
+				regulator-max-microvolt = <3500000>;
+			};
+			mt6359_vcn33_2_wifi_ldo_reg: ldo_vcn33_2_wifi {
+				regulator-name = "vcn33_2_wifi";
+				regulator-min-microvolt = <2800000>;
+				regulator-max-microvolt = <3500000>;
+			};
+			mt6359_va12_ldo_reg: ldo_va12 {
+				regulator-name = "va12";
+				regulator-min-microvolt = <1200000>;
+				regulator-max-microvolt = <1300000>;
+				regulator-always-on;
+			};
+			mt6359_va09_ldo_reg: ldo_va09 {
+				regulator-name = "va09";
+				regulator-min-microvolt = <800000>;
+				regulator-max-microvolt = <1200000>;
+			};
+			mt6359_vrf18_ldo_reg: ldo_vrf18 {
+				regulator-name = "vrf18";
+				regulator-min-microvolt = <1700000>;
+				regulator-max-microvolt = <1810000>;
+			};
+			mt6359_vsram_md_ldo_reg: ldo_vsram_md {
+				regulator-name = "vsram_md";
+				regulator-min-microvolt = <500000>;
+				regulator-max-microvolt = <1293750>;
+				regulator-ramp-delay = <10760>;
+				regulator-enable-ramp-delay = <240>;
+			};
+			mt6359_vufs_ldo_reg: ldo_vufs {
+				regulator-name = "vufs";
+				regulator-min-microvolt = <1700000>;
+				regulator-max-microvolt = <1900000>;
+			};
+			mt6359_vm18_ldo_reg: ldo_vm18 {
+				regulator-name = "vm18";
+				regulator-min-microvolt = <1700000>;
+				regulator-max-microvolt = <1900000>;
+				regulator-always-on;
+			};
+			mt6359_vbbck_ldo_reg: ldo_vbbck {
+				regulator-name = "vbbck";
+				regulator-min-microvolt = <1100000>;
+				regulator-max-microvolt = <1200000>;
+			};
+			mt6359_vsram_proc1_ldo_reg: ldo_vsram_proc1 {
+				regulator-name = "vsram_proc1";
+				regulator-min-microvolt = <500000>;
+				regulator-max-microvolt = <1293750>;
+				regulator-ramp-delay = <7500>;
+				regulator-enable-ramp-delay = <240>;
+				regulator-always-on;
+			};
+			mt6359_vsim2_ldo_reg: ldo_vsim2 {
+				regulator-name = "vsim2";
+				regulator-min-microvolt = <1700000>;
+				regulator-max-microvolt = <3100000>;
+			};
+			mt6359_vsram_others_sshub_ldo: ldo_vsram_others_sshub {
+				regulator-name = "vsram_others_sshub";
+				regulator-min-microvolt = <500000>;
+				regulator-max-microvolt = <1293750>;
+			};
+		};
+
+		mt6359rtc: mt6359rtc {
+			compatible = "mediatek,mt6358-rtc";
+		};
+	};
+};
diff --git a/arch/arm64/boot/dts/mediatek/mt8195-cherry.dts b/arch/arm64/boot/dts/mediatek/mt8195-cherry.dts
new file mode 100644
index 0000000000000000000000000000000000000000..d757fbeb0589db94673826a5e418bf30beadecfd
--- /dev/null
+++ b/arch/arm64/boot/dts/mediatek/mt8195-cherry.dts
@@ -0,0 +1,39 @@
+// SPDX-License-Identifier: (GPL-2.0 OR MIT)
+/*
+ * Copyright (C) 2021 MediaTek Inc.
+ */
+/dts-v1/;
+#include "mt8195-cherry.dtsi"
+
+/ {
+	model = "MediaTek Cherry board";
+	compatible = "google,cherry", "mediatek,mt8195";
+};
+
+&subpmic_mtk_regulator {
+	mt_pmic_vmc_ldo_reg: ldo3 {
+		regulator-compatible = "LDO3";
+		regulator-name = "mt6360,ldo3";
+		regulator-min-microvolt = <1200000>;
+		regulator-max-microvolt = <3600000>;
+		regulator-allowed-modes = <0 2>;
+	};
+
+	mt_pmic_vmch_ldo_reg: ldo5 {
+		regulator-compatible = "LDO5";
+		regulator-name = "mt6360,ldo5";
+		regulator-min-microvolt = <2700000>;
+		regulator-max-microvolt = <3600000>;
+		regulator-allowed-modes = <0 2>;
+	};
+};
+
+&sound {
+	compatible = "mediatek,mt8195_mt6359_rt1019_rt5682";
+	mediatek,dptx-codec = <&dp_tx>;
+	mediatek,hdmi-codec = <&hdmi0>;
+};
+
+&rt1019p {
+	status = "okay";
+};
diff --git a/arch/arm64/boot/dts/mediatek/mt8195-cherry.dtsi b/arch/arm64/boot/dts/mediatek/mt8195-cherry.dtsi
new file mode 100644
index 0000000000000000000000000000000000000000..56d2671b90d5d78f91c130af5c10a01bbdf7f9eb
--- /dev/null
+++ b/arch/arm64/boot/dts/mediatek/mt8195-cherry.dtsi
@@ -0,0 +1,1330 @@
+// SPDX-License-Identifier: (GPL-2.0 OR MIT)
+/*
+ * Copyright (C) 2021 MediaTek Inc.
+ */
+/dts-v1/;
+#include <dt-bindings/gpio/gpio.h>
+#include "mt8195.dtsi"
+#include "mt6359.dtsi"
+
+/ {
+	aliases {
+		serial0 = &uart0;
+		i2c0 = &i2c0;
+		i2c1 = &i2c1;
+		i2c2 = &i2c2;
+		i2c3 = &i2c3;
+		i2c4 = &i2c4;
+		i2c5 = &i2c5;
+		i2c7 = &i2c7;
+		mmc0 = &mmc0;
+		mmc1 = &mmc1;
+	};
+
+	backlight_lcd0: backlight_lcd0 {
+		compatible = "pwm-backlight";
+		pwms = <&disp_pwm0 0 500000>;
+		enable-gpios = <&pio 82 GPIO_ACTIVE_HIGH>;
+		brightness-levels = <0 1023>;
+		num-interpolated-steps = <1023>;
+		default-brightness-level = <576>;
+		status = "okay";
+	};
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+	};
+
+	memory@40000000 {
+		device_type = "memory";
+		reg = <0 0x40000000 0 0x80000000>;
+	};
+
+	rt1019p: rt1019p {
+		compatible = "realtek,rt1019p";
+		pinctrl-names = "default";
+		pinctrl-0 = <&rt1019p_pins_default>;
+		sdb-gpios = <&pio 100 GPIO_ACTIVE_HIGH>;
+		status = "disabled";
+	};
+
+	usb_p0_vbus: regulator@2 {
+		compatible = "regulator-fixed";
+		regulator-name = "vbus0";
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		enable-active-high;
+		regulator-always-on;
+	};
+
+	usb_p1_vbus: regulator@3 {
+		compatible = "regulator-fixed";
+		regulator-name = "vbus1";
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		enable-active-high;
+		regulator-always-on;
+	};
+
+	usb_p2_vbus: regulator@4 {
+		compatible = "regulator-fixed";
+		regulator-name = "vbus2";
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		enable-active-high;
+		regulator-always-on;
+	};
+
+	usb_p3_vbus: regulator@5 {
+		compatible = "regulator-fixed";
+		regulator-name = "vbus3";
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		enable-active-high;
+		regulator-always-on;
+	};
+
+	tboard_thermistor1: tboard_thermistor1 {
+		compatible = "generic-adc-thermal";
+		#thermal-sensor-cells = <0>;
+		io-channels = <&auxadc 0>;
+		io-channel-names = "sensor-channel";
+		temperature-lookup-table = <    (-5000) 4241
+                                                0 4063
+                                                5000 3856
+                                                10000 3621
+                                                15000 3364
+                                                20000 3091
+                                                25000 2810
+                                                30000 2526
+                                                35000 2247
+                                                40000 1982
+                                                45000 1734
+                                                50000 1507
+                                                55000 1305
+                                                60000 1122
+                                                65000 964
+                                                70000 827
+                                                75000 710
+                                                80000 606
+                                                85000 519
+                                                90000 445
+                                                95000 382
+                                                100000 330
+                                                105000 284
+                                                110000 245
+                                                115000 213
+                                                120000 183
+                                                125000 161>;
+
+	};
+
+	tboard_thermistor2: tboard_thermistor2 {
+		compatible = "generic-adc-thermal";
+		#thermal-sensor-cells = <0>;
+		io-channels = <&auxadc 0>;
+		io-channel-names = "sensor-channel";
+		temperature-lookup-table = <    (-5000) 4241
+                                                0 4063
+                                                5000 3856
+                                                10000 3621
+                                                15000 3364
+                                                20000 3091
+                                                25000 2810
+                                                30000 2526
+                                                35000 2247
+                                                40000 1982
+                                                45000 1734
+                                                50000 1507
+                                                55000 1305
+                                                60000 1122
+                                                65000 964
+                                                70000 827
+                                                75000 710
+                                                80000 606
+                                                85000 519
+                                                90000 445
+                                                95000 382
+                                                100000 330
+                                                105000 284
+                                                110000 245
+                                                115000 213
+                                                120000 183
+                                                125000 161>;
+	};
+
+	tboard_thermistor3: tboard_thermistor3 {
+		compatible = "generic-adc-thermal";
+		#thermal-sensor-cells = <0>;
+		io-channels = <&auxadc 0>;
+		io-channel-names = "sensor-channel";
+		temperature-lookup-table = <    (-5000) 4241
+                                                0 4063
+                                                5000 3856
+                                                10000 3621
+                                                15000 3364
+                                                20000 3091
+                                                25000 2810
+                                                30000 2526
+                                                35000 2247
+                                                40000 1982
+                                                45000 1734
+                                                50000 1507
+                                                55000 1305
+                                                60000 1122
+                                                65000 964
+                                                70000 827
+                                                75000 710
+                                                80000 606
+                                                85000 519
+                                                90000 445
+                                                95000 382
+                                                100000 330
+                                                105000 284
+                                                110000 245
+                                                115000 213
+                                                120000 183
+                                                125000 161>;
+	};
+
+	panel: panel {
+		compatible = "lg,lp120up1";
+		power-supply = <&panel_fixed_3v3>;
+		backlight = <&backlight_lcd0>;
+
+		port {
+			panel_in: endpoint {
+				remote-endpoint = <&edp_out>;
+			};
+		};
+	};
+
+	panel_fixed_3v3: regulator@0 {
+		compatible = "regulator-fixed";
+		regulator-name = "PANEL_3V3";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		enable-active-high;
+		gpio = <&pio 55 GPIO_ACTIVE_HIGH>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&panel_fixed_pins>;
+	};
+
+	reserved_memory: reserved-memory {
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+
+		scp_mem_reserved: scp_mem_region {
+			compatible = "shared-dma-pool";
+			reg = <0 0x50000000 0 0x2900000>;
+			no-map;
+		};
+
+		dfd-buffer{
+			compatible = "mediatek,dfd-buffer";
+			reg = <0 0x6A000000 0 0x100000>;
+			no-map;
+		};
+	};
+};
+
+&afe {
+	mediatek,etdm-in2-cowork-source = <2>;
+	mediatek,etdm-out2-cowork-source = <0>;
+	status = "okay";
+};
+
+&auxadc {
+	status = "okay";
+};
+
+&dp_intf0 {
+	status = "okay";
+	ports {
+		port {
+			dp_intf0_out: endpoint {
+				remote-endpoint = <&edp_in>;
+			};
+		};
+	};
+};
+
+&dp_intf1 {
+	status = "okay";
+	ports {
+		port {
+			dp_intf1_out: endpoint {
+				remote-endpoint = <&dptx_in>;
+			};
+		};
+	};
+};
+
+&edp_tx {
+	pinctrl-names = "default";
+	pinctrl-0 = <&edp_pin>;
+	status = "okay";
+
+	ports {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		port@0 {
+			reg = <0>;
+			edp_in: endpoint {
+			remote-endpoint = <&dp_intf0_out>;
+			};
+		};
+		port@1 {
+			reg = <1>;
+			edp_out: endpoint {
+				remote-endpoint = <&panel_in>;
+			};
+		};
+	};
+};
+
+&dp_tx {
+	pinctrl-names = "default";
+	pinctrl-0 = <&dptx_pin>;
+	status = "okay";
+
+	ports {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		port@0 {
+			reg = <0>;
+			dptx_in: endpoint {
+			remote-endpoint = <&dp_intf1_out>;
+			};
+		};
+	};
+};
+
+&disp_pwm0 {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&disp_pwm0_pin_default>;
+};
+
+&pmic {
+	interrupt-parent = <&pio>;
+	interrupts = <222 IRQ_TYPE_LEVEL_HIGH>;
+};
+
+&mfg0 {
+	domain-supply = <&mt6315_7_vbuck1>;
+};
+
+&mt6359codec {
+	mediatek,dmic-mode = <1>; /* one-wire */
+	mediatek,mic-type-0 = <2>; /* DMIC */
+};
+
+&mt6359_vgpu11_sshub_buck_reg {
+	regulator-always-on;
+	regulator-min-microvolt = <550000>;
+	regulator-max-microvolt = <550000>;
+};
+
+/* for CORE */
+&mt6359_vgpu11_buck_reg {
+	regulator-always-on;
+};
+
+/* for CORE SRAM */
+&mt6359_vpu_buck_reg {
+	regulator-always-on;
+};
+
+/* for CPU-L */
+&mt6359_vcore_buck_reg {
+	regulator-always-on;
+};
+
+&mt6359_vaud18_ldo_reg {
+	regulator-always-on;
+};
+
+&mt6359_vrf12_ldo_reg {
+	regulator-always-on;
+};
+
+&mt6359_vufs_ldo_reg {
+	regulator-always-on;
+};
+
+&gpu {
+	supply-names = "mali","mali_sram";
+	mali-supply = <&mt6315_7_vbuck1>;
+	mali_sram-supply = <&mt6359_vsram_others_ldo_reg>;
+	operating-points-v2 = <&gpu_opp_table>;
+	power_model@0 {
+		compatible = "arm,mali-simple-power-model";
+		static-coefficient = <162868>;
+		dynamic-coefficient = <2649>;
+		ts = <(-199560) 37873 (-665) 9>;
+		thermal-zone = "soc_max";
+	};
+	power_model@1 {
+		compatible = "arm,mali-tnax-power-model";
+		scale = <5>;
+	};
+};
+
+&sound {
+	pinctrl-names = "default";
+	pinctrl-0 = <&aud_pins_default>;
+	status = "okay";
+};
+
+&spmi {
+	grpid = <11>;
+	mt6315_6: mt6315@6 {
+		compatible = "mediatek,mt6315-regulator";
+		reg = <0x6 0 0xb 1>;
+
+		regulators {
+			mt6315_6_vbuck1: vbuck1 {
+				regulator-compatible = "vbuck1";
+				regulator-name = "Vbcpu";
+				regulator-min-microvolt = <300000>;
+				regulator-max-microvolt = <1193750>;
+				regulator-enable-ramp-delay = <256>;
+				regulator-allowed-modes = <0 1 2 4>;
+				regulator-always-on;
+			};
+		};
+	};
+
+	mt6315_7: mt6315@7 {
+		compatible = "mediatek,mt6315-regulator";
+		reg = <0x7 0 0xb 1>;
+
+		regulators {
+			mt6315_7_vbuck1: vbuck1 {
+				regulator-compatible = "vbuck1";
+				regulator-name = "Vgpu";
+				regulator-min-microvolt = <300000>;
+				regulator-max-microvolt = <1193750>;
+				regulator-enable-ramp-delay = <256>;
+				regulator-allowed-modes = <0 1 2 4>;
+			};
+		};
+	};
+};
+
+&uart0 {
+	status = "okay";
+};
+
+&thermal_zones {
+	ap_ntc1 {
+		polling-delay = <1000>; /* milliseconds */
+		polling-delay-passive = <0>; /* milliseconds */
+		thermal-sensors = <&tboard_thermistor1>;
+	};
+
+	ap_ntc2 {
+		polling-delay = <1000>; /* milliseconds */
+		polling-delay-passive = <0>; /* milliseconds */
+		thermal-sensors = <&tboard_thermistor2>;
+	};
+
+	ap_ntc3 {
+		polling-delay = <1000>; /* milliseconds */
+		polling-delay-passive = <0>; /* milliseconds */
+		thermal-sensors = <&tboard_thermistor3>;
+	};
+};
+
+&u2port0 {
+	status = "okay";
+};
+
+&u2port1 {
+	status = "okay";
+};
+
+&u2port2 {
+	status = "okay";
+};
+
+&u2port3 {
+	status = "okay";
+};
+
+&u3port0 {
+	status = "okay";
+};
+
+&u3phy0 {
+	status="okay";
+};
+
+&u3phy1 {
+	status = "okay";
+};
+
+&u3phy2 {
+	status="okay";
+};
+
+&u3phy3 {
+	status="okay";
+};
+
+&mmc0 {
+	status = "okay";
+	pinctrl-names = "default", "state_uhs";
+	pinctrl-0 = <&mmc0_pins_default>;
+	pinctrl-1 = <&mmc0_pins_uhs>;
+	bus-width = <8>;
+	max-frequency = <200000000>;
+	cap-mmc-highspeed;
+	mmc-hs200-1_8v;
+	mmc-hs400-1_8v;
+	cap-mmc-hw-reset;
+	no-sdio;
+	no-sd;
+	hs400-ds-delay = <0x14c11>;
+	vmmc-supply = <&mt6359_vemc_1_ldo_reg>;
+	vqmmc-supply = <&mt6359_vufs_ldo_reg>;
+	non-removable;
+};
+
+&mmc1 {
+	status = "okay";
+	pinctrl-names = "default", "state_uhs";
+	pinctrl-0 = <&mmc1_pins_default>;
+	pinctrl-1 = <&mmc1_pins_uhs>;
+	bus-width = <4>;
+	max-frequency = <200000000>;
+	cap-sd-highspeed;
+	sd-uhs-sdr50;
+	sd-uhs-sdr104;
+	no-mmc;
+	no-sdio;
+	cd-gpios = <&pio 54 GPIO_ACTIVE_LOW>;
+	vmmc-supply = <&mt_pmic_vmch_ldo_reg>;
+	vqmmc-supply = <&mt_pmic_vmc_ldo_reg>;
+};
+
+&pcie0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pcie0_pins_default>;
+	status = "okay";
+};
+
+&pcie1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pcie1_pins_default>;
+	status = "okay";
+};
+
+&pciephy {
+	status = "okay";
+};
+
+&pio {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pio_default>;
+
+	/* 144 lines */
+	gpio-line-names =
+		"I2S_SPKR_MCLK",
+		"I2S_SPKR_DATAIN",
+		"I2S_SPKR_LRCK",
+		"I2S_SPKR_BCLK",
+		"EC_AP_INT_ODL",
+		/*
+		 * AP_FLASH_WP_L is crossystem ABI. Schematics
+		 * call it AP_FLASH_WP_ODL.
+		 */
+		"AP_FLASH_WP_L",
+		"TCHPAD_INT_ODL",
+		"EDP_HPD_1V8",
+		"AP_I2C_CAM_SDA",
+		"AP_I2C_CAM_SCL",
+		"AP_I2C_TCHPAD_SDA_1V8",
+		"AP_I2C_TCHPAD_SCL_1V8",
+		"AP_I2C_AUD_SDA",
+		"AP_I2C_AUD_SCL",
+		"AP_I2C_TPM_SDA_1V8",
+		"AP_I2C_TPM_SCL_1V8",
+		"AP_I2C_TCHSCR_SDA_1V8",
+		"AP_I2C_TCHSCR_SCL_1V8",
+		"EC_AP_HPD_OD",
+		"",
+		"PCIE_NVME_RST_L",
+		"PCIE_NVME_CLKREQ_ODL",
+		"PCIE_RST_1V8_L",
+		"PCIE_CLKREQ_1V8_ODL",
+		"PCIE_WAKE_1V8_ODL",
+		"CLK_24M_CAM0",
+		"CAM1_SEN_EN",
+		"AP_I2C_PWR_SCL_1V8",
+		"AP_I2C_PWR_SDA_1V8",
+		"AP_I2C_MISC_SCL",
+		"AP_I2C_MISC_SDA",
+		"EN_PP5000_HDMI_X",
+		"AP_HDMITX_HTPLG",
+		"",
+		"AP_HDMITX_SCL_1V8",
+		"AP_HDMITX_SDA_1V8",
+		"AP_RTC_CLK32K",
+		"AP_EC_WATCHDOG_L",
+		"SRCLKENA0",
+		"SRCLKENA1",
+		"PWRAP_SPI0_CS_L",
+		"PWRAP_SPI0_CK",
+		"PWRAP_SPI0_MOSI",
+		"PWRAP_SPI0_MISO",
+		"SPMI_SCL",
+		"SPMI_SDA",
+		"",
+		"",
+		"",
+		"I2S_HP_DATAIN",
+		"I2S_HP_MCLK",
+		"I2S_HP_BCK",
+		"I2S_HP_LRCK",
+		"I2S_HP_DATAOUT",
+		"SD_CD_ODL",
+		"EN_PP3300_DISP_X",
+		"TCHSCR_RST_1V8_L",
+		"TCHSCR_REPORT_DISABLE",
+		"EN_PP3300_WLAN_X",
+		"BT_KILL_1V8_L",
+		"I2S_SPKR_DATAOUT",
+		"WIFI_KILL_1V8_L",
+		"BEEP_ON",
+		"SCP_I2C_SENSOR_SCL_1V8",
+		"SCP_I2C_SENSOR_SDA_1V8",
+		"",
+		"",
+		"",
+		"",
+		"AUD_CLK_MOSI",
+		"AUD_SYNC_MOSI",
+		"AUD_DAT_MOSI0",
+		"AUD_DAT_MOSI1",
+		"AUD_DAT_MISO0",
+		"AUD_DAT_MISO1",
+		"AUD_DAT_MISO2",
+		"SCP_VREQ_VAO",
+		"AP_SPI_GSC_TPM_CLK",
+		"AP_SPI_GSC_TPM_MOSI",
+		"AP_SPI_GSC_TPM_CS_L",
+		"AP_SPI_GSC_TPM_MISO",
+		"EN_PP1000_CAM_X",
+		"AP_EDP_BKLTEN",
+		"",
+		"USB3_HUB_RST_L",
+		"",
+		"WLAN_ALERT_ODL",
+		"EC_IN_RW_ODL",
+		"GSC_AP_INT_ODL",
+		"HP_INT_ODL",
+		"CAM0_RST_L",
+		"CAM1_RST_L",
+		"TCHSCR_INT_1V8_L",
+		"CAM1_DET_L",
+		"RST_ALC1011_L",
+		"",
+		"",
+		"BL_PWM_1V8",
+		"UART_AP_TX_DBG_RX",
+		"UART_DBG_TX_AP_RX",
+		"EN_SPKR",
+		"AP_EC_WARM_RST_REQ",
+		"UART_SCP_TX_DBGCON_RX",
+		"UART_DBGCON_TX_SCP_RX",
+		"",
+		"",
+		"KPCOL0",
+		"",
+		"MT6315_GPU_INT",
+		"MT6315_PROC_BC_INT",
+		"SD_CMD",
+		"SD_CLK",
+		"SD_DAT0",
+		"SD_DAT1",
+		"SD_DAT2",
+		"SD_DAT3",
+		"EMMC_DAT7",
+		"EMMC_DAT6",
+		"EMMC_DAT5",
+		"EMMC_DAT4",
+		"EMMC_RSTB",
+		"EMMC_CMD",
+		"EMMC_CLK",
+		"EMMC_DAT3",
+		"EMMC_DAT2",
+		"EMMC_DAT1",
+		"EMMC_DAT0",
+		"EMMC_DSL",
+		"",
+		"",
+		"MT6360_INT_ODL",
+		"SCP_JTAG0_TRSTN",
+		"AP_SPI_EC_CS_L",
+		"AP_SPI_EC_CLK",
+		"AP_SPI_EC_MOSI",
+		"AP_SPI_EC_MISO",
+		"SCP_JTAG0_TMS",
+		"SCP_JTAG0_TCK",
+		"SCP_JTAG0_TDO",
+		"SCP_JTAG0_TDI",
+		"AP_SPI_FLASH_CS_L",
+		"AP_SPI_FLASH_CLK",
+		"AP_SPI_FLASH_MOSI",
+		"AP_SPI_FLASH_MISO";
+
+	pio_default: pio_default {
+		wifi_enable {
+			pinmux = <PINMUX_GPIO58__FUNC_GPIO58>;
+			output-high;
+			drive-strength = <MTK_DRIVE_14mA>;
+		};
+	};
+
+	aud_pins_default: audiodefault {
+		pins_cmd_dat {
+		    pinmux = <PINMUX_GPIO69__FUNC_AUD_CLK_MOSI>,
+			     <PINMUX_GPIO70__FUNC_AUD_SYNC_MOSI>,
+			     <PINMUX_GPIO71__FUNC_AUD_DAT_MOSI0>,
+			     <PINMUX_GPIO72__FUNC_AUD_DAT_MOSI1>,
+			     <PINMUX_GPIO73__FUNC_AUD_DAT_MISO0>,
+			     <PINMUX_GPIO74__FUNC_AUD_DAT_MISO1>,
+			     <PINMUX_GPIO75__FUNC_AUD_DAT_MISO2>,
+			     <PINMUX_GPIO0__FUNC_TDMIN_MCK>,
+			     <PINMUX_GPIO1__FUNC_TDMIN_DI>,
+			     <PINMUX_GPIO2__FUNC_TDMIN_LRCK>,
+			     <PINMUX_GPIO3__FUNC_TDMIN_BCK>,
+			     <PINMUX_GPIO60__FUNC_I2SO2_D0>,
+			     <PINMUX_GPIO49__FUNC_I2SIN_D0>,
+			     <PINMUX_GPIO50__FUNC_I2SO1_MCK>,
+			     <PINMUX_GPIO51__FUNC_I2SO1_BCK>,
+			     <PINMUX_GPIO52__FUNC_I2SO1_WS>,
+			     <PINMUX_GPIO53__FUNC_I2SO1_D0>;
+		};
+
+		pins_jack {
+			pinmux = <PINMUX_GPIO89__FUNC_GPIO89>;
+			input-enable;
+			bias-pull-up = <MTK_PUPD_SET_R1R0_01>;
+		};
+	};
+
+	cr50_irq: cr50_irq {
+		pins_bus {
+			pinmux = <PINMUX_GPIO88__FUNC_GPIO88>;
+			input-enable;
+		};
+	};
+
+	ec_ap_int_odl: ec_ap_int_odl {
+		pins1 {
+			pinmux = <PINMUX_GPIO4__FUNC_GPIO4>;
+			input-enable;
+			bias-pull-up = <MTK_PUPD_SET_R1R0_01>;
+		};
+	};
+
+	i2c0_pin: i2c0_pin {
+		pins_bus {
+			pinmux = <PINMUX_GPIO8__FUNC_SDA0>,
+				 <PINMUX_GPIO9__FUNC_SCL0>;
+			bias-disable;
+			mediatek,drive-strength-adv = <7>;
+		};
+	};
+
+	i2c1_pin: i2c1_pin {
+		pins_bus {
+			pinmux = <PINMUX_GPIO10__FUNC_SDA1>,
+				 <PINMUX_GPIO11__FUNC_SCL1>;
+			bias-pull-up;
+			mediatek,rsel = <7>;
+			mediatek,drive-strength-adv = <7>;
+		};
+	};
+
+	i2c2_pin: i2c2_pin {
+		pins_bus {
+			pinmux = <PINMUX_GPIO12__FUNC_SDA2>,
+				 <PINMUX_GPIO13__FUNC_SCL2>;
+			bias-disable;
+			mediatek,drive-strength-adv = <7>;
+		};
+	};
+	panel_fixed_pins: panel_fixed_pins {
+		pins1 {
+			pinmux = <PINMUX_GPIO55__FUNC_GPIO55>;
+		};
+	};
+	i2c3_pin: i2c3_pin {
+		pins_bus {
+			pinmux = <PINMUX_GPIO14__FUNC_SDA3>,
+				 <PINMUX_GPIO15__FUNC_SCL3>;
+			bias-pull-up;
+			mediatek,rsel = <7>;
+			mediatek,drive-strength-adv = <7>;
+		};
+	};
+
+	i2c4_pin: i2c4_pin {
+		pins_bus {
+			pinmux = <PINMUX_GPIO16__FUNC_SDA4>,
+				 <PINMUX_GPIO17__FUNC_SCL4>;
+			bias-pull-up;
+			mediatek,rsel = <7>;
+			mediatek,drive-strength-adv = <0>;
+			drive-strength = <MTK_DRIVE_4mA>;
+		};
+	};
+
+	i2c5_pin: i2c5_pin {
+		pins_bus {
+			pinmux = <PINMUX_GPIO29__FUNC_SCL5>,
+				 <PINMUX_GPIO30__FUNC_SDA5>;
+			bias-disable;
+			mediatek,drive-strength-adv = <7>;
+		};
+	};
+
+	i2c7_pin: i2c7_pin {
+		pins_bus {
+			pinmux = <PINMUX_GPIO27__FUNC_SCL7>,
+				 <PINMUX_GPIO28__FUNC_SDA7>;
+			bias-disable;
+		};
+	};
+
+	pcie0_pins_default: pcie0default {
+		pins {
+			pinmux = <PINMUX_GPIO19__FUNC_WAKEN>,
+				 <PINMUX_GPIO20__FUNC_PERSTN>,
+				 <PINMUX_GPIO21__FUNC_CLKREQN>;
+				 bias-pull-up;
+		};
+	};
+
+	pcie1_pins_default: pcie1default {
+		pins {
+			pinmux = <PINMUX_GPIO22__FUNC_PERSTN_1>,
+				 <PINMUX_GPIO23__FUNC_CLKREQN_1>,
+				 <PINMUX_GPIO24__FUNC_WAKEN_1>;
+				 bias-pull-up;
+		};
+	};
+
+	mmc0_pins_default: mmc0default {
+		pins_cmd_dat {
+			pinmux = <PINMUX_GPIO126__FUNC_MSDC0_DAT0>,
+				 <PINMUX_GPIO125__FUNC_MSDC0_DAT1>,
+				 <PINMUX_GPIO124__FUNC_MSDC0_DAT2>,
+				 <PINMUX_GPIO123__FUNC_MSDC0_DAT3>,
+				 <PINMUX_GPIO119__FUNC_MSDC0_DAT4>,
+				 <PINMUX_GPIO118__FUNC_MSDC0_DAT5>,
+				 <PINMUX_GPIO117__FUNC_MSDC0_DAT6>,
+				 <PINMUX_GPIO116__FUNC_MSDC0_DAT7>,
+				 <PINMUX_GPIO121__FUNC_MSDC0_CMD>;
+			input-enable;
+			drive-strength = <MTK_DRIVE_6mA>;
+			bias-pull-up = <MTK_PUPD_SET_R1R0_01>;
+		};
+
+		pins_clk {
+			pinmux = <PINMUX_GPIO122__FUNC_MSDC0_CLK>;
+			drive-strength = <MTK_DRIVE_6mA>;
+			bias-pull-down = <MTK_PUPD_SET_R1R0_10>;
+		};
+
+		pins_rst {
+			pinmux = <PINMUX_GPIO120__FUNC_MSDC0_RSTB>;
+			drive-strength = <MTK_DRIVE_6mA>;
+			bias-pull-up = <MTK_PUPD_SET_R1R0_01>;
+		};
+	};
+
+	mmc0_pins_uhs: mmc0uhs{
+		pins_cmd_dat {
+			pinmux = <PINMUX_GPIO126__FUNC_MSDC0_DAT0>,
+				 <PINMUX_GPIO125__FUNC_MSDC0_DAT1>,
+				 <PINMUX_GPIO124__FUNC_MSDC0_DAT2>,
+				 <PINMUX_GPIO123__FUNC_MSDC0_DAT3>,
+				 <PINMUX_GPIO119__FUNC_MSDC0_DAT4>,
+				 <PINMUX_GPIO118__FUNC_MSDC0_DAT5>,
+				 <PINMUX_GPIO117__FUNC_MSDC0_DAT6>,
+				 <PINMUX_GPIO116__FUNC_MSDC0_DAT7>,
+				 <PINMUX_GPIO121__FUNC_MSDC0_CMD>;
+			input-enable;
+			drive-strength = <MTK_DRIVE_8mA>;
+			bias-pull-up = <MTK_PUPD_SET_R1R0_01>;
+		};
+
+		pins_clk {
+			pinmux = <PINMUX_GPIO122__FUNC_MSDC0_CLK>;
+			drive-strength = <MTK_DRIVE_8mA>;
+			bias-pull-down = <MTK_PUPD_SET_R1R0_10>;
+		};
+
+		pins_ds {
+			pinmux = <PINMUX_GPIO127__FUNC_MSDC0_DSL>;
+			drive-strength = <MTK_DRIVE_8mA>;
+			bias-pull-down = <MTK_PUPD_SET_R1R0_10>;
+		};
+
+		pins_rst {
+			pinmux = <PINMUX_GPIO120__FUNC_MSDC0_RSTB>;
+			drive-strength = <MTK_DRIVE_8mA>;
+			bias-pull-up = <MTK_PUPD_SET_R1R0_01>;
+		};
+	};
+
+	mmc1_pins_default: mmc1-pins-default {
+		pins_cmd_dat {
+			pinmux = <PINMUX_GPIO110__FUNC_MSDC1_CMD>,
+				 <PINMUX_GPIO112__FUNC_MSDC1_DAT0>,
+				 <PINMUX_GPIO113__FUNC_MSDC1_DAT1>,
+				 <PINMUX_GPIO114__FUNC_MSDC1_DAT2>,
+				 <PINMUX_GPIO115__FUNC_MSDC1_DAT3>;
+			input-enable;
+			drive-strength = <MTK_DRIVE_8mA>;
+			bias-pull-up = <MTK_PUPD_SET_R1R0_01>;
+		};
+
+		pins_clk {
+			pinmux = <PINMUX_GPIO111__FUNC_MSDC1_CLK>;
+			drive-strength = <MTK_DRIVE_8mA>;
+			bias-pull-down = <MTK_PUPD_SET_R1R0_10>;
+		};
+
+		pins_insert {
+			pinmux = <PINMUX_GPIO54__FUNC_GPIO54>;
+			bias-pull-up;
+		};
+	};
+
+	mmc1_pins_uhs: mmc1-pins-uhs {
+		pins_cmd_dat {
+			pinmux = <PINMUX_GPIO110__FUNC_MSDC1_CMD>,
+				 <PINMUX_GPIO112__FUNC_MSDC1_DAT0>,
+				 <PINMUX_GPIO113__FUNC_MSDC1_DAT1>,
+				 <PINMUX_GPIO114__FUNC_MSDC1_DAT2>,
+				 <PINMUX_GPIO115__FUNC_MSDC1_DAT3>;
+			input-enable;
+			drive-strength = <MTK_DRIVE_8mA>;
+			bias-pull-up = <MTK_PUPD_SET_R1R0_01>;
+		};
+
+		pins_clk {
+			pinmux = <PINMUX_GPIO111__FUNC_MSDC1_CLK>;
+			drive-strength = <MTK_DRIVE_8mA>;
+			bias-pull-down = <MTK_PUPD_SET_R1R0_10>;
+		};
+	};
+
+	hdmi_pin: hdmipinctrl {
+		hdmi_hotplug {
+			pinmux = <PINMUX_GPIO32__FUNC_HDMITX20_HTPLG>;
+			bias-pull-down;
+		};
+		hdmi_ddc {
+			pinmux = <PINMUX_GPIO34__FUNC_HDMITX20_SCL>,
+				 <PINMUX_GPIO35__FUNC_HDMITX20_SDA>;
+			mediatek,drive-strength-adv = <0>;
+			drive-strength = <MTK_DRIVE_10mA>;
+		};
+		hdmi_cec {
+			pinmux = <PINMUX_GPIO33__FUNC_HDMITX20_CEC>;
+			bias-disable;
+		};
+		hdmi_5vctrl {
+			pinmux = <PINMUX_GPIO31__FUNC_GPIO31>;
+			slew-rate = <1>;
+			output-high;
+		};
+	};
+
+	hdmi0_pins_default: hdmi0default {
+		hdmirx_hpd {
+			pinmux = <PINMUX_GPIO27__FUNC_HDMIRX20_HTPLG>;
+		};
+		hdmirx_5v {
+			pinmux = <PINMUX_GPIO28__FUNC_HDMIRX20_PWR5V>;
+			bias-disable;
+		};
+		hdmirx_scl {
+			pinmux = <PINMUX_GPIO29__FUNC_HDMIRX20_SCL>;
+		};
+		hdmirx_sda {
+			pinmux = <PINMUX_GPIO30__FUNC_HDMIRX20_SDA>;
+			mediatek,drive-strength-adv = <0>;
+			drive-strength = <MTK_DRIVE_10mA>;
+		};
+	};
+
+	dptx_pin: dptx_pin_default {
+		pins_cmd_dat1 {
+			pinmux = <PINMUX_GPIO18__FUNC_DP_TX_HPD>;
+			bias-pull-up;
+		};
+	};
+
+	disp_pwm0_pin_default: disp_pwm0_pin_default {
+		pins1 {
+			pinmux = <PINMUX_GPIO82__FUNC_GPIO82>;
+		};
+		pins2 {
+			pinmux = <PINMUX_GPIO97__FUNC_DISP_PWM0>;
+		};
+	};
+
+	edp_pin: edp_pin_default {
+		pins_cmd_dat {
+			pinmux = <PINMUX_GPIO7__FUNC_EDP_TX_HPD>;
+			bias-pull-up;
+		};
+	};
+
+	nor_pins_default: nor {
+		pins0 {
+			pinmux = <PINMUX_GPIO142__FUNC_SPINOR_IO0>,
+				 <PINMUX_GPIO141__FUNC_SPINOR_CK>,
+				 <PINMUX_GPIO143__FUNC_SPINOR_IO1>;
+			drive-strength = <MTK_DRIVE_6mA>;
+			bias-pull-down;
+		};
+
+		pins1 {
+			pinmux = <PINMUX_GPIO140__FUNC_SPINOR_CS>;
+			drive-strength = <MTK_DRIVE_6mA>;
+			bias-pull-up;
+		};
+	};
+
+	rt1011_pins_default: rt1011default {
+		pins_spk {
+			pinmux = <PINMUX_GPIO94__FUNC_GPIO94>,
+			     <PINMUX_GPIO100__FUNC_GPIO100>;
+			output-high;
+		};
+	};
+
+	rt1019p_pins_default: rt1019p_pins {
+		pins {
+			pinmux = <PINMUX_GPIO100__FUNC_GPIO100>;
+			output-low;
+		};
+	};
+
+	spi_pins_0: spi0@0 {
+		pins_spi {
+			pinmux = <PINMUX_GPIO132__FUNC_SPIM0_CSB>,
+				 <PINMUX_GPIO134__FUNC_SPIM0_MO>,
+				 <PINMUX_GPIO133__FUNC_SPIM0_CLK>;
+			bias-disable;
+		};
+		pins_spi_mi {
+			pinmux = <PINMUX_GPIO135__FUNC_SPIM0_MI>;
+			bias-pull-down;
+		};
+	};
+
+	subpmic_default: subpmicdefault {
+		subpmic_pin_irq: pin_irq {
+			pinmux = <PINMUX_GPIO130__FUNC_GPIO130>;
+			input-enable;
+			bias-pull-up;
+		};
+	};
+
+	touchpad_pins: touchpad-pins {
+		touchpad_int {
+			pinmux = <PINMUX_GPIO6__FUNC_GPIO6>;
+			input-enable;
+			bias-pull-up;
+		};
+	};
+
+	touchscreen_pins: touchscreen-pins {
+		pin_irq {
+			pinmux = <PINMUX_GPIO92__FUNC_GPIO92>;
+			input-enable;
+			bias-pull-up = <MTK_PUPD_SET_R1R0_01>;
+		};
+		touch_pin_reset: pin_reset {
+			pinmux = <PINMUX_GPIO56__FUNC_GPIO56>;
+			output-high;
+		};
+		touch_pin_report_sw: pin_report_sw {
+			pinmux = <PINMUX_GPIO57__FUNC_GPIO57>;
+			output-low;
+		};
+	};
+
+	scp_pins: scp {
+		pins_scp_vreq {
+			pinmux = <PINMUX_GPIO76__FUNC_SCP_VREQ_VAO>,
+				 <PINMUX_GPIO102__FUNC_TP_UTXD1_AO>,
+				 <PINMUX_GPIO103__FUNC_TP_URXD1_AO>;
+			bias-disable;
+			input-enable;
+		};
+	};
+};
+
+&disp_dpi1 {
+	status = "okay";
+	port {
+		dpi1_out: endpoint@0 {
+			remote-endpoint = <&hdmi0_in>;
+		};
+	};
+};
+
+&hdmi0 {
+	status = "okay";
+	ports {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		port@0 {
+			reg = <0>;
+			hdmi0_in: endpoint {
+				remote-endpoint = <&dpi1_out>;
+			};
+		};
+	};
+};
+
+&i2c0 {
+	status = "okay";
+	clock-frequency = <400000>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c0_pin>;
+};
+
+&i2c1 {
+	status = "okay";
+	clock-frequency = <400000>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c1_pin>;
+	i2c-scl-internal-delay-ns = <12500>;
+
+	touchpad@15 {
+		compatible = "elan,ekth3000";
+		reg = <0x15>;
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&touchpad_pins>;
+
+		interrupt-parent = <&pio>;
+		interrupts = <6 IRQ_TYPE_LEVEL_LOW>;
+
+		wakeup-source;
+	};
+};
+
+&i2c2 {
+	status = "okay";
+	clock-frequency = <400000>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c2_pin>;
+
+	rt5682@1a {
+               compatible = "realtek,rt5682i";
+               reg = <0x1a>;
+               interrupt-parent = <&pio>;
+               interrupts = <89 IRQ_TYPE_EDGE_BOTH>;
+               realtek,jd-src = <1>;
+               realtek,btndet-delay = <16>;
+	};
+
+	rt1011_l: rt1011@38 {
+		compatible = "realtek,rt1011";
+		reg = <0x38>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&rt1011_pins_default>;
+		status = "disabled";
+	};
+
+	rt1011_r: rt1011@39 {
+		compatible = "realtek,rt1011";
+		reg = <0x39>;
+		status = "disabled";
+	};
+};
+
+&i2c3 {
+	status = "okay";
+	clock-frequency = <400000>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c3_pin>;
+
+	cr50@50 {
+		compatible = "google,cr50";
+		reg = <0x50>;
+		interrupt-parent = <&pio>;
+		interrupts = <88 IRQ_TYPE_EDGE_FALLING>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&cr50_irq>;
+	};
+};
+
+&i2c4 {
+	status = "okay";
+	clock-frequency = <400000>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c4_pin>;
+
+	touchscreen: touchscreen@10 {
+		compatible = "hid-over-i2c";
+		reg = <0x10>;
+		interrupt-parent = <&pio>;
+		interrupts = <92 IRQ_TYPE_LEVEL_LOW>;
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&touchscreen_pins>;
+
+		post-power-on-delay-ms = <10>;
+		hid-descr-addr = <0x0001>;
+	};
+};
+
+&i2c5 {
+	status = "okay";
+	clock-frequency = <400000>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c5_pin>;
+};
+
+&i2c7 {
+	status = "okay";
+	clock-frequency = <400000>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c7_pin>;
+
+	#address-cells = <1>;
+	#size-cells = <0>;
+
+	subpmic_mtk: mt6360_pmu@34 {
+		#interrupt-cells = <2>;
+		status = "ok";
+		compatible = "mediatek,mt6360";
+		reg = <0x34>;
+		wakeup-source;
+		interrupt-controller;
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&subpmic_default>;
+
+		interrupt-parent = <&pio>;
+		interrupts = <130 IRQ_TYPE_EDGE_FALLING>;
+		interrupt-names = "IRQB";
+
+		subpmic_mtk_regulator: regulator {
+			compatible = "mediatek,mt6360_ldo";
+			mt_pmic_vfp_ldo_reg: ldo1 {
+				regulator-compatible = "LDO1";
+				regulator-name = "mt6360,ldo1";
+				regulator-min-microvolt = <3000000>;
+				regulator-max-microvolt = <3600000>;
+				regulator-allowed-modes = <0 2>;
+				regulator-always-on;
+			};
+			mt_pmic_vtp_ldo_reg: ldo2 {
+				regulator-compatible = "LDO2";
+				regulator-name = "vtp";
+				regulator-min-microvolt = <1200000>;
+				regulator-max-microvolt = <3600000>;
+				regulator-allowed-modes = <0 2>;
+			};
+		};
+	};
+};
+
+&scp {
+	memory-region = <&scp_mem_reserved>;
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&scp_pins>;
+
+	cros_ec {
+		compatible = "google,cros-ec-rpmsg";
+		mtk,rpmsg-name = "cros-ec-rpmsg";
+	};
+};
+
+&xhci {
+	vusb33-supply = <&mt6359_vusb_ldo_reg>;
+	vbus-supply = <&usb_p0_vbus>;
+	status = "okay";
+};
+
+&xhci1 {
+	vusb33-supply = <&mt6359_vusb_ldo_reg>;
+	vbus-supply = <&usb_p1_vbus>;
+	mediatek,frame-cnt;
+	status = "okay";
+};
+
+&xhci2 {
+	vusb33-supply = <&mt6359_vusb_ldo_reg>;
+	vbus-supply = <&usb_p2_vbus>;
+	mediatek,frame-cnt;
+	status = "okay";
+};
+
+&xhci3 {
+	vusb33-supply = <&mt6359_vusb_ldo_reg>;
+	vbus-supply = <&usb_p3_vbus>;
+	mediatek,frame-cnt;
+	status = "okay";
+};
+
+&nor_flash {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&nor_pins_default>;
+
+	flash@0 {
+		compatible = "jedec,spi-nor";
+		reg = <0>;
+		spi-max-frequency = <52000000>;
+		spi-rx-bus-width = <2>;
+		spi-tx-bus-width = <2>;
+	};
+};
+
+&spi0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&spi_pins_0>;
+	mediatek,pad-select = <0>;
+	status = "okay";
+
+	cros_ec: ec@0 {
+		compatible = "google,cros-ec-spi";
+		reg = <0>;
+		spi-max-frequency = <3000000>;
+		interrupt-parent = <&pio>;
+		interrupts = <4 IRQ_TYPE_LEVEL_LOW>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&ec_ap_int_odl>;
+
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		i2c_tunnel: i2c-tunnel {
+			compatible = "google,cros-ec-i2c-tunnel";
+			google,remote-bus = <0>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+		};
+	};
+};
+
+#include <arm/cros-ec-keyboard.dtsi>
+#include <arm/cros-ec-sbs.dtsi>
diff --git a/arch/arm64/boot/dts/mediatek/mt8195-evb.dts b/arch/arm64/boot/dts/mediatek/mt8195-evb.dts
new file mode 100644
index 0000000000000000000000000000000000000000..82bb10e9a53108ebf504505db1517786359efe34
--- /dev/null
+++ b/arch/arm64/boot/dts/mediatek/mt8195-evb.dts
@@ -0,0 +1,29 @@
+// SPDX-License-Identifier: (GPL-2.0 OR MIT)
+/*
+ * Copyright (C) 2021 MediaTek Inc.
+ * Author: Seiya Wang <seiya.wang@mediatek.com>
+ */
+/dts-v1/;
+#include "mt8195.dtsi"
+
+/ {
+	model = "MediaTek MT8195 evaluation board";
+	compatible = "mediatek,mt8195-evb", "mediatek,mt8195";
+
+	aliases {
+		serial0 = &uart0;
+	};
+
+	chosen {
+		stdout-path = "serial0:921600n8";
+	};
+
+	memory@40000000 {
+		device_type = "memory";
+		reg = <0 0x40000000 0 0x80000000>;
+	};
+};
+
+&uart0 {
+	status = "okay";
+};
diff --git a/arch/arm64/boot/dts/mediatek/mt8195-tomato.dts b/arch/arm64/boot/dts/mediatek/mt8195-tomato.dts
new file mode 100644
index 0000000000000000000000000000000000000000..4d1a34bb27631d68799766de8ef953a43b2639b4
--- /dev/null
+++ b/arch/arm64/boot/dts/mediatek/mt8195-tomato.dts
@@ -0,0 +1,65 @@
+// SPDX-License-Identifier: (GPL-2.0 OR MIT)
+/*
+ * Copyright (C) 2021 MediaTek Inc.
+ */
+/dts-v1/;
+#include "mt8195-cherry.dtsi"
+
+/ {
+	model = "MediaTek Tomato board";
+	compatible =  "google,tomato", "mediatek,mt8195";
+};
+
+&cros_ec {
+	mt_pmic_vmc_ldo_reg: regulator@0 {
+		compatible = "google,cros-ec-regulator";
+		regulator-min-microvolt = <1200000>;
+		regulator-max-microvolt = <3600000>;
+		reg = <0>;
+	};
+	mt_pmic_vmch_ldo_reg: regulator@1 {
+		compatible = "google,cros-ec-regulator";
+		regulator-min-microvolt = <2700000>;
+		regulator-max-microvolt = <3600000>;
+		reg = <1>;
+	};
+};
+
+&sound {
+	compatible = "mediatek,mt8195_mt6359_rt1019_rt5682";
+	mediatek,dptx-codec = <&dp_tx>;
+	mediatek,hdmi-codec = <&hdmi0>;
+};
+
+&rt1019p {
+	status = "okay";
+};
+
+&keyboard_controller {
+	function-row-physmap = <
+		MATRIX_KEY(0x00, 0x02, 0)	/* T1 */
+		MATRIX_KEY(0x03, 0x02, 0)	/* T2 */
+		MATRIX_KEY(0x02, 0x02, 0)	/* T3 */
+		MATRIX_KEY(0x01, 0x02, 0)	/* T4 */
+		MATRIX_KEY(0x03, 0x04, 0)	/* T5 */
+		MATRIX_KEY(0x02, 0x04, 0)	/* T6 */
+		MATRIX_KEY(0x01, 0x04, 0)	/* T7 */
+		MATRIX_KEY(0x02, 0x09, 0)	/* T8 */
+		MATRIX_KEY(0x01, 0x09, 0)	/* T9 */
+		MATRIX_KEY(0x00, 0x04, 0)	/* T10 */
+	>;
+	linux,keymap = <
+		MATRIX_KEY(0x00, 0x02, KEY_BACK)
+		MATRIX_KEY(0x03, 0x02, KEY_REFRESH)
+		MATRIX_KEY(0x02, 0x02, KEY_ZOOM)
+		MATRIX_KEY(0x01, 0x02, KEY_SCALE)
+		MATRIX_KEY(0x03, 0x04, KEY_SYSRQ)
+		MATRIX_KEY(0x02, 0x04, KEY_BRIGHTNESSDOWN)
+		MATRIX_KEY(0x01, 0x04, KEY_BRIGHTNESSUP)
+		MATRIX_KEY(0x02, 0x09, KEY_MUTE)
+		MATRIX_KEY(0x01, 0x09, KEY_VOLUMEDOWN)
+		MATRIX_KEY(0x00, 0x04, KEY_VOLUMEUP)
+
+		CROS_STD_MAIN_KEYMAP
+	>;
+};
diff --git a/arch/arm64/boot/dts/mediatek/mt8195.dtsi b/arch/arm64/boot/dts/mediatek/mt8195.dtsi
new file mode 100644
index 0000000000000000000000000000000000000000..e64efa85946dc562c58cf31542d73133e594dda6
--- /dev/null
+++ b/arch/arm64/boot/dts/mediatek/mt8195.dtsi
@@ -0,0 +1,3840 @@
+// SPDX-License-Identifier: (GPL-2.0 OR MIT)
+/*
+ * Copyright (c) 2021 MediaTek Inc.
+ * Author: Seiya Wang <seiya.wang@mediatek.com>
+ */
+
+/dts-v1/;
+
+#include <dt-bindings/clock/mt8195-clk.h>
+#include <dt-bindings/gce/mt8195-gce.h>
+#include <dt-bindings/interrupt-controller/arm-gic.h>
+#include <dt-bindings/interrupt-controller/irq.h>
+#include <dt-bindings/memory/mt8195-memory-port.h>
+#include <dt-bindings/phy/phy.h>
+#include <dt-bindings/pinctrl/mt8195-pinfunc.h>
+#include <dt-bindings/power/mt8195-power.h>
+#include <dt-bindings/reset/ti-syscon.h>
+#include <dt-bindings/reset/mt8195-resets.h>
+#include <dt-bindings/thermal/thermal.h>
+
+/ {
+	compatible = "mediatek,mt8195";
+	interrupt-parent = <&gic>;
+	#address-cells = <2>;
+	#size-cells = <2>;
+
+	aliases {
+		dpi1 = &disp_dpi1;
+		dp-intf0 = &dp_intf0;
+		dp-intf1 = &dp_intf1;
+		gce0 = &gce0;
+		gce1 = &gce1;
+		mutex0 = &mutex;
+		mutex1 = &mutex1;
+		merge1 = &merge1;
+		merge2 = &merge2;
+		merge3 = &merge3;
+		merge4 = &merge4;
+		merge5 = &merge5;
+		vdo1_rdma0 = &vdo1_rdma0;
+		vdo1_rdma1 = &vdo1_rdma1;
+		vdo1_rdma2 = &vdo1_rdma2;
+		vdo1_rdma3 = &vdo1_rdma3;
+		vdo1_rdma4 = &vdo1_rdma4;
+		vdo1_rdma5 = &vdo1_rdma5;
+		vdo1_rdma6 = &vdo1_rdma6;
+		vdo1_rdma7 = &vdo1_rdma7;
+	};
+
+	clocks {
+		clk26m: oscillator0 {
+			compatible = "fixed-clock";
+			#clock-cells = <0>;
+			clock-frequency = <26000000>;
+			clock-output-names = "clk26m";
+		};
+
+		clk32k: oscillator1 {
+			compatible = "fixed-clock";
+			#clock-cells = <0>;
+			clock-frequency = <32768>;
+			clock-output-names = "clk32k";
+		};
+	};
+
+	cpus {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		cpu0: cpu@0 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a55", "arm,armv8";
+			reg = <0x000>;
+			enable-method = "psci";
+			performance-domains = <&performance 0>;
+			clock-frequency = <1701000000>;
+			capacity-dmips-mhz = <578>;
+			cpu-idle-states = <&cpuoff_l &clusteroff_l>;
+			next-level-cache = <&l2_0>;
+			#cooling-cells = <2>;
+		};
+
+		cpu1: cpu@100 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a55", "arm,armv8";
+			reg = <0x100>;
+			enable-method = "psci";
+			performance-domains = <&performance 0>;
+			clock-frequency = <1701000000>;
+			capacity-dmips-mhz = <578>;
+			cpu-idle-states = <&cpuoff_l &clusteroff_l>;
+			next-level-cache = <&l2_0>;
+			#cooling-cells = <2>;
+		};
+
+		cpu2: cpu@200 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a55", "arm,armv8";
+			reg = <0x200>;
+			enable-method = "psci";
+			performance-domains = <&performance 0>;
+			clock-frequency = <1701000000>;
+			capacity-dmips-mhz = <578>;
+			cpu-idle-states = <&cpuoff_l &clusteroff_l>;
+			next-level-cache = <&l2_0>;
+			#cooling-cells = <2>;
+		};
+
+		cpu3: cpu@300 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a55", "arm,armv8";
+			reg = <0x300>;
+			enable-method = "psci";
+			performance-domains = <&performance 0>;
+			clock-frequency = <1701000000>;
+			capacity-dmips-mhz = <578>;
+			cpu-idle-states = <&cpuoff_l &clusteroff_l>;
+			next-level-cache = <&l2_0>;
+			#cooling-cells = <2>;
+		};
+
+		cpu4: cpu@400 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a78", "arm,armv8";
+			reg = <0x400>;
+			enable-method = "psci";
+			performance-domains = <&performance 1>;
+			clock-frequency = <2171000000>;
+			capacity-dmips-mhz = <1024>;
+			cpu-idle-states = <&cpuoff_b &clusteroff_b>;
+			next-level-cache = <&l2_1>;
+			#cooling-cells = <2>;
+		};
+
+		cpu5: cpu@500 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a78", "arm,armv8";
+			reg = <0x500>;
+			enable-method = "psci";
+			performance-domains = <&performance 1>;
+			clock-frequency = <2171000000>;
+			capacity-dmips-mhz = <1024>;
+			cpu-idle-states = <&cpuoff_b &clusteroff_b>;
+			next-level-cache = <&l2_1>;
+			#cooling-cells = <2>;
+		};
+
+		cpu6: cpu@600 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a78", "arm,armv8";
+			reg = <0x600>;
+			enable-method = "psci";
+			performance-domains = <&performance 1>;
+			clock-frequency = <2171000000>;
+			capacity-dmips-mhz = <1024>;
+			cpu-idle-states = <&cpuoff_b &clusteroff_b>;
+			next-level-cache = <&l2_1>;
+			#cooling-cells = <2>;
+		};
+
+		cpu7: cpu@700 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a78", "arm,armv8";
+			reg = <0x700>;
+			enable-method = "psci";
+			performance-domains = <&performance 1>;
+			clock-frequency = <2171000000>;
+			capacity-dmips-mhz = <1024>;
+			cpu-idle-states = <&cpuoff_b &clusteroff_b>;
+			next-level-cache = <&l2_1>;
+			#cooling-cells = <2>;
+		};
+
+		cpu-map {
+			cluster0 {
+				core0 {
+					cpu = <&cpu0>;
+				};
+				core1 {
+					cpu = <&cpu1>;
+				};
+				core2 {
+					cpu = <&cpu2>;
+				};
+				core3 {
+					cpu = <&cpu3>;
+				};
+			};
+			cluster1 {
+				core0 {
+					cpu = <&cpu4>;
+				};
+				core1 {
+					cpu = <&cpu5>;
+				};
+				core2 {
+					cpu = <&cpu6>;
+				};
+				core3 {
+					cpu = <&cpu7>;
+				};
+			};
+		};
+
+		idle-states {
+			entry-method = "arm,psci";
+			cpuoff_l: cpuoff_l {
+				compatible = "arm,idle-state";
+				arm,psci-suspend-param = <0x00010001>;
+				local-timer-stop;
+				entry-latency-us = <50>;
+				exit-latency-us = <95>;
+				min-residency-us = <580>;
+			};
+			cpuoff_b: cpuoff_b {
+				compatible = "arm,idle-state";
+				arm,psci-suspend-param = <0x00010001>;
+				local-timer-stop;
+				entry-latency-us = <45>;
+				exit-latency-us = <140>;
+				min-residency-us = <740>;
+			};
+			clusteroff_l: clusteroff_l {
+				compatible = "arm,idle-state";
+				arm,psci-suspend-param = <0x01010002>;
+				local-timer-stop;
+				entry-latency-us = <55>;
+				exit-latency-us = <155>;
+				min-residency-us = <840>;
+			};
+			clusteroff_b: clusteroff_b {
+				compatible = "arm,idle-state";
+				arm,psci-suspend-param = <0x01010002>;
+				local-timer-stop;
+				entry-latency-us = <50>;
+				exit-latency-us = <200>;
+				min-residency-us = <1000>;
+			};
+		};
+
+		l2_0: l2-cache0 {
+			compatible = "cache";
+			next-level-cache = <&l3_0>;
+		};
+
+		l2_1: l2-cache1 {
+			compatible = "cache";
+			next-level-cache = <&l3_0>;
+		};
+
+		l3_0: l3-cache {
+			compatible = "cache";
+		};
+	};
+
+	dsu-pmu {
+		compatible = "arm,dsu-pmu";
+		interrupts = <GIC_SPI 18 IRQ_TYPE_LEVEL_HIGH 0>;
+		cpus = <&cpu0>, <&cpu1>, <&cpu2>, <&cpu3>,
+		       <&cpu4>, <&cpu5>, <&cpu6>, <&cpu7>;
+	};
+
+	dmic_codec: dmic-codec {
+		compatible = "dmic-codec";
+		num-channels = <2>;
+		wakeup-delay-ms = <50>;
+	};
+
+	pmu-a55 {
+		compatible = "arm,cortex-a55-pmu";
+		interrupt-parent = <&gic>;
+		interrupts = <GIC_PPI 7 IRQ_TYPE_LEVEL_HIGH &ppi_cluster0>;
+	};
+
+	pmu-a78 {
+		compatible = "arm,cortex-a78-pmu";
+		interrupt-parent = <&gic>;
+		interrupts = <GIC_PPI 7 IRQ_TYPE_LEVEL_HIGH &ppi_cluster1>;
+	};
+
+	psci {
+		compatible = "arm,psci-1.0";
+		method = "smc";
+	};
+
+        performance: performance-controller@11bc10 {
+                compatible = "mediatek,cpufreq-hw";
+                reg = <0 0x0011bc10 0 0x120>, <0 0x0011bd30 0 0x120>;
+                #performance-domain-cells = <1>;
+        };
+
+	timer: timer {
+		compatible = "arm,armv8-timer";
+		interrupt-parent = <&gic>;
+		interrupts = <GIC_PPI 13 IRQ_TYPE_LEVEL_HIGH 0>,
+			     <GIC_PPI 14 IRQ_TYPE_LEVEL_HIGH 0>,
+			     <GIC_PPI 11 IRQ_TYPE_LEVEL_HIGH 0>,
+			     <GIC_PPI 10 IRQ_TYPE_LEVEL_HIGH 0>;
+		clock-frequency = <13000000>;
+	};
+
+	soc {
+		#address-cells = <2>;
+		#size-cells = <2>;
+		compatible = "simple-bus";
+		ranges;
+
+		gic: interrupt-controller@c000000 {
+			compatible = "arm,gic-v3";
+			#interrupt-cells = <4>;
+			#redistributor-regions = <1>;
+			interrupt-parent = <&gic>;
+			interrupt-controller;
+			reg = <0 0x0c000000 0 0x40000>,
+			      <0 0x0c040000 0 0x200000>;
+			interrupts = <GIC_PPI 9 IRQ_TYPE_LEVEL_HIGH 0>;
+
+			ppi-partitions {
+				ppi_cluster0: interrupt-partition-0 {
+					affinity = <&cpu0 &cpu1 &cpu2 &cpu3>;
+				};
+				ppi_cluster1: interrupt-partition-1 {
+					affinity = <&cpu4 &cpu5 &cpu6 &cpu7>;
+				};
+			};
+		};
+
+		dbgtop: dbgtop@1000d000 {
+                       compatible = "mediatek,dbgtop";
+                       reg = <0 0x1000d000 0 0x1000>;
+		};
+
+		dfd@0c600000 {
+			compatible = "mediatek,dfd";
+			mediatek,enabled = <1>;
+			mediatek,chain_length = <0xbe29>;
+			mediatek,rg_dfd_timeout = <0xc8>;
+			dfd,base_addr_msb = <0x6A000000>;
+			dfd,base_addr = <0x6A000000>;
+		};
+
+		topckgen: syscon@10000000 {
+			compatible = "mediatek,mt8195-topckgen", "syscon";
+			reg = <0 0x10000000 0 0x1000>;
+			#clock-cells = <1>;
+		};
+
+		infracfg_ao: infracfg_ao@10001000 {
+			compatible = "mediatek,mt8195-infracfg_ao", "syscon", "simple-mfd";
+			reg = <0 0x10001000 0 0x1000>;
+			#clock-cells = <1>;
+
+			infracfg_rst: reset-controller {
+				compatible = "ti,syscon-reset";
+				#reset-cells = <1>;
+				ti,reset-bits = <
+					0x140 18 0x144 18 0 0 (ASSERT_SET | DEASSERT_SET | STATUS_NONE)
+					0x120 1 0x124 1 0 0     (ASSERT_SET | DEASSERT_SET | STATUS_NONE)
+					0x730 1 0x734 1 0 0     (ASSERT_SET | DEASSERT_SET | STATUS_NONE)
+					0x150 5 0x154 5 0 0     (ASSERT_SET | DEASSERT_SET | STATUS_NONE)
+				>;
+			};
+		};
+
+		pericfg: syscon@10003000 {
+			compatible = "mediatek,mt8195-pericfg", "syscon";
+			reg = <0 0x10003000 0 0x1000>;
+			#clock-cells = <1>;
+		};
+
+		pio: pinctrl@10005000 {
+			compatible = "mediatek,mt8195-pinctrl";
+			reg = <0 0x10005000 0 0x1000>,
+			      <0 0x11d10000 0 0x1000>,
+			      <0 0x11d30000 0 0x1000>,
+			      <0 0x11d40000 0 0x1000>,
+			      <0 0x11e20000 0 0x1000>,
+			      <0 0x11eb0000 0 0x1000>,
+			      <0 0x11f40000 0 0x1000>,
+			      <0 0x1000b000 0 0x1000>;
+			reg-names = "iocfg0", "iocfg_bm", "iocfg_bl",
+				    "iocfg_br", "iocfg_lm", "iocfg_rb",
+				    "iocfg_tl", "eint";
+			gpio-controller;
+			#gpio-cells = <2>;
+			gpio-ranges = <&pio 0 0 144>;
+			interrupt-controller;
+			interrupts = <GIC_SPI 235 IRQ_TYPE_LEVEL_HIGH 0>;
+			#interrupt-cells = <2>;
+
+			hdmi_pin: hdmipinctrl {
+				hdmi_hotplug {
+					pinmux = <PINMUX_GPIO32__FUNC_HDMITX20_HTPLG>;
+					bias-pull-down;
+				};
+				hdmi_ddc {
+					pinmux = <PINMUX_GPIO34__FUNC_HDMITX20_SCL>,
+						<PINMUX_GPIO35__FUNC_HDMITX20_SDA>;
+					mediatek,drive-strength-adv = <0>;
+					drive-strength = <MTK_DRIVE_10mA>;
+				};
+				hdmi_cec {
+					pinmux = <PINMUX_GPIO33__FUNC_HDMITX20_CEC>;
+					bias-disable;
+				};
+				hdmi_5vctrl {
+					pinmux = <PINMUX_GPIO31__FUNC_GPIO31>;
+					slew-rate = <1>;
+					output-high;
+				};
+			};
+		};
+
+		scpsys: syscon@10006000 {
+			compatible = "syscon", "simple-mfd";
+			reg = <0 0x10006000 0 0x1000>;
+			#power-domain-cells = <1>;
+
+			/* System Power Manager */
+			spm: power-controller {
+				compatible = "mediatek,mt8195-power-controller";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				#power-domain-cells = <1>;
+
+				/* power domain of the SoC */
+				mfg0: power-domain@MT8195_POWER_DOMAIN_MFG0 {
+					reg = <MT8195_POWER_DOMAIN_MFG0>;
+					#address-cells = <1>;
+					#size-cells = <0>;
+					#power-domain-cells = <1>;
+
+					power-domain@MT8195_POWER_DOMAIN_MFG1 {
+						reg = <MT8195_POWER_DOMAIN_MFG1>;
+						clocks = <&apmixedsys CLK_APMIXED_MFGPLL>;
+						clock-names = "mfg";
+						mediatek,infracfg = <&infracfg_ao>;
+						#address-cells = <1>;
+						#size-cells = <0>;
+						#power-domain-cells = <1>;
+
+						power-domain@MT8195_POWER_DOMAIN_MFG2 {
+							reg = <MT8195_POWER_DOMAIN_MFG2>;
+							#power-domain-cells = <0>;
+						};
+
+						power-domain@MT8195_POWER_DOMAIN_MFG3 {
+							reg = <MT8195_POWER_DOMAIN_MFG3>;
+							#power-domain-cells = <0>;
+						};
+
+						power-domain@MT8195_POWER_DOMAIN_MFG4 {
+							reg = <MT8195_POWER_DOMAIN_MFG4>;
+							#power-domain-cells = <0>;
+						};
+
+						power-domain@MT8195_POWER_DOMAIN_MFG5 {
+							reg = <MT8195_POWER_DOMAIN_MFG5>;
+							#power-domain-cells = <0>;
+						};
+
+						power-domain@MT8195_POWER_DOMAIN_MFG6 {
+							reg = <MT8195_POWER_DOMAIN_MFG6>;
+							#power-domain-cells = <0>;
+						};
+					};
+				};
+
+				power-domain@MT8195_POWER_DOMAIN_VPPSYS0 {
+					reg = <MT8195_POWER_DOMAIN_VPPSYS0>;
+					clocks = <&topckgen CLK_TOP_VPP>,
+						 <&topckgen CLK_TOP_CAM>,
+						 <&topckgen CLK_TOP_CCU>,
+						 <&topckgen CLK_TOP_IMG>,
+						 <&topckgen CLK_TOP_VENC>,
+						 <&topckgen CLK_TOP_VDEC>,
+						 <&topckgen CLK_TOP_WPE_VPP>,
+						 <&topckgen CLK_TOP_CFG_VPP0>,
+						 <&vppsys0 CLK_VPP0_SMI_COMMON>,
+						 <&vppsys0 CLK_VPP0_GALS_VDO0_LARB0>,
+						 <&vppsys0 CLK_VPP0_GALS_VDO0_LARB1>,
+						 <&vppsys0 CLK_VPP0_GALS_VENCSYS>,
+						 <&vppsys0 CLK_VPP0_GALS_VENCSYS_CORE1>,
+						 <&vppsys0 CLK_VPP0_GALS_INFRA>,
+						 <&vppsys0 CLK_VPP0_GALS_CAMSYS>,
+						 <&vppsys0 CLK_VPP0_GALS_VPP1_LARB5>,
+						 <&vppsys0 CLK_VPP0_GALS_VPP1_LARB6>,
+						 <&vppsys0 CLK_VPP0_SMI_REORDER>,
+						 <&vppsys0 CLK_VPP0_SMI_IOMMU>,
+						 <&vppsys0 CLK_VPP0_GALS_IMGSYS_CAMSYS>,
+						 <&vppsys0 CLK_VPP0_GALS_EMI0_EMI1>,
+						 <&vppsys0 CLK_VPP0_SMI_SUB_COMMON_REORDER>,
+						 <&vppsys0 CLK_VPP0_SMI_RSI>,
+						 <&vppsys0 CLK_VPP0_SMI_COMMON_LARB4>,
+						 <&vppsys0 CLK_VPP0_GALS_VDEC_VDEC_CORE1>,
+						 <&vppsys0 CLK_VPP0_GALS_VPP1_WPE>,
+						 <&vppsys0 CLK_VPP0_GALS_VDO0_VDO1_VENCSYS_CORE1>;
+					clock-names = "vppsys", "vppsys1", "vppsys2", "vppsys3",
+						      "vppsys4", "vppsys5", "vppsys6", "vppsys7",
+						      "vppsys0-0", "vppsys0-1", "vppsys0-2", "vppsys0-3",
+						      "vppsys0-4", "vppsys0-5", "vppsys0-6", "vppsys0-7",
+						      "vppsys0-8", "vppsys0-9", "vppsys0-10", "vppsys0-11",
+						      "vppsys0-12", "vppsys0-13", "vppsys0-14",
+						      "vppsys0-15", "vppsys0-16", "vppsys0-17",
+						      "vppsys0-18";
+					mediatek,infracfg = <&infracfg_ao>;
+					#address-cells = <1>;
+					#size-cells = <0>;
+					#power-domain-cells = <1>;
+
+					power-domain@MT8195_POWER_DOMAIN_VDEC1 {
+						reg = <MT8195_POWER_DOMAIN_VDEC1>;
+						clocks = <&vdecsys CLK_VDEC_LARB1>;
+						clock-names = "vdec1-0";
+						mediatek,infracfg = <&infracfg_ao>;
+						#power-domain-cells = <0>;
+					};
+
+					power-domain@MT8195_POWER_DOMAIN_VENC_CORE1 {
+						reg = <MT8195_POWER_DOMAIN_VENC_CORE1>;
+						mediatek,infracfg = <&infracfg_ao>;
+						#power-domain-cells = <0>;
+					};
+
+					power-domain@MT8195_POWER_DOMAIN_VDOSYS0 {
+						reg = <MT8195_POWER_DOMAIN_VDOSYS0>;
+						clocks = <&topckgen CLK_TOP_CFG_VDO0>,
+							 <&vdosys0 CLK_VDO0_SMI_GALS>,
+							 <&vdosys0 CLK_VDO0_SMI_COMMON>,
+							 <&vdosys0 CLK_VDO0_SMI_EMI>,
+							 <&vdosys0 CLK_VDO0_SMI_IOMMU>,
+							 <&vdosys0 CLK_VDO0_SMI_LARB>,
+							 <&vdosys0 CLK_VDO0_SMI_RSI>;
+						clock-names = "vdosys0", "vdosys0-0", "vdosys0-1",
+							      "vdosys0-2", "vdosys0-3",
+							      "vdosys0-4", "vdosys0-5";
+						mediatek,infracfg = <&infracfg_ao>;
+						#address-cells = <1>;
+						#size-cells = <0>;
+						#power-domain-cells = <1>;
+
+						power-domain@MT8195_POWER_DOMAIN_VPPSYS1 {
+							reg = <MT8195_POWER_DOMAIN_VPPSYS1>;
+							clocks = <&topckgen CLK_TOP_CFG_VPP1>,
+								 <&vppsys1 CLK_VPP1_VPPSYS1_GALS>,
+								 <&vppsys1 CLK_VPP1_VPPSYS1_LARB>;
+							clock-names = "vppsys1", "vppsys1-0",
+								      "vppsys1-1";
+							mediatek,infracfg = <&infracfg_ao>;
+							#power-domain-cells = <0>;
+						};
+
+						power-domain@MT8195_POWER_DOMAIN_WPESYS {
+							reg = <MT8195_POWER_DOMAIN_WPESYS>;
+							clocks = <&wpesys CLK_WPE_SMI_LARB7>,
+								 <&wpesys CLK_WPE_SMI_LARB8>,
+								 <&wpesys CLK_WPE_SMI_LARB7_P>,
+								 <&wpesys CLK_WPE_SMI_LARB8_P>;
+							clock-names = "wepsys-0", "wepsys-1", "wepsys-2",
+								      "wepsys-3";
+							mediatek,infracfg = <&infracfg_ao>;
+							#power-domain-cells = <0>;
+						};
+
+						power-domain@MT8195_POWER_DOMAIN_VDEC0 {
+							reg = <MT8195_POWER_DOMAIN_VDEC0>;
+							clocks = <&vdecsys_soc CLK_VDEC_SOC_LARB1>;
+							clock-names = "vdec0-0";
+							mediatek,infracfg = <&infracfg_ao>;
+							#power-domain-cells = <0>;
+						};
+
+						power-domain@MT8195_POWER_DOMAIN_VDEC2 {
+							reg = <MT8195_POWER_DOMAIN_VDEC2>;
+							clocks = <&vdecsys_core1 CLK_VDEC_CORE1_LARB1>;
+							clock-names = "vdec2-0";
+							mediatek,infracfg = <&infracfg_ao>;
+							#power-domain-cells = <0>;
+						};
+
+						power-domain@MT8195_POWER_DOMAIN_VENC {
+							reg = <MT8195_POWER_DOMAIN_VENC>;
+							mediatek,infracfg = <&infracfg_ao>;
+							#power-domain-cells = <0>;
+						};
+
+						power-domain@MT8195_POWER_DOMAIN_VDOSYS1 {
+							reg = <MT8195_POWER_DOMAIN_VDOSYS1>;
+							clocks = <&topckgen CLK_TOP_CFG_VDO1>,
+								 <&vdosys1 CLK_VDO1_SMI_LARB2>,
+								 <&vdosys1 CLK_VDO1_SMI_LARB3>,
+								 <&vdosys1 CLK_VDO1_GALS>;
+							clock-names = "vdosys1", "vdosys1-0",
+								      "vdosys1-1", "vdosys1-2";
+							mediatek,infracfg = <&infracfg_ao>;
+							#address-cells = <1>;
+							#size-cells = <0>;
+							#power-domain-cells = <1>;
+
+							power-domain@MT8195_POWER_DOMAIN_DP_TX {
+								reg = <MT8195_POWER_DOMAIN_DP_TX>;
+								mediatek,infracfg = <&infracfg_ao>;
+								#power-domain-cells = <0>;
+							};
+
+							power-domain@MT8195_POWER_DOMAIN_EPD_TX {
+								reg = <MT8195_POWER_DOMAIN_EPD_TX>;
+								mediatek,infracfg = <&infracfg_ao>;
+								#power-domain-cells = <0>;
+							};
+
+							power-domain@MT8195_POWER_DOMAIN_HDMI_TX {
+								reg = <MT8195_POWER_DOMAIN_HDMI_TX>;
+								clocks = <&topckgen CLK_TOP_HDMI_APB>;
+								clock-names = "hdmi_tx";
+								#power-domain-cells = <0>;
+							};
+						};
+
+						power-domain@MT8195_POWER_DOMAIN_IMG {
+							reg = <MT8195_POWER_DOMAIN_IMG>;
+							clocks = <&imgsys CLK_IMG_LARB9>,
+								 <&imgsys CLK_IMG_GALS>;
+							clock-names = "img-0", "img-1";
+							mediatek,infracfg = <&infracfg_ao>;
+							#address-cells = <1>;
+							#size-cells = <0>;
+							#power-domain-cells = <1>;
+
+							power-domain@MT8195_POWER_DOMAIN_DIP {
+								reg = <MT8195_POWER_DOMAIN_DIP>;
+								#power-domain-cells = <0>;
+							};
+
+							power-domain@MT8195_POWER_DOMAIN_IPE {
+								reg = <MT8195_POWER_DOMAIN_IPE>;
+								clocks = <&topckgen CLK_TOP_IPE>,
+									 <&imgsys CLK_IMG_IPE>,
+									 <&ipesys CLK_IPE_SMI_LARB12>;
+								clock-names = "ipe", "ipe-0", "ipe-1";
+								mediatek,infracfg = <&infracfg_ao>;
+								#power-domain-cells = <0>;
+							};
+						};
+
+						power-domain@MT8195_POWER_DOMAIN_CAM {
+							reg = <MT8195_POWER_DOMAIN_CAM>;
+							clocks = <&camsys CLK_CAM_LARB13>,
+								 <&camsys CLK_CAM_LARB14>,
+								 <&camsys CLK_CAM_CAM2MM0_GALS>,
+								 <&camsys CLK_CAM_CAM2MM1_GALS>,
+								 <&camsys CLK_CAM_CAM2SYS_GALS>;
+							clock-names = "cam-0", "cam-1", "cam-2", "cam-3",
+								      "cam-4";
+							mediatek,infracfg = <&infracfg_ao>;
+							#address-cells = <1>;
+							#size-cells = <0>;
+							#power-domain-cells = <1>;
+
+							power-domain@MT8195_POWER_DOMAIN_CAM_RAWA {
+								reg = <MT8195_POWER_DOMAIN_CAM_RAWA>;
+								#power-domain-cells = <0>;
+							};
+
+							power-domain@MT8195_POWER_DOMAIN_CAM_RAWB {
+								reg = <MT8195_POWER_DOMAIN_CAM_RAWB>;
+								#power-domain-cells = <0>;
+							};
+
+							power-domain@MT8195_POWER_DOMAIN_CAM_MRAW {
+								reg = <MT8195_POWER_DOMAIN_CAM_MRAW>;
+								#power-domain-cells = <0>;
+							};
+						};
+					};
+				};
+
+				power-domain@MT8195_POWER_DOMAIN_PCIE_MAC_P0 {
+					reg = <MT8195_POWER_DOMAIN_PCIE_MAC_P0>;
+					mediatek,infracfg = <&infracfg_ao>;
+					#power-domain-cells = <0>;
+				};
+
+				power-domain@MT8195_POWER_DOMAIN_PCIE_MAC_P1 {
+					reg = <MT8195_POWER_DOMAIN_PCIE_MAC_P1>;
+					mediatek,infracfg = <&infracfg_ao>;
+					#power-domain-cells = <0>;
+				};
+
+				power-domain@MT8195_POWER_DOMAIN_PCIE_PHY {
+					reg = <MT8195_POWER_DOMAIN_PCIE_PHY>;
+					#power-domain-cells = <0>;
+				};
+
+				power-domain@MT8195_POWER_DOMAIN_SSUSB_PCIE_PHY {
+					reg = <MT8195_POWER_DOMAIN_SSUSB_PCIE_PHY>;
+					#power-domain-cells = <0>;
+				};
+
+				power-domain@MT8195_POWER_DOMAIN_CSI_RX_TOP {
+					reg = <MT8195_POWER_DOMAIN_CSI_RX_TOP>;
+					clocks = <&topckgen CLK_TOP_SENINF>,
+						 <&topckgen CLK_TOP_SENINF2>;
+					clock-names = "csi_rx_top", "csi_rx_top1";
+					#power-domain-cells = <0>;
+				};
+
+				power-domain@MT8195_POWER_DOMAIN_ETHER {
+					reg = <MT8195_POWER_DOMAIN_ETHER>;
+					clocks = <&pericfg_ao CLK_PERI_AO_ETHERNET_MAC>;
+					clock-names = "ether";
+					#power-domain-cells = <0>;
+				};
+
+				power-domain@MT8195_POWER_DOMAIN_ADSP {
+					reg = <MT8195_POWER_DOMAIN_ADSP>;
+					clocks = <&topckgen CLK_TOP_ADSP>,
+						 <&topckgen CLK_TOP_AUDIO_LOCAL_BUS>;
+					clock-names = "adsp", "adsp1";
+					#address-cells = <1>;
+					#size-cells = <0>;
+					mediatek,infracfg = <&infracfg_ao>;
+					#power-domain-cells = <1>;
+
+					power-domain@MT8195_POWER_DOMAIN_AUDIO {
+						reg = <MT8195_POWER_DOMAIN_AUDIO>;
+						clocks = <&topckgen CLK_TOP_A1SYS_HP>,
+							 <&topckgen CLK_TOP_AUD_INTBUS>,
+							 <&topckgen CLK_TOP_AUDIO_LOCAL_BUS>,
+							 <&infracfg_ao CLK_INFRA_AO_AUDIO_26M_B>;
+						clock-names = "audio", "audio1", "audio2",
+							      "audio3";
+						mediatek,infracfg = <&infracfg_ao>;
+						#power-domain-cells = <0>;
+					};
+				};
+			};
+		};
+
+		watchdog: watchdog@10007000 {
+			compatible = "mediatek,mt8195-wdt", "mediatek,mt6589-wdt";
+			disable_extrst;
+			reg = <0 0x10007000 0 0x100>;
+		};
+
+		apmixedsys: syscon@1000c000 {
+			compatible = "mediatek,mt8195-apmixedsys", "syscon";
+			reg = <0 0x1000c000 0 0x1000>;
+			#clock-cells = <1>;
+		};
+
+		cec: cec@10014000 {
+			compatible = "mediatek,mt8195-cec";
+			reg = <0 0x10014000 0 0x100>;
+			interrupts = <GIC_SPI 680 IRQ_TYPE_LEVEL_HIGH 0>;
+			clocks = <&infracfg_ao CLK_INFRA_AO_CEC_66M_H>,
+				 <&infracfg_ao CLK_INFRA_AO_CEC_66M_B>,
+				 <&infracfg_ao CLK_INFRA_AO_HDMI_32K>,
+				 <&infracfg_ao CLK_INFRA_AO_HDMI_26M>;
+			clock-names = "cec_66m_h",
+				      "cec_66m_b",
+				      "hdmi_32k",
+				      "hdmi_26m";
+			hdmi = <&hdmi0>;
+		};
+
+		systimer: timer@10017000 {
+			compatible = "mediatek,mt8195-timer", "mediatek,mt6765-timer";
+			reg = <0 0x10017000 0 0x1000>;
+			interrupts = <GIC_SPI 265 IRQ_TYPE_LEVEL_HIGH 0>;
+			clocks = <&clk26m>;
+		};
+
+		pwrap: pwrap@10024000 {
+			compatible = "mediatek,mt8195-pwrap", "syscon";
+			reg = <0 0x10024000 0 0x1000>;
+			reg-names = "pwrap";
+			interrupts = <GIC_SPI 243 IRQ_TYPE_LEVEL_HIGH 0>;
+			clocks = <&infracfg_ao CLK_INFRA_AO_PMIC_AP>,
+				 <&infracfg_ao CLK_INFRA_AO_PMIC_TMR>;
+			clock-names = "spi", "wrap";
+			assigned-clocks = <&topckgen CLK_TOP_PWRAP_ULPOSC>;
+			assigned-clock-parents = <&topckgen CLK_TOP_ULPOSC1_D10>;
+		};
+
+		spmi: spmi@10027000 {
+			compatible = "mediatek,mt8195-spmi";
+			reg = <0 0x10027000 0 0x000e00>,
+			      <0 0x10029000 0 0x000100>;
+			reg-names = "pmif", "spmimst";
+			clocks = <&infracfg_ao CLK_INFRA_AO_PMIC_AP>,
+				 <&infracfg_ao CLK_INFRA_AO_PMIC_TMR>,
+				 <&topckgen CLK_TOP_SPMI_M_MST>;
+			clock-names = "pmif_sys_ck",
+				      "pmif_tmr_ck",
+				      "spmimst_clk_mux";
+			assigned-clocks = <&topckgen CLK_TOP_PWRAP_ULPOSC>;
+			assigned-clock-parents = <&topckgen CLK_TOP_ULPOSC1_D10>;
+		};
+
+		nnasys: syscon@10211000 {
+			compatible = "mediatek,mt8195-nnasys", "syscon";
+			reg = <0 0x10211000 0 0x1000>;
+			#clock-cells = <1>;
+		};
+
+		iommu_infra: infra-iommu@10315000 {
+			compatible = "mediatek,mt8195-iommu-infra";
+			reg = <0 0x10315000 0 0x5000>;
+			interrupts = <GIC_SPI 795 IRQ_TYPE_LEVEL_HIGH 0>,
+				     <GIC_SPI 796 IRQ_TYPE_LEVEL_HIGH 0>,
+				     <GIC_SPI 797 IRQ_TYPE_LEVEL_HIGH 0>,
+				     <GIC_SPI 798 IRQ_TYPE_LEVEL_HIGH 0>,
+				     <GIC_SPI 799 IRQ_TYPE_LEVEL_HIGH 0>;
+			clocks = <&clk26m>;
+			clock-names = "bclk";
+			#iommu-cells = <1>;
+		};
+
+		gce0: mdp_mailbox@10320000 {
+			compatible = "mediatek,mt8195-gce";
+			reg = <0 0x10320000 0 0x4000>;
+			interrupts = <GIC_SPI 226 IRQ_TYPE_LEVEL_HIGH 0>;
+			#mbox-cells = <2>;
+			clocks = <&infracfg_ao CLK_INFRA_AO_GCE>;
+		};
+
+		gce1: disp_mailbox@10330000 {
+			compatible = "mediatek,mt8195-gce";
+			reg = <0 0x10330000 0 0x4000>;
+			interrupts = <GIC_SPI 228 IRQ_TYPE_LEVEL_HIGH 0>;
+			#mbox-cells = <2>;
+			clocks = <&infracfg_ao CLK_INFRA_AO_GCE2>;
+		};
+
+		scp: scp@10500000 {
+			compatible = "mediatek,mt8195-scp";
+			reg = <0 0x10500000 0 0x100000>,
+			      <0 0x10700000 0 0x8000>,
+			      <0 0x10720000 0 0xe0000>;
+			reg-names = "sram", "l1tcm", "cfg";
+			interrupts = <GIC_SPI 462 IRQ_TYPE_LEVEL_HIGH 0>;
+			status = "okay";
+		};
+
+		scp_adsp: syscon@10720000 {
+			compatible = "mediatek,mt8195-scp_adsp", "syscon";
+			reg = <0 0x10720000 0 0x1000>;
+			#clock-cells = <1>;
+		};
+
+		afe: mt8195-afe-pcm@10890000 {
+			compatible = "mediatek,mt8195-audio";
+			reg = <0 0x10890000 0 0x10000>;
+			mediatek,topckgen = <&topckgen>;
+			power-domains = <&spm MT8195_POWER_DOMAIN_AUDIO>;
+			interrupts = <GIC_SPI 822 IRQ_TYPE_LEVEL_HIGH 0>;
+			clocks = <&clk26m>,
+				<&apmixedsys CLK_APMIXED_APLL1>,
+				<&apmixedsys CLK_APMIXED_APLL2>,
+				<&topckgen CLK_TOP_APLL12_DIV0>,
+				<&topckgen CLK_TOP_APLL12_DIV1>,
+				<&topckgen CLK_TOP_APLL12_DIV2>,
+				<&topckgen CLK_TOP_APLL12_DIV3>,
+				<&topckgen CLK_TOP_APLL12_DIV9>,
+				<&topckgen CLK_TOP_A1SYS_HP>,
+				<&topckgen CLK_TOP_AUD_INTBUS>,
+				<&topckgen CLK_TOP_AUDIO_H>,
+				<&topckgen CLK_TOP_AUDIO_LOCAL_BUS>,
+				<&topckgen CLK_TOP_DPTX_MCK>,
+				<&topckgen CLK_TOP_I2SO1_MCK>,
+				<&topckgen CLK_TOP_I2SO2_MCK>,
+				<&topckgen CLK_TOP_I2SI1_MCK>,
+				<&topckgen CLK_TOP_I2SI2_MCK>,
+				<&infracfg_ao CLK_INFRA_AO_AUDIO_26M_B>,
+				<&scp_adsp CLK_SCP_ADSP_AUDIODSP>;
+			clock-names = "clk26m",
+				"apll1_ck",
+				"apll2_ck",
+				"apll12_div0",
+				"apll12_div1",
+				"apll12_div2",
+				"apll12_div3",
+				"apll12_div9",
+				"a1sys_hp_sel",
+				"aud_intbus_sel",
+				"audio_h_sel",
+				"audio_local_bus_sel",
+				"dptx_m_sel",
+				"i2so1_m_sel",
+				"i2so2_m_sel",
+				"i2si1_m_sel",
+				"i2si2_m_sel",
+				"infra_ao_audio_26m_b",
+				"scp_adsp_audiodsp";
+			status = "disabled";
+		};
+
+		audsys_src: syscon@108a0000 {
+			compatible = "mediatek,mt8195-audsys_src", "syscon";
+			reg = <0 0x108a0000 0 0x2000>;
+			#clock-cells = <1>;
+		};
+
+		uart0: serial@11001100 {
+			compatible = "mediatek,mt8195-uart", "mediatek,mt6577-uart";
+			reg = <0 0x11001100 0 0x100>;
+			interrupts = <GIC_SPI 141 IRQ_TYPE_LEVEL_HIGH 0>;
+			clocks = <&clk26m>, <&clk26m>;
+			clock-names = "baud", "bus";
+			status = "disabled";
+		};
+
+		uart1: serial@11001200 {
+			compatible = "mediatek,mt8195-uart", "mediatek,mt6577-uart";
+			reg = <0 0x11001200 0 0x100>;
+			interrupts = <GIC_SPI 142 IRQ_TYPE_LEVEL_HIGH 0>;
+			clocks = <&clk26m>, <&clk26m>;
+			clock-names = "baud", "bus";
+		};
+
+		uart2: serial@11001300 {
+			compatible = "mediatek,mt8195-uart", "mediatek,mt6577-uart";
+			reg = <0 0x11001300 0 0x100>;
+			interrupts = <GIC_SPI 143 IRQ_TYPE_LEVEL_HIGH 0>;
+			clocks = <&clk26m>, <&clk26m>;
+			clock-names = "baud", "bus";
+			status = "disabled";
+		};
+
+		uart3: serial@11001400 {
+			compatible = "mediatek,mt8195-uart", "mediatek,mt6577-uart";
+			reg = <0 0x11001400 0 0x100>;
+			interrupts = <GIC_SPI 723 IRQ_TYPE_LEVEL_HIGH 0>;
+			clocks = <&clk26m>, <&clk26m>;
+			clock-names = "baud", "bus";
+			status = "disabled";
+		};
+
+		uart4: serial@11001500 {
+			compatible = "mediatek,mt8195-uart", "mediatek,mt6577-uart";
+			reg = <0 0x11001500 0 0x100>;
+			interrupts = <GIC_SPI 724 IRQ_TYPE_LEVEL_HIGH 0>;
+			clocks = <&clk26m>, <&clk26m>;
+			clock-names = "baud", "bus";
+			status = "disabled";
+		};
+
+		uart5: serial@11001600 {
+			compatible = "mediatek,mt8195-uart", "mediatek,mt6577-uart";
+			reg = <0 0x11001600 0 0x100>;
+			interrupts = <GIC_SPI 725 IRQ_TYPE_LEVEL_HIGH 0>;
+			clocks = <&clk26m>, <&clk26m>;
+			clock-names = "baud", "bus";
+			status = "disabled";
+		};
+
+		auxadc: auxadc@11002000 {
+			compatible = "mediatek,mt8195-auxadc", "mediatek,mt8173-auxadc";
+			reg = <0 0x11002000 0 0x1000>;
+			clocks = <&infracfg_ao CLK_INFRA_AO_AUXADC>;
+			clock-names = "main";
+			#io-channel-cells = <1>;
+			status = "disabled";
+		};
+
+		pericfg_ao: syscon@11003000 {
+			compatible = "mediatek,mt8195-pericfg_ao", "syscon";
+			reg = <0 0x11003000 0 0x1000>;
+			#clock-cells = <1>;
+		};
+
+		spi0: spi@1100a000 {
+			compatible = "mediatek,mt8195-spi",
+				     "mediatek,mt6765-spi";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			reg = <0 0x1100a000 0 0x1000>;
+			interrupts = <GIC_SPI 191 IRQ_TYPE_LEVEL_HIGH 0>;
+			clocks = <&topckgen CLK_TOP_UNIVPLL_D6_D2>,
+				 <&topckgen CLK_TOP_SPI>,
+				 <&infracfg_ao CLK_INFRA_AO_SPI0>;
+			clock-names = "parent-clk", "sel-clk", "spi-clk";
+			status = "disabled";
+		};
+
+		lvts: lvts@1100b000 {
+			compatible = "mediatek,mt8195-lvts";
+			#thermal-sensor-cells = <1>;
+			reg = <0 0x1100b000 0 0x1000>,
+				<0 0x11278000 0 0x1000>;
+			interrupts = <GIC_SPI 169 IRQ_TYPE_LEVEL_HIGH 0>,
+					<GIC_SPI 170 IRQ_TYPE_LEVEL_HIGH 0>;
+			clocks = <&infracfg_ao CLK_INFRA_AO_THERM>;
+			clock-names = "lvts_clk";
+			resets = <&infracfg_rst 1>,
+					<&infracfg_rst 2>;
+			nvmem-cells = <&lvts_e_data1 &lvts_e_data2>;
+			nvmem-cell-names = "e_data1","e_data2";
+		};
+
+		svs: svs@1100b000 {
+			compatible = "mediatek,mt8195-svs";
+			reg = <0 0x1100b000 0 0x1000>;
+			interrupts = <GIC_SPI 199 IRQ_TYPE_LEVEL_HIGH 0>;
+			clocks = <&infracfg_ao CLK_INFRA_AO_THERM>;
+			clock-names = "main";
+			nvmem-cells = <&svs_calibration>,
+				      <&lvts_e_data1>;
+			nvmem-cell-names = "svs-calibration-data",
+					   "t-calibration-data";
+			resets = <&infracfg_rst 3>;
+			reset-names = "svs_rst";
+		};
+
+		disp_pwm0: disp_pwm0@1100e000 {
+			compatible = "mediatek,mt8183-disp-pwm";
+			reg = <0 0x1100e000 0 0x1000>;
+			interrupts = <GIC_SPI 203 IRQ_TYPE_LEVEL_LOW 0>;
+			power-domains = <&spm MT8195_POWER_DOMAIN_VDOSYS0>;
+			#pwm-cells = <2>;
+			clocks = <&topckgen CLK_TOP_DISP_PWM0>,
+					<&infracfg_ao CLK_INFRA_AO_DISP_PWM>;
+			clock-names = "main", "mm";
+			status = "disabled";
+		};
+
+		disp_pwm1: disp_pwm1@1100f000 {
+			compatible = "mediatek,mt8183-disp-pwm";
+			reg = <0 0x1100f000 0 0x1000>;
+			interrupts = <GIC_SPI 793 IRQ_TYPE_LEVEL_HIGH 0>;
+			#pwm-cells = <2>;
+			clocks = <&topckgen CLK_TOP_DISP_PWM1>,
+				<&infracfg_ao CLK_INFRA_AO_DISP_PWM1>;
+			clock-names = "main", "mm";
+			status = "disabled";
+		};
+
+		spi1: spi@11010000 {
+			compatible = "mediatek,mt8195-spi",
+				     "mediatek,mt6765-spi";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			reg = <0 0x11010000 0 0x1000>;
+			interrupts = <GIC_SPI 192 IRQ_TYPE_LEVEL_HIGH 0>;
+			clocks = <&clk26m>,
+				 <&clk26m>,
+				 <&clk26m>;
+			clock-names = "parent-clk", "sel-clk", "spi-clk";
+			status = "disabled";
+		};
+
+		spi2: spi@11012000 {
+			compatible = "mediatek,mt8195-spi",
+				     "mediatek,mt6765-spi";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			reg = <0 0x11012000 0 0x1000>;
+			interrupts = <GIC_SPI 193 IRQ_TYPE_LEVEL_HIGH 0>;
+			clocks = <&clk26m>,
+				 <&clk26m>,
+				 <&clk26m>;
+			clock-names = "parent-clk", "sel-clk", "spi-clk";
+			status = "disabled";
+		};
+
+		spi3: spi@11013000 {
+			compatible = "mediatek,mt8195-spi",
+				     "mediatek,mt6765-spi";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			reg = <0 0x11013000 0 0x1000>;
+			interrupts = <GIC_SPI 194 IRQ_TYPE_LEVEL_HIGH 0>;
+			clocks = <&clk26m>,
+				 <&clk26m>,
+				 <&clk26m>;
+			clock-names = "parent-clk", "sel-clk", "spi-clk";
+			status = "disabled";
+		};
+
+		spi4: spi@11018000 {
+			compatible = "mediatek,mt8195-spi",
+				     "mediatek,mt6765-spi";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			reg = <0 0x11018000 0 0x1000>;
+			interrupts = <GIC_SPI 195 IRQ_TYPE_LEVEL_HIGH 0>;
+			clocks = <&clk26m>,
+				 <&clk26m>,
+				 <&clk26m>;
+			clock-names = "parent-clk", "sel-clk", "spi-clk";
+			status = "disabled";
+		};
+
+		spi5: spi@11019000 {
+			compatible = "mediatek,mt8195-spi",
+				     "mediatek,mt6765-spi";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			reg = <0 0x11019000 0 0x1000>;
+			interrupts = <GIC_SPI 196 IRQ_TYPE_LEVEL_HIGH 0>;
+			clocks = <&clk26m>,
+				 <&clk26m>,
+				 <&clk26m>;
+			clock-names = "parent-clk", "sel-clk", "spi-clk";
+			status = "disabled";
+		};
+
+		spi6: spi@1101d000 {
+			compatible = "mediatek,mt8195-spi",
+				     "mediatek,mt6765-spi";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			reg = <0 0x1101d000 0 0x1000>;
+			interrupts = <GIC_SPI 197 IRQ_TYPE_LEVEL_HIGH 0>;
+			clocks = <&clk26m>,
+				 <&clk26m>,
+				 <&clk26m>;
+			clock-names = "parent-clk", "sel-clk", "spi-clk";
+			status = "disabled";
+		};
+
+		spi7: spi@1101e000 {
+			compatible = "mediatek,mt8195-spi",
+				     "mediatek,mt6765-spi";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			reg = <0 0x1101e000 0 0x1000>;
+			interrupts = <GIC_SPI 198 IRQ_TYPE_LEVEL_HIGH 0>;
+			clocks = <&clk26m>,
+				 <&clk26m>,
+				 <&clk26m>;
+			clock-names = "parent-clk", "sel-clk", "spi-clk";
+			status = "disabled";
+		};
+
+		xhci: xhci@11200000 {
+			compatible = "mediatek,mt8195-xhci",
+				     "mediatek,mtk-xhci";
+			reg = <0 0x11200000 0 0x1000>,
+			      <0 0x11203e00 0 0x0100>;
+			reg-names = "mac", "ippc";
+			interrupts-extended = <&gic GIC_SPI 129 IRQ_TYPE_LEVEL_HIGH 0>,
+					      <&pio 219 IRQ_TYPE_LEVEL_LOW>;
+			interrupt-names = "host", "wakeup";
+			phys = <&u2port0 PHY_TYPE_USB2>,
+			       <&u3port0 PHY_TYPE_USB3>;
+			assigned-clocks = <&topckgen CLK_TOP_USB_TOP>,
+					  <&topckgen CLK_TOP_SSUSB_XHCI>;
+			assigned-clock-parents = <&topckgen CLK_TOP_UNIVPLL_D5_D4>,
+						 <&topckgen CLK_TOP_UNIVPLL_D5_D4>;
+			clocks = <&infracfg_ao CLK_INFRA_AO_SSUSB>,
+				 <&infracfg_ao CLK_INFRA_AO_SSUSB_XHCI>,
+				 <&topckgen CLK_TOP_SSUSB_REF>,
+				 <&apmixedsys CLK_APMIXED_USB1PLL>;
+			clock-names = "sys_ck", "xhci_ck", "ref_ck", "mcu_ck";
+			mediatek,syscon-wakeup = <&pericfg 0x400 103>;
+			wakeup-source;
+			#address-cells = <2>;
+			#size-cells = <2>;
+			status = "disabled";
+		};
+
+		mmc0: mmc@11230000 {
+			compatible = "mediatek,mt8195-mmc",
+				     "mediatek,mt8192-mmc",
+				     "mediatek,mt8183-mmc";
+			reg = <0 0x11230000 0 0x10000>,
+			      <0 0x11f50000 0 0x1000>;
+			interrupts = <GIC_SPI 131 IRQ_TYPE_LEVEL_HIGH 0>;
+			clocks = <&topckgen CLK_TOP_MSDC50_0>,
+				 <&infracfg_ao CLK_INFRA_AO_MSDC0>,
+				 <&infracfg_ao CLK_INFRA_AO_MSDC0_SRC>;
+			clock-names = "source", "hclk", "source_cg";
+			status = "disabled";
+		};
+
+		mmc1: mmc@11240000 {
+			compatible = "mediatek,mt8195-mmc",
+				     "mediatek,mt8192-mmc",
+				     "mediatek,mt8183-mmc";
+			reg = <0 0x11240000 0 0x1000>,
+			      <0 0x11c70000 0 0x1000>;
+			interrupts = <GIC_SPI 135 IRQ_TYPE_LEVEL_HIGH 0>;
+			clocks = <&topckgen CLK_TOP_MSDC30_1>,
+				 <&infracfg_ao CLK_INFRA_AO_MSDC1>,
+				 <&infracfg_ao CLK_INFRA_AO_MSDC1_SRC>;
+			clock-names = "source", "hclk", "source_cg";
+			assigned-clocks = <&topckgen CLK_TOP_MSDC30_1>;
+			assigned-clock-parents = <&topckgen CLK_TOP_MSDCPLL_D2>;
+			status = "disabled";
+		};
+
+		xhci1: xhci1@11290000 {
+			compatible = "mediatek,mt8195-xhci",
+				     "mediatek,mtk-xhci";
+			reg = <0 0x11290000 0 0x1000>,
+			      <0 0x11293e00 0 0x0100>;
+			reg-names = "mac", "ippc";
+			interrupts-extended = <&gic GIC_SPI 530 IRQ_TYPE_LEVEL_HIGH 0>,
+					     <&pio 218 IRQ_TYPE_LEVEL_LOW>;
+			interrupt-names = "host", "wakeup";
+			phys = <&u2port1 PHY_TYPE_USB2>;
+			assigned-clocks = <&topckgen CLK_TOP_USB_TOP_1P>,
+					  <&topckgen CLK_TOP_SSUSB_XHCI_1P>;
+			assigned-clock-parents = <&topckgen CLK_TOP_UNIVPLL_D5_D4>,
+						 <&topckgen CLK_TOP_UNIVPLL_D5_D4>;
+			clocks = <&pericfg_ao CLK_PERI_AO_SSUSB_1P_BUS>,
+				 <&pericfg_ao CLK_PERI_AO_SSUSB_1P_XHCI>,
+				 <&topckgen CLK_TOP_SSUSB_P1_REF>,
+				 <&apmixedsys CLK_APMIXED_USB1PLL>;
+			clock-names = "sys_ck", "xhci_ck", "ref_ck", "mcu_ck";
+			mediatek,syscon-wakeup = <&pericfg 0x400 104>;
+			wakeup-source;
+			mediatek,u3p-dis-msk = <0x1>;
+			#address-cells = <2>;
+			#size-cells = <2>;
+			status = "disabled";
+		};
+
+		xhci2: xhci2@112a0000 {
+			compatible = "mediatek,mt8195-xhci",
+				     "mediatek,mtk-xhci";
+			reg = <0 0x112a0000 0 0x1000>,
+			      <0 0x112a3e00 0 0x0100>;
+			reg-names = "mac", "ippc";
+			interrupts = <GIC_SPI 533 IRQ_TYPE_LEVEL_HIGH 0>;
+			phys = <&u2port2 PHY_TYPE_USB2>;
+			assigned-clocks = <&topckgen CLK_TOP_USB_TOP_2P>,
+					  <&topckgen CLK_TOP_SSUSB_XHCI_2P>;
+			assigned-clock-parents = <&topckgen CLK_TOP_UNIVPLL_D5_D4>,
+						 <&topckgen CLK_TOP_UNIVPLL_D5_D4>;
+			clocks = <&pericfg_ao CLK_PERI_AO_SSUSB_2P_BUS>,
+				 <&pericfg_ao CLK_PERI_AO_SSUSB_2P_XHCI>,
+				 <&topckgen CLK_TOP_SSUSB_P2_REF>;
+			clock-names = "sys_ck", "xhci_ck", "ref_ck";
+			#address-cells = <2>;
+			#size-cells = <2>;
+			status = "disabled";
+		};
+
+		xhci3: xhci3@112b0000 {
+			compatible = "mediatek,mt8195-xhci",
+				     "mediatek,mtk-xhci";
+			reg = <0 0x112b0000 0 0x1000>,
+			      <0 0x112b3e00 0 0x0100>;
+			reg-names = "mac", "ippc";
+			interrupts-extended = <&gic GIC_SPI 536 IRQ_TYPE_LEVEL_HIGH 0>,
+					      <&pio 221 IRQ_TYPE_LEVEL_LOW>;
+			interrupts-names = "host", "wakeup";
+			phys = <&u2port3 PHY_TYPE_USB2>;
+			assigned-clocks = <&topckgen CLK_TOP_USB_TOP_3P>,
+					  <&topckgen CLK_TOP_SSUSB_XHCI_3P>;
+			assigned-clock-parents = <&topckgen CLK_TOP_UNIVPLL_D5_D4>,
+						 <&topckgen CLK_TOP_UNIVPLL_D5_D4>;
+			clocks = <&pericfg_ao CLK_PERI_AO_SSUSB_3P_BUS>,
+				 <&pericfg_ao CLK_PERI_AO_SSUSB_3P_XHCI>,
+				 <&topckgen CLK_TOP_SSUSB_P3_REF>;
+			clock-names = "sys_ck", "xhci_ck", "ref_ck";
+			mediatek,syscon-wakeup = <&pericfg 0x400 106>;
+			wakeup-source;
+			usb2-lpm-disable;
+			#address-cells = <2>;
+			#size-cells = <2>;
+			status = "disabled";
+		};
+
+		pcie0: pcie@112f0000 {
+			compatible = "mediatek,mt8192-pcie",
+				     "mediatek,mt8195-pcie";
+			device_type = "pci";
+			#address-cells = <3>;
+			#size-cells = <2>;
+			reg = <0 0x112f0000 0 0x4000>;
+			reg-names = "pcie-mac";
+			interrupts = <GIC_SPI 791 IRQ_TYPE_LEVEL_HIGH 0>;
+			bus-range = <0x00 0xff>;
+			ranges = <0x81000000 0 0x20000000
+				  0x0 0x20000000 0 0x200000>,
+				 <0x82000000 0 0x20200000
+				  0x0 0x20200000 0 0x3e00000>;
+
+			iommu-map = <0 &iommu_infra IOMMU_PORT_INFRA_PCIE0 0x2>;
+			iommu-map-mask = <0x0>;
+
+			status = "disabled";
+
+			clocks = <&infracfg_ao CLK_INFRA_AO_PCIE_PL_P_250M_P0>,
+				 <&infracfg_ao CLK_INFRA_AO_PCIE_TL_26M>,
+				 <&infracfg_ao CLK_INFRA_AO_PCIE_TL_96M>,
+				 <&infracfg_ao CLK_INFRA_AO_PCIE_TL_32K>,
+				 <&infracfg_ao CLK_INFRA_AO_PCIE_PERI_26M>,
+				 <&pericfg_ao CLK_PERI_AO_PCIE_P0_MEM>;
+			assigned-clocks = <&topckgen CLK_TOP_TL>;
+			assigned-clock-parents = <&topckgen CLK_TOP_MAINPLL_D4_D4>;
+
+			phys = <&pciephy>;
+			phy-names = "pcie-phy";
+			power-domains = <&spm MT8195_POWER_DOMAIN_PCIE_MAC_P0>;
+
+			#interrupt-cells = <1>;
+			interrupt-map-mask = <0 0 0 7>;
+			interrupt-map = <0 0 0 1 &pcie_intc0 0>,
+					<0 0 0 2 &pcie_intc0 1>,
+					<0 0 0 3 &pcie_intc0 2>,
+					<0 0 0 4 &pcie_intc0 3>;
+			pcie_intc0: interrupt-controller {
+				interrupt-controller;
+				#address-cells = <0>;
+				#interrupt-cells = <1>;
+			};
+		};
+
+		pcie1: pcie@112f8000 {
+			compatible = "mediatek,mt8192-pcie",
+				     "mediatek,mt8195-pcie";
+			device_type = "pci";
+			#address-cells = <3>;
+			#size-cells = <2>;
+			reg = <0 0x112f8000 0 0x4000>;
+			reg-names = "pcie-mac";
+			interrupts = <GIC_SPI 792 IRQ_TYPE_LEVEL_HIGH 0>;
+			bus-range = <0x00 0xff>;
+			ranges = <0x81000000 0 0x24000000
+				  0x0 0x24000000 0 0x200000>,
+				 <0x82000000 0 0x24200000
+				  0x0 0x24200000 0 0x3e00000>;
+
+			iommu-map = <0 &iommu_infra IOMMU_PORT_INFRA_PCIE1 0x2>;
+			iommu-map-mask = <0x0>;
+
+			status = "disabled";
+
+			clocks = <&infracfg_ao CLK_INFRA_AO_PCIE_PL_P_250M_P1>,
+				 <&infracfg_ao CLK_INFRA_AO_PCIE_P1_TL_96M>,
+				 <&infracfg_ao CLK_INFRA_AO_PCIE_P1_PERI_26M>,
+				 <&pericfg_ao CLK_PERI_AO_PCIE_P0_MEM>;
+			assigned-clocks = <&topckgen CLK_TOP_TL_P1>;
+			assigned-clock-parents = <&topckgen CLK_TOP_MAINPLL_D4_D4>;
+
+			phys = <&u3port1 PHY_TYPE_PCIE>;
+			phy-names = "pcie-phy";
+			power-domains = <&spm MT8195_POWER_DOMAIN_PCIE_MAC_P1>;
+
+			//resets = <&infracfg_rst 0>;
+			//reset-names = "phy";
+
+			#interrupt-cells = <1>;
+			interrupt-map-mask = <0 0 0 7>;
+			interrupt-map = <0 0 0 1 &pcie_intc1 0>,
+					<0 0 0 2 &pcie_intc1 1>,
+					<0 0 0 3 &pcie_intc1 2>,
+					<0 0 0 4 &pcie_intc1 3>;
+			pcie_intc1: interrupt-controller {
+				interrupt-controller;
+				#address-cells = <0>;
+				#interrupt-cells = <1>;
+			};
+		};
+
+		nor_flash: nor@1132c000 {
+			compatible = "mediatek,mt8195-nor", "mediatek,mt8173-nor";
+			reg = <0 0x1132c000 0 0x1000>;
+			interrupts = <GIC_SPI 825 IRQ_TYPE_LEVEL_HIGH 0>;
+			clocks = <&topckgen CLK_TOP_SPINOR>,
+				 <&pericfg_ao CLK_PERI_AO_FLASHIF_FLASH>,
+				 <&pericfg_ao CLK_PERI_AO_FLASHIF_BUS>;
+			clock-names = "spi", "sf", "axi";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			status = "disabled";
+		};
+
+		efuse: efuse@11c10000 {
+			compatible = "mediatek,efuse";
+			reg = <0 0x11c10000 0 0x1000>;
+			#address-cells = <1>;
+			#size-cells = <1>;
+
+			lvts_e_data1: data1 {
+				reg = <0x1bc 0x14>;
+			};
+			lvts_e_data2: data1-1 {
+				reg = <0x1d0 0x38>;
+			};
+			svs_calibration: calib@580 {
+				reg = <0x580 0x64>;
+			};
+		};
+
+		u3phy2: t-phy@11c40000 {
+			compatible = "mediatek,mt8195-tphy", "mediatek,generic-tphy-v3";
+			#address-cells = <1>;
+			#size-cells = <1>;
+			ranges = <0 0 0x11c40000 0x700>;
+			status = "disabled";
+
+			u2port2: usb-phy@0 {
+				reg = <0x0 0x700>;
+				clocks = <&topckgen CLK_TOP_SSUSB_PHY_P2_REF>;
+				clock-names = "ref";
+				#phy-cells = <1>;
+			};
+		};
+
+		u3phy3: t-phy@11c50000 {
+			compatible = "mediatek,mt8195-tphy", "mediatek,generic-tphy-v3";
+			#address-cells = <1>;
+			#size-cells = <1>;
+			ranges = <0 0 0x11c50000 0x700>;
+			status = "disabled";
+
+			u2port3: usb-phy@0 {
+				reg = <0x0 0x700>;
+				clocks = <&topckgen CLK_TOP_SSUSB_PHY_P3_REF>;
+				clock-names = "ref";
+				#phy-cells = <1>;
+			};
+		};
+
+		i2c5: i2c@11d00000 {
+			compatible = "mediatek,mt8195-i2c",
+				     "mediatek,mt8192-i2c";
+			reg = <0 0x11d00000 0 0x1000>,
+			      <0 0x10220580 0 0x80>;
+			interrupts = <GIC_SPI 154 IRQ_TYPE_LEVEL_HIGH 0>;
+			clock-div = <1>;
+			clocks = <&imp_iic_wrap_s CLK_IMP_IIC_WRAP_S_I2C5>,
+				 <&infracfg_ao CLK_INFRA_AO_APDMA_B>;
+			clock-names = "main", "dma";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			status = "disabled";
+		};
+
+		i2c7: i2c@11d02000 {
+			compatible = "mediatek,mt8195-i2c",
+				     "mediatek,mt8192-i2c";
+			reg = <0 0x11d02000 0 0x1000>,
+			      <0 0x10220680 0 0x80>;
+			interrupts = <GIC_SPI 156 IRQ_TYPE_LEVEL_HIGH 0>;
+			clock-div = <1>;
+			clocks = <&imp_iic_wrap_s CLK_IMP_IIC_WRAP_S_I2C7>,
+				 <&infracfg_ao CLK_INFRA_AO_APDMA_B>;
+			clock-names = "main", "dma";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			status = "disabled";
+		};
+
+		imp_iic_wrap_s: syscon@11d03000 {
+			compatible = "mediatek,mt8195-imp_iic_wrap_s", "syscon";
+			reg = <0 0x11d03000 0 0x1000>;
+			#clock-cells = <1>;
+		};
+
+		hdmi_phy: hdmi-phy@11d5f000 {
+			compatible = "mediatek,mt8195-hdmi-phy";
+			reg = <0 0x11d5f000 0 0x100>;
+			clocks = <&topckgen CLK_TOP_HDMI_XTAL>;
+			clock-names = "hdmi_xtal_sel";
+			clock-output-names = "hdmi_txpll";
+			#clock-cells = <0>;
+			#phy-cells = <0>;
+		};
+
+		i2c0: i2c@11e00000 {
+			compatible = "mediatek,mt8195-i2c",
+				     "mediatek,mt8192-i2c";
+			reg = <0 0x11e00000 0 0x1000>,
+			      <0 0x10220080 0 0x80>;
+			interrupts = <GIC_SPI 144 IRQ_TYPE_LEVEL_HIGH 0>;
+			clock-div = <1>;
+			clocks = <&imp_iic_wrap_w CLK_IMP_IIC_WRAP_W_I2C0>,
+				 <&infracfg_ao CLK_INFRA_AO_APDMA_B>;
+			clock-names = "main", "dma";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			status = "okay";
+		};
+
+		i2c1: i2c@11e01000 {
+			compatible = "mediatek,mt8195-i2c",
+				     "mediatek,mt8192-i2c";
+			reg = <0 0x11e01000 0 0x1000>,
+			      <0 0x10220200 0 0x80>;
+			interrupts = <GIC_SPI 147 IRQ_TYPE_LEVEL_HIGH 0>;
+			clock-div = <1>;
+			clocks = <&imp_iic_wrap_w CLK_IMP_IIC_WRAP_W_I2C1>,
+				 <&infracfg_ao CLK_INFRA_AO_APDMA_B>;
+			clock-names = "main", "dma";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			status = "disabled";
+		};
+
+		i2c2: i2c@11e02000 {
+			compatible = "mediatek,mt8195-i2c",
+				     "mediatek,mt8192-i2c";
+			reg = <0 0x11e02000 0 0x1000>,
+			      <0 0x10220380 0 0x80>;
+			interrupts = <GIC_SPI 150 IRQ_TYPE_LEVEL_HIGH 0>;
+			clock-div = <1>;
+			clocks = <&imp_iic_wrap_w CLK_IMP_IIC_WRAP_W_I2C2>,
+				 <&infracfg_ao CLK_INFRA_AO_APDMA_B>;
+			clock-names = "main", "dma";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			status = "disabled";
+		};
+
+		i2c3: i2c@11e03000 {
+			compatible = "mediatek,mt8195-i2c",
+				     "mediatek,mt8192-i2c";
+			reg = <0 0x11e03000 0 0x1000>,
+			      <0 0x10220480 0 0x80>;
+			interrupts = <GIC_SPI 152 IRQ_TYPE_LEVEL_HIGH 0>;
+			clock-div = <1>;
+			clocks = <&imp_iic_wrap_w CLK_IMP_IIC_WRAP_W_I2C3>,
+				 <&infracfg_ao CLK_INFRA_AO_APDMA_B>;
+			clock-names = "main", "dma";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			status = "disabled";
+		};
+
+		i2c4: i2c@11e04000 {
+			compatible = "mediatek,mt8195-i2c",
+				     "mediatek,mt8192-i2c";
+			reg = <0 0x11e04000 0 0x1000>,
+			      <0 0x10220500 0 0x80>;
+			interrupts = <GIC_SPI 153 IRQ_TYPE_LEVEL_HIGH 0>;
+			clock-div = <1>;
+			clocks = <&imp_iic_wrap_w CLK_IMP_IIC_WRAP_W_I2C4>,
+				 <&infracfg_ao CLK_INFRA_AO_APDMA_B>;
+			clock-names = "main", "dma";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			status = "disabled";
+		};
+
+		imp_iic_wrap_w: syscon@11e05000 {
+			compatible = "mediatek,mt8195-imp_iic_wrap_w", "syscon";
+			reg = <0 0x11e05000 0 0x1000>;
+			#clock-cells = <1>;
+		};
+
+		u3phy1: t-phy@11e30000 {
+			compatible = "mediatek,mt8195-tphy", "mediatek,generic-tphy-v3";
+			#address-cells = <1>;
+			#size-cells = <1>;
+			ranges = <0 0 0x11e30000 0xe00>;
+			power-domains = <&spm MT8195_POWER_DOMAIN_SSUSB_PCIE_PHY>;
+			status = "disabled";
+
+			u2port1: usb-phy@0 {
+				reg = <0x0 0x700>;
+				clocks = <&topckgen CLK_TOP_SSUSB_PHY_P1_REF>,
+					 <&clk26m>;
+				clock-names = "ref", "da_ref";
+				#phy-cells = <1>;
+			};
+
+			u3port1: usb-phy@700 {
+				reg = <0x700 0x700>;
+				clocks = <&apmixedsys CLK_APMIXED_PLL_SSUSB26M>,
+					 <&topckgen CLK_TOP_SSUSB_PHY_P1_REF>;
+				clock-names = "ref", "da_ref";
+				#phy-cells = <1>;
+			};
+		};
+
+		u3phy0: t-phy@11e40000 {
+			compatible = "mediatek,mt8195-tphy", "mediatek,generic-tphy-v3";
+			#address-cells = <1>;
+			#size-cells = <1>;
+			ranges = <0 0 0x11e40000 0xe00>;
+			status = "disabled";
+
+			u2port0: usb-phy@0 {
+				reg = <0x0 0x700>;
+				clocks = <&topckgen CLK_TOP_SSUSB_PHY_REF>,
+					 <&clk26m>;
+				clock-names = "ref", "da_ref";
+				#phy-cells = <1>;
+			};
+
+			u3port0: usb-phy@700 {
+				reg = <0x700 0x700>;
+				clocks = <&apmixedsys CLK_APMIXED_PLL_SSUSB26M>,
+					 <&topckgen CLK_TOP_SSUSB_PHY_REF>;
+				clock-names = "ref", "da_ref";
+				#phy-cells = <1>;
+			};
+		};
+
+		pciephy: phy@11e80000 {
+			compatible = "mediatek,mt8195-pcie-phy";
+			#address-cells = <2>;
+			#size-cells = <2>;
+			#phy-cells = <0>;
+			reg = <0 0x11e80000 0 0x10000>,
+			      <0 0x11e90000 0 0x10000>;
+			reg-names = "phy-sif", "phy-ckm";
+
+			power-domains = <&spm MT8195_POWER_DOMAIN_PCIE_PHY>;
+			status = "disabled";
+		};
+
+		ufsphy: phy@11fa0000 {
+			compatible = "mediatek,mt8195-ufsphy", "mediatek,mt8183-ufsphy";
+			reg = <0 0x11fa0000 0 0xc000>;
+			clocks = <&clk26m>, <&clk26m>;
+			clock-names = "unipro", "mp";
+			#phy-cells = <0>;
+			status = "disabled";
+		};
+
+		gpu: mali@13000000 {
+			compatible = "mediatek,mt8195-mali", "arm,mali-valhall";
+			reg = <0 0x13000000 0 0x4000>;
+			interrupts =
+				<GIC_SPI 395 IRQ_TYPE_LEVEL_HIGH 0>,
+				<GIC_SPI 396 IRQ_TYPE_LEVEL_HIGH 0>,
+				<GIC_SPI 397 IRQ_TYPE_LEVEL_HIGH 0>;
+			interrupt-names =
+				"GPU",
+				"MMU",
+				"JOB";
+
+			/*
+			 * Note: the properties below are not part of the
+			 * upstream binding.
+			 */
+			clocks =
+				<&topckgen CLK_TOP_MFG_CK_FAST_REF>,
+				<&apmixedsys CLK_APMIXED_MFGPLL>,
+				<&apmixedsys CLK_APMIXED_MFGPLL>,
+				<&topckgen CLK_TOP_MFG_CORE_TMP>,
+				<&mfgcfg CLK_MFG_BG3D>;
+
+			clock-names =
+				"clk_mux",
+				"clk_pll_src",
+				"clk_main_parent",
+				"clk_sub_parent",
+				"subsys_bg3d";
+
+			power-domains =
+				<&spm MT8195_POWER_DOMAIN_MFG2>,
+				<&spm MT8195_POWER_DOMAIN_MFG3>,
+				<&spm MT8195_POWER_DOMAIN_MFG4>,
+				<&spm MT8195_POWER_DOMAIN_MFG5>,
+				<&spm MT8195_POWER_DOMAIN_MFG6>;
+			power-domain-names = "core0",
+				"core1",
+				"core2",
+				"core3",
+				"core4";
+		};
+
+		gpu_opp_table: opp_table0 {
+			/*
+			 * Note: "operating-points-v2-mali" compatible and the
+			 * opp-core-mask properties are not part of upstream
+			 * binding.
+			 */
+
+			compatible = "operating-points-v2", "operating-points-v2-mali";
+			opp-shared;
+
+			opp-390000000 {
+				opp-hz = /bits/ 64 <390000000>;
+				opp-hz-real = /bits/ 64 <390000000>,
+					      /bits/ 64 <390000000>;
+				opp-microvolt = <625000>,
+						<750000>;
+			};
+
+			opp-410000000 {
+				opp-hz = /bits/ 64 <410000000>;
+				opp-hz-real = /bits/ 64 <410000000>,
+					      /bits/ 64 <410000000>;
+				opp-microvolt = <631250>,
+						<750000>;
+			};
+
+			opp-431000000 {
+				opp-hz = /bits/ 64 <431000000>;
+				opp-hz-real = /bits/ 64 <431000000>,
+					      /bits/ 64 <431000000>;
+				opp-microvolt = <631250>,
+						<750000>;
+			};
+
+			opp-473000000 {
+				opp-hz = /bits/ 64 <473000000>;
+				opp-hz-real = /bits/ 64 <473000000>,
+					      /bits/ 64 <473000000>;
+				opp-microvolt = <637500>,
+						<750000>;
+			};
+
+			opp-515000000 {
+				opp-hz = /bits/ 64 <515000000>;
+				opp-hz-real = /bits/ 64 <515000000>,
+					      /bits/ 64 <515000000>;
+				opp-microvolt = <637500>,
+						<750000>;
+			};
+
+			opp-556000000 {
+				opp-hz = /bits/ 64 <556000000>;
+				opp-hz-real = /bits/ 64 <556000000>,
+					      /bits/ 64 <556000000>;
+				opp-microvolt = <643750>,
+						<750000>;
+			};
+
+			opp-598000000 {
+				opp-hz = /bits/ 64 <598000000>;
+				opp-hz-real = /bits/ 64 <598000000>,
+					      /bits/ 64 <598000000>;
+				opp-microvolt = <650000>,
+						<750000>;
+			};
+
+			opp-640000000 {
+				opp-hz = /bits/ 64 <640000000>;
+				opp-hz-real = /bits/ 64 <640000000>,
+					      /bits/ 64 <640000000>;
+				opp-microvolt = <650000>,
+						<750000>;
+			};
+
+			opp-670000000 {
+				opp-hz = /bits/ 64 <670000000>;
+				opp-hz-real = /bits/ 64 <670000000>,
+					      /bits/ 64 <670000000>;
+				opp-microvolt = <662500>,
+						<750000>;
+			};
+
+			opp-700000000 {
+				opp-hz = /bits/ 64 <700000000>;
+				opp-hz-real = /bits/ 64 <700000000>,
+					      /bits/ 64 <700000000>;
+				opp-microvolt = <675000>,
+						<750000>;
+			};
+
+			opp-730000000 {
+				opp-hz = /bits/ 64 <730000000>;
+				opp-hz-real = /bits/ 64 <730000000>,
+					      /bits/ 64 <730000000>;
+				opp-microvolt = <687500>,
+						<750000>;
+			};
+
+			opp-760000000 {
+				opp-hz = /bits/ 64 <760000000>;
+				opp-hz-real = /bits/ 64 <760000000>,
+					      /bits/ 64 <760000000>;
+				opp-microvolt = <700000>,
+						<750000>;
+			};
+
+			opp-790000000 {
+				opp-hz = /bits/ 64 <790000000>;
+				opp-hz-real = /bits/ 64 <790000000>,
+					      /bits/ 64 <790000000>;
+				opp-microvolt = <712500>,
+						<750000>;
+			};
+
+			opp-820000000 {
+				opp-hz = /bits/ 64 <820000000>;
+				opp-hz-real = /bits/ 64 <820000000>,
+					      /bits/ 64 <820000000>;
+				opp-microvolt = <725000>,
+						<750000>;
+			};
+
+			opp-850000000 {
+				opp-hz = /bits/ 64 <850000000>;
+				opp-hz-real = /bits/ 64 <850000000>,
+					      /bits/ 64 <850000000>;
+				opp-microvolt = <737500>,
+						<750000>;
+			};
+
+			opp-880000000 {
+				opp-hz = /bits/ 64 <880000000>;
+				opp-hz-real = /bits/ 64 <880000000>,
+					      /bits/ 64 <880000000>;
+				opp-microvolt = <750000>,
+						<750000>;
+			};
+		};
+
+
+		mfgcfg: syscon@13fbf000 {
+			compatible = "mediatek,mt8195-mfgcfg", "syscon";
+			reg = <0 0x13fbf000 0 0x1000>;
+			#clock-cells = <1>;
+		};
+
+		vppsys0: syscon@14000000 {
+			compatible = "mediatek,mt8195-vppsys0", "syscon";
+			reg = <0 0x14000000 0 0x1000>;
+			mediatek,gce-client-reg = <&gce0 SUBSYS_1400XXXX 0 0x1000>;
+			#clock-cells = <1>;
+		};
+		
+		vpp0_mutex: vpp0_mutex@1400f000 {
+			compatible = "mediatek,vpp0_mutex";
+			reg = <0 0x1400f000 0 0x1000>;
+			mediatek,gce-client-reg = <&gce0 SUBSYS_1400XXXX 0xf000 0x1000>;
+			interrupts = <GIC_SPI 592 IRQ_TYPE_LEVEL_HIGH 0>;
+			#clocks = <&vppsys0 CLK_VPP0_MUTEX>;
+			#clock-names = "MDP_MUTEX0";
+			clocks = <&vppsys0 CLK_VPP0_MUTEX>,
+				 <&vppsys0 CLK_VPP0_WARP0_ASYNC_TX>,
+				 <&vppsys0 CLK_VPP0_WARP1_ASYNC_TX>,
+				 <&vppsys0 CLK_VPP0_VPP02VPP1_RELAY>,
+				 <&vppsys0 CLK_VPP0_VPP12VPP0_ASYNC>,
+				 <&vppsys0 CLK_VPP0_MMSYSRAM_TOP>,
+				 <&vppsys0 CLK_VPP0_WARP0_RELAY>,
+				 <&vppsys0 CLK_VPP0_WARP0_MDP_DL_ASYNC>,
+				 <&vppsys0 CLK_VPP0_WARP1_RELAY>,
+				 <&vppsys0 CLK_VPP0_WARP1_MDP_DL_ASYNC>,
+				 <&topckgen CLK_TOP_CFG_VPP0>,
+				 <&topckgen CLK_TOP_CFG_26M_VPP0>;
+			clock-names = "MDP_MUTEX0",
+					 "WARP0_ASYNC_TX",
+					 "WARP1_ASYNC_TX",
+					 "VPP02VPP1_RELAY",
+					 "VPP12VPP0_ASYNC",
+					 "MMSYSRAM_TOP",
+					 "WARP0_RELAY",
+					 "WARP0_MDP_DL_ASYNC",
+					 "WARP1_RELAY",
+					 "WARP1_MDP_DL_ASYNC",
+					 "TOP_CFG_VPP0",
+					 "TOP_CFG_26M_VPP0";
+			power-domains = <&spm MT8195_POWER_DOMAIN_VPPSYS0>;
+		};
+
+		mdp_rdma0: mdp_rdma0@14001000 {
+			compatible = "mediatek,mt8195-mdp-rdma", "mediatek,mt8195-mdp3";
+			mediatek,scp = <&scp>;
+			mediatek,mdp-id = <0>;
+			reg = <0 0x14001000 0 0x1000>;
+			mediatek,gce-client-reg = <&gce0 SUBSYS_1400XXXX 0x1000 0x1000>;
+			interrupts = <GIC_SPI 578 IRQ_TYPE_LEVEL_HIGH 0>;
+			power-domains = <&spm MT8195_POWER_DOMAIN_VPPSYS0>,
+							<&spm MT8195_POWER_DOMAIN_VPPSYS1>;
+			iommus = <&iommu_vpp M4U_PORT_L4_MDP_RDMA>,
+				 <&iommu_vpp M4U_PORT_L4_MDP_WROT>,
+				 <&iommu_vpp M4U_PORT_L6_SVPP3_MDP_RDMA>,
+				 <&iommu_vpp M4U_PORT_L6_SVPP3_MDP_WROT>;
+			clocks = <&vppsys0 CLK_VPP0_MDP_RDMA>;
+			clock-names = "MDP_RDMA0";
+			mediatek,mmsys2 = <&vppsys1>;
+			mediatek,mm-mutex2 = <&vpp1_mutex>;
+			mediatek,mmsys = <&vppsys0>;
+			mediatek,mm-mutex   = <&vpp0_mutex>;
+			mboxes =
+				<&gce0 12 CMDQ_THR_PRIO_1>,
+				<&gce0 13 CMDQ_THR_PRIO_1>,
+				<&gce0 14 CMDQ_THR_PRIO_1>,
+				<&gce0 21 CMDQ_THR_PRIO_1>,
+				<&gce0 22 CMDQ_THR_PRIO_1>;
+			/* To be removed after DRM enabled --> */
+			/* To Do: refine after mdp3 */
+			mdp_rdma0  = <&mdp_rdma0>;
+			mdp_rdma1  = <&svpp1_mdp_rdma>;
+			mdp_rdma2  = <&svpp2_mdp_rdma>;
+			mdp_rdma3  = <&svpp3_mdp_rdma>;
+			mdp_stitch = <&mdp_stitch0>;
+			mdp_rsz0   = <&mdp_rsz0>;
+			mdp_rsz1   = <&svpp1_mdp_rsz>;
+			mdp_rsz2   = <&svpp2_mdp_rsz>;
+			mdp_rsz3   = <&svpp3_mdp_rsz>;
+			mdp_wrot0  = <&mdp_wrot0>;
+			mdp_wrot1  = <&svpp1_mdp_wrot>;
+			mdp_wrot2  = <&svpp2_mdp_wrot>;
+			mdp_wrot3  = <&svpp3_mdp_wrot>;
+			mdp_tdshp0 = <&mdp_tdshp0>;
+			mdp_tdshp1 = <&svpp1_mdp_tdshp>;
+			mdp_tdshp2 = <&svpp2_mdp_tdshp>;
+			mdp_tdshp3 = <&svpp3_mdp_tdshp>;
+			mdp_aal0   = <&mdp_aal0>;
+			mdp_aal1   = <&svpp1_mdp_aal>;
+			mdp_aal2   = <&svpp2_mdp_aal>;
+			mdp_aal3   = <&svpp3_mdp_aal>;
+			mdp_color0 = <&mdp_color0>;
+			mdp_color1 = <&svpp1_mdp_color>;
+			mdp_color2 = <&svpp2_mdp_color>;
+			mdp_color3 = <&svpp3_mdp_color>;
+			mdp_hdr0   = <&mdp_hdr0>;
+			mdp_hdr1   = <&svpp1_mdp_hdr>;
+			mdp_hdr2   = <&svpp2_mdp_hdr>;
+			mdp_hdr3   = <&svpp3_mdp_hdr>;
+			mdp_fg0    = <&mdp_fg0>;
+			mdp_fg1    = <&svpp1_mdp_fg>;
+			mdp_fg2    = <&svpp2_mdp_fg>;
+			mdp_fg3    = <&svpp3_mdp_fg>;
+			mdp_tcc0   = <&mdp_tcc0>;
+			mdp_tcc1   = <&svpp1_mdp_tcc>;
+			mdp_ovl0   = <&mdp_ovl0>;
+			mdp_ovl1   = <&svpp1_mdp_ovl>;
+			mdp_pad0   = <&mdp_pad0>;
+			mdp_pad1   = <&svpp1_mdp_pad>;
+			mdp_pad2   = <&svpp2_mdp_pad>;
+			mdp_pad3   = <&svpp3_mdp_pad>;
+			mdp_split  = <&vpp_split0>;
+			mdp_merge2 = <&svpp2_mdp_merge>;
+			mdp_merge3 = <&svpp3_mdp_merge>;
+			mediatek,gce-events = <CMDQ_EVENT_VPP0_MDP_RDMA_SOF>,
+								<CMDQ_EVENT_VPP0_MDP_WROT_SOF>,
+								<CMDQ_EVENT_VPP0_MDP_RDMA_FRAME_DONE>,
+								<CMDQ_EVENT_VPP0_MDP_WROT_VIDO_WDONE>,
+								<CMDQ_EVENT_VPP1_SVPP1_MDP_RDMA_SOF>,
+								<CMDQ_EVENT_VPP1_SVPP2_MDP_RDMA_SOF>,
+								<CMDQ_EVENT_VPP1_SVPP3_MDP_RDMA_SOF>,
+								<CMDQ_EVENT_VPP1_SVPP1_MDP_WROT_SOF>,
+								<CMDQ_EVENT_VPP1_SVPP2_MDP_WROT_SOF>,
+								<CMDQ_EVENT_VPP1_SVPP3_MDP_WROT_SOF>,
+								<CMDQ_EVENT_VPP1_SVPP1_MDP_RDMA_FRAME_DONE>,
+								<CMDQ_EVENT_VPP1_SVPP2_MDP_RDMA_FRAME_DONE>,
+								<CMDQ_EVENT_VPP1_SVPP3_MDP_RDMA_FRAME_DONE>,
+								<CMDQ_EVENT_VPP1_SVPP1_MDP_WROT_FRAME_DONE>,
+								<CMDQ_EVENT_VPP1_SVPP2_MDP_WROT_FRAME_DONE>,
+								<CMDQ_EVENT_VPP1_SVPP3_MDP_WROT_FRAME_DONE>;
+			/* To Do: refine after DRM enabled */
+			thread_count = <24>;
+			mediatek,mailbox-gce = <&gce0>;
+			disp_mutex_reg = <0x14120000 0x1000>;
+			g3d_config_base = <0x13000000 0 0xffff0000>;
+			mmsys_config_base = <0x13000000 1 0xffff0000>;
+			disp_dither_base = <0x1c007000 2 0xffff0000>;
+			mm_na_base = <0x14020000 3 0xffff0000>;
+			imgsys_base = <0x15020000 4 0xffff0000>;
+			vdec_gcon_base = <0x18800000 5 0xffff0000>;
+			venc_gcon_base = <0x18810000 6 0xffff0000>;
+			conn_peri_base = <0x18820000 7 0xffff0000>;
+			topckgen_base = <0x18830000 8 0xffff0000>;
+			kp_base = <0x18840000 9 0xffff0000>;
+			scp_sram_base = <0x10000000 10 0xffff0000>;
+			infra_na3_base = <0x10010000 11 0xffff0000>;
+			infra_na4_base = <0x10020000 12 0xffff0000>;
+			scp_base = <0x10030000 13 0xffff0000>;
+			mcucfg_base = <0xc530000 14 0xffff0000>;
+			gcpu_base = <0x10050000 15 0xffff0000>;
+			usb0_base = <0x10200000 16 0xffff0000>;
+			usb_sif_base = <0x10280000 17 0xffff0000>;
+			audio_base = <0x17000000 18 0xffff0000>;
+			vdec_base = <0x17010000 19 0xffff0000>;
+			msdc2_base = <0x17020000 20 0xffff0000>;
+			vdec1_base = <0x17030000 21 0xffff0000>;
+			msdc3_base = <0x18000000 22 0xffff0000>;
+			ap_dma_base = <0x18010000 23 0xffff0000>;
+			gce_base = <0x10320000 24 0xffff0000>;
+			vdec2_base = <0x18040000 25 0xffff0000>;
+			vdec3_base = <0x18050000 26 0xffff0000>;
+			camsys_base = <0x18080000 27 0xffff0000>;
+			camsys1_base = <0x180a0000 28 0xffff0000>;
+			camsys2_base = <0x180b0000 29 0xffff0000>;
+		};
+
+		mdp_fg0: mdp_fg0@14002000 {
+			compatible = "mediatek,mt8195-mdp-fg";
+			mediatek,mdp-id = <0>;
+			reg = <0 0x14002000 0 0x1000>;
+			mediatek,gce-client-reg = <&gce0 SUBSYS_1400XXXX 0x2000 0x1000>;
+			interrupts = <GIC_SPI 579 IRQ_TYPE_LEVEL_HIGH 0>;
+			clocks = <&vppsys0 CLK_VPP0_MDP_FG>;
+			clock-names = "MDP_FG0";
+			power-domains = <&spm MT8195_POWER_DOMAIN_VPPSYS0>;
+		};
+
+		mdp_stitch0: mdp_stich0@14003000 {
+			compatible = "mediatek,mt8195-mdp-stitch";
+			mediatek,mdp-id = <0>;
+			reg = <0 0x14003000 0 0x1000>;
+			mediatek,gce-client-reg = <&gce0 SUBSYS_1400XXXX 0x3000 0x1000>;
+			interrupts = <GIC_SPI 580 IRQ_TYPE_LEVEL_HIGH 0>;
+			clocks = <&vppsys0 CLK_VPP0_STITCH>;
+			clock-names = "MDP_STITCH";
+			power-domains = <&spm MT8195_POWER_DOMAIN_VPPSYS0>;
+		};
+
+		mdp_hdr0: mdp_hdr0@14004000 {
+			compatible = "mediatek,mt8195-mdp-hdr";
+			mediatek,mdp-id = <0>;
+			reg = <0 0x14004000 0 0x1000>;
+			mediatek,gce-client-reg = <&gce0 SUBSYS_1400XXXX 0x4000 0x1000>;
+			interrupts = <GIC_SPI 581 IRQ_TYPE_LEVEL_HIGH 0>;
+			clocks = <&vppsys0 CLK_VPP0_MDP_HDR>;
+			clock-names = "MDP_HDR0";
+			power-domains = <&spm MT8195_POWER_DOMAIN_VPPSYS0>;
+		};
+
+		mdp_aal0: mdp_aal0@14005000 {
+			compatible = "mediatek,mt8195-mdp-aal";
+			mediatek,mdp-id = <0>;
+			reg = <0 0x14005000 0 0x1000>;
+			mediatek,gce-client-reg = <&gce0 SUBSYS_1400XXXX 0x5000 0x1000>;
+			interrupts = <GIC_SPI 582 IRQ_TYPE_LEVEL_HIGH 0>;
+			clocks = <&vppsys0 CLK_VPP0_MDP_AAL>;
+			clock-names = "MDP_AAL0";
+			power-domains = <&spm MT8195_POWER_DOMAIN_VPPSYS0>;
+		};
+
+		mdp_rsz0: mdp_rsz0@14006000 {
+			compatible = "mediatek,mt8195-mdp-rsz";
+			mediatek,mdp-id = <0>;
+			reg = <0 0x14006000 0 0x1000>;
+			mediatek,gce-client-reg = <&gce0 SUBSYS_1400XXXX 0x6000 0x1000>;
+			interrupts = <GIC_SPI 583 IRQ_TYPE_LEVEL_HIGH 0>;
+			clocks = <&vppsys0 CLK_VPP0_MDP_RSZ>;
+			clock-names = "MDP_RSZ0";
+			power-domains = <&spm MT8195_POWER_DOMAIN_VPPSYS0>;
+		};
+
+		mdp_tdshp0: mdp_tdshp0@14007000 {
+			compatible = "mediatek,mt8195-mdp-tdshp";
+			mediatek,mdp-id = <0>;
+			reg = <0 0x14007000 0 0x1000>;
+			mediatek,gce-client-reg = <&gce0 SUBSYS_1400XXXX 0x7000 0x1000>;
+			interrupts = <GIC_SPI 584 IRQ_TYPE_LEVEL_HIGH 0>;
+			clocks = <&vppsys0 CLK_VPP0_MDP_TDSHP>;
+			clock-names = "MDP_TDSHP0";
+			power-domains = <&spm MT8195_POWER_DOMAIN_VPPSYS0>;
+		};
+
+		mdp_color0: mdp_color0@14008000 {
+			compatible = "mediatek,mt8195-mdp-color";
+			mediatek,mdp-id = <0>;
+			reg = <0 0x14008000 0 0x1000>;
+			mediatek,gce-client-reg = <&gce0 SUBSYS_1400XXXX 0x8000 0x1000>;
+			interrupts = <GIC_SPI 585 IRQ_TYPE_LEVEL_HIGH 0>;
+			clocks = <&vppsys0 CLK_VPP0_MDP_COLOR>;
+			clock-names = "MDP_COLOR0";
+			power-domains = <&spm MT8195_POWER_DOMAIN_VPPSYS0>;
+		};
+
+		mdp_ovl0: mdp_ovl0@14009000 {
+			compatible = "mediatek,mt8195-mdp-ovl";
+			mediatek,mdp-id = <0>;
+			reg = <0 0x14009000 0 0x1000>;
+			mediatek,gce-client-reg = <&gce0 SUBSYS_1400XXXX 0x9000 0x1000>;
+			interrupts = <GIC_SPI 586 IRQ_TYPE_LEVEL_HIGH 0>;
+			clocks = <&vppsys0 CLK_VPP0_MDP_OVL>;
+			clock-names = "MDP_OVL0";
+			power-domains = <&spm MT8195_POWER_DOMAIN_VPPSYS0>;
+		};
+
+		mdp_pad0: mdp_pad0@1400a000 {
+			compatible = "mediatek,mt8195-mdp-pad";
+			mediatek,mdp-id = <0>;
+			reg = <0 0x1400a000 0 0x1000>;
+			mediatek,gce-client-reg = <&gce0 SUBSYS_1400XXXX 0xa000 0x1000>;
+			interrupts = <GIC_SPI 588 IRQ_TYPE_LEVEL_HIGH 0>;
+			clocks = <&vppsys0 CLK_VPP0_PADDING>;
+			clock-names = "MDP_PAD0";
+			power-domains = <&spm MT8195_POWER_DOMAIN_VPPSYS0>;
+		};
+
+		mdp_tcc0: mdp_tcc0@1400b000 {
+			compatible = "mediatek,mt8195-mdp-tcc";
+			mediatek,mdp-id = <0>;
+			reg = <0 0x1400b000 0 0x1000>;
+			mediatek,gce-client-reg = <&gce0 SUBSYS_1400XXXX 0xb000 0x1000>;
+			interrupts = <GIC_SPI 589 IRQ_TYPE_LEVEL_HIGH 0>;
+			clocks = <&vppsys0 CLK_VPP0_MDP_TCC>;
+			clock-names = "MDP_TCC0";
+			power-domains = <&spm MT8195_POWER_DOMAIN_VPPSYS0>;
+		};
+
+		mdp_wrot0: mdp_wrot0@1400c000 {
+			compatible = "mediatek,mt8195-mdp-wrot";
+			mediatek,mdp-id = <0>;
+			reg = <0 0x1400c000 0 0x1000>;
+			mediatek,gce-client-reg = <&gce0 SUBSYS_1400XXXX 0xc000 0x1000>;
+			interrupts = <GIC_SPI 590 IRQ_TYPE_LEVEL_HIGH 0>;
+			clocks = <&vppsys0 CLK_VPP0_MDP_WROT>;
+			clock-names = "MDP_WROT0";
+			iommus = <&iommu_vpp M4U_PORT_L4_MDP_WROT>;
+			power-domains = <&spm MT8195_POWER_DOMAIN_VPPSYS0>;
+		};
+
+		mmsram: mmsram@1400d000 {
+			compatible = "mediatek,mmsram";
+			reg = <0 0x1400d000 0 0x1000>,
+				  <0 0x1e000000 0 0x260000>;
+			mediatek,gce-client-reg = <&gce0 SUBSYS_1400XXXX 0xd000 0x1000>;
+			interrupts = <GIC_SPI 591 IRQ_TYPE_LEVEL_HIGH 0>;
+			clocks = <&vppsys0 CLK_VPP0_MMSYSRAM_TOP>;
+			clock-names = "MMSYSRAM_TOP";
+			power-domains = <&spm MT8195_POWER_DOMAIN_VPPSYS0>;
+		};
+		
+		smi_sub_common_vpp0_vpp1_2x1: smi@14010000 {
+			compatible = "mediatek,mt8195-smi-sub-common";
+			reg = <0 0x14010000 0 0x1000>;
+			clocks = <&vppsys0 CLK_VPP0_GALS_VPP1_WPE>,
+			       <&vppsys0 CLK_VPP0_GALS_VPP1_WPE>,
+			       <&vppsys0 CLK_VPP0_GALS_VPP1_WPE>;
+			clock-names = "apb", "smi", "gals0";
+			mediatek,smi = <&smi_common_vpp>;
+			mediatek,smi_sub_common;
+			power-domains = <&spm MT8195_POWER_DOMAIN_VPPSYS0>;
+		};
+
+		smi_sub_common_vdec_vpp0_2x1: smi@14011000 {
+			compatible = "mediatek,mt8195-smi-sub-common";
+			reg = <0 0x14011000 0 0x1000>;
+			clocks = <&vppsys0 CLK_VPP0_GALS_VDEC_VDEC_CORE1>,
+			         <&vppsys0 CLK_VPP0_GALS_VDEC_VDEC_CORE1>,
+			         <&vppsys0 CLK_VPP0_GALS_VDEC_VDEC_CORE1>;
+			clock-names = "apb", "smi", "gals0";
+			mediatek,smi = <&smi_common_vpp>;
+			mediatek,smi_sub_common;
+			power-domains = <&spm MT8195_POWER_DOMAIN_VPPSYS0>;
+		};
+
+		smi_common_vpp: smi@14012000 {
+			compatible = "mediatek,mt8195-smi-common-vpp";
+			mediatek,common-id = <1>;
+			reg = <0 0x14012000 0 0x1000>;
+			mediatek,gce-client-reg = <&gce0 SUBSYS_1401XXXX 0x2000 0x1000>;
+			clocks = <&vppsys0 CLK_VPP0_SMI_COMMON_LARB4>,
+			       <&vppsys0 CLK_VPP0_SMI_COMMON_LARB4>,
+			       <&vppsys0 CLK_VPP0_SMI_RSI>,
+			       <&vppsys0 CLK_VPP0_SMI_RSI>;
+			clock-names = "apb", "smi", "gals0", "gals1";
+			power-domains = <&spm MT8195_POWER_DOMAIN_VPPSYS0>;
+		};
+
+		larb4: larb@14013000 {
+			compatible = "mediatek,mt8195-smi-larb";
+			reg = <0 0x14013000 0 0x1000>;
+			mediatek,gce-client-reg = <&gce0 SUBSYS_1401XXXX 0x3000 0x1000>;
+			mediatek,larb-id = <4>;
+			mediatek,smi = <&smi_sub_common_vpp0_vpp1_2x1>;
+			clocks = <&vppsys0 CLK_VPP0_GALS_VPP1_WPE>,
+			       <&vppsys0 CLK_VPP0_SMI_COMMON_LARB4>;
+			clock-names = "apb", "smi";
+			power-domains = <&spm MT8195_POWER_DOMAIN_VPPSYS0>;
+		};
+
+		iommu_vpp: iommu@14018000 {
+			compatible = "mediatek,mt8195-iommu-vpp";
+			reg = <0 0x14018000 0 0x1000>;
+			mediatek,gce-client-reg = <&gce0 SUBSYS_1401XXXX 0x8000 0x1000>;
+			mediatek,larbs = <&larb1 &larb3 &larb4 &larb6 &larb8
+					  &larb12 &larb14 &larb16 &larb18
+					  &larb20 &larb22 &larb23 &larb26
+					  &larb27>;
+			interrupts = <GIC_SPI 594 IRQ_TYPE_LEVEL_HIGH 0>;
+			clocks = <&vppsys0 CLK_VPP0_SMI_IOMMU>;
+			clock-names = "bclk";
+			#iommu-cells = <1>;
+			power-domains = <&spm MT8195_POWER_DOMAIN_VPPSYS0>;
+		};
+
+		wpesys: syscon@14e00000 {
+			compatible = "mediatek,mt8195-wpesys", "syscon";
+			reg = <0 0x14e00000 0 0x1000>;
+			#clock-cells = <1>;
+		};
+
+		wpesys_vpp0: syscon@14e02000 {
+			compatible = "mediatek,mt8195-wpesys_vpp0", "syscon";
+			reg = <0 0x14e02000 0 0x1000>;
+			#clock-cells = <1>;
+		};
+
+		wpesys_vpp1: syscon@14e03000 {
+			compatible = "mediatek,mt8195-wpesys_vpp1", "syscon";
+			reg = <0 0x14e03000 0 0x1000>;
+			#clock-cells = <1>;
+		};
+
+		larb7: larb@14e04000 {
+			compatible = "mediatek,mt8195-smi-larb";
+			reg = <0 0x14e04000 0 0x1000>;
+			mediatek,larb-id = <7>;
+			mediatek,smi = <&smi_common_vdo>;
+			clocks = <&wpesys CLK_WPE_SMI_LARB7>,
+				 <&wpesys CLK_WPE_SMI_LARB7>;
+			clock-names = "apb", "smi";
+			power-domains = <&spm MT8195_POWER_DOMAIN_WPESYS>;
+		};
+
+		larb8: larb@14e05000 {
+			compatible = "mediatek,mt8195-smi-larb";
+			reg = <0 0x14e05000 0 0x1000>;
+			mediatek,larb-id = <8>;
+			mediatek,smi = <&smi_common_vpp>;
+			clocks = <&wpesys CLK_WPE_SMI_LARB8>,
+			       <&wpesys CLK_WPE_SMI_LARB8>,
+			       <&vppsys0 CLK_VPP0_GALS_VPP1_WPE>;
+			clock-names = "apb", "smi", "gals";
+			power-domains = <&spm MT8195_POWER_DOMAIN_WPESYS>;
+		};
+
+		vppsys1: syscon@14f00000 {
+			compatible = "mediatek,mt8195-vppsys1", "syscon";
+			reg = <0 0x14f00000 0 0x1000>;
+			mediatek,gce-client-reg = <&gce0 SUBSYS_14f0XXXX 0 0x1000>;
+			#clock-cells = <1>;
+		};
+
+		vpp1_mutex: vpp1_mutex@14f01000 {
+			compatible = "mediatek,vpp1_mutex";
+			reg = <0 0x14f01000 0 0x1000>;
+			mediatek,gce-client-reg = <&gce0 SUBSYS_14f0XXXX 0x1000 0x1000>;
+			interrupts = <GIC_SPI 635 IRQ_TYPE_LEVEL_HIGH 0>;
+			#clocks = <&vppsys1 CLK_VPP1_DISP_MUTEX>;
+			#clock-names = "DISP_MUTEX";
+			clocks = <&vppsys1 CLK_VPP1_DISP_MUTEX>,
+				 /*<&vppsys1 CLK_VPP1_SVPP2_VDO0_DL_RELAY>,
+				 <&vppsys1 CLK_VPP1_SVPP3_VDO1_DL_RELAY>,*/
+				 <&vppsys1 CLK_VPP1_VPPSYS1_GALS>,
+				 <&vppsys1 CLK_VPP1_VPPSYS1_LARB>,
+				 /*<&vppsys1 CLK_VPP1_DL_ASYNC>,
+				 <&vppsys1 CLK_VPP1_SVPP2_VDO1_DL_RELAY>,
+				 <&vppsys1 CLK_VPP1_SVPP3_VDO0_DL_RELAY>,
+				 <&vppsys1 CLK_VPP1_VPP0_DL1_RELAY>,
+				 <&vppsys1 CLK_VPP1_HDMI_META>,
+				 <&vppsys1 CLK_VPP1_VPP_SPLIT_HDMI>,
+				 <&vppsys1 CLK_VPP1_DGI_IN>,
+				 <&vppsys1 CLK_VPP1_DGI_OUT>,
+				 <&vppsys1 CLK_VPP1_VPP_SPLIT_DGI>,
+				 <&vppsys1 CLK_VPP1_VPP0_DL_ASYNC>,
+				 <&vppsys1 CLK_VPP1_VPP0_DL_RELAY>,*/
+				 <&vppsys1 CLK_VPP1_VPP_SPLIT_26M>,
+				 <&topckgen CLK_TOP_CFG_VPP1>,
+				 <&topckgen CLK_TOP_CFG_26M_VPP1>;
+			clock-names = "DISP_MUTEX",
+					 /*"SVPP2_VDO0_DL_RELAY",
+					 "SVPP3_VDO1_DL_RELAY",*/
+					 "VPPSYS1_GALS",
+					 "VPPSYS1_LARB",
+					 /*"VPP0_DL_ASYNC_VPP1",
+					 "SVPP2_VDO1_DL_RELAY",
+					 "SVPP3_VDO0_DL_RELAY",
+					 "VPP0_DL1_RELAY",
+					 "HDMI_META",
+					 "SPLIT_HDMI",
+					 "DGI_IN",
+					 "DGI_OUT",
+					 "SPLIT_DGI",
+					 "VPP0_DL_ASYNC_VPP0",
+					 "VPP0_DL_RELAY",*/
+					 "VPP_SPLIT_26M",
+					 "TOP_CFG_VPP1",
+					 "TOP_CFG_26M_VPP1";
+			power-domains = <&spm MT8195_POWER_DOMAIN_VPPSYS1>;
+		};
+
+		larb5: larb@14f02000 {
+			compatible = "mediatek,mt8195-smi-larb";
+			reg = <0 0x14f02000 0 0x1000>;
+			mediatek,gce-client-reg = <&gce0 SUBSYS_14f0XXXX 0x2000 0x1000>;
+			mediatek,larb-id = <5>;
+			mediatek,smi = <&smi_common_vdo>;
+			clocks = <&vppsys1 CLK_VPP1_VPPSYS1_LARB>,
+			       <&vppsys1 CLK_VPP1_VPPSYS1_GALS>,
+			       <&vppsys0 CLK_VPP0_GALS_VPP1_LARB5>;
+			clock-names = "apb", "smi", "gals";
+			power-domains = <&spm MT8195_POWER_DOMAIN_VPPSYS1>;
+		};
+
+		larb6: larb@14f03000 {
+			compatible = "mediatek,mt8195-smi-larb";
+			reg = <0 0x14f03000 0 0x1000>;
+			mediatek,gce-client-reg = <&gce0 SUBSYS_14f0XXXX 0x3000 0x1000>;
+			mediatek,larb-id = <6>;
+			mediatek,smi = <&smi_sub_common_vpp0_vpp1_2x1>;
+			clocks = <&vppsys0 CLK_VPP0_GALS_VPP1_WPE>,
+			       <&vppsys1 CLK_VPP1_VPPSYS1_LARB>,
+			       <&vppsys1 CLK_VPP1_VPPSYS1_GALS>,
+			       <&vppsys0 CLK_VPP0_GALS_VPP1_LARB6>;
+			clock-names = "apb", "smi", "gals", "gals1";
+			power-domains = <&spm MT8195_POWER_DOMAIN_VPPSYS1>;
+		};
+
+		imgsys: syscon@15000000 {
+			compatible = "mediatek,mt8195-imgsys", "syscon";
+			reg = <0 0x15000000 0 0x1000>;
+			#clock-cells = <1>;
+		};
+
+		vpp_split0: vpp_split0@14f06000 {
+			compatible = "mediatek,mt8195-mdp-split";
+			mediatek,mdp-id = <1>;
+			reg = <0 0x14f06000 0 0x1000>;
+			mediatek,gce-client-reg = <&gce0 SUBSYS_14f0XXXX 0x6000 0x1000>;
+			interrupts = <GIC_SPI 605 IRQ_TYPE_LEVEL_HIGH 0>,
+				<GIC_SPI 606 IRQ_TYPE_LEVEL_HIGH 0>;
+			clocks = <&vppsys1 CLK_VPP1_VPP_SPLIT>;
+			clock-names = "MDP_SPLIT";
+			power-domains = <&spm MT8195_POWER_DOMAIN_VPPSYS1>;
+		};
+
+		svpp1_mdp_tcc: svpp1_mdp_tcc@14f07000 {
+			compatible = "mediatek,mt8195-mdp-tcc";
+			mediatek,mdp-id = <1>;
+			reg = <0 0x14f07000 0 0x1000>;
+			mediatek,gce-client-reg = <&gce0 SUBSYS_14f0XXXX 0x7000 0x1000>;
+			interrupts = <GIC_SPI 607 IRQ_TYPE_LEVEL_HIGH 0>;
+			clocks = <&vppsys1 CLK_VPP1_SVPP1_MDP_TCC>;
+			clock-names = "MDP_TCC1";
+			power-domains = <&spm MT8195_POWER_DOMAIN_VPPSYS1>;
+		};
+
+		svpp1_mdp_rdma: svpp1_mdp_rdma@14f08000 {
+			compatible = "mediatek,mt8195-mdp-rdma", "mediatek,mt8195-mdp3";
+			mediatek,mdp-id = <1>;
+			reg = <0 0x14f08000 0 0x1000>;
+			mediatek,gce-client-reg = <&gce0 SUBSYS_14f0XXXX 0x8000 0x1000>;
+			interrupts = <GIC_SPI 608 IRQ_TYPE_LEVEL_HIGH 0>;
+			clocks = <&vppsys1 CLK_VPP1_SVPP1_MDP_RDMA>;
+			clock-names = "MDP_RDMA1";
+			iommus = <&iommu_vdo M4U_PORT_L5_SVPP1_MDP_RDMA>,
+				 <&iommu_vdo M4U_PORT_L5_SVPP2_MDP_RDMA>,
+				 <&iommu_vdo M4U_PORT_L5_SVPP1_MDP_WROT>,
+				 <&iommu_vdo M4U_PORT_L5_SVPP2_MDP_WROT>;
+			power-domains = <&spm MT8195_POWER_DOMAIN_VPPSYS1>;
+		};
+
+		svpp2_mdp_rdma: svpp2_mdp_rdma@14f09000 {
+			compatible = "mediatek,mt8195-mdp-rdma";
+			mediatek,mdp-id = <2>;
+			reg = <0 0x14f09000 0 0x1000>;
+			mediatek,gce-client-reg = <&gce0 SUBSYS_14f0XXXX 0x9000 0x1000>;
+			interrupts = <GIC_SPI 609 IRQ_TYPE_LEVEL_HIGH 0>;
+			clocks = <&vppsys1 CLK_VPP1_SVPP2_MDP_RDMA>;
+			clock-names = "MDP_RDMA2";
+			iommus = <&iommu_vdo M4U_PORT_L5_SVPP2_MDP_RDMA>;
+			power-domains = <&spm MT8195_POWER_DOMAIN_VPPSYS1>;
+		};
+
+		svpp3_mdp_rdma: svpp3_mdp_rdma@14f0a000 {
+			compatible = "mediatek,mt8195-mdp-rdma";
+			mediatek,mdp-id = <3>;
+			reg = <0 0x14f0a000 0 0x1000>;
+			mediatek,gce-client-reg = <&gce0 SUBSYS_14f0XXXX 0xa000 0x1000>;
+			interrupts = <GIC_SPI 610 IRQ_TYPE_LEVEL_HIGH 0>;
+			clocks = <&vppsys1 CLK_VPP1_SVPP3_MDP_RDMA>;
+			clock-names = "MDP_RDMA3";
+			iommus = <&iommu_vpp M4U_PORT_L6_SVPP3_MDP_RDMA>;
+			power-domains = <&spm MT8195_POWER_DOMAIN_VPPSYS1>;
+		};
+
+		svpp1_mdp_fg: svpp1_mdp_fg@14f0b000 {
+			compatible = "mediatek,mt8195-mdp-fg";
+			mediatek,mdp-id = <1>;
+			reg = <0 0x14f0b000 0 0x1000>;
+			mediatek,gce-client-reg = <&gce0 SUBSYS_14f0XXXX 0xb000 0x1000>;
+			interrupts = <GIC_SPI 611 IRQ_TYPE_LEVEL_HIGH 0>;
+			clocks = <&vppsys1 CLK_VPP1_SVPP1_MDP_FG>;
+			clock-names = "MDP_FG1";
+			power-domains = <&spm MT8195_POWER_DOMAIN_VPPSYS1>;
+		};
+
+		svpp2_mdp_fg: svpp2_mdp_fg@14f0c000 {
+			compatible = "mediatek,mt8195-mdp-fg";
+			mediatek,mdp-id = <2>;
+			reg = <0 0x14f0c000 0 0x1000>;
+			mediatek,gce-client-reg = <&gce0 SUBSYS_14f0XXXX 0xc000 0x1000>;
+			interrupts = <GIC_SPI 612 IRQ_TYPE_LEVEL_HIGH 0>;
+			clocks = <&vppsys1 CLK_VPP1_SVPP2_MDP_FG>;
+			clock-names = "MDP_FG2";
+			power-domains = <&spm MT8195_POWER_DOMAIN_VPPSYS1>;
+		};
+
+		svpp3_mdp_fg: svpp3_mdp_fg@14f0c000 {
+			compatible = "mediatek,mt8195-mdp-fg";
+			mediatek,mdp-id = <3>;
+			reg = <0 0x14f0d000 0 0x1000>;
+			mediatek,gce-client-reg = <&gce0 SUBSYS_14f0XXXX 0xd000 0x1000>;
+			interrupts = <GIC_SPI 613 IRQ_TYPE_LEVEL_HIGH 0>;
+			clocks = <&vppsys1 CLK_VPP1_SVPP3_MDP_FG>;
+			clock-names = "MDP_FG3";
+			power-domains = <&spm MT8195_POWER_DOMAIN_VPPSYS1>;
+		};
+
+		svpp1_mdp_hdr: svpp1_mdp_hdr@14f0e000 {
+			compatible = "mediatek,mt8195-mdp-hdr";
+			mediatek,mdp-id = <1>;
+			reg = <0 0x14f0e000 0 0x1000>;
+			mediatek,gce-client-reg = <&gce0 SUBSYS_14f0XXXX 0xe000 0x1000>;
+			interrupts = <GIC_SPI 614 IRQ_TYPE_LEVEL_HIGH 0>;
+			clocks = <&vppsys1 CLK_VPP1_SVPP1_MDP_HDR>;
+			clock-names = "MDP_HDR1";
+			power-domains = <&spm MT8195_POWER_DOMAIN_VPPSYS1>;
+		};
+
+		svpp2_mdp_hdr: svpp2_mdp_hdr@14f0f000 {
+			compatible = "mediatek,mt8195-mdp-hdr";
+			mediatek,mdp-id = <2>;
+			reg = <0 0x14f0f000 0 0x1000>;
+			mediatek,gce-client-reg = <&gce0 SUBSYS_14f0XXXX 0xf000 0x1000>;
+			interrupts = <GIC_SPI 615 IRQ_TYPE_LEVEL_HIGH 0>;
+			clocks = <&vppsys1 CLK_VPP1_SVPP2_MDP_HDR>;
+			clock-names = "MDP_HDR2";
+			power-domains = <&spm MT8195_POWER_DOMAIN_VPPSYS1>;
+		};
+
+		svpp3_mdp_hdr: svpp3_mdp_hdr@14f10000 {
+			compatible = "mediatek,mt8195-mdp-hdr";
+			mediatek,mdp-id = <3>;
+			reg = <0 0x14f10000 0 0x1000>;
+			mediatek,gce-client-reg = <&gce0 SUBSYS_14f1XXXX 0 0x1000>;
+			interrupts = <GIC_SPI 616 IRQ_TYPE_LEVEL_HIGH 0>;
+			clocks = <&vppsys1 CLK_VPP1_SVPP3_MDP_HDR>;
+			clock-names = "MDP_HDR3";
+			power-domains = <&spm MT8195_POWER_DOMAIN_VPPSYS1>;
+		};
+
+		svpp1_mdp_aal: svpp1_mdp_aal@14f11000 {
+			compatible = "mediatek,mt8195-mdp-aal";
+			mediatek,mdp-id = <1>;
+			reg = <0 0x14f11000 0 0x1000>;
+			mediatek,gce-client-reg = <&gce0 SUBSYS_14f1XXXX 0x1000 0x1000>;
+			interrupts = <GIC_SPI 617 IRQ_TYPE_LEVEL_HIGH 0>;
+			clocks = <&vppsys1 CLK_VPP1_SVPP1_MDP_AAL>;
+			clock-names = "MDP_AAL1";
+			power-domains = <&spm MT8195_POWER_DOMAIN_VPPSYS1>;
+		};
+
+		svpp2_mdp_aal: svpp2_mdp_aal@14f12000 {
+			compatible = "mediatek,mt8195-mdp-aal";
+			mediatek,mdp-id = <2>;
+			reg = <0 0x14f12000 0 0x1000>;
+			mediatek,gce-client-reg = <&gce0 SUBSYS_14f1XXXX 0x2000 0x1000>;
+			interrupts = <GIC_SPI 618 IRQ_TYPE_LEVEL_HIGH 0>;
+			clocks = <&vppsys1 CLK_VPP1_SVPP2_MDP_AAL>;
+			clock-names = "MDP_AAL2";
+			power-domains = <&spm MT8195_POWER_DOMAIN_VPPSYS1>;
+		};
+
+		svpp3_mdp_aal: svpp3_mdp_aal@14f13000 {
+			compatible = "mediatek,mt8195-mdp-aal";
+			mediatek,mdp-id = <3>;
+			reg = <0 0x14f13000 0 0x1000>;
+			mediatek,gce-client-reg = <&gce0 SUBSYS_14f1XXXX 0x3000 0x1000>;
+			interrupts = <GIC_SPI 619 IRQ_TYPE_LEVEL_HIGH 0>;
+			clocks = <&vppsys1 CLK_VPP1_SVPP3_MDP_AAL>;
+			clock-names = "MDP_AAL3";
+			power-domains = <&spm MT8195_POWER_DOMAIN_VPPSYS1>;
+		};
+
+		svpp1_mdp_rsz: svpp1_mdp_rsz@14f14000 {
+			compatible = "mediatek,mt8195-mdp-rsz";
+			mediatek,mdp-id = <1>;
+			reg = <0 0x14f14000 0 0x1000>;
+			mediatek,gce-client-reg = <&gce0 SUBSYS_14f1XXXX 0x4000 0x1000>;
+			interrupts = <GIC_SPI 620 IRQ_TYPE_LEVEL_HIGH 0>;
+			clocks = <&vppsys1 CLK_VPP1_SVPP1_MDP_RSZ>;
+			clock-names = "MDP_RSZ1";
+			power-domains = <&spm MT8195_POWER_DOMAIN_VPPSYS1>;
+		};
+
+		svpp2_mdp_rsz: svpp2_mdp_rsz@14f15000 {
+			compatible = "mediatek,mt8195-mdp-rsz";
+			mediatek,mdp-id = <2>;
+			reg = <0 0x14f15000 0 0x1000>;
+			mediatek,gce-client-reg = <&gce0 SUBSYS_14f1XXXX 0x5000 0x1000>;
+			interrupts = <GIC_SPI 621 IRQ_TYPE_LEVEL_HIGH 0>;
+			clocks = <&vppsys1 CLK_VPP1_SVPP2_MDP_RSZ>,
+					<&vppsys1 CLK_VPP1_SVPP2_VPP_MERGE>;
+			clock-names = "MDP_RSZ2";
+			power-domains = <&spm MT8195_POWER_DOMAIN_VPPSYS1>;
+		};
+
+		svpp3_mdp_rsz: svpp3_mdp_rsz@14f16000 {
+			compatible = "mediatek,mt8195-mdp-rsz";
+			mediatek,mdp-id = <3>;
+			reg = <0 0x14f16000 0 0x1000>;
+			mediatek,gce-client-reg = <&gce0 SUBSYS_14f1XXXX 0x6000 0x1000>;
+			interrupts = <GIC_SPI 622 IRQ_TYPE_LEVEL_HIGH 0>;
+			clocks = <&vppsys1 CLK_VPP1_SVPP3_MDP_RSZ>,
+					<&vppsys1 CLK_VPP1_SVPP3_VPP_MERGE>;
+			clock-names = "MDP_RSZ3";
+			power-domains = <&spm MT8195_POWER_DOMAIN_VPPSYS1>;
+		};
+
+		svpp1_mdp_tdshp: svpp1_mdp_tdshp@14f17000 {
+			compatible = "mediatek,mt8195-mdp-tdshp";
+			mediatek,mdp-id = <1>;
+			reg = <0 0x14f17000 0 0x1000>;
+			mediatek,gce-client-reg = <&gce0 SUBSYS_14f1XXXX 0x7000 0x1000>;
+			interrupts = <GIC_SPI 623 IRQ_TYPE_LEVEL_HIGH 0>;
+			clocks = <&vppsys1 CLK_VPP1_SVPP1_MDP_TDSHP>;
+			clock-names = "MDP_TDSHP1";
+			power-domains = <&spm MT8195_POWER_DOMAIN_VPPSYS1>;
+		};
+
+		svpp2_mdp_tdshp: svpp2_mdp_tdshp@14f18000 {
+			compatible = "mediatek,mt8195-mdp-tdshp";
+			mediatek,mdp-id = <2>;
+			reg = <0 0x14f18000 0 0x1000>;
+			mediatek,gce-client-reg = <&gce0 SUBSYS_14f1XXXX 0x8000 0x1000>;
+			interrupts = <GIC_SPI 624 IRQ_TYPE_LEVEL_HIGH 0>;
+			clocks = <&vppsys1 CLK_VPP1_SVPP2_MDP_TDSHP>;
+			clock-names = "MDP_TDSHP2";
+			power-domains = <&spm MT8195_POWER_DOMAIN_VPPSYS1>;
+		};
+
+		svpp3_mdp_tdshp: svpp3_mdp_tdshp@14f19000 {
+			compatible = "mediatek,mt8195-mdp-tdshp";
+			mediatek,mdp-id = <3>;
+			reg = <0 0x14f19000 0 0x1000>;
+			mediatek,gce-client-reg = <&gce0 SUBSYS_14f1XXXX 0x9000 0x1000>;
+			interrupts = <GIC_SPI 625 IRQ_TYPE_LEVEL_HIGH 0>;
+			clocks = <&vppsys1 CLK_VPP1_SVPP3_MDP_TDSHP>;
+			clock-names = "MDP_TDSHP3";
+			power-domains = <&spm MT8195_POWER_DOMAIN_VPPSYS1>;
+		};
+
+		svpp2_mdp_merge: svpp2_mdp_merge@14f1a000 {
+			compatible = "mediatek,mt8195-mdp-merge";
+			mediatek,mdp-id = <2>;
+			reg = <0 0x14f1a000 0 0x1000>;
+			mediatek,gce-client-reg = <&gce0 SUBSYS_14f1XXXX 0xa000 0x1000>;
+			interrupts = <GIC_SPI 626 IRQ_TYPE_LEVEL_HIGH 0>;
+			clocks = <&vppsys1 CLK_VPP1_SVPP2_VPP_MERGE>;
+			clock-names = "MDP_MERGE2";
+			power-domains = <&spm MT8195_POWER_DOMAIN_VPPSYS1>;
+		};
+
+		svpp3_mdp_merge: svpp3_mdp_merge@14f1b000 {
+			compatible = "mediatek,mt8195-mdp-merge";
+			mediatek,mdp-id = <3>;
+			reg = <0 0x14f1b000 0 0x1000>;
+			mediatek,gce-client-reg = <&gce0 SUBSYS_14f1XXXX 0xb000 0x1000>;
+			interrupts = <GIC_SPI 627 IRQ_TYPE_LEVEL_HIGH 0>;
+			clocks = <&vppsys1 CLK_VPP1_SVPP3_VPP_MERGE>;
+			clock-names = "MDP_MERGE3";
+			power-domains = <&spm MT8195_POWER_DOMAIN_VPPSYS1>;
+		};
+
+		svpp1_mdp_color: svpp1_mdp_color@14f1c000 {
+			compatible = "mediatek,mt8195-mdp-color";
+			mediatek,mdp-id = <1>;
+			reg = <0 0x14f1c000 0 0x1000>;
+			mediatek,gce-client-reg = <&gce0 SUBSYS_14f1XXXX 0xc000 0x1000>;
+			interrupts = <GIC_SPI 628 IRQ_TYPE_LEVEL_HIGH 0>;
+			clocks = <&vppsys1 CLK_VPP1_SVPP1_MDP_COLOR>;
+			clock-names = "MDP_COLOR1";
+			power-domains = <&spm MT8195_POWER_DOMAIN_VPPSYS1>;
+		};
+
+		svpp2_mdp_color: svpp2_mdp_color@14f1d000 {
+			compatible = "mediatek,mt8195-mdp-color";
+			mediatek,mdp-id = <2>;
+			reg = <0 0x14f1d000 0 0x1000>;
+			mediatek,gce-client-reg = <&gce0 SUBSYS_14f1XXXX 0xd000 0x1000>;
+			interrupts = <GIC_SPI 629 IRQ_TYPE_LEVEL_HIGH 0>;
+			clocks = <&vppsys1 CLK_VPP1_SVPP2_MDP_COLOR>;
+			clock-names = "MDP_COLOR2";
+			power-domains = <&spm MT8195_POWER_DOMAIN_VPPSYS1>;
+		};
+
+		svpp3_mdp_color: svpp3_mdp_color@14f1e000 {
+			compatible = "mediatek,mt8195-mdp-color";
+			mediatek,mdp-id = <3>;
+			reg = <0 0x14f1e000 0 0x1000>;
+			mediatek,gce-client-reg = <&gce0 SUBSYS_14f1XXXX 0xe000 0x1000>;
+			interrupts = <GIC_SPI 630 IRQ_TYPE_LEVEL_HIGH 0>;
+			clocks = <&vppsys1 CLK_VPP1_SVPP3_MDP_COLOR>;
+			clock-names = "MDP_COLOR3";
+			power-domains = <&spm MT8195_POWER_DOMAIN_VPPSYS1>;
+		};
+
+		svpp1_mdp_ovl: svpp1_mdp_ovl@14f1f000 {
+			compatible = "mediatek,mt8195-mdp-ovl";
+			mediatek,mdp-id = <1>;
+			reg = <0 0x14f1f000 0 0x1000>;
+			mediatek,gce-client-reg = <&gce0 SUBSYS_14f1XXXX 0xf000 0x1000>;
+			interrupts = <GIC_SPI 631 IRQ_TYPE_LEVEL_HIGH 0>;
+			clocks = <&vppsys1 CLK_VPP1_SVPP1_MDP_OVL>;
+			clock-names = "MDP_OVL1";
+			power-domains = <&spm MT8195_POWER_DOMAIN_VPPSYS1>;
+		};
+
+		svpp1_mdp_pad: svpp1_mdp_pad@14f20000 {
+			compatible = "mediatek,mt8195-mdp-pad";
+			mediatek,mdp-id = <1>;
+			reg = <0 0x14f20000 0 0x1000>;
+			mediatek,gce-client-reg = <&gce0 SUBSYS_14f2XXXX 0 0x1000>;
+			interrupts = <GIC_SPI 632 IRQ_TYPE_LEVEL_HIGH 0>;
+			clocks = <&vppsys1 CLK_VPP1_SVPP1_VPP_PAD>;
+			clock-names = "MDP_PAD1";
+			power-domains = <&spm MT8195_POWER_DOMAIN_VPPSYS1>;
+		};
+
+		svpp2_mdp_pad: svpp2_mdp_pad@14f21000 {
+			compatible = "mediatek,mt8195-mdp-pad";
+			mediatek,mdp-id = <2>;
+			reg = <0 0x14f21000 0 0x1000>;
+			mediatek,gce-client-reg = <&gce0 SUBSYS_14f2XXXX 0x1000 0x1000>;
+			interrupts = <GIC_SPI 633 IRQ_TYPE_LEVEL_HIGH 0>;
+			clocks = <&vppsys1 CLK_VPP1_SVPP2_VPP_PAD>;
+			clock-names = "MDP_PAD2";
+			power-domains = <&spm MT8195_POWER_DOMAIN_VPPSYS1>;
+		};
+
+		svpp3_mdp_pad: svpp3_mdp_pad@14f22000 {
+			compatible = "mediatek,mt8195-mdp-pad";
+			mediatek,mdp-id = <3>;
+			reg = <0 0x14f22000 0 0x1000>;
+			mediatek,gce-client-reg = <&gce0 SUBSYS_14f2XXXX 0x2000 0x1000>;
+			interrupts = <GIC_SPI 634 IRQ_TYPE_LEVEL_HIGH 0>;
+			clocks = <&vppsys1 CLK_VPP1_SVPP3_VPP_PAD>;
+			clock-names = "MDP_PAD3";
+			power-domains = <&spm MT8195_POWER_DOMAIN_VPPSYS1>;
+		};
+
+		svpp1_mdp_wrot: svpp1_mdp_wrot@14f23000 {
+			compatible = "mediatek,mt8195-mdp-wrot";
+			mediatek,mdp-id = <1>;
+			reg = <0 0x14f23000 0 0x1000>;
+			mediatek,gce-client-reg = <&gce0 SUBSYS_14f2XXXX 0x3000 0x1000>;
+			interrupts = <GIC_SPI 635 IRQ_TYPE_LEVEL_HIGH 0>;
+			/* iommus = <&iommu_vdo M4U_PORT_L5_SVPP1_MDP_WROT>; */
+			clocks = <&vppsys1 CLK_VPP1_SVPP1_MDP_WROT>;
+			clock-names = "MDP_WROT1";
+			iommus = <&iommu_vdo M4U_PORT_L5_SVPP1_MDP_WROT>;
+			power-domains = <&spm MT8195_POWER_DOMAIN_VPPSYS1>;
+		};
+
+		svpp2_mdp_wrot: svpp2_mdp_wrot@14f24000 {
+			compatible = "mediatek,mt8195-mdp-wrot";
+			mediatek,mdp-id = <2>;
+			reg = <0 0x14f24000 0 0x1000>;
+			mediatek,gce-client-reg = <&gce0 SUBSYS_14f2XXXX 0x4000 0x1000>;
+			interrupts = <GIC_SPI 636 IRQ_TYPE_LEVEL_HIGH 0>;
+			/* iommus = <&iommu_vdo M4U_PORT_L5_SVPP2_MDP_WROT>; */
+			clocks = <&vppsys1 CLK_VPP1_SVPP2_MDP_WROT>;
+			clock-names = "MDP_WROT2";
+			iommus = <&iommu_vdo M4U_PORT_L5_SVPP2_MDP_WROT>;
+			power-domains = <&spm MT8195_POWER_DOMAIN_VPPSYS1>;
+		};
+
+		svpp3_mdp_wrot: svpp3_mdp_wrot@14f25000 {
+			compatible = "mediatek,mt8195-mdp-wrot";
+			mediatek,mdp-id = <3>;
+			reg = <0 0x14f25000 0 0x1000>;
+			mediatek,gce-client-reg = <&gce0 SUBSYS_14f2XXXX 0x5000 0x1000>;
+			interrupts = <GIC_SPI 637 IRQ_TYPE_LEVEL_HIGH 0>;
+			/* iommus = <&iommu_vpp M4U_PORT_L6_SVPP3_MDP_WROT>; */
+			clocks = <&vppsys1 CLK_VPP1_SVPP3_MDP_WROT>;
+			clock-names = "MDP_WROT3";
+			iommus = <&iommu_vpp M4U_PORT_L6_SVPP3_MDP_WROT>;
+			power-domains = <&spm MT8195_POWER_DOMAIN_VPPSYS1>;
+		};
+
+		larb9: larb@15001000 {
+			compatible = "mediatek,mt8195-smi-larb";
+			reg = <0 0x15001000 0 0x1000>;
+			mediatek,larb-id = <9>;
+			mediatek,smi = <&smi_sub_common_img1_3x1>;
+			clocks = <&imgsys CLK_IMG_LARB9>,
+			         <&imgsys CLK_IMG_LARB9>,
+			         <&imgsys CLK_IMG_GALS>;
+			clock-names = "apb", "smi", "gals";
+			power-domains = <&spm MT8195_POWER_DOMAIN_IMG>;
+		};
+
+		smi_sub_common_img0_3x1: smi@15002000 {
+			compatible = "mediatek,mt8195-smi-sub-common";
+			reg = <0 0x15002000 0 0x1000>;
+			clocks = <&imgsys CLK_IMG_IPE>,
+				 <&imgsys CLK_IMG_IPE>,
+			         <&vppsys0 CLK_VPP0_GALS_IMGSYS_CAMSYS>;
+			clock-names = "apb", "smi", "gals0";
+			mediatek,smi = <&smi_common_vpp>;
+			mediatek,smi_sub_common;
+			power-domains = <&spm MT8195_POWER_DOMAIN_IMG>;
+		};
+
+		smi_sub_common_img1_3x1: smi@15003000 {
+			compatible = "mediatek,mt8195-smi-sub-common";
+			reg = <0 0x15003000 0 0x1000>;
+			clocks = <&imgsys CLK_IMG_LARB9>,
+				 <&imgsys CLK_IMG_LARB9>,
+				 <&imgsys CLK_IMG_GALS>;
+			clock-names = "apb", "smi", "gals0";
+			mediatek,smi = <&smi_common_vdo>;
+			mediatek,smi_sub_common;
+			power-domains = <&spm MT8195_POWER_DOMAIN_IMG>;
+		};
+
+		imgsys1_dip_top: syscon@15110000 {
+			compatible = "mediatek,mt8195-imgsys1_dip_top", "syscon";
+			reg = <0 0x15110000 0 0x1000>;
+			#clock-cells = <1>;
+		};
+
+		larb10: larb@15120000 {
+			compatible = "mediatek,mt8195-smi-larb";
+			reg = <0 0x15120000 0 0x1000>;
+			mediatek,larb-id = <10>;
+			mediatek,smi = <&smi_sub_common_img1_3x1>;
+			clocks = <&imgsys CLK_IMG_DIP0>,
+			       <&imgsys1_dip_top CLK_IMG1_DIP_TOP_LARB10>,
+			       <&imgsys CLK_IMG_LARB9>,
+			       <&imgsys CLK_IMG_GALS>;
+			clock-names = "apb", "smi", "gals", "gals1";
+			power-domains = <&spm MT8195_POWER_DOMAIN_DIP>;
+		};
+
+		imgsys1_dip_nr: syscon@15130000 {
+			compatible = "mediatek,mt8195-imgsys1_dip_nr", "syscon";
+			reg = <0 0x15130000 0 0x1000>;
+			#clock-cells = <1>;
+		};
+
+		imgsys1_wpe: syscon@15220000 {
+			compatible = "mediatek,mt8195-imgsys1_wpe", "syscon";
+			reg = <0 0x15220000 0 0x1000>;
+			#clock-cells = <1>;
+		};
+
+		larb11: larb@15230000 {
+			compatible = "mediatek,mt8195-smi-larb";
+			reg = <0 0x15230000 0 0x1000>;
+			mediatek,larb-id = <11>;
+			mediatek,smi = <&smi_sub_common_img1_3x1>;
+			clocks = <&imgsys CLK_IMG_WPE0>,
+			       <&imgsys1_wpe CLK_IMG1_WPE_LARB11>,
+			       <&imgsys CLK_IMG_LARB9>,
+			       <&imgsys CLK_IMG_GALS>;
+			clock-names = "apb", "smi", "gals", "gals1";
+			power-domains = <&spm MT8195_POWER_DOMAIN_DIP>;
+		};
+
+		ipesys: syscon@15330000 {
+			compatible = "mediatek,mt8195-ipesys", "syscon";
+			reg = <0 0x15330000 0 0x1000>;
+			#clock-cells = <1>;
+		};
+
+		larb12: larb@15340000 {
+			compatible = "mediatek,mt8195-smi-larb";
+			reg = <0 0x15340000 0 0x1000>;
+			mediatek,larb-id = <12>;
+			mediatek,smi = <&smi_sub_common_img0_3x1>;
+			clocks = <&ipesys CLK_IPE_SMI_LARB12>,
+				 <&ipesys CLK_IPE_SMI_LARB12>;
+			clock-names = "apb", "smi";
+			power-domains = <&spm MT8195_POWER_DOMAIN_IPE>;
+		};
+
+		camsys: syscon@16000000 {
+			compatible = "mediatek,mt8195-camsys", "syscon";
+			reg = <0 0x16000000 0 0x1000>;
+			#clock-cells = <1>;
+		};
+
+		larb13: larb@16001000 {
+			compatible = "mediatek,mt8195-smi-larb";
+			reg = <0 0x16001000 0 0x1000>;
+			mediatek,larb-id = <13>;
+			mediatek,smi = <&smi_sub_common_cam_4x1>;
+			clocks = <&camsys CLK_CAM_LARB13>,
+			       <&camsys CLK_CAM_LARB13>,
+			       <&camsys CLK_CAM_CAM2MM0_GALS>;
+			clock-names = "apb", "smi", "gals";
+			power-domains = <&spm MT8195_POWER_DOMAIN_CAM>;
+		};
+
+		larb14: larb@16002000 {
+			compatible = "mediatek,mt8195-smi-larb";
+			reg = <0 0x16002000 0 0x1000>;
+			mediatek,larb-id = <14>;
+			mediatek,smi = <&smi_sub_common_cam_7x1>;
+			clocks = <&camsys CLK_CAM_LARB14>,
+				 <&camsys CLK_CAM_LARB14>;
+			clock-names = "apb", "smi";
+			power-domains = <&spm MT8195_POWER_DOMAIN_CAM>;
+		};
+
+		smi_sub_common_cam_4x1: smi@16004000 {
+			compatible = "mediatek,mt8195-smi-sub-common";
+			reg = <0 0x16004000 0 0x1000>;
+			clocks = <&camsys CLK_CAM_LARB13>,
+				 <&camsys CLK_CAM_LARB13>,
+				 <&camsys CLK_CAM_CAM2MM0_GALS>;
+			clock-names = "apb", "smi", "gals0";
+			mediatek,smi = <&smi_common_vdo>;
+			mediatek,smi_sub_common;
+			power-domains = <&spm MT8195_POWER_DOMAIN_CAM>;
+		};
+
+		smi_sub_common_cam_7x1: smi@16005000 {
+			compatible = "mediatek,mt8195-smi-sub-common";
+			reg = <0 0x16005000 0 0x1000>;
+			clocks = <&camsys CLK_CAM_LARB14>,
+				 <&camsys CLK_CAM_CAM2MM1_GALS>,
+				 <&vppsys0 CLK_VPP0_GALS_IMGSYS_CAMSYS>;
+			clock-names = "apb", "smi", "gals0";
+			mediatek,smi = <&smi_common_vpp>;
+			mediatek,smi_sub_common;
+			power-domains = <&spm MT8195_POWER_DOMAIN_CAM>;
+		};
+
+		larb16: larb@16012000 {
+			compatible = "mediatek,mt8195-smi-larb";
+			reg = <0 0x16012000 0 0x1000>;
+			mediatek,larb-id = <16>;
+			mediatek,smi = <&smi_sub_common_cam_7x1>;
+			clocks = <&camsys_rawa CLK_CAM_RAWA_LARBX>,
+			         <&camsys_rawa CLK_CAM_RAWA_LARBX>;
+			clock-names = "apb", "smi";
+			power-domains = <&spm MT8195_POWER_DOMAIN_CAM_RAWA>;
+		};
+
+		larb17: larb@16013000 {
+			compatible = "mediatek,mt8195-smi-larb";
+			reg = <0 0x16013000 0 0x1000>;
+			mediatek,larb-id = <17>;
+			mediatek,smi = <&smi_sub_common_cam_4x1>;
+			clocks = <&camsys_yuva CLK_CAM_YUVA_LARBX>,
+			         <&camsys_yuva CLK_CAM_YUVA_LARBX>;
+			clock-names = "apb", "smi";
+			power-domains = <&spm MT8195_POWER_DOMAIN_CAM_RAWA>;
+		};
+
+		larb27: larb@16014000 {
+			compatible = "mediatek,mt8195-smi-larb";
+			reg = <0 0x16014000 0 0x1000>;
+			mediatek,larb-id = <27>;
+			mediatek,smi = <&smi_sub_common_cam_7x1>;
+			clocks = <&camsys_rawb CLK_CAM_RAWB_LARBX>,
+				 <&camsys_rawb CLK_CAM_RAWB_LARBX>;
+			clock-names = "apb", "smi";
+			power-domains = <&spm MT8195_POWER_DOMAIN_CAM_RAWB>;
+		};
+
+		larb28: larb@16015000 {
+			compatible = "mediatek,mt8195-smi-larb";
+			reg = <0 0x16015000 0 0x1000>;
+			mediatek,larb-id = <28>;
+			mediatek,smi = <&smi_sub_common_cam_4x1>;
+			clocks = <&camsys_yuvb CLK_CAM_YUVB_LARBX>,
+				 <&camsys_yuvb CLK_CAM_YUVB_LARBX>;
+			clock-names = "apb", "smi";
+			power-domains = <&spm MT8195_POWER_DOMAIN_CAM_RAWB>;
+		};
+
+		camsys_rawa: syscon@1604f000 {
+			compatible = "mediatek,mt8195-camsys_rawa", "syscon";
+			reg = <0 0x1604f000 0 0x1000>;
+			#clock-cells = <1>;
+		};
+
+		camsys_yuva: syscon@1606f000 {
+			compatible = "mediatek,mt8195-camsys_yuva", "syscon";
+			reg = <0 0x1606f000 0 0x1000>;
+			#clock-cells = <1>;
+		};
+
+		camsys_rawb: syscon@1608f000 {
+			compatible = "mediatek,mt8195-camsys_rawb", "syscon";
+			reg = <0 0x1608f000 0 0x1000>;
+			#clock-cells = <1>;
+		};
+
+		camsys_yuvb: syscon@160af000 {
+			compatible = "mediatek,mt8195-camsys_yuvb", "syscon";
+			reg = <0 0x160af000 0 0x1000>;
+			#clock-cells = <1>;
+		};
+
+		camsys_mraw: syscon@16140000 {
+			compatible = "mediatek,mt8195-camsys_mraw", "syscon";
+			reg = <0 0x16140000 0 0x1000>;
+			#clock-cells = <1>;
+		};
+
+		larb25: larb@16141000 {
+			compatible = "mediatek,mt8195-smi-larb";
+			reg = <0 0x16141000 0 0x1000>;
+			mediatek,larb-id = <25>;
+			mediatek,smi = <&smi_sub_common_cam_4x1>;
+			clocks = <&camsys CLK_CAM_LARB13>,
+			         <&camsys_mraw CLK_CAM_MRAW_LARBX>,
+			         <&camsys CLK_CAM_CAM2MM0_GALS>;
+			clock-names = "apb", "smi", "gals";
+			power-domains = <&spm MT8195_POWER_DOMAIN_CAM_MRAW>;
+		};
+
+		larb26: larb@16142000 {
+			compatible = "mediatek,mt8195-smi-larb";
+			reg = <0 0x16142000 0 0x1000>;
+			mediatek,larb-id = <26>;
+			mediatek,smi = <&smi_sub_common_cam_7x1>;
+			clocks = <&camsys_mraw CLK_CAM_MRAW_LARBX>,
+				 <&camsys_mraw CLK_CAM_MRAW_LARBX>;
+			clock-names = "apb", "smi";
+			power-domains = <&spm MT8195_POWER_DOMAIN_CAM_MRAW>;
+
+		};
+
+		ccusys: syscon@17200000 {
+			compatible = "mediatek,mt8195-ccusys", "syscon";
+			reg = <0 0x17200000 0 0x1000>;
+			#clock-cells = <1>;
+		};
+
+		larb18: larb@17201000 {
+			compatible = "mediatek,mt8195-smi-larb";
+			reg = <0 0x17201000 0 0x1000>;
+			mediatek,larb-id = <18>;
+			mediatek,smi = <&smi_sub_common_cam_7x1>;
+			clocks = <&ccusys CLK_CCU_LARB18>,
+				 <&ccusys CLK_CCU_LARB18>;
+			clock-names = "apb", "smi";
+			power-domains = <&spm MT8195_POWER_DOMAIN_CAM>;
+		};
+
+		vcodec_dec: vcodec_dec@18000000 {
+			compatible = "mediatek,mt8195-vcodec-dec";
+			reg = <0 0x18000000 0 0x1000>;		/* VDEC_SYS */
+			mediatek,scp = <&scp>;
+			iommus = <&iommu_vdo M4U_PORT_L21_VDEC_MC_EXT>;
+			dma-ranges = <0x1 0x0 0x0 0x40000000 0x0 0xfff00000>;
+		};
+
+		vcodec_lat_soc: vcodec_lat_soc@0x18002000 {
+			compatible = "mediatek,mtk-vcodec-lat-soc";
+			reg = <0 0x18002000 0 0x800>;		/* VDEC_MISC */
+			iommus = <&iommu_vpp M4U_PORT_L23_VDEC_UFO_ENC_EXT>,
+				<&iommu_vpp M4U_PORT_L23_VDEC_RDMA_EXT>;
+			clocks = <&topckgen CLK_TOP_VDEC>,
+				<&vdecsys_soc CLK_VDEC_SOC_VDEC>,
+				 <&vdecsys_soc CLK_VDEC_SOC_LAT>,
+				 <&topckgen CLK_TOP_UNIVPLL_D4>;
+			clock-names = "vdec-sel", "vdec-soc-vdec", "vdec-soc-lat", "vdec-top";
+				 assigned-clocks = <&topckgen CLK_TOP_VDEC>;
+			assigned-clock-parents = <&topckgen CLK_TOP_UNIVPLL_D4>;
+			power-domains = <&spm MT8195_POWER_DOMAIN_VDEC0>;
+			dma-ranges = <0x1 0x0 0x0 0x40000000 0x0 0xfff00000>;
+		};
+
+		vcodec_lat: vcodec_lat@0x18010000 {
+			compatible = "mediatek,mtk-vcodec-lat";
+			reg = <0 0x18010000 0 0x800>;		/* VDEC_MISC */
+			interrupts = <GIC_SPI 708 IRQ_TYPE_LEVEL_HIGH 0>;
+			iommus = <&iommu_vdo M4U_PORT_L24_VDEC_LAT0_VLD_EXT>,
+				<&iommu_vdo M4U_PORT_L24_VDEC_LAT0_VLD2_EXT>,
+				<&iommu_vdo M4U_PORT_L24_VDEC_LAT0_AVC_MC_EXT>,
+				<&iommu_vdo M4U_PORT_L24_VDEC_LAT0_PRED_RD_EXT>,
+				<&iommu_vdo M4U_PORT_L24_VDEC_LAT0_TILE_EXT>,
+				<&iommu_vdo M4U_PORT_L24_VDEC_LAT0_WDMA_EXT>;
+			clocks = <&topckgen CLK_TOP_VDEC>,
+				 <&vdecsys_soc CLK_VDEC_SOC_VDEC>,
+				 <&vdecsys_soc CLK_VDEC_SOC_LAT>,
+				 <&topckgen CLK_TOP_UNIVPLL_D4>;
+			clock-names = "vdec-sel", "vdec-soc-vdec", "vdec-soc-lat", "vdec-top";
+			assigned-clocks = <&topckgen CLK_TOP_VDEC>;
+			assigned-clock-parents = <&topckgen CLK_TOP_UNIVPLL_D4>;
+			power-domains =  <&spm MT8195_POWER_DOMAIN_VDEC0>;
+			dma-ranges = <0x1 0x0 0x0 0x40000000 0x0 0xfff00000>;
+		};
+
+		vcodec_core: vcodec_core@0x18025000 {
+			compatible = "mediatek,mtk-vcodec-core";
+			reg = <0 0x18025000 0 0x1000>;		/* VDEC_CORE_MISC */
+			interrupts = <GIC_SPI 707 IRQ_TYPE_LEVEL_HIGH 0>;
+			iommus = <&iommu_vdo M4U_PORT_L21_VDEC_MC_EXT>,
+				<&iommu_vdo M4U_PORT_L21_VDEC_UFO_EXT>,
+				<&iommu_vdo M4U_PORT_L21_VDEC_PP_EXT>,
+				<&iommu_vdo M4U_PORT_L21_VDEC_PRED_RD_EXT>,
+				<&iommu_vdo M4U_PORT_L21_VDEC_PRED_WR_EXT>,
+				<&iommu_vdo M4U_PORT_L21_VDEC_PPWRAP_EXT>,
+				<&iommu_vdo M4U_PORT_L21_VDEC_TILE_EXT>,
+				<&iommu_vdo M4U_PORT_L21_VDEC_VLD_EXT>,
+				<&iommu_vdo M4U_PORT_L21_VDEC_VLD2_EXT>,
+				<&iommu_vdo M4U_PORT_L21_VDEC_AVC_MV_EXT>;
+			clocks = <&topckgen CLK_TOP_VDEC>,
+				 <&vdecsys CLK_VDEC_VDEC>,
+				 <&vdecsys CLK_VDEC_LAT>,
+				 <&topckgen CLK_TOP_UNIVPLL_D4>;
+			clock-names = "vdec-sel", "vdec-soc-vdec", "vdec-soc-lat", "vdec-top";
+			assigned-clocks = <&topckgen CLK_TOP_VDEC>;
+			assigned-clock-parents = <&topckgen CLK_TOP_UNIVPLL_D4>;
+			power-domains = <&spm MT8195_POWER_DOMAIN_VDEC1>;
+			dma-ranges = <0x1 0x0 0x0 0x40000000 0x0 0xfff00000>;
+		};
+
+		vcodec_core1: vcodec_core1@0x18035000 {
+			compatible = "mediatek,mtk-vcodec-core1";
+			reg = <0 0x18035000 0 0x1000>;		/* VDEC_CORE1_MISC */
+			interrupts = <GIC_SPI 709 IRQ_TYPE_LEVEL_HIGH 0>;
+			iommus = <&iommu_vpp M4U_PORT_L22_VDEC_MC_EXT>,
+				<&iommu_vpp M4U_PORT_L22_VDEC_UFO_EXT>,
+				<&iommu_vpp M4U_PORT_L22_VDEC_PP_EXT>,
+				<&iommu_vpp M4U_PORT_L22_VDEC_PRED_RD_EXT>,
+				<&iommu_vpp M4U_PORT_L22_VDEC_PRED_WR_EXT>,
+				<&iommu_vpp M4U_PORT_L22_VDEC_PPWRAP_EXT>,
+				<&iommu_vpp M4U_PORT_L22_VDEC_TILE_EXT>,
+				<&iommu_vpp M4U_PORT_L22_VDEC_VLD_EXT>,
+				<&iommu_vpp M4U_PORT_L22_VDEC_VLD2_EXT>,
+				<&iommu_vpp M4U_PORT_L22_VDEC_AVC_MV_EXT>;
+			clocks = <&topckgen CLK_TOP_VDEC>,
+				 <&vdecsys CLK_VDEC_CORE1_VDEC>,
+				 <&vdecsys CLK_VDEC_CORE1_LAT>,
+				 <&topckgen CLK_TOP_UNIVPLL_D4>;
+			clock-names = "vdec-sel", "vdec-soc-vdec", "vdec-soc-lat", "vdec-top";
+			assigned-clocks = <&topckgen CLK_TOP_VDEC>;
+			assigned-clock-parents = <&topckgen CLK_TOP_UNIVPLL_D4>;
+			power-domains = <&spm MT8195_POWER_DOMAIN_VDEC2>;
+			dma-ranges = <0x1 0x0 0x0 0x40000000 0x0 0xfff00000>;
+		};
+
+		larb24: larb@1800d000 {
+			compatible = "mediatek,mt8195-smi-larb";
+			reg = <0 0x1800d000 0 0x1000>;
+			mediatek,larb-id = <24>;
+			mediatek,smi = <&smi_common_vdo>;
+			clocks = <&vdecsys_soc CLK_VDEC_SOC_LARB1>,
+			         <&vdecsys_soc CLK_VDEC_SOC_LARB1>;
+			clock-names = "apb", "smi";
+			power-domains = <&spm MT8195_POWER_DOMAIN_VDEC0>;
+		};
+
+		larb23: larb@1800e000 {
+			compatible = "mediatek,mt8195-smi-larb";
+			reg = <0 0x1800e000 0 0x1000>;
+			mediatek,larb-id = <23>;
+			mediatek,smi = <&smi_sub_common_vdec_vpp0_2x1>;
+			clocks = <&vppsys0 CLK_VPP0_GALS_VDEC_VDEC_CORE1>,
+			         <&vdecsys_soc CLK_VDEC_SOC_LARB1>;
+			clock-names = "apb", "smi";
+			power-domains = <&spm MT8195_POWER_DOMAIN_VDEC0>;
+		};
+
+		vdecsys_soc: syscon@1800f000 {
+			compatible = "mediatek,mt8195-vdecsys_soc", "syscon";
+			reg = <0 0x1800f000 0 0x1000>;
+			#clock-cells = <1>;
+		};
+
+		larb21: larb@1802e000 {
+			compatible = "mediatek,mt8195-smi-larb";
+			reg = <0 0x1802e000 0 0x1000>;
+			mediatek,larb-id = <21>;
+			mediatek,smi = <&smi_common_vdo>;
+			clocks = <&vdecsys CLK_VDEC_LARB1>,
+			       <&vdecsys CLK_VDEC_LARB1>;
+			clock-names = "apb", "smi";
+			power-domains = <&spm MT8195_POWER_DOMAIN_VDEC1>;
+		};
+
+		vdecsys: syscon@1802f000 {
+			compatible = "mediatek,mt8195-vdecsys", "syscon";
+			reg = <0 0x1802f000 0 0x1000>;
+			#clock-cells = <1>;
+		};
+
+		larb22: larb@1803e000 {
+			compatible = "mediatek,mt8195-smi-larb";
+			reg = <0 0x1803e000 0 0x1000>;
+			mediatek,larb-id = <22>;
+			mediatek,smi = <&smi_sub_common_vdec_vpp0_2x1>;
+			clocks = <&vppsys0 CLK_VPP0_GALS_VDEC_VDEC_CORE1>,
+			         <&vdecsys_core1 CLK_VDEC_CORE1_LARB1>;
+			clock-names = "apb", "smi";
+			power-domains = <&spm MT8195_POWER_DOMAIN_VDEC2>;
+		};
+
+		vdecsys_core1: syscon@1803f000 {
+			compatible = "mediatek,mt8195-vdecsys_core1", "syscon";
+			reg = <0 0x1803f000 0 0x1000>;
+			#clock-cells = <1>;
+		};
+
+		iommu_apu0: iommu@19010000 {
+			compatible = "mediatek,mt8195-iommu-apu";
+			reg = <0 0x19010000 0 0x1000>;
+			interrupts = <GIC_SPI 426 IRQ_TYPE_LEVEL_HIGH 0>;
+			clocks = <&clk26m>;
+			clock-names = "bclk";
+			#iommu-cells = <1>;
+			/* power-domains = <&apuspm MT8195_POWER_DOMAIN_APUSYS_TOP>; */
+			status = "disabled";
+		};
+
+		iommu_apu1: iommu@19015000 {
+			compatible = "mediatek,mt8195-iommu-apu";
+			reg = <0 0x19015000 0 0x1000>;
+			interrupts = <GIC_SPI 431 IRQ_TYPE_LEVEL_HIGH 0>;
+			clocks = <&clk26m>;
+			clock-names = "bclk";
+			#iommu-cells = <1>;
+			/* power-domains = <&apuspm MT8195_POWER_DOMAIN_APUSYS_TOP>; */
+			status = "disabled";
+		};
+
+		apusys_pll: syscon@190f3000 {
+			compatible = "mediatek,mt8195-apusys_pll", "syscon";
+			reg = <0 0x190f3000 0 0x1000>;
+			#clock-cells = <1>;
+		};
+
+		vencsys: syscon@1a000000 {
+			compatible = "mediatek,mt8195-vencsys", "syscon";
+			reg = <0 0x1a000000 0 0x1000>;
+			#clock-cells = <1>;
+		};
+
+		larb19: larb@1a010000 {
+			compatible = "mediatek,mt8195-smi-larb";
+			reg = <0 0x1a010000 0 0x1000>;
+			mediatek,larb-id = <19>;
+			mediatek,smi = <&smi_common_vdo>;
+			clocks = <&vencsys CLK_VENC_VENC>,
+				 <&vencsys CLK_VENC_GALS>;
+			clock-names = "apb", "smi";
+			power-domains = <&spm MT8195_POWER_DOMAIN_VENC>;
+		};
+
+		venc: venc@1a020000 {
+			compatible = "mediatek,mt8195-vcodec-enc";
+			reg = <0 0x1a020000 0 0x10000>;/* VENC_C0 */
+			iommus = <&iommu_vdo M4U_PORT_L19_VENC_RCPU>,
+					<&iommu_vdo M4U_PORT_L19_VENC_REC>,
+					<&iommu_vdo M4U_PORT_L19_VENC_BSDMA>,
+					<&iommu_vdo M4U_PORT_L19_VENC_SV_COMV>,
+					<&iommu_vdo M4U_PORT_L19_VENC_RD_COMV>,
+					<&iommu_vdo M4U_PORT_L19_VENC_CUR_LUMA>,
+					<&iommu_vdo M4U_PORT_L19_VENC_CUR_CHROMA>,
+					<&iommu_vdo M4U_PORT_L19_VENC_REF_LUMA>,
+					<&iommu_vdo M4U_PORT_L19_VENC_REF_CHROMA>;
+			interrupts = <GIC_SPI 341 IRQ_TYPE_LEVEL_HIGH 0>;
+			mediatek,scp = <&scp>;
+			clocks = <&vencsys CLK_VENC_VENC>;
+			clock-names = "MT_CG_VENC0";
+			assigned-clocks = <&topckgen CLK_TOP_VENC>;
+			assigned-clock-parents = <&topckgen CLK_TOP_UNIVPLL_D4>;
+			power-domains = <&spm MT8195_POWER_DOMAIN_VENC>;
+			dma-ranges = <0x1 0x0 0x0 0x40000000 0x0 0xfff00000>;
+		};
+
+		vencsys_core1: syscon@1b000000 {
+			compatible = "mediatek,mt8195-vencsys_core1", "syscon";
+			reg = <0 0x1b000000 0 0x1000>;
+			#clock-cells = <1>;
+		};
+
+		larb20: larb@1b010000 {
+			compatible = "mediatek,mt8195-smi-larb";
+			reg = <0 0x1b010000 0 0x1000>;
+			mediatek,larb-id = <20>;
+			mediatek,smi = <&smi_common_vpp>;
+			clocks = <&vencsys_core1 CLK_VENC_CORE1_LARB>,
+				 <&vencsys_core1 CLK_VENC_CORE1_GALS>,
+				 <&vppsys0 CLK_VPP0_GALS_VDO0_VDO1_VENCSYS_CORE1>;
+			clock-names = "apb", "smi", "gals";
+			power-domains = <&spm MT8195_POWER_DOMAIN_VENC_CORE1>;
+		};
+
+		ovl0: disp_ovl@1c000000 {
+			compatible = "mediatek,mt8195-disp-ovl",
+				     "mediatek,mt8183-disp-ovl";
+			reg = <0 0x1c000000 0 0x1000>;
+			interrupts = <GIC_SPI 636 IRQ_TYPE_LEVEL_HIGH 0>;
+			power-domains = <&spm MT8195_POWER_DOMAIN_VDOSYS0>;
+			clocks = <&vdosys0 CLK_VDO0_DISP_OVL0>;
+			iommus = <&iommu_vdo M4U_PORT_L0_DISP_OVL0_RDMA0>;
+			mediatek,gce-client-reg =
+				 <&gce1 SUBSYS_1c00XXXX 0x0000 0x1000>;
+		};
+
+		rdma0: disp_rdma@1c002000 {
+			compatible = "mediatek,mt8195-disp-rdma";
+			reg = <0 0x1c002000 0 0x1000>;
+			interrupts = <GIC_SPI 638 IRQ_TYPE_LEVEL_HIGH 0>;
+			power-domains = <&spm MT8195_POWER_DOMAIN_VDOSYS0>;
+			clocks = <&vdosys0 CLK_VDO0_DISP_RDMA0>;
+			iommus = <&iommu_vdo M4U_PORT_L0_DISP_RDMA0>;
+			mediatek,gce-client-reg =
+				 <&gce1 SUBSYS_1c00XXXX 0x2000 0x1000>;
+		};
+
+		color0: disp_color@1c003000 {
+			compatible = "mediatek,mt8195-disp-color",
+				     "mediatek,mt8173-disp-color";
+			reg = <0 0x1c003000 0 0x1000>;
+			interrupts = <GIC_SPI 639 IRQ_TYPE_LEVEL_HIGH 0>;
+			power-domains = <&spm MT8195_POWER_DOMAIN_VDOSYS0>;
+			clocks = <&vdosys0 CLK_VDO0_DISP_COLOR0>;
+			mediatek,gce-client-reg =
+				 <&gce1 SUBSYS_1c00XXXX 0x3000 0x1000>;
+		};
+
+		ccorr0: disp_ccorr@1c004000 {
+			compatible = "mediatek,mt8195-disp-ccorr";
+			reg = <0 0x1c004000 0 0x1000>;
+			interrupts = <GIC_SPI 640 IRQ_TYPE_LEVEL_HIGH 0>;
+			power-domains = <&spm MT8195_POWER_DOMAIN_VDOSYS0>;
+			clocks = <&vdosys0 CLK_VDO0_DISP_CCORR0>;
+			mediatek,gce-client-reg =
+				 <&gce1 SUBSYS_1c00XXXX 0x4000 0x1000>;
+		};
+
+		aal0: disp_aal@1c005000 {
+			compatible = "mediatek,mt8195-disp-aal",
+				     "mediatek,mt8173-disp-aal";
+			reg = <0 0x1c005000 0 0x1000>;
+			interrupts = <GIC_SPI 641 IRQ_TYPE_LEVEL_HIGH 0>;
+			power-domains = <&spm MT8195_POWER_DOMAIN_VDOSYS0>;
+			clocks = <&vdosys0 CLK_VDO0_DISP_AAL0>;
+			mediatek,gce-client-reg =
+				 <&gce1 SUBSYS_1c00XXXX 0x5000 0x1000>;
+		};
+
+		gamma0: disp_gamma@1c006000 {
+			compatible = "mediatek,mt8195-disp-gamma",
+				     "mediatek,mt8173-disp-gamma";
+			reg = <0 0x1c006000 0 0x1000>;
+			interrupts = <GIC_SPI 642 IRQ_TYPE_LEVEL_HIGH 0>;
+			power-domains = <&spm MT8195_POWER_DOMAIN_VDOSYS0>;
+			clocks = <&vdosys0 CLK_VDO0_DISP_GAMMA0>;
+			mediatek,gce-client-reg =
+				 <&gce1 SUBSYS_1c00XXXX 0x6000 0x1000>;
+		};
+
+		dither0: disp_dither@1c007000 {
+			compatible = "mediatek,mt8195-disp-dither",
+				     "mediatek,mt8183-disp-dither";
+			reg = <0 0x1c007000 0 0x1000>;
+			interrupts = <GIC_SPI 643 IRQ_TYPE_LEVEL_HIGH 0>;
+			power-domains = <&spm MT8195_POWER_DOMAIN_VDOSYS0>;
+			clocks = <&vdosys0 CLK_VDO0_DISP_DITHER0>;
+			mediatek,gce-client-reg =
+				 <&gce1 SUBSYS_1c00XXXX 0x7000 0x1000>;
+		};
+
+		dsc0: disp_dsc_wrap@1c009000 {
+			compatible = "mediatek,mt8195-disp-dsc";
+			reg = <0 0x1c009000 0 0x1000>;
+			interrupts = <GIC_SPI 645 IRQ_TYPE_LEVEL_HIGH 0>;
+			power-domains = <&spm MT8195_POWER_DOMAIN_VDOSYS0>;
+			clocks = <&vdosys0 CLK_VDO0_DSC_WRAP0>;
+			mediatek,gce-client-reg =
+				 <&gce1 SUBSYS_1c00XXXX 0x9000 0x1000>;
+		};
+
+		merge0: disp_vpp_merge0@1c014000 {
+			compatible = "mediatek,mt8195-disp-merge";
+			reg = <0 0x1c014000 0 0x1000>;
+			interrupts = <GIC_SPI 656 IRQ_TYPE_LEVEL_HIGH 0>;
+			power-domains = <&spm MT8195_POWER_DOMAIN_VDOSYS0>;
+			clocks = <&vdosys0 CLK_VDO0_VPP_MERGE0>;
+			mediatek,gce-client-reg =
+				 <&gce1 SUBSYS_1c01XXXX 0x4000 0x1000>;
+		};
+
+		dp_intf0: dp_intf0@1c015000 {
+			status = "disabled";
+			compatible = "mediatek,mt8195-dpintf";
+			reg = <0 0x1c015000 0 0x1000>;
+			interrupts = <GIC_SPI 657 IRQ_TYPE_LEVEL_HIGH 0>;
+			clocks = <&vdosys0  CLK_VDO0_DP_INTF0>,
+				<&vdosys0 CLK_VDO0_DP_INTF0_DP_INTF>,
+				<&topckgen CLK_TOP_EDP>,
+				<&topckgen CLK_TOP_TVDPLL1_D2>,
+				<&topckgen CLK_TOP_TVDPLL1_D4>,
+				<&topckgen CLK_TOP_TVDPLL1_D8>,
+				<&topckgen CLK_TOP_TVDPLL1_D16>,
+				<&apmixedsys CLK_APMIXED_TVDPLL1>;
+			clock-names = "hf_fmm_ck",
+				      "hf_fdp_ck",
+				      "MUX_DP",
+				      "TVDPLL_D2",
+				      "TVDPLL_D4",
+				      "TVDPLL_D8",
+				      "TVDPLL_D16",
+				      "DPI_CK";
+		};
+
+		mutex: disp_mutex0@1c016000 {
+			compatible = "mediatek,mt8195-disp-mutex";
+			reg = <0 0x1c016000 0 0x1000>;
+			reg-names = "vdo0_mutex";
+			interrupts = <GIC_SPI 658 IRQ_TYPE_LEVEL_HIGH 0>;
+			power-domains = <&spm MT8195_POWER_DOMAIN_VDOSYS0>;
+			clocks = <&vdosys0 CLK_VDO0_DISP_MUTEX0>;
+			clock-names = "vdo0_mutex";
+			mediatek,gce-events =
+				 <CMDQ_EVENT_VDO0_DISP_STREAM_DONE_0>;
+		};
+
+		larb0: larb@1c018000 {
+			compatible = "mediatek,mt8195-smi-larb";
+			reg = <0 0x1c018000 0 0x1000>;
+			mediatek,larb-id = <0>;
+			mediatek,smi = <&smi_common_vdo>;
+			clocks = <&vdosys0 CLK_VDO0_SMI_LARB>,
+				 <&vdosys0 CLK_VDO0_SMI_LARB>,
+				 <&vppsys0 CLK_VPP0_GALS_VDO0_LARB0>;
+			clock-names = "apb", "smi", "gals";
+			power-domains = <&spm MT8195_POWER_DOMAIN_VDOSYS0>;
+		};
+
+		larb1: larb@1c019000 {
+			compatible = "mediatek,mt8195-smi-larb";
+			reg = <0 0x1c019000 0 0x1000>;
+			mediatek,larb-id = <1>;
+			mediatek,smi = <&smi_common_vpp>;
+			clocks = <&vdosys0 CLK_VDO0_SMI_LARB>,
+				 <&vppsys0 CLK_VPP0_GALS_VDO0_VDO1_VENCSYS_CORE1>,
+				 <&vppsys0 CLK_VPP0_GALS_VDO0_LARB1>;
+			clock-names = "apb", "smi", "gals";
+			power-domains = <&spm MT8195_POWER_DOMAIN_VDOSYS0>;
+		};
+
+		vdosys0: syscon@1c01a000 {
+			compatible = "mediatek,mt8195-vdosys0", "syscon";
+			reg = <0 0x1c01a000 0 0x1000>;
+			mboxes = <&gce1 0 CMDQ_THR_PRIO_4>;
+			#clock-cells = <1>;
+		};
+
+		smi_common_vdo: smi@1c01b000 {
+			compatible = "mediatek,mt8195-smi-common-vdo";
+			reg = <0 0x1c01b000 0 0x1000>;
+			clocks = <&vdosys0 CLK_VDO0_SMI_COMMON>,
+				 <&vdosys0 CLK_VDO0_SMI_EMI>,
+				 <&vdosys0 CLK_VDO0_SMI_RSI>,
+				 <&vdosys0 CLK_VDO0_SMI_GALS>;
+			clock-names = "apb", "smi", "gals0", "gals1";
+			power-domains = <&spm MT8195_POWER_DOMAIN_VDOSYS0>;
+
+		};
+
+		iommu_vdo: iommu@1c01f000 {
+			compatible = "mediatek,mt8195-iommu-vdo";
+			reg = <0 0x1c01f000 0 0x1000>;
+			mediatek,larbs = <&larb0 &larb2 &larb5 &larb7 &larb9
+					  &larb10 &larb11 &larb13 &larb17
+					  &larb19 &larb21 &larb24 &larb25
+					  &larb28>;
+			interrupts = <GIC_SPI 669 IRQ_TYPE_LEVEL_HIGH 0>;
+			#iommu-cells = <1>;
+			clocks = <&vdosys0 CLK_VDO0_SMI_IOMMU>;
+			clock-names = "bclk";
+			power-domains = <&spm MT8195_POWER_DOMAIN_VDOSYS0>;
+		};
+
+		vdosys1: syscon@1c100000 {
+			compatible = "mediatek,mt8195-vdosys1", "syscon";
+			reg = <0 0x1c100000 0 0x1000>;
+			mboxes = <&gce1 1 CMDQ_THR_PRIO_4>;
+			mediatek,gce-client-reg = <&gce1 SUBSYS_1c10XXXX 0x0000 0x1000>;
+			#clock-cells = <1>;
+			#reset-cells = <1>;
+		};
+
+		mutex1: disp_mutex0@1c101000 {
+			compatible = "mediatek,mt8195-disp-mutex";
+			reg = <0 0x1c101000 0 0x1000>;
+			reg-names = "vdo1_mutex";
+			interrupts = <GIC_SPI 494 IRQ_TYPE_LEVEL_HIGH 0>;
+			power-domains = <&spm MT8195_POWER_DOMAIN_VDOSYS1>;
+			clocks = <&vdosys1 CLK_VDO1_DISP_MUTEX>;
+			clock-names = "vdo1_mutex";
+			mediatek,gce-events = <CMDQ_EVENT_VDO1_STREAM_DONE_ENG_0>;
+		};
+
+		larb2: larb@1c102000 {
+			compatible = "mediatek,mt8195-smi-larb";
+			reg = <0 0x1c102000 0 0x1000>;
+			mediatek,larb-id = <2>;
+			mediatek,smi = <&smi_common_vdo>;
+			clocks = <&vdosys1 CLK_VDO1_SMI_LARB2>,
+			         <&vdosys1 CLK_VDO1_SMI_LARB2>,
+			         <&vdosys1 CLK_VDO1_GALS>;
+			clock-names = "apb", "smi", "gals";
+			power-domains = <&spm MT8195_POWER_DOMAIN_VDOSYS1>;
+		};
+
+		larb3: larb@1c103000 {
+			compatible = "mediatek,mt8195-smi-larb";
+			reg = <0 0x1c103000 0 0x1000>;
+			mediatek,larb-id = <3>;
+			mediatek,smi = <&smi_common_vpp>;
+			clocks = <&vdosys1 CLK_VDO1_SMI_LARB3>,
+			         <&vdosys1 CLK_VDO1_GALS>,
+			         <&vppsys0 CLK_VPP0_GALS_VDO0_VDO1_VENCSYS_CORE1>;
+			clock-names = "apb", "smi", "gals";
+			power-domains = <&spm MT8195_POWER_DOMAIN_VDOSYS1>;
+		};
+
+		vdo1_rdma0: vdo1_rdma@1c104000 {
+			compatible = "mediatek,mt8195-vdo1-rdma";
+			reg = <0 0x1c104000 0 0x1000>;
+			interrupts = <GIC_SPI 495 IRQ_TYPE_LEVEL_HIGH 0>;
+			clocks = <&vdosys1 CLK_VDO1_MDP_RDMA0>;
+			power-domains = <&spm MT8195_POWER_DOMAIN_VDOSYS1>;
+			iommus = <&iommu_vdo M4U_PORT_L2_MDP_RDMA0>;
+			mediatek,gce-client-reg = <&gce1 SUBSYS_1c10XXXX 0x4000 0x1000>;
+		};
+
+		vdo1_rdma1: vdo1_rdma@1c105000 {
+			compatible = "mediatek,mt8195-vdo1-rdma";
+			reg = <0 0x1c105000 0 0x1000>;
+			interrupts = <GIC_SPI 496 IRQ_TYPE_LEVEL_HIGH 0>;
+			clocks = <&vdosys1 CLK_VDO1_MDP_RDMA1>;
+			power-domains = <&spm MT8195_POWER_DOMAIN_VDOSYS1>;
+			iommus = <&iommu_vpp M4U_PORT_L3_MDP_RDMA1>;
+			mediatek,gce-client-reg = <&gce1 SUBSYS_1c10XXXX 0x5000 0x1000>;
+		};
+
+		vdo1_rdma2: vdo1_rdma@1c106000 {
+			compatible = "mediatek,mt8195-vdo1-rdma";
+			reg = <0 0x1c106000 0 0x1000>;
+			interrupts = <GIC_SPI 497 IRQ_TYPE_LEVEL_HIGH 0>;
+			clocks = <&vdosys1 CLK_VDO1_MDP_RDMA2>;
+			power-domains = <&spm MT8195_POWER_DOMAIN_VDOSYS1>;
+			iommus = <&iommu_vdo M4U_PORT_L2_MDP_RDMA2>;
+			mediatek,gce-client-reg = <&gce1 SUBSYS_1c10XXXX 0x6000 0x1000>;
+		};
+
+		vdo1_rdma3: vdo1_rdma@1c107000 {
+			compatible = "mediatek,mt8195-vdo1-rdma";
+			reg = <0 0x1c107000 0 0x1000>;
+			interrupts = <GIC_SPI 498 IRQ_TYPE_LEVEL_HIGH 0>;
+			clocks = <&vdosys1 CLK_VDO1_MDP_RDMA3>;
+			power-domains = <&spm MT8195_POWER_DOMAIN_VDOSYS1>;
+			iommus = <&iommu_vpp M4U_PORT_L3_MDP_RDMA3>;
+			mediatek,gce-client-reg = <&gce1 SUBSYS_1c10XXXX 0x7000 0x1000>;
+		};
+
+		vdo1_rdma4: vdo1_rdma@1c108000 {
+			compatible = "mediatek,mt8195-vdo1-rdma";
+			reg = <0 0x1c108000 0 0x1000>;
+			interrupts = <GIC_SPI 499 IRQ_TYPE_LEVEL_HIGH 0>;
+			clocks = <&vdosys1 CLK_VDO1_MDP_RDMA4>;
+			power-domains = <&spm MT8195_POWER_DOMAIN_VDOSYS1>;
+			iommus = <&iommu_vdo M4U_PORT_L2_MDP_RDMA4>;
+			mediatek,gce-client-reg = <&gce1 SUBSYS_1c10XXXX 0x8000 0x1000>;
+		};
+
+		vdo1_rdma5: vdo1_rdma@1c109000 {
+			compatible = "mediatek,mt8195-vdo1-rdma";
+			reg = <0 0x1c109000 0 0x1000>;
+			interrupts = <GIC_SPI 500 IRQ_TYPE_LEVEL_HIGH 0>;
+			clocks = <&vdosys1 CLK_VDO1_MDP_RDMA5>;
+			power-domains = <&spm MT8195_POWER_DOMAIN_VDOSYS1>;
+			iommus = <&iommu_vpp M4U_PORT_L3_MDP_RDMA5>;
+			mediatek,gce-client-reg = <&gce1 SUBSYS_1c10XXXX 0x9000 0x1000>;
+		};
+
+		vdo1_rdma6: vdo1_rdma@1c10a000 {
+			compatible = "mediatek,mt8195-vdo1-rdma";
+			reg = <0 0x1c10a000 0 0x1000>;
+			interrupts = <GIC_SPI 501 IRQ_TYPE_LEVEL_HIGH 0>;
+			clocks = <&vdosys1 CLK_VDO1_MDP_RDMA6>;
+			power-domains = <&spm MT8195_POWER_DOMAIN_VDOSYS1>;
+			iommus = <&iommu_vdo M4U_PORT_L2_MDP_RDMA6>;
+			mediatek,gce-client-reg = <&gce1 SUBSYS_1c10XXXX 0xa000 0x1000>;
+		};
+
+		vdo1_rdma7: vdo1_rdma@1c10b000 {
+			compatible = "mediatek,mt8195-vdo1-rdma";
+			reg = <0 0x1c10b000 0 0x1000>;
+			interrupts = <GIC_SPI 502 IRQ_TYPE_LEVEL_HIGH 0>;
+			clocks = <&vdosys1 CLK_VDO1_MDP_RDMA7>;
+			power-domains = <&spm MT8195_POWER_DOMAIN_VDOSYS1>;
+			iommus = <&iommu_vpp M4U_PORT_L3_MDP_RDMA7>;
+			mediatek,gce-client-reg = <&gce1 SUBSYS_1c10XXXX 0xb000 0x1000>;
+		};
+
+		merge1: disp_vpp_merge@1c10c000 {
+			compatible = "mediatek,mt8195-disp-merge";
+			reg = <0 0x1c10c000 0 0x1000>;
+			interrupts = <GIC_SPI 503 IRQ_TYPE_LEVEL_HIGH 0>;
+			clocks = <&vdosys1 CLK_VDO1_VPP_MERGE0>,
+				 <&vdosys1 CLK_VDO1_MERGE0_DL_ASYNC>;
+			clock-names = "merge","merge_async";
+			power-domains = <&spm MT8195_POWER_DOMAIN_VDOSYS1>;
+			mediatek,gce-client-reg = <&gce1 SUBSYS_1c10XXXX 0xc000 0x1000>;
+			mediatek,merge-mute = <1>;
+			resets = <&vdosys1 MT8195_VDOSYS1_SW0_RST_B_MERGE0_DL_ASYNC>;
+		};
+
+		merge2: disp_vpp_merge@1c10d000 {
+			compatible = "mediatek,mt8195-disp-merge";
+			reg = <0 0x1c10d000 0 0x1000>;
+			interrupts = <GIC_SPI 504 IRQ_TYPE_LEVEL_HIGH 0>;
+			clocks = <&vdosys1 CLK_VDO1_VPP_MERGE1>,
+				 <&vdosys1 CLK_VDO1_MERGE1_DL_ASYNC>;
+			clock-names = "merge","merge_async";
+			power-domains = <&spm MT8195_POWER_DOMAIN_VDOSYS1>;
+			mediatek,gce-client-reg = <&gce1 SUBSYS_1c10XXXX 0xd000 0x1000>;
+			mediatek,merge-mute = <1>;
+			resets = <&vdosys1 MT8195_VDOSYS1_SW0_RST_B_MERGE1_DL_ASYNC>;
+		};
+
+		merge3: disp_vpp_merge@1c10e000 {
+			compatible = "mediatek,mt8195-disp-merge";
+			reg = <0 0x1c10e000 0 0x1000>;
+			interrupts = <GIC_SPI 505 IRQ_TYPE_LEVEL_HIGH 0>;
+			clocks = <&vdosys1 CLK_VDO1_VPP_MERGE2>,
+				 <&vdosys1 CLK_VDO1_MERGE2_DL_ASYNC>;
+			clock-names = "merge","merge_async";
+			power-domains = <&spm MT8195_POWER_DOMAIN_VDOSYS1>;
+			mediatek,gce-client-reg = <&gce1 SUBSYS_1c10XXXX 0xe000 0x1000>;
+			mediatek,merge-mute = <1>;
+			resets = <&vdosys1 MT8195_VDOSYS1_SW0_RST_B_MERGE2_DL_ASYNC>;
+		};
+
+		merge4: disp_vpp_merge@1c10f000 {
+			compatible = "mediatek,mt8195-disp-merge";
+			reg = <0 0x1c10f000 0 0x1000>;
+			interrupts = <GIC_SPI 506 IRQ_TYPE_LEVEL_HIGH 0>;
+			clocks = <&vdosys1 CLK_VDO1_VPP_MERGE3>,
+				 <&vdosys1 CLK_VDO1_MERGE3_DL_ASYNC>;
+			clock-names = "merge","merge_async";
+			power-domains = <&spm MT8195_POWER_DOMAIN_VDOSYS1>;
+			mediatek,gce-client-reg = <&gce1 SUBSYS_1c10XXXX 0xf000 0x1000>;
+			mediatek,merge-mute = <1>;
+			resets = <&vdosys1 MT8195_VDOSYS1_SW0_RST_B_MERGE3_DL_ASYNC>;
+		};
+
+		merge5: disp_vpp_merge5@1c110000 {
+			compatible = "mediatek,mt8195-disp-merge";
+			reg = <0 0x1c110000 0 0x1000>;
+			interrupts = <GIC_SPI 507 IRQ_TYPE_LEVEL_HIGH 0>;
+			clocks = <&vdosys1 CLK_VDO1_VPP_MERGE4>,
+				 <&vdosys1 CLK_VDO1_MERGE4_DL_ASYNC>;
+			clock-names = "merge","merge_async";
+			power-domains = <&spm MT8195_POWER_DOMAIN_VDOSYS1>;
+			mediatek,gce-client-reg = <&gce1 SUBSYS_1c11XXXX 0x0000 0x1000>;
+			mediatek,merge-fifo-en = <1>;
+			resets = <&vdosys1 MT8195_VDOSYS1_SW0_RST_B_MERGE4_DL_ASYNC>;
+		};
+
+		disp_dpi1: disp_dpi1@1c112000 {
+			compatible = "mediatek,mt8195-dpi";
+			reg = <0 0x1c112000 0 0x1000>;
+			mediatek,vdosys1-dpi = <&vdosys1 0x0>;
+			interrupts = <GIC_SPI 512 IRQ_TYPE_LEVEL_HIGH 0>;
+			power-domains = <&spm MT8195_POWER_DOMAIN_VDOSYS1>;
+			clocks = <&vdosys1 CLK_VDO1_DPI1>,
+				 <&vdosys1 CLK_VDO1_DPI1_MM>;
+			clock-names = "pixel", "engine";
+			status = "disabled";
+		};
+
+		dp_intf1: dp_intf1@1c113000 {
+			compatible = "mediatek,mt8195-dpintf";
+			reg = <0 0x1c113000 0 0x1000>;
+			interrupts = <GIC_SPI 513 IRQ_TYPE_LEVEL_HIGH 0>;
+			power-domains = <&spm MT8195_POWER_DOMAIN_VDOSYS1>;
+			clocks = <&vdosys1 CLK_VDO1_DP_INTF0_MM>,
+				 <&vdosys1 CLK_VDO1_DPINTF>,
+				 <&topckgen CLK_TOP_DP>,
+				 <&topckgen CLK_TOP_TVDPLL2_D2>,
+				 <&topckgen CLK_TOP_TVDPLL2_D4>,
+				 <&topckgen CLK_TOP_TVDPLL2_D8>,
+				 <&topckgen CLK_TOP_TVDPLL2_D16>,
+				 <&apmixedsys CLK_APMIXED_TVDPLL2>;
+			clock-names = "hf_fmm_ck",
+				      "hf_fdp_ck",
+				      "MUX_DP",
+				      "TVDPLL_D2",
+				      "TVDPLL_D4",
+				      "TVDPLL_D8",
+				      "TVDPLL_D16",
+				      "DPI_CK";
+			status = "disabled";
+		};
+
+		disp_ethdr@1c114000 {
+			compatible = "mediatek,mt8195-disp-ethdr";
+			reg = <0 0x1c114000 0 0x1000>,
+			      <0 0x1c115000 0 0x1000>,
+			      <0 0x1c117000 0 0x1000>,
+			      <0 0x1c119000 0 0x1000>,
+			      <0 0x1c11A000 0 0x1000>,
+			      <0 0x1c11B000 0 0x1000>,
+			      <0 0x1c11C000 0 0x1000>;
+			reg-names = "mixer", "vdo_fe0", "vdo_fe1", "gfx_fe0", "gfx_fe1",
+				    "vdo_be", "adl_ds";
+			mediatek,gce-client-reg = <&gce1 SUBSYS_1c11XXXX 0x4000 0x1000>,
+						  <&gce1 SUBSYS_1c11XXXX 0x5000 0x1000>,
+						  <&gce1 SUBSYS_1c11XXXX 0x7000 0x1000>,
+						  <&gce1 SUBSYS_1c11XXXX 0x9000 0x1000>,
+						  <&gce1 SUBSYS_1c11XXXX 0xA000 0x1000>,
+						  <&gce1 SUBSYS_1c11XXXX 0xB000 0x1000>,
+						  <&gce1 SUBSYS_1c11XXXX 0xC000 0x1000>;
+			clocks = <&vdosys1 CLK_VDO1_DISP_MIXER>,
+				 <&vdosys1 CLK_VDO1_HDR_VDO_FE0>,
+				 <&vdosys1 CLK_VDO1_HDR_VDO_FE1>,
+				 <&vdosys1 CLK_VDO1_HDR_GFX_FE0>,
+				 <&vdosys1 CLK_VDO1_HDR_GFX_FE1>,
+				 <&vdosys1 CLK_VDO1_HDR_VDO_BE>,
+				 <&vdosys1 CLK_VDO1_26M_SLOW>,
+				 <&vdosys1 CLK_VDO1_HDR_VDO_FE0_DL_ASYNC>,
+				 <&vdosys1 CLK_VDO1_HDR_VDO_FE1_DL_ASYNC>,
+				 <&vdosys1 CLK_VDO1_HDR_GFX_FE0_DL_ASYNC>,
+				 <&vdosys1 CLK_VDO1_HDR_GFX_FE1_DL_ASYNC>,
+				 <&vdosys1 CLK_VDO1_HDR_VDO_BE_DL_ASYNC>,
+				 <&topckgen CLK_TOP_ETHDR>;
+			clock-names = "mixer", "vdo_fe0", "vdo_fe1", "gfx_fe0", "gfx_fe1",
+				      "vdo_be", "adl_ds", "vdo_fe0_async", "vdo_fe1_async",
+				      "gfx_fe0_async", "gfx_fe1_async","vdo_be_async",
+				      "ethdr_top";
+			power-domains = <&spm MT8195_POWER_DOMAIN_VDOSYS1>;
+			iommus = <&iommu_vpp M4U_PORT_L3_HDR_DS>,
+				 <&iommu_vpp M4U_PORT_L3_HDR_ADL>;
+			interrupts = <GIC_SPI 517 IRQ_TYPE_LEVEL_HIGH 0>; /* disp mixer */
+			resets = <&vdosys1 MT8195_VDOSYS1_SW1_RST_B_HDR_VDO_FE0_DL_ASYNC>,
+				 <&vdosys1 MT8195_VDOSYS1_SW1_RST_B_HDR_VDO_FE1_DL_ASYNC>,
+				 <&vdosys1 MT8195_VDOSYS1_SW1_RST_B_HDR_GFX_FE0_DL_ASYNC>,
+				 <&vdosys1 MT8195_VDOSYS1_SW1_RST_B_HDR_GFX_FE1_DL_ASYNC>,
+				 <&vdosys1 MT8195_VDOSYS1_SW1_RST_B_HDR_VDO_BE_DL_ASYNC>;
+		};
+
+		hdmi0: hdmi@1c300000 {
+			compatible = "mediatek,mt8195-hdmi";
+			reg = <0 0x1c300000 0 0x1000>;
+			power-domains = <&spm MT8195_POWER_DOMAIN_HDMI_TX>;
+			clocks = <&topckgen CLK_TOP_UNIVPLL_D6_D4>,
+				 <&topckgen CLK_TOP_MSDCPLL_D2>,
+				 <&topckgen CLK_TOP_HDMI_APB>,
+				 <&topckgen CLK_TOP_UNIVPLL_D4_D8>,
+				 <&topckgen CLK_TOP_HDCP>,
+				 <&topckgen CLK_TOP_HDCP_24M>,
+				 <&vppsys1 CLK_VPP1_VPP_SPLIT_HDMI>;
+			clock-names = "univpll_d6_d4",
+				      "msdcpll_d2",
+				      "hdmi_apb_sel",
+				      "univpll_d4_d8",
+				      "hdcp_sel",
+				      "hdcp24_sel",
+				      "split_hdmi";
+			interrupts = <GIC_SPI 677 IRQ_TYPE_LEVEL_HIGH 0>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&hdmi_pin>;
+			phys = <&hdmi_phy>;
+			phy-names = "hdmi";
+			cec = <&cec>;
+			ddc-i2c-bus = <&hdmiddc0>;
+			status = "disabled";
+		};
+
+		edp_tx: edp_tx@1c500000 {
+			status = "disabled";
+			compatible = "mediatek,mt8195-edp_tx";
+			reg = <0 0x1c500000 0 0x8000>;
+			power-domains = <&spm MT8195_POWER_DOMAIN_EPD_TX>;
+			interrupts = <GIC_SPI 676 IRQ_TYPE_LEVEL_HIGH 0>;
+		};
+
+		dp_tx: dp_tx@1c600000 {
+			compatible = "mediatek,mt8195-dp_tx";
+			reg = <0 0x1c600000 0 0x8000>;
+			power-domains = <&spm MT8195_POWER_DOMAIN_DP_TX>;
+			interrupts = <GIC_SPI 458 IRQ_TYPE_LEVEL_HIGH 0>;
+			status = "disabled";
+		};
+	};
+
+	hdmiddc0: ddc_i2c {
+		compatible = "mediatek,mt8195-hdmi-ddc";
+		clocks = <&clk26m>;
+		clock-names = "ddc-i2c";
+	};
+
+	sound: mt8195-sound {
+		mediatek,platform = <&afe>;
+		status = "disabled";
+	};
+
+	thermal_zones: thermal-zones {
+		soc_max {
+			polling-delay = <1000>; /* milliseconds */
+			polling-delay-passive = <100>; /* milliseconds */
+			thermal-sensors = <&lvts 0>;
+			sustainable-power = <4000>;
+
+			trips {
+				threshold: trip-point@0 {
+					temperature = <68000>;
+					hysteresis = <2000>;
+					type = "passive";
+				};
+
+				target: target@1 {
+					temperature = <90000>;
+					hysteresis = <2000>;
+					type = "passive";
+				};
+
+				soc_max_crit: soc_max_crit@0 {
+					temperature = <115000>;
+					hysteresis = <2000>;
+					type = "critical";
+				};
+			};
+			cooling-maps {
+				map0 {
+					trip = <&target>;
+					cooling-device = <&cpu0
+						THERMAL_NO_LIMIT
+						THERMAL_NO_LIMIT>,
+								<&cpu1
+						THERMAL_NO_LIMIT
+						THERMAL_NO_LIMIT>,
+								<&cpu2
+						THERMAL_NO_LIMIT
+						THERMAL_NO_LIMIT>,
+								<&cpu3
+						THERMAL_NO_LIMIT
+						THERMAL_NO_LIMIT>;
+					contribution = <3072>;
+				};
+				map1 {
+					trip = <&target>;
+					cooling-device = <&cpu4
+						THERMAL_NO_LIMIT
+						THERMAL_NO_LIMIT>,
+								<&cpu5
+						THERMAL_NO_LIMIT
+						THERMAL_NO_LIMIT>,
+								<&cpu6
+						THERMAL_NO_LIMIT
+						THERMAL_NO_LIMIT>,
+								<&cpu7
+						THERMAL_NO_LIMIT
+						THERMAL_NO_LIMIT>;
+					contribution = <1024>;
+				};
+			};
+		};
+		cpu_big1 {
+			polling-delay = <0>; /* milliseconds */
+			polling-delay-passive = <0>; /* milliseconds */
+			thermal-sensors = <&lvts 1>;
+		};
+		cpu_big2 {
+			polling-delay = <0>; /* milliseconds */
+			polling-delay-passive = <0>; /* milliseconds */
+			thermal-sensors = <&lvts 2>;
+		};
+		cpu_big3 {
+			polling-delay = <0>; /* milliseconds */
+			polling-delay-passive = <0>; /* milliseconds */
+			thermal-sensors = <&lvts 3>;
+		};
+		cpu_big4 {
+			polling-delay = <0>; /* milliseconds */
+			polling-delay-passive = <0>; /* milliseconds */
+			thermal-sensors = <&lvts 4>;
+		};
+		cpu_little1{
+			polling-delay = <0>; /* milliseconds */
+			polling-delay-passive = <0>; /* milliseconds */
+			thermal-sensors = <&lvts 5>;
+		};
+		cpu_little2 {
+			polling-delay = <0>; /* milliseconds */
+			polling-delay-passive = <0>; /* milliseconds */
+			thermal-sensors = <&lvts 6>;
+		};
+		cpu_little3 {
+			polling-delay = <0>; /* milliseconds */
+			polling-delay-passive = <0>; /* milliseconds */
+			thermal-sensors = <&lvts 7>;
+		};
+		cpu_little4 {
+			polling-delay = <0>; /* milliseconds */
+			polling-delay-passive = <0>; /* milliseconds */
+			thermal-sensors = <&lvts 8>;
+		};
+		vpu1 {
+			polling-delay = <0>; /* milliseconds */
+			polling-delay-passive = <0>; /* milliseconds */
+			thermal-sensors = <&lvts 9>;
+		};
+		vpu2 {
+			polling-delay = <0>; /* milliseconds */
+			polling-delay-passive = <0>; /* milliseconds */
+			thermal-sensors = <&lvts 10>;
+		};
+		gpu1 {
+			polling-delay = <0>; /* milliseconds */
+			polling-delay-passive = <0>; /* milliseconds */
+			thermal-sensors = <&lvts 11>;
+		};
+		gpu2 {
+			polling-delay = <0>; /* milliseconds */
+			polling-delay-passive = <0>; /* milliseconds */
+			thermal-sensors = <&lvts 12>;
+		};
+		vdec {
+			polling-delay = <0>; /* milliseconds */
+			polling-delay-passive = <0>; /* milliseconds */
+			thermal-sensors = <&lvts 13>;
+		};
+		img {
+			polling-delay = <0>; /* milliseconds */
+			polling-delay-passive = <0>; /* milliseconds */
+			thermal-sensors = <&lvts 14>;
+		};
+		infra {
+			polling-delay = <0>; /* milliseconds */
+			polling-delay-passive = <0>; /* milliseconds */
+			thermal-sensors = <&lvts 15>;
+		};
+		cam1 {
+			polling-delay = <0>; /* milliseconds */
+			polling-delay-passive = <0>; /* milliseconds */
+			thermal-sensors = <&lvts 16>;
+		};
+		cam2 {
+			polling-delay = <0>; /* milliseconds */
+			polling-delay-passive = <0>; /* milliseconds */
+			thermal-sensors = <&lvts 17>;
+		};
+	};
+
+	bring-up {
+		compatible = "mediatek,clk-bring-up";
+		clocks = <&infracfg_ao CLK_INFRA_AO_UART0>;
+	};
+};
diff --git a/arch/arm64/configs/defconfig b/arch/arm64/configs/defconfig
index 5cfe3cf6f2acb2db8020bbf8821aba0a9c787538..b806aa771c3e5579998ef99cb0752a41524f6bfd 100644
--- a/arch/arm64/configs/defconfig
+++ b/arch/arm64/configs/defconfig
@@ -916,6 +916,7 @@ CONFIG_TEGRA_IOMMU_SMMU=y
 CONFIG_ARM_SMMU=y
 CONFIG_ARM_SMMU_V3=y
 CONFIG_QCOM_IOMMU=y
+CONFIG_MTK_IOMMU=y
 CONFIG_REMOTEPROC=y
 CONFIG_QCOM_Q6V5_MSS=m
 CONFIG_QCOM_Q6V5_PAS=m
@@ -1092,3 +1093,4 @@ CONFIG_DEBUG_KERNEL=y
 # CONFIG_DEBUG_PREEMPT is not set
 # CONFIG_FTRACE is not set
 CONFIG_MEMTEST=y
+CONFIG_RESET_TI_SYSCON=y
diff --git a/chromeos/config/arm64/chromiumos-arm64.flavour.config b/chromeos/config/arm64/chromiumos-arm64.flavour.config
index afaa5a6f1430049c9a6fa2426d9b80bb9c5790e0..f8d60ae7cbedff199cfe47724c2c0c55b3319be1 100644
--- a/chromeos/config/arm64/chromiumos-arm64.flavour.config
+++ b/chromeos/config/arm64/chromiumos-arm64.flavour.config
@@ -6,7 +6,7 @@ CONFIG_ARCH_MEDIATEK=y
 CONFIG_ARCH_QCOM=y
 CONFIG_ARCH_ROCKCHIP=y
 CONFIG_ARM_MEDIATEK_CPUFREQ=y
-CONFIG_ARM_MT8183_CCI_DEVFREQ=m
+CONFIG_ARM_MEDIATEK_CPUFREQ_HW=y
 CONFIG_ARM_PSCI_CPUIDLE=y
 CONFIG_ARM_QCOM_CPUFREQ_HW=y
 CONFIG_ARM_SMMU=y
@@ -21,6 +21,7 @@ CONFIG_ATH11K_DEBUG=y
 CONFIG_ATH11K_DEBUGFS=y
 CONFIG_ATH11K_TRACING=y
 CONFIG_BACKLIGHT_GPIO=y
+CONFIG_BLK_DEV_NVME=y
 CONFIG_BT_HCIBTUSB_MTK=y
 CONFIG_BT_HCIUART_QCA=y
 CONFIG_BT_HCIUART_RTL=y
@@ -39,6 +40,22 @@ CONFIG_COMMON_CLK_MT8183_MFGCFG=y
 CONFIG_COMMON_CLK_MT8183_MMSYS=y
 CONFIG_COMMON_CLK_MT8183_VDECSYS=y
 CONFIG_COMMON_CLK_MT8183_VENCSYS=y
+CONFIG_COMMON_CLK_MT8195_APUSYS_PLL=y
+CONFIG_COMMON_CLK_MT8195_CAMSYS=y
+CONFIG_COMMON_CLK_MT8195_CCUSYS=y
+CONFIG_COMMON_CLK_MT8195_IMGSYS=y
+CONFIG_COMMON_CLK_MT8195_IMP_IIC_WRAP=y
+CONFIG_COMMON_CLK_MT8195_IPESYS=y
+CONFIG_COMMON_CLK_MT8195_MFGCFG=y
+CONFIG_COMMON_CLK_MT8195_NNASYS=y
+CONFIG_COMMON_CLK_MT8195_SCP_ADSP=y
+CONFIG_COMMON_CLK_MT8195_VDECSYS=y
+CONFIG_COMMON_CLK_MT8195_VDOSYS0=y
+CONFIG_COMMON_CLK_MT8195_VDOSYS1=y
+CONFIG_COMMON_CLK_MT8195_VENCSYS=y
+CONFIG_COMMON_CLK_MT8195_VPPSYS0=y
+CONFIG_COMMON_CLK_MT8195_VPPSYS1=y
+CONFIG_COMMON_CLK_MT8195_WPESYS=y
 CONFIG_COMMON_CLK_PALMAS=y
 CONFIG_COMMON_CLK_QCOM=y
 CONFIG_COMMON_CLK_RK808=y
@@ -48,16 +65,19 @@ CONFIG_CORESIGHT_CPU_DEBUG_DEFAULT_ON=y
 CONFIG_CORESIGHT_LINK_AND_SINK_TMC=y
 CONFIG_CORESIGHT_SOURCE_ETM4X=y
 CONFIG_CPUFREQ_DT=y
+CONFIG_CPU_THERMAL=y
 CONFIG_CROS_EC_MKBP_PROXIMITY=m
 CONFIG_CROS_EC_RPMSG=m
 CONFIG_CRYPTO_DEV_VIRTIO=m
 CONFIG_CRYPTO_MICHAEL_MIC=y
 CONFIG_DEVFREQ_GOV_PASSIVE=y
+CONFIG_DEVFREQ_THERMAL=y
 CONFIG_DRM_ANALOGIX_ANX7625=y
 CONFIG_DRM_ANALOGIX_ANX78XX=y
 CONFIG_DRM_ITE_IT6505=y
 CONFIG_DRM_MEDIATEK=y
 CONFIG_DRM_MEDIATEK_HDMI=y
+CONFIG_DRM_MEDIATEK_HDMI_SUSPEND_LOW_POWER=y
 CONFIG_DRM_MSM=y
 # CONFIG_DRM_MSM_HDMI_HDCP is not set
 CONFIG_DRM_PANEL_BOE_TV101WUM_NL6=y
@@ -99,6 +119,7 @@ CONFIG_INTERCONNECT_QCOM_SDM845=y
 CONFIG_LEDS_PWM=y
 CONFIG_MEDIATEK_MT6577_AUXADC=y
 CONFIG_MEDIATEK_WATCHDOG=y
+CONFIG_MFD_MT6360=y
 CONFIG_MFD_MT6397=y
 CONFIG_MFD_PALMAS=y
 CONFIG_MFD_RK808=y
@@ -114,13 +135,17 @@ CONFIG_MTK_CMDQ=y
 CONFIG_MTK_EFUSE=y
 CONFIG_MTK_IOMMU=y
 CONFIG_MTK_PMIC_WRAP=y
+CONFIG_MTK_SCP=m
 CONFIG_MTK_SENINF=m
+CONFIG_MTK_SOC_THERMAL_LVTS=y
 CONFIG_MTK_SVS=y
+CONFIG_MTK_THERMAL=y
 CONFIG_MWIFIEX_PCIE=m
 CONFIG_MWIFIEX_SDIO=m
 CONFIG_PCIEAER=y
 CONFIG_PCIEASPM_POWERSAVE=y
-CONFIG_PCIE_MEDIATEK=y
+CONFIG_PCIE_MEDIATEK_GEN3=y
+CONFIG_PHY_MTK_PCIE=y
 CONFIG_PCIE_QCOM=y
 CONFIG_PCIE_ROCKCHIP_HOST=y
 CONFIG_PHY_MTK_TPHY=y
@@ -179,7 +204,10 @@ CONFIG_REGULATOR_CROS_EC=y
 CONFIG_REGULATOR_DA9211=y
 CONFIG_REGULATOR_MAX8973=y
 CONFIG_REGULATOR_MT6311=y
+CONFIG_REGULATOR_MT6315=y
 CONFIG_REGULATOR_MT6358=y
+CONFIG_REGULATOR_MT6359=y
+CONFIG_REGULATOR_MT6360=y
 CONFIG_REGULATOR_MT6397=y
 CONFIG_REGULATOR_PALMAS=y
 CONFIG_REGULATOR_QCOM_RPMH=y
@@ -248,6 +276,9 @@ CONFIG_SND_SOC_MT8183_DA7219_MAX98357A=y
 CONFIG_SND_SOC_MT8183_MT6358_TS3A227E_MAX98357A=y
 CONFIG_SND_SOC_MT8192=y
 CONFIG_SND_SOC_MT8192_MT6359_RT1015_RT5682=y
+CONFIG_SND_SOC_MT8195=y
+CONFIG_SND_SOC_MT8195_MT6359_RT1011_RT5682=y
+CONFIG_SND_SOC_MT8195_MT6359_RT1019_RT5682=y
 CONFIG_SND_SOC_QCOM=y
 CONFIG_SND_SOC_RK3399_GRU_SOUND=y
 CONFIG_SND_SOC_ROCKCHIP=y
@@ -262,11 +293,14 @@ CONFIG_SPI_QCOM_GENI=y
 CONFIG_SPI_QCOM_QSPI=y
 CONFIG_SPI_ROCKCHIP=y
 CONFIG_SPMI=y
+CONFIG_SPMI_MTK_PMIF=y
 CONFIG_STAGING_MEDIA=y
 CONFIG_STMMAC_ETH=m
 CONFIG_SX9310=m
 CONFIG_TCG_CR50_I2C=y
 CONFIG_TCG_TIS_I2C_INFINEON=y
+CONFIG_THERMAL=y
+CONFIG_THERMAL_WRITABLE_TRIPS=y
 CONFIG_TOUCHSCREEN_MELFAS_MIP4=y
 CONFIG_TYPEC=m
 CONFIG_USB_MTU3=y
@@ -292,3 +326,4 @@ CONFIG_VIRTIO_CONSOLE=y
 CONFIG_VIRTIO_INPUT=y
 CONFIG_VIRTIO_MMIO=y
 CONFIG_VIRTIO_NET=y
+CONFIG_PINCTRL_MT8195=y
diff --git a/chromeos/config/arm64/chromiumos-mediatek.flavour.config b/chromeos/config/arm64/chromiumos-mediatek.flavour.config
index 92646dd2f032f91f32d03ab53b3d440267a8abda..afd953671242035106f2a77721ac0ed55854a984 100644
--- a/chromeos/config/arm64/chromiumos-mediatek.flavour.config
+++ b/chromeos/config/arm64/chromiumos-mediatek.flavour.config
@@ -3,15 +3,18 @@
 #
 CONFIG_ARCH_MEDIATEK=y
 CONFIG_ARM_MEDIATEK_CPUFREQ=y
-CONFIG_ARM_MT8183_CCI_DEVFREQ=m
+CONFIG_ARM_MEDIATEK_CPUFREQ_HW=y
 CONFIG_ARM_PSCI_CPUIDLE=y
 CONFIG_ATH10K_DEBUG=y
 CONFIG_ATH10K_DEBUGFS=y
 CONFIG_ATH10K_SDIO=m
 CONFIG_ATH10K_TRACING=y
+CONFIG_BLK_DEV_NVME=y
 CONFIG_BT_HCIBTUSB_MTK=y
 CONFIG_BT_HCIUART_QCA=y
 CONFIG_BT_HCIUART_RTL=y
+CONFIG_MTK_DBGTOP=y
+CONFIG_MTK_PLATFORM="mt8195"
 # CONFIG_COMMON_CLK_MT2712 is not set
 # CONFIG_COMMON_CLK_MT6797 is not set
 CONFIG_COMMON_CLK_MT8183_AUDIOSYS=y
@@ -25,14 +28,33 @@ CONFIG_COMMON_CLK_MT8183_MFGCFG=y
 CONFIG_COMMON_CLK_MT8183_MMSYS=y
 CONFIG_COMMON_CLK_MT8183_VDECSYS=y
 CONFIG_COMMON_CLK_MT8183_VENCSYS=y
+CONFIG_COMMON_CLK_MT8195_APUSYS_PLL=y
+CONFIG_COMMON_CLK_MT8195_CAMSYS=y
+CONFIG_COMMON_CLK_MT8195_CCUSYS=y
+CONFIG_COMMON_CLK_MT8195_IMGSYS=y
+CONFIG_COMMON_CLK_MT8195_IMP_IIC_WRAP=y
+CONFIG_COMMON_CLK_MT8195_IPESYS=y
+CONFIG_COMMON_CLK_MT8195_MFGCFG=y
+CONFIG_COMMON_CLK_MT8195_NNASYS=y
+CONFIG_COMMON_CLK_MT8195_SCP_ADSP=y
+CONFIG_COMMON_CLK_MT8195_VDECSYS=y
+CONFIG_COMMON_CLK_MT8195_VDOSYS0=y
+CONFIG_COMMON_CLK_MT8195_VDOSYS1=y
+CONFIG_COMMON_CLK_MT8195_VENCSYS=y
+CONFIG_COMMON_CLK_MT8195_VPPSYS0=y
+CONFIG_COMMON_CLK_MT8195_VPPSYS1=y
+CONFIG_COMMON_CLK_MT8195_WPESYS=y
+CONFIG_CPU_THERMAL=y
 CONFIG_CROS_EC_RPMSG=m
 CONFIG_DEVFREQ_GOV_PASSIVE=y
 CONFIG_DEVFREQ_GOV_SIMPLE_ONDEMAND=y
+CONFIG_DEVFREQ_THERMAL=y
 CONFIG_DRM_ANALOGIX_ANX7625=y
 CONFIG_DRM_ANALOGIX_ANX78XX=y
 CONFIG_DRM_ITE_IT6505=y
 CONFIG_DRM_MEDIATEK=y
 CONFIG_DRM_MEDIATEK_HDMI=y
+CONFIG_DRM_MEDIATEK_HDMI_SUSPEND_LOW_POWER=y
 CONFIG_DRM_PANEL_BOE_TV101WUM_NL6=y
 CONFIG_DRM_PANEL_INNOLUX_HIMAX8279D=y
 CONFIG_DRM_PANEL_INNOLUX_P079ZCA=y
@@ -51,6 +73,7 @@ CONFIG_MALI_VALHALL_EXPERT=y
 CONFIG_MALI_VALHALL_PLATFORM_NAME="mediatek"
 CONFIG_MEDIATEK_MT6577_AUXADC=y
 CONFIG_MEDIATEK_WATCHDOG=y
+CONFIG_MFD_MT6360=y
 CONFIG_MFD_MT6397=y
 CONFIG_MMC_MTK=y
 CONFIG_MT7921E=m
@@ -58,11 +81,16 @@ CONFIG_MTK_CMDQ=y
 CONFIG_MTK_EFUSE=y
 CONFIG_MTK_IOMMU=y
 CONFIG_MTK_PMIC_WRAP=y
+CONFIG_MTK_SCP=m
 CONFIG_MTK_SENINF=m
+CONFIG_MTK_SOC_THERMAL_LVTS=y
 CONFIG_MTK_SVS=y
+CONFIG_MTK_THERMAL=y
+CONFIG_PCI=y
 CONFIG_PCIEAER=y
-CONFIG_PCIEASPM_POWERSAVE=y
-CONFIG_PCIE_MEDIATEK=y
+CONFIG_PCIEASPM_POWER_SUPERSAVE=y
+CONFIG_PCIE_MEDIATEK_GEN3=y
+CONFIG_PHY_MTK_PCIE=y
 CONFIG_PHY_MTK_TPHY=y
 # CONFIG_PINCTRL_MT2712 is not set
 # CONFIG_PINCTRL_MT7622 is not set
@@ -71,7 +99,10 @@ CONFIG_PM_DEVFREQ=y
 CONFIG_PWM_MTK_DISP=y
 CONFIG_REGULATOR_CROS_EC=y
 CONFIG_REGULATOR_DA9211=y
+CONFIG_REGULATOR_MT6315=y
 CONFIG_REGULATOR_MT6358=y
+CONFIG_REGULATOR_MT6359=y
+CONFIG_REGULATOR_MT6360=y
 CONFIG_REGULATOR_MT6397=y
 CONFIG_REMOTEPROC=y
 CONFIG_RESET_TI_SYSCON=y
@@ -98,12 +129,19 @@ CONFIG_SND_SOC_MT8183_DA7219_MAX98357A=y
 CONFIG_SND_SOC_MT8183_MT6358_TS3A227E_MAX98357A=y
 CONFIG_SND_SOC_MT8192=y
 CONFIG_SND_SOC_MT8192_MT6359_RT1015_RT5682=y
+CONFIG_SND_SOC_MT8195=y
+CONFIG_SND_SOC_MT8195_MT6359_RT1011_RT5682=y
+CONFIG_SND_SOC_MT8195_MT6359_RT1019_RT5682=y
 CONFIG_SPI_GPIO=y
 CONFIG_SPI_MT65XX=y
 CONFIG_SPI_MTK_NOR=y
+CONFIG_SPMI=y
+CONFIG_SPMI_MTK_PMIF=y
 CONFIG_STAGING_MEDIA=y
 CONFIG_TCG_CR50_I2C=y
 CONFIG_TCG_TIS_I2C_INFINEON=y
+CONFIG_THERMAL=y
+CONFIG_THERMAL_WRITABLE_TRIPS=y
 CONFIG_TMPFS=y
 CONFIG_USB_MTU3=y
 CONFIG_USB_MTU3_HOST=y
@@ -117,3 +155,5 @@ CONFIG_VIDEO_MEDIATEK_VCODEC=m
 CONFIG_VIDEO_OV02A10=m
 CONFIG_VIDEO_OV5695=m
 CONFIG_VIDEO_OV8856=m
+CONFIG_PINCTRL_MT8195=y
+CONFIG_MTK_DFD=y
diff --git a/chromeos/scripts/kernelconfig b/chromeos/scripts/kernelconfig
index 960449f01179a420238849ecfdff9cdde74bb0d9..ff74c1b0cd42a7dc6742fab248bb330f56bc5091 100755
--- a/chromeos/scripts/kernelconfig
+++ b/chromeos/scripts/kernelconfig
@@ -59,7 +59,7 @@ build_one() {
 		elif [[ "${arch}" == "x86_64" ]]; then
 			prefix=x86_64
 			compiler=clang
-			cross="${prefix}-cros-linux-gnu"
+			cross="${prefix}-pc-linux-gnu"
 		elif [[ "${arch}" == "armel" ]]; then
 			prefix=armv7a
 			compiler=clang
diff --git a/drivers/base/power/runtime.c b/drivers/base/power/runtime.c
index bc649da4899a0b873884226c40af571c6cfed8a2..aef716e3b2c1a6dc7082c37bb808c8f1c840d224 100644
--- a/drivers/base/power/runtime.c
+++ b/drivers/base/power/runtime.c
@@ -642,11 +642,12 @@ static int rpm_suspend(struct device *dev, int rpmflags)
 
 	callback = RPM_GET_CALLBACK(dev, runtime_suspend);
 
-	dev_pm_enable_wake_irq_check(dev, true);
+	//dev_pm_enable_wake_irq_check(dev, true);
 	retval = rpm_callback(callback, dev);
 	if (retval)
 		goto fail;
 
+	dev_pm_enable_wake_irq_check(dev, true);
  no_callback:
 	__update_runtime_status(dev, RPM_SUSPENDED);
 	pm_runtime_deactivate_timer(dev);
diff --git a/drivers/bluetooth/btusb.c b/drivers/bluetooth/btusb.c
index b2f5840edc75dcb3134f8ab23be2c1b85515c03e..f502a4a9d2bb31f46e0fc855d557eed3a6bfc632 100644
--- a/drivers/bluetooth/btusb.c
+++ b/drivers/bluetooth/btusb.c
@@ -2214,6 +2214,7 @@ static void btusb_mtk_wmt_recv(struct urb *urb)
 		skb = bt_skb_alloc(HCI_WMT_MAX_EVENT_SIZE, GFP_ATOMIC);
 		if (!skb) {
 			hdev->stat.err_rx++;
+			kfree(urb->setup_packet);
 			return;
 		}
 
@@ -2234,6 +2235,7 @@ static void btusb_mtk_wmt_recv(struct urb *urb)
 			data->evt_skb = skb_clone(skb, GFP_ATOMIC);
 			if (!data->evt_skb) {
 				kfree_skb(skb);
+				kfree(urb->setup_packet);
 				return;
 			}
 		}
@@ -2242,6 +2244,7 @@ static void btusb_mtk_wmt_recv(struct urb *urb)
 		if (err < 0) {
 			kfree_skb(data->evt_skb);
 			data->evt_skb = NULL;
+			kfree(urb->setup_packet);
 			return;
 		}
 
@@ -2252,6 +2255,7 @@ static void btusb_mtk_wmt_recv(struct urb *urb)
 			wake_up_bit(&data->flags,
 				    BTUSB_TX_WAIT_VND_EVT);
 		}
+		kfree(urb->setup_packet);
 		return;
 	} else if (urb->status == -ENOENT) {
 		/* Avoid suspend failed when usb_kill_urb */
@@ -2272,6 +2276,7 @@ static void btusb_mtk_wmt_recv(struct urb *urb)
 	usb_anchor_urb(urb, &data->ctrl_anchor);
 	err = usb_submit_urb(urb, GFP_ATOMIC);
 	if (err < 0) {
+		kfree(urb->setup_packet);
 		/* -EPERM: urb is being killed;
 		 * -ENODEV: device got disconnected
 		 */
@@ -2327,6 +2332,7 @@ static int btusb_mtk_submit_wmt_recv_urb(struct hci_dev *hdev)
 		if (err != -EPERM && err != -ENODEV)
 			bt_dev_err(hdev, "urb %p submission failed (%d)",
 				   urb, -err);
+		kfree(dr);
 		usb_unanchor_urb(urb);
 	}
 
@@ -2374,7 +2380,7 @@ static int btusb_mtk_hci_wmt_sync(struct hci_dev *hdev,
 	/* Submit control IN URB on demand to process the WMT event */
 	err = btusb_mtk_submit_wmt_recv_urb(hdev);
 	if (err < 0)
-		return err;
+		goto err_free_wc;
 
 	/* The vendor specific WMT commands are all answered by a vendor
 	 * specific event and will have the Command Status or Command
diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 2dc4d2306b74d53332856edb8f30062df46d8016..899defab2bd504349ee4c8103900ba2af04c4d07 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -1264,7 +1264,7 @@ static void __init clk_disable_unused_subtree(struct clk_core *core)
 static bool clk_ignore_unused __initdata;
 static int __init clk_ignore_unused_setup(char *__unused)
 {
-	clk_ignore_unused = true;
+	clk_ignore_unused = false;
 	return 1;
 }
 __setup("clk_ignore_unused", clk_ignore_unused_setup);
diff --git a/drivers/clk/mediatek/Kconfig b/drivers/clk/mediatek/Kconfig
index ce8475098b31c781d4d6ab220621368541bc07e2..d11a50b574ca97113d7cff58f3646bcc5186ddbd 100644
--- a/drivers/clk/mediatek/Kconfig
+++ b/drivers/clk/mediatek/Kconfig
@@ -489,6 +489,14 @@ config COMMON_CLK_MT8183_VENCSYS
 	help
 	  This driver supports MediaTek MT8183 vencsys clocks.
 
+config COMMON_CLK_MT8195
+        bool "Clock driver for MediaTek MT8195"
+        depends on ARM64 || COMPILE_TEST
+        select COMMON_CLK_MEDIATEK
+        default ARCH_MEDIATEK
+        help
+          This driver supports MediaTek MT8195 clocks.
+
 config COMMON_CLK_MT8516
 	bool "Clock driver for MediaTek MT8516"
 	depends on ARCH_MEDIATEK || COMPILE_TEST
diff --git a/drivers/clk/mediatek/Makefile b/drivers/clk/mediatek/Makefile
index 3b0c2be7382491e195186b75dacd6e72247085d4..989c8ddc56a4e28cf2c3314af9dcb6efcc0284ff 100644
--- a/drivers/clk/mediatek/Makefile
+++ b/drivers/clk/mediatek/Makefile
@@ -67,5 +67,15 @@ obj-$(CONFIG_COMMON_CLK_MT8183_MFGCFG) += clk-mt8183-mfgcfg.o
 obj-$(CONFIG_COMMON_CLK_MT8183_MMSYS) += clk-mt8183-mm.o
 obj-$(CONFIG_COMMON_CLK_MT8183_VDECSYS) += clk-mt8183-vdec.o
 obj-$(CONFIG_COMMON_CLK_MT8183_VENCSYS) += clk-mt8183-venc.o
+obj-$(CONFIG_COMMON_CLK_MT8195) += clk-mt8195-apmixedsys.o clk-mt8195-topckgen.o \
+				   clk-mt8195-peri_ao.o clk-mt8195-infra_ao.o \
+				   clk-mt8195-cam.o clk-mt8195-ccu.o clk-mt8195-img.o \
+				   clk-mt8195-ipe.o clk-mt8195-mfg.o clk-mt8195-scp_adsp.o \
+				   clk-mt8195-vdec.o clk-mt8195-vdo0.o clk-mt8195-vdo1.o \
+				   clk-mt8195-venc.o clk-mt8195-vpp0.o clk-mt8195-vpp1.o \
+				   clk-mt8195-wpe.o clk-mt8195-imp_iic_wrap.o \
+				   clk-mt8195-apusys_pll.o
+obj-$(CONFIG_COMMON_CLK_MT8195) += clk-bringup.o clkdbg.o clkdbg-mt8195.o clkchk.o \
+				   clkchk-mt8195.o
 obj-$(CONFIG_COMMON_CLK_MT8516) += clk-mt8516.o
 obj-$(CONFIG_COMMON_CLK_MT8516_AUDSYS) += clk-mt8516-aud.o
diff --git a/drivers/clk/mediatek/clk-bringup.c b/drivers/clk/mediatek/clk-bringup.c
new file mode 100644
index 0000000000000000000000000000000000000000..3f2ade5360f1a6d7b125f2380331125036d4efca
--- /dev/null
+++ b/drivers/clk/mediatek/clk-bringup.c
@@ -0,0 +1,72 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2020 MediaTek Inc.
+ */
+
+#include <linux/clk.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_platform.h>
+
+#define CLK_MAX_NUM 160
+
+static const struct of_device_id bring_up_id_table[] = {
+	{ .compatible = "mediatek,clk-bring-up",},
+	{ },
+};
+MODULE_DEVICE_TABLE(of, bring_up_id_table);
+
+static int bring_up_probe(struct platform_device *pdev)
+{
+	struct clk *clk_list[CLK_MAX_NUM];
+	int clk_con, i;
+	long ret;
+
+	clk_con = of_count_phandle_with_args(pdev->dev.of_node, "clocks",
+			"#clock-cells");
+
+	for (i = 0; i < clk_con; i++) {
+		clk_list[i] = of_clk_get(pdev->dev.of_node, i);
+		if (IS_ERR(clk_list[i])) {
+			ret = PTR_ERR(clk_list[i]);
+
+			if (ret == -EPROBE_DEFER)
+				pr_err("clk %d is not ready\n", i);
+			else
+				pr_err("get clk %d fail, ret=%d, clk_con=%d\n",
+				       i, (int)ret, clk_con);
+			i--;
+			goto failed;
+		}
+	}
+
+	for (i = 0; i < clk_con; i++)
+		clk_prepare_enable(clk_list[i]);
+
+	return 0;
+
+failed:
+	while (i > 0) {
+		clk_put(clk_list[i]);
+		i--;
+	}
+	return ret;
+}
+
+static int bring_up_remove(struct platform_device *pdev)
+{
+	return 0;
+}
+
+static struct platform_driver bring_up = {
+	.probe		= bring_up_probe,
+	.remove		= bring_up_remove,
+	.driver		= {
+		.name	= "bring_up",
+		.owner	= THIS_MODULE,
+		.of_match_table = bring_up_id_table,
+	},
+};
+
+module_platform_driver(bring_up);
diff --git a/drivers/clk/mediatek/clk-mt8195-apmixedsys.c b/drivers/clk/mediatek/clk-mt8195-apmixedsys.c
new file mode 100644
index 0000000000000000000000000000000000000000..6156ceeed71e6e9938ffb8f2d96d73629f55a1fd
--- /dev/null
+++ b/drivers/clk/mediatek/clk-mt8195-apmixedsys.c
@@ -0,0 +1,145 @@
+// SPDX-License-Identifier: GPL-2.0-only
+//
+// Copyright (c) 2021 MediaTek Inc.
+// Author: Chun-Jie Chen <chun-jie.chen@mediatek.com>
+
+#include "clk-gate.h"
+#include "clk-mtk.h"
+
+#include <dt-bindings/clock/mt8195-clk.h>
+#include <linux/of_device.h>
+#include <linux/platform_device.h>
+
+static const struct mtk_gate_regs apmixed_cg_regs = {
+	.set_ofs = 0x8,
+	.clr_ofs = 0x8,
+	.sta_ofs = 0x8,
+};
+
+#define GATE_APMIXED(_id, _name, _parent, _shift)			\
+	GATE_MTK(_id, _name, _parent, &apmixed_cg_regs, _shift, &mtk_clk_gate_ops_no_setclr_inv)
+
+static const struct mtk_gate apmixed_clks[] = {
+	GATE_APMIXED(CLK_APMIXED_PLL_SSUSB26M, "pll_ssusb26m", "clk26m", 1),
+};
+
+#define MT8195_PLL_FMAX		(3800UL * MHZ)
+#define MT8195_PLL_FMIN		(1500UL * MHZ)
+#define MT8195_INTEGER_BITS	8
+
+#define PLL(_id, _name, _reg, _pwr_reg, _en_mask, _flags,		\
+	    _rst_bar_mask, _pcwbits, _pd_reg, _pd_shift,		\
+	    _tuner_reg, _tuner_en_reg, _tuner_en_bit,			\
+	    _pcw_reg, _pcw_shift, _pcw_chg_reg,				\
+	    _en_reg, _pll_en_bit) {					\
+		.id = _id,						\
+		.name = _name,						\
+		.reg = _reg,						\
+		.pwr_reg = _pwr_reg,					\
+		.en_mask = _en_mask,					\
+		.flags = _flags,					\
+		.rst_bar_mask = _rst_bar_mask,				\
+		.fmax = MT8195_PLL_FMAX,				\
+		.fmin = MT8195_PLL_FMIN,				\
+		.pcwbits = _pcwbits,					\
+		.pcwibits = MT8195_INTEGER_BITS,			\
+		.pd_reg = _pd_reg,					\
+		.pd_shift = _pd_shift,					\
+		.tuner_reg = _tuner_reg,				\
+		.tuner_en_reg = _tuner_en_reg,				\
+		.tuner_en_bit = _tuner_en_bit,				\
+		.pcw_reg = _pcw_reg,					\
+		.pcw_shift = _pcw_shift,				\
+		.pcw_chg_reg = _pcw_chg_reg,				\
+		.en_reg = _en_reg,					\
+		.pll_en_bit = _pll_en_bit,				\
+	}
+
+static const struct mtk_pll_data plls[] = {
+	PLL(CLK_APMIXED_NNAPLL, "nnapll", 0x0390, 0x03a0, 0,
+	    0, 0, 22, 0x0398, 24, 0, 0, 0, 0x0398, 0, 0x0398, 0, 9),
+	PLL(CLK_APMIXED_RESPLL, "respll", 0x0190, 0x0320, 0,
+	    0, 0, 22, 0x0198, 24, 0, 0, 0, 0x0198, 0, 0x0198, 0, 9),
+	PLL(CLK_APMIXED_ETHPLL, "ethpll", 0x0360, 0x0370, 0,
+	    0, 0, 22, 0x0368, 24, 0, 0, 0, 0x0368, 0, 0x0368, 0, 9),
+	PLL(CLK_APMIXED_MSDCPLL, "msdcpll", 0x0710, 0x0720, 0,
+	    0, 0, 22, 0x0718, 24, 0, 0, 0, 0x0718, 0, 0x0718, 0, 9),
+	PLL(CLK_APMIXED_TVDPLL1, "tvdpll1", 0x00a0, 0x00b0, 0,
+	    0, 0, 22, 0x00a8, 24, 0, 0, 0, 0x00a8, 0, 0x00a8, 0, 9),
+	PLL(CLK_APMIXED_TVDPLL2, "tvdpll2", 0x00c0, 0x00d0, 0,
+	    0, 0, 22, 0x00c8, 24, 0, 0, 0, 0x00c8, 0, 0x00c8, 0, 9),
+	PLL(CLK_APMIXED_MMPLL, "mmpll", 0x00e0, 0x00f0, 0xff000000,
+	    HAVE_RST_BAR, BIT(23), 22, 0x00e8, 24, 0, 0, 0, 0x00e8, 0, 0x00e8, 0, 9),
+	PLL(CLK_APMIXED_MAINPLL, "mainpll", 0x01d0, 0x01e0, 0xff000000,
+	    HAVE_RST_BAR, BIT(23), 22, 0x01d8, 24, 0, 0, 0, 0x01d8, 0, 0x01d8, 0, 9),
+	PLL(CLK_APMIXED_VDECPLL, "vdecpll", 0x0890, 0x08a0, 0,
+	    0, 0, 22, 0x0898, 24, 0, 0, 0, 0x0898, 0, 0x0898, 0, 9),
+	PLL(CLK_APMIXED_IMGPLL, "imgpll", 0x0100, 0x0110, 0,
+	    0, 0, 22, 0x0108, 24, 0, 0, 0, 0x0108, 0, 0x0108, 0, 9),
+	PLL(CLK_APMIXED_UNIVPLL, "univpll", 0x01f0, 0x0700, 0xff000000,
+	    HAVE_RST_BAR, BIT(23), 22, 0x01f8, 24, 0, 0, 0, 0x01f8, 0, 0x01f8, 0, 9),
+	PLL(CLK_APMIXED_HDMIPLL1, "hdmipll1", 0x08c0, 0x08d0, 0,
+	    0, 0, 22, 0x08c8, 24, 0, 0, 0, 0x08c8, 0, 0x08c8, 0, 9),
+	PLL(CLK_APMIXED_HDMIPLL2, "hdmipll2", 0x0870, 0x0880, 0,
+	    0, 0, 22, 0x0878, 24, 0, 0, 0, 0x0878, 0, 0x0878, 0, 9),
+	PLL(CLK_APMIXED_HDMIRX_APLL, "hdmirx_apll", 0x08e0, 0x0dd4, 0,
+	    0, 0, 32, 0x08e8, 24, 0, 0, 0, 0x08ec, 0, 0x08e8, 0, 9),
+	PLL(CLK_APMIXED_USB1PLL, "usb1pll", 0x01a0, 0x01b0, 0,
+	    0, 0, 22, 0x01a8, 24, 0, 0, 0, 0x01a8, 0, 0x01a8, 0, 9),
+	PLL(CLK_APMIXED_ADSPPLL, "adsppll", 0x07e0, 0x07f0, 0,
+	    0, 0, 22, 0x07e8, 24, 0, 0, 0, 0x07e8, 0, 0x07e8, 0, 9),
+	PLL(CLK_APMIXED_APLL1, "apll1", 0x07c0, 0x0dc0, 0,
+	    0, 0, 32, 0x07c8, 24, 0x0470, 0x0000, 12, 0x07cc, 0, 0x07c8, 0, 9),
+	PLL(CLK_APMIXED_APLL2, "apll2", 0x0780, 0x0dc4, 0,
+	    0, 0, 32, 0x0788, 24, 0x0474, 0x0000, 13, 0x078c, 0, 0x0788, 0, 9),
+	PLL(CLK_APMIXED_APLL3, "apll3", 0x0760, 0x0dc8, 0,
+	    0, 0, 32, 0x0768, 24, 0x0478, 0x0000, 14, 0x076c, 0, 0x0768, 0, 9),
+	PLL(CLK_APMIXED_APLL4, "apll4", 0x0740, 0x0dcc, 0,
+	    0, 0, 32, 0x0748, 24, 0x047C, 0x0000, 15, 0x074c, 0, 0x0748, 0, 9),
+	PLL(CLK_APMIXED_APLL5, "apll5", 0x07a0, 0x0dd0, 0x100000,
+	    0, 0, 32, 0x07a8, 24, 0x0480, 0x0000, 16, 0x07ac, 0, 0x07a8, 0, 9),
+	PLL(CLK_APMIXED_MFGPLL, "mfgpll", 0x0340, 0x0350, 0,
+	    0, 0, 22, 0x0348, 24, 0, 0, 0, 0x0348, 0, 0x0348, 0, 9),
+	PLL(CLK_APMIXED_DGIPLL, "dgipll", 0x0150, 0x0160, 0,
+	    0, 0, 22, 0x0158, 24, 0, 0, 0, 0x0158, 0, 0x0158, 0, 9),
+};
+
+static const struct of_device_id of_match_clk_mt8195_apmixed[] = {
+	{ .compatible = "mediatek,mt8195-apmixedsys", },
+	{}
+};
+
+static int clk_mt8195_apmixed_probe(struct platform_device *pdev)
+{
+	struct clk_onecell_data *clk_data;
+	struct device_node *node = pdev->dev.of_node;
+	int r;
+
+	clk_data = mtk_alloc_clk_data(CLK_APMIXED_NR_CLK);
+	if (!clk_data)
+		return -ENOMEM;
+
+	mtk_clk_register_plls(node, plls, ARRAY_SIZE(plls), clk_data);
+	r = mtk_clk_register_gates(node, apmixed_clks, ARRAY_SIZE(apmixed_clks), clk_data);
+	if (r)
+		goto free_apmixed_data;
+
+	r = of_clk_add_provider(node, of_clk_src_onecell_get, clk_data);
+	if (r)
+		goto free_apmixed_data;
+
+	return r;
+
+free_apmixed_data:
+	mtk_free_clk_data(clk_data);
+	return r;
+}
+
+static struct platform_driver clk_mt8195_apmixed_drv = {
+	.probe = clk_mt8195_apmixed_probe,
+	.driver = {
+		.name = "clk-mt8195-apmixed",
+		.of_match_table = of_match_clk_mt8195_apmixed,
+	},
+};
+builtin_platform_driver(clk_mt8195_apmixed_drv);
diff --git a/drivers/clk/mediatek/clk-mt8195-apusys_pll.c b/drivers/clk/mediatek/clk-mt8195-apusys_pll.c
new file mode 100644
index 0000000000000000000000000000000000000000..f1c84186346e5c18ad81bdf6bc9692e14d02125c
--- /dev/null
+++ b/drivers/clk/mediatek/clk-mt8195-apusys_pll.c
@@ -0,0 +1,92 @@
+// SPDX-License-Identifier: GPL-2.0-only
+//
+// Copyright (c) 2021 MediaTek Inc.
+// Author: Chun-Jie Chen <chun-jie.chen@mediatek.com>
+
+#include "clk-mtk.h"
+
+#include <dt-bindings/clock/mt8195-clk.h>
+#include <linux/clk-provider.h>
+#include <linux/platform_device.h>
+
+#define MT8195_PLL_FMAX		(3800UL * MHZ)
+#define MT8195_PLL_FMIN		(1500UL * MHZ)
+#define MT8195_INTEGER_BITS	(8)
+#define MT8195_PCW_BITS		(22)
+#define MT8195_POSDIV_SHIFT	(24)
+#define MT8195_PLL_EN_BIT	(0)
+#define MT8195_PCW_SHIFT	(0)
+
+/*
+ * The "en_reg" and "pcw_chg_reg" fields are standard offset register compared
+ * with "reg" field, so set zero to imply it.
+ * No tuner control in apu pll, so set "tuner_XXX" as zero to imply it.
+ * No rst or post divider enable in apu pll, so set "rst_bar_mask" and "en_mask"
+ * as zero to imply it.
+ */
+#define PLL(_id, _name, _reg, _pwr_reg, _pd_reg, _pcw_reg) {		\
+		.id = _id,						\
+		.name = _name,						\
+		.reg = _reg,						\
+		.pwr_reg = _pwr_reg,					\
+		.en_mask = 0,						\
+		.flags = 0,						\
+		.rst_bar_mask = 0,					\
+		.fmax = MT8195_PLL_FMAX,				\
+		.fmin = MT8195_PLL_FMIN,				\
+		.pcwbits = MT8195_PCW_BITS,				\
+		.pcwibits = MT8195_INTEGER_BITS,			\
+		.pd_reg = _pd_reg,					\
+		.pd_shift = MT8195_POSDIV_SHIFT,			\
+		.tuner_reg = 0,						\
+		.tuner_en_reg = 0,					\
+		.tuner_en_bit = 0,					\
+		.pcw_reg = _pcw_reg,					\
+		.pcw_shift = MT8195_PCW_SHIFT,				\
+		.pcw_chg_reg = 0,					\
+		.en_reg = 0,						\
+		.pll_en_bit = MT8195_PLL_EN_BIT,			\
+	}
+
+static const struct mtk_pll_data apusys_plls[] = {
+	PLL(CLK_APUSYS_PLL_APUPLL, "apusys_pll_apupll", 0x008, 0x014, 0x00c, 0x00c),
+	PLL(CLK_APUSYS_PLL_NPUPLL, "apusys_pll_npupll", 0x018, 0x024, 0x01c, 0x01c),
+	PLL(CLK_APUSYS_PLL_APUPLL1, "apusys_pll_apupll1", 0x028, 0x034, 0x02c, 0x02c),
+	PLL(CLK_APUSYS_PLL_APUPLL2, "apusys_pll_apupll2", 0x038, 0x044, 0x03c, 0x03c),
+};
+
+static int clk_mt8195_apusys_pll_probe(struct platform_device *pdev)
+{
+	struct clk_onecell_data *clk_data;
+	struct device_node *node = pdev->dev.of_node;
+	int r;
+
+	clk_data = mtk_alloc_clk_data(CLK_APUSYS_PLL_NR_CLK);
+	if (!clk_data)
+		return -ENOMEM;
+
+	mtk_clk_register_plls(node, apusys_plls, ARRAY_SIZE(apusys_plls), clk_data);
+	r = of_clk_add_provider(node, of_clk_src_onecell_get, clk_data);
+	if (r)
+		goto free_apusys_pll_data;
+
+	return r;
+
+free_apusys_pll_data:
+	mtk_free_clk_data(clk_data);
+	return r;
+}
+
+static const struct of_device_id of_match_clk_mt8195_apusys_pll[] = {
+	{ .compatible = "mediatek,mt8195-apusys_pll", },
+	{}
+};
+
+static struct platform_driver clk_mt8195_apusys_pll_drv = {
+	.probe = clk_mt8195_apusys_pll_probe,
+	.driver = {
+		.name = "clk-mt8195-apusys_pll",
+		.of_match_table = of_match_clk_mt8195_apusys_pll,
+	},
+};
+builtin_platform_driver(clk_mt8195_apusys_pll_drv);
diff --git a/drivers/clk/mediatek/clk-mt8195-cam.c b/drivers/clk/mediatek/clk-mt8195-cam.c
new file mode 100644
index 0000000000000000000000000000000000000000..3d261fc3848e5e2296cd62336020547a6ca92753
--- /dev/null
+++ b/drivers/clk/mediatek/clk-mt8195-cam.c
@@ -0,0 +1,142 @@
+// SPDX-License-Identifier: GPL-2.0-only
+//
+// Copyright (c) 2021 MediaTek Inc.
+// Author: Chun-Jie Chen <chun-jie.chen@mediatek.com>
+
+#include "clk-gate.h"
+#include "clk-mtk.h"
+
+#include <dt-bindings/clock/mt8195-clk.h>
+#include <linux/clk-provider.h>
+#include <linux/platform_device.h>
+
+static const struct mtk_gate_regs cam_cg_regs = {
+	.set_ofs = 0x4,
+	.clr_ofs = 0x8,
+	.sta_ofs = 0x0,
+};
+
+#define GATE_CAM(_id, _name, _parent, _shift)			\
+	GATE_MTK(_id, _name, _parent, &cam_cg_regs, _shift, &mtk_clk_gate_ops_setclr)
+
+static const struct mtk_gate cam_clks[] = {
+	GATE_CAM(CLK_CAM_LARB13, "cam_larb13", "top_cam", 0),
+	GATE_CAM(CLK_CAM_LARB14, "cam_larb14", "top_cam", 1),
+	GATE_CAM(CLK_CAM_MAIN_CAM, "cam_main_cam", "top_cam", 3),
+	GATE_CAM(CLK_CAM_MAIN_CAMTG, "cam_main_camtg", "top_cam", 4),
+	GATE_CAM(CLK_CAM_SENINF, "cam_seninf", "top_cam", 5),
+	GATE_CAM(CLK_CAM_GCAMSVA, "cam_gcamsva", "top_cam", 6),
+	GATE_CAM(CLK_CAM_GCAMSVB, "cam_gcamsvb", "top_cam", 7),
+	GATE_CAM(CLK_CAM_GCAMSVC, "cam_gcamsvc", "top_cam", 8),
+	GATE_CAM(CLK_CAM_SCAMSA, "cam_scamsa", "top_cam", 9),
+	GATE_CAM(CLK_CAM_SCAMSB, "cam_scamsb", "top_cam", 10),
+	GATE_CAM(CLK_CAM_CAMSV_TOP, "cam_camsv_top", "top_cam", 11),
+	GATE_CAM(CLK_CAM_CAMSV_CQ, "cam_camsv_cq", "top_cam", 12),
+	GATE_CAM(CLK_CAM_ADL, "cam_adl", "top_cam", 16),
+	GATE_CAM(CLK_CAM_ASG, "cam_asg", "top_cam", 17),
+	GATE_CAM(CLK_CAM_PDA, "cam_pda", "top_cam", 18),
+	GATE_CAM(CLK_CAM_FAKE_ENG, "cam_fake_eng", "top_cam", 19),
+	GATE_CAM(CLK_CAM_MAIN_MRAW0, "cam_main_mraw0", "top_cam", 20),
+	GATE_CAM(CLK_CAM_MAIN_MRAW1, "cam_main_mraw1", "top_cam", 21),
+	GATE_CAM(CLK_CAM_MAIN_MRAW2, "cam_main_mraw2", "top_cam", 22),
+	GATE_CAM(CLK_CAM_MAIN_MRAW3, "cam_main_mraw3", "top_cam", 23),
+	GATE_CAM(CLK_CAM_CAM2MM0_GALS, "cam_cam2mm0_gals", "top_cam", 24),
+	GATE_CAM(CLK_CAM_CAM2MM1_GALS, "cam_cam2mm1_gals", "top_cam", 25),
+	GATE_CAM(CLK_CAM_CAM2SYS_GALS, "cam_cam2sys_gals", "top_cam", 26),
+};
+
+static const struct mtk_gate cam_mraw_clks[] = {
+	GATE_CAM(CLK_CAM_MRAW_LARBX, "cam_mraw_larbx", "top_cam", 0),
+	GATE_CAM(CLK_CAM_MRAW_CAMTG, "cam_mraw_camtg", "top_cam", 2),
+	GATE_CAM(CLK_CAM_MRAW_MRAW0, "cam_mraw_mraw0", "top_cam", 3),
+	GATE_CAM(CLK_CAM_MRAW_MRAW1, "cam_mraw_mraw1", "top_cam", 4),
+	GATE_CAM(CLK_CAM_MRAW_MRAW2, "cam_mraw_mraw2", "top_cam", 5),
+	GATE_CAM(CLK_CAM_MRAW_MRAW3, "cam_mraw_mraw3", "top_cam", 6),
+};
+
+static const struct mtk_gate cam_rawa_clks[] = {
+	GATE_CAM(CLK_CAM_RAWA_LARBX, "cam_rawa_larbx", "top_cam", 0),
+	GATE_CAM(CLK_CAM_RAWA_CAM, "cam_rawa_cam", "top_cam", 1),
+	GATE_CAM(CLK_CAM_RAWA_CAMTG, "cam_rawa_camtg", "top_cam", 2),
+};
+
+static const struct mtk_gate cam_rawb_clks[] = {
+	GATE_CAM(CLK_CAM_RAWB_LARBX, "cam_rawb_larbx", "top_cam", 0),
+	GATE_CAM(CLK_CAM_RAWB_CAM, "cam_rawb_cam", "top_cam", 1),
+	GATE_CAM(CLK_CAM_RAWB_CAMTG, "cam_rawb_camtg", "top_cam", 2),
+};
+
+static const struct mtk_gate cam_yuva_clks[] = {
+	GATE_CAM(CLK_CAM_YUVA_LARBX, "cam_yuva_larbx", "top_cam", 0),
+	GATE_CAM(CLK_CAM_YUVA_CAM, "cam_yuva_cam", "top_cam", 1),
+	GATE_CAM(CLK_CAM_YUVA_CAMTG, "cam_yuva_camtg", "top_cam", 2),
+};
+
+static const struct mtk_gate cam_yuvb_clks[] = {
+	GATE_CAM(CLK_CAM_YUVB_LARBX, "cam_yuvb_larbx", "top_cam", 0),
+	GATE_CAM(CLK_CAM_YUVB_CAM, "cam_yuvb_cam", "top_cam", 1),
+	GATE_CAM(CLK_CAM_YUVB_CAMTG, "cam_yuvb_camtg", "top_cam", 2),
+};
+
+static const struct mtk_clk_desc cam_desc = {
+	.clks = cam_clks,
+	.num_clks = ARRAY_SIZE(cam_clks),
+};
+
+static const struct mtk_clk_desc cam_mraw_desc = {
+	.clks = cam_mraw_clks,
+	.num_clks = ARRAY_SIZE(cam_mraw_clks),
+};
+
+static const struct mtk_clk_desc cam_rawa_desc = {
+	.clks = cam_rawa_clks,
+	.num_clks = ARRAY_SIZE(cam_rawa_clks),
+};
+
+static const struct mtk_clk_desc cam_rawb_desc = {
+	.clks = cam_rawb_clks,
+	.num_clks = ARRAY_SIZE(cam_rawb_clks),
+};
+
+static const struct mtk_clk_desc cam_yuva_desc = {
+	.clks = cam_yuva_clks,
+	.num_clks = ARRAY_SIZE(cam_yuva_clks),
+};
+
+static const struct mtk_clk_desc cam_yuvb_desc = {
+	.clks = cam_yuvb_clks,
+	.num_clks = ARRAY_SIZE(cam_yuvb_clks),
+};
+
+static const struct of_device_id of_match_clk_mt8195_cam[] = {
+	{
+		.compatible = "mediatek,mt8195-camsys",
+		.data = &cam_desc,
+	}, {
+		.compatible = "mediatek,mt8195-camsys_mraw",
+		.data = &cam_mraw_desc,
+	}, {
+		.compatible = "mediatek,mt8195-camsys_rawa",
+		.data = &cam_rawa_desc,
+	}, {
+		.compatible = "mediatek,mt8195-camsys_rawb",
+		.data = &cam_rawb_desc,
+	}, {
+		.compatible = "mediatek,mt8195-camsys_yuva",
+		.data = &cam_yuva_desc,
+	}, {
+		.compatible = "mediatek,mt8195-camsys_yuvb",
+		.data = &cam_yuvb_desc,
+	}, {
+		/* sentinel */
+	}
+};
+
+static struct platform_driver clk_mt8195_cam_drv = {
+	.probe = mtk_clk_simple_probe,
+	.driver = {
+		.name = "clk-mt8195-cam",
+		.of_match_table = of_match_clk_mt8195_cam,
+	},
+};
+builtin_platform_driver(clk_mt8195_cam_drv);
diff --git a/drivers/clk/mediatek/clk-mt8195-ccu.c b/drivers/clk/mediatek/clk-mt8195-ccu.c
new file mode 100644
index 0000000000000000000000000000000000000000..f846f1d736051f40a8e7ebc53d2b92da4ad6f912
--- /dev/null
+++ b/drivers/clk/mediatek/clk-mt8195-ccu.c
@@ -0,0 +1,50 @@
+// SPDX-License-Identifier: GPL-2.0-only
+//
+// Copyright (c) 2021 MediaTek Inc.
+// Author: Chun-Jie Chen <chun-jie.chen@mediatek.com>
+
+#include "clk-gate.h"
+#include "clk-mtk.h"
+
+#include <dt-bindings/clock/mt8195-clk.h>
+#include <linux/clk-provider.h>
+#include <linux/platform_device.h>
+
+static const struct mtk_gate_regs ccu_cg_regs = {
+	.set_ofs = 0x4,
+	.clr_ofs = 0x8,
+	.sta_ofs = 0x0,
+};
+
+#define GATE_CCU(_id, _name, _parent, _shift)			\
+	GATE_MTK(_id, _name, _parent, &ccu_cg_regs, _shift, &mtk_clk_gate_ops_setclr)
+
+static const struct mtk_gate ccu_clks[] = {
+	GATE_CCU(CLK_CCU_LARB18, "ccu_larb18", "top_ccu", 0),
+	GATE_CCU(CLK_CCU_AHB, "ccu_ahb", "top_ccu", 1),
+	GATE_CCU(CLK_CCU_CCU0, "ccu_ccu0", "top_ccu", 2),
+	GATE_CCU(CLK_CCU_CCU1, "ccu_ccu1", "top_ccu", 3),
+};
+
+static const struct mtk_clk_desc ccu_desc = {
+	.clks = ccu_clks,
+	.num_clks = ARRAY_SIZE(ccu_clks),
+};
+
+static const struct of_device_id of_match_clk_mt8195_ccu[] = {
+	{
+		.compatible = "mediatek,mt8195-ccusys",
+		.data = &ccu_desc,
+	}, {
+		/* sentinel */
+	}
+};
+
+static struct platform_driver clk_mt8195_ccu_drv = {
+	.probe = mtk_clk_simple_probe,
+	.driver = {
+		.name = "clk-mt8195-ccu",
+		.of_match_table = of_match_clk_mt8195_ccu,
+	},
+};
+builtin_platform_driver(clk_mt8195_ccu_drv);
diff --git a/drivers/clk/mediatek/clk-mt8195-img.c b/drivers/clk/mediatek/clk-mt8195-img.c
new file mode 100644
index 0000000000000000000000000000000000000000..22b52a8f15feae81056d980f315c231e1c32766f
--- /dev/null
+++ b/drivers/clk/mediatek/clk-mt8195-img.c
@@ -0,0 +1,96 @@
+// SPDX-License-Identifier: GPL-2.0-only
+//
+// Copyright (c) 2021 MediaTek Inc.
+// Author: Chun-Jie Chen <chun-jie.chen@mediatek.com>
+
+#include "clk-gate.h"
+#include "clk-mtk.h"
+
+#include <dt-bindings/clock/mt8195-clk.h>
+#include <linux/clk-provider.h>
+#include <linux/platform_device.h>
+
+static const struct mtk_gate_regs img_cg_regs = {
+	.set_ofs = 0x4,
+	.clr_ofs = 0x8,
+	.sta_ofs = 0x0,
+};
+
+#define GATE_IMG(_id, _name, _parent, _shift)			\
+	GATE_MTK(_id, _name, _parent, &img_cg_regs, _shift, &mtk_clk_gate_ops_setclr)
+
+static const struct mtk_gate img_clks[] = {
+	GATE_IMG(CLK_IMG_LARB9, "img_larb9", "top_img", 0),
+	GATE_IMG(CLK_IMG_TRAW0, "img_traw0", "top_img", 1),
+	GATE_IMG(CLK_IMG_TRAW1, "img_traw1", "top_img", 2),
+	GATE_IMG(CLK_IMG_TRAW2, "img_traw2", "top_img", 3),
+	GATE_IMG(CLK_IMG_TRAW3, "img_traw3", "top_img", 4),
+	GATE_IMG(CLK_IMG_DIP0, "img_dip0", "top_img", 8),
+	GATE_IMG(CLK_IMG_WPE0, "img_wpe0", "top_img", 9),
+	GATE_IMG(CLK_IMG_IPE, "img_ipe", "top_img", 10),
+	GATE_IMG(CLK_IMG_DIP1, "img_dip1", "top_img", 11),
+	GATE_IMG(CLK_IMG_WPE1, "img_wpe1", "top_img", 12),
+	GATE_IMG(CLK_IMG_GALS, "img_gals", "top_img", 31),
+};
+
+static const struct mtk_gate img1_dip_top_clks[] = {
+	GATE_IMG(CLK_IMG1_DIP_TOP_LARB10, "img1_dip_top_larb10", "top_img", 0),
+	GATE_IMG(CLK_IMG1_DIP_TOP_DIP_TOP, "img1_dip_top_dip_top", "top_img", 1),
+};
+
+static const struct mtk_gate img1_dip_nr_clks[] = {
+	GATE_IMG(CLK_IMG1_DIP_NR_RESERVE, "img1_dip_nr_reserve", "top_img", 0),
+	GATE_IMG(CLK_IMG1_DIP_NR_DIP_NR, "img1_dip_nr_dip_nr", "top_img", 1),
+};
+
+static const struct mtk_gate img1_wpe_clks[] = {
+	GATE_IMG(CLK_IMG1_WPE_LARB11, "img1_wpe_larb11", "top_img", 0),
+	GATE_IMG(CLK_IMG1_WPE_WPE, "img1_wpe_wpe", "top_img", 1),
+};
+
+static const struct mtk_clk_desc img_desc = {
+	.clks = img_clks,
+	.num_clks = ARRAY_SIZE(img_clks),
+};
+
+static const struct mtk_clk_desc img1_dip_top_desc = {
+	.clks = img1_dip_top_clks,
+	.num_clks = ARRAY_SIZE(img1_dip_top_clks),
+};
+
+static const struct mtk_clk_desc img1_dip_nr_desc = {
+	.clks = img1_dip_nr_clks,
+	.num_clks = ARRAY_SIZE(img1_dip_nr_clks),
+};
+
+static const struct mtk_clk_desc img1_wpe_desc = {
+	.clks = img1_wpe_clks,
+	.num_clks = ARRAY_SIZE(img1_wpe_clks),
+};
+
+static const struct of_device_id of_match_clk_mt8195_img[] = {
+	{
+		.compatible = "mediatek,mt8195-imgsys",
+		.data = &img_desc,
+	}, {
+		.compatible = "mediatek,mt8195-imgsys1_dip_top",
+		.data = &img1_dip_top_desc,
+	}, {
+		.compatible = "mediatek,mt8195-imgsys1_dip_nr",
+		.data = &img1_dip_nr_desc,
+	}, {
+		.compatible = "mediatek,mt8195-imgsys1_wpe",
+		.data = &img1_wpe_desc,
+	}, {
+		/* sentinel */
+	}
+};
+
+static struct platform_driver clk_mt8195_img_drv = {
+	.probe = mtk_clk_simple_probe,
+	.driver = {
+		.name = "clk-mt8195-img",
+		.of_match_table = of_match_clk_mt8195_img,
+	},
+};
+builtin_platform_driver(clk_mt8195_img_drv);
diff --git a/drivers/clk/mediatek/clk-mt8195-imp_iic_wrap.c b/drivers/clk/mediatek/clk-mt8195-imp_iic_wrap.c
new file mode 100644
index 0000000000000000000000000000000000000000..0e2ac0a30aa04f766986ab15ca2f909227e07cb0
--- /dev/null
+++ b/drivers/clk/mediatek/clk-mt8195-imp_iic_wrap.c
@@ -0,0 +1,68 @@
+// SPDX-License-Identifier: GPL-2.0-only
+//
+// Copyright (c) 2021 MediaTek Inc.
+// Author: Chun-Jie Chen <chun-jie.chen@mediatek.com>
+
+#include "clk-gate.h"
+#include "clk-mtk.h"
+
+#include <dt-bindings/clock/mt8195-clk.h>
+#include <linux/clk-provider.h>
+#include <linux/platform_device.h>
+
+#include <dt-bindings/clock/mt8195-clk.h>
+
+static const struct mtk_gate_regs imp_iic_wrap_cg_regs = {
+	.set_ofs = 0xe08,
+	.clr_ofs = 0xe04,
+	.sta_ofs = 0xe00,
+};
+
+#define GATE_IMP_IIC_WRAP(_id, _name, _parent, _shift)				\
+	GATE_MTK_FLAGS(_id, _name, _parent, &imp_iic_wrap_cg_regs, _shift,	\
+		&mtk_clk_gate_ops_setclr, CLK_OPS_PARENT_ENABLE)
+
+static const struct mtk_gate imp_iic_wrap_s_clks[] = {
+	GATE_IMP_IIC_WRAP(CLK_IMP_IIC_WRAP_S_I2C5, "imp_iic_wrap_s_i2c5", "top_i2c", 0),
+	GATE_IMP_IIC_WRAP(CLK_IMP_IIC_WRAP_S_I2C6, "imp_iic_wrap_s_i2c6", "top_i2c", 1),
+	GATE_IMP_IIC_WRAP(CLK_IMP_IIC_WRAP_S_I2C7, "imp_iic_wrap_s_i2c7", "top_i2c", 2),
+};
+
+static const struct mtk_gate imp_iic_wrap_w_clks[] = {
+	GATE_IMP_IIC_WRAP(CLK_IMP_IIC_WRAP_W_I2C0, "imp_iic_wrap_w_i2c0", "top_i2c", 0),
+	GATE_IMP_IIC_WRAP(CLK_IMP_IIC_WRAP_W_I2C1, "imp_iic_wrap_w_i2c1", "top_i2c", 1),
+	GATE_IMP_IIC_WRAP(CLK_IMP_IIC_WRAP_W_I2C2, "imp_iic_wrap_w_i2c2", "top_i2c", 2),
+	GATE_IMP_IIC_WRAP(CLK_IMP_IIC_WRAP_W_I2C3, "imp_iic_wrap_w_i2c3", "top_i2c", 3),
+	GATE_IMP_IIC_WRAP(CLK_IMP_IIC_WRAP_W_I2C4, "imp_iic_wrap_w_i2c4", "top_i2c", 4),
+};
+
+static const struct mtk_clk_desc imp_iic_wrap_s_desc = {
+	.clks = imp_iic_wrap_s_clks,
+	.num_clks = ARRAY_SIZE(imp_iic_wrap_s_clks),
+};
+
+static const struct mtk_clk_desc imp_iic_wrap_w_desc = {
+	.clks = imp_iic_wrap_w_clks,
+	.num_clks = ARRAY_SIZE(imp_iic_wrap_w_clks),
+};
+
+static const struct of_device_id of_match_clk_mt8195_imp_iic_wrap[] = {
+	{
+		.compatible = "mediatek,mt8195-imp_iic_wrap_s",
+		.data = &imp_iic_wrap_s_desc,
+	}, {
+		.compatible = "mediatek,mt8195-imp_iic_wrap_w",
+		.data = &imp_iic_wrap_w_desc,
+	}, {
+		/* sentinel */
+	}
+};
+
+static struct platform_driver clk_mt8195_imp_iic_wrap_drv = {
+	.probe = mtk_clk_simple_probe,
+	.driver = {
+		.name = "clk-mt8195-imp_iic_wrap",
+		.of_match_table = of_match_clk_mt8195_imp_iic_wrap,
+	},
+};
+builtin_platform_driver(clk_mt8195_imp_iic_wrap_drv);
diff --git a/drivers/clk/mediatek/clk-mt8195-infra_ao.c b/drivers/clk/mediatek/clk-mt8195-infra_ao.c
new file mode 100644
index 0000000000000000000000000000000000000000..68e77b078097384b1a1f870f9fa7da8f798adcfb
--- /dev/null
+++ b/drivers/clk/mediatek/clk-mt8195-infra_ao.c
@@ -0,0 +1,216 @@
+// SPDX-License-Identifier: GPL-2.0-only
+//
+// Copyright (c) 2021 MediaTek Inc.
+// Author: Chun-Jie Chen <chun-jie.chen@mediatek.com>
+
+#include "clk-gate.h"
+#include "clk-mtk.h"
+
+#include <dt-bindings/clock/mt8195-clk.h>
+#include <linux/clk-provider.h>
+#include <linux/platform_device.h>
+
+static const struct mtk_gate_regs infra_ao0_cg_regs = {
+	.set_ofs = 0x80,
+	.clr_ofs = 0x84,
+	.sta_ofs = 0x90,
+};
+
+static const struct mtk_gate_regs infra_ao1_cg_regs = {
+	.set_ofs = 0x88,
+	.clr_ofs = 0x8c,
+	.sta_ofs = 0x94,
+};
+
+static const struct mtk_gate_regs infra_ao2_cg_regs = {
+	.set_ofs = 0xa4,
+	.clr_ofs = 0xa8,
+	.sta_ofs = 0xac,
+};
+
+static const struct mtk_gate_regs infra_ao3_cg_regs = {
+	.set_ofs = 0xc0,
+	.clr_ofs = 0xc4,
+	.sta_ofs = 0xc8,
+};
+
+static const struct mtk_gate_regs infra_ao4_cg_regs = {
+	.set_ofs = 0xe0,
+	.clr_ofs = 0xe4,
+	.sta_ofs = 0xe8,
+};
+
+#define GATE_INFRA_AO0_FLAGS(_id, _name, _parent, _shift, _flag)                \
+	GATE_MTK_FLAGS(_id, _name, _parent, &infra_ao0_cg_regs, _shift, \
+		&mtk_clk_gate_ops_setclr, _flag)
+
+#define GATE_INFRA_AO0(_id, _name, _parent, _shift)	\
+	GATE_INFRA_AO0_FLAGS(_id, _name, _parent, _shift, 0)
+
+#define GATE_INFRA_AO1_FLAGS(_id, _name, _parent, _shift, _flag)		\
+	GATE_MTK_FLAGS(_id, _name, _parent, &infra_ao1_cg_regs, _shift,	\
+		&mtk_clk_gate_ops_setclr, _flag)
+
+#define GATE_INFRA_AO1(_id, _name, _parent, _shift)	\
+	GATE_INFRA_AO1_FLAGS(_id, _name, _parent, _shift, 0)
+
+#define GATE_INFRA_AO2_FLAGS(_id, _name, _parent, _shift, _flag)		\
+	GATE_MTK_FLAGS(_id, _name, _parent, &infra_ao2_cg_regs, _shift, \
+		&mtk_clk_gate_ops_setclr, _flag)
+
+#define GATE_INFRA_AO2(_id, _name, _parent, _shift)			\
+	GATE_INFRA_AO2_FLAGS(_id, _name, _parent, _shift, 0)
+
+#define GATE_INFRA_AO3_FLAGS(_id, _name, _parent, _shift, _flag)		\
+	GATE_MTK_FLAGS(_id, _name, _parent, &infra_ao3_cg_regs, _shift,	\
+		&mtk_clk_gate_ops_setclr, _flag)
+
+#define GATE_INFRA_AO3(_id, _name, _parent, _shift)	\
+	GATE_INFRA_AO3_FLAGS(_id, _name, _parent, _shift, 0)
+
+#define GATE_INFRA_AO4_FLAGS(_id, _name, _parent, _shift, _flag)		\
+	GATE_MTK_FLAGS(_id, _name, _parent, &infra_ao4_cg_regs, _shift,	\
+		&mtk_clk_gate_ops_setclr, _flag)
+
+#define GATE_INFRA_AO4(_id, _name, _parent, _shift)	\
+	GATE_INFRA_AO4_FLAGS(_id, _name, _parent, _shift, 0)
+
+static const struct mtk_gate infra_ao_clks[] = {
+	/* INFRA_AO0 */
+	GATE_INFRA_AO0(CLK_INFRA_AO_PMIC_TMR, "infra_ao_pmic_tmr", "top_pwrap_ulposc", 0),
+	GATE_INFRA_AO0(CLK_INFRA_AO_PMIC_AP, "infra_ao_pmic_ap", "top_pwrap_ulposc", 1),
+	GATE_INFRA_AO0(CLK_INFRA_AO_PMIC_MD, "infra_ao_pmic_md", "top_pwrap_ulposc", 2),
+	GATE_INFRA_AO0(CLK_INFRA_AO_PMIC_CONN, "infra_ao_pmic_conn", "top_pwrap_ulposc", 3),
+	/* infra_ao_sej is main clock is for secure engine with JTAG support */
+	GATE_INFRA_AO0_FLAGS(CLK_INFRA_AO_SEJ, "infra_ao_sej", "top_axi", 5, CLK_IS_CRITICAL),
+	GATE_INFRA_AO0(CLK_INFRA_AO_APXGPT, "infra_ao_apxgpt", "top_axi", 6),
+	GATE_INFRA_AO0(CLK_INFRA_AO_GCE, "infra_ao_gce", "top_axi", 8),
+	GATE_INFRA_AO0(CLK_INFRA_AO_GCE2, "infra_ao_gce2", "top_axi", 9),
+	GATE_INFRA_AO0(CLK_INFRA_AO_THERM, "infra_ao_therm", "top_axi", 10),
+	GATE_INFRA_AO0(CLK_INFRA_AO_PWM_H, "infra_ao_pwm_h", "top_axi", 15),
+	GATE_INFRA_AO0(CLK_INFRA_AO_PWM1, "infra_ao_pwm1", "top_pwm", 16),
+	GATE_INFRA_AO0(CLK_INFRA_AO_PWM2, "infra_ao_pwm2", "top_pwm", 17),
+	GATE_INFRA_AO0(CLK_INFRA_AO_PWM3, "infra_ao_pwm3", "top_pwm", 18),
+	GATE_INFRA_AO0(CLK_INFRA_AO_PWM4, "infra_ao_pwm4", "top_pwm", 19),
+	GATE_INFRA_AO0(CLK_INFRA_AO_PWM, "infra_ao_pwm", "top_pwm", 21),
+	GATE_INFRA_AO0(CLK_INFRA_AO_UART0, "infra_ao_uart0", "top_uart", 22),
+	GATE_INFRA_AO0(CLK_INFRA_AO_UART1, "infra_ao_uart1", "top_uart", 23),
+	GATE_INFRA_AO0(CLK_INFRA_AO_UART2, "infra_ao_uart2", "top_uart", 24),
+	GATE_INFRA_AO0(CLK_INFRA_AO_UART3, "infra_ao_uart3", "top_uart", 25),
+	GATE_INFRA_AO0(CLK_INFRA_AO_UART4, "infra_ao_uart4", "top_uart", 26),
+	GATE_INFRA_AO0(CLK_INFRA_AO_GCE_26M, "infra_ao_gce_26m", "clk26m", 27),
+	GATE_INFRA_AO0(CLK_INFRA_AO_CQ_DMA_FPC, "infra_ao_cq_dma_fpc", "fpc", 28),
+	GATE_INFRA_AO0(CLK_INFRA_AO_UART5, "infra_ao_uart5", "top_uart", 29),
+	/* INFRA_AO1 */
+	GATE_INFRA_AO1(CLK_INFRA_AO_HDMI_26M, "infra_ao_hdmi_26m", "clk26m", 0),
+	GATE_INFRA_AO1(CLK_INFRA_AO_SPI0, "infra_ao_spi0", "top_spi", 1),
+	GATE_INFRA_AO1(CLK_INFRA_AO_MSDC0, "infra_ao_msdc0", "top_msdc50_0_hclk", 2),
+	GATE_INFRA_AO1(CLK_INFRA_AO_MSDC1, "infra_ao_msdc1", "top_axi", 4),
+	GATE_INFRA_AO1(CLK_INFRA_AO_CG1_MSDC2, "infra_ao_cg1_msdc2", "top_axi", 5),
+	GATE_INFRA_AO1(CLK_INFRA_AO_MSDC0_SRC, "infra_ao_msdc0_src", "top_msdc50_0", 6),
+	GATE_INFRA_AO1(CLK_INFRA_AO_TRNG, "infra_ao_trng", "top_axi", 9),
+	GATE_INFRA_AO1(CLK_INFRA_AO_AUXADC, "infra_ao_auxadc", "clk26m", 10),
+	GATE_INFRA_AO1(CLK_INFRA_AO_CPUM, "infra_ao_cpum", "top_axi", 11),
+	GATE_INFRA_AO1(CLK_INFRA_AO_HDMI_32K, "infra_ao_hdmi_32k", "clk32k", 12),
+	GATE_INFRA_AO1(CLK_INFRA_AO_CEC_66M_H, "infra_ao_cec_66m_h", "top_axi", 13),
+	GATE_INFRA_AO1(CLK_INFRA_AO_IRRX, "infra_ao_irrx", "top_axi", 14),
+	GATE_INFRA_AO1(CLK_INFRA_AO_PCIE_TL_26M, "infra_ao_pcie_tl_26m", "clk26m", 15),
+	GATE_INFRA_AO1(CLK_INFRA_AO_MSDC1_SRC, "infra_ao_msdc1_src", "top_msdc30_1", 16),
+	GATE_INFRA_AO1(CLK_INFRA_AO_CEC_66M_B, "infra_ao_cec_66m_b", "top_axi", 17),
+	GATE_INFRA_AO1(CLK_INFRA_AO_PCIE_TL_96M, "infra_ao_pcie_tl_96m", "top_tl", 18),
+	/* infra_ao_device_apc is for device access permission control module */
+	GATE_INFRA_AO1_FLAGS(CLK_INFRA_AO_DEVICE_APC, "infra_ao_device_apc", "top_axi", 20,
+			     CLK_IS_CRITICAL),
+	GATE_INFRA_AO1(CLK_INFRA_AO_ECC_66M_H, "infra_ao_ecc_66m_h", "top_axi", 23),
+	GATE_INFRA_AO1(CLK_INFRA_AO_DEBUGSYS, "infra_ao_debugsys", "top_axi", 24),
+	GATE_INFRA_AO1(CLK_INFRA_AO_AUDIO, "infra_ao_audio", "top_axi", 25),
+	GATE_INFRA_AO1(CLK_INFRA_AO_PCIE_TL_32K, "infra_ao_pcie_tl_32k", "clk32k", 26),
+	GATE_INFRA_AO1(CLK_INFRA_AO_DBG_TRACE, "infra_ao_dbg_trace", "top_axi", 29),
+	GATE_INFRA_AO1(CLK_INFRA_AO_DRAMC_F26M, "infra_ao_dramc_f26m", "clk26m", 31),
+	/* INFRA_AO2 */
+	GATE_INFRA_AO2(CLK_INFRA_AO_IRTX, "infra_ao_irtx", "top_axi", 0),
+	GATE_INFRA_AO2(CLK_INFRA_AO_SSUSB, "infra_ao_ssusb", "top_usb_top", 1),
+	GATE_INFRA_AO2(CLK_INFRA_AO_DISP_PWM, "infra_ao_disp_pwm", "top_disp_pwm0", 2),
+	GATE_INFRA_AO2(CLK_INFRA_AO_CLDMA_B, "infra_ao_cldma_b", "top_axi", 3),
+	GATE_INFRA_AO2(CLK_INFRA_AO_AUDIO_26M_B, "infra_ao_audio_26m_b", "clk26m", 4),
+	GATE_INFRA_AO2(CLK_INFRA_AO_SPI1, "infra_ao_spi1", "top_spi", 6),
+	GATE_INFRA_AO2(CLK_INFRA_AO_SPI2, "infra_ao_spi2", "top_spi", 9),
+	GATE_INFRA_AO2(CLK_INFRA_AO_SPI3, "infra_ao_spi3", "top_spi", 10),
+	GATE_INFRA_AO2(CLK_INFRA_AO_UNIPRO_SYS, "infra_ao_unipro_sys", "top_ufs", 11),
+	GATE_INFRA_AO2(CLK_INFRA_AO_UNIPRO_TICK, "infra_ao_unipro_tick", "top_ufs_tick1us", 12),
+	GATE_INFRA_AO2(CLK_INFRA_AO_UFS_MP_SAP_B, "infra_ao_ufs_mp_sap_b", "top_ufs_mp_sap_cfg", 13),
+	/*
+	 * because no pwrmcu kernel driver in chrome, so make the main clocks as
+	 * always on clocks to support pwrmcu.
+	 */
+	GATE_INFRA_AO2_FLAGS(CLK_INFRA_AO_PWRMCU, "infra_ao_pwrmcu", "top_pwrmcu", 15,
+			     CLK_IS_CRITICAL),
+	GATE_INFRA_AO2_FLAGS(CLK_INFRA_AO_PWRMCU_BUS_H, "infra_ao_pwrmcu_bus_h", "top_axi", 17,
+			     CLK_IS_CRITICAL),
+	GATE_INFRA_AO2(CLK_INFRA_AO_APDMA_B, "infra_ao_apdma_b", "top_axi", 18),
+	GATE_INFRA_AO2(CLK_INFRA_AO_SPI4, "infra_ao_spi4", "top_spi", 25),
+	GATE_INFRA_AO2(CLK_INFRA_AO_SPI5, "infra_ao_spi5", "top_spi", 26),
+	GATE_INFRA_AO2(CLK_INFRA_AO_CQ_DMA, "infra_ao_cq_dma", "top_axi", 27),
+	GATE_INFRA_AO2(CLK_INFRA_AO_AES_UFSFDE, "infra_ao_aes_ufsfde", "top_ufs", 28),
+	GATE_INFRA_AO2(CLK_INFRA_AO_AES, "infra_ao_aes", "top_aes_ufsfde", 29),
+	GATE_INFRA_AO2(CLK_INFRA_AO_UFS_TICK, "infra_ao_ufs_tick", "top_ufs_tick1us", 30),
+	GATE_INFRA_AO2(CLK_INFRA_AO_SSUSB_XHCI, "infra_ao_ssusb_xhci", "top_ssusb_xhci", 31),
+	/* INFRA_AO3 */
+	GATE_INFRA_AO3(CLK_INFRA_AO_MSDC0_SELF, "infra_ao_msdc0f", "top_msdc50_0", 0),
+	GATE_INFRA_AO3(CLK_INFRA_AO_MSDC1_SELF, "infra_ao_msdc1f", "top_msdc50_0", 1),
+	GATE_INFRA_AO3(CLK_INFRA_AO_MSDC2_SELF, "infra_ao_msdc2f", "top_msdc50_0", 2),
+	GATE_INFRA_AO3(CLK_INFRA_AO_I2S_DMA, "infra_ao_i2s_dma", "top_axi", 5),
+	GATE_INFRA_AO3(CLK_INFRA_AO_AP_MSDC0, "infra_ao_ap_msdc0", "top_msdc50_0", 7),
+	GATE_INFRA_AO3(CLK_INFRA_AO_MD_MSDC0, "infra_ao_md_msdc0", "top_msdc50_0", 8),
+	GATE_INFRA_AO3(CLK_INFRA_AO_CG3_MSDC2, "infra_ao_cg3_msdc2", "top_msdc30_2", 9),
+	GATE_INFRA_AO3(CLK_INFRA_AO_GCPU, "infra_ao_gcpu", "top_gcpu", 10),
+	GATE_INFRA_AO3(CLK_INFRA_AO_PCIE_PERI_26M, "infra_ao_pcie_peri_26m", "clk26m", 15),
+	GATE_INFRA_AO3(CLK_INFRA_AO_GCPU_66M_B, "infra_ao_gcpu_66m_b", "top_axi", 16),
+	GATE_INFRA_AO3(CLK_INFRA_AO_GCPU_133M_B, "infra_ao_gcpu_133m_b", "top_axi", 17),
+	GATE_INFRA_AO3(CLK_INFRA_AO_DISP_PWM1, "infra_ao_disp_pwm1", "top_disp_pwm1", 20),
+	GATE_INFRA_AO3(CLK_INFRA_AO_FBIST2FPC, "infra_ao_fbist2fpc", "top_msdc50_0", 24),
+	/* infra_ao_device_apc_sync is for device access permission control module */
+	GATE_INFRA_AO3_FLAGS(CLK_INFRA_AO_DEVICE_APC_SYNC, "infra_ao_device_apc_sync", "top_axi", 25,
+			     CLK_IS_CRITICAL),
+	GATE_INFRA_AO3(CLK_INFRA_AO_PCIE_P1_PERI_26M, "infra_ao_pcie_p1_peri_26m", "clk26m", 26),
+	GATE_INFRA_AO3(CLK_INFRA_AO_SPIS0, "infra_ao_spis0", "top_spis", 28),
+	GATE_INFRA_AO3(CLK_INFRA_AO_SPIS1, "infra_ao_spis1", "top_spis", 29),
+	/* INFRA_AO4 */
+	/* infra_ao_133m_m_peri infra_ao_66m_m_peri are main clocks of peripheral */
+	GATE_INFRA_AO4_FLAGS(CLK_INFRA_AO_133M_M_PERI, "infra_ao_133m_m_peri", "top_axi", 0,
+			     CLK_IS_CRITICAL),
+	GATE_INFRA_AO4_FLAGS(CLK_INFRA_AO_66M_M_PERI, "infra_ao_66m_m_peri", "top_axi", 1,
+			     CLK_IS_CRITICAL),
+	GATE_INFRA_AO4(CLK_INFRA_AO_PCIE_PL_P_250M_P0, "infra_ao_pcie_pl_p_250m_p0", "pextp_pipe", 7),
+	GATE_INFRA_AO4(CLK_INFRA_AO_PCIE_PL_P_250M_P1, "infra_ao_pcie_pl_p_250m_p1",
+		       "ssusb_u3phy_p1_p_p0", 8),
+	GATE_INFRA_AO4(CLK_INFRA_AO_PCIE_P1_TL_96M, "infra_ao_pcie_p1_tl_96m", "top_tl_p1", 17),
+	GATE_INFRA_AO4(CLK_INFRA_AO_AES_MSDCFDE_0P, "infra_ao_aes_msdcfde_0p", "top_aes_msdcfde", 18),
+	GATE_INFRA_AO4(CLK_INFRA_AO_UFS_TX_SYMBOL, "infra_ao_ufs_tx_symbol", "ufs_tx_symbol", 22),
+	GATE_INFRA_AO4(CLK_INFRA_AO_UFS_RX_SYMBOL, "infra_ao_ufs_rx_symbol", "ufs_rx_symbol", 23),
+	GATE_INFRA_AO4(CLK_INFRA_AO_UFS_RX_SYMBOL1, "infra_ao_ufs_rx_symbol1", "ufs_rx_symbol1", 24),
+	GATE_INFRA_AO4(CLK_INFRA_AO_PERI_UFS_MEM_SUB, "infra_ao_peri_ufs_mem_sub", "mem_466m", 31),
+};
+
+static const struct mtk_clk_desc infra_ao_desc = {
+	.clks = infra_ao_clks,
+	.num_clks = ARRAY_SIZE(infra_ao_clks),
+};
+
+static const struct of_device_id of_match_clk_mt8195_infra_ao[] = {
+	{
+		.compatible = "mediatek,mt8195-infracfg_ao",
+		.data = &infra_ao_desc,
+	}, {
+		/* sentinel */
+	}
+};
+
+static struct platform_driver clk_mt8195_infra_ao_drv = {
+	.probe = mtk_clk_simple_probe,
+	.driver = {
+		.name = "clk-mt8195-infra_ao",
+		.of_match_table = of_match_clk_mt8195_infra_ao,
+	},
+};
+builtin_platform_driver(clk_mt8195_infra_ao_drv);
diff --git a/drivers/clk/mediatek/clk-mt8195-ipe.c b/drivers/clk/mediatek/clk-mt8195-ipe.c
new file mode 100644
index 0000000000000000000000000000000000000000..fc1d42b6ac846a1c87a287ba65dd98be8f905b33
--- /dev/null
+++ b/drivers/clk/mediatek/clk-mt8195-ipe.c
@@ -0,0 +1,51 @@
+// SPDX-License-Identifier: GPL-2.0-only
+//
+// Copyright (c) 2021 MediaTek Inc.
+// Author: Chun-Jie Chen <chun-jie.chen@mediatek.com>
+
+#include "clk-gate.h"
+#include "clk-mtk.h"
+
+#include <dt-bindings/clock/mt8195-clk.h>
+#include <linux/clk-provider.h>
+#include <linux/platform_device.h>
+
+static const struct mtk_gate_regs ipe_cg_regs = {
+	.set_ofs = 0x0,
+	.clr_ofs = 0x0,
+	.sta_ofs = 0x0,
+};
+
+#define GATE_IPE(_id, _name, _parent, _shift)			\
+	GATE_MTK(_id, _name, _parent, &ipe_cg_regs, _shift, &mtk_clk_gate_ops_no_setclr)
+
+static const struct mtk_gate ipe_clks[] = {
+	GATE_IPE(CLK_IPE_DPE, "ipe_dpe", "top_ipe", 0),
+	GATE_IPE(CLK_IPE_FDVT, "ipe_fdvt", "top_ipe", 1),
+	GATE_IPE(CLK_IPE_ME, "ipe_me", "top_ipe", 2),
+	GATE_IPE(CLK_IPE_TOP, "ipe_top", "top_ipe", 3),
+	GATE_IPE(CLK_IPE_SMI_LARB12, "ipe_smi_larb12", "top_ipe", 4),
+};
+
+static const struct mtk_clk_desc ipe_desc = {
+	.clks = ipe_clks,
+	.num_clks = ARRAY_SIZE(ipe_clks),
+};
+
+static const struct of_device_id of_match_clk_mt8195_ipe[] = {
+	{
+		.compatible = "mediatek,mt8195-ipesys",
+		.data = &ipe_desc,
+	}, {
+		/* sentinel */
+	}
+};
+
+static struct platform_driver clk_mt8195_ipe_drv = {
+	.probe = mtk_clk_simple_probe,
+	.driver = {
+		.name = "clk-mt8195-ipe",
+		.of_match_table = of_match_clk_mt8195_ipe,
+	},
+};
+builtin_platform_driver(clk_mt8195_ipe_drv);
diff --git a/drivers/clk/mediatek/clk-mt8195-mfg.c b/drivers/clk/mediatek/clk-mt8195-mfg.c
new file mode 100644
index 0000000000000000000000000000000000000000..aca6d9c0837ca611cb80a5dbfae430da58dec9bc
--- /dev/null
+++ b/drivers/clk/mediatek/clk-mt8195-mfg.c
@@ -0,0 +1,47 @@
+// SPDX-License-Identifier: GPL-2.0-only
+//
+// Copyright (c) 2021 MediaTek Inc.
+// Author: Chun-Jie Chen <chun-jie.chen@mediatek.com>
+
+#include "clk-gate.h"
+#include "clk-mtk.h"
+
+#include <dt-bindings/clock/mt8195-clk.h>
+#include <linux/clk-provider.h>
+#include <linux/platform_device.h>
+
+static const struct mtk_gate_regs mfg_cg_regs = {
+	.set_ofs = 0x4,
+	.clr_ofs = 0x8,
+	.sta_ofs = 0x0,
+};
+
+#define GATE_MFG(_id, _name, _parent, _shift)			\
+	GATE_MTK(_id, _name, _parent, &mfg_cg_regs, _shift, &mtk_clk_gate_ops_setclr)
+
+static const struct mtk_gate mfg_clks[] = {
+	GATE_MFG(CLK_MFG_BG3D, "mfg_bg3d", "top_mfg_core_tmp", 0),
+};
+
+static const struct mtk_clk_desc mfg_desc = {
+	.clks = mfg_clks,
+	.num_clks = ARRAY_SIZE(mfg_clks),
+};
+
+static const struct of_device_id of_match_clk_mt8195_mfg[] = {
+	{
+		.compatible = "mediatek,mt8195-mfgcfg",
+		.data = &mfg_desc,
+	}, {
+		/* sentinel */
+	}
+};
+
+static struct platform_driver clk_mt8195_mfg_drv = {
+	.probe = mtk_clk_simple_probe,
+	.driver = {
+		.name = "clk-mt8195-mfg",
+		.of_match_table = of_match_clk_mt8195_mfg,
+	},
+};
+builtin_platform_driver(clk_mt8195_mfg_drv);
diff --git a/drivers/clk/mediatek/clk-mt8195-peri_ao.c b/drivers/clk/mediatek/clk-mt8195-peri_ao.c
new file mode 100644
index 0000000000000000000000000000000000000000..907a92b22de8d0657d980d614f3c7ff20e5a6172
--- /dev/null
+++ b/drivers/clk/mediatek/clk-mt8195-peri_ao.c
@@ -0,0 +1,62 @@
+// SPDX-License-Identifier: GPL-2.0-only
+//
+// Copyright (c) 2021 MediaTek Inc.
+// Author: Chun-Jie Chen <chun-jie.chen@mediatek.com>
+
+#include "clk-gate.h"
+#include "clk-mtk.h"
+
+#include <dt-bindings/clock/mt8195-clk.h>
+#include <linux/clk-provider.h>
+#include <linux/platform_device.h>
+
+static const struct mtk_gate_regs peri_ao_cg_regs = {
+	.set_ofs = 0x10,
+	.clr_ofs = 0x14,
+	.sta_ofs = 0x18,
+};
+
+#define GATE_PERI_AO(_id, _name, _parent, _shift)			\
+	GATE_MTK(_id, _name, _parent, &peri_ao_cg_regs, _shift, &mtk_clk_gate_ops_setclr)
+
+static const struct mtk_gate peri_ao_clks[] = {
+	GATE_PERI_AO(CLK_PERI_AO_ETHERNET, "peri_ao_ethernet", "top_axi", 0),
+	GATE_PERI_AO(CLK_PERI_AO_ETHERNET_BUS, "peri_ao_ethernet_bus", "top_axi", 1),
+	GATE_PERI_AO(CLK_PERI_AO_FLASHIF_BUS, "peri_ao_flashif_bus", "top_axi", 3),
+	GATE_PERI_AO(CLK_PERI_AO_FLASHIF_FLASH, "peri_ao_flashif_flash", "top_spinor", 5),
+	GATE_PERI_AO(CLK_PERI_AO_SSUSB_1P_BUS, "peri_ao_ssusb_1p_bus", "top_usb_top_1p", 7),
+	GATE_PERI_AO(CLK_PERI_AO_SSUSB_1P_XHCI, "peri_ao_ssusb_1p_xhci", "top_ssusb_xhci_1p", 8),
+	GATE_PERI_AO(CLK_PERI_AO_SSUSB_2P_BUS, "peri_ao_ssusb_2p_bus", "top_usb_top_2p", 9),
+	GATE_PERI_AO(CLK_PERI_AO_SSUSB_2P_XHCI, "peri_ao_ssusb_2p_xhci", "top_ssusb_xhci_2p", 10),
+	GATE_PERI_AO(CLK_PERI_AO_SSUSB_3P_BUS, "peri_ao_ssusb_3p_bus", "top_usb_top_3p", 11),
+	GATE_PERI_AO(CLK_PERI_AO_SSUSB_3P_XHCI, "peri_ao_ssusb_3p_xhci", "top_ssusb_xhci_3p", 12),
+	GATE_PERI_AO(CLK_PERI_AO_SPINFI, "peri_ao_spinfi", "top_spinfi_bclk", 15),
+	GATE_PERI_AO(CLK_PERI_AO_ETHERNET_MAC, "peri_ao_ethernet_mac", "top_snps_eth_250m", 16),
+	GATE_PERI_AO(CLK_PERI_AO_NFI_H, "peri_ao_nfi_h", "top_axi", 19),
+	GATE_PERI_AO(CLK_PERI_AO_FNFI1X, "peri_ao_fnfi1x", "top_nfi1x", 20),
+	GATE_PERI_AO(CLK_PERI_AO_PCIE_P0_MEM, "peri_ao_pcie_p0_mem", "mem_466m", 24),
+	GATE_PERI_AO(CLK_PERI_AO_PCIE_P1_MEM, "peri_ao_pcie_p1_mem", "mem_466m", 25),
+};
+
+static const struct mtk_clk_desc peri_ao_desc = {
+	.clks = peri_ao_clks,
+	.num_clks = ARRAY_SIZE(peri_ao_clks),
+};
+
+static const struct of_device_id of_match_clk_mt8195_peri_ao[] = {
+	{
+		.compatible = "mediatek,mt8195-pericfg_ao",
+		.data = &peri_ao_desc,
+	}, {
+		/* sentinel */
+	}
+};
+
+static struct platform_driver clk_mt8195_peri_ao_drv = {
+	.probe = mtk_clk_simple_probe,
+	.driver = {
+		.name = "clk-mt8195-peri_ao",
+		.of_match_table = of_match_clk_mt8195_peri_ao,
+	},
+};
+builtin_platform_driver(clk_mt8195_peri_ao_drv);
diff --git a/drivers/clk/mediatek/clk-mt8195-scp_adsp.c b/drivers/clk/mediatek/clk-mt8195-scp_adsp.c
new file mode 100644
index 0000000000000000000000000000000000000000..26b4846c589451d85266baf69fbf10e362ecaf9f
--- /dev/null
+++ b/drivers/clk/mediatek/clk-mt8195-scp_adsp.c
@@ -0,0 +1,47 @@
+// SPDX-License-Identifier: GPL-2.0-only
+//
+// Copyright (c) 2021 MediaTek Inc.
+// Author: Chun-Jie Chen <chun-jie.chen@mediatek.com>
+
+#include "clk-gate.h"
+#include "clk-mtk.h"
+
+#include <dt-bindings/clock/mt8195-clk.h>
+#include <linux/clk-provider.h>
+#include <linux/platform_device.h>
+
+static const struct mtk_gate_regs scp_adsp_cg_regs = {
+	.set_ofs = 0x180,
+	.clr_ofs = 0x180,
+	.sta_ofs = 0x180,
+};
+
+#define GATE_SCP_ADSP(_id, _name, _parent, _shift)			\
+	GATE_MTK(_id, _name, _parent, &scp_adsp_cg_regs, _shift, &mtk_clk_gate_ops_no_setclr)
+
+static const struct mtk_gate scp_adsp_clks[] = {
+	GATE_SCP_ADSP(CLK_SCP_ADSP_AUDIODSP, "scp_adsp_audiodsp", "top_adsp", 0),
+};
+
+static const struct mtk_clk_desc scp_adsp_desc = {
+	.clks = scp_adsp_clks,
+	.num_clks = ARRAY_SIZE(scp_adsp_clks),
+};
+
+static const struct of_device_id of_match_clk_mt8195_scp_adsp[] = {
+	{
+		.compatible = "mediatek,mt8195-scp_adsp",
+		.data = &scp_adsp_desc,
+	}, {
+		/* sentinel */
+	}
+};
+
+static struct platform_driver clk_mt8195_scp_adsp_drv = {
+	.probe = mtk_clk_simple_probe,
+	.driver = {
+		.name = "clk-mt8195-scp_adsp",
+		.of_match_table = of_match_clk_mt8195_scp_adsp,
+	},
+};
+builtin_platform_driver(clk_mt8195_scp_adsp_drv);
diff --git a/drivers/clk/mediatek/clk-mt8195-topckgen.c b/drivers/clk/mediatek/clk-mt8195-topckgen.c
new file mode 100644
index 0000000000000000000000000000000000000000..3e2aba9c40bb78351ddd60005f28f8b452c0cd8c
--- /dev/null
+++ b/drivers/clk/mediatek/clk-mt8195-topckgen.c
@@ -0,0 +1,1273 @@
+// SPDX-License-Identifier: GPL-2.0-only
+//
+// Copyright (c) 2021 MediaTek Inc.
+// Author: Chun-Jie Chen <chun-jie.chen@mediatek.com>
+
+#include "clk-gate.h"
+#include "clk-mtk.h"
+#include "clk-mux.h"
+
+#include <dt-bindings/clock/mt8195-clk.h>
+#include <linux/of_device.h>
+#include <linux/platform_device.h>
+
+static DEFINE_SPINLOCK(mt8195_clk_lock);
+
+static const struct mtk_fixed_clk top_fixed_clks[] = {
+	FIXED_CLK(CLK_TOP_IN_DGI, "in_dgi", NULL, 165000000),
+	FIXED_CLK(CLK_TOP_ULPOSC1, "ulposc1", NULL, 248000000),
+	FIXED_CLK(CLK_TOP_ULPOSC2, "ulposc2", NULL, 326000000),
+	FIXED_CLK(CLK_TOP_MEM_466M, "mem_466m", NULL, 533000000),
+	FIXED_CLK(CLK_TOP_MPHONE_SLAVE_B, "mphone_slave_b", NULL, 49152000),
+	FIXED_CLK(CLK_TOP_PEXTP_PIPE, "pextp_pipe", NULL, 250000000),
+	FIXED_CLK(CLK_TOP_UFS_RX_SYMBOL, "ufs_rx_symbol", NULL, 166000000),
+	FIXED_CLK(CLK_TOP_UFS_TX_SYMBOL, "ufs_tx_symbol", NULL, 166000000),
+	FIXED_CLK(CLK_TOP_SSUSB_U3PHY_P1_P_P0, "ssusb_u3phy_p1_p_p0", NULL, 131000000),
+	FIXED_CLK(CLK_TOP_UFS_RX_SYMBOL1, "ufs_rx_symbol1", NULL, 166000000),
+	FIXED_CLK(CLK_TOP_FPC, "fpc", NULL, 50000000),
+	FIXED_CLK(CLK_TOP_HDMIRX_P, "hdmirx_p", NULL, 594000000),
+};
+
+static const struct mtk_fixed_factor top_divs[] = {
+	FACTOR(CLK_TOP_CLK26M_D2, "clk26m_d2", "clk26m", 1, 2),
+	FACTOR(CLK_TOP_CLK26M_D52, "clk26m_d52", "clk26m", 1, 52),
+	FACTOR(CLK_TOP_IN_DGI_D2, "in_dgi_d2", "in_dgi", 1, 2),
+	FACTOR(CLK_TOP_IN_DGI_D4, "in_dgi_d4", "in_dgi", 1, 4),
+	FACTOR(CLK_TOP_IN_DGI_D6, "in_dgi_d6", "in_dgi", 1, 6),
+	FACTOR(CLK_TOP_IN_DGI_D8, "in_dgi_d8", "in_dgi", 1, 8),
+	FACTOR(CLK_TOP_MAINPLL_D3, "mainpll_d3", "mainpll", 1, 3),
+	FACTOR(CLK_TOP_MAINPLL_D4, "mainpll_d4", "mainpll", 1, 4),
+	FACTOR(CLK_TOP_MAINPLL_D4_D2, "mainpll_d4_d2", "mainpll_d4", 1, 2),
+	FACTOR(CLK_TOP_MAINPLL_D4_D4, "mainpll_d4_d4", "mainpll_d4", 1, 4),
+	FACTOR(CLK_TOP_MAINPLL_D4_D8, "mainpll_d4_d8", "mainpll_d4", 1, 8),
+	FACTOR(CLK_TOP_MAINPLL_D5, "mainpll_d5", "mainpll", 1, 5),
+	FACTOR(CLK_TOP_MAINPLL_D5_D2, "mainpll_d5_d2", "mainpll_d5", 1, 2),
+	FACTOR(CLK_TOP_MAINPLL_D5_D4, "mainpll_d5_d4", "mainpll_d5", 1, 4),
+	FACTOR(CLK_TOP_MAINPLL_D5_D8, "mainpll_d5_d8", "mainpll_d5", 1, 8),
+	FACTOR(CLK_TOP_MAINPLL_D6, "mainpll_d6", "mainpll", 1, 6),
+	FACTOR(CLK_TOP_MAINPLL_D6_D2, "mainpll_d6_d2", "mainpll_d6", 1, 2),
+	FACTOR(CLK_TOP_MAINPLL_D6_D4, "mainpll_d6_d4", "mainpll_d6", 1, 4),
+	FACTOR(CLK_TOP_MAINPLL_D6_D8, "mainpll_d6_d8", "mainpll_d6", 1, 8),
+	FACTOR(CLK_TOP_MAINPLL_D7, "mainpll_d7", "mainpll", 1, 7),
+	FACTOR(CLK_TOP_MAINPLL_D7_D2, "mainpll_d7_d2", "mainpll_d7", 1, 2),
+	FACTOR(CLK_TOP_MAINPLL_D7_D4, "mainpll_d7_d4", "mainpll_d7", 1, 4),
+	FACTOR(CLK_TOP_MAINPLL_D7_D8, "mainpll_d7_d8", "mainpll_d7", 1, 8),
+	FACTOR(CLK_TOP_MAINPLL_D9, "mainpll_d9", "mainpll", 1, 9),
+	FACTOR(CLK_TOP_UNIVPLL_D2, "univpll_d2", "univpll", 1, 2),
+	FACTOR(CLK_TOP_UNIVPLL_D3, "univpll_d3", "univpll", 1, 3),
+	FACTOR(CLK_TOP_UNIVPLL_D4, "univpll_d4", "univpll", 1, 4),
+	FACTOR(CLK_TOP_UNIVPLL_D4_D2, "univpll_d4_d2", "univpll_d4", 1, 2),
+	FACTOR(CLK_TOP_UNIVPLL_D4_D4, "univpll_d4_d4", "univpll_d4", 1, 4),
+	FACTOR(CLK_TOP_UNIVPLL_D4_D8, "univpll_d4_d8", "univpll_d4", 1, 8),
+	FACTOR(CLK_TOP_UNIVPLL_D5, "univpll_d5", "univpll", 1, 5),
+	FACTOR(CLK_TOP_UNIVPLL_D5_D2, "univpll_d5_d2", "univpll_d5", 1, 2),
+	FACTOR(CLK_TOP_UNIVPLL_D5_D4, "univpll_d5_d4", "univpll_d5", 1, 4),
+	FACTOR(CLK_TOP_UNIVPLL_D5_D8, "univpll_d5_d8", "univpll_d5", 1, 8),
+	FACTOR(CLK_TOP_UNIVPLL_D6, "univpll_d6", "univpll", 1, 6),
+	FACTOR(CLK_TOP_UNIVPLL_D6_D2, "univpll_d6_d2", "univpll_d6", 1, 2),
+	FACTOR(CLK_TOP_UNIVPLL_D6_D4, "univpll_d6_d4", "univpll_d6", 1, 4),
+	FACTOR(CLK_TOP_UNIVPLL_D6_D8, "univpll_d6_d8", "univpll_d6", 1, 8),
+	FACTOR(CLK_TOP_UNIVPLL_D6_D16, "univpll_d6_d16", "univpll_d6", 1, 16),
+	FACTOR(CLK_TOP_UNIVPLL_D7, "univpll_d7", "univpll", 1, 7),
+	FACTOR(CLK_TOP_UNIVPLL_192M, "univpll_192m", "univpll", 1, 13),
+	FACTOR(CLK_TOP_UNIVPLL_192M_D4, "univpll_192m_d4", "univpll_192m", 1, 4),
+	FACTOR(CLK_TOP_UNIVPLL_192M_D8, "univpll_192m_d8", "univpll_192m", 1, 8),
+	FACTOR(CLK_TOP_UNIVPLL_192M_D16, "univpll_192m_d16", "univpll_192m", 1, 16),
+	FACTOR(CLK_TOP_UNIVPLL_192M_D32, "univpll_192m_d32", "univpll_192m", 1, 32),
+	FACTOR(CLK_TOP_APLL1_D3, "apll1_d3", "apll1", 1, 3),
+	FACTOR(CLK_TOP_APLL1_D4, "apll1_d4", "apll1", 1, 4),
+	FACTOR(CLK_TOP_APLL2_D3, "apll2_d3", "apll2", 1, 3),
+	FACTOR(CLK_TOP_APLL2_D4, "apll2_d4", "apll2", 1, 4),
+	FACTOR(CLK_TOP_APLL3_D4, "apll3_d4", "apll3", 1, 4),
+	FACTOR(CLK_TOP_APLL4_D4, "apll4_d4", "apll4", 1, 4),
+	FACTOR(CLK_TOP_APLL5_D4, "apll5_d4", "apll5", 1, 4),
+	FACTOR(CLK_TOP_HDMIRX_APLL_D3, "hdmirx_apll_d3", "hdmirx_apll", 1, 3),
+	FACTOR(CLK_TOP_HDMIRX_APLL_D4, "hdmirx_apll_d4", "hdmirx_apll", 1, 4),
+	FACTOR(CLK_TOP_HDMIRX_APLL_D6, "hdmirx_apll_d6", "hdmirx_apll", 1, 6),
+	FACTOR(CLK_TOP_MMPLL_D4, "mmpll_d4", "mmpll", 1, 4),
+	FACTOR(CLK_TOP_MMPLL_D4_D2, "mmpll_d4_d2", "mmpll_d4", 1, 2),
+	FACTOR(CLK_TOP_MMPLL_D4_D4, "mmpll_d4_d4", "mmpll_d4", 1, 4),
+	FACTOR(CLK_TOP_MMPLL_D5, "mmpll_d5", "mmpll", 1, 5),
+	FACTOR(CLK_TOP_MMPLL_D5_D2, "mmpll_d5_d2", "mmpll_d5", 1, 2),
+	FACTOR(CLK_TOP_MMPLL_D5_D4, "mmpll_d5_d4", "mmpll_d5", 1, 4),
+	FACTOR(CLK_TOP_MMPLL_D6, "mmpll_d6", "mmpll", 1, 6),
+	FACTOR(CLK_TOP_MMPLL_D6_D2, "mmpll_d6_d2", "mmpll_d6", 1, 2),
+	FACTOR(CLK_TOP_MMPLL_D7, "mmpll_d7", "mmpll", 1, 7),
+	FACTOR(CLK_TOP_MMPLL_D9, "mmpll_d9", "mmpll", 1, 9),
+	FACTOR(CLK_TOP_TVDPLL1_D2, "tvdpll1_d2", "tvdpll1", 1, 2),
+	FACTOR(CLK_TOP_TVDPLL1_D4, "tvdpll1_d4", "tvdpll1", 1, 4),
+	FACTOR(CLK_TOP_TVDPLL1_D8, "tvdpll1_d8", "tvdpll1", 1, 8),
+	FACTOR(CLK_TOP_TVDPLL1_D16, "tvdpll1_d16", "tvdpll1", 1, 16),
+	FACTOR(CLK_TOP_TVDPLL2_D2, "tvdpll2_d2", "tvdpll2", 1, 2),
+	FACTOR(CLK_TOP_TVDPLL2_D4, "tvdpll2_d4", "tvdpll2", 1, 4),
+	FACTOR(CLK_TOP_TVDPLL2_D8, "tvdpll2_d8", "tvdpll2", 1, 8),
+	FACTOR(CLK_TOP_TVDPLL2_D16, "tvdpll2_d16", "tvdpll2", 1, 16),
+	FACTOR(CLK_TOP_MSDCPLL_D2, "msdcpll_d2", "msdcpll", 1, 2),
+	FACTOR(CLK_TOP_MSDCPLL_D4, "msdcpll_d4", "msdcpll", 1, 4),
+	FACTOR(CLK_TOP_MSDCPLL_D16, "msdcpll_d16", "msdcpll", 1, 16),
+	FACTOR(CLK_TOP_ETHPLL_D2, "ethpll_d2", "ethpll", 1, 2),
+	FACTOR(CLK_TOP_ETHPLL_D8, "ethpll_d8", "ethpll", 1, 8),
+	FACTOR(CLK_TOP_ETHPLL_D10, "ethpll_d10", "ethpll", 1, 10),
+	FACTOR(CLK_TOP_DGIPLL_D2, "dgipll_d2", "dgipll", 1, 2),
+	FACTOR(CLK_TOP_ULPOSC1_D2, "ulposc1_d2", "ulposc1", 1, 2),
+	FACTOR(CLK_TOP_ULPOSC1_D4, "ulposc1_d4", "ulposc1", 1, 4),
+	FACTOR(CLK_TOP_ULPOSC1_D7, "ulposc1_d7", "ulposc1", 1, 7),
+	FACTOR(CLK_TOP_ULPOSC1_D8, "ulposc1_d8", "ulposc1", 1, 8),
+	FACTOR(CLK_TOP_ULPOSC1_D10, "ulposc1_d10", "ulposc1", 1, 10),
+	FACTOR(CLK_TOP_ULPOSC1_D16, "ulposc1_d16", "ulposc1", 1, 16),
+	FACTOR(CLK_TOP_ADSPPLL_D2, "adsppll_d2", "adsppll", 1, 2),
+	FACTOR(CLK_TOP_ADSPPLL_D4, "adsppll_d4", "adsppll", 1, 4),
+	FACTOR(CLK_TOP_ADSPPLL_D8, "adsppll_d8", "adsppll", 1, 8),
+};
+
+static const char * const axi_parents[] = {
+	"clk26m",
+	"mainpll_d4_d4",
+	"mainpll_d7_d2",
+	"mainpll_d4_d2",
+	"mainpll_d5_d2",
+	"mainpll_d6_d2",
+	"ulposc1_d4"
+};
+
+static const char * const spm_parents[] = {
+	"clk26m",
+	"ulposc1_d10",
+	"mainpll_d7_d4",
+	"clk32k"
+};
+
+static const char * const scp_parents[] = {
+	"clk26m",
+	"univpll_d4",
+	"mainpll_d6",
+	"univpll_d6",
+	"univpll_d4_d2",
+	"mainpll_d4_d2",
+	"mainpll_d4",
+	"mainpll_d6_d2"
+};
+
+static const char * const bus_aximem_parents[] = {
+	"clk26m",
+	"mainpll_d7_d2",
+	"mainpll_d4_d2",
+	"mainpll_d5_d2",
+	"mainpll_d6"
+};
+
+static const char * const vpp_parents[] = {
+	"clk26m",
+	"univpll_d6_d2",
+	"mainpll_d5_d2",
+	"mmpll_d6_d2",
+	"univpll_d5_d2",
+	"univpll_d4_d2",
+	"mmpll_d4_d2",
+	"mmpll_d7",
+	"univpll_d6",
+	"mainpll_d4",
+	"mmpll_d5",
+	"tvdpll1",
+	"tvdpll2",
+	"univpll_d4",
+	"mmpll_d4"
+};
+
+static const char * const ethdr_parents[] = {
+	"clk26m",
+	"univpll_d6_d2",
+	"mainpll_d5_d2",
+	"mmpll_d6_d2",
+	"univpll_d5_d2",
+	"univpll_d4_d2",
+	"mmpll_d4_d2",
+	"mmpll_d7",
+	"univpll_d6",
+	"mainpll_d4",
+	"mmpll_d5_d4",
+	"tvdpll1",
+	"tvdpll2",
+	"univpll_d4",
+	"mmpll_d4"
+};
+
+static const char * const ipe_parents[] = {
+	"clk26m",
+	"imgpll",
+	"mainpll_d4",
+	"mmpll_d6",
+	"univpll_d6",
+	"mainpll_d6",
+	"mmpll_d4_d2",
+	"univpll_d4_d2",
+	"mainpll_d4_d2",
+	"mmpll_d6_d2",
+	"univpll_d5_d2"
+};
+
+static const char * const cam_parents[] = {
+	"clk26m",
+	"mainpll_d4",
+	"mmpll_d4",
+	"univpll_d4",
+	"univpll_d5",
+	"univpll_d6",
+	"mmpll_d7",
+	"univpll_d4_d2",
+	"mainpll_d4_d2",
+	"imgpll"
+};
+
+static const char * const ccu_parents[] = {
+	"clk26m",
+	"univpll_d6",
+	"mainpll_d4_d2",
+	"mainpll_d4",
+	"univpll_d5",
+	"mainpll_d6",
+	"mmpll_d6",
+	"mmpll_d7",
+	"univpll_d4_d2",
+	"univpll_d7"
+};
+
+static const char * const img_parents[] = {
+	"clk26m",
+	"imgpll",
+	"univpll_d4",
+	"mainpll_d4",
+	"univpll_d5",
+	"mmpll_d6",
+	"univpll_d6",
+	"mainpll_d6",
+	"mmpll_d4_d2",
+	"univpll_d4_d2",
+	"mainpll_d4_d2",
+	"univpll_d5_d2"
+};
+
+static const char * const camtm_parents[] = {
+	"clk26m",
+	"univpll_d4_d4",
+	"univpll_d6_d2",
+	"univpll_d6_d4"
+};
+
+static const char * const dsp_parents[] = {
+	"clk26m",
+	"univpll_d6_d2",
+	"univpll_d4_d2",
+	"univpll_d5",
+	"univpll_d4",
+	"mmpll_d4",
+	"mainpll_d3",
+	"univpll_d3"
+};
+
+static const char * const dsp1_parents[] = {
+	"clk26m",
+	"univpll_d6_d2",
+	"mainpll_d4_d2",
+	"univpll_d5",
+	"mmpll_d5",
+	"univpll_d4",
+	"mainpll_d3",
+	"univpll_d3"
+};
+
+static const char * const dsp2_parents[] = {
+	"clk26m",
+	"univpll_d6_d2",
+	"univpll_d4_d2",
+	"mainpll_d4",
+	"univpll_d4",
+	"mmpll_d4",
+	"mainpll_d3",
+	"univpll_d3"
+};
+
+static const char * const ipu_if_parents[] = {
+	"clk26m",
+	"univpll_d6_d2",
+	"univpll_d5_d2",
+	"mainpll_d4_d2",
+	"mainpll_d6",
+	"univpll_d5",
+	"univpll_d4",
+	"mmpll_d4"
+};
+
+static const char * const mfg_parents[] = {
+	"clk26m",
+	"mainpll_d5_d2",
+	"univpll_d6",
+	"univpll_d7"
+};
+
+static const char * const camtg_parents[] = {
+	"clk26m",
+	"univpll_192m_d8",
+	"univpll_d6_d8",
+	"univpll_192m_d4",
+	"univpll_d6_d16",
+	"clk26m_d2",
+	"univpll_192m_d16",
+	"univpll_192m_d32"
+};
+
+static const char * const uart_parents[] = {
+	"clk26m",
+	"univpll_d6_d8"
+};
+
+static const char * const spi_parents[] = {
+	"clk26m",
+	"mainpll_d5_d4",
+	"mainpll_d6_d4",
+	"msdcpll_d4",
+	"univpll_d6_d2",
+	"mainpll_d6_d2",
+	"mainpll_d4_d4",
+	"univpll_d5_d4"
+};
+
+static const char * const spis_parents[] = {
+	"clk26m",
+	"univpll_d6",
+	"mainpll_d6",
+	"univpll_d4_d2",
+	"univpll_d6_d2",
+	"univpll_d4_d4",
+	"univpll_d6_d4",
+	"mainpll_d7_d4"
+};
+
+static const char * const msdc50_0_h_parents[] = {
+	"clk26m",
+	"mainpll_d4_d2",
+	"mainpll_d6_d2"
+};
+
+static const char * const msdc50_0_parents[] = {
+	"clk26m",
+	"msdcpll",
+	"msdcpll_d2",
+	"univpll_d4_d4",
+	"mainpll_d6_d2",
+	"univpll_d4_d2"
+};
+
+static const char * const msdc30_parents[] = {
+	"clk26m",
+	"univpll_d6_d2",
+	"mainpll_d6_d2",
+	"mainpll_d7_d2",
+	"msdcpll_d2"
+};
+
+static const char * const intdir_parents[] = {
+	"clk26m",
+	"univpll_d6",
+	"mainpll_d4",
+	"univpll_d4"
+};
+
+static const char * const aud_intbus_parents[] = {
+	"clk26m",
+	"mainpll_d4_d4",
+	"mainpll_d7_d4"
+};
+
+static const char * const audio_h_parents[] = {
+	"clk26m",
+	"univpll_d7",
+	"apll1",
+	"apll2"
+};
+
+static const char * const pwrap_ulposc_parents[] = {
+	"ulposc1_d10",
+	"clk26m",
+	"ulposc1_d4",
+	"ulposc1_d7",
+	"ulposc1_d8",
+	"ulposc1_d16",
+	"mainpll_d4_d8",
+	"univpll_d5_d8"
+};
+
+static const char * const atb_parents[] = {
+	"clk26m",
+	"mainpll_d4_d2",
+	"mainpll_d5_d2"
+};
+
+static const char * const pwrmcu_parents[] = {
+	"clk26m",
+	"mainpll_d7_d2",
+	"mainpll_d6_d2",
+	"mainpll_d5_d2",
+	"mainpll_d9",
+	"mainpll_d4_d2"
+};
+
+static const char * const dp_parents[] = {
+	"clk26m",
+	"tvdpll1_d2",
+	"tvdpll2_d2",
+	"tvdpll1_d4",
+	"tvdpll2_d4",
+	"tvdpll1_d8",
+	"tvdpll2_d8",
+	"tvdpll1_d16",
+	"tvdpll2_d16"
+};
+
+static const char * const disp_pwm_parents[] = {
+	"clk26m",
+	"univpll_d6_d4",
+	"ulposc1_d2",
+	"ulposc1_d4",
+	"ulposc1_d16"
+};
+
+static const char * const usb_parents[] = {
+	"clk26m",
+	"univpll_d5_d4",
+	"univpll_d6_d4",
+	"univpll_d5_d2"
+};
+
+static const char * const i2c_parents[] = {
+	"clk26m",
+	"mainpll_d4_d8",
+	"univpll_d5_d4"
+};
+
+static const char * const seninf_parents[] = {
+	"clk26m",
+	"univpll_d4_d4",
+	"univpll_d6_d2",
+	"univpll_d4_d2",
+	"univpll_d7",
+	"univpll_d6",
+	"mmpll_d6",
+	"univpll_d5"
+};
+
+static const char * const gcpu_parents[] = {
+	"clk26m",
+	"mainpll_d6",
+	"univpll_d4_d2",
+	"mmpll_d5_d2",
+	"univpll_d5_d2"
+};
+
+static const char * const dxcc_parents[] = {
+	"clk26m",
+	"mainpll_d4_d2",
+	"mainpll_d4_d4",
+	"mainpll_d4_d8"
+};
+
+static const char * const dpmaif_parents[] = {
+	"clk26m",
+	"univpll_d4_d4",
+	"mainpll_d6",
+	"mainpll_d4_d2",
+	"univpll_d4_d2"
+};
+
+static const char * const aes_fde_parents[] = {
+	"clk26m",
+	"mainpll_d4_d2",
+	"mainpll_d6",
+	"mainpll_d4_d4",
+	"univpll_d4_d2",
+	"univpll_d6"
+};
+
+static const char * const ufs_parents[] = {
+	"clk26m",
+	"mainpll_d4_d4",
+	"mainpll_d4_d8",
+	"univpll_d4_d4",
+	"mainpll_d6_d2",
+	"univpll_d6_d2",
+	"msdcpll_d2"
+};
+
+static const char * const ufs_tick1us_parents[] = {
+	"clk26m_d52",
+	"clk26m"
+};
+
+static const char * const ufs_mp_sap_parents[] = {
+	"clk26m",
+	"msdcpll_d16"
+};
+
+static const char * const venc_parents[] = {
+	"clk26m",
+	"mmpll_d4_d2",
+	"mainpll_d6",
+	"univpll_d4_d2",
+	"mainpll_d4_d2",
+	"univpll_d6",
+	"mmpll_d6",
+	"mainpll_d5_d2",
+	"mainpll_d6_d2",
+	"mmpll_d9",
+	"univpll_d4_d4",
+	"mainpll_d4",
+	"univpll_d4",
+	"univpll_d5",
+	"univpll_d5_d2",
+	"mainpll_d5"
+};
+
+static const char * const vdec_parents[] = {
+	"clk26m",
+	"mainpll_d5_d2",
+	"mmpll_d6_d2",
+	"univpll_d4_d2",
+	"mmpll_d4_d2",
+	"mainpll_d5",
+	"mmpll_d6",
+	"mmpll_d5",
+	"vdecpll",
+	"univpll_d4",
+	"mmpll_d4",
+	"univpll_d6_d2",
+	"mmpll_d9",
+	"univpll_d6",
+	"univpll_d5",
+	"mainpll_d4"
+};
+
+static const char * const pwm_parents[] = {
+	"clk26m",
+	"univpll_d4_d8"
+};
+
+static const char * const mcupm_parents[] = {
+	"clk26m",
+	"mainpll_d6_d2",
+	"mainpll_d7_d4",
+};
+
+static const char * const spmi_parents[] = {
+	"clk26m",
+	"clk26m_d2",
+	"ulposc1_d8",
+	"ulposc1_d10",
+	"ulposc1_d16",
+	"ulposc1_d7",
+	"clk32k",
+	"mainpll_d7_d8",
+	"mainpll_d6_d8",
+	"mainpll_d5_d8"
+};
+
+static const char * const dvfsrc_parents[] = {
+	"clk26m",
+	"ulposc1_d10",
+	"univpll_d6_d8",
+	"msdcpll_d16"
+};
+
+static const char * const tl_parents[] = {
+	"clk26m",
+	"univpll_d5_d4",
+	"mainpll_d4_d4"
+};
+
+static const char * const dsi_occ_parents[] = {
+	"clk26m",
+	"mainpll_d6_d2",
+	"univpll_d5_d2",
+	"univpll_d4_d2"
+};
+
+static const char * const wpe_vpp_parents[] = {
+	"clk26m",
+	"mainpll_d5_d2",
+	"mmpll_d6_d2",
+	"univpll_d5_d2",
+	"mainpll_d4_d2",
+	"univpll_d4_d2",
+	"mmpll_d4_d2",
+	"mainpll_d6",
+	"mmpll_d7",
+	"univpll_d6",
+	"mainpll_d5",
+	"univpll_d5",
+	"mainpll_d4",
+	"tvdpll1",
+	"univpll_d4"
+};
+
+static const char * const hdcp_parents[] = {
+	"clk26m",
+	"univpll_d4_d8",
+	"mainpll_d5_d8",
+	"univpll_d6_d4"
+};
+
+static const char * const hdcp_24m_parents[] = {
+	"clk26m",
+	"univpll_192m_d4",
+	"univpll_192m_d8",
+	"univpll_d6_d8"
+};
+
+static const char * const hd20_dacr_ref_parents[] = {
+	"clk26m",
+	"univpll_d4_d2",
+	"univpll_d4_d4",
+	"univpll_d4_d8"
+};
+
+static const char * const hd20_hdcp_c_parents[] = {
+	"clk26m",
+	"msdcpll_d4",
+	"univpll_d4_d8",
+	"univpll_d6_d8"
+};
+
+static const char * const hdmi_xtal_parents[] = {
+	"clk26m",
+	"clk26m_d2"
+};
+
+static const char * const hdmi_apb_parents[] = {
+	"clk26m",
+	"univpll_d6_d4",
+	"msdcpll_d2"
+};
+
+static const char * const snps_eth_250m_parents[] = {
+	"clk26m",
+	"ethpll_d2"
+};
+
+static const char * const snps_eth_62p4m_ptp_parents[] = {
+	"apll2_d3",
+	"apll1_d3",
+	"clk26m",
+	"ethpll_d8"
+};
+
+static const char * const snps_eth_50m_rmii_parents[] = {
+	"clk26m",
+	"ethpll_d10"
+};
+
+static const char * const dgi_out_parents[] = {
+	"clk26m",
+	"dgipll",
+	"dgipll_d2",
+	"in_dgi",
+	"in_dgi_d2",
+	"mmpll_d4_d4"
+};
+
+static const char * const nna_parents[] = {
+	"clk26m",
+	"nnapll",
+	"univpll_d4",
+	"mainpll_d4",
+	"univpll_d5",
+	"mmpll_d6",
+	"univpll_d6",
+	"mainpll_d6",
+	"mmpll_d4_d2",
+	"univpll_d4_d2",
+	"mainpll_d4_d2",
+	"mmpll_d6_d2"
+};
+
+static const char * const adsp_parents[] = {
+	"clk26m",
+	"clk26m_d2",
+	"mainpll_d6",
+	"mainpll_d5_d2",
+	"univpll_d4_d4",
+	"univpll_d4",
+	"univpll_d6",
+	"ulposc1",
+	"adsppll",
+	"adsppll_d2",
+	"adsppll_d4",
+	"adsppll_d8"
+};
+
+static const char * const asm_parents[] = {
+	"clk26m",
+	"univpll_d6_d4",
+	"univpll_d6_d2",
+	"mainpll_d5_d2"
+};
+
+static const char * const apll1_parents[] = {
+	"clk26m",
+	"apll1_d4"
+};
+
+static const char * const apll2_parents[] = {
+	"clk26m",
+	"apll2_d4"
+};
+
+static const char * const apll3_parents[] = {
+	"clk26m",
+	"apll3_d4"
+};
+
+static const char * const apll4_parents[] = {
+	"clk26m",
+	"apll4_d4"
+};
+
+static const char * const apll5_parents[] = {
+	"clk26m",
+	"apll5_d4"
+};
+
+static const char * const i2s_parents[] = {
+	"clk26m",
+	"apll1",
+	"apll2",
+	"apll3",
+	"apll4",
+	"apll5",
+	"hdmirx_apll"
+};
+
+static const char * const a1sys_hp_parents[] = {
+	"clk26m",
+	"apll1_d4"
+};
+
+static const char * const a2sys_parents[] = {
+	"clk26m",
+	"apll2_d4"
+};
+
+static const char * const a3sys_parents[] = {
+	"clk26m",
+	"apll3_d4",
+	"apll4_d4",
+	"apll5_d4",
+	"hdmirx_apll_d3",
+	"hdmirx_apll_d4",
+	"hdmirx_apll_d6"
+};
+
+static const char * const spinfi_b_parents[] = {
+	"clk26m",
+	"univpll_d6_d8",
+	"univpll_d5_d8",
+	"mainpll_d4_d8",
+	"mainpll_d7_d4",
+	"mainpll_d6_d4",
+	"univpll_d6_d4",
+	"univpll_d5_d4"
+};
+
+static const char * const nfi1x_parents[] = {
+	"clk26m",
+	"univpll_d5_d4",
+	"mainpll_d7_d4",
+	"mainpll_d6_d4",
+	"univpll_d6_d4",
+	"mainpll_d4_d4",
+	"mainpll_d7_d2",
+	"mainpll_d6_d2"
+};
+
+static const char * const ecc_parents[] = {
+	"clk26m",
+	"mainpll_d4_d4",
+	"mainpll_d5_d2",
+	"mainpll_d4_d2",
+	"mainpll_d6",
+	"univpll_d6"
+};
+
+static const char * const audio_local_bus_parents[] = {
+	"clk26m",
+	"clk26m_d2",
+	"mainpll_d4_d4",
+	"mainpll_d7_d2",
+	"mainpll_d4_d2",
+	"mainpll_d5_d2",
+	"mainpll_d6_d2",
+	"mainpll_d7",
+	"univpll_d6",
+	"ulposc1",
+	"ulposc1_d4",
+	"ulposc1_d2"
+};
+
+static const char * const spinor_parents[] = {
+	"clk26m",
+	"clk26m_d2",
+	"mainpll_d7_d8",
+	"univpll_d6_d8"
+};
+
+static const char * const dvio_dgi_ref_parents[] = {
+	"clk26m",
+	"in_dgi",
+	"in_dgi_d2",
+	"in_dgi_d4",
+	"in_dgi_d6",
+	"in_dgi_d8",
+	"mmpll_d4_d4"
+};
+
+static const char * const ulposc_parents[] = {
+	"ulposc1",
+	"ethpll_d2",
+	"mainpll_d4_d2",
+	"ethpll_d10"
+};
+
+static const char * const ulposc_core_parents[] = {
+	"ulposc2",
+	"univpll_d7",
+	"mainpll_d6",
+	"ethpll_d10"
+};
+
+static const char * const srck_parents[] = {
+	"ulposc1_d10",
+	"clk26m"
+};
+
+static const char * const mfg_fast_parents[] = {
+	"top_mfg_core_tmp",
+	"mfgpll"
+};
+
+static const struct mtk_mux top_mtk_muxes[] = {
+	/*
+	 * CLK_CFG_0
+	 * top_axi and top_bus_aximem are bus clocks, should not be closed by Linux.
+	 * top_spm and top_scp are main clocks in always-on co-processor.
+	 */
+	MUX_GATE_CLR_SET_UPD_FLAGS(CLK_TOP_AXI, "top_axi",
+		axi_parents, 0x020, 0x024, 0x028, 0, 3, 7, 0x04, 0, CLK_IS_CRITICAL),
+	MUX_GATE_CLR_SET_UPD_FLAGS(CLK_TOP_SPM, "top_spm",
+		spm_parents, 0x020, 0x024, 0x028, 8, 2, 15, 0x04, 1, CLK_IS_CRITICAL),
+	MUX_GATE_CLR_SET_UPD_FLAGS(CLK_TOP_SCP, "top_scp",
+		scp_parents, 0x020, 0x024, 0x028, 16, 3, 23, 0x04, 2, CLK_IS_CRITICAL),
+	MUX_GATE_CLR_SET_UPD_FLAGS(CLK_TOP_BUS_AXIMEM, "top_bus_aximem",
+		bus_aximem_parents, 0x020, 0x024, 0x028, 24, 3, 31, 0x04, 3, CLK_IS_CRITICAL),
+	/* CLK_CFG_1 */
+	MUX_GATE_CLR_SET_UPD(CLK_TOP_VPP, "top_vpp",
+		vpp_parents, 0x02C, 0x030, 0x034, 0, 4, 7, 0x04, 4),
+	MUX_GATE_CLR_SET_UPD(CLK_TOP_ETHDR, "top_ethdr",
+		ethdr_parents, 0x02C, 0x030, 0x034, 8, 4, 15, 0x04, 5),
+	MUX_GATE_CLR_SET_UPD(CLK_TOP_IPE, "top_ipe",
+		ipe_parents, 0x02C, 0x030, 0x034, 16, 4, 23, 0x04, 6),
+	MUX_GATE_CLR_SET_UPD(CLK_TOP_CAM, "top_cam",
+		cam_parents, 0x02C, 0x030, 0x034, 24, 4, 31, 0x04, 7),
+	/* CLK_CFG_2 */
+	MUX_GATE_CLR_SET_UPD(CLK_TOP_CCU, "top_ccu",
+		ccu_parents, 0x038, 0x03C, 0x040, 0, 4, 7, 0x04, 8),
+	MUX_GATE_CLR_SET_UPD(CLK_TOP_IMG, "top_img",
+		img_parents, 0x038, 0x03C, 0x040, 8, 4, 15, 0x04, 9),
+	MUX_GATE_CLR_SET_UPD(CLK_TOP_CAMTM, "top_camtm",
+		camtm_parents, 0x038, 0x03C, 0x040, 16, 2, 23, 0x04, 10),
+	MUX_GATE_CLR_SET_UPD(CLK_TOP_DSP, "top_dsp",
+		dsp_parents, 0x038, 0x03C, 0x040, 24, 3, 31, 0x04, 11),
+	/* CLK_CFG_3 */
+	MUX_GATE_CLR_SET_UPD(CLK_TOP_DSP1, "top_dsp1",
+		dsp1_parents, 0x044, 0x048, 0x04C, 0, 3, 7, 0x04, 12),
+	MUX_GATE_CLR_SET_UPD(CLK_TOP_DSP2, "top_dsp2",
+		dsp1_parents, 0x044, 0x048, 0x04C, 8, 3, 15, 0x04, 13),
+	MUX_GATE_CLR_SET_UPD(CLK_TOP_DSP3, "top_dsp3",
+		dsp1_parents, 0x044, 0x048, 0x04C, 16, 3, 23, 0x04, 14),
+	MUX_GATE_CLR_SET_UPD(CLK_TOP_DSP4, "top_dsp4",
+		dsp2_parents, 0x044, 0x048, 0x04C, 24, 3, 31, 0x04, 15),
+	/* CLK_CFG_4 */
+	MUX_GATE_CLR_SET_UPD(CLK_TOP_DSP5, "top_dsp5",
+		dsp2_parents, 0x050, 0x054, 0x058, 0, 3, 7, 0x04, 16),
+	MUX_GATE_CLR_SET_UPD(CLK_TOP_DSP6, "top_dsp6",
+		dsp2_parents, 0x050, 0x054, 0x058, 8, 3, 15, 0x04, 17),
+	MUX_GATE_CLR_SET_UPD(CLK_TOP_DSP7, "top_dsp7",
+		dsp_parents, 0x050, 0x054, 0x058, 16, 3, 23, 0x04, 18),
+	MUX_GATE_CLR_SET_UPD(CLK_TOP_IPU_IF, "top_ipu_if",
+		ipu_if_parents, 0x050, 0x054, 0x058, 24, 3, 31, 0x04, 19),
+	/* CLK_CFG_5 */
+	MUX_GATE_CLR_SET_UPD(CLK_TOP_MFG_CORE_TMP, "top_mfg_core_tmp",
+		mfg_parents, 0x05C, 0x060, 0x064, 0, 2, 7, 0x04, 20),
+	MUX_GATE_CLR_SET_UPD(CLK_TOP_CAMTG, "top_camtg",
+		camtg_parents, 0x05C, 0x060, 0x064, 8, 3, 15, 0x04, 21),
+	MUX_GATE_CLR_SET_UPD(CLK_TOP_CAMTG2, "top_camtg2",
+		camtg_parents, 0x05C, 0x060, 0x064, 16, 3, 23, 0x04, 22),
+	MUX_GATE_CLR_SET_UPD(CLK_TOP_CAMTG3, "top_camtg3",
+		camtg_parents, 0x05C, 0x060, 0x064, 24, 3, 31, 0x04, 23),
+	/* CLK_CFG_6 */
+	MUX_GATE_CLR_SET_UPD(CLK_TOP_CAMTG4, "top_camtg4",
+		camtg_parents, 0x068, 0x06C, 0x070, 0, 3, 7, 0x04, 24),
+	MUX_GATE_CLR_SET_UPD(CLK_TOP_CAMTG5, "top_camtg5",
+		camtg_parents, 0x068, 0x06C, 0x070, 8, 3, 15, 0x04, 25),
+	MUX_GATE_CLR_SET_UPD(CLK_TOP_UART, "top_uart",
+		uart_parents, 0x068, 0x06C, 0x070, 16, 1, 23, 0x04, 26),
+	MUX_GATE_CLR_SET_UPD(CLK_TOP_SPI, "top_spi",
+		spi_parents, 0x068, 0x06C, 0x070, 24, 3, 31, 0x04, 27),
+	/* CLK_CFG_7 */
+	MUX_GATE_CLR_SET_UPD(CLK_TOP_SPIS, "top_spis",
+		spis_parents, 0x074, 0x078, 0x07C, 0, 3, 7, 0x04, 28),
+	MUX_GATE_CLR_SET_UPD(CLK_TOP_MSDC50_0_HCLK, "top_msdc50_0_hclk",
+		msdc50_0_h_parents, 0x074, 0x078, 0x07C, 8, 2, 15, 0x04, 29),
+	MUX_GATE_CLR_SET_UPD(CLK_TOP_MSDC50_0, "top_msdc50_0",
+		msdc50_0_parents, 0x074, 0x078, 0x07C, 16, 3, 23, 0x04, 30),
+	MUX_GATE_CLR_SET_UPD(CLK_TOP_MSDC30_1, "top_msdc30_1",
+		msdc30_parents, 0x074, 0x078, 0x07C, 24, 3, 31, 0x04, 31),
+	/* CLK_CFG_8 */
+	MUX_GATE_CLR_SET_UPD(CLK_TOP_MSDC30_2, "top_msdc30_2",
+		msdc30_parents, 0x080, 0x084, 0x088, 0, 3, 7, 0x08, 0),
+	MUX_GATE_CLR_SET_UPD(CLK_TOP_INTDIR, "top_intdir",
+		intdir_parents, 0x080, 0x084, 0x088, 8, 2, 15, 0x08, 1),
+	MUX_GATE_CLR_SET_UPD(CLK_TOP_AUD_INTBUS, "top_aud_intbus",
+		aud_intbus_parents, 0x080, 0x084, 0x088, 16, 2, 23, 0x08, 2),
+	MUX_GATE_CLR_SET_UPD(CLK_TOP_AUDIO_H, "top_audio_h",
+		audio_h_parents, 0x080, 0x084, 0x088, 24, 2, 31, 0x08, 3),
+	/*
+	 * CLK_CFG_9
+	 * top_pwrmcu is main clock in other co-processor, should not be
+	 * handled by Linux.
+	 */
+	MUX_GATE_CLR_SET_UPD(CLK_TOP_PWRAP_ULPOSC, "top_pwrap_ulposc",
+		pwrap_ulposc_parents, 0x08C, 0x090, 0x094, 0, 3, 7, 0x08, 4),
+	MUX_GATE_CLR_SET_UPD(CLK_TOP_ATB, "top_atb",
+		atb_parents, 0x08C, 0x090, 0x094, 8, 2, 15, 0x08, 5),
+	MUX_GATE_CLR_SET_UPD_FLAGS(CLK_TOP_PWRMCU, "top_pwrmcu",
+		pwrmcu_parents, 0x08C, 0x090, 0x094, 16, 3, 23, 0x08, 6, CLK_IS_CRITICAL),
+	MUX_GATE_CLR_SET_UPD(CLK_TOP_DP, "top_dp",
+		dp_parents, 0x08C, 0x090, 0x094, 24, 4, 31, 0x08, 7),
+	/* CLK_CFG_10 */
+	MUX_GATE_CLR_SET_UPD(CLK_TOP_EDP, "top_edp",
+		dp_parents, 0x098, 0x09C, 0x0A0, 0, 4, 7, 0x08, 8),
+	MUX_GATE_CLR_SET_UPD(CLK_TOP_DPI, "top_dpi",
+		dp_parents, 0x098, 0x09C, 0x0A0, 8, 4, 15, 0x08, 9),
+	MUX_GATE_CLR_SET_UPD(CLK_TOP_DISP_PWM0, "top_disp_pwm0",
+		disp_pwm_parents, 0x098, 0x09C, 0x0A0, 16, 3, 23, 0x08, 10),
+	MUX_GATE_CLR_SET_UPD(CLK_TOP_DISP_PWM1, "top_disp_pwm1",
+		disp_pwm_parents, 0x098, 0x09C, 0x0A0, 24, 3, 31, 0x08, 11),
+	/* CLK_CFG_11 */
+	MUX_GATE_CLR_SET_UPD(CLK_TOP_USB_TOP, "top_usb_top",
+		usb_parents, 0x0A4, 0x0A8, 0x0AC, 0, 2, 7, 0x08, 12),
+	MUX_GATE_CLR_SET_UPD(CLK_TOP_SSUSB_XHCI, "top_ssusb_xhci",
+		usb_parents, 0x0A4, 0x0A8, 0x0AC, 8, 2, 15, 0x08, 13),
+	MUX_GATE_CLR_SET_UPD(CLK_TOP_USB_TOP_1P, "top_usb_top_1p",
+		usb_parents, 0x0A4, 0x0A8, 0x0AC, 16, 2, 23, 0x08, 14),
+	MUX_GATE_CLR_SET_UPD(CLK_TOP_SSUSB_XHCI_1P, "top_ssusb_xhci_1p",
+		usb_parents, 0x0A4, 0x0A8, 0x0AC, 24, 2, 31, 0x08, 15),
+	/* CLK_CFG_12 */
+	MUX_GATE_CLR_SET_UPD(CLK_TOP_USB_TOP_2P, "top_usb_top_2p",
+		usb_parents, 0x0B0, 0x0B4, 0x0B8, 0, 2, 7, 0x08, 16),
+	MUX_GATE_CLR_SET_UPD(CLK_TOP_SSUSB_XHCI_2P, "top_ssusb_xhci_2p",
+		usb_parents, 0x0B0, 0x0B4, 0x0B8, 8, 2, 15, 0x08, 17),
+	MUX_GATE_CLR_SET_UPD(CLK_TOP_USB_TOP_3P, "top_usb_top_3p",
+		usb_parents, 0x0B0, 0x0B4, 0x0B8, 16, 2, 23, 0x08, 18),
+	MUX_GATE_CLR_SET_UPD(CLK_TOP_SSUSB_XHCI_3P, "top_ssusb_xhci_3p",
+		usb_parents, 0x0B0, 0x0B4, 0x0B8, 24, 2, 31, 0x08, 19),
+	/* CLK_CFG_13 */
+	MUX_GATE_CLR_SET_UPD(CLK_TOP_I2C, "top_i2c",
+		i2c_parents, 0x0BC, 0x0C0, 0x0C4, 0, 2, 7, 0x08, 20),
+	MUX_GATE_CLR_SET_UPD(CLK_TOP_SENINF, "top_seninf",
+		seninf_parents, 0x0BC, 0x0C0, 0x0C4, 8, 3, 15, 0x08, 21),
+	MUX_GATE_CLR_SET_UPD(CLK_TOP_SENINF1, "top_seninf1",
+		seninf_parents, 0x0BC, 0x0C0, 0x0C4, 16, 3, 23, 0x08, 22),
+	MUX_GATE_CLR_SET_UPD(CLK_TOP_SENINF2, "top_seninf2",
+		seninf_parents, 0x0BC, 0x0C0, 0x0C4, 24, 3, 31, 0x08, 23),
+	/* CLK_CFG_14 */
+	MUX_GATE_CLR_SET_UPD(CLK_TOP_SENINF3, "top_seninf3",
+		seninf_parents, 0x0C8, 0x0CC, 0x0D0, 0, 3, 7, 0x08, 24),
+	MUX_GATE_CLR_SET_UPD(CLK_TOP_GCPU, "top_gcpu",
+		gcpu_parents, 0x0C8, 0x0CC, 0x0D0, 8, 3, 15, 0x08, 25),
+	MUX_GATE_CLR_SET_UPD(CLK_TOP_DXCC, "top_dxcc",
+		dxcc_parents, 0x0C8, 0x0CC, 0x0D0, 16, 2, 23, 0x08, 26),
+	MUX_GATE_CLR_SET_UPD(CLK_TOP_DPMAIF_MAIN, "top_dpmaif_main",
+		dpmaif_parents, 0x0C8, 0x0CC, 0x0D0, 24, 3, 31, 0x08, 27),
+	/* CLK_CFG_15 */
+	MUX_GATE_CLR_SET_UPD(CLK_TOP_AES_UFSFDE, "top_aes_ufsfde",
+		aes_fde_parents, 0x0D4, 0x0D8, 0x0DC, 0, 3, 7, 0x08, 28),
+	MUX_GATE_CLR_SET_UPD(CLK_TOP_UFS, "top_ufs",
+		ufs_parents, 0x0D4, 0x0D8, 0x0DC, 8, 3, 15, 0x08, 29),
+	MUX_GATE_CLR_SET_UPD(CLK_TOP_UFS_TICK1US, "top_ufs_tick1us",
+		ufs_tick1us_parents, 0x0D4, 0x0D8, 0x0DC, 16, 1, 23, 0x08, 30),
+	MUX_GATE_CLR_SET_UPD(CLK_TOP_UFS_MP_SAP_CFG, "top_ufs_mp_sap_cfg",
+		ufs_mp_sap_parents, 0x0D4, 0x0D8, 0x0DC, 24, 1, 31, 0x08, 31),
+	/*
+	 * CLK_CFG_16
+	 * top_mcupm is main clock in other co-processor, should not be
+	 * handled by Linux.
+	 */
+	MUX_GATE_CLR_SET_UPD(CLK_TOP_VENC, "top_venc",
+		venc_parents, 0x0E0, 0x0E4, 0x0E8, 0, 4, 7, 0x0C, 0),
+	MUX_GATE_CLR_SET_UPD(CLK_TOP_VDEC, "top_vdec",
+		vdec_parents, 0x0E0, 0x0E4, 0x0E8, 8, 4, 15, 0x0C, 1),
+	MUX_GATE_CLR_SET_UPD(CLK_TOP_PWM, "top_pwm",
+		pwm_parents, 0x0E0, 0x0E4, 0x0E8, 16, 1, 23, 0x0C, 2),
+	MUX_GATE_CLR_SET_UPD_FLAGS(CLK_TOP_MCUPM, "top_mcupm",
+		mcupm_parents, 0x0E0, 0x0E4, 0x0E8, 24, 2, 31, 0x0C, 3, CLK_IS_CRITICAL),
+	/*
+	 * CLK_CFG_17
+	 * top_dvfsrc is for internal DVFS usage, should not be handled by Linux.
+	 */
+	MUX_GATE_CLR_SET_UPD(CLK_TOP_SPMI_P_MST, "top_spmi_p_mst",
+		spmi_parents, 0x0EC, 0x0F0, 0x0F4, 0, 4, 7, 0x0C, 4),
+	MUX_GATE_CLR_SET_UPD(CLK_TOP_SPMI_M_MST, "top_spmi_m_mst",
+		spmi_parents, 0x0EC, 0x0F0, 0x0F4, 8, 4, 15, 0x0C, 5),
+	MUX_GATE_CLR_SET_UPD_FLAGS(CLK_TOP_DVFSRC, "top_dvfsrc",
+		dvfsrc_parents, 0x0EC, 0x0F0, 0x0F4, 16, 2, 23, 0x0C, 6, CLK_IS_CRITICAL),
+	MUX_GATE_CLR_SET_UPD(CLK_TOP_TL, "top_tl",
+		tl_parents, 0x0EC, 0x0F0, 0x0F4, 24, 2, 31, 0x0C, 7),
+	/* CLK_CFG_18 */
+	MUX_GATE_CLR_SET_UPD(CLK_TOP_TL_P1, "top_tl_p1",
+		tl_parents, 0x0F8, 0x0FC, 0x0100, 0, 2, 7, 0x0C, 8),
+	MUX_GATE_CLR_SET_UPD(CLK_TOP_AES_MSDCFDE, "top_aes_msdcfde",
+		aes_fde_parents, 0x0F8, 0x0FC, 0x0100, 8, 3, 15, 0x0C, 9),
+	MUX_GATE_CLR_SET_UPD(CLK_TOP_DSI_OCC, "top_dsi_occ",
+		dsi_occ_parents, 0x0F8, 0x0FC, 0x0100, 16, 2, 23, 0x0C, 10),
+	MUX_GATE_CLR_SET_UPD(CLK_TOP_WPE_VPP, "top_wpe_vpp",
+		wpe_vpp_parents, 0x0F8, 0x0FC, 0x0100, 24, 4, 31, 0x0C, 11),
+	/* CLK_CFG_19 */
+	MUX_GATE_CLR_SET_UPD(CLK_TOP_HDCP, "top_hdcp",
+		hdcp_parents, 0x0104, 0x0108, 0x010C, 0, 2, 7, 0x0C, 12),
+	MUX_GATE_CLR_SET_UPD(CLK_TOP_HDCP_24M, "top_hdcp_24m",
+		hdcp_24m_parents, 0x0104, 0x0108, 0x010C, 8, 2, 15, 0x0C, 13),
+	MUX_GATE_CLR_SET_UPD(CLK_TOP_HD20_DACR_REF_CLK, "top_hd20_dacr_ref_clk",
+		hd20_dacr_ref_parents, 0x0104, 0x0108, 0x010C, 16, 2, 23, 0x0C, 14),
+	MUX_GATE_CLR_SET_UPD(CLK_TOP_HD20_HDCP_CCLK, "top_hd20_hdcp_cclk",
+		hd20_hdcp_c_parents, 0x0104, 0x0108, 0x010C, 24, 2, 31, 0x0C, 15),
+	/* CLK_CFG_20 */
+	MUX_GATE_CLR_SET_UPD(CLK_TOP_HDMI_XTAL, "top_hdmi_xtal",
+		hdmi_xtal_parents, 0x0110, 0x0114, 0x0118, 0, 1, 7, 0x0C, 16),
+	MUX_GATE_CLR_SET_UPD(CLK_TOP_HDMI_APB, "top_hdmi_apb",
+		hdmi_apb_parents, 0x0110, 0x0114, 0x0118, 8, 2, 15, 0x0C, 17),
+	MUX_GATE_CLR_SET_UPD(CLK_TOP_SNPS_ETH_250M, "top_snps_eth_250m",
+		snps_eth_250m_parents, 0x0110, 0x0114, 0x0118, 16, 1, 23, 0x0C, 18),
+	MUX_GATE_CLR_SET_UPD(CLK_TOP_SNPS_ETH_62P4M_PTP, "top_snps_eth_62p4m_ptp",
+		snps_eth_62p4m_ptp_parents, 0x0110, 0x0114, 0x0118, 24, 2, 31, 0x0C, 19),
+	/* CLK_CFG_21 */
+	MUX_GATE_CLR_SET_UPD(CLK_TOP_SNPS_ETH_50M_RMII, "snps_eth_50m_rmii",
+		snps_eth_50m_rmii_parents, 0x011C, 0x0120, 0x0124, 0, 1, 7, 0x0C, 20),
+	MUX_GATE_CLR_SET_UPD(CLK_TOP_DGI_OUT, "top_dgi_out",
+		dgi_out_parents, 0x011C, 0x0120, 0x0124, 8, 3, 15, 0x0C, 21),
+	MUX_GATE_CLR_SET_UPD(CLK_TOP_NNA0, "top_nna0",
+		nna_parents, 0x011C, 0x0120, 0x0124, 16, 4, 23, 0x0C, 22),
+	MUX_GATE_CLR_SET_UPD(CLK_TOP_NNA1, "top_nna1",
+		nna_parents, 0x011C, 0x0120, 0x0124, 24, 4, 31, 0x0C, 23),
+	/* CLK_CFG_22 */
+	MUX_GATE_CLR_SET_UPD(CLK_TOP_ADSP, "top_adsp",
+		adsp_parents, 0x0128, 0x012C, 0x0130, 0, 4, 7, 0x0C, 24),
+	MUX_GATE_CLR_SET_UPD(CLK_TOP_ASM_H, "top_asm_h",
+		asm_parents, 0x0128, 0x012C, 0x0130, 8, 2, 15, 0x0C, 25),
+	MUX_GATE_CLR_SET_UPD(CLK_TOP_ASM_M, "top_asm_m",
+		asm_parents, 0x0128, 0x012C, 0x0130, 16, 2, 23, 0x0C, 26),
+	MUX_GATE_CLR_SET_UPD(CLK_TOP_ASM_L, "top_asm_l",
+		asm_parents, 0x0128, 0x012C, 0x0130, 24, 2, 31, 0x0C, 27),
+	/* CLK_CFG_23 */
+	MUX_GATE_CLR_SET_UPD(CLK_TOP_APLL1, "top_apll1",
+		apll1_parents, 0x0134, 0x0138, 0x013C, 0, 1, 7, 0x0C, 28),
+	MUX_GATE_CLR_SET_UPD(CLK_TOP_APLL2, "top_apll2",
+		apll2_parents, 0x0134, 0x0138, 0x013C, 8, 1, 15, 0x0C, 29),
+	MUX_GATE_CLR_SET_UPD(CLK_TOP_APLL3, "top_apll3",
+		apll3_parents, 0x0134, 0x0138, 0x013C, 16, 1, 23, 0x0C, 30),
+	MUX_GATE_CLR_SET_UPD(CLK_TOP_APLL4, "top_apll4",
+		apll4_parents, 0x0134, 0x0138, 0x013C, 24, 1, 31, 0x0C, 31),
+	/*
+	 * CLK_CFG_24
+	 * i2so4_mck is not used in MT8195.
+	 */
+	MUX_GATE_CLR_SET_UPD(CLK_TOP_APLL5, "top_apll5",
+		apll5_parents, 0x0140, 0x0144, 0x0148, 0, 1, 7, 0x010, 0),
+	MUX_GATE_CLR_SET_UPD(CLK_TOP_I2SO1_MCK, "top_i2so1_mck",
+		i2s_parents, 0x0140, 0x0144, 0x0148, 8, 3, 15, 0x010, 1),
+	MUX_GATE_CLR_SET_UPD(CLK_TOP_I2SO2_MCK, "top_i2so2_mck",
+		i2s_parents, 0x0140, 0x0144, 0x0148, 16, 3, 23, 0x010, 2),
+	/*
+	 * CLK_CFG_25
+	 * i2so5_mck and i2si4_mck are not used in MT8195.
+	 */
+	MUX_GATE_CLR_SET_UPD(CLK_TOP_I2SI1_MCK, "top_i2si1_mck",
+		i2s_parents, 0x014C, 0x0150, 0x0154, 8, 3, 15, 0x010, 5),
+	MUX_GATE_CLR_SET_UPD(CLK_TOP_I2SI2_MCK, "top_i2si2_mck",
+		i2s_parents, 0x014C, 0x0150, 0x0154, 16, 3, 23, 0x010, 6),
+	/*
+	 * CLK_CFG_26
+	 * i2si5_mck is not used in MT8195.
+	 */
+	MUX_GATE_CLR_SET_UPD(CLK_TOP_DPTX_MCK, "top_dptx_mck",
+		i2s_parents, 0x0158, 0x015C, 0x0160, 8, 3, 15, 0x010, 9),
+	MUX_GATE_CLR_SET_UPD(CLK_TOP_AUD_IEC_CLK, "top_aud_iec_clk",
+		i2s_parents, 0x0158, 0x015C, 0x0160, 16, 3, 23, 0x010, 10),
+	MUX_GATE_CLR_SET_UPD(CLK_TOP_A1SYS_HP, "top_a1sys_hp",
+		a1sys_hp_parents, 0x0158, 0x015C, 0x0160, 24, 1, 31, 0x010, 11),
+	/* CLK_CFG_27 */
+	MUX_GATE_CLR_SET_UPD(CLK_TOP_A2SYS_HF, "top_a2sys_hf",
+		a2sys_parents, 0x0164, 0x0168, 0x016C, 0, 1, 7, 0x010, 12),
+	MUX_GATE_CLR_SET_UPD(CLK_TOP_A3SYS_HF, "top_a3sys_hf",
+		a3sys_parents, 0x0164, 0x0168, 0x016C, 8, 3, 15, 0x010, 13),
+	MUX_GATE_CLR_SET_UPD(CLK_TOP_A4SYS_HF, "top_a4sys_hf",
+		a3sys_parents, 0x0164, 0x0168, 0x016C, 16, 3, 23, 0x010, 14),
+	MUX_GATE_CLR_SET_UPD(CLK_TOP_SPINFI_BCLK, "top_spinfi_bclk",
+		spinfi_b_parents, 0x0164, 0x0168, 0x016C, 24, 3, 31, 0x010, 15),
+	/* CLK_CFG_28 */
+	MUX_GATE_CLR_SET_UPD(CLK_TOP_NFI1X, "top_nfi1x",
+		nfi1x_parents, 0x0170, 0x0174, 0x0178, 0, 3, 7, 0x010, 16),
+	MUX_GATE_CLR_SET_UPD(CLK_TOP_ECC, "top_ecc",
+		ecc_parents, 0x0170, 0x0174, 0x0178, 8, 3, 15, 0x010, 17),
+	MUX_GATE_CLR_SET_UPD(CLK_TOP_AUDIO_LOCAL_BUS, "top_audio_local_bus",
+		audio_local_bus_parents, 0x0170, 0x0174, 0x0178, 16, 4, 23, 0x010, 18),
+	MUX_GATE_CLR_SET_UPD(CLK_TOP_SPINOR, "top_spinor",
+		spinor_parents, 0x0170, 0x0174, 0x0178, 24, 2, 31, 0x010, 19),
+	/*
+	 * CLK_CFG_29
+	 * top_ulposc/top_ulposc_core/top_srck are clock source of always on co-processor,
+	 * should not be closed by Linux.
+	 */
+	MUX_GATE_CLR_SET_UPD(CLK_TOP_DVIO_DGI_REF, "top_dvio_dgi_ref",
+		dvio_dgi_ref_parents, 0x017C, 0x0180, 0x0184, 0, 3, 7, 0x010, 20),
+	MUX_GATE_CLR_SET_UPD_FLAGS(CLK_TOP_ULPOSC, "top_ulposc",
+		ulposc_parents, 0x017C, 0x0180, 0x0184, 8, 2, 15, 0x010, 21, CLK_IS_CRITICAL),
+	MUX_GATE_CLR_SET_UPD_FLAGS(CLK_TOP_ULPOSC_CORE, "top_ulposc_core",
+		ulposc_core_parents, 0x017C, 0x0180, 0x0184, 16, 2, 23, 0x010, 22, CLK_IS_CRITICAL),
+	MUX_GATE_CLR_SET_UPD_FLAGS(CLK_TOP_SRCK, "top_srck",
+		srck_parents, 0x017C, 0x0180, 0x0184, 24, 1, 31, 0x010, 23, CLK_IS_CRITICAL),
+	/*
+	 * the clocks in CLK_CFG_30 ~ 37 are backup clock source, no need to handled
+	 * by Linux.
+	 */
+};
+
+static struct mtk_composite top_muxes[] = {
+	/* CLK_MISC_CFG_3 */
+	MUX(CLK_TOP_MFG_CK_FAST_REF, "mfg_ck_fast_ref", mfg_fast_parents, 0x0250, 8, 1),
+};
+
+static const struct mtk_composite top_adj_divs[] = {
+	DIV_GATE(CLK_TOP_APLL12_DIV0, "apll12_div0", "top_i2si1_mck", 0x0320, 0, 0x0328, 8, 0),
+	DIV_GATE(CLK_TOP_APLL12_DIV1, "apll12_div1", "top_i2si2_mck", 0x0320, 1, 0x0328, 8, 8),
+	DIV_GATE(CLK_TOP_APLL12_DIV2, "apll12_div2", "top_i2so1_mck", 0x0320, 2, 0x0328, 8, 16),
+	DIV_GATE(CLK_TOP_APLL12_DIV3, "apll12_div3", "top_i2so2_mck", 0x0320, 3, 0x0328, 8, 24),
+	DIV_GATE(CLK_TOP_APLL12_DIV4, "apll12_div4", "top_aud_iec_clk", 0x0320, 4, 0x0334, 8, 0),
+	/* apll12_div5 ~ 8 are not used in MT8195. */
+	DIV_GATE(CLK_TOP_APLL12_DIV9, "apll12_div9", "top_dptx_mck", 0x0320, 9, 0x0338, 8, 8),
+};
+
+static const struct mtk_gate_regs top0_cg_regs = {
+	.set_ofs = 0x238,
+	.clr_ofs = 0x238,
+	.sta_ofs = 0x238,
+};
+
+static const struct mtk_gate_regs top1_cg_regs = {
+	.set_ofs = 0x250,
+	.clr_ofs = 0x250,
+	.sta_ofs = 0x250,
+};
+
+#define GATE_TOP0_FLAGS(_id, _name, _parent, _shift, _flag)		\
+	GATE_MTK_FLAGS(_id, _name, _parent, &top0_cg_regs, _shift,	\
+		&mtk_clk_gate_ops_no_setclr_inv, _flag)
+
+#define GATE_TOP0(_id, _name, _parent, _shift)			\
+	GATE_TOP0_FLAGS(_id, _name, _parent, _shift, 0)
+
+#define GATE_TOP1(_id, _name, _parent, _shift)			\
+	GATE_MTK(_id, _name, _parent, &top1_cg_regs, _shift, &mtk_clk_gate_ops_no_setclr_inv)
+
+static const struct mtk_gate top_clks[] = {
+	/* TOP0 */
+	GATE_TOP0(CLK_TOP_CFG_VPP0, "cfg_vpp0", "top_vpp", 0),
+	GATE_TOP0(CLK_TOP_CFG_VPP1, "cfg_vpp1", "top_vpp", 1),
+	GATE_TOP0(CLK_TOP_CFG_VDO0, "cfg_vdo0", "top_vpp", 2),
+	GATE_TOP0(CLK_TOP_CFG_VDO1, "cfg_vdo1", "top_vpp", 3),
+	GATE_TOP0(CLK_TOP_CFG_UNIPLL_SES, "cfg_unipll_ses", "univpll_d2", 4),
+	GATE_TOP0(CLK_TOP_CFG_26M_VPP0, "cfg_26m_vpp0", "clk26m", 5),
+	GATE_TOP0(CLK_TOP_CFG_26M_VPP1, "cfg_26m_vpp1", "clk26m", 6),
+	GATE_TOP0(CLK_TOP_CFG_26M_AUD, "cfg_26m_aud", "clk26m", 9),
+	/*
+	 * cfg_axi_east, cfg_axi_east_north, cfg_axi_north and cfg_axi_south
+	 * are peripheral bus clock branches.
+	 */
+	GATE_TOP0_FLAGS(CLK_TOP_CFG_AXI_EAST, "cfg_axi_east", "top_axi", 10, CLK_IS_CRITICAL),
+	GATE_TOP0_FLAGS(CLK_TOP_CFG_AXI_EAST_NORTH, "cfg_axi_east_north", "top_axi", 11,
+		CLK_IS_CRITICAL),
+	GATE_TOP0_FLAGS(CLK_TOP_CFG_AXI_NORTH, "cfg_axi_north", "top_axi", 12, CLK_IS_CRITICAL),
+	GATE_TOP0_FLAGS(CLK_TOP_CFG_AXI_SOUTH, "cfg_axi_south", "top_axi", 13, CLK_IS_CRITICAL),
+	GATE_TOP0(CLK_TOP_CFG_EXT_TEST, "cfg_ext_test", "msdcpll_d2", 15),
+	/* TOP1 */
+	GATE_TOP1(CLK_TOP_SSUSB_REF, "ssusb_ref", "clk26m", 0),
+	GATE_TOP1(CLK_TOP_SSUSB_PHY_REF, "ssusb_phy_ref", "clk26m", 1),
+	GATE_TOP1(CLK_TOP_SSUSB_P1_REF, "ssusb_p1_ref", "clk26m", 2),
+	GATE_TOP1(CLK_TOP_SSUSB_PHY_P1_REF, "ssusb_phy_p1_ref", "clk26m", 3),
+	GATE_TOP1(CLK_TOP_SSUSB_P2_REF, "ssusb_p2_ref", "clk26m", 4),
+	GATE_TOP1(CLK_TOP_SSUSB_PHY_P2_REF, "ssusb_phy_p2_ref", "clk26m", 5),
+	GATE_TOP1(CLK_TOP_SSUSB_P3_REF, "ssusb_p3_ref", "clk26m", 6),
+	GATE_TOP1(CLK_TOP_SSUSB_PHY_P3_REF, "ssusb_phy_p3_ref", "clk26m", 7),
+};
+
+static const struct of_device_id of_match_clk_mt8195_topck[] = {
+	{ .compatible = "mediatek,mt8195-topckgen", },
+	{}
+};
+
+static int clk_mt8195_topck_probe(struct platform_device *pdev)
+{
+	struct clk_onecell_data *top_clk_data;
+	struct device_node *node = pdev->dev.of_node;
+	int r;
+	void __iomem *base;
+
+	top_clk_data = mtk_alloc_clk_data(CLK_TOP_NR_CLK);
+	if (!top_clk_data)
+		return -ENOMEM;
+
+	base = devm_platform_ioremap_resource(pdev, 0);
+	if (IS_ERR(base)) {
+		r = PTR_ERR(base);
+		goto free_top_data;
+	}
+
+	mtk_clk_register_fixed_clks(top_fixed_clks, ARRAY_SIZE(top_fixed_clks),
+				    top_clk_data);
+	mtk_clk_register_factors(top_divs, ARRAY_SIZE(top_divs), top_clk_data);
+	mtk_clk_register_muxes(top_mtk_muxes, ARRAY_SIZE(top_mtk_muxes), node,
+			       &mt8195_clk_lock, top_clk_data);
+	mtk_clk_register_composites(top_muxes, ARRAY_SIZE(top_muxes), base,
+				    &mt8195_clk_lock, top_clk_data);
+	mtk_clk_register_composites(top_adj_divs, ARRAY_SIZE(top_adj_divs), base,
+				    &mt8195_clk_lock, top_clk_data);
+	r = mtk_clk_register_gates(node, top_clks, ARRAY_SIZE(top_clks), top_clk_data);
+	if (r)
+		goto free_top_data;
+
+	r = of_clk_add_provider(node, of_clk_src_onecell_get, top_clk_data);
+	if (r)
+		goto free_top_data;
+
+	return r;
+
+free_top_data:
+	mtk_free_clk_data(top_clk_data);
+	return r;
+}
+
+static struct platform_driver clk_mt8195_topck_drv = {
+	.probe = clk_mt8195_topck_probe,
+	.driver = {
+		.name = "clk-mt8195-topck",
+		.of_match_table = of_match_clk_mt8195_topck,
+	},
+};
+builtin_platform_driver(clk_mt8195_topck_drv);
diff --git a/drivers/clk/mediatek/clk-mt8195-vdec.c b/drivers/clk/mediatek/clk-mt8195-vdec.c
new file mode 100644
index 0000000000000000000000000000000000000000..a1df04f42a906c6d036eac81c98bb7b935b7a56a
--- /dev/null
+++ b/drivers/clk/mediatek/clk-mt8195-vdec.c
@@ -0,0 +1,104 @@
+// SPDX-License-Identifier: GPL-2.0-only
+//
+// Copyright (c) 2021 MediaTek Inc.
+// Author: Chun-Jie Chen <chun-jie.chen@mediatek.com>
+
+#include "clk-gate.h"
+#include "clk-mtk.h"
+
+#include <dt-bindings/clock/mt8195-clk.h>
+#include <linux/clk-provider.h>
+#include <linux/platform_device.h>
+
+static const struct mtk_gate_regs vdec0_cg_regs = {
+	.set_ofs = 0x0,
+	.clr_ofs = 0x4,
+	.sta_ofs = 0x0,
+};
+
+static const struct mtk_gate_regs vdec1_cg_regs = {
+	.set_ofs = 0x200,
+	.clr_ofs = 0x204,
+	.sta_ofs = 0x200,
+};
+
+static const struct mtk_gate_regs vdec2_cg_regs = {
+	.set_ofs = 0x8,
+	.clr_ofs = 0xc,
+	.sta_ofs = 0x8,
+};
+
+#define GATE_VDEC0(_id, _name, _parent, _shift)			\
+	GATE_MTK(_id, _name, _parent, &vdec0_cg_regs, _shift, &mtk_clk_gate_ops_setclr_inv)
+
+#define GATE_VDEC1(_id, _name, _parent, _shift)			\
+	GATE_MTK(_id, _name, _parent, &vdec1_cg_regs, _shift, &mtk_clk_gate_ops_setclr_inv)
+
+#define GATE_VDEC2(_id, _name, _parent, _shift)			\
+	GATE_MTK(_id, _name, _parent, &vdec2_cg_regs, _shift, &mtk_clk_gate_ops_setclr_inv)
+
+static const struct mtk_gate vdec_clks[] = {
+	/* VDEC0 */
+	GATE_VDEC0(CLK_VDEC_VDEC, "vdec_vdec", "top_vdec", 0),
+	/* VDEC1 */
+	GATE_VDEC1(CLK_VDEC_LAT, "vdec_lat", "top_vdec", 0),
+	/* VDEC2 */
+	GATE_VDEC2(CLK_VDEC_LARB1, "vdec_larb1", "top_vdec", 0),
+};
+
+static const struct mtk_gate vdec_core1_clks[] = {
+	/* VDEC0 */
+	GATE_VDEC0(CLK_VDEC_CORE1_VDEC, "vdec_core1_vdec", "top_vdec", 0),
+	/* VDEC1 */
+	GATE_VDEC1(CLK_VDEC_CORE1_LAT, "vdec_core1_lat", "top_vdec", 0),
+	/* VDEC2 */
+	GATE_VDEC2(CLK_VDEC_CORE1_LARB1, "vdec_core1_larb1", "top_vdec", 0),
+};
+
+static const struct mtk_gate vdec_soc_clks[] = {
+	/* VDEC0 */
+	GATE_VDEC0(CLK_VDEC_SOC_VDEC, "vdec_soc_vdec", "top_vdec", 0),
+	/* VDEC1 */
+	GATE_VDEC1(CLK_VDEC_SOC_LAT, "vdec_soc_lat", "top_vdec", 0),
+	/* VDEC2 */
+	GATE_VDEC2(CLK_VDEC_SOC_LARB1, "vdec_soc_larb1", "top_vdec", 0),
+};
+
+static const struct mtk_clk_desc vdec_desc = {
+	.clks = vdec_clks,
+	.num_clks = ARRAY_SIZE(vdec_clks),
+};
+
+static const struct mtk_clk_desc vdec_core1_desc = {
+	.clks = vdec_core1_clks,
+	.num_clks = ARRAY_SIZE(vdec_core1_clks),
+};
+
+static const struct mtk_clk_desc vdec_soc_desc = {
+	.clks = vdec_soc_clks,
+	.num_clks = ARRAY_SIZE(vdec_soc_clks),
+};
+
+static const struct of_device_id of_match_clk_mt8195_vdec[] = {
+	{
+		.compatible = "mediatek,mt8195-vdecsys",
+		.data = &vdec_desc,
+	}, {
+		.compatible = "mediatek,mt8195-vdecsys_core1",
+		.data = &vdec_core1_desc,
+	}, {
+		.compatible = "mediatek,mt8195-vdecsys_soc",
+		.data = &vdec_soc_desc,
+	}, {
+		/* sentinel */
+	}
+};
+
+static struct platform_driver clk_mt8195_vdec_drv = {
+	.probe = mtk_clk_simple_probe,
+	.driver = {
+		.name = "clk-mt8195-vdec",
+		.of_match_table = of_match_clk_mt8195_vdec,
+	},
+};
+builtin_platform_driver(clk_mt8195_vdec_drv);
diff --git a/drivers/clk/mediatek/clk-mt8195-vdo0.c b/drivers/clk/mediatek/clk-mt8195-vdo0.c
new file mode 100644
index 0000000000000000000000000000000000000000..f7ff7618c714a1b2769ed2346079c563de427bd7
--- /dev/null
+++ b/drivers/clk/mediatek/clk-mt8195-vdo0.c
@@ -0,0 +1,123 @@
+// SPDX-License-Identifier: GPL-2.0-only
+//
+// Copyright (c) 2021 MediaTek Inc.
+// Author: Chun-Jie Chen <chun-jie.chen@mediatek.com>
+
+#include "clk-gate.h"
+#include "clk-mtk.h"
+
+#include <dt-bindings/clock/mt8195-clk.h>
+#include <linux/clk-provider.h>
+#include <linux/platform_device.h>
+
+static const struct mtk_gate_regs vdo0_0_cg_regs = {
+	.set_ofs = 0x104,
+	.clr_ofs = 0x108,
+	.sta_ofs = 0x100,
+};
+
+static const struct mtk_gate_regs vdo0_1_cg_regs = {
+	.set_ofs = 0x114,
+	.clr_ofs = 0x118,
+	.sta_ofs = 0x110,
+};
+
+static const struct mtk_gate_regs vdo0_2_cg_regs = {
+	.set_ofs = 0x124,
+	.clr_ofs = 0x128,
+	.sta_ofs = 0x120,
+};
+
+#define GATE_VDO0_0(_id, _name, _parent, _shift)			\
+	GATE_MTK(_id, _name, _parent, &vdo0_0_cg_regs, _shift, &mtk_clk_gate_ops_setclr)
+
+#define GATE_VDO0_1(_id, _name, _parent, _shift)			\
+	GATE_MTK(_id, _name, _parent, &vdo0_1_cg_regs, _shift, &mtk_clk_gate_ops_setclr)
+
+#define GATE_VDO0_2(_id, _name, _parent, _shift)			\
+	GATE_MTK(_id, _name, _parent, &vdo0_2_cg_regs, _shift, &mtk_clk_gate_ops_setclr)
+
+static const struct mtk_gate vdo0_clks[] = {
+	/* VDO0_0 */
+	GATE_VDO0_0(CLK_VDO0_DISP_OVL0, "vdo0_disp_ovl0", "top_vpp", 0),
+	GATE_VDO0_0(CLK_VDO0_DISP_COLOR0, "vdo0_disp_color0", "top_vpp", 2),
+	GATE_VDO0_0(CLK_VDO0_DISP_COLOR1, "vdo0_disp_color1", "top_vpp", 3),
+	GATE_VDO0_0(CLK_VDO0_DISP_CCORR0, "vdo0_disp_ccorr0", "top_vpp", 4),
+	GATE_VDO0_0(CLK_VDO0_DISP_CCORR1, "vdo0_disp_ccorr1", "top_vpp", 5),
+	GATE_VDO0_0(CLK_VDO0_DISP_AAL0, "vdo0_disp_aal0", "top_vpp", 6),
+	GATE_VDO0_0(CLK_VDO0_DISP_AAL1, "vdo0_disp_aal1", "top_vpp", 7),
+	GATE_VDO0_0(CLK_VDO0_DISP_GAMMA0, "vdo0_disp_gamma0", "top_vpp", 8),
+	GATE_VDO0_0(CLK_VDO0_DISP_GAMMA1, "vdo0_disp_gamma1", "top_vpp", 9),
+	GATE_VDO0_0(CLK_VDO0_DISP_DITHER0, "vdo0_disp_dither0", "top_vpp", 10),
+	GATE_VDO0_0(CLK_VDO0_DISP_DITHER1, "vdo0_disp_dither1", "top_vpp", 11),
+	GATE_VDO0_0(CLK_VDO0_DISP_OVL1, "vdo0_disp_ovl1", "top_vpp", 16),
+	GATE_VDO0_0(CLK_VDO0_DISP_WDMA0, "vdo0_disp_wdma0", "top_vpp", 17),
+	GATE_VDO0_0(CLK_VDO0_DISP_WDMA1, "vdo0_disp_wdma1", "top_vpp", 18),
+	GATE_VDO0_0(CLK_VDO0_DISP_RDMA0, "vdo0_disp_rdma0", "top_vpp", 19),
+	GATE_VDO0_0(CLK_VDO0_DISP_RDMA1, "vdo0_disp_rdma1", "top_vpp", 20),
+	GATE_VDO0_0(CLK_VDO0_DSI0, "vdo0_dsi0", "top_vpp", 21),
+	GATE_VDO0_0(CLK_VDO0_DSI1, "vdo0_dsi1", "top_vpp", 22),
+	GATE_VDO0_0(CLK_VDO0_DSC_WRAP0, "vdo0_dsc_wrap0", "top_vpp", 23),
+	GATE_VDO0_0(CLK_VDO0_VPP_MERGE0, "vdo0_vpp_merge0", "top_vpp", 24),
+	GATE_VDO0_0(CLK_VDO0_DP_INTF0, "vdo0_dp_intf0", "top_vpp", 25),
+	GATE_VDO0_0(CLK_VDO0_DISP_MUTEX0, "vdo0_disp_mutex0", "top_vpp", 26),
+	GATE_VDO0_0(CLK_VDO0_DISP_IL_ROT0, "vdo0_disp_il_rot0", "top_vpp", 27),
+	GATE_VDO0_0(CLK_VDO0_APB_BUS, "vdo0_apb_bus", "top_vpp", 28),
+	GATE_VDO0_0(CLK_VDO0_FAKE_ENG0, "vdo0_fake_eng0", "top_vpp", 29),
+	GATE_VDO0_0(CLK_VDO0_FAKE_ENG1, "vdo0_fake_eng1", "top_vpp", 30),
+	/* VDO0_1 */
+	GATE_VDO0_1(CLK_VDO0_DL_ASYNC0, "vdo0_dl_async0", "top_vpp", 0),
+	GATE_VDO0_1(CLK_VDO0_DL_ASYNC1, "vdo0_dl_async1", "top_vpp", 1),
+	GATE_VDO0_1(CLK_VDO0_DL_ASYNC2, "vdo0_dl_async2", "top_vpp", 2),
+	GATE_VDO0_1(CLK_VDO0_DL_ASYNC3, "vdo0_dl_async3", "top_vpp", 3),
+	GATE_VDO0_1(CLK_VDO0_DL_ASYNC4, "vdo0_dl_async4", "top_vpp", 4),
+	GATE_VDO0_1(CLK_VDO0_DISP_MONITOR0, "vdo0_disp_monitor0", "top_vpp", 5),
+	GATE_VDO0_1(CLK_VDO0_DISP_MONITOR1, "vdo0_disp_monitor1", "top_vpp", 6),
+	GATE_VDO0_1(CLK_VDO0_DISP_MONITOR2, "vdo0_disp_monitor2", "top_vpp", 7),
+	GATE_VDO0_1(CLK_VDO0_DISP_MONITOR3, "vdo0_disp_monitor3", "top_vpp", 8),
+	GATE_VDO0_1(CLK_VDO0_DISP_MONITOR4, "vdo0_disp_monitor4", "top_vpp", 9),
+	GATE_VDO0_1(CLK_VDO0_SMI_GALS, "vdo0_smi_gals", "top_vpp", 10),
+	GATE_VDO0_1(CLK_VDO0_SMI_COMMON, "vdo0_smi_common", "top_vpp", 11),
+	GATE_VDO0_1(CLK_VDO0_SMI_EMI, "vdo0_smi_emi", "top_vpp", 12),
+	GATE_VDO0_1(CLK_VDO0_SMI_IOMMU, "vdo0_smi_iommu", "top_vpp", 13),
+	GATE_VDO0_1(CLK_VDO0_SMI_LARB, "vdo0_smi_larb", "top_vpp", 14),
+	GATE_VDO0_1(CLK_VDO0_SMI_RSI, "vdo0_smi_rsi", "top_vpp", 15),
+	/* VDO0_2 */
+	GATE_VDO0_2(CLK_VDO0_DSI0_DSI, "vdo0_dsi0_dsi", "top_dsi_occ", 0),
+	GATE_VDO0_2(CLK_VDO0_DSI1_DSI, "vdo0_dsi1_dsi", "top_dsi_occ", 8),
+	GATE_VDO0_2(CLK_VDO0_DP_INTF0_DP_INTF, "vdo0_dp_intf0_dp_intf", "top_edp", 16),
+};
+
+static int clk_mt8195_vdo0_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct device_node *node = dev->parent->of_node;
+	struct clk_onecell_data *clk_data;
+	int r;
+
+	clk_data = mtk_alloc_clk_data(CLK_VDO0_NR_CLK);
+	if (!clk_data)
+		return -ENOMEM;
+
+	r = mtk_clk_register_gates(node, vdo0_clks, ARRAY_SIZE(vdo0_clks), clk_data);
+	if (r)
+		goto free_vdo0_data;
+
+	r = of_clk_add_provider(node, of_clk_src_onecell_get, clk_data);
+	if (r)
+		goto free_vdo0_data;
+
+	return r;
+
+free_vdo0_data:
+	mtk_free_clk_data(clk_data);
+	return r;
+}
+
+static struct platform_driver clk_mt8195_vdo0_drv = {
+	.probe = clk_mt8195_vdo0_probe,
+	.driver = {
+		.name = "clk-mt8195-vdo0",
+	},
+};
+builtin_platform_driver(clk_mt8195_vdo0_drv);
diff --git a/drivers/clk/mediatek/clk-mt8195-vdo1.c b/drivers/clk/mediatek/clk-mt8195-vdo1.c
new file mode 100644
index 0000000000000000000000000000000000000000..03df8eae88382abdd41afdd5d924bd316720054f
--- /dev/null
+++ b/drivers/clk/mediatek/clk-mt8195-vdo1.c
@@ -0,0 +1,140 @@
+// SPDX-License-Identifier: GPL-2.0-only
+//
+// Copyright (c) 2021 MediaTek Inc.
+// Author: Chun-Jie Chen <chun-jie.chen@mediatek.com>
+
+#include "clk-gate.h"
+#include "clk-mtk.h"
+
+#include <dt-bindings/clock/mt8195-clk.h>
+#include <linux/clk-provider.h>
+#include <linux/platform_device.h>
+
+static const struct mtk_gate_regs vdo1_0_cg_regs = {
+	.set_ofs = 0x104,
+	.clr_ofs = 0x108,
+	.sta_ofs = 0x100,
+};
+
+static const struct mtk_gate_regs vdo1_1_cg_regs = {
+	.set_ofs = 0x124,
+	.clr_ofs = 0x128,
+	.sta_ofs = 0x120,
+};
+
+static const struct mtk_gate_regs vdo1_2_cg_regs = {
+	.set_ofs = 0x134,
+	.clr_ofs = 0x138,
+	.sta_ofs = 0x130,
+};
+
+static const struct mtk_gate_regs vdo1_3_cg_regs = {
+	.set_ofs = 0x144,
+	.clr_ofs = 0x148,
+	.sta_ofs = 0x140,
+};
+
+#define GATE_VDO1_0(_id, _name, _parent, _shift)			\
+	GATE_MTK(_id, _name, _parent, &vdo1_0_cg_regs, _shift, &mtk_clk_gate_ops_setclr)
+
+#define GATE_VDO1_1(_id, _name, _parent, _shift)			\
+	GATE_MTK(_id, _name, _parent, &vdo1_1_cg_regs, _shift, &mtk_clk_gate_ops_setclr)
+
+#define GATE_VDO1_2(_id, _name, _parent, _shift)			\
+	GATE_MTK(_id, _name, _parent, &vdo1_2_cg_regs, _shift, &mtk_clk_gate_ops_setclr)
+
+#define GATE_VDO1_3(_id, _name, _parent, _shift)			\
+	GATE_MTK(_id, _name, _parent, &vdo1_3_cg_regs, _shift, &mtk_clk_gate_ops_setclr)
+
+static const struct mtk_gate vdo1_clks[] = {
+	/* VDO1_0 */
+	GATE_VDO1_0(CLK_VDO1_SMI_LARB2, "vdo1_smi_larb2", "top_vpp", 0),
+	GATE_VDO1_0(CLK_VDO1_SMI_LARB3, "vdo1_smi_larb3", "top_vpp", 1),
+	GATE_VDO1_0(CLK_VDO1_GALS, "vdo1_gals", "top_vpp", 2),
+	GATE_VDO1_0(CLK_VDO1_FAKE_ENG0, "vdo1_fake_eng0", "top_vpp", 3),
+	GATE_VDO1_0(CLK_VDO1_FAKE_ENG, "vdo1_fake_eng", "top_vpp", 4),
+	GATE_VDO1_0(CLK_VDO1_MDP_RDMA0, "vdo1_mdp_rdma0", "top_vpp", 5),
+	GATE_VDO1_0(CLK_VDO1_MDP_RDMA1, "vdo1_mdp_rdma1", "top_vpp", 6),
+	GATE_VDO1_0(CLK_VDO1_MDP_RDMA2, "vdo1_mdp_rdma2", "top_vpp", 7),
+	GATE_VDO1_0(CLK_VDO1_MDP_RDMA3, "vdo1_mdp_rdma3", "top_vpp", 8),
+	GATE_VDO1_0(CLK_VDO1_VPP_MERGE0, "vdo1_vpp_merge0", "top_vpp", 9),
+	GATE_VDO1_0(CLK_VDO1_VPP_MERGE1, "vdo1_vpp_merge1", "top_vpp", 10),
+	GATE_VDO1_0(CLK_VDO1_VPP_MERGE2, "vdo1_vpp_merge2", "top_vpp", 11),
+	GATE_VDO1_0(CLK_VDO1_VPP_MERGE3, "vdo1_vpp_merge3", "top_vpp", 12),
+	GATE_VDO1_0(CLK_VDO1_VPP_MERGE4, "vdo1_vpp_merge4", "top_vpp", 13),
+	GATE_VDO1_0(CLK_VDO1_VPP2_TO_VDO1_DL_ASYNC, "vdo1_vpp2_to_vdo1_dl_async", "top_vpp", 14),
+	GATE_VDO1_0(CLK_VDO1_VPP3_TO_VDO1_DL_ASYNC, "vdo1_vpp3_to_vdo1_dl_async", "top_vpp", 15),
+	GATE_VDO1_0(CLK_VDO1_DISP_MUTEX, "vdo1_disp_mutex", "top_vpp", 16),
+	GATE_VDO1_0(CLK_VDO1_MDP_RDMA4, "vdo1_mdp_rdma4", "top_vpp", 17),
+	GATE_VDO1_0(CLK_VDO1_MDP_RDMA5, "vdo1_mdp_rdma5", "top_vpp", 18),
+	GATE_VDO1_0(CLK_VDO1_MDP_RDMA6, "vdo1_mdp_rdma6", "top_vpp", 19),
+	GATE_VDO1_0(CLK_VDO1_MDP_RDMA7, "vdo1_mdp_rdma7", "top_vpp", 20),
+	GATE_VDO1_0(CLK_VDO1_DP_INTF0_MM, "vdo1_dp_intf0_mm", "top_vpp", 21),
+	GATE_VDO1_0(CLK_VDO1_DPI0_MM, "vdo1_dpi0_mm", "top_vpp", 22),
+	GATE_VDO1_0(CLK_VDO1_DPI1_MM, "vdo1_dpi1_mm", "top_vpp", 23),
+	GATE_VDO1_0(CLK_VDO1_DISP_MONITOR, "vdo1_disp_monitor", "top_vpp", 24),
+	GATE_VDO1_0(CLK_VDO1_MERGE0_DL_ASYNC, "vdo1_merge0_dl_async", "top_vpp", 25),
+	GATE_VDO1_0(CLK_VDO1_MERGE1_DL_ASYNC, "vdo1_merge1_dl_async", "top_vpp", 26),
+	GATE_VDO1_0(CLK_VDO1_MERGE2_DL_ASYNC, "vdo1_merge2_dl_async", "top_vpp", 27),
+	GATE_VDO1_0(CLK_VDO1_MERGE3_DL_ASYNC, "vdo1_merge3_dl_async", "top_vpp", 28),
+	GATE_VDO1_0(CLK_VDO1_MERGE4_DL_ASYNC, "vdo1_merge4_dl_async", "top_vpp", 29),
+	GATE_VDO1_0(CLK_VDO1_VDO0_DSC_TO_VDO1_DL_ASYNC, "vdo1_vdo0_dsc_to_vdo1_dl_async",
+		    "top_vpp", 30),
+	GATE_VDO1_0(CLK_VDO1_VDO0_MERGE_TO_VDO1_DL_ASYNC, "vdo1_vdo0_merge_to_vdo1_dl_async",
+		    "top_vpp", 31),
+	/* VDO1_1 */
+	GATE_VDO1_1(CLK_VDO1_HDR_VDO_FE0, "vdo1_hdr_vdo_fe0", "top_vpp", 0),
+	GATE_VDO1_1(CLK_VDO1_HDR_GFX_FE0, "vdo1_hdr_gfx_fe0", "top_vpp", 1),
+	GATE_VDO1_1(CLK_VDO1_HDR_VDO_BE, "vdo1_hdr_vdo_be", "top_vpp", 2),
+	GATE_VDO1_1(CLK_VDO1_HDR_VDO_FE1, "vdo1_hdr_vdo_fe1", "top_vpp", 16),
+	GATE_VDO1_1(CLK_VDO1_HDR_GFX_FE1, "vdo1_hdr_gfx_fe1", "top_vpp", 17),
+	GATE_VDO1_1(CLK_VDO1_DISP_MIXER, "vdo1_disp_mixer", "top_vpp", 18),
+	GATE_VDO1_1(CLK_VDO1_HDR_VDO_FE0_DL_ASYNC, "vdo1_hdr_vdo_fe0_dl_async", "top_vpp", 19),
+	GATE_VDO1_1(CLK_VDO1_HDR_VDO_FE1_DL_ASYNC, "vdo1_hdr_vdo_fe1_dl_async", "top_vpp", 20),
+	GATE_VDO1_1(CLK_VDO1_HDR_GFX_FE0_DL_ASYNC, "vdo1_hdr_gfx_fe0_dl_async", "top_vpp", 21),
+	GATE_VDO1_1(CLK_VDO1_HDR_GFX_FE1_DL_ASYNC, "vdo1_hdr_gfx_fe1_dl_async", "top_vpp", 22),
+	GATE_VDO1_1(CLK_VDO1_HDR_VDO_BE_DL_ASYNC, "vdo1_hdr_vdo_be_dl_async", "top_vpp", 23),
+	/* VDO1_2 */
+	GATE_VDO1_2(CLK_VDO1_DPI0, "vdo1_dpi0", "top_vpp", 0),
+	GATE_VDO1_2(CLK_VDO1_DISP_MONITOR_DPI0, "vdo1_disp_monitor_dpi0", "top_vpp", 1),
+	GATE_VDO1_2(CLK_VDO1_DPI1, "vdo1_dpi1", "top_vpp", 8),
+	GATE_VDO1_2(CLK_VDO1_DISP_MONITOR_DPI1, "vdo1_disp_monitor_dpi1", "top_vpp", 9),
+	GATE_VDO1_2(CLK_VDO1_DPINTF, "vdo1_dpintf", "top_vpp", 16),
+	GATE_VDO1_2(CLK_VDO1_DISP_MONITOR_DPINTF, "vdo1_disp_monitor_dpintf", "top_vpp", 17),
+	/* VDO1_3 */
+	GATE_VDO1_3(CLK_VDO1_26M_SLOW, "vdo1_26m_slow", "clk26m", 8),
+};
+
+static int clk_mt8195_vdo1_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct device_node *node = dev->parent->of_node;
+	struct clk_onecell_data *clk_data;
+	int r;
+
+	clk_data = mtk_alloc_clk_data(CLK_VDO1_NR_CLK);
+	if (!clk_data)
+		return -ENOMEM;
+
+	r = mtk_clk_register_gates(node, vdo1_clks, ARRAY_SIZE(vdo1_clks), clk_data);
+	if (r)
+		goto free_vdo1_data;
+
+	r = of_clk_add_provider(node, of_clk_src_onecell_get, clk_data);
+	if (r)
+		goto free_vdo1_data;
+
+	return r;
+
+free_vdo1_data:
+	mtk_free_clk_data(clk_data);
+	return r;
+}
+
+static struct platform_driver clk_mt8195_vdo1_drv = {
+	.probe = clk_mt8195_vdo1_probe,
+	.driver = {
+		.name = "clk-mt8195-vdo1",
+	},
+};
+builtin_platform_driver(clk_mt8195_vdo1_drv);
diff --git a/drivers/clk/mediatek/clk-mt8195-venc.c b/drivers/clk/mediatek/clk-mt8195-venc.c
new file mode 100644
index 0000000000000000000000000000000000000000..7339851a0856641e50cd7b2b8b5372aac15dd0b0
--- /dev/null
+++ b/drivers/clk/mediatek/clk-mt8195-venc.c
@@ -0,0 +1,69 @@
+// SPDX-License-Identifier: GPL-2.0-only
+//
+// Copyright (c) 2021 MediaTek Inc.
+// Author: Chun-Jie Chen <chun-jie.chen@mediatek.com>
+
+#include "clk-gate.h"
+#include "clk-mtk.h"
+
+#include <dt-bindings/clock/mt8195-clk.h>
+#include <linux/clk-provider.h>
+#include <linux/platform_device.h>
+
+static const struct mtk_gate_regs venc_cg_regs = {
+	.set_ofs = 0x4,
+	.clr_ofs = 0x8,
+	.sta_ofs = 0x0,
+};
+
+#define GATE_VENC(_id, _name, _parent, _shift)			\
+	GATE_MTK(_id, _name, _parent, &venc_cg_regs, _shift, &mtk_clk_gate_ops_setclr_inv)
+
+static const struct mtk_gate venc_clks[] = {
+	GATE_VENC(CLK_VENC_LARB, "venc_larb", "top_venc", 0),
+	GATE_VENC(CLK_VENC_VENC, "venc_venc", "top_venc", 4),
+	GATE_VENC(CLK_VENC_JPGENC, "venc_jpgenc", "top_venc", 8),
+	GATE_VENC(CLK_VENC_JPGDEC, "venc_jpgdec", "top_venc", 12),
+	GATE_VENC(CLK_VENC_JPGDEC_C1, "venc_jpgdec_c1", "top_venc", 16),
+	GATE_VENC(CLK_VENC_GALS, "venc_gals", "top_venc", 28),
+};
+
+static const struct mtk_gate venc_core1_clks[] = {
+	GATE_VENC(CLK_VENC_CORE1_LARB, "venc_core1_larb", "top_venc", 0),
+	GATE_VENC(CLK_VENC_CORE1_VENC, "venc_core1_venc", "top_venc", 4),
+	GATE_VENC(CLK_VENC_CORE1_JPGENC, "venc_core1_jpgenc", "top_venc", 8),
+	GATE_VENC(CLK_VENC_CORE1_JPGDEC, "venc_core1_jpgdec", "top_venc", 12),
+	GATE_VENC(CLK_VENC_CORE1_JPGDEC_C1, "venc_core1_jpgdec_c1", "top_venc", 16),
+	GATE_VENC(CLK_VENC_CORE1_GALS, "venc_core1_gals", "top_venc", 28),
+};
+
+static const struct mtk_clk_desc venc_desc = {
+	.clks = venc_clks,
+	.num_clks = ARRAY_SIZE(venc_clks),
+};
+
+static const struct mtk_clk_desc venc_core1_desc = {
+	.clks = venc_core1_clks,
+	.num_clks = ARRAY_SIZE(venc_core1_clks),
+};
+
+static const struct of_device_id of_match_clk_mt8195_venc[] = {
+	{
+		.compatible = "mediatek,mt8195-vencsys",
+		.data = &venc_desc,
+	}, {
+		.compatible = "mediatek,mt8195-vencsys_core1",
+		.data = &venc_core1_desc,
+	}, {
+		/* sentinel */
+	}
+};
+
+static struct platform_driver clk_mt8195_venc_drv = {
+	.probe = mtk_clk_simple_probe,
+	.driver = {
+		.name = "clk-mt8195-venc",
+		.of_match_table = of_match_clk_mt8195_venc,
+	},
+};
+builtin_platform_driver(clk_mt8195_venc_drv);
diff --git a/drivers/clk/mediatek/clk-mt8195-vpp0.c b/drivers/clk/mediatek/clk-mt8195-vpp0.c
new file mode 100644
index 0000000000000000000000000000000000000000..c3241466a8d0c55d13c7e69ad013904a64c8553f
--- /dev/null
+++ b/drivers/clk/mediatek/clk-mt8195-vpp0.c
@@ -0,0 +1,110 @@
+// SPDX-License-Identifier: GPL-2.0-only
+//
+// Copyright (c) 2021 MediaTek Inc.
+// Author: Chun-Jie Chen <chun-jie.chen@mediatek.com>
+
+#include "clk-gate.h"
+#include "clk-mtk.h"
+
+#include <dt-bindings/clock/mt8195-clk.h>
+#include <linux/clk-provider.h>
+#include <linux/platform_device.h>
+
+static const struct mtk_gate_regs vpp0_0_cg_regs = {
+	.set_ofs = 0x24,
+	.clr_ofs = 0x28,
+	.sta_ofs = 0x20,
+};
+
+static const struct mtk_gate_regs vpp0_1_cg_regs = {
+	.set_ofs = 0x30,
+	.clr_ofs = 0x34,
+	.sta_ofs = 0x2c,
+};
+
+static const struct mtk_gate_regs vpp0_2_cg_regs = {
+	.set_ofs = 0x3c,
+	.clr_ofs = 0x40,
+	.sta_ofs = 0x38,
+};
+
+#define GATE_VPP0_0(_id, _name, _parent, _shift)			\
+	GATE_MTK(_id, _name, _parent, &vpp0_0_cg_regs, _shift, &mtk_clk_gate_ops_setclr)
+
+#define GATE_VPP0_1(_id, _name, _parent, _shift)			\
+	GATE_MTK(_id, _name, _parent, &vpp0_1_cg_regs, _shift, &mtk_clk_gate_ops_setclr)
+
+#define GATE_VPP0_2(_id, _name, _parent, _shift)			\
+	GATE_MTK(_id, _name, _parent, &vpp0_2_cg_regs, _shift, &mtk_clk_gate_ops_setclr)
+
+static const struct mtk_gate vpp0_clks[] = {
+	/* VPP0_0 */
+	GATE_VPP0_0(CLK_VPP0_MDP_FG, "vpp0_mdp_fg", "top_vpp", 1),
+	GATE_VPP0_0(CLK_VPP0_STITCH, "vpp0_stitch", "top_vpp", 2),
+	GATE_VPP0_0(CLK_VPP0_PADDING, "vpp0_padding", "top_vpp", 7),
+	GATE_VPP0_0(CLK_VPP0_MDP_TCC, "vpp0_mdp_tcc", "top_vpp", 8),
+	GATE_VPP0_0(CLK_VPP0_WARP0_ASYNC_TX, "vpp0_warp0_async_tx", "top_vpp", 10),
+	GATE_VPP0_0(CLK_VPP0_WARP1_ASYNC_TX, "vpp0_warp1_async_tx", "top_vpp", 11),
+	GATE_VPP0_0(CLK_VPP0_MUTEX, "vpp0_mutex", "top_vpp", 13),
+	GATE_VPP0_0(CLK_VPP0_VPP02VPP1_RELAY, "vpp0_vpp02vpp1_relay", "top_vpp", 14),
+	GATE_VPP0_0(CLK_VPP0_VPP12VPP0_ASYNC, "vpp0_vpp12vpp0_async", "top_vpp", 15),
+	GATE_VPP0_0(CLK_VPP0_MMSYSRAM_TOP, "vpp0_mmsysram_top", "top_vpp", 16),
+	GATE_VPP0_0(CLK_VPP0_MDP_AAL, "vpp0_mdp_aal", "top_vpp", 17),
+	GATE_VPP0_0(CLK_VPP0_MDP_RSZ, "vpp0_mdp_rsz", "top_vpp", 18),
+	/* VPP0_1 */
+	GATE_VPP0_1(CLK_VPP0_SMI_COMMON, "vpp0_smi_common", "top_vpp", 0),
+	GATE_VPP0_1(CLK_VPP0_GALS_VDO0_LARB0, "vpp0_gals_vdo0_larb0", "top_vpp", 1),
+	GATE_VPP0_1(CLK_VPP0_GALS_VDO0_LARB1, "vpp0_gals_vdo0_larb1", "top_vpp", 2),
+	GATE_VPP0_1(CLK_VPP0_GALS_VENCSYS, "vpp0_gals_vencsys", "top_vpp", 3),
+	GATE_VPP0_1(CLK_VPP0_GALS_VENCSYS_CORE1, "vpp0_gals_vencsys_core1", "top_vpp", 4),
+	GATE_VPP0_1(CLK_VPP0_GALS_INFRA, "vpp0_gals_infra", "top_vpp", 5),
+	GATE_VPP0_1(CLK_VPP0_GALS_CAMSYS, "vpp0_gals_camsys", "top_vpp", 6),
+	GATE_VPP0_1(CLK_VPP0_GALS_VPP1_LARB5, "vpp0_gals_vpp1_larb5", "top_vpp", 7),
+	GATE_VPP0_1(CLK_VPP0_GALS_VPP1_LARB6, "vpp0_gals_vpp1_larb6", "top_vpp", 8),
+	GATE_VPP0_1(CLK_VPP0_SMI_REORDER, "vpp0_smi_reorder", "top_vpp", 9),
+	GATE_VPP0_1(CLK_VPP0_SMI_IOMMU, "vpp0_smi_iommu", "top_vpp", 10),
+	GATE_VPP0_1(CLK_VPP0_GALS_IMGSYS_CAMSYS, "vpp0_gals_imgsys_camsys", "top_vpp", 11),
+	GATE_VPP0_1(CLK_VPP0_MDP_RDMA, "vpp0_mdp_rdma", "top_vpp", 12),
+	GATE_VPP0_1(CLK_VPP0_MDP_WROT, "vpp0_mdp_wrot", "top_vpp", 13),
+	GATE_VPP0_1(CLK_VPP0_GALS_EMI0_EMI1, "vpp0_gals_emi0_emi1", "top_vpp", 16),
+	GATE_VPP0_1(CLK_VPP0_SMI_SUB_COMMON_REORDER, "vpp0_smi_sub_common_reorder", "top_vpp", 17),
+	GATE_VPP0_1(CLK_VPP0_SMI_RSI, "vpp0_smi_rsi", "top_vpp", 18),
+	GATE_VPP0_1(CLK_VPP0_SMI_COMMON_LARB4, "vpp0_smi_common_larb4", "top_vpp", 19),
+	GATE_VPP0_1(CLK_VPP0_GALS_VDEC_VDEC_CORE1, "vpp0_gals_vdec_vdec_core1", "top_vpp", 20),
+	GATE_VPP0_1(CLK_VPP0_GALS_VPP1_WPE, "vpp0_gals_vpp1_wpe", "top_vpp", 21),
+	GATE_VPP0_1(CLK_VPP0_GALS_VDO0_VDO1_VENCSYS_CORE1, "vpp0_gals_vdo0_vdo1_vencsys_core1",
+		    "top_vpp", 22),
+	GATE_VPP0_1(CLK_VPP0_FAKE_ENG, "vpp0_fake_eng", "top_vpp", 23),
+	GATE_VPP0_1(CLK_VPP0_MDP_HDR, "vpp0_mdp_hdr", "top_vpp", 24),
+	GATE_VPP0_1(CLK_VPP0_MDP_TDSHP, "vpp0_mdp_tdshp", "top_vpp", 25),
+	GATE_VPP0_1(CLK_VPP0_MDP_COLOR, "vpp0_mdp_color", "top_vpp", 26),
+	GATE_VPP0_1(CLK_VPP0_MDP_OVL, "vpp0_mdp_ovl", "top_vpp", 27),
+	/* VPP0_2 */
+	GATE_VPP0_2(CLK_VPP0_WARP0_RELAY, "vpp0_warp0_relay", "top_wpe_vpp", 0),
+	GATE_VPP0_2(CLK_VPP0_WARP0_MDP_DL_ASYNC, "vpp0_warp0_mdp_dl_async", "top_wpe_vpp", 1),
+	GATE_VPP0_2(CLK_VPP0_WARP1_RELAY, "vpp0_warp1_relay", "top_wpe_vpp", 2),
+	GATE_VPP0_2(CLK_VPP0_WARP1_MDP_DL_ASYNC, "vpp0_warp1_mdp_dl_async", "top_wpe_vpp", 3),
+};
+
+static const struct mtk_clk_desc vpp0_desc = {
+	.clks = vpp0_clks,
+	.num_clks = ARRAY_SIZE(vpp0_clks),
+};
+
+static const struct of_device_id of_match_clk_mt8195_vpp0[] = {
+	{
+		.compatible = "mediatek,mt8195-vppsys0",
+		.data = &vpp0_desc,
+	}, {
+		/* sentinel */
+	}
+};
+
+static struct platform_driver clk_mt8195_vpp0_drv = {
+	.probe = mtk_clk_simple_probe,
+	.driver = {
+		.name = "clk-mt8195-vpp0",
+		.of_match_table = of_match_clk_mt8195_vpp0,
+	},
+};
+builtin_platform_driver(clk_mt8195_vpp0_drv);
diff --git a/drivers/clk/mediatek/clk-mt8195-vpp1.c b/drivers/clk/mediatek/clk-mt8195-vpp1.c
new file mode 100644
index 0000000000000000000000000000000000000000..ce0b9a40a1794c0b755cbe5c0dba9ce5244840bc
--- /dev/null
+++ b/drivers/clk/mediatek/clk-mt8195-vpp1.c
@@ -0,0 +1,108 @@
+// SPDX-License-Identifier: GPL-2.0-only
+//
+// Copyright (c) 2021 MediaTek Inc.
+// Author: Chun-Jie Chen <chun-jie.chen@mediatek.com>
+
+#include "clk-gate.h"
+#include "clk-mtk.h"
+
+#include <dt-bindings/clock/mt8195-clk.h>
+#include <linux/clk-provider.h>
+#include <linux/platform_device.h>
+
+static const struct mtk_gate_regs vpp1_0_cg_regs = {
+	.set_ofs = 0x104,
+	.clr_ofs = 0x108,
+	.sta_ofs = 0x100,
+};
+
+static const struct mtk_gate_regs vpp1_1_cg_regs = {
+	.set_ofs = 0x114,
+	.clr_ofs = 0x118,
+	.sta_ofs = 0x110,
+};
+
+#define GATE_VPP1_0(_id, _name, _parent, _shift)			\
+	GATE_MTK(_id, _name, _parent, &vpp1_0_cg_regs, _shift, &mtk_clk_gate_ops_setclr)
+
+#define GATE_VPP1_1(_id, _name, _parent, _shift)			\
+	GATE_MTK(_id, _name, _parent, &vpp1_1_cg_regs, _shift, &mtk_clk_gate_ops_setclr)
+
+static const struct mtk_gate vpp1_clks[] = {
+	/* VPP1_0 */
+	GATE_VPP1_0(CLK_VPP1_SVPP1_MDP_OVL, "vpp1_svpp1_mdp_ovl", "top_vpp", 0),
+	GATE_VPP1_0(CLK_VPP1_SVPP1_MDP_TCC, "vpp1_svpp1_mdp_tcc", "top_vpp", 1),
+	GATE_VPP1_0(CLK_VPP1_SVPP1_MDP_WROT, "vpp1_svpp1_mdp_wrot", "top_vpp", 2),
+	GATE_VPP1_0(CLK_VPP1_SVPP1_VPP_PAD, "vpp1_svpp1_vpp_pad", "top_vpp", 3),
+	GATE_VPP1_0(CLK_VPP1_SVPP2_MDP_WROT, "vpp1_svpp2_mdp_wrot", "top_vpp", 4),
+	GATE_VPP1_0(CLK_VPP1_SVPP2_VPP_PAD, "vpp1_svpp2_vpp_pad", "top_vpp", 5),
+	GATE_VPP1_0(CLK_VPP1_SVPP3_MDP_WROT, "vpp1_svpp3_mdp_wrot", "top_vpp", 6),
+	GATE_VPP1_0(CLK_VPP1_SVPP3_VPP_PAD, "vpp1_svpp3_vpp_pad", "top_vpp", 7),
+	GATE_VPP1_0(CLK_VPP1_SVPP1_MDP_RDMA, "vpp1_svpp1_mdp_rdma", "top_vpp", 8),
+	GATE_VPP1_0(CLK_VPP1_SVPP1_MDP_FG, "vpp1_svpp1_mdp_fg", "top_vpp", 9),
+	GATE_VPP1_0(CLK_VPP1_SVPP2_MDP_RDMA, "vpp1_svpp2_mdp_rdma", "top_vpp", 10),
+	GATE_VPP1_0(CLK_VPP1_SVPP2_MDP_FG, "vpp1_svpp2_mdp_fg", "top_vpp", 11),
+	GATE_VPP1_0(CLK_VPP1_SVPP3_MDP_RDMA, "vpp1_svpp3_mdp_rdma", "top_vpp", 12),
+	GATE_VPP1_0(CLK_VPP1_SVPP3_MDP_FG, "vpp1_svpp3_mdp_fg", "top_vpp", 13),
+	GATE_VPP1_0(CLK_VPP1_VPP_SPLIT, "vpp1_vpp_split", "top_vpp", 14),
+	GATE_VPP1_0(CLK_VPP1_SVPP2_VDO0_DL_RELAY, "vpp1_svpp2_vdo0_dl_relay", "top_vpp", 15),
+	GATE_VPP1_0(CLK_VPP1_SVPP1_MDP_TDSHP, "vpp1_svpp1_mdp_tdshp", "top_vpp", 16),
+	GATE_VPP1_0(CLK_VPP1_SVPP1_MDP_COLOR, "vpp1_svpp1_mdp_color", "top_vpp", 17),
+	GATE_VPP1_0(CLK_VPP1_SVPP3_VDO1_DL_RELAY, "vpp1_svpp3_vdo1_dl_relay", "top_vpp", 18),
+	GATE_VPP1_0(CLK_VPP1_SVPP2_VPP_MERGE, "vpp1_svpp2_vpp_merge", "top_vpp", 19),
+	GATE_VPP1_0(CLK_VPP1_SVPP2_MDP_COLOR, "vpp1_svpp2_mdp_color", "top_vpp", 20),
+	GATE_VPP1_0(CLK_VPP1_VPPSYS1_GALS, "vpp1_vppsys1_gals", "top_vpp", 21),
+	GATE_VPP1_0(CLK_VPP1_SVPP3_VPP_MERGE, "vpp1_svpp3_vpp_merge", "top_vpp", 22),
+	GATE_VPP1_0(CLK_VPP1_SVPP3_MDP_COLOR, "vpp1_svpp3_mdp_color", "top_vpp", 23),
+	GATE_VPP1_0(CLK_VPP1_VPPSYS1_LARB, "vpp1_vppsys1_larb", "top_vpp", 24),
+	GATE_VPP1_0(CLK_VPP1_SVPP1_MDP_RSZ, "vpp1_svpp1_mdp_rsz", "top_vpp", 25),
+	GATE_VPP1_0(CLK_VPP1_SVPP1_MDP_HDR, "vpp1_svpp1_mdp_hdr", "top_vpp", 26),
+	GATE_VPP1_0(CLK_VPP1_SVPP1_MDP_AAL, "vpp1_svpp1_mdp_aal", "top_vpp", 27),
+	GATE_VPP1_0(CLK_VPP1_SVPP2_MDP_HDR, "vpp1_svpp2_mdp_hdr", "top_vpp", 28),
+	GATE_VPP1_0(CLK_VPP1_SVPP2_MDP_AAL, "vpp1_svpp2_mdp_aal", "top_vpp", 29),
+	GATE_VPP1_0(CLK_VPP1_DL_ASYNC, "vpp1_dl_async", "top_vpp", 30),
+	GATE_VPP1_0(CLK_VPP1_LARB5_FAKE_ENG, "vpp1_larb5_fake_eng", "top_vpp", 31),
+	/* VPP1_1 */
+	GATE_VPP1_1(CLK_VPP1_SVPP3_MDP_HDR, "vpp1_svpp3_mdp_hdr", "top_vpp", 0),
+	GATE_VPP1_1(CLK_VPP1_SVPP3_MDP_AAL, "vpp1_svpp3_mdp_aal", "top_vpp", 1),
+	GATE_VPP1_1(CLK_VPP1_SVPP2_VDO1_DL_RELAY, "vpp1_svpp2_vdo1_dl_relay", "top_vpp", 2),
+	GATE_VPP1_1(CLK_VPP1_LARB6_FAKE_ENG, "vpp1_larb6_fake_eng", "top_vpp", 3),
+	GATE_VPP1_1(CLK_VPP1_SVPP2_MDP_RSZ, "vpp1_svpp2_mdp_rsz", "top_vpp", 4),
+	GATE_VPP1_1(CLK_VPP1_SVPP3_MDP_RSZ, "vpp1_svpp3_mdp_rsz", "top_vpp", 5),
+	GATE_VPP1_1(CLK_VPP1_SVPP3_VDO0_DL_RELAY, "vpp1_svpp3_vdo0_dl_relay", "top_vpp", 6),
+	GATE_VPP1_1(CLK_VPP1_DISP_MUTEX, "vpp1_disp_mutex", "top_vpp", 7),
+	GATE_VPP1_1(CLK_VPP1_SVPP2_MDP_TDSHP, "vpp1_svpp2_mdp_tdshp", "top_vpp", 8),
+	GATE_VPP1_1(CLK_VPP1_SVPP3_MDP_TDSHP, "vpp1_svpp3_mdp_tdshp", "top_vpp", 9),
+	GATE_VPP1_1(CLK_VPP1_VPP0_DL1_RELAY, "vpp1_vpp0_dl1_relay", "top_vpp", 10),
+	GATE_VPP1_1(CLK_VPP1_HDMI_META, "vpp1_hdmi_meta", "hdmirx_p", 11),
+	GATE_VPP1_1(CLK_VPP1_VPP_SPLIT_HDMI, "vpp1_vpp_split_hdmi", "hdmirx_p", 12),
+	GATE_VPP1_1(CLK_VPP1_DGI_IN, "vpp1_dgi_in", "in_dgi", 13),
+	GATE_VPP1_1(CLK_VPP1_DGI_OUT, "vpp1_dgi_out", "top_dgi_out", 14),
+	GATE_VPP1_1(CLK_VPP1_VPP_SPLIT_DGI, "vpp1_vpp_split_dgi", "top_dgi_out", 15),
+	GATE_VPP1_1(CLK_VPP1_VPP0_DL_ASYNC, "vpp1_vpp0_dl_async", "top_vpp", 16),
+	GATE_VPP1_1(CLK_VPP1_VPP0_DL_RELAY, "vpp1_vpp0_dl_relay", "top_vpp", 17),
+	GATE_VPP1_1(CLK_VPP1_VPP_SPLIT_26M, "vpp1_vpp_split_26m", "clk26m", 26),
+};
+
+static const struct mtk_clk_desc vpp1_desc = {
+	.clks = vpp1_clks,
+	.num_clks = ARRAY_SIZE(vpp1_clks),
+};
+
+static const struct of_device_id of_match_clk_mt8195_vpp1[] = {
+	{
+		.compatible = "mediatek,mt8195-vppsys1",
+		.data = &vpp1_desc,
+	}, {
+		/* sentinel */
+	}
+};
+
+static struct platform_driver clk_mt8195_vpp1_drv = {
+	.probe = mtk_clk_simple_probe,
+	.driver = {
+		.name = "clk-mt8195-vpp1",
+		.of_match_table = of_match_clk_mt8195_vpp1,
+	},
+};
+builtin_platform_driver(clk_mt8195_vpp1_drv);
diff --git a/drivers/clk/mediatek/clk-mt8195-wpe.c b/drivers/clk/mediatek/clk-mt8195-wpe.c
new file mode 100644
index 0000000000000000000000000000000000000000..274d60838d8e94158ae5c14b8f84cf9fed1a2238
--- /dev/null
+++ b/drivers/clk/mediatek/clk-mt8195-wpe.c
@@ -0,0 +1,143 @@
+// SPDX-License-Identifier: GPL-2.0-only
+//
+// Copyright (c) 2021 MediaTek Inc.
+// Author: Chun-Jie Chen <chun-jie.chen@mediatek.com>
+
+#include "clk-gate.h"
+#include "clk-mtk.h"
+
+#include <dt-bindings/clock/mt8195-clk.h>
+#include <linux/clk-provider.h>
+#include <linux/platform_device.h>
+
+static const struct mtk_gate_regs wpe_cg_regs = {
+	.set_ofs = 0x0,
+	.clr_ofs = 0x0,
+	.sta_ofs = 0x0,
+};
+
+static const struct mtk_gate_regs wpe_vpp0_cg_regs = {
+	.set_ofs = 0x58,
+	.clr_ofs = 0x58,
+	.sta_ofs = 0x58,
+};
+
+static const struct mtk_gate_regs wpe_vpp1_cg_regs = {
+	.set_ofs = 0x5c,
+	.clr_ofs = 0x5c,
+	.sta_ofs = 0x5c,
+};
+
+#define GATE_WPE(_id, _name, _parent, _shift)			\
+	GATE_MTK(_id, _name, _parent, &wpe_cg_regs, _shift, &mtk_clk_gate_ops_no_setclr_inv)
+
+#define GATE_WPE_VPP0(_id, _name, _parent, _shift)			\
+	GATE_MTK(_id, _name, _parent, &wpe_vpp0_cg_regs, _shift, &mtk_clk_gate_ops_no_setclr_inv)
+
+#define GATE_WPE_VPP1(_id, _name, _parent, _shift)			\
+	GATE_MTK(_id, _name, _parent, &wpe_vpp1_cg_regs, _shift, &mtk_clk_gate_ops_no_setclr_inv)
+
+static const struct mtk_gate wpe_clks[] = {
+	GATE_WPE(CLK_WPE_VPP0, "wpe_vpp0", "top_wpe_vpp", 16),
+	GATE_WPE(CLK_WPE_VPP1, "wpe_vpp1", "top_wpe_vpp", 17),
+	GATE_WPE(CLK_WPE_SMI_LARB7, "wpe_smi_larb7", "top_wpe_vpp", 18),
+	GATE_WPE(CLK_WPE_SMI_LARB8, "wpe_smi_larb8", "top_wpe_vpp", 19),
+	GATE_WPE(CLK_WPE_EVENT_TX, "wpe_event_tx", "top_wpe_vpp", 20),
+	GATE_WPE(CLK_WPE_SMI_LARB7_P, "wpe_smi_larb7_p", "top_wpe_vpp", 24),
+	GATE_WPE(CLK_WPE_SMI_LARB8_P, "wpe_smi_larb8_p", "top_wpe_vpp", 25),
+};
+
+static const struct mtk_gate wpe_vpp0_clks[] = {
+	/* WPE_VPP0 */
+	GATE_WPE_VPP0(CLK_WPE_VPP0_VGEN, "wpe_vpp0_vgen", "top_img", 0),
+	GATE_WPE_VPP0(CLK_WPE_VPP0_EXT, "wpe_vpp0_ext", "top_img", 1),
+	GATE_WPE_VPP0(CLK_WPE_VPP0_VFC, "wpe_vpp0_vfc", "top_img", 2),
+	GATE_WPE_VPP0(CLK_WPE_VPP0_CACH0_TOP, "wpe_vpp0_cach0_top", "top_img", 3),
+	GATE_WPE_VPP0(CLK_WPE_VPP0_CACH0_DMA, "wpe_vpp0_cach0_dma", "top_img", 4),
+	GATE_WPE_VPP0(CLK_WPE_VPP0_CACH1_TOP, "wpe_vpp0_cach1_top", "top_img", 5),
+	GATE_WPE_VPP0(CLK_WPE_VPP0_CACH1_DMA, "wpe_vpp0_cach1_dma", "top_img", 6),
+	GATE_WPE_VPP0(CLK_WPE_VPP0_CACH2_TOP, "wpe_vpp0_cach2_top", "top_img", 7),
+	GATE_WPE_VPP0(CLK_WPE_VPP0_CACH2_DMA, "wpe_vpp0_cach2_dma", "top_img", 8),
+	GATE_WPE_VPP0(CLK_WPE_VPP0_CACH3_TOP, "wpe_vpp0_cach3_top", "top_img", 9),
+	GATE_WPE_VPP0(CLK_WPE_VPP0_CACH3_DMA, "wpe_vpp0_cach3_dma", "top_img", 10),
+	GATE_WPE_VPP0(CLK_WPE_VPP0_PSP, "wpe_vpp0_psp", "top_img", 11),
+	GATE_WPE_VPP0(CLK_WPE_VPP0_PSP2, "wpe_vpp0_psp2", "top_img", 12),
+	GATE_WPE_VPP0(CLK_WPE_VPP0_SYNC, "wpe_vpp0_sync", "top_img", 13),
+	GATE_WPE_VPP0(CLK_WPE_VPP0_C24, "wpe_vpp0_c24", "top_img", 14),
+	GATE_WPE_VPP0(CLK_WPE_VPP0_MDP_CROP, "wpe_vpp0_mdp_crop", "top_img", 15),
+	GATE_WPE_VPP0(CLK_WPE_VPP0_ISP_CROP, "wpe_vpp0_isp_crop", "top_img", 16),
+	GATE_WPE_VPP0(CLK_WPE_VPP0_TOP, "wpe_vpp0_top", "top_img", 17),
+	/* WPE_VPP1 */
+	GATE_WPE_VPP1(CLK_WPE_VPP0_VECI, "wpe_vpp0_veci", "top_img", 0),
+	GATE_WPE_VPP1(CLK_WPE_VPP0_VEC2I, "wpe_vpp0_vec2i", "top_img", 1),
+	GATE_WPE_VPP1(CLK_WPE_VPP0_VEC3I, "wpe_vpp0_vec3i", "top_img", 2),
+	GATE_WPE_VPP1(CLK_WPE_VPP0_WPEO, "wpe_vpp0_wpeo", "top_img", 3),
+	GATE_WPE_VPP1(CLK_WPE_VPP0_MSKO, "wpe_vpp0_msko", "top_img", 4),
+};
+
+static const struct mtk_gate wpe_vpp1_clks[] = {
+	/* WPE_VPP0 */
+	GATE_WPE_VPP0(CLK_WPE_VPP1_VGEN, "wpe_vpp1_vgen", "top_img", 0),
+	GATE_WPE_VPP0(CLK_WPE_VPP1_EXT, "wpe_vpp1_ext", "top_img", 1),
+	GATE_WPE_VPP0(CLK_WPE_VPP1_VFC, "wpe_vpp1_vfc", "top_img", 2),
+	GATE_WPE_VPP0(CLK_WPE_VPP1_CACH0_TOP, "wpe_vpp1_cach0_top", "top_img", 3),
+	GATE_WPE_VPP0(CLK_WPE_VPP1_CACH0_DMA, "wpe_vpp1_cach0_dma", "top_img", 4),
+	GATE_WPE_VPP0(CLK_WPE_VPP1_CACH1_TOP, "wpe_vpp1_cach1_top", "top_img", 5),
+	GATE_WPE_VPP0(CLK_WPE_VPP1_CACH1_DMA, "wpe_vpp1_cach1_dma", "top_img", 6),
+	GATE_WPE_VPP0(CLK_WPE_VPP1_CACH2_TOP, "wpe_vpp1_cach2_top", "top_img", 7),
+	GATE_WPE_VPP0(CLK_WPE_VPP1_CACH2_DMA, "wpe_vpp1_cach2_dma", "top_img", 8),
+	GATE_WPE_VPP0(CLK_WPE_VPP1_CACH3_TOP, "wpe_vpp1_cach3_top", "top_img", 9),
+	GATE_WPE_VPP0(CLK_WPE_VPP1_CACH3_DMA, "wpe_vpp1_cach3_dma", "top_img", 10),
+	GATE_WPE_VPP0(CLK_WPE_VPP1_PSP, "wpe_vpp1_psp", "top_img", 11),
+	GATE_WPE_VPP0(CLK_WPE_VPP1_PSP2, "wpe_vpp1_psp2", "top_img", 12),
+	GATE_WPE_VPP0(CLK_WPE_VPP1_SYNC, "wpe_vpp1_sync", "top_img", 13),
+	GATE_WPE_VPP0(CLK_WPE_VPP1_C24, "wpe_vpp1_c24", "top_img", 14),
+	GATE_WPE_VPP0(CLK_WPE_VPP1_MDP_CROP, "wpe_vpp1_mdp_crop", "top_img", 15),
+	GATE_WPE_VPP0(CLK_WPE_VPP1_ISP_CROP, "wpe_vpp1_isp_crop", "top_img", 16),
+	GATE_WPE_VPP0(CLK_WPE_VPP1_TOP, "wpe_vpp1_top", "top_img", 17),
+	/* WPE_VPP1 */
+	GATE_WPE_VPP1(CLK_WPE_VPP1_VECI, "wpe_vpp1_veci", "top_img", 0),
+	GATE_WPE_VPP1(CLK_WPE_VPP1_VEC2I, "wpe_vpp1_vec2i", "top_img", 1),
+	GATE_WPE_VPP1(CLK_WPE_VPP1_VEC3I, "wpe_vpp1_vec3i", "top_img", 2),
+	GATE_WPE_VPP1(CLK_WPE_VPP1_WPEO, "wpe_vpp1_wpeo", "top_img", 3),
+	GATE_WPE_VPP1(CLK_WPE_VPP1_MSKO, "wpe_vpp1_msko", "top_img", 4),
+};
+
+static const struct mtk_clk_desc wpe_desc = {
+	.clks = wpe_clks,
+	.num_clks = ARRAY_SIZE(wpe_clks),
+};
+
+static const struct mtk_clk_desc wpe_vpp0_desc = {
+	.clks = wpe_vpp0_clks,
+	.num_clks = ARRAY_SIZE(wpe_vpp0_clks),
+};
+
+static const struct mtk_clk_desc wpe_vpp1_desc = {
+	.clks = wpe_vpp1_clks,
+	.num_clks = ARRAY_SIZE(wpe_vpp1_clks),
+};
+
+static const struct of_device_id of_match_clk_mt8195_wpe[] = {
+	{
+		.compatible = "mediatek,mt8195-wpesys",
+		.data = &wpe_desc,
+	}, {
+		.compatible = "mediatek,mt8195-wpesys_vpp0",
+		.data = &wpe_vpp0_desc,
+	}, {
+		.compatible = "mediatek,mt8195-wpesys_vpp1",
+		.data = &wpe_vpp1_desc,
+	}, {
+		/* sentinel */
+	}
+};
+
+static struct platform_driver clk_mt8195_wpe_drv = {
+	.probe = mtk_clk_simple_probe,
+	.driver = {
+		.name = "clk-mt8195-wpe",
+		.of_match_table = of_match_clk_mt8195_wpe,
+	},
+};
+builtin_platform_driver(clk_mt8195_wpe_drv);
diff --git a/drivers/clk/mediatek/clk-pll.c b/drivers/clk/mediatek/clk-pll.c
index 99ada6e06697aecc608f621ee4ef40ba73c8d1fd..df0eee0bab770f00513ad78e089c5fe17a7662cf 100644
--- a/drivers/clk/mediatek/clk-pll.c
+++ b/drivers/clk/mediatek/clk-pll.c
@@ -239,7 +239,6 @@ static int mtk_pll_prepare(struct clk_hw *hw)
 {
 	struct mtk_clk_pll *pll = to_mtk_clk_pll(hw);
 	u32 r;
-	u32 div_en_mask;
 
 	r = readl(pll->pwr_addr) | CON0_PWR_ON;
 	writel(r, pll->pwr_addr);
@@ -252,9 +251,8 @@ static int mtk_pll_prepare(struct clk_hw *hw)
 	r = readl(pll->en_addr) | BIT(pll->data->pll_en_bit);
 	writel(r, pll->en_addr);
 
-	div_en_mask = pll->data->en_mask & ~CON0_BASE_EN;
-	if (div_en_mask) {
-		r = readl(pll->base_addr + REG_CON0) | div_en_mask;
+	if (pll->data->en_mask) {
+		r = readl(pll->base_addr + REG_CON0) | pll->data->en_mask;
 		writel(r, pll->base_addr + REG_CON0);
 	}
 
@@ -275,7 +273,6 @@ static void mtk_pll_unprepare(struct clk_hw *hw)
 {
 	struct mtk_clk_pll *pll = to_mtk_clk_pll(hw);
 	u32 r;
-	u32 div_en_mask;
 
 	if (pll->data->flags & HAVE_RST_BAR) {
 		r = readl(pll->base_addr + REG_CON0);
@@ -285,9 +282,8 @@ static void mtk_pll_unprepare(struct clk_hw *hw)
 
 	__mtk_pll_tuner_disable(pll);
 
-	div_en_mask = pll->data->en_mask & ~CON0_BASE_EN;
-	if (div_en_mask) {
-		r = readl(pll->base_addr + REG_CON0) & ~div_en_mask;
+	if (pll->data->en_mask) {
+		r = readl(pll->base_addr + REG_CON0) & ~pll->data->en_mask;
 		writel(r, pll->base_addr + REG_CON0);
 	}
 
diff --git a/drivers/clk/mediatek/clkchk-mt8195.c b/drivers/clk/mediatek/clkchk-mt8195.c
new file mode 100644
index 0000000000000000000000000000000000000000..b12e506b5931701d601c0f98c2a51adb920e15c1
--- /dev/null
+++ b/drivers/clk/mediatek/clkchk-mt8195.c
@@ -0,0 +1,783 @@
+// SPDX-License-Identifier: GPL-2.0
+//
+// Copyright (c) 2020 MediaTek Inc.
+// Author: Weiyi Lu <weiyi.lu@mediatek.com>
+
+#include <linux/module.h>
+#include "clkchk.h"
+
+static const char * const off_pll_names[] = {
+	"nnapll",
+	"respll",
+	"ethpll",
+	"msdcpll",
+	"tvdpll1",
+	"tvdpll2",
+	"mmpll",
+	//"mainpll",
+	"vdecpll",
+	"imgpll",
+	"univpll",
+	"hdmipll1",
+	"hdmipll2",
+	"hdmirx_apll",
+	"usb1pll",
+	"adsppll",
+	"apll1",
+	"apll2",
+	"apll3",
+	"apll4",
+	"apll5",
+	"mfgpll",
+	"dgipll",
+	"apusys_pll_apupll",
+	"apusys_pll_npupll",
+	"apusys_pll_apupll1",
+	"apusys_pll_apupll2",
+	NULL
+};
+
+static const char * const all_clk_names[] = {
+	"clk26m",
+	"clk32k",
+	"nnapll",
+	"respll",
+	"ethpll",
+	"msdcpll",
+	"tvdpll1",
+	"tvdpll2",
+	"mmpll",
+	"mainpll",
+	"vdecpll",
+	"imgpll",
+	"univpll",
+	"hdmipll1",
+	"hdmipll2",
+	"hdmirx_apll",
+	"usb1pll",
+	"adsppll",
+	"apll1",
+	"apll2",
+	"apll3",
+	"apll4",
+	"apll5",
+	"mfgpll",
+	"dgipll",
+	"apusys_pll_apupll",
+	"apusys_pll_npupll",
+	"apusys_pll_apupll1",
+	"apusys_pll_apupll2",
+	"pll_ssusb26m",
+	"in_dgi",
+	"ulposc1",
+	"ulposc2",
+	"mem_466m",
+	"mphone_slave_b",
+	"pextp_pipe",
+	"ufs_rx_symbol",
+	"ufs_tx_symbol",
+	"ssusb_u3phy_p1_p_p0",
+	"ufs_rx_symbol1",
+	"fpc",
+	"hdmirx_p",
+	"clk26m_d2",
+	"clk26m_d52",
+	"in_dgi_d2",
+	"in_dgi_d4",
+	"in_dgi_d6",
+	"in_dgi_d8",
+	"mainpll_d3",
+	"mainpll_d4",
+	"mainpll_d4_d2",
+	"mainpll_d4_d4",
+	"mainpll_d4_d8",
+	"mainpll_d5",
+	"mainpll_d5_d2",
+	"mainpll_d5_d4",
+	"mainpll_d5_d8",
+	"mainpll_d6",
+	"mainpll_d6_d2",
+	"mainpll_d6_d4",
+	"mainpll_d6_d8",
+	"mainpll_d7",
+	"mainpll_d7_d2",
+	"mainpll_d7_d4",
+	"mainpll_d7_d8",
+	"mainpll_d9",
+	"univpll_d2",
+	"univpll_d3",
+	"univpll_d4",
+	"univpll_d4_d2",
+	"univpll_d4_d4",
+	"univpll_d4_d8",
+	"univpll_d5",
+	"univpll_d5_d2",
+	"univpll_d5_d4",
+	"univpll_d5_d8",
+	"univpll_d6",
+	"univpll_d6_d2",
+	"univpll_d6_d4",
+	"univpll_d6_d8",
+	"univpll_d6_d16",
+	"univpll_d7",
+	"univpll_192m",
+	"univpll_192m_d4",
+	"univpll_192m_d8",
+	"univpll_192m_d16",
+	"univpll_192m_d32",
+	"apll1_d3",
+	"apll1_d4",
+	"apll2_d3",
+	"apll2_d4",
+	"apll3_d4",
+	"apll4_d4",
+	"apll5_d4",
+	"hdmirx_apll_d3",
+	"hdmirx_apll_d4",
+	"hdmirx_apll_d6",
+	"mmpll_d4",
+	"mmpll_d4_d2",
+	"mmpll_d4_d4",
+	"mmpll_d5",
+	"mmpll_d5_d2",
+	"mmpll_d5_d4",
+	"mmpll_d6",
+	"mmpll_d6_d2",
+	"mmpll_d7",
+	"mmpll_d9",
+	"tvdpll1_d2",
+	"tvdpll1_d4",
+	"tvdpll1_d8",
+	"tvdpll1_d16",
+	"tvdpll2_d2",
+	"tvdpll2_d4",
+	"tvdpll2_d8",
+	"tvdpll2_d16",
+	"msdcpll_d2",
+	"msdcpll_d4",
+	"msdcpll_d16",
+	"ethpll_d2",
+	"ethpll_d8",
+	"ethpll_d10",
+	"dgipll_d2",
+	"ulposc1_d2",
+	"ulposc1_d4",
+	"ulposc1_d7",
+	"ulposc1_d8",
+	"ulposc1_d10",
+	"ulposc1_d16",
+	"adsppll_d2",
+	"adsppll_d4",
+	"adsppll_d8",
+	"top_axi",
+	"top_spm",
+	"top_scp",
+	"top_bus_aximem",
+	"top_vpp",
+	"top_ethdr",
+	"top_ipe",
+	"top_cam",
+	"top_ccu",
+	"top_img",
+	"top_camtm",
+	"top_dsp",
+	"top_dsp1",
+	"top_dsp2",
+	"top_dsp3",
+	"top_dsp4",
+	"top_dsp5",
+	"top_dsp6",
+	"top_dsp7",
+	"top_ipu_if",
+	"top_mfg_core_tmp",
+	"top_camtg",
+	"top_camtg2",
+	"top_camtg3",
+	"top_camtg4",
+	"top_camtg5",
+	"top_uart",
+	"top_spi",
+	"top_spis",
+	"top_msdc50_0_hclk",
+	"top_msdc50_0",
+	"top_msdc30_1",
+	"top_msdc30_2",
+	"top_intdir",
+	"top_aud_intbus",
+	"top_audio_h",
+	"top_pwrap_ulposc",
+	"top_atb",
+	"top_pwrmcu",
+	"top_dp",
+	"top_edp",
+	"top_dpi",
+	"top_disp_pwm0",
+	"top_disp_pwm1",
+	"top_usb_top",
+	"top_ssusb_xhci",
+	"top_usb_top_1p",
+	"top_ssusb_xhci_1p",
+	"top_usb_top_2p",
+	"top_ssusb_xhci_2p",
+	"top_usb_top_3p",
+	"top_ssusb_xhci_3p",
+	"top_i2c",
+	"top_seninf",
+	"top_seninf1",
+	"top_seninf2",
+	"top_seninf3",
+	"top_gcpu",
+	"top_dxcc",
+	"top_dpmaif_main",
+	"top_aes_ufsfde",
+	"top_ufs",
+	"top_ufs_tick1us",
+	"top_ufs_mp_sap_cfg",
+	"top_venc",
+	"top_vdec",
+	"top_pwm",
+	"top_mcupm",
+	"top_spmi_p_mst",
+	"top_spmi_m_mst",
+	"top_dvfsrc",
+	"top_tl",
+	"top_tl_p1",
+	"top_aes_msdcfde",
+	"top_dsi_occ",
+	"top_wpe_vpp",
+	"top_hdcp",
+	"top_hdcp_24m",
+	"top_hd20_dacr_ref_clk",
+	"top_hd20_hdcp_cclk",
+	"top_hdmi_xtal",
+	"top_hdmi_apb",
+	"top_snps_eth_250m",
+	"top_snps_eth_62p4m_ptp",
+	"snps_eth_50m_rmii",
+	"top_dgi_out",
+	"top_nna0",
+	"top_nna1",
+	"top_adsp",
+	"top_asm_h",
+	"top_asm_m",
+	"top_asm_l",
+	"top_apll1",
+	"top_apll2",
+	"top_apll3",
+	"top_apll4",
+	"top_apll5",
+	"top_i2so1_mck",
+	"top_i2so2_mck",
+	"top_i2si1_mck",
+	"top_i2si2_mck",
+	"top_dptx_mck",
+	"top_aud_iec_clk",
+	"top_a1sys_hp",
+	"top_a2sys_hf",
+	"top_a3sys_hf",
+	"top_a4sys_hf",
+	"top_spinfi_bclk",
+	"top_nfi1x",
+	"top_ecc",
+	"top_audio_local_bus",
+	"top_spinor",
+	"top_dvio_dgi_ref",
+	"top_ulposc",
+	"top_ulposc_core",
+	"top_srck",
+	"mfg_ck_fast_ref",
+	"apll12_div0",
+	"apll12_div1",
+	"apll12_div2",
+	"apll12_div3",
+	"apll12_div4",
+	"apll12_div9",
+	"cfg_vpp0",
+	"cfg_vpp1",
+	"cfg_vdo0",
+	"cfg_vdo1",
+	"cfg_unipll_ses",
+	"cfg_26m_vpp0",
+	"cfg_26m_vpp1",
+	"cfg_26m_aud",
+	"cfg_axi_east",
+	"cfg_axi_east_north",
+	"cfg_axi_north",
+	"cfg_axi_south",
+	"cfg_ext_test",
+	"ssusb_ref",
+	"ssusb_phy_ref",
+	"ssusb_p1_ref",
+	"ssusb_phy_p1_ref",
+	"ssusb_p2_ref",
+	"ssusb_phy_p2_ref",
+	"ssusb_p3_ref",
+	"ssusb_phy_p3_ref",
+	"infra_ao_pmic_tmr",
+	"infra_ao_pmic_ap",
+	"infra_ao_pmic_md",
+	"infra_ao_pmic_conn",
+	"infra_ao_sej",
+	"infra_ao_apxgpt",
+	"infra_ao_gce",
+	"infra_ao_gce2",
+	"infra_ao_therm",
+	"infra_ao_pwm_h",
+	"infra_ao_pwm1",
+	"infra_ao_pwm2",
+	"infra_ao_pwm3",
+	"infra_ao_pwm4",
+	"infra_ao_pwm",
+	"infra_ao_uart0",
+	"infra_ao_uart1",
+	"infra_ao_uart2",
+	"infra_ao_uart3",
+	"infra_ao_uart4",
+	"infra_ao_gce_26m",
+	"infra_ao_cq_dma_fpc",
+	"infra_ao_uart5",
+	"infra_ao_hdmi_26m",
+	"infra_ao_spi0",
+	"infra_ao_msdc0",
+	"infra_ao_msdc1",
+	"infra_ao_cg1_msdc2",
+	"infra_ao_msdc0_src",
+	"infra_ao_trng",
+	"infra_ao_auxadc",
+	"infra_ao_cpum",
+	"infra_ao_hdmi_32k",
+	"infra_ao_cec_66m_h",
+	"infra_ao_irrx",
+	"infra_ao_pcie_tl_26m",
+	"infra_ao_msdc1_src",
+	"infra_ao_cec_66m_b",
+	"infra_ao_pcie_tl_96m",
+	"infra_ao_device_apc",
+	"infra_ao_ecc_66m_h",
+	"infra_ao_debugsys",
+	"infra_ao_audio",
+	"infra_ao_pcie_tl_32k",
+	"infra_ao_dbg_trace",
+	"infra_ao_dramc_f26m",
+	"infra_ao_irtx",
+	"infra_ao_ssusb",
+	"infra_ao_disp_pwm",
+	"infra_ao_cldma_b",
+	"infra_ao_audio_26m_b",
+	"infra_ao_spi1",
+	"infra_ao_spi2",
+	"infra_ao_spi3",
+	"infra_ao_unipro_sys",
+	"infra_ao_unipro_tick",
+	"infra_ao_ufs_mp_sap_b",
+	"infra_ao_pwrmcu",
+	"infra_ao_pwrmcu_bus_h",
+	"infra_ao_apdma_b",
+	"infra_ao_spi4",
+	"infra_ao_spi5",
+	"infra_ao_cq_dma",
+	"infra_ao_aes_ufsfde",
+	"infra_ao_aes",
+	"infra_ao_ufs_tick",
+	"infra_ao_ssusb_xhci",
+	"infra_ao_msdc0_self",
+	"infra_ao_msdc1_self",
+	"infra_ao_msdc2_self",
+	"infra_ao_i2s_dma",
+	"infra_ao_ap_msdc0",
+	"infra_ao_md_msdc0",
+	"infra_ao_cg3_msdc2",
+	"infra_ao_gcpu",
+	"infra_ao_pcie_peri_26m",
+	"infra_ao_gcpu_66m_b",
+	"infra_ao_gcpu_133m_b",
+	"infra_ao_disp_pwm1",
+	"infra_ao_fbist2fpc",
+	"infra_ao_device_apc_sync",
+	"infra_ao_pcie_p1_peri_26m",
+	"infra_ao_spis0",
+	"infra_ao_spis1",
+	"infra_ao_133m_m_peri",
+	"infra_ao_66m_m_peri",
+	"infra_ao_pcie_pl_p_250m_p0",
+	"infra_ao_pcie_pl_p_250m_p1",
+	"infra_ao_pcie_p1_tl_96m",
+	"infra_ao_aes_msdcfde_0p",
+	"infra_ao_ufs_tx_symbol",
+	"infra_ao_ufs_rx_symbol",
+	"infra_ao_ufs_rx_symbol1",
+	"infra_ao_peri_ufs_mem_sub",
+	"scp_adsp_audiodsp",
+	"peri_ao_ethernet",
+	"peri_ao_ethernet_bus",
+	"peri_ao_flashif_bus",
+	"peri_ao_flashif_flash",
+	"peri_ao_ssusb_1p_bus",
+	"peri_ao_ssusb_1p_xhci",
+	"peri_ao_ssusb_2p_bus",
+	"peri_ao_ssusb_2p_xhci",
+	"peri_ao_ssusb_3p_bus",
+	"peri_ao_ssusb_3p_xhci",
+	"peri_ao_spinfi",
+	"peri_ao_ethernet_mac",
+	"peri_ao_nfi_h",
+	"peri_ao_fnfi1x",
+	"peri_ao_pcie_p0_mem",
+	"peri_ao_pcie_p1_mem",
+	"imp_iic_wrap_s_i2c5",
+	"imp_iic_wrap_s_i2c6",
+	"imp_iic_wrap_s_i2c7",
+	"imp_iic_wrap_w_i2c0",
+	"imp_iic_wrap_w_i2c1",
+	"imp_iic_wrap_w_i2c2",
+	"imp_iic_wrap_w_i2c3",
+	"imp_iic_wrap_w_i2c4",
+	"mfg_bg3d",
+	"vpp0_mdp_fg",
+	"vpp0_stitch",
+	"vpp0_padding",
+	"vpp0_mdp_tcc",
+	"vpp0_warp0_async_tx",
+	"vpp0_warp1_async_tx",
+	"vpp0_mutex",
+	"vpp0_vpp02vpp1_relay",
+	"vpp0_vpp12vpp0_async",
+	"vpp0_mmsysram_top",
+	"vpp0_mdp_aal",
+	"vpp0_mdp_rsz",
+	"vpp0_smi_common",
+	"vpp0_gals_vdo0_larb0",
+	"vpp0_gals_vdo0_larb1",
+	"vpp0_gals_vencsys",
+	"vpp0_gals_vencsys_core1",
+	"vpp0_gals_infra",
+	"vpp0_gals_camsys",
+	"vpp0_gals_vpp1_larb5",
+	"vpp0_gals_vpp1_larb6",
+	"vpp0_smi_reorder",
+	"vpp0_smi_iommu",
+	"vpp0_gals_imgsys_camsys",
+	"vpp0_mdp_rdma",
+	"vpp0_mdp_wrot",
+	"vpp0_gals_emi0_emi1",
+	"vpp0_smi_sub_common_reorder",
+	"vpp0_smi_rsi",
+	"vpp0_smi_common_larb4",
+	"vpp0_gals_vdec_vdec_core1",
+	"vpp0_gals_vpp1_wpe",
+	"vpp0_gals_vdo0_vdo1_vencsys_core1",
+	"vpp0_fake_eng",
+	"vpp0_mdp_hdr",
+	"vpp0_mdp_tdshp",
+	"vpp0_mdp_color",
+	"vpp0_mdp_ovl",
+	"vpp0_warp0_relay",
+	"vpp0_warp0_mdp_dl_async",
+	"vpp0_warp1_relay",
+	"vpp0_warp1_mdp_dl_async",
+	"wpe_vpp0",
+	"wpe_vpp1",
+	"wpe_smi_larb7",
+	"wpe_smi_larb8",
+	"wpe_event_tx",
+	"wpe_smi_larb7_p",
+	"wpe_smi_larb8_p",
+	"wpe_vpp0_veci",
+	"wpe_vpp0_vec2i",
+	"wpe_vpp0_vec3i",
+	"wpe_vpp0_wpeo",
+	"wpe_vpp0_msko",
+	"wpe_vpp0_vgen",
+	"wpe_vpp0_ext",
+	"wpe_vpp0_vfc",
+	"wpe_vpp0_cach0_top",
+	"wpe_vpp0_cach0_dma",
+	"wpe_vpp0_cach1_top",
+	"wpe_vpp0_cach1_dma",
+	"wpe_vpp0_cach2_top",
+	"wpe_vpp0_cach2_dma",
+	"wpe_vpp0_cach3_top",
+	"wpe_vpp0_cach3_dma",
+	"wpe_vpp0_psp",
+	"wpe_vpp0_psp2",
+	"wpe_vpp0_sync",
+	"wpe_vpp0_c24",
+	"wpe_vpp0_mdp_crop",
+	"wpe_vpp0_isp_crop",
+	"wpe_vpp0_top",
+	"wpe_vpp1_veci",
+	"wpe_vpp1_vec2i",
+	"wpe_vpp1_vec3i",
+	"wpe_vpp1_wpeo",
+	"wpe_vpp1_msko",
+	"wpe_vpp1_vgen",
+	"wpe_vpp1_ext",
+	"wpe_vpp1_vfc",
+	"wpe_vpp1_cach0_top",
+	"wpe_vpp1_cach0_dma",
+	"wpe_vpp1_cach1_top",
+	"wpe_vpp1_cach1_dma",
+	"wpe_vpp1_cach2_top",
+	"wpe_vpp1_cach2_dma",
+	"wpe_vpp1_cach3_top",
+	"wpe_vpp1_cach3_dma",
+	"wpe_vpp1_psp",
+	"wpe_vpp1_psp2",
+	"wpe_vpp1_sync",
+	"wpe_vpp1_c24",
+	"wpe_vpp1_mdp_crop",
+	"wpe_vpp1_isp_crop",
+	"wpe_vpp1_top",
+	"vpp1_svpp1_mdp_ovl",
+	"vpp1_svpp1_mdp_tcc",
+	"vpp1_svpp1_mdp_wrot",
+	"vpp1_svpp1_vpp_pad",
+	"vpp1_svpp2_mdp_wrot",
+	"vpp1_svpp2_vpp_pad",
+	"vpp1_svpp3_mdp_wrot",
+	"vpp1_svpp3_vpp_pad",
+	"vpp1_svpp1_mdp_rdma",
+	"vpp1_svpp1_mdp_fg",
+	"vpp1_svpp2_mdp_rdma",
+	"vpp1_svpp2_mdp_fg",
+	"vpp1_svpp3_mdp_rdma",
+	"vpp1_svpp3_mdp_fg",
+	"vpp1_vpp_split",
+	"vpp1_svpp2_vdo0_dl_relay",
+	"vpp1_svpp1_mdp_tdshp",
+	"vpp1_svpp1_mdp_color",
+	"vpp1_svpp3_vdo1_dl_relay",
+	"vpp1_svpp2_vpp_merge",
+	"vpp1_svpp2_mdp_color",
+	"vpp1_vppsys1_gals",
+	"vpp1_svpp3_vpp_merge",
+	"vpp1_svpp3_mdp_color",
+	"vpp1_vppsys1_larb",
+	"vpp1_svpp1_mdp_rsz",
+	"vpp1_svpp1_mdp_hdr",
+	"vpp1_svpp1_mdp_aal",
+	"vpp1_svpp2_mdp_hdr",
+	"vpp1_svpp2_mdp_aal",
+	"vpp1_dl_async",
+	"vpp1_larb5_fake_eng",
+	"vpp1_svpp3_mdp_hdr",
+	"vpp1_svpp3_mdp_aal",
+	"vpp1_svpp2_vdo1_dl_relay",
+	"vpp1_larb6_fake_eng",
+	"vpp1_svpp2_mdp_rsz",
+	"vpp1_svpp3_mdp_rsz",
+	"vpp1_svpp3_vdo0_dl_relay",
+	"vpp1_disp_mutex",
+	"vpp1_svpp2_mdp_tdshp",
+	"vpp1_svpp3_mdp_tdshp",
+	"vpp1_vpp0_dl1_relay",
+	"vpp1_hdmi_meta",
+	"vpp1_vpp_split_hdmi",
+	"vpp1_dgi_in",
+	"vpp1_dgi_out",
+	"vpp1_vpp_split_dgi",
+	"vpp1_vpp0_dl_async",
+	"vpp1_vpp0_dl_relay",
+	"vpp1_vpp_split_26m",
+	"img_larb9",
+	"img_traw0",
+	"img_traw1",
+	"img_traw2",
+	"img_traw3",
+	"img_dip0",
+	"img_wpe0",
+	"img_ipe",
+	"img_dip1",
+	"img_wpe1",
+	"img_gals",
+	"img1_dip_top_larb10",
+	"img1_dip_top_dip_top",
+	"img1_dip_nr_reserve",
+	"img1_dip_nr_dip_nr",
+	"img1_wpe_larb11",
+	"img1_wpe_wpe",
+	"ipe_dpe",
+	"ipe_fdvt",
+	"ipe_me",
+	"ipe_top",
+	"ipe_smi_larb12",
+	"cam_larb13",
+	"cam_larb14",
+	"cam_main_cam",
+	"cam_main_camtg",
+	"cam_seninf",
+	"cam_gcamsva",
+	"cam_gcamsvb",
+	"cam_gcamsvc",
+	"cam_scamsa",
+	"cam_scamsb",
+	"cam_camsv_top",
+	"cam_camsv_cq",
+	"cam_adl",
+	"cam_asg",
+	"cam_pda",
+	"cam_fake_eng",
+	"cam_main_mraw0",
+	"cam_main_mraw1",
+	"cam_main_mraw2",
+	"cam_main_mraw3",
+	"cam_cam2mm0_gals",
+	"cam_cam2mm1_gals",
+	"cam_cam2sys_gals",
+	"cam_rawa_larbx",
+	"cam_rawa_cam",
+	"cam_rawa_camtg",
+	"cam_yuva_larbx",
+	"cam_yuva_cam",
+	"cam_yuva_camtg",
+	"cam_rawb_larbx",
+	"cam_rawb_cam",
+	"cam_rawb_camtg",
+	"cam_yuvb_larbx",
+	"cam_yuvb_cam",
+	"cam_yuvb_camtg",
+	"cam_mraw_larbx",
+	"cam_mraw_camtg",
+	"cam_mraw_mraw0",
+	"cam_mraw_mraw1",
+	"cam_mraw_mraw2",
+	"cam_mraw_mraw3",
+	"ccu_larb18",
+	"ccu_ahb",
+	"ccu_ccu0",
+	"ccu_ccu1",
+	"vdec_soc_larb1",
+	"vdec_soc_lat",
+	"vdec_soc_vdec",
+	"vdec_larb1",
+	"vdec_lat",
+	"vdec_vdec",
+	"vdec_core1_larb1",
+	"vdec_core1_lat",
+	"vdec_core1_vdec",
+	"venc_larb",
+	"venc_venc",
+	"venc_jpgenc",
+	"venc_jpgdec",
+	"venc_jpgdec_c1",
+	"venc_gals",
+	"venc_core1_larb",
+	"venc_core1_venc",
+	"venc_core1_jpgenc",
+	"venc_core1_jpgdec",
+	"venc_core1_jpgdec_c1",
+	"venc_core1_gals",
+	"vdo0_disp_ovl0",
+	"vdo0_disp_color0",
+	"vdo0_disp_color1",
+	"vdo0_disp_ccorr0",
+	"vdo0_disp_ccorr1",
+	"vdo0_disp_aal0",
+	"vdo0_disp_aal1",
+	"vdo0_disp_gamma0",
+	"vdo0_disp_gamma1",
+	"vdo0_disp_dither0",
+	"vdo0_disp_dither1",
+	"vdo0_disp_ovl1",
+	"vdo0_disp_wdma0",
+	"vdo0_disp_wdma1",
+	"vdo0_disp_rdma0",
+	"vdo0_disp_rdma1",
+	"vdo0_dsi0",
+	"vdo0_dsi1",
+	"vdo0_dsc_wrap0",
+	"vdo0_vpp_merge0",
+	"vdo0_dp_intf0",
+	"vdo0_disp_mutex0",
+	"vdo0_disp_il_rot0",
+	"vdo0_apb_bus",
+	"vdo0_fake_eng0",
+	"vdo0_fake_eng1",
+	"vdo0_dl_async0",
+	"vdo0_dl_async1",
+	"vdo0_dl_async2",
+	"vdo0_dl_async3",
+	"vdo0_dl_async4",
+	"vdo0_disp_monitor0",
+	"vdo0_disp_monitor1",
+	"vdo0_disp_monitor2",
+	"vdo0_disp_monitor3",
+	"vdo0_disp_monitor4",
+	"vdo0_smi_gals",
+	"vdo0_smi_common",
+	"vdo0_smi_emi",
+	"vdo0_smi_iommu",
+	"vdo0_smi_larb",
+	"vdo0_smi_rsi",
+	"vdo0_dsi0_dsi",
+	"vdo0_dsi1_dsi",
+	"vdo0_dp_intf0_dp_intf",
+	"vdo1_smi_larb2",
+	"vdo1_smi_larb3",
+	"vdo1_gals",
+	"vdo1_fake_eng0",
+	"vdo1_fake_eng",
+	"vdo1_mdp_rdma0",
+	"vdo1_mdp_rdma1",
+	"vdo1_mdp_rdma2",
+	"vdo1_mdp_rdma3",
+	"vdo1_vpp_merge0",
+	"vdo1_vpp_merge1",
+	"vdo1_vpp_merge2",
+	"vdo1_vpp_merge3",
+	"vdo1_vpp_merge4",
+	"vdo1_vpp2_to_vdo1_dl_async",
+	"vdo1_vpp3_to_vdo1_dl_async",
+	"vdo1_disp_mutex",
+	"vdo1_mdp_rdma4",
+	"vdo1_mdp_rdma5",
+	"vdo1_mdp_rdma6",
+	"vdo1_mdp_rdma7",
+	"vdo1_dp_intf0_mm",
+	"vdo1_dpi0_mm",
+	"vdo1_dpi1_mm",
+	"vdo1_disp_monitor",
+	"vdo1_merge0_dl_async",
+	"vdo1_merge1_dl_async",
+	"vdo1_merge2_dl_async",
+	"vdo1_merge3_dl_async",
+	"vdo1_merge4_dl_async",
+	"vdo1_vdo0_dsc_to_vdo1_dl_async",
+	"vdo1_vdo0_merge_to_vdo1_dl_async",
+	"vdo1_hdr_vdo_fe0",
+	"vdo1_hdr_gfx_fe0",
+	"vdo1_hdr_vdo_be",
+	"vdo1_hdr_vdo_fe1",
+	"vdo1_hdr_gfx_fe1",
+	"vdo1_disp_mixer",
+	"vdo1_hdr_vdo_fe0_dl_async",
+	"vdo1_hdr_vdo_fe1_dl_async",
+	"vdo1_hdr_gfx_fe0_dl_async",
+	"vdo1_hdr_gfx_fe1_dl_async",
+	"vdo1_hdr_vdo_be_dl_async",
+	"vdo1_dpi0",
+	"vdo1_disp_monitor_dpi0",
+	"vdo1_dpi1",
+	"vdo1_disp_monitor_dpi1",
+	"vdo1_dpintf",
+	"vdo1_disp_monitor_dpintf",
+	"vdo1_26m_slow",
+	/* end */
+	NULL
+};
+
+static const char * const compatible[] = {"mediatek,mt8195", NULL};
+
+static struct clkchk_cfg_t cfg = {
+	.aee_excp_on_fail = false,
+	.warn_on_fail = true,
+	.compatible = compatible,
+	.off_pll_names = off_pll_names,
+	.all_clk_names = all_clk_names,
+};
+
+static int __init clkchk_platform_init(void)
+{
+	return clkchk_init(&cfg);
+}
+subsys_initcall(clkchk_platform_init);
diff --git a/drivers/clk/mediatek/clkchk.c b/drivers/clk/mediatek/clkchk.c
new file mode 100644
index 0000000000000000000000000000000000000000..cea8b558b539c28a7aa76c2ca5b3578a02edd74a
--- /dev/null
+++ b/drivers/clk/mediatek/clkchk.c
@@ -0,0 +1,188 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2019 MediaTek Inc.
+ */
+
+#define pr_fmt(fmt) "[clkchk] " fmt
+
+#include <linux/clk-provider.h>
+#include <linux/syscore_ops.h>
+#include "clkchk.h"
+
+#define AEE_EXCP_CHECK_PLL_FAIL	0
+#define CLKDBG_CCF_API_4_4	1
+#define MAX_PLLS		32
+
+#if AEE_EXCP_CHECK_PLL_FAIL
+#include <mt-plat/aee.h>
+#endif
+
+#if !CLKDBG_CCF_API_4_4
+
+/* backward compatible */
+
+static const char *clk_hw_get_name(const struct clk_hw *hw)
+{
+	return __clk_get_name(hw->clk);
+}
+
+static bool clk_hw_is_prepared(const struct clk_hw *hw)
+{
+	return __clk_is_prepared(hw->clk);
+}
+
+static bool clk_hw_is_enabled(const struct clk_hw *hw)
+{
+	return __clk_is_enabled(hw->clk);
+}
+
+static unsigned long clk_hw_get_rate(const struct clk_hw *hw)
+{
+	return __clk_get_rate(hw->clk);
+}
+
+static struct clk_hw *clk_hw_get_parent(const struct clk_hw *hw)
+{
+	return __clk_get_hw(clk_get_parent(hw->clk));
+}
+
+#endif /* !CLKDBG_CCF_API_4_4 */
+
+static struct clkchk_cfg_t *clkchk_cfg;
+
+static const char *ccf_state(struct clk_hw *hw)
+{
+	if (__clk_get_enable_count(hw->clk))
+		return "enabled";
+
+	if (clk_hw_is_prepared(hw))
+		return "prepared";
+
+	return "disabled";
+}
+
+static void print_enabled_clks(void)
+{
+	const char * const *cn = clkchk_cfg->all_clk_names;
+
+	pr_warn("enabled clks:\n");
+
+	for (; *cn != NULL; cn++) {
+		struct clk *c = __clk_lookup(*cn);
+		struct clk_hw *c_hw = __clk_get_hw(c);
+		struct clk_hw *p_hw;
+
+		if (IS_ERR_OR_NULL(c) || c_hw == NULL)
+			continue;
+
+		p_hw = clk_hw_get_parent(c_hw);
+
+		if (p_hw == NULL)
+			continue;
+
+		if (!clk_hw_is_prepared(c_hw) &&
+			__clk_get_enable_count(c) <= 0U)
+			continue;
+
+		pr_warn("[%-17s: %8s, %3d, %3d, %10ld, %17s]\n",
+			clk_hw_get_name(c_hw),
+			ccf_state(c_hw),
+			clk_hw_is_prepared(c_hw),
+			__clk_get_enable_count(c),
+			clk_hw_get_rate(c_hw),
+			p_hw != NULL ? clk_hw_get_name(p_hw) : "- ");
+	}
+}
+
+static void check_pll_off(void)
+{
+	static struct clk *off_plls[MAX_PLLS];
+
+	struct clk **c;
+	int invalid = 0;
+	char buf[128] = {0};
+	int n = 0;
+
+	if (off_plls[0] == NULL) {
+		const char * const *pn = clkchk_cfg->off_pll_names;
+		struct clk **end = off_plls + MAX_PLLS - 1;
+
+		for (c = off_plls; *pn != NULL && c < end; pn++, c++)
+			*c = __clk_lookup(*pn);
+	}
+
+	for (c = off_plls; *c != NULL; c++) {
+		struct clk_hw *c_hw = __clk_get_hw(*c);
+
+		if (c_hw == NULL)
+			continue;
+
+		if (!clk_hw_is_prepared(c_hw) && !clk_hw_is_enabled(c_hw))
+			continue;
+
+		n += snprintf(buf + n, sizeof(buf) - (size_t)n, "%s ",
+				clk_hw_get_name(c_hw));
+
+		invalid++;
+	}
+
+	if (invalid == 0)
+		return;
+
+	/* invalid. output debug info */
+
+	pr_warn("unexpected unclosed PLL: %s\n", buf);
+	print_enabled_clks();
+
+#if AEE_EXCP_CHECK_PLL_FAIL
+	if (clkchk_cfg->aee_excp_on_fail)
+		aee_kernel_exception("clkchk", "unclosed PLL: %s\n", buf);
+#endif
+
+	if (clkchk_cfg->warn_on_fail)
+		WARN_ON(true);
+}
+
+static int clkchk_syscore_suspend(void)
+{
+	check_pll_off();
+
+	return 0;
+}
+
+static void clkchk_syscore_resume(void)
+{
+}
+
+static struct syscore_ops clkchk_syscore_ops = {
+	.suspend = clkchk_syscore_suspend,
+	.resume = clkchk_syscore_resume,
+};
+
+int clkchk_init(struct clkchk_cfg_t *cfg)
+{
+	const char * const *c;
+	bool match = false;
+
+	if (cfg == NULL || cfg->compatible == NULL
+		|| cfg->all_clk_names == NULL || cfg->off_pll_names == NULL) {
+		pr_warn("Invalid clkchk_cfg.\n");
+		return -EINVAL;
+	}
+
+	clkchk_cfg = cfg;
+
+	for (c = cfg->compatible; *c != NULL; c++) {
+		if (of_machine_is_compatible(*c) != 0) {
+			match = true;
+			break;
+		}
+	}
+
+	if (!match)
+		return -ENODEV;
+
+	register_syscore_ops(&clkchk_syscore_ops);
+
+	return 0;
+}
diff --git a/drivers/clk/mediatek/clkchk.h b/drivers/clk/mediatek/clkchk.h
new file mode 100644
index 0000000000000000000000000000000000000000..c9f1e103ffd3c35cb8e965732122028b0340a9c0
--- /dev/null
+++ b/drivers/clk/mediatek/clkchk.h
@@ -0,0 +1,17 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2019 MediaTek Inc.
+ */
+
+#include <stdbool.h>
+#include <stddef.h>
+
+struct clkchk_cfg_t {
+	bool aee_excp_on_fail;
+	bool warn_on_fail;
+	const char * const *compatible;
+	const char * const *off_pll_names;
+	const char * const *all_clk_names;
+};
+
+int clkchk_init(struct clkchk_cfg_t *cfg);
diff --git a/drivers/clk/mediatek/clkdbg-mt8195.c b/drivers/clk/mediatek/clkdbg-mt8195.c
new file mode 100644
index 0000000000000000000000000000000000000000..2ef4a49d3be029f50e8d8eee1ce6787fb8d005c3
--- /dev/null
+++ b/drivers/clk/mediatek/clkdbg-mt8195.c
@@ -0,0 +1,1778 @@
+// SPDX-License-Identifier: GPL-2.0
+//
+// Copyright (c) 2020 MediaTek Inc.
+// Author: Weiyi Lu <weiyi.lu@mediatek.com>
+
+#include <linux/clk-provider.h>
+#include <linux/io.h>
+#include <linux/seq_file.h>
+
+#include "clkdbg.h"
+
+#define DUMP_INIT_STATE		0
+
+/*
+ * clkdbg dump_regs
+ */
+
+enum {
+	mcucfg,
+	topckgen,
+	infracfg_ao,
+	scpsys,
+	apmixedsys,
+	infracfg_ao_bcrm,
+	scp_adsp,
+	pericfg_ao,
+	imp_iic_wrap_s,
+	imp_iic_wrap_w,
+	mfgcfg,
+	vppsys0,
+	wpesys,
+	wpesys_vpp0,
+	wpesys_vpp1,
+	vppsys1,
+	imgsys,
+	imgsys1_dip_top,
+	imgsys1_dip_nr,
+	imgsys1_wpe,
+	ipesys,
+	camsys,
+	camsys_rawa,
+	camsys_yuva,
+	camsys_rawb,
+	camsys_yuvb,
+	camsys_mraw,
+	ccusys,
+	vdecsys_soc,
+	vdecsys,
+	vdecsys_core1,
+	apusys_pll,
+	vencsys,
+	vencsys_core1,
+	vdosys0,
+	vdosys1,
+};
+
+#define REGBASE_V(_phys, _id_name) { .phys = _phys, .name = #_id_name }
+
+/*
+ * checkpatch.pl ERROR:COMPLEX_MACRO
+ *
+ * #define REGBASE(_phys, _id_name) [_id_name] = REGBASE_V(_phys, _id_name)
+ */
+
+static struct regbase rb[] = {
+	[mcucfg] = REGBASE_V(0x0C53A000, mcucfg),	/* PAGE_SIZE: 0x0C530000 -> 0x0C53A000 */
+	[topckgen] = REGBASE_V(0x10000000, topckgen),
+	[infracfg_ao] = REGBASE_V(0x10001000, infracfg_ao),
+	[scpsys] = REGBASE_V(0x10006000, scpsys),
+	[apmixedsys] = REGBASE_V(0x1000C000, apmixedsys),
+	[infracfg_ao_bcrm] = REGBASE_V(0x10022000, infracfg_ao_bcrm),
+	[scp_adsp] = REGBASE_V(0x10720000, scp_adsp),
+	[pericfg_ao] = REGBASE_V(0x11003000, pericfg_ao),
+	[imp_iic_wrap_s] = REGBASE_V(0x11D03000, imp_iic_wrap_s),
+	[imp_iic_wrap_w] = REGBASE_V(0x11E05000, imp_iic_wrap_w),
+	[mfgcfg] = REGBASE_V(0x13fbf000, mfgcfg),
+	[vppsys0] = REGBASE_V(0x14000000, vppsys0),
+	[wpesys] = REGBASE_V(0x14e00000, wpesys),
+	[wpesys_vpp0] = REGBASE_V(0x14e02000, wpesys_vpp0),
+	[wpesys_vpp1] = REGBASE_V(0x14e03000, wpesys_vpp1),
+	[vppsys1] = REGBASE_V(0x14f00000, vppsys1),
+	[imgsys] = REGBASE_V(0x15000000, imgsys),
+	[imgsys1_dip_top] = REGBASE_V(0x15110000, imgsys1_dip_top),
+	[imgsys1_dip_nr] = REGBASE_V(0x15130000, imgsys1_dip_nr),
+	[imgsys1_wpe] = REGBASE_V(0x15220000, imgsys1_wpe),
+	[ipesys] = REGBASE_V(0x15330000, ipesys),
+	[camsys] = REGBASE_V(0x16000000, camsys),
+	[camsys_rawa] = REGBASE_V(0x1604f000, camsys_rawa),
+	[camsys_yuva] = REGBASE_V(0x1606f000, camsys_yuva),
+	[camsys_rawb] = REGBASE_V(0x1608f000, camsys_rawb),
+	[camsys_yuvb] = REGBASE_V(0x160af000, camsys_yuvb),
+	[camsys_mraw] = REGBASE_V(0x16140000, camsys_mraw),
+	[ccusys] = REGBASE_V(0x17200000, ccusys),
+	[vdecsys_soc] = REGBASE_V(0x1800f000, vdecsys_soc),
+	[vdecsys] = REGBASE_V(0x1802f000, vdecsys),
+	[vdecsys_core1] = REGBASE_V(0x1803f000, vdecsys_core1),
+	[apusys_pll] = REGBASE_V(0x190F3000, apusys_pll),
+	[vencsys] = REGBASE_V(0x1a000000, vencsys),
+	[vencsys_core1] = REGBASE_V(0x1b000000, vencsys_core1),
+	[vdosys0] = REGBASE_V(0x1c01a000, vdosys0),
+	[vdosys1] = REGBASE_V(0x1c100000, vdosys1),
+};
+
+#define REGNAME(_base, _ofs, _name)	\
+	{ .base = &rb[_base], .ofs = _ofs, .name = #_name }
+
+static struct regname rn[] = {
+	REGNAME(apmixedsys, 0x0000, AP_PLL_CON0),
+	REGNAME(apmixedsys, 0x0020, ARMPLL_LL_CON0),
+	REGNAME(apmixedsys, 0x0024, ARMPLL_LL_CON1),
+	REGNAME(apmixedsys, 0x0028, ARMPLL_LL_CON2),
+	REGNAME(apmixedsys, 0x002C, ARMPLL_LL_CON3),
+	REGNAME(apmixedsys, 0X0600, ARMPLL_LL_CON4),
+	REGNAME(apmixedsys, 0X0070, ARMPLL_BL_CON0),
+	REGNAME(apmixedsys, 0X0074, ARMPLL_BL_CON1),
+	REGNAME(apmixedsys, 0X0078, ARMPLL_BL_CON2),
+	REGNAME(apmixedsys, 0X007C, ARMPLL_BL_CON3),
+	REGNAME(apmixedsys, 0X0080, ARMPLL_BL_CON4),
+	REGNAME(apmixedsys, 0X0030, CCIPLL_CON0),
+	REGNAME(apmixedsys, 0X0634, CCIPLL_CON1),
+	REGNAME(apmixedsys, 0X0638, CCIPLL_CON2),
+	REGNAME(apmixedsys, 0X063C, CCIPLL_CON3),
+	REGNAME(apmixedsys, 0X0640, CCIPLL_CON4),
+	REGNAME(apmixedsys, 0X0390, NNAPLL_CON0),
+	REGNAME(apmixedsys, 0X0394, NNAPLL_CON1),
+	REGNAME(apmixedsys, 0X0398, NNAPLL_CON2),
+	REGNAME(apmixedsys, 0X039C, NNAPLL_CON3),
+	REGNAME(apmixedsys, 0X03A0, NNAPLL_CON4),
+	REGNAME(apmixedsys, 0X0190, RESPLL_CON0),
+	REGNAME(apmixedsys, 0X0194, RESPLL_CON1),
+	REGNAME(apmixedsys, 0X0198, RESPLL_CON2),
+	REGNAME(apmixedsys, 0X019C, RESPLL_CON3),
+	REGNAME(apmixedsys, 0X0320, RESPLL_CON4),
+	REGNAME(apmixedsys, 0X0360, ETHPLL_CON0),
+	REGNAME(apmixedsys, 0X0364, ETHPLL_CON1),
+	REGNAME(apmixedsys, 0X0368, ETHPLL_CON2),
+	REGNAME(apmixedsys, 0X036C, ETHPLL_CON3),
+	REGNAME(apmixedsys, 0X0370, ETHPLL_CON4),
+	REGNAME(apmixedsys, 0X0710, MSDCPLL_CON0),
+	REGNAME(apmixedsys, 0X0714, MSDCPLL_CON1),
+	REGNAME(apmixedsys, 0X0718, MSDCPLL_CON2),
+	REGNAME(apmixedsys, 0X071C, MSDCPLL_CON3),
+	REGNAME(apmixedsys, 0X0720, MSDCPLL_CON4),
+	REGNAME(apmixedsys, 0X00A0, TVDPLL1_CON0),
+	REGNAME(apmixedsys, 0X00A4, TVDPLL1_CON1),
+	REGNAME(apmixedsys, 0X00A8, TVDPLL1_CON2),
+	REGNAME(apmixedsys, 0X00AC, TVDPLL1_CON3),
+	REGNAME(apmixedsys, 0X00B0, TVDPLL1_CON4),
+	REGNAME(apmixedsys, 0X00C0, TVDPLL2_CON0),
+	REGNAME(apmixedsys, 0X00C4, TVDPLL2_CON1),
+	REGNAME(apmixedsys, 0X00C8, TVDPLL2_CON2),
+	REGNAME(apmixedsys, 0X00CC, TVDPLL2_CON3),
+	REGNAME(apmixedsys, 0X00D0, TVDPLL2_CON4),
+	REGNAME(apmixedsys, 0X0800, MPLL_CON0),
+	REGNAME(apmixedsys, 0X0804, MPLL_CON1),
+	REGNAME(apmixedsys, 0X0808, MPLL_CON2),
+	REGNAME(apmixedsys, 0X080C, MPLL_CON3),
+	REGNAME(apmixedsys, 0X0810, MPLL_CON4),
+	REGNAME(apmixedsys, 0X00E0, MMPLL_CON0),
+	REGNAME(apmixedsys, 0X00E4, MMPLL_CON1),
+	REGNAME(apmixedsys, 0X00E8, MMPLL_CON2),
+	REGNAME(apmixedsys, 0X00EC, MMPLL_CON3),
+	REGNAME(apmixedsys, 0X00F0, MMPLL_CON4),
+	REGNAME(apmixedsys, 0X01D0, MAINPLL_CON0),
+	REGNAME(apmixedsys, 0X01D4, MAINPLL_CON1),
+	REGNAME(apmixedsys, 0X01D8, MAINPLL_CON2),
+	REGNAME(apmixedsys, 0X01DC, MAINPLL_CON3),
+	REGNAME(apmixedsys, 0X01E0, MAINPLL_CON4),
+	REGNAME(apmixedsys, 0X0890, VDECPLL_CON0),
+	REGNAME(apmixedsys, 0X0894, VDECPLL_CON1),
+	REGNAME(apmixedsys, 0X0898, VDECPLL_CON2),
+	REGNAME(apmixedsys, 0X089C, VDECPLL_CON3),
+	REGNAME(apmixedsys, 0X08A0, VDECPLL_CON4),
+	REGNAME(apmixedsys, 0X0100, IMGPLL_CON0),
+	REGNAME(apmixedsys, 0X0104, IMGPLL_CON1),
+	REGNAME(apmixedsys, 0X0108, IMGPLL_CON2),
+	REGNAME(apmixedsys, 0X010C, IMGPLL_CON3),
+	REGNAME(apmixedsys, 0X0110, IMGPLL_CON4),
+	REGNAME(apmixedsys, 0X01F0, UNIVPLL_CON0),
+	REGNAME(apmixedsys, 0X01F4, UNIVPLL_CON1),
+	REGNAME(apmixedsys, 0X01F8, UNIVPLL_CON2),
+	REGNAME(apmixedsys, 0X01FC, UNIVPLL_CON3),
+	REGNAME(apmixedsys, 0X0700, UNIVPLL_CON4),
+	REGNAME(apmixedsys, 0X08C0, HDMIPLL1_CON0),
+	REGNAME(apmixedsys, 0X08C4, HDMIPLL1_CON1),
+	REGNAME(apmixedsys, 0X08C8, HDMIPLL1_CON2),
+	REGNAME(apmixedsys, 0X08CC, HDMIPLL1_CON3),
+	REGNAME(apmixedsys, 0X08D0, HDMIPLL1_CON4),
+	REGNAME(apmixedsys, 0X0870, HDMIPLL2_CON0),
+	REGNAME(apmixedsys, 0X0874, HDMIPLL2_CON1),
+	REGNAME(apmixedsys, 0X0878, HDMIPLL2_CON2),
+	REGNAME(apmixedsys, 0X087C, HDMIPLL2_CON3),
+	REGNAME(apmixedsys, 0X0880, HDMIPLL2_CON4),
+	REGNAME(apmixedsys, 0X08E0, HDMIRX_APLL_CON0),
+	REGNAME(apmixedsys, 0X08E4, HDMIRX_APLL_CON1),
+	REGNAME(apmixedsys, 0X08E8, HDMIRX_APLL_CON2),
+	REGNAME(apmixedsys, 0X08EC, HDMIRX_APLL_CON3),
+	REGNAME(apmixedsys, 0X08F0, HDMIRX_APLL_CON4),
+	REGNAME(apmixedsys, 0X0DD4, HDMIRX_APLL_CON5),
+	REGNAME(apmixedsys, 0X01A0, USB1PLL_CON0),
+	REGNAME(apmixedsys, 0X01A4, USB1PLL_CON1),
+	REGNAME(apmixedsys, 0X01A8, USB1PLL_CON2),
+	REGNAME(apmixedsys, 0X01AC, USB1PLL_CON3),
+	REGNAME(apmixedsys, 0X01B0, USB1PLL_CON4),
+	REGNAME(apmixedsys, 0X07E0, ADSPPLL_CON0),
+	REGNAME(apmixedsys, 0X07E4, ADSPPLL_CON1),
+	REGNAME(apmixedsys, 0X07E8, ADSPPLL_CON2),
+	REGNAME(apmixedsys, 0X07EC, ADSPPLL_CON3),
+	REGNAME(apmixedsys, 0X07F0, ADSPPLL_CON4),
+	REGNAME(apmixedsys, 0X07C0, APLL1_CON0),
+	REGNAME(apmixedsys, 0X07C4, APLL1_CON1),
+	REGNAME(apmixedsys, 0X07C8, APLL1_CON2),
+	REGNAME(apmixedsys, 0X07CC, APLL1_CON3),
+	REGNAME(apmixedsys, 0X07D0, APLL1_CON4),
+	REGNAME(apmixedsys, 0X0DC0, APLL1_CON5),
+	REGNAME(apmixedsys, 0X0780, APLL2_CON0),
+	REGNAME(apmixedsys, 0X0784, APLL2_CON1),
+	REGNAME(apmixedsys, 0X0788, APLL2_CON2),
+	REGNAME(apmixedsys, 0X078C, APLL2_CON3),
+	REGNAME(apmixedsys, 0X0790, APLL2_CON4),
+	REGNAME(apmixedsys, 0X0DC4, APLL2_CON5),
+	REGNAME(apmixedsys, 0X0760, APLL3_CON0),
+	REGNAME(apmixedsys, 0X0764, APLL3_CON1),
+	REGNAME(apmixedsys, 0X0768, APLL3_CON2),
+	REGNAME(apmixedsys, 0X076C, APLL3_CON3),
+	REGNAME(apmixedsys, 0X0770, APLL3_CON4),
+	REGNAME(apmixedsys, 0X0DC8, APLL3_CON5),
+	REGNAME(apmixedsys, 0X0740, APLL4_CON0),
+	REGNAME(apmixedsys, 0X0744, APLL4_CON1),
+	REGNAME(apmixedsys, 0X0748, APLL4_CON2),
+	REGNAME(apmixedsys, 0X074C, APLL4_CON3),
+	REGNAME(apmixedsys, 0X0750, APLL4_CON4),
+	REGNAME(apmixedsys, 0X0DCC, APLL4_CON5),
+	REGNAME(apmixedsys, 0X07A0, APLL5_CON0),
+	REGNAME(apmixedsys, 0X07A4, APLL5_CON1),
+	REGNAME(apmixedsys, 0X07A8, APLL5_CON2),
+	REGNAME(apmixedsys, 0X07AC, APLL5_CON3),
+	REGNAME(apmixedsys, 0X07B0, APLL5_CON4),
+	REGNAME(apmixedsys, 0X0DD0, APLL5_CON5),
+	REGNAME(apmixedsys, 0X0340, MFGPLL_CON0),
+	REGNAME(apmixedsys, 0X0344, MFGPLL_CON1),
+	REGNAME(apmixedsys, 0X0348, MFGPLL_CON2),
+	REGNAME(apmixedsys, 0X034C, MFGPLL_CON3),
+	REGNAME(apmixedsys, 0X0350, MFGPLL_CON4),
+	REGNAME(apmixedsys, 0X0150, DGIPLL_CON0),
+	REGNAME(apmixedsys, 0X0154, DGIPLL_CON1),
+	REGNAME(apmixedsys, 0X0158, DGIPLL_CON2),
+	REGNAME(apmixedsys, 0X015C, DGIPLL_CON3),
+	REGNAME(apmixedsys, 0X0160, DGIPLL_CON4),
+	REGNAME(apmixedsys, 0x0470, APLL1_TUNER_CON0),
+	REGNAME(apmixedsys, 0x0474, APLL2_TUNER_CON0),
+	REGNAME(apmixedsys, 0x0478, APLL3_TUNER_CON0),
+	REGNAME(apmixedsys, 0x047C, APLL4_TUNER_CON0),
+	REGNAME(apmixedsys, 0x0480, APLL5_TUNER_CON0),
+	REGNAME(apusys_pll, 0x008, PLL4H_PLL1_CON0),
+	REGNAME(apusys_pll, 0x00C, PLL4H_PLL1_CON1),
+	REGNAME(apusys_pll, 0x014, PLL4H_PLL1_CON3),
+	REGNAME(apusys_pll, 0x018, PLL4H_PLL2_CON0),
+	REGNAME(apusys_pll, 0x01C, PLL4H_PLL2_CON1),
+	REGNAME(apusys_pll, 0x024, PLL4H_PLL2_CON3),
+	REGNAME(apusys_pll, 0x028, PLL4H_PLL3_CON0),
+	REGNAME(apusys_pll, 0x02C, PLL4H_PLL3_CON1),
+	REGNAME(apusys_pll, 0x034, PLL4H_PLL3_CON3),
+	REGNAME(apusys_pll, 0x038, PLL4H_PLL4_CON0),
+	REGNAME(apusys_pll, 0x03C, PLL4H_PLL4_CON1),
+	REGNAME(apusys_pll, 0x044, PLL4H_PLL4_CON3),
+	REGNAME(mcucfg, 0x02A0, CPU_PLLDIV_CFG0),	/* PAGE_SIZE: 0xA2A0->0x02A0 */
+	REGNAME(mcucfg, 0x02A4, CPU_PLLDIV_CFG1),	/* PAGE_SIZE: 0xA2A4->0x02A4 */
+	REGNAME(mcucfg, 0x02E0, BUS_PLLDIV_CFG),	/* PAGE_SIZE: 0xA2E0->0x02E0 */
+	REGNAME(infracfg_ao, 0x70, INFRA_BUS_DCM_CTRL),
+	REGNAME(infracfg_ao_bcrm, 0x034, VDNR_DCM_TOP_INFRA_CTRL0),
+	REGNAME(topckgen, 0x0264, CLK_SCP_CFG_0),
+	REGNAME(topckgen, 0x020, CLK_CFG_0),
+	REGNAME(topckgen, 0x02c, CLK_CFG_1),
+	REGNAME(topckgen, 0x038, CLK_CFG_2),
+	REGNAME(topckgen, 0x044, CLK_CFG_3),
+	REGNAME(topckgen, 0x050, CLK_CFG_4),
+	REGNAME(topckgen, 0x05c, CLK_CFG_5),
+	REGNAME(topckgen, 0x068, CLK_CFG_6),
+	REGNAME(topckgen, 0x074, CLK_CFG_7),
+	REGNAME(topckgen, 0x080, CLK_CFG_8),
+	REGNAME(topckgen, 0x08c, CLK_CFG_9),
+	REGNAME(topckgen, 0x098, CLK_CFG_10),
+	REGNAME(topckgen, 0x0a4, CLK_CFG_11),
+	REGNAME(topckgen, 0x0b0, CLK_CFG_12),
+	REGNAME(topckgen, 0x0bc, CLK_CFG_13),
+	REGNAME(topckgen, 0x0c8, CLK_CFG_14),
+	REGNAME(topckgen, 0x0d4, CLK_CFG_15),
+	REGNAME(topckgen, 0x0e0, CLK_CFG_16),
+	REGNAME(topckgen, 0x0ec, CLK_CFG_17),
+	REGNAME(topckgen, 0x0f8, CLK_CFG_18),
+	REGNAME(topckgen, 0x104, CLK_CFG_19),
+	REGNAME(topckgen, 0x110, CLK_CFG_20),
+	REGNAME(topckgen, 0x11c, CLK_CFG_21),
+	REGNAME(topckgen, 0x128, CLK_CFG_22),
+	REGNAME(topckgen, 0x134, CLK_CFG_23),
+	REGNAME(topckgen, 0x140, CLK_CFG_24),
+	REGNAME(topckgen, 0x14c, CLK_CFG_25),
+	REGNAME(topckgen, 0x158, CLK_CFG_26),
+	REGNAME(topckgen, 0x164, CLK_CFG_27),
+	REGNAME(topckgen, 0x170, CLK_CFG_28),
+	REGNAME(topckgen, 0x17c, CLK_CFG_29),
+	REGNAME(topckgen, 0x1dc, CLK_CFG_37),
+	REGNAME(scpsys, 0x16C, PWR_STATUS),
+	REGNAME(scpsys, 0x170, PWR_STATUS_2ND),
+	REGNAME(scpsys, 0x174, CPU_PWR_STATUS),
+	REGNAME(scpsys, 0x178, CPU_PWR_STATUS_2ND),
+	REGNAME(scpsys, 0x300, MFG0_PWR_CON),
+	REGNAME(scpsys, 0x304, MFG1_PWR_CON),
+	REGNAME(scpsys, 0x308, MFG2_PWR_CON),
+	REGNAME(scpsys, 0x30C, MFG3_PWR_CON),
+	REGNAME(scpsys, 0x310, MFG4_PWR_CON),
+	REGNAME(scpsys, 0x314, MFG5_PWR_CON),
+	REGNAME(scpsys, 0x318, MFG6_PWR_CON),
+	REGNAME(scpsys, 0x328, PEXTP_MAC_TOP_P0_PWR_CON),
+	REGNAME(scpsys, 0x32C, PEXTP_MAC_TOP_P1_PWR_CON),
+	REGNAME(scpsys, 0x330, PCIE_PHY_PWR_CON),
+	REGNAME(scpsys, 0x334, SSUSB_PCIE_PHY_PWR_CON),
+	REGNAME(scpsys, 0x338, SSUSB_TOP_P1_PWR_CON),
+	REGNAME(scpsys, 0x33C, SSUSB_TOP_P2_PWR_CON),
+	REGNAME(scpsys, 0x340, SSUSB_TOP_P3_PWR_CON),
+	REGNAME(scpsys, 0x344, ETHER_PWR_CON),
+	REGNAME(scpsys, 0x358, AUDIO_PWR_CON),
+	REGNAME(scpsys, 0x35C, AUDIO_ASRC_PWR_CON),
+	REGNAME(scpsys, 0x360, ADSP_PWR_CON),
+	REGNAME(scpsys, 0x364, VPPSYS0_PWR_CON),
+	REGNAME(scpsys, 0x368, VPPSYS1_PWR_CON),
+	REGNAME(scpsys, 0x36C, VDOSYS0_PWR_CON),
+	REGNAME(scpsys, 0x370, VDOSYS1_PWR_CON),
+	REGNAME(scpsys, 0x374, WPESYS_PWR_CON),
+	REGNAME(scpsys, 0x378, DP_TX_PWR_CON),
+	REGNAME(scpsys, 0x37C, EDP_TX_PWR_CON),
+	REGNAME(scpsys, 0x380, HDMI_TX_PWR_CON),
+	REGNAME(scpsys, 0x384, HDMI_RX_PWR_CON),
+	REGNAME(scpsys, 0x388, VDE0_PWR_CON),
+	REGNAME(scpsys, 0x38C, VDE1_PWR_CON),
+	REGNAME(scpsys, 0x390, VDE2_PWR_CON),
+	REGNAME(scpsys, 0x394, VEN_PWR_CON),
+	REGNAME(scpsys, 0x398, VEN_CORE1_PWR_CON),
+	REGNAME(scpsys, 0x39C, CAM_PWR_CON),
+	REGNAME(scpsys, 0x3A0, CAM_RAWA_PWR_CON),
+	REGNAME(scpsys, 0x3A4, CAM_RAWB_PWR_CON),
+	REGNAME(scpsys, 0x3A8, CAM_RAWC_PWR_CON),
+	REGNAME(scpsys, 0x3AC, IMG_M_PWR_CON),
+	REGNAME(scpsys, 0x3B0, IMG_D_PWR_CON),
+	REGNAME(scpsys, 0x3B4, IPE_PWR_CON),
+	REGNAME(scpsys, 0x3B8, NNA0_PWR_CON),
+	REGNAME(scpsys, 0x3BC, NNA1_PWR_CON),
+	REGNAME(scpsys, 0x3C0, IPNNA_PWR_CON),
+	REGNAME(scpsys, 0x3C4, CSI_RX_TOP_PWR_CON),
+	REGNAME(topckgen, 0x238, TOPCKGEN_CLK_MISC_CFG_1),
+	REGNAME(topckgen, 0x250, TOPCKGEN_CLK_MISC_CFG_3),
+	REGNAME(infracfg_ao, 0x90, INFRACFG_AO_MODULE_SW_CG_0),
+	REGNAME(infracfg_ao, 0x94, INFRACFG_AO_MODULE_SW_CG_1),
+	REGNAME(infracfg_ao, 0xac, INFRACFG_AO_MODULE_SW_CG_2),
+	REGNAME(infracfg_ao, 0xc8, INFRACFG_AO_MODULE_SW_CG_3),
+	REGNAME(infracfg_ao, 0xe8, INFRACFG_AO_MODULE_SW_CG_4),
+	REGNAME(apmixedsys, 0x8, APMIXEDSYS_AP_PLL_CON2),
+	REGNAME(scp_adsp, 0x180, SCP_PAR_TOP_AUDIODSP_CK_CG),
+	REGNAME(pericfg_ao, 0x18, PERICFG_AO_PERI_MODULE_SW_CG_0),
+	REGNAME(imp_iic_wrap_s, 0xe00, IMP_IIC_WRAP_SOUTH_AP_CLOCK_CG_SOUTH),
+	REGNAME(imp_iic_wrap_w, 0xe00, IMP_IIC_WRAP_WEST_AP_CLOCK_CG_WEST),
+	REGNAME(mfgcfg, 0x0, MFGCFG_MFG_CG),
+	REGNAME(vppsys0, 0x20, VPP0_REG_VPPSYS0_CG0),
+	REGNAME(vppsys0, 0x2c, VPP0_REG_VPPSYS0_CG1),
+	REGNAME(vppsys0, 0x38, VPP0_REG_VPPSYS0_CG2),
+	REGNAME(wpesys, 0x0, WPESYS_TOP_REG_WPESYS_RG_000),
+	REGNAME(wpesys_vpp0, 0x58, WPE_VPP0_CTL_WPE_DCM_DIS),
+	REGNAME(wpesys_vpp0, 0x5c, WPE_VPP0_CTL_DMA_DCM_DIS),
+	REGNAME(wpesys_vpp1, 0x58, WPE_VPP1_CTL_WPE_DCM_DIS),
+	REGNAME(wpesys_vpp1, 0x5c, WPE_VPP1_CTL_DMA_DCM_DIS),
+	REGNAME(vppsys1, 0x100, VPPSYS1_CONFIG_VPPSYS1_CG_0),
+	REGNAME(vppsys1, 0x110, VPPSYS1_CONFIG_VPPSYS1_CG_1),
+	REGNAME(imgsys, 0x0, IMGSYS_MAIN_IMG_MAIN_CG),
+	REGNAME(imgsys1_dip_top, 0x0, IMGSYS1_DIP_TOP_MACRO_CG),
+	REGNAME(imgsys1_dip_nr, 0x0, IMGSYS1_DIP_NR_MACRO_CG),
+	REGNAME(imgsys1_wpe, 0x0, IMGSYS1_WPE_MACRO_CG),
+	REGNAME(ipesys, 0x0, IPESYS_MACRO_CG),
+	REGNAME(camsys, 0x0, CAMSYS_MAIN_CAMSYS_CG),
+	REGNAME(camsys_rawa, 0x0, CAMSYS_RAWA_CAMSYS_CG),
+	REGNAME(camsys_yuva, 0x0, CAMSYS_YUVA_CAMSYS_CG),
+	REGNAME(camsys_rawb, 0x0, CAMSYS_RAWB_CAMSYS_CG),
+	REGNAME(camsys_yuvb, 0x0, CAMSYS_YUVB_CAMSYS_CG),
+	REGNAME(camsys_mraw, 0x0, CAMSYS_MRAW_CAMSYS_CG),
+	REGNAME(ccusys, 0x0, CCU_MAIN_CCUSYS_CG),
+	REGNAME(vdecsys_soc, 0x0, VDEC_SOC_GCON_VDEC_CKEN),
+	REGNAME(vdecsys_soc, 0x200, VDEC_SOC_GCON_LAT_CKEN),
+	REGNAME(vdecsys_soc, 0x8, VDEC_SOC_GCON_LARB_CKEN_CON),
+	REGNAME(vdecsys, 0x0, VDEC_GCON_VDEC_CKEN),
+	REGNAME(vdecsys, 0x200, VDEC_GCON_LAT_CKEN),
+	REGNAME(vdecsys, 0x8, VDEC_GCON_LARB_CKEN_CON),
+	REGNAME(vdecsys_core1, 0x0, VDEC_CORE1_GCON_VDEC_CKEN),
+	REGNAME(vdecsys_core1, 0x200, VDEC_CORE1_GCON_LAT_CKEN),
+	REGNAME(vdecsys_core1, 0x8, VDEC_CORE1_GCON_LARB_CKEN_CON),
+	REGNAME(vencsys, 0x0, VENC_GCON_VENCSYS_CG),
+	REGNAME(vencsys_core1, 0x0, VENC_CORE1_GCON_VENCSYS_CG),
+	REGNAME(vdosys0, 0x100, VDOSYS0_CONFIG_GLOBAL0_CG_0),
+	REGNAME(vdosys0, 0x110, VDOSYS0_CONFIG_GLOBAL0_CG_1),
+	REGNAME(vdosys0, 0x120, VDOSYS0_CONFIG_GLOBAL0_CG_2),
+	REGNAME(vdosys1, 0x100, VDOSYS1_CONFIG_VDOSYS1_CG_0),
+	REGNAME(vdosys1, 0x120, VDOSYS1_CONFIG_VDOSYS1_CG_1),
+	REGNAME(vdosys1, 0x130, VDOSYS1_CONFIG_VDOSYS1_CG_2),
+	REGNAME(vdosys1, 0x140, VDOSYS1_CONFIG_VDOSYS1_CG_3),
+	{}
+};
+
+static const struct regname *get_all_regnames(void)
+{
+	return rn;
+}
+
+static void __init init_regbase(void)
+{
+	size_t i;
+
+	for (i = 0; i < ARRAY_SIZE(rb); i++)
+		rb[i].virt = ioremap(rb[i].phys, PAGE_SIZE);
+}
+
+/*
+ * clkdbg fmeter
+ */
+
+#include <linux/delay.h>
+
+#define clk_readl(addr)		readl(addr)
+#define clk_writel(addr, val)	\
+	do { writel(val, addr); wmb(); } while (0) /* sync write */
+
+#define FMCLK(_t, _i, _n) { .type = _t, .id = _i, .name = _n }
+
+static const struct fmeter_clk fclks[] = {
+	FMCLK(ABIST, 1, "AD_ADSPPLL_CK"),
+	FMCLK(ABIST, 2, "AD_APLL1_CK"),
+	FMCLK(ABIST, 3, "AD_APLL2_CK"),
+	FMCLK(ABIST, 4, "AD_APLL3_CK"),
+	FMCLK(ABIST, 5, "AD_APLL4_CK"),
+	FMCLK(ABIST, 6, "AD_APLL5_CK"),
+	FMCLK(ABIST, 7, "AD_DGIPLL_CK"),
+	FMCLK(ABIST, 8, "pad_in_dgi_clk_i"),
+	FMCLK(ABIST, 9, "AD_HDMIPLL1_CK"),
+	FMCLK(ABIST, 10, "AD_HDMIPLL2_CK"),
+	FMCLK(ABIST, 11, "AD_HDMIRX_APLL_CK"),
+	FMCLK(ABIST, 12, "AD_ETHPLL_CK"),
+	FMCLK(ABIST, 13, "AD_IMGPLL_CK"),
+	FMCLK(ABIST, 14, "AD_MAINPLL_CK"),
+	FMCLK(ABIST, 15, "AD_MAINPLL_DIV2_CK"),
+	FMCLK(ABIST, 16, "AD_MAINPLL_DIV3_CK"),
+	FMCLK(ABIST, 17, "AD_MAINPLL_DIV4_CK"),
+	FMCLK(ABIST, 18, "AD_MAINPLL_DIV5_CK"),
+	FMCLK(ABIST, 19, "AD_MAINPLL_DIV6_CK"),
+	FMCLK(ABIST, 20, "AD_MAINPLL_DIV7_CK"),
+	FMCLK(ABIST, 21, "AD_MAINPLL_DIV9_CK"),
+	FMCLK(ABIST, 22, "AD_CLKSQ_FS26M_CK"),
+	FMCLK(ABIST, 23, "AD_MMPLL_CK"),
+	FMCLK(ABIST, 24, "AD_MMPLL_D3_CK"),
+	FMCLK(ABIST, 25, "AD_MMPLL_D4_CK"),
+	FMCLK(ABIST, 26, "AD_MMPLL_D5_CK"),
+	FMCLK(ABIST, 27, "AD_MMPLL_D6_CK"),
+	FMCLK(ABIST, 28, "AD_MMPLL_D7_CK"),
+	FMCLK(ABIST, 29, "AD_MMPLL_D9_CK"),
+	FMCLK(ABIST, 30, "AD_MPLL_CK"),
+	FMCLK(ABIST, 31, "AD_MSDCPLL_CK"),
+	FMCLK(ABIST, 32, "AD_MFGPLL_CK"),
+	FMCLK(ABIST, 33, "AD_MFGPLL_OPP_CK"),
+	FMCLK(ABIST, 34, "AD_TVDPLL1_CK"),
+	FMCLK(ABIST, 35, "AD_TVDPLL2_CK"),
+	FMCLK(ABIST, 36, "AD_CLKSQ_CKBUF1_26M"),
+	FMCLK(ABIST, 37, "AD_CLKSQ_CKBUF2_26M"),
+	FMCLK(ABIST, 38, "AD_UNIVPLL_CK"),
+	FMCLK(ABIST, 39, "AD_UNIVPLL_DIV2_CK"),
+	FMCLK(ABIST, 40, "AD_UNIVPLL_DIV3_CK"),
+	FMCLK(ABIST, 41, "AD_UNIVPLL_DIV4_CK"),
+	FMCLK(ABIST, 42, "AD_UNIVPLL_DIV5_CK"),
+	FMCLK(ABIST, 43, "AD_UNIVPLL_DIV6_CK"),
+	FMCLK(ABIST, 44, "AD_UNIVPLL_DIV7_CK"),
+	FMCLK(ABIST, 45, "AD_USB20_192M_CK"),
+	FMCLK(ABIST, 46, "AD_USB1PLL_CK"),
+	FMCLK(ABIST, 47, "AD_VDECPLL_CK"),
+	FMCLK(ABIST, 48, "AD_ULPOSC_CK"),
+	FMCLK(ABIST, 49, "AD_OSC_SYNC_CK"),
+	FMCLK(ABIST, 50, "AD_ULPOSC2_CK"),
+	FMCLK(ABIST, 51, "AD_OSC_SYNC_CK_2"),
+	FMCLK(ABIST, 52, "AD_ARMPLL_LL_CK"),
+	FMCLK(ABIST, 53, "AD_ARMPLL_BL_CK"),
+	FMCLK(ABIST, 54, "AD_CCIPLL_CK"),
+	FMCLK(ABIST, 55, "AD_NNAPLL_CK"),
+	FMCLK(ABIST, 56, "AD_RESPLL_CK"),
+	FMCLK(ABIST, 57, "AD_APPLLGP1_MON_FM_CK"),
+	FMCLK(ABIST, 58, "dsi0_ad_dsi_ckg_dsiclk_anaout"),
+	FMCLK(ABIST, 59, "dsi0_ad_dsi_test_ck_anaout"),
+	FMCLK(ABIST, 60, "dsi1_ad_dsi_ckg_dsiclk_anaout"),
+	FMCLK(ABIST, 61, "dsi1_ad_dsi_test_ck_anaout"),
+	FMCLK(ABIST, 62, "_FIXED_0"),
+	FMCLK(ABIST, 63, "AD_NNAPLL_CKDIV_CK"),
+	FMCLK(ABIST, 64, "ADA_LVTS_TO_PLLGP_MON_CK_L1"),
+	FMCLK(ABIST, 65, "ADA_LVTS_TO_PLLGP_MON_CK_L2"),
+	FMCLK(ABIST, 66, "ADA_LVTS_TO_PLLGP_MON_CK_L3"),
+	FMCLK(ABIST, 67, "ADA_LVTS_TO_PLLGP_MON_CK_L4"),
+	FMCLK(ABIST, 68, "ADA_LVTS_TO_PLLGP_MON_CK_L5"),
+	FMCLK(ABIST, 69, "ADA_LVTS_TO_PLLGP_MON_CK_L6"),
+	FMCLK(ABIST, 70, "ADA_LVTS_TO_PLLGP_MON_CK_L7"),
+	FMCLK(ABIST, 71, "AD_CSI0A_CDPHY_DELAYCAL_CK"),
+	FMCLK(ABIST, 72, "AD_CSI0B_CDPHY_DELAYCAL_CK"),
+	FMCLK(ABIST, 73, "AD_CSI0C_CDPHY_DELAYCAL_CK"),
+	FMCLK(ABIST, 74, "AD_CSI0D_CDPHY_DELAYCAL_CK"),
+	FMCLK(ABIST, 75, "AD_CSI2A_CDPHY_DELAYCAL_CK"),
+	FMCLK(ABIST, 76, "AD_CSI2B_CDPHY_DELAYCAL_CK"),
+	FMCLK(ABIST, 77, "eARC_bck_int"),
+	FMCLK(ABIST, 78, "mclk_128fs_o"),
+	FMCLK(ABIST, 79, "spdifin_iec_ck"),
+	FMCLK(ABIST, 80, "other_splin_bck_i"),
+	FMCLK(ABIST, 81, "other_splin_mck_i"),
+	FMCLK(ABIST, 82, "u2a_rx_sof_p0"),
+	FMCLK(ABIST, 83, "u2a_rx_sof_p2"),
+	FMCLK(ABIST, 84, "u2a_rx_sof_p3"),
+	FMCLK(ABIST, 85, "u2a_tx_sof_p0"),
+	FMCLK(ABIST, 86, "u2a_tx_sof_p1"),
+	FMCLK(ABIST, 87, "u2a_tx_sof_p2"),
+	FMCLK(ABIST, 88, "u2a_tx_sof_p3"),
+	FMCLK(ABIST, 89, "aud_i2sin_mck_i"),
+	FMCLK(ABIST, 90, "aud_i2sin_bck_i"),
+	FMCLK(ABIST, 91, "other_tdmin_mck_i"),
+	FMCLK(ABIST, 92, "aud_i2so2_bck_i"),
+	FMCLK(ABIST, 93, "aud_i2si4_bck_i"),
+	FMCLK(ABIST, 94, "aud_i2si5_bck_i"),
+	FMCLK(ABIST, 95, "AD_HDMITX21PLL_MONREF_CK"),
+	FMCLK(ABIST, 96, "AD_HDMITX21PLL_MONFBK_CK"),
+	FMCLK(ABIST, 97, "AD_HDMITX21_CLKDIG_1"),
+	FMCLK(ABIST, 98, "AD_HDMITX21_CLKDIG_1_CTS"),
+	FMCLK(ABIST, 99, "AD_HDMITXPLL_PIXEL_CK"),
+	FMCLK(ABIST, 100, "AD_EARCRX_DM_CK"),
+	FMCLK(ABIST, 101, "AD_EARCRX_CM_SLEW_CK"),
+	FMCLK(ABIST, 102, "AD_EARCRXPLL_CK_DIG"),
+	FMCLK(ABIST, 103, "msdc01_in_ck"),
+	FMCLK(ABIST, 104, "msdc02_in_ck"),
+	FMCLK(ABIST, 105, "msdc11_in_ck"),
+	FMCLK(ABIST, 106, "msdc12_in_ck"),
+	FMCLK(ABIST, 107, "msdc21_in_ck"),
+	FMCLK(ABIST, 108, "msdc22_in_ck"),
+	FMCLK(ABIST, 109, "msdc31_in_ck"),
+	FMCLK(ABIST, 110, "msdc32_in_ck"),
+	FMCLK(ABIST, 111, "UFS_MP_CLK2FREQ"),
+	FMCLK(ABIST, 112, "mcusys_arm_clk_out_all"),
+	FMCLK(ABIST, 113, "fmem_ck_aft_dcm_ch2"),
+	FMCLK(ABIST, 114, "fmem_ck_bfe_dcm_ch2"),
+	FMCLK(ABIST, 115, "AD_RPHYPLL_DIV4_CK_ch23"),
+	FMCLK(ABIST, 116, "AD_RCLRPLL_DIV4_CK_ch23"),
+	FMCLK(ABIST, 117, "fmem_ck_aft_dcm_ch0"),
+	FMCLK(ABIST, 118, "fmem_ck_bfe_dcm_ch0"),
+	FMCLK(ABIST, 119, "AD_RCLRPLL_DIV4_CK_ch01"),
+	FMCLK(ABIST, 120, "AD_RPHYPLL_DIV4_CK_ch01"),
+	FMCLK(ABIST, 121, "_FIXED_0"),
+	FMCLK(ABIST, 122, "_FIXED_0"),
+	FMCLK(ABIST, 123, "_FIXED_0"),
+	FMCLK(ABIST, 124, "_FIXED_0"),
+	FMCLK(ABIST, 125, "_FIXED_0"),
+	FMCLK(ABIST, 126, "_FIXED_0"),
+	FMCLK(ABIST, 127, "o_rx_acr_aud_clk_x"),
+	FMCLK(CKGEN, 0, "hd_faxi_ck"),
+	FMCLK(CKGEN, 1, "hg_fspm_ck"),
+	FMCLK(CKGEN, 2, "hf_fscp_ck"),
+	FMCLK(CKGEN, 3, "hd_fbus_aximem_ck"),
+	FMCLK(CKGEN, 4, "hf_fvpp_ck"),
+	FMCLK(CKGEN, 5, "hf_fethdr_ck"),
+	FMCLK(CKGEN, 6, "hf_fipe_ck"),
+	FMCLK(CKGEN, 7, "hf_fcam_ck"),
+	FMCLK(CKGEN, 8, "hf_fccu_ck"),
+	FMCLK(CKGEN, 9, "hf_fimg_ck"),
+	FMCLK(CKGEN, 10, "hf_fcamtm_ck"),
+	FMCLK(CKGEN, 11, "hf_fdsp_ck"),
+	FMCLK(CKGEN, 12, "hf_fdsp1_ck"),
+	FMCLK(CKGEN, 13, "hf_fdsp2_ck"),
+	FMCLK(CKGEN, 14, "hf_fdsp3_ck"),
+	FMCLK(CKGEN, 15, "hf_fdsp4_ck"),
+	FMCLK(CKGEN, 16, "hf_fdsp5_ck"),
+	FMCLK(CKGEN, 17, "hf_fdsp6_ck"),
+	FMCLK(CKGEN, 18, "hf_fdsp7_ck"),
+	FMCLK(CKGEN, 19, "hf_fipu_if_ck"),
+	FMCLK(CKGEN, 20, "hf_fmfg_core_tmp_ck"),
+	FMCLK(CKGEN, 21, "f_fcamtg_ck"),
+	FMCLK(CKGEN, 22, "f_fcamtg2_ck"),
+	FMCLK(CKGEN, 23, "f_fcamtg3_ck"),
+	FMCLK(CKGEN, 24, "f_fcamtg4_ck"),
+	FMCLK(CKGEN, 25, "f_fcamtg5_ck"),
+	FMCLK(CKGEN, 26, "f_fuart_ck"),
+	FMCLK(CKGEN, 27, "hf_fspi_ck"),
+	FMCLK(CKGEN, 28, "hf_fspis_ck"),
+	FMCLK(CKGEN, 29, "hf_fmsdc50_0_hclk_ck"),
+	FMCLK(CKGEN, 30, "hf_fmsdc50_0_ck"),
+	FMCLK(CKGEN, 31, "hf_fmsdc30_1_ck"),
+	FMCLK(CKGEN, 32, "hf_fmsdc30_2_ck"),
+	FMCLK(CKGEN, 33, "hf_fintdir_ck"),
+	FMCLK(CKGEN, 34, "hf_faud_intbus_ck"),
+	FMCLK(CKGEN, 35, "hf_faudio_h_ck"),
+	FMCLK(CKGEN, 36, "f_fpwrap_ulposc_ck"),
+	FMCLK(CKGEN, 37, "hf_fatb_ck"),
+	FMCLK(CKGEN, 38, "hf_fpwrmcu_ck"),
+	FMCLK(CKGEN, 39, "hf_fdp_ck"),
+	FMCLK(CKGEN, 40, "hf_fedp_ck"),
+	FMCLK(CKGEN, 41, "hf_fdpi_ck"),
+	FMCLK(CKGEN, 42, "f_fdisp_pwm0_ck"),
+	FMCLK(CKGEN, 43, "f_fdisp_pwm1_ck"),
+	FMCLK(CKGEN, 44, "f_fusb_top_ck"),
+	FMCLK(CKGEN, 45, "f_fssusb_xhci_ck"),
+	FMCLK(CKGEN, 46, "f_fusb_top_1p_ck"),
+	FMCLK(CKGEN, 47, "f_fssusb_xhci_1p_ck"),
+	FMCLK(CKGEN, 48, "f_fusb_top_2p_ck"),
+	FMCLK(CKGEN, 49, "f_fssusb_xhci_2p_ck"),
+	FMCLK(CKGEN, 50, "f_fusb_top_3p_ck"),
+	FMCLK(CKGEN, 51, "f_fssusb_xhci_3p_ck"),
+	FMCLK(CKGEN, 52, "f_fi2c_ck"),
+	FMCLK(CKGEN, 53, "f_fseninf_ck"),
+	FMCLK(CKGEN, 54, "f_fseninf1_ck"),
+	FMCLK(CKGEN, 55, "f_fseninf2_ck"),
+	FMCLK(CKGEN, 56, "f_fseninf3_ck"),
+	FMCLK(CKGEN, 57, "hf_gcpu_ck"),
+	FMCLK(CKGEN, 58, "hf_fdxcc_ck"),
+	FMCLK(CKGEN, 59, "hf_fdpmaif_main_ck"),
+	FMCLK(CKGEN, 60, "hf_faes_ufsfde_ck"),
+	FMCLK(CKGEN, 61, "hf_fufs_ck"),
+	FMCLK(CKGEN, 62, "f_ufs_tick1us_ck"),
+	FMCLK(CKGEN, 63, "f_ufs_mp_sap_cfg_ck"),
+	FMCLK(CKGEN, 64, "hf_fvenc_ck"),
+	FMCLK(CKGEN, 65, "hf_fvdec_ck"),
+	FMCLK(CKGEN, 66, "hf_fpwm_ck"),
+	FMCLK(CKGEN, 67, "hg_mcupm_ck"),
+	FMCLK(CKGEN, 68, "hf_fspmi_p_mst_ck"),
+	FMCLK(CKGEN, 69, "hf_fspmi_m_mst_ck"),
+	FMCLK(CKGEN, 70, "hg_fdvfsrc_ck"),
+	FMCLK(CKGEN, 71, "hf_ftl_ck"),
+	FMCLK(CKGEN, 72, "hf_ftl_p1_ck"),
+	FMCLK(CKGEN, 73, "hf_faes_msdcfde_ck"),
+	FMCLK(CKGEN, 74, "hf_dsi_occ_ck"),
+	FMCLK(CKGEN, 75, "hf_fwpe_vpp_ck"),
+	FMCLK(CKGEN, 76, "hf_fhdcp_ck"),
+	FMCLK(CKGEN, 77, "hf_fhdcp_24m_ck"),
+	FMCLK(CKGEN, 78, "hf_fhd20_dacr_ref_clk"),
+	FMCLK(CKGEN, 79, "hf_fhd20_hdcp_cclk"),
+	FMCLK(CKGEN, 80, "hf_fhdmi_xtal"),
+	FMCLK(CKGEN, 81, "hf_fhdmi_apb_ck"),
+	FMCLK(CKGEN, 82, "hf_fsnps_eth_250m_ck"),
+	FMCLK(CKGEN, 83, "hf_fsnps_eth_62p4m_ptp_ck"),
+	FMCLK(CKGEN, 84, "hf_fsnps_eth_50m_rmii_ck"),
+	FMCLK(CKGEN, 85, "hf_dgi_out_ck"),
+	FMCLK(CKGEN, 86, "hf_ipnna_nna0_ck"),
+	FMCLK(CKGEN, 87, "hf_ipnna_nna1_ck"),
+	FMCLK(CKGEN, 88, "hf_fadsp_ck"),
+	FMCLK(CKGEN, 89, "hf_fasm_h_ck"),
+	FMCLK(CKGEN, 90, "hf_fasm_m_ck"),
+	FMCLK(CKGEN, 91, "hf_fasm_l_ck"),
+	FMCLK(CKGEN, 92, "hf_fapll1_ck"),
+	FMCLK(CKGEN, 93, "hf_fapll2_ck"),
+	FMCLK(CKGEN, 94, "hf_fapll3_ck"),
+	FMCLK(CKGEN, 95, "hf_fapll4_ck"),
+	FMCLK(CKGEN, 96, "hf_fapll5_ck"),
+	FMCLK(CKGEN, 97, "hf_fi2so1_mck"),
+	FMCLK(CKGEN, 98, "hf_fi2so2_mck"),
+	FMCLK(CKGEN, 99, "hf_fi2so4_mck"),
+	FMCLK(CKGEN, 100, "hf_fi2so5_mck"),
+	FMCLK(CKGEN, 101, "hf_fi2si1_mck"),
+	FMCLK(CKGEN, 102, "hf_fi2si2_mck"),
+	FMCLK(CKGEN, 103, "hf_fi2si4_mck"),
+	FMCLK(CKGEN, 104, "hf_fi2si5_mck"),
+	FMCLK(CKGEN, 105, "hf_fdptx_mck"),
+	FMCLK(CKGEN, 106, "hf_aud_iec_clk"),
+	FMCLK(CKGEN, 107, "hf_a1sys_hp_ck"),
+	FMCLK(CKGEN, 108, "hf_a2sys_hf_ck"),
+	FMCLK(CKGEN, 109, "hf_a3sys_hf_ck"),
+	FMCLK(CKGEN, 110, "hf_a4sys_hf_ck"),
+	FMCLK(CKGEN, 111, "hf_fspinfi_bclk_ck"),
+	FMCLK(CKGEN, 112, "hf_fnfi1x_ck"),
+	FMCLK(CKGEN, 113, "hf_ecc_ck"),
+	FMCLK(CKGEN, 114, "hf_faudio_local_bus_ck"),
+	FMCLK(CKGEN, 115, "hf_fspinor_ck"),
+	FMCLK(CKGEN, 116, "f_dvio_dgi_ref_ck"),
+	FMCLK(CKGEN, 117, "f_ulposc_ck"),
+	FMCLK(CKGEN, 118, "f_ulposc_core_ck"),
+	FMCLK(CKGEN, 119, "hf_fsrck_ck"),
+	FMCLK(CKGEN, 120, "src_occ_50m_clk"),
+	FMCLK(CKGEN, 121, "src_occ_78m_clk"),
+	FMCLK(CKGEN, 122, "src_occ_125m_clk"),
+	FMCLK(CKGEN, 123, "src_occ_250m_clk"),
+	FMCLK(CKGEN, 124, "src_occ_500m_clk"),
+	FMCLK(CKGEN, 125, "src_occ_240m_clk"),
+	FMCLK(CKGEN, 126, "src_occ_810m_clk"),
+	FMCLK(CKGEN, 127, "src_occ_202m_clk"),
+	FMCLK(CKGEN, 128, "src_occ_600m_clk"),
+	FMCLK(CKGEN, 129, "src_occ_100m_clk"),
+	FMCLK(CKGEN, 130, "src_occ_150m_clk"),
+	FMCLK(CKGEN, 131, "src_occ_600m_1_clk"),
+	FMCLK(CKGEN, 132, "src_occ_208m_clk"),
+	FMCLK(CKGEN, 133, "src_occ_202m_1_clk"),
+	FMCLK(CKGEN, 134, "src_occ_148m_clk"),
+	FMCLK(CKGEN, 135, "src_occ_156m_clk"),
+	FMCLK(CKGEN, 136, "src_occ_312m_clk"),
+	FMCLK(CKGEN, 137, "src_occ_594m_clk"),
+	FMCLK(CKGEN, 138, "src_occ_313m_clk"),
+	FMCLK(CKGEN, 139, "src_occ_108m_clk"),
+	FMCLK(CKGEN, 140, "src_occ_300m_clk"),
+	FMCLK(CKGEN, 141, "src_occ_375m_clk"),
+	FMCLK(CKGEN, 142, "src_occ_333m_clk"),
+	FMCLK(CKGEN, 143, "src_occ_600m_2_clk"),
+	FMCLK(CKGEN, 144, "src_occ_660m_clk"),
+	FMCLK(CKGEN, 145, "src_occ_750m_clk"),
+	FMCLK(CKGEN, 146, "src_occ_864m_clk"),
+	FMCLK(CKGEN, 147, "src_occ_gcpu_div2_ck"),
+	FMCLK(CKGEN, 148, "f_rsvd1_ck"),
+	FMCLK(CKGEN, 149, "f_rsvd2_ck"),
+	FMCLK(CKGEN, 150, "f_rsvd3_ck"),
+	{}
+};
+
+#define CLK_MISC_CFG_0	(rb[topckgen].virt + 0x22C)
+#define CLK_DBG_CFG		(rb[topckgen].virt + 0x20C)
+#define CLK26CALI_0		(rb[topckgen].virt + 0x218)
+#define CLK26CALI_1		(rb[topckgen].virt + 0x21C)
+
+static unsigned int mt_get_ckgen_freq(unsigned int ID)
+{
+	int output = 0, i = 0;
+	unsigned int temp, clk26cali_0, clk_dbg_cfg, clk_misc_cfg_0, clk26cali_1;
+	bool timeout = false;
+
+	clk_dbg_cfg = clk_readl(CLK_DBG_CFG);
+	clk_writel(CLK_DBG_CFG, (clk_dbg_cfg & 0xFE00FFFC) | (ID << 16) | 0x1 | (0x1 << 24));
+
+	clk_misc_cfg_0 = clk_readl(CLK_MISC_CFG_0);
+	clk_writel(CLK_MISC_CFG_0, (clk_misc_cfg_0 & 0x00FFFFFF)); /* divider = 0*/
+	clk26cali_0 = clk_readl(CLK26CALI_0);
+	clk26cali_1 = clk_readl(CLK26CALI_1);
+	clk_writel(CLK26CALI_0, 0x80);
+	clk_writel(CLK26CALI_0, 0x90);
+
+	/* wait frequency meter finish */
+	while (clk_readl(CLK26CALI_0) & 0x10) {
+		udelay(10);
+		i++;
+		if (i > 10000) {
+			timeout = true;
+			pr_info("ckgen meter[%d], timeout\n", ID);
+			break;
+		}
+	}
+
+	if (!timeout) {
+		temp = clk_readl(CLK26CALI_1) & 0xFFFF;
+		output = (temp * 26000) / 1024; /* KHz */
+	} else {
+		output = 0;
+	}
+
+	clk_writel(CLK_DBG_CFG, clk_dbg_cfg);
+	clk_writel(CLK_MISC_CFG_0, clk_misc_cfg_0);
+	clk_writel(CLK26CALI_0, clk26cali_0);
+	clk_writel(CLK26CALI_1, clk26cali_1);
+
+	/* pr_info("ckgen meter[%d] = %d KHz\n", ID, output); */
+	return output;
+}
+
+static unsigned int mt_get_abist_freq(unsigned int ID)
+{
+	int output = 0, i = 0;
+	unsigned int temp, clk26cali_0, clk_dbg_cfg, clk_misc_cfg_0, clk26cali_1;
+	bool timeout = false;
+
+	clk_dbg_cfg = clk_readl(CLK_DBG_CFG);
+	clk_writel(CLK_DBG_CFG, (clk_dbg_cfg & 0xFEFF80FC) | (ID << 8));
+	clk_misc_cfg_0 = clk_readl(CLK_MISC_CFG_0);
+	clk_writel(CLK_MISC_CFG_0, (clk_misc_cfg_0 & 0x00FFFFFF) | (3 << 24)); /* divider = 4 */
+	clk26cali_0 = clk_readl(CLK26CALI_0);
+	clk26cali_1 = clk_readl(CLK26CALI_1);
+	clk_writel(CLK26CALI_0, 0x80);
+	clk_writel(CLK26CALI_0, 0x90);
+
+	/* wait frequency meter finish */
+	while (clk_readl(CLK26CALI_0) & 0x10) {
+		udelay(10);
+		i++;
+		if (i > 10000) {
+			timeout = true;
+			pr_info("abist meter[%d], timeout\n", ID);
+			break;
+		}
+	}
+
+	if (!timeout) {
+		temp = clk_readl(CLK26CALI_1) & 0xFFFF;
+		output = (temp * 26000) / 1024; /* KHz */
+	} else {
+		output = 0;
+	}
+
+	clk_writel(CLK_DBG_CFG, clk_dbg_cfg);
+	clk_writel(CLK_MISC_CFG_0, clk_misc_cfg_0);
+	clk_writel(CLK26CALI_0, clk26cali_0);
+	clk_writel(CLK26CALI_1, clk26cali_1);
+
+	/* pr_info("abist meter[%d] = %d KHz\n", ID, output * 4); */
+	return output * 4;
+}
+
+static u32 fmeter_freq_op(const struct fmeter_clk *fclk)
+{
+	if (fclk->type == ABIST)
+		return mt_get_abist_freq(fclk->id);
+	else if (fclk->type == CKGEN)
+		return mt_get_ckgen_freq(fclk->id);
+	return 0;
+}
+
+static const struct fmeter_clk *get_all_fmeter_clks(void)
+{
+	return fclks;
+}
+
+/*
+ * clkdbg dump_state
+ */
+
+static const char * const *get_all_clk_names(void)
+{
+	static const char * const clks[] = {
+		"clk26m",
+		"clk32k",
+		"nnapll",
+		"respll",
+		"ethpll",
+		"msdcpll",
+		"tvdpll1",
+		"tvdpll2",
+		"mmpll",
+		"mainpll",
+		"vdecpll",
+		"imgpll",
+		"univpll",
+		"hdmipll1",
+		"hdmipll2",
+		"hdmirx_apll",
+		"usb1pll",
+		"adsppll",
+		"apll1",
+		"apll2",
+		"apll3",
+		"apll4",
+		"apll5",
+		"mfgpll",
+		"dgipll",
+		"apusys_pll_apupll",
+		"apusys_pll_npupll",
+		"apusys_pll_apupll1",
+		"apusys_pll_apupll2",
+		"pll_ssusb26m",
+		"in_dgi",
+		"ulposc1",
+		"ulposc2",
+		"mem_466m",
+		"mphone_slave_b",
+		"pextp_pipe",
+		"ufs_rx_symbol",
+		"ufs_tx_symbol",
+		"ssusb_u3phy_p1_p_p0",
+		"ufs_rx_symbol1",
+		"fpc",
+		"hdmirx_p",
+		"clk26m_d2",
+		"clk26m_d52",
+		"in_dgi_d2",
+		"in_dgi_d4",
+		"in_dgi_d6",
+		"in_dgi_d8",
+		"mainpll_d3",
+		"mainpll_d4",
+		"mainpll_d4_d2",
+		"mainpll_d4_d4",
+		"mainpll_d4_d8",
+		"mainpll_d5",
+		"mainpll_d5_d2",
+		"mainpll_d5_d4",
+		"mainpll_d5_d8",
+		"mainpll_d6",
+		"mainpll_d6_d2",
+		"mainpll_d6_d4",
+		"mainpll_d6_d8",
+		"mainpll_d7",
+		"mainpll_d7_d2",
+		"mainpll_d7_d4",
+		"mainpll_d7_d8",
+		"mainpll_d9",
+		"univpll_d2",
+		"univpll_d3",
+		"univpll_d4",
+		"univpll_d4_d2",
+		"univpll_d4_d4",
+		"univpll_d4_d8",
+		"univpll_d5",
+		"univpll_d5_d2",
+		"univpll_d5_d4",
+		"univpll_d5_d8",
+		"univpll_d6",
+		"univpll_d6_d2",
+		"univpll_d6_d4",
+		"univpll_d6_d8",
+		"univpll_d6_d16",
+		"univpll_d7",
+		"univpll_192m",
+		"univpll_192m_d4",
+		"univpll_192m_d8",
+		"univpll_192m_d16",
+		"univpll_192m_d32",
+		"apll1_d3",
+		"apll1_d4",
+		"apll2_d3",
+		"apll2_d4",
+		"apll3_d4",
+		"apll4_d4",
+		"apll5_d4",
+		"hdmirx_apll_d3",
+		"hdmirx_apll_d4",
+		"hdmirx_apll_d6",
+		"mmpll_d4",
+		"mmpll_d4_d2",
+		"mmpll_d4_d4",
+		"mmpll_d5",
+		"mmpll_d5_d2",
+		"mmpll_d5_d4",
+		"mmpll_d6",
+		"mmpll_d6_d2",
+		"mmpll_d7",
+		"mmpll_d9",
+		"tvdpll1_d2",
+		"tvdpll1_d4",
+		"tvdpll1_d8",
+		"tvdpll1_d16",
+		"tvdpll2_d2",
+		"tvdpll2_d4",
+		"tvdpll2_d8",
+		"tvdpll2_d16",
+		"msdcpll_d2",
+		"msdcpll_d4",
+		"msdcpll_d16",
+		"ethpll_d2",
+		"ethpll_d8",
+		"ethpll_d10",
+		"dgipll_d2",
+		"ulposc1_d2",
+		"ulposc1_d4",
+		"ulposc1_d7",
+		"ulposc1_d8",
+		"ulposc1_d10",
+		"ulposc1_d16",
+		"adsppll_d2",
+		"adsppll_d4",
+		"adsppll_d8",
+		"top_axi",
+		"top_spm",
+		"top_scp",
+		"top_bus_aximem",
+		"top_vpp",
+		"top_ethdr",
+		"top_ipe",
+		"top_cam",
+		"top_ccu",
+		"top_img",
+		"top_camtm",
+		"top_dsp",
+		"top_dsp1",
+		"top_dsp2",
+		"top_dsp3",
+		"top_dsp4",
+		"top_dsp5",
+		"top_dsp6",
+		"top_dsp7",
+		"top_ipu_if",
+		"top_mfg_core_tmp",
+		"top_camtg",
+		"top_camtg2",
+		"top_camtg3",
+		"top_camtg4",
+		"top_camtg5",
+		"top_uart",
+		"top_spi",
+		"top_spis",
+		"top_msdc50_0_hclk",
+		"top_msdc50_0",
+		"top_msdc30_1",
+		"top_msdc30_2",
+		"top_intdir",
+		"top_aud_intbus",
+		"top_audio_h",
+		"top_pwrap_ulposc",
+		"top_atb",
+		"top_pwrmcu",
+		"top_dp",
+		"top_edp",
+		"top_dpi",
+		"top_disp_pwm0",
+		"top_disp_pwm1",
+		"top_usb_top",
+		"top_ssusb_xhci",
+		"top_usb_top_1p",
+		"top_ssusb_xhci_1p",
+		"top_usb_top_2p",
+		"top_ssusb_xhci_2p",
+		"top_usb_top_3p",
+		"top_ssusb_xhci_3p",
+		"top_i2c",
+		"top_seninf",
+		"top_seninf1",
+		"top_seninf2",
+		"top_seninf3",
+		"top_gcpu",
+		"top_dxcc",
+		"top_dpmaif_main",
+		"top_aes_ufsfde",
+		"top_ufs",
+		"top_ufs_tick1us",
+		"top_ufs_mp_sap_cfg",
+		"top_venc",
+		"top_vdec",
+		"top_pwm",
+		"top_mcupm",
+		"top_spmi_p_mst",
+		"top_spmi_m_mst",
+		"top_dvfsrc",
+		"top_tl",
+		"top_tl_p1",
+		"top_aes_msdcfde",
+		"top_dsi_occ",
+		"top_wpe_vpp",
+		"top_hdcp",
+		"top_hdcp_24m",
+		"top_hd20_dacr_ref_clk",
+		"top_hd20_hdcp_cclk",
+		"top_hdmi_xtal",
+		"top_hdmi_apb",
+		"top_snps_eth_250m",
+		"top_snps_eth_62p4m_ptp",
+		"snps_eth_50m_rmii",
+		"top_dgi_out",
+		"top_nna0",
+		"top_nna1",
+		"top_adsp",
+		"top_asm_h",
+		"top_asm_m",
+		"top_asm_l",
+		"top_apll1",
+		"top_apll2",
+		"top_apll3",
+		"top_apll4",
+		"top_apll5",
+		"top_i2so1_mck",
+		"top_i2so2_mck",
+		"top_i2si1_mck",
+		"top_i2si2_mck",
+		"top_dptx_mck",
+		"top_aud_iec_clk",
+		"top_a1sys_hp",
+		"top_a2sys_hf",
+		"top_a3sys_hf",
+		"top_a4sys_hf",
+		"top_spinfi_bclk",
+		"top_nfi1x",
+		"top_ecc",
+		"top_audio_local_bus",
+		"top_spinor",
+		"top_dvio_dgi_ref",
+		"top_ulposc",
+		"top_ulposc_core",
+		"top_srck",
+		"mfg_ck_fast_ref",
+		"apll12_div0",
+		"apll12_div1",
+		"apll12_div2",
+		"apll12_div3",
+		"apll12_div4",
+		"apll12_div9",
+		"cfg_vpp0",
+		"cfg_vpp1",
+		"cfg_vdo0",
+		"cfg_vdo1",
+		"cfg_unipll_ses",
+		"cfg_26m_vpp0",
+		"cfg_26m_vpp1",
+		"cfg_26m_aud",
+		"cfg_axi_east",
+		"cfg_axi_east_north",
+		"cfg_axi_north",
+		"cfg_axi_south",
+		"cfg_ext_test",
+		"ssusb_ref",
+		"ssusb_phy_ref",
+		"ssusb_p1_ref",
+		"ssusb_phy_p1_ref",
+		"ssusb_p2_ref",
+		"ssusb_phy_p2_ref",
+		"ssusb_p3_ref",
+		"ssusb_phy_p3_ref",
+		"infra_ao_pmic_tmr",
+		"infra_ao_pmic_ap",
+		"infra_ao_pmic_md",
+		"infra_ao_pmic_conn",
+		"infra_ao_sej",
+		"infra_ao_apxgpt",
+		"infra_ao_gce",
+		"infra_ao_gce2",
+		"infra_ao_therm",
+		"infra_ao_pwm_h",
+		"infra_ao_pwm1",
+		"infra_ao_pwm2",
+		"infra_ao_pwm3",
+		"infra_ao_pwm4",
+		"infra_ao_pwm",
+		"infra_ao_uart0",
+		"infra_ao_uart1",
+		"infra_ao_uart2",
+		"infra_ao_uart3",
+		"infra_ao_uart4",
+		"infra_ao_gce_26m",
+		"infra_ao_cq_dma_fpc",
+		"infra_ao_uart5",
+		"infra_ao_hdmi_26m",
+		"infra_ao_spi0",
+		"infra_ao_msdc0",
+		"infra_ao_msdc1",
+		"infra_ao_cg1_msdc2",
+		"infra_ao_msdc0_src",
+		"infra_ao_trng",
+		"infra_ao_auxadc",
+		"infra_ao_cpum",
+		"infra_ao_hdmi_32k",
+		"infra_ao_cec_66m_h",
+		"infra_ao_irrx",
+		"infra_ao_pcie_tl_26m",
+		"infra_ao_msdc1_src",
+		"infra_ao_cec_66m_b",
+		"infra_ao_pcie_tl_96m",
+		"infra_ao_device_apc",
+		"infra_ao_ecc_66m_h",
+		"infra_ao_debugsys",
+		"infra_ao_audio",
+		"infra_ao_pcie_tl_32k",
+		"infra_ao_dbg_trace",
+		"infra_ao_dramc_f26m",
+		"infra_ao_irtx",
+		"infra_ao_ssusb",
+		"infra_ao_disp_pwm",
+		"infra_ao_cldma_b",
+		"infra_ao_audio_26m_b",
+		"infra_ao_spi1",
+		"infra_ao_spi2",
+		"infra_ao_spi3",
+		"infra_ao_unipro_sys",
+		"infra_ao_unipro_tick",
+		"infra_ao_ufs_mp_sap_b",
+		"infra_ao_pwrmcu",
+		"infra_ao_pwrmcu_bus_h",
+		"infra_ao_apdma_b",
+		"infra_ao_spi4",
+		"infra_ao_spi5",
+		"infra_ao_cq_dma",
+		"infra_ao_aes_ufsfde",
+		"infra_ao_aes",
+		"infra_ao_ufs_tick",
+		"infra_ao_ssusb_xhci",
+		"infra_ao_msdc0_self",
+		"infra_ao_msdc1_self",
+		"infra_ao_msdc2_self",
+		"infra_ao_i2s_dma",
+		"infra_ao_ap_msdc0",
+		"infra_ao_md_msdc0",
+		"infra_ao_cg3_msdc2",
+		"infra_ao_gcpu",
+		"infra_ao_pcie_peri_26m",
+		"infra_ao_gcpu_66m_b",
+		"infra_ao_gcpu_133m_b",
+		"infra_ao_disp_pwm1",
+		"infra_ao_fbist2fpc",
+		"infra_ao_device_apc_sync",
+		"infra_ao_pcie_p1_peri_26m",
+		"infra_ao_spis0",
+		"infra_ao_spis1",
+		"infra_ao_133m_m_peri",
+		"infra_ao_66m_m_peri",
+		"infra_ao_pcie_pl_p_250m_p0",
+		"infra_ao_pcie_pl_p_250m_p1",
+		"infra_ao_pcie_p1_tl_96m",
+		"infra_ao_aes_msdcfde_0p",
+		"infra_ao_ufs_tx_symbol",
+		"infra_ao_ufs_rx_symbol",
+		"infra_ao_ufs_rx_symbol1",
+		"infra_ao_peri_ufs_mem_sub",
+		"scp_adsp_audiodsp",
+		"peri_ao_ethernet",
+		"peri_ao_ethernet_bus",
+		"peri_ao_flashif_bus",
+		"peri_ao_flashif_flash",
+		"peri_ao_ssusb_1p_bus",
+		"peri_ao_ssusb_1p_xhci",
+		"peri_ao_ssusb_2p_bus",
+		"peri_ao_ssusb_2p_xhci",
+		"peri_ao_ssusb_3p_bus",
+		"peri_ao_ssusb_3p_xhci",
+		"peri_ao_spinfi",
+		"peri_ao_ethernet_mac",
+		"peri_ao_nfi_h",
+		"peri_ao_fnfi1x",
+		"peri_ao_pcie_p0_mem",
+		"peri_ao_pcie_p1_mem",
+		"imp_iic_wrap_s_i2c5",
+		"imp_iic_wrap_s_i2c6",
+		"imp_iic_wrap_s_i2c7",
+		"imp_iic_wrap_w_i2c0",
+		"imp_iic_wrap_w_i2c1",
+		"imp_iic_wrap_w_i2c2",
+		"imp_iic_wrap_w_i2c3",
+		"imp_iic_wrap_w_i2c4",
+		"mfg_bg3d",
+		"vpp0_mdp_fg",
+		"vpp0_stitch",
+		"vpp0_padding",
+		"vpp0_mdp_tcc",
+		"vpp0_warp0_async_tx",
+		"vpp0_warp1_async_tx",
+		"vpp0_mutex",
+		"vpp0_vpp02vpp1_relay",
+		"vpp0_vpp12vpp0_async",
+		"vpp0_mmsysram_top",
+		"vpp0_mdp_aal",
+		"vpp0_mdp_rsz",
+		"vpp0_smi_common",
+		"vpp0_gals_vdo0_larb0",
+		"vpp0_gals_vdo0_larb1",
+		"vpp0_gals_vencsys",
+		"vpp0_gals_vencsys_core1",
+		"vpp0_gals_infra",
+		"vpp0_gals_camsys",
+		"vpp0_gals_vpp1_larb5",
+		"vpp0_gals_vpp1_larb6",
+		"vpp0_smi_reorder",
+		"vpp0_smi_iommu",
+		"vpp0_gals_imgsys_camsys",
+		"vpp0_mdp_rdma",
+		"vpp0_mdp_wrot",
+		"vpp0_gals_emi0_emi1",
+		"vpp0_smi_sub_common_reorder",
+		"vpp0_smi_rsi",
+		"vpp0_smi_common_larb4",
+		"vpp0_gals_vdec_vdec_core1",
+		"vpp0_gals_vpp1_wpe",
+		"vpp0_gals_vdo0_vdo1_vencsys_core1",
+		"vpp0_fake_eng",
+		"vpp0_mdp_hdr",
+		"vpp0_mdp_tdshp",
+		"vpp0_mdp_color",
+		"vpp0_mdp_ovl",
+		"vpp0_warp0_relay",
+		"vpp0_warp0_mdp_dl_async",
+		"vpp0_warp1_relay",
+		"vpp0_warp1_mdp_dl_async",
+		"wpe_vpp0",
+		"wpe_vpp1",
+		"wpe_smi_larb7",
+		"wpe_smi_larb8",
+		"wpe_event_tx",
+		"wpe_smi_larb7_p",
+		"wpe_smi_larb8_p",
+		"wpe_vpp0_veci",
+		"wpe_vpp0_vec2i",
+		"wpe_vpp0_vec3i",
+		"wpe_vpp0_wpeo",
+		"wpe_vpp0_msko",
+		"wpe_vpp0_vgen",
+		"wpe_vpp0_ext",
+		"wpe_vpp0_vfc",
+		"wpe_vpp0_cach0_top",
+		"wpe_vpp0_cach0_dma",
+		"wpe_vpp0_cach1_top",
+		"wpe_vpp0_cach1_dma",
+		"wpe_vpp0_cach2_top",
+		"wpe_vpp0_cach2_dma",
+		"wpe_vpp0_cach3_top",
+		"wpe_vpp0_cach3_dma",
+		"wpe_vpp0_psp",
+		"wpe_vpp0_psp2",
+		"wpe_vpp0_sync",
+		"wpe_vpp0_c24",
+		"wpe_vpp0_mdp_crop",
+		"wpe_vpp0_isp_crop",
+		"wpe_vpp0_top",
+		"wpe_vpp1_veci",
+		"wpe_vpp1_vec2i",
+		"wpe_vpp1_vec3i",
+		"wpe_vpp1_wpeo",
+		"wpe_vpp1_msko",
+		"wpe_vpp1_vgen",
+		"wpe_vpp1_ext",
+		"wpe_vpp1_vfc",
+		"wpe_vpp1_cach0_top",
+		"wpe_vpp1_cach0_dma",
+		"wpe_vpp1_cach1_top",
+		"wpe_vpp1_cach1_dma",
+		"wpe_vpp1_cach2_top",
+		"wpe_vpp1_cach2_dma",
+		"wpe_vpp1_cach3_top",
+		"wpe_vpp1_cach3_dma",
+		"wpe_vpp1_psp",
+		"wpe_vpp1_psp2",
+		"wpe_vpp1_sync",
+		"wpe_vpp1_c24",
+		"wpe_vpp1_mdp_crop",
+		"wpe_vpp1_isp_crop",
+		"wpe_vpp1_top",
+		"vpp1_svpp1_mdp_ovl",
+		"vpp1_svpp1_mdp_tcc",
+		"vpp1_svpp1_mdp_wrot",
+		"vpp1_svpp1_vpp_pad",
+		"vpp1_svpp2_mdp_wrot",
+		"vpp1_svpp2_vpp_pad",
+		"vpp1_svpp3_mdp_wrot",
+		"vpp1_svpp3_vpp_pad",
+		"vpp1_svpp1_mdp_rdma",
+		"vpp1_svpp1_mdp_fg",
+		"vpp1_svpp2_mdp_rdma",
+		"vpp1_svpp2_mdp_fg",
+		"vpp1_svpp3_mdp_rdma",
+		"vpp1_svpp3_mdp_fg",
+		"vpp1_vpp_split",
+		"vpp1_svpp2_vdo0_dl_relay",
+		"vpp1_svpp1_mdp_tdshp",
+		"vpp1_svpp1_mdp_color",
+		"vpp1_svpp3_vdo1_dl_relay",
+		"vpp1_svpp2_vpp_merge",
+		"vpp1_svpp2_mdp_color",
+		"vpp1_vppsys1_gals",
+		"vpp1_svpp3_vpp_merge",
+		"vpp1_svpp3_mdp_color",
+		"vpp1_vppsys1_larb",
+		"vpp1_svpp1_mdp_rsz",
+		"vpp1_svpp1_mdp_hdr",
+		"vpp1_svpp1_mdp_aal",
+		"vpp1_svpp2_mdp_hdr",
+		"vpp1_svpp2_mdp_aal",
+		"vpp1_dl_async",
+		"vpp1_larb5_fake_eng",
+		"vpp1_svpp3_mdp_hdr",
+		"vpp1_svpp3_mdp_aal",
+		"vpp1_svpp2_vdo1_dl_relay",
+		"vpp1_larb6_fake_eng",
+		"vpp1_svpp2_mdp_rsz",
+		"vpp1_svpp3_mdp_rsz",
+		"vpp1_svpp3_vdo0_dl_relay",
+		"vpp1_disp_mutex",
+		"vpp1_svpp2_mdp_tdshp",
+		"vpp1_svpp3_mdp_tdshp",
+		"vpp1_vpp0_dl1_relay",
+		"vpp1_hdmi_meta",
+		"vpp1_vpp_split_hdmi",
+		"vpp1_dgi_in",
+		"vpp1_dgi_out",
+		"vpp1_vpp_split_dgi",
+		"vpp1_vpp0_dl_async",
+		"vpp1_vpp0_dl_relay",
+		"vpp1_vpp_split_26m",
+		"img_larb9",
+		"img_traw0",
+		"img_traw1",
+		"img_traw2",
+		"img_traw3",
+		"img_dip0",
+		"img_wpe0",
+		"img_ipe",
+		"img_dip1",
+		"img_wpe1",
+		"img_gals",
+		"img1_dip_top_larb10",
+		"img1_dip_top_dip_top",
+		"img1_dip_nr_reserve",
+		"img1_dip_nr_dip_nr",
+		"img1_wpe_larb11",
+		"img1_wpe_wpe",
+		"ipe_dpe",
+		"ipe_fdvt",
+		"ipe_me",
+		"ipe_top",
+		"ipe_smi_larb12",
+		"cam_larb13",
+		"cam_larb14",
+		"cam_main_cam",
+		"cam_main_camtg",
+		"cam_seninf",
+		"cam_gcamsva",
+		"cam_gcamsvb",
+		"cam_gcamsvc",
+		"cam_scamsa",
+		"cam_scamsb",
+		"cam_camsv_top",
+		"cam_camsv_cq",
+		"cam_adl",
+		"cam_asg",
+		"cam_pda",
+		"cam_fake_eng",
+		"cam_main_mraw0",
+		"cam_main_mraw1",
+		"cam_main_mraw2",
+		"cam_main_mraw3",
+		"cam_cam2mm0_gals",
+		"cam_cam2mm1_gals",
+		"cam_cam2sys_gals",
+		"cam_rawa_larbx",
+		"cam_rawa_cam",
+		"cam_rawa_camtg",
+		"cam_yuva_larbx",
+		"cam_yuva_cam",
+		"cam_yuva_camtg",
+		"cam_rawb_larbx",
+		"cam_rawb_cam",
+		"cam_rawb_camtg",
+		"cam_yuvb_larbx",
+		"cam_yuvb_cam",
+		"cam_yuvb_camtg",
+		"cam_mraw_larbx",
+		"cam_mraw_camtg",
+		"cam_mraw_mraw0",
+		"cam_mraw_mraw1",
+		"cam_mraw_mraw2",
+		"cam_mraw_mraw3",
+		"ccu_larb18",
+		"ccu_ahb",
+		"ccu_ccu0",
+		"ccu_ccu1",
+		"vdec_soc_larb1",
+		"vdec_soc_lat",
+		"vdec_soc_vdec",
+		"vdec_larb1",
+		"vdec_lat",
+		"vdec_vdec",
+		"vdec_core1_larb1",
+		"vdec_core1_lat",
+		"vdec_core1_vdec",
+		"venc_larb",
+		"venc_venc",
+		"venc_jpgenc",
+		"venc_jpgdec",
+		"venc_jpgdec_c1",
+		"venc_gals",
+		"venc_core1_larb",
+		"venc_core1_venc",
+		"venc_core1_jpgenc",
+		"venc_core1_jpgdec",
+		"venc_core1_jpgdec_c1",
+		"venc_core1_gals",
+		"vdo0_disp_ovl0",
+		"vdo0_disp_color0",
+		"vdo0_disp_color1",
+		"vdo0_disp_ccorr0",
+		"vdo0_disp_ccorr1",
+		"vdo0_disp_aal0",
+		"vdo0_disp_aal1",
+		"vdo0_disp_gamma0",
+		"vdo0_disp_gamma1",
+		"vdo0_disp_dither0",
+		"vdo0_disp_dither1",
+		"vdo0_disp_ovl1",
+		"vdo0_disp_wdma0",
+		"vdo0_disp_wdma1",
+		"vdo0_disp_rdma0",
+		"vdo0_disp_rdma1",
+		"vdo0_dsi0",
+		"vdo0_dsi1",
+		"vdo0_dsc_wrap0",
+		"vdo0_vpp_merge0",
+		"vdo0_dp_intf0",
+		"vdo0_disp_mutex0",
+		"vdo0_disp_il_rot0",
+		"vdo0_apb_bus",
+		"vdo0_fake_eng0",
+		"vdo0_fake_eng1",
+		"vdo0_dl_async0",
+		"vdo0_dl_async1",
+		"vdo0_dl_async2",
+		"vdo0_dl_async3",
+		"vdo0_dl_async4",
+		"vdo0_disp_monitor0",
+		"vdo0_disp_monitor1",
+		"vdo0_disp_monitor2",
+		"vdo0_disp_monitor3",
+		"vdo0_disp_monitor4",
+		"vdo0_smi_gals",
+		"vdo0_smi_common",
+		"vdo0_smi_emi",
+		"vdo0_smi_iommu",
+		"vdo0_smi_larb",
+		"vdo0_smi_rsi",
+		"vdo0_dsi0_dsi",
+		"vdo0_dsi1_dsi",
+		"vdo0_dp_intf0_dp_intf",
+		"vdo1_smi_larb2",
+		"vdo1_smi_larb3",
+		"vdo1_gals",
+		"vdo1_fake_eng0",
+		"vdo1_fake_eng",
+		"vdo1_mdp_rdma0",
+		"vdo1_mdp_rdma1",
+		"vdo1_mdp_rdma2",
+		"vdo1_mdp_rdma3",
+		"vdo1_vpp_merge0",
+		"vdo1_vpp_merge1",
+		"vdo1_vpp_merge2",
+		"vdo1_vpp_merge3",
+		"vdo1_vpp_merge4",
+		"vdo1_vpp2_to_vdo1_dl_async",
+		"vdo1_vpp3_to_vdo1_dl_async",
+		"vdo1_disp_mutex",
+		"vdo1_mdp_rdma4",
+		"vdo1_mdp_rdma5",
+		"vdo1_mdp_rdma6",
+		"vdo1_mdp_rdma7",
+		"vdo1_dp_intf0_mm",
+		"vdo1_dpi0_mm",
+		"vdo1_dpi1_mm",
+		"vdo1_disp_monitor",
+		"vdo1_merge0_dl_async",
+		"vdo1_merge1_dl_async",
+		"vdo1_merge2_dl_async",
+		"vdo1_merge3_dl_async",
+		"vdo1_merge4_dl_async",
+		"vdo1_vdo0_dsc_to_vdo1_dl_async",
+		"vdo1_vdo0_merge_to_vdo1_dl_async",
+		"vdo1_hdr_vdo_fe0",
+		"vdo1_hdr_gfx_fe0",
+		"vdo1_hdr_vdo_be",
+		"vdo1_hdr_vdo_fe1",
+		"vdo1_hdr_gfx_fe1",
+		"vdo1_disp_mixer",
+		"vdo1_hdr_vdo_fe0_dl_async",
+		"vdo1_hdr_vdo_fe1_dl_async",
+		"vdo1_hdr_gfx_fe0_dl_async",
+		"vdo1_hdr_gfx_fe1_dl_async",
+		"vdo1_hdr_vdo_be_dl_async",
+		"vdo1_dpi0",
+		"vdo1_disp_monitor_dpi0",
+		"vdo1_dpi1",
+		"vdo1_disp_monitor_dpi1",
+		"vdo1_dpintf",
+		"vdo1_disp_monitor_dpintf",
+		"vdo1_26m_slow",
+		/* end */
+		NULL
+	};
+
+	return clks;
+}
+
+/*
+ * clkdbg pwr_status
+ */
+
+static const char * const *get_pwr_names(void)
+{
+	static const char * const pwr_names[] = {
+		[0] = "",
+		[1] = "",
+		[2] = "",
+		[3] = "ETHER",
+		[4] = "",
+		[5] = "",
+		[6] = "",
+		[7] = "",
+		[8] = "AUDIO",
+		[9] = "AUDIO_ASRC",
+		[10] = "ADSP",
+		[11] = "VPPSYS0",
+		[12] = "VPPSYS1",
+		[13] = "VDOSYS0",
+		[14] = "VDOSYS1",
+		[15] = "WPESYS",
+		[16] = "DP_TX",
+		[17] = "EPD_TX",
+		[18] = "HDMI_TX",
+		[19] = "HDMI_RX",
+		[20] = "VDEC0",
+		[21] = "VDEC1",
+		[22] = "VDEC2",
+		[23] = "VENC",
+		[24] = "VENC_CORE1",
+		[25] = "CAM",
+		[26] = "CAM_RAWA",
+		[27] = "CAM_RAWB",
+		[28] = "CAM_MRAW",
+		[29] = "IMG",
+		[30] = "DIP",
+		[31] = "IPE",
+		/* CPU_PWR_STA */
+		[32] = "CPUEB",
+		[33] = "MFG0",
+		[34] = "MFG1",
+		[35] = "MFG2",
+		[36] = "MFG3",
+		[37] = "MFG4",
+		[38] = "MFG5",
+		[39] = "MFG6",
+		[40] = "IFR",
+		[41] = "IFR_SUB",
+		[42] = "PERI",
+		[43] = "PEXTP_MAC_TOP_P0",
+		[44] = "PEXTP_MAC_TOP_P1",
+		[45] = "PCIE_PHY",
+		[46] = "SSUSB_PCIE_PHY",
+		[47] = "NNA0",
+		[48] = "NNA1",
+		[49] = "IPNNA",
+		[50] = "CSI_RX_TOP",
+		[51] = "",
+		[52] = "",
+		[53] = "",
+		[54] = "CPU0",
+		[55] = "CPU1",
+		[56] = "CPU2",
+		[57] = "CPU3",
+		[58] = "CPU4",
+		[59] = "CPU5",
+		[60] = "CPU6",
+		[61] = "CPU7",
+		[62] = "CPUTOP",
+		[63] = "MCUSYS",
+		[64] = NULL,
+	};
+
+	return pwr_names;
+}
+
+static u32 _get_pwr_status(u32 pwr_sta_ofs, u32 pwr_sta_2nd_ofs)
+{
+	static void __iomem *scpsys_base, *pwr_sta, *pwr_sta_2nd;
+
+	scpsys_base = ioremap(0x10006000, PAGE_SIZE);
+	pwr_sta = scpsys_base + pwr_sta_ofs;
+	pwr_sta_2nd = scpsys_base + pwr_sta_2nd_ofs;
+
+	return clk_readl(pwr_sta) & clk_readl(pwr_sta_2nd);
+}
+
+static u32 *get_all_pwr_status(void)
+{
+	static struct regs {
+		u32 pwr_sta_ofs;
+		u32 pwr_sta_2nd_ofs;
+	} g[] = {
+		{0x16c, 0x170},
+		{0x174, 0x178},
+	};
+
+	static u32 pwr_sta[PWR_STA_GROUP_NR];
+	int i;
+
+	for (i = 0; i < PWR_STA_GROUP_NR; i++)
+		pwr_sta[i] = _get_pwr_status(g[i].pwr_sta_ofs, g[i].pwr_sta_2nd_ofs);
+
+	return pwr_sta;
+}
+
+/*
+ * clkdbg dump_clks
+ */
+
+static void setup_provider_clk(struct provider_clk *pvdck)
+{
+	static const struct {
+		const char *pvdname;
+		u32 pwr_sta_group;
+		u32 pwr_mask;
+	} pvd_pwr_mask[] = {
+		{"mfgcfg", 1, BIT(2)},
+		{"vppsys0", 0, BIT(11)},
+		{"wpesys", 0, BIT(15)},
+		{"wpesys_vpp0", 0, BIT(15)},
+		{"wpesys_vpp1", 0, BIT(15)},
+		{"vppsys1", 0, BIT(12)},
+		{"imgsys", 0, BIT(29)},
+		{"imgsys1_dip_top", 0, BIT(30)},
+		{"imgsys1_dip_nr", 0, BIT(30)},
+		{"imgsys1_wpe", 0, BIT(30)},
+		{"ipesys", 0, BIT(31)},
+		{"camsys", 0, BIT(25)},
+		{"camsys_rawa", 0, BIT(26)},
+		{"camsys_yuva", 0, BIT(26)},
+		{"camsys_rawb", 0, BIT(27)},
+		{"camsys_yuvb", 0, BIT(27)},
+		{"camsys_mraw", 0, BIT(28)},
+		{"ccusys", 0, BIT(25)},
+		{"vdecsys_soc", 0, BIT(20)},
+		{"vdecsys", 0, BIT(21)},
+		{"vdecsys_core1", 0, BIT(22)},
+		{"vencsys", 0, BIT(23)},
+		{"vencsys_core1", 0, BIT(24)},
+		{"vdosys0", 0, BIT(13)},
+		{"vdosys1", 0, BIT(14)},
+	};
+
+	static const struct {
+		const char *bus_clk_name;
+		const char *provider_name;
+	} pvd_bus_map[] = {
+		{"i2c_sel", "imp_iic_wrap_s"},
+		{"i2c_sel", "imp_iic_wrap_w"},
+	};
+
+	size_t i;
+	const char *pvdname = pvdck->provider_name;
+
+	if (pvdname == NULL)
+		return;
+
+	for (i = 0; i < ARRAY_SIZE(pvd_pwr_mask); i++) {
+		if (strcmp(pvdname, pvd_pwr_mask[i].pvdname) == 0) {
+			pvdck->pwr_sta_group = pvd_pwr_mask[i].pwr_sta_group;
+			pvdck->pwr_mask = pvd_pwr_mask[i].pwr_mask;
+			return;
+		}
+	}
+
+	for (i = 0; i < ARRAY_SIZE(pvd_bus_map); i++) {
+		if (strcmp(pvdname, pvd_bus_map[i].provider_name) == 0) {
+			pvdck->bus_ck = __clk_lookup(pvd_bus_map[i].bus_clk_name);
+			return;
+		}
+	}
+}
+
+static struct device_node *get_power_controller(void)
+{
+	return of_find_compatible_node(NULL, NULL, "mediatek,mt8195-power-controller");
+}
+
+/*
+ * init functions
+ */
+
+static struct clkdbg_ops clkdbg_mt8195_ops = {
+	.get_all_fmeter_clks = get_all_fmeter_clks,
+	.fmeter_freq = fmeter_freq_op,
+	.get_all_regnames = get_all_regnames,
+	.get_all_clk_names = get_all_clk_names,
+	.get_pwr_names = get_pwr_names,
+	.setup_provider_clk = setup_provider_clk,
+	.get_all_pwr_status = get_all_pwr_status,
+	.get_power_controller = get_power_controller,
+};
+
+static void __init init_custom_cmds(void)
+{
+	static const struct cmd_fn cmds[] = {
+		{}
+	};
+
+	set_custom_cmds(cmds);
+}
+
+static int __init clkdbg_mt8195_init(void)
+{
+	if (of_machine_is_compatible("mediatek,mt8195") == 0)
+		return -ENODEV;
+
+	init_regbase();
+
+	init_custom_cmds();
+	set_clkdbg_ops(&clkdbg_mt8195_ops);
+
+#if DUMP_INIT_STATE
+	print_regs();
+	print_fmeter_all();
+#endif /* DUMP_INIT_STATE */
+
+	return 0;
+}
+device_initcall(clkdbg_mt8195_init);
diff --git a/drivers/clk/mediatek/clkdbg.c b/drivers/clk/mediatek/clkdbg.c
new file mode 100644
index 0000000000000000000000000000000000000000..fd825c05e7685e995c4c462ca8c96ea1ce85a8eb
--- /dev/null
+++ b/drivers/clk/mediatek/clkdbg.c
@@ -0,0 +1,2345 @@
+// SPDX-License-Identifier: GPL-2.0
+//
+// Copyright (c) 2020 MediaTek Inc.
+// Author: Weiyi Lu <weiyi.lu@mediatek.com>
+
+#define pr_fmt(fmt) "[clkdbg] " fmt
+
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_platform.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+
+#include <linux/proc_fs.h>
+#include <linux/fs.h>
+#include <linux/seq_file.h>
+#include <linux/uaccess.h>
+
+#include <linux/clk.h>
+#include <linux/clk-provider.h>
+#include <linux/pm_domain.h>
+#include <linux/pm_runtime.h>
+#include <linux/module.h>
+#include <linux/version.h>
+
+#include "clkdbg.h"
+
+#if defined(CONFIG_PM_DEBUG)
+#define CLKDBG_PM_DOMAIN	1
+#else
+#define CLKDBG_PM_DOMAIN	0
+#endif
+#define CLKDBG_PM_DOMAIN_API_4_9	1
+#define CLKDBG_CCF_API_4_4	1
+#define CLKDBG_HACK_CLK		0
+#define CLKDBG_HACK_CLK_CORE	1
+#define CLKDBG_DROP_GENPD_AS_IN_PARAM	1
+#define CLKDBG_GENPD_STATUS_5_10	1
+
+#define TOTAL_CLK_NUM		1050
+#define MAX_SUBSYS_CLK_NUM	300
+/* NOTICE: to ensure null termination, always increase the maximum amount by one */
+#define TOTAL_PD_NUM		65
+#define TOTAL_DEV_STATE		(TOTAL_PD_NUM *3) /* clkdbg-pd, bring-up-pd, general user dev */
+
+#if !CLKDBG_CCF_API_4_4
+
+/* backward compatible */
+
+static const char *clk_hw_get_name(const struct clk_hw *hw)
+{
+	return __clk_get_name(hw->clk);
+}
+
+static bool clk_hw_is_prepared(const struct clk_hw *hw)
+{
+	return __clk_is_prepared(hw->clk);
+}
+
+static bool clk_hw_is_enabled(const struct clk_hw *hw)
+{
+	return __clk_is_enabled(hw->clk);
+}
+
+static unsigned long clk_hw_get_rate(const struct clk_hw *hw)
+{
+	return __clk_get_rate(hw->clk);
+}
+
+static unsigned int clk_hw_get_num_parents(const struct clk_hw *hw)
+{
+	return __clk_get_num_parents(hw->clk);
+}
+
+static struct clk_hw *clk_hw_get_parent_by_index(const struct clk_hw *hw,
+					  unsigned int index)
+{
+	return __clk_get_hw(clk_get_parent_by_index(hw->clk, index));
+}
+
+#endif /* !CLKDBG_CCF_API_4_4 */
+
+#if CLKDBG_HACK_CLK
+
+#include <linux/clk-private.h>
+
+static bool clk_hw_is_on(struct clk_hw *hw)
+{
+	const struct clk_ops *ops = hw->clk->ops;
+
+	if (ops->is_enabled)
+		return clk_hw_is_enabled(hw);
+	else if (ops->is_prepared)
+		return clk_hw_is_prepared(hw);
+	return clk_hw_is_enabled(hw) || clk_hw_is_prepared(hw);
+}
+
+#elif CLKDBG_HACK_CLK_CORE
+
+struct clk_core {
+	const char		*name;
+	const struct clk_ops	*ops;
+	struct clk_hw		*hw;
+};
+
+static bool clk_hw_is_on(struct clk_hw *hw)
+{
+	const struct clk_ops *ops = hw->core->ops;
+
+	if (ops->is_enabled)
+		return clk_hw_is_enabled(hw);
+	else if (ops->is_prepared)
+		return clk_hw_is_prepared(hw);
+	return clk_hw_is_enabled(hw) || clk_hw_is_prepared(hw);
+}
+
+#else
+
+static bool clk_hw_is_on(struct clk_hw *hw)
+{
+	return __clk_get_enable_count(hw->clk) || clk_hw_is_prepared(hw);
+}
+
+#endif /* !CLKDBG_HACK_CLK && !CLKDBG_HACK_CLK_CORE */
+
+static const struct clkdbg_ops *clkdbg_ops;
+
+void set_clkdbg_ops(const struct clkdbg_ops *ops)
+{
+	clkdbg_ops = ops;
+}
+
+static const struct fmeter_clk *get_all_fmeter_clks(void)
+{
+	if (clkdbg_ops == NULL || clkdbg_ops->get_all_fmeter_clks  == NULL)
+		return NULL;
+
+	return clkdbg_ops->get_all_fmeter_clks();
+}
+
+static void *prepare_fmeter(void)
+{
+	if (clkdbg_ops == NULL || clkdbg_ops->prepare_fmeter == NULL)
+		return NULL;
+
+	return clkdbg_ops->prepare_fmeter();
+}
+
+static void unprepare_fmeter(void *data)
+{
+	if (clkdbg_ops == NULL || clkdbg_ops->unprepare_fmeter == NULL)
+		return;
+
+	clkdbg_ops->unprepare_fmeter(data);
+}
+
+static u32 fmeter_freq(const struct fmeter_clk *fclk)
+{
+	if (clkdbg_ops == NULL || clkdbg_ops->fmeter_freq == NULL)
+		return 0;
+
+	return clkdbg_ops->fmeter_freq(fclk);
+}
+
+static const struct regname *get_all_regnames(void)
+{
+	if (clkdbg_ops == NULL || clkdbg_ops->get_all_regnames == NULL)
+		return NULL;
+
+	return clkdbg_ops->get_all_regnames();
+}
+
+static const char * const *get_all_clk_names(void)
+{
+	if (clkdbg_ops == NULL || clkdbg_ops->get_all_clk_names == NULL)
+		return NULL;
+
+	return clkdbg_ops->get_all_clk_names();
+}
+
+static const char * const *get_pwr_names(void)
+{
+	static const char * const default_pwr_names[] = {
+		[0]  = "",
+		[1]  = "",
+		[2]  = "",
+		[3]  = "",
+		[4]  = "",
+		[5]  = "",
+		[6]  = "",
+		[7]  = "",
+		[8]  = "",
+		[9]  = "",
+		[10] = "",
+		[11] = "",
+		[12] = "",
+		[13] = "",
+		[14] = "",
+		[15] = "",
+		[16] = "",
+		[17] = "",
+		[18] = "",
+		[19] = "",
+		[20] = "",
+		[21] = "",
+		[22] = "",
+		[23] = "",
+		[24] = "",
+		[25] = "",
+		[26] = "",
+		[27] = "",
+		[28] = "",
+		[29] = "",
+		[30] = "",
+		[31] = "",
+	};
+
+	if (clkdbg_ops == NULL || clkdbg_ops->get_pwr_names == NULL)
+		return default_pwr_names;
+
+	return clkdbg_ops->get_pwr_names();
+}
+
+static void setup_provider_clk(struct provider_clk *pvdck)
+{
+	if (clkdbg_ops == NULL || clkdbg_ops->setup_provider_clk == NULL)
+		return;
+
+	clkdbg_ops->setup_provider_clk(pvdck);
+}
+
+static bool is_valid_reg(void __iomem *addr)
+{
+#ifdef CONFIG_64BIT
+	return ((u64)addr & 0xf0000000) != 0UL ||
+			(((u64)addr >> 32U) & 0xf0000000) != 0UL;
+#else
+	return ((u32)addr & 0xf0000000) != 0U;
+#endif
+}
+
+enum clkdbg_opt {
+	CLKDBG_EN_SUSPEND_SAVE_1,
+	CLKDBG_EN_SUSPEND_SAVE_2,
+	CLKDBG_EN_SUSPEND_SAVE_3,
+	CLKDBG_EN_LOG_SAVE_POINTS,
+};
+
+static u32 clkdbg_flags;
+
+static void set_clkdbg_flag(enum clkdbg_opt opt)
+{
+	clkdbg_flags |= BIT(opt);
+}
+
+static void clr_clkdbg_flag(enum clkdbg_opt opt)
+{
+	clkdbg_flags &= ~BIT(opt);
+}
+
+static bool has_clkdbg_flag(enum clkdbg_opt opt)
+{
+	return (clkdbg_flags & BIT(opt)) != 0U;
+}
+
+typedef void (*fn_fclk_freq_proc)(const struct fmeter_clk *fclk,
+					u32 freq, void *data);
+
+static void proc_all_fclk_freq(fn_fclk_freq_proc proc, void *data)
+{
+	void *fmeter_data;
+	const struct fmeter_clk *fclk;
+
+	fclk = get_all_fmeter_clks();
+
+	if (fclk == NULL || proc == NULL)
+		return;
+
+	fmeter_data = prepare_fmeter();
+
+	for (; fclk->type != FT_NULL; fclk++) {
+		u32 freq;
+
+		freq = fmeter_freq(fclk);
+		proc(fclk, freq, data);
+	}
+
+	unprepare_fmeter(fmeter_data);
+}
+
+static void print_fclk_freq(const struct fmeter_clk *fclk, u32 freq, void *data)
+{
+	pr_info("%2d: %-29s: %u\n", fclk->id, fclk->name, freq);
+}
+
+void print_fmeter_all(void)
+{
+	proc_all_fclk_freq(print_fclk_freq, NULL);
+}
+
+static void seq_print_fclk_freq(const struct fmeter_clk *fclk,
+				u32 freq, void *data)
+{
+	struct seq_file *s = data;
+
+	seq_printf(s, "%2d: %-29s: %u\n", fclk->id, fclk->name, freq);
+}
+
+static int seq_print_fmeter_all(struct seq_file *s, void *v)
+{
+	proc_all_fclk_freq(seq_print_fclk_freq, s);
+
+	return 0;
+}
+
+typedef void (*fn_regname_proc)(const struct regname *rn, void *data);
+
+static void proc_all_regname(fn_regname_proc proc, void *data)
+{
+	const struct regname *rn = get_all_regnames();
+
+	if (rn == NULL)
+		return;
+
+	for (; rn->base != NULL; rn++)
+		proc(rn, data);
+}
+
+static void print_reg(const struct regname *rn, void *data)
+{
+	if (!is_valid_reg(ADDR(rn)))
+		return;
+
+	pr_info("%-21s: [0x%08x][0x%p] = 0x%08x\n",
+			rn->name, PHYSADDR(rn), ADDR(rn), clk_readl(ADDR(rn)));
+}
+
+void print_regs(void)
+{
+	proc_all_regname(print_reg, NULL);
+}
+
+static void seq_print_reg(const struct regname *rn, void *data)
+{
+	struct seq_file *s = data;
+
+	if (!is_valid_reg(ADDR(rn)))
+		return;
+
+	seq_printf(s, "%-21s: [0x%08x][0x%p] = 0x%08x\n",
+		rn->name, PHYSADDR(rn), ADDR(rn), clk_readl(ADDR(rn)));
+}
+
+static int seq_print_regs(struct seq_file *s, void *v)
+{
+	proc_all_regname(seq_print_reg, s);
+
+	return 0;
+}
+
+static void print_reg2(const struct regname *rn, void *data)
+{
+	if (!is_valid_reg(ADDR(rn)))
+		return;
+
+	pr_info("%-21s: [0x%08x][0x%p] = 0x%08x\n",
+		rn->name, PHYSADDR(rn), ADDR(rn), clk_readl(ADDR(rn)));
+
+	msleep(20);
+}
+
+static int clkdbg_dump_regs2(struct seq_file *s, void *v)
+{
+	proc_all_regname(print_reg2, s);
+
+	return 0;
+}
+
+static u32 read_spm_pwr_status(void)
+{
+	static void __iomem *scpsys_base, *pwr_sta, *pwr_sta_2nd;
+
+	if (clkdbg_ops == NULL || clkdbg_ops->get_spm_pwr_status  == NULL) {
+		if (scpsys_base == NULL ||
+		    pwr_sta == NULL || pwr_sta_2nd == NULL) {
+			scpsys_base = ioremap(0x10006000, PAGE_SIZE);
+			pwr_sta = scpsys_base + 0x60c;
+			pwr_sta_2nd = scpsys_base + 0x610;
+		}
+
+		return clk_readl(pwr_sta) & clk_readl(pwr_sta_2nd);
+	} else
+		return clkdbg_ops->get_spm_pwr_status();
+}
+
+static u32 *read_all_pwr_status(void)
+{
+	if (clkdbg_ops == NULL || clkdbg_ops->get_all_pwr_status == NULL)
+		return NULL;
+	else
+		return clkdbg_ops->get_all_pwr_status();
+}
+
+static bool clk_hw_pwr_is_on(struct clk_hw *c_hw,
+			u32 pwr_status, struct provider_clk *pvdck)
+{
+	if (pvdck->bus_ck != NULL && !__clk_is_enabled(pvdck->bus_ck))
+		return false;
+
+	if ((pwr_status & pvdck->pwr_mask) != pvdck->pwr_mask)
+		return false;
+
+	return clk_hw_is_on(c_hw);
+}
+
+static bool pvdck_pwr_is_on(struct provider_clk *pvdck, u32 pwr_status)
+{
+	struct clk *c = pvdck->ck;
+	struct clk_hw *c_hw = __clk_get_hw(c);
+
+	return clk_hw_pwr_is_on(c_hw, pwr_status, pvdck);
+}
+
+static bool pvdck_is_on(struct provider_clk *pvdck)
+{
+	u32 pwr_status = 0;
+
+	if (pvdck->pwr_mask != 0U) {
+		if (clkdbg_ops->get_all_pwr_status) {
+			u32 *val = read_all_pwr_status();
+
+			pwr_status = val[pvdck->pwr_sta_group];
+		} else
+			pwr_status = read_spm_pwr_status();
+	}
+
+	return pvdck_pwr_is_on(pvdck, pwr_status);
+}
+
+static const char *ccf_state(struct clk_hw *hw)
+{
+	if (__clk_get_enable_count(hw->clk))
+		return "enabled";
+
+	if (clk_hw_is_prepared(hw))
+		return "prepared";
+
+	return "disabled";
+}
+
+static void dump_clk_state(const char *clkname, struct seq_file *s)
+{
+	struct clk *c = __clk_lookup(clkname);
+	struct clk *p = IS_ERR_OR_NULL(c) ? NULL : clk_get_parent(c);
+	struct clk_hw *c_hw = __clk_get_hw(c);
+	struct clk_hw *p_hw = __clk_get_hw(p);
+
+	if (IS_ERR_OR_NULL(c)) {
+		seq_printf(s, "[%17s: NULL]\n", clkname);
+		return;
+	}
+
+	seq_printf(s, "[%-17s: %8s, %3d, %3d, %10ld, %17s]\n",
+		clk_hw_get_name(c_hw),
+		ccf_state(c_hw),
+		clk_hw_is_prepared(c_hw),
+		__clk_get_enable_count(c),
+		clk_hw_get_rate(c_hw),
+		p != NULL ? clk_hw_get_name(p_hw) : "- ");
+}
+
+static int clkdbg_dump_state_all(struct seq_file *s, void *v)
+{
+	const char * const *ckn = get_all_clk_names();
+
+	if (ckn == NULL)
+		return 0;
+
+	for (; *ckn != NULL; ckn++)
+		dump_clk_state(*ckn, s);
+
+	return 0;
+}
+
+static const char *get_provider_name(struct device_node *node, u32 *cells)
+{
+	const char *name;
+	const char *p;
+	u32 cc;
+
+	if (of_property_read_u32(node, "#clock-cells", &cc) != 0)
+		cc = 0;
+
+	if (cells != NULL)
+		*cells = cc;
+
+	if (cc == 0U) {
+		if (of_property_read_string(node,
+				"clock-output-names", &name) < 0)
+			name = node->name;
+
+		return name;
+	}
+
+	if (of_property_read_string(node, "compatible", &name) < 0)
+		name = node->name;
+
+	p = strchr(name, (int)'-');
+
+	if (p != NULL)
+		return p + 1;
+	else
+		return name;
+}
+
+struct provider_clk *get_all_provider_clks(void)
+{
+	static struct provider_clk provider_clks[TOTAL_CLK_NUM];
+	struct device_node *node = NULL;
+	unsigned int n = 0;
+
+	if (provider_clks[0].ck != NULL)
+		return provider_clks;
+
+	do {
+		const char *node_name;
+		u32 cells;
+
+		node = of_find_node_with_property(node, "#clock-cells");
+
+		if (node == NULL)
+			break;
+
+		node_name = get_provider_name(node, &cells);
+
+		if (cells == 0U) {
+			struct clk *ck = __clk_lookup(node_name);
+
+			if (IS_ERR_OR_NULL(ck))
+				continue;
+
+			provider_clks[n].ck = ck;
+			setup_provider_clk(&provider_clks[n]);
+			++n;
+		} else {
+			unsigned int i;
+
+			for (i = 0; i < MAX_SUBSYS_CLK_NUM; i++) {
+				struct of_phandle_args pa;
+				struct clk *ck;
+
+				pa.np = node;
+				pa.args[0] = i;
+				pa.args_count = 1;
+				ck = of_clk_get_from_provider(&pa);
+
+				if (PTR_ERR(ck) == -EINVAL)
+					break;
+				else if (IS_ERR_OR_NULL(ck))
+					continue;
+
+				provider_clks[n].ck = ck;
+				provider_clks[n].idx = i;
+				provider_clks[n].provider_name = node_name;
+				setup_provider_clk(&provider_clks[n]);
+				++n;
+			}
+		}
+	} while (node != NULL && n < TOTAL_CLK_NUM);
+
+	return provider_clks;
+}
+
+static void dump_provider_clk(struct provider_clk *pvdck, struct seq_file *s)
+{
+	struct clk *c = pvdck->ck;
+	struct clk *p = IS_ERR_OR_NULL(c) ? NULL : clk_get_parent(c);
+	struct clk_hw *c_hw = __clk_get_hw(c);
+	struct clk_hw *p_hw = __clk_get_hw(p);
+
+	seq_printf(s, "[%10s: %-17s: %3s, %3d, %3d, %10ld, %17s]\n",
+		pvdck->provider_name != NULL ? pvdck->provider_name : "/ ",
+		clk_hw_get_name(c_hw),
+		pvdck_is_on(pvdck) ? "ON" : "off",
+		clk_hw_is_prepared(c_hw),
+		__clk_get_enable_count(c),
+		clk_hw_get_rate(c_hw),
+		p != NULL ? clk_hw_get_name(p_hw) : "- ");
+}
+
+static int clkdbg_dump_provider_clks(struct seq_file *s, void *v)
+{
+	struct provider_clk *pvdck = get_all_provider_clks();
+
+	for (; pvdck->ck != NULL; pvdck++)
+		dump_provider_clk(pvdck, s);
+
+	return 0;
+}
+
+static void dump_provider_mux(struct provider_clk *pvdck, struct seq_file *s)
+{
+	unsigned int i;
+	struct clk *c = pvdck->ck;
+	struct clk_hw *c_hw = __clk_get_hw(c);
+	unsigned int np = clk_hw_get_num_parents(c_hw);
+
+	if (np <= 1U)
+		return;
+
+	dump_provider_clk(pvdck, s);
+
+	for (i = 0; i < np; i++) {
+		struct clk_hw *p_hw = clk_hw_get_parent_by_index(c_hw, i);
+
+		if (IS_ERR_OR_NULL(p_hw))
+			continue;
+
+		seq_printf(s, "\t\t\t(%2d: %-17s: %8s, %10ld)\n",
+			i,
+			clk_hw_get_name(p_hw),
+			ccf_state(p_hw),
+			clk_hw_get_rate(p_hw));
+	}
+}
+
+static int clkdbg_dump_muxes(struct seq_file *s, void *v)
+{
+	struct provider_clk *pvdck = get_all_provider_clks();
+
+	for (; pvdck->ck != NULL; pvdck++)
+		dump_provider_mux(pvdck, s);
+
+	return 0;
+}
+
+
+static void show_pwr_status(u32 *pwr_status)
+{
+	unsigned int i;
+	const char * const *pwr_name = get_pwr_names();
+
+	if (clkdbg_ops->get_all_pwr_status) {
+		for (i = 0; i < PWR_STA_GROUP_NR; i++)
+			pr_info("SPM_PWR_STATUS[%d]: 0x%08x\n\n", i, pwr_status[i]);
+
+		for (i = 0; pwr_name[i] != NULL; i++) {
+			const char *st = (pwr_status[i / 32] & BIT(i % 32)) != 0U ? "ON" : "off";
+
+			pr_info("[%2d]: %3s: %s\n", i, st, pwr_name[i]);
+			mdelay(20);
+		}
+	} else {
+		pr_info("SPM_PWR_STATUS: 0x%08x\n\n", *pwr_status);
+
+		for (i = 0; i < 32; i++) {
+			const char *st = (*pwr_status & BIT(i)) != 0U ? "ON" : "off";
+
+			pr_info("[%2d]: %3s: %s\n", i, st, pwr_name[i]);
+			mdelay(20);
+		}
+	}
+}
+
+static int dump_pwr_status(u32 *pwr_status, struct seq_file *s)
+{
+	unsigned int i;
+	const char * const *pwr_name = get_pwr_names();
+
+	if (clkdbg_ops->get_all_pwr_status) {
+		for (i = 0; i < PWR_STA_GROUP_NR; i++)
+			seq_printf(s, "SPM_PWR_STATUS[%d]: 0x%08x\n\n", i, pwr_status[i]);
+
+		for (i = 0; pwr_name[i] != NULL; i++) {
+			const char *st = (pwr_status[i / 32] & BIT(i % 32)) != 0U ? "ON" : "off";
+
+			seq_printf(s, "[%2d]: %3s: %s\n", i, st, pwr_name[i]);
+		}
+	} else {
+		seq_printf(s, "SPM_PWR_STATUS: 0x%08x\n\n", *pwr_status);
+
+		for (i = 0; i < 32; i++) {
+			const char *st = (*pwr_status & BIT(i)) != 0U ? "ON" : "off";
+
+			seq_printf(s, "[%2d]: %3s: %s\n", i, st, pwr_name[i]);
+		}
+	}
+
+	return 0;
+}
+
+static int clkdbg_pwr_status(struct seq_file *s, void *v)
+{
+	u32 val;
+
+	if (clkdbg_ops->get_all_pwr_status)
+		return dump_pwr_status(read_all_pwr_status(), s);
+
+	val = read_spm_pwr_status();
+	return dump_pwr_status(&val, s);
+}
+
+static char last_cmd[128] = "null";
+
+const char *get_last_cmd(void)
+{
+	return last_cmd;
+}
+
+static int clkop_int_ckname(int (*clkop)(struct clk *clk),
+			const char *clkop_name, const char *clk_name,
+			struct clk *ck, struct seq_file *s)
+{
+	struct clk *clk;
+
+	if (!IS_ERR_OR_NULL(ck)) {
+		clk = ck;
+	} else {
+		clk = __clk_lookup(clk_name);
+		if (IS_ERR_OR_NULL(clk)) {
+			seq_printf(s, "clk_lookup(%s): 0x%p\n", clk_name, clk);
+			return PTR_ERR(clk);
+		}
+	}
+
+	return clkop(clk);
+}
+
+static int clkdbg_clkop_int_ckname(int (*clkop)(struct clk *clk),
+			const char *clkop_name, struct seq_file *s, void *v)
+{
+	char cmd[sizeof(last_cmd)];
+	char *c = cmd;
+	char *ign;
+	char *clk_name;
+	int r = 0;
+
+	strncpy(cmd, last_cmd, sizeof(cmd));
+	cmd[sizeof(cmd) - 1UL] = '\0';
+
+	ign = strsep(&c, " ");
+	clk_name = strsep(&c, " ");
+
+	if (clk_name == NULL)
+		return 0;
+
+	if (strcmp(clk_name, "all") == 0) {
+		struct provider_clk *pvdck = get_all_provider_clks();
+
+		for (; pvdck->ck != NULL; pvdck++) {
+			r |= clkop_int_ckname(clkop, clkop_name, NULL,
+						pvdck->ck, s);
+		}
+
+		seq_printf(s, "%s(%s): %d\n", clkop_name, clk_name, r);
+
+		return r;
+	}
+
+	r = clkop_int_ckname(clkop, clkop_name, clk_name, NULL, s);
+	seq_printf(s, "%s(%s): %d\n", clkop_name, clk_name, r);
+
+	return r;
+}
+
+static void clkop_void_ckname(void (*clkop)(struct clk *clk),
+			const char *clkop_name, const char *clk_name,
+			struct clk *ck, struct seq_file *s)
+{
+	struct clk *clk;
+
+	if (!IS_ERR_OR_NULL(ck)) {
+		clk = ck;
+	} else {
+		clk = __clk_lookup(clk_name);
+		if (IS_ERR_OR_NULL(clk)) {
+			seq_printf(s, "clk_lookup(%s): 0x%p\n", clk_name, clk);
+			return;
+		}
+	}
+
+	clkop(clk);
+}
+
+static int clkdbg_clkop_void_ckname(void (*clkop)(struct clk *clk),
+			const char *clkop_name, struct seq_file *s, void *v)
+{
+	char cmd[sizeof(last_cmd)];
+	char *c = cmd;
+	char *ign;
+	char *clk_name;
+
+	strncpy(cmd, last_cmd, sizeof(cmd));
+	cmd[sizeof(cmd) - 1UL] = '\0';
+
+	ign = strsep(&c, " ");
+	clk_name = strsep(&c, " ");
+
+	if (clk_name == NULL)
+		return 0;
+
+	if (strcmp(clk_name, "all") == 0) {
+		struct provider_clk *pvdck = get_all_provider_clks();
+
+		for (; pvdck->ck != NULL; pvdck++) {
+			clkop_void_ckname(clkop, clkop_name, NULL,
+						pvdck->ck, s);
+		}
+
+		seq_printf(s, "%s(%s)\n", clkop_name, clk_name);
+
+		return 0;
+	}
+
+	clkop_void_ckname(clkop, clkop_name, clk_name, NULL, s);
+	seq_printf(s, "%s(%s)\n", clkop_name, clk_name);
+
+	return 0;
+}
+
+static int clkdbg_prepare(struct seq_file *s, void *v)
+{
+	return clkdbg_clkop_int_ckname(clk_prepare,
+					"clk_prepare", s, v);
+}
+
+static int clkdbg_unprepare(struct seq_file *s, void *v)
+{
+	return clkdbg_clkop_void_ckname(clk_unprepare,
+					"clk_unprepare", s, v);
+}
+
+static int clkdbg_enable(struct seq_file *s, void *v)
+{
+	return clkdbg_clkop_int_ckname(clk_enable,
+					"clk_enable", s, v);
+}
+
+static int clkdbg_disable(struct seq_file *s, void *v)
+{
+	return clkdbg_clkop_void_ckname(clk_disable,
+					"clk_disable", s, v);
+}
+
+static int clkdbg_prepare_enable(struct seq_file *s, void *v)
+{
+	return clkdbg_clkop_int_ckname(clk_prepare_enable,
+					"clk_prepare_enable", s, v);
+}
+
+static int clkdbg_disable_unprepare(struct seq_file *s, void *v)
+{
+	return clkdbg_clkop_void_ckname(clk_disable_unprepare,
+					"clk_disable_unprepare", s, v);
+}
+
+void prepare_enable_provider(const char *pvd)
+{
+	bool allpvd = (pvd == NULL || strcmp(pvd, "all") == 0);
+	struct provider_clk *pvdck = get_all_provider_clks();
+
+	for (; pvdck->ck != NULL; pvdck++) {
+		if (allpvd || (pvdck->provider_name != NULL &&
+				strcmp(pvd, pvdck->provider_name) == 0)) {
+			int r = clk_prepare_enable(pvdck->ck);
+
+			if (r != 0)
+				pr_info("clk_prepare_enable(): %d\n", r);
+		}
+	}
+}
+
+void disable_unprepare_provider(const char *pvd)
+{
+	bool allpvd = (pvd == NULL || strcmp(pvd, "all") == 0);
+	struct provider_clk *pvdck = get_all_provider_clks();
+
+	for (; pvdck->ck != NULL; pvdck++) {
+		if (allpvd || (pvdck->provider_name != NULL &&
+				strcmp(pvd, pvdck->provider_name) == 0))
+			clk_disable_unprepare(pvdck->ck);
+	}
+}
+
+static void clkpvdop(void (*pvdop)(const char *), const char *clkpvdop_name,
+			struct seq_file *s)
+{
+	char cmd[sizeof(last_cmd)];
+	char *c = cmd;
+	char *ign;
+	char *pvd_name;
+
+	strncpy(cmd, last_cmd, sizeof(cmd));
+	cmd[sizeof(cmd) - 1UL] = '\0';
+
+	ign = strsep(&c, " ");
+	pvd_name = strsep(&c, " ");
+
+	if (pvd_name == NULL)
+		return;
+
+	pvdop(pvd_name);
+	seq_printf(s, "%s(%s)\n", clkpvdop_name, pvd_name);
+}
+
+static int clkdbg_prepare_enable_provider(struct seq_file *s, void *v)
+{
+	clkpvdop(prepare_enable_provider, "prepare_enable_provider", s);
+	return 0;
+}
+
+static int clkdbg_disable_unprepare_provider(struct seq_file *s, void *v)
+{
+	clkpvdop(disable_unprepare_provider, "disable_unprepare_provider", s);
+	return 0;
+}
+
+static int clkdbg_set_parent(struct seq_file *s, void *v)
+{
+	char cmd[sizeof(last_cmd)];
+	char *c = cmd;
+	char *ign;
+	char *clk_name;
+	char *parent_name;
+	struct clk *clk;
+	struct clk *parent;
+	int r;
+
+	strncpy(cmd, last_cmd, sizeof(cmd));
+	cmd[sizeof(cmd) - 1UL] = '\0';
+
+	ign = strsep(&c, " ");
+	clk_name = strsep(&c, " ");
+	parent_name = strsep(&c, " ");
+
+	if (clk_name == NULL || parent_name == NULL)
+		return 0;
+
+	seq_printf(s, "clk_set_parent(%s, %s): ", clk_name, parent_name);
+
+	clk = __clk_lookup(clk_name);
+	if (IS_ERR_OR_NULL(clk)) {
+		seq_printf(s, "__clk_lookup(): 0x%p\n", clk);
+		return PTR_ERR(clk);
+	}
+
+	parent = __clk_lookup(parent_name);
+	if (IS_ERR_OR_NULL(parent)) {
+		seq_printf(s, "__clk_lookup(): 0x%p\n", parent);
+		return PTR_ERR(parent);
+	}
+
+	r = clk_prepare_enable(clk);
+	if (r != 0) {
+		seq_printf(s, "clk_prepare_enable(): %d\n", r);
+		return r;
+	}
+
+	r = clk_set_parent(clk, parent);
+	seq_printf(s, "%d\n", r);
+
+	clk_disable_unprepare(clk);
+
+	return r;
+}
+
+static int clkdbg_set_rate(struct seq_file *s, void *v)
+{
+	char cmd[sizeof(last_cmd)];
+	char *c = cmd;
+	char *ign;
+	char *clk_name;
+	char *rate_str;
+	struct clk *clk;
+	unsigned long rate;
+	int r;
+
+	strncpy(cmd, last_cmd, sizeof(cmd));
+	cmd[sizeof(cmd) - 1UL] = '\0';
+
+	ign = strsep(&c, " ");
+	clk_name = strsep(&c, " ");
+	rate_str = strsep(&c, " ");
+
+	if (clk_name == NULL || rate_str == NULL)
+		return 0;
+
+	r = kstrtoul(rate_str, 0, &rate);
+
+	seq_printf(s, "clk_set_rate(%s, %lu): %d: ", clk_name, rate, r);
+
+	clk = __clk_lookup(clk_name);
+	if (IS_ERR_OR_NULL(clk)) {
+		seq_printf(s, "__clk_lookup(): 0x%p\n", clk);
+		return PTR_ERR(clk);
+	}
+
+	r = clk_set_rate(clk, rate);
+	seq_printf(s, "%d\n", r);
+
+	return r;
+}
+
+static void *reg_from_str(const char *str)
+{
+	static phys_addr_t phys;
+	static void __iomem *virt;
+
+	if (sizeof(void *) == sizeof(unsigned long)) {
+		unsigned long v;
+
+		if (kstrtoul(str, 0, &v) == 0U) {
+			if ((0xf0000000 & v) < 0x20000000) {
+				if (virt != NULL && v > phys
+						&& v < phys + PAGE_SIZE)
+					return virt + v - phys;
+
+				if (virt != NULL)
+					iounmap(virt);
+
+				phys = v & ~(PAGE_SIZE - 1U);
+				virt = ioremap(phys, PAGE_SIZE);
+
+				return virt + v - phys;
+			}
+
+			return (void *)((uintptr_t)v);
+		}
+	} else if (sizeof(void *) == sizeof(unsigned long long)) {
+		unsigned long long v;
+
+		if (kstrtoull(str, 0, &v) == 0) {
+			if ((0xfffffffff0000000ULL & v) < 0x20000000) {
+				if (virt && v > phys && v < phys + PAGE_SIZE)
+					return virt + v - phys;
+
+				if (virt != NULL)
+					iounmap(virt);
+
+				phys = v & ~(PAGE_SIZE - 1);
+				virt = ioremap(phys, PAGE_SIZE);
+
+				return virt + v - phys;
+			}
+
+			return (void *)((uintptr_t)v);
+		}
+	} else {
+		pr_warn("unexpected pointer size: sizeof(void *): %zu\n",
+			sizeof(void *));
+	}
+
+	pr_warn("%s(): parsing error: %s\n", __func__, str);
+
+	return NULL;
+}
+
+static int parse_reg_val_from_cmd(void __iomem **preg, unsigned long *pval)
+{
+	char cmd[sizeof(last_cmd)];
+	char *c = cmd;
+	char *ign;
+	char *reg_str;
+	char *val_str;
+	int r = 0;
+
+	strncpy(cmd, last_cmd, sizeof(cmd));
+	cmd[sizeof(cmd) - 1UL] = '\0';
+
+	ign = strsep(&c, " ");
+	reg_str = strsep(&c, " ");
+	val_str = strsep(&c, " ");
+
+	if (preg != NULL && reg_str != NULL) {
+		*preg = reg_from_str(reg_str);
+		if (*preg != NULL)
+			r++;
+	}
+
+	if (pval != NULL && val_str != NULL && kstrtoul(val_str, 0, pval) == 0)
+		r++;
+
+	return r;
+}
+
+static int clkdbg_reg_read(struct seq_file *s, void *v)
+{
+	void __iomem *reg;
+	unsigned long val;
+
+	if (parse_reg_val_from_cmd(&reg, NULL) != 1)
+		return 0;
+
+	seq_printf(s, "readl(0x%p): ", reg);
+
+	val = clk_readl(reg);
+	seq_printf(s, "0x%08x\n", (u32)val);
+
+	return 0;
+}
+
+static int clkdbg_reg_write(struct seq_file *s, void *v)
+{
+	void __iomem *reg;
+	unsigned long val;
+
+	if (parse_reg_val_from_cmd(&reg, &val) != 2)
+		return 0;
+
+	seq_printf(s, "writel(0x%p, 0x%08x): ", reg, (u32)val);
+
+	clk_writel(reg, val);
+	val = clk_readl(reg);
+	seq_printf(s, "0x%08x\n", (u32)val);
+
+	return 0;
+}
+
+static int clkdbg_reg_set(struct seq_file *s, void *v)
+{
+	void __iomem *reg;
+	unsigned long val;
+
+	if (parse_reg_val_from_cmd(&reg, &val) != 2)
+		return 0;
+
+	seq_printf(s, "writel(0x%p, 0x%08x): ", reg, (u32)val);
+
+	clk_setl(reg, val);
+	val = clk_readl(reg);
+	seq_printf(s, "0x%08x\n", (u32)val);
+
+	return 0;
+}
+
+static int clkdbg_reg_clr(struct seq_file *s, void *v)
+{
+	void __iomem *reg;
+	unsigned long val;
+
+	if (parse_reg_val_from_cmd(&reg, &val) != 2)
+		return 0;
+
+	seq_printf(s, "writel(0x%p, 0x%08x): ", reg, (u32)val);
+
+	clk_clrl(reg, val);
+	val = clk_readl(reg);
+	seq_printf(s, "0x%08x\n", (u32)val);
+
+	return 0;
+}
+
+static int parse_val_from_cmd(unsigned long *pval)
+{
+	char cmd[sizeof(last_cmd)];
+	char *c = cmd;
+	char *ign;
+	char *val_str;
+	int r = 0;
+
+	strncpy(cmd, last_cmd, sizeof(cmd));
+	cmd[sizeof(cmd) - 1UL] = '\0';
+
+	ign = strsep(&c, " ");
+	val_str = strsep(&c, " ");
+
+	if (pval != NULL && val_str != NULL && kstrtoul(val_str, 0, pval) == 0)
+		r++;
+
+	return r;
+}
+
+static int clkdbg_show_flags(struct seq_file *s, void *v)
+{
+	static const char * const clkdbg_opt_name[] = {
+		"CLKDBG_EN_SUSPEND_SAVE_1",
+		"CLKDBG_EN_SUSPEND_SAVE_2",
+		"CLKDBG_EN_SUSPEND_SAVE_3",
+		"CLKDBG_EN_LOG_SAVE_POINTS",
+	};
+
+	size_t i;
+
+	seq_printf(s, "clkdbg_flags: 0x%08x\n", clkdbg_flags);
+
+	for (i = 0; i < ARRAY_SIZE(clkdbg_opt_name); i++) {
+		const char *onff =
+			has_clkdbg_flag((enum clkdbg_opt)i) ? "ON" : "off";
+
+		seq_printf(s, "[%2zd]: %3s: %s\n", i, onff, clkdbg_opt_name[i]);
+	}
+
+	return 0;
+}
+
+static int clkdbg_set_flag(struct seq_file *s, void *v)
+{
+	unsigned long val;
+
+	if (parse_val_from_cmd(&val) != 1)
+		return 0;
+
+	set_clkdbg_flag((enum clkdbg_opt)val);
+
+	seq_printf(s, "clkdbg_flags: 0x%08x\n", clkdbg_flags);
+
+	return 0;
+}
+
+static int clkdbg_clr_flag(struct seq_file *s, void *v)
+{
+	unsigned long val;
+
+	if (parse_val_from_cmd(&val) != 1)
+		return 0;
+
+	clr_clkdbg_flag((enum clkdbg_opt)val);
+
+	seq_printf(s, "clkdbg_flags: 0x%08x\n", clkdbg_flags);
+
+	return 0;
+}
+
+#if CLKDBG_PM_DOMAIN
+
+/*
+ * pm_domain support
+ */
+
+static struct device_node *get_power_controller(void)
+{
+	if (clkdbg_ops == NULL || clkdbg_ops->get_power_controller  == NULL)
+		return of_find_node_with_property(NULL, "#power-domain-cells");
+	else
+		return clkdbg_ops->get_power_controller();
+}
+
+
+static struct generic_pm_domain **get_all_genpd(void)
+{
+	static struct generic_pm_domain *pds[TOTAL_PD_NUM];
+	static unsigned int num_pds;
+	const size_t maxpd = ARRAY_SIZE(pds) - 1; /* ensure null termination */
+	struct device_node *node;
+#if CLKDBG_PM_DOMAIN_API_4_9
+	struct platform_device *pdev;
+	int r;
+#endif
+
+	if (num_pds != 0)
+		goto out;
+
+	node = get_power_controller();
+
+	if (node == NULL)
+		return NULL;
+
+#if CLKDBG_PM_DOMAIN_API_4_9
+	pdev = platform_device_alloc("traverse", 0);
+#endif
+
+	for (num_pds = 0; num_pds < maxpd; num_pds++) {
+		struct of_phandle_args pa;
+
+		pa.np = node;
+		pa.args[0] = num_pds;
+		pa.args_count = 1;
+
+#if CLKDBG_PM_DOMAIN_API_4_9
+		r = of_genpd_add_device(&pa, &pdev->dev);
+		if (r == -EINVAL)
+			continue;
+		else if (r != 0)
+			pr_warn("%s(): of_genpd_add_device(%d)\n", __func__, r);
+		pds[num_pds] = pd_to_genpd(pdev->dev.pm_domain);
+#if CLKDBG_DROP_GENPD_AS_IN_PARAM
+		r = pm_genpd_remove_device(&pdev->dev);
+#else
+		r = pm_genpd_remove_device(pds[num_pds], &pdev->dev);
+#endif
+		if (r != 0)
+			pr_warn("%s(): pm_genpd_remove_device(%d)\n",
+					__func__, r);
+#else
+		pds[num_pds] = of_genpd_get_from_provider(&pa);
+#endif
+
+		if (IS_ERR(pds[num_pds])) {
+			pds[num_pds] = NULL;
+			break;
+		}
+	}
+
+#if CLKDBG_PM_DOMAIN_API_4_9
+	platform_device_put(pdev);
+#endif
+
+out:
+	return pds;
+}
+
+static struct device *dev_from_name(const char *name)
+{
+	struct generic_pm_domain **pds = get_all_genpd();
+
+	for (; pds != NULL && *pds != NULL; pds++) {
+		struct pm_domain_data *pdd;
+		struct generic_pm_domain *pd = *pds;
+
+		if (IS_ERR_OR_NULL(pd))
+			continue;
+
+		list_for_each_entry(pdd, &pd->dev_list, list_node) {
+			struct device *dev = pdd->dev;
+			const char *devname = dev_name(dev);
+
+			if (devname && strcmp(name, devname) == 0)
+				return dev;
+		}
+	}
+
+	return NULL;
+}
+
+static struct generic_pm_domain *genpd_from_name(const char *name)
+{
+	struct generic_pm_domain **pds = get_all_genpd();
+
+	for (; pds != NULL && *pds != NULL; pds++) {
+		struct generic_pm_domain *pd = *pds;
+
+		if (IS_ERR_OR_NULL(pd))
+			continue;
+
+		if (strcmp(name, pd->name) == 0)
+			return pd;
+	}
+
+	return NULL;
+}
+
+struct genpd_dev_state {
+	struct device *dev;
+	bool active;
+	atomic_t usage_count;
+	unsigned int disable_depth;
+	enum rpm_status runtime_status;
+};
+
+struct genpd_state {
+	struct generic_pm_domain *pd;
+	enum gpd_status status;
+	struct genpd_dev_state *dev_state;
+	int num_dev_state;
+};
+
+static void save_all_genpd_state(struct genpd_state *genpd_states,
+				struct genpd_dev_state *genpd_dev_states)
+{
+	struct genpd_state *pdst = genpd_states;
+	struct genpd_dev_state *devst = genpd_dev_states;
+	struct generic_pm_domain **pds = get_all_genpd();
+
+	for (; pds != NULL && *pds != NULL; pds++) {
+		struct pm_domain_data *pdd;
+		struct generic_pm_domain *pd = *pds;
+
+		if (IS_ERR_OR_NULL(pd))
+			continue;
+
+		pdst->pd = pd;
+		pdst->status = pd->status;
+		pdst->dev_state = devst;
+		pdst->num_dev_state = 0;
+
+		list_for_each_entry(pdd, &pd->dev_list, list_node) {
+			struct device *d = pdd->dev;
+
+			devst->dev = d;
+			devst->active = pm_runtime_active(d);
+			devst->usage_count = d->power.usage_count;
+			devst->disable_depth = d->power.disable_depth;
+			devst->runtime_status = d->power.runtime_status;
+
+			devst++;
+			pdst->num_dev_state++;
+		}
+
+		pdst++;
+	}
+
+	pdst->pd = NULL;
+	devst->dev = NULL;
+}
+
+static void show_genpd_state(struct genpd_state *pdst)
+{
+	static const char * const gpd_status_name[] = {
+		"ACTIVE",
+		"POWER_OFF",
+	};
+
+	static const char * const prm_status_name[] = {
+		"active",
+		"resuming",
+		"suspended",
+		"suspending",
+	};
+
+	pr_info("domain_on [pmd_name  status]\n");
+	pr_info("\tdev_on (dev_name usage_count, disable, status)\n");
+	pr_info("------------------------------------------------------\n");
+
+	for (; pdst->pd != NULL; pdst++) {
+		int i;
+		struct generic_pm_domain *pd = pdst->pd;
+
+		if (IS_ERR_OR_NULL(pd)) {
+			pr_info("pd: 0x%p\n", pd);
+			continue;
+		}
+
+#if CLKDBG_GENPD_STATUS_5_10
+		pr_info("%c [%-9s %11s]\n",
+			(pdst->status == GENPD_STATE_ON) ? '+' : '-',
+			pd->name, gpd_status_name[pdst->status]);
+#else
+		pr_info("%c [%-9s %11s]\n",
+			(pdst->status == GPD_STATE_ACTIVE) ? '+' : '-',
+			pd->name, gpd_status_name[pdst->status]);
+#endif
+
+		for (i = 0; i < pdst->num_dev_state; i++) {
+			struct genpd_dev_state *devst = &pdst->dev_state[i];
+			struct device *dev = devst->dev;
+
+			pr_info("\t%c (%-19s %3d, %d, %10s)\n",
+				devst->active ? '+' : '-',
+				dev_name(dev),
+				atomic_read(&dev->power.usage_count),
+				devst->disable_depth,
+				prm_status_name[devst->runtime_status]);
+			mdelay(20);
+		}
+	}
+}
+
+static void dump_genpd_state(struct genpd_state *pdst, struct seq_file *s)
+{
+	static const char * const gpd_status_name[] = {
+		"ACTIVE",
+		"POWER_OFF",
+	};
+
+	static const char * const prm_status_name[] = {
+		"active",
+		"resuming",
+		"suspended",
+		"suspending",
+	};
+
+	seq_puts(s, "domain_on [pmd_name  status]\n");
+	seq_puts(s, "\tdev_on (dev_name usage_count, disable, status)\n");
+	seq_puts(s, "------------------------------------------------------\n");
+
+	for (; pdst->pd != NULL; pdst++) {
+		int i;
+		struct generic_pm_domain *pd = pdst->pd;
+
+		if (IS_ERR_OR_NULL(pd)) {
+			seq_printf(s, "pd: 0x%p\n", pd);
+			continue;
+		}
+
+#if CLKDBG_GENPD_STATUS_5_10
+		seq_printf(s, "%c [%-9s %11s]\n",
+			(pdst->status == GENPD_STATE_ON) ? '+' : '-',
+			pd->name, gpd_status_name[pdst->status]);
+#else
+		seq_printf(s, "%c [%-9s %11s]\n",
+			(pdst->status == GPD_STATE_ACTIVE) ? '+' : '-',
+			pd->name, gpd_status_name[pdst->status]);
+#endif
+
+		for (i = 0; i < pdst->num_dev_state; i++) {
+			struct genpd_dev_state *devst = &pdst->dev_state[i];
+			struct device *dev = devst->dev;
+
+			seq_printf(s, "\t%c (%-19s %3d, %d, %10s)\n",
+				devst->active ? '+' : '-',
+				dev_name(dev),
+				atomic_read(&dev->power.usage_count),
+				devst->disable_depth,
+				prm_status_name[devst->runtime_status]);
+		}
+	}
+}
+
+static void seq_print_all_genpd(struct seq_file *s)
+{
+	static struct genpd_dev_state devst[TOTAL_DEV_STATE];
+	static struct genpd_state pdst[TOTAL_PD_NUM];
+
+	save_all_genpd_state(pdst, devst);
+	dump_genpd_state(pdst, s);
+}
+
+static int clkdbg_dump_genpd(struct seq_file *s, void *v)
+{
+	seq_print_all_genpd(s);
+
+	return 0;
+}
+
+static int clkdbg_pm_runtime_enable(struct seq_file *s, void *v)
+{
+	char cmd[sizeof(last_cmd)];
+	char *c = cmd;
+	char *ign;
+	char *dev_name;
+	struct device *dev;
+
+	strncpy(cmd, last_cmd, sizeof(cmd));
+	cmd[sizeof(cmd) - 1UL] = '\0';
+
+	ign = strsep(&c, " ");
+	dev_name = strsep(&c, " ");
+
+	if (dev_name == NULL)
+		return 0;
+
+	seq_printf(s, "pm_runtime_enable(%s): ", dev_name);
+
+	dev = dev_from_name(dev_name);
+	if (dev != NULL) {
+		pm_runtime_enable(dev);
+		seq_puts(s, "\n");
+	} else {
+		seq_puts(s, "NULL\n");
+	}
+
+	return 0;
+}
+
+static int clkdbg_pm_runtime_disable(struct seq_file *s, void *v)
+{
+	char cmd[sizeof(last_cmd)];
+	char *c = cmd;
+	char *ign;
+	char *dev_name;
+	struct device *dev;
+
+	strncpy(cmd, last_cmd, sizeof(cmd));
+	cmd[sizeof(cmd) - 1UL] = '\0';
+
+	ign = strsep(&c, " ");
+	dev_name = strsep(&c, " ");
+
+	if (dev_name == NULL)
+		return 0;
+
+	seq_printf(s, "pm_runtime_disable(%s): ", dev_name);
+
+	dev = dev_from_name(dev_name);
+	if (dev != NULL) {
+		pm_runtime_disable(dev);
+		seq_puts(s, "\n");
+	} else {
+		seq_puts(s, "NULL\n");
+	}
+
+	return 0;
+}
+
+static int clkdbg_pm_runtime_get_sync(struct seq_file *s, void *v)
+{
+	char cmd[sizeof(last_cmd)];
+	char *c = cmd;
+	char *ign;
+	char *dev_name;
+	struct device *dev;
+
+	strncpy(cmd, last_cmd, sizeof(cmd));
+	cmd[sizeof(cmd) - 1UL] = '\0';
+
+	ign = strsep(&c, " ");
+	dev_name = strsep(&c, " ");
+
+	if (dev_name == NULL)
+		return 0;
+
+	seq_printf(s, "pm_runtime_get_sync(%s): ", dev_name);
+
+	dev = dev_from_name(dev_name);
+	if (dev != NULL) {
+		int r = pm_runtime_get_sync(dev);
+
+		seq_printf(s, "%d\n", r);
+	} else {
+		seq_puts(s, "NULL\n");
+	}
+
+	return 0;
+}
+
+static int clkdbg_pm_runtime_put_sync(struct seq_file *s, void *v)
+{
+	char cmd[sizeof(last_cmd)];
+	char *c = cmd;
+	char *ign;
+	char *dev_name;
+	struct device *dev;
+
+	strncpy(cmd, last_cmd, sizeof(cmd));
+	cmd[sizeof(cmd) - 1UL] = '\0';
+
+	ign = strsep(&c, " ");
+	dev_name = strsep(&c, " ");
+
+	if (dev_name == NULL)
+		return 0;
+
+	seq_printf(s, "pm_runtime_put_sync(%s): ", dev_name);
+
+	dev = dev_from_name(dev_name);
+	if (dev != NULL) {
+		int r = pm_runtime_put_sync(dev);
+
+		seq_printf(s, "%d\n", r);
+	} else {
+		seq_puts(s, "NULL\n");
+	}
+
+	return 0;
+}
+
+static int genpd_op(const char *gpd_op_name, struct seq_file *s)
+{
+	char cmd[sizeof(last_cmd)];
+	char *c = cmd;
+	char *ign;
+	char *pd_name;
+	struct generic_pm_domain *genpd;
+	int gpd_op_id;
+	int (*gpd_op)(struct generic_pm_domain *genpd);
+	int r = 0;
+
+	strncpy(cmd, last_cmd, sizeof(cmd));
+	cmd[sizeof(cmd) - 1UL] = '\0';
+
+	ign = strsep(&c, " ");
+	pd_name = strsep(&c, " ");
+
+	if (pd_name == NULL)
+		return 0;
+
+	if (strcmp(gpd_op_name, "power_on") == 0)
+		gpd_op_id = 1;
+	else
+		gpd_op_id = 0;
+
+	if (strcmp(pd_name, "all") == 0) {
+		struct generic_pm_domain **pds = get_all_genpd();
+
+		for (; pds != NULL && *pds != NULL; pds++) {
+			genpd = *pds;
+
+			if (IS_ERR_OR_NULL(genpd))
+				continue;
+
+			gpd_op = (gpd_op_id == 1) ?
+					genpd->power_on : genpd->power_off;
+			r |= gpd_op(genpd);
+		}
+
+		seq_printf(s, "%s(%s): %d\n", gpd_op_name, pd_name, r);
+
+		return 0;
+	}
+
+	genpd = genpd_from_name(pd_name);
+	if (genpd != NULL) {
+		gpd_op = (gpd_op_id == 1) ? genpd->power_on : genpd->power_off;
+		r = gpd_op(genpd);
+
+		seq_printf(s, "%s(%s): %d\n", gpd_op_name, pd_name, r);
+	} else {
+		seq_printf(s, "genpd_from_name(%s): NULL\n", pd_name);
+	}
+
+	return 0;
+}
+
+static int clkdbg_pwr_on(struct seq_file *s, void *v)
+{
+	return genpd_op("power_on", s);
+}
+
+static int clkdbg_pwr_off(struct seq_file *s, void *v)
+{
+	return genpd_op("power_off", s);
+}
+
+/*
+ * clkdbg reg_pdrv/runeg_pdrv support
+ */
+
+static int clkdbg_probe(struct platform_device *pdev)
+{
+	int r;
+
+	pm_runtime_enable(&pdev->dev);
+	r = pm_runtime_get_sync(&pdev->dev);
+	if (r != 0)
+		pr_warn("%s(): pm_runtime_get_sync(%d)\n", __func__, r);
+
+	return r;
+}
+
+static int clkdbg_remove(struct platform_device *pdev)
+{
+	int r;
+
+	r = pm_runtime_put_sync(&pdev->dev);
+	if (r != 0)
+		pr_warn("%s(): pm_runtime_put_sync(%d)\n", __func__, r);
+	pm_runtime_disable(&pdev->dev);
+
+	return r;
+}
+
+struct pdev_drv {
+	struct platform_driver pdrv;
+	struct platform_device *pdev;
+	struct generic_pm_domain *genpd;
+};
+
+#define PDEV_DRV(_name) {				\
+	.pdrv = {					\
+		.probe		= clkdbg_probe,		\
+		.remove		= clkdbg_remove,	\
+		.driver		= {			\
+			.name	= _name,		\
+		},					\
+	},						\
+}
+
+static struct pdev_drv pderv[] = {
+	PDEV_DRV("clkdbg-pd0"),
+	PDEV_DRV("clkdbg-pd1"),
+	PDEV_DRV("clkdbg-pd2"),
+	PDEV_DRV("clkdbg-pd3"),
+	PDEV_DRV("clkdbg-pd4"),
+	PDEV_DRV("clkdbg-pd5"),
+	PDEV_DRV("clkdbg-pd6"),
+	PDEV_DRV("clkdbg-pd7"),
+	PDEV_DRV("clkdbg-pd8"),
+	PDEV_DRV("clkdbg-pd9"),
+	PDEV_DRV("clkdbg-pd10"),
+	PDEV_DRV("clkdbg-pd11"),
+	PDEV_DRV("clkdbg-pd12"),
+	PDEV_DRV("clkdbg-pd13"),
+	PDEV_DRV("clkdbg-pd14"),
+	PDEV_DRV("clkdbg-pd15"),
+	PDEV_DRV("clkdbg-pd16"),
+	PDEV_DRV("clkdbg-pd17"),
+	PDEV_DRV("clkdbg-pd18"),
+	PDEV_DRV("clkdbg-pd19"),
+	PDEV_DRV("clkdbg-pd20"),
+	PDEV_DRV("clkdbg-pd21"),
+	PDEV_DRV("clkdbg-pd22"),
+	PDEV_DRV("clkdbg-pd23"),
+	PDEV_DRV("clkdbg-pd24"),
+	PDEV_DRV("clkdbg-pd25"),
+	PDEV_DRV("clkdbg-pd26"),
+	PDEV_DRV("clkdbg-pd27"),
+	PDEV_DRV("clkdbg-pd28"),
+	PDEV_DRV("clkdbg-pd29"),
+	PDEV_DRV("clkdbg-pd30"),
+	PDEV_DRV("clkdbg-pd31"),
+	PDEV_DRV("clkdbg-pd32"),
+	PDEV_DRV("clkdbg-pd33"),
+	PDEV_DRV("clkdbg-pd34"),
+	PDEV_DRV("clkdbg-pd35"),
+	PDEV_DRV("clkdbg-pd36"),
+	PDEV_DRV("clkdbg-pd37"),
+	PDEV_DRV("clkdbg-pd38"),
+	PDEV_DRV("clkdbg-pd39"),
+};
+
+static void reg_pdev_drv(const char *pdname, struct seq_file *s)
+{
+	size_t i;
+	struct generic_pm_domain **pds = get_all_genpd();
+	bool allpd = (pdname == NULL || strcmp(pdname, "all") == 0);
+	int r;
+
+	for (i = 0; i < ARRAY_SIZE(pderv) && pds != NULL && *pds != NULL; i++, pds++) {
+		const char *name = pderv[i].pdrv.driver.name;
+		struct generic_pm_domain *pd = *pds;
+
+		if (IS_ERR_OR_NULL(pd) || pderv[i].genpd != NULL)
+			continue;
+
+		if (!allpd && strcmp(pdname, pd->name) != 0)
+			continue;
+
+		pderv[i].genpd = pd;
+
+		pderv[i].pdev = platform_device_alloc(name, 0);
+		r = platform_device_add(pderv[i].pdev);
+		if (r != 0 && s != NULL)
+			seq_printf(s, "%s(): platform_device_add(%d)\n",
+						__func__, r);
+
+		r = pm_genpd_add_device(pd, &pderv[i].pdev->dev);
+		if (r != 0 && s != NULL)
+			seq_printf(s, "%s(): pm_genpd_add_device(%d)\n",
+						__func__, r);
+		r = platform_driver_register(&pderv[i].pdrv);
+		if (r != 0 && s != NULL)
+			seq_printf(s, "%s(): platform_driver_register(%d)\n",
+						__func__, r);
+
+		if (s != NULL)
+			seq_printf(s, "%s --> %s\n", name, pd->name);
+	}
+}
+
+static void unreg_pdev_drv(const char *pdname, struct seq_file *s)
+{
+	ssize_t i;
+	bool allpd = (pdname == NULL || strcmp(pdname, "all") == 0);
+	int r;
+
+	for (i = ARRAY_SIZE(pderv) - 1L; i >= 0L; i--) {
+		const char *name = pderv[i].pdrv.driver.name;
+		struct generic_pm_domain *pd = pderv[i].genpd;
+
+		if (IS_ERR_OR_NULL(pd))
+			continue;
+
+		if (!allpd && strcmp(pdname, pd->name) != 0)
+			continue;
+
+#if CLKDBG_DROP_GENPD_AS_IN_PARAM
+		r = pm_genpd_remove_device(&pderv[i].pdev->dev);
+#else
+		r = pm_genpd_remove_device(pd, &pderv[i].pdev->dev);
+#endif
+		if (r != 0 && s != NULL)
+			seq_printf(s, "%s(): pm_genpd_remove_device(%d)\n",
+						__func__, r);
+
+		platform_driver_unregister(&pderv[i].pdrv);
+		platform_device_unregister(pderv[i].pdev);
+
+		pderv[i].genpd = NULL;
+
+		if (s != NULL)
+			seq_printf(s, "%s -x- %s\n", name, pd->name);
+	}
+}
+
+static int clkdbg_reg_pdrv(struct seq_file *s, void *v)
+{
+	char cmd[sizeof(last_cmd)];
+	char *c = cmd;
+	char *ign;
+	char *pd_name;
+
+	strncpy(cmd, last_cmd, sizeof(cmd));
+	cmd[sizeof(cmd) - 1UL] = '\0';
+
+	ign = strsep(&c, " ");
+	pd_name = strsep(&c, " ");
+
+	if (pd_name == NULL)
+		return 0;
+
+	reg_pdev_drv(pd_name, s);
+
+	return 0;
+}
+
+static int clkdbg_unreg_pdrv(struct seq_file *s, void *v)
+{
+	char cmd[sizeof(last_cmd)];
+	char *c = cmd;
+	char *ign;
+	char *pd_name;
+
+	strncpy(cmd, last_cmd, sizeof(cmd));
+	cmd[sizeof(cmd) - 1UL] = '\0';
+
+	ign = strsep(&c, " ");
+	pd_name = strsep(&c, " ");
+
+	if (pd_name == NULL)
+		return 0;
+
+	unreg_pdev_drv(pd_name, s);
+
+	return 0;
+}
+
+#endif /* CLKDBG_PM_DOMAIN */
+
+void reg_pdrv(const char *pdname)
+{
+#if CLKDBG_PM_DOMAIN
+	reg_pdev_drv(pdname, NULL);
+#endif
+}
+
+void unreg_pdrv(const char *pdname)
+{
+#if CLKDBG_PM_DOMAIN
+	unreg_pdev_drv(pdname, NULL);
+#endif
+}
+
+/*
+ * Suspend / resume handler
+ */
+
+#include <linux/suspend.h>
+#include <linux/syscore_ops.h>
+
+struct provider_clk_state {
+	struct provider_clk *pvdck;
+	bool prepared;
+	bool enabled;
+	unsigned int enable_count;
+	unsigned long rate;
+	struct clk *parent;
+};
+
+struct save_point {
+	u32 pwr_status[PWR_STA_GROUP_NR];
+	struct provider_clk_state clks_states[TOTAL_CLK_NUM];
+#if CLKDBG_PM_DOMAIN
+	struct genpd_state genpd_states[TOTAL_PD_NUM];
+	struct genpd_dev_state genpd_dev_states[100];
+#endif
+};
+
+static struct save_point save_point_1;
+static struct save_point save_point_2;
+static struct save_point save_point_3;
+
+static void save_pwr_status(u32 *pwr_status)
+{
+	if (clkdbg_ops->get_all_pwr_status) {
+		u32 *val = read_all_pwr_status();
+		int i;
+
+		for (i = 0; i < PWR_STA_GROUP_NR; i++)
+			pwr_status[i] = val[i];
+	} else
+		*pwr_status = read_spm_pwr_status();
+}
+
+static void save_all_clks_state(struct provider_clk_state *clks_states,
+				u32 *pwr_status)
+{
+	struct provider_clk *pvdck = get_all_provider_clks();
+	struct provider_clk_state *st = clks_states;
+
+	for (; pvdck->ck != NULL; pvdck++, st++) {
+		struct clk *c = pvdck->ck;
+		struct clk_hw *c_hw = __clk_get_hw(c);
+
+		st->pvdck = pvdck;
+		st->prepared = clk_hw_is_prepared(c_hw);
+		st->enabled = clk_hw_pwr_is_on(c_hw, pwr_status[pvdck->pwr_sta_group],
+							pvdck);
+		st->enable_count = __clk_get_enable_count(c);
+		st->rate = clk_hw_get_rate(c_hw);
+		st->parent = IS_ERR_OR_NULL(c) ? NULL : clk_get_parent(c);
+	}
+}
+
+static void show_provider_clk_state(struct provider_clk_state *st)
+{
+	struct provider_clk *pvdck = st->pvdck;
+	struct clk_hw *c_hw = __clk_get_hw(pvdck->ck);
+
+	pr_info("[%10s: %-17s: %3s, %3d, %3d, %10ld, %17s]\n",
+		pvdck->provider_name != NULL ? pvdck->provider_name : "/ ",
+		clk_hw_get_name(c_hw),
+		st->enabled ? "ON" : "off",
+		st->prepared,
+		st->enable_count,
+		st->rate,
+		st->parent != NULL ?
+			clk_hw_get_name(__clk_get_hw(st->parent)) : "- ");
+	mdelay(20);
+}
+
+static void dump_provider_clk_state(struct provider_clk_state *st,
+					struct seq_file *s)
+{
+	struct provider_clk *pvdck = st->pvdck;
+	struct clk_hw *c_hw = __clk_get_hw(pvdck->ck);
+
+	seq_printf(s, "[%10s: %-17s: %3s, %3d, %3d, %10ld, %17s]\n",
+		pvdck->provider_name != NULL ? pvdck->provider_name : "/ ",
+		clk_hw_get_name(c_hw),
+		st->enabled ? "ON" : "off",
+		st->prepared,
+		st->enable_count,
+		st->rate,
+		st->parent != NULL ?
+			clk_hw_get_name(__clk_get_hw(st->parent)) : "- ");
+}
+
+static void show_save_point(struct save_point *sp)
+{
+	struct provider_clk_state *st = sp->clks_states;
+
+	for (; st->pvdck != NULL; st++)
+		show_provider_clk_state(st);
+
+	pr_info("\n");
+	show_pwr_status(sp->pwr_status);
+
+#if CLKDBG_PM_DOMAIN
+	pr_info("\n");
+	show_genpd_state(sp->genpd_states);
+#endif
+}
+
+static void store_save_point(struct save_point *sp)
+{
+	save_pwr_status(sp->pwr_status);
+	save_all_clks_state(sp->clks_states, sp->pwr_status);
+
+#if CLKDBG_PM_DOMAIN
+	save_all_genpd_state(sp->genpd_states, sp->genpd_dev_states);
+#endif
+
+	if (has_clkdbg_flag(CLKDBG_EN_LOG_SAVE_POINTS))
+		show_save_point(sp);
+}
+
+static void dump_save_point(struct save_point *sp, struct seq_file *s)
+{
+	struct provider_clk_state *st = sp->clks_states;
+
+	for (; st->pvdck != NULL; st++)
+		dump_provider_clk_state(st, s);
+
+	seq_puts(s, "\n");
+	dump_pwr_status(sp->pwr_status, s);
+
+#if CLKDBG_PM_DOMAIN
+	seq_puts(s, "\n");
+	dump_genpd_state(sp->genpd_states, s);
+#endif
+}
+
+static int clkdbg_dump_suspend_clks_1(struct seq_file *s, void *v)
+{
+	dump_save_point(&save_point_1, s);
+	return 0;
+}
+
+static int clkdbg_dump_suspend_clks_2(struct seq_file *s, void *v)
+{
+	dump_save_point(&save_point_2, s);
+	return 0;
+}
+
+static int clkdbg_dump_suspend_clks_3(struct seq_file *s, void *v)
+{
+	dump_save_point(&save_point_3, s);
+	return 0;
+}
+
+static int clkdbg_dump_suspend_clks(struct seq_file *s, void *v)
+{
+	if (has_clkdbg_flag(CLKDBG_EN_SUSPEND_SAVE_3) &&
+			save_point_3.pwr_status[0] != 0U)
+		return clkdbg_dump_suspend_clks_3(s, v);
+	else if (has_clkdbg_flag(CLKDBG_EN_SUSPEND_SAVE_2) &&
+			save_point_2.pwr_status[0] != 0U)
+		return clkdbg_dump_suspend_clks_2(s, v);
+	else if (has_clkdbg_flag(CLKDBG_EN_SUSPEND_SAVE_1) &&
+			save_point_1.pwr_status[0] != 0U)
+		return clkdbg_dump_suspend_clks_1(s, v);
+
+	return 0;
+}
+
+static int clkdbg_pm_event_handler(struct notifier_block *nb,
+					unsigned long event, void *ptr)
+{
+	switch (event) {
+	case PM_HIBERNATION_PREPARE:
+	case PM_SUSPEND_PREPARE:
+		/* suspend */
+		if (has_clkdbg_flag(CLKDBG_EN_SUSPEND_SAVE_1)) {
+			store_save_point(&save_point_1);
+			return NOTIFY_OK;
+		}
+
+		break;
+	case PM_POST_HIBERNATION:
+	case PM_POST_SUSPEND:
+		/* resume */
+		break;
+	}
+
+	return NOTIFY_DONE;
+}
+
+static struct notifier_block clkdbg_pm_notifier = {
+	.notifier_call = clkdbg_pm_event_handler,
+};
+
+static int clkdbg_syscore_suspend(void)
+{
+	if (has_clkdbg_flag(CLKDBG_EN_SUSPEND_SAVE_2))
+		store_save_point(&save_point_2);
+
+	return 0;
+}
+
+static void clkdbg_syscore_resume(void)
+{
+}
+
+static struct syscore_ops clkdbg_syscore_ops = {
+	.suspend = clkdbg_syscore_suspend,
+	.resume = clkdbg_syscore_resume,
+};
+
+static int __init clkdbg_pm_init(void)
+{
+	int r;
+
+	register_syscore_ops(&clkdbg_syscore_ops);
+	r = register_pm_notifier(&clkdbg_pm_notifier);
+	if (r != 0)
+		pr_warn("%s(): register_pm_notifier(%d)\n", __func__, r);
+
+	return r;
+}
+subsys_initcall(clkdbg_pm_init);
+
+static int clkdbg_suspend_ops_valid(suspend_state_t state)
+{
+	return state == PM_SUSPEND_MEM ? 1 : 0;
+}
+
+static int clkdbg_suspend_ops_begin(suspend_state_t state)
+{
+	return 0;
+}
+
+static int clkdbg_suspend_ops_prepare(void)
+{
+	return 0;
+}
+
+static int clkdbg_suspend_ops_enter(suspend_state_t state)
+{
+	if (has_clkdbg_flag(CLKDBG_EN_SUSPEND_SAVE_3))
+		store_save_point(&save_point_3);
+
+	return 0;
+}
+
+static void clkdbg_suspend_ops_finish(void)
+{
+}
+
+static void clkdbg_suspend_ops_end(void)
+{
+}
+
+static const struct platform_suspend_ops clkdbg_suspend_ops = {
+	.valid = clkdbg_suspend_ops_valid,
+	.begin = clkdbg_suspend_ops_begin,
+	.prepare = clkdbg_suspend_ops_prepare,
+	.enter = clkdbg_suspend_ops_enter,
+	.finish = clkdbg_suspend_ops_finish,
+	.end = clkdbg_suspend_ops_end,
+};
+
+static int clkdbg_suspend_set_ops(struct seq_file *s, void *v)
+{
+	suspend_set_ops(&clkdbg_suspend_ops);
+
+	return 0;
+}
+
+static const struct cmd_fn *custom_cmds;
+
+void set_custom_cmds(const struct cmd_fn *cmds)
+{
+	custom_cmds = cmds;
+}
+
+static int clkdbg_cmds(struct seq_file *s, void *v);
+
+static const struct cmd_fn common_cmds[] = {
+	CMDFN("dump_regs", seq_print_regs),
+	CMDFN("dump_regs2", clkdbg_dump_regs2),
+	CMDFN("dump_state", clkdbg_dump_state_all),
+	CMDFN("dump_clks", clkdbg_dump_provider_clks),
+	CMDFN("dump_muxes", clkdbg_dump_muxes),
+	CMDFN("fmeter", seq_print_fmeter_all),
+	CMDFN("pwr_status", clkdbg_pwr_status),
+	CMDFN("prepare", clkdbg_prepare),
+	CMDFN("unprepare", clkdbg_unprepare),
+	CMDFN("enable", clkdbg_enable),
+	CMDFN("disable", clkdbg_disable),
+	CMDFN("prepare_enable", clkdbg_prepare_enable),
+	CMDFN("disable_unprepare", clkdbg_disable_unprepare),
+	CMDFN("prepare_enable_provider", clkdbg_prepare_enable_provider),
+	CMDFN("disable_unprepare_provider", clkdbg_disable_unprepare_provider),
+	CMDFN("set_parent", clkdbg_set_parent),
+	CMDFN("set_rate", clkdbg_set_rate),
+	CMDFN("reg_read", clkdbg_reg_read),
+	CMDFN("reg_write", clkdbg_reg_write),
+	CMDFN("reg_set", clkdbg_reg_set),
+	CMDFN("reg_clr", clkdbg_reg_clr),
+	CMDFN("show_flags", clkdbg_show_flags),
+	CMDFN("set_flag", clkdbg_set_flag),
+	CMDFN("clr_flag", clkdbg_clr_flag),
+#if CLKDBG_PM_DOMAIN
+	CMDFN("dump_genpd", clkdbg_dump_genpd),
+	CMDFN("pm_runtime_enable", clkdbg_pm_runtime_enable),
+	CMDFN("pm_runtime_disable", clkdbg_pm_runtime_disable),
+	CMDFN("pm_runtime_get_sync", clkdbg_pm_runtime_get_sync),
+	CMDFN("pm_runtime_put_sync", clkdbg_pm_runtime_put_sync),
+	CMDFN("pwr_on", clkdbg_pwr_on),
+	CMDFN("pwr_off", clkdbg_pwr_off),
+	CMDFN("reg_pdrv", clkdbg_reg_pdrv),
+	CMDFN("unreg_pdrv", clkdbg_unreg_pdrv),
+#endif /* CLKDBG_PM_DOMAIN */
+	CMDFN("suspend_set_ops", clkdbg_suspend_set_ops),
+	CMDFN("dump_suspend_clks", clkdbg_dump_suspend_clks),
+	CMDFN("dump_suspend_clks_1", clkdbg_dump_suspend_clks_1),
+	CMDFN("dump_suspend_clks_2", clkdbg_dump_suspend_clks_2),
+	CMDFN("dump_suspend_clks_3", clkdbg_dump_suspend_clks_3),
+	CMDFN("cmds", clkdbg_cmds),
+	{}
+};
+
+static int clkdbg_cmds(struct seq_file *s, void *v)
+{
+	const struct cmd_fn *cf;
+
+	for (cf = common_cmds; cf->cmd != NULL; cf++)
+		seq_printf(s, "%s\n", cf->cmd);
+
+	for (cf = custom_cmds; cf != NULL && cf->cmd != NULL; cf++)
+		seq_printf(s, "%s\n", cf->cmd);
+
+	seq_puts(s, "\n");
+
+	return 0;
+}
+
+static int clkdbg_show(struct seq_file *s, void *v)
+{
+	const struct cmd_fn *cf;
+	char cmd[sizeof(last_cmd)];
+
+	strncpy(cmd, last_cmd, sizeof(cmd));
+	cmd[sizeof(cmd) - 1UL] = '\0';
+
+	for (cf = custom_cmds; cf != NULL && cf->cmd != NULL; cf++) {
+		char *c = cmd;
+		char *token = strsep(&c, " ");
+
+		if (strcmp(cf->cmd, token) == 0)
+			return cf->fn(s, v);
+	}
+
+	for (cf = common_cmds; cf->cmd != NULL; cf++) {
+		char *c = cmd;
+		char *token = strsep(&c, " ");
+
+		if (strcmp(cf->cmd, token) == 0)
+			return cf->fn(s, v);
+	}
+
+	return 0;
+}
+
+static int clkdbg_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, clkdbg_show, NULL);
+}
+
+static ssize_t clkdbg_write(
+		struct file *file,
+		const char __user *buffer,
+		size_t count,
+		loff_t *data)
+{
+	size_t len = 0;
+
+	len = (count < (sizeof(last_cmd) - 1UL)) ?
+				count : (sizeof(last_cmd) - 1UL);
+	if (copy_from_user(last_cmd, buffer, len) != 0UL)
+		return 0;
+
+	last_cmd[len] = '\0';
+
+	if (last_cmd[len - 1UL] == '\n')
+		last_cmd[len - 1UL] = '\0';
+
+	return (ssize_t)len;
+}
+
+static const struct proc_ops clkdbg_fops = {
+	.proc_open	= clkdbg_open,
+	.proc_read	= seq_read,
+	.proc_write	= clkdbg_write,
+	.proc_lseek	= seq_lseek,
+	.proc_release	= single_release,
+};
+
+/*
+ * init functions
+ */
+
+static int __init clkdbg_debug_init(void)
+{
+	struct proc_dir_entry *entry;
+
+	entry = proc_create("clkdbg", 0644, NULL, &clkdbg_fops);
+	if (entry == 0)
+		return -ENOMEM;
+
+	set_clkdbg_flag(CLKDBG_EN_SUSPEND_SAVE_3);
+
+	return 0;
+}
+module_init(clkdbg_debug_init);
diff --git a/drivers/clk/mediatek/clkdbg.h b/drivers/clk/mediatek/clkdbg.h
new file mode 100644
index 0000000000000000000000000000000000000000..9fec97f9b9f87b0eac50067f75414b1ea248a659
--- /dev/null
+++ b/drivers/clk/mediatek/clkdbg.h
@@ -0,0 +1,88 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2020 MediaTek Inc.
+ * Author: Weiyi Lu <weiyi.lu@mediatek.com>
+ */
+
+struct seq_file;
+
+#define clk_readl(addr)		readl(addr)
+#define clk_writel(addr, val)	\
+	do { writel(val, addr); wmb(); } while (0) /* sync write */
+#define clk_setl(addr, val)	clk_writel(addr, clk_readl(addr) | (val))
+#define clk_clrl(addr, val)	clk_writel(addr, clk_readl(addr) & ~(val))
+
+enum FMETER_TYPE {
+	FT_NULL,
+	ABIST,
+	CKGEN
+};
+
+struct fmeter_clk {
+	enum FMETER_TYPE type;
+	u32 id;
+	const char *name;
+};
+
+struct regbase {
+	u32 phys;
+	void __iomem *virt;
+	const char *name;
+};
+
+struct regname {
+	struct regbase *base;
+	u32 ofs;
+	const char *name;
+};
+
+#define ADDR(rn)	(rn->base->virt + rn->ofs)
+#define PHYSADDR(rn)	(rn->base->phys + rn->ofs)
+
+struct cmd_fn {
+	const char	*cmd;
+	int (*fn)(struct seq_file *s, void *v);
+};
+
+#define CMDFN(_cmd, _fn) {	\
+	.cmd = _cmd,		\
+	.fn = _fn,		\
+}
+
+#define PWR_STA_GROUP_NR	2
+struct provider_clk {
+	const char *provider_name;
+	u32 idx;
+	struct clk *ck;
+	struct clk *bus_ck;
+	u32 pwr_mask;
+	u32 pwr_sta_group;
+};
+
+struct clkdbg_ops {
+	const struct fmeter_clk *(*get_all_fmeter_clks)(void);
+	void *(*prepare_fmeter)(void);
+	void (*unprepare_fmeter)(void *data);
+	u32 (*fmeter_freq)(const struct fmeter_clk *fclk);
+	const struct regname *(*get_all_regnames)(void);
+	const char * const *(*get_all_clk_names)(void);
+	const char * const *(*get_pwr_names)(void);
+	void (*setup_provider_clk)(struct provider_clk *pvdck);
+	u32 (*get_spm_pwr_status)(void);
+	u32 *(*get_all_pwr_status)(void);
+	struct device_node *(*get_power_controller)(void);
+};
+
+void set_clkdbg_ops(const struct clkdbg_ops *ops);
+void set_custom_cmds(const struct cmd_fn *cmds);
+
+struct provider_clk *get_all_provider_clks(void);
+const char *get_last_cmd(void);
+
+void reg_pdrv(const char *pdname);
+void unreg_pdrv(const char *pdname);
+void prepare_enable_provider(const char *pvd);
+void disable_unprepare_provider(const char *pvd);
+
+void print_regs(void);
+void print_fmeter_all(void);
diff --git a/drivers/cpufreq/Kconfig.arm b/drivers/cpufreq/Kconfig.arm
index 1f73fa75b1a0519a6b76e5825e5f187b94d46fa6..5f140f927615401a2bf0f0f071b4d1068df3b0cc 100644
--- a/drivers/cpufreq/Kconfig.arm
+++ b/drivers/cpufreq/Kconfig.arm
@@ -123,6 +123,18 @@ config ARM_MEDIATEK_CPUFREQ
 	help
 	  This adds the CPUFreq driver support for MediaTek SoCs.
 
+config ARM_MEDIATEK_CPUFREQ_HW
+	tristate "MediaTek CPUFreq HW driver"
+	depends on ARCH_MEDIATEK || COMPILE_TEST
+	default m
+	help
+	  Support for the CPUFreq HW driver.
+	  Some MediaTek chipsets have a HW engine to offload the steps
+	  necessary for changing the frequency of the CPUs. Firmware loaded
+	  in this engine exposes a programming interface to the OS.
+	  The driver implements the cpufreq interface for this HW engine.
+	  Say Y if you want to support CPUFreq HW.
+
 config ARM_OMAP2PLUS_CPUFREQ
 	bool "TI OMAP2+"
 	depends on ARCH_OMAP2PLUS
diff --git a/drivers/cpufreq/Makefile b/drivers/cpufreq/Makefile
index 1502f84910ea6518bae579202f33383a86289d48..2dc5b6085b73c5292bb69927bccb3147a53ddd47 100644
--- a/drivers/cpufreq/Makefile
+++ b/drivers/cpufreq/Makefile
@@ -63,6 +63,7 @@ obj-$(CONFIG_ARM_IMX6Q_CPUFREQ)		+= imx6q-cpufreq.o
 obj-$(CONFIG_ARM_IMX_CPUFREQ_DT)	+= imx-cpufreq-dt.o
 obj-$(CONFIG_ARM_KIRKWOOD_CPUFREQ)	+= kirkwood-cpufreq.o
 obj-$(CONFIG_ARM_MEDIATEK_CPUFREQ)	+= mediatek-cpufreq.o
+obj-$(CONFIG_ARM_MEDIATEK_CPUFREQ_HW)	+= mediatek-cpufreq-hw.o
 obj-$(CONFIG_MACH_MVEBU_V7)		+= mvebu-cpufreq.o
 obj-$(CONFIG_ARM_OMAP2PLUS_CPUFREQ)	+= omap-cpufreq.o
 obj-$(CONFIG_ARM_PXA2xx_CPUFREQ)	+= pxa2xx-cpufreq.o
diff --git a/drivers/cpufreq/mediatek-cpufreq-hw.c b/drivers/cpufreq/mediatek-cpufreq-hw.c
new file mode 100644
index 0000000000000000000000000000000000000000..6f3a4618735d55a512dba3261c82a5dc304242d2
--- /dev/null
+++ b/drivers/cpufreq/mediatek-cpufreq-hw.c
@@ -0,0 +1,370 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2020 MediaTek Inc.
+ */
+
+#include <linux/bitfield.h>
+#include <linux/cpufreq.h>
+#include <linux/energy_model.h>
+#include <linux/init.h>
+#include <linux/iopoll.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of_address.h>
+#include <linux/of_platform.h>
+#include <linux/pm_qos.h>
+#include <linux/slab.h>
+
+#define LUT_MAX_ENTRIES			32U
+#define LUT_FREQ			GENMASK(11, 0)
+#define LUT_ROW_SIZE			0x4
+#define CPUFREQ_HW_STATUS		BIT(0)
+#define SVS_HW_STATUS			BIT(1)
+#define POLL_USEC			1000
+#define TIMEOUT_USEC			300000
+
+enum {
+	REG_FREQ_LUT_TABLE,
+	REG_FREQ_ENABLE,
+	REG_FREQ_PERF_STATE,
+	REG_FREQ_HW_STATE,
+	REG_EM_POWER_TBL,
+	REG_FREQ_LATENCY,
+
+	REG_ARRAY_SIZE,
+};
+
+struct cpufreq_mtk {
+	struct cpufreq_frequency_table *table;
+	void __iomem *reg_bases[REG_ARRAY_SIZE];
+	int nr_opp;
+	cpumask_t related_cpus;
+};
+
+static const u16 cpufreq_mtk_offsets[REG_ARRAY_SIZE] = {
+	[REG_FREQ_LUT_TABLE]	= 0x0,
+	[REG_FREQ_ENABLE]	= 0x84,
+	[REG_FREQ_PERF_STATE]	= 0x88,
+	[REG_FREQ_HW_STATE]	= 0x8c,
+	[REG_EM_POWER_TBL]	= 0x90,
+	[REG_FREQ_LATENCY]	= 0x110,
+};
+
+static struct cpufreq_mtk *mtk_freq_domain_map[NR_CPUS];
+
+static int __maybe_unused
+mtk_cpufreq_get_cpu_power(unsigned long *mW,
+			  unsigned long *KHz, struct device *cpu_dev)
+{
+	struct cpufreq_mtk *c = mtk_freq_domain_map[cpu_dev->id];
+	int i;
+
+	for (i = 0; i < c->nr_opp; i++) {
+		if (c->table[i].frequency < *KHz)
+			break;
+	}
+	i--;
+
+	*KHz = c->table[i].frequency;
+	*mW = readl_relaxed(c->reg_bases[REG_EM_POWER_TBL] +
+			    i * LUT_ROW_SIZE) / 1000;
+
+	return 0;
+}
+
+static int mtk_cpufreq_hw_target_index(struct cpufreq_policy *policy,
+				       unsigned int index)
+{
+	struct cpufreq_mtk *c = policy->driver_data;
+
+	writel_relaxed(index, c->reg_bases[REG_FREQ_PERF_STATE]);
+
+	return 0;
+}
+
+static unsigned int mtk_cpufreq_hw_get(unsigned int cpu)
+{
+	struct cpufreq_mtk *c;
+	unsigned int index;
+
+	c = mtk_freq_domain_map[cpu];
+
+	index = readl_relaxed(c->reg_bases[REG_FREQ_PERF_STATE]);
+	index = min(index, LUT_MAX_ENTRIES - 1);
+
+	return c->table[index].frequency;
+}
+
+static unsigned int mtk_cpufreq_hw_fast_switch(struct cpufreq_policy *policy,
+					       unsigned int target_freq)
+{
+	struct cpufreq_mtk *c = policy->driver_data;
+	unsigned int index;
+
+	index = cpufreq_table_find_index_dl(policy, target_freq);
+
+	writel_relaxed(index, c->reg_bases[REG_FREQ_PERF_STATE]);
+
+	return policy->freq_table[index].frequency;
+}
+
+static int mtk_cpufreq_hw_cpu_init(struct cpufreq_policy *policy)
+{
+	struct cpufreq_mtk *c;
+	struct device *cpu_dev;
+	struct em_data_callback em_cb = EM_DATA_CB(mtk_cpufreq_get_cpu_power);
+	struct pm_qos_request *qos_request;
+	int sig, pwr_hw = CPUFREQ_HW_STATUS | SVS_HW_STATUS;
+	unsigned int latency;
+
+	qos_request = kzalloc(sizeof(*qos_request), GFP_KERNEL);
+	if (!qos_request)
+		return -ENOMEM;
+
+	cpu_dev = get_cpu_device(policy->cpu);
+	if (!cpu_dev) {
+		pr_err("failed to get cpu%d device\n", policy->cpu);
+		return -ENODEV;
+	}
+
+	c = mtk_freq_domain_map[policy->cpu];
+	if (!c) {
+		pr_err("No scaling support for CPU%d\n", policy->cpu);
+		return -ENODEV;
+	}
+
+	cpumask_copy(policy->cpus, &c->related_cpus);
+
+	policy->freq_table = c->table;
+	policy->driver_data = c;
+
+	latency = readl_relaxed(c->reg_bases[REG_FREQ_LATENCY]);
+	if (!latency)
+		latency = CPUFREQ_ETERNAL;
+
+	/* us convert to ns */
+	policy->cpuinfo.transition_latency = latency * 1000;
+
+	policy->fast_switch_possible = true;
+
+	/* Let CPUs leave idle-off state for SVS CPU initializing */
+	cpu_latency_qos_add_request(qos_request, 0);
+
+	/* HW should be in enabled state to proceed now */
+	writel_relaxed(0x1, c->reg_bases[REG_FREQ_ENABLE]);
+
+	if (readl_poll_timeout(c->reg_bases[REG_FREQ_HW_STATE], sig,
+			       (sig & pwr_hw) == pwr_hw, POLL_USEC,
+			       TIMEOUT_USEC)) {
+		if (!(sig & CPUFREQ_HW_STATUS)) {
+			pr_info("cpufreq hardware of CPU%d is not enabled\n",
+				policy->cpu);
+			return -ENODEV;
+		}
+
+		pr_info("SVS of CPU%d is not enabled\n", policy->cpu);
+	}
+
+	em_dev_register_perf_domain(cpu_dev, c->nr_opp, &em_cb, policy->cpus, true);
+
+	cpu_latency_qos_remove_request(qos_request);
+	kfree(qos_request);
+
+	return 0;
+}
+
+static int mtk_cpufreq_hw_cpu_exit(struct cpufreq_policy *policy)
+{
+	struct cpufreq_mtk *c;
+
+	c = mtk_freq_domain_map[policy->cpu];
+	if (!c) {
+		pr_err("No scaling support for CPU%d\n", policy->cpu);
+		return -ENODEV;
+	}
+
+	/* HW should be in paused state now */
+	writel_relaxed(0x0, c->reg_bases[REG_FREQ_ENABLE]);
+
+	return 0;
+}
+
+static struct cpufreq_driver cpufreq_mtk_hw_driver = {
+	.flags		= CPUFREQ_NEED_INITIAL_FREQ_CHECK |
+			  CPUFREQ_HAVE_GOVERNOR_PER_POLICY |
+			  CPUFREQ_IS_COOLING_DEV,
+	.verify		= cpufreq_generic_frequency_table_verify,
+	.target_index	= mtk_cpufreq_hw_target_index,
+	.get		= mtk_cpufreq_hw_get,
+	.init		= mtk_cpufreq_hw_cpu_init,
+	.exit		= mtk_cpufreq_hw_cpu_exit,
+	.fast_switch	= mtk_cpufreq_hw_fast_switch,
+	.name		= "mtk-cpufreq-hw",
+	.attr		= cpufreq_generic_attr,
+};
+
+static int mtk_cpu_create_freq_table(struct platform_device *pdev,
+				     struct cpufreq_mtk *c)
+{
+	struct device *dev = &pdev->dev;
+	void __iomem *base_table;
+	u32 data, i, freq, prev_freq = 0;
+
+	c->table = devm_kcalloc(dev, LUT_MAX_ENTRIES + 1,
+				sizeof(*c->table), GFP_KERNEL);
+	if (!c->table)
+		return -ENOMEM;
+
+	base_table = c->reg_bases[REG_FREQ_LUT_TABLE];
+
+	for (i = 0; i < LUT_MAX_ENTRIES; i++) {
+		data = readl_relaxed(base_table + (i * LUT_ROW_SIZE));
+		freq = FIELD_GET(LUT_FREQ, data) * 1000;
+
+		if (freq == prev_freq)
+			break;
+
+		c->table[i].frequency = freq;
+
+		dev_dbg(dev, "index=%d freq=%d\n",
+			i, c->table[i].frequency);
+
+		prev_freq = freq;
+	}
+
+	c->table[i].frequency = CPUFREQ_TABLE_END;
+	c->nr_opp = i;
+
+	return 0;
+}
+
+static int mtk_get_related_cpus(int index, struct cpufreq_mtk *c)
+{
+	struct device_node *cpu_np;
+	struct of_phandle_args args;
+	int cpu, ret;
+
+	for_each_possible_cpu(cpu) {
+		cpu_np = of_cpu_device_node_get(cpu);
+		if (!cpu_np)
+			continue;
+
+		ret = of_parse_phandle_with_args(cpu_np, "performance-domains",
+						 "#performance-domain-cells", 0,
+						 &args);
+		of_node_put(cpu_np);
+		if (ret < 0)
+			continue;
+
+		if (index == args.args[0]) {
+			cpumask_set_cpu(cpu, &c->related_cpus);
+			mtk_freq_domain_map[cpu] = c;
+		}
+	}
+
+	return 0;
+}
+
+static int mtk_cpu_resources_init(struct platform_device *pdev,
+				  unsigned int cpu, int index,
+				  const u16 *offsets)
+{
+	struct cpufreq_mtk *c;
+	struct device *dev = &pdev->dev;
+	int ret, i;
+	void __iomem *base;
+
+	if (mtk_freq_domain_map[cpu])
+		return 0;
+
+	c = devm_kzalloc(dev, sizeof(*c), GFP_KERNEL);
+	if (!c)
+		return -ENOMEM;
+
+	base = devm_platform_ioremap_resource(pdev, index);
+	if (IS_ERR(base))
+		return PTR_ERR(base);
+
+	for (i = REG_FREQ_LUT_TABLE; i < REG_ARRAY_SIZE; i++)
+		c->reg_bases[i] = base + offsets[i];
+
+	ret = mtk_get_related_cpus(index, c);
+	if (ret) {
+		dev_err(dev, "Domain-%d failed to get related CPUs\n", index);
+		return ret;
+	}
+
+	ret = mtk_cpu_create_freq_table(pdev, c);
+	if (ret) {
+		dev_err(dev, "Domain-%d failed to create freq table\n", index);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int mtk_cpufreq_hw_driver_probe(struct platform_device *pdev)
+{
+	struct device_node *cpu_np;
+	struct of_phandle_args args;
+	const u16 *offsets;
+	unsigned int cpu;
+	int ret;
+
+	offsets = of_device_get_match_data(&pdev->dev);
+	if (!offsets)
+		return -EINVAL;
+
+	for_each_possible_cpu(cpu) {
+		cpu_np = of_cpu_device_node_get(cpu);
+		if (!cpu_np) {
+			dev_err(&pdev->dev, "Failed to get cpu %d device\n",
+				cpu);
+			return -ENODEV;
+		}
+
+		ret = of_parse_phandle_with_args(cpu_np, "performance-domains",
+						 "#performance-domain-cells", 0,
+						 &args);
+		if (ret < 0)
+			return ret;
+
+		/* Get the bases of cpufreq for domains */
+		ret = mtk_cpu_resources_init(pdev, cpu, args.args[0], offsets);
+		if (ret) {
+			dev_err(&pdev->dev, "CPUFreq resource init failed\n");
+			return ret;
+		}
+	}
+
+	ret = cpufreq_register_driver(&cpufreq_mtk_hw_driver);
+	if (ret) {
+		dev_err(&pdev->dev, "CPUFreq HW driver failed to register\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+static int mtk_cpufreq_hw_driver_remove(struct platform_device *pdev)
+{
+	return cpufreq_unregister_driver(&cpufreq_mtk_hw_driver);
+}
+
+static const struct of_device_id mtk_cpufreq_hw_match[] = {
+	{ .compatible = "mediatek,cpufreq-hw", .data = &cpufreq_mtk_offsets },
+	{}
+};
+
+static struct platform_driver mtk_cpufreq_hw_driver = {
+	.probe = mtk_cpufreq_hw_driver_probe,
+	.remove = mtk_cpufreq_hw_driver_remove,
+	.driver = {
+		.name = "mtk-cpufreq-hw",
+		.of_match_table = mtk_cpufreq_hw_match,
+	},
+};
+module_platform_driver(mtk_cpufreq_hw_driver);
+
+MODULE_DESCRIPTION("Mediatek cpufreq-hw driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/gpu/drm/mediatek/Kconfig b/drivers/gpu/drm/mediatek/Kconfig
index 2976d21e9a34a3e77563bb4d9291e8b0935f34a5..918ef76d8cee897d87843dded48c71aa39f466cb 100644
--- a/drivers/gpu/drm/mediatek/Kconfig
+++ b/drivers/gpu/drm/mediatek/Kconfig
@@ -25,6 +25,26 @@ config DRM_MEDIATEK_HDMI
 	tristate "DRM HDMI Support for Mediatek SoCs"
 	depends on DRM_MEDIATEK
 	select SND_SOC_HDMI_CODEC if SND_SOC
-	select PHY_MTK_HDMI
+	select GENERIC_PHY
+	select CEC_CORE
+	select CEC_NOTIFIER
 	help
 	  DRM/KMS HDMI driver for Mediatek SoCs
+config DRM_MEDIATEK_HDMI_HDCP
+	tristate "DRM HDMI HDCP Support for Mediatek SoCs"
+	depends on DRM_MEDIATEK_HDMI
+	help
+	  DRM/KMS HDMI HDCP driver for Mediatek SoCs.
+	  Choose this option if you want to enable
+	  HDCP driver, and this config depends on
+	  DRM_MEDIATEK_HDMI.
+
+config DRM_MEDIATEK_HDMI_SUSPEND_LOW_POWER
+	tristate "DRM HDMI SUSPEND LOW POWER Support for Mediatek SoCs"
+	depends on DRM_MEDIATEK_HDMI
+	help
+	  DRM/KMS HDMI SUSPEND_LOW_POWER for Mediatek SoCs.
+	  Choose this option if you want to disable/enable
+	  clock and power domain when platform enter suspend,
+	  and this config depends on DRM_MEDIATEK_HDMI.
+source "drivers/gpu/drm/mediatek/mediatek_v2/Kconfig"
diff --git a/drivers/gpu/drm/mediatek/Makefile b/drivers/gpu/drm/mediatek/Makefile
index 29098d7c8307cf6749b0731fd9690e9714da0a69..1c3f245a2f5d6978afd1733ee1a0e5fe1b28982e 100644
--- a/drivers/gpu/drm/mediatek/Makefile
+++ b/drivers/gpu/drm/mediatek/Makefile
@@ -1,10 +1,15 @@
 # SPDX-License-Identifier: GPL-2.0
 
+ifeq (y, $(filter y, $(CONFIG_DRM_MEDIATEK_V2)))
+obj-$(CONFIG_DRM_MEDIATEK) += mediatek_v2/
+else
 mediatek-drm-y := mtk_disp_aal.o \
 		  mtk_disp_ccorr.o \
 		  mtk_disp_color.o \
 		  mtk_disp_gamma.o \
+		  mtk_disp_merge.o \
 		  mtk_disp_ovl.o \
+		  mtk_disp_ovl_adaptor.o \
 		  mtk_disp_rdma.o \
 		  mtk_drm_crtc.o \
 		  mtk_drm_ddp_comp.o \
@@ -12,12 +17,26 @@ mediatek-drm-y := mtk_disp_aal.o \
 		  mtk_drm_gem.o \
 		  mtk_drm_plane.o \
 		  mtk_dsi.o \
-		  mtk_dpi.o
+		  mtk_dpi.o \
+		  mtk_dp_intf.o \
+		  mtk_dp.o \
+		  mtk_dp_hal.o \
+		  mtk_dp_autotest.o \
+		  mtk_ethdr.o \
+		  mtk_mdp_rdma.o
 
 obj-$(CONFIG_DRM_MEDIATEK) += mediatek-drm.o
 
-mediatek-drm-hdmi-objs := mtk_cec.o \
-			  mtk_hdmi.o \
-			  mtk_hdmi_ddc.o
+mediatek-drm-hdmi-objs := ./mediatek_v2/mtk_hdmi.o \
+			 ./mediatek_v2/mtk_hdmi_ddc.o \
+			 ./mediatek_v2/mtk_mt8195_hdmi_phy.o \
+			 ./mediatek_v2/mtk_hdmi_hdr.o \
+			 ./mediatek_v2/mtk_hdmi_debug.o \
+			 ./mediatek_v2/mtk_hdmi_edid.o \
+
+ifeq ($(CONFIG_DRM_MEDIATEK_HDMI_HDCP),y)
+mediatek-drm-hdmi-objs += ./mediatek_v2/mtk_hdmi_hdcp.o
+endif
 
 obj-$(CONFIG_DRM_MEDIATEK_HDMI) += mediatek-drm-hdmi.o
+endif
diff --git a/drivers/gpu/drm/mediatek/mediatek_v2/Kconfig b/drivers/gpu/drm/mediatek/mediatek_v2/Kconfig
new file mode 100644
index 0000000000000000000000000000000000000000..d5a71b1de4d757a8d7b2d0293183d7ce2c47ea55
--- /dev/null
+++ b/drivers/gpu/drm/mediatek/mediatek_v2/Kconfig
@@ -0,0 +1,29 @@
+config DRM_MEDIATEK_V2
+	bool "Version 2 of DRM Support for Mediatek SoCs"
+	help
+	  Choose this option if you have a phone Mediatek
+	  SoCs. The module will be called mediatek-drm v2
+	  This driver provides kernel mode setting and
+	  buffer management to userspace.
+
+config DRM_MTK_SHADOW_REGISTER_SUPPORT
+	bool "DRM shadow register Support for Mediatek SoCs"
+	depends on DRM_MEDIATEK
+	help
+	  DRM shadow register Support for Mediatek SoCs.
+	  define CONFIG_DRM_MTK_SHADOW_REGISTER_SUPPORT to
+	  enable Shadow Register on display.
+	  This feature will de-risk configuration time shortage.
+	  If you want to use Shadow Register on display,
+	  please make sure it is Y in xxx_defconfig.
+	  This feature depends on Mediatek SoCs HW spec.
+	  If unsure, set N.
+
+config DRM_MTK_DISABLE_AEE_LAYER
+	bool "Disable AEE Layer for the customer who don't want to produce AEE"
+	help
+	  Disable AEE Layer if you do not want to produce AEE.
+	  Default Mediatek SoCs will produce AEE when exception occurred.
+	  If this value is y, will not produce AEE.
+	  If this value is n, will produce AEE.
+	  If you do not produce AEE, please set it to Y in xxx_defconfig.
\ No newline at end of file
diff --git a/drivers/gpu/drm/mediatek/mediatek_v2/Makefile b/drivers/gpu/drm/mediatek/mediatek_v2/Makefile
new file mode 100644
index 0000000000000000000000000000000000000000..bb5ed2758d85646917c45449bf9aa8c2fc178060
--- /dev/null
+++ b/drivers/gpu/drm/mediatek/mediatek_v2/Makefile
@@ -0,0 +1,123 @@
+#subdir-ccflags-y += -Werror
+subdir-ccflags-y += -Wno-error
+
+#mediatek-drm-y := mtk_drm_drv.o \
+#		  mtk_disp_color.o \
+#		  mtk_disp_ccorr.o \
+#		  mtk_disp_gamma.o \
+#		  mtk_disp_aal.o \
+#		  mtk_disp_dither.o \
+#		  mtk_disp_ovl.o \
+#		  mtk_disp_rdma.o \
+#		  mtk_disp_rsz.o \
+#		  mtk_disp_wdma.o \
+#		  mtk_drm_crtc.o \
+#		  mtk_drm_ddp.o \
+#		  mtk_drm_ddp_addon.o \
+#		  mtk_drm_ddp_comp.o \
+#		  mtk_drm_fb.o \
+#		  mtk_drm_gem.o \
+#		  mtk_drm_plane.o \
+#		  mtk_dsi.o \
+#		  mtk_mipi_tx.o \
+#		  mtk_writeback.o \
+#		  mtk_sync.o \
+#		  mtk_fence.o \
+#		  mtk_drm_session.o \
+#		  mtk_dump.o \
+#		  mtk_debug.o \
+#		  mtk_layering_rule.o \
+#		  mtk_layering_rule_base.o \
+#		  mtk_rect.o \
+#		  mtk_drm_mmp.o \
+#		  mtk_drm_trace.o \
+#		  mtk_panel_ext.o \
+#		  mtk_drm_helper.o \
+#		  mtk_drm_lowpower.o \
+#		  mtk_disp_postmask.o \
+#		  mtk_drm_assert.o \
+#		  mtk_drm_fbconsole.o \
+#		  mtk_disp_recovery.o \
+#		  mtk_disp_pmqos.o \
+#		  mtk_disp_dsc.o \
+#		  mtk_drm_arr.o \
+#		  mtk_disp_merge.o \
+#		  mtk_dmdp_aal.o \
+#		  mtk_disp_pseudo_ovl.o \
+#		  mtk_ethdr.o \
+#		  mtk_mdp_rdma.o \
+#		  mtk_fbconfig_kdebug.o
+
+#ifneq ($(CONFIG_MTK_FB), y)
+#mediatek-drm-y += font_8x16.o
+#endif
+
+#ifeq ($(CONFIG_DRM_MEDIATEK_DEBUG_FS),y)
+#mediatek-drm-y += mtk_drm_debugfs.o
+#endif
+
+#ifeq ($(CONFIG_MTK_HDMI_SUPPORT), y)
+#obj-y += mtk_dp_intf.o \
+#	mtk_dp.o \
+#	mtk_dp_hal.o \
+#	mtk_dp_debug.o
+
+#ifeq (yy, $(CONFIG_MTK_TEE_GP_SUPPORT)$(CONFIG_TRUSTONIC_TEE_SUPPORT))
+#obj-y += ca/
+#ccflags-y += -DDPTX_HDCP_ENABLE
+#obj-y += mtk_dp_hdcp1x.o \
+#	mtk_dp_hdcp2.o
+#endif
+
+#endif
+
+#mediatek-drm-$(CONFIG_DRM_FBDEV_EMULATION) += mtk_drm_fbdev.o
+
+#obj-$(CONFIG_DRM_MEDIATEK) += mediatek-drm.o
+
+#mediatek-drm-hdmi-objs := mtk_hdmi.o \
+#			  mtk_hdmi_ddc.o \
+#			  mtk_mt8195_hdmi_phy.o
+
+#obj-$(CONFIG_DRM_MEDIATEK_HDMI) += mediatek-drm-hdmi.o
+#obj-$(CONFIG_DRM_MEDIATEK_HDMI) += mediatek-drm-hdmi.o \
+#				  mtk_dpi.o \
+#				  mtk_lvds.o \
+#				  mtk_lvds_phy.o
+
+#ccflags-y += -I$(srctree)/drivers/misc/mediatek/dramc/$(MTK_PLATFORM)	\
+#             -I$(srctree)/drivers/misc/mediatek/smi/			\
+#             -I$(srctree)/drivers/misc/mediatek/mmp/			\
+#             -I$(srctree)/drivers/misc/mediatek/mmdvfs/			\
+#             -I$(srctree)/drivers/iommu/				\
+#             -I$(srctree)/drivers/devfreq/				\
+#             -I$(srctree)/drivers/gpu/drm/				\
+#             -I$(srctree)/drivers/misc/mediatek/include/mt-plat/$(MTK_PLATFORM)/include/mach/				\
+#             -I$(srctree)/drivers/misc/mediatek/include/mt-plat \
+#             -I$(srctree)/drivers/misc/mediatek/leds/ \
+#             -I$(srctree)/drivers/misc/mediatek/leds/$(MTK_PLATFORM) \
+#             -I$(srctree)/drivers/misc/mediatek/cmdq/mailbox/ \
+#             -I$(srctree)/include/uapi/drm/ \
+
+#ccflags-$(CONFIG_MTK_CMDQ_MBOX_EXT) += -I$(srctree)/drivers/misc/mediatek/cmdq/mailbox
+
+#subdir-ccflags-y += -I$(srctree)/drivers/staging/android/mtk_ion/ \
+#		    -I$(srctree)/drivers/staging/android/mtk_ion/mtk
+
+#ifeq (y, $(filter y, $(CONFIG_MACH_MT6885) $(CONFIG_MACH_MT6893) $(CONFIG_MACH_MT6873) $(CONFIG_MACH_MT6853)))
+#ccflags-y += -DDRM_MMPATH
+#ccflags-y += -DNOT_SUPPORT_CABC_HW
+#ccflags-y += -DDISP_MDP_COLOR_ON
+#ccflags-y += -DCCORR_SUPPORT
+#endif
+
+#ifeq (y, $(filter y, $(CONFIG_MACH_MT6833)))
+#ccflags-y += -DNOT_SUPPORT_CABC_HW
+#ccflags-y += -DDISP_MDP_COLOR_ON
+#ccflags-y += -DCCORR_SUPPORT
+#endif
+
+#ifeq (y, $(filter y, $(CONFIG_MACH_MT8195)))
+#ccflags-y += -DDISP_MDP_COLOR_ON
+#ccflags-y += -DCCORR_SUPPORT
+#endif
diff --git a/drivers/gpu/drm/mediatek/mediatek_v2/mtk_cec.c b/drivers/gpu/drm/mediatek/mediatek_v2/mtk_cec.c
new file mode 100644
index 0000000000000000000000000000000000000000..689d1c0d1fb9ac2a2972a88ecbeddafce5f470f6
--- /dev/null
+++ b/drivers/gpu/drm/mediatek/mediatek_v2/mtk_cec.c
@@ -0,0 +1,1117 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2019 MediaTek Inc.
+ */
+
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/io.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/of_gpio.h>
+#include <linux/of_irq.h>
+#include <linux/of_platform.h>
+#include <linux/of_address.h>
+#include <linux/slab.h>
+#include <linux/workqueue.h>
+#include <linux/module.h>
+
+#include "mtk_cec.h"
+
+
+#define cec_clk_27m 0x1
+#define cec_clk_32k 0x2
+unsigned char cec_clock = cec_clk_27m;
+
+static const char * const mtk_cec_clk_names[MTK_CEC_CLK_COUNT] = {
+	[MTK_CEC_66M_H] = "cec_66m_h",
+	[MTK_CEC_66M_B] = "cec_66m_b",
+	[MTK_HDMI_32K] = "hdmi_32k",
+	[MTK_HDMI_26M] = "hdmi_26m",
+};
+
+struct mtk_cec *mtk_global_cec;
+unsigned char mtk_cec_log = 1;
+
+#define MTK_CEC_LOG(fmt, arg...) \
+	do {	if (unlikely(mtk_cec_log)) {	\
+		pr_info("[CEC] %s,%d,"fmt, __func__, __LINE__, ##arg);	\
+		}	\
+	} while (0)
+
+#define MTK_CEC_FUNC()	\
+	do {	if (unlikely(mtk_cec_log)) \
+		pr_info("[CEC] %s\n", __func__); \
+	} while (0)
+
+static inline void mtk_cec_clear_bits(struct mtk_cec *cec,
+	unsigned int offset, unsigned int bits)
+{
+	void __iomem *reg = cec->regs + offset;
+	u32 tmp;
+
+	tmp = readl(reg);
+	tmp &= ~bits;
+	writel(tmp, reg);
+}
+
+static inline void mtk_cec_set_bits(struct mtk_cec *cec,
+	unsigned int offset, unsigned int bits)
+{
+	void __iomem *reg = cec->regs + offset;
+	u32 tmp;
+
+	tmp = readl(reg);
+	tmp |= bits;
+	writel(tmp, reg);
+}
+
+static inline void mtk_cec_mask(struct mtk_cec *cec, unsigned int offset,
+			 unsigned int val, unsigned int mask)
+{
+	u32 tmp = readl(cec->regs + offset) & ~mask;
+
+	tmp |= (val & mask);
+	writel(tmp, cec->regs + offset);
+}
+
+static inline void mtk_cec_write(struct mtk_cec *cec,
+	unsigned int offset, unsigned int val)
+{
+	writel(val, cec->regs + offset);
+}
+
+
+static inline unsigned int mtk_cec_read(struct mtk_cec *cec,
+	unsigned int offset)
+{
+	return readl(cec->regs + offset);
+}
+
+static inline bool mtk_cec_read_bit(struct mtk_cec *cec,
+	unsigned int offset, unsigned int bits)
+{
+	return (readl(cec->regs + offset) & bits) ? true : false;
+
+}
+
+inline void mtk_cec_rx_reset(struct mtk_cec *cec)
+{
+	unsigned int val;
+
+	MTK_CEC_FUNC();
+
+	val = mtk_cec_read(cec, CEC2_TR_CONFIG);
+	mtk_cec_write(cec, CEC2_TR_CONFIG, val & (~CEC2_RX_RESET_WRITE));
+	udelay(1);
+	val = mtk_cec_read(cec, CEC2_TR_CONFIG);
+	mtk_cec_write(cec, CEC2_TR_CONFIG, val |
+		(CEC2_TX_RESET_WRITE | CEC2_RX_RESET_WRITE));
+}
+
+inline void mtk_cec_tx_reset(struct mtk_cec *cec)
+{
+	unsigned int val;
+
+	MTK_CEC_FUNC();
+
+	val = mtk_cec_read(cec, CEC2_TR_CONFIG);
+	mtk_cec_write(cec, CEC2_TR_CONFIG, val & (~CEC2_TX_RESET_WRITE));
+	udelay(1);
+	val = mtk_cec_read(cec, CEC2_TR_CONFIG);
+	mtk_cec_write(cec, CEC2_TR_CONFIG, val |
+		(CEC2_TX_RESET_WRITE | CEC2_RX_RESET_WRITE));
+}
+
+static void mtk_cec_clk_div(struct mtk_cec *cec, unsigned int clk_src)
+{
+	if (clk_src == cec_clk_27m) {
+		/* divide the clock of 26Mhz to 100khz */
+		mtk_cec_mask(cec, CEC2_CKGEN, CEC2_CLK_27M_EN, CEC2_CLK_27M_EN);
+		mtk_cec_mask(cec, CEC2_CKGEN, CEC2_DIV_SEL_100K, CEC2_CLK_DIV);
+		mtk_cec_mask(cec, CEC2_CKGEN, 0x0, CEC2_CLK_SEL_DIV);
+	} else {
+		/* do not divide the clock of 32khz */
+		mtk_cec_mask(cec, CEC2_CKGEN, 0x0, CEC2_CLK_27M_EN);
+		mtk_cec_mask(cec, CEC2_CKGEN, CEC2_CLK_32K_EN, CEC2_CLK_32K_EN);
+		mtk_cec_mask(cec, CEC2_CKGEN,
+			CEC2_CLK_SEL_DIV, CEC2_CLK_SEL_DIV);
+		return;
+	}
+}
+
+static void mtk_cec_rx_check_addr(struct mtk_cec *cec, bool enable)
+{
+	if (enable) {
+		mtk_cec_mask(cec, CEC2_TR_CONFIG,
+			CEC2_RX_CHK_DST, CEC2_RX_CHK_DST);
+		mtk_cec_mask(cec, CEC2_TR_CONFIG, 0, CEC2_BYPASS);
+	} else {
+		mtk_cec_mask(cec, CEC2_TR_CONFIG, 0, CEC2_RX_CHK_DST);
+		mtk_cec_mask(cec, CEC2_TR_CONFIG, CEC2_BYPASS, CEC2_BYPASS);
+	}
+}
+
+static void mtk_cec_rx_timing_config(struct mtk_cec *cec, unsigned int clk_src)
+{
+	MTK_CEC_FUNC();
+
+	if (clk_src == cec_clk_27m) {
+		/* use default timing value */
+		mtk_cec_write(cec, CEC2_RX_TIMER_START_R, 0x0186015e);
+		mtk_cec_write(cec, CEC2_RX_TIMER_START_F, 0x01d601ae);
+		mtk_cec_write(cec, CEC2_RX_TIMER_DATA, 0x011300cd);
+		mtk_cec_write(cec, CEC2_RX_TIMER_ACK, 0x00690082);
+		mtk_cec_write(cec, CEC2_RX_TIMER_ERROR, 0x01680000);
+		mtk_cec_mask(cec, CEC2_CKGEN, CEC2_CLK_27M_EN, CEC2_CLK_27M_EN);
+	} else {
+		mtk_cec_write(cec, CEC2_RX_TIMER_START_R, 0x007d0070);
+		mtk_cec_write(cec, CEC2_RX_TIMER_START_F, 0x0099008a);
+		mtk_cec_write(cec, CEC2_RX_TIMER_DATA, 0x00230040);
+		mtk_cec_write(cec, CEC2_RX_TIMER_ACK, 0x00000030);
+		mtk_cec_write(cec, CEC2_RX_TIMER_ERROR, 0x007300aa);
+		return;
+	}
+
+	mtk_cec_mask(cec, CEC2_TR_CONFIG, CEC2_RX_ACK_ERROR_BYPASS,
+		CEC2_RX_ACK_ERROR_BYPASS);
+	mtk_cec_rx_reset(cec);
+}
+
+static void mtk_cec_tx_timing_config(struct mtk_cec *cec, unsigned int clk_src)
+{
+	MTK_CEC_FUNC();
+
+	if (clk_src == cec_clk_27m) {
+		/* use default timing value */
+		mtk_cec_write(cec, CEC2_TX_TIMER_START, 0x01c20172);
+		mtk_cec_write(cec, CEC2_TX_TIMER_DATA_R, 0x003c0096);
+		mtk_cec_write(cec, CEC2_TX_T_DATA_F, 0x00f000f0);
+		mtk_cec_write(cec, TX_TIMER_DATA_S, 0x00040069);
+		mtk_cec_write(cec, CEC2_LINE_DET, 0x1f4004b0);
+
+		mtk_cec_mask(cec, CEC2_TX_TIMER_ACK, 0x00aa0028,
+			CEC2_TX_TIMER_ACK_MAX | CEC2_TX_TIMER_ACK_MIN);
+		mtk_cec_mask(cec, CEC2_CKGEN, CEC2_CLK_27M_EN, CEC2_CLK_27M_EN);
+	} else {
+		mtk_cec_write(cec, CEC2_TX_TIMER_START, 0x00920079);
+		mtk_cec_write(cec, CEC2_TX_TIMER_DATA_R, 0x00140031);
+		mtk_cec_write(cec, CEC2_TX_T_DATA_F, 0x004f004f);
+		mtk_cec_write(cec, TX_TIMER_DATA_S, 0x00010022);
+		mtk_cec_write(cec, CEC2_LINE_DET, 0x0a000180);
+
+		mtk_cec_mask(cec, CEC2_TX_TIMER_ACK, 0x0036000d,
+			CEC2_TX_TIMER_ACK_MAX | CEC2_TX_TIMER_ACK_MIN);
+		return;
+	}
+	mtk_cec_mask(cec, CEC2_TX_ARB, 0x01 << 24,
+		CEC2_TX_MAX_RETRANSMIT_NUM_ARB);
+	mtk_cec_mask(cec, CEC2_TX_ARB, 0x01 << 20,
+		CEC2_TX_MAX_RETRANSMIT_NUM_COL);
+	mtk_cec_mask(cec, CEC2_TX_ARB, 0x01 << 16,
+		CEC2_TX_MAX_RETRANSMIT_NUM_NAK);
+	mtk_cec_mask(cec, CEC2_TX_ARB, 0x03 << 8,
+		CEC2_TX_BCNT_RETRANSMIT);
+	mtk_cec_mask(cec, CEC2_TX_ARB, 0x07 << 4,
+		CEC2_TX_BCNT_NEW_MSG);
+	mtk_cec_mask(cec, CEC2_TX_ARB, 0x05,
+		CEC2_TX_BCNT_NEW_INIT);
+
+	mtk_cec_mask(cec, CEC2_CKGEN, CEC2_CLK_TX_EN, CEC2_CLK_TX_EN);
+	mtk_cec_tx_reset(cec);
+}
+
+inline void mtk_cec_txrx_interrupts_config(struct mtk_cec *cec)
+{
+	/*disable all irq config*/
+	mtk_cec_write(cec, CEC2_INT_CLR, 0xffffffff);
+	mtk_cec_write(cec, CEC2_INT_CLR, 0);
+
+	/*enable all rx irq config except FSM_CHG_INT*/
+	mtk_cec_mask(cec, CEC2_INT_EN, CEC2_RX_INT_ALL_EN, CEC2_RX_INT_ALL_EN);
+	mtk_cec_mask(cec, CEC2_INT_EN, 0, CEC2_RX_FSM_CHG_INT_EN); //can.zeng add
+}
+
+static void mtk_cec_set_logic_addr(struct mtk_cec *cec,
+	u8 la, enum cec_la_num num)
+{
+	MTK_CEC_FUNC();
+
+	if (num == DEVICE_ADDR_1)
+		mtk_cec_mask(cec, CEC2_TR_CONFIG, la << CEC2_LA1_SHIFT,
+			CEC2_DEVICE_ADDR1);
+	else if (num == DEVICE_ADDR_2)
+		mtk_cec_mask(cec, CEC2_TR_CONFIG, la << CEC2_LA2_SHIFT,
+			CEC2_DEVICE_ADDR2);
+	else if (num == DEVICE_ADDR_3)
+		mtk_cec_mask(cec, CEC2_TR_CONFIG, la << CEC2_LA3_SHIFT,
+			CEC2_DEVICE_ADDR3);
+	else
+		MTK_CEC_LOG("Cannot support more than 3 logic address");
+}
+
+static void mtk_cec_logic_addr_config(struct cec_adapter *adap)
+{
+	__u8 unreg_la_addr = 0xff;
+	struct mtk_cec *cec = adap->priv;
+	struct cec_log_addrs *cec_la = &(adap->log_addrs);
+
+	MTK_CEC_FUNC();
+
+	memset((void *)cec_la, 0, sizeof(struct cec_log_addrs));
+	cec_la->num_log_addrs = 0;
+	cec_la->log_addr[0] = CEC_LOG_ADDR_UNREGISTERED;
+	cec_la->cec_version = CEC_OP_CEC_VERSION_1_4;
+	cec_la->log_addr_type[0] = CEC_LOG_ADDR_TYPE_UNREGISTERED;
+	cec_la->primary_device_type[0] = CEC_LOG_ADDR_TYPE_UNREGISTERED;
+	cec_la->log_addr_mask = 0;
+
+	mtk_cec_set_logic_addr(cec, unreg_la_addr, DEVICE_ADDR_1);
+	mtk_cec_set_logic_addr(cec, unreg_la_addr, DEVICE_ADDR_2);
+	mtk_cec_set_logic_addr(cec, unreg_la_addr, DEVICE_ADDR_3);
+}
+
+inline void mtk_cec_int_disable_all(struct mtk_cec *cec)
+{
+	mtk_cec_mask(cec, CEC2_INT_EN, 0x0, CEC2_INT_ALL_EN);
+}
+
+static void mtk_cec_init(struct mtk_cec *cec)
+{
+	MTK_CEC_FUNC();
+
+	mtk_cec_clk_div(cec, cec_clock);
+	mtk_cec_rx_check_addr(cec, true);
+	mtk_cec_rx_timing_config(cec, cec_clock);
+	mtk_cec_tx_timing_config(cec, cec_clock);
+	mtk_cec_txrx_interrupts_config(cec);
+	mtk_cec_logic_addr_config(cec->adap);
+
+}
+
+static void mtk_cec_deinit(struct mtk_cec *cec)
+{
+	mtk_cec_int_disable_all(cec);
+}
+
+static int mtk_cec_power_enable(struct mtk_cec *cec, bool enable)
+{
+	MTK_CEC_LOG("enable=%d\n", enable);
+
+	if (enable) {
+		mtk_cec_clk_enable(cec, true);
+		mtk_cec_mask(cec, CEC2_CKGEN, 0, CEC2_CLK_PDN);
+		cec->cec_enabled = true;
+	} else {
+		mtk_cec_mask(cec, CEC2_CKGEN, CEC2_CLK_PDN, CEC2_CLK_PDN);
+		mtk_cec_clk_enable(cec, false);
+		cec->cec_enabled = false;
+	}
+	return 0;
+
+}
+
+/*
+ *	static unsigned int mtk_cec_get_logic_addr(struct mtk_cec *cec,
+ *		enum cec_la_num num)
+ *	{
+ *		if (num == DEVICE_ADDR_1)
+ *			return ((mtk_cec_read(cec, CEC2_TR_CONFIG) &
+ *				CEC2_DEVICE_ADDR1) >> CEC2_LA1_SHIFT);
+ *		else if (num == DEVICE_ADDR_2)
+ *			return ((mtk_cec_read(cec, CEC2_TR_CONFIG) &
+ *				CEC2_DEVICE_ADDR2) >> CEC2_LA2_SHIFT);
+ *		else if (num == DEVICE_ADDR_3)
+ *			return ((mtk_cec_read(cec, CEC2_TR_CONFIG) &
+ *				CEC2_DEVICE_ADDR3) >> CEC2_LA3_SHIFT);
+ *		else
+ *			MTK_CEC_LOG("Cannot support more than 3 logic address");
+ *		return CEC_LOG_ADDR_UNREGISTERED;
+ *	}
+ */
+
+static int mtk_cec_adap_enable(struct cec_adapter *adap, bool enable)
+{
+	struct mtk_cec *cec = adap->priv;
+
+	MTK_CEC_LOG("enable=%d\n", enable);
+	if (enable) {
+		if (cec->cec_enabled)
+			MTK_CEC_LOG("cec has already been enabled, return\n");
+		else {
+			mtk_cec_power_enable(cec, true);
+			mtk_cec_init(cec);
+		}
+	} else {
+		if (!cec->cec_enabled)
+			MTK_CEC_LOG("cec has already been disabled, return\n");
+		else {
+			mtk_cec_deinit(cec);
+			mtk_cec_power_enable(cec, false);
+		}
+	}
+	return 0;
+}
+
+static int mtk_cec_adap_log_addr(struct cec_adapter *adap, u8 logical_addr)
+{
+	struct mtk_cec *cec = adap->priv;
+
+	MTK_CEC_LOG("logical_address=%d\n", logical_addr);
+
+	/* to do :mtk cec can accept 3 logic address, now just accept one */
+	if (logical_addr != CEC_LOG_ADDR_INVALID)
+		mtk_cec_set_logic_addr(cec, logical_addr, DEVICE_ADDR_1);
+
+	return 0;
+}
+
+static void mtk_cec_set_msg_header(struct mtk_cec *cec, struct cec_msg *msg)
+{
+	struct cec_msg_header_block header = { };
+
+	header.destination = (msg->msg[0]) & 0x0f;
+	header.initiator = ((msg->msg[0]) & 0xf0) >> 4;
+	mtk_cec_mask(cec, CEC2_TX_HEADER,
+		header.initiator << 4, CEC2_TX_HEADER_SRC);
+	mtk_cec_mask(cec, CEC2_TX_HEADER,
+		header.destination, CEC2_TX_HEADER_DST);
+}
+
+static void mtk_cec_print_cec_frame(struct cec_frame *frame)
+{
+	struct cec_msg *msg = frame->msg;
+	unsigned char header = msg->msg[0];
+
+	MTK_CEC_LOG("cec message initiator is %d\n", (header & 0xf0) >> 4);
+	MTK_CEC_LOG("cec message follower is %d\n", header & 0x0f);
+	MTK_CEC_LOG("cec message length is %d\n", msg->len);
+	MTK_CEC_LOG("cec message opcode is 0x%x\n", msg->msg[1]);
+}
+
+inline bool mtk_cec_tx_fsm_fail(struct mtk_cec *cec)
+{
+	return ((mtk_cec_read(cec, CEC2_TX_STATUS) &
+		CEC2_TX_FSM) >> 16) == 0x10 ? true : false;
+}
+
+
+inline bool mtk_cec_tx_fail_int(struct mtk_cec *cec)
+{
+	return (mtk_cec_read(cec, CEC2_INT_STA) &
+		CEC2_TX_INT_FAIL) ? true : false;
+}
+
+
+inline bool mtk_cec_input(struct mtk_cec *cec)
+{
+	return mtk_cec_read_bit(cec, CEC2_RX_STATUS, CEC2_CEC_INPUT);
+}
+
+inline bool mtk_cec_tx_fsm_idle(struct mtk_cec *cec)
+{
+	return ((mtk_cec_read(cec, CEC2_TX_STATUS) &
+		CEC2_TX_FSM) >> 16) == 0x01 ? true : false;
+}
+
+inline void mtk_cec_tx_int_disable_all(struct mtk_cec *cec)
+{
+	mtk_cec_mask(cec, CEC2_INT_EN, 0x0, CEC2_TX_INT_ALL_EN);
+}
+
+inline void mtk_cec_tx_int_clear_all(struct mtk_cec *cec)
+{
+	mtk_cec_mask(cec, CEC2_INT_CLR,
+		CEC2_TX_INT_ALL_CLR, CEC2_TX_INT_ALL_CLR);
+	mtk_cec_mask(cec, CEC2_INT_CLR, 0, CEC2_TX_INT_ALL_CLR);
+}
+
+inline void mtk_cec_tx_finish_int_en(struct mtk_cec *cec, unsigned int en)
+{
+	mtk_cec_mask(cec, CEC2_INT_EN, en << 8, CEC2_TX_DATA_FINISH_INT_EN);
+}
+
+inline void mtk_cec_tx_fail_longlow_int_en(struct mtk_cec *cec, unsigned int en)
+{
+	mtk_cec_mask(cec, CEC2_INT_EN, en << 7, CEC2_LINE_lOW_LONG_INT_EN);
+}
+
+inline void mtk_cec_tx_fail_retransmit_int_en(struct mtk_cec *cec,
+	unsigned int en)
+{
+	mtk_cec_mask(cec, CEC2_INT_EN, en << 12,
+		CEC2_TX_FAIL_RETRANSMIT_INT_EN);
+}
+
+inline void mtk_cec_tx_trigger_send(struct mtk_cec *cec)
+{
+	MTK_CEC_FUNC();
+	mtk_cec_mask(cec, CEC2_TX_HEADER, CEC2_TX_READY, CEC2_TX_READY);
+}
+
+inline void mtk_cec_tx_set_h_eom(struct mtk_cec *cec, unsigned int heom)
+{
+	mtk_cec_mask(cec, CEC2_TX_HEADER, heom << 8, CEC2_TX_HEADER_EOM);
+}
+
+inline void mtk_cec_tx_set_data_len(struct mtk_cec *cec, unsigned int len)
+{
+	mtk_cec_mask(cec, CEC2_TX_HEADER, len << 12, CEC2_TX_SEND_CNT);
+}
+
+inline void mtk_cec_tx_detect_startbit(struct mtk_cec *cec)
+{
+	static unsigned int tx_fsm, pre_tx_fsm;
+
+	tx_fsm = ((mtk_cec_read(cec, CEC2_TX_STATUS)) & CEC2_TX_FSM) >> 16;
+	if ((tx_fsm == 0x08) && (pre_tx_fsm == 0x20)) {
+		mtk_cec_tx_reset(cec);
+		MTK_CEC_LOG("\nDetect Start bit Err\n\n");
+		mtk_cec_tx_int_clear_all(cec); //can.zeng add
+		cec->transmitting.status.tx_status = CEC_TX_FAIL; //can.zeng add
+		cec_transmit_attempt_done(cec->adap, CEC_TX_STATUS_ERROR); //can.zeng add
+	}
+	pre_tx_fsm = tx_fsm;
+}
+
+inline bool mtk_cec_tx_fail_longlow(struct mtk_cec *cec)
+{
+	return mtk_cec_read_bit(cec, CEC2_INT_STA, CEC2_LINE_lOW_LONG_INT_STA);
+}
+
+inline void mtk_cec_tx_fail_longlow_intclr(struct mtk_cec *cec)
+{
+	mtk_cec_mask(cec, CEC2_INT_CLR,
+		CEC2_LINE_lOW_LONG_INT_CLR, CEC2_LINE_lOW_LONG_INT_CLR);
+	mtk_cec_mask(cec, CEC2_INT_CLR, 0, CEC2_LINE_lOW_LONG_INT_CLR);
+}
+
+inline bool mtk_cec_tx_fail_retransmit_intsta(struct mtk_cec *cec)
+{
+	return mtk_cec_read_bit(cec, CEC2_INT_STA,
+		CEC2_TX_FAIL_RETRANSMIT_INT_STA);
+}
+
+inline void mtk_cec_tx_fail_retransmit_intclr(struct mtk_cec *cec)
+{
+	mtk_cec_mask(cec, CEC2_INT_CLR,
+		CEC2_TX_FAIL_RETRANSMIT_INT_CLR,
+		CEC2_TX_FAIL_RETRANSMIT_INT_CLR);
+	mtk_cec_mask(cec, CEC2_INT_CLR, 0, CEC2_TX_FAIL_RETRANSMIT_INT_CLR);
+}
+
+inline bool mtk_cec_tx_fail_h_ack(struct mtk_cec *cec)
+{
+	return mtk_cec_read_bit(cec, CEC2_INT_STA,
+		CEC2_TX_FAIL_HEADER_ACK_INT_STA);
+}
+
+inline void mtk_cec_tx_fail_h_ack_intclr(struct mtk_cec *cec)
+{
+	mtk_cec_mask(cec, CEC2_INT_CLR,
+		CEC2_TX_FAIL_HEADER_ACK_INT_CLR,
+		CEC2_TX_FAIL_HEADER_ACK_INT_CLR);
+	mtk_cec_mask(cec, CEC2_INT_CLR, 0, CEC2_TX_FAIL_HEADER_ACK_INT_CLR);
+}
+
+inline bool mtk_cec_tx_fail_data_ack(struct mtk_cec *cec)
+{
+	return mtk_cec_read_bit(cec, CEC2_INT_STA,
+		CEC2_TX_FAIL_DATA_ACK_INT_STA);
+}
+
+inline void mtk_cec_tx_fail_data_ack_intclr(struct mtk_cec *cec)
+{
+	mtk_cec_mask(cec, CEC2_INT_CLR,
+		CEC2_TX_FAIL_DATA_ACK_INT_CLR, CEC2_TX_FAIL_DATA_ACK_INT_CLR);
+	mtk_cec_mask(cec, CEC2_INT_CLR, 0, CEC2_TX_FAIL_DATA_ACK_INT_CLR);
+}
+
+inline bool mtk_cec_tx_fail_data(struct mtk_cec *cec)
+{
+	return mtk_cec_read_bit(cec, CEC2_INT_STA, CEC2_TX_FAIL_DATA_INT_STA);
+}
+
+inline void mtk_cec_tx_fail_data_intclr(struct mtk_cec *cec)
+{
+	mtk_cec_mask(cec, CEC2_INT_CLR,
+		CEC2_TX_FAIL_DATA_INT_CLR, CEC2_TX_FAIL_DATA_INT_CLR);
+	mtk_cec_mask(cec, CEC2_INT_CLR, 0, CEC2_TX_FAIL_DATA_INT_CLR);
+}
+
+inline bool mtk_cec_tx_fail_header(struct mtk_cec *cec)
+{
+	return mtk_cec_read_bit(cec, CEC2_INT_STA, CEC2_TX_FAIL_HEADER_INT_STA);
+}
+
+inline void mtk_cec_tx_fail_header_intclr(struct mtk_cec *cec)
+{
+	mtk_cec_mask(cec, CEC2_INT_CLR,
+		CEC2_TX_FAIL_HEADER_INT_CLR, CEC2_TX_FAIL_HEADER_INT_CLR);
+	mtk_cec_mask(cec, CEC2_INT_CLR, 0, CEC2_TX_FAIL_HEADER_INT_CLR);
+}
+
+inline bool mtk_cec_tx_fail_src(struct mtk_cec *cec)
+{
+	return mtk_cec_read_bit(cec, CEC2_INT_STA, CEC2_TX_FAIL_SRC_INT_STA);
+}
+
+inline void mtk_cec_tx_fail_src_intclr(struct mtk_cec *cec)
+{
+	mtk_cec_mask(cec, CEC2_INT_CLR,
+		CEC2_TX_FAIL_SRC_INT_CLR, CEC2_TX_FAIL_SRC_INT_CLR);
+	mtk_cec_mask(cec, CEC2_INT_CLR, 0, CEC2_TX_FAIL_SRC_INT_CLR);
+}
+
+inline bool mtk_cec_tx_finish(struct mtk_cec *cec)
+{
+	return mtk_cec_read_bit(cec, CEC2_INT_STA, CEC2_TX_DATA_FINISH_INT_STA);
+}
+
+inline void mtk_cec_tx_finish_clr(struct mtk_cec *cec)
+{
+	mtk_cec_mask(cec, CEC2_INT_CLR,
+		CEC2_TX_DATA_FINISH_INT_CLR, CEC2_TX_DATA_FINISH_INT_CLR);
+	mtk_cec_mask(cec, CEC2_INT_CLR,
+		0, CEC2_TX_DATA_FINISH_INT_CLR);
+}
+
+static void mtk_cec_tx_set_data(struct mtk_cec *cec,
+	struct cec_msg *cec_msg, unsigned char data_len)
+{
+	unsigned char i, addr, byte_shift;
+
+	for (i = 0; i < data_len; i++) {
+		addr = (i / 4) * 4 + CEC2_TX_DATA0;
+		byte_shift = (i % 4 * 8);
+		mtk_cec_mask(cec, addr, cec_msg->msg[i+1] << byte_shift,
+			0xff << byte_shift);
+	}
+}
+
+inline bool mtk_cec_rx_header_arrived(struct mtk_cec *cec)
+{
+	bool is_rx_fsm_irq;
+	bool is_rx_fsm_header;
+
+	is_rx_fsm_irq = mtk_cec_read_bit(cec, CEC2_INT_STA,
+		CEC2_RX_FSM_CHG_INT_STA);
+	is_rx_fsm_header = ((mtk_cec_read(cec,
+		CEC2_RX_STATUS) & CEC2_RX_FSM) >> 16) == 0x08;
+	if (is_rx_fsm_irq && is_rx_fsm_header)
+		return true;
+	else
+		return false;
+}
+
+inline unsigned int mtk_cec_rx_get_dst(struct mtk_cec *cec)
+{
+	return mtk_cec_read(cec, CEC2_RX_BUF_HEADER) & CEC2_RX_HEADER_DST;
+}
+
+inline unsigned int mtk_cec_rx_get_src(struct mtk_cec *cec)
+{
+	return (mtk_cec_read(cec, CEC2_RX_BUF_HEADER) &
+		CEC2_RX_HEADER_SRC) >> 4;
+}
+
+inline bool mtk_cec_rx_data_arrived(struct mtk_cec *cec)
+{
+	return mtk_cec_read_bit(cec, CEC2_INT_STA, CEC2_RX_DATA_RCVD_INT_STA);
+}
+
+inline bool mtk_cec_rx_buffer_ready(struct mtk_cec *cec)
+{
+	return mtk_cec_read_bit(cec, CEC2_INT_STA, CEC2_RX_BUF_READY_INT_STA);
+}
+
+inline bool mtk_cec_rx_buffer_full(struct mtk_cec *cec)
+{
+	return mtk_cec_read_bit(cec, CEC2_INT_STA, CEC2_RX_BUF_FULL_INT_STA);
+}
+
+
+inline void mtk_cec_rx_int_all_clr(struct mtk_cec *cec)
+{
+	mtk_cec_mask(cec, CEC2_INT_CLR, CEC2_RX_INT_ALL_CLR, CEC2_RX_INT_ALL_CLR);
+	mtk_cec_mask(cec, CEC2_INT_CLR, 0, CEC2_RX_INT_ALL_CLR);
+}
+
+static int mtk_cec_send_msg(struct mtk_cec *cec)
+{
+	unsigned char msg_data_size;
+	unsigned char size;
+	struct cec_frame *frame = &cec->transmitting;
+
+	size = frame->msg->len;
+	msg_data_size = size - CEC_HEADER_BLOCK_SIZE;
+
+	mtk_cec_print_cec_frame(frame);
+
+	if (frame->status.tx_status == CEC_TX_START) {
+
+		if (mtk_cec_tx_fsm_fail(cec) || mtk_cec_tx_fail_int(cec)) {
+			mtk_cec_tx_reset(cec);
+			if (mtk_cec_input(cec))
+				mtk_cec_tx_fail_longlow_intclr(cec);
+			return -EIO;
+		}
+
+		if (!mtk_cec_tx_fsm_idle(cec))
+			mtk_cec_tx_reset(cec);
+
+		/* fill header block*/
+		mtk_cec_set_msg_header(cec, frame->msg);
+		MTK_CEC_LOG("tx header=0x%02x,seq=%d,op=0x%x,l=%d\n",
+			frame->msg->msg[0], frame->msg->sequence,
+			frame->msg->msg[1], frame->msg->len);
+
+		/*disable and clear interrupts*/
+		mtk_cec_tx_int_disable_all(cec);
+		mtk_cec_tx_int_clear_all(cec);
+
+		/* fill data block*/
+		if (msg_data_size == 0)
+			mtk_cec_tx_set_h_eom(cec, 1);
+		else {
+			mtk_cec_tx_set_h_eom(cec, 0);
+			mtk_cec_tx_set_data_len(cec, msg_data_size);
+			mtk_cec_tx_set_data(cec, frame->msg, msg_data_size);
+		}
+		cec->transmitting.status.tx_status = CEC_TX_Transmitting;
+	}
+
+	mtk_cec_tx_finish_int_en(cec, 1);
+	mtk_cec_tx_fail_longlow_int_en(cec, 1);
+	mtk_cec_tx_fail_retransmit_int_en(cec, 1);
+	mtk_cec_tx_trigger_send(cec);
+
+	return 0;
+}
+
+static void mtk_cec_msg_init(struct mtk_cec *cec, struct cec_msg *msg)
+{
+	cec->transmitting.msg = msg;
+	cec->transmitting.retry_count = 0;
+	cec->transmitting.status.tx_status = CEC_TX_START;
+}
+
+static int mtk_cec_adap_transmit(struct cec_adapter *adap, u8 attempts,
+				 u32 signal_free_time, struct cec_msg *msg)
+{
+	struct mtk_cec *cec = adap->priv;
+
+	MTK_CEC_FUNC();
+	mtk_cec_msg_init(cec, msg);
+	mtk_cec_send_msg(cec);
+
+	return 0;
+}
+
+inline unsigned int mtk_cec_rx_data_len(struct mtk_cec *cec)
+{
+	unsigned int val;
+
+	val = mtk_cec_read(cec, CEC2_RX_BUF_HEADER);
+	if (val & CEC2_RX_HEADER_EOM)
+		return 0;
+	if (val & CEC2_RX_BUF_CNT)
+		return ((val & CEC2_RX_BUF_CNT) >> 12);
+	else
+		return 0;
+}
+
+inline void mtk_cec_rx_notify_data_taken(struct mtk_cec *cec)
+{
+	mtk_cec_mask(cec, CEC2_RX_BUF_HEADER,
+		CEC2_RX_BUF_RISC_ACK, CEC2_RX_BUF_RISC_ACK);
+}
+
+void mtk_cec_tx_work_handle(struct work_struct *data)
+{
+	struct mtk_cec *cec = mtk_global_cec;
+
+	if (cec->transmitting.status.tx_status == CEC_TX_COMPLETE) {
+		MTK_CEC_LOG("notify CEC CORE adapter transmit done\n");
+		cec_transmit_attempt_done(cec->adap, CEC_TX_STATUS_OK);
+
+	} else if ((cec->transmitting.status.tx_status == CEC_TX_FAIL_HNAK) ||
+		(cec->transmitting.status.tx_status == CEC_TX_FAIL_DNAK)) {
+		MTK_CEC_LOG("notify CEC CORE adapter transmit NACK\n");
+		cec_transmit_attempt_done(cec->adap, CEC_TX_STATUS_NACK);
+
+	} else if ((cec->transmitting.status.tx_status == CEC_TX_FAIL) ||
+		(cec->transmitting.status.tx_status == CEC_TX_FAIL_HEAD) ||
+		(cec->transmitting.status.tx_status == CEC_TX_FAIL_DATA) ||
+		(cec->transmitting.status.tx_status == CEC_TX_FAIL_SRC) ||
+		(cec->transmitting.status.tx_status == CEC_TX_FAIL_LOW) ||
+		(cec->transmitting.status.tx_status == CEC_TX_FAIL_RETR)) {
+		MTK_CEC_LOG("notify CEC CORE adapter transmit error\n");
+		cec_transmit_attempt_done(cec->adap, CEC_TX_STATUS_ERROR);
+
+	} else {
+		MTK_CEC_LOG("WARNING: no corresponding case\n");
+		cec_transmit_attempt_done(cec->adap, CEC_TX_STATUS_ERROR);
+	}
+}
+
+void mtk_cec_rx_work_handle(struct work_struct *data)
+{
+	struct mtk_cec *cec = mtk_global_cec;
+	struct cec_frame *received_msg = &cec->received;
+
+	if (received_msg->status.rx_status == CEC_RX_COMPLETE) {
+		MTK_CEC_LOG("notify CEC CORE adapter receive msg\n");
+		cec_received_msg(cec->adap, received_msg->msg);
+	}
+}
+
+static void mtk_cec_receiving_msg(struct mtk_cec *cec)
+{
+	unsigned char rxlen;
+	unsigned char i, addr, byte_shift;
+
+	struct cec_msg_header_block header = { };
+	struct cec_frame *received_msg = &cec->received;
+
+	received_msg->status.rx_status = CEC_RX_Receiving;
+	if (!mtk_cec_rx_buffer_ready(cec)) {
+		received_msg->status.rx_status = CEC_RX_FAIL;
+		MTK_CEC_LOG("%s,cec buffer not ready\n", __func__);
+		return;
+	}
+
+	/* <polling message> only */
+	if (mtk_cec_rx_data_len(cec) == 0) {
+		MTK_CEC_LOG("polling message\n");
+		mtk_cec_rx_notify_data_taken(cec);
+		received_msg->status.rx_status = CEC_RX_COMPLETE;
+		return;
+	}
+
+	header.initiator = mtk_cec_rx_get_src(cec);
+	header.destination = mtk_cec_rx_get_dst(cec);
+	received_msg->msg->msg[0] =
+		(header.initiator << 4 | header.destination);
+
+	rxlen = mtk_cec_rx_data_len(cec);
+	received_msg->msg->len = rxlen + CEC_HEADER_BLOCK_SIZE;
+
+	for (i = 0; i < rxlen; i++) {
+		addr = (i / 4) * 4 + CEC2_RX_DATA0;
+		byte_shift = (i % 4 * 8);
+		received_msg->msg->msg[i+1] =
+		(mtk_cec_read(cec, addr) & 0xff << byte_shift) >> byte_shift;
+	}
+	MTK_CEC_LOG("RECEIVED MESSAGE:\n");
+	mtk_cec_print_cec_frame(received_msg);
+	received_msg->status.rx_status = CEC_RX_COMPLETE;
+	mtk_cec_rx_notify_data_taken(cec);
+	schedule_work(&cec->cec_rx_work);
+
+}
+
+static void mtk_cec_rx_event_handler(struct mtk_cec *cec)
+{
+	//unsigned char ReceivedDst;
+
+	struct cec_frame *received_msg = &cec->received;
+
+	received_msg->msg = &cec->rx_msg;
+
+/*
+ *	if (mtk_cec_rx_header_arrived(cec)) {
+ *		received_msg->status.rx_status = CEC_RX_START;
+ *		ReceivedDst = mtk_cec_rx_get_dst(cec);
+ *		MTK_CEC_LOG("header_addr=0x%08x\n",
+ *		(mtk_cec_rx_get_src(cec) << 4) + ReceivedDst);
+ *		if ((ReceivedDst == mtk_cec_get_logic_addr(cec, DEVICE_ADDR_1))
+ *		    || (ReceivedDst ==
+ *		    mtk_cec_get_logic_addr(cec, DEVICE_ADDR_2))
+ *		    || (ReceivedDst ==
+ *		    mtk_cec_get_logic_addr(cec, DEVICE_ADDR_3))
+ *		    || (ReceivedDst == 0xf)) {
+ *			MTK_CEC_LOG("RX:H\n");
+ *		} else {
+ *			MTK_CEC_LOG("[mtk_cec]RX:H False\n");
+ *		}
+ *	}
+ */
+	if (mtk_cec_rx_data_arrived(cec) || mtk_cec_rx_buffer_ready(cec)) {
+		MTK_CEC_LOG("RX:D\n");
+		mtk_cec_receiving_msg(cec);
+	}
+	if (mtk_cec_rx_buffer_full(cec)) {
+		received_msg->status.rx_status = CEC_RX_FAIL;
+		MTK_CEC_LOG("[mtk_cec]Overflow\n");
+	}
+
+	mtk_cec_rx_int_all_clr(cec);
+
+}
+
+static void mtk_cec_tx_event_handler(struct mtk_cec *cec)
+{
+	mtk_cec_tx_detect_startbit(cec);
+
+	//if (cec->transmitting.status.tx_status == CEC_TX_Transmitting) {
+	if (mtk_cec_tx_fail_longlow(cec)) {
+		mtk_cec_tx_fail_longlow_int_en(cec, 0);
+		mtk_cec_tx_fail_longlow_intclr(cec);
+		mtk_cec_tx_reset(cec);
+		cec->transmitting.status.tx_status = CEC_TX_FAIL_LOW;
+		schedule_work(&cec->cec_tx_work);
+		MTK_CEC_LOG("CEC Direct/Brdcst msg fail:long low");
+	}
+
+	if (mtk_cec_tx_fail_retransmit_intsta(cec)) {
+		cec->transmitting.status.tx_status = CEC_TX_FAIL_RETR;
+
+		/*broadcast msg*/
+		if ((cec->transmitting.msg->msg[0] & 0x0f) ==
+			CEC_LOG_ADDR_BROADCAST) {
+			if (mtk_cec_tx_fail_h_ack(cec) ||
+				mtk_cec_tx_fail_data_ack(cec)) {
+				mtk_cec_tx_fail_h_ack_intclr(cec);
+				mtk_cec_tx_fail_data_ack_intclr(cec);
+				MTK_CEC_LOG("broardcast NACK:done\n");
+				cec->transmitting.status.tx_status = CEC_TX_COMPLETE;
+			} else {
+				MTK_CEC_LOG("broardcast ACK:fail\n");
+				cec->transmitting.status.tx_status = CEC_TX_FAIL;
+			}
+			schedule_work(&cec->cec_tx_work);
+		} else { /*direct msg*/
+			if (mtk_cec_tx_fail_h_ack(cec)) {
+				mtk_cec_tx_fail_h_ack_intclr(cec);
+				cec->transmitting.status.tx_status = CEC_TX_FAIL_HNAK;
+				MTK_CEC_LOG("err:Header NACK\n");
+			}
+			if (mtk_cec_tx_fail_data_ack(cec)) {
+				mtk_cec_tx_fail_data_ack_intclr(cec);
+				cec->transmitting.status.tx_status = CEC_TX_FAIL_DNAK;
+				MTK_CEC_LOG("err:Data NACK\n");
+			}
+			if (mtk_cec_tx_fail_data(cec)) {
+				mtk_cec_tx_fail_data_intclr(cec);
+				cec->transmitting.status.tx_status = CEC_TX_FAIL_DATA;
+				MTK_CEC_LOG("err:Data\n");
+			}
+			if (mtk_cec_tx_fail_header(cec)) {
+				mtk_cec_tx_fail_header_intclr(cec);
+				cec->transmitting.status.tx_status = CEC_TX_FAIL_HEAD;
+				MTK_CEC_LOG("err:Header\n");
+			}
+			if (mtk_cec_tx_fail_src(cec)) {
+				mtk_cec_tx_fail_src_intclr(cec);
+				cec->transmitting.status.tx_status = CEC_TX_FAIL_SRC;
+				MTK_CEC_LOG("err:Source\n");
+			}
+			schedule_work(&cec->cec_tx_work);
+		}
+
+		MTK_CEC_LOG("err:Retransmit\n");
+		mtk_cec_tx_fail_retransmit_intclr(cec);
+	}
+
+	if (mtk_cec_tx_finish(cec)) {
+		mtk_cec_tx_finish_clr(cec);
+		mtk_cec_tx_int_disable_all(cec);
+		mtk_cec_tx_int_clear_all(cec);
+		if ((cec->transmitting.msg->msg[0] & 0x0f) ==
+			CEC_LOG_ADDR_BROADCAST)
+			MTK_CEC_LOG("CEC Brdcst message success\n");
+		else
+			MTK_CEC_LOG("CEC Direct message success\n");
+
+		cec->transmitting.status.tx_status = CEC_TX_COMPLETE;
+		schedule_work(&cec->cec_tx_work);
+	}
+	//}
+}
+
+static irqreturn_t mtk_cec_isr_thread(int irq, void *arg)
+{
+	//struct device *dev = arg;
+	//can.zeng todo verify
+	//struct mtk_cec *cec = dev_get_drvdata(dev);
+	struct mtk_cec *cec = mtk_global_cec;
+
+	MTK_CEC_LOG("status=0x%08x,en=0x%08x,irq=0x%08x\n",
+		mtk_cec_read(cec, CEC2_INT_STA),
+		mtk_cec_read(cec, CEC2_INT_EN),
+		(mtk_cec_read(cec, CEC2_INT_STA) &
+		mtk_cec_read(cec, CEC2_INT_EN)));
+
+	mtk_cec_rx_event_handler(cec);
+	mtk_cec_tx_event_handler(cec);
+
+	return IRQ_HANDLED;
+}
+
+static const struct cec_adap_ops mtk_hdmi_cec_adap_ops = {
+	.adap_enable = mtk_cec_adap_enable,
+	.adap_log_addr = mtk_cec_adap_log_addr,
+	.adap_transmit = mtk_cec_adap_transmit,
+};
+
+static int mtk_get_cec_clk(struct mtk_cec *cec,
+				struct device_node *np)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(mtk_cec_clk_names); i++) {
+		cec->clk[i] = of_clk_get_by_name(np,
+			mtk_cec_clk_names[i]);
+
+		if (IS_ERR(cec->clk[i]))
+			return PTR_ERR(cec->clk[i]);
+	}
+
+	return 0;
+}
+
+int mtk_cec_clk_enable(struct mtk_cec *cec, bool enable)
+{
+	int i, ret;
+
+	if (enable == true) {
+		for (i = 0; i < ARRAY_SIZE(mtk_cec_clk_names); i++) {
+			ret = clk_prepare_enable(cec->clk[i]);
+			if (ret) {
+				MTK_CEC_LOG("Failed to enable cec clk: %d\n", ret);
+				return ret;
+			}
+		}
+	} else {
+		for (i = 0; i < ARRAY_SIZE(mtk_cec_clk_names); i++)
+			clk_disable_unprepare(cec->clk[i]);
+	}
+
+	return 0;
+}
+
+static int mtk_cec_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct mtk_cec *cec;
+	struct resource *res;
+	struct device_node *np;
+	struct platform_device *hdmi_dev;
+	int ret;
+
+	cec = devm_kzalloc(dev, sizeof(*cec), GFP_KERNEL);
+	if (!cec)
+		return -ENOMEM;
+
+	np = of_parse_phandle(pdev->dev.of_node, "hdmi", 0);
+	if (!np) {
+		MTK_CEC_LOG("Failed to find hdmi node in CEC node\n");
+		return -ENODEV;
+	}
+	hdmi_dev = of_find_device_by_node(np);
+	if (!hdmi_dev) {
+		MTK_CEC_LOG("Failed to find hdmi platform device\n");
+		return -EPROBE_DEFER;
+	}
+	cec->notifier = cec_notifier_get(&hdmi_dev->dev);
+	if (!cec->notifier)
+		return -ENOMEM;
+
+	mtk_global_cec = cec;
+
+	platform_set_drvdata(pdev, cec);
+	spin_lock_init(&cec->lock);
+
+	ret = mtk_get_cec_clk(cec, dev->of_node);
+	if (ret) {
+		MTK_CEC_LOG("Failed to get clocks: %d\n", ret);
+		return ret;
+	}
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	cec->regs = devm_ioremap_resource(dev, res);
+	if (IS_ERR(cec->regs)) {
+		ret = PTR_ERR(cec->regs);
+		dev_err(dev, "Failed to ioremap cec: %d\n", ret);
+		return ret;
+	}
+
+	cec->irq = irq_of_parse_and_map(pdev->dev.of_node, 0);
+	/*can.zeng todo, where to free_irq*/
+	if (request_irq(cec->irq, mtk_cec_isr_thread,
+		IRQF_TRIGGER_HIGH, "cecirq", NULL) < 0)
+		MTK_CEC_LOG("request cec interrupt failed.\n");
+	else
+		MTK_CEC_LOG("request cec interrupt success\n");
+
+	cec->adap = cec_allocate_adapter(&mtk_hdmi_cec_adap_ops,
+					cec, "mtk-hdmi-cec",
+					CEC_CAP_TRANSMIT | CEC_CAP_PASSTHROUGH |
+					CEC_CAP_LOG_ADDRS | CEC_CAP_PHYS_ADDR, 1);
+
+	ret = PTR_ERR_OR_ZERO(cec->adap);
+	if (ret < 0) {
+		MTK_CEC_LOG("Failed to allocate cec adapter %d\n", ret);
+		return ret;
+	}
+
+	ret = cec_register_adapter(cec->adap, dev);
+	if (ret) {
+		MTK_CEC_LOG("Fail to register cec adapter\n");
+		cec_delete_adapter(cec->adap);
+		return ret;
+	}
+
+	cec_register_cec_notifier(cec->adap, cec->notifier);
+
+	INIT_WORK(&cec->cec_tx_work, mtk_cec_tx_work_handle);
+	INIT_WORK(&cec->cec_rx_work, mtk_cec_rx_work_handle);
+
+	cec->cec_enabled = false;
+
+	return 0;
+}
+
+static int mtk_cec_remove(struct platform_device *pdev)
+{
+	int i;
+	struct mtk_cec *cec = platform_get_drvdata(pdev);
+
+	cec_unregister_adapter(cec->adap);
+	cec_notifier_put(cec->notifier);
+
+	for (i = 0; i < ARRAY_SIZE(mtk_cec_clk_names); i++)
+		clk_disable_unprepare(cec->clk[i]);
+	return 0;
+}
+
+struct mtk_hdmi_cec_data {
+	bool support_cec;
+};
+
+static const struct mtk_hdmi_cec_data mt8195_cec_data = {
+	.support_cec = true,
+};
+
+static const struct of_device_id mtk_cec_of_ids[] = {
+	{ .compatible = "mediatek,mt8195-cec",
+	  .data = &mt8195_cec_data},
+	  {},
+};
+
+MODULE_DEVICE_TABLE(of, mtk_cec_of_ids);
+
+
+struct platform_driver mtk_cec_driver = {
+	.probe = mtk_cec_probe,
+	.remove = mtk_cec_remove,
+	.driver = {
+		.name = "mediatek-cec",
+		.of_match_table = mtk_cec_of_ids,
+	},
+};
+
+MODULE_AUTHOR("Can Zeng <can.zeng@mediatek.com>");
+MODULE_DESCRIPTION("MediaTek HDMI Driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/gpu/drm/mediatek/mediatek_v2/mtk_cec.h b/drivers/gpu/drm/mediatek/mediatek_v2/mtk_cec.h
new file mode 100644
index 0000000000000000000000000000000000000000..bbc39ed249ade80bd7e011ba45b64a647736c3de
--- /dev/null
+++ b/drivers/gpu/drm/mediatek/mediatek_v2/mtk_cec.h
@@ -0,0 +1,342 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2019 MediaTek Inc.
+ */
+
+#ifndef _MTK_CEC_H
+#define _MTK_CEC_H
+
+#include <linux/cec.h>
+#include <uapi/linux/cec.h>
+#include <media/cec.h>
+#include <media/cec-notifier.h>
+
+
+/***** New CEC IP HW START*******/
+#define CEC2_TR_CONFIG		0x00
+#define CEC2_RX_CHK_DST			BIT(29)
+#define CEC2_BYPASS				BIT(28)
+#define CEC2_DEVICE_ADDR3			(0xf << 16)
+#define CEC2_LA3_SHIFT			16
+#define CEC2_DEVICE_ADDR2			(0xf << 20)
+#define CEC2_LA2_SHIFT			20
+#define CEC2_DEVICE_ADDR1			(0xf << 24)
+#define CEC2_LA1_SHIFT			24
+#define CEC2_RX_ACK_ERROR_BYPASS		BIT(13)
+#define CEC2_RX_ACK_ERROR_HANDLE		BIT(12)
+#define CEC2_RX_DATA_ACK			BIT(11)
+#define CEC2_RX_HEADER_ACK			BIT(10)
+#define CEC2_RX_HEADER_TRIG_INT_EN		BIT(9)
+#define CEC2_RX_ACK_SEL			BIT(8)
+#define CEC2_TX_RESET_WRITE				BIT(1)
+#define CEC2_TX_RESET_READ				BIT(0)
+#define CEC2_RX_RESET_WRITE				BIT(0)
+#define CEC2_RX_RESET_READ				BIT(1)
+
+#define CEC2_CKGEN		0x04
+#define CEC2_CLK_TX_EN			BIT(20)
+#define CEC2_CLK_32K_EN			BIT(19)
+#define CEC2_CLK_27M_EN			BIT(18)
+#define CEC2_CLK_SEL_DIV			BIT(17)
+#define CEC2_CLK_PDN				BIT(16)
+#define CEC2_CLK_DIV				(0xffff << 0)
+#define CEC2_DIV_SEL_100K		0x82
+
+#define CEC2_RX_TIMER_START_R	0x08
+#define CEC2_RX_TIMER_START_R_MAX		(0x7ff << 16)
+#define CEC2_RX_TIMER_START_R_MIN		(0x7ff)
+
+#define CEC2_RX_TIMER_START_F	0x0c
+#define CEC2_RX_TIMER_START_F_MAX		(0x7ff << 16)
+#define CEC2_RX_TIMER_START_F_MIN		(0x7ff)
+
+#define CEC2_RX_TIMER_DATA		0x10
+#define CEC2_RX_TIMER_DATA_F_MAX		(0x7ff << 16)
+#define CEC2_RX_TIMER_DATA_F_MIN		(0x7ff)
+
+#define CEC2_RX_TIMER_ACK		0x14
+#define CEC2_RX_TIMER_DATA_SAMPLE		(0x7ff << 16)
+#define CEC2_RX_TIMER_ACK_R			0x7ff
+
+#define CEC2_RX_TIMER_ERROR		0x18
+#define CEC2_RX_TIMER_ERROR_D		(0x7ff << 16)
+
+#define CEC2_TX_TIMER_START		0x1c
+#define CEC2_TX_TIMER_START_F		(0x7ff << 16)
+#define CEC2_TX_TIMER_START_F_SHIFT	16
+#define CEC2_TX_TIMER_START_R		(0x7ff)
+
+#define CEC2_TX_TIMER_DATA_R		0x20
+#define CEC2_TX_TIMER_BIT1_R			(0x7ff << 16)
+#define CEC2_TX_TIMER_BIT1_R_SHIFT	16
+#define CEC2_TX_TIMER_BIT0_R			(0x7ff)
+
+#define CEC2_TX_T_DATA_F			0x24
+#define CEC2_TX_TIMER_DATA_BIT		(0x7ff << 16)
+#define CEC2_TX_TIMER_DATA_BIT_SHIFT	16
+#define CEC2_TX_TIMER_DATA_F			(0x7ff)
+
+#define TX_TIMER_DATA_S		0x28
+#define CEC2_TX_COMP_CNT					(0x7ff << 16)
+#define CEC2_TX_TIMER_DATA_SAMPLE		(0x7ff)
+
+#define CEC2_TX_ARB		0x2c
+#define CEC2_TX_MAX_RETRANSMIT_NUM_ARB		GENMASK(29, 24)
+#define CEC2_TX_MAX_RETRANSMIT_NUM_COL		GENMASK(23, 20)
+#define CEC2_TX_MAX_RETRANSMIT_NUM_NAK		GENMASK(19, 16)
+#define CEC2_TX_BCNT_RETRANSMIT				GENMASK(11, 8)
+#define CEC2_TX_BCNT_NEW_MSG				GENMASK(7, 4)
+#define CEC2_TX_BCNT_NEW_INIT				GENMASK(3, 0)
+
+#define CEC2_TX_HEADER		0x30
+#define CEC2_TX_READY			BIT(16)
+#define CEC2_TX_SEND_CNT			(0xf << 12)
+#define CEC2_TX_HEADER_EOM			BIT(8)
+#define CEC2_TX_HEADER_DST			(0x0f)
+#define CEC2_TX_HEADER_SRC			(0xf0)
+
+#define CEC2_TX_DATA0		0x34
+#define CEC2_TX_DATA_B3			(0xff << 24)
+#define CEC2_TX_DATA_B2			(0xff << 16)
+#define CEC2_TX_DATA_B1			(0xff << 8)
+#define CEC2_TX_DATA_B0			(0xff)
+
+#define CEC2_TX_DATA1		0x38
+#define CEC2_TX_DATA_B7			(0xff << 24)
+#define CEC2_TX_DATA_B6			(0xff << 16)
+#define CEC2_TX_DATA_B5			(0xff << 8)
+#define CEC2_TX_DATA_B4			(0xff)
+
+#define CEC2_TX_DATA2		0x3c
+#define CEC2_TX_DATA_B11			(0xff << 24)
+#define CEC2_TX_DATA_B10			(0xff << 16)
+#define CEC2_TX_DATA_B9			(0xff << 8)
+#define CEC2_TX_DATA_B8			(0xff)
+
+#define CEC2_TX_DATA3		0x40
+#define CEC2_TX_DATA_B15			(0xff << 24)
+#define CEC2_TX_DATA_B14			(0xff << 16)
+#define CEC2_TX_DATA_B13			(0xff << 8)
+#define CEC2_TX_DATA_B12			(0xff)
+
+#define CEC2_TX_TIMER_ACK		0x44
+#define CEC2_TX_TIMER_ACK_MAX		GENMASK(26, 16)
+#define CEC2_TX_TIMER_ACK_MIN		GENMASK(15, 0)
+
+#define CEC2_LINE_DET		0x48
+#define CEC2_TIMER_LOW_LONG			GENMASK(31, 16)
+#define CEC2_TIMER_HIGH_LONG		GENMASK(15, 0)
+
+#define CEC2_RX_BUF_HEADER		0x4c
+#define CEC2_RX_BUF_RISC_ACK			BIT(16)
+#define CEC2_RX_BUF_CNT			(0xf << 12)
+#define CEC2_RX_HEADER_EOM			BIT(8)
+#define	CEC2_RX_HEADER_SRC			(0xf << 4)
+#define CEC2_RX_HEADER_DST			(0xf)
+
+#define CEC2_RX_DATA0		0x50
+#define CEC2_RX_DATA_B3			(0xff << 24)
+#define CEC2_RX_DATA_B2			(0xff << 16)
+#define CEC2_RX_DATA_B1			(0xff << 8)
+#define CEC2_RX_DATA_B0			(0xff)
+
+#define CEC2_RX_DATA1		0x54
+#define CEC2_RX_DATA_B7			(0xff << 24)
+#define CEC2_RX_DATA_B6			(0xff << 16)
+#define CEC2_RX_DATA_B5			(0xff << 8)
+#define CEC2_RX_DATA_B4			(0xff)
+
+#define CEC2_RX_DATA2		0x58
+#define CEC2_RX_DATA_B11			(0xff << 24)
+#define CEC2_RX_DATA_B10			(0xff << 16)
+#define CEC2_RX_DATA_B9			(0xff << 8)
+#define CEC2_RX_DATA_B8			(0xff)
+
+#define CEC2_RX_DATA3		0x5c
+#define CEC2_RX_DATA_B15			(0xff << 24)
+#define CEC2_RX_DATA_B14			(0xff << 16)
+#define CEC2_RX_DATA_B13			(0xff << 8)
+#define CEC2_RX_DATA_B12			(0xff)
+
+#define CEC2_RX_STATUS		0x60
+#define CEC2_CEC_INPUT			BIT(31)
+#define CEC2_RX_FSM				GENMASK(22, 16)
+#define CEC2_RX_BIT_COUNTER		(0xf << 12)
+#define CEC2_RX_TIMER			(0x7ff)
+
+#define CEC2_TX_STATUS		0x64
+#define CEC2_TX_NUM_RETRANSMIT	GENMASK(31, 26)
+#define CEC2_TX_FSM				GENMASK(24, 16)
+#define CEC2_TX_BIT_COUNTER		(0xf << 12)
+#define CEC2_TX_TIMER			(0x7ff)
+
+#define CEC2_BACK		0x70
+#define CEC2_RGS_BACK			GENMASK(31, 21)
+#define CEC2_TX_LAST_ERR_STA		GENMASK(24, 16)
+#define CEC2_REG_BACK			GENMASK(15, 0)
+
+#define CEC2_INT_CLR			0x74
+#define CEC2_INT_CLR_ALL			GENMASK(23, 0)
+#define CEC2_RX_INT_ALL_CLR			GENMASK(23, 16)
+#define CEC2_TX_INT_FAIL_CLR		(GENMASK(14, 9) | BIT(7))
+#define CEC2_TX_INT_ALL_CLR (CEC2_TX_INT_FAIL_CLR | BIT(15) | BIT(8))
+#define CEC2_RX_FSM_CHG_INT_CLR		BIT(23)
+#define CEC2_RX_ACK_FAIL_INT_CLR		BIT(22)
+#define CEC2_RX_ERROR_HANDLING_INT_CLR	BIT(21)
+#define CEC2_RX_BUF_FULL_INT_CLR		BIT(20)
+#define CEC2_RX_STAGE_READY_INT_CLR		BIT(19)
+#define CEC2_RX_DATA_RCVD_INT_CLR		BIT(18)
+#define CEC2_RX_HEADER_RCVD_INT_CLR		BIT(17)
+#define CEC2_TX_FSM_CHG_INT_CLR		BIT(15)
+#define CEC2_TX_FAIL_DATA_ACK_INT_CLR	BIT(14)
+#define CEC2_TX_FAIL_HEADER_ACK_INT_CLR	BIT(13)
+#define CEC2_TX_FAIL_RETRANSMIT_INT_CLR	BIT(12)
+#define CEC2_TX_FAIL_DATA_INT_CLR		BIT(11)
+#define CEC2_TX_FAIL_HEADER_INT_CLR		BIT(10)
+#define CEC2_TX_FAIL_SRC_INT_CLR		BIT(9)
+#define CEC2_TX_DATA_FINISH_INT_CLR		BIT(8)
+#define CEC2_LINE_lOW_LONG_INT_CLR		BIT(7)
+#define CEC2_LINE_HIGH_LONG_INT_CLR		BIT(6)
+#define CEC2_PORD_FAIL_INT_CLR		BIT(5)
+#define CEC2_PORD_RISE_INT_CLR		BIT(4)
+#define CEC2_HTPLG_FAIL_INT_CLR		BIT(3)
+#define CEC2_HTPLG_RISE_INT_CLR		BIT(2)
+#define CEC2_FAIL_INT_CLR		BIT(1)
+#define CEC2_RISE_INT_CLR		BIT(0)
+
+#define CEC2_INT_EN			0x78
+#define CEC2_INT_ALL_EN		GENMASK(31, 0)
+#define CEC2_RX_INT_ALL_EN		GENMASK(23, 16)
+#define CEC2_TX_INT_FAIL_EN		(GENMASK(14, 9) | BIT(7))
+#define CEC2_TX_INT_ALL_EN		(CEC2_TX_INT_FAIL_EN | BIT(15) | BIT(8))
+#define CEC2_RX_FSM_CHG_INT_EN		BIT(23)
+#define CEC2_RX_ACK_FAIL_INT_EN		BIT(22)
+#define CEC2_RX_ERROR_HANDLING_INT_EN	BIT(21)
+#define CEC2_RX_BUF_FULL_INT_EN		BIT(20)
+#define CEC2_RX_STAGE_READY_INT_EN		BIT(19)
+#define CEC2_RX_DATA_RCVD_INT_EN		BIT(18)
+#define CEC2_RX_HEADER_RCVD_INT_EN		BIT(17)
+#define CEC2_RX_BUF_READY_INT_EN		BIT(16)
+#define CEC2_TX_FSM_CHG_INT_EN		BIT(15)
+#define CEC2_TX_FAIL_DATA_ACK_INT_EN		BIT(14)
+#define CEC2_TX_FAIL_HEADER_ACK_INT_EN	BIT(13)
+#define CEC2_TX_FAIL_RETRANSMIT_INT_EN	BIT(12)
+#define CEC2_TX_FAIL_DATA_INT_EN		BIT(11)
+#define CEC2_TX_FAIL_HEADER_INT_EN		BIT(10)
+#define CEC2_TX_FAIL_SRC_INT_EN		BIT(9)
+#define CEC2_TX_DATA_FINISH_INT_EN		BIT(8)
+#define CEC2_LINE_lOW_LONG_INT_EN		BIT(7)
+#define CEC2_LINE_HIGH_LONG_INT_EN		BIT(6)
+#define CEC2_PORD_FAIL_INT_EN		BIT(5)
+#define CEC2_PORD_RISE_INT_EN		BIT(4)
+#define CEC2_HTPLG_FAIL_INT_EN		BIT(3)
+#define CEC2_HTPLG_RISE_INT_EN		BIT(2)
+#define CEC2_FALL_INT_EN			BIT(1)
+#define CEC2_RISE_INT_EN			BIT(0)
+
+#define CEC2_INT_STA			0x7c
+#define CEC2_TRX_INT_STA		GENMASK(23, 0)
+#define CEC2_TX_INT_FAIL		(GENMASK(14, 9) | BIT(7))
+#define CEC2_RX_FSM_CHG_INT_STA		BIT(23)
+#define CEC2_RX_ACK_FAIL_INT_STA		BIT(22)
+#define CEC2_RX_ERROR_HANDLING_INT_STA	BIT(21)
+#define CEC2_RX_BUF_FULL_INT_STA		BIT(20)
+#define CEC2_RX_STAGE_READY_INT_STA		BIT(19)
+#define CEC2_RX_DATA_RCVD_INT_STA		BIT(18)
+#define CEC2_RX_HEADER_RCVD_INT_STA		BIT(17)
+#define CEC2_RX_BUF_READY_INT_STA		BIT(16)
+#define CEC2_TX_FSM_CHG_INT_STA		BIT(15)
+#define CEC2_TX_FAIL_DATA_ACK_INT_STA	BIT(14)
+#define CEC2_TX_FAIL_HEADER_ACK_INT_STA	BIT(13)
+#define CEC2_TX_FAIL_RETRANSMIT_INT_STA	BIT(12)
+#define CEC2_TX_FAIL_DATA_INT_STA		BIT(11)
+#define CEC2_TX_FAIL_HEADER_INT_STA		BIT(10)
+#define CEC2_TX_FAIL_SRC_INT_STA		BIT(9)
+#define CEC2_TX_DATA_FINISH_INT_STA		BIT(8)
+#define CEC2_LINE_lOW_LONG_INT_STA		BIT(7)
+#define CEC2_LINE_HIGH_LONG_INT_STA		BIT(6)
+#define CEC2_PORD_FAIL_INT_STA		BIT(5)
+#define CEC2_PORD_RISE_INT_STA		BIT(4)
+#define CEC2_HTPLG_FAIL_INT_STA		BIT(3)
+#define CEC2_HTPLG_RISE_INT_STA		BIT(2)
+#define CEC2_FAlL_INT_STA		BIT(1)
+#define CEC2_RISE_INT_STA		BIT(0)
+/***** register map end*******/
+
+#define CEC_HEADER_BLOCK_SIZE 1
+
+enum mtk_cec_clk_id {
+	MTK_CEC_66M_H,
+	MTK_CEC_66M_B,
+	MTK_HDMI_32K,
+	MTK_HDMI_26M,
+	MTK_CEC_CLK_COUNT,
+};
+
+enum cec_tx_status {
+	CEC_TX_START,
+	CEC_TX_Transmitting,
+	CEC_TX_COMPLETE,
+	CEC_TX_FAIL,
+	CEC_TX_FAIL_DNAK,
+	CEC_TX_FAIL_HNAK,
+	CEC_TX_FAIL_RETR,
+	CEC_TX_FAIL_DATA,
+	CEC_TX_FAIL_HEAD,
+	CEC_TX_FAIL_SRC,
+	CEC_TX_FAIL_LOW,
+	CEC_TX_STATUS_NUM,
+};
+
+enum cec_rx_status {
+	CEC_RX_START,
+	CEC_RX_Receiving,
+	CEC_RX_COMPLETE,
+	CEC_RX_FAIL,
+	CEC_RX_STATUS_NUM,
+};
+
+struct cec_frame {
+	struct cec_msg *msg;
+	unsigned char retry_count;
+	union {
+		enum cec_tx_status tx_status;
+		enum cec_rx_status rx_status;
+	} status;
+};
+
+struct mtk_cec {
+	void __iomem *regs;
+	struct clk *clk[MTK_CEC_CLK_COUNT];
+	int irq;
+	struct device *hdmi_dev;
+	spinlock_t lock;
+	struct cec_adapter *adap;
+	struct cec_notifier	*notifier;
+	struct cec_frame transmitting;
+	struct cec_frame received;
+	struct cec_msg rx_msg;	/* dynamic alloc or fixed memory?? */
+	bool cec_enabled;
+	struct work_struct cec_tx_work;
+	struct work_struct cec_rx_work;
+};
+
+enum cec_inner_clock {
+	CLK_27M_SRC = 0,
+};
+
+enum cec_la_num {
+	DEVICE_ADDR_1 = 1,
+	DEVICE_ADDR_2 = 2,
+	DEVICE_ADDR_3 = 3,
+};
+
+struct cec_msg_header_block {
+	unsigned char destination:4;
+	unsigned char initiator:4;
+};
+
+int mtk_cec_clk_enable(struct mtk_cec *cec, bool enable);
+extern struct mtk_cec *mtk_global_cec;
+
+#endif /* _MTK_CEC_H */
diff --git a/drivers/gpu/drm/mediatek/mediatek_v2/mtk_debug.h b/drivers/gpu/drm/mediatek/mediatek_v2/mtk_debug.h
new file mode 100644
index 0000000000000000000000000000000000000000..0a7ba65bbd0078b89540975aba4f75fc49927ee6
--- /dev/null
+++ b/drivers/gpu/drm/mediatek/mediatek_v2/mtk_debug.h
@@ -0,0 +1,49 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2019 MediaTek Inc.
+ */
+
+#ifndef __MTKFB_DEBUG_H
+#define __MTKFB_DEBUG_H
+
+#define LOGGER_BUFFER_SIZE (16 * 1024)
+#define ERROR_BUFFER_COUNT 4
+#define FENCE_BUFFER_COUNT 22
+#define DEBUG_BUFFER_COUNT 30
+#define DUMP_BUFFER_COUNT 10
+#define STATUS_BUFFER_COUNT 1
+#if defined(CONFIG_MT_ENG_BUILD) || !defined(CONFIG_MTK_GMO_RAM_OPTIMIZE)
+#define DEBUG_BUFFER_SIZE                                                      \
+	(4096 +                                                                \
+	 (ERROR_BUFFER_COUNT + FENCE_BUFFER_COUNT + DEBUG_BUFFER_COUNT +       \
+	  DUMP_BUFFER_COUNT + STATUS_BUFFER_COUNT) *                           \
+		 LOGGER_BUFFER_SIZE)
+#else
+#define DEBUG_BUFFER_SIZE 10240
+#endif
+
+extern int mtk_disp_hrt_bw_dbg(void);
+
+#ifdef _DRM_P_H_
+struct disp_rect {
+	u32 x;
+	u32 y;
+	u32 width;
+	u32 height;
+};
+void disp_dbg_probe(void);
+void disp_dbg_init(struct drm_device *drm_dev);
+void disp_dbg_deinit(void);
+int mtk_dprec_mmp_dump_ovl_layer(struct mtk_plane_state *plane_state);
+int disp_met_set(void *data, u64 val);
+void mtk_drm_idlemgr_kick_ext(const char *source);
+unsigned int mtk_dbg_get_lfr_mode_value(void);
+unsigned int mtk_dbg_get_lfr_type_value(void);
+unsigned int mtk_dbg_get_lfr_enable_value(void);
+unsigned int mtk_dbg_get_lfr_update_value(void);
+unsigned int mtk_dbg_get_lfr_vse_dis_value(void);
+unsigned int mtk_dbg_get_lfr_skip_num_value(void);
+unsigned int mtk_dbg_get_lfr_dbg_value(void);
+#endif
+
+#endif
diff --git a/drivers/gpu/drm/mediatek/mediatek_v2/mtk_hdmi.c b/drivers/gpu/drm/mediatek/mediatek_v2/mtk_hdmi.c
new file mode 100644
index 0000000000000000000000000000000000000000..296c17440b7c4184155a24d0e7646059381fc5e2
--- /dev/null
+++ b/drivers/gpu/drm/mediatek/mediatek_v2/mtk_hdmi.c
@@ -0,0 +1,3257 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2019 MediaTek Inc.
+ */
+
+
+#include <linux/arm-smccc.h>
+#include <linux/delay.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/mfd/syscon.h>
+#include <linux/of_platform.h>
+#include <linux/of.h>
+#include <linux/of_irq.h>
+#include <linux/of_gpio.h>
+#include <linux/of_graph.h>
+#include <linux/phy/phy.h>
+#include <linux/kthread.h>
+#include <linux/timer.h>
+#include <linux/pm_wakeup.h>
+
+#include <drm/drm_scdc_helper.h>
+#include <drm/drm_displayid.h>
+#include <drm/drm_probe_helper.h>
+
+#include "mtk_drm_crtc.h"
+#include "mtk_hdmi_ddc.h"
+#include "mtk_hdmi_phy.h"
+#include "mtk_cec.h"
+#include "mtk_ethdr.h"
+#include "mtk_hdmi.h"
+#include "mtk_hdmi_regs.h"
+#include "mtk_log.h"
+#include "mtk_hdmi_hdcp.h"
+#include "mtk_hdmi_ca.h"
+#include "mtk_hdmi_debug.h"
+#include "mtk_hdmi_hdr.h"
+#include "mtk_hdmi_edid.h"
+
+#include <linux/debugfs.h>
+
+static const char * const mtk_hdmi_clk_names[MTK_HDMI_CLK_COUNT] = {
+	[MTK_HDMI_CLK_HDMI_TXPLL] = "txpll",
+	[MTK_HDMI_CLK_UNIVPLL_D6D4] = "univpll_d6_d4",
+	[MTK_HDMI_CLK_MSDCPLL_D2] = "msdcpll_d2",
+	[MTK_HDMI_CLK_HDMI_APB_SEL] = "hdmi_apb_sel",
+	[MTK_HDMI_UNIVPLL_D4D8] = "univpll_d4_d8",
+	[MTK_HDIM_HDCP_SEL] = "hdcp_sel",
+	[MTK_HDMI_HDCP_24M_SEL] = "hdcp24_sel",
+	[MTK_HDMI_VPP_SPLIT_HDMI] = "split_hdmi",
+};
+
+//can.zeng todo verify
+struct mtk_hdmi *global_mtk_hdmi;
+
+unsigned char mtk_hdmi_log = 1;
+
+#define HDMI_LOG(fmt, arg...) \
+	do {	if (mtk_hdmi_log) { \
+		pr_debug("[HDMI] %s,%d "fmt, __func__, __LINE__, ##arg); \
+		} \
+	} while (0)
+
+#define HDMI_FUNC()	\
+	do {	if (mtk_hdmi_log) \
+		pr_debug("[HDMI] %s\n", __func__); \
+	} while (0)
+
+static inline struct mtk_hdmi *hdmi_ctx_from_bridge(struct drm_bridge *b)
+{
+	return container_of(b, struct mtk_hdmi, bridge);
+}
+
+static inline struct mtk_hdmi *hdmi_ctx_from_conn(struct drm_connector *c)
+{
+	return container_of(c, struct mtk_hdmi, conn);
+}
+
+struct mtk_hdmi_ddc *hdmi_ddc_ctx_from_mtk_hdmi(struct mtk_hdmi *hdmi)
+{
+	return container_of(hdmi->ddc_adpt, struct mtk_hdmi_ddc, adap);
+}
+
+
+u32 mtk_hdmi_read(struct mtk_hdmi *hdmi, u32 offset)
+{
+	return readl(hdmi->regs + offset);
+}
+
+void mtk_hdmi_write(struct mtk_hdmi *hdmi, u32 offset, u32 val)
+{
+	writel(val, hdmi->regs + offset);
+}
+
+static inline void mtk_hdmi_clear_bits(struct mtk_hdmi *hdmi,
+	u32 offset, u32 bits)
+{
+	void __iomem *reg = hdmi->regs + offset;
+	u32 tmp;
+
+	tmp = readl(reg);
+	tmp &= ~bits;
+	writel(tmp, reg);
+}
+
+static inline void mtk_hdmi_set_bits(struct mtk_hdmi *hdmi,
+	u32 offset, u32 bits)
+{
+	void __iomem *reg = hdmi->regs + offset;
+	u32 tmp;
+
+	tmp = readl(reg);
+	tmp |= bits;
+	writel(tmp, reg);
+}
+
+void mtk_hdmi_mask(struct mtk_hdmi *hdmi,
+	u32 offset, u32 val, u32 mask)
+{
+	void __iomem *reg = hdmi->regs + offset;
+	u32 tmp;
+
+	tmp = readl(reg);
+	tmp = (tmp & ~mask) | (val & mask);
+	writel(tmp, reg);
+}
+
+static inline void mtk_hdmi_clr_all_int_status(struct mtk_hdmi *hdmi)
+{
+	/*clear all tx irq*/
+	mtk_hdmi_write(hdmi, TOP_INT_CLR00, 0xffffffff);
+	mtk_hdmi_write(hdmi, TOP_INT_CLR00, 0x00000000);
+	mtk_hdmi_write(hdmi, TOP_INT_CLR01, 0xffffffff);
+	mtk_hdmi_write(hdmi, TOP_INT_CLR01, 0x00000000);
+}
+
+static inline void mtk_hdmi_disable_all_int(struct mtk_hdmi *hdmi)
+{
+	/*disable all tx irq*/
+	mtk_hdmi_write(hdmi, TOP_INT_MASK00, 0x00000000);
+	mtk_hdmi_write(hdmi, TOP_INT_MASK01, 0x00000000);
+}
+
+static inline void mtk_hdmi_en_hdcp_reauth_int(
+	struct mtk_hdmi *hdmi,  bool enable)
+{
+	if (enable == true)
+		mtk_hdmi_mask(hdmi, TOP_INT_MASK00,
+			HDCP2X_RX_REAUTH_REQ_DDCM_INT_UNMASK,
+			HDCP2X_RX_REAUTH_REQ_DDCM_INT_UNMASK);
+	else
+		mtk_hdmi_mask(hdmi, TOP_INT_MASK00,
+			HDCP2X_RX_REAUTH_REQ_DDCM_INT_MASK,
+			HDCP2X_RX_REAUTH_REQ_DDCM_INT_UNMASK);
+}
+
+inline void mtk_hdmi_enable_hpd_pord_irq(struct mtk_hdmi *hdmi, bool enable)
+{
+	if (enable == true)
+		mtk_hdmi_mask(hdmi, TOP_INT_MASK00, 0x0000000f, 0x0000000f);
+	else
+		mtk_hdmi_mask(hdmi, TOP_INT_MASK00, 0x00000000, 0x0000000f);
+}
+
+inline void mtk_hdmi_clr_htplg_pord_irq(struct mtk_hdmi *hdmi)
+{
+	mtk_hdmi_mask(hdmi, TOP_INT_CLR00, 0x0000000f, 0x0000000f);
+	mtk_hdmi_mask(hdmi, TOP_INT_CLR00, 0x00000000, 0x0000000f);
+}
+
+inline void mtk_hdmi_set_sw_hpd(struct mtk_hdmi *hdmi, bool high)
+{
+	if (high == true)
+		mtk_hdmi_mask(hdmi, HDMITX_CONFIG, 0x1 << HDMITX_SW_HPD_SHIFT, HDMITX_SW_HPD);
+	else
+		mtk_hdmi_mask(hdmi, HDMITX_CONFIG, 0x0 << HDMITX_SW_HPD_SHIFT, HDMITX_SW_HPD);
+}
+
+//can.zeng modification done->void HDMIForceHDCPHPCLevel(void)
+static inline void mtk_hdmi_force_hdcp_hpd(struct mtk_hdmi *hdmi)
+{
+	/* force HDCP HPD to 1*/
+	mtk_hdmi_mask(hdmi, HDCP2X_CTRL_0, HDCP2X_HPD_OVR, HDCP2X_HPD_OVR);
+	mtk_hdmi_mask(hdmi, HDCP2X_CTRL_0, HDCP2X_HPD_SW, HDCP2X_HPD_SW);
+}
+
+
+//can.zeng modification done->void vDisable_HDCP_Encrypt(void)
+void mtk_hdmi_disable_hdcp_encrypt(struct mtk_hdmi *hdmi)
+{
+	HDMI_FUNC();
+
+	mtk_hdmi_mask(hdmi, HDCP2X_CTRL_0,
+		0x0 << HDCP2X_ENCRYPT_EN_SHIFT, HDCP2X_ENCRYPT_EN);
+	mtk_hdmi_mask(hdmi, HDCP1X_CTRL,
+		0x0 << HDCP1X_ENC_EN_SHIFT, HDCP1X_ENC_EN);
+}
+
+void mtk_hdmi_yuv420_downsample(struct mtk_hdmi *hdmi, bool enable)
+{
+	HDMI_FUNC();
+
+	if (enable == true) {
+		HDMI_LOG("Color Space: YUV420 downsample\n");
+		mtk_hdmi_mask(hdmi, HDMITX_CONFIG,
+			HDMI_YUV420_MODE | HDMITX_SW_HPD, HDMI_YUV420_MODE | HDMITX_SW_HPD);
+		mtk_hdmi_mask(hdmi, VID_DOWNSAMPLE_CONFIG,
+			C444_C422_CONFIG_ENABLE, C444_C422_CONFIG_ENABLE);
+		mtk_hdmi_mask(hdmi, VID_DOWNSAMPLE_CONFIG,
+			C422_C420_CONFIG_ENABLE, C422_C420_CONFIG_ENABLE);
+		mtk_hdmi_mask(hdmi, VID_DOWNSAMPLE_CONFIG,
+			0, C422_C420_CONFIG_BYPASS);
+		mtk_hdmi_mask(hdmi, VID_DOWNSAMPLE_CONFIG,
+			C422_C420_CONFIG_OUT_CB_OR_CR,
+			C422_C420_CONFIG_OUT_CB_OR_CR);
+		mtk_hdmi_mask(hdmi, VID_OUT_FORMAT,
+			OUTPUT_FORMAT_DEMUX_420_ENABLE,
+			OUTPUT_FORMAT_DEMUX_420_ENABLE);
+	} else {
+		HDMI_LOG("Color Space: not YUV420 downsample\n");
+		mtk_hdmi_mask(hdmi, HDMITX_CONFIG,
+			0 | HDMITX_SW_HPD, HDMI_YUV420_MODE | HDMITX_SW_HPD);
+		mtk_hdmi_mask(hdmi, VID_DOWNSAMPLE_CONFIG,
+			0, C444_C422_CONFIG_ENABLE);
+		mtk_hdmi_mask(hdmi, VID_DOWNSAMPLE_CONFIG,
+			0, C422_C420_CONFIG_ENABLE);
+		mtk_hdmi_mask(hdmi, VID_DOWNSAMPLE_CONFIG,
+			C422_C420_CONFIG_BYPASS, C422_C420_CONFIG_BYPASS);
+		mtk_hdmi_mask(hdmi, VID_DOWNSAMPLE_CONFIG,
+			0, C422_C420_CONFIG_OUT_CB_OR_CR);
+		mtk_hdmi_mask(hdmi, VID_OUT_FORMAT,
+			0, OUTPUT_FORMAT_DEMUX_420_ENABLE);
+	}
+}
+
+bool mtk_hdmi_tmds_over_340M(struct mtk_hdmi *hdmi)
+{
+	unsigned long pixel_clk, tmds_clk;
+
+	HDMI_FUNC();
+
+	pixel_clk = hdmi->mode.clock * 1000;//in HZ
+
+/* TMDS clk frequency */
+	if (hdmi->color_depth == HDMI_8_BIT)
+		tmds_clk = pixel_clk;
+	else if (hdmi->color_depth == HDMI_10_BIT)
+		tmds_clk = pixel_clk * 5 / 4; // *1.25
+	else if (hdmi->color_depth == HDMI_12_BIT)
+		tmds_clk = pixel_clk * 3 / 2; // *1.5
+	else if (hdmi->color_depth == HDMI_16_BIT)
+		tmds_clk = pixel_clk * 2; // *2
+	else {
+		HDMI_LOG("%s, unknown color depth\n", __func__);
+		return -EINVAL;
+	}
+	if ((tmds_clk >= 340000000) && (hdmi->csp != HDMI_COLORSPACE_YUV420)) {
+		HDMI_LOG("TMDS over 340M!\n");
+		return true;
+	}
+	HDMI_LOG("TMDS under 340M\n");
+	return false;
+}
+
+static inline void mtk_hdmi_enable_scrambling(
+	struct mtk_hdmi *hdmi, bool enable)
+{
+	/* DDC write scrambing enable */
+	//drm_scdc_set_scrambling(hdmi->ddc_adpt, enable);
+	udelay(100);
+
+	if (enable == true)
+		mtk_hdmi_mask(hdmi, TOP_CFG00, SCR_ON | HDMI2_ON,
+			SCR_ON | HDMI2_ON);
+	else
+		mtk_hdmi_mask(hdmi, TOP_CFG00, SCR_OFF | HDMI2_OFF,
+			SCR_ON | HDMI2_ON);
+}
+
+static inline void mtk_hdmi_high_tmds_clock_ratio(
+	struct mtk_hdmi *hdmi, bool enable)
+{
+	/* DDC write scrambing enable */
+	//drm_scdc_set_high_tmds_clock_ratio(hdmi->ddc_adpt, enable);
+	/* hw set high bit clock ratio*/
+	mtk_tmds_high_bit_clk_ratio(hdmi, enable);
+}
+
+//can.zeng modification verify-> void hdmi_config_ref_clock(int resolution)
+void mtk_hdmi_480p_576p_setting(struct mtk_hdmi *hdmi)
+{
+	//can.zeng need to verify
+/*
+ *	switch (resolutionmode) {
+ *	case HDMI_VIDEO_720x480p_60Hz:
+ *	case HDMI_VIDEO_720x576p_50Hz:
+ *	case HDMI_VIDEO_720x480i_60Hz:
+ *	case HDMI_VIDEO_720x576i_50Hz:
+ *		vWriteHdmiSYSMsk(0x228, 1 << 16, 1 << 16);
+ *		break;
+ *
+ *	default:
+ *		vWriteHdmiSYSMsk(0x228, 0 << 16, 1 << 16);
+ *		break;
+ *	}
+ */
+	if (((hdmi->mode.hdisplay == 720) && (hdmi->mode.vdisplay == 480)) ||
+		((hdmi->mode.hdisplay == 720) && (hdmi->mode.vdisplay == 576)))
+		; /* vWriteHdmiSYSMsk(0x228, 1 << 16, 1 << 16); can.zeng*/
+	else
+		; /* vWriteHdmiSYSMsk(0x228, 0 << 16, 1 << 16); can.zeng*/
+
+}
+
+//can.zeng done -> void vBlackHDMIOnly(),void vUnBlackHDMIOnly()
+void mtk_hdmi_hw_vid_black(struct mtk_hdmi *hdmi, bool black)
+{
+	if (black == true)
+		mtk_hdmi_mask(hdmi, TOP_VMUTE_CFG1, REG_VMUTE_EN, REG_VMUTE_EN);
+	else
+		mtk_hdmi_mask(hdmi, TOP_VMUTE_CFG1, 0, REG_VMUTE_EN);
+}
+
+//can.zeng modification done->void MuteHDMIAudio(void)
+void mtk_hdmi_hw_aud_mute(struct mtk_hdmi *hdmi)
+{
+	HDMI_FUNC();
+
+	if (mtk_hdmi_read(hdmi, AIP_CTRL) & DSD_EN)
+		mtk_hdmi_mask(hdmi, AIP_TXCTRL,
+			DSD_MUTE_DATA | AUD_MUTE_FIFO_EN,
+			DSD_MUTE_DATA | AUD_MUTE_FIFO_EN);
+	else
+		mtk_hdmi_mask(hdmi, AIP_TXCTRL,	AUD_MUTE_FIFO_EN,
+		AUD_MUTE_FIFO_EN);
+}
+
+//can.zeng modification done->void UnMuteHDMIAudio(void)
+void mtk_hdmi_hw_aud_unmute(struct mtk_hdmi *hdmi)
+{
+	mtk_hdmi_mask(hdmi, AIP_TXCTRL, AUD_MUTE_DIS, AUD_MUTE_FIFO_EN);
+}
+
+void mtk_hdmi_AV_mute(struct mtk_hdmi *hdmi)
+{
+	mtk_hdmi_hw_aud_mute(hdmi);
+	mtk_hdmi_hw_vid_black(hdmi, true);
+}
+
+void mtk_hdmi_AV_unmute(struct mtk_hdmi *hdmi)
+{
+	mtk_hdmi_hw_aud_unmute(hdmi);
+	mtk_hdmi_hw_vid_black(hdmi, false);
+}
+
+//can.zeng modification done-> void vResetHDMI(char bRst)
+static void mtk_hdmi_hw_reset(struct mtk_hdmi *hdmi)
+{
+	HDMI_FUNC();
+	mtk_hdmi_mask(hdmi, HDMITX_CONFIG,
+		0x0 << HDMITX_SW_RSTB_SHIFT, HDMITX_SW_RSTB);
+	udelay(1);
+	mtk_hdmi_mask(hdmi, HDMITX_CONFIG,
+		0x1 << HDMITX_SW_RSTB_SHIFT, HDMITX_SW_RSTB);
+}
+
+//can.zeng modification done->void vEnableHdmiMode(char bOn)
+static void mtk_hdmi_enable_hdmi_mode(struct mtk_hdmi *hdmi, bool enable)
+{
+	if (enable == true) {
+		mtk_hdmi_mask(hdmi, TOP_CFG00, HDMI_MODE_HDMI, HDMI_MODE_HDMI);
+		HDMI_LOG("HDMI Mode\n");
+	} else {
+		mtk_hdmi_mask(hdmi, TOP_CFG00, HDMI_MODE_DVI, HDMI_MODE_HDMI);
+		HDMI_LOG("DVI Mode\n");
+	}
+}
+
+//can.zeng modification done->bool fgTVisHDMI(void)
+static bool mtk_hdmi_sink_is_hdmi_device(struct mtk_hdmi *hdmi)
+{
+	if (hdmi->dvi_mode == true)
+		return false;
+	else
+		return true;
+}
+
+//can.zeng modification done->void vEnableDeepColor()
+static void mtk_hdmi_set_deep_color(struct mtk_hdmi *hdmi,
+	bool is_hdmi_sink)
+{
+	unsigned int deep_color = 0;
+
+	HDMI_FUNC();
+
+	if (hdmi->csp == HDMI_COLORSPACE_YUV422) {
+		//ycbcr422 12bit not deep color
+		deep_color = DEEPCOLOR_MODE_8BIT;
+	} else {
+		if (hdmi->color_depth == HDMI_8_BIT) {
+			deep_color = DEEPCOLOR_MODE_8BIT;
+			HDMI_LOG("not DEEP COLOR\n");
+		} else if (hdmi->color_depth == HDMI_10_BIT) {
+			deep_color = DEEPCOLOR_MODE_10BIT;
+			HDMI_LOG("DEEP COLOR 10-bit\n");
+		} else if (hdmi->color_depth == HDMI_12_BIT) {
+			deep_color = DEEPCOLOR_MODE_12BIT;
+			HDMI_LOG("DEEP COLOR 12-bit\n");
+		} else if (hdmi->color_depth == HDMI_16_BIT) {
+			deep_color = DEEPCOLOR_MODE_16BIT;
+			HDMI_LOG("DEEP COLOR 16-bit\n");
+		} else {
+			HDMI_LOG("color depth err\n");
+			WARN_ON(1);
+		}
+	}
+	mtk_hdmi_mask(hdmi, TOP_CFG00, deep_color, DEEPCOLOR_MODE_MASKBIT);
+
+	/* GCP */
+	mtk_hdmi_mask(hdmi, TOP_CFG00, 0, DEEPCOLOR_PAT_EN);
+	if ((is_hdmi_sink == true) && (deep_color != DEEPCOLOR_MODE_8BIT))
+		mtk_hdmi_mask(hdmi, TOP_MISC_CTLR, DEEP_COLOR_ADD,
+			DEEP_COLOR_ADD);
+	else
+		mtk_hdmi_mask(hdmi, TOP_MISC_CTLR, 0, DEEP_COLOR_ADD);
+}
+
+//can.zeng done->void vHalSendAudioInfoFrame()
+static void mtk_hdmi_hw_audio_infoframe(
+	struct mtk_hdmi *hdmi, u8 *buffer, u8 len)
+{
+	enum hdmi_infoframe_type frame_type;
+	u8 frame_ver;
+	u8 frame_len;
+	u8 checksum;
+
+	frame_type = buffer[0];
+	frame_ver = buffer[1];
+	frame_len = buffer[2];
+	checksum = buffer[3];
+
+	HDMI_LOG("frame_type:0x%x,version:0x%x,length:0x%x,checksum:0x%x\n",
+		frame_type, frame_ver, frame_len, checksum);
+
+	mtk_hdmi_mask(hdmi, TOP_INFO_EN, AUD_DIS_WR | AUD_DIS,
+		AUD_EN_WR | AUD_EN);
+	mtk_hdmi_mask(hdmi, TOP_INFO_RPT, AUD_RPT_DIS, AUD_RPT_EN);
+
+	mtk_hdmi_write(hdmi, TOP_AIF_HEADER, (frame_len << 16) +
+		(frame_ver << 8) + (frame_type << 0));
+	mtk_hdmi_write(hdmi, TOP_AIF_PKT00,
+		(buffer[6] << 24) + (buffer[5] << 16) +
+		(buffer[4] << 8) + (buffer[3] << 0));
+	mtk_hdmi_write(hdmi, TOP_AIF_PKT01,
+		(buffer[8] << 8) + (buffer[7] << 0));
+	mtk_hdmi_write(hdmi, TOP_AIF_PKT02, 0);
+	mtk_hdmi_write(hdmi, TOP_AIF_PKT03, 0);
+
+	mtk_hdmi_mask(hdmi, TOP_INFO_RPT, AUD_RPT_EN, AUD_RPT_EN);
+	mtk_hdmi_mask(hdmi, TOP_INFO_EN, AUD_EN_WR | AUD_EN,
+		AUD_EN_WR | AUD_EN);
+
+}
+
+//can.zeng done->void vHalSendAVIInfoFrame(unsigned char *pr_bData)
+static void mtk_hdmi_hw_avi_infoframe(
+	struct mtk_hdmi *hdmi, u8 *buffer, u8 len)
+{
+
+	enum hdmi_infoframe_type frame_type = buffer[0];
+	u8 frame_ver = buffer[1];
+	u8 frame_len = buffer[2];
+	u8 checksum = buffer[3];
+
+	HDMI_LOG("frame_type:0x%x,version:0x%x,length:0x%x,checksum:0x%x\n",
+		frame_type, frame_ver, frame_len, checksum);
+
+	mtk_hdmi_mask(hdmi, TOP_INFO_EN, AVI_DIS_WR | AVI_DIS,
+		AVI_EN_WR | AVI_EN);
+	mtk_hdmi_mask(hdmi, TOP_INFO_RPT, AVI_RPT_DIS, AVI_RPT_EN);
+
+	mtk_hdmi_write(hdmi, TOP_AVI_HEADER, (buffer[2] << 16) +
+		(buffer[1] << 8) + (buffer[0] << 0));
+
+	mtk_hdmi_write(hdmi, TOP_AVI_PKT00,
+		(buffer[6] << 24) + (buffer[5] << 16) +
+		(buffer[4] << 8) + (buffer[3] << 0));
+
+	mtk_hdmi_write(hdmi, TOP_AVI_PKT01,
+		(buffer[9] << 16) + (buffer[8] << 8) +
+		(buffer[7] << 0));
+
+	mtk_hdmi_write(hdmi, TOP_AVI_PKT02,
+		(buffer[13] << 24) + (buffer[12] << 16) +
+		(buffer[11] << 8) + (buffer[10] << 0));
+
+	mtk_hdmi_write(hdmi, TOP_AVI_PKT03,
+		(buffer[16] << 16) + (buffer[15] << 8) +
+		(buffer[14] << 0));
+
+	mtk_hdmi_write(hdmi, TOP_AVI_PKT04, 0);
+	mtk_hdmi_write(hdmi, TOP_AVI_PKT05, 0);
+
+	mtk_hdmi_mask(hdmi, TOP_INFO_RPT, AVI_RPT_EN, AVI_RPT_EN);
+	mtk_hdmi_mask(hdmi, TOP_INFO_EN, AVI_EN_WR | AVI_EN,
+		AVI_EN_WR | AVI_EN);
+
+}
+
+static void mtk_hdmi_hw_spd_infoframe(struct mtk_hdmi *hdmi, u8 *buffer,
+					u8 len)
+{
+	enum hdmi_infoframe_type frame_type = buffer[0];
+	u8 frame_ver = buffer[1];
+	u8 frame_len = buffer[2];
+	u8 checksum = buffer[3];
+
+	HDMI_LOG("frame_type:0x%x,version:0x%x,length:0x%x,checksum:0x%x\n",
+		frame_type, frame_ver, frame_len, checksum);
+
+	mtk_hdmi_mask(hdmi, TOP_INFO_EN, SPD_DIS_WR | SPD_DIS,
+		SPD_EN_WR | SPD_EN);
+	mtk_hdmi_mask(hdmi, TOP_INFO_RPT, SPD_RPT_DIS, SPD_RPT_EN);
+
+	mtk_hdmi_write(hdmi, TOP_SPDIF_HEADER, (buffer[2] << 16) +
+		(buffer[1] << 8) + (buffer[0] << 0));
+
+	mtk_hdmi_write(hdmi, TOP_SPDIF_PKT00,
+		(buffer[6] << 24) + (buffer[5] << 16) +
+		(buffer[4] << 8) + (buffer[3] << 0));
+
+	mtk_hdmi_write(hdmi, TOP_SPDIF_PKT01,
+		(buffer[9] << 16) + (buffer[8] << 8) +
+		(buffer[7] << 0));
+
+	mtk_hdmi_write(hdmi, TOP_SPDIF_PKT02,
+		(buffer[13] << 24) + (buffer[12] << 16) +
+		(buffer[11] << 8) + (buffer[10] << 0));
+
+	mtk_hdmi_write(hdmi, TOP_SPDIF_PKT03,
+		(buffer[16] << 16) + (buffer[15] << 8) +
+		(buffer[14] << 0));
+
+	mtk_hdmi_write(hdmi, TOP_SPDIF_PKT04,
+		(buffer[20] << 24) + (buffer[19] << 16) +
+		(buffer[18] << 8) + (buffer[17] << 0));
+
+	mtk_hdmi_write(hdmi, TOP_SPDIF_PKT05,
+		(buffer[23] << 16) + (buffer[22] << 8) +
+		(buffer[21] << 0));
+
+	mtk_hdmi_write(hdmi, TOP_SPDIF_PKT06,
+		(buffer[27] << 24) + (buffer[26] << 16) +
+		(buffer[25] << 8) + (buffer[24] << 0));
+
+	mtk_hdmi_write(hdmi, TOP_SPDIF_PKT07,
+		(buffer[30] << 16) + (buffer[29] << 8) +
+		(buffer[28] << 0));
+
+	mtk_hdmi_mask(hdmi, TOP_INFO_RPT, SPD_RPT_EN, SPD_RPT_EN);
+	mtk_hdmi_mask(hdmi, TOP_INFO_EN, SPD_EN_WR | SPD_EN,
+		SPD_EN_WR | SPD_EN);
+
+}
+
+/*for 3D and standard Dolby Vision info;
+ *low-latency dolby vision use Dolby VSIF
+ */
+ //can.zeng todo verify the buffer length
+static void mtk_hdmi_hw_h14b_vsif(
+	struct mtk_hdmi *hdmi, u8 *buffer, u8 len)
+{
+
+	enum hdmi_infoframe_type frame_type = buffer[0];
+	u8 frame_ver = buffer[1];
+	u8 frame_len = buffer[2];
+	u8 checksum = buffer[3];
+
+	HDMI_LOG("frame_type:0x%x,version:0x%x,length:0x%x,checksum:0x%x\n",
+		frame_type, frame_ver, frame_len, checksum);
+
+	mtk_hdmi_mask(hdmi, TOP_INFO_EN, VSIF_DIS | VSIF_DIS_WR,
+		VSIF_EN | VSIF_EN_WR);
+	mtk_hdmi_mask(hdmi, TOP_INFO_RPT, VSIF_RPT_DIS, VSIF_RPT_EN);
+
+	mtk_hdmi_write(hdmi, TOP_VSIF_HEADER,
+		(buffer[2] << 16) + (buffer[1] << 8) +
+		(buffer[0] << 0));
+
+	mtk_hdmi_write(hdmi, TOP_VSIF_PKT00,
+		(buffer[6] << 24) + (buffer[5] << 16) +
+		(buffer[4] << 8) + (buffer[3] << 0));
+	mtk_hdmi_write(hdmi, TOP_VSIF_PKT01,
+		(buffer[8] << 8) + (buffer[7] << 0));
+
+	mtk_hdmi_write(hdmi, TOP_VSIF_PKT02, 0);
+	mtk_hdmi_write(hdmi, TOP_VSIF_PKT03, 0);
+	mtk_hdmi_write(hdmi, TOP_VSIF_PKT04, 0);
+	mtk_hdmi_write(hdmi, TOP_VSIF_PKT05, 0);
+	mtk_hdmi_write(hdmi, TOP_VSIF_PKT06, 0);
+	mtk_hdmi_write(hdmi, TOP_VSIF_PKT07, 0);
+
+	mtk_hdmi_mask(hdmi, TOP_INFO_RPT, VSIF_RPT_EN, VSIF_RPT_EN);
+	mtk_hdmi_mask(hdmi, TOP_INFO_EN, VSIF_EN | VSIF_EN_WR,
+		VSIF_EN | VSIF_EN_WR);
+}
+
+//can.zeng todo verify, which TOP_GEN_PCK to be used?
+static void mtk_hdmi_hw_hf_vsif(
+	struct mtk_hdmi *hdmi/*, u8 *buffer, u8 len*/)
+{
+
+}
+
+//can.zeng modification done
+static int mtk_hdmi_setup_audio_infoframe(struct mtk_hdmi *hdmi)
+{
+	struct hdmi_codec_params *params = &hdmi->aud_param.codec_params;
+	struct hdmi_audio_infoframe frame;
+	u8 buffer[14];
+	ssize_t err;
+
+	pr_info("HDMI_CODEC_PARAMS: audio infoframe\n");
+	pr_info("type %d\n", params->cea.type);
+	pr_info("version %d\n", params->cea.version);
+	pr_info("length %d\n", params->cea.length);
+	pr_info("channels %d\n", params->cea.channels);
+	pr_info("coding_type %d\n", params->cea.coding_type);
+	pr_info("sample_size %d\n", params->cea.sample_size);
+	pr_info("sample_frequency %d\n", params->cea.sample_frequency);
+	pr_info("coding_type_ext %d\n", params->cea.coding_type_ext);
+	pr_info("channel_allocation %d\n", params->cea.channel_allocation);
+
+	memcpy(&frame, &hdmi->aud_param.codec_params.cea, sizeof(struct hdmi_audio_infoframe));
+
+	err = hdmi_audio_infoframe_pack(&frame, buffer, sizeof(buffer));
+	if (err < 0) {
+		HDMI_LOG("Failed to pack audio infoframe: %zd\n", err);
+		return err;
+	}
+
+	mtk_hdmi_hw_audio_infoframe(hdmi, buffer, sizeof(buffer));
+	return 0;
+}
+
+#define H14bVSIF_DOLBYVISION_LENGTH  0x18
+
+//can.zeng todo add special process:
+//1: 4K defined in HDMI 1.4 spec
+//2: 3D defined in HDMI 1.4 spec
+//3: DolbyVision indicated by HDMI14b VSIF
+int mtk_hdmi_setup_h14b_vsif(struct mtk_hdmi *hdmi,
+						struct drm_display_mode *mode)
+{
+	struct hdmi_vendor_infoframe frame;
+	u8 buffer[22];
+	ssize_t err;
+	unsigned char check_sum;
+	int i;
+
+	err = drm_hdmi_vendor_infoframe_from_display_mode(
+		&frame, &hdmi->conn, mode);
+	if (err) {
+		HDMI_LOG("Failed to get VSIF from mode: %zd\n", err);
+		return err;
+	}
+
+	err = hdmi_vendor_infoframe_pack(&frame, buffer, sizeof(buffer));
+	if (err < 0) {
+		HDMI_LOG("Failed to pack VSIF: %zd\n", err);
+		return err;
+	}
+
+	//special process for DolbyVision H14b Vsif
+	if (_fgDolbyHdrEnable) {
+		buffer[2] = H14bVSIF_DOLBYVISION_LENGTH;
+		buffer[3] = 0; // firstly, make checksum = 0
+		/* re-calculate checksum */
+		for (i = 0, check_sum = 0; i < sizeof(buffer); i++)
+			check_sum += buffer[i];
+		check_sum = 0x100 - check_sum;
+		buffer[3] = check_sum;
+	}
+
+	mtk_hdmi_hw_h14b_vsif(hdmi, buffer, sizeof(buffer));
+	return 0;
+}
+
+//can.zeng todo function'implementation
+static int mtk_hdmi_setup_hf_vsif(struct mtk_hdmi *hdmi,
+	struct drm_display_mode *mode)
+{
+	mtk_hdmi_hw_hf_vsif(hdmi);
+
+	return 0;
+}
+
+//can.zeng modification done->void vAudioPacketOff(unsigned char bOn)
+void mtk_hdmi_hw_send_aud_packet(struct mtk_hdmi *hdmi, bool enable)
+{
+	if (enable == false) {
+		mtk_hdmi_mask(hdmi, AIP_TXCTRL, AUD_PACKET_DROP,
+			AUD_PACKET_DROP);
+		HDMI_LOG("audio packet Off\n");
+	} else {
+		mtk_hdmi_mask(hdmi, AIP_TXCTRL, 0, AUD_PACKET_DROP);
+		HDMI_LOG("audio packet On\n");
+	}
+}
+
+//can.zeng modification done-> void vSend_AVMUTE(void)
+static inline void mtk_hdmi_hw_send_av_mute(struct mtk_hdmi *hdmi)
+{
+	/*GCP packet */
+	HDMI_FUNC();
+
+	mtk_hdmi_mask(hdmi, TOP_CFG01, 0, CP_CLR_MUTE_EN);
+	mtk_hdmi_mask(hdmi, TOP_CFG01, 0, CP_SET_MUTE_EN);
+	mtk_hdmi_mask(hdmi, TOP_INFO_RPT, 0, CP_RPT_EN);
+	mtk_hdmi_mask(hdmi, TOP_INFO_EN, 0, CP_EN | CP_EN_WR);
+
+	mtk_hdmi_mask(hdmi, TOP_CFG01, 0, CP_CLR_MUTE_EN);
+	mtk_hdmi_mask(hdmi, TOP_CFG01, CP_SET_MUTE_EN, CP_SET_MUTE_EN);
+	mtk_hdmi_mask(hdmi, TOP_INFO_RPT, CP_RPT_EN, CP_RPT_EN);
+	mtk_hdmi_mask(hdmi, TOP_INFO_EN, CP_EN | CP_EN_WR, CP_EN | CP_EN_WR);
+
+}
+
+//can.zeng modification done-> void vSend_AVUNMUTE(void)
+static inline void mtk_hdmi_hw_send_av_unmute(struct mtk_hdmi *hdmi)
+{
+	/*GCP packet */
+	HDMI_FUNC();
+
+	mtk_hdmi_mask(hdmi, TOP_CFG01, 0, CP_CLR_MUTE_EN);
+	mtk_hdmi_mask(hdmi, TOP_CFG01, 0, CP_SET_MUTE_EN);
+	mtk_hdmi_mask(hdmi, TOP_INFO_RPT, 0, CP_RPT_EN);
+	mtk_hdmi_mask(hdmi, TOP_INFO_EN, 0, CP_EN | CP_EN_WR);
+
+	mtk_hdmi_mask(hdmi, TOP_CFG01, CP_CLR_MUTE_EN, CP_CLR_MUTE_EN);
+	mtk_hdmi_mask(hdmi, TOP_CFG01, 0, CP_SET_MUTE_DIS);
+	mtk_hdmi_mask(hdmi, TOP_INFO_RPT, CP_RPT_EN, CP_RPT_EN);
+	mtk_hdmi_mask(hdmi, TOP_INFO_EN, CP_EN | CP_EN_WR, CP_EN | CP_EN_WR);
+
+}
+
+static void mtk_hdmi_hw_ncts_enable(struct mtk_hdmi *hdmi, bool enable)
+{
+	unsigned int data;
+
+	data = mtk_hdmi_read(hdmi, AIP_CTRL);
+
+	if (enable == false)
+		data |= CTS_SW_SEL;
+	else
+		data &= ~CTS_SW_SEL;
+
+	mtk_hdmi_write(hdmi, AIP_CTRL, data);
+}
+
+static void mtk_hdmi_hw_aud_set_channel_status(
+	struct mtk_hdmi *hdmi, u8 *channel_status)
+{
+	HDMI_LOG("Channel Status Bit: %x, %x, %x, %x, %x, %x, %x\n",
+		channel_status[0], channel_status[1], channel_status[2],
+		channel_status[3], channel_status[4], channel_status[5],
+		channel_status[6]);
+
+	/* actually, only the first 5 or 7 bytes of Channel Status
+	 * contain useful information
+	 */
+	mtk_hdmi_write(hdmi, AIP_I2S_CHST0,
+		(channel_status[3] << 24) + (channel_status[2] << 16) +
+		(channel_status[1] << 8) + (channel_status[0] << 0));
+	mtk_hdmi_write(hdmi, AIP_I2S_CHST1,
+		(channel_status[6] << 16) + (channel_status[5] << 8) +
+		(channel_status[4] << 0));
+}
+
+struct hdmi_acr_n {
+	unsigned int clock;
+	unsigned int n[3];
+};
+
+/* Recommended N values from HDMI specification, tables 7-1 to 7-3 */
+static const struct hdmi_acr_n hdmi_rec_n_table[] = {
+	/* Clock, N: 32kHz 44.1kHz 48kHz */
+	{  25175, {  4576,  7007,  6864 } },
+	{  74176, { 11648, 17836, 11648 } },
+	{ 148352, { 11648,  8918,  5824 } },
+	{ 296703, {  5824,  4459,  5824 } },
+	{ 297000, {  3072,  4704,  5120 } },
+	{      0, {  4096,  6272,  6144 } }, /* all other TMDS clocks */
+};
+
+/**
+ * hdmi_recommended_n() - Return N value recommended by HDMI specification
+ * @freq: audio sample rate in Hz
+ * @clock: rounded TMDS clock in kHz
+ */
+static unsigned int hdmi_recommended_n(unsigned int freq, unsigned int clock)
+{
+	const struct hdmi_acr_n *recommended;
+	unsigned int i;
+
+	for (i = 0; i < ARRAY_SIZE(hdmi_rec_n_table) - 1; i++) {
+		if (clock == hdmi_rec_n_table[i].clock)
+			break;
+	}
+	recommended = hdmi_rec_n_table + i;
+
+	switch (freq) {
+	case 32000:
+		return recommended->n[0];
+	case 44100:
+		return recommended->n[1];
+	case 48000:
+		return recommended->n[2];
+	case 88200:
+		return recommended->n[1] * 2;
+	case 96000:
+		return recommended->n[2] * 2;
+	case 176400:
+		return recommended->n[1] * 4;
+	case 192000:
+		return recommended->n[2] * 4;
+	default:
+		return (128 * freq) / 1000;
+	}
+}
+
+static unsigned int hdmi_mode_clock_to_hz(unsigned int clock)
+{
+	switch (clock) {
+	case 25175:
+		return 25174825;	/* 25.2/1.001 MHz */
+	case 74176:
+		return 74175824;	/* 74.25/1.001 MHz */
+	case 148352:
+		return 148351648;	/* 148.5/1.001 MHz */
+	case 296703:
+		return 296703297;	/* 297/1.001 MHz */
+	default:
+		return clock * 1000;
+	}
+}
+
+static unsigned int hdmi_expected_cts(unsigned int audio_sample_rate,
+				      unsigned int tmds_clock, unsigned int n)
+{
+	return DIV_ROUND_CLOSEST_ULL((u64)hdmi_mode_clock_to_hz(tmds_clock) * n,
+				     128 * audio_sample_rate);
+}
+
+static void mtk_hdmi_hw_aud_set_ncts(struct mtk_hdmi *hdmi,
+				     unsigned int sample_rate,
+				     unsigned int clock)
+{
+	unsigned int n, ncts;
+
+	n = hdmi_recommended_n(sample_rate, clock);
+	ncts = hdmi_expected_cts(sample_rate, clock, n);
+
+	HDMI_LOG("sample_rate=%u, clock=%d, ncts=%u, n=%u\n",
+		sample_rate, clock, n, ncts);
+
+	mtk_hdmi_write(hdmi, AIP_N_VAL, n);
+	mtk_hdmi_write(hdmi, AIP_CTS_SVAL, ncts);
+
+}
+
+static int mtk_hdmi_video_change_vpll(struct mtk_hdmi *hdmi, u32 clock)
+{
+	unsigned long rate;
+	int ret;
+
+	/* The DPI driver already should have set TVDPLL to the correct rate */
+	ret = clk_set_rate(hdmi->clk[MTK_HDMI_CLK_HDMI_TXPLL], clock);
+	if (ret) {
+		HDMI_LOG("Failed to set PLL to %u Hz: %d\n", clock, ret);
+		return ret;
+	}
+
+	rate = clk_get_rate(hdmi->clk[MTK_HDMI_CLK_HDMI_TXPLL]);
+
+	if (DIV_ROUND_CLOSEST(rate, 1000) != DIV_ROUND_CLOSEST(clock, 1000))
+		HDMI_LOG("Want PLL %u Hz, got %lu Hz\n", clock, rate);
+	else
+		HDMI_LOG("Want PLL %u Hz, got %lu Hz\n", clock, rate);
+
+	return 0;
+}
+
+static int mtk_hdmi_aud_enable_packet(struct mtk_hdmi *hdmi, bool enable)
+{
+	mtk_hdmi_hw_send_aud_packet(hdmi, enable);
+	return 0;
+}
+
+static int mtk_hdmi_aud_on_off_hw_ncts(struct mtk_hdmi *hdmi, bool on)
+{
+	mtk_hdmi_hw_ncts_enable(hdmi, on);
+	return 0;
+}
+
+//can.zeng done->void vSetHdmiDsdConfig()
+static void mtk_hdmi_audio_dsd_config(struct mtk_hdmi *hdmi,
+	unsigned char chNum, bool dsd_bypass)
+{
+	HDMI_FUNC();
+
+	mtk_hdmi_mask(hdmi, AIP_CTRL, DSD_EN, SPDIF_EN | DSD_EN | HBRA_ON);
+	mtk_hdmi_mask(hdmi, AIP_TXCTRL, DSD_MUTE_DATA, DSD_MUTE_DATA);
+	if (dsd_bypass == true)
+		mtk_hdmi_write(hdmi, TOP_AUD_MAP, 0x75316420);
+	/* 0x13570246 */
+	else
+		mtk_hdmi_write(hdmi, TOP_AUD_MAP, 0x04230150);
+	/* 0 FL;1 SL;2 CENT;3 FR;4 SR;5 LFE 0x32400510 */
+
+	/* rxtx bypass */
+	mtk_hdmi_mask(hdmi, AIP_SPDIF_CTRL, 0, I2S2DSD_EN);
+}
+
+//can.zeng done->void vSetHdmi2I2SfifoMap(unsigned int bFifoMap)
+static inline void mtk_hdmi_hw_i2s_fifo_map(struct mtk_hdmi *hdmi,
+	unsigned int fifo_mapping)
+{
+	mtk_hdmi_mask(hdmi, AIP_I2S_CTRL, fifo_mapping,
+		FIFO3_MAP |	FIFO2_MAP | FIFO1_MAP | FIFO0_MAP);
+}
+
+//can.zeng done-> void vSetHdmi2I2SCH(unsigned int bCH)
+static inline void mtk_hdmi_hw_i2s_ch_number(struct mtk_hdmi *hdmi,
+	unsigned int chNum)
+{
+	mtk_hdmi_mask(hdmi, AIP_CTRL, chNum << I2S_EN_SHIFT, I2S_EN);
+}
+
+
+//can.zeng done->void vSetHdmiI2SChNum()
+static void mtk_hdmi_hw_i2s_ch_mapping(struct mtk_hdmi *hdmi,
+	unsigned char chNum, unsigned char mapping)
+{
+	unsigned int bData, bData1, bData2, bData3;
+
+	if (chNum == 2) {	/* I2S 2ch */
+		bData = 0x1;	/* 2ch data */
+		bData1 = 0x50;	/* data0 */
+
+	} else if ((chNum == 3) || (chNum == 4)) {	/* I2S 2ch */
+		if ((chNum == 4) && (mapping == 0x08))
+			bData = 0x3;	/* 4ch data */
+		else
+			bData = 0x03;	/* 4ch data */
+
+		bData1 = 0x50;	/* data0 */
+
+	} else if ((chNum == 6) || (chNum == 5)) {	/* I2S 5.1ch */
+		if ((chNum == 6) && (mapping == 0x0E)) {
+			bData = 0xf;	/* 6.0 ch data */
+			bData1 = 0x50;	/* data0 */
+		} else {
+			bData = 0x7;	/* 5.1ch data, 5/0ch */
+			bData1 = 0x50;	/* data0 */
+		}
+
+	} else if (chNum == 8) {	/* I2S 5.1ch */
+		bData = 0xf;	/* 7.1ch data */
+		bData1 = 0x50;	/* data0 */
+	} else if (chNum == 7) {	/* I2S 6.1ch */
+		bData = 0xf;	/* 6.1ch data */
+		bData1 = 0x50;	/* data0 */
+	} else {
+		bData = 0x01;	/* 2ch data */
+		bData1 = 0x50;	/* data0 */
+	}
+
+	bData2 = 0xc6;
+	bData3 = 0xfa;
+
+	mtk_hdmi_hw_i2s_fifo_map(hdmi, (MAP_SD3 << 6) | (MAP_SD2 << 4) |
+		(MAP_SD1 << 2) | (MAP_SD0 << 0));
+	mtk_hdmi_hw_i2s_ch_number(hdmi, bData);
+
+	if (chNum == 2)
+		mtk_hdmi_mask(hdmi, AIP_TXCTRL, LAYOUT0, LAYOUT1);
+	else
+		mtk_hdmi_mask(hdmi, AIP_TXCTRL, LAYOUT1, LAYOUT1);
+
+}
+
+//can.zeng done->void vSetHdmiI2SDataFmt(unsigned char bFmt)
+static void mtk_hdmi_i2s_data_fmt(struct mtk_hdmi *hdmi,
+	unsigned char fmt)
+{
+	unsigned int u4Data;
+
+	HDMI_LOG("fmt = %d-------\n", fmt);
+
+	u4Data = mtk_hdmi_read(hdmi, AIP_I2S_CTRL);
+	HDMI_LOG("AIP_I2S_CTRL1 value = 0x%x-------\n", u4Data);
+	u4Data &= ~(WS_HIGH | I2S_1ST_BIT_NOSHIFT | JUSTIFY_RIGHT);
+
+	switch (fmt) {
+	case HDMI_I2S_MODE_RJT_24BIT:
+		u4Data |= (WS_HIGH | I2S_1ST_BIT_NOSHIFT | JUSTIFY_RIGHT);
+		break;
+
+	case HDMI_I2S_MODE_RJT_16BIT:
+		u4Data |= (WS_HIGH | I2S_1ST_BIT_NOSHIFT | JUSTIFY_RIGHT);
+		break;
+
+	case HDMI_I2S_MODE_LJT_24BIT:
+		u4Data |= (WS_HIGH | I2S_1ST_BIT_NOSHIFT);
+		break;
+
+	case HDMI_I2S_MODE_LJT_16BIT:
+		u4Data |= (WS_HIGH | I2S_1ST_BIT_NOSHIFT);
+		break;
+
+	case HDMI_I2S_MODE_I2S_24BIT:
+		break;
+
+	case HDMI_I2S_MODE_I2S_16BIT:
+		break;
+
+	default:
+		break;
+	}
+	mtk_hdmi_write(hdmi, AIP_I2S_CTRL, u4Data);
+
+	u4Data = mtk_hdmi_read(hdmi, AIP_I2S_CTRL);
+	HDMI_LOG("AIP_I2S_CTRL2 value = 0x%x-------\n", u4Data);
+}
+
+//can.zeng done->void vSetHdmiI2SSckEdge(unsigned int bEdge)
+static inline void mtk_hdmi_i2s_sck_edge(
+	struct mtk_hdmi *hdmi, unsigned int edge)
+{
+	mtk_hdmi_mask(hdmi, AIP_I2S_CTRL, edge, SCK_EDGE_RISE);
+}
+
+//can.zeng done->void vSetHdmiI2SCbitOrder(unsigned int bCbit)
+static inline void mtk_hdmi_i2s_cbit_order(
+	struct mtk_hdmi *hdmi, unsigned int cbit)
+{
+	mtk_hdmi_mask(hdmi, AIP_I2S_CTRL, cbit, CBIT_ORDER_SAME);
+}
+
+//can.zeng done->void vSetHdmiI2SVbit(unsigned int bVbit)
+static inline void mtk_hdmi_i2s_vbit(
+	struct mtk_hdmi *hdmi, unsigned int vbit)
+{
+	mtk_hdmi_mask(hdmi, AIP_I2S_CTRL, vbit, VBIT_COM);
+}
+
+//can.zeng done->void vSetHdmiI2SDataDir(unsigned int bDataDir)
+static inline void mtk_hdmi_i2s_data_direction(
+	struct mtk_hdmi *hdmi, unsigned int data_dir)
+{
+	mtk_hdmi_mask(hdmi, AIP_I2S_CTRL, data_dir, DATA_DIR_LSB);
+}
+
+//can.zeng done->void vEnableInputAudioType(unsigned int bspdifi2s)
+static inline void mtk_hdmi_hw_audio_type(
+	struct mtk_hdmi *hdmi, unsigned int spdif_i2s)
+{
+	mtk_hdmi_mask(hdmi, AIP_CTRL, spdif_i2s << SPDIF_EN_SHIFT, SPDIF_EN);
+}
+
+//can.zeng done->unsigned char bGetChannelMapping(void)
+//can.zeng done->void vUpdateAudSrcChType(unsigned char u1SrcChType)
+static unsigned char mtk_hdmi_get_i2s_ch_mapping(
+	struct mtk_hdmi *hdmi, unsigned char channel_type)
+{
+	unsigned char FR, FL, FC, LFE, RR, RL, RRC, RLC, RC;
+	unsigned char ch_number = 0;
+	unsigned char ChannelMap = 0x00;
+
+	switch (channel_type) {
+	case HDMI_AUD_CHAN_TYPE_1_0:
+	case HDMI_AUD_CHAN_TYPE_2_0:
+		FR = 1;
+		FL = 1;
+		LFE = 0;
+		ch_number = 2;
+		break;
+
+	case HDMI_AUD_CHAN_TYPE_1_1:
+	case HDMI_AUD_CHAN_TYPE_2_1:
+		FR = 1;
+		FL = 1;
+		LFE = 1;
+		ch_number = 3;
+		break;
+
+	case HDMI_AUD_CHAN_TYPE_3_0:
+		FR = 1;
+		FL = 1;
+		FC = 1;
+		LFE = 0;
+		ch_number = 3;
+		break;
+
+	case HDMI_AUD_CHAN_TYPE_3_0_LRS:
+		FR = 1;
+		FL = 1;
+		RR = 1;
+		RL = 1;
+		LFE = 0;
+		ch_number = 4;
+		break;
+
+	case HDMI_AUD_CHAN_TYPE_3_1_LRS:
+		FR = 1;
+		FL = 1;
+		FC = 0;
+		LFE = 1;
+		RR = 1;
+		RL = 1;
+		ch_number = 5;
+		break;
+
+	case HDMI_AUD_CHAN_TYPE_4_0_CLRS:
+		FR = 1;
+		FL = 1;
+		FC = 1;
+		LFE = 0;
+		RR = 1;
+		RL = 1;
+		ch_number = 5;
+		break;
+
+	case HDMI_AUD_CHAN_TYPE_4_1_CLRS:
+		FR = 1;
+		FL = 1;
+		FC = 1;
+		LFE = 1;
+		RR = 1;
+		RL = 1;
+		ch_number = 6;
+		break;
+
+	case HDMI_AUD_CHAN_TYPE_3_1:
+		FR = 1;
+		FL = 1;
+		FC = 1;
+		LFE = 1;
+		ch_number = 4;
+		break;
+
+	case HDMI_AUD_CHAN_TYPE_4_0:
+		FR = 1;
+		FL = 1;
+		RR = 1;
+		RL = 1;
+		LFE = 0;
+		ch_number = 4;
+		break;
+
+	case HDMI_AUD_CHAN_TYPE_4_1:
+		FR = 1;
+		FL = 1;
+		RR = 1;
+		RL = 1;
+		LFE = 1;
+		ch_number = 5;
+		break;
+
+	case HDMI_AUD_CHAN_TYPE_5_0:
+		FR = 1;
+		FL = 1;
+		FC = 1;
+		LFE = 0;
+		RR = 1;
+		RL = 1;
+		ch_number = 5;
+		break;
+
+	case HDMI_AUD_CHAN_TYPE_5_1:
+		FR = 1;
+		FL = 1;
+		FC = 1;
+		LFE = 1;
+		RR = 1;
+		RL = 1;
+		ch_number = 6;
+		break;
+
+	case HDMI_AUD_CHAN_TYPE_6_0:
+	case HDMI_AUD_CHAN_TYPE_6_0_CS:
+	case HDMI_AUD_CHAN_TYPE_6_0_CH:
+	case HDMI_AUD_CHAN_TYPE_6_0_OH:
+	case HDMI_AUD_CHAN_TYPE_6_0_CHR:
+		FR = 1;
+		FL = 1;
+		FC = 1;
+		LFE = 0;
+		RR = 1;
+		RL = 1;
+		RC = 1;
+		ch_number = 6;
+		break;
+
+	case HDMI_AUD_CHAN_TYPE_6_1:
+	case HDMI_AUD_CHAN_TYPE_6_1_CS:
+	case HDMI_AUD_CHAN_TYPE_6_1_CH:
+	case HDMI_AUD_CHAN_TYPE_6_1_OH:
+	case HDMI_AUD_CHAN_TYPE_6_1_CHR:
+		FR = 1;
+		FL = 1;
+		FC = 1;
+		LFE = 1;
+		RR = 1;
+		RL = 1;
+		RC = 1;
+		ch_number = 7;
+		break;
+
+	case HDMI_AUD_CHAN_TYPE_7_0:
+	case HDMI_AUD_CHAN_TYPE_7_0_LH_RH:
+	case HDMI_AUD_CHAN_TYPE_7_0_LSR_RSR:
+	case HDMI_AUD_CHAN_TYPE_7_0_LC_RC:
+	case HDMI_AUD_CHAN_TYPE_7_0_LW_RW:
+	case HDMI_AUD_CHAN_TYPE_7_0_LSD_RSD:
+	case HDMI_AUD_CHAN_TYPE_7_0_LSS_RSS:
+	case HDMI_AUD_CHAN_TYPE_7_0_LHS_RHS:
+	case HDMI_AUD_CHAN_TYPE_7_0_CS_CH:
+	case HDMI_AUD_CHAN_TYPE_7_0_CS_OH:
+	case HDMI_AUD_CHAN_TYPE_7_0_CS_CHR:
+	case HDMI_AUD_CHAN_TYPE_7_0_CH_OH:
+	case HDMI_AUD_CHAN_TYPE_7_0_CH_CHR:
+	case HDMI_AUD_CHAN_TYPE_7_0_OH_CHR:
+	case HDMI_AUD_CHAN_TYPE_7_0_LSS_RSS_LSR_RSR:
+	case HDMI_AUD_CHAN_TYPE_8_0_LH_RH_CS:
+		FR = 1;
+		FL = 1;
+		FC = 1;
+		LFE = 0;
+		RR = 1;
+		RL = 1;
+		RRC = 1;
+		RLC = 1;
+		ch_number = 7;
+		break;
+
+	case HDMI_AUD_CHAN_TYPE_7_1:
+	case HDMI_AUD_CHAN_TYPE_7_1_LH_RH:
+	case HDMI_AUD_CHAN_TYPE_7_1_LSR_RSR:
+	case HDMI_AUD_CHAN_TYPE_7_1_LC_RC:
+	case HDMI_AUD_CHAN_TYPE_7_1_LW_RW:
+	case HDMI_AUD_CHAN_TYPE_7_1_LSD_RSD:
+	case HDMI_AUD_CHAN_TYPE_7_1_LSS_RSS:
+	case HDMI_AUD_CHAN_TYPE_7_1_LHS_RHS:
+	case HDMI_AUD_CHAN_TYPE_7_1_CS_CH:
+	case HDMI_AUD_CHAN_TYPE_7_1_CS_OH:
+	case HDMI_AUD_CHAN_TYPE_7_1_CS_CHR:
+	case HDMI_AUD_CHAN_TYPE_7_1_CH_OH:
+	case HDMI_AUD_CHAN_TYPE_7_1_CH_CHR:
+	case HDMI_AUD_CHAN_TYPE_7_1_OH_CHR:
+	case HDMI_AUD_CHAN_TYPE_7_1_LSS_RSS_LSR_RSR:
+		FR = 1;
+		FL = 1;
+		FC = 1;
+		LFE = 1;
+		RR = 1;
+		RL = 1;
+		RRC = 1;
+		RLC = 1;
+		ch_number = 8;
+		break;
+
+	default:
+		FR = 1;
+		FL = 1;
+		ch_number = 2;
+		break;
+	}
+
+
+	switch (ch_number) {
+	case 8:
+		break;
+
+	case 7:
+		break;
+
+	case 6:
+		if ((FR == 1) && (FL == 1) && (FC == 1) &&
+			(RR == 1) && (RL == 1) && (RC == 1) &&
+			(LFE == 0)) {
+			/* 6.0 */
+			ChannelMap = 0x0E;
+		} else if ((FR == 1) && (FL == 1) && (FC == 1) &&
+			(RR == 1) && (RL == 1) && (RC == 0) && (LFE == 1)) {
+			/* 5.1 */
+			ChannelMap = 0x0B;
+		}
+		break;
+
+	case 5:
+		break;
+
+	case 4:
+		if ((FR == 1) && (FL == 1) && (RR == 1) &&
+		    (RL == 1) && (LFE == 0))
+			ChannelMap = 0x08;
+		else if ((FR == 1) && (FL == 1) && (FC == 1) &&
+			(LFE == 1))
+			ChannelMap = 0x03;
+		break;
+
+	case 3:
+		if ((FR == 1) && (FL == 1) && (FC == 1))
+			ChannelMap = 0x02;
+		else if ((FR == 1) && (FL == 1) && (LFE == 1))
+			ChannelMap = 0x01;
+		break;
+
+	case 2:
+		if ((FR == 1) && (FL == 1))
+			ChannelMap = 0x00;
+		break;
+
+	default:
+		break;
+	}
+
+	HDMI_LOG("Ch_Num=%d, FR %d, FL %d, FC %d, LFE %d\n",
+		ch_number, FR, FL, FC, LFE);
+	HDMI_LOG("RR %d, RL %d, RRC %d, RLC %d, RC %d\n",
+		RR, RL, RRC, RLC, RC);
+
+	return ChannelMap;
+}
+
+//can.zeng done->void vSetChannelSwap(unsigned char u1SwapBit)
+static inline void mtk_hdmi_hw_i2s_ch_swap(
+	struct mtk_hdmi *hdmi, unsigned char SwapBit)
+{
+	mtk_hdmi_mask(hdmi, AIP_SPDIF_CTRL, SwapBit << 20, 0x0F << 20);
+}
+
+//can.zeng done->void vSetHdmiHbrConfig(bool fgRxDsdBypass)
+static void mtk_hdmi_hbr_config(
+	struct mtk_hdmi *hdmi, bool dsd_bypass)
+{
+	if (dsd_bypass == true) {
+		mtk_hdmi_mask(hdmi, AIP_CTRL,
+			HBRA_ON, SPDIF_EN | DSD_EN | HBRA_ON);
+		mtk_hdmi_mask(hdmi, AIP_CTRL, I2S_EN, I2S_EN);
+	} else {
+		mtk_hdmi_mask(hdmi, AIP_CTRL,
+			SPDIF_EN, SPDIF_EN | DSD_EN | HBRA_ON);
+		mtk_hdmi_mask(hdmi, AIP_CTRL, SPDIF_INTERNAL_MODULE,
+			SPDIF_INTERNAL_MODULE);
+		mtk_hdmi_mask(hdmi, AIP_CTRL, HBR_FROM_SPDIF, HBR_FROM_SPDIF);
+		mtk_hdmi_mask(hdmi, AIP_CTRL, CTS_CAL_N4, CTS_CAL_N4);
+
+		/* can.zeng todo verify what is following setting for */
+		/* vWriteHdmiTOPCKMsk(0xe8, (0x1 << 11),
+		 *	(0x1 << 12) | (0x1 << 11));
+		 */
+	}
+}
+
+//can.zeng done->void vSetHdmiSpdifConfig(void)
+static inline void mtk_hdmi_hw_spdif_config(struct mtk_hdmi *hdmi)
+{
+	mtk_hdmi_mask(hdmi, AIP_SPDIF_CTRL, WR_1UI_UNLOCK, WR_1UI_LOCK);
+	mtk_hdmi_mask(hdmi, AIP_SPDIF_CTRL, FS_UNOVERRIDE, FS_OVERRIDE_WRITE);
+	mtk_hdmi_mask(hdmi, AIP_SPDIF_CTRL, WR_2UI_UNLOCK, WR_2UI_LOCK);
+	mtk_hdmi_mask(hdmi, AIP_SPDIF_CTRL, 0x4 <<
+		MAX_1UI_WRITE_SHIFT, MAX_1UI_WRITE);
+	mtk_hdmi_mask(hdmi, AIP_SPDIF_CTRL, 0x9 <<
+		MAX_2UI_WRITE_SHIFT, MAX_2UI_WRITE);
+	mtk_hdmi_mask(hdmi, AIP_SPDIF_CTRL, 0x4 <<
+		AUD_ERR_THRESH_SHIFT, AUD_ERR_THRESH);
+	mtk_hdmi_mask(hdmi, AIP_SPDIF_CTRL, I2S2DSD_EN, I2S2DSD_EN);
+}
+
+//can.zeng modification done->void vSetHDMIAudioIn(void)
+static int mtk_hdmi_aud_set_input(struct mtk_hdmi *hdmi)
+{
+	unsigned char ChMapping;
+
+	HDMI_FUNC();
+
+	mtk_hdmi_write(hdmi, TOP_AUD_MAP,
+			  C_SD7 + C_SD6 + C_SD5 + C_SD4 +
+			  C_SD3 + C_SD2 + C_SD1 + C_SD0);
+	mtk_hdmi_mask(hdmi, AIP_SPDIF_CTRL, 0, 0x0F << 20);
+	mtk_hdmi_mask(hdmi, AIP_CTRL, 0, SPDIF_EN | DSD_EN | HBRA_ON |
+			 CTS_CAL_N4 | HBR_FROM_SPDIF | SPDIF_INTERNAL_MODULE);
+	mtk_hdmi_mask(hdmi, AIP_TXCTRL, 0, DSD_MUTE_DATA | LAYOUT1);
+
+	if (hdmi->aud_param.aud_input_type == HDMI_AUD_INPUT_I2S) {
+		if (hdmi->aud_param.aud_codec == HDMI_AUDIO_CODING_TYPE_DSD) {
+			mtk_hdmi_audio_dsd_config(hdmi,
+				hdmi->aud_param.codec_params.channels, 0);
+			mtk_hdmi_hw_i2s_ch_mapping(hdmi,
+				hdmi->aud_param.codec_params.channels, 1);
+		} else {
+			mtk_hdmi_i2s_data_fmt(hdmi,
+				hdmi->aud_param.aud_i2s_fmt);
+			mtk_hdmi_i2s_sck_edge(hdmi, SCK_EDGE_RISE);
+			mtk_hdmi_i2s_cbit_order(hdmi, CBIT_ORDER_SAME);
+			mtk_hdmi_i2s_vbit(hdmi, VBIT_PCM);
+			mtk_hdmi_i2s_data_direction(hdmi, DATA_DIR_MSB);
+			mtk_hdmi_hw_audio_type(hdmi, HDMI_AUD_INPUT_I2S);
+			ChMapping = mtk_hdmi_get_i2s_ch_mapping(hdmi,
+				hdmi->aud_param.aud_input_chan_type);
+			mtk_hdmi_hw_i2s_ch_mapping(hdmi,
+				hdmi->aud_param.codec_params.channels,
+				ChMapping);
+			mtk_hdmi_hw_i2s_ch_swap(hdmi, LFE_CC_SWAP);
+		}
+	} else {
+		if ((hdmi->aud_param.aud_input_type == HDMI_AUD_INPUT_SPDIF) &&
+		((hdmi->aud_param.aud_codec == HDMI_AUDIO_CODING_TYPE_DTS_HD)
+		|| (hdmi->aud_param.aud_codec == HDMI_AUDIO_CODING_TYPE_MLP))
+		&& (hdmi->aud_param.codec_params.sample_rate == 768000)) {
+			mtk_hdmi_hbr_config(hdmi, false);
+		} else {
+			mtk_hdmi_hw_spdif_config(hdmi);
+			mtk_hdmi_hw_i2s_ch_mapping(hdmi, 2, 0);
+		}
+	}
+
+	return 0;
+}
+
+static int mtk_hdmi_aud_set_sw_ncts(struct mtk_hdmi *hdmi,
+				struct drm_display_mode *display_mode)
+{
+	unsigned int sample_rate = hdmi->aud_param.codec_params.sample_rate;
+
+	mtk_hdmi_aud_on_off_hw_ncts(hdmi, false);
+
+	mtk_hdmi_hw_aud_set_ncts(hdmi, sample_rate, display_mode->clock);
+
+	return 0;
+}
+
+//can.zeng done->void vEnableAudio(unsigned int bOn)
+static inline void mtk_hdmi_hw_audio_input_enable(
+	struct mtk_hdmi *hdmi, unsigned int enable)
+{
+	if (enable == true)
+		mtk_hdmi_mask(hdmi, AIP_CTRL, AUD_IN_EN, AUD_IN_EN);
+	else
+		mtk_hdmi_mask(hdmi, AIP_CTRL, 0x0 << AUD_IN_EN_SHIFT,
+			AUD_IN_EN);
+}
+
+//void vAipCtrlInit(void)
+static void mtk_hdmi_aip_ctrl_init(struct mtk_hdmi *hdmi)
+{
+	mtk_hdmi_mask(hdmi, AIP_CTRL,
+		AUD_SEL_OWRT | NO_MCLK_CTSGEN_SEL | CTS_REQ_EN,
+		AUD_SEL_OWRT | NO_MCLK_CTSGEN_SEL | MCLK_EN | CTS_REQ_EN);
+	mtk_hdmi_mask(hdmi, AIP_TPI_CTRL, TPI_AUDIO_LOOKUP_DIS,
+		TPI_AUDIO_LOOKUP_EN);
+}
+
+//can.zeng modification done->void vResetAudioHDMI(unsigned char bRst)
+void mtk_hdmi_audio_reset(struct mtk_hdmi *hdmi, bool rst)
+{
+	HDMI_FUNC();
+
+	if (rst == true) {
+		mtk_hdmi_mask(hdmi, AIP_TXCTRL, RST4AUDIO |
+			RST4AUDIO_FIFO | RST4AUDIO_ACR,
+			RST4AUDIO | RST4AUDIO_FIFO | RST4AUDIO_ACR);
+	} else {
+		mtk_hdmi_mask(hdmi, AIP_TXCTRL, 0,
+			RST4AUDIO | RST4AUDIO_FIFO | RST4AUDIO_ACR);
+	}
+}
+
+//can.zeng modification done-> vChgHDMIAudioOutput()
+static int mtk_hdmi_aud_output_config(struct mtk_hdmi *hdmi,
+				      struct drm_display_mode *display_mode)
+{
+	HDMI_FUNC();
+
+	mtk_hdmi_hw_aud_mute(hdmi);
+	mtk_hdmi_aud_enable_packet(hdmi, false);
+	mtk_hdmi_audio_reset(hdmi, true);
+	mtk_hdmi_aip_ctrl_init(hdmi);
+
+	mtk_hdmi_aud_set_input(hdmi);
+
+	mtk_hdmi_hw_aud_set_channel_status(hdmi,
+			hdmi->aud_param.codec_params.iec.status);
+
+	mtk_hdmi_setup_audio_infoframe(hdmi);
+
+	mtk_hdmi_hw_audio_input_enable(hdmi, true);
+
+	mtk_hdmi_audio_reset(hdmi, false);
+
+	mtk_hdmi_aud_set_sw_ncts(hdmi, display_mode);
+
+	udelay(25);
+	mtk_hdmi_aud_on_off_hw_ncts(hdmi, true);
+
+	mtk_hdmi_aud_enable_packet(hdmi, true);
+	mtk_hdmi_hw_aud_unmute(hdmi);
+	return 0;
+}
+
+int mtk_hdmi_setup_avi_infoframe(struct mtk_hdmi *hdmi,
+					struct drm_display_mode *mode)
+{
+	struct hdmi_avi_infoframe frame;
+	u8 buffer[17];
+	ssize_t err;
+	bool is_hdmi2x_sink = false;
+
+	//can.zeng todo verify
+	if (hdmi->conn.display_info.hdmi.scdc.supported == true) {
+		is_hdmi2x_sink = true; //if support scdc, then the sink support HDMI2.0
+		HDMI_LOG("HDMI2.x sink\n");
+	}
+	err = drm_hdmi_avi_infoframe_from_display_mode(&frame, &hdmi->conn, mode);
+
+	if (err < 0) {
+		dev_err(hdmi->dev,
+			"Failed to get AVI infoframe from mode: %zd\n", err);
+		return err;
+	}
+
+	//add information that not be included in drm_display_mode
+	/* colorspace and colorimetry */
+	if (_fgDolbyHdrEnable)
+		frame.colorspace = HDMI_COLORSPACE_RGB; //force DolbyHDR colorspace RGB
+	/* in current solution, when low latency dolby vision,
+	 * ETHDR only send colorspace format ycbcr422
+	 */
+	if (_fgLowLatencyDolbyVisionEnable)
+		frame.colorspace = HDMI_COLORSPACE_YUV422;
+	if (_fgBT2020Enable) { //can.zeng todo verify, remove? shall be maintain by ETHDR?
+		HDMI_LOG("BT2020\n");
+		frame.colorimetry = HDMI_COLORIMETRY_EXTENDED;
+		frame.extended_colorimetry = HDMI_EXTENDED_COLORIMETRY_BT2020;
+	} else {
+		frame.colorimetry = hdmi->colorimtery;
+		//no need, since we cannot support other extended colorimetry?
+		if (frame.colorimetry == HDMI_COLORIMETRY_EXTENDED)
+			frame.extended_colorimetry = hdmi->extended_colorimetry;
+	}
+
+	/* quantiation range:limited or full */
+	if (_fgDolbyHdrEnable)
+		frame.quantization_range = HDMI_QUANTIZATION_RANGE_FULL;
+	else {
+		if (frame.colorspace == HDMI_COLORSPACE_RGB)
+			frame.quantization_range = hdmi->quantization_range;
+		else
+			frame.ycc_quantization_range = hdmi->ycc_quantization_range;
+	}
+	err = hdmi_avi_infoframe_pack(&frame, buffer, sizeof(buffer));
+	if (err < 0) {
+		dev_err(hdmi->dev, "Failed to pack AVI infoframe: %zd\n", err);
+		return err;
+	}
+
+	mtk_hdmi_hw_avi_infoframe(hdmi, buffer, sizeof(buffer));
+	return 0;
+}
+
+static int mtk_hdmi_setup_spd_infoframe(struct mtk_hdmi *hdmi,
+					const char *vendor,
+					const char *product)
+{
+	struct hdmi_spd_infoframe frame;
+	u8 buffer[29];
+	ssize_t err;
+
+	err = hdmi_spd_infoframe_init(&frame, vendor, product);
+	if (err < 0) {
+		dev_err(hdmi->dev, "Failed to initialize SPD infoframe: %zd\n",
+			err);
+		return err;
+	}
+
+	err = hdmi_spd_infoframe_pack(&frame, buffer, sizeof(buffer));
+	if (err < 0) {
+		dev_err(hdmi->dev, "Failed to pack SDP infoframe: %zd\n", err);
+		return err;
+	}
+
+	mtk_hdmi_hw_spd_infoframe(hdmi, buffer, sizeof(buffer));
+	return 0;
+}
+
+static int mtk_hdmi_output_init(struct mtk_hdmi *hdmi)
+{
+	struct hdmi_audio_param *aud_param = &hdmi->aud_param;
+
+	aud_param->aud_codec = HDMI_AUDIO_CODING_TYPE_PCM;
+	aud_param->aud_sampe_size = HDMI_AUDIO_SAMPLE_SIZE_16;
+	aud_param->aud_input_type = HDMI_AUD_INPUT_I2S;
+	aud_param->aud_i2s_fmt = HDMI_I2S_MODE_I2S_24BIT;
+	aud_param->aud_mclk = HDMI_AUD_MCLK_128FS;
+	aud_param->aud_input_chan_type = HDMI_AUD_CHAN_TYPE_2_0;
+
+	hdmi->hpd = HDMI_PLUG_OUT;
+	hdmi->set_csp_depth = RGB444_8bit;
+	hdmi->csp = HDMI_COLORSPACE_RGB;
+	hdmi->color_depth = HDMI_8_BIT;
+	hdmi->colorimtery = HDMI_COLORIMETRY_NONE;
+	hdmi->extended_colorimetry = HDMI_EXTENDED_COLORIMETRY_RESERVED;
+	hdmi->quantization_range = HDMI_QUANTIZATION_RANGE_DEFAULT;
+	hdmi->ycc_quantization_range = HDMI_YCC_QUANTIZATION_RANGE_LIMITED;
+
+	return 0;
+}
+
+static int mtk_hdmi_reset_colorspace_setting(struct mtk_hdmi *hdmi)
+{
+	HDMI_FUNC();
+
+	hdmi->set_csp_depth = RGB444_8bit;
+	hdmi->csp = HDMI_COLORSPACE_RGB;
+	hdmi->color_depth = HDMI_8_BIT;
+	hdmi->colorimtery = HDMI_COLORIMETRY_NONE;
+	hdmi->extended_colorimetry = HDMI_EXTENDED_COLORIMETRY_RESERVED;
+	hdmi->quantization_range = HDMI_QUANTIZATION_RANGE_DEFAULT;
+	hdmi->ycc_quantization_range = HDMI_YCC_QUANTIZATION_RANGE_LIMITED;
+
+	return 0;
+}
+
+static void mtk_hdmi_audio_enable(struct mtk_hdmi *hdmi)
+{
+	HDMI_FUNC();
+
+	mtk_hdmi_aud_enable_packet(hdmi, true);
+	hdmi->audio_enable = true;
+}
+
+static void mtk_hdmi_audio_disable(struct mtk_hdmi *hdmi)
+{
+	HDMI_FUNC();
+
+	mtk_hdmi_aud_enable_packet(hdmi, false);
+	hdmi->audio_enable = false;
+}
+
+static int mtk_hdmi_audio_set_param(struct mtk_hdmi *hdmi,
+				    struct hdmi_audio_param *param)
+{
+	if (!hdmi->audio_enable) {
+		HDMI_LOG("hdmi audio is in disable state!\n");
+		return -EINVAL;
+	}
+	HDMI_LOG("codec:%d, input:%d, channel:%d, fs:%d\n",
+		param->aud_codec, param->aud_input_type,
+		param->aud_input_chan_type, param->codec_params.sample_rate);
+	memcpy(&hdmi->aud_param, param, sizeof(*param));
+	return mtk_hdmi_aud_output_config(hdmi, &hdmi->mode);
+}
+
+
+//can.zeng modification done-> void vChgHDMIVideoResolution(void)
+static void mtk_hdmi_change_video_resolution(struct mtk_hdmi *hdmi)
+{
+	bool is_over_340M = false;
+	bool is_hdmi_sink = false;
+	unsigned char enscramble;
+	struct mtk_hdmi_ddc *ddc = hdmi_ddc_ctx_from_mtk_hdmi(hdmi);
+
+	HDMI_FUNC();
+
+	mtk_hdmi_hw_reset(hdmi);
+	mtk_hdmi_set_sw_hpd(hdmi, true);
+	mtk_hdmi_colorspace_setting(hdmi);
+	udelay(2);
+
+	mtk_hdmi_write(hdmi, HDCP_TOP_CTRL, 0x0);
+	mtk_hdmi_en_hdcp_reauth_int(hdmi, true);
+	mtk_hdmi_enable_hpd_pord_irq(hdmi, true);
+	mtk_hdmi_force_hdcp_hpd(hdmi);
+
+	is_hdmi_sink = mtk_hdmi_sink_is_hdmi_device(hdmi);
+	mtk_hdmi_set_deep_color(hdmi, is_hdmi_sink);
+	mtk_hdmi_enable_hdmi_mode(hdmi, is_hdmi_sink);
+
+	udelay(5);
+	mtk_hdmi_hw_vid_black(hdmi, true);
+	mtk_hdmi_hw_aud_mute(hdmi);
+	mtk_hdmi_hw_send_av_unmute(hdmi);
+
+	mtk_hdmi_mask(hdmi, TOP_CFG01, NULL_PKT_VSYNC_HIGH_EN,
+		NULL_PKT_VSYNC_HIGH_EN | NULL_PKT_EN);
+
+	is_over_340M = mtk_hdmi_tmds_over_340M(hdmi);
+	if (is_over_340M == true)
+		enscramble = SCRAMBLING_ENABLE | TMDS_BIT_CLOCK_RATION;
+	else
+		enscramble = 0;
+	fgDDCDataWrite(ddc, RX_REG_SCRAMBLE >> 1,
+		RX_REG_TMDS_CONFIG, 1, &enscramble);
+	mtk_hdmi_enable_scrambling(hdmi, is_over_340M);
+	mtk_hdmi_high_tmds_clock_ratio(hdmi, is_over_340M);
+
+	if (hdmi->csp == HDMI_COLORSPACE_YUV420)
+		mtk_hdmi_yuv420_downsample(hdmi, true);
+	else
+		mtk_hdmi_yuv420_downsample(hdmi, false);
+
+	mtk_hdmi_480p_576p_setting(hdmi);
+	/* hdmitx_confighdmisetting(vformat); necessary here? */
+}
+
+static int mtk_hdmi_output_set_display_mode(struct mtk_hdmi *hdmi,
+					    struct drm_display_mode *mode)
+{
+	int ret;
+
+	ret = mtk_hdmi_video_change_vpll(hdmi, mode->clock * 1000);
+	if (ret) {
+		dev_err(hdmi->dev, "Failed to set vpll: %d\n", ret);
+		return ret;
+	}
+
+	mtk_hdmi_change_video_resolution(hdmi);
+	mtk_hdmi_aud_output_config(hdmi, mode);
+
+	return 0;
+}
+
+static int mtk_hdmi_get_all_clk(struct mtk_hdmi *hdmi,
+				struct device_node *np)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(mtk_hdmi_clk_names); i++) {
+		if (i == MTK_HDMI_CLK_HDMI_TXPLL)
+			hdmi->clk[i] = hdmi->hdmi_phy_base->txpll;
+		else
+			hdmi->clk[i] = of_clk_get_by_name(np,
+				mtk_hdmi_clk_names[i]);
+
+		if (IS_ERR(hdmi->clk[i]))
+			return PTR_ERR(hdmi->clk[i]);
+	}
+
+	return 0;
+}
+
+void mtk_hdmi_clk_enable(struct mtk_hdmi *hdmi)
+{
+	int i;
+
+	HDMI_FUNC();
+
+	clk_set_parent(hdmi->clk[MTK_HDIM_HDCP_SEL], hdmi->clk[MTK_HDMI_UNIVPLL_D4D8]);
+
+	for (i = 0; i < ARRAY_SIZE(mtk_hdmi_clk_names); i++) {
+		if ((i == MTK_HDMI_CLK_HDMI_TXPLL) || (i == MTK_HDMI_UNIVPLL_D4D8) ||
+		(i == MTK_HDMI_CLK_UNIVPLL_D6D4) || (i == MTK_HDMI_CLK_MSDCPLL_D2) ||
+		(i == MTK_HDMI_CLK_HDMI_APB_SEL))
+			continue;
+		else
+			clk_prepare_enable(hdmi->clk[i]);
+	}
+}
+
+void mtk_hdmi_clk_disable(struct mtk_hdmi *hdmi)
+{
+	int i;
+
+	HDMI_FUNC();
+
+	for (i = 0; i < ARRAY_SIZE(mtk_hdmi_clk_names); i++) {
+		if ((i == MTK_HDMI_CLK_HDMI_TXPLL) || (i == MTK_HDMI_UNIVPLL_D4D8) ||
+		(i == MTK_HDMI_CLK_UNIVPLL_D6D4) || (i == MTK_HDMI_CLK_MSDCPLL_D2) ||
+		(i == MTK_HDMI_CLK_HDMI_APB_SEL))
+			continue;
+		else
+			clk_disable_unprepare(hdmi->clk[i]);
+	}
+}
+
+static void mtk_hdmi_hpd_event(enum HDMI_HPD_STATE hpd, struct device *dev)
+{
+	struct mtk_hdmi *hdmi = dev_get_drvdata(dev);
+
+	if (hdmi && hdmi->bridge.encoder && hdmi->bridge.encoder->dev)
+		drm_helper_hpd_irq_event(hdmi->bridge.encoder->dev);
+}
+
+enum HDMI_HPD_STATE mtk_hdmi_hpd_pord_status(struct mtk_hdmi *hdmi)
+{
+	unsigned int hpd_status;
+	enum HDMI_HPD_STATE hpd;
+
+	hpd_status = mtk_hdmi_read(hdmi, HPD_DDC_STATUS);
+	if ((hpd_status & (HPD_PIN_STA | PORD_PIN_STA)) == (HPD_PIN_STA | PORD_PIN_STA))
+		hpd = HDMI_PLUG_IN_AND_SINK_POWER_ON;
+	else if ((hpd_status & (HPD_PIN_STA | PORD_PIN_STA)) == PORD_PIN_STA)
+		hpd = HDMI_PLUG_IN_ONLY;
+	else
+		hpd = HDMI_PLUG_OUT;
+
+	return hpd;
+}
+
+static irqreturn_t mtk_hdmi_isr(int irq, void *arg)
+{
+	//struct device *dev = arg;
+	//can.zeng todo verify
+	struct mtk_hdmi *hdmi = global_mtk_hdmi;
+	unsigned int int_status;
+
+	HDMI_LOG("INT MASK0=0x%08x, INT MASK1=0x%08x\n",
+		mtk_hdmi_read(hdmi, TOP_INT_MASK00),
+		mtk_hdmi_read(hdmi, TOP_INT_MASK01));
+	HDMI_LOG("INT STATUS0=0x%08x, INT STATUS1=0x%08x\n",
+		mtk_hdmi_read(hdmi, TOP_INT_STA00),
+		mtk_hdmi_read(hdmi, TOP_INT_STA01));
+	int_status = mtk_hdmi_read(hdmi, TOP_INT_STA00);
+
+#ifdef CONFIG_DRM_MEDIATEK_HDMI_HDCP
+	/* handle HDCP 2.x re-auth interrupt */
+	if (int_status & HDCP2X_RX_REAUTH_REQ_DDCM_INT_STA) {
+		if ((hdmi->hpd == HDMI_PLUG_IN_AND_SINK_POWER_ON) && (hdmi->hdcp_ctrl_state !=
+			HDCP2x_AUTHENTICATION)) {
+			HDMI_LOG("reauth_req\n");
+			vSetHDCPState(HDCP2x_AUTHENTICATION);
+			atomic_set(&hdmi_hdcp_event, 1);
+			wake_up_interruptible(&hdmi->hdcp_wq);
+		}
+
+		mtk_hdmi_mask(hdmi, TOP_INT_CLR00,
+			HDCP2X_RX_REAUTH_REQ_DDCM_INT_CLR,
+			HDCP2X_RX_REAUTH_REQ_DDCM_INT_CLR);
+		mtk_hdmi_mask(hdmi, TOP_INT_CLR00,
+			HDCP2X_RX_REAUTH_REQ_DDCM_INT_UNCLR,
+			HDCP2X_RX_REAUTH_REQ_DDCM_INT_UNCLR);
+	}
+#endif
+
+	/* handle hpd interrupt */
+	if (int_status & (PORD_F_INT_STA | PORD_R_INT_STA |
+		HTPLG_F_INT_STA | HTPLG_R_INT_STA)) {
+		HDMI_LOG("HPD/PORD IRQ\n");
+		HDMI_LOG("wait 40ms for HPD/PORD stable\n");
+		queue_delayed_work(hdmi->hdmi_wq, &hdmi->hpd_work,
+				msecs_to_jiffies(40));
+		mtk_hdmi_enable_hpd_pord_irq(hdmi, false);
+		mtk_hdmi_clr_htplg_pord_irq(hdmi);
+	}
+
+	/*clear all tx irq*/
+	mtk_hdmi_clr_all_int_status(hdmi);
+
+	return IRQ_HANDLED;
+}
+
+void mtk_hdmi_hpd_work_handle(struct work_struct *data)
+{
+	//struct mtk_hdmi *hdmi = container_of(data, struct mtk_hdmi, hpd_work);
+	//can.zeng todo verify
+	struct mtk_hdmi *hdmi = global_mtk_hdmi;
+	unsigned long long starttime = sched_clock();
+	enum HDMI_HPD_STATE hpd;
+
+	if (abs(sched_clock() - starttime) > 100000000ULL)
+		HDMI_LOG("Handle time over 100ms\n");
+	hpd = mtk_hdmi_hpd_pord_status(hdmi);
+	if (hpd != hdmi->hpd) {
+		HDMI_LOG("Hot Plug State Change! old=%d, new=%d\n", hdmi->hpd, hpd);
+		hdmi->hpd = hpd;
+		mtk_hdmi_hpd_event(hpd, hdmi->dev);
+	} else
+		HDMI_LOG("Hot Plug State NOT Change! hpd=%d\n", hdmi->hpd);
+
+	mtk_hdmi_enable_hpd_pord_irq(hdmi, true);
+}
+
+static int mtk_hdmi_init_workqueue(struct mtk_hdmi *hdmi)
+{
+	HDMI_FUNC();
+	hdmi->hdmi_wq = create_singlethread_workqueue("hdmitx_wq");
+	if (!hdmi->hdmi_wq) {
+		HDMI_LOG("Failed to create hdmitx workqueue\n");
+		return -ENOMEM;
+	}
+
+	INIT_DELAYED_WORK(&hdmi->hpd_work, mtk_hdmi_hpd_work_handle);
+	INIT_DELAYED_WORK(&hdmi->hdr10_delay_work, Hdr10DelayOffHandler);
+	INIT_DELAYED_WORK(&hdmi->hdr10vsif_delay_work, Hdr10pVsifDelayOffHandler);
+	return 0;
+}
+
+#ifdef CONFIG_DRM_MEDIATEK_HDMI_HDCP
+#define HDMI_HDCP_INTERVAL 10
+void hdmi_hdcp_timer_isr(struct timer_list *timer)
+{
+	struct mtk_hdmi *hdmi = global_mtk_hdmi;
+
+	atomic_set(&hdmi_hdcp_event, 1);
+	wake_up_interruptible(&hdmi->hdcp_wq);
+	mod_timer(&hdmi->hdcp_timer, jiffies + HDMI_HDCP_INTERVAL / (1000 / HZ));
+
+	hdcp_delay_time -= HDMI_HDCP_INTERVAL;
+}
+
+void hdmi_hdcp_start_task(void)
+{
+	struct mtk_hdmi *hdmi = global_mtk_hdmi;
+
+	HDMI_FUNC();
+	memset((void *)&(hdmi->hdcp_timer), 0, sizeof(hdmi->hdcp_timer));
+	timer_setup(&hdmi->hdcp_timer, hdmi_hdcp_timer_isr, 0);
+	hdmi->hdcp_timer.expires = jiffies + 1000 / (1000 / HZ);
+	add_timer(&hdmi->hdcp_timer);
+	hdmi->repeater_hdcp = false;
+	vHDCPInitAuth();
+}
+
+void hdmi_hdcp_stop_task(void)
+{
+	struct mtk_hdmi *hdmi = global_mtk_hdmi;
+
+	HDMI_FUNC();
+	if (hdmi->hdcp_timer.function)
+		del_timer_sync(&hdmi->hdcp_timer);
+	memset((void *)&hdmi->hdcp_timer, 0, sizeof(hdmi->hdcp_timer));
+}
+
+void hdmi_hdcp_task(enum HDCP_CTRL_STATE_T e_hdcp_state)
+{
+	unsigned int bStatus;
+	struct mtk_hdmi *hdmi = global_mtk_hdmi;
+
+	bStatus = mtk_hdmi_read(hdmi, TOP_INT_STA00);
+	if (bStatus & HDCP_RI_128_INT_STA) {
+		/* clear ri irq */
+		mtk_hdmi_mask(hdmi, TOP_INT_CLR00, HDCP_RI_128_INT_CLR,
+			HDCP_RI_128_INT_CLR);
+		mtk_hdmi_mask(hdmi, TOP_INT_CLR00, 0x0, HDCP_RI_128_INT_CLR);
+
+		if ((hdmi->hdcp_ctrl_state == HDCP_WAIT_RI) ||
+			(hdmi->hdcp_ctrl_state == HDCP_CHECK_LINK_INTEGRITY)) {
+			vSetHDCPState(HDCP_CHECK_LINK_INTEGRITY);
+			//vSendHdmiCmd(HDMI_HDCP_PROTOCAL_CMD);
+		}
+	}
+
+	if (fgIsHDCPCtrlTimeOut(hdmi->hdcp_ctrl_state))
+		hdcp_service(hdmi->hdcp_ctrl_state);
+
+}
+
+static int hdmi_hdcp_kthread(void *data)
+{
+	struct mtk_hdmi *hdmi = global_mtk_hdmi;
+
+	for (;;) {
+		wait_event_interruptible(hdmi->hdcp_wq,
+			atomic_read(&hdmi_hdcp_event));
+		atomic_set(&hdmi_hdcp_event, 0);
+		hdmi_hdcp_task(hdmi->hdcp_ctrl_state);
+		if (kthread_should_stop())
+			break;
+	}
+	return 0;
+}
+
+static int mtk_create_hdmi_hdcp_task(struct mtk_hdmi *hdmi)
+{
+	HDMI_FUNC();
+
+	init_waitqueue_head(&hdmi->hdcp_wq);
+	hdmi->hdcp_task = kthread_create(hdmi_hdcp_kthread,
+					NULL, "hdmi_hdcp_kthread");
+	if (hdmi->hdcp_task == NULL) {
+		HDMI_LOG("Failed to create hdcp task\n");
+		return -EINVAL;
+	}
+	wake_up_process(hdmi->hdcp_task);
+
+	return 0;
+}
+#endif
+
+static enum drm_connector_status hdmi_conn_detect(struct drm_connector *conn,
+						  bool force)
+{
+	struct mtk_hdmi *hdmi = hdmi_ctx_from_conn(conn);
+
+	HDMI_LOG();
+
+	if (hdmi->hpd == HDMI_PLUG_IN_AND_SINK_POWER_ON) {
+		HDMI_LOG("HPD High\n");
+	} else if (hdmi->hpd == HDMI_PLUG_IN_ONLY) {
+		HDMI_LOG("Plug In only\n");
+	} else {
+		HDMI_LOG("HPD low\n");
+		vClearEdidInfo();
+		mtk_hdmi_update_hdmi_info_property(hdmi);
+		memset(hdmi->raw_edid.edid, 0,
+			hdmi->raw_edid.blk_num * EDID_LENGTH);
+		hdmi->raw_edid.blk_num = 0;
+		hdmi->support_csp_depth = RGB444_8bit;
+		hdmi->set_csp_depth = RGB444_8bit;
+		hdmi->csp = HDMI_COLORSPACE_RGB;
+		hdmi->color_depth = HDMI_8_BIT;
+		hdmi->colorimtery = HDMI_COLORIMETRY_NONE;
+		hdmi->extended_colorimetry = HDMI_EXTENDED_COLORIMETRY_RESERVED;
+		hdmi->quantization_range = HDMI_QUANTIZATION_RANGE_DEFAULT;
+		hdmi->ycc_quantization_range = HDMI_YCC_QUANTIZATION_RANGE_LIMITED;
+		if (hdmi->hpd == HDMI_PLUG_OUT) {
+			//cec_notifier_set_phys_addr(hdmi->notifier, CEC_PHYS_ADDR_INVALID);
+			/* not clear physical address to make sure cec HAL
+			 * can send <One touch Play> message to wake up TV with
+			 * former valid physical address
+			 */
+		} else if (hdmi->hpd == HDMI_PLUG_IN_ONLY)
+			; //not clear valid physical address
+	}
+
+	return (hdmi->hpd != HDMI_PLUG_OUT) ?
+		connector_status_connected : connector_status_disconnected;
+}
+
+static void hdmi_conn_destroy(struct drm_connector *conn)
+{
+	drm_connector_cleanup(conn);
+}
+
+static int hdmi_conn_atomic_set_property(struct drm_connector *conn,
+	struct drm_connector_state *state, struct drm_property *property,
+	uint64_t val)
+{
+	struct mtk_hdmi *hdmi = hdmi_ctx_from_conn(conn);
+
+	spin_lock(&hdmi->property_lock);
+
+	if (property == hdmi->csp_depth_prop) {
+		if (val & (hdmi->support_csp_depth))
+			hdmi->set_csp_depth = val;
+		else {
+			HDMI_LOG("un-support colorspace & colordepth, %x\n", val);
+			spin_unlock(&hdmi->property_lock);
+			return -EINVAL;
+		}
+	} else {
+		HDMI_LOG("un-support property\n");
+		spin_unlock(&hdmi->property_lock);
+		return -EINVAL;
+	}
+
+	spin_unlock(&hdmi->property_lock);
+	return 0;
+}
+
+static int hdmi_conn_atomic_get_property(struct drm_connector *conn,
+	const struct drm_connector_state *state, struct drm_property *property,
+	uint64_t *val)
+{
+	struct mtk_hdmi *hdmi = hdmi_ctx_from_conn(conn);
+
+	spin_lock(&hdmi->property_lock);
+
+	if (property == hdmi->csp_depth_prop) {
+		*val = hdmi->support_csp_depth;
+	} else {
+		HDMI_LOG("un-support property\n");
+		spin_unlock(&hdmi->property_lock);
+		return -EINVAL;
+	}
+
+	spin_unlock(&hdmi->property_lock);
+	return 0;
+}
+
+//for ETHDR get supported ColorSpace and ColorDepth
+//return 0 success, else failure
+unsigned int get_hdmi_supported_colorspace_depth(
+	struct drm_bridge *bridge, uint64_t *colorspace_depth)
+{
+	struct mtk_hdmi *hdmi =	hdmi_ctx_from_bridge(bridge);
+	struct drm_connector *connector = &hdmi->conn;
+	struct drm_property *prop = hdmi->csp_depth_prop;
+	unsigned int result;
+
+	HDMI_LOG("Get ColorSpace,ColorDepth in kernel side\n");
+
+	if (connector->funcs->atomic_get_property) {
+		result = connector->funcs->atomic_get_property(connector,
+			NULL, prop, colorspace_depth);
+		if (result != 0)
+			return -EINVAL;
+	} else
+		return -EINVAL;
+
+	return 0;
+}
+EXPORT_SYMBOL(get_hdmi_supported_colorspace_depth);
+
+//for ETHDR set supported ColorSpace and ColorDepth
+//return 0 success, else failure
+unsigned int set_hdmi_colorspace_depth(
+	struct drm_bridge *bridge, uint64_t colorspace_depth)
+{
+	struct mtk_hdmi *hdmi =	hdmi_ctx_from_bridge(bridge);
+	struct drm_connector *connector = &hdmi->conn;
+	struct drm_property *prop = hdmi->csp_depth_prop;
+	unsigned int result;
+
+	HDMI_LOG("Set ColorSpace,ColorDepth in kernel side\n");
+
+	if (connector->funcs->atomic_set_property) {
+		result = connector->funcs->atomic_set_property(connector,
+			NULL, prop, colorspace_depth);
+		if (result != 0)
+			return -EINVAL;
+	} else
+		return -EINVAL;
+
+	return 0;
+}
+EXPORT_SYMBOL(set_hdmi_colorspace_depth);
+
+//for ETHDR set Colorimetry and QuantizationRange
+//return 0 success, else failure
+unsigned int set_hdmi_colorimetry_range(struct drm_bridge *bridge,
+	enum hdmi_colorimetry colorimtery, enum hdmi_extended_colorimetry extended_colorimetry,
+	enum hdmi_quantization_range quantization_range,
+	enum hdmi_ycc_quantization_range ycc_quantization_range)
+{
+	struct mtk_hdmi *hdmi =	hdmi_ctx_from_bridge(bridge);
+
+	HDMI_LOG("Set Colorimetry,QuantizationRange in kernel side\n");
+
+	hdmi->colorimtery = colorimtery;
+	hdmi->extended_colorimetry = extended_colorimetry;
+	hdmi->quantization_range = quantization_range;
+	hdmi->ycc_quantization_range = ycc_quantization_range;
+
+	return 0;
+}
+EXPORT_SYMBOL(set_hdmi_colorimetry_range);
+
+//for DPI get output ColorSpace and Colorimetry
+//return 0 success, else failure
+unsigned int get_hdmi_colorspace_colorimetry(struct drm_bridge *bridge,
+	enum hdmi_colorspace *colorspace, enum hdmi_colorimetry *colorimtery,
+	enum hdmi_extended_colorimetry *extended_colorimetry,
+	enum hdmi_quantization_range *quantization_range,
+	enum hdmi_ycc_quantization_range *ycc_quantization_range)
+{
+	struct mtk_hdmi *hdmi =	hdmi_ctx_from_bridge(bridge);
+
+	HDMI_LOG("DPI get ColorSpace and Colorimetry\n");
+	*colorspace = hdmi->csp;
+	*colorimtery = hdmi->colorimtery;
+	*extended_colorimetry = hdmi->extended_colorimetry;
+	*quantization_range = hdmi->quantization_range;
+	*ycc_quantization_range = hdmi->ycc_quantization_range;
+	//DPI cannot support BT2020 conversion, so no need extended_colorimetry information
+	return 0;
+}
+EXPORT_SYMBOL(get_hdmi_colorspace_colorimetry);
+
+
+struct mtk_hdmi_edid *mtk_hdmi_get_raw_edid(struct drm_bridge *bridge)
+{
+	struct mtk_hdmi *hdmi =	hdmi_ctx_from_bridge(bridge);
+	struct edid *edid = (struct edid *)(hdmi->raw_edid.edid);
+
+	if (!drm_edid_is_valid(edid)) {
+		HDMI_LOG("EDID invalid\n");
+		return NULL;
+	}
+
+	return &(hdmi->raw_edid);
+}
+EXPORT_SYMBOL(mtk_hdmi_get_raw_edid);
+
+//update color space & deep color property
+static unsigned int mtk_hdmi_update_sink_csp_depth(
+	struct drm_connector *conn, struct edid *edid)
+{
+	struct mtk_hdmi *hdmi = hdmi_ctx_from_conn(conn);
+	struct drm_display_info *disp_info = &conn->display_info;
+	struct drm_hdmi_info *hdmi_info = &disp_info->hdmi;
+	unsigned int prop_value = 0;
+
+	if (disp_info->color_formats & DRM_COLOR_FORMAT_RGB444) {
+		prop_value |= RGB444_8bit;
+		if (disp_info->edid_hdmi_dc_modes & DRM_EDID_HDMI_DC_30)
+			prop_value |= RGB444_10bit;
+		if (disp_info->edid_hdmi_dc_modes & DRM_EDID_HDMI_DC_36)
+			prop_value |= RGB444_12bit;
+		if (disp_info->edid_hdmi_dc_modes & DRM_EDID_HDMI_DC_48)
+			prop_value |= RGB444_16bit;
+	}
+
+	if (disp_info->color_formats & DRM_COLOR_FORMAT_YCRCB444) {
+		prop_value |= YCBCR444_8bit;
+		if (disp_info->edid_hdmi_dc_modes & DRM_EDID_HDMI_DC_30)
+			prop_value |= YCBCR444_10bit;
+		if (disp_info->edid_hdmi_dc_modes & DRM_EDID_HDMI_DC_36)
+			prop_value |= YCBCR444_12bit;
+		if (disp_info->edid_hdmi_dc_modes & DRM_EDID_HDMI_DC_48)
+			prop_value |= YCBCR444_16bit;
+	}
+
+	if (disp_info->color_formats & DRM_COLOR_FORMAT_YCRCB422)
+		prop_value |= YCBCR422_12bit;
+
+	if (disp_info->color_formats & DRM_COLOR_FORMAT_YCRCB420) {
+		prop_value |= YCBCR420_8bit;
+		if (hdmi_info->y420_dc_modes & DRM_EDID_YCBCR420_DC_30)
+			prop_value |= YCBCR420_10bit;
+		if (hdmi_info->y420_dc_modes & DRM_EDID_YCBCR420_DC_36)
+			prop_value |= YCBCR420_12bit;
+		if (hdmi_info->y420_dc_modes & DRM_EDID_YCBCR420_DC_48)
+			prop_value |= YCBCR420_16bit;
+	}
+
+	hdmi->support_csp_depth = prop_value;
+
+	HDMI_LOG("hdmi->support_csp_depth = 0x%x\n", hdmi->support_csp_depth);
+
+	return prop_value;
+}
+
+int mtk_hdmi_enable_disable(struct mtk_hdmi *hdmi, bool enable)
+{
+	int ret;
+
+	HDMI_LOG("enable = %d\n", enable);
+
+	if ((enable == true) && (hdmi->hdmi_enabled == false)) {
+		if (hdmi->power_clk_enabled == false) {
+			/* power domain on */
+			ret = pm_runtime_get_sync(hdmi->dev);
+			HDMI_LOG("[pm]Power Domain On %d\n", ret);
+			/* clk on */
+			mtk_hdmi_clk_enable(hdmi);
+
+			hdmi->power_clk_enabled = true;
+		} else
+			HDMI_LOG("Power and clock already On\n");
+
+		if (hdmi->irq_registered == false) {
+			/* disable all tx interrupts */
+			mtk_hdmi_disable_all_int(hdmi);
+			/* request irq */
+			hdmi->hdmi_irq = irq_of_parse_and_map(hdmi->dev->of_node, 0);
+			if (request_irq(hdmi->hdmi_irq, mtk_hdmi_isr,
+				IRQF_TRIGGER_HIGH, "hdmiirq", NULL) < 0)
+				HDMI_LOG("request hdmi interrupt failed.\n");
+			else
+				HDMI_LOG("request hdmi interrupt success\n");
+			hdmi->irq_registered = true;
+			/* enable hpd interrupt */
+			mtk_hdmi_set_sw_hpd(hdmi, true);
+			mtk_hdmi_enable_hpd_pord_irq(hdmi, true);
+		} else
+			HDMI_LOG("IRQ already registered\n");
+
+	} else if ((enable == false) && (hdmi->hdmi_enabled == true)) { 
+		if (hdmi->irq_registered == true) {
+			/* free irq */
+			free_irq(hdmi->hdmi_irq, NULL);
+			hdmi->irq_registered = false;
+		} else
+			HDMI_LOG("IRQ already un-registered\n");
+
+		if (hdmi->power_clk_enabled == true) {
+			/* clk disable */
+			mtk_hdmi_clk_disable(hdmi);
+			/* power domain off */
+			ret = pm_runtime_put_sync(hdmi->dev);
+			HDMI_LOG("[pm]Power Domain Off %d\n", ret);
+
+			hdmi->power_clk_enabled = false;
+		} else
+			HDMI_LOG("Power and clock already Off\n");
+	}
+
+	hdmi->hdmi_enabled = enable;
+
+	return 0;
+}
+
+static const struct drm_prop_enum_list csp_depth_props[] = {
+	{ __builtin_ffs(RGB444_8bit),  "RGB444_8bit" },
+	{ __builtin_ffs(RGB444_10bit), "RGB444_10bit" },
+	{ __builtin_ffs(RGB444_12bit), "RGB444_10bit" },
+	{ __builtin_ffs(RGB444_16bit), "RGB444_16bit" },
+	{ __builtin_ffs(YCBCR444_8bit),  "YCBCR444_8bit" },
+	{ __builtin_ffs(YCBCR444_10bit),  "YCBCR444_10bit" },
+	{ __builtin_ffs(YCBCR444_12bit),  "YCBCR444_12bit" },
+	{ __builtin_ffs(YCBCR444_16bit),  "YCBCR444_16bit" },
+	{ __builtin_ffs(YCBCR422_8bit_NO_SUPPORT),  "YCBCR422_8bit_NO_SUPPORT" },
+	{ __builtin_ffs(YCBCR422_10bit_NO_SUPPORT),  "YCBCR422_10bit_NO_SUPPORT" },
+	{ __builtin_ffs(YCBCR422_12bit),  "YCBCR422_12bit" },
+	{ __builtin_ffs(YCBCR422_16bit_NO_SUPPORT),  "YCBCR422_16bit_NO_SUPPORT" },
+	{ __builtin_ffs(YCBCR420_8bit),  "YCBCR420_8bit" },
+	{ __builtin_ffs(YCBCR420_10bit),  "YCBCR420_10bit" },
+	{ __builtin_ffs(YCBCR420_12bit),  "YCBCR420_12bit" },
+	{ __builtin_ffs(YCBCR420_16bit),  "YCBCR420_16bit" },
+};
+
+static void mtk_hdmi_connetor_init_property(
+	struct drm_device *drm_dev, struct drm_connector *conn)
+{
+	struct mtk_hdmi *hdmi = hdmi_ctx_from_conn(conn);
+	struct drm_property *prop;
+	/* ycbcr422 cannot support 8,10,16bit */
+	unsigned int supported_csp_depth_mask =
+		RGB444_8bit | RGB444_10bit | RGB444_12bit |
+		RGB444_16bit | YCBCR444_8bit | YCBCR444_10bit |
+		YCBCR444_12bit | YCBCR444_16bit | YCBCR422_12bit |
+		YCBCR420_8bit | YCBCR420_10bit | YCBCR420_12bit |
+		YCBCR420_16bit;
+
+	spin_lock_init(&hdmi->property_lock);
+
+	/* create colorspace_depth bitmask property */
+	prop = drm_property_create_bitmask(conn->dev, 0, "hdmi_colorspace_depth",
+					   csp_depth_props, ARRAY_SIZE(csp_depth_props),
+					   supported_csp_depth_mask);
+
+	if (!prop) {
+		HDMI_LOG("cannot create colorspace_depth property\n");
+		return;
+	}
+	HDMI_LOG("create colorspace & colordepth property\n");
+	hdmi->csp_depth_prop = prop;
+	drm_object_attach_property(&conn->base, prop, 0);
+
+	/* create mtk_hdmi_blob property, include EDID parser info,
+	 * such as max_tmds_clock_rate, max_tmds_character_rate, support dolby vision
+	 */
+	prop = drm_property_create(conn->dev, DRM_MODE_PROP_BLOB |
+				   DRM_MODE_PROP_IMMUTABLE,
+				   "HDMI_INFO", 0);
+	if (!prop) {
+		HDMI_LOG("cannot create HDMI_INFO blob property\n");
+		return;
+	}
+	hdmi->hdmi_info_blob = prop;
+	hdmi->hdmi_info_blob_ptr = NULL;
+	drm_object_attach_property(&conn->base, prop, 0);
+}
+
+int mtk_hdmi_update_hdmi_info_property(struct mtk_hdmi *hdmi)
+{
+	struct drm_device *dev = hdmi->conn.dev;
+	size_t size = 0;
+	int ret;
+	struct mtk_hdmi_info info;
+
+	info.edid_sink_colorimetry = _HdmiSinkAvCap.ui2_sink_colorimetry;
+	info.edid_sink_rgb_color_bit = _HdmiSinkAvCap.e_sink_rgb_color_bit;
+	info.edid_sink_ycbcr_color_bit = _HdmiSinkAvCap.e_sink_ycbcr_color_bit;
+	info.ui1_sink_dc420_color_bit = _HdmiSinkAvCap.ui1_sink_dc420_color_bit;
+	info.edid_sink_max_tmds_clock = _HdmiSinkAvCap.ui1_sink_max_tmds_clock;
+	info.edid_sink_max_tmds_character_rate = _HdmiSinkAvCap.ui2_sink_max_tmds_character_rate;
+	info.edid_sink_support_dynamic_hdr = _HdmiSinkAvCap.ui1_sink_support_dynamic_hdr;
+
+	HDMI_LOG("edid_sink_colorimetry=0x%x\n", info.edid_sink_colorimetry);
+	HDMI_LOG("edid_sink_rgb_color_bit=0x%x\n", info.edid_sink_rgb_color_bit);
+	HDMI_LOG("edid_sink_ycbcr_color_bit=0x%x\n", info.edid_sink_ycbcr_color_bit);
+	HDMI_LOG("ui1_sink_dc420_color_bit=0x%x\n", info.ui1_sink_dc420_color_bit);
+	HDMI_LOG("edid_sink_max_tmds_clock=%d\n", info.edid_sink_max_tmds_clock);
+	HDMI_LOG("edid_sink_max_tmds_character_rate=%d\n", info.edid_sink_max_tmds_character_rate);
+	HDMI_LOG("edid_sink_support_dynamic_hdr=0x%x\n", info.edid_sink_support_dynamic_hdr);
+
+	size = sizeof(struct mtk_hdmi_info);
+
+	ret = drm_property_replace_global_blob(dev, &hdmi->hdmi_info_blob_ptr,
+		size, &info, &hdmi->conn.base, hdmi->hdmi_info_blob);
+	return ret;
+}
+
+static void mtk_hdmi_convert_colorspace_depth(struct mtk_hdmi *hdmi)
+{
+	switch (hdmi->set_csp_depth) {
+	case RGB444_8bit:
+		hdmi->csp = HDMI_COLORSPACE_RGB;
+		hdmi->color_depth = HDMI_8_BIT;
+		break;
+	case RGB444_10bit:
+		hdmi->csp = HDMI_COLORSPACE_RGB;
+		hdmi->color_depth = HDMI_10_BIT;
+		break;
+	case RGB444_12bit:
+		hdmi->csp = HDMI_COLORSPACE_RGB;
+		hdmi->color_depth = HDMI_12_BIT;
+		break;
+	case RGB444_16bit:
+		hdmi->csp = HDMI_COLORSPACE_RGB;
+		hdmi->color_depth = HDMI_16_BIT;
+		break;
+	case YCBCR444_8bit:
+		hdmi->csp = HDMI_COLORSPACE_YUV444;
+		hdmi->color_depth = HDMI_8_BIT;
+		break;
+	case YCBCR444_10bit:
+		hdmi->csp = HDMI_COLORSPACE_YUV444;
+		hdmi->color_depth = HDMI_10_BIT;
+		break;
+	case YCBCR444_12bit:
+		hdmi->csp = HDMI_COLORSPACE_YUV444;
+		hdmi->color_depth = HDMI_12_BIT;
+		break;
+	case YCBCR444_16bit:
+		hdmi->csp = HDMI_COLORSPACE_YUV444;
+		hdmi->color_depth = HDMI_16_BIT;
+		break;
+	case YCBCR422_12bit:
+		hdmi->csp = HDMI_COLORSPACE_YUV422;
+		hdmi->color_depth = HDMI_12_BIT;
+		break;
+	case YCBCR420_8bit:
+		hdmi->csp = HDMI_COLORSPACE_YUV420;
+		hdmi->color_depth = HDMI_8_BIT;
+		break;
+	case YCBCR420_10bit:
+		hdmi->csp = HDMI_COLORSPACE_YUV420;
+		hdmi->color_depth = HDMI_10_BIT;
+		break;
+	case YCBCR420_12bit:
+		hdmi->csp = HDMI_COLORSPACE_YUV420;
+		hdmi->color_depth = HDMI_12_BIT;
+		break;
+	case YCBCR420_16bit:
+		hdmi->csp = HDMI_COLORSPACE_YUV420;
+		hdmi->color_depth = HDMI_16_BIT;
+		break;
+	default:
+		HDMI_LOG("ERROR:wrong ColorSpace or ColorDepth\n");
+		hdmi->csp = HDMI_COLORSPACE_RGB;
+		hdmi->color_depth = HDMI_8_BIT;
+	}
+	HDMI_LOG("color space:%d, color depth:%d\n", hdmi->csp, hdmi->color_depth);
+}
+
+static int mtk_hdmi_conn_get_modes(struct drm_connector *conn)
+{
+	struct mtk_hdmi *hdmi = hdmi_ctx_from_conn(conn);
+	struct mtk_hdmi_ddc *ddc = hdmi_ddc_ctx_from_mtk_hdmi(hdmi);
+	unsigned char *edid_buff;
+	struct edid *edid;
+	int ret;
+	bool edid_read;
+	unsigned char retry_times = 0;
+
+	HDMI_LOG("start\n");
+
+	if (!hdmi->ddc_adpt)
+		return -ENODEV;
+
+	edid_buff = kzalloc(EDID_LENGTH * 4, GFP_KERNEL);
+
+edid_retry:
+	hdmi_ddc_request(ddc, 1);
+	hdmi_ddc_free(ddc, 1);
+
+	//edid = drm_get_edid(conn, hdmi->ddc_adpt);
+	edid_read = fgDDCDataRead(ddc, 0x50, 0x00, EDID_LENGTH, &edid_buff[0]);
+	if (edid_read == true)
+		HDMI_LOG("read Block 0 success\n");
+	else
+		HDMI_LOG("read Block 0 failure\n");
+
+	edid_read = fgDDCDataRead(ddc, 0x50, 0x80, EDID_LENGTH, &edid_buff[128]);
+	if (edid_read == true)
+		HDMI_LOG("read Block 1 success\n");
+	else
+		HDMI_LOG("read Block 1 failure\n");
+
+	retry_times++;
+
+	edid = (struct edid *)edid_buff;
+	if (!drm_edid_is_valid(edid)) {
+		if (retry_times <= 5) {
+			HDMI_LOG("EDID invalid, retry=%d\n", retry_times);
+			msleep(20);
+			goto edid_retry;
+		} else {
+			HDMI_LOG("EDID invalid, return\n");
+			kfree(edid_buff);
+			return -EINVAL;
+		}
+	}
+
+	if ((edid->extensions + 1) <= 4)
+		hdmi->raw_edid.blk_num = edid->extensions + 1;
+	else
+		hdmi->raw_edid.blk_num = 4;
+
+	memcpy(hdmi->raw_edid.edid, edid,
+		hdmi->raw_edid.blk_num * EDID_LENGTH);
+
+	hdmi->dvi_mode = !drm_detect_monitor_audio(edid);
+
+	drm_connector_update_edid_property(conn, edid);
+	cec_notifier_set_phys_addr_from_edid(hdmi->notifier, edid);
+
+	ret = drm_add_edid_modes(conn, edid);
+
+	mtk_hdmi_update_sink_csp_depth(conn, edid);
+
+	hdmi_checkedid();
+	mtk_hdmi_update_hdmi_info_property(hdmi);
+
+	kfree(edid_buff);
+
+#ifdef CONFIG_DRM_MEDIATEK_HDMI_HDCP
+	/* acquire sink's hdcp version */
+	vReadHdcpVersion();
+#endif
+
+	HDMI_LOG("end\n");
+
+	return ret;
+}
+
+static int mtk_hdmi_conn_mode_valid(struct drm_connector *conn,
+				    struct drm_display_mode *mode)
+{
+	HDMI_LOG("xres=%d, yres=%d, intl=%d clock=%d\n",
+		mode->hdisplay, mode->vdisplay,
+		!!(mode->flags & DRM_MODE_FLAG_INTERLACE), mode->clock * 1000);
+
+	if (mode->clock < 27000) {
+		HDMI_LOG("MODE_CLOCK_LOW!\n");
+		return MODE_CLOCK_LOW;
+	}
+	if (mode->clock > 594000) {
+		HDMI_LOG("MODE_CLOCK_HIGH!\n");
+		return MODE_CLOCK_HIGH;
+	}
+
+	return drm_mode_validate_size(mode, 0x1fff, 0x1fff);
+}
+
+static struct drm_encoder *mtk_hdmi_conn_best_enc(struct drm_connector *conn)
+{
+	struct mtk_hdmi *hdmi = hdmi_ctx_from_conn(conn);
+
+	HDMI_LOG();
+
+	return hdmi->bridge.encoder;
+}
+
+static const struct drm_connector_funcs mtk_hdmi_connector_funcs = {
+	/* .dpms = drm_atomic_helper_connector_dpms, */
+	.detect = hdmi_conn_detect,
+	.fill_modes = drm_helper_probe_single_connector_modes,
+	.destroy = hdmi_conn_destroy,
+	.reset = drm_atomic_helper_connector_reset,
+	.atomic_duplicate_state = drm_atomic_helper_connector_duplicate_state,
+	.atomic_destroy_state = drm_atomic_helper_connector_destroy_state,
+	.atomic_set_property = hdmi_conn_atomic_set_property,
+	.atomic_get_property = hdmi_conn_atomic_get_property,
+};
+
+static const struct drm_connector_helper_funcs
+		mtk_hdmi_connector_helper_funcs = {
+	.get_modes = mtk_hdmi_conn_get_modes,
+	.mode_valid = mtk_hdmi_conn_mode_valid,
+	.best_encoder = mtk_hdmi_conn_best_enc,
+};
+
+/*
+ * Bridge callbacks
+ */
+
+static int mtk_hdmi_bridge_attach(struct drm_bridge *bridge, enum drm_bridge_attach_flags flags)
+{
+	struct mtk_hdmi *hdmi = hdmi_ctx_from_bridge(bridge);
+	int ret;
+
+	HDMI_LOG("start\n");
+
+	ret = drm_connector_init(bridge->encoder->dev, &hdmi->conn,
+				 &mtk_hdmi_connector_funcs,
+				 DRM_MODE_CONNECTOR_HDMIA);
+	if (ret) {
+		HDMI_LOG("Failed to initialize connector: %d\n", ret);
+		return ret;
+	}
+	drm_connector_helper_add(&hdmi->conn, &mtk_hdmi_connector_helper_funcs);
+
+	hdmi->conn.polled = DRM_CONNECTOR_POLL_HPD;
+	hdmi->conn.interlace_allowed = false;
+	hdmi->conn.doublescan_allowed = false;
+	hdmi->conn.ycbcr_420_allowed = true;
+
+	ret = drm_connector_attach_encoder(&hdmi->conn,
+						bridge->encoder);
+	if (ret) {
+		HDMI_LOG("Failed to attach connector to encoder: %d\n", ret);
+		return ret;
+	}
+
+	mtk_hdmi_connetor_init_property(bridge->dev, &hdmi->conn);
+
+	pm_runtime_enable(hdmi->dev);
+	mtk_hdmi_enable_disable(hdmi, true);
+
+	HDMI_LOG("end\n");
+
+	return 0;
+}
+
+static bool mtk_hdmi_bridge_mode_fixup(struct drm_bridge *bridge,
+				       const struct drm_display_mode *mode,
+				       struct drm_display_mode *adjusted_mode)
+{
+	HDMI_FUNC();
+
+	return true;
+}
+
+static void mtk_hdmi_bridge_disable(struct drm_bridge *bridge)
+{
+	struct mtk_hdmi *hdmi = hdmi_ctx_from_bridge(bridge);
+
+	HDMI_FUNC();
+
+	if (!hdmi->enabled)
+		return;
+
+	mtk_hdmi_hw_send_av_mute(hdmi);
+	usleep_range(50000, 50050);
+	mtk_hdmi_hw_vid_black(hdmi, true);
+	mtk_hdmi_hw_aud_mute(hdmi);
+	mtk_hdmi_disable_hdcp_encrypt(hdmi);
+	usleep_range(50000, 50050);
+
+#ifdef CONFIG_DRM_MEDIATEK_HDMI_HDCP
+	hdmi_hdcp_stop_task();
+	vHDCPReset();
+#endif
+	hdmi->enabled = false;
+}
+
+static void mtk_hdmi_bridge_post_disable(struct drm_bridge *bridge)
+{
+	struct mtk_hdmi *hdmi = hdmi_ctx_from_bridge(bridge);
+
+	HDMI_LOG("start\n");
+
+	if (!hdmi->powered)
+		return;
+
+	phy_power_off(hdmi->phy);
+
+	hdmi->powered = false;
+
+	reset_hdmi_hdr_status();
+	mtk_hdmi_reset_colorspace_setting(hdmi);
+
+	/* signal the disconnect event to audio codec */
+	mtk_hdmi_handle_plugged_change(hdmi, false);
+
+	HDMI_LOG("end\n");
+}
+
+static void mtk_hdmi_bridge_mode_set(struct drm_bridge *bridge,
+				    const struct drm_display_mode *mode,
+				    const struct drm_display_mode *adjusted_mode)
+{
+	struct mtk_hdmi *hdmi = hdmi_ctx_from_bridge(bridge);
+
+	HDMI_LOG("start\n");
+
+	HDMI_LOG("cur info: name:%s, hdisplay:%d\n",
+		adjusted_mode->name, adjusted_mode->hdisplay);
+	HDMI_LOG("hsync_start:%d,hsync_end:%d, htotal:%d",
+		adjusted_mode->hsync_start, adjusted_mode->hsync_end,
+		adjusted_mode->htotal);
+	HDMI_LOG("hskew:%d, vdisplay:%d\n",
+		adjusted_mode->hskew, adjusted_mode->vdisplay);
+	HDMI_LOG("vsync_start:%d, vsync_end:%d, vtotal:%d",
+		adjusted_mode->vsync_start, adjusted_mode->vsync_end,
+		adjusted_mode->vtotal);
+	HDMI_LOG("vscan:%d, flag:%d\n",
+		adjusted_mode->vscan, adjusted_mode->flags);
+
+	drm_mode_copy(&hdmi->mode, adjusted_mode);
+
+	HDMI_LOG("end\n");
+
+}
+
+static void mtk_hdmi_send_infoframe(struct mtk_hdmi *hdmi,
+				    struct drm_display_mode *mode)
+{
+	HDMI_FUNC();
+	/* mtk_hdmi_setup_audio_infoframe(hdmi); */
+	mtk_hdmi_setup_avi_infoframe(hdmi, mode);
+	mtk_hdmi_setup_spd_infoframe(hdmi, "mediatek", "On-chip HDMI");
+	if ((mode->flags & DRM_MODE_FLAG_3D_MASK) ||
+		((_fgDolbyHdrEnable == true) && (_use_dolby_vsif == false)))
+		mtk_hdmi_setup_h14b_vsif(hdmi, mode);
+	if (_fgLowLatencyDolbyVisionEnable ||
+		((_fgDolbyHdrEnable == true) && (_use_dolby_vsif == true)))
+		mtk_hdmi_hw_dolby_vsif(hdmi, true, _fgLowLatencyDolbyVisionEnable,
+			true, _fgBackltCtrlMDPresent, _u4EffTmaxPQ);
+	mtk_hdmi_hw_static_hdr_infoframe(hdmi, _bStaticHdrStatus, _bHdrMetadataBuff);
+
+	if (0) //can.zeng todo verify the condition
+		mtk_hdmi_setup_hf_vsif(hdmi, mode);
+}
+
+static void mtk_hdmi_bridge_pre_enable(struct drm_bridge *bridge)
+{
+	struct mtk_hdmi *hdmi = hdmi_ctx_from_bridge(bridge);
+
+	HDMI_FUNC();
+
+#ifdef CONFIG_OPTEE
+	hdmi_ca_init(); //initialize HDMI CA session
+#endif
+
+	mtk_hdmi_convert_colorspace_depth(hdmi);
+	mtk_hdmi_output_set_display_mode(hdmi, &hdmi->mode);
+	mtk_hdmi_send_infoframe(hdmi, &hdmi->mode);
+
+	/* dpi hardware depends on hdmi txpll clock,
+	 * drm call flow: bridge_pre_enable -> encoder_enable -> bridge_enable,
+	 * dpi need write register in 'encoder_enable' with hdmi txpll clock,
+	 * so hdmi txpll need be enabled in 'bridge_pre_enable'
+	 */
+	if (__clk_is_enabled(hdmi->clk[MTK_HDMI_CLK_HDMI_TXPLL]) == false)
+		clk_prepare_enable(hdmi->clk[MTK_HDMI_CLK_HDMI_TXPLL]);
+
+	hdmi->powered = true;
+}
+
+static void mtk_hdmi_bridge_enable(struct drm_bridge *bridge)
+{
+	struct mtk_hdmi *hdmi = hdmi_ctx_from_bridge(bridge);
+
+	HDMI_FUNC();
+
+	phy_power_on(hdmi->phy);
+
+#ifdef CONFIG_DRM_MEDIATEK_HDMI_HDCP
+	hdmi_hdcp_start_task();
+#else
+	mtk_hdmi_hw_vid_black(hdmi, false);
+	mtk_hdmi_hw_aud_unmute(hdmi);
+#endif
+
+	/* signal the connect event to audio codec */
+	mtk_hdmi_handle_plugged_change(hdmi, true);
+
+	hdmi->enabled = true;
+}
+
+static const struct drm_bridge_funcs mtk_hdmi_bridge_funcs = {
+	.attach = mtk_hdmi_bridge_attach,
+	.mode_fixup = mtk_hdmi_bridge_mode_fixup,
+	.disable = mtk_hdmi_bridge_disable,
+	.post_disable = mtk_hdmi_bridge_post_disable,
+	.mode_set = mtk_hdmi_bridge_mode_set,
+	.pre_enable = mtk_hdmi_bridge_pre_enable,
+	.enable = mtk_hdmi_bridge_enable,
+};
+
+static int mtk_hdmi_dt_parse_pdata(struct mtk_hdmi *hdmi,
+				   struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct device_node *np = dev->of_node;
+	//struct device_node *cec_np,
+	//struct device_node *port, *ep, *remote, *i2c_np;
+	//struct device_node *remote,
+	struct device_node *i2c_np;
+	//struct platform_device *cec_pdev;
+	struct resource *mem;
+	int ret;
+	struct mtk_hdmi_ddc *ddc;
+
+	ret = mtk_hdmi_get_all_clk(hdmi, np);
+	if (ret) {
+		HDMI_LOG("Failed to get clocks: %d\n", ret);
+		return ret;
+	}
+
+	mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	hdmi->regs = devm_ioremap_resource(dev, mem);
+	if (IS_ERR(hdmi->regs))
+		return PTR_ERR(hdmi->regs);
+
+	i2c_np = of_parse_phandle(pdev->dev.of_node, "ddc-i2c-bus", 0);
+	if (!i2c_np) {
+		HDMI_LOG("Failed to find ddc-i2c-bus node in %s\n",
+			(pdev->dev.of_node)->full_name);
+		of_node_put(pdev->dev.of_node);
+		return -EINVAL;
+	}
+	of_node_put(pdev->dev.of_node);
+
+	hdmi->ddc_adpt = of_find_i2c_adapter_by_node(i2c_np);
+	if (!hdmi->ddc_adpt) {
+		HDMI_LOG("Failed to get ddc i2c adapter by node\n");
+		return -EINVAL;
+	}
+
+	//can.zeng todo verify
+	ddc = hdmi_ddc_ctx_from_mtk_hdmi(hdmi);
+	ddc->regs = hdmi->regs;
+
+	return 0;
+}
+
+void mtk_hdmi_handle_plugged_change(struct mtk_hdmi *hdmi,
+		bool plugged)
+{
+	HDMI_FUNC();
+
+	if (hdmi->plugged_cb && hdmi->codec_dev) {
+		HDMI_LOG("plugged = %d\n", plugged);
+		hdmi->plugged_cb(hdmi->codec_dev, plugged);
+	}
+}
+
+int mtk_hdmi_set_plugged_cb(struct mtk_hdmi *hdmi,
+		hdmi_codec_plugged_cb fn, struct device *codec_dev)
+{
+	bool plugged;
+
+	HDMI_FUNC();
+
+	hdmi->plugged_cb = fn;
+	hdmi->codec_dev = codec_dev;
+	plugged = (hdmi->hpd == HDMI_PLUG_IN_AND_SINK_POWER_ON) ? true : false;
+	mtk_hdmi_handle_plugged_change(hdmi, plugged);
+
+	return 0;
+}
+
+/*
+ * HDMI audio codec callbacks
+ */
+static int mtk_hdmi_audio_hook_plugged_cb(struct device *dev,
+	void *data, hdmi_codec_plugged_cb fn, struct device *codec_dev)
+{
+	struct mtk_hdmi *hdmi = dev_get_drvdata(dev);
+
+	HDMI_FUNC();
+
+	if (!hdmi) {
+		HDMI_LOG("invalid input\n");
+		return -ENODEV;
+	}
+
+	return mtk_hdmi_set_plugged_cb(hdmi, fn, codec_dev);
+}
+
+
+static int mtk_hdmi_audio_hw_params(struct device *dev, void *data,
+				    struct hdmi_codec_daifmt *daifmt,
+				    struct hdmi_codec_params *params)
+{
+	struct mtk_hdmi *hdmi = dev_get_drvdata(dev);
+	struct hdmi_audio_param hdmi_params;
+	unsigned int chan = params->cea.channels;
+
+	HDMI_LOG("%u Hz, %d bit, %d channels\n",
+		params->sample_rate, params->sample_width, chan);
+
+	if (!hdmi->bridge.encoder)
+		return -ENODEV;
+
+	switch (chan) {
+	case 2:
+		hdmi_params.aud_input_chan_type = HDMI_AUD_CHAN_TYPE_2_0;
+		break;
+	case 4:
+		hdmi_params.aud_input_chan_type = HDMI_AUD_CHAN_TYPE_4_0;
+		break;
+	case 6:
+		hdmi_params.aud_input_chan_type = HDMI_AUD_CHAN_TYPE_5_1;
+		break;
+	case 8:
+		hdmi_params.aud_input_chan_type = HDMI_AUD_CHAN_TYPE_7_1;
+		break;
+	default:
+		HDMI_LOG("ERROR: channel[%d] not supported!\n", chan);
+		return -EINVAL;
+	}
+
+	switch (params->sample_rate) {
+	case 32000:
+	case 44100:
+	case 48000:
+	case 88200:
+	case 96000:
+	case 176400:
+	case 192000:
+		break;
+	default:
+		HDMI_LOG("ERROR: rate[%d] not supported!\n", params->sample_rate);
+		return -EINVAL;
+	}
+
+	switch (daifmt->fmt) {
+	case HDMI_I2S:
+		hdmi_params.aud_codec = HDMI_AUDIO_CODING_TYPE_PCM;
+		hdmi_params.aud_sampe_size = HDMI_AUDIO_SAMPLE_SIZE_16;
+		hdmi_params.aud_input_type = HDMI_AUD_INPUT_I2S;
+		hdmi_params.aud_i2s_fmt = HDMI_I2S_MODE_I2S_24BIT;
+		hdmi_params.aud_mclk = HDMI_AUD_MCLK_128FS;
+		break;
+	default:
+		HDMI_LOG("ERROR: Invalid DAI format %d\n", daifmt->fmt);
+		return -EINVAL;
+	}
+
+	memcpy(&hdmi_params.codec_params, params,
+	       sizeof(hdmi_params.codec_params));
+
+	mtk_hdmi_audio_set_param(hdmi, &hdmi_params);
+
+	return 0;
+}
+
+static int mtk_hdmi_audio_startup(struct device *dev, void *data)
+{
+	struct mtk_hdmi *hdmi = dev_get_drvdata(dev);
+
+	HDMI_FUNC();
+
+	mtk_hdmi_audio_enable(hdmi);
+
+	return 0;
+}
+
+static void mtk_hdmi_audio_shutdown(struct device *dev, void *data)
+{
+	struct mtk_hdmi *hdmi = dev_get_drvdata(dev);
+
+	HDMI_FUNC();
+
+	mtk_hdmi_audio_disable(hdmi);
+}
+
+
+static int
+mtk_hdmi_audio_mute(struct device *dev, void *data, bool enable, int direction)
+{
+	struct mtk_hdmi *hdmi = dev_get_drvdata(dev);
+
+	if (direction != SNDRV_PCM_STREAM_PLAYBACK)
+		return 0;
+
+	HDMI_LOG("enable=%d\n", enable);
+
+	if (enable)
+		mtk_hdmi_hw_aud_mute(hdmi);
+	else
+		mtk_hdmi_hw_aud_unmute(hdmi);
+
+	return 0;
+}
+
+static int mtk_hdmi_audio_get_eld(struct device *dev, void *data, uint8_t *buf, size_t len)
+{
+	struct mtk_hdmi *hdmi = dev_get_drvdata(dev);
+	struct drm_connector *conn = &hdmi->conn;
+	unsigned int i;
+
+	HDMI_FUNC();
+
+	dev_dbg(dev, "ELD data start\n");
+	for (i = 0; i < 128; i += 8) {
+		dev_dbg(dev, "%2x %2x %2x %2x %2x %2x %2x %2x\n",
+			conn->eld[i], conn->eld[i+1], conn->eld[i+2], conn->eld[i+3],
+			conn->eld[i+4], conn->eld[i+5], conn->eld[i+6], conn->eld[i+7]);
+	}
+	dev_dbg(dev, "ELD data end\n");
+
+	memcpy(buf, hdmi->conn.eld, min(sizeof(hdmi->conn.eld), len));
+
+	return 0;
+}
+
+static const struct hdmi_codec_ops mtk_hdmi_audio_codec_ops = {
+	.hw_params = mtk_hdmi_audio_hw_params,
+	.audio_startup = mtk_hdmi_audio_startup,
+	.audio_shutdown = mtk_hdmi_audio_shutdown,
+	.mute_stream = mtk_hdmi_audio_mute,
+	.get_eld = mtk_hdmi_audio_get_eld,
+	.hook_plugged_cb = mtk_hdmi_audio_hook_plugged_cb,
+};
+
+static void mtk_hdmi_register_audio_driver(struct device *dev)
+{
+	struct mtk_hdmi *hdmi = dev_get_drvdata(dev);
+	struct hdmi_codec_pdata codec_data = {
+		.ops = &mtk_hdmi_audio_codec_ops,
+		.max_i2s_channels = 8,
+		.i2s = 1,
+		.data = hdmi,
+	};
+	struct platform_device *pdev;
+
+	pdev = platform_device_register_data(dev, HDMI_CODEC_DRV_NAME,
+					     PLATFORM_DEVID_AUTO, &codec_data,
+					     sizeof(codec_data));
+	if (IS_ERR(pdev))
+		return;
+
+	HDMI_LOG("%s driver bound to HDMI\n", HDMI_CODEC_DRV_NAME);
+}
+
+static int mtk_drm_hdmi_probe(struct platform_device *pdev)
+{
+	struct mtk_hdmi *hdmi;
+	struct device *dev = &pdev->dev;
+	int ret;
+
+	HDMI_LOG("probe start\n");
+
+	hdmi = devm_kzalloc(dev, sizeof(*hdmi), GFP_KERNEL);
+	if (!hdmi)
+		return -ENOMEM;
+
+	hdmi->dev = dev;
+
+	global_mtk_hdmi = hdmi;
+
+	hdmi->phy = devm_phy_get(dev, "hdmi");
+	if (IS_ERR(hdmi->phy)) {
+		ret = PTR_ERR(hdmi->phy);
+		HDMI_LOG("Failed to get HDMI PHY: %d\n", ret);
+		return ret;
+	}
+	hdmi->hdmi_phy_base = phy_get_drvdata(hdmi->phy);
+
+	ret = mtk_hdmi_dt_parse_pdata(hdmi, pdev);
+	if (ret)
+		return ret;
+
+	platform_set_drvdata(pdev, hdmi);
+
+	ret = mtk_hdmi_output_init(hdmi);
+	if (ret) {
+		HDMI_LOG("Failed to initialize hdmi output\n");
+		return ret;
+	}
+
+	mtk_hdmi_register_audio_driver(dev);
+
+	/* create hdmi debugfs */
+	hdmitx_debug_init();
+
+	mtk_hdmi_init_workqueue(hdmi);
+
+	/* initialize HDR */
+	vInitHdr();
+
+#ifdef CONFIG_DRM_MEDIATEK_HDMI_HDCP
+	mtk_create_hdmi_hdcp_task(hdmi);
+	hdmi->enable_hdcp = true;
+#endif
+
+	hdmi->bridge.funcs = &mtk_hdmi_bridge_funcs;
+	hdmi->bridge.of_node = pdev->dev.of_node;
+	drm_bridge_add(&hdmi->bridge);
+
+	HDMI_LOG("probe success\n");
+	return 0;
+}
+
+static int mtk_drm_hdmi_remove(struct platform_device *pdev)
+{
+	struct mtk_hdmi *hdmi = platform_get_drvdata(pdev);
+
+	drm_bridge_remove(&hdmi->bridge);
+	mtk_hdmi_clk_disable(hdmi);
+	hdmitx_debug_uninit();
+
+	return 0;
+}
+
+struct ipi_cmd_s {
+	unsigned int id;
+	unsigned int data;
+	unsigned int sus_flag;
+};
+
+#ifdef CONFIG_PM_SLEEP
+static int mtk_hdmi_suspend(struct device *dev)
+{
+	struct mtk_hdmi *hdmi = dev_get_drvdata(dev);
+#ifdef CONFIG_DRM_MEDIATEK_HDMI_SUSPEND_LOW_POWER
+	//struct mtk_cec *cec = mtk_global_cec;
+
+	HDMI_FUNC();
+	if (hdmi->power_clk_enabled == true) {
+		mtk_hdmi_clk_disable(hdmi);
+		pm_runtime_put_sync(hdmi->dev);
+		HDMI_LOG("[pm]Power Domain Off\n");
+		hdmi->power_clk_enabled = false;
+	} else
+		HDMI_LOG("Power and clock already Off\n");
+	//if (cec->cec_enabled == true) {
+	//	mtk_cec_clk_enable(cec, false);
+	//	cec->cec_enabled = false;
+	//}
+
+	dev_dbg(dev, "hdmi suspend success!\n");
+	HDMI_LOG("%s done\n", __func__);
+
+	return 0;
+
+#else
+#ifdef CONFIG_HDMI_TX_IPI_SUPPORT
+	struct ipi_cmd_s ipi_cmd;
+	//int ret;
+#endif
+
+	device_set_wakeup_path(dev);
+	dev_dbg(dev, "hdmi suspend success!\n");
+
+#ifdef CONFIG_HDMI_TX_IPI_SUPPORT
+	ipi_cmd.id = 0x55;
+	ipi_cmd.data = 0xaa;
+	ipi_cmd.sus_flag = 1;
+	//ret = scp_ipi_send(IPI_HDMICEC, &ipi_cmd, sizeof(struct ipi_cmd_s), 0, SCP_A_ID);
+	//if (ret != SCP_IPI_DONE)
+		//HDMI_LOG("[CEC]ipi cmd fail\n");
+#endif
+	HDMI_LOG("[CEC]%s done\n", __func__);
+	return 0;
+#endif
+}
+
+static int mtk_hdmi_resume(struct device *dev)
+{
+	struct mtk_hdmi *hdmi = dev_get_drvdata(dev);
+#ifdef CONFIG_DRM_MEDIATEK_HDMI_SUSPEND_LOW_POWER
+	//struct mtk_cec *cec = mtk_global_cec;
+
+	HDMI_FUNC();
+	if (hdmi->power_clk_enabled == false) {
+		pm_runtime_get_sync(hdmi->dev);
+		HDMI_LOG("Power Domain On\n");
+		mtk_hdmi_clk_enable(hdmi);
+		hdmi->power_clk_enabled = true;
+	} else
+		HDMI_LOG("Power and clock already On\n");
+
+	//if (cec->cec_enabled == false) {
+	//	mtk_cec_clk_enable(cec, true);
+	//	cec->cec_enabled = true;
+	//}
+
+	dev_dbg(dev, "hdmi resume success!\n");
+	HDMI_LOG("%s done\n", __func__);
+	return 0;
+
+#else
+
+#ifdef CONFIG_HDMI_TX_IPI_SUPPORT
+	struct ipi_cmd_s ipi_cmd;
+	//int ret;
+#endif
+	mtk_hdmi_clk_enable(hdmi);
+
+	dev_dbg(dev, "hdmi resume success!\n");
+
+#ifdef CONFIG_HDMI_TX_IPI_SUPPORT
+	ipi_cmd.id = 0x55;
+	ipi_cmd.data = 0x00;
+	ipi_cmd.sus_flag = 0;
+	//ret = scp_ipi_send(IPI_HDMICEC, &ipi_cmd, sizeof(struct ipi_cmd_s), 0, SCP_A_ID);
+	//if (ret != SCP_IPI_DONE)
+		//HDMI_LOG("[CEC]ipi cmd fail\n");
+#endif
+	HDMI_LOG("[CEC]%s done\n", __func__);
+	return 0;
+#endif
+}
+#endif
+static SIMPLE_DEV_PM_OPS(mtk_hdmi_pm_ops, mtk_hdmi_suspend, mtk_hdmi_resume);
+
+static const struct of_device_id mtk_drm_hdmi_of_ids[] = {
+	{ .compatible = "mediatek,mt8195-hdmi", },
+	{}
+};
+
+static struct platform_driver mtk_hdmi_driver = {
+	.probe = mtk_drm_hdmi_probe,
+	.remove = mtk_drm_hdmi_remove,
+	.driver = {
+		.name = "mediatek-drm-hdmi",
+		.of_match_table = mtk_drm_hdmi_of_ids,
+		.pm = &mtk_hdmi_pm_ops,
+	},
+};
+
+static struct platform_driver * const mtk_hdmi_drivers[] = {
+	&mtk_hdmi_phy_driver,
+	&mtk_hdmi_ddc_driver,
+//	&mtk_cec_driver,
+	&mtk_hdmi_driver,
+};
+
+static int __init mtk_hdmitx_init(void)
+{
+	int ret;
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(mtk_hdmi_drivers); i++) {
+		ret = platform_driver_register(mtk_hdmi_drivers[i]);
+		if (ret < 0) {
+			HDMI_LOG("Failed to register %s driver: %d\n",
+			       mtk_hdmi_drivers[i]->driver.name, ret);
+			goto err;
+		}
+	}
+
+	return 0;
+
+err:
+	while (--i >= 0)
+		platform_driver_unregister(mtk_hdmi_drivers[i]);
+
+	return ret;
+}
+
+static void __exit mtk_hdmitx_exit(void)
+{
+	int i;
+
+	for (i = ARRAY_SIZE(mtk_hdmi_drivers) - 1; i >= 0; i--)
+		platform_driver_unregister(mtk_hdmi_drivers[i]);
+}
+
+module_init(mtk_hdmitx_init);
+module_exit(mtk_hdmitx_exit);
+
+MODULE_AUTHOR("Can Zeng <can.zeng@mediatek.com>");
+MODULE_DESCRIPTION("MediaTek HDMI Driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/gpu/drm/mediatek/mediatek_v2/mtk_hdmi.h b/drivers/gpu/drm/mediatek/mediatek_v2/mtk_hdmi.h
new file mode 100644
index 0000000000000000000000000000000000000000..d2b4d06ef29c9516ff26ad44f092bc0370d819fb
--- /dev/null
+++ b/drivers/gpu/drm/mediatek/mediatek_v2/mtk_hdmi.h
@@ -0,0 +1,321 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2019 MediaTek Inc.
+ */
+
+#ifndef _MTK_HDMI_CTRL_H
+#define _MTK_HDMI_CTRL_H
+
+#include <linux/hdmi.h>
+#include <drm/drm_bridge.h>
+#include <drm/drm_atomic_helper.h>
+#include <drm/drm_crtc.h>
+#include <drm/drm_crtc_helper.h>
+#include <drm/drm_edid.h>
+#include <linux/platform_device.h>
+#include <linux/i2c.h>
+#include <sound/hdmi-codec.h>
+#include <linux/clk.h>
+#include <linux/mutex.h>
+#include "mtk_hdmi_hdcp.h"
+
+#define RGB444_8bit  BIT(0)
+#define RGB444_10bit BIT(1)
+#define RGB444_12bit BIT(2)
+#define RGB444_16bit BIT(3)
+#define YCBCR444_8bit  BIT(4)
+#define YCBCR444_10bit BIT(5)
+#define YCBCR444_12bit BIT(6)
+#define YCBCR444_16bit BIT(7)
+#define YCBCR422_8bit_NO_SUPPORT  BIT(8)
+#define YCBCR422_10bit_NO_SUPPORT BIT(9)
+#define YCBCR422_12bit BIT(10)
+#define YCBCR422_16bit_NO_SUPPORT BIT(11)
+#define YCBCR420_8bit  BIT(12)
+#define YCBCR420_10bit BIT(13)
+#define YCBCR420_12bit BIT(14)
+#define YCBCR420_16bit BIT(15)
+
+
+#define NCTS_BYTES	7
+
+enum mtk_hdmi_clk_id {
+	MTK_HDMI_CLK_HDMI_TXPLL,
+	MTK_HDMI_CLK_UNIVPLL_D6D4,
+	MTK_HDMI_CLK_MSDCPLL_D2,
+	MTK_HDMI_CLK_HDMI_APB_SEL,
+	MTK_HDMI_UNIVPLL_D4D8,
+	MTK_HDIM_HDCP_SEL,
+	MTK_HDMI_HDCP_24M_SEL,
+	MTK_HDMI_VPP_SPLIT_HDMI,
+	MTK_HDMI_CLK_COUNT,
+};
+
+enum hdmi_aud_input_type {
+	HDMI_AUD_INPUT_I2S = 0,
+	HDMI_AUD_INPUT_SPDIF,
+};
+
+enum hdmi_aud_i2s_fmt {
+	HDMI_I2S_MODE_RJT_24BIT = 0,
+	HDMI_I2S_MODE_RJT_16BIT,
+	HDMI_I2S_MODE_LJT_24BIT,
+	HDMI_I2S_MODE_LJT_16BIT,
+	HDMI_I2S_MODE_I2S_24BIT,
+	HDMI_I2S_MODE_I2S_16BIT
+};
+
+enum hdmi_aud_mclk {
+	HDMI_AUD_MCLK_128FS,
+	HDMI_AUD_MCLK_192FS,
+	HDMI_AUD_MCLK_256FS,
+	HDMI_AUD_MCLK_384FS,
+	HDMI_AUD_MCLK_512FS,
+	HDMI_AUD_MCLK_768FS,
+	HDMI_AUD_MCLK_1152FS,
+};
+
+enum hdmi_aud_channel_type {
+	HDMI_AUD_CHAN_TYPE_1_0 = 0,
+	HDMI_AUD_CHAN_TYPE_1_1,
+	HDMI_AUD_CHAN_TYPE_2_0,
+	HDMI_AUD_CHAN_TYPE_2_1,
+	HDMI_AUD_CHAN_TYPE_3_0,
+	HDMI_AUD_CHAN_TYPE_3_1,
+	HDMI_AUD_CHAN_TYPE_4_0,
+	HDMI_AUD_CHAN_TYPE_4_1,
+	HDMI_AUD_CHAN_TYPE_5_0,
+	HDMI_AUD_CHAN_TYPE_5_1,
+	HDMI_AUD_CHAN_TYPE_6_0,
+	HDMI_AUD_CHAN_TYPE_6_1,
+	HDMI_AUD_CHAN_TYPE_7_0,
+	HDMI_AUD_CHAN_TYPE_7_1,
+	HDMI_AUD_CHAN_TYPE_3_0_LRS,
+	HDMI_AUD_CHAN_TYPE_3_1_LRS,
+	HDMI_AUD_CHAN_TYPE_4_0_CLRS,
+	HDMI_AUD_CHAN_TYPE_4_1_CLRS,
+	HDMI_AUD_CHAN_TYPE_6_1_CS,
+	HDMI_AUD_CHAN_TYPE_6_1_CH,
+	HDMI_AUD_CHAN_TYPE_6_1_OH,
+	HDMI_AUD_CHAN_TYPE_6_1_CHR,
+	HDMI_AUD_CHAN_TYPE_7_1_LH_RH,
+	HDMI_AUD_CHAN_TYPE_7_1_LSR_RSR,
+	HDMI_AUD_CHAN_TYPE_7_1_LC_RC,
+	HDMI_AUD_CHAN_TYPE_7_1_LW_RW,
+	HDMI_AUD_CHAN_TYPE_7_1_LSD_RSD,
+	HDMI_AUD_CHAN_TYPE_7_1_LSS_RSS,
+	HDMI_AUD_CHAN_TYPE_7_1_LHS_RHS,
+	HDMI_AUD_CHAN_TYPE_7_1_CS_CH,
+	HDMI_AUD_CHAN_TYPE_7_1_CS_OH,
+	HDMI_AUD_CHAN_TYPE_7_1_CS_CHR,
+	HDMI_AUD_CHAN_TYPE_7_1_CH_OH,
+	HDMI_AUD_CHAN_TYPE_7_1_CH_CHR,
+	HDMI_AUD_CHAN_TYPE_7_1_OH_CHR,
+	HDMI_AUD_CHAN_TYPE_7_1_LSS_RSS_LSR_RSR,
+	HDMI_AUD_CHAN_TYPE_6_0_CS,
+	HDMI_AUD_CHAN_TYPE_6_0_CH,
+	HDMI_AUD_CHAN_TYPE_6_0_OH,
+	HDMI_AUD_CHAN_TYPE_6_0_CHR,
+	HDMI_AUD_CHAN_TYPE_7_0_LH_RH,
+	HDMI_AUD_CHAN_TYPE_7_0_LSR_RSR,
+	HDMI_AUD_CHAN_TYPE_7_0_LC_RC,
+	HDMI_AUD_CHAN_TYPE_7_0_LW_RW,
+	HDMI_AUD_CHAN_TYPE_7_0_LSD_RSD,
+	HDMI_AUD_CHAN_TYPE_7_0_LSS_RSS,
+	HDMI_AUD_CHAN_TYPE_7_0_LHS_RHS,
+	HDMI_AUD_CHAN_TYPE_7_0_CS_CH,
+	HDMI_AUD_CHAN_TYPE_7_0_CS_OH,
+	HDMI_AUD_CHAN_TYPE_7_0_CS_CHR,
+	HDMI_AUD_CHAN_TYPE_7_0_CH_OH,
+	HDMI_AUD_CHAN_TYPE_7_0_CH_CHR,
+	HDMI_AUD_CHAN_TYPE_7_0_OH_CHR,
+	HDMI_AUD_CHAN_TYPE_7_0_LSS_RSS_LSR_RSR,
+	HDMI_AUD_CHAN_TYPE_8_0_LH_RH_CS,
+	HDMI_AUD_CHAN_TYPE_UNKNOWN = 0xFF
+};
+
+enum hdmi_aud_channel_swap_type {
+	HDMI_AUD_SWAP_LR,
+	HDMI_AUD_SWAP_LFE_CC,
+	HDMI_AUD_SWAP_LSRS,
+	HDMI_AUD_SWAP_RLS_RRS,
+	HDMI_AUD_SWAP_LR_STATUS,
+};
+
+struct hdmi_audio_param {
+	enum hdmi_audio_coding_type aud_codec;
+	enum hdmi_audio_sample_size aud_sampe_size;
+	enum hdmi_aud_input_type aud_input_type;
+	enum hdmi_aud_i2s_fmt aud_i2s_fmt;
+	enum hdmi_aud_mclk aud_mclk;
+	enum hdmi_aud_channel_type aud_input_chan_type;
+	struct hdmi_codec_params codec_params;
+};
+
+enum hdmi_color_depth {
+	HDMI_8_BIT,
+	HDMI_10_BIT,
+	HDMI_12_BIT,
+	HDMI_16_BIT
+};
+
+struct mtk_hdmi_edid {
+	unsigned char edid[EDID_LENGTH * 4];
+	unsigned char blk_num;
+};
+
+enum HDMI_HPD_STATE {
+	HDMI_PLUG_OUT = 0,
+	HDMI_PLUG_IN_AND_SINK_POWER_ON,
+	HDMI_PLUG_IN_ONLY,
+};
+
+struct mtk_hdmi {
+	struct drm_bridge bridge;
+	struct drm_connector conn;
+	struct device *dev;
+	struct phy *phy;
+	struct mtk_hdmi_phy *hdmi_phy_base;
+	struct device *cec_dev;
+	struct cec_notifier *notifier;
+	struct i2c_adapter *ddc_adpt;
+	struct clk *clk[MTK_HDMI_CLK_COUNT];
+	struct drm_display_mode mode;
+	bool dvi_mode;
+	u32 max_hdisplay;
+	u32 max_vdisplay;
+	void __iomem *regs;
+	spinlock_t property_lock;
+	struct drm_property *hdmi_info_blob;
+	struct drm_property_blob *hdmi_info_blob_ptr;
+	struct drm_property *csp_depth_prop;
+	uint64_t support_csp_depth;
+	uint64_t set_csp_depth;
+	enum hdmi_colorspace csp;
+	enum hdmi_color_depth color_depth;
+	enum hdmi_colorimetry colorimtery;
+	enum hdmi_extended_colorimetry extended_colorimetry;
+	enum hdmi_quantization_range quantization_range;
+	enum hdmi_ycc_quantization_range ycc_quantization_range;
+	struct mtk_hdmi_edid raw_edid;
+
+	struct hdmi_audio_param aud_param;
+	bool audio_enable;
+	struct device *codec_dev;
+	hdmi_codec_plugged_cb plugged_cb;
+
+	bool powered;
+	bool enabled;
+	unsigned int hdmi_irq;
+	enum HDMI_HPD_STATE hpd;
+	struct workqueue_struct *hdmi_wq;
+	struct delayed_work hpd_work;
+	struct delayed_work hdr10_delay_work;
+	struct delayed_work hdr10vsif_delay_work;
+	struct mutex hdr_mutex;
+
+#ifdef CONFIG_DRM_MEDIATEK_HDMI_HDCP
+	bool repeater_hdcp;
+	wait_queue_head_t hdcp_wq;
+	struct task_struct *hdcp_task;
+	struct timer_list hdcp_timer;
+	bool enable_hdcp;
+	bool hdcp_2x_support;
+	bool key_is_installed;
+	bool bin_is_loaded;
+	bool donwstream_is_repeater;
+	enum HDCP_CTRL_STATE_T hdcp_ctrl_state;
+#endif
+
+	bool hdmi_enabled;
+	bool power_clk_enabled;
+	bool irq_registered;
+};
+
+extern struct platform_driver mtk_cec_driver;
+extern struct platform_driver mtk_hdmi_ddc_driver;
+extern struct platform_driver mtk_hdmi_phy_driver;
+
+extern struct mtk_hdmi *global_mtk_hdmi;
+
+u32 mtk_hdmi_read(struct mtk_hdmi *hdmi, u32 offset);
+void mtk_hdmi_write(struct mtk_hdmi *hdmi, u32 offset, u32 val);
+void mtk_hdmi_mask(struct mtk_hdmi *hdmi,
+	u32 offset, u32 val, u32 mask);
+void mtk_hdmi_clk_enable(struct mtk_hdmi *hdmi);
+void mtk_hdmi_clk_disable(struct mtk_hdmi *hdmi);
+void mtk_hdmi_AV_mute(struct mtk_hdmi *hdmi);
+void mtk_hdmi_AV_unmute(struct mtk_hdmi *hdmi);
+bool mtk_hdmi_tmds_over_340M(struct mtk_hdmi *hdmi);
+extern void mtk_dpi_pattern_en(bool enable);
+struct mtk_hdmi_ddc *hdmi_ddc_ctx_from_mtk_hdmi(struct mtk_hdmi *hdmi);
+void mtk_hdmi_colorspace_setting(struct mtk_hdmi *hdmi);
+int mtk_hdmi_setup_h14b_vsif(struct mtk_hdmi *hdmi, struct drm_display_mode *mode);
+int mtk_hdmi_setup_avi_infoframe(struct mtk_hdmi *hdmi, struct drm_display_mode *mode);
+void mtk_hdmi_audio_reset(struct mtk_hdmi *hdmi, bool rst);
+void mtk_hdmi_hw_send_aud_packet(struct mtk_hdmi *hdmi, bool enable);
+void mtk_hdmi_hw_vid_black(struct mtk_hdmi *hdmi, bool black);
+void mtk_hdmi_hw_aud_mute(struct mtk_hdmi *hdmi);
+void mtk_hdmi_hw_aud_unmute(struct mtk_hdmi *hdmi);
+void mtk_hdmi_handle_plugged_change(struct mtk_hdmi *hdmi, bool plugged);
+
+#ifdef CONFIG_DRM_MEDIATEK_HDMI
+struct mtk_hdmi_edid *mtk_hdmi_get_raw_edid(struct drm_bridge *bridge);
+unsigned int set_hdmi_colorspace_depth(struct drm_bridge *bridge, uint64_t colorspace_depth);
+unsigned int set_hdmi_colorimetry_range(struct drm_bridge *bridge,
+	enum hdmi_colorimetry colorimtery, enum hdmi_extended_colorimetry extended_colorimetry,
+	enum hdmi_quantization_range quantization_range,
+	enum hdmi_ycc_quantization_range ycc_quantization_range);
+unsigned int get_hdmi_colorspace_colorimetry(struct drm_bridge *bridge,
+	enum hdmi_colorspace *colorspace, enum hdmi_colorimetry *colorimtery,
+	enum hdmi_extended_colorimetry *extended_colorimetry,
+	enum hdmi_quantization_range *quantization_range,
+	enum hdmi_ycc_quantization_range *ycc_quantization_range);
+#else
+inline struct mtk_hdmi_edid *mtk_hdmi_get_raw_edid(struct drm_bridge *bridge)
+{
+	return NULL;
+}
+inline unsigned int set_hdmi_colorspace_depth(struct drm_bridge *bridge, uint64_t colorspace_depth)
+{
+	return 0;
+}
+inline unsigned int set_hdmi_colorimetry_range(struct drm_bridge *bridge,
+	enum hdmi_colorimetry colorimtery, enum hdmi_extended_colorimetry extended_colorimetry,
+	enum hdmi_quantization_range quantization_range,
+	enum hdmi_ycc_quantization_range ycc_quantization_range)
+{
+	return 0;
+}
+inline unsigned int get_hdmi_colorspace_colorimetry(struct drm_bridge *bridge,
+	enum hdmi_colorspace *colorspace, enum hdmi_colorimetry *colorimtery,
+	enum hdmi_extended_colorimetry *extended_colorimetry,
+	enum hdmi_quantization_range *quantization_range,
+	enum hdmi_ycc_quantization_range *ycc_quantization_range)
+{
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_DRM_MEDIATEK_HDMI_HDCP
+void hdmi_hdcp_start(void);
+void hdmi_hdcp_stop(void);
+#endif
+
+int mtk_hdmi_enable_disable(struct mtk_hdmi *hdmi, bool enable);
+int mtk_drm_ioctl_enable_hdmi(struct drm_device *dev, void *data, struct drm_file *file_priv);
+
+/* struct mtk_hdmi_info is used to propagate blob property to userspace */
+struct mtk_hdmi_info {
+	unsigned short edid_sink_colorimetry;
+	unsigned char edid_sink_rgb_color_bit;
+	unsigned char edid_sink_ycbcr_color_bit;
+	unsigned char ui1_sink_dc420_color_bit;
+	unsigned short edid_sink_max_tmds_clock;
+	unsigned short edid_sink_max_tmds_character_rate;
+	unsigned char edid_sink_support_dynamic_hdr;
+};
+
+int mtk_hdmi_update_hdmi_info_property(struct mtk_hdmi *hdmi);
+
+#endif /* _MTK_HDMI_CTRL_H */
diff --git a/drivers/gpu/drm/mediatek/mediatek_v2/mtk_hdmi_ca.c b/drivers/gpu/drm/mediatek/mediatek_v2/mtk_hdmi_ca.c
new file mode 100644
index 0000000000000000000000000000000000000000..a3225ad5000a1814657f221a8217d17c1d853330
--- /dev/null
+++ b/drivers/gpu/drm/mediatek/mediatek_v2/mtk_hdmi_ca.c
@@ -0,0 +1,437 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2019 MediaTek Inc.
+ */
+
+
+
+#ifdef CONFIG_OPTEE
+#include <linux/kernel.h>
+#include <linux/slab.h>
+
+#include "tz_cross/trustzone.h"
+#include "tz_cross/ta_test.h"
+#include "tz_cross/ta_mem.h"
+#include "trustzone/kree/system.h"
+#include "trustzone/kree/mem.h"
+
+#include "mtk_hdmi_ca.h"
+#include "mtk_hdmi_hdcp.h"
+
+unsigned char mtk_hdmi_ca_log = 1;
+
+#define HDMI_CA_LOG(fmt, arg...) \
+	do {	if (mtk_hdmi_ca_log) { \
+		pr_info("[HDMI][CA] %s,%d "fmt, __func__, __LINE__, ##arg); \
+		} \
+	} while (0)
+
+#define HDMI_CA_FUNC()	\
+	do {	if (mtk_hdmi_ca_log) \
+		pr_info("[HDMI][CA] %s\n", __func__); \
+	} while (0)
+
+KREE_SESSION_HANDLE ca_hdmi_session;
+
+bool fgCaHDMICreate(void)
+{
+	int tz_ret = 0;
+
+	tz_ret = KREE_CreateSession(TZ_TA_HDMI_UUID, &ca_hdmi_session);
+	if (tz_ret != TZ_RESULT_SUCCESS) {
+		/* Should provide strerror style error string in UREE. */
+		HDMI_CA_LOG("Create ca_hdmi_session Error: %d\n", tz_ret);
+		return false;
+	}
+	HDMI_CA_LOG("Create ca_hdmi_session ok: %d\n", tz_ret);
+
+	return true;
+}
+
+bool fgCaHDMIClose(void)
+{
+	int tz_ret = 0;
+
+	tz_ret = KREE_CloseSession(ca_hdmi_session);
+	if (tz_ret != TZ_RESULT_SUCCESS) {
+		/* Should provide strerror style error string in UREE. */
+		HDMI_CA_LOG("Close ca_hdmi_session Error: %d\n", tz_ret);
+		return false;
+	}
+	HDMI_CA_LOG("Close ca_hdmi_session ok: %d\n", tz_ret);
+
+	return true;
+}
+
+void vCaHDMIWriteReg(unsigned int u4addr, unsigned int u4data)
+{
+	int tz_ret = 0;
+	union MTEEC_PARAM param[2];
+
+	if (ca_hdmi_session == 0) {
+		HDMI_CA_LOG("[CA]TEE ca_hdmi_session=0\n");
+		return;
+	}
+
+	param[0].value.a = u4addr & 0xFFF;
+	param[0].value.b = 0;
+	param[1].value.a = u4data;
+	param[1].value.b = 0;
+
+	tz_ret = KREE_TeeServiceCall(ca_hdmi_session, HDMI_TA_WRITE_REG,
+				     TZ_ParamTypes2(TZPT_VALUE_INPUT,
+				     TZPT_VALUE_INPUT), param);
+
+	if (tz_ret != TZ_RESULT_SUCCESS)
+		HDMI_CA_LOG("[CA] HDMI_TA_WRITE_REG err:%X\n", tz_ret);
+
+}
+
+void vCaHDMIWriteHDCPRST(unsigned int u4addr, unsigned int u4data)
+{
+	int tz_ret = 0;
+	union MTEEC_PARAM param[2];
+
+	if (ca_hdmi_session == 0) {
+		HDMI_CA_LOG("[CA]TEE ca_hdmi_session=0\n");
+		return;
+	}
+
+	param[0].value.a = u4addr;
+	param[0].value.b = 0;
+	param[1].value.a = u4data;
+	param[1].value.b = 0;
+
+	tz_ret = KREE_TeeServiceCall(ca_hdmi_session, HDMI_TA_HDCP_RST,
+				     TZ_ParamTypes2(TZPT_VALUE_INPUT,
+				     TZPT_VALUE_INPUT), param);
+
+	if (tz_ret != TZ_RESULT_SUCCESS)
+		HDMI_CA_LOG("[CA] HDMI_TA_WRITE_REG err:%X\n", tz_ret);
+
+}
+
+void vCaHDMIWriteHdcpCtrl(unsigned int u4addr, unsigned int u4data)
+{
+	int tz_ret = 0;
+	union MTEEC_PARAM param[2];
+
+	if (ca_hdmi_session == 0) {
+		HDMI_CA_LOG("[HDMI] TEE ca_hdmi_session=0\n");
+		return;
+	}
+
+	param[0].value.a = u4addr;
+	param[0].value.b = 0;
+	param[1].value.a = u4data;
+	param[1].value.b = 0;
+
+	tz_ret = KREE_TeeServiceCall(ca_hdmi_session, HDMI_TA_WRITE_REG,
+				     TZ_ParamTypes2(TZPT_VALUE_INPUT,
+				     TZPT_VALUE_INPUT), param);
+
+	if (tz_ret != TZ_RESULT_SUCCESS)
+		HDMI_CA_LOG("[CA]HDMI_TA_WRITE_REG err:%X\n", tz_ret);
+}
+
+bool fgCaHDMIInstallHdcpKey(unsigned char *pdata, unsigned int u4Len)
+{
+	int tz_ret = 0;
+	union MTEEC_PARAM param[2];
+
+	KREE_SHAREDMEM_HANDLE hdmitx_shm_handle;
+	struct KREE_SHAREDMEM_PARAM hdmitx_shm_param;
+
+	if (ca_hdmi_session == 0) {
+		HDMI_CA_LOG("[CA] TEE ca_hdmi_session=0\n");
+		return false;
+	}
+	HDMI_CA_LOG("[CA]%s,%d\n", __func__, u4Len);
+
+	if (u4Len > HDCPKEY_LENGTH_DRM)
+		return false;
+
+	hdmitx_shm_param.buffer = pdata;
+	hdmitx_shm_param.size = u4Len;
+
+	tz_ret = KREE_RegisterSharedmem(ca_hdmi_session,
+		&hdmitx_shm_handle, &hdmitx_shm_param);
+	if (tz_ret != TZ_RESULT_SUCCESS) {
+		HDMI_CA_LOG("[CA]KREE_RegisterSharedmem Error\n");
+		return false;
+	}
+
+	param[0].memref.handle = (uint32_t) hdmitx_shm_handle;
+	param[0].memref.offset = 0;
+	param[0].memref.size = u4Len;
+
+	param[1].value.a = u4Len;
+	param[1].value.b = 0;
+
+	tz_ret = KREE_TeeServiceCall(ca_hdmi_session, HDMI_TA_INSTALL_HDCP_KEY,
+				     TZ_ParamTypes2(TZPT_MEMREF_INPUT,
+				     TZPT_VALUE_INPUT), param);
+
+	if (tz_ret != TZ_RESULT_SUCCESS) {
+		HDMI_CA_LOG("[CA] HDMI_TA_INSTALL_HDCP_KEY err:%X\n", tz_ret);
+
+		tz_ret = KREE_UnregisterSharedmem(ca_hdmi_session,
+			hdmitx_shm_handle);
+		if (tz_ret != TZ_RESULT_SUCCESS)
+			HDMI_CA_LOG("[CA]KREE_UnregisterSharedmem Error\n");
+		return false;
+	}
+
+	tz_ret = KREE_UnregisterSharedmem(ca_hdmi_session,
+		hdmitx_shm_handle);
+	if (tz_ret != TZ_RESULT_SUCCESS) {
+		HDMI_CA_LOG("[CA]KREE_UnregisterSharedmem Error\n");
+		return false;
+	}
+
+	return true;
+}
+
+bool fgCaHDMIGetAKsv(unsigned char *pdata)
+{
+	int tz_ret = 0;
+	union MTEEC_PARAM param[1];
+	unsigned char *ptr;
+	unsigned char i;
+	KREE_SHAREDMEM_HANDLE hdmitx_shm_handle;
+	struct KREE_SHAREDMEM_PARAM hdmitx_shm_param;
+
+	if (ca_hdmi_session == 0) {
+		HDMI_CA_LOG("[CA] TEE ca_hdmi_session=0\n");
+		return false;
+	}
+
+	ptr = kmalloc(HDCP_AKSV_COUNT, GFP_KERNEL);
+	if (ptr == NULL) {
+		HDMI_CA_LOG("[CA] AKSV kmalloc failure\n");
+		return false;
+	}
+
+	hdmitx_shm_param.buffer = ptr;
+	hdmitx_shm_param.size = HDCP_AKSV_COUNT;
+	tz_ret = KREE_RegisterSharedmem(ca_hdmi_session,
+		&hdmitx_shm_handle, &hdmitx_shm_param);
+	if (tz_ret != TZ_RESULT_SUCCESS) {
+		HDMI_CA_LOG("[CA]KREE_RegisterSharedmem Error\n");
+		return false;
+	}
+
+	param[0].memref.handle = (uint32_t) hdmitx_shm_handle;
+	param[0].memref.offset = 0;
+	param[0].memref.size = HDCP_AKSV_COUNT;
+	tz_ret = KREE_TeeServiceCall(ca_hdmi_session, HDMI_TA_GET_HDCP_AKSV,
+			TZ_ParamTypes1(TZPT_MEMREF_OUTPUT), param);
+	if (tz_ret != TZ_RESULT_SUCCESS) {
+		HDMI_CA_LOG("[CA]HDMI_TA_GET_HDCP_AKSV err:%X\n", tz_ret);
+
+		tz_ret = KREE_UnregisterSharedmem(ca_hdmi_session,
+			hdmitx_shm_handle);
+		if (tz_ret != TZ_RESULT_SUCCESS)
+			HDMI_CA_LOG("[CA]KREE_UnregisterSharedmem Error\n");
+		kfree(ptr);
+		return false;
+	}
+
+	tz_ret = KREE_UnregisterSharedmem(ca_hdmi_session,
+		hdmitx_shm_handle);
+	if (tz_ret != TZ_RESULT_SUCCESS) {
+		HDMI_CA_LOG("[CA]KREE_UnregisterSharedmem Error\n");
+		kfree(ptr);
+		return false;
+	}
+
+	for (i = 0; i < HDCP_AKSV_COUNT; i++)
+		pdata[i] = ptr[i];
+
+	HDMI_CA_LOG("[CA]hdcp aksv : %x %x %x %x %x\n",
+		   pdata[0], pdata[1], pdata[2], pdata[3], pdata[4]);
+	kfree(ptr);
+	return true;
+
+}
+
+bool fgCaHDMIGetTAStatus(unsigned char *pdata)
+{
+	int tz_ret = 0;
+	union MTEEC_PARAM param[1];
+	unsigned char *ptr;
+	KREE_SHAREDMEM_HANDLE hdmitx_shm_handle;
+	struct KREE_SHAREDMEM_PARAM hdmitx_shm_param;
+
+	if (ca_hdmi_session == 0) {
+		HDMI_CA_LOG("[CA] TEE ca_hdmi_session=0\n");
+		return false;
+	}
+
+	ptr = kmalloc(2, GFP_KERNEL);
+	if (ptr == NULL) {
+		HDMI_CA_LOG("[CA]%s\n", __func__);
+		return false;
+	}
+
+	hdmitx_shm_param.buffer = ptr;
+	hdmitx_shm_param.size = 2;
+	tz_ret = KREE_RegisterSharedmem(ca_hdmi_session,
+		&hdmitx_shm_handle, &hdmitx_shm_param);
+	if (tz_ret != TZ_RESULT_SUCCESS) {
+		HDMI_CA_LOG("[CA]KREE_RegisterSharedmem Error\n");
+		return false;
+	}
+
+	param[0].memref.handle = (uint32_t) hdmitx_shm_handle;
+	param[0].memref.offset = 0;
+	param[0].memref.size = 2;
+	tz_ret = KREE_TeeServiceCall(ca_hdmi_session, HDMI_TA_READ_STATUS,
+				     TZ_ParamTypes1(TZPT_MEMREF_OUTPUT), param);
+	if (tz_ret != TZ_RESULT_SUCCESS) {
+		HDMI_CA_LOG("[CA]%s err:%X\n", __func__, tz_ret);
+
+		tz_ret = KREE_UnregisterSharedmem(ca_hdmi_session,
+			hdmitx_shm_handle);
+		if (tz_ret != TZ_RESULT_SUCCESS)
+			HDMI_CA_LOG("[CA]KREE_UnregisterSharedmem Error\n");
+		kfree(ptr);
+		return false;
+	}
+
+	tz_ret = KREE_UnregisterSharedmem(ca_hdmi_session,
+		hdmitx_shm_handle);
+	if (tz_ret != TZ_RESULT_SUCCESS) {
+		HDMI_CA_LOG("[CA]KREE_UnregisterSharedmem Error\n");
+		kfree(ptr);
+		return false;
+	}
+
+	pdata[0] = ptr[0];
+	pdata[1] = ptr[1];
+
+	kfree(ptr);
+	return true;
+}
+
+bool fgCaHDMILoadHDCPKey(void)
+{
+	int tz_ret = 0;
+	union MTEEC_PARAM param[1];
+
+	HDMI_CA_LOG("[CA] %s\n", __func__);
+	if (ca_hdmi_session == 0) {
+		HDMI_CA_LOG("[CA] TEE ca_hdmi_session=0\n");
+		return false;
+	}
+	param[0].value.a = 0;
+	param[0].value.b = 0;
+
+	tz_ret = KREE_TeeServiceCall(ca_hdmi_session, HDMI_TA_LOAD_HDCP_KEY,
+				     TZ_ParamTypes1(TZPT_VALUE_INPUT), param);
+
+	if (tz_ret != TZ_RESULT_SUCCESS) {
+		HDMI_CA_LOG("[CA] HDMI_TA_LOAD_HDCP_KEY err:%X\n", tz_ret);
+		return false;
+	}
+	return true;
+}
+
+bool fgCaHDMILoadROM(void)
+{
+	int tz_ret = 0;
+	union MTEEC_PARAM param[1];
+
+	if (ca_hdmi_session == 0) {
+		HDMI_CA_LOG("[CA] TEE ca_hdmi_session=0\n");
+		return false;
+	}
+
+	param[0].value.a = 0;
+	param[0].value.b = 0;
+
+	tz_ret = KREE_TeeServiceCall(ca_hdmi_session, HDMI_TA_LOAD_ROM,
+				     TZ_ParamTypes1(TZPT_VALUE_INPUT), param);
+
+	if (tz_ret != TZ_RESULT_SUCCESS) {
+		HDMI_CA_LOG("[CA]HDMI_TA_LOAD_ROM err:%X\n", tz_ret);
+		return false;
+	}
+	return true;
+}
+
+
+bool fgCaHDMITestHDCPVersion(void)
+{
+	int tz_ret = 0;
+	union MTEEC_PARAM param[1];
+
+	if (ca_hdmi_session == 0) {
+		HDMI_CA_LOG("[CA] TEE ca_hdmi_session=0\n");
+		return false;
+	}
+
+	param[0].value.a = 0;
+	param[0].value.b = 0;
+
+	tz_ret = KREE_TeeServiceCall(ca_hdmi_session, HDMI_TA_TEST_HDCP_VERSION,
+				     TZ_ParamTypes1(TZPT_VALUE_INPUT), param);
+
+	if (tz_ret != TZ_RESULT_SUCCESS) {
+		HDMI_CA_LOG("[CA]HDMI_TA_TEST_HDCP_VERSION err:%X\n", tz_ret);
+		return false;
+	}
+	return true;
+}
+
+void fgCaHDMISetTzLogLevel(unsigned int loglevel)
+{
+	int tz_ret = 0;
+	union MTEEC_PARAM param[2];
+
+	if (ca_hdmi_session == 0) {
+		HDMI_CA_LOG("[HDMI] TEE ca_hdmi_session=0\n");
+		return;
+	}
+
+	param[0].value.a = loglevel;
+	param[0].value.b = 0;
+
+	tz_ret = KREE_TeeServiceCall(ca_hdmi_session, HDMI_TA_SET_LOG_LEVEL,
+				     TZ_ParamTypes1(TZPT_VALUE_INPUT), param);
+
+	if (tz_ret != TZ_RESULT_SUCCESS)
+		HDMI_CA_LOG("[CA]HDMI_TA_SET_LOG_LEVEL err:%X\n", tz_ret);
+}
+
+void fgCaHDMISetSecureRegEntry(unsigned int Tx_entry,
+	unsigned int Rx_entry)
+{
+	int tz_ret = 0;
+	union MTEEC_PARAM param[2];
+
+	if (ca_hdmi_session == 0) {
+		HDMI_CA_LOG("[CA]TEE ca_hdmi_session=0\n");
+		return;
+	}
+
+	param[0].value.a = Tx_entry;
+	param[0].value.b = 0;
+	param[1].value.a = Rx_entry;
+	param[1].value.b = 0;
+
+	tz_ret = KREE_TeeServiceCall(ca_hdmi_session, HDMI_TA_SECURE_REG_ENTRY,
+				     TZ_ParamTypes2(TZPT_VALUE_INPUT,
+				     TZPT_VALUE_INPUT), param);
+
+	if (tz_ret != TZ_RESULT_SUCCESS)
+		HDMI_CA_LOG("[CA] HDMI_TA_SECURE_REG_ENTRY err:%X\n", tz_ret);
+}
+
+void hdmi_ca_init(void)
+{
+	if (ca_hdmi_session == 0)
+		fgCaHDMICreate();
+}
+
+#endif
diff --git a/drivers/gpu/drm/mediatek/mediatek_v2/mtk_hdmi_ca.h b/drivers/gpu/drm/mediatek/mediatek_v2/mtk_hdmi_ca.h
new file mode 100644
index 0000000000000000000000000000000000000000..32d24d758d20b150d67685ef5b803b02dceb3285
--- /dev/null
+++ b/drivers/gpu/drm/mediatek/mediatek_v2/mtk_hdmi_ca.h
@@ -0,0 +1,63 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2019 MediaTek Inc.
+ */
+
+
+
+#ifndef _HDMI_CA_H_
+#define _HDMI_CA_H_
+
+#ifdef CONFIG_OPTEE
+
+#include <linux/types.h>
+
+#define TZ_TA_HDMI_UUID "eaf800b0-da1b-11e2-a28f-0800200c9a66"
+
+enum HDMI_TA_SERVICE_CMD_T {
+	HDMI_TA_WRITE_REG = 0,
+	HDMI_TA_DPI1_WRITE_REG,
+	HDMI_TA_INSTALL_HDCP_KEY,
+	HDMI_TA_LOAD_HDCP_KEY,
+	HDMI_TA_GET_HDCP_AKSV,
+	HDMI_TA_HDCP_ENC_EN,
+	HDMI_TA_HDCP_RST,
+	HDMI_TA_VID_UNMUTE,
+	HDMI_TA_AUD_UNMUTE,
+	HDMI_TA_PROTECT_HDMIREG,
+	HDMI_TA_LOAD_ROM,
+	HDMI_TA_HDCP_FAIL,
+	HDMI_TA_TEST_HDCP_VERSION,
+	HDMI_TA_SET_LOG_LEVEL,
+	HDMI_TA_HDCP_OFF,
+	HDMI_TA_READ_STATUS,
+	HDMI_TA_LOAD_RAM,
+	HDMI_TA_SECURE_REG_ENTRY,
+};
+
+enum TA_RETURN_HDMI_HDCP_STATE {
+	TA_RETURN_HDCP_STATE_ENC_EN = 0,
+	TA_RETURN_HDCP_STATE_ENC_FAIL,
+	TA_RETURN_HDCP_STATE_ENC_UNKNOWN,
+};
+
+bool fgCaHDMICreate(void);
+bool fgCaHDMIClose(void);
+void vCaHDMIWriteReg(unsigned int u4addr, unsigned int u4data);
+bool fgCaHDMIInstallHdcpKey(unsigned char *pdata, unsigned int u4Len);
+bool fgCaHDMIGetAKsv(unsigned char *pdata);
+bool fgCaHDMILoadHDCPKey(void);
+bool fgCaHDMILoadROM(void);
+void vCaHDMIWriteHdcpCtrl(unsigned int u4addr, unsigned int u4data);
+bool fgCaHDMITestHDCPVersion(void);
+void vCaHDMIWriteHDCPRST(unsigned int u4addr, unsigned int u4data);
+void fgCaHDMISetTzLogLevel(unsigned int loglevel);
+bool fgCaHDMIGetTAStatus(unsigned char *pdata);
+void fgCaHDMISetSecureRegEntry(unsigned int Tx_entry,
+	unsigned int Rx_entry);
+
+void hdmi_ca_init(void);
+
+
+#endif
+#endif
diff --git a/drivers/gpu/drm/mediatek/mediatek_v2/mtk_hdmi_ddc.c b/drivers/gpu/drm/mediatek/mediatek_v2/mtk_hdmi_ddc.c
new file mode 100644
index 0000000000000000000000000000000000000000..33553e9aff3e22db17e91a6b4be34a89d8a7f742
--- /dev/null
+++ b/drivers/gpu/drm/mediatek/mediatek_v2/mtk_hdmi_ddc.c
@@ -0,0 +1,911 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2019 MediaTek Inc.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/time.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/err.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/io.h>
+#include <linux/iopoll.h>
+#include <linux/of_address.h>
+#include <linux/of_irq.h>
+#include <linux/of_platform.h>
+#include <linux/semaphore.h>
+
+#include "mtk_hdmi_ddc.h"
+#include "mtk_hdmi_regs.h"
+#include "mtk_hdmi_hdcp.h"
+#include "mtk_hdmi_ca.h"
+#include "mtk_hdmi.h"
+#include "mtk_hdmi_edid.h"
+
+unsigned char mtk_ddc_log = 1;
+
+#define HDMI_DDC_LOG(fmt, arg...) \
+	do {	if (mtk_ddc_log) { \
+		pr_info("[HDMI][DDC] %s,%d "fmt, __func__, __LINE__, ##arg); \
+		} \
+	} while (0)
+
+#define HDMI_DDC_FUNC()	\
+	do {	if (mtk_ddc_log) \
+		pr_info("[HDMI][DDC] %s\n", __func__); \
+	} while (0)
+
+enum SIF_BIT_T_HDMI {
+	SIF_8_BIT_HDMI,		/* /< [8 bits data address.] */
+	SIF_16_BIT_HDMI,	/* /< [16 bits data address.] */
+};
+
+enum SIF_BIT_T {
+	SIF_8_BIT,		/* /< [8 bits data address.] */
+	SIF_16_BIT,		/* /< [16 bits data address.] */
+};
+
+inline bool mtk_ddc_readbit(struct mtk_hdmi_ddc *ddc,
+	unsigned short reg, unsigned int offset)
+{
+	return (readl(ddc->regs + reg) & offset) ? true : false;
+}
+
+inline unsigned int mtk_ddc_read(
+	struct mtk_hdmi_ddc *ddc, unsigned short reg)
+{
+	return readl(ddc->regs + reg);
+}
+
+inline void mtk_ddc_write(struct mtk_hdmi_ddc *ddc,
+	unsigned short reg, unsigned int val)
+{
+	writel(val, ddc->regs + reg);
+}
+
+inline void mtk_ddc_mask(struct mtk_hdmi_ddc *ddc,
+	unsigned int reg, unsigned int val, unsigned int mask)
+{
+	unsigned int tmp;
+
+	tmp = readl(ddc->regs + reg) & ~mask;
+	tmp |= (val & mask);
+	writel(tmp, ddc->regs + reg);
+}
+
+DEFINE_SEMAPHORE(hdcp_ddc_mutex);
+static unsigned int ddc_count;
+/* 1: hdmi reset, 2: risc DDC, 3: hdcp2.x reset, 4: requset DDC */
+bool hdmi_ddc_request(struct mtk_hdmi_ddc *ddc, unsigned char req)
+{
+#ifdef CONFIG_DRM_MEDIATEK_HDMI_HDCP
+	unsigned int i;
+#endif
+
+	if (down_interruptible(&hdcp_ddc_mutex)) {
+		HDMI_DDC_LOG(
+		"can't get semaphore in for boot time\n");
+		return true;
+	}
+
+	ddc_count++;
+
+	if (req == 1)
+		HDMI_DDC_LOG(">HDMI reset request DDC, %d\n", ddc_count);
+	else if (req == 3)
+		HDMI_DDC_LOG(">HDCP2.x rst request DDC, %d\n", ddc_count);
+	else if (req == 4)
+		HDMI_DDC_LOG(">request DDC, %d\n", ddc_count);
+
+#ifdef CONFIG_DRM_MEDIATEK_HDMI_HDCP
+	/* if hdcp2.x enable and req is hdcp1.x, then return */
+	if (req == 2)
+		return true;
+	if (req == 5) {
+		/* reset DDC */
+		mtk_ddc_mask(ddc, TOP_MISC_CTLR, DISABLE_IDLE_DDC_RESET,
+			DISABLE_IDLE_DDC_RESET);
+#ifdef CONFIG_OPTEE
+		vCaHDMIWriteHDCPRST(RISC_CLK_DDC_RST, RISC_CLK_DDC_RST);
+		udelay(1);
+		vCaHDMIWriteHDCPRST(0, RISC_CLK_DDC_RST);
+#endif
+		mtk_ddc_mask(ddc, TOP_MISC_CTLR, 0, DISABLE_IDLE_DDC_RESET);
+
+		/* send stop cmd */
+		if (mtk_ddc_read(ddc, HDCP2X_DDCM_STATUS) & DDC_I2C_BUS_LOW) {
+			mtk_ddc_mask(ddc, DDC_CTRL, (CLOCK_SCL <<
+				DDC_CMD_SHIFT), DDC_CMD);
+			udelay(250);
+		}
+		return true;
+	}
+
+	if ((mtk_ddc_read(ddc, HDCP2X_CTRL_0) & HDCP2X_EN) == 0)
+		return true;
+
+	/* step1 : wait hdcp2.x auth finish */
+	if (req == 4) {
+		for (i = 0; i < 1000; i++) {
+			if (fgHDMIHdcp2Auth() == false)
+				break;
+			usleep_range(1000, 1500);
+		}
+		HDMI_DDC_LOG("hdcp2.x stop, %d, %d\n", i,
+			bHDMIHDCP2Err());
+	} else {
+		HDMI_DDC_LOG("req %d, hdcp2.x state %d\n",
+			req, bHDMIHDCP2Err());
+	}
+#endif
+
+	/* step2 : stop polling */
+	mtk_ddc_mask(ddc, HDCP2X_POL_CTRL,
+	HDCP2X_DIS_POLL_EN, HDCP2X_DIS_POLL_EN);
+
+#ifdef CONFIG_DRM_MEDIATEK_HDMI_HDCP
+	/* step4 : stop hdcp2.x */
+	mtk_ddc_mask(ddc, HDCP2X_GP_IN, 0xdb << HDCP2X_GP_IN3_SHIFT,
+	HDCP2X_GP_IN3);
+
+	/* step5 : wait hdcp2.x msg finish */
+	for (i = 0; i < 100; i++) {
+		if ((mtk_ddc_read(ddc, HPD_DDC_STATUS) & DDC_I2C_IN_PROG) == 0) {
+			mtk_ddc_mask(ddc, HDCP2X_CTRL_0, 0, HDCP2X_EN);
+			break;
+		}
+		usleep_range(1000, 1050);
+	}
+
+	if (i == 100) {
+		HDMI_DDC_LOG("DDC error, %d\n", bHDMIHDCP2Err());
+
+		/* reset DDC */
+		mtk_ddc_mask(ddc, TOP_MISC_CTLR, DISABLE_IDLE_DDC_RESET,
+			DISABLE_IDLE_DDC_RESET);
+#ifdef CONFIG_OPTEE
+		vCaHDMIWriteHDCPRST(RISC_CLK_DDC_RST, RISC_CLK_DDC_RST);
+		udelay(1);
+		vCaHDMIWriteHDCPRST(0, RISC_CLK_DDC_RST);
+#endif
+		mtk_ddc_mask(ddc, TOP_MISC_CTLR, 0, DISABLE_IDLE_DDC_RESET);
+
+		/* send stop cmd */
+		if (mtk_ddc_read(ddc, HDCP2X_DDCM_STATUS) & DDC_I2C_BUS_LOW) {
+			mtk_ddc_mask(ddc, DDC_CTRL,
+				(CLOCK_SCL << DDC_CMD_SHIFT), DDC_CMD);
+			udelay(250);
+		}
+	} else if (i > 1) {
+		HDMI_DDC_LOG("DDC stop, %d, %d\n", i, bHDMIHDCP2Err());
+	}
+
+	/* step6 : disable HDCP2.x */
+	mtk_ddc_mask(ddc, HDCP2X_CTRL_0, 0, HDCP2X_EN);
+
+	/* step7 : reset HDCP2.x */
+#ifdef CONFIG_OPTEE
+	/* SOFT_HDCP_RST, SOFT_HDCP_RST); */
+	vCaHDMIWriteHDCPRST(SOFT_HDCP_RST, SOFT_HDCP_RST);
+	/* SOFT_HDCP_CORE_RST, SOFT_HDCP_CORE_RST); */
+	vCaHDMIWriteHDCPRST(SOFT_HDCP_CORE_RST, SOFT_HDCP_CORE_RST);
+	udelay(1);
+	/* SOFT_HDCP_NOR, SOFT_HDCP_RST); */
+	vCaHDMIWriteHDCPRST(SOFT_HDCP_NOR, SOFT_HDCP_RST);
+	/* SOFT_HDCP_CORE_NOR, SOFT_HDCP_CORE_RST); */
+	vCaHDMIWriteHDCPRST(SOFT_HDCP_CORE_NOR, SOFT_HDCP_CORE_RST);
+#endif
+
+	/* step8 : free hdcp2.x */
+	mtk_ddc_mask(ddc, HDCP2X_GP_IN, 0 << HDCP2X_GP_IN3_SHIFT, HDCP2X_GP_IN3);
+#endif
+
+	return true;
+}
+
+void hdmi_ddc_free(struct mtk_hdmi_ddc *ddc, unsigned char req)
+{
+	up(&hdcp_ddc_mutex);
+
+	if (req == 1)
+		HDMI_DDC_LOG("HDMI reset free DDC, %d\n", ddc_count);
+	else if (req == 3)
+		HDMI_DDC_LOG("HDCP2.x rst free DDC, %d\n", ddc_count);
+	else if (req == 4)
+		HDMI_DDC_LOG("free DDC, %d\n", ddc_count);
+}
+
+static unsigned char _DDCMRead(struct mtk_hdmi_ddc *ddc,
+	unsigned char ucCurAddrMode,
+	unsigned int u4ClkDiv, unsigned char ucDev,
+	unsigned int u4Addr, enum SIF_BIT_T ucAddrType,
+	unsigned char *pucValue, unsigned int u4Count)
+{
+	unsigned int i, temp_length, loop_counter;
+	unsigned int ucReadCount, ucIdx;
+
+	if ((pucValue == NULL) || (u4Count == 0) || (u4ClkDiv == 0))
+		return 0;
+
+	ucIdx = 0;
+
+	if (u4Count >= 16) {
+		temp_length = 16;
+		loop_counter = u4Count / 16;
+	} else {
+		temp_length = u4Count;
+		loop_counter = 1;
+	}
+
+	mtk_ddc_mask(ddc, HPD_DDC_CTRL, u4ClkDiv <<
+		DDC_DELAY_CNT_SHIFT, DDC_DELAY_CNT);
+	for (i = 0; i < loop_counter; i++) {
+		if (ucDev > EDID_ID) {
+			mtk_ddc_mask(ddc, SCDC_CTRL, (ucDev - EDID_ID) <<
+				DDC_SEGMENT_SHIFT, DDC_SEGMENT);
+			mtk_ddc_write(ddc, DDC_CTRL,
+				(ENH_READ_NO_ACK << DDC_CMD_SHIFT) +
+				(temp_length << DDC_DIN_CNT_SHIFT) +
+				((u4Addr + i * temp_length) <<
+				DDC_OFFSET_SHIFT) + (EDID_ID << 1));
+		} else {
+			mtk_ddc_write(ddc, DDC_CTRL,
+				(SEQ_READ_NO_ACK << DDC_CMD_SHIFT) +
+				(temp_length << DDC_DIN_CNT_SHIFT)
+				+ ((u4Addr + i * temp_length) <<
+				DDC_OFFSET_SHIFT) + (ucDev << 1));
+		}
+
+		msleep(20);
+
+		for (ucIdx = 0; ucIdx < temp_length; ucIdx++) {
+			mtk_ddc_write(ddc, SI2C_CTRL, (SI2C_ADDR_READ <<
+				SI2C_ADDR_SHIFT) + SI2C_RD);
+			mtk_ddc_write(ddc, SI2C_CTRL,
+				(SI2C_ADDR_READ << SI2C_ADDR_SHIFT) +
+				SI2C_CONFIRM_READ);
+
+			pucValue[i * 16 + ucIdx] =
+			    (mtk_ddc_read(ddc, HPD_DDC_STATUS) &
+			    DDC_DATA_OUT) >> DDC_DATA_OUT_SHIFT;
+
+			ucReadCount = i * 16 + ucIdx + 1;
+		}
+	}
+	return ucReadCount;
+}
+
+
+void DDC_WR_ONE(struct mtk_hdmi_ddc *ddc,
+	unsigned int addr_id, unsigned int offset_id,
+	unsigned char wr_data)
+{
+	unsigned int i;
+
+	if (mtk_ddc_read(ddc, HDCP2X_DDCM_STATUS) &
+		DDC_I2C_BUS_LOW) {
+		mtk_ddc_mask(ddc, DDC_CTRL,
+			(CLOCK_SCL << DDC_CMD_SHIFT), DDC_CMD);
+		udelay(250);
+	}
+	mtk_ddc_mask(ddc, HPD_DDC_CTRL, DDC2_CLOK<<
+		DDC_DELAY_CNT_SHIFT, DDC_DELAY_CNT);
+	mtk_ddc_write(ddc, SI2C_CTRL, SI2C_ADDR_READ <<
+		SI2C_ADDR_SHIFT);
+	mtk_ddc_mask(ddc, SI2C_CTRL,
+		wr_data << SI2C_WDATA_SHIFT, SI2C_WDATA);
+	mtk_ddc_mask(ddc, SI2C_CTRL, SI2C_WR, SI2C_WR);
+
+	mtk_ddc_write(ddc, DDC_CTRL, (SEQ_WRITE_REQ_ACK <<
+		DDC_CMD_SHIFT) + (1 << DDC_DIN_CNT_SHIFT)
+		+ (offset_id << DDC_OFFSET_SHIFT) + (addr_id << 1));
+
+	for (i = 0; i < 5; i++)
+		udelay(200);
+
+/*	if ((mtk_ddc_read(ddc, HPD_DDC_STATUS) &
+ *		DDC_I2C_IN_PROG) == 0)
+ *		HDMI_DDC_LOG("[HDMI][DDC] error: time out\n");
+ */
+	if ((mtk_ddc_read(ddc, HDCP2X_DDCM_STATUS) &
+		(DDC_I2C_NO_ACK | DDC_I2C_BUS_LOW))) {
+		if ((mtk_ddc_read(ddc, DDC_CTRL) & 0xFF) == (RX_ID << 1))
+			HDMI_DDC_LOG(
+			"[1x]err_w:0xc10=0x%08x,0xc60=0x%08x,0xc68=0x%08x\n",
+			mtk_ddc_read(ddc, DDC_CTRL),
+			mtk_ddc_read(ddc, HPD_DDC_STATUS),
+			mtk_ddc_read(ddc, HDCP2X_DDCM_STATUS));
+		else
+			HDMI_DDC_LOG(
+			"err_w:0xc10=0x%08x,0xc60=0x%08x,0xc68=0x%08x\n",
+			mtk_ddc_read(ddc, DDC_CTRL),
+			mtk_ddc_read(ddc, HPD_DDC_STATUS),
+			mtk_ddc_read(ddc, HDCP2X_DDCM_STATUS));
+		if (mtk_ddc_read(ddc, HDCP2X_DDCM_STATUS) & DDC_I2C_BUS_LOW) {
+			mtk_ddc_mask(ddc, DDC_CTRL,
+				(CLOCK_SCL << DDC_CMD_SHIFT),
+				DDC_CMD);
+			udelay(250);
+		}
+	}
+}
+
+static unsigned char _DDCMWrite(struct mtk_hdmi_ddc *ddc,
+	unsigned char ucCurAddrMode, unsigned int u4ClkDiv,
+	unsigned char ucDev, unsigned int u4Addr,
+	enum SIF_BIT_T ucAddrType, const unsigned char *pucValue,
+	unsigned int u4Count)
+{
+	unsigned int i;
+
+	for (i = 0; i < u4Count; i++) {
+		DDC_WR_ONE(ddc, ucDev, u4Addr + i, *(pucValue + i));
+		mdelay(2);
+	}
+
+	return u4Count;
+}
+
+unsigned int DDCM_RanAddr_Write(struct mtk_hdmi_ddc *ddc,
+	unsigned int u4ClkDiv, unsigned char ucDev, unsigned int u4Addr,
+	enum SIF_BIT_T ucAddrType, const unsigned char *pucValue,
+	unsigned int u4Count)
+{
+	unsigned int u4WriteCount1 = 0;
+	unsigned char ucReturnVaule = 0;
+
+	if ((pucValue == NULL) ||
+	    (u4Count == 0) ||
+	    (u4ClkDiv == 0) ||
+	    (ucAddrType > SIF_16_BIT) ||
+	    ((ucAddrType == SIF_8_BIT) && (u4Addr > 255)) ||
+	    ((ucAddrType == SIF_16_BIT) && (u4Addr > 65535))) {
+		return 0;
+	}
+
+
+	if (ucAddrType == SIF_8_BIT)
+		u4WriteCount1 = ((255 - u4Addr) + 1);
+	else if (ucAddrType == SIF_16_BIT)
+		u4WriteCount1 = ((65535 - u4Addr) + 1);
+
+	u4WriteCount1 = (u4WriteCount1 > u4Count) ? u4Count : u4WriteCount1;
+	ucReturnVaule = _DDCMWrite(ddc, 0, u4ClkDiv, ucDev,
+		u4Addr, ucAddrType, pucValue, u4WriteCount1);
+
+	return (unsigned int)ucReturnVaule;
+}
+
+unsigned int DDCM_CurAddr_Read(struct mtk_hdmi_ddc *ddc,
+	unsigned int u4ClkDiv, unsigned char ucDev,
+	unsigned char *pucValue, unsigned int u4Count)
+{
+	unsigned char ucReturnVaule;
+
+	HDMI_DDC_FUNC();
+
+	if ((pucValue == NULL) || (u4Count == 0) || (u4ClkDiv == 0))
+		return 0;
+
+	ucReturnVaule = _DDCMRead(ddc, 1, u4ClkDiv, ucDev, 0,
+		SIF_8_BIT, pucValue, u4Count);
+
+	return (unsigned int)ucReturnVaule;
+}
+
+unsigned char DDCM_RanAddr_Read(struct mtk_hdmi_ddc *ddc,
+	unsigned int u4ClkDiv, unsigned char ucDev,
+	unsigned int u4Addr, enum SIF_BIT_T ucAddrType,
+	unsigned char *pucValue, unsigned int u4Count)
+{
+	unsigned int u4ReadCount = 0;
+	unsigned char ucReturnVaule = 0;
+
+	HDMI_DDC_FUNC();
+	if ((pucValue == NULL) ||
+	    (u4Count == 0) ||
+	    (u4ClkDiv == 0) ||
+	    (ucAddrType > SIF_16_BIT) ||
+	    ((ucAddrType == SIF_8_BIT) && (u4Addr > 255)) ||
+	    ((ucAddrType == SIF_16_BIT) && (u4Addr > 65535))) {
+		return 0;
+	}
+
+	if (ucAddrType == SIF_8_BIT)
+		u4ReadCount = ((255 - u4Addr) + 1);
+	else if (ucAddrType == SIF_16_BIT)
+		u4ReadCount = ((65535 - u4Addr) + 1);
+
+	u4ReadCount = (u4ReadCount > u4Count) ? u4Count : u4ReadCount;
+	ucReturnVaule = _DDCMRead(ddc, 0, u4ClkDiv, ucDev,
+		u4Addr, ucAddrType, pucValue, u4ReadCount);
+
+
+	return ucReturnVaule;
+}
+
+unsigned char _DDCMRead_hdmi(struct mtk_hdmi_ddc *ddc,
+	unsigned char ucCurAddrMode, unsigned int u4ClkDiv,
+	unsigned char ucDev, unsigned int u4Addr,
+	enum SIF_BIT_T_HDMI ucAddrType,
+	unsigned char *pucValue, unsigned int u4Count)
+{
+	unsigned int i, temp_length, loop_counter, temp_ksvlist, device_n;
+	unsigned int ucReadCount, ucIdx;
+	unsigned long DdcStartTime, DdcEndTime, DdcTimeOut;
+
+	if ((pucValue == NULL) || (u4Count == 0) || (u4ClkDiv == 0))
+		return 0;
+
+	ucIdx = 0;
+	if (mtk_ddc_read(ddc, HDCP2X_DDCM_STATUS) & DDC_I2C_BUS_LOW) {
+		mtk_ddc_mask(ddc, DDC_CTRL,
+			(CLOCK_SCL << DDC_CMD_SHIFT), DDC_CMD);
+		udelay(250);
+	}
+
+	mtk_ddc_mask(ddc, DDC_CTRL,
+		(CLEAR_FIFO << DDC_CMD_SHIFT), DDC_CMD);
+
+	if (u4Addr == 0x43) {
+		mtk_ddc_write(ddc, DDC_CTRL,
+			(SEQ_READ_NO_ACK << DDC_CMD_SHIFT) +
+			(u4Count << DDC_DIN_CNT_SHIFT) +
+			(u4Addr << DDC_OFFSET_SHIFT) +
+			(ucDev << 1));
+		udelay(250);
+		udelay(250);
+		udelay(200);
+
+		if (u4Count > 10)
+			temp_ksvlist = 10;
+		else
+			temp_ksvlist = u4Count;
+
+		for (ucIdx = 0; ucIdx < temp_ksvlist; ucIdx++) {
+			mtk_ddc_write(ddc, SI2C_CTRL,
+				(SI2C_ADDR_READ << SI2C_ADDR_SHIFT) + SI2C_RD);
+			mtk_ddc_write(ddc, SI2C_CTRL,
+				(SI2C_ADDR_READ << SI2C_ADDR_SHIFT) +
+				SI2C_CONFIRM_READ);
+
+			pucValue[ucIdx] =
+				(mtk_ddc_read(ddc, HPD_DDC_STATUS) &
+				DDC_DATA_OUT) >> DDC_DATA_OUT_SHIFT;
+			udelay(100);
+
+		}
+
+		if (u4Count == temp_ksvlist)
+			return (ucIdx + 1);
+
+		udelay(250);
+		udelay(250);
+
+		if (u4Count / 5 == 3)
+			device_n = 5;
+		else
+			device_n = 10;
+
+		for (ucIdx = 10; ucIdx < (10 + device_n); ucIdx++) {
+
+			mtk_ddc_write(ddc, SI2C_CTRL,
+				(SI2C_ADDR_READ << SI2C_ADDR_SHIFT) + SI2C_RD);
+			mtk_ddc_write(ddc, SI2C_CTRL,
+				(SI2C_ADDR_READ <<
+				SI2C_ADDR_SHIFT) + SI2C_CONFIRM_READ);
+
+			pucValue[ucIdx] =
+			    (mtk_ddc_read(ddc, HPD_DDC_STATUS) &
+			    DDC_DATA_OUT) >> DDC_DATA_OUT_SHIFT;
+			udelay(100);
+		}
+
+		if (u4Count == (10 + device_n))
+			return (ucIdx + 1);
+
+		udelay(250);
+		udelay(250);
+
+		if (u4Count / 5 == 5)
+			device_n = 5;
+		else
+			device_n = 10;
+
+		for (ucIdx = 20; ucIdx < (20 + device_n); ucIdx++) {
+
+			mtk_ddc_write(ddc, SI2C_CTRL,
+				(SI2C_ADDR_READ << SI2C_ADDR_SHIFT) + SI2C_RD);
+			mtk_ddc_write(ddc, SI2C_CTRL,
+				(SI2C_ADDR_READ <<
+				SI2C_ADDR_SHIFT) + SI2C_CONFIRM_READ);
+
+			pucValue[ucIdx] =
+			    (mtk_ddc_read(ddc, HPD_DDC_STATUS) &
+			    DDC_DATA_OUT) >> DDC_DATA_OUT_SHIFT;
+			udelay(100);
+		}
+
+		if (u4Count == (20 + device_n))
+			return (ucIdx + 1);
+
+		udelay(250);
+		udelay(250);
+
+		if (u4Count / 5 == 7)
+			device_n = 5;
+		else
+			device_n = 10;
+
+		for (ucIdx = 30; ucIdx < (30 + device_n); ucIdx++) {
+
+			mtk_ddc_write(ddc, SI2C_CTRL,
+				(SI2C_ADDR_READ << SI2C_ADDR_SHIFT) + SI2C_RD);
+			mtk_ddc_write(ddc, SI2C_CTRL,
+				(SI2C_ADDR_READ << SI2C_ADDR_SHIFT)
+				+ SI2C_CONFIRM_READ);
+
+			pucValue[ucIdx] =
+			    (mtk_ddc_read(ddc, HPD_DDC_STATUS) &
+			    DDC_DATA_OUT) >> DDC_DATA_OUT_SHIFT;
+			udelay(100);
+		}
+
+		if (u4Count == (30 + device_n))
+			return (ucIdx + 1);
+
+		udelay(250);
+		udelay(250);
+
+		for (ucIdx = 40; ucIdx < (40 + 5); ucIdx++) {
+
+			mtk_ddc_write(ddc, SI2C_CTRL,
+				(SI2C_ADDR_READ << SI2C_ADDR_SHIFT) + SI2C_RD);
+			mtk_ddc_write(ddc, SI2C_CTRL,
+				(SI2C_ADDR_READ <<
+				SI2C_ADDR_SHIFT) + SI2C_CONFIRM_READ);
+
+			pucValue[ucIdx] =
+			    (mtk_ddc_read(ddc, HPD_DDC_STATUS) &
+			    DDC_DATA_OUT) >> DDC_DATA_OUT_SHIFT;
+			udelay(100);
+		}
+
+		if (u4Count == 45)
+			return (ucIdx + 1);
+	} else {
+		if (u4Count >= 16) {
+			temp_length = 16;
+			loop_counter = u4Count / 16 +
+				((u4Count % 16 == 0) ? 0 : 1);
+		} else {
+			temp_length = u4Count;
+			loop_counter = 1;
+		}
+		if (ucDev >= EDID_ID) {
+			if (u4ClkDiv < DDC2_CLOK_EDID)
+				u4ClkDiv = DDC2_CLOK_EDID;
+		}
+		mtk_ddc_mask(ddc, HPD_DDC_CTRL, u4ClkDiv <<
+			DDC_DELAY_CNT_SHIFT, DDC_DELAY_CNT);
+		for (i = 0; i < loop_counter; i++) {
+			if ((i == (loop_counter - 1)) && (i != 0) &&
+				(u4Count % 16))
+				temp_length = u4Count % 16;
+
+			if (ucDev > EDID_ID) {
+				mtk_ddc_mask(ddc, SCDC_CTRL,
+					(ucDev - EDID_ID) <<
+					DDC_SEGMENT_SHIFT, DDC_SEGMENT);
+				mtk_ddc_write(ddc, DDC_CTRL,
+					(ENH_READ_NO_ACK << DDC_CMD_SHIFT) +
+					(temp_length << DDC_DIN_CNT_SHIFT) +
+					((u4Addr + i * temp_length) <<
+					DDC_OFFSET_SHIFT) +
+					(EDID_ID << 1));
+			} else {
+				mtk_ddc_write(ddc, DDC_CTRL,
+					(SEQ_READ_NO_ACK << DDC_CMD_SHIFT) +
+					(temp_length << DDC_DIN_CNT_SHIFT) +
+					((u4Addr + ((u4Addr == 0x43) ?
+					0 : (i * 16))) <<
+					DDC_OFFSET_SHIFT) + (ucDev << 1));
+			}
+			mdelay(2);
+			DdcStartTime = jiffies;
+			DdcTimeOut = temp_length + 5;
+			DdcEndTime = DdcStartTime + (DdcTimeOut) * HZ / 1000;
+			while (1) {
+				if ((mtk_ddc_read(ddc, HPD_DDC_STATUS) &
+					DDC_I2C_IN_PROG) == 0)
+					break;
+
+				if (time_after(jiffies, DdcEndTime)) {
+					pr_info(
+					"[HDMI][DDC] error: time out\n");
+					return 0;
+				}
+				mdelay(1);
+			}
+			if ((mtk_ddc_read(ddc, HDCP2X_DDCM_STATUS) &
+			     (DDC_I2C_NO_ACK | DDC_I2C_BUS_LOW))) {
+				if ((mtk_ddc_read(ddc, DDC_CTRL) &
+					0xFF) ==
+					(RX_ID << 1))
+					HDMI_DDC_LOG(
+		"[1x]err_r:0xc10=0x%08x,0xc60=0x%08x,0xc68=0x%08x\n",
+					mtk_ddc_read(ddc, DDC_CTRL),
+					mtk_ddc_read(ddc, HPD_DDC_STATUS),
+					mtk_ddc_read(ddc, HDCP2X_DDCM_STATUS));
+				else
+					HDMI_DDC_LOG(
+			"err_r:0xc10=0x%08x,0xc60=0x%08x,0xc68=0x%08x\n",
+					mtk_ddc_read(ddc, DDC_CTRL),
+					mtk_ddc_read(ddc, HPD_DDC_STATUS),
+					mtk_ddc_read(ddc, HDCP2X_DDCM_STATUS));
+				if (mtk_ddc_read(ddc, HDCP2X_DDCM_STATUS) &
+					DDC_I2C_BUS_LOW) {
+					mtk_ddc_mask(ddc, DDC_CTRL,
+					(CLOCK_SCL << DDC_CMD_SHIFT),
+					DDC_CMD);
+					udelay(250);
+				}
+				return 0;
+			}
+			for (ucIdx = 0; ucIdx < temp_length; ucIdx++) {
+				mtk_ddc_write(ddc, SI2C_CTRL,
+					(SI2C_ADDR_READ <<
+					SI2C_ADDR_SHIFT) + SI2C_RD);
+				mtk_ddc_write(ddc, SI2C_CTRL,
+					(SI2C_ADDR_READ <<
+					SI2C_ADDR_SHIFT) +
+					SI2C_CONFIRM_READ);
+
+				pucValue[i * 16 + ucIdx] =
+				    (mtk_ddc_read(ddc, HPD_DDC_STATUS) &
+				    DDC_DATA_OUT) >>
+				    DDC_DATA_OUT_SHIFT;
+		/*
+		 * when reading edid, if hdmi module been reset,
+		 * ddc will fail and it's
+		 *speed will be set to 400.
+		 */
+				if (((mtk_ddc_read(ddc, HPD_DDC_CTRL) >> 16) &
+					0xFFFF) < DDC2_CLOK) {
+					HDMI_DDC_LOG(
+						"error: speed dev=0x%x; addr=0x%x\n",
+						ucDev, u4Addr);
+					return 0;
+				}
+
+				ucReadCount = i * 16 + ucIdx + 1;
+			}
+		}
+		return ucReadCount;
+	}
+	return 0;
+}
+
+unsigned char fgDDCBusy;
+unsigned char vDDCRead(struct mtk_hdmi_ddc *ddc,
+	unsigned int u4ClkDiv, unsigned char ucDev,
+	unsigned int u4Addr, enum SIF_BIT_T_HDMI ucAddrType,
+	unsigned char *pucValue, unsigned int u4Count)
+{
+	unsigned int u4ReadCount = 0;
+	unsigned char ucReturnVaule = 0;
+
+
+	if ((pucValue == NULL) ||
+	    (u4Count == 0) ||
+	    (u4ClkDiv == 0) ||
+	    (ucAddrType > SIF_16_BIT_HDMI) ||
+	    ((ucAddrType == SIF_8_BIT_HDMI) && (u4Addr > 255)) ||
+	    ((ucAddrType == SIF_16_BIT_HDMI) && (u4Addr > 65535))) {
+		return 0;
+	}
+
+	if (ucAddrType == SIF_8_BIT_HDMI)
+		u4ReadCount = ((255 - u4Addr) + 1);
+	else if (ucAddrType == SIF_16_BIT_HDMI)
+		u4ReadCount = ((65535 - u4Addr) + 1);
+
+	u4ReadCount = (u4ReadCount > u4Count) ? u4Count : u4ReadCount;
+	ucReturnVaule =
+	    _DDCMRead_hdmi(ddc, 0, u4ClkDiv,
+	    ucDev, u4Addr, ucAddrType, pucValue, u4ReadCount);
+	return ucReturnVaule;
+}
+
+unsigned char fgDDCDataRead(struct mtk_hdmi_ddc *ddc,
+	unsigned char bDevice, unsigned char bData_Addr,
+	unsigned char bDataCount, unsigned char *prData)
+{
+	bool flag;
+
+	//HDMI_DDC_FUNC();
+
+	while (fgDDCBusy == 1) {
+		HDMI_DDC_LOG("[HDMI][DDC]DDC read busy\n");
+		mdelay(2);
+	}
+	fgDDCBusy = 1;
+
+	hdmi_ddc_request(ddc, 2);
+	if (vDDCRead(ddc, DDC2_CLOK, (unsigned char)bDevice,
+		(unsigned int)bData_Addr, SIF_8_BIT_HDMI,
+		(unsigned char *)prData, (unsigned int)bDataCount)
+		== bDataCount) {
+		fgDDCBusy = 0;
+		flag = true;
+	} else {
+		fgDDCBusy = 0;
+		flag = false;
+}
+	hdmi_ddc_free(ddc, 2);
+
+	return flag;
+}
+
+unsigned char fgDDCDataWrite(struct mtk_hdmi_ddc *ddc,
+	unsigned char bDevice, unsigned char bData_Addr,
+	unsigned char bDataCount, unsigned char *prData)
+{
+	unsigned int i;
+
+	HDMI_DDC_FUNC();
+	while (fgDDCBusy == 1) {
+		HDMI_DDC_LOG("[HDMI][DDC]DDC write busy\n");
+		mdelay(2);
+	}
+	fgDDCBusy = 1;
+
+	hdmi_ddc_request(ddc, 2);
+	for (i = 0; i < bDataCount; i++)
+		DDC_WR_ONE(ddc, bDevice, bData_Addr + i, *(prData + i));
+	hdmi_ddc_free(ddc, 2);
+
+	fgDDCBusy = 0;
+	return 1;
+}
+
+static int mtk_hdmi_ddc_xfer(struct i2c_adapter *adapter,
+			     struct i2c_msg *msgs, int num)
+{
+	struct mtk_hdmi_ddc *ddc = adapter->algo_data;
+	struct device *dev = adapter->dev.parent;
+	int ret;
+	int i;
+
+	if (!ddc) {
+		HDMI_DDC_LOG("invalid arguments\n");
+		return -EINVAL;
+	}
+
+	for (i = 0; i < num; i++) {
+		struct i2c_msg *msg = &msgs[i];
+
+		HDMI_DDC_LOG("i2c msg, adr:0x%x, flags:%d, len :0x%x\n",
+			msg->addr, msg->flags, msg->len);
+
+		if (msg->flags & I2C_M_RD)
+			ret = fgDDCDataRead(ddc, msg->addr, msg->buf[0],
+				(msg->len), &msg->buf[0]);
+			//can.zeng todo verify
+		else
+			ret = fgDDCDataWrite(ddc, msg->addr, msg->buf[0],
+				(msg->len - 1), &msg->buf[1]);
+			//can.zeng todo verify
+
+		if (ret <= 0)
+			goto xfer_end;
+	}
+
+
+	return i;
+
+xfer_end:
+	dev_err(dev, "ddc failed!\n");
+	return ret;
+}
+
+static u32 mtk_hdmi_ddc_func(struct i2c_adapter *adapter)
+{
+	return I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;
+}
+
+static const struct i2c_algorithm mtk_hdmi_ddc_algorithm = {
+	.master_xfer = mtk_hdmi_ddc_xfer,
+	.functionality = mtk_hdmi_ddc_func,
+};
+
+static int mtk_hdmi_ddc_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct mtk_hdmi_ddc *ddc;
+	//struct resource *mem;
+	int ret;
+
+	HDMI_DDC_LOG("probe start\n");
+
+	ddc = devm_kzalloc(dev, sizeof(struct mtk_hdmi_ddc), GFP_KERNEL);
+	if (!ddc)
+		return -ENOMEM;
+
+	ddc->clk = devm_clk_get(dev, "ddc-i2c");
+	if (IS_ERR(ddc->clk)) {
+		dev_err(dev, "get ddc_clk failed: %p ,\n", ddc->clk);
+		return PTR_ERR(ddc->clk);
+	}
+/*  can.zeng todo verify
+ *	mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+ *	ddc->regs = devm_ioremap_resource(&pdev->dev, mem);
+ *	if (IS_ERR(ddc->regs))
+ *		return PTR_ERR(ddc->regs);
+ */
+	ret = clk_prepare_enable(ddc->clk);
+	if (ret) {
+		dev_err(dev, "enable ddc clk failed!\n");
+		return ret;
+	}
+
+	strlcpy(ddc->adap.name, "mediatek-hdmi-ddc", sizeof(ddc->adap.name));
+	ddc->adap.owner = THIS_MODULE;
+	ddc->adap.class = I2C_CLASS_DDC;
+	ddc->adap.algo = &mtk_hdmi_ddc_algorithm;
+	ddc->adap.retries = 3;
+	ddc->adap.dev.of_node = dev->of_node;
+	ddc->adap.algo_data = ddc;
+	ddc->adap.dev.parent = &pdev->dev;
+
+	ret = i2c_add_adapter(&ddc->adap);
+	if (ret < 0) {
+		dev_err(dev, "failed to add bus to i2c core\n");
+		goto err_clk_disable;
+	}
+
+	platform_set_drvdata(pdev, ddc);
+/*
+ *	HDMI_DDC_LOG("ddc->adap: %p\n", &ddc->adap);
+ *	HDMI_DDC_LOG("ddc->clk: %p\n", ddc->clk);
+ *	HDMI_DDC_LOG("physical adr: %pa, end: %pa\n", &mem->start,
+ *		&mem->end);
+ */
+	HDMI_DDC_LOG("probe end\n");
+	return 0;
+
+err_clk_disable:
+	clk_disable_unprepare(ddc->clk);
+	return ret;
+}
+
+static int mtk_hdmi_ddc_remove(struct platform_device *pdev)
+{
+	struct mtk_hdmi_ddc *ddc = platform_get_drvdata(pdev);
+
+	i2c_del_adapter(&ddc->adap);
+	clk_disable_unprepare(ddc->clk);
+
+	return 0;
+}
+
+static const struct of_device_id mtk_hdmi_ddc_match[] = {
+	{ .compatible = "mediatek,mt8195-hdmi-ddc", },
+	{},
+};
+
+struct platform_driver mtk_hdmi_ddc_driver = {
+	.probe = mtk_hdmi_ddc_probe,
+	.remove = mtk_hdmi_ddc_remove,
+	.driver = {
+		.name = "mediatek-hdmi-ddc",
+		.of_match_table = mtk_hdmi_ddc_match,
+	},
+};
+
+MODULE_AUTHOR("Can Zeng <can.zeng@mediatek.com>");
+MODULE_DESCRIPTION("MediaTek HDMI DDC Driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/gpu/drm/mediatek/mediatek_v2/mtk_hdmi_ddc.h b/drivers/gpu/drm/mediatek/mediatek_v2/mtk_hdmi_ddc.h
new file mode 100644
index 0000000000000000000000000000000000000000..8e089540192c668af7cb46ab00ea65755ddd1e1b
--- /dev/null
+++ b/drivers/gpu/drm/mediatek/mediatek_v2/mtk_hdmi_ddc.h
@@ -0,0 +1,34 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2019 MediaTek Inc.
+ */
+
+#ifndef _MTK_DDC_H
+#define _MTK_DDC_H
+
+#include <linux/clk.h>
+#include <linux/i2c.h>
+
+struct mtk_hdmi_ddc {
+	struct i2c_adapter adap;
+	struct clk *clk;
+	void __iomem *regs;
+};
+
+
+#define SIF1_CLOK 288		/* 26M/(v) = 100Khz */
+#define DDC2_CLOK 572		/* BIM=208M/(v*4) = 90Khz */
+#define DDC2_CLOK_EDID 832	/* BIM=208M/(v*4) = 62.5Khz */
+/* for HF1-55 */
+
+unsigned char fgDDCDataRead(struct mtk_hdmi_ddc *ddc,
+	unsigned char bDevice, unsigned char bData_Addr,
+	unsigned char bDataCount, unsigned char *prData);
+unsigned char fgDDCDataWrite(struct mtk_hdmi_ddc *ddc,
+	unsigned char bDevice, unsigned char bData_Addr,
+	unsigned char bDataCount, unsigned char *prData);
+bool hdmi_ddc_request(struct mtk_hdmi_ddc *ddc, unsigned char req);
+void hdmi_ddc_free(struct mtk_hdmi_ddc *ddc, unsigned char req);
+
+
+#endif /* _MTK_DDC_H */
diff --git a/drivers/gpu/drm/mediatek/mediatek_v2/mtk_hdmi_debug.c b/drivers/gpu/drm/mediatek/mediatek_v2/mtk_hdmi_debug.c
new file mode 100644
index 0000000000000000000000000000000000000000..d2cf5bb7a4bff669aadd7d51cab0ad2b57952570
--- /dev/null
+++ b/drivers/gpu/drm/mediatek/mediatek_v2/mtk_hdmi_debug.c
@@ -0,0 +1,942 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2019 MediaTek Inc.
+ */
+
+#include <linux/delay.h>
+#include <linux/kernel.h>
+#include <linux/of_platform.h>
+#include <linux/debugfs.h>
+#include <linux/pm_runtime.h>
+
+#include "mtk_cec.h"
+#include "mtk_hdmi_ddc.h"
+#include "mtk_hdmi_phy.h"
+#include "mtk_hdmi.h"
+#include "mtk_hdmi_regs.h"
+#include "mtk_hdmi_hdr.h"
+#include "mtk_hdmi_debug.h"
+
+unsigned char mtk_hdmi_debug_log = 1;
+
+#define HDMI_DEBUG_LOG(fmt, arg...) \
+	do {	if (mtk_hdmi_debug_log) { \
+		pr_info("[HDMI][DEBUG] %s,%d "fmt, __func__, __LINE__, ##arg); \
+		} \
+	} while (0)
+
+#define HDMI_DEBUG_FUNC()	\
+	do {	if (mtk_hdmi_debug_log) \
+		pr_info("[HDMI][DEBUG] %s\n", __func__); \
+	} while (0)
+
+
+/* 1 - 640x480@60Hz 4:3 */
+struct drm_display_mode mode_640x480_60hz_4v3 = {
+	DRM_MODE("640x480", DRM_MODE_TYPE_DRIVER, 25175, 640, 656,
+	752, 800, 0, 480, 490, 492, 525, 0,
+	 DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC),
+	.picture_aspect_ratio = HDMI_PICTURE_ASPECT_4_3,};
+EXPORT_SYMBOL(mode_640x480_60hz_4v3);
+
+/* 2 - 720x480@60Hz 4:3 */
+struct drm_display_mode mode_720x480_60hz_4v3 = {
+	DRM_MODE("720x480", DRM_MODE_TYPE_DRIVER, 27000, 720, 736,
+	798, 858, 0, 480, 489, 495, 525, 0,
+	DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC),
+	.picture_aspect_ratio = HDMI_PICTURE_ASPECT_4_3,};
+EXPORT_SYMBOL(mode_720x480_60hz_4v3);
+
+/* 18 - 720x576@50Hz 16:9 */
+struct drm_display_mode mode_720x576_50hz_16v9 = {
+	DRM_MODE("720x576", DRM_MODE_TYPE_DRIVER, 27000, 720, 732,
+	796, 864, 0, 576, 581, 586, 625, 0,
+	DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC),
+	.picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9,};
+EXPORT_SYMBOL(mode_720x576_50hz_16v9);
+
+/* 19 - 1280x720@50Hz 16:9 */
+struct drm_display_mode mode_1280x720_50hz_16v9 = {
+	DRM_MODE("1280x720", DRM_MODE_TYPE_DRIVER, 74250, 1280, 1720,
+	1760, 1980, 0, 720, 725, 730, 750, 0,
+	DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9,};
+EXPORT_SYMBOL(mode_1280x720_50hz_16v9);
+
+/* 4 - 1280x720@60Hz 16:9 */
+struct drm_display_mode mode_1280x720_60hz_16v9 = {
+	DRM_MODE("1280x720", DRM_MODE_TYPE_DRIVER, 74250, 1280, 1390,
+	1430, 1650, 0, 720, 725, 730, 750, 0,
+	DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9,};
+EXPORT_SYMBOL(mode_1280x720_60hz_16v9);
+
+/* 16 - 1920x1080@60Hz 16:9 */
+struct drm_display_mode mode_1920x1080_60hz_16v9 = {
+	DRM_MODE("1920x1080", DRM_MODE_TYPE_DRIVER, 148500, 1920, 2008,
+	2052, 2200, 0, 1080, 1084, 1089, 1125, 0,
+	DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9,};
+EXPORT_SYMBOL(mode_1920x1080_60hz_16v9);
+
+/* 31 - 1920x1080@50Hz 16:9 */
+struct drm_display_mode mode_1920x1080_50hz_16v9 = {
+	DRM_MODE("1920x1080", DRM_MODE_TYPE_DRIVER, 148500, 1920, 2448,
+	2492, 2640, 0, 1080, 1084, 1089, 1125, 0,
+	DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9,};
+EXPORT_SYMBOL(mode_1920x1080_50hz_16v9);
+
+/* 32 - 1920x1080@24Hz 16:9 */
+struct drm_display_mode mode_1920x1080_24hz_16v9 = {
+	DRM_MODE("1920x1080", DRM_MODE_TYPE_DRIVER, 74250, 1920, 2558,
+	2602, 2750, 0, 1080, 1084, 1089, 1125, 0,
+	DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9,};
+EXPORT_SYMBOL(mode_1920x1080_24hz_16v9);
+
+/* 33 - 1920x1080@25Hz 16:9 */
+struct drm_display_mode mode_1920x1080_25hz_16v9 = {
+	DRM_MODE("1920x1080", DRM_MODE_TYPE_DRIVER, 74250, 1920, 2448,
+	2492, 2640, 0, 1080, 1084, 1089, 1125, 0,
+	DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9,};
+EXPORT_SYMBOL(mode_1920x1080_25hz_16v9);
+
+/* 34 - 1920x1080@30Hz 16:9 */
+struct drm_display_mode mode_1920x1080_30hz_16v9 = {
+	DRM_MODE("1920x1080", DRM_MODE_TYPE_DRIVER, 74250, 1920, 2008,
+	2052, 2200, 0, 1080, 1084, 1089, 1125, 0,
+	DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9,};
+EXPORT_SYMBOL(mode_1920x1080_30hz_16v9);
+
+/* 93 - 3840x2160@24Hz 16:9 */
+struct drm_display_mode mode_3840x2160_24hz_16v9 = {
+	DRM_MODE("3840x2160", DRM_MODE_TYPE_DRIVER, 297000, 3840, 5116,
+	5204, 5500, 0, 2160, 2168, 2178, 2250, 0,
+	DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9,};
+EXPORT_SYMBOL(mode_3840x2160_24hz_16v9);
+
+/* 94 - 3840x2160@25Hz 16:9 */
+struct drm_display_mode mode_3840x2160_25hz_16v9 = {
+	DRM_MODE("3840x2160", DRM_MODE_TYPE_DRIVER, 297000, 3840, 4896,
+	4984, 5280, 0, 2160, 2168, 2178, 2250, 0,
+	DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9,};
+EXPORT_SYMBOL(mode_3840x2160_25hz_16v9);
+
+/* 95 - 3840x2160@30Hz 16:9 */
+struct drm_display_mode mode_3840x2160_30hz_16v9 = {
+	DRM_MODE("3840x2160", DRM_MODE_TYPE_DRIVER, 297000, 3840, 4016,
+	4104, 4400, 0, 2160, 2168, 2178, 2250, 0,
+	DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9,};
+EXPORT_SYMBOL(mode_3840x2160_30hz_16v9);
+
+/* 96 - 3840x2160@50Hz 16:9 */
+struct drm_display_mode mode_3840x2160_50hz_16v9 = {
+	DRM_MODE("3840x2160", DRM_MODE_TYPE_DRIVER, 594000, 3840, 4896,
+	4984, 5280, 0, 2160, 2168, 2178, 2250, 0,
+	DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9,};
+EXPORT_SYMBOL(mode_3840x2160_50hz_16v9);
+
+/* 97 - 3840x2160@60Hz 16:9 */
+struct drm_display_mode mode_3840x2160_60hz_16v9 = {
+	DRM_MODE("3840x2160", DRM_MODE_TYPE_DRIVER, 594000, 3840, 4016,
+	4104, 4400, 0, 2160, 2168, 2178, 2250, 0,
+	DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9,};
+EXPORT_SYMBOL(mode_3840x2160_60hz_16v9);
+
+/* 98 - 4096x2160@24Hz 256:135 */
+struct drm_display_mode mode_4096x2160_24hz = {
+	DRM_MODE("4096x2160", DRM_MODE_TYPE_DRIVER, 297000, 4096, 5116,
+	5204, 5500, 0, 2160, 2168, 2178, 2250, 0,
+	DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.picture_aspect_ratio = HDMI_PICTURE_ASPECT_256_135,};
+EXPORT_SYMBOL(mode_4096x2160_24hz);
+
+/* 99 - 4096x2160@25Hz 256:135 */
+struct drm_display_mode mode_4096x2160_25hz = {
+	DRM_MODE("4096x2160", DRM_MODE_TYPE_DRIVER, 297000, 4096, 5064,
+	5152, 5280, 0, 2160, 2168, 2178, 2250, 0,
+	DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.picture_aspect_ratio = HDMI_PICTURE_ASPECT_256_135,};
+EXPORT_SYMBOL(mode_4096x2160_25hz);
+
+/* 100 - 4096x2160@30Hz 256:135 */
+struct drm_display_mode mode_4096x2160_30hz = {
+	DRM_MODE("4096x2160", DRM_MODE_TYPE_DRIVER, 297000, 4096, 4184,
+	4272, 4400, 0, 2160, 2168, 2178, 2250, 0,
+	DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.picture_aspect_ratio = HDMI_PICTURE_ASPECT_256_135,};
+EXPORT_SYMBOL(mode_4096x2160_30hz);
+
+/* 101 - 4096x2160@50Hz 256:135 */
+struct drm_display_mode mode_4096x2160_50hz = {
+	DRM_MODE("4096x2160", DRM_MODE_TYPE_DRIVER, 594000, 4096, 5064,
+	5152, 5280, 0, 2160, 2168, 2178, 2250, 0,
+	DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.picture_aspect_ratio = HDMI_PICTURE_ASPECT_256_135,};
+EXPORT_SYMBOL(mode_4096x2160_50hz);
+
+/* 102 - 4096x2160@60Hz 256:135 */
+struct drm_display_mode mode_4096x2160_60hz = {
+	DRM_MODE("4096x2160", DRM_MODE_TYPE_DRIVER, 594000, 4096, 4184,
+	4272, 4400, 0, 2160, 2168, 2178, 2250, 0,
+	DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.picture_aspect_ratio = HDMI_PICTURE_ASPECT_256_135,};
+EXPORT_SYMBOL(mode_4096x2160_60hz);
+
+
+static char debug_buffer[2048] = {0};
+static unsigned int temp_len, buf_offset;
+
+#define HDMI_ATTR_SPRINTF(fmt, arg...)  \
+do { \
+	HDMI_DEBUG_LOG(fmt, ##arg); \
+	if (buf_offset < (sizeof(debug_buffer) - 1)) { \
+		temp_len = \
+		sprintf(debug_buffer + buf_offset, fmt, ##arg);	 \
+		buf_offset += temp_len; \
+		debug_buffer[buf_offset] = 0;\
+	} \
+} while (0)
+
+static void mtk_hdmi_freq_meter(struct mtk_hdmi *hdmi,
+	unsigned int mode)
+{
+	unsigned int clockFreq;
+
+	if (mode == 1) //pixel clock
+		mtk_hdmi_mask(hdmi, 0x1a4, 0x0 << 5, 0x3 << 5);
+	else if (mode == 2) //tmds clock
+		mtk_hdmi_mask(hdmi, 0x1a4, 0x1 << 5, 0x3 << 5);
+	else if (mode == 3) //i2s sck
+		mtk_hdmi_mask(hdmi, 0x1a4, 0x2 << 5, 0x3 << 5);
+	else //i2s lrck
+		mtk_hdmi_mask(hdmi, 0x1a4, 0x3 << 5, 0x3 << 5);
+
+	mtk_hdmi_write(hdmi, 0x1d4, 0x000007ff);
+	mtk_hdmi_mask(hdmi, 0x1d0, 0x1 << 0, 0x1 << 0);
+
+	udelay(40);
+
+	clockFreq = mtk_hdmi_read(hdmi, 0x1d4);
+	clockFreq = clockFreq >> 16;
+	clockFreq = clockFreq * 24000 / 1024;
+
+	if (mode == 1)
+		HDMI_ATTR_SPRINTF("pixel clock freq meter is %d khz\n",
+			clockFreq);
+	else if (mode == 2)
+		HDMI_ATTR_SPRINTF("tmds clock freq meter is %d khz\n",
+			clockFreq);
+	else if (mode == 3)
+		HDMI_ATTR_SPRINTF("i2s Sck freq meter is %d khz\n",
+			clockFreq);
+	else
+		HDMI_ATTR_SPRINTF("i2s LRck freq meter is %d khz\n",
+			clockFreq);
+
+	HDMI_DEBUG_LOG("clock freq meter is %d khz\n", clockFreq);
+}
+
+static unsigned int mtk_hdmi_set_txpll(
+	struct mtk_hdmi *hdmi, char *str_p)
+{
+	unsigned long clkrate; // in HZ
+	int ret;
+
+	ret = kstrtol(str_p, 0, &clkrate);
+	if (ret < 1) {
+		HDMI_ATTR_SPRINTF("parameter error\n");
+		return -EINVAL;
+	}
+	HDMI_ATTR_SPRINTF("set txpll rate: %d HZ\n", clkrate);
+
+	vTxSignalOnOff(hdmi->hdmi_phy_base, false);
+	clk_disable_unprepare(hdmi->hdmi_phy_base->txpll);
+	udelay(10);
+
+	clk_set_rate(hdmi->hdmi_phy_base->txpll, clkrate);
+	udelay(10);
+
+	clk_prepare_enable(hdmi->hdmi_phy_base->txpll);
+	vTxSignalOnOff(hdmi->hdmi_phy_base, true);
+
+	mdelay(10);
+	mtk_hdmi_freq_meter(hdmi, 2);//tmds clock
+	return 0;
+}
+
+static unsigned int set_colordeep(struct mtk_hdmi *hdmi,
+	char *str_p)
+{
+	unsigned int colorspace;
+	unsigned int deepcolor;
+	int ret;
+
+	ret = sscanf(str_p, "0x%x/0x%x", &colorspace,
+		&deepcolor);
+	if (ret < 1) {
+		HDMI_ATTR_SPRINTF("parameter error\n");
+		return -EINVAL;
+	}
+
+	if (colorspace == HDMI_COLORSPACE_RGB) {
+		hdmi->csp = HDMI_COLORSPACE_RGB;
+		HDMI_ATTR_SPRINTF("HDMI_COLORSPACE_RGB\n");
+	} else if (colorspace == HDMI_COLORSPACE_YUV422) {
+		hdmi->csp = HDMI_COLORSPACE_YUV422;
+		HDMI_ATTR_SPRINTF("HDMI_COLORSPACE_YUV422\n");
+	} else if (colorspace == HDMI_COLORSPACE_YUV444) {
+		hdmi->csp = HDMI_COLORSPACE_YUV444;
+		HDMI_ATTR_SPRINTF("HDMI_COLORSPACE_YUV444\n");
+	} else if (colorspace == HDMI_COLORSPACE_YUV420) {
+		hdmi->csp = HDMI_COLORSPACE_YUV420;
+		HDMI_ATTR_SPRINTF("HDMI_COLORSPACE_YUV420\n");
+	} else {
+		HDMI_ATTR_SPRINTF("Wrong Parameters\n");
+		return -EINVAL;
+	}
+
+	if (deepcolor == HDMI_8_BIT) {
+		hdmi->color_depth = HDMI_8_BIT;
+		HDMI_ATTR_SPRINTF("HDMI_8_BIT\n");
+	} else if (deepcolor == HDMI_10_BIT) {
+		hdmi->color_depth = HDMI_10_BIT;
+		HDMI_ATTR_SPRINTF("HDMI_10_BIT\n");
+	} else if (deepcolor == HDMI_12_BIT) {
+		hdmi->color_depth = HDMI_12_BIT;
+		HDMI_ATTR_SPRINTF("HDMI_12_BIT\n");
+	} else if (deepcolor == HDMI_16_BIT) {
+		hdmi->color_depth = HDMI_16_BIT;
+		HDMI_ATTR_SPRINTF("HDMI_16_BIT\n");
+	} else {
+		HDMI_ATTR_SPRINTF("Wrong Parameters\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static unsigned int hdmi_read_reg(struct mtk_hdmi *hdmi, char *str_p)
+{
+	unsigned int u4Data;
+	unsigned int u4Addr;
+	int ret;
+
+	if (strncmp(str_p, "help", 4) == 0) {
+		HDMI_ATTR_SPRINTF("rg:0xPPPPPPPP\n");
+		return 0;
+	}
+
+	ret = kstrtouint(str_p, 0, &u4Addr);
+
+	if (u4Addr >= 0x1c300000)
+		u4Data = mtk_hdmi_read(hdmi, u4Addr - 0x1c300000);
+	else if (u4Addr >= 0x11d5f000)
+		u4Data = mtk_hdmi_phy_read(hdmi->hdmi_phy_base,
+			u4Addr - 0x11d5f000);
+	else
+		HDMI_ATTR_SPRINTF(
+	"%s the address is over of the range: 0x%08x\n",
+	__func__, u4Addr);
+
+	HDMI_ATTR_SPRINTF("0x%08x = 0x%08x\n", u4Addr, u4Data);
+
+	return 0;
+}
+
+static unsigned int hdmi_read_reg_range(struct mtk_hdmi *hdmi, char *str_p)
+{
+	unsigned int u4Data;
+	unsigned int u4Addr;
+	unsigned int u4Count;
+	int ret;
+
+	if (strncmp(str_p, "help", 4) == 0) {
+		HDMI_ATTR_SPRINTF("rg:0xPPPPPPPP/0xPPP\n");
+		return 0;
+	}
+
+	ret = sscanf(str_p, "0x%x/0x%x", &u4Addr, &u4Count);
+
+	while (u4Count >= 4) {
+		if (u4Addr >= 0x1c300000)
+			u4Data = mtk_hdmi_read(hdmi, u4Addr - 0x1c300000);
+		else if (u4Addr >= 0x11d5f000)
+			u4Data = mtk_hdmi_phy_read(hdmi->hdmi_phy_base,
+				u4Addr - 0x11d5f000);
+		else
+			HDMI_ATTR_SPRINTF(
+	"%s the address is over of the range: 0x%08x\n",
+	__func__, u4Addr);
+
+		HDMI_ATTR_SPRINTF("0x%08x = 0x%08x\n", u4Addr, u4Data);
+		udelay(2);
+		u4Addr = u4Addr + 4;
+		u4Count = u4Count - 4;
+	}
+
+	return 0;
+}
+
+static unsigned int hdmi_write_reg(struct mtk_hdmi *hdmi, char *str_p)
+{
+	unsigned int u4Data;
+	unsigned int u4Addr;
+	int ret;
+
+	if (strncmp(str_p, "help", 4) == 0) {
+		HDMI_ATTR_SPRINTF("wg:0xPPPPPPPP=0xPPPPPPPP\n");
+		return 0;
+	}
+
+	ret = sscanf(str_p, "0x%x=0x%x", &u4Addr, &u4Data);
+
+	if (u4Addr >= 0x1c300000)
+		mtk_hdmi_write(hdmi, u4Addr - 0x1c300000, u4Data);
+	else if (u4Addr >= 0x11d5f000)
+		mtk_hdmi_phy_write(hdmi->hdmi_phy_base,
+			u4Addr - 0x11d5f000, u4Data);
+	else
+		HDMI_ATTR_SPRINTF(
+	"%s the address is over of the range: 0x%08x\n",
+	__func__, u4Addr);
+
+	HDMI_ATTR_SPRINTF("0x%08x = 0x%08x\n", u4Addr, u4Data);
+
+	return 0;
+}
+
+static unsigned int set_abist_pattern(
+	struct mtk_hdmi *hdmi, char *str_p)
+{
+	unsigned int ret;
+	unsigned int mode_num, OnOff;
+	unsigned char abist_format;
+	struct drm_display_mode *mode;
+	const struct drm_bridge_funcs *bridge_funs = hdmi->bridge.funcs;
+
+	ret = sscanf(str_p, "0x%x/0x%x", &OnOff, &mode_num);
+
+	switch (mode_num) {
+	case 0x2:
+		HDMI_ATTR_SPRINTF("0x2: 720*480P@60\n");
+		mode = &mode_720x480_60hz_4v3;
+		abist_format = 0x2;
+		break;
+	case 0x3:
+		HDMI_ATTR_SPRINTF("0x3: 1280*720P@60\n");
+		mode = &mode_1280x720_60hz_16v9;
+		abist_format = 0x3;
+		break;
+	case 0x4:
+		HDMI_ATTR_SPRINTF("0x4: 1280*720P@50\n");
+		mode = &mode_1280x720_50hz_16v9;
+		abist_format = 0xc;
+		break;
+	case 0x5:
+		HDMI_ATTR_SPRINTF("0x5: 1920*1080P@60\n");
+		mode = &mode_1920x1080_60hz_16v9;
+		abist_format = 0xa;
+		break;
+	case 0x6:
+		HDMI_ATTR_SPRINTF("0x6: 1920*1080P@50\n");
+		mode = &mode_1920x1080_50hz_16v9;
+		abist_format = 0x13;
+		break;
+	case 0x7:
+		HDMI_ATTR_SPRINTF("0x7: 3840*2160P@30\n");
+		mode = &mode_3840x2160_30hz_16v9;
+		abist_format = 0x19;
+		break;
+	case 0x8:
+		HDMI_ATTR_SPRINTF("0x8: 3840*2160P@50\n");
+		mode = &mode_3840x2160_50hz_16v9;
+		abist_format = 0x18;
+		break;
+	case 0x9:
+		HDMI_ATTR_SPRINTF("0x9: 3840*2160P@60\n");
+		mode = &mode_3840x2160_60hz_16v9;
+		abist_format = 0x19;
+		break;
+	case 0xa:
+		HDMI_ATTR_SPRINTF("0xa: 4096*2160P@30\n");
+		mode = &mode_4096x2160_30hz;
+		abist_format = 0x1a;
+		break;
+	default:
+		HDMI_ATTR_SPRINTF("Wrong Mode!!\n");
+		mode = &mode_720x480_60hz_4v3;
+		abist_format = 0x2;
+	}
+
+	if (hdmi->enabled == true)
+		bridge_funs->disable(&hdmi->bridge);
+	if (hdmi->powered == true)
+		bridge_funs->post_disable(&hdmi->bridge);
+
+	msleep(50);
+
+	bridge_funs->mode_set(&hdmi->bridge, NULL, mode);
+	bridge_funs->pre_enable(&hdmi->bridge);
+	bridge_funs->enable(&hdmi->bridge);
+
+	mtk_hdmi_mask(hdmi, TOP_CFG00, (abist_format << 16),
+		ABIST_VIDEO_FORMAT_MASKBIT);
+	mtk_hdmi_mask(hdmi, TOP_CFG00, (OnOff << 31), ABIST_ENABLE);
+
+	return 0;
+}
+
+void set_dpi_pattern(struct mtk_hdmi *hdmi, char *str_p)
+{
+	struct drm_display_mode *mode;
+	unsigned int OnOff, mode_num;
+	int ret;
+	struct device_node *dpi_node;
+	struct drm_bridge *hdmi_bridge = &hdmi->bridge;
+	struct drm_bridge *dpi_bridge;
+
+	dpi_node = of_find_compatible_node(NULL, NULL, "mediatek,mt8195-dpi");
+	if (dpi_node == NULL) {
+		HDMI_DEBUG_LOG("cannot find dpi node\n");
+		return;
+	}
+	HDMI_DEBUG_LOG("dpi_node.name=%s, dpi_node.full_name=%s\n",
+		dpi_node->name, dpi_node->full_name);
+	dpi_bridge = of_drm_find_bridge(dpi_node);
+	if (dpi_bridge == NULL) {
+		HDMI_DEBUG_LOG("cannot find dpi bridge\n");
+		return;
+	}
+
+	ret = sscanf(str_p, "0x%x/0x%x", &OnOff, &mode_num);
+
+	switch (mode_num) {
+	case 0x2:
+		HDMI_ATTR_SPRINTF("0x2: 720*480P@60\n");
+		mode = &mode_720x480_60hz_4v3;
+		break;
+	case 0x3:
+		HDMI_ATTR_SPRINTF("0x3: 1280*720P@60\n");
+		mode = &mode_1280x720_60hz_16v9;
+		break;
+	case 0x4:
+		HDMI_ATTR_SPRINTF("0x4: 1280*720P@50\n");
+		mode = &mode_1280x720_50hz_16v9;
+		break;
+	case 0x5:
+		HDMI_ATTR_SPRINTF("0x5: 1920*1080P@60\n");
+		mode = &mode_1920x1080_60hz_16v9;
+		break;
+	case 0x6:
+		HDMI_ATTR_SPRINTF("0x6: 1920*1080P@50\n");
+		mode = &mode_1920x1080_50hz_16v9;
+		break;
+	case 0x7:
+		HDMI_ATTR_SPRINTF("0x7: 3840*2160P@30\n");
+		mode = &mode_3840x2160_30hz_16v9;
+		break;
+	case 0x8:
+		HDMI_ATTR_SPRINTF("0x8: 3840*2160P@50\n");
+		mode = &mode_3840x2160_50hz_16v9;
+		break;
+	case 0x9:
+		HDMI_ATTR_SPRINTF("0x9: 3840*2160P@60\n");
+		mode = &mode_3840x2160_60hz_16v9;
+		break;
+	case 0xa:
+		HDMI_ATTR_SPRINTF("0xa: 4096*2160P@30\n");
+		mode = &mode_4096x2160_30hz;
+		break;
+	default:
+		HDMI_ATTR_SPRINTF("Wrong Mode!!\n");
+		mode = &mode_720x480_60hz_4v3;
+	}
+
+	if (hdmi->enabled == true)
+		hdmi_bridge->funcs->disable(&hdmi->bridge);
+	if (hdmi->powered == true)
+		hdmi_bridge->funcs->post_disable(&hdmi->bridge);
+
+	msleep(50);
+
+	dpi_bridge->funcs->mode_set(dpi_bridge, NULL, mode);
+	hdmi_bridge->funcs->mode_set(hdmi_bridge, NULL, mode);
+
+	hdmi_bridge->funcs->pre_enable(hdmi_bridge);
+	dpi_bridge->funcs->enable(dpi_bridge);
+
+	if (OnOff != 0)
+		mtk_dpi_pattern_en(true);
+	else
+		mtk_dpi_pattern_en(false);
+
+	hdmi_bridge->funcs->enable(hdmi_bridge);
+
+	mtk_hdmi_mask(hdmi, TOP_CFG00, (0x0 << 31), ABIST_ENABLE);
+}
+
+
+static void _HdrEnable(char *str_p)
+{
+	unsigned int ret;
+	unsigned int fgHdrEnable, fgBT2020Enable, fgDolbyHdrEnable;
+	unsigned int use_dolby_vsif;
+	struct mtk_hdmi *hdmi = global_mtk_hdmi;
+
+	ret = sscanf(str_p, "0x%x/0x%x/0x%x/0x%x", &fgHdrEnable,
+		&fgBT2020Enable, &fgDolbyHdrEnable, &use_dolby_vsif);
+
+	if (fgHdrEnable == 3) {
+		_bStaticHdrStatus = HDR_PACKET_DISABLE;
+		mtk_hdmi_hw_static_hdr_infoframe(hdmi, _bStaticHdrStatus,
+		_bHdrMetadataBuff);
+	} else if (fgHdrEnable == 4) {
+		_bStaticHdrStatus = HDR_PACKET_ACTIVE;
+		mtk_hdmi_hw_static_hdr_infoframe(hdmi, _bStaticHdrStatus,
+		_bHdrMetadataBuff);
+	} else if (fgHdrEnable == 5) {
+		_bStaticHdrStatus = HDR_PACKET_ZERO;
+		mtk_hdmi_hw_static_hdr_infoframe(hdmi, _bStaticHdrStatus,
+		_bHdrMetadataBuff);
+	} else {
+		vHdr10Enable(fgHdrEnable);
+		vBT2020Enable(fgBT2020Enable);
+		if (use_dolby_vsif != 0)
+			vDolbyHdrEnable(fgDolbyHdrEnable, true);
+		else
+			vDolbyHdrEnable(fgDolbyHdrEnable, false);
+	}
+}
+
+void mtk_hdmi_power_clock_enable(struct mtk_hdmi *hdmi, bool enable)
+{
+	HDMI_DEBUG_LOG("enable: %d\n", enable);
+
+	if (enable == true) {
+		if (hdmi->power_clk_enabled == false) {
+			pm_runtime_get_sync(hdmi->dev);
+			mtk_hdmi_clk_enable(hdmi);
+			hdmi->power_clk_enabled = true;
+		}
+	} else {
+		if (hdmi->power_clk_enabled == true) {
+			mtk_hdmi_clk_disable(hdmi);
+			pm_runtime_put_sync(hdmi->dev);
+			hdmi->power_clk_enabled = false;
+		}
+	}
+}
+
+static void process_dbg_cmd(char *opt)
+{
+	unsigned int ret, i, size, en;
+	char testbuf[500] = {0};
+	unsigned int use_dolby_vsif;
+	struct VID_PLA_HDR_METADATA_INFO_T hdr_metadata;
+	struct mtk_hdmi *hdmi;
+
+	if (global_mtk_hdmi != NULL)
+		hdmi = global_mtk_hdmi;
+	else {
+		HDMI_ATTR_SPRINTF("mtk_hdmi structure is NULL\n");
+		HDMI_DEBUG_LOG("mtk_hdmi structure is NULL\n");
+		return;
+	}
+
+	if (strncmp(opt, "settxpll:", 9) == 0)
+		mtk_hdmi_set_txpll(hdmi, opt + 9);
+	else if (strncmp(opt, "codeep:", 7) == 0)
+		set_colordeep(hdmi, opt + 7);
+	else if (strncmp(opt, "abist:", 6) == 0)
+		set_abist_pattern(hdmi, opt + 6);
+	else if (strncmp(opt, "dpi_pattern:", 12) == 0)
+		set_dpi_pattern(hdmi, opt + 12);
+	else if (strncmp(opt, "hdmi_enable", 11) == 0) {
+		pm_runtime_enable(hdmi->dev);
+		mtk_hdmi_enable_disable(hdmi, true);
+	} else if (strncmp(opt, "color_bar_on", 12) == 0)
+		mtk_dpi_pattern_en(true);
+	else if (strncmp(opt, "color_bar_off", 13) == 0)
+		mtk_dpi_pattern_en(false);
+	else if (strncmp(opt, "power_clock_on", 14) == 0)
+		mtk_hdmi_power_clock_enable(hdmi, true);
+	else if (strncmp(opt, "power_clock_off", 15) == 0)
+		mtk_hdmi_power_clock_enable(hdmi, false);
+	else if (strncmp(opt, "audreset", 8) == 0) {
+		mtk_hdmi_audio_reset(hdmi, true);
+	} else if (strncmp(opt, "audpacket:", 10) == 0) {
+		ret = sscanf(opt+10, "%x", &en);
+		if (ret < 1)
+			return;
+		mtk_hdmi_hw_send_aud_packet(hdmi, !!en);
+
+	} else if (strncmp(opt, "vidmute:", 8) == 0) {
+		ret = sscanf(opt+8, "%x", &en);
+		if (ret < 1)
+			return;
+		mtk_hdmi_hw_vid_black(hdmi, !!en);
+
+	} else if (strncmp(opt, "audmute:", 8) == 0) {
+		ret = sscanf(opt+8, "%x", &en);
+		if (ret < 1)
+			return;
+		if (en)
+			mtk_hdmi_hw_aud_mute(hdmi);
+		else
+			mtk_hdmi_hw_aud_unmute(hdmi);
+	} else if (strncmp(opt, "getfreqmeter:", 13) == 0) {
+		unsigned int mode;
+
+		ret = sscanf(opt+13, "%x", &mode);
+		if (ret < 1)
+			return;
+		mtk_hdmi_freq_meter(hdmi, mode);
+	} else if (strncmp(opt, "rrg:", 4) == 0)
+		hdmi_read_reg_range(hdmi, opt + 4);
+	else if (strncmp(opt, "rg:", 3) == 0)
+		hdmi_read_reg(hdmi, opt + 3);
+	else if (strncmp(opt, "wg:", 3) == 0)
+		hdmi_write_reg(hdmi, opt + 3);
+	else if (strncmp(opt, "hdren:", 6) == 0)
+		_HdrEnable(opt + 6);
+	else if (strncmp(opt, "sdr", 3) == 0)
+		vHdr10PlusEnable(false);
+	else if (strncmp(opt, "dovistd:", 8) == 0) {
+		ret = sscanf(opt+8, "%x/%x", &en, &use_dolby_vsif);
+		if (ret < 1)
+			return;
+		vHdr10PlusEnable(false);
+		if (use_dolby_vsif != 0)
+			vDolbyHdrEnable(en, true);
+		else
+			vDolbyHdrEnable(en, false);
+	} else if (strncmp(opt, "dovill:", 7) == 0) {
+		ret = sscanf(opt+7, "%x", &en);
+		if (ret < 1)
+			return;
+		if (en) {
+			vHdr10PlusEnable(false);
+			vLowLatencyDolbyVisionEnable(false);
+			hdr_metadata.e_DynamicRangeType =
+			 VID_PLA_DR_TYPE_DOVI_LOWLATENCY;
+			hdr_metadata.metadata_info
+			 .dovi_lowlatency_metadata
+			 .fgBackltCtrlMdPresent = 0;
+			hdr_metadata.metadata_info
+			 .dovi_lowlatency_metadata.ui4_EffTmaxPQ = 0;
+			vVdpSetHdrMetadata(true, hdr_metadata);
+			vLowLatencyDolbyVisionEnable(true);
+		} else
+			vLowLatencyDolbyVisionEnable(false);
+	} else if (strncmp(opt, "hlg:", 4) == 0) {
+		ret = sscanf(opt+4, "%x", &en);
+		if (ret < 1)
+			return;
+		if (en) {
+			vHdr10PlusEnable(false);
+			vHdr10Enable(false);
+			hdr_metadata.e_DynamicRangeType = VID_PLA_DR_TYPE_HDR10;
+			hdr_metadata.metadata_info.hdr10_metadata
+			 .ui2_DisplayPrimariesX[0] = 0x8a48;
+			hdr_metadata.metadata_info.hdr10_metadata
+			 .ui2_DisplayPrimariesY[0] = 0x3908;
+			hdr_metadata.metadata_info.hdr10_metadata
+			 .ui2_DisplayPrimariesX[1] = 0x2134;
+			hdr_metadata.metadata_info.hdr10_metadata
+			 .ui2_DisplayPrimariesY[1] = 0x9baa;
+			hdr_metadata.metadata_info.hdr10_metadata
+			 .ui2_DisplayPrimariesX[2] = 0x1996;
+			hdr_metadata.metadata_info.hdr10_metadata
+			 .ui2_DisplayPrimariesY[2] = 0x1996;
+			hdr_metadata.metadata_info.hdr10_metadata
+			 .ui2_WhitePointX = 0x3d13;
+			hdr_metadata.metadata_info.hdr10_metadata
+			 .ui2_WhitePointY = 0x4042;
+			hdr_metadata.metadata_info.hdr10_metadata
+			 .ui2_MaxDisplayMasteringLuminance = 0xfa0;
+			hdr_metadata.metadata_info.hdr10_metadata
+			 .ui2_MinDisplayMasteringLuminance = 0x32;
+			hdr_metadata.metadata_info.hdr10_metadata
+			 .ui2_MaxCLL = 0x2222;
+			hdr_metadata.metadata_info.hdr10_metadata
+			 .ui2_MaxFALL = 0x79;
+			vSetStaticHdrType(GAMMA_HLG);
+			vVdpSetHdrMetadata(true, hdr_metadata);
+			vHdr10Enable(true);
+		} else
+			vHdr10Enable(false);
+	} else if (strncmp(opt, "hdr10gst:", 9) == 0) {
+		ret = sscanf(opt+9, "%x", &en);
+		if (ret < 1)
+			return;
+		HDMI_ATTR_SPRINTF("en=%x\n", en);
+		if (en) {
+			vHdr10PlusEnable(false);
+			vHdr10Enable(false);
+			hdr_metadata.e_DynamicRangeType = VID_PLA_DR_TYPE_HDR10;
+			hdr_metadata.metadata_info
+			 .hdr10_metadata
+			 .ui2_DisplayPrimariesX[0] = 0x8a48;
+			hdr_metadata.metadata_info
+			 .hdr10_metadata
+			 .ui2_DisplayPrimariesY[0] = 0x3908;
+			hdr_metadata.metadata_info
+			 .hdr10_metadata
+			 .ui2_DisplayPrimariesX[1] = 0x2134;
+			hdr_metadata.metadata_info
+			 .hdr10_metadata
+			 .ui2_DisplayPrimariesY[1] = 0x9baa;
+			hdr_metadata.metadata_info
+			 .hdr10_metadata
+			 .ui2_DisplayPrimariesX[2] = 0x1996;
+			hdr_metadata.metadata_info
+			 .hdr10_metadata
+			 .ui2_DisplayPrimariesY[2] = 0x1996;
+			hdr_metadata.metadata_info
+			 .hdr10_metadata.ui2_WhitePointX = 0x3d13;
+			hdr_metadata.metadata_info
+			 .hdr10_metadata.ui2_WhitePointY = 0x4042;
+			hdr_metadata.metadata_info
+			 .hdr10_metadata
+			 .ui2_MaxDisplayMasteringLuminance = 0xfa0;
+			hdr_metadata.metadata_info
+			 .hdr10_metadata
+			 .ui2_MinDisplayMasteringLuminance = 0x32;
+			hdr_metadata.metadata_info
+			 .hdr10_metadata.ui2_MaxCLL = 0x2222;
+			hdr_metadata.metadata_info
+			 .hdr10_metadata.ui2_MaxFALL = 0x79;
+
+			vSetStaticHdrType(GAMMA_ST2084);
+			vVdpSetHdrMetadata(true, hdr_metadata);
+			vHdr10Enable(true);
+		} else
+			vHdr10Enable(false);
+	} else if (strncmp(opt, "hdr10emp:", 9) == 0) {
+		ret = sscanf(opt+9, "%x", &en);
+		if (ret < 1)
+			return;
+		HDMI_ATTR_SPRINTF("en=%x\n", en);
+		if (en) {
+			vHdr10PlusEnable(false);
+			hdr_metadata.e_DynamicRangeType =
+				VID_PLA_DR_TYPE_HDR10_PLUS;
+			size = 300;
+			hdr_metadata.metadata_info
+				.hdr10_plus_metadata.hdr10p_metadata_info
+				.ui4_Hdr10PlusSize =
+					size;
+			hdr_metadata.metadata_info
+				.hdr10_plus_metadata.hdr10p_metadata_info
+				.ui4_Hdr10PlusAddr =
+				(unsigned long)(&testbuf);
+			for (i = 0; i < size; i++)
+				testbuf[i] = (i % 255);
+			vVdpSetHdrMetadata(true, hdr_metadata);
+			vHdr10PlusEnable(true);
+		} else
+			vHdr10PlusEnable(false);
+	} else if (strncmp(opt, "hdr10pvsif:", 11) == 0) {
+		ret = sscanf(opt+11, "%x", &en);
+		if (ret < 1)
+			return;
+		if (en) {
+			vHdr10PlusEnable(false);
+			vHdr10PlusVSIFEnable(false);
+			hdr_metadata.e_DynamicRangeType =
+				VID_PLA_DR_TYPE_HDR10_PLUS_VSIF;
+			size = 27;
+			hdr_metadata.metadata_info
+				.hdr10_plus_metadata
+				.hdr10p_metadata_info.ui4_Hdr10PlusSize =
+				size;
+			hdr_metadata.metadata_info
+				.hdr10_plus_metadata
+				.hdr10p_metadata_info.ui4_Hdr10PlusAddr =
+				(unsigned long)(&testbuf);
+			for (i = 0; i < size; i++)
+				testbuf[i] = (i % 255);
+			vVdpSetHdrMetadata(true, hdr_metadata);
+			vHdr10PlusVSIFEnable(true);
+		} else
+			vHdr10PlusVSIFEnable(false);
+		}
+
+}
+
+struct dentry *hdmitx_debugfs;
+
+static int debug_open(struct inode *inode, struct file *file)
+{
+	file->private_data = inode->i_private;
+	return 0;
+}
+
+static ssize_t debug_read(struct file *file,
+	char __user *ubuf, size_t count, loff_t *ppos)
+{
+	int n = 0;
+
+	n = strlen(debug_buffer);
+	debug_buffer[n++] = 0;
+
+	return simple_read_from_buffer(ubuf, count, ppos, debug_buffer, n);
+}
+
+static ssize_t debug_write(struct file *file,
+	const char __user *ubuf, size_t count, loff_t *ppos)
+{
+	const int debug_bufmax = sizeof(debug_buffer) - 1;
+	ssize_t ret;
+
+	ret = count;
+
+	if (count > debug_bufmax)
+		count = debug_bufmax;
+
+	if (copy_from_user(&debug_buffer, ubuf, count))
+		return -EFAULT;
+
+	debug_buffer[count] = 0;
+	buf_offset = 0;
+
+	process_dbg_cmd(debug_buffer);
+
+	return ret;
+}
+
+static const struct file_operations debug_fops = {
+	.read = debug_read,
+	.write = debug_write,
+	.open = debug_open,
+};
+
+int hdmitx_debug_init(void)
+{
+	HDMI_DEBUG_FUNC();
+	hdmitx_debugfs = debugfs_create_file("hdmitx",
+		S_IFREG | 0444, NULL, (void *)0, &debug_fops);
+
+	if (IS_ERR(hdmitx_debugfs))
+		return PTR_ERR(hdmitx_debugfs);
+
+
+	HDMI_DEBUG_LOG("register hdmitx debugfs success\n");
+
+	return 0;
+}
+
+void hdmitx_debug_uninit(void)
+{
+	debugfs_remove(hdmitx_debugfs);
+}
+
diff --git a/drivers/gpu/drm/mediatek/mediatek_v2/mtk_hdmi_debug.h b/drivers/gpu/drm/mediatek/mediatek_v2/mtk_hdmi_debug.h
new file mode 100644
index 0000000000000000000000000000000000000000..d30b53430f2960933f8099f8e375003a1886dffc
--- /dev/null
+++ b/drivers/gpu/drm/mediatek/mediatek_v2/mtk_hdmi_debug.h
@@ -0,0 +1,12 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2019 MediaTek Inc.
+ */
+
+#ifndef _MTK_HDMI_DEBUG_H
+#define _MTK_HDMI_DEBUG_H
+
+int hdmitx_debug_init(void);
+void hdmitx_debug_uninit(void);
+
+#endif /* _MTK_HDMI_DEBUG_H */
diff --git a/drivers/gpu/drm/mediatek/mediatek_v2/mtk_hdmi_edid.c b/drivers/gpu/drm/mediatek/mediatek_v2/mtk_hdmi_edid.c
new file mode 100644
index 0000000000000000000000000000000000000000..b4b1ee1115a6189c81ccb8e9cef1a4444044a4c8
--- /dev/null
+++ b/drivers/gpu/drm/mediatek/mediatek_v2/mtk_hdmi_edid.c
@@ -0,0 +1,3434 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2019 MediaTek Inc.
+ */
+
+#include "mtk_hdmi.h"
+#include "mtk_hdmi_regs.h"
+#include "mtk_hdmi_edid.h"
+#include "mtk_hdmi_hdcp.h"
+
+unsigned char mtk_edid_log = 1;
+
+#define HDMI_EDID_LOG(fmt, arg...) \
+	do {	if (mtk_edid_log) { \
+		pr_debug("[HDMI][EDID] %s,%d "fmt, __func__, __LINE__, ##arg); \
+		} \
+	} while (0)
+
+#define HDMI_EDID_FUNC()	\
+	do {	if (mtk_edid_log) \
+		pr_debug("[HDMI][EDID] %s\n", __func__); \
+	} while (0)
+
+
+#ifndef FALSE
+#define FALSE   0
+#endif
+
+#ifndef TRUE
+#define TRUE    1
+#endif
+
+static unsigned int i4HdmiShareInfo[MAX_HDMI_SHAREINFO];
+
+bool debug_hdr10p_force_enable_edid = FALSE;
+unsigned char debug_hdr10p_force_set_appversion = 0xff;
+
+struct HDMI_SINK_AV_CAP_T _HdmiSinkAvCap;
+static unsigned char _fgHdmiNoEdidCheck = FALSE;
+static unsigned int _u4i_3D_VIC;
+static unsigned int _ui4First_16_NTSC_VIC;
+static unsigned int _ui4First_16_PAL_VIC;
+static unsigned int _ui4First_16_VIC[16];
+static unsigned char _bEdidData[EDID_SIZE];	/* 4 block 512 Bytes */
+static unsigned char aEDIDHeader[EDID_HEADER_LEN] = {
+	0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00
+};
+static unsigned char aEDIDVSDBHeader[EDID_VSDB_LEN] = {
+	0x03, 0x0c, 0x00};
+static unsigned char aEDIDHFVSDBHeader[EDID_VSDB_LEN] = {
+	0xd8, 0x5d, 0xc4};
+
+static unsigned int aEDIDDoblyVSVDBHeader = 0x00d046;
+static unsigned int aEDIDPhilipsVSVDBHeader = 0xea9fb1;
+static unsigned int aEDIDHdr10PlusVSVDBHeader = 0x90848b;
+
+unsigned int _ui4svd_128_VIC[128];
+unsigned int _u4i_svd_420_CMDB;
+
+const unsigned char _cFsStr[][7] = { {"32khz  "},
+{"44khz  "},
+{"48khz  "},
+{"88khz  "},
+{"96khz  "},
+{"176khz "},
+{"192khz "}
+};
+
+const unsigned char _cBitdeepStr[][7] = { {"16bit  "},
+{"20bit  "},
+{"24bit  "}
+};
+
+unsigned char cDstStr[50];
+unsigned char cDstBitStr[21];
+
+bool fgIsHdmiNoEDIDCheck(void)
+{
+	HDMI_EDID_FUNC();
+
+	return _fgHdmiNoEdidCheck;
+}
+
+void vSetNoEdidChkInfo(void)
+{
+	unsigned char bInx;
+
+	HDMI_EDID_FUNC();
+
+	vSetSharedInfo(SI_EDID_PARSING_RESULT, TRUE);
+	vSetSharedInfo(SI_EDID_VSDB_EXIST, TRUE);
+	_HdmiSinkAvCap.b_sink_support_hdmi_mode = TRUE;
+	_HdmiSinkAvCap.ui4_sink_dtd_ntsc_resolution = 0xffffffff;
+	_HdmiSinkAvCap.ui4_sink_dtd_pal_resolution = 0xffffffff;
+	_HdmiSinkAvCap.ui4_sink_1st_dtd_ntsc_resolution = 0xffffffff;
+	_HdmiSinkAvCap.ui4_sink_1st_dtd_pal_resolution = 0xffffffff;
+	_HdmiSinkAvCap.ui2_sink_colorimetry = 0xffff;
+	_HdmiSinkAvCap.ui4_sink_cea_ntsc_resolution = 0xffffffff;
+	_HdmiSinkAvCap.ui4_sink_cea_pal_resolution = 0xffffffff;
+	_HdmiSinkAvCap.ui2_sink_aud_dec = 0xffff;
+	_HdmiSinkAvCap.ui1_sink_dsd_ch_num = 5;
+	for (bInx = 0; bInx < 7; bInx++) {
+		_HdmiSinkAvCap.ui1_sink_pcm_ch_sampling[bInx] = 0xff;
+		_HdmiSinkAvCap.ui1_sink_dsd_ch_sampling[bInx] = 0xff;
+		_HdmiSinkAvCap.ui1_sink_dst_ch_sampling[bInx] = 0xff;
+		_HdmiSinkAvCap.ui1_sink_ac3_ch_sampling[bInx] = 0xff;
+		_HdmiSinkAvCap.ui1_sink_ec3_ch_sampling[bInx] = 0xff;
+	}
+
+	for (bInx = 0; bInx < 7; bInx++)
+		_HdmiSinkAvCap.ui1_sink_pcm_bit_size[bInx] = 0xff;
+
+	_HdmiSinkAvCap.ui1_sink_spk_allocation = 0xff;
+
+
+	_HdmiSinkAvCap.e_sink_rgb_color_bit =
+	    (HDMI_SINK_DEEP_COLOR_10_BIT |
+	    HDMI_SINK_DEEP_COLOR_12_BIT |
+	     HDMI_SINK_DEEP_COLOR_16_BIT);
+	_HdmiSinkAvCap.e_sink_ycbcr_color_bit =
+	    (HDMI_SINK_DEEP_COLOR_10_BIT |
+	    HDMI_SINK_DEEP_COLOR_12_BIT |
+	     HDMI_SINK_DEEP_COLOR_16_BIT);
+	_HdmiSinkAvCap.ui1_sink_dc420_color_bit =
+	    (HDMI_SINK_DEEP_COLOR_10_BIT |
+	    HDMI_SINK_DEEP_COLOR_12_BIT |
+	     HDMI_SINK_DEEP_COLOR_16_BIT);
+	_HdmiSinkAvCap.ui2_edid_chksum_and_audio_sup = 0;
+	_HdmiSinkAvCap.ui1_sink_support_ai = 1;
+
+	_HdmiSinkAvCap.b_sink_edid_ready = TRUE;
+
+	_HdmiSinkAvCap.b_sink_3D_present = TRUE;
+	_HdmiSinkAvCap.ui4_sink_cea_3D_resolution = 0xFFFFFFFF;
+	_HdmiSinkAvCap.ui1_sink_max_tmds_clock = 0xFFFF;
+
+	_HdmiSinkAvCap.ui4_sink_hdmi_4k2kvic = 0x3f;
+	_HdmiSinkAvCap.b_sink_SCDC_present = 1;
+	_HdmiSinkAvCap.b_sink_LTE_340M_sramble = 1;
+	_HdmiSinkAvCap.ui1_sink_support_dolby_atoms = FALSE;
+}
+
+void vClearEdidInfo(void)
+{
+	unsigned char bInx;
+
+	HDMI_EDID_FUNC();
+
+	memset((void *)_bEdidData, 0, EDID_SIZE);
+
+	vSetSharedInfo(SI_EDID_PARSING_RESULT, FALSE);
+	vSetSharedInfo(SI_EDID_VSDB_EXIST, FALSE);
+	_HdmiSinkAvCap.b_sink_support_hdmi_mode = FALSE;
+	_HdmiSinkAvCap.ui4_sink_dtd_ntsc_resolution = 0;
+	_HdmiSinkAvCap.ui4_sink_dtd_pal_resolution = 0;
+	_HdmiSinkAvCap.ui4_sink_1st_dtd_ntsc_resolution = 0;
+	_HdmiSinkAvCap.ui4_sink_1st_dtd_pal_resolution = 0;
+	_HdmiSinkAvCap.ui2_sink_colorimetry = 0;
+	_HdmiSinkAvCap.ui4_sink_cea_ntsc_resolution = 0;
+	_HdmiSinkAvCap.ui4_sink_cea_pal_resolution = 0;
+	_HdmiSinkAvCap.ui4_sink_native_ntsc_resolution = 0;
+	_HdmiSinkAvCap.ui4_sink_native_pal_resolution = 0;
+	_HdmiSinkAvCap.ui2_sink_vcdb_data = 0;
+	_HdmiSinkAvCap.ui2_sink_aud_dec = 0;
+	_HdmiSinkAvCap.ui1_sink_dsd_ch_num = 0;
+	for (bInx = 0; bInx < 7; bInx++) {
+		if (bInx == 0)
+			_HdmiSinkAvCap.ui1_sink_pcm_ch_sampling[bInx] = 0x07;
+		else
+			_HdmiSinkAvCap.ui1_sink_pcm_ch_sampling[bInx] = 0;
+		_HdmiSinkAvCap.ui1_sink_dsd_ch_sampling[bInx] = 0;
+		_HdmiSinkAvCap.ui1_sink_dst_ch_sampling[bInx] = 0;
+		_HdmiSinkAvCap.ui1_sink_ac3_ch_sampling[bInx] = 0;
+		_HdmiSinkAvCap.ui1_sink_ec3_ch_sampling[bInx] = 0;
+	}
+
+	for (bInx = 0; bInx < 7; bInx++) {
+		if (bInx == 0)
+			_HdmiSinkAvCap.ui1_sink_pcm_bit_size[bInx] = 0x07;
+		else
+			_HdmiSinkAvCap.ui1_sink_pcm_bit_size[bInx] = 0;
+	}
+
+	_HdmiSinkAvCap.ui1_sink_spk_allocation = 0;
+	_HdmiSinkAvCap.ui1_sink_i_latency_present = 0;
+	_HdmiSinkAvCap.ui1_sink_p_latency_present = 0;
+	_HdmiSinkAvCap.ui1_sink_p_audio_latency = 0;
+	_HdmiSinkAvCap.ui1_sink_p_video_latency = 0;
+	_HdmiSinkAvCap.ui1_sink_i_audio_latency = 0;
+	_HdmiSinkAvCap.ui1_sink_i_video_latency = 0;
+
+	_HdmiSinkAvCap.e_sink_rgb_color_bit =
+		HDMI_SINK_NO_DEEP_COLOR;
+	_HdmiSinkAvCap.e_sink_ycbcr_color_bit =
+		HDMI_SINK_NO_DEEP_COLOR;
+	_HdmiSinkAvCap.ui1_sink_dc420_color_bit =
+		HDMI_SINK_NO_DEEP_COLOR;
+	_HdmiSinkAvCap.ui2_edid_chksum_and_audio_sup =
+	    (SINK_BASIC_AUDIO_NO_SUP |
+	    SINK_SAD_NO_EXIST | SINK_BASE_BLK_CHKSUM_ERR |
+	     SINK_EXT_BLK_CHKSUM_ERR);
+
+	_HdmiSinkAvCap.b_sink_edid_ready = FALSE;
+	_HdmiSinkAvCap.ui1_sink_support_ai = 0;
+	_HdmiSinkAvCap.ui1_Display_Horizontal_Size = 0;
+	_HdmiSinkAvCap.ui1_Display_Vertical_Size = 0;
+	_HdmiSinkAvCap.ui4_sink_hdmi_4k2kvic = 0;
+	_HdmiSinkAvCap.ui4_sink_hdmi_4k2kvic_420_vdb = 0;
+	_HdmiSinkAvCap.b_sink_SCDC_present = 0;
+	_HdmiSinkAvCap.b_sink_LTE_340M_sramble = 0;
+	_HdmiSinkAvCap.ui1_sink_max_tmds_clock = 0;
+	_HdmiSinkAvCap.ui2_sink_max_tmds_character_rate = 0;
+	_HdmiSinkAvCap.ui1_sink_support_static_hdr = 0;
+	_HdmiSinkAvCap.ui1_sink_support_dynamic_hdr = 0;
+	_HdmiSinkAvCap.ui1_sink_hdr_content_max_luminance = 0;
+	_HdmiSinkAvCap.ui1_sink_hdr_content_max_frame_average_luminance = 0;
+	_HdmiSinkAvCap.ui1_sink_hdr_content_min_luminance = 0;
+	_HdmiSinkAvCap.ui1_sink_hdr10plus_app_version = 0xff;
+	_HdmiSinkAvCap.ui4_sink_dolbyvision_vsvdb_length = 0;
+	_HdmiSinkAvCap.ui4_sink_dolbyvision_vsvdb_version = 0;
+	_HdmiSinkAvCap.ui4_sink_dolbyvision_vsvdb_v1_low_latency = 0;
+	_HdmiSinkAvCap.ui4_sink_dolbyvision_vsvdb_v2_interface = 0;
+	_HdmiSinkAvCap.ui4_sink_dolbyvision_vsvdb_low_latency_support = 0;
+	_HdmiSinkAvCap.ui4_sink_dolbyvision_vsvdb_v2_supports_10b_12b_444 = 0;
+	_HdmiSinkAvCap.ui4_sink_dolbyvision_vsvdb_support_backlight_control = 0;
+	_HdmiSinkAvCap.ui4_sink_dolbyvision_vsvdb_backlt_min_lumal = 0;
+	_HdmiSinkAvCap.ui4_sink_dolbyvision_vsvdb_tmin = 0;
+	_HdmiSinkAvCap.ui4_sink_dolbyvision_vsvdb_tmax = 0;
+	_HdmiSinkAvCap.ui4_sink_dolbyvision_vsvdb_tminPQ = 0;
+	_HdmiSinkAvCap.ui4_sink_dolbyvision_vsvdb_tmaxPQ = 0;
+	_HdmiSinkAvCap.ui4_sink_dolbyvision_vsvdb_Rx = 0;
+	_HdmiSinkAvCap.ui4_sink_dolbyvision_vsvdb_Ry = 0;
+	_HdmiSinkAvCap.ui4_sink_dolbyvision_vsvdb_Gx = 0;
+	_HdmiSinkAvCap.ui4_sink_dolbyvision_vsvdb_Gy = 0;
+	_HdmiSinkAvCap.ui4_sink_dolbyvision_vsvdb_Bx = 0;
+	_HdmiSinkAvCap.ui4_sink_dolbyvision_vsvdb_By = 0;
+	_HdmiSinkAvCap.ui4_sink_dolbyvision_vsvdb_Wx = 0;
+	_HdmiSinkAvCap.ui4_sink_dolbyvision_vsvdb_Wy = 0;
+	for (bInx = 0; bInx < 32; bInx++)
+		_HdmiSinkAvCap.ui1_sink_dolbyvision_block[bInx] = 0;
+	for (bInx = 0; bInx < 7; bInx++)
+		_HdmiSinkAvCap.ui1_sink_hdr_block[bInx] = 0;
+	for (bInx = 0; bInx < 8; bInx++)
+		_HdmiSinkAvCap.ui1_sink_hfvsdb_block[bInx] = 0;
+	_HdmiSinkAvCap.ui1_sink_hf_vsdb_info = 0;
+	_HdmiSinkAvCap.ui1_CNC = 0;
+	_HdmiSinkAvCap.ui1_sink_support_dolby_atoms = FALSE;
+
+	if (fgIsHdmiNoEDIDCheck())
+		vSetNoEdidChkInfo();
+
+}
+
+void vShowEdidRawData(void)
+{
+	unsigned short bTemp, i, j;
+	unsigned char *p;
+
+	HDMI_EDID_FUNC();
+
+	for (bTemp = 0; bTemp < 2; bTemp++) {
+		HDMI_EDID_LOG(
+"===================================================================\n");
+		HDMI_EDID_LOG("   EDID Block Number=#%d\n", bTemp);
+		HDMI_EDID_LOG(
+"   | 00  01  02  03  04  05  06  07  08  09  0a  0b  0c  0d  0e  0f\n");
+		HDMI_EDID_LOG(
+"===================================================================\n");
+		j = bTemp * EDID_BLOCK_LEN;
+		for (i = 0; i < 8; i++) {
+			p = &_bEdidData[j + i * 16];
+			HDMI_EDID_LOG(
+"%02x:  %02x  %02x  %02x  %02x  %02x  %02x  %02x  %02x  %02x  %02x  ",
+i * 16 + j, p[0], p[1], p[2], p[3], p[4], p[5], p[6], p[7], p[8], p[9]);
+			HDMI_EDID_LOG("%02x  %02x  %02x  %02x  %02x  %02x\n",
+				p[10], p[11], p[12], p[13], p[14], p[15]);
+		}
+	}
+	HDMI_EDID_LOG("===========================================\n");
+
+}
+
+void vAnalyzeDTD(unsigned short ui2Active,
+	unsigned short ui2HBlanking, unsigned char bVfiq,
+	unsigned char bFormat, unsigned char fgFirstDTD)
+{
+	unsigned int ui4NTSC = _HdmiSinkAvCap.ui4_sink_dtd_ntsc_resolution;
+	unsigned int ui4PAL = _HdmiSinkAvCap.ui4_sink_dtd_pal_resolution;
+	unsigned int ui41stNTSC = _HdmiSinkAvCap.ui4_sink_1st_dtd_ntsc_resolution;
+	unsigned int ui41stPAL = _HdmiSinkAvCap.ui4_sink_1st_dtd_pal_resolution;
+
+	HDMI_EDID_FUNC();
+
+	switch (ui2Active) {
+	case 0x5a0:		/* 480i */
+		if (ui2HBlanking == 0x114) {	/* NTSC */
+			if (bFormat == 0) {	/* p-scan */
+				ui4NTSC |= SINK_480P_1440;
+				if (fgFirstDTD)
+					ui41stNTSC |= SINK_480P_1440;
+			} else {
+				ui4NTSC |= SINK_480I;
+				if (fgFirstDTD)
+					ui41stNTSC |= SINK_480I;
+			}
+		} else if (ui2HBlanking == 0x120) {	/* PAL */
+			if (bFormat == 0) {	/* p-scan */
+				ui4PAL |= SINK_576P_1440;
+				if (fgFirstDTD)
+					ui41stPAL |= SINK_576P_1440;
+			} else {
+				ui4PAL |= SINK_576I;
+				if (fgFirstDTD)
+					ui41stPAL |= SINK_576I;
+			}
+		}
+		break;
+	case 0x2d0:		/* 480p */
+		if ((ui2HBlanking == 0x8a)
+			&& (bFormat == 0)) {	/* NTSC, p-scan */
+			ui4NTSC |= SINK_480P;
+			if (fgFirstDTD)
+				ui41stNTSC |= SINK_480P;
+		} else if ((ui2HBlanking == 0x90)
+		&& (bFormat == 0)) {	/* PAL, p-scan */
+			ui4PAL |= SINK_576P;
+			if (fgFirstDTD)
+				ui41stPAL |= SINK_576P;
+		}
+		break;
+	case 0x500:		/* 720p */
+		if ((ui2HBlanking == 0x172)
+			&& (bFormat == 0)) {	/* NTSC, p-scan */
+			ui4NTSC |= SINK_720P60;
+			if (fgFirstDTD)
+				ui41stNTSC |= SINK_720P60;
+		} else if ((ui2HBlanking == 0x2bc)
+		&& (bFormat == 0)) {	/* PAL, p-scan */
+			ui4PAL |= SINK_720P50;
+			if (fgFirstDTD)
+				ui41stPAL |= SINK_720P50;
+		}
+		break;
+	case 0x780:		/* 1080i, 1080P */
+		if ((ui2HBlanking == 0x118) && (bFormat == 1)) {
+			ui4NTSC |= SINK_1080I60;
+			if (fgFirstDTD)
+				ui41stNTSC |= SINK_1080I60;
+
+			HDMI_EDID_LOG("Support 1080i60\n");
+		} else if ((ui2HBlanking == 0x118) && (bFormat == 0)) {
+			if ((bVfiq >= 29) && (bVfiq <= 31)) {
+				ui4NTSC |= SINK_1080P30;
+				if (fgFirstDTD)
+					ui41stNTSC |= SINK_1080P30;
+
+				HDMI_EDID_LOG("Support 1080P30\n");
+			} else {
+				ui4NTSC |= SINK_1080P60;
+				if (fgFirstDTD)
+					ui41stNTSC |= SINK_1080P60;
+
+				HDMI_EDID_LOG("Support 1080P60\n");
+			}
+		} else if ((ui2HBlanking == 0x2d0) && (bFormat == 1)) {
+			ui4PAL |= SINK_1080I50;
+			if (fgFirstDTD)
+				ui41stPAL |= SINK_1080I50;
+
+			HDMI_EDID_LOG("Support 1080i50\n");
+		} else if ((ui2HBlanking == 0x2d0) && (bFormat == 0)) {
+			if ((bVfiq >= 24) && (bVfiq <= 26)) {
+				ui4PAL |= SINK_1080P25;
+				if (fgFirstDTD)
+					ui41stPAL |= SINK_1080P25;
+
+				HDMI_EDID_LOG("Support 1080P25\n");
+			} else {
+				ui4PAL |= SINK_1080P50;
+				if (fgFirstDTD)
+					ui41stPAL |= SINK_1080P50;
+
+				HDMI_EDID_LOG("Support 1080P50\n");
+			}
+		} else if ((ui2HBlanking == 0x33e) && (bFormat == 0)) {
+			if ((bVfiq >= 23) && (bVfiq <= 25)) {
+				ui4PAL |= SINK_1080P24;
+				if (fgFirstDTD)
+					ui41stPAL |= SINK_1080P24;
+
+				HDMI_EDID_LOG("Support 1080P24\n");
+			}
+		}
+		break;
+	}
+	_HdmiSinkAvCap.ui4_sink_dtd_ntsc_resolution =
+		ui4NTSC;
+	_HdmiSinkAvCap.ui4_sink_dtd_pal_resolution =
+		ui4PAL;
+	_HdmiSinkAvCap.ui4_sink_1st_dtd_ntsc_resolution =
+		ui41stNTSC;
+	_HdmiSinkAvCap.ui4_sink_1st_dtd_pal_resolution =
+		ui41stPAL;
+}
+
+unsigned char fgParserEDID(unsigned char *prbData)
+{
+	unsigned char bIdx;
+	unsigned char bTemp = 0;
+	unsigned short ui2HActive, ui2HBlanking;
+	unsigned char Vfiq = 1;
+	unsigned int dHtotal = 1, dVtotal = 1, ui2PixClk = 1;
+	unsigned short ui2VActive, ui2VBlanking;
+
+	HDMI_EDID_FUNC();
+
+	_HdmiSinkAvCap.ui1_Edid_Version =
+		*(prbData + EDID_ADDR_VERSION);
+	_HdmiSinkAvCap.ui1_Edid_Revision =
+		*(prbData + EDID_ADDR_REVISION);
+	_HdmiSinkAvCap.ui1_Display_Horizontal_Size =
+		*(prbData + EDID_IMAGE_HORIZONTAL_SIZE);
+	_HdmiSinkAvCap.ui1_Display_Vertical_Size =
+		*(prbData + EDID_IMAGE_VERTICAL_SIZE);
+
+	/* Step 1: check if EDID header pass */
+	/* ie. EDID[0] ~ EDID[7] = specify header pattern */
+	for (bIdx = EDID_ADDR_HEADER; bIdx <
+		(EDID_ADDR_HEADER + EDID_HEADER_LEN); bIdx++) {
+		if (*(prbData + bIdx) != aEDIDHeader[bIdx]) {
+			HDMI_EDID_LOG("FALSE Header = 0x%x\n", *(prbData + bIdx));
+			return FALSE;
+		}
+	}
+
+	/* Step 2: Check if EDID checksume pass */
+	/* ie. value of EDID[0] + ... + [0x7F] = 256*n */
+	for (bIdx = 0; bIdx < EDID_BLOCK_LEN; bIdx++) {
+		/* add the value into checksum */
+		bTemp += *(prbData + bIdx);
+	}
+
+	/* check if EDID checksume pass */
+	if (bTemp) {
+		HDMI_EDID_LOG("FALSE Checksum = 0x%x\n", bTemp);
+		return FALSE;
+	}
+		_HdmiSinkAvCap.ui2_edid_chksum_and_audio_sup &=
+			~SINK_BASE_BLK_CHKSUM_ERR;
+
+	/* [3.3] read-back H active line to define EDID resolution */
+	for (bIdx = 0; bIdx < 2; bIdx++) {
+		ui2HActive = (unsigned short)(*(prbData +
+			EDID_ADDR_TIMING_DSPR_1 + 18 * bIdx +
+			OFST_H_ACT_BLA_HI) & 0xf0) << 4;
+		ui2HActive |= *(prbData + EDID_ADDR_TIMING_DSPR_1 +
+			18 * bIdx + OFST_H_ACTIVE_LO);
+		ui2HBlanking = (unsigned short)(*(prbData +
+		    EDID_ADDR_TIMING_DSPR_1 + 18 * bIdx +
+			OFST_H_ACT_BLA_HI) & 0x0f) << 8;
+		ui2HBlanking |= *(prbData + EDID_ADDR_TIMING_DSPR_1 +
+		    18 * bIdx + OFST_H_BLANKING_LO);
+		bTemp = (*(prbData + EDID_ADDR_TIMING_DSPR_1 +
+			18 * bIdx + OFST_FLAGS) & 0x80) >> 7;
+
+		ui2VActive = (unsigned short)*(prbData +
+			EDID_ADDR_TIMING_DSPR_1 + 18 * bIdx + OFST_V_ACTIVE_LO);
+		ui2VActive |= (unsigned short)(*(prbData +
+			EDID_ADDR_TIMING_DSPR_1 +
+			18 * bIdx + OFST_V_ACTIVE_HI) & 0xf0) << 4;
+		ui2VBlanking = (unsigned short)(*(prbData +
+			EDID_ADDR_TIMING_DSPR_1 +
+			18 * bIdx + OFST_V_ACTIVE_HI) & 0x0f) << 8;
+		ui2VBlanking |= *(prbData + EDID_ADDR_TIMING_DSPR_1 +
+			18 * bIdx + OFST_V_BLANKING_LO);
+		ui2PixClk = (unsigned short)*(prbData +
+			EDID_ADDR_TIMING_DSPR_1 + 18 *
+			bIdx + OFST_PXL_CLK_LO);
+		ui2PixClk |= ((unsigned short)*(prbData +
+			EDID_ADDR_TIMING_DSPR_1 + 18 *
+			bIdx + OFST_PXL_CLK_HI)) << 8;
+
+		ui2PixClk = ui2PixClk * 10000;
+		dHtotal = (ui2HActive + ui2HBlanking);
+		dVtotal = (ui2VActive + ui2VBlanking);
+		Vfiq = 1;
+		if (((dHtotal * dVtotal) != 0) && (ui2PixClk != 0))
+			Vfiq = ui2PixClk / (dHtotal * dVtotal);
+		HDMI_EDID_LOG("base,clk=%d,h=%d,v=%d,vfiq=%d\n",
+			ui2PixClk, dHtotal, dVtotal, Vfiq);
+		if (bIdx == 0)
+			vAnalyzeDTD(ui2HActive,
+			ui2HBlanking, Vfiq, bTemp, TRUE);
+		else
+			vAnalyzeDTD(ui2HActive,
+			ui2HBlanking, Vfiq, bTemp, FALSE);
+	}
+
+	/* if go here, ie. parsing EDID data ok !! */
+	return TRUE;
+}
+
+static void vParser_Video_Data_Block(
+	unsigned char *prData, unsigned char Len)
+{
+	/* Video data block */
+	unsigned int ui4CEA_NTSC = 0,
+	ui4CEA_PAL = 0,
+	ui4OrgCEA_NTSC = 0,
+	ui4OrgCEA_PAL = 0,
+	ui4NativeCEA_NTSC = 0,
+	ui4NativeCEA_PAL = 0;
+	unsigned int ui4Temp = 0;
+	unsigned int bIdx;
+	unsigned char bNo = Len, b_Native_bit;
+
+	for (bIdx = 0; bIdx < bNo; bIdx++) {
+		if (*(prData + 1 + bIdx) & 0x80) {	/* Native bit */
+			ui4OrgCEA_NTSC = ui4CEA_NTSC;
+			ui4OrgCEA_PAL = ui4CEA_PAL;
+		}
+
+		_ui4svd_128_VIC[bIdx] = (*(prData + 1 + bIdx) & 0x7f);
+		b_Native_bit = (*(prData + 1 + bIdx) & 0x80);
+
+		switch (*(prData + 1 + bIdx) & 0x7f) {
+		case 1:
+			ui4CEA_NTSC |= SINK_VGA;
+			ui4OrgCEA_NTSC |= SINK_VGA;
+			if (b_Native_bit)	/* Native bit */
+				ui4NativeCEA_NTSC |= SINK_VGA;
+			break;
+
+		case 6:
+			ui4CEA_NTSC |= SINK_480I;
+			ui4OrgCEA_NTSC |= SINK_480I;
+			if (*(prData + 1 + bIdx) & 0x80)	/* Native bit */
+				ui4NativeCEA_NTSC |= SINK_480I;
+			break;
+
+		case 7:
+			ui4CEA_NTSC |= SINK_480I;
+			ui4OrgCEA_NTSC |= SINK_480I;	/* 16:9 */
+			if (*(prData + 1 + bIdx) & 0x80)	/* Native bit */
+				ui4NativeCEA_NTSC |= SINK_480I;
+			break;
+		case 2:
+			ui4CEA_NTSC |= SINK_480P;
+			ui4OrgCEA_NTSC |= SINK_480P;
+			if (*(prData + 1 + bIdx) & 0x80)	/* Native bit */
+				ui4NativeCEA_NTSC |= SINK_480P;
+
+			break;
+		case 3:
+			ui4CEA_NTSC |= SINK_480P;
+			ui4OrgCEA_NTSC |= SINK_480P;
+			if (*(prData + 1 + bIdx) & 0x80)	/* Native bit */
+				ui4NativeCEA_NTSC |= SINK_480P;
+
+			break;
+		case 14:
+		case 15:
+			ui4CEA_NTSC |= SINK_480P_1440;
+			ui4OrgCEA_NTSC |= SINK_480P_1440;
+			if (*(prData + 1 + bIdx) & 0x80)	/* Native bit */
+				ui4NativeCEA_NTSC |= SINK_480P_1440;
+
+			break;
+		case 4:
+			ui4CEA_NTSC |= SINK_720P60;
+			ui4OrgCEA_NTSC |= SINK_720P60;
+			if (*(prData + 1 + bIdx) & 0x80)	/* Native bit */
+				ui4NativeCEA_NTSC |= SINK_720P60;
+
+			break;
+		case 5:
+			ui4CEA_NTSC |= SINK_1080I60;
+			ui4OrgCEA_NTSC |= SINK_1080I60;
+			if (*(prData + 1 + bIdx) & 0x80)	/* Native bit */
+				ui4NativeCEA_NTSC |= SINK_1080I60;
+			break;
+		case 21:
+			ui4CEA_PAL |= SINK_576I;
+			ui4OrgCEA_PAL |= SINK_576I;
+			if (*(prData + 1 + bIdx) & 0x80)	/* Native bit */
+				ui4NativeCEA_PAL |= SINK_576I;
+			break;
+
+		case 22:
+			ui4CEA_PAL |= SINK_576I;
+			ui4OrgCEA_PAL |= SINK_576I;
+			if (*(prData + 1 + bIdx) & 0x80)	/* Native bit */
+				ui4NativeCEA_PAL |= SINK_576I;
+
+			break;
+		case 16:
+			ui4CEA_NTSC |= SINK_1080P60;
+			ui4OrgCEA_NTSC |= SINK_1080P60;
+			if (*(prData + 1 + bIdx) & 0x80)	/* Native bit */
+				ui4NativeCEA_NTSC |= SINK_1080P60;
+			break;
+
+		case 17:
+			ui4CEA_PAL |= SINK_576P;
+			ui4OrgCEA_PAL |= SINK_576P;
+			if (*(prData + 1 + bIdx) & 0x80)	/* Native bit */
+				ui4NativeCEA_PAL |= SINK_576P;
+			break;
+
+		case 18:
+			ui4CEA_PAL |= SINK_576P;
+			ui4OrgCEA_PAL |= SINK_576P;
+			if (*(prData + 1 + bIdx) & 0x80)	/* Native bit */
+				ui4NativeCEA_PAL |= SINK_576P;
+
+			break;
+
+		case 29:
+		case 30:
+			ui4CEA_PAL |= SINK_576P_1440;
+			ui4OrgCEA_PAL |= SINK_576P_1440;
+			if (*(prData + 1 + bIdx) & 0x80)	/* Native bit */
+				ui4NativeCEA_PAL |= SINK_576P_1440;
+			break;
+
+		case 19:
+			ui4CEA_PAL |= SINK_720P50;
+			ui4OrgCEA_PAL |= SINK_720P50;
+			if (*(prData + 1 + bIdx) & 0x80)	/* Native bit */
+				ui4NativeCEA_PAL |= SINK_720P50;
+
+			break;
+		case 20:
+			ui4CEA_PAL |= SINK_1080I50;
+			ui4OrgCEA_PAL |= SINK_1080I50;
+			if (*(prData + 1 + bIdx) & 0x80)	/* Native bit */
+				ui4NativeCEA_PAL |= SINK_1080I50;
+
+			break;
+
+		case 31:
+			ui4CEA_PAL |= SINK_1080P50;
+			ui4OrgCEA_PAL |= SINK_1080P50;
+			if (*(prData + 1 + bIdx) & 0x80)	/* Native bit */
+				ui4NativeCEA_PAL |= SINK_1080P50;
+			break;
+
+		case 32:
+			ui4CEA_NTSC |= SINK_1080P24;
+			ui4CEA_PAL |= SINK_1080P24;
+			ui4CEA_NTSC |= SINK_1080P23976;
+			ui4CEA_PAL |= SINK_1080P23976;
+			ui4OrgCEA_PAL |= SINK_1080P24;
+			ui4OrgCEA_NTSC |= SINK_1080P23976;
+			if (*(prData + 1 + bIdx) & 0x80)	/* Native bit */
+				ui4NativeCEA_PAL |= SINK_1080P24;
+
+			break;
+
+		case 33:
+			/* ui4CEA_NTSC |= SINK_1080P25; */
+			ui4CEA_PAL |= SINK_1080P25;
+			ui4OrgCEA_PAL |= SINK_1080P25;
+			if (*(prData + 1 + bIdx) & 0x80)	/* Native bit */
+				ui4NativeCEA_PAL |= SINK_1080P25;
+
+			break;
+
+		case 34:
+			ui4CEA_NTSC |= SINK_1080P30;
+			ui4CEA_NTSC |= SINK_1080P2997;
+			ui4CEA_PAL |= SINK_1080P30;
+			ui4CEA_PAL |= SINK_1080P2997;
+			ui4OrgCEA_PAL |= SINK_1080P30;
+			ui4OrgCEA_NTSC |= SINK_1080P2997;
+			if (*(prData + 1 + bIdx) & 0x80)	/* Native bit */
+				ui4NativeCEA_PAL |= SINK_1080P30;
+			break;
+
+		case 35:
+			ui4CEA_NTSC |= SINK_480P_2880;
+			ui4OrgCEA_NTSC |= SINK_480P_2880_4_3;
+			if (b_Native_bit)	/* Native bit */
+				ui4NativeCEA_NTSC |= SINK_480P_2880_4_3;
+			break;
+
+		case 36:
+			ui4CEA_NTSC |= SINK_480P_2880;
+			ui4OrgCEA_NTSC |= SINK_480P_2880;
+			if (b_Native_bit)	/* Native bit */
+				ui4NativeCEA_NTSC |= SINK_480P_2880;
+			break;
+
+		case 37:
+			ui4CEA_PAL |= SINK_576P_2880;
+			ui4OrgCEA_PAL |= SINK_576P_2880_4_3;
+			if (b_Native_bit)	/* Native bit */
+				ui4NativeCEA_PAL |= SINK_576P_2880_4_3;
+			break;
+
+		case 38:
+			ui4CEA_PAL |= SINK_576P_2880;
+			ui4OrgCEA_PAL |= SINK_576P_2880;
+			if (b_Native_bit)	/* Native bit */
+				ui4NativeCEA_PAL |= SINK_576P_2880;
+
+			break;
+		case 93:
+		case 103:
+			_HdmiSinkAvCap.ui4_sink_hdmi_4k2kvic |=
+			    SINK_2160P_24HZ | SINK_2160P_23_976HZ;
+			break;
+		case 94:
+		case 104:
+			_HdmiSinkAvCap.ui4_sink_hdmi_4k2kvic |= SINK_2160P_25HZ;
+			break;
+		case 95:
+		case 105:
+			_HdmiSinkAvCap.ui4_sink_hdmi_4k2kvic |=
+			    SINK_2160P_29_97HZ | SINK_2160P_30HZ;
+			break;
+		case 98:
+			_HdmiSinkAvCap.ui4_sink_hdmi_4k2kvic |=
+			    SINK_2161P_24HZ | SINK_2161P_23_976HZ;
+			break;
+		case 99:
+			_HdmiSinkAvCap.ui4_sink_hdmi_4k2kvic |= SINK_2161P_25HZ;
+			break;
+		case 100:
+			_HdmiSinkAvCap.ui4_sink_hdmi_4k2kvic |=
+			    SINK_2161P_29_97HZ | SINK_2161P_30HZ;
+			break;
+
+		case 96:
+		case 106:
+			_HdmiSinkAvCap.ui4_sink_hdmi_4k2kvic |= SINK_2160P_50HZ;
+			break;
+		case 97:
+		case 107:
+			_HdmiSinkAvCap.ui4_sink_hdmi_4k2kvic |= SINK_2160P_60HZ;
+			break;
+		case 101:
+			_HdmiSinkAvCap.ui4_sink_hdmi_4k2kvic |= SINK_2161P_50HZ;
+			break;
+		case 102:
+			_HdmiSinkAvCap.ui4_sink_hdmi_4k2kvic |= SINK_2161P_60HZ;
+			break;
+		case 60:
+			ui4CEA_NTSC |= SINK_720P24;
+			ui4CEA_PAL |= SINK_720P24;
+			ui4CEA_NTSC |= SINK_720P23976;
+			ui4CEA_PAL |= SINK_720P23976;
+			ui4OrgCEA_PAL |= SINK_720P24;
+			ui4OrgCEA_NTSC |= SINK_720P23976;
+			if (b_Native_bit)	/* Native bit */
+				ui4NativeCEA_PAL |= SINK_720P24;
+			break;
+
+		default:
+			break;
+		}
+
+		if (bIdx < 0x10) {
+			switch (*(prData + 1 + bIdx) & 0x7f) {
+			case 6:
+			case 7:
+				ui4Temp = SINK_480I;
+				break;
+			case 2:
+			case 3:
+				ui4Temp = SINK_480P;
+				break;
+			case 14:
+			case 15:
+				ui4Temp = SINK_480P_1440;
+				break;
+			case 4:
+				ui4Temp = SINK_720P60;
+				break;
+			case 5:
+				ui4Temp = SINK_1080I60;
+				break;
+			case 21:
+			case 22:
+				ui4Temp = SINK_576I;
+				break;
+			case 16:
+				ui4Temp = SINK_1080P60;
+				break;
+
+			case 17:
+			case 18:
+				ui4Temp = SINK_576P;
+				break;
+			case 29:
+			case 30:
+				ui4Temp = SINK_576P_1440;
+				break;
+			case 19:
+				ui4Temp = SINK_720P50;
+				break;
+			case 20:
+				ui4Temp = SINK_1080I50;
+				break;
+
+			case 31:
+				ui4Temp = SINK_1080P50;
+				break;
+
+			case 32:
+				ui4Temp |= SINK_1080P24;
+				ui4Temp |= SINK_1080P23976;
+				break;
+
+			case 33:
+				/* ui4CEA_NTSC |= SINK_1080P25; */
+				ui4Temp = SINK_1080P25;
+				break;
+
+			case 34:
+				ui4Temp |= SINK_1080P30;
+				ui4Temp |= SINK_1080P2997;
+
+				break;
+
+			default:
+				break;
+
+
+			}
+
+			_ui4First_16_NTSC_VIC |= ui4CEA_NTSC;
+			_ui4First_16_PAL_VIC |= ui4CEA_PAL;
+			_ui4First_16_VIC[bIdx] = ui4Temp;
+		}
+
+		if (*(prData + 1 + bIdx) & 0x80) {
+			ui4OrgCEA_NTSC =
+				ui4CEA_NTSC & (~ui4OrgCEA_NTSC);
+			ui4OrgCEA_PAL =
+				ui4CEA_PAL & (~ui4OrgCEA_PAL);
+
+			if (ui4OrgCEA_NTSC) {
+				_HdmiSinkAvCap
+					.ui4_sink_native_ntsc_resolution =
+					ui4OrgCEA_NTSC;
+			} else if (ui4OrgCEA_PAL) {
+				_HdmiSinkAvCap
+					.ui4_sink_native_pal_resolution =
+					ui4OrgCEA_PAL;
+			} else {
+				_HdmiSinkAvCap
+					.ui4_sink_native_ntsc_resolution = 0;
+				_HdmiSinkAvCap
+					.ui4_sink_native_pal_resolution = 0;
+			}
+		}
+	}
+
+	_HdmiSinkAvCap.ui4_sink_cea_ntsc_resolution |=
+		ui4CEA_NTSC;
+	_HdmiSinkAvCap.ui4_sink_cea_pal_resolution |=
+		ui4CEA_PAL;
+	_HdmiSinkAvCap.ui4_sink_org_cea_ntsc_resolution |=
+		ui4OrgCEA_NTSC;
+	_HdmiSinkAvCap.ui4_sink_org_cea_pal_resolution |=
+		ui4OrgCEA_PAL;
+	_HdmiSinkAvCap.ui4_sink_native_ntsc_resolution |=
+		ui4NativeCEA_NTSC;
+	_HdmiSinkAvCap.ui4_sink_native_pal_resolution |=
+		ui4NativeCEA_PAL;
+
+}
+
+static void vParser_Audio_Data_Block(
+	unsigned char *prData, unsigned char Len)
+{
+	unsigned int bIdx;
+	unsigned char bLengthSum;
+	unsigned char bNo, bAudCode, bPcmChNum;
+
+	bNo = Len;
+	/* Audio data block */
+	_HdmiSinkAvCap.ui2_edid_chksum_and_audio_sup &=
+	~(SINK_SAD_NO_EXIST);
+	for (bIdx = 0; bIdx < (bNo / 3); bIdx++) {
+		bLengthSum = bIdx * 3;
+		bAudCode = (*(prData + bLengthSum + 1) &
+			0x78) >> 3;	/* get audio code */
+
+		if (bAudCode == AVD_DOLBY_PLUS) {
+			bPcmChNum = (*(prData + bLengthSum + 1) & 0x07) + 1;
+			if (bPcmChNum >= 2) {
+				_HdmiSinkAvCap.ui1_sink_ec3_ch_sampling[bPcmChNum - 2] =
+					(*(prData + bLengthSum + 2) & 0x7f);
+			}
+		}
+		if (((*(prData + bLengthSum + 3) & 0x01) == 0x1) &&
+			(bAudCode == AVD_DOLBY_PLUS)) {
+			bAudCode = AVD_DOLBY_ATMOS;
+			_HdmiSinkAvCap.ui1_sink_support_dolby_atoms = TRUE;
+		}
+
+		if ((bAudCode >= AVD_LPCM) && bAudCode <= AVD_WMA) {
+			_HdmiSinkAvCap.ui2_sink_aud_dec |= (1 << (bAudCode - 1));
+	/* PCM:1 HDMI_SINK_AUDIO_DEC_LPCM AC3:2 HDMI_SINK_AUDIO_DEC_AC3 */
+	/*must support dolby plus if support atmos according to spec*/
+
+			if (bAudCode == AVD_DOLBY_ATMOS)
+				_HdmiSinkAvCap.ui2_sink_aud_dec |=
+				(1 << (AVD_DOLBY_PLUS - 1));
+		}
+
+		if (bAudCode == AVD_LPCM) {	/* LPCM */
+			bPcmChNum = (*(prData + bLengthSum + 1) & 0x07) + 1;
+			if (bPcmChNum >= 2) {
+				_HdmiSinkAvCap.ui1_sink_pcm_ch_sampling[bPcmChNum - 2] =
+					(*(prData + bLengthSum + 2) & 0x7f);
+				_HdmiSinkAvCap.ui1_sink_pcm_bit_size[bPcmChNum - 2] =
+				    (*(prData + bLengthSum + 3) & 0x07);
+			}
+		}
+
+		if (bAudCode == AVD_AC3) {	/* AVD_AC3 */
+			bPcmChNum = (*(prData + bLengthSum + 1) & 0x07) + 1;
+			if (bPcmChNum >= 2) {
+				_HdmiSinkAvCap.ui1_sink_ac3_ch_sampling[bPcmChNum - 2] =
+				    (*(prData + bLengthSum + 2) & 0x7f);
+			}
+		}
+
+		if (bAudCode == AVD_DST) {	/* DST */
+			bPcmChNum = (*(prData + bLengthSum + 1) & 0x07) + 1;
+			if (bPcmChNum >= 2) {
+				_HdmiSinkAvCap.ui1_sink_dst_ch_sampling[bPcmChNum - 2] =
+				    (*(prData + bLengthSum + 2) & 0x7f);
+			}
+		}
+
+		if (bAudCode == AVD_DSD) {	/* DSD */
+			bPcmChNum = (*(prData + bLengthSum + 1) & 0x07) + 1;
+			if (bPcmChNum >= 2) {
+				_HdmiSinkAvCap.ui1_sink_dsd_ch_sampling[bPcmChNum - 2] =
+				    (*(prData + bLengthSum + 2) & 0x7f);
+			}
+		}
+
+		if (bAudCode == AVD_MPEG1_AUD) {
+			bPcmChNum = (*(prData + bLengthSum + 1) & 0x07) + 1;
+			if (bPcmChNum >= 2) {
+				_HdmiSinkAvCap.ui1_sink_mpeg1_ch_sampling[bPcmChNum - 2] =
+				(*(prData + bLengthSum + 2) & 0x7f);
+			}
+		}
+
+		if (bAudCode == AVD_MP3) {
+			bPcmChNum = (*(prData + bLengthSum + 1) & 0x07) + 1;
+			if (bPcmChNum >= 2) {
+				_HdmiSinkAvCap.ui1_sink_mp3_ch_sampling[bPcmChNum - 2] =
+					(*(prData + bLengthSum + 2) & 0x7f);
+			}
+		}
+
+		if (bAudCode == AVD_MPEG2_AUD) {
+			bPcmChNum = (*(prData + bLengthSum + 1) & 0x07) + 1;
+			if (bPcmChNum >= 2) {
+				_HdmiSinkAvCap.ui1_sink_mpeg2_ch_sampling[bPcmChNum - 2] =
+				    (*(prData + bLengthSum + 2) & 0x7f);
+			}
+		}
+
+		if (bAudCode == AVD_AAC) {
+			bPcmChNum = (*(prData + bLengthSum + 1) & 0x07) + 1;
+			if (bPcmChNum >= 2) {
+				_HdmiSinkAvCap.ui1_sink_aac_ch_sampling[bPcmChNum - 2] =
+				    (*(prData + bLengthSum + 2) & 0x7f);
+			}
+		}
+
+		if (bAudCode == AVD_DTS) {
+			_HdmiSinkAvCap.ui4_sink_dts_fs =
+				(*(prData + bLengthSum + 2) & 0x7f);
+			bPcmChNum = (*(prData + bLengthSum + 1) & 0x07) + 1;
+			if (bPcmChNum >= 2) {
+				_HdmiSinkAvCap.ui1_sink_dts_ch_sampling[bPcmChNum - 2] =
+				    (*(prData + bLengthSum + 2) & 0x7f);
+			}
+		}
+
+		if (bAudCode == AVD_ATRAC) {
+			bPcmChNum = (*(prData + bLengthSum + 1) & 0x07) + 1;
+			if (bPcmChNum >= 2) {
+				_HdmiSinkAvCap.ui1_sink_atrac_ch_sampling[bPcmChNum - 2] =
+				    (*(prData + bLengthSum + 2) & 0x7f);
+			}
+		}
+
+		if (bAudCode == AVD_DOLBY_PLUS) {
+			bPcmChNum = (*(prData + bLengthSum + 1) & 0x07) + 1;
+			if (bPcmChNum >= 2) {
+				_HdmiSinkAvCap.ui1_sink_dolby_plus_ch_sampling[bPcmChNum - 2] =
+				    (*(prData + bLengthSum + 2) & 0x7f);
+			}
+			if ((*(prData + bLengthSum + 3) & 0x01) == 0x1) {
+				/* SAD DD+, Byte-3 Bit-0 is Dolby Atmos */
+				_HdmiSinkAvCap.ui1_sink_support_dolby_atoms = TRUE;
+			}
+			if ((*(prData + bLengthSum + 3) & 0x02) == 0x2) {
+		/* SAD DD+, Byte-3 Bit-1 is Dolby Atmos ACMOD 28 */
+				_HdmiSinkAvCap.ui1_sink_support_dolby_atoms = TRUE;
+			}
+
+		}
+
+		if (bAudCode == AVD_DTS_HD) {
+			bPcmChNum = (*(prData + bLengthSum + 1) & 0x07) + 1;
+			if (bPcmChNum >= 2) {
+				_HdmiSinkAvCap.ui1_sink_dts_hd_ch_sampling[bPcmChNum - 2] =
+				    (*(prData + bLengthSum + 2) & 0x7f);
+			}
+		}
+
+		if (bAudCode == AVD_MAT_MLP) {
+			bPcmChNum = (*(prData + bLengthSum + 1) & 0x07) + 1;
+			if (bPcmChNum >= 2) {
+				_HdmiSinkAvCap.ui1_sink_mat_mlp_ch_sampling[bPcmChNum - 2] =
+				    (*(prData + bLengthSum + 2) & 0x7f);
+			}
+		}
+
+		if (bAudCode == AVD_WMA) {
+			bPcmChNum = (*(prData + bLengthSum + 1) & 0x07) + 1;
+			if (bPcmChNum >= 2) {
+				_HdmiSinkAvCap.ui1_sink_wma_ch_sampling[bPcmChNum - 2] =
+				    (*(prData + bLengthSum + 2) & 0x7f);
+			}
+		}
+	}
+}
+
+static void vParser_Speaker_Allocation(
+	unsigned char *prData, unsigned char Len)
+{
+	_HdmiSinkAvCap.ui1_sink_spk_allocation =
+		*(prData + 1) & 0x7f;
+
+}
+
+static void vParser_VendorSpecfic_Data_Block(
+	unsigned char *prData, unsigned char Len)
+{
+	unsigned char bTemp13;
+	unsigned char bTemp8;
+	unsigned char bTemp;
+	unsigned char bNo = Len;
+	unsigned char bLatency_offset = 0;
+	unsigned char b3D_Multi_present = 0,
+		b3D_Structure_7_0 = 1,
+		b3D_MASK_15_8 = 1,
+		b3D_MASK_7_0 = 1,
+		b2D_VIC_order_Index = 0;
+	unsigned char i, bTemp14 = 1, bDataTemp = 1;
+	unsigned int u23D_MASK_ALL;
+
+	/* HF VDSB exit */
+	for (bTemp = 0; bTemp < EDID_VSDB_LEN; bTemp++) {
+		if (*(prData + bTemp + 1) != aEDIDHFVSDBHeader[bTemp])
+			break;
+	}
+	if (bTemp == EDID_VSDB_LEN) {
+		vSetSharedInfo(SI_EDID_VSDB_EXIST, TRUE);
+		_HdmiSinkAvCap.b_sink_support_hdmi_mode = TRUE;
+		for (i = 0; i < 8; i++) {
+			_HdmiSinkAvCap.ui1_sink_hfvsdb_block[i] =
+			    *(prData + i);
+		}
+
+		_HdmiSinkAvCap.ui2_sink_max_tmds_character_rate =
+			*(prData + 5) * 5;
+		bTemp13 = *(prData + 6);
+		if (bTemp13 & 0x88)
+			_HdmiSinkAvCap.b_sink_LTE_340M_sramble = TRUE;
+		if (bTemp13 & 0x80) {
+			_HdmiSinkAvCap.ui1_sink_hf_vsdb_info |=
+				EDID_HF_VSDB_SCDC_PRESENT;
+			_HdmiSinkAvCap.b_sink_SCDC_present = TRUE;
+		}
+		if (bTemp13 & 0x40) {
+			_HdmiSinkAvCap.ui1_sink_hf_vsdb_info |=
+			    EDID_HF_VSDB_RR_CAPABLE;
+		}
+		if (bTemp13 & 0x08) {
+			_HdmiSinkAvCap.ui1_sink_hf_vsdb_info |=
+			    EDID_HF_VSDB_LTE_340MCSC_SCRAMBLE;
+		}
+		if (bTemp13 & 0x04) {
+			_HdmiSinkAvCap.ui1_sink_hf_vsdb_info |=
+			    EDID_HF_VSDB_INDEPENDENT_VIEW;
+		}
+		if (bTemp13 & 0x02) {
+			_HdmiSinkAvCap.ui1_sink_hf_vsdb_info |=
+			    EDID_HF_VSDB_DUAL_VIEW;
+		}
+		if (bTemp13 & 0x01) {
+			_HdmiSinkAvCap.ui1_sink_hf_vsdb_info |=
+			    EDID_HF_VSDB_3D_OSD_DISPARITY;
+		}
+		bTemp13 = *(prData + 7);
+		_HdmiSinkAvCap.ui1_sink_dc420_color_bit =
+			(bTemp13 & 0x07);
+	}
+
+
+	/* VDSB exit */
+	for (bTemp = 0; bTemp < EDID_VSDB_LEN; bTemp++) {
+		if (*(prData + bTemp + 1) != aEDIDVSDBHeader[bTemp])
+			break;
+	}
+	/* for loop to end, is. VSDB header match */
+	if (bTemp == EDID_VSDB_LEN) {
+		vSetSharedInfo(SI_EDID_VSDB_EXIST, TRUE);
+		_HdmiSinkAvCap.b_sink_support_hdmi_mode = TRUE;
+		/* Read CEC physis address */
+		if (bNo >= 5) {
+			_HdmiSinkAvCap.ui2_sink_cec_address =
+			    (*(prData + 4) << 8) | (*(prData + 5));
+		} else {
+			_HdmiSinkAvCap.ui2_sink_cec_address = 0xFFFF;
+		}
+
+		/* Read Support AI */
+		if (bNo >= 6) {
+			bTemp = *(prData + 6);
+			if (bTemp & 0x80) {
+				_HdmiSinkAvCap.ui1_sink_support_ai = 1;
+				vSetSharedInfo(SI_HDMI_SUPPORTS_AI, 1);
+			} else {
+				_HdmiSinkAvCap.ui1_sink_support_ai = 0;
+				vSetSharedInfo(SI_HDMI_SUPPORTS_AI, 0);
+			}
+
+			/* kenny add 2010/4/25 for repeater EDID check */
+			_HdmiSinkAvCap.u1_sink_support_ai =
+			i4SharedInfo(SI_HDMI_SUPPORTS_AI);
+			_HdmiSinkAvCap.e_sink_rgb_color_bit =
+				((bTemp >> 4) & 0x07);
+
+			_HdmiSinkAvCap.u1_sink_max_tmds = *(prData + 7);
+
+			if (bTemp & 0x08) {	/* support YCbCr Deep Color */
+				_HdmiSinkAvCap.e_sink_ycbcr_color_bit =
+					((bTemp >> 4) & 0x07);
+			}
+		} else {
+			_HdmiSinkAvCap.ui1_sink_support_ai = 0;
+			vSetSharedInfo(SI_HDMI_SUPPORTS_AI, 0);
+		}
+
+		/* max tmds clock */
+		if (bNo >= 7) {
+			bTemp = *(prData + 7);
+			_HdmiSinkAvCap.ui1_sink_max_tmds_clock =
+				((unsigned short)bTemp) * 5;
+		} else {
+			_HdmiSinkAvCap.ui1_sink_max_tmds_clock = 0;
+		}
+
+		/* Read Latency data */
+		if (bNo >= 8) {
+			bTemp = *(prData + 8);
+			if (bTemp & 0x20)
+				_HdmiSinkAvCap.b_sink_hdmi_video_present = 1;
+			else
+				_HdmiSinkAvCap.b_sink_hdmi_video_present = 0;
+			_HdmiSinkAvCap.ui1_sink_content_cnc = bTemp & 0x0f;
+
+			if (bTemp & 0x80) {	/* Latency Present */
+				/* kenny add 2010/4/25 */
+				_HdmiSinkAvCap
+				.ui1_sink_p_latency_present = TRUE;
+				if ((bNo >= 9) && (*(prData + 9) != 0x00) &&
+					(*(prData + 9) != 0xFF))
+					_HdmiSinkAvCap
+					.ui1_sink_p_video_latency =
+					(*(prData + 9) - 1) << 1;
+				if ((bNo >= 10) && (*(prData + 10) != 0x00) &&
+					(*(prData + 10) != 0xFF))
+					_HdmiSinkAvCap
+					.ui1_sink_p_audio_latency =
+					(*(prData + 10) - 1) << 1;
+
+			}
+			if (bTemp & 0x40) {	/* Interlace Latency present */
+				_HdmiSinkAvCap
+					.ui1_sink_i_latency_present = TRUE;
+				if ((bNo >= 11) && (*(prData + 11) != 0x00) &&
+					(*(prData + 11) != 0xFF))
+					_HdmiSinkAvCap
+					.ui1_sink_i_video_latency =
+					(*(prData + 11) - 1) << 1;
+				if ((bNo >= 12) && (*(prData + 12) != 0x00) &&
+					(*(prData + 12) != 0xFF))
+					_HdmiSinkAvCap
+					.ui1_sink_i_audio_latency =
+					(*(prData + 12) - 1) << 1;
+			}
+
+			_HdmiSinkAvCap.ui1_CNC = bTemp & 0x0F;
+		}
+
+		if (bNo >= 8) {
+			bTemp = *(prData + 8);
+
+			if (!(bTemp & 0x80))	/* Latency Present */
+				bLatency_offset = bLatency_offset + 2;
+			if (!(bTemp & 0x40))	/* Interlace Latency present */
+				bLatency_offset = bLatency_offset + 2;
+		}
+		if (bNo >= 13) {	/* kenny add */
+			bTemp = *(prData + 13);
+			if (bTemp & 0x80)
+				_HdmiSinkAvCap.b_sink_3D_present = 1;
+			else
+				_HdmiSinkAvCap.b_sink_3D_present = 0;
+
+		}
+		if (bNo >= 8) {
+			bTemp8 = *(prData + 8);
+
+			if (bTemp8 & 0x20)
+				;
+		}
+
+		if (bNo >= (13 - bLatency_offset)) {
+			bTemp13 = *(prData + 13 - bLatency_offset);
+
+			if (bTemp13 & 0x80) {
+				_u4i_3D_VIC |= SINK_720P50;
+				_u4i_3D_VIC |= SINK_720P60;
+				_u4i_3D_VIC |= SINK_1080P23976;
+				_u4i_3D_VIC |= SINK_1080P24;
+				_HdmiSinkAvCap.b_sink_3D_present = TRUE;
+			} else
+				_HdmiSinkAvCap.b_sink_3D_present = FALSE;
+		} else
+			_HdmiSinkAvCap.b_sink_3D_present = FALSE;
+
+		if (bNo >= (13 - bLatency_offset)) {
+			bTemp13 = *(prData + 13 - bLatency_offset);
+
+			if ((bTemp13 & 0x60) == 0x20)
+				b3D_Multi_present = 0x20;
+			else if ((bTemp13 & 0x60) == 0x40)
+				b3D_Multi_present = 0x40;
+			else
+				b3D_Multi_present = 0x00;
+		}
+
+		if (bNo >= (14 - bLatency_offset))
+			bTemp14 = *(prData + 14 - bLatency_offset);
+
+		if (_HdmiSinkAvCap
+			.b_sink_hdmi_video_present == TRUE) {
+			/* hdmi_vic */
+			if ((bNo > (14 - bLatency_offset))
+				&& (((bTemp14 & 0xE0) >> 5) > 0)) {
+				for (bTemp = 0; bTemp <
+					((bTemp14 & 0xE0) >> 5);
+					 bTemp++) {
+					if ((*
+						 (prData + 15 -
+						 bLatency_offset +
+						  bTemp)) == 0x01)
+						_HdmiSinkAvCap
+						.ui4_sink_hdmi_4k2kvic
+							|=
+							SINK_2160P_29_97HZ +
+							SINK_2160P_30HZ;
+					if ((*
+						 (prData + 15 -
+						 bLatency_offset +
+						  bTemp)) == 0x02)
+						_HdmiSinkAvCap
+						.ui4_sink_hdmi_4k2kvic
+							|= SINK_2160P_25HZ;
+					if ((*
+						 (prData + 15 -
+						 bLatency_offset +
+						  bTemp)) == 0x03)
+						_HdmiSinkAvCap
+						.ui4_sink_hdmi_4k2kvic
+							|=
+							SINK_2160P_23_976HZ +
+							SINK_2160P_24HZ;
+					if ((*
+						 (prData + 15 -
+						 bLatency_offset +
+						  bTemp)) == 0x04)
+						_HdmiSinkAvCap
+						.ui4_sink_hdmi_4k2kvic
+							|= SINK_2161P_24HZ;
+				}
+			}
+		}
+
+		if (bNo > (14 - bLatency_offset + ((bTemp14 & 0xE0) >> 5))) {
+			if (b3D_Multi_present == 0x20) {
+				if (((15 - bLatency_offset +
+					((bTemp14 & 0xE0) >> 5)) +
+				     (bTemp14 & 0x1F)) >=
+				    (15 - bLatency_offset +
+				    ((bTemp14 & 0xE0) >> 5) + 2))
+					b3D_Structure_7_0 =
+					*(prData + 15 - bLatency_offset +
+					((bTemp14 & 0xE0) >> 5) + 1);
+
+				/* support frame packet */
+				if ((b3D_Structure_7_0 & 0x01) == 0x01)
+					for (i = 0; i < 0x10; i++)
+						_u4i_3D_VIC |=
+						_ui4First_16_VIC[i];
+
+				while (((15 - bLatency_offset +
+					 ((bTemp14 & 0xE0) >> 5)) +
+					(bTemp14 & 0x1F)) >
+				       ((15 - bLatency_offset +
+		((bTemp14 & 0xE0) >> 5)) + 2 + b2D_VIC_order_Index)) {
+					/* 2 is 3D_structure */
+					bDataTemp =
+					    *(prData + 15 - bLatency_offset +
+					      ((bTemp14 & 0xE0) >> 5) +
+					      2 + b2D_VIC_order_Index);
+					if ((bDataTemp & 0x0F) < 0x08) {
+						b2D_VIC_order_Index =
+					b2D_VIC_order_Index + 1;
+			/* 3D_Structure=0, support frame packet */
+					if ((bDataTemp & 0x0F) == 0x00)
+						_u4i_3D_VIC |=
+					_ui4First_16_VIC[((bDataTemp & 0xF0) >>
+								      4)];
+					} else {
+						b2D_VIC_order_Index =
+							b2D_VIC_order_Index + 2;
+					}
+				}
+			} else if (b3D_Multi_present == 0x40) {
+				if (((15 - bLatency_offset +
+				      ((bTemp14 & 0xE0) >> 5)) +
+				     (bTemp14 & 0x1F)) >=
+			((15 - bLatency_offset +
+			((bTemp14 & 0xE0) >> 5)) + 4)) {
+		/* 4 is 3D_structure+3D_MASK */
+		/* b3D_Structure_15_8=*(prData+15+((bTemp&0xE0)>>5)); */
+					b3D_Structure_7_0 =
+					    *(prData + 15 - bLatency_offset +
+					      ((bTemp14 & 0xE0) >> 5) + 1);
+					b3D_MASK_15_8 =
+					    *(prData + 15 - bLatency_offset +
+					      ((bTemp14 & 0xE0) >> 5) + 2);
+					b3D_MASK_7_0 =
+					    *(prData + 15 - bLatency_offset +
+					      ((bTemp14 & 0xE0) >> 5) + 3);
+					/* support frame packet */
+					if ((b3D_Structure_7_0 & 0x01) ==
+						0x01) {
+						u23D_MASK_ALL =
+					(((unsigned short)(b3D_MASK_15_8)) << 8)
+						    |
+					((unsigned short)(b3D_MASK_7_0));
+			for (i = 0; i < 0x10; i++) {
+				if (u23D_MASK_ALL & 0x0001)
+					_u4i_3D_VIC |=
+							_ui4First_16_VIC[i];
+
+						u23D_MASK_ALL =
+							u23D_MASK_ALL >> 1;
+					}
+				}
+
+				}
+				while (((15 - bLatency_offset +
+					 ((bTemp14 & 0xE0) >> 5)) +
+					(bTemp14 & 0x1F)) >
+				       (15 - bLatency_offset +
+					((bTemp14 & 0xE0) >> 5) + 4 +
+					b2D_VIC_order_Index)) {
+					bDataTemp =
+					    *(prData + 15 - bLatency_offset +
+					      ((bTemp14 & 0xE0) >> 5) +
+					      4 + b2D_VIC_order_Index);
+					if ((bDataTemp & 0x0F) < 0x08) {
+						b2D_VIC_order_Index =
+							b2D_VIC_order_Index + 1;
+						/* 3D_Structure=0 */
+					if ((bDataTemp & 0x0F) == 0x00) {
+						_u4i_3D_VIC |=
+					_ui4First_16_VIC[((bDataTemp & 0xF0) >>
+								      4)];
+					}
+
+					} else {
+						b2D_VIC_order_Index =
+							b2D_VIC_order_Index + 2;
+					}
+				}
+
+			} else {
+				b3D_Structure_7_0 = 0;
+				while (((15 - bLatency_offset +
+					 ((bTemp14 & 0xE0) >> 5)) +
+					(bTemp14 & 0x1F)) >
+				       ((15 - bLatency_offset +
+					 ((bTemp14 & 0xE0) >> 5)) +
+					 b2D_VIC_order_Index)) {
+					bDataTemp =
+					    *(prData + 15 - bLatency_offset +
+					      ((bTemp14 & 0xE0) >> 5) +
+					      b2D_VIC_order_Index);
+					if ((bDataTemp & 0x0F) < 0x08) {
+						b2D_VIC_order_Index =
+							b2D_VIC_order_Index + 1;
+					/* 3D_Structure=0 */
+					if ((bDataTemp & 0x0F) == 0x00) {
+						_u4i_3D_VIC |=
+					_ui4First_16_VIC[((bDataTemp &
+						    0xF0) >>
+								      4)];
+					}
+
+					} else {
+						b2D_VIC_order_Index =
+							b2D_VIC_order_Index + 2;
+					}
+				}
+			}
+
+		}
+		_HdmiSinkAvCap.ui4_sink_cea_3D_resolution = _u4i_3D_VIC;
+	} /* if(bTemp==EDID_VSDB_LEN) */
+	else {
+		/* vSetSharedInfo(SI_EDID_VSDB_EXIST, FALSE); */
+		/* _HdmiSinkAvCap.b_sink_support_hdmi_mode = FALSE; */
+	}
+
+}
+
+void vParserDolbyVisionBlock(unsigned char *prData)
+{
+	unsigned char bVersion;
+	unsigned char bLength;
+	unsigned char bDataLen;
+
+	bLength = (*prData) & 0x1F;
+	bVersion = ((*(prData + 5)) >> 5) & 0x07;
+	_HdmiSinkAvCap.ui4_sink_dolbyvision_vsvdb_length =
+		bLength + 1;
+	_HdmiSinkAvCap.ui4_sink_dolbyvision_vsvdb_version =
+		bVersion;
+
+	if (bLength > 0x1A) {
+		bDataLen = 0x1A;
+		HDMI_EDID_LOG("[HDMI TX]Dolby Vision length > 0x1A, %d\n",
+			bDataLen);
+	} else {
+		bDataLen = bLength;
+	}
+	memcpy(_HdmiSinkAvCap.ui1_sink_dolbyvision_block,
+		prData, (bDataLen + 1));
+
+
+	if ((bLength == 0x19) && (bVersion == 0)) {
+		_HdmiSinkAvCap.ui1_sink_support_dynamic_hdr |=
+			EDID_SUPPORT_DOLBY_HDR;
+		if ((*(prData + 5)) & 0x01)
+			_HdmiSinkAvCap.ui1_sink_support_dynamic_hdr |=
+			EDID_SUPPORT_YUV422_12BIT;
+		if ((*(prData + 5)) & 0x02)
+			_HdmiSinkAvCap.ui1_sink_support_dynamic_hdr |=
+			EDID_SUPPORT_DOLBY_HDR_2160P60;
+
+		_HdmiSinkAvCap.ui4_sink_dolbyvision_vsvdb_tminPQ =
+			((*(prData + 19)) << 4) |
+			(((*(prData + 18)) >> 4) &
+			0x0F);
+		_HdmiSinkAvCap.ui4_sink_dolbyvision_vsvdb_tmaxPQ =
+			((*(prData + 20)) << 4) | ((*(prData + 18)) & 0x0F);
+		_HdmiSinkAvCap.ui4_sink_dolbyvision_vsvdb_Rx =
+			((*(prData + 7)) << 4) |
+			(((*(prData + 6)) >> 4) &
+			0x0F);
+		_HdmiSinkAvCap.ui4_sink_dolbyvision_vsvdb_Ry =
+			((*(prData + 8)) << 4) | ((*(prData + 6)) & 0x0F);
+		_HdmiSinkAvCap.ui4_sink_dolbyvision_vsvdb_Gx =
+			((*(prData + 10)) << 4) | (((*(prData + 9)) >> 4) &
+			0x0F);
+		_HdmiSinkAvCap.ui4_sink_dolbyvision_vsvdb_Gy =
+			((*(prData + 11)) << 4) | ((*(prData + 9)) & 0x0F);
+		_HdmiSinkAvCap.ui4_sink_dolbyvision_vsvdb_Bx =
+			((*(prData + 13)) << 4) | (((*(prData + 12)) >> 4) &
+			0x0F);
+		_HdmiSinkAvCap.ui4_sink_dolbyvision_vsvdb_By =
+			((*(prData + 14)) << 4) | ((*(prData + 12)) & 0x0F);
+		_HdmiSinkAvCap.ui4_sink_dolbyvision_vsvdb_Wx =
+			((*(prData + 16)) << 4) | (((*(prData + 15)) >> 4) &
+			0x0F);
+		_HdmiSinkAvCap.ui4_sink_dolbyvision_vsvdb_Wy =
+			((*(prData + 17)) << 4) | ((*(prData + 15)) & 0x0F);
+	} else if ((bLength == 0x0E) &&
+	(bVersion == 1)) {
+		_HdmiSinkAvCap.ui1_sink_support_dynamic_hdr |=
+			EDID_SUPPORT_DOLBY_HDR;
+		if ((*(prData + 5)) & 0x01)
+			_HdmiSinkAvCap.ui1_sink_support_dynamic_hdr |=
+			EDID_SUPPORT_YUV422_12BIT;
+		if ((*(prData + 5)) & 0x02)
+			_HdmiSinkAvCap.ui1_sink_support_dynamic_hdr |=
+			EDID_SUPPORT_DOLBY_HDR_2160P60;
+
+		_HdmiSinkAvCap.ui4_sink_dolbyvision_vsvdb_tmin =
+			(*(prData + 7)) >> 1;
+		_HdmiSinkAvCap.ui4_sink_dolbyvision_vsvdb_tmax =
+			(*(prData + 6)) >> 1;
+		_HdmiSinkAvCap.ui4_sink_dolbyvision_vsvdb_Rx =
+			*(prData + 9);
+		_HdmiSinkAvCap.ui4_sink_dolbyvision_vsvdb_Ry =
+			*(prData + 10);
+		_HdmiSinkAvCap.ui4_sink_dolbyvision_vsvdb_Gx =
+			*(prData + 11);
+		_HdmiSinkAvCap.ui4_sink_dolbyvision_vsvdb_Gy =
+			*(prData + 12);
+		_HdmiSinkAvCap.ui4_sink_dolbyvision_vsvdb_Bx =
+			*(prData + 13);
+		_HdmiSinkAvCap.ui4_sink_dolbyvision_vsvdb_By =
+			*(prData + 14);
+	} else if ((bLength == 0x0B) && (bVersion == 1)) {
+		_HdmiSinkAvCap
+			.ui1_sink_support_dynamic_hdr |=
+			EDID_SUPPORT_DOLBY_HDR;
+		if ((*(prData + 5)) & 0x01)
+			_HdmiSinkAvCap
+			.ui1_sink_support_dynamic_hdr |=
+			EDID_SUPPORT_YUV422_12BIT;
+		if ((*(prData + 5)) & 0x02)
+			_HdmiSinkAvCap
+			.ui1_sink_support_dynamic_hdr |=
+			EDID_SUPPORT_DOLBY_HDR_2160P60;
+
+		_HdmiSinkAvCap
+			.ui4_sink_dolbyvision_vsvdb_v1_low_latency =
+			(*(prData + 8)) & 0x03;
+		if (_HdmiSinkAvCap
+			.ui4_sink_dolbyvision_vsvdb_v1_low_latency == 1)
+			_HdmiSinkAvCap
+			.ui4_sink_dolbyvision_vsvdb_low_latency_support = 1;
+		_HdmiSinkAvCap.ui4_sink_dolbyvision_vsvdb_tmin =
+			(*(prData + 7)) >> 1;
+		_HdmiSinkAvCap.ui4_sink_dolbyvision_vsvdb_tmax =
+			(*(prData + 6)) >> 1;
+		_HdmiSinkAvCap.ui4_sink_dolbyvision_vsvdb_Rx =
+			((*(prData + 11)) >> 3) | 0xA0;
+		_HdmiSinkAvCap.ui4_sink_dolbyvision_vsvdb_Ry =
+			(((*(prData + 11)) & 0x07) << 2)
+						 | (((*(prData + 10)) & 0x01)
+						 << 1) |
+						 ((*(prData + 9)) &
+						 0x01) | 0x40;
+		_HdmiSinkAvCap.ui4_sink_dolbyvision_vsvdb_Gx =
+			(*(prData + 9)) >> 1;
+		_HdmiSinkAvCap.ui4_sink_dolbyvision_vsvdb_Gy =
+			((*(prData + 10)) >> 1) | 0x80;
+		_HdmiSinkAvCap.ui4_sink_dolbyvision_vsvdb_Bx =
+			((*(prData + 8)) >> 5) | 0x20;
+		_HdmiSinkAvCap.ui4_sink_dolbyvision_vsvdb_By =
+			(((*(prData + 8)) >> 2) & 0x07) | 0x08;
+	} else if ((bLength == 0x0B) && (bVersion == 2)) {
+		_HdmiSinkAvCap
+		.ui1_sink_support_dynamic_hdr |=
+			EDID_SUPPORT_DOLBY_HDR;
+		if ((*(prData + 5)) & 0x01)
+			_HdmiSinkAvCap
+		.ui1_sink_support_dynamic_hdr |=
+			EDID_SUPPORT_YUV422_12BIT;
+		_HdmiSinkAvCap
+		.ui4_sink_dolbyvision_vsvdb_v2_interface =
+			(*(prData + 7)) & 0x03;
+
+		_HdmiSinkAvCap
+		.ui4_sink_dolbyvision_vsvdb_low_latency_support = 1;
+		_HdmiSinkAvCap
+		.ui4_sink_dolbyvision_vsvdb_v2_supports_10b_12b_444 =
+			(((*(prData + 8)) & 0x01) << 1) |
+			((*(prData + 9)) & 0x01);
+		_HdmiSinkAvCap
+		.ui4_sink_dolbyvision_vsvdb_support_backlight_control =
+			((*(prData + 5)) >> 1) & 0x01;
+		_HdmiSinkAvCap.ui4_sink_dolbyvision_vsvdb_backlt_min_lumal =
+			(*(prData + 6)) & 0x03;
+		_HdmiSinkAvCap.ui4_sink_dolbyvision_vsvdb_tminPQ =
+			((*(prData + 6)) >> 3) * 20;
+		_HdmiSinkAvCap.ui4_sink_dolbyvision_vsvdb_tmaxPQ =
+			((*(prData + 7)) >> 3) * 65 + 2055;
+		_HdmiSinkAvCap.ui4_sink_dolbyvision_vsvdb_Rx =
+			((*(prData + 10)) >> 3) | 0xA0;
+		_HdmiSinkAvCap.ui4_sink_dolbyvision_vsvdb_Ry =
+			((*(prData + 11)) >> 3) | 0x40;
+		_HdmiSinkAvCap.ui4_sink_dolbyvision_vsvdb_Gx =
+			(*(prData + 8)) >> 1;
+		_HdmiSinkAvCap.ui4_sink_dolbyvision_vsvdb_Gy =
+			((*(prData + 9)) >> 1) | 0x80;
+		_HdmiSinkAvCap.ui4_sink_dolbyvision_vsvdb_Bx =
+			((*(prData + 10)) & 0x07) | 0x20;
+		_HdmiSinkAvCap.ui4_sink_dolbyvision_vsvdb_By =
+			((*(prData + 11)) & 0x07) | 0x08;
+	}
+}
+
+
+static void vParser_User_Extension_Tag(
+	unsigned char *prData, unsigned char Len)
+{
+	unsigned char bTemp, bIdx, i;
+	unsigned int u4IEEE = 0;
+	unsigned char u2svd_420_cmdb;
+
+/* Use Extended Tag */
+	if (*(prData + 1) == 0x05) {
+		if (*(prData + 2) & 0x1) {
+			/* Suppot xvYcc601 */
+			_HdmiSinkAvCap.ui2_sink_colorimetry |=
+			SINK_XV_YCC601;
+		}
+
+		if (*(prData + 2) & 0x2) {
+			/* Suppot xvYcc709 */
+			_HdmiSinkAvCap.ui2_sink_colorimetry |=
+			SINK_XV_YCC709;
+		}
+
+		if (*(prData + 2) & 0x4) {
+			/* Suppot sYcc601 */
+			_HdmiSinkAvCap.ui2_sink_colorimetry |=
+			SINK_S_YCC601;
+		}
+
+		if (*(prData + 2) & 0x8) {
+			/* Suppot adobe Ycc709 */
+			_HdmiSinkAvCap.ui2_sink_colorimetry |=
+			SINK_ADOBE_YCC601;
+		}
+
+		if (*(prData + 2) & 0x10) {
+			/* Suppot adobe RGB */
+			_HdmiSinkAvCap.ui2_sink_colorimetry |=
+			SINK_ADOBE_RGB;
+		}
+
+		if (*(prData + 2) & 0x20) {
+			/* Suppot BT2020 Cycc */
+			_HdmiSinkAvCap.ui2_sink_colorimetry |=
+			SINK_COLOR_SPACE_BT2020_CYCC;
+		}
+
+		if (*(prData + 2) & 0x40) {
+			/* Suppot BT2020 Ycc */
+			_HdmiSinkAvCap.ui2_sink_colorimetry |=
+			SINK_COLOR_SPACE_BT2020_YCC;
+		}
+
+		if (*(prData + 2) & 0x80) {
+			/* Suppot BT2020 RGB */
+			_HdmiSinkAvCap.ui2_sink_colorimetry |=
+			SINK_COLOR_SPACE_BT2020_RGB;
+		}
+
+		if (*(prData + 3) & 0x1) {
+			/* support Gamut data P0 */
+			_HdmiSinkAvCap.ui2_sink_colorimetry |=
+			SINK_METADATA0;
+		}
+
+		if (*(prData + 3) & 0x2) {
+			/* support Gamut data P1 */
+			_HdmiSinkAvCap.ui2_sink_colorimetry |=
+			SINK_METADATA1;
+		}
+
+		if (*(prData + 3) & 0x4) {
+			/* support Gamut data P1 */
+			_HdmiSinkAvCap.ui2_sink_colorimetry |=
+			SINK_METADATA2;
+		}
+	} else if (*(prData + 1) ==
+	0x6) {
+		/* Extend Tag code ==0x6 */
+		/* support SDR */
+		if (*(prData + 2) & 0x1) {
+			/* Suppot SDR */
+			_HdmiSinkAvCap.ui1_sink_support_static_hdr |=
+			EDID_SUPPORT_SDR;
+		}
+
+		if (*(prData + 2) & 0x2) {
+			/* Suppot HDR */
+			_HdmiSinkAvCap.ui1_sink_support_static_hdr |=
+			EDID_SUPPORT_HDR;
+		}
+
+		if (*(prData + 2) & 0x4) {
+			/* Suppot ST 2084 */
+			_HdmiSinkAvCap.ui1_sink_support_static_hdr |=
+			EDID_SUPPORT_SMPTE_ST_2084;
+		}
+
+		if (*(prData + 2) & 0x8) {
+			/* Suppot Future EOTF */
+			_HdmiSinkAvCap.ui1_sink_support_static_hdr |=
+			EDID_SUPPORT_FUTURE_EOTF;
+		}
+
+		if (*(prData + 2) & 0x10) {
+			/* Suppot ET4 */
+			_HdmiSinkAvCap.ui1_sink_support_static_hdr |=
+			EDID_SUPPORT_ET_4;
+		}
+
+		if (*(prData + 2) & 0x20) {
+			/* Suppot ET5 */
+			_HdmiSinkAvCap.ui1_sink_support_static_hdr |=
+			EDID_SUPPORT_ET_5;
+		}
+
+		if ((*prData & 0x1F) >= 4) {
+			/* Max luminance */
+			_HdmiSinkAvCap.ui1_sink_hdr_content_max_luminance =
+			*(prData + 4);
+		}
+
+		if ((*prData & 0x1F) >= 5) {
+			/* support avarage luminance */
+			_HdmiSinkAvCap
+		.ui1_sink_hdr_content_max_frame_average_luminance =
+			    *(prData + 5);
+		}
+
+		if ((*prData & 0x1F) >= 6) {
+			/* support Min luminance */
+			_HdmiSinkAvCap.ui1_sink_hdr_content_min_luminance =
+			*(prData + 6);
+		}
+
+		for (bTemp = 0; bTemp < ((*prData & 0x1F) + 1); bTemp++) {
+			if (bTemp <= 6)
+				_HdmiSinkAvCap.ui1_sink_hdr_block[bTemp] =
+				*(prData + bTemp);
+		}
+	} else if (*(prData + 1) ==
+	0x7) {
+		unsigned char version, type_len = 0;
+		unsigned int type;
+
+		if (Len >= 1)
+		/* Extend Tag code ==0x7 */
+			for (bIdx = 0; bIdx < Len - 1; bIdx += type_len) {
+				type_len = *(prData + 2 + bIdx);
+				if (type_len >= 2) {
+					type =
+						(*(prData + 2 + bIdx + 1)) +
+					((*(prData + 2 + bIdx + 2)) << 8);
+				switch (type) {
+				case 0x0001:
+				case 0x0002:
+				case 0x0003:
+					break;
+				case 0x0004:
+					_HdmiSinkAvCap
+					.ui1_sink_support_dynamic_hdr |=
+						EDID_SUPPORT_HDR10_PLUS;
+					if (type_len >= 3)
+						version =
+						(*(prData + 2 + bIdx + 3)) &
+						0x0f;
+					break;
+				default:
+					break;
+				}
+			}
+		}
+	} else if (*(prData + 1) == 0x01) {
+		/* Extend Tag code ==0x01 philips vs-vsdb HDR dobly */
+		u4IEEE = ((*(prData + 4)) << 16) |
+		((*(prData + 3)) << 8) |
+		(*(prData + 2));
+		HDMI_EDID_LOG("u4IEEE = 0x%x, Len=%d\n", u4IEEE, Len);
+		if (u4IEEE == aEDIDPhilipsVSVDBHeader) {
+			if (Len >= 5) {
+				bTemp = *(prData + 5);
+				if (bTemp & 0x1)
+					_HdmiSinkAvCap
+				.ui1_sink_support_dynamic_hdr
+					|= EDID_SUPPORT_PHILIPS_HDR;
+			}
+		} else if (u4IEEE == aEDIDDoblyVSVDBHeader) {
+			vParserDolbyVisionBlock(prData);
+		} else if ((u4IEEE == aEDIDHdr10PlusVSVDBHeader) &&
+		(Len >= 5)) {
+			_HdmiSinkAvCap.ui1_sink_hdr10plus_app_version =
+				(*(prData + 5)) & 0x03;
+			_HdmiSinkAvCap.ui1_sink_support_dynamic_hdr |=
+				EDID_SUPPORT_HDR10_PLUS;
+		}
+	} else if (*(prData + 1) == 0xE) {
+		/* Extend Tag code ==0xE */
+		/* support ycbcr420 Only SVDs */
+		HDMI_EDID_LOG(
+		"Support YCBCR 420 only video data block, %d\n",
+		Len - 1);
+		for (bIdx = 0; bIdx < Len - 1; bIdx++) {
+			_HdmiSinkAvCap.ui2_sink_colorimetry |= SINK_YCBCR_420;
+			HDMI_EDID_LOG(" vic = %d\n", (*(prData + 2 + bIdx) &
+				0x7f));
+			switch (*(prData + 2 + bIdx) & 0x7f) {
+			case 96:
+			case 106:
+				_HdmiSinkAvCap.ui4_sink_hdmi_4k2kvic_420_vdb |=
+					SINK_2160P_50HZ;
+				break;
+			case 97:
+			case 107:
+				_HdmiSinkAvCap.ui4_sink_hdmi_4k2kvic_420_vdb |=
+					SINK_2160P_60HZ;
+				break;
+			case 101:
+				_HdmiSinkAvCap.ui4_sink_hdmi_4k2kvic_420_vdb |=
+					SINK_2161P_50HZ;
+				break;
+			case 102:
+				_HdmiSinkAvCap.ui4_sink_hdmi_4k2kvic_420_vdb |=
+					SINK_2161P_60HZ;
+				break;
+			default:
+				break;
+			}
+		}
+	} else if (*(prData + 1) ==
+	0xF) {
+		/* Extend Tag code ==0xF */
+		/* support ycbcr420 capability Map data block */
+		HDMI_EDID_LOG(
+		"Support YCBCR 420 Capability Map data block, %d\n",
+		Len - 1);
+		_HdmiSinkAvCap.ui2_sink_colorimetry |=
+			SINK_YCBCR_420_CAPABILITY;
+		if (Len == 1)
+			_HdmiSinkAvCap.ui4_sink_hdmi_4k2kvic_420_vdb =
+			    SINK_2160P_50HZ | SINK_2160P_60HZ |
+			    SINK_2161P_50HZ | SINK_2161P_60HZ;
+		else {
+			for (bIdx = 0; bIdx < Len - 1; bIdx++) {
+				u2svd_420_cmdb = *(prData + 2 + bIdx);
+				HDMI_EDID_LOG(
+					" u2svd_420_cmdb = %d\n",
+					u2svd_420_cmdb);
+			for (i = 0; i < 8; i++) {
+				if (u2svd_420_cmdb & 0x0001) {
+					switch (_ui4svd_128_VIC[bIdx * 8 + i]
+						& 0x7f) {
+					case 96:
+					case 106:
+			_HdmiSinkAvCap.ui4_sink_hdmi_4k2kvic_420_vdb
+						    |= SINK_2160P_50HZ;
+						break;
+					case 97:
+					case 107:
+			_HdmiSinkAvCap.ui4_sink_hdmi_4k2kvic_420_vdb
+					    |= SINK_2160P_60HZ;
+						break;
+					case 101:
+			_HdmiSinkAvCap.ui4_sink_hdmi_4k2kvic_420_vdb
+						    |= SINK_2161P_50HZ;
+						break;
+					case 102:
+			_HdmiSinkAvCap.ui4_sink_hdmi_4k2kvic_420_vdb
+						    |= SINK_2161P_60HZ;
+						break;
+					default:
+						break;
+					}
+					}
+					u2svd_420_cmdb = u2svd_420_cmdb >> 1;
+				}
+			}
+		}
+
+	} else if (*(prData + 1) == 0x0) {
+		/* Extend Tag code ==0x0 */
+		if (*(prData + 2) & 0x40) {
+			/* support selectable, QS=1 */
+			_HdmiSinkAvCap.ui2_sink_vcdb_data |=
+			SINK_RGB_SELECTABLE;
+		}
+	}
+}
+
+void vSetEdidChkError(void)
+{
+	unsigned char bInx;
+
+	HDMI_EDID_FUNC();
+	vSetSharedInfo(SI_EDID_PARSING_RESULT, TRUE);
+	vSetSharedInfo(SI_EDID_VSDB_EXIST, FALSE);
+	_HdmiSinkAvCap.b_sink_support_hdmi_mode = TRUE;
+	_HdmiSinkAvCap.ui4_sink_dtd_ntsc_resolution = SINK_480P;
+	_HdmiSinkAvCap.ui4_sink_dtd_pal_resolution = SINK_576P;
+	_HdmiSinkAvCap.ui2_sink_colorimetry = 0;
+	_HdmiSinkAvCap.ui4_sink_cea_ntsc_resolution = 0;
+	_HdmiSinkAvCap.ui4_sink_cea_pal_resolution = 0;
+	_HdmiSinkAvCap.ui4_sink_native_ntsc_resolution = 0;
+	_HdmiSinkAvCap.ui4_sink_native_pal_resolution = 0;
+	_HdmiSinkAvCap.ui2_sink_vcdb_data = 0;
+	_HdmiSinkAvCap.ui2_sink_aud_dec = 1;	/* PCM only */
+	_HdmiSinkAvCap.ui1_sink_dsd_ch_num = 0;
+	for (bInx = 0; bInx < 7; bInx++) {
+		if (bInx == 0)
+			_HdmiSinkAvCap.ui1_sink_pcm_ch_sampling[bInx] = 0x07;
+		else
+			_HdmiSinkAvCap.ui1_sink_pcm_ch_sampling[bInx] = 0x0;
+		_HdmiSinkAvCap.ui1_sink_dsd_ch_sampling[bInx] = 0;
+		_HdmiSinkAvCap.ui1_sink_dst_ch_sampling[bInx] = 0;
+		_HdmiSinkAvCap.ui1_sink_ac3_ch_sampling[bInx] = 0;
+		_HdmiSinkAvCap.ui1_sink_ec3_ch_sampling[bInx] = 0;
+	}
+
+	for (bInx = 0; bInx < 7; bInx++) {
+		if (bInx == 0)
+			_HdmiSinkAvCap.ui1_sink_pcm_bit_size[bInx] = 0x07;
+		else
+			_HdmiSinkAvCap.ui1_sink_pcm_bit_size[bInx] = 0;
+	}
+
+	_HdmiSinkAvCap.ui1_sink_spk_allocation = 0;
+	_HdmiSinkAvCap.ui1_sink_i_latency_present = 0;
+	_HdmiSinkAvCap.ui1_sink_p_latency_present = 0;
+	_HdmiSinkAvCap.ui1_sink_p_audio_latency = 0;
+	_HdmiSinkAvCap.ui1_sink_p_video_latency = 0;
+	_HdmiSinkAvCap.ui1_sink_i_audio_latency = 0;
+	_HdmiSinkAvCap.ui1_sink_i_video_latency = 0;
+
+	_HdmiSinkAvCap.e_sink_rgb_color_bit = HDMI_SINK_NO_DEEP_COLOR;
+	_HdmiSinkAvCap.e_sink_ycbcr_color_bit = HDMI_SINK_NO_DEEP_COLOR;
+	_HdmiSinkAvCap.ui1_sink_dc420_color_bit = HDMI_SINK_NO_DEEP_COLOR;
+	_HdmiSinkAvCap.ui2_edid_chksum_and_audio_sup =
+	    (SINK_BASIC_AUDIO_NO_SUP | SINK_SAD_NO_EXIST |
+	    SINK_BASE_BLK_CHKSUM_ERR |
+	     SINK_EXT_BLK_CHKSUM_ERR);
+	_HdmiSinkAvCap.b_sink_edid_ready = FALSE;
+	_HdmiSinkAvCap.ui1_sink_support_dolby_atoms = FALSE;
+	_HdmiSinkAvCap.ui1_sink_support_ai = 0;
+
+	_HdmiSinkAvCap.ui4_sink_hdmi_4k2kvic = 0;
+	_HdmiSinkAvCap.b_sink_SCDC_present = 0;
+	_HdmiSinkAvCap.b_sink_LTE_340M_sramble = 0;
+	_HdmiSinkAvCap.ui1_sink_max_tmds_clock = 0;
+	_HdmiSinkAvCap.ui2_sink_max_tmds_character_rate = 0;
+}
+
+void vParserCEADataBlock(unsigned char *prData, unsigned char bLen)
+{
+	unsigned char Header;
+	int bIdx;
+	unsigned char bType, dataBlock_Len;
+
+	HDMI_EDID_FUNC();
+	while (bLen) {
+		if (bLen > 0x80)
+			break;
+
+	/* Step 1: get 1st data block type & total number of this data type */
+		Header = *prData;
+		bType = Header >> 5;	/* bit[7:5] */
+		dataBlock_Len = Header & 0x1F;	/* bit[4:0] */
+
+		if (bType == 0x02)
+			vParser_Video_Data_Block(prData, dataBlock_Len);
+		else if (bType == 0x01)
+			vParser_Audio_Data_Block(prData, dataBlock_Len);
+		else if (bType == 0x04)
+			vParser_Speaker_Allocation(prData, dataBlock_Len);
+		else if (bType == 0x03)
+			vParser_VendorSpecfic_Data_Block(prData, dataBlock_Len);
+		else if (bType == 0x07)
+			vParser_User_Extension_Tag(prData, dataBlock_Len);
+		else
+			HDMI_EDID_LOG("Invalid Data Block\n");
+
+		/* re-assign the next data block address */
+		/* '1' means the tag byte */
+		prData += (dataBlock_Len + 1);
+		bLen -= (dataBlock_Len + 1);
+	}	/* while(bLen) */
+
+	for (bIdx = 6; bIdx >= 1; bIdx--) {
+		_HdmiSinkAvCap.ui1_sink_pcm_ch_sampling[bIdx - 1] |=
+		    _HdmiSinkAvCap.ui1_sink_pcm_ch_sampling[bIdx];
+		_HdmiSinkAvCap.ui1_sink_ac3_ch_sampling[bIdx - 1] |=
+		    _HdmiSinkAvCap.ui1_sink_ac3_ch_sampling[bIdx];
+		_HdmiSinkAvCap.ui1_sink_ec3_ch_sampling[bIdx - 1] |=
+		    _HdmiSinkAvCap.ui1_sink_ec3_ch_sampling[bIdx];
+		_HdmiSinkAvCap.ui1_sink_dts_ch_sampling[bIdx - 1] |=
+		    _HdmiSinkAvCap.ui1_sink_dts_ch_sampling[bIdx];
+		_HdmiSinkAvCap.ui1_sink_dts_hd_ch_sampling[bIdx - 1] |=
+		    _HdmiSinkAvCap.ui1_sink_dts_hd_ch_sampling[bIdx];
+		_HdmiSinkAvCap.ui1_sink_dsd_ch_sampling[bIdx - 1] |=
+		    _HdmiSinkAvCap.ui1_sink_dsd_ch_sampling[bIdx];
+	}
+
+	if (_HdmiSinkAvCap.ui2_edid_chksum_and_audio_sup &
+		SINK_EXT_BLK_CHKSUM_ERR) {
+		vSetSharedInfo(SI_EDID_VSDB_EXIST, FALSE);
+		_HdmiSinkAvCap.b_sink_support_hdmi_mode = FALSE;
+	}
+
+}
+
+
+unsigned char fgParserExtEDID(unsigned char *prData)
+{
+	unsigned char bIdx;
+	unsigned char bTemp = 0;
+	unsigned short ui2HActive, ui2HBlanking;
+	unsigned short ui2VActive, ui2VBlanking;
+	unsigned char bOfst, *prCEAaddr;
+	unsigned char Vfiq = 1;
+	unsigned int dHtotal = 1, dVtotal = 1, ui2PixClk = 1;
+
+	HDMI_EDID_FUNC();
+
+	_HdmiSinkAvCap.ui1_ExtEdid_Revision = *(prData +
+		EXTEDID_ADDR_REVISION);
+
+	for (bIdx = 0; bIdx < EDID_BLOCK_LEN; bIdx++) {
+		/* add the value into checksum */
+		bTemp += *(prData + bIdx);
+	}
+
+
+	bTemp = 0;
+	/* check if EDID checksume pass */
+	if (bTemp)
+		return FALSE;
+
+	_HdmiSinkAvCap.ui2_edid_chksum_and_audio_sup &=
+		~SINK_EXT_BLK_CHKSUM_ERR;
+
+	/* Step 1: get the offset value of 1st
+	 *detail timing description within extension block
+	 */
+	bOfst = *(prData + EXTEDID_ADDR_OFST_TIME_DSPR);
+	/* Support basic audio */
+	if (*(prData + EDID_ADDR_EXTEND_BYTE3) & 0x40)
+		_HdmiSinkAvCap.ui2_edid_chksum_and_audio_sup &=
+		~SINK_BASIC_AUDIO_NO_SUP;
+
+	/* Max'0528'04, move to here, after read
+	 *0x80 ~ 0xFF because it is 0x83...
+	 */
+	/* receiver support YCbCr 4:4:4 */
+	if (*(prData + EDID_ADDR_EXTEND_BYTE3) & 0x20)
+		_HdmiSinkAvCap.ui2_sink_colorimetry |= SINK_YCBCR_444;
+	/* receiver support YCbCr 4:2:2 */
+	if (*(prData + EDID_ADDR_EXTEND_BYTE3) & 0x10)
+		_HdmiSinkAvCap.ui2_sink_colorimetry |= SINK_YCBCR_422;
+
+	_HdmiSinkAvCap.ui2_sink_colorimetry |= SINK_RGB;
+/* Step 3: read-back the pixel clock of each timing descriptor */
+
+/* Step 4: read-back V active line to define EDID resolution */
+	for (bIdx = 0; bIdx < 6; bIdx++) {
+		if (((bOfst + 18 * bIdx) > 109) ||
+			(*(prData + bOfst + 18 * bIdx) == 0))
+			break;
+
+		ui2HActive =
+		    (unsigned short)(*(prData + bOfst + 18 *
+		    bIdx + OFST_H_ACT_BLA_HI) & 0xf0) << 4;
+		ui2HActive |= *(prData + bOfst + 18 * bIdx +
+			OFST_H_ACTIVE_LO);
+		ui2HBlanking =
+		    (unsigned short)(*(prData + bOfst + 18 *
+		    bIdx + OFST_H_ACT_BLA_HI) & 0x0f) << 8;
+		ui2HBlanking |= *(prData + bOfst + 18 * bIdx +
+			OFST_H_BLANKING_LO);
+		ui2VBlanking =
+		    (unsigned short)(*(prData + bOfst + 18 *
+		    bIdx + OFST_V_ACTIVE_HI) & 0x0f) << 8;
+		ui2VBlanking |= *(prData + bOfst + 18 * bIdx +
+			OFST_V_BLANKING_LO);
+		bTemp = (*(prData + bOfst + 18 * bIdx +
+			OFST_FLAGS) & 0x80) >> 7;
+
+		ui2PixClk = (unsigned short)*(prData+bOfst + 18 *
+			bIdx+OFST_PXL_CLK_LO);
+		ui2PixClk |= ((unsigned short)*(prData+bOfst + 18 *
+			bIdx+OFST_PXL_CLK_HI)) << 8;
+		ui2VActive = (unsigned short)*(prData+bOfst + 18 *
+			bIdx+OFST_V_ACTIVE_LO);
+		ui2VActive |= (unsigned short)(*(prData+bOfst + 18 *
+			bIdx+OFST_V_ACTIVE_HI) & 0xf0) << 4;
+		ui2PixClk = ui2PixClk * 10000;
+		dHtotal = (ui2HActive + ui2HBlanking);
+		dVtotal = (ui2VActive + ui2VBlanking);
+		Vfiq = 1;
+		if (((dHtotal * dVtotal) != 0) && (ui2PixClk != 0))
+			Vfiq = ui2PixClk / (dHtotal * dVtotal);
+		HDMI_EDID_LOG("clk=%d,h=%d,v=%d,vfiq=%d\n",
+			ui2PixClk, dHtotal, dVtotal, Vfiq);
+		vAnalyzeDTD(ui2HActive, ui2HBlanking, Vfiq, bTemp, FALSE);
+	}
+	/* for simplay #7-37, #7-36 */
+	if (*(prData + EXTEDID_ADDR_REVISION) >= 0x03) {
+
+		prCEAaddr = prData + 4;
+		vParserCEADataBlock(prCEAaddr, bOfst - 4);
+	}
+
+	HDMI_EDID_LOG("parsing EDID data ok\n");
+	/* if go here, ie. parsing EDID data ok !! */
+	return TRUE;
+}
+
+void vParserExtEDIDState(unsigned char *prEdid)
+{
+	unsigned char bTemp;
+	unsigned char *prData;
+
+	HDMI_EDID_FUNC();
+
+	if (i4SharedInfo(SI_EDID_PARSING_RESULT) == TRUE) {
+		/* parsing EDID extension block if it exist */
+		for (bTemp = 0; bTemp < i4SharedInfo(SI_EDID_EXT_BLOCK_NO);
+		bTemp++) {
+			if ((EDID_BLOCK_LEN + bTemp * EDID_BLOCK_LEN) <
+				EDID_SIZE) {	/* for Buffer Overflow error */
+				if (*(prEdid + EDID_BLOCK_LEN + bTemp *
+					EDID_BLOCK_LEN) == 0x02) {
+					prData = (prEdid + EDID_BLOCK_LEN +
+						bTemp * EDID_BLOCK_LEN);
+					fgParserExtEDID(prData);
+				} else if (*(prEdid + EDID_BLOCK_LEN +
+				bTemp * EDID_BLOCK_LEN) ==
+					   0xF0) {
+
+				}
+			} else {
+
+			}
+		}
+	}
+}
+
+void hdmi_checkedid(void)
+{
+	unsigned char i;
+	struct mtk_hdmi *hdmi = global_mtk_hdmi;
+
+	HDMI_EDID_FUNC();
+
+	vClearEdidInfo();
+
+	for (i = 0; i < 0x10; i++)
+		_ui4First_16_VIC[i] = 0;
+
+	_ui4First_16_NTSC_VIC = 0;
+	_ui4First_16_PAL_VIC = 0;
+	_u4i_3D_VIC = 0;
+	_HdmiSinkAvCap.b_sink_hdmi_video_present = FALSE;
+	_HdmiSinkAvCap.b_sink_3D_present = FALSE;
+	_HdmiSinkAvCap.ui4_sink_cea_3D_resolution = 0;
+
+	if (hdmi == NULL) {
+		HDMI_EDID_LOG();
+		return;
+	}
+	memcpy(&_bEdidData[0], hdmi->raw_edid.edid, EDID_SIZE);
+	vSetSharedInfo(SI_EDID_EXT_BLOCK_NO, hdmi->raw_edid.blk_num);
+
+	if (fgParserEDID(&_bEdidData[0]) == TRUE) {
+		vSetSharedInfo(SI_EDID_PARSING_RESULT, TRUE);
+		_HdmiSinkAvCap.b_sink_edid_ready = TRUE;
+	}
+
+	/* for Buffer Overflow error */
+	if ((i4SharedInfo(SI_EDID_EXT_BLOCK_NO) *
+		EDID_BLOCK_LEN) < EDID_SIZE)
+		vParserExtEDIDState(&_bEdidData[0]);
+
+}
+
+unsigned char vCheckPcmBitSize(
+	unsigned char ui1ChNumInx)
+{
+	unsigned char ui1Data, u1MaxBit;
+	int i;
+
+	u1MaxBit = PCM_16BIT;
+	for (i = 6; i >= ui1ChNumInx; i--) {
+		ui1Data = _HdmiSinkAvCap.ui1_sink_pcm_bit_size[i];
+
+		if (ui1Data & (1 << PCM_24BIT)) {
+			if (u1MaxBit < PCM_24BIT)
+				u1MaxBit = PCM_24BIT;
+		} else if (ui1Data & (1 << PCM_20BIT)) {
+			if (u1MaxBit < PCM_20BIT)
+				u1MaxBit = PCM_20BIT;
+		}
+	}
+
+	return u1MaxBit;
+}
+
+void vShowEdidInformation(void)
+{
+	unsigned int u4Res = 0;
+	unsigned char bInx = 0;
+	unsigned int maxTMDSRate = 0;
+	unsigned int yuv420Supported = 0;
+
+	HDMI_EDID_FUNC();
+
+	HDMI_EDID_LOG("EDID ver:%d/rev:%d\n",
+		_HdmiSinkAvCap.ui1_Edid_Version,
+		      _HdmiSinkAvCap.ui1_Edid_Revision);
+	HDMI_EDID_LOG("EDID Extend Rev:%d\n",
+		_HdmiSinkAvCap.ui1_ExtEdid_Revision);
+	if (_HdmiSinkAvCap.b_sink_support_hdmi_mode)
+		HDMI_EDID_LOG("SINK Device is HDMI\n");
+	else
+		HDMI_EDID_LOG("SINK Device is DVI\n");
+
+	if (_HdmiSinkAvCap.b_sink_support_hdmi_mode)
+		HDMI_EDID_LOG("CEC ADDRESS:%x\n",
+		_HdmiSinkAvCap.ui2_sink_cec_address);
+
+	HDMI_EDID_LOG("max clock limit : %d\n",
+		_HdmiSinkAvCap.ui1_sink_max_tmds_clock);
+
+	u4Res = (_HdmiSinkAvCap.ui4_sink_cea_ntsc_resolution |
+		 _HdmiSinkAvCap.ui4_sink_dtd_ntsc_resolution |
+		 _HdmiSinkAvCap.ui4_sink_cea_pal_resolution |
+		 _HdmiSinkAvCap.ui4_sink_dtd_pal_resolution);
+
+	if (u4Res & SINK_480I)
+		HDMI_EDID_LOG("SUPPORT 1440x480I 59.94hz\n");
+	if (u4Res & SINK_480I_1440)
+		HDMI_EDID_LOG("SUPPORT 2880x480I 59.94hz\n");
+	if (u4Res & SINK_480P)
+		HDMI_EDID_LOG("SUPPORT 720x480P 59.94hz\n");
+	if (u4Res & SINK_480P_1440)
+		HDMI_EDID_LOG("SUPPORT 1440x480P 59.94hz\n");
+	if (u4Res & SINK_480P_2880)
+		HDMI_EDID_LOG("SUPPORT 2880x480P 59.94hz\n");
+	if (u4Res & SINK_720P60)
+		HDMI_EDID_LOG("SUPPORT 1280x720P 59.94hz\n");
+	if (u4Res & SINK_1080I60)
+		HDMI_EDID_LOG("SUPPORT 1920x1080I 59.94hz\n");
+	if (u4Res & SINK_1080P60)
+		HDMI_EDID_LOG("SUPPORT 1920x1080P 59.94hz\n");
+
+	if (u4Res & SINK_576I)
+		HDMI_EDID_LOG("SUPPORT 1440x576I 50hz\n");
+	if (u4Res & SINK_576I_1440)
+		HDMI_EDID_LOG("SUPPORT 2880x576I 50hz\n");
+	if (u4Res & SINK_576P)
+		HDMI_EDID_LOG("SUPPORT 720x576P 50hz\n");
+	if (u4Res & SINK_576P_1440)
+		HDMI_EDID_LOG("SUPPORT 1440x576P 50hz\n");
+	if (u4Res & SINK_576P_2880)
+		HDMI_EDID_LOG("SUPPORT 2880x576P 50hz\n");
+	if (u4Res & SINK_720P50)
+		HDMI_EDID_LOG("SUPPORT 1280x720P 50hz\n");
+	if (u4Res & SINK_1080I50)
+		HDMI_EDID_LOG("SUPPORT 1920x1080I 50hz\n");
+	if (u4Res & SINK_1080P50)
+		HDMI_EDID_LOG("SUPPORT 1920x1080P 50hz\n");
+	if (u4Res & SINK_1080P30)
+		HDMI_EDID_LOG("SUPPORT 1920x1080P 30hz\n");
+	if (u4Res & SINK_1080P24)
+		HDMI_EDID_LOG("SUPPORT 1920x1080P 24hz\n");
+	if (u4Res & SINK_1080P25)
+		HDMI_EDID_LOG("SUPPORT 1920x1080P 25hz\n");
+
+	u4Res =
+	    (_HdmiSinkAvCap.ui4_sink_native_ntsc_resolution |
+	    _HdmiSinkAvCap.ui4_sink_native_pal_resolution);
+	HDMI_EDID_LOG("NTSC Native =%x\n",
+		_HdmiSinkAvCap.ui4_sink_native_ntsc_resolution);
+	HDMI_EDID_LOG("PAL Native =%x\n",
+		_HdmiSinkAvCap.ui4_sink_native_pal_resolution);
+	if (u4Res & SINK_480I)
+		HDMI_EDID_LOG("Native resolution is 1440x480I 59.94hz\n");
+	if (u4Res & SINK_480I_1440)
+		HDMI_EDID_LOG("Native resolution is 2880x480I 59.94hz\n");
+	if (u4Res & SINK_480P)
+		HDMI_EDID_LOG("Native resolution is 720x480P 59.94hz\n");
+	if (u4Res & SINK_480P_1440)
+		HDMI_EDID_LOG("Native resolution is 1440x480P 59.94hz\n");
+	if (u4Res & SINK_480P_2880)
+		HDMI_EDID_LOG("Native resolution is 2880x480P 59.94hz\n");
+	if (u4Res & SINK_720P60)
+		HDMI_EDID_LOG("Native resolution is 1280x720P 59.94hz\n");
+	if (u4Res & SINK_1080I60)
+		HDMI_EDID_LOG("Native resolution is 1920x1080I 59.94hz\n");
+	if (u4Res & SINK_1080P60)
+		HDMI_EDID_LOG("Native resolution is 1920x1080P 59.94hz\n");
+	if (u4Res & SINK_576I)
+		HDMI_EDID_LOG("Native resolution is 1440x576I 50hz\n");
+	if (u4Res & SINK_576I_1440)
+		HDMI_EDID_LOG("Native resolution is 2880x576I 50hz\n");
+	if (u4Res & SINK_576P)
+		HDMI_EDID_LOG("Native resolution is 720x576P 50hz\n");
+	if (u4Res & SINK_576P_1440)
+		HDMI_EDID_LOG("Native resolution is 1440x576P 50hz\n");
+	if (u4Res & SINK_576P_2880)
+		HDMI_EDID_LOG("Native resolution is 2880x576P 50hz\n");
+	if (u4Res & SINK_720P50)
+		HDMI_EDID_LOG("Native resolution is 1280x720P 50hz\n");
+	if (u4Res & SINK_1080I50)
+		HDMI_EDID_LOG("Native resolution is 1920x1080I 50hz\n");
+	if (u4Res & SINK_1080P50)
+		HDMI_EDID_LOG("Native resolution is 1920x1080P 50hz\n");
+	if (u4Res & SINK_1080P30)
+		HDMI_EDID_LOG("Native resolution is 1920x1080P 30hz\n");
+	if (u4Res & SINK_1080P24)
+		HDMI_EDID_LOG("Native resolution is 1920x1080P 24hz\n");
+	if (u4Res & SINK_1080P25)
+		HDMI_EDID_LOG("Native resolution is 1920x1080P 25hz\n");
+
+	u4Res = _HdmiSinkAvCap.ui4_sink_hdmi_4k2kvic |
+		_HdmiSinkAvCap.ui4_sink_hdmi_4k2kvic_420_vdb;
+	if (u4Res & SINK_2160P_23_976HZ)
+		HDMI_EDID_LOG("4k2k support to SINK_2160P_23_976HZ\n");
+	if (u4Res & SINK_2160P_24HZ)
+		HDMI_EDID_LOG("4k2k support to SINK_2160P_24HZ\n");
+	if (u4Res & SINK_2160P_25HZ)
+		HDMI_EDID_LOG("4k2k support to SINK_2160P_25HZ\n");
+	if (u4Res & SINK_2160P_29_97HZ)
+		HDMI_EDID_LOG("4k2k support to SINK_2160P_29_97HZ\n");
+	if (u4Res & SINK_2160P_30HZ)
+		HDMI_EDID_LOG("4k2k support to SINK_2160P_30HZ\n");
+	if (u4Res & SINK_2161P_24HZ)
+		HDMI_EDID_LOG("4k2k support to SINK_2161P_24HZ\n");
+	/* For HDMI2 modes, TMDS character rate should
+	 *be >= 340 atleast or >=297 for 420modes. However,
+	 *   some HDMI1.x AVRs when providing the combined
+	 *EDID for the AVR and sink incorrectly report
+	 *   support for HDMI2.0 modes indicating 4k@60/50
+	 *modes as available. Check TMDS character rate
+	 *  for the same. If it is not set or < 340, support
+	 *for 4k@60/50 is not there and EDID is
+	 *   incorrectly indicating 4k@60/50 support. Remove
+	 *4k@60/50 support for such cases.
+	 */
+	if (_HdmiSinkAvCap.ui2_sink_max_tmds_character_rate != 0)
+		maxTMDSRate = _HdmiSinkAvCap.ui2_sink_max_tmds_character_rate;
+	else
+		maxTMDSRate = _HdmiSinkAvCap.ui1_sink_max_tmds_clock;
+
+	yuv420Supported = ((_HdmiSinkAvCap.ui2_sink_colorimetry &
+		SINK_YCBCR_420) ||
+		(_HdmiSinkAvCap.ui2_sink_colorimetry &
+		SINK_YCBCR_420_CAPABILITY)) ? 1 : 0;
+	if (((yuv420Supported) && (maxTMDSRate >= 297)) ||
+		(maxTMDSRate >= 340)/* HDMI2 modes*/) {
+		if (u4Res & SINK_2160P_50HZ)
+			HDMI_EDID_LOG("4k2k support to SINK_2160P_50HZ\n");
+		if (u4Res & SINK_2160P_60HZ)
+			HDMI_EDID_LOG("4k2k support to SINK_2160P_60HZ\n");
+		if (u4Res & SINK_2161P_50HZ)
+			HDMI_EDID_LOG("4k2k support to SINK_2161P_50HZ\n");
+		if (u4Res & SINK_2161P_60HZ)
+			HDMI_EDID_LOG("4k2k support to SINK_2161P_60HZ\n");
+	}
+
+	HDMI_EDID_LOG("SUPPORT RGB\n");
+	if (_HdmiSinkAvCap.ui2_sink_colorimetry &
+		SINK_YCBCR_444)
+		HDMI_EDID_LOG("SUPPORT YCBCR 444\n");
+	if (_HdmiSinkAvCap.ui2_sink_colorimetry &
+		SINK_YCBCR_422)
+		HDMI_EDID_LOG("SUPPORT YCBCR 422\n");
+	if (_HdmiSinkAvCap.ui2_sink_colorimetry &
+		SINK_YCBCR_420)
+		HDMI_EDID_LOG("SUPPORT YCBCR ONLY 420, 0x%x\n",
+			      _HdmiSinkAvCap.ui4_sink_hdmi_4k2kvic_420_vdb);
+	if (_HdmiSinkAvCap.ui2_sink_colorimetry &
+		SINK_YCBCR_420_CAPABILITY)
+		HDMI_EDID_LOG(
+		"SUPPORT YCBCR 420 and other colorspace, 0x%x\n",
+		_HdmiSinkAvCap.ui4_sink_hdmi_4k2kvic_420_vdb);
+	if (_HdmiSinkAvCap.ui2_sink_colorimetry &
+		SINK_XV_YCC709)
+		HDMI_EDID_LOG("SUPPORT xvYCC 709\n");
+	if (_HdmiSinkAvCap.ui2_sink_colorimetry &
+		SINK_XV_YCC601)
+		HDMI_EDID_LOG("SUPPORT xvYCC 601\n");
+	if (_HdmiSinkAvCap.ui2_sink_colorimetry &
+		SINK_S_YCC601)
+		HDMI_EDID_LOG("SINK_S_YCC601\n");
+	if (_HdmiSinkAvCap.ui2_sink_colorimetry &
+		SINK_ADOBE_YCC601)
+		HDMI_EDID_LOG("SINK_ADOBE_YCC601\n");
+	if (_HdmiSinkAvCap.ui2_sink_colorimetry &
+		SINK_ADOBE_RGB)
+		HDMI_EDID_LOG("SINK_ADOBE_RGB\n");
+	if (_HdmiSinkAvCap.ui2_sink_colorimetry &
+		SINK_COLOR_SPACE_BT2020_CYCC)
+		HDMI_EDID_LOG("SINK_COLOR_SPACE_BT2020_CYCC\n");
+	if (_HdmiSinkAvCap.ui2_sink_colorimetry &
+		SINK_COLOR_SPACE_BT2020_YCC)
+		HDMI_EDID_LOG("SINK_COLOR_SPACE_BT2020_YCC\n");
+	if (_HdmiSinkAvCap.ui2_sink_colorimetry &
+		SINK_COLOR_SPACE_BT2020_RGB)
+		HDMI_EDID_LOG("SINK_COLOR_SPACE_BT2020_RGB\n");
+	if (_HdmiSinkAvCap.ui2_sink_colorimetry &
+		SINK_METADATA0)
+		HDMI_EDID_LOG("SUPPORT metadata P0\n");
+	if (_HdmiSinkAvCap.ui2_sink_colorimetry &
+		SINK_METADATA1)
+		HDMI_EDID_LOG("SUPPORT metadata P1\n");
+	if (_HdmiSinkAvCap.ui2_sink_colorimetry &
+		SINK_METADATA2)
+		HDMI_EDID_LOG("SUPPORT metadata P2\n");
+
+
+	if (_HdmiSinkAvCap.e_sink_ycbcr_color_bit &
+		HDMI_SINK_DEEP_COLOR_10_BIT)
+		HDMI_EDID_LOG("SUPPORT YCBCR 30 Bits Deep Color\n");
+	if (_HdmiSinkAvCap.e_sink_ycbcr_color_bit &
+		HDMI_SINK_DEEP_COLOR_12_BIT)
+		HDMI_EDID_LOG("SUPPORT YCBCR 36 Bits Deep Color\n");
+	if (_HdmiSinkAvCap.e_sink_ycbcr_color_bit &
+		HDMI_SINK_DEEP_COLOR_16_BIT)
+		HDMI_EDID_LOG("SUPPORT YCBCR 48 Bits Deep Color\n");
+	if (_HdmiSinkAvCap.e_sink_ycbcr_color_bit ==
+		HDMI_SINK_NO_DEEP_COLOR)
+		HDMI_EDID_LOG("Not SUPPORT YCBCR Deep Color\n");
+
+	if (_HdmiSinkAvCap.ui1_sink_dc420_color_bit &
+		HDMI_SINK_DEEP_COLOR_16_BIT)
+		HDMI_EDID_LOG("SUPPORT YCBCR420 48 Bits Deep Color\n");
+	if (_HdmiSinkAvCap.ui1_sink_dc420_color_bit &
+		HDMI_SINK_DEEP_COLOR_12_BIT)
+		HDMI_EDID_LOG("SUPPORT YCBCR420 36 Bits Deep Color\n");
+	if (_HdmiSinkAvCap.ui1_sink_dc420_color_bit &
+		HDMI_SINK_DEEP_COLOR_10_BIT)
+		HDMI_EDID_LOG("SUPPORT YCBCR420 30 Bits Deep Color\n");
+	if (_HdmiSinkAvCap.ui1_sink_dc420_color_bit == HDMI_SINK_NO_DEEP_COLOR)
+		HDMI_EDID_LOG("Not SUPPORT YCBCR420 Deep Color\n");
+
+	if (_HdmiSinkAvCap.e_sink_rgb_color_bit &
+		HDMI_SINK_DEEP_COLOR_10_BIT)
+		HDMI_EDID_LOG("SUPPORT RGB 30 Bits Deep Color\n");
+	if (_HdmiSinkAvCap.e_sink_rgb_color_bit & HDMI_SINK_DEEP_COLOR_12_BIT)
+		HDMI_EDID_LOG("SUPPORT RGB 36 Bits Deep Color\n");
+	if (_HdmiSinkAvCap.e_sink_rgb_color_bit & HDMI_SINK_DEEP_COLOR_16_BIT)
+		HDMI_EDID_LOG("SUPPORT RGB 48 Bits Deep Color\n");
+	if (_HdmiSinkAvCap.e_sink_rgb_color_bit == HDMI_SINK_NO_DEEP_COLOR)
+		HDMI_EDID_LOG("Not SUPPORT RGB Deep Color\n");
+
+	if (_HdmiSinkAvCap.ui2_sink_aud_dec & HDMI_SINK_AUDIO_DEC_LPCM)
+		HDMI_EDID_LOG("SUPPORT LPCM\n");
+	if (_HdmiSinkAvCap.ui2_sink_aud_dec & HDMI_SINK_AUDIO_DEC_AC3)
+		HDMI_EDID_LOG("SUPPORT AC3 Decode\n");
+	if (_HdmiSinkAvCap.ui2_sink_aud_dec & HDMI_SINK_AUDIO_DEC_MPEG1)
+		HDMI_EDID_LOG("SUPPORT MPEG1 Decode\n");
+	if (_HdmiSinkAvCap.ui2_sink_aud_dec & HDMI_SINK_AUDIO_DEC_MP3)
+		HDMI_EDID_LOG("SUPPORT AC3 Decode\n");
+	if (_HdmiSinkAvCap.ui2_sink_aud_dec & HDMI_SINK_AUDIO_DEC_MPEG2)
+		HDMI_EDID_LOG("SUPPORT MPEG2 Decode\n");
+	if (_HdmiSinkAvCap.ui2_sink_aud_dec & HDMI_SINK_AUDIO_DEC_AAC)
+		HDMI_EDID_LOG("SUPPORT AAC Decode\n");
+	if (_HdmiSinkAvCap.ui2_sink_aud_dec & HDMI_SINK_AUDIO_DEC_DTS)
+		HDMI_EDID_LOG("SUPPORT DTS Decode\n");
+	if (_HdmiSinkAvCap.ui2_sink_aud_dec & HDMI_SINK_AUDIO_DEC_ATRAC)
+		HDMI_EDID_LOG("SUPPORT ATRAC Decode\n");
+	if (_HdmiSinkAvCap.ui2_sink_aud_dec & HDMI_SINK_AUDIO_DEC_DSD)
+		HDMI_EDID_LOG("SUPPORT SACD DSD Decode\n");
+	if (_HdmiSinkAvCap.ui2_sink_aud_dec & HDMI_SINK_AUDIO_DEC_DOLBY_PLUS)
+		HDMI_EDID_LOG("SUPPORT Dolby Plus Decode\n");
+	if (_HdmiSinkAvCap.ui2_sink_aud_dec & HDMI_SINK_AUDIO_DEC_DTS_HD)
+		HDMI_EDID_LOG("SUPPORT DTS HD Decode\n");
+	if (_HdmiSinkAvCap.ui2_sink_aud_dec & HDMI_SINK_AUDIO_DEC_MAT_MLP)
+		HDMI_EDID_LOG("SUPPORT MAT MLP Decode\n");
+	if (_HdmiSinkAvCap.ui2_sink_aud_dec & HDMI_SINK_AUDIO_DEC_DST)
+		HDMI_EDID_LOG("SUPPORT SACD DST Decode\n");
+	if ((_HdmiSinkAvCap.ui2_sink_aud_dec & HDMI_SINK_AUDIO_DEC_ATMOS) ||
+		(_HdmiSinkAvCap.ui1_sink_support_dolby_atoms == TRUE))
+		HDMI_EDID_LOG("SUPPORT Dolby ATMOS\n");
+	if (_HdmiSinkAvCap.ui2_sink_aud_dec & HDMI_SINK_AUDIO_DEC_WMA)
+		HDMI_EDID_LOG("SUPPORT  WMA Decode\n");
+
+	if (_HdmiSinkAvCap.ui1_sink_pcm_ch_sampling[0] != 0) {
+
+		for (bInx = 0; bInx < 50; bInx++) {
+			memcpy(&cDstStr[0 + bInx], " ", 1);
+			if (bInx < 21)
+				memcpy(&cDstBitStr[0 + bInx], " ", 1);
+		}
+
+		for (bInx = 0; bInx < 7; bInx++) {
+			if ((_HdmiSinkAvCap.ui1_sink_pcm_ch_sampling[0] >>
+				bInx) &
+				0x01)
+				memcpy(&cDstStr[0 + bInx * 7],
+				&_cFsStr[bInx][0], 7);
+		}
+		for (bInx = 0; bInx < 3; bInx++) {
+			if ((_HdmiSinkAvCap.ui1_sink_pcm_bit_size[0] >>
+				bInx) &
+				0x01)
+				memcpy(&cDstBitStr[0 + bInx * 7],
+				&_cBitdeepStr[bInx][0], 7);
+		}
+		HDMI_EDID_LOG("SUPPORT PCM Max 2CH, Fs is: %s\n",
+			&cDstStr[0]);
+
+	}
+
+	if (_HdmiSinkAvCap.ui1_sink_pcm_ch_sampling[4] != 0) {
+
+		for (bInx = 0; bInx < 50; bInx++) {
+			memcpy(&cDstStr[0 + bInx], " ", 1);
+			if (bInx < 21)
+				memcpy(&cDstBitStr[0 + bInx], " ", 1);
+		}
+
+		for (bInx = 0; bInx < 7; bInx++) {
+			if ((_HdmiSinkAvCap.ui1_sink_pcm_ch_sampling[4] >>
+				bInx) &
+				0x01)
+				memcpy(&cDstStr[0 + bInx * 7],
+				&_cFsStr[bInx][0], 7);
+		}
+		for (bInx = 0; bInx < 3; bInx++) {
+			if ((_HdmiSinkAvCap.ui1_sink_pcm_bit_size[4] >>
+				bInx) & 0x01)
+				memcpy(&cDstBitStr[0 + bInx * 7],
+				&_cBitdeepStr[bInx][0], 7);
+		}
+		HDMI_EDID_LOG(
+		"[HDMI]SUPPORT PCM Max 6CH, Fs is: %s; bitdeep is: %s\n",
+			&cDstStr[0], &cDstBitStr[0]);
+	}
+
+	if (_HdmiSinkAvCap.ui1_sink_pcm_ch_sampling[5] != 0) {
+
+		for (bInx = 0; bInx < 50; bInx++) {
+			memcpy(&cDstStr[0 + bInx], " ", 1);
+			if (bInx < 21)
+				memcpy(&cDstBitStr[0 + bInx], " ", 1);
+		}
+
+		for (bInx = 0; bInx < 7; bInx++) {
+			if ((_HdmiSinkAvCap.ui1_sink_pcm_ch_sampling[5] >>
+				bInx) &
+				0x01)
+				memcpy(&cDstStr[0 + bInx * 7],
+				&_cFsStr[bInx][0], 7);
+		}
+		for (bInx = 0; bInx < 3; bInx++) {
+			if ((_HdmiSinkAvCap.ui1_sink_pcm_bit_size[5] >> bInx) &
+				0x01)
+				memcpy(&cDstBitStr[0 + bInx * 7],
+				&_cBitdeepStr[bInx][0], 7);
+		}
+		HDMI_EDID_LOG(
+		"[HDMI]SUPPORT PCM Max 7CH, Fs is: %s; bitdeep is: %s\n",
+			&cDstStr[0], &cDstBitStr[0]);
+	}
+
+	if (_HdmiSinkAvCap.ui1_sink_pcm_ch_sampling[6] != 0) {
+
+		for (bInx = 0; bInx < 50; bInx++) {
+			memcpy(&cDstStr[0 + bInx], " ", 1);
+			if (bInx < 21)
+				memcpy(&cDstBitStr[0 + bInx], " ", 1);
+		}
+
+		for (bInx = 0; bInx < 7; bInx++) {
+			if ((_HdmiSinkAvCap.ui1_sink_pcm_ch_sampling[6] >>
+				bInx) &
+				0x01)
+				memcpy(&cDstStr[0 + bInx * 7],
+				&_cFsStr[bInx][0], 7);
+		}
+		for (bInx = 0; bInx < 3; bInx++) {
+			if ((_HdmiSinkAvCap.ui1_sink_pcm_bit_size[6] >> bInx)
+				& 0x01)
+				memcpy(&cDstBitStr[0 + bInx * 7],
+				&_cBitdeepStr[bInx][0], 7);
+		}
+		HDMI_EDID_LOG(
+		"[HDMI]SUPPORT PCM Max 8CH, FS is: %s; bitdeep is: %s\n",
+			&cDstStr[0], &cDstBitStr[0]);
+	}
+
+	if (_HdmiSinkAvCap.ui1_sink_ac3_ch_sampling[0] != 0) {
+
+		for (bInx = 0; bInx < 50; bInx++)
+			memcpy(&cDstStr[0 + bInx], " ", 1);
+
+
+		for (bInx = 0; bInx < 7; bInx++) {
+			if ((_HdmiSinkAvCap.ui1_sink_ac3_ch_sampling[0] >>
+				bInx) &
+				0x01)
+				memcpy(&cDstStr[0 + bInx * 7],
+				&_cFsStr[bInx][0], 7);
+		}
+		HDMI_EDID_LOG("SUPPORT AC3 Max 2CH, Fs is: %s\n",
+			&cDstStr[0]);
+
+	}
+
+	if (_HdmiSinkAvCap.ui1_sink_ac3_ch_sampling[4] != 0) {
+
+		for (bInx = 0; bInx < 50; bInx++)
+			memcpy(&cDstStr[0 + bInx], " ", 1);
+
+		for (bInx = 0; bInx < 7; bInx++) {
+			if ((_HdmiSinkAvCap.ui1_sink_ac3_ch_sampling[4] >>
+				bInx) &
+				0x01)
+				memcpy(&cDstStr[0 + bInx * 7],
+				&_cFsStr[bInx][0], 7);
+		}
+		HDMI_EDID_LOG("SUPPORT AC3 Max 6CH, Fs is: %s\n",
+			&cDstStr[0]);
+
+	}
+
+	if (_HdmiSinkAvCap.ui1_sink_ac3_ch_sampling[5] != 0) {
+
+		for (bInx = 0; bInx < 50; bInx++)
+			memcpy(&cDstStr[0 + bInx], " ", 1);
+
+		for (bInx = 0; bInx < 7; bInx++) {
+			if ((_HdmiSinkAvCap.ui1_sink_ac3_ch_sampling[5] >>
+				bInx) &
+				0x01)
+				memcpy(&cDstStr[0 + bInx * 7],
+				&_cFsStr[bInx][0],
+				7);
+		}
+		HDMI_EDID_LOG("SUPPORT AC3 Max 7CH, Fs is: %s\n",
+			&cDstStr[0]);
+
+	}
+
+	if (_HdmiSinkAvCap.ui1_sink_ac3_ch_sampling[6] != 0) {
+
+		for (bInx = 0; bInx < 50; bInx++)
+			memcpy(&cDstStr[0 + bInx], " ", 1);
+
+		for (bInx = 0; bInx < 7; bInx++) {
+			if ((_HdmiSinkAvCap.ui1_sink_ac3_ch_sampling[6] >>
+				bInx) &
+				0x01)
+				memcpy(&cDstStr[0 + bInx * 7],
+				&_cFsStr[bInx][0], 7);
+		}
+		HDMI_EDID_LOG("SUPPORT AC3 Max 8CH, FS is: %s\n",
+			&cDstStr[0]);
+
+	}
+
+	if (_HdmiSinkAvCap.ui1_sink_ec3_ch_sampling[0] != 0) {
+
+		for (bInx = 0; bInx < 50; bInx++)
+			memcpy(&cDstStr[0 + bInx], " ", 1);
+
+
+		for (bInx = 0; bInx < 7; bInx++) {
+			if ((_HdmiSinkAvCap.ui1_sink_ec3_ch_sampling[0] >>
+				bInx) &
+				0x01)
+				memcpy(&cDstStr[0 + bInx * 7],
+				&_cFsStr[bInx][0], 7);
+		}
+		HDMI_EDID_LOG("SUPPORT E-AC3 Max 2CH, Fs is: %s\n",
+			&cDstStr[0]);
+
+	}
+
+	if (_HdmiSinkAvCap.ui1_sink_ec3_ch_sampling[4] != 0) {
+
+		for (bInx = 0; bInx < 50; bInx++)
+			memcpy(&cDstStr[0 + bInx], " ", 1);
+
+		for (bInx = 0; bInx < 7; bInx++) {
+			if ((_HdmiSinkAvCap.ui1_sink_ec3_ch_sampling[4] >>
+				bInx) &
+				0x01)
+				memcpy(&cDstStr[0 + bInx * 7],
+				&_cFsStr[bInx][0], 7);
+		}
+		HDMI_EDID_LOG("SUPPORT E-AC3 Max 6CH, Fs is: %s\n",
+			&cDstStr[0]);
+
+	}
+
+	if (_HdmiSinkAvCap.ui1_sink_ec3_ch_sampling[5] != 0) {
+
+		for (bInx = 0; bInx < 50; bInx++)
+			memcpy(&cDstStr[0 + bInx], " ", 1);
+
+		for (bInx = 0; bInx < 7; bInx++) {
+			if ((_HdmiSinkAvCap.ui1_sink_ec3_ch_sampling[5] >>
+				bInx) &
+				0x01)
+				memcpy(&cDstStr[0 + bInx * 7],
+				&_cFsStr[bInx][0], 7);
+		}
+		HDMI_EDID_LOG("SUPPORT E-AC3 Max 7CH, Fs is: %s\n",
+			&cDstStr[0]);
+
+	}
+
+	if (_HdmiSinkAvCap.ui1_sink_ec3_ch_sampling[6] != 0) {
+
+		for (bInx = 0; bInx < 50; bInx++)
+			memcpy(&cDstStr[0 + bInx], " ", 1);
+
+		for (bInx = 0; bInx < 7; bInx++) {
+			if ((_HdmiSinkAvCap.ui1_sink_ec3_ch_sampling[6] >>
+				bInx) & 0x01)
+				memcpy(&cDstStr[0 + bInx * 7],
+				&_cFsStr[bInx][0], 7);
+		}
+		HDMI_EDID_LOG("SUPPORT E-AC3 Max 8CH, FS is: %s\n",
+			&cDstStr[0]);
+
+	}
+
+	if (_HdmiSinkAvCap.ui1_sink_dts_ch_sampling[0] != 0) {
+
+		for (bInx = 0; bInx < 50; bInx++)
+			memcpy(&cDstStr[0 + bInx], " ", 1);
+
+
+		for (bInx = 0; bInx < 7; bInx++) {
+			if ((_HdmiSinkAvCap.ui1_sink_dts_ch_sampling[0] >>
+				bInx) & 0x01)
+				memcpy(&cDstStr[0 + bInx * 7],
+				&_cFsStr[bInx][0], 7);
+		}
+		HDMI_EDID_LOG("[HDMI]SUPPORT DTS Max 2CH, Fs is: %s\n",
+			&cDstStr[0]);
+
+	}
+
+	if (_HdmiSinkAvCap.ui1_sink_dts_ch_sampling[4] != 0) {
+
+		for (bInx = 0; bInx < 50; bInx++)
+			memcpy(&cDstStr[0 + bInx], " ", 1);
+
+		for (bInx = 0; bInx < 7; bInx++) {
+			if ((_HdmiSinkAvCap.ui1_sink_dts_ch_sampling[4] >>
+				bInx) & 0x01)
+				memcpy(&cDstStr[0 + bInx * 7],
+				&_cFsStr[bInx][0], 7);
+		}
+		HDMI_EDID_LOG(
+			"[HDMI]SUPPORT dts Max 6CH, Fs is: %s\n",
+			&cDstStr[0]);
+
+	}
+
+	if (_HdmiSinkAvCap.ui1_sink_dts_ch_sampling[5] != 0) {
+
+		for (bInx = 0; bInx < 50; bInx++)
+			memcpy(&cDstStr[0 + bInx], " ", 1);
+
+		for (bInx = 0; bInx < 7; bInx++) {
+			if ((_HdmiSinkAvCap.ui1_sink_dts_ch_sampling[5] >>
+				bInx) & 0x01)
+				memcpy(&cDstStr[0 + bInx * 7],
+				&_cFsStr[bInx][0], 7);
+		}
+		HDMI_EDID_LOG(
+			"[HDMI]SUPPORT dts Max 7CH, Fs is: %s\n",
+			&cDstStr[0]);
+
+	}
+
+	if (_HdmiSinkAvCap.ui1_sink_dts_ch_sampling[6] != 0) {
+
+		for (bInx = 0; bInx < 50; bInx++)
+			memcpy(&cDstStr[0 + bInx], " ", 1);
+
+		for (bInx = 0; bInx < 7; bInx++) {
+			if ((_HdmiSinkAvCap.ui1_sink_dts_ch_sampling[6] >>
+				bInx) & 0x01)
+				memcpy(&cDstStr[0 + bInx * 7],
+				&_cFsStr[bInx][0], 7);
+		}
+		HDMI_EDID_LOG(
+			"[HDMI]SUPPORT dts Max 8CH, FS is: %s\n",
+			&cDstStr[0]);
+
+	}
+
+	if (_HdmiSinkAvCap.ui1_sink_dts_hd_ch_sampling[0] != 0) {
+
+		for (bInx = 0; bInx < 50; bInx++)
+			memcpy(&cDstStr[0 + bInx], " ", 1);
+
+
+		for (bInx = 0; bInx < 7; bInx++) {
+			if ((_HdmiSinkAvCap.ui1_sink_dts_hd_ch_sampling[0] >>
+				bInx) & 0x01)
+				memcpy(&cDstStr[0 + bInx * 7],
+				&_cFsStr[bInx][0], 7);
+		}
+		HDMI_EDID_LOG("[HDMI]SUPPORT DTS HD Max 2CH, Fs is: %s\n",
+			&cDstStr[0]);
+
+	}
+
+	if (_HdmiSinkAvCap.ui1_sink_dts_hd_ch_sampling[4] != 0) {
+
+		for (bInx = 0; bInx < 50; bInx++)
+			memcpy(&cDstStr[0 + bInx], " ", 1);
+
+		for (bInx = 0; bInx < 7; bInx++) {
+			if ((_HdmiSinkAvCap.ui1_sink_dts_hd_ch_sampling[4] >>
+				bInx) & 0x01)
+				memcpy(&cDstStr[0 + bInx * 7],
+				&_cFsStr[bInx][0], 7);
+		}
+		HDMI_EDID_LOG("[HDMI]SUPPORT DTS HD Max 6CH, Fs is: %s\n",
+			&cDstStr[0]);
+
+	}
+
+	if (_HdmiSinkAvCap.ui1_sink_dts_hd_ch_sampling[5] != 0) {
+
+		for (bInx = 0; bInx < 50; bInx++)
+			memcpy(&cDstStr[0 + bInx], " ", 1);
+
+		for (bInx = 0; bInx < 7; bInx++) {
+			if ((_HdmiSinkAvCap.ui1_sink_dts_hd_ch_sampling[5] >>
+				bInx) & 0x01)
+				memcpy(&cDstStr[0 + bInx * 7],
+				&_cFsStr[bInx][0], 7);
+		}
+		HDMI_EDID_LOG(
+			"[HDMI]SUPPORT DTS HD Max 7CH, Fs is: %s\n",
+			&cDstStr[0]);
+
+	}
+
+	if (_HdmiSinkAvCap.ui1_sink_dts_hd_ch_sampling[6] != 0) {
+
+		for (bInx = 0; bInx < 50; bInx++)
+			memcpy(&cDstStr[0 + bInx], " ", 1);
+
+		for (bInx = 0; bInx < 7; bInx++) {
+			if ((_HdmiSinkAvCap.ui1_sink_dts_hd_ch_sampling[6] >>
+				bInx) & 0x01)
+				memcpy(&cDstStr[0 + bInx * 7],
+				&_cFsStr[bInx][0], 7);
+		}
+		HDMI_EDID_LOG(
+		"[HDMI]SUPPORT DTS HD Max 8CH, FS is: %s\n",
+			&cDstStr[0]);
+
+	}
+
+	if (_HdmiSinkAvCap.ui1_sink_spk_allocation &
+		SINK_AUDIO_FL_FR)
+		HDMI_EDID_LOG("Speaker FL/FR allocated\n");
+	if (_HdmiSinkAvCap.ui1_sink_spk_allocation &
+		SINK_AUDIO_LFE)
+		HDMI_EDID_LOG("Speaker LFE allocated\n");
+	if (_HdmiSinkAvCap.ui1_sink_spk_allocation &
+		SINK_AUDIO_FC)
+		HDMI_EDID_LOG("Speaker FC allocated\n");
+	if (_HdmiSinkAvCap.ui1_sink_spk_allocation &
+		SINK_AUDIO_RL_RR)
+		HDMI_EDID_LOG("Speaker RL/RR allocated\n");
+	if (_HdmiSinkAvCap.ui1_sink_spk_allocation &
+		SINK_AUDIO_RC)
+		HDMI_EDID_LOG("Speaker RC allocated\n");
+	if (_HdmiSinkAvCap.ui1_sink_spk_allocation &
+		SINK_AUDIO_FLC_FRC)
+		HDMI_EDID_LOG("Speaker FLC/FRC allocated\n");
+	if (_HdmiSinkAvCap.ui1_sink_spk_allocation &
+		SINK_AUDIO_RLC_RRC)
+		HDMI_EDID_LOG("Speaker RLC/RRC allocated\n");
+
+	HDMI_EDID_LOG("HDMI edid support content type =%x\n",
+		      _HdmiSinkAvCap.ui1_sink_content_cnc);
+	HDMI_EDID_LOG("Lip Sync Progressive audio latency = %d\n",
+		      _HdmiSinkAvCap.ui1_sink_p_audio_latency);
+	HDMI_EDID_LOG("Lip Sync Progressive video latency = %d\n",
+		      _HdmiSinkAvCap.ui1_sink_p_video_latency);
+	if (_HdmiSinkAvCap.ui1_sink_i_latency_present) {
+		HDMI_EDID_LOG("Lip Sync Interlace audio latency = %d\n",
+			      _HdmiSinkAvCap.ui1_sink_i_audio_latency);
+		HDMI_EDID_LOG("Lip Sync Interlace video latency = %d\n",
+			      _HdmiSinkAvCap.ui1_sink_i_video_latency);
+	}
+
+	if (_HdmiSinkAvCap.ui1_sink_support_ai == 1)
+		HDMI_EDID_LOG("Support AI\n");
+	else
+		HDMI_EDID_LOG("Not Support AI\n");
+
+	HDMI_EDID_LOG("Monitor Max horizontal size = %d\n",
+		      _HdmiSinkAvCap.ui1_Display_Horizontal_Size);
+	HDMI_EDID_LOG("Monitor Max vertical size = %d\n",
+		      _HdmiSinkAvCap.ui1_Display_Vertical_Size);
+
+
+	if (_HdmiSinkAvCap.b_sink_hdmi_video_present == TRUE)
+		HDMI_EDID_LOG("HDMI_Video_Present\n");
+	else
+		HDMI_EDID_LOG("No HDMI_Video_Present\n");
+
+	if (_HdmiSinkAvCap.b_sink_3D_present == TRUE)
+		HDMI_EDID_LOG("3D_present\n");
+	else
+		HDMI_EDID_LOG("No 3D_present\n");
+
+	if (_HdmiSinkAvCap.b_sink_SCDC_present == TRUE)
+		HDMI_EDID_LOG("HDMI_SCDC_Present\n");
+
+	if (_HdmiSinkAvCap.b_sink_LTE_340M_sramble == TRUE)
+		HDMI_EDID_LOG("LTE_340M_sramble\n");
+
+	if (_HdmiSinkAvCap.ui1_sink_hf_vsdb_info &
+		EDID_HF_VSDB_SCDC_PRESENT)
+		HDMI_EDID_LOG("EDID_HF_VSDB_SCDC_PRESENT EXIST\n");
+	if (_HdmiSinkAvCap.ui1_sink_hf_vsdb_info &
+		EDID_HF_VSDB_RR_CAPABLE)
+		HDMI_EDID_LOG("EDID_HF_VSDB_RR_CAPABLE EXIST\n");
+	if (_HdmiSinkAvCap.ui1_sink_hf_vsdb_info &
+		EDID_HF_VSDB_LTE_340MCSC_SCRAMBLE)
+		HDMI_EDID_LOG("EDID_HF_VSDB_LTE_340MCSC_SCRAMBLE EXIST\n");
+	if (_HdmiSinkAvCap.ui1_sink_hf_vsdb_info &
+		EDID_HF_VSDB_INDEPENDENT_VIEW)
+		HDMI_EDID_LOG("EDID_HF_VSDB_INDEPENDENT_VIEW EXIST\n");
+	if (_HdmiSinkAvCap.ui1_sink_hf_vsdb_info &
+		EDID_HF_VSDB_DUAL_VIEW)
+		HDMI_EDID_LOG("EDID_HF_VSDB_DUAL_VIEW EXIST\n");
+	if (_HdmiSinkAvCap.ui1_sink_hf_vsdb_info &
+		EDID_HF_VSDB_3D_OSD_DISPARITY)
+		HDMI_EDID_LOG("EDID_HF_VSDB_3D_OSD_DISPARITY EXIST\n");
+	if (_HdmiSinkAvCap.ui1_sink_support_dynamic_hdr &
+		EDID_SUPPORT_PHILIPS_HDR)
+		HDMI_EDID_LOG("EDID_SUPPORT_PHILIPS_HDR\n");
+	if (_HdmiSinkAvCap.ui1_sink_support_dynamic_hdr &
+		EDID_SUPPORT_DOLBY_HDR)
+		HDMI_EDID_LOG(
+		"EDID_SUPPORT_DOLBY_HDR(Dolby HDR Enable Bit)\n");
+	if (_HdmiSinkAvCap.ui1_sink_support_dynamic_hdr &
+		EDID_SUPPORT_YUV422_12BIT)
+		HDMI_EDID_LOG("EDID_SUPPORT_YUV422_12BIT\n");
+	if (_HdmiSinkAvCap.ui1_sink_support_dynamic_hdr &
+		EDID_SUPPORT_DOLBY_HDR_2160P60)
+		HDMI_EDID_LOG("EDID_SUPPORT_DOLBY_HDR_2160P60\n");
+	if (!(_HdmiSinkAvCap.ui1_sink_support_dynamic_hdr &
+		EDID_SUPPORT_DOLBY_HDR_2160P60) &&
+		(_HdmiSinkAvCap.ui1_sink_support_dynamic_hdr &
+		EDID_SUPPORT_DOLBY_HDR))
+		HDMI_EDID_LOG(
+	"[HDMI TX]Dolby enable and Dolby 2160P60 disable, max Dolby 2160P30\n");
+	if (_HdmiSinkAvCap.ui1_sink_support_dynamic_hdr &
+		EDID_SUPPORT_HDR10_PLUS)
+		HDMI_EDID_LOG("EDID_SUPPORT_HDR10_PLUS\n");
+	if (_HdmiSinkAvCap.ui1_sink_hdr10plus_app_version)
+		HDMI_EDID_LOG("ui1_sink_hdr10plus_app_version=0x%x\n",
+		_HdmiSinkAvCap.ui1_sink_hdr10plus_app_version);
+	if (_HdmiSinkAvCap.ui1_sink_support_static_hdr &
+		EDID_SUPPORT_SDR)
+		HDMI_EDID_LOG("EDID_SUPPORT_SDR\n");
+	if (_HdmiSinkAvCap.ui1_sink_support_static_hdr &
+		EDID_SUPPORT_HDR)
+		HDMI_EDID_LOG("EDID_SUPPORT_HDR\n");
+	if (_HdmiSinkAvCap.ui1_sink_support_static_hdr &
+		EDID_SUPPORT_SMPTE_ST_2084)
+		HDMI_EDID_LOG(
+	"EDID_SUPPORT_SMPTE_ST_2084(HDR10 Enable Bit)\n");
+	if (_HdmiSinkAvCap.ui1_sink_support_static_hdr &
+		EDID_SUPPORT_FUTURE_EOTF)
+		HDMI_EDID_LOG("EDID_SUPPORT_FUTURE_EOTF\n");
+	if (_HdmiSinkAvCap.ui1_sink_support_static_hdr &
+		EDID_SUPPORT_ET_4)
+		HDMI_EDID_LOG("EDID_SUPPORT_ET_4\n");
+	if (_HdmiSinkAvCap.ui1_sink_support_static_hdr &
+		EDID_SUPPORT_ET_5)
+		HDMI_EDID_LOG("EDID_SUPPORT_ET_5\n");
+
+	HDMI_EDID_LOG(
+	"ui1_sink_hdr_content_max_luminance = 0x%x\n",
+		_HdmiSinkAvCap.ui1_sink_hdr_content_max_luminance);
+	HDMI_EDID_LOG(
+	"ui1_sink_hdr_content_max_frame_average_luminance = 0x%x\n",
+_HdmiSinkAvCap.ui1_sink_hdr_content_max_frame_average_luminance);
+	HDMI_EDID_LOG(
+	"ui1_sink_hdr_content_min_luminance = 0x%x\n",
+		_HdmiSinkAvCap.ui1_sink_hdr_content_min_luminance);
+
+	HDMI_EDID_LOG(
+	"HDR block=0x%x;0x%x;0x%x;0x%x;0x%x;0x%x;0x%x\n",
+		_HdmiSinkAvCap.ui1_sink_hdr_block[0],
+		_HdmiSinkAvCap.ui1_sink_hdr_block[1],
+		_HdmiSinkAvCap.ui1_sink_hdr_block[2],
+		_HdmiSinkAvCap.ui1_sink_hdr_block[3],
+		_HdmiSinkAvCap.ui1_sink_hdr_block[4],
+		_HdmiSinkAvCap.ui1_sink_hdr_block[5],
+		_HdmiSinkAvCap.ui1_sink_hdr_block[6]);
+	HDMI_EDID_LOG(
+	"HFVSDB block=0x%x;0x%x;0x%x;0x%x;0x%x;0x%x;0x%x;0x%x\n",
+		_HdmiSinkAvCap.ui1_sink_hfvsdb_block[0],
+		_HdmiSinkAvCap.ui1_sink_hfvsdb_block[1],
+		_HdmiSinkAvCap.ui1_sink_hfvsdb_block[2],
+		_HdmiSinkAvCap.ui1_sink_hfvsdb_block[3],
+		_HdmiSinkAvCap.ui1_sink_hfvsdb_block[4],
+		_HdmiSinkAvCap.ui1_sink_hfvsdb_block[5],
+		_HdmiSinkAvCap.ui1_sink_hfvsdb_block[6],
+		_HdmiSinkAvCap.ui1_sink_hfvsdb_block[7]);
+
+	HDMI_EDID_LOG(
+		"[HDMI TX]ui2_sink_max_tmds_character_rate = 0x%x\n",
+		_HdmiSinkAvCap.ui2_sink_max_tmds_character_rate);
+	HDMI_EDID_LOG("[HDMI TX]ui1_sink_hf_vsdb_info = 0x%x\n",
+		_HdmiSinkAvCap.ui1_sink_hf_vsdb_info);
+}
+
+long long hdmi_DispGetEdidInfo(void)
+{
+	long long u4Resolution = 0x0;
+	long long u4Res = 0x0;
+	unsigned int maxTMDSRate = 0;
+	unsigned int yuv420Supported = 0;
+
+	HDMI_EDID_FUNC();
+
+	u4Res = (_HdmiSinkAvCap.ui4_sink_cea_ntsc_resolution |
+		 _HdmiSinkAvCap.ui4_sink_dtd_ntsc_resolution |
+		 _HdmiSinkAvCap.ui4_sink_cea_pal_resolution |
+		 _HdmiSinkAvCap.ui4_sink_dtd_pal_resolution);
+
+	if (u4Res & (SINK_480I | SINK_480I_1440 | SINK_480I_2880 |
+		SINK_480I_4_3))
+		u4Resolution |= RES_480i_60;
+	if (u4Res & (SINK_576I | SINK_576I_1440 | SINK_576I_2880 |
+		SINK_576I_4_3))
+		u4Resolution |= RES_576i_50;
+	if (u4Res & (SINK_576I | SINK_576I_1440 | SINK_576I_2880 |
+		SINK_576I_4_3))
+		u4Resolution |= RES_576i_50;
+	if (u4Res & (SINK_480P | SINK_480P_1440 | SINK_480P_2880 |
+		SINK_480P_2880_4_3 | SINK_480P_4_3))
+		u4Resolution |= RES_480p_60;
+	if (u4Res & (SINK_576P | SINK_576P_1440 | SINK_576P_2880 |
+		SINK_576P_2880_4_3 | SINK_576P_4_3))
+		u4Resolution |= RES_576p_50;
+	if (u4Res & SINK_720P60)
+		u4Resolution |= (RES_720p_60 | RES_720P_59_94);
+	if (u4Res & SINK_720P50)
+		u4Resolution |= RES_720p_50;
+	if (u4Res & SINK_1080I60)
+		u4Resolution |= RES_1080i_60;
+	if (u4Res & SINK_1080I50)
+		u4Resolution |= RES_1080i_50;
+	if (u4Res & SINK_1080P30)
+		u4Resolution |= RES_1080p_30;
+	if (u4Res & SINK_1080P2997)
+		u4Resolution |= RES_1080p_29;
+	if (u4Res & SINK_1080P25)
+		u4Resolution |= RES_1080p_25;
+	if (u4Res & SINK_1080P24)
+		u4Resolution |= RES_1080p_24;
+	if (u4Res & SINK_1080P23976)
+		u4Resolution |= RES_1080p_23;
+	if (u4Res & SINK_1080P60)
+		u4Resolution |= (RES_1080p_60 | RES_1080P_59_94);
+	if (u4Res & SINK_1080P50)
+		u4Resolution |= RES_1080p_50;
+
+	HDMI_EDID_LOG(
+	"%s u4Res = 0x%llx\n", __func__,
+	u4Res);
+
+	u4Res = _HdmiSinkAvCap.ui4_sink_hdmi_4k2kvic |
+		_HdmiSinkAvCap.ui4_sink_hdmi_4k2kvic_420_vdb;
+
+	if (u4Res & SINK_2160P_23_976HZ)
+		u4Resolution |= RES_2160P_23_976;
+	if (u4Res & SINK_2160P_24HZ)
+		u4Resolution |= RES_2160P_24;
+	if (u4Res & SINK_2160P_25HZ)
+		u4Resolution |= RES_2160P_25;
+	if (u4Res & SINK_2160P_29_97HZ)
+		u4Resolution |= RES_2160P_29_97;
+	if (u4Res & SINK_2160P_30HZ)
+		u4Resolution |= RES_2160P_30;
+	if (u4Res & SINK_2161P_24HZ)
+		u4Resolution |= RES_2161P_24;
+
+	/* For HDMI2 modes, TMDS character rate should
+	 *be >= 340 atleast or >=297 for 420modes. However,
+	 * some HDMI1.x AVRs when providing the combined
+	 *EDID for the AVR and sink incorrectly report
+	 * support for HDMI2.0 modes indicating 4k@60/50
+	 *modes as available. Check TMDS character rate
+	 * for the same. If it is not set or < 340, support
+	 *for 4k@60/50 is not there and EDID is
+	 * incorrectly indicating 4k@60/50 support.
+	 *Remove 4k@60/50 support for such cases.
+	 */
+	if (_HdmiSinkAvCap.ui2_sink_max_tmds_character_rate != 0)
+		maxTMDSRate = _HdmiSinkAvCap.ui2_sink_max_tmds_character_rate;
+	else
+		maxTMDSRate = _HdmiSinkAvCap.ui1_sink_max_tmds_clock;
+
+	yuv420Supported = ((_HdmiSinkAvCap.ui2_sink_colorimetry &
+		SINK_YCBCR_420) ||
+		(_HdmiSinkAvCap.ui2_sink_colorimetry &
+		SINK_YCBCR_420_CAPABILITY)) ? 1 : 0;
+	if (((yuv420Supported) && (maxTMDSRate >= 297)) ||
+		(maxTMDSRate >= 340)/* HDMI2 modes*/) {
+		if (u4Res & SINK_2160P_60HZ)
+			u4Resolution |= (RES_2160P_60 | RES_2160P_59_94);
+		if (u4Res & SINK_2160P_50HZ)
+			u4Resolution |= RES_2160P_50;
+		if (u4Res & SINK_2161P_60HZ)
+			u4Resolution |= (RES_2161P_60 |
+				RES_2161P_59_94);
+		if (u4Res & SINK_2161P_50HZ)
+			u4Resolution |=
+				RES_2161P_50;
+	} else {
+		HDMI_EDID_LOG("4k@60/50 modes are not supported\n");
+	}
+	return u4Resolution;
+}
+
+void hdmi_AppGetEdidInfo(
+	struct HDMI_EDID_T *pv_get_info)
+{
+	unsigned int i;
+	long long u4Res = 0x0;
+	unsigned int maxTMDSRate = 0;
+	unsigned int yuv420Supported = 0;
+
+	HDMI_EDID_FUNC();
+
+	pv_get_info->ui4_ntsc_resolution =
+	    (_HdmiSinkAvCap.ui4_sink_cea_ntsc_resolution |
+	    _HdmiSinkAvCap.ui4_sink_dtd_ntsc_resolution);
+	pv_get_info->ui4_pal_resolution =
+	    (_HdmiSinkAvCap.ui4_sink_cea_pal_resolution |
+	    _HdmiSinkAvCap.ui4_sink_dtd_pal_resolution);
+	pv_get_info->ui4_sink_native_ntsc_resolution =
+	    _HdmiSinkAvCap.ui4_sink_native_ntsc_resolution;
+	pv_get_info->ui4_sink_native_pal_resolution =
+		_HdmiSinkAvCap.ui4_sink_native_pal_resolution;
+	pv_get_info->ui4_sink_cea_ntsc_resolution =
+		_HdmiSinkAvCap.ui4_sink_cea_ntsc_resolution;
+	pv_get_info->ui4_sink_cea_pal_resolution =
+		_HdmiSinkAvCap.ui4_sink_cea_pal_resolution;
+	pv_get_info->ui4_sink_dtd_ntsc_resolution =
+		_HdmiSinkAvCap.ui4_sink_dtd_ntsc_resolution;
+	pv_get_info->ui4_sink_dtd_pal_resolution =
+		_HdmiSinkAvCap.ui4_sink_dtd_pal_resolution;
+	pv_get_info->ui4_sink_1st_dtd_ntsc_resolution =
+	    _HdmiSinkAvCap.ui4_sink_1st_dtd_ntsc_resolution;
+	pv_get_info->ui4_sink_1st_dtd_pal_resolution =
+	    _HdmiSinkAvCap.ui4_sink_1st_dtd_pal_resolution;
+	pv_get_info->ui2_sink_colorimetry =
+		_HdmiSinkAvCap.ui2_sink_colorimetry;
+	pv_get_info->ui1_sink_rgb_color_bit =
+		_HdmiSinkAvCap.e_sink_rgb_color_bit;
+	pv_get_info->ui1_sink_ycbcr_color_bit =
+		_HdmiSinkAvCap.e_sink_ycbcr_color_bit;
+	pv_get_info->ui1_sink_dc420_color_bit =
+		_HdmiSinkAvCap.ui1_sink_dc420_color_bit;
+	pv_get_info->ui2_sink_aud_dec =
+		_HdmiSinkAvCap.ui2_sink_aud_dec | HDMI_SINK_AUDIO_DEC_LPCM;
+	//pv_get_info->ui1_sink_is_plug_in =
+	//	_stAvdAVInfo.b_hotplug_state;
+	pv_get_info->ui4_hdmi_pcm_ch_type =
+	    ((_HdmiSinkAvCap.ui1_sink_pcm_ch_sampling[0]) |
+	     (_HdmiSinkAvCap.ui1_sink_pcm_ch_sampling[4] << 8) |
+	     (_HdmiSinkAvCap.ui1_sink_pcm_ch_sampling[6] <<
+						16));
+	pv_get_info->ui4_hdmi_pcm_ch3ch4ch5ch7_type =
+	    ((_HdmiSinkAvCap.ui1_sink_pcm_ch_sampling[1]) |
+	      (_HdmiSinkAvCap.ui1_sink_pcm_ch_sampling[2] << 8) |
+	     (_HdmiSinkAvCap.ui1_sink_pcm_ch_sampling[3] << 16)
+	     | (_HdmiSinkAvCap.ui1_sink_pcm_ch_sampling[5] << 24));
+
+	pv_get_info->ui4_hdmi_ac3_ch_type =
+	    ((_HdmiSinkAvCap.ui1_sink_ac3_ch_sampling[0]) |
+	     (_HdmiSinkAvCap.ui1_sink_ac3_ch_sampling[4] << 8) |
+	     (_HdmiSinkAvCap.ui1_sink_ac3_ch_sampling[6] << 16));
+	pv_get_info->ui4_hdmi_ac3_ch3ch4ch5ch7_type =
+	    ((_HdmiSinkAvCap.ui1_sink_ac3_ch_sampling[1]) |
+	     (_HdmiSinkAvCap.ui1_sink_ac3_ch_sampling[2] << 8) |
+	     (_HdmiSinkAvCap.ui1_sink_ac3_ch_sampling[3] << 16) |
+	     (_HdmiSinkAvCap.ui1_sink_ac3_ch_sampling[5] << 24));
+	pv_get_info->ui4_hdmi_ec3_ch_type =
+	    ((_HdmiSinkAvCap.ui1_sink_ec3_ch_sampling[0]) |
+	     (_HdmiSinkAvCap.ui1_sink_ec3_ch_sampling[4] << 8) |
+	     (_HdmiSinkAvCap.ui1_sink_ec3_ch_sampling[6] << 16));
+	pv_get_info->ui4_hdmi_ec3_ch3ch4ch5ch7_type =
+	    ((_HdmiSinkAvCap.ui1_sink_ec3_ch_sampling[1]) |
+	     (_HdmiSinkAvCap.ui1_sink_ec3_ch_sampling[2] << 8) |
+	     (_HdmiSinkAvCap.ui1_sink_ec3_ch_sampling[3] << 16) |
+	     (_HdmiSinkAvCap.ui1_sink_ec3_ch_sampling[5] << 24));
+
+	pv_get_info->ui4_hdmi_dts_ch_type =
+	    ((_HdmiSinkAvCap.ui1_sink_dts_ch_sampling[0]) |
+	     (_HdmiSinkAvCap.ui1_sink_dts_ch_sampling[4] << 8) |
+	     (_HdmiSinkAvCap.ui1_sink_dts_ch_sampling[6] << 16));
+	pv_get_info->ui4_hdmi_dts_ch3ch4ch5ch7_type =
+	    ((_HdmiSinkAvCap.ui1_sink_dts_ch_sampling[1]) |
+	     (_HdmiSinkAvCap.ui1_sink_dts_ch_sampling[2] << 8) |
+	     (_HdmiSinkAvCap.ui1_sink_dts_ch_sampling[3] << 16) |
+	     (_HdmiSinkAvCap.ui1_sink_dts_ch_sampling[5] << 24));
+
+	pv_get_info->ui4_hdmi_dts_hd_ch_type =
+	    ((_HdmiSinkAvCap.ui1_sink_dts_hd_ch_sampling[0]) |
+	     (_HdmiSinkAvCap.ui1_sink_dts_hd_ch_sampling[4] << 8) |
+	     (_HdmiSinkAvCap.ui1_sink_dts_hd_ch_sampling[6] << 16));
+	pv_get_info->ui4_hdmi_dts_hd_ch3ch4ch5ch7_type =
+	    ((_HdmiSinkAvCap.ui1_sink_dts_hd_ch_sampling[1]) |
+	     (_HdmiSinkAvCap.ui1_sink_dts_hd_ch_sampling[2] << 8) |
+	     (_HdmiSinkAvCap.ui1_sink_dts_hd_ch_sampling[3] << 16) |
+	     (_HdmiSinkAvCap.ui1_sink_dts_hd_ch_sampling[5] << 24));
+
+	pv_get_info->ui4_hdmi_pcm_bit_size =
+	    ((_HdmiSinkAvCap.ui1_sink_pcm_bit_size[0]) |
+	     (_HdmiSinkAvCap.ui1_sink_pcm_bit_size[4] << 8) |
+	     (_HdmiSinkAvCap.ui1_sink_pcm_bit_size[6] << 16));
+
+	pv_get_info->ui1_sink_support_dolby_atoms =
+		_HdmiSinkAvCap.ui1_sink_support_dolby_atoms;
+	pv_get_info->ui1_sink_i_latency_present =
+		_HdmiSinkAvCap.ui1_sink_i_latency_present;
+	pv_get_info->ui1_sink_p_audio_latency =
+		_HdmiSinkAvCap.ui1_sink_p_audio_latency;
+	pv_get_info->ui1_sink_p_video_latency =
+		_HdmiSinkAvCap.ui1_sink_p_video_latency;
+	pv_get_info->ui1_sink_i_audio_latency =
+		_HdmiSinkAvCap.ui1_sink_i_audio_latency;
+	pv_get_info->ui1_sink_i_video_latency =
+		_HdmiSinkAvCap.ui1_sink_i_video_latency;
+
+	pv_get_info->ui1ExtEdid_Revision =
+		_HdmiSinkAvCap.ui1_ExtEdid_Revision;
+	pv_get_info->ui1Edid_Version =
+		_HdmiSinkAvCap.ui1_Edid_Version;
+	pv_get_info->ui1Edid_Revision =
+		_HdmiSinkAvCap.ui1_Edid_Revision;
+	pv_get_info->ui1_Display_Horizontal_Size =
+		_HdmiSinkAvCap.ui1_Display_Horizontal_Size;
+	pv_get_info->ui1_Display_Vertical_Size =
+		_HdmiSinkAvCap.ui1_Display_Vertical_Size;
+	pv_get_info->ui2_sink_cec_address =
+		_HdmiSinkAvCap.ui2_sink_cec_address;
+	HDMI_EDID_LOG("[edid]to app,ntsc:%x,pal:%x,pa:%x\n",
+		pv_get_info->ui4_ntsc_resolution,
+		      pv_get_info->ui4_pal_resolution,
+		      pv_get_info->ui2_sink_cec_address);
+	HDMI_EDID_LOG("[edid]to app,aud dec:%x,pcm ch:%x\n",
+		pv_get_info->ui2_sink_aud_dec,
+		      pv_get_info->ui4_hdmi_pcm_ch_type);
+
+	pv_get_info->b_sink_SCDC_present =
+		_HdmiSinkAvCap.b_sink_SCDC_present;
+	pv_get_info->b_sink_LTE_340M_sramble =
+		_HdmiSinkAvCap.b_sink_LTE_340M_sramble;
+
+	u4Res = _HdmiSinkAvCap.ui4_sink_hdmi_4k2kvic |
+		_HdmiSinkAvCap.ui4_sink_hdmi_4k2kvic_420_vdb;
+
+	/* For HDMI2 modes, TMDS character rate should
+	 *be >= 340 atleast or >=297 for 420modes. However,
+	 * some HDMI1.x AVRs when providing the combined
+	 *EDID for the AVR and sink incorrectly report
+	 * support for HDMI2.0 modes indicating 4k@60/50
+	 *modes as available. Check TMDS character rate
+	 * for the same. If it is not set or < 340, support
+	 *for 4k@60/50 is not there and EDID is
+	 * incorrectly indicating 4k@60/50 support.
+	 *Remove 4k@60/50 support for such cases.
+	 */
+	if (_HdmiSinkAvCap.ui2_sink_max_tmds_character_rate != 0)
+		maxTMDSRate =
+		_HdmiSinkAvCap.ui2_sink_max_tmds_character_rate;
+	else
+		maxTMDSRate =
+		_HdmiSinkAvCap.ui1_sink_max_tmds_clock;
+
+	yuv420Supported = ((
+		_HdmiSinkAvCap.ui2_sink_colorimetry & SINK_YCBCR_420) ||
+					   (
+					   _HdmiSinkAvCap.ui2_sink_colorimetry &
+					   SINK_YCBCR_420_CAPABILITY)) ? 1 : 0;
+	if (((yuv420Supported) && (maxTMDSRate >= 297)) ||
+		(maxTMDSRate >= 340)/* HDMI2 modes*/) {
+		pv_get_info->ui4_sink_hdmi_4k2kvic = u4Res;
+	} else {
+		if (u4Res != 0) {
+			HDMI_EDID_LOG("u4Res=0x%llx, maxTMDSRate=%u, ",
+			    u4Res, maxTMDSRate);
+			HDMI_EDID_LOG("max_tmds_clock=%u,max_tmds_char_rate=%u\n",
+			    _HdmiSinkAvCap.ui1_sink_max_tmds_clock,
+			    _HdmiSinkAvCap.ui2_sink_max_tmds_character_rate);
+			if (u4Res & SINK_2160P_60HZ)
+				u4Res &= ~SINK_2160P_60HZ;
+			if (u4Res & SINK_2160P_50HZ)
+				u4Res &= ~SINK_2160P_50HZ;
+			if (u4Res & SINK_2161P_60HZ)
+				u4Res &= ~SINK_2161P_60HZ;
+			if (u4Res & SINK_2161P_50HZ)
+				u4Res &= ~SINK_2161P_50HZ;
+			HDMI_EDID_LOG("4k@60/50 modes are not supported,4K u4Res=0x%llx\n",
+				u4Res);
+		}
+		pv_get_info->ui4_sink_hdmi_4k2kvic = u4Res;
+	}
+
+	pv_get_info->ui1_sink_max_tmds_clock =
+		_HdmiSinkAvCap.ui1_sink_max_tmds_clock;
+	pv_get_info->ui2_sink_max_tmds_character_rate =
+		_HdmiSinkAvCap.ui2_sink_max_tmds_character_rate;
+	pv_get_info->ui1_sink_support_static_hdr =
+		_HdmiSinkAvCap.ui1_sink_support_static_hdr;
+	if (debug_hdr10p_force_enable_edid)
+		_HdmiSinkAvCap.ui1_sink_support_dynamic_hdr |=
+		EDID_SUPPORT_HDR10_PLUS;
+	if (debug_hdr10p_force_set_appversion != 0xff)
+		_HdmiSinkAvCap.ui1_sink_hdr10plus_app_version =
+		debug_hdr10p_force_set_appversion;
+	pv_get_info->ui1_sink_support_dynamic_hdr =
+		_HdmiSinkAvCap.ui1_sink_support_dynamic_hdr;
+	pv_get_info->ui1_sink_hdr10plus_app_version =
+		_HdmiSinkAvCap.ui1_sink_hdr10plus_app_version;
+	pv_get_info->ui1_sink_hdr_content_max_luminance =
+	_HdmiSinkAvCap.ui1_sink_hdr_content_max_luminance;
+	pv_get_info->ui1_sink_hdr_content_max_frame_average_luminance =
+	_HdmiSinkAvCap.ui1_sink_hdr_content_max_frame_average_luminance;
+	pv_get_info->ui1_sink_hdr_content_min_luminance =
+	_HdmiSinkAvCap.ui1_sink_hdr_content_min_luminance;
+	pv_get_info->ui4_sink_dolbyvision_vsvdb_length =
+	_HdmiSinkAvCap.ui4_sink_dolbyvision_vsvdb_length;
+	pv_get_info->ui4_sink_dolbyvision_vsvdb_version =
+	_HdmiSinkAvCap.ui4_sink_dolbyvision_vsvdb_version;
+	pv_get_info->ui4_sink_dolbyvision_vsvdb_v1_low_latency =
+	_HdmiSinkAvCap.ui4_sink_dolbyvision_vsvdb_v1_low_latency;
+	pv_get_info->ui4_sink_dolbyvision_vsvdb_v2_interface =
+	_HdmiSinkAvCap.ui4_sink_dolbyvision_vsvdb_v2_interface;
+	pv_get_info->ui4_sink_dolbyvision_vsvdb_low_latency_support =
+	_HdmiSinkAvCap.ui4_sink_dolbyvision_vsvdb_low_latency_support;
+	pv_get_info->ui4_sink_dolbyvision_vsvdb_v2_supports_10b_12b_444 =
+_HdmiSinkAvCap.ui4_sink_dolbyvision_vsvdb_v2_supports_10b_12b_444;
+pv_get_info->ui4_sink_dolbyvision_vsvdb_support_backlight_control =
+_HdmiSinkAvCap.ui4_sink_dolbyvision_vsvdb_support_backlight_control;
+	pv_get_info->ui4_sink_dolbyvision_vsvdb_backlt_min_lumal =
+	_HdmiSinkAvCap.ui4_sink_dolbyvision_vsvdb_backlt_min_lumal;
+	pv_get_info->ui4_sink_dolbyvision_vsvdb_tmin =
+		_HdmiSinkAvCap.ui4_sink_dolbyvision_vsvdb_tmin;
+	pv_get_info->ui4_sink_dolbyvision_vsvdb_tmax =
+		_HdmiSinkAvCap.ui4_sink_dolbyvision_vsvdb_tmax;
+	pv_get_info->ui4_sink_dolbyvision_vsvdb_tminPQ =
+		_HdmiSinkAvCap.ui4_sink_dolbyvision_vsvdb_tminPQ;
+	pv_get_info->ui4_sink_dolbyvision_vsvdb_tmaxPQ =
+		_HdmiSinkAvCap.ui4_sink_dolbyvision_vsvdb_tmaxPQ;
+	pv_get_info->ui4_sink_dolbyvision_vsvdb_Rx =
+		_HdmiSinkAvCap.ui4_sink_dolbyvision_vsvdb_Rx;
+	pv_get_info->ui4_sink_dolbyvision_vsvdb_Ry =
+		_HdmiSinkAvCap.ui4_sink_dolbyvision_vsvdb_Ry;
+	pv_get_info->ui4_sink_dolbyvision_vsvdb_Gx =
+		_HdmiSinkAvCap.ui4_sink_dolbyvision_vsvdb_Gx;
+	pv_get_info->ui4_sink_dolbyvision_vsvdb_Gy =
+		_HdmiSinkAvCap.ui4_sink_dolbyvision_vsvdb_Gy;
+	pv_get_info->ui4_sink_dolbyvision_vsvdb_Bx =
+		_HdmiSinkAvCap.ui4_sink_dolbyvision_vsvdb_Bx;
+	pv_get_info->ui4_sink_dolbyvision_vsvdb_By =
+		_HdmiSinkAvCap.ui4_sink_dolbyvision_vsvdb_By;
+	pv_get_info->ui4_sink_dolbyvision_vsvdb_Wx =
+		_HdmiSinkAvCap.ui4_sink_dolbyvision_vsvdb_Wx;
+	pv_get_info->ui4_sink_dolbyvision_vsvdb_Wy =
+		_HdmiSinkAvCap.ui4_sink_dolbyvision_vsvdb_Wy;
+	for (i = 0; i < 32; i++)
+		pv_get_info->ui1_sink_dolbyvision_block[i] =
+		_HdmiSinkAvCap.ui1_sink_dolbyvision_block[i];
+
+	for (i = 0; i < 256; i++)
+		pv_get_info->ui1rawdata_edid[i] = _bEdidData[i];
+}
+
+unsigned char hdmi_check_edid_header(void)
+{
+	unsigned char bIdx;
+
+	for (bIdx = EDID_ADDR_HEADER; bIdx <
+		(EDID_ADDR_HEADER + EDID_HEADER_LEN); bIdx++) {
+		if (_bEdidData[bIdx] != aEDIDHeader[bIdx])
+			return 0;
+	}
+	return 1;
+}
+
+void hdmi_clear_edid_data(void)
+{
+	memset(_bEdidData, 0, EDID_SIZE);
+}
+
+unsigned int i4SharedInfo(unsigned int u4Index)
+{
+	return i4HdmiShareInfo[u4Index];
+}
+
+void vSetSharedInfo(unsigned int u4Index, unsigned int i4Value)
+{
+	i4HdmiShareInfo[u4Index] = i4Value;
+}
+
diff --git a/drivers/gpu/drm/mediatek/mediatek_v2/mtk_hdmi_edid.h b/drivers/gpu/drm/mediatek/mediatek_v2/mtk_hdmi_edid.h
new file mode 100644
index 0000000000000000000000000000000000000000..d512198b3861b27595dfd00b18ca9bed8fa1fd2f
--- /dev/null
+++ b/drivers/gpu/drm/mediatek/mediatek_v2/mtk_hdmi_edid.h
@@ -0,0 +1,617 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2019 MediaTek Inc.
+ */
+
+#ifndef __hdmiedid_h__
+#define __hdmiedid_h__
+
+#define EDID_SIZE 512
+
+#define EDID_ID     0x50	/* 0xA0 */
+#define EDID_ID1    0x51	/* 0xA2 */
+
+/* (5) Define the EDID relative information */
+/* (5.1) Define one EDID block length */
+#define EDID_BLOCK_LEN      128
+/* (5.2) Define EDID header length */
+#define EDID_HEADER_LEN     8
+/* (5.3) Define the address for EDID info.
+ *(ref. EDID Recommended Practive for EIA/CEA-861)
+ * Base Block 0
+ */
+#define EDID_ADDR_HEADER                      0x00
+#define EDID_ADDR_VERSION                     0x12
+#define EDID_ADDR_REVISION                    0x13
+#define EDID_IMAGE_HORIZONTAL_SIZE            0x15
+#define EDID_IMAGE_VERTICAL_SIZE              0x16
+#define EDID_ADDR_FEATURE_SUPPORT             0x18
+#define EDID_ADDR_TIMING_DSPR_1               0x36
+#define EDID_ADDR_TIMING_DSPR_2               0x48
+#define EDID_ADDR_MONITOR_DSPR_1              0x5A
+#define EDID_ADDR_MONITOR_DSPR_2              0x6C
+#define EDID_ADDR_EXT_BLOCK_FLAG              0x7E
+/* EDID address: 0x83 */
+#define EDID_ADDR_EXTEND_BYTE3                0x03
+/* for ID receiver if RGB, YCbCr 4:2:2 or 4:4:4 */
+/* Extension Block 1: */
+#define EXTEDID_ADDR_TAG                      0x00
+#define EXTEDID_ADDR_REVISION                 0x01
+#define EXTEDID_ADDR_OFST_TIME_DSPR           0x02
+
+/* (5.4) Define the ID for descriptor block type */
+/* Notice: reference Table 11 ~ 14 of "EDID
+ *Recommended Practive for EIA/CEA-861"
+ */
+#define DETAIL_TIMING_DESCRIPTOR              -1
+#define UNKNOWN_DESCRIPTOR                    -255
+#define MONITOR_NAME_DESCRIPTOR               0xFC
+#define MONITOR_RANGE_LIMITS_DESCRIPTOR       0xFD
+
+
+/* (5.5) Define the offset address of info.
+ *within detail timing descriptor block
+ */
+#define OFST_PXL_CLK_LO       0
+#define OFST_PXL_CLK_HI       1
+#define OFST_H_ACTIVE_LO      2
+#define OFST_H_BLANKING_LO    3
+#define OFST_H_ACT_BLA_HI     4
+#define OFST_V_ACTIVE_LO      5
+#define OFST_V_BLANKING_LO    6
+#define OFST_V_ACTIVE_HI      7
+#define OFST_FLAGS            17
+
+/* (5.6) Define the ID for EDID extension type */
+#define LCD_TIMING                  0x1
+#define CEA_TIMING_EXTENSION        0x01
+#define EDID_20_EXTENSION           0x20
+#define COLOR_INFO_TYPE0            0x30
+#define DVI_FEATURE_DATA            0x40
+#define TOUCH_SCREEN_MAP            0x50
+#define BLOCK_MAP                   0xF0
+#define EXTENSION_DEFINITION        0xFF
+
+/* (5.7) Define EDID VSDB header length */
+#define EDID_VSDB_LEN               0x03
+enum HDMI_SINK_DEEP_COLOR_T {
+	HDMI_SINK_NO_DEEP_COLOR = 0,
+	HDMI_SINK_DEEP_COLOR_10_BIT = (1 << 0),
+	HDMI_SINK_DEEP_COLOR_12_BIT = (1 << 1),
+	HDMI_SINK_DEEP_COLOR_16_BIT = (1 << 2)
+};
+
+struct HDMI_SINK_AV_CAP_T {
+	/* use HDMI_SINK_VIDEO_RES_T */
+	unsigned int ui4_sink_cea_ntsc_resolution;
+	/* use HDMI_SINK_VIDEO_RES_T */
+	unsigned int ui4_sink_cea_pal_resolution;
+	/* use HDMI_SINK_VIDEO_RES_T */
+	unsigned int ui4_sink_org_cea_ntsc_resolution;
+	/* use HDMI_SINK_VIDEO_RES_T */
+	unsigned int ui4_sink_org_cea_pal_resolution;
+	/* use HDMI_SINK_VIDEO_RES_T */
+	unsigned int ui4_sink_dtd_ntsc_resolution;
+	/* use HDMI_SINK_VIDEO_RES_T */
+	unsigned int ui4_sink_dtd_pal_resolution;
+	/* use HDMI_SINK_VIDEO_RES_T */
+	unsigned int ui4_sink_1st_dtd_ntsc_resolution;
+	/* use HDMI_SINK_VIDEO_RES_T */
+	unsigned int ui4_sink_1st_dtd_pal_resolution;
+	/* use HDMI_SINK_VIDEO_RES_T */
+	unsigned int ui4_sink_native_ntsc_resolution;
+	/* use HDMI_SINK_VIDEO_RES_T */
+	unsigned int ui4_sink_native_pal_resolution;
+	/* use HDMI_SINK_VIDEO_COLORIMETRY_T */
+	unsigned short ui2_sink_colorimetry;
+	/* use HDMI_SINK_VCDB_T */
+	unsigned short ui2_sink_vcdb_data;
+	/* HDMI_SINK_AUDIO_DECODER_T */
+	unsigned short ui2_sink_aud_dec;
+	unsigned char ui1_sink_dsd_ch_num;
+	unsigned char ui1_sink_pcm_ch_sampling[7];
+	/* n: channel number index, value: each bit
+	 *means sampling rate for this channel number
+	 *(SINK_AUDIO_32k..)
+	 */
+	unsigned char ui1_sink_pcm_bit_size[7];
+	/* //n: channel number index, value: each bit
+	 *means bit size for this channel number
+	 */
+	unsigned char ui1_sink_dst_ch_sampling[7];
+	/* n: channel number index, value: each bit
+	 *means sampling rate for this channel number
+	 *(SINK_AUDIO_32k..)
+	 */
+	unsigned char ui1_sink_dsd_ch_sampling[7];
+	/* n: channel number index, value: each bit
+	 *means sampling rate for this channel number
+	 *(SINK_AUDIO_32k..)
+	 */
+	unsigned char ui1_sink_ac3_ch_sampling[7];
+	/* n: channel number index, value: each bit
+	 *means sampling rate for this channel number
+	 *(SINK_AUDIO_32k..)
+	 */
+	unsigned char ui1_sink_ec3_ch_sampling[7];
+	/* n: channel number index, value:
+	 *each bit means sampling rate for this channel
+	 *number (SINK_AUDIO_32k..)
+	 */
+
+	unsigned char ui1_sink_org_pcm_ch_sampling[7];
+	unsigned char ui1_sink_org_pcm_bit_size[7];
+	unsigned char ui1_sink_mpeg1_ch_sampling[7];
+	unsigned char ui1_sink_mp3_ch_sampling[7];
+	unsigned char ui1_sink_mpeg2_ch_sampling[7];
+	unsigned char ui1_sink_aac_ch_sampling[7];
+	unsigned char ui4_sink_dts_fs;
+	unsigned char ui1_sink_dts_ch_sampling[7];
+	unsigned char ui1_sink_atrac_ch_sampling[7];
+	unsigned char ui1_sink_dolby_plus_ch_sampling[7];
+	unsigned char ui1_sink_dts_hd_ch_sampling[7];
+	unsigned char ui1_sink_mat_mlp_ch_sampling[7];
+	unsigned char ui1_sink_wma_ch_sampling[7];
+	unsigned char ui1_sink_support_dolby_atoms;
+	unsigned short ui1_sink_max_tmds_clock;
+	unsigned char ui1_sink_spk_allocation;
+	unsigned char ui1_sink_content_cnc;
+	unsigned char ui1_sink_p_latency_present;
+	unsigned char ui1_sink_i_latency_present;
+	unsigned int ui1_sink_p_audio_latency;
+	unsigned int ui1_sink_p_video_latency;
+	unsigned int ui1_sink_i_audio_latency;
+	unsigned int ui1_sink_i_video_latency;
+	unsigned char e_sink_rgb_color_bit;
+	unsigned char e_sink_ycbcr_color_bit;
+	unsigned char u1_sink_support_ai;
+	unsigned char u1_sink_max_tmds;
+	/* HDMI_EDID_CHKSUM_AND_AUDIO_SUP_T */
+	unsigned short ui2_edid_chksum_and_audio_sup;
+	unsigned short ui2_sink_cec_address;
+	unsigned char b_sink_edid_ready;
+	unsigned char b_sink_support_hdmi_mode;
+	unsigned char ui1_ExtEdid_Revision;
+	unsigned char ui1_Edid_Version;
+	unsigned char ui1_Edid_Revision;
+	unsigned char ui1_sink_support_ai;
+	unsigned char ui1_Display_Horizontal_Size;
+	unsigned char ui1_Display_Vertical_Size;
+	unsigned char b_sink_hdmi_video_present;
+	unsigned char ui1_CNC;
+	unsigned char b_sink_3D_present;
+	unsigned int ui4_sink_cea_3D_resolution;
+	unsigned char b_sink_SCDC_present;
+	unsigned char b_sink_LTE_340M_sramble;
+	unsigned int ui4_sink_hdmi_4k2kvic;
+
+	unsigned int ui4_sink_id_serial_number;
+	unsigned char ui1_sink_support_static_hdr;
+	unsigned char ui1_sink_support_dynamic_hdr;
+	unsigned char ui1_sink_hdr10plus_app_version;
+	unsigned char ui1_sink_dolbyvision_block[32];
+	unsigned char ui1_sink_hf_vsdb_exist;
+	unsigned short ui2_sink_max_tmds_character_rate;
+	unsigned char ui1_sink_hf_vsdb_info;
+	unsigned char ui1_sink_dc420_color_bit;
+	unsigned char ui1_sink_hdr_content_max_luminance;
+	unsigned char ui1_sink_hdr_content_max_frame_average_luminance;
+	unsigned char ui1_sink_hdr_content_min_luminance;
+	unsigned char ui1_sink_hdr_block[7];	/* add for hdmi rx merge EDID */
+	unsigned char ui1_sink_hfvsdb_block[8];	/* add for hdmi rx merge EDID */
+
+	unsigned int ui4_sink_hdmi_4k2kvic_420_vdb;
+
+	unsigned int ui4_sink_dolbyvision_vsvdb_length;
+	unsigned int ui4_sink_dolbyvision_vsvdb_version;
+	unsigned int ui4_sink_dolbyvision_vsvdb_v1_low_latency;
+	unsigned int ui4_sink_dolbyvision_vsvdb_v2_interface;
+	unsigned int ui4_sink_dolbyvision_vsvdb_low_latency_support;
+	unsigned int ui4_sink_dolbyvision_vsvdb_v2_supports_10b_12b_444;
+	unsigned int ui4_sink_dolbyvision_vsvdb_support_backlight_control;
+	unsigned int ui4_sink_dolbyvision_vsvdb_backlt_min_lumal;
+	unsigned int ui4_sink_dolbyvision_vsvdb_tmin;
+	unsigned int ui4_sink_dolbyvision_vsvdb_tmax;
+	unsigned int ui4_sink_dolbyvision_vsvdb_tminPQ;
+	unsigned int ui4_sink_dolbyvision_vsvdb_tmaxPQ;
+	unsigned int ui4_sink_dolbyvision_vsvdb_Rx;
+	unsigned int ui4_sink_dolbyvision_vsvdb_Ry;
+	unsigned int ui4_sink_dolbyvision_vsvdb_Gx;
+	unsigned int ui4_sink_dolbyvision_vsvdb_Gy;
+	unsigned int ui4_sink_dolbyvision_vsvdb_Bx;
+	unsigned int ui4_sink_dolbyvision_vsvdb_By;
+	unsigned int ui4_sink_dolbyvision_vsvdb_Wx;
+	unsigned int ui4_sink_dolbyvision_vsvdb_Wy;
+};
+
+/* HDMI_SINK_AUDIO_DECODER_T define what kind of audio decoder */
+/* can be supported by sink. */
+#define   HDMI_SINK_AUDIO_DEC_LPCM        (1<<0)
+#define   HDMI_SINK_AUDIO_DEC_AC3         (1<<1)
+#define   HDMI_SINK_AUDIO_DEC_MPEG1       (1<<2)
+#define   HDMI_SINK_AUDIO_DEC_MP3         (1<<3)
+#define   HDMI_SINK_AUDIO_DEC_MPEG2       (1<<4)
+#define   HDMI_SINK_AUDIO_DEC_AAC         (1<<5)
+#define   HDMI_SINK_AUDIO_DEC_DTS         (1<<6)
+#define   HDMI_SINK_AUDIO_DEC_ATRAC       (1<<7)
+#define   HDMI_SINK_AUDIO_DEC_DSD         (1<<8)
+#define   HDMI_SINK_AUDIO_DEC_DOLBY_PLUS   (1<<9)
+#define   HDMI_SINK_AUDIO_DEC_DTS_HD      (1<<10)
+#define   HDMI_SINK_AUDIO_DEC_MAT_MLP     (1<<11)
+#define   HDMI_SINK_AUDIO_DEC_DST         (1<<12)
+#define   HDMI_SINK_AUDIO_DEC_ATMOS       (1<<13)
+#define   HDMI_SINK_AUDIO_DEC_WMA         (1<<14)
+
+
+/* Sink audio channel ability for a fixed Fs */
+#define SINK_AUDIO_2CH   (1<<0)
+#define SINK_AUDIO_3CH   (1<<1)
+#define SINK_AUDIO_4CH   (1<<2)
+#define SINK_AUDIO_5CH   (1<<3)
+#define SINK_AUDIO_6CH   (1<<4)
+#define SINK_AUDIO_7CH   (1<<5)
+#define SINK_AUDIO_8CH   (1<<6)
+
+/* Sink supported sampling rate for a fixed channel number */
+#define SINK_AUDIO_32k (1<<0)
+#define SINK_AUDIO_44k (1<<1)
+#define SINK_AUDIO_48k (1<<2)
+#define SINK_AUDIO_88k (1<<3)
+#define SINK_AUDIO_96k (1<<4)
+#define SINK_AUDIO_176k (1<<5)
+#define SINK_AUDIO_192k (1<<6)
+
+/*The following definition is for Sink speaker allocation data block .*/
+#define SINK_AUDIO_FL_FR   (1<<0)
+#define SINK_AUDIO_LFE     (1<<1)
+#define SINK_AUDIO_FC      (1<<2)
+#define SINK_AUDIO_RL_RR   (1<<3)
+#define SINK_AUDIO_RC      (1<<4)
+#define SINK_AUDIO_FLC_FRC (1<<5)
+#define SINK_AUDIO_RLC_RRC (1<<6)
+
+/* The following definition is */
+/* For EDID Audio Support, //HDMI_EDID_CHKSUM_AND_AUDIO_SUP_T */
+#define SINK_BASIC_AUDIO_NO_SUP    (1<<0)
+#define SINK_SAD_NO_EXIST          (1<<1)/* short audio descriptor */
+#define SINK_BASE_BLK_CHKSUM_ERR   (1<<2)
+#define SINK_EXT_BLK_CHKSUM_ERR    (1<<3)
+
+
+#define RES_480i_60      (1 << 0)
+#define RES_576i_50    (1 << 1)
+#define RES_480p_60   (1 << 2)
+#define RES_576p_50   (1 << 3)
+#define RES_720p_60 (1 << 4)
+#define RES_720p_50 (1 << 5)
+#define RES_1080i_60      (1 << 6)
+#define RES_1080i_50 (1 << 7)
+#define RES_1080p_30 (1 << 8)
+#define RES_1080p_25   (1 << 9)
+#define RES_1080p_24      (1 << 10)
+#define RES_1080p_23    (1 << 11)
+#define RES_1080p_29   (1 << 12)
+#define RES_1080p_60   (1 << 13)
+#define RES_1080p_50 (1 << 14)
+#define RES_2160P_23_976   (1 << 21)
+#define RES_2160P_24   (1 << 22)
+#define RES_2160P_25       (1 << 23)
+#define RES_2160P_29_97   (1 << 24)
+#define RES_2160P_30   (1 << 25)
+#define RES_2161P_24 (1 << 26)
+#define RES_2160P_60   (1 << 27)
+#define RES_2160P_50   (1 << 28)
+#define RES_2161P_60 (1 << 29)
+#define RES_2161P_50       (1<<30)
+#define RES_720P_59_94	(1LL << 31)
+#define RES_1080P_59_94	(1LL << 32)
+#define RES_2160P_59_94	(1LL << 33)
+#define RES_2161P_59_94	(1LL << 34)
+
+#define SINK_480P      (1 << 0)
+#define SINK_720P60    (1 << 1)
+#define SINK_1080I60   (1 << 2)
+#define SINK_1080P60   (1 << 3)
+#define SINK_480P_1440 (1 << 4)
+#define SINK_480P_2880 (1 << 5)
+#define SINK_480I      (1 << 6)
+#define SINK_480I_1440 (1 << 7)
+#define SINK_480I_2880 (1 << 8)
+#define SINK_1080P30   (1 << 9)
+#define SINK_576P      (1 << 10)
+#define SINK_720P50    (1 << 11)
+#define SINK_1080I50   (1 << 12)
+#define SINK_1080P50   (1 << 13)
+#define SINK_576P_1440 (1 << 14)
+#define SINK_576P_2880 (1 << 15)
+#define SINK_576I      (1 << 16)
+#define SINK_576I_1440 (1 << 17)
+#define SINK_576I_2880 (1 << 18)
+#define SINK_1080P25   (1 << 19)
+#define SINK_1080P24   (1 << 20)
+#define SINK_1080P23976   (1 << 21)
+#define SINK_1080P2997   (1 << 22)
+#define SINK_VGA       (1 << 23)	/* 640x480P */
+#define SINK_480I_4_3   (1 << 24)	/* 720x480I 4:3 */
+#define SINK_480P_4_3   (1 << 25)	/* 720x480P 4:3 */
+#define SINK_480P_2880_4_3 (1 << 26)
+#define SINK_576I_4_3   (1 << 27)	/* 720x480I 4:3 */
+#define SINK_576P_4_3   (1 << 28)	/* 720x480P 4:3 */
+#define SINK_576P_2880_4_3 (1 << 29)
+#define SINK_720P24       (1<<30)
+#define SINK_720P23976 (1<<31)
+
+/*the 2160 mean 3840x2160 */
+#define SINK_2160P_23_976HZ (1 << 0)
+#define SINK_2160P_24HZ (1 << 1)
+#define SINK_2160P_25HZ (1 << 2)
+#define SINK_2160P_29_97HZ (1 << 3)
+#define SINK_2160P_30HZ (1 << 4)
+/*the 2161 mean 4096x2160 */
+#define SINK_2161P_24HZ (1 << 5)
+#define SINK_2161P_25HZ (1 << 6)
+#define SINK_2161P_30HZ (1 << 7)
+#define SINK_2160P_50HZ (1 << 8)
+#define SINK_2160P_60HZ (1 << 9)
+#define SINK_2161P_50HZ (1 << 10)
+#define SINK_2161P_60HZ (1 << 11)
+#define SINK_2161P_23_976HZ (1 << 12)
+#define SINK_2161P_29_97HZ (1 << 13)
+
+enum AUDIO_BITSTREAM_TYPE_T {
+	AVD_BITS_NONE = 0,
+	AVD_LPCM = 1,
+	AVD_AC3,
+	AVD_MPEG1_AUD,
+	AVD_MP3,
+	AVD_MPEG2_AUD,
+	AVD_AAC,
+	AVD_DTS,
+	AVD_ATRAC,
+	AVD_DSD,
+	AVD_DOLBY_PLUS,
+	AVD_DTS_HD,
+	AVD_MAT_MLP,
+	AVD_DST,
+	AVD_DOLBY_ATMOS,
+	AVD_WMA,
+	AVD_CDDA,
+	AVD_SACD_PCM,
+	AVD_HDCD = 0xfe,
+	AVD_BITS_OTHERS = 0xff
+};
+
+enum EDID_HF_VSDB_INFO_T {
+	EDID_HF_VSDB_3D_OSD_DISPARITY = (1 << 0),
+	EDID_HF_VSDB_DUAL_VIEW = (1 << 1),
+	EDID_HF_VSDB_INDEPENDENT_VIEW = (1 << 2),
+	EDID_HF_VSDB_LTE_340MCSC_SCRAMBLE = (1 << 3),
+	EDID_HF_VSDB_RR_CAPABLE = (1 << 6),
+	EDID_HF_VSDB_SCDC_PRESENT = (1 << 7),
+};
+
+/* Dynamic hdr supported by Sink */
+enum EDID_DYNAMIC_HDR_T {
+	EDID_SUPPORT_PHILIPS_HDR = (1 << 0),
+	EDID_SUPPORT_DOLBY_HDR = (1 << 1),
+	EDID_SUPPORT_YUV422_12BIT = (1 << 2),
+	EDID_SUPPORT_DOLBY_HDR_2160P60 = (1 << 3),
+	EDID_SUPPORT_HDR10_PLUS = (1 << 4),
+};
+
+/* This HDMI_SINK_VIDEO_COLORIMETRY_T will define what kind of YCBCR */
+/* can be supported by sink. */
+/* And each bit also defines the colorimetry data block of EDID. */
+#define SINK_YCBCR_444 (1<<0)
+#define SINK_YCBCR_422 (1<<1)
+#define SINK_XV_YCC709 (1<<2)
+#define SINK_XV_YCC601 (1<<3)
+#define SINK_METADATA0 (1<<4)
+#define SINK_METADATA1 (1<<5)
+#define SINK_METADATA2 (1<<6)
+#define SINK_RGB       (1<<7)
+#define SINK_COLOR_SPACE_BT2020_CYCC  (1<<8)
+#define SINK_COLOR_SPACE_BT2020_YCC  (1<<9)
+#define SINK_COLOR_SPACE_BT2020_RGB  (1<<10)
+#define SINK_YCBCR_420 (1<<11)
+#define SINK_YCBCR_420_CAPABILITY (1<<12)
+
+#define SINK_METADATA3 (1<<13)
+#define SINK_S_YCC601     (1<<14)
+#define SINK_ADOBE_YCC601  (1<<15)
+#define SINK_ADOBE_RGB  (1<<16)
+
+/* Static hdr supported by Sink */
+enum EDID_STATIC_HDR_T {
+	EDID_SUPPORT_SDR = (1 << 0),
+	EDID_SUPPORT_HDR = (1 << 1),
+	EDID_SUPPORT_SMPTE_ST_2084 = (1 << 2),
+	EDID_SUPPORT_FUTURE_EOTF = (1 << 3),
+	EDID_SUPPORT_ET_4 = (1 << 4),
+	EDID_SUPPORT_ET_5 = (1 << 5),
+};
+
+/* HDMI_SINK_VCDB_T Each bit defines the
+ *VIDEO Capability Data Block of EDID.
+ */
+#define SINK_CE_ALWAYS_OVERSCANNED                  (1<<0)
+#define SINK_CE_ALWAYS_UNDERSCANNED                 (1<<1)
+#define SINK_CE_BOTH_OVER_AND_UNDER_SCAN            (1<<2)
+#define SINK_IT_ALWAYS_OVERSCANNED                  (1<<3)
+#define SINK_IT_ALWAYS_UNDERSCANNED                 (1<<4)
+#define SINK_IT_BOTH_OVER_AND_UNDER_SCAN            (1<<5)
+#define SINK_PT_ALWAYS_OVERSCANNED                  (1<<6)
+#define SINK_PT_ALWAYS_UNDERSCANNED                 (1<<7)
+#define SINK_PT_BOTH_OVER_AND_UNDER_SCAN            (1<<8)
+#define SINK_RGB_SELECTABLE                         (1<<9)
+
+enum HDMI_AUDIO_SAMPLING_T {
+	HDMI_FS_32K = 0,
+	HDMI_FS_44K,
+	HDMI_FS_48K,
+	HDMI_FS_88K,
+	HDMI_FS_96K,
+	HDMI_FS_176K,
+	HDMI_FS_192K
+};
+
+enum PCM_BIT_SIZE_T {
+	PCM_16BIT = 0,
+	PCM_20BIT,
+	PCM_24BIT
+};
+
+struct HDMI_EDID_T {
+	/* use EDID_VIDEO_RES_T, there are many resolution */
+	unsigned int ui4_ntsc_resolution;
+	unsigned int ui4_pal_resolution;	/* use EDID_VIDEO_RES_T */
+	unsigned int ui4_sink_native_ntsc_resolution;
+	/* use EDID_VIDEO_RES_T, only one NTSC resolution,
+	 *Zero means none native NTSC resolution is aviable
+	 */
+	unsigned int ui4_sink_native_pal_resolution;
+	/* use EDID_VIDEO_RES_T, only one resolution,
+	 *Zero means none native PAL resolution is aviable
+	 */
+	/* use EDID_VIDEO_RES_T */
+	unsigned int ui4_sink_cea_ntsc_resolution;
+	/* use EDID_VIDEO_RES_T */
+	unsigned int ui4_sink_cea_pal_resolution;
+	/* use EDID_VIDEO_RES_T */
+	unsigned int ui4_sink_dtd_ntsc_resolution;
+	/* use EDID_VIDEO_RES_T */
+	unsigned int ui4_sink_dtd_pal_resolution;
+	/* use EDID_VIDEO_RES_T */
+	unsigned int ui4_sink_1st_dtd_ntsc_resolution;
+	/* use EDID_VIDEO_RES_T */
+	unsigned int ui4_sink_1st_dtd_pal_resolution;
+	/* use EDID_VIDEO_COLORIMETRY_T */
+	unsigned short ui2_sink_colorimetry;
+	unsigned char ui1_sink_rgb_color_bit;	/* color bit for RGB */
+	unsigned char ui1_sink_ycbcr_color_bit;	/* color bit for YCbCr */
+	unsigned char ui1_sink_dc420_color_bit;
+	unsigned short ui2_sink_aud_dec;	/* use EDID_AUDIO_DECODER_T */
+	unsigned char ui1_sink_is_plug_in;	/* 1: Plug in 0:Plug Out */
+	unsigned int ui4_hdmi_pcm_ch_type;	/* use EDID_A_FMT_CH_TYPE */
+	/* use EDID_A_FMT_CH_TYPE1 */
+	unsigned int ui4_hdmi_pcm_ch3ch4ch5ch7_type;
+	unsigned int ui4_hdmi_ac3_ch_type;	/* use AVD_AC3_CH_TYPE */
+	/* use AVD_AC3_CH_TYPE1 */
+	unsigned int ui4_hdmi_ac3_ch3ch4ch5ch7_type;
+	unsigned int ui4_hdmi_ec3_ch_type;	/* AVD_DOLBY_PLUS_CH_TYPE */
+	/* AVD_DOLBY_PLUS_CH_TYPE1 */
+	unsigned int ui4_hdmi_ec3_ch3ch4ch5ch7_type;
+	unsigned int ui4_hdmi_dts_ch_type;
+	unsigned int ui4_hdmi_dts_ch3ch4ch5ch7_type;
+	unsigned int ui4_hdmi_dts_hd_ch_type;
+	unsigned int ui4_hdmi_dts_hd_ch3ch4ch5ch7_type;
+	unsigned int ui4_hdmi_pcm_bit_size;
+	unsigned int ui4_hdmi_pcm_ch3ch4ch5ch7_bit_size;
+	/* use EDID_A_FMT_CH_TYPE */
+	unsigned int ui4_dac_pcm_ch_type;
+	unsigned char ui1_sink_support_dolby_atoms;
+	unsigned char ui1_sink_i_latency_present;
+	unsigned int ui1_sink_p_audio_latency;
+	unsigned int ui1_sink_p_video_latency;
+	unsigned int ui1_sink_i_audio_latency;
+	unsigned int ui1_sink_i_video_latency;
+	unsigned char ui1ExtEdid_Revision;
+	unsigned char ui1Edid_Version;
+	unsigned char ui1Edid_Revision;
+	unsigned char ui1_Display_Horizontal_Size;
+	unsigned char ui1_Display_Vertical_Size;
+	unsigned int ui4_ID_Serial_Number;
+	unsigned int ui4_sink_cea_3D_resolution;
+	/* 0: not support AI, 1:support AI */
+	unsigned char ui1_sink_support_ai;
+	unsigned short ui2_sink_cec_address;
+	unsigned short ui1_sink_max_tmds_clock;
+	unsigned short ui2_sink_3D_structure;
+	unsigned int ui4_sink_cea_FP_SUP_3D_resolution;
+	unsigned int ui4_sink_cea_TOB_SUP_3D_resolution;
+	unsigned int ui4_sink_cea_SBS_SUP_3D_resolution;
+	unsigned short ui2_sink_ID_manufacturer_name;/* (08H~09H) */
+	unsigned short ui2_sink_ID_product_code;	/* (0aH~0bH) */
+	unsigned int ui4_sink_ID_serial_number;	/* (0cH~0fH) */
+	unsigned char ui1_sink_week_of_manufacture;	/* (10H) */
+	/* (11H)  base on year 1990 */
+	unsigned char ui1_sink_year_of_manufacture;
+	unsigned char b_sink_SCDC_present;
+	unsigned char b_sink_LTE_340M_sramble;
+	unsigned int ui4_sink_hdmi_4k2kvic;
+	unsigned short ui2_sink_max_tmds_character_rate;
+	unsigned char ui1_sink_support_static_hdr;
+	unsigned char ui1_sink_support_dynamic_hdr;
+	unsigned char ui1_sink_hdr10plus_app_version;
+	unsigned char ui1_sink_hdr_content_max_luminance;
+	unsigned char ui1_sink_hdr_content_max_frame_average_luminance;
+	unsigned char ui1_sink_hdr_content_min_luminance;
+	unsigned int ui4_sink_dolbyvision_vsvdb_length;
+	unsigned int ui4_sink_dolbyvision_vsvdb_version;
+	unsigned int ui4_sink_dolbyvision_vsvdb_v1_low_latency;
+	unsigned int ui4_sink_dolbyvision_vsvdb_v2_interface;
+	unsigned int ui4_sink_dolbyvision_vsvdb_low_latency_support;
+	unsigned int ui4_sink_dolbyvision_vsvdb_v2_supports_10b_12b_444;
+	unsigned int ui4_sink_dolbyvision_vsvdb_support_backlight_control;
+	unsigned int ui4_sink_dolbyvision_vsvdb_backlt_min_lumal;
+	unsigned int ui4_sink_dolbyvision_vsvdb_tmin;
+	unsigned int ui4_sink_dolbyvision_vsvdb_tmax;
+	unsigned int ui4_sink_dolbyvision_vsvdb_tminPQ;
+	unsigned int ui4_sink_dolbyvision_vsvdb_tmaxPQ;
+	unsigned int ui4_sink_dolbyvision_vsvdb_Rx;
+	unsigned int ui4_sink_dolbyvision_vsvdb_Ry;
+	unsigned int ui4_sink_dolbyvision_vsvdb_Gx;
+	unsigned int ui4_sink_dolbyvision_vsvdb_Gy;
+	unsigned int ui4_sink_dolbyvision_vsvdb_Bx;
+	unsigned int ui4_sink_dolbyvision_vsvdb_By;
+	unsigned int ui4_sink_dolbyvision_vsvdb_Wx;
+	unsigned int ui4_sink_dolbyvision_vsvdb_Wy;
+	unsigned char ui1_sink_dolbyvision_block[32];
+	unsigned char ui1rawdata_edid[256];
+};
+
+
+enum HDMI_SHARE_INFO_TYPE_T {
+	SI_EDID_VSDB_EXIST = 0,
+	SI_HDMI_RECEIVER_STATUS,
+	SI_HDMI_PORD_OFF_PLUG_ONLY,
+	SI_EDID_EXT_BLOCK_NO,
+	SI_EDID_PARSING_RESULT,
+	SI_HDMI_SUPPORTS_AI,
+	SI_HDMI_HDCP_RESULT,
+	SI_REPEATER_DEVICE_COUNT,
+	SI_HDMI_CEC_LA,
+	SI_HDMI_CEC_ACTIVE_SOURCE,
+	SI_HDMI_CEC_PROCESS,
+	SI_HDMI_CEC_PARA0,
+	SI_HDMI_CEC_PARA1,
+	SI_HDMI_CEC_PARA2,
+	SI_HDMI_NO_HDCP_TEST,
+	SI_HDMI_SRC_CONTROL,
+	SI_A_CODE_MODE,
+	SI_EDID_AUDIO_CAPABILITY,
+	SI_HDMI_AUDIO_INPUT_SOURCE,
+	SI_HDMI_AUDIO_CH_NUM,
+	SI_HDMI_DVD_AUDIO_PROHIBIT,
+	SI_DVD_HDCP_REVOCATION_RESULT
+};
+#define MAX_HDMI_SHAREINFO  64
+
+extern void hdmi_checkedid(void);
+extern unsigned char hdmi_fgreadedid(unsigned char i1noedid);
+extern void vShowEdidInformation(void);
+extern void vShowEdidRawData(void);
+extern void vClearEdidInfo(void);
+extern void hdmi_AppGetEdidInfo(struct HDMI_EDID_T *pv_get_info);
+extern long long hdmi_DispGetEdidInfo(void);
+extern long long vDispGetHdmiResolution(void);
+extern unsigned char vCheckPcmBitSize(unsigned char ui1ChNumInx);
+extern void hdmi_clear_edid_data(void);
+extern unsigned char hdmi_check_edid_header(void);
+
+extern unsigned int i4SharedInfo(unsigned int u4Index);
+extern void vSetSharedInfo(unsigned int u4Index, unsigned int i4Value);
+
+extern struct HDMI_SINK_AV_CAP_T _HdmiSinkAvCap;
+
+#endif
diff --git a/drivers/gpu/drm/mediatek/mediatek_v2/mtk_hdmi_hdcp.c b/drivers/gpu/drm/mediatek/mediatek_v2/mtk_hdmi_hdcp.c
new file mode 100644
index 0000000000000000000000000000000000000000..a70f9a2ea932aaf24bcdbd9258ebec1d7f2c9444
--- /dev/null
+++ b/drivers/gpu/drm/mediatek/mediatek_v2/mtk_hdmi_hdcp.c
@@ -0,0 +1,51222 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2019 MediaTek Inc.
+ */
+
+
+#ifdef CONFIG_OPTEE
+#include "mtk_hdmi_ca.h"
+#endif
+#include "mtk_hdmi.h"
+#include "mtk_hdmi_regs.h"
+#include "mtk_hdmi_ddc.h"
+#include "mtk_hdmi_hdcp.h"
+#include "mtk_hdmi_edid.h"
+
+#ifndef CONFIG_MTK_HDMI_RX
+#include "mtk_hdmi_rpt.h"
+struct MTK_HDMIRX *hdmirxhandle;
+struct device *hdmirxdev;
+#endif
+
+
+#define REPEAT_CHECK_AUTHHDCP_VALUE 25
+#define MARK_LAST_AUTH_FAIL 0xf0
+#define MARK_FIRST_AUTH_FAIL 0xf1
+
+#define USE_INT_HDCP
+#define SUPPORT_SIMPLAY
+#define SRM_SUPPORT
+
+#define HDMI_OK	     (unsigned int)(0)
+#define HDMI_FAIL     (unsigned int)(-1)
+
+
+#define SV_OK	     (unsigned char)(0)
+#define SV_FAIL      (unsigned char)(-1)
+
+/* #define SUPPORT_SOFT_SHA */
+/* for debug message */
+#define DEBUG_HDCP_RI
+#define DEBUG_HDCP
+/* #define DEBUG_HDCP_RI_AN_FIX */
+#define SRM_DBG
+/* #define SUPPORT_RI_SAME_WAIT_NEXT_SYNC_UPDATE 1
+ * move it to hdmi_drv.h
+ */
+//static enum HDMI_HDCP_KEY_T bhdcpkey = EXTERNAL_KEY;
+/* no encrypt key */
+const unsigned char HDCP_NOENCRYPT_KEY[HDCP_KEY_RESERVE] = {
+	0
+};
+
+/* encrypt key */
+const unsigned char HDCP_ENCRYPT_KEY[HDCP_KEY_RESERVE] = {
+	0
+};
+
+atomic_t hdmi_hdcp_event = ATOMIC_INIT(0);
+
+#ifdef SRM_SUPPORT
+struct SRMINFO {
+	unsigned int dwVRLLenInDram;
+	unsigned int dwVer;
+
+	unsigned char bID;
+};
+
+struct SRMINFO _rSRMInfo;
+
+unsigned char _bHdcp_Bksv[5];
+//unsigned char _bLastHdcpStatus = SV_OK;
+
+unsigned char _bHdcpStatus = SV_OK;
+unsigned char _u1SRMSignatureChkFlag;
+#endif
+
+unsigned int _u14SeqMnum;
+
+static unsigned char _bReAuthCnt;
+static unsigned char _bReRepeaterPollCnt;
+static unsigned char _bReCertPollCnt;
+static unsigned char _bReRepeaterDoneCnt;
+struct HDMI_HDCP_BKSV_INFO hdmi_hdcp_info;
+static unsigned char _bReAKEtPollCnt;
+
+
+#ifdef CONFIG_OPTEE
+static unsigned char u1CaHdcpAKsv[HDCP_AKSV_COUNT];
+#endif
+
+#define HDCP_KEY_RESERVE 287
+
+unsigned char bHdcpKeyBuff[HDCP_KEY_RESERVE] = { };
+
+unsigned char HDMI_AKSV[HDCP_AKSV_COUNT];
+unsigned char bKsv_buff[KSV_BUFF_SIZE];
+unsigned char HDCPBuff[60];
+unsigned char bKsvlist_buff[KSV_LIST_SIZE];
+unsigned char bKsvlist[KSV_LIST_SIZE];
+
+
+unsigned char bSHABuff[20];	/* SHA hash value 20 bytes */
+unsigned char _bReCheckBstatusCount;
+unsigned char _bReCompRiCount;
+unsigned char _bReCheckReadyBit;
+
+unsigned char _bSRMBuff[SRM_SIZE];
+
+unsigned char _bTxBKAV[HDCP_AKSV_COUNT] = { 0 };
+
+unsigned char _bDevice_Count;
+unsigned int _u2TxBStatus;
+
+
+unsigned long hdcp_unmute_start_time;
+unsigned long hdcp_logo_start_time;
+unsigned int hdcp_unmute_logo_flag = 0xff;
+bool hdcp_unmute_start_flag;
+
+unsigned char hdcp_pram[16384] = {
+	0x02,
+	0x00,
+	0x25,
+	0x02,
+	0x01,
+	0xa9,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0x02,
+	0x00,
+	0xb0,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0x02,
+	0x02,
+	0x0f,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0x02,
+	0x00,
+	0xef,
+	0x12,
+	0x03,
+	0x10,
+	0x80,
+	0xfe,
+	0xe4,
+	0x73,
+	0x75,
+	0x81,
+	0x20,
+	0x12,
+	0x00,
+	0xaa,
+	0xe5,
+	0x82,
+	0x60,
+	0x03,
+	0x02,
+	0x00,
+	0x1e,
+	0x79,
+	0x00,
+	0xe9,
+	0x44,
+	0x00,
+	0x60,
+	0x1b,
+	0x7a,
+	0x00,
+	0x90,
+	0x21,
+	0xad,
+	0x78,
+	0x00,
+	0x75,
+	0xa0,
+	0x00,
+	0xe4,
+	0x93,
+	0xf2,
+	0xa3,
+	0x08,
+	0xb8,
+	0x00,
+	0x02,
+	0x05,
+	0xa0,
+	0xd9,
+	0xf4,
+	0xda,
+	0xf2,
+	0x75,
+	0xa0,
+	0xff,
+	0xe4,
+	0x78,
+	0xff,
+	0xf6,
+	0xd8,
+	0xfd,
+	0x78,
+	0x00,
+	0xe8,
+	0x44,
+	0x00,
+	0x60,
+	0x0a,
+	0x79,
+	0x00,
+	0x75,
+	0xa0,
+	0x00,
+	0xe4,
+	0xf3,
+	0x09,
+	0xd8,
+	0xfc,
+	0x78,
+	0x00,
+	0xe8,
+	0x44,
+	0x00,
+	0x60,
+	0x0c,
+	0x79,
+	0x00,
+	0x90,
+	0x00,
+	0x00,
+	0xe4,
+	0xf0,
+	0xa3,
+	0xd8,
+	0xfc,
+	0xd9,
+	0xfa,
+	0x02,
+	0x00,
+	0x1e,
+	0xc0,
+	0x12,
+	0x85,
+	0x81,
+	0x12,
+	0xac,
+	0x82,
+	0xad,
+	0x83,
+	0xae,
+	0xf0,
+	0xff,
+	0xe5,
+	0x12,
+	0x24,
+	0xfa,
+	0xf8,
+	0x86,
+	0x13,
+	0x08,
+	0x86,
+	0x14,
+	0x08,
+	0x86,
+	0x15,
+	0x08,
+	0x86,
+	0x16,
+	0x8c,
+	0x82,
+	0x8d,
+	0x83,
+	0x8e,
+	0xf0,
+	0xef,
+	0x12,
+	0x20,
+	0xf7,
+	0xd0,
+	0x12,
+	0x22,
+	0xc2,
+	0xaf,
+	0x90,
+	0x00,
+	0x01,
+	0x22,
+	0xc0,
+	0xe0,
+	0xc0,
+	0x82,
+	0xc0,
+	0x83,
+	0xc0,
+	0xd0,
+	0x75,
+	0xd0,
+	0x08,
+	0x90,
+	0x69,
+	0xd9,
+	0xe0,
+	0x24,
+	0x01,
+	0xf0,
+	0x90,
+	0x69,
+	0xd9,
+	0xe0,
+	0xff,
+	0x90,
+	0x69,
+	0xd8,
+	0xe0,
+	0xfe,
+	0xc3,
+	0xef,
+	0x9e,
+	0x40,
+	0x0a,
+	0xc2,
+	0x8c,
+	0x90,
+	0x69,
+	0xe1,
+	0x74,
+	0x01,
+	0xf0,
+	0x80,
+	0x0b,
+	0x90,
+	0x30,
+	0x31,
+	0xe0,
+	0xff,
+	0x74,
+	0xff,
+	0xc3,
+	0x9f,
+	0xf5,
+	0x8c,
+	0xd0,
+	0xd0,
+	0xd0,
+	0x83,
+	0xd0,
+	0x82,
+	0xd0,
+	0xe0,
+	0x32,
+	0xc0,
+	0xe0,
+	0xc0,
+	0x82,
+	0xc0,
+	0x83,
+	0xc0,
+	0xd0,
+	0x75,
+	0xd0,
+	0x08,
+	0x90,
+	0x69,
+	0xdb,
+	0xe0,
+	0x24,
+	0x01,
+	0xf0,
+	0x90,
+	0x69,
+	0xdb,
+	0xe0,
+	0xff,
+	0x90,
+	0x69,
+	0xda,
+	0xe0,
+	0xfe,
+	0xc3,
+	0xef,
+	0x9e,
+	0x50,
+	0x03,
+	0x02,
+	0x01,
+	0x95,
+	0x90,
+	0x69,
+	0xf6,
+	0xe0,
+	0xff,
+	0x60,
+	0x53,
+	0x90,
+	0x69,
+	0xf4,
+	0xe0,
+	0xff,
+	0x60,
+	0x1c,
+	0x90,
+	0x69,
+	0xf4,
+	0xe4,
+	0xf0,
+	0x90,
+	0x69,
+	0xf5,
+	0xf0,
+	0x90,
+	0x69,
+	0xf2,
+	0xf0,
+	0x90,
+	0x69,
+	0xef,
+	0xf0,
+	0x90,
+	0x69,
+	0xf1,
+	0xe4,
+	0xf0,
+	0x90,
+	0x30,
+	0x07,
+	0xf0,
+	0x80,
+	0x24,
+	0x90,
+	0x69,
+	0xf5,
+	0xe0,
+	0xff,
+	0x70,
+	0x15,
+	0x90,
+	0x69,
+	0xf2,
+	0xe0,
+	0xff,
+	0x70,
+	0x0e,
+	0x90,
+	0x69,
+	0xef,
+	0xe0,
+	0xff,
+	0x70,
+	0x07,
+	0x90,
+	0x69,
+	0xf1,
+	0xe0,
+	0x24,
+	0x01,
+	0xf0,
+	0x90,
+	0x30,
+	0x07,
+	0xe0,
+	0xff,
+	0x44,
+	0x02,
+	0xf0,
+	0xc2,
+	0x8e,
+	0x75,
+	0xff,
+	0x01,
+	0x90,
+	0x30,
+	0x0c,
+	0xe4,
+	0xf0,
+	0x80,
+	0x20,
+	0xc2,
+	0x8e,
+	0x75,
+	0xff,
+	0x01,
+	0x90,
+	0x30,
+	0x0c,
+	0xe4,
+	0xf0,
+	0x90,
+	0x30,
+	0x02,
+	0xe0,
+	0xff,
+	0x53,
+	0x0f,
+	0x20,
+	0xbf,
+	0x20,
+	0x04,
+	0x7f,
+	0x42,
+	0x80,
+	0x02,
+	0x7f,
+	0x00,
+	0x90,
+	0x30,
+	0x07,
+	0xef,
+	0xf0,
+	0x75,
+	0xf7,
+	0x01,
+	0x75,
+	0xf7,
+	0x01,
+	0x80,
+	0x0b,
+	0x90,
+	0x30,
+	0x31,
+	0xe0,
+	0xff,
+	0x74,
+	0xff,
+	0xc3,
+	0x9f,
+	0xf5,
+	0x8d,
+	0xd0,
+	0xd0,
+	0xd0,
+	0x83,
+	0xd0,
+	0x82,
+	0xd0,
+	0xe0,
+	0x32,
+	0xc0,
+	0xe0,
+	0xc0,
+	0x82,
+	0xc0,
+	0x83,
+	0xc0,
+	0xd0,
+	0x75,
+	0xd0,
+	0x08,
+	0x90,
+	0x69,
+	0xf6,
+	0xe0,
+	0xff,
+	0x60,
+	0x26,
+	0x90,
+	0x69,
+	0xe2,
+	0x74,
+	0x01,
+	0xf0,
+	0x90,
+	0x30,
+	0x07,
+	0xe4,
+	0xf0,
+	0x90,
+	0x69,
+	0xf1,
+	0xf0,
+	0x90,
+	0x69,
+	0xf2,
+	0xf0,
+	0x90,
+	0x69,
+	0xef,
+	0xf0,
+	0x90,
+	0x69,
+	0xf5,
+	0xe4,
+	0xf0,
+	0x90,
+	0x30,
+	0x45,
+	0xf0,
+	0x90,
+	0x30,
+	0x0c,
+	0xf0,
+	0x80,
+	0x1f,
+	0x90,
+	0x30,
+	0x02,
+	0xe0,
+	0xff,
+	0x53,
+	0x0f,
+	0x20,
+	0xbf,
+	0x20,
+	0x04,
+	0x7f,
+	0x40,
+	0x80,
+	0x02,
+	0x7f,
+	0x00,
+	0x90,
+	0x30,
+	0x07,
+	0xef,
+	0xf0,
+	0x90,
+	0x69,
+	0xe7,
+	0xe4,
+	0xf0,
+	0x90,
+	0x6c,
+	0x34,
+	0xf0,
+	0x75,
+	0xf7,
+	0x01,
+	0x75,
+	0xf7,
+	0x01,
+	0xd0,
+	0xd0,
+	0xd0,
+	0x83,
+	0xd0,
+	0x82,
+	0xd0,
+	0xe0,
+	0x32,
+	0xc0,
+	0x20,
+	0xc0,
+	0xe0,
+	0xc0,
+	0xf0,
+	0xc0,
+	0x82,
+	0xc0,
+	0x83,
+	0xc0,
+	0x07,
+	0xc0,
+	0x06,
+	0xc0,
+	0x05,
+	0xc0,
+	0x04,
+	0xc0,
+	0x03,
+	0xc0,
+	0x02,
+	0xc0,
+	0x01,
+	0xc0,
+	0x00,
+	0xc0,
+	0xd0,
+	0x75,
+	0xd0,
+	0x08,
+	0xc2,
+	0xaa,
+	0x90,
+	0x69,
+	0xe3,
+	0x74,
+	0x01,
+	0xf0,
+	0x90,
+	0x69,
+	0xe4,
+	0xe5,
+	0xa0,
+	0xf0,
+	0x90,
+	0x69,
+	0xf6,
+	0xe0,
+	0xff,
+	0x70,
+	0x36,
+	0x90,
+	0x69,
+	0xe4,
+	0xe0,
+	0xff,
+	0xbf,
+	0x02,
+	0x2e,
+	0x90,
+	0x30,
+	0x07,
+	0xe4,
+	0xf0,
+	0x90,
+	0x6d,
+	0x08,
+	0xe0,
+	0xfe,
+	0xa3,
+	0xe0,
+	0xff,
+	0xc0,
+	0x0f,
+	0xc0,
+	0x0e,
+	0x8e,
+	0x82,
+	0x8f,
+	0x83,
+	0x75,
+	0xd0,
+	0x00,
+	0x12,
+	0x00,
+	0x23,
+	0x75,
+	0xd0,
+	0x08,
+	0xd0,
+	0x0e,
+	0xd0,
+	0x0f,
+	0x90,
+	0x6c,
+	0x34,
+	0x74,
+	0x01,
+	0xf0,
+	0x75,
+	0xf7,
+	0x01,
+	0x75,
+	0xf7,
+	0x01,
+	0xd0,
+	0xd0,
+	0xd0,
+	0x00,
+	0xd0,
+	0x01,
+	0xd0,
+	0x02,
+	0xd0,
+	0x03,
+	0xd0,
+	0x04,
+	0xd0,
+	0x05,
+	0xd0,
+	0x06,
+	0xd0,
+	0x07,
+	0xd0,
+	0x83,
+	0xd0,
+	0x82,
+	0xd0,
+	0xf0,
+	0xd0,
+	0xe0,
+	0xd0,
+	0x20,
+	0x32,
+	0xc2,
+	0x8c,
+	0xc2,
+	0xa9,
+	0xc2,
+	0x8e,
+	0xc2,
+	0xab,
+	0x22,
+	0xaf,
+	0x82,
+	0x90,
+	0x69,
+	0xd8,
+	0xef,
+	0xf0,
+	0x90,
+	0x69,
+	0xd9,
+	0xe4,
+	0xf0,
+	0x90,
+	0x30,
+	0x31,
+	0xe0,
+	0xff,
+	0x74,
+	0xff,
+	0xc3,
+	0x9f,
+	0xf5,
+	0x8c,
+	0xd2,
+	0x8c,
+	0xd2,
+	0xa9,
+	0x22,
+	0xaf,
+	0x82,
+	0x90,
+	0x69,
+	0xd8,
+	0xef,
+	0xf0,
+	0x90,
+	0x69,
+	0xd9,
+	0xe4,
+	0xf0,
+	0x75,
+	0x8c,
+	0x00,
+	0xd2,
+	0x8c,
+	0xd2,
+	0xa9,
+	0x22,
+	0xaf,
+	0x82,
+	0x90,
+	0x69,
+	0xda,
+	0xef,
+	0xf0,
+	0x90,
+	0x69,
+	0xdb,
+	0xe4,
+	0xf0,
+	0x90,
+	0x30,
+	0x31,
+	0xe0,
+	0xff,
+	0x74,
+	0xff,
+	0xc3,
+	0x9f,
+	0xf5,
+	0x8d,
+	0xd2,
+	0x8e,
+	0xd2,
+	0xab,
+	0x22,
+	0x90,
+	0x30,
+	0x0a,
+	0xe0,
+	0xff,
+	0xbf,
+	0xdb,
+	0x12,
+	0x90,
+	0x69,
+	0xf6,
+	0xe0,
+	0xff,
+	0x60,
+	0x04,
+	0x7f,
+	0x02,
+	0x80,
+	0x02,
+	0x7f,
+	0x84,
+	0x90,
+	0x30,
+	0x02,
+	0xef,
+	0xf0,
+	0x90,
+	0x30,
+	0x32,
+	0xe0,
+	0xf5,
+	0x82,
+	0x12,
+	0x02,
+	0xcf,
+	0x80,
+	0xfe,
+	0x90,
+	0x30,
+	0x01,
+	0x74,
+	0xab,
+	0xf0,
+	0x90,
+	0x69,
+	0xf4,
+	0xe4,
+	0xf0,
+	0x90,
+	0x30,
+	0x04,
+	0xe0,
+	0xff,
+	0x53,
+	0x07,
+	0x10,
+	0xe4,
+	0xbf,
+	0x00,
+	0x01,
+	0x04,
+	0xff,
+	0x90,
+	0x69,
+	0xf6,
+	0xb4,
+	0x01,
+	0x00,
+	0xe4,
+	0x33,
+	0xf0,
+	0x90,
+	0x69,
+	0xf6,
+	0xe0,
+	0xff,
+	0x60,
+	0x08,
+	0x90,
+	0x30,
+	0x00,
+	0x74,
+	0x2f,
+	0xf0,
+	0x80,
+	0x06,
+	0x90,
+	0x30,
+	0x00,
+	0x74,
+	0x1f,
+	0xf0,
+	0x90,
+	0x69,
+	0xf6,
+	0xe0,
+	0xff,
+	0x70,
+	0x71,
+	0xfe,
+	0xff,
+	0xc3,
+	0xee,
+	0x94,
+	0x05,
+	0xef,
+	0x64,
+	0x80,
+	0x94,
+	0x80,
+	0x50,
+	0x25,
+	0x8e,
+	0x05,
+	0x74,
+	0x04,
+	0xc3,
+	0x9d,
+	0x24,
+	0x40,
+	0xfc,
+	0xe4,
+	0x34,
+	0x30,
+	0xfd,
+	0xee,
+	0x24,
+	0x40,
+	0xf5,
+	0x82,
+	0xef,
+	0x34,
+	0x05,
+	0xf5,
+	0x83,
+	0xe0,
+	0xfb,
+	0x8c,
+	0x82,
+	0x8d,
+	0x83,
+	0xf0,
+	0x0e,
+	0xbe,
+	0x00,
+	0xd3,
+	0x0f,
+	0x80,
+	0xd0,
+	0x90,
+	0x69,
+	0xbc,
+	0xe0,
+	0xff,
+	0xbf,
+	0x5a,
+	0x1a,
+	0x90,
+	0x69,
+	0xbd,
+	0xe0,
+	0xff,
+	0xbf,
+	0xf0,
+	0x12,
+	0x90,
+	0x69,
+	0xbe,
+	0xe0,
+	0xff,
+	0xbf,
+	0x0f,
+	0x0a,
+	0x90,
+	0x69,
+	0xbf,
+	0xe0,
+	0xff,
+	0xbf,
+	0xa5,
+	0x02,
+	0x80,
+	0x1d,
+	0x90,
+	0x6c,
+	0x34,
+	0xe4,
+	0xf0,
+	0x90,
+	0x69,
+	0xbc,
+	0x74,
+	0x5a,
+	0xf0,
+	0x90,
+	0x69,
+	0xbd,
+	0x74,
+	0xf0,
+	0xf0,
+	0x90,
+	0x69,
+	0xbe,
+	0x74,
+	0x0f,
+	0xf0,
+	0x90,
+	0x69,
+	0xbf,
+	0x74,
+	0xa5,
+	0xf0,
+	0x75,
+	0xff,
+	0x01,
+	0x90,
+	0x6c,
+	0xc8,
+	0x74,
+	0x29,
+	0xf0,
+	0xa3,
+	0x74,
+	0x9f,
+	0xf0,
+	0x90,
+	0x6c,
+	0xcc,
+	0x74,
+	0x8f,
+	0xf0,
+	0xa3,
+	0x74,
+	0xa1,
+	0xf0,
+	0x90,
+	0x6c,
+	0xbc,
+	0x74,
+	0xa1,
+	0xf0,
+	0xa3,
+	0x74,
+	0xa3,
+	0xf0,
+	0x90,
+	0x6c,
+	0xc0,
+	0x74,
+	0x68,
+	0xf0,
+	0xa3,
+	0x74,
+	0xa4,
+	0xf0,
+	0x90,
+	0x6c,
+	0xc4,
+	0x74,
+	0x9f,
+	0xf0,
+	0xa3,
+	0x74,
+	0xa7,
+	0xf0,
+	0x90,
+	0x6c,
+	0xd0,
+	0x74,
+	0xa3,
+	0xf0,
+	0xa3,
+	0x74,
+	0xa8,
+	0xf0,
+	0x90,
+	0x6c,
+	0x50,
+	0x74,
+	0xa5,
+	0xf0,
+	0xa3,
+	0x74,
+	0xb3,
+	0xf0,
+	0x90,
+	0x6c,
+	0x54,
+	0x74,
+	0xbd,
+	0xf0,
+	0xa3,
+	0x74,
+	0xc6,
+	0xf0,
+	0x90,
+	0x6c,
+	0x58,
+	0x74,
+	0xe0,
+	0xf0,
+	0xa3,
+	0x74,
+	0xc5,
+	0xf0,
+	0x90,
+	0x6c,
+	0x5c,
+	0x74,
+	0xc1,
+	0xf0,
+	0xa3,
+	0x74,
+	0xc4,
+	0xf0,
+	0x90,
+	0x6c,
+	0x60,
+	0x74,
+	0x57,
+	0xf0,
+	0xa3,
+	0x74,
+	0xc2,
+	0xf0,
+	0x90,
+	0x6c,
+	0x64,
+	0x74,
+	0xea,
+	0xf0,
+	0xa3,
+	0x74,
+	0xc1,
+	0xf0,
+	0x90,
+	0x6c,
+	0x68,
+	0x74,
+	0x9d,
+	0xf0,
+	0xa3,
+	0x74,
+	0xc1,
+	0xf0,
+	0x90,
+	0x6c,
+	0x6c,
+	0x74,
+	0x44,
+	0xf0,
+	0xa3,
+	0x74,
+	0xc1,
+	0xf0,
+	0x90,
+	0x6c,
+	0x70,
+	0x74,
+	0xb5,
+	0xf0,
+	0xa3,
+	0x74,
+	0xc0,
+	0xf0,
+	0x90,
+	0x6c,
+	0x74,
+	0x74,
+	0x4a,
+	0xf0,
+	0xa3,
+	0x74,
+	0xc0,
+	0xf0,
+	0x90,
+	0x6c,
+	0x78,
+	0x74,
+	0x13,
+	0xf0,
+	0xa3,
+	0x74,
+	0xc0,
+	0xf0,
+	0x90,
+	0x6c,
+	0x7c,
+	0x74,
+	0xc6,
+	0xf0,
+	0xa3,
+	0x74,
+	0xbf,
+	0xf0,
+	0x90,
+	0x6c,
+	0x80,
+	0x74,
+	0xe1,
+	0xf0,
+	0xa3,
+	0x74,
+	0xbe,
+	0xf0,
+	0x90,
+	0x6c,
+	0x84,
+	0x74,
+	0xb2,
+	0xf0,
+	0xa3,
+	0x74,
+	0xbe,
+	0xf0,
+	0x90,
+	0x6c,
+	0x88,
+	0x74,
+	0x23,
+	0xf0,
+	0xa3,
+	0x74,
+	0xbe,
+	0xf0,
+	0x90,
+	0x6c,
+	0x8c,
+	0x74,
+	0xaa,
+	0xf0,
+	0xa3,
+	0x74,
+	0xbd,
+	0xf0,
+	0x90,
+	0x6c,
+	0x90,
+	0x74,
+	0x9a,
+	0xf0,
+	0xa3,
+	0x74,
+	0xbc,
+	0xf0,
+	0x90,
+	0x6c,
+	0x94,
+	0x74,
+	0xb4,
+	0xf0,
+	0xa3,
+	0x74,
+	0xba,
+	0xf0,
+	0x90,
+	0x6c,
+	0x98,
+	0x74,
+	0x83,
+	0xf0,
+	0xa3,
+	0x74,
+	0xb7,
+	0xf0,
+	0x90,
+	0x6c,
+	0x9c,
+	0x74,
+	0x36,
+	0xf0,
+	0xa3,
+	0x74,
+	0xb3,
+	0xf0,
+	0x90,
+	0x6c,
+	0xa0,
+	0x74,
+	0xea,
+	0xf0,
+	0xa3,
+	0x74,
+	0xb2,
+	0xf0,
+	0x90,
+	0x6c,
+	0xa4,
+	0x74,
+	0x0c,
+	0xf0,
+	0xa3,
+	0x74,
+	0xb7,
+	0xf0,
+	0x90,
+	0x6c,
+	0xa8,
+	0x74,
+	0x28,
+	0xf0,
+	0xa3,
+	0x74,
+	0xb7,
+	0xf0,
+	0x90,
+	0x6c,
+	0xac,
+	0x74,
+	0x76,
+	0xf0,
+	0xa3,
+	0x74,
+	0xbe,
+	0xf0,
+	0x90,
+	0x6c,
+	0xb0,
+	0x74,
+	0x85,
+	0xf0,
+	0xa3,
+	0x74,
+	0xc0,
+	0xf0,
+	0x90,
+	0x6c,
+	0xb4,
+	0x74,
+	0x81,
+	0xf0,
+	0xa3,
+	0x74,
+	0xc6,
+	0xf0,
+	0x90,
+	0x6c,
+	0xb8,
+	0x74,
+	0x03,
+	0xf0,
+	0xa3,
+	0x74,
+	0xb7,
+	0xf0,
+	0x90,
+	0x6c,
+	0xd4,
+	0x74,
+	0xf3,
+	0xf0,
+	0xa3,
+	0x74,
+	0xd7,
+	0xf0,
+	0x90,
+	0x6c,
+	0xd8,
+	0x74,
+	0x8e,
+	0xf0,
+	0xa3,
+	0x74,
+	0xd7,
+	0xf0,
+	0x90,
+	0x6c,
+	0xdc,
+	0x74,
+	0x3b,
+	0xf0,
+	0xa3,
+	0x74,
+	0xd7,
+	0xf0,
+	0x90,
+	0x6c,
+	0xe0,
+	0x74,
+	0x99,
+	0xf0,
+	0xa3,
+	0x74,
+	0xd6,
+	0xf0,
+	0x90,
+	0x6c,
+	0xe4,
+	0x74,
+	0x59,
+	0xf0,
+	0xa3,
+	0x74,
+	0xd6,
+	0xf0,
+	0x90,
+	0x6c,
+	0xe8,
+	0x74,
+	0x1b,
+	0xf0,
+	0xa3,
+	0x74,
+	0xd6,
+	0xf0,
+	0x90,
+	0x6c,
+	0xec,
+	0x74,
+	0xdc,
+	0xf0,
+	0xa3,
+	0x74,
+	0xd4,
+	0xf0,
+	0x90,
+	0x6c,
+	0xf0,
+	0x74,
+	0x7f,
+	0xf0,
+	0xa3,
+	0x74,
+	0xd4,
+	0xf0,
+	0x90,
+	0x6c,
+	0xf4,
+	0x74,
+	0x22,
+	0xf0,
+	0xa3,
+	0x74,
+	0xd4,
+	0xf0,
+	0x90,
+	0x6c,
+	0xf8,
+	0x74,
+	0x96,
+	0xf0,
+	0xa3,
+	0x74,
+	0xd3,
+	0xf0,
+	0x90,
+	0x6c,
+	0xfc,
+	0x74,
+	0xdd,
+	0xf0,
+	0xa3,
+	0x74,
+	0xd2,
+	0xf0,
+	0x90,
+	0x6d,
+	0x00,
+	0x74,
+	0xfc,
+	0xf0,
+	0xa3,
+	0x74,
+	0xd1,
+	0xf0,
+	0x90,
+	0x6d,
+	0x04,
+	0x74,
+	0x03,
+	0xf0,
+	0xa3,
+	0x74,
+	0xd0,
+	0xf0,
+	0x90,
+	0x6d,
+	0x08,
+	0x74,
+	0xfe,
+	0xf0,
+	0xa3,
+	0x74,
+	0xad,
+	0xf0,
+	0x90,
+	0x69,
+	0xe2,
+	0xe4,
+	0xf0,
+	0x90,
+	0x69,
+	0xe3,
+	0xf0,
+	0x90,
+	0x69,
+	0xe1,
+	0xf0,
+	0x90,
+	0x69,
+	0xe9,
+	0xf0,
+	0x90,
+	0x69,
+	0xf6,
+	0xe0,
+	0xff,
+	0x60,
+	0x2a,
+	0x90,
+	0x30,
+	0x0c,
+	0xe4,
+	0xf0,
+	0x90,
+	0x30,
+	0x04,
+	0xe0,
+	0xff,
+	0x90,
+	0x69,
+	0xe7,
+	0x74,
+	0x07,
+	0x5f,
+	0xf0,
+	0x90,
+	0x30,
+	0x04,
+	0xe0,
+	0xff,
+	0x53,
+	0x07,
+	0x20,
+	0xe4,
+	0xbf,
+	0x00,
+	0x01,
+	0x04,
+	0xff,
+	0x90,
+	0x69,
+	0xe8,
+	0xb4,
+	0x01,
+	0x00,
+	0xe4,
+	0x33,
+	0xf0,
+	0x80,
+	0x3a,
+	0x90,
+	0x30,
+	0x04,
+	0xe0,
+	0xff,
+	0x90,
+	0x69,
+	0xe5,
+	0x74,
+	0x07,
+	0x5f,
+	0xf0,
+	0x90,
+	0x30,
+	0x04,
+	0xe0,
+	0xff,
+	0x53,
+	0x07,
+	0x20,
+	0xe4,
+	0xbf,
+	0x00,
+	0x01,
+	0x04,
+	0xff,
+	0x90,
+	0x69,
+	0xe6,
+	0xb4,
+	0x01,
+	0x00,
+	0xe4,
+	0x33,
+	0xf0,
+	0x90,
+	0x30,
+	0x04,
+	0xe0,
+	0xff,
+	0x53,
+	0x07,
+	0x80,
+	0xe4,
+	0xbf,
+	0x00,
+	0x01,
+	0x04,
+	0xff,
+	0x90,
+	0x30,
+	0x45,
+	0xb4,
+	0x01,
+	0x00,
+	0xe4,
+	0x33,
+	0xf0,
+	0x90,
+	0x30,
+	0x04,
+	0xe0,
+	0xff,
+	0x53,
+	0x07,
+	0x40,
+	0xe4,
+	0xbf,
+	0x00,
+	0x01,
+	0x04,
+	0xff,
+	0x90,
+	0x69,
+	0xf7,
+	0xb4,
+	0x01,
+	0x00,
+	0xe4,
+	0x33,
+	0xf0,
+	0x90,
+	0x30,
+	0x08,
+	0xe4,
+	0xf0,
+	0x90,
+	0x69,
+	0xf6,
+	0xe0,
+	0xff,
+	0x60,
+	0x29,
+	0x90,
+	0x69,
+	0xe7,
+	0xe0,
+	0xff,
+	0xbf,
+	0x0a,
+	0x00,
+	0x50,
+	0x1f,
+	0x90,
+	0x69,
+	0xe5,
+	0xe0,
+	0xff,
+	0x24,
+	0xfe,
+	0x40,
+	0x16,
+	0x90,
+	0x69,
+	0xe7,
+	0xe0,
+	0xff,
+	0xbf,
+	0x02,
+	0x00,
+	0x40,
+	0x0c,
+	0x90,
+	0x69,
+	0xe8,
+	0xe0,
+	0xff,
+	0xbf,
+	0x01,
+	0x04,
+	0x90,
+	0x69,
+	0xe8,
+	0xe0,
+	0xc2,
+	0x8c,
+	0xc2,
+	0x8e,
+	0xd2,
+	0xa8,
+	0xd2,
+	0xaa,
+	0xc2,
+	0xa9,
+	0xc2,
+	0xab,
+	0xd2,
+	0xaf,
+	0x75,
+	0x8a,
+	0x00,
+	0x90,
+	0x30,
+	0x31,
+	0xe0,
+	0xff,
+	0x74,
+	0xff,
+	0xc3,
+	0x9f,
+	0xf5,
+	0x8c,
+	0x75,
+	0x8b,
+	0x00,
+	0x90,
+	0x30,
+	0x31,
+	0xe0,
+	0xff,
+	0x74,
+	0xff,
+	0xc3,
+	0x9f,
+	0xf5,
+	0x8d,
+	0x75,
+	0x89,
+	0x55,
+	0x90,
+	0x69,
+	0xf6,
+	0xe0,
+	0xff,
+	0x60,
+	0x08,
+	0x90,
+	0x30,
+	0x07,
+	0xe0,
+	0xff,
+	0x54,
+	0x70,
+	0xf0,
+	0x90,
+	0x30,
+	0x0a,
+	0xe0,
+	0xff,
+	0xbf,
+	0xdb,
+	0x12,
+	0x90,
+	0x69,
+	0xf6,
+	0xe0,
+	0xff,
+	0x60,
+	0x04,
+	0x7f,
+	0x2c,
+	0x80,
+	0x02,
+	0x7f,
+	0xa2,
+	0x90,
+	0x30,
+	0x02,
+	0xef,
+	0xf0,
+	0x90,
+	0x30,
+	0x06,
+	0xe0,
+	0xff,
+	0x53,
+	0x07,
+	0x80,
+	0xbf,
+	0x80,
+	0x16,
+	0x90,
+	0x30,
+	0x02,
+	0xe0,
+	0xff,
+	0x53,
+	0x07,
+	0x10,
+	0xe4,
+	0xbf,
+	0x10,
+	0x01,
+	0x04,
+	0xff,
+	0xb4,
+	0x01,
+	0x00,
+	0xe4,
+	0x33,
+	0xff,
+	0x70,
+	0x04,
+	0x7f,
+	0x00,
+	0x80,
+	0x02,
+	0x7f,
+	0x01,
+	0x90,
+	0x69,
+	0x8f,
+	0xef,
+	0xf0,
+	0x90,
+	0x44,
+	0x02,
+	0x74,
+	0x81,
+	0xf0,
+	0x90,
+	0x69,
+	0xf6,
+	0xe0,
+	0xff,
+	0x70,
+	0x03,
+	0x02,
+	0x15,
+	0xa5,
+	0x90,
+	0x30,
+	0x01,
+	0xe0,
+	0xff,
+	0x20,
+	0xe3,
+	0x0b,
+	0x90,
+	0x30,
+	0x06,
+	0xe0,
+	0xff,
+	0x53,
+	0x07,
+	0x80,
+	0xbf,
+	0x80,
+	0x08,
+	0x90,
+	0x30,
+	0x07,
+	0xe0,
+	0xff,
+	0x54,
+	0x70,
+	0xf0,
+	0x90,
+	0x30,
+	0x03,
+	0xe0,
+	0xff,
+	0xbf,
+	0xff,
+	0x06,
+	0x75,
+	0xf7,
+	0x01,
+	0x75,
+	0xf7,
+	0x01,
+	0x90,
+	0x30,
+	0x03,
+	0xe0,
+	0xff,
+	0xbf,
+	0xdb,
+	0x3f,
+	0x90,
+	0x69,
+	0xe1,
+	0xe4,
+	0xf0,
+	0x12,
+	0x02,
+	0x96,
+	0x90,
+	0x30,
+	0x32,
+	0xe0,
+	0xf5,
+	0x82,
+	0x12,
+	0x02,
+	0x9f,
+	0x7f,
+	0x00,
+	0x90,
+	0x30,
+	0x03,
+	0xe0,
+	0xfe,
+	0xbe,
+	0xdb,
+	0x24,
+	0x90,
+	0x69,
+	0xe1,
+	0xe0,
+	0xfe,
+	0x60,
+	0xf1,
+	0x90,
+	0x69,
+	0xe1,
+	0xe4,
+	0xf0,
+	0xc0,
+	0x07,
+	0x12,
+	0x02,
+	0x96,
+	0x90,
+	0x30,
+	0x32,
+	0xe0,
+	0xf5,
+	0x82,
+	0x12,
+	0x02,
+	0x9f,
+	0xd0,
+	0x07,
+	0x90,
+	0x30,
+	0x03,
+	0xef,
+	0xf0,
+	0x0f,
+	0x80,
+	0xd4,
+	0x90,
+	0x30,
+	0x00,
+	0xe0,
+	0xff,
+	0xbf,
+	0x20,
+	0x03,
+	0x75,
+	0xff,
+	0x01,
+	0x90,
+	0x30,
+	0x06,
+	0xe0,
+	0xff,
+	0x30,
+	0xe6,
+	0x31,
+	0x90,
+	0x69,
+	0xf4,
+	0x74,
+	0x01,
+	0xf0,
+	0x90,
+	0x30,
+	0x06,
+	0xe0,
+	0x54,
+	0x41,
+	0xf0,
+	0x90,
+	0x30,
+	0x07,
+	0x74,
+	0x40,
+	0xf0,
+	0x90,
+	0x30,
+	0x02,
+	0xe0,
+	0xff,
+	0x53,
+	0x07,
+	0x04,
+	0xbf,
+	0x04,
+	0x02,
+	0x80,
+	0x09,
+	0x90,
+	0x30,
+	0x3c,
+	0xe0,
+	0xf5,
+	0x82,
+	0x12,
+	0x02,
+	0xcf,
+	0x90,
+	0x30,
+	0x08,
+	0x74,
+	0x41,
+	0xf0,
+	0x80,
+	0xfe,
+	0x90,
+	0x69,
+	0xef,
+	0xe0,
+	0xff,
+	0x60,
+	0x24,
+	0x90,
+	0x69,
+	0xf4,
+	0x74,
+	0x01,
+	0xf0,
+	0x90,
+	0x30,
+	0x02,
+	0xe0,
+	0xff,
+	0x53,
+	0x07,
+	0x04,
+	0xbf,
+	0x04,
+	0x02,
+	0x80,
+	0x09,
+	0x90,
+	0x30,
+	0x3c,
+	0xe0,
+	0xf5,
+	0x82,
+	0x12,
+	0x02,
+	0xcf,
+	0x90,
+	0x30,
+	0x08,
+	0x74,
+	0x35,
+	0xf0,
+	0x80,
+	0xfe,
+	0x90,
+	0x69,
+	0xf1,
+	0xe0,
+	0xff,
+	0x60,
+	0x24,
+	0x90,
+	0x69,
+	0xf4,
+	0x74,
+	0x01,
+	0xf0,
+	0x90,
+	0x30,
+	0x02,
+	0xe0,
+	0xff,
+	0x53,
+	0x07,
+	0x04,
+	0xbf,
+	0x04,
+	0x02,
+	0x80,
+	0x09,
+	0x90,
+	0x30,
+	0x3c,
+	0xe0,
+	0xf5,
+	0x82,
+	0x12,
+	0x02,
+	0xcf,
+	0x90,
+	0x30,
+	0x08,
+	0x74,
+	0x36,
+	0xf0,
+	0x80,
+	0xfe,
+	0x90,
+	0x69,
+	0xf2,
+	0xe0,
+	0xff,
+	0x60,
+	0x24,
+	0x90,
+	0x69,
+	0xf4,
+	0x74,
+	0x01,
+	0xf0,
+	0x90,
+	0x30,
+	0x02,
+	0xe0,
+	0xff,
+	0x53,
+	0x07,
+	0x04,
+	0xbf,
+	0x04,
+	0x02,
+	0x80,
+	0x09,
+	0x90,
+	0x30,
+	0x3c,
+	0xe0,
+	0xf5,
+	0x82,
+	0x12,
+	0x02,
+	0xcf,
+	0x90,
+	0x30,
+	0x08,
+	0x74,
+	0x37,
+	0xf0,
+	0x80,
+	0xfe,
+	0x90,
+	0x69,
+	0xf5,
+	0xe0,
+	0xff,
+	0x60,
+	0x27,
+	0x90,
+	0x69,
+	0xf4,
+	0x74,
+	0x01,
+	0xf0,
+	0x90,
+	0x30,
+	0x02,
+	0xe0,
+	0xff,
+	0x53,
+	0x07,
+	0x04,
+	0xbf,
+	0x04,
+	0x02,
+	0x80,
+	0x09,
+	0x90,
+	0x30,
+	0x3c,
+	0xe0,
+	0xf5,
+	0x82,
+	0x12,
+	0x02,
+	0xcf,
+	0x90,
+	0x69,
+	0xf5,
+	0xe0,
+	0xff,
+	0x90,
+	0x30,
+	0x08,
+	0xf0,
+	0x80,
+	0xfe,
+	0x90,
+	0x69,
+	0x8f,
+	0xe0,
+	0xff,
+	0x60,
+	0x11,
+	0x75,
+	0xff,
+	0x01,
+	0x90,
+	0x30,
+	0x07,
+	0xe4,
+	0xf0,
+	0x90,
+	0x30,
+	0x08,
+	0x74,
+	0x40,
+	0xf0,
+	0x02,
+	0x06,
+	0xf2,
+	0x90,
+	0x30,
+	0x08,
+	0xe0,
+	0xff,
+	0x60,
+	0x4b,
+	0xbf,
+	0x03,
+	0x03,
+	0x02,
+	0x09,
+	0x58,
+	0xbf,
+	0x04,
+	0x03,
+	0x02,
+	0x09,
+	0xe7,
+	0xbf,
+	0x0b,
+	0x03,
+	0x02,
+	0x0b,
+	0x18,
+	0xbf,
+	0x0e,
+	0x03,
+	0x02,
+	0x0b,
+	0x78,
+	0xbf,
+	0x10,
+	0x03,
+	0x02,
+	0x0c,
+	0x8f,
+	0xbf,
+	0x12,
+	0x03,
+	0x02,
+	0x0d,
+	0x0c,
+	0xbf,
+	0x18,
+	0x03,
+	0x02,
+	0x0d,
+	0xfd,
+	0xbf,
+	0x1e,
+	0x03,
+	0x02,
+	0x0f,
+	0xef,
+	0xbf,
+	0x23,
+	0x03,
+	0x02,
+	0x10,
+	0xe6,
+	0xbf,
+	0x25,
+	0x03,
+	0x02,
+	0x11,
+	0x51,
+	0xbf,
+	0x29,
+	0x03,
+	0x02,
+	0x0d,
+	0x72,
+	0xbf,
+	0x2b,
+	0x03,
+	0x02,
+	0x12,
+	0xa5,
+	0x02,
+	0x15,
+	0x9d,
+	0xe5,
+	0xf7,
+	0x60,
+	0x0b,
+	0x90,
+	0x30,
+	0x01,
+	0xe0,
+	0xff,
+	0x53,
+	0x07,
+	0x01,
+	0xbf,
+	0x01,
+	0x22,
+	0x7e,
+	0x00,
+	0x7f,
+	0x00,
+	0xc3,
+	0xee,
+	0x94,
+	0x05,
+	0xef,
+	0x64,
+	0x80,
+	0x94,
+	0x80,
+	0x50,
+	0x13,
+	0xee,
+	0x24,
+	0x88,
+	0xf5,
+	0x82,
+	0xef,
+	0x34,
+	0x69,
+	0xf5,
+	0x83,
+	0xe4,
+	0xf0,
+	0x0e,
+	0xbe,
+	0x00,
+	0xe5,
+	0x0f,
+	0x80,
+	0xe2,
+	0x74,
+	0x01,
+	0xb5,
+	0xf7,
+	0x02,
+	0x80,
+	0x03,
+	0x02,
+	0x06,
+	0xf2,
+	0x90,
+	0x69,
+	0xea,
+	0xe4,
+	0xf0,
+	0x90,
+	0x30,
+	0x45,
+	0xf0,
+	0x90,
+	0x6c,
+	0xa0,
+	0xe0,
+	0xfe,
+	0xa3,
+	0xe0,
+	0xff,
+	0xc0,
+	0x07,
+	0xc0,
+	0x06,
+	0x8e,
+	0x82,
+	0x8f,
+	0x83,
+	0x12,
+	0x00,
+	0x23,
+	0xd0,
+	0x06,
+	0xd0,
+	0x07,
+	0x75,
+	0xff,
+	0x01,
+	0x90,
+	0x30,
+	0x33,
+	0xe0,
+	0xf5,
+	0x82,
+	0x12,
+	0x02,
+	0xcf,
+	0x90,
+	0x6c,
+	0x9c,
+	0xe0,
+	0xfe,
+	0xa3,
+	0xe0,
+	0xff,
+	0xc0,
+	0x07,
+	0xc0,
+	0x06,
+	0x8e,
+	0x82,
+	0x8f,
+	0x83,
+	0x12,
+	0x00,
+	0x23,
+	0xd0,
+	0x06,
+	0xd0,
+	0x07,
+	0x12,
+	0x02,
+	0x96,
+	0x90,
+	0x30,
+	0x2e,
+	0x74,
+	0x01,
+	0xf0,
+	0x90,
+	0x30,
+	0x38,
+	0xe0,
+	0xf5,
+	0x82,
+	0x12,
+	0x02,
+	0x9f,
+	0x90,
+	0x30,
+	0x08,
+	0x74,
+	0x03,
+	0xf0,
+	0x02,
+	0x06,
+	0xf2,
+	0x90,
+	0x69,
+	0xe3,
+	0xe0,
+	0xff,
+	0x60,
+	0x5f,
+	0x90,
+	0x69,
+	0xe3,
+	0xe4,
+	0xf0,
+	0x12,
+	0x02,
+	0x96,
+	0x90,
+	0x69,
+	0xe4,
+	0xe0,
+	0xff,
+	0xbf,
+	0x03,
+	0x34,
+	0x90,
+	0x30,
+	0x33,
+	0xe0,
+	0xf5,
+	0x82,
+	0x12,
+	0x02,
+	0xcf,
+	0x90,
+	0x6c,
+	0x50,
+	0xe0,
+	0xfe,
+	0xa3,
+	0xe0,
+	0xff,
+	0xc0,
+	0x07,
+	0xc0,
+	0x06,
+	0x8e,
+	0x82,
+	0x8f,
+	0x83,
+	0x12,
+	0x00,
+	0x23,
+	0xd0,
+	0x06,
+	0xd0,
+	0x07,
+	0x12,
+	0x02,
+	0x96,
+	0x90,
+	0x30,
+	0x2e,
+	0x74,
+	0x04,
+	0xf0,
+	0xd2,
+	0xaa,
+	0x90,
+	0x30,
+	0x08,
+	0x74,
+	0x04,
+	0xf0,
+	0x02,
+	0x06,
+	0xf2,
+	0x90,
+	0x30,
+	0x0a,
+	0xe0,
+	0xff,
+	0xbf,
+	0xdb,
+	0x06,
+	0x90,
+	0x30,
+	0x02,
+	0x74,
+	0x2f,
+	0xf0,
+	0x90,
+	0x69,
+	0xf2,
+	0xe0,
+	0x24,
+	0x01,
+	0xf0,
+	0x12,
+	0x02,
+	0xeb,
+	0x02,
+	0x06,
+	0xf2,
+	0x90,
+	0x69,
+	0xe1,
+	0xe0,
+	0xff,
+	0x70,
+	0x03,
+	0x02,
+	0x06,
+	0xf2,
+	0x90,
+	0x69,
+	0xe1,
+	0xe4,
+	0xf0,
+	0x90,
+	0x69,
+	0xf5,
+	0x74,
+	0x30,
+	0xf0,
+	0x90,
+	0x30,
+	0x0a,
+	0xe0,
+	0xff,
+	0xbf,
+	0xdb,
+	0x06,
+	0x90,
+	0x30,
+	0x02,
+	0x74,
+	0x30,
+	0xf0,
+	0x12,
+	0x02,
+	0xeb,
+	0x02,
+	0x06,
+	0xf2,
+	0x90,
+	0x6c,
+	0xb8,
+	0xe0,
+	0xfe,
+	0xa3,
+	0xe0,
+	0xff,
+	0xc0,
+	0x07,
+	0x8e,
+	0x82,
+	0x8f,
+	0x83,
+	0x12,
+	0x00,
+	0x23,
+	0xae,
+	0x82,
+	0xd0,
+	0x07,
+	0x7f,
+	0x00,
+	0xee,
+	0x4f,
+	0x60,
+	0x17,
+	0x90,
+	0x69,
+	0xf5,
+	0x74,
+	0x31,
+	0xf0,
+	0x90,
+	0x30,
+	0x0a,
+	0xe0,
+	0xfd,
+	0xbd,
+	0xdb,
+	0x06,
+	0x90,
+	0x30,
+	0x02,
+	0x74,
+	0x32,
+	0xf0,
+	0x12,
+	0x02,
+	0xeb,
+	0x90,
+	0x30,
+	0x0a,
+	0xe0,
+	0xfd,
+	0xbd,
+	0xdb,
+	0x06,
+	0x90,
+	0x30,
+	0x02,
+	0x74,
+	0x33,
+	0xf0,
+	0x90,
+	0x6c,
+	0xa4,
+	0xe0,
+	0xfc,
+	0xa3,
+	0xe0,
+	0xfd,
+	0x8c,
+	0x82,
+	0x8d,
+	0x83,
+	0x12,
+	0x00,
+	0x23,
+	0xac,
+	0x82,
+	0xad,
+	0x83,
+	0x8c,
+	0x06,
+	0x8d,
+	0x07,
+	0xee,
+	0x4f,
+	0x60,
+	0x03,
+	0x12,
+	0x02,
+	0xeb,
+	0x90,
+	0x6c,
+	0xa8,
+	0xe0,
+	0xfc,
+	0xa3,
+	0xe0,
+	0xfd,
+	0x8c,
+	0x82,
+	0x8d,
+	0x83,
+	0x12,
+	0x00,
+	0x23,
+	0xac,
+	0x82,
+	0x90,
+	0x69,
+	0xea,
+	0xec,
+	0xf0,
+	0xe0,
+	0xfd,
+	0x60,
+	0x34,
+	0x90,
+	0x30,
+	0x33,
+	0xe0,
+	0xf5,
+	0x82,
+	0x12,
+	0x02,
+	0xcf,
+	0x90,
+	0x6c,
+	0x8c,
+	0xe0,
+	0xfc,
+	0xa3,
+	0xe0,
+	0xfd,
+	0xc0,
+	0x05,
+	0xc0,
+	0x04,
+	0x8c,
+	0x82,
+	0x8d,
+	0x83,
+	0x12,
+	0x00,
+	0x23,
+	0xd0,
+	0x04,
+	0xd0,
+	0x05,
+	0x12,
+	0x02,
+	0x96,
+	0x90,
+	0x30,
+	0x0f,
+	0x74,
+	0x02,
+	0xf0,
+	0x90,
+	0x30,
+	0x34,
+	0xe0,
+	0xf5,
+	0x82,
+	0x12,
+	0x02,
+	0x9f,
+	0x80,
+	0x7c,
+	0x90,
+	0x6c,
+	0x98,
+	0xe0,
+	0xfc,
+	0xa3,
+	0xe0,
+	0xfd,
+	0xc0,
+	0x05,
+	0xc0,
+	0x04,
+	0x8c,
+	0x82,
+	0x8d,
+	0x83,
+	0x12,
+	0x00,
+	0x23,
+	0xd0,
+	0x04,
+	0xd0,
+	0x05,
+	0x90,
+	0x30,
+	0x0a,
+	0xe0,
+	0xfd,
+	0xbd,
+	0xdb,
+	0x06,
+	0x90,
+	0x30,
+	0x02,
+	0x74,
+	0x34,
+	0xf0,
+	0x90,
+	0x6c,
+	0x94,
+	0xe0,
+	0xfc,
+	0xa3,
+	0xe0,
+	0xfd,
+	0xc0,
+	0x05,
+	0xc0,
+	0x04,
+	0x8c,
+	0x82,
+	0x8d,
+	0x83,
+	0x12,
+	0x00,
+	0x23,
+	0xd0,
+	0x04,
+	0xd0,
+	0x05,
+	0x90,
+	0x30,
+	0x0a,
+	0xe0,
+	0xfd,
+	0xbd,
+	0xdb,
+	0x06,
+	0x90,
+	0x30,
+	0x02,
+	0x74,
+	0x35,
+	0xf0,
+	0x90,
+	0x30,
+	0x33,
+	0xe0,
+	0xf5,
+	0x82,
+	0x12,
+	0x02,
+	0xcf,
+	0x90,
+	0x6c,
+	0x90,
+	0xe0,
+	0xfc,
+	0xa3,
+	0xe0,
+	0xfd,
+	0xc0,
+	0x05,
+	0xc0,
+	0x04,
+	0x8c,
+	0x82,
+	0x8d,
+	0x83,
+	0x12,
+	0x00,
+	0x23,
+	0xd0,
+	0x04,
+	0xd0,
+	0x05,
+	0x12,
+	0x02,
+	0x96,
+	0x90,
+	0x30,
+	0x0f,
+	0x74,
+	0x01,
+	0xf0,
+	0x90,
+	0x30,
+	0x35,
+	0xe0,
+	0xf5,
+	0x82,
+	0x12,
+	0x02,
+	0x9f,
+	0x90,
+	0x30,
+	0x08,
+	0x74,
+	0x0b,
+	0xf0,
+	0x02,
+	0x06,
+	0xf2,
+	0x90,
+	0x6c,
+	0xc8,
+	0xe0,
+	0xfc,
+	0xa3,
+	0xe0,
+	0xfd,
+	0x90,
+	0x69,
+	0xe5,
+	0xe0,
+	0xfb,
+	0xc0,
+	0x05,
+	0xc0,
+	0x04,
+	0x74,
+	0x38,
+	0xc0,
+	0xe0,
+	0x74,
+	0x0b,
+	0xc0,
+	0xe0,
+	0xc0,
+	0x04,
+	0xc0,
+	0x05,
+	0x8b,
+	0x82,
+	0x22,
+	0xd0,
+	0x04,
+	0xd0,
+	0x05,
+	0x90,
+	0x30,
+	0x0a,
+	0xe0,
+	0xfd,
+	0xbd,
+	0xdb,
+	0x06,
+	0x90,
+	0x30,
+	0x02,
+	0x74,
+	0x3a,
+	0xf0,
+	0x90,
+	0x6c,
+	0xbc,
+	0xe0,
+	0xfc,
+	0xa3,
+	0xe0,
+	0xfd,
+	0xc0,
+	0x05,
+	0xc0,
+	0x04,
+	0x8c,
+	0x82,
+	0x8d,
+	0x83,
+	0x12,
+	0x00,
+	0x23,
+	0xd0,
+	0x04,
+	0xd0,
+	0x05,
+	0x90,
+	0x30,
+	0x0a,
+	0xe0,
+	0xfd,
+	0xbd,
+	0xdb,
+	0x06,
+	0x90,
+	0x30,
+	0x02,
+	0x74,
+	0x3b,
+	0xf0,
+	0x90,
+	0x30,
+	0x08,
+	0x74,
+	0x0e,
+	0xf0,
+	0x02,
+	0x06,
+	0xf2,
+	0x90,
+	0x69,
+	0xe3,
+	0xe0,
+	0xfd,
+	0x70,
+	0x03,
+	0x02,
+	0x0c,
+	0x66,
+	0x90,
+	0x69,
+	0xe3,
+	0xe4,
+	0xf0,
+	0x90,
+	0x69,
+	0xe4,
+	0xe0,
+	0xfd,
+	0xbd,
+	0x07,
+	0x02,
+	0x80,
+	0x03,
+	0x02,
+	0x0c,
+	0x4b,
+	0x90,
+	0x30,
+	0x33,
+	0xe0,
+	0xf5,
+	0x82,
+	0x12,
+	0x02,
+	0xcf,
+	0x90,
+	0x6c,
+	0x88,
+	0xe0,
+	0xfc,
+	0xa3,
+	0xe0,
+	0xfd,
+	0xc0,
+	0x05,
+	0xc0,
+	0x04,
+	0x8c,
+	0x82,
+	0x8d,
+	0x83,
+	0x12,
+	0x00,
+	0x23,
+	0xd0,
+	0x04,
+	0xd0,
+	0x05,
+	0x90,
+	0x30,
+	0x0f,
+	0x74,
+	0x04,
+	0xf0,
+	0xd2,
+	0xaa,
+	0x90,
+	0x6c,
+	0xac,
+	0xe0,
+	0xfc,
+	0xa3,
+	0xe0,
+	0xfd,
+	0x8c,
+	0x82,
+	0x8d,
+	0x83,
+	0x12,
+	0x00,
+	0x23,
+	0xac,
+	0x82,
+	0xad,
+	0x83,
+	0x8c,
+	0x06,
+	0x8d,
+	0x07,
+	0xee,
+	0x4f,
+	0x60,
+	0x41,
+	0x90,
+	0x30,
+	0x01,
+	0xe0,
+	0xfd,
+	0x20,
+	0xe2,
+	0x22,
+	0x7c,
+	0x00,
+	0x7d,
+	0x00,
+	0xc3,
+	0xec,
+	0x94,
+	0x05,
+	0xed,
+	0x64,
+	0x80,
+	0x94,
+	0x80,
+	0x50,
+	0x13,
+	0xec,
+	0x24,
+	0x88,
+	0xf5,
+	0x82,
+	0xed,
+	0x34,
+	0x69,
+	0xf5,
+	0x83,
+	0xe4,
+	0xf0,
+	0x0c,
+	0xbc,
+	0x00,
+	0xe5,
+	0x0d,
+	0x80,
+	0xe2,
+	0x90,
+	0x69,
+	0xf5,
+	0x74,
+	0x32,
+	0xf0,
+	0x90,
+	0x30,
+	0x0a,
+	0xe0,
+	0xfd,
+	0xbd,
+	0xdb,
+	0x06,
+	0x90,
+	0x30,
+	0x02,
+	0x74,
+	0x3d,
+	0xf0,
+	0x12,
+	0x02,
+	0xeb,
+	0x90,
+	0x30,
+	0x0a,
+	0xe0,
+	0xfd,
+	0xbd,
+	0xdb,
+	0x06,
+	0x90,
+	0x30,
+	0x02,
+	0x74,
+	0x3e,
+	0xf0,
+	0x12,
+	0x02,
+	0x96,
+	0x90,
+	0x69,
+	0xea,
+	0xe0,
+	0xfd,
+	0x60,
+	0x09,
+	0x90,
+	0x30,
+	0x08,
+	0x74,
+	0x12,
+	0xf0,
+	0x02,
+	0x06,
+	0xf2,
+	0x90,
+	0x30,
+	0x39,
+	0xe0,
+	0xf5,
+	0x82,
+	0x12,
+	0x02,
+	0xcf,
+	0x90,
+	0x30,
+	0x08,
+	0x74,
+	0x10,
+	0xf0,
+	0x02,
+	0x06,
+	0xf2,
+	0x90,
+	0x30,
+	0x0a,
+	0xe0,
+	0xfd,
+	0xbd,
+	0xdb,
+	0x06,
+	0x90,
+	0x30,
+	0x02,
+	0x74,
+	0x3f,
+	0xf0,
+	0x90,
+	0x69,
+	0xf2,
+	0xe0,
+	0x24,
+	0x01,
+	0xf0,
+	0x12,
+	0x02,
+	0xeb,
+	0x02,
+	0x06,
+	0xf2,
+	0x90,
+	0x69,
+	0xe1,
+	0xe0,
+	0xfd,
+	0x70,
+	0x03,
+	0x02,
+	0x06,
+	0xf2,
+	0x90,
+	0x69,
+	0xe1,
+	0xe4,
+	0xf0,
+	0x90,
+	0x69,
+	0xf5,
+	0x74,
+	0x39,
+	0xf0,
+	0x90,
+	0x30,
+	0x0a,
+	0xe0,
+	0xfd,
+	0xbd,
+	0xdb,
+	0x06,
+	0x90,
+	0x30,
+	0x02,
+	0x74,
+	0x40,
+	0xf0,
+	0x12,
+	0x02,
+	0xeb,
+	0x02,
+	0x06,
+	0xf2,
+	0x90,
+	0x69,
+	0xe3,
+	0xe0,
+	0xfd,
+	0x70,
+	0x03,
+	0x02,
+	0x06,
+	0xf2,
+	0x90,
+	0x69,
+	0xe3,
+	0xe4,
+	0xf0,
+	0x12,
+	0x02,
+	0x96,
+	0x90,
+	0x69,
+	0xe4,
+	0xe0,
+	0xfd,
+	0xbd,
+	0x08,
+	0x48,
+	0x90,
+	0x30,
+	0x33,
+	0xe0,
+	0xf5,
+	0x82,
+	0x12,
+	0x02,
+	0xcf,
+	0x90,
+	0x6c,
+	0x84,
+	0xe0,
+	0xfc,
+	0xa3,
+	0xe0,
+	0xfd,
+	0xc0,
+	0x05,
+	0xc0,
+	0x04,
+	0x8c,
+	0x82,
+	0x8d,
+	0x83,
+	0x12,
+	0x00,
+	0x23,
+	0xd0,
+	0x04,
+	0xd0,
+	0x05,
+	0x90,
+	0x30,
+	0x0f,
+	0x74,
+	0x08,
+	0xf0,
+	0xd2,
+	0xaa,
+	0x90,
+	0x6c,
+	0x80,
+	0xe0,
+	0xfc,
+	0xa3,
+	0xe0,
+	0xfd,
+	0xc0,
+	0x05,
+	0xc0,
+	0x04,
+	0x8c,
+	0x82,
+	0x8d,
+	0x83,
+	0x12,
+	0x00,
+	0x23,
+	0xd0,
+	0x04,
+	0xd0,
+	0x05,
+	0x90,
+	0x30,
+	0x08,
+	0x74,
+	0x12,
+	0xf0,
+	0x02,
+	0x06,
+	0xf2,
+	0x90,
+	0x30,
+	0x0a,
+	0xe0,
+	0xfd,
+	0xbd,
+	0xdb,
+	0x06,
+	0x90,
+	0x30,
+	0x02,
+	0x74,
+	0x41,
+	0xf0,
+	0x90,
+	0x69,
+	0xf2,
+	0xe0,
+	0x24,
+	0x01,
+	0xf0,
+	0x12,
+	0x02,
+	0xeb,
+	0x02,
+	0x06,
+	0xf2,
+	0x90,
+	0x6c,
+	0x7c,
+	0xe0,
+	0xfc,
+	0xa3,
+	0xe0,
+	0xfd,
+	0xc0,
+	0x05,
+	0xc0,
+	0x04,
+	0x8c,
+	0x82,
+	0x8d,
+	0x83,
+	0x12,
+	0x00,
+	0x23,
+	0xd0,
+	0x04,
+	0xd0,
+	0x05,
+	0x90,
+	0x6c,
+	0xc0,
+	0xe0,
+	0xfc,
+	0xa3,
+	0xe0,
+	0xfd,
+	0xc0,
+	0x05,
+	0xc0,
+	0x04,
+	0x8c,
+	0x82,
+	0x8d,
+	0x83,
+	0x12,
+	0x00,
+	0x23,
+	0xd0,
+	0x04,
+	0xd0,
+	0x05,
+	0x90,
+	0x30,
+	0x33,
+	0xe0,
+	0xf5,
+	0x82,
+	0x12,
+	0x02,
+	0xcf,
+	0x90,
+	0x6c,
+	0x78,
+	0xe0,
+	0xfc,
+	0xa3,
+	0xe0,
+	0xfd,
+	0xc0,
+	0x05,
+	0xc0,
+	0x04,
+	0x8c,
+	0x82,
+	0x8d,
+	0x83,
+	0x12,
+	0x00,
+	0x23,
+	0xd0,
+	0x04,
+	0xd0,
+	0x05,
+	0x12,
+	0x02,
+	0x96,
+	0x90,
+	0x30,
+	0x0f,
+	0x74,
+	0x10,
+	0xf0,
+	0x90,
+	0x30,
+	0x36,
+	0xe0,
+	0xf5,
+	0x82,
+	0x12,
+	0x02,
+	0x9f,
+	0x90,
+	0x30,
+	0x08,
+	0x74,
+	0x29,
+	0xf0,
+	0x90,
+	0x69,
+	0xe3,
+	0xe0,
+	0xfd,
+	0x60,
+	0x5b,
+	0x90,
+	0x69,
+	0xe3,
+	0xe4,
+	0xf0,
+	0x90,
+	0x69,
+	0xe4,
+	0xe0,
+	0xfd,
+	0xbd,
+	0x0a,
+	0x30,
+	0x90,
+	0x30,
+	0x33,
+	0xe0,
+	0xf5,
+	0x82,
+	0x12,
+	0x02,
+	0xcf,
+	0x90,
+	0x6c,
+	0x74,
+	0xe0,
+	0xfc,
+	0xa3,
+	0xe0,
+	0xfd,
+	0xc0,
+	0x05,
+	0xc0,
+	0x04,
+	0x8c,
+	0x82,
+	0x8d,
+	0x83,
+	0x12,
+	0x00,
+	0x23,
+	0xd0,
+	0x04,
+	0xd0,
+	0x05,
+	0x90,
+	0x30,
+	0x0f,
+	0x74,
+	0x20,
+	0xf0,
+	0xd2,
+	0xaa,
+	0x90,
+	0x30,
+	0x08,
+	0x74,
+	0x18,
+	0xf0,
+	0x80,
+	0x18,
+	0x90,
+	0x30,
+	0x0a,
+	0xe0,
+	0xfd,
+	0xbd,
+	0xdb,
+	0x06,
+	0x90,
+	0x30,
+	0x02,
+	0x74,
+	0x43,
+	0xf0,
+	0x90,
+	0x69,
+	0xf2,
+	0xe0,
+	0x24,
+	0x01,
+	0xf0,
+	0x12,
+	0x02,
+	0xeb,
+	0x12,
+	0x02,
+	0x96,
+	0x02,
+	0x06,
+	0xf2,
+	0x90,
+	0x69,
+	0xe1,
+	0xe0,
+	0xfd,
+	0x70,
+	0x03,
+	0x02,
+	0x06,
+	0xf2,
+	0x90,
+	0x69,
+	0xe1,
+	0xe4,
+	0xf0,
+	0x90,
+	0x30,
+	0x0a,
+	0xe0,
+	0xfd,
+	0xbd,
+	0xdb,
+	0x06,
+	0x90,
+	0x30,
+	0x02,
+	0x74,
+	0x44,
+	0xf0,
+	0x90,
+	0x69,
+	0xf5,
+	0x74,
+	0x38,
+	0xf0,
+	0x12,
+	0x02,
+	0xeb,
+	0x02,
+	0x06,
+	0xf2,
+	0x90,
+	0x6c,
+	0xb0,
+	0xe0,
+	0xfc,
+	0xa3,
+	0xe0,
+	0xfd,
+	0x8c,
+	0x82,
+	0x8d,
+	0x83,
+	0x12,
+	0x00,
+	0x23,
+	0xac,
+	0x82,
+	0xad,
+	0x83,
+	0x8c,
+	0x06,
+	0x8d,
+	0x07,
+	0xee,
+	0x4f,
+	0x60,
+	0x23,
+	0x90,
+	0x30,
+	0x0a,
+	0xe0,
+	0xfd,
+	0xbd,
+	0xdb,
+	0x06,
+	0x90,
+	0x30,
+	0x02,
+	0x74,
+	0x47,
+	0xf0,
+	0x90,
+	0x69,
+	0xf5,
+	0x74,
+	0x33,
+	0xf0,
+	0x12,
+	0x02,
+	0xeb,
+	0x90,
+	0x30,
+	0x08,
+	0x74,
+	0x12,
+	0xf0,
+	0x12,
+	0x02,
+	0x96,
+	0x02,
+	0x06,
+	0xf2,
+	0x90,
+	0x30,
+	0x0a,
+	0xe0,
+	0xfd,
+	0xbd,
+	0xdb,
+	0x06,
+	0x90,
+	0x30,
+	0x02,
+	0x74,
+	0x48,
+	0xf0,
+	0x90,
+	0x6c,
+	0xcc,
+	0xe0,
+	0xfc,
+	0xa3,
+	0xe0,
+	0xfd,
+	0x90,
+	0x69,
+	0xe5,
+	0xe0,
+	0xfb,
+	0xc0,
+	0x05,
+	0xc0,
+	0x04,
+	0x74,
+	0x69,
+	0xc0,
+	0xe0,
+	0x74,
+	0x0e,
+	0xc0,
+	0xe0,
+	0xc0,
+	0x04,
+	0xc0,
+	0x05,
+	0x8b,
+	0x82,
+	0x22,
+	0xd0,
+	0x04,
+	0xd0,
+	0x05,
+	0x90,
+	0x6c,
+	0x70,
+	0xe0,
+	0xfc,
+	0xa3,
+	0xe0,
+	0xfd,
+	0xc0,
+	0x05,
+	0xc0,
+	0x04,
+	0x8c,
+	0x82,
+	0x8d,
+	0x83,
+	0x12,
+	0x00,
+	0x23,
+	0xd0,
+	0x04,
+	0xd0,
+	0x05,
+	0x90,
+	0x6c,
+	0x6c,
+	0xe0,
+	0xfc,
+	0xa3,
+	0xe0,
+	0xfd,
+	0xc0,
+	0x05,
+	0xc0,
+	0x04,
+	0x8c,
+	0x82,
+	0x8d,
+	0x83,
+	0x12,
+	0x00,
+	0x23,
+	0xd0,
+	0x04,
+	0xd0,
+	0x05,
+	0x90,
+	0x6c,
+	0x68,
+	0xe0,
+	0xfc,
+	0xa3,
+	0xe0,
+	0xfd,
+	0xc0,
+	0x05,
+	0xc0,
+	0x04,
+	0x8c,
+	0x82,
+	0x8d,
+	0x83,
+	0x12,
+	0x00,
+	0x23,
+	0xd0,
+	0x04,
+	0xd0,
+	0x05,
+	0x90,
+	0x30,
+	0x33,
+	0xe0,
+	0xf5,
+	0x82,
+	0x12,
+	0x02,
+	0xcf,
+	0x90,
+	0x6c,
+	0x64,
+	0xe0,
+	0xfc,
+	0xa3,
+	0xe0,
+	0xfd,
+	0xc0,
+	0x05,
+	0xc0,
+	0x04,
+	0x8c,
+	0x82,
+	0x8d,
+	0x83,
+	0x12,
+	0x00,
+	0x23,
+	0xd0,
+	0x04,
+	0xd0,
+	0x05,
+	0x12,
+	0x02,
+	0x96,
+	0x90,
+	0x30,
+	0x2e,
+	0x74,
+	0x02,
+	0xf0,
+	0x90,
+	0x63,
+	0x64,
+	0x75,
+	0xf0,
+	0x00,
+	0x12,
+	0x21,
+	0x7d,
+	0xfa,
+	0xa3,
+	0x12,
+	0x21,
+	0x7d,
+	0xfb,
+	0xa3,
+	0x12,
+	0x21,
+	0x7d,
+	0xfc,
+	0xa3,
+	0x12,
+	0x21,
+	0x7d,
+	0xfd,
+	0x90,
+	0x44,
+	0xcc,
+	0xea,
+	0xf0,
+	0xa3,
+	0xeb,
+	0xf0,
+	0xa3,
+	0xec,
+	0xf0,
+	0xa3,
+	0xed,
+	0xf0,
+	0x90,
+	0x63,
+	0x60,
+	0x75,
+	0xf0,
+	0x00,
+	0x12,
+	0x21,
+	0x7d,
+	0xfa,
+	0xa3,
+	0x12,
+	0x21,
+	0x7d,
+	0xfb,
+	0xa3,
+	0x12,
+	0x21,
+	0x7d,
+	0xfc,
+	0xa3,
+	0x12,
+	0x21,
+	0x7d,
+	0xfd,
+	0x90,
+	0x44,
+	0xc8,
+	0xea,
+	0xf0,
+	0xa3,
+	0xeb,
+	0xf0,
+	0xa3,
+	0xec,
+	0xf0,
+	0xa3,
+	0xed,
+	0xf0,
+	0x90,
+	0x63,
+	0x5c,
+	0x75,
+	0xf0,
+	0x00,
+	0x12,
+	0x21,
+	0x7d,
+	0xfa,
+	0xa3,
+	0x12,
+	0x21,
+	0x7d,
+	0xfb,
+	0xa3,
+	0x12,
+	0x21,
+	0x7d,
+	0xfc,
+	0xa3,
+	0x12,
+	0x21,
+	0x7d,
+	0xfd,
+	0x90,
+	0x44,
+	0xc4,
+	0xea,
+	0xf0,
+	0xa3,
+	0xeb,
+	0xf0,
+	0xa3,
+	0xec,
+	0xf0,
+	0xa3,
+	0xed,
+	0xf0,
+	0x90,
+	0x63,
+	0x58,
+	0xe0,
+	0xfa,
+	0xa3,
+	0xe0,
+	0xfb,
+	0xa3,
+	0xe0,
+	0xfc,
+	0xa3,
+	0xe0,
+	0xfd,
+	0x90,
+	0x44,
+	0xc0,
+	0xea,
+	0xf0,
+	0xa3,
+	0xeb,
+	0xf0,
+	0xa3,
+	0xec,
+	0xf0,
+	0xa3,
+	0xed,
+	0xf0,
+	0x90,
+	0x63,
+	0x54,
+	0x75,
+	0xf0,
+	0x00,
+	0x12,
+	0x21,
+	0x7d,
+	0xfa,
+	0xa3,
+	0x12,
+	0x21,
+	0x7d,
+	0xfb,
+	0xa3,
+	0x12,
+	0x21,
+	0x7d,
+	0xfc,
+	0xa3,
+	0x12,
+	0x21,
+	0x7d,
+	0xfd,
+	0x90,
+	0x44,
+	0x84,
+	0xea,
+	0xf0,
+	0xa3,
+	0xeb,
+	0xf0,
+	0xa3,
+	0xec,
+	0xf0,
+	0xa3,
+	0xed,
+	0xf0,
+	0x90,
+	0x63,
+	0x50,
+	0xe0,
+	0xfa,
+	0xa3,
+	0xe0,
+	0xfb,
+	0xa3,
+	0xe0,
+	0xfc,
+	0xa3,
+	0xe0,
+	0xfd,
+	0x90,
+	0x44,
+	0x80,
+	0xea,
+	0xf0,
+	0xa3,
+	0xeb,
+	0xf0,
+	0xa3,
+	0xec,
+	0xf0,
+	0xa3,
+	0xed,
+	0xf0,
+	0x90,
+	0x30,
+	0x45,
+	0xe0,
+	0xfd,
+	0x60,
+	0x27,
+	0x90,
+	0x30,
+	0x02,
+	0xe0,
+	0xfd,
+	0x53,
+	0x05,
+	0x08,
+	0xbd,
+	0x08,
+	0x02,
+	0x80,
+	0x1a,
+	0x90,
+	0x69,
+	0xe1,
+	0xe4,
+	0xf0,
+	0x12,
+	0x02,
+	0x96,
+	0x90,
+	0x30,
+	0x3e,
+	0xe0,
+	0xf5,
+	0x82,
+	0x12,
+	0x02,
+	0xbb,
+	0x90,
+	0x30,
+	0x08,
+	0x74,
+	0x1e,
+	0xf0,
+	0x02,
+	0x06,
+	0xf2,
+	0x90,
+	0x30,
+	0x3a,
+	0xe0,
+	0xf5,
+	0x82,
+	0x12,
+	0x02,
+	0x9f,
+	0x90,
+	0x30,
+	0x08,
+	0x74,
+	0x2b,
+	0xf0,
+	0x02,
+	0x06,
+	0xf2,
+	0x90,
+	0x69,
+	0xe3,
+	0xe0,
+	0xfd,
+	0x70,
+	0x03,
+	0x02,
+	0x10,
+	0xc8,
+	0x90,
+	0x69,
+	0xe3,
+	0xe4,
+	0xf0,
+	0x12,
+	0x02,
+	0x96,
+	0x90,
+	0x69,
+	0xe4,
+	0xe0,
+	0xfd,
+	0xbd,
+	0x0c,
+	0x02,
+	0x80,
+	0x03,
+	0x02,
+	0x10,
+	0xad,
+	0x90,
+	0x6c,
+	0x60,
+	0xe0,
+	0xfc,
+	0xa3,
+	0xe0,
+	0xfd,
+	0xc0,
+	0x05,
+	0xc0,
+	0x04,
+	0x8c,
+	0x82,
+	0x8d,
+	0x83,
+	0x12,
+	0x00,
+	0x23,
+	0xd0,
+	0x04,
+	0xd0,
+	0x05,
+	0x90,
+	0x30,
+	0x48,
+	0xe0,
+	0x70,
+	0x0c,
+	0x90,
+	0x30,
+	0x47,
+	0xe0,
+	0x70,
+	0x06,
+	0x90,
+	0x30,
+	0x46,
+	0xe0,
+	0x60,
+	0x0e,
+	0x90,
+	0x30,
+	0x07,
+	0xe4,
+	0xf0,
+	0x90,
+	0x69,
+	0xf5,
+	0x74,
+	0x3e,
+	0xf0,
+	0x12,
+	0x02,
+	0xeb,
+	0x90,
+	0x30,
+	0x22,
+	0xe0,
+	0xfd,
+	0x54,
+	0x0c,
+	0x60,
+	0x0e,
+	0x90,
+	0x30,
+	0x07,
+	0xe4,
+	0xf0,
+	0x90,
+	0x69,
+	0xf5,
+	0x74,
+	0x3d,
+	0xf0,
+	0x12,
+	0x02,
+	0xeb,
+	0x90,
+	0x6c,
+	0x54,
+	0xe0,
+	0xfc,
+	0xa3,
+	0xe0,
+	0xfd,
+	0xc0,
+	0x05,
+	0xc0,
+	0x04,
+	0x8c,
+	0x82,
+	0x8d,
+	0x83,
+	0x12,
+	0x00,
+	0x23,
+	0xd0,
+	0x04,
+	0xd0,
+	0x05,
+	0x90,
+	0x30,
+	0x0f,
+	0x74,
+	0x40,
+	0xf0,
+	0xd2,
+	0xaa,
+	0x90,
+	0x30,
+	0x2f,
+	0xe0,
+	0x90,
+	0x30,
+	0x2c,
+	0xf0,
+	0x90,
+	0x30,
+	0x4b,
+	0xe4,
+	0xf0,
+	0x90,
+	0x30,
+	0x4a,
+	0xf0,
+	0x90,
+	0x30,
+	0x49,
+	0xf0,
+	0x90,
+	0x30,
+	0x02,
+	0xe0,
+	0xfd,
+	0x53,
+	0x05,
+	0x80,
+	0xbd,
+	0x80,
+	0x09,
+	0x90,
+	0x30,
+	0x08,
+	0x74,
+	0x2b,
+	0xf0,
+	0x02,
+	0x06,
+	0xf2,
+	0x90,
+	0x30,
+	0x08,
+	0x74,
+	0x23,
+	0xf0,
+	0x02,
+	0x06,
+	0xf2,
+	0x90,
+	0x30,
+	0x0a,
+	0xe0,
+	0xfd,
+	0xbd,
+	0xdb,
+	0x06,
+	0x90,
+	0x30,
+	0x02,
+	0x74,
+	0x4c,
+	0xf0,
+	0x90,
+	0x69,
+	0xf2,
+	0xe0,
+	0x24,
+	0x01,
+	0xf0,
+	0x12,
+	0x02,
+	0xeb,
+	0x02,
+	0x06,
+	0xf2,
+	0x90,
+	0x69,
+	0xe1,
+	0xe0,
+	0xfd,
+	0x70,
+	0x03,
+	0x02,
+	0x06,
+	0xf2,
+	0x90,
+	0x69,
+	0xe1,
+	0xe4,
+	0xf0,
+	0x12,
+	0x02,
+	0x96,
+	0x90,
+	0x69,
+	0xf5,
+	0x74,
+	0x3a,
+	0xf0,
+	0x12,
+	0x02,
+	0xeb,
+	0x02,
+	0x06,
+	0xf2,
+	0x90,
+	0x6c,
+	0x5c,
+	0xe0,
+	0xfc,
+	0xa3,
+	0xe0,
+	0xfd,
+	0xc0,
+	0x05,
+	0xc0,
+	0x04,
+	0x8c,
+	0x82,
+	0x8d,
+	0x83,
+	0x12,
+	0x00,
+	0x23,
+	0xd0,
+	0x04,
+	0xd0,
+	0x05,
+	0x90,
+	0x30,
+	0x2d,
+	0x74,
+	0x02,
+	0xf0,
+	0x90,
+	0x30,
+	0x37,
+	0xe0,
+	0xf5,
+	0x82,
+	0x12,
+	0x02,
+	0x9f,
+	0x90,
+	0x6c,
+	0xd0,
+	0xe0,
+	0xfc,
+	0xa3,
+	0xe0,
+	0xfd,
+	0xc0,
+	0x05,
+	0xc0,
+	0x04,
+	0x8c,
+	0x82,
+	0x8d,
+	0x83,
+	0x12,
+	0x00,
+	0x23,
+	0xd0,
+	0x04,
+	0xd0,
+	0x05,
+	0x90,
+	0x6c,
+	0xc4,
+	0xe0,
+	0xfc,
+	0xa3,
+	0xe0,
+	0xfd,
+	0xc0,
+	0x05,
+	0xc0,
+	0x04,
+	0x8c,
+	0x82,
+	0x8d,
+	0x83,
+	0x12,
+	0x00,
+	0x23,
+	0xd0,
+	0x04,
+	0xd0,
+	0x05,
+	0x90,
+	0x30,
+	0x07,
+	0xe0,
+	0xfd,
+	0x54,
+	0x77,
+	0xf0,
+	0x90,
+	0x69,
+	0xe9,
+	0x74,
+	0x01,
+	0xf0,
+	0x90,
+	0x30,
+	0x08,
+	0x74,
+	0x25,
+	0xf0,
+	0x02,
+	0x06,
+	0xf2,
+	0x90,
+	0x69,
+	0xe3,
+	0xe0,
+	0xfd,
+	0x70,
+	0x03,
+	0x02,
+	0x12,
+	0x3f,
+	0x90,
+	0x69,
+	0xe3,
+	0xe4,
+	0xf0,
+	0x90,
+	0x69,
+	0xe4,
+	0xe0,
+	0xfd,
+	0xbd,
+	0x11,
+	0x02,
+	0x80,
+	0x03,
+	0x02,
+	0x12,
+	0x24,
+	0x12,
+	0x02,
+	0x96,
+	0x90,
+	0x6c,
+	0x58,
+	0xe0,
+	0xfc,
+	0xa3,
+	0xe0,
+	0xfd,
+	0xc0,
+	0x05,
+	0xc0,
+	0x04,
+	0x8c,
+	0x82,
+	0x8d,
+	0x83,
+	0x12,
+	0x00,
+	0x23,
+	0xd0,
+	0x04,
+	0xd0,
+	0x05,
+	0x90,
+	0x6c,
+	0xb4,
+	0xe0,
+	0xfc,
+	0xa3,
+	0xe0,
+	0xfd,
+	0x8c,
+	0x82,
+	0x8d,
+	0x83,
+	0x12,
+	0x00,
+	0x23,
+	0xac,
+	0x82,
+	0xad,
+	0x83,
+	0x8c,
+	0x06,
+	0x8d,
+	0x07,
+	0xee,
+	0x4f,
+	0x60,
+	0x4e,
+	0x90,
+	0x30,
+	0x07,
+	0xe0,
+	0x44,
+	0x08,
+	0xf0,
+	0x90,
+	0x30,
+	0x0a,
+	0xe0,
+	0xfd,
+	0xbd,
+	0xdb,
+	0x06,
+	0x90,
+	0x30,
+	0x02,
+	0x74,
+	0x4a,
+	0xf0,
+	0x90,
+	0x30,
+	0x49,
+	0xe0,
+	0xfd,
+	0xbd,
+	0xff,
+	0x1e,
+	0x90,
+	0x30,
+	0x4a,
+	0xe0,
+	0xfd,
+	0xbd,
+	0xff,
+	0x0b,
+	0x90,
+	0x30,
+	0x4b,
+	0xe0,
+	0xfd,
+	0x0d,
+	0x90,
+	0x30,
+	0x4b,
+	0xed,
+	0xf0,
+	0x90,
+	0x30,
+	0x4a,
+	0xe0,
+	0xfd,
+	0x0d,
+	0x90,
+	0x30,
+	0x4a,
+	0xed,
+	0xf0,
+	0x90,
+	0x30,
+	0x49,
+	0xe0,
+	0xfd,
+	0x0d,
+	0x90,
+	0x30,
+	0x49,
+	0xed,
+	0xf0,
+	0x90,
+	0x30,
+	0x08,
+	0x74,
+	0x23,
+	0xf0,
+	0x80,
+	0x2b,
+	0x90,
+	0x30,
+	0x07,
+	0xe0,
+	0x44,
+	0x80,
+	0xf0,
+	0x90,
+	0x30,
+	0x0a,
+	0xe0,
+	0xfd,
+	0xbd,
+	0xdb,
+	0x06,
+	0x90,
+	0x30,
+	0x02,
+	0x74,
+	0x4b,
+	0xf0,
+	0xd2,
+	0xaa,
+	0x90,
+	0x69,
+	0xe9,
+	0xe4,
+	0xf0,
+	0x90,
+	0x30,
+	0x3d,
+	0xe0,
+	0xf5,
+	0x82,
+	0x12,
+	0x02,
+	0x9f,
+	0x90,
+	0x30,
+	0x08,
+	0x74,
+	0x2b,
+	0xf0,
+	0x90,
+	0x30,
+	0x0f,
+	0x74,
+	0x80,
+	0xf0,
+	0x02,
+	0x06,
+	0xf2,
+	0x90,
+	0x30,
+	0x0a,
+	0xe0,
+	0xfd,
+	0xbd,
+	0xdb,
+	0x06,
+	0x90,
+	0x30,
+	0x02,
+	0x74,
+	0x4c,
+	0xf0,
+	0x90,
+	0x69,
+	0xf2,
+	0xe0,
+	0x24,
+	0x01,
+	0xf0,
+	0x12,
+	0x02,
+	0xeb,
+	0x02,
+	0x06,
+	0xf2,
+	0x90,
+	0x69,
+	0xe1,
+	0xe0,
+	0xfd,
+	0x70,
+	0x03,
+	0x02,
+	0x06,
+	0xf2,
+	0x90,
+	0x69,
+	0xe1,
+	0xe4,
+	0xf0,
+	0x12,
+	0x02,
+	0x96,
+	0x90,
+	0x69,
+	0xe9,
+	0xe4,
+	0xf0,
+	0x90,
+	0x30,
+	0x07,
+	0xe0,
+	0x44,
+	0x08,
+	0xf0,
+	0x90,
+	0x30,
+	0x0a,
+	0xe0,
+	0xfd,
+	0xbd,
+	0xdb,
+	0x06,
+	0x90,
+	0x30,
+	0x02,
+	0x74,
+	0x4d,
+	0xf0,
+	0x90,
+	0x30,
+	0x49,
+	0xe0,
+	0xfd,
+	0xbd,
+	0xff,
+	0x1e,
+	0x90,
+	0x30,
+	0x4a,
+	0xe0,
+	0xfd,
+	0xbd,
+	0xff,
+	0x0b,
+	0x90,
+	0x30,
+	0x4b,
+	0xe0,
+	0xfd,
+	0x0d,
+	0x90,
+	0x30,
+	0x4b,
+	0xed,
+	0xf0,
+	0x90,
+	0x30,
+	0x4a,
+	0xe0,
+	0xfd,
+	0x0d,
+	0x90,
+	0x30,
+	0x4a,
+	0xed,
+	0xf0,
+	0x90,
+	0x30,
+	0x49,
+	0xe0,
+	0xfd,
+	0x0d,
+	0x90,
+	0x30,
+	0x49,
+	0xed,
+	0xf0,
+	0x90,
+	0x30,
+	0x08,
+	0x74,
+	0x23,
+	0xf0,
+	0x02,
+	0x06,
+	0xf2,
+	0x90,
+	0x30,
+	0x45,
+	0xe0,
+	0xfd,
+	0x60,
+	0x24,
+	0x90,
+	0x30,
+	0x02,
+	0xe0,
+	0xfd,
+	0x53,
+	0x05,
+	0x08,
+	0xbd,
+	0x08,
+	0x02,
+	0x80,
+	0x17,
+	0x90,
+	0x30,
+	0x22,
+	0xe0,
+	0xfd,
+	0x54,
+	0x0c,
+	0x60,
+	0x0e,
+	0x90,
+	0x30,
+	0x07,
+	0xe4,
+	0xf0,
+	0x90,
+	0x69,
+	0xf5,
+	0x74,
+	0x3d,
+	0xf0,
+	0x12,
+	0x02,
+	0xeb,
+	0x90,
+	0x30,
+	0x01,
+	0xe0,
+	0xfd,
+	0x53,
+	0x05,
+	0x40,
+	0xbd,
+	0x40,
+	0x08,
+	0x90,
+	0x30,
+	0x07,
+	0xe0,
+	0xfd,
+	0x54,
+	0xf7,
+	0xf0,
+	0x90,
+	0x69,
+	0xe3,
+	0xe0,
+	0xfd,
+	0x70,
+	0x03,
+	0x02,
+	0x14,
+	0x6d,
+	0x90,
+	0x69,
+	0xe3,
+	0xe4,
+	0xf0,
+	0x90,
+	0x69,
+	0xe4,
+	0xe0,
+	0xfd,
+	0xbd,
+	0x0c,
+	0x02,
+	0x80,
+	0x03,
+	0x02,
+	0x13,
+	0xdb,
+	0x90,
+	0x6c,
+	0x60,
+	0xe0,
+	0xfc,
+	0xa3,
+	0xe0,
+	0xfd,
+	0xc0,
+	0x05,
+	0xc0,
+	0x04,
+	0x8c,
+	0x82,
+	0x8d,
+	0x83,
+	0x12,
+	0x00,
+	0x23,
+	0xd0,
+	0x04,
+	0xd0,
+	0x05,
+	0x90,
+	0x30,
+	0x02,
+	0xe0,
+	0xfd,
+	0x53,
+	0x05,
+	0x08,
+	0xbd,
+	0x08,
+	0x03,
+	0x02,
+	0x13,
+	0xb1,
+	0x90,
+	0x69,
+	0xba,
+	0xe0,
+	0xfd,
+	0x90,
+	0x30,
+	0x48,
+	0xe0,
+	0xfc,
+	0xc3,
+	0x9d,
+	0x40,
+	0x47,
+	0x90,
+	0x69,
+	0xba,
+	0xe0,
+	0xfd,
+	0x90,
+	0x30,
+	0x48,
+	0xe0,
+	0xfc,
+	0xed,
+	0xb5,
+	0x04,
+	0x0e,
+	0x90,
+	0x69,
+	0xb9,
+	0xe0,
+	0xfd,
+	0x90,
+	0x30,
+	0x47,
+	0xe0,
+	0xfc,
+	0xc3,
+	0x9d,
+	0x40,
+	0x2b,
+	0x90,
+	0x69,
+	0xba,
+	0xe0,
+	0xfd,
+	0x90,
+	0x30,
+	0x48,
+	0xe0,
+	0xfc,
+	0xed,
+	0xb5,
+	0x04,
+	0x2e,
+	0x90,
+	0x69,
+	0xb9,
+	0xe0,
+	0xfd,
+	0x90,
+	0x30,
+	0x47,
+	0xe0,
+	0xfc,
+	0xed,
+	0xb5,
+	0x04,
+	0x20,
+	0x90,
+	0x69,
+	0xb8,
+	0xe0,
+	0xfd,
+	0x90,
+	0x30,
+	0x46,
+	0xe0,
+	0xfc,
+	0xc3,
+	0xed,
+	0x9c,
+	0x40,
+	0x11,
+	0x90,
+	0x30,
+	0x07,
+	0x74,
+	0x02,
+	0xf0,
+	0x90,
+	0x69,
+	0xf5,
+	0x74,
+	0x3b,
+	0xf0,
+	0x12,
+	0x02,
+	0xeb,
+	0x80,
+	0x27,
+	0x90,
+	0x69,
+	0xba,
+	0xe0,
+	0xfd,
+	0xbd,
+	0xff,
+	0x1f,
+	0x90,
+	0x69,
+	0xb9,
+	0xe0,
+	0xfd,
+	0xbd,
+	0xff,
+	0x17,
+	0x90,
+	0x69,
+	0xb8,
+	0xe0,
+	0xfd,
+	0xbd,
+	0xff,
+	0x0f,
+	0x90,
+	0x30,
+	0x07,
+	0x74,
+	0x02,
+	0xf0,
+	0x90,
+	0x69,
+	0xf5,
+	0x74,
+	0x3c,
+	0xf0,
+	0x12,
+	0x02,
+	0xeb,
+	0x90,
+	0x6c,
+	0x54,
+	0xe0,
+	0xfc,
+	0xa3,
+	0xe0,
+	0xfd,
+	0xc0,
+	0x05,
+	0xc0,
+	0x04,
+	0x8c,
+	0x82,
+	0x8d,
+	0x83,
+	0x12,
+	0x00,
+	0x23,
+	0xd0,
+	0x04,
+	0xd0,
+	0x05,
+	0x90,
+	0x30,
+	0x0f,
+	0x74,
+	0x40,
+	0xf0,
+	0x90,
+	0x30,
+	0x07,
+	0xe0,
+	0xfd,
+	0x44,
+	0x81,
+	0xf0,
+	0xd2,
+	0xaa,
+	0x02,
+	0x06,
+	0xf2,
+	0x90,
+	0x69,
+	0xe4,
+	0xe0,
+	0xfd,
+	0xbd,
+	0x11,
+	0x6f,
+	0x12,
+	0x02,
+	0x96,
+	0x90,
+	0x6c,
+	0x58,
+	0xe0,
+	0xfc,
+	0xa3,
+	0xe0,
+	0xfd,
+	0xc0,
+	0x05,
+	0xc0,
+	0x04,
+	0x8c,
+	0x82,
+	0x8d,
+	0x83,
+	0x12,
+	0x00,
+	0x23,
+	0xd0,
+	0x04,
+	0xd0,
+	0x05,
+	0x90,
+	0x6c,
+	0xb4,
+	0xe0,
+	0xfc,
+	0xa3,
+	0xe0,
+	0xfd,
+	0x8c,
+	0x82,
+	0x8d,
+	0x83,
+	0x12,
+	0x00,
+	0x23,
+	0xac,
+	0x82,
+	0xad,
+	0x83,
+	0x8c,
+	0x06,
+	0x8d,
+	0x07,
+	0xee,
+	0x4f,
+	0x60,
+	0x15,
+	0x90,
+	0x30,
+	0x07,
+	0xe0,
+	0x44,
+	0x08,
+	0xf0,
+	0x90,
+	0x30,
+	0x0a,
+	0xe0,
+	0xfd,
+	0xbd,
+	0xdb,
+	0x06,
+	0x90,
+	0x30,
+	0x02,
+	0x74,
+	0x4a,
+	0xf0,
+	0x90,
+	0x30,
+	0x0f,
+	0x74,
+	0x80,
+	0xf0,
+	0x90,
+	0x30,
+	0x07,
+	0xe0,
+	0x44,
+	0x81,
+	0xf0,
+	0x90,
+	0x30,
+	0x0a,
+	0xe0,
+	0xfd,
+	0xbd,
+	0xdb,
+	0x06,
+	0x90,
+	0x30,
+	0x02,
+	0x74,
+	0x4b,
+	0xf0,
+	0xd2,
+	0xaa,
+	0x90,
+	0x69,
+	0xe9,
+	0xe4,
+	0xf0,
+	0x02,
+	0x06,
+	0xf2,
+	0x90,
+	0x30,
+	0x0a,
+	0xe0,
+	0xfd,
+	0xbd,
+	0xdb,
+	0x06,
+	0x90,
+	0x30,
+	0x02,
+	0x74,
+	0x4c,
+	0xf0,
+	0x90,
+	0x69,
+	0xf2,
+	0xe0,
+	0x24,
+	0x01,
+	0xf0,
+	0x12,
+	0x02,
+	0xeb,
+	0x02,
+	0x06,
+	0xf2,
+	0x90,
+	0x69,
+	0xe9,
+	0xe0,
+	0xfd,
+	0x60,
+	0x03,
+	0x02,
+	0x15,
+	0x51,
+	0x90,
+	0x30,
+	0x2b,
+	0xe0,
+	0xfd,
+	0x20,
+	0xe1,
+	0x03,
+	0x02,
+	0x15,
+	0x51,
+	0x90,
+	0x30,
+	0x2f,
+	0xe0,
+	0x90,
+	0x30,
+	0x2c,
+	0xf0,
+	0x90,
+	0x30,
+	0x49,
+	0xe0,
+	0xfd,
+	0x90,
+	0x30,
+	0x4f,
+	0xe0,
+	0xfc,
+	0xed,
+	0xb5,
+	0x04,
+	0x3b,
+	0x90,
+	0x30,
+	0x02,
+	0xe0,
+	0xfd,
+	0x20,
+	0xe7,
+	0x33,
+	0x90,
+	0x30,
+	0x49,
+	0xe0,
+	0xfd,
+	0xbd,
+	0xff,
+	0x1e,
+	0x90,
+	0x30,
+	0x4a,
+	0xe0,
+	0xfd,
+	0xbd,
+	0xff,
+	0x0b,
+	0x90,
+	0x30,
+	0x4b,
+	0xe0,
+	0xfd,
+	0x0d,
+	0x90,
+	0x30,
+	0x4b,
+	0xed,
+	0xf0,
+	0x90,
+	0x30,
+	0x4a,
+	0xe0,
+	0xfd,
+	0x0d,
+	0x90,
+	0x30,
+	0x4a,
+	0xed,
+	0xf0,
+	0x90,
+	0x30,
+	0x49,
+	0xe0,
+	0xfd,
+	0x0d,
+	0x90,
+	0x30,
+	0x49,
+	0xed,
+	0xf0,
+	0x80,
+	0x19,
+	0x90,
+	0x30,
+	0x51,
+	0xe0,
+	0x90,
+	0x30,
+	0x4b,
+	0xf0,
+	0x90,
+	0x30,
+	0x50,
+	0xe0,
+	0x90,
+	0x30,
+	0x4a,
+	0xf0,
+	0x90,
+	0x30,
+	0x4f,
+	0xe0,
+	0xfd,
+	0x90,
+	0x30,
+	0x49,
+	0xf0,
+	0x90,
+	0x6c,
+	0x5c,
+	0xe0,
+	0xfc,
+	0xa3,
+	0xe0,
+	0xfd,
+	0xc0,
+	0x05,
+	0xc0,
+	0x04,
+	0x8c,
+	0x82,
+	0x8d,
+	0x83,
+	0x12,
+	0x00,
+	0x23,
+	0xd0,
+	0x04,
+	0xd0,
+	0x05,
+	0x90,
+	0x30,
+	0x2d,
+	0x74,
+	0x02,
+	0xf0,
+	0x90,
+	0x30,
+	0x37,
+	0xe0,
+	0xf5,
+	0x82,
+	0x12,
+	0x02,
+	0x9f,
+	0x90,
+	0x6c,
+	0xd0,
+	0xe0,
+	0xfc,
+	0xa3,
+	0xe0,
+	0xfd,
+	0xc0,
+	0x05,
+	0xc0,
+	0x04,
+	0x8c,
+	0x82,
+	0x8d,
+	0x83,
+	0x12,
+	0x00,
+	0x23,
+	0xd0,
+	0x04,
+	0xd0,
+	0x05,
+	0x90,
+	0x6c,
+	0xc4,
+	0xe0,
+	0xfc,
+	0xa3,
+	0xe0,
+	0xfd,
+	0xc0,
+	0x05,
+	0xc0,
+	0x04,
+	0x8c,
+	0x82,
+	0x8d,
+	0x83,
+	0x12,
+	0x00,
+	0x23,
+	0xd0,
+	0x04,
+	0xd0,
+	0x05,
+	0x90,
+	0x30,
+	0x07,
+	0xe0,
+	0xfd,
+	0x54,
+	0x77,
+	0xf0,
+	0x90,
+	0x69,
+	0xe9,
+	0x74,
+	0x01,
+	0xf0,
+	0x02,
+	0x06,
+	0xf2,
+	0x90,
+	0x69,
+	0xe1,
+	0xe0,
+	0xfd,
+	0x70,
+	0x03,
+	0x02,
+	0x06,
+	0xf2,
+	0x90,
+	0x69,
+	0xe1,
+	0xe4,
+	0xf0,
+	0x12,
+	0x02,
+	0x96,
+	0x90,
+	0x69,
+	0xe9,
+	0xe0,
+	0xfd,
+	0x60,
+	0x28,
+	0x90,
+	0x69,
+	0xe9,
+	0xe4,
+	0xf0,
+	0x90,
+	0x30,
+	0x07,
+	0xe0,
+	0x44,
+	0x08,
+	0xf0,
+	0x90,
+	0x30,
+	0x0f,
+	0x74,
+	0x80,
+	0xf0,
+	0x90,
+	0x30,
+	0x0a,
+	0xe0,
+	0xfd,
+	0xbd,
+	0xdb,
+	0x02,
+	0x80,
+	0x03,
+	0x02,
+	0x06,
+	0xf2,
+	0x90,
+	0x30,
+	0x02,
+	0x74,
+	0x4d,
+	0xf0,
+	0x02,
+	0x06,
+	0xf2,
+	0x90,
+	0x30,
+	0x07,
+	0xe0,
+	0xfd,
+	0x44,
+	0x81,
+	0xf0,
+	0x02,
+	0x06,
+	0xf2,
+	0x90,
+	0x30,
+	0x08,
+	0xe4,
+	0xf0,
+	0x02,
+	0x06,
+	0xf2,
+	0x90,
+	0x30,
+	0x03,
+	0xe0,
+	0xfd,
+	0xbd,
+	0xff,
+	0x06,
+	0x75,
+	0xf7,
+	0x01,
+	0x75,
+	0xf7,
+	0x01,
+	0x90,
+	0x30,
+	0x03,
+	0xe0,
+	0xfd,
+	0xbd,
+	0xdb,
+	0x3f,
+	0x90,
+	0x69,
+	0xe1,
+	0xe4,
+	0xf0,
+	0x12,
+	0x02,
+	0x96,
+	0x90,
+	0x30,
+	0x32,
+	0xe0,
+	0xf5,
+	0x82,
+	0x12,
+	0x02,
+	0x9f,
+	0x7d,
+	0x00,
+	0x90,
+	0x30,
+	0x03,
+	0xe0,
+	0xfc,
+	0xbc,
+	0xdb,
+	0x24,
+	0x90,
+	0x69,
+	0xe1,
+	0xe0,
+	0xfc,
+	0x60,
+	0xf1,
+	0x90,
+	0x69,
+	0xe1,
+	0xe4,
+	0xf0,
+	0xc0,
+	0x05,
+	0x12,
+	0x02,
+	0x96,
+	0x90,
+	0x30,
+	0x32,
+	0xe0,
+	0xf5,
+	0x82,
+	0x12,
+	0x02,
+	0x9f,
+	0xd0,
+	0x05,
+	0x90,
+	0x30,
+	0x03,
+	0xed,
+	0xf0,
+	0x0d,
+	0x80,
+	0xd4,
+	0x90,
+	0x30,
+	0x00,
+	0xe0,
+	0xfd,
+	0xbd,
+	0x20,
+	0x05,
+	0x75,
+	0xff,
+	0x01,
+	0x80,
+	0x9e,
+	0x90,
+	0x69,
+	0x8f,
+	0xe0,
+	0xfd,
+	0x60,
+	0x10,
+	0x75,
+	0xff,
+	0x01,
+	0x90,
+	0x30,
+	0x07,
+	0xe4,
+	0xf0,
+	0x90,
+	0x30,
+	0x08,
+	0x74,
+	0x40,
+	0xf0,
+	0x80,
+	0x87,
+	0x90,
+	0x30,
+	0x08,
+	0xe0,
+	0xfd,
+	0x60,
+	0x2d,
+	0xbd,
+	0x0f,
+	0x03,
+	0x02,
+	0x17,
+	0x94,
+	0xbd,
+	0x15,
+	0x03,
+	0x02,
+	0x18,
+	0x27,
+	0xbd,
+	0x18,
+	0x03,
+	0x02,
+	0x19,
+	0xc8,
+	0xbd,
+	0x1b,
+	0x03,
+	0x02,
+	0x1a,
+	0x29,
+	0xbd,
+	0x1d,
+	0x03,
+	0x02,
+	0x1b,
+	0x67,
+	0xbd,
+	0x28,
+	0x03,
+	0x02,
+	0x16,
+	0xcb,
+	0xbd,
+	0x2b,
+	0x03,
+	0x02,
+	0x1c,
+	0x1b,
+	0x02,
+	0x1e,
+	0x76,
+	0x90,
+	0x69,
+	0xea,
+	0xe4,
+	0xf0,
+	0xd2,
+	0xaa,
+	0x90,
+	0x6c,
+	0x34,
+	0xe0,
+	0xfd,
+	0x60,
+	0x46,
+	0x90,
+	0x69,
+	0xe3,
+	0xe4,
+	0xf0,
+	0x90,
+	0x6c,
+	0x34,
+	0xf0,
+	0x90,
+	0x30,
+	0x2e,
+	0x74,
+	0x01,
+	0xf0,
+	0x12,
+	0x02,
+	0x96,
+	0xd2,
+	0xaa,
+	0x90,
+	0x30,
+	0x33,
+	0xe0,
+	0xf5,
+	0x82,
+	0x12,
+	0x02,
+	0xcf,
+	0x90,
+	0x6d,
+	0x04,
+	0xe0,
+	0xfc,
+	0xa3,
+	0xe0,
+	0xfd,
+	0xc0,
+	0x05,
+	0xc0,
+	0x04,
+	0x8c,
+	0x82,
+	0x8d,
+	0x83,
+	0x12,
+	0x00,
+	0x23,
+	0xd0,
+	0x04,
+	0xd0,
+	0x05,
+	0x12,
+	0x02,
+	0x96,
+	0x90,
+	0x30,
+	0x2e,
+	0x74,
+	0x04,
+	0xf0,
+	0x90,
+	0x30,
+	0x08,
+	0x74,
+	0x28,
+	0xf0,
+	0x02,
+	0x15,
+	0xa5,
+	0x90,
+	0x69,
+	0xe3,
+	0xe0,
+	0xfd,
+	0x70,
+	0x03,
+	0x02,
+	0x15,
+	0xa5,
+	0x90,
+	0x69,
+	0xe3,
+	0xe4,
+	0xf0,
+	0xd2,
+	0xaa,
+	0x90,
+	0x30,
+	0x0a,
+	0xe0,
+	0xfd,
+	0xbd,
+	0xdb,
+	0x06,
+	0x90,
+	0x30,
+	0x02,
+	0x74,
+	0xa3,
+	0xf0,
+	0x12,
+	0x02,
+	0xeb,
+	0x02,
+	0x15,
+	0xa5,
+	0x90,
+	0x69,
+	0xe3,
+	0xe0,
+	0xfd,
+	0x70,
+	0x03,
+	0x02,
+	0x15,
+	0xa5,
+	0x90,
+	0x69,
+	0xe3,
+	0xe4,
+	0xf0,
+	0x12,
+	0x02,
+	0x96,
+	0x90,
+	0x30,
+	0x33,
+	0xe0,
+	0xf5,
+	0x82,
+	0x12,
+	0x02,
+	0xcf,
+	0x90,
+	0x69,
+	0xe4,
+	0xe0,
+	0xfd,
+	0xbd,
+	0x04,
+	0x45,
+	0x90,
+	0x6d,
+	0x00,
+	0xe0,
+	0xfc,
+	0xa3,
+	0xe0,
+	0xfd,
+	0xc0,
+	0x05,
+	0xc0,
+	0x04,
+	0x8c,
+	0x82,
+	0x8d,
+	0x83,
+	0x12,
+	0x00,
+	0x23,
+	0xd0,
+	0x04,
+	0xd0,
+	0x05,
+	0x90,
+	0x30,
+	0x0f,
+	0x74,
+	0x01,
+	0xf0,
+	0xd2,
+	0xaa,
+	0x90,
+	0x6c,
+	0xd4,
+	0xe0,
+	0xfc,
+	0xa3,
+	0xe0,
+	0xfd,
+	0xc0,
+	0x05,
+	0xc0,
+	0x04,
+	0x8c,
+	0x82,
+	0x8d,
+	0x83,
+	0x12,
+	0x00,
+	0x23,
+	0xd0,
+	0x04,
+	0xd0,
+	0x05,
+	0x90,
+	0x30,
+	0x0f,
+	0x74,
+	0x08,
+	0xf0,
+	0x90,
+	0x30,
+	0x08,
+	0x74,
+	0x0f,
+	0xf0,
+	0x02,
+	0x15,
+	0xa5,
+	0x90,
+	0x69,
+	0xe4,
+	0xe0,
+	0xfd,
+	0xbd,
+	0x05,
+	0x45,
+	0x90,
+	0x69,
+	0xea,
+	0x74,
+	0x01,
+	0xf0,
+	0x90,
+	0x6c,
+	0xfc,
+	0xe0,
+	0xfc,
+	0xa3,
+	0xe0,
+	0xfd,
+	0xc0,
+	0x05,
+	0xc0,
+	0x04,
+	0x8c,
+	0x82,
+	0x8d,
+	0x83,
+	0x12,
+	0x00,
+	0x23,
+	0xd0,
+	0x04,
+	0xd0,
+	0x05,
+	0x90,
+	0x30,
+	0x0f,
+	0x74,
+	0x02,
+	0xf0,
+	0xd2,
+	0xaa,
+	0x90,
+	0x6c,
+	0xd4,
+	0xe0,
+	0xfc,
+	0xa3,
+	0xe0,
+	0xfd,
+	0xc0,
+	0x05,
+	0xc0,
+	0x04,
+	0x8c,
+	0x82,
+	0x8d,
+	0x83,
+	0x12,
+	0x00,
+	0x23,
+	0xd0,
+	0x04,
+	0xd0,
+	0x05,
+	0x90,
+	0x30,
+	0x08,
+	0x74,
+	0x0f,
+	0xf0,
+	0x02,
+	0x15,
+	0xa5,
+	0x90,
+	0x30,
+	0x0a,
+	0xe0,
+	0xfd,
+	0xbd,
+	0xdb,
+	0x06,
+	0x90,
+	0x30,
+	0x02,
+	0x74,
+	0xa4,
+	0xf0,
+	0x12,
+	0x02,
+	0xeb,
+	0x02,
+	0x15,
+	0xa5,
+	0x90,
+	0x69,
+	0xe3,
+	0xe0,
+	0xfd,
+	0x70,
+	0x03,
+	0x02,
+	0x15,
+	0xa5,
+	0x90,
+	0x69,
+	0xe3,
+	0xe4,
+	0xf0,
+	0x12,
+	0x02,
+	0x96,
+	0x90,
+	0x69,
+	0xe4,
+	0xe0,
+	0xfd,
+	0xbd,
+	0x09,
+	0x65,
+	0x90,
+	0x30,
+	0x33,
+	0xe0,
+	0xf5,
+	0x82,
+	0x12,
+	0x02,
+	0xcf,
+	0x90,
+	0x6c,
+	0xf8,
+	0xe0,
+	0xfc,
+	0xa3,
+	0xe0,
+	0xfd,
+	0xc0,
+	0x05,
+	0xc0,
+	0x04,
+	0x8c,
+	0x82,
+	0x8d,
+	0x83,
+	0x12,
+	0x00,
+	0x23,
+	0xd0,
+	0x04,
+	0xd0,
+	0x05,
+	0x90,
+	0x30,
+	0x0f,
+	0x74,
+	0x10,
+	0xf0,
+	0xd2,
+	0xaa,
+	0x90,
+	0x6c,
+	0xc0,
+	0xe0,
+	0xfc,
+	0xa3,
+	0xe0,
+	0xfd,
+	0xc0,
+	0x05,
+	0xc0,
+	0x04,
+	0x8c,
+	0x82,
+	0x8d,
+	0x83,
+	0x12,
+	0x00,
+	0x23,
+	0xd0,
+	0x04,
+	0xd0,
+	0x05,
+	0x90,
+	0x6c,
+	0xf4,
+	0xe0,
+	0xfc,
+	0xa3,
+	0xe0,
+	0xfd,
+	0xc0,
+	0x05,
+	0xc0,
+	0x04,
+	0x8c,
+	0x82,
+	0x8d,
+	0x83,
+	0x12,
+	0x00,
+	0x23,
+	0xd0,
+	0x04,
+	0xd0,
+	0x05,
+	0x90,
+	0x30,
+	0x0f,
+	0x74,
+	0x20,
+	0xf0,
+	0x90,
+	0x30,
+	0x08,
+	0x74,
+	0x15,
+	0xf0,
+	0x02,
+	0x15,
+	0xa5,
+	0x90,
+	0x30,
+	0x0a,
+	0xe0,
+	0xfd,
+	0xbd,
+	0xdb,
+	0x06,
+	0x90,
+	0x30,
+	0x02,
+	0x74,
+	0xa6,
+	0xf0,
+	0x12,
+	0x02,
+	0xeb,
+	0x02,
+	0x15,
+	0xa5,
+	0x90,
+	0x69,
+	0xe3,
+	0xe0,
+	0xfd,
+	0x70,
+	0x03,
+	0x02,
+	0x15,
+	0xa5,
+	0x90,
+	0x69,
+	0xe3,
+	0xe4,
+	0xf0,
+	0x12,
+	0x02,
+	0x96,
+	0x90,
+	0x69,
+	0xe4,
+	0xe0,
+	0xfd,
+	0xbd,
+	0x0b,
+	0x02,
+	0x80,
+	0x03,
+	0x02,
+	0x19,
+	0xb4,
+	0x90,
+	0x30,
+	0x33,
+	0xe0,
+	0xf5,
+	0x82,
+	0x12,
+	0x02,
+	0xcf,
+	0x90,
+	0x30,
+	0x0a,
+	0xe0,
+	0xfd,
+	0xbd,
+	0xdb,
+	0x06,
+	0x90,
+	0x30,
+	0x02,
+	0x74,
+	0xaa,
+	0xf0,
+	0x90,
+	0x6c,
+	0xf0,
+	0xe0,
+	0xfc,
+	0xa3,
+	0xe0,
+	0xfd,
+	0xc0,
+	0x05,
+	0xc0,
+	0x04,
+	0x8c,
+	0x82,
+	0x8d,
+	0x83,
+	0x12,
+	0x00,
+	0x23,
+	0xd0,
+	0x04,
+	0xd0,
+	0x05,
+	0x12,
+	0x02,
+	0x96,
+	0x90,
+	0x30,
+	0x2e,
+	0x74,
+	0x02,
+	0xf0,
+	0xd2,
+	0xaa,
+	0x90,
+	0x6c,
+	0xcc,
+	0xe0,
+	0xfc,
+	0xa3,
+	0xe0,
+	0xfd,
+	0x90,
+	0x69,
+	0xe7,
+	0xe0,
+	0xfb,
+	0xc0,
+	0x05,
+	0xc0,
+	0x04,
+	0x74,
+	0x9f,
+	0xc0,
+	0xe0,
+	0x74,
+	0x18,
+	0xc0,
+	0xe0,
+	0xc0,
+	0x04,
+	0xc0,
+	0x05,
+	0x8b,
+	0x82,
+	0x22,
+	0xd0,
+	0x04,
+	0xd0,
+	0x05,
+	0x90,
+	0x6c,
+	0xec,
+	0xe0,
+	0xfc,
+	0xa3,
+	0xe0,
+	0xfd,
+	0xc0,
+	0x05,
+	0xc0,
+	0x04,
+	0x8c,
+	0x82,
+	0x8d,
+	0x83,
+	0x12,
+	0x00,
+	0x23,
+	0xd0,
+	0x04,
+	0xd0,
+	0x05,
+	0x90,
+	0x63,
+	0x64,
+	0x75,
+	0xf0,
+	0x00,
+	0x12,
+	0x21,
+	0x7d,
+	0xfa,
+	0xa3,
+	0x12,
+	0x21,
+	0x7d,
+	0xfb,
+	0xa3,
+	0x12,
+	0x21,
+	0x7d,
+	0xfc,
+	0xa3,
+	0x12,
+	0x21,
+	0x7d,
+	0xfd,
+	0x90,
+	0x44,
+	0xcc,
+	0xea,
+	0xf0,
+	0xa3,
+	0xeb,
+	0xf0,
+	0xa3,
+	0xec,
+	0xf0,
+	0xa3,
+	0xed,
+	0xf0,
+	0x90,
+	0x63,
+	0x60,
+	0x75,
+	0xf0,
+	0x00,
+	0x12,
+	0x21,
+	0x7d,
+	0xfa,
+	0xa3,
+	0x12,
+	0x21,
+	0x7d,
+	0xfb,
+	0xa3,
+	0x12,
+	0x21,
+	0x7d,
+	0xfc,
+	0xa3,
+	0x12,
+	0x21,
+	0x7d,
+	0xfd,
+	0x90,
+	0x44,
+	0xc8,
+	0xea,
+	0xf0,
+	0xa3,
+	0xeb,
+	0xf0,
+	0xa3,
+	0xec,
+	0xf0,
+	0xa3,
+	0xed,
+	0xf0,
+	0x90,
+	0x63,
+	0x5c,
+	0x75,
+	0xf0,
+	0x00,
+	0x12,
+	0x21,
+	0x7d,
+	0xfa,
+	0xa3,
+	0x12,
+	0x21,
+	0x7d,
+	0xfb,
+	0xa3,
+	0x12,
+	0x21,
+	0x7d,
+	0xfc,
+	0xa3,
+	0x12,
+	0x21,
+	0x7d,
+	0xfd,
+	0x90,
+	0x44,
+	0xc4,
+	0xea,
+	0xf0,
+	0xa3,
+	0xeb,
+	0xf0,
+	0xa3,
+	0xec,
+	0xf0,
+	0xa3,
+	0xed,
+	0xf0,
+	0x90,
+	0x63,
+	0x58,
+	0xe0,
+	0xfa,
+	0xa3,
+	0xe0,
+	0xfb,
+	0xa3,
+	0xe0,
+	0xfc,
+	0xa3,
+	0xe0,
+	0xfd,
+	0x90,
+	0x44,
+	0xc0,
+	0xea,
+	0xf0,
+	0xa3,
+	0xeb,
+	0xf0,
+	0xa3,
+	0xec,
+	0xf0,
+	0xa3,
+	0xed,
+	0xf0,
+	0x90,
+	0x63,
+	0x54,
+	0x75,
+	0xf0,
+	0x00,
+	0x12,
+	0x21,
+	0x7d,
+	0xfa,
+	0xa3,
+	0x12,
+	0x21,
+	0x7d,
+	0xfb,
+	0xa3,
+	0x12,
+	0x21,
+	0x7d,
+	0xfc,
+	0xa3,
+	0x12,
+	0x21,
+	0x7d,
+	0xfd,
+	0x90,
+	0x44,
+	0x84,
+	0xea,
+	0xf0,
+	0xa3,
+	0xeb,
+	0xf0,
+	0xa3,
+	0xec,
+	0xf0,
+	0xa3,
+	0xed,
+	0xf0,
+	0x90,
+	0x63,
+	0x50,
+	0xe0,
+	0xfa,
+	0xa3,
+	0xe0,
+	0xfb,
+	0xa3,
+	0xe0,
+	0xfc,
+	0xa3,
+	0xe0,
+	0xfd,
+	0x90,
+	0x44,
+	0x80,
+	0xea,
+	0xf0,
+	0xa3,
+	0xeb,
+	0xf0,
+	0xa3,
+	0xec,
+	0xf0,
+	0xa3,
+	0xed,
+	0xf0,
+	0x90,
+	0x30,
+	0x45,
+	0xe0,
+	0xfd,
+	0x60,
+	0x16,
+	0x90,
+	0x30,
+	0x02,
+	0xe0,
+	0xfd,
+	0x53,
+	0x05,
+	0x08,
+	0xbd,
+	0x08,
+	0x02,
+	0x80,
+	0x09,
+	0x90,
+	0x30,
+	0x08,
+	0x74,
+	0x18,
+	0xf0,
+	0x02,
+	0x15,
+	0xa5,
+	0x90,
+	0x30,
+	0x08,
+	0x74,
+	0x2b,
+	0xf0,
+	0x02,
+	0x15,
+	0xa5,
+	0x90,
+	0x30,
+	0x0a,
+	0xe0,
+	0xfd,
+	0xbd,
+	0xdb,
+	0x06,
+	0x90,
+	0x30,
+	0x02,
+	0x74,
+	0xab,
+	0xf0,
+	0x12,
+	0x02,
+	0xeb,
+	0x02,
+	0x15,
+	0xa5,
+	0x90,
+	0x30,
+	0x23,
+	0xe0,
+	0xfd,
+	0x70,
+	0x03,
+	0x02,
+	0x15,
+	0xa5,
+	0x90,
+	0x30,
+	0x23,
+	0xe0,
+	0x90,
+	0x30,
+	0x20,
+	0xf0,
+	0x90,
+	0x30,
+	0x24,
+	0xe0,
+	0x90,
+	0x30,
+	0x21,
+	0xf0,
+	0x90,
+	0x30,
+	0x25,
+	0xe0,
+	0xfd,
+	0x90,
+	0x30,
+	0x22,
+	0x74,
+	0x0f,
+	0x5d,
+	0xf0,
+	0x90,
+	0x30,
+	0x48,
+	0xe4,
+	0xf0,
+	0x90,
+	0x30,
+	0x47,
+	0xf0,
+	0x90,
+	0x30,
+	0x46,
+	0xf0,
+	0x90,
+	0x6c,
+	0xd8,
+	0xe0,
+	0xfc,
+	0xa3,
+	0xe0,
+	0xfd,
+	0xc0,
+	0x05,
+	0xc0,
+	0x04,
+	0x8c,
+	0x82,
+	0x8d,
+	0x83,
+	0x12,
+	0x00,
+	0x23,
+	0xd0,
+	0x04,
+	0xd0,
+	0x05,
+	0x90,
+	0x69,
+	0xe1,
+	0xe4,
+	0xf0,
+	0x12,
+	0x02,
+	0x96,
+	0x90,
+	0x30,
+	0x2d,
+	0x74,
+	0x01,
+	0xf0,
+	0x90,
+	0x30,
+	0x08,
+	0x74,
+	0x1b,
+	0xf0,
+	0x02,
+	0x15,
+	0xa5,
+	0x90,
+	0x69,
+	0xe3,
+	0xe0,
+	0xfd,
+	0x70,
+	0x03,
+	0x02,
+	0x1b,
+	0x4f,
+	0x90,
+	0x69,
+	0xe3,
+	0xe4,
+	0xf0,
+	0x90,
+	0x69,
+	0xe4,
+	0xe0,
+	0xfd,
+	0xbd,
+	0x0f,
+	0x02,
+	0x80,
+	0x03,
+	0x02,
+	0x1a,
+	0xcc,
+	0x90,
+	0x6c,
+	0xe8,
+	0xe0,
+	0xfc,
+	0xa3,
+	0xe0,
+	0xfd,
+	0xc0,
+	0x05,
+	0xc0,
+	0x04,
+	0x8c,
+	0x82,
+	0x8d,
+	0x83,
+	0x12,
+	0x00,
+	0x23,
+	0xd0,
+	0x04,
+	0xd0,
+	0x05,
+	0x12,
+	0x02,
+	0x96,
+	0x90,
+	0x30,
+	0x0f,
+	0x74,
+	0x40,
+	0xf0,
+	0x90,
+	0x6c,
+	0xe4,
+	0xe0,
+	0xfc,
+	0xa3,
+	0xe0,
+	0xfd,
+	0x8c,
+	0x82,
+	0x8d,
+	0x83,
+	0x12,
+	0x00,
+	0x23,
+	0xac,
+	0x82,
+	0xad,
+	0x83,
+	0x8c,
+	0x06,
+	0x8d,
+	0x07,
+	0xee,
+	0x4f,
+	0x60,
+	0x1e,
+	0x90,
+	0x30,
+	0x07,
+	0xe0,
+	0x44,
+	0x08,
+	0xf0,
+	0xe0,
+	0x54,
+	0xfe,
+	0xf0,
+	0x90,
+	0x30,
+	0x0a,
+	0xe0,
+	0xfd,
+	0xbd,
+	0xdb,
+	0x06,
+	0x90,
+	0x30,
+	0x02,
+	0x74,
+	0xac,
+	0xf0,
+	0x12,
+	0x02,
+	0xeb,
+	0x80,
+	0x0e,
+	0x90,
+	0x30,
+	0x0a,
+	0xe0,
+	0xfd,
+	0xbd,
+	0xdb,
+	0x06,
+	0x90,
+	0x30,
+	0x02,
+	0x74,
+	0xad,
+	0xf0,
+	0xd2,
+	0xaa,
+	0x90,
+	0x69,
+	0xe9,
+	0xe0,
+	0xfd,
+	0x60,
+	0x0e,
+	0x90,
+	0x69,
+	0xe9,
+	0xe4,
+	0xf0,
+	0x90,
+	0x30,
+	0x08,
+	0x74,
+	0x2b,
+	0xf0,
+	0x02,
+	0x15,
+	0xa5,
+	0x90,
+	0x30,
+	0x08,
+	0x74,
+	0x1d,
+	0xf0,
+	0x02,
+	0x15,
+	0xa5,
+	0x90,
+	0x69,
+	0xe4,
+	0xe0,
+	0xfd,
+	0xbd,
+	0x10,
+	0x75,
+	0x90,
+	0x69,
+	0xe1,
+	0xe4,
+	0xf0,
+	0x12,
+	0x02,
+	0x96,
+	0x90,
+	0x6c,
+	0xe0,
+	0xe0,
+	0xfc,
+	0xa3,
+	0xe0,
+	0xfd,
+	0xc0,
+	0x05,
+	0xc0,
+	0x04,
+	0x8c,
+	0x82,
+	0x8d,
+	0x83,
+	0x12,
+	0x00,
+	0x23,
+	0xd0,
+	0x04,
+	0xd0,
+	0x05,
+	0x90,
+	0x6c,
+	0xd0,
+	0xe0,
+	0xfc,
+	0xa3,
+	0xe0,
+	0xfd,
+	0xc0,
+	0x05,
+	0xc0,
+	0x04,
+	0x8c,
+	0x82,
+	0x8d,
+	0x83,
+	0x12,
+	0x00,
+	0x23,
+	0xd0,
+	0x04,
+	0xd0,
+	0x05,
+	0x90,
+	0x6c,
+	0xc4,
+	0xe0,
+	0xfc,
+	0xa3,
+	0xe0,
+	0xfd,
+	0xc0,
+	0x05,
+	0xc0,
+	0x04,
+	0x8c,
+	0x82,
+	0x8d,
+	0x83,
+	0x12,
+	0x00,
+	0x23,
+	0xd0,
+	0x04,
+	0xd0,
+	0x05,
+	0x90,
+	0x6c,
+	0xdc,
+	0xe0,
+	0xfc,
+	0xa3,
+	0xe0,
+	0xfd,
+	0xc0,
+	0x05,
+	0xc0,
+	0x04,
+	0x8c,
+	0x82,
+	0x8d,
+	0x83,
+	0x12,
+	0x00,
+	0x23,
+	0xd0,
+	0x04,
+	0xd0,
+	0x05,
+	0x90,
+	0x30,
+	0x0f,
+	0x74,
+	0x80,
+	0xf0,
+	0xd2,
+	0xaa,
+	0x90,
+	0x69,
+	0xe9,
+	0x74,
+	0x01,
+	0xf0,
+	0x02,
+	0x15,
+	0xa5,
+	0x12,
+	0x02,
+	0xeb,
+	0x02,
+	0x15,
+	0xa5,
+	0x90,
+	0x69,
+	0xe1,
+	0xe0,
+	0xfd,
+	0x70,
+	0x03,
+	0x02,
+	0x15,
+	0xa5,
+	0x90,
+	0x69,
+	0xe1,
+	0xe4,
+	0xf0,
+	0x12,
+	0x02,
+	0x96,
+	0x12,
+	0x02,
+	0xeb,
+	0x02,
+	0x15,
+	0xa5,
+	0x90,
+	0x69,
+	0xe3,
+	0xe0,
+	0xfd,
+	0x70,
+	0x03,
+	0x02,
+	0x1c,
+	0x03,
+	0x90,
+	0x69,
+	0xe3,
+	0xe4,
+	0xf0,
+	0x90,
+	0x69,
+	0xe4,
+	0xe0,
+	0xfd,
+	0xbd,
+	0x10,
+	0x02,
+	0x80,
+	0x02,
+	0x80,
+	0x7b,
+	0x90,
+	0x69,
+	0xe1,
+	0xe4,
+	0xf0,
+	0x12,
+	0x02,
+	0x96,
+	0x90,
+	0x6c,
+	0xe0,
+	0xe0,
+	0xfc,
+	0xa3,
+	0xe0,
+	0xfd,
+	0xc0,
+	0x05,
+	0xc0,
+	0x04,
+	0x8c,
+	0x82,
+	0x8d,
+	0x83,
+	0x12,
+	0x00,
+	0x23,
+	0xd0,
+	0x04,
+	0xd0,
+	0x05,
+	0x90,
+	0x6c,
+	0xd0,
+	0xe0,
+	0xfc,
+	0xa3,
+	0xe0,
+	0xfd,
+	0xc0,
+	0x05,
+	0xc0,
+	0x04,
+	0x8c,
+	0x82,
+	0x8d,
+	0x83,
+	0x12,
+	0x00,
+	0x23,
+	0xd0,
+	0x04,
+	0xd0,
+	0x05,
+	0x90,
+	0x6c,
+	0xc4,
+	0xe0,
+	0xfc,
+	0xa3,
+	0xe0,
+	0xfd,
+	0xc0,
+	0x05,
+	0xc0,
+	0x04,
+	0x8c,
+	0x82,
+	0x8d,
+	0x83,
+	0x12,
+	0x00,
+	0x23,
+	0xd0,
+	0x04,
+	0xd0,
+	0x05,
+	0x90,
+	0x6c,
+	0xdc,
+	0xe0,
+	0xfc,
+	0xa3,
+	0xe0,
+	0xfd,
+	0xc0,
+	0x05,
+	0xc0,
+	0x04,
+	0x8c,
+	0x82,
+	0x8d,
+	0x83,
+	0x12,
+	0x00,
+	0x23,
+	0xd0,
+	0x04,
+	0xd0,
+	0x05,
+	0x90,
+	0x30,
+	0x0f,
+	0x74,
+	0x80,
+	0xf0,
+	0xd2,
+	0xaa,
+	0x90,
+	0x30,
+	0x2b,
+	0x74,
+	0x01,
+	0xf0,
+	0x90,
+	0x30,
+	0x08,
+	0x74,
+	0x2b,
+	0xf0,
+	0x02,
+	0x15,
+	0xa5,
+	0x12,
+	0x02,
+	0xeb,
+	0x02,
+	0x15,
+	0xa5,
+	0x90,
+	0x69,
+	0xe1,
+	0xe0,
+	0xfd,
+	0x70,
+	0x03,
+	0x02,
+	0x15,
+	0xa5,
+	0x90,
+	0x69,
+	0xe1,
+	0xe4,
+	0xf0,
+	0x12,
+	0x02,
+	0x96,
+	0x12,
+	0x02,
+	0xeb,
+	0x02,
+	0x15,
+	0xa5,
+	0x90,
+	0x30,
+	0x07,
+	0xe0,
+	0x44,
+	0x01,
+	0xf0,
+	0x90,
+	0x69,
+	0xe3,
+	0xe0,
+	0xfd,
+	0x70,
+	0x03,
+	0x02,
+	0x1d,
+	0xd7,
+	0x90,
+	0x69,
+	0xe3,
+	0xe4,
+	0xf0,
+	0x90,
+	0x69,
+	0xe4,
+	0xe0,
+	0xfd,
+	0xbd,
+	0x0f,
+	0x72,
+	0x90,
+	0x6c,
+	0xe8,
+	0xe0,
+	0xfc,
+	0xa3,
+	0xe0,
+	0xfd,
+	0xc0,
+	0x05,
+	0xc0,
+	0x04,
+	0x8c,
+	0x82,
+	0x8d,
+	0x83,
+	0x12,
+	0x00,
+	0x23,
+	0xd0,
+	0x04,
+	0xd0,
+	0x05,
+	0x12,
+	0x02,
+	0x96,
+	0x90,
+	0x30,
+	0x0f,
+	0x74,
+	0x40,
+	0xf0,
+	0x90,
+	0x6c,
+	0xe4,
+	0xe0,
+	0xfc,
+	0xa3,
+	0xe0,
+	0xfd,
+	0x8c,
+	0x82,
+	0x8d,
+	0x83,
+	0x12,
+	0x00,
+	0x23,
+	0xac,
+	0x82,
+	0xad,
+	0x83,
+	0x8c,
+	0x06,
+	0x8d,
+	0x07,
+	0xee,
+	0x4f,
+	0x60,
+	0x1e,
+	0x90,
+	0x30,
+	0x07,
+	0xe0,
+	0x44,
+	0x08,
+	0xf0,
+	0xe0,
+	0x54,
+	0xfe,
+	0xf0,
+	0x90,
+	0x30,
+	0x0a,
+	0xe0,
+	0xff,
+	0xbf,
+	0xdb,
+	0x06,
+	0x90,
+	0x30,
+	0x02,
+	0x74,
+	0xac,
+	0xf0,
+	0x12,
+	0x02,
+	0xeb,
+	0x80,
+	0x0e,
+	0x90,
+	0x30,
+	0x0a,
+	0xe0,
+	0xff,
+	0xbf,
+	0xdb,
+	0x06,
+	0x90,
+	0x30,
+	0x02,
+	0x74,
+	0xad,
+	0xf0,
+	0xd2,
+	0xaa,
+	0x90,
+	0x30,
+	0x2d,
+	0x74,
+	0x01,
+	0xf0,
+	0x02,
+	0x15,
+	0xa5,
+	0x90,
+	0x69,
+	0xe4,
+	0xe0,
+	0xff,
+	0xbf,
+	0x10,
+	0x02,
+	0x80,
+	0x03,
+	0x02,
+	0x15,
+	0xa5,
+	0x12,
+	0x02,
+	0x96,
+	0x90,
+	0x6c,
+	0xe0,
+	0xe0,
+	0xfe,
+	0xa3,
+	0xe0,
+	0xff,
+	0xc0,
+	0x07,
+	0xc0,
+	0x06,
+	0x8e,
+	0x82,
+	0x8f,
+	0x83,
+	0x12,
+	0x00,
+	0x23,
+	0xd0,
+	0x06,
+	0xd0,
+	0x07,
+	0x90,
+	0x30,
+	0x02,
+	0xe0,
+	0xff,
+	0x53,
+	0x07,
+	0x08,
+	0xbf,
+	0x08,
+	0x03,
+	0x02,
+	0x1d,
+	0x81,
+	0x90,
+	0x69,
+	0xba,
+	0xe0,
+	0xff,
+	0x90,
+	0x30,
+	0x4b,
+	0xe0,
+	0xfe,
+	0xc3,
+	0x9f,
+	0x40,
+	0x47,
+	0x90,
+	0x69,
+	0xba,
+	0xe0,
+	0xff,
+	0x90,
+	0x30,
+	0x4b,
+	0xe0,
+	0xfe,
+	0xef,
+	0xb5,
+	0x06,
+	0x0e,
+	0x90,
+	0x69,
+	0xb9,
+	0xe0,
+	0xff,
+	0x90,
+	0x30,
+	0x4a,
+	0xe0,
+	0xfe,
+	0xc3,
+	0x9f,
+	0x40,
+	0x2b,
+	0x90,
+	0x69,
+	0xba,
+	0xe0,
+	0xff,
+	0x90,
+	0x30,
+	0x4b,
+	0xe0,
+	0xfe,
+	0xef,
+	0xb5,
+	0x06,
+	0x37,
+	0x90,
+	0x69,
+	0xb9,
+	0xe0,
+	0xff,
+	0x90,
+	0x30,
+	0x4a,
+	0xe0,
+	0xfe,
+	0xef,
+	0xb5,
+	0x06,
+	0x29,
+	0x90,
+	0x69,
+	0xb8,
+	0xe0,
+	0xff,
+	0x90,
+	0x30,
+	0x49,
+	0xe0,
+	0xfe,
+	0xc3,
+	0xef,
+	0x9e,
+	0x40,
+	0x1a,
+	0x90,
+	0x30,
+	0x02,
+	0xe0,
+	0xff,
+	0x53,
+	0x07,
+	0x20,
+	0xbf,
+	0x20,
+	0x04,
+	0x7f,
+	0x42,
+	0x80,
+	0x02,
+	0x7f,
+	0x00,
+	0x90,
+	0x30,
+	0x07,
+	0xef,
+	0xf0,
+	0xd2,
+	0xaa,
+	0x80,
+	0xfe,
+	0x90,
+	0x69,
+	0xba,
+	0xe0,
+	0xff,
+	0xbf,
+	0xff,
+	0x2a,
+	0x90,
+	0x69,
+	0xb9,
+	0xe0,
+	0xff,
+	0xbf,
+	0xff,
+	0x22,
+	0x90,
+	0x69,
+	0xb8,
+	0xe0,
+	0xff,
+	0xbf,
+	0xff,
+	0x1a,
+	0x90,
+	0x30,
+	0x02,
+	0xe0,
+	0xff,
+	0x53,
+	0x07,
+	0x20,
+	0xbf,
+	0x20,
+	0x04,
+	0x7f,
+	0x42,
+	0x80,
+	0x02,
+	0x7f,
+	0x00,
+	0x90,
+	0x30,
+	0x07,
+	0xef,
+	0xf0,
+	0xd2,
+	0xaa,
+	0x80,
+	0xfe,
+	0x90,
+	0x6c,
+	0xd0,
+	0xe0,
+	0xfe,
+	0xa3,
+	0xe0,
+	0xff,
+	0xc0,
+	0x07,
+	0xc0,
+	0x06,
+	0x8e,
+	0x82,
+	0x8f,
+	0x83,
+	0x12,
+	0x00,
+	0x23,
+	0xd0,
+	0x06,
+	0xd0,
+	0x07,
+	0x90,
+	0x6c,
+	0xc4,
+	0xe0,
+	0xfe,
+	0xa3,
+	0xe0,
+	0xff,
+	0xc0,
+	0x07,
+	0xc0,
+	0x06,
+	0x8e,
+	0x82,
+	0x8f,
+	0x83,
+	0x12,
+	0x00,
+	0x23,
+	0xd0,
+	0x06,
+	0xd0,
+	0x07,
+	0x90,
+	0x6c,
+	0xdc,
+	0xe0,
+	0xfe,
+	0xa3,
+	0xe0,
+	0xff,
+	0xc0,
+	0x07,
+	0xc0,
+	0x06,
+	0x8e,
+	0x82,
+	0x8f,
+	0x83,
+	0x12,
+	0x00,
+	0x23,
+	0xd0,
+	0x06,
+	0xd0,
+	0x07,
+	0x90,
+	0x30,
+	0x2b,
+	0x74,
+	0x01,
+	0xf0,
+	0x90,
+	0x30,
+	0x0f,
+	0x74,
+	0x80,
+	0xf0,
+	0xd2,
+	0xaa,
+	0x02,
+	0x15,
+	0xa5,
+	0x90,
+	0x30,
+	0x2a,
+	0xe0,
+	0xff,
+	0x20,
+	0xe1,
+	0x03,
+	0x02,
+	0x15,
+	0xa5,
+	0x90,
+	0x30,
+	0x23,
+	0xe0,
+	0x90,
+	0x30,
+	0x20,
+	0xf0,
+	0x90,
+	0x30,
+	0x24,
+	0xe0,
+	0x90,
+	0x30,
+	0x21,
+	0xf0,
+	0x90,
+	0x30,
+	0x25,
+	0xe0,
+	0xff,
+	0x90,
+	0x30,
+	0x22,
+	0x74,
+	0x0f,
+	0x5f,
+	0xf0,
+	0x90,
+	0x30,
+	0x46,
+	0xe0,
+	0xff,
+	0x90,
+	0x30,
+	0x4c,
+	0xe0,
+	0xfe,
+	0xef,
+	0xb5,
+	0x06,
+	0x37,
+	0x90,
+	0x30,
+	0x46,
+	0xe0,
+	0xff,
+	0xbf,
+	0xff,
+	0x22,
+	0x90,
+	0x30,
+	0x47,
+	0xe0,
+	0xff,
+	0xbf,
+	0xff,
+	0x0f,
+	0x90,
+	0x30,
+	0x48,
+	0xe0,
+	0x90,
+	0x30,
+	0x48,
+	0xe0,
+	0xff,
+	0x0f,
+	0x90,
+	0x30,
+	0x48,
+	0xef,
+	0xf0,
+	0x90,
+	0x30,
+	0x47,
+	0xe0,
+	0xff,
+	0x0f,
+	0x90,
+	0x30,
+	0x47,
+	0xef,
+	0xf0,
+	0x90,
+	0x30,
+	0x46,
+	0xe0,
+	0xff,
+	0x0f,
+	0x90,
+	0x30,
+	0x46,
+	0xef,
+	0xf0,
+	0x80,
+	0x19,
+	0x90,
+	0x30,
+	0x4e,
+	0xe0,
+	0x90,
+	0x30,
+	0x48,
+	0xf0,
+	0x90,
+	0x30,
+	0x4d,
+	0xe0,
+	0x90,
+	0x30,
+	0x47,
+	0xf0,
+	0x90,
+	0x30,
+	0x4c,
+	0xe0,
+	0xff,
+	0x90,
+	0x30,
+	0x46,
+	0xf0,
+	0x90,
+	0x6c,
+	0xd8,
+	0xe0,
+	0xfe,
+	0xa3,
+	0xe0,
+	0xff,
+	0xc0,
+	0x07,
+	0xc0,
+	0x06,
+	0x8e,
+	0x82,
+	0x8f,
+	0x83,
+	0x12,
+	0x00,
+	0x23,
+	0xd0,
+	0x06,
+	0xd0,
+	0x07,
+	0x02,
+	0x15,
+	0xa5,
+	0x12,
+	0x02,
+	0xeb,
+	0x02,
+	0x15,
+	0xa5,
+	0xad,
+	0x82,
+	0xae,
+	0x83,
+	0xaf,
+	0xf0,
+	0x90,
+	0x00,
+	0x08,
+	0xe0,
+	0xfb,
+	0xa3,
+	0xe0,
+	0xfc,
+	0x4b,
+	0x70,
+	0x24,
+	0x90,
+	0x00,
+	0x08,
+	0x74,
+	0xff,
+	0xf0,
+	0xa3,
+	0xf0,
+	0x90,
+	0x00,
+	0x0a,
+	0x74,
+	0xff,
+	0xf0,
+	0xa3,
+	0xf0,
+	0x90,
+	0x00,
+	0x06,
+	0x74,
+	0xf4,
+	0xf0,
+	0x90,
+	0x00,
+	0x04,
+	0x74,
+	0x01,
+	0xf0,
+	0x90,
+	0x00,
+	0x04,
+	0xe0,
+	0xfc,
+	0x20,
+	0xe0,
+	0xf8,
+	0x90,
+	0x00,
+	0x04,
+	0x74,
+	0x01,
+	0xf0,
+	0x90,
+	0x00,
+	0x04,
+	0xe0,
+	0xfc,
+	0x20,
+	0xe0,
+	0xf8,
+	0x90,
+	0x00,
+	0x00,
+	0xe0,
+	0xf9,
+	0xa3,
+	0xe0,
+	0xfa,
+	0xa3,
+	0xe0,
+	0xfb,
+	0xa3,
+	0xe0,
+	0xfc,
+	0x8d,
+	0x82,
+	0x8e,
+	0x83,
+	0x8f,
+	0xf0,
+	0xe9,
+	0x12,
+	0x20,
+	0xde,
+	0xa3,
+	0xea,
+	0x12,
+	0x20,
+	0xde,
+	0xa3,
+	0xeb,
+	0x12,
+	0x20,
+	0xde,
+	0xa3,
+	0xec,
+	0x02,
+	0x20,
+	0xde,
+	0xc0,
+	0x12,
+	0x85,
+	0x81,
+	0x12,
+	0xc0,
+	0x82,
+	0xc0,
+	0x83,
+	0xc0,
+	0xf0,
+	0xe5,
+	0x81,
+	0x24,
+	0x08,
+	0xf5,
+	0x81,
+	0x7b,
+	0x00,
+	0x7c,
+	0x00,
+	0xa8,
+	0x12,
+	0x08,
+	0x86,
+	0x82,
+	0x08,
+	0x86,
+	0x83,
+	0x08,
+	0x86,
+	0xf0,
+	0xc0,
+	0x04,
+	0xc0,
+	0x03,
+	0x12,
+	0x21,
+	0x65,
+	0xaa,
+	0x82,
+	0xaf,
+	0x83,
+	0xd0,
+	0x03,
+	0xd0,
+	0x04,
+	0xe5,
+	0x12,
+	0x24,
+	0x04,
+	0xf8,
+	0xa6,
+	0x02,
+	0x08,
+	0xa6,
+	0x07,
+	0xe5,
+	0x12,
+	0x24,
+	0x04,
+	0xf8,
+	0xc3,
+	0x74,
+	0x03,
+	0x96,
+	0xe4,
+	0x08,
+	0x96,
+	0x40,
+	0x03,
+	0x02,
+	0x20,
+	0x8b,
+	0xe5,
+	0x12,
+	0x24,
+	0x04,
+	0xf8,
+	0xe6,
+	0x24,
+	0xfd,
+	0xfa,
+	0x08,
+	0xe6,
+	0x34,
+	0xff,
+	0xfd,
+	0xe5,
+	0x12,
+	0x24,
+	0x06,
+	0xf8,
+	0xe4,
+	0xf6,
+	0x08,
+	0xf6,
+	0xe5,
+	0x12,
+	0x24,
+	0x06,
+	0xf8,
+	0x86,
+	0x06,
+	0x08,
+	0x86,
+	0x07,
+	0xc3,
+	0xee,
+	0x9a,
+	0xef,
+	0x9d,
+	0x40,
+	0x03,
+	0x02,
+	0x20,
+	0x81,
+	0xc0,
+	0x02,
+	0xc0,
+	0x05,
+	0xe5,
+	0x12,
+	0x24,
+	0x06,
+	0xf8,
+	0x74,
+	0x03,
+	0x26,
+	0xfe,
+	0xe4,
+	0x08,
+	0x36,
+	0xff,
+	0xa8,
+	0x12,
+	0x08,
+	0xee,
+	0x26,
+	0xfe,
+	0xef,
+	0x08,
+	0x36,
+	0xfd,
+	0x08,
+	0x86,
+	0x07,
+	0x8e,
+	0x82,
+	0x8d,
+	0x83,
+	0x8f,
+	0xf0,
+	0x12,
+	0x21,
+	0x7d,
+	0xfe,
+	0x33,
+	0x95,
+	0xe0,
+	0xe4,
+	0xe5,
+	0x12,
+	0x24,
+	0x08,
+	0xf8,
+	0x08,
+	0x08,
+	0x08,
+	0xa6,
+	0x06,
+	0x18,
+	0x18,
+	0x18,
+	0x76,
+	0x00,
+	0x08,
+	0x76,
+	0x00,
+	0x08,
+	0x76,
+	0x00,
+	0xe5,
+	0x12,
+	0x24,
+	0x06,
+	0xf8,
+	0x74,
+	0x02,
+	0x26,
+	0xfe,
+	0xe4,
+	0x08,
+	0x36,
+	0xff,
+	0xa8,
+	0x12,
+	0x08,
+	0xee,
+	0x26,
+	0xfe,
+	0xef,
+	0x08,
+	0x36,
+	0xff,
+	0x08,
+	0x86,
+	0x05,
+	0x8e,
+	0x82,
+	0x8f,
+	0x83,
+	0x8d,
+	0xf0,
+	0x12,
+	0x21,
+	0x7d,
+	0xfe,
+	0x33,
+	0x95,
+	0xe0,
+	0x7f,
+	0x00,
+	0x8f,
+	0x02,
+	0x8e,
+	0x05,
+	0xe4,
+	0xff,
+	0xfe,
+	0xe5,
+	0x12,
+	0x24,
+	0x08,
+	0xf8,
+	0xee,
+	0x46,
+	0xf6,
+	0xef,
+	0x08,
+	0x46,
+	0xf6,
+	0xed,
+	0x08,
+	0x46,
+	0xf6,
+	0xea,
+	0x08,
+	0x46,
+	0xf6,
+	0xe5,
+	0x12,
+	0x24,
+	0x06,
+	0xf8,
+	0x74,
+	0x01,
+	0x26,
+	0xfe,
+	0xe4,
+	0x08,
+	0x36,
+	0xff,
+	0xa8,
+	0x12,
+	0x08,
+	0xee,
+	0x26,
+	0xfe,
+	0xef,
+	0x08,
+	0x36,
+	0xff,
+	0x08,
+	0x86,
+	0x05,
+	0x8e,
+	0x82,
+	0x8f,
+	0x83,
+	0x8d,
+	0xf0,
+	0x12,
+	0x21,
+	0x7d,
+	0xfe,
+	0x33,
+	0x95,
+	0xe0,
+	0x7f,
+	0x00,
+	0x7d,
+	0x00,
+	0x8d,
+	0x02,
+	0x8f,
+	0x05,
+	0x8e,
+	0x07,
+	0x7e,
+	0x00,
+	0xe5,
+	0x12,
+	0x24,
+	0x08,
+	0xf8,
+	0xee,
+	0x46,
+	0xf6,
+	0xef,
+	0x08,
+	0x46,
+	0xf6,
+	0xed,
+	0x08,
+	0x46,
+	0xf6,
+	0xea,
+	0x08,
+	0x46,
+	0xf6,
+	0xa8,
+	0x12,
+	0x08,
+	0xe5,
+	0x12,
+	0x24,
+	0x06,
+	0xf9,
+	0xe7,
+	0x26,
+	0xfd,
+	0x09,
+	0xe7,
+	0x08,
+	0x36,
+	0xfe,
+	0x08,
+	0x86,
+	0x07,
+	0x8d,
+	0x82,
+	0x8e,
+	0x83,
+	0x8f,
+	0xf0,
+	0x12,
+	0x21,
+	0x7d,
+	0xfd,
+	0x33,
+	0x95,
+	0xe0,
+	0xe4,
+	0xff,
+	0xfe,
+	0xfa,
+	0xe5,
+	0x12,
+	0x24,
+	0x08,
+	0xf8,
+	0xe6,
+	0x42,
+	0x05,
+	0x08,
+	0xe6,
+	0x42,
+	0x07,
+	0x08,
+	0xe6,
+	0x42,
+	0x06,
+	0x08,
+	0xe6,
+	0x42,
+	0x02,
+	0x90,
+	0x74,
+	0x00,
+	0xed,
+	0xf0,
+	0xa3,
+	0xef,
+	0xf0,
+	0xa3,
+	0xee,
+	0xf0,
+	0xa3,
+	0xea,
+	0xf0,
+	0xe5,
+	0x12,
+	0x24,
+	0x06,
+	0xf8,
+	0x74,
+	0x04,
+	0x26,
+	0xf6,
+	0xe4,
+	0x08,
+	0x36,
+	0xf6,
+	0xd0,
+	0x05,
+	0xd0,
+	0x02,
+	0x02,
+	0x1f,
+	0x47,
+	0xe5,
+	0x12,
+	0x24,
+	0x06,
+	0xf8,
+	0x86,
+	0x03,
+	0x08,
+	0x86,
+	0x04,
+	0x8b,
+	0x06,
+	0x8c,
+	0x07,
+	0x8e,
+	0x04,
+	0x8f,
+	0x05,
+	0xe5,
+	0x12,
+	0x24,
+	0x04,
+	0xf8,
+	0xc3,
+	0xec,
+	0x96,
+	0xed,
+	0x08,
+	0x96,
+	0x50,
+	0x22,
+	0xa8,
+	0x12,
+	0x08,
+	0xee,
+	0x26,
+	0xfb,
+	0xef,
+	0x08,
+	0x36,
+	0xfc,
+	0x08,
+	0x86,
+	0x05,
+	0x8b,
+	0x82,
+	0x8c,
+	0x83,
+	0x8d,
+	0xf0,
+	0x12,
+	0x21,
+	0x7d,
+	0xfb,
+	0x90,
+	0x74,
+	0x00,
+	0xf0,
+	0x0e,
+	0xbe,
+	0x00,
+	0xd0,
+	0x0f,
+	0x80,
+	0xcd,
+	0x85,
+	0x12,
+	0x81,
+	0xd0,
+	0x12,
+	0x22,
+	0xac,
+	0x82,
+	0xad,
+	0x83,
+	0xae,
+	0xf0,
+	0xff,
+	0x90,
+	0x7c,
+	0x00,
+	0xec,
+	0xf0,
+	0xa3,
+	0xed,
+	0xf0,
+	0xa3,
+	0xee,
+	0xf0,
+	0xa3,
+	0xef,
+	0xf0,
+	0x22,
+	0x20,
+	0xf7,
+	0x10,
+	0x30,
+	0xf6,
+	0x11,
+	0x88,
+	0x83,
+	0xa8,
+	0x82,
+	0x20,
+	0xf5,
+	0x07,
+	0xf6,
+	0xa8,
+	0x83,
+	0x75,
+	0x83,
+	0x00,
+	0x22,
+	0xf2,
+	0x80,
+	0xf7,
+	0xf0,
+	0x22,
+	0xaa,
+	0xf0,
+	0xfb,
+	0xe5,
+	0x82,
+	0x85,
+	0x13,
+	0xf0,
+	0xa4,
+	0xfc,
+	0xad,
+	0xf0,
+	0xe5,
+	0x83,
+	0x85,
+	0x13,
+	0xf0,
+	0xa4,
+	0x2d,
+	0xfd,
+	0xe4,
+	0x35,
+	0xf0,
+	0xfe,
+	0xe5,
+	0x82,
+	0x85,
+	0x14,
+	0xf0,
+	0xa4,
+	0x2d,
+	0xfd,
+	0xe5,
+	0xf0,
+	0x3e,
+	0xfe,
+	0xe4,
+	0x33,
+	0xff,
+	0xea,
+	0x85,
+	0x13,
+	0xf0,
+	0xa4,
+	0x2e,
+	0xfe,
+	0xe5,
+	0xf0,
+	0x3f,
+	0xff,
+	0xe5,
+	0x83,
+	0x85,
+	0x14,
+	0xf0,
+	0xa4,
+	0x2e,
+	0xfe,
+	0xe5,
+	0xf0,
+	0x3f,
+	0xff,
+	0xe5,
+	0x82,
+	0x85,
+	0x15,
+	0xf0,
+	0xa4,
+	0x2e,
+	0xfe,
+	0xe5,
+	0xf0,
+	0x3f,
+	0xff,
+	0xeb,
+	0x85,
+	0x13,
+	0xf0,
+	0xa4,
+	0x2f,
+	0xff,
+	0xea,
+	0x85,
+	0x14,
+	0xf0,
+	0xa4,
+	0x2f,
+	0xff,
+	0xe5,
+	0x83,
+	0x85,
+	0x15,
+	0xf0,
+	0xa4,
+	0x2f,
+	0xff,
+	0xe5,
+	0x82,
+	0x85,
+	0x16,
+	0xf0,
+	0xa4,
+	0x2f,
+	0x8e,
+	0xf0,
+	0x8d,
+	0x83,
+	0x8c,
+	0x82,
+	0x22,
+	0xaa,
+	0x82,
+	0xab,
+	0x83,
+	0x12,
+	0x21,
+	0x7d,
+	0x60,
+	0x03,
+	0xa3,
+	0x80,
+	0xf8,
+	0xc3,
+	0xe5,
+	0x82,
+	0x9a,
+	0xf5,
+	0x82,
+	0xe5,
+	0x83,
+	0x9b,
+	0xf5,
+	0x83,
+	0x22,
+	0x20,
+	0xf7,
+	0x14,
+	0x30,
+	0xf6,
+	0x14,
+	0x88,
+	0x83,
+	0xa8,
+	0x82,
+	0x20,
+	0xf5,
+	0x07,
+	0xe6,
+	0xa8,
+	0x83,
+	0x75,
+	0x83,
+	0x00,
+	0x22,
+	0xe2,
+	0x80,
+	0xf7,
+	0xe4,
+	0x93,
+	0x22,
+	0xe0,
+	0x22,
+	0x30,
+	0x31,
+	0x30,
+	0x00,
+	0x60,
+	0x09,
+	0x06,
+	0x0d,
+	0x65,
+	0x01,
+	0x48,
+	0x86,
+	0x01,
+	0x02,
+	0x04,
+	0x03,
+	0x20,
+	0x04,
+	0x00,
+	0x05,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xF6,
+	0x13,
+	0x92,
+	0xE4,
+	0x19,
+	0x2A,
+	0x9E,
+	0xA3,
+	0x2B,
+	0xC8,
+	0xE7,
+	0xB1,
+	0x34,
+	0x95,
+	0xC4,
+	0xC8,
+	0x97,
+	0xE0,
+	0x7B,
+	0xFA,
+	0xB4,
+	0x2C,
+	0x92,
+	0xAB,
+	0x50,
+	0xA1,
+	0x9E,
+	0x66,
+	0x06,
+	0x2B,
+	0x6F,
+	0x8B,
+	0x32,
+	0x59,
+	0x65,
+	0x7E,
+	0x6F,
+	0x2B,
+	0x5F,
+	0x26,
+	0x01,
+	0xA9,
+	0xA2,
+	0xC7,
+	0xF5,
+	0x57,
+	0x79,
+	0x4F,
+	0x84,
+	0xA8,
+	0x49,
+	0x42,
+	0x97,
+	0x19,
+	0xA2,
+	0x97,
+	0x38,
+	0x89,
+	0xF6,
+	0xCB,
+	0x47,
+	0x3D,
+	0xBA,
+	0x65,
+	0x18,
+	0x2D,
+	0x5E,
+	0x19,
+	0x4C,
+	0xD3,
+	0x5A,
+	0x64,
+	0xA7,
+	0xE1,
+	0x46,
+	0xEC,
+	0x07,
+	0x09,
+	0x7E,
+	0xDE,
+	0xE4,
+	0x77,
+	0xA3,
+	0xAF,
+	0x34,
+	0xC6,
+	0xC1,
+	0x74,
+	0xAB,
+	0xAE,
+	0x66,
+	0x09,
+	0x8A,
+	0xE3,
+	0xF2,
+	0x9D,
+	0xD2,
+	0xDA,
+	0xBC,
+	0xA8,
+	0x08,
+	0x35,
+	0xA9,
+	0x6A,
+	0xEB,
+	0xC3,
+	0x1D,
+	0x82,
+	0xD2,
+	0x11,
+	0xC1,
+	0xD6,
+	0xD8,
+	0xB1,
+	0x05,
+	0xBB,
+	0x7E,
+	0xC8,
+	0x27,
+	0x55,
+	0x3D,
+	0x94,
+	0xE0,
+	0xF6,
+	0xCE,
+	0x6A,
+	0x25,
+	0x8B
+};
+
+
+/* ///////////////////////////////////////////////////////////////////////// */
+unsigned char hdcp_prom[32768] = {
+	0x02,
+	0x80,
+	0x23,
+	0x02,
+	0xae,
+	0x62,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0x02,
+	0x99,
+	0x6e,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0x02,
+	0xae,
+	0xc8,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0x02,
+	0x99,
+	0xad,
+	0x12,
+	0xd8,
+	0x7c,
+	0x80,
+	0xfe,
+	0x75,
+	0x81,
+	0x20,
+	0x12,
+	0x99,
+	0x68,
+	0xe5,
+	0x82,
+	0x60,
+	0x03,
+	0x02,
+	0x80,
+	0x1e,
+	0x79,
+	0x00,
+	0xe9,
+	0x44,
+	0x00,
+	0x60,
+	0x1b,
+	0x7a,
+	0x00,
+	0x90,
+	0xf6,
+	0x7b,
+	0x78,
+	0x00,
+	0x75,
+	0xa0,
+	0x00,
+	0xe4,
+	0x93,
+	0xf2,
+	0xa3,
+	0x08,
+	0xb8,
+	0x00,
+	0x02,
+	0x05,
+	0xa0,
+	0xd9,
+	0xf4,
+	0xda,
+	0xf2,
+	0x75,
+	0xa0,
+	0xff,
+	0xe4,
+	0x78,
+	0xff,
+	0xf6,
+	0xd8,
+	0xfd,
+	0x78,
+	0x00,
+	0xe8,
+	0x44,
+	0x00,
+	0x60,
+	0x0a,
+	0x79,
+	0x00,
+	0x75,
+	0xa0,
+	0x00,
+	0xe4,
+	0xf3,
+	0x09,
+	0xd8,
+	0xfc,
+	0x78,
+	0x00,
+	0xe8,
+	0x44,
+	0x00,
+	0x60,
+	0x0c,
+	0x79,
+	0x00,
+	0x90,
+	0x00,
+	0x00,
+	0xe4,
+	0xf0,
+	0xa3,
+	0xd8,
+	0xfc,
+	0xd9,
+	0xfa,
+	0x02,
+	0x80,
+	0x1e,
+	0xac,
+	0x82,
+	0xad,
+	0x83,
+	0xae,
+	0xf0,
+	0xff,
+	0xec,
+	0x4d,
+	0x4e,
+	0x4f,
+	0x70,
+	0x1d,
+	0x90,
+	0x01,
+	0x70,
+	0xe4,
+	0xf0,
+	0xa3,
+	0xf0,
+	0xa3,
+	0xf0,
+	0xa3,
+	0x74,
+	0x40,
+	0xf0,
+	0x90,
+	0x01,
+	0x70,
+	0x74,
+	0x01,
+	0xf0,
+	0xa3,
+	0xe4,
+	0xf0,
+	0xa3,
+	0xf0,
+	0xa3,
+	0x74,
+	0x40,
+	0xf0,
+	0x22,
+	0x90,
+	0x01,
+	0x70,
+	0xe4,
+	0xf0,
+	0xa3,
+	0xf0,
+	0xa3,
+	0xf0,
+	0xa3,
+	0x74,
+	0x80,
+	0xf0,
+	0x90,
+	0x01,
+	0x70,
+	0x74,
+	0x01,
+	0xf0,
+	0xa3,
+	0xe4,
+	0xf0,
+	0xa3,
+	0xf0,
+	0xa3,
+	0x74,
+	0x80,
+	0xf0,
+	0x22,
+	0x90,
+	0x6c,
+	0x38,
+	0xe0,
+	0xfe,
+	0xa3,
+	0xe0,
+	0xff,
+	0x90,
+	0x6c,
+	0x40,
+	0xe0,
+	0xfc,
+	0xa3,
+	0xe0,
+	0xfd,
+	0xec,
+	0xc3,
+	0x9e,
+	0xfe,
+	0xed,
+	0x9f,
+	0xff,
+	0xe4,
+	0xfd,
+	0xef,
+	0xcd,
+	0xc4,
+	0x03,
+	0x54,
+	0xf8,
+	0xcd,
+	0xc4,
+	0x03,
+	0xcd,
+	0x6d,
+	0xcd,
+	0x54,
+	0xf8,
+	0xcd,
+	0x6d,
+	0xfc,
+	0xee,
+	0xc4,
+	0x03,
+	0x54,
+	0xf8,
+	0xff,
+	0xee,
+	0xc4,
+	0x03,
+	0x54,
+	0x07,
+	0x4d,
+	0xfd,
+	0x7e,
+	0x00,
+	0x90,
+	0x6c,
+	0x38,
+	0xe0,
+	0xfa,
+	0xa3,
+	0xe0,
+	0xfb,
+	0x8a,
+	0x00,
+	0x8b,
+	0x01,
+	0xe4,
+	0xfa,
+	0xfb,
+	0xee,
+	0x28,
+	0xfe,
+	0xef,
+	0x39,
+	0xff,
+	0xed,
+	0x3a,
+	0xfd,
+	0xec,
+	0x3b,
+	0xfc,
+	0x90,
+	0x6c,
+	0x3c,
+	0xe0,
+	0xf8,
+	0x79,
+	0x00,
+	0x88,
+	0x02,
+	0xe9,
+	0xca,
+	0x25,
+	0xe0,
+	0xca,
+	0x33,
+	0xca,
+	0x25,
+	0xe0,
+	0xca,
+	0x33,
+	0xfb,
+	0xe4,
+	0xf9,
+	0x2e,
+	0xfe,
+	0xe9,
+	0x3f,
+	0xff,
+	0xea,
+	0x3d,
+	0xfd,
+	0xeb,
+	0x3c,
+	0xfc,
+	0x90,
+	0x6c,
+	0x44,
+	0xe0,
+	0xf8,
+	0xe4,
+	0xe8,
+	0x28,
+	0xfb,
+	0xe4,
+	0xf8,
+	0xf9,
+	0xfa,
+	0xe8,
+	0x2e,
+	0xfe,
+	0xe9,
+	0x3f,
+	0xff,
+	0xea,
+	0x3d,
+	0xfd,
+	0xeb,
+	0x3c,
+	0xfc,
+	0x90,
+	0x40,
+	0x44,
+	0xee,
+	0xf0,
+	0xa3,
+	0xef,
+	0xf0,
+	0xa3,
+	0xed,
+	0xf0,
+	0xa3,
+	0xec,
+	0xf0,
+	0x90,
+	0x40,
+	0x00,
+	0xe0,
+	0x70,
+	0xfa,
+	0x22,
+	0x90,
+	0x6c,
+	0x38,
+	0xe0,
+	0xfe,
+	0xa3,
+	0xe0,
+	0xff,
+	0x90,
+	0x40,
+	0x04,
+	0xee,
+	0xf0,
+	0xa3,
+	0xef,
+	0xf0,
+	0x90,
+	0x6c,
+	0x3c,
+	0xe0,
+	0x90,
+	0x40,
+	0x06,
+	0xf0,
+	0x90,
+	0x6c,
+	0x40,
+	0xe0,
+	0xfe,
+	0xa3,
+	0xe0,
+	0xff,
+	0x90,
+	0x40,
+	0x08,
+	0xee,
+	0xf0,
+	0xa3,
+	0xef,
+	0xf0,
+	0x90,
+	0x6c,
+	0x44,
+	0xe0,
+	0x90,
+	0x40,
+	0x0a,
+	0xf0,
+	0x90,
+	0x6c,
+	0x48,
+	0xe0,
+	0xfe,
+	0xa3,
+	0xe0,
+	0xff,
+	0x90,
+	0x40,
+	0x0c,
+	0xee,
+	0xf0,
+	0xa3,
+	0xef,
+	0xf0,
+	0x90,
+	0x40,
+	0x41,
+	0xe4,
+	0xf0,
+	0x90,
+	0x40,
+	0x00,
+	0xe0,
+	0x70,
+	0xfa,
+	0x22,
+	0xac,
+	0x82,
+	0xad,
+	0x83,
+	0xae,
+	0xf0,
+	0xff,
+	0x90,
+	0x40,
+	0x10,
+	0xec,
+	0xf0,
+	0xa3,
+	0xed,
+	0xf0,
+	0xa3,
+	0xee,
+	0xf0,
+	0xa3,
+	0xef,
+	0xf0,
+	0x90,
+	0x6c,
+	0x38,
+	0xe0,
+	0xfe,
+	0xa3,
+	0xe0,
+	0xff,
+	0x90,
+	0x40,
+	0x04,
+	0xee,
+	0xf0,
+	0xa3,
+	0xef,
+	0xf0,
+	0x90,
+	0x6c,
+	0x3c,
+	0xe0,
+	0x90,
+	0x40,
+	0x06,
+	0xf0,
+	0x90,
+	0x6c,
+	0x40,
+	0xe0,
+	0xfe,
+	0xa3,
+	0xe0,
+	0xff,
+	0x90,
+	0x40,
+	0x08,
+	0xee,
+	0xf0,
+	0xa3,
+	0xef,
+	0xf0,
+	0x90,
+	0x6c,
+	0x44,
+	0xe0,
+	0x90,
+	0x40,
+	0x0a,
+	0xf0,
+	0x90,
+	0x6c,
+	0x48,
+	0xe0,
+	0xfe,
+	0xa3,
+	0xe0,
+	0xff,
+	0x90,
+	0x40,
+	0x0c,
+	0xee,
+	0xf0,
+	0xa3,
+	0xef,
+	0xf0,
+	0x90,
+	0x41,
+	0x41,
+	0xe4,
+	0xf0,
+	0x90,
+	0x40,
+	0x00,
+	0xe0,
+	0x70,
+	0xfa,
+	0x22,
+	0x90,
+	0x6c,
+	0x38,
+	0xe0,
+	0xfe,
+	0xa3,
+	0xe0,
+	0xff,
+	0x90,
+	0x6c,
+	0x40,
+	0xe0,
+	0xfc,
+	0xa3,
+	0xe0,
+	0xfd,
+	0xec,
+	0xc3,
+	0x9e,
+	0xfe,
+	0xed,
+	0x9f,
+	0xff,
+	0xe4,
+	0xfd,
+	0xef,
+	0xcd,
+	0xc4,
+	0x03,
+	0x54,
+	0xf8,
+	0xcd,
+	0xc4,
+	0x03,
+	0xcd,
+	0x6d,
+	0xcd,
+	0x54,
+	0xf8,
+	0xcd,
+	0x6d,
+	0xfc,
+	0xee,
+	0xc4,
+	0x03,
+	0x54,
+	0xf8,
+	0xff,
+	0xee,
+	0xc4,
+	0x03,
+	0x54,
+	0x07,
+	0x4d,
+	0xfd,
+	0x7e,
+	0x00,
+	0x90,
+	0x6c,
+	0x38,
+	0xe0,
+	0xfa,
+	0xa3,
+	0xe0,
+	0xfb,
+	0x8a,
+	0x00,
+	0x8b,
+	0x01,
+	0xe4,
+	0xfa,
+	0xfb,
+	0xee,
+	0x28,
+	0xfe,
+	0xef,
+	0x39,
+	0xff,
+	0xed,
+	0x3a,
+	0xfd,
+	0xec,
+	0x3b,
+	0xfc,
+	0x90,
+	0x6c,
+	0x3c,
+	0xe0,
+	0xf8,
+	0x79,
+	0x00,
+	0x88,
+	0x02,
+	0xe9,
+	0xca,
+	0x25,
+	0xe0,
+	0xca,
+	0x33,
+	0xca,
+	0x25,
+	0xe0,
+	0xca,
+	0x33,
+	0xfb,
+	0xe4,
+	0xf9,
+	0x2e,
+	0xfe,
+	0xe9,
+	0x3f,
+	0xff,
+	0xea,
+	0x3d,
+	0xfd,
+	0xeb,
+	0x3c,
+	0xfc,
+	0x90,
+	0x6c,
+	0x44,
+	0xe0,
+	0xf8,
+	0xe4,
+	0xe8,
+	0x28,
+	0xfb,
+	0xe4,
+	0xf8,
+	0xf9,
+	0xfa,
+	0xe8,
+	0x2e,
+	0xfe,
+	0xe9,
+	0x3f,
+	0xff,
+	0xea,
+	0x3d,
+	0xfd,
+	0xeb,
+	0x3c,
+	0xfc,
+	0x90,
+	0x40,
+	0x84,
+	0xee,
+	0xf0,
+	0xa3,
+	0xef,
+	0xf0,
+	0xa3,
+	0xed,
+	0xf0,
+	0xa3,
+	0xec,
+	0xf0,
+	0x90,
+	0x40,
+	0x00,
+	0xe0,
+	0x70,
+	0xfa,
+	0x22,
+	0x90,
+	0x6c,
+	0x38,
+	0xe0,
+	0xfe,
+	0xa3,
+	0xe0,
+	0xff,
+	0x90,
+	0x40,
+	0x04,
+	0xee,
+	0xf0,
+	0xa3,
+	0xef,
+	0xf0,
+	0x90,
+	0x6c,
+	0x3c,
+	0xe0,
+	0x90,
+	0x40,
+	0x06,
+	0xf0,
+	0x90,
+	0x6c,
+	0x40,
+	0xe0,
+	0xfe,
+	0xa3,
+	0xe0,
+	0xff,
+	0x90,
+	0x40,
+	0x08,
+	0xee,
+	0xf0,
+	0xa3,
+	0xef,
+	0xf0,
+	0x90,
+	0x6c,
+	0x44,
+	0xe0,
+	0x90,
+	0x40,
+	0x0a,
+	0xf0,
+	0x90,
+	0x6c,
+	0x48,
+	0xe0,
+	0xfe,
+	0xa3,
+	0xe0,
+	0xff,
+	0x90,
+	0x40,
+	0x0c,
+	0xee,
+	0xf0,
+	0xa3,
+	0xef,
+	0xf0,
+	0x90,
+	0x40,
+	0x81,
+	0xe4,
+	0xf0,
+	0x90,
+	0x40,
+	0x00,
+	0xe0,
+	0x70,
+	0xfa,
+	0x22,
+	0x90,
+	0x6c,
+	0x38,
+	0xe0,
+	0xfe,
+	0xa3,
+	0xe0,
+	0xff,
+	0x7d,
+	0x00,
+	0x7c,
+	0x00,
+	0x90,
+	0x6c,
+	0x38,
+	0xe0,
+	0xfa,
+	0xa3,
+	0xe0,
+	0xfb,
+	0x90,
+	0x6c,
+	0x40,
+	0xe0,
+	0xf8,
+	0xa3,
+	0xe0,
+	0xf9,
+	0xe8,
+	0xc3,
+	0x9a,
+	0xfa,
+	0xe9,
+	0x9b,
+	0xfb,
+	0x8a,
+	0x00,
+	0x8b,
+	0x01,
+	0xe4,
+	0xfa,
+	0xe9,
+	0xca,
+	0xc4,
+	0x03,
+	0x54,
+	0xf8,
+	0xca,
+	0xc4,
+	0x03,
+	0xca,
+	0x6a,
+	0xca,
+	0x54,
+	0xf8,
+	0xca,
+	0x6a,
+	0xfb,
+	0xe8,
+	0xc4,
+	0x03,
+	0x54,
+	0xf8,
+	0xf9,
+	0xe8,
+	0xc4,
+	0x03,
+	0x54,
+	0x07,
+	0x4a,
+	0xfa,
+	0xe4,
+	0x2e,
+	0xfe,
+	0xe9,
+	0x3f,
+	0xff,
+	0xea,
+	0x3d,
+	0xfd,
+	0xeb,
+	0x3c,
+	0xfc,
+	0x90,
+	0x6c,
+	0x3c,
+	0xe0,
+	0xf8,
+	0x79,
+	0x00,
+	0x88,
+	0x02,
+	0xe9,
+	0xca,
+	0x25,
+	0xe0,
+	0xca,
+	0x33,
+	0xca,
+	0x25,
+	0xe0,
+	0xca,
+	0x33,
+	0xfb,
+	0xe4,
+	0xf9,
+	0x2e,
+	0xfe,
+	0xe9,
+	0x3f,
+	0xff,
+	0xea,
+	0x3d,
+	0xfd,
+	0xeb,
+	0x3c,
+	0xfc,
+	0x90,
+	0x6c,
+	0x44,
+	0xe0,
+	0xf8,
+	0xe4,
+	0xe8,
+	0x28,
+	0xfb,
+	0xe4,
+	0xf8,
+	0xf9,
+	0xfa,
+	0xe8,
+	0x2e,
+	0xfe,
+	0xe9,
+	0x3f,
+	0xff,
+	0xea,
+	0x3d,
+	0xfd,
+	0xeb,
+	0x3c,
+	0xfc,
+	0x90,
+	0x40,
+	0xc4,
+	0xee,
+	0xf0,
+	0xa3,
+	0xef,
+	0xf0,
+	0xa3,
+	0xed,
+	0xf0,
+	0xa3,
+	0xec,
+	0xf0,
+	0x90,
+	0x40,
+	0x00,
+	0xe0,
+	0x70,
+	0xfa,
+	0x22,
+	0x90,
+	0x6c,
+	0x38,
+	0xe0,
+	0xfe,
+	0xa3,
+	0xe0,
+	0xff,
+	0x90,
+	0x40,
+	0x04,
+	0xee,
+	0xf0,
+	0xa3,
+	0xef,
+	0xf0,
+	0x90,
+	0x6c,
+	0x3c,
+	0xe0,
+	0x90,
+	0x40,
+	0x06,
+	0xf0,
+	0x90,
+	0x6c,
+	0x40,
+	0xe0,
+	0xfe,
+	0xa3,
+	0xe0,
+	0xff,
+	0x90,
+	0x40,
+	0x08,
+	0xee,
+	0xf0,
+	0xa3,
+	0xef,
+	0xf0,
+	0x90,
+	0x6c,
+	0x44,
+	0xe0,
+	0x90,
+	0x40,
+	0x0a,
+	0xf0,
+	0x90,
+	0x6c,
+	0x48,
+	0xe0,
+	0xfe,
+	0xa3,
+	0xe0,
+	0xff,
+	0x90,
+	0x40,
+	0x0c,
+	0xee,
+	0xf0,
+	0xa3,
+	0xef,
+	0xf0,
+	0x90,
+	0x40,
+	0xc1,
+	0xe4,
+	0xf0,
+	0x90,
+	0x40,
+	0x00,
+	0xe0,
+	0x70,
+	0xfa,
+	0x22,
+	0x90,
+	0x6c,
+	0x38,
+	0xe0,
+	0xfe,
+	0xa3,
+	0xe0,
+	0xff,
+	0x7d,
+	0x00,
+	0x7c,
+	0x00,
+	0x90,
+	0x6c,
+	0x38,
+	0xe0,
+	0xfa,
+	0xa3,
+	0xe0,
+	0xfb,
+	0x90,
+	0x6c,
+	0x40,
+	0xe0,
+	0xf8,
+	0xa3,
+	0xe0,
+	0xf9,
+	0xe8,
+	0xc3,
+	0x9a,
+	0xfa,
+	0xe9,
+	0x9b,
+	0xfb,
+	0x8a,
+	0x00,
+	0x8b,
+	0x01,
+	0xe4,
+	0xfa,
+	0xe9,
+	0xca,
+	0xc4,
+	0x03,
+	0x54,
+	0xf8,
+	0xca,
+	0xc4,
+	0x03,
+	0xca,
+	0x6a,
+	0xca,
+	0x54,
+	0xf8,
+	0xca,
+	0x6a,
+	0xfb,
+	0xe8,
+	0xc4,
+	0x03,
+	0x54,
+	0xf8,
+	0xf9,
+	0xe8,
+	0xc4,
+	0x03,
+	0x54,
+	0x07,
+	0x4a,
+	0xfa,
+	0xe4,
+	0x2e,
+	0xfe,
+	0xe9,
+	0x3f,
+	0xff,
+	0xea,
+	0x3d,
+	0xfd,
+	0xeb,
+	0x3c,
+	0xfc,
+	0x90,
+	0x6c,
+	0x3c,
+	0xe0,
+	0xf8,
+	0x79,
+	0x00,
+	0x88,
+	0x02,
+	0xe9,
+	0xca,
+	0x25,
+	0xe0,
+	0xca,
+	0x33,
+	0xca,
+	0x25,
+	0xe0,
+	0xca,
+	0x33,
+	0xfb,
+	0xe4,
+	0xf9,
+	0x2e,
+	0xfe,
+	0xe9,
+	0x3f,
+	0xff,
+	0xea,
+	0x3d,
+	0xfd,
+	0xeb,
+	0x3c,
+	0xfc,
+	0x90,
+	0x6c,
+	0x44,
+	0xe0,
+	0xf8,
+	0xe4,
+	0xe8,
+	0x28,
+	0xfb,
+	0xe4,
+	0xf8,
+	0xf9,
+	0xfa,
+	0xe8,
+	0x2e,
+	0xfe,
+	0xe9,
+	0x3f,
+	0xff,
+	0xea,
+	0x3d,
+	0xfd,
+	0xeb,
+	0x3c,
+	0xfc,
+	0x90,
+	0x41,
+	0x04,
+	0xee,
+	0xf0,
+	0xa3,
+	0xef,
+	0xf0,
+	0xa3,
+	0xed,
+	0xf0,
+	0xa3,
+	0xec,
+	0xf0,
+	0x90,
+	0x40,
+	0x00,
+	0xe0,
+	0x70,
+	0xfa,
+	0x22,
+	0x90,
+	0x6c,
+	0x38,
+	0xe0,
+	0xfe,
+	0xa3,
+	0xe0,
+	0xff,
+	0x90,
+	0x40,
+	0x04,
+	0xee,
+	0xf0,
+	0xa3,
+	0xef,
+	0xf0,
+	0x90,
+	0x6c,
+	0x3c,
+	0xe0,
+	0x90,
+	0x40,
+	0x06,
+	0xf0,
+	0x90,
+	0x6c,
+	0x40,
+	0xe0,
+	0xfe,
+	0xa3,
+	0xe0,
+	0xff,
+	0x90,
+	0x40,
+	0x08,
+	0xee,
+	0xf0,
+	0xa3,
+	0xef,
+	0xf0,
+	0x90,
+	0x6c,
+	0x44,
+	0xe0,
+	0x90,
+	0x40,
+	0x0a,
+	0xf0,
+	0x90,
+	0x6c,
+	0x38,
+	0xe0,
+	0xfe,
+	0xa3,
+	0xe0,
+	0xff,
+	0x90,
+	0x40,
+	0x0c,
+	0xee,
+	0xf0,
+	0xa3,
+	0xef,
+	0xf0,
+	0x90,
+	0x41,
+	0x01,
+	0xe4,
+	0xf0,
+	0x90,
+	0x40,
+	0x00,
+	0xe0,
+	0x70,
+	0xfa,
+	0x22,
+	0x90,
+	0x6c,
+	0x3c,
+	0xe0,
+	0xff,
+	0xe4,
+	0xfd,
+	0xcd,
+	0xc4,
+	0x54,
+	0xf0,
+	0xcd,
+	0xc4,
+	0xcd,
+	0x6d,
+	0xcd,
+	0x54,
+	0xf0,
+	0xcd,
+	0x6d,
+	0xfc,
+	0xef,
+	0xc4,
+	0x54,
+	0xf0,
+	0xfe,
+	0xef,
+	0xc4,
+	0x54,
+	0x0f,
+	0x4d,
+	0xfd,
+	0x7f,
+	0x00,
+	0x90,
+	0x6c,
+	0x38,
+	0xe0,
+	0xfa,
+	0xa3,
+	0xe0,
+	0xfb,
+	0x8a,
+	0x00,
+	0x8b,
+	0x01,
+	0xe4,
+	0xfa,
+	0xfb,
+	0xe8,
+	0x42,
+	0x07,
+	0xe9,
+	0x42,
+	0x06,
+	0xea,
+	0x42,
+	0x05,
+	0xeb,
+	0x42,
+	0x04,
+	0x90,
+	0x41,
+	0xc0,
+	0xef,
+	0xf0,
+	0xa3,
+	0xee,
+	0xf0,
+	0xa3,
+	0xed,
+	0xf0,
+	0xa3,
+	0xec,
+	0xf0,
+	0x90,
+	0x40,
+	0x00,
+	0xe0,
+	0x70,
+	0xfa,
+	0x22,
+	0x90,
+	0x6c,
+	0x40,
+	0xe0,
+	0xfe,
+	0xa3,
+	0xe0,
+	0x8e,
+	0x05,
+	0xc4,
+	0x54,
+	0xf0,
+	0xcd,
+	0xc4,
+	0xcd,
+	0x6d,
+	0xcd,
+	0x54,
+	0xf0,
+	0xcd,
+	0x6d,
+	0xfc,
+	0x7f,
+	0x00,
+	0x7e,
+	0x00,
+	0x90,
+	0x6c,
+	0x3c,
+	0xe0,
+	0xf8,
+	0xe4,
+	0xfa,
+	0xca,
+	0xc4,
+	0x54,
+	0xf0,
+	0xca,
+	0xc4,
+	0xca,
+	0x6a,
+	0xca,
+	0x54,
+	0xf0,
+	0xca,
+	0x6a,
+	0xfb,
+	0xe8,
+	0xc4,
+	0x54,
+	0xf0,
+	0xf9,
+	0xe8,
+	0xc4,
+	0x54,
+	0x0f,
+	0x4a,
+	0xfa,
+	0xe4,
+	0x42,
+	0x06,
+	0xe9,
+	0x42,
+	0x07,
+	0xea,
+	0x42,
+	0x05,
+	0xeb,
+	0x42,
+	0x04,
+	0x90,
+	0x6c,
+	0x38,
+	0xe0,
+	0xfa,
+	0xa3,
+	0xe0,
+	0xfb,
+	0x8a,
+	0x00,
+	0x8b,
+	0x01,
+	0xe4,
+	0xfa,
+	0xfb,
+	0xe8,
+	0x42,
+	0x06,
+	0xe9,
+	0x42,
+	0x07,
+	0xea,
+	0x42,
+	0x05,
+	0xeb,
+	0x42,
+	0x04,
+	0x90,
+	0x41,
+	0x80,
+	0xee,
+	0xf0,
+	0xa3,
+	0xef,
+	0xf0,
+	0xa3,
+	0xed,
+	0xf0,
+	0xa3,
+	0xec,
+	0xf0,
+	0x90,
+	0x40,
+	0x00,
+	0xe0,
+	0x70,
+	0xfa,
+	0x22,
+	0xc0,
+	0x12,
+	0xe5,
+	0x81,
+	0xf5,
+	0x12,
+	0x24,
+	0x04,
+	0xf5,
+	0x81,
+	0x90,
+	0x6c,
+	0x40,
+	0xe0,
+	0xfe,
+	0xa3,
+	0xe0,
+	0xff,
+	0xa8,
+	0x12,
+	0x08,
+	0x08,
+	0x08,
+	0xa6,
+	0x06,
+	0xef,
+	0xc4,
+	0x54,
+	0xf0,
+	0xc6,
+	0xc4,
+	0xc6,
+	0x66,
+	0xc6,
+	0x54,
+	0xf0,
+	0xc6,
+	0x66,
+	0x08,
+	0xf6,
+	0x18,
+	0x18,
+	0x76,
+	0x00,
+	0x18,
+	0x76,
+	0x00,
+	0x90,
+	0x6c,
+	0x3c,
+	0xe0,
+	0xfa,
+	0xe4,
+	0xfe,
+	0xce,
+	0xc4,
+	0x54,
+	0xf0,
+	0xce,
+	0xc4,
+	0xce,
+	0x6e,
+	0xce,
+	0x54,
+	0xf0,
+	0xce,
+	0x6e,
+	0xff,
+	0xea,
+	0xc4,
+	0x54,
+	0xf0,
+	0xfb,
+	0xea,
+	0xc4,
+	0x54,
+	0x0f,
+	0x4e,
+	0xfe,
+	0x7a,
+	0x00,
+	0xa8,
+	0x12,
+	0x08,
+	0xea,
+	0x46,
+	0xf6,
+	0xeb,
+	0x08,
+	0x46,
+	0xf6,
+	0xee,
+	0x08,
+	0x46,
+	0xf6,
+	0xef,
+	0x08,
+	0x46,
+	0xf6,
+	0x90,
+	0x6c,
+	0x38,
+	0xe0,
+	0xfc,
+	0xa3,
+	0xe0,
+	0xfd,
+	0x7e,
+	0x00,
+	0x7f,
+	0x00,
+	0xa8,
+	0x12,
+	0x08,
+	0xe6,
+	0x42,
+	0x04,
+	0x08,
+	0xe6,
+	0x42,
+	0x05,
+	0x08,
+	0xe6,
+	0x42,
+	0x06,
+	0x08,
+	0xe6,
+	0x42,
+	0x07,
+	0x90,
+	0x42,
+	0x00,
+	0xec,
+	0xf0,
+	0xa3,
+	0xed,
+	0xf0,
+	0xa3,
+	0xee,
+	0xf0,
+	0xa3,
+	0xef,
+	0xf0,
+	0x90,
+	0x40,
+	0x00,
+	0xe0,
+	0x70,
+	0xfa,
+	0x90,
+	0x40,
+	0x02,
+	0xe0,
+	0xff,
+	0x74,
+	0x01,
+	0x5f,
+	0xf5,
+	0x82,
+	0x85,
+	0x12,
+	0x81,
+	0xd0,
+	0x12,
+	0x22,
+	0xc0,
+	0x12,
+	0x85,
+	0x81,
+	0x12,
+	0xc0,
+	0x82,
+	0xc0,
+	0x83,
+	0xc0,
+	0xf0,
+	0xc0,
+	0xe0,
+	0xa8,
+	0x12,
+	0x08,
+	0xe6,
+	0xf4,
+	0xfa,
+	0x08,
+	0xe6,
+	0xf4,
+	0xfb,
+	0x08,
+	0xe6,
+	0xf4,
+	0xfe,
+	0x08,
+	0xe6,
+	0xf4,
+	0xff,
+	0x74,
+	0x01,
+	0x2a,
+	0xfc,
+	0xe4,
+	0x3b,
+	0xfd,
+	0xe4,
+	0x3e,
+	0xfe,
+	0xe4,
+	0x3f,
+	0xff,
+	0xa8,
+	0x12,
+	0x08,
+	0xe6,
+	0x08,
+	0x46,
+	0x08,
+	0x46,
+	0x08,
+	0x46,
+	0x70,
+	0x08,
+	0x90,
+	0x00,
+	0x00,
+	0xe4,
+	0xf5,
+	0xf0,
+	0x80,
+	0x07,
+	0x8c,
+	0x82,
+	0x8d,
+	0x83,
+	0x8e,
+	0xf0,
+	0xef,
+	0x85,
+	0x12,
+	0x81,
+	0xd0,
+	0x12,
+	0x22,
+	0xc0,
+	0x12,
+	0x85,
+	0x81,
+	0x12,
+	0xc0,
+	0x82,
+	0xc0,
+	0x83,
+	0xc0,
+	0xf0,
+	0xc0,
+	0xe0,
+	0xe5,
+	0x81,
+	0x24,
+	0x0e,
+	0xf5,
+	0x81,
+	0xe5,
+	0x12,
+	0x24,
+	0x07,
+	0xf8,
+	0x76,
+	0x01,
+	0xe4,
+	0x08,
+	0xf6,
+	0x08,
+	0xf6,
+	0x08,
+	0xf6,
+	0xe5,
+	0x12,
+	0x24,
+	0x05,
+	0xf8,
+	0x76,
+	0x02,
+	0x08,
+	0x76,
+	0x00,
+	0xe5,
+	0x12,
+	0x24,
+	0x05,
+	0xf8,
+	0xc3,
+	0x74,
+	0x20,
+	0x96,
+	0xe4,
+	0x64,
+	0x80,
+	0x08,
+	0x86,
+	0xf0,
+	0x63,
+	0xf0,
+	0x80,
+	0x95,
+	0xf0,
+	0x50,
+	0x03,
+	0x02,
+	0x88,
+	0x0d,
+	0xe5,
+	0x12,
+	0x24,
+	0x05,
+	0xf8,
+	0xb6,
+	0x20,
+	0x14,
+	0x08,
+	0xb6,
+	0x00,
+	0x10,
+	0xe5,
+	0x12,
+	0x24,
+	0x0f,
+	0xf8,
+	0x74,
+	0xff,
+	0xf6,
+	0x08,
+	0xf6,
+	0x08,
+	0xf6,
+	0x08,
+	0xf6,
+	0x80,
+	0x3a,
+	0xe5,
+	0x12,
+	0x24,
+	0x05,
+	0xf8,
+	0x86,
+	0xf0,
+	0x05,
+	0xf0,
+	0x7f,
+	0x01,
+	0x7e,
+	0x00,
+	0x7d,
+	0x00,
+	0x7c,
+	0x00,
+	0x80,
+	0x0c,
+	0xef,
+	0x2f,
+	0xff,
+	0xee,
+	0x33,
+	0xfe,
+	0xed,
+	0x33,
+	0xfd,
+	0xec,
+	0x33,
+	0xfc,
+	0xd5,
+	0xf0,
+	0xf1,
+	0xe5,
+	0x12,
+	0x24,
+	0x0f,
+	0xf8,
+	0xef,
+	0x24,
+	0xff,
+	0xf6,
+	0xee,
+	0x34,
+	0xff,
+	0x08,
+	0xf6,
+	0xed,
+	0x34,
+	0xff,
+	0x08,
+	0xf6,
+	0xec,
+	0x34,
+	0xff,
+	0x08,
+	0xf6,
+	0xe5,
+	0x12,
+	0x24,
+	0x07,
+	0xf8,
+	0x86,
+	0x13,
+	0x08,
+	0x86,
+	0x14,
+	0x08,
+	0x86,
+	0x15,
+	0x08,
+	0x86,
+	0x16,
+	0xa8,
+	0x12,
+	0x08,
+	0x86,
+	0x82,
+	0x08,
+	0x86,
+	0x83,
+	0x08,
+	0x86,
+	0xf0,
+	0x08,
+	0xe6,
+	0x12,
+	0xf3,
+	0x8f,
+	0xac,
+	0x82,
+	0xad,
+	0x83,
+	0xae,
+	0xf0,
+	0xff,
+	0xe5,
+	0x12,
+	0x24,
+	0x0f,
+	0xf8,
+	0xe6,
+	0x52,
+	0x04,
+	0x08,
+	0xe6,
+	0x52,
+	0x05,
+	0x08,
+	0xe6,
+	0x52,
+	0x06,
+	0x08,
+	0xe6,
+	0x52,
+	0x07,
+	0xe5,
+	0x12,
+	0x24,
+	0x0b,
+	0xf8,
+	0xa6,
+	0x04,
+	0x08,
+	0xa6,
+	0x05,
+	0x08,
+	0xa6,
+	0x06,
+	0x08,
+	0xa6,
+	0x07,
+	0xe5,
+	0x12,
+	0x24,
+	0x05,
+	0xf8,
+	0xe6,
+	0x24,
+	0xff,
+	0xfa,
+	0x08,
+	0xe6,
+	0x34,
+	0xff,
+	0x8a,
+	0xf0,
+	0x05,
+	0xf0,
+	0x7a,
+	0x01,
+	0x7b,
+	0x00,
+	0x7e,
+	0x00,
+	0x7f,
+	0x00,
+	0x80,
+	0x0c,
+	0xea,
+	0x2a,
+	0xfa,
+	0xeb,
+	0x33,
+	0xfb,
+	0xee,
+	0x33,
+	0xfe,
+	0xef,
+	0x33,
+	0xff,
+	0xd5,
+	0xf0,
+	0xf1,
+	0xe5,
+	0x12,
+	0x24,
+	0x0b,
+	0xf8,
+	0xc3,
+	0xea,
+	0x96,
+	0xeb,
+	0x08,
+	0x96,
+	0xee,
+	0x08,
+	0x96,
+	0xef,
+	0x08,
+	0x96,
+	0x50,
+	0x3e,
+	0xe5,
+	0x12,
+	0x24,
+	0x05,
+	0xf8,
+	0xe6,
+	0x24,
+	0xff,
+	0xfe,
+	0x08,
+	0xe6,
+	0x34,
+	0xff,
+	0x8e,
+	0xf0,
+	0x05,
+	0xf0,
+	0x7e,
+	0x01,
+	0x7f,
+	0x00,
+	0x7d,
+	0x00,
+	0x7c,
+	0x00,
+	0x80,
+	0x0c,
+	0xee,
+	0x2e,
+	0xfe,
+	0xef,
+	0x33,
+	0xff,
+	0xed,
+	0x33,
+	0xfd,
+	0xec,
+	0x33,
+	0xfc,
+	0xd5,
+	0xf0,
+	0xf1,
+	0xe5,
+	0x12,
+	0x24,
+	0x07,
+	0xf8,
+	0xee,
+	0x26,
+	0xf6,
+	0xef,
+	0x08,
+	0x36,
+	0xf6,
+	0xed,
+	0x08,
+	0x36,
+	0xf6,
+	0xec,
+	0x08,
+	0x36,
+	0xf6,
+	0xe5,
+	0x12,
+	0x24,
+	0x05,
+	0xf8,
+	0x06,
+	0xb6,
+	0x00,
+	0x02,
+	0x08,
+	0x06,
+	0x02,
+	0x86,
+	0xca,
+	0xe5,
+	0x12,
+	0x24,
+	0x07,
+	0xf8,
+	0x86,
+	0x82,
+	0x08,
+	0x86,
+	0x83,
+	0x08,
+	0x86,
+	0xf0,
+	0x08,
+	0xe6,
+	0x85,
+	0x12,
+	0x81,
+	0xd0,
+	0x12,
+	0x22,
+	0x12,
+	0xf4,
+	0x15,
+	0xfd,
+	0xa3,
+	0x12,
+	0xf4,
+	0x15,
+	0xfe,
+	0xa3,
+	0x12,
+	0xf4,
+	0x15,
+	0xff,
+	0xa3,
+	0x12,
+	0xf4,
+	0x15,
+	0x8d,
+	0x82,
+	0x8e,
+	0x83,
+	0x8f,
+	0xf0,
+	0x12,
+	0x86,
+	0x9f,
+	0x02,
+	0x86,
+	0x52,
+	0xc0,
+	0x12,
+	0x85,
+	0x81,
+	0x12,
+	0x12,
+	0xf1,
+	0x31,
+	0x90,
+	0x70,
+	0x00,
+	0xe5,
+	0x12,
+	0x24,
+	0xfa,
+	0xf8,
+	0xe6,
+	0xf0,
+	0xa3,
+	0x08,
+	0xe6,
+	0xf0,
+	0xa3,
+	0x08,
+	0xe6,
+	0xf0,
+	0xa3,
+	0x08,
+	0xe6,
+	0xf0,
+	0x7e,
+	0x00,
+	0x7f,
+	0x00,
+	0x8e,
+	0x02,
+	0xef,
+	0xfb,
+	0x33,
+	0x95,
+	0xe0,
+	0xfc,
+	0xfd,
+	0xe5,
+	0x12,
+	0x24,
+	0xf6,
+	0xf8,
+	0xc3,
+	0xea,
+	0x96,
+	0xeb,
+	0x08,
+	0x96,
+	0xec,
+	0x08,
+	0x96,
+	0xed,
+	0x08,
+	0x96,
+	0x50,
+	0x58,
+	0xe5,
+	0x12,
+	0x24,
+	0xfa,
+	0xf8,
+	0xea,
+	0x26,
+	0xfa,
+	0xeb,
+	0x08,
+	0x36,
+	0xfb,
+	0xec,
+	0x08,
+	0x36,
+	0xfc,
+	0xed,
+	0x08,
+	0x36,
+	0xfd,
+	0xea,
+	0x2a,
+	0xfa,
+	0xeb,
+	0x33,
+	0xfb,
+	0xec,
+	0x33,
+	0xfc,
+	0xed,
+	0x33,
+	0xfd,
+	0xea,
+	0x2a,
+	0xfa,
+	0xeb,
+	0x33,
+	0xfb,
+	0xec,
+	0x33,
+	0xfc,
+	0xed,
+	0x33,
+	0xfd,
+	0x74,
+	0x60,
+	0x2b,
+	0xfb,
+	0xe4,
+	0x3c,
+	0xe4,
+	0x3d,
+	0x8a,
+	0x82,
+	0x8b,
+	0x83,
+	0xe0,
+	0xfa,
+	0xa3,
+	0xe0,
+	0xfb,
+	0xa3,
+	0xe0,
+	0xfc,
+	0xa3,
+	0xe0,
+	0xfd,
+	0x90,
+	0x70,
+	0x00,
+	0xea,
+	0xf0,
+	0xa3,
+	0xeb,
+	0xf0,
+	0xa3,
+	0xec,
+	0xf0,
+	0xa3,
+	0xed,
+	0xf0,
+	0x0e,
+	0xbe,
+	0x00,
+	0x8f,
+	0x0f,
+	0x80,
+	0x8c,
+	0xd0,
+	0x12,
+	0x22,
+	0xc0,
+	0x12,
+	0x85,
+	0x81,
+	0x12,
+	0xaf,
+	0x82,
+	0xe5,
+	0x12,
+	0x24,
+	0xfd,
+	0xf8,
+	0x86,
+	0x05,
+	0x7e,
+	0x00,
+	0xe5,
+	0x12,
+	0x24,
+	0xf1,
+	0xf8,
+	0xed,
+	0x26,
+	0xfd,
+	0xee,
+	0x08,
+	0x36,
+	0xfe,
+	0xe5,
+	0x12,
+	0x24,
+	0xf5,
+	0xf8,
+	0x90,
+	0x6c,
+	0x38,
+	0xe6,
+	0xf0,
+	0x08,
+	0xa3,
+	0xe6,
+	0xf0,
+	0xe5,
+	0x12,
+	0x24,
+	0xfd,
+	0xf8,
+	0x90,
+	0x6c,
+	0x3c,
+	0xe6,
+	0xf0,
+	0xe5,
+	0x12,
+	0x24,
+	0xfd,
+	0xf8,
+	0x90,
+	0x6c,
+	0x44,
+	0xe6,
+	0xf0,
+	0xef,
+	0x70,
+	0x29,
+	0xe5,
+	0x12,
+	0x24,
+	0xf3,
+	0xf8,
+	0x90,
+	0x6c,
+	0x40,
+	0xe6,
+	0xf0,
+	0x08,
+	0xa3,
+	0xe6,
+	0xf0,
+	0xe5,
+	0x12,
+	0x24,
+	0xf1,
+	0xf8,
+	0x90,
+	0x6c,
+	0x48,
+	0xe6,
+	0xf0,
+	0x08,
+	0xa3,
+	0xe6,
+	0xf0,
+	0xc0,
+	0x06,
+	0xc0,
+	0x05,
+	0x12,
+	0x81,
+	0x6a,
+	0xd0,
+	0x05,
+	0xd0,
+	0x06,
+	0x80,
+	0x2c,
+	0xe5,
+	0x12,
+	0x24,
+	0xf1,
+	0xf8,
+	0x90,
+	0x6c,
+	0x40,
+	0xe6,
+	0xf0,
+	0x08,
+	0xa3,
+	0xe6,
+	0xf0,
+	0xc0,
+	0x06,
+	0xc0,
+	0x05,
+	0x12,
+	0x85,
+	0x37,
+	0xd0,
+	0x05,
+	0xd0,
+	0x06,
+	0x90,
+	0x6c,
+	0x38,
+	0xed,
+	0xf0,
+	0xa3,
+	0xee,
+	0xf0,
+	0xc0,
+	0x06,
+	0xc0,
+	0x05,
+	0x12,
+	0x84,
+	0xe5,
+	0xd0,
+	0x05,
+	0xd0,
+	0x06,
+	0xe5,
+	0x12,
+	0x24,
+	0xf7,
+	0xf8,
+	0x90,
+	0x6c,
+	0x38,
+	0xe6,
+	0xf0,
+	0x08,
+	0xa3,
+	0xe6,
+	0xf0,
+	0xe5,
+	0x12,
+	0x24,
+	0xf1,
+	0xf8,
+	0x90,
+	0x6c,
+	0x40,
+	0xe6,
+	0xf0,
+	0x08,
+	0xa3,
+	0xe6,
+	0xf0,
+	0xe5,
+	0x12,
+	0x24,
+	0xf1,
+	0xf8,
+	0x90,
+	0x6c,
+	0x48,
+	0xe6,
+	0xf0,
+	0x08,
+	0xa3,
+	0xe6,
+	0xf0,
+	0xe5,
+	0x12,
+	0x24,
+	0xf9,
+	0xf8,
+	0x86,
+	0x82,
+	0x08,
+	0x86,
+	0x83,
+	0x08,
+	0x86,
+	0xf0,
+	0x08,
+	0xe6,
+	0xc0,
+	0x06,
+	0xc0,
+	0x05,
+	0x12,
+	0x81,
+	0xb6,
+	0xd0,
+	0x05,
+	0xd0,
+	0x06,
+	0x90,
+	0x6c,
+	0x38,
+	0xed,
+	0xf0,
+	0xa3,
+	0xee,
+	0xf0,
+	0xe5,
+	0x12,
+	0x24,
+	0xfd,
+	0xf8,
+	0x90,
+	0x6c,
+	0x3c,
+	0xe6,
+	0x04,
+	0xf0,
+	0xe5,
+	0x12,
+	0x24,
+	0xf7,
+	0xf8,
+	0x90,
+	0x6c,
+	0x40,
+	0xe6,
+	0xf0,
+	0x08,
+	0xa3,
+	0xe6,
+	0xf0,
+	0x12,
+	0x84,
+	0x99,
+	0xe5,
+	0x12,
+	0x24,
+	0xfd,
+	0xf8,
+	0x90,
+	0x6c,
+	0x3c,
+	0xe6,
+	0xf0,
+	0xe5,
+	0x12,
+	0x24,
+	0xef,
+	0xf8,
+	0x90,
+	0x6c,
+	0x40,
+	0xe6,
+	0xf0,
+	0x08,
+	0xa3,
+	0xe6,
+	0xf0,
+	0x12,
+	0x85,
+	0x37,
+	0xd0,
+	0x12,
+	0x22,
+	0xc0,
+	0x12,
+	0x85,
+	0x81,
+	0x12,
+	0x05,
+	0x81,
+	0x05,
+	0x81,
+	0xaf,
+	0x82,
+	0x8f,
+	0x05,
+	0x7e,
+	0x00,
+	0xe5,
+	0x12,
+	0x24,
+	0xf2,
+	0xf8,
+	0xed,
+	0x26,
+	0xfb,
+	0xee,
+	0x08,
+	0x36,
+	0xfc,
+	0xa8,
+	0x12,
+	0x08,
+	0xa6,
+	0x03,
+	0x08,
+	0xa6,
+	0x04,
+	0xa8,
+	0x12,
+	0x08,
+	0xed,
+	0x26,
+	0xfb,
+	0xee,
+	0x08,
+	0x36,
+	0xfc,
+	0x8b,
+	0x02,
+	0xed,
+	0x2a,
+	0xfd,
+	0xee,
+	0x3c,
+	0xfe,
+	0x90,
+	0x6c,
+	0x38,
+	0xea,
+	0xf0,
+	0xa3,
+	0xec,
+	0xf0,
+	0x90,
+	0x6c,
+	0x3c,
+	0xef,
+	0xf0,
+	0xc0,
+	0x07,
+	0xc0,
+	0x06,
+	0xc0,
+	0x05,
+	0xc0,
+	0x04,
+	0xc0,
+	0x02,
+	0x12,
+	0x84,
+	0xe5,
+	0xd0,
+	0x02,
+	0xd0,
+	0x04,
+	0xd0,
+	0x05,
+	0xd0,
+	0x06,
+	0xe5,
+	0x12,
+	0x24,
+	0xf6,
+	0xf8,
+	0x90,
+	0x6c,
+	0x38,
+	0xe6,
+	0xf0,
+	0x08,
+	0xa3,
+	0xe6,
+	0xf0,
+	0x90,
+	0x6c,
+	0x40,
+	0xed,
+	0xf0,
+	0xa3,
+	0xee,
+	0xf0,
+	0xc0,
+	0x06,
+	0xc0,
+	0x05,
+	0xc0,
+	0x04,
+	0xc0,
+	0x02,
+	0x12,
+	0x85,
+	0x37,
+	0xd0,
+	0x02,
+	0xd0,
+	0x04,
+	0xd0,
+	0x05,
+	0xd0,
+	0x06,
+	0xd0,
+	0x07,
+	0x90,
+	0x6c,
+	0x38,
+	0xea,
+	0xf0,
+	0xa3,
+	0xec,
+	0xf0,
+	0xef,
+	0x2f,
+	0xfb,
+	0x90,
+	0x6c,
+	0x3c,
+	0xf0,
+	0xe5,
+	0x12,
+	0x24,
+	0xf8,
+	0xf8,
+	0x90,
+	0x6c,
+	0x40,
+	0xe6,
+	0xf0,
+	0x08,
+	0xa3,
+	0xe6,
+	0xf0,
+	0x90,
+	0x6c,
+	0x44,
+	0xef,
+	0xf0,
+	0xc0,
+	0x07,
+	0xc0,
+	0x06,
+	0xc0,
+	0x05,
+	0xc0,
+	0x04,
+	0xc0,
+	0x03,
+	0xc0,
+	0x02,
+	0x12,
+	0x84,
+	0x99,
+	0xd0,
+	0x02,
+	0xd0,
+	0x03,
+	0xd0,
+	0x04,
+	0xd0,
+	0x05,
+	0xd0,
+	0x06,
+	0xd0,
+	0x07,
+	0x90,
+	0x6c,
+	0x3c,
+	0xef,
+	0xf0,
+	0xe5,
+	0x12,
+	0x24,
+	0xf2,
+	0xf8,
+	0x90,
+	0x6c,
+	0x40,
+	0xe6,
+	0xf0,
+	0x08,
+	0xa3,
+	0xe6,
+	0xf0,
+	0xc0,
+	0x07,
+	0xc0,
+	0x06,
+	0xc0,
+	0x05,
+	0xc0,
+	0x04,
+	0xc0,
+	0x03,
+	0xc0,
+	0x02,
+	0x12,
+	0x85,
+	0x37,
+	0x12,
+	0x84,
+	0xe5,
+	0xd0,
+	0x02,
+	0xd0,
+	0x03,
+	0xd0,
+	0x04,
+	0xd0,
+	0x05,
+	0xd0,
+	0x06,
+	0xe5,
+	0x12,
+	0x24,
+	0xf4,
+	0xf8,
+	0x90,
+	0x6c,
+	0x38,
+	0xe6,
+	0xf0,
+	0x08,
+	0xa3,
+	0xe6,
+	0xf0,
+	0x90,
+	0x6c,
+	0x40,
+	0xed,
+	0xf0,
+	0xa3,
+	0xee,
+	0xf0,
+	0xc0,
+	0x04,
+	0xc0,
+	0x03,
+	0xc0,
+	0x02,
+	0x12,
+	0x85,
+	0x37,
+	0xd0,
+	0x02,
+	0xd0,
+	0x03,
+	0xd0,
+	0x04,
+	0xd0,
+	0x07,
+	0x90,
+	0x6c,
+	0x38,
+	0xea,
+	0xf0,
+	0xa3,
+	0xec,
+	0xf0,
+	0x90,
+	0x6c,
+	0x3c,
+	0xeb,
+	0xf0,
+	0xe5,
+	0x12,
+	0x24,
+	0xf8,
+	0xf8,
+	0x90,
+	0x6c,
+	0x40,
+	0xe6,
+	0xf0,
+	0x08,
+	0xa3,
+	0xe6,
+	0xf0,
+	0x90,
+	0x6c,
+	0x44,
+	0xef,
+	0xf0,
+	0xc0,
+	0x07,
+	0xc0,
+	0x04,
+	0xc0,
+	0x02,
+	0x12,
+	0x84,
+	0x99,
+	0xd0,
+	0x02,
+	0xd0,
+	0x04,
+	0xd0,
+	0x07,
+	0x90,
+	0x6c,
+	0x3c,
+	0xef,
+	0xf0,
+	0xa8,
+	0x12,
+	0x08,
+	0x90,
+	0x6c,
+	0x40,
+	0xe6,
+	0xf0,
+	0x08,
+	0xa3,
+	0xe6,
+	0xf0,
+	0xc0,
+	0x07,
+	0xc0,
+	0x04,
+	0xc0,
+	0x02,
+	0x12,
+	0x85,
+	0x37,
+	0xd0,
+	0x02,
+	0xd0,
+	0x04,
+	0xd0,
+	0x07,
+	0xc0,
+	0x07,
+	0xc0,
+	0x04,
+	0xc0,
+	0x02,
+	0xe5,
+	0x12,
+	0x24,
+	0xf2,
+	0xf8,
+	0xe6,
+	0xc0,
+	0xe0,
+	0x08,
+	0xe6,
+	0xc0,
+	0xe0,
+	0xc0,
+	0x02,
+	0xc0,
+	0x04,
+	0xa8,
+	0x12,
+	0x08,
+	0xe6,
+	0xc0,
+	0xe0,
+	0x08,
+	0xe6,
+	0xc0,
+	0xe0,
+	0xe5,
+	0x12,
+	0x24,
+	0xf2,
+	0xf8,
+	0xe6,
+	0xc0,
+	0xe0,
+	0x08,
+	0xe6,
+	0xc0,
+	0xe0,
+	0xe5,
+	0x12,
+	0x24,
+	0xf8,
+	0xf8,
+	0xe6,
+	0xc0,
+	0xe0,
+	0x08,
+	0xe6,
+	0xc0,
+	0xe0,
+	0xe5,
+	0x12,
+	0x24,
+	0xfa,
+	0xf8,
+	0xe6,
+	0xc0,
+	0xe0,
+	0x08,
+	0xe6,
+	0xc0,
+	0xe0,
+	0x08,
+	0xe6,
+	0xc0,
+	0xe0,
+	0x08,
+	0xe6,
+	0xc0,
+	0xe0,
+	0xc0,
+	0x07,
+	0x75,
+	0x82,
+	0x00,
+	0x12,
+	0x88,
+	0xd9,
+	0xe5,
+	0x81,
+	0x24,
+	0xf1,
+	0xf5,
+	0x81,
+	0xd0,
+	0x02,
+	0xd0,
+	0x04,
+	0xd0,
+	0x07,
+	0xe5,
+	0x12,
+	0x24,
+	0xf0,
+	0xf8,
+	0xe6,
+	0xc0,
+	0xe0,
+	0x08,
+	0xe6,
+	0xc0,
+	0xe0,
+	0xc0,
+	0x02,
+	0xc0,
+	0x04,
+	0xa8,
+	0x12,
+	0x08,
+	0xe6,
+	0xc0,
+	0xe0,
+	0x08,
+	0xe6,
+	0xc0,
+	0xe0,
+	0xe5,
+	0x12,
+	0x24,
+	0xf2,
+	0xf8,
+	0xe6,
+	0xc0,
+	0xe0,
+	0x08,
+	0xe6,
+	0xc0,
+	0xe0,
+	0xe5,
+	0x12,
+	0x24,
+	0xf8,
+	0xf8,
+	0xe6,
+	0xc0,
+	0xe0,
+	0x08,
+	0xe6,
+	0xc0,
+	0xe0,
+	0xe5,
+	0x12,
+	0x24,
+	0xfa,
+	0xf8,
+	0xe6,
+	0xc0,
+	0xe0,
+	0x08,
+	0xe6,
+	0xc0,
+	0xe0,
+	0x08,
+	0xe6,
+	0xc0,
+	0xe0,
+	0x08,
+	0xe6,
+	0xc0,
+	0xe0,
+	0xc0,
+	0x07,
+	0x75,
+	0x82,
+	0x01,
+	0x12,
+	0x88,
+	0xd9,
+	0xe5,
+	0x81,
+	0x24,
+	0xf1,
+	0x85,
+	0x12,
+	0x81,
+	0xd0,
+	0x12,
+	0x22,
+	0xc0,
+	0x12,
+	0xe5,
+	0x81,
+	0xf5,
+	0x12,
+	0x24,
+	0x0f,
+	0xf5,
+	0x81,
+	0xaf,
+	0x82,
+	0xa8,
+	0x12,
+	0x08,
+	0xe4,
+	0xf6,
+	0x08,
+	0xf6,
+	0x08,
+	0xf6,
+	0x08,
+	0xf6,
+	0xef,
+	0x60,
+	0x0b,
+	0xe5,
+	0x12,
+	0x24,
+	0xfd,
+	0xf8,
+	0xe6,
+	0xc3,
+	0x13,
+	0xff,
+	0x80,
+	0x07,
+	0xe5,
+	0x12,
+	0x24,
+	0xfd,
+	0xf8,
+	0x86,
+	0x07,
+	0xe5,
+	0x12,
+	0x24,
+	0x09,
+	0xf8,
+	0xa6,
+	0x07,
+	0xe5,
+	0x12,
+	0x24,
+	0xf5,
+	0xf8,
+	0xe5,
+	0x12,
+	0x24,
+	0x0a,
+	0xf9,
+	0xe6,
+	0xf7,
+	0x08,
+	0x09,
+	0xe6,
+	0xf7,
+	0xe5,
+	0x12,
+	0x24,
+	0x09,
+	0xf8,
+	0x86,
+	0x02,
+	0x7e,
+	0x00,
+	0xe5,
+	0x12,
+	0x24,
+	0x0a,
+	0xf8,
+	0xea,
+	0x26,
+	0xfc,
+	0xee,
+	0x08,
+	0x36,
+	0xfd,
+	0xe5,
+	0x12,
+	0x24,
+	0x0c,
+	0xf8,
+	0xa6,
+	0x04,
+	0x08,
+	0xa6,
+	0x05,
+	0xe5,
+	0x12,
+	0x24,
+	0x0c,
+	0xf8,
+	0xea,
+	0x26,
+	0xfa,
+	0xee,
+	0x08,
+	0x36,
+	0xfe,
+	0xe5,
+	0x12,
+	0x24,
+	0x0e,
+	0xf8,
+	0xa6,
+	0x02,
+	0x08,
+	0xa6,
+	0x06,
+	0xe5,
+	0x12,
+	0x24,
+	0xfb,
+	0xf8,
+	0x86,
+	0x05,
+	0x08,
+	0xe6,
+	0xcd,
+	0x25,
+	0xe0,
+	0xcd,
+	0x33,
+	0xcd,
+	0x25,
+	0xe0,
+	0xcd,
+	0x33,
+	0x24,
+	0x60,
+	0xfe,
+	0x7c,
+	0x00,
+	0x8d,
+	0x82,
+	0x8e,
+	0x83,
+	0x8c,
+	0xf0,
+	0x12,
+	0x88,
+	0x22,
+	0xab,
+	0x82,
+	0xac,
+	0x83,
+	0xad,
+	0xf0,
+	0xfe,
+	0xe5,
+	0x12,
+	0x24,
+	0x05,
+	0xf8,
+	0xa6,
+	0x03,
+	0x08,
+	0xa6,
+	0x04,
+	0x08,
+	0xa6,
+	0x05,
+	0x08,
+	0xa6,
+	0x06,
+	0xe5,
+	0x12,
+	0x24,
+	0xf7,
+	0xf8,
+	0x90,
+	0x6c,
+	0x38,
+	0xe6,
+	0xf0,
+	0x08,
+	0xa3,
+	0xe6,
+	0xf0,
+	0xe5,
+	0x12,
+	0x24,
+	0xfd,
+	0xf8,
+	0x90,
+	0x6c,
+	0x3c,
+	0xe6,
+	0xf0,
+	0xe5,
+	0x12,
+	0x24,
+	0x0c,
+	0xf8,
+	0x90,
+	0x6c,
+	0x40,
+	0xe6,
+	0xf0,
+	0x08,
+	0xa3,
+	0xe6,
+	0xf0,
+	0x12,
+	0x85,
+	0x37,
+	0xe5,
+	0x12,
+	0x24,
+	0x0a,
+	0xf8,
+	0x90,
+	0x6c,
+	0x38,
+	0xe6,
+	0xf0,
+	0x08,
+	0xa3,
+	0xe6,
+	0xf0,
+	0xe5,
+	0x12,
+	0x24,
+	0x09,
+	0xf8,
+	0x90,
+	0x6c,
+	0x3c,
+	0xe6,
+	0xf0,
+	0x12,
+	0x84,
+	0xe5,
+	0xe5,
+	0x12,
+	0x24,
+	0xfd,
+	0xf8,
+	0xe5,
+	0x12,
+	0x24,
+	0x09,
+	0xf9,
+	0x90,
+	0x6c,
+	0x3c,
+	0xe7,
+	0x26,
+	0xf0,
+	0xe5,
+	0x12,
+	0x24,
+	0xfb,
+	0xf8,
+	0x90,
+	0x6c,
+	0x40,
+	0xe6,
+	0xf0,
+	0x08,
+	0xa3,
+	0xe6,
+	0xf0,
+	0xe5,
+	0x12,
+	0x24,
+	0x09,
+	0xf8,
+	0x90,
+	0x6c,
+	0x44,
+	0xe6,
+	0xf0,
+	0x12,
+	0x84,
+	0x99,
+	0xe5,
+	0x12,
+	0x24,
+	0x0e,
+	0xf8,
+	0x86,
+	0x05,
+	0x08,
+	0xe6,
+	0xcd,
+	0x25,
+	0xe0,
+	0xcd,
+	0x33,
+	0xcd,
+	0x25,
+	0xe0,
+	0xcd,
+	0x33,
+	0x24,
+	0x60,
+	0xfe,
+	0x8d,
+	0x82,
+	0x8e,
+	0x83,
+	0x74,
+	0x01,
+	0xf0,
+	0xa3,
+	0xe4,
+	0xf0,
+	0xa3,
+	0xf0,
+	0xa3,
+	0xf0,
+	0xe5,
+	0x12,
+	0x24,
+	0x0c,
+	0xf8,
+	0x90,
+	0x6c,
+	0x38,
+	0xe6,
+	0xf0,
+	0x08,
+	0xa3,
+	0xe6,
+	0xf0,
+	0xe5,
+	0x12,
+	0x24,
+	0x09,
+	0xf8,
+	0x90,
+	0x6c,
+	0x3c,
+	0xe6,
+	0xf0,
+	0x12,
+	0x84,
+	0xe5,
+	0xe5,
+	0x12,
+	0x24,
+	0x09,
+	0xf8,
+	0x90,
+	0x6c,
+	0x3c,
+	0xe6,
+	0x04,
+	0xf0,
+	0x12,
+	0x84,
+	0x99,
+	0xe5,
+	0x12,
+	0x24,
+	0x09,
+	0xf8,
+	0xe6,
+	0x14,
+	0xfb,
+	0xfe,
+	0xee,
+	0x20,
+	0xe7,
+	0x44,
+	0xee,
+	0xfa,
+	0x33,
+	0x95,
+	0xe0,
+	0xff,
+	0xe5,
+	0x12,
+	0x24,
+	0xf9,
+	0xf8,
+	0xea,
+	0x26,
+	0xfa,
+	0xef,
+	0x08,
+	0x36,
+	0xca,
+	0x25,
+	0xe0,
+	0xca,
+	0x33,
+	0xca,
+	0x25,
+	0xe0,
+	0xca,
+	0x33,
+	0x24,
+	0x60,
+	0xff,
+	0x8a,
+	0x82,
+	0x8f,
+	0x83,
+	0xa8,
+	0x12,
+	0x08,
+	0xe0,
+	0xf6,
+	0xa3,
+	0xe0,
+	0x08,
+	0xf6,
+	0xa3,
+	0xe0,
+	0x08,
+	0xf6,
+	0xa3,
+	0xe0,
+	0x08,
+	0xf6,
+	0xa8,
+	0x12,
+	0x08,
+	0xe6,
+	0x08,
+	0x46,
+	0x08,
+	0x46,
+	0x08,
+	0x46,
+	0x70,
+	0x05,
+	0x1e,
+	0x8e,
+	0x03,
+	0x80,
+	0xb8,
+	0x8e,
+	0x03,
+	0x7a,
+	0x1f,
+	0xea,
+	0x20,
+	0xe7,
+	0x47,
+	0x8a,
+	0xf0,
+	0x05,
+	0xf0,
+	0x7c,
+	0x01,
+	0x7d,
+	0x00,
+	0x7e,
+	0x00,
+	0x7f,
+	0x00,
+	0x80,
+	0x0c,
+	0xec,
+	0x2c,
+	0xfc,
+	0xed,
+	0x33,
+	0xfd,
+	0xee,
+	0x33,
+	0xfe,
+	0xef,
+	0x33,
+	0xff,
+	0xd5,
+	0xf0,
+	0xf1,
+	0xa8,
+	0x12,
+	0x08,
+	0xe6,
+	0x52,
+	0x04,
+	0x08,
+	0xe6,
+	0x52,
+	0x05,
+	0x08,
+	0xe6,
+	0x52,
+	0x06,
+	0x08,
+	0xe6,
+	0x52,
+	0x07,
+	0xec,
+	0x4d,
+	0x4e,
+	0x4f,
+	0x70,
+	0x12,
+	0xea,
+	0x70,
+	0x0c,
+	0xa8,
+	0x12,
+	0x08,
+	0x76,
+	0x01,
+	0xe4,
+	0x08,
+	0xf6,
+	0x08,
+	0xf6,
+	0x08,
+	0xf6,
+	0x1a,
+	0x80,
+	0xb5,
+	0x8a,
+	0x06,
+	0x8b,
+	0x05,
+	0xed,
+	0x30,
+	0xe7,
+	0x03,
+	0x02,
+	0x8f,
+	0x8f,
+	0xed,
+	0xfb,
+	0x33,
+	0x95,
+	0xe0,
+	0xfc,
+	0xe5,
+	0x12,
+	0x24,
+	0xf9,
+	0xf8,
+	0xeb,
+	0x26,
+	0xfb,
+	0xec,
+	0x08,
+	0x36,
+	0xcb,
+	0x25,
+	0xe0,
+	0xcb,
+	0x33,
+	0xcb,
+	0x25,
+	0xe0,
+	0xcb,
+	0x33,
+	0x24,
+	0x60,
+	0xfc,
+	0x8b,
+	0x82,
+	0x8c,
+	0x83,
+	0xa8,
+	0x12,
+	0x08,
+	0xe0,
+	0xf6,
+	0xa3,
+	0xe0,
+	0x08,
+	0xf6,
+	0xa3,
+	0xe0,
+	0x08,
+	0xf6,
+	0xa3,
+	0xe0,
+	0x08,
+	0xf6,
+	0x90,
+	0x30,
+	0x02,
+	0xe4,
+	0xf0,
+	0x90,
+	0x30,
+	0x03,
+	0xed,
+	0xf0,
+	0x90,
+	0x30,
+	0x02,
+	0x74,
+	0x5e,
+	0xf0,
+	0x8e,
+	0x04,
+	0xec,
+	0x30,
+	0xe7,
+	0x03,
+	0x02,
+	0x8f,
+	0x89,
+	0xc0,
+	0x05,
+	0xc0,
+	0x05,
+	0xc0,
+	0x04,
+	0xe5,
+	0x12,
+	0x24,
+	0x0c,
+	0xf8,
+	0xe6,
+	0xc0,
+	0xe0,
+	0x08,
+	0xe6,
+	0xc0,
+	0xe0,
+	0xe5,
+	0x12,
+	0x24,
+	0x0e,
+	0xf8,
+	0xe6,
+	0xc0,
+	0xe0,
+	0x08,
+	0xe6,
+	0xc0,
+	0xe0,
+	0xe5,
+	0x12,
+	0x24,
+	0x0c,
+	0xf8,
+	0xe6,
+	0xc0,
+	0xe0,
+	0x08,
+	0xe6,
+	0xc0,
+	0xe0,
+	0xe5,
+	0x12,
+	0x24,
+	0x0c,
+	0xf8,
+	0xe6,
+	0xc0,
+	0xe0,
+	0x08,
+	0xe6,
+	0xc0,
+	0xe0,
+	0xe5,
+	0x12,
+	0x24,
+	0xfb,
+	0xf8,
+	0xe6,
+	0xc0,
+	0xe0,
+	0x08,
+	0xe6,
+	0xc0,
+	0xe0,
+	0xe5,
+	0x12,
+	0x24,
+	0x05,
+	0xf8,
+	0xe6,
+	0xc0,
+	0xe0,
+	0x08,
+	0xe6,
+	0xc0,
+	0xe0,
+	0x08,
+	0xe6,
+	0xc0,
+	0xe0,
+	0x08,
+	0xe6,
+	0xc0,
+	0xe0,
+	0xe5,
+	0x12,
+	0x24,
+	0x09,
+	0xf8,
+	0xe6,
+	0xc0,
+	0xe0,
+	0x75,
+	0x82,
+	0x00,
+	0x12,
+	0x88,
+	0xd9,
+	0xe5,
+	0x81,
+	0x24,
+	0xf1,
+	0xf5,
+	0x81,
+	0xd0,
+	0x04,
+	0xd0,
+	0x05,
+	0x8c,
+	0xf0,
+	0x05,
+	0xf0,
+	0x7a,
+	0x01,
+	0x7b,
+	0x00,
+	0x7d,
+	0x00,
+	0x7f,
+	0x00,
+	0x80,
+	0x0c,
+	0xea,
+	0x2a,
+	0xfa,
+	0xeb,
+	0x33,
+	0xfb,
+	0xed,
+	0x33,
+	0xfd,
+	0xef,
+	0x33,
+	0xff,
+	0xd5,
+	0xf0,
+	0xf1,
+	0xa8,
+	0x12,
+	0x08,
+	0xe6,
+	0x52,
+	0x02,
+	0x08,
+	0xe6,
+	0x52,
+	0x03,
+	0x08,
+	0xe6,
+	0x52,
+	0x05,
+	0x08,
+	0xe6,
+	0x52,
+	0x07,
+	0xea,
+	0x4b,
+	0x4d,
+	0x4f,
+	0xd0,
+	0x05,
+	0x60,
+	0x6c,
+	0xc0,
+	0x05,
+	0xc0,
+	0x04,
+	0xe5,
+	0x12,
+	0x24,
+	0x0c,
+	0xf8,
+	0xe6,
+	0xc0,
+	0xe0,
+	0x08,
+	0xe6,
+	0xc0,
+	0xe0,
+	0xe5,
+	0x12,
+	0x24,
+	0x0e,
+	0xf8,
+	0xe6,
+	0xc0,
+	0xe0,
+	0x08,
+	0xe6,
+	0xc0,
+	0xe0,
+	0xe5,
+	0x12,
+	0x24,
+	0x0c,
+	0xf8,
+	0xe6,
+	0xc0,
+	0xe0,
+	0x08,
+	0xe6,
+	0xc0,
+	0xe0,
+	0xe5,
+	0x12,
+	0x24,
+	0x0a,
+	0xf8,
+	0xe6,
+	0xc0,
+	0xe0,
+	0x08,
+	0xe6,
+	0xc0,
+	0xe0,
+	0xe5,
+	0x12,
+	0x24,
+	0xfb,
+	0xf8,
+	0xe6,
+	0xc0,
+	0xe0,
+	0x08,
+	0xe6,
+	0xc0,
+	0xe0,
+	0xe5,
+	0x12,
+	0x24,
+	0x05,
+	0xf8,
+	0xe6,
+	0xc0,
+	0xe0,
+	0x08,
+	0xe6,
+	0xc0,
+	0xe0,
+	0x08,
+	0xe6,
+	0xc0,
+	0xe0,
+	0x08,
+	0xe6,
+	0xc0,
+	0xe0,
+	0xe5,
+	0x12,
+	0x24,
+	0x09,
+	0xf8,
+	0xe6,
+	0xc0,
+	0xe0,
+	0x75,
+	0x82,
+	0x00,
+	0x12,
+	0x88,
+	0xd9,
+	0xe5,
+	0x81,
+	0x24,
+	0xf1,
+	0xf5,
+	0x81,
+	0xd0,
+	0x04,
+	0xd0,
+	0x05,
+	0x1c,
+	0x02,
+	0x8e,
+	0x6d,
+	0x7e,
+	0x1f,
+	0x1d,
+	0x02,
+	0x8e,
+	0x21,
+	0xe5,
+	0x12,
+	0x24,
+	0xf3,
+	0xf8,
+	0xe6,
+	0xc0,
+	0xe0,
+	0x08,
+	0xe6,
+	0xc0,
+	0xe0,
+	0xe5,
+	0x12,
+	0x24,
+	0x0e,
+	0xf8,
+	0xe6,
+	0xc0,
+	0xe0,
+	0x08,
+	0xe6,
+	0xc0,
+	0xe0,
+	0xe5,
+	0x12,
+	0x24,
+	0x0c,
+	0xf8,
+	0xe6,
+	0xc0,
+	0xe0,
+	0x08,
+	0xe6,
+	0xc0,
+	0xe0,
+	0xe5,
+	0x12,
+	0x24,
+	0x0c,
+	0xf8,
+	0xe6,
+	0xc0,
+	0xe0,
+	0x08,
+	0xe6,
+	0xc0,
+	0xe0,
+	0xe5,
+	0x12,
+	0x24,
+	0xfb,
+	0xf8,
+	0xe6,
+	0xc0,
+	0xe0,
+	0x08,
+	0xe6,
+	0xc0,
+	0xe0,
+	0xe5,
+	0x12,
+	0x24,
+	0x05,
+	0xf8,
+	0xe6,
+	0xc0,
+	0xe0,
+	0x08,
+	0xe6,
+	0xc0,
+	0xe0,
+	0x08,
+	0xe6,
+	0xc0,
+	0xe0,
+	0x08,
+	0xe6,
+	0xc0,
+	0xe0,
+	0xe5,
+	0x12,
+	0x24,
+	0x09,
+	0xf8,
+	0xe6,
+	0xc0,
+	0xe0,
+	0x75,
+	0x82,
+	0x01,
+	0x12,
+	0x88,
+	0xd9,
+	0xe5,
+	0x81,
+	0x24,
+	0xf1,
+	0xf5,
+	0x81,
+	0x85,
+	0x12,
+	0x81,
+	0xd0,
+	0x12,
+	0x22,
+	0xc0,
+	0x12,
+	0x85,
+	0x81,
+	0x12,
+	0xc0,
+	0x82,
+	0xe5,
+	0x81,
+	0x24,
+	0x08,
+	0xf5,
+	0x81,
+	0xa8,
+	0x12,
+	0x08,
+	0x86,
+	0x05,
+	0x7e,
+	0x00,
+	0xe5,
+	0x12,
+	0x24,
+	0xf0,
+	0xf8,
+	0xed,
+	0x26,
+	0xfd,
+	0xee,
+	0x08,
+	0x36,
+	0xfe,
+	0x8d,
+	0x07,
+	0xa8,
+	0x12,
+	0x08,
+	0xe6,
+	0xc3,
+	0x13,
+	0xfc,
+	0xfa,
+	0x7b,
+	0x00,
+	0xa8,
+	0x12,
+	0x08,
+	0x08,
+	0xea,
+	0x2f,
+	0xf6,
+	0xeb,
+	0x3e,
+	0x08,
+	0xf6,
+	0xa8,
+	0x12,
+	0x08,
+	0x08,
+	0xa8,
+	0x12,
+	0x08,
+	0x08,
+	0xe5,
+	0x12,
+	0x24,
+	0x04,
+	0xf9,
+	0xea,
+	0x26,
+	0xf7,
+	0xeb,
+	0x08,
+	0x36,
+	0x09,
+	0xf7,
+	0xe5,
+	0x12,
+	0x24,
+	0x04,
+	0xe5,
+	0x12,
+	0x24,
+	0x04,
+	0xf8,
+	0xea,
+	0x26,
+	0xfa,
+	0xeb,
+	0x08,
+	0x36,
+	0xfb,
+	0xc0,
+	0x07,
+	0xc0,
+	0x06,
+	0xc0,
+	0x04,
+	0xc0,
+	0x03,
+	0xc0,
+	0x02,
+	0xc0,
+	0x07,
+	0xc0,
+	0x06,
+	0xe5,
+	0x12,
+	0x24,
+	0x04,
+	0xf8,
+	0xe6,
+	0xc0,
+	0xe0,
+	0x08,
+	0xe6,
+	0xc0,
+	0xe0,
+	0xe5,
+	0x12,
+	0x24,
+	0xf2,
+	0xf8,
+	0xe6,
+	0xc0,
+	0xe0,
+	0x08,
+	0xe6,
+	0xc0,
+	0xe0,
+	0xe5,
+	0x12,
+	0x24,
+	0xf8,
+	0xf8,
+	0xe6,
+	0xc0,
+	0xe0,
+	0x08,
+	0xe6,
+	0xc0,
+	0xe0,
+	0xe5,
+	0x12,
+	0x24,
+	0xfc,
+	0xf8,
+	0xe6,
+	0xc0,
+	0xe0,
+	0x08,
+	0xe6,
+	0xc0,
+	0xe0,
+	0xa8,
+	0x12,
+	0x08,
+	0xe6,
+	0xc0,
+	0xe0,
+	0x75,
+	0x82,
+	0x01,
+	0x12,
+	0x8c,
+	0x11,
+	0xe5,
+	0x81,
+	0x24,
+	0xf5,
+	0xf5,
+	0x81,
+	0xa8,
+	0x12,
+	0x08,
+	0x08,
+	0xe6,
+	0xc0,
+	0xe0,
+	0x08,
+	0xe6,
+	0xc0,
+	0xe0,
+	0xe5,
+	0x12,
+	0x24,
+	0x04,
+	0xf8,
+	0xe6,
+	0xc0,
+	0xe0,
+	0x08,
+	0xe6,
+	0xc0,
+	0xe0,
+	0xe5,
+	0x12,
+	0x24,
+	0xf2,
+	0xf8,
+	0xe6,
+	0xc0,
+	0xe0,
+	0x08,
+	0xe6,
+	0xc0,
+	0xe0,
+	0xe5,
+	0x12,
+	0x24,
+	0xf6,
+	0xf8,
+	0xe6,
+	0xc0,
+	0xe0,
+	0x08,
+	0xe6,
+	0xc0,
+	0xe0,
+	0xe5,
+	0x12,
+	0x24,
+	0xfa,
+	0xf8,
+	0xe6,
+	0xc0,
+	0xe0,
+	0x08,
+	0xe6,
+	0xc0,
+	0xe0,
+	0xa8,
+	0x12,
+	0x08,
+	0xe6,
+	0xc0,
+	0xe0,
+	0x75,
+	0x82,
+	0x01,
+	0x12,
+	0x8c,
+	0x11,
+	0xe5,
+	0x81,
+	0x24,
+	0xf5,
+	0xf5,
+	0x81,
+	0xd0,
+	0x02,
+	0xd0,
+	0x03,
+	0xd0,
+	0x04,
+	0xd0,
+	0x06,
+	0xd0,
+	0x07,
+	0x90,
+	0x6c,
+	0x38,
+	0xef,
+	0xf0,
+	0xa3,
+	0xee,
+	0xf0,
+	0x90,
+	0x6c,
+	0x3c,
+	0xec,
+	0xf0,
+	0xa8,
+	0x12,
+	0x08,
+	0x08,
+	0x90,
+	0x6c,
+	0x40,
+	0xe6,
+	0xf0,
+	0x08,
+	0xa3,
+	0xe6,
+	0xf0,
+	0x90,
+	0x6c,
+	0x44,
+	0xec,
+	0xf0,
+	0xe5,
+	0x12,
+	0x24,
+	0x04,
+	0xf8,
+	0x90,
+	0x6c,
+	0x48,
+	0xe6,
+	0xf0,
+	0x08,
+	0xa3,
+	0xe6,
+	0xf0,
+	0xc0,
+	0x04,
+	0xc0,
+	0x03,
+	0xc0,
+	0x02,
+	0x12,
+	0x83,
+	0xaa,
+	0xd0,
+	0x02,
+	0xd0,
+	0x03,
+	0xd0,
+	0x04,
+	0xeb,
+	0xca,
+	0x25,
+	0xe0,
+	0xca,
+	0x33,
+	0xca,
+	0x25,
+	0xe0,
+	0xca,
+	0x33,
+	0xfb,
+	0x8a,
+	0x06,
+	0x74,
+	0x60,
+	0x2b,
+	0xff,
+	0x8e,
+	0x82,
+	0x8f,
+	0x83,
+	0xe5,
+	0x12,
+	0x24,
+	0x06,
+	0xf8,
+	0xe0,
+	0xf6,
+	0xa3,
+	0xe0,
+	0x08,
+	0xf6,
+	0xa3,
+	0xe0,
+	0x08,
+	0xf6,
+	0xa3,
+	0xe0,
+	0x08,
+	0xf6,
+	0xe5,
+	0x12,
+	0x24,
+	0x04,
+	0xf8,
+	0x90,
+	0x6c,
+	0x38,
+	0xe6,
+	0xf0,
+	0x08,
+	0xa3,
+	0xe6,
+	0xf0,
+	0x90,
+	0x6c,
+	0x3c,
+	0xec,
+	0xf0,
+	0xe5,
+	0x12,
+	0x24,
+	0xfc,
+	0xf8,
+	0x90,
+	0x6c,
+	0x40,
+	0xe6,
+	0xf0,
+	0x08,
+	0xa3,
+	0xe6,
+	0xf0,
+	0x90,
+	0x6c,
+	0x44,
+	0xec,
+	0xf0,
+	0xe5,
+	0x12,
+	0x24,
+	0x04,
+	0xf8,
+	0x90,
+	0x6c,
+	0x48,
+	0xe6,
+	0xf0,
+	0x08,
+	0xa3,
+	0xe6,
+	0xf0,
+	0x8a,
+	0x06,
+	0x74,
+	0x60,
+	0x2b,
+	0xff,
+	0xe5,
+	0x12,
+	0x24,
+	0x06,
+	0xf8,
+	0xe6,
+	0x08,
+	0x46,
+	0x08,
+	0x46,
+	0x08,
+	0x46,
+	0x60,
+	0x7a,
+	0xe5,
+	0x12,
+	0x24,
+	0x04,
+	0xf8,
+	0x90,
+	0x6c,
+	0x38,
+	0xe6,
+	0xf0,
+	0x08,
+	0xa3,
+	0xe6,
+	0xf0,
+	0x90,
+	0x6c,
+	0x3c,
+	0xec,
+	0xf0,
+	0xe5,
+	0x12,
+	0x24,
+	0xfc,
+	0xf8,
+	0x90,
+	0x6c,
+	0x40,
+	0xe6,
+	0xf0,
+	0x08,
+	0xa3,
+	0xe6,
+	0xf0,
+	0x90,
+	0x6c,
+	0x44,
+	0xec,
+	0xf0,
+	0xe5,
+	0x12,
+	0x24,
+	0x04,
+	0xf8,
+	0x90,
+	0x6c,
+	0x48,
+	0xe6,
+	0xf0,
+	0x08,
+	0xa3,
+	0xe6,
+	0xf0,
+	0xc0,
+	0x07,
+	0xc0,
+	0x06,
+	0xc0,
+	0x04,
+	0x12,
+	0x82,
+	0xbb,
+	0xd0,
+	0x04,
+	0xd0,
+	0x06,
+	0xd0,
+	0x07,
+	0x8e,
+	0x82,
+	0x8f,
+	0x83,
+	0xc0,
+	0x06,
+	0xc0,
+	0x07,
+	0xe0,
+	0xfa,
+	0xa3,
+	0xe0,
+	0xfb,
+	0xa3,
+	0xe0,
+	0xfd,
+	0xa3,
+	0xe0,
+	0xff,
+	0xea,
+	0xf4,
+	0xfa,
+	0xeb,
+	0xf4,
+	0xfb,
+	0xed,
+	0xf4,
+	0xfd,
+	0xef,
+	0xf4,
+	0xe5,
+	0x12,
+	0x24,
+	0x06,
+	0xf8,
+	0x74,
+	0x01,
+	0x5a,
+	0xf6,
+	0x08,
+	0x76,
+	0x00,
+	0x08,
+	0x76,
+	0x00,
+	0x08,
+	0x76,
+	0x00,
+	0xd0,
+	0x07,
+	0xd0,
+	0x06,
+	0x02,
+	0x91,
+	0x9b,
+	0xe5,
+	0x12,
+	0x24,
+	0x04,
+	0xf8,
+	0x90,
+	0x6c,
+	0x38,
+	0xe6,
+	0xf0,
+	0x08,
+	0xa3,
+	0xe6,
+	0xf0,
+	0x90,
+	0x6c,
+	0x3c,
+	0xec,
+	0xf0,
+	0xe5,
+	0x12,
+	0x24,
+	0xf4,
+	0xf8,
+	0x90,
+	0x6c,
+	0x40,
+	0xe6,
+	0xf0,
+	0x08,
+	0xa3,
+	0xe6,
+	0xf0,
+	0x90,
+	0x6c,
+	0x44,
+	0xec,
+	0xf0,
+	0xe5,
+	0x12,
+	0x24,
+	0xf0,
+	0xf8,
+	0x90,
+	0x6c,
+	0x48,
+	0xe6,
+	0xf0,
+	0x08,
+	0xa3,
+	0xe6,
+	0xf0,
+	0xc0,
+	0x04,
+	0x12,
+	0x81,
+	0x6a,
+	0xd0,
+	0x04,
+	0xe5,
+	0x12,
+	0x24,
+	0xf0,
+	0xf8,
+	0x90,
+	0x6c,
+	0x38,
+	0xe6,
+	0xf0,
+	0x08,
+	0xa3,
+	0xe6,
+	0xf0,
+	0xa8,
+	0x12,
+	0x08,
+	0x90,
+	0x6c,
+	0x3c,
+	0xe6,
+	0xf0,
+	0xe5,
+	0x12,
+	0x24,
+	0xfc,
+	0xf8,
+	0x90,
+	0x6c,
+	0x40,
+	0xe6,
+	0xf0,
+	0x08,
+	0xa3,
+	0xe6,
+	0xf0,
+	0x90,
+	0x6c,
+	0x44,
+	0xec,
+	0xf0,
+	0xc0,
+	0x04,
+	0x12,
+	0x84,
+	0x99,
+	0xd0,
+	0x04,
+	0xe5,
+	0x12,
+	0x24,
+	0xf0,
+	0xf8,
+	0x90,
+	0x6c,
+	0x38,
+	0xe6,
+	0xf0,
+	0x08,
+	0xa3,
+	0xe6,
+	0xf0,
+	0x90,
+	0x6c,
+	0x3c,
+	0xec,
+	0xf0,
+	0xe5,
+	0x12,
+	0x24,
+	0xfa,
+	0xf8,
+	0x90,
+	0x6c,
+	0x40,
+	0xe6,
+	0xf0,
+	0x08,
+	0xa3,
+	0xe6,
+	0xf0,
+	0x90,
+	0x6c,
+	0x44,
+	0xec,
+	0xf0,
+	0xe5,
+	0x12,
+	0x24,
+	0x04,
+	0xf8,
+	0x90,
+	0x6c,
+	0x48,
+	0xe6,
+	0xf0,
+	0x08,
+	0xa3,
+	0xe6,
+	0xf0,
+	0xc0,
+	0x04,
+	0x12,
+	0x81,
+	0x6a,
+	0xd0,
+	0x04,
+	0xa8,
+	0x12,
+	0x08,
+	0x08,
+	0x90,
+	0x6c,
+	0x38,
+	0xe6,
+	0xf0,
+	0x08,
+	0xa3,
+	0xe6,
+	0xf0,
+	0x90,
+	0x6c,
+	0x3c,
+	0xec,
+	0xf0,
+	0xe5,
+	0x12,
+	0x24,
+	0x04,
+	0xf8,
+	0x90,
+	0x6c,
+	0x40,
+	0xe6,
+	0xf0,
+	0x08,
+	0xa3,
+	0xe6,
+	0xf0,
+	0xa8,
+	0x12,
+	0x08,
+	0x90,
+	0x6c,
+	0x44,
+	0xe6,
+	0xf0,
+	0xe5,
+	0x12,
+	0x24,
+	0xf0,
+	0xf8,
+	0x90,
+	0x6c,
+	0x48,
+	0xe6,
+	0xf0,
+	0x08,
+	0xa3,
+	0xe6,
+	0xf0,
+	0x12,
+	0x82,
+	0xbb,
+	0xe5,
+	0x12,
+	0x24,
+	0xf0,
+	0xf8,
+	0x90,
+	0x6c,
+	0x38,
+	0xe6,
+	0xf0,
+	0x08,
+	0xa3,
+	0xe6,
+	0xf0,
+	0xa8,
+	0x12,
+	0x08,
+	0x90,
+	0x6c,
+	0x3c,
+	0xe6,
+	0xf0,
+	0xe5,
+	0x12,
+	0x24,
+	0xee,
+	0xf8,
+	0x90,
+	0x6c,
+	0x40,
+	0xe6,
+	0xf0,
+	0x08,
+	0xa3,
+	0xe6,
+	0xf0,
+	0x12,
+	0x85,
+	0x37,
+	0x85,
+	0x12,
+	0x81,
+	0xd0,
+	0x12,
+	0x22,
+	0xc0,
+	0x12,
+	0x85,
+	0x81,
+	0x12,
+	0xc0,
+	0x82,
+	0xe5,
+	0x81,
+	0x24,
+	0x04,
+	0xf5,
+	0x81,
+	0xe5,
+	0x12,
+	0x24,
+	0xf3,
+	0xf8,
+	0x86,
+	0x05,
+	0x08,
+	0x86,
+	0x06,
+	0xe5,
+	0x12,
+	0x24,
+	0xfd,
+	0xf8,
+	0xe6,
+	0x75,
+	0xf0,
+	0x02,
+	0xa4,
+	0xac,
+	0xf0,
+	0x2d,
+	0xfb,
+	0xec,
+	0x3e,
+	0xfc,
+	0xa8,
+	0x12,
+	0x08,
+	0x08,
+	0xa6,
+	0x03,
+	0x08,
+	0xa6,
+	0x04,
+	0xe5,
+	0x12,
+	0x24,
+	0xfd,
+	0xf8,
+	0x86,
+	0x02,
+	0x7f,
+	0x00,
+	0xa8,
+	0x12,
+	0x08,
+	0x08,
+	0xea,
+	0x26,
+	0xfb,
+	0xef,
+	0x08,
+	0x36,
+	0xfc,
+	0xe5,
+	0x12,
+	0x24,
+	0x04,
+	0xf8,
+	0xea,
+	0x2b,
+	0xf6,
+	0xef,
+	0x3c,
+	0x08,
+	0xf6,
+	0xe5,
+	0x12,
+	0x24,
+	0x04,
+	0xe5,
+	0x12,
+	0x24,
+	0xf7,
+	0xf8,
+	0x90,
+	0x6c,
+	0x38,
+	0xe6,
+	0xf0,
+	0x08,
+	0xa3,
+	0xe6,
+	0xf0,
+	0xe5,
+	0x12,
+	0x24,
+	0xfd,
+	0xf8,
+	0x90,
+	0x6c,
+	0x3c,
+	0xe6,
+	0xf0,
+	0xe5,
+	0x12,
+	0x24,
+	0xfd,
+	0xf8,
+	0x90,
+	0x6c,
+	0x44,
+	0xe6,
+	0xf0,
+	0xa8,
+	0x12,
+	0x08,
+	0xe6,
+	0x70,
+	0x2b,
+	0xe5,
+	0x12,
+	0x24,
+	0xf5,
+	0xf8,
+	0x90,
+	0x6c,
+	0x40,
+	0xe6,
+	0xf0,
+	0x08,
+	0xa3,
+	0xe6,
+	0xf0,
+	0x90,
+	0x6c,
+	0x48,
+	0xed,
+	0xf0,
+	0xa3,
+	0xee,
+	0xf0,
+	0xc0,
+	0x06,
+	0xc0,
+	0x05,
+	0xc0,
+	0x04,
+	0xc0,
+	0x03,
+	0x12,
+	0x81,
+	0x6a,
+	0xd0,
+	0x03,
+	0xd0,
+	0x04,
+	0xd0,
+	0x05,
+	0xd0,
+	0x06,
+	0x80,
+	0x40,
+	0x90,
+	0x6c,
+	0x40,
+	0xed,
+	0xf0,
+	0xa3,
+	0xee,
+	0xf0,
+	0xc0,
+	0x07,
+	0xc0,
+	0x06,
+	0xc0,
+	0x05,
+	0xc0,
+	0x04,
+	0xc0,
+	0x03,
+	0xc0,
+	0x02,
+	0x12,
+	0x85,
+	0x37,
+	0xd0,
+	0x02,
+	0xd0,
+	0x03,
+	0xd0,
+	0x04,
+	0xd0,
+	0x05,
+	0xd0,
+	0x06,
+	0xd0,
+	0x07,
+	0x90,
+	0x6c,
+	0x38,
+	0xea,
+	0x2d,
+	0xf0,
+	0xef,
+	0x3e,
+	0xa3,
+	0xf0,
+	0xc0,
+	0x06,
+	0xc0,
+	0x05,
+	0xc0,
+	0x04,
+	0xc0,
+	0x03,
+	0x12,
+	0x84,
+	0xe5,
+	0xd0,
+	0x03,
+	0xd0,
+	0x04,
+	0xd0,
+	0x05,
+	0xd0,
+	0x06,
+	0x90,
+	0x6c,
+	0x38,
+	0xed,
+	0xf0,
+	0xa3,
+	0xee,
+	0xf0,
+	0xe5,
+	0x12,
+	0x24,
+	0xfb,
+	0xf8,
+	0x90,
+	0x6c,
+	0x40,
+	0xe6,
+	0xf0,
+	0x08,
+	0xa3,
+	0xe6,
+	0xf0,
+	0xa8,
+	0x12,
+	0x08,
+	0x08,
+	0x90,
+	0x6c,
+	0x48,
+	0xe6,
+	0xf0,
+	0x08,
+	0xa3,
+	0xe6,
+	0xf0,
+	0xc0,
+	0x06,
+	0xc0,
+	0x05,
+	0xc0,
+	0x04,
+	0xc0,
+	0x03,
+	0x12,
+	0x81,
+	0x6a,
+	0xd0,
+	0x03,
+	0xd0,
+	0x04,
+	0xe5,
+	0x12,
+	0x24,
+	0xf9,
+	0xf8,
+	0x90,
+	0x6c,
+	0x38,
+	0xe6,
+	0xf0,
+	0x08,
+	0xa3,
+	0xe6,
+	0xf0,
+	0xa8,
+	0x12,
+	0x08,
+	0x08,
+	0x90,
+	0x6c,
+	0x40,
+	0xe6,
+	0xf0,
+	0x08,
+	0xa3,
+	0xe6,
+	0xf0,
+	0x90,
+	0x6c,
+	0x48,
+	0xeb,
+	0xf0,
+	0xa3,
+	0xec,
+	0xf0,
+	0xc0,
+	0x04,
+	0xc0,
+	0x03,
+	0x12,
+	0x81,
+	0x6a,
+	0xd0,
+	0x03,
+	0xd0,
+	0x04,
+	0xd0,
+	0x05,
+	0xd0,
+	0x06,
+	0x90,
+	0x6c,
+	0x38,
+	0xed,
+	0xf0,
+	0xa3,
+	0xee,
+	0xf0,
+	0xe5,
+	0x12,
+	0x24,
+	0xfd,
+	0xf8,
+	0xe6,
+	0x25,
+	0xe0,
+	0xff,
+	0x90,
+	0x6c,
+	0x3c,
+	0xf0,
+	0x90,
+	0x6c,
+	0x40,
+	0xeb,
+	0xf0,
+	0xa3,
+	0xec,
+	0xf0,
+	0x90,
+	0x6c,
+	0x44,
+	0xef,
+	0xf0,
+	0x12,
+	0x82,
+	0xbb,
+	0xe5,
+	0x12,
+	0x24,
+	0x04,
+	0xf8,
+	0x90,
+	0x6c,
+	0x38,
+	0xe6,
+	0xf0,
+	0x08,
+	0xa3,
+	0xe6,
+	0xf0,
+	0xe5,
+	0x12,
+	0x24,
+	0xfd,
+	0xf8,
+	0x90,
+	0x6c,
+	0x3c,
+	0xe6,
+	0x04,
+	0xf0,
+	0xe5,
+	0x12,
+	0x24,
+	0xf9,
+	0xf8,
+	0x90,
+	0x6c,
+	0x40,
+	0xe6,
+	0xf0,
+	0x08,
+	0xa3,
+	0xe6,
+	0xf0,
+	0xe5,
+	0x12,
+	0x24,
+	0xfd,
+	0xf8,
+	0x90,
+	0x6c,
+	0x44,
+	0xe6,
+	0xf0,
+	0x12,
+	0x84,
+	0x99,
+	0xe5,
+	0x12,
+	0x24,
+	0xfd,
+	0xf8,
+	0x90,
+	0x6c,
+	0x3c,
+	0xe6,
+	0xf0,
+	0xe5,
+	0x12,
+	0x24,
+	0xf1,
+	0xf8,
+	0x90,
+	0x6c,
+	0x40,
+	0xe6,
+	0xf0,
+	0x08,
+	0xa3,
+	0xe6,
+	0xf0,
+	0x12,
+	0x85,
+	0x37,
+	0x85,
+	0x12,
+	0x81,
+	0xd0,
+	0x12,
+	0x22,
+	0xc0,
+	0x12,
+	0x85,
+	0x81,
+	0x12,
+	0x05,
+	0x81,
+	0x05,
+	0x81,
+	0xaf,
+	0x82,
+	0x8f,
+	0x05,
+	0x7e,
+	0x00,
+	0xe5,
+	0x12,
+	0x24,
+	0xf4,
+	0xf8,
+	0xed,
+	0x26,
+	0xfb,
+	0xee,
+	0x08,
+	0x36,
+	0xfc,
+	0xa8,
+	0x12,
+	0x08,
+	0xa6,
+	0x03,
+	0x08,
+	0xa6,
+	0x04,
+	0xa8,
+	0x12,
+	0x08,
+	0xed,
+	0x26,
+	0xfb,
+	0xee,
+	0x08,
+	0x36,
+	0xfc,
+	0x8b,
+	0x02,
+	0xed,
+	0x2a,
+	0xfd,
+	0xee,
+	0x3c,
+	0xfe,
+	0x90,
+	0x6c,
+	0x38,
+	0xea,
+	0xf0,
+	0xa3,
+	0xec,
+	0xf0,
+	0x90,
+	0x6c,
+	0x3c,
+	0xef,
+	0xf0,
+	0xc0,
+	0x07,
+	0xc0,
+	0x06,
+	0xc0,
+	0x05,
+	0xc0,
+	0x04,
+	0xc0,
+	0x02,
+	0x12,
+	0x84,
+	0xe5,
+	0xd0,
+	0x02,
+	0xd0,
+	0x04,
+	0xd0,
+	0x05,
+	0xd0,
+	0x06,
+	0xe5,
+	0x12,
+	0x24,
+	0xf8,
+	0xf8,
+	0x90,
+	0x6c,
+	0x38,
+	0xe6,
+	0xf0,
+	0x08,
+	0xa3,
+	0xe6,
+	0xf0,
+	0x90,
+	0x6c,
+	0x40,
+	0xed,
+	0xf0,
+	0xa3,
+	0xee,
+	0xf0,
+	0xc0,
+	0x06,
+	0xc0,
+	0x05,
+	0xc0,
+	0x04,
+	0xc0,
+	0x02,
+	0x12,
+	0x85,
+	0x37,
+	0xd0,
+	0x02,
+	0xd0,
+	0x04,
+	0xd0,
+	0x05,
+	0xd0,
+	0x06,
+	0xd0,
+	0x07,
+	0x90,
+	0x6c,
+	0x38,
+	0xea,
+	0xf0,
+	0xa3,
+	0xec,
+	0xf0,
+	0xef,
+	0x2f,
+	0xfb,
+	0x90,
+	0x6c,
+	0x3c,
+	0xf0,
+	0xe5,
+	0x12,
+	0x24,
+	0xfa,
+	0xf8,
+	0x90,
+	0x6c,
+	0x40,
+	0xe6,
+	0xf0,
+	0x08,
+	0xa3,
+	0xe6,
+	0xf0,
+	0x90,
+	0x6c,
+	0x44,
+	0xef,
+	0xf0,
+	0xc0,
+	0x07,
+	0xc0,
+	0x06,
+	0xc0,
+	0x05,
+	0xc0,
+	0x04,
+	0xc0,
+	0x03,
+	0xc0,
+	0x02,
+	0x12,
+	0x84,
+	0x99,
+	0xd0,
+	0x02,
+	0xd0,
+	0x03,
+	0xd0,
+	0x04,
+	0xd0,
+	0x05,
+	0xd0,
+	0x06,
+	0xd0,
+	0x07,
+	0x90,
+	0x6c,
+	0x3c,
+	0xef,
+	0xf0,
+	0xe5,
+	0x12,
+	0x24,
+	0xf4,
+	0xf8,
+	0x90,
+	0x6c,
+	0x40,
+	0xe6,
+	0xf0,
+	0x08,
+	0xa3,
+	0xe6,
+	0xf0,
+	0xc0,
+	0x07,
+	0xc0,
+	0x06,
+	0xc0,
+	0x05,
+	0xc0,
+	0x04,
+	0xc0,
+	0x03,
+	0xc0,
+	0x02,
+	0x12,
+	0x85,
+	0x37,
+	0x12,
+	0x84,
+	0xe5,
+	0xd0,
+	0x02,
+	0xd0,
+	0x03,
+	0xd0,
+	0x04,
+	0xd0,
+	0x05,
+	0xd0,
+	0x06,
+	0xe5,
+	0x12,
+	0x24,
+	0xf6,
+	0xf8,
+	0x90,
+	0x6c,
+	0x38,
+	0xe6,
+	0xf0,
+	0x08,
+	0xa3,
+	0xe6,
+	0xf0,
+	0x90,
+	0x6c,
+	0x40,
+	0xed,
+	0xf0,
+	0xa3,
+	0xee,
+	0xf0,
+	0xc0,
+	0x04,
+	0xc0,
+	0x03,
+	0xc0,
+	0x02,
+	0x12,
+	0x85,
+	0x37,
+	0xd0,
+	0x02,
+	0xd0,
+	0x03,
+	0xd0,
+	0x04,
+	0x90,
+	0x6c,
+	0x38,
+	0xea,
+	0xf0,
+	0xa3,
+	0xec,
+	0xf0,
+	0x90,
+	0x6c,
+	0x3c,
+	0xeb,
+	0xf0,
+	0xe5,
+	0x12,
+	0x24,
+	0xfa,
+	0xf8,
+	0x90,
+	0x6c,
+	0x40,
+	0xe6,
+	0xf0,
+	0x08,
+	0xa3,
+	0xe6,
+	0xf0,
+	0xc0,
+	0x04,
+	0xc0,
+	0x02,
+	0x12,
+	0x84,
+	0x99,
+	0xd0,
+	0x02,
+	0xd0,
+	0x04,
+	0xd0,
+	0x07,
+	0x90,
+	0x6c,
+	0x3c,
+	0xef,
+	0xf0,
+	0xa8,
+	0x12,
+	0x08,
+	0x90,
+	0x6c,
+	0x40,
+	0xe6,
+	0xf0,
+	0x08,
+	0xa3,
+	0xe6,
+	0xf0,
+	0xc0,
+	0x07,
+	0xc0,
+	0x04,
+	0xc0,
+	0x02,
+	0x12,
+	0x85,
+	0x37,
+	0xd0,
+	0x02,
+	0xd0,
+	0x04,
+	0xd0,
+	0x07,
+	0xc0,
+	0x07,
+	0xc0,
+	0x04,
+	0xc0,
+	0x02,
+	0xe5,
+	0x12,
+	0x24,
+	0xf4,
+	0xf8,
+	0xe6,
+	0xc0,
+	0xe0,
+	0x08,
+	0xe6,
+	0xc0,
+	0xe0,
+	0xc0,
+	0x02,
+	0xc0,
+	0x04,
+	0xa8,
+	0x12,
+	0x08,
+	0xe6,
+	0xc0,
+	0xe0,
+	0x08,
+	0xe6,
+	0xc0,
+	0xe0,
+	0xe5,
+	0x12,
+	0x24,
+	0xf4,
+	0xf8,
+	0xe6,
+	0xc0,
+	0xe0,
+	0x08,
+	0xe6,
+	0xc0,
+	0xe0,
+	0xe5,
+	0x12,
+	0x24,
+	0xfa,
+	0xf8,
+	0xe6,
+	0xc0,
+	0xe0,
+	0x08,
+	0xe6,
+	0xc0,
+	0xe0,
+	0xe5,
+	0x12,
+	0x24,
+	0xfc,
+	0xf8,
+	0xe6,
+	0xc0,
+	0xe0,
+	0x08,
+	0xe6,
+	0xc0,
+	0xe0,
+	0xc0,
+	0x07,
+	0x75,
+	0x82,
+	0x00,
+	0x12,
+	0x93,
+	0x2f,
+	0xe5,
+	0x81,
+	0x24,
+	0xf3,
+	0xf5,
+	0x81,
+	0xd0,
+	0x02,
+	0xd0,
+	0x04,
+	0xd0,
+	0x07,
+	0xe5,
+	0x12,
+	0x24,
+	0xf2,
+	0xf8,
+	0xe6,
+	0xc0,
+	0xe0,
+	0x08,
+	0xe6,
+	0xc0,
+	0xe0,
+	0xc0,
+	0x02,
+	0xc0,
+	0x04,
+	0xa8,
+	0x12,
+	0x08,
+	0xe6,
+	0xc0,
+	0xe0,
+	0x08,
+	0xe6,
+	0xc0,
+	0xe0,
+	0xe5,
+	0x12,
+	0x24,
+	0xf4,
+	0xf8,
+	0xe6,
+	0xc0,
+	0xe0,
+	0x08,
+	0xe6,
+	0xc0,
+	0xe0,
+	0xe5,
+	0x12,
+	0x24,
+	0xfa,
+	0xf8,
+	0xe6,
+	0xc0,
+	0xe0,
+	0x08,
+	0xe6,
+	0xc0,
+	0xe0,
+	0xe5,
+	0x12,
+	0x24,
+	0xfc,
+	0xf8,
+	0xe6,
+	0xc0,
+	0xe0,
+	0x08,
+	0xe6,
+	0xc0,
+	0xe0,
+	0xc0,
+	0x07,
+	0x75,
+	0x82,
+	0x01,
+	0x12,
+	0x93,
+	0x2f,
+	0xe5,
+	0x81,
+	0x24,
+	0xf3,
+	0x85,
+	0x12,
+	0x81,
+	0xd0,
+	0x12,
+	0x22,
+	0xc0,
+	0x12,
+	0x85,
+	0x81,
+	0x12,
+	0xc0,
+	0x82,
+	0xe5,
+	0x81,
+	0x24,
+	0x07,
+	0xf5,
+	0x81,
+	0xa8,
+	0x12,
+	0x08,
+	0x86,
+	0x05,
+	0x7e,
+	0x00,
+	0xe5,
+	0x12,
+	0x24,
+	0xf4,
+	0xf8,
+	0xed,
+	0x26,
+	0xfb,
+	0xee,
+	0x08,
+	0x36,
+	0xfc,
+	0xed,
+	0x2b,
+	0xfd,
+	0xee,
+	0x3c,
+	0xfe,
+	0xe5,
+	0x12,
+	0x24,
+	0x07,
+	0xf8,
+	0xa6,
+	0x05,
+	0x08,
+	0xa6,
+	0x06,
+	0xe5,
+	0x12,
+	0x24,
+	0xf6,
+	0xf8,
+	0x90,
+	0x6c,
+	0x38,
+	0xe6,
+	0xf0,
+	0x08,
+	0xa3,
+	0xe6,
+	0xf0,
+	0xa8,
+	0x12,
+	0x08,
+	0x90,
+	0x6c,
+	0x3c,
+	0xe6,
+	0xf0,
+	0x90,
+	0x6c,
+	0x40,
+	0xeb,
+	0xf0,
+	0xa3,
+	0xec,
+	0xf0,
+	0xc0,
+	0x04,
+	0xc0,
+	0x03,
+	0x12,
+	0x85,
+	0x37,
+	0xe5,
+	0x12,
+	0x24,
+	0xf4,
+	0xf8,
+	0x90,
+	0x6c,
+	0x38,
+	0xe6,
+	0xf0,
+	0x08,
+	0xa3,
+	0xe6,
+	0xf0,
+	0x12,
+	0x84,
+	0xe5,
+	0xa8,
+	0x12,
+	0x08,
+	0xe6,
+	0x25,
+	0xe0,
+	0x90,
+	0x6c,
+	0x3c,
+	0xf0,
+	0xe5,
+	0x12,
+	0x24,
+	0xfa,
+	0xf8,
+	0x90,
+	0x6c,
+	0x40,
+	0xe6,
+	0xf0,
+	0x08,
+	0xa3,
+	0xe6,
+	0xf0,
+	0xa8,
+	0x12,
+	0x08,
+	0x90,
+	0x6c,
+	0x44,
+	0xe6,
+	0xf0,
+	0x12,
+	0x84,
+	0x99,
+	0xd0,
+	0x03,
+	0xd0,
+	0x04,
+	0xe5,
+	0x12,
+	0x24,
+	0x07,
+	0xf8,
+	0x86,
+	0x02,
+	0x08,
+	0xe6,
+	0xca,
+	0x25,
+	0xe0,
+	0xca,
+	0x33,
+	0xca,
+	0x25,
+	0xe0,
+	0xca,
+	0x33,
+	0x24,
+	0x60,
+	0xfe,
+	0x8a,
+	0x82,
+	0x8e,
+	0x83,
+	0x74,
+	0x01,
+	0xf0,
+	0xa3,
+	0xe4,
+	0xf0,
+	0xa3,
+	0xf0,
+	0xa3,
+	0xf0,
+	0x90,
+	0x6c,
+	0x38,
+	0xeb,
+	0xf0,
+	0xa3,
+	0xec,
+	0xf0,
+	0xa8,
+	0x12,
+	0x08,
+	0x90,
+	0x6c,
+	0x3c,
+	0xe6,
+	0xf0,
+	0xc0,
+	0x04,
+	0xc0,
+	0x03,
+	0x12,
+	0x84,
+	0xe5,
+	0xa8,
+	0x12,
+	0x08,
+	0x90,
+	0x6c,
+	0x3c,
+	0xe6,
+	0x04,
+	0xf0,
+	0xa8,
+	0x12,
+	0x08,
+	0x90,
+	0x6c,
+	0x44,
+	0xe6,
+	0xf0,
+	0x12,
+	0x84,
+	0x99,
+	0xd0,
+	0x03,
+	0xd0,
+	0x04,
+	0xa8,
+	0x12,
+	0x08,
+	0xe6,
+	0x14,
+	0xfe,
+	0xee,
+	0x30,
+	0xe7,
+	0x03,
+	0x02,
+	0x99,
+	0x1a,
+	0xee,
+	0xfa,
+	0x33,
+	0x95,
+	0xe0,
+	0xfd,
+	0xe5,
+	0x12,
+	0x24,
+	0xf8,
+	0xf8,
+	0xea,
+	0x26,
+	0xfa,
+	0xed,
+	0x08,
+	0x36,
+	0xca,
+	0x25,
+	0xe0,
+	0xca,
+	0x33,
+	0xca,
+	0x25,
+	0xe0,
+	0xca,
+	0x33,
+	0x24,
+	0x60,
+	0xfd,
+	0x8a,
+	0x82,
+	0x8d,
+	0x83,
+	0xe5,
+	0x12,
+	0x24,
+	0x03,
+	0xf8,
+	0xe0,
+	0xf6,
+	0xa3,
+	0xe0,
+	0x08,
+	0xf6,
+	0xa3,
+	0xe0,
+	0x08,
+	0xf6,
+	0xa3,
+	0xe0,
+	0x08,
+	0xf6,
+	0xa8,
+	0x12,
+	0x08,
+	0x08,
+	0x76,
+	0x1f,
+	0xa8,
+	0x12,
+	0x08,
+	0x08,
+	0xe6,
+	0x30,
+	0xe7,
+	0x03,
+	0x02,
+	0x99,
+	0x16,
+	0xc0,
+	0x06,
+	0xc0,
+	0x06,
+	0xc0,
+	0x04,
+	0xc0,
+	0x03,
+	0xc0,
+	0x03,
+	0xc0,
+	0x04,
+	0xe5,
+	0x12,
+	0x24,
+	0x07,
+	0xf8,
+	0xe6,
+	0xc0,
+	0xe0,
+	0x08,
+	0xe6,
+	0xc0,
+	0xe0,
+	0xc0,
+	0x03,
+	0xc0,
+	0x04,
+	0xc0,
+	0x03,
+	0xc0,
+	0x04,
+	0xe5,
+	0x12,
+	0x24,
+	0xfa,
+	0xf8,
+	0xe6,
+	0xc0,
+	0xe0,
+	0x08,
+	0xe6,
+	0xc0,
+	0xe0,
+	0xe5,
+	0x12,
+	0x24,
+	0xfc,
+	0xf8,
+	0xe6,
+	0xc0,
+	0xe0,
+	0x08,
+	0xe6,
+	0xc0,
+	0xe0,
+	0xa8,
+	0x12,
+	0x08,
+	0xe6,
+	0xc0,
+	0xe0,
+	0x75,
+	0x82,
+	0x00,
+	0x12,
+	0x93,
+	0x2f,
+	0xe5,
+	0x81,
+	0x24,
+	0xf3,
+	0xf5,
+	0x81,
+	0xd0,
+	0x03,
+	0xd0,
+	0x04,
+	0xd0,
+	0x06,
+	0xa8,
+	0x12,
+	0x08,
+	0x08,
+	0x86,
+	0xf0,
+	0x05,
+	0xf0,
+	0x7a,
+	0x01,
+	0x7d,
+	0x00,
+	0x7e,
+	0x00,
+	0x7f,
+	0x00,
+	0x80,
+	0x0c,
+	0xea,
+	0x2a,
+	0xfa,
+	0xed,
+	0x33,
+	0xfd,
+	0xee,
+	0x33,
+	0xfe,
+	0xef,
+	0x33,
+	0xff,
+	0xd5,
+	0xf0,
+	0xf1,
+	0xe5,
+	0x12,
+	0x24,
+	0x03,
+	0xf8,
+	0xe6,
+	0x52,
+	0x02,
+	0x08,
+	0xe6,
+	0x52,
+	0x05,
+	0x08,
+	0xe6,
+	0x52,
+	0x06,
+	0x08,
+	0xe6,
+	0x52,
+	0x07,
+	0xea,
+	0x4d,
+	0x4e,
+	0x4f,
+	0xd0,
+	0x06,
+	0x60,
+	0x56,
+	0xc0,
+	0x06,
+	0xc0,
+	0x04,
+	0xc0,
+	0x03,
+	0xc0,
+	0x03,
+	0xc0,
+	0x04,
+	0xe5,
+	0x12,
+	0x24,
+	0x07,
+	0xf8,
+	0xe6,
+	0xc0,
+	0xe0,
+	0x08,
+	0xe6,
+	0xc0,
+	0xe0,
+	0xc0,
+	0x03,
+	0xc0,
+	0x04,
+	0xe5,
+	0x12,
+	0x24,
+	0xf4,
+	0xf8,
+	0xe6,
+	0xc0,
+	0xe0,
+	0x08,
+	0xe6,
+	0xc0,
+	0xe0,
+	0xe5,
+	0x12,
+	0x24,
+	0xfa,
+	0xf8,
+	0xe6,
+	0xc0,
+	0xe0,
+	0x08,
+	0xe6,
+	0xc0,
+	0xe0,
+	0xe5,
+	0x12,
+	0x24,
+	0xfc,
+	0xf8,
+	0xe6,
+	0xc0,
+	0xe0,
+	0x08,
+	0xe6,
+	0xc0,
+	0xe0,
+	0xa8,
+	0x12,
+	0x08,
+	0xe6,
+	0xc0,
+	0xe0,
+	0x75,
+	0x82,
+	0x00,
+	0x12,
+	0x93,
+	0x2f,
+	0xe5,
+	0x81,
+	0x24,
+	0xf3,
+	0xf5,
+	0x81,
+	0xd0,
+	0x03,
+	0xd0,
+	0x04,
+	0xd0,
+	0x06,
+	0xa8,
+	0x12,
+	0x08,
+	0x08,
+	0x16,
+	0x02,
+	0x98,
+	0x20,
+	0x1e,
+	0x02,
+	0x97,
+	0xde,
+	0xe5,
+	0x12,
+	0x24,
+	0xf2,
+	0xf8,
+	0xe6,
+	0xc0,
+	0xe0,
+	0x08,
+	0xe6,
+	0xc0,
+	0xe0,
+	0xe5,
+	0x12,
+	0x24,
+	0x07,
+	0xf8,
+	0xe6,
+	0xc0,
+	0xe0,
+	0x08,
+	0xe6,
+	0xc0,
+	0xe0,
+	0xc0,
+	0x03,
+	0xc0,
+	0x04,
+	0xc0,
+	0x03,
+	0xc0,
+	0x04,
+	0xe5,
+	0x12,
+	0x24,
+	0xfa,
+	0xf8,
+	0xe6,
+	0xc0,
+	0xe0,
+	0x08,
+	0xe6,
+	0xc0,
+	0xe0,
+	0xe5,
+	0x12,
+	0x24,
+	0xfc,
+	0xf8,
+	0xe6,
+	0xc0,
+	0xe0,
+	0x08,
+	0xe6,
+	0xc0,
+	0xe0,
+	0xa8,
+	0x12,
+	0x08,
+	0xe6,
+	0xc0,
+	0xe0,
+	0x75,
+	0x82,
+	0x01,
+	0x12,
+	0x93,
+	0x2f,
+	0xe5,
+	0x81,
+	0x24,
+	0xf3,
+	0x85,
+	0x12,
+	0x81,
+	0xd0,
+	0x12,
+	0x22,
+	0xc2,
+	0xaf,
+	0x90,
+	0x00,
+	0x01,
+	0x22,
+	0xc0,
+	0xe0,
+	0xc0,
+	0x82,
+	0xc0,
+	0x83,
+	0xc0,
+	0xd0,
+	0x75,
+	0xd0,
+	0x08,
+	0x90,
+	0x69,
+	0xd9,
+	0xe0,
+	0x24,
+	0x01,
+	0xf0,
+	0x90,
+	0x69,
+	0xd9,
+	0xe0,
+	0xff,
+	0x90,
+	0x69,
+	0xd8,
+	0xe0,
+	0xfe,
+	0xc3,
+	0xef,
+	0x9e,
+	0x40,
+	0x0a,
+	0xc2,
+	0x8c,
+	0x90,
+	0x69,
+	0xe1,
+	0x74,
+	0x01,
+	0xf0,
+	0x80,
+	0x0b,
+	0x90,
+	0x30,
+	0x31,
+	0xe0,
+	0xff,
+	0x74,
+	0xff,
+	0xc3,
+	0x9f,
+	0xf5,
+	0x8c,
+	0xd0,
+	0xd0,
+	0xd0,
+	0x83,
+	0xd0,
+	0x82,
+	0xd0,
+	0xe0,
+	0x32,
+	0xc0,
+	0xe0,
+	0xc0,
+	0x82,
+	0xc0,
+	0x83,
+	0xc0,
+	0xd0,
+	0x75,
+	0xd0,
+	0x08,
+	0x90,
+	0x69,
+	0xdb,
+	0xe0,
+	0x24,
+	0x01,
+	0xf0,
+	0x90,
+	0x69,
+	0xdb,
+	0xe0,
+	0xff,
+	0x90,
+	0x69,
+	0xda,
+	0xe0,
+	0xfe,
+	0xc3,
+	0xef,
+	0x9e,
+	0x50,
+	0x03,
+	0x02,
+	0x9a,
+	0x53,
+	0x90,
+	0x6c,
+	0x04,
+	0xe0,
+	0xff,
+	0x60,
+	0x53,
+	0x90,
+	0x69,
+	0xf4,
+	0xe0,
+	0xff,
+	0x60,
+	0x1c,
+	0x90,
+	0x69,
+	0xf4,
+	0xe4,
+	0xf0,
+	0x90,
+	0x6c,
+	0x08,
+	0xf0,
+	0x90,
+	0x69,
+	0xf2,
+	0xf0,
+	0x90,
+	0x69,
+	0xef,
+	0xf0,
+	0x90,
+	0x69,
+	0xf1,
+	0xe4,
+	0xf0,
+	0x90,
+	0x30,
+	0x07,
+	0xf0,
+	0x80,
+	0x24,
+	0x90,
+	0x6c,
+	0x08,
+	0xe0,
+	0xff,
+	0x70,
+	0x15,
+	0x90,
+	0x69,
+	0xf2,
+	0xe0,
+	0xff,
+	0x70,
+	0x0e,
+	0x90,
+	0x69,
+	0xef,
+	0xe0,
+	0xff,
+	0x70,
+	0x07,
+	0x90,
+	0x69,
+	0xf1,
+	0xe0,
+	0x24,
+	0x01,
+	0xf0,
+	0x90,
+	0x30,
+	0x07,
+	0xe0,
+	0xff,
+	0x44,
+	0x02,
+	0xf0,
+	0xc2,
+	0x8e,
+	0x75,
+	0xff,
+	0x01,
+	0x90,
+	0x30,
+	0x0c,
+	0xe4,
+	0xf0,
+	0x80,
+	0x20,
+	0xc2,
+	0x8e,
+	0x75,
+	0xff,
+	0x01,
+	0x90,
+	0x30,
+	0x0c,
+	0xe4,
+	0xf0,
+	0x90,
+	0x30,
+	0x02,
+	0xe0,
+	0xff,
+	0x53,
+	0x0f,
+	0x20,
+	0xbf,
+	0x20,
+	0x04,
+	0x7f,
+	0x42,
+	0x80,
+	0x02,
+	0x7f,
+	0x00,
+	0x90,
+	0x30,
+	0x07,
+	0xef,
+	0xf0,
+	0x75,
+	0xf7,
+	0x01,
+	0x75,
+	0xf7,
+	0x01,
+	0x80,
+	0x0b,
+	0x90,
+	0x30,
+	0x31,
+	0xe0,
+	0xff,
+	0x74,
+	0xff,
+	0xc3,
+	0x9f,
+	0xf5,
+	0x8d,
+	0xd0,
+	0xd0,
+	0xd0,
+	0x83,
+	0xd0,
+	0x82,
+	0xd0,
+	0xe0,
+	0x32,
+	0xc0,
+	0x12,
+	0x85,
+	0x81,
+	0x12,
+	0xc0,
+	0x82,
+	0xc0,
+	0x83,
+	0xc0,
+	0xf0,
+	0xe5,
+	0x81,
+	0x24,
+	0x15,
+	0xf5,
+	0x81,
+	0xe5,
+	0x12,
+	0x24,
+	0x0e,
+	0xf9,
+	0x77,
+	0x00,
+	0xe9,
+	0x04,
+	0xf8,
+	0x76,
+	0x00,
+	0x74,
+	0x02,
+	0x29,
+	0xf8,
+	0x76,
+	0x00,
+	0x74,
+	0x03,
+	0x29,
+	0xf8,
+	0x76,
+	0x00,
+	0xe5,
+	0x12,
+	0x24,
+	0xfa,
+	0xf8,
+	0xe6,
+	0x54,
+	0x1f,
+	0x60,
+	0x24,
+	0xe5,
+	0x12,
+	0x24,
+	0xfa,
+	0xf8,
+	0x86,
+	0x03,
+	0x08,
+	0xe6,
+	0xc4,
+	0x03,
+	0xcb,
+	0xc4,
+	0x03,
+	0x54,
+	0x07,
+	0x6b,
+	0xcb,
+	0x54,
+	0x07,
+	0xcb,
+	0x6b,
+	0xcb,
+	0x30,
+	0xe2,
+	0x02,
+	0x44,
+	0xf8,
+	0xfc,
+	0x0b,
+	0xbb,
+	0x00,
+	0x20,
+	0x0c,
+	0x80,
+	0x1d,
+	0xe5,
+	0x12,
+	0x24,
+	0xfa,
+	0xf8,
+	0x86,
+	0x03,
+	0x08,
+	0xe6,
+	0xc4,
+	0x03,
+	0xcb,
+	0xc4,
+	0x03,
+	0x54,
+	0x07,
+	0x6b,
+	0xcb,
+	0x54,
+	0x07,
+	0xcb,
+	0x6b,
+	0xcb,
+	0x30,
+	0xe2,
+	0x02,
+	0x44,
+	0xf8,
+	0xfc,
+	0xe5,
+	0x12,
+	0x24,
+	0x0a,
+	0xf8,
+	0xa6,
+	0x03,
+	0x08,
+	0xa6,
+	0x04,
+	0x89,
+	0x02,
+	0xe5,
+	0x12,
+	0x24,
+	0xfc,
+	0xf8,
+	0x86,
+	0x82,
+	0x08,
+	0x86,
+	0x83,
+	0xa3,
+	0xa3,
+	0xa3,
+	0xa3,
+	0x75,
+	0x13,
+	0x40,
+	0x75,
+	0x14,
+	0x00,
+	0xc0,
+	0x02,
+	0xc0,
+	0x01,
+	0x12,
+	0xf4,
+	0x31,
+	0xc8,
+	0xe5,
+	0x12,
+	0x24,
+	0x12,
+	0xc8,
+	0xa6,
+	0x82,
+	0x08,
+	0xa6,
+	0x83,
+	0xd0,
+	0x01,
+	0xd0,
+	0x02,
+	0xe5,
+	0x12,
+	0x24,
+	0xfc,
+	0xf8,
+	0x74,
+	0x44,
+	0x26,
+	0xfe,
+	0xe4,
+	0x08,
+	0x36,
+	0xff,
+	0xe5,
+	0x12,
+	0x24,
+	0x14,
+	0xf8,
+	0xa6,
+	0x06,
+	0xef,
+	0xa2,
+	0xe7,
+	0xc6,
+	0x33,
+	0xc6,
+	0x33,
+	0xa2,
+	0xe7,
+	0xc6,
+	0x33,
+	0xc6,
+	0x33,
+	0xc6,
+	0x54,
+	0x03,
+	0x30,
+	0xe1,
+	0x02,
+	0x44,
+	0xfc,
+	0x08,
+	0xf6,
+	0xe5,
+	0x12,
+	0x24,
+	0x14,
+	0xf8,
+	0xc0,
+	0x01,
+	0xe5,
+	0x12,
+	0x24,
+	0x16,
+	0xf9,
+	0xe6,
+	0x24,
+	0xff,
+	0xf7,
+	0x08,
+	0xe6,
+	0x34,
+	0xff,
+	0x09,
+	0xf7,
+	0xd0,
+	0x01,
+	0xe5,
+	0x12,
+	0x24,
+	0x0c,
+	0xf8,
+	0xe4,
+	0xf6,
+	0x08,
+	0xf6,
+	0xe5,
+	0x12,
+	0x24,
+	0x08,
+	0xf8,
+	0xe4,
+	0xf6,
+	0x08,
+	0xf6,
+	0xe5,
+	0x12,
+	0x24,
+	0x08,
+	0xf8,
+	0xc0,
+	0x01,
+	0xe5,
+	0x12,
+	0x24,
+	0x0a,
+	0xf9,
+	0xc3,
+	0xe6,
+	0x97,
+	0x08,
+	0xe6,
+	0x64,
+	0x80,
+	0x09,
+	0x87,
+	0xf0,
+	0x63,
+	0xf0,
+	0x80,
+	0x95,
+	0xf0,
+	0xd0,
+	0x01,
+	0x40,
+	0x03,
+	0x02,
+	0x9e,
+	0x76,
+	0xc0,
+	0x02,
+	0x90,
+	0x30,
+	0x0a,
+	0xe0,
+	0xfa,
+	0xba,
+	0xdb,
+	0x02,
+	0x80,
+	0x04,
+	0xd0,
+	0x02,
+	0x80,
+	0x08,
+	0xd0,
+	0x02,
+	0x90,
+	0x30,
+	0x02,
+	0x74,
+	0x4e,
+	0xf0,
+	0x8a,
+	0x03,
+	0x7c,
+	0x00,
+	0x7f,
+	0x40,
+	0x8b,
+	0x82,
+	0x8c,
+	0x83,
+	0x8f,
+	0xf0,
+	0x12,
+	0xf4,
+	0x15,
+	0xfb,
+	0xa3,
+	0x12,
+	0xf4,
+	0x15,
+	0xfc,
+	0xa3,
+	0x12,
+	0xf4,
+	0x15,
+	0xff,
+	0xa3,
+	0x12,
+	0xf4,
+	0x15,
+	0xfe,
+	0x90,
+	0x40,
+	0x10,
+	0xeb,
+	0xf0,
+	0xa3,
+	0xec,
+	0xf0,
+	0xa3,
+	0xef,
+	0xf0,
+	0xa3,
+	0xee,
+	0xf0,
+	0x90,
+	0x42,
+	0x41,
+	0x74,
+	0x82,
+	0xf0,
+	0x90,
+	0x40,
+	0x00,
+	0xe0,
+	0x70,
+	0xfa,
+	0xc0,
+	0x02,
+	0x7a,
+	0x80,
+	0x7d,
+	0x6b,
+	0x53,
+	0x05,
+	0x0f,
+	0xe4,
+	0xfe,
+	0xc3,
+	0x13,
+	0xff,
+	0xee,
+	0x13,
+	0xfe,
+	0xed,
+	0x13,
+	0xfd,
+	0xea,
+	0x13,
+	0xfa,
+	0xef,
+	0xc3,
+	0x13,
+	0xee,
+	0x13,
+	0xed,
+	0x13,
+	0xfd,
+	0xea,
+	0x13,
+	0x90,
+	0x40,
+	0x04,
+	0xf0,
+	0xa3,
+	0xed,
+	0xf0,
+	0xe5,
+	0x12,
+	0x24,
+	0x12,
+	0xf8,
+	0x86,
+	0x07,
+	0x90,
+	0x40,
+	0x0a,
+	0xef,
+	0xf0,
+	0x7a,
+	0x00,
+	0x7d,
+	0x6b,
+	0x53,
+	0x05,
+	0x0f,
+	0xe4,
+	0xfe,
+	0xc3,
+	0x13,
+	0xff,
+	0xee,
+	0x13,
+	0xfe,
+	0xed,
+	0x13,
+	0xfd,
+	0xea,
+	0x13,
+	0xfa,
+	0xef,
+	0xc3,
+	0x13,
+	0xee,
+	0x13,
+	0xed,
+	0x13,
+	0xfd,
+	0xea,
+	0x13,
+	0x90,
+	0x40,
+	0x08,
+	0xf0,
+	0xa3,
+	0xed,
+	0xf0,
+	0x7a,
+	0x40,
+	0x7d,
+	0x69,
+	0x53,
+	0x05,
+	0x0f,
+	0xe4,
+	0xfe,
+	0xc3,
+	0x13,
+	0xff,
+	0xee,
+	0x13,
+	0xfe,
+	0xed,
+	0x13,
+	0xfd,
+	0xea,
+	0x13,
+	0xfa,
+	0xef,
+	0xc3,
+	0x13,
+	0xff,
+	0xee,
+	0x13,
+	0xfe,
+	0xed,
+	0x13,
+	0xfd,
+	0xea,
+	0x13,
+	0x90,
+	0x40,
+	0x0c,
+	0xf0,
+	0xa3,
+	0xed,
+	0xf0,
+	0xe5,
+	0x12,
+	0x24,
+	0x04,
+	0xf8,
+	0xe4,
+	0xf6,
+	0x08,
+	0xf6,
+	0xd0,
+	0x02,
+	0xe5,
+	0x12,
+	0x24,
+	0x04,
+	0xf8,
+	0xc0,
+	0x01,
+	0xe5,
+	0x12,
+	0x24,
+	0x14,
+	0xf9,
+	0xc3,
+	0xe6,
+	0x97,
+	0x08,
+	0xe6,
+	0x64,
+	0x80,
+	0x09,
+	0x87,
+	0xf0,
+	0x63,
+	0xf0,
+	0x80,
+	0x95,
+	0xf0,
+	0xd0,
+	0x01,
+	0x40,
+	0x03,
+	0x02,
+	0x9d,
+	0x73,
+	0xe5,
+	0x12,
+	0x24,
+	0x06,
+	0xf8,
+	0xe4,
+	0xf6,
+	0x08,
+	0xf6,
+	0xe5,
+	0x12,
+	0x24,
+	0x06,
+	0xf8,
+	0xc3,
+	0xe6,
+	0x94,
+	0x40,
+	0x08,
+	0xe6,
+	0x64,
+	0x80,
+	0x94,
+	0x80,
+	0x40,
+	0x03,
+	0x02,
+	0x9d,
+	0x2b,
+	0xc0,
+	0x02,
+	0xe5,
+	0x12,
+	0x24,
+	0x04,
+	0xf8,
+	0x86,
+	0x07,
+	0x08,
+	0xe6,
+	0x54,
+	0x03,
+	0xa2,
+	0xe0,
+	0xcf,
+	0x13,
+	0xcf,
+	0x13,
+	0xa2,
+	0xe0,
+	0xcf,
+	0x13,
+	0xcf,
+	0x13,
+	0xcf,
+	0xfe,
+	0xe5,
+	0x12,
+	0x24,
+	0x06,
+	0xf8,
+	0xef,
+	0x26,
+	0xfa,
+	0xee,
+	0x08,
+	0x36,
+	0xfd,
+	0xe5,
+	0x12,
+	0x24,
+	0xfc,
+	0xf8,
+	0xc3,
+	0xea,
+	0x96,
+	0xed,
+	0x64,
+	0x80,
+	0x08,
+	0x86,
+	0xf0,
+	0x63,
+	0xf0,
+	0x80,
+	0x95,
+	0xf0,
+	0xd0,
+	0x02,
+	0x50,
+	0x48,
+	0xc0,
+	0x02,
+	0xe5,
+	0x12,
+	0x24,
+	0x06,
+	0xf8,
+	0xe6,
+	0x24,
+	0x80,
+	0xfa,
+	0x08,
+	0xe6,
+	0x34,
+	0x6b,
+	0xfd,
+	0xe5,
+	0x12,
+	0x24,
+	0x06,
+	0xf8,
+	0xef,
+	0x26,
+	0xfb,
+	0xee,
+	0x08,
+	0x36,
+	0xfc,
+	0xa8,
+	0x12,
+	0x08,
+	0xeb,
+	0x26,
+	0xfb,
+	0xec,
+	0x08,
+	0x36,
+	0xfc,
+	0x08,
+	0x86,
+	0x07,
+	0x8b,
+	0x82,
+	0x8c,
+	0x83,
+	0x8f,
+	0xf0,
+	0x12,
+	0xf4,
+	0x15,
+	0xfb,
+	0x8a,
+	0x82,
+	0x8d,
+	0x83,
+	0xf0,
+	0xe5,
+	0x12,
+	0x24,
+	0x06,
+	0xf8,
+	0x06,
+	0xb6,
+	0x00,
+	0x02,
+	0x08,
+	0x06,
+	0xd0,
+	0x02,
+	0x02,
+	0x9c,
+	0x91,
+	0xe5,
+	0x12,
+	0x24,
+	0x04,
+	0xf8,
+	0xc0,
+	0x01,
+	0xe5,
+	0x12,
+	0x24,
+	0x16,
+	0xf9,
+	0x86,
+	0xf0,
+	0xe7,
+	0xb5,
+	0xf0,
+	0x0a,
+	0x08,
+	0x86,
+	0xf0,
+	0x09,
+	0xe7,
+	0xb5,
+	0xf0,
+	0x02,
+	0x80,
+	0x04,
+	0xd0,
+	0x01,
+	0x80,
+	0x0e,
+	0xd0,
+	0x01,
+	0x90,
+	0x42,
+	0x41,
+	0x74,
+	0x84,
+	0xf0,
+	0x90,
+	0x40,
+	0x00,
+	0xe0,
+	0x70,
+	0xfa,
+	0x90,
+	0x42,
+	0x41,
+	0x74,
+	0x91,
+	0xf0,
+	0x90,
+	0x40,
+	0x00,
+	0xe0,
+	0x70,
+	0xfa,
+	0xe5,
+	0x12,
+	0x24,
+	0x04,
+	0xf8,
+	0x06,
+	0xb6,
+	0x00,
+	0x02,
+	0x08,
+	0x06,
+	0x02,
+	0x9c,
+	0x66,
+	0x90,
+	0x30,
+	0x0a,
+	0xe0,
+	0xff,
+	0xbf,
+	0xdb,
+	0x06,
+	0x90,
+	0x30,
+	0x02,
+	0x74,
+	0x4f,
+	0xf0,
+	0xe5,
+	0x12,
+	0x24,
+	0xfa,
+	0xf8,
+	0xc0,
+	0x01,
+	0xe5,
+	0x12,
+	0x24,
+	0x0c,
+	0xf9,
+	0xe6,
+	0xc3,
+	0x97,
+	0xfe,
+	0x08,
+	0xe6,
+	0x09,
+	0x97,
+	0xff,
+	0xe5,
+	0x12,
+	0x24,
+	0x0c,
+	0xf8,
+	0x74,
+	0x20,
+	0x26,
+	0xfc,
+	0xe4,
+	0x08,
+	0x36,
+	0xfd,
+	0xe5,
+	0x12,
+	0x24,
+	0x18,
+	0xf8,
+	0xe5,
+	0x12,
+	0x24,
+	0xfa,
+	0xf9,
+	0xc3,
+	0xe7,
+	0x9c,
+	0x09,
+	0xe7,
+	0x64,
+	0x80,
+	0x8d,
+	0xf0,
+	0x63,
+	0xf0,
+	0x80,
+	0x95,
+	0xf0,
+	0xd0,
+	0x01,
+	0xe4,
+	0x33,
+	0xf6,
+	0xe5,
+	0x12,
+	0x24,
+	0x04,
+	0xf8,
+	0xe4,
+	0xf6,
+	0x08,
+	0xf6,
+	0xe5,
+	0x12,
+	0x24,
+	0x18,
+	0xf8,
+	0xe6,
+	0x60,
+	0x06,
+	0x8e,
+	0x05,
+	0x8f,
+	0x04,
+	0x80,
+	0x04,
+	0x7d,
+	0x20,
+	0x7c,
+	0x00,
+	0xe5,
+	0x12,
+	0x24,
+	0x04,
+	0xf8,
+	0xc3,
+	0xe6,
+	0x9d,
+	0x08,
+	0xe6,
+	0x64,
+	0x80,
+	0x8c,
+	0xf0,
+	0x63,
+	0xf0,
+	0x80,
+	0x95,
+	0xf0,
+	0x50,
+	0x51,
+	0xc0,
+	0x02,
+	0xe5,
+	0x12,
+	0x24,
+	0x0c,
+	0xf8,
+	0xc0,
+	0x01,
+	0xe5,
+	0x12,
+	0x24,
+	0x04,
+	0xf9,
+	0xe7,
+	0x26,
+	0xfa,
+	0x09,
+	0xe7,
+	0x08,
+	0x36,
+	0xfc,
+	0xd0,
+	0x01,
+	0xe5,
+	0x12,
+	0x24,
+	0xf7,
+	0xf8,
+	0xea,
+	0x26,
+	0xfa,
+	0xec,
+	0x08,
+	0x36,
+	0xfc,
+	0x08,
+	0x86,
+	0x03,
+	0xe5,
+	0x12,
+	0x24,
+	0x04,
+	0xf8,
+	0xe6,
+	0x24,
+	0x40,
+	0xf5,
+	0x82,
+	0x08,
+	0xe6,
+	0x34,
+	0x69,
+	0xf5,
+	0x83,
+	0xe0,
+	0xfd,
+	0x8a,
+	0x82,
+	0x8c,
+	0x83,
+	0x8b,
+	0xf0,
+	0x12,
+	0xf3,
+	0x29,
+	0xe5,
+	0x12,
+	0x24,
+	0x04,
+	0xf8,
+	0x06,
+	0xb6,
+	0x00,
+	0x02,
+	0x08,
+	0x06,
+	0xd0,
+	0x02,
+	0x80,
+	0x88,
+	0xe5,
+	0x12,
+	0x24,
+	0x0c,
+	0xf8,
+	0x74,
+	0x20,
+	0x26,
+	0xf6,
+	0xe4,
+	0x08,
+	0x36,
+	0xf6,
+	0x7e,
+	0x03,
+	0x7f,
+	0x00,
+	0xef,
+	0x20,
+	0xe7,
+	0x12,
+	0xee,
+	0x29,
+	0xf8,
+	0x86,
+	0x05,
+	0x0d,
+	0xa6,
+	0x05,
+	0xed,
+	0x70,
+	0x07,
+	0x1e,
+	0xbe,
+	0xff,
+	0x01,
+	0x1f,
+	0x80,
+	0xea,
+	0xe5,
+	0x12,
+	0x24,
+	0x08,
+	0xf8,
+	0x06,
+	0xb6,
+	0x00,
+	0x02,
+	0x08,
+	0x06,
+	0x02,
+	0x9b,
+	0x66,
+	0x85,
+	0x12,
+	0x81,
+	0xd0,
+	0x12,
+	0x22,
+	0xc0,
+	0x12,
+	0xe5,
+	0x81,
+	0xf5,
+	0x12,
+	0x24,
+	0x08,
+	0xf5,
+	0x81,
+	0xa8,
+	0x12,
+	0x08,
+	0x08,
+	0x08,
+	0xa6,
+	0x82,
+	0x08,
+	0xa6,
+	0x83,
+	0x08,
+	0xa6,
+	0xf0,
+	0xe5,
+	0x12,
+	0x24,
+	0xfb,
+	0xf8,
+	0x86,
+	0x02,
+	0x08,
+	0x86,
+	0x03,
+	0x08,
+	0x86,
+	0x04,
+	0xe5,
+	0x12,
+	0x24,
+	0xf8,
+	0xf8,
+	0xe5,
+	0x12,
+	0x24,
+	0x06,
+	0xf9,
+	0xe6,
+	0xf7,
+	0x08,
+	0x09,
+	0xe6,
+	0xf7,
+	0x08,
+	0x09,
+	0xe6,
+	0xf7,
+	0xa8,
+	0x12,
+	0x08,
+	0xe4,
+	0xf6,
+	0x08,
+	0xf6,
+	0xa8,
+	0x12,
+	0x08,
+	0xe5,
+	0x12,
+	0x24,
+	0xf6,
+	0xf9,
+	0xc3,
+	0xe6,
+	0x97,
+	0x08,
+	0xe6,
+	0x64,
+	0x80,
+	0x09,
+	0x87,
+	0xf0,
+	0x63,
+	0xf0,
+	0x80,
+	0x95,
+	0xf0,
+	0x50,
+	0x4f,
+	0xe5,
+	0x12,
+	0x24,
+	0x03,
+	0xf8,
+	0x86,
+	0x82,
+	0x08,
+	0x86,
+	0x83,
+	0x08,
+	0x86,
+	0xf0,
+	0x12,
+	0xf4,
+	0x15,
+	0xfd,
+	0xa3,
+	0x18,
+	0x18,
+	0xa6,
+	0x82,
+	0x08,
+	0xa6,
+	0x83,
+	0x8a,
+	0x82,
+	0x8b,
+	0x83,
+	0x8c,
+	0xf0,
+	0x12,
+	0xf4,
+	0x15,
+	0xff,
+	0xa3,
+	0xaa,
+	0x82,
+	0xab,
+	0x83,
+	0xef,
+	0x62,
+	0x05,
+	0xe5,
+	0x12,
+	0x24,
+	0x06,
+	0xf8,
+	0x86,
+	0x82,
+	0x08,
+	0x86,
+	0x83,
+	0x08,
+	0x86,
+	0xf0,
+	0xed,
+	0x12,
+	0xf3,
+	0x29,
+	0xa3,
+	0x18,
+	0x18,
+	0xa6,
+	0x82,
+	0x08,
+	0xa6,
+	0x83,
+	0xa8,
+	0x12,
+	0x08,
+	0x06,
+	0xb6,
+	0x00,
+	0x02,
+	0x08,
+	0x06,
+	0x80,
+	0x98,
+	0x85,
+	0x12,
+	0x81,
+	0xd0,
+	0x12,
+	0x22,
+	0xaf,
+	0x82,
+	0x90,
+	0x30,
+	0x0a,
+	0xe0,
+	0xfe,
+	0xbe,
+	0xdb,
+	0x06,
+	0x90,
+	0x30,
+	0x02,
+	0x74,
+	0x50,
+	0xf0,
+	0x90,
+	0x63,
+	0x74,
+	0x75,
+	0xf0,
+	0x00,
+	0x12,
+	0xf4,
+	0x15,
+	0xfb,
+	0xa3,
+	0x12,
+	0xf4,
+	0x15,
+	0xfc,
+	0xa3,
+	0x12,
+	0xf4,
+	0x15,
+	0xfd,
+	0xa3,
+	0x12,
+	0xf4,
+	0x15,
+	0xfe,
+	0x90,
+	0x44,
+	0x10,
+	0xeb,
+	0xf0,
+	0xa3,
+	0xec,
+	0xf0,
+	0xa3,
+	0xed,
+	0xf0,
+	0xa3,
+	0xee,
+	0xf0,
+	0x90,
+	0x63,
+	0x70,
+	0x75,
+	0xf0,
+	0x00,
+	0x12,
+	0xf4,
+	0x15,
+	0xfb,
+	0xa3,
+	0x12,
+	0xf4,
+	0x15,
+	0xfc,
+	0xa3,
+	0x12,
+	0xf4,
+	0x15,
+	0xfd,
+	0xa3,
+	0x12,
+	0xf4,
+	0x15,
+	0xfe,
+	0x90,
+	0x44,
+	0x0c,
+	0xeb,
+	0xf0,
+	0xa3,
+	0xec,
+	0xf0,
+	0xa3,
+	0xed,
+	0xf0,
+	0xa3,
+	0xee,
+	0xf0,
+	0x90,
+	0x63,
+	0x6c,
+	0x75,
+	0xf0,
+	0x00,
+	0x12,
+	0xf4,
+	0x15,
+	0xfb,
+	0xa3,
+	0x12,
+	0xf4,
+	0x15,
+	0xfc,
+	0xa3,
+	0x12,
+	0xf4,
+	0x15,
+	0xfd,
+	0xa3,
+	0x12,
+	0xf4,
+	0x15,
+	0xfe,
+	0x90,
+	0x44,
+	0x08,
+	0xeb,
+	0xf0,
+	0xa3,
+	0xec,
+	0xf0,
+	0xa3,
+	0xed,
+	0xf0,
+	0xa3,
+	0xee,
+	0xf0,
+	0x90,
+	0x63,
+	0x68,
+	0xe0,
+	0xfb,
+	0xa3,
+	0xe0,
+	0xfc,
+	0xa3,
+	0xe0,
+	0xfd,
+	0xa3,
+	0xe0,
+	0xfe,
+	0x90,
+	0x44,
+	0x04,
+	0xeb,
+	0xf0,
+	0xa3,
+	0xec,
+	0xf0,
+	0xa3,
+	0xed,
+	0xf0,
+	0xa3,
+	0xee,
+	0xf0,
+	0x90,
+	0x69,
+	0xb4,
+	0x75,
+	0xf0,
+	0x00,
+	0x12,
+	0xf4,
+	0x15,
+	0xfb,
+	0xa3,
+	0x12,
+	0xf4,
+	0x15,
+	0xfc,
+	0xa3,
+	0x12,
+	0xf4,
+	0x15,
+	0xfd,
+	0xa3,
+	0x12,
+	0xf4,
+	0x15,
+	0xfe,
+	0x90,
+	0x44,
+	0x20,
+	0xeb,
+	0xf0,
+	0xa3,
+	0xec,
+	0xf0,
+	0xa3,
+	0xed,
+	0xf0,
+	0xa3,
+	0xee,
+	0xf0,
+	0x90,
+	0x69,
+	0xb0,
+	0xe0,
+	0xfb,
+	0xa3,
+	0xe0,
+	0xfc,
+	0xa3,
+	0xe0,
+	0xfd,
+	0xa3,
+	0xe0,
+	0xfe,
+	0x90,
+	0x44,
+	0x1c,
+	0xeb,
+	0xf0,
+	0xa3,
+	0xec,
+	0xf0,
+	0xa3,
+	0xed,
+	0xf0,
+	0xa3,
+	0xee,
+	0xf0,
+	0xbf,
+	0x02,
+	0x00,
+	0xe4,
+	0x33,
+	0xff,
+	0x70,
+	0x44,
+	0x90,
+	0x69,
+	0x84,
+	0xf5,
+	0xf0,
+	0x12,
+	0xf4,
+	0x15,
+	0xfb,
+	0xa3,
+	0x12,
+	0xf4,
+	0x15,
+	0xfc,
+	0xa3,
+	0x12,
+	0xf4,
+	0x15,
+	0xfd,
+	0xa3,
+	0x12,
+	0xf4,
+	0x15,
+	0xfe,
+	0x90,
+	0x44,
+	0x18,
+	0xeb,
+	0xf0,
+	0xa3,
+	0xec,
+	0xf0,
+	0xa3,
+	0xed,
+	0xf0,
+	0xa3,
+	0xee,
+	0xf0,
+	0x90,
+	0x69,
+	0x80,
+	0xe0,
+	0xfb,
+	0xa3,
+	0xe0,
+	0xfc,
+	0xa3,
+	0xe0,
+	0xfd,
+	0xa3,
+	0xe0,
+	0xfe,
+	0x90,
+	0x44,
+	0x14,
+	0xeb,
+	0xf0,
+	0xa3,
+	0xec,
+	0xf0,
+	0xa3,
+	0xed,
+	0xf0,
+	0xa3,
+	0xee,
+	0xf0,
+	0x80,
+	0x16,
+	0x90,
+	0x44,
+	0x18,
+	0xe4,
+	0xf0,
+	0xa3,
+	0xf0,
+	0xa3,
+	0xf0,
+	0xa3,
+	0xf0,
+	0x90,
+	0x44,
+	0x14,
+	0xf0,
+	0xa3,
+	0xe4,
+	0xf0,
+	0xa3,
+	0xf0,
+	0xa3,
+	0xf0,
+	0x90,
+	0x44,
+	0x24,
+	0xe0,
+	0xfb,
+	0xa3,
+	0xe0,
+	0xfc,
+	0xa3,
+	0xe0,
+	0xfd,
+	0xa3,
+	0xe0,
+	0xfe,
+	0x90,
+	0x65,
+	0x10,
+	0xeb,
+	0xf0,
+	0xa3,
+	0xec,
+	0xf0,
+	0xa3,
+	0xed,
+	0xf0,
+	0xa3,
+	0xee,
+	0xf0,
+	0x90,
+	0x44,
+	0x28,
+	0xe0,
+	0xfb,
+	0xa3,
+	0xe0,
+	0xfc,
+	0xa3,
+	0xe0,
+	0xfd,
+	0xa3,
+	0xe0,
+	0xfe,
+	0x90,
+	0x65,
+	0x14,
+	0xeb,
+	0xf0,
+	0xa3,
+	0xec,
+	0xf0,
+	0xa3,
+	0xed,
+	0xf0,
+	0xa3,
+	0xee,
+	0xf0,
+	0x90,
+	0x44,
+	0x2c,
+	0xe0,
+	0xfb,
+	0xa3,
+	0xe0,
+	0xfc,
+	0xa3,
+	0xe0,
+	0xfd,
+	0xa3,
+	0xe0,
+	0xfe,
+	0x90,
+	0x65,
+	0x18,
+	0xeb,
+	0xf0,
+	0xa3,
+	0xec,
+	0xf0,
+	0xa3,
+	0xed,
+	0xf0,
+	0xa3,
+	0xee,
+	0xf0,
+	0x90,
+	0x44,
+	0x30,
+	0xe0,
+	0xfb,
+	0xa3,
+	0xe0,
+	0xfc,
+	0xa3,
+	0xe0,
+	0xfd,
+	0xa3,
+	0xe0,
+	0xfe,
+	0x90,
+	0x65,
+	0x1c,
+	0xeb,
+	0xf0,
+	0xa3,
+	0xec,
+	0xf0,
+	0xa3,
+	0xed,
+	0xf0,
+	0xa3,
+	0xee,
+	0xf0,
+	0xef,
+	0x70,
+	0x21,
+	0x90,
+	0x69,
+	0x80,
+	0xe0,
+	0xfc,
+	0xa3,
+	0xe0,
+	0xfd,
+	0xa3,
+	0xe0,
+	0xfe,
+	0xa3,
+	0xe0,
+	0xff,
+	0x63,
+	0x04,
+	0x01,
+	0x90,
+	0x44,
+	0x14,
+	0xec,
+	0xf0,
+	0xa3,
+	0xed,
+	0xf0,
+	0xa3,
+	0xee,
+	0xf0,
+	0xa3,
+	0xef,
+	0xf0,
+	0x80,
+	0x0d,
+	0x90,
+	0x44,
+	0x14,
+	0x74,
+	0x01,
+	0xf0,
+	0xa3,
+	0xe4,
+	0xf0,
+	0xa3,
+	0xf0,
+	0xa3,
+	0xf0,
+	0x90,
+	0x44,
+	0x24,
+	0xe0,
+	0xfc,
+	0xa3,
+	0xe0,
+	0xfd,
+	0xa3,
+	0xe0,
+	0xfe,
+	0xa3,
+	0xe0,
+	0xff,
+	0x90,
+	0x65,
+	0x00,
+	0xec,
+	0xf0,
+	0xa3,
+	0xed,
+	0xf0,
+	0xa3,
+	0xee,
+	0xf0,
+	0xa3,
+	0xef,
+	0xf0,
+	0x90,
+	0x44,
+	0x28,
+	0xe0,
+	0xfc,
+	0xa3,
+	0xe0,
+	0xfd,
+	0xa3,
+	0xe0,
+	0xfe,
+	0xa3,
+	0xe0,
+	0xff,
+	0x90,
+	0x65,
+	0x04,
+	0xec,
+	0xf0,
+	0xa3,
+	0xed,
+	0xf0,
+	0xa3,
+	0xee,
+	0xf0,
+	0xa3,
+	0xef,
+	0xf0,
+	0x90,
+	0x44,
+	0x2c,
+	0xe0,
+	0xfc,
+	0xa3,
+	0xe0,
+	0xfd,
+	0xa3,
+	0xe0,
+	0xfe,
+	0xa3,
+	0xe0,
+	0xff,
+	0x90,
+	0x65,
+	0x08,
+	0xec,
+	0xf0,
+	0xa3,
+	0xed,
+	0xf0,
+	0xa3,
+	0xee,
+	0xf0,
+	0xa3,
+	0xef,
+	0xf0,
+	0x90,
+	0x44,
+	0x30,
+	0xe0,
+	0xfc,
+	0xa3,
+	0xe0,
+	0xfd,
+	0xa3,
+	0xe0,
+	0xfe,
+	0xa3,
+	0xe0,
+	0xff,
+	0x90,
+	0x65,
+	0x0c,
+	0xec,
+	0xf0,
+	0xa3,
+	0xed,
+	0xf0,
+	0xa3,
+	0xee,
+	0xf0,
+	0xa3,
+	0xef,
+	0xf0,
+	0x90,
+	0x30,
+	0x0a,
+	0xe0,
+	0xff,
+	0xbf,
+	0xdb,
+	0x06,
+	0x90,
+	0x30,
+	0x02,
+	0x74,
+	0x52,
+	0xf0,
+	0x22,
+	0xc0,
+	0x12,
+	0xe5,
+	0x81,
+	0xf5,
+	0x12,
+	0x24,
+	0x04,
+	0xf5,
+	0x81,
+	0xaf,
+	0x82,
+	0x90,
+	0x63,
+	0x74,
+	0x75,
+	0xf0,
+	0x00,
+	0x12,
+	0xf4,
+	0x15,
+	0xfb,
+	0xa3,
+	0x12,
+	0xf4,
+	0x15,
+	0xfc,
+	0xa3,
+	0x12,
+	0xf4,
+	0x15,
+	0xfd,
+	0xa3,
+	0x12,
+	0xf4,
+	0x15,
+	0xfe,
+	0x90,
+	0x44,
+	0x10,
+	0xeb,
+	0xf0,
+	0xa3,
+	0xec,
+	0xf0,
+	0xa3,
+	0xed,
+	0xf0,
+	0xa3,
+	0xee,
+	0xf0,
+	0x90,
+	0x63,
+	0x70,
+	0x75,
+	0xf0,
+	0x00,
+	0x12,
+	0xf4,
+	0x15,
+	0xfb,
+	0xa3,
+	0x12,
+	0xf4,
+	0x15,
+	0xfc,
+	0xa3,
+	0x12,
+	0xf4,
+	0x15,
+	0xfd,
+	0xa3,
+	0x12,
+	0xf4,
+	0x15,
+	0xfe,
+	0x90,
+	0x44,
+	0x0c,
+	0xeb,
+	0xf0,
+	0xa3,
+	0xec,
+	0xf0,
+	0xa3,
+	0xed,
+	0xf0,
+	0xa3,
+	0xee,
+	0xf0,
+	0x90,
+	0x63,
+	0x6c,
+	0x75,
+	0xf0,
+	0x00,
+	0x12,
+	0xf4,
+	0x15,
+	0xfb,
+	0xa3,
+	0x12,
+	0xf4,
+	0x15,
+	0xfc,
+	0xa3,
+	0x12,
+	0xf4,
+	0x15,
+	0xfd,
+	0xa3,
+	0x12,
+	0xf4,
+	0x15,
+	0xfe,
+	0x90,
+	0x63,
+	0x44,
+	0x75,
+	0xf0,
+	0x00,
+	0xa8,
+	0x12,
+	0x08,
+	0x12,
+	0xf4,
+	0x15,
+	0xf6,
+	0xa3,
+	0x12,
+	0xf4,
+	0x15,
+	0x08,
+	0xf6,
+	0xa3,
+	0x12,
+	0xf4,
+	0x15,
+	0x08,
+	0xf6,
+	0xa3,
+	0x12,
+	0xf4,
+	0x15,
+	0x08,
+	0xf6,
+	0xa8,
+	0x12,
+	0x08,
+	0xe6,
+	0x62,
+	0x03,
+	0x08,
+	0xe6,
+	0x62,
+	0x04,
+	0x08,
+	0xe6,
+	0x62,
+	0x05,
+	0x08,
+	0xe6,
+	0x62,
+	0x06,
+	0x90,
+	0x44,
+	0x08,
+	0xeb,
+	0xf0,
+	0xa3,
+	0xec,
+	0xf0,
+	0xa3,
+	0xed,
+	0xf0,
+	0xa3,
+	0xee,
+	0xf0,
+	0x90,
+	0x63,
+	0x68,
+	0xa8,
+	0x12,
+	0x08,
+	0xe0,
+	0xf6,
+	0xa3,
+	0xe0,
+	0x08,
+	0xf6,
+	0xa3,
+	0xe0,
+	0x08,
+	0xf6,
+	0xa3,
+	0xe0,
+	0x08,
+	0xf6,
+	0x90,
+	0x63,
+	0x40,
+	0xe0,
+	0xfa,
+	0xa3,
+	0xe0,
+	0xfc,
+	0xa3,
+	0xe0,
+	0xfd,
+	0xa3,
+	0xe0,
+	0xfe,
+	0xa8,
+	0x12,
+	0x08,
+	0xe6,
+	0x62,
+	0x02,
+	0x08,
+	0xe6,
+	0x62,
+	0x04,
+	0x08,
+	0xe6,
+	0x62,
+	0x05,
+	0x08,
+	0xe6,
+	0x62,
+	0x06,
+	0x90,
+	0x44,
+	0x04,
+	0xea,
+	0xf0,
+	0xa3,
+	0xec,
+	0xf0,
+	0xa3,
+	0xed,
+	0xf0,
+	0xa3,
+	0xee,
+	0xf0,
+	0x90,
+	0x69,
+	0xb4,
+	0x75,
+	0xf0,
+	0x00,
+	0x12,
+	0xf4,
+	0x15,
+	0xfb,
+	0xa3,
+	0x12,
+	0xf4,
+	0x15,
+	0xfc,
+	0xa3,
+	0x12,
+	0xf4,
+	0x15,
+	0xfd,
+	0xa3,
+	0x12,
+	0xf4,
+	0x15,
+	0xfe,
+	0x90,
+	0x44,
+	0x20,
+	0xeb,
+	0xf0,
+	0xa3,
+	0xec,
+	0xf0,
+	0xa3,
+	0xed,
+	0xf0,
+	0xa3,
+	0xee,
+	0xf0,
+	0x90,
+	0x69,
+	0xb0,
+	0xe0,
+	0xfb,
+	0xa3,
+	0xe0,
+	0xfc,
+	0xa3,
+	0xe0,
+	0xfd,
+	0xa3,
+	0xe0,
+	0xfe,
+	0x90,
+	0x44,
+	0x1c,
+	0xeb,
+	0xf0,
+	0xa3,
+	0xec,
+	0xf0,
+	0xa3,
+	0xed,
+	0xf0,
+	0xa3,
+	0xee,
+	0xf0,
+	0xbf,
+	0x02,
+	0x00,
+	0x40,
+	0x48,
+	0x90,
+	0x69,
+	0x84,
+	0x75,
+	0xf0,
+	0x00,
+	0x12,
+	0xf4,
+	0x15,
+	0xfb,
+	0xa3,
+	0x12,
+	0xf4,
+	0x15,
+	0xfc,
+	0xa3,
+	0x12,
+	0xf4,
+	0x15,
+	0xfd,
+	0xa3,
+	0x12,
+	0xf4,
+	0x15,
+	0xfe,
+	0x90,
+	0x44,
+	0x18,
+	0xeb,
+	0xf0,
+	0xa3,
+	0xec,
+	0xf0,
+	0xa3,
+	0xed,
+	0xf0,
+	0xa3,
+	0xee,
+	0xf0,
+	0x90,
+	0x69,
+	0x80,
+	0xe0,
+	0xfb,
+	0xa3,
+	0xe0,
+	0xfc,
+	0xa3,
+	0xe0,
+	0xfd,
+	0xa3,
+	0xe0,
+	0xfe,
+	0x63,
+	0x03,
+	0x02,
+	0x90,
+	0x44,
+	0x14,
+	0xeb,
+	0xf0,
+	0xa3,
+	0xec,
+	0xf0,
+	0xa3,
+	0xed,
+	0xf0,
+	0xa3,
+	0xee,
+	0xf0,
+	0x80,
+	0x18,
+	0x90,
+	0x44,
+	0x18,
+	0xe4,
+	0xf0,
+	0xa3,
+	0xf0,
+	0xa3,
+	0xf0,
+	0xa3,
+	0xf0,
+	0x90,
+	0x44,
+	0x14,
+	0x74,
+	0x02,
+	0xf0,
+	0xa3,
+	0xe4,
+	0xf0,
+	0xa3,
+	0xf0,
+	0xa3,
+	0xf0,
+	0x90,
+	0x44,
+	0x24,
+	0xe0,
+	0xfb,
+	0xa3,
+	0xe0,
+	0xfc,
+	0xa3,
+	0xe0,
+	0xfd,
+	0xa3,
+	0xe0,
+	0xfe,
+	0x90,
+	0x64,
+	0xe0,
+	0xeb,
+	0xf0,
+	0xa3,
+	0xec,
+	0xf0,
+	0xa3,
+	0xed,
+	0xf0,
+	0xa3,
+	0xee,
+	0xf0,
+	0x90,
+	0x44,
+	0x28,
+	0xe0,
+	0xfb,
+	0xa3,
+	0xe0,
+	0xfc,
+	0xa3,
+	0xe0,
+	0xfd,
+	0xa3,
+	0xe0,
+	0xfe,
+	0x90,
+	0x64,
+	0xe4,
+	0xeb,
+	0xf0,
+	0xa3,
+	0xec,
+	0xf0,
+	0xa3,
+	0xed,
+	0xf0,
+	0xa3,
+	0xee,
+	0xf0,
+	0x90,
+	0x44,
+	0x2c,
+	0xe0,
+	0xfb,
+	0xa3,
+	0xe0,
+	0xfc,
+	0xa3,
+	0xe0,
+	0xfd,
+	0xa3,
+	0xe0,
+	0xfe,
+	0x90,
+	0x64,
+	0xe8,
+	0xeb,
+	0xf0,
+	0xa3,
+	0xec,
+	0xf0,
+	0xa3,
+	0xed,
+	0xf0,
+	0xa3,
+	0xee,
+	0xf0,
+	0x90,
+	0x44,
+	0x30,
+	0xe0,
+	0xfb,
+	0xa3,
+	0xe0,
+	0xfc,
+	0xa3,
+	0xe0,
+	0xfd,
+	0xa3,
+	0xe0,
+	0xfe,
+	0x90,
+	0x64,
+	0xec,
+	0xeb,
+	0xf0,
+	0xa3,
+	0xec,
+	0xf0,
+	0xa3,
+	0xed,
+	0xf0,
+	0xa3,
+	0xee,
+	0xf0,
+	0x85,
+	0x12,
+	0x81,
+	0xd0,
+	0x12,
+	0x22,
+	0x7e,
+	0x00,
+	0x7f,
+	0x00,
+	0xc3,
+	0xee,
+	0x94,
+	0x08,
+	0xef,
+	0x64,
+	0x80,
+	0x94,
+	0x80,
+	0x50,
+	0x25,
+	0xee,
+	0x24,
+	0x40,
+	0xfc,
+	0xef,
+	0x34,
+	0x65,
+	0xfd,
+	0x8e,
+	0x03,
+	0x74,
+	0x07,
+	0xc3,
+	0x9b,
+	0x24,
+	0xb0,
+	0xf5,
+	0x82,
+	0xe4,
+	0x34,
+	0x69,
+	0xf5,
+	0x83,
+	0xe0,
+	0xfb,
+	0x8c,
+	0x82,
+	0x8d,
+	0x83,
+	0xf0,
+	0x0e,
+	0xbe,
+	0x00,
+	0xd3,
+	0x0f,
+	0x80,
+	0xd0,
+	0x90,
+	0x65,
+	0x48,
+	0x74,
+	0x02,
+	0xf0,
+	0x90,
+	0x65,
+	0x49,
+	0xe4,
+	0xf0,
+	0x90,
+	0x30,
+	0x45,
+	0xe0,
+	0x90,
+	0x65,
+	0x4a,
+	0xf0,
+	0x90,
+	0x65,
+	0x4b,
+	0x74,
+	0x02,
+	0xf0,
+	0x90,
+	0x65,
+	0x4c,
+	0xe4,
+	0xf0,
+	0x90,
+	0x65,
+	0x4d,
+	0xf0,
+	0x74,
+	0x20,
+	0x24,
+	0x00,
+	0xfd,
+	0xe4,
+	0x34,
+	0x65,
+	0xfe,
+	0x7f,
+	0x00,
+	0x7b,
+	0x00,
+	0x7c,
+	0x00,
+	0xc3,
+	0xeb,
+	0x94,
+	0x20,
+	0xec,
+	0x64,
+	0x80,
+	0x94,
+	0x80,
+	0x50,
+	0x23,
+	0xeb,
+	0x24,
+	0x60,
+	0xf9,
+	0xec,
+	0x34,
+	0x64,
+	0xfa,
+	0x1d,
+	0xbd,
+	0xff,
+	0x01,
+	0x1e,
+	0x8d,
+	0x82,
+	0x8e,
+	0x83,
+	0x8f,
+	0xf0,
+	0x12,
+	0xf4,
+	0x15,
+	0xf8,
+	0x89,
+	0x82,
+	0x8a,
+	0x83,
+	0xf0,
+	0x0b,
+	0xbb,
+	0x00,
+	0xd5,
+	0x0c,
+	0x80,
+	0xd2,
+	0x74,
+	0x0e,
+	0xc0,
+	0xe0,
+	0xe4,
+	0xc0,
+	0xe0,
+	0xc0,
+	0xe0,
+	0xc0,
+	0xe0,
+	0x74,
+	0x40,
+	0xc0,
+	0xe0,
+	0x74,
+	0x65,
+	0xc0,
+	0xe0,
+	0xe4,
+	0xc0,
+	0xe0,
+	0x90,
+	0x64,
+	0x60,
+	0x75,
+	0xf0,
+	0x00,
+	0x12,
+	0xa9,
+	0xc9,
+	0xe5,
+	0x81,
+	0x24,
+	0xf9,
+	0xf5,
+	0x81,
+	0x90,
+	0x30,
+	0x0a,
+	0xe0,
+	0xff,
+	0xbf,
+	0xdb,
+	0x06,
+	0x90,
+	0x30,
+	0x02,
+	0x74,
+	0x53,
+	0xf0,
+	0x22,
+	0xc0,
+	0x12,
+	0x85,
+	0x81,
+	0x12,
+	0x05,
+	0x81,
+	0x05,
+	0x81,
+	0x05,
+	0x81,
+	0x7e,
+	0x00,
+	0x7f,
+	0x00,
+	0xc3,
+	0xee,
+	0x94,
+	0x08,
+	0xef,
+	0x64,
+	0x80,
+	0x94,
+	0x80,
+	0x50,
+	0x25,
+	0xee,
+	0x24,
+	0x40,
+	0xfc,
+	0xef,
+	0x34,
+	0x65,
+	0xfd,
+	0x8e,
+	0x03,
+	0x74,
+	0x07,
+	0xc3,
+	0x9b,
+	0x24,
+	0x40,
+	0xf5,
+	0x82,
+	0xe4,
+	0x34,
+	0x63,
+	0xf5,
+	0x83,
+	0xe0,
+	0xfb,
+	0x8c,
+	0x82,
+	0x8d,
+	0x83,
+	0xf0,
+	0x0e,
+	0xbe,
+	0x00,
+	0xd3,
+	0x0f,
+	0x80,
+	0xd0,
+	0x74,
+	0x20,
+	0x24,
+	0x00,
+	0xfd,
+	0xe4,
+	0x34,
+	0x65,
+	0xfe,
+	0x7f,
+	0x00,
+	0xa8,
+	0x12,
+	0x08,
+	0xe4,
+	0xf6,
+	0x08,
+	0xf6,
+	0xa8,
+	0x12,
+	0x08,
+	0xc3,
+	0xe6,
+	0x94,
+	0x20,
+	0x08,
+	0xe6,
+	0x64,
+	0x80,
+	0x94,
+	0x80,
+	0x50,
+	0x2b,
+	0xa8,
+	0x12,
+	0x08,
+	0xe6,
+	0x24,
+	0x60,
+	0xfa,
+	0x08,
+	0xe6,
+	0x34,
+	0x64,
+	0xfc,
+	0x1d,
+	0xbd,
+	0xff,
+	0x01,
+	0x1e,
+	0x8d,
+	0x82,
+	0x8e,
+	0x83,
+	0x8f,
+	0xf0,
+	0x12,
+	0xf4,
+	0x15,
+	0xfb,
+	0x8a,
+	0x82,
+	0x8c,
+	0x83,
+	0xf0,
+	0xa8,
+	0x12,
+	0x08,
+	0x06,
+	0xb6,
+	0x00,
+	0x02,
+	0x08,
+	0x06,
+	0x80,
+	0xc6,
+	0x7d,
+	0x88,
+	0x7e,
+	0x69,
+	0x7f,
+	0x00,
+	0xa8,
+	0x12,
+	0x08,
+	0x76,
+	0x18,
+	0x08,
+	0x76,
+	0x00,
+	0xa8,
+	0x12,
+	0x08,
+	0xc3,
+	0xe6,
+	0x94,
+	0x20,
+	0x08,
+	0xe6,
+	0x64,
+	0x80,
+	0x94,
+	0x80,
+	0x50,
+	0x49,
+	0xa8,
+	0x12,
+	0x08,
+	0xe6,
+	0x24,
+	0x60,
+	0xfa,
+	0x08,
+	0xe6,
+	0x34,
+	0x64,
+	0xfc,
+	0xa8,
+	0x12,
+	0x08,
+	0xe6,
+	0x24,
+	0x60,
+	0xf5,
+	0x82,
+	0x08,
+	0xe6,
+	0x34,
+	0x64,
+	0xf5,
+	0x83,
+	0xe5,
+	0x12,
+	0x24,
+	0x03,
+	0xf8,
+	0xe0,
+	0xf6,
+	0x1d,
+	0xbd,
+	0xff,
+	0x01,
+	0x1e,
+	0x8d,
+	0x82,
+	0x8e,
+	0x83,
+	0x8f,
+	0xf0,
+	0x12,
+	0xf4,
+	0x15,
+	0xfb,
+	0xe5,
+	0x12,
+	0x24,
+	0x03,
+	0xf8,
+	0xe6,
+	0x62,
+	0x03,
+	0x8a,
+	0x82,
+	0x8c,
+	0x83,
+	0xeb,
+	0xf0,
+	0xa8,
+	0x12,
+	0x08,
+	0x06,
+	0xb6,
+	0x00,
+	0x02,
+	0x08,
+	0x06,
+	0x80,
+	0xa8,
+	0x74,
+	0x08,
+	0xc0,
+	0xe0,
+	0xe4,
+	0xc0,
+	0xe0,
+	0xc0,
+	0xe0,
+	0xc0,
+	0xe0,
+	0x74,
+	0x40,
+	0xc0,
+	0xe0,
+	0x74,
+	0x65,
+	0xc0,
+	0xe0,
+	0xe4,
+	0xc0,
+	0xe0,
+	0x90,
+	0x64,
+	0x60,
+	0x75,
+	0xf0,
+	0x00,
+	0x12,
+	0xa9,
+	0xc9,
+	0xe5,
+	0x81,
+	0x24,
+	0xf9,
+	0xf5,
+	0x81,
+	0x90,
+	0x30,
+	0x0a,
+	0xe0,
+	0xff,
+	0xbf,
+	0xdb,
+	0x06,
+	0x90,
+	0x30,
+	0x02,
+	0x74,
+	0x54,
+	0xf0,
+	0x85,
+	0x12,
+	0x81,
+	0xd0,
+	0x12,
+	0x22,
+	0xc0,
+	0x12,
+	0xe5,
+	0x81,
+	0xf5,
+	0x12,
+	0x24,
+	0x04,
+	0xf5,
+	0x81,
+	0x90,
+	0x30,
+	0x21,
+	0xe0,
+	0xff,
+	0xe5,
+	0x12,
+	0x24,
+	0x03,
+	0xf8,
+	0xef,
+	0x75,
+	0xf0,
+	0x05,
+	0xa4,
+	0xf6,
+	0x08,
+	0xa6,
+	0xf0,
+	0xe5,
+	0x12,
+	0x24,
+	0x03,
+	0xf8,
+	0xe6,
+	0x24,
+	0x40,
+	0xfc,
+	0x08,
+	0xe6,
+	0x34,
+	0x65,
+	0xfd,
+	0x90,
+	0x30,
+	0x20,
+	0xe0,
+	0x25,
+	0xe0,
+	0x8c,
+	0x82,
+	0x8d,
+	0x83,
+	0xf0,
+	0xe5,
+	0x12,
+	0x24,
+	0x03,
+	0xf8,
+	0xe6,
+	0x24,
+	0x40,
+	0xfc,
+	0x08,
+	0xe6,
+	0x34,
+	0x65,
+	0xfd,
+	0xe5,
+	0x12,
+	0x24,
+	0x03,
+	0xf8,
+	0xe6,
+	0x24,
+	0x40,
+	0xf5,
+	0x82,
+	0x08,
+	0xe6,
+	0x34,
+	0x65,
+	0xf5,
+	0x83,
+	0xe0,
+	0xfb,
+	0x90,
+	0x30,
+	0x21,
+	0xe0,
+	0xfa,
+	0xba,
+	0x10,
+	0x00,
+	0xb3,
+	0xe4,
+	0x33,
+	0xfa,
+	0xeb,
+	0x42,
+	0x02,
+	0x8c,
+	0x82,
+	0x8d,
+	0x83,
+	0xea,
+	0xf0,
+	0xe5,
+	0x12,
+	0x24,
+	0x03,
+	0xf8,
+	0x06,
+	0xb6,
+	0x00,
+	0x02,
+	0x08,
+	0x06,
+	0xe5,
+	0x12,
+	0x24,
+	0x03,
+	0xf8,
+	0xe6,
+	0x24,
+	0x40,
+	0xfc,
+	0x08,
+	0xe6,
+	0x34,
+	0x65,
+	0xfd,
+	0x90,
+	0x30,
+	0x21,
+	0xe0,
+	0x54,
+	0x0f,
+	0xc4,
+	0x54,
+	0xf0,
+	0x8c,
+	0x82,
+	0x8d,
+	0x83,
+	0xf0,
+	0xe5,
+	0x12,
+	0x24,
+	0x03,
+	0xf8,
+	0xe6,
+	0x24,
+	0x40,
+	0xfc,
+	0x08,
+	0xe6,
+	0x34,
+	0x65,
+	0xfd,
+	0xe5,
+	0x12,
+	0x24,
+	0x03,
+	0xf8,
+	0xe6,
+	0x24,
+	0x40,
+	0xf5,
+	0x82,
+	0x08,
+	0xe6,
+	0x34,
+	0x65,
+	0xf5,
+	0x83,
+	0xe0,
+	0xfb,
+	0x90,
+	0x30,
+	0x22,
+	0xe0,
+	0xfa,
+	0x42,
+	0x03,
+	0x8c,
+	0x82,
+	0x8d,
+	0x83,
+	0xeb,
+	0xf0,
+	0xe5,
+	0x12,
+	0x24,
+	0x03,
+	0xf8,
+	0x06,
+	0xb6,
+	0x00,
+	0x02,
+	0x08,
+	0x06,
+	0xe5,
+	0x12,
+	0x24,
+	0x03,
+	0xf8,
+	0x86,
+	0x04,
+	0x08,
+	0x86,
+	0x05,
+	0xe5,
+	0x12,
+	0x24,
+	0x03,
+	0xf8,
+	0x06,
+	0xb6,
+	0x00,
+	0x02,
+	0x08,
+	0x06,
+	0xec,
+	0x24,
+	0x40,
+	0xfc,
+	0xed,
+	0x34,
+	0x65,
+	0xfd,
+	0x90,
+	0x30,
+	0x48,
+	0xe0,
+	0xfb,
+	0x8c,
+	0x82,
+	0x8d,
+	0x83,
+	0xf0,
+	0xe5,
+	0x12,
+	0x24,
+	0x03,
+	0xf8,
+	0x86,
+	0x04,
+	0x08,
+	0x86,
+	0x05,
+	0xe5,
+	0x12,
+	0x24,
+	0x03,
+	0xf8,
+	0x06,
+	0xb6,
+	0x00,
+	0x02,
+	0x08,
+	0x06,
+	0xec,
+	0x24,
+	0x40,
+	0xfc,
+	0xed,
+	0x34,
+	0x65,
+	0xfd,
+	0x90,
+	0x30,
+	0x47,
+	0xe0,
+	0xfb,
+	0x8c,
+	0x82,
+	0x8d,
+	0x83,
+	0xf0,
+	0xe5,
+	0x12,
+	0x24,
+	0x03,
+	0xf8,
+	0x86,
+	0x04,
+	0x08,
+	0x86,
+	0x05,
+	0xe5,
+	0x12,
+	0x24,
+	0x03,
+	0xf8,
+	0x06,
+	0xb6,
+	0x00,
+	0x02,
+	0x08,
+	0x06,
+	0xec,
+	0x24,
+	0x40,
+	0xfc,
+	0xed,
+	0x34,
+	0x65,
+	0xfd,
+	0x90,
+	0x30,
+	0x46,
+	0xe0,
+	0x8c,
+	0x82,
+	0x8d,
+	0x83,
+	0xf0,
+	0x74,
+	0x20,
+	0x24,
+	0x00,
+	0xfb,
+	0xe4,
+	0x34,
+	0x65,
+	0xfc,
+	0x7d,
+	0x00,
+	0xa8,
+	0x12,
+	0x08,
+	0xe4,
+	0xf6,
+	0x08,
+	0xf6,
+	0xa8,
+	0x12,
+	0x08,
+	0xc3,
+	0xe6,
+	0x94,
+	0x20,
+	0x08,
+	0xe6,
+	0x64,
+	0x80,
+	0x94,
+	0x80,
+	0x50,
+	0x2b,
+	0xa8,
+	0x12,
+	0x08,
+	0xe6,
+	0x24,
+	0x60,
+	0xfe,
+	0x08,
+	0xe6,
+	0x34,
+	0x64,
+	0xff,
+	0x1b,
+	0xbb,
+	0xff,
+	0x01,
+	0x1c,
+	0x8b,
+	0x82,
+	0x8c,
+	0x83,
+	0x8d,
+	0xf0,
+	0x12,
+	0xf4,
+	0x15,
+	0xfa,
+	0x8e,
+	0x82,
+	0x8f,
+	0x83,
+	0xf0,
+	0xa8,
+	0x12,
+	0x08,
+	0x06,
+	0xb6,
+	0x00,
+	0x02,
+	0x08,
+	0x06,
+	0x80,
+	0xc6,
+	0x90,
+	0x30,
+	0x0a,
+	0xe0,
+	0xff,
+	0xbf,
+	0xdb,
+	0x06,
+	0x90,
+	0x30,
+	0x02,
+	0x74,
+	0x55,
+	0xf0,
+	0xe5,
+	0x12,
+	0x24,
+	0x03,
+	0xf8,
+	0x86,
+	0x04,
+	0x08,
+	0x86,
+	0x05,
+	0xe6,
+	0x33,
+	0x95,
+	0xe0,
+	0xfe,
+	0xff,
+	0xc0,
+	0x04,
+	0xc0,
+	0x05,
+	0xc0,
+	0x06,
+	0xc0,
+	0x07,
+	0x74,
+	0x40,
+	0xc0,
+	0xe0,
+	0x74,
+	0x65,
+	0xc0,
+	0xe0,
+	0xe4,
+	0xc0,
+	0xe0,
+	0x90,
+	0x64,
+	0x60,
+	0x75,
+	0xf0,
+	0x00,
+	0x12,
+	0xa9,
+	0xc9,
+	0xe5,
+	0x81,
+	0x24,
+	0xf9,
+	0xf5,
+	0x81,
+	0x90,
+	0x30,
+	0x0a,
+	0xe0,
+	0xff,
+	0xbf,
+	0xdb,
+	0x06,
+	0x90,
+	0x30,
+	0x02,
+	0x74,
+	0x57,
+	0xf0,
+	0x7e,
+	0x00,
+	0x7f,
+	0x00,
+	0xc3,
+	0xee,
+	0x94,
+	0x20,
+	0xef,
+	0x64,
+	0x80,
+	0x94,
+	0x80,
+	0x50,
+	0x20,
+	0xee,
+	0x24,
+	0x40,
+	0xfc,
+	0xef,
+	0x34,
+	0x6d,
+	0xfd,
+	0xee,
+	0x24,
+	0x40,
+	0xf5,
+	0x82,
+	0xef,
+	0x34,
+	0x69,
+	0xf5,
+	0x83,
+	0xe0,
+	0xfb,
+	0x8c,
+	0x82,
+	0x8d,
+	0x83,
+	0xf0,
+	0x0e,
+	0xbe,
+	0x00,
+	0xd8,
+	0x0f,
+	0x80,
+	0xd5,
+	0x85,
+	0x12,
+	0x81,
+	0xd0,
+	0x12,
+	0x22,
+	0x90,
+	0x30,
+	0x0a,
+	0xe0,
+	0xff,
+	0xbf,
+	0xdb,
+	0x06,
+	0x90,
+	0x30,
+	0x02,
+	0x74,
+	0x58,
+	0xf0,
+	0x90,
+	0x30,
+	0x2c,
+	0xe0,
+	0x25,
+	0xe0,
+	0x24,
+	0x40,
+	0xff,
+	0xe4,
+	0x34,
+	0x65,
+	0xfe,
+	0x90,
+	0x30,
+	0x4b,
+	0xe0,
+	0x8f,
+	0x82,
+	0x8e,
+	0x83,
+	0xf0,
+	0x90,
+	0x30,
+	0x2c,
+	0xe0,
+	0x25,
+	0xe0,
+	0x04,
+	0x24,
+	0x40,
+	0xfe,
+	0xe4,
+	0x34,
+	0x65,
+	0xff,
+	0x90,
+	0x30,
+	0x4a,
+	0xe0,
+	0x8e,
+	0x82,
+	0x8f,
+	0x83,
+	0xf0,
+	0x90,
+	0x30,
+	0x2c,
+	0xe0,
+	0x25,
+	0xe0,
+	0x24,
+	0x02,
+	0x24,
+	0x40,
+	0xfe,
+	0xe4,
+	0x34,
+	0x65,
+	0xff,
+	0x90,
+	0x30,
+	0x49,
+	0xe0,
+	0x8e,
+	0x82,
+	0x8f,
+	0x83,
+	0xf0,
+	0x74,
+	0x20,
+	0x24,
+	0x40,
+	0xfd,
+	0xe4,
+	0x34,
+	0x69,
+	0xfe,
+	0x7f,
+	0x00,
+	0x7b,
+	0x00,
+	0x7c,
+	0x00,
+	0xc3,
+	0xeb,
+	0x94,
+	0x20,
+	0xec,
+	0x64,
+	0x80,
+	0x94,
+	0x80,
+	0x50,
+	0x23,
+	0xeb,
+	0x24,
+	0x60,
+	0xf9,
+	0xec,
+	0x34,
+	0x64,
+	0xfa,
+	0x1d,
+	0xbd,
+	0xff,
+	0x01,
+	0x1e,
+	0x8d,
+	0x82,
+	0x8e,
+	0x83,
+	0x8f,
+	0xf0,
+	0x12,
+	0xf4,
+	0x15,
+	0xf8,
+	0x89,
+	0x82,
+	0x8a,
+	0x83,
+	0xf0,
+	0x0b,
+	0xbb,
+	0x00,
+	0xd5,
+	0x0c,
+	0x80,
+	0xd2,
+	0x90,
+	0x30,
+	0x2c,
+	0xe0,
+	0x75,
+	0xf0,
+	0x02,
+	0xa4,
+	0x24,
+	0x03,
+	0xfe,
+	0xe4,
+	0x35,
+	0xf0,
+	0xff,
+	0x33,
+	0x95,
+	0xe0,
+	0xfd,
+	0xfc,
+	0xc0,
+	0x06,
+	0xc0,
+	0x07,
+	0xc0,
+	0x05,
+	0xc0,
+	0x04,
+	0x74,
+	0x40,
+	0xc0,
+	0xe0,
+	0x74,
+	0x65,
+	0xc0,
+	0xe0,
+	0xe4,
+	0xc0,
+	0xe0,
+	0x90,
+	0x64,
+	0x60,
+	0x75,
+	0xf0,
+	0x00,
+	0x12,
+	0xa9,
+	0xc9,
+	0xe5,
+	0x81,
+	0x24,
+	0xf9,
+	0xf5,
+	0x81,
+	0x90,
+	0x30,
+	0x0a,
+	0xe0,
+	0xff,
+	0xbf,
+	0xdb,
+	0x06,
+	0x90,
+	0x30,
+	0x02,
+	0x74,
+	0x5a,
+	0xf0,
+	0x7e,
+	0x00,
+	0x7f,
+	0x00,
+	0xc3,
+	0xee,
+	0x94,
+	0x20,
+	0xef,
+	0x64,
+	0x80,
+	0x94,
+	0x80,
+	0x50,
+	0x20,
+	0xee,
+	0x24,
+	0x80,
+	0xfc,
+	0xef,
+	0x34,
+	0x6d,
+	0xfd,
+	0xee,
+	0x24,
+	0x40,
+	0xf5,
+	0x82,
+	0xef,
+	0x34,
+	0x69,
+	0xf5,
+	0x83,
+	0xe0,
+	0xfb,
+	0x8c,
+	0x82,
+	0x8d,
+	0x83,
+	0xf0,
+	0x0e,
+	0xbe,
+	0x00,
+	0xd8,
+	0x0f,
+	0x80,
+	0xd5,
+	0x22,
+	0xc0,
+	0x12,
+	0x85,
+	0x81,
+	0x12,
+	0x05,
+	0x81,
+	0xa8,
+	0x12,
+	0x08,
+	0x76,
+	0x00,
+	0xa8,
+	0x12,
+	0x08,
+	0xb6,
+	0x08,
+	0x00,
+	0x50,
+	0x48,
+	0xa8,
+	0x12,
+	0x08,
+	0xe6,
+	0x25,
+	0xe0,
+	0x25,
+	0xe0,
+	0xfe,
+	0x7d,
+	0x66,
+	0xa8,
+	0x12,
+	0x08,
+	0x74,
+	0x07,
+	0xc3,
+	0x96,
+	0x25,
+	0xe0,
+	0x25,
+	0xe0,
+	0xfc,
+	0x7b,
+	0x65,
+	0x7a,
+	0x00,
+	0x8c,
+	0x82,
+	0x8b,
+	0x83,
+	0x8a,
+	0xf0,
+	0xc0,
+	0x06,
+	0xc0,
+	0x05,
+	0x12,
+	0xad,
+	0x16,
+	0xaa,
+	0x82,
+	0xab,
+	0x83,
+	0xac,
+	0xf0,
+	0xff,
+	0xd0,
+	0x05,
+	0xd0,
+	0x06,
+	0x8e,
+	0x82,
+	0x8d,
+	0x83,
+	0xea,
+	0xf0,
+	0xa3,
+	0xeb,
+	0xf0,
+	0xa3,
+	0xec,
+	0xf0,
+	0xa3,
+	0xef,
+	0xf0,
+	0xa8,
+	0x12,
+	0x08,
+	0x06,
+	0x80,
+	0xb0,
+	0x7c,
+	0x00,
+	0x7d,
+	0x66,
+	0x53,
+	0x05,
+	0x0f,
+	0xe4,
+	0xfe,
+	0xc3,
+	0x13,
+	0xff,
+	0xee,
+	0x13,
+	0xfe,
+	0xed,
+	0x13,
+	0xfd,
+	0xec,
+	0x13,
+	0xfc,
+	0xef,
+	0xc3,
+	0x13,
+	0xee,
+	0x13,
+	0xed,
+	0x13,
+	0xfd,
+	0xec,
+	0x13,
+	0x90,
+	0x40,
+	0x04,
+	0xf0,
+	0xa3,
+	0xed,
+	0xf0,
+	0x90,
+	0x40,
+	0x0a,
+	0x74,
+	0x20,
+	0xf0,
+	0x7c,
+	0x00,
+	0x7d,
+	0x69,
+	0x53,
+	0x05,
+	0x0f,
+	0xe4,
+	0xfe,
+	0xc3,
+	0x13,
+	0xff,
+	0xee,
+	0x13,
+	0xfe,
+	0xed,
+	0x13,
+	0xfd,
+	0xec,
+	0x13,
+	0xfc,
+	0xef,
+	0xc3,
+	0x13,
+	0xee,
+	0x13,
+	0xed,
+	0x13,
+	0xfd,
+	0xec,
+	0x13,
+	0x90,
+	0x40,
+	0x08,
+	0xf0,
+	0xa3,
+	0xed,
+	0xf0,
+	0x7c,
+	0x40,
+	0x7d,
+	0x69,
+	0x53,
+	0x05,
+	0x0f,
+	0xe4,
+	0xfe,
+	0xc3,
+	0x13,
+	0xff,
+	0xee,
+	0x13,
+	0xfe,
+	0xed,
+	0x13,
+	0xfd,
+	0xec,
+	0x13,
+	0xfc,
+	0xef,
+	0xc3,
+	0x13,
+	0xff,
+	0xee,
+	0x13,
+	0xfe,
+	0xed,
+	0x13,
+	0xfd,
+	0xec,
+	0x13,
+	0xfc,
+	0x90,
+	0x40,
+	0x0c,
+	0xf0,
+	0xa3,
+	0xed,
+	0xf0,
+	0x90,
+	0x42,
+	0x41,
+	0x74,
+	0x87,
+	0xf0,
+	0x90,
+	0x40,
+	0x00,
+	0xe0,
+	0x70,
+	0xfa,
+	0xff,
+	0xbf,
+	0x10,
+	0x00,
+	0x50,
+	0x38,
+	0xef,
+	0x24,
+	0x40,
+	0xf5,
+	0x82,
+	0xe4,
+	0x34,
+	0x69,
+	0xf5,
+	0x83,
+	0xe0,
+	0xfe,
+	0xef,
+	0x24,
+	0x40,
+	0xfc,
+	0xe4,
+	0x34,
+	0x69,
+	0xfd,
+	0x74,
+	0x1f,
+	0xc3,
+	0x9f,
+	0xfb,
+	0x24,
+	0x40,
+	0xf5,
+	0x82,
+	0xe4,
+	0x34,
+	0x69,
+	0xf5,
+	0x83,
+	0xe0,
+	0xfa,
+	0x8c,
+	0x82,
+	0x8d,
+	0x83,
+	0xf0,
+	0xeb,
+	0x24,
+	0x40,
+	0xf5,
+	0x82,
+	0xe4,
+	0x34,
+	0x69,
+	0xf5,
+	0x83,
+	0xee,
+	0xf0,
+	0x0f,
+	0x80,
+	0xc3,
+	0x15,
+	0x81,
+	0xd0,
+	0x12,
+	0x22,
+	0xc0,
+	0x12,
+	0x85,
+	0x81,
+	0x12,
+	0xc0,
+	0x82,
+	0xc0,
+	0x83,
+	0xc0,
+	0xf0,
+	0xe5,
+	0x81,
+	0x24,
+	0x04,
+	0xf5,
+	0x81,
+	0x7a,
+	0x00,
+	0x7b,
+	0x00,
+	0x7c,
+	0x00,
+	0x7f,
+	0x00,
+	0xc3,
+	0xea,
+	0x94,
+	0x40,
+	0xeb,
+	0x94,
+	0x00,
+	0xec,
+	0x94,
+	0x00,
+	0xef,
+	0x94,
+	0x00,
+	0x50,
+	0x1c,
+	0xea,
+	0x24,
+	0x80,
+	0xf5,
+	0x82,
+	0xeb,
+	0x34,
+	0x68,
+	0xf5,
+	0x83,
+	0x74,
+	0x36,
+	0xf0,
+	0x0a,
+	0xba,
+	0x00,
+	0x09,
+	0x0b,
+	0xbb,
+	0x00,
+	0x05,
+	0x0c,
+	0xbc,
+	0x00,
+	0xd8,
+	0x0f,
+	0x80,
+	0xd5,
+	0xe5,
+	0x12,
+	0x24,
+	0x04,
+	0xf8,
+	0xe4,
+	0xf6,
+	0x08,
+	0xf6,
+	0x08,
+	0xf6,
+	0x08,
+	0xf6,
+	0xe5,
+	0x12,
+	0x24,
+	0x04,
+	0xf8,
+	0xc3,
+	0xe6,
+	0x94,
+	0x20,
+	0x08,
+	0xe6,
+	0x94,
+	0x00,
+	0x08,
+	0xe6,
+	0x94,
+	0x00,
+	0x08,
+	0xe6,
+	0x94,
+	0x00,
+	0x50,
+	0x60,
+	0xe5,
+	0x12,
+	0x24,
+	0x04,
+	0xf8,
+	0xe6,
+	0x24,
+	0x80,
+	0xfa,
+	0x08,
+	0xe6,
+	0x34,
+	0x68,
+	0xfb,
+	0xe5,
+	0x12,
+	0x24,
+	0x04,
+	0xf8,
+	0xe6,
+	0x24,
+	0x80,
+	0xf5,
+	0x82,
+	0x08,
+	0xe6,
+	0x34,
+	0x68,
+	0xf5,
+	0x83,
+	0xe0,
+	0xff,
+	0xa8,
+	0x12,
+	0x08,
+	0x86,
+	0x04,
+	0x08,
+	0x86,
+	0x05,
+	0x08,
+	0x86,
+	0x06,
+	0xe5,
+	0x12,
+	0x24,
+	0x04,
+	0xf8,
+	0xe6,
+	0x2c,
+	0xfc,
+	0x08,
+	0xe6,
+	0x3d,
+	0xfd,
+	0x8c,
+	0x82,
+	0x8d,
+	0x83,
+	0x8e,
+	0xf0,
+	0x12,
+	0xf4,
+	0x15,
+	0xfc,
+	0x62,
+	0x07,
+	0x8a,
+	0x82,
+	0x8b,
+	0x83,
+	0xef,
+	0xf0,
+	0xe5,
+	0x12,
+	0x24,
+	0x04,
+	0xf8,
+	0x06,
+	0xb6,
+	0x00,
+	0x0c,
+	0x08,
+	0x06,
+	0xb6,
+	0x00,
+	0x07,
+	0x08,
+	0x06,
+	0xb6,
+	0x00,
+	0x02,
+	0x08,
+	0x06,
+	0x80,
+	0x89,
+	0x7c,
+	0x80,
+	0x7d,
+	0x68,
+	0x53,
+	0x05,
+	0x0f,
+	0xe4,
+	0xfe,
+	0xc3,
+	0x13,
+	0xff,
+	0xee,
+	0x13,
+	0xfe,
+	0xed,
+	0x13,
+	0xfd,
+	0xec,
+	0x13,
+	0xfc,
+	0xef,
+	0xc3,
+	0x13,
+	0xee,
+	0x13,
+	0xed,
+	0x13,
+	0xfd,
+	0xec,
+	0x13,
+	0x90,
+	0x40,
+	0x04,
+	0xf0,
+	0xa3,
+	0xed,
+	0xf0,
+	0xe5,
+	0x12,
+	0x24,
+	0xf7,
+	0xf8,
+	0x74,
+	0x3f,
+	0x56,
+	0x90,
+	0x40,
+	0x0a,
+	0xf0,
+	0x7c,
+	0x00,
+	0x7d,
+	0x69,
+	0x53,
+	0x05,
+	0x0f,
+	0xe4,
+	0xfe,
+	0xc3,
+	0x13,
+	0xff,
+	0xee,
+	0x13,
+	0xfe,
+	0xed,
+	0x13,
+	0xfd,
+	0xec,
+	0x13,
+	0xfc,
+	0xef,
+	0xc3,
+	0x13,
+	0xee,
+	0x13,
+	0xed,
+	0x13,
+	0xfd,
+	0xec,
+	0x13,
+	0x90,
+	0x40,
+	0x08,
+	0xf0,
+	0xa3,
+	0xed,
+	0xf0,
+	0x7c,
+	0xc0,
+	0x7d,
+	0x68,
+	0x53,
+	0x05,
+	0x0f,
+	0xe4,
+	0xfe,
+	0xc3,
+	0x13,
+	0xff,
+	0xee,
+	0x13,
+	0xfe,
+	0xed,
+	0x13,
+	0xfd,
+	0xec,
+	0x13,
+	0xfc,
+	0xef,
+	0xc3,
+	0x13,
+	0xff,
+	0xee,
+	0x13,
+	0xfe,
+	0xed,
+	0x13,
+	0xfd,
+	0xec,
+	0x13,
+	0xfc,
+	0x90,
+	0x40,
+	0x0c,
+	0xf0,
+	0xa3,
+	0xed,
+	0xf0,
+	0x90,
+	0x42,
+	0x41,
+	0x74,
+	0x83,
+	0xf0,
+	0x90,
+	0x40,
+	0x00,
+	0xe0,
+	0x70,
+	0xfa,
+	0xe5,
+	0x12,
+	0x24,
+	0xfb,
+	0xf8,
+	0x86,
+	0x04,
+	0x08,
+	0x86,
+	0x05,
+	0x08,
+	0x86,
+	0x06,
+	0xe4,
+	0xc3,
+	0x13,
+	0xff,
+	0xee,
+	0x13,
+	0xfe,
+	0xed,
+	0x13,
+	0xfd,
+	0xec,
+	0x13,
+	0xfc,
+	0xef,
+	0xc3,
+	0x13,
+	0xee,
+	0x13,
+	0xed,
+	0x13,
+	0xfd,
+	0xec,
+	0x13,
+	0x90,
+	0x40,
+	0x04,
+	0xf0,
+	0xa3,
+	0xed,
+	0xf0,
+	0xe5,
+	0x12,
+	0x24,
+	0xf7,
+	0xf8,
+	0x86,
+	0x04,
+	0x08,
+	0x86,
+	0x05,
+	0x08,
+	0x86,
+	0x06,
+	0x08,
+	0x86,
+	0x07,
+	0xc3,
+	0x74,
+	0x40,
+	0x9c,
+	0xe4,
+	0x9d,
+	0xe4,
+	0x9e,
+	0xe4,
+	0x9f,
+	0x50,
+	0x1e,
+	0x90,
+	0x42,
+	0x41,
+	0x74,
+	0x89,
+	0xf0,
+	0x90,
+	0x40,
+	0x00,
+	0xe0,
+	0x70,
+	0xfa,
+	0xec,
+	0x24,
+	0xc0,
+	0xfc,
+	0xed,
+	0x34,
+	0xff,
+	0xfd,
+	0xee,
+	0x34,
+	0xff,
+	0xfe,
+	0xef,
+	0x34,
+	0xff,
+	0xff,
+	0x80,
+	0xd6,
+	0xec,
+	0x4d,
+	0x4e,
+	0x4f,
+	0x70,
+	0x06,
+	0x90,
+	0x42,
+	0x41,
+	0x74,
+	0xa0,
+	0xf0,
+	0x90,
+	0x40,
+	0x00,
+	0xe0,
+	0x70,
+	0xfa,
+	0x90,
+	0x42,
+	0x41,
+	0x74,
+	0x85,
+	0xf0,
+	0x90,
+	0x40,
+	0x00,
+	0xe0,
+	0x70,
+	0xfa,
+	0xfc,
+	0xfd,
+	0xfe,
+	0xff,
+	0xc3,
+	0xec,
+	0x94,
+	0x40,
+	0xed,
+	0x94,
+	0x00,
+	0xee,
+	0x94,
+	0x00,
+	0xef,
+	0x94,
+	0x00,
+	0x50,
+	0x1c,
+	0xec,
+	0x24,
+	0x80,
+	0xf5,
+	0x82,
+	0xed,
+	0x34,
+	0x68,
+	0xf5,
+	0x83,
+	0x74,
+	0x5c,
+	0xf0,
+	0x0c,
+	0xbc,
+	0x00,
+	0x09,
+	0x0d,
+	0xbd,
+	0x00,
+	0x05,
+	0x0e,
+	0xbe,
+	0x00,
+	0xd8,
+	0x0f,
+	0x80,
+	0xd5,
+	0xe5,
+	0x12,
+	0x24,
+	0x04,
+	0xf8,
+	0xe4,
+	0xf6,
+	0x08,
+	0xf6,
+	0x08,
+	0xf6,
+	0x08,
+	0xf6,
+	0xe5,
+	0x12,
+	0x24,
+	0x04,
+	0xf8,
+	0xc3,
+	0xe6,
+	0x94,
+	0x20,
+	0x08,
+	0xe6,
+	0x94,
+	0x00,
+	0x08,
+	0xe6,
+	0x94,
+	0x00,
+	0x08,
+	0xe6,
+	0x94,
+	0x00,
+	0x50,
+	0x60,
+	0xe5,
+	0x12,
+	0x24,
+	0x04,
+	0xf8,
+	0xe6,
+	0x24,
+	0x80,
+	0xfa,
+	0x08,
+	0xe6,
+	0x34,
+	0x68,
+	0xfb,
+	0xe5,
+	0x12,
+	0x24,
+	0x04,
+	0xf8,
+	0xe6,
+	0x24,
+	0x80,
+	0xf5,
+	0x82,
+	0x08,
+	0xe6,
+	0x34,
+	0x68,
+	0xf5,
+	0x83,
+	0xe0,
+	0xff,
+	0xa8,
+	0x12,
+	0x08,
+	0x86,
+	0x04,
+	0x08,
+	0x86,
+	0x05,
+	0x08,
+	0x86,
+	0x06,
+	0xe5,
+	0x12,
+	0x24,
+	0x04,
+	0xf8,
+	0xe6,
+	0x2c,
+	0xfc,
+	0x08,
+	0xe6,
+	0x3d,
+	0xfd,
+	0x8c,
+	0x82,
+	0x8d,
+	0x83,
+	0x8e,
+	0xf0,
+	0x12,
+	0xf4,
+	0x15,
+	0xfc,
+	0x62,
+	0x07,
+	0x8a,
+	0x82,
+	0x8b,
+	0x83,
+	0xef,
+	0xf0,
+	0xe5,
+	0x12,
+	0x24,
+	0x04,
+	0xf8,
+	0x06,
+	0xb6,
+	0x00,
+	0x0c,
+	0x08,
+	0x06,
+	0xb6,
+	0x00,
+	0x07,
+	0x08,
+	0x06,
+	0xb6,
+	0x00,
+	0x02,
+	0x08,
+	0x06,
+	0x80,
+	0x89,
+	0x7c,
+	0x80,
+	0x7d,
+	0x68,
+	0x53,
+	0x05,
+	0x0f,
+	0xe4,
+	0xfe,
+	0xc3,
+	0x13,
+	0xff,
+	0xee,
+	0x13,
+	0xfe,
+	0xed,
+	0x13,
+	0xfd,
+	0xec,
+	0x13,
+	0xfc,
+	0xef,
+	0xc3,
+	0x13,
+	0xee,
+	0x13,
+	0xed,
+	0x13,
+	0xfd,
+	0xec,
+	0x13,
+	0x90,
+	0x40,
+	0x04,
+	0xf0,
+	0xa3,
+	0xed,
+	0xf0,
+	0x90,
+	0x40,
+	0x0a,
+	0x74,
+	0x20,
+	0xf0,
+	0x7c,
+	0x00,
+	0x7d,
+	0x69,
+	0x53,
+	0x05,
+	0x0f,
+	0xe4,
+	0xfe,
+	0xc3,
+	0x13,
+	0xff,
+	0xee,
+	0x13,
+	0xfe,
+	0xed,
+	0x13,
+	0xfd,
+	0xec,
+	0x13,
+	0xfc,
+	0xef,
+	0xc3,
+	0x13,
+	0xee,
+	0x13,
+	0xed,
+	0x13,
+	0xfd,
+	0xec,
+	0x13,
+	0x90,
+	0x40,
+	0x08,
+	0xf0,
+	0xa3,
+	0xed,
+	0xf0,
+	0x7c,
+	0x40,
+	0x7d,
+	0x69,
+	0x53,
+	0x05,
+	0x0f,
+	0xe4,
+	0xfe,
+	0xc3,
+	0x13,
+	0xff,
+	0xee,
+	0x13,
+	0xfe,
+	0xed,
+	0x13,
+	0xfd,
+	0xec,
+	0x13,
+	0xfc,
+	0xef,
+	0xc3,
+	0x13,
+	0xff,
+	0xee,
+	0x13,
+	0xfe,
+	0xed,
+	0x13,
+	0xfd,
+	0xec,
+	0x13,
+	0xfc,
+	0x90,
+	0x40,
+	0x0c,
+	0xf0,
+	0xa3,
+	0xed,
+	0xf0,
+	0x90,
+	0x42,
+	0x41,
+	0x74,
+	0x83,
+	0xf0,
+	0x90,
+	0x40,
+	0x00,
+	0xe0,
+	0x70,
+	0xfa,
+	0x7c,
+	0xc0,
+	0x7d,
+	0x68,
+	0x53,
+	0x05,
+	0x0f,
+	0xe4,
+	0xfe,
+	0xc3,
+	0x13,
+	0xff,
+	0xee,
+	0x13,
+	0xfe,
+	0xed,
+	0x13,
+	0xfd,
+	0xec,
+	0x13,
+	0xfc,
+	0xef,
+	0xc3,
+	0x13,
+	0xff,
+	0xee,
+	0x13,
+	0xfe,
+	0xed,
+	0x13,
+	0xfd,
+	0xec,
+	0x13,
+	0xfc,
+	0x90,
+	0x40,
+	0x04,
+	0xf0,
+	0xa3,
+	0xed,
+	0xf0,
+	0x90,
+	0x42,
+	0x41,
+	0x74,
+	0x85,
+	0xf0,
+	0x90,
+	0x40,
+	0x00,
+	0xe0,
+	0x70,
+	0xfa,
+	0x85,
+	0x12,
+	0x81,
+	0xd0,
+	0x12,
+	0x22,
+	0xc0,
+	0x12,
+	0x85,
+	0x81,
+	0x12,
+	0xc0,
+	0x82,
+	0xc0,
+	0x83,
+	0xc0,
+	0xf0,
+	0xe5,
+	0x81,
+	0x24,
+	0x07,
+	0xf5,
+	0x81,
+	0xe5,
+	0x12,
+	0x24,
+	0x07,
+	0xfc,
+	0xe5,
+	0x12,
+	0x24,
+	0x04,
+	0xf8,
+	0xa6,
+	0x04,
+	0x08,
+	0x76,
+	0x00,
+	0x08,
+	0x76,
+	0x40,
+	0xe5,
+	0x12,
+	0x24,
+	0x04,
+	0xf8,
+	0x74,
+	0x03,
+	0x26,
+	0xfa,
+	0xe4,
+	0x08,
+	0x36,
+	0xfb,
+	0x08,
+	0x86,
+	0x04,
+	0xa8,
+	0x12,
+	0x08,
+	0x86,
+	0x82,
+	0x08,
+	0x86,
+	0x83,
+	0x08,
+	0x86,
+	0xf0,
+	0x12,
+	0xf4,
+	0x15,
+	0x8a,
+	0x82,
+	0x8b,
+	0x83,
+	0x8c,
+	0xf0,
+	0x12,
+	0xf3,
+	0x29,
+	0xe5,
+	0x12,
+	0x24,
+	0x04,
+	0xf8,
+	0x74,
+	0x02,
+	0x26,
+	0xfd,
+	0xe4,
+	0x08,
+	0x36,
+	0xfe,
+	0x08,
+	0x86,
+	0x07,
+	0xa8,
+	0x12,
+	0x08,
+	0x74,
+	0x01,
+	0x26,
+	0xfa,
+	0xe4,
+	0x08,
+	0x36,
+	0xfb,
+	0x08,
+	0x86,
+	0x04,
+	0x8a,
+	0x82,
+	0x8b,
+	0x83,
+	0x8c,
+	0xf0,
+	0x12,
+	0xf4,
+	0x15,
+	0x8d,
+	0x82,
+	0x8e,
+	0x83,
+	0x8f,
+	0xf0,
+	0x12,
+	0xf3,
+	0x29,
+	0xe5,
+	0x12,
+	0x24,
+	0x04,
+	0xf8,
+	0x74,
+	0x01,
+	0x26,
+	0xfd,
+	0xe4,
+	0x08,
+	0x36,
+	0xfe,
+	0x08,
+	0x86,
+	0x07,
+	0xa8,
+	0x12,
+	0x08,
+	0x74,
+	0x02,
+	0x26,
+	0xfa,
+	0xe4,
+	0x08,
+	0x36,
+	0xfb,
+	0x08,
+	0x86,
+	0x04,
+	0x8a,
+	0x82,
+	0x8b,
+	0x83,
+	0x8c,
+	0xf0,
+	0x12,
+	0xf4,
+	0x15,
+	0x8d,
+	0x82,
+	0x8e,
+	0x83,
+	0x8f,
+	0xf0,
+	0x12,
+	0xf3,
+	0x29,
+	0xa8,
+	0x12,
+	0x08,
+	0x74,
+	0x03,
+	0x26,
+	0xfd,
+	0xe4,
+	0x08,
+	0x36,
+	0xfe,
+	0x08,
+	0x86,
+	0x07,
+	0x8d,
+	0x82,
+	0x8e,
+	0x83,
+	0x8f,
+	0xf0,
+	0x12,
+	0xf4,
+	0x15,
+	0xfd,
+	0xe5,
+	0x12,
+	0x24,
+	0x04,
+	0xf8,
+	0x86,
+	0x82,
+	0x08,
+	0x86,
+	0x83,
+	0x08,
+	0x86,
+	0xf0,
+	0xed,
+	0x12,
+	0xf3,
+	0x29,
+	0xe5,
+	0x12,
+	0x24,
+	0x07,
+	0xf8,
+	0x86,
+	0x82,
+	0x08,
+	0x86,
+	0x83,
+	0x08,
+	0x86,
+	0xf0,
+	0x08,
+	0xe6,
+	0x85,
+	0x12,
+	0x81,
+	0xd0,
+	0x12,
+	0x22,
+	0x90,
+	0x30,
+	0x07,
+	0xe0,
+	0x54,
+	0xf0,
+	0xf0,
+	0x90,
+	0x30,
+	0x08,
+	0x74,
+	0x38,
+	0xf0,
+	0x7e,
+	0x00,
+	0x7f,
+	0x00,
+	0x74,
+	0xf5,
+	0x25,
+	0xb0,
+	0x40,
+	0x1a,
+	0x8e,
+	0x04,
+	0x8f,
+	0x05,
+	0x0e,
+	0xbe,
+	0x00,
+	0x01,
+	0x0f,
+	0xc3,
+	0x74,
+	0x10,
+	0x9c,
+	0x74,
+	0x27,
+	0x9d,
+	0x50,
+	0xe8,
+	0x75,
+	0xf7,
+	0x01,
+	0x75,
+	0xf7,
+	0x01,
+	0x80,
+	0xe0,
+	0x7e,
+	0x00,
+	0x7f,
+	0x00,
+	0xc3,
+	0xee,
+	0x94,
+	0x08,
+	0xef,
+	0x64,
+	0x80,
+	0x94,
+	0x80,
+	0x50,
+	0x19,
+	0x8e,
+	0x05,
+	0x74,
+	0x07,
+	0xc3,
+	0x9d,
+	0x24,
+	0xb0,
+	0xf5,
+	0x82,
+	0xe4,
+	0x34,
+	0x69,
+	0xf5,
+	0x83,
+	0xe5,
+	0xa0,
+	0xf0,
+	0x0e,
+	0xbe,
+	0x00,
+	0xdf,
+	0x0f,
+	0x80,
+	0xdc,
+	0x90,
+	0x69,
+	0xe7,
+	0xe5,
+	0xa0,
+	0xf0,
+	0xe5,
+	0xa0,
+	0xe5,
+	0xa0,
+	0x22,
+	0xc0,
+	0xe0,
+	0xc0,
+	0x82,
+	0xc0,
+	0x83,
+	0xc0,
+	0xd0,
+	0x75,
+	0xd0,
+	0x08,
+	0x90,
+	0x6c,
+	0x04,
+	0xe0,
+	0xff,
+	0x60,
+	0x26,
+	0x90,
+	0x69,
+	0xe2,
+	0x74,
+	0x01,
+	0xf0,
+	0x90,
+	0x30,
+	0x07,
+	0xe4,
+	0xf0,
+	0x90,
+	0x69,
+	0xf1,
+	0xf0,
+	0x90,
+	0x69,
+	0xf2,
+	0xf0,
+	0x90,
+	0x69,
+	0xef,
+	0xf0,
+	0x90,
+	0x6c,
+	0x08,
+	0xe4,
+	0xf0,
+	0x90,
+	0x30,
+	0x45,
+	0xf0,
+	0x90,
+	0x30,
+	0x0c,
+	0xf0,
+	0x80,
+	0x1f,
+	0x90,
+	0x30,
+	0x02,
+	0xe0,
+	0xff,
+	0x53,
+	0x0f,
+	0x20,
+	0xbf,
+	0x20,
+	0x04,
+	0x7f,
+	0x40,
+	0x80,
+	0x02,
+	0x7f,
+	0x00,
+	0x90,
+	0x30,
+	0x07,
+	0xef,
+	0xf0,
+	0x90,
+	0x69,
+	0xe7,
+	0xe4,
+	0xf0,
+	0x90,
+	0x6c,
+	0x34,
+	0xf0,
+	0x75,
+	0xf7,
+	0x01,
+	0x75,
+	0xf7,
+	0x01,
+	0xd0,
+	0xd0,
+	0xd0,
+	0x83,
+	0xd0,
+	0x82,
+	0xd0,
+	0xe0,
+	0x32,
+	0xc0,
+	0x20,
+	0xc0,
+	0xe0,
+	0xc0,
+	0xf0,
+	0xc0,
+	0x82,
+	0xc0,
+	0x83,
+	0xc0,
+	0x07,
+	0xc0,
+	0x06,
+	0xc0,
+	0x05,
+	0xc0,
+	0x04,
+	0xc0,
+	0x03,
+	0xc0,
+	0x02,
+	0xc0,
+	0x01,
+	0xc0,
+	0x00,
+	0xc0,
+	0xd0,
+	0x75,
+	0xd0,
+	0x08,
+	0xc2,
+	0xaa,
+	0x90,
+	0x69,
+	0xe3,
+	0x74,
+	0x01,
+	0xf0,
+	0x90,
+	0x69,
+	0xe4,
+	0xe5,
+	0xa0,
+	0xf0,
+	0x90,
+	0x6c,
+	0x04,
+	0xe0,
+	0xff,
+	0x70,
+	0x22,
+	0x90,
+	0x69,
+	0xe4,
+	0xe0,
+	0xff,
+	0xbf,
+	0x02,
+	0x1a,
+	0x90,
+	0x30,
+	0x07,
+	0xe4,
+	0xf0,
+	0x75,
+	0xd0,
+	0x00,
+	0x12,
+	0xad,
+	0xfe,
+	0x75,
+	0xd0,
+	0x08,
+	0x90,
+	0x6c,
+	0x34,
+	0x74,
+	0x01,
+	0xf0,
+	0x75,
+	0xf7,
+	0x01,
+	0x75,
+	0xf7,
+	0x01,
+	0xd0,
+	0xd0,
+	0xd0,
+	0x00,
+	0xd0,
+	0x01,
+	0xd0,
+	0x02,
+	0xd0,
+	0x03,
+	0xd0,
+	0x04,
+	0xd0,
+	0x05,
+	0xd0,
+	0x06,
+	0xd0,
+	0x07,
+	0xd0,
+	0x83,
+	0xd0,
+	0x82,
+	0xd0,
+	0xf0,
+	0xd0,
+	0xe0,
+	0xd0,
+	0x20,
+	0x32,
+	0xc2,
+	0x8c,
+	0xc2,
+	0xa9,
+	0xc2,
+	0x8e,
+	0xc2,
+	0xab,
+	0x22,
+	0xaf,
+	0x82,
+	0x90,
+	0x69,
+	0xd8,
+	0xef,
+	0xf0,
+	0x90,
+	0x69,
+	0xd9,
+	0xe4,
+	0xf0,
+	0x90,
+	0x30,
+	0x31,
+	0xe0,
+	0xff,
+	0x74,
+	0xff,
+	0xc3,
+	0x9f,
+	0xf5,
+	0x8c,
+	0xd2,
+	0x8c,
+	0xd2,
+	0xa9,
+	0x22,
+	0xaf,
+	0x82,
+	0x90,
+	0x69,
+	0xd8,
+	0xef,
+	0xf0,
+	0x90,
+	0x69,
+	0xd9,
+	0xe4,
+	0xf0,
+	0x75,
+	0x8c,
+	0x00,
+	0xd2,
+	0x8c,
+	0xd2,
+	0xa9,
+	0x22,
+	0xaf,
+	0x82,
+	0x90,
+	0x69,
+	0xda,
+	0xef,
+	0xf0,
+	0x90,
+	0x69,
+	0xdb,
+	0xe4,
+	0xf0,
+	0x90,
+	0x30,
+	0x31,
+	0xe0,
+	0xff,
+	0x74,
+	0xff,
+	0xc3,
+	0x9f,
+	0xf5,
+	0x8d,
+	0xd2,
+	0x8e,
+	0xd2,
+	0xab,
+	0x22,
+	0x90,
+	0x30,
+	0x0a,
+	0xe0,
+	0xff,
+	0xbf,
+	0xdb,
+	0x12,
+	0x90,
+	0x6c,
+	0x04,
+	0xe0,
+	0xff,
+	0x60,
+	0x04,
+	0x7f,
+	0x02,
+	0x80,
+	0x02,
+	0x7f,
+	0x84,
+	0x90,
+	0x30,
+	0x02,
+	0xef,
+	0xf0,
+	0x90,
+	0x30,
+	0x32,
+	0xe0,
+	0xf5,
+	0x82,
+	0x12,
+	0xaf,
+	0x74,
+	0x80,
+	0xfe,
+	0x7c,
+	0x80,
+	0x7d,
+	0x64,
+	0x53,
+	0x05,
+	0x0f,
+	0xe4,
+	0xfe,
+	0xc3,
+	0x13,
+	0xff,
+	0xee,
+	0x13,
+	0xfe,
+	0xed,
+	0x13,
+	0xfd,
+	0xec,
+	0x13,
+	0xfc,
+	0xef,
+	0xc3,
+	0x13,
+	0xee,
+	0x13,
+	0xed,
+	0x13,
+	0xfd,
+	0xec,
+	0x13,
+	0x90,
+	0x40,
+	0x04,
+	0xf0,
+	0xa3,
+	0xed,
+	0xf0,
+	0x90,
+	0x40,
+	0x0a,
+	0x74,
+	0x0a,
+	0xf0,
+	0x7c,
+	0x00,
+	0x7d,
+	0x69,
+	0x53,
+	0x05,
+	0x0f,
+	0xe4,
+	0xfe,
+	0xc3,
+	0x13,
+	0xff,
+	0xee,
+	0x13,
+	0xfe,
+	0xed,
+	0x13,
+	0xfd,
+	0xec,
+	0x13,
+	0xfc,
+	0xef,
+	0xc3,
+	0x13,
+	0xee,
+	0x13,
+	0xed,
+	0x13,
+	0xfd,
+	0xec,
+	0x13,
+	0x90,
+	0x40,
+	0x08,
+	0xf0,
+	0xa3,
+	0xed,
+	0xf0,
+	0x7c,
+	0x40,
+	0x7d,
+	0x69,
+	0x53,
+	0x05,
+	0x0f,
+	0xe4,
+	0xfe,
+	0xc3,
+	0x13,
+	0xff,
+	0xee,
+	0x13,
+	0xfe,
+	0xed,
+	0x13,
+	0xfd,
+	0xec,
+	0x13,
+	0xfc,
+	0xef,
+	0xc3,
+	0x13,
+	0xff,
+	0xee,
+	0x13,
+	0xfe,
+	0xed,
+	0x13,
+	0xfd,
+	0xec,
+	0x13,
+	0xfc,
+	0x90,
+	0x40,
+	0x0c,
+	0xf0,
+	0xa3,
+	0xed,
+	0xf0,
+	0x90,
+	0x42,
+	0x41,
+	0x74,
+	0x8b,
+	0xf0,
+	0x90,
+	0x40,
+	0x00,
+	0xe0,
+	0x70,
+	0xfa,
+	0x90,
+	0x42,
+	0x41,
+	0x74,
+	0x89,
+	0xf0,
+	0x90,
+	0x40,
+	0x00,
+	0xe0,
+	0x70,
+	0xfa,
+	0x90,
+	0x42,
+	0x41,
+	0x74,
+	0x8d,
+	0xf0,
+	0x90,
+	0x40,
+	0x00,
+	0xe0,
+	0x70,
+	0xfa,
+	0x22,
+	0xc0,
+	0x12,
+	0xe5,
+	0x81,
+	0xf5,
+	0x12,
+	0x24,
+	0x05,
+	0xf5,
+	0x81,
+	0x7e,
+	0x00,
+	0x7f,
+	0x00,
+	0xc3,
+	0xee,
+	0x94,
+	0x60,
+	0xef,
+	0x64,
+	0x80,
+	0x94,
+	0x80,
+	0x50,
+	0x41,
+	0x74,
+	0x60,
+	0x2e,
+	0xfc,
+	0xe4,
+	0x3f,
+	0xcc,
+	0x25,
+	0xe0,
+	0xcc,
+	0x33,
+	0xcc,
+	0x25,
+	0xe0,
+	0xcc,
+	0x33,
+	0x24,
+	0x60,
+	0xfd,
+	0xee,
+	0x4f,
+	0xb4,
+	0x01,
+	0x00,
+	0xe4,
+	0x33,
+	0xfb,
+	0x60,
+	0x04,
+	0x7b,
+	0x03,
+	0x80,
+	0x02,
+	0x7b,
+	0x00,
+	0x8b,
+	0x00,
+	0x79,
+	0x00,
+	0x7a,
+	0x00,
+	0x7b,
+	0x00,
+	0x8c,
+	0x82,
+	0x8d,
+	0x83,
+	0xe8,
+	0xf0,
+	0xa3,
+	0xe9,
+	0xf0,
+	0xa3,
+	0xea,
+	0xf0,
+	0xa3,
+	0xeb,
+	0xf0,
+	0x0e,
+	0xbe,
+	0x00,
+	0xb7,
+	0x0f,
+	0x80,
+	0xb4,
+	0xe5,
+	0x12,
+	0x24,
+	0x03,
+	0xf8,
+	0x74,
+	0x80,
+	0x24,
+	0x7b,
+	0xf6,
+	0x74,
+	0x01,
+	0x34,
+	0xf4,
+	0x08,
+	0xf6,
+	0x08,
+	0x76,
+	0x80,
+	0xa8,
+	0x12,
+	0x08,
+	0xe4,
+	0xf6,
+	0x08,
+	0xf6,
+	0xa8,
+	0x12,
+	0x08,
+	0xc3,
+	0xe6,
+	0x94,
+	0x60,
+	0x08,
+	0xe6,
+	0x64,
+	0x80,
+	0x94,
+	0x80,
+	0x50,
+	0x65,
+	0xa8,
+	0x12,
+	0x08,
+	0x86,
+	0x07,
+	0x08,
+	0xe6,
+	0xcf,
+	0x25,
+	0xe0,
+	0xcf,
+	0x33,
+	0xcf,
+	0x25,
+	0xe0,
+	0xcf,
+	0x33,
+	0x24,
+	0x60,
+	0xfe,
+	0x8f,
+	0x04,
+	0x8e,
+	0x03,
+	0xe5,
+	0x12,
+	0x24,
+	0x03,
+	0xf8,
+	0xe6,
+	0x24,
+	0xfc,
+	0xf6,
+	0x08,
+	0xe6,
+	0x34,
+	0xff,
+	0xf6,
+	0xe5,
+	0x12,
+	0x24,
+	0x03,
+	0xf8,
+	0x86,
+	0x05,
+	0x08,
+	0x86,
+	0x06,
+	0x08,
+	0x86,
+	0x07,
+	0x8d,
+	0x82,
+	0x8e,
+	0x83,
+	0x8f,
+	0xf0,
+	0xc0,
+	0x04,
+	0xc0,
+	0x03,
+	0x12,
+	0xad,
+	0x16,
+	0xaa,
+	0x82,
+	0xad,
+	0x83,
+	0xae,
+	0xf0,
+	0xff,
+	0xd0,
+	0x03,
+	0xd0,
+	0x04,
+	0x8c,
+	0x82,
+	0x8b,
+	0x83,
+	0xea,
+	0xf0,
+	0xa3,
+	0xed,
+	0xf0,
+	0xa3,
+	0xee,
+	0xf0,
+	0xa3,
+	0xef,
+	0xf0,
+	0xa8,
+	0x12,
+	0x08,
+	0x06,
+	0xb6,
+	0x00,
+	0x02,
+	0x08,
+	0x06,
+	0x80,
+	0x8c,
+	0x74,
+	0xc0,
+	0xc0,
+	0xe0,
+	0xe4,
+	0xc0,
+	0xe0,
+	0x74,
+	0xc0,
+	0xc0,
+	0xe0,
+	0xe4,
+	0xc0,
+	0xe0,
+	0x74,
+	0xc0,
+	0xc0,
+	0xe0,
+	0xe4,
+	0xc0,
+	0xe0,
+	0x74,
+	0x60,
+	0xc0,
+	0xe0,
+	0xe4,
+	0xc0,
+	0xe0,
+	0xe4,
+	0xc0,
+	0xe0,
+	0xc0,
+	0xe0,
+	0x74,
+	0x60,
+	0xc0,
+	0xe0,
+	0x75,
+	0x82,
+	0x00,
+	0x12,
+	0x8c,
+	0x11,
+	0xe5,
+	0x81,
+	0x24,
+	0xf5,
+	0xf5,
+	0x81,
+	0x85,
+	0x12,
+	0x81,
+	0xd0,
+	0x12,
+	0x22,
+	0xc0,
+	0x12,
+	0xe5,
+	0x81,
+	0xf5,
+	0x12,
+	0x24,
+	0x04,
+	0xf5,
+	0x81,
+	0x7e,
+	0x00,
+	0x7f,
+	0x00,
+	0xc3,
+	0xee,
+	0x94,
+	0x05,
+	0xef,
+	0x64,
+	0x80,
+	0x94,
+	0x80,
+	0x40,
+	0x03,
+	0x02,
+	0xb2,
+	0x31,
+	0x8e,
+	0x05,
+	0x74,
+	0x08,
+	0x2d,
+	0xc2,
+	0xd5,
+	0x75,
+	0xf0,
+	0x04,
+	0x30,
+	0xe7,
+	0x04,
+	0xb2,
+	0xd5,
+	0xf4,
+	0x04,
+	0xa4,
+	0x30,
+	0xd5,
+	0x0a,
+	0xf4,
+	0x24,
+	0x01,
+	0xc5,
+	0xf0,
+	0xf4,
+	0x34,
+	0x00,
+	0xc5,
+	0xf0,
+	0x24,
+	0x00,
+	0xf5,
+	0x82,
+	0x74,
+	0x63,
+	0x35,
+	0xf0,
+	0xf5,
+	0x83,
+	0xa8,
+	0x12,
+	0x08,
+	0xe0,
+	0xf6,
+	0xa3,
+	0xe0,
+	0x08,
+	0xf6,
+	0xa3,
+	0xe0,
+	0x08,
+	0xf6,
+	0xa3,
+	0xe0,
+	0x08,
+	0xf6,
+	0x74,
+	0x04,
+	0xc3,
+	0x9e,
+	0xfd,
+	0xe4,
+	0x9f,
+	0xcd,
+	0x25,
+	0xe0,
+	0xcd,
+	0x33,
+	0xcd,
+	0x25,
+	0xe0,
+	0xcd,
+	0x33,
+	0xfc,
+	0xc0,
+	0x06,
+	0xc0,
+	0x07,
+	0xed,
+	0x24,
+	0x67,
+	0xfd,
+	0xec,
+	0x34,
+	0xf4,
+	0xfc,
+	0x7b,
+	0x80,
+	0x8d,
+	0x82,
+	0x8c,
+	0x83,
+	0x8b,
+	0xf0,
+	0x12,
+	0xf4,
+	0x15,
+	0xfb,
+	0xa3,
+	0x12,
+	0xf4,
+	0x15,
+	0xfc,
+	0xa3,
+	0x12,
+	0xf4,
+	0x15,
+	0xfd,
+	0xa3,
+	0x12,
+	0xf4,
+	0x15,
+	0xfe,
+	0xa8,
+	0x12,
+	0x08,
+	0xe6,
+	0xb5,
+	0x03,
+	0x15,
+	0x08,
+	0xe6,
+	0xb5,
+	0x04,
+	0x10,
+	0x08,
+	0xe6,
+	0xb5,
+	0x05,
+	0x0b,
+	0x08,
+	0xe6,
+	0xb5,
+	0x06,
+	0x06,
+	0xd0,
+	0x07,
+	0xd0,
+	0x06,
+	0x80,
+	0x0a,
+	0xd0,
+	0x07,
+	0xd0,
+	0x06,
+	0x75,
+	0x82,
+	0x01,
+	0x02,
+	0xb2,
+	0xe4,
+	0x0e,
+	0xbe,
+	0x00,
+	0x01,
+	0x0f,
+	0x02,
+	0xb1,
+	0x82,
+	0x7e,
+	0x0d,
+	0x7f,
+	0x00,
+	0xc3,
+	0xee,
+	0x94,
+	0x5f,
+	0xef,
+	0x64,
+	0x80,
+	0x94,
+	0x80,
+	0x50,
+	0x3a,
+	0x8e,
+	0x04,
+	0xef,
+	0xcc,
+	0x25,
+	0xe0,
+	0xcc,
+	0x33,
+	0xcc,
+	0x25,
+	0xe0,
+	0xcc,
+	0x33,
+	0xfd,
+	0x8c,
+	0x82,
+	0x74,
+	0x63,
+	0x2d,
+	0xf5,
+	0x83,
+	0xe0,
+	0xfa,
+	0xa3,
+	0xe0,
+	0xfb,
+	0xa3,
+	0xe0,
+	0xfc,
+	0xa3,
+	0xe0,
+	0xfd,
+	0xba,
+	0xff,
+	0x0b,
+	0xbb,
+	0xff,
+	0x08,
+	0xbc,
+	0xff,
+	0x05,
+	0xbd,
+	0xff,
+	0x02,
+	0x80,
+	0x05,
+	0x75,
+	0x82,
+	0x01,
+	0x80,
+	0x71,
+	0x0e,
+	0xbe,
+	0x00,
+	0xbe,
+	0x0f,
+	0x80,
+	0xbb,
+	0x90,
+	0x64,
+	0x7c,
+	0xe0,
+	0xfc,
+	0xa3,
+	0xe0,
+	0xfd,
+	0xa3,
+	0xe0,
+	0xfe,
+	0xa3,
+	0xe0,
+	0xff,
+	0xbc,
+	0xff,
+	0x0b,
+	0xbd,
+	0xff,
+	0x08,
+	0xbe,
+	0x01,
+	0x05,
+	0xbf,
+	0x00,
+	0x02,
+	0x80,
+	0x05,
+	0x75,
+	0x82,
+	0x01,
+	0x80,
+	0x49,
+	0x7e,
+	0x00,
+	0x7f,
+	0x00,
+	0xc3,
+	0xee,
+	0x94,
+	0x20,
+	0xef,
+	0x64,
+	0x80,
+	0x94,
+	0x80,
+	0x50,
+	0x37,
+	0xee,
+	0x24,
+	0x00,
+	0xfb,
+	0xef,
+	0x34,
+	0x63,
+	0xfc,
+	0x7d,
+	0x00,
+	0x8b,
+	0x82,
+	0x8c,
+	0x83,
+	0x8d,
+	0xf0,
+	0x12,
+	0xf4,
+	0x15,
+	0xfb,
+	0x8e,
+	0x05,
+	0x74,
+	0x1f,
+	0xc3,
+	0x9d,
+	0x24,
+	0x40,
+	0xf5,
+	0x82,
+	0xe4,
+	0x34,
+	0x69,
+	0xf5,
+	0x83,
+	0xe0,
+	0xfd,
+	0xeb,
+	0xb5,
+	0x05,
+	0x02,
+	0x80,
+	0x05,
+	0x75,
+	0x82,
+	0x01,
+	0x80,
+	0x0a,
+	0x0e,
+	0xbe,
+	0x00,
+	0xc1,
+	0x0f,
+	0x80,
+	0xbe,
+	0x75,
+	0x82,
+	0x00,
+	0x85,
+	0x12,
+	0x81,
+	0xd0,
+	0x12,
+	0x22,
+	0x90,
+	0x30,
+	0x01,
+	0xe0,
+	0xff,
+	0x30,
+	0xe1,
+	0x31,
+	0x90,
+	0x69,
+	0xb4,
+	0x75,
+	0xf0,
+	0x00,
+	0x74,
+	0x20,
+	0x12,
+	0xf3,
+	0x29,
+	0xa3,
+	0x74,
+	0xe4,
+	0x12,
+	0xf3,
+	0x29,
+	0xa3,
+	0x74,
+	0xfa,
+	0x12,
+	0xf3,
+	0x29,
+	0xa3,
+	0x74,
+	0x18,
+	0x12,
+	0xf3,
+	0x29,
+	0x90,
+	0x69,
+	0xb0,
+	0x74,
+	0x49,
+	0xf0,
+	0xa3,
+	0x74,
+	0x51,
+	0xf0,
+	0xa3,
+	0x74,
+	0xfb,
+	0xf0,
+	0xa3,
+	0x74,
+	0x6a,
+	0xf0,
+	0x80,
+	0x12,
+	0x90,
+	0x69,
+	0xb4,
+	0x75,
+	0xf0,
+	0x00,
+	0x12,
+	0xec,
+	0xc0,
+	0x90,
+	0x69,
+	0xb0,
+	0x75,
+	0xf0,
+	0x00,
+	0x12,
+	0xec,
+	0xc0,
+	0x22,
+	0x90,
+	0x30,
+	0x0b,
+	0x74,
+	0x0c,
+	0xf0,
+	0x90,
+	0x30,
+	0x0c,
+	0x74,
+	0x80,
+	0xf0,
+	0x75,
+	0x90,
+	0x02,
+	0x7f,
+	0x00,
+	0xbf,
+	0x08,
+	0x00,
+	0x50,
+	0x13,
+	0x74,
+	0x07,
+	0xc3,
+	0x9f,
+	0x24,
+	0xb0,
+	0xf5,
+	0x82,
+	0xe4,
+	0x34,
+	0x69,
+	0xf5,
+	0x83,
+	0xe0,
+	0xf5,
+	0x90,
+	0x0f,
+	0x80,
+	0xe8,
+	0x75,
+	0x90,
+	0x02,
+	0x75,
+	0x90,
+	0x00,
+	0x75,
+	0x90,
+	0x00,
+	0x90,
+	0x30,
+	0x0c,
+	0xe0,
+	0xff,
+	0x30,
+	0xe6,
+	0xf8,
+	0x90,
+	0x30,
+	0x0c,
+	0xe4,
+	0xf0,
+	0x22,
+	0x74,
+	0xf8,
+	0x25,
+	0xb0,
+	0x50,
+	0xfa,
+	0x7e,
+	0x00,
+	0x7f,
+	0x00,
+	0xc3,
+	0xee,
+	0x94,
+	0x08,
+	0xef,
+	0x64,
+	0x80,
+	0x94,
+	0x80,
+	0x50,
+	0x19,
+	0x8e,
+	0x05,
+	0x74,
+	0x07,
+	0xc3,
+	0x9d,
+	0x24,
+	0x80,
+	0xf5,
+	0x82,
+	0xe4,
+	0x34,
+	0x69,
+	0xf5,
+	0x83,
+	0xe5,
+	0xa0,
+	0xf0,
+	0x0e,
+	0xbe,
+	0x00,
+	0xdf,
+	0x0f,
+	0x80,
+	0xdc,
+	0x22,
+	0xc0,
+	0x12,
+	0xe5,
+	0x81,
+	0xf5,
+	0x12,
+	0x24,
+	0x0a,
+	0xf5,
+	0x81,
+	0x74,
+	0xfa,
+	0x25,
+	0xb0,
+	0x40,
+	0x0c,
+	0x90,
+	0x69,
+	0xe1,
+	0xe0,
+	0xff,
+	0x60,
+	0xf3,
+	0x12,
+	0xaf,
+	0x90,
+	0x80,
+	0xee,
+	0xe4,
+	0xfe,
+	0xff,
+	0xe5,
+	0x12,
+	0x24,
+	0x03,
+	0xf8,
+	0xe4,
+	0xf6,
+	0x08,
+	0xf6,
+	0xa8,
+	0x12,
+	0x08,
+	0xe4,
+	0xf6,
+	0x08,
+	0xf6,
+	0xa8,
+	0x12,
+	0x08,
+	0xc3,
+	0xe6,
+	0x94,
+	0x05,
+	0x08,
+	0xe6,
+	0x64,
+	0x80,
+	0x94,
+	0x80,
+	0x50,
+	0x5e,
+	0xe5,
+	0x12,
+	0x24,
+	0x03,
+	0xf8,
+	0xe6,
+	0x24,
+	0x80,
+	0xf5,
+	0x82,
+	0x08,
+	0xe6,
+	0x34,
+	0x64,
+	0xf5,
+	0x83,
+	0xe5,
+	0xa0,
+	0xf0,
+	0xa8,
+	0x12,
+	0x08,
+	0x86,
+	0x03,
+	0x74,
+	0x04,
+	0xc3,
+	0x9b,
+	0x24,
+	0x40,
+	0xfa,
+	0xe4,
+	0x34,
+	0x30,
+	0xfb,
+	0xe5,
+	0x12,
+	0x24,
+	0x03,
+	0xf8,
+	0x86,
+	0x04,
+	0x08,
+	0x86,
+	0x05,
+	0xe5,
+	0x12,
+	0x24,
+	0x03,
+	0xf8,
+	0x06,
+	0xb6,
+	0x00,
+	0x02,
+	0x08,
+	0x06,
+	0xe5,
+	0x12,
+	0x24,
+	0x03,
+	0xf8,
+	0x86,
+	0x06,
+	0x08,
+	0x86,
+	0x07,
+	0xec,
+	0x24,
+	0x80,
+	0xf5,
+	0x82,
+	0xed,
+	0x34,
+	0x64,
+	0xf5,
+	0x83,
+	0xe0,
+	0xfd,
+	0x8a,
+	0x82,
+	0x8b,
+	0x83,
+	0xf0,
+	0xa8,
+	0x12,
+	0x08,
+	0x06,
+	0xb6,
+	0x00,
+	0x02,
+	0x08,
+	0x06,
+	0x80,
+	0x93,
+	0xe5,
+	0x12,
+	0x24,
+	0x03,
+	0xa8,
+	0x12,
+	0x08,
+	0xe4,
+	0xf6,
+	0x08,
+	0xf6,
+	0xa8,
+	0x12,
+	0x08,
+	0xc3,
+	0xe6,
+	0x94,
+	0x80,
+	0x08,
+	0xe6,
+	0x64,
+	0x80,
+	0x94,
+	0x80,
+	0x50,
+	0x71,
+	0x74,
+	0xff,
+	0x25,
+	0xb0,
+	0x40,
+	0x0c,
+	0x90,
+	0x69,
+	0xe1,
+	0xe0,
+	0xfb,
+	0x60,
+	0xf3,
+	0x12,
+	0xaf,
+	0x90,
+	0x80,
+	0xee,
+	0xe5,
+	0x12,
+	0x24,
+	0x03,
+	0xf8,
+	0xe6,
+	0x24,
+	0x80,
+	0xf5,
+	0x82,
+	0x08,
+	0xe6,
+	0x34,
+	0x64,
+	0xf5,
+	0x83,
+	0xe5,
+	0xa0,
+	0xf0,
+	0xa8,
+	0x12,
+	0x08,
+	0x86,
+	0x02,
+	0x74,
+	0x7f,
+	0xc3,
+	0x9a,
+	0x24,
+	0x00,
+	0xfa,
+	0xe4,
+	0x34,
+	0x6a,
+	0xfb,
+	0xe5,
+	0x12,
+	0x24,
+	0x03,
+	0xf8,
+	0x86,
+	0x04,
+	0x08,
+	0x86,
+	0x05,
+	0xe5,
+	0x12,
+	0x24,
+	0x03,
+	0xf8,
+	0x06,
+	0xb6,
+	0x00,
+	0x02,
+	0x08,
+	0x06,
+	0xe5,
+	0x12,
+	0x24,
+	0x03,
+	0xf8,
+	0x86,
+	0x06,
+	0x08,
+	0x86,
+	0x07,
+	0xec,
+	0x24,
+	0x80,
+	0xf5,
+	0x82,
+	0xed,
+	0x34,
+	0x64,
+	0xf5,
+	0x83,
+	0xe0,
+	0xfd,
+	0x8a,
+	0x82,
+	0x8b,
+	0x83,
+	0xf0,
+	0xa8,
+	0x12,
+	0x08,
+	0x06,
+	0xb6,
+	0x00,
+	0x02,
+	0x08,
+	0x06,
+	0x02,
+	0xb4,
+	0x4c,
+	0xe5,
+	0x12,
+	0x24,
+	0x03,
+	0xf8,
+	0x86,
+	0x06,
+	0x08,
+	0x86,
+	0x07,
+	0x74,
+	0xfb,
+	0x25,
+	0xb0,
+	0x40,
+	0x14,
+	0x90,
+	0x69,
+	0xe1,
+	0xe0,
+	0xfd,
+	0x60,
+	0xf3,
+	0xc0,
+	0x07,
+	0xc0,
+	0x06,
+	0x12,
+	0xaf,
+	0x90,
+	0xd0,
+	0x06,
+	0xd0,
+	0x07,
+	0x80,
+	0xe6,
+	0xa8,
+	0x12,
+	0x08,
+	0xe4,
+	0xf6,
+	0x08,
+	0xf6,
+	0xa8,
+	0x12,
+	0x08,
+	0xc3,
+	0xe6,
+	0x94,
+	0x03,
+	0x08,
+	0xe6,
+	0x64,
+	0x80,
+	0x94,
+	0x80,
+	0x50,
+	0x42,
+	0xee,
+	0x24,
+	0x80,
+	0xf5,
+	0x82,
+	0xef,
+	0x34,
+	0x64,
+	0xf5,
+	0x83,
+	0xe5,
+	0xa0,
+	0xf0,
+	0xa8,
+	0x12,
+	0x08,
+	0x86,
+	0x03,
+	0x74,
+	0x02,
+	0xc3,
+	0x9b,
+	0x24,
+	0x80,
+	0xfa,
+	0xe4,
+	0x34,
+	0x6a,
+	0xfb,
+	0x8e,
+	0x04,
+	0x8f,
+	0x05,
+	0x0e,
+	0xbe,
+	0x00,
+	0x01,
+	0x0f,
+	0xec,
+	0x24,
+	0x80,
+	0xf5,
+	0x82,
+	0xed,
+	0x34,
+	0x64,
+	0xf5,
+	0x83,
+	0xe0,
+	0xfd,
+	0x8a,
+	0x82,
+	0x8b,
+	0x83,
+	0xf0,
+	0xa8,
+	0x12,
+	0x08,
+	0x06,
+	0xb6,
+	0x00,
+	0x02,
+	0x08,
+	0x06,
+	0x80,
+	0xaf,
+	0xe5,
+	0x12,
+	0x24,
+	0x09,
+	0xfd,
+	0x7b,
+	0x00,
+	0x7c,
+	0x00,
+	0xc3,
+	0xeb,
+	0x94,
+	0x02,
+	0xec,
+	0x64,
+	0x80,
+	0x94,
+	0x80,
+	0x50,
+	0x6a,
+	0xee,
+	0x24,
+	0x80,
+	0xf5,
+	0x82,
+	0xef,
+	0x34,
+	0x64,
+	0xf5,
+	0x83,
+	0xe5,
+	0xa0,
+	0xf0,
+	0x8b,
+	0x02,
+	0x74,
+	0x01,
+	0xc3,
+	0x9a,
+	0x2d,
+	0xf9,
+	0xc0,
+	0x05,
+	0x8e,
+	0x02,
+	0x8f,
+	0x05,
+	0x0e,
+	0xbe,
+	0x00,
+	0x01,
+	0x0f,
+	0xea,
+	0x24,
+	0x80,
+	0xf5,
+	0x82,
+	0xed,
+	0x34,
+	0x64,
+	0xf5,
+	0x83,
+	0xe0,
+	0xf7,
+	0x90,
+	0x30,
+	0x01,
+	0xe0,
+	0xfd,
+	0x53,
+	0x05,
+	0x80,
+	0xbd,
+	0x80,
+	0x02,
+	0x80,
+	0x04,
+	0xd0,
+	0x05,
+	0x80,
+	0x26,
+	0xd0,
+	0x05,
+	0xeb,
+	0x2d,
+	0xf9,
+	0xe7,
+	0x60,
+	0x1e,
+	0x90,
+	0x69,
+	0xef,
+	0xe0,
+	0x24,
+	0x01,
+	0xf0,
+	0xc0,
+	0x07,
+	0xc0,
+	0x06,
+	0xc0,
+	0x05,
+	0xc0,
+	0x04,
+	0xc0,
+	0x03,
+	0x12,
+	0xaf,
+	0x90,
+	0xd0,
+	0x03,
+	0xd0,
+	0x04,
+	0xd0,
+	0x05,
+	0xd0,
+	0x06,
+	0xd0,
+	0x07,
+	0x0b,
+	0xbb,
+	0x00,
+	0x8e,
+	0x0c,
+	0x80,
+	0x8b,
+	0xed,
+	0x04,
+	0xf9,
+	0xe7,
+	0xc4,
+	0x54,
+	0x0f,
+	0x90,
+	0x69,
+	0xf8,
+	0xf0,
+	0xe5,
+	0x12,
+	0x24,
+	0x05,
+	0xfd,
+	0x7e,
+	0x00,
+	0x7f,
+	0x40,
+	0xa8,
+	0x12,
+	0x08,
+	0xe4,
+	0xf6,
+	0x08,
+	0xf6,
+	0xa8,
+	0x12,
+	0x08,
+	0xc3,
+	0xe6,
+	0x94,
+	0x60,
+	0x08,
+	0xe6,
+	0x64,
+	0x80,
+	0x94,
+	0x80,
+	0x40,
+	0x03,
+	0x02,
+	0xb6,
+	0xa4,
+	0x74,
+	0xfc,
+	0x25,
+	0xb0,
+	0x40,
+	0x18,
+	0x90,
+	0x69,
+	0xe1,
+	0xe0,
+	0xfa,
+	0x60,
+	0xf3,
+	0xc0,
+	0x07,
+	0xc0,
+	0x06,
+	0xc0,
+	0x05,
+	0x12,
+	0xaf,
+	0x90,
+	0xd0,
+	0x05,
+	0xd0,
+	0x06,
+	0xd0,
+	0x07,
+	0x80,
+	0xe2,
+	0x74,
+	0x03,
+	0x2d,
+	0xfa,
+	0xe4,
+	0x3e,
+	0xfb,
+	0x8f,
+	0x04,
+	0x8a,
+	0x82,
+	0x8b,
+	0x83,
+	0x8c,
+	0xf0,
+	0xe5,
+	0xa0,
+	0x12,
+	0xf3,
+	0x29,
+	0x74,
+	0x02,
+	0x2d,
+	0xfa,
+	0xe4,
+	0x3e,
+	0xfb,
+	0x8f,
+	0x04,
+	0x8a,
+	0x82,
+	0x8b,
+	0x83,
+	0x8c,
+	0xf0,
+	0xe5,
+	0xa0,
+	0x12,
+	0xf3,
+	0x29,
+	0x74,
+	0x01,
+	0x2d,
+	0xfa,
+	0xe4,
+	0x3e,
+	0xfb,
+	0x8f,
+	0x04,
+	0x8a,
+	0x82,
+	0x8b,
+	0x83,
+	0x8c,
+	0xf0,
+	0xe5,
+	0xa0,
+	0x12,
+	0xf3,
+	0x29,
+	0x8d,
+	0x82,
+	0x8e,
+	0x83,
+	0x8f,
+	0xf0,
+	0xe5,
+	0xa0,
+	0x12,
+	0xf3,
+	0x29,
+	0xa8,
+	0x12,
+	0x08,
+	0x74,
+	0x1f,
+	0xc3,
+	0x96,
+	0xfb,
+	0x74,
+	0x01,
+	0x08,
+	0x96,
+	0xcb,
+	0x25,
+	0xe0,
+	0xcb,
+	0x33,
+	0xcb,
+	0x25,
+	0xe0,
+	0xcb,
+	0x33,
+	0x24,
+	0x60,
+	0xfc,
+	0x8b,
+	0x82,
+	0x8c,
+	0x83,
+	0xe5,
+	0x12,
+	0x24,
+	0x05,
+	0xf8,
+	0xe6,
+	0xf0,
+	0xa3,
+	0x08,
+	0xe6,
+	0xf0,
+	0xa3,
+	0x08,
+	0xe6,
+	0xf0,
+	0xa3,
+	0x08,
+	0xe6,
+	0xf0,
+	0x90,
+	0x30,
+	0x00,
+	0xe0,
+	0xfc,
+	0xbc,
+	0x15,
+	0x08,
+	0x90,
+	0x30,
+	0x08,
+	0x74,
+	0x3f,
+	0xf0,
+	0x80,
+	0xfe,
+	0xa8,
+	0x12,
+	0x08,
+	0x06,
+	0xb6,
+	0x00,
+	0x02,
+	0x08,
+	0x06,
+	0x02,
+	0xb5,
+	0xe1,
+	0x12,
+	0xb3,
+	0x76,
+	0x74,
+	0xfd,
+	0x25,
+	0xb0,
+	0x50,
+	0xfa,
+	0x90,
+	0x69,
+	0xe5,
+	0xe5,
+	0xa0,
+	0xf0,
+	0xaf,
+	0xa0,
+	0x90,
+	0x30,
+	0x45,
+	0xe5,
+	0xa0,
+	0xf0,
+	0x90,
+	0x30,
+	0x01,
+	0xe0,
+	0xfe,
+	0x53,
+	0x06,
+	0x80,
+	0xbe,
+	0x80,
+	0x26,
+	0x90,
+	0x69,
+	0xe5,
+	0xe0,
+	0xfe,
+	0xbe,
+	0x02,
+	0x14,
+	0xef,
+	0x70,
+	0x11,
+	0x90,
+	0x30,
+	0x45,
+	0xe0,
+	0xff,
+	0x60,
+	0x14,
+	0x90,
+	0x30,
+	0x45,
+	0xe0,
+	0xff,
+	0xbf,
+	0x01,
+	0x02,
+	0x80,
+	0x0a,
+	0x90,
+	0x69,
+	0xef,
+	0xe0,
+	0x24,
+	0x01,
+	0xf0,
+	0x12,
+	0xaf,
+	0x90,
+	0x90,
+	0x30,
+	0x00,
+	0xe0,
+	0xff,
+	0x53,
+	0x07,
+	0x40,
+	0xbf,
+	0x40,
+	0x06,
+	0x90,
+	0x30,
+	0x2a,
+	0x74,
+	0x01,
+	0xf0,
+	0x85,
+	0x12,
+	0x81,
+	0xd0,
+	0x12,
+	0x22,
+	0x12,
+	0xaf,
+	0xb5,
+	0x12,
+	0xb0,
+	0x55,
+	0x02,
+	0xb1,
+	0x74,
+	0x90,
+	0x30,
+	0x00,
+	0xe0,
+	0xff,
+	0x53,
+	0x07,
+	0x40,
+	0xbf,
+	0x40,
+	0x0d,
+	0x90,
+	0x30,
+	0x00,
+	0xe0,
+	0xff,
+	0x53,
+	0x07,
+	0x80,
+	0xbf,
+	0x80,
+	0x02,
+	0x80,
+	0xf3,
+	0x90,
+	0x00,
+	0x00,
+	0x22,
+	0x7f,
+	0x01,
+	0x7e,
+	0x00,
+	0xbe,
+	0x05,
+	0x00,
+	0x50,
+	0x25,
+	0xee,
+	0x24,
+	0x88,
+	0xf5,
+	0x82,
+	0xe4,
+	0x34,
+	0x69,
+	0xf5,
+	0x83,
+	0xe0,
+	0xfd,
+	0xee,
+	0x24,
+	0x40,
+	0xf5,
+	0x82,
+	0xe4,
+	0x34,
+	0x30,
+	0xf5,
+	0x83,
+	0xe0,
+	0xfc,
+	0xed,
+	0xb5,
+	0x04,
+	0x02,
+	0x80,
+	0x04,
+	0x7f,
+	0x00,
+	0x80,
+	0x03,
+	0x0e,
+	0x80,
+	0xd6,
+	0xef,
+	0x60,
+	0x23,
+	0x7e,
+	0x00,
+	0xbe,
+	0x10,
+	0x00,
+	0x50,
+	0x1c,
+	0xee,
+	0x24,
+	0x68,
+	0xfc,
+	0xe4,
+	0x34,
+	0x63,
+	0xfd,
+	0xee,
+	0x24,
+	0xc0,
+	0xf5,
+	0x82,
+	0xe4,
+	0x34,
+	0x69,
+	0xf5,
+	0x83,
+	0xe0,
+	0xfb,
+	0x8c,
+	0x82,
+	0x8d,
+	0x83,
+	0xf0,
+	0x0e,
+	0x80,
+	0xdf,
+	0x7e,
+	0x00,
+	0x8f,
+	0x82,
+	0x8e,
+	0x83,
+	0x22,
+	0x90,
+	0x30,
+	0x01,
+	0xe0,
+	0xff,
+	0x30,
+	0xe1,
+	0x6b,
+	0x90,
+	0x63,
+	0x74,
+	0x75,
+	0xf0,
+	0x00,
+	0x74,
+	0x1b,
+	0x12,
+	0xf3,
+	0x29,
+	0xa3,
+	0x74,
+	0xc5,
+	0x12,
+	0xf3,
+	0x29,
+	0xa3,
+	0x74,
+	0xbc,
+	0x12,
+	0xf3,
+	0x29,
+	0xa3,
+	0x74,
+	0x68,
+	0x12,
+	0xf3,
+	0x29,
+	0x90,
+	0x63,
+	0x70,
+	0x75,
+	0xf0,
+	0x00,
+	0x74,
+	0xd0,
+	0x12,
+	0xf3,
+	0x29,
+	0xa3,
+	0x74,
+	0x1b,
+	0x12,
+	0xf3,
+	0x29,
+	0xa3,
+	0x74,
+	0xdb,
+	0x12,
+	0xf3,
+	0x29,
+	0xa3,
+	0x74,
+	0xa9,
+	0x12,
+	0xf3,
+	0x29,
+	0x90,
+	0x63,
+	0x6c,
+	0x75,
+	0xf0,
+	0x00,
+	0x74,
+	0x9a,
+	0x12,
+	0xf3,
+	0x29,
+	0xa3,
+	0x74,
+	0x5e,
+	0x12,
+	0xf3,
+	0x29,
+	0xa3,
+	0x74,
+	0xf1,
+	0x12,
+	0xf3,
+	0x29,
+	0xa3,
+	0x74,
+	0xfa,
+	0x12,
+	0xf3,
+	0x29,
+	0x90,
+	0x63,
+	0x68,
+	0x74,
+	0xb9,
+	0xf0,
+	0xa3,
+	0x74,
+	0xaf,
+	0xf0,
+	0xa3,
+	0x74,
+	0xa5,
+	0xf0,
+	0xa3,
+	0x74,
+	0xd8,
+	0xf0,
+	0x80,
+	0x24,
+	0x90,
+	0x63,
+	0x74,
+	0x75,
+	0xf0,
+	0x00,
+	0x12,
+	0xec,
+	0xc0,
+	0x90,
+	0x63,
+	0x70,
+	0x75,
+	0xf0,
+	0x00,
+	0x12,
+	0xec,
+	0xc0,
+	0x90,
+	0x63,
+	0x6c,
+	0x75,
+	0xf0,
+	0x00,
+	0x12,
+	0xec,
+	0xc0,
+	0x90,
+	0x63,
+	0x68,
+	0x75,
+	0xf0,
+	0x00,
+	0x12,
+	0xec,
+	0xc0,
+	0x22,
+	0xc0,
+	0x12,
+	0xe5,
+	0x81,
+	0xf5,
+	0x12,
+	0x24,
+	0x27,
+	0xf5,
+	0x81,
+	0x90,
+	0x40,
+	0x04,
+	0xe4,
+	0xf0,
+	0xa3,
+	0xf0,
+	0x90,
+	0x40,
+	0x0a,
+	0xf0,
+	0x7c,
+	0x00,
+	0x7d,
+	0x69,
+	0x53,
+	0x05,
+	0x0f,
+	0xe4,
+	0xfe,
+	0xc3,
+	0x13,
+	0xff,
+	0xee,
+	0x13,
+	0xfe,
+	0xed,
+	0x13,
+	0xfd,
+	0xec,
+	0x13,
+	0xfc,
+	0xef,
+	0xc3,
+	0x13,
+	0xee,
+	0x13,
+	0xed,
+	0x13,
+	0xfd,
+	0xec,
+	0x13,
+	0x90,
+	0x40,
+	0x08,
+	0xf0,
+	0xa3,
+	0xed,
+	0xf0,
+	0x7c,
+	0x40,
+	0x7d,
+	0x69,
+	0x53,
+	0x05,
+	0x0f,
+	0xe4,
+	0xfe,
+	0xc3,
+	0x13,
+	0xff,
+	0xee,
+	0x13,
+	0xfe,
+	0xed,
+	0x13,
+	0xfd,
+	0xec,
+	0x13,
+	0xfc,
+	0xef,
+	0xc3,
+	0x13,
+	0xff,
+	0xee,
+	0x13,
+	0xfe,
+	0xed,
+	0x13,
+	0xfd,
+	0xec,
+	0x13,
+	0xfc,
+	0x90,
+	0x40,
+	0x0c,
+	0xf0,
+	0xa3,
+	0xed,
+	0xf0,
+	0x90,
+	0x42,
+	0x41,
+	0x74,
+	0xa7,
+	0xf0,
+	0x90,
+	0x40,
+	0x00,
+	0xe0,
+	0x70,
+	0xfa,
+	0xfe,
+	0xff,
+	0xc3,
+	0xee,
+	0x94,
+	0x20,
+	0xef,
+	0x64,
+	0x80,
+	0x94,
+	0x80,
+	0x50,
+	0x24,
+	0x8e,
+	0x05,
+	0x74,
+	0x21,
+	0x2d,
+	0x24,
+	0xd8,
+	0xfc,
+	0xe4,
+	0x34,
+	0x63,
+	0xfd,
+	0xee,
+	0x24,
+	0x40,
+	0xf5,
+	0x82,
+	0xef,
+	0x34,
+	0x69,
+	0xf5,
+	0x83,
+	0xe0,
+	0xfb,
+	0x8c,
+	0x82,
+	0x8d,
+	0x83,
+	0xf0,
+	0x0e,
+	0xbe,
+	0x00,
+	0xd4,
+	0x0f,
+	0x80,
+	0xd1,
+	0xe5,
+	0x12,
+	0x24,
+	0x02,
+	0xff,
+	0xe5,
+	0x12,
+	0x24,
+	0x22,
+	0xf8,
+	0xa6,
+	0x07,
+	0x08,
+	0x76,
+	0x00,
+	0x08,
+	0x76,
+	0x40,
+	0x7b,
+	0x00,
+	0xbb,
+	0x20,
+	0x00,
+	0x50,
+	0x20,
+	0xc0,
+	0x07,
+	0xe5,
+	0x12,
+	0x24,
+	0x22,
+	0xf8,
+	0xeb,
+	0x26,
+	0xfa,
+	0xe4,
+	0x08,
+	0x36,
+	0xfe,
+	0x08,
+	0x86,
+	0x07,
+	0x8a,
+	0x82,
+	0x8e,
+	0x83,
+	0x8f,
+	0xf0,
+	0xeb,
+	0x12,
+	0xf3,
+	0x29,
+	0x0b,
+	0xd0,
+	0x07,
+	0x80,
+	0xdb,
+	0x7e,
+	0x00,
+	0xbe,
+	0x2e,
+	0x00,
+	0x50,
+	0x11,
+	0x74,
+	0x41,
+	0x2e,
+	0x24,
+	0xd8,
+	0xf5,
+	0x82,
+	0xe4,
+	0x34,
+	0x63,
+	0xf5,
+	0x83,
+	0xe4,
+	0xf0,
+	0x0e,
+	0x80,
+	0xea,
+	0x90,
+	0x64,
+	0x47,
+	0x74,
+	0x01,
+	0xf0,
+	0x7e,
+	0x00,
+	0xbe,
+	0x10,
+	0x00,
+	0x50,
+	0x36,
+	0xc0,
+	0x07,
+	0x74,
+	0x70,
+	0x2e,
+	0x24,
+	0xd8,
+	0xfc,
+	0xe4,
+	0x34,
+	0x63,
+	0xfd,
+	0x8e,
+	0x02,
+	0x7b,
+	0x00,
+	0x74,
+	0x0f,
+	0xc3,
+	0x9a,
+	0xfa,
+	0xe4,
+	0x9b,
+	0xfb,
+	0xea,
+	0x24,
+	0x68,
+	0xfa,
+	0xeb,
+	0x34,
+	0x63,
+	0xfb,
+	0x7f,
+	0x00,
+	0x8a,
+	0x82,
+	0x8b,
+	0x83,
+	0x8f,
+	0xf0,
+	0x12,
+	0xf4,
+	0x15,
+	0xfa,
+	0x8c,
+	0x82,
+	0x8d,
+	0x83,
+	0xf0,
+	0x0e,
+	0xd0,
+	0x07,
+	0x80,
+	0xc5,
+	0x8f,
+	0x06,
+	0x7d,
+	0x00,
+	0x7c,
+	0x40,
+	0xc0,
+	0x07,
+	0x74,
+	0x79,
+	0xc0,
+	0xe0,
+	0x74,
+	0x63,
+	0xc0,
+	0xe0,
+	0xe4,
+	0xc0,
+	0xe0,
+	0x74,
+	0x5f,
+	0xc0,
+	0xe0,
+	0xe4,
+	0xc0,
+	0xe0,
+	0x74,
+	0x20,
+	0xc0,
+	0xe0,
+	0xe4,
+	0xc0,
+	0xe0,
+	0x8e,
+	0x82,
+	0x8d,
+	0x83,
+	0x8c,
+	0xf0,
+	0x12,
+	0x9a,
+	0x67,
+	0xe5,
+	0x81,
+	0x24,
+	0xf9,
+	0xf5,
+	0x81,
+	0x74,
+	0x5f,
+	0xc0,
+	0xe0,
+	0xe4,
+	0xc0,
+	0xe0,
+	0x74,
+	0x79,
+	0xc0,
+	0xe0,
+	0x74,
+	0x63,
+	0xc0,
+	0xe0,
+	0xe4,
+	0xc0,
+	0xe0,
+	0x74,
+	0x79,
+	0xc0,
+	0xe0,
+	0x74,
+	0x63,
+	0xc0,
+	0xe0,
+	0xe4,
+	0xc0,
+	0xe0,
+	0x90,
+	0x63,
+	0xf9,
+	0x75,
+	0xf0,
+	0x00,
+	0x12,
+	0x9e,
+	0x7c,
+	0xe5,
+	0x81,
+	0x24,
+	0xf8,
+	0xf5,
+	0x81,
+	0xd0,
+	0x07,
+	0x7e,
+	0x00,
+	0xbe,
+	0x5f,
+	0x00,
+	0x50,
+	0x1e,
+	0x74,
+	0x21,
+	0x2e,
+	0x24,
+	0xd8,
+	0xfc,
+	0xe4,
+	0x34,
+	0x63,
+	0xfd,
+	0xee,
+	0x24,
+	0x79,
+	0xf5,
+	0x82,
+	0xe4,
+	0x34,
+	0x63,
+	0xf5,
+	0x83,
+	0xe0,
+	0xfb,
+	0x8c,
+	0x82,
+	0x8d,
+	0x83,
+	0xf0,
+	0x0e,
+	0x80,
+	0xdd,
+	0xc0,
+	0x07,
+	0x74,
+	0xd9,
+	0xc0,
+	0xe0,
+	0x74,
+	0x63,
+	0xc0,
+	0xe0,
+	0xe4,
+	0xc0,
+	0xe0,
+	0x74,
+	0x20,
+	0xc0,
+	0xe0,
+	0xe4,
+	0xc0,
+	0xe0,
+	0x74,
+	0x5f,
+	0xc0,
+	0xe0,
+	0xe4,
+	0xc0,
+	0xe0,
+	0x90,
+	0x63,
+	0x79,
+	0x75,
+	0xf0,
+	0x00,
+	0x12,
+	0x9a,
+	0x67,
+	0xe5,
+	0x81,
+	0x24,
+	0xf9,
+	0xf5,
+	0x81,
+	0xd0,
+	0x07,
+	0x7e,
+	0x00,
+	0x7d,
+	0x40,
+	0x74,
+	0x20,
+	0xc0,
+	0xe0,
+	0xe4,
+	0xc0,
+	0xe0,
+	0x74,
+	0xd9,
+	0xc0,
+	0xe0,
+	0x74,
+	0x63,
+	0xc0,
+	0xe0,
+	0xe4,
+	0xc0,
+	0xe0,
+	0x74,
+	0xd9,
+	0xc0,
+	0xe0,
+	0x74,
+	0x63,
+	0xc0,
+	0xe0,
+	0xe4,
+	0xc0,
+	0xe0,
+	0x8f,
+	0x82,
+	0x8e,
+	0x83,
+	0x8d,
+	0xf0,
+	0x12,
+	0x9e,
+	0x7c,
+	0xe5,
+	0x81,
+	0x24,
+	0xf8,
+	0xf5,
+	0x81,
+	0x90,
+	0x63,
+	0xd8,
+	0xe4,
+	0xf0,
+	0xe5,
+	0x12,
+	0x24,
+	0x25,
+	0xf8,
+	0x76,
+	0x58,
+	0x08,
+	0x76,
+	0x64,
+	0x08,
+	0x76,
+	0x00,
+	0xa8,
+	0x12,
+	0x08,
+	0x76,
+	0x00,
+	0xa8,
+	0x12,
+	0x08,
+	0xb6,
+	0x20,
+	0x00,
+	0x50,
+	0x60,
+	0xe5,
+	0x12,
+	0x24,
+	0x25,
+	0xf8,
+	0xe6,
+	0x24,
+	0xfc,
+	0xf6,
+	0x08,
+	0xe6,
+	0x34,
+	0xff,
+	0xf6,
+	0xa8,
+	0x12,
+	0x08,
+	0x86,
+	0x02,
+	0x7b,
+	0x00,
+	0x74,
+	0x50,
+	0x2a,
+	0xfa,
+	0xe4,
+	0x3b,
+	0xca,
+	0x25,
+	0xe0,
+	0xca,
+	0x33,
+	0xca,
+	0x25,
+	0xe0,
+	0xca,
+	0x33,
+	0x24,
+	0x60,
+	0xfb,
+	0x8a,
+	0x06,
+	0x8b,
+	0x05,
+	0xe5,
+	0x12,
+	0x24,
+	0x25,
+	0xf8,
+	0x86,
+	0x82,
+	0x08,
+	0x86,
+	0x83,
+	0x08,
+	0x86,
+	0xf0,
+	0xc0,
+	0x06,
+	0xc0,
+	0x05,
+	0x12,
+	0xad,
+	0x16,
+	0xaa,
+	0x82,
+	0xab,
+	0x83,
+	0xac,
+	0xf0,
+	0xff,
+	0xd0,
+	0x05,
+	0xd0,
+	0x06,
+	0x8e,
+	0x82,
+	0x8d,
+	0x83,
+	0xea,
+	0xf0,
+	0xa3,
+	0xeb,
+	0xf0,
+	0xa3,
+	0xec,
+	0xf0,
+	0xa3,
+	0xef,
+	0xf0,
+	0xa8,
+	0x12,
+	0x08,
+	0x06,
+	0x80,
+	0x98,
+	0x85,
+	0x12,
+	0x81,
+	0xd0,
+	0x12,
+	0x22,
+	0xc0,
+	0x12,
+	0xe5,
+	0x81,
+	0xf5,
+	0x12,
+	0x24,
+	0x0f,
+	0xf5,
+	0x81,
+	0x12,
+	0xb8,
+	0x1b,
+	0xe5,
+	0x12,
+	0x24,
+	0x03,
+	0xf8,
+	0x76,
+	0x83,
+	0x08,
+	0x76,
+	0x6a,
+	0x08,
+	0x76,
+	0x00,
+	0xe5,
+	0x12,
+	0x24,
+	0x06,
+	0xfc,
+	0xe5,
+	0x12,
+	0x24,
+	0x0a,
+	0xf8,
+	0xa6,
+	0x04,
+	0x08,
+	0x76,
+	0x00,
+	0x08,
+	0x76,
+	0x40,
+	0xe5,
+	0x12,
+	0x24,
+	0x03,
+	0xf8,
+	0x16,
+	0xb6,
+	0xff,
+	0x02,
+	0x08,
+	0x16,
+	0xe5,
+	0x12,
+	0x24,
+	0x03,
+	0xf8,
+	0x86,
+	0x82,
+	0x08,
+	0x86,
+	0x83,
+	0x08,
+	0x86,
+	0xf0,
+	0x12,
+	0xf4,
+	0x15,
+	0xfc,
+	0xe5,
+	0x12,
+	0x24,
+	0x0a,
+	0xf8,
+	0x86,
+	0x82,
+	0x08,
+	0x86,
+	0x83,
+	0x08,
+	0x86,
+	0xf0,
+	0xec,
+	0x12,
+	0xf3,
+	0x29,
+	0xe5,
+	0x12,
+	0x24,
+	0x0a,
+	0xf8,
+	0x74,
+	0x01,
+	0x26,
+	0xfa,
+	0xe4,
+	0x08,
+	0x36,
+	0xfb,
+	0x08,
+	0x86,
+	0x04,
+	0xe5,
+	0x12,
+	0x24,
+	0x03,
+	0xf8,
+	0x16,
+	0xb6,
+	0xff,
+	0x02,
+	0x08,
+	0x16,
+	0xe5,
+	0x12,
+	0x24,
+	0x03,
+	0xf8,
+	0x86,
+	0x82,
+	0x08,
+	0x86,
+	0x83,
+	0x08,
+	0x86,
+	0xf0,
+	0x12,
+	0xf4,
+	0x15,
+	0x8a,
+	0x82,
+	0x8b,
+	0x83,
+	0x8c,
+	0xf0,
+	0x12,
+	0xf3,
+	0x29,
+	0xe5,
+	0x12,
+	0x24,
+	0x0a,
+	0xf8,
+	0x74,
+	0x02,
+	0x26,
+	0xfd,
+	0xe4,
+	0x08,
+	0x36,
+	0xfe,
+	0x08,
+	0x86,
+	0x07,
+	0xe5,
+	0x12,
+	0x24,
+	0x03,
+	0xf8,
+	0x16,
+	0xb6,
+	0xff,
+	0x02,
+	0x08,
+	0x16,
+	0xe5,
+	0x12,
+	0x24,
+	0x03,
+	0xf8,
+	0x86,
+	0x82,
+	0x08,
+	0x86,
+	0x83,
+	0x08,
+	0x86,
+	0xf0,
+	0x12,
+	0xf4,
+	0x15,
+	0xfc,
+	0x8d,
+	0x82,
+	0x8e,
+	0x83,
+	0x8f,
+	0xf0,
+	0x12,
+	0xf3,
+	0x29,
+	0xe5,
+	0x12,
+	0x24,
+	0x0a,
+	0xf8,
+	0x74,
+	0x03,
+	0x26,
+	0xfd,
+	0xe4,
+	0x08,
+	0x36,
+	0xfe,
+	0x08,
+	0x86,
+	0x07,
+	0x8d,
+	0x82,
+	0x8e,
+	0x83,
+	0x8f,
+	0xf0,
+	0xe4,
+	0x12,
+	0xf3,
+	0x29,
+	0x90,
+	0x60,
+	0x80,
+	0xe5,
+	0x12,
+	0x24,
+	0x06,
+	0xf8,
+	0xe6,
+	0xf0,
+	0xa3,
+	0x08,
+	0xe6,
+	0xf0,
+	0xa3,
+	0x08,
+	0xe6,
+	0xf0,
+	0xa3,
+	0x08,
+	0xe6,
+	0xf0,
+	0x7e,
+	0x01,
+	0x7f,
+	0x00,
+	0xc3,
+	0xee,
+	0x94,
+	0x20,
+	0xef,
+	0x64,
+	0x80,
+	0x94,
+	0x80,
+	0x50,
+	0x26,
+	0x74,
+	0x20,
+	0x2e,
+	0xfc,
+	0xe4,
+	0x3f,
+	0xcc,
+	0x25,
+	0xe0,
+	0xcc,
+	0x33,
+	0xcc,
+	0x25,
+	0xe0,
+	0xcc,
+	0x33,
+	0x24,
+	0x60,
+	0xfd,
+	0x8c,
+	0x82,
+	0x8d,
+	0x83,
+	0xe4,
+	0xf0,
+	0xa3,
+	0xf0,
+	0xa3,
+	0xf0,
+	0xa3,
+	0xf0,
+	0x0e,
+	0xbe,
+	0x00,
+	0xd2,
+	0x0f,
+	0x80,
+	0xcf,
+	0xe5,
+	0x12,
+	0x24,
+	0x0d,
+	0xf8,
+	0x76,
+	0x00,
+	0x08,
+	0x76,
+	0x6a,
+	0x08,
+	0x76,
+	0x00,
+	0xa8,
+	0x12,
+	0x08,
+	0xe4,
+	0xf6,
+	0x08,
+	0xf6,
+	0xa8,
+	0x12,
+	0x08,
+	0xc3,
+	0xe6,
+	0x94,
+	0x20,
+	0x08,
+	0xe6,
+	0x64,
+	0x80,
+	0x94,
+	0x80,
+	0x50,
+	0x65,
+	0xa8,
+	0x12,
+	0x08,
+	0x86,
+	0x02,
+	0x08,
+	0xe6,
+	0xca,
+	0x25,
+	0xe0,
+	0xca,
+	0x33,
+	0xca,
+	0x25,
+	0xe0,
+	0xca,
+	0x33,
+	0x24,
+	0x60,
+	0xfc,
+	0x8a,
+	0x06,
+	0x8c,
+	0x05,
+	0xe5,
+	0x12,
+	0x24,
+	0x0d,
+	0xf8,
+	0x86,
+	0x02,
+	0x08,
+	0x86,
+	0x03,
+	0x08,
+	0x86,
+	0x04,
+	0x8a,
+	0x82,
+	0x8b,
+	0x83,
+	0x8c,
+	0xf0,
+	0x12,
+	0xf4,
+	0x15,
+	0xfa,
+	0xa3,
+	0x12,
+	0xf4,
+	0x15,
+	0xfb,
+	0xa3,
+	0x12,
+	0xf4,
+	0x15,
+	0xfc,
+	0xa3,
+	0x12,
+	0xf4,
+	0x15,
+	0xff,
+	0x8e,
+	0x82,
+	0x8d,
+	0x83,
+	0xea,
+	0xf0,
+	0xa3,
+	0xeb,
+	0xf0,
+	0xa3,
+	0xec,
+	0xf0,
+	0xa3,
+	0xef,
+	0xf0,
+	0xe5,
+	0x12,
+	0x24,
+	0x0d,
+	0xf8,
+	0x74,
+	0x04,
+	0x26,
+	0xf6,
+	0xe4,
+	0x08,
+	0x36,
+	0xf6,
+	0xa8,
+	0x12,
+	0x08,
+	0x06,
+	0xb6,
+	0x00,
+	0x02,
+	0x08,
+	0x06,
+	0x80,
+	0x8c,
+	0x74,
+	0x50,
+	0xc0,
+	0xe0,
+	0xe4,
+	0xc0,
+	0xe0,
+	0x74,
+	0x50,
+	0xc0,
+	0xe0,
+	0xe4,
+	0xc0,
+	0xe0,
+	0x74,
+	0x50,
+	0xc0,
+	0xe0,
+	0xe4,
+	0xc0,
+	0xe0,
+	0x74,
+	0x20,
+	0xc0,
+	0xe0,
+	0xe4,
+	0xc0,
+	0xe0,
+	0xe4,
+	0xc0,
+	0xe0,
+	0xc0,
+	0xe0,
+	0x74,
+	0x20,
+	0xc0,
+	0xe0,
+	0x75,
+	0x82,
+	0x00,
+	0x12,
+	0x8c,
+	0x11,
+	0xe5,
+	0x81,
+	0x24,
+	0xf5,
+	0xf5,
+	0x81,
+	0x85,
+	0x12,
+	0x81,
+	0xd0,
+	0x12,
+	0x22,
+	0xc0,
+	0x12,
+	0xe5,
+	0x81,
+	0xf5,
+	0x12,
+	0x24,
+	0x0f,
+	0xf5,
+	0x81,
+	0x90,
+	0x30,
+	0x0b,
+	0x74,
+	0x81,
+	0xf0,
+	0x90,
+	0x30,
+	0x0c,
+	0x74,
+	0x80,
+	0xf0,
+	0x75,
+	0x90,
+	0x04,
+	0xe5,
+	0x12,
+	0x24,
+	0x06,
+	0xff,
+	0xe5,
+	0x12,
+	0x24,
+	0x03,
+	0xf8,
+	0xa6,
+	0x07,
+	0x08,
+	0x76,
+	0x00,
+	0x08,
+	0x76,
+	0x40,
+	0xe5,
+	0x12,
+	0x24,
+	0x03,
+	0xf8,
+	0x74,
+	0x03,
+	0x26,
+	0xfa,
+	0xe4,
+	0x08,
+	0x36,
+	0xfb,
+	0x08,
+	0x86,
+	0x04,
+	0xe5,
+	0x12,
+	0x24,
+	0x03,
+	0xf8,
+	0xe5,
+	0x12,
+	0x24,
+	0x0a,
+	0xf9,
+	0x74,
+	0x02,
+	0x26,
+	0xf7,
+	0xe4,
+	0x08,
+	0x36,
+	0x09,
+	0xf7,
+	0x08,
+	0x09,
+	0xe6,
+	0xf7,
+	0xe5,
+	0x12,
+	0x24,
+	0x03,
+	0xf8,
+	0xe5,
+	0x12,
+	0x24,
+	0x0d,
+	0xf9,
+	0x74,
+	0x01,
+	0x26,
+	0xf7,
+	0xe4,
+	0x08,
+	0x36,
+	0x09,
+	0xf7,
+	0x08,
+	0x09,
+	0xe6,
+	0xf7,
+	0xa8,
+	0x12,
+	0x08,
+	0x76,
+	0x1f,
+	0x08,
+	0x76,
+	0x00,
+	0xa8,
+	0x12,
+	0x08,
+	0x08,
+	0xe6,
+	0x30,
+	0xe7,
+	0x03,
+	0x02,
+	0xbd,
+	0x97,
+	0x74,
+	0xf8,
+	0x25,
+	0x90,
+	0x50,
+	0xfa,
+	0xa8,
+	0x12,
+	0x08,
+	0x74,
+	0x50,
+	0x26,
+	0xfd,
+	0xe4,
+	0x08,
+	0x36,
+	0xcd,
+	0x25,
+	0xe0,
+	0xcd,
+	0x33,
+	0xcd,
+	0x25,
+	0xe0,
+	0xcd,
+	0x33,
+	0x24,
+	0x60,
+	0xff,
+	0x8d,
+	0x82,
+	0x8f,
+	0x83,
+	0xe5,
+	0x12,
+	0x24,
+	0x06,
+	0xf8,
+	0xe0,
+	0xf6,
+	0xa3,
+	0xe0,
+	0x08,
+	0xf6,
+	0xa3,
+	0xe0,
+	0x08,
+	0xf6,
+	0xa3,
+	0xe0,
+	0x08,
+	0xf6,
+	0x8a,
+	0x82,
+	0x8b,
+	0x83,
+	0x8c,
+	0xf0,
+	0x12,
+	0xf4,
+	0x15,
+	0xf5,
+	0x90,
+	0xe5,
+	0x12,
+	0x24,
+	0x0a,
+	0xf8,
+	0x86,
+	0x82,
+	0x08,
+	0x86,
+	0x83,
+	0x08,
+	0x86,
+	0xf0,
+	0x12,
+	0xf4,
+	0x15,
+	0xf5,
+	0x90,
+	0xe5,
+	0x12,
+	0x24,
+	0x0d,
+	0xf8,
+	0x86,
+	0x82,
+	0x08,
+	0x86,
+	0x83,
+	0x08,
+	0x86,
+	0xf0,
+	0x12,
+	0xf4,
+	0x15,
+	0xf5,
+	0x90,
+	0xe5,
+	0x12,
+	0x24,
+	0x03,
+	0xf8,
+	0x86,
+	0x82,
+	0x08,
+	0x86,
+	0x83,
+	0x08,
+	0x86,
+	0xf0,
+	0x12,
+	0xf4,
+	0x15,
+	0xf5,
+	0x90,
+	0xa8,
+	0x12,
+	0x08,
+	0x16,
+	0xb6,
+	0xff,
+	0x02,
+	0x08,
+	0x16,
+	0x02,
+	0xbd,
+	0x0b,
+	0x90,
+	0x30,
+	0x0c,
+	0xe0,
+	0xff,
+	0x30,
+	0xe6,
+	0xf8,
+	0x90,
+	0x30,
+	0x0c,
+	0xe4,
+	0xf0,
+	0x85,
+	0x12,
+	0x81,
+	0xd0,
+	0x12,
+	0x22,
+	0x90,
+	0x30,
+	0x0b,
+	0x74,
+	0x21,
+	0xf0,
+	0x90,
+	0x30,
+	0x0c,
+	0x74,
+	0x80,
+	0xf0,
+	0x75,
+	0x90,
+	0x05,
+	0x74,
+	0xf0,
+	0x25,
+	0x90,
+	0x50,
+	0xfa,
+	0x7e,
+	0x00,
+	0x7f,
+	0x00,
+	0xc3,
+	0xee,
+	0x94,
+	0x10,
+	0xef,
+	0x64,
+	0x80,
+	0x94,
+	0x80,
+	0x50,
+	0x19,
+	0x8e,
+	0x05,
+	0x74,
+	0x0f,
+	0xc3,
+	0x9d,
+	0x24,
+	0xa0,
+	0xf5,
+	0x82,
+	0xe4,
+	0x34,
+	0x69,
+	0xf5,
+	0x83,
+	0xe0,
+	0xf5,
+	0x90,
+	0x0e,
+	0xbe,
+	0x00,
+	0xdf,
+	0x0f,
+	0x80,
+	0xdc,
+	0x74,
+	0xf0,
+	0x25,
+	0x90,
+	0x50,
+	0xfa,
+	0x7e,
+	0x00,
+	0x7f,
+	0x00,
+	0xc3,
+	0xee,
+	0x94,
+	0x10,
+	0xef,
+	0x64,
+	0x80,
+	0x94,
+	0x80,
+	0x50,
+	0x19,
+	0x8e,
+	0x05,
+	0x74,
+	0x0f,
+	0xc3,
+	0x9d,
+	0x24,
+	0x90,
+	0xf5,
+	0x82,
+	0xe4,
+	0x34,
+	0x69,
+	0xf5,
+	0x83,
+	0xe0,
+	0xf5,
+	0x90,
+	0x0e,
+	0xbe,
+	0x00,
+	0xdf,
+	0x0f,
+	0x80,
+	0xdc,
+	0x90,
+	0x30,
+	0x0c,
+	0xe0,
+	0xff,
+	0x30,
+	0xe6,
+	0xf8,
+	0x90,
+	0x30,
+	0x0c,
+	0xe4,
+	0xf0,
+	0x22,
+	0x74,
+	0xf0,
+	0x25,
+	0xb0,
+	0x50,
+	0xfa,
+	0x7e,
+	0x00,
+	0x7f,
+	0x00,
+	0xc3,
+	0xee,
+	0x94,
+	0x10,
+	0xef,
+	0x64,
+	0x80,
+	0x94,
+	0x80,
+	0x50,
+	0x14,
+	0xee,
+	0x24,
+	0xa0,
+	0xf5,
+	0x82,
+	0xef,
+	0x34,
+	0x64,
+	0xf5,
+	0x83,
+	0xe5,
+	0xa0,
+	0xf0,
+	0x0e,
+	0xbe,
+	0x00,
+	0xe4,
+	0x0f,
+	0x80,
+	0xe1,
+	0x74,
+	0xf0,
+	0x25,
+	0xb0,
+	0x50,
+	0xfa,
+	0x7e,
+	0x10,
+	0x7f,
+	0x00,
+	0xc3,
+	0xee,
+	0x94,
+	0x20,
+	0xef,
+	0x64,
+	0x80,
+	0x94,
+	0x80,
+	0x50,
+	0x14,
+	0xee,
+	0x24,
+	0xa0,
+	0xf5,
+	0x82,
+	0xef,
+	0x34,
+	0x64,
+	0xf5,
+	0x83,
+	0xe5,
+	0xa0,
+	0xf0,
+	0x0e,
+	0xbe,
+	0x00,
+	0xe4,
+	0x0f,
+	0x80,
+	0xe1,
+	0x22,
+	0x7e,
+	0x00,
+	0x7f,
+	0x00,
+	0xc3,
+	0xee,
+	0x94,
+	0x20,
+	0xef,
+	0x64,
+	0x80,
+	0x94,
+	0x80,
+	0x50,
+	0x29,
+	0xee,
+	0x24,
+	0xa0,
+	0xf5,
+	0x82,
+	0xef,
+	0x34,
+	0x64,
+	0xf5,
+	0x83,
+	0xe0,
+	0xfd,
+	0xee,
+	0x24,
+	0x40,
+	0xf5,
+	0x82,
+	0xef,
+	0x34,
+	0x69,
+	0xf5,
+	0x83,
+	0xe0,
+	0xfc,
+	0xed,
+	0xb5,
+	0x04,
+	0x02,
+	0x80,
+	0x04,
+	0x90,
+	0x00,
+	0x01,
+	0x22,
+	0x0e,
+	0xbe,
+	0x00,
+	0xcf,
+	0x0f,
+	0x80,
+	0xcc,
+	0x90,
+	0x00,
+	0x00,
+	0x22,
+	0x74,
+	0xf0,
+	0x25,
+	0xb0,
+	0x50,
+	0xfa,
+	0x7e,
+	0x00,
+	0x7f,
+	0x00,
+	0xc3,
+	0xee,
+	0x94,
+	0x10,
+	0xef,
+	0x64,
+	0x80,
+	0x94,
+	0x80,
+	0x50,
+	0x19,
+	0x8e,
+	0x05,
+	0x74,
+	0x0f,
+	0xc3,
+	0x9d,
+	0x24,
+	0xa0,
+	0xf5,
+	0x82,
+	0xe4,
+	0x34,
+	0x69,
+	0xf5,
+	0x83,
+	0xe5,
+	0xa0,
+	0xf0,
+	0x0e,
+	0xbe,
+	0x00,
+	0xdf,
+	0x0f,
+	0x80,
+	0xdc,
+	0x22,
+	0x90,
+	0x69,
+	0xe7,
+	0xe0,
+	0xff,
+	0xbf,
+	0x02,
+	0x00,
+	0x40,
+	0x0b,
+	0x90,
+	0x69,
+	0xe5,
+	0xe0,
+	0xff,
+	0xbf,
+	0x02,
+	0x00,
+	0x50,
+	0x01,
+	0x22,
+	0x7e,
+	0x00,
+	0x7f,
+	0x00,
+	0xc3,
+	0xee,
+	0x94,
+	0x05,
+	0xef,
+	0x64,
+	0x80,
+	0x94,
+	0x80,
+	0x50,
+	0x20,
+	0xee,
+	0x24,
+	0x88,
+	0xfc,
+	0xef,
+	0x34,
+	0x69,
+	0xfd,
+	0xee,
+	0x24,
+	0x40,
+	0xf5,
+	0x82,
+	0xef,
+	0x34,
+	0x30,
+	0xf5,
+	0x83,
+	0xe0,
+	0xfb,
+	0x8c,
+	0x82,
+	0x8d,
+	0x83,
+	0xf0,
+	0x0e,
+	0xbe,
+	0x00,
+	0xd8,
+	0x0f,
+	0x80,
+	0xd5,
+	0x7e,
+	0x00,
+	0x7f,
+	0x00,
+	0xc3,
+	0xee,
+	0x94,
+	0x08,
+	0xef,
+	0x64,
+	0x80,
+	0x94,
+	0x80,
+	0x50,
+	0x2f,
+	0xee,
+	0x24,
+	0x90,
+	0xfc,
+	0xef,
+	0x34,
+	0x69,
+	0xfd,
+	0x90,
+	0x69,
+	0xe7,
+	0xe0,
+	0xfb,
+	0xbb,
+	0x02,
+	0x00,
+	0x50,
+	0x04,
+	0x7b,
+	0x00,
+	0x80,
+	0x0c,
+	0xee,
+	0x24,
+	0x80,
+	0xf5,
+	0x82,
+	0xef,
+	0x34,
+	0x69,
+	0xf5,
+	0x83,
+	0xe0,
+	0xfb,
+	0x8c,
+	0x82,
+	0x8d,
+	0x83,
+	0xeb,
+	0xf0,
+	0x0e,
+	0xbe,
+	0x00,
+	0xc9,
+	0x0f,
+	0x80,
+	0xc6,
+	0x7e,
+	0x08,
+	0x7f,
+	0x00,
+	0xc3,
+	0xee,
+	0x94,
+	0x10,
+	0xef,
+	0x64,
+	0x80,
+	0x94,
+	0x80,
+	0x50,
+	0x24,
+	0xee,
+	0x24,
+	0x90,
+	0xfc,
+	0xef,
+	0x34,
+	0x69,
+	0xfd,
+	0x8e,
+	0x03,
+	0xeb,
+	0x24,
+	0xf8,
+	0x24,
+	0xb0,
+	0xf5,
+	0x82,
+	0xe4,
+	0x34,
+	0x69,
+	0xf5,
+	0x83,
+	0xe0,
+	0xfb,
+	0x8c,
+	0x82,
+	0x8d,
+	0x83,
+	0xf0,
+	0x0e,
+	0xbe,
+	0x00,
+	0xd4,
+	0x0f,
+	0x80,
+	0xd1,
+	0x7e,
+	0x00,
+	0x7f,
+	0x00,
+	0xc3,
+	0xee,
+	0x94,
+	0x10,
+	0xef,
+	0x64,
+	0x80,
+	0x94,
+	0x80,
+	0x50,
+	0x20,
+	0xee,
+	0x24,
+	0xc0,
+	0xfc,
+	0xef,
+	0x34,
+	0x69,
+	0xfd,
+	0xee,
+	0x24,
+	0x68,
+	0xf5,
+	0x82,
+	0xef,
+	0x34,
+	0x63,
+	0xf5,
+	0x83,
+	0xe0,
+	0xfb,
+	0x8c,
+	0x82,
+	0x8d,
+	0x83,
+	0xf0,
+	0x0e,
+	0xbe,
+	0x00,
+	0xd8,
+	0x0f,
+	0x80,
+	0xd5,
+	0x22,
+	0x90,
+	0x30,
+	0x01,
+	0xe0,
+	0xff,
+	0x30,
+	0xe1,
+	0x32,
+	0x90,
+	0x63,
+	0x47,
+	0x74,
+	0x32,
+	0xf0,
+	0x90,
+	0x63,
+	0x46,
+	0x74,
+	0x75,
+	0xf0,
+	0x90,
+	0x63,
+	0x45,
+	0x74,
+	0x3e,
+	0xf0,
+	0x90,
+	0x63,
+	0x44,
+	0x74,
+	0xa8,
+	0xf0,
+	0x90,
+	0x63,
+	0x43,
+	0x74,
+	0x78,
+	0xf0,
+	0x90,
+	0x63,
+	0x42,
+	0x74,
+	0xa6,
+	0xf0,
+	0x90,
+	0x63,
+	0x41,
+	0x74,
+	0x38,
+	0xf0,
+	0x90,
+	0x63,
+	0x40,
+	0x74,
+	0x1c,
+	0xf0,
+	0x80,
+	0x12,
+	0x90,
+	0x63,
+	0x44,
+	0x75,
+	0xf0,
+	0x00,
+	0x12,
+	0xec,
+	0xc0,
+	0x90,
+	0x63,
+	0x40,
+	0x75,
+	0xf0,
+	0x00,
+	0x12,
+	0xec,
+	0xc0,
+	0x22,
+	0x90,
+	0x30,
+	0x0b,
+	0x74,
+	0x09,
+	0xf0,
+	0x90,
+	0x30,
+	0x0c,
+	0x74,
+	0x80,
+	0xf0,
+	0x75,
+	0x90,
+	0x09,
+	0x7f,
+	0x00,
+	0xbf,
+	0x08,
+	0x00,
+	0x50,
+	0x13,
+	0x74,
+	0x07,
+	0xc3,
+	0x9f,
+	0x24,
+	0x40,
+	0xf5,
+	0x82,
+	0xe4,
+	0x34,
+	0x63,
+	0xf5,
+	0x83,
+	0xe0,
+	0xf5,
+	0x90,
+	0x0f,
+	0x80,
+	0xe8,
+	0x90,
+	0x30,
+	0x0c,
+	0xe0,
+	0xff,
+	0x30,
+	0xe6,
+	0xf8,
+	0x90,
+	0x30,
+	0x0c,
+	0xe4,
+	0xf0,
+	0x22,
+	0x74,
+	0xf0,
+	0x25,
+	0xb0,
+	0x50,
+	0xfa,
+	0x7f,
+	0x00,
+	0xbf,
+	0x10,
+	0x00,
+	0x50,
+	0x10,
+	0xef,
+	0x24,
+	0xa0,
+	0xf5,
+	0x82,
+	0xe4,
+	0x34,
+	0x64,
+	0xf5,
+	0x83,
+	0xe5,
+	0xa0,
+	0xf0,
+	0x0f,
+	0x80,
+	0xeb,
+	0x74,
+	0xf0,
+	0x25,
+	0xb0,
+	0x50,
+	0xfa,
+	0x7f,
+	0x10,
+	0xbf,
+	0x20,
+	0x00,
+	0x50,
+	0x10,
+	0xef,
+	0x24,
+	0xa0,
+	0xf5,
+	0x82,
+	0xe4,
+	0x34,
+	0x64,
+	0xf5,
+	0x83,
+	0xe5,
+	0xa0,
+	0xf0,
+	0x0f,
+	0x80,
+	0xeb,
+	0x22,
+	0x7f,
+	0x00,
+	0xbf,
+	0x20,
+	0x00,
+	0x50,
+	0x25,
+	0xef,
+	0x24,
+	0xa0,
+	0xf5,
+	0x82,
+	0xe4,
+	0x34,
+	0x64,
+	0xf5,
+	0x83,
+	0xe0,
+	0xfe,
+	0xef,
+	0x24,
+	0x40,
+	0xf5,
+	0x82,
+	0xe4,
+	0x34,
+	0x69,
+	0xf5,
+	0x83,
+	0xe0,
+	0xfd,
+	0xee,
+	0xb5,
+	0x05,
+	0x02,
+	0x80,
+	0x04,
+	0x90,
+	0x00,
+	0x01,
+	0x22,
+	0x0f,
+	0x80,
+	0xd6,
+	0x90,
+	0x00,
+	0x00,
+	0x22,
+	0x90,
+	0x30,
+	0x01,
+	0xe0,
+	0xff,
+	0x30,
+	0xe1,
+	0x62,
+	0x90,
+	0x63,
+	0x67,
+	0x74,
+	0xf3,
+	0xf0,
+	0x90,
+	0x63,
+	0x66,
+	0x74,
+	0xdf,
+	0xf0,
+	0x90,
+	0x63,
+	0x65,
+	0x74,
+	0x1d,
+	0xf0,
+	0x90,
+	0x63,
+	0x64,
+	0x74,
+	0xd9,
+	0xf0,
+	0x90,
+	0x63,
+	0x63,
+	0x74,
+	0x57,
+	0xf0,
+	0x90,
+	0x63,
+	0x62,
+	0x74,
+	0x96,
+	0xf0,
+	0x90,
+	0x63,
+	0x61,
+	0x74,
+	0x12,
+	0xf0,
+	0x90,
+	0x63,
+	0x60,
+	0x74,
+	0x3f,
+	0xf0,
+	0x90,
+	0x63,
+	0x5f,
+	0x74,
+	0x98,
+	0xf0,
+	0x90,
+	0x63,
+	0x5e,
+	0x74,
+	0x97,
+	0xf0,
+	0x90,
+	0x63,
+	0x5d,
+	0x74,
+	0x89,
+	0xf0,
+	0x90,
+	0x63,
+	0x5c,
+	0x74,
+	0xb4,
+	0xf0,
+	0x90,
+	0x63,
+	0x5b,
+	0x74,
+	0x21,
+	0xf0,
+	0x90,
+	0x63,
+	0x5a,
+	0x74,
+	0xe1,
+	0xf0,
+	0x90,
+	0x63,
+	0x59,
+	0x74,
+	0x2d,
+	0xf0,
+	0x90,
+	0x63,
+	0x58,
+	0x74,
+	0xe1,
+	0xf0,
+	0x80,
+	0x24,
+	0x90,
+	0x63,
+	0x64,
+	0x75,
+	0xf0,
+	0x00,
+	0x12,
+	0xec,
+	0xc0,
+	0x90,
+	0x63,
+	0x60,
+	0x75,
+	0xf0,
+	0x00,
+	0x12,
+	0xec,
+	0xc0,
+	0x90,
+	0x63,
+	0x5c,
+	0x75,
+	0xf0,
+	0x00,
+	0x12,
+	0xec,
+	0xc0,
+	0x90,
+	0x63,
+	0x58,
+	0x75,
+	0xf0,
+	0x00,
+	0x12,
+	0xec,
+	0xc0,
+	0x22,
+	0x74,
+	0x10,
+	0xc0,
+	0xe0,
+	0xe4,
+	0xc0,
+	0xe0,
+	0x74,
+	0x80,
+	0xc0,
+	0xe0,
+	0x74,
+	0x64,
+	0xc0,
+	0xe0,
+	0xe4,
+	0xc0,
+	0xe0,
+	0x74,
+	0x58,
+	0xc0,
+	0xe0,
+	0x74,
+	0x63,
+	0xc0,
+	0xe0,
+	0xe4,
+	0xc0,
+	0xe0,
+	0x90,
+	0x64,
+	0xe0,
+	0x75,
+	0xf0,
+	0x00,
+	0x12,
+	0x9e,
+	0x7c,
+	0xe5,
+	0x81,
+	0x24,
+	0xf8,
+	0xf5,
+	0x81,
+	0x74,
+	0x08,
+	0xc0,
+	0xe0,
+	0xe4,
+	0xc0,
+	0xe0,
+	0x74,
+	0x80,
+	0xc0,
+	0xe0,
+	0x74,
+	0x64,
+	0xc0,
+	0xe0,
+	0xe4,
+	0xc0,
+	0xe0,
+	0x74,
+	0x80,
+	0xc0,
+	0xe0,
+	0x74,
+	0x69,
+	0xc0,
+	0xe0,
+	0xe4,
+	0xc0,
+	0xe0,
+	0x90,
+	0x64,
+	0x80,
+	0x75,
+	0xf0,
+	0x00,
+	0x12,
+	0x9e,
+	0x7c,
+	0xe5,
+	0x81,
+	0x24,
+	0xf8,
+	0xf5,
+	0x81,
+	0x22,
+	0x90,
+	0x30,
+	0x01,
+	0xe0,
+	0xff,
+	0x30,
+	0xe1,
+	0x32,
+	0x90,
+	0x63,
+	0x57,
+	0x74,
+	0x40,
+	0xf0,
+	0x90,
+	0x63,
+	0x56,
+	0x74,
+	0x2b,
+	0xf0,
+	0x90,
+	0x63,
+	0x55,
+	0x74,
+	0x6b,
+	0xf0,
+	0x90,
+	0x63,
+	0x54,
+	0x74,
+	0x43,
+	0xf0,
+	0x90,
+	0x63,
+	0x53,
+	0x74,
+	0xc5,
+	0xf0,
+	0x90,
+	0x63,
+	0x52,
+	0x74,
+	0xe8,
+	0xf0,
+	0x90,
+	0x63,
+	0x51,
+	0x74,
+	0x86,
+	0xf0,
+	0x90,
+	0x63,
+	0x50,
+	0x74,
+	0xd8,
+	0xf0,
+	0x80,
+	0x12,
+	0x90,
+	0x63,
+	0x54,
+	0x75,
+	0xf0,
+	0x00,
+	0x12,
+	0xec,
+	0xc0,
+	0x90,
+	0x63,
+	0x50,
+	0x75,
+	0xf0,
+	0x00,
+	0x12,
+	0xec,
+	0xc0,
+	0x22,
+	0x90,
+	0x30,
+	0x0b,
+	0x74,
+	0x19,
+	0xf0,
+	0x90,
+	0x30,
+	0x0c,
+	0x74,
+	0x80,
+	0xf0,
+	0x75,
+	0x90,
+	0x0b,
+	0x7e,
+	0x00,
+	0x7f,
+	0x00,
+	0xc3,
+	0xee,
+	0x94,
+	0x10,
+	0xef,
+	0x64,
+	0x80,
+	0x94,
+	0x80,
+	0x50,
+	0x19,
+	0x8e,
+	0x05,
+	0x74,
+	0x0f,
+	0xc3,
+	0x9d,
+	0x24,
+	0x80,
+	0xf5,
+	0x82,
+	0xe4,
+	0x34,
+	0x64,
+	0xf5,
+	0x83,
+	0xe0,
+	0xf5,
+	0x90,
+	0x0e,
+	0xbe,
+	0x00,
+	0xdf,
+	0x0f,
+	0x80,
+	0xdc,
+	0x7e,
+	0x00,
+	0x7f,
+	0x00,
+	0xc3,
+	0xee,
+	0x94,
+	0x08,
+	0xef,
+	0x64,
+	0x80,
+	0x94,
+	0x80,
+	0x50,
+	0x19,
+	0x8e,
+	0x05,
+	0x74,
+	0x07,
+	0xc3,
+	0x9d,
+	0x24,
+	0x50,
+	0xf5,
+	0x82,
+	0xe4,
+	0x34,
+	0x63,
+	0xf5,
+	0x83,
+	0xe0,
+	0xf5,
+	0x90,
+	0x0e,
+	0xbe,
+	0x00,
+	0xdf,
+	0x0f,
+	0x80,
+	0xdc,
+	0x90,
+	0x30,
+	0x0c,
+	0xe0,
+	0xff,
+	0x30,
+	0xe6,
+	0xf8,
+	0x90,
+	0x30,
+	0x0c,
+	0xe4,
+	0xf0,
+	0x22,
+	0x7e,
+	0x00,
+	0x7f,
+	0x00,
+	0x7c,
+	0x00,
+	0x7d,
+	0x00,
+	0x74,
+	0xfe,
+	0x25,
+	0xb0,
+	0x40,
+	0x23,
+	0x8c,
+	0x02,
+	0x8d,
+	0x03,
+	0x0c,
+	0xbc,
+	0x00,
+	0x01,
+	0x0d,
+	0x8c,
+	0x06,
+	0x8d,
+	0x07,
+	0xc3,
+	0x74,
+	0x10,
+	0x9a,
+	0x74,
+	0x27,
+	0x9b,
+	0x50,
+	0xe4,
+	0xc0,
+	0x05,
+	0xc0,
+	0x04,
+	0x12,
+	0xaf,
+	0x90,
+	0xd0,
+	0x04,
+	0xd0,
+	0x05,
+	0x80,
+	0xd7,
+	0xc0,
+	0x04,
+	0xc0,
+	0x05,
+	0xab,
+	0xa0,
+	0xaa,
+	0xa0,
+	0x74,
+	0x0e,
+	0x5b,
+	0xc3,
+	0x13,
+	0x90,
+	0x30,
+	0x20,
+	0xf0,
+	0x53,
+	0x03,
+	0x01,
+	0xeb,
+	0xc4,
+	0x54,
+	0xf0,
+	0xfb,
+	0x90,
+	0x30,
+	0x21,
+	0xf0,
+	0x74,
+	0xf0,
+	0x5a,
+	0xc4,
+	0x54,
+	0x0f,
+	0xfd,
+	0x90,
+	0x30,
+	0x21,
+	0xe0,
+	0xfc,
+	0x4d,
+	0xf0,
+	0x90,
+	0x30,
+	0x22,
+	0x74,
+	0x0f,
+	0x5a,
+	0xf0,
+	0x90,
+	0x30,
+	0x22,
+	0xe0,
+	0xfd,
+	0x54,
+	0x0c,
+	0x60,
+	0x07,
+	0xd0,
+	0x05,
+	0xd0,
+	0x04,
+	0x02,
+	0xc3,
+	0xd8,
+	0xd0,
+	0x05,
+	0xd0,
+	0x04,
+	0x74,
+	0xfd,
+	0x25,
+	0xb0,
+	0x40,
+	0x23,
+	0x8c,
+	0x02,
+	0x8d,
+	0x03,
+	0x0c,
+	0xbc,
+	0x00,
+	0x01,
+	0x0d,
+	0x8c,
+	0x06,
+	0x8d,
+	0x07,
+	0xc3,
+	0x74,
+	0x10,
+	0x9a,
+	0x74,
+	0x27,
+	0x9b,
+	0x50,
+	0xe4,
+	0xc0,
+	0x05,
+	0xc0,
+	0x04,
+	0x12,
+	0xaf,
+	0x90,
+	0xd0,
+	0x04,
+	0xd0,
+	0x05,
+	0x80,
+	0xd7,
+	0x90,
+	0x30,
+	0x48,
+	0xe0,
+	0x90,
+	0x69,
+	0xba,
+	0xf0,
+	0x90,
+	0x30,
+	0x47,
+	0xe0,
+	0x90,
+	0x69,
+	0xb9,
+	0xf0,
+	0x90,
+	0x30,
+	0x46,
+	0xe0,
+	0xfb,
+	0x90,
+	0x69,
+	0xb8,
+	0xf0,
+	0x90,
+	0x30,
+	0x48,
+	0xe5,
+	0xa0,
+	0xf0,
+	0x90,
+	0x30,
+	0x47,
+	0xe5,
+	0xa0,
+	0xf0,
+	0x90,
+	0x30,
+	0x46,
+	0xe5,
+	0xa0,
+	0xf0,
+	0x74,
+	0xf0,
+	0x25,
+	0xb0,
+	0x40,
+	0x23,
+	0x8c,
+	0x02,
+	0x8d,
+	0x03,
+	0x0c,
+	0xbc,
+	0x00,
+	0x01,
+	0x0d,
+	0x8c,
+	0x06,
+	0x8d,
+	0x07,
+	0xc3,
+	0x74,
+	0x10,
+	0x9a,
+	0x74,
+	0x27,
+	0x9b,
+	0x50,
+	0xe4,
+	0xc0,
+	0x05,
+	0xc0,
+	0x04,
+	0x12,
+	0xaf,
+	0x90,
+	0xd0,
+	0x04,
+	0xd0,
+	0x05,
+	0x80,
+	0xd7,
+	0x8c,
+	0x06,
+	0x8d,
+	0x07,
+	0x7d,
+	0x00,
+	0xbd,
+	0x10,
+	0x00,
+	0x50,
+	0x10,
+	0xed,
+	0x24,
+	0xa0,
+	0xf5,
+	0x82,
+	0xe4,
+	0x34,
+	0x64,
+	0xf5,
+	0x83,
+	0xe5,
+	0xa0,
+	0xf0,
+	0x0d,
+	0x80,
+	0xeb,
+	0x90,
+	0x30,
+	0x26,
+	0x74,
+	0x01,
+	0xf0,
+	0x7d,
+	0x00,
+	0x90,
+	0x30,
+	0x21,
+	0xe0,
+	0xfc,
+	0xc3,
+	0xed,
+	0x9c,
+	0x50,
+	0x66,
+	0x8e,
+	0x03,
+	0x8f,
+	0x04,
+	0x74,
+	0xfb,
+	0x25,
+	0xb0,
+	0x40,
+	0x2b,
+	0xc0,
+	0x05,
+	0x8b,
+	0x02,
+	0x8c,
+	0x05,
+	0x0b,
+	0xbb,
+	0x00,
+	0x01,
+	0x0c,
+	0x8b,
+	0x06,
+	0x8c,
+	0x07,
+	0xc3,
+	0x74,
+	0x10,
+	0x9a,
+	0x74,
+	0x27,
+	0x9d,
+	0xd0,
+	0x05,
+	0x50,
+	0xe0,
+	0xc0,
+	0x05,
+	0xc0,
+	0x04,
+	0xc0,
+	0x03,
+	0x12,
+	0xaf,
+	0x90,
+	0xd0,
+	0x03,
+	0xd0,
+	0x04,
+	0xd0,
+	0x05,
+	0x80,
+	0xcf,
+	0x8b,
+	0x06,
+	0x8c,
+	0x07,
+	0xed,
+	0x75,
+	0xf0,
+	0x05,
+	0xa4,
+	0xfc,
+	0x7b,
+	0x00,
+	0xbb,
+	0x05,
+	0x00,
+	0x50,
+	0x17,
+	0xaa,
+	0xa0,
+	0xeb,
+	0x2c,
+	0x24,
+	0x40,
+	0xf5,
+	0x82,
+	0xe4,
+	0x34,
+	0x65,
+	0xf5,
+	0x83,
+	0xea,
+	0xf0,
+	0x90,
+	0x30,
+	0x27,
+	0xea,
+	0xf0,
+	0x0b,
+	0x80,
+	0xe4,
+	0x0d,
+	0x80,
+	0x96,
+	0x90,
+	0x30,
+	0x2a,
+	0x74,
+	0x01,
+	0xf0,
+	0x22,
+	0x90,
+	0x69,
+	0xe5,
+	0xe0,
+	0xff,
+	0x60,
+	0x38,
+	0x7e,
+	0x00,
+	0x7f,
+	0x00,
+	0xc3,
+	0xee,
+	0x94,
+	0x10,
+	0xef,
+	0x64,
+	0x80,
+	0x94,
+	0x80,
+	0x50,
+	0x61,
+	0xee,
+	0x24,
+	0xa0,
+	0xf5,
+	0x82,
+	0xef,
+	0x34,
+	0x64,
+	0xf5,
+	0x83,
+	0xe0,
+	0xfd,
+	0xee,
+	0x24,
+	0x40,
+	0xf5,
+	0x82,
+	0xef,
+	0x34,
+	0x6d,
+	0xf5,
+	0x83,
+	0xe0,
+	0xfc,
+	0xed,
+	0xb5,
+	0x04,
+	0x02,
+	0x80,
+	0x04,
+	0x90,
+	0x00,
+	0x01,
+	0x22,
+	0x0e,
+	0xbe,
+	0x00,
+	0xcf,
+	0x0f,
+	0x80,
+	0xcc,
+	0x7e,
+	0x00,
+	0x7f,
+	0x00,
+	0xc3,
+	0xee,
+	0x94,
+	0x20,
+	0xef,
+	0x64,
+	0x80,
+	0x94,
+	0x80,
+	0x50,
+	0x29,
+	0xee,
+	0x24,
+	0xa0,
+	0xf5,
+	0x82,
+	0xef,
+	0x34,
+	0x64,
+	0xf5,
+	0x83,
+	0xe0,
+	0xfd,
+	0xee,
+	0x24,
+	0x40,
+	0xf5,
+	0x82,
+	0xef,
+	0x34,
+	0x6d,
+	0xf5,
+	0x83,
+	0xe0,
+	0xfc,
+	0xed,
+	0xb5,
+	0x04,
+	0x02,
+	0x80,
+	0x04,
+	0x90,
+	0x00,
+	0x01,
+	0x22,
+	0x0e,
+	0xbe,
+	0x00,
+	0xcf,
+	0x0f,
+	0x80,
+	0xcc,
+	0x90,
+	0x00,
+	0x00,
+	0x22,
+	0x90,
+	0x30,
+	0x0b,
+	0x74,
+	0x11,
+	0xf0,
+	0x90,
+	0x30,
+	0x0c,
+	0x74,
+	0x80,
+	0xf0,
+	0x75,
+	0x90,
+	0x0f,
+	0x7e,
+	0x00,
+	0x7f,
+	0x00,
+	0xc3,
+	0xee,
+	0x94,
+	0x10,
+	0xef,
+	0x64,
+	0x80,
+	0x94,
+	0x80,
+	0x50,
+	0x18,
+	0x8e,
+	0x05,
+	0x74,
+	0x10,
+	0x2d,
+	0x24,
+	0x40,
+	0xf5,
+	0x82,
+	0xe4,
+	0x34,
+	0x69,
+	0xf5,
+	0x83,
+	0xe0,
+	0xf5,
+	0x90,
+	0x0e,
+	0xbe,
+	0x00,
+	0xe0,
+	0x0f,
+	0x80,
+	0xdd,
+	0x7e,
+	0x00,
+	0x7f,
+	0x00,
+	0x90,
+	0x30,
+	0x0c,
+	0xe0,
+	0xfd,
+	0x20,
+	0xe6,
+	0x1f,
+	0x8e,
+	0x04,
+	0x8f,
+	0x05,
+	0x0e,
+	0xbe,
+	0x00,
+	0x01,
+	0x0f,
+	0xc3,
+	0x74,
+	0x10,
+	0x9c,
+	0x74,
+	0x27,
+	0x9d,
+	0x50,
+	0xe6,
+	0xc0,
+	0x07,
+	0xc0,
+	0x06,
+	0x12,
+	0xaf,
+	0x90,
+	0xd0,
+	0x06,
+	0xd0,
+	0x07,
+	0x80,
+	0xd9,
+	0x90,
+	0x30,
+	0x0c,
+	0xe4,
+	0xf0,
+	0x22,
+	0xc0,
+	0x12,
+	0x85,
+	0x81,
+	0x12,
+	0x05,
+	0x81,
+	0x05,
+	0x81,
+	0x7e,
+	0x00,
+	0x7f,
+	0x00,
+	0x90,
+	0x30,
+	0x2c,
+	0xe0,
+	0x25,
+	0xe0,
+	0xfd,
+	0x90,
+	0x30,
+	0x0b,
+	0x74,
+	0x06,
+	0x2d,
+	0xf0,
+	0x90,
+	0x30,
+	0x0c,
+	0x74,
+	0x80,
+	0xf0,
+	0x75,
+	0x90,
+	0x10,
+	0x90,
+	0x30,
+	0x4b,
+	0xe0,
+	0xf5,
+	0x90,
+	0x90,
+	0x30,
+	0x4a,
+	0xe0,
+	0xf5,
+	0x90,
+	0x90,
+	0x30,
+	0x49,
+	0xe0,
+	0xf5,
+	0x90,
+	0x75,
+	0x90,
+	0x00,
+	0x90,
+	0x30,
+	0x2c,
+	0xe0,
+	0xf5,
+	0x90,
+	0x90,
+	0x30,
+	0x28,
+	0x74,
+	0x01,
+	0xf0,
+	0xa8,
+	0x12,
+	0x08,
+	0xe4,
+	0xf6,
+	0x08,
+	0xf6,
+	0x90,
+	0x30,
+	0x2c,
+	0xe0,
+	0xfb,
+	0x7a,
+	0x00,
+	0xa8,
+	0x12,
+	0x08,
+	0xc3,
+	0xe6,
+	0x9b,
+	0x08,
+	0xe6,
+	0x64,
+	0x80,
+	0x8a,
+	0xf0,
+	0x63,
+	0xf0,
+	0x80,
+	0x95,
+	0xf0,
+	0x40,
+	0x03,
+	0x02,
+	0xc5,
+	0xae,
+	0x8e,
+	0x02,
+	0x8f,
+	0x03,
+	0x74,
+	0xfe,
+	0x25,
+	0x90,
+	0x40,
+	0x23,
+	0x8a,
+	0x04,
+	0x8b,
+	0x05,
+	0x0a,
+	0xba,
+	0x00,
+	0x01,
+	0x0b,
+	0x8a,
+	0x06,
+	0x8b,
+	0x07,
+	0xc3,
+	0x74,
+	0x10,
+	0x9c,
+	0x74,
+	0x27,
+	0x9d,
+	0x50,
+	0xe4,
+	0xc0,
+	0x03,
+	0xc0,
+	0x02,
+	0x12,
+	0xaf,
+	0x90,
+	0xd0,
+	0x02,
+	0xd0,
+	0x03,
+	0x80,
+	0xd7,
+	0x8a,
+	0x06,
+	0x8b,
+	0x07,
+	0x7a,
+	0x00,
+	0x7b,
+	0x00,
+	0xc3,
+	0xea,
+	0x94,
+	0x02,
+	0xeb,
+	0x64,
+	0x80,
+	0x94,
+	0x80,
+	0x50,
+	0x38,
+	0xc0,
+	0x06,
+	0xc0,
+	0x07,
+	0xa8,
+	0x12,
+	0x08,
+	0xe6,
+	0x26,
+	0xff,
+	0x8a,
+	0x06,
+	0xee,
+	0x2f,
+	0xff,
+	0x24,
+	0x40,
+	0xfd,
+	0xe4,
+	0x34,
+	0x65,
+	0xfe,
+	0x90,
+	0x30,
+	0x29,
+	0xe0,
+	0xfc,
+	0x8d,
+	0x82,
+	0x8e,
+	0x83,
+	0xf0,
+	0xef,
+	0x24,
+	0x40,
+	0xf5,
+	0x82,
+	0xe4,
+	0x34,
+	0x65,
+	0xf5,
+	0x83,
+	0xe0,
+	0xf5,
+	0x90,
+	0x0a,
+	0xba,
+	0x00,
+	0x01,
+	0x0b,
+	0xd0,
+	0x07,
+	0xd0,
+	0x06,
+	0x80,
+	0xbd,
+	0xa8,
+	0x12,
+	0x08,
+	0x06,
+	0xb6,
+	0x00,
+	0x02,
+	0x08,
+	0x06,
+	0x02,
+	0xc5,
+	0x0d,
+	0x90,
+	0x30,
+	0x0c,
+	0xe0,
+	0xfd,
+	0x20,
+	0xe6,
+	0x1f,
+	0x8e,
+	0x04,
+	0x8f,
+	0x05,
+	0x0e,
+	0xbe,
+	0x00,
+	0x01,
+	0x0f,
+	0xc3,
+	0x74,
+	0x10,
+	0x9c,
+	0x74,
+	0x27,
+	0x9d,
+	0x50,
+	0xe6,
+	0xc0,
+	0x07,
+	0xc0,
+	0x06,
+	0x12,
+	0xaf,
+	0x90,
+	0xd0,
+	0x06,
+	0xd0,
+	0x07,
+	0x80,
+	0xd9,
+	0x90,
+	0x30,
+	0x0c,
+	0xe4,
+	0xf0,
+	0x85,
+	0x12,
+	0x81,
+	0xd0,
+	0x12,
+	0x22,
+	0x7e,
+	0x00,
+	0x7f,
+	0x00,
+	0x7c,
+	0x00,
+	0x7d,
+	0x00,
+	0x74,
+	0xf0,
+	0x25,
+	0xb0,
+	0x40,
+	0x23,
+	0x8c,
+	0x02,
+	0x8d,
+	0x03,
+	0x0c,
+	0xbc,
+	0x00,
+	0x01,
+	0x0d,
+	0x8c,
+	0x06,
+	0x8d,
+	0x07,
+	0xc3,
+	0x74,
+	0x10,
+	0x9a,
+	0x74,
+	0x27,
+	0x9b,
+	0x50,
+	0xe4,
+	0xc0,
+	0x05,
+	0xc0,
+	0x04,
+	0x12,
+	0xaf,
+	0x90,
+	0xd0,
+	0x04,
+	0xd0,
+	0x05,
+	0x80,
+	0xd7,
+	0x8c,
+	0x06,
+	0x8d,
+	0x07,
+	0x7c,
+	0x00,
+	0x7d,
+	0x00,
+	0xc3,
+	0xec,
+	0x94,
+	0x10,
+	0xed,
+	0x64,
+	0x80,
+	0x94,
+	0x80,
+	0x50,
+	0x14,
+	0xec,
+	0x24,
+	0x20,
+	0xf5,
+	0x82,
+	0xed,
+	0x34,
+	0x65,
+	0xf5,
+	0x83,
+	0xe5,
+	0xa0,
+	0xf0,
+	0x0c,
+	0xbc,
+	0x00,
+	0xe4,
+	0x0d,
+	0x80,
+	0xe1,
+	0x74,
+	0xf0,
+	0x25,
+	0xb0,
+	0x40,
+	0x1f,
+	0x8e,
+	0x04,
+	0x8f,
+	0x05,
+	0x0e,
+	0xbe,
+	0x00,
+	0x01,
+	0x0f,
+	0xc3,
+	0x74,
+	0x10,
+	0x9c,
+	0x74,
+	0x27,
+	0x9d,
+	0x50,
+	0xe8,
+	0xc0,
+	0x07,
+	0xc0,
+	0x06,
+	0x12,
+	0xaf,
+	0x90,
+	0xd0,
+	0x06,
+	0xd0,
+	0x07,
+	0x80,
+	0xdb,
+	0x7e,
+	0x10,
+	0x7f,
+	0x00,
+	0xc3,
+	0xee,
+	0x94,
+	0x20,
+	0xef,
+	0x64,
+	0x80,
+	0x94,
+	0x80,
+	0x50,
+	0x14,
+	0xee,
+	0x24,
+	0x20,
+	0xf5,
+	0x82,
+	0xef,
+	0x34,
+	0x65,
+	0xf5,
+	0x83,
+	0xe5,
+	0xa0,
+	0xf0,
+	0x0e,
+	0xbe,
+	0x00,
+	0xe4,
+	0x0f,
+	0x80,
+	0xe1,
+	0x22,
+	0x7e,
+	0x00,
+	0x7f,
+	0x00,
+	0xc3,
+	0xee,
+	0x94,
+	0x20,
+	0xef,
+	0x64,
+	0x80,
+	0x94,
+	0x80,
+	0x50,
+	0x29,
+	0xee,
+	0x24,
+	0x20,
+	0xf5,
+	0x82,
+	0xef,
+	0x34,
+	0x65,
+	0xf5,
+	0x83,
+	0xe0,
+	0xfd,
+	0xee,
+	0x24,
+	0x80,
+	0xf5,
+	0x82,
+	0xef,
+	0x34,
+	0x6d,
+	0xf5,
+	0x83,
+	0xe0,
+	0xfc,
+	0xed,
+	0xb5,
+	0x04,
+	0x02,
+	0x80,
+	0x04,
+	0x90,
+	0x00,
+	0x01,
+	0x22,
+	0x0e,
+	0xbe,
+	0x00,
+	0xcf,
+	0x0f,
+	0x80,
+	0xcc,
+	0x90,
+	0x00,
+	0x00,
+	0x22,
+	0x90,
+	0x30,
+	0x22,
+	0xe0,
+	0xff,
+	0x54,
+	0x0c,
+	0x60,
+	0x01,
+	0x22,
+	0x12,
+	0xa5,
+	0x92,
+	0x12,
+	0xc3,
+	0xdf,
+	0xae,
+	0x82,
+	0xaf,
+	0x83,
+	0xee,
+	0x60,
+	0x1e,
+	0x90,
+	0x30,
+	0x07,
+	0xe0,
+	0x44,
+	0x08,
+	0xf0,
+	0x90,
+	0x6c,
+	0x08,
+	0x74,
+	0x34,
+	0xf0,
+	0x90,
+	0x30,
+	0x0a,
+	0xe0,
+	0xff,
+	0xbf,
+	0xdb,
+	0x06,
+	0x90,
+	0x30,
+	0x02,
+	0x74,
+	0x1f,
+	0xf0,
+	0x12,
+	0xaf,
+	0x90,
+	0x90,
+	0x30,
+	0x2a,
+	0x74,
+	0x01,
+	0xf0,
+	0x90,
+	0x30,
+	0x0a,
+	0xe0,
+	0xff,
+	0xbf,
+	0xdb,
+	0x06,
+	0x90,
+	0x30,
+	0x02,
+	0x74,
+	0x20,
+	0xf0,
+	0x90,
+	0x69,
+	0xe5,
+	0xe0,
+	0xff,
+	0xbf,
+	0x01,
+	0x00,
+	0x40,
+	0x03,
+	0x02,
+	0xc4,
+	0x5a,
+	0x22,
+	0x7e,
+	0x00,
+	0x7f,
+	0x00,
+	0xc3,
+	0xee,
+	0x94,
+	0x08,
+	0xef,
+	0x64,
+	0x80,
+	0x94,
+	0x80,
+	0x50,
+	0x2f,
+	0xee,
+	0x24,
+	0x90,
+	0xfc,
+	0xef,
+	0x34,
+	0x69,
+	0xfd,
+	0x90,
+	0x69,
+	0xe7,
+	0xe0,
+	0xfb,
+	0xbb,
+	0x02,
+	0x00,
+	0x50,
+	0x04,
+	0x7b,
+	0x00,
+	0x80,
+	0x0c,
+	0xee,
+	0x24,
+	0x80,
+	0xf5,
+	0x82,
+	0xef,
+	0x34,
+	0x69,
+	0xf5,
+	0x83,
+	0xe0,
+	0xfb,
+	0x8c,
+	0x82,
+	0x8d,
+	0x83,
+	0xeb,
+	0xf0,
+	0x0e,
+	0xbe,
+	0x00,
+	0xc9,
+	0x0f,
+	0x80,
+	0xc6,
+	0x7e,
+	0x08,
+	0x7f,
+	0x00,
+	0xc3,
+	0xee,
+	0x94,
+	0x10,
+	0xef,
+	0x64,
+	0x80,
+	0x94,
+	0x80,
+	0x50,
+	0x24,
+	0xee,
+	0x24,
+	0x90,
+	0xfc,
+	0xef,
+	0x34,
+	0x69,
+	0xfd,
+	0x8e,
+	0x03,
+	0xeb,
+	0x24,
+	0xf8,
+	0x24,
+	0xb0,
+	0xf5,
+	0x82,
+	0xe4,
+	0x34,
+	0x69,
+	0xf5,
+	0x83,
+	0xe0,
+	0xfb,
+	0x8c,
+	0x82,
+	0x8d,
+	0x83,
+	0xf0,
+	0x0e,
+	0xbe,
+	0x00,
+	0xd4,
+	0x0f,
+	0x80,
+	0xd1,
+	0x90,
+	0x64,
+	0xd0,
+	0x75,
+	0xf0,
+	0x00,
+	0x12,
+	0xad,
+	0x16,
+	0xac,
+	0x82,
+	0xad,
+	0x83,
+	0xae,
+	0xf0,
+	0xff,
+	0x90,
+	0x44,
+	0x10,
+	0xec,
+	0xf0,
+	0xa3,
+	0xed,
+	0xf0,
+	0xa3,
+	0xee,
+	0xf0,
+	0xa3,
+	0xef,
+	0xf0,
+	0x90,
+	0x64,
+	0xd4,
+	0x75,
+	0xf0,
+	0x00,
+	0x12,
+	0xad,
+	0x16,
+	0xac,
+	0x82,
+	0xad,
+	0x83,
+	0xae,
+	0xf0,
+	0xff,
+	0x90,
+	0x44,
+	0x0c,
+	0xec,
+	0xf0,
+	0xa3,
+	0xed,
+	0xf0,
+	0xa3,
+	0xee,
+	0xf0,
+	0xa3,
+	0xef,
+	0xf0,
+	0x90,
+	0x64,
+	0xd8,
+	0x75,
+	0xf0,
+	0x00,
+	0x12,
+	0xad,
+	0x16,
+	0xac,
+	0x82,
+	0xad,
+	0x83,
+	0xae,
+	0xf0,
+	0xff,
+	0x90,
+	0x44,
+	0x08,
+	0xec,
+	0xf0,
+	0xa3,
+	0xed,
+	0xf0,
+	0xa3,
+	0xee,
+	0xf0,
+	0xa3,
+	0xef,
+	0xf0,
+	0x90,
+	0x64,
+	0xdc,
+	0x75,
+	0xf0,
+	0x00,
+	0x12,
+	0xad,
+	0x16,
+	0xac,
+	0x82,
+	0xad,
+	0x83,
+	0xae,
+	0xf0,
+	0xff,
+	0x90,
+	0x44,
+	0x04,
+	0xec,
+	0xf0,
+	0xa3,
+	0xed,
+	0xf0,
+	0xa3,
+	0xee,
+	0xf0,
+	0xa3,
+	0xef,
+	0xf0,
+	0x90,
+	0x69,
+	0x9c,
+	0x75,
+	0xf0,
+	0x00,
+	0x12,
+	0xf4,
+	0x15,
+	0xfc,
+	0xa3,
+	0x12,
+	0xf4,
+	0x15,
+	0xfd,
+	0xa3,
+	0x12,
+	0xf4,
+	0x15,
+	0xfe,
+	0xa3,
+	0x12,
+	0xf4,
+	0x15,
+	0xff,
+	0x90,
+	0x44,
+	0x20,
+	0xec,
+	0xf0,
+	0xa3,
+	0xed,
+	0xf0,
+	0xa3,
+	0xee,
+	0xf0,
+	0xa3,
+	0xef,
+	0xf0,
+	0x90,
+	0x69,
+	0x98,
+	0x75,
+	0xf0,
+	0x00,
+	0x12,
+	0xf4,
+	0x15,
+	0xfc,
+	0xa3,
+	0x12,
+	0xf4,
+	0x15,
+	0xfd,
+	0xa3,
+	0x12,
+	0xf4,
+	0x15,
+	0xfe,
+	0xa3,
+	0x12,
+	0xf4,
+	0x15,
+	0xff,
+	0x90,
+	0x44,
+	0x1c,
+	0xec,
+	0xf0,
+	0xa3,
+	0xed,
+	0xf0,
+	0xa3,
+	0xee,
+	0xf0,
+	0xa3,
+	0xef,
+	0xf0,
+	0x90,
+	0x69,
+	0x94,
+	0x75,
+	0xf0,
+	0x00,
+	0x12,
+	0xf4,
+	0x15,
+	0xfc,
+	0xa3,
+	0x12,
+	0xf4,
+	0x15,
+	0xfd,
+	0xa3,
+	0x12,
+	0xf4,
+	0x15,
+	0xfe,
+	0xa3,
+	0x12,
+	0xf4,
+	0x15,
+	0xff,
+	0x90,
+	0x44,
+	0x18,
+	0xec,
+	0xf0,
+	0xa3,
+	0xed,
+	0xf0,
+	0xa3,
+	0xee,
+	0xf0,
+	0xa3,
+	0xef,
+	0xf0,
+	0x90,
+	0x69,
+	0x90,
+	0xe0,
+	0xfc,
+	0xa3,
+	0xe0,
+	0xfd,
+	0xa3,
+	0xe0,
+	0xfe,
+	0xa3,
+	0xe0,
+	0xff,
+	0x90,
+	0x44,
+	0x14,
+	0xec,
+	0xf0,
+	0xa3,
+	0xed,
+	0xf0,
+	0xa3,
+	0xee,
+	0xf0,
+	0xa3,
+	0xef,
+	0xf0,
+	0x90,
+	0x44,
+	0x24,
+	0xe0,
+	0xfc,
+	0xa3,
+	0xe0,
+	0xfd,
+	0xa3,
+	0xe0,
+	0xfe,
+	0xa3,
+	0xe0,
+	0xff,
+	0x90,
+	0x64,
+	0x90,
+	0xec,
+	0xf0,
+	0xa3,
+	0xed,
+	0xf0,
+	0xa3,
+	0xee,
+	0xf0,
+	0xa3,
+	0xef,
+	0xf0,
+	0x90,
+	0x44,
+	0x28,
+	0xe0,
+	0xfc,
+	0xa3,
+	0xe0,
+	0xfd,
+	0xa3,
+	0xe0,
+	0xfe,
+	0xa3,
+	0xe0,
+	0xff,
+	0x90,
+	0x64,
+	0x94,
+	0x75,
+	0xf0,
+	0x00,
+	0xec,
+	0x12,
+	0xf3,
+	0x29,
+	0xa3,
+	0xed,
+	0x12,
+	0xf3,
+	0x29,
+	0xa3,
+	0xee,
+	0x12,
+	0xf3,
+	0x29,
+	0xa3,
+	0xef,
+	0x12,
+	0xf3,
+	0x29,
+	0x90,
+	0x44,
+	0x2c,
+	0xe0,
+	0xfc,
+	0xa3,
+	0xe0,
+	0xfd,
+	0xa3,
+	0xe0,
+	0xfe,
+	0xa3,
+	0xe0,
+	0xff,
+	0x90,
+	0x64,
+	0x98,
+	0x75,
+	0xf0,
+	0x00,
+	0xec,
+	0x12,
+	0xf3,
+	0x29,
+	0xa3,
+	0xed,
+	0x12,
+	0xf3,
+	0x29,
+	0xa3,
+	0xee,
+	0x12,
+	0xf3,
+	0x29,
+	0xa3,
+	0xef,
+	0x12,
+	0xf3,
+	0x29,
+	0x90,
+	0x44,
+	0x30,
+	0xe0,
+	0xfc,
+	0xa3,
+	0xe0,
+	0xfd,
+	0xa3,
+	0xe0,
+	0xfe,
+	0xa3,
+	0xe0,
+	0xff,
+	0x90,
+	0x64,
+	0x9c,
+	0x75,
+	0xf0,
+	0x00,
+	0xec,
+	0x12,
+	0xf3,
+	0x29,
+	0xa3,
+	0xed,
+	0x12,
+	0xf3,
+	0x29,
+	0xa3,
+	0xee,
+	0x12,
+	0xf3,
+	0x29,
+	0xa3,
+	0xef,
+	0x12,
+	0xf3,
+	0x29,
+	0x74,
+	0x10,
+	0xc0,
+	0xe0,
+	0xe4,
+	0xc0,
+	0xe0,
+	0x74,
+	0x90,
+	0xc0,
+	0xe0,
+	0x74,
+	0x64,
+	0xc0,
+	0xe0,
+	0xe4,
+	0xc0,
+	0xe0,
+	0x74,
+	0x68,
+	0xc0,
+	0xe0,
+	0x74,
+	0x63,
+	0xc0,
+	0xe0,
+	0xe4,
+	0xc0,
+	0xe0,
+	0x90,
+	0x64,
+	0x90,
+	0x75,
+	0xf0,
+	0x00,
+	0x12,
+	0x9e,
+	0x7c,
+	0xe5,
+	0x81,
+	0x24,
+	0xf8,
+	0xf5,
+	0x81,
+	0x22,
+	0x90,
+	0x64,
+	0xd0,
+	0x75,
+	0xf0,
+	0x00,
+	0x12,
+	0xad,
+	0x16,
+	0xac,
+	0x82,
+	0xad,
+	0x83,
+	0xae,
+	0xf0,
+	0xff,
+	0x90,
+	0x44,
+	0x10,
+	0xec,
+	0xf0,
+	0xa3,
+	0xed,
+	0xf0,
+	0xa3,
+	0xee,
+	0xf0,
+	0xa3,
+	0xef,
+	0xf0,
+	0x90,
+	0x64,
+	0xd4,
+	0x75,
+	0xf0,
+	0x00,
+	0x12,
+	0xad,
+	0x16,
+	0xac,
+	0x82,
+	0xad,
+	0x83,
+	0xae,
+	0xf0,
+	0xff,
+	0x90,
+	0x44,
+	0x0c,
+	0xec,
+	0xf0,
+	0xa3,
+	0xed,
+	0xf0,
+	0xa3,
+	0xee,
+	0xf0,
+	0xa3,
+	0xef,
+	0xf0,
+	0x90,
+	0x64,
+	0xd8,
+	0x75,
+	0xf0,
+	0x00,
+	0x12,
+	0xad,
+	0x16,
+	0xac,
+	0x82,
+	0xad,
+	0x83,
+	0xae,
+	0xf0,
+	0xff,
+	0x90,
+	0x44,
+	0x08,
+	0xec,
+	0xf0,
+	0xa3,
+	0xed,
+	0xf0,
+	0xa3,
+	0xee,
+	0xf0,
+	0xa3,
+	0xef,
+	0xf0,
+	0x90,
+	0x64,
+	0xdc,
+	0x75,
+	0xf0,
+	0x00,
+	0x12,
+	0xad,
+	0x16,
+	0xac,
+	0x82,
+	0xad,
+	0x83,
+	0xae,
+	0xf0,
+	0xff,
+	0x90,
+	0x44,
+	0x04,
+	0xec,
+	0xf0,
+	0xa3,
+	0xed,
+	0xf0,
+	0xa3,
+	0xee,
+	0xf0,
+	0xa3,
+	0xef,
+	0xf0,
+	0x90,
+	0x69,
+	0x9c,
+	0x75,
+	0xf0,
+	0x00,
+	0x12,
+	0xf4,
+	0x15,
+	0xfc,
+	0xa3,
+	0x12,
+	0xf4,
+	0x15,
+	0xfd,
+	0xa3,
+	0x12,
+	0xf4,
+	0x15,
+	0xfe,
+	0xa3,
+	0x12,
+	0xf4,
+	0x15,
+	0xff,
+	0x90,
+	0x44,
+	0x20,
+	0xec,
+	0xf0,
+	0xa3,
+	0xed,
+	0xf0,
+	0xa3,
+	0xee,
+	0xf0,
+	0xa3,
+	0xef,
+	0xf0,
+	0x90,
+	0x69,
+	0x98,
+	0x75,
+	0xf0,
+	0x00,
+	0x12,
+	0xf4,
+	0x15,
+	0xfc,
+	0xa3,
+	0x12,
+	0xf4,
+	0x15,
+	0xfd,
+	0xa3,
+	0x12,
+	0xf4,
+	0x15,
+	0xfe,
+	0xa3,
+	0x12,
+	0xf4,
+	0x15,
+	0xff,
+	0x90,
+	0x44,
+	0x1c,
+	0xec,
+	0xf0,
+	0xa3,
+	0xed,
+	0xf0,
+	0xa3,
+	0xee,
+	0xf0,
+	0xa3,
+	0xef,
+	0xf0,
+	0x90,
+	0x69,
+	0x94,
+	0x75,
+	0xf0,
+	0x00,
+	0x12,
+	0xf4,
+	0x15,
+	0xfc,
+	0xa3,
+	0x12,
+	0xf4,
+	0x15,
+	0xfd,
+	0xa3,
+	0x12,
+	0xf4,
+	0x15,
+	0xfe,
+	0xa3,
+	0x12,
+	0xf4,
+	0x15,
+	0xff,
+	0x90,
+	0x44,
+	0x18,
+	0xec,
+	0xf0,
+	0xa3,
+	0xed,
+	0xf0,
+	0xa3,
+	0xee,
+	0xf0,
+	0xa3,
+	0xef,
+	0xf0,
+	0x90,
+	0x69,
+	0x90,
+	0xe0,
+	0xfc,
+	0xa3,
+	0xe0,
+	0xfd,
+	0xa3,
+	0xe0,
+	0xfe,
+	0xa3,
+	0xe0,
+	0xff,
+	0x90,
+	0x44,
+	0x14,
+	0xec,
+	0xf0,
+	0xa3,
+	0xed,
+	0xf0,
+	0xa3,
+	0xee,
+	0xf0,
+	0xa3,
+	0xef,
+	0xf0,
+	0x90,
+	0x44,
+	0x24,
+	0xe0,
+	0xfc,
+	0xa3,
+	0xe0,
+	0xfd,
+	0xa3,
+	0xe0,
+	0xfe,
+	0xa3,
+	0xe0,
+	0xff,
+	0x90,
+	0x63,
+	0x68,
+	0xec,
+	0xf0,
+	0xa3,
+	0xed,
+	0xf0,
+	0xa3,
+	0xee,
+	0xf0,
+	0xa3,
+	0xef,
+	0xf0,
+	0x90,
+	0x44,
+	0x28,
+	0xe0,
+	0xfc,
+	0xa3,
+	0xe0,
+	0xfd,
+	0xa3,
+	0xe0,
+	0xfe,
+	0xa3,
+	0xe0,
+	0xff,
+	0x90,
+	0x63,
+	0x6c,
+	0x75,
+	0xf0,
+	0x00,
+	0xec,
+	0x12,
+	0xf3,
+	0x29,
+	0xa3,
+	0xed,
+	0x12,
+	0xf3,
+	0x29,
+	0xa3,
+	0xee,
+	0x12,
+	0xf3,
+	0x29,
+	0xa3,
+	0xef,
+	0x12,
+	0xf3,
+	0x29,
+	0x90,
+	0x44,
+	0x2c,
+	0xe0,
+	0xfc,
+	0xa3,
+	0xe0,
+	0xfd,
+	0xa3,
+	0xe0,
+	0xfe,
+	0xa3,
+	0xe0,
+	0xff,
+	0x90,
+	0x63,
+	0x70,
+	0x75,
+	0xf0,
+	0x00,
+	0xec,
+	0x12,
+	0xf3,
+	0x29,
+	0xa3,
+	0xed,
+	0x12,
+	0xf3,
+	0x29,
+	0xa3,
+	0xee,
+	0x12,
+	0xf3,
+	0x29,
+	0xa3,
+	0xef,
+	0x12,
+	0xf3,
+	0x29,
+	0x90,
+	0x44,
+	0x30,
+	0xe0,
+	0xfc,
+	0xa3,
+	0xe0,
+	0xfd,
+	0xa3,
+	0xe0,
+	0xfe,
+	0xa3,
+	0xe0,
+	0xff,
+	0x90,
+	0x63,
+	0x74,
+	0x75,
+	0xf0,
+	0x00,
+	0xec,
+	0x12,
+	0xf3,
+	0x29,
+	0xa3,
+	0xed,
+	0x12,
+	0xf3,
+	0x29,
+	0xa3,
+	0xee,
+	0x12,
+	0xf3,
+	0x29,
+	0xa3,
+	0xef,
+	0x12,
+	0xf3,
+	0x29,
+	0x74,
+	0x10,
+	0xc0,
+	0xe0,
+	0xe4,
+	0xc0,
+	0xe0,
+	0x74,
+	0x68,
+	0xc0,
+	0xe0,
+	0x74,
+	0x63,
+	0xc0,
+	0xe0,
+	0xe4,
+	0xc0,
+	0xe0,
+	0x74,
+	0xa0,
+	0xc0,
+	0xe0,
+	0x74,
+	0x69,
+	0xc0,
+	0xe0,
+	0xe4,
+	0xc0,
+	0xe0,
+	0x90,
+	0x63,
+	0x68,
+	0x75,
+	0xf0,
+	0x00,
+	0x12,
+	0x9e,
+	0x7c,
+	0xe5,
+	0x81,
+	0x24,
+	0xf8,
+	0xf5,
+	0x81,
+	0x22,
+	0xc0,
+	0x12,
+	0xe5,
+	0x81,
+	0xf5,
+	0x12,
+	0x24,
+	0x45,
+	0xf5,
+	0x81,
+	0x7d,
+	0x40,
+	0x7e,
+	0x61,
+	0x7f,
+	0x00,
+	0xa8,
+	0x12,
+	0x08,
+	0xe4,
+	0xf6,
+	0x08,
+	0xf6,
+	0xa8,
+	0x12,
+	0x08,
+	0xc3,
+	0xe6,
+	0x94,
+	0x80,
+	0x08,
+	0xe6,
+	0x64,
+	0x80,
+	0x94,
+	0x80,
+	0x50,
+	0x30,
+	0xa8,
+	0x12,
+	0x08,
+	0x86,
+	0x02,
+	0x74,
+	0x7f,
+	0xc3,
+	0x9a,
+	0x24,
+	0xd8,
+	0xfa,
+	0xe4,
+	0x34,
+	0x63,
+	0xfc,
+	0x8d,
+	0x82,
+	0x8e,
+	0x83,
+	0x8f,
+	0xf0,
+	0x12,
+	0xf4,
+	0x15,
+	0xfb,
+	0xa3,
+	0xad,
+	0x82,
+	0xae,
+	0x83,
+	0x8a,
+	0x82,
+	0x8c,
+	0x83,
+	0xeb,
+	0xf0,
+	0xa8,
+	0x12,
+	0x08,
+	0x06,
+	0xb6,
+	0x00,
+	0x02,
+	0x08,
+	0x06,
+	0x80,
+	0xc1,
+	0xe5,
+	0x12,
+	0x24,
+	0x23,
+	0xff,
+	0xfc,
+	0x7d,
+	0x00,
+	0x7e,
+	0x40,
+	0xc0,
+	0x07,
+	0xc0,
+	0x04,
+	0xc0,
+	0x05,
+	0xc0,
+	0x06,
+	0x74,
+	0x20,
+	0xc0,
+	0xe0,
+	0xe4,
+	0xc0,
+	0xe0,
+	0x74,
+	0x5f,
+	0xc0,
+	0xe0,
+	0xe4,
+	0xc0,
+	0xe0,
+	0x90,
+	0x63,
+	0xf9,
+	0x75,
+	0xf0,
+	0x00,
+	0x12,
+	0x9a,
+	0x67,
+	0xe5,
+	0x81,
+	0x24,
+	0xf9,
+	0xf5,
+	0x81,
+	0xd0,
+	0x07,
+	0xe5,
+	0x12,
+	0x24,
+	0x03,
+	0xfe,
+	0xe5,
+	0x12,
+	0x24,
+	0x43,
+	0xf8,
+	0xa6,
+	0x06,
+	0x08,
+	0x76,
+	0x00,
+	0x08,
+	0x76,
+	0x40,
+	0x8f,
+	0x02,
+	0x7d,
+	0x00,
+	0x7f,
+	0x40,
+	0xc0,
+	0x06,
+	0x74,
+	0x20,
+	0xc0,
+	0xe0,
+	0xe4,
+	0xc0,
+	0xe0,
+	0xe5,
+	0x12,
+	0x24,
+	0x43,
+	0xf8,
+	0xe6,
+	0xc0,
+	0xe0,
+	0x08,
+	0xe6,
+	0xc0,
+	0xe0,
+	0x08,
+	0xe6,
+	0xc0,
+	0xe0,
+	0xc0,
+	0x02,
+	0xc0,
+	0x05,
+	0xc0,
+	0x07,
+	0x90,
+	0x63,
+	0xd9,
+	0x75,
+	0xf0,
+	0x00,
+	0x12,
+	0x9e,
+	0x7c,
+	0xe5,
+	0x81,
+	0x24,
+	0xf8,
+	0xf5,
+	0x81,
+	0xd0,
+	0x06,
+	0x7f,
+	0x00,
+	0x7d,
+	0x40,
+	0x74,
+	0x79,
+	0xc0,
+	0xe0,
+	0x74,
+	0x63,
+	0xc0,
+	0xe0,
+	0xe4,
+	0xc0,
+	0xe0,
+	0x74,
+	0x5f,
+	0xc0,
+	0xe0,
+	0xe4,
+	0xc0,
+	0xe0,
+	0x74,
+	0x20,
+	0xc0,
+	0xe0,
+	0xe4,
+	0xc0,
+	0xe0,
+	0x8e,
+	0x82,
+	0x8f,
+	0x83,
+	0x8d,
+	0xf0,
+	0x12,
+	0x9a,
+	0x67,
+	0xe5,
+	0x81,
+	0x24,
+	0xf9,
+	0xf5,
+	0x81,
+	0x74,
+	0x5f,
+	0xc0,
+	0xe0,
+	0xe4,
+	0xc0,
+	0xe0,
+	0x74,
+	0x79,
+	0xc0,
+	0xe0,
+	0x74,
+	0x63,
+	0xc0,
+	0xe0,
+	0xe4,
+	0xc0,
+	0xe0,
+	0x74,
+	0x79,
+	0xc0,
+	0xe0,
+	0x74,
+	0x63,
+	0xc0,
+	0xe0,
+	0xe4,
+	0xc0,
+	0xe0,
+	0x90,
+	0x63,
+	0xf9,
+	0x75,
+	0xf0,
+	0x00,
+	0x12,
+	0x9e,
+	0x7c,
+	0xe5,
+	0x81,
+	0x24,
+	0xf8,
+	0xf5,
+	0x81,
+	0x7e,
+	0x00,
+	0x7f,
+	0x00,
+	0xc3,
+	0xee,
+	0x94,
+	0x10,
+	0xef,
+	0x64,
+	0x80,
+	0x94,
+	0x80,
+	0x50,
+	0x27,
+	0x8e,
+	0x05,
+	0x74,
+	0x0f,
+	0xc3,
+	0x9d,
+	0x24,
+	0x68,
+	0xfb,
+	0xe4,
+	0x34,
+	0x63,
+	0xfc,
+	0x74,
+	0x4f,
+	0x2d,
+	0x24,
+	0x79,
+	0xf5,
+	0x82,
+	0xe4,
+	0x34,
+	0x63,
+	0xf5,
+	0x83,
+	0xe0,
+	0xfd,
+	0x8b,
+	0x82,
+	0x8c,
+	0x83,
+	0xf0,
+	0x0e,
+	0xbe,
+	0x00,
+	0xd1,
+	0x0f,
+	0x80,
+	0xce,
+	0x85,
+	0x12,
+	0x81,
+	0xd0,
+	0x12,
+	0x22,
+	0x74,
+	0x50,
+	0xc0,
+	0xe0,
+	0xe4,
+	0xc0,
+	0xe0,
+	0x74,
+	0x50,
+	0xc0,
+	0xe0,
+	0xe4,
+	0xc0,
+	0xe0,
+	0x74,
+	0x50,
+	0xc0,
+	0xe0,
+	0xe4,
+	0xc0,
+	0xe0,
+	0x74,
+	0x40,
+	0xc0,
+	0xe0,
+	0xe4,
+	0xc0,
+	0xe0,
+	0x74,
+	0x30,
+	0xc0,
+	0xe0,
+	0xe4,
+	0xc0,
+	0xe0,
+	0x74,
+	0x20,
+	0xc0,
+	0xe0,
+	0xe4,
+	0xc0,
+	0xe0,
+	0x74,
+	0x10,
+	0xc0,
+	0xe0,
+	0xe4,
+	0xc0,
+	0xe0,
+	0xe4,
+	0xc0,
+	0xe0,
+	0xc0,
+	0xe0,
+	0x75,
+	0x82,
+	0x20,
+	0x12,
+	0x8f,
+	0xf9,
+	0xe5,
+	0x81,
+	0x24,
+	0xf0,
+	0xf5,
+	0x81,
+	0x22,
+	0xc0,
+	0x12,
+	0xe5,
+	0x81,
+	0xf5,
+	0x12,
+	0x24,
+	0x0d,
+	0xf5,
+	0x81,
+	0x74,
+	0x40,
+	0x24,
+	0x00,
+	0xfd,
+	0xe4,
+	0x34,
+	0x04,
+	0xfe,
+	0x7f,
+	0x00,
+	0xe5,
+	0x12,
+	0x24,
+	0x03,
+	0xf8,
+	0xa6,
+	0x05,
+	0x08,
+	0xa6,
+	0x06,
+	0x08,
+	0xa6,
+	0x07,
+	0xa8,
+	0x12,
+	0x08,
+	0xe4,
+	0xf6,
+	0x08,
+	0xf6,
+	0xa8,
+	0x12,
+	0x08,
+	0xc3,
+	0xe6,
+	0x94,
+	0x10,
+	0x08,
+	0xe6,
+	0x64,
+	0x80,
+	0x94,
+	0x80,
+	0x50,
+	0x65,
+	0xa8,
+	0x12,
+	0x08,
+	0x86,
+	0x02,
+	0x08,
+	0xe6,
+	0xca,
+	0x25,
+	0xe0,
+	0xca,
+	0x33,
+	0xca,
+	0x25,
+	0xe0,
+	0xca,
+	0x33,
+	0x24,
+	0x60,
+	0xfc,
+	0x8a,
+	0x07,
+	0x8c,
+	0x06,
+	0xe5,
+	0x12,
+	0x24,
+	0x03,
+	0xf8,
+	0xe6,
+	0x24,
+	0xfc,
+	0xf6,
+	0x08,
+	0xe6,
+	0x34,
+	0xff,
+	0xf6,
+	0xe5,
+	0x12,
+	0x24,
+	0x03,
+	0xf8,
+	0x86,
+	0x02,
+	0x08,
+	0x86,
+	0x03,
+	0x08,
+	0x86,
+	0x04,
+	0x8a,
+	0x82,
+	0x8b,
+	0x83,
+	0x8c,
+	0xf0,
+	0xc0,
+	0x07,
+	0xc0,
+	0x06,
+	0x12,
+	0xad,
+	0x16,
+	0xad,
+	0x82,
+	0xac,
+	0x83,
+	0xab,
+	0xf0,
+	0xfa,
+	0xd0,
+	0x06,
+	0xd0,
+	0x07,
+	0x8f,
+	0x82,
+	0x8e,
+	0x83,
+	0xed,
+	0xf0,
+	0xa3,
+	0xec,
+	0xf0,
+	0xa3,
+	0xeb,
+	0xf0,
+	0xa3,
+	0xea,
+	0xf0,
+	0xa8,
+	0x12,
+	0x08,
+	0x06,
+	0xb6,
+	0x00,
+	0x02,
+	0x08,
+	0x06,
+	0x80,
+	0x8c,
+	0x74,
+	0x80,
+	0x24,
+	0x00,
+	0xfd,
+	0xe4,
+	0x34,
+	0x04,
+	0xfe,
+	0x7f,
+	0x00,
+	0xe5,
+	0x12,
+	0x24,
+	0x06,
+	0xf8,
+	0xa6,
+	0x05,
+	0x08,
+	0xa6,
+	0x06,
+	0x08,
+	0xa6,
+	0x07,
+	0xa8,
+	0x12,
+	0x08,
+	0xe4,
+	0xf6,
+	0x08,
+	0xf6,
+	0xa8,
+	0x12,
+	0x08,
+	0xc3,
+	0xe6,
+	0x94,
+	0x10,
+	0x08,
+	0xe6,
+	0x64,
+	0x80,
+	0x94,
+	0x80,
+	0x50,
+	0x68,
+	0xa8,
+	0x12,
+	0x08,
+	0x74,
+	0x10,
+	0x26,
+	0xfa,
+	0xe4,
+	0x08,
+	0x36,
+	0xca,
+	0x25,
+	0xe0,
+	0xca,
+	0x33,
+	0xca,
+	0x25,
+	0xe0,
+	0xca,
+	0x33,
+	0x24,
+	0x60,
+	0xfc,
+	0x8a,
+	0x07,
+	0x8c,
+	0x06,
+	0xe5,
+	0x12,
+	0x24,
+	0x06,
+	0xf8,
+	0xe6,
+	0x24,
+	0xfc,
+	0xf6,
+	0x08,
+	0xe6,
+	0x34,
+	0xff,
+	0xf6,
+	0xe5,
+	0x12,
+	0x24,
+	0x06,
+	0xf8,
+	0x86,
+	0x02,
+	0x08,
+	0x86,
+	0x03,
+	0x08,
+	0x86,
+	0x04,
+	0x8a,
+	0x82,
+	0x8b,
+	0x83,
+	0x8c,
+	0xf0,
+	0xc0,
+	0x07,
+	0xc0,
+	0x06,
+	0x12,
+	0xad,
+	0x16,
+	0xad,
+	0x82,
+	0xac,
+	0x83,
+	0xab,
+	0xf0,
+	0xfa,
+	0xd0,
+	0x06,
+	0xd0,
+	0x07,
+	0x8f,
+	0x82,
+	0x8e,
+	0x83,
+	0xed,
+	0xf0,
+	0xa3,
+	0xec,
+	0xf0,
+	0xa3,
+	0xeb,
+	0xf0,
+	0xa3,
+	0xea,
+	0xf0,
+	0xa8,
+	0x12,
+	0x08,
+	0x06,
+	0xb6,
+	0x00,
+	0x02,
+	0x08,
+	0x06,
+	0x80,
+	0x89,
+	0x74,
+	0xc0,
+	0x24,
+	0x00,
+	0xfd,
+	0xe4,
+	0x34,
+	0x04,
+	0xfe,
+	0x7f,
+	0x00,
+	0xe5,
+	0x12,
+	0x24,
+	0x0a,
+	0xf8,
+	0xa6,
+	0x05,
+	0x08,
+	0xa6,
+	0x06,
+	0x08,
+	0xa6,
+	0x07,
+	0xa8,
+	0x12,
+	0x08,
+	0xe4,
+	0xf6,
+	0x08,
+	0xf6,
+	0xa8,
+	0x12,
+	0x08,
+	0xc3,
+	0xe6,
+	0x94,
+	0x10,
+	0x08,
+	0xe6,
+	0x64,
+	0x80,
+	0x94,
+	0x80,
+	0x50,
+	0x68,
+	0xa8,
+	0x12,
+	0x08,
+	0x74,
+	0x20,
+	0x26,
+	0xfa,
+	0xe4,
+	0x08,
+	0x36,
+	0xca,
+	0x25,
+	0xe0,
+	0xca,
+	0x33,
+	0xca,
+	0x25,
+	0xe0,
+	0xca,
+	0x33,
+	0x24,
+	0x60,
+	0xfc,
+	0x8a,
+	0x07,
+	0x8c,
+	0x06,
+	0xe5,
+	0x12,
+	0x24,
+	0x0a,
+	0xf8,
+	0xe6,
+	0x24,
+	0xfc,
+	0xf6,
+	0x08,
+	0xe6,
+	0x34,
+	0xff,
+	0xf6,
+	0xe5,
+	0x12,
+	0x24,
+	0x0a,
+	0xf8,
+	0x86,
+	0x02,
+	0x08,
+	0x86,
+	0x03,
+	0x08,
+	0x86,
+	0x04,
+	0x8a,
+	0x82,
+	0x8b,
+	0x83,
+	0x8c,
+	0xf0,
+	0xc0,
+	0x07,
+	0xc0,
+	0x06,
+	0x12,
+	0xad,
+	0x16,
+	0xad,
+	0x82,
+	0xac,
+	0x83,
+	0xab,
+	0xf0,
+	0xfa,
+	0xd0,
+	0x06,
+	0xd0,
+	0x07,
+	0x8f,
+	0x82,
+	0x8e,
+	0x83,
+	0xed,
+	0xf0,
+	0xa3,
+	0xec,
+	0xf0,
+	0xa3,
+	0xeb,
+	0xf0,
+	0xa3,
+	0xea,
+	0xf0,
+	0xa8,
+	0x12,
+	0x08,
+	0x06,
+	0xb6,
+	0x00,
+	0x02,
+	0x08,
+	0x06,
+	0x80,
+	0x89,
+	0x7d,
+	0x00,
+	0x74,
+	0x01,
+	0x24,
+	0x04,
+	0xfe,
+	0x7f,
+	0x00,
+	0xe5,
+	0x12,
+	0x24,
+	0x0a,
+	0xf8,
+	0xa6,
+	0x05,
+	0x08,
+	0xa6,
+	0x06,
+	0x08,
+	0xa6,
+	0x07,
+	0xa8,
+	0x12,
+	0x08,
+	0xe4,
+	0xf6,
+	0x08,
+	0xf6,
+	0xa8,
+	0x12,
+	0x08,
+	0xc3,
+	0xe6,
+	0x94,
+	0x10,
+	0x08,
+	0xe6,
+	0x64,
+	0x80,
+	0x94,
+	0x80,
+	0x50,
+	0x68,
+	0xa8,
+	0x12,
+	0x08,
+	0x74,
+	0x30,
+	0x26,
+	0xfa,
+	0xe4,
+	0x08,
+	0x36,
+	0xca,
+	0x25,
+	0xe0,
+	0xca,
+	0x33,
+	0xca,
+	0x25,
+	0xe0,
+	0xca,
+	0x33,
+	0x24,
+	0x60,
+	0xfc,
+	0x8a,
+	0x06,
+	0x8c,
+	0x05,
+	0xe5,
+	0x12,
+	0x24,
+	0x0a,
+	0xf8,
+	0xe6,
+	0x24,
+	0xfc,
+	0xf6,
+	0x08,
+	0xe6,
+	0x34,
+	0xff,
+	0xf6,
+	0xe5,
+	0x12,
+	0x24,
+	0x0a,
+	0xf8,
+	0x86,
+	0x02,
+	0x08,
+	0x86,
+	0x03,
+	0x08,
+	0x86,
+	0x04,
+	0x8a,
+	0x82,
+	0x8b,
+	0x83,
+	0x8c,
+	0xf0,
+	0xc0,
+	0x06,
+	0xc0,
+	0x05,
+	0x12,
+	0xad,
+	0x16,
+	0xaa,
+	0x82,
+	0xab,
+	0x83,
+	0xac,
+	0xf0,
+	0xff,
+	0xd0,
+	0x05,
+	0xd0,
+	0x06,
+	0x8e,
+	0x82,
+	0x8d,
+	0x83,
+	0xea,
+	0xf0,
+	0xa3,
+	0xeb,
+	0xf0,
+	0xa3,
+	0xec,
+	0xf0,
+	0xa3,
+	0xef,
+	0xf0,
+	0xa8,
+	0x12,
+	0x08,
+	0x06,
+	0xb6,
+	0x00,
+	0x02,
+	0x08,
+	0x06,
+	0x80,
+	0x89,
+	0xe5,
+	0x12,
+	0x24,
+	0x0a,
+	0xf8,
+	0x74,
+	0x40,
+	0x24,
+	0x00,
+	0xf6,
+	0x74,
+	0x01,
+	0x34,
+	0x04,
+	0x08,
+	0xf6,
+	0x08,
+	0x76,
+	0x00,
+	0xa8,
+	0x12,
+	0x08,
+	0xe4,
+	0xf6,
+	0x08,
+	0xf6,
+	0xa8,
+	0x12,
+	0x08,
+	0xc3,
+	0xe6,
+	0x94,
+	0x10,
+	0x08,
+	0xe6,
+	0x64,
+	0x80,
+	0x94,
+	0x80,
+	0x50,
+	0x68,
+	0xa8,
+	0x12,
+	0x08,
+	0x74,
+	0x40,
+	0x26,
+	0xfa,
+	0xe4,
+	0x08,
+	0x36,
+	0xca,
+	0x25,
+	0xe0,
+	0xca,
+	0x33,
+	0xca,
+	0x25,
+	0xe0,
+	0xca,
+	0x33,
+	0x24,
+	0x60,
+	0xfc,
+	0x8a,
+	0x06,
+	0x8c,
+	0x05,
+	0xe5,
+	0x12,
+	0x24,
+	0x0a,
+	0xf8,
+	0xe6,
+	0x24,
+	0xfc,
+	0xf6,
+	0x08,
+	0xe6,
+	0x34,
+	0xff,
+	0xf6,
+	0xe5,
+	0x12,
+	0x24,
+	0x0a,
+	0xf8,
+	0x86,
+	0x02,
+	0x08,
+	0x86,
+	0x03,
+	0x08,
+	0x86,
+	0x04,
+	0x8a,
+	0x82,
+	0x8b,
+	0x83,
+	0x8c,
+	0xf0,
+	0xc0,
+	0x06,
+	0xc0,
+	0x05,
+	0x12,
+	0xad,
+	0x16,
+	0xaa,
+	0x82,
+	0xab,
+	0x83,
+	0xac,
+	0xf0,
+	0xff,
+	0xd0,
+	0x05,
+	0xd0,
+	0x06,
+	0x8e,
+	0x82,
+	0x8d,
+	0x83,
+	0xea,
+	0xf0,
+	0xa3,
+	0xeb,
+	0xf0,
+	0xa3,
+	0xec,
+	0xf0,
+	0xa3,
+	0xef,
+	0xf0,
+	0xa8,
+	0x12,
+	0x08,
+	0x06,
+	0xb6,
+	0x00,
+	0x02,
+	0x08,
+	0x06,
+	0x80,
+	0x89,
+	0x85,
+	0x12,
+	0x81,
+	0xd0,
+	0x12,
+	0x22,
+	0x12,
+	0xcc,
+	0xb9,
+	0x12,
+	0xcc,
+	0x76,
+	0x02,
+	0xcb,
+	0x13,
+	0x90,
+	0x30,
+	0x01,
+	0xe0,
+	0xff,
+	0x30,
+	0xe1,
+	0x32,
+	0x90,
+	0x69,
+	0x87,
+	0x74,
+	0x3b,
+	0xf0,
+	0x90,
+	0x69,
+	0x86,
+	0x74,
+	0xa0,
+	0xf0,
+	0x90,
+	0x69,
+	0x85,
+	0x74,
+	0xbe,
+	0xf0,
+	0x90,
+	0x69,
+	0x84,
+	0x74,
+	0xde,
+	0xf0,
+	0x90,
+	0x69,
+	0x83,
+	0x74,
+	0x0c,
+	0xf0,
+	0x90,
+	0x69,
+	0x82,
+	0x74,
+	0x46,
+	0xf0,
+	0x90,
+	0x69,
+	0x81,
+	0x74,
+	0xa9,
+	0xf0,
+	0x90,
+	0x69,
+	0x80,
+	0x74,
+	0x91,
+	0xf0,
+	0x80,
+	0x12,
+	0x90,
+	0x69,
+	0x84,
+	0x75,
+	0xf0,
+	0x00,
+	0x12,
+	0xec,
+	0xc0,
+	0x90,
+	0x69,
+	0x80,
+	0x75,
+	0xf0,
+	0x00,
+	0x12,
+	0xec,
+	0xc0,
+	0x22,
+	0x90,
+	0x30,
+	0x0b,
+	0x74,
+	0x16,
+	0xf0,
+	0x90,
+	0x30,
+	0x0c,
+	0x74,
+	0x82,
+	0xf0,
+	0x75,
+	0x90,
+	0x03,
+	0x7e,
+	0x00,
+	0x7f,
+	0x00,
+	0x7c,
+	0x00,
+	0x7d,
+	0x00,
+	0xc3,
+	0xec,
+	0x94,
+	0x8a,
+	0xed,
+	0x64,
+	0x80,
+	0x94,
+	0x80,
+	0x50,
+	0x2a,
+	0x74,
+	0xfe,
+	0x25,
+	0x90,
+	0x50,
+	0xfa,
+	0xc3,
+	0xee,
+	0x94,
+	0x05,
+	0xef,
+	0x64,
+	0x80,
+	0x94,
+	0x80,
+	0x50,
+	0x05,
+	0x0e,
+	0xbe,
+	0x00,
+	0x01,
+	0x0f,
+	0xec,
+	0x24,
+	0x40,
+	0xf5,
+	0x82,
+	0xed,
+	0x34,
+	0x05,
+	0xf5,
+	0x83,
+	0xe0,
+	0xf5,
+	0x90,
+	0x0c,
+	0xbc,
+	0x00,
+	0xce,
+	0x0d,
+	0x80,
+	0xcb,
+	0x7e,
+	0x00,
+	0x7f,
+	0x00,
+	0xc3,
+	0xee,
+	0x94,
+	0x80,
+	0xef,
+	0x64,
+	0x80,
+	0x94,
+	0x81,
+	0x50,
+	0x24,
+	0x74,
+	0xfe,
+	0x25,
+	0x90,
+	0x50,
+	0xfa,
+	0x90,
+	0x30,
+	0x00,
+	0xe0,
+	0xfd,
+	0xbd,
+	0x01,
+	0x04,
+	0x7d,
+	0x00,
+	0x80,
+	0x09,
+	0x8e,
+	0x82,
+	0x74,
+	0x06,
+	0x2f,
+	0xf5,
+	0x83,
+	0xe0,
+	0xfd,
+	0x8d,
+	0x90,
+	0x0e,
+	0xbe,
+	0x00,
+	0xd4,
+	0x0f,
+	0x80,
+	0xd1,
+	0x12,
+	0xcf,
+	0xb6,
+	0x74,
+	0xf8,
+	0x25,
+	0x90,
+	0x50,
+	0xfa,
+	0x7e,
+	0x00,
+	0x7f,
+	0x00,
+	0xc3,
+	0xee,
+	0x94,
+	0x08,
+	0xef,
+	0x64,
+	0x80,
+	0x94,
+	0x80,
+	0x50,
+	0x24,
+	0x74,
+	0x07,
+	0xc3,
+	0x9e,
+	0xfc,
+	0xe4,
+	0x9f,
+	0xfd,
+	0xec,
+	0x24,
+	0x80,
+	0xfc,
+	0xed,
+	0x34,
+	0x69,
+	0xfd,
+	0x7b,
+	0x00,
+	0x8c,
+	0x82,
+	0x8d,
+	0x83,
+	0x8b,
+	0xf0,
+	0x12,
+	0xf4,
+	0x15,
+	0xf5,
+	0x90,
+	0x0e,
+	0xbe,
+	0x00,
+	0xd4,
+	0x0f,
+	0x80,
+	0xd1,
+	0x74,
+	0xfd,
+	0x25,
+	0x90,
+	0x50,
+	0xfa,
+	0x75,
+	0x90,
+	0x02,
+	0x75,
+	0x90,
+	0x00,
+	0x90,
+	0x30,
+	0x45,
+	0xe0,
+	0xf5,
+	0x90,
+	0x90,
+	0x30,
+	0x0c,
+	0xe0,
+	0xff,
+	0x30,
+	0xe6,
+	0xf8,
+	0x90,
+	0x30,
+	0x0c,
+	0xe4,
+	0xf0,
+	0x22,
+	0xc0,
+	0x12,
+	0x85,
+	0x81,
+	0x12,
+	0x05,
+	0x81,
+	0x05,
+	0x81,
+	0x7c,
+	0x80,
+	0x7d,
+	0x68,
+	0x53,
+	0x05,
+	0x0f,
+	0xe4,
+	0xfe,
+	0xc3,
+	0x13,
+	0xff,
+	0xee,
+	0x13,
+	0xfe,
+	0xed,
+	0x13,
+	0xfd,
+	0xec,
+	0x13,
+	0xfc,
+	0xef,
+	0xc3,
+	0x13,
+	0xee,
+	0x13,
+	0xed,
+	0x13,
+	0xfd,
+	0xec,
+	0x13,
+	0x90,
+	0x40,
+	0x04,
+	0xf0,
+	0xa3,
+	0xed,
+	0xf0,
+	0x90,
+	0x40,
+	0x0a,
+	0xe4,
+	0xf0,
+	0x7c,
+	0x00,
+	0x7d,
+	0x69,
+	0x53,
+	0x05,
+	0x0f,
+	0xe4,
+	0xfe,
+	0xc3,
+	0x13,
+	0xff,
+	0xee,
+	0x13,
+	0xfe,
+	0xed,
+	0x13,
+	0xfd,
+	0xec,
+	0x13,
+	0xfc,
+	0xef,
+	0xc3,
+	0x13,
+	0xee,
+	0x13,
+	0xed,
+	0x13,
+	0xfd,
+	0xec,
+	0x13,
+	0x90,
+	0x40,
+	0x08,
+	0xf0,
+	0xa3,
+	0xed,
+	0xf0,
+	0x7c,
+	0xc0,
+	0x7d,
+	0x64,
+	0x53,
+	0x05,
+	0x0f,
+	0xe4,
+	0xfe,
+	0xc3,
+	0x13,
+	0xff,
+	0xee,
+	0x13,
+	0xfe,
+	0xed,
+	0x13,
+	0xfd,
+	0xec,
+	0x13,
+	0xfc,
+	0xef,
+	0xc3,
+	0x13,
+	0xff,
+	0xee,
+	0x13,
+	0xfe,
+	0xed,
+	0x13,
+	0xfd,
+	0xec,
+	0x13,
+	0xfc,
+	0x90,
+	0x40,
+	0x0c,
+	0xf0,
+	0xa3,
+	0xed,
+	0xf0,
+	0x90,
+	0x42,
+	0x41,
+	0x74,
+	0x82,
+	0xf0,
+	0x90,
+	0x40,
+	0x00,
+	0xe0,
+	0x70,
+	0xfa,
+	0xfe,
+	0xff,
+	0xc3,
+	0xee,
+	0x94,
+	0x05,
+	0xef,
+	0x64,
+	0x80,
+	0x94,
+	0x80,
+	0x50,
+	0x7c,
+	0x8e,
+	0x04,
+	0xef,
+	0x54,
+	0x03,
+	0xa2,
+	0xe0,
+	0xcc,
+	0x13,
+	0xcc,
+	0x13,
+	0xa2,
+	0xe0,
+	0xcc,
+	0x13,
+	0xcc,
+	0x13,
+	0xcc,
+	0xfd,
+	0x7a,
+	0x00,
+	0x7b,
+	0x00,
+	0xc3,
+	0xea,
+	0x94,
+	0x40,
+	0xeb,
+	0x64,
+	0x80,
+	0x94,
+	0x80,
+	0x50,
+	0x34,
+	0xc0,
+	0x06,
+	0xc0,
+	0x07,
+	0xa8,
+	0x12,
+	0x08,
+	0xea,
+	0x24,
+	0x80,
+	0xf6,
+	0xeb,
+	0x34,
+	0x68,
+	0x08,
+	0xf6,
+	0xec,
+	0x2a,
+	0xfe,
+	0xed,
+	0x3b,
+	0xff,
+	0x8e,
+	0x82,
+	0x74,
+	0x04,
+	0x2f,
+	0xf5,
+	0x83,
+	0xe0,
+	0xff,
+	0xa8,
+	0x12,
+	0x08,
+	0x86,
+	0x82,
+	0x08,
+	0x86,
+	0x83,
+	0xef,
+	0xf0,
+	0x0a,
+	0xba,
+	0x00,
+	0x01,
+	0x0b,
+	0xd0,
+	0x07,
+	0xd0,
+	0x06,
+	0x80,
+	0xc1,
+	0xbe,
+	0x04,
+	0x0f,
+	0xbf,
+	0x00,
+	0x0c,
+	0x90,
+	0x42,
+	0x41,
+	0x74,
+	0x84,
+	0xf0,
+	0x90,
+	0x40,
+	0x00,
+	0xe0,
+	0x70,
+	0xfa,
+	0x90,
+	0x42,
+	0x41,
+	0x74,
+	0x81,
+	0xf0,
+	0x90,
+	0x40,
+	0x00,
+	0xe0,
+	0x70,
+	0xfa,
+	0x0e,
+	0xbe,
+	0x00,
+	0x01,
+	0x0f,
+	0x02,
+	0xd1,
+	0x6f,
+	0x85,
+	0x12,
+	0x81,
+	0xd0,
+	0x12,
+	0x22,
+	0xc0,
+	0x12,
+	0xe5,
+	0x81,
+	0xf5,
+	0x12,
+	0x24,
+	0x09,
+	0xf5,
+	0x81,
+	0xe5,
+	0x12,
+	0x24,
+	0x03,
+	0xff,
+	0xe5,
+	0x12,
+	0x24,
+	0x07,
+	0xf8,
+	0xa6,
+	0x07,
+	0x08,
+	0x76,
+	0x00,
+	0x08,
+	0x76,
+	0x40,
+	0x7a,
+	0xc0,
+	0x7b,
+	0x61,
+	0x7c,
+	0x00,
+	0xa8,
+	0x12,
+	0x08,
+	0xe4,
+	0xf6,
+	0x08,
+	0xf6,
+	0xa8,
+	0x12,
+	0x08,
+	0xc3,
+	0xe6,
+	0x94,
+	0x80,
+	0x08,
+	0xe6,
+	0x64,
+	0x80,
+	0x94,
+	0x80,
+	0x40,
+	0x03,
+	0x02,
+	0xd2,
+	0xd7,
+	0x74,
+	0xfc,
+	0x25,
+	0xb0,
+	0x50,
+	0xfa,
+	0xe5,
+	0x12,
+	0x24,
+	0x07,
+	0xf8,
+	0x74,
+	0x03,
+	0x26,
+	0xfd,
+	0xe4,
+	0x08,
+	0x36,
+	0xfe,
+	0x08,
+	0x86,
+	0x07,
+	0x8d,
+	0x82,
+	0x8e,
+	0x83,
+	0x8f,
+	0xf0,
+	0xe5,
+	0xa0,
+	0x12,
+	0xf3,
+	0x29,
+	0xe5,
+	0x12,
+	0x24,
+	0x07,
+	0xf8,
+	0x74,
+	0x02,
+	0x26,
+	0xfd,
+	0xe4,
+	0x08,
+	0x36,
+	0xfe,
+	0x08,
+	0x86,
+	0x07,
+	0x8d,
+	0x82,
+	0x8e,
+	0x83,
+	0x8f,
+	0xf0,
+	0xe5,
+	0xa0,
+	0x12,
+	0xf3,
+	0x29,
+	0xe5,
+	0x12,
+	0x24,
+	0x07,
+	0xf8,
+	0x74,
+	0x01,
+	0x26,
+	0xfd,
+	0xe4,
+	0x08,
+	0x36,
+	0xfe,
+	0x08,
+	0x86,
+	0x07,
+	0x8d,
+	0x82,
+	0x8e,
+	0x83,
+	0x8f,
+	0xf0,
+	0xe5,
+	0xa0,
+	0x12,
+	0xf3,
+	0x29,
+	0xe5,
+	0x12,
+	0x24,
+	0x07,
+	0xf8,
+	0x86,
+	0x82,
+	0x08,
+	0x86,
+	0x83,
+	0x08,
+	0x86,
+	0xf0,
+	0xe5,
+	0xa0,
+	0x12,
+	0xf3,
+	0x29,
+	0xea,
+	0x24,
+	0xfc,
+	0xfa,
+	0xeb,
+	0x34,
+	0xff,
+	0xfb,
+	0x8a,
+	0x82,
+	0x8b,
+	0x83,
+	0x8c,
+	0xf0,
+	0xe5,
+	0x12,
+	0x24,
+	0x03,
+	0xf8,
+	0xe6,
+	0x12,
+	0xf3,
+	0x29,
+	0xa3,
+	0x08,
+	0xe6,
+	0x12,
+	0xf3,
+	0x29,
+	0xa3,
+	0x08,
+	0xe6,
+	0x12,
+	0xf3,
+	0x29,
+	0xa3,
+	0x08,
+	0xe6,
+	0x12,
+	0xf3,
+	0x29,
+	0xa8,
+	0x12,
+	0x08,
+	0x74,
+	0x04,
+	0x26,
+	0xf6,
+	0xe4,
+	0x08,
+	0x36,
+	0xf6,
+	0x02,
+	0xd2,
+	0x25,
+	0x85,
+	0x12,
+	0x81,
+	0xd0,
+	0x12,
+	0x22,
+	0x74,
+	0xf0,
+	0x25,
+	0xb0,
+	0x50,
+	0xfa,
+	0x7e,
+	0x00,
+	0x7f,
+	0x00,
+	0xc3,
+	0xee,
+	0x94,
+	0x10,
+	0xef,
+	0x64,
+	0x80,
+	0x94,
+	0x80,
+	0x50,
+	0x19,
+	0x8e,
+	0x05,
+	0x74,
+	0x0f,
+	0xc3,
+	0x9d,
+	0x24,
+	0xa0,
+	0xf5,
+	0x82,
+	0xe4,
+	0x34,
+	0x69,
+	0xf5,
+	0x83,
+	0xe5,
+	0xa0,
+	0xf0,
+	0x0e,
+	0xbe,
+	0x00,
+	0xdf,
+	0x0f,
+	0x80,
+	0xdc,
+	0x74,
+	0xf0,
+	0x25,
+	0xb0,
+	0x50,
+	0xfa,
+	0x7e,
+	0x00,
+	0x7f,
+	0x00,
+	0xc3,
+	0xee,
+	0x94,
+	0x10,
+	0xef,
+	0x64,
+	0x80,
+	0x94,
+	0x80,
+	0x50,
+	0x19,
+	0x8e,
+	0x05,
+	0x74,
+	0x0f,
+	0xc3,
+	0x9d,
+	0x24,
+	0x90,
+	0xf5,
+	0x82,
+	0xe4,
+	0x34,
+	0x69,
+	0xf5,
+	0x83,
+	0xe5,
+	0xa0,
+	0xf0,
+	0x0e,
+	0xbe,
+	0x00,
+	0xdf,
+	0x0f,
+	0x80,
+	0xdc,
+	0x22,
+	0x90,
+	0x30,
+	0x00,
+	0xe0,
+	0xff,
+	0xbf,
+	0x0a,
+	0x02,
+	0x80,
+	0xfe,
+	0x90,
+	0x30,
+	0x0b,
+	0x74,
+	0x11,
+	0xf0,
+	0x90,
+	0x30,
+	0x0c,
+	0x74,
+	0x80,
+	0xf0,
+	0x75,
+	0x90,
+	0x08,
+	0x7e,
+	0x00,
+	0x7f,
+	0x00,
+	0xc3,
+	0xee,
+	0x94,
+	0x10,
+	0xef,
+	0x64,
+	0x80,
+	0x94,
+	0x80,
+	0x50,
+	0x26,
+	0x90,
+	0x30,
+	0x00,
+	0xe0,
+	0xfd,
+	0xbd,
+	0x03,
+	0x04,
+	0x7d,
+	0x00,
+	0x80,
+	0x11,
+	0x8e,
+	0x04,
+	0x74,
+	0x0f,
+	0xc3,
+	0x9c,
+	0x24,
+	0x90,
+	0xf5,
+	0x82,
+	0xe4,
+	0x34,
+	0x64,
+	0xf5,
+	0x83,
+	0xe0,
+	0xfd,
+	0x8d,
+	0x90,
+	0x0e,
+	0xbe,
+	0x00,
+	0xd2,
+	0x0f,
+	0x80,
+	0xcf,
+	0x90,
+	0x30,
+	0x0c,
+	0xe0,
+	0xff,
+	0x30,
+	0xe6,
+	0xf8,
+	0x90,
+	0x30,
+	0x0c,
+	0xe4,
+	0xf0,
+	0x22,
+	0x74,
+	0xf8,
+	0x25,
+	0xb0,
+	0x50,
+	0xfa,
+	0x7e,
+	0x00,
+	0x7f,
+	0x00,
+	0xc3,
+	0xee,
+	0x94,
+	0x08,
+	0xef,
+	0x64,
+	0x80,
+	0x94,
+	0x80,
+	0x50,
+	0x19,
+	0x8e,
+	0x05,
+	0x74,
+	0x07,
+	0xc3,
+	0x9d,
+	0x24,
+	0x40,
+	0xf5,
+	0x82,
+	0xe4,
+	0x34,
+	0x63,
+	0xf5,
+	0x83,
+	0xe5,
+	0xa0,
+	0xf0,
+	0x0e,
+	0xbe,
+	0x00,
+	0xdf,
+	0x0f,
+	0x80,
+	0xdc,
+	0x22,
+	0x90,
+	0x30,
+	0x00,
+	0xe0,
+	0xff,
+	0xbf,
+	0x09,
+	0x02,
+	0x80,
+	0xfe,
+	0x90,
+	0x30,
+	0x0b,
+	0x74,
+	0x21,
+	0xf0,
+	0x90,
+	0x30,
+	0x0c,
+	0x74,
+	0x80,
+	0xf0,
+	0x75,
+	0x90,
+	0x07,
+	0x7e,
+	0x00,
+	0x7f,
+	0x00,
+	0xc3,
+	0xee,
+	0x94,
+	0x20,
+	0xef,
+	0x64,
+	0x80,
+	0x94,
+	0x80,
+	0x50,
+	0x27,
+	0x74,
+	0xfe,
+	0x25,
+	0x90,
+	0x50,
+	0xfa,
+	0x90,
+	0x30,
+	0x00,
+	0xe0,
+	0xfd,
+	0xbd,
+	0x02,
+	0x04,
+	0x7d,
+	0x00,
+	0x80,
+	0x0c,
+	0xee,
+	0x24,
+	0x40,
+	0xf5,
+	0x82,
+	0xef,
+	0x34,
+	0x69,
+	0xf5,
+	0x83,
+	0xe0,
+	0xfd,
+	0x8d,
+	0x90,
+	0x0e,
+	0xbe,
+	0x00,
+	0xd1,
+	0x0f,
+	0x80,
+	0xce,
+	0x90,
+	0x30,
+	0x0c,
+	0xe0,
+	0xff,
+	0x30,
+	0xe6,
+	0xf8,
+	0x90,
+	0x30,
+	0x0c,
+	0xe4,
+	0xf0,
+	0x22,
+	0x90,
+	0x30,
+	0x00,
+	0xe0,
+	0xff,
+	0xbf,
+	0x0b,
+	0x02,
+	0x80,
+	0xfe,
+	0x75,
+	0x90,
+	0x0a,
+	0x90,
+	0x30,
+	0x0b,
+	0x74,
+	0x21,
+	0xf0,
+	0x90,
+	0x30,
+	0x0c,
+	0x74,
+	0x80,
+	0xf0,
+	0x7e,
+	0x00,
+	0x7f,
+	0x00,
+	0xc3,
+	0xee,
+	0x94,
+	0x20,
+	0xef,
+	0x64,
+	0x80,
+	0x94,
+	0x80,
+	0x50,
+	0x27,
+	0x74,
+	0xfe,
+	0x25,
+	0x90,
+	0x50,
+	0xfa,
+	0x90,
+	0x30,
+	0x00,
+	0xe0,
+	0xfd,
+	0xbd,
+	0x04,
+	0x04,
+	0x7d,
+	0x00,
+	0x80,
+	0x0c,
+	0xee,
+	0x24,
+	0x40,
+	0xf5,
+	0x82,
+	0xef,
+	0x34,
+	0x69,
+	0xf5,
+	0x83,
+	0xe0,
+	0xfd,
+	0x8d,
+	0x90,
+	0x0e,
+	0xbe,
+	0x00,
+	0xd1,
+	0x0f,
+	0x80,
+	0xce,
+	0x90,
+	0x30,
+	0x0c,
+	0xe0,
+	0xff,
+	0x30,
+	0xe6,
+	0xf8,
+	0x90,
+	0x30,
+	0x0c,
+	0xe4,
+	0xf0,
+	0x22,
+	0x74,
+	0xf0,
+	0x25,
+	0xb0,
+	0x50,
+	0xfa,
+	0x7e,
+	0x00,
+	0x7f,
+	0x00,
+	0xc3,
+	0xee,
+	0x94,
+	0x10,
+	0xef,
+	0x64,
+	0x80,
+	0x94,
+	0x80,
+	0x50,
+	0x19,
+	0x8e,
+	0x05,
+	0x74,
+	0x0f,
+	0xc3,
+	0x9d,
+	0x24,
+	0x80,
+	0xf5,
+	0x82,
+	0xe4,
+	0x34,
+	0x64,
+	0xf5,
+	0x83,
+	0xe5,
+	0xa0,
+	0xf0,
+	0x0e,
+	0xbe,
+	0x00,
+	0xdf,
+	0x0f,
+	0x80,
+	0xdc,
+	0x74,
+	0xf8,
+	0x25,
+	0xb0,
+	0x50,
+	0xfa,
+	0x7e,
+	0x00,
+	0x7f,
+	0x00,
+	0xc3,
+	0xee,
+	0x94,
+	0x08,
+	0xef,
+	0x64,
+	0x80,
+	0x94,
+	0x80,
+	0x50,
+	0x19,
+	0x8e,
+	0x05,
+	0x74,
+	0x07,
+	0xc3,
+	0x9d,
+	0x24,
+	0x50,
+	0xf5,
+	0x82,
+	0xe4,
+	0x34,
+	0x63,
+	0xf5,
+	0x83,
+	0xe5,
+	0xa0,
+	0xf0,
+	0x0e,
+	0xbe,
+	0x00,
+	0xdf,
+	0x0f,
+	0x80,
+	0xdc,
+	0x22,
+	0x74,
+	0x10,
+	0xc0,
+	0xe0,
+	0xe4,
+	0xc0,
+	0xe0,
+	0x74,
+	0x58,
+	0xc0,
+	0xe0,
+	0x74,
+	0x63,
+	0xc0,
+	0xe0,
+	0xe4,
+	0xc0,
+	0xe0,
+	0x74,
+	0x80,
+	0xc0,
+	0xe0,
+	0x74,
+	0x64,
+	0xc0,
+	0xe0,
+	0xe4,
+	0xc0,
+	0xe0,
+	0x90,
+	0x64,
+	0xe0,
+	0x75,
+	0xf0,
+	0x00,
+	0x12,
+	0x9e,
+	0x7c,
+	0xe5,
+	0x81,
+	0x24,
+	0xf8,
+	0xf5,
+	0x81,
+	0x74,
+	0x08,
+	0xc0,
+	0xe0,
+	0xe4,
+	0xc0,
+	0xe0,
+	0x74,
+	0x58,
+	0xc0,
+	0xe0,
+	0x74,
+	0x63,
+	0xc0,
+	0xe0,
+	0xe4,
+	0xc0,
+	0xe0,
+	0x74,
+	0x80,
+	0xc0,
+	0xe0,
+	0x74,
+	0x69,
+	0xc0,
+	0xe0,
+	0xe4,
+	0xc0,
+	0xe0,
+	0x90,
+	0x63,
+	0x58,
+	0x75,
+	0xf0,
+	0x00,
+	0x12,
+	0x9e,
+	0x7c,
+	0xe5,
+	0x81,
+	0x24,
+	0xf8,
+	0xf5,
+	0x81,
+	0x22,
+	0x75,
+	0x90,
+	0x0c,
+	0x90,
+	0x30,
+	0x20,
+	0xe0,
+	0x25,
+	0xe0,
+	0xff,
+	0x90,
+	0x30,
+	0x21,
+	0xe0,
+	0xfe,
+	0xbe,
+	0x10,
+	0x00,
+	0xb3,
+	0xe4,
+	0x33,
+	0x4f,
+	0xf5,
+	0x90,
+	0x90,
+	0x30,
+	0x21,
+	0xe0,
+	0x54,
+	0x0f,
+	0xc4,
+	0x54,
+	0xf0,
+	0xff,
+	0x90,
+	0x30,
+	0x22,
+	0xe0,
+	0x54,
+	0x0f,
+	0xfe,
+	0x4f,
+	0xf5,
+	0x90,
+	0x90,
+	0x30,
+	0x22,
+	0xe0,
+	0xff,
+	0x54,
+	0x0c,
+	0x60,
+	0x03,
+	0x02,
+	0xd6,
+	0x01,
+	0x90,
+	0x30,
+	0x48,
+	0xe0,
+	0xf5,
+	0x90,
+	0x90,
+	0x30,
+	0x47,
+	0xe0,
+	0xf5,
+	0x90,
+	0x90,
+	0x30,
+	0x46,
+	0xe0,
+	0xf5,
+	0x90,
+	0x90,
+	0x30,
+	0x21,
+	0xe0,
+	0x75,
+	0xf0,
+	0x05,
+	0xa4,
+	0x90,
+	0x30,
+	0x0b,
+	0x24,
+	0x16,
+	0xf0,
+	0x90,
+	0x30,
+	0x0c,
+	0x74,
+	0x80,
+	0xf0,
+	0x7e,
+	0x00,
+	0x7f,
+	0x00,
+	0xc3,
+	0xee,
+	0x94,
+	0x10,
+	0xef,
+	0x64,
+	0x80,
+	0x94,
+	0x80,
+	0x50,
+	0x27,
+	0x74,
+	0xfe,
+	0x25,
+	0x90,
+	0x50,
+	0xfa,
+	0x90,
+	0x30,
+	0x00,
+	0xe0,
+	0xfd,
+	0xbd,
+	0x06,
+	0x04,
+	0x7d,
+	0x00,
+	0x80,
+	0x0c,
+	0xee,
+	0x24,
+	0x40,
+	0xf5,
+	0x82,
+	0xef,
+	0x34,
+	0x69,
+	0xf5,
+	0x83,
+	0xe0,
+	0xfd,
+	0x8d,
+	0x90,
+	0x0e,
+	0xbe,
+	0x00,
+	0xd1,
+	0x0f,
+	0x80,
+	0xce,
+	0x7e,
+	0x00,
+	0x7f,
+	0x00,
+	0x90,
+	0x30,
+	0x21,
+	0xe0,
+	0x75,
+	0xf0,
+	0x05,
+	0xa4,
+	0xfd,
+	0xac,
+	0xf0,
+	0xc3,
+	0xee,
+	0x9d,
+	0xef,
+	0x64,
+	0x80,
+	0x8c,
+	0xf0,
+	0x63,
+	0xf0,
+	0x80,
+	0x95,
+	0xf0,
+	0x50,
+	0x26,
+	0x74,
+	0xfe,
+	0x25,
+	0x90,
+	0x50,
+	0xfa,
+	0xee,
+	0x24,
+	0x40,
+	0xf5,
+	0x82,
+	0xef,
+	0x34,
+	0x65,
+	0xf5,
+	0x83,
+	0xe0,
+	0xf5,
+	0x90,
+	0x0e,
+	0xbe,
+	0x00,
+	0xcf,
+	0x0f,
+	0x80,
+	0xcc,
+	0x90,
+	0x30,
+	0x0b,
+	0x74,
+	0x03,
+	0xf0,
+	0x90,
+	0x30,
+	0x0c,
+	0x74,
+	0x80,
+	0xf0,
+	0x90,
+	0x30,
+	0x0c,
+	0xe0,
+	0xff,
+	0x30,
+	0xe6,
+	0xf8,
+	0x90,
+	0x30,
+	0x0c,
+	0xe4,
+	0xf0,
+	0x22,
+	0x74,
+	0xf0,
+	0x25,
+	0xb0,
+	0x50,
+	0xfa,
+	0x7e,
+	0x00,
+	0x7f,
+	0x00,
+	0xc3,
+	0xee,
+	0x94,
+	0x10,
+	0xef,
+	0x64,
+	0x80,
+	0x94,
+	0x80,
+	0x50,
+	0x28,
+	0xee,
+	0x24,
+	0xa0,
+	0xf5,
+	0x82,
+	0xef,
+	0x34,
+	0x64,
+	0xf5,
+	0x83,
+	0xe5,
+	0xa0,
+	0xf0,
+	0x90,
+	0x30,
+	0x00,
+	0xe0,
+	0xfd,
+	0xbd,
+	0x08,
+	0x0c,
+	0xee,
+	0x24,
+	0xa0,
+	0xf5,
+	0x82,
+	0xef,
+	0x34,
+	0x64,
+	0xf5,
+	0x83,
+	0xe4,
+	0xf0,
+	0x0e,
+	0xbe,
+	0x00,
+	0xd0,
+	0x0f,
+	0x80,
+	0xcd,
+	0x22,
+	0x7e,
+	0x00,
+	0x7f,
+	0x00,
+	0xc3,
+	0xee,
+	0x94,
+	0x10,
+	0xef,
+	0x64,
+	0x80,
+	0x94,
+	0x80,
+	0x50,
+	0x2d,
+	0xee,
+	0x24,
+	0xa0,
+	0xf5,
+	0x82,
+	0xef,
+	0x34,
+	0x64,
+	0xf5,
+	0x83,
+	0xe0,
+	0xfd,
+	0x8e,
+	0x04,
+	0x74,
+	0x10,
+	0x2c,
+	0x24,
+	0x40,
+	0xf5,
+	0x82,
+	0xe4,
+	0x34,
+	0x6d,
+	0xf5,
+	0x83,
+	0xe0,
+	0xfc,
+	0xed,
+	0xb5,
+	0x04,
+	0x02,
+	0x80,
+	0x04,
+	0x90,
+	0x00,
+	0x01,
+	0x22,
+	0x0e,
+	0xbe,
+	0x00,
+	0xcb,
+	0x0f,
+	0x80,
+	0xc8,
+	0x90,
+	0x00,
+	0x00,
+	0x22,
+	0x74,
+	0xfb,
+	0x25,
+	0xb0,
+	0x50,
+	0xfa,
+	0x90,
+	0x30,
+	0x4b,
+	0xe0,
+	0x90,
+	0x69,
+	0xba,
+	0xf0,
+	0x90,
+	0x30,
+	0x4a,
+	0xe0,
+	0x90,
+	0x69,
+	0xb9,
+	0xf0,
+	0x90,
+	0x30,
+	0x49,
+	0xe0,
+	0x90,
+	0x69,
+	0xb8,
+	0xf0,
+	0x90,
+	0x30,
+	0x4b,
+	0xe5,
+	0xa0,
+	0xf0,
+	0x90,
+	0x30,
+	0x4a,
+	0xe5,
+	0xa0,
+	0xf0,
+	0x90,
+	0x30,
+	0x49,
+	0xe5,
+	0xa0,
+	0xf0,
+	0xe5,
+	0xa0,
+	0x90,
+	0x30,
+	0x2c,
+	0xe5,
+	0xa0,
+	0xf0,
+	0x90,
+	0x30,
+	0x28,
+	0x74,
+	0x01,
+	0xf0,
+	0x7e,
+	0x00,
+	0x7f,
+	0x00,
+	0x90,
+	0x30,
+	0x2c,
+	0xe0,
+	0xfd,
+	0x7c,
+	0x00,
+	0xc3,
+	0xee,
+	0x9d,
+	0xef,
+	0x64,
+	0x80,
+	0x8c,
+	0xf0,
+	0x63,
+	0xf0,
+	0x80,
+	0x95,
+	0xf0,
+	0x50,
+	0x49,
+	0x74,
+	0xfe,
+	0x25,
+	0xb0,
+	0x50,
+	0xfa,
+	0x7c,
+	0x00,
+	0x7d,
+	0x00,
+	0xc3,
+	0xec,
+	0x94,
+	0x02,
+	0xed,
+	0x64,
+	0x80,
+	0x94,
+	0x80,
+	0x50,
+	0x2d,
+	0x8e,
+	0x03,
+	0xeb,
+	0x2b,
+	0xfb,
+	0x8c,
+	0x02,
+	0xea,
+	0x2b,
+	0xfb,
+	0x24,
+	0x40,
+	0xf5,
+	0x82,
+	0xe4,
+	0x34,
+	0x65,
+	0xf5,
+	0x83,
+	0xe5,
+	0xa0,
+	0xf0,
+	0xeb,
+	0x24,
+	0x40,
+	0xf5,
+	0x82,
+	0xe4,
+	0x34,
+	0x65,
+	0xf5,
+	0x83,
+	0xe0,
+	0xfb,
+	0x90,
+	0x30,
+	0x29,
+	0xf0,
+	0x0c,
+	0xbc,
+	0x00,
+	0xcb,
+	0x0d,
+	0x80,
+	0xc8,
+	0x0e,
+	0xbe,
+	0x00,
+	0xa4,
+	0x0f,
+	0x80,
+	0xa1,
+	0x22,
+	0x90,
+	0x30,
+	0x0b,
+	0x74,
+	0x21,
+	0xf0,
+	0x90,
+	0x30,
+	0x0c,
+	0x74,
+	0x80,
+	0xf0,
+	0x75,
+	0x90,
+	0x11,
+	0x7e,
+	0x00,
+	0x7f,
+	0x00,
+	0xc3,
+	0xee,
+	0x94,
+	0x20,
+	0xef,
+	0x64,
+	0x80,
+	0x94,
+	0x80,
+	0x50,
+	0x27,
+	0x74,
+	0xfe,
+	0x25,
+	0x90,
+	0x50,
+	0xfa,
+	0x90,
+	0x30,
+	0x00,
+	0xe0,
+	0xfd,
+	0xbd,
+	0x07,
+	0x04,
+	0x7d,
+	0x00,
+	0x80,
+	0x0c,
+	0xee,
+	0x24,
+	0x40,
+	0xf5,
+	0x82,
+	0xef,
+	0x34,
+	0x69,
+	0xf5,
+	0x83,
+	0xe0,
+	0xfd,
+	0x8d,
+	0x90,
+	0x0e,
+	0xbe,
+	0x00,
+	0xd1,
+	0x0f,
+	0x80,
+	0xce,
+	0x90,
+	0x30,
+	0x0c,
+	0xe0,
+	0xff,
+	0x30,
+	0xe6,
+	0xf8,
+	0x90,
+	0x30,
+	0x0c,
+	0xe4,
+	0xf0,
+	0x22,
+	0x90,
+	0x30,
+	0x07,
+	0xe0,
+	0x44,
+	0x04,
+	0xf0,
+	0x90,
+	0x30,
+	0x26,
+	0x74,
+	0x01,
+	0xf0,
+	0x7f,
+	0x00,
+	0x90,
+	0x30,
+	0x21,
+	0xe0,
+	0x75,
+	0xf0,
+	0x05,
+	0xa4,
+	0xfe,
+	0xad,
+	0xf0,
+	0x8f,
+	0x03,
+	0x7c,
+	0x00,
+	0xc3,
+	0xeb,
+	0x9e,
+	0xec,
+	0x64,
+	0x80,
+	0x8d,
+	0xf0,
+	0x63,
+	0xf0,
+	0x80,
+	0x95,
+	0xf0,
+	0x50,
+	0x15,
+	0xef,
+	0x24,
+	0x40,
+	0xfd,
+	0xe4,
+	0x34,
+	0x65,
+	0xfe,
+	0x90,
+	0x30,
+	0x27,
+	0xe0,
+	0xfc,
+	0x8d,
+	0x82,
+	0x8e,
+	0x83,
+	0xf0,
+	0x0f,
+	0x80,
+	0xcd,
+	0x12,
+	0xa5,
+	0x92,
+	0x12,
+	0xd5,
+	0x35,
+	0x90,
+	0x30,
+	0x07,
+	0xe0,
+	0x54,
+	0xfb,
+	0xf0,
+	0x90,
+	0x69,
+	0xe5,
+	0xe0,
+	0xff,
+	0xbf,
+	0x01,
+	0x00,
+	0x40,
+	0x09,
+	0x90,
+	0x30,
+	0x3b,
+	0xe0,
+	0xf5,
+	0x82,
+	0x02,
+	0xaf,
+	0x74,
+	0xd2,
+	0xaa,
+	0x22,
+	0x12,
+	0xaf,
+	0x3b,
+	0x12,
+	0xd0,
+	0xde,
+	0x90,
+	0x69,
+	0xea,
+	0xe0,
+	0xff,
+	0x60,
+	0x05,
+	0x12,
+	0xc9,
+	0x4c,
+	0x80,
+	0x03,
+	0x12,
+	0xcf,
+	0xad,
+	0x90,
+	0x69,
+	0xe7,
+	0xe0,
+	0xf5,
+	0x82,
+	0x12,
+	0x9f,
+	0x29,
+	0x12,
+	0xa3,
+	0xa1,
+	0x90,
+	0x30,
+	0x33,
+	0xe0,
+	0xf5,
+	0x82,
+	0x12,
+	0xaf,
+	0x74,
+	0x12,
+	0xd3,
+	0xc5,
+	0x90,
+	0x30,
+	0x0f,
+	0x74,
+	0x04,
+	0xf0,
+	0x90,
+	0x69,
+	0xea,
+	0xe0,
+	0xff,
+	0x70,
+	0x12,
+	0x12,
+	0xaf,
+	0x3b,
+	0x12,
+	0xc7,
+	0x14,
+	0x90,
+	0x30,
+	0x33,
+	0xe0,
+	0xf5,
+	0x82,
+	0x12,
+	0xaf,
+	0x74,
+	0x02,
+	0xd3,
+	0x3a,
+	0x22,
+	0x90,
+	0x30,
+	0x05,
+	0xe0,
+	0xff,
+	0x30,
+	0xe1,
+	0xf8,
+	0x12,
+	0xf1,
+	0x2d,
+	0xe5,
+	0x82,
+	0x85,
+	0x83,
+	0xf0,
+	0x45,
+	0xf0,
+	0x60,
+	0x10,
+	0x90,
+	0x30,
+	0x06,
+	0x74,
+	0x01,
+	0xf0,
+	0x90,
+	0x30,
+	0x07,
+	0xe0,
+	0xff,
+	0x44,
+	0x10,
+	0xf0,
+	0x80,
+	0x08,
+	0x90,
+	0x30,
+	0x07,
+	0xe0,
+	0xff,
+	0x44,
+	0x30,
+	0xf0,
+	0x90,
+	0x30,
+	0x05,
+	0xe0,
+	0xff,
+	0x20,
+	0xe1,
+	0xf8,
+	0x75,
+	0xf7,
+	0x01,
+	0x75,
+	0xf7,
+	0x01,
+	0x80,
+	0xfe,
+	0x90,
+	0x30,
+	0x01,
+	0x74,
+	0xab,
+	0xf0,
+	0x90,
+	0x69,
+	0xf4,
+	0xe4,
+	0xf0,
+	0x90,
+	0x30,
+	0x04,
+	0xe0,
+	0xff,
+	0x53,
+	0x07,
+	0x10,
+	0xe4,
+	0xbf,
+	0x00,
+	0x01,
+	0x04,
+	0xff,
+	0x90,
+	0x6c,
+	0x04,
+	0xb4,
+	0x01,
+	0x00,
+	0xe4,
+	0x33,
+	0xf0,
+	0x90,
+	0x6c,
+	0x04,
+	0xe0,
+	0xff,
+	0x60,
+	0x08,
+	0x90,
+	0x30,
+	0x00,
+	0x74,
+	0x0f,
+	0xf0,
+	0x80,
+	0x06,
+	0x90,
+	0x30,
+	0x00,
+	0x74,
+	0x5f,
+	0xf0,
+	0x90,
+	0x69,
+	0xbc,
+	0xe4,
+	0xf0,
+	0x90,
+	0x69,
+	0xbd,
+	0xf0,
+	0x90,
+	0x69,
+	0xbe,
+	0xf0,
+	0x90,
+	0x69,
+	0xbf,
+	0xf0,
+	0x90,
+	0x6c,
+	0x04,
+	0xe0,
+	0xff,
+	0x70,
+	0x3b,
+	0xfe,
+	0xff,
+	0xc3,
+	0xee,
+	0x94,
+	0x05,
+	0xef,
+	0x64,
+	0x80,
+	0x94,
+	0x80,
+	0x50,
+	0x25,
+	0x8e,
+	0x05,
+	0x74,
+	0x04,
+	0xc3,
+	0x9d,
+	0x24,
+	0x40,
+	0xfc,
+	0xe4,
+	0x34,
+	0x30,
+	0xfd,
+	0xee,
+	0x24,
+	0x40,
+	0xf5,
+	0x82,
+	0xef,
+	0x34,
+	0x05,
+	0xf5,
+	0x83,
+	0xe0,
+	0xfb,
+	0x8c,
+	0x82,
+	0x8d,
+	0x83,
+	0xf0,
+	0x0e,
+	0xbe,
+	0x00,
+	0xd3,
+	0x0f,
+	0x80,
+	0xd0,
+	0xe5,
+	0xf7,
+	0x70,
+	0x05,
+	0x90,
+	0x6c,
+	0x34,
+	0xe4,
+	0xf0,
+	0x75,
+	0xff,
+	0x01,
+	0x90,
+	0x69,
+	0xe2,
+	0xe4,
+	0xf0,
+	0x90,
+	0x69,
+	0xe3,
+	0xf0,
+	0x90,
+	0x69,
+	0xe1,
+	0xf0,
+	0x90,
+	0x69,
+	0xe9,
+	0xf0,
+	0x90,
+	0x6c,
+	0x04,
+	0xe0,
+	0xff,
+	0x60,
+	0x2a,
+	0x90,
+	0x30,
+	0x0c,
+	0xe4,
+	0xf0,
+	0x90,
+	0x30,
+	0x04,
+	0xe0,
+	0xff,
+	0x90,
+	0x69,
+	0xe7,
+	0x74,
+	0x07,
+	0x5f,
+	0xf0,
+	0x90,
+	0x30,
+	0x04,
+	0xe0,
+	0xff,
+	0x53,
+	0x07,
+	0x20,
+	0xe4,
+	0xbf,
+	0x00,
+	0x01,
+	0x04,
+	0xff,
+	0x90,
+	0x69,
+	0xe8,
+	0xb4,
+	0x01,
+	0x00,
+	0xe4,
+	0x33,
+	0xf0,
+	0x80,
+	0x3a,
+	0x90,
+	0x30,
+	0x04,
+	0xe0,
+	0xff,
+	0x90,
+	0x69,
+	0xe5,
+	0x74,
+	0x07,
+	0x5f,
+	0xf0,
+	0x90,
+	0x30,
+	0x04,
+	0xe0,
+	0xff,
+	0x53,
+	0x07,
+	0x20,
+	0xe4,
+	0xbf,
+	0x00,
+	0x01,
+	0x04,
+	0xff,
+	0x90,
+	0x69,
+	0xe6,
+	0xb4,
+	0x01,
+	0x00,
+	0xe4,
+	0x33,
+	0xf0,
+	0x90,
+	0x30,
+	0x04,
+	0xe0,
+	0xff,
+	0x53,
+	0x07,
+	0x80,
+	0xe4,
+	0xbf,
+	0x00,
+	0x01,
+	0x04,
+	0xff,
+	0x90,
+	0x30,
+	0x45,
+	0xb4,
+	0x01,
+	0x00,
+	0xe4,
+	0x33,
+	0xf0,
+	0x90,
+	0x30,
+	0x04,
+	0xe0,
+	0xff,
+	0x53,
+	0x07,
+	0x40,
+	0xe4,
+	0xbf,
+	0x00,
+	0x01,
+	0x04,
+	0xff,
+	0x90,
+	0x6c,
+	0x00,
+	0xb4,
+	0x01,
+	0x00,
+	0xe4,
+	0x33,
+	0xf0,
+	0x90,
+	0x30,
+	0x08,
+	0xe4,
+	0xf0,
+	0x90,
+	0x6c,
+	0x04,
+	0xe0,
+	0xff,
+	0x60,
+	0x29,
+	0x90,
+	0x69,
+	0xe7,
+	0xe0,
+	0xff,
+	0xbf,
+	0x0a,
+	0x00,
+	0x50,
+	0x1f,
+	0x90,
+	0x69,
+	0xe5,
+	0xe0,
+	0xff,
+	0x24,
+	0xfe,
+	0x40,
+	0x16,
+	0x90,
+	0x69,
+	0xe7,
+	0xe0,
+	0xff,
+	0xbf,
+	0x02,
+	0x00,
+	0x40,
+	0x0c,
+	0x90,
+	0x69,
+	0xe8,
+	0xe0,
+	0xff,
+	0xbf,
+	0x01,
+	0x04,
+	0x90,
+	0x69,
+	0xe8,
+	0xe0,
+	0xc2,
+	0x8c,
+	0xc2,
+	0x8e,
+	0xd2,
+	0xa8,
+	0xd2,
+	0xaa,
+	0xc2,
+	0xa9,
+	0xc2,
+	0xab,
+	0xd2,
+	0xaf,
+	0x75,
+	0x8a,
+	0x00,
+	0x90,
+	0x30,
+	0x31,
+	0xe0,
+	0xff,
+	0x74,
+	0xff,
+	0xc3,
+	0x9f,
+	0xf5,
+	0x8c,
+	0x75,
+	0x8b,
+	0x00,
+	0x90,
+	0x30,
+	0x31,
+	0xe0,
+	0xff,
+	0x74,
+	0xff,
+	0xc3,
+	0x9f,
+	0xf5,
+	0x8d,
+	0x75,
+	0x89,
+	0x55,
+	0x90,
+	0x6c,
+	0x04,
+	0xe0,
+	0xff,
+	0x60,
+	0x08,
+	0x90,
+	0x30,
+	0x07,
+	0xe0,
+	0xff,
+	0x54,
+	0x70,
+	0xf0,
+	0x90,
+	0x30,
+	0x0a,
+	0xe0,
+	0xff,
+	0xbf,
+	0xdb,
+	0x12,
+	0x90,
+	0x6c,
+	0x04,
+	0xe0,
+	0xff,
+	0x60,
+	0x04,
+	0x7f,
+	0x2c,
+	0x80,
+	0x02,
+	0x7f,
+	0xa2,
+	0x90,
+	0x30,
+	0x02,
+	0xef,
+	0xf0,
+	0x90,
+	0x30,
+	0x06,
+	0xe0,
+	0xff,
+	0x53,
+	0x07,
+	0x80,
+	0xbf,
+	0x80,
+	0x16,
+	0x90,
+	0x30,
+	0x02,
+	0xe0,
+	0xff,
+	0x53,
+	0x07,
+	0x10,
+	0xe4,
+	0xbf,
+	0x10,
+	0x01,
+	0x04,
+	0xff,
+	0xb4,
+	0x01,
+	0x00,
+	0xe4,
+	0x33,
+	0xff,
+	0x70,
+	0x04,
+	0x7f,
+	0x00,
+	0x80,
+	0x02,
+	0x7f,
+	0x01,
+	0x90,
+	0x69,
+	0x8f,
+	0xef,
+	0xf0,
+	0x90,
+	0x44,
+	0x02,
+	0x74,
+	0x81,
+	0xf0,
+	0x90,
+	0x6c,
+	0x04,
+	0xe0,
+	0xff,
+	0x70,
+	0x03,
+	0x02,
+	0xe6,
+	0x25,
+	0x90,
+	0x30,
+	0x01,
+	0xe0,
+	0xff,
+	0x20,
+	0xe3,
+	0x0b,
+	0x90,
+	0x30,
+	0x06,
+	0xe0,
+	0xff,
+	0x53,
+	0x07,
+	0x80,
+	0xbf,
+	0x80,
+	0x08,
+	0x90,
+	0x30,
+	0x07,
+	0xe0,
+	0xff,
+	0x54,
+	0x70,
+	0xf0,
+	0x90,
+	0x30,
+	0x03,
+	0xe0,
+	0xff,
+	0xbf,
+	0xff,
+	0x06,
+	0x75,
+	0xf7,
+	0x01,
+	0x75,
+	0xf7,
+	0x01,
+	0x90,
+	0x30,
+	0x03,
+	0xe0,
+	0xff,
+	0xbf,
+	0xdb,
+	0x3f,
+	0x90,
+	0x69,
+	0xe1,
+	0xe4,
+	0xf0,
+	0x12,
+	0xaf,
+	0x3b,
+	0x90,
+	0x30,
+	0x32,
+	0xe0,
+	0xf5,
+	0x82,
+	0x12,
+	0xaf,
+	0x44,
+	0x7f,
+	0x00,
+	0x90,
+	0x30,
+	0x03,
+	0xe0,
+	0xfe,
+	0xbe,
+	0xdb,
+	0x24,
+	0x90,
+	0x69,
+	0xe1,
+	0xe0,
+	0xfe,
+	0x60,
+	0xf1,
+	0x90,
+	0x69,
+	0xe1,
+	0xe4,
+	0xf0,
+	0xc0,
+	0x07,
+	0x12,
+	0xaf,
+	0x3b,
+	0x90,
+	0x30,
+	0x32,
+	0xe0,
+	0xf5,
+	0x82,
+	0x12,
+	0xaf,
+	0x44,
+	0xd0,
+	0x07,
+	0x90,
+	0x30,
+	0x03,
+	0xef,
+	0xf0,
+	0x0f,
+	0x80,
+	0xd4,
+	0x90,
+	0x30,
+	0x00,
+	0xe0,
+	0xff,
+	0xbf,
+	0x20,
+	0x03,
+	0x75,
+	0xff,
+	0x01,
+	0x90,
+	0x30,
+	0x06,
+	0xe0,
+	0xff,
+	0x30,
+	0xe6,
+	0x31,
+	0x90,
+	0x69,
+	0xf4,
+	0x74,
+	0x01,
+	0xf0,
+	0x90,
+	0x30,
+	0x06,
+	0xe0,
+	0x54,
+	0x41,
+	0xf0,
+	0x90,
+	0x30,
+	0x07,
+	0x74,
+	0x40,
+	0xf0,
+	0x90,
+	0x30,
+	0x02,
+	0xe0,
+	0xff,
+	0x53,
+	0x07,
+	0x04,
+	0xbf,
+	0x04,
+	0x02,
+	0x80,
+	0x09,
+	0x90,
+	0x30,
+	0x3c,
+	0xe0,
+	0xf5,
+	0x82,
+	0x12,
+	0xaf,
+	0x74,
+	0x90,
+	0x30,
+	0x08,
+	0x74,
+	0x41,
+	0xf0,
+	0x80,
+	0xfe,
+	0x90,
+	0x30,
+	0x05,
+	0xe0,
+	0xff,
+	0x30,
+	0xe0,
+	0x06,
+	0x12,
+	0xd8,
+	0x40,
+	0x02,
+	0xda,
+	0x63,
+	0x90,
+	0x69,
+	0xef,
+	0xe0,
+	0xff,
+	0x60,
+	0x24,
+	0x90,
+	0x69,
+	0xf4,
+	0x74,
+	0x01,
+	0xf0,
+	0x90,
+	0x30,
+	0x02,
+	0xe0,
+	0xff,
+	0x53,
+	0x07,
+	0x04,
+	0xbf,
+	0x04,
+	0x02,
+	0x80,
+	0x09,
+	0x90,
+	0x30,
+	0x3c,
+	0xe0,
+	0xf5,
+	0x82,
+	0x12,
+	0xaf,
+	0x74,
+	0x90,
+	0x30,
+	0x08,
+	0x74,
+	0x35,
+	0xf0,
+	0x80,
+	0xfe,
+	0x90,
+	0x69,
+	0xf1,
+	0xe0,
+	0xff,
+	0x60,
+	0x24,
+	0x90,
+	0x69,
+	0xf4,
+	0x74,
+	0x01,
+	0xf0,
+	0x90,
+	0x30,
+	0x02,
+	0xe0,
+	0xff,
+	0x53,
+	0x07,
+	0x04,
+	0xbf,
+	0x04,
+	0x02,
+	0x80,
+	0x09,
+	0x90,
+	0x30,
+	0x3c,
+	0xe0,
+	0xf5,
+	0x82,
+	0x12,
+	0xaf,
+	0x74,
+	0x90,
+	0x30,
+	0x08,
+	0x74,
+	0x36,
+	0xf0,
+	0x80,
+	0xfe,
+	0x90,
+	0x69,
+	0xf2,
+	0xe0,
+	0xff,
+	0x60,
+	0x24,
+	0x90,
+	0x69,
+	0xf4,
+	0x74,
+	0x01,
+	0xf0,
+	0x90,
+	0x30,
+	0x02,
+	0xe0,
+	0xff,
+	0x53,
+	0x07,
+	0x04,
+	0xbf,
+	0x04,
+	0x02,
+	0x80,
+	0x09,
+	0x90,
+	0x30,
+	0x3c,
+	0xe0,
+	0xf5,
+	0x82,
+	0x12,
+	0xaf,
+	0x74,
+	0x90,
+	0x30,
+	0x08,
+	0x74,
+	0x37,
+	0xf0,
+	0x80,
+	0xfe,
+	0x90,
+	0x6c,
+	0x08,
+	0xe0,
+	0xff,
+	0x60,
+	0x27,
+	0x90,
+	0x69,
+	0xf4,
+	0x74,
+	0x01,
+	0xf0,
+	0x90,
+	0x30,
+	0x02,
+	0xe0,
+	0xff,
+	0x53,
+	0x07,
+	0x04,
+	0xbf,
+	0x04,
+	0x02,
+	0x80,
+	0x09,
+	0x90,
+	0x30,
+	0x3c,
+	0xe0,
+	0xf5,
+	0x82,
+	0x12,
+	0xaf,
+	0x74,
+	0x90,
+	0x6c,
+	0x08,
+	0xe0,
+	0xff,
+	0x90,
+	0x30,
+	0x08,
+	0xf0,
+	0x80,
+	0xfe,
+	0x90,
+	0x69,
+	0x8f,
+	0xe0,
+	0xff,
+	0x60,
+	0x11,
+	0x75,
+	0xff,
+	0x01,
+	0x90,
+	0x30,
+	0x07,
+	0xe4,
+	0xf0,
+	0x90,
+	0x30,
+	0x08,
+	0x74,
+	0x40,
+	0xf0,
+	0x02,
+	0xda,
+	0x63,
+	0x90,
+	0x30,
+	0x08,
+	0xe0,
+	0xff,
+	0x60,
+	0x4b,
+	0xbf,
+	0x03,
+	0x03,
+	0x02,
+	0xdc,
+	0xaf,
+	0xbf,
+	0x04,
+	0x03,
+	0x02,
+	0xdd,
+	0x2a,
+	0xbf,
+	0x0b,
+	0x03,
+	0x02,
+	0xdd,
+	0xe3,
+	0xbf,
+	0x0e,
+	0x03,
+	0x02,
+	0xde,
+	0x14,
+	0xbf,
+	0x10,
+	0x03,
+	0x02,
+	0xdf,
+	0x0b,
+	0xbf,
+	0x12,
+	0x03,
+	0x02,
+	0xdf,
+	0x60,
+	0xbf,
+	0x18,
+	0x03,
+	0x02,
+	0xe0,
+	0x01,
+	0xbf,
+	0x1e,
+	0x03,
+	0x02,
+	0xe1,
+	0x7c,
+	0xbf,
+	0x23,
+	0x03,
+	0x02,
+	0xe2,
+	0x46,
+	0xbf,
+	0x25,
+	0x03,
+	0x02,
+	0xe2,
+	0x75,
+	0xbf,
+	0x29,
+	0x03,
+	0x02,
+	0xdf,
+	0x8a,
+	0xbf,
+	0x2b,
+	0x03,
+	0x02,
+	0xe3,
+	0xa9,
+	0x02,
+	0xe6,
+	0x1d,
+	0xe5,
+	0xf7,
+	0x60,
+	0x0b,
+	0x90,
+	0x30,
+	0x01,
+	0xe0,
+	0xff,
+	0x53,
+	0x07,
+	0x01,
+	0xbf,
+	0x01,
+	0x22,
+	0x7e,
+	0x00,
+	0x7f,
+	0x00,
+	0xc3,
+	0xee,
+	0x94,
+	0x05,
+	0xef,
+	0x64,
+	0x80,
+	0x94,
+	0x80,
+	0x50,
+	0x13,
+	0xee,
+	0x24,
+	0x88,
+	0xf5,
+	0x82,
+	0xef,
+	0x34,
+	0x69,
+	0xf5,
+	0x83,
+	0xe4,
+	0xf0,
+	0x0e,
+	0xbe,
+	0x00,
+	0xe5,
+	0x0f,
+	0x80,
+	0xe2,
+	0x74,
+	0x01,
+	0xb5,
+	0xf7,
+	0x02,
+	0x80,
+	0x03,
+	0x02,
+	0xda,
+	0x63,
+	0x90,
+	0x69,
+	0xea,
+	0xe4,
+	0xf0,
+	0x90,
+	0x30,
+	0x45,
+	0xf0,
+	0x12,
+	0xb2,
+	0xea,
+	0x75,
+	0xff,
+	0x01,
+	0x90,
+	0x30,
+	0x33,
+	0xe0,
+	0xf5,
+	0x82,
+	0x12,
+	0xaf,
+	0x74,
+	0x12,
+	0xb3,
+	0x36,
+	0x12,
+	0xaf,
+	0x3b,
+	0x90,
+	0x30,
+	0x2e,
+	0x74,
+	0x01,
+	0xf0,
+	0x90,
+	0x30,
+	0x38,
+	0xe0,
+	0xf5,
+	0x82,
+	0x12,
+	0xaf,
+	0x44,
+	0x90,
+	0x30,
+	0x08,
+	0x74,
+	0x03,
+	0xf0,
+	0x02,
+	0xda,
+	0x63,
+	0x90,
+	0x69,
+	0xe3,
+	0xe0,
+	0xff,
+	0x60,
+	0x4b,
+	0x90,
+	0x69,
+	0xe3,
+	0xe4,
+	0xf0,
+	0x12,
+	0xaf,
+	0x3b,
+	0x90,
+	0x69,
+	0xe4,
+	0xe0,
+	0xff,
+	0xbf,
+	0x03,
+	0x20,
+	0x90,
+	0x30,
+	0x33,
+	0xe0,
+	0xf5,
+	0x82,
+	0x12,
+	0xaf,
+	0x74,
+	0x12,
+	0xb3,
+	0xa5,
+	0x12,
+	0xaf,
+	0x3b,
+	0x90,
+	0x30,
+	0x2e,
+	0x74,
+	0x04,
+	0xf0,
+	0xd2,
+	0xaa,
+	0x90,
+	0x30,
+	0x08,
+	0x74,
+	0x04,
+	0xf0,
+	0x02,
+	0xda,
+	0x63,
+	0x90,
+	0x30,
+	0x0a,
+	0xe0,
+	0xff,
+	0xbf,
+	0xdb,
+	0x06,
+	0x90,
+	0x30,
+	0x02,
+	0x74,
+	0x2f,
+	0xf0,
+	0x90,
+	0x69,
+	0xf2,
+	0xe0,
+	0x24,
+	0x01,
+	0xf0,
+	0x12,
+	0xaf,
+	0x90,
+	0x02,
+	0xda,
+	0x63,
+	0x90,
+	0x69,
+	0xe1,
+	0xe0,
+	0xff,
+	0x70,
+	0x03,
+	0x02,
+	0xda,
+	0x63,
+	0x90,
+	0x69,
+	0xe1,
+	0xe4,
+	0xf0,
+	0x90,
+	0x6c,
+	0x08,
+	0x74,
+	0x30,
+	0xf0,
+	0x90,
+	0x30,
+	0x0a,
+	0xe0,
+	0xff,
+	0xbf,
+	0xdb,
+	0x06,
+	0x90,
+	0x30,
+	0x02,
+	0x74,
+	0x30,
+	0xf0,
+	0x12,
+	0xaf,
+	0x90,
+	0x02,
+	0xda,
+	0x63,
+	0x12,
+	0xb7,
+	0x03,
+	0xae,
+	0x82,
+	0x7f,
+	0x00,
+	0xee,
+	0x4f,
+	0x60,
+	0x17,
+	0x90,
+	0x6c,
+	0x08,
+	0x74,
+	0x31,
+	0xf0,
+	0x90,
+	0x30,
+	0x0a,
+	0xe0,
+	0xfd,
+	0xbd,
+	0xdb,
+	0x06,
+	0x90,
+	0x30,
+	0x02,
+	0x74,
+	0x32,
+	0xf0,
+	0x12,
+	0xaf,
+	0x90,
+	0x90,
+	0x30,
+	0x0a,
+	0xe0,
+	0xfd,
+	0xbd,
+	0xdb,
+	0x06,
+	0x90,
+	0x30,
+	0x02,
+	0x74,
+	0x33,
+	0xf0,
+	0x12,
+	0xb7,
+	0x0c,
+	0xac,
+	0x82,
+	0xad,
+	0x83,
+	0x8c,
+	0x06,
+	0x8d,
+	0x07,
+	0xee,
+	0x4f,
+	0x60,
+	0x03,
+	0x12,
+	0xaf,
+	0x90,
+	0x12,
+	0xb7,
+	0x28,
+	0xac,
+	0x82,
+	0x90,
+	0x69,
+	0xea,
+	0xec,
+	0xf0,
+	0xe0,
+	0xfd,
+	0x60,
+	0x20,
+	0x90,
+	0x30,
+	0x33,
+	0xe0,
+	0xf5,
+	0x82,
+	0x12,
+	0xaf,
+	0x74,
+	0x12,
+	0xbd,
+	0xaa,
+	0x12,
+	0xaf,
+	0x3b,
+	0x90,
+	0x30,
+	0x0f,
+	0x74,
+	0x02,
+	0xf0,
+	0x90,
+	0x30,
+	0x34,
+	0xe0,
+	0xf5,
+	0x82,
+	0x12,
+	0xaf,
+	0x44,
+	0x80,
+	0x40,
+	0x12,
+	0xb7,
+	0x83,
+	0x90,
+	0x30,
+	0x0a,
+	0xe0,
+	0xfd,
+	0xbd,
+	0xdb,
+	0x06,
+	0x90,
+	0x30,
+	0x02,
+	0x74,
+	0x34,
+	0xf0,
+	0x12,
+	0xba,
+	0xb4,
+	0x90,
+	0x30,
+	0x0a,
+	0xe0,
+	0xfd,
+	0xbd,
+	0xdb,
+	0x06,
+	0x90,
+	0x30,
+	0x02,
+	0x74,
+	0x35,
+	0xf0,
+	0x90,
+	0x30,
+	0x33,
+	0xe0,
+	0xf5,
+	0x82,
+	0x12,
+	0xaf,
+	0x74,
+	0x12,
+	0xbc,
+	0x9a,
+	0x12,
+	0xaf,
+	0x3b,
+	0x90,
+	0x30,
+	0x0f,
+	0x74,
+	0x01,
+	0xf0,
+	0x90,
+	0x30,
+	0x35,
+	0xe0,
+	0xf5,
+	0x82,
+	0x12,
+	0xaf,
+	0x44,
+	0x90,
+	0x30,
+	0x08,
+	0x74,
+	0x0b,
+	0xf0,
+	0x02,
+	0xda,
+	0x63,
+	0x90,
+	0x69,
+	0xe5,
+	0xe0,
+	0xf5,
+	0x82,
+	0x12,
+	0x9f,
+	0x29,
+	0x90,
+	0x30,
+	0x0a,
+	0xe0,
+	0xfd,
+	0xbd,
+	0xdb,
+	0x06,
+	0x90,
+	0x30,
+	0x02,
+	0x74,
+	0x3a,
+	0xf0,
+	0x12,
+	0xa3,
+	0xa1,
+	0x90,
+	0x30,
+	0x0a,
+	0xe0,
+	0xfd,
+	0xbd,
+	0xdb,
+	0x06,
+	0x90,
+	0x30,
+	0x02,
+	0x74,
+	0x3b,
+	0xf0,
+	0x90,
+	0x30,
+	0x08,
+	0x74,
+	0x0e,
+	0xf0,
+	0x02,
+	0xda,
+	0x63,
+	0x90,
+	0x69,
+	0xe3,
+	0xe0,
+	0xfd,
+	0x70,
+	0x03,
+	0x02,
+	0xde,
+	0xe2,
+	0x90,
+	0x69,
+	0xe3,
+	0xe4,
+	0xf0,
+	0x90,
+	0x69,
+	0xe4,
+	0xe0,
+	0xfd,
+	0xbd,
+	0x07,
+	0x02,
+	0x80,
+	0x03,
+	0x02,
+	0xde,
+	0xc7,
+	0x90,
+	0x30,
+	0x33,
+	0xe0,
+	0xf5,
+	0x82,
+	0x12,
+	0xaf,
+	0x74,
+	0x12,
+	0xbe,
+	0x23,
+	0x90,
+	0x30,
+	0x0f,
+	0x74,
+	0x04,
+	0xf0,
+	0xd2,
+	0xaa,
+	0x12,
+	0xbe,
+	0x76,
+	0xac,
+	0x82,
+	0xad,
+	0x83,
+	0x8c,
+	0x06,
+	0x8d,
+	0x07,
+	0xee,
+	0x4f,
+	0x60,
+	0x41,
+	0x90,
+	0x30,
+	0x01,
+	0xe0,
+	0xfd,
+	0x20,
+	0xe2,
+	0x22,
+	0x7c,
+	0x00,
+	0x7d,
+	0x00,
+	0xc3,
+	0xec,
+	0x94,
+	0x05,
+	0xed,
+	0x64,
+	0x80,
+	0x94,
+	0x80,
+	0x50,
+	0x13,
+	0xec,
+	0x24,
+	0x88,
+	0xf5,
+	0x82,
+	0xed,
+	0x34,
+	0x69,
+	0xf5,
+	0x83,
+	0xe4,
+	0xf0,
+	0x0c,
+	0xbc,
+	0x00,
+	0xe5,
+	0x0d,
+	0x80,
+	0xe2,
+	0x90,
+	0x6c,
+	0x08,
+	0x74,
+	0x32,
+	0xf0,
+	0x90,
+	0x30,
+	0x0a,
+	0xe0,
+	0xfd,
+	0xbd,
+	0xdb,
+	0x06,
+	0x90,
+	0x30,
+	0x02,
+	0x74,
+	0x3d,
+	0xf0,
+	0x12,
+	0xaf,
+	0x90,
+	0x90,
+	0x30,
+	0x0a,
+	0xe0,
+	0xfd,
+	0xbd,
+	0xdb,
+	0x06,
+	0x90,
+	0x30,
+	0x02,
+	0x74,
+	0x3e,
+	0xf0,
+	0x12,
+	0xaf,
+	0x3b,
+	0x90,
+	0x69,
+	0xea,
+	0xe0,
+	0xfd,
+	0x60,
+	0x09,
+	0x90,
+	0x30,
+	0x08,
+	0x74,
+	0x12,
+	0xf0,
+	0x02,
+	0xda,
+	0x63,
+	0x90,
+	0x30,
+	0x39,
+	0xe0,
+	0xf5,
+	0x82,
+	0x12,
+	0xaf,
+	0x74,
+	0x90,
+	0x30,
+	0x08,
+	0x74,
+	0x10,
+	0xf0,
+	0x02,
+	0xda,
+	0x63,
+	0x90,
+	0x30,
+	0x0a,
+	0xe0,
+	0xfd,
+	0xbd,
+	0xdb,
+	0x06,
+	0x90,
+	0x30,
+	0x02,
+	0x74,
+	0x3f,
+	0xf0,
+	0x90,
+	0x69,
+	0xf2,
+	0xe0,
+	0x24,
+	0x01,
+	0xf0,
+	0x12,
+	0xaf,
+	0x90,
+	0x02,
+	0xda,
+	0x63,
+	0x90,
+	0x69,
+	0xe1,
+	0xe0,
+	0xfd,
+	0x70,
+	0x03,
+	0x02,
+	0xda,
+	0x63,
+	0x90,
+	0x69,
+	0xe1,
+	0xe4,
+	0xf0,
+	0x90,
+	0x6c,
+	0x08,
+	0x74,
+	0x39,
+	0xf0,
+	0x90,
+	0x30,
+	0x0a,
+	0xe0,
+	0xfd,
+	0xbd,
+	0xdb,
+	0x06,
+	0x90,
+	0x30,
+	0x02,
+	0x74,
+	0x40,
+	0xf0,
+	0x12,
+	0xaf,
+	0x90,
+	0x02,
+	0xda,
+	0x63,
+	0x90,
+	0x69,
+	0xe3,
+	0xe0,
+	0xfd,
+	0x70,
+	0x03,
+	0x02,
+	0xda,
+	0x63,
+	0x90,
+	0x69,
+	0xe3,
+	0xe4,
+	0xf0,
+	0x12,
+	0xaf,
+	0x3b,
+	0x90,
+	0x69,
+	0xe4,
+	0xe0,
+	0xfd,
+	0xbd,
+	0x08,
+	0x20,
+	0x90,
+	0x30,
+	0x33,
+	0xe0,
+	0xf5,
+	0x82,
+	0x12,
+	0xaf,
+	0x74,
+	0x12,
+	0xbe,
+	0xb2,
+	0x90,
+	0x30,
+	0x0f,
+	0x74,
+	0x08,
+	0xf0,
+	0xd2,
+	0xaa,
+	0x12,
+	0xbe,
+	0xe1,
+	0x90,
+	0x30,
+	0x08,
+	0x74,
+	0x12,
+	0xf0,
+	0x02,
+	0xda,
+	0x63,
+	0x90,
+	0x30,
+	0x0a,
+	0xe0,
+	0xfd,
+	0xbd,
+	0xdb,
+	0x06,
+	0x90,
+	0x30,
+	0x02,
+	0x74,
+	0x41,
+	0xf0,
+	0x90,
+	0x69,
+	0xf2,
+	0xe0,
+	0x24,
+	0x01,
+	0xf0,
+	0x12,
+	0xaf,
+	0x90,
+	0x02,
+	0xda,
+	0x63,
+	0x12,
+	0xbf,
+	0xc6,
+	0x12,
+	0xa4,
+	0x68,
+	0x90,
+	0x30,
+	0x33,
+	0xe0,
+	0xf5,
+	0x82,
+	0x12,
+	0xaf,
+	0x74,
+	0x12,
+	0xc0,
+	0x13,
+	0x12,
+	0xaf,
+	0x3b,
+	0x90,
+	0x30,
+	0x0f,
+	0x74,
+	0x10,
+	0xf0,
+	0x90,
+	0x30,
+	0x36,
+	0xe0,
+	0xf5,
+	0x82,
+	0x12,
+	0xaf,
+	0x44,
+	0x90,
+	0x30,
+	0x08,
+	0x74,
+	0x29,
+	0xf0,
+	0x90,
+	0x69,
+	0xe3,
+	0xe0,
+	0xfd,
+	0x60,
+	0x47,
+	0x90,
+	0x69,
+	0xe3,
+	0xe4,
+	0xf0,
+	0x90,
+	0x69,
+	0xe4,
+	0xe0,
+	0xfd,
+	0xbd,
+	0x0a,
+	0x1c,
+	0x90,
+	0x30,
+	0x33,
+	0xe0,
+	0xf5,
+	0x82,
+	0x12,
+	0xaf,
+	0x74,
+	0x12,
+	0xc0,
+	0x4a,
+	0x90,
+	0x30,
+	0x0f,
+	0x74,
+	0x20,
+	0xf0,
+	0xd2,
+	0xaa,
+	0x90,
+	0x30,
+	0x08,
+	0x74,
+	0x18,
+	0xf0,
+	0x80,
+	0x18,
+	0x90,
+	0x30,
+	0x0a,
+	0xe0,
+	0xfd,
+	0xbd,
+	0xdb,
+	0x06,
+	0x90,
+	0x30,
+	0x02,
+	0x74,
+	0x43,
+	0xf0,
+	0x90,
+	0x69,
+	0xf2,
+	0xe0,
+	0x24,
+	0x01,
+	0xf0,
+	0x12,
+	0xaf,
+	0x90,
+	0x12,
+	0xaf,
+	0x3b,
+	0x02,
+	0xda,
+	0x63,
+	0x90,
+	0x69,
+	0xe1,
+	0xe0,
+	0xfd,
+	0x70,
+	0x03,
+	0x02,
+	0xda,
+	0x63,
+	0x90,
+	0x69,
+	0xe1,
+	0xe4,
+	0xf0,
+	0x90,
+	0x30,
+	0x0a,
+	0xe0,
+	0xfd,
+	0xbd,
+	0xdb,
+	0x06,
+	0x90,
+	0x30,
+	0x02,
+	0x74,
+	0x44,
+	0xf0,
+	0x90,
+	0x6c,
+	0x08,
+	0x74,
+	0x38,
+	0xf0,
+	0x12,
+	0xaf,
+	0x90,
+	0x02,
+	0xda,
+	0x63,
+	0x12,
+	0xc0,
+	0x85,
+	0xac,
+	0x82,
+	0xad,
+	0x83,
+	0x8c,
+	0x06,
+	0x8d,
+	0x07,
+	0xee,
+	0x4f,
+	0x60,
+	0x23,
+	0x90,
+	0x30,
+	0x0a,
+	0xe0,
+	0xfd,
+	0xbd,
+	0xdb,
+	0x06,
+	0x90,
+	0x30,
+	0x02,
+	0x74,
+	0x47,
+	0xf0,
+	0x90,
+	0x6c,
+	0x08,
+	0x74,
+	0x33,
+	0xf0,
+	0x12,
+	0xaf,
+	0x90,
+	0x90,
+	0x30,
+	0x08,
+	0x74,
+	0x12,
+	0xf0,
+	0x12,
+	0xaf,
+	0x3b,
+	0x02,
+	0xda,
+	0x63,
+	0x90,
+	0x30,
+	0x0a,
+	0xe0,
+	0xfd,
+	0xbd,
+	0xdb,
+	0x06,
+	0x90,
+	0x30,
+	0x02,
+	0x74,
+	0x48,
+	0xf0,
+	0x90,
+	0x69,
+	0xe5,
+	0xe0,
+	0xf5,
+	0x82,
+	0x12,
+	0xa1,
+	0x8f,
+	0x12,
+	0xc0,
+	0xb5,
+	0x12,
+	0xc1,
+	0x44,
+	0x12,
+	0xc1,
+	0x9d,
+	0x90,
+	0x30,
+	0x33,
+	0xe0,
+	0xf5,
+	0x82,
+	0x12,
+	0xaf,
+	0x74,
+	0x12,
+	0xc1,
+	0xea,
+	0x12,
+	0xaf,
+	0x3b,
+	0x90,
+	0x30,
+	0x2e,
+	0x74,
+	0x02,
+	0xf0,
+	0x90,
+	0x63,
+	0x64,
+	0x75,
+	0xf0,
+	0x00,
+	0x12,
+	0xf4,
+	0x15,
+	0xfa,
+	0xa3,
+	0x12,
+	0xf4,
+	0x15,
+	0xfb,
+	0xa3,
+	0x12,
+	0xf4,
+	0x15,
+	0xfc,
+	0xa3,
+	0x12,
+	0xf4,
+	0x15,
+	0xfd,
+	0x90,
+	0x44,
+	0xcc,
+	0xea,
+	0xf0,
+	0xa3,
+	0xeb,
+	0xf0,
+	0xa3,
+	0xec,
+	0xf0,
+	0xa3,
+	0xed,
+	0xf0,
+	0x90,
+	0x63,
+	0x60,
+	0x75,
+	0xf0,
+	0x00,
+	0x12,
+	0xf4,
+	0x15,
+	0xfa,
+	0xa3,
+	0x12,
+	0xf4,
+	0x15,
+	0xfb,
+	0xa3,
+	0x12,
+	0xf4,
+	0x15,
+	0xfc,
+	0xa3,
+	0x12,
+	0xf4,
+	0x15,
+	0xfd,
+	0x90,
+	0x44,
+	0xc8,
+	0xea,
+	0xf0,
+	0xa3,
+	0xeb,
+	0xf0,
+	0xa3,
+	0xec,
+	0xf0,
+	0xa3,
+	0xed,
+	0xf0,
+	0x90,
+	0x63,
+	0x5c,
+	0x75,
+	0xf0,
+	0x00,
+	0x12,
+	0xf4,
+	0x15,
+	0xfa,
+	0xa3,
+	0x12,
+	0xf4,
+	0x15,
+	0xfb,
+	0xa3,
+	0x12,
+	0xf4,
+	0x15,
+	0xfc,
+	0xa3,
+	0x12,
+	0xf4,
+	0x15,
+	0xfd,
+	0x90,
+	0x44,
+	0xc4,
+	0xea,
+	0xf0,
+	0xa3,
+	0xeb,
+	0xf0,
+	0xa3,
+	0xec,
+	0xf0,
+	0xa3,
+	0xed,
+	0xf0,
+	0x90,
+	0x63,
+	0x58,
+	0xe0,
+	0xfa,
+	0xa3,
+	0xe0,
+	0xfb,
+	0xa3,
+	0xe0,
+	0xfc,
+	0xa3,
+	0xe0,
+	0xfd,
+	0x90,
+	0x44,
+	0xc0,
+	0xea,
+	0xf0,
+	0xa3,
+	0xeb,
+	0xf0,
+	0xa3,
+	0xec,
+	0xf0,
+	0xa3,
+	0xed,
+	0xf0,
+	0x90,
+	0x63,
+	0x54,
+	0x75,
+	0xf0,
+	0x00,
+	0x12,
+	0xf4,
+	0x15,
+	0xfa,
+	0xa3,
+	0x12,
+	0xf4,
+	0x15,
+	0xfb,
+	0xa3,
+	0x12,
+	0xf4,
+	0x15,
+	0xfc,
+	0xa3,
+	0x12,
+	0xf4,
+	0x15,
+	0xfd,
+	0x90,
+	0x44,
+	0x84,
+	0xea,
+	0xf0,
+	0xa3,
+	0xeb,
+	0xf0,
+	0xa3,
+	0xec,
+	0xf0,
+	0xa3,
+	0xed,
+	0xf0,
+	0x90,
+	0x63,
+	0x50,
+	0xe0,
+	0xfa,
+	0xa3,
+	0xe0,
+	0xfb,
+	0xa3,
+	0xe0,
+	0xfc,
+	0xa3,
+	0xe0,
+	0xfd,
+	0x90,
+	0x44,
+	0x80,
+	0xea,
+	0xf0,
+	0xa3,
+	0xeb,
+	0xf0,
+	0xa3,
+	0xec,
+	0xf0,
+	0xa3,
+	0xed,
+	0xf0,
+	0x90,
+	0x30,
+	0x45,
+	0xe0,
+	0xfd,
+	0x60,
+	0x27,
+	0x90,
+	0x30,
+	0x02,
+	0xe0,
+	0xfd,
+	0x53,
+	0x05,
+	0x08,
+	0xbd,
+	0x08,
+	0x02,
+	0x80,
+	0x1a,
+	0x90,
+	0x69,
+	0xe1,
+	0xe4,
+	0xf0,
+	0x12,
+	0xaf,
+	0x3b,
+	0x90,
+	0x30,
+	0x3e,
+	0xe0,
+	0xf5,
+	0x82,
+	0x12,
+	0xaf,
+	0x60,
+	0x90,
+	0x30,
+	0x08,
+	0x74,
+	0x1e,
+	0xf0,
+	0x02,
+	0xda,
+	0x63,
+	0x90,
+	0x30,
+	0x3a,
+	0xe0,
+	0xf5,
+	0x82,
+	0x12,
+	0xaf,
+	0x44,
+	0x90,
+	0x30,
+	0x08,
+	0x74,
+	0x2b,
+	0xf0,
+	0x02,
+	0xda,
+	0x63,
+	0x90,
+	0x69,
+	0xe3,
+	0xe0,
+	0xfd,
+	0x70,
+	0x03,
+	0x02,
+	0xe2,
+	0x28,
+	0x90,
+	0x69,
+	0xe3,
+	0xe4,
+	0xf0,
+	0x12,
+	0xaf,
+	0x3b,
+	0x90,
+	0x69,
+	0xe4,
+	0xe0,
+	0xfd,
+	0xbd,
+	0x0c,
+	0x77,
+	0x12,
+	0xc2,
+	0x57,
+	0x90,
+	0x30,
+	0x48,
+	0xe0,
+	0x70,
+	0x0c,
+	0x90,
+	0x30,
+	0x47,
+	0xe0,
+	0x70,
+	0x06,
+	0x90,
+	0x30,
+	0x46,
+	0xe0,
+	0x60,
+	0x0e,
+	0x90,
+	0x30,
+	0x07,
+	0xe4,
+	0xf0,
+	0x90,
+	0x6c,
+	0x08,
+	0x74,
+	0x3e,
+	0xf0,
+	0x12,
+	0xaf,
+	0x90,
+	0x90,
+	0x30,
+	0x22,
+	0xe0,
+	0xfd,
+	0x54,
+	0x0c,
+	0x60,
+	0x0e,
+	0x90,
+	0x30,
+	0x07,
+	0xe4,
+	0xf0,
+	0x90,
+	0x6c,
+	0x08,
+	0x74,
+	0x3d,
+	0xf0,
+	0x12,
+	0xaf,
+	0x90,
+	0x12,
+	0xc6,
+	0xbd,
+	0x90,
+	0x30,
+	0x0f,
+	0x74,
+	0x40,
+	0xf0,
+	0xd2,
+	0xaa,
+	0x90,
+	0x30,
+	0x2f,
+	0xe0,
+	0x90,
+	0x30,
+	0x2c,
+	0xf0,
+	0x90,
+	0x30,
+	0x4b,
+	0xe4,
+	0xf0,
+	0x90,
+	0x30,
+	0x4a,
+	0xf0,
+	0x90,
+	0x30,
+	0x49,
+	0xf0,
+	0x90,
+	0x30,
+	0x02,
+	0xe0,
+	0xfd,
+	0x53,
+	0x05,
+	0x80,
+	0xbd,
+	0x80,
+	0x09,
+	0x90,
+	0x30,
+	0x08,
+	0x74,
+	0x2b,
+	0xf0,
+	0x02,
+	0xda,
+	0x63,
+	0x90,
+	0x30,
+	0x08,
+	0x74,
+	0x23,
+	0xf0,
+	0x02,
+	0xda,
+	0x63,
+	0x90,
+	0x30,
+	0x0a,
+	0xe0,
+	0xfd,
+	0xbd,
+	0xdb,
+	0x06,
+	0x90,
+	0x30,
+	0x02,
+	0x74,
+	0x4c,
+	0xf0,
+	0x90,
+	0x69,
+	0xf2,
+	0xe0,
+	0x24,
+	0x01,
+	0xf0,
+	0x12,
+	0xaf,
+	0x90,
+	0x02,
+	0xda,
+	0x63,
+	0x90,
+	0x69,
+	0xe1,
+	0xe0,
+	0xfd,
+	0x70,
+	0x03,
+	0x02,
+	0xda,
+	0x63,
+	0x90,
+	0x69,
+	0xe1,
+	0xe4,
+	0xf0,
+	0x12,
+	0xaf,
+	0x3b,
+	0x90,
+	0x6c,
+	0x08,
+	0x74,
+	0x3a,
+	0xf0,
+	0x12,
+	0xaf,
+	0x90,
+	0x02,
+	0xda,
+	0x63,
+	0x12,
+	0xc4,
+	0xc1,
+	0x90,
+	0x30,
+	0x2d,
+	0x74,
+	0x02,
+	0xf0,
+	0x90,
+	0x30,
+	0x37,
+	0xe0,
+	0xf5,
+	0x82,
+	0x12,
+	0xaf,
+	0x44,
+	0x12,
+	0xa8,
+	0xa3,
+	0x12,
+	0xa7,
+	0x9f,
+	0x90,
+	0x30,
+	0x07,
+	0xe0,
+	0xfd,
+	0x54,
+	0x77,
+	0xf0,
+	0x90,
+	0x69,
+	0xe9,
+	0x74,
+	0x01,
+	0xf0,
+	0x90,
+	0x30,
+	0x08,
+	0x74,
+	0x25,
+	0xf0,
+	0x02,
+	0xda,
+	0x63,
+	0x90,
+	0x69,
+	0xe3,
+	0xe0,
+	0xfd,
+	0x70,
+	0x03,
+	0x02,
+	0xe3,
+	0x43,
+	0x90,
+	0x69,
+	0xe3,
+	0xe4,
+	0xf0,
+	0x90,
+	0x69,
+	0xe4,
+	0xe0,
+	0xfd,
+	0xbd,
+	0x11,
+	0x02,
+	0x80,
+	0x03,
+	0x02,
+	0xe3,
+	0x28,
+	0x12,
+	0xaf,
+	0x3b,
+	0x12,
+	0xc5,
+	0xe0,
+	0x12,
+	0xc6,
+	0x81,
+	0xac,
+	0x82,
+	0xad,
+	0x83,
+	0x8c,
+	0x06,
+	0x8d,
+	0x07,
+	0xee,
+	0x4f,
+	0x60,
+	0x4e,
+	0x90,
+	0x30,
+	0x07,
+	0xe0,
+	0x44,
+	0x08,
+	0xf0,
+	0x90,
+	0x30,
+	0x0a,
+	0xe0,
+	0xfd,
+	0xbd,
+	0xdb,
+	0x06,
+	0x90,
+	0x30,
+	0x02,
+	0x74,
+	0x4a,
+	0xf0,
+	0x90,
+	0x30,
+	0x49,
+	0xe0,
+	0xfd,
+	0xbd,
+	0xff,
+	0x1e,
+	0x90,
+	0x30,
+	0x4a,
+	0xe0,
+	0xfd,
+	0xbd,
+	0xff,
+	0x0b,
+	0x90,
+	0x30,
+	0x4b,
+	0xe0,
+	0xfd,
+	0x0d,
+	0x90,
+	0x30,
+	0x4b,
+	0xed,
+	0xf0,
+	0x90,
+	0x30,
+	0x4a,
+	0xe0,
+	0xfd,
+	0x0d,
+	0x90,
+	0x30,
+	0x4a,
+	0xed,
+	0xf0,
+	0x90,
+	0x30,
+	0x49,
+	0xe0,
+	0xfd,
+	0x0d,
+	0x90,
+	0x30,
+	0x49,
+	0xed,
+	0xf0,
+	0x90,
+	0x30,
+	0x08,
+	0x74,
+	0x23,
+	0xf0,
+	0x80,
+	0x2b,
+	0x90,
+	0x30,
+	0x07,
+	0xe0,
+	0x44,
+	0x80,
+	0xf0,
+	0x90,
+	0x30,
+	0x0a,
+	0xe0,
+	0xfd,
+	0xbd,
+	0xdb,
+	0x06,
+	0x90,
+	0x30,
+	0x02,
+	0x74,
+	0x4b,
+	0xf0,
+	0xd2,
+	0xaa,
+	0x90,
+	0x69,
+	0xe9,
+	0xe4,
+	0xf0,
+	0x90,
+	0x30,
+	0x3d,
+	0xe0,
+	0xf5,
+	0x82,
+	0x12,
+	0xaf,
+	0x44,
+	0x90,
+	0x30,
+	0x08,
+	0x74,
+	0x2b,
+	0xf0,
+	0x90,
+	0x30,
+	0x0f,
+	0x74,
+	0x80,
+	0xf0,
+	0x02,
+	0xda,
+	0x63,
+	0x90,
+	0x30,
+	0x0a,
+	0xe0,
+	0xfd,
+	0xbd,
+	0xdb,
+	0x06,
+	0x90,
+	0x30,
+	0x02,
+	0x74,
+	0x4c,
+	0xf0,
+	0x90,
+	0x69,
+	0xf2,
+	0xe0,
+	0x24,
+	0x01,
+	0xf0,
+	0x12,
+	0xaf,
+	0x90,
+	0x02,
+	0xda,
+	0x63,
+	0x90,
+	0x69,
+	0xe1,
+	0xe0,
+	0xfd,
+	0x70,
+	0x03,
+	0x02,
+	0xda,
+	0x63,
+	0x90,
+	0x69,
+	0xe1,
+	0xe4,
+	0xf0,
+	0x12,
+	0xaf,
+	0x3b,
+	0x90,
+	0x69,
+	0xe9,
+	0xe4,
+	0xf0,
+	0x90,
+	0x30,
+	0x07,
+	0xe0,
+	0x44,
+	0x08,
+	0xf0,
+	0x90,
+	0x30,
+	0x0a,
+	0xe0,
+	0xfd,
+	0xbd,
+	0xdb,
+	0x06,
+	0x90,
+	0x30,
+	0x02,
+	0x74,
+	0x4d,
+	0xf0,
+	0x90,
+	0x30,
+	0x49,
+	0xe0,
+	0xfd,
+	0xbd,
+	0xff,
+	0x1e,
+	0x90,
+	0x30,
+	0x4a,
+	0xe0,
+	0xfd,
+	0xbd,
+	0xff,
+	0x0b,
+	0x90,
+	0x30,
+	0x4b,
+	0xe0,
+	0xfd,
+	0x0d,
+	0x90,
+	0x30,
+	0x4b,
+	0xed,
+	0xf0,
+	0x90,
+	0x30,
+	0x4a,
+	0xe0,
+	0xfd,
+	0x0d,
+	0x90,
+	0x30,
+	0x4a,
+	0xed,
+	0xf0,
+	0x90,
+	0x30,
+	0x49,
+	0xe0,
+	0xfd,
+	0x0d,
+	0x90,
+	0x30,
+	0x49,
+	0xed,
+	0xf0,
+	0x90,
+	0x30,
+	0x08,
+	0x74,
+	0x23,
+	0xf0,
+	0x02,
+	0xda,
+	0x63,
+	0x90,
+	0x30,
+	0x45,
+	0xe0,
+	0xfd,
+	0x60,
+	0x24,
+	0x90,
+	0x30,
+	0x02,
+	0xe0,
+	0xfd,
+	0x53,
+	0x05,
+	0x08,
+	0xbd,
+	0x08,
+	0x02,
+	0x80,
+	0x17,
+	0x90,
+	0x30,
+	0x22,
+	0xe0,
+	0xfd,
+	0x54,
+	0x0c,
+	0x60,
+	0x0e,
+	0x90,
+	0x30,
+	0x07,
+	0xe4,
+	0xf0,
+	0x90,
+	0x6c,
+	0x08,
+	0x74,
+	0x3d,
+	0xf0,
+	0x12,
+	0xaf,
+	0x90,
+	0x90,
+	0x30,
+	0x01,
+	0xe0,
+	0xfd,
+	0x53,
+	0x05,
+	0x40,
+	0xbd,
+	0x40,
+	0x08,
+	0x90,
+	0x30,
+	0x07,
+	0xe0,
+	0xfd,
+	0x54,
+	0xf7,
+	0xf0,
+	0x90,
+	0x69,
+	0xe3,
+	0xe0,
+	0xfd,
+	0x70,
+	0x03,
+	0x02,
+	0xe5,
+	0x29,
+	0x90,
+	0x69,
+	0xe3,
+	0xe4,
+	0xf0,
+	0x90,
+	0x69,
+	0xe4,
+	0xe0,
+	0xfd,
+	0xbd,
+	0x0c,
+	0x02,
+	0x80,
+	0x03,
+	0x02,
+	0xe4,
+	0xb7,
+	0x12,
+	0xc2,
+	0x57,
+	0x90,
+	0x30,
+	0x02,
+	0xe0,
+	0xfd,
+	0x53,
+	0x05,
+	0x08,
+	0xbd,
+	0x08,
+	0x03,
+	0x02,
+	0xe4,
+	0xa1,
+	0x90,
+	0x69,
+	0xba,
+	0xe0,
+	0xfd,
+	0x90,
+	0x30,
+	0x48,
+	0xe0,
+	0xfc,
+	0xc3,
+	0x9d,
+	0x40,
+	0x47,
+	0x90,
+	0x69,
+	0xba,
+	0xe0,
+	0xfd,
+	0x90,
+	0x30,
+	0x48,
+	0xe0,
+	0xfc,
+	0xed,
+	0xb5,
+	0x04,
+	0x0e,
+	0x90,
+	0x69,
+	0xb9,
+	0xe0,
+	0xfd,
+	0x90,
+	0x30,
+	0x47,
+	0xe0,
+	0xfc,
+	0xc3,
+	0x9d,
+	0x40,
+	0x2b,
+	0x90,
+	0x69,
+	0xba,
+	0xe0,
+	0xfd,
+	0x90,
+	0x30,
+	0x48,
+	0xe0,
+	0xfc,
+	0xed,
+	0xb5,
+	0x04,
+	0x2e,
+	0x90,
+	0x69,
+	0xb9,
+	0xe0,
+	0xfd,
+	0x90,
+	0x30,
+	0x47,
+	0xe0,
+	0xfc,
+	0xed,
+	0xb5,
+	0x04,
+	0x20,
+	0x90,
+	0x69,
+	0xb8,
+	0xe0,
+	0xfd,
+	0x90,
+	0x30,
+	0x46,
+	0xe0,
+	0xfc,
+	0xc3,
+	0xed,
+	0x9c,
+	0x40,
+	0x11,
+	0x90,
+	0x30,
+	0x07,
+	0x74,
+	0x02,
+	0xf0,
+	0x90,
+	0x6c,
+	0x08,
+	0x74,
+	0x3b,
+	0xf0,
+	0x12,
+	0xaf,
+	0x90,
+	0x80,
+	0x27,
+	0x90,
+	0x69,
+	0xba,
+	0xe0,
+	0xfd,
+	0xbd,
+	0xff,
+	0x1f,
+	0x90,
+	0x69,
+	0xb9,
+	0xe0,
+	0xfd,
+	0xbd,
+	0xff,
+	0x17,
+	0x90,
+	0x69,
+	0xb8,
+	0xe0,
+	0xfd,
+	0xbd,
+	0xff,
+	0x0f,
+	0x90,
+	0x30,
+	0x07,
+	0x74,
+	0x02,
+	0xf0,
+	0x90,
+	0x6c,
+	0x08,
+	0x74,
+	0x3c,
+	0xf0,
+	0x12,
+	0xaf,
+	0x90,
+	0x12,
+	0xc6,
+	0xbd,
+	0x90,
+	0x30,
+	0x0f,
+	0x74,
+	0x40,
+	0xf0,
+	0x90,
+	0x30,
+	0x07,
+	0xe0,
+	0xfd,
+	0x44,
+	0x81,
+	0xf0,
+	0xd2,
+	0xaa,
+	0x02,
+	0xda,
+	0x63,
+	0x90,
+	0x69,
+	0xe4,
+	0xe0,
+	0xfd,
+	0xbd,
+	0x11,
+	0x4f,
+	0x12,
+	0xaf,
+	0x3b,
+	0x12,
+	0xc5,
+	0xe0,
+	0x12,
+	0xc6,
+	0x81,
+	0xac,
+	0x82,
+	0xad,
+	0x83,
+	0x8c,
+	0x06,
+	0x8d,
+	0x07,
+	0xee,
+	0x4f,
+	0x60,
+	0x15,
+	0x90,
+	0x30,
+	0x07,
+	0xe0,
+	0x44,
+	0x08,
+	0xf0,
+	0x90,
+	0x30,
+	0x0a,
+	0xe0,
+	0xfd,
+	0xbd,
+	0xdb,
+	0x06,
+	0x90,
+	0x30,
+	0x02,
+	0x74,
+	0x4a,
+	0xf0,
+	0x90,
+	0x30,
+	0x0f,
+	0x74,
+	0x80,
+	0xf0,
+	0x90,
+	0x30,
+	0x07,
+	0xe0,
+	0x44,
+	0x81,
+	0xf0,
+	0x90,
+	0x30,
+	0x0a,
+	0xe0,
+	0xfd,
+	0xbd,
+	0xdb,
+	0x06,
+	0x90,
+	0x30,
+	0x02,
+	0x74,
+	0x4b,
+	0xf0,
+	0xd2,
+	0xaa,
+	0x90,
+	0x69,
+	0xe9,
+	0xe4,
+	0xf0,
+	0x02,
+	0xda,
+	0x63,
+	0x90,
+	0x30,
+	0x0a,
+	0xe0,
+	0xfd,
+	0xbd,
+	0xdb,
+	0x06,
+	0x90,
+	0x30,
+	0x02,
+	0x74,
+	0x4c,
+	0xf0,
+	0x90,
+	0x69,
+	0xf2,
+	0xe0,
+	0x24,
+	0x01,
+	0xf0,
+	0x12,
+	0xaf,
+	0x90,
+	0x02,
+	0xda,
+	0x63,
+	0x90,
+	0x69,
+	0xe9,
+	0xe0,
+	0xfd,
+	0x60,
+	0x03,
+	0x02,
+	0xe5,
+	0xd1,
+	0x90,
+	0x30,
+	0x2b,
+	0xe0,
+	0xfd,
+	0x20,
+	0xe1,
+	0x03,
+	0x02,
+	0xe5,
+	0xd1,
+	0x90,
+	0x30,
+	0x2f,
+	0xe0,
+	0x90,
+	0x30,
+	0x2c,
+	0xf0,
+	0x90,
+	0x30,
+	0x49,
+	0xe0,
+	0xfd,
+	0x90,
+	0x30,
+	0x4f,
+	0xe0,
+	0xfc,
+	0xed,
+	0xb5,
+	0x04,
+	0x3b,
+	0x90,
+	0x30,
+	0x02,
+	0xe0,
+	0xfd,
+	0x20,
+	0xe7,
+	0x33,
+	0x90,
+	0x30,
+	0x49,
+	0xe0,
+	0xfd,
+	0xbd,
+	0xff,
+	0x1e,
+	0x90,
+	0x30,
+	0x4a,
+	0xe0,
+	0xfd,
+	0xbd,
+	0xff,
+	0x0b,
+	0x90,
+	0x30,
+	0x4b,
+	0xe0,
+	0xfd,
+	0x0d,
+	0x90,
+	0x30,
+	0x4b,
+	0xed,
+	0xf0,
+	0x90,
+	0x30,
+	0x4a,
+	0xe0,
+	0xfd,
+	0x0d,
+	0x90,
+	0x30,
+	0x4a,
+	0xed,
+	0xf0,
+	0x90,
+	0x30,
+	0x49,
+	0xe0,
+	0xfd,
+	0x0d,
+	0x90,
+	0x30,
+	0x49,
+	0xed,
+	0xf0,
+	0x80,
+	0x19,
+	0x90,
+	0x30,
+	0x51,
+	0xe0,
+	0x90,
+	0x30,
+	0x4b,
+	0xf0,
+	0x90,
+	0x30,
+	0x50,
+	0xe0,
+	0x90,
+	0x30,
+	0x4a,
+	0xf0,
+	0x90,
+	0x30,
+	0x4f,
+	0xe0,
+	0xfd,
+	0x90,
+	0x30,
+	0x49,
+	0xf0,
+	0x12,
+	0xc4,
+	0xc1,
+	0x90,
+	0x30,
+	0x2d,
+	0x74,
+	0x02,
+	0xf0,
+	0x90,
+	0x30,
+	0x37,
+	0xe0,
+	0xf5,
+	0x82,
+	0x12,
+	0xaf,
+	0x44,
+	0x12,
+	0xa8,
+	0xa3,
+	0x12,
+	0xa7,
+	0x9f,
+	0x90,
+	0x30,
+	0x07,
+	0xe0,
+	0xfd,
+	0x54,
+	0x77,
+	0xf0,
+	0x90,
+	0x69,
+	0xe9,
+	0x74,
+	0x01,
+	0xf0,
+	0x02,
+	0xda,
+	0x63,
+	0x90,
+	0x69,
+	0xe1,
+	0xe0,
+	0xfd,
+	0x70,
+	0x03,
+	0x02,
+	0xda,
+	0x63,
+	0x90,
+	0x69,
+	0xe1,
+	0xe4,
+	0xf0,
+	0x12,
+	0xaf,
+	0x3b,
+	0x90,
+	0x69,
+	0xe9,
+	0xe0,
+	0xfd,
+	0x60,
+	0x28,
+	0x90,
+	0x69,
+	0xe9,
+	0xe4,
+	0xf0,
+	0x90,
+	0x30,
+	0x07,
+	0xe0,
+	0x44,
+	0x08,
+	0xf0,
+	0x90,
+	0x30,
+	0x0f,
+	0x74,
+	0x80,
+	0xf0,
+	0x90,
+	0x30,
+	0x0a,
+	0xe0,
+	0xfd,
+	0xbd,
+	0xdb,
+	0x02,
+	0x80,
+	0x03,
+	0x02,
+	0xda,
+	0x63,
+	0x90,
+	0x30,
+	0x02,
+	0x74,
+	0x4d,
+	0xf0,
+	0x02,
+	0xda,
+	0x63,
+	0x90,
+	0x30,
+	0x07,
+	0xe0,
+	0xfd,
+	0x44,
+	0x81,
+	0xf0,
+	0x02,
+	0xda,
+	0x63,
+	0x90,
+	0x30,
+	0x08,
+	0xe4,
+	0xf0,
+	0x02,
+	0xda,
+	0x63,
+	0x90,
+	0x30,
+	0x03,
+	0xe0,
+	0xfd,
+	0xbd,
+	0xff,
+	0x06,
+	0x75,
+	0xf7,
+	0x01,
+	0x75,
+	0xf7,
+	0x01,
+	0x90,
+	0x30,
+	0x03,
+	0xe0,
+	0xfd,
+	0xbd,
+	0xdb,
+	0x3f,
+	0x90,
+	0x69,
+	0xe1,
+	0xe4,
+	0xf0,
+	0x12,
+	0xaf,
+	0x3b,
+	0x90,
+	0x30,
+	0x32,
+	0xe0,
+	0xf5,
+	0x82,
+	0x12,
+	0xaf,
+	0x44,
+	0x7d,
+	0x00,
+	0x90,
+	0x30,
+	0x03,
+	0xe0,
+	0xfc,
+	0xbc,
+	0xdb,
+	0x24,
+	0x90,
+	0x69,
+	0xe1,
+	0xe0,
+	0xfc,
+	0x60,
+	0xf1,
+	0x90,
+	0x69,
+	0xe1,
+	0xe4,
+	0xf0,
+	0xc0,
+	0x05,
+	0x12,
+	0xaf,
+	0x3b,
+	0x90,
+	0x30,
+	0x32,
+	0xe0,
+	0xf5,
+	0x82,
+	0x12,
+	0xaf,
+	0x44,
+	0xd0,
+	0x05,
+	0x90,
+	0x30,
+	0x03,
+	0xed,
+	0xf0,
+	0x0d,
+	0x80,
+	0xd4,
+	0x90,
+	0x30,
+	0x00,
+	0xe0,
+	0xfd,
+	0xbd,
+	0x20,
+	0x03,
+	0x75,
+	0xff,
+	0x01,
+	0x90,
+	0x30,
+	0x05,
+	0xe0,
+	0xfd,
+	0x30,
+	0xe0,
+	0x05,
+	0x12,
+	0xd8,
+	0x40,
+	0x80,
+	0x93,
+	0x90,
+	0x69,
+	0x8f,
+	0xe0,
+	0xfd,
+	0x60,
+	0x11,
+	0x75,
+	0xff,
+	0x01,
+	0x90,
+	0x30,
+	0x07,
+	0xe4,
+	0xf0,
+	0x90,
+	0x30,
+	0x08,
+	0x74,
+	0x40,
+	0xf0,
+	0x02,
+	0xe6,
+	0x25,
+	0x90,
+	0x30,
+	0x08,
+	0xe0,
+	0xfd,
+	0x60,
+	0x2c,
+	0xbd,
+	0x0f,
+	0x03,
+	0x02,
+	0xe7,
+	0xbb,
+	0xbd,
+	0x15,
+	0x03,
+	0x02,
+	0xe8,
+	0x12,
+	0xbd,
+	0x18,
+	0x03,
+	0x02,
+	0xe9,
+	0x70,
+	0xbd,
+	0x1b,
+	0x03,
+	0x02,
+	0xe9,
+	0xbd,
+	0xbd,
+	0x1d,
+	0x03,
+	0x02,
+	0xea,
+	0x86,
+	0xbd,
+	0x28,
+	0x02,
+	0x80,
+	0x6e,
+	0xbd,
+	0x2b,
+	0x03,
+	0x02,
+	0xea,
+	0xe3,
+	0x02,
+	0xec,
+	0xba,
+	0x90,
+	0x69,
+	0xea,
+	0xe4,
+	0xf0,
+	0xd2,
+	0xaa,
+	0x90,
+	0x6c,
+	0x34,
+	0xe0,
+	0xfd,
+	0x60,
+	0x32,
+	0x90,
+	0x69,
+	0xe3,
+	0xe4,
+	0xf0,
+	0x90,
+	0x6c,
+	0x34,
+	0xf0,
+	0x90,
+	0x30,
+	0x2e,
+	0x74,
+	0x01,
+	0xf0,
+	0x12,
+	0xaf,
+	0x3b,
+	0xd2,
+	0xaa,
+	0x90,
+	0x30,
+	0x33,
+	0xe0,
+	0xf5,
+	0x82,
+	0x12,
+	0xaf,
+	0x74,
+	0x12,
+	0xd0,
+	0x03,
+	0x12,
+	0xaf,
+	0x3b,
+	0x90,
+	0x30,
+	0x2e,
+	0x74,
+	0x04,
+	0xf0,
+	0x90,
+	0x30,
+	0x08,
+	0x74,
+	0x28,
+	0xf0,
+	0x02,
+	0xe6,
+	0x25,
+	0x90,
+	0x69,
+	0xe3,
+	0xe0,
+	0xfd,
+	0x70,
+	0x03,
+	0x02,
+	0xe6,
+	0x25,
+	0x90,
+	0x69,
+	0xe3,
+	0xe4,
+	0xf0,
+	0xd2,
+	0xaa,
+	0x90,
+	0x30,
+	0x0a,
+	0xe0,
+	0xfd,
+	0xbd,
+	0xdb,
+	0x06,
+	0x90,
+	0x30,
+	0x02,
+	0x74,
+	0xa3,
+	0xf0,
+	0x12,
+	0xaf,
+	0x90,
+	0x02,
+	0xe6,
+	0x25,
+	0x90,
+	0x69,
+	0xe3,
+	0xe0,
+	0xfd,
+	0x70,
+	0x03,
+	0x02,
+	0xe6,
+	0x25,
+	0x90,
+	0x69,
+	0xe3,
+	0xe4,
+	0xf0,
+	0x12,
+	0xaf,
+	0x3b,
+	0x90,
+	0x30,
+	0x33,
+	0xe0,
+	0xf5,
+	0x82,
+	0x12,
+	0xaf,
+	0x74,
+	0x90,
+	0x69,
+	0xe4,
+	0xe0,
+	0xfd,
+	0xbd,
+	0x04,
+	0x1d,
+	0x12,
+	0xd1,
+	0xfc,
+	0x90,
+	0x30,
+	0x0f,
+	0x74,
+	0x01,
+	0xf0,
+	0xd2,
+	0xaa,
+	0x12,
+	0xd7,
+	0xf3,
+	0x90,
+	0x30,
+	0x0f,
+	0x74,
+	0x08,
+	0xf0,
+	0x90,
+	0x30,
+	0x08,
+	0x74,
+	0x0f,
+	0xf0,
+	0x02,
+	0xe6,
+	0x25,
+	0x90,
+	0x69,
+	0xe4,
+	0xe0,
+	0xfd,
+	0xbd,
+	0x05,
+	0x1d,
+	0x90,
+	0x69,
+	0xea,
+	0x74,
+	0x01,
+	0xf0,
+	0x12,
+	0xd2,
+	0xdd,
+	0x90,
+	0x30,
+	0x0f,
+	0x74,
+	0x02,
+	0xf0,
+	0xd2,
+	0xaa,
+	0x12,
+	0xd7,
+	0xf3,
+	0x90,
+	0x30,
+	0x08,
+	0x74,
+	0x0f,
+	0xf0,
+	0x02,
+	0xe6,
+	0x25,
+	0x90,
+	0x30,
+	0x0a,
+	0xe0,
+	0xfd,
+	0xbd,
+	0xdb,
+	0x06,
+	0x90,
+	0x30,
+	0x02,
+	0x74,
+	0xa4,
+	0xf0,
+	0x12,
+	0xaf,
+	0x90,
+	0x02,
+	0xe6,
+	0x25,
+	0x90,
+	0x69,
+	0xe3,
+	0xe0,
+	0xfd,
+	0x70,
+	0x03,
+	0x02,
+	0xe6,
+	0x25,
+	0x90,
+	0x69,
+	0xe3,
+	0xe4,
+	0xf0,
+	0x12,
+	0xaf,
+	0x3b,
+	0x90,
+	0x69,
+	0xe4,
+	0xe0,
+	0xfd,
+	0xbd,
+	0x09,
+	0x29,
+	0x90,
+	0x30,
+	0x33,
+	0xe0,
+	0xf5,
+	0x82,
+	0x12,
+	0xaf,
+	0x74,
+	0x12,
+	0xd3,
+	0x96,
+	0x90,
+	0x30,
+	0x0f,
+	0x74,
+	0x10,
+	0xf0,
+	0xd2,
+	0xaa,
+	0x12,
+	0xa4,
+	0x68,
+	0x12,
+	0xd4,
+	0x22,
+	0x90,
+	0x30,
+	0x0f,
+	0x74,
+	0x20,
+	0xf0,
+	0x90,
+	0x30,
+	0x08,
+	0x74,
+	0x15,
+	0xf0,
+	0x02,
+	0xe6,
+	0x25,
+	0x90,
+	0x30,
+	0x0a,
+	0xe0,
+	0xfd,
+	0xbd,
+	0xdb,
+	0x06,
+	0x90,
+	0x30,
+	0x02,
+	0x74,
+	0xa6,
+	0xf0,
+	0x12,
+	0xaf,
+	0x90,
+	0x02,
+	0xe6,
+	0x25,
+	0x90,
+	0x69,
+	0xe3,
+	0xe0,
+	0xfd,
+	0x70,
+	0x03,
+	0x02,
+	0xe6,
+	0x25,
+	0x90,
+	0x69,
+	0xe3,
+	0xe4,
+	0xf0,
+	0x12,
+	0xaf,
+	0x3b,
+	0x90,
+	0x69,
+	0xe4,
+	0xe0,
+	0xfd,
+	0xbd,
+	0x0b,
+	0x02,
+	0x80,
+	0x03,
+	0x02,
+	0xe9,
+	0x5c,
+	0x90,
+	0x30,
+	0x33,
+	0xe0,
+	0xf5,
+	0x82,
+	0x12,
+	0xaf,
+	0x74,
+	0x90,
+	0x30,
+	0x0a,
+	0xe0,
+	0xfd,
+	0xbd,
+	0xdb,
+	0x06,
+	0x90,
+	0x30,
+	0x02,
+	0x74,
+	0xaa,
+	0xf0,
+	0x12,
+	0xd4,
+	0x7f,
+	0x12,
+	0xaf,
+	0x3b,
+	0x90,
+	0x30,
+	0x2e,
+	0x74,
+	0x02,
+	0xf0,
+	0xd2,
+	0xaa,
+	0x90,
+	0x69,
+	0xe7,
+	0xe0,
+	0xf5,
+	0x82,
+	0x12,
+	0xa1,
+	0x8f,
+	0x12,
+	0xd4,
+	0xdc,
+	0x90,
+	0x63,
+	0x64,
+	0x75,
+	0xf0,
+	0x00,
+	0x12,
+	0xf4,
+	0x15,
+	0xfa,
+	0xa3,
+	0x12,
+	0xf4,
+	0x15,
+	0xfb,
+	0xa3,
+	0x12,
+	0xf4,
+	0x15,
+	0xfc,
+	0xa3,
+	0x12,
+	0xf4,
+	0x15,
+	0xfd,
+	0x90,
+	0x44,
+	0xcc,
+	0xea,
+	0xf0,
+	0xa3,
+	0xeb,
+	0xf0,
+	0xa3,
+	0xec,
+	0xf0,
+	0xa3,
+	0xed,
+	0xf0,
+	0x90,
+	0x63,
+	0x60,
+	0x75,
+	0xf0,
+	0x00,
+	0x12,
+	0xf4,
+	0x15,
+	0xfa,
+	0xa3,
+	0x12,
+	0xf4,
+	0x15,
+	0xfb,
+	0xa3,
+	0x12,
+	0xf4,
+	0x15,
+	0xfc,
+	0xa3,
+	0x12,
+	0xf4,
+	0x15,
+	0xfd,
+	0x90,
+	0x44,
+	0xc8,
+	0xea,
+	0xf0,
+	0xa3,
+	0xeb,
+	0xf0,
+	0xa3,
+	0xec,
+	0xf0,
+	0xa3,
+	0xed,
+	0xf0,
+	0x90,
+	0x63,
+	0x5c,
+	0x75,
+	0xf0,
+	0x00,
+	0x12,
+	0xf4,
+	0x15,
+	0xfa,
+	0xa3,
+	0x12,
+	0xf4,
+	0x15,
+	0xfb,
+	0xa3,
+	0x12,
+	0xf4,
+	0x15,
+	0xfc,
+	0xa3,
+	0x12,
+	0xf4,
+	0x15,
+	0xfd,
+	0x90,
+	0x44,
+	0xc4,
+	0xea,
+	0xf0,
+	0xa3,
+	0xeb,
+	0xf0,
+	0xa3,
+	0xec,
+	0xf0,
+	0xa3,
+	0xed,
+	0xf0,
+	0x90,
+	0x63,
+	0x58,
+	0xe0,
+	0xfa,
+	0xa3,
+	0xe0,
+	0xfb,
+	0xa3,
+	0xe0,
+	0xfc,
+	0xa3,
+	0xe0,
+	0xfd,
+	0x90,
+	0x44,
+	0xc0,
+	0xea,
+	0xf0,
+	0xa3,
+	0xeb,
+	0xf0,
+	0xa3,
+	0xec,
+	0xf0,
+	0xa3,
+	0xed,
+	0xf0,
+	0x90,
+	0x63,
+	0x54,
+	0x75,
+	0xf0,
+	0x00,
+	0x12,
+	0xf4,
+	0x15,
+	0xfa,
+	0xa3,
+	0x12,
+	0xf4,
+	0x15,
+	0xfb,
+	0xa3,
+	0x12,
+	0xf4,
+	0x15,
+	0xfc,
+	0xa3,
+	0x12,
+	0xf4,
+	0x15,
+	0xfd,
+	0x90,
+	0x44,
+	0x84,
+	0xea,
+	0xf0,
+	0xa3,
+	0xeb,
+	0xf0,
+	0xa3,
+	0xec,
+	0xf0,
+	0xa3,
+	0xed,
+	0xf0,
+	0x90,
+	0x63,
+	0x50,
+	0xe0,
+	0xfa,
+	0xa3,
+	0xe0,
+	0xfb,
+	0xa3,
+	0xe0,
+	0xfc,
+	0xa3,
+	0xe0,
+	0xfd,
+	0x90,
+	0x44,
+	0x80,
+	0xea,
+	0xf0,
+	0xa3,
+	0xeb,
+	0xf0,
+	0xa3,
+	0xec,
+	0xf0,
+	0xa3,
+	0xed,
+	0xf0,
+	0x90,
+	0x30,
+	0x45,
+	0xe0,
+	0xfd,
+	0x60,
+	0x16,
+	0x90,
+	0x30,
+	0x02,
+	0xe0,
+	0xfd,
+	0x53,
+	0x05,
+	0x08,
+	0xbd,
+	0x08,
+	0x02,
+	0x80,
+	0x09,
+	0x90,
+	0x30,
+	0x08,
+	0x74,
+	0x18,
+	0xf0,
+	0x02,
+	0xe6,
+	0x25,
+	0x90,
+	0x30,
+	0x08,
+	0x74,
+	0x2b,
+	0xf0,
+	0x02,
+	0xe6,
+	0x25,
+	0x90,
+	0x30,
+	0x0a,
+	0xe0,
+	0xfd,
+	0xbd,
+	0xdb,
+	0x06,
+	0x90,
+	0x30,
+	0x02,
+	0x74,
+	0xab,
+	0xf0,
+	0x12,
+	0xaf,
+	0x90,
+	0x02,
+	0xe6,
+	0x25,
+	0x90,
+	0x30,
+	0x23,
+	0xe0,
+	0xfd,
+	0x70,
+	0x03,
+	0x02,
+	0xe6,
+	0x25,
+	0x90,
+	0x30,
+	0x23,
+	0xe0,
+	0x90,
+	0x30,
+	0x20,
+	0xf0,
+	0x90,
+	0x30,
+	0x24,
+	0xe0,
+	0x90,
+	0x30,
+	0x21,
+	0xf0,
+	0x90,
+	0x30,
+	0x25,
+	0xe0,
+	0xfd,
+	0x90,
+	0x30,
+	0x22,
+	0x74,
+	0x0f,
+	0x5d,
+	0xf0,
+	0x90,
+	0x30,
+	0x48,
+	0xe4,
+	0xf0,
+	0x90,
+	0x30,
+	0x47,
+	0xf0,
+	0x90,
+	0x30,
+	0x46,
+	0xf0,
+	0x12,
+	0xd7,
+	0x8e,
+	0x90,
+	0x69,
+	0xe1,
+	0xe4,
+	0xf0,
+	0x12,
+	0xaf,
+	0x3b,
+	0x90,
+	0x30,
+	0x2d,
+	0x74,
+	0x01,
+	0xf0,
+	0x90,
+	0x30,
+	0x08,
+	0x74,
+	0x1b,
+	0xf0,
+	0x02,
+	0xe6,
+	0x25,
+	0x90,
+	0x69,
+	0xe3,
+	0xe0,
+	0xfd,
+	0x70,
+	0x03,
+	0x02,
+	0xea,
+	0x6e,
+	0x90,
+	0x69,
+	0xe3,
+	0xe4,
+	0xf0,
+	0x90,
+	0x69,
+	0xe4,
+	0xe0,
+	0xfd,
+	0xbd,
+	0x0f,
+	0x67,
+	0x12,
+	0xd6,
+	0x1b,
+	0x12,
+	0xaf,
+	0x3b,
+	0x90,
+	0x30,
+	0x0f,
+	0x74,
+	0x40,
+	0xf0,
+	0x12,
+	0xd6,
+	0x59,
+	0xac,
+	0x82,
+	0xad,
+	0x83,
+	0x8c,
+	0x06,
+	0x8d,
+	0x07,
+	0xee,
+	0x4f,
+	0x60,
+	0x1e,
+	0x90,
+	0x30,
+	0x07,
+	0xe0,
+	0x44,
+	0x08,
+	0xf0,
+	0xe0,
+	0x54,
+	0xfe,
+	0xf0,
+	0x90,
+	0x30,
+	0x0a,
+	0xe0,
+	0xfd,
+	0xbd,
+	0xdb,
+	0x06,
+	0x90,
+	0x30,
+	0x02,
+	0x74,
+	0xac,
+	0xf0,
+	0x12,
+	0xaf,
+	0x90,
+	0x80,
+	0x0e,
+	0x90,
+	0x30,
+	0x0a,
+	0xe0,
+	0xfd,
+	0xbd,
+	0xdb,
+	0x06,
+	0x90,
+	0x30,
+	0x02,
+	0x74,
+	0xad,
+	0xf0,
+	0xd2,
+	0xaa,
+	0x90,
+	0x69,
+	0xe9,
+	0xe0,
+	0xfd,
+	0x60,
+	0x0e,
+	0x90,
+	0x69,
+	0xe9,
+	0xe4,
+	0xf0,
+	0x90,
+	0x30,
+	0x08,
+	0x74,
+	0x2b,
+	0xf0,
+	0x02,
+	0xe6,
+	0x25,
+	0x90,
+	0x30,
+	0x08,
+	0x74,
+	0x1d,
+	0xf0,
+	0x02,
+	0xe6,
+	0x25,
+	0x90,
+	0x69,
+	0xe4,
+	0xe0,
+	0xfd,
+	0xbd,
+	0x10,
+	0x25,
+	0x90,
+	0x69,
+	0xe1,
+	0xe4,
+	0xf0,
+	0x12,
+	0xaf,
+	0x3b,
+	0x12,
+	0xd6,
+	0x99,
+	0x12,
+	0xa8,
+	0xa3,
+	0x12,
+	0xa7,
+	0x9f,
+	0x12,
+	0xd7,
+	0x3b,
+	0x90,
+	0x30,
+	0x0f,
+	0x74,
+	0x80,
+	0xf0,
+	0xd2,
+	0xaa,
+	0x90,
+	0x69,
+	0xe9,
+	0x74,
+	0x01,
+	0xf0,
+	0x02,
+	0xe6,
+	0x25,
+	0x12,
+	0xaf,
+	0x90,
+	0x02,
+	0xe6,
+	0x25,
+	0x90,
+	0x69,
+	0xe1,
+	0xe0,
+	0xfd,
+	0x70,
+	0x03,
+	0x02,
+	0xe6,
+	0x25,
+	0x90,
+	0x69,
+	0xe1,
+	0xe4,
+	0xf0,
+	0x12,
+	0xaf,
+	0x3b,
+	0x12,
+	0xaf,
+	0x90,
+	0x02,
+	0xe6,
+	0x25,
+	0x90,
+	0x69,
+	0xe3,
+	0xe0,
+	0xfd,
+	0x60,
+	0x3e,
+	0x90,
+	0x69,
+	0xe3,
+	0xe4,
+	0xf0,
+	0x90,
+	0x69,
+	0xe4,
+	0xe0,
+	0xfd,
+	0xbd,
+	0x10,
+	0x2b,
+	0x90,
+	0x69,
+	0xe1,
+	0xe4,
+	0xf0,
+	0x12,
+	0xaf,
+	0x3b,
+	0x12,
+	0xd6,
+	0x99,
+	0x12,
+	0xa8,
+	0xa3,
+	0x12,
+	0xa7,
+	0x9f,
+	0x12,
+	0xd7,
+	0x3b,
+	0x90,
+	0x30,
+	0x0f,
+	0x74,
+	0x80,
+	0xf0,
+	0xd2,
+	0xaa,
+	0x90,
+	0x30,
+	0x2b,
+	0x74,
+	0x01,
+	0xf0,
+	0x90,
+	0x30,
+	0x08,
+	0x74,
+	0x2b,
+	0xf0,
+	0x02,
+	0xe6,
+	0x25,
+	0x12,
+	0xaf,
+	0x90,
+	0x02,
+	0xe6,
+	0x25,
+	0x90,
+	0x69,
+	0xe1,
+	0xe0,
+	0xfd,
+	0x70,
+	0x03,
+	0x02,
+	0xe6,
+	0x25,
+	0x90,
+	0x69,
+	0xe1,
+	0xe4,
+	0xf0,
+	0x12,
+	0xaf,
+	0x3b,
+	0x12,
+	0xaf,
+	0x90,
+	0x02,
+	0xe6,
+	0x25,
+	0x90,
+	0x30,
+	0x07,
+	0xe0,
+	0x44,
+	0x01,
+	0xf0,
+	0x90,
+	0x69,
+	0xe3,
+	0xe0,
+	0xfd,
+	0x70,
+	0x03,
+	0x02,
+	0xec,
+	0x2f,
+	0x90,
+	0x69,
+	0xe3,
+	0xe4,
+	0xf0,
+	0x90,
+	0x69,
+	0xe4,
+	0xe0,
+	0xfd,
+	0xbd,
+	0x0f,
+	0x52,
+	0x12,
+	0xd6,
+	0x1b,
+	0x12,
+	0xaf,
+	0x3b,
+	0x90,
+	0x30,
+	0x0f,
+	0x74,
+	0x40,
+	0xf0,
+	0x12,
+	0xd6,
+	0x59,
+	0xac,
+	0x82,
+	0xad,
+	0x83,
+	0x8c,
+	0x06,
+	0x8d,
+	0x07,
+	0xee,
+	0x4f,
+	0x60,
+	0x1e,
+	0x90,
+	0x30,
+	0x07,
+	0xe0,
+	0x44,
+	0x08,
+	0xf0,
+	0xe0,
+	0x54,
+	0xfe,
+	0xf0,
+	0x90,
+	0x30,
+	0x0a,
+	0xe0,
+	0xff,
+	0xbf,
+	0xdb,
+	0x06,
+	0x90,
+	0x30,
+	0x02,
+	0x74,
+	0xac,
+	0xf0,
+	0x12,
+	0xaf,
+	0x90,
+	0x80,
+	0x0e,
+	0x90,
+	0x30,
+	0x0a,
+	0xe0,
+	0xff,
+	0xbf,
+	0xdb,
+	0x06,
+	0x90,
+	0x30,
+	0x02,
+	0x74,
+	0xad,
+	0xf0,
+	0xd2,
+	0xaa,
+	0x90,
+	0x30,
+	0x2d,
+	0x74,
+	0x01,
+	0xf0,
+	0x02,
+	0xe6,
+	0x25,
+	0x90,
+	0x69,
+	0xe4,
+	0xe0,
+	0xff,
+	0xbf,
+	0x10,
+	0x02,
+	0x80,
+	0x03,
+	0x02,
+	0xe6,
+	0x25,
+	0x12,
+	0xaf,
+	0x3b,
+	0x12,
+	0xd6,
+	0x99,
+	0x90,
+	0x30,
+	0x02,
+	0xe0,
+	0xff,
+	0x53,
+	0x07,
+	0x08,
+	0xbf,
+	0x08,
+	0x03,
+	0x02,
+	0xec,
+	0x15,
+	0x90,
+	0x69,
+	0xba,
+	0xe0,
+	0xff,
+	0x90,
+	0x30,
+	0x4b,
+	0xe0,
+	0xfe,
+	0xc3,
+	0x9f,
+	0x40,
+	0x47,
+	0x90,
+	0x69,
+	0xba,
+	0xe0,
+	0xff,
+	0x90,
+	0x30,
+	0x4b,
+	0xe0,
+	0xfe,
+	0xef,
+	0xb5,
+	0x06,
+	0x0e,
+	0x90,
+	0x69,
+	0xb9,
+	0xe0,
+	0xff,
+	0x90,
+	0x30,
+	0x4a,
+	0xe0,
+	0xfe,
+	0xc3,
+	0x9f,
+	0x40,
+	0x2b,
+	0x90,
+	0x69,
+	0xba,
+	0xe0,
+	0xff,
+	0x90,
+	0x30,
+	0x4b,
+	0xe0,
+	0xfe,
+	0xef,
+	0xb5,
+	0x06,
+	0x37,
+	0x90,
+	0x69,
+	0xb9,
+	0xe0,
+	0xff,
+	0x90,
+	0x30,
+	0x4a,
+	0xe0,
+	0xfe,
+	0xef,
+	0xb5,
+	0x06,
+	0x29,
+	0x90,
+	0x69,
+	0xb8,
+	0xe0,
+	0xff,
+	0x90,
+	0x30,
+	0x49,
+	0xe0,
+	0xfe,
+	0xc3,
+	0xef,
+	0x9e,
+	0x40,
+	0x1a,
+	0x90,
+	0x30,
+	0x02,
+	0xe0,
+	0xff,
+	0x53,
+	0x07,
+	0x20,
+	0xbf,
+	0x20,
+	0x04,
+	0x7f,
+	0x42,
+	0x80,
+	0x02,
+	0x7f,
+	0x00,
+	0x90,
+	0x30,
+	0x07,
+	0xef,
+	0xf0,
+	0xd2,
+	0xaa,
+	0x80,
+	0xfe,
+	0x90,
+	0x69,
+	0xba,
+	0xe0,
+	0xff,
+	0xbf,
+	0xff,
+	0x2a,
+	0x90,
+	0x69,
+	0xb9,
+	0xe0,
+	0xff,
+	0xbf,
+	0xff,
+	0x22,
+	0x90,
+	0x69,
+	0xb8,
+	0xe0,
+	0xff,
+	0xbf,
+	0xff,
+	0x1a,
+	0x90,
+	0x30,
+	0x02,
+	0xe0,
+	0xff,
+	0x53,
+	0x07,
+	0x20,
+	0xbf,
+	0x20,
+	0x04,
+	0x7f,
+	0x42,
+	0x80,
+	0x02,
+	0x7f,
+	0x00,
+	0x90,
+	0x30,
+	0x07,
+	0xef,
+	0xf0,
+	0xd2,
+	0xaa,
+	0x80,
+	0xfe,
+	0x12,
+	0xa8,
+	0xa3,
+	0x12,
+	0xa7,
+	0x9f,
+	0x12,
+	0xd7,
+	0x3b,
+	0x90,
+	0x30,
+	0x2b,
+	0x74,
+	0x01,
+	0xf0,
+	0x90,
+	0x30,
+	0x0f,
+	0x74,
+	0x80,
+	0xf0,
+	0xd2,
+	0xaa,
+	0x02,
+	0xe6,
+	0x25,
+	0x90,
+	0x30,
+	0x2a,
+	0xe0,
+	0xff,
+	0x20,
+	0xe1,
+	0x03,
+	0x02,
+	0xe6,
+	0x25,
+	0x90,
+	0x30,
+	0x23,
+	0xe0,
+	0x90,
+	0x30,
+	0x20,
+	0xf0,
+	0x90,
+	0x30,
+	0x24,
+	0xe0,
+	0x90,
+	0x30,
+	0x21,
+	0xf0,
+	0x90,
+	0x30,
+	0x25,
+	0xe0,
+	0xff,
+	0x90,
+	0x30,
+	0x22,
+	0x74,
+	0x0f,
+	0x5f,
+	0xf0,
+	0x90,
+	0x30,
+	0x46,
+	0xe0,
+	0xff,
+	0x90,
+	0x30,
+	0x4c,
+	0xe0,
+	0xfe,
+	0xef,
+	0xb5,
+	0x06,
+	0x37,
+	0x90,
+	0x30,
+	0x46,
+	0xe0,
+	0xff,
+	0xbf,
+	0xff,
+	0x22,
+	0x90,
+	0x30,
+	0x47,
+	0xe0,
+	0xff,
+	0xbf,
+	0xff,
+	0x0f,
+	0x90,
+	0x30,
+	0x48,
+	0xe0,
+	0x90,
+	0x30,
+	0x48,
+	0xe0,
+	0xff,
+	0x0f,
+	0x90,
+	0x30,
+	0x48,
+	0xef,
+	0xf0,
+	0x90,
+	0x30,
+	0x47,
+	0xe0,
+	0xff,
+	0x0f,
+	0x90,
+	0x30,
+	0x47,
+	0xef,
+	0xf0,
+	0x90,
+	0x30,
+	0x46,
+	0xe0,
+	0xff,
+	0x0f,
+	0x90,
+	0x30,
+	0x46,
+	0xef,
+	0xf0,
+	0x80,
+	0x19,
+	0x90,
+	0x30,
+	0x4e,
+	0xe0,
+	0x90,
+	0x30,
+	0x48,
+	0xf0,
+	0x90,
+	0x30,
+	0x4d,
+	0xe0,
+	0x90,
+	0x30,
+	0x47,
+	0xf0,
+	0x90,
+	0x30,
+	0x4c,
+	0xe0,
+	0xff,
+	0x90,
+	0x30,
+	0x46,
+	0xf0,
+	0x12,
+	0xd7,
+	0x8e,
+	0x02,
+	0xe6,
+	0x25,
+	0x12,
+	0xaf,
+	0x90,
+	0x02,
+	0xe6,
+	0x25,
+	0xad,
+	0x82,
+	0xae,
+	0x83,
+	0xaf,
+	0xf0,
+	0x90,
+	0x00,
+	0x08,
+	0xe0,
+	0xfb,
+	0xa3,
+	0xe0,
+	0xfc,
+	0x4b,
+	0x70,
+	0x24,
+	0x90,
+	0x00,
+	0x08,
+	0x74,
+	0xff,
+	0xf0,
+	0xa3,
+	0xf0,
+	0x90,
+	0x00,
+	0x0a,
+	0x74,
+	0xff,
+	0xf0,
+	0xa3,
+	0xf0,
+	0x90,
+	0x00,
+	0x06,
+	0x74,
+	0xf4,
+	0xf0,
+	0x90,
+	0x00,
+	0x04,
+	0x74,
+	0x01,
+	0xf0,
+	0x90,
+	0x00,
+	0x04,
+	0xe0,
+	0xfc,
+	0x20,
+	0xe0,
+	0xf8,
+	0x90,
+	0x00,
+	0x04,
+	0x74,
+	0x01,
+	0xf0,
+	0x90,
+	0x00,
+	0x04,
+	0xe0,
+	0xfc,
+	0x20,
+	0xe0,
+	0xf8,
+	0x90,
+	0x00,
+	0x00,
+	0xe0,
+	0xf9,
+	0xa3,
+	0xe0,
+	0xfa,
+	0xa3,
+	0xe0,
+	0xfb,
+	0xa3,
+	0xe0,
+	0xfc,
+	0x8d,
+	0x82,
+	0x8e,
+	0x83,
+	0x8f,
+	0xf0,
+	0xe9,
+	0x12,
+	0xf3,
+	0x29,
+	0xa3,
+	0xea,
+	0x12,
+	0xf3,
+	0x29,
+	0xa3,
+	0xeb,
+	0x12,
+	0xf3,
+	0x29,
+	0xa3,
+	0xec,
+	0x02,
+	0xf3,
+	0x29,
+	0xae,
+	0x82,
+	0x53,
+	0x06,
+	0x01,
+	0xe4,
+	0xce,
+	0x25,
+	0xe0,
+	0xce,
+	0x33,
+	0xce,
+	0x25,
+	0xe0,
+	0xce,
+	0x33,
+	0xff,
+	0x33,
+	0x95,
+	0xe0,
+	0xfd,
+	0xfc,
+	0x90,
+	0x00,
+	0x8c,
+	0xee,
+	0xf0,
+	0xa3,
+	0xef,
+	0xf0,
+	0xa3,
+	0xed,
+	0xf0,
+	0xa3,
+	0xec,
+	0xf0,
+	0x90,
+	0x00,
+	0x84,
+	0xe4,
+	0xf0,
+	0xa3,
+	0xf0,
+	0xa3,
+	0xf0,
+	0xa3,
+	0xf0,
+	0x22,
+	0xc0,
+	0x12,
+	0xe5,
+	0x81,
+	0xf5,
+	0x12,
+	0x24,
+	0x06,
+	0xf5,
+	0x81,
+	0xad,
+	0x82,
+	0xae,
+	0x83,
+	0xaf,
+	0xf0,
+	0xa8,
+	0x12,
+	0x08,
+	0xa6,
+	0x05,
+	0x08,
+	0xa6,
+	0x06,
+	0x08,
+	0xa6,
+	0x07,
+	0xe5,
+	0x12,
+	0x24,
+	0xfc,
+	0xf8,
+	0x86,
+	0x03,
+	0x08,
+	0x86,
+	0x04,
+	0xc3,
+	0xeb,
+	0x94,
+	0x04,
+	0xec,
+	0x64,
+	0x80,
+	0x94,
+	0x80,
+	0x50,
+	0x03,
+	0x02,
+	0xee,
+	0x31,
+	0x7a,
+	0x88,
+	0x7e,
+	0x00,
+	0x7f,
+	0x00,
+	0xa8,
+	0x12,
+	0x08,
+	0x86,
+	0x82,
+	0x08,
+	0x86,
+	0x83,
+	0x08,
+	0x86,
+	0xf0,
+	0x12,
+	0xf4,
+	0x15,
+	0xfd,
+	0xa3,
+	0x18,
+	0x18,
+	0xa6,
+	0x82,
+	0x08,
+	0xa6,
+	0x83,
+	0x8a,
+	0x82,
+	0x8e,
+	0x83,
+	0x8f,
+	0xf0,
+	0xed,
+	0x12,
+	0xf3,
+	0x29,
+	0xa3,
+	0xaa,
+	0x82,
+	0xae,
+	0x83,
+	0xa8,
+	0x12,
+	0x08,
+	0x86,
+	0x82,
+	0x08,
+	0x86,
+	0x83,
+	0x08,
+	0x86,
+	0xf0,
+	0x12,
+	0xf4,
+	0x15,
+	0xfd,
+	0xa3,
+	0x18,
+	0x18,
+	0xa6,
+	0x82,
+	0x08,
+	0xa6,
+	0x83,
+	0x8a,
+	0x82,
+	0x8e,
+	0x83,
+	0x8f,
+	0xf0,
+	0xed,
+	0x12,
+	0xf3,
+	0x29,
+	0xa3,
+	0xaa,
+	0x82,
+	0xae,
+	0x83,
+	0xa8,
+	0x12,
+	0x08,
+	0x86,
+	0x82,
+	0x08,
+	0x86,
+	0x83,
+	0x08,
+	0x86,
+	0xf0,
+	0x12,
+	0xf4,
+	0x15,
+	0xfd,
+	0xa3,
+	0x18,
+	0x18,
+	0xa6,
+	0x82,
+	0x08,
+	0xa6,
+	0x83,
+	0x8a,
+	0x82,
+	0x8e,
+	0x83,
+	0x8f,
+	0xf0,
+	0xed,
+	0x12,
+	0xf3,
+	0x29,
+	0xa3,
+	0xaa,
+	0x82,
+	0xae,
+	0x83,
+	0xa8,
+	0x12,
+	0x08,
+	0x86,
+	0x82,
+	0x08,
+	0x86,
+	0x83,
+	0x08,
+	0x86,
+	0xf0,
+	0x12,
+	0xf4,
+	0x15,
+	0xfd,
+	0xa3,
+	0x18,
+	0x18,
+	0xa6,
+	0x82,
+	0x08,
+	0xa6,
+	0x83,
+	0x8a,
+	0x82,
+	0x8e,
+	0x83,
+	0x8f,
+	0xf0,
+	0xed,
+	0x12,
+	0xf3,
+	0x29,
+	0xeb,
+	0x24,
+	0xfc,
+	0xfb,
+	0xec,
+	0x34,
+	0xff,
+	0xfc,
+	0x02,
+	0xed,
+	0x7f,
+	0x7d,
+	0x88,
+	0x7e,
+	0x00,
+	0x7f,
+	0x00,
+	0xa8,
+	0x12,
+	0x08,
+	0xe5,
+	0x12,
+	0x24,
+	0x04,
+	0xf9,
+	0xe6,
+	0xf7,
+	0x08,
+	0x09,
+	0xe6,
+	0xf7,
+	0x08,
+	0x09,
+	0xe6,
+	0xf7,
+	0xeb,
+	0x4c,
+	0x60,
+	0x2f,
+	0xe5,
+	0x12,
+	0x24,
+	0x04,
+	0xf8,
+	0x86,
+	0x82,
+	0x08,
+	0x86,
+	0x83,
+	0x08,
+	0x86,
+	0xf0,
+	0x12,
+	0xf4,
+	0x15,
+	0xfa,
+	0xa3,
+	0x18,
+	0x18,
+	0xa6,
+	0x82,
+	0x08,
+	0xa6,
+	0x83,
+	0x8d,
+	0x82,
+	0x8e,
+	0x83,
+	0x8f,
+	0xf0,
+	0xea,
+	0x12,
+	0xf3,
+	0x29,
+	0xa3,
+	0xad,
+	0x82,
+	0xae,
+	0x83,
+	0x1b,
+	0xbb,
+	0xff,
+	0x01,
+	0x1c,
+	0x80,
+	0xcd,
+	0x85,
+	0x12,
+	0x81,
+	0xd0,
+	0x12,
+	0x22,
+	0xc0,
+	0x12,
+	0xe5,
+	0x81,
+	0xf5,
+	0x12,
+	0x24,
+	0x04,
+	0xf5,
+	0x81,
+	0xae,
+	0x82,
+	0xaf,
+	0x83,
+	0x90,
+	0x00,
+	0x8c,
+	0xe0,
+	0xfa,
+	0xa3,
+	0xe0,
+	0xfb,
+	0xa3,
+	0xe0,
+	0xfc,
+	0xa3,
+	0xe0,
+	0xfd,
+	0xea,
+	0x20,
+	0xe0,
+	0xee,
+	0x90,
+	0x00,
+	0x60,
+	0xe4,
+	0xf0,
+	0xa3,
+	0xf0,
+	0xa3,
+	0xf0,
+	0xa3,
+	0xf0,
+	0xee,
+	0x4f,
+	0x60,
+	0x0a,
+	0x7c,
+	0x05,
+	0x7d,
+	0x00,
+	0x7e,
+	0x00,
+	0x7f,
+	0x00,
+	0x80,
+	0x08,
+	0x7c,
+	0x08,
+	0x7d,
+	0x00,
+	0x7e,
+	0x00,
+	0x7f,
+	0x00,
+	0xc0,
+	0x04,
+	0xc0,
+	0x05,
+	0xc0,
+	0x06,
+	0xc0,
+	0x07,
+	0x90,
+	0x00,
+	0x8c,
+	0xe0,
+	0xfa,
+	0xa3,
+	0xe0,
+	0xfb,
+	0xa3,
+	0xe0,
+	0xa3,
+	0xe0,
+	0xea,
+	0xd0,
+	0x07,
+	0xd0,
+	0x06,
+	0xd0,
+	0x05,
+	0xd0,
+	0x04,
+	0x20,
+	0xe0,
+	0xe0,
+	0xa8,
+	0x12,
+	0x08,
+	0xec,
+	0x2c,
+	0xf6,
+	0xed,
+	0x33,
+	0x08,
+	0xf6,
+	0xee,
+	0x33,
+	0x08,
+	0xf6,
+	0xef,
+	0x33,
+	0x08,
+	0xf6,
+	0x18,
+	0x18,
+	0x18,
+	0xe6,
+	0x25,
+	0xe0,
+	0xf6,
+	0x08,
+	0xe6,
+	0x33,
+	0xf6,
+	0x08,
+	0xe6,
+	0x33,
+	0xf6,
+	0x08,
+	0xe6,
+	0x33,
+	0xf6,
+	0xe5,
+	0x12,
+	0x24,
+	0xfb,
+	0xf8,
+	0x86,
+	0x02,
+	0x08,
+	0x86,
+	0x03,
+	0x08,
+	0x86,
+	0x07,
+	0xa8,
+	0x12,
+	0x08,
+	0xe6,
+	0xc0,
+	0xe0,
+	0x08,
+	0xe6,
+	0xc0,
+	0xe0,
+	0x08,
+	0xe6,
+	0xc0,
+	0xe0,
+	0x08,
+	0xe6,
+	0xc0,
+	0xe0,
+	0xc0,
+	0x02,
+	0xc0,
+	0x03,
+	0xc0,
+	0x07,
+	0x90,
+	0x00,
+	0x60,
+	0x75,
+	0xf0,
+	0x00,
+	0x12,
+	0xef,
+	0x75,
+	0xe5,
+	0x81,
+	0x24,
+	0xf9,
+	0xf5,
+	0x81,
+	0x85,
+	0x12,
+	0x81,
+	0xd0,
+	0x12,
+	0x22,
+	0xc0,
+	0x12,
+	0x85,
+	0x81,
+	0x12,
+	0x12,
+	0xed,
+	0x2a,
+	0xe5,
+	0x12,
+	0x24,
+	0xf7,
+	0xf8,
+	0x86,
+	0x06,
+	0x08,
+	0x86,
+	0x07,
+	0xe5,
+	0x12,
+	0x24,
+	0xfb,
+	0xf8,
+	0x86,
+	0x03,
+	0x08,
+	0x86,
+	0x04,
+	0x08,
+	0x86,
+	0x05,
+	0xc0,
+	0x06,
+	0xc0,
+	0x07,
+	0x8b,
+	0x82,
+	0x8c,
+	0x83,
+	0x8d,
+	0xf0,
+	0x12,
+	0xed,
+	0x5a,
+	0x15,
+	0x81,
+	0x15,
+	0x81,
+	0xd0,
+	0x12,
+	0x22,
+	0xc0,
+	0x12,
+	0x85,
+	0x81,
+	0x12,
+	0xc0,
+	0x82,
+	0xc0,
+	0x83,
+	0xc0,
+	0xf0,
+	0xe5,
+	0x81,
+	0x24,
+	0x0d,
+	0xf5,
+	0x81,
+	0xe5,
+	0x12,
+	0x24,
+	0xf7,
+	0xf8,
+	0xe5,
+	0x12,
+	0x24,
+	0x0d,
+	0xf9,
+	0xe6,
+	0xf7,
+	0x08,
+	0x09,
+	0xe6,
+	0xf7,
+	0x08,
+	0x09,
+	0xe6,
+	0xf7,
+	0x08,
+	0x09,
+	0xe6,
+	0xf7,
+	0xe5,
+	0x12,
+	0x24,
+	0x04,
+	0xf8,
+	0xe4,
+	0xf6,
+	0x08,
+	0xf6,
+	0xe5,
+	0x12,
+	0x24,
+	0x0d,
+	0xf8,
+	0xe6,
+	0x08,
+	0x46,
+	0x08,
+	0x46,
+	0x08,
+	0x46,
+	0x70,
+	0x03,
+	0x02,
+	0xf1,
+	0x27,
+	0xe5,
+	0x12,
+	0x24,
+	0x0d,
+	0xf8,
+	0xe6,
+	0x24,
+	0xfc,
+	0xf6,
+	0x08,
+	0xe6,
+	0x34,
+	0xff,
+	0xf6,
+	0x08,
+	0xe6,
+	0x34,
+	0xff,
+	0xf6,
+	0x08,
+	0xe6,
+	0x34,
+	0xff,
+	0xf6,
+	0xe5,
+	0x12,
+	0x24,
+	0x04,
+	0xf8,
+	0x86,
+	0x05,
+	0x08,
+	0xe6,
+	0xcd,
+	0x25,
+	0xe0,
+	0xcd,
+	0x33,
+	0xcd,
+	0x25,
+	0xe0,
+	0xcd,
+	0x33,
+	0xfe,
+	0xa8,
+	0x12,
+	0x08,
+	0xed,
+	0x26,
+	0xfd,
+	0xee,
+	0x08,
+	0x36,
+	0xfe,
+	0x08,
+	0x86,
+	0x07,
+	0x8d,
+	0x82,
+	0x8e,
+	0x83,
+	0x8f,
+	0xf0,
+	0xe5,
+	0x12,
+	0x24,
+	0x06,
+	0xf8,
+	0x12,
+	0xf4,
+	0x15,
+	0xf6,
+	0xa3,
+	0x12,
+	0xf4,
+	0x15,
+	0x08,
+	0xf6,
+	0xa3,
+	0x12,
+	0xf4,
+	0x15,
+	0x08,
+	0xf6,
+	0xa3,
+	0x12,
+	0xf4,
+	0x15,
+	0x08,
+	0xf6,
+	0xe5,
+	0x12,
+	0x24,
+	0x06,
+	0xff,
+	0xe5,
+	0x12,
+	0x24,
+	0x0a,
+	0xf8,
+	0xa6,
+	0x07,
+	0x08,
+	0x76,
+	0x00,
+	0x08,
+	0x76,
+	0x40,
+	0xe5,
+	0x12,
+	0x24,
+	0xfb,
+	0xf8,
+	0x86,
+	0x02,
+	0x08,
+	0x86,
+	0x03,
+	0x08,
+	0x86,
+	0x04,
+	0xe5,
+	0x12,
+	0x24,
+	0x0a,
+	0xf8,
+	0x74,
+	0x03,
+	0x26,
+	0xfd,
+	0xe4,
+	0x08,
+	0x36,
+	0xfe,
+	0x08,
+	0x86,
+	0x07,
+	0x8d,
+	0x82,
+	0x8e,
+	0x83,
+	0x8f,
+	0xf0,
+	0x12,
+	0xf4,
+	0x15,
+	0x8a,
+	0x82,
+	0x8b,
+	0x83,
+	0x8c,
+	0xf0,
+	0x12,
+	0xf3,
+	0x29,
+	0xe5,
+	0x12,
+	0x24,
+	0xfb,
+	0xf8,
+	0x74,
+	0x01,
+	0x2a,
+	0xf6,
+	0xe4,
+	0x3b,
+	0x08,
+	0xf6,
+	0x08,
+	0xa6,
+	0x04,
+	0xe5,
+	0x12,
+	0x24,
+	0xfb,
+	0xf8,
+	0x86,
+	0x05,
+	0x08,
+	0x86,
+	0x06,
+	0x08,
+	0x86,
+	0x07,
+	0xe5,
+	0x12,
+	0x24,
+	0x0a,
+	0xf8,
+	0x74,
+	0x02,
+	0x26,
+	0xfa,
+	0xe4,
+	0x08,
+	0x36,
+	0xfb,
+	0x08,
+	0x86,
+	0x04,
+	0x8a,
+	0x82,
+	0x8b,
+	0x83,
+	0x8c,
+	0xf0,
+	0x12,
+	0xf4,
+	0x15,
+	0x8d,
+	0x82,
+	0x8e,
+	0x83,
+	0x8f,
+	0xf0,
+	0x12,
+	0xf3,
+	0x29,
+	0xe5,
+	0x12,
+	0x24,
+	0xfb,
+	0xf8,
+	0x74,
+	0x01,
+	0x2d,
+	0xf6,
+	0xe4,
+	0x3e,
+	0x08,
+	0xf6,
+	0x08,
+	0xa6,
+	0x07,
+	0xe5,
+	0x12,
+	0x24,
+	0xfb,
+	0xf8,
+	0x86,
+	0x05,
+	0x08,
+	0x86,
+	0x06,
+	0x08,
+	0x86,
+	0x07,
+	0xe5,
+	0x12,
+	0x24,
+	0x0a,
+	0xf8,
+	0x74,
+	0x01,
+	0x26,
+	0xfa,
+	0xe4,
+	0x08,
+	0x36,
+	0xfb,
+	0x08,
+	0x86,
+	0x04,
+	0x8a,
+	0x82,
+	0x8b,
+	0x83,
+	0x8c,
+	0xf0,
+	0x12,
+	0xf4,
+	0x15,
+	0xfa,
+	0x8d,
+	0x82,
+	0x8e,
+	0x83,
+	0x8f,
+	0xf0,
+	0x12,
+	0xf3,
+	0x29,
+	0xe5,
+	0x12,
+	0x24,
+	0xfb,
+	0xf8,
+	0x74,
+	0x01,
+	0x2d,
+	0xf6,
+	0xe4,
+	0x3e,
+	0x08,
+	0xf6,
+	0x08,
+	0xa6,
+	0x07,
+	0xe5,
+	0x12,
+	0x24,
+	0xfb,
+	0xf8,
+	0x86,
+	0x05,
+	0x08,
+	0x86,
+	0x06,
+	0x08,
+	0x86,
+	0x07,
+	0xe5,
+	0x12,
+	0x24,
+	0x0a,
+	0xf8,
+	0x86,
+	0x82,
+	0x08,
+	0x86,
+	0x83,
+	0x08,
+	0x86,
+	0xf0,
+	0x12,
+	0xf4,
+	0x15,
+	0xfc,
+	0x8d,
+	0x82,
+	0x8e,
+	0x83,
+	0x8f,
+	0xf0,
+	0x12,
+	0xf3,
+	0x29,
+	0xe5,
+	0x12,
+	0x24,
+	0xfb,
+	0xf8,
+	0x74,
+	0x01,
+	0x2d,
+	0xf6,
+	0xe4,
+	0x3e,
+	0x08,
+	0xf6,
+	0x08,
+	0xa6,
+	0x07,
+	0xe5,
+	0x12,
+	0x24,
+	0x04,
+	0xf8,
+	0x06,
+	0xb6,
+	0x00,
+	0x02,
+	0x08,
+	0x06,
+	0x02,
+	0xef,
+	0xa7,
+	0x85,
+	0x12,
+	0x81,
+	0xd0,
+	0x12,
+	0x22,
+	0x90,
+	0x00,
+	0x01,
+	0x22,
+	0xc0,
+	0x12,
+	0x85,
+	0x81,
+	0x12,
+	0xc0,
+	0x82,
+	0xc0,
+	0x83,
+	0xc0,
+	0xf0,
+	0xe5,
+	0x81,
+	0x24,
+	0x08,
+	0xf5,
+	0x81,
+	0x7b,
+	0x00,
+	0x7c,
+	0x00,
+	0xa8,
+	0x12,
+	0x08,
+	0x86,
+	0x82,
+	0x08,
+	0x86,
+	0x83,
+	0x08,
+	0x86,
+	0xf0,
+	0xc0,
+	0x04,
+	0xc0,
+	0x03,
+	0x12,
+	0xf3,
+	0xfd,
+	0xaa,
+	0x82,
+	0xaf,
+	0x83,
+	0xd0,
+	0x03,
+	0xd0,
+	0x04,
+	0xe5,
+	0x12,
+	0x24,
+	0x04,
+	0xf8,
+	0xa6,
+	0x02,
+	0x08,
+	0xa6,
+	0x07,
+	0xe5,
+	0x12,
+	0x24,
+	0x04,
+	0xf8,
+	0xc3,
+	0x74,
+	0x03,
+	0x96,
+	0xe4,
+	0x08,
+	0x96,
+	0x40,
+	0x03,
+	0x02,
+	0xf2,
+	0xd6,
+	0xe5,
+	0x12,
+	0x24,
+	0x04,
+	0xf8,
+	0xe6,
+	0x24,
+	0xfd,
+	0xfa,
+	0x08,
+	0xe6,
+	0x34,
+	0xff,
+	0xfd,
+	0xe5,
+	0x12,
+	0x24,
+	0x06,
+	0xf8,
+	0xe4,
+	0xf6,
+	0x08,
+	0xf6,
+	0xe5,
+	0x12,
+	0x24,
+	0x06,
+	0xf8,
+	0x86,
+	0x06,
+	0x08,
+	0x86,
+	0x07,
+	0xc3,
+	0xee,
+	0x9a,
+	0xef,
+	0x9d,
+	0x40,
+	0x03,
+	0x02,
+	0xf2,
+	0xcc,
+	0xc0,
+	0x02,
+	0xc0,
+	0x05,
+	0xe5,
+	0x12,
+	0x24,
+	0x06,
+	0xf8,
+	0x74,
+	0x03,
+	0x26,
+	0xfe,
+	0xe4,
+	0x08,
+	0x36,
+	0xff,
+	0xa8,
+	0x12,
+	0x08,
+	0xee,
+	0x26,
+	0xfe,
+	0xef,
+	0x08,
+	0x36,
+	0xfd,
+	0x08,
+	0x86,
+	0x07,
+	0x8e,
+	0x82,
+	0x8d,
+	0x83,
+	0x8f,
+	0xf0,
+	0x12,
+	0xf4,
+	0x15,
+	0xfe,
+	0x33,
+	0x95,
+	0xe0,
+	0xe4,
+	0xe5,
+	0x12,
+	0x24,
+	0x08,
+	0xf8,
+	0x08,
+	0x08,
+	0x08,
+	0xa6,
+	0x06,
+	0x18,
+	0x18,
+	0x18,
+	0x76,
+	0x00,
+	0x08,
+	0x76,
+	0x00,
+	0x08,
+	0x76,
+	0x00,
+	0xe5,
+	0x12,
+	0x24,
+	0x06,
+	0xf8,
+	0x74,
+	0x02,
+	0x26,
+	0xfe,
+	0xe4,
+	0x08,
+	0x36,
+	0xff,
+	0xa8,
+	0x12,
+	0x08,
+	0xee,
+	0x26,
+	0xfe,
+	0xef,
+	0x08,
+	0x36,
+	0xff,
+	0x08,
+	0x86,
+	0x05,
+	0x8e,
+	0x82,
+	0x8f,
+	0x83,
+	0x8d,
+	0xf0,
+	0x12,
+	0xf4,
+	0x15,
+	0xfe,
+	0x33,
+	0x95,
+	0xe0,
+	0x7f,
+	0x00,
+	0x8f,
+	0x02,
+	0x8e,
+	0x05,
+	0xe4,
+	0xff,
+	0xfe,
+	0xe5,
+	0x12,
+	0x24,
+	0x08,
+	0xf8,
+	0xee,
+	0x46,
+	0xf6,
+	0xef,
+	0x08,
+	0x46,
+	0xf6,
+	0xed,
+	0x08,
+	0x46,
+	0xf6,
+	0xea,
+	0x08,
+	0x46,
+	0xf6,
+	0xe5,
+	0x12,
+	0x24,
+	0x06,
+	0xf8,
+	0x74,
+	0x01,
+	0x26,
+	0xfe,
+	0xe4,
+	0x08,
+	0x36,
+	0xff,
+	0xa8,
+	0x12,
+	0x08,
+	0xee,
+	0x26,
+	0xfe,
+	0xef,
+	0x08,
+	0x36,
+	0xff,
+	0x08,
+	0x86,
+	0x05,
+	0x8e,
+	0x82,
+	0x8f,
+	0x83,
+	0x8d,
+	0xf0,
+	0x12,
+	0xf4,
+	0x15,
+	0xfe,
+	0x33,
+	0x95,
+	0xe0,
+	0x7f,
+	0x00,
+	0x7d,
+	0x00,
+	0x8d,
+	0x02,
+	0x8f,
+	0x05,
+	0x8e,
+	0x07,
+	0x7e,
+	0x00,
+	0xe5,
+	0x12,
+	0x24,
+	0x08,
+	0xf8,
+	0xee,
+	0x46,
+	0xf6,
+	0xef,
+	0x08,
+	0x46,
+	0xf6,
+	0xed,
+	0x08,
+	0x46,
+	0xf6,
+	0xea,
+	0x08,
+	0x46,
+	0xf6,
+	0xa8,
+	0x12,
+	0x08,
+	0xe5,
+	0x12,
+	0x24,
+	0x06,
+	0xf9,
+	0xe7,
+	0x26,
+	0xfd,
+	0x09,
+	0xe7,
+	0x08,
+	0x36,
+	0xfe,
+	0x08,
+	0x86,
+	0x07,
+	0x8d,
+	0x82,
+	0x8e,
+	0x83,
+	0x8f,
+	0xf0,
+	0x12,
+	0xf4,
+	0x15,
+	0xfd,
+	0x33,
+	0x95,
+	0xe0,
+	0xe4,
+	0xff,
+	0xfe,
+	0xfa,
+	0xe5,
+	0x12,
+	0x24,
+	0x08,
+	0xf8,
+	0xe6,
+	0x42,
+	0x05,
+	0x08,
+	0xe6,
+	0x42,
+	0x07,
+	0x08,
+	0xe6,
+	0x42,
+	0x06,
+	0x08,
+	0xe6,
+	0x42,
+	0x02,
+	0x90,
+	0x74,
+	0x00,
+	0xed,
+	0xf0,
+	0xa3,
+	0xef,
+	0xf0,
+	0xa3,
+	0xee,
+	0xf0,
+	0xa3,
+	0xea,
+	0xf0,
+	0xe5,
+	0x12,
+	0x24,
+	0x06,
+	0xf8,
+	0x74,
+	0x04,
+	0x26,
+	0xf6,
+	0xe4,
+	0x08,
+	0x36,
+	0xf6,
+	0xd0,
+	0x05,
+	0xd0,
+	0x02,
+	0x02,
+	0xf1,
+	0x92,
+	0xe5,
+	0x12,
+	0x24,
+	0x06,
+	0xf8,
+	0x86,
+	0x03,
+	0x08,
+	0x86,
+	0x04,
+	0x8b,
+	0x06,
+	0x8c,
+	0x07,
+	0x8e,
+	0x04,
+	0x8f,
+	0x05,
+	0xe5,
+	0x12,
+	0x24,
+	0x04,
+	0xf8,
+	0xc3,
+	0xec,
+	0x96,
+	0xed,
+	0x08,
+	0x96,
+	0x50,
+	0x22,
+	0xa8,
+	0x12,
+	0x08,
+	0xee,
+	0x26,
+	0xfb,
+	0xef,
+	0x08,
+	0x36,
+	0xfc,
+	0x08,
+	0x86,
+	0x05,
+	0x8b,
+	0x82,
+	0x8c,
+	0x83,
+	0x8d,
+	0xf0,
+	0x12,
+	0xf4,
+	0x15,
+	0xfb,
+	0x90,
+	0x74,
+	0x00,
+	0xf0,
+	0x0e,
+	0xbe,
+	0x00,
+	0xd0,
+	0x0f,
+	0x80,
+	0xcd,
+	0x85,
+	0x12,
+	0x81,
+	0xd0,
+	0x12,
+	0x22,
+	0xac,
+	0x82,
+	0xad,
+	0x83,
+	0xae,
+	0xf0,
+	0xff,
+	0x90,
+	0x7c,
+	0x00,
+	0xec,
+	0xf0,
+	0xa3,
+	0xed,
+	0xf0,
+	0xa3,
+	0xee,
+	0xf0,
+	0xa3,
+	0xef,
+	0xf0,
+	0x22,
+	0x20,
+	0xf7,
+	0x10,
+	0x30,
+	0xf6,
+	0x11,
+	0x88,
+	0x83,
+	0xa8,
+	0x82,
+	0x20,
+	0xf5,
+	0x07,
+	0xf6,
+	0xa8,
+	0x83,
+	0x75,
+	0x83,
+	0x00,
+	0x22,
+	0xf2,
+	0x80,
+	0xf7,
+	0xf0,
+	0x22,
+	0xe5,
+	0x13,
+	0x45,
+	0x14,
+	0x60,
+	0x46,
+	0x7a,
+	0x01,
+	0xe5,
+	0x13,
+	0x25,
+	0xe0,
+	0xf5,
+	0x13,
+	0xe5,
+	0x14,
+	0x33,
+	0x40,
+	0x12,
+	0xf5,
+	0x14,
+	0xe5,
+	0x82,
+	0x95,
+	0x13,
+	0xe5,
+	0x83,
+	0x95,
+	0x14,
+	0x40,
+	0x03,
+	0x0a,
+	0x80,
+	0xe6,
+	0xc3,
+	0xe5,
+	0x14,
+	0x13,
+	0xf5,
+	0x14,
+	0xe5,
+	0x13,
+	0x13,
+	0xf5,
+	0x13,
+	0xc3,
+	0xe5,
+	0x82,
+	0x95,
+	0x13,
+	0xf5,
+	0xf0,
+	0xe5,
+	0x83,
+	0x95,
+	0x14,
+	0x40,
+	0x05,
+	0xf5,
+	0x83,
+	0x85,
+	0xf0,
+	0x82,
+	0xc3,
+	0xe5,
+	0x14,
+	0x13,
+	0xf5,
+	0x14,
+	0xe5,
+	0x13,
+	0x13,
+	0xf5,
+	0x13,
+	0xda,
+	0xe1,
+	0x22,
+	0xaa,
+	0xf0,
+	0xfb,
+	0xe5,
+	0x82,
+	0x85,
+	0x13,
+	0xf0,
+	0xa4,
+	0xfc,
+	0xad,
+	0xf0,
+	0xe5,
+	0x83,
+	0x85,
+	0x13,
+	0xf0,
+	0xa4,
+	0x2d,
+	0xfd,
+	0xe4,
+	0x35,
+	0xf0,
+	0xfe,
+	0xe5,
+	0x82,
+	0x85,
+	0x14,
+	0xf0,
+	0xa4,
+	0x2d,
+	0xfd,
+	0xe5,
+	0xf0,
+	0x3e,
+	0xfe,
+	0xe4,
+	0x33,
+	0xff,
+	0xea,
+	0x85,
+	0x13,
+	0xf0,
+	0xa4,
+	0x2e,
+	0xfe,
+	0xe5,
+	0xf0,
+	0x3f,
+	0xff,
+	0xe5,
+	0x83,
+	0x85,
+	0x14,
+	0xf0,
+	0xa4,
+	0x2e,
+	0xfe,
+	0xe5,
+	0xf0,
+	0x3f,
+	0xff,
+	0xe5,
+	0x82,
+	0x85,
+	0x15,
+	0xf0,
+	0xa4,
+	0x2e,
+	0xfe,
+	0xe5,
+	0xf0,
+	0x3f,
+	0xff,
+	0xeb,
+	0x85,
+	0x13,
+	0xf0,
+	0xa4,
+	0x2f,
+	0xff,
+	0xea,
+	0x85,
+	0x14,
+	0xf0,
+	0xa4,
+	0x2f,
+	0xff,
+	0xe5,
+	0x83,
+	0x85,
+	0x15,
+	0xf0,
+	0xa4,
+	0x2f,
+	0xff,
+	0xe5,
+	0x82,
+	0x85,
+	0x16,
+	0xf0,
+	0xa4,
+	0x2f,
+	0x8e,
+	0xf0,
+	0x8d,
+	0x83,
+	0x8c,
+	0x82,
+	0x22,
+	0xaa,
+	0x82,
+	0xab,
+	0x83,
+	0x12,
+	0xf4,
+	0x15,
+	0x60,
+	0x03,
+	0xa3,
+	0x80,
+	0xf8,
+	0xc3,
+	0xe5,
+	0x82,
+	0x9a,
+	0xf5,
+	0x82,
+	0xe5,
+	0x83,
+	0x9b,
+	0xf5,
+	0x83,
+	0x22,
+	0x20,
+	0xf7,
+	0x14,
+	0x30,
+	0xf6,
+	0x14,
+	0x88,
+	0x83,
+	0xa8,
+	0x82,
+	0x20,
+	0xf5,
+	0x07,
+	0xe6,
+	0xa8,
+	0x83,
+	0x75,
+	0x83,
+	0x00,
+	0x22,
+	0xe2,
+	0x80,
+	0xf7,
+	0xe4,
+	0x93,
+	0x22,
+	0xe0,
+	0x22,
+	0xc2,
+	0xd5,
+	0xe5,
+	0x83,
+	0x30,
+	0xe7,
+	0x0d,
+	0xd2,
+	0xd5,
+	0xe4,
+	0xc3,
+	0x95,
+	0x82,
+	0xf5,
+	0x82,
+	0xe4,
+	0x95,
+	0x83,
+	0xf5,
+	0x83,
+	0xe5,
+	0x14,
+	0x30,
+	0xe7,
+	0x0b,
+	0xe4,
+	0xc3,
+	0x95,
+	0x13,
+	0xf5,
+	0x13,
+	0xe4,
+	0x95,
+	0x14,
+	0xf5,
+	0x14,
+	0x12,
+	0xf3,
+	0x42,
+	0x30,
+	0xd5,
+	0x0b,
+	0xe4,
+	0xc3,
+	0x95,
+	0x82,
+	0xf5,
+	0x82,
+	0xe4,
+	0x95,
+	0x83,
+	0xf5,
+	0x83,
+	0x22,
+	0x30,
+	0x31,
+	0x30,
+	0x00,
+	0x60,
+	0x09,
+	0x06,
+	0x0d,
+	0x65,
+	0x01,
+	0x48,
+	0x86,
+	0x01,
+	0x02,
+	0x04,
+	0x03,
+	0x20,
+	0x04,
+	0x00,
+	0x05,
+	0xb0,
+	0xe9,
+	0xaa,
+	0x45,
+	0xf1,
+	0x29,
+	0xba,
+	0x0a,
+	0x1c,
+	0xbe,
+	0x17,
+	0x57,
+	0x28,
+	0xeb,
+	0x2b,
+	0x4e,
+	0x8f,
+	0xd0,
+	0xc0,
+	0x6a,
+	0xad,
+	0x79,
+	0x98,
+	0x0f,
+	0x8d,
+	0x43,
+	0x8d,
+	0x47,
+	0x04,
+	0xb8,
+	0x2b,
+	0xf4,
+	0x15,
+	0x21,
+	0x56,
+	0x19,
+	0x01,
+	0x40,
+	0x01,
+	0x3b,
+	0xd0,
+	0x91,
+	0x90,
+	0x62,
+	0x9e,
+	0x89,
+	0xc2,
+	0x27,
+	0x8e,
+	0xcf,
+	0xb6,
+	0xdb,
+	0xce,
+	0x3f,
+	0x72,
+	0x10,
+	0x50,
+	0x93,
+	0x8c,
+	0x23,
+	0x29,
+	0x83,
+	0x7b,
+	0x80,
+	0x64,
+	0xa7,
+	0x59,
+	0xe8,
+	0x61,
+	0x67,
+	0x4c,
+	0xbc,
+	0xd8,
+	0x58,
+	0xb8,
+	0xf1,
+	0xd4,
+	0xf8,
+	0x2c,
+	0x37,
+	0x98,
+	0x16,
+	0x26,
+	0x0e,
+	0x4e,
+	0xf9,
+	0x4e,
+	0xee,
+	0x24,
+	0xde,
+	0xcc,
+	0xd1,
+	0x4b,
+	0x4b,
+	0xc5,
+	0x06,
+	0x7a,
+	0xfb,
+	0x49,
+	0x65,
+	0xe6,
+	0xc0,
+	0x00,
+	0x83,
+	0x48,
+	0x1e,
+	0x8e,
+	0x42,
+	0x2a,
+	0x53,
+	0xa0,
+	0xf5,
+	0x37,
+	0x29,
+	0x2b,
+	0x5a,
+	0xf9,
+	0x73,
+	0xc5,
+	0x9a,
+	0xa1,
+	0xb5,
+	0xb5,
+	0x74,
+	0x7c,
+	0x06,
+	0xdc,
+	0x7b,
+	0x7c,
+	0xdc,
+	0x6c,
+	0x6e,
+	0x82,
+	0x6b,
+	0x49,
+	0x88,
+	0xd4,
+	0x1b,
+	0x25,
+	0xe0,
+	0xee,
+	0xd1,
+	0x79,
+	0xbd,
+	0x39,
+	0x85,
+	0xfa,
+	0x4f,
+	0x25,
+	0xec,
+	0x70,
+	0x19,
+	0x23,
+	0xc1,
+	0xb9,
+	0xa6,
+	0xd9,
+	0x7e,
+	0x3e,
+	0xda,
+	0x48,
+	0xa9,
+	0x58,
+	0xe3,
+	0x18,
+	0x14,
+	0x1e,
+	0x9f,
+	0x30,
+	0x7f,
+	0x4c,
+	0xa8,
+	0xae,
+	0x53,
+	0x22,
+	0x66,
+	0x2b,
+	0xbe,
+	0x24,
+	0xcb,
+	0x47,
+	0x66,
+	0xfc,
+	0x83,
+	0xcf,
+	0x5c,
+	0x2d,
+	0x1e,
+	0x3a,
+	0xab,
+	0xab,
+	0x06,
+	0xbe,
+	0x05,
+	0xaa,
+	0x1a,
+	0x9b,
+	0x2d,
+	0xb7,
+	0xa6,
+	0x54,
+	0xf3,
+	0x63,
+	0x2b,
+	0x97,
+	0xbf,
+	0x93,
+	0xbe,
+	0xc1,
+	0xaf,
+	0x21,
+	0x39,
+	0x49,
+	0x0c,
+	0xe9,
+	0x31,
+	0x90,
+	0xcc,
+	0xc2,
+	0xbb,
+	0x3c,
+	0x02,
+	0xc4,
+	0xe2,
+	0xbd,
+	0xbd,
+	0x2f,
+	0x84,
+	0x63,
+	0x9b,
+	0xd2,
+	0xdd,
+	0x78,
+	0x3e,
+	0x90,
+	0xc6,
+	0xc5,
+	0xac,
+	0x16,
+	0x77,
+	0x2e,
+	0x69,
+	0x6c,
+	0x77,
+	0xfd,
+	0xed,
+	0x8a,
+	0x4d,
+	0x6a,
+	0x8c,
+	0xa3,
+	0xa9,
+	0x25,
+	0x6c,
+	0x21,
+	0xfd,
+	0xb2,
+	0x94,
+	0x0c,
+	0x84,
+	0xaa,
+	0x07,
+	0x29,
+	0x26,
+	0x46,
+	0xf7,
+	0x9b,
+	0x3a,
+	0x19,
+	0x87,
+	0xe0,
+	0x9f,
+	0xeb,
+	0x30,
+	0xa8,
+	0xf5,
+	0x64,
+	0xeb,
+	0x07,
+	0xf1,
+	0xe9,
+	0xdb,
+	0xf9,
+	0xaf,
+	0x2c,
+	0x8b,
+	0x69,
+	0x7e,
+	0x2e,
+	0x67,
+	0x39,
+	0x3f,
+	0xf3,
+	0xa6,
+	0xe5,
+	0xcd,
+	0xda,
+	0x24,
+	0x9b,
+	0xa2,
+	0x78,
+	0x72,
+	0xf0,
+	0xa2,
+	0x27,
+	0xc3,
+	0xe0,
+	0x25,
+	0xb4,
+	0xa1,
+	0x04,
+	0x6a,
+	0x59,
+	0x80,
+	0x27,
+	0xb5,
+	0xda,
+	0xb4,
+	0xb4,
+	0x53,
+	0x97,
+	0x3b,
+	0x28,
+	0x99,
+	0xac,
+	0xf4,
+	0x96,
+	0x27,
+	0x0f,
+	0x7f,
+	0x30,
+	0x0c,
+	0x4a,
+	0xaf,
+	0xcb,
+	0x9e,
+	0xd8,
+	0x71,
+	0x28,
+	0x24,
+	0x3e,
+	0xbc,
+	0x35,
+	0x15,
+	0xbe,
+	0x13,
+	0xeb,
+	0xaf,
+	0x43,
+	0x01,
+	0xbd,
+	0x61,
+	0x24,
+	0x54,
+	0x34,
+	0x9f,
+	0x73,
+	0x3e,
+	0xb5,
+	0x10,
+	0x9f,
+	0xc9,
+	0xfc,
+	0x80,
+	0xe8,
+	0x4d,
+	0xe3,
+	0x32,
+	0x96,
+	0x8f,
+	0x88,
+	0x10,
+	0x23,
+	0x25,
+	0xf3,
+	0xd3,
+	0x3e,
+	0x6e,
+	0x6d,
+	0xbb,
+	0xdc,
+	0x29,
+	0x66,
+	0xeb,
+	0x5b,
+	0x53,
+	0x29,
+	0xcc,
+	0xab,
+	0xe8,
+	0x38,
+	0x15,
+	0xee,
+	0x76,
+	0x7b,
+	0x41,
+	0x50,
+	0xa6,
+	0x3b,
+	0x71,
+	0x23,
+	0x85,
+	0xfe,
+	0x66,
+	0xa7,
+	0x03,
+	0x3c,
+	0xc2,
+	0xb7,
+	0x5d,
+	0x8e,
+	0xee,
+	0xe1,
+	0x16,
+	0xcc,
+	0x06,
+	0xfb,
+	0x99,
+	0x17,
+	0x19,
+	0x61,
+	0x6e,
+	0x8f,
+	0xaa,
+	0x35,
+	0x88,
+	0x74,
+	0x4d,
+	0xcd,
+	0x14,
+	0xaa,
+	0x01,
+	0xab,
+	0x56,
+	0x00,
+	0xa5,
+	0xdd,
+	0xef,
+	0x13,
+	0xf4,
+	0xf5,
+	0x89,
+	0xdb,
+	0x7d,
+	0x49,
+	0x54,
+	0xbf,
+	0xe6,
+	0xd6,
+	0xd8,
+	0xc5,
+	0x81,
+	0x92,
+	0x33,
+	0xf3,
+	0x7e,
+	0xa7,
+	0x20,
+	0x45,
+	0x3c,
+	0x64,
+	0xfe,
+	0x50,
+	0xa1,
+	0x0a,
+	0xf6,
+	0x5f,
+	0x72,
+	0x6f,
+	0x05,
+	0xae,
+	0x94,
+	0x93,
+	0xf2,
+	0x07,
+	0x21,
+	0x31,
+	0xe7,
+	0xcf,
+	0xdc,
+	0x99,
+	0x8f,
+	0xf8,
+	0x91,
+	0x3a,
+	0xd5,
+	0x7e,
+	0x0d,
+	0x6e,
+	0x66,
+	0xa8,
+	0x7e,
+	0x76,
+	0x3b,
+	0x2d,
+	0x84,
+	0x08,
+	0xee,
+	0x97,
+	0x7e,
+	0xc6,
+	0xd3,
+	0xf1,
+	0xba,
+	0xc2,
+	0xc3,
+	0x5b,
+	0x8a,
+	0x83,
+	0x88,
+	0x90,
+	0x68,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff,
+	0xff
+};
+
+unsigned char mtk_hdmi_hdcp_log = 1;
+
+#define HDMI_HDCP_LOG(fmt, arg...) \
+	do {	if (mtk_hdmi_hdcp_log) { \
+		pr_info("[HDMI][HDCP] %s,%d "fmt, __func__, __LINE__, ##arg); \
+		} \
+	} while (0)
+
+#define HDMI_HDCP_FUNC()	\
+	do {	if (mtk_hdmi_hdcp_log) \
+		pr_info("[HDMI][HDCP] %s\n", __func__); \
+	} while (0)
+
+int hdcp_delay_time; //ms
+static inline void set_hdcp_delay_time(unsigned int delay_time)
+{
+	hdcp_delay_time = delay_time;
+}
+
+unsigned int get_hdcp_delay_time(void)
+{
+	return hdcp_delay_time;
+}
+
+bool fgIsHDCPCtrlTimeOut(enum HDCP_CTRL_STATE_T e_hdcp_state)
+{
+	if (hdcp_delay_time <= 0)
+		return true;
+	return false;
+}
+
+void hdcp_unmute_logo(void)
+{
+#ifdef CONFIG_OPTEE
+	HDMI_HDCP_LOG("boot unmute fast logo\n");
+	vCaHDMIWriteHdcpCtrl(0x88880000, 0xaaaa5555);
+	hdcp_unmute_logo_flag = 1;
+#endif
+}
+
+void hdcp_mute_log(void)
+{
+#ifdef CONFIG_OPTEE
+	HDMI_HDCP_LOG("boot mute fast logo\n");
+	vCaHDMIWriteHdcpCtrl(0x88880000, 0x5555aaaa);
+	hdcp_unmute_logo_flag = 0;
+#endif
+}
+
+void vCleanAuthFailInt(void)
+{
+	struct mtk_hdmi *hdmi = global_mtk_hdmi;
+
+	mtk_hdmi_write(hdmi, TOP_INT_CLR00, 0x00020000);
+	udelay(1);
+	mtk_hdmi_write(hdmi, TOP_INT_CLR00, 0x00000000);
+	HDMI_HDCP_LOG("0x14025c8c = 0x%08x\n",
+		mtk_hdmi_read(hdmi, HDCP2X_STATUS_0));
+	_bHdcpStatus = SV_FAIL;
+}
+
+void vHDMI2xClearINT(void)
+{
+	struct mtk_hdmi *hdmi = global_mtk_hdmi;
+
+	HDMI_HDCP_LOG("%s\n", __func__);
+
+	mtk_hdmi_write(hdmi, TOP_INT_CLR00, 0xfffffff0);
+	mtk_hdmi_write(hdmi, TOP_INT_CLR01, 0xffffffff);
+	udelay(1);
+	mtk_hdmi_write(hdmi, TOP_INT_CLR00, 0x0);
+	mtk_hdmi_write(hdmi, TOP_INT_CLR01, 0x0);
+}
+
+void vHalHDCP1x_Reset(void)
+{
+	struct mtk_hdmi *hdmi = global_mtk_hdmi;
+
+	/* Reset hdcp 1.x */
+#ifdef CONFIG_OPTEE
+	/* SOFT_HDCP_1P4_RST, SOFT_HDCP_1P4_RST); */
+	vCaHDMIWriteHDCPRST(SOFT_HDCP_1P4_RST, SOFT_HDCP_1P4_RST);
+	udelay(100);
+	/* SOFT_HDCP_1P4_NOR, SOFT_HDCP_1P4_RST); */
+	vCaHDMIWriteHDCPRST(SOFT_HDCP_1P4_NOR, SOFT_HDCP_1P4_RST);
+#endif
+
+	mtk_hdmi_mask(hdmi, HDCP1X_CTRL, 0, ANA_TOP);
+	mtk_hdmi_mask(hdmi, HDCP1X_CTRL, 0, HDCP1X_ENC_EN);
+}
+
+void vSetHDCPState(enum HDCP_CTRL_STATE_T e_state)
+{
+	struct mtk_hdmi *hdmi = global_mtk_hdmi;
+
+	hdmi->hdcp_ctrl_state = e_state;
+}
+
+
+void vHDCPEncryptState(unsigned int u1Success)
+{
+	//HDMI_HDCP_FUNC();
+
+	//HDMI_HDCP_LOG("u1SuccessState = %d\n", u1Success);
+
+	//hdmi_audio_signal_state(u1Success);
+}
+
+/*
+ * void vSendHdmiCmd(unsigned char u1icmd)
+ * {
+ *	HDMI_HDCP_FUNC();
+ *	hdmi_hdmiCmd = u1icmd;
+ * }
+ *
+ * void vClearHdmiCmd(void)
+ * {
+ *	HDMI_HDCP_FUNC();
+ *	hdmi_hdmiCmd = 0xff;
+ * }
+ */
+void vHDMIClearINT(void)
+{
+	struct mtk_hdmi *hdmi = global_mtk_hdmi;
+
+	HDMI_HDCP_FUNC();
+
+	mtk_hdmi_write(hdmi, TOP_INT_CLR00, 0xfffffff0);
+	mtk_hdmi_write(hdmi, TOP_INT_CLR01, 0xffffffff);
+	udelay(1);
+	mtk_hdmi_write(hdmi, TOP_INT_CLR00, 0x0);
+	mtk_hdmi_write(hdmi, TOP_INT_CLR01, 0x0);
+}
+
+void vHdcpDdcHwPoll(bool _bhw)
+{
+	struct mtk_hdmi *hdmi = global_mtk_hdmi;
+
+	if (_bhw == true)
+		mtk_hdmi_mask(hdmi, HDCP2X_POL_CTRL, 0, HDCP2X_DIS_POLL_EN);
+	else
+		mtk_hdmi_mask(hdmi, HDCP2X_POL_CTRL, HDCP2X_DIS_POLL_EN,
+		HDCP2X_DIS_POLL_EN);
+}
+
+void vHalHDCP2x_Reset(void)
+{
+	struct mtk_hdmi *hdmi = global_mtk_hdmi;
+	/* Reset hdcp 2.x */
+	HDMI_HDCP_LOG("0xc68=0x%x\n", mtk_hdmi_read(hdmi, HDCP2X_DDCM_STATUS));
+
+	if (mtk_hdmi_read(hdmi, HDCP2X_CTRL_0) &
+		HDCP2X_ENCRYPT_EN) {
+		mtk_hdmi_mask(hdmi, HDCP2X_CTRL_0, 0, HDCP2X_ENCRYPT_EN);
+		mdelay(50);
+	}
+
+	vHdcpDdcHwPoll(false);
+
+#ifdef CONFIG_OPTEE
+	/* SOFT_HDCP_RST, SOFT_HDCP_RST); */
+	vCaHDMIWriteHDCPRST(SOFT_HDCP_RST, SOFT_HDCP_RST);
+	/* SOFT_HDCP_CORE_RST, SOFT_HDCP_CORE_RST); */
+	vCaHDMIWriteHDCPRST(SOFT_HDCP_CORE_RST, SOFT_HDCP_CORE_RST);
+	udelay(1);
+	/* SOFT_HDCP_NOR, SOFT_HDCP_RST); */
+	vCaHDMIWriteHDCPRST(SOFT_HDCP_NOR, SOFT_HDCP_RST);
+	/* SOFT_HDCP_CORE_NOR, SOFT_HDCP_CORE_RST); */
+	vCaHDMIWriteHDCPRST(SOFT_HDCP_CORE_NOR, SOFT_HDCP_CORE_RST);
+#endif
+
+}
+
+void vHDCPReset(void)
+{
+	struct mtk_hdmi *hdmi = global_mtk_hdmi;
+	struct mtk_hdmi_ddc *ddc = hdmi_ddc_ctx_from_mtk_hdmi(hdmi);
+
+	HDMI_HDCP_LOG("%s\n", __func__);
+	if (hdmi->enable_hdcp == false)
+		return;
+	vHalHDCP1x_Reset();
+
+	hdmi_ddc_request(ddc, 3);
+	vHalHDCP2x_Reset();
+	hdmi_ddc_free(ddc, 3);
+
+	vSetHDCPState(HDCP_RECEIVER_NOT_READY);
+	//hdmi_audio_signal_state(0);
+	_bReCheckBstatusCount = 0;
+}
+
+void vHDCP14InitAuth(void)
+{
+	set_hdcp_delay_time(HDCP_WAIT_RES_CHG_OK_TIMEOUE);
+	vSetHDCPState(HDCP_WAIT_RES_CHG_OK);
+	_bReCheckBstatusCount = 0;
+}
+
+void vHDCPInitAuth(void)
+{
+	struct mtk_hdmi *hdmi = global_mtk_hdmi;
+
+	HDMI_HDCP_LOG("%s, 0xc68=0x%x, %lums\n", __func__,
+		      mtk_hdmi_read(hdmi, HDCP2X_DDCM_STATUS), jiffies);
+
+	vHDCPReset();
+	if (hdmi->hdcp_2x_support == true) {
+		{
+			if (hdmi->bin_is_loaded == false)
+				set_hdcp_delay_time(HDCP2x_WAIT_LOADBIN_TIMEOUE);
+			else
+				set_hdcp_delay_time(HDCP2x_WAIT_RES_CHG_OK_TIMEOUE);
+		}
+		vSetHDCPState(HDCP2x_WAIT_RES_CHG_OK);
+	} else {
+		vHDCP14InitAuth();
+	}
+}
+
+void vRepeaterOnOff(unsigned char fgIsRep)
+{
+	struct mtk_hdmi *hdmi = global_mtk_hdmi;
+
+	if (fgIsRep == true)
+		mtk_hdmi_mask(hdmi, 0xcd0, 1 << 5, 1 << 5);
+	else
+		mtk_hdmi_mask(hdmi, 0xcd0, 0 << 5, 1 << 5);
+}
+
+void vStopAn(void)
+{
+	struct mtk_hdmi *hdmi = global_mtk_hdmi;
+
+	mtk_hdmi_mask(hdmi, 0xcd0, 1 << 4, 1 << 4);
+}
+
+void vReadAn(unsigned char *AnValue)
+{
+	unsigned char bIndex;
+	struct mtk_hdmi *hdmi = global_mtk_hdmi;
+
+	AnValue[0] = mtk_hdmi_read(hdmi, 0xcc0) & 0xff;
+	AnValue[1] = (mtk_hdmi_read(hdmi, 0xcc0) & 0xff00) >> 8;
+	AnValue[2] = (mtk_hdmi_read(hdmi, 0xcc0) & 0xff0000) >> 16;
+	AnValue[3] = (mtk_hdmi_read(hdmi, 0xcc0) & 0xff000000) >> 24;
+	AnValue[4] = mtk_hdmi_read(hdmi, 0xcc4) & 0xff;
+	AnValue[5] = (mtk_hdmi_read(hdmi, 0xcc4) & 0xff00) >> 8;
+	AnValue[6] = (mtk_hdmi_read(hdmi, 0xcc4) & 0xff0000) >> 16;
+	AnValue[7] = (mtk_hdmi_read(hdmi, 0xcc4) & 0xff000000) >> 24;
+	for (bIndex = 0; bIndex < 8; bIndex++)
+		HDMI_HDCP_LOG("[1x]AnValue[%d] =0x%02x\n",
+		bIndex, AnValue[bIndex]);
+
+}
+
+void vSendAn(void)
+{
+	struct mtk_hdmi *hdmi = global_mtk_hdmi;
+	struct mtk_hdmi_ddc *ddc = hdmi_ddc_ctx_from_mtk_hdmi(hdmi);
+	unsigned char bHDCPBuf[HDCP_AN_COUNT];
+	/* Step 1: issue command to general a new An value */
+	/* (1) read the value first */
+	/* (2) set An control as stop to general a An first */
+	vStopAn();
+
+	/* Step 2: Read An from Transmitter */
+	vReadAn(bHDCPBuf);
+	/* Step 3: Send An to Receiver */
+	fgDDCDataWrite(ddc, RX_ID, RX_REG_HDCP_AN, HDCP_AN_COUNT, bHDCPBuf);
+
+}
+
+void vWriteBksvToTx(unsigned char *bBKsv)
+{
+	unsigned int temp;
+	struct mtk_hdmi *hdmi = global_mtk_hdmi;
+
+	HDMI_HDCP_LOG("bksv 0x%x; 0x%x; 0x%x; 0x%x; 0x%x\n",
+		bBKsv[0], bBKsv[1], bBKsv[2],
+		      bBKsv[3], bBKsv[4]);
+	temp = (((bBKsv[3]) & 0xff) << 24) +
+		(((bBKsv[2]) & 0xff) << 16) +
+	    (((bBKsv[1]) & 0xff) << 8) +
+	    (bBKsv[0] & 0xff);
+	mtk_hdmi_write(hdmi, 0xcb0, temp);
+	udelay(10);
+	mtk_hdmi_write(hdmi, 0xcb4, bBKsv[4]);
+
+	mtk_hdmi_mask(hdmi, 0xcd0, 1 << 0, 1 << 0);
+	udelay(100);
+	mtk_hdmi_mask(hdmi, 0xcd0, 0 << 0, 1 << 0);
+
+	HDMI_HDCP_LOG("[1x]bksv 0xcb0 =0x%08x\n",
+		mtk_hdmi_read(hdmi, 0xcb0));
+	HDMI_HDCP_LOG("[1x]bksv 0xcb4 =0x%08x\n",
+		mtk_hdmi_read(hdmi, 0xcb4));
+
+}
+
+bool fgIsRepeater(void)
+{
+	struct mtk_hdmi *hdmi = global_mtk_hdmi;
+
+	return (hdmi->donwstream_is_repeater == true);
+}
+
+#ifdef SRM_SUPPORT
+void vCompareSRM(void)
+{
+	unsigned int dwKsvInx = 0, dwVRLIndex = 0;
+	unsigned char *ptrSRM, bNomOfDevice = 0;
+	unsigned char bKSV_Sink_Index = 0, bIndex = 0, dwIndex = 0;
+
+	if (_rSRMInfo.bID != 0x80)
+		return;
+
+
+#ifdef SRM_DBG
+	{
+		HDMI_HDCP_LOG("[HDCP]SRM Count = %d ",
+			_rSRMInfo.dwVRLLenInDram);
+		HDMI_HDCP_LOG("[HDCP]Key=%x, %x, %x, %x, %x",
+			_bHdcp_Bksv[0], _bHdcp_Bksv[1],
+			_bHdcp_Bksv[2], _bHdcp_Bksv[3], _bHdcp_Bksv[4]);
+	}
+
+#endif
+#ifdef REVOKE_TEST
+	_bHdcp_Bksv[0] = 0x6b;
+	_bHdcp_Bksv[1] = 0x3b;
+	_bHdcp_Bksv[2] = 0x60;
+	_bHdcp_Bksv[3] = 0xa0;
+	_bHdcp_Bksv[4] = 0x54;
+#endif
+
+	vSetSharedInfo(SI_DVD_HDCP_REVOCATION_RESULT, REVOCATION_NOT_CHK);
+
+	dwVRLIndex = 0;
+	ptrSRM = &_bSRMBuff[8];
+while (_rSRMInfo.dwVRLLenInDram > dwVRLIndex) {
+	bNomOfDevice = *(ptrSRM + dwVRLIndex) & 0x7F;	/* 40*N */
+	dwVRLIndex++;
+	for (dwKsvInx = 0; dwKsvInx < bNomOfDevice; dwKsvInx++) {
+		for (dwIndex = 0; dwIndex < 5; dwIndex++) {
+			if (*(ptrSRM + dwVRLIndex +
+				(dwKsvInx * 5) + dwIndex) !=
+			    _bHdcp_Bksv[dwIndex])
+				break;
+		}
+
+		if (fgIsRepeater()) {
+			for (bKSV_Sink_Index = 0;
+			     bKSV_Sink_Index <
+				i4SharedInfo(SI_REPEATER_DEVICE_COUNT);
+			     bKSV_Sink_Index++) {
+				for (bIndex = 0; bIndex < 5; bIndex++) {
+					if ((((bKSV_Sink_Index + 1) * 5 -
+						bIndex - 1) < 192) &&
+						(*(ptrSRM + dwVRLIndex +
+						(dwKsvInx * 5) + bIndex) !=
+						bKsv_buff[(bKSV_Sink_Index + 1)
+						* 5 - bIndex - 1]))
+						break;
+				}
+				if (bIndex == 5)
+					break;
+			}
+		}
+
+		if ((dwIndex == 5) || (bIndex == 5)) {
+			vSetSharedInfo(SI_DVD_HDCP_REVOCATION_RESULT,
+			REVOCATION_IS_CHK | IS_REVOCATION_KEY);
+			break;
+		}
+		vSetSharedInfo(SI_DVD_HDCP_REVOCATION_RESULT,
+			       REVOCATION_IS_CHK | NOT_REVOCATION_KEY);
+	}
+	if ((dwIndex == 5) || (bIndex == 5))
+		break;
+	dwVRLIndex += bNomOfDevice * 5;
+}
+
+#ifdef SRM_DBG
+	{
+		HDMI_HDCP_LOG("[HDCP]Shared Info=%x",
+			i4SharedInfo(SI_DVD_HDCP_REVOCATION_RESULT));
+		if (i4SharedInfo(SI_DVD_HDCP_REVOCATION_RESULT) &
+			IS_REVOCATION_KEY)
+			HDMI_HDCP_LOG("[HDCP]Revoked Sink Key\n");
+	}
+#endif
+
+}
+#endif
+
+bool isKsvLegal(unsigned char ksv[HDCP_AKSV_COUNT])
+{
+	unsigned char i, bit_shift, one_cnt;
+
+	one_cnt = 0;
+	for (i = 0; i < HDCP_AKSV_COUNT; i++) {
+		for (bit_shift = 0; bit_shift < 8; bit_shift++)
+			if (ksv[i] & BIT(bit_shift))
+				one_cnt++;
+	}
+	if (one_cnt == 20)
+		return true;
+
+	HDMI_HDCP_LOG("[HDCP],err ksv is:0x%02x,0x%02x,0x%02x,0x%02x,0x%02x\n",
+		ksv[0], ksv[1], ksv[2], ksv[3], ksv[4]);
+	return false;
+
+}
+
+void vExchangeKSVs(void)
+{
+	struct mtk_hdmi *hdmi = global_mtk_hdmi;
+	struct mtk_hdmi_ddc *ddc = hdmi_ddc_ctx_from_mtk_hdmi(hdmi);
+
+	unsigned char bHDCPBuf[HDCP_AKSV_COUNT];
+#ifdef SRM_SUPPORT
+	unsigned char bIndx;
+#endif
+	/* Step 1: read Aksv from transmitter, and send to receiver */
+	HDMI_HDCP_LOG("HDMI_AKSV:0x%x 0x%x 0x%x 0x%x 0x%x\n",
+		HDMI_AKSV[0], HDMI_AKSV[1], HDMI_AKSV[2], HDMI_AKSV[3],
+		HDMI_AKSV[4]);
+
+	fgDDCDataWrite(ddc, RX_ID, RX_REG_HDCP_AKSV, HDCP_AKSV_COUNT,
+		HDMI_AKSV);
+
+	/* Step 4: read Bksv from receiver, and send to transmitter */
+	fgDDCDataRead(ddc, RX_ID, RX_REG_HDCP_BKSV, HDCP_BKSV_COUNT, bHDCPBuf);
+	HDMI_HDCP_LOG("bHDCPBuf 0x%x; 0x%x; 0x%x; 0x%x; 0x%x\n",
+		bHDCPBuf[0], bHDCPBuf[1],
+		      bHDCPBuf[2], bHDCPBuf[3], bHDCPBuf[4]);
+	vWriteBksvToTx(bHDCPBuf);
+	HDMI_HDCP_LOG("BSKV:0x%x 0x%x 0x%x 0x%x 0x%x\n",
+		bHDCPBuf[0], bHDCPBuf[1],
+		bHDCPBuf[2], bHDCPBuf[3], bHDCPBuf[4]);
+
+	for (bIndx = 0; bIndx < HDCP_AKSV_COUNT; bIndx++)
+		_bTxBKAV[bIndx] = bHDCPBuf[bIndx];
+
+#ifdef SRM_SUPPORT
+	for (bIndx = 0; bIndx < HDCP_AKSV_COUNT; bIndx++)
+		_bHdcp_Bksv[bIndx] = bHDCPBuf[HDCP_AKSV_COUNT - bIndx - 1];
+	/* _bHdcp_Bksv[bIndx] = bHDCPBuf[bIndx]; */
+
+	vCompareSRM();
+
+#endif
+
+}
+
+void vSendAKey(unsigned char *bAkey)
+{
+	unsigned int i;
+	struct mtk_hdmi *hdmi = global_mtk_hdmi;
+
+	for (i = 0; i < 280; i++) {
+		mtk_hdmi_write(hdmi, 0xcc8, *(bAkey + i));
+		udelay(10);
+	}
+}
+
+unsigned char bCheckHDCPRiStatus(void)
+{
+	struct mtk_hdmi *hdmi = global_mtk_hdmi;
+
+	HDMI_HDCP_FUNC();
+
+	if (mtk_hdmi_read(hdmi, 0xcf4) & (1 << 25))
+		return true;
+	else
+		return false;
+}
+
+bool fgCompareRi(void)
+{
+	unsigned char bTemp;
+	unsigned char bHDCPBuf[4];
+	struct mtk_hdmi *hdmi = global_mtk_hdmi;
+	struct mtk_hdmi_ddc *ddc = hdmi_ddc_ctx_from_mtk_hdmi(hdmi);
+
+	//HDMI_HDCP_FUNC();
+
+	bHDCPBuf[2] = mtk_hdmi_read(hdmi, 0xc78) & 0xff;
+	bHDCPBuf[3] = (mtk_hdmi_read(hdmi, 0xc78) >> 8) & 0xff;
+
+	/* Read R0'/ Ri' from Receiver */
+	fgDDCDataRead(ddc, RX_ID, RX_REG_RI, HDCP_RI_COUNT,
+				bHDCPBuf);
+
+	if (hdmi->hdcp_ctrl_state == HDCP_COMPARE_R0)
+		HDMI_HDCP_LOG(
+			"[HDCP1.x][R0]Rx_Ri=0x%x%x Tx_Ri=0x%x%x\n",
+			bHDCPBuf[0], bHDCPBuf[1], bHDCPBuf[2], bHDCPBuf[3]);
+/*	else
+ *		HDMI_HDCP_LOG(
+ *			"[HDCP1.x]Rx_Ri=0x%x%x Tx_Ri=0x%x%x\n",
+ *			bHDCPBuf[0], bHDCPBuf[1], bHDCPBuf[2], bHDCPBuf[3]);
+ */
+	/* compare R0 and R0' */
+	for (bTemp = 0; bTemp < HDCP_RI_COUNT; bTemp++) {
+		if (bHDCPBuf[bTemp] == bHDCPBuf[bTemp +
+			HDCP_RI_COUNT]) {
+			continue;
+		} else {	/* R0 != R0' */
+
+			break;
+		}
+	}
+
+	/* return the compare result */
+	if (bTemp == HDCP_RI_COUNT) {
+		_bHdcpStatus = SV_OK;
+		return true;
+	}
+	{
+		_bHdcpStatus = SV_FAIL;
+		HDMI_HDCP_LOG("[HDCP][1.x]Rx_Ri=0x%x%x Tx_Ri=0x%x%x\n",
+			bHDCPBuf[0], bHDCPBuf[1], bHDCPBuf[2], bHDCPBuf[3]);
+		return false;
+	}
+
+}
+
+void vEnableEncrpt(void)
+{
+	struct mtk_hdmi *hdmi = global_mtk_hdmi;
+
+	HDMI_HDCP_FUNC();
+
+	mtk_hdmi_mask(hdmi, 0xcd0, 1 << 6, 1 << 6);
+}
+
+void vHalWriteKsvListPort(unsigned char *prKsvData,
+			unsigned char bDevice_Count,
+			  unsigned char *prBstatus)
+{
+	unsigned char bIndex;
+	struct mtk_hdmi *hdmi = global_mtk_hdmi;
+
+	HDMI_HDCP_FUNC();
+
+	if ((bDevice_Count * 5) < KSV_BUFF_SIZE) {
+		mtk_hdmi_write(hdmi, 0xc1c, (*(prBstatus)) +
+			((*(prBstatus + 1)) << 8));
+		mtk_hdmi_mask(hdmi, 0xcd0, (1 << 3), (1 << 3));
+		HDMI_HDCP_LOG("[HDCP]0xc1c = 0x%08x\n",
+			mtk_hdmi_read(hdmi, 0xc1c));
+
+		for (bIndex = 0; bIndex < (bDevice_Count * 5);
+		bIndex++) {
+			HDMI_HDCP_LOG("[HDCP]0xcd4 =0x%08x\n",
+				(*(prKsvData + bIndex)) + (1 << 8));
+			mtk_hdmi_write(hdmi, 0xcd4,
+				(*(prKsvData + bIndex)) + (1 << 8));
+		}
+	}
+
+}
+
+void vHalWriteHashPort(unsigned char *prHashVBuff)
+{
+	unsigned char bIndex;
+	struct mtk_hdmi *hdmi = global_mtk_hdmi;
+
+	HDMI_HDCP_FUNC();
+
+	for (bIndex = 0; bIndex < 5; bIndex++) {
+		HDMI_HDCP_LOG("[HDCP]write v,0x%08x =0x%08x\n",
+			(0xce0 + bIndex * 4),
+			((*(prHashVBuff + 3 + bIndex * 4)) << 24) +
+			((*(prHashVBuff + 2 + bIndex * 4)) << 16) +
+			((*(prHashVBuff + 1 + bIndex * 4)) << 8) +
+			(*(prHashVBuff + 0 + bIndex * 4)));
+
+	}
+
+	mtk_hdmi_write(hdmi, 0xce0,
+		((*(prHashVBuff + 3)) << 24) +
+		((*(prHashVBuff + 2)) << 16) +
+		((*(prHashVBuff + 1)) << 8) +
+		(*(prHashVBuff + 0)));
+
+	mtk_hdmi_write(hdmi, 0xce4,
+		((*(prHashVBuff + 7)) << 24) +
+		((*(prHashVBuff + 6)) << 16) +
+		((*(prHashVBuff + 5)) << 8) +
+		(*(prHashVBuff + 4)));
+
+	mtk_hdmi_write(hdmi, 0xce8,
+		((*(prHashVBuff + 11)) << 24) +
+		((*(prHashVBuff + 10)) << 16) +
+		((*(prHashVBuff + 9)) << 8) +
+		(*(prHashVBuff + 8)));
+
+	mtk_hdmi_write(hdmi, 0xcec,
+		((*(prHashVBuff + 15)) << 24) +
+		((*(prHashVBuff + 14)) << 16) +
+		((*(prHashVBuff + 13)) << 8) +
+		(*(prHashVBuff + 12)));
+
+	mtk_hdmi_write(hdmi, 0xcf0,
+		((*(prHashVBuff + 19)) << 24) +
+		((*(prHashVBuff + 18)) << 16) +
+		((*(prHashVBuff + 17)) << 8) +
+		(*(prHashVBuff + 16)));
+
+	for (bIndex = 0; bIndex < 5; bIndex++) {
+		HDMI_HDCP_LOG("[HDCP]read v,0x%08x =0x%08x\n",
+			(0xce0 + bIndex * 4), mtk_hdmi_read(hdmi, 0xce0 + bIndex * 4));
+
+	}
+}
+
+void vReadKSVFIFO(void)
+{
+	unsigned char bTemp, bIndex, bDevice_Count;
+	unsigned char bStatus[2], bBstatus1;
+	unsigned int u2TxBStatus;
+	struct mtk_hdmi *hdmi = global_mtk_hdmi;
+	struct mtk_hdmi_ddc *ddc = hdmi_ddc_ctx_from_mtk_hdmi(hdmi);
+
+	HDMI_HDCP_FUNC();
+
+	fgDDCDataRead(ddc, RX_ID, RX_REG_BSTATUS1 + 1, 1, &bBstatus1);
+	fgDDCDataRead(ddc, RX_ID, RX_REG_BSTATUS1, 1, &bDevice_Count);
+	_u2TxBStatus = (((unsigned int)bBstatus1) << 8) | bDevice_Count;
+
+	bDevice_Count &= DEVICE_COUNT_MASK;
+
+	if ((bDevice_Count & MAX_DEVS_EXCEEDED) ||
+		(bBstatus1 & MAX_CASCADE_EXCEEDED)) {
+
+		fgDDCDataRead(ddc, RX_ID, RX_REG_BSTATUS1, 2, bStatus);
+		fgDDCDataRead(ddc, RX_ID, RX_REG_BSTATUS1, 1, &bDevice_Count);
+		bDevice_Count &= DEVICE_COUNT_MASK;
+		u2TxBStatus = bStatus[0] | (bStatus[1] << 8);
+		vSetSharedInfo(SI_REPEATER_DEVICE_COUNT, bDevice_Count);
+		if (i4SharedInfo(SI_REPEATER_DEVICE_COUNT) == 0)
+			_bDevice_Count = 0;
+		else
+			_bDevice_Count = bDevice_Count;
+
+		_u2TxBStatus = u2TxBStatus;
+		vSetHDCPState(HDCP_RE_DO_AUTHENTICATION);
+		//vSendHdmiCmd(HDMI_HDCP_PROTOCAL_CMD);
+		_bHdcpStatus = SV_FAIL;
+		return;
+	}
+
+	if (bDevice_Count > 32) {
+		for (bTemp = 0; bTemp < 2; bTemp++) {
+			fgDDCDataRead(ddc, RX_ID, RX_REG_BSTATUS1, 1,
+				&bDevice_Count);
+			bDevice_Count &= DEVICE_COUNT_MASK;
+			if (bDevice_Count <= 32)
+				break;
+		}
+		if (bTemp == 2)
+			bDevice_Count = 32;
+	}
+
+	vSetSharedInfo(SI_REPEATER_DEVICE_COUNT, bDevice_Count);
+
+	if (bDevice_Count == 0) {
+		for (bIndex = 0; bIndex < 5; bIndex++)
+			bKsv_buff[bIndex] = 0;
+
+		for (bIndex = 0; bIndex < 2; bIndex++)
+			bStatus[bIndex] = 0;
+
+		for (bIndex = 0; bIndex < 20; bIndex++)
+			bSHABuff[bIndex] = 0;
+
+		mtk_hdmi_mask(hdmi, 0xcd0, (1 << 11), (1 << 11));
+	} else {
+		fgDDCDataRead(ddc, RX_ID, RX_REG_KSV_FIFO, bDevice_Count * 5,
+			bKsv_buff);
+		mtk_hdmi_mask(hdmi, 0xcd0, (0 << 11), (1 << 11));
+	}
+
+	HDMI_HDCP_LOG("[1x]bDevice_Count = %d\n", bDevice_Count);
+
+	fgDDCDataRead(ddc, RX_ID, RX_REG_BSTATUS1, 2, bStatus);
+	fgDDCDataRead(ddc, RX_ID, RX_REG_REPEATER_V, 20, bSHABuff);
+
+	u2TxBStatus = bStatus[0] | (bStatus[1] << 8);
+	HDMI_HDCP_LOG(
+	"[1x]TX BSTATUS: bStatus[0]=%x, bStatus[1]=%x, u2TxBStatus=%x\n",
+		   bStatus[0], bStatus[1], u2TxBStatus);
+
+
+#ifdef SRM_SUPPORT
+	vCompareSRM();
+#endif
+
+	vHalWriteKsvListPort(bKsv_buff, bDevice_Count, bStatus);
+	vHalWriteHashPort(bSHABuff);
+
+	vSetHDCPState(HDCP_COMPARE_V);
+	/* set time-out value as 0.5 sec */
+	set_hdcp_delay_time(HDCP_WAIT_V_RDY_TIMEOUE);
+
+	for (bIndex = 0; bIndex < bDevice_Count; bIndex++) {
+		if ((bIndex * 5 + 4) < KSV_BUFF_SIZE) {
+			HDMI_HDCP_LOG("[HDCP1.x] KSV List: Device[%d]= %x,%x,%x,%x,%x\n",
+				bIndex, bKsv_buff[bIndex * 5], bKsv_buff[bIndex * 5 + 1],
+				bKsv_buff[bIndex * 5 + 2], bKsv_buff[bIndex * 5 + 3],
+				bKsv_buff[bIndex * 5 + 4]);
+		}
+	}
+	HDMI_HDCP_LOG("[HDCP][1.x]Tx BKSV: %x, %x, %x, %x, %x\n",
+		_bTxBKAV[0], _bTxBKAV[1], _bTxBKAV[2],
+		_bTxBKAV[3], _bTxBKAV[4]);
+
+	if (i4SharedInfo(SI_REPEATER_DEVICE_COUNT) == 0)
+		_bDevice_Count = 0;
+	else
+		_bDevice_Count = bDevice_Count;
+
+	_u2TxBStatus = u2TxBStatus;
+
+	HDMI_HDCP_LOG("[1x]_bDevice_Count = %x, _u2TxBStatus = %x\n",
+		_bDevice_Count, _u2TxBStatus);
+
+}
+
+unsigned int uiReadHDCPStatus(void)
+{
+	struct mtk_hdmi *hdmi = global_mtk_hdmi;
+
+	HDMI_HDCP_LOG("[1x]0xcf4 = 0x%08x\n", mtk_hdmi_read(hdmi, 0xcf4));
+	return mtk_hdmi_read(hdmi, 0xcf4);
+}
+
+unsigned int uiReadIRQStatus01(void)
+{
+	struct mtk_hdmi *hdmi = global_mtk_hdmi;
+
+	HDMI_HDCP_LOG("[1x]0x1ac = 0x%08x\n", mtk_hdmi_read(hdmi, 0x1ac));
+	HDMI_HDCP_LOG("[1x]0x1bc = 0x%08x\n", mtk_hdmi_read(hdmi, 0x1bc));
+
+	return mtk_hdmi_read(hdmi, 0x1ac);
+}
+
+void vWriteAksvKeyMask(unsigned char *PrData)
+{
+	unsigned char bData;
+	/* - write wIdx into 92. */
+	struct mtk_hdmi *hdmi = global_mtk_hdmi;
+
+	bData = 0x00;
+	mtk_hdmi_mask(hdmi, 0xccc, (bData << 24), 0xff << 24);
+	bData = 0x00;
+	mtk_hdmi_mask(hdmi, 0xccc, (bData << 16), 0xff << 16);
+}
+
+void vAKeyDone(void)
+{
+	struct mtk_hdmi *hdmi = global_mtk_hdmi;
+
+	HDMI_HDCP_FUNC();
+
+	mtk_hdmi_mask(hdmi, 0xcd0, 1 << 2, 1 << 2);
+	udelay(100);
+	mtk_hdmi_mask(hdmi, 0xcd0, 0 << 0, 1 << 2);
+
+}
+
+unsigned int bHDMIHDCP2Err(void)
+{
+	struct mtk_hdmi *hdmi = global_mtk_hdmi;
+
+	return (mtk_hdmi_read(hdmi, HDCP2X_STATUS_0) &
+		HDCP2X_STATE) >> 16;
+}
+
+bool fgHDMIHdcp2Err(void)
+{
+	unsigned int hdcp2_txstate;
+
+	hdcp2_txstate = bHDMIHDCP2Err();
+	if ((hdcp2_txstate == 0x30)
+	    || (hdcp2_txstate == 0x31)
+	    || (hdcp2_txstate == 0x32)
+	    || (hdcp2_txstate == 0x33)
+	    || (hdcp2_txstate == 0x34)
+	    || (hdcp2_txstate == 0x35)
+	    || (hdcp2_txstate == 0x36)
+	    || (hdcp2_txstate == 0x37)
+	    || (hdcp2_txstate == 0x38)
+	    || (hdcp2_txstate == 0x39)
+	    || (hdcp2_txstate == 0x3a)
+	    || (hdcp2_txstate == 0x3b)
+	    || (hdcp2_txstate == 0x3c)
+	    || (hdcp2_txstate == 0x3d)
+	    || (hdcp2_txstate == 0x3e))
+		return true;
+	return false;
+}
+
+bool fgHDMIHdcp2Auth(void)
+{
+	unsigned int hdcp2_txstate;
+
+	hdcp2_txstate = bHDMIHDCP2Err();
+	if ((hdcp2_txstate == 3)
+	    || (hdcp2_txstate == 4)
+	    || (hdcp2_txstate == 11)
+	    || (hdcp2_txstate == 14)
+	    || (hdcp2_txstate == 16)
+	    || (hdcp2_txstate == 18)
+	    || (hdcp2_txstate == 41)
+	    || (hdcp2_txstate == 24))
+		return true;
+	return false;
+}
+
+unsigned char u1CountNum1(unsigned char u1Data)
+{
+	unsigned char i, bCount = 0;
+
+	for (i = 0; i < 8; i++) {
+		if (((u1Data >> i) & 0x01) == 0x01)
+			bCount++;
+	}
+	return bCount;
+}
+
+void hdcp_service(enum HDCP_CTRL_STATE_T e_hdcp_state)
+{
+	unsigned char bIndx, bTemp, BStatus[2] = {0};
+	unsigned char bRptID[155];
+	unsigned int readvalue, i, devicecnt;
+	unsigned int uitemp1, uitemp2, depth, count1;
+	bool fgRepeaterError = false;
+	unsigned char ta_status[2];
+	bool ret;
+	struct mtk_hdmi *hdmi = global_mtk_hdmi;
+	struct mtk_hdmi_ddc *ddc = hdmi_ddc_ctx_from_mtk_hdmi(hdmi);
+
+	if (hdmi->enable_hdcp == false) {
+		HDMI_HDCP_LOG("hdmi->enable_hdcp==false\n");
+		vSetHDCPState(HDCP_RECEIVER_NOT_READY);
+		mtk_hdmi_AV_unmute(hdmi);
+		//hdmi_hdcp22_monitor_stop();
+		return;
+	}
+
+	if (hdmi->key_is_installed == false) {
+		ret = fgCaHDMIGetAKsv(u1CaHdcpAKsv);
+		if (ret == true)
+			hdmi->key_is_installed = true;
+	}
+
+	switch (e_hdcp_state) {
+	case HDCP_RECEIVER_NOT_READY:
+		HDMI_HDCP_LOG("HDCP_RECEIVER_NOT_READY\n");
+		break;
+
+	case HDCP_READ_EDID:
+		break;
+
+	case HDCP_WAIT_RES_CHG_OK:
+		if (fgIsHDCPCtrlTimeOut(e_hdcp_state)) {
+			if (hdmi->enable_hdcp == false) {	/* disable HDCP */
+				vSetHDCPState(HDCP_RECEIVER_NOT_READY);
+				mtk_hdmi_AV_unmute(hdmi);
+				//vSendHdmiCmd(HDMI_HDCP_PROTOCAL_CMD);
+			} else {
+				vSetHDCPState(HDCP_RE_DO_AUTHENTICATION);
+				//vSendHdmiCmd(HDMI_HDCP_PROTOCAL_CMD);
+				//_bLastHdcpStatus = HDCP_RECEIVER_NOT_READY;
+			}
+		}
+		break;
+
+	case HDCP_INIT_AUTHENTICATION:
+#ifdef CONFIG_OPTEE
+		/* HDCP_1P4_TCLK_EN, HDCP_1P4_TCLK_EN); */
+		vCaHDMIWriteHDCPRST(HDCP_1P4_TCLK_EN, HDCP_1P4_TCLK_EN);
+#endif
+
+		if (hdmi->repeater_hdcp == true) {
+			if ((hdmirxhandle != NULL) &&
+			(hdmirxhandle->hdcp_is_doing_auth != NULL) &&
+			(hdmirxhandle->hdcp_is_rpt != NULL) &&
+			(!(hdmirxhandle->hdcp_is_doing_auth(hdmirxdev)) &&
+			hdmirxhandle->hdcp_is_rpt(hdmirxdev))) {
+				vSetHDCPState(HDCP_RECEIVER_NOT_READY);
+				mtk_hdmi_AV_unmute(hdmi);
+				HDMI_HDCP_LOG(
+				"[1.x][REPEATER]upstream no need auth\n");
+				break;
+			}
+
+			if (hdmi->hpd != HDMI_PLUG_IN_AND_SINK_POWER_ON) {
+				vSetHDCPState(HDCP_RECEIVER_NOT_READY);
+				HDMI_HDCP_LOG("[1.x][REPEATER] hpd low\n");
+				break;
+			}
+		}
+		mtk_hdmi_AV_mute(hdmi);
+		vSetSharedInfo(SI_HDMI_HDCP_RESULT, 0);
+
+		hdmi_ddc_request(ddc, 5);
+		hdmi_ddc_free(ddc, 5);
+
+		if (!fgDDCDataRead(ddc, RX_ID, RX_REG_BCAPS, 1,
+			&bTemp)) {
+			HDMI_HDCP_LOG(
+			"[1.x]fail-->HDCP_INIT_AUTHENTICATION-->0\n");
+			_bHdcpStatus = SV_FAIL;
+			vHDCPEncryptState(0); /* for audio notify */
+			set_hdcp_delay_time(HDCP_WAIT_300MS_TIMEOUT);
+			break;
+		}
+		if (!(hdmi->dvi_mode)) {
+			fgDDCDataRead(ddc, RX_ID, RX_REG_BSTATUS1, 2, BStatus);
+			if ((BStatus[1] & 0x10) == 0) {
+				HDMI_HDCP_LOG("[1x]BStatus=0x%x,0x%x\n",
+					BStatus[0], BStatus[1]);
+				_bReCheckBstatusCount++;
+	/* wait for upto 4.5 seconds to detect otherwise proceed anyway */
+				if (_bReCheckBstatusCount < 15) {
+					_bHdcpStatus = SV_FAIL;
+					vHDCPEncryptState(0);
+					set_hdcp_delay_time(
+						HDCP_WAIT_300MS_TIMEOUT);
+					break;
+				}
+			}
+		}
+
+		HDMI_HDCP_LOG("[1x]RX_REG_BCAPS = 0x%08x\n", bTemp);
+		for (bIndx = 0; bIndx < HDCP_AKSV_COUNT; bIndx++) {
+#ifdef CONFIG_OPTEE
+			HDMI_AKSV[bIndx] = u1CaHdcpAKsv[bIndx];
+#else
+			HDMI_AKSV[bIndx] = bHdcpKeyBuff[1 + bIndx];
+#endif
+			HDMI_HDCP_LOG("[1x]HDMI_AKSV[%d] = 0x%x\n",
+			bIndx,
+				   HDMI_AKSV[bIndx]);
+		}
+
+#ifndef NO_ENCRYPT_KEY_TEST
+		vWriteAksvKeyMask(&HDMI_AKSV[0]);
+#endif
+
+		fgDDCDataRead(ddc, RX_ID, RX_REG_BCAPS, 1, &bTemp);
+		vSetSharedInfo(SI_REPEATER_DEVICE_COUNT, 0);
+		if (bTemp & RX_BIT_ADDR_RPTR)
+			hdmi->donwstream_is_repeater = true;
+		else
+			hdmi->donwstream_is_repeater = false;
+
+		if (fgIsRepeater())
+			vRepeaterOnOff(true);
+		else
+			vRepeaterOnOff(false);
+
+		vSendAn();
+		vExchangeKSVs();
+		if ((!isKsvLegal(HDMI_AKSV)) ||
+			(!isKsvLegal(_bTxBKAV))) {
+			HDMI_HDCP_LOG(
+		"[1x]fail-->HDCP_INIT_AUTHENTICATION-->isKsvLegal\n");
+			mtk_hdmi_AV_mute(hdmi);
+			vSetHDCPState(HDCP_RE_DO_AUTHENTICATION);
+			_bHdcpStatus = SV_FAIL;
+			set_hdcp_delay_time(HDCP_WAIT_300MS_TIMEOUT);
+			break;
+		}
+
+#ifdef SRM_SUPPORT
+		if (((hdmi->repeater_hdcp == true) && ((hdmirxhandle != NULL) &&
+			(hdmirxhandle->hdcp_is_rpt != NULL) &&
+			(!(hdmirxhandle->hdcp_is_rpt(hdmirxdev)) &&
+			((i4SharedInfo(SI_DVD_HDCP_REVOCATION_RESULT) &
+			IS_REVOCATION_KEY) && (_rSRMInfo.bID == 0x80))))) ||
+			((hdmi->repeater_hdcp == false) &&
+			((i4SharedInfo(SI_DVD_HDCP_REVOCATION_RESULT) &
+			IS_REVOCATION_KEY) && (_rSRMInfo.bID == 0x80)))) {
+			HDMI_HDCP_LOG(
+			"[1x]fail-->HDCP_INIT_AUTHENTICATION-->1\n");
+			mtk_hdmi_AV_mute(hdmi);
+			vSetHDCPState(HDCP_RE_DO_AUTHENTICATION);
+			_bHdcpStatus = SV_FAIL;
+			set_hdcp_delay_time(HDCP_WAIT_300MS_TIMEOUT);
+			break;
+
+		}
+#endif
+#ifdef CONFIG_OPTEE
+		fgCaHDMILoadHDCPKey();
+#else
+		vSendAKey(&bHdcpKeyBuff[6]);	/* around 190msec */
+#endif
+
+		/* set time-out value as 100 ms */
+		set_hdcp_delay_time(HDCP_WAIT_R0_TIMEOUT);
+		vAKeyDone();
+
+		/* change state as waiting R0 */
+		vSetHDCPState(HDCP_WAIT_R0);
+
+		break;
+
+
+	case HDCP_WAIT_R0:
+		bTemp = bCheckHDCPRiStatus();
+		if (bTemp == true) {
+			vSetHDCPState(HDCP_COMPARE_R0);
+		} else {
+			vSetHDCPState(HDCP_RE_DO_AUTHENTICATION);
+			//vSendHdmiCmd(HDMI_HDCP_PROTOCAL_CMD);
+			_bHdcpStatus = SV_FAIL;
+			vHDCPEncryptState(0); /* for audio notify */
+			break;
+		}
+
+	case HDCP_COMPARE_R0:
+
+		if (fgCompareRi() == true) {
+
+			vEnableEncrpt();	/* Enabe encrption */
+
+			/* change state as check repeater */
+			vSetHDCPState(HDCP_CHECK_REPEATER);
+			//vSendHdmiCmd(HDMI_HDCP_PROTOCAL_CMD);
+			vSetSharedInfo(SI_HDMI_HDCP_RESULT, 0x01);
+		} else {
+			vSetHDCPState(HDCP_RE_COMPARE_R0);
+			//vSendHdmiCmd(HDMI_HDCP_PROTOCAL_CMD);
+			HDMI_HDCP_LOG("[1x]fail-->HDCP_WAIT_R0-->1\n");
+			vHDCPEncryptState(0); /* for audio notify */
+			_bReCompRiCount = 0;
+		}
+
+		break;
+
+	case HDCP_RE_COMPARE_R0:
+
+		_bReCompRiCount++;
+		if (fgIsHDCPCtrlTimeOut(e_hdcp_state) && _bReCompRiCount > 3) {
+			vSetHDCPState(HDCP_RE_DO_AUTHENTICATION);
+			//vSendHdmiCmd(HDMI_HDCP_PROTOCAL_CMD);
+			_bHdcpStatus = SV_FAIL;
+			_bReCompRiCount = 0;
+			vHDCPEncryptState(0); /* for audio notify */
+			HDMI_HDCP_LOG("[1x]fail-->HDCP_WAIT_R0-->2\n");
+
+		} else {
+			if (fgCompareRi() == true) {
+				vEnableEncrpt();	/* Enabe encrption */
+
+				/* change state as check repeater */
+				vSetHDCPState(HDCP_CHECK_REPEATER);
+				//vSendHdmiCmd(HDMI_HDCP_PROTOCAL_CMD);
+				vSetSharedInfo(SI_HDMI_HDCP_RESULT, 0x01);
+			} else {
+				//vSendHdmiCmd(HDMI_HDCP_PROTOCAL_CMD);
+			}
+
+		}
+		break;
+
+	case HDCP_CHECK_REPEATER:
+		HDMI_HDCP_LOG("[1x]HDCP_CHECK_REPEATER\n");
+		/* if the device is a Repeater, */
+		if (fgIsRepeater()) {
+			_bReCheckReadyBit = 0;
+			vSetHDCPState(HDCP_WAIT_KSV_LIST);
+			set_hdcp_delay_time(HDCP_WAIT_KSV_LIST_TIMEOUT);
+		} else {
+
+			_bDevice_Count = 0;
+			_u2TxBStatus = 0;
+			if (hdmi->repeater_hdcp == true) {
+				if ((hdmirxhandle != NULL) &&
+				(hdmirxhandle->set_ksv != NULL))
+					hdmirxhandle->set_ksv(
+					hdmirxdev, 0, _u2TxBStatus,
+					&_bTxBKAV[0], &bKsv_buff[0], true);
+			}
+			vSetHDCPState(HDCP_WAIT_RI);
+			//vSendHdmiCmd(HDMI_HDCP_PROTOCAL_CMD);
+		}
+
+		break;
+
+	case HDCP_WAIT_KSV_LIST:
+
+		fgDDCDataRead(ddc, RX_ID, RX_REG_BCAPS, 1, &bTemp);
+		if ((bTemp & RX_BIT_ADDR_READY)) {
+			_bReCheckReadyBit = 0;
+			vSetHDCPState(HDCP_READ_KSV_LIST);
+		} else {
+			if (_bReCheckReadyBit >
+				HDCP_CHECK_KSV_LIST_RDY_RETRY_COUNT) {
+				vSetHDCPState(HDCP_RE_DO_AUTHENTICATION);
+				//vSendHdmiCmd(HDMI_HDCP_PROTOCAL_CMD);
+				_bReCheckReadyBit = 0;
+				_bHdcpStatus = SV_FAIL;
+				HDMI_HDCP_LOG("[1x]HDCP_WAIT_KSV_LIST, fail\n");
+			} else {
+				_bReCheckReadyBit++;
+				vSetHDCPState(HDCP_WAIT_KSV_LIST);
+				set_hdcp_delay_time(HDCP_WAIT_KSV_LIST_RETRY_TIMEOUT);
+			}
+			break;
+		}
+
+	case HDCP_READ_KSV_LIST:
+
+		vReadKSVFIFO();
+#ifdef SRM_SUPPORT
+		if (((hdmi->repeater_hdcp == true) &&
+		((hdmirxhandle != NULL) &&
+		(hdmirxhandle->hdcp_is_rpt != NULL) &&
+		(!(hdmirxhandle->hdcp_is_rpt(hdmirxdev)) &&
+		((i4SharedInfo(SI_DVD_HDCP_REVOCATION_RESULT) &
+		IS_REVOCATION_KEY) && (_rSRMInfo.bID == 0x80))))) ||
+		((hdmi->repeater_hdcp == false) &&
+		(i4SharedInfo(SI_DVD_HDCP_REVOCATION_RESULT) & IS_REVOCATION_KEY)
+		 && (_rSRMInfo.bID == 0x80))) {
+			mtk_hdmi_AV_mute(hdmi);
+			vSetHDCPState(HDCP_RE_DO_AUTHENTICATION);
+			_bHdcpStatus = SV_FAIL;
+			/* 2007/12/27 add 300 ms  issue next coomand */
+			set_hdcp_delay_time(HDCP_WAIT_300MS_TIMEOUT);
+			break;
+		}
+#endif
+		break;
+
+	case HDCP_COMPARE_V:
+
+		uitemp1 = uiReadHDCPStatus();
+		uitemp2 = uiReadIRQStatus01();
+		mtk_hdmi_write(hdmi, TOP_INT_CLR01, 0x00004000);
+		udelay(10);
+		mtk_hdmi_write(hdmi, TOP_INT_CLR01, 0x00000000);
+		if ((uitemp2 & (1 << 14)) || (uitemp1 & (1 << 28))) {
+			if ((uitemp2 & (1 << 14))) {
+				if (hdmi->repeater_hdcp == true) {
+					if ((hdmirxhandle != NULL) &&
+					(hdmirxhandle->set_ksv != NULL))
+						hdmirxhandle->set_ksv(
+						hdmirxdev, 0, _u2TxBStatus,
+						&_bTxBKAV[0], &bKsv_buff[0], true);
+				}
+				vSetHDCPState(HDCP_WAIT_RI);
+				//vSendHdmiCmd(HDMI_HDCP_PROTOCAL_CMD);
+				HDMI_HDCP_LOG("[1x]HDCP_COMPARE_V, pass\n");
+				vSetSharedInfo(SI_HDMI_HDCP_RESULT,
+					(i4SharedInfo(SI_HDMI_HDCP_RESULT) | 0x02));
+				/* step 2 OK. */
+			} else {
+				vSetHDCPState(HDCP_RE_DO_AUTHENTICATION);
+				//vSendHdmiCmd(HDMI_HDCP_PROTOCAL_CMD);
+				HDMI_HDCP_LOG("[1x]HDCP_COMPARE_V, fail\n");
+				_bHdcpStatus = SV_FAIL;
+				if (hdmi->repeater_hdcp == true) {
+					if ((hdmirxhandle != NULL) &&
+					(hdmirxhandle->set_ksv != NULL))
+						hdmirxhandle->set_ksv(
+						hdmirxdev, 0, _u2TxBStatus,
+						&_bTxBKAV[0], &bKsv_buff[0], false);
+				}
+			}
+		} else {
+			HDMI_HDCP_LOG("[HDCP]V Not RDY\n");
+			vSetHDCPState(HDCP_RE_DO_AUTHENTICATION);
+			_bHdcpStatus = SV_FAIL;
+			//vSendHdmiCmd(HDMI_HDCP_PROTOCAL_CMD);
+			if (hdmi->repeater_hdcp == true) {
+				if ((hdmirxhandle != NULL) &&
+				(hdmirxhandle->set_ksv != NULL))
+					hdmirxhandle->set_ksv(
+					hdmirxdev, 0, _u2TxBStatus,
+					&_bTxBKAV[0], &bKsv_buff[0], false);
+			}
+		}
+
+		break;
+
+	case HDCP_WAIT_RI:
+
+		mtk_hdmi_AV_unmute(hdmi);
+		//hdmi_audio_signal_state(1);
+		hdcp_unmute_start_flag = true;
+		//hdcp_set_unmute_start_time();
+		//HDMI_HDCP_LOG("[HDCP1.x]pass, %lums\n", jiffies);
+		vHDCPEncryptState(1); /* for audio notify */
+		break;
+
+	case HDCP_CHECK_LINK_INTEGRITY:
+#ifdef SRM_SUPPORT
+
+		if (((hdmi->repeater_hdcp == true) && ((hdmirxhandle != NULL) &&
+		(hdmirxhandle->hdcp_is_rpt != NULL) &&
+		((!(hdmirxhandle->hdcp_is_rpt(hdmirxdev)) &&
+		((i4SharedInfo(SI_DVD_HDCP_REVOCATION_RESULT)
+		& IS_REVOCATION_KEY) && (_rSRMInfo.bID == 0x80)))
+		|| (!(hdmirxhandle->hdcp_is_doing_auth(hdmirxdev))
+		&& hdmirxhandle->hdcp_is_rpt(hdmirxdev))))) ||
+		((hdmi->repeater_hdcp == false) && ((i4SharedInfo(SI_DVD_HDCP_REVOCATION_RESULT) &
+			IS_REVOCATION_KEY) && (_rSRMInfo.bID == 0x80)))) {
+			mtk_hdmi_AV_mute(hdmi);
+			vSetHDCPState(HDCP_RE_DO_AUTHENTICATION);
+			_bHdcpStatus = SV_FAIL;
+			vHDCPEncryptState(0); /* for audio notify */
+			set_hdcp_delay_time(HDCP_WAIT_300MS_TIMEOUT);
+			break;
+
+		}
+#endif
+		if (fgCompareRi() == true) {
+			vSetSharedInfo(SI_HDMI_HDCP_RESULT,
+				(i4SharedInfo(SI_HDMI_HDCP_RESULT) |
+				       0x04));
+			/* step 3 OK. */
+			if (fgIsRepeater()) {
+				if (i4SharedInfo(SI_HDMI_HDCP_RESULT) ==
+					0x07) {	/* step 1, 2, 3. */
+					vSetSharedInfo(SI_HDMI_HDCP_RESULT,
+					(i4SharedInfo(SI_HDMI_HDCP_RESULT) |
+						       0x08));
+					/* all ok. */
+				}
+			} else {	/* not repeater, don't need step 2. */
+
+				if (i4SharedInfo(SI_HDMI_HDCP_RESULT) ==
+					0x05) {	/* step 1, 3. */
+					vSetSharedInfo(SI_HDMI_HDCP_RESULT,
+					(i4SharedInfo(SI_HDMI_HDCP_RESULT) |
+						       0x08));
+					/* all ok. */
+				}
+			}
+		} else {
+			_bReCompRiCount = 0;
+			vSetHDCPState(HDCP_RE_COMPARE_RI);
+			//vSendHdmiCmd(HDMI_HDCP_PROTOCAL_CMD);
+			vHDCPEncryptState(0); /* for audio notify */
+			HDMI_HDCP_LOG("[1x]fai-->HDCP_CHECK_LINK_INTEGRITY\n");
+
+		}
+		break;
+
+	case HDCP_RE_COMPARE_RI:
+		HDMI_HDCP_LOG("[1x]HDCP_RE_COMPARE_RI\n");
+		_bReCompRiCount++;
+		if (_bReCompRiCount > 5) {
+			vSetHDCPState(HDCP_RE_DO_AUTHENTICATION);
+			//vSendHdmiCmd(HDMI_HDCP_PROTOCAL_CMD);
+			_bReCompRiCount = 0;
+			_bHdcpStatus = SV_FAIL;
+			HDMI_HDCP_LOG("[1x]fai-->HDCP_RE_COMPARE_RI\n");
+			vHDCPEncryptState(0); /* for audio notify */
+		} else {
+			if (fgCompareRi() == true) {
+				_bReCompRiCount = 0;
+				vSetHDCPState(HDCP_CHECK_LINK_INTEGRITY);
+				//vSendHdmiCmd(HDMI_HDCP_PROTOCAL_CMD);
+				vSetSharedInfo(SI_HDMI_HDCP_RESULT,
+				(i4SharedInfo(SI_HDMI_HDCP_RESULT) | 0x04));
+				/* step 3 OK. */
+				if (fgIsRepeater()) {
+					if (i4SharedInfo(
+						SI_HDMI_HDCP_RESULT) ==
+					0x07) {	/* step 1, 2, 3. */
+						vSetSharedInfo(
+							SI_HDMI_HDCP_RESULT,
+					(i4SharedInfo(SI_HDMI_HDCP_RESULT) |
+								0x08));
+						/* all ok. */
+					}
+				} else {
+					if (i4SharedInfo(SI_HDMI_HDCP_RESULT) ==
+					0x05) {	/* step 1, 3. */
+						vSetSharedInfo(
+						SI_HDMI_HDCP_RESULT,
+					(i4SharedInfo(SI_HDMI_HDCP_RESULT) |
+								0x08));
+						/* all ok. */
+					}
+				}
+
+			} else {
+				vSetHDCPState(HDCP_RE_COMPARE_RI);
+				//vSendHdmiCmd(HDMI_HDCP_PROTOCAL_CMD);
+			}
+		}
+		break;
+
+	case HDCP_RE_DO_AUTHENTICATION:
+		HDMI_HDCP_LOG("[1x]HDCP_RE_DO_AUTHENTICATION\n");
+		mtk_hdmi_AV_mute(hdmi);
+		vHDCPReset();
+		if (hdmi->hpd != HDMI_PLUG_IN_AND_SINK_POWER_ON) {
+			vSetHDCPState(HDCP_RECEIVER_NOT_READY);
+			//vSendHdmiCmd(HDMI_HDCP_PROTOCAL_CMD);
+		} else {
+			vSetHDCPState(HDCP_WAIT_RESET_OK);
+		if (hdmi->repeater_hdcp == true) {
+			if ((hdmirxhandle != NULL) &&
+			(hdmirxhandle->hdcp_is_rpt != NULL) &&
+			hdmirxhandle->hdcp_is_rpt(hdmirxdev))
+				set_hdcp_delay_time(50);
+			else
+				set_hdcp_delay_time(HDCP_WAIT_RE_DO_AUTHENTICATION);
+		} else
+			set_hdcp_delay_time(HDCP_WAIT_RE_DO_AUTHENTICATION);
+
+		}
+		break;
+
+	case HDCP_WAIT_RESET_OK:
+		if (fgIsHDCPCtrlTimeOut(e_hdcp_state)) {
+			vSetHDCPState(HDCP_INIT_AUTHENTICATION);
+			//vSendHdmiCmd(HDMI_HDCP_PROTOCAL_CMD);
+		}
+		break;
+
+		/*hdcp2 code start here */
+	case HDCP2x_WAIT_RES_CHG_OK:
+		HDMI_HDCP_LOG("HDCP2x_WAIT_RES_CHG_OK, %lums\n",
+			jiffies);
+		if (fgIsHDCPCtrlTimeOut(e_hdcp_state)) {
+			if (hdmi->hpd != HDMI_PLUG_IN_AND_SINK_POWER_ON) {
+				vSetHDCPState(HDCP_RECEIVER_NOT_READY);
+				HDMI_HDCP_LOG("set state HDCP_RECEIVER_NOT_READY\n");
+			} else if (hdmi->enable_hdcp == false) {
+				vSetHDCPState(HDCP_RECEIVER_NOT_READY);
+				mtk_hdmi_AV_unmute(hdmi);
+				HDMI_HDCP_LOG("set state HDCP_RECEIVER_NOT_READY\n");
+			} else {
+				mtk_hdmi_AV_mute(hdmi);
+				_bReRepeaterPollCnt = 0;
+				_bReCertPollCnt = 0;
+				_bReAuthCnt = 0;
+				_u14SeqMnum = 0;
+				vHDMI2xClearINT();
+				vSetHDCPState(HDCP2x_LOAD_BIN);
+		/* set_hdcp_delay_time(HDCP2x_WAIT_LOADBIN_TIMEOUE); */
+				//vSendHdmiCmd(HDMI_HDCP_PROTOCAL_CMD);
+
+				mtk_hdmi_mask(hdmi, HDCP2X_RPT_SEQ_NUM, 0,
+					HDCP2X_RPT_SEQ_NUM_M);
+				mtk_hdmi_mask(hdmi, HDCP2X_CTRL_0, 0,
+					HDCP2X_ENCRYPT_EN);
+				mtk_hdmi_mask(hdmi, HPD_DDC_CTRL,
+					DDC2_CLOK << DDC_DELAY_CNT_SHIFT,
+						 DDC_DELAY_CNT);
+				//_bLastHdcpStatus = HDCP_RECEIVER_NOT_READY;
+			}
+		}
+		break;
+
+	case HDCP2x_LOAD_BIN:
+		if (hdmi->repeater_hdcp == true) {
+			if (hdmi->hpd != HDMI_PLUG_IN_AND_SINK_POWER_ON) {
+				vSetHDCPState(HDCP_RECEIVER_NOT_READY);
+				HDMI_HDCP_LOG(
+				"[HDMI][HDCP2.x][REPEATER]TMDS is off\n");
+				break;
+			}
+		}
+		HDMI_HDCP_LOG("HDCP2x_LOAD_BIN, flag = %d\n", hdmi->bin_is_loaded);
+
+#ifdef CONFIG_OPTEE
+		/* SOFT_HDCP_CORE_RST, SOFT_HDCP_CORE_RST); */
+		vCaHDMIWriteHDCPRST(SOFT_HDCP_CORE_RST, SOFT_HDCP_CORE_RST);
+#endif
+
+		if (hdmi->bin_is_loaded == false) {
+#ifdef CONFIG_OPTEE
+			HDMI_HDCP_LOG("HDCP 2.x trustzone load Ram & Rom\n");
+			fgCaHDMILoadROM();
+#else
+			HDMI_HDCP_LOG("HDCP 2.x kernel load Ram & Rom\n");
+			for (readvalue = 0; readvalue < 0x8000; readvalue++) {
+				udelay(1);
+				mtk_hdmi_write(hdmi, PROM_CTRL, (readvalue << PROM_ADDR_SHIFT) +
+				(hdcp_prom[readvalue] << PROM_WDATA_SHIFT) + PROM_CS + PROM_WR);
+			}
+			mtk_hdmi_write(hdmi, PROM_CTRL, 0);
+
+			for (readvalue = 0; readvalue < 0x4000; readvalue++) {
+				udelay(1);
+				mtk_hdmi_write(hdmi, PRAM_CTRL, (readvalue << PRAM_ADDR_SHIFT) +
+					(hdcp_pram[readvalue] << PRAM_WDATA_SHIFT) +
+					PRAM_CTRL_SEL + PRAM_CS + PRAM_WR);
+			}
+			udelay(5);
+			mtk_hdmi_write(hdmi, PRAM_CTRL, 0);
+#endif
+			hdmi->bin_is_loaded = true;
+		} else {
+			mdelay(1);
+			mtk_hdmi_write(hdmi, PRAM_CTRL, (0x3fff << PRAM_ADDR_SHIFT) +
+				(hdcp_pram[0x3fff] << PRAM_WDATA_SHIFT) +
+				PRAM_CTRL_SEL + PRAM_CS + PRAM_WR);
+
+			mtk_hdmi_write(hdmi, PROM_CTRL, 0);
+			mtk_hdmi_write(hdmi, PRAM_CTRL, 0);
+		}
+		mtk_hdmi_mask(hdmi, HDCP2X_CTRL_0, HDCP2X_CUPD_START,
+			HDCP2X_CUPD_START);
+#ifdef CONFIG_OPTEE
+		/* SOFT_HDCP_CORE_NOR, SOFT_HDCP_CORE_RST); */
+		vCaHDMIWriteHDCPRST(SOFT_HDCP_CORE_NOR, SOFT_HDCP_CORE_RST);
+		/* HDCP_TCLK_EN, HDCP_TCLK_EN); */
+		vCaHDMIWriteHDCPRST(HDCP_TCLK_EN, HDCP_TCLK_EN);
+#endif
+
+		if (hdmi->hdcp_ctrl_state != HDCP2x_LOAD_BIN) {
+			HDMI_HDCP_LOG("hdcp state changed by other thread\n");
+			break;
+		}
+
+		vSetHDCPState(HDCP2x_INITAIL_OK);
+		set_hdcp_delay_time(HDCP2x_WAIT_INITAIL_TIMEOUE);
+		break;
+
+	case HDCP2x_INITAIL_OK:
+		HDMI_HDCP_LOG("HDCP2x_INITAIL_OK, %lums\n", jiffies);
+		readvalue = mtk_hdmi_read(hdmi, TOP_INT_STA00);
+		HDMI_HDCP_LOG("reg 0x1A8 = 0x%08x\n", readvalue);
+		fgCaHDMIGetTAStatus(ta_status);
+		if ((readvalue & HDCP2X_CCHK_DONE_INT_STA) &&
+			((ta_status[0] & 0x03) == 0)) {
+			HDMI_HDCP_LOG("hdcp2.2 ram/rom check is done\n");
+			vSetHDCPState(HDCP2x_AUTHENTICATION);
+			//vSendHdmiCmd(HDMI_HDCP_PROTOCAL_CMD);
+		} else {
+			HDMI_HDCP_LOG("hdcp2.2 ram/rom check is fail, %x\n",
+				ta_status[0]);
+			vHDCPInitAuth();
+			_bHdcpStatus = SV_FAIL;
+			hdmi->bin_is_loaded = false;
+		}
+		break;
+
+	case HDCP2x_AUTHENTICATION:
+		HDMI_HDCP_LOG("HDCP2x_AUTHENTICATION, %lums\n", jiffies);
+		/* enable reauth_req irq */
+		mtk_hdmi_mask(hdmi, TOP_INT_MASK00, 0x02000000, 0x02000000);
+		mtk_hdmi_mask(hdmi, HDCP2X_TEST_TP0, 0x75 <<
+			HDCP2X_TP1_SHIFT, HDCP2X_TP1);
+
+		mtk_hdmi_mask(hdmi, HDCP2X_CTRL_0, HDCP2X_EN |
+		HDCP2X_HDMIMODE,
+				 HDCP2X_EN | HDCP2X_HDMIMODE |
+				 HDCP2X_ENCRYPT_EN);
+		mtk_hdmi_mask(hdmi, SI2C_CTRL, RX_CAP_RD_TRIG,
+			RX_CAP_RD_TRIG);
+
+		mtk_hdmi_mask(hdmi, HDCP2X_POL_CTRL, 0x3402,
+			HDCP2X_POL_VAL1 | HDCP2X_POL_VAL0);
+
+		mtk_hdmi_write(hdmi, HDCP2X_TEST_TP0, 0x2a01be03);
+		mtk_hdmi_write(hdmi, HDCP2X_TEST_TP1, 0x09026411);
+		mtk_hdmi_write(hdmi, HDCP2X_TEST_TP2, 0xa7111110);
+		mtk_hdmi_write(hdmi, HDCP2X_TEST_TP3, 0x00fa0d7d);
+		mtk_hdmi_mask(hdmi, HDCP2X_GP_IN, 0x0 <<
+			HDCP2X_GP_IN2_SHIFT, HDCP2X_GP_IN2);
+		mtk_hdmi_mask(hdmi, HDCP2X_GP_IN, 0x0 <<
+			HDCP2X_GP_IN3_SHIFT, HDCP2X_GP_IN3);
+
+#ifdef CONFIG_OPTEE
+		/* set SM */
+		vCaHDMIWriteHdcpCtrl(0x88880000, 0xaaaa0000);
+#endif
+
+		vHdcpDdcHwPoll(true);
+		mtk_hdmi_mask(hdmi, HDCP2X_CTRL_0, HDCP2X_REAUTH_SW,
+			HDCP2X_REAUTH_SW);
+		udelay(1);
+		mtk_hdmi_mask(hdmi, HDCP2X_CTRL_0, 0, HDCP2X_REAUTH_SW);
+		vSetHDCPState(HDCP2x_CHECK_CERT_OK);
+		set_hdcp_delay_time(HDCP2x_WAIT_CERT_TIMEOUE);
+		break;
+
+	case HDCP2x_CHECK_AKE_OK:
+		HDMI_HDCP_LOG("0x1a8=0x%08x, 0xc60=0x%08x, 0xc8c=0x%08x\n",
+		     mtk_hdmi_read(hdmi, TOP_INT_STA00),
+		     mtk_hdmi_read(hdmi, HPD_DDC_STATUS),
+		     mtk_hdmi_read(hdmi, HDCP2X_STATUS_0));
+		readvalue = mtk_hdmi_read(hdmi, TOP_INT_STA00);
+		if (readvalue & HDCP2X_AKE_SENT_RCVD_INT_STA) {
+			vSetHDCPState(HDCP2x_CHECK_CERT_OK);
+			set_hdcp_delay_time(HDCP2x_WAIT_CERT_TIMEOUE);
+			HDMI_HDCP_LOG("_bReAKEtPollCnt = %d\n", _bReAKEtPollCnt);
+			_bReAKEtPollCnt = 0;
+		} else {
+			vSetHDCPState(HDCP2x_CHECK_AKE_OK);
+			set_hdcp_delay_time(HDCP2x_WAIT_AKE_TIMEOUE);
+			_bReAKEtPollCnt++;
+		}
+		break;
+
+	case HDCP2x_CHECK_CERT_OK:
+		HDMI_HDCP_LOG("0x1a8=0x%08x, 0xc60=0x%08x, 0xc8c=0x%08x\n",
+		     mtk_hdmi_read(hdmi, TOP_INT_STA00),
+		     mtk_hdmi_read(hdmi, HPD_DDC_STATUS),
+		     mtk_hdmi_read(hdmi, HDCP2X_STATUS_0));
+		readvalue = mtk_hdmi_read(hdmi, TOP_INT_STA00);
+		if (readvalue & HDCP2X_CERT_SEND_RCVD_INT_STA) {
+			vSetHDCPState(HDCP2x_REPEATER_CHECK);
+			set_hdcp_delay_time(HDCP2x_WAIT_REPEATER_CHECK_TIMEOUE);
+			_bReCertPollCnt = 0;
+		} else if (_bReCertPollCnt < 20) {
+			_bReCertPollCnt++;
+			if (fgHDMIHdcp2Err()) {
+				_bReCertPollCnt = 0;
+				_bHdcpStatus = SV_FAIL;
+				vSetHDCPState(HDCP2x_WAIT_RES_CHG_OK);
+				//vSendHdmiCmd(HDMI_HDCP_PROTOCAL_CMD);
+				vHdcpDdcHwPoll(false);
+				HDMI_HDCP_LOG("hdcp2_err=%x, HDCP2X_STATE = %d\n",
+				     bHDMIHDCP2Err(), _bReCertPollCnt);
+				break;
+			}
+
+			HDMI_HDCP_LOG("_bReCertPollCnt=%d\n", _bReCertPollCnt);
+
+			vSetHDCPState(HDCP2x_CHECK_CERT_OK);
+			set_hdcp_delay_time(10);
+		} else {
+			HDMI_HDCP_LOG("0x1a8=0x%08x,0xc60=0x%08x,0xc8c=0x%08x, %d\n",
+		     mtk_hdmi_read(hdmi, TOP_INT_STA00),
+		     mtk_hdmi_read(hdmi, HPD_DDC_STATUS),
+		     mtk_hdmi_read(hdmi, HDCP2X_STATUS_0), _bReCertPollCnt);
+			_bReCertPollCnt = 0;
+			_bHdcpStatus = SV_FAIL;
+
+			vHDCPInitAuth();
+		}
+		break;
+
+	case HDCP2x_REPEATER_CHECK:
+		HDMI_HDCP_LOG("0x1a8=0x%08x, 0xc60=0x%08x, 0xc8c=0x%08x\n",
+		     mtk_hdmi_read(hdmi, TOP_INT_STA00),
+		     mtk_hdmi_read(hdmi, HPD_DDC_STATUS),
+		     mtk_hdmi_read(hdmi, HDCP2X_STATUS_0));
+		readvalue = mtk_hdmi_read(hdmi, HDCP2X_STATUS_0);
+		if (readvalue & HDCP2X_RPT_REPEATER) {
+			HDMI_HDCP_LOG("downstream device is repeater\n");
+			hdmi->donwstream_is_repeater = true;
+			vSetHDCPState(HDCP2x_REPEATER_CHECK_OK);
+			set_hdcp_delay_time(HDCP2x_WAIT_REPEATER_POLL_TIMEOUE);
+		} else {
+			HDMI_HDCP_LOG("downstream device is receiver\n");
+			hdmi->donwstream_is_repeater = false;
+			vSetHDCPState(HDCP2x_AUTHEN_CHECK);
+			set_hdcp_delay_time(HDCP2x_WAIT_AUTHEN_TIMEOUE);
+
+			_bDevice_Count = 0;
+			_u2TxBStatus = 0;
+			_bTxBKAV[4] = mtk_hdmi_read(hdmi, HDCP2X_RCVR_ID) & 0xff;
+			_bTxBKAV[3] = (mtk_hdmi_read(hdmi, HDCP2X_RCVR_ID) & 0xff00) >> 8;
+			_bTxBKAV[2] = (mtk_hdmi_read(hdmi, HDCP2X_RCVR_ID) & 0xff0000) >> 16;
+			_bTxBKAV[1] = (mtk_hdmi_read(hdmi, HDCP2X_RCVR_ID) & 0xff000000) >> 24;
+			_bTxBKAV[0] = (mtk_hdmi_read(hdmi, HDCP2X_RPT_SEQ) & 0xff000000) >> 24;
+
+			_u2TxBStatus = ((mtk_hdmi_read(hdmi, HDCP2X_STATUS_0) & 0x3c) >> 2)
+			    + (((mtk_hdmi_read(hdmi, HDCP2X_STATUS_1) & 0xff00) >> 8) << 4)
+			    + ((mtk_hdmi_read(hdmi, HDCP2X_STATUS_1) & 0xff) << 9);
+			HDMI_HDCP_LOG("[2.x]_bTxBKAV=0x%x;0x%x;0x%x;0x%x;0x%x\n",
+				_bTxBKAV[0], _bTxBKAV[1], _bTxBKAV[2],
+				_bTxBKAV[3], _bTxBKAV[4]);
+			if (hdmi->repeater_hdcp == true) {
+				if ((hdmirxhandle != NULL) &&
+				(hdmirxhandle->set_ksv != NULL))
+					hdmirxhandle->set_ksv(hdmirxdev, 1,
+					_u2TxBStatus, &_bTxBKAV[0],
+					&bKsv_buff[0], true);
+			}
+			HDMI_HDCP_LOG("[2.x]_u2TxBStatus=0x%x\n", _u2TxBStatus);
+		}
+		break;
+
+	case HDCP2x_REPEATER_CHECK_OK:
+		HDMI_HDCP_LOG
+("0x1a8=0x%08x,0xc60=0x%08x,0xc8c=0x%08x,0xc90=0x%08x\n",
+		     mtk_hdmi_read(hdmi, TOP_INT_STA00),
+		     mtk_hdmi_read(hdmi, HPD_DDC_STATUS),
+		     mtk_hdmi_read(hdmi, HDCP2X_STATUS_0),
+		     mtk_hdmi_read(hdmi, HDCP2X_STATUS_1));
+/*  0x1a0[23] can not work sometime, so add 0x1a0[24][16]  */
+		readvalue = mtk_hdmi_read(hdmi, TOP_INT_STA00);
+		if ((readvalue & HDCP2X_RPT_RCVID_CHANGED_INT_STA)
+		    || (readvalue & HDCP2X_RPT_SMNG_XFER_DONE_INT_STA)
+		    || (readvalue & HDCP2X_AUTH_DONE_INT_STA)) {
+			_bReRepeaterPollCnt = 0;
+			vSetHDCPState(HDCP2x_RESET_RECEIVER);
+			set_hdcp_delay_time(HDCP2x_WAIT_RESET_RECEIVER_TIMEOUE);
+
+		} else if ((_bReRepeaterPollCnt <= 30) &&
+		(fgHDMIHdcp2Err() == false)) {
+			_bReRepeaterPollCnt++;
+			HDMI_HDCP_LOG("_bReRepeaterPollCnt=%d\n",
+				      _bReRepeaterPollCnt);
+			vSetHDCPState(HDCP2x_REPEATER_CHECK_OK);
+			set_hdcp_delay_time(HDCP2x_WAIT_REPEATER_POLL_TIMEOUE);
+		} else {
+			HDMI_HDCP_LOG
+("[HDMI][HDCP2.x]hdcp2.2 assume repeater failure, hdcp2_err=%x\n",
+			     bHDMIHDCP2Err());
+			vHDCPInitAuth();
+			_bHdcpStatus = SV_FAIL;
+			_bReRepeaterPollCnt = 0;
+			if (hdmi->repeater_hdcp == true) {
+				if ((hdmirxhandle != NULL) &&
+				(hdmirxhandle->set_ksv != NULL))
+					hdmirxhandle->set_ksv(hdmirxdev, 1,
+					_u2TxBStatus, &_bTxBKAV[0],
+					&bKsv_buff[0], false);
+			}
+			/* 2020-08-13
+			 * set_hdcp_delay_time(HDCP2x_WAIT_LOADBIN_TIMEOUE);
+			 * vSetHDCPState(HDCP2x_WAIT_RES_CHG_OK);
+			 */
+		}
+		break;
+
+	case HDCP2x_RESET_RECEIVER:
+		HDMI_HDCP_LOG
+		("0x1a8 = 0x%08x, 0xc60 = 0x%08x, 0xc8c = 0x%08x, %lums\n",
+		     mtk_hdmi_read(hdmi, TOP_INT_STA00),
+		     mtk_hdmi_read(hdmi, HPD_DDC_STATUS),
+		     mtk_hdmi_read(hdmi, HDCP2X_STATUS_0), jiffies);
+		mtk_hdmi_mask(hdmi, HDCP2X_CTRL_2, HDCP2X_RPT_RCVID_RD_START,
+				 HDCP2X_RPT_RCVID_RD_START);
+		udelay(1);
+		mtk_hdmi_mask(hdmi, HDCP2X_CTRL_2, 0, HDCP2X_RPT_RCVID_RD_START);
+		devicecnt =
+		    (mtk_hdmi_read(hdmi, HDCP2X_STATUS_1) & HDCP2X_RPT_DEVCNT) >>
+		    HDCP2X_RPT_DEVCNT_SHIFT;
+
+		depth = mtk_hdmi_read(hdmi, HDCP2X_STATUS_1) &
+			HDCP2X_RPT_DEPTH;
+		if ((depth == 0) && (devicecnt != 0))
+			fgRepeaterError = true;
+		count1 = 0;
+
+		bRptID[0] =
+		    (mtk_hdmi_read(hdmi, HDCP2X_STATUS_1) &
+		    HDCP2X_RPT_RCVID_OUT) >>
+		    HDCP2X_RPT_RCVID_OUT_SHIFT;
+		count1 = count1 + u1CountNum1(bRptID[0]);
+		for (i = 1; i < 5 * devicecnt; i++) {
+			mtk_hdmi_mask(hdmi, HDCP2X_CTRL_2,
+				HDCP2X_RPT_RCVID_RD,
+				HDCP2X_RPT_RCVID_RD);
+			udelay(1);
+			mtk_hdmi_mask(hdmi, HDCP2X_CTRL_2, 0,
+				HDCP2X_RPT_RCVID_RD);
+			if (i < 155) {
+				bRptID[i] =
+				    (mtk_hdmi_read(hdmi, HDCP2X_STATUS_1) &
+				    HDCP2X_RPT_RCVID_OUT) >>
+				    HDCP2X_RPT_RCVID_OUT_SHIFT;
+				count1 = count1+u1CountNum1(bRptID[i]);
+				if ((i % 5) == 4) {
+					if (count1 != 20)
+						fgRepeaterError = true;
+					count1 = 0;
+				}
+			} else
+				HDMI_HDCP_LOG("device count exceed\n");
+		}
+
+		for (i = 0; i < 5 * devicecnt; i++) {
+			if ((i % 5) == 0)
+				HDMI_HDCP_LOG("ID[%d]:", i / 5);
+
+			HDMI_HDCP_LOG("0x%x,", bRptID[i]);
+
+			if ((i % 5) == 4)
+				HDMI_HDCP_LOG("\n");
+		}
+		if (fgRepeaterError) {
+			HDMI_HDCP_LOG("repeater parameter invaild\n");
+			mtk_hdmi_AV_mute(hdmi);
+			vHDCPReset();
+			vHDCPInitAuth();
+			break;
+		}
+
+		_bDevice_Count = devicecnt;
+		vSetHDCPState(HDCP2x_REPEAT_MSG_DONE);
+		set_hdcp_delay_time(HDCP2x_WAIT_REPEATER_DONE_TIMEOUE);
+
+		_bTxBKAV[4] =
+			mtk_hdmi_read(hdmi, HDCP2X_RCVR_ID) & 0xff;
+		_bTxBKAV[3] =
+			(mtk_hdmi_read(hdmi, HDCP2X_RCVR_ID) & 0xff00) >> 8;
+		_bTxBKAV[2] =
+			(mtk_hdmi_read(hdmi, HDCP2X_RCVR_ID) & 0xff0000) >> 16;
+		_bTxBKAV[1] =
+			(mtk_hdmi_read(hdmi, HDCP2X_RCVR_ID) & 0xff000000) >> 24;
+		_bTxBKAV[0] =
+			(mtk_hdmi_read(hdmi, HDCP2X_RPT_SEQ) & 0xff000000) >> 24;
+		_u2TxBStatus =
+			((mtk_hdmi_read(hdmi, HDCP2X_STATUS_0) & 0x3c) >> 2)
+		+ (((mtk_hdmi_read(hdmi, HDCP2X_STATUS_1) & 0xff00) >> 8) << 4)
+		+ ((mtk_hdmi_read(hdmi, HDCP2X_STATUS_1) & 0xff) << 9);
+
+		if (hdmi->repeater_hdcp == true) {
+			if ((hdmirxhandle != NULL) &&
+			(hdmirxhandle->set_ksv != NULL))
+				hdmirxhandle->set_ksv(hdmirxdev, 1,
+					_u2TxBStatus, &_bTxBKAV[0], &bRptID[0], true);
+		}
+		break;
+
+	case HDCP2x_REPEAT_MSG_DONE:
+		HDMI_HDCP_LOG
+		  ("0x1a8 = 0x%08x, 0xc60 = 0x%08x, 0xc8c = 0x%08x, %lums\n",
+		     mtk_hdmi_read(hdmi, TOP_INT_STA00),
+		     mtk_hdmi_read(hdmi, HPD_DDC_STATUS),
+		     mtk_hdmi_read(hdmi, HDCP2X_STATUS_0), jiffies);
+		readvalue = mtk_hdmi_read(hdmi, TOP_INT_STA00);
+		if ((readvalue & HDCP2X_RPT_SMNG_XFER_DONE_INT_STA)
+		    || (readvalue & HDCP2X_AUTH_DONE_INT_STA)) {
+			_bReRepeaterDoneCnt = 0;
+			mtk_hdmi_mask(hdmi, HDCP2X_CTRL_2, 0,
+				HDCP2X_RPT_SMNG_WR_START);
+			vSetHDCPState(HDCP2x_AUTHEN_CHECK);
+			set_hdcp_delay_time(HDCP2x_WAIT_AUTHEN_TIMEOUE);
+		} else if ((_bReRepeaterDoneCnt < 10) &&
+		(fgHDMIHdcp2Err() == false)) {
+			_bReRepeaterDoneCnt++;
+			HDMI_HDCP_LOG("_bReRepeaterDoneCnt=%d\n",
+				      _bReRepeaterDoneCnt);
+			vSetHDCPState(HDCP2x_REPEAT_MSG_DONE);
+			set_hdcp_delay_time(HDCP2x_WAIT_REPEATER_DONE_TIMEOUE);
+		} else {
+			HDMI_HDCP_LOG(
+		"repeater smsg done failure, hdcp2_err=%x\n",
+				      bHDMIHDCP2Err());
+			vHDCPInitAuth();
+
+			_bReRepeaterDoneCnt = 0;
+			_bHdcpStatus = SV_FAIL;
+		}
+		break;
+
+	case HDCP2x_AUTHEN_CHECK:
+		HDMI_HDCP_LOG
+("0x1a8 = 0x%08x, 0xc60 = 0x%08x, 0xc8c = 0x%08x, %lums\n",
+		     mtk_hdmi_read(hdmi, TOP_INT_STA00),
+		     mtk_hdmi_read(hdmi, HPD_DDC_STATUS),
+		     mtk_hdmi_read(hdmi, HDCP2X_STATUS_0), jiffies);
+		readvalue = mtk_hdmi_read(hdmi, TOP_INT_STA00);
+		if (readvalue & HDCP2X_AUTH_DONE_INT_STA) {
+			if (hdmi->repeater_hdcp == true) {
+			/* can.zeng todo check
+			 *	if (fgHdmiRepeaterIsBypassMode())
+			 *		vHDMI2TxNotifyToRx(1);
+			 */
+			}
+			HDMI_HDCP_LOG("[HDCP2.x]pass, %lums\n", jiffies);
+			vSetHDCPState(HDCP2x_ENCRYPTION);
+			set_hdcp_delay_time(HDCP2x_WAIT_AITHEN_DEALY_TIMEOUE);
+			_bReAuthCnt = 0;
+		} else if (((readvalue & HDCP2X_AUTH_FAIL_INT_STA) &&
+				(_bReAuthCnt != 0))
+			   || (_bReAuthCnt > REPEAT_CHECK_AUTHHDCP_VALUE) ||
+			   fgHDMIHdcp2Err()) {
+			HDMI_HDCP_LOG
+("[HDMI][HDCP2.x]hdcp2.2 authentication fail-->1, hdcp2_err=%x\n",
+			     bHDMIHDCP2Err());
+			vHDCPInitAuth();
+			_bReAuthCnt = 0;
+			vHDCPEncryptState(0); /* for audio notify */
+			if (readvalue & HDCP2X_AUTH_FAIL_INT_STA) {
+				vCleanAuthFailInt();
+				vHDCPEncryptState(0); /* for audio notify */
+				HDMI_HDCP_LOG(
+				"hdcp2.2 authentication fail-->2\n");
+			}
+		} else {
+			if ((readvalue & HDCP2X_AUTH_FAIL_INT_STA) &&
+				(_bReAuthCnt == 0)) {
+				vCleanAuthFailInt();
+				vHDCPEncryptState(0); /* for audio notify */
+				HDMI_HDCP_LOG("hdcp2.2 authentication fail-->3\n");
+			}
+			_bReAuthCnt++;
+			HDMI_HDCP_LOG("hdcp2.2 authentication wait=%d\n",
+				      _bReAuthCnt);
+			vSetHDCPState(HDCP2x_AUTHEN_CHECK);
+			set_hdcp_delay_time(HDCP2x_WAIT_AUTHEN_TIMEOUE);
+		}
+		break;
+
+	case HDCP2x_ENCRYPTION:
+		if (hdmi->hpd != HDMI_PLUG_IN_AND_SINK_POWER_ON) {
+			vSetHDCPState(HDCP_RECEIVER_NOT_READY);
+			//vSendHdmiCmd(HDMI_HDCP_PROTOCAL_CMD);
+		} else {
+			mtk_hdmi_mask(hdmi, HDCP2X_CTRL_0, HDCP2X_ENCRYPT_EN,
+				HDCP2X_ENCRYPT_EN);
+			_bReAuthCnt = 0;
+			_bHdcpStatus = SV_OK;
+			mtk_hdmi_AV_unmute(hdmi);
+			//hdmi_audio_signal_state(1);
+			hdcp_unmute_start_flag = true;
+			//hdcp_set_unmute_start_time();
+			//HDMI_HDCP_LOG("[HDCP2.x]pass, %lums\n", jiffies);
+			vHDCPEncryptState(1); /* for audio notify */
+		}
+		break;
+
+	default:
+		break;
+	}
+
+}
+
+void vHDCPBStatus(void)
+{
+/* _u2TxBStatus */
+	unsigned int u2Temp = 0;
+	struct mtk_hdmi *hdmi = global_mtk_hdmi;
+
+	if (hdmi->hdcp_2x_support == true) {
+		HDMI_HDCP_LOG("hdcp2.2\n");
+		if (fgIsRepeater()) {
+			HDMI_HDCP_LOG("Bstatus = 0x%x\n", _u2TxBStatus);
+
+			if (_u2TxBStatus & (0x1 << 2))
+				HDMI_HDCP_LOG("MAX_CASCADE_EXCEEDED = 1\n");
+			else
+				HDMI_HDCP_LOG("MAX_CASCADE_EXCEEDED = 0\n");
+
+			u2Temp = (_u2TxBStatus >> 9) & (0x7);
+			HDMI_HDCP_LOG("DEPTH = %d\n", u2Temp);
+
+			if (_u2TxBStatus & (0x1 << 3))
+				HDMI_HDCP_LOG("MAX_DEVS_EXCEEDED = 1\n");
+			else
+				HDMI_HDCP_LOG("MAX_DEVS_EXCEEDED = 0\n");
+
+			u2Temp = (_u2TxBStatus >> 4) & (0x1f);
+			HDMI_HDCP_LOG("DEVICE_COUNT = %d\n", u2Temp);
+
+			u2Temp = (_u2TxBStatus >> 1) & (0x1);
+			if (u2Temp)
+				HDMI_HDCP_LOG
+	("presence of an hdcp20 compliant repeater in the topology\n");
+
+			u2Temp = (_u2TxBStatus >> 0) & (0x1);
+			if (u2Temp)
+				HDMI_HDCP_LOG
+	("presence of an hdcp1x compliant repeater in the topology\n");
+		} else {
+			HDMI_HDCP_LOG("A Connected device is only Sink!!!\n");
+		}
+
+	} else {
+		HDMI_HDCP_LOG("hdcp1.4\n");
+		if (fgIsRepeater()) {
+			HDMI_HDCP_LOG("Bstatus = 0x%x\n", _u2TxBStatus);
+			if (_u2TxBStatus & (0x1 << 12))
+				HDMI_HDCP_LOG("HDMI_MODE = 1\n");
+			else
+				HDMI_HDCP_LOG("HDMI_MODE = 0\n");
+
+			if (_u2TxBStatus & (0x1 << 11))
+				HDMI_HDCP_LOG("MAX_CASCADE_EXCEEDED = 1\n");
+			else
+				HDMI_HDCP_LOG("MAX_CASCADE_EXCEEDED = 0\n");
+
+			u2Temp = (_u2TxBStatus >> 8) & (0x7);
+			HDMI_HDCP_LOG("DEPTH = %d\n", u2Temp);
+
+			if (_u2TxBStatus & (0x1 << 7))
+				HDMI_HDCP_LOG("MAX_DEVS_EXCEEDED = 1\n");
+			else
+				HDMI_HDCP_LOG("MAX_DEVS_EXCEEDED = 0\n");
+
+			u2Temp = _u2TxBStatus & 0x7F;
+			HDMI_HDCP_LOG("DEVICE_COUNT = %d\n", u2Temp);
+		} else {
+			HDMI_HDCP_LOG("A Connected device is only Sink!!!\n");
+		}
+	}
+}
+
+void vShowHdcpStatus(void)
+{
+	struct mtk_hdmi *hdmi = global_mtk_hdmi;
+
+	HDMI_HDCP_LOG("[hdcp]state=%d\n", hdmi->hdcp_ctrl_state);
+	HDMI_HDCP_LOG("[hdcp]hdcp2_version_flag=%d\n", hdmi->hdcp_2x_support);
+	HDMI_HDCP_LOG("[hdcp]hdcp_key_load_status=%d\n", hdmi->key_is_installed);
+	HDMI_HDCP_LOG("[hdcp]hdcp_unmute_logo_flag=%d\n", hdcp_unmute_logo_flag);
+	HDMI_HDCP_LOG("[hdcp]enalbe_hdcp=%d\n", hdmi->enable_hdcp);
+	HDMI_HDCP_LOG("[hdcp]hdcp_unmute_start_flag=%d\n", hdcp_unmute_start_flag);
+
+	if ((mtk_hdmi_read(hdmi, HDCP1x_STATUS) &
+		HDCP_ENCRYPTING_ON) == HDCP_ENCRYPTING_ON)
+		HDMI_HDCP_LOG("[hdcp1]HDCP_ENCRYPTING_ON\n");
+	else
+		HDMI_HDCP_LOG("[hdcp1]HDCP_ENCRYPTING_OFF\n");
+	if ((mtk_hdmi_read(hdmi, HDCP2X_STATUS_0) &
+		HDCP2X_ENCRYPTING_ON) == HDCP2X_ENCRYPTING_ON)
+		HDMI_HDCP_LOG("[hdcp2]HDCP2X_ENCRYPTING_ON\n");
+	else
+		HDMI_HDCP_LOG("[hdcp2]HDCP2X_ENCRYPTING_OFF\n");
+}
+
+void vReadHdcpVersion(void)
+{
+	unsigned char bTemp;
+	struct mtk_hdmi *hdmi = global_mtk_hdmi;
+	struct mtk_hdmi_ddc *ddc = hdmi_ddc_ctx_from_mtk_hdmi(hdmi);
+
+	if (!fgDDCDataRead(ddc, RX_ID, RX_REG_HDCP2VERSION,
+		1, &bTemp)) {
+		HDMI_HDCP_LOG("read hdcp version fail from sink\n");
+		hdmi->hdcp_2x_support = false;
+	} else if (bTemp & 0x4) {
+		hdmi->hdcp_2x_support = true;
+		HDMI_HDCP_LOG("sink support hdcp2.2 version\n");
+	} else {
+		hdmi->hdcp_2x_support = false;
+		HDMI_HDCP_LOG("sink support hdcp1.x version\n");
+	}
+}
+
diff --git a/drivers/gpu/drm/mediatek/mediatek_v2/mtk_hdmi_hdcp.h b/drivers/gpu/drm/mediatek/mediatek_v2/mtk_hdmi_hdcp.h
new file mode 100644
index 0000000000000000000000000000000000000000..f64759ce55ae345ed8c5aed88aaa54204f6c60ae
--- /dev/null
+++ b/drivers/gpu/drm/mediatek/mediatek_v2/mtk_hdmi_hdcp.h
@@ -0,0 +1,213 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2019 MediaTek Inc.
+ */
+
+
+#ifndef __hdmihdcp_h__
+#define __hdmihdcp_h__
+
+#include <linux/timer.h>
+
+enum HDMI_HDCP_VERSION {
+	HDMI_HDCP_1_x,
+	HDMI_HDCP_2_x
+};
+
+struct HDMI_HDCP_BKSV_INFO {
+	unsigned char bksv_list[160];
+	unsigned int bstatus;
+	unsigned char is_plug_in;
+	unsigned char is_hdcp_ok;
+};
+
+enum HDCP_CTRL_STATE_T {
+	HDCP_RECEIVER_NOT_READY = 0x00,
+	HDCP_READ_EDID,
+	HDCP_INIT_AUTHENTICATION,
+	HDCP_WAIT_R0,
+	HDCP_COMPARE_R0,
+	HDCP_WAIT_RI,
+	HDCP_CHECK_LINK_INTEGRITY,
+	HDCP_RE_DO_AUTHENTICATION,
+	HDCP_RE_COMPARE_RI,
+	HDCP_RE_COMPARE_R0,
+	HDCP_CHECK_REPEATER,
+	HDCP_WAIT_KSV_LIST,
+	HDCP_READ_KSV_LIST,
+	HDCP_COMPARE_V,
+	HDCP_RETRY_FAIL,
+	HDCP_WAIT_RESET_OK,
+	HDCP_WAIT_RES_CHG_OK,
+	HDCP_WAIT_SINK_UPDATE_RI_DDC_PORT,
+
+	HDCP2x_WAIT_RES_CHG_OK,
+	HDCP2x_SWITCH_OK,
+	HDCP2x_LOAD_BIN,
+	HDCP2x_INITAIL_OK,
+	HDCP2x_AUTHENTICATION,
+	HDCP2x_AUTHEN_CHECK,
+	HDCP2x_CHECK_AKE_OK,
+	HDCP2x_CHECK_CERT_OK,
+	HDCP2x_REPEATER_CHECK,
+	HDCP2x_REPEATER_CHECK_OK,
+	HDCP2x_RESET_RECEIVER,
+	HDCP2x_REPEAT_MSG_DONE,
+	HDCP2x_ENCRYPTION,
+	HDCP2x_POLLING_RXSTATUS
+};
+
+enum HDMI_CTRL_STATE_T {
+	HDMI_STATE_IDLE = 0,
+	HDMI_STATE_HOT_PLUG_OUT,
+	HDMI_STATE_HOT_PLUGIN_AND_POWER_ON,
+	HDMI_STATE_HOT_PLUG_IN_ONLY,
+	HDMI_STATE_READ_EDID,
+	HDMI_STATE_POWER_ON_READ_EDID,
+	HDMI_STATE_POWER_OFF_HOT_PLUG_OUT,
+
+};
+
+enum HDMI_HDCP_KEY_T {
+	EXTERNAL_KEY = 0,
+	INTERNAL_NOENCRYPT_KEY,
+	INTERNAL_ENCRYPT_KEY
+};
+
+/* Notice: there are three device ID for SiI9993 (Receiver) */
+#define RX_ID       0x3A	/* Max'0308'04, 0x74 */
+/* (2.2) Define the desired register address of receiver */
+/* Software Reset Register */
+#define RX_REG_SRST           0x05
+/* An register (total 8 bytes, address from 0x18 ~ 0x1F) */
+#define RX_REG_HDCP_AN        0x18
+/* Aksv register (total 5 bytes, address from 0x10 ~ 0x14) */
+#define RX_REG_HDCP_AKSV      0x10
+/* Bksv register (total 5 bytes, address from 0x00 ~ 0x04) */
+#define RX_REG_HDCP_BKSV      0x00
+/* BCAPS register */
+#define RX_REG_BCAPS          0x40
+#define RX_BIT_ADDR_RPTR      0x40	/* bit 6 */
+#define RX_BIT_ADDR_READY     0x20	/* bit 5 */
+#define RX_REG_HDCP2VERSION   0x50
+#define RX_REG_RXSTATUS   0x70
+#define RX_RXSTATUS_REAUTH_REQ (0x0800)
+
+#define RX_REG_BSTATUS1       0x41
+#define DEVICE_COUNT_MASK     0xff
+#define MAX_DEVS_EXCEEDED  (0x01<<7)
+#define MAX_CASCADE_EXCEEDED (0x01<<3)
+
+#define RX_REG_KSV_FIFO       0x43
+#define RX_REG_REPEATER_V     0x20
+#define RX_REG_TMDS_CONFIG     0x20
+#define SCRAMBLING_ENABLE     (1<<0)
+#define TMDS_BIT_CLOCK_RATION  (1<<1)
+
+/* Ri register (total 2 bytes, address from 0x08 ~ 0x09) */
+#define RX_REG_RI             0x08
+#define RX_REG_SCRAMBLE             0xA8
+
+/* (2) Define the counter for An register byte */
+#define HDCP_AN_COUNT                 8
+
+/* (3) Define the counter for HDCP Aksv register byte */
+#define HDCP_AKSV_COUNT               5
+
+/* (3) Define the counter for HDCP Bksv register byte */
+#define HDCP_BKSV_COUNT               5
+
+/* (4) Define the counter for Ri register byte */
+#define HDCP_RI_COUNT                 2
+
+#define HDCP_WAIT_5MS_TIMEOUT          5	/* 5 ms, */
+#define HDCP_WAIT_10MS_TIMEOUT          10	/* 10 ms, */
+#define HDCP_WAIT_300MS_TIMEOUT          300	/* 10 ms, */
+/* 25//for timer 5ms      // 100 ms, */
+#define HDCP_WAIT_R0_TIMEOUT          110
+/* 4600//5000//5500//1100//for timer 5ms //5000   // 5.5 sec */
+#define HDCP_WAIT_KSV_LIST_TIMEOUT    100
+#define HDCP_WAIT_KSV_LIST_RETRY_TIMEOUT    100
+/* 500//for timer 5ms //2000   // 2.5 sec, */
+#define HDCP_WAIT_RI_TIMEOUT          2500
+/* 20////for timer 20ms 200 //kenny 100->200 */
+#define HDCP_WAIT_RE_DO_AUTHENTICATION 200
+/* 50//for 20ms timer //1000   // 1 sec, 50*20ms */
+#define HDCP_WAIT_RECEIVER_READY      1000
+#define HDCP_WAIT_RES_CHG_OK_TIMEOUE 500	/* 30//6 */
+#define HDCP_WAIT_V_RDY_TIMEOUE 500	/* 30//6 */
+#define HDCP_CHECK_KSV_LIST_RDY_RETRY_COUNT    56	/* 10 */
+
+#define HDCP2x_WAIT_RES_CHG_OK_TIMEOUE 500
+#define HDCP2x_WAIT_AUTHEN_TIMEOUE 100
+#define HDCP2x_WAIT_RAMROM_TIMEOUE 50	/* 3 */
+#define HDCP2x_WAIT_AUTHEN_AGAIN_TIMEOUE 100
+#define HDCP2x_WAIT_LOADBIN_TIMEOUE 10
+#define HDCP2x_WAIT_POLLING_TIMEOUE 1000
+#define HDCP2x_WAIT_AITHEN_DEALY_TIMEOUE 250
+#define HDCP2x_WAIT_REPEATER_POLL_TIMEOUE 100
+#define HDCP2x_WAIT_RESET_RECEIVER_TIMEOUE 10
+#define HDCP2x_WAIT_REPEATER_DONE_TIMEOUE 100
+#define HDCP2x_WAIT_REPEATER_CHECK_TIMEOUE 150
+#define HDCP2x_WAIT_SWITCH_TIMEOUE 300
+#define HDCP2x_WAIT_CERT_TIMEOUE 20
+#define HDCP2x_WAIT_INITAIL_TIMEOUE 10
+#define HDCP2x_WAIT_AKE_TIMEOUE 10
+
+#define SRM_SIZE 5120
+
+
+#define  HDMI_H0  0x67452301
+#define  HDMI_H1  0xefcdab89
+#define  HDMI_H2  0x98badcfe
+#define  HDMI_H3  0x10325476
+#define  HDMI_H4  0xc3d2e1f0
+
+#define  HDMI_K0  0x5a827999
+#define  HDMI_K1  0x6ed9eba1
+#define  HDMI_K2  0x8f1bbcdc
+#define  HDMI_K3  0xca62c1d6
+
+/* for HDCP key access method */
+/* Key accessed by host */
+#define HOST_ACCESS                  1
+/* Key auto accessed by HDCP hardware from eeprom */
+#define NON_HOST_ACCESS_FROM_EEPROM  2
+/* Key auto accessed by HDCP hardware from MCM */
+#define NON_HOST_ACCESS_FROM_MCM     3
+#define NON_HOST_ACCESS_FROM_GCPU    4
+/* for HDCP */
+#define KSV_BUFF_SIZE 192
+#define KSV_LIST_SIZE 60
+#define HDCP_KEY_RESERVE 287
+
+/* for SI_DVD_HDCP_REVOCATION_RESULT */
+#define REVOCATION_NOT_CHK  0
+#define IS_REVOCATION_KEY      (1<<0)
+#define NOT_REVOCATION_KEY     (1<<1)
+#define REVOCATION_IS_CHK      (1<<2)
+
+#define HDCPKEY_LENGTH_DRM 512
+
+#ifdef CONFIG_DRM_MEDIATEK_HDMI_HDCP
+bool fgIsHDCPCtrlTimeOut(enum HDCP_CTRL_STATE_T e_hdcp_state);
+bool fgHDMIHdcp2Auth(void);
+unsigned int bHDMIHDCP2Err(void);
+void hdcp2x_load_rom_ram(void);
+void hdcp_service(enum HDCP_CTRL_STATE_T e_hdcp_state);
+void vSetHDCPState(enum HDCP_CTRL_STATE_T e_state);
+void vHDCPInitAuth(void);
+extern atomic_t hdmi_hdcp_event;
+void vReadHdcpVersion(void);
+void vHDCPReset(void);
+extern int hdcp_delay_time;
+
+#ifdef CONFIG_MTK_HDMI_RX
+#include "mtk_hdmi_rpt.h"
+extern struct MTK_HDMIRX *hdmirxhandle;
+extern struct device *hdmirxdev;
+#endif
+
+#endif
+
+#endif
diff --git a/drivers/gpu/drm/mediatek/mediatek_v2/mtk_hdmi_hdr.c b/drivers/gpu/drm/mediatek/mediatek_v2/mtk_hdmi_hdr.c
new file mode 100644
index 0000000000000000000000000000000000000000..e66341903434fa8fedae1e3a41a728d360eac315
--- /dev/null
+++ b/drivers/gpu/drm/mediatek/mediatek_v2/mtk_hdmi_hdr.c
@@ -0,0 +1,1061 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2019 MediaTek Inc.
+ */
+
+#include "mtk_hdmi_regs.h"
+#include "mtk_hdmi_hdr.h"
+#include <linux/slab.h>
+
+unsigned char mtk_hdr_log = 1;
+
+#define HDMI_HDR_LOG(fmt, arg...) \
+	do {	if (mtk_hdr_log) { \
+		pr_info("[HDMI][HDR] %s,%d "fmt, __func__, __LINE__, ##arg); \
+		} \
+	} while (0)
+
+#define HDMI_HDR_FUNC()	\
+	do {	if (mtk_hdr_log) \
+		pr_info("[HDMI][HDR] %s\n", __func__); \
+	} while (0)
+
+
+static struct PACKET_HW_T pkthw[GEN_PKT_HW_NUM] = {
+	{
+		.hw_num = GEN_PKT_HW1,
+		.addr_header = TOP_GEN_HEADER,
+		.addr_pkt = TOP_GEN_PKT00,
+		.addr_wr_en = TOP_INFO_EN,
+		.mask_wr_en = GEN_EN | GEN_EN_WR,
+		.addr_rep_en = TOP_INFO_RPT,
+		.mask_rep_en = GEN_RPT_EN,
+	},
+	{
+		.hw_num = GEN_PKT_HW2,
+		.addr_header = TOP_GEN2_HEADER,
+		.addr_pkt = TOP_GEN2_PKT00,
+		.addr_wr_en = TOP_INFO_EN,
+		.mask_wr_en = GEN2_EN | GEN2_EN_WR,
+		.addr_rep_en = TOP_INFO_RPT,
+		.mask_rep_en = GEN2_RPT_EN,
+	},
+	{
+		.hw_num = GEN_PKT_HW3,
+		.addr_header = TOP_GEN3_HEADER,
+		.addr_pkt = TOP_GEN3_PKT00,
+		.addr_wr_en = TOP_INFO_EN,
+		.mask_wr_en = GEN3_EN | GEN3_EN_WR,
+		.addr_rep_en = TOP_INFO_RPT,
+		.mask_rep_en = GEN3_RPT_EN,
+	},
+	{
+		.hw_num = GEN_PKT_HW4,
+		.addr_header = TOP_GEN4_HEADER,
+		.addr_pkt = TOP_GEN4_PKT00,
+		.addr_wr_en = TOP_INFO_EN,
+		.mask_wr_en = GEN4_EN | GEN4_EN_WR,
+		.addr_rep_en = TOP_INFO_RPT,
+		.mask_rep_en = GEN4_RPT_EN,
+	},
+	{
+		.hw_num = GEN_PKT_HW5,
+		.addr_header = TOP_GEN5_HEADER,
+		.addr_pkt = TOP_GEN5_PKT00,
+		.addr_wr_en = TOP_INFO_EN,
+		.mask_wr_en = GEN5_EN | GEN5_EN_WR,
+		.addr_rep_en = TOP_INFO_RPT,
+		.mask_rep_en = GEN5_RPT_EN,
+	},
+	{
+		.hw_num = GEN_PKT_HW6,
+		.addr_header = TOP_GEN6_HEADER,
+		.addr_pkt = TOP_GEN6_PKT00,
+		.addr_wr_en = TOP_INFO_EN,
+		.mask_wr_en = GEN6_EN | GEN6_EN_WR,
+		.addr_rep_en = TOP_INFO_RPT,
+		.mask_rep_en = GEN6_RPT_EN,
+	},
+	{
+		.hw_num = GEN_PKT_HW7,
+		.addr_header = TOP_GEN7_HEADER,
+		.addr_pkt = TOP_GEN7_PKT00,
+		.addr_wr_en = TOP_INFO_EN,
+		.mask_wr_en = GEN7_EN | GEN7_EN_WR,
+		.addr_rep_en = TOP_INFO_RPT,
+		.mask_rep_en = GEN7_RPT_EN,
+	},
+	{
+		.hw_num = GEN_PKT_HW8,
+		.addr_header = TOP_GEN8_HEADER,
+		.addr_pkt = TOP_GEN8_PKT00,
+		.addr_wr_en = TOP_INFO_EN,
+		.mask_wr_en = GEN8_EN | GEN8_EN_WR,
+		.addr_rep_en = TOP_INFO_RPT,
+		.mask_rep_en = GEN8_RPT_EN,
+	},
+	{
+		.hw_num = GEN_PKT_HW9,
+		.addr_header = TOP_GEN9_HEADER,
+		.addr_pkt = TOP_GEN9_PKT00,
+		.addr_wr_en = TOP_INFO_EN_EXPAND,
+		.mask_wr_en = GEN9_EN | GEN9_EN_WR,
+		.addr_rep_en = TOP_INFO_RPT,
+		.mask_rep_en = GEN9_RPT_EN,
+	},
+	{
+		.hw_num = GEN_PKT_HW10,
+		.addr_header = TOP_GEN10_HEADER,
+		.addr_pkt = TOP_GEN10_PKT00,
+		.addr_wr_en = TOP_INFO_EN_EXPAND,
+		.mask_wr_en = GEN10_EN | GEN10_EN_WR,
+		.addr_rep_en = TOP_INFO_RPT,
+		.mask_rep_en = GEN10_RPT_EN,
+	},
+	{
+		.hw_num = GEN_PKT_HW11,
+		.addr_header = TOP_GEN11_HEADER,
+		.addr_pkt = TOP_GEN11_PKT00,
+		.addr_wr_en = TOP_INFO_EN_EXPAND,
+		.mask_wr_en = GEN11_EN | GEN11_EN_WR,
+		.addr_rep_en = TOP_INFO_RPT,
+		.mask_rep_en = GEN11_RPT_EN,
+	},
+	{
+		.hw_num = GEN_PKT_HW12,
+		.addr_header = TOP_GEN12_HEADER,
+		.addr_pkt = TOP_GEN12_PKT00,
+		.addr_wr_en = TOP_INFO_EN_EXPAND,
+		.mask_wr_en = GEN12_EN | GEN12_EN_WR,
+		.addr_rep_en = TOP_INFO_RPT,
+		.mask_rep_en = GEN12_RPT_EN,
+	},
+	{
+		.hw_num = GEN_PKT_HW13,
+		.addr_header = TOP_GEN13_HEADER,
+		.addr_pkt = TOP_GEN13_PKT00,
+		.addr_wr_en = TOP_INFO_EN_EXPAND,
+		.mask_wr_en = GEN13_EN | GEN13_EN_WR,
+		.addr_rep_en = TOP_INFO_RPT,
+		.mask_rep_en = GEN13_RPT_EN,
+	},
+	{
+		.hw_num = GEN_PKT_HW14,
+		.addr_header = TOP_GEN14_HEADER,
+		.addr_pkt = TOP_GEN14_PKT00,
+		.addr_wr_en = TOP_INFO_EN_EXPAND,
+		.mask_wr_en = GEN14_EN | GEN14_EN_WR,
+		.addr_rep_en = TOP_INFO_RPT,
+		.mask_rep_en = GEN14_RPT_EN,
+	},
+	{
+		.hw_num = GEN_PKT_HW15,
+		.addr_header = TOP_GEN15_HEADER,
+		.addr_pkt = TOP_GEN15_PKT00,
+		.addr_wr_en = TOP_INFO_EN_EXPAND,
+		.mask_wr_en = GEN15_EN | GEN15_EN_WR,
+		.addr_rep_en = TOP_INFO_RPT,
+		.mask_rep_en = GEN15_RPT_EN,
+	},
+
+};
+
+char _bHdrType;
+char *_bHdrMetadataBuff;
+char _bStaticHdrType = GAMMA_ST2084;
+bool _fgLowLatencyDolbyVisionEnable;
+bool _fgBackltCtrlMDPresent;
+unsigned int _u4EffTmaxPQ;
+bool _fgBT2020Enable;
+bool _fgDolbyHdrEnable;
+bool _use_dolby_vsif;
+unsigned int _u4HdrDebugDisableType;
+char _bStaticHdrStatus = HDR_PACKET_DISABLE;
+bool dovi_off_delay_needed;
+
+void vHalEnablePacket(struct mtk_hdmi *hdmi,
+	struct PACKET_HW_T hw, bool en)
+{
+	if (en) {
+		mtk_hdmi_mask(hdmi, hw.addr_rep_en, hw.mask_rep_en, hw.mask_rep_en);
+		mtk_hdmi_mask(hdmi, hw.addr_wr_en, hw.mask_wr_en, hw.mask_wr_en);
+	} else {
+		mtk_hdmi_mask(hdmi, hw.addr_wr_en, 0, hw.mask_wr_en);
+		mtk_hdmi_mask(hdmi, hw.addr_rep_en, 0, hw.mask_rep_en);
+	}
+}
+
+void vHalSendPacket(struct mtk_hdmi *hdmi,
+	struct PACKET_HW_T hw, unsigned char hb[3], unsigned char pb[28])
+{
+	unsigned char i;
+
+	vHalEnablePacket(hdmi, hw, false);
+	mtk_hdmi_write(hdmi, hw.addr_header, (hb[2] << 16) +
+		(hb[1] << 8) + (hb[0] << 0));
+	for (i = 0; i < 4; i++) {
+		mtk_hdmi_write(hdmi, hw.addr_pkt + 8 * i,
+			(pb[3 + 7 * i] << 24) + (pb[2 + 7 * i] << 16) +
+			(pb[1 + 7 * i] << 8) + (pb[0 + 7 * i] << 0));
+		mtk_hdmi_write(hdmi, hw.addr_pkt + 8 * i + 4,
+			(pb[6 + 7 * i] << 16) + (pb[5 + 7 * i] << 8) +
+			(pb[4 + 7 * i] << 0));
+	}
+	vHalEnablePacket(hdmi, hw, true);
+
+	HDMI_HDR_LOG("hw_num=%d, hb[0-2]=0x%02x,0x%02x,0x%02x\n",
+		hw.hw_num, hb[0], hb[1], hb[2]);
+	HDMI_HDR_LOG("pb[0-27]=");
+	for (i = 0; i < EMP_SIZE_MAX; i++)
+		HDMI_HDR_LOG(",0x%02x", pb[i]);
+	HDMI_HDR_LOG("\n");
+}
+
+//can.zeng done->void vHalSendStaticHdrInfoFrame()
+void mtk_hdmi_hw_static_hdr_infoframe(
+	struct mtk_hdmi *hdmi, char bEnable, char *pr_bData)
+{
+
+	char bHDR_CHSUM = 0;
+	char i;
+
+	mtk_hdmi_mask(hdmi, TOP_INFO_EN, 0, GEN4_EN | GEN4_EN_WR);
+	mtk_hdmi_mask(hdmi, TOP_INFO_RPT, 0, GEN4_RPT_EN);
+
+	if (pr_bData == NULL)
+		return;
+
+	HDMI_HDR_LOG("bEnable = %d\n", bEnable);
+
+	if (bEnable == HDR_PACKET_ACTIVE) {
+		mtk_hdmi_write(hdmi, TOP_GEN4_HEADER, (HDR_LEN << 16) +
+			(HDR_VERS << 8) + (HDR_TYPE << 0));
+		bHDR_CHSUM = HDR_LEN + HDR_VERS + HDR_TYPE;
+		for (i = 0; i < HDR_LEN; i++)
+			bHDR_CHSUM += (*(pr_bData + i));
+		bHDR_CHSUM = 0x100 - bHDR_CHSUM;
+		mtk_hdmi_write(hdmi, TOP_GEN4_PKT00,
+			((*(pr_bData + 2)) << 24) + (*(pr_bData + 1) << 16) +
+			((*(pr_bData + 0)) << 8) + (bHDR_CHSUM << 0));
+		/* HDMI_HDR_LOG(" 1 data0=0x%x, data1=0x%x, data2=0x%x, data3=0x%x\n",
+		 *	(bHDR_CHSUM << 0), ((*(pr_bData + 0)) << 8),
+		 *	(*(pr_bData + 1) << 16), ((*(pr_bData + 2)) << 24));
+		 */
+		mtk_hdmi_write(hdmi, TOP_GEN4_PKT01,
+			(((*(pr_bData + 5)) << 16) + ((*(pr_bData + 4)) << 8) +
+			((*(pr_bData + 3)) << 0)));
+		/* HDMI_HDR_LOG(" 2 data0=0x%x, data1=0x%x, data2=0x%x\n",
+		 *	((*(pr_bData + 3)) << 0), ((*(pr_bData + 4)) << 8),
+		 *	((*(pr_bData + 5)) << 16));
+		 */
+		mtk_hdmi_write(hdmi, TOP_GEN4_PKT02,
+			((*(pr_bData + 9)) << 24) + ((*(pr_bData + 8)) << 16) +
+			((*(pr_bData + 7)) << 8) + ((*(pr_bData + 6)) << 0));
+		/* HDMI_HDR_LOG(" 3 data0=0x%x, data1=0x%x, data2=0x%x, data3=0x%x\n",
+		 *	((*(pr_bData + 6)) << 0), ((*(pr_bData + 7)) << 8),
+		 *	((*(pr_bData + 8)) << 16), ((*(pr_bData + 9)) << 24));
+		 */
+		mtk_hdmi_write(hdmi, TOP_GEN4_PKT03,
+			((*(pr_bData + 12)) << 16) + ((*(pr_bData + 11)) << 8) +
+			((*(pr_bData + 10)) << 0));
+		/* HDMI_HDR_LOG(" 4 data0=0x%x, data1=0x%x, data2=0x%x\n",
+		 *	((*(pr_bData + 10)) << 0), ((*(pr_bData + 11)) << 8),
+		 *	((*(pr_bData + 12)) << 16));
+		 */
+		mtk_hdmi_write(hdmi, TOP_GEN4_PKT04,
+			((*(pr_bData + 16)) << 24) + (*(pr_bData + 15) << 16) +
+			((*(pr_bData + 14)) << 8) + ((*(pr_bData + 13)) << 0));
+		/* HDMI_HDR_LOG(" 5 data0=0x%x, data1=0x%x, data2=0x%x, data3=0x%x\n",
+		 *	((*(pr_bData + 13)) << 0), ((*(pr_bData + 14)) << 8),
+		 *	(*(pr_bData + 15) << 16), ((*(pr_bData + 16)) << 24));
+		 */
+		mtk_hdmi_write(hdmi, TOP_GEN4_PKT05,
+			(*(pr_bData + 19) << 16) + ((*(pr_bData + 18)) << 8) +
+			((*(pr_bData + 17)) << 0));
+		/* HDMI_HDR_LOG(" 6 data0=0x%x, data1=0x%x, data2=0x%x\n",
+		 *	((*(pr_bData + 17)) << 0), ((*(pr_bData + 18)) << 8),
+		 *	(*(pr_bData + 19) << 16));
+		 */
+		mtk_hdmi_write(hdmi, TOP_GEN4_PKT06,
+			((*(pr_bData + 23)) << 24) + (*(pr_bData + 22) << 16) +
+			((*(pr_bData + 21)) << 8) + ((*(pr_bData + 20)) << 0));
+		/* HDMI_HDR_LOG(" 7 data0=0x%x, data1=0x%x, data2=0x%x, data3=0x%x\n",
+		 *	((*(pr_bData + 20)) << 0), ((*(pr_bData + 21)) << 8),
+		 *	(*(pr_bData + 22) << 16), ((*(pr_bData + 23)) << 24));
+		 */
+		mtk_hdmi_write(hdmi, TOP_GEN4_PKT07,
+			((*(pr_bData + 25)) << 8) + ((*(pr_bData + 24)) << 0));
+		/* HDMI_HDR_LOG(" 8 data0=0x%x, data1=0x%x\n",
+		 *	((*(pr_bData + 24)) << 0), ((*(pr_bData + 25)) << 8));
+		 */
+		mtk_hdmi_mask(hdmi, TOP_INFO_RPT, GEN4_RPT_EN, GEN4_RPT_EN);
+		mtk_hdmi_mask(hdmi, TOP_INFO_EN, GEN4_EN |
+			GEN4_EN_WR, GEN4_EN | GEN4_EN_WR);
+
+	} else if (bEnable == HDR_PACKET_ZERO) {
+		mtk_hdmi_write(hdmi, TOP_GEN4_HEADER,
+				  (HDR_LEN << 16) + (HDR_VERS << 8) +
+				  (HDR_TYPE << 0));
+		bHDR_CHSUM = HDR_LEN + HDR_VERS + HDR_TYPE;
+		bHDR_CHSUM = 0x100 - bHDR_CHSUM;
+		mtk_hdmi_write(hdmi, TOP_GEN4_PKT00, bHDR_CHSUM);
+		mtk_hdmi_write(hdmi, TOP_GEN4_PKT01, 0);
+		mtk_hdmi_write(hdmi, TOP_GEN4_PKT02, 0);
+		mtk_hdmi_write(hdmi, TOP_GEN4_PKT03, 0);
+		mtk_hdmi_write(hdmi, TOP_GEN4_PKT04, 0);
+		mtk_hdmi_write(hdmi, TOP_GEN4_PKT05, 0);
+		mtk_hdmi_write(hdmi, TOP_GEN4_PKT06, 0);
+		mtk_hdmi_write(hdmi, TOP_GEN4_PKT07, 0);
+
+		mtk_hdmi_mask(hdmi, TOP_INFO_RPT, GEN4_RPT_EN, GEN4_RPT_EN);
+		mtk_hdmi_mask(hdmi, TOP_INFO_EN, GEN4_EN |
+			GEN4_EN_WR, GEN4_EN | GEN4_EN_WR);
+
+	}
+
+}
+
+
+//can.zeng done->void vHalSendHdr10PlusVSIF()
+//can.zeng todo verify
+void mtk_hdmi_hw_samsung_hdr10p_vsif(
+	struct mtk_hdmi *hdmi, char bEnable,
+	union VID_HDR10_PLUS_METADATA_UNION_T *pr_bData)
+{
+	unsigned char i;
+	unsigned char HB[3] = {0};
+	unsigned char PB[DYNAMIC_HDR10P_VSIF_MAXLEN + 1] = {0};
+	unsigned char chsum = 0;
+	unsigned char size =
+		(unsigned char)(pr_bData->hdr10p_metadata_info.ui4_Hdr10PlusSize & 0xff);
+	unsigned char *meta =
+		(unsigned char *)(unsigned long)pr_bData->hdr10p_metadata_info.ui4_Hdr10PlusAddr;
+
+	if (size > DYNAMIC_HDR10P_VSIF_MAXLEN) {
+		HDMI_HDR_LOG("Error in %s,size=%d", __func__, size);
+		return;
+	}
+
+	HB[0] = 0x80 | DYNAMIC_HDR10P_VSIF_TYPE;
+	HB[1] = DYNAMIC_HDR10P_VSIF_VERSION;
+	HB[2] = size & 0x1f;
+	chsum = HB[0] + HB[1] + HB[2];
+	for (i = 0; i < size; i++) {
+		PB[i + 1] = *(meta + i);
+		chsum += PB[i + 1];
+	}
+	PB[0] = 0x100 - chsum;
+	vHalSendPacket(hdmi, pkthw[DYNAMIC_HDR10P_VSIF_PKTHW], HB, PB);
+}
+
+
+void vDynamicHdrEMP_HeaderInit(unsigned char *hb,
+	unsigned int *size,
+	unsigned char *sequence_index, char *first, char *last)
+{
+	*(hb + 0) = DYNAMIC_HDR_EMP_TYPE;
+	if (*size <= EMP_SIZE_FIRST) {
+		*first = 1;
+		*last = 1;
+		*sequence_index = 0;
+	} else if ((EMP_SIZE_FIRST + (*sequence_index) * EMP_SIZE_MAX) < *size) {
+		if (*sequence_index == 0)
+			*first = 1;
+		else
+			*first = 0;
+		*last = 0;
+	} else if ((EMP_SIZE_FIRST + (*sequence_index) * EMP_SIZE_MAX) >= *size) {
+		*first = 0;
+		*last = 1;
+	}
+	*(hb + 1) = (((*first) << 7) | ((*last) << 6)) & 0xc0;
+	*(hb + 2) = *sequence_index;
+}
+
+//can.zeng done->void vHalSendDynamicHdrEMPs()
+void mtk_hdmi_hw_dynamic_hdr_emp(struct mtk_hdmi *hdmi,
+	char bEnable, union VID_HDR10_PLUS_METADATA_UNION_T *pr_bData)
+{
+	unsigned char HB[3] = {0};
+	unsigned char PB[EMP_SIZE_MAX] = {0};
+	unsigned char i, pkthw_index;
+	unsigned char first, last, pb_new, pb_end, dataset_tagm,
+		dataset_tagl, dataset_lenm, dataset_lenl;
+	unsigned char sequence_index = 0;
+	unsigned int size = pr_bData->hdr10p_metadata_info
+		.ui4_Hdr10PlusSize;
+	unsigned char *meta =
+		(unsigned char *)(unsigned long)
+		pr_bData->hdr10p_metadata_info
+		.ui4_Hdr10PlusAddr;
+	struct PACKET_HW_T pkthw_list[GEN_PKT_HW_NUM] = {
+		pkthw[GEN_PKT_HW1], pkthw[GEN_PKT_HW2],
+		pkthw[GEN_PKT_HW3], pkthw[GEN_PKT_HW4],
+		pkthw[GEN_PKT_HW5], pkthw[GEN_PKT_HW6],
+		pkthw[GEN_PKT_HW7], pkthw[GEN_PKT_HW8],
+		pkthw[GEN_PKT_HW9], pkthw[GEN_PKT_HW10],
+		pkthw[GEN_PKT_HW11], pkthw[GEN_PKT_HW12],
+		pkthw[GEN_PKT_HW13], pkthw[GEN_PKT_HW14],
+		pkthw[GEN_PKT_HW15],
+	};
+
+	HDMI_HDR_LOG("meta=%p, size=%d\n", meta, size);
+	/*tset_size[0-3]=78,56,34,12  */
+
+	for (pkthw_index = 0; pkthw_index < GEN_PKT_HW_NUM; pkthw_index++)
+		vHalEnablePacket(hdmi, pkthw_list[pkthw_index], false);
+	vDynamicHdrEMP_HeaderInit(HB, &size, &sequence_index, &first, &last);
+
+	if (first) {
+		pb_new = 1;
+		pb_end = 0;
+		dataset_tagm = 0x00;
+		dataset_tagl = 0x04;
+		dataset_lenm = (unsigned char)((size >> 8) & 0xff);
+		dataset_lenl = (unsigned char)(size & 0xff);
+		PB[0] = (pb_new << 7) | (pb_end << 6) |
+			(DYNAMIC_HDR_EMP_DS_TYPE << 4) |
+			(DYNAMIC_HDR_EMP_AFR  << 3) |
+			(DYNAMIC_HDR_EMP_VFR << 2) |
+			(DYNAMIC_HDR_EMP_SYNC << 1);
+		PB[1] = 0;
+		PB[2] = DYNAMIC_HDR_EMP_ORGID;
+		PB[3] = dataset_tagm;
+		PB[4] = dataset_tagl;
+		PB[5] = dataset_lenm;
+		PB[6] = dataset_lenl;
+
+		if (last)
+			for (i = 0; i < size; i++)
+				*(PB + 7 + i) = *(meta + i);
+		else
+			for (i = 0; i < EMP_SIZE_FIRST; i++)
+				*(PB + 7 + i) = *(meta + i);
+
+		pkthw_index = (sequence_index % GEN_PKT_HW_NUM);
+		vHalSendPacket(hdmi, pkthw_list[pkthw_index], HB, PB);
+		sequence_index++;
+		if (last) {
+			HDMI_HDR_LOG("Return in first\n");
+			return;
+		}
+	}
+
+	vDynamicHdrEMP_HeaderInit(HB, &size, &sequence_index, &first, &last);
+	while (last == 0) {
+		for (i = 0; i < EMP_SIZE_MAX; i++)
+			*(PB + i) = (*(meta + ((sequence_index - 1) *
+			EMP_SIZE_MAX) + EMP_SIZE_FIRST + i));
+		pkthw_index = (sequence_index % GEN_PKT_HW_NUM);
+		vHalSendPacket(hdmi, pkthw_list[pkthw_index], HB, PB);
+		sequence_index++;
+		vDynamicHdrEMP_HeaderInit(HB, &size,
+			&sequence_index, &first, &last);
+	};
+
+	for (i = 0; i < EMP_SIZE_MAX; i++)
+		*(PB + i) = 0;
+
+	HDMI_HDR_LOG("%s(),%d ,left size=%d\n", __func__, __LINE__,
+		(size - ((sequence_index - 1) * EMP_SIZE_MAX) -
+		EMP_SIZE_FIRST));
+	for (i = 0; i < (size - ((sequence_index - 1) *
+		EMP_SIZE_MAX) - EMP_SIZE_FIRST); i++)
+		*(PB + i) = (*(meta + ((sequence_index - 1) *
+		EMP_SIZE_MAX) + EMP_SIZE_FIRST + i));
+	pkthw_index = (sequence_index % GEN_PKT_HW_NUM);
+	vHalSendPacket(hdmi, pkthw_list[pkthw_index], HB, PB);
+	sequence_index = 0;
+}
+
+
+//can.zeng done-> void vHalSendDolbyVSIF()
+void mtk_hdmi_hw_dolby_vsif(
+	struct mtk_hdmi *hdmi, bool fgEnable,
+	bool fgLowLatency, bool fgDolbyVisionSignal,
+	bool fgBackltCtrlMdPresent, unsigned int u4EfftmaxPQ)
+{
+	unsigned char bData[6];
+	unsigned char bHDR_CHSUM = 0;
+	unsigned char i;
+
+	mtk_hdmi_mask(hdmi, TOP_INFO_EN, 0, GEN5_EN | GEN5_EN_WR);
+	mtk_hdmi_mask(hdmi, TOP_INFO_RPT, 0, GEN5_RPT_EN);
+
+	if (fgEnable) {
+		bData[0] = 0x46;
+		bData[1] = 0xD0;
+		bData[2] = 0x00;
+		bData[3] = (fgDolbyVisionSignal << 1) | fgLowLatency;
+		bData[4] = (fgBackltCtrlMdPresent << 7) |
+			((u4EfftmaxPQ >> 8) & 0x0F);
+		bData[5] = u4EfftmaxPQ & 0xFF;
+		if (fgLowLatency)
+			bData[3] |= 1;
+		if (fgDolbyVisionSignal)
+			bData[3] |= (1 << 1);
+		if (fgBackltCtrlMdPresent)
+			bData[4] |= (1 << 7);
+
+		mtk_hdmi_write(hdmi, TOP_GEN5_HEADER,
+			(DOLBYVSIF_LEN << 16) + (DOLBYVSIF_VERS << 8) +
+			(DOLBYVSIF_TYPE << 0));
+		bHDR_CHSUM = DOLBYVSIF_LEN + DOLBYVSIF_VERS + DOLBYVSIF_TYPE;
+		for (i = 0; i < 6; i++)
+			bHDR_CHSUM += bData[i];
+		bHDR_CHSUM = 0x100 - bHDR_CHSUM;
+		mtk_hdmi_write(hdmi, TOP_GEN5_PKT00,
+			(bData[2] << 24) + (bData[1] << 16) +
+			(bData[0] << 8) + (bHDR_CHSUM << 0));
+		mtk_hdmi_write(hdmi, TOP_GEN5_PKT01, (bData[5] << 16) +
+			(bData[4] << 8) + (bData[3] << 0));
+		mtk_hdmi_write(hdmi, TOP_GEN5_PKT02, 0);
+		mtk_hdmi_write(hdmi, TOP_GEN5_PKT03, 0);
+		mtk_hdmi_write(hdmi, TOP_GEN5_PKT04, 0);
+		mtk_hdmi_write(hdmi, TOP_GEN5_PKT05, 0);
+		mtk_hdmi_write(hdmi, TOP_GEN5_PKT06, 0);
+		mtk_hdmi_write(hdmi, TOP_GEN5_PKT07, 0);
+		mtk_hdmi_mask(hdmi, TOP_INFO_RPT, GEN5_RPT_EN, GEN5_RPT_EN);
+		mtk_hdmi_mask(hdmi, TOP_INFO_EN, GEN5_EN |
+			GEN5_EN_WR, GEN5_EN | GEN5_EN_WR);
+	}
+}
+
+void vHdr10PlusVSIF_ZeroPacket(void)
+{
+	char testbuf[27] = {0};
+	struct VID_PLA_HDR_METADATA_INFO_T hdr_metadata;
+
+	hdr_metadata.e_DynamicRangeType = VID_PLA_DR_TYPE_HDR10_PLUS_VSIF;
+	hdr_metadata.metadata_info.hdr10_plus_metadata
+		.hdr10p_metadata_info.ui4_Hdr10PlusSize =
+		27;
+	hdr_metadata.metadata_info.hdr10_plus_metadata
+		.hdr10p_metadata_info.ui4_Hdr10PlusAddr =
+		(unsigned long)(&testbuf);
+	vVdpSetHdrMetadata(true, hdr_metadata);
+}
+
+void Hdr10OffImmediately(void)
+{
+	struct mtk_hdmi *hdmi = global_mtk_hdmi;
+
+	if (!hdmi)
+		return;
+
+	if (_bHdrType == VID_PLA_DR_TYPE_HDR10 ||
+		_bHdrType == VID_PLA_DR_TYPE_HDR10_PLUS_VSIF) {
+		_bStaticHdrStatus = HDR_PACKET_DISABLE;
+		mtk_hdmi_hw_static_hdr_infoframe(hdmi, _bStaticHdrStatus,
+			_bHdrMetadataBuff);
+		if (_bHdrType == VID_PLA_DR_TYPE_HDR10)
+			_bHdrType = VID_PLA_DR_TYPE_SDR;
+		HDMI_HDR_LOG("HDR10 off done\n");
+	} else
+		HDMI_HDR_LOG("HDR10 already off\n");
+}
+
+void Hdr10pVsifOffImmediately(void)
+{
+	struct PACKET_HW_T mpkthw = pkthw[DYNAMIC_HDR10P_VSIF_PKTHW];
+	struct mtk_hdmi *hdmi = global_mtk_hdmi;
+
+	if (!hdmi)
+		return;
+
+	if (_bHdrType == VID_PLA_DR_TYPE_HDR10_PLUS_VSIF) {
+		vHalEnablePacket(hdmi, mpkthw, false);
+		if (_bHdrType == VID_PLA_DR_TYPE_HDR10_PLUS_VSIF)
+			_bHdrType = VID_PLA_DR_TYPE_SDR;
+		HDMI_HDR_LOG("Hdr10pVsif off done\n");
+	} else
+		HDMI_HDR_LOG("Hdr10pVsif already off\n");
+}
+
+void HdrDelayAllOffImmediately(void)
+{
+	Hdr10OffImmediately();
+	Hdr10pVsifOffImmediately();
+}
+
+
+static void hdmi_hdr_mutex_init(struct mutex *lock)
+{
+	mutex_init(lock);
+}
+
+static void hdmi_hdr_mutex_lock(struct mutex *lock)
+{
+	if (mutex_is_locked(lock)) {
+		pr_info("ERROR: HDR Lock has been locked, return\n");
+		return;
+	}
+	mutex_lock(lock);
+}
+
+static void hdmi_hdr_mutex_unlock(struct mutex *lock)
+{
+	if (!mutex_is_locked(lock)) {
+		pr_info("ERROR: HDR Lock not locked, return\n");
+		return;
+	}
+	mutex_unlock(lock);
+}
+
+void vSetStaticHdrType(enum VID_GAMMA_T bType)
+{
+	struct mtk_hdmi *hdmi = global_mtk_hdmi;
+
+	if (!hdmi)
+		return;
+
+	hdmi_hdr_mutex_lock(&hdmi->hdr_mutex);
+
+	if (_bHdrMetadataBuff == NULL)
+		return;
+
+	if (bType == GAMMA_HLG) {
+		_bStaticHdrType = GAMMA_HLG;
+		*_bHdrMetadataBuff = 0x03;	/* EOTF */
+	} else {
+		_bStaticHdrType = GAMMA_ST2084;
+		*_bHdrMetadataBuff = 0x02;	/* EOTF */
+	}
+
+	HDMI_HDR_LOG("bType = %d, _bStaticHdrType =%d\n", bType, _bStaticHdrType);
+
+	hdmi_hdr_mutex_unlock(&hdmi->hdr_mutex);
+
+}
+EXPORT_SYMBOL(vSetStaticHdrType);
+
+void vVdpSetHdrMetadata(bool enable,
+	struct VID_PLA_HDR_METADATA_INFO_T hdr_metadata)
+{
+	struct HDMI_STATIC_METADATA_INFO_T _bStaticHdrMetadata;
+	bool fgMetadataSame = false;
+	struct mtk_hdmi *hdmi = global_mtk_hdmi;
+
+	if (!hdmi)
+		return;
+
+	if (_u4HdrDebugDisableType & HDR_DEBUG_DISABLE_METADATA)
+		return;
+
+	if (_bHdrMetadataBuff == NULL) {
+		HDMI_HDR_LOG("ERROR:MetadataBuff is NULL\n");
+		return;
+	}
+
+	hdmi_hdr_mutex_lock(&hdmi->hdr_mutex);
+
+	HDMI_HDR_LOG("set HDR metadata Type=%d\n",
+		hdr_metadata.e_DynamicRangeType);
+
+	if (hdr_metadata.e_DynamicRangeType == VID_PLA_DR_TYPE_HDR10) {
+		if (_bStaticHdrType == GAMMA_HLG)
+			_bStaticHdrMetadata.ui1_EOTF = 0x03;	/* HLG */
+		else
+			_bStaticHdrMetadata.ui1_EOTF = 0x02;	/* 2084 */
+
+		_bStaticHdrMetadata.ui1_Static_Metadata_ID = 0;
+		_bStaticHdrMetadata.ui2_DisplayPrimariesX0 =
+		    hdr_metadata.metadata_info.hdr10_metadata
+		    .ui2_DisplayPrimariesX[0];
+		_bStaticHdrMetadata.ui2_DisplayPrimariesY0 =
+		    hdr_metadata.metadata_info.hdr10_metadata
+		    .ui2_DisplayPrimariesY[0];
+		_bStaticHdrMetadata.ui2_DisplayPrimariesX1 =
+		    hdr_metadata.metadata_info.hdr10_metadata
+		    .ui2_DisplayPrimariesX[1];
+		_bStaticHdrMetadata.ui2_DisplayPrimariesY1 =
+		    hdr_metadata.metadata_info.hdr10_metadata
+		    .ui2_DisplayPrimariesY[1];
+		_bStaticHdrMetadata.ui2_DisplayPrimariesX2 =
+		    hdr_metadata.metadata_info.hdr10_metadata
+		    .ui2_DisplayPrimariesX[2];
+		_bStaticHdrMetadata.ui2_DisplayPrimariesY2 =
+		    hdr_metadata.metadata_info.hdr10_metadata
+		    .ui2_DisplayPrimariesY[2];
+		_bStaticHdrMetadata.ui2_WhitePointX =
+		    hdr_metadata.metadata_info.hdr10_metadata.ui2_WhitePointX;
+		_bStaticHdrMetadata.ui2_WhitePointY =
+		    hdr_metadata.metadata_info.hdr10_metadata.ui2_WhitePointY;
+		_bStaticHdrMetadata.ui2_MaxDisplayMasteringLuminance =
+		    hdr_metadata
+		    .metadata_info
+		    .hdr10_metadata.ui2_MaxDisplayMasteringLuminance;
+		_bStaticHdrMetadata.ui2_MinDisplayMasteringLuminance =
+		    hdr_metadata
+		    .metadata_info
+		    .hdr10_metadata.ui2_MinDisplayMasteringLuminance;
+		_bStaticHdrMetadata.ui2_MaxCLL =
+		    hdr_metadata.metadata_info.hdr10_metadata.ui2_MaxCLL;
+		_bStaticHdrMetadata.ui2_MaxFALL =
+		    hdr_metadata.metadata_info.hdr10_metadata.ui2_MaxFALL;
+
+		HDMI_HDR_LOG(" set HDR ui2_DisplayPrimariesX0=0x%x\n",
+			      _bStaticHdrMetadata.ui2_DisplayPrimariesX0);
+		HDMI_HDR_LOG(" set HDR ui2_DisplayPrimariesY0=0x%x\n",
+			      _bStaticHdrMetadata.ui2_DisplayPrimariesY0);
+		HDMI_HDR_LOG(" set HDR ui2_DisplayPrimariesX1=0x%x\n",
+			      _bStaticHdrMetadata.ui2_DisplayPrimariesX1);
+		HDMI_HDR_LOG(" set HDR ui2_DisplayPrimariesY1=0x%x\n",
+			      _bStaticHdrMetadata.ui2_DisplayPrimariesY1);
+		HDMI_HDR_LOG(" set HDR ui2_DisplayPrimariesX2=0x%x\n",
+			      _bStaticHdrMetadata.ui2_DisplayPrimariesX2);
+		HDMI_HDR_LOG(" set HDR ui2_DisplayPrimariesY2=0x%x\n",
+			      _bStaticHdrMetadata.ui2_DisplayPrimariesX2);
+		HDMI_HDR_LOG(" set HDR ui2_WhitePointX=0x%x\n",
+			      _bStaticHdrMetadata.ui2_WhitePointX);
+		HDMI_HDR_LOG(" set HDR ui2_WhitePointY=0x%x\n",
+			      _bStaticHdrMetadata.ui2_WhitePointY);
+		HDMI_HDR_LOG(" set HDR ui2_MaxDisplayMasteringLuminance=0x%x\n",
+			      _bStaticHdrMetadata
+			      .ui2_MaxDisplayMasteringLuminance);
+		HDMI_HDR_LOG(" set HDR ui2_MinDisplayMasteringLuminance=0x%x\n",
+			      _bStaticHdrMetadata
+			      .ui2_MinDisplayMasteringLuminance);
+		HDMI_HDR_LOG(" set HDR ui2_MaxCLL=0x%x\n",
+			      _bStaticHdrMetadata.ui2_MaxCLL);
+		memcpy(_bHdrMetadataBuff, &_bStaticHdrMetadata,
+			sizeof(struct HDMI_STATIC_METADATA_INFO_T));
+		mtk_hdmi_hw_static_hdr_infoframe(hdmi, _bStaticHdrStatus, _bHdrMetadataBuff);
+	} else if (hdr_metadata.e_DynamicRangeType == VID_PLA_DR_TYPE_DOVI_LOWLATENCY) {
+		if ((_fgBackltCtrlMDPresent ==
+		hdr_metadata.metadata_info.dovi_lowlatency_metadata.fgBackltCtrlMdPresent)
+		&& (_u4EffTmaxPQ ==
+		hdr_metadata.metadata_info.dovi_lowlatency_metadata.ui4_EffTmaxPQ)) {
+			fgMetadataSame = true;
+		} else {
+			_fgBackltCtrlMDPresent  =
+			 hdr_metadata.metadata_info.dovi_lowlatency_metadata.fgBackltCtrlMdPresent;
+			if (_fgBackltCtrlMDPresent)
+				_u4EffTmaxPQ =
+				hdr_metadata.metadata_info.dovi_lowlatency_metadata.ui4_EffTmaxPQ;
+			else
+				_u4EffTmaxPQ = 0;
+			HDMI_HDR_LOG(" %d, _u4EffTmaxPQ =0x%x\n ",
+				_fgBackltCtrlMDPresent, _u4EffTmaxPQ);
+		}
+		if ((!fgMetadataSame) && _fgLowLatencyDolbyVisionEnable)
+			mtk_hdmi_hw_dolby_vsif(hdmi, true, true, true,
+			_fgBackltCtrlMDPresent, _u4EffTmaxPQ);
+	} else if (hdr_metadata.e_DynamicRangeType == VID_PLA_DR_TYPE_HDR10_PLUS) {
+		HDMI_HDR_LOG("HDR10+\n");
+		mtk_hdmi_hw_dynamic_hdr_emp(hdmi, enable,
+			&(hdr_metadata.metadata_info.hdr10_plus_metadata));
+	} else if (hdr_metadata.e_DynamicRangeType == VID_PLA_DR_TYPE_HDR10_PLUS_VSIF) {
+		HDMI_HDR_LOG("HDR10+ VSIF\n");
+		mtk_hdmi_hw_samsung_hdr10p_vsif(hdmi, enable,
+			&(hdr_metadata.metadata_info.hdr10_plus_metadata));
+	}
+
+	hdmi_hdr_mutex_unlock(&hdmi->hdr_mutex);
+}
+EXPORT_SYMBOL(vVdpSetHdrMetadata);
+
+//can.zeng modification done->void vHDMIVideoOutput(char ui1ColorSpace)
+void mtk_hdmi_colorspace_setting(struct mtk_hdmi *hdmi)
+{
+	unsigned int video_mute;
+
+	video_mute = mtk_hdmi_read(hdmi, TOP_VMUTE_CFG1) & REG_VMUTE_EN;
+	/* keep the video mute bit to avoid screen flicker */
+
+	if ((hdmi->csp == HDMI_COLORSPACE_YUV444) ||
+		(hdmi->csp == HDMI_COLORSPACE_YUV420)) {
+		mtk_hdmi_write(hdmi, TOP_VMUTE_CFG1, 0x8000 | video_mute);
+		mtk_hdmi_write(hdmi, TOP_VMUTE_CFG2, 0x80001000);
+	} else if (hdmi->csp == HDMI_COLORSPACE_YUV422) {
+		mtk_hdmi_write(hdmi, TOP_VMUTE_CFG1, 0x8000 | video_mute);
+		mtk_hdmi_write(hdmi, TOP_VMUTE_CFG2, 0x00001000);
+	} else {
+		mtk_hdmi_write(hdmi, TOP_VMUTE_CFG1, 0x1000 | video_mute);
+		mtk_hdmi_write(hdmi, TOP_VMUTE_CFG2, 0x10001000);
+	}
+
+	if (_fgLowLatencyDolbyVisionEnable) {
+		/* in current solution, when low latency dolby vision,
+		 * ETHDR only send colorspace format ycbcr422
+		 */
+		mtk_hdmi_write(hdmi, TOP_VMUTE_CFG1, 0x8000 | video_mute);
+		mtk_hdmi_write(hdmi, TOP_VMUTE_CFG2, 0x00001000);
+	}
+	if (_fgDolbyHdrEnable) {
+		/* DolbyVision case: not mute video to avoid destroy metadata */
+		mtk_hdmi_write(hdmi, TOP_VMUTE_CFG1, 0x8000);
+		mtk_hdmi_write(hdmi, TOP_VMUTE_CFG2, 0x80001000);
+	}
+}
+
+void vBT2020Enable(bool fgEnable)
+{
+	struct mtk_hdmi *hdmi = global_mtk_hdmi;
+
+	if (!hdmi)
+		return;
+
+	if (_u4HdrDebugDisableType & HDR_DEBUG_DISABLE_BT2020)
+		return;
+
+	hdmi_hdr_mutex_lock(&hdmi->hdr_mutex);
+
+	HDMI_HDR_LOG(" _fgBT2020Enable =%d\n", fgEnable);
+	_fgBT2020Enable = fgEnable;
+	//can.zeng todo verify how to process avi infoframe
+	mtk_hdmi_setup_avi_infoframe(hdmi, &hdmi->mode);
+	mtk_hdmi_colorspace_setting(hdmi);
+
+	hdmi_hdr_mutex_unlock(&hdmi->hdr_mutex);
+}
+EXPORT_SYMBOL(vBT2020Enable);
+
+//can.zeng modification done->void vHdrEnable(bool fgEnable)
+void vHdr10Enable(bool fgEnable)
+{
+	struct mtk_hdmi *hdmi = global_mtk_hdmi;
+
+	if (!hdmi)
+		return;
+
+	if (_u4HdrDebugDisableType & HDR_DEBUG_DISABLE_HDR)
+		return;
+
+	hdmi_hdr_mutex_lock(&hdmi->hdr_mutex);
+
+	HDMI_HDR_LOG("fgEnable = %d, _bStaticHdrStatus =%d,  _bHdrType=%d\n",
+		fgEnable, _bStaticHdrStatus, _bHdrType);
+
+	if (fgEnable) {
+		HdrDelayAllOffImmediately();
+		_bStaticHdrStatus = HDR_PACKET_ACTIVE;
+		mtk_hdmi_hw_static_hdr_infoframe(hdmi, _bStaticHdrStatus, _bHdrMetadataBuff);
+		_bHdrType = VID_PLA_DR_TYPE_HDR10;
+	} else {
+		if (_bStaticHdrStatus == HDR_PACKET_ACTIVE) {
+			_bStaticHdrStatus = HDR_PACKET_ZERO;
+			mtk_hdmi_hw_static_hdr_infoframe(hdmi, _bStaticHdrStatus,
+				_bHdrMetadataBuff);
+			//vSetHdr10TimeDelayOff(2000);
+			/* per HDMI specification: shall send HDR10 zero packet
+			 * for two 2seconds then stop HDR10 packet
+			 */
+			queue_delayed_work(hdmi->hdmi_wq, &hdmi->hdr10_delay_work,
+				msecs_to_jiffies(2000));
+			HDMI_HDR_LOG("HDR10 SET TIMER\n");
+		}
+	}
+
+	hdmi_hdr_mutex_unlock(&hdmi->hdr_mutex);
+}
+EXPORT_SYMBOL(vHdr10Enable);
+
+void vHdr10PlusEnable(bool fgEnable)
+{
+	unsigned char pkthw_index;
+	struct mtk_hdmi *hdmi = global_mtk_hdmi;
+
+	if (!hdmi)
+		return;
+
+	hdmi_hdr_mutex_lock(&hdmi->hdr_mutex);
+
+	HDMI_HDR_LOG("fgEnable=%d\n", fgEnable);
+	if (fgEnable) {
+		HdrDelayAllOffImmediately();
+		for (pkthw_index = 0; pkthw_index < GEN_PKT_HW_NUM; pkthw_index++)
+			vHalEnablePacket(hdmi, pkthw[pkthw_index], true);
+		_bHdrType = VID_PLA_DR_TYPE_HDR10_PLUS;
+	} else {
+		for (pkthw_index = 0; pkthw_index < GEN_PKT_HW_NUM; pkthw_index++)
+			vHalEnablePacket(hdmi, pkthw[pkthw_index], false);
+		_bHdrType = VID_PLA_DR_TYPE_SDR;
+	}
+
+	hdmi_hdr_mutex_unlock(&hdmi->hdr_mutex);
+}
+EXPORT_SYMBOL(vHdr10PlusEnable);
+
+void vHdr10PlusVSIFEnable(bool fgEnable)
+{
+	struct PACKET_HW_T mpkthw = pkthw[DYNAMIC_HDR10P_VSIF_PKTHW];
+	struct mtk_hdmi *hdmi = global_mtk_hdmi;
+
+	if (!hdmi)
+		return;
+
+	hdmi_hdr_mutex_lock(&hdmi->hdr_mutex);
+
+	HDMI_HDR_LOG("fgEnable=%d\n", fgEnable);
+
+	if (fgEnable) {
+		HdrDelayAllOffImmediately();
+		vHalEnablePacket(hdmi, mpkthw, true);
+		_bHdrType = VID_PLA_DR_TYPE_HDR10_PLUS_VSIF;
+	} else {
+		vHdr10PlusVSIF_ZeroPacket();
+		//vSetHdr10pVsifTimeDelayOff(2000);
+		queue_delayed_work(hdmi->hdmi_wq, &hdmi->hdr10vsif_delay_work,
+			msecs_to_jiffies(2000));
+	}
+
+	hdmi_hdr_mutex_unlock(&hdmi->hdr_mutex);
+}
+EXPORT_SYMBOL(vHdr10PlusVSIFEnable);
+
+void vDolbyHdrEnable(bool fgEnable, bool use_dolby_vsif)
+{
+	struct mtk_hdmi *hdmi = global_mtk_hdmi;
+
+	if (!hdmi)
+		return;
+
+	if (_u4HdrDebugDisableType & HDR_DEBUG_DISABLE_DOLBY_HDR)
+		return;
+
+	hdmi_hdr_mutex_lock(&hdmi->hdr_mutex);
+
+	dovi_off_delay_needed = false;
+	if ((_fgDolbyHdrEnable == true) && (fgEnable == false))
+		dovi_off_delay_needed = true;
+
+	HDMI_HDR_LOG("fgEnable=%d, use_dolby_vsif=%d\n", fgEnable, use_dolby_vsif);
+	_fgDolbyHdrEnable = fgEnable;
+	_use_dolby_vsif = use_dolby_vsif;
+
+	if (fgEnable) {
+#ifdef CANZENG_TODO_VERIFY
+		//can.zeng todo, not link to TA temporarily
+		vCaHDMIWriteHdcpCtrl(0x88880000, 0xaaaa5551);
+#endif
+		HdrDelayAllOffImmediately();
+		if (use_dolby_vsif)
+			mtk_hdmi_hw_dolby_vsif(hdmi, true, false, true, 0, 0);
+		else
+			mtk_hdmi_setup_h14b_vsif(hdmi, &hdmi->mode);
+		_bHdrType = VID_PLA_DR_TYPE_DOVI;
+	} else {
+#ifdef CANZENG_TODO_VERIFY
+		vCaHDMIWriteHdcpCtrl(0x88880000, 0xaaaa5550);
+#endif
+		if (use_dolby_vsif)
+			mtk_hdmi_hw_dolby_vsif(hdmi, true, 0, 0, 0, 0);
+		else
+			mtk_hdmi_setup_h14b_vsif(hdmi, &hdmi->mode);
+		_bHdrType = VID_PLA_DR_TYPE_SDR;
+	}
+	mtk_hdmi_setup_avi_infoframe(hdmi, &hdmi->mode);
+	mtk_hdmi_colorspace_setting(hdmi);
+
+	hdmi_hdr_mutex_unlock(&hdmi->hdr_mutex);
+}
+EXPORT_SYMBOL(vDolbyHdrEnable);
+
+void vLowLatencyDolbyVisionEnable(bool fgEnable)
+{
+	struct mtk_hdmi *hdmi = global_mtk_hdmi;
+
+	if (!hdmi)
+		return;
+
+	if (fgEnable == _fgLowLatencyDolbyVisionEnable)
+		return;
+
+	hdmi_hdr_mutex_lock(&hdmi->hdr_mutex);
+
+	HDMI_HDR_LOG("fgEnable=%d\n", fgEnable);
+	_fgLowLatencyDolbyVisionEnable = fgEnable;
+
+	if (fgEnable) {
+		HdrDelayAllOffImmediately();
+		vBT2020Enable(true);
+		mtk_hdmi_hw_dolby_vsif(hdmi, true, true, true,
+			_fgBackltCtrlMDPresent, _u4EffTmaxPQ);
+		//low latency Dolby Vision use DolbyVSIF
+		//mtk_hdmi_setup_h14b_vsif(hdmi, &hdmi->mode);
+		_bHdrType = VID_PLA_DR_TYPE_DOVI_LOWLATENCY;
+	} else {
+		vBT2020Enable(false);
+		mtk_hdmi_hw_dolby_vsif(hdmi, true, 0, 0, 0, 0);
+		//low latency Dolby Vision use DolbyVSIF
+		//mtk_hdmi_setup_h14b_vsif(hdmi, &hdmi->mode);
+		_bHdrType = VID_PLA_DR_TYPE_SDR;
+	}
+
+	hdmi_hdr_mutex_unlock(&hdmi->hdr_mutex);
+}
+EXPORT_SYMBOL(vLowLatencyDolbyVisionEnable);
+
+void Hdr10DelayOffHandler(struct work_struct *data)
+{
+	HDMI_HDR_FUNC();
+	if (_bStaticHdrStatus == HDR_PACKET_ZERO) {
+		Hdr10OffImmediately();
+		HDMI_HDR_LOG("[delay]HDR10 off done\n");
+	} else
+		HDMI_HDR_LOG("[delay]HDR10 already off\n");
+
+}
+
+void Hdr10pVsifDelayOffHandler(struct work_struct *data)
+{
+	HDMI_HDR_FUNC();
+	Hdr10OffImmediately();
+	Hdr10pVsifOffImmediately();
+	HDMI_HDR_LOG("[delay]HDR10VSIF off done\n");
+}
+
+void vInitHdr(void)
+{
+	struct HDMI_STATIC_METADATA_INFO_T initbuf;
+	struct mtk_hdmi *hdmi = global_mtk_hdmi;
+
+	if (!hdmi)
+		return;
+
+	HDMI_HDR_FUNC();
+
+	hdmi_hdr_mutex_init(&hdmi->hdr_mutex);
+
+	_bHdrMetadataBuff = kmalloc(256, GFP_KERNEL);
+	if (_bHdrMetadataBuff == NULL)
+		HDMI_HDR_LOG("[HDR] vInitHdrMetadata Buffer NULL\n");
+
+	initbuf.ui1_EOTF = 0x02;
+	initbuf.ui1_Static_Metadata_ID = 0;
+	initbuf.ui2_DisplayPrimariesX0 = 35400;
+	initbuf.ui2_DisplayPrimariesY0 = 14600;
+	initbuf.ui2_DisplayPrimariesX1 = 8500;
+	initbuf.ui2_DisplayPrimariesY1 = 39850;
+	initbuf.ui2_DisplayPrimariesX2 = 6550;
+	initbuf.ui2_DisplayPrimariesY2 = 2300;
+	initbuf.ui2_WhitePointX = 15635;
+	initbuf.ui2_WhitePointY = 16450;
+	initbuf.ui2_MaxDisplayMasteringLuminance = 1000;
+	initbuf.ui2_MinDisplayMasteringLuminance = 50;
+	initbuf.ui2_MaxCLL = 1000;
+	initbuf.ui2_MaxFALL = 400;
+	memcpy(_bHdrMetadataBuff, &initbuf,
+		sizeof(struct HDMI_STATIC_METADATA_INFO_T));
+
+	_u4HdrDebugDisableType = 0;
+
+	_fgBT2020Enable = 0;
+	_bHdrType = VID_PLA_DR_TYPE_SDR;
+
+}
+
+void reset_hdmi_hdr_status(void)
+{
+	_bHdrType = VID_PLA_DR_TYPE_SDR;
+	_bStaticHdrType = GAMMA_ST2084;
+	_fgLowLatencyDolbyVisionEnable = false;
+	_fgBackltCtrlMDPresent = false;
+	_fgBT2020Enable = false;
+	_fgDolbyHdrEnable = false;
+	_use_dolby_vsif = false;
+	_bStaticHdrStatus = HDR_PACKET_DISABLE;
+	memset(_bHdrMetadataBuff, 0,
+		sizeof(struct HDMI_STATIC_METADATA_INFO_T));
+}
diff --git a/drivers/gpu/drm/mediatek/mediatek_v2/mtk_hdmi_hdr.h b/drivers/gpu/drm/mediatek/mediatek_v2/mtk_hdmi_hdr.h
new file mode 100644
index 0000000000000000000000000000000000000000..1e4227b1385db3d3d59696801fa99dced61c59df
--- /dev/null
+++ b/drivers/gpu/drm/mediatek/mediatek_v2/mtk_hdmi_hdr.h
@@ -0,0 +1,195 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2019 MediaTek Inc.
+ */
+
+#ifndef _MTK_HDR_H
+#define _MTK_HDR_H
+
+#include "mtk_hdmi.h"
+
+#define HDR_DEBUG_DISABLE_METADATA        (1<<0)
+#define HDR_DEBUG_DISABLE_HDR             (1<<1)
+#define HDR_DEBUG_DISABLE_BT2020          (1<<2)
+#define HDR_DEBUG_DISABLE_DOLBY_HDR       (1<<3)
+#define HDR_DEBUG_DISABLE_PHI_HDR         (1<<4)
+
+#define DOVI_METADATA_MAX_LENGTH 100
+#define PHLP_METADATA_MAX_LENGTH 100
+#define HDR10_PLUS_METADATA_MAX_LENGTH 100
+
+#define HDR_TYPE            0x87
+#define HDR_VERS            0x01
+#define HDR_LEN             0x1A
+
+/* Phi Hdr Info Frame */
+#define PHI_HDR_TYPE            0x81
+#define PHI_HDR_VERS            0x01
+#define PHI_HDR_LEN             0x04
+
+/* DolbyVision VS Info Frame */
+#define DOLBYVSIF_TYPE            0x81
+#define DOLBYVSIF_VERS            0x01
+#define DOLBYVSIF_LEN             0x1B
+
+/* Dynamic HDR EMP */
+#define DYNAMIC_HDR_EMP_TYPE            0x7F
+#define DYNAMIC_HDR_EMP_DS_TYPE         0x01
+#define DYNAMIC_HDR_EMP_AFR             0x00
+#define DYNAMIC_HDR_EMP_VFR             0x01
+#define DYNAMIC_HDR_EMP_SYNC            0x01
+#define DYNAMIC_HDR_EMP_ORGID           0x02
+#define EMP_SIZE_FIRST      21
+#define EMP_SIZE_MAX        28
+
+/* Dynamic HDR10 PLUS VSIF */
+#define DYNAMIC_HDR10P_VSIF_TYPE		0x01
+#define DYNAMIC_HDR10P_VSIF_VERSION		0x01
+#define DYNAMIC_HDR10P_VSIF_MAXLEN		27
+#define DYNAMIC_HDR10P_VSIF_PKTHW		GEN_PKT_HW7
+
+#define HDR_PACKET_DISABLE    0x00
+#define HDR_PACKET_ACTIVE     0x01
+#define HDR_PACKET_ZERO       0x02
+
+enum VID_GAMMA_T {
+	GAMMA_ST2084 = 1,
+	GAMMA_HLG = 2,
+	GAMMA_24 = 1,
+	GAMMA_709 = 2,
+};
+
+enum VID_PLA_DR_TYPE_T {
+	VID_PLA_DR_TYPE_SDR = 0,
+	VID_PLA_DR_TYPE_HDR10,
+	VID_PLA_DR_TYPE_DOVI,
+	VID_PLA_DR_TYPE_PHLP_RESVERD,
+	VID_PLA_DR_TYPE_DOVI_LOWLATENCY,
+	VID_PLA_DR_TYPE_HDR10_PLUS,
+	VID_PLA_DR_TYPE_HDR10_PLUS_VSIF,
+};
+
+struct VID_STATIC_HDMI_MD_T {
+	unsigned short ui2_DisplayPrimariesX[3];
+	unsigned short ui2_DisplayPrimariesY[3];
+	unsigned short ui2_WhitePointX;
+	unsigned short ui2_WhitePointY;
+	unsigned short ui2_MaxDisplayMasteringLuminance;
+	unsigned short ui2_MinDisplayMasteringLuminance;
+	unsigned short ui2_MaxCLL;
+	unsigned short ui2_MaxFALL;
+	unsigned char fgNeedUpdStaticMeta;
+};
+
+struct HDMI_STATIC_METADATA_INFO_T {
+	char ui1_EOTF;
+	char ui1_Static_Metadata_ID;
+	unsigned short ui2_DisplayPrimariesX0;
+	unsigned short ui2_DisplayPrimariesY0;
+	unsigned short ui2_DisplayPrimariesX1;
+	unsigned short ui2_DisplayPrimariesY1;
+	unsigned short ui2_DisplayPrimariesX2;
+	unsigned short ui2_DisplayPrimariesY2;
+	unsigned short ui2_WhitePointX;
+	unsigned short ui2_WhitePointY;
+	unsigned short ui2_MaxDisplayMasteringLuminance;
+	unsigned short ui2_MinDisplayMasteringLuminance;
+	unsigned short ui2_MaxCLL;
+	unsigned short ui2_MaxFALL;
+};
+
+struct VID_PLA_DOVI_METADATA_INFO_T {
+	unsigned short ui2_DisplayPrimariesX[3];
+	unsigned int ui4_RpuIdx;
+	unsigned int ui4_RpuStartAddr;
+	unsigned int ui4_RpuSize;
+};
+
+union VID_PLA_DOVI_METADATA_UNION_T {
+	char dovi_metada_buffer[DOVI_METADATA_MAX_LENGTH];
+	struct VID_PLA_DOVI_METADATA_INFO_T dovi_metadata_info;
+};
+
+struct VID_PLA_PHLP_METADATA_INFO_T {
+	unsigned int ui4_PhilipHdrAddr;
+	unsigned int ui4_PhilipHdrSize;
+	unsigned int ui4_Index;
+
+};
+
+union VID_PLA_PHLP_METADATA_UNION_T {
+	char phlp_metada_buffer[DOVI_METADATA_MAX_LENGTH];
+	struct VID_PLA_PHLP_METADATA_INFO_T phlp_metadata_info;
+};
+
+struct VID_DOVI_LOWLATENCY_MD_INFO_T {
+	char fgBackltCtrlMdPresent;
+	unsigned int ui4_EffTmaxPQ;
+};
+
+struct VID_HDR10_PLUS_METADATA_INFO_T {
+	unsigned long ui4_Hdr10PlusAddr;
+	unsigned int ui4_Hdr10PlusSize;
+	unsigned int ui4_Hdr10PlusIdx;
+	unsigned int ui4_isTrustZone;
+};
+
+union VID_HDR10_PLUS_METADATA_UNION_T {
+	char hdr10_plus_metada_buffer[HDR10_PLUS_METADATA_MAX_LENGTH];
+	struct VID_HDR10_PLUS_METADATA_INFO_T hdr10p_metadata_info;
+};
+
+union VID_PLA_HDR_METADATA_UNION_T {
+	struct VID_STATIC_HDMI_MD_T hdr10_metadata;
+	union VID_PLA_DOVI_METADATA_UNION_T dovi_metadata;
+	union VID_PLA_PHLP_METADATA_UNION_T phlp_metadata;
+	struct VID_DOVI_LOWLATENCY_MD_INFO_T dovi_lowlatency_metadata;
+	union VID_HDR10_PLUS_METADATA_UNION_T hdr10_plus_metadata;
+};
+
+struct VID_PLA_HDR_METADATA_INFO_T {
+	enum VID_PLA_DR_TYPE_T e_DynamicRangeType;
+	union VID_PLA_HDR_METADATA_UNION_T metadata_info;
+	unsigned char fgIsMetadata;
+};
+
+void mtk_hdmi_hw_static_hdr_infoframe(
+	struct mtk_hdmi *hdmi, char bEnable, char *pr_bData);
+void mtk_hdmi_hw_dolby_vsif(struct mtk_hdmi *hdmi, bool fgEnable, bool fgLowLatency,
+	bool fgDolbyVisionSignal, bool fgBackltCtrlMdPresent, unsigned int u4EfftmaxPQ);
+
+#ifdef CONFIG_DRM_MEDIATEK_HDMI
+void vBT2020Enable(bool fgEnable);
+void vHdr10Enable(bool fgEnable);
+void vHdr10PlusEnable(bool fgEnable);
+void vHdr10PlusVSIFEnable(bool fgEnable);
+void vDolbyHdrEnable(bool fgEnable, bool use_dolby_vsif);
+void vLowLatencyDolbyVisionEnable(bool fgEnable);
+void vSetStaticHdrType(enum VID_GAMMA_T bType);
+void vVdpSetHdrMetadata(bool enable, struct VID_PLA_HDR_METADATA_INFO_T hdr_metadata);
+#else
+inline void vBT2020Enable(bool fgEnable) {};
+inline void vHdr10Enable(bool fgEnable) {};
+inline void vHdr10PlusEnable(bool fgEnable) {};
+inline void vHdr10PlusVSIFEnable(bool fgEnable) {};
+inline void vDolbyHdrEnable(bool fgEnable, bool use_dolby_vsif) {};
+inline void vLowLatencyDolbyVisionEnable(bool fgEnable) {};
+inline void vSetStaticHdrType(enum VID_GAMMA_T bType) {};
+inline void vVdpSetHdrMetadata(bool enable, struct VID_PLA_HDR_METADATA_INFO_T hdr_metadata) {};
+#endif
+
+void Hdr10DelayOffHandler(struct work_struct *data);
+void Hdr10pVsifDelayOffHandler(struct work_struct *data);
+void vInitHdr(void);
+void reset_hdmi_hdr_status(void);
+
+extern bool _fgDolbyHdrEnable;
+extern bool _fgBT2020Enable;
+extern char *_bHdrMetadataBuff;
+extern char _bStaticHdrStatus;
+extern bool _use_dolby_vsif;
+extern bool _fgLowLatencyDolbyVisionEnable;
+extern bool _fgBackltCtrlMDPresent;
+extern unsigned int _u4EffTmaxPQ;
+
+#endif /* _MTK_HDR_H */
diff --git a/drivers/gpu/drm/mediatek/mediatek_v2/mtk_hdmi_phy.h b/drivers/gpu/drm/mediatek/mediatek_v2/mtk_hdmi_phy.h
new file mode 100644
index 0000000000000000000000000000000000000000..7c71a409fce023ae8fc6b1b61c857432de8adf41
--- /dev/null
+++ b/drivers/gpu/drm/mediatek/mediatek_v2/mtk_hdmi_phy.h
@@ -0,0 +1,54 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2019 MediaTek Inc.
+ */
+
+#ifndef _MTK_HDMI_PHY_H
+#define _MTK_HDMI_PHY_H
+
+#include <linux/types.h>
+#include <linux/clk.h>
+#include <linux/clk-provider.h>
+
+#include "mtk_hdmi.h"
+
+enum mtk_hdmi_phy_clk_id {
+	MTK_HDMI_PHY_XTAL_SEL,
+	MTK_HDMI_PHY_CLK_COUNT,
+};
+
+enum txpll_clk_parent {
+	PLLGP1_PLLGP_2H_PLL2,
+	HDMIRX,
+	XTAL26M,
+	TXPLL_CLK_PARENT_COUNT,
+};
+
+struct mtk_hdmi_phy {
+	void __iomem *regs;
+	struct device *dev;
+	struct clk *clk[MTK_HDMI_PHY_CLK_COUNT];
+	struct clk *txpll;
+	struct clk_hw txpll_hw;
+	unsigned long txpll_rate;
+	enum txpll_clk_parent clk_parent;
+	unsigned long rx_clk_rate;
+	unsigned long min_tmds_clock;
+	unsigned long max_tmds_clock;
+	unsigned int efuse;
+};
+
+extern struct mtk_hdmi_phy *global_hdmi_phy;
+
+void vTxSignalOnOff(struct mtk_hdmi_phy *hdmi_phy, bool OnOff);
+void mtk_hdmi_ana_fifo_en(struct mtk_hdmi_phy *hdmi_phy);
+void mtk_tmds_high_bit_clk_ratio(
+	struct mtk_hdmi *hdmi, bool enable);
+
+unsigned int mtk_hdmi_phy_read(
+	struct mtk_hdmi_phy *hdmi_phy, unsigned short reg);
+void mtk_hdmi_phy_write(struct mtk_hdmi_phy *hdmi_phy,
+	unsigned short reg, unsigned int val);
+
+
+#endif
diff --git a/drivers/gpu/drm/mediatek/mediatek_v2/mtk_hdmi_regs.h b/drivers/gpu/drm/mediatek/mediatek_v2/mtk_hdmi_regs.h
new file mode 100644
index 0000000000000000000000000000000000000000..d68aaaafa30b4bcdcb95f92615346e497321f37d
--- /dev/null
+++ b/drivers/gpu/drm/mediatek/mediatek_v2/mtk_hdmi_regs.h
@@ -0,0 +1,2732 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2019 MediaTek Inc.
+ */
+
+#ifndef _MTK_HDMI_REGS_H
+#define _MTK_HDMI_REGS_H
+
+
+/*********HDMI21 tx analog register start*******/
+
+#define HDMI_1_CFG_0	0x00
+
+#define	RG_HDMITX21_SER_EN (0xf << 28)
+#define	RG_HDMITX21_DRV_EN (0xf << 24)
+#define	RG_HDMITX21_DRV_IMP_EN (0xf << 20)
+#define	RG_HDMITX21_SER_5T1_BIST_EN (0x1 << 19)
+#define	RG_HDMITX21_SER_DIN_SEL (0xf << 15)
+#define	RG_HDMITX21_SER_BIST_TOG (0x1 << 14)
+#define	RG_HDMITX21_SER_CLKDIG_INV (0x1 << 13)
+#define RG_HDMITX21_DRV_IBIAS_CLK (0x3f << 5)
+
+#define	RG_HDMITX21_SER_EN_SHIFT (28)
+#define	RG_HDMITX21_DRV_EN_SHIFT (24)
+#define	RG_HDMITX21_DRV_IMP_EN_SHIFT (20)
+#define	RG_HDMITX21_SER_5T1_BIST_EN_SHIFT (19)
+#define	RG_HDMITX21_SER_DIN_SEL_SHIFT (15)
+#define	RG_HDMITX21_SER_BIST_TOG_SHIFT (14)
+#define	RG_HDMITX21_SER_CLKDIG_INV_SHIFT (13)
+#define RG_HDMITX21_DRV_IBIAS_CLK_SHIFT (5)
+
+
+#define HDMI_1_CFG_1	0x04
+
+#define RG_HDMITX21_DRV_IBIAS_D2 (0x3f << 26)
+#define RG_HDMITX21_DRV_IBIAS_D1 (0x3f << 20)
+#define RG_HDMITX21_DRV_IBIAS_D0 (0x3f << 14)
+
+#define RG_HDMITX21_DRV_IBIAS_D2_SHIFT (26)
+#define RG_HDMITX21_DRV_IBIAS_D1_SHIFT (20)
+#define RG_HDMITX21_DRV_IBIAS_D0_SHIFT (14)
+
+
+#define HDMI_1_CFG_2	0x08
+
+#define RG_HDMITX21_DRV_IMP_CLK_EN1 (0x3f << 26)
+#define RG_HDMITX21_DRV_IMP_D2_EN1 (0x3f << 20)
+#define RG_HDMITX21_DRV_IMP_D1_EN1 (0x3f << 14)
+#define RG_HDMITX21_DRV_IMP_D0_EN1  (0x3f << 8)
+
+#define RG_HDMITX21_DRV_IMP_CLK_EN1_SHIFT (26)
+#define RG_HDMITX21_DRV_IMP_D2_EN1_SHIFT (20)
+#define RG_HDMITX21_DRV_IMP_D1_EN1_SHIFT (14)
+#define RG_HDMITX21_DRV_IMP_D0_EN1_SHIFT  (8)
+
+
+#define HDMI_1_CFG_3	0x0c
+
+#define RG_HDMITX21_SER_DIN (0x3ffff << 14)
+#define RG_HDMITX21_SER_PASS_SEL (0x3 << 12)
+#define RG_HDMITX21_SLDO_EN (0xf << 8)
+#define RG_HDMITX21_SLDOLPF_EN (0x1 << 7)
+#define RG_HDMITX21_SLDO_LVROD (0x3 << 5)
+#define RG_HDMITX21_SLDO_MONEN (0x1 << 4)
+#define RG_HDMITX21_CKLDO_EN (0x1 << 3)
+#define RG_HDMITX21_CKLDOLPF_EN (0x1 << 2)
+#define RG_HDMITX21_CKLDO_LVROD (0x3 << 0)
+
+#define RG_HDMITX21_SER_DIN_SHIFT (14)
+#define RG_HDMITX21_SER_PASS_SEL_SHIFT (12)
+#define RG_HDMITX21_SLDO_EN_SHIFT (8)
+#define RG_HDMITX21_SLDOLPF_EN_SHIFT (7)
+#define RG_HDMITX21_SLDO_LVROD_SHIFT (5)
+#define RG_HDMITX21_SLDO_MONEN_SHIFT (4)
+#define RG_HDMITX21_CKLDO_EN_SHIFT (3)
+#define RG_HDMITX21_CKLDOLPF_EN_SHIFT (2)
+#define RG_HDMITX21_CKLDO_LVROD_SHIFT (0)
+
+
+#define HDMI_1_CFG_4	0x10
+
+#define RG_HDMITX21_CKLDO_MONEN (0x1 << 31)
+#define RG_HDMITX21_ABIST_EN (0x1 << 30)
+#define RG_HDMITX21_CKTST_EN (0x1 << 29)
+#define RG_HDMITX21_CKTST_SEL (0x7 << 26)
+#define RG_HDMITX21_CKTST_DIV (0x3 << 24)
+#define RG_HDMITX21_VDCTSTBUF_EN (0x1 << 23)
+#define RG_HDMITX21_VDCTST_BYPASS (0x1 << 22)
+#define RG_HDMITX21_VDCTST_SEL (0x1f << 17)
+
+#define RG_HDMITX21_CKLDO_MONEN_SHIFT (31)
+#define RG_HDMITX21_ABIST_EN_SHIFT (30)
+#define RG_HDMITX21_CKTST_EN_SHIFT (29)
+#define RG_HDMITX21_CKTST_SEL_SHIFT (26)
+#define RG_HDMITX21_CKTST_DIV_SHIFT (24)
+#define RG_HDMITX21_VDCTSTBUF_EN_SHIFT (23)
+#define RG_HDMITX21_VDCTST_BYPASS_SHIFT (22)
+#define RG_HDMITX21_VDCTST_SEL_SHIFT (17)
+
+
+#define HDMI_1_CFG_5	0x14
+
+#define RG_HDMITX21_RESERVE (0xffffffff << 0)
+
+#define HDMI_1_CFG_6	0x18
+
+#define RG_HDMITX21_SER_ABEDG_EN (0x1 << 31)
+#define RG_HDMITX21_BIAS_LPF_EN (0x1 << 30)
+#define RG_HDMITX21_BIAS_EN (0x1 << 29)
+#define RG_HDMITX21_TX_POSDIV_EN (0x1 << 28)
+#define RG_HDMITX21_TX_POSDIV (0x3 << 26)
+#define RG_HDMITX21_INTR_EN (0x1 << 23)
+#define RG_HDMITX21_INTR_CAL (0x1f << 18)
+#define RG_HDMITX21_SLDO_BYPASS_EN (0x1 << 17)
+#define RG_HDMITX21_FRL_D2_EN (0x1 << 16)
+#define RG_HDMITX21_FRL_D1_EN (0x1 << 15)
+#define RG_HDMITX21_FRL_D0_EN (0x1 << 14)
+#define RG_HDMITX21_FRL_CK_EN (0x1 << 13)
+#define RG_HDMITX21_FRL_EN (0x1 << 12)
+#define RG_HDMITX21_CK_DRV_OP_EN (0x1 << 11)
+#define RG_HDMITX21_D0_DRV_OP_EN (0x1 << 10)
+#define RG_HDMITX21_D1_DRV_OP_EN (0x1 << 9)
+#define RG_HDMITX21_D2_DRV_OP_EN (0x1 << 8)
+#define RG_HDMITX21_SER_FFE2_D0_EN (0x1 << 7)
+#define RG_HDMITX21_SER_FFE2_D1_EN (0x1 << 6)
+#define RG_HDMITX21_SER_FFE2_D2_EN (0x1 << 5)
+#define RG_HDMITX21_SER_FFE2_CK_EN (0x1 << 4)
+#define RG_HDMITX21_SER_FFE1_D0_EN (0x1 << 3)
+#define RG_HDMITX21_SER_FFE1_D1_EN (0x1 << 2)
+#define RG_HDMITX21_SER_FFE1_D2_EN (0x1 << 1)
+#define RG_HDMITX21_SER_FFE1_CK_EN (0x1 << 0)
+
+#define RG_HDMITX21_SER_ABEDG_EN_SHIFT (31)
+#define RG_HDMITX21_BIAS_LPF_EN_SHIFT (30)
+#define RG_HDMITX21_BIAS_EN_SHIFT (29)
+#define RG_HDMITX21_TX_POSDIV_EN_SHIFT (28)
+#define RG_HDMITX21_TX_POSDIV_SHIFT (26)
+#define RG_HDMITX21_INTR_EN_SHIFT (23)
+#define RG_HDMITX21_INTR_CAL_SHIFT (18)
+#define RG_HDMITX21_SLDO_BYPASS_EN_SHIFT (17)
+#define RG_HDMITX21_FRL_D2_EN_SHIFT (16)
+#define RG_HDMITX21_FRL_D1_EN_SHIFT (15)
+#define RG_HDMITX21_FRL_D0_EN_SHIFT (14)
+#define RG_HDMITX21_FRL_CK_EN_SHIFT (13)
+#define RG_HDMITX21_FRL_EN_SHIFT (12)
+#define RG_HDMITX21_CK_DRV_OP_EN_SHIFT (11)
+#define RG_HDMITX21_D0_DRV_OP_EN_SHIFT (10)
+#define RG_HDMITX21_D1_DRV_OP_EN_SHIFT (9)
+#define RG_HDMITX21_D2_DRV_OP_EN_SHIFT (8)
+#define RG_HDMITX21_SER_FFE2_D0_EN_SHIFT (7)
+#define RG_HDMITX21_SER_FFE2_D1_EN_SHIFT (6)
+#define RG_HDMITX21_SER_FFE2_D2_EN_SHIFT (5)
+#define RG_HDMITX21_SER_FFE2_CK_EN_SHIFT (4)
+#define RG_HDMITX21_SER_FFE1_D0_EN_SHIFT (3)
+#define RG_HDMITX21_SER_FFE1_D1_EN_SHIFT (2)
+#define RG_HDMITX21_SER_FFE1_D2_EN_SHIFT (1)
+#define RG_HDMITX21_SER_FFE1_CK_EN_SHIFT (0)
+
+
+#define HDMI_1_CFG_7	0x1c
+
+#define RG_HDMITX21_DRV_IBIAS_D2_FFE1 (0x1f << 27)
+#define RG_HDMITX21_DRV_IBIAS_D1_FFE1 (0x1f << 22)
+#define RG_HDMITX21_DRV_IBIAS_D0_FFE1 (0x1f << 17)
+#define RG_HDMITX21_DRV_IBIAS_CK_FFE1 (0x1f << 12)
+
+#define RG_HDMITX21_DRV_IBIAS_D2_FFE1_SHIFT (27)
+#define RG_HDMITX21_DRV_IBIAS_D1_FFE1_SHIFT (22)
+#define RG_HDMITX21_DRV_IBIAS_D0_FFE1_SHIFT (17)
+#define RG_HDMITX21_DRV_IBIAS_CK_FFE1_SHIFT (12)
+
+
+#define HDMI_1_CFG_8	0x20
+
+#define RG_HDMITX21_DRV_IBIAS_D2_FFE2 (0xf << 28)
+#define RG_HDMITX21_DRV_IBIAS_D1_FFE2 (0xf << 24)
+#define RG_HDMITX21_DRV_IBIAS_D0_FFE2 (0xf << 20)
+#define RG_HDMITX21_DRV_IBIAS_CK_FFE2 (0xf << 16)
+#define RG_HDMITX21_SER_DUMMY_FFE2_D2_EN (0x1 << 15)
+#define RG_HDMITX21_SER_DUMMY_FFE2_D1_EN (0x1 << 14)
+#define RG_HDMITX21_SER_DUMMY_FFE2_D0_EN (0x1 << 13)
+#define RG_HDMITX21_SER_DUMMY_FFE2_CK_EN (0x1 << 12)
+#define RG_HDMITX21_SER_DUMMY_FFE1_D2_EN (0x1 << 11)
+#define RG_HDMITX21_SER_DUMMY_FFE1_D1_EN (0x1 << 10)
+#define RG_HDMITX21_SER_DUMMY_FFE1_D0_EN (0x1 << 9)
+#define RG_HDMITX21_SER_DUMMY_FFE1_CK_EN (0x1 << 8)
+#define RG_HDMITX21_SER_DUMMY_FFE0_D2_EN (0x1 << 7)
+#define RG_HDMITX21_SER_DUMMY_FFE0_D1_EN (0x1 << 6)
+#define RG_HDMITX21_SER_DUMMY_FFE0_D0_EN (0x1 << 5)
+#define RG_HDMITX21_SER_DUMMY_FFE0_CK_EN (0x1 << 4)
+
+#define RG_HDMITX21_DRV_IBIAS_D2_FFE2_SHIFT (28)
+#define RG_HDMITX21_DRV_IBIAS_D1_FFE2_SHIFT (24)
+#define RG_HDMITX21_DRV_IBIAS_D0_FFE2_SHIFT (20)
+#define RG_HDMITX21_DRV_IBIAS_CK_FFE2_SHIFT (16)
+#define RG_HDMITX21_SER_DUMMY_FFE2_D2_EN_SHIFT (15)
+#define RG_HDMITX21_SER_DUMMY_FFE2_D1_EN_SHIFT (14)
+#define RG_HDMITX21_SER_DUMMY_FFE2_D0_EN_SHIFT (13)
+#define RG_HDMITX21_SER_DUMMY_FFE2_CK_EN_SHIFT (12)
+#define RG_HDMITX21_SER_DUMMY_FFE1_D2_EN_SHIFT (11)
+#define RG_HDMITX21_SER_DUMMY_FFE1_D1_EN_SHIFT (10)
+#define RG_HDMITX21_SER_DUMMY_FFE1_D0_EN_SHIFT (9)
+#define RG_HDMITX21_SER_DUMMY_FFE1_CK_EN_SHIFT (8)
+#define RG_HDMITX21_SER_DUMMY_FFE0_D2_EN_SHIFT (7)
+#define RG_HDMITX21_SER_DUMMY_FFE0_D1_EN_SHIFT (6)
+#define RG_HDMITX21_SER_DUMMY_FFE0_D0_EN_SHIFT (5)
+#define RG_HDMITX21_SER_DUMMY_FFE0_CK_EN_SHIFT (4)
+
+
+#define HDMI_1_CFG_9	0x24
+
+#define RG_HDMITX21_PRE_CROSS_POINT_D0_DP_SEL (0x3 << 30)
+#define RG_HDMITX21_PRE_CROSS_POINT_D1_DP_SEL (0x3 << 28)
+#define RG_HDMITX21_PRE_CROSS_POINT_D2_DP_SEL (0x3 << 26)
+#define RG_HDMITX21_PRE_CROSS_POINT_CK_DP_SEL (0x3 << 24)
+#define RG_HDMITX21_PRE_CROSS_POINT_D0_FFE1_SEL (0x3 << 22)
+#define RG_HDMITX21_PRE_CROSS_POINT_D1_FFE1_SEL (0x3 << 20)
+#define RG_HDMITX21_PRE_CROSS_POINT_D2_FFE1_SEL (0x3 << 18)
+#define RG_HDMITX21_PRE_CROSS_POINT_CK_FFE1_SEL (0x3 << 16)
+#define RG_HDMITX21_PRE_CROSS_POINT_D0_FFE2_SEL (0x3 << 14)
+#define RG_HDMITX21_PRE_CROSS_POINT_D1_FFE2_SEL (0x3 << 12)
+#define RG_HDMITX21_PRE_CROSS_POINT_D2_FFE2_SEL (0x3 << 10)
+#define RG_HDMITX21_PRE_CROSS_POINT_CK_FFE2_SEL (0x3 << 8)
+#define RG_HDMITX21_BIAS_PI_OD1P25 (0x1 << 7)
+#define RG_HDMITX21_BIAS_PI_OD1P125 (0x1 << 6)
+#define RG_HDMITX21_SLDO_VREF_SEL (0x3 << 4)
+
+#define RG_HDMITX21_PRE_CROSS_POINT_D0_DP_SEL_SHIFT (30)
+#define RG_HDMITX21_PRE_CROSS_POINT_D1_DP_SEL_SHIFT (28)
+#define RG_HDMITX21_PRE_CROSS_POINT_D2_DP_SEL_SHIFT (26)
+#define RG_HDMITX21_PRE_CROSS_POINT_CK_DP_SEL_SHIFT (24)
+#define RG_HDMITX21_PRE_CROSS_POINT_D0_FFE1_SEL_SHIFT (22)
+#define RG_HDMITX21_PRE_CROSS_POINT_D1_FFE1_SEL_SHIFT (20)
+#define RG_HDMITX21_PRE_CROSS_POINT_D2_FFE1_SEL_SHIFT (18)
+#define RG_HDMITX21_PRE_CROSS_POINT_CK_FFE1_SEL_SHIFT (16)
+#define RG_HDMITX21_PRE_CROSS_POINT_D0_FFE2_SEL_SHIFT (14)
+#define RG_HDMITX21_PRE_CROSS_POINT_D1_FFE2_SEL_SHIFT (12)
+#define RG_HDMITX21_PRE_CROSS_POINT_D2_FFE2_SEL_SHIFT (10)
+#define RG_HDMITX21_PRE_CROSS_POINT_CK_FFE2_SEL_SHIFT (8)
+#define RG_HDMITX21_BIAS_PI_OD1P25_SHIFT (7)
+#define RG_HDMITX21_BIAS_PI_OD1P125_SHIFT (6)
+#define RG_HDMITX21_SLDO_VREF_SEL_SHIFT (4)
+
+
+#define HDMI_1_READ	0x28
+
+#define RGS_HDMITX21_PLUG_TST (0x1 << 31)
+#define RGS_HDMITX21_5T1_EDG (0xf << 27)
+#define RGS_HDMITX21_5T1_LEV (0xf << 23)
+#define RGS_HDMITX21_2T1_EDG (0xf << 19)
+#define RGS_HDMITX21_2T1_LEV (0xf << 15)
+
+#define RGS_HDMITX21_PLUG_TST_SHIFT (31)
+#define RGS_HDMITX21_5T1_EDG_SHIFT (27)
+#define RGS_HDMITX21_5T1_LEV_SHIFT (23)
+#define RGS_HDMITX21_2T1_EDG_SHIFT (19)
+#define RGS_HDMITX21_2T1_LEV_SHIFT (15)
+
+#define HDMI_1_CFG_10	0x40
+
+#define RG_HDMITXCLKSQ_EN	(0x1 << 30)
+#define RG_HDMITXCLKSQ_HYS_EN	(0x1 << 29)
+#define RG_HDMITXCLKSQ_LPFEN	(0x1 << 28)
+#define RG_HDMITX21_BG_PWD (0x1 << 20)
+#define RG_HDMITX21_BG_MONEN (0x1 << 19)
+#define RG_HDMITX21_BG_CKEN (0x1 << 18)
+#define RG_HDMITX21_BG_LPF_EN (0x1 << 17)
+#define RG_HDMITX21_BIAS_PE_BG_VREF_SEL (0x3 << 15)
+#define RG_HDMITX21_PLL_BG_VREF_SEL (0x3 << 13)
+#define RG_HDMITX21_BG_CKDIV (0x3 << 11)
+#define RG_HDMITX21_BIAS_PE_VREF_SELB (0x1 << 10)
+#define RG_HDMITX21_BIAS_PE_PWR_VREF_SEL (0x3 << 8)
+#define RG_HDMITX21_VREF_GEN2_EN	(0x1 << 7)
+#define RG_HDMITX21_VREF_GEN2_REFSEL	(0x3 << 5)
+#define RG_HDMITX21_VREF_SEL	(0x1 << 4)
+#define RG_HDMITX21_VREF_GEN2_0P96_SEL	(0x1 << 3)
+#define RG_HDMITXPLL_REF_CK_SEL	(0x3 << 1)
+#define RG_HDMITX21_BG_RSTB	(0x1 << 0)
+
+#define RG_HDMITXCLKSQ_EN_SHIFT	(30)
+#define RG_HDMITXCLKSQ_HYS_EN_SHIFT	(29)
+#define RG_HDMITXCLKSQ_LPFEN_SHIFT	(28)
+#define RG_HDMITX21_BG_PWD_SHIFT (20)
+#define RG_HDMITX21_BG_MONEN_SHIFT (19)
+#define RG_HDMITX21_BG_CKEN_SHIFT (18)
+#define RG_HDMITX21_BG_LPF_EN_SHIFT (17)
+#define RG_HDMITX21_BIAS_PE_BG_VREF_SEL_SHIFT (15)
+#define RG_HDMITX21_PLL_BG_VREF_SEL_SHIFT (13)
+#define RG_HDMITX21_BG_CKDIV_SHIFT (11)
+#define RG_HDMITX21_BIAS_PE_VREF_SELB_SHIFT (10)
+#define RG_HDMITX21_BIAS_PE_PWR_VREF_SEL_SHIFT (8)
+#define RG_HDMITX21_VREF_GEN2_EN_SHIFT	(7)
+#define RG_HDMITX21_VREF_GEN2_REFSEL_SHIFT	(5)
+#define RG_HDMITX21_VREF_SEL_SHIFT	(4)
+#define RG_HDMITX21_VREF_GEN2_0P96_SEL_SHIFT	(3)
+#define RG_HDMITXPLL_REF_CK_SEL_SHIFT	(1)
+#define RG_HDMITX21_BG_RSTB_SHIFT	(0)
+
+#define HDMI_1_PLL_CFG_0	0x44
+
+#define RG_HDMITXPLL_TCL_EN (0x1 << 31)
+#define RG_HDMITXPLL_BP2 (0x1 << 30)
+#define RG_HDMITXPLL_PFD_OFFSET (0x3 << 28)
+#define RG_HDMITXPLL_LVR_SEL (0x3 << 26)
+#define RG_HDMITXPLL_PCW_CHG (0x1 << 25)
+#define RG_HDMITXPLL_IBAND_FIX_EN (0x1 << 24)
+#define RG_HDMITXPLL_MONREF_EN (0x1 << 23)
+#define RG_HDMITXPLL_MONCK_EN (0x1 << 22)
+#define RG_HDMITXPLL_MONVC_EN (0x1 << 21)
+#define RG_HDMITXPLL_LOAD (0x1 << 20)
+#define RG_HDMITXPLL_KFC (0x3 << 18)
+#define RG_HDMITXPLL_RST_DLY (0x3 << 16)
+#define RG_HDMITXPLL_DEBUG_SEL (0x1 << 15)
+#define RG_HDMITXPLL_FRA_EN (0x1 << 14)
+#define RG_HDMITXPLL_HREN (0x3 << 12)
+#define RG_HDMITXPLL_SDM_ORDER (0x3 << 10)
+#define RG_HDMITXPLL_SSC_DIR (0x3 << 8)
+
+#define RG_HDMITXPLL_TCL_EN_SHIFT (31)
+#define RG_HDMITXPLL_BP2_SHIFT (30)
+#define RG_HDMITXPLL_PFD_OFFSET_SHIFT (28)
+#define RG_HDMITXPLL_LVR_SEL_SHIFT (26)
+#define RG_HDMITXPLL_PCW_CHG_SHIFT (25)
+#define RG_HDMITXPLL_IBAND_FIX_EN_SHIFT (24)
+#define RG_HDMITXPLL_MONREF_EN_SHIFT (23)
+#define RG_HDMITXPLL_MONCK_EN_SHIFT (22)
+#define RG_HDMITXPLL_MONVC_EN_SHIFT (21)
+#define RG_HDMITXPLL_LOAD_SHIFT (20)
+#define RG_HDMITXPLL_KFC_SHIFT (18)
+#define RG_HDMITXPLL_RST_DLY_SHIFT (16)
+#define RG_HDMITXPLL_DEBUG_SEL_SHIFT (15)
+#define RG_HDMITXPLL_FRA_EN_SHIFT (14)
+#define RG_HDMITXPLL_HREN_SHIFT (12)
+#define RG_HDMITXPLL_SDM_ORDER_SHIFT (10)
+#define RG_HDMITXPLL_SSC_DIR_SHIFT (8)
+
+#define HDMI_1_PLL_CFG_1	0x48
+
+#define RG_HDMITXPLL_SSC_PRD (0xffff << 16)
+#define RG_HDMITXPLL_RESERVE (0xffff << 0)
+#define RG_HDMITXPLL_RESERVE_BIT13 BIT(13)
+#define RG_HDMITXPLL_RESERVE_BIT14 BIT(14)
+#define RG_HDMITXPLL_RESERVE_BIT12_11 GENMASK(12, 11)
+#define RG_HDMITXPLL_RESERVE_BIT3_2 GENMASK(3, 2)
+#define RG_HDMITXPLL_RESERVE_BIT1_0 GENMASK(1, 0)
+
+#define RG_HDMITXPLL_SSC_PRD_SHIFT (16)
+#define RG_HDMITXPLL_RESERVE_SHIFT (0)
+#define RG_HDMITXPLL_RESERVE_BIT13_SHIFT (13)
+#define RG_HDMITXPLL_RESERVE_BIT14_SHIFT (14)
+#define RG_HDMITXPLL_RESERVE_BIT12_11_SHIFT (11)
+#define RG_HDMITXPLL_RESERVE_BIT3_2_SHIFT (2)
+#define RG_HDMITXPLL_RESERVE_BIT1_0_SHIFT (0)
+
+
+#define HDMI_1_PLL_CFG_2	0x4c
+
+#define RG_HDMITXPLL_PWD (0x1 << 31)
+#define RG_HDMITXPLL_PFD_OFFSET_EN (0x1 << 30)
+#define RG_HDMITXPLL_HIKVCO (0x1 << 29)
+#define RG_HDMITXPLL_BC (0x3 << 27)
+#define RG_HDMITXPLL_IC (0x1f << 22)
+#define RG_HDMITXPLL_BR (0x7 << 19)
+#define RG_HDMITXPLL_IR (0x1f << 14)
+#define RG_HDMITXPLL_BP (0xf << 10)
+#define RG_HDMITXPLL_BAND (0x3ff << 0)
+
+#define RG_HDMITXPLL_PWD_SHIFT (31)
+#define RG_HDMITXPLL_PFD_OFFSET_EN_SHIFT (30)
+#define RG_HDMITXPLL_HIKVCO_SHIFT (29)
+#define RG_HDMITXPLL_BC_SHIFT (27)
+#define RG_HDMITXPLL_IC_SHIFT (22)
+#define RG_HDMITXPLL_BR_SHIFT (19)
+#define RG_HDMITXPLL_IR_SHIFT (14)
+#define RG_HDMITXPLL_BP_SHIFT (10)
+#define RG_HDMITXPLL_BAND_SHIFT (0)
+
+
+#define HDMI_1_PLL_CFG_3	0x50
+
+#define RG_HDMITXPLL_FBKDIV_low (0xffffffff << 0)
+
+#define RG_HDMITXPLL_FBKDIV_low_SHIFT (0)
+
+
+#define HDMI_1_PLL_CFG_4	0x54
+
+#define RG_HDMITXPLL_FBKDIV_high (0x1 << 31)
+#define RG_HDMITXPLL_FBKSEL (0x1 << 30)
+#define RG_HDMITXPLL_PREDIV (0x3 << 28)
+#define RG_HDMITXPLL_KBAND_PREDIV (0x3 << 26)
+#define RG_HDMITXPLL_DIV_CTRL (0x3 << 24)
+#define RG_HDMITXPLL_POSDIV (0x3 << 22)
+#define RG_HDMITXPLL_POSDIV_DIV3_CTRL (0x1 << 21)
+#define DA_HDMITXPLL_PWR_ON (0x1 << 2)
+#define DA_HDMITXPLL_ISO_EN (0x1 << 1)
+#define RG_HDMITXPLL_SSC_EN (0x1 << 0)
+
+#define RG_HDMITXPLL_FBKDIV_high_SHIFT (31)
+#define RG_HDMITXPLL_FBKSEL_SHIFT (30)
+#define RG_HDMITXPLL_PREDIV_SHIFT (28)
+#define RG_HDMITXPLL_KBAND_PREDIV_SHIFT (26)
+#define RG_HDMITXPLL_DIV_CTRL_SHIFT (24)
+#define RG_HDMITXPLL_POSDIV_SHIFT (22)
+#define RG_HDMITXPLL_POSDIV_DIV3_CTRL_SHIFT (21)
+#define DA_HDMITXPLL_PWR_ON_SHIFT (2)
+#define DA_HDMITXPLL_ISO_EN_SHIFT (1)
+#define RG_HDMITXPLL_SSC_EN_SHIFT (0)
+
+
+#define HDMI_1_PLL_CFG_5	0x58
+
+#define RG_HDMITXPLL_SSC_DELTA1 (0xffff << 16)
+#define RG_HDMITXPLL_SSC_DELTA (0xffff << 0)
+
+#define RG_HDMITXPLL_SSC_DELTA1_SHIFT (16)
+#define RG_HDMITXPLL_SSC_DELTA_SHIFT (0)
+
+#define EARC_RX_CFG_0	0x5c
+
+#define RG_EARCRX_TERM50_EN (0x1 << 31)
+#define RG_EARCRX_TERM50_SEL (0x1f << 26)
+#define RG_EARCRX_VCM_TERM_SEL (0x3 << 24)
+#define RG_EARCRX_BIAS_EN (0x1 << 22)
+#define RG_EARCRX_BIAS_INTR_CAL (0x1f << 17)
+#define RG_EARCRX_REFGEN_MONEN (0x1 << 16)
+#define RG_EARCRX_DM_LDO09_SEL (0x1 << 14)
+#define RG_EARCRX_DM_LDO_LVROD (0x3 << 12)
+#define RG_EARCRX_DM_LDO_MONEN (0x1 << 11)
+#define RG_EARCRX_PWM_CDR_EN (0x1 << 10)
+#define RG_EARCRX_PWM_CDR_TOBDET_EN (0x1 << 9)
+#define RG_EARCRX_PWM_GEAR_SEL (0x3 << 7)
+#define RG_EARCRX_CMTX_EN (0x1 << 5)
+#define RG_EARCRX_CM_VREFT_SEL (0x1 << 4)
+#define RG_EARCRX_CM_LDO_PWD (0x1 << 3)
+#define RG_EARCRX_CM_REG_PWD (0x1 << 2)
+#define RG_EARCRX_CM_LDO_LVROD (0x3 << 0)
+
+#define RG_EARCRX_TERM50_EN_SHIFT (31)
+#define RG_EARCRX_TERM50_SEL_SHIFT (26)
+#define RG_EARCRX_VCM_TERM_SEL_SHIFT (24)
+#define RG_EARCRX_BIAS_EN_SHIFT (22)
+#define RG_EARCRX_BIAS_INTR_CAL_SHIFT (17)
+#define RG_EARCRX_REFGEN_MONEN_SHIFT (16)
+#define RG_EARCRX_DM_LDO09_SEL_SHIFT (14)
+#define RG_EARCRX_DM_LDO_LVROD_SHIFT (12)
+#define RG_EARCRX_DM_LDO_MONEN_SHIFT (11)
+#define RG_EARCRX_PWM_CDR_EN_SHIFT (10)
+#define RG_EARCRX_PWM_CDR_TOBDET_EN_SHIFT (9)
+#define RG_EARCRX_PWM_GEAR_SEL_SHIFT (7)
+#define RG_EARCRX_CMTX_EN_SHIFT (5)
+#define RG_EARCRX_CM_VREFT_SEL_SHIFT (4)
+#define RG_EARCRX_CM_LDO_PWD_SHIFT (3)
+#define RG_EARCRX_CM_REG_PWD_SHIFT (2)
+#define RG_EARCRX_CM_LDO_LVROD_SHIFT (0)
+
+#define EARC_RX_CFG_1	0x60
+
+#define RG_EARCRX_CM_LDO_MONEN (0x1 << 31)
+#define RG_EARCRX_CM_TRAN_SEL (0x7 << 28)
+#define RG_EARCRX_CM_DLY_SEL (0x7 << 25)
+#define RG_EARCRX_CM_SLEW_OSC_EN (0x1 << 24)
+#define RG_EARCRX_REG_MONEN (0x1 << 23)
+#define RG_EARCRX_ARC_EN (0x1 << 21)
+#define RG_EARCRX_CMRX_EN (0x1 << 20)
+#define RG_EARCRX_CMRX_BUF_EN (0x1 << 19)
+#define RG_EARCRX_CMRX_HPF_BW_CTRL (0x1 << 18)
+#define RG_EARCRX_CMRX_HYST_AMP_EN (0x1 << 17)
+#define RG_EARCRX_CMRX_HYST_SEL (0x1 << 16)
+#define RG_EARCRX_CM_VREF_MONEN BIT(15)
+#define RG_EARCRX_VDCTST_SEL GENMASK(14, 12)
+#define RG_EARCRX_REV GENMASK(11, 4)
+#define RG_EARCRXPLL_TSTDIV GENMASK(2, 1)
+#define RG_EARCRXPLL_EN BIT(0)
+
+#define RG_EARCRX_CM_LDO_MONEN_SHIFT (31)
+#define RG_EARCRX_CM_TRAN_SEL_SHIFT (28)
+#define RG_EARCRX_CM_DLY_SEL_SHIFT (25)
+#define RG_EARCRX_CM_SLEW_OSC_EN_SHIFT (24)
+#define RG_EARCRX_REG_MONEN_SHIFT (23)
+#define RG_EARCRX_ARC_EN_SHIFT (21)
+#define RG_EARCRX_CMRX_EN_SHIFT (20)
+#define RG_EARCRX_CMRX_BUF_EN_SHIFT (19)
+#define RG_EARCRX_CMRX_HPF_BW_CTRL_SHIFT (18)
+#define RG_EARCRX_CMRX_HYST_AMP_EN_SHIFT (17)
+#define RG_EARCRX_CMRX_HYST_SEL_SHIFT (16)
+#define RG_EARCRX_CM_VREF_MONEN_SHIFT (15)
+#define RG_EARCRX_VDCTST_SEL_SHIFT (12)
+#define RG_EARCRX_REV_SHIFT (4)
+#define RG_EARCRXPLL_TSTDIV_SHIFT (1)
+#define RG_EARCRXPLL_EN_SHIFT (0)
+
+
+#define EARC_RX_CFG_2	0x64
+
+#define RG_EARCRXPLL_PREDIV GENMASK(31, 30)
+#define RG_EARCRXPLL_POSDIV GENMASK(29, 27)
+#define RG_EARCRXPLL_BLP BIT(26)
+#define RG_EARCRXPLL_DIV3_EN BIT(25)
+#define RG_EARCRXPLL_GLITCHFREE_EN BIT(24)
+#define RG_EARCRXPLL_LVROD_EN BIT(23)
+#define RG_EARCRXPLL_MONCK_EN BIT(22)
+#define RG_EARCRXPLL_MONREF_EN BIT(21)
+#define RG_EARCRXPLL_MONVC_EN BIT(20)
+#define RG_EARCRXPLL_SDM_FRA_EN BIT(19)
+#define RG_EARCRXPLL_SDM_PWR_ON BIT(3)
+#define RG_EARCRXPLL_SDM_ISO_EN BIT(2)
+#define DA_EARCRX_ARC_EN BIT(1)
+#define RG_EARCRXPLL_SDM_PCW_CHG BIT(0)
+
+#define RG_EARCRXPLL_PREDIV_SHIFT (30)
+#define RG_EARCRXPLL_POSDIV_SHIFT (27)
+#define RG_EARCRXPLL_BLP_SHIFT (26)
+#define RG_EARCRXPLL_DIV3_EN_SHIFT (25)
+#define RG_EARCRXPLL_GLITCHFREE_EN_SHIFT (24)
+#define RG_EARCRXPLL_LVROD_EN_SHIFT (23)
+#define RG_EARCRXPLL_MONCK_EN_SHIFT (22)
+#define RG_EARCRXPLL_MONREF_EN_SHIFT (21)
+#define RG_EARCRXPLL_MONVC_EN_SHIFT (20)
+#define RG_EARCRXPLL_SDM_FRA_EN_SHIFT (19)
+#define RG_EARCRXPLL_SDM_PWR_ON_SHIFT (3)
+#define RG_EARCRXPLL_SDM_ISO_EN_SHIFT (2)
+#define DA_EARCRX_ARC_EN_SHIFT (1)
+#define RG_EARCRXPLL_SDM_PCW_CHG_SHIFT (0)
+
+#define HDMI_1_READ_PLL	0x68
+
+#define RGS_HDMITXPLL_VCOCAL_CPLT	(0x1 << 31)
+#define RGS_HDMITXPLL_VCOCAL_STATE	(0xff << 23)
+
+#define RGS_HDMITXPLL_VCOCAL_CPLT_SHIFT (31)
+#define RGS_HDMITXPLL_VCOCAL_STATE_SHIFT (23)
+
+
+#define HDMI20_CLK_CFG	0x70
+
+#define reg_txc_div (0x3 << 30)
+#define reg_txc_data_2 (0x3ff << 20)
+#define reg_txc_data_1 (0x3ff << 10)
+#define reg_txc_data_0 (0x3ff << 0)
+
+#define reg_txc_div_SHIFT (30)
+#define reg_txc_data_2_SHIFT (20)
+#define reg_txc_data_1_SHIFT (10)
+#define reg_txc_data_0_SHIFT (0)
+
+
+#define HDMI_ANA_CTL	0x7c
+
+#define reg_ana_hdmi20_data_sync (0x1 << 20)
+#define reg_ana_hdmi20_packet_mode (0x1 << 19)
+#define reg_ana_hdmi20_mhl_mode (0x1 << 18)
+#define reg_ana_hdmi20_rd_inv (0x1 << 17)
+#define reg_ana_hdmi20_fifo_en (0x1 << 16)
+
+#define reg_ana_hdmi20_data_sync_SHIFT (20)
+#define reg_ana_hdmi20_packet_mode_SHIFT (19)
+#define reg_ana_hdmi20_mhl_mode_SHIFT (18)
+#define reg_ana_hdmi20_rd_inv_SHIFT (17)
+#define reg_ana_hdmi20_fifo_en_SHIFT (16)
+
+
+#define EARC_RX_CFG_3	0x80
+
+#define RG_EARCRXPLL_SDM_PCW (0xffffffff << 0)
+
+#define RG_EARCRXPLL_SDM_PCW_SHIFT (0)
+
+
+#define HDMI_1_CFG_21 0x84
+
+#define RG_HDMITX_DRV_IMP_CLK_EN1 GENMASK(31, 26)
+#define RG_HDMITX_DRV_IMP_D2_EN1 GENMASK(25, 20)
+#define RG_HDMITX_DRV_IMP_D1_EN1 GENMASK(19, 14)
+#define RG_HDMITX_DRV_IMP_D0_EN1 GENMASK(13, 8)
+
+#define RG_HDMITX_DRV_IMP_CLK_EN1_SHIFT (26)
+#define RG_HDMITX_DRV_IMP_D2_EN1_SHIFT (20)
+#define RG_HDMITX_DRV_IMP_D1_EN1_SHIFT (14)
+#define RG_HDMITX_DRV_IMP_D0_EN1_SHIFT (8)
+
+#define HDMI_1_CFG_22 0x88
+/*RG_HDMITX21_INTR_CAL_READOUT in 0x88 is different form
+ *RG_HDMITX21_INTR_CAL in 0x18, RG_HDMITX21_INTR_CAL can
+ *be write trough efuse or register, but
+ *RG_HDMITX21_INTR_CAL_READOUT only can be read
+ */
+#define RG_HDMITX21_INTR_CAL_READOUT GENMASK(22, 18)
+#define RG_HDMITX21_INTR_CAL_READOUT_SHIFT (18)
+
+#define HDMI_CTL_0	0xc0
+
+#define reg_eARC_auto_sync (0x1 << 7)
+#define reg_clk_inv (0x1 << 6)
+#define reg_fifo_en (0x1 << 5)
+
+#define reg_eARC_auto_sync_SHIFT (7)
+#define reg_clk_inv_SHIFT (6)
+#define reg_fifo_en_SHIFT (5)
+
+#define HDMI_CTL_1	0xc4
+
+#define RG_HDMITX_PWR5V_O BIT(9)
+#define RG_SW_HPD_ON BIT(8)
+#define RG_INTR_IMP_RG_MODE GENMASK(7, 3)
+#define RG_HDMIRX_PCW_SEL BIT(2)
+
+#define RG_HDMITX_PWR5V_O_SHIFT (9)
+#define RG_SW_HPD_ON_SHIFT (8)
+#define RG_INTR_IMP_RG_MODE_SHIFT (3)
+#define RG_HDMIRX_PCW_SEL_SHIFT (2)
+
+
+#define HDMI_CTL_2	0xc8
+
+#define lane_num (0xff << 24)
+#define reg_hd21_test_en (0x1 << 22)
+#define reg_16b18b_en (0x1 << 21)
+
+#define lane_num_SHIFT (24)
+#define reg_hd21_test_en_SHIFT (22)
+#define reg_16b18b_en_SHIFT (21)
+
+
+#define HDMI_CTL_3	0xcc
+
+#define REG_RESPLL_DIV_CONFIG GENMASK(31, 27)
+#define REG_PRBS_EN BIT(26)
+#define REG_PRBS_CLK_EN BIT(25)
+#define REG_PRBS_OUT_EN BIT(24)
+#define REG_HDMITX_PIXEL_CLOCK BIT(23)
+#define REG_HDMIRX_CK_SEL_1 BIT(22)
+#define REG_HDMIRX_CK_SEL_2 BIT(21)
+#define REG_HDMIRX_DIV_CONFG GENMASK(20, 16)
+#define REG_PIXEL_CLOCK_SEL BIT(10)
+#define REG_HDMITX_REF_RESPLL_SEL BIT(9)
+#define REG_HDMITX_REF_XTAL_SEL BIT(7)
+#define REG_MONITOR_SEL BIT(5)
+#define REG_HDMITXPLL_DIV GENMASK(4, 0)
+
+#define REG_RESPLL_DIV_CONFIG_SHIFT (27)
+#define REG_PRBS_EN_SHIFT (26)
+#define REG_PRBS_CLK_EN_SHIFT (25)
+#define REG_PRBS_OUT_EN_SHIFT (24)
+#define REG_HDMITX_PIXEL_CLOCK_SHIFT (23)
+#define REG_HDMIRX_CK_SEL_1_SHIFT (22)
+#define REG_HDMIRX_CK_SEL_2_SHIFT (21)
+#define REG_HDMIRX_DIV_CONFG_SHIFT (16)
+#define REG_PIXEL_CLOCK_SEL_SHIFT (10)
+#define REG_HDMITX_REF_RESPLL_SEL_SHIFT (9)
+#define REG_HDMITX_REF_XTAL_SEL_SHIFT (7)
+#define REG_MONITOR_SEL_SHIFT (5)
+#define REG_HDMITXPLL_DIV_SHIFT (0)
+
+#define HDMI_CTL_PSECUREB	0xd0
+#define REG_HDMI_PSECUREB GENMASK(31, 0)
+#define REG_HDMI_PSECUREB_SHIFT 0
+
+
+/*********HDMI21 tx analog register end*********/
+
+/*******HDMI tx digital register start******/
+#define TOP_CFG00 0x000
+
+#define ABIST_ENABLE (1 << 31)
+#define ABIST_DISABLE (0 << 31)
+#define ABIST_SPEED_MODE_SET (1 << 27)
+#define ABIST_SPEED_MODE_CLR (0 << 27)
+#define ABIST_DATA_FORMAT_STAIR (0 << 24)
+#define ABIST_DATA_FORMAT_0xAA (1 << 24)
+#define ABIST_DATA_FORMAT_0x55 (2 << 24)
+#define ABIST_DATA_FORMAT_0x11 (3 << 24)
+#define ABIST_VSYNC_POL_LOW (0 << 23)
+#define ABIST_VSYNC_POL_HIGH (1 << 23)
+#define ABIST_HSYNC_POL_LOW (0 << 22)
+#define ABIST_HSYNC_POL_HIGH (1 << 22)
+#define ABIST_VIDEO_FORMAT_720x480P (0x2 << 16)
+#define ABIST_VIDEO_FORMAT_720P60 (0x3 << 16)
+#define ABIST_VIDEO_FORMAT_1080I60 (0x4 << 16)
+#define ABIST_VIDEO_FORMAT_480I (0x5 << 16)
+#define ABIST_VIDEO_FORMAT_1440x480P (0x9 << 16)
+#define ABIST_VIDEO_FORMAT_1080P60 (0xA << 16)
+#define ABIST_VIDEO_FORMAT_576P (0xB << 16)
+#define ABIST_VIDEO_FORMAT_720P50 (0xC << 16)
+#define ABIST_VIDEO_FORMAT_1080I50 (0xD << 16)
+#define ABIST_VIDEO_FORMAT_576I (0xE << 16)
+#define ABIST_VIDEO_FORMAT_1440x576P (0x12 << 16)
+#define ABIST_VIDEO_FORMAT_1080P50 (0x13 << 16)
+#define ABIST_VIDEO_FORMAT_3840x2160P25 (0x18 << 16)
+#define ABIST_VIDEO_FORMAT_3840x2160P30 (0x19 << 16)
+#define ABIST_VIDEO_FORMAT_4096X2160P30 (0x1A << 16)
+#define ABIST_VIDEO_FORMAT_MASKBIT (0x3F << 16)
+#define HDMI2_BYP_ON (1 << 13)
+#define HDMI2_BYP_OFF (0 << 13)
+#define DEEPCOLOR_PAT_EN (1 << 12)
+#define DEEPCOLOR_PAT_DIS (0 << 12)
+#define DEEPCOLOR_MODE_8BIT (0 << 8)
+#define DEEPCOLOR_MODE_10BIT (1 << 8)
+#define DEEPCOLOR_MODE_12BIT (2 << 8)
+#define DEEPCOLOR_MODE_16BIT (3 << 8)
+#define DEEPCOLOR_MODE_MASKBIT (3 << 8)
+
+#define HDMIMODE_VAL_HDMI (1 << 7)
+#define HDMIMODE_VAL_DVI (0 << 7)
+#define HDMIMODE_OVR_ON (1 << 6)
+#define HDMIMODE_OVR_OFF (0 << 6)
+#define SCR_MODE_CTS (1 << 5)
+#define SCR_MODE_NORMAL (0 << 5)
+#define SCR_ON (1 << 4)
+#define SCR_OFF (0 << 4)
+#define HDMI_MODE_HDMI (1 << 3)
+#define HDMI_MODE_DVI (0 << 3)
+#define HDMI2_ON (1 << 2)
+#define HDMI2_OFF (0 << 2)
+
+
+/***********************************************/
+#define TOP_CFG01 0x004
+
+#define VIDEO_MUTE_DATA (0xFFFFFF << 4)
+#define NULL_PKT_VSYNC_HIGH_EN (1 << 3)
+#define NULL_PKT_VSYNC_HIGH_DIS (0 << 3)
+#define NULL_PKT_EN (1 << 2)
+#define NULL_PKT_DIS (0 << 2)
+#define CP_CLR_MUTE_EN (1 << 1)
+#define CP_CLR_MUTE_DIS (0 << 1)
+#define CP_SET_MUTE_EN (1 << 0)
+#define CP_SET_MUTE_DIS (0 << 0)
+
+
+/***********************************************/
+#define TOP_CFG02 0x008
+
+#define MHL_IEEE_NO (0xFFFFFF << 8)
+#define MHL_VFMT_EXTD (0x3 << 5)
+#define VSI_OVERRIDE_DIS (0x1 << 4)
+#define AVI_OVERRIDE_DIS (0x1 << 3)
+#define MINIVSYNC_ON (0x1 << 2)
+#define MHL_3DCONV_EN (0x1 << 1)
+#define INTR_ENCRYPTION_EN (0x1 << 0)
+#define INTR_ENCRYPTION_DIS (0x0 << 0)
+
+/***********************************************/
+#define TOP_AUD_MAP 0x00C
+
+#define SD7_MAP (0x7 << 28)
+#define SD6_MAP (0x7 << 24)
+#define SD5_MAP (0x7 << 20)
+#define SD4_MAP (0x7 << 16)
+#define SD3_MAP (0x7 << 12)
+#define SD2_MAP (0x7 << 8)
+#define SD1_MAP (0x7 << 4)
+#define SD0_MAP (0x7 << 0)
+
+#define C_SD7 (0x7 << 28)
+#define C_SD6 (0x6 << 24)
+#define C_SD5 (0x5 << 20)
+#define C_SD4 (0x4 << 16)
+#define C_SD3 (0x3 << 12)
+#define C_SD2 (0x2 << 8)
+#define C_SD1 (0x1 << 4)
+#define C_SD0 (0x0 << 0)
+
+
+/***********************************************/
+#define TOP_OUT00 0x010
+
+#define QC_SEL (0x3 << 10)
+#define Q2_SEL (0x3 << 8)
+#define Q1_SEL (0x3 << 6)
+#define Q0_SEL (0x3 << 4)
+#define USE_CH_MUX4 (0x1 << 2)
+#define USE_CH_MUX0 (0x0 << 2)
+#define TX_BIT_INV_EN (0x1 << 1)
+#define TX_BIT_INV_DIS (0x0 << 1)
+#define Q_9T0_BIT_SWAP (0x1 << 0)
+#define Q_9T0_NO_SWAP (0x0 << 0)
+
+#define SELECT_CK_CHANNEL 0x3
+#define SELECT_Q2_CHANNEL 0x2
+#define SELECT_Q1_CHANNEL 0x1
+#define SELECT_Q0_CHANNEL 0x0
+
+/***********************************************/
+#define TOP_OUT01 0x014
+
+#define TXC_DIV8 (0x3 << 0x30)
+#define TXC_DIV4 (0x2 << 0x30)
+#define TXC_DIV2 (0x1 << 0x30)
+#define TXC_DIV1 (0x0 << 0x30)
+#define TXC_DATA2 (0x3FF << 20)
+#define TXC_DATA1 (0x3FF << 10)
+#define TXC_DATA0 (0x3FF << 0)
+
+/***********************************************/
+#define TOP_OUT02 0x018
+
+#define FIX_OUT_EN (0x1 << 31)
+#define FIX_OUT_DIS (0x0 << 31)
+#define QOUT_DATA (0x3FFFFFFF << 0)
+
+/***********************************************/
+#define TOP_INFO_EN 0x01C
+
+#define GEN8_EN_WR (0x1 << 30)
+#define GEN8_DIS_WR (0x0 << 30)
+#define GEN7_EN_WR (0x1 << 29)
+#define GEN7_DIS_WR (0x0 << 29)
+#define GEN6_EN_WR (0x1 << 28)
+#define GEN6_DIS_WR (0x0 << 28)
+#define VSIF_EN_WR (0x1 << 27)
+#define VSIF_DIS_WR (0x0 << 27)
+#define GAMUT_EN_WR (0x1 << 26)
+#define GAMUT_DIS_WR (0x0 << 26)
+#define GEN5_EN_WR (0x1 << 25)
+#define GEN5_DIS_WR (0x0 << 25)
+#define GEN4_EN_WR (0x1 << 24)
+#define GEN4_DIS_WR (0x1 << 24)
+#define GEN3_EN_WR (0x1 << 23)
+#define GEN3_DIS_WR (0x0 << 23)
+#define GEN2_EN_WR (0x1 << 22)
+#define GEN2_DIS_WR (0x0 << 22)
+#define CP_EN_WR (0x1 << 21)
+#define CP_DIS_WR (0x0 << 21)
+#define GEN_EN_WR (0x1 << 20)
+#define GEN_DIS_WR (0x0 << 20)
+#define MPEG_EN_WR (0x1 << 19)
+#define MPEG_DIS_WR (0x0 << 19)
+#define AUD_EN_WR (0x1 << 18)
+#define AUD_DIS_WR (0x0 << 18)
+#define SPD_EN_WR (0x1 << 17)
+#define SPD_DIS_WR (0x0 << 17)
+#define AVI_EN_WR (0x1 << 16)
+#define AVI_DIS_WR (0x0 << 16)
+#define GEN8_EN (0x1 << 14)
+#define GEN8_DIS (0x0 << 14)
+#define GEN7_EN (0x1 << 13)
+#define GEN7_DIS (0x0 << 13)
+#define GEN6_EN (0x1 << 12)
+#define GEN6_DIS (0x0 << 12)
+#define VSIF_EN (0x1 << 11)
+#define VSIF_DIS (0x0 << 11)
+#define HDMI2_GAMUT_EN (0x1 << 10)
+#define HDMI2_GAMUT_DIS (0x0 << 10)
+#define GEN5_EN (0x1 << 9)
+#define GEN5_DIS (0x0 << 9)
+#define GEN4_EN (0x1 << 8)
+#define GEN4_DIS (0x1 << 8)
+#define GEN3_EN (0x1 << 7)
+#define GEN3_DIS (0x0 << 7)
+#define GEN2_EN (0x1 << 6)
+#define GEN2_DIS (0x0 << 6)
+#define CP_EN (0x1 << 5)
+#define CP_DIS (0x0 << 5)
+#define GEN_EN (0x1 << 4)
+#define GEN_DIS (0x0 << 4)
+#define MPEG_EN (0x1 << 3)
+#define MPEG_DIS (0x0 << 3)
+#define AUD_EN (0x1 << 2)
+#define AUD_DIS (0x0 << 2)
+#define SPD_EN (0x1 << 1)
+#define SPD_DIS (0x0 << 1)
+#define AVI_EN (0x1 << 0)
+#define AVI_DIS (0x0 << 0)
+
+/***********************************************/
+#define TOP_INFO_RPT 0x020
+
+#define GEN15_RPT_EN (0x1 << 21)
+#define GEN15_RPT_DIS (0x1 << 21)
+#define GEN14_RPT_EN (0x1 << 20)
+#define GEN14_RPT_DIS (0x1 << 20)
+#define GEN13_RPT_EN (0x1 << 19)
+#define GEN13_RPT_DIS (0x1 << 19)
+#define GEN12_RPT_EN (0x1 << 18)
+#define GEN12_RPT_DIS (0x1 << 18)
+#define GEN11_RPT_EN (0x1 << 17)
+#define GEN11_RPT_DIS (0x1 << 17)
+#define GEN10_RPT_EN (0x1 << 16)
+#define GEN10_RPT_DIS (0x1 << 16)
+#define GEN9_RPT_EN (0x1 << 15)
+#define GEN9_RPT_DIS (0x1 << 15)
+#define GEN8_RPT_EN (0x1 << 14)
+#define GEN8_RPT_DIS (0x1 << 14)
+#define GEN7_RPT_EN (0x1 << 13)
+#define GEN7_RPT_DIS (0x1 << 13)
+#define GEN6_RPT_EN (0x1 << 12)
+#define GEN6_RPT_DIS (0x1 << 12)
+#define VSIF_RPT_EN (0x1 << 11)
+#define VSIF_RPT_DIS (0x0 << 11)
+#define GAMUT_RPT_EN (0x1 << 10)
+#define GAMUT_RPT_DIS (0x0 << 10)
+#define GEN5_RPT_EN (0x1 << 9)
+#define GEN5_RPT_DIS (0x0 << 9)
+#define GEN4_RPT_EN (0x1 << 8)
+#define GEN4_RPT_DIS (0x1 << 8)
+#define GEN3_RPT_EN (0x1 << 7)
+#define GEN3_RPT_DIS (0x0 << 7)
+#define GEN2_RPT_EN (0x1 << 6)
+#define GEN2_RPT_DIS (0x0 << 6)
+#define CP_RPT_EN (0x1 << 5)
+#define CP_RPT_DIS (0x0 << 5)
+#define GEN_RPT_EN (0x1 << 4)
+#define GEN_RPT_DIS (0x0 << 4)
+#define MPEG_RPT_EN (0x1 << 3)
+#define MPEG_RPT_DIS (0x0 << 3)
+#define AUD_RPT_EN (0x1 << 2)
+#define AUD_RPT_DIS (0x0 << 2)
+#define SPD_RPT_EN (0x1 << 1)
+#define SPD_RPT_DIS (0x0 << 1)
+#define AVI_RPT_EN (0x1 << 0)
+#define AVI_RPT_DIS (0x0 << 0)
+
+/***********************************************/
+#define TOP_AVI_HEADER 0x024
+
+#define AVI_HEADER (0xFFFFFF << 0)
+
+/***********************************************/
+#define TOP_AVI_PKT00 0x028
+
+#define AVI_PKT00 (0xFFFFFFFF << 0)
+
+/***********************************************/
+#define TOP_AVI_PKT01 0x02C
+
+#define AVI_PKT01 (0xFFFFFF << 0)
+
+/***********************************************/
+#define TOP_AVI_PKT02 0x030
+
+#define AVI_PKT02 (0xFFFFFFFF << 0)
+
+/***********************************************/
+#define TOP_AVI_PKT03 0x034
+
+#define AVI_PKT03 (0xFFFFFF << 0)
+
+/***********************************************/
+#define TOP_AVI_PKT04 0x038
+
+#define AVI_PKT04 (0xFFFFFFFF << 0)
+
+/***********************************************/
+#define TOP_AVI_PKT05 0x03C
+
+#define AVI_PKT05 (0xFFFFFF << 0)
+
+/***********************************************/
+#define TOP_AIF_HEADER 0x040
+
+#define AIF_HEADER (0x00FFFFFF << 0)
+
+/***********************************************/
+#define TOP_AIF_PKT00 0x044
+
+#define AIF_PKT00 (0xFFFFFFFF << 0)
+
+/***********************************************/
+#define TOP_AIF_PKT01 0x048
+
+#define AIF_PKT01 (0x00FFFFFF << 0)
+
+/***********************************************/
+#define TOP_AIF_PKT02 0x04C
+
+#define AIF_PKT02 (0xFFFFFFFF << 0)
+
+/***********************************************/
+#define TOP_AIF_PKT03 0x050
+
+#define AIF_PKT03 (0x00FFFFFF << 0)
+
+/***********************************************/
+#define TOP_SPDIF_HEADER 0x054
+
+#define SPDIF_HEADER (0x00FFFFFF << 0)
+
+/***********************************************/
+#define TOP_SPDIF_PKT00 0x058
+
+#define SPDIF_PKT00 (0xFFFFFFFF << 0)
+
+/***********************************************/
+#define TOP_SPDIF_PKT01 0x05C
+
+#define SPDIF_PKT01 (0x00FFFFFF << 0)
+
+/***********************************************/
+#define TOP_SPDIF_PKT02 0x060
+
+#define SPDIF_PKT02 (0xFFFFFFFF << 0)
+
+/***********************************************/
+#define TOP_SPDIF_PKT03 0x064
+
+#define SPDIF_PKT03 (0x00FFFFFF << 0)
+
+/***********************************************/
+#define TOP_SPDIF_PKT04 0x068
+
+#define SPDIF_PKT04 (0xFFFFFFFF << 0)
+
+/***********************************************/
+#define TOP_SPDIF_PKT05 0x06C
+
+#define SPDIF_PKT05 (0x00FFFFFF << 0)
+
+/***********************************************/
+#define TOP_SPDIF_PKT06 0x070
+
+#define SPDIF_PKT06 (0xFFFFFFFF << 0)
+
+/***********************************************/
+#define TOP_SPDIF_PKT07 0x074
+
+#define SPDIF_PKT07 (0x00FFFFFF << 0)
+
+/***********************************************/
+#define TOP_MPEG_HEADER 0x078
+
+#define MPEG_HEADER (0x00FFFFFF << 0)
+
+/***********************************************/
+#define TOP_MPEG_PKT00 0x07C
+
+#define MPEG_PKT00 (0xFFFFFFFF << 0)
+
+/***********************************************/
+#define TOP_MPEG_PKT01 0x080
+
+#define MPEG_PKT01 (0x00FFFFFF << 0)
+
+/***********************************************/
+#define TOP_MPEG_PKT02 0x084
+
+#define MPEG_PKT02 (0xFFFFFFFF << 0)
+
+/***********************************************/
+#define TOP_MPEG_PKT03 0x088
+
+#define MPEG_PKT03 (0x00FFFFFF << 0)
+
+/***********************************************/
+#define TOP_MPEG_PKT04 0x08C
+
+#define MPEG_PKT04 (0xFFFFFFFF << 0)
+
+/***********************************************/
+#define TOP_MPEG_PKT05 0x090
+
+#define MPEG_PKT05 (0x00FFFFFF << 0)
+
+/***********************************************/
+#define TOP_MPEG_PKT06 0x094
+
+#define MPEG_PKT06 (0xFFFFFFFF << 0)
+
+/***********************************************/
+#define TOP_MPEG_PKT07 0x098
+
+#define MPEG_PKT07 (0x00FFFFFF << 0)
+
+/***********************************************/
+#define TOP_GEN_HEADER 0x09C
+
+#define GEN_HEADER (0x00FFFFFF << 0)
+
+/***********************************************/
+#define TOP_GEN_PKT00 0x0A0
+
+#define GEN_PKT00 (0xFFFFFFFF << 0)
+
+/***********************************************/
+#define TOP_GEN_PKT01 0x0A4
+
+#define GEN_PKT01 (0x00FFFFFF << 0)
+
+/***********************************************/
+#define TOP_GEN_PKT02 0x0A8
+
+#define GEN_PKT02 (0xFFFFFFFF << 0)
+
+/***********************************************/
+#define TOP_GEN_PKT03 0x0AC
+
+#define GEN_PKT03 (0x00FFFFFF << 0)
+
+/***********************************************/
+#define TOP_GEN_PKT04 0x0B0
+
+#define GEN_PKT04 (0xFFFFFFFF << 0)
+
+/***********************************************/
+#define TOP_GEN_PKT05 0x0B4
+
+#define GEN_PKT05 (0x00FFFFFF << 0)
+
+/***********************************************/
+#define TOP_GEN_PKT06 0x0B8
+
+#define GEN_PKT06 (0xFFFFFFFF << 0)
+
+/***********************************************/
+#define TOP_GEN_PKT07 0x0BC
+
+#define GEN_PKT07 (0x00FFFFFF << 0)
+
+/***********************************************/
+#define TOP_GEN2_HEADER 0x0C0
+
+#define GEN2_HEADER (0x00FFFFFF << 0)
+
+/***********************************************/
+#define TOP_GEN2_PKT00 0x0C4
+
+#define GEN2_PKT00 (0xFFFFFFFF << 0)
+
+/***********************************************/
+#define TOP_GEN2_PKT01 0x0C8
+
+#define GEN2_PKT01 (0x00FFFFFF << 0)
+
+/***********************************************/
+#define TOP_GEN2_PKT02 0x0CC
+
+#define GEN2_PKT02 (0xFFFFFFFF << 0)
+
+/***********************************************/
+#define TOP_GEN2_PKT03 0x0D0
+
+#define GEN2_PKT03 (0x00FFFFFF << 0)
+
+/***********************************************/
+#define TOP_GEN2_PKT04 0x0D4
+
+#define GEN2_PKT04 (0xFFFFFFFF << 0)
+
+/***********************************************/
+#define TOP_GEN2_PKT05 0x0D8
+
+#define GEN2_PKT05 (0x00FFFFFF << 0)
+
+/***********************************************/
+#define TOP_GEN2_PKT06 0x0DC
+
+#define GEN2_PKT06 (0xFFFFFFFF << 0)
+
+/***********************************************/
+#define TOP_GEN2_PKT07 0x0E0
+
+#define GEN2_PKT07 (0x00FFFFFF << 0)
+
+/***********************************************/
+#define TOP_GEN3_HEADER 0x0E4
+
+#define GEN3_HEADER (0x00FFFFFF << 0)
+
+/***********************************************/
+#define TOP_GEN3_PKT00 0x0E8
+
+#define GEN3_PKT00 (0xFFFFFFFF << 0)
+
+/***********************************************/
+#define TOP_GEN3_PKT01 0x0EC
+
+#define GEN3_PKT01 (0x00FFFFFF << 0)
+
+/***********************************************/
+#define TOP_GEN3_PKT02 0x0F0
+
+#define GEN3_PKT02 (0xFFFFFFFF << 0)
+
+/***********************************************/
+#define TOP_GEN3_PKT03 0x0F4
+
+#define GEN3_PKT03 (0x00FFFFFF << 0)
+
+/***********************************************/
+#define TOP_GEN3_PKT04 0x0F8
+
+#define GEN3_PKT04 (0xFFFFFFFF << 0)
+
+/***********************************************/
+#define TOP_GEN3_PKT05 0x0FC
+
+#define GEN3_PKT05 (0x00FFFFFF << 0)
+
+/***********************************************/
+#define TOP_GEN3_PKT06 0x100
+
+#define GEN3_PKT06 (0xFFFFFFFF << 0)
+
+/***********************************************/
+#define TOP_GEN3_PKT07 0x104
+
+#define GEN3_PKT07 (0x00FFFFFF << 0)
+
+/***********************************************/
+#define TOP_GEN4_HEADER 0x108
+
+#define GEN4_HEADER (0x00FFFFFF << 0)
+
+/***********************************************/
+#define TOP_GEN4_PKT00 0x10C
+
+#define GEN4_PKT00 (0xFFFFFFFF << 0)
+
+/***********************************************/
+#define TOP_GEN4_PKT01 0x110
+
+#define GEN4_PKT01 (0x00FFFFFF << 0)
+
+/***********************************************/
+#define TOP_GEN4_PKT02 0x114
+
+#define GEN4_PKT02 (0xFFFFFFFF << 0)
+
+/***********************************************/
+#define TOP_GEN4_PKT03 0x118
+
+#define GEN4_PKT03 (0x00FFFFFF << 0)
+
+/***********************************************/
+#define TOP_GEN4_PKT04 0x11C
+
+#define GEN4_PKT04 (0xFFFFFFFF << 0)
+
+/***********************************************/
+#define TOP_GEN4_PKT05 0x120
+
+#define GEN4_PKT05 (0x00FFFFFF << 0)
+
+/***********************************************/
+#define TOP_GEN4_PKT06 0x124
+
+#define GEN4_PKT06 (0xFFFFFFFF << 0)
+
+/***********************************************/
+#define TOP_GEN4_PKT07 0x128
+
+#define GEN4_PKT07 (0x00FFFFFF << 0)
+
+/***********************************************/
+#define TOP_GEN5_HEADER 0x12C
+
+#define GEN5_HEADER (0x00FFFFFF << 0)
+
+/***********************************************/
+#define TOP_GEN5_PKT00 0x130
+
+#define GEN5_PKT00 (0xFFFFFFFF << 0)
+
+/***********************************************/
+#define TOP_GEN5_PKT01 0x134
+
+#define GEN5_PKT01 (0x00FFFFFF << 0)
+
+/***********************************************/
+#define TOP_GEN5_PKT02 0x138
+
+#define GEN5_PKT02 (0xFFFFFFFF << 0)
+
+/***********************************************/
+#define TOP_GEN5_PKT03 0x13C
+
+#define GEN5_PKT03 (0x00FFFFFF << 0)
+
+/***********************************************/
+#define TOP_GEN5_PKT04 0x140
+
+#define GEN5_PKT04 (0xFFFFFFFF << 0)
+
+/***********************************************/
+#define TOP_GEN5_PKT05 0x144
+
+#define GEN5_PKT05 (0x00FFFFFF << 0)
+
+/***********************************************/
+#define TOP_GEN5_PKT06 0x148
+
+#define GEN5_PKT06 (0xFFFFFFFF << 0)
+
+/***********************************************/
+#define TOP_GEN5_PKT07 0x14C
+
+#define GEN5_PKT07 (0x00FFFFFF << 0)
+
+/***********************************************/
+#define TOP_GAMUT_HEADER 0x150
+
+#define GAMUT_HEADER (0x00FFFFFF << 0)
+
+/***********************************************/
+#define TOP_GAMUT_PKT00 0x154
+
+#define GAMUT_PKT00 (0xFFFFFFFF << 0)
+
+/***********************************************/
+#define TOP_GAMUT_PKT01 0x158
+
+#define GAMUT_PKT01 (0x00FFFFFF << 0)
+
+/***********************************************/
+#define TOP_GAMUT_PKT02 0x15C
+
+#define GAMUT_PKT02 (0xFFFFFFFF << 0)
+
+/***********************************************/
+#define TOP_GAMUT_PKT03 0x160
+
+#define GAMUT_PKT03 (0x00FFFFFF << 0)
+
+/***********************************************/
+#define TOP_GAMUT_PKT04 0x164
+
+#define GAMUT_PKT04 (0xFFFFFFFF << 0)
+
+/***********************************************/
+#define TOP_GAMUT_PKT05 0x168
+
+#define GAMUT_PKT05 (0x00FFFFFF << 0)
+
+/***********************************************/
+#define TOP_GAMUT_PKT06 0x16C
+
+#define GAMUT_PKT06 (0xFFFFFFFF << 0)
+
+/***********************************************/
+#define TOP_GAMUT_PKT07 0x170
+
+#define GAMUT_PKT07 (0x00FFFFFF << 0)
+
+/***********************************************/
+#define TOP_VSIF_HEADER 0x174
+
+#define VSIF_HEADER (0x00FFFFFF << 0)
+
+/***********************************************/
+#define TOP_VSIF_PKT00 0x178
+
+#define VSIF_PKT00 (0xFFFFFFFF << 0)
+
+/***********************************************/
+#define TOP_VSIF_PKT01 0x17C
+
+#define VSIF_PKT01 (0x00FFFFFF << 0)
+
+/***********************************************/
+#define TOP_VSIF_PKT02 0x180
+
+#define VSIF_PKT02 (0xFFFFFFFF << 0)
+
+/***********************************************/
+#define TOP_VSIF_PKT03 0x184
+
+#define VSIF_PKT03 (0x00FFFFFF << 0)
+
+/***********************************************/
+#define TOP_VSIF_PKT04 0x188
+
+#define VSIF_PKT04 (0xFFFFFFFF << 0)
+
+/***********************************************/
+#define TOP_VSIF_PKT05 0x18C
+
+#define VSIF_PKT05 (0x00FFFFFF << 0)
+
+/***********************************************/
+#define TOP_VSIF_PKT06 0x190
+
+#define VSIF_PKT06 (0xFFFFFFFF << 0)
+
+/***********************************************/
+#define TOP_VSIF_PKT07 0x194
+
+#define VSIF_PKT07 (0x00FFFFFF << 0)
+
+/***********************************************/
+#define TOP_DROP_CFG00 0x198
+
+#define LR_SWAP (0x01<<0)
+#define LFE_CC_SWAP (0x01<<1)
+#define LSRS_SWAP (0x01<<2)
+#define RLS_RRS_SWAP (0x01<<3)
+#define LR_STATUS_SWAP (0x01<<4)
+
+
+/***********************************************/
+#define TOP_DROP_CFG01 0x19C
+
+/***********************************************/
+
+
+/***********************************************/
+#define TOP_MISC_CTLR 0x1A4
+
+#define INFO_HEADER (0xFF << 16)
+#define DISABLE_IDLE_DDC_RESET (0x1 << 7)
+#define DEEP_COLOR_ADD (0x1 << 4)
+#define HSYNC_POL_POS (0x1 << 1)
+#define HSYNC_POL_NEG (0x0 << 1)
+#define VSYNC_POL_POS (0x1 << 0)
+#define VSYNC_POL_NEG (0x0 << 0)
+
+/***********************************************/
+#define TOP_INT_STA00 0x1A8
+
+#define DDC_FIFO_HALF_FULL_INT_STA (1 << 31)
+#define DDC_FIFO_FULL_INT_STA (1 << 30)
+#define DDC_I2C_IN_PROG_INT_STA (1 << 29)
+#define HDCP_RI_128_INT_STA (1 << 28)
+#define HDCP_SHA_START_INT_STA (1 << 27)
+#define HDCP2X_RX_RPT_READY_DDCM_INT_STA (1 << 26)
+#define HDCP2X_RX_REAUTH_REQ_DDCM_INT_STA (1 << 25)
+#define HDCP2X_RPT_SMNG_XFER_DONE_INT_STA (1 << 24)
+#define HDCP2X_RPT_RCVID_CHANGED_INT_STA (1 << 23)
+#define HDCP2X_CERT_SEND_RCVD_INT_STA (1 << 22)
+#define HDCP2X_SKE_SENT_RCVD_INT_STA (1 << 21)
+#define HDCP2X_AKE_SENT_RCVD_INT_STA (1 << 20)
+#define HDCP2X_HASH_FAIL_INT_STA (1 << 19)
+#define HDCP2X_CCHK_DONE_INT_STA (1 << 18)
+#define HDCP2X_AUTH_FAIL_INT_STA (1 << 17)
+#define HDCP2X_AUTH_DONE_INT_STA (1 << 16)
+#define HDCP2X_MSG_7_INT_STA (1 << 15)
+#define HDCP2X_MSG_6_INT_STA (1 << 14)
+#define HDCP2X_MSG_5_INT_STA (1 << 13)
+#define HDCP2X_MSG_4_INT_STA (1 << 12)
+#define HDCP2X_MSG_3_INT_STA (1 << 11)
+#define HDCP2X_MSG_2_INT_STA (1 << 10)
+#define HDCP2X_MSG_1_INT_STA (1 << 9)
+#define HDCP2X_MSG_0_INT_STA (1 << 8)
+#define INFO_DONE_INT_STA (1 << 7)
+#define PB_FULL_INT_STA (1 << 6)
+#define AUDIO_INT_STA (1 << 5)
+#define VSYNC_INT_STA (1 << 4)
+#define PORD_F_INT_STA (1 << 3)
+#define PORD_R_INT_STA (1 << 2)
+#define HTPLG_F_INT_STA (1 << 1)
+#define HTPLG_R_INT_STA (1 << 0)
+
+/***********************************************/
+#define TOP_INT_STA01 0x1AC
+
+#define HDCP2X_STATE_CHANGE_P_INT_STA (1 << 10)
+#define SCDC_UP_FLAG_DONE_INT_STA (1 << 9)
+#define SCDC_SLAVE_RD_REQ_P_INT_STA (1 << 8)
+#define SCDC_DDC_CONFICT_INT_STA (1 << 7)
+#define SCDC_DDC_DONE_INT_STA (1 << 6)
+#define RI_ERR3_INT_STA (1 << 5)
+#define RI_ERR2_INT_STA (1 << 4)
+#define RI_ERR1_INT_STA (1 << 3)
+#define RI_ERR0_INT_STA (1 << 2)
+#define RI_BCAP_ON_INT_STA (1 << 1)
+#define DDC_FIFO_EMPTY_INT_STA (1 << 0)
+
+/***********************************************/
+#define TOP_INT_MASK00 0x1B0
+
+#define DDC_FIFO_HALF_FULL_INT_MASK (0 << 31)
+#define DDC_FIFO_HALF_FULL_INT_UNMASK (1 << 31)
+#define DDC_FIFO_FULL_INT_MASK (0 << 30)
+#define DDC_FIFO_FULL_INT_UNMASK (1 << 30)
+#define DDC_I2C_IN_PROG_INT_MASK (0 << 29)
+#define DDC_I2C_IN_PROG_INT_UNMASK (1 << 29)
+#define HDCP_RI_128_INT_MASK (0 << 28)
+#define HDCP_RI_128_INT_UNMASK (1 << 28)
+#define HDCP_SHA_START_INT_MASK (0 << 27)
+#define HDCP_SHA_START_INT_UNMASK (1 << 27)
+#define HDCP2X_RX_RPT_READY_DDCM_INT_MASK (0 << 26)
+#define HDCP2X_RX_RPT_READY_DDCM_INT_UNMASK (1 << 26)
+#define HDCP2X_RX_REAUTH_REQ_DDCM_INT_MASK (0 << 25)
+#define HDCP2X_RX_REAUTH_REQ_DDCM_INT_UNMASK (1 << 25)
+#define HDCP2X_RPT_SMNG_XFER_DONE_INT_MASK (0 << 24)
+#define HDCP2X_RPT_SMNG_XFER_DONE_INT_UNMASK (1 << 24)
+#define HDCP2X_RPT_RCVID_CHANGED_INT_MASK (0 << 23)
+#define HDCP2X_RPT_RCVID_CHANGED_INT_UNMASK (1 << 23)
+#define HDCP2X_CERT_SEND_RCVD_INT_MASK (0 << 22)
+#define HDCP2X_CERT_SEND_RCVD_INT_UNMASK (1 << 22)
+#define HDCP2X_SKE_SENT_RCVD_INT_MASK (0 << 21)
+#define HDCP2X_SKE_SENT_RCVD_INT_UNMASK (1 << 21)
+#define HDCP2X_AKE_SENT_RCVD_INT_MASK (0 << 20)
+#define HDCP2X_AKE_SENT_RCVD_INT_UNMASK (1 << 20)
+#define HDCP2X_HASH_FAIL_INT_MASK (0 << 19)
+#define HDCP2X_HASH_FAIL_INT_UNMASK (1 << 19)
+#define HDCP2X_CCHK_DONE_INT_MASK (0 << 18)
+#define HDCP2X_CCHK_DONE_INT_UNMASK (1 << 18)
+#define HDCP2X_AUTH_FAIL_INT_MASK (0 << 17)
+#define HDCP2X_AUTH_FAIL_INT_UNMASK (1 << 17)
+#define HDCP2X_AUTH_DONE_INT_MASK (0 << 16)
+#define HDCP2X_AUTH_DONE_INT_UNMASK (1 << 16)
+#define HDCP2X_MSG_7_INT_MASK (0 << 15)
+#define HDCP2X_MSG_7_INT_UNMASK (1 << 15)
+#define HDCP2X_MSG_6_INT_MASK (0 << 14)
+#define HDCP2X_MSG_6_INT_UNMASK (1 << 14)
+#define HDCP2X_MSG_5_INT_MASK (0 << 13)
+#define HDCP2X_MSG_5_INT_UNMASK (1 << 13)
+#define HDCP2X_MSG_4_INT_MASK (0 << 12)
+#define HDCP2X_MSG_4_INT_UNMASK (1 << 12)
+#define HDCP2X_MSG_3_INT_MASK (0 << 11)
+#define HDCP2X_MSG_3_INT_UNMASK (1 << 11)
+#define HDCP2X_MSG_2_INT_MASK (0 << 10)
+#define HDCP2X_MSG_2_INT_UNMASK (1 << 10)
+#define HDCP2X_MSG_1_INT_MASK (0 << 9)
+#define HDCP2X_MSG_1_INT_UNMASK (1 << 9)
+#define HDCP2X_MSG_0_INT_MASK (0 << 8)
+#define HDCP2X_MSG_0_INT_UNMASK (1 << 8)
+#define INFO_DONE_INT_MASK (0 << 7)
+#define INFO_DONE_INT_UNMASK (1 << 7)
+#define PB_FULL_INT_MASK (0 << 6)
+#define PB_FULL_INT_UNMASK (1 << 6)
+#define AUDIO_INT_MASK (0 << 5)
+#define AUDIO_INT_UNMASK (1 << 5)
+#define VSYNC_INT_MASK (0 << 4)
+#define VSYNC_INT_UNMASK (1 << 4)
+#define PORD_F_INT_MASK (0 << 3)
+#define PORD_F_INT_UNMASK (1 << 3)
+#define PORD_R_INT_MASK (0 << 2)
+#define PORD_R_INT_UNMASK (1 << 2)
+#define HTPLG_F_INT_MASK (0 << 1)
+#define HTPLG_F_INT_UNMASK (1 << 1)
+#define HTPLG_R_INT_MASK (0 << 0)
+#define HTPLG_R_INT_UNMASK (1 << 0)
+
+/***********************************************/
+#define TOP_INT_MASK01 0x1B4
+
+#define HDCP2X_STATE_CHANGE_P_INT_MASK (1 << 10)
+#define SCDC_UP_FLAG_DONE_INT_MASK (1 << 9)
+#define SCDC_SLAVE_RD_REQ_P_INT_MASK (1 << 8)
+#define SCDC_DDC_CONFICT_INT_MASK (1 << 7)
+#define SCDC_DDC_DONE_INT_MASK (1 << 6)
+#define RI_ERR3_INT_MASK (1 << 5)
+#define RI_ERR2_INT_MASK (1 << 4)
+#define RI_ERR1_INT_MASK (1 << 3)
+#define RI_ERR0_INT_MASK (1 << 2)
+#define RI_BCAP_ON_INT_MASK (1 << 1)
+#define DDC_FIFO_EMPTY_INT_MASK (1 << 0)
+
+#define HDCP2X_STATE_CHANGE_P_INT_UNMASK (0 << 10)
+#define SCDC_UP_FLAG_DONE_INT_UNMASK (0 << 9)
+#define SCDC_SLAVE_RD_REQ_P_INT_UNMASK (0 << 8)
+#define SCDC_DDC_CONFICT_INT_UNMASK (0 << 7)
+#define SCDC_DDC_DONE_INT_UNMASK (0 << 6)
+#define RI_ERR3_INT_UNMASK (0 << 5)
+#define RI_ERR2_INT_UNMASK (0 << 4)
+#define RI_ERR1_INT_UNMASK (0 << 3)
+#define RI_ERR0_INT_UNMASK (0 << 2)
+#define RI_BCAP_ON_INT_UNMASK (0 << 1)
+#define DDC_FIFO_EMPTY_INT_UNMASK (0 << 0)
+/***********************************************/
+#define TOP_INT_CLR00 0x1B8
+
+#define DDC_FIFO_HALF_FULL_INT_CLR (1 << 31)
+#define DDC_FIFO_FULL_INT_CLR (1 << 30)
+#define DDC_I2C_IN_PROG_INT_CLR (1 << 29)
+#define HDCP_RI_128_INT_CLR (1 << 28)
+#define HDCP_SHA_START_INT_CLR (1 << 27)
+#define HDCP2X_RX_RPT_READY_DDCM_INT_CLR (1 << 26)
+#define HDCP2X_RX_REAUTH_REQ_DDCM_INT_CLR (1 << 25)
+#define HDCP2X_RPT_SMNG_XFER_DONE_INT_CLR (1 << 24)
+#define HDCP2X_RPT_RCVID_CHANGED_INT_CLR (1 << 23)
+#define HDCP2X_CERT_SEND_RCVD_INT_CLR (1 << 22)
+#define HDCP2X_SKE_SENT_RCVD_INT_CLR (1 << 21)
+#define HDCP2X_AKE_SENT_RCVD_INT_CLR (1 << 20)
+#define HDCP2X_HASH_FAIL_INT_CLR (1 << 19)
+#define HDCP2X_CCHK_DONE_INT_CLR (1 << 18)
+#define HDCP2X_AUTH_FAIL_INT_CLR (1 << 17)
+#define HDCP2X_AUTH_DONE_INT_CLR (1 << 16)
+#define HDCP2X_MSG_7_INT_CLR (1 << 15)
+#define HDCP2X_MSG_6_INT_CLR (1 << 14)
+#define HDCP2X_MSG_5_INT_CLR (1 << 13)
+#define HDCP2X_MSG_4_INT_CLR (1 << 12)
+#define HDCP2X_MSG_3_INT_CLR (1 << 11)
+#define HDCP2X_MSG_2_INT_CLR (1 << 10)
+#define HDCP2X_MSG_1_INT_CLR (1 << 9)
+#define HDCP2X_MSG_0_INT_CLR (1 << 8)
+#define INFO_DONE_INT_CLR (1 << 7)
+#define PB_FULL_INT_CLR (1 << 6)
+#define AUDIO_INT_CLR (1 << 5)
+#define VSYNC_INT_CLR (1 << 4)
+#define PORD_F_INT_CLR (1 << 3)
+#define PORD_R_INT_CLR (1 << 2)
+#define HTPLG_F_INT_CLR (1 << 1)
+#define HTPLG_R_INT_CLR (1 << 0)
+
+#define DDC_FIFO_HALF_FULL_INT_UNCLR (0 << 31)
+#define DDC_FIFO_FULL_INT_UNCLR (0 << 30)
+#define DDC_I2C_IN_PROG_INT_UNCLR (0 << 29)
+#define HDCP_RI_128_INT_UNCLR (0 << 28)
+#define HDCP_SHA_START_INT_UNCLR (0 << 27)
+#define HDCP2X_RX_RPT_READY_DDCM_INT_UNCLR (0 << 26)
+#define HDCP2X_RX_REAUTH_REQ_DDCM_INT_UNCLR (0 << 25)
+#define HDCP2X_RPT_SMNG_XFER_DONE_INT_UNCLR (0 << 24)
+#define HDCP2X_RPT_RCVID_CHANGED_INT_UNCLR (0 << 23)
+#define HDCP2X_CERT_SEND_RCVD_INT_UNCLR (0 << 22)
+#define HDCP2X_SKE_SENT_RCVD_INT_UNCLR (0 << 21)
+#define HDCP2X_AKE_SENT_RCVD_INT_UNCLR (0 << 20)
+#define HDCP2X_HASH_FAIL_INT_UNCLR (0 << 19)
+#define HDCP2X_CCHK_DONE_INT_UNCLR (0 << 18)
+#define HDCP2X_AUTH_FAIL_INT_UNCLR (0 << 17)
+#define HDCP2X_AUTH_DONE_INT_UNCLR (0 << 16)
+#define HDCP2X_MSG_7_INT_UNCLR (0 << 15)
+#define HDCP2X_MSG_6_INT_UNCLR (0 << 14)
+#define HDCP2X_MSG_5_INT_UNCLR (0 << 13)
+#define HDCP2X_MSG_4_INT_UNCLR (0 << 12)
+#define HDCP2X_MSG_3_INT_UNCLR (0 << 11)
+#define HDCP2X_MSG_2_INT_UNCLR (0 << 10)
+#define HDCP2X_MSG_1_INT_UNCLR (0 << 9)
+#define HDCP2X_MSG_0_INT_UNCLR (0 << 8)
+#define INFO_DONE_INT_UNCLR (0 << 7)
+#define PB_FULL_INT_UNCLR (0 << 6)
+#define AUDIO_INT_UNCLR (0 << 5)
+#define VSYNC_INT_UNCLR (0 << 4)
+#define PORD_F_INT_UNCLR (0 << 3)
+#define PORD_R_INT_UNCLR (0 << 2)
+#define HTPLG_F_INT_UNCLR (0 << 1)
+#define HTPLG_R_INT_UNCLR (0 << 0)
+
+/***********************************************/
+#define TOP_INT_CLR01 0x1BC
+
+#define HDCP2X_STATE_CHANGE_P_INT_CLR (1 << 10)
+#define SCDC_UP_FLAG_DONE_INT_CLR (1 << 9)
+#define SCDC_SLAVE_RD_REQ_P_INT_CLR (1 << 8)
+#define SCDC_DDC_CONFICT_INT_CLR (1 << 7)
+#define SCDC_DDC_DONE_INT_CLR (1 << 6)
+#define RI_ERR3_INT_CLR (1 << 5)
+#define RI_ERR2_INT_CLR (1 << 4)
+#define RI_ERR1_INT_CLR (1 << 3)
+#define RI_ERR0_INT_CLR (1 << 2)
+#define RI_BCAP_ON_INT_CLR (1 << 1)
+#define DDC_FIFO_EMPTY_INT_CLR (1 << 0)
+
+#define HDCP2X_STATE_CHANGE_P_INT_UNCLR (0 << 10)
+#define SCDC_UP_FLAG_DONE_INT_UNCLR (0 << 9)
+#define SCDC_SLAVE_RD_REQ_P_INT_UNCLR (0 << 8)
+#define SCDC_DDC_CONFICT_INT_UNCLR (0 << 7)
+#define SCDC_DDC_DONE_INT_UNCLR (0 << 6)
+#define RI_ERR3_INT_UNCLR (0 << 5)
+#define RI_ERR2_INT_UNCLR (0 << 4)
+#define RI_ERR1_INT_UNCLR (0 << 3)
+#define RI_ERR0_INT_UNCLR (0 << 2)
+#define RI_BCAP_ON_INT_UNCLR (0 << 1)
+#define DDC_FIFO_EMPTY_INT_UNCLR (0 << 0)
+
+/***********************************************/
+#define TOP_STA 0x1C0
+
+#define STARTUP_FLAG (1 << 13)
+#define P_STABLE (1 << 12)
+#define CEA_AVI_EN (1 << 11)
+#define CEA_SPD_EN (1 << 10)
+#define CEA_AUD_EN (1 << 9)
+#define CEA_MPEG_EN (1 << 8)
+#define CEA_GEN_EN (1 << 7)
+#define CEA_CP_EN (1 << 6)
+#define CEA_GEN2_EN (1 << 5)
+#define CEA_GEN3_EN (1 << 4)
+#define CEA_GEN4_EN (1 << 3)
+#define CEA_GEN5_EN (1 << 2)
+#define CEA_GAMUT_EN (1 << 1)
+#define CEA_VSIF_EN (1 << 0)
+
+#define TOP_VMUTE_CFG1 0x1C8
+#define REG_VMUTE_EN (1 << 16)
+
+#define TOP_VMUTE_CFG2 0x1CC
+
+#define HDMI_PLLMETER_TRIGGER 0x1D0
+#define HDMI_PLL_FREQ_TRGGIER (1 << 0)
+
+#define HDMI_PLLMETER 0x1D4
+#define HDMI_PLLMETER_ENABLE (1 << 10)
+#define HDMI_PLLMETER_RESULT (0xFFFF << 16)
+
+#define TOP_GEN6_HEADER 0x200
+#define TOP_GEN6_PKT00 0x204
+
+#define TOP_GEN7_HEADER 0x224
+#define TOP_GEN7_PKT00 0x228
+
+#define TOP_GEN8_HEADER 0x248
+#define TOP_GEN8_PKT00 0x24c
+
+#define TOP_GEN9_HEADER 0x26c
+#define TOP_GEN9_PKT00 0x270
+
+#define TOP_GEN10_HEADER 0x290
+#define TOP_GEN10_PKT00 0x294
+
+#define TOP_GEN11_HEADER 0x2b4
+#define TOP_GEN11_PKT00 0x2b8
+
+#define TOP_GEN12_HEADER 0x2d8
+#define TOP_GEN12_PKT00 0x2dc
+
+#define TOP_GEN13_HEADER 0x2fc
+#define TOP_GEN13_PKT00 0x300
+
+#define TOP_GEN14_HEADER 0x320
+#define TOP_GEN14_PKT00 0x324
+
+#define TOP_GEN15_HEADER 0x344
+#define TOP_GEN15_PKT00 0x348
+
+#define TOP_INFO_EN_EXPAND 0x368
+
+#define GEN15_EN_WR (0x1 << 22)
+#define GEN15_DIS_WR (0x0 << 22)
+#define GEN14_EN_WR (0x1 << 21)
+#define GEN14_DIS_WR (0x0 << 21)
+#define GEN13_EN_WR (0x1 << 20)
+#define GEN13_DIS_WR (0x0 << 20)
+#define GEN12_EN_WR (0x1 << 19)
+#define GEN12_DIS_WR (0x0 << 19)
+#define GEN11_EN_WR (0x1 << 18)
+#define GEN11_DIS_WR (0x0 << 18)
+#define GEN10_EN_WR (0x1 << 17)
+#define GEN10_DIS_WR (0x0 << 17)
+#define GEN9_EN_WR (0x1 << 16)
+#define GEN9_DIS_WR (0x1 << 16)
+#define GEN15_EN (0x1 << 6)
+#define GEN15_DIS (0x0 << 6)
+#define GEN14_EN (0x1 << 5)
+#define GEN14_DIS (0x0 << 5)
+#define GEN13_EN (0x1 << 4)
+#define GEN13_DIS (0x0 << 4)
+#define GEN12_EN (0x1 << 3)
+#define GEN12_DIS (0x0 << 3)
+#define GEN11_EN (0x1 << 2)
+#define GEN11_DIS (0x0 << 2)
+#define GEN10_EN (0x1 << 1)
+#define GEN10_DIS (0x0 << 1)
+#define GEN9_EN (0x1 << 0)
+#define GEN9_DIS (0x0 << 0)
+
+#define TOP_VSYNC_SEND 0x370
+#define MAX_HSYNC_NUM (0xFF << 16)
+#define MIN_HSYNC_NUM (0xFF)
+
+enum HDMI_GEN_PACKET_HW_ENUM {
+	GEN_PKT_HW1,
+	GEN_PKT_HW2,
+	GEN_PKT_HW3,
+	GEN_PKT_HW4,
+	GEN_PKT_HW5,
+	GEN_PKT_HW6,
+	GEN_PKT_HW7,
+	GEN_PKT_HW8,
+	GEN_PKT_HW9,
+	GEN_PKT_HW10,
+	GEN_PKT_HW11,
+	GEN_PKT_HW12,
+	GEN_PKT_HW13,
+	GEN_PKT_HW14,
+	GEN_PKT_HW15,
+	GEN_PKT_HW_NUM,
+};
+
+struct PACKET_HW_T {
+	enum HDMI_GEN_PACKET_HW_ENUM hw_num;
+	unsigned int addr_header;
+	unsigned int addr_pkt;
+	unsigned int addr_wr_en;
+	unsigned int mask_wr_en;
+	unsigned int addr_rep_en;
+	unsigned int mask_rep_en;
+};
+
+/****HDMI TX digital register end****/
+
+
+/****HDMI audio register start*******/
+#define AIP_CTRL 0x400
+
+#define SPDIF_INTERNAL_MODULE (1 << 24)
+#define CTS_CAL_N4 (1 << 23)
+#define CTS_CAL_N2 (1 << 22)
+#define RESET_NEW_SPDIF (1 << 21)
+#define HBR_FROM_SPDIF (1 << 20)
+#define I2S_EN (0xF << 16)
+#define I2S_EN_SHIFT 16
+#define DSD_EN (1 << 15)
+#define HBRA_ON (1 << 14)
+#define HBRA_OFF (0 << 14)
+#define SPDIF_EN (1 << 13)
+#define SPDIF_EN_SHIFT 13
+#define SPDIF_DIS (0 << 13)
+#define AUD_PKT_EN (1 << 12)
+#define AUD_PAR_EN (1 << 10)
+#define AUD_SEL_OWRT (1 << 9)
+#define AUD_IN_EN (1 << 8)
+#define AUD_IN_EN_SHIFT 8
+#define FM_IN_VAL_SW (0x7 << 4)
+#define MCLK_128FS 0x0
+#define MCLK_256FS 0x1
+#define MCLK_384FS 0x2
+#define MCLK_512FS 0x3
+#define MCLK_768FS 0x4
+#define MCLK_1024FS 0x5
+#define MCLK_1152FS 0x6
+#define MCLK_192FS 0x7
+#define NO_MCLK_CTSGEN_SEL (1 << 3)
+#define MCLK_CTSGEN_SEL (0 << 3)
+#define MCLK_EN (1 << 2)
+#define CTS_REQ_EN (1 << 1)
+#define CTS_REQ_DIS (0 << 1)
+#define CTS_SW_SEL (1 << 0)
+#define CTS_HW_SEL (0 << 0)
+
+/***********************************************/
+#define AIP_N_VAL 0x404
+
+#define N_VAL_SW (0xFFFFF << 0)
+
+/***********************************************/
+#define AIP_CTS_SVAL 0x408
+
+#define CTS_VAL_SW (0xFFFFF << 0)
+
+/***********************************************/
+#define AIP_SPDIF_CTRL 0x40C
+
+#define I2S2DSD_EN (1 << 30)
+#define AUD_ERR_THRESH (0x3F << 24)
+#define AUD_ERR_THRESH_SHIFT 24
+
+#define MAX_2UI_WRITE (0xFF << 16)
+#define MAX_2UI_WRITE_SHIFT 16
+
+#define MAX_1UI_WRITE (0xFF << 8)
+#define MAX_1UI_WRITE_SHIFT 8
+
+#define WR_2UI_LOCK (1 << 2)
+#define WR_2UI_UNLOCK (0 << 2)
+#define FS_OVERRIDE_WRITE (1 << 1)
+#define FS_UNOVERRIDE (0 << 1)
+#define WR_1UI_LOCK (1 << 0)
+#define WR_1UI_UNLOCK (0 << 0)
+
+/***********************************************/
+#define AIP_I2S_CTRL 0x410
+
+#define DSD_INTERLEAVE (0xFF << 20)
+#define I2S_IN_LENGTH (0xF << 16)
+#define I2S_IN_LENGTH_SHIFT 16
+#define I2S_LENGTH_24BITS 0xB
+#define I2S_LENGTH_23BITS 0x9
+#define I2S_LENGTH_22BITS 0x5
+#define I2S_LENGTH_21BITS 0xD
+#define I2S_LENGTH_20BITS 0xA
+#define I2S_LENGTH_19BITS 0x8
+#define I2S_LENGTH_18BITS 0x4
+#define I2S_LENGTH_17BITS 0xC
+#define I2S_LENGTH_16BITS 0x2
+#define SCK_EDGE_RISE (0x1 << 14)
+#define SCK_EDGE_FALL (0x0 << 14)
+#define CBIT_ORDER_SAME (0x1 << 13)
+#define CBIT_ORDER_CON (0x0 << 13)
+#define VBIT_PCM (0x0 << 12)
+#define VBIT_COM (0x1 << 12)
+#define WS_LOW (0x0 << 11)
+#define WS_HIGH (0x1 << 11)
+#define JUSTIFY_RIGHT (0x1 << 10)
+#define JUSTIFY_LEFT (0x0 << 10)
+#define DATA_DIR_MSB (0x0 << 9)
+#define DATA_DIR_LSB (0x1 << 9)
+#define I2S_1ST_BIT_SHIFT (0x0 << 8)
+#define I2S_1ST_BIT_NOSHIFT (0x1 << 8)
+#define FIFO3_MAP (0x3 << 6)
+#define FIFO2_MAP (0x3 << 4)
+#define FIFO1_MAP (0x3 << 2)
+#define FIFO0_MAP (0x3 << 0)
+#define MAP_SD0 0x0
+#define MAP_SD1 0x1
+#define MAP_SD2 0x2
+#define MAP_SD3 0x3
+
+/***********************************************/
+#define AIP_I2S_CHST0 0x414
+
+#define CBIT3B (0xF << 28)
+#define CBIT3A (0xF << 24)
+#define CBIT2B (0xF << 20)
+#define CBIT2A (0xF << 16)
+#define FS_2205KHZ 0x4
+#define FS_441KHZ 0x0
+#define FS_882KHZ 0x8
+#define FS_1764KHZ 0xC
+#define FS_24KHZ 0x6
+#define FS_48KHZ 0x2
+#define FS_96KHZ 0xA
+#define FS_192KHZ 0xE
+#define FS_32KHZ 0x3
+#define FS_768KHZ 0x9
+#define CBIT1 (0xFF << 8)
+#define CBIT0 (0xFF << 0)
+
+/***********************************************/
+#define AIP_I2S_CHST1 0x418
+
+#define CBIT_MSB (0xFFFF << 8)
+#define CBIT4B (0xF << 4)
+#define CBIT4A (0xF << 0)
+#define NOT_INDICATE 0x0
+#define BITS20_16 0x1
+#define BITS22_18 0x2
+#define BITS23_19 0x4
+#define BITS24_20 0x5
+#define BITS22_17 0x6
+
+/***********************************************/
+#define AIP_DOWNSAMPLE_CTRL 0x41C
+
+/***********************************************/
+#define AIP_PAR_CTRL 0x420
+
+/***********************************************/
+#define AIP_TXCTRL 0x424
+
+#define DSD_MUTE_DATA (0x1 << 7)
+#define AUD_PACKET_DROP (0x1 << 6)
+#define AUD_MUTE_FIFO_EN (0x1 << 5)
+#define AUD_MUTE_DIS (0x0 << 5)
+#define LAYOUT0 (0x0 << 4)
+#define LAYOUT1 (0x1 << 4)
+#define RST4AUDIO_ACR (0x1 << 2)
+#define RST4AUDIO_FIFO (0x1 << 1)
+#define RST4AUDIO (0x1 << 0)
+
+/***********************************************/
+#define AIP_TPI_CTRL 0x428
+
+#define TPI_AUD_SF_OVRD_VALUE (0x1 << 15)
+#define TPI_AUD_SF_OVRD_STREAM (0x0 << 15)
+#define TPI_AUD_SF (0x3F << 8)
+#define SF2205 0x4
+#define SF441 0x0
+#define SF882 0x8
+#define SF1764 0xC
+#define SF3528 0xD
+#define SF7056 0x2D
+#define SF14112 0x1D
+#define SF24 0x6
+#define SF48 0x2
+#define SF96 0xA
+#define SF192 0xE
+#define SF384 0x5
+#define SF768 0x9
+#define SF1536 0x15
+#define SF32 0x3
+#define SF64 0xB
+#define SF128 0x2B
+#define SF256 0x1B
+#define SF512 0x3B
+#define SF1024 0x35
+#define TPI_SPDIF_SAMPLE_SIZE (0x3 << 6)
+#define REFER_HEADER 0x0
+#define SAMPLE_SIZE_BIT16 0x1
+#define SAMPLE_SIZE_BIT20 0x2
+#define SAMPLE_SIZE_BIT24 0x3
+#define TPI_AUD_MUTE (0x1 << 4)
+#define TPI_AUD_UNMUTE (0x0 << 4)
+#define TPI_AUDIO_LOOKUP_EN (0x1 << 2)
+#define TPI_AUDIO_LOOKUP_DIS (0x0 << 2)
+#define TPI_AUD_HNDL (0x3 << 0)
+#define BLOCK_AUDIO 0x0
+#define DOWNSAMPLE 0x2
+#define PASSAUDIO 0x3
+
+/***********************************************/
+#define AIP_INT_CTRL 0x42C
+#define BURST_PREAMBLE_RST (0x01 << 15)
+
+#define DSD_VALID_INT_MSK (0x1 << 24)
+#define P_ERR_INT_MSK (0x1 << 23)
+#define PREAMBLE_ERR_INT_MSK (0x1 << 22)
+#define HW_CTS_CHANGED_INT_MSK (0x1 << 21)
+#define PKT_OVRWRT_INT_MSK (0x1 << 20)
+#define DROP_SMPL_ERR_INT_MSK (0x1 << 19)
+#define BIPHASE_ERR_INT_MSK (0x1 << 18)
+#define UNDERRUN_INT_MSK (0x1 << 17)
+#define OVERRUN_INT_MSK (0x1 << 16)
+#define DSD_VALID_INT_CLR (0x1 << 8)
+#define P_ERR_INT_CLR (0x1 << 7)
+#define PREAMBLE_ERR_INT_CLR (0x1 << 6)
+#define HW_CTS_CHANGED_INT_CLR (0x1 << 5)
+#define PKT_OVRWRT_INT_CLR (0x1 << 4)
+#define DROP_SMPL_ERR_INT_CLR (0x1 << 3)
+#define BIPHASE_ERR_INT_CLR (0x1 << 2)
+#define UNDERRUN_INT_CLR (0x1 << 1)
+#define OVERRUN_INT_CLR (0x1 << 0)
+#define DSD_VALID_INT_UNMSK (0x0 << 24)
+#define P_ERR_INT_UNMSK (0x0 << 23)
+#define PREAMBLE_ERR_INT_UNMSK (0x0 << 22)
+#define HW_CTS_CHANGED_INT_UNMSK (0x0 << 21)
+#define PKT_OVRWRT_INT_UNMSK (0x0 << 20)
+#define DROP_SMPL_ERR_INT_UNMSK (0x0 << 19)
+#define BIPHASE_ERR_INT_UNMSK (0x0 << 18)
+#define UNDERRUN_INT_UNMSK (0x0 << 17)
+#define OVERRUN_INT_UNMSK (0x0 << 16)
+#define DSD_VALID_INT_UNCLR (0x0 << 8)
+#define P_ERR_INT_UNCLR (0x0 << 7)
+#define PREAMBLE_ERR_INT_UNCLR (0x0 << 6)
+#define HW_CTS_CHANGED_INT_UNCLR (0x0 << 5)
+#define PKT_OVRWRT_INT_UNCLR (0x0 << 4)
+#define DROP_SMPL_ERR_INT_UNCLR (0x0 << 3)
+#define BIPHASE_ERR_INT_UNCLR (0x0 << 2)
+#define UNDERRUN_INT_UNCLR (0x0 << 1)
+#define OVERRUN_INT_UNCLR (0x0 << 0)
+
+/***********************************************/
+#define AIP_STA00 0x430
+
+#define AUD_NO_AUDIO (0x1 << 29)
+#define RO_2UI_LOCK (0x1 << 28)
+#define FS_OVERRIDE_READ (0x1 << 27)
+#define RO_1UI_LOCK (0x1 << 26)
+#define AUD_ID (0x3F << 20)
+#define N_VAL_SW (0xFFFFF << 0)
+
+/***********************************************/
+#define AIP_STA01 0x434
+
+#define AUDIO_SPDIF_FS (0x3F << 24)
+#define AUDIO_LENGTH (0xF << 20)
+#define CTS_VAL_HW (0xFFFFF << 0)
+
+/***********************************************/
+#define AIP_STA02 0x438
+
+#define FIFO_DIFF (0x3F << 24)
+#define CBIT_L (0xFF << 16)
+#define MAX_2UI_READ (0xFF << 8)
+#define MAX_1UI_READ (0xFF << 0)
+
+/***********************************************/
+#define AIP_STA03 0x43C
+
+#define SRC_EN (0x1 << 20)
+#define SRC_CTRL (0x1 << 19)
+#define LAYOUT (0x1 << 18)
+#define AUD_MUTE_EN (0x1 << 17)
+#define HDMI_MUTE (0x1 << 16)
+#define DSD_VALID_INT_STA (0x1 << 8)
+#define P_ERR_INT_STA (0x1 << 7)
+#define PREAMBLE_ERR_INT_STA (0x1 << 6)
+#define HW_CTS_CHANGED_INT_STA (0x1 << 5)
+#define PKT_OVRWRT_INT_STA (0x1 << 4)
+#define DROP_SMPL_ERR_INT_STA (0x1 << 3)
+#define BIPHASE_ERR_INT_STA (0x1 << 2)
+#define UNDERRUN_INT_STA (0x1 << 1)
+#define OVERRUN_INT_STA (0x1 << 0)
+/*********************HDMI audio register end**************************/
+
+/*********************HDMI video register start**************************/
+
+#define VID_CSC_COEF_0 0x8D0
+
+#define MULTI_CSC_MULTCOEFFR1C1 (0xffff << 16)
+#define MULTI_CSC_CONFIG_DITHER_ENABLE (0x1 << 10)
+#define MULTI_CSC_CONFIG_IN_RGB (0x1 << 9)
+#define MULTI_CSC_CONFIG_IN_PC (0x1 << 8)
+#define MULTI_CSC_CONFIG_IN_SD (0x3 << 6)
+#define BT_709_IN (0x0 << 6)
+#define BT_601_IN (0x1 << 6)
+#define BT_NON2020_IN (0x2 << 6)
+#define BT_2020_IN (0x3 << 6)
+#define MULTI_CSC_CONFIG_OUT_RGB (0x1 << 5)
+#define MULTI_CSC_CONFIG_OUT_PC (0x1 << 4)
+#define MULTI_CSC_CONFIG_OUT_SD (0x3 << 2)
+#define BT_709_OUT (0x0 << 2)
+#define BT_601_OUT (0x1 << 2)
+#define BT_NON2020_OUT (0x2 << 2)
+#define BT_2020_OUT (0x3 << 2)
+#define MULTI_CSC_CONFIG_ENABLE (0x3 << 0)
+#define CONVERSION_DISABLED (0x0 << 0)
+#define CONVERSION_ENABLED_BY_IN_OUT (0x1 << 0)
+#define CONVERSION_ENABLED_BY_PROGRAM (0x2 << 0)
+#define CONVERSION_RESERVED (0x3 << 0)
+
+/***********************************************/
+#define VID_DOWNSAMPLE_CONFIG 0x8F0
+
+#define RANGE_CLIP_CONFIG (0x1 << 16)
+#define DITHER_CONFIG_SPATIAL_DUAL (0x1 << 12)
+#define DITHER_CONFIG_SPATIAL_ENABLE (0x1 << 11)
+#define DITHER_CONFIG_RND_ENABLE (0x1 << 10)
+#define DITHER_CONFIG_MODE (0x3 << 8)
+#define D_12_TO_10 (0x0 << 8)
+#define D_12_TO_8 (0x1 << 8)
+#define D_10_TO_8 (0x2 << 8)
+#define D_NO_CHANGE (0x3 << 8)
+#define C422_C420_CONFIG_OUT_CB_CR_POLARITY (0x1 << 7)
+#define C422_C420_CONFIG_OUT_CB_OR_CR (0x1 << 6)
+#define C422_C420_CONFIG_BYPASS (0x1 << 5)
+#define C422_C420_CONFIG_ENABLE (0x1 << 4)
+#define C444_C422_CONFIG_DISABLE_FILTER (0x1 << 2)
+#define C444_C422_CONFIG_ENABLE (0x1 << 0)
+/***********************************************/
+#define VID_OUT_FORMAT 0x8FC
+
+#define OUTPUT_FORMAT_DEMUX_CB_OR_CR (0x1 << 11)
+#define OUTPUT_FORMAT_DEMUX_420_ENABLE (0x1 << 10)
+#define OUTPUT_FORMAT_PIXEL_RATE (0x3 << 8)
+#define OUTPUT_FORMAT_CBCR_ORDER (0x1 << 7)
+#define OUTPUT_FORMAT_YC_MUX_POLARITY (0x1 << 6)
+#define OUTPUT_FORMAT_YC_MUX_ENABLE (0x1 << 5)
+#define OUTPUT_FORMAT_DDR_MODE (0x7 << 2)
+#define OUTPUT_FORMAT_DDR_POLARITY (0x1 << 1)
+#define OUTPUT_FORMAT_DDR_ENABLE (0x1 << 0)
+
+#define HDMITX_CONFIG 0x900
+/* HDMITX_CONFIG BIT(28) BIT(29) cannot be read, if read, always 0.
+ * if use mtk_hdmi_mask(), it will read the register fisrt,
+ * then write register. if want to set BIT(28) BIT(29) 1,
+ * every time write HDMITX_CONFIG shall set BIT(28) BIT(29) to 1.
+ */
+#define HDMITX_SW_RSTB BIT(31)
+#define HDMITX_SW_HPD BIT(29)
+#define HDMI_YUV420_MODE BIT(10)
+
+#define HDMITX_SW_RSTB_SHIFT (31)
+#define HDMITX_SW_HPD_SHIFT (29)
+#define HDMI_YUV420_MODE_SHIFT (10)
+
+#define HDMITX_MUX (0x1 << 0)
+
+#define HDMI_BYPS_CFG 0x1e0
+
+#define rg_full_byps_mode (0x1 << 2)
+/*********************HDMI video register end**************************/
+
+/*********************HDMI HDCP register start**************************/
+
+#define HDCP_TOP_CTRL 0xC00
+
+#define OTP2XAOVR_EN (0x1 << 13)
+#define OTP2XVOVR_EN (0x1 << 12)
+#define OTPAMUTEOVR_SET (0x1 << 10)
+#define OTPADROPOVR_SET (0x1 << 9)
+#define OTPVMUTEOVR_SET (0x1 << 8)
+#define OTP14AOVR_EN (0x1 << 5)
+#define OTP14VOVR_EN (0x1 << 4)
+#define HDCP_DISABLE (0x1 << 0)
+#define OTP2XAOVR_DIS (0x0 << 13)
+#define OTP2XVOVR_DIS (0x0 << 12)
+#define OTPAMUTEOVR_UNSET (0x0 << 10)
+#define OTPADROPOVR_UNSET (0x0 << 9)
+#define OTPVMUTEOVR_UNSET (0x0 << 8)
+#define OTP14AOVR_DIS (0x0 << 5)
+#define OTP14VOVR_DIS (0x0 << 4)
+#define HDCP_ENABLE (0x0 << 0)
+
+/***********************************************/
+#define HPD_PORD_CTRL 0xC04
+
+#define PORD_T2 (0xFF << 24)
+#define PORD_T1 (0xFF << 16)
+#define HPD_T2 (0xFF << 8)
+#define HPD_T1 (0xFF << 0)
+
+/***********************************************/
+#define HPD_DDC_CTRL 0xC08
+
+#define DDC_DELAY_CNT (0xFFFF << 16)
+#define DDC_DELAY_CNT_SHIFT (16)
+
+#define HW_DDC_MASTER (0x1 << 14)
+#define DDC_DEBUG (0x1 << 13)
+#define MAN_DDC_SYNC (0x1 << 12)
+#define DSDA_SYNC (0x1 << 11)
+#define DSCL_SYNC (0x1 << 10)
+#define TPI_DDC_REQ_LEVEL (0x3 << 8)
+#define DDC_GPU_REQUEST (0x1 << 7)
+#define TPI_DDC_BURST_MODE (0x1 << 6)
+#define DDC_SHORT_RI_RD (0x1 << 5)
+#define DDC_FLT_EN_SYNC (0x1 << 4)
+#define PORD_DEBOUNCE_EN (0x1 << 3)
+#define HPD_DEBOUNCE_EN (0x1 << 2)
+#define HPDIN_STA (0x1 << 1)
+#define HPDIN_OVER_EN (0x1 << 0)
+
+/***********************************************/
+#define HDCP_RI_CTRL 0xC0C
+
+#define RI_BCAP_EN (0x1 << 29)
+#define RI_EN (0x1 << 28)
+#define RI_128_COMP (0x7F << 20)
+#define KSV_FORWARD (0x1 << 19)
+#define INTERM_RI_CHECK_EN (0x1 << 18)
+#define R0_ABSOLUTE  (0x1 << 17)
+#define DOUBLE_RI_CHECK (0x1 << 16)
+#define TPI_R0_CALC_TIME (0xF << 12)
+#define RI_CHECK_SHIP (0x1 << 11)
+#define LEGACY_TPI_RI_CHECK (0x7 << 8)
+#define RI_LN_NUM (0xFF << 0)
+
+/***********************************************/
+#define DDC_CTRL 0xC10
+
+#define DDC_CMD (0xF << 28)
+#define DDC_CMD_SHIFT (28)
+
+#define ABORT_TRANSACTION 0xF
+#define CLEAR_FIFO 0x9
+#define CLOCK_SCL 0xA
+#define CURR_READ_NO_ACK 0x0
+#define CURR_READ_ACK 0x1
+#define SEQ_READ_NO_ACK 0x2
+#define SEQ_READ_ACK 0x3
+#define ENH_READ_NO_ACK 0x4
+#define ENH_READ_ACK 0x5
+#define SEQ_WRITE_IGN_ACK 0x6
+#define SEQ_WRITE_REQ_ACK 0x7
+#define DDC_DIN_CNT (0x3FF << 16)
+#define DDC_DIN_CNT_SHIFT (16)
+
+#define DDC_OFFSET (0xFF << 8)
+#define DDC_OFFSET_SHIFT (8)
+
+//#define DDC_ADDR (0x7F << 1)
+
+/***********************************************/
+#define HDCP_TPI_CTRL 0xC14
+
+#define EDID_MODE_EN (0x1 << 8)
+#define CANCEL_PROT_EN (0x1 << 7)
+#define TPI_AUTH_RETRY_CNT (0x7 << 4)
+#define COPP_PROTLEVEL (0x1 << 3)
+#define TPI_REAUTH_CTL (0x1 << 2)
+#define TPI_HDCP_PREP_EN (0x1 << 1)
+#define SW_TPI_EN (0x1 << 0)
+
+/***********************************************/
+#define SCDC_CTRL 0xC18
+
+#define DDC_SEGMENT (0xFF << 8)
+#define DDC_SEGMENT_SHIFT (8)
+
+#define SCDC_AUTO_REPLY_STOP (0x1 << 3)
+#define SCDC_AUTO_POLL (0x1 << 2)
+#define SCDC_AUTO_REPLY (0x1 << 1)
+#define SCDC_ACCESS (0x1 << 0)
+
+/***********************************************/
+#define TXDS_BSTATUS 0xC1C
+
+#define DS_BSTATUS (0x7 << 13)
+#define DS_HDMI_MODE (0x1 << 12)
+#define DS_CASC_EXCEED (0x1 << 11)
+#define DS_DEPTH (0x7 << 8)
+#define DS_DEV_EXCEED (0x1 << 7)
+#define DS_DEV_CNT (0x7F << 0)
+
+/***********************************************/
+#define HDCP2X_CTRL_0 0xC20
+
+#define HDCP2X_CPVER (0xF << 20)
+#define HDCP2X_CUPD_START (0x1 << 16)
+#define HDCP2X_REAUTH_MSK (0xF << 12)
+#define HDCP2X_REAUTH_MSK_SHIFT (12)
+
+#define HDCP2X_HPD_SW (0x1 << 11)
+#define HDCP2X_HPD_OVR (0x1 << 10)
+#define HDCP2X_CTL3MSK (0x1 << 9)
+#define HDCP2X_REAUTH_SW (0x1 << 8)
+#define HDCP2X_ENCRYPT_EN (0x1 << 7)
+#define HDCP2X_POLINT_SEL (0x1 << 6)
+#define HDCP2X_POLINT_OVR (0x1 << 5)
+#define HDCP2X_PRECOMPUTE (0x1 << 4)
+#define HDCP2X_HDMIMODE (0x1 << 3)
+#define HDCP2X_REPEATER (0x1 << 2)
+#define HDCP2X_HDCPTX (0x1 << 1)
+#define HDCP2X_EN (0x1 << 0)
+
+#define HDCP2X_ENCRYPT_EN_SHIFT (7)
+
+/***********************************************/
+#define HDCP2X_CTRL_1 0xC24
+
+#define HDCP2X_CUPD_SIZE (0xFFFF << 0)
+
+/***********************************************/
+#define HDCP2X_CTRL_2 0xC28
+
+#define HDCP2X_RINGOSC_BIST_START (0x1 << 28)
+#define HDCP2X_MSG_SZ_CLR_OPTION (0x1 << 26)
+#define HDCP2X_RPT_READY_CLR_OPTION (0x1 << 25)
+#define HDCP2X_REAUTH_REQ_CLR_OPTION (0x1 << 24)
+#define HDCP2X_RPT_SMNG_IN (0xFF << 16)
+#define HDCP2X_RPT_SMNG_K (0xFF << 8)
+#define HDCP2X_RPT_SMNG_XFER_START (0x1 << 4)
+#define HDCP2X_RPT_SMNG_WR_START (0x1 << 3)
+#define HDCP2X_RPT_SMNG_WR (0x1 << 2)
+#define HDCP2X_RPT_RCVID_RD_START (0x1 << 1)
+#define HDCP2X_RPT_RCVID_RD (0x1 << 0)
+
+#define HDCP2X_RPT_SMNG_K_SHIFT (8)
+#define HDCP2X_RPT_SMNG_IN_SHIFT (16)
+
+/***********************************************/
+#define HDCP2X_CTRL_STM 0xC2C
+
+#define HDCP2X_STM_CTR (0xFFFFFFFF << 0)
+
+/***********************************************/
+#define HDCP2X_TEST_TP0 0xC30
+
+#define HDCP2X_TP3 (0xFF << 24)
+#define HDCP2X_TP2 (0xFF << 16)
+#define HDCP2X_TP1 (0xFF << 8)
+#define HDCP2X_TP0 (0xFF << 0)
+#define HDCP2X_TP3_SHIFT (24)
+#define HDCP2X_TP2_SHIFT (16)
+#define HDCP2X_TP1_SHIFT (8)
+#define HDCP2X_TP0_SHIFT (0)
+/***********************************************/
+#define HDCP2X_TEST_TP1 0xC34
+
+#define HDCP2X_TP7 (0xFF << 24)
+#define HDCP2X_TP6 (0xFF << 16)
+#define HDCP2X_TP5 (0xFF << 8)
+#define HDCP2X_TP4 (0xFF << 0)
+
+/***********************************************/
+#define HDCP2X_TEST_TP2 0xC38
+
+#define HDCP2X_TP11 (0xFF << 24)
+#define HDCP2X_TP10 (0xFF << 16)
+#define HDCP2X_TP9 (0xFF << 8)
+#define HDCP2X_TP8 (0xFF << 0)
+
+/***********************************************/
+#define HDCP2X_TEST_TP3 0xC3C
+
+#define HDCP2X_TP15 (0xFF << 24)
+#define HDCP2X_TP14 (0xFF << 16)
+#define HDCP2X_TP13 (0xFF << 8)
+#define HDCP2X_TP12 (0xFF << 0)
+
+/***********************************************/
+#define HDCP2X_GP_IN 0xC40
+
+#define HDCP2X_GP_IN3 (0xFF << 24)
+#define HDCP2X_GP_IN2 (0xFF << 16)
+#define HDCP2X_GP_IN1 (0xFF << 8)
+#define HDCP2X_GP_IN0 (0xFF << 0)
+#define HDCP2X_GP_IN3_SHIFT (24)
+#define HDCP2X_GP_IN2_SHIFT (16)
+#define HDCP2X_GP_IN1_SHIFT (8)
+#define HDCP2X_GP_IN0_SHIFT (0)
+/***********************************************/
+#define HDCP2X_DEBUG_CTRL 0xC44
+
+#define HDCP2X_DB_CTRL3 (0xFF << 24)
+#define HDCP2X_DB_CTRL2 (0xFF << 16)
+#define HDCP2X_DB_CTRL1 (0xFF << 8)
+#define HDCP2X_DB_CTRL0 (0xFF << 0)
+
+/***********************************************/
+#define HDCP2X_SPI_SI_ADDR 0xC48
+
+#define HDCP2X_SPI_SI_S_ADDR (0xFFFF << 16)
+#define HDCP2X_SPI_SI_E_ADDR (0xFFFF << 0)
+
+/***********************************************/
+#define HDCP2X_SPI_ADDR_CTRL 0xC4C
+
+#define HDCP2X_SPI_SI_S_ADDR (0xFFFF << 16)
+#define HDCP2X_SPI_SI_E_ADDR (0xFFFF << 0)
+
+/***********************************************/
+#define HDCP2X_RPT_SEQ_NUM 0xC50
+
+#define MHL3_P0_STM_ID (0x7 << 24)
+#define HDCP2X_RPT_SEQ_NUM_M (0xFFFFFF << 0)
+
+/***********************************************/
+#define HDCP2X_POL_CTRL 0xC54
+
+#define HDCP2X_DIS_POLL_EN (0x1 << 16)
+#define HDCP2X_POL_VAL1 (0xFF << 8)
+#define HDCP2X_POL_VAL0 (0xFF << 0)
+
+/***********************************************/
+#define WR_PULSE 0xC58
+
+#define HDCP2X_SPI_ADDR_RESET (0x1 << 3)
+#define DDC_BUS_LOW (0x1 << 2)
+#define DDC_NO_ACK (0x1 << 1)
+#define DDCM_ABORT (0x1 << 0)
+
+/***********************************************/
+#define HPD_DDC_STATUS 0xC60
+
+#define DDC_DATA_OUT (0xFF << 16)
+#define DDC_DATA_OUT_SHIFT (16)
+
+#define DDC_FIFO_FULL (0x1 << 15)
+#define DDC_FIFO_EMPTY (0x1 << 14)
+#define DDC_I2C_IN_PROG (0x1 << 13)
+#define DDC_DATA_OUT_CNT (0x1F << 8)
+#define RX_HDCP2_CAP_EN (0x1 << 7)
+#define HDCP2_AUTH_RXCAP_FAIL (0x1 << 6)
+#define PORD_PIN_STA (0x1 << 5)
+#define HPD_PIN_STA (0x1 << 4)
+#define PORD_STATE (0x3 << 2)
+#define PORD_STATE_SHIFT (2)
+#define PORD_STATE_CONNECTED (2)
+#define PORD_STATE_DISCONNECTED (0)
+#define HPD_STATE (0x3 << 0)
+#define HPD_STATE_SHIFT (0)
+#define HPD_STATE_CONNECTED (2)
+#define HPD_STATE_DISCONNECTED (0)
+
+/***********************************************/
+#define SCDC_STATUS 0xC64
+
+#define SCDC_STATE (0xF << 28)
+#define SCDC_RREQ_STATE (0xF << 24)
+#define SCDC_UP_FLAG1_STATUS (0xFF << 16)
+#define SCDC_UP_FLAG0_STATUS (0xFF << 8)
+#define SCDC_UP_FLAG_DONE (0x1 << 6)
+#define SCDC_SLAVE_RD_REQ_P (0x1 << 5)
+#define SCDC_DDC_CONFLICT (0x1 << 4)
+#define SCDC_DDC_DONE (0x1 << 3)
+#define SCDC_IN_PROG (0x1 << 2)
+#define SCDC_RREQ_IN_PROG (0x1 << 1)
+#define SCDC_ACTIVE (0x1 << 0)
+
+/***********************************************/
+#define HDCP2X_DDCM_STATUS 0xC68
+
+#define RI_ON (0x1 << 31)
+#define HDCP_I_CNT (0x7F << 24)
+#define HDCP_RI_RDY (0x1 << 23)
+#define KSV_FIFO_FIRST (0x1 << 22)
+#define KSV_FIFO_LAST (0x1 << 21)
+#define KSV_FIFO_BYTES (0x1F << 16)
+#define HDCP2X_DDCM_CTL_CS (0xF << 12)
+#define DDC_I2C_BUS_LOW	(0x1 << 11)
+#define DDC_I2C_NO_ACK (0x1 << 10)
+#define DDC_FIFO_WRITE_IN_USE (0x1 << 9)
+#define DDC_FIFO_READ_IN_USE (0x1 << 8)
+#define HDCP1_DDC_TPI_GRANT (0x1 << 6)
+#define HDCP2X_DDCM_AUTH_POLL_ERR (0x1 << 5)
+#define HDCP2X_DDCM_RCV_FAIL (0x1 << 4)
+#define HDCP2X_DDCM_SND_FAIL (0x1 << 3)
+#define HDCP2X_DDCM_AUTH_ERR (0x1 << 2)
+#define HDCP2_DDC_TPI_GRANT (0x1 << 1)
+#define HDCP2X_DIS_POLL_GNT (0x1 << 0)
+
+/***********************************************/
+#define TPI_STATUS_0 0xC6C
+
+#define TPI_AUTH_STATE (0x3 << 30)
+#define TPI_COPP_LINK_STATUS (0x3 << 28)
+#define TPI_COPP_GPROT (0x1 << 27)
+#define TPI_COPP_LPROT (0x1 << 26)
+#define TPI_COPP_HDCP_REP (0x1 << 25)
+#define TPI_COPP_PROTYPE (0x1 << 24)
+#define TPI_RI_PRIME1 (0xFF << 16)
+#define TPI_RI_PRIME0 (0xFF << 8)
+#define DS_BKSV (0xFF << 0)
+
+/***********************************************/
+#define TPI_STATUS_1 0xC70
+
+#define TPI_READ_V_PRIME_ERR (0x1 << 26)
+#define TPI_READ_RI_PRIME_ERR (0x1 << 25)
+#define TPI_READ_RI_2ND_ERR (0x1 << 24)
+#define TPI_READ_R0_PRIME_ERR (0x1 << 23)
+#define TPI_READ_KSV_FIFO_RDY_ERR (0x1 << 22)
+#define TPI_READ_BSTATUS_ERR (0x1 << 21)
+#define TPI_READ_KSV_LIST_ERR (0x1 << 20)
+#define TPI_WRITE_AKSV_ERR (0x1 << 19)
+#define TPI_WRITE_AN_ERR (0x1 << 18)
+#define TPI_READ_RX_REPEATER_ERR (0x1 << 17)
+#define TPI_READ_BKSV_ERR (0x1 << 16)
+#define TPI_READ_V_PRIME_DONE (0x1 << 10)
+#define TPI_READ_RI_PRIME_DONE (0x1 << 9)
+#define TPI_READ_RI_2ND_DONE (0x1 << 8)
+#define TPI_READ_R0_PRIME_DONE (0x1 << 7)
+#define TPI_READ_KSV_FIFO_RDY_DONE (0x1 << 6)
+#define TPI_READ_BSTATUS_DONE (0x1 << 5)
+#define TPI_READ_KSV_LIST_DONE (0x1 << 4)
+#define TPI_WRITE_AKSV_DONE (0x1 << 3)
+#define TPI_WRITE_AN_DONE (0x1 << 2)
+#define TPI_READ_RX_REPEATER_DONE (0x1 << 1)
+#define TPI_READ_BKSV_DONE (0x1 << 0)
+
+/***********************************************/
+#define TPI_STATUS_FSM 0xC74
+
+#define DDC_HDCP_ACC_NMB (0x3FF << 20)
+#define TPI_DDCM_CTL_CS (0xF << 16)
+#define TPI_DS_AUTH_CS (0xF << 12)
+#define TPI_LINK_ENC_CS (0x7 << 9)
+#define TPI_RX_AUTH_CS (0x1F << 4)
+#define TPI_HW_CS (0xF << 0)
+
+/***********************************************/
+#define KSV_RI_STATUS 0xC78
+
+#define RI_RX (0xFFFF << 16)
+#define RI_TX (0xFFFF << 0)
+
+/***********************************************/
+#define HDCP2X_DEBUG_STATUS_0 0xC7C
+
+#define HDCP2X_DEBUG_STAT3 (0xFF << 24)
+#define HDCP2X_DEBUG_STAT2 (0xFF << 16)
+#define HDCP2X_DEBUG_STAT1 (0xFF << 8)
+#define HDCP2X_DEBUG_STAT0 (0xFF << 0)
+
+/***********************************************/
+#define HDCP2X_DEBUG_STATUS_1 0xC80
+
+#define HDCP2X_DEBUG_STAT7 (0xFF << 24)
+#define HDCP2X_DEBUG_STAT6 (0xFF << 16)
+#define HDCP2X_DEBUG_STAT5 (0xFF << 8)
+#define HDCP2X_DEBUG_STAT4 (0xFF << 0)
+
+/***********************************************/
+#define HDCP2X_DEBUG_STATUS_2 0xC84
+
+#define HDCP2X_DEBUG_STAT11 (0xFF << 24)
+#define HDCP2X_DEBUG_STAT10 (0xFF << 16)
+#define HDCP2X_DEBUG_STAT9 (0xFF << 8)
+#define HDCP2X_DEBUG_STAT8 (0xFF << 0)
+
+/***********************************************/
+#define HDCP2X_DEBUG_STATUS_3 0xC88
+
+#define HDCP2X_DEBUG_STAT15 (0xFF << 24)
+#define HDCP2X_DEBUG_STAT14 (0xFF << 16)
+#define HDCP2X_DEBUG_STAT13 (0xFF << 8)
+#define HDCP2X_DEBUG_STAT12 (0xFF << 0)
+
+/***********************************************/
+#define HDCP2X_STATUS_0 0xC8C
+
+#define HDCP2X_AUTH_STAT (0xFF << 24)
+#define HDCP2X_STATE (0xFF << 16)
+#define HDCP2X_RPT_REPEATER (0x1 << 8)
+#define HDCP2X_PRG_SEL (0x1 << 7)
+#define HDCP2X_CUPD_DONE (0x1 << 6)
+#define HDCP2X_RPT_MX_DEVS_EXC (0x1 << 5)
+#define HDCP2X_RPT_MAX_CASC_EXC (0x1 << 4)
+#define HDCP2X_RPT_HDCP20RPT_DSTRM (0x1 << 3)
+#define HDCP2X_RPT_HDCP1DEV_DSTRM (0x1 << 2)
+#define HDCP2X_RPT_RCVID_CHANGED (0x1 << 1)
+#define HDCP2X_RPT_SMNG_XFER_DONE (0x1 << 0)
+
+/***********************************************/
+#define HDCP2X_STATUS_1 0xC90
+
+#define HDCP2X_RINGOSS_BIST_FAIL (0x1 << 25)
+#define HDCP2X_RINGOSC_BIST_DONE (0x1 << 24)
+#define HDCP2X_RPT_RCVID_OUT (0xFF << 16)
+#define HDCP2X_RPT_DEVCNT (0xFF << 8)
+#define HDCP2X_RPT_DEPTH (0xFF << 0)
+
+#define HDCP2X_RPT_DEVCNT_SHIFT (8)
+#define HDCP2X_RPT_RCVID_OUT_SHIFT (16)
+
+/***********************************************/
+#define HDCP2X_RCVR_ID 0xC94
+
+#define HDCP2X_RCVR_ID_L (0xFFFFFFFF << 0)
+
+/***********************************************/
+#define HDCP2X_RPT_SEQ 0xC98
+
+#define HDCP2X_RCVR_ID_H (0xFF << 24)
+#define HDCP2X_RPT_SEQ_NUM_V (0xFFFFFF << 0)
+
+/***********************************************/
+#define HDCP2X_GP_OUT 0xC9C
+
+#define HDCP2X_GP_OUT3 (0xFF << 24)
+#define HDCP2X_GP_OUT2 (0xFF << 16)
+#define HDCP2X_GP_OUT1 (0xFF << 8)
+#define HDCP2X_GP_OUT0 (0xFF << 0)
+
+/***********************************************/
+#define PROM_CTRL 0xCA0
+
+#define PROM_ADDR (0xFFFF << 16)
+#define PROM_ADDR_SHIFT (16)
+
+#define PROM_WDATA (0xFF << 8)
+#define PROM_WDATA_SHIFT (8)
+
+#define PROM_CS (0x1 << 1)
+#define PROM_WR (0x1 << 0)
+
+/***********************************************/
+#define PRAM_CTRL 0xCA4
+
+#define PRAM_ADDR (0xFFFF << 16)
+#define PRAM_ADDR_SHIFT (16)
+
+#define PRAM_WDATA (0xFF << 8)
+#define PRAM_WDATA_SHIFT (8)
+
+#define PRAM_CTRL_SEL (0x1 << 2)
+#define PRAM_CS (0x1 << 1)
+#define PRAM_WR (0x1 << 0)
+
+/***********************************************/
+#define PROM_DATA 0xCA8
+
+#define PROM_RDATA (0xFF << 8)
+#define PRAM_RDATA (0xFF << 0)
+
+/***********************************************/
+#define SI2C_CTRL 0xCAC
+
+#define SI2C_ADDR (0xFFFF << 16)
+#define SI2C_ADDR_SHIFT (16)
+#define SI2C_ADDR_READ (0xF4)
+
+#define SI2C_WDATA (0xFF << 8)
+#define SI2C_WDATA_SHIFT (8)
+
+#define RX_CAP_RD_TRIG (0x1 << 5)
+#define KSV_RD (0x1 << 4)
+#define SI2C_STOP (0x1 << 3)
+#define SI2C_CONFIRM_READ (0x1 << 2)
+#define SI2C_RD (0x1 << 1)
+#define SI2C_WR (0x1 << 0)
+
+
+#define HDCP1X_CTRL 0xCD0
+
+#define HDCP1X_ENC_EN (0x1 << 6)
+#define HDCP1X_ENC_EN_SHIFT (6)
+#define ANA_TOP (0x1 << 4)
+#define ANA_TOP_SHIFT (4)
+
+#define HDCP1x_STATUS 0xCF4
+
+#define HDCP_ENCRYPTING_ON (0x1 << 26)
+
+#define HDCP2X_STATUS_0 0xC8C
+
+#define HDCP2X_STATE (0xFF << 16)
+#define HDCP2X_ENCRYPTING_ON (0x1 << 10)
+
+/* hdcp cfg */
+#define SLOW_CLK_DIV_CNT (0xFF << 16)
+#define RISC_CLK_DDC_RST (0x1 << 15)
+#define HDCP_1P4_TCLK_EN (0x1 << 9)
+#define HDCP_1P4_TCLK_DIS (0x0 << 9)
+#define HDCP_TCLK_EN (0x1 << 8)
+#define HDCP_TCLK_DIS (0x0 << 8)
+#define SOFT_VIDEO_RST (0x1 << 5)
+#define SOFT_VIDEO_NOR (0x0 << 5)
+#define SOFT_HDCP_1P4_RST (0x1 << 2)
+#define SOFT_HDCP_1P4_NOR (0x0 << 2)
+#define SOFT_HDCP_CORE_RST (0x1 << 1)
+#define SOFT_HDCP_CORE_NOR (0x0 << 1)
+#define SOFT_HDCP_RST (0x1 << 0)
+#define SOFT_HDCP_NOR (0x0 << 0)
+
+/********************HDMI HDCP register end***********************/
+
+
+#define MMSYS_VDOUT_SW_RST		0x888
+
+#define MMSYS_VDOUT_HDMI_RST		(0x1 << 8)
+#define MMSYS_VDOUT_RGB2HDMI_RST		(0x1 << 9)
+
+#define HDR_DEBUG_DISABLE_METADATA        (1<<0)
+#define HDR_DEBUG_DISABLE_HDR             (1<<1)
+#define HDR_DEBUG_DISABLE_BT2020          (1<<2)
+#define HDR_DEBUG_DISABLE_DOLBY_HDR       (1<<3)
+#define HDR_DEBUG_DISABLE_PHI_HDR         (1<<4)
+
+
+/* vdout */
+#define RW_VDOUT_CLK 0x5c0
+	#define MAIN_CLK_OFF (0x1 << 0)
+	#define HDMI_CLK_OFF (0x1 << 4)
+	#define VDOUT_CLK_SELF_OPTION (1 << 16)
+	#define HD_2FS_148 (0x1 << 23)
+	#define VDOUT_CLK_SCL_HD (0x1 << 24)
+	#define VDOUT_CLK_SCL_PRGS (0x1 << 25)
+	#define VDOUT_CLK_SCL_1080P (0x1 << 26)
+	#define SCL_PRGS27M (0x1 << 27)
+	#define SCL_HCKSEL (0x1 << 28)
+	#define SCL_VCKSEL (0x1 << 29)
+	#define HD_HALF (0x1 << 30)
+
+#define VDTCLK_CFG3 0x5cc /* 0x15cc */
+	/* set this bit to 1 when use w2d write 480p output*/
+	#define VIDEOIN_NEW_SD_SEL (0x01 << 31)
+	/*is used to set video clock to 296MHz for mast clock*/
+	#define MAST_296M_EN (0x01 << 25)
+	#define DIG_296M_EN (0x01 << 24)
+	#define P2I_296M_EN	(0x01 << 22)
+	/*is used to set video clock to 296MHz for NR*/
+	#define NR_296M_EN (0x01 << 21)
+	/*is used to set video clock to 296MHz for HDMI*/
+	#define RGB2HDMI_296M_EN (0x01 << 19)
+	#define VDO4_296M_EN (0x01 << 17)
+	#define FMT_296M_EN (0x01 << 16)
+
+#define VDTCLK_CONFIG4 0x5d0 /* 0x15d0*/
+	#define RGB2HDMI_594M_EN (0x01 << 7)
+	#define VDO3_594M_EN (0x01 << 10)
+	#define VDO3_296M_EN (0x01 << 11)
+	#define VDO3_150HZ_EN (0x01 << 12)
+	#define DISPFMT3_OFF (0x01 << 13)
+	#define FMT_594M_EN (0x01 << 16)
+	#define VDO4_594M_EN (0x01 << 17)
+
+#define HDMI_CONFIG_SUB 0x5d4
+	#define SELF_OPT_HDMI_SUB (0x1 << 2)
+	#define VDOUT_CLK_HDMI_HD_SUB (0x1 << 3)
+	#define VDOUT_CLK_HDMI_1080P_SUB (0x1 << 5)
+	#define VDOUT_CLK_HDMI_PRGS_SUB (0x1 << 6)
+	#define RGB2HDMI_296M_EN_SUB (0x1 << 7)
+	#define HDMI_PRGS27M_SUB (0x1 << 8)
+	#define HDMI_HDAUD_CLK_SUB (0x1 << 9)
+	#define HDMI_422_TO_420 (0x1 << 11)
+/***********************************************/
+
+#endif
diff --git a/drivers/gpu/drm/mediatek/mediatek_v2/mtk_log.h b/drivers/gpu/drm/mediatek/mediatek_v2/mtk_log.h
new file mode 100644
index 0000000000000000000000000000000000000000..1934d0ef01deb6bcc43c2bff0171fbc306bb4b74
--- /dev/null
+++ b/drivers/gpu/drm/mediatek/mediatek_v2/mtk_log.h
@@ -0,0 +1,150 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2019 MediaTek Inc.
+ */
+
+#ifndef __MTKFB_LOG_H
+#define __MTKFB_LOG_H
+
+#include <linux/kernel.h>
+
+extern unsigned long long mutex_time_start;
+extern unsigned long long mutex_time_end;
+extern long long mutex_time_period;
+extern const char *mutex_locker;
+
+enum DPREC_LOGGER_PR_TYPE {
+	DPREC_LOGGER_ERROR,
+	DPREC_LOGGER_FENCE,
+	DPREC_LOGGER_DEBUG,
+	DPREC_LOGGER_DUMP,
+	DPREC_LOGGER_STATUS,
+	DPREC_LOGGER_PR_NUM
+};
+
+int mtk_dprec_logger_pr(unsigned int type, char *fmt, ...);
+
+#define DDPINFO(fmt, arg...)                                                   \
+	do {                                                                   \
+		mtk_dprec_logger_pr(DPREC_LOGGER_DEBUG, fmt, ##arg);           \
+		if (g_mobile_log)                                              \
+			pr_info(pr_fmt(fmt), ##arg);     \
+	} while (0)
+
+#define DDPFUNC(fmt, arg...)		\
+	pr_info("[%s line:%d]"pr_fmt(fmt), __func__, __LINE__, ##arg)
+
+#define DDPDBG(fmt, arg...)                                                    \
+	do {                                                                   \
+		if (!g_detail_log)                                             \
+			break;                                                 \
+		mtk_dprec_logger_pr(DPREC_LOGGER_DEBUG, fmt, ##arg);           \
+		if (g_mobile_log)                                              \
+			pr_info(pr_fmt(fmt), ##arg);     \
+	} while (0)
+
+#define DDPMSG(fmt, arg...)                                                    \
+	do {                                                                   \
+		mtk_dprec_logger_pr(DPREC_LOGGER_DEBUG, fmt, ##arg);           \
+		pr_info(pr_fmt(fmt), ##arg);             \
+	} while (0)
+
+#define DDPDUMP(fmt, arg...)                                                   \
+	do {                                                                   \
+		mtk_dprec_logger_pr(DPREC_LOGGER_DUMP, fmt, ##arg);            \
+		if (g_mobile_log)                                              \
+			pr_info(pr_fmt(fmt), ##arg);     \
+	} while (0)
+
+#define DDPFENCE(fmt, arg...)                                                  \
+	do {                                                                   \
+		mtk_dprec_logger_pr(DPREC_LOGGER_FENCE, fmt, ##arg);           \
+		if (g_fence_log)                                               \
+			pr_info(pr_fmt(fmt), ##arg);     \
+	} while (0)
+
+#define DDPPR_ERR(fmt, arg...)                                                 \
+	do {                                                                   \
+		mtk_dprec_logger_pr(DPREC_LOGGER_ERROR, fmt, ##arg);           \
+		pr_err(pr_fmt(fmt), ##arg);              \
+	} while (0)
+
+#define DDPIRQ(fmt, arg...)                                                    \
+	do {                                                                   \
+		if (g_irq_log)                                                 \
+			mtk_dprec_logger_pr(DPREC_LOGGER_DEBUG, fmt, ##arg);   \
+	} while (0)
+
+#define DDP_MUTEX_LOCK(lock, name, line)                                       \
+	do {                                                                   \
+		DDPINFO("M_LOCK:%s[%d] +\n", name, line);		   \
+		DRM_MMP_EVENT_START(mutex_lock, (unsigned long)lock,	   \
+				line);	   \
+		mutex_lock(lock);		   \
+		mutex_time_start = sched_clock();		   \
+		mutex_locker = name;		   \
+	} while (0)
+
+#define DDP_MUTEX_UNLOCK(lock, name, line)                                     \
+	do {                                                                   \
+		mutex_locker = NULL;		   \
+		mutex_time_end = sched_clock();		   \
+		mutex_time_period = mutex_time_end - mutex_time_start;   \
+		if (mutex_time_period > 1000000000) {		   \
+			DDPPR_ERR("M_ULOCK:%s[%d] timeout:<%lld ns>!\n",   \
+				name, line, mutex_time_period);		   \
+			DRM_MMP_MARK(mutex_lock,		   \
+				(unsigned long)mutex_time_period, 0);   \
+			dump_stack();		   \
+		}		   \
+		mutex_unlock(lock);		   \
+		DRM_MMP_EVENT_END(mutex_lock, (unsigned long)lock,	   \
+			line);	   \
+		DDPINFO("M_ULOCK:%s[%d] -\n", name, line);		   \
+	} while (0)
+
+#define DDP_MUTEX_LOCK_NESTED(lock, i, name, line)                             \
+	do {                                                                   \
+		DDPINFO("M_LOCK_NST[%d]:%s[%d] +\n", i, name, line);   \
+		mutex_lock_nested(lock, i);		   \
+	} while (0)
+
+#define DDP_MUTEX_UNLOCK_NESTED(lock, i, name, line)                           \
+	do {                                                                   \
+		mutex_unlock(lock);		   \
+		DDPINFO("M_ULOCK_NST[%d]:%s[%d] -\n", i, name, line);	\
+	} while (0)
+
+#ifdef CONFIG_MTK_AEE_FEATURE
+#define DDPAEE(string, args...)                                                \
+	do {                                                                   \
+		char str[200];                                                 \
+		int r;	\
+		r = snprintf(str, 199, "DDP:" string, ##args);                 \
+		if (r < 0) {	\
+			pr_err("snprintf error\n");	\
+		}	\
+		aee_kernel_warning_api(__FILE__, __LINE__,                     \
+				       DB_OPT_DEFAULT |                        \
+					       DB_OPT_MMPROFILE_BUFFER,        \
+				       str, string, ##args);                   \
+		DDPPR_ERR("[DDP Error]" string, ##args);                       \
+	} while (0)
+#else /* !CONFIG_MTK_AEE_FEATURE */
+#define DDPAEE(string, args...)                                                \
+	do {                                                                   \
+		char str[200];                                                 \
+		int r;	\
+		r = snprintf(str, 199, "DDP:" string, ##args);                 \
+		if (r < 0) {	\
+			pr_err("snprintf error\n");	\
+		}	\
+		pr_err("[DDP Error]" string, ##args);                          \
+	} while (0)
+#endif /* CONFIG_MTK_AEE_FEATURE */
+
+extern bool g_mobile_log;
+extern bool g_fence_log;
+extern bool g_irq_log;
+extern bool g_detail_log;
+#endif
diff --git a/drivers/gpu/drm/mediatek/mediatek_v2/mtk_mt8195_hdmi_phy.c b/drivers/gpu/drm/mediatek/mediatek_v2/mtk_mt8195_hdmi_phy.c
new file mode 100644
index 0000000000000000000000000000000000000000..e9fe6f256fea6509ed8e32a2dec0bdaf8de76d56
--- /dev/null
+++ b/drivers/gpu/drm/mediatek/mediatek_v2/mtk_mt8195_hdmi_phy.c
@@ -0,0 +1,1280 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2019 MediaTek Inc.
+ */
+
+#include <linux/delay.h>
+#include <linux/io.h>
+#include <linux/mfd/syscon.h>
+#include <linux/module.h>
+#include <linux/phy/phy.h>
+#include <linux/platform_device.h>
+#include <linux/types.h>
+#include <linux/nvmem-consumer.h>
+
+#include "mtk_hdmi_regs.h"
+#include "mtk_hdmi_phy.h"
+
+static const char * const mtk_hdmi_phy_clk_names[MTK_HDMI_PHY_CLK_COUNT] = {
+	[MTK_HDMI_PHY_XTAL_SEL] = "hdmi_xtal_sel",
+};
+
+unsigned char mtk_hdmi_phy_log = 1;
+
+#define HDMI_PHY_LOG(fmt, arg...) \
+	do {	if (mtk_hdmi_phy_log) { \
+		pr_info("[HDMI][phy] %s,%d "fmt, __func__, __LINE__, ##arg); \
+		} \
+	} while (0)
+
+#define HDMI_PHY_FUNC()	\
+	do {	if (mtk_hdmi_phy_log) \
+		pr_info("[HDMI][hpy] %s\n", __func__); \
+	} while (0)
+
+static inline bool mtk_hdmi_phy_readbit(struct mtk_hdmi_phy *hdmi_phy,
+	unsigned short reg, unsigned int offset)
+{
+	return (readl(hdmi_phy->regs + reg) & offset) ? true : false;
+}
+
+unsigned int mtk_hdmi_phy_read(
+	struct mtk_hdmi_phy *hdmi_phy, unsigned short reg)
+{
+	return readl(hdmi_phy->regs + reg);
+}
+
+void mtk_hdmi_phy_write(struct mtk_hdmi_phy *hdmi_phy,
+	unsigned short reg, unsigned int val)
+{
+	writel(val, hdmi_phy->regs + reg);
+}
+
+static inline void mtk_hdmi_phy_mask(struct mtk_hdmi_phy *hdmi_phy,
+	unsigned int reg, unsigned int val, unsigned int mask)
+{
+	unsigned int tmp;
+
+	tmp = readl(hdmi_phy->regs + reg) & ~mask;
+	tmp |= (val & mask);
+	writel(tmp, hdmi_phy->regs + reg);
+}
+
+static inline struct mtk_hdmi_phy *to_mtk_hdmi_phy(struct clk_hw *hw)
+{
+	return container_of(hw, struct mtk_hdmi_phy, txpll_hw);
+}
+
+//can.zeng todo verify
+static inline struct mtk_hdmi *to_mtk_hdmi(struct mtk_hdmi_phy *hdmi_phy)
+{
+	return global_mtk_hdmi;
+}
+
+/*********Analog API export to HDMI Digital start*****/
+void mtk_hdmi_ana_fifo_en(struct mtk_hdmi_phy *hdmi_phy)
+{
+	HDMI_PHY_FUNC();
+
+	/*make data fifo writable for hdmi2.0*/
+	mtk_hdmi_phy_mask(hdmi_phy, HDMI_ANA_CTL, reg_ana_hdmi20_fifo_en,
+		reg_ana_hdmi20_fifo_en);
+}
+
+
+//void hdmitx_confighdmisetting(unsigned int resolutionmode)
+void mtk_tmds_high_bit_clk_ratio(struct mtk_hdmi *hdmi, bool enable)
+{
+	struct mtk_hdmi_phy *hdmi_phy =	hdmi->hdmi_phy_base;
+
+	HDMI_PHY_FUNC();
+
+	mtk_hdmi_ana_fifo_en(hdmi_phy);
+
+/* HDMI 2.0 specification, 3.4Gbps <= TMDS Bit Rate <= 6G,
+ * clock bit ratio 1:40, under 3.4Gbps, clock bit ratio 1:10
+ */
+	if (enable == true) {
+		HDMI_PHY_LOG("Over 3.4Gbps, clk bit ratio 1:40\n");
+		mtk_hdmi_phy_mask(hdmi_phy, HDMI20_CLK_CFG,
+			(0x2 << reg_txc_div_SHIFT), reg_txc_div);
+	} else {
+		HDMI_PHY_LOG("Under 3.4Gbps, clk bit ratio 1:10\n");
+		mtk_hdmi_phy_mask(hdmi_phy, HDMI20_CLK_CFG, 0, reg_txc_div);
+	}
+}
+
+/*********Analog API export to HDMI Digital end*******/
+
+const char *txpll_parent_dts_names[TXPLL_CLK_PARENT_COUNT] = {
+	"tvdpll", "hdmirx_clk", "xtal26m"};
+
+static int mtk_hdmi_txpll_select_source(struct clk_hw *hw,
+	unsigned char hdmirx_ref_ck_div,
+	unsigned char ad_respll_ck_div)
+{
+
+	struct mtk_hdmi_phy *hdmi_phy = to_mtk_hdmi_phy(hw);
+
+	if ((hdmi_phy->clk_parent < PLLGP1_PLLGP_2H_PLL2) ||
+		(hdmi_phy->clk_parent >= TXPLL_CLK_PARENT_COUNT)) {
+		HDMI_PHY_LOG("%s: err: wrong clk parent\n", __func__);
+		return -EINVAL;
+	}
+
+/* if txpll source is hdmirx_ref_ck or ad_respll_ck:
+ * 5-bit divider: 0b00000=0x0-> /1, 0b00001=0x1 -> /2, 0b11111=0x1f -> /32
+ */
+	if (hdmi_phy->clk_parent == PLLGP1_PLLGP_2H_PLL2) {
+		mtk_hdmi_phy_mask(hdmi_phy, HDMI_CTL_3,
+			(ad_respll_ck_div - 1) << REG_RESPLL_DIV_CONFIG_SHIFT,
+			REG_RESPLL_DIV_CONFIG);
+		mtk_hdmi_phy_mask(hdmi_phy, HDMI_CTL_3,
+			0x1 << REG_HDMITX_REF_RESPLL_SEL_SHIFT,
+			REG_HDMITX_REF_RESPLL_SEL);
+		HDMI_PHY_LOG("txpll source clk is TVD PLL\n");
+		HDMI_PHY_LOG("ad_respll_clk_div = %x\n", ad_respll_ck_div);
+
+	} else if (hdmi_phy->clk_parent == HDMIRX) {
+		mtk_hdmi_phy_mask(hdmi_phy, HDMI_CTL_3,
+			(hdmirx_ref_ck_div - 1) << REG_HDMIRX_DIV_CONFG_SHIFT,
+			REG_HDMIRX_DIV_CONFG);
+		mtk_hdmi_phy_mask(hdmi_phy, HDMI_CTL_3,
+			0x1 << REG_HDMITX_REF_XTAL_SEL_SHIFT,
+			REG_HDMITX_REF_XTAL_SEL);
+		mtk_hdmi_phy_mask(hdmi_phy, HDMI_CTL_3,
+			0x0 << REG_HDMITX_REF_RESPLL_SEL_SHIFT,
+			REG_HDMITX_REF_RESPLL_SEL);
+		HDMI_PHY_LOG("txpll source clk is HDMIRX REF CLK\n");
+		HDMI_PHY_LOG("hdmirx_ref_clk_div = %x\n", hdmirx_ref_ck_div);
+
+	} else if (hdmi_phy->clk_parent == XTAL26M) {
+		mtk_hdmi_phy_mask(hdmi_phy, HDMI_CTL_3,
+			0x0 << REG_HDMITX_REF_XTAL_SEL_SHIFT,
+			REG_HDMITX_REF_XTAL_SEL);
+		mtk_hdmi_phy_mask(hdmi_phy, HDMI_CTL_3,
+			0x0 << REG_HDMITX_REF_RESPLL_SEL_SHIFT,
+			REG_HDMITX_REF_RESPLL_SEL);
+		HDMI_PHY_LOG("txpll source clk is xTal26M CLK\n");
+
+	}
+
+	/*DA_HDMITX21_REF_CK for TXPLL input source*/
+	mtk_hdmi_phy_mask(hdmi_phy, HDMI_1_CFG_10,
+		0x0 << RG_HDMITXPLL_REF_CK_SEL_SHIFT, RG_HDMITXPLL_REF_CK_SEL);
+
+	return 0;
+}
+
+static int mtk_hdmi_txpll_performance_setting(struct clk_hw *hw)
+{
+	struct mtk_hdmi_phy *hdmi_phy = to_mtk_hdmi_phy(hw);
+	struct mtk_hdmi *hdmi = to_mtk_hdmi(hdmi_phy);
+
+/* no matter txpll input source is HDMIRX_REF_CK, xTal26M or TVD PLL,
+ * the performance configuration is the same.
+ * RG_HDMITXPLL_BP2 always 1'b1 = 0x1
+ * RG_HDMITXPLL_BC[1:0] always 2'b11 = 0x3
+ * RG_HDMITXPLL_IC[4:0] always 5'b00001 = 0x1
+ * RG_HDMITXPLL_BR[2:0] stage treatment:
+ *      24bit or 48bit->3'b001 = 0x1
+ *      30bit or 36bit->3'b011 = 0x3
+ * RG_HDMITXPLL_IR[4:0] stage treatment:
+ *      24bit,30bit,48bit ->5'b00010 = 0x2
+ *      36bit ->5'b00011 = 0x3
+ * RG_HDMITXPLL_BP[3:0] always 4'b1111 = 0xf
+ * RG_HDMITXPLL_IBAND_FIX_EN, RG_HDMITXPLL_RESERVE[14] always 2'b00 = 0x0
+ * RG_HDMITXPLL_HIKVCO always 1'b1 = 0x1
+ */
+
+	/* BP2 */
+	mtk_hdmi_phy_mask(hdmi_phy, HDMI_1_PLL_CFG_0,
+		0x1 << RG_HDMITXPLL_BP2_SHIFT, RG_HDMITXPLL_BP2);
+
+	/* BC */
+	mtk_hdmi_phy_mask(hdmi_phy, HDMI_1_PLL_CFG_2,
+		0x3 << RG_HDMITXPLL_BC_SHIFT, RG_HDMITXPLL_BC);
+
+	/* IC */
+	mtk_hdmi_phy_mask(hdmi_phy, HDMI_1_PLL_CFG_2,
+		0x1 << RG_HDMITXPLL_IC_SHIFT, RG_HDMITXPLL_IC);
+
+	/* BR */
+	if ((hdmi->color_depth == HDMI_8_BIT) ||
+		(hdmi->color_depth == HDMI_10_BIT) ||
+		(hdmi->color_depth == HDMI_16_BIT))
+		mtk_hdmi_phy_mask(hdmi_phy, HDMI_1_PLL_CFG_2,
+			0x2 << RG_HDMITXPLL_BR_SHIFT, RG_HDMITXPLL_BR);
+	else if (hdmi->color_depth == HDMI_12_BIT)
+		mtk_hdmi_phy_mask(hdmi_phy, HDMI_1_PLL_CFG_2,
+			0x1 << RG_HDMITXPLL_BR_SHIFT, RG_HDMITXPLL_BR);
+	else {
+		HDMI_PHY_LOG("%s, unknown color depth\n", __func__);
+		return -EINVAL;
+	}
+
+	/* IR */
+	if ((hdmi->color_depth == HDMI_8_BIT) ||
+		(hdmi->color_depth == HDMI_16_BIT))
+		mtk_hdmi_phy_mask(hdmi_phy, HDMI_1_PLL_CFG_2,
+			0x2 << RG_HDMITXPLL_IR_SHIFT, RG_HDMITXPLL_IR);
+	else if (hdmi->color_depth == HDMI_10_BIT)
+		mtk_hdmi_phy_mask(hdmi_phy, HDMI_1_PLL_CFG_2,
+			0x3 << RG_HDMITXPLL_IR_SHIFT, RG_HDMITXPLL_IR);
+	else if (hdmi->color_depth == HDMI_12_BIT)
+		mtk_hdmi_phy_mask(hdmi_phy, HDMI_1_PLL_CFG_2,
+			0x4 << RG_HDMITXPLL_IR_SHIFT, RG_HDMITXPLL_IR);
+	else {
+		HDMI_PHY_LOG("%s, unknown color depth\n", __func__);
+		return -EINVAL;
+	}
+
+	/* BP */
+	mtk_hdmi_phy_mask(hdmi_phy, HDMI_1_PLL_CFG_2,
+		0xf << RG_HDMITXPLL_BP_SHIFT, RG_HDMITXPLL_BP);
+
+	/* IBAND_FIX_EN, RESERVE[14] */
+	mtk_hdmi_phy_mask(hdmi_phy, HDMI_1_PLL_CFG_0,
+		0x0 << RG_HDMITXPLL_IBAND_FIX_EN_SHIFT,
+		RG_HDMITXPLL_IBAND_FIX_EN);
+	mtk_hdmi_phy_mask(hdmi_phy, HDMI_1_PLL_CFG_1,
+		0x0 << RG_HDMITXPLL_RESERVE_BIT14_SHIFT,
+		RG_HDMITXPLL_RESERVE_BIT14);
+
+	/* HIKVCO */
+	mtk_hdmi_phy_mask(hdmi_phy, HDMI_1_PLL_CFG_2,
+		0x0 << RG_HDMITXPLL_HIKVCO_SHIFT, RG_HDMITXPLL_HIKVCO);
+
+	/* HREN */
+	mtk_hdmi_phy_mask(hdmi_phy, HDMI_1_PLL_CFG_0,
+		0x1 << RG_HDMITXPLL_HREN_SHIFT, RG_HDMITXPLL_HREN);
+
+	/* LVR_SEL */
+	mtk_hdmi_phy_mask(hdmi_phy, HDMI_1_PLL_CFG_0,
+		0x1 << RG_HDMITXPLL_LVR_SEL_SHIFT, RG_HDMITXPLL_LVR_SEL);
+
+	/* RG_HDMITXPLL_RESERVE[12:11] */
+	mtk_hdmi_phy_mask(hdmi_phy, HDMI_1_PLL_CFG_1,
+		0x3 << RG_HDMITXPLL_RESERVE_BIT12_11_SHIFT, RG_HDMITXPLL_RESERVE_BIT12_11);
+
+	/* TCL_EN */
+	mtk_hdmi_phy_mask(hdmi_phy, HDMI_1_PLL_CFG_0,
+		0x1 << RG_HDMITXPLL_TCL_EN_SHIFT, RG_HDMITXPLL_TCL_EN);
+
+	if (hdmi_phy->efuse == 0) {
+		/* disable read calibration impedance from efuse */
+		mtk_hdmi_phy_mask(hdmi_phy, HDMI_CTL_1,
+			0x1f << RG_INTR_IMP_RG_MODE_SHIFT,
+			RG_INTR_IMP_RG_MODE);
+	}
+
+	return 0;
+}
+
+static int mtk_hdmi_txpll_set_hw(struct clk_hw *hw,
+	unsigned char hdmirx_ref_ck_div, unsigned char ad_respll_ck_div,
+	unsigned char prediv, unsigned char fbkdiv_high,
+	unsigned long fbkdiv_low, unsigned char fbkdiv_hs3,
+	unsigned char posdiv1, unsigned char posdiv2,
+	unsigned char txprediv, unsigned char txposdiv,
+	unsigned char digital_div)
+{
+	unsigned char txposdiv_value = 0;
+	unsigned char div3_ctrl_value = 0;
+	unsigned char posdiv_vallue = 0;
+	unsigned char div_ctrl_value = 0;
+	unsigned char reserve_3_2_value = 0;
+	unsigned char prediv_value = 0;
+	unsigned char reserve13_value = 0;
+
+	struct mtk_hdmi_phy *hdmi_phy = to_mtk_hdmi_phy(hw);
+
+	mtk_hdmi_txpll_select_source(hw, hdmirx_ref_ck_div, ad_respll_ck_div);
+
+	mtk_hdmi_txpll_performance_setting(hw);
+
+
+	mtk_hdmi_phy_mask(hdmi_phy, HDMI_1_CFG_10,
+		0x2 << RG_HDMITX21_BIAS_PE_BG_VREF_SEL_SHIFT,
+		RG_HDMITX21_BIAS_PE_BG_VREF_SEL);
+	mtk_hdmi_phy_mask(hdmi_phy, HDMI_1_CFG_10,
+		0x0 << RG_HDMITX21_VREF_SEL_SHIFT, RG_HDMITX21_VREF_SEL);
+	mtk_hdmi_phy_mask(hdmi_phy, HDMI_1_CFG_9,
+		0x2 << RG_HDMITX21_SLDO_VREF_SEL_SHIFT,
+		RG_HDMITX21_SLDO_VREF_SEL);
+	mtk_hdmi_phy_mask(hdmi_phy, HDMI_1_CFG_10,
+		0x0 << RG_HDMITX21_BIAS_PE_VREF_SELB_SHIFT,
+		RG_HDMITX21_BIAS_PE_VREF_SELB);
+	mtk_hdmi_phy_mask(hdmi_phy, HDMI_1_CFG_3,
+		0x1 << RG_HDMITX21_SLDOLPF_EN_SHIFT, RG_HDMITX21_SLDOLPF_EN);
+	mtk_hdmi_phy_mask(hdmi_phy, HDMI_1_CFG_6,
+		0x11 << RG_HDMITX21_INTR_CAL_SHIFT, RG_HDMITX21_INTR_CAL);
+	mtk_hdmi_phy_mask(hdmi_phy, HDMI_1_PLL_CFG_2,
+		0x1 << RG_HDMITXPLL_PWD_SHIFT, RG_HDMITXPLL_PWD);
+
+	/* TXPOSDIV */
+	if (txposdiv == 1)
+		txposdiv_value = 0x0;
+	else if (txposdiv == 2)
+		txposdiv_value = 0x1;
+	else if (txposdiv == 4)
+		txposdiv_value = 0x2;
+	else if (txposdiv == 8)
+		txposdiv_value = 0x3;
+	else {
+		HDMI_PHY_LOG("TXPOSDIV error\n");
+		return -EINVAL;
+	}
+	mtk_hdmi_phy_mask(hdmi_phy, HDMI_1_CFG_6,
+		txposdiv_value << RG_HDMITX21_TX_POSDIV_SHIFT,
+		RG_HDMITX21_TX_POSDIV);
+
+	/* /5, tmds_clk_frequency = tmds_data_frequency / 5 */
+	mtk_hdmi_phy_mask(hdmi_phy, HDMI_1_CFG_6,
+		0x1 << RG_HDMITX21_TX_POSDIV_EN_SHIFT,
+		RG_HDMITX21_TX_POSDIV_EN);
+	mtk_hdmi_phy_mask(hdmi_phy, HDMI_1_CFG_6,
+		0x0 << RG_HDMITX21_FRL_EN_SHIFT, RG_HDMITX21_FRL_EN);
+
+	/* TXPREDIV */
+	if (txprediv == 2) {
+		div3_ctrl_value = 0x0;
+		posdiv_vallue = 0x0;
+	} else if (txprediv == 4) {
+		div3_ctrl_value = 0x0;
+		posdiv_vallue = 0x1;
+	} else if (txprediv == 6) {
+		div3_ctrl_value = 0x1;
+		posdiv_vallue = 0x0;
+	} else if (txprediv == 12) {
+		div3_ctrl_value = 0x1;
+		posdiv_vallue = 0x1;
+	} else {
+		HDMI_PHY_LOG("TXPREDIV error\n");
+		return -EINVAL;
+	}
+	mtk_hdmi_phy_mask(hdmi_phy, HDMI_1_PLL_CFG_4,
+		div3_ctrl_value << RG_HDMITXPLL_POSDIV_DIV3_CTRL_SHIFT,
+		RG_HDMITXPLL_POSDIV_DIV3_CTRL);
+	mtk_hdmi_phy_mask(hdmi_phy, HDMI_1_PLL_CFG_4,
+		posdiv_vallue << RG_HDMITXPLL_POSDIV_SHIFT,
+		RG_HDMITXPLL_POSDIV);
+
+	/* POSDIV1 */
+	if (posdiv1 == 5)
+		div_ctrl_value = 0x0;
+	else if (posdiv1 == 10)
+		div_ctrl_value = 0x1;
+	else if (posdiv1 == (125 / 10))
+		div_ctrl_value = 0x2;
+	else if (posdiv1 == 15)
+		div_ctrl_value = 0x3;
+	else {
+		HDMI_PHY_LOG("POSDIV1 error\n");
+		HDMI_PHY_LOG("POSDIV1 = %d\n", posdiv1);
+		div_ctrl_value = 0x1;
+		//return -EINVAL;
+	}
+	mtk_hdmi_phy_mask(hdmi_phy, HDMI_1_PLL_CFG_4,
+		div_ctrl_value << RG_HDMITXPLL_DIV_CTRL_SHIFT,
+		RG_HDMITXPLL_DIV_CTRL);
+
+	/* DE add new setting */
+	mtk_hdmi_phy_mask(hdmi_phy, HDMI_1_PLL_CFG_1,
+		0x0 << RG_HDMITXPLL_RESERVE_BIT14_SHIFT,
+		RG_HDMITXPLL_RESERVE_BIT14);
+
+	/* POSDIV2 */
+	if (posdiv2 == 1)
+		reserve_3_2_value = 0x0;
+	else if (posdiv2 == 2)
+		reserve_3_2_value = 0x1;
+	else if (posdiv2 == 4)
+		reserve_3_2_value = 0x2;
+	else if (posdiv2 == 6)
+		reserve_3_2_value = 0x3;
+	else {
+		HDMI_PHY_LOG("POSDIV2 error\n");
+		HDMI_PHY_LOG("POSDIV2 = %d\n", posdiv2);
+		reserve_3_2_value = 0x1;
+		//return -EINVAL;
+	}
+	mtk_hdmi_phy_mask(hdmi_phy, HDMI_1_PLL_CFG_1,
+		reserve_3_2_value << RG_HDMITXPLL_RESERVE_BIT3_2_SHIFT,
+		RG_HDMITXPLL_RESERVE_BIT3_2);
+
+	/* DE add new setting */
+	mtk_hdmi_phy_mask(hdmi_phy, HDMI_1_PLL_CFG_1,
+		0x2 << RG_HDMITXPLL_RESERVE_BIT1_0_SHIFT,
+		RG_HDMITXPLL_RESERVE_BIT1_0);
+
+	/* PREDIV */
+	if (prediv == 1)
+		prediv_value = 0x0;
+	else if (prediv == 2)
+		prediv_value = 0x1;
+	else if (prediv == 4)
+		prediv_value = 0x2;
+	else {
+		HDMI_PHY_LOG("PREDIV error\n");
+		HDMI_PHY_LOG("PREDIV = %d\n", prediv);
+		//return -EINVAL;
+	}
+	mtk_hdmi_phy_mask(hdmi_phy, HDMI_1_PLL_CFG_4,
+		prediv_value << RG_HDMITXPLL_PREDIV_SHIFT,
+		RG_HDMITXPLL_PREDIV);
+
+	/* FBKDIV_HS3 */
+	if (fbkdiv_hs3 == 1)
+		reserve13_value = 0x0;
+	else if (fbkdiv_hs3 == 2)
+		reserve13_value = 0x1;
+	else {
+		HDMI_PHY_LOG("FBKDIV_HS3 error\n");
+		return -EINVAL;
+	}
+	mtk_hdmi_phy_mask(hdmi_phy, HDMI_1_PLL_CFG_1,
+		reserve13_value << RG_HDMITXPLL_RESERVE_BIT13_SHIFT,
+		RG_HDMITXPLL_RESERVE_BIT13);
+
+	/* FBDIV */
+	mtk_hdmi_phy_mask(hdmi_phy, HDMI_1_PLL_CFG_4,
+		fbkdiv_high << RG_HDMITXPLL_FBKDIV_high_SHIFT,
+		RG_HDMITXPLL_FBKDIV_high);
+	mtk_hdmi_phy_mask(hdmi_phy, HDMI_1_PLL_CFG_3,
+		fbkdiv_low << RG_HDMITXPLL_FBKDIV_low_SHIFT,
+		RG_HDMITXPLL_FBKDIV_low);
+
+	/* Digital DIVIDER */
+	if (hdmi_phy->clk_parent == PLLGP1_PLLGP_2H_PLL2)
+		mtk_hdmi_phy_mask(hdmi_phy, HDMI_CTL_3,
+			0x1 << REG_PIXEL_CLOCK_SEL_SHIFT, REG_PIXEL_CLOCK_SEL);
+	else if (hdmi_phy->clk_parent == XTAL26M)
+		mtk_hdmi_phy_mask(hdmi_phy, HDMI_CTL_3,
+			0x0 << REG_PIXEL_CLOCK_SEL_SHIFT, REG_PIXEL_CLOCK_SEL);
+	else
+		HDMI_PHY_LOG("no need to set Digital Divider path\n");
+
+	HDMI_PHY_LOG("Digital Divider = %d\n", digital_div);
+	if (digital_div == 1)
+		mtk_hdmi_phy_mask(hdmi_phy, HDMI_CTL_3,
+			0x0 << REG_HDMITX_PIXEL_CLOCK_SHIFT, REG_HDMITX_PIXEL_CLOCK);
+	else {
+		mtk_hdmi_phy_mask(hdmi_phy, HDMI_CTL_3,
+			0x1 << REG_HDMITX_PIXEL_CLOCK_SHIFT, REG_HDMITX_PIXEL_CLOCK);
+		mtk_hdmi_phy_mask(hdmi_phy, HDMI_CTL_3,
+			(digital_div - 1) << REG_HDMITXPLL_DIV_SHIFT, REG_HDMITXPLL_DIV);
+	}
+
+	return 0;
+}
+
+#define PCW_DECIMAL_WIDTH 24
+
+static int mtk_hdmi_txpll_calculate_params(struct clk_hw *hw,
+	unsigned long rate, unsigned long parent_rate)
+{
+	int ret;
+	unsigned long long tmds_clk = 0;
+	unsigned long long  pixel_clk = 0;
+	//ref clock from hdmi Rx
+	unsigned long long hdmirx_ref_ck= 0;
+	unsigned char hdmirx_ref_ck_div = 0;
+	//ref clock from tvd pll
+	unsigned long long ad_respll_ck = 0;
+	unsigned char ad_respll_ck_div = 0;
+	//txpll input source frequency
+	unsigned long long da_hdmitx21_ref_ck = 0;
+	unsigned long long ns_hdmitxpll_ck = 0; //ICO output clk
+	//source clk for Display digital
+	unsigned long long ad_hdmitxpll_pixel_ck = 0;
+	unsigned char digital_div = 0;
+	unsigned long long pcw = 0; //FBDIV
+	unsigned char txprediv = 0;
+	unsigned char txposdiv = 0;
+	unsigned char fbkdiv_high = 0;
+	unsigned long fbkdiv_low = 0;
+	unsigned char posdiv1 = 0;
+	unsigned char posdiv2 = 0;
+	unsigned char prediv = 1; //prediv is always 1
+	unsigned char fbkdiv_hs3 = 1; //fbkdiv_hs3 is always 1
+	int i = 0;
+	unsigned char TXPREDIV[4] = {2, 4, 6, 12};
+
+	struct mtk_hdmi_phy *hdmi_phy = to_mtk_hdmi_phy(hw);
+	struct mtk_hdmi *hdmi = to_mtk_hdmi(hdmi_phy);
+
+	pixel_clk = hdmi->mode.clock * 1000;//in HZ
+
+/* TMDS clk frequency */
+	if ((hdmi->csp == HDMI_COLORSPACE_RGB) || (hdmi->csp == HDMI_COLORSPACE_YUV444)) {
+		if (hdmi->color_depth == HDMI_8_BIT)
+			tmds_clk = pixel_clk;
+		else if (hdmi->color_depth == HDMI_10_BIT)
+			tmds_clk = pixel_clk * 5 / 4; // *1.25
+		else if (hdmi->color_depth == HDMI_12_BIT)
+			tmds_clk = pixel_clk * 3 / 2; // *1.5
+		else if (hdmi->color_depth == HDMI_16_BIT)
+			tmds_clk = pixel_clk * 2; // *2
+		else {
+			HDMI_PHY_LOG("%s, unknown color depth\n", __func__);
+			return -EINVAL;
+		}
+	} else if (hdmi->csp == HDMI_COLORSPACE_YUV422)
+		tmds_clk = pixel_clk; //YUV420,12bit,TMDS_CLK == 8bit RGB444 TMDS_CLK
+	else if (hdmi->csp == HDMI_COLORSPACE_YUV420) {
+		if (hdmi->color_depth == HDMI_8_BIT)
+			tmds_clk = pixel_clk / 2;
+		else if (hdmi->color_depth == HDMI_10_BIT)
+			tmds_clk = pixel_clk / 2 * 5 / 4; // *1.25
+		else if (hdmi->color_depth == HDMI_12_BIT)
+			tmds_clk = pixel_clk / 2 * 3 / 2; // *1.5
+		else if (hdmi->color_depth == HDMI_16_BIT)
+			tmds_clk = pixel_clk / 2 * 2; // *2
+		else {
+			HDMI_PHY_LOG("%s, unknown color depth\n", __func__);
+			return -EINVAL;
+		}
+	} else
+		HDMI_PHY_LOG("unknown color space\n");
+
+	if ((tmds_clk < hdmi_phy->min_tmds_clock) &&
+		(tmds_clk > hdmi_phy->max_tmds_clock)) {
+		HDMI_PHY_LOG("%s, TMDS ck out of range\n", __func__);
+		return -EINVAL;
+	}
+
+/* DA_HDMITX21_REF_CK:
+ * there 3 input clk source :
+ * 1st: tvdpll(PLLGP1):
+ *     AD_RESPLL_CK: 648M(27M times),
+ *                   594M(>HD and integer framerate),
+ *                   593.4M(>HD and fractional framerate)
+ * 2st: hdmirx clk: 27M,74M,148M,297M,594M,etc, depends on what clk Rx receive
+ * 3st: xTal26M crystal clk: always 26M
+ */
+	if (hdmi_phy->clk_parent == XTAL26M)
+		da_hdmitx21_ref_ck = 26000000UL; //in HZ
+	else if (hdmi_phy->clk_parent == HDMIRX) {
+		hdmirx_ref_ck = hdmi_phy->rx_clk_rate;
+		HDMI_PHY_LOG("Rx ref clk, hdmirx_ref_ck=%d\n", hdmirx_ref_ck);
+		for (i = 32; i >= 1; i--)
+			if (((hdmirx_ref_ck / i / prediv) >= 20000000UL) &&
+				((hdmirx_ref_ck / i / prediv) <= 30000000UL))
+				break;
+		/* constraint: txpll input clk range: 20Mhz~30Mhz */
+		if (i == 1 && (((hdmirx_ref_ck / i / prediv) < 20000000UL) ||
+			((hdmirx_ref_ck / i / prediv) > 30000000UL))) {
+			HDMI_PHY_LOG("%s, Rx ck err\n", __func__);
+			return -EINVAL;
+		}
+		hdmirx_ref_ck_div = i;
+		da_hdmitx21_ref_ck = hdmirx_ref_ck / i / prediv;
+	} else if (hdmi_phy->clk_parent == PLLGP1_PLLGP_2H_PLL2) {
+	//can.zeng todo verify,
+	//case 1: ad_respll_ck = parent_rate,
+	//case 2: stage treatment according to current pixel clk
+
+		if ((pixel_clk % 27000000) == 0) {
+			ad_respll_ck = 648000000;
+			ad_respll_ck_div = 24;
+		} else if (pixel_clk % 74250000 == 0) {
+			ad_respll_ck = 594000000;
+			ad_respll_ck_div = 22;
+		} else if (pixel_clk % 74135000 == 0) {
+			ad_respll_ck = 593400000;
+			ad_respll_ck_div = 22;
+		} else {
+			//can.zeng todo in-regular hdmi resolution clk
+			return -EINVAL;
+		}
+
+		da_hdmitx21_ref_ck = ad_respll_ck / ad_respll_ck_div;
+	} else {
+		HDMI_PHY_LOG("%s, unknown clk parent\n", __func__);
+		return -EINVAL;
+	}
+
+/*  TXPOSDIV stage treatment:
+ *	0M  <  TMDS clk  < 54M		  /8
+ *	54M <= TMDS clk  < 148.35M    /4
+ *	148.35M <=TMDS clk < 296.7M   /2
+ *	296.7 <=TMDS clk <= 594M	  /1
+ */
+	if (tmds_clk < 54000000UL)
+		txposdiv = 8;
+	else if ((tmds_clk >= 54000000UL) && (tmds_clk < 148350000UL))
+		txposdiv = 4;
+	else if ((tmds_clk >= 148350000UL) && (tmds_clk < 296700000UL))
+		txposdiv = 2;
+	else if ((tmds_clk >= 296700000UL) && (tmds_clk <= 594000000UL))
+		txposdiv = 1;
+	else {
+		HDMI_PHY_LOG("%s, tmds clk out of range\n", __func__);
+		return -EINVAL;
+	}
+
+/* calculate TXPREDIV: can be 2, 4, 6, 12
+ * ICO clk = 5*TMDS_CLK*TXPOSDIV*TXPREDIV
+ * ICO clk constraint: 5G =< ICO clk <= 12G
+ */
+	for (i = 0; i < ARRAY_SIZE(TXPREDIV); i++) {
+		ns_hdmitxpll_ck = 5 * tmds_clk * txposdiv * TXPREDIV[i];
+		if ((ns_hdmitxpll_ck >= 5000000000UL) &&
+			(ns_hdmitxpll_ck <= 12000000000UL))
+			break;
+	}
+	if ((i == (ARRAY_SIZE(TXPREDIV) - 1)) &&
+		((ns_hdmitxpll_ck < 5000000000UL) ||
+		(ns_hdmitxpll_ck > 12000000000UL))) {
+		HDMI_PHY_LOG("%s, TXPREDIV, >12G or <5G\n", __func__);
+		return -EINVAL;
+	}
+	txprediv = TXPREDIV[i];
+
+/* PCW calculation: FBKDIV
+ * formula: pcw=(frequency_out*2^pcw_bit) / frequency_in / FBKDIV_HS3;
+ * RG_HDMITXPLL_FBKDIV[32:0]:
+ * [32,24] 9bit integer, [23,0]:24bit fraction
+ */
+	pcw = ns_hdmitxpll_ck;
+	/*
+	 *for (i = 0; i < PCW_DECIMAL_WIDTH; i++)
+	 *	pcw *=2;
+	 */
+	pcw = pcw << PCW_DECIMAL_WIDTH;
+	pcw = pcw / da_hdmitx21_ref_ck;
+	pcw = pcw / fbkdiv_hs3;
+
+	if ((pcw / (1ULL << 32)) > 1) {
+		HDMI_PHY_LOG("%s, PCW out range\n", __func__);
+		return -EINVAL;
+	} else if ((pcw / (1ULL << 32)) == 1) {
+		fbkdiv_high = 1;
+		fbkdiv_low = pcw % (1ULL << 32);
+	} else {
+		fbkdiv_high = 0;
+		fbkdiv_low = pcw;
+	}
+	/* can.zeng todo verify algorithm
+	 * if clk input source is HDMI RX, the PCW shall be integer
+	 * because the Rx ref clk == pixel clk, or == 1/2 pixel clk,
+	 * so the integer pcw to make the txpll output more accurate
+	 */
+	if (hdmi_phy->clk_parent == HDMIRX) {
+		if ((fbkdiv_low & BIT(23)) != 0)
+			fbkdiv_low = (fbkdiv_low & (~(GENMASK(23, 0)))) + BIT(24);
+		else
+			fbkdiv_low = fbkdiv_low & (~(GENMASK(23, 0)));
+	}
+
+/* posdiv1:
+ * posdiv1 stage treatment according to color_depth:
+ * 24bit -> posdiv1 /10, 30bit -> posdiv1 /12.5,
+ * 36bit -> posdiv1 /15, 48bit -> posdiv1 /10
+ */
+
+//can.zeng todo verify, make posdiv2 always 1 temporarily,
+//and pixel clock be generated by Digital Divider, max /32
+/* posdiv2:
+ */
+	if ((hdmi->csp == HDMI_COLORSPACE_RGB) || (hdmi->csp == HDMI_COLORSPACE_YUV444)
+	|| (hdmi->csp == HDMI_COLORSPACE_YUV420)) {
+		if ((hdmi->color_depth == HDMI_8_BIT) ||
+			(hdmi->color_depth == HDMI_16_BIT)) {
+			posdiv1 = 10; // div 10
+			posdiv2 = 1;
+			ad_hdmitxpll_pixel_ck = (ns_hdmitxpll_ck / 10) / 1;
+		} else if (hdmi->color_depth == HDMI_10_BIT) {
+			posdiv1 = 125 / 10; // div 12.5
+			posdiv2 = 1;
+			ad_hdmitxpll_pixel_ck = ((ns_hdmitxpll_ck * 10) / 125) / 1;
+		} else if (hdmi->color_depth == HDMI_12_BIT) {
+			posdiv1 = 15; // div 15
+			posdiv2 = 1;
+			ad_hdmitxpll_pixel_ck = (ns_hdmitxpll_ck / 15) / 1;
+		} else {
+			HDMI_PHY_LOG("%s, unknown color depth\n", __func__);
+			return -EINVAL;
+		}
+	} else if (hdmi->csp == HDMI_COLORSPACE_YUV422) {
+		//yuv422 is the same as yuv444 8bit
+		posdiv1 = 10; // div 10
+		posdiv2 = 1;
+		ad_hdmitxpll_pixel_ck = (ns_hdmitxpll_ck / 10) / 1;
+	} else
+		HDMI_PHY_LOG("unknown color space\n");
+	HDMI_PHY_LOG("ad_hdmitxpll_pixel_clk =%ull\n", ad_hdmitxpll_pixel_ck);
+
+/* Digital clk divider, max /32 */
+	digital_div = ad_hdmitxpll_pixel_ck / pixel_clk;
+	if (!((digital_div <= 32) && (digital_div >= 1))) {
+		HDMI_PHY_LOG("%s, Invalid Digital Divider\n", __func__);
+		return -EINVAL;
+	}
+	HDMI_PHY_LOG("digital divider = %d\n", digital_div);
+
+	ret = mtk_hdmi_txpll_set_hw(hw, hdmirx_ref_ck_div, ad_respll_ck_div,
+		prediv, fbkdiv_high, fbkdiv_low, fbkdiv_hs3,
+		posdiv1, posdiv2, txprediv, txposdiv, digital_div);
+	if (ret != 0) {
+		HDMI_PHY_LOG("set HW parameters error!\n");
+		return -EINVAL;
+	}
+
+	pr_info("[HDMI][TXPLL] Parameter list:\n");
+	pr_info("hdmirx_ref_ck_div = %d\n", hdmirx_ref_ck_div);
+	pr_info("ad_respll_ck_div = %d\n", ad_respll_ck_div);
+	pr_info("prediv = %d\n", prediv);
+	pr_info("pcw = %ld\n", pcw);
+	pr_info("pcw = %lx\n", pcw);
+	pr_info("fbkdiv_high = %x\n", fbkdiv_high);
+	pr_info("fbkdiv_low = %lx\n", fbkdiv_low);
+	pr_info("fbkdiv_hs3 = %d\n", fbkdiv_hs3);
+	pr_info("posdiv1 = %d\n", posdiv1);
+	pr_info("posdiv2 = %d\n", posdiv2);
+	pr_info("digital_div = %d\n", digital_div);
+	pr_info("txprediv = %d\n", txprediv);
+	pr_info("txposdiv = %d\n", txposdiv);
+
+	pr_info("hdmi->color_depth=%d\n", hdmi->color_depth);
+	pr_info("hdmi->color_space=%d\n", hdmi->csp);
+	return 0;
+}
+
+static int mtk_hdmi_txpll_drv_setting(struct clk_hw *hw)
+{
+	unsigned char data_channel_bias, clk_channel_bias;
+	unsigned char impedance, impedance_en;
+	struct mtk_hdmi_phy *hdmi_phy = to_mtk_hdmi_phy(hw);
+	struct mtk_hdmi *hdmi = to_mtk_hdmi(hdmi_phy);
+	unsigned long tmds_clk;
+	unsigned long pixel_clk = hdmi->mode.clock * 1000;//in HZ
+
+	/* TMDS clk frequency */
+	if (hdmi->color_depth == HDMI_8_BIT)
+		tmds_clk = pixel_clk;
+	else if (hdmi->color_depth == HDMI_10_BIT)
+		tmds_clk = pixel_clk * 5 / 4; // *1.25
+	else if (hdmi->color_depth == HDMI_12_BIT)
+		tmds_clk = pixel_clk * 3 / 2; // *1.5
+	else if (hdmi->color_depth == HDMI_16_BIT)
+		tmds_clk = pixel_clk * 2; // *2
+	else {
+		HDMI_PHY_LOG("%s, unknown color depth\n", __func__);
+		return -EINVAL;
+	}
+
+/* bias & impedance setting:
+ * 3G < data rate <= 6G: enable impedance 100ohm,
+ *      data channel bias 24mA, clock channel bias 20mA
+ * pixel clk >= HD,  74.175MHZ <= pixel clk <= 300MHZ:
+ *      enalbe impedance 100ohm
+ *      data channel 20mA, clock channel 16mA
+ * 27M =< pixel clk < 74.175: disable impedance
+ *      data channel & clock channel bias 10mA
+ */
+
+	/* 3G < data rate <= 6G, 300M < tmds rate <= 594M */
+	if ((tmds_clk > 300000000UL) && (tmds_clk <= 594000000UL)) {
+		data_channel_bias = 0x3c; //24mA
+		clk_channel_bias = 0x34;  //20mA
+		impedance_en = 0xf;
+		impedance = 0x36; //100ohm
+	} else if ((pixel_clk >= 74175000UL) && (pixel_clk <= 300000000UL)) {
+		data_channel_bias = 0x34; //20mA
+		clk_channel_bias = 0x2c;  //16mA
+		impedance_en = 0xf;
+		impedance = 0x36; //100ohm
+	} else if ((pixel_clk >= 27000000UL) && (pixel_clk < 74175000UL)) {
+		data_channel_bias = 0x14; //10mA
+		clk_channel_bias = 0x14; //10mA
+		impedance_en = 0x0;
+		impedance = 0x0;
+	} else {
+		HDMI_PHY_LOG("%s, CK out of range\n", __func__);
+		return -EINVAL;
+	}
+
+	/* bias */
+	mtk_hdmi_phy_mask(hdmi_phy, HDMI_1_CFG_1,
+		data_channel_bias << RG_HDMITX21_DRV_IBIAS_D0_SHIFT,
+		RG_HDMITX21_DRV_IBIAS_D0);
+	mtk_hdmi_phy_mask(hdmi_phy, HDMI_1_CFG_1,
+		data_channel_bias << RG_HDMITX21_DRV_IBIAS_D1_SHIFT,
+		RG_HDMITX21_DRV_IBIAS_D1);
+	mtk_hdmi_phy_mask(hdmi_phy, HDMI_1_CFG_1,
+		data_channel_bias << RG_HDMITX21_DRV_IBIAS_D2_SHIFT,
+		RG_HDMITX21_DRV_IBIAS_D2);
+	mtk_hdmi_phy_mask(hdmi_phy, HDMI_1_CFG_0,
+		clk_channel_bias << RG_HDMITX21_DRV_IBIAS_CLK_SHIFT,
+		RG_HDMITX21_DRV_IBIAS_CLK);
+
+	/* impedance */
+	mtk_hdmi_phy_mask(hdmi_phy, HDMI_1_CFG_0,
+		impedance_en << RG_HDMITX21_DRV_IMP_EN_SHIFT,
+		RG_HDMITX21_DRV_IMP_EN);
+	mtk_hdmi_phy_mask(hdmi_phy, HDMI_1_CFG_2,
+		impedance << RG_HDMITX21_DRV_IMP_D0_EN1_SHIFT,
+		RG_HDMITX21_DRV_IMP_D0_EN1);
+	mtk_hdmi_phy_mask(hdmi_phy, HDMI_1_CFG_2,
+		impedance << RG_HDMITX21_DRV_IMP_D1_EN1_SHIFT,
+		RG_HDMITX21_DRV_IMP_D1_EN1);
+	mtk_hdmi_phy_mask(hdmi_phy, HDMI_1_CFG_2,
+		impedance << RG_HDMITX21_DRV_IMP_D2_EN1_SHIFT,
+		RG_HDMITX21_DRV_IMP_D2_EN1);
+	mtk_hdmi_phy_mask(hdmi_phy, HDMI_1_CFG_2,
+		impedance << RG_HDMITX21_DRV_IMP_CLK_EN1_SHIFT,
+		RG_HDMITX21_DRV_IMP_CLK_EN1);
+	//can.zeng todo, actually this impedance value need calibration
+
+	return 0;
+}
+
+static int mtk_hdmi_txpll_prepare(struct clk_hw *hw)
+{
+	struct mtk_hdmi_phy *hdmi_phy = to_mtk_hdmi_phy(hw);
+
+	dev_dbg(hdmi_phy->dev, "%s\n", __func__);
+
+	HDMI_PHY_LOG();
+
+	mtk_hdmi_phy_mask(hdmi_phy, HDMI_1_CFG_6,
+		0x1 << RG_HDMITX21_TX_POSDIV_EN_SHIFT,
+		RG_HDMITX21_TX_POSDIV_EN);
+
+	mtk_hdmi_phy_mask(hdmi_phy, HDMI_1_CFG_0,
+		0xf << RG_HDMITX21_SER_EN_SHIFT, RG_HDMITX21_SER_EN);
+	mtk_hdmi_phy_mask(hdmi_phy, HDMI_1_CFG_6,
+		0x1 << RG_HDMITX21_D0_DRV_OP_EN_SHIFT,
+		RG_HDMITX21_D0_DRV_OP_EN);
+	mtk_hdmi_phy_mask(hdmi_phy, HDMI_1_CFG_6,
+		0x1 << RG_HDMITX21_D1_DRV_OP_EN_SHIFT,
+		RG_HDMITX21_D1_DRV_OP_EN);
+	mtk_hdmi_phy_mask(hdmi_phy, HDMI_1_CFG_6,
+		0x1 << RG_HDMITX21_D2_DRV_OP_EN_SHIFT,
+		RG_HDMITX21_D2_DRV_OP_EN);
+	mtk_hdmi_phy_mask(hdmi_phy, HDMI_1_CFG_6,
+		0x1 << RG_HDMITX21_CK_DRV_OP_EN_SHIFT,
+		RG_HDMITX21_CK_DRV_OP_EN);
+
+	mtk_hdmi_phy_mask(hdmi_phy, HDMI_1_CFG_6,
+		0x0 << RG_HDMITX21_FRL_D0_EN_SHIFT, RG_HDMITX21_FRL_D0_EN);
+	mtk_hdmi_phy_mask(hdmi_phy, HDMI_1_CFG_6,
+		0x0 << RG_HDMITX21_FRL_D1_EN_SHIFT, RG_HDMITX21_FRL_D1_EN);
+	mtk_hdmi_phy_mask(hdmi_phy, HDMI_1_CFG_6,
+		0x0 << RG_HDMITX21_FRL_D2_EN_SHIFT, RG_HDMITX21_FRL_D2_EN);
+	mtk_hdmi_phy_mask(hdmi_phy, HDMI_1_CFG_6,
+		0x0 << RG_HDMITX21_FRL_CK_EN_SHIFT, RG_HDMITX21_FRL_CK_EN);
+
+	mtk_hdmi_txpll_drv_setting(hw);
+
+	mtk_hdmi_phy_mask(hdmi_phy, HDMI_1_CFG_10,
+		0x0 << RG_HDMITX21_BG_PWD_SHIFT, RG_HDMITX21_BG_PWD);
+	mtk_hdmi_phy_mask(hdmi_phy, HDMI_1_CFG_6,
+		0x1 << RG_HDMITX21_BIAS_EN_SHIFT, RG_HDMITX21_BIAS_EN);
+	mtk_hdmi_phy_mask(hdmi_phy, HDMI_1_CFG_3,
+		0x1 << RG_HDMITX21_CKLDO_EN_SHIFT, RG_HDMITX21_CKLDO_EN);
+	mtk_hdmi_phy_mask(hdmi_phy, HDMI_1_CFG_3,
+		0xf << RG_HDMITX21_SLDO_EN_SHIFT, RG_HDMITX21_SLDO_EN);
+
+	mtk_hdmi_phy_mask(hdmi_phy, HDMI_1_PLL_CFG_4,
+		0x1 << DA_HDMITXPLL_PWR_ON_SHIFT, DA_HDMITXPLL_PWR_ON);
+	udelay(5);
+	mtk_hdmi_phy_mask(hdmi_phy, HDMI_1_PLL_CFG_4,
+		0x0 << DA_HDMITXPLL_ISO_EN_SHIFT, DA_HDMITXPLL_ISO_EN);
+	udelay(5);
+	mtk_hdmi_phy_mask(hdmi_phy, HDMI_1_PLL_CFG_2,
+		0x0 << RG_HDMITXPLL_PWD_SHIFT, RG_HDMITXPLL_PWD);
+	udelay(30);
+
+	return 0;
+}
+
+static void mtk_hdmi_txpll_unprepare(struct clk_hw *hw)
+{
+	struct mtk_hdmi_phy *hdmi_phy = to_mtk_hdmi_phy(hw);
+
+	dev_dbg(hdmi_phy->dev, "%s\n", __func__);
+	HDMI_PHY_LOG();
+
+	mtk_hdmi_phy_mask(hdmi_phy, HDMI_1_CFG_10,
+		0x1 << RG_HDMITX21_BG_PWD_SHIFT, RG_HDMITX21_BG_PWD);
+	mtk_hdmi_phy_mask(hdmi_phy, HDMI_1_CFG_6,
+		0x0 << RG_HDMITX21_BIAS_EN_SHIFT, RG_HDMITX21_BIAS_EN);
+	mtk_hdmi_phy_mask(hdmi_phy, HDMI_1_CFG_3,
+		0x0 << RG_HDMITX21_CKLDO_EN_SHIFT, RG_HDMITX21_CKLDO_EN);
+	mtk_hdmi_phy_mask(hdmi_phy, HDMI_1_CFG_3,
+		0x0 << RG_HDMITX21_SLDO_EN_SHIFT, RG_HDMITX21_SLDO_EN);
+
+	mtk_hdmi_phy_mask(hdmi_phy, HDMI_1_PLL_CFG_2,
+		0x1 << RG_HDMITXPLL_PWD_SHIFT, RG_HDMITXPLL_PWD);
+	udelay(10);
+	mtk_hdmi_phy_mask(hdmi_phy, HDMI_1_PLL_CFG_4,
+		0x1 << DA_HDMITXPLL_ISO_EN_SHIFT, DA_HDMITXPLL_ISO_EN);
+	udelay(10);
+	mtk_hdmi_phy_mask(hdmi_phy, HDMI_1_PLL_CFG_4,
+		0x0 << DA_HDMITXPLL_PWR_ON_SHIFT, DA_HDMITXPLL_PWR_ON);
+
+}
+
+
+//can.zeng todo verify the set_parent function.need to figure out the call trace
+/*static int mtk_hdmi_txpll_set_parent(struct clk_hw *hw, u8 index)
+ *{
+ *	return 0;
+ *}
+ */
+
+//can.zeng todo verify, how to detemine the return index
+/*static u8 mtk_hdmi_txpll_get_parent(struct clk_hw *hw)
+ *{
+ *	struct mtk_hdmi_phy *hdmi_phy = to_mtk_hdmi_phy(hw);
+ *
+ *	return hdmi_phy->clk_parent;
+ *}
+ */
+
+static int mtk_hdmi_txpll_set_rate(struct clk_hw *hw, unsigned long rate,
+				 unsigned long parent_rate)
+{
+	struct mtk_hdmi_phy *hdmi_phy = to_mtk_hdmi_phy(hw);
+	int ret;
+
+	HDMI_PHY_LOG();
+
+	dev_dbg(hdmi_phy->dev, "%s: %lu Hz, parent: %lu Hz\n", __func__,
+		rate, parent_rate);
+
+	ret = mtk_hdmi_txpll_calculate_params(hw, rate, parent_rate);
+	if (ret != 0) {
+		HDMI_PHY_LOG("error!!\n");
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static long mtk_hdmi_txpll_round_rate(struct clk_hw *hw, unsigned long rate,
+				    unsigned long *parent_rate)
+{
+/* workaround patch: when clk_set_rate(clk, req_rate) is called, if the req_rate
+ * is the same as last, CCF core won't call ops.set_rate because ops.round_rate
+ * return the new req_rate's round == last clk_core.rate. Always return 1 in
+ * this function to make context that new req_rate's round rate never equal last
+ * clk_core.rate, so the ops.set_rate can be called in every clk_set_rate.
+ */
+
+/*
+ *	struct mtk_hdmi_phy *hdmi_phy = to_mtk_hdmi_phy(hw);
+ *
+ *	hdmi_phy->txpll_rate = rate;
+ *	return rate;
+ */
+	return 1;
+}
+
+static unsigned long mtk_hdmi_txpll_recalc_rate(struct clk_hw *hw,
+					      unsigned long parent_rate)
+{
+	struct mtk_hdmi_phy *hdmi_phy = to_mtk_hdmi_phy(hw);
+
+	return hdmi_phy->txpll_rate;
+}
+
+static const struct clk_ops mtk_hdmi_txpll_ops = {
+	.prepare = mtk_hdmi_txpll_prepare,
+	.unprepare = mtk_hdmi_txpll_unprepare,
+/*	.set_parent = mtk_hdmi_txpll_set_parent,
+ *	.get_parent = mtk_hdmi_txpll_get_parent,
+ */
+	.set_rate = mtk_hdmi_txpll_set_rate,
+	.round_rate = mtk_hdmi_txpll_round_rate,
+	.recalc_rate = mtk_hdmi_txpll_recalc_rate,
+};
+
+void vTxSignalOnOff(struct mtk_hdmi_phy *hdmi_phy, bool OnOff)
+{
+	if (OnOff) {
+		HDMI_PHY_LOG("HDMI Tx TMDS ON\n");
+
+		mtk_hdmi_phy_mask(hdmi_phy, HDMI_1_CFG_0,
+			RG_HDMITX21_DRV_EN, RG_HDMITX21_DRV_EN);
+	} else {
+		HDMI_PHY_LOG("HDMI Tx TMDS Off\n");
+
+		mtk_hdmi_phy_mask(hdmi_phy, HDMI_1_CFG_0,
+			0x0 << RG_HDMITX21_DRV_EN_SHIFT, RG_HDMITX21_DRV_EN);
+/*
+ *		mtk_hdmi_phy_mask(hdmi_phy, HDMI_1_CFG_6,
+ *			0x0 << RG_HDMITX21_TX_POSDIV_EN_SHIFT,
+ *			RG_HDMITX21_TX_POSDIV_EN);
+ *		mtk_hdmi_phy_mask(hdmi_phy, HDMI_1_CFG_6,
+ *			0x0 << RG_HDMITX21_FRL_EN_SHIFT,
+ *			RG_HDMITX21_FRL_EN);
+ *		mtk_hdmi_phy_mask(hdmi_phy, HDMI_1_CFG_0,
+ *			0x0 << RG_HDMITX21_SER_EN_SHIFT,
+ *			RG_HDMITX21_SER_EN);
+ *
+ *		mtk_hdmi_phy_mask(hdmi_phy, HDMI_1_CFG_6,
+ *			0x0 << RG_HDMITX21_D0_DRV_OP_EN_SHIFT,
+ *			RG_HDMITX21_D0_DRV_OP_EN);
+ *		mtk_hdmi_phy_mask(hdmi_phy, HDMI_1_CFG_6,
+ *			0x0 << RG_HDMITX21_D1_DRV_OP_EN_SHIFT,
+ *			RG_HDMITX21_D1_DRV_OP_EN);
+ *		mtk_hdmi_phy_mask(hdmi_phy, HDMI_1_CFG_6,
+ *			0x0 << RG_HDMITX21_D2_DRV_OP_EN_SHIFT,
+ *			RG_HDMITX21_D2_DRV_OP_EN);
+ *		mtk_hdmi_phy_mask(hdmi_phy, HDMI_1_CFG_6,
+ *			0x0 << RG_HDMITX21_CK_DRV_OP_EN_SHIFT,
+ *			RG_HDMITX21_CK_DRV_OP_EN);
+ *
+ *		mtk_hdmi_phy_mask(hdmi_phy, HDMI_1_CFG_6,
+ *			0x0 << RG_HDMITX21_FRL_D0_EN_SHIFT,
+ *			RG_HDMITX21_FRL_D0_EN);
+ *		mtk_hdmi_phy_mask(hdmi_phy, HDMI_1_CFG_6,
+ *			0x0 << RG_HDMITX21_FRL_D1_EN_SHIFT,
+ *			RG_HDMITX21_FRL_D1_EN);
+ *		mtk_hdmi_phy_mask(hdmi_phy, HDMI_1_CFG_6,
+ *			0x0 << RG_HDMITX21_FRL_D2_EN_SHIFT,
+ *			RG_HDMITX21_FRL_D2_EN);
+ *		mtk_hdmi_phy_mask(hdmi_phy, HDMI_1_CFG_6,
+ *			0x0 << RG_HDMITX21_FRL_CK_EN_SHIFT,
+ *			RG_HDMITX21_FRL_CK_EN);
+ *
+ *		mtk_hdmi_phy_mask(hdmi_phy, HDMI_1_CFG_1,
+ *			0x0 << RG_HDMITX21_DRV_IBIAS_D0_SHIFT,
+ *			RG_HDMITX21_DRV_IBIAS_D0);
+ *		mtk_hdmi_phy_mask(hdmi_phy, HDMI_1_CFG_1,
+ *			0x0 << RG_HDMITX21_DRV_IBIAS_D1_SHIFT,
+ *			RG_HDMITX21_DRV_IBIAS_D1);
+ *		mtk_hdmi_phy_mask(hdmi_phy, HDMI_1_CFG_1,
+ *			0x0 << RG_HDMITX21_DRV_IBIAS_D2_SHIFT,
+ *			RG_HDMITX21_DRV_IBIAS_D2);
+ *		mtk_hdmi_phy_mask(hdmi_phy, HDMI_1_CFG_0,
+ *			0x0 << RG_HDMITX21_DRV_IBIAS_CLK_SHIFT,
+ *			RG_HDMITX21_DRV_IBIAS_CLK);
+ *
+ *		mtk_hdmi_phy_mask(hdmi_phy, HDMI_1_CFG_0,
+ *			0x0 << RG_HDMITX21_DRV_IMP_EN_SHIFT,
+ *			RG_HDMITX21_DRV_IMP_EN);
+ *		mtk_hdmi_phy_mask(hdmi_phy, HDMI_1_CFG_2,
+ *			0x0 << RG_HDMITX21_DRV_IMP_D0_EN1_SHIFT,
+ *			RG_HDMITX21_DRV_IMP_D0_EN1);
+ *		mtk_hdmi_phy_mask(hdmi_phy, HDMI_1_CFG_2,
+ *			0x0 << RG_HDMITX21_DRV_IMP_D1_EN1_SHIFT,
+ *			RG_HDMITX21_DRV_IMP_D1_EN1);
+ *		mtk_hdmi_phy_mask(hdmi_phy, HDMI_1_CFG_2,
+ *			0x0 << RG_HDMITX21_DRV_IMP_D2_EN1_SHIFT,
+ *			RG_HDMITX21_DRV_IMP_D2_EN1);
+ *		mtk_hdmi_phy_mask(hdmi_phy, HDMI_1_CFG_2,
+ *			0x0 << RG_HDMITX21_DRV_IMP_CLK_EN1_SHIFT,
+ *			RG_HDMITX21_DRV_IMP_CLK_EN1);
+ */
+		HDMI_PHY_LOG("vTxSignalOff = %lums\n", jiffies);
+	}
+
+}
+
+static void mtk_hdmi_phy_enable_tmds(struct mtk_hdmi_phy *hdmi_phy)
+{
+	HDMI_PHY_FUNC();
+
+	vTxSignalOnOff(hdmi_phy, true);
+	usleep_range(100, 150);
+}
+
+static void mtk_hdmi_phy_disable_tmds(struct mtk_hdmi_phy *hdmi_phy)
+{
+	HDMI_PHY_FUNC();
+
+	vTxSignalOnOff(hdmi_phy, false);
+}
+
+static int mtk_hdmi_phy_power_on(struct phy *phy)
+{
+	struct mtk_hdmi_phy *hdmi_phy = phy_get_drvdata(phy);
+	int ret;
+
+	HDMI_PHY_FUNC();
+
+	if (__clk_is_enabled(hdmi_phy->txpll) == false) {
+		ret = clk_prepare_enable(hdmi_phy->txpll);
+		if (ret < 0)
+			return ret;
+	}
+	udelay(10);
+	mtk_hdmi_phy_enable_tmds(hdmi_phy);
+
+	return 0;
+}
+
+static int mtk_hdmi_phy_power_off(struct phy *phy)
+{
+	struct mtk_hdmi_phy *hdmi_phy = phy_get_drvdata(phy);
+
+	HDMI_PHY_FUNC();
+
+	mtk_hdmi_phy_disable_tmds(hdmi_phy);
+	udelay(10);
+	if (__clk_is_enabled(hdmi_phy->txpll) == true)
+		clk_disable_unprepare(hdmi_phy->txpll);
+
+	return 0;
+}
+
+static const struct phy_ops mtk_hdmi_phy_ops = {
+	.power_on = mtk_hdmi_phy_power_on,
+	.power_off = mtk_hdmi_phy_power_off,
+	.owner = THIS_MODULE,
+};
+
+static int mtk_hdmi_phy_get_all_clk(
+	struct mtk_hdmi_phy *hdmi_phy, struct device *dev)
+{
+	int i, ret;
+	/*	int i;
+	 *	struct clk *txpll_clk_parents[TXPLL_CLK_PARENT_COUNT];
+	 *	const char *txpll_parent_names[TXPLL_CLK_PARENT_COUNT];
+	 *	struct clk_init_data clk_init = {
+	 *		.ops = &mtk_hdmi_txpll_ops,
+	 *		.num_parents = TXPLL_CLK_PARENT_COUNT,
+	 *		.parent_names = (const char * const *)txpll_parent_names,
+	 *		.flags = CLK_SET_RATE_PARENT | CLK_SET_RATE_GATE,
+	 *	};
+	 */
+	const char *ref_clk_name;
+	struct clk_init_data clk_init = {
+		.ops = &mtk_hdmi_txpll_ops,
+		.num_parents = 1,
+		.parent_names = (const char * const *)&ref_clk_name,
+		.flags = CLK_SET_RATE_PARENT | CLK_SET_RATE_GATE,
+	};
+
+	for (i = 0; i < ARRAY_SIZE(mtk_hdmi_phy_clk_names); i++) {
+		hdmi_phy->clk[i] = of_clk_get_by_name(dev->of_node,
+			mtk_hdmi_phy_clk_names[i]);
+
+		if (IS_ERR(hdmi_phy->clk[i]))
+			return PTR_ERR(hdmi_phy->clk[i]);
+	}
+
+	/* specify clock parent 26M for bring up */
+	hdmi_phy->clk_parent = XTAL26M;
+
+	ref_clk_name = __clk_get_name(hdmi_phy->clk[MTK_HDMI_PHY_XTAL_SEL]);
+
+/*acquire txpll 3 clk parent, can.zeng todo verify
+ *	for (i = PLLGP1_PLLGP_2H_PLL2; i < TXPLL_CLK_PARENT_COUNT; i++) {
+ *		txpll_clk_parents[i] =
+ *			devm_clk_get(dev, txpll_parent_dts_names[i]);
+ *		if (IS_ERR(txpll_clk_parents[i])) {
+ *			ret = PTR_ERR(txpll_clk_parents[i]);
+ *			HDMI_PHY_LOG("Fail to get the %dst ref clk\n", i);
+ *
+ *			return ret;
+ *		}
+ *		txpll_parent_names[i] = __clk_get_name(txpll_clk_parents[i]);
+ *	}
+ *acquire txpll 3 clk parent, can.zeng todo verify
+ */
+
+	ret = of_property_read_string(dev->of_node, "clock-output-names",
+					  &clk_init.name);
+	if (ret < 0) {
+		HDMI_PHY_LOG("Failed to read clock-output-names: %d\n", ret);
+		return ret;
+	}
+
+	hdmi_phy->txpll_hw.init = &clk_init;
+	hdmi_phy->txpll = devm_clk_register(dev, &hdmi_phy->txpll_hw);
+	if (IS_ERR(hdmi_phy->txpll)) {
+		ret = PTR_ERR(hdmi_phy->txpll);
+		HDMI_PHY_LOG("Failed to register PLL: %d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+
+struct mtk_hdmi_phy *global_hdmi_phy;
+
+static int mtk_hdmi_phy_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct mtk_hdmi_phy *hdmi_phy;
+	struct resource *mem;
+	struct phy *phy;
+	struct phy_provider *phy_provider;
+	int ret;
+
+	HDMI_PHY_LOG("probe start\n");
+
+	hdmi_phy = devm_kzalloc(dev, sizeof(*hdmi_phy), GFP_KERNEL);
+	if (!hdmi_phy)
+		return -ENOMEM;
+
+	global_hdmi_phy = hdmi_phy;
+
+	ret = mtk_hdmi_phy_get_all_clk(hdmi_phy, dev);
+	if (ret) {
+		HDMI_PHY_LOG("Failed to get clocks: %d\n", ret);
+		return ret;
+	}
+
+	mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	hdmi_phy->regs = devm_ioremap_resource(dev, mem);
+	if (IS_ERR(hdmi_phy->regs)) {
+		ret = PTR_ERR(hdmi_phy->regs);
+		HDMI_PHY_LOG("Failed to get memory resource: %d\n", ret);
+		return ret;
+	}
+
+	/* min & max tmds frequency range:
+	 * HDMI protocal specify tmds clock must above 25M,
+	 * mt8195 tmds top limit is 594M
+	 */
+	hdmi_phy->min_tmds_clock = 25000000; //25M
+	hdmi_phy->max_tmds_clock = 594000000; //594M
+
+	phy = devm_phy_create(dev, NULL, &mtk_hdmi_phy_ops);
+	if (IS_ERR(phy)) {
+		HDMI_PHY_LOG("Failed to create HDMI PHY\n");
+		return PTR_ERR(phy);
+	}
+	phy_set_drvdata(phy, hdmi_phy);
+
+	phy_provider = devm_of_phy_provider_register(dev, of_phy_simple_xlate);
+	if (IS_ERR(phy_provider))
+		return PTR_ERR(phy_provider);
+
+	hdmi_phy->dev = dev;
+
+	HDMI_PHY_LOG("probe end\n");
+
+	return of_clk_add_provider(dev->of_node, of_clk_src_simple_get,
+				   hdmi_phy->txpll);
+}
+
+static int mtk_hdmi_phy_remove(struct platform_device *pdev)
+{
+	return 0;
+}
+
+static const struct of_device_id mtk_hdmi_phy_match[] = {
+	{ .compatible = "mediatek,mt8195-hdmi-phy", },
+	{},
+};
+
+struct platform_driver mtk_hdmi_phy_driver = {
+	.probe = mtk_hdmi_phy_probe,
+	.remove = mtk_hdmi_phy_remove,
+	.driver = {
+		.name = "mediatek-hdmi-phy",
+		.of_match_table = mtk_hdmi_phy_match,
+	},
+};
+
+MODULE_AUTHOR("Can Zeng <can.zeng@mediatek.com>");
+MODULE_DESCRIPTION("MediaTek MT8195 HDMI PHY Driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/gpu/drm/mediatek/mtk_disp_aal.c b/drivers/gpu/drm/mediatek/mtk_disp_aal.c
index f46d4ab73d6a681feb200a066daa93339fae09b4..dadd1afed0764a134bf43c77f68665c50d276250 100644
--- a/drivers/gpu/drm/mediatek/mtk_disp_aal.c
+++ b/drivers/gpu/drm/mediatek/mtk_disp_aal.c
@@ -20,7 +20,6 @@
 #define DISP_AAL_SIZE				0x0030
 #define DISP_AAL_OUTPUT_SIZE			0x04d8
 
-
 struct mtk_disp_aal_data {
 	bool has_gamma;
 };
diff --git a/drivers/gpu/drm/mediatek/mtk_disp_ccorr.c b/drivers/gpu/drm/mediatek/mtk_disp_ccorr.c
index 141cb36b9c07b7407cc3e907f08ed2e96a66d2ce..f8e7ee221d688e5d0afb6d0e09b974b764969b57 100644
--- a/drivers/gpu/drm/mediatek/mtk_disp_ccorr.c
+++ b/drivers/gpu/drm/mediatek/mtk_disp_ccorr.c
@@ -205,9 +205,15 @@ static const struct mtk_disp_ccorr_data mt8183_ccorr_driver_data = {
 	.matrix_bits = 10,
 };
 
+static const struct mtk_disp_ccorr_data mt8195_ccorr_driver_data = {
+	.matrix_bits = 11,
+};
+
 static const struct of_device_id mtk_disp_ccorr_driver_dt_match[] = {
 	{ .compatible = "mediatek,mt8183-disp-ccorr",
 	  .data = &mt8183_ccorr_driver_data},
+	{ .compatible = "mediatek,mt8195-disp-ccorr",
+	  .data = &mt8195_ccorr_driver_data},
 	{},
 };
 MODULE_DEVICE_TABLE(of, mtk_disp_ccorr_driver_dt_match);
diff --git a/drivers/gpu/drm/mediatek/mtk_disp_color.c b/drivers/gpu/drm/mediatek/mtk_disp_color.c
index 6f4c80bbc0eb6730cc50453e4f672fb3a7a83bf1..473f5bb5cbadce716fb3590dcaaa24c47ebca0db 100644
--- a/drivers/gpu/drm/mediatek/mtk_disp_color.c
+++ b/drivers/gpu/drm/mediatek/mtk_disp_color.c
@@ -133,6 +133,8 @@ static int mtk_disp_color_probe(struct platform_device *pdev)
 
 static int mtk_disp_color_remove(struct platform_device *pdev)
 {
+	component_del(&pdev->dev, &mtk_disp_color_component_ops);
+
 	return 0;
 }
 
diff --git a/drivers/gpu/drm/mediatek/mtk_disp_drv.h b/drivers/gpu/drm/mediatek/mtk_disp_drv.h
index 86c3068894b11645395af60b77301366fc54f5e3..93ca91812514a27f0bbe56c479ec8a3253bbec85 100644
--- a/drivers/gpu/drm/mediatek/mtk_disp_drv.h
+++ b/drivers/gpu/drm/mediatek/mtk_disp_drv.h
@@ -8,6 +8,7 @@
 
 #include <linux/soc/mediatek/mtk-cmdq.h>
 #include "mtk_drm_plane.h"
+#include "mtk_mdp_rdma.h"
 
 int mtk_aal_clk_enable(struct device *dev);
 void mtk_aal_clk_disable(struct device *dev);
@@ -41,6 +42,11 @@ void mtk_dither_set_common(void __iomem *regs, struct cmdq_client_reg *cmdq_reg,
 
 void mtk_dpi_start(struct device *dev);
 void mtk_dpi_stop(struct device *dev);
+int mtk_dpi_encoder_index(struct device *dev);
+
+void mtk_dpintf_start(struct device *dev);
+void mtk_dpintf_stop(struct device *dev);
+int mtk_dpintf_encoder_index(struct device *dev);
 
 void mtk_dsi_ddp_start(struct device *dev);
 void mtk_dsi_ddp_stop(struct device *dev);
@@ -55,6 +61,20 @@ void mtk_gamma_set_common(void __iomem *regs, struct drm_crtc_state *state);
 void mtk_gamma_start(struct device *dev);
 void mtk_gamma_stop(struct device *dev);
 
+int mtk_merge_clk_enable(struct device *dev);
+void mtk_merge_clk_disable(struct device *dev);
+void mtk_merge_config(struct device *dev, unsigned int width,
+		      unsigned int height, unsigned int vrefresh,
+		      unsigned int bpc, struct cmdq_pkt *cmdq_pkt);
+void mtk_merge_start(struct device *dev);
+void mtk_merge_stop(struct device *dev);
+void mtk_merge_advance_config(struct device *dev, unsigned int l_w, unsigned int r_w,
+			      unsigned int h, unsigned int vrefresh, unsigned int bpc,
+			      struct cmdq_pkt *cmdq_pkt);
+void mtk_merge_unmute(struct device *dev, struct cmdq_pkt *cmdq_pkt);
+void mtk_merge_enable(struct device *dev, struct cmdq_pkt *cmdq_pkt);
+void mtk_merge_disable(struct device *dev, struct cmdq_pkt *cmdq_pkt);
+
 void mtk_ovl_bgclr_in_on(struct device *dev);
 void mtk_ovl_bgclr_in_off(struct device *dev);
 void mtk_ovl_bypass_shadow(struct device *dev);
@@ -98,4 +118,27 @@ void mtk_rdma_enable_vblank(struct device *dev,
 			    void *vblank_cb_data);
 void mtk_rdma_disable_vblank(struct device *dev);
 
+int mtk_ovl_adaptor_clk_enable(struct device *dev);
+void mtk_ovl_adaptor_clk_disable(struct device *dev);
+void mtk_ovl_adaptor_config(struct device *dev, unsigned int w,
+			    unsigned int h, unsigned int vrefresh,
+			    unsigned int bpc, struct cmdq_pkt *cmdq_pkt);
+void mtk_ovl_adaptor_layer_config(struct device *dev, unsigned int idx,
+				  struct mtk_plane_state *state,
+				  struct cmdq_pkt *cmdq_pkt);
+void mtk_ovl_adaptor_enable_vblank(struct device *dev,
+				   void (*vblank_cb)(void *),
+				   void *vblank_cb_data);
+void mtk_ovl_adaptor_disable_vblank(struct device *dev);
+void mtk_ovl_adaptor_start(struct device *dev);
+void mtk_ovl_adaptor_stop(struct device *dev);
+unsigned int mtk_ovl_adaptor_layer_nr(struct device *dev);
+
+int mtk_mdp_rdma_clk_enable(struct device *dev);
+void mtk_mdp_rdma_clk_disable(struct device *dev);
+void mtk_mdp_rdma_start(struct device *dev, struct cmdq_pkt *cmdq_pkt);
+void mtk_mdp_rdma_stop(struct device *dev, struct cmdq_pkt *cmdq_pkt);
+void mtk_mdp_rdma_config(struct device *dev, struct mtk_mdp_rdma_cfg *cfg,
+			 struct cmdq_pkt *cmdq_pkt);
+
 #endif
diff --git a/drivers/gpu/drm/mediatek/mtk_disp_merge.c b/drivers/gpu/drm/mediatek/mtk_disp_merge.c
new file mode 100644
index 0000000000000000000000000000000000000000..13c788f67cedb1000da30bf45108fa3e972d720a
--- /dev/null
+++ b/drivers/gpu/drm/mediatek/mtk_disp_merge.c
@@ -0,0 +1,297 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2021 MediaTek Inc.
+ */
+
+#include <linux/clk.h>
+#include <linux/component.h>
+#include <linux/of_device.h>
+#include <linux/of_irq.h>
+#include <linux/platform_device.h>
+#include <linux/reset.h>
+#include <linux/soc/mediatek/mtk-cmdq.h>
+
+#include "mtk_drm_ddp_comp.h"
+#include "mtk_drm_drv.h"
+#include "mtk_disp_drv.h"
+
+#define DISP_REG_MERGE_CTRL		0x000
+#define MERGE_EN				1
+#define DISP_REG_MERGE_CFG_0		0x010
+#define DISP_REG_MERGE_CFG_1		0x014
+#define DISP_REG_MERGE_CFG_4		0x020
+#define DISP_REG_MERGE_CFG_10		0x038
+/* no swap */
+#define SWAP_MODE				0
+#define FLD_SWAP_MODE				GENMASK(4, 0)
+#define DISP_REG_MERGE_CFG_12		0x040
+#define CFG_10_10_1PI_2PO_BUF_MODE		6
+#define CFG_10_10_2PI_2PO_BUF_MODE		8
+#define CFG_11_10_1PI_2PO_MERGE			18
+#define FLD_CFG_MERGE_MODE			GENMASK(4, 0)
+#define DISP_REG_MERGE_CFG_24		0x070
+#define DISP_REG_MERGE_CFG_25		0x074
+#define DISP_REG_MERGE_CFG_26		0x078
+#define DISP_REG_MERGE_CFG_27		0x07c
+#define DISP_REG_MERGE_CFG_36		0x0a0
+#define ULTRA_EN				BIT(0)
+#define PREULTRA_EN				BIT(4)
+#define DISP_REG_MERGE_CFG_37		0x0a4
+/* 0: Off, 1: SRAM0, 2: SRAM1, 3: SRAM0 + SRAM1 */
+#define BUFFER_MODE				3
+#define FLD_BUFFER_MODE				GENMASK(1, 0)
+/*
+ * For the ultra and preultra settings, 6us ~ 9us is experience value
+ * and the maximum frequency of mmsys clock is 594MHz.
+ */
+#define DISP_REG_MERGE_CFG_40		0x0b0
+/* 6 us, 594M pixel/sec */
+#define ULTRA_TH_LOW				(6 * 594)
+/* 8 us, 594M pixel/sec */
+#define ULTRA_TH_HIGH				(8 * 594)
+#define FLD_ULTRA_TH_LOW			GENMASK(15, 0)
+#define FLD_ULTRA_TH_HIGH			GENMASK(31, 16)
+#define DISP_REG_MERGE_CFG_41		0x0b4
+/* 8 us, 594M pixel/sec */
+#define PREULTRA_TH_LOW				(8 * 594)
+/* 9 us, 594M pixel/sec */
+#define PREULTRA_TH_HIGH			(9 * 594)
+#define FLD_PREULTRA_TH_LOW			GENMASK(15, 0)
+#define FLD_PREULTRA_TH_HIGH			GENMASK(31, 16)
+
+#define DISP_REG_MERGE_MUTE_0		0xf00
+
+struct mtk_disp_merge {
+	void __iomem *regs;
+	struct clk *clk;
+	struct clk *async_clk;
+	struct cmdq_client_reg		cmdq_reg;
+	bool				fifo_en;
+	bool				mute_support;
+};
+
+void mtk_merge_start(struct device *dev)
+{
+	mtk_merge_enable(dev, NULL);
+}
+
+void mtk_merge_stop(struct device *dev)
+{
+	struct mtk_disp_merge *priv = dev_get_drvdata(dev);
+
+	mtk_merge_disable(dev, NULL);
+
+	if (priv->async_clk)
+		device_reset_optional(dev);
+}
+
+void mtk_merge_enable(struct device *dev, struct cmdq_pkt *cmdq_pkt)
+{
+	struct mtk_disp_merge *priv = dev_get_drvdata(dev);
+
+	mtk_ddp_write(cmdq_pkt, 1, &priv->cmdq_reg, priv->regs,
+		      DISP_REG_MERGE_CTRL);
+}
+
+void mtk_merge_disable(struct device *dev, struct cmdq_pkt *cmdq_pkt)
+{
+	struct mtk_disp_merge *priv = dev_get_drvdata(dev);
+
+	mtk_ddp_write(cmdq_pkt, 0, &priv->cmdq_reg, priv->regs,
+		      DISP_REG_MERGE_CTRL);
+}
+
+void mtk_merge_unmute(struct device *dev, struct cmdq_pkt *cmdq_pkt)
+{
+	struct mtk_disp_merge *priv = dev_get_drvdata(dev);
+
+	if (priv->mute_support)
+		mtk_ddp_write(cmdq_pkt, 0x0, &priv->cmdq_reg, priv->regs,
+			      DISP_REG_MERGE_MUTE_0);
+}
+
+static void mtk_merge_fifo_setting(struct mtk_disp_merge *priv,
+				   struct cmdq_pkt *cmdq_pkt)
+{
+	mtk_ddp_write(cmdq_pkt, ULTRA_EN | PREULTRA_EN,
+		      &priv->cmdq_reg, priv->regs, DISP_REG_MERGE_CFG_36);
+
+	mtk_ddp_write_mask(cmdq_pkt, BUFFER_MODE,
+			   &priv->cmdq_reg, priv->regs, DISP_REG_MERGE_CFG_37,
+			   FLD_BUFFER_MODE);
+
+	mtk_ddp_write_mask(cmdq_pkt, ULTRA_TH_LOW | ULTRA_TH_HIGH << 16,
+			   &priv->cmdq_reg, priv->regs, DISP_REG_MERGE_CFG_40,
+			   FLD_ULTRA_TH_LOW | FLD_ULTRA_TH_HIGH);
+
+	mtk_ddp_write_mask(cmdq_pkt, PREULTRA_TH_LOW | PREULTRA_TH_HIGH << 16,
+			   &priv->cmdq_reg, priv->regs, DISP_REG_MERGE_CFG_41,
+			   FLD_PREULTRA_TH_LOW | FLD_PREULTRA_TH_HIGH);
+}
+
+void mtk_merge_config(struct device *dev, unsigned int w,
+		      unsigned int h, unsigned int vrefresh,
+		      unsigned int bpc, struct cmdq_pkt *cmdq_pkt)
+{
+	mtk_merge_advance_config(dev, w, 0, h, vrefresh, bpc, cmdq_pkt);
+}
+
+void mtk_merge_advance_config(struct device *dev, unsigned int l_w, unsigned int r_w,
+			      unsigned int h, unsigned int vrefresh, unsigned int bpc,
+			      struct cmdq_pkt *cmdq_pkt)
+{
+	struct mtk_disp_merge *priv = dev_get_drvdata(dev);
+	unsigned int mode = CFG_10_10_1PI_2PO_BUF_MODE;
+
+	if (!h || !l_w) {
+		dev_err(dev, "%s: input width(%d) or height(%d) is invalid\n", __func__, l_w, h);
+		return;
+	}
+
+	if (priv->fifo_en) {
+		mtk_merge_fifo_setting(priv, cmdq_pkt);
+		mode = CFG_10_10_2PI_2PO_BUF_MODE;
+	}
+
+	if (r_w)
+		mode = CFG_11_10_1PI_2PO_MERGE;
+
+	mtk_ddp_write(cmdq_pkt, h << 16 | l_w, &priv->cmdq_reg, priv->regs,
+		      DISP_REG_MERGE_CFG_0);
+	mtk_ddp_write(cmdq_pkt, h << 16 | r_w, &priv->cmdq_reg, priv->regs,
+		      DISP_REG_MERGE_CFG_1);
+	mtk_ddp_write(cmdq_pkt, h << 16 | (l_w + r_w), &priv->cmdq_reg, priv->regs,
+		      DISP_REG_MERGE_CFG_4);
+	mtk_ddp_write(cmdq_pkt, h << 16 | l_w, &priv->cmdq_reg, priv->regs,
+		      DISP_REG_MERGE_CFG_24);
+	if (r_w)
+		mtk_ddp_write(cmdq_pkt, h << 16 | r_w, &priv->cmdq_reg, priv->regs,
+			      DISP_REG_MERGE_CFG_25);
+	else
+		mtk_ddp_write(cmdq_pkt, h << 16 | l_w, &priv->cmdq_reg, priv->regs,
+			      DISP_REG_MERGE_CFG_25);
+
+	mtk_ddp_write(cmdq_pkt, h << 16 | l_w, &priv->cmdq_reg, priv->regs,
+		      DISP_REG_MERGE_CFG_26);
+	mtk_ddp_write(cmdq_pkt, h << 16 | r_w, &priv->cmdq_reg, priv->regs,
+		      DISP_REG_MERGE_CFG_27);
+
+	mtk_ddp_write_mask(cmdq_pkt, SWAP_MODE, &priv->cmdq_reg, priv->regs,
+			   DISP_REG_MERGE_CFG_10, FLD_SWAP_MODE);
+	mtk_ddp_write_mask(cmdq_pkt, mode, &priv->cmdq_reg, priv->regs,
+			   DISP_REG_MERGE_CFG_12, FLD_CFG_MERGE_MODE);
+}
+
+int mtk_merge_clk_enable(struct device *dev)
+{
+	int ret = 0;
+	struct mtk_disp_merge *priv = dev_get_drvdata(dev);
+
+	ret = clk_prepare_enable(priv->clk);
+	if (ret)
+		pr_err("merge clk prepare enable failed\n");
+	ret = clk_prepare_enable(priv->async_clk);
+	if (ret)
+		pr_err("async clk prepare enable failed\n");
+
+	return ret;
+}
+
+void mtk_merge_clk_disable(struct device *dev)
+{
+	struct mtk_disp_merge *priv = dev_get_drvdata(dev);
+
+	clk_disable_unprepare(priv->async_clk);
+	clk_disable_unprepare(priv->clk);
+}
+
+static int mtk_disp_merge_bind(struct device *dev, struct device *master,
+			       void *data)
+{
+	return 0;
+}
+
+static void mtk_disp_merge_unbind(struct device *dev, struct device *master,
+				  void *data)
+{
+}
+
+static const struct component_ops mtk_disp_merge_component_ops = {
+	.bind	= mtk_disp_merge_bind,
+	.unbind = mtk_disp_merge_unbind,
+};
+
+static int mtk_disp_merge_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct resource *res;
+	struct mtk_disp_merge *priv;
+	int ret;
+
+	priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	priv->regs = devm_ioremap_resource(dev, res);
+	if (IS_ERR(priv->regs)) {
+		dev_err(dev, "failed to ioremap merge\n");
+		return PTR_ERR(priv->regs);
+	}
+
+	priv->clk = devm_clk_get(dev, NULL);
+	if (IS_ERR(priv->clk)) {
+		dev_err(dev, "failed to get merge clk\n");
+		return PTR_ERR(priv->clk);
+	}
+
+	priv->async_clk = of_clk_get(dev->of_node, 1);
+	if (IS_ERR(priv->async_clk)) {
+		ret = PTR_ERR(priv->async_clk);
+		dev_dbg(dev, "No merge async clock: %d\n", ret);
+		priv->async_clk = NULL;
+	}
+
+#if IS_REACHABLE(CONFIG_MTK_CMDQ)
+	ret = cmdq_dev_get_client_reg(dev, &priv->cmdq_reg, 0);
+	if (ret)
+		dev_dbg(dev, "get mediatek,gce-client-reg fail!\n");
+#endif
+
+	priv->fifo_en = of_property_read_bool(dev->of_node,
+					      "mediatek,merge-fifo-en");
+
+	priv->mute_support = of_property_read_bool(dev->of_node,
+						   "mediatek,merge-mute");
+	platform_set_drvdata(pdev, priv);
+
+	ret = component_add(dev, &mtk_disp_merge_component_ops);
+	if (ret != 0)
+		dev_err(dev, "Failed to add component: %d\n", ret);
+
+	return ret;
+}
+
+static int mtk_disp_merge_remove(struct platform_device *pdev)
+{
+	component_del(&pdev->dev, &mtk_disp_merge_component_ops);
+
+	return 0;
+}
+
+static const struct of_device_id mtk_disp_merge_driver_dt_match[] = {
+	{ .compatible = "mediatek,mt8195-disp-merge", },
+	{},
+};
+
+MODULE_DEVICE_TABLE(of, mtk_disp_merge_driver_dt_match);
+
+struct platform_driver mtk_disp_merge_driver = {
+	.probe = mtk_disp_merge_probe,
+	.remove = mtk_disp_merge_remove,
+	.driver = {
+		.name = "mediatek-disp-merge",
+		.owner = THIS_MODULE,
+		.of_match_table = mtk_disp_merge_driver_dt_match,
+	},
+};
diff --git a/drivers/gpu/drm/mediatek/mtk_disp_ovl.c b/drivers/gpu/drm/mediatek/mtk_disp_ovl.c
index ea5760f856ec6d0c085326de4e97f719306ac05d..3c8da4df5b07ce73a4b9fd98948b592016a4012e 100644
--- a/drivers/gpu/drm/mediatek/mtk_disp_ovl.c
+++ b/drivers/gpu/drm/mediatek/mtk_disp_ovl.c
@@ -27,6 +27,11 @@
 #define DISP_REG_OVL_DATAPATH_CON		0x0024
 #define OVL_LAYER_SMI_ID_EN				BIT(0)
 #define OVL_BGCLR_SEL_IN				BIT(2)
+#define OVL_GCLAST_EN					BIT(24)
+#define OVL_HDR_GCLAST_EN				BIT(25)
+#define OVL_OUTPUT_CLAMP				BIT(26)
+#define OVL_DATAPATH_CON				(OVL_LAYER_SMI_ID_EN | \
+					OVL_GCLAST_EN | OVL_HDR_GCLAST_EN | OVL_OUTPUT_CLAMP)
 #define DISP_REG_OVL_ROI_BGCLR			0x0028
 #define DISP_REG_OVL_SRC_CON			0x002c
 #define DISP_REG_OVL_CON(n)			(0x0030 + 0x20 * (n))
@@ -238,6 +243,10 @@ void mtk_ovl_layer_on(struct device *dev, unsigned int idx,
 			    gmc_thrshd_h << 16 | gmc_thrshd_h << 24;
 	mtk_ddp_write(cmdq_pkt, gmc_value,
 		      &ovl->cmdq_reg, ovl->regs, DISP_REG_OVL_RDMA_GMC(idx));
+
+	mtk_ddp_write_mask(cmdq_pkt, OVL_DATAPATH_CON, &ovl->cmdq_reg, ovl->regs,
+				 DISP_REG_OVL_DATAPATH_CON, OVL_DATAPATH_CON);
+
 	mtk_ddp_write_mask(cmdq_pkt, BIT(idx), &ovl->cmdq_reg, ovl->regs,
 			   DISP_REG_OVL_SRC_CON, BIT(idx));
 }
@@ -430,6 +439,8 @@ static int mtk_disp_ovl_remove(struct platform_device *pdev)
 {
 	pm_runtime_disable(&pdev->dev);
 
+	component_del(&pdev->dev, &mtk_disp_ovl_component_ops);
+
 	return 0;
 }
 
diff --git a/drivers/gpu/drm/mediatek/mtk_disp_ovl_adaptor.c b/drivers/gpu/drm/mediatek/mtk_disp_ovl_adaptor.c
new file mode 100644
index 0000000000000000000000000000000000000000..0cca29399da2c73a0ac844426b7d86507d71fc6c
--- /dev/null
+++ b/drivers/gpu/drm/mediatek/mtk_disp_ovl_adaptor.c
@@ -0,0 +1,403 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Copyright (c) 2021 MediaTek Inc.
+ */
+
+#include <drm/drm_fourcc.h>
+#include <linux/clk.h>
+#include <linux/component.h>
+#include <linux/of_device.h>
+#include <linux/of_address.h>
+#include <linux/platform_device.h>
+#include <linux/pm_runtime.h>
+#include <linux/reset.h>
+#include <linux/soc/mediatek/mtk-mmsys.h>
+#include <linux/soc/mediatek/mtk-cmdq.h>
+
+#include "mtk_drm_drv.h"
+#include "mtk_drm_crtc.h"
+#include "mtk_drm_ddp_comp.h"
+#include "mtk_disp_drv.h"
+#include "mtk_ethdr.h"
+
+#define MTK_OVL_ADAPTOR_RDMA_MAX_WIDTH 1920
+#define MTK_OVL_ADAPTOR_LAYER_NUM 4
+
+enum mtk_ovl_adaptor_comp_type {
+	OVL_ADAPTOR_TYPE_RDMA = 0,
+	OVL_ADAPTOR_TYPE_MERGE,
+	OVL_ADAPTOR_TYPE_NUM,
+};
+
+enum mtk_ovl_adaptor_comp_id {
+	OVL_ADAPTOR_MDP_RDMA0,
+	OVL_ADAPTOR_MDP_RDMA1,
+	OVL_ADAPTOR_MDP_RDMA2,
+	OVL_ADAPTOR_MDP_RDMA3,
+	OVL_ADAPTOR_MDP_RDMA4,
+	OVL_ADAPTOR_MDP_RDMA5,
+	OVL_ADAPTOR_MDP_RDMA6,
+	OVL_ADAPTOR_MDP_RDMA7,
+	OVL_ADAPTOR_MERGE0,
+	OVL_ADAPTOR_MERGE1,
+	OVL_ADAPTOR_MERGE2,
+	OVL_ADAPTOR_MERGE3,
+	OVL_ADAPTOR_ID_MAX
+};
+
+struct ovl_adaptor_comp_match {
+	enum mtk_ovl_adaptor_comp_type type;
+	int alias_id;
+};
+
+struct mtk_disp_ovl_adaptor {
+	struct device *ovl_adaptor_comp[OVL_ADAPTOR_ID_MAX];
+	struct device *mmsys_dev;
+};
+
+static const char * const ovl_adaptor_comp_str[] = {
+	"OVL_ADAPTOR_MDP_RDMA0",
+	"OVL_ADAPTOR_MDP_RDMA1",
+	"OVL_ADAPTOR_MDP_RDMA2",
+	"OVL_ADAPTOR_MDP_RDMA3",
+	"OVL_ADAPTOR_MDP_RDMA4",
+	"OVL_ADAPTOR_MDP_RDMA5",
+	"OVL_ADAPTOR_MDP_RDMA6",
+	"OVL_ADAPTOR_MDP_RDMA7",
+	"OVL_ADAPTOR_MERGE0",
+	"OVL_ADAPTOR_MERGE1",
+	"OVL_ADAPTOR_MERGE2",
+	"OVL_ADAPTOR_MERGE3",
+	"OVL_ADAPTOR_ID_MAX"
+};
+
+static const char * const private_comp_stem[OVL_ADAPTOR_TYPE_NUM] = {
+	[OVL_ADAPTOR_TYPE_RDMA] = "vdo1_rdma",
+	[OVL_ADAPTOR_TYPE_MERGE] = "merge",
+};
+
+static const struct ovl_adaptor_comp_match comp_matches[OVL_ADAPTOR_ID_MAX] = {
+	[OVL_ADAPTOR_MDP_RDMA0] =	{ OVL_ADAPTOR_TYPE_RDMA, 0 },
+	[OVL_ADAPTOR_MDP_RDMA1] =	{ OVL_ADAPTOR_TYPE_RDMA, 1 },
+	[OVL_ADAPTOR_MDP_RDMA2] =	{ OVL_ADAPTOR_TYPE_RDMA, 2 },
+	[OVL_ADAPTOR_MDP_RDMA3] =	{ OVL_ADAPTOR_TYPE_RDMA, 3 },
+	[OVL_ADAPTOR_MDP_RDMA4] =	{ OVL_ADAPTOR_TYPE_RDMA, 4 },
+	[OVL_ADAPTOR_MDP_RDMA5] =	{ OVL_ADAPTOR_TYPE_RDMA, 5 },
+	[OVL_ADAPTOR_MDP_RDMA6] =	{ OVL_ADAPTOR_TYPE_RDMA, 6 },
+	[OVL_ADAPTOR_MDP_RDMA7] =	{ OVL_ADAPTOR_TYPE_RDMA, 7 },
+	[OVL_ADAPTOR_MERGE0] =	{ OVL_ADAPTOR_TYPE_MERGE, 1 },
+	[OVL_ADAPTOR_MERGE1] =	{ OVL_ADAPTOR_TYPE_MERGE, 2 },
+	[OVL_ADAPTOR_MERGE2] =	{ OVL_ADAPTOR_TYPE_MERGE, 3 },
+	[OVL_ADAPTOR_MERGE3] =	{ OVL_ADAPTOR_TYPE_MERGE, 4 },
+};
+
+static struct device *get_ovl_adaptor(struct device *parent)
+{
+	return device_find_child_by_name(parent, "mediatek-disp-ovl-adaptor");
+}
+
+void mtk_ovl_adaptor_layer_config(struct device *dev, unsigned int idx,
+				  struct mtk_plane_state *state,
+				  struct cmdq_pkt *cmdq_pkt)
+{
+	struct device *ovl_adaptor_dev = get_ovl_adaptor(dev);
+	struct mtk_disp_ovl_adaptor *ovl_adaptor = dev_get_drvdata(ovl_adaptor_dev);
+	struct mtk_plane_pending_state *pending = &state->pending;
+	struct mtk_mdp_rdma_cfg rdma_config = {0};
+	struct device *rdma_l;
+	struct device *rdma_r;
+	struct device *merge;
+	const struct drm_format_info *fmt_info = drm_format_info(pending->format);
+	bool use_dual_pipe = false;
+	unsigned int l_w = 0;
+	unsigned int r_w = 0;
+
+	dev_dbg(dev, "%s+ idx:%d, enable:%d, fmt:0x%x\n", __func__, idx,
+		pending->enable, pending->format);
+	dev_dbg(dev, "addr 0x%lx, fb w:%d, {%d,%d,%d,%d}\n",
+		pending->addr, (pending->pitch / fmt_info->cpp[0]),
+		pending->x, pending->y, pending->width, pending->height);
+
+	rdma_l = ovl_adaptor->ovl_adaptor_comp[OVL_ADAPTOR_MDP_RDMA0 + 2 * idx];
+	rdma_r = ovl_adaptor->ovl_adaptor_comp[OVL_ADAPTOR_MDP_RDMA0 + 2 * idx + 1];
+	merge = ovl_adaptor->ovl_adaptor_comp[OVL_ADAPTOR_MERGE0 + idx];
+
+	if (!pending->enable) {
+		mtk_merge_disable(merge, cmdq_pkt);
+		mtk_mdp_rdma_stop(rdma_l, cmdq_pkt);
+		mtk_mdp_rdma_stop(rdma_r, cmdq_pkt);
+		mtk_ethdr_layer_config(dev, idx, state, cmdq_pkt);
+		return;
+	}
+
+	/* ETHDR is in 1T2P domain, width needs to be 2 pixels align */
+	pending->width = ALIGN_DOWN(pending->width, 2);
+
+	if (pending->width > MTK_OVL_ADAPTOR_RDMA_MAX_WIDTH)
+		use_dual_pipe = true;
+
+	if (use_dual_pipe) {
+		l_w = (pending->width / 2) + ((pending->width / 2) % 2);
+		r_w = pending->width - l_w;
+	} else {
+		l_w = pending->width;
+	}
+	mtk_merge_advance_config(merge, l_w, r_w, pending->height, 0, 0, cmdq_pkt);
+	mtk_mmsys_ddp_config(ovl_adaptor->mmsys_dev, MMSYS_CONFIG_MERGE_ASYNC_WIDTH,
+			     idx, pending->width / 2, cmdq_pkt);
+	mtk_mmsys_ddp_config(ovl_adaptor->mmsys_dev, MMSYS_CONFIG_MERGE_ASYNC_HEIGHT,
+			     idx, pending->height, cmdq_pkt);
+
+	rdma_config.csc_enable = fmt_info->is_yuv ? true : false;
+	rdma_config.profile = RDMA_CSC_FULL709_TO_RGB;
+	rdma_config.width = l_w;
+	rdma_config.height = pending->height;
+	rdma_config.addr0 = pending->addr;
+	rdma_config.pitch = pending->pitch;
+	rdma_config.fmt = pending->format;
+	mtk_mdp_rdma_config(rdma_l, &rdma_config, cmdq_pkt);
+
+	rdma_config.x_left = l_w;
+	rdma_config.width = r_w;
+	mtk_mdp_rdma_config(rdma_r, &rdma_config, cmdq_pkt);
+
+	mtk_merge_enable(merge, cmdq_pkt);
+	mtk_merge_unmute(merge, cmdq_pkt);
+
+	mtk_mdp_rdma_start(rdma_l, cmdq_pkt);
+	if (use_dual_pipe)
+		mtk_mdp_rdma_start(rdma_r, cmdq_pkt);
+	else
+		mtk_mdp_rdma_stop(rdma_r, cmdq_pkt);
+
+	mtk_ethdr_layer_config(dev, idx, state, cmdq_pkt);
+}
+
+void mtk_ovl_adaptor_config(struct device *dev, unsigned int w,
+			    unsigned int h, unsigned int vrefresh,
+			    unsigned int bpc, struct cmdq_pkt *cmdq_pkt)
+{
+	mtk_ethdr_config(dev, w, h, vrefresh, bpc, cmdq_pkt);
+}
+
+void mtk_ovl_adaptor_start(struct device *dev)
+{
+	mtk_ethdr_start(dev);
+}
+
+void mtk_ovl_adaptor_stop(struct device *dev)
+{
+	struct device *ovl_adaptor_dev = get_ovl_adaptor(dev);
+	struct mtk_disp_ovl_adaptor *ovl_adaptor = dev_get_drvdata(ovl_adaptor_dev);
+	struct device *rdma_l;
+	struct device *rdma_r;
+	struct device *merge;
+	u32 i;
+
+	for (i = 0; i < MTK_OVL_ADAPTOR_LAYER_NUM; i++) {
+		rdma_l = ovl_adaptor->ovl_adaptor_comp[OVL_ADAPTOR_MDP_RDMA0 + 2 * i];
+		rdma_r = ovl_adaptor->ovl_adaptor_comp[OVL_ADAPTOR_MDP_RDMA0 + 2 * i + 1];
+		merge = ovl_adaptor->ovl_adaptor_comp[OVL_ADAPTOR_MERGE0 + i];
+
+		mtk_mdp_rdma_stop(rdma_l, NULL);
+		mtk_mdp_rdma_stop(rdma_r, NULL);
+		mtk_merge_stop(merge);
+	}
+
+	mtk_ethdr_stop(dev);
+}
+
+int mtk_ovl_adaptor_clk_enable(struct device *dev)
+{
+	struct device *ovl_adaptor_dev = get_ovl_adaptor(dev);
+	struct mtk_disp_ovl_adaptor *ovl_adaptor = dev_get_drvdata(ovl_adaptor_dev);
+	struct device *comp;
+	int ret;
+	int i;
+
+	for (i = OVL_ADAPTOR_MDP_RDMA0; i < OVL_ADAPTOR_ID_MAX; i++) {
+		comp = ovl_adaptor->ovl_adaptor_comp[i];
+
+		if (i < OVL_ADAPTOR_MERGE0)
+			ret = mtk_mdp_rdma_clk_enable(comp);
+		else
+			ret = mtk_merge_clk_enable(comp);
+		if (ret) {
+			dev_err(dev,
+				"Failed to enable clock %d, err %d-%s\n",
+				i, ret, ovl_adaptor_comp_str[i]);
+			goto clk_err;
+		}
+	}
+
+	mtk_ethdr_clk_enable(dev);
+	return ret;
+
+clk_err:
+	while (--i >= 0) {
+		comp = ovl_adaptor->ovl_adaptor_comp[i];
+		if (i < OVL_ADAPTOR_MERGE0)
+			mtk_mdp_rdma_clk_disable(comp);
+		else
+			mtk_merge_clk_disable(comp);
+	}
+	return ret;
+}
+
+void mtk_ovl_adaptor_clk_disable(struct device *dev)
+{
+	struct device *ovl_adaptor_dev = get_ovl_adaptor(dev);
+	struct mtk_disp_ovl_adaptor *ovl_adaptor = dev_get_drvdata(ovl_adaptor_dev);
+	struct device *comp;
+	int i;
+
+	for (i = OVL_ADAPTOR_MDP_RDMA0; i < OVL_ADAPTOR_ID_MAX; i++) {
+		comp = ovl_adaptor->ovl_adaptor_comp[i];
+
+		if (i < OVL_ADAPTOR_MERGE0)
+			mtk_mdp_rdma_clk_disable(comp);
+		else
+			mtk_merge_clk_disable(comp);
+	}
+	mtk_ethdr_clk_disable(dev);
+}
+
+unsigned int mtk_ovl_adaptor_layer_nr(struct device *dev)
+{
+	return MTK_OVL_ADAPTOR_LAYER_NUM;
+}
+
+void mtk_ovl_adaptor_enable_vblank(struct device *dev, void (*vblank_cb)(void *),
+				   void *vblank_cb_data)
+{
+	mtk_ethdr_enable_vblank(dev, vblank_cb, vblank_cb_data);
+}
+
+void mtk_ovl_adaptor_disable_vblank(struct device *dev)
+{
+	mtk_ethdr_disable_vblank(dev);
+}
+
+static int ovl_adaptor_comp_get_id(struct device *dev, struct device_node *node,
+				   enum mtk_ovl_adaptor_comp_type type)
+{
+	int alias_id = of_alias_get_id(node, private_comp_stem[type]);
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(comp_matches); i++)
+		if (comp_matches[i].type == type &&
+		    comp_matches[i].alias_id == alias_id)
+			return i;
+
+	dev_err(dev, "Failed to get id. type: %d, alias: %d\n", type, alias_id);
+	return -EINVAL;
+}
+
+static const struct of_device_id mtk_ovl_adaptor_comp_dt_ids[] = {
+	{
+		.compatible = "mediatek,mt8195-vdo1-rdma",
+		.data = (void *)OVL_ADAPTOR_TYPE_RDMA,
+	}, {
+		.compatible = "mediatek,mt8195-disp-merge",
+		.data = (void *)OVL_ADAPTOR_TYPE_MERGE,
+	},
+	{},
+};
+
+static int ovl_adaptor_comp_init(struct device *dev)
+{
+	struct mtk_disp_ovl_adaptor *priv = dev_get_drvdata(dev);
+	struct device_node *node, *parent;
+	struct platform_device *comp_pdev;
+
+	parent = dev->parent->of_node->parent;
+
+	for_each_child_of_node(parent, node) {
+		const struct of_device_id *of_id;
+		enum mtk_ovl_adaptor_comp_type type;
+		int id;
+
+		of_id = of_match_node(mtk_ovl_adaptor_comp_dt_ids, node);
+		if (!of_id)
+			continue;
+
+		if (!of_device_is_available(node)) {
+			dev_info(dev, "Skipping disabled component %pOF\n",
+				 node);
+			continue;
+		}
+
+		type = (enum mtk_ovl_adaptor_comp_type)of_id->data;
+		id = ovl_adaptor_comp_get_id(dev, node, type);
+		if (id < 0) {
+			dev_warn(dev, "Skipping unknown component %pOF\n",
+				 node);
+			continue;
+		}
+
+		comp_pdev = of_find_device_by_node(node);
+		if (!comp_pdev) {
+			dev_warn(dev, "can't find platform device of node:%s\n",
+				 node->name);
+			return -ENODEV;
+		}
+		priv->ovl_adaptor_comp[id] = &comp_pdev->dev;
+
+		dev_info(dev, "[DRM]dev:%s, node:%s\n", dev_name(priv->ovl_adaptor_comp[id]),
+			 ovl_adaptor_comp_str[id]);
+	}
+
+	return 0;
+}
+
+static const struct of_device_id ovl_adaptor_driver_dt_match[] = {
+	{ .compatible = "mediatek,mt8195-disp-ethdr"},
+	{},
+};
+MODULE_DEVICE_TABLE(of, mtk_disp_ovl_adaptor_driver_dt_match);
+
+static int mtk_disp_ovl_adaptor_probe(struct platform_device *pdev)
+{
+	struct mtk_disp_ovl_adaptor *priv;
+	struct device *dev = &pdev->dev;
+	struct device_node *phandle = dev->parent->of_node;
+	const struct of_device_id *of_id;
+	int ret;
+
+	dev_info(dev, "%s+\n", __func__);
+
+	of_id = of_match_node(ovl_adaptor_driver_dt_match, phandle);
+	if (!of_id)
+		return -ENODEV;
+
+	priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	priv->mmsys_dev = pdev->dev.platform_data;
+
+	platform_set_drvdata(pdev, priv);
+
+	ret = ovl_adaptor_comp_init(dev);
+	if (ret) {
+		dev_notice(dev, "ovl_adaptor comp init fail\n");
+		return ret;
+	}
+
+	dev_info(dev, "%s-\n", __func__);
+	return ret;
+}
+
+static int mtk_disp_ovl_adaptor_remove(struct platform_device *pdev)
+{
+	return 0;
+}
+
+struct platform_driver mtk_disp_ovl_adaptor_driver = {
+	.probe = mtk_disp_ovl_adaptor_probe,
+	.remove = mtk_disp_ovl_adaptor_remove,
+	.driver = {
+			.name = "mediatek-disp-ovl-adaptor",
+			.owner = THIS_MODULE,
+		},
+};
diff --git a/drivers/gpu/drm/mediatek/mtk_disp_rdma.c b/drivers/gpu/drm/mediatek/mtk_disp_rdma.c
index 251f034acb09e2bde0f701c82f38b87f1fa2d721..c865337bb8946e8258152f675b4ec271caa68b70 100644
--- a/drivers/gpu/drm/mediatek/mtk_disp_rdma.c
+++ b/drivers/gpu/drm/mediatek/mtk_disp_rdma.c
@@ -360,6 +360,10 @@ static const struct mtk_disp_rdma_data mt8183_rdma_driver_data = {
 	.fifo_size = 5 * SZ_1K,
 };
 
+static const struct mtk_disp_rdma_data mt8195_rdma_driver_data = {
+	.fifo_size = 1920,
+};
+
 static const struct of_device_id mtk_disp_rdma_driver_dt_match[] = {
 	{ .compatible = "mediatek,mt2701-disp-rdma",
 	  .data = &mt2701_rdma_driver_data},
@@ -367,6 +371,8 @@ static const struct of_device_id mtk_disp_rdma_driver_dt_match[] = {
 	  .data = &mt8173_rdma_driver_data},
 	{ .compatible = "mediatek,mt8183-disp-rdma",
 	  .data = &mt8183_rdma_driver_data},
+	{ .compatible = "mediatek,mt8195-disp-rdma",
+	  .data = &mt8195_rdma_driver_data},
 	{},
 };
 MODULE_DEVICE_TABLE(of, mtk_disp_rdma_driver_dt_match);
diff --git a/drivers/gpu/drm/mediatek/mtk_dp.c b/drivers/gpu/drm/mediatek/mtk_dp.c
new file mode 100644
index 0000000000000000000000000000000000000000..b34de1165e1a7899c0e0e1468c978804dafbe9f8
--- /dev/null
+++ b/drivers/gpu/drm/mediatek/mtk_dp.c
@@ -0,0 +1,2426 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2019 MediaTek Inc.
+ */
+
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_irq.h>
+#include <linux/of_platform.h>
+#include <linux/platform_device.h>
+#include <linux/arm-smccc.h>
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/mfd/syscon.h>
+#include <linux/of_gpio.h>
+#include <linux/of_graph.h>
+#include <linux/phy/phy.h>
+#include <linux/regmap.h>
+#include <linux/component.h>
+#include <linux/of_device.h>
+#include <linux/extcon.h>
+#include <linux/extcon-provider.h>
+#include <linux/kthread.h>
+#include <linux/errno.h>
+
+#include <drm/drm_atomic_helper.h>
+#include <drm/drm_bridge.h>
+#include <drm/drm_crtc.h>
+#include <drm/drm_crtc_helper.h>
+#include <drm/drm_edid.h>
+#include <drm/drm_dp_helper.h>
+#include <drm/drm_print.h>
+#include <drm/drm_probe_helper.h>
+#include <drm/mediatek_drm.h>
+#include <drm/drm_of.h>
+#include <drm/drm_panel.h>
+#include <sound/hdmi-codec.h>
+#include <video/videomode.h>
+
+#include "mtk_dp.h"
+#include "mtk_dp_hal.h"
+#include "mtk_dp_api.h"
+#include "mtk_dp_reg.h"
+#include "mtk_drm_ddp_comp.h"
+#include "mtk_drm_drv.h"
+
+static inline struct mtk_dp *dp_from_conn(struct drm_connector *c)
+{
+	return container_of(c, struct mtk_dp, conn);
+}
+
+static inline struct mtk_dp *dp_from_bridge(struct drm_bridge *b)
+{
+	return container_of(b, struct mtk_dp, bridge);
+}
+
+static bool mdrv_DPTx_AuxWrite_Bytes(struct mtk_dp *mtk_dp, u8 ubCmd,
+	u32  usDPCDADDR, size_t ubLength, BYTE *pData)
+{
+	bool bReplyStatus = false;
+	u8 ubRetryLimit = 0x7;
+
+	if (!mtk_dp->training_info.bCablePlugIn ||
+		((mtk_dp->training_info.usPHY_STS & (HPD_DISCONNECT)) != 0x0)) {
+
+		if (!mtk_dp->training_info.bDPTxAutoTest_EN)
+			mtk_dp->training_state = DPTX_NTSTATE_CHECKCAP;
+		return false;
+	}
+
+	do {
+		bReplyStatus = mhal_DPTx_AuxWrite_Bytes(mtk_dp, ubCmd,
+			usDPCDADDR, ubLength, pData);
+		ubRetryLimit--;
+		if (!bReplyStatus) {
+			udelay(50);
+		} else
+			return true;
+	} while (ubRetryLimit > 0);
+
+	pr_err("Aux Write Fail: cmd = %d, addr = 0x%x, len = %ld\n",
+		ubCmd, usDPCDADDR, ubLength);
+
+	return false;
+}
+
+static bool mdrv_DPTx_AuxWrite_DPCD(struct mtk_dp *mtk_dp, u8 ubCmd,
+	u32 usDPCDADDR, size_t ubLength, BYTE *pData)
+{
+	bool bRet = true;
+	size_t times = 0;
+	size_t remain = 0;
+	size_t loop = 0;
+
+	if (ubLength > DP_AUX_MAX_PAYLOAD_BYTES) {
+		times = ubLength / DP_AUX_MAX_PAYLOAD_BYTES;
+		remain = ubLength % DP_AUX_MAX_PAYLOAD_BYTES;
+
+		for (loop = 0; loop < times; loop++)
+			bRet &= mdrv_DPTx_AuxWrite_Bytes(mtk_dp,
+				ubCmd,
+				usDPCDADDR + (loop * DP_AUX_MAX_PAYLOAD_BYTES),
+				DP_AUX_MAX_PAYLOAD_BYTES,
+				pData + (loop * DP_AUX_MAX_PAYLOAD_BYTES));
+
+		if (remain > 0)
+			bRet &= mdrv_DPTx_AuxWrite_Bytes(mtk_dp,
+				ubCmd,
+				usDPCDADDR + (times * DP_AUX_MAX_PAYLOAD_BYTES),
+				remain,
+				pData + (times * DP_AUX_MAX_PAYLOAD_BYTES));
+	} else {
+		bRet &= mdrv_DPTx_AuxWrite_Bytes(mtk_dp,
+				ubCmd,
+				usDPCDADDR,
+				ubLength,
+				pData);
+	}
+
+	return bRet;
+}
+
+
+static bool mdrv_DPTx_AuxRead_Bytes(struct mtk_dp *mtk_dp, u8 ubCmd,
+	u32 usDPCDADDR, size_t ubLength, BYTE *pData)
+{
+	bool bReplyStatus = false;
+	u8 ubRetryLimit = 7;
+
+	if (!mtk_dp->training_info.bCablePlugIn ||
+		((mtk_dp->training_info.usPHY_STS & (HPD_DISCONNECT)) != 0x0)) {
+		if (!mtk_dp->training_info.bDPTxAutoTest_EN)
+			mtk_dp->training_state = DPTX_NTSTATE_CHECKCAP;
+		return false;
+	}
+
+
+	do {
+		bReplyStatus = mhal_DPTx_AuxRead_Bytes(mtk_dp, ubCmd,
+					usDPCDADDR, ubLength, pData);
+		if (!bReplyStatus) {
+			udelay(50);
+		} else
+			return true;
+
+		ubRetryLimit--;
+	} while (ubRetryLimit > 0);
+
+	pr_err("Aux Read Fail: cmd = %d, addr = 0x%x, len = %ld\n",
+		ubCmd, usDPCDADDR, ubLength);
+
+	return false;
+}
+
+static bool mdrv_DPTx_AuxRead_DPCD(struct mtk_dp *mtk_dp, u8 ubCmd,
+	u32 usDPCDADDR, size_t ubLength, BYTE *pRxBuf)
+{
+	bool bRet = true;
+	size_t times = 0;
+	size_t remain = 0;
+	size_t loop = 0;
+
+	if (ubLength > DP_AUX_MAX_PAYLOAD_BYTES) {
+		times = ubLength / DP_AUX_MAX_PAYLOAD_BYTES;
+		remain = ubLength % DP_AUX_MAX_PAYLOAD_BYTES;
+
+		for (loop = 0; loop < times; loop++)
+			bRet &= mdrv_DPTx_AuxRead_Bytes(mtk_dp,
+				ubCmd,
+				usDPCDADDR + (loop * DP_AUX_MAX_PAYLOAD_BYTES),
+				DP_AUX_MAX_PAYLOAD_BYTES,
+				pRxBuf + (loop * DP_AUX_MAX_PAYLOAD_BYTES));
+
+		if (remain > 0)
+			bRet &= mdrv_DPTx_AuxRead_Bytes(mtk_dp,
+				ubCmd,
+				usDPCDADDR + (times * DP_AUX_MAX_PAYLOAD_BYTES),
+				remain,
+				pRxBuf + (times * DP_AUX_MAX_PAYLOAD_BYTES));
+	} else
+		bRet &= mdrv_DPTx_AuxRead_Bytes(mtk_dp,
+				ubCmd,
+				usDPCDADDR,
+				ubLength,
+				pRxBuf);
+
+	return bRet;
+}
+
+static void mdrv_DPTx_InitVariable(struct mtk_dp *mtk_dp)
+{
+	mtk_dp->training_info.ubDPSysVersion = DP_VERSION_14;
+	mtk_dp->training_info.ubLinkRate = DP_LINKRATE_HBR2;
+	mtk_dp->training_info.ubLinkLaneCount = DP_LANECOUNT_4;
+	mtk_dp->training_info.bSinkEXTCAP_En = false;
+	mtk_dp->training_info.bSinkSSC_En = false;
+	mtk_dp->training_info.bTPS3 = true;
+	mtk_dp->training_info.bTPS4 = true;
+	mtk_dp->training_info.usPHY_STS = HPD_INITIAL_STATE;
+	mtk_dp->training_info.bCablePlugIn = false;
+	mtk_dp->training_info.bCableStateChange = false;
+	mtk_dp->training_state = DPTX_NTSTATE_STARTUP;
+	mtk_dp->training_state_pre = DPTX_NTSTATE_STARTUP;
+	mtk_dp->state = DPTXSTATE_INITIAL;
+	mtk_dp->state_pre = DPTXSTATE_INITIAL;
+
+	mtk_dp->info.input_src = DPTX_SRC_DPINTF;
+	mtk_dp->info.format = DP_COLOR_FORMAT_RGB_444;
+	mtk_dp->info.depth = DP_COLOR_DEPTH_8BIT;
+	if (!mtk_dp->info.bPatternGen)
+		mtk_dp->info.resolution = SINK_3840_2160;
+	mtk_dp->info.bSetAudioMute = false;
+	mtk_dp->info.bSetVideoMute = false;
+	memset(&mtk_dp->info.DPTX_OUTBL, 0,
+		sizeof(struct DPTX_TIMING_PARAMETER));
+	mtk_dp->info.DPTX_OUTBL.FrameRate = 60;
+
+	mtk_dp->bPowerOn = false;
+	mtk_dp->video_enable = false;
+	mtk_dp->dp_ready = false;
+	mtk_dp->has_dsc = false;
+	mtk_dp->has_fec = false;
+	mtk_dp->dsc_enable = false;
+
+	mdrv_DPTx_CheckMaxLinkRate(mtk_dp);
+}
+
+static void mdrv_DPTx_SetSDP_DownCntinit(struct mtk_dp *mtk_dp,
+	u16 Sram_Read_Start)
+{
+	u16 SDP_Down_Cnt_Init = 0x0000;
+	u8 ucDCOffset;
+
+	if (mtk_dp->info.DPTX_OUTBL.PixRateKhz > 0)
+		SDP_Down_Cnt_Init = (Sram_Read_Start *
+			mtk_dp->training_info.ubLinkRate * 2700 * 8)
+			/ (mtk_dp->info.DPTX_OUTBL.PixRateKhz * 4);
+
+	switch (mtk_dp->training_info.ubLinkLaneCount) {
+	case DP_LANECOUNT_1:
+		SDP_Down_Cnt_Init = (SDP_Down_Cnt_Init > 0x1A) ?
+			SDP_Down_Cnt_Init : 0x1A;  //26
+		break;
+	case DP_LANECOUNT_2:
+		// case for LowResolution && High Audio Sample Rate
+		ucDCOffset = (mtk_dp->info.DPTX_OUTBL.Vtt <= 525) ?
+			0x04 : 0x00;
+		SDP_Down_Cnt_Init = (SDP_Down_Cnt_Init > 0x10) ?
+			SDP_Down_Cnt_Init : 0x10 + ucDCOffset; //20 or 16
+		break;
+	case DP_LANECOUNT_4:
+		SDP_Down_Cnt_Init = (SDP_Down_Cnt_Init > 0x06) ?
+			SDP_Down_Cnt_Init : 0x06; //6
+		break;
+	default:
+		SDP_Down_Cnt_Init = (SDP_Down_Cnt_Init > 0x06) ?
+			SDP_Down_Cnt_Init : 0x06;
+		break;
+	}
+
+	mhal_DPTx_SetSDP_DownCntinit(mtk_dp, SDP_Down_Cnt_Init);
+}
+
+static void mdrv_DPTx_SetSDP_DownCntinitInHblanking(struct mtk_dp *mtk_dp)
+{
+	int PixClkMhz;
+	u8 ucDCOffset;
+
+	PixClkMhz = (mtk_dp->info.format == DP_COLOR_FORMAT_YUV_420) ?
+		mtk_dp->info.DPTX_OUTBL.PixRateKhz/2000 :
+		mtk_dp->info.DPTX_OUTBL.PixRateKhz/1000;
+
+	switch (mtk_dp->training_info.ubLinkLaneCount) {
+	case DP_LANECOUNT_1:
+		mhal_DPTx_SetSDP_DownCntinitInHblanking(mtk_dp, 0x0020);
+		break;
+	case DP_LANECOUNT_2:
+		ucDCOffset = (mtk_dp->info.DPTX_OUTBL.Vtt <= 525) ? 0x14 : 0x00;
+		mhal_DPTx_SetSDP_DownCntinitInHblanking(mtk_dp,
+			0x0018 + ucDCOffset);
+		break;
+	case DP_LANECOUNT_4:
+		ucDCOffset = (mtk_dp->info.DPTX_OUTBL.Vtt <= 525) ? 0x08 : 0x00;
+		if (PixClkMhz > (mtk_dp->training_info.ubLinkRate * 27))
+			mhal_DPTx_SetSDP_DownCntinitInHblanking(mtk_dp, 0x0008);
+		else
+			mhal_DPTx_SetSDP_DownCntinitInHblanking(mtk_dp,
+				0x0010 + ucDCOffset);
+		break;
+	}
+
+}
+
+static void mdrv_DPTx_SetTU(struct mtk_dp *mtk_dp)
+{
+	int TU_size = 0;
+	int NValue = 0;
+	int FValue = 0;
+	int PixRateMhz = 0;
+	u8 ColorBpp;
+	u16 Sram_Read_Start = DPTX_TBC_BUF_ReadStartAdrThrd;
+
+	ColorBpp = mhal_DPTx_GetColorBpp(mtk_dp);
+	PixRateMhz = mtk_dp->info.DPTX_OUTBL.PixRateKhz/1000;
+	TU_size = (640*(PixRateMhz)*ColorBpp)/
+			(mtk_dp->training_info.ubLinkRate * 27 *
+				mtk_dp->training_info.ubLinkLaneCount * 8);
+
+	NValue = TU_size / 10;
+	FValue = TU_size-NValue * 10;
+
+	if (mtk_dp->training_info.ubLinkLaneCount > 0) {
+		Sram_Read_Start = mtk_dp->info.DPTX_OUTBL.Hde /
+			(mtk_dp->training_info.ubLinkLaneCount*4*2*2);
+		Sram_Read_Start =
+			(Sram_Read_Start < DPTX_TBC_BUF_ReadStartAdrThrd) ?
+			Sram_Read_Start : DPTX_TBC_BUF_ReadStartAdrThrd;
+		mhal_DPTx_SetTU_SramRdStart(mtk_dp, Sram_Read_Start);
+	}
+
+	mhal_DPTx_SetTU_SetEncoder(mtk_dp);
+	mdrv_DPTx_SetSDP_DownCntinitInHblanking(mtk_dp);
+	mdrv_DPTx_SetSDP_DownCntinit(mtk_dp, Sram_Read_Start);
+}
+
+static void mdrv_DPTx_CalculateMN(struct mtk_dp *mtk_dp)
+{
+	int ubTargetFrameRate = 60;
+	int ulTargetPixelclk = 148500000; // default set FHD
+
+	if (mtk_dp->info.DPTX_OUTBL.FrameRate > 0) {
+		ubTargetFrameRate = mtk_dp->info.DPTX_OUTBL.FrameRate;
+		ulTargetPixelclk = (int)mtk_dp->info.DPTX_OUTBL.Htt*
+			(int)mtk_dp->info.DPTX_OUTBL.Vtt*ubTargetFrameRate;
+	} else if (mtk_dp->info.DPTX_OUTBL.PixRateKhz > 0) {
+		ulTargetPixelclk = mtk_dp->info.DPTX_OUTBL.PixRateKhz * 1000;
+	} else {
+		ulTargetPixelclk = (int)mtk_dp->info.DPTX_OUTBL.Htt *
+			(int)mtk_dp->info.DPTX_OUTBL.Vtt * ubTargetFrameRate;
+	}
+
+	if (ulTargetPixelclk > 0)
+		mtk_dp->info.DPTX_OUTBL.PixRateKhz = ulTargetPixelclk / 1000;
+}
+
+static void mdrv_DPTx_Set_MISC(struct mtk_dp *mtk_dp)
+{
+	u8 format, depth;
+	union MISC_T DPTX_MISC;
+
+	format = mtk_dp->info.format;
+	depth = mtk_dp->info.depth;
+
+	// MISC 0/1 refernce to spec 1.4a p143 Table 2-96
+	// MISC0[7:5] color depth
+	switch (depth) {
+	case DP_COLOR_DEPTH_6BIT:
+	case DP_COLOR_DEPTH_8BIT:
+	case DP_COLOR_DEPTH_10BIT:
+	case DP_COLOR_DEPTH_12BIT:
+	case DP_COLOR_DEPTH_16BIT:
+	default:
+		DPTX_MISC.dp_misc.color_depth = depth;
+		break;
+	}
+
+	// MISC0[3]: 0->RGB, 1->YUV
+	// MISC0[2:1]: 01b->4:2:2, 10b->4:4:4
+	switch (format) {
+	case DP_COLOR_FORMAT_YUV_444:
+		DPTX_MISC.dp_misc.color_format = 0x1;  //01'b
+		break;
+
+	case DP_COLOR_FORMAT_YUV_422:
+		DPTX_MISC.dp_misc.color_format = 0x2;  //10'b
+		break;
+
+	case DP_COLOR_FORMAT_YUV_420:
+		//not support
+		break;
+
+	case DP_COLOR_FORMAT_RAW:
+		DPTX_MISC.dp_misc.color_format = 0x1;
+		DPTX_MISC.dp_misc.spec_def2 = 0x1;
+		break;
+	case DP_COLOR_FORMAT_YONLY:
+		DPTX_MISC.dp_misc.color_format = 0x0;
+		DPTX_MISC.dp_misc.spec_def2 = 0x1;
+		break;
+
+	case DP_COLOR_FORMAT_RGB_444:
+	default:
+		break;
+	}
+
+	mhal_DPTx_SetMISC(mtk_dp, DPTX_MISC.ucMISC);
+}
+
+void mdrv_DPTx_SetDPTXOut(struct mtk_dp *mtk_dp)
+{
+	mhal_DPTx_EnableBypassMSA(mtk_dp, false);
+	mdrv_DPTx_CalculateMN(mtk_dp);
+
+	switch (mtk_dp->info.input_src) {
+	case DPTX_SRC_PG:
+		mhal_DPTx_PGEnable(mtk_dp, true);
+		mhal_DPTx_Set_MVIDx2(mtk_dp, false);
+		break;
+
+	case DPTX_SRC_DPINTF:
+		mhal_DPTx_PGEnable(mtk_dp, false);
+		break;
+
+	default:
+		mhal_DPTx_PGEnable(mtk_dp, true);
+		break;
+	}
+
+	mdrv_DPTx_SetTU(mtk_dp);
+}
+
+static bool mdrv_DPTx_CheckSinkLock(struct mtk_dp *mtk_dp, u8 *pDPCD20x, u8 *pDPCD200C)
+{
+	bool bLocked = true;
+
+	switch (mtk_dp->training_info.ubLinkLaneCount) {
+	case DP_LANECOUNT_1:
+		if ((pDPCD20x[2] & 0x07) != 0x07)
+			bLocked = false;
+		break;
+	case DP_LANECOUNT_2:
+		if ((pDPCD20x[2] & 0x77) != 0x77)
+			bLocked = false;
+		break;
+	case DP_LANECOUNT_4:
+		if (((pDPCD20x[2] != 0x77) || (pDPCD20x[3] != 0x77)))
+			bLocked = false;
+		break;
+	}
+
+	if ((pDPCD20x[4]&BIT0) == 0)
+		bLocked = false;
+
+	if (!bLocked) {
+		if (mtk_dp->training_state > DPTX_NTSTATE_TRAINING_PRE)
+			mtk_dp->training_state = DPTX_NTSTATE_TRAINING_PRE;
+	}
+
+	return bLocked;
+}
+
+static void mdrv_DPTx_CheckSinkHPDEvent(struct mtk_dp *mtk_dp)
+{
+	u8 ubDPCD20x[6];
+	u8 ubDPCD2002[2];
+	u8 ubDPCD200C[4];
+	bool ret;
+
+	memset(ubDPCD20x, 0x0, sizeof(ubDPCD20x));
+	memset(ubDPCD2002, 0x0, sizeof(ubDPCD2002));
+	memset(ubDPCD200C, 0x0, sizeof(ubDPCD200C));
+
+	ret = drm_dp_dpcd_read(&mtk_dp->aux, DPCD_02002, ubDPCD2002, 0x2);
+	if (!ret)
+		return;
+
+	ret = drm_dp_dpcd_read(&mtk_dp->aux, DPCD_0200C, ubDPCD200C, 0x4);
+	if (!ret)
+		return;
+
+	ret = drm_dp_dpcd_read(&mtk_dp->aux, DPCD_00200, ubDPCD20x, 0x6);
+	if (!ret)
+		return;
+
+	mdrv_DPTx_CheckSinkLock(mtk_dp, ubDPCD20x, ubDPCD200C);
+	mdrv_DPTx_CheckSinkESI(mtk_dp, ubDPCD20x, ubDPCD2002);
+
+	if ((ubDPCD2002[0x0] & 0x1F || ubDPCD20x[0x0] & 0x1F) &&
+		(ubDPCD200C[0x2] & BIT6 || ubDPCD20x[0x4] & BIT6)) {
+
+		mtk_dp->training_info.ucCheckCapTimes = 0;
+		if (mtk_dp->edid) {
+			kfree(mtk_dp->edid);
+			mtk_dp->edid = NULL;
+		}
+		mtk_dp->training_state = DPTX_NTSTATE_CHECKEDID;
+		mdelay(20);
+	}
+}
+
+void mdrv_DPTx_CheckMaxLinkRate(struct mtk_dp *mtk_dp)
+{
+	switch (mtk_dp->training_info.ubDPSysVersion) {
+	case DP_VERSION_11:
+		mtk_dp->training_info.ubSysMaxLinkRate = DP_LINKRATE_HBR;
+		break;
+	case DP_VERSION_12:
+		mtk_dp->training_info.ubSysMaxLinkRate = DP_LINKRATE_HBR2;
+		break;
+	case DP_VERSION_14:
+		mtk_dp->training_info.ubSysMaxLinkRate = DP_LINKRATE_HBR3;
+		break;
+	default:
+		mtk_dp->training_info.ubSysMaxLinkRate = DP_LINKRATE_HBR2;
+		break;
+	}
+}
+
+/*void mdrv_DPTx_DisconnetInit(struct mtk_dp *mtk_dp)
+{
+	mdrv_DPTx_CheckMaxLinkRate(mtk_dp);
+}*/
+
+void mdrv_DPTx_SPKG_SDP(struct mtk_dp *mtk_dp, bool bEnable, u8 ucSDPType,
+	u8 *pHB, u8 *pDB)
+{
+	mhal_DPTx_SPKG_SDP(mtk_dp, bEnable, ucSDPType, pHB, pDB);
+}
+
+static void mdrv_DPTx_StopSentSDP(struct mtk_dp *mtk_dp)
+{
+	u8 ubPkgType;
+
+	for (ubPkgType = DPTx_SDPTYP_ACM ; ubPkgType < DPTx_SDPTYP_MAX_NUM;
+		ubPkgType++)
+		mhal_DPTx_SPKG_SDP(mtk_dp, false, ubPkgType, NULL, NULL);
+
+	mhal_DPTx_SPKG_VSC_EXT_VESA(mtk_dp, false, 0x00, NULL);
+	mhal_DPTx_SPKG_VSC_EXT_CEA(mtk_dp, false, 0x00, NULL);
+}
+
+int mdrv_DPTx_HPD_HandleInThread(struct mtk_dp *mtk_dp)
+{
+	int ret = DPTX_NOERR;
+
+	if (mtk_dp->training_info.bCableStateChange) {
+		bool ubCurrentHPD = mhal_DPTx_GetHPDPinLevel(mtk_dp);
+
+		mtk_dp->training_info.bCableStateChange = false;
+
+		if (mtk_dp->training_info.bCablePlugIn && ubCurrentHPD) {
+			dev_info(mtk_dp->dev, "HPD_CON\n");
+		} else {
+			mdrv_DPTx_VideoMute(mtk_dp, true);
+			mdrv_DPTx_AudioMute(mtk_dp, true);
+
+			if (mtk_dp->bUeventToHwc) {
+				mtk_dp->bUeventToHwc = false;
+				mtk_dp->disp_status = DPTX_DISP_NONE;
+			}
+
+			mdrv_DPTx_InitVariable(mtk_dp);
+			mhal_DPTx_PHY_SetIdlePattern(mtk_dp, true);
+			if (mtk_dp->has_fec)
+				mhal_DPTx_EnableFEC(mtk_dp, false);
+			mdrv_DPTx_StopSentSDP(mtk_dp);
+
+			if (mtk_dp->dp_tx_clk)
+				clk_disable_unprepare(mtk_dp->dp_tx_clk);
+			if (mtk_dp->edid) {
+				kfree(mtk_dp->edid);
+				mtk_dp->edid = NULL;
+			}
+			ret = DPTX_PLUG_OUT;
+		}
+	}
+
+	return ret;
+}
+
+void mdrv_DPTx_VideoMute(struct mtk_dp *mtk_dp, bool bENABLE)
+{
+	mtk_dp->info.bVideoMute = (mtk_dp->info.bSetVideoMute) ?
+		true : bENABLE;
+	mhal_DPTx_VideoMute(mtk_dp, mtk_dp->info.bVideoMute);
+}
+
+void mdrv_DPTx_AudioMute(struct mtk_dp *mtk_dp, bool bENABLE)
+{
+	mtk_dp->info.bAudioMute = (mtk_dp->info.bSetAudioMute) ?
+		true : bENABLE;
+	mhal_DPTx_AudioMute(mtk_dp, mtk_dp->info.bAudioMute);
+}
+
+static bool mdrv_DPTx_TrainingCheckSwingPre(struct mtk_dp *mtk_dp,
+	u8 ubTargetLaneCount, u8 *ubDPCP202_x, u8 *ubDPCP_Buffer1)
+{
+	u8 ubSwingValue;
+	u8 ubPreemphasis;
+
+	if (ubTargetLaneCount >= 0x1) { //lane0
+		ubSwingValue = (ubDPCP202_x[0x4]&0x3);
+		ubPreemphasis = ((ubDPCP202_x[0x4]&0x0C)>>2);
+		//Adjust the swing and pre-emphasis
+		mhal_DPTx_SetSwingtPreEmphasis(mtk_dp, DPTx_LANE0,
+			ubSwingValue, ubPreemphasis);
+		//Adjust the swing and pre-emphasis done, notify Sink Side
+		ubDPCP_Buffer1[0x0] = ubSwingValue | (ubPreemphasis << 3);
+		if (ubSwingValue == DPTx_SWING3) { //MAX_SWING_REACHED
+			ubDPCP_Buffer1[0x0] |= BIT2;
+		}
+		//MAX_PRE-EMPHASIS_REACHED
+		if (ubPreemphasis == DPTx_PREEMPHASIS3)
+			ubDPCP_Buffer1[0x0] |= BIT5;
+
+	}
+
+	if (ubTargetLaneCount >= 0x2) { //lane1
+		ubSwingValue = (ubDPCP202_x[0x4]&0x30) >> 4;
+		ubPreemphasis = ((ubDPCP202_x[0x4]&0xC0)>>6);
+		//Adjust the swing and pre-emphasis
+		mhal_DPTx_SetSwingtPreEmphasis(mtk_dp, DPTx_LANE1,
+			ubSwingValue, ubPreemphasis);
+		//Adjust the swing and pre-emphasis done, notify Sink Side
+		ubDPCP_Buffer1[0x1] = ubSwingValue | (ubPreemphasis << 3);
+		if (ubSwingValue == DPTx_SWING3) { //MAX_SWING_REACHED
+			ubDPCP_Buffer1[0x1] |= BIT2;
+		}
+		//MAX_PRE-EMPHASIS_REACHED
+		if (ubPreemphasis == DPTx_PREEMPHASIS3)
+			ubDPCP_Buffer1[0x1] |= BIT5;
+
+	}
+
+	if (ubTargetLaneCount == 0x4) { //lane 2,3
+		ubSwingValue = (ubDPCP202_x[0x5]&0x3);
+		ubPreemphasis = ((ubDPCP202_x[0x5]&0x0C)>>2);
+
+		//Adjust the swing and pre-emphasis
+		mhal_DPTx_SetSwingtPreEmphasis(mtk_dp, DPTx_LANE2,
+			(ubDPCP202_x[0x5]&0x3), ((ubDPCP202_x[0x5]&0x0C)>>2));
+		//Adjust the swing and pre-emphasis done, notify Sink Side
+		ubDPCP_Buffer1[0x2] = ubSwingValue | (ubPreemphasis << 3);
+		if (ubSwingValue == DPTx_SWING3) { //MAX_SWING_REACHED
+			ubDPCP_Buffer1[0x2] |= BIT2;
+		}
+		//MAX_PRE-EMPHASIS_REACHED
+		if (ubPreemphasis == DPTx_PREEMPHASIS3)
+			ubDPCP_Buffer1[0x2] |= BIT5;
+
+
+		ubSwingValue = (ubDPCP202_x[0x5]&0x30) >> 4;
+		ubPreemphasis = ((ubDPCP202_x[0x5]&0xC0)>>6);
+
+		//Adjust the swing and pre-emphasis
+		mhal_DPTx_SetSwingtPreEmphasis(mtk_dp, DPTx_LANE3,
+			((ubDPCP202_x[0x5]&0x30)>>4),
+			((ubDPCP202_x[0x5]&0xC0)>>6));
+		//Adjust the swing and pre-emphasis done, notify Sink Side
+		ubDPCP_Buffer1[0x3] = ubSwingValue | (ubPreemphasis << 3);
+		if (ubSwingValue == DPTx_SWING3) { //MAX_SWING_REACHED
+			ubDPCP_Buffer1[0x3] |= BIT2;
+		}
+		//MAX_PRE-EMPHASIS_REACHED
+		if (ubPreemphasis == DPTx_PREEMPHASIS3)
+			ubDPCP_Buffer1[0x3] |= BIT5;
+	}
+
+	//Wait signal stable enough
+	mdelay(2);
+	return true;
+}
+
+static void mdrv_DPTx_Print_TrainingState(u8 state)
+{
+	switch (state) {
+	case DPTX_NTSTATE_STARTUP:
+		pr_info("NTSTATE_STARTUP!\n");
+		break;
+	case DPTX_NTSTATE_CHECKCAP:
+		pr_info("NTSTATE_CHECKCAP!\n");
+		break;
+	case DPTX_NTSTATE_CHECKEDID:
+		pr_info("NTSTATE_CHECKEDID!\n");
+		break;
+	case DPTX_NTSTATE_TRAINING_PRE:
+		pr_info("NTSTATE_TRAINING_PRE!\n");
+		break;
+	case DPTX_NTSTATE_TRAINING:
+		pr_info("NTSTATE_TRAINING!\n");
+		break;
+	case DPTX_NTSTATE_CHECKTIMING:
+		pr_info("NTSTATE_CHECKTIMING!\n");
+		break;
+	case DPTX_NTSTATE_NORMAL:
+		pr_info("NTSTATE_NORMAL!\n");
+		break;
+	case DPTX_NTSTATE_POWERSAVE:
+		pr_info("NTSTATE_POWERSAVE!\n");
+		break;
+	case DPTX_NTSTATE_DPIDLE:
+		pr_info("NTSTATE_DPIDLE!\n");
+		break;
+	}
+}
+
+int mdrv_DPTx_set_reTraining(struct mtk_dp *mtk_dp)
+{
+	int ret = 0;
+
+	if (mtk_dp->training_state > DPTX_NTSTATE_STARTUP)
+		mtk_dp->training_state = DPTX_NTSTATE_STARTUP;
+
+	if (mtk_dp->state > DPTXSTATE_INITIAL)
+		mtk_dp->state = DPTXSTATE_INITIAL;
+
+	mhal_DPTx_DigitalSwReset(mtk_dp);
+
+	return ret;
+}
+
+static int mdrv_DPTx_TrainingFlow(struct mtk_dp *mtk_dp, u8 ubLaneRate, u8 ubLaneCount)
+{
+	u8  ubTempValue[0x6];
+	u8  ubTargetLinkRate = ubLaneRate;
+	u8  ubTargetLaneCount = ubLaneCount;
+	u8  ubDPCP_Buffer1[0x4];
+	u8  bPassTPS1 = false;
+	u8  bPassTPS2_3 = false;
+	u8  ubTrainRetryTimes;
+	u8  ubStatusControl;
+	u8  ubIterationCount;
+	u8  ubDPCD206;
+
+	memset(ubTempValue, 0x0, sizeof(ubTempValue));
+	memset(ubDPCP_Buffer1, 0x0, sizeof(ubDPCP_Buffer1));
+
+	drm_dp_dpcd_read(&mtk_dp->aux, DPCD_00600, ubTempValue, 0x1);
+	if (ubTempValue[0] != 0x01) {
+		ubTempValue[0] = 0x01;
+		drm_dp_dpcd_write(&mtk_dp->aux, DPCD_00600, ubTempValue, 0x1);
+		mdelay(1);
+	}
+
+	ubTempValue[0] = ubTargetLinkRate;
+	ubTempValue[1] = ubTargetLaneCount | DPTX_AUX_SET_ENAHNCED_FRAME;
+	drm_dp_dpcd_write(&mtk_dp->aux, DPCD_00100, ubTempValue, 0x2);
+
+	if (mtk_dp->training_info.bSinkSSC_En) {
+		ubTempValue[0x0] = 0x10;
+		drm_dp_dpcd_write(&mtk_dp->aux, DPCD_00107, ubTempValue, 0x1);
+	}
+
+	ubTrainRetryTimes = 0x0;
+	ubStatusControl = 0x0;
+	ubIterationCount = 0x1;
+	ubDPCD206 = 0xFF;
+
+	mhal_DPTx_SetTxLane(mtk_dp, ubTargetLaneCount/2);
+	mhal_DPTx_SetTxRate(mtk_dp, ubTargetLinkRate);
+
+	do {
+		ubTrainRetryTimes++;
+		if (!mtk_dp->training_info.bCablePlugIn ||
+			((mtk_dp->training_info.usPHY_STS & HPD_DISCONNECT)
+				!= 0x0))
+			return DPTX_PLUG_OUT;
+
+		if (mtk_dp->training_state < DPTX_NTSTATE_TRAINING)
+			return DPTX_TRANING_STATE_CHANGE;
+
+		if (!bPassTPS1)	{
+			mhal_DPTx_SetScramble(mtk_dp, false);
+
+			if (ubStatusControl == 0x0)	{
+				mhal_DPTx_SetTxTrainingPattern(mtk_dp, BIT4);
+				ubStatusControl = 0x1;
+				ubTempValue[0] = 0x21;
+				drm_dp_dpcd_write(&mtk_dp->aux, DPCD_00102,
+					ubTempValue, 0x1);
+				drm_dp_dpcd_read(&mtk_dp->aux, DPCD_00206,
+					(ubTempValue+4), 0x2);
+				ubIterationCount++;
+
+				mdrv_DPTx_TrainingCheckSwingPre(mtk_dp,
+					ubTargetLaneCount, ubTempValue,
+					ubDPCP_Buffer1);
+			}
+			drm_dp_dpcd_write(&mtk_dp->aux, DPCD_00103,
+				ubDPCP_Buffer1, ubTargetLaneCount);
+
+			drm_dp_link_train_clock_recovery_delay(&mtk_dp->aux,
+				mtk_dp->rx_cap);
+			drm_dp_dpcd_read(&mtk_dp->aux, DPCD_00202,
+				ubTempValue, 0x6);
+
+			if (drm_dp_clock_recovery_ok(ubTempValue,
+				ubTargetLaneCount)) {
+				mtk_dp->training_info.cr_done = true;
+				bPassTPS1 = true;
+				ubTrainRetryTimes = 0x0;
+				ubIterationCount = 0x1;
+			} else {
+				//request swing & emp is the same eith last time
+				if (ubDPCD206 == ubTempValue[0x4]) {
+					ubIterationCount++;
+					if (ubDPCD206&0x3)
+						ubIterationCount =
+						DPTX_TRAIN_MAX_ITERATION;
+				} else {
+					ubDPCD206 = ubTempValue[0x4];
+				}
+			}
+		} else if (bPassTPS1 && !bPassTPS2_3) {
+			if (ubStatusControl == 0x1) {
+				if (mtk_dp->training_info.bTPS4)
+					mhal_DPTx_SetTxTrainingPattern(mtk_dp,
+						BIT7);
+				else if (mtk_dp->training_info.bTPS3)
+					mhal_DPTx_SetTxTrainingPattern(mtk_dp,
+						BIT6);
+				else
+					mhal_DPTx_SetTxTrainingPattern(mtk_dp,
+						BIT5);
+
+				if (mtk_dp->training_info.bTPS4) {
+					ubTempValue[0] = 0x07;
+					drm_dp_dpcd_write(&mtk_dp->aux,
+						DPCD_00102, ubTempValue, 0x1);
+				} else if (mtk_dp->training_info.bTPS3) {
+					ubTempValue[0] = 0x23;
+					drm_dp_dpcd_write(&mtk_dp->aux,
+						DPCD_00102, ubTempValue, 0x1);
+				} else {
+					ubTempValue[0] = 0x22;
+					drm_dp_dpcd_write(&mtk_dp->aux,
+						DPCD_00102, ubTempValue, 0x1);
+				}
+
+				ubStatusControl = 0x2;
+				drm_dp_dpcd_read(&mtk_dp->aux, DPCD_00206,
+					(ubTempValue+4), 0x2);
+
+				ubIterationCount++;
+				mdrv_DPTx_TrainingCheckSwingPre(mtk_dp,
+					ubTargetLaneCount, ubTempValue,
+					ubDPCP_Buffer1);
+			}
+
+			drm_dp_dpcd_write(&mtk_dp->aux, DPCD_00103,
+				ubDPCP_Buffer1, ubTargetLaneCount);
+			drm_dp_link_train_channel_eq_delay(&mtk_dp->aux,
+				mtk_dp->rx_cap);
+
+			drm_dp_dpcd_read(&mtk_dp->aux, DPCD_00202,
+				ubTempValue, 0x6);
+
+			if (!drm_dp_clock_recovery_ok(ubTempValue,
+				ubTargetLaneCount)) {
+				mtk_dp->training_info.cr_done = false;
+				mtk_dp->training_info.eq_done = false;
+				break;
+			}
+
+			if (drm_dp_channel_eq_ok(ubTempValue,
+				ubTargetLaneCount)) {
+				mtk_dp->training_info.eq_done = true;
+				bPassTPS2_3 = true;
+				break;
+			}
+
+			if (ubDPCD206 == ubTempValue[0x4])
+				ubIterationCount++;
+			else
+				ubDPCD206 = ubTempValue[0x4];
+		}
+
+		mdrv_DPTx_TrainingCheckSwingPre(mtk_dp, ubTargetLaneCount,
+			ubTempValue, ubDPCP_Buffer1);
+	} while ((ubTrainRetryTimes < DPTX_TRAIN_RETRY_LIMIT) &&
+		(ubIterationCount < DPTX_TRAIN_MAX_ITERATION));
+
+	ubTempValue[0] = 0x0;
+	drm_dp_dpcd_write(&mtk_dp->aux, DPCD_00102, ubTempValue, 0x1);
+	mhal_DPTx_SetTxTrainingPattern(mtk_dp, 0);
+
+	if (bPassTPS2_3) {
+		mtk_dp->training_info.ubLinkRate = ubTargetLinkRate;
+		mtk_dp->training_info.ubLinkLaneCount = ubTargetLaneCount;
+
+		mhal_DPTx_SetScramble(mtk_dp, true);
+
+		ubTempValue[0] = ubTargetLaneCount
+			| DPTX_AUX_SET_ENAHNCED_FRAME;
+		drm_dp_dpcd_write(&mtk_dp->aux, DPCD_00101, ubTempValue, 0x1);
+		mhal_DPTx_SetEF_Mode(mtk_dp, ENABLE_DPTX_EF_MODE);
+
+		return DPTX_NOERR;
+	}
+
+	return DPTX_TRANING_FAIL;
+}
+
+static bool mdrv_DPTx_CheckSinkCap(struct mtk_dp *mtk_dp)
+{
+	u8 bTempBuffer[0x10];
+
+	if (!mhal_DPTx_GetHPDPinLevel(mtk_dp))
+		return false;
+
+	memset(bTempBuffer, 0x0, sizeof(bTempBuffer));
+
+	bTempBuffer[0x0] = 0x1;
+	drm_dp_dpcd_write(&mtk_dp->aux, DPCD_00600, bTempBuffer, 0x1);
+	mdelay(2);
+
+	drm_dp_dpcd_read(&mtk_dp->aux, DPCD_00000, bTempBuffer, 0x10);
+
+	mtk_dp->training_info.ubDPCD_REV = bTempBuffer[0x0];
+
+	mtk_dp->training_info.bSinkEXTCAP_En = (bTempBuffer[0x0E]&BIT7) ?
+		true : false;
+
+	if (mtk_dp->training_info.bSinkEXTCAP_En) {
+		drm_dp_dpcd_read(&mtk_dp->aux, DPCD_02200, bTempBuffer, 0x10);
+		mtk_dp->training_info.ubDPCD_REV = bTempBuffer[0x0];
+	}
+
+	memcpy(mtk_dp->rx_cap, bTempBuffer, 0x10);
+	mtk_dp->rx_cap[0xe] &= 0x7F;
+
+#if !ENABLE_DPTX_FIX_LRLC
+	mtk_dp->training_info.ubLinkRate =
+		(bTempBuffer[0x1] >= mtk_dp->training_info.ubSysMaxLinkRate) ?
+		mtk_dp->training_info.ubSysMaxLinkRate : bTempBuffer[0x1];
+	mtk_dp->training_info.ubLinkLaneCount =
+		((bTempBuffer[0x2]&0x1F) >= MAX_LANECOUNT) ?
+		MAX_LANECOUNT : (bTempBuffer[0x2]&0x1F);
+
+	if (mtk_dp->training_info.ubLinkRate > 0x14) {
+		if (mtk_dp->training_info.ubLinkLaneCount > 2)
+			mtk_dp->training_info.ubLinkLaneCount = 2;
+	}
+#endif
+
+#if ENABLE_DPTX_FIX_TPS2
+	mtk_dp->training_info.bTPS3 = 0;
+	mtk_dp->training_info.bTPS4 = 0;
+#else
+	mtk_dp->training_info.bTPS3 = (bTempBuffer[0x2]&BIT6)>>0x6;
+	mtk_dp->training_info.bTPS4 = (bTempBuffer[0x3]&BIT7)>>0x7;
+#endif
+	mtk_dp->training_info.bDWN_STRM_PORT_PRESENT
+			= (bTempBuffer[0x5] & BIT0);
+
+#if (ENABLE_DPTX_SSC_OUTPUT == 0x1)
+	if ((bTempBuffer[0x3] & BIT0) == 0x1)
+		mtk_dp->training_info.bSinkSSC_En = true;
+	else
+		mtk_dp->training_info.bSinkSSC_En = false;
+#endif
+
+#if ENABLE_DPTX_SSC_FORCEON
+	mtk_dp->training_info.bSinkSSC_En = true;
+#endif
+
+	drm_dp_dpcd_read(&mtk_dp->aux, DPCD_00021, bTempBuffer, 0x1);
+	mtk_dp->training_info.bDPMstCAP = (bTempBuffer[0x0] & BIT0);
+	mtk_dp->training_info.bDPMstBranch = false;
+
+	if (mtk_dp->training_info.bDPMstCAP == BIT0) {
+		if (mtk_dp->training_info.bDWN_STRM_PORT_PRESENT == 0x1)
+			mtk_dp->training_info.bDPMstBranch = true;
+
+		drm_dp_dpcd_read(&mtk_dp->aux, DPCD_02003, bTempBuffer, 0x1);
+
+		if (bTempBuffer[0x0] != 0x0)
+			drm_dp_dpcd_write(&mtk_dp->aux, DPCD_02003,
+				bTempBuffer, 0x1);
+	}
+
+	return true;
+}
+
+static unsigned int mdrv_DPTx_getAudioCaps(struct mtk_dp *mtk_dp)
+{
+	struct cea_sad *sads;
+	int sad_count, i, j;
+	unsigned int caps = 0;
+
+	if (mtk_dp->edid == NULL) {
+		pr_err("EDID not found!\n");
+		return 0;
+	}
+
+	sad_count = drm_edid_to_sad(mtk_dp->edid, &sads);
+	if (sad_count <= 0)
+		return 0;
+
+	for (i = 0; i < sad_count; i++) {
+		if (sads[i].format == 0x01)	{
+			for (j = 0; j < sads[i].channels; j++)
+				caps |= ((1 << j) <<
+					DP_CAPABILITY_CHANNEL_SFT) &
+					(DP_CAPABILITY_CHANNEL_MASK <<
+					DP_CAPABILITY_CHANNEL_SFT);
+
+			caps |= (sads[i].freq << DP_CAPABILITY_SAMPLERATE_SFT) &
+				(DP_CAPABILITY_SAMPLERATE_MASK <<
+				DP_CAPABILITY_SAMPLERATE_SFT);
+			caps |= (sads[i].byte2 << DP_CAPABILITY_BITWIDTH_SFT) &
+				(DP_CAPABILITY_BITWIDTH_MASK <<
+				DP_CAPABILITY_BITWIDTH_SFT);
+		}
+	}
+
+	return caps;
+}
+
+static bool mdrv_DPTx_TrainingChangeMode(struct mtk_dp *mtk_dp)
+{
+	mhal_DPTx_PHYD_Reset(mtk_dp);
+	mhal_DPTx_ResetSwingtPreEmphasis(mtk_dp);
+	mhal_DPTx_SSCOnOffSetting(mtk_dp, mtk_dp->training_info.bSinkSSC_En);
+
+	mdelay(2);
+	return true;
+}
+
+int mdrv_DPTx_SetTrainingStart(struct mtk_dp *mtk_dp)
+{
+	u8 ret = DPTX_NOERR;
+	u8 ubLaneCount;
+	u8 ubLinkRate;
+	u8 ubTemp[16];
+	u8 ubTrainTimeLimits;
+#if !ENABLE_DPTX_FIX_LRLC
+	u8 maxLinkRate;
+#endif
+
+	if (!mhal_DPTx_GetHPDPinLevel(mtk_dp)) {
+		ubTrainTimeLimits = 6;
+		while (ubTrainTimeLimits > 6) {
+			if (mhal_DPTx_GetHPDPinLevel(mtk_dp))
+				break;
+
+			ubTrainTimeLimits--;
+			mdelay(1);
+		}
+
+		if (ubTrainTimeLimits == 0)	{
+			mtk_dp->training_state = DPTX_NTSTATE_DPIDLE;
+			return DPTX_PLUG_OUT;
+		}
+	}
+
+	if (!mtk_dp->training_info.bDPTxAutoTest_EN) {
+		ubTemp[0] = 0x1;
+		drm_dp_dpcd_write(&mtk_dp->aux, DPCD_00600, ubTemp, 0x1);
+
+		ubLinkRate = mtk_dp->rx_cap[1];
+		ubLaneCount = mtk_dp->rx_cap[2] & 0x1F;
+
+#if !ENABLE_DPTX_FIX_LRLC
+		mtk_dp->training_info.ubLinkRate =
+			(ubLinkRate >= mtk_dp->training_info.ubSysMaxLinkRate) ?
+			mtk_dp->training_info.ubSysMaxLinkRate : ubLinkRate;
+		mtk_dp->training_info.ubLinkLaneCount =
+			(ubLaneCount >= MAX_LANECOUNT) ?
+			MAX_LANECOUNT : ubLaneCount;
+		if (mtk_dp->training_info.ubLinkRate > 0x14) {
+			if (mtk_dp->training_info.ubLinkLaneCount > 2)
+				mtk_dp->training_info.ubLinkLaneCount = 2;
+		}
+#endif
+		if (mtk_dp->training_info.bSinkEXTCAP_En)
+			drm_dp_dpcd_read(&mtk_dp->aux, DPCD_02002, ubTemp, 0x1);
+		else
+			drm_dp_dpcd_read(&mtk_dp->aux, DPCD_00200, ubTemp, 0x1);
+
+		if ((ubTemp[0x0] & 0xBF) != 0)
+			mtk_dp->training_info.ubSinkCountNum = ubTemp[0x0]&0xBF;
+	}
+
+	ubLinkRate = mtk_dp->training_info.ubLinkRate;
+	ubLaneCount = mtk_dp->training_info.ubLinkLaneCount;
+
+	switch (ubLinkRate) {
+	case DP_LINKRATE_RBR:
+	case DP_LINKRATE_HBR:
+	case DP_LINKRATE_HBR2:
+	case DP_LINKRATE_HBR25:
+	case DP_LINKRATE_HBR3:
+		break;
+	default:
+		mtk_dp->training_info.ubLinkRate = DP_LINKRATE_HBR3;
+		break;
+	};
+
+#if !ENABLE_DPTX_FIX_LRLC
+	maxLinkRate = ubLinkRate;
+	ubTrainTimeLimits = 0x6;
+#endif
+	do {
+		mtk_dp->training_info.cr_done = false;
+		mtk_dp->training_info.eq_done = false;
+
+		mdrv_DPTx_TrainingChangeMode(mtk_dp);
+		ret = mdrv_DPTx_TrainingFlow(mtk_dp, ubLinkRate, ubLaneCount);
+		if (ret == DPTX_PLUG_OUT || ret == DPTX_TRANING_STATE_CHANGE)
+			return ret;
+
+		if (!mtk_dp->training_info.cr_done) {
+#if !ENABLE_DPTX_FIX_LRLC
+			switch (ubLinkRate) {
+			case DP_LINKRATE_RBR:
+				ubLaneCount = ubLaneCount/2;
+				ubLinkRate = maxLinkRate;
+				if (ubLaneCount == 0x0) {
+					mtk_dp->training_state
+						= DPTX_NTSTATE_DPIDLE;
+					return DPTX_TRANING_FAIL;
+				}
+				break;
+			case DP_LINKRATE_HBR:
+				ubLinkRate = DP_LINKRATE_RBR;
+				break;
+			case DP_LINKRATE_HBR2:
+				ubLinkRate = DP_LINKRATE_HBR;
+				break;
+			case DP_LINKRATE_HBR3:
+				ubLinkRate = DP_LINKRATE_HBR2;
+				break;
+			default:
+				return DPTX_TRANING_FAIL;
+			};
+#endif
+			ubTrainTimeLimits--;
+		} else if (!mtk_dp->training_info.eq_done) {
+#if !ENABLE_DPTX_FIX_LRLC
+			if (ubLaneCount == DP_LANECOUNT_4)
+				ubLaneCount = DP_LANECOUNT_2;
+			else if (ubLaneCount == DP_LANECOUNT_2)
+				ubLaneCount = DP_LANECOUNT_1;
+			else
+				return DPTX_TRANING_FAIL;
+#endif
+			ubTrainTimeLimits--;
+		} else
+			return DPTX_NOERR;
+
+	} while (ubTrainTimeLimits > 0);
+
+	return DPTX_TRANING_FAIL;
+}
+
+static int mdrv_DPTx_Training_Handler(struct mtk_dp *mtk_dp)
+{
+	int ret = DPTX_NOERR;
+
+	ret = mdrv_DPTx_HPD_HandleInThread(mtk_dp);
+
+	if (!mtk_dp->training_info.bCablePlugIn)
+		return DPTX_PLUG_OUT;
+
+	if (mtk_dp->training_state == DPTX_NTSTATE_NORMAL)
+		return ret;
+
+	if (mtk_dp->training_state_pre != mtk_dp->training_state) {
+		mdrv_DPTx_Print_TrainingState(mtk_dp->training_state);
+
+		mtk_dp->training_state_pre = mtk_dp->training_state;
+	}
+
+	switch (mtk_dp->training_state) {
+	case DPTX_NTSTATE_STARTUP:
+		mtk_dp->training_state = DPTX_NTSTATE_CHECKCAP;
+		break;
+
+	case DPTX_NTSTATE_CHECKCAP:
+		if (mdrv_DPTx_CheckSinkCap(mtk_dp)) {
+			mtk_dp->training_info.ucCheckCapTimes = 0;
+			mtk_dp->training_state = DPTX_NTSTATE_CHECKEDID;
+		} else {
+			BYTE uaCheckTimes = 0;
+
+			mtk_dp->training_info.ucCheckCapTimes++;
+			uaCheckTimes = mtk_dp->training_info.ucCheckCapTimes;
+
+			if (uaCheckTimes > DPTX_CheckSinkCap_TimeOutCnt) {
+				mtk_dp->training_info.ucCheckCapTimes = 0;
+				mtk_dp->training_state = DPTX_NTSTATE_DPIDLE;
+				ret = DPTX_TIMEOUT;
+			}
+		}
+		break;
+
+	case DPTX_NTSTATE_CHECKEDID:
+		if (mtk_dp->edid)
+			mtk_dp->info.audio_caps
+				= mdrv_DPTx_getAudioCaps(mtk_dp);
+
+		mtk_dp->training_state = DPTX_NTSTATE_TRAINING_PRE;
+		break;
+
+	case DPTX_NTSTATE_TRAINING_PRE:
+		mtk_dp->training_state = DPTX_NTSTATE_TRAINING;
+		break;
+
+	case DPTX_NTSTATE_TRAINING:
+		ret = mdrv_DPTx_SetTrainingStart(mtk_dp);
+		if (ret == DPTX_NOERR) {
+			mdrv_DPTx_VideoMute(mtk_dp, true);
+			mdrv_DPTx_AudioMute(mtk_dp, true);
+			mtk_dp->training_state = DPTX_NTSTATE_CHECKTIMING;
+			mtk_dp->dp_ready = true;
+			mhal_DPTx_EnableFEC(mtk_dp, mtk_dp->has_fec);
+		}  else if (ret != DPTX_TRANING_STATE_CHANGE)
+			mtk_dp->training_state = DPTX_NTSTATE_DPIDLE;
+
+		ret = DPTX_NOERR;
+		break;
+
+	case DPTX_NTSTATE_CHECKTIMING:
+		mtk_dp->training_state = DPTX_NTSTATE_NORMAL;
+		break;
+	case DPTX_NTSTATE_NORMAL:
+		break;
+	case DPTX_NTSTATE_POWERSAVE:
+		break;
+	case DPTX_NTSTATE_DPIDLE:
+		break;
+	default:
+		break;
+	}
+
+	return ret;
+}
+
+static int mdrv_DPTx_Handle(struct mtk_dp *mtk_dp)
+{
+	int ret = DPTX_NOERR;
+
+	if (!mtk_dp->training_info.bCablePlugIn)
+		return DPTX_PLUG_OUT;
+
+	if (mtk_dp->state != mtk_dp->state_pre)
+		mtk_dp->state_pre = mtk_dp->state;
+
+	switch (mtk_dp->state) {
+	case DPTXSTATE_INITIAL:
+		mdrv_DPTx_VideoMute(mtk_dp, true);
+		mdrv_DPTx_AudioMute(mtk_dp, true);
+		mtk_dp->state = DPTXSTATE_IDLE;
+		break;
+
+	case DPTXSTATE_IDLE:
+		if (mtk_dp->training_state == DPTX_NTSTATE_NORMAL)
+			mtk_dp->state = DPTXSTATE_PREPARE;
+		break;
+
+	case DPTXSTATE_PREPARE:
+		if (mtk_dp->bUeventToHwc)
+			mtk_dp->bUeventToHwc = false;
+
+		if (mtk_dp->info.bPatternGen) {
+			mtk_dp->video_enable = true;
+			mtk_dp->info.input_src = DPTX_SRC_PG;
+		}
+
+		if (mtk_dp->video_enable) {
+			mtk_dp_video_config(mtk_dp);
+			mdrv_DPTx_Video_Enable(mtk_dp, true);
+		}
+
+		if (mtk_dp->audio_enable && (mtk_dp->info.audio_caps != 0)) {
+			mdrv_DPTx_I2S_Audio_Config(mtk_dp);
+			mdrv_DPTx_I2S_Audio_Enable(mtk_dp, true);
+		}
+
+		mtk_dp->state = DPTXSTATE_NORMAL;
+		break;
+
+	case DPTXSTATE_NORMAL:
+		if (mtk_dp->training_state != DPTX_NTSTATE_NORMAL) {
+			mdrv_DPTx_VideoMute(mtk_dp, true);
+			mdrv_DPTx_AudioMute(mtk_dp, true);
+			mdrv_DPTx_StopSentSDP(mtk_dp);
+			mtk_dp->state = DPTXSTATE_IDLE;
+		}
+		break;
+
+	default:
+		break;
+	}
+
+	return ret;
+}
+
+static void mdrv_DPTx_HPD_HandleInISR(struct mtk_dp *mtk_dp)
+{
+	bool ubCurrentHPD = mhal_DPTx_GetHPDPinLevel(mtk_dp);
+
+	if (mtk_dp->training_info.usPHY_STS == HPD_INITIAL_STATE)
+		return;
+
+	if ((mtk_dp->training_info.usPHY_STS & (HPD_CONNECT|HPD_DISCONNECT))
+		== (HPD_CONNECT|HPD_DISCONNECT)) {
+		if (ubCurrentHPD)
+			mtk_dp->training_info.usPHY_STS &= ~HPD_DISCONNECT;
+		else
+			mtk_dp->training_info.usPHY_STS &= ~HPD_CONNECT;
+	}
+
+	if ((mtk_dp->training_info.usPHY_STS & (HPD_INT_EVNET|HPD_DISCONNECT))
+		== (HPD_INT_EVNET|HPD_DISCONNECT)) {
+		if (ubCurrentHPD)
+			mtk_dp->training_info.usPHY_STS &= ~HPD_DISCONNECT;
+	}
+
+	if (mtk_dp->training_info.bCablePlugIn)
+		mtk_dp->training_info.usPHY_STS &= ~HPD_CONNECT;
+	else
+		mtk_dp->training_info.usPHY_STS &= ~HPD_DISCONNECT;
+
+	if (mtk_dp->training_info.usPHY_STS & HPD_CONNECT) {
+		mtk_dp->training_info.usPHY_STS &= ~HPD_CONNECT;
+		mtk_dp->training_info.bCablePlugIn = true;
+		mtk_dp->training_info.bCableStateChange = true;
+		mtk_dp->bUeventToHwc = true;
+		queue_work(mtk_dp->workqueue, &mtk_dp->work);
+	}
+
+	if (mtk_dp->training_info.usPHY_STS & HPD_DISCONNECT) {
+		mtk_dp->training_info.usPHY_STS &= ~HPD_DISCONNECT;
+		mtk_dp->training_info.bCablePlugIn = false;
+		mtk_dp->training_info.bCableStateChange = true;
+		mtk_dp->training_state = DPTX_NTSTATE_STARTUP;
+		mtk_dp->training_state_pre = DPTX_NTSTATE_STARTUP;
+		mtk_dp->bUeventToHwc = true;
+		queue_work(mtk_dp->workqueue, &mtk_dp->work);
+	}
+
+	if (mtk_dp->training_info.usPHY_STS & HPD_INT_EVNET)
+		queue_work(mtk_dp->workqueue, &mtk_dp->work);
+
+}
+
+static int DPTx_Int_Count;
+void mdrv_DPTx_HPD_ISREvent(struct mtk_dp *mtk_dp)
+{
+	u8 ubIsrEnable = 0xF1;
+	u16 ubSWStatus = mhal_DPTx_GetSWIRQStatus(mtk_dp);
+	u8 ubHWStatus_undefine =  mhal_DPTx_GetHPDIRQStatus(mtk_dp);
+	u8 ubHWStatus =  ubHWStatus_undefine&(~ubIsrEnable);
+
+	DPTx_Int_Count++;
+
+	mtk_dp->irq_status = (ubHWStatus | ubSWStatus);
+	mtk_dp->training_info.usPHY_STS |= (ubHWStatus | ubSWStatus);
+
+	mdrv_DPTx_HPD_HandleInISR(mtk_dp);
+
+	if (ubSWStatus)
+		mhal_DPTx_SWInterruptClr(mtk_dp, ubSWStatus);
+
+	if (ubHWStatus)
+		mhal_DPTx_HPDInterruptClr(mtk_dp, ubHWStatus);
+}
+
+static void mdrv_DPTx_ISR(struct mtk_dp *mtk_dp)
+{
+	mhal_DPTx_ISR(mtk_dp);
+}
+
+static void mdrv_DPTx_InitPort(struct mtk_dp *mtk_dp)
+{
+	mhal_DPTx_PHY_SetIdlePattern(mtk_dp, true);
+	mdrv_DPTx_InitVariable(mtk_dp);
+
+	mhal_DPTx_InitialSetting(mtk_dp);
+	mhal_DPTx_AuxSetting(mtk_dp);
+	mhal_DPTx_DigitalSetting(mtk_dp);
+	mhal_DPTx_PHYSetting(mtk_dp);
+	mhal_DPTx_HPDDetectSetting(mtk_dp);
+
+	mhal_DPTx_DigitalSwReset(mtk_dp);
+	mhal_DPTx_Set_Efuse_Value(mtk_dp);
+}
+
+void mdrv_DPTx_Video_Enable(struct mtk_dp *mtk_dp, bool bEnable)
+{
+	if (bEnable) {
+		mdrv_DPTx_SetDPTXOut(mtk_dp);
+		mdrv_DPTx_VideoMute(mtk_dp, false);
+		mhal_DPTx_Verify_Clock(mtk_dp);
+	} else
+		mdrv_DPTx_VideoMute(mtk_dp, true);
+}
+
+static void mdrv_DPTx_Set_Color_Format(struct mtk_dp *mtk_dp, u8 ucColorFormat)
+{
+	mtk_dp->info.format = ucColorFormat;
+	mhal_DPTx_SetColorFormat(mtk_dp, ucColorFormat);
+}
+
+static void mdrv_DPTx_Set_Color_Depth(struct mtk_dp *mtk_dp, u8 ucColorDepth)
+{
+	mtk_dp->info.depth = ucColorDepth;
+	mhal_DPTx_SetColorDepth(mtk_dp, ucColorDepth);
+}
+
+void mdrv_DPTx_I2S_Audio_Enable(struct mtk_dp *mtk_dp, bool bEnable)
+{
+	if (bEnable)
+		mdrv_DPTx_AudioMute(mtk_dp, false);
+	else
+		mdrv_DPTx_AudioMute(mtk_dp, true);
+}
+
+static void mdrv_DPTx_I2S_Audio_Set_MDiv(struct mtk_dp *mtk_dp, u8 ucDiv)
+{
+	char bTable[7][5] = {"X2", "X4", "X8", "N/A", "/2", "/4", "/8"};
+
+	dev_info(mtk_dp->dev, "I2S Set Audio M Divider = %s\n", bTable[ucDiv-1]);
+	mhal_DPTx_Audio_M_Divider_Setting(mtk_dp, ucDiv);
+}
+
+void mdrv_DPTx_I2S_Audio_Config(struct mtk_dp *mtk_dp)
+{
+	u8 ucChannel, ucFs, ucWordlength;
+	unsigned int tmp = mtk_dp->info.audio_config;
+
+	if (!mtk_dp->dp_ready) {
+		pr_err("%s, DP is not ready!\n", __func__);
+		return;
+	}
+
+	ucChannel = (tmp >> DP_CAPABILITY_CHANNEL_SFT)
+		& DP_CAPABILITY_CHANNEL_MASK;
+	ucFs = (tmp >> DP_CAPABILITY_SAMPLERATE_SFT)
+		& DP_CAPABILITY_SAMPLERATE_MASK;
+	ucWordlength = (tmp >> DP_CAPABILITY_BITWIDTH_SFT)
+			& DP_CAPABILITY_BITWIDTH_MASK;
+
+	switch (ucChannel) {
+	case DP_CHANNEL_2:
+		ucChannel = 2;
+		break;
+	case DP_CHANNEL_8:
+		ucChannel = 8;
+		break;
+	default:
+		ucChannel = 2;
+		break;
+	}
+
+	switch (ucFs) {
+	case DP_SAMPLERATE_32:
+		ucFs = FS_32K;
+		break;
+	case DP_SAMPLERATE_44:
+		ucFs = FS_44K;
+		break;
+	case DP_SAMPLERATE_48:
+		ucFs = FS_48K;
+		break;
+	case DP_SAMPLERATE_96:
+		ucFs = FS_96K;
+		break;
+	case DP_SAMPLERATE_192:
+		ucFs = FS_192K;
+		break;
+	default:
+		ucFs = FS_48K;
+		break;
+	}
+
+	switch (ucWordlength) {
+	case DP_BITWIDTH_16:
+		ucWordlength = WL_16bit;
+		break;
+	case DP_BITWIDTH_20:
+		ucWordlength = WL_20bit;
+		break;
+	case DP_BITWIDTH_24:
+		ucWordlength = WL_24bit;
+		break;
+	default:
+		ucWordlength = WL_24bit;
+		break;
+	}
+
+	mdrv_DPTx_I2S_Audio_SDP_Channel_Setting(mtk_dp, ucChannel,
+		ucFs, ucWordlength);
+	mdrv_DPTx_I2S_Audio_Ch_Status_Set(mtk_dp, ucChannel,
+		ucFs, ucWordlength);
+
+	mhal_DPTx_Audio_PG_EN(mtk_dp, ucChannel, ucFs, false);
+	mdrv_DPTx_I2S_Audio_Set_MDiv(mtk_dp, 5);
+}
+
+void mdrv_DPTx_I2S_Audio_SDP_Channel_Setting(struct mtk_dp *mtk_dp,
+	u8 ucChannel, u8 ucFs, u8 ucWordlength)
+{
+	u8 SDP_DB[32] = {0};
+	u8 SDP_HB[4] = {0};
+
+	SDP_HB[1] = DP_SPEC_SDPTYP_AINFO;
+	SDP_HB[2] = 0x1B;
+	SDP_HB[3] = 0x48;
+
+	SDP_DB[0x0] = 0x10 | (ucChannel-1); //L-PCM[7:4], channel-1[2:0]
+	SDP_DB[0x1] = ucFs << 2 | ucWordlength; // fs[4:2], len[1:0]
+	SDP_DB[0x2] = 0x0;
+
+	if (ucChannel == 8)
+		SDP_DB[0x3] = 0x13;
+	else
+		SDP_DB[0x3] = 0x00;
+
+	mhal_DPTx_Audio_SDP_Setting(mtk_dp, ucChannel);
+	mdrv_DPTx_SPKG_SDP(mtk_dp, true, DPTx_SDPTYP_AUI, SDP_HB, SDP_DB);
+}
+
+void mdrv_DPTx_I2S_Audio_Ch_Status_Set(struct mtk_dp *mtk_dp, u8 ucChannel,
+	u8 ucFs, u8 ucWordlength)
+{
+	mhal_DPTx_Audio_Ch_Status_Set(mtk_dp, ucChannel, ucFs, ucWordlength);
+}
+
+void mdrv_DPTx_FEC_Ready(struct mtk_dp *mtk_dp, u8 err_cnt_sel)
+{
+	u8 i, Data[3];
+
+	drm_dp_dpcd_read(&mtk_dp->aux, 0x90, Data, 0x1);
+
+	/* FEC error count select 120[3:1]:         *
+	 * 000b: FEC_ERROR_COUNT_DIS                *
+	 * 001b: UNCORRECTED_BLOCK_ERROR_COUNT      *
+	 * 010b: CORRECTED_BLOCK_ERROR_COUNT        *
+	 * 011b: BIT_ERROR_COUNT                    *
+	 * 100b: PARITY_BLOCK_ERROR_COUNT           *
+	 * 101b: PARITY_BIT_ERROR_COUNT             *
+	 */
+	if (Data[0] & BIT0) {
+		mtk_dp->has_fec = true;
+		Data[0] = (err_cnt_sel << 1) | 0x1;     //FEC Ready
+		drm_dp_dpcd_write(&mtk_dp->aux, 0x120, Data, 0x1);
+		drm_dp_dpcd_read(&mtk_dp->aux, 0x280, Data, 0x3);
+		for (i = 0; i < 3; i++)
+			dev_info(mtk_dp->dev, "FEC status & error Count: 0x%x\n", Data[i]);
+	}
+}
+
+void mtk_dp_video_config(struct mtk_dp *mtk_dp)
+{
+	struct DPTX_TIMING_PARAMETER *DPTX_TBL = &mtk_dp->info.DPTX_OUTBL;
+	u32 mvid = 0;
+	bool overwrite = false;
+	struct videomode vm = { 0 };
+
+	drm_display_mode_to_videomode(&mtk_dp->mode, &vm);
+
+	if (!mtk_dp->dp_ready) {
+		pr_err("%s, DP is not ready!\n", __func__);
+		return;
+	}
+
+	if (mtk_dp->info.resolution >= SINK_MAX) {
+		pr_err("DPTX doesn't support this resolution(%d)!\n",
+			mtk_dp->info.resolution);
+		return;
+	}
+
+	DPTX_TBL->FrameRate = mtk_dp->mode.clock * 1000 / mtk_dp->mode.htotal / mtk_dp->mode.vtotal;
+	DPTX_TBL->Htt = mtk_dp->mode.htotal;
+	DPTX_TBL->Hbp = vm.hback_porch;
+	DPTX_TBL->Hsw = vm.hsync_len;
+	DPTX_TBL->bHsp = 0;
+	DPTX_TBL->Hfp = vm.hfront_porch;
+	DPTX_TBL->Hde = vm.hactive;
+	DPTX_TBL->Vtt = mtk_dp->mode.vtotal;
+	DPTX_TBL->Vbp = vm.vback_porch;
+	DPTX_TBL->Vsw = vm.vsync_len;
+	DPTX_TBL->bVsp = 0;
+	DPTX_TBL->Vfp = vm.vfront_porch;
+	DPTX_TBL->Vde = vm.vactive;
+
+	mhal_DPTx_OverWrite_MN(mtk_dp, overwrite, mvid, 0x8000);
+
+	if (mtk_dp->has_dsc) {
+		uint8_t Data[1];
+
+		Data[0] = (u8) mtk_dp->dsc_enable;
+		drm_dp_dpcd_write(&mtk_dp->aux, 0x160, Data, 0x1);
+	}
+
+	//interlace not support
+	DPTX_TBL->Video_ip_mode = DPTX_VIDEO_PROGRESSIVE;
+	mhal_DPTx_SetMSA(mtk_dp);
+
+	mdrv_DPTx_Set_MISC(mtk_dp);
+
+	mdrv_DPTx_Set_Color_Depth(mtk_dp, mtk_dp->info.depth);
+	mdrv_DPTx_Set_Color_Format(mtk_dp, mtk_dp->info.format);
+}
+
+struct edid *mtk_dp_handle_edid(struct mtk_dp *mtk_dp)
+{
+	struct drm_connector *connector = &mtk_dp->conn;
+
+	/* use cached edid if we have one */
+	if (mtk_dp->edid) {
+		/* invalid edid */
+		if (IS_ERR(mtk_dp->edid))
+			return NULL;
+
+		return drm_edid_duplicate(mtk_dp->edid);
+	}
+
+	return drm_get_edid(connector, &mtk_dp->aux.ddc);
+}
+
+static void mtk_dp_update_plugged_status(struct mtk_dp *mtk_dp)
+{
+	bool connected;
+
+	mutex_lock(&mtk_dp->update_plugged_status_lock);
+	connected = mhal_DPTx_GetHPDPinLevel(mtk_dp);
+	if (mtk_dp->plugged_cb && mtk_dp->codec_dev)
+		mtk_dp->plugged_cb(mtk_dp->codec_dev, connected);
+	mutex_unlock(&mtk_dp->update_plugged_status_lock);
+}
+
+static void mtk_dp_work_func(struct work_struct *work)
+{
+	int event;
+	struct mtk_dp *mtk_dp = container_of(work, struct mtk_dp, work);
+
+	event = mhal_DPTx_GetHPDPinLevel(mtk_dp) ? connector_status_connected :
+		connector_status_disconnected;
+
+	if (event < 0)
+		return;
+
+	if (mtk_dp->bridge_attached)
+		drm_helper_hpd_irq_event(mtk_dp->bridge.dev);
+
+	if (event == connector_status_disconnected)
+		mtk_dp_update_plugged_status(mtk_dp);
+
+	if (mtk_dp->training_info.usPHY_STS & HPD_INT_EVNET) {
+		mtk_dp->training_info.usPHY_STS &= ~HPD_INT_EVNET;
+		mdrv_DPTx_CheckSinkHPDEvent(mtk_dp);
+	}
+}
+
+static irqreturn_t mtk_dp_hpd_event(int hpd, void *dev)
+{
+	struct mtk_dp *mtk_dp = dev;
+
+	mdrv_DPTx_ISR(mtk_dp);
+
+	return IRQ_HANDLED;
+}
+
+static int mtk_dp_dt_parse_pdata(struct mtk_dp *mtk_dp,
+		struct platform_device *pdev)
+{
+	struct resource regs;
+	struct device *dev = &pdev->dev;
+	int ret = 0;
+
+	if (of_address_to_resource(dev->of_node, 0, &regs) != 0)
+		dev_err(dev, "Missing reg in %s node\n",
+		dev->of_node->full_name);
+
+	mtk_dp->regs = of_iomap(dev->of_node, 0);
+	mtk_dp->dp_tx_clk = devm_clk_get(dev, "dp_tx_faxi");
+	if (IS_ERR(mtk_dp->dp_tx_clk)) {
+		ret = PTR_ERR(mtk_dp->dp_tx_clk);
+		dev_err(dev, "Failed to get dptx clock: %d\n", ret);
+		mtk_dp->dp_tx_clk = NULL;
+	}
+
+	return 0;
+}
+
+static inline struct mtk_dp *mtk_dp_ctx_from_conn(struct drm_connector *c)
+{
+	return container_of(c, struct mtk_dp, conn);
+}
+
+static enum drm_connector_status mtk_dp_conn_detect(struct drm_connector *conn,
+	bool force)
+{
+	struct mtk_dp *mtk_dp = mtk_dp_ctx_from_conn(conn);
+
+	return ((mhal_DPTx_GetHPDPinLevel(mtk_dp)) ? connector_status_connected :
+		connector_status_disconnected);
+}
+
+static enum drm_connector_status mtk_dp_bdg_detect(struct drm_bridge *bridge)
+{
+	struct mtk_dp *mtk_dp = dp_from_bridge(bridge);
+	enum drm_connector_status ret;
+
+	ret = mhal_DPTx_GetHPDPinLevel(mtk_dp) ? connector_status_connected :
+			connector_status_disconnected;
+
+	if (mtk_dp->driver_data && mtk_dp->driver_data->is_edp)
+		return connector_status_connected;
+	else
+		return ret;
+}
+
+static void mtk_dp_conn_destroy(struct drm_connector *conn)
+{
+	drm_connector_cleanup(conn);
+}
+
+static const struct drm_connector_funcs mtk_dp_connector_funcs = {
+	.detect = mtk_dp_conn_detect,
+	.fill_modes = drm_helper_probe_single_connector_modes,
+	.destroy = mtk_dp_conn_destroy,
+	.reset = drm_atomic_helper_connector_reset,
+	.atomic_duplicate_state = drm_atomic_helper_connector_duplicate_state,
+	.atomic_destroy_state = drm_atomic_helper_connector_destroy_state,
+};
+
+static int mtk_dp_conn_mode_valid(struct drm_connector *conn,
+		struct drm_display_mode *mode)
+{
+	return MODE_OK;
+}
+
+static struct drm_encoder *mtk_dp_conn_best_enc(struct drm_connector *conn)
+{
+	struct mtk_dp *mtk_dp = dp_from_conn(conn);
+
+	return mtk_dp->bridge.encoder;
+}
+
+static int mtk_dp_conn_get_modes(struct drm_connector *conn)
+{
+	struct mtk_dp *mtk_dp = dp_from_conn(conn);
+	int ret;
+	int num_modes = 0;
+
+	if (mtk_dp->edid) {
+		drm_connector_update_edid_property(&mtk_dp->conn,
+			mtk_dp->edid);
+		num_modes = drm_add_edid_modes(&mtk_dp->conn, mtk_dp->edid);
+		return num_modes;
+	} else {
+		mtk_dp->edid = drm_get_edid(conn, &mtk_dp->aux.ddc);
+		if (!mtk_dp->edid) {
+			DRM_ERROR("Failed to read EDID\n");
+			goto error;
+		}
+
+		ret = drm_connector_update_edid_property(conn, mtk_dp->edid);
+		if (ret) {
+			DRM_ERROR("Failed to update EDID property: %d\n", ret);
+			goto error;
+		}
+
+		num_modes = drm_add_edid_modes(conn, mtk_dp->edid);
+		return num_modes;
+	}
+
+error:
+	return num_modes;
+}
+
+static int mtk_dp_bdg_get_modes(struct drm_bridge *bridge, struct drm_connector *conn)
+{
+	struct mtk_dp *mtk_dp = dp_from_bridge(bridge);
+	int ret;
+	int num_modes = 0;
+
+	if (mtk_dp->edid) {
+		drm_connector_update_edid_property(&mtk_dp->conn,
+			mtk_dp->edid);
+		num_modes = drm_add_edid_modes(&mtk_dp->conn, mtk_dp->edid);
+		return num_modes;
+	} else {
+		mtk_dp->edid = drm_get_edid(conn, &mtk_dp->aux.ddc);
+		if (!mtk_dp->edid) {
+			DRM_ERROR("Failed to read EDID\n");
+			goto error;
+		}
+
+		ret = drm_connector_update_edid_property(conn, mtk_dp->edid);
+		if (ret) {
+			DRM_ERROR("Failed to update EDID property: %d\n", ret);
+			goto error;
+		}
+
+		num_modes = drm_add_edid_modes(conn, mtk_dp->edid);
+		return num_modes;
+	}
+
+error:
+	return num_modes;
+}
+
+static const struct drm_connector_helper_funcs
+		mtk_dp_connector_helper_funcs = {
+	.get_modes = mtk_dp_conn_get_modes,
+	.mode_valid = mtk_dp_conn_mode_valid,
+	.best_encoder = mtk_dp_conn_best_enc,
+};
+
+static struct edid *mtk_get_edid(struct drm_bridge *bridge,
+			   struct drm_connector *connector)
+{
+	struct mtk_dp *mtk_dp = dp_from_bridge(bridge);
+	bool poweroff = !mtk_dp->powered;
+
+	drm_bridge_chain_pre_enable(bridge);
+
+	kfree(mtk_dp->edid);
+
+	mtk_dp->edid = drm_get_edid(connector, &mtk_dp->aux.ddc);
+
+	mtk_dp->curr_conn = connector;
+
+	/*
+	 * If we call the get_edid() function without having enabled the chip
+	 * before, return the chip to its original power state.
+	 */
+	if (poweroff)
+		drm_bridge_chain_post_disable(bridge);
+
+	if (mtk_dp->edid == NULL)
+		return NULL;
+
+	return drm_edid_duplicate(mtk_dp->edid);
+}
+
+
+static ssize_t mtk_dp_aux_transfer(struct drm_dp_aux *mtk_aux,
+	struct drm_dp_aux_msg *msg)
+{
+	u8 ubCmd;
+	void *pData;
+	size_t ubLength, ret = 0;
+	u32 usADDR;
+	bool ack = false;
+	struct mtk_dp *mtk_dp;
+
+	mtk_dp = container_of(mtk_aux, struct mtk_dp, aux);
+	ubCmd = msg->request;
+	usADDR = msg->address;
+	ubLength = msg->size;
+	pData = msg->buffer;
+
+	switch (ubCmd) {
+	case DP_AUX_I2C_MOT:
+	case DP_AUX_I2C_WRITE:
+	case DP_AUX_NATIVE_WRITE:
+	case DP_AUX_I2C_WRITE_STATUS_UPDATE:
+	case DP_AUX_I2C_WRITE_STATUS_UPDATE | DP_AUX_I2C_MOT:
+		ubCmd &= ~DP_AUX_I2C_WRITE_STATUS_UPDATE;
+		ack = mdrv_DPTx_AuxWrite_DPCD(mtk_dp, ubCmd,
+			usADDR, ubLength, pData);
+		break;
+
+	case DP_AUX_I2C_READ:
+	case DP_AUX_NATIVE_READ:
+	case DP_AUX_I2C_READ | DP_AUX_I2C_MOT:
+		ack = mdrv_DPTx_AuxRead_DPCD(mtk_dp, ubCmd,
+			usADDR, ubLength, pData);
+		break;
+
+	default:
+		pr_err("invalid aux cmd = %d\n", ubCmd);
+		ret = -EINVAL;
+		break;
+	}
+
+	if (ack) {
+		msg->reply = DP_AUX_NATIVE_REPLY_ACK | DP_AUX_I2C_REPLY_ACK;
+		ret = ubLength;
+	} else {
+		msg->reply = DP_AUX_NATIVE_REPLY_NACK | DP_AUX_I2C_REPLY_NACK;
+		ret = -EAGAIN;
+	}
+
+	return ret;
+}
+
+static void mtk_dp_aux_init(struct mtk_dp *mtk_dp)
+{
+	drm_dp_aux_init(&mtk_dp->aux);
+
+	mtk_dp->aux.name = kasprintf(GFP_KERNEL, "DPDDC-MTK");
+	mtk_dp->aux.transfer = mtk_dp_aux_transfer;
+}
+
+static void mtk_dp_HPDInterruptSet(struct mtk_dp *mtk_dp, int bstatus)
+{
+	if ((bstatus == HPD_CONNECT && !mtk_dp->bPowerOn)
+		|| (bstatus == HPD_DISCONNECT && mtk_dp->bPowerOn)
+		|| (bstatus == HPD_INT_EVNET && mtk_dp->bPowerOn)) {
+
+		if (bstatus == HPD_CONNECT) {
+			int ret;
+
+			if (mtk_dp->dp_tx_clk) {
+				ret = clk_prepare_enable(mtk_dp->dp_tx_clk);
+				if (ret < 0)
+					pr_err("Fail to enable dptx clock: %d\n", ret);
+			}
+			mdrv_DPTx_InitPort(mtk_dp);
+			mhal_DPTx_AnalogPowerOnOff(mtk_dp, true);
+			mtk_dp->bPowerOn = true;
+		}
+
+		mhal_DPTx_HPDInterruptEnable(mtk_dp, true);
+		return;
+	}
+}
+
+void mtk_dp_poweroff(struct mtk_dp *mtk_dp)
+{
+	mutex_lock(&mtk_dp->dp_lock);
+
+	mtk_dp_HPDInterruptSet(mtk_dp, HPD_DISCONNECT);
+	mutex_unlock(&mtk_dp->dp_lock);
+}
+
+void mtk_dp_poweron(struct mtk_dp *mtk_dp)
+{
+	mutex_lock(&mtk_dp->dp_lock);
+
+	mtk_dp_HPDInterruptSet(mtk_dp, HPD_CONNECT);
+	msWrite2Byte(mtk_dp, TOP_OFFSET, 0x2); /* config only aux */
+	mutex_unlock(&mtk_dp->dp_lock);
+}
+
+static void mtk_dp_bridge_detach(struct drm_bridge *bridge)
+{
+	struct mtk_dp *mtk_dp = dp_from_bridge(bridge);
+
+	mtk_dp->bridge_attached = 0;
+}
+
+static int mtk_dp_bridge_attach(struct drm_bridge *bridge,
+			enum drm_bridge_attach_flags flags)
+{
+	struct mtk_dp *mtk_dp = dp_from_bridge(bridge);
+	int ret;
+
+	mtk_dp_poweron(mtk_dp);
+
+	if (mtk_dp->next_bridge) {
+		ret = drm_bridge_attach(bridge->encoder, mtk_dp->next_bridge, &mtk_dp->bridge, flags);
+		if (ret) {
+			dev_err(mtk_dp->dev,
+				"Failed to attach external bridge: %d\n", ret);
+			return ret;
+		}
+	}
+
+	mtk_dp->bridge_attached = 1;
+
+	if (flags & DRM_BRIDGE_ATTACH_NO_CONNECTOR) {
+		DRM_ERROR("Fix bridge driver to make connector optional!");
+		return 0;
+	}
+
+	mtk_dp->drm_dev = bridge->dev;
+
+	ret = drm_connector_init(bridge->dev, &mtk_dp->conn, &mtk_dp_connector_funcs,
+				 DRM_MODE_CONNECTOR_DisplayPort);
+	if (ret)
+		return ret;
+	drm_connector_helper_add(&mtk_dp->conn, &mtk_dp_connector_helper_funcs);
+
+	mtk_dp->conn.polled = DRM_CONNECTOR_POLL_HPD;
+	mtk_dp->conn.interlace_allowed = false;
+	mtk_dp->conn.doublescan_allowed = false;
+
+	ret = drm_connector_attach_encoder(&mtk_dp->conn,
+						bridge->encoder);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+static bool mtk_dp_bridge_mode_fixup(struct drm_bridge *bridge,
+				       const struct drm_display_mode *mode,
+				       struct drm_display_mode *adjusted_mode)
+{
+	return true;
+}
+
+static void mtk_dp_bridge_disable(struct drm_bridge *bridge)
+{
+	struct mtk_dp *mtk_dp = dp_from_bridge(bridge);
+	u8 bTempBuffer;
+
+	if (!mtk_dp->enabled)
+		return;
+
+	if (mhal_DPTx_GetHPDPinLevel(mtk_dp)) {
+		bTempBuffer = 0x2;
+		drm_dp_dpcd_write(&mtk_dp->aux, DPCD_00600, &bTempBuffer, 0x1);
+		mdelay(2);
+	}
+
+	msWrite2Byte(mtk_dp, TOP_OFFSET, 0x2); /* config only aux */
+
+	/* for change resolution retraining */
+	mtk_dp->training_state = DPTX_NTSTATE_STARTUP;
+	mtk_dp->training_state_pre = DPTX_NTSTATE_STARTUP;
+	mtk_dp->state = DPTXSTATE_INITIAL;
+	mtk_dp->state_pre = DPTXSTATE_INITIAL;
+	mtk_dp->enabled = false;
+}
+
+static void mtk_dp_bridge_post_disable(struct drm_bridge *bridge)
+{
+	struct mtk_dp *mtk_dp = dp_from_bridge(bridge);
+
+	if (!mtk_dp->powered)
+		return;
+
+	mtk_dp->powered = false;
+}
+
+static void mtk_dp_bridge_mode_set(struct drm_bridge *bridge,
+				     const struct drm_display_mode *mode,
+				     const struct drm_display_mode *adjusted_mode)
+{
+	struct mtk_dp *mtk_dp = dp_from_bridge(bridge);
+
+	drm_mode_copy(&mtk_dp->mode, adjusted_mode);
+}
+
+static void mtk_dp_bridge_pre_enable(struct drm_bridge *bridge)
+{
+	struct mtk_dp *mtk_dp = dp_from_bridge(bridge);
+
+	msWrite4ByteMask(mtk_dp, 0x0008, 0xf << 8, BITMASK(11 : 8));
+
+	mdrv_DPTx_CheckSinkCap(mtk_dp);
+
+	mtk_dp->powered = true;
+}
+
+static void mtk_dp_bridge_enable(struct drm_bridge *bridge)
+{
+	struct mtk_dp *mtk_dp = dp_from_bridge(bridge);
+	int ret = DPTX_NOERR;
+	int i;
+
+	mtk_dp->enabled = true;
+	mtk_dp_update_plugged_status(mtk_dp);
+
+	msWrite2Byte(mtk_dp, TOP_OFFSET, 0x3); /* config mainlink and aux */
+
+	mdrv_DPTx_CheckSinkCap(mtk_dp);
+	//training
+	for (i = 0; i < 50; i++) {
+		ret = mdrv_DPTx_Training_Handler(mtk_dp);
+		if (ret != DPTX_NOERR)
+			break;
+
+		ret = mdrv_DPTx_Handle(mtk_dp);
+		if (ret != DPTX_NOERR)
+			break;
+	}
+
+	mtk_dp_video_config(mtk_dp);
+	mdrv_DPTx_Video_Enable(mtk_dp, true);
+
+	if ((mtk_dp->info.audio_caps != 0)) {
+		mdrv_DPTx_I2S_Audio_Config(mtk_dp);
+		mdrv_DPTx_I2S_Audio_Enable(mtk_dp, true);
+	}
+}
+
+static enum drm_mode_status
+mtk_dp_bridge_mode_valid(struct drm_bridge *bridge,
+			  const struct drm_display_info *info,
+			  const struct drm_display_mode *mode)
+{
+	struct mtk_dp *mtk_dp = dp_from_bridge(bridge);
+	u32 rx_linkrate;
+
+	rx_linkrate = (u32)mtk_dp->training_info.ubLinkRate * 270000;
+
+	if (rx_linkrate * mtk_dp->training_info.ubLinkLaneCount < mode->clock * 24)
+		return MODE_CLOCK_HIGH;
+
+	return MODE_OK;
+}
+
+static const struct drm_bridge_funcs mtk_dp_bridge_funcs = {
+	.detach = mtk_dp_bridge_detach,
+	.attach = mtk_dp_bridge_attach,
+	.mode_fixup = mtk_dp_bridge_mode_fixup,
+	.mode_valid = mtk_dp_bridge_mode_valid,
+	.disable = mtk_dp_bridge_disable,
+	.post_disable = mtk_dp_bridge_post_disable,
+	.mode_set = mtk_dp_bridge_mode_set,
+	.pre_enable = mtk_dp_bridge_pre_enable,
+	.enable = mtk_dp_bridge_enable,
+	.get_edid = mtk_get_edid,
+	.detect = mtk_dp_bdg_detect,
+	.get_modes = mtk_dp_bdg_get_modes,
+};
+
+/*
+ * HDMI audio codec callbacks
+ */
+static int mtk_dp_audio_hw_params(struct device *dev, void *data,
+				    struct hdmi_codec_daifmt *daifmt,
+				    struct hdmi_codec_params *params)
+{
+	struct mtk_dp *mtk_dp = dev_get_drvdata(dev);
+	u8 ucChannel, ucFs, ucWordlength;
+	unsigned int chan = params->cea.channels;
+
+	if (!mtk_dp->dp_ready) {
+		pr_err("%s, DP is not ready!\n", __func__);
+		return -ENODEV;
+	}
+
+	switch (chan) {
+	case 2:
+		ucChannel = 2;
+		break;
+	case 4:
+	case 6:
+	case 8:
+		ucChannel = 8;
+		break;
+	default:
+		ucChannel = 2;
+		break;
+	}
+
+	switch (params->sample_rate) {
+	case 32000:
+		ucFs = FS_32K;
+		break;
+	case 44100:
+		ucFs = FS_44K;
+		break;
+	case 48000:
+		ucFs = FS_48K;
+		break;
+	case 88200:
+		ucFs = FS_88K;
+		break;
+	case 96000:
+		ucFs = FS_96K;
+		break;
+	case 176400:
+		ucFs = FS_176K;
+		break;
+	case 192000:
+		ucFs = FS_192K;
+		break;
+	default:
+		ucFs = FS_48K;
+		break;
+	}
+
+	switch (daifmt->fmt) {
+	case HDMI_I2S:
+	default:
+		ucWordlength = WL_24bit;
+		break;
+	}
+
+	mdrv_DPTx_I2S_Audio_SDP_Channel_Setting(mtk_dp, ucChannel,
+		ucFs, ucWordlength);
+	mdrv_DPTx_I2S_Audio_Ch_Status_Set(mtk_dp, ucChannel,
+		ucFs, ucWordlength);
+
+	mhal_DPTx_Audio_PG_EN(mtk_dp, ucChannel, ucFs, false);
+	mdrv_DPTx_I2S_Audio_Set_MDiv(mtk_dp, 5);
+
+	return 0;
+}
+
+static int mtk_dp_audio_startup(struct device *dev, void *data)
+{
+	struct mtk_dp *mtk_dp = dev_get_drvdata(dev);
+
+	mdrv_DPTx_AudioMute(mtk_dp, false);
+
+	return 0;
+}
+
+static void mtk_dp_audio_shutdown(struct device *dev, void *data)
+{
+	struct mtk_dp *mtk_dp = dev_get_drvdata(dev);
+
+	mdrv_DPTx_AudioMute(mtk_dp, true);
+}
+
+static int mtk_dp_audio_get_eld(struct device *dev, void *data, uint8_t *buf, size_t len)
+{
+	struct mtk_dp *mtk_dp = dev_get_drvdata(dev);
+
+	if (mtk_dp->enabled)
+		memcpy(buf, mtk_dp->curr_conn->eld, min(sizeof(mtk_dp->curr_conn->eld), len));
+	else
+		memset(buf, 0, len);
+
+	return 0;
+}
+
+static int mtk_dp_audio_hook_plugged_cb(struct device *dev, void *data,
+					  hdmi_codec_plugged_cb fn,
+					  struct device *codec_dev)
+{
+	struct mtk_dp *mtk_dp = data;
+
+	mutex_lock(&mtk_dp->update_plugged_status_lock);
+	mtk_dp->plugged_cb = fn;
+	mtk_dp->codec_dev = codec_dev;
+	mutex_unlock(&mtk_dp->update_plugged_status_lock);
+
+	mtk_dp_update_plugged_status(mtk_dp);
+
+	return 0;
+}
+
+static const struct hdmi_codec_ops mtk_dp_audio_codec_ops = {
+	.hw_params = mtk_dp_audio_hw_params,
+	.audio_startup = mtk_dp_audio_startup,
+	.audio_shutdown = mtk_dp_audio_shutdown,
+	//.mute_stream = mtk_dp_audio_mute,
+	.get_eld = mtk_dp_audio_get_eld,
+	.hook_plugged_cb = mtk_dp_audio_hook_plugged_cb,
+	.no_capture_mute = 1,
+};
+
+static int mtk_dp_register_audio_driver(struct device *dev)
+{
+	struct mtk_dp *mtk_dp = dev_get_drvdata(dev);
+	struct hdmi_codec_pdata codec_data = {
+		.ops = &mtk_dp_audio_codec_ops,
+		.max_i2s_channels = 8,
+		.i2s = 1,
+		.data = mtk_dp,
+	};
+	struct platform_device *pdev;
+
+	pdev = platform_device_register_data(dev, HDMI_CODEC_DRV_NAME,
+					     PLATFORM_DEVID_AUTO, &codec_data,
+					     sizeof(codec_data));
+	if (IS_ERR(pdev))
+		return PTR_ERR(pdev);
+
+	DRM_INFO("%s driver bound to DP\n", HDMI_CODEC_DRV_NAME);
+	return 0;
+}
+
+static int mtk_drm_dp_probe(struct platform_device *pdev)
+{
+	struct mtk_dp *mtk_dp;
+	struct device *dev = &pdev->dev;
+	int ret, irq_num = 0;
+	struct mtk_drm_private *mtk_priv = dev_get_drvdata(dev);
+	struct drm_panel *panel;
+
+	dev_err(&pdev->dev, "%s \n", __func__);
+	dev_err(&pdev->dev, "DP_TX PROBE START!!!");
+	mtk_dp = devm_kmalloc(dev, sizeof(*mtk_dp), GFP_KERNEL | __GFP_ZERO);
+	if (!mtk_dp)
+		return -ENOMEM;
+
+	memset(mtk_dp, 0, sizeof(struct mtk_dp));
+	mtk_dp->id = 0x0;
+	mtk_dp->dev = dev;
+	mtk_dp->priv = mtk_priv;
+	mtk_dp->bUeventToHwc = false;
+
+	irq_num = platform_get_irq(pdev, 0);
+	if (irq_num < 0) {
+		dev_err(&pdev->dev, "failed to request dp irq resource\n");
+		return -EPROBE_DEFER;
+	}
+
+	mtk_dp->driver_data = of_device_get_match_data(dev);
+
+	if (mtk_dp->driver_data && mtk_dp->driver_data->is_edp) {
+		ret = drm_of_find_panel_or_bridge(dev->of_node, 1, 0,
+						  &panel, &mtk_dp->next_bridge);
+		if (ret) {
+			dev_err(dev, "failed to drm_of_find_panel_or_bridge!ret=%d\n", ret);
+			return -EPROBE_DEFER;
+		}
+
+		if (panel) {
+			mtk_dp->next_bridge = devm_drm_panel_bridge_add(dev, panel);
+			if (IS_ERR(mtk_dp->next_bridge)) {
+				ret = PTR_ERR(mtk_dp->next_bridge);
+				dev_err(dev, "failed to devm_drm_panel_bridge_add!\n");
+				return -EPROBE_DEFER;
+			}
+		}
+	}
+	ret = mtk_dp_dt_parse_pdata(mtk_dp, pdev);
+	if (ret)
+		return ret;
+
+	mtk_dp_aux_init(mtk_dp);
+
+	dev_err(&pdev->dev, "type %d, irq %d\n", MTK_DISP_DPTX, irq_num);
+
+	irq_set_status_flags(irq_num, IRQ_TYPE_LEVEL_HIGH);
+	ret = devm_request_irq(&pdev->dev, irq_num, mtk_dp_hpd_event,
+			IRQ_TYPE_LEVEL_HIGH, dev_name(&pdev->dev), mtk_dp);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to request mediatek dptx irq\n");
+		return -EPROBE_DEFER;
+	}
+
+	INIT_WORK(&mtk_dp->work, mtk_dp_work_func);
+	mtk_dp->workqueue = create_workqueue("mtk_dp_work");
+	if (!mtk_dp->workqueue) {
+		DRM_DEV_ERROR(dev, "failed to create work queue\n");
+		ret = -ENOMEM;
+		return ret;
+	}
+
+	mutex_init(&mtk_dp->dp_lock);
+
+	platform_set_drvdata(pdev, mtk_dp);
+
+	if (!(mtk_dp->driver_data && mtk_dp->driver_data->is_edp)) {
+		mutex_init(&mtk_dp->update_plugged_status_lock);
+		ret = mtk_dp_register_audio_driver(dev);
+		if (ret) {
+			dev_err(dev, "Failed to register audio driver: %d\n", ret);
+			return ret;
+		}
+	}
+	mtk_dp->bridge.funcs = &mtk_dp_bridge_funcs;
+	mtk_dp->bridge.of_node = pdev->dev.of_node;
+	if (mtk_dp->driver_data && mtk_dp->driver_data->is_edp)
+		mtk_dp->bridge.type = DRM_MODE_CONNECTOR_eDP;
+	else
+		mtk_dp->bridge.type = DRM_MODE_CONNECTOR_DisplayPort;
+
+	mtk_dp->bridge.ops = DRM_BRIDGE_OP_DETECT | DRM_BRIDGE_OP_EDID
+			| DRM_BRIDGE_OP_HPD | DRM_BRIDGE_OP_MODES;
+	drm_bridge_add(&mtk_dp->bridge);
+
+	pm_runtime_enable(dev);
+	pm_runtime_get_sync(dev);
+
+	platform_set_drvdata(pdev, mtk_dp);
+
+	dev_err(&pdev->dev, "probe done\n");
+
+	return 0;
+}
+
+static int mtk_drm_dp_remove(struct platform_device *pdev)
+{
+	struct mtk_dp *mtk_dp = platform_get_drvdata(pdev);
+
+	mdrv_DPTx_VideoMute(mtk_dp, true);
+	mdrv_DPTx_AudioMute(mtk_dp, true);
+
+	pm_runtime_disable(&pdev->dev);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM_SLEEP
+static int mtk_dp_suspend(struct device *dev)
+{
+	struct mtk_dp *mtk_dp = dev_get_drvdata(dev);
+
+	mhal_DPTx_AnalogPowerOnOff(mtk_dp, false);
+	mhal_DPTx_HPDInterruptEnable(mtk_dp, false);
+
+	pm_runtime_put_sync(dev);
+
+	return 0;
+}
+
+static int mtk_dp_resume(struct device *dev)
+{
+	struct mtk_dp *mtk_dp = dev_get_drvdata(dev);
+
+	pm_runtime_get_sync(dev);
+
+	mdrv_DPTx_InitPort(mtk_dp);
+	mhal_DPTx_AnalogPowerOnOff(mtk_dp, true);
+	mhal_DPTx_HPDInterruptEnable(mtk_dp, true);
+
+	return 0;
+}
+#endif
+
+static SIMPLE_DEV_PM_OPS(mtk_dp_pm_ops,
+		mtk_dp_suspend, mtk_dp_resume);
+
+static const struct mtk_dp_driver_data mt8195_edp_driver_data = {
+	.is_edp = true,
+};
+
+static const struct of_device_id mtk_dp_of_match[] = {
+	{ .compatible = "mediatek,mt8195-dp_tx", },
+	{ .compatible = "mediatek,mt8195-edp_tx",
+	  .data = &mt8195_edp_driver_data },
+	{ },
+};
+
+
+struct platform_driver mtk_dp_tx_driver = {
+	.probe = mtk_drm_dp_probe,
+	.remove = mtk_drm_dp_remove,
+	.driver = {
+		.name = "mediatek-drm-dp",
+		.of_match_table = mtk_dp_of_match,
+		.pm = &mtk_dp_pm_ops,
+	},
+};
+
diff --git a/drivers/gpu/drm/mediatek/mtk_dp.h b/drivers/gpu/drm/mediatek/mtk_dp.h
new file mode 100644
index 0000000000000000000000000000000000000000..d62fa368382cd3ab731987ea1e295d306fc2acea
--- /dev/null
+++ b/drivers/gpu/drm/mediatek/mtk_dp.h
@@ -0,0 +1,229 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2019 MediaTek Inc.
+ */
+
+#ifndef __MTK_DP__H__
+#define __MTK_DP__H__
+
+#include "mtk_dp_common.h"
+
+
+#define DPTX_CheckSinkCap_TimeOutCnt		0x3
+
+#define HPD_INT_EVNET		BIT(3)
+#define HPD_CONNECT		BIT(2)
+#define HPD_DISCONNECT		BIT(1)
+#define HPD_INITIAL_STATE	0
+
+#define DPTX_TBC_SELBUF_CASE		2
+#define DPTX_TBC_BUF_SIZE		DPTX_TBC_SELBUF_CASE
+#if (DPTX_TBC_SELBUF_CASE == 2)
+#define DPTX_TBC_BUF_ReadStartAdrThrd	0x08
+#elif (DPTX_TBC_SELBUF_CASE == 1)
+#define DPTX_TBC_BUF_ReadStartAdrThrd	0x10
+#else
+#define DPTX_TBC_BUF_ReadStartAdrThrd	0x1F
+#endif
+
+#define ENABLE_DPTX_EF_MODE		0x1
+#if (ENABLE_DPTX_EF_MODE == 0x01)
+#define DPTX_AUX_SET_ENAHNCED_FRAME	0x80
+#else
+#define DPTX_AUX_SET_ENAHNCED_FRAME	0x00
+#endif
+
+#define DPTX_TRAIN_RETRY_LIMIT		0x8
+#define DPTX_TRAIN_MAX_ITERATION	0x5
+
+enum DPTx_SOURCE_TYPE {
+	DPTX_SRC_DPINTF = 0,
+	DPTX_SRC_PG	= 1,
+};
+
+enum DPTx_State {
+	DPTXSTATE_INITIAL		= 0,
+	DPTXSTATE_IDLE			= 1,
+	DPTXSTATE_HDCP_AUTH		= 2,
+	DPTXSTATE_PREPARE		= 3,
+	DPTXSTATE_NORMAL		= 4,
+};
+
+enum DPTx_DISP_State {
+	DPTX_DISP_NONE		= 0,
+	DPTX_DISP_RESUME	= 1,
+	DPTX_DISP_SUSPEND	= 2,
+};
+
+enum DPTx_Return_Status {
+	DPTX_NOERR			= 0,
+	DPTX_PLUG_OUT			= 1,
+	DPTX_TIMEOUT			= 2,
+	DPTX_AUTH_FAIL			= 3,
+	DPTX_EDID_FAIL			= 4,
+	DPTX_TRANING_FAIL		= 5,
+	DPTX_TRANING_STATE_CHANGE	= 6,
+};
+
+enum DPTX_TRAINING_STATE {
+	DPTX_NTSTATE_STARTUP		= 0x0,
+	DPTX_NTSTATE_CHECKCAP		= 0x1,
+	DPTX_NTSTATE_CHECKEDID		= 0x2,
+	DPTX_NTSTATE_TRAINING_PRE	= 0x3,
+	DPTX_NTSTATE_TRAINING		= 0x4,
+	DPTX_NTSTATE_CHECKTIMING	= 0x5,
+	DPTX_NTSTATE_NORMAL		= 0x6,
+	DPTX_NTSTATE_POWERSAVE		= 0x7,
+	DPTX_NTSTATE_DPIDLE		= 0x8,
+	DPTX_NTSTATE_MAX,
+};
+
+enum DPTx_FEC_ERROR_COUNT_TYPE {
+	FEC_ERROR_COUNT_DISABLE                = 0x0,
+	FEC_UNCORRECTED_BLOCK_ERROR_COUNT      = 0x1,
+	FEC_CORRECTED_BLOCK_ERROR_COUNT        = 0x2,
+	FEC_BIT_ERROR_COUNT                    = 0x3,
+	FEC_PARITY_BLOCK_ERROR_COUNT           = 0x4,
+	FEC_PARITY_BIT_ERROR_COUNT             = 0x5,
+};
+
+enum DP_LANECOUNT {
+	DP_LANECOUNT_1 = 0x1,
+	DP_LANECOUNT_2 = 0x2,
+	DP_LANECOUNT_4 = 0x4,
+};
+
+enum DP_VERSION {
+	DP_VERSION_11 = 0x11,
+	DP_VERSION_12 = 0x12,
+	DP_VERSION_14 = 0x14,
+	DP_VERSION_12_14 = 0x16,
+	DP_VERSION_14_14 = 0x17,
+	DP_VERSION_MAX,
+};
+
+enum DP_LINKRATE {
+	DP_LINKRATE_RBR = 0x6,
+	DP_LINKRATE_HBR = 0xA,
+	DP_LINKRATE_HBR2 = 0x14,
+	DP_LINKRATE_HBR25 = 0x19,
+	DP_LINKRATE_HBR3 = 0x1E,
+};
+
+enum DPTx_SWING_NUM {
+	DPTx_SWING0	= 0x00,
+	DPTx_SWING1	= 0x01,
+	DPTx_SWING2	= 0x02,
+	DPTx_SWING3	= 0x03,
+};
+
+enum DPTx_PREEMPHASIS_NUM {
+	DPTx_PREEMPHASIS0	= 0x00,
+	DPTx_PREEMPHASIS1	= 0x01,
+	DPTx_PREEMPHASIS2	= 0x02,
+	DPTx_PREEMPHASIS3	= 0x03,
+};
+
+//SINK_WIDTH_HIGHT_FPS
+enum DP_VIDEO_TIMING_TYPE {
+	SINK_640_480        = 0,
+	SINK_800_600        = 1,
+	SINK_1280_720       = 2,
+	SINK_1280_960       = 3,
+	SINK_1280_1024      = 4,
+	SINK_1920_1080      = 5,
+	SINK_1080_2460      = 6,
+	SINK_1920_1200      = 7,
+	SINK_1920_1440      = 8,
+	SINK_2560_1600      = 9,
+	SINK_3840_2160_30   = 10,//4K30
+	SINK_3840_2160      = 11,//4k60
+	SINK_7680_4320      = 12,
+	SINK_MAX,
+};
+
+enum DP_VIDEO_MUTE {
+	video_unmute	= 1,
+	video_mute	= 2,
+};
+
+enum DPTX_VIDEO_MODE {
+	DPTX_VIDEO_INTERLACE    = 0,
+	DPTX_VIDEO_PROGRESSIVE  = 1,
+};
+
+
+#define MAX_LANECOUNT	DP_LANECOUNT_4
+
+#define FAKE_DEFAULT_RES 0xFF
+
+#define DP_VIDEO_TIMING_MASK 0x000000ff
+#define DP_VIDEO_TIMING_SFT 0
+#define DP_COLOR_DEPTH_MASK 0x0000ff00
+#define DP_COLOR_DEPTH_SFT 8
+#define DP_COLOR_FORMAT_MASK 0x00ff0000
+#define DP_COLOR_FORMAT_SFT 16
+
+#define DP_CHANNEL_2      BIT(0)
+#define DP_CHANNEL_3      BIT(1)
+#define DP_CHANNEL_4      BIT(2)
+#define DP_CHANNEL_5      BIT(3)
+#define DP_CHANNEL_6      BIT(4)
+#define DP_CHANNEL_7      BIT(5)
+#define DP_CHANNEL_8      BIT(6)
+
+#define DP_SAMPLERATE_32  BIT(0)
+#define DP_SAMPLERATE_44  BIT(1)
+#define DP_SAMPLERATE_48  BIT(2)
+#define DP_SAMPLERATE_96  BIT(3)
+#define DP_SAMPLERATE_192 BIT(4)
+
+#define DP_BITWIDTH_16    BIT(0)
+#define DP_BITWIDTH_20    BIT(1)
+#define DP_BITWIDTH_24    BIT(2)
+
+#define DP_CAPABILITY_CHANNEL_MASK              0x7F
+#define DP_CAPABILITY_CHANNEL_SFT               0
+#define DP_CAPABILITY_SAMPLERATE_MASK           0x1F
+#define DP_CAPABILITY_SAMPLERATE_SFT            8
+#define DP_CAPABILITY_BITWIDTH_MASK             0x07
+#define DP_CAPABILITY_BITWIDTH_SFT              16
+
+
+void mtk_dp_poweroff(struct mtk_dp *mtk_dp);
+void mtk_dp_poweron(struct mtk_dp *mtk_dp);
+void mtk_dp_video_trigger(int res);
+struct edid *mtk_dp_handle_edid(struct mtk_dp *mtk_dp);
+int mdrv_DPTx_SetTrainingStart(struct mtk_dp *mtk_dp);
+void mdrv_DPTx_CheckMaxLinkRate(struct mtk_dp *mtk_dp);
+void mtk_dp_video_config(struct mtk_dp *mtk_dp);
+void mtk_dp_force_res(unsigned int res, unsigned int bpc);
+void mtk_dp_hotplug_uevent(unsigned int status);
+void mtk_dp_enable_4k60(int enable);
+void mdrv_DPTx_FEC_Ready(struct mtk_dp *mtk_dp, u8 err_cnt_sel);
+void mdrv_DPTx_DSC_Support(struct mtk_dp *mtk_dp);
+void mtk_dp_dsc_pps_send(u8 *PPS_128);
+void mdrv_DPTx_VideoMute(struct mtk_dp *mtk_dp, bool bENABLE);
+void mdrv_DPTx_AudioMute(struct mtk_dp *mtk_dp, bool bENABLE);
+void mdrv_DPTx_SPKG_SDP(struct mtk_dp *mtk_dp, bool bEnable, u8 ucSDPType,
+	u8 *pHB, u8 *pDB);
+void mdrv_DPTx_I2S_Audio_Config(struct mtk_dp *mtk_dp);
+void mdrv_DPTx_I2S_Audio_Enable(struct mtk_dp *mtk_dp, bool bEnable);
+void mdrv_DPTx_I2S_Audio_Ch_Status_Set(struct mtk_dp *mtk_dp, u8 ucChannel,
+	u8 ucFs, u8 ucWordlength);
+void mdrv_DPTx_I2S_Audio_SDP_Channel_Setting(struct mtk_dp *mtk_dp,
+	u8 ucChannel, u8 ucFs, u8 ucWordlength);
+int mdrv_DPTx_HPD_HandleInThread(struct mtk_dp *mtk_dp);
+void mdrv_DPTx_Video_Enable(struct mtk_dp *mtk_dp, bool bEnable);
+DWORD getTimeDiff(DWORD dwPreTime);
+DWORD getSystemTime(void);
+void mtk_dp_force_audio(unsigned int ch, unsigned int fs, unsigned int len);
+void mtk_dp_test(unsigned int status);
+void mtk_dp_fec_enable(unsigned int status);
+void mtk_dp_power_save(unsigned int status);
+void mtk_dp_set_adjust_phy(uint8_t c0, uint8_t cp1);
+int mdrv_DPTx_set_reTraining(struct mtk_dp *mtk_dp);
+void mdrv_DPTx_PatternSet(bool enable, int resolution);
+void mdrv_DPTx_SetDPTXOut(struct mtk_dp *mtk_dp);
+void mdrv_DPTx_CheckSinkESI(struct mtk_dp *mtk_dp, u8 *pDPCD20x, u8 *pDPCD2002);
+#endif //__MTK_DP__H__
diff --git a/drivers/gpu/drm/mediatek/mtk_dp_api.h b/drivers/gpu/drm/mediatek/mtk_dp_api.h
new file mode 100644
index 0000000000000000000000000000000000000000..38e40559f35e643e475d22c24af58ef4ac391135
--- /dev/null
+++ b/drivers/gpu/drm/mediatek/mtk_dp_api.h
@@ -0,0 +1,19 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2019 MediaTek Inc.
+ */
+
+
+#ifndef __DRTX_API_H__
+#define __DRTX_API_H__
+
+void mtk_dp_SWInterruptSet(int bstatus);
+int mtk_drm_dp_audio_enable(struct drm_device *dev,
+			void *data, struct drm_file *file_priv);
+int mtk_drm_dp_audio_config(struct drm_device *dev,
+			void *data, struct drm_file *file_priv);
+int mtk_drm_dp_get_cap(struct drm_device *dev,
+			void *data, struct drm_file *file_priv);
+void mtk_dp_get_dsc_capability(u8 *dsc_cap);
+#endif
+
diff --git a/drivers/gpu/drm/mediatek/mtk_dp_autotest.c b/drivers/gpu/drm/mediatek/mtk_dp_autotest.c
new file mode 100644
index 0000000000000000000000000000000000000000..87760a294c671ff2e0296f429f41a3635b27107e
--- /dev/null
+++ b/drivers/gpu/drm/mediatek/mtk_dp_autotest.c
@@ -0,0 +1,608 @@
+
+#include "mtk_dp.h"
+#include "mtk_dp_hal.h"
+#include "mtk_dp_api.h"
+#include "mtk_dp_reg.h"
+
+#define PATTERN_NONE			0x0
+#define PATTERN_D10_2			0x1
+#define PATTERN_SYMBOL_ERR		0x2
+#define PATTERN_PRBS7			0x3
+#define PATTERN_80B			0x4
+#define PATTERN_HBR2_COM_EYE		0x5
+#define CP2520_PATTERN2                 0x6
+#define CP2520_PATTERN3                 0x7
+
+struct DP_CTS_AUTO_REQ {
+	unsigned int test_link_training;
+	unsigned int test_pattern_req;
+	unsigned int test_edid_read;
+	unsigned int test_link_rate;	//06h:1.62Gbps, 0Ah:2.7Gbps
+	unsigned int test_lane_count;
+	//01h:color ramps,02h:black&white vertical,03h:color square
+	unsigned int test_pattern;
+	unsigned int test_h_total;
+	unsigned int test_v_total;
+	unsigned int test_h_start;
+	unsigned int test_v_start;
+	unsigned int test_hsync_width;
+	unsigned int test_hsync_polarity;
+	unsigned int test_vsync_width;
+	unsigned int test_vsync_polarity;
+	unsigned int test_h_width;
+	unsigned int test_v_height;
+	unsigned int test_sync_clk;
+	unsigned int test_color_fmt;
+	unsigned int test_dynamic_range;
+	unsigned int test_YCbCr_coefficient;
+	unsigned int test_bit_depth;
+	unsigned int test_refresh_denominator;
+	unsigned int test_interlaced;
+	unsigned int test_refresh_rate_numerator;
+	unsigned int test_aduio_channel_count;
+	unsigned int test_aduio_samling_rate;
+};
+
+enum DPTx_PG_Sel {
+	DPTx_PG_20bit	= 0,
+	DPTx_PG_80bit	= 1,
+	DPTx_PG_11bit	= 2,
+	DPTx_PG_8bit	= 3,
+	DPTx_PG_PRBS7	= 4,
+};
+
+struct DP_CTS_AUTO_REQ cts_req;
+bool mdrv_DPTx_Video_PG_AutoTest(struct mtk_dp *mtk_dp)//, BYTE ubDPCD_201)
+{
+	BYTE i;
+	BYTE dpcd22x[16];  //220~22F
+	BYTE dpcd23x[5];   //230~234
+	BYTE dpcd27x[10];	//220~22F
+	BYTE ucMISC[2] = {0x00};
+
+	drm_dp_dpcd_read(&mtk_dp->aux, DPCD_00220, dpcd22x, 16);
+	drm_dp_dpcd_read(&mtk_dp->aux, DPCD_00230, dpcd23x, 5);
+	drm_dp_dpcd_read(&mtk_dp->aux, DPCD_00271, dpcd27x, 10);
+
+	for (i = 0; i < 10; i++)
+		DPTXMSG("dpcd27%d = 0x%x\n", i+1, dpcd27x[i]);
+
+	cts_req.test_aduio_channel_count = (((dpcd27x[0]) & 0xF0) >> 4) + 1;
+	cts_req.test_aduio_samling_rate = ((dpcd27x[0]) & 0x0F) + 1;
+	DPTXMSG("channel = %d, sr = %d\n",
+		cts_req.test_aduio_channel_count,
+		cts_req.test_aduio_samling_rate);
+	cts_req.test_pattern = (dpcd22x[1]);
+	cts_req.test_h_total = ((dpcd22x[2]<<8) + (dpcd22x[3]));
+	cts_req.test_v_total = ((dpcd22x[4]<<8) + (dpcd22x[5]));
+	cts_req.test_h_start = ((dpcd22x[6]<<8) + (dpcd22x[7]));
+	cts_req.test_v_start = ((dpcd22x[8]<<8) + (dpcd22x[9]));
+	cts_req.test_hsync_polarity = ((dpcd22x[0xa] & 0x80)>>7);
+	cts_req.test_hsync_width =
+		(((dpcd22x[0xa] & 0x7f)<<8) + (dpcd22x[0xb]));
+	cts_req.test_vsync_polarity = ((dpcd22x[0xc] & 0x80)>>7);
+	cts_req.test_vsync_width =
+		(((dpcd22x[0xc] & 0x7f)<<8) + (dpcd22x[0xd]));
+	cts_req.test_h_width = ((dpcd22x[0xe]<<8) + (dpcd22x[0xf]));
+	cts_req.test_v_height = ((dpcd23x[0]<<8) + (dpcd23x[1]));
+	cts_req.test_sync_clk = (dpcd23x[2] & 0x1);
+	cts_req.test_color_fmt = ((dpcd23x[2] & 0x6)>>1);
+	cts_req.test_dynamic_range = ((dpcd23x[2] & 0x8)>>3);
+	cts_req.test_YCbCr_coefficient = ((dpcd23x[2] & 0x10)>>4);
+	cts_req.test_bit_depth = ((dpcd23x[2] & 0xe0)>>5);
+	cts_req.test_refresh_denominator = (dpcd23x[3] & 0x1);
+	cts_req.test_interlaced = ((dpcd23x[3] & 0x2)>>1);
+	cts_req.test_refresh_rate_numerator = (dpcd23x[4]);
+
+	DPTXMSG("[DPTXCTS] test request:\n");
+	DPTXMSG("req.test_pattern = %d\n", cts_req.test_pattern);
+	DPTXMSG("req.test_h_total = %d\n", cts_req.test_h_total);
+	DPTXMSG("req.test_v_total = %d\n", cts_req.test_v_total);
+	DPTXMSG("req.test_h_start = %d\n", cts_req.test_h_start);
+	DPTXMSG("req.test_v_start = %d\n", cts_req.test_v_start);
+	DPTXMSG("req.test_hsync_polarity = %d\n",
+		cts_req.test_hsync_polarity);
+	DPTXMSG("req.test_hsync_width = d\n",
+		cts_req.test_hsync_width);
+	DPTXMSG("req.test_vsync_polarity = %d\n",
+		cts_req.test_vsync_polarity);
+	DPTXMSG("req.test_vsync_width =  %d\n",
+		cts_req.test_vsync_width);
+	DPTXMSG("req.test_h_width = %d\n", cts_req.test_h_width);
+	DPTXMSG("req.test_v_height = %d\n", cts_req.test_v_height);
+	DPTXMSG("req.test_sync_clk = %d\n", cts_req.test_sync_clk);
+	DPTXMSG("req.test_color_fmt = %d\n", cts_req.test_color_fmt);
+	DPTXMSG("req.test_dynamic_range = %d\n",
+		cts_req.test_dynamic_range);
+	DPTXMSG("req.test_YCbCr_coefficient = %d\n",
+		cts_req.test_YCbCr_coefficient);
+	DPTXMSG("req.test_bit_depth = %d\n", cts_req.test_bit_depth);
+	DPTXMSG("req.test_refresh_denominator = %d\n",
+		cts_req.test_refresh_denominator);
+	DPTXMSG("req.test_interlaced = %d\n",
+		cts_req.test_interlaced);
+	DPTXMSG("req.test_refresh_rate_numerator = %d\n",
+		cts_req.test_refresh_rate_numerator);
+
+	mtk_dp->info.DPTX_OUTBL.Htt = cts_req.test_h_total;
+	mtk_dp->info.DPTX_OUTBL.Hde = cts_req.test_h_width;
+	mtk_dp->info.DPTX_OUTBL.Hfp = cts_req.test_h_total
+		- cts_req.test_h_start - cts_req.test_h_width;
+	mtk_dp->info.DPTX_OUTBL.Hsw = cts_req.test_hsync_width;
+	mtk_dp->info.DPTX_OUTBL.bHsp = cts_req.test_hsync_polarity;
+	mtk_dp->info.DPTX_OUTBL.Hbp = cts_req.test_h_start
+		- cts_req.test_hsync_width;
+	mtk_dp->info.DPTX_OUTBL.Vtt = cts_req.test_v_total;
+	mtk_dp->info.DPTX_OUTBL.Vde = cts_req.test_v_height;
+	mtk_dp->info.DPTX_OUTBL.Vfp = cts_req.test_v_total
+		- cts_req.test_v_start - cts_req.test_v_height;
+	mtk_dp->info.DPTX_OUTBL.Vsw = cts_req.test_vsync_width;
+	mtk_dp->info.DPTX_OUTBL.bVsp = cts_req.test_vsync_polarity;
+	mtk_dp->info.DPTX_OUTBL.Vbp = cts_req.test_v_start
+		- cts_req.test_vsync_width;
+	mtk_dp->info.DPTX_OUTBL.Hbk = cts_req.test_h_total
+		- cts_req.test_h_width;
+	mtk_dp->info.DPTX_OUTBL.FrameRate = cts_req.test_refresh_rate_numerator;
+	mtk_dp->info.DPTX_OUTBL.PixRateKhz = 0;
+	mtk_dp->info.DPTX_OUTBL.Video_ip_mode = DPTX_VIDEO_PROGRESSIVE;
+	if (cts_req.test_interlaced)
+		DPTXMSG("Warning: not support interlace\n");
+
+	//Clear MISC1&0 except [2:1]Colorfmt & [7:5]ColorDepth
+	mhal_DPTx_SetMISC(mtk_dp, ucMISC);
+
+	mtk_dp->info.format = cts_req.test_color_fmt;
+	mtk_dp->info.depth = cts_req.test_bit_depth;
+	//mtk_dp->info.DPTX_MISC.dp_misc.spec_def1 = cts_req.test_dynamic_range;
+
+	mhal_DPTx_SetColorFormat(mtk_dp, mtk_dp->info.format);
+	mhal_DPTx_SetColorDepth(mtk_dp, mtk_dp->info.depth);
+	mhal_DPTx_SetMSA(mtk_dp);
+	mdrv_DPTx_SetDPTXOut(mtk_dp);
+	mdrv_DPTx_VideoMute(mtk_dp, false);
+
+	return 0;
+}
+
+void mdrv_DPTx_Audio_PG_AutoTest(struct mtk_dp *mtk_dp)
+{
+	BYTE SDP_DB[32] = {0};
+	BYTE SDP_HB[4] = {0};
+	BYTE ucWordlength = WL_24bit;
+
+	mhal_DPTx_Audio_SDP_Setting(mtk_dp, cts_req.test_aduio_channel_count);
+	mhal_DPTx_Audio_Ch_Status_Set(mtk_dp, cts_req.test_aduio_channel_count,
+		cts_req.test_aduio_samling_rate, ucWordlength);
+	mdrv_DPTx_I2S_Audio_Enable(mtk_dp, false);
+
+	SDP_HB[1] = DP_SPEC_SDPTYP_AINFO;
+	SDP_HB[2] = 0x1B;
+	SDP_HB[3] = 0x48;
+
+	mdrv_DPTx_SPKG_SDP(mtk_dp, 1, 4, SDP_HB, SDP_DB);
+}
+
+bool mdrv_DPTx_PHY_AdjustSwingPre(struct mtk_dp *mtk_dp, BYTE ubLaneCount)
+{
+	BYTE ubSwingValue;
+	BYTE ubPreemphasis;
+	BYTE ubTempBuf1[0x2];
+	BYTE ubDPCP_Buffer1[0x4];
+	bool bReplyStatus = false;
+
+	memset(ubDPCP_Buffer1, 0x0, sizeof(ubDPCP_Buffer1));
+	bReplyStatus = drm_dp_dpcd_read(&mtk_dp->aux, DPCD_00206,
+				ubTempBuf1, 0x2);
+	drm_dp_dpcd_write(&mtk_dp->aux, DPCD_00103, ubDPCP_Buffer1, 0x4);
+	if (bReplyStatus) {
+		if (ubLaneCount >= 0x1) {
+			ubSwingValue = (ubTempBuf1[0x0]&0x3);
+			ubPreemphasis = ((ubTempBuf1[0x0]&0x0C)>>2);
+			//Adjust the swing and pre-emphasis
+			mhal_DPTx_SetSwingtPreEmphasis(mtk_dp, DPTx_LANE0,
+				ubSwingValue, ubPreemphasis);
+			//Adjust the swing and pre-emphasis done,
+				//notify Sink Side
+			ubDPCP_Buffer1[0x0] =
+				ubSwingValue | (ubPreemphasis << 3);
+			//MAX_SWING_REACHED
+			if (ubSwingValue == DPTx_SWING3)
+				ubDPCP_Buffer1[0x0] |= BIT(2);
+
+			//MAX_PRE-EMPHASIS_REACHED
+			if (ubPreemphasis == DPTx_PREEMPHASIS3)
+				ubDPCP_Buffer1[0x0] |= BIT(5);
+
+		}
+
+		if (ubLaneCount >= 0x2) {
+			ubSwingValue = (ubTempBuf1[0x0]&0x30) >> 4;
+			ubPreemphasis = ((ubTempBuf1[0x0]&0xC0)>>6);
+			//Adjust the swing and pre-emphasis
+			mhal_DPTx_SetSwingtPreEmphasis(mtk_dp, DPTx_LANE1,
+				ubSwingValue, ubPreemphasis);
+			//Adjust the swing and pre-emphasis done,
+				//notify Sink Side
+			ubDPCP_Buffer1[0x1] =
+				ubSwingValue | (ubPreemphasis << 3);
+			if (ubSwingValue == DPTx_SWING3) {  //MAX_SWING_REACHED
+				ubDPCP_Buffer1[0x1] |= BIT(2);
+			}
+			//MAX_PRE-EMPHASIS_REACHED
+			if (ubPreemphasis == DPTx_PREEMPHASIS3)
+				ubDPCP_Buffer1[0x1] |= BIT(5);
+
+		}
+
+		if (ubLaneCount == 0x4) {
+			ubSwingValue = (ubTempBuf1[0x1]&0x3);
+			ubPreemphasis = ((ubTempBuf1[0x1]&0x0C)>>2);
+
+			//Adjust the swing and pre-emphasis
+			mhal_DPTx_SetSwingtPreEmphasis(mtk_dp, DPTx_LANE2,
+				ubSwingValue, ubPreemphasis);
+			//Adjust the swing and pre-emphasis done,
+				//notify Sink Side
+			ubDPCP_Buffer1[0x2] =
+				ubSwingValue | (ubPreemphasis << 3);
+			if (ubSwingValue == DPTx_SWING3) { //MAX_SWING_REACHED
+				ubDPCP_Buffer1[0x2] |= BIT(2);
+			}
+			//MAX_PRE-EMPHASIS_REACHED
+			if (ubPreemphasis == DPTx_PREEMPHASIS3)
+				ubDPCP_Buffer1[0x2] |= BIT(5);
+
+
+			ubSwingValue = (ubTempBuf1[0x1]&0x30) >> 4;
+			ubPreemphasis = ((ubTempBuf1[0x1]&0xC0)>>6);
+
+			//Adjust the swing and pre-emphasis
+			mhal_DPTx_SetSwingtPreEmphasis(mtk_dp, DPTx_LANE3,
+				ubSwingValue, ubPreemphasis);
+			//Adjust the swing and pre-emphasis done,
+				//notify Sink Side
+			ubDPCP_Buffer1[0x3] =
+				ubSwingValue | (ubPreemphasis << 3);
+			if (ubSwingValue == DPTx_SWING3) { //MAX_SWING_REACHED
+				ubDPCP_Buffer1[0x3] |= BIT(2);
+			}
+			//MAX_PRE-EMPHASIS_REACHED
+			if (ubPreemphasis == DPTx_PREEMPHASIS3)
+				ubDPCP_Buffer1[0x3] |= BIT(5);
+
+		}
+		drm_dp_dpcd_write(&mtk_dp->aux, DPCD_00103,
+			ubDPCP_Buffer1, 0x4);
+	}
+	return true;
+}
+
+void mhal_DPTx_PHY_ResetPattern(struct mtk_dp *mtk_dp)
+{
+	DPTXFUNC();
+	//reset pattern
+	mhal_DPTx_SetTxLane(mtk_dp, DPTx_LANE_4);
+	mhal_DPTx_ProgramPatternEnable(mtk_dp, false);
+	mhal_DPTx_PatternSelect(mtk_dp, 0x00);
+	mhal_DPTx_PRBSEnable(mtk_dp, false);
+	mhal_DPTx_ComplianceEyeEnSetting(mtk_dp, false);
+}
+
+void mhal_DPTx_PRBSEnable(struct mtk_dp *mtk_dp, bool bENABLE)
+{
+	DPTXFUNC();
+	if (bENABLE)
+		msWriteByteMask(mtk_dp, REG_3444_DP_TRANS_P0, (BIT3), BIT3);
+	else
+		msWriteByteMask(mtk_dp, REG_3444_DP_TRANS_P0, (0), BIT3);
+}
+
+void mhal_DPTx_ProgramPatternEnable(struct mtk_dp *mtk_dp, bool bENABLE)
+{
+	DPTXFUNC();
+	if (bENABLE)
+		msWriteByteMask(mtk_dp,
+			REG_3440_DP_TRANS_P0,
+			0x0F,
+			MASKBIT(3 : 0));
+	else
+		msWriteByteMask(mtk_dp,
+			REG_3440_DP_TRANS_P0,
+			0,
+			MASKBIT(3 : 0));
+}
+
+void mhal_DPTx_PatternSelect(struct mtk_dp *mtk_dp, int Value)
+{
+	DPTXFUNC();
+	msWriteByteMask(mtk_dp,
+		REG_3440_DP_TRANS_P0, (Value << 4), MASKBIT(6 : 4));
+	msWriteByteMask(mtk_dp,
+		REG_3440_DP_TRANS_P0 + 1, (Value), MASKBIT(2 : 0));
+	msWriteByteMask(mtk_dp,
+		REG_3440_DP_TRANS_P0 + 1, (Value << 4), MASKBIT(6 : 4));
+	msWriteByteMask(mtk_dp,
+		REG_3444_DP_TRANS_P0, (Value), MASKBIT(2 : 0));
+}
+
+void mhal_DPTx_SetProgramPattern(struct mtk_dp *mtk_dp,
+	BYTE Value, BYTE  *usData)
+{
+	DPTXFUNC();
+	//16bit RG need *2
+	msWriteByte(mtk_dp, REG_3448_DP_TRANS_P0 + Value*6*2, usData[0]);
+	msWriteByte(mtk_dp, REG_3448_DP_TRANS_P0 + 1 + Value*6*2, usData[1]);
+	msWriteByte(mtk_dp, REG_344C_DP_TRANS_P0 + Value*6*2, usData[2]);
+	msWriteByte(mtk_dp, REG_344C_DP_TRANS_P0 + 1 + Value*6*2, usData[3]);
+	msWriteByte(mtk_dp, REG_3450_DP_TRANS_P0 + Value*6*2, usData[4]);
+	msWriteByte(mtk_dp, REG_3450_DP_TRANS_P0 + 1 + Value*6*2, 0x00);
+}
+
+void mhal_DPTx_ComplianceEyeEnSetting(struct mtk_dp *mtk_dp, bool bENABLE)
+{
+	DPTXFUNC();
+	if (bENABLE)
+		msWriteByteMask(mtk_dp, REG_3478_DP_TRANS_P0, (BIT0), BIT0);
+	else
+		msWriteByteMask(mtk_dp, REG_3478_DP_TRANS_P0, (0), BIT0);
+}
+
+bool mdrv_DPTx_PHY_PatternSetting(struct mtk_dp *mtk_dp, BYTE ubPatternType,
+	BYTE ubTEST_LANE_COUNT)
+{
+	BYTE i;
+	BYTE PGdata[5] = {0x1F, 0x7C, 0xF0, 0xC1, 0x07};
+
+	mhal_DPTx_DataLanePNSwap(mtk_dp, false);
+	mhal_DPTx_PHY_ResetPattern(mtk_dp);
+	switch (ubPatternType) {
+	case PATTERN_NONE:
+		//Disable U02 patch code, add interskew for test pattern,
+			//lane1/2/3 select lane0 pipe delay
+		break;
+	case PATTERN_D10_2:
+		mhal_DPTx_SetTxTrainingPattern(mtk_dp, BIT(4));
+		mhal_DPTx_SetTxLane(mtk_dp, (ubTEST_LANE_COUNT/2));
+		break;
+	case PATTERN_SYMBOL_ERR:
+		break;
+	case PATTERN_PRBS7:
+		mhal_DPTx_DataLanePNSwap(mtk_dp, true);
+		mhal_DPTx_ProgramPatternEnable(mtk_dp, true);
+		mhal_DPTx_PRBSEnable(mtk_dp, true);
+		mhal_DPTx_ProgramPatternEnable(mtk_dp, true);
+		mhal_DPTx_PRBSEnable(mtk_dp, true);
+		mhal_DPTx_PatternSelect(mtk_dp, DPTx_PG_PRBS7);
+		break;
+	case PATTERN_80B:
+		for (i = 0x0; i < 4; i++)
+			mhal_DPTx_SetProgramPattern(mtk_dp, i, PGdata);
+
+		mhal_DPTx_ProgramPatternEnable(mtk_dp, true);
+		mhal_DPTx_PatternSelect(mtk_dp, DPTx_PG_80bit);
+		break;
+	case PATTERN_HBR2_COM_EYE:
+		mhal_DPTx_ComplianceEyeEnSetting(mtk_dp, true);
+		break;
+	};
+	return true;
+}
+
+bool mdrv_DPTx_CheckSSC(struct mtk_dp *mtk_dp)
+{
+	BYTE ubTempBuffer[0x2];
+
+	drm_dp_dpcd_read(&mtk_dp->aux,
+		DPCD_00003 + DPCD_02200*mtk_dp->training_info.bSinkEXTCAP_En,
+		ubTempBuffer, 0x1);
+
+	if (ubTempBuffer[0x0] & 0x1) {
+		ubTempBuffer[0x0] = 0x10;
+		drm_dp_dpcd_write(&mtk_dp->aux, DPCD_00107, ubTempBuffer, 0x1);
+		mtk_dp->info.bSinkSSC_En = true;
+		mhal_DPTx_SSCOnOffSetting(mtk_dp, true);
+	} else {
+		mtk_dp->info.bSinkSSC_En = false;
+		mhal_DPTx_SSCOnOffSetting(mtk_dp, false);
+	}
+
+	return true;
+}
+
+bool mdrv_DPTx_PHY_AutoTest(struct mtk_dp *mtk_dp, BYTE ubDPCD_201)
+{
+	bool bAutoTestIRQ = false;
+	BYTE ubDPCD_218 = 0x0;
+	BYTE ubTempBuffer[0x10];
+	BYTE ubDPCD_248;
+	WORD usSYMERRCNT_N;             // for sym Error Count
+	// for  1.sym Error Count (DPCD0210-0217)  / 2.PHY 80b(DPCD_0250-0259)
+	BYTE ubDPCDRDBUF[10];
+	BYTE ubTEST_LINK_RATE;   // DPCD_219
+	BYTE ubTEST_LANE_COUNT;  // DPCD_220
+
+	memset(ubTempBuffer, 0x0, sizeof(ubTempBuffer));
+	DPTXMSG("PHY_AutoTest Start\n");
+	DPTXMSG("DPCD 201 = 0x%x\n", ubDPCD_201);
+
+	if (ubDPCD_201 & BIT(1)) {
+		bAutoTestIRQ = true;
+		drm_dp_dpcd_write(&mtk_dp->aux, DPCD_00201, &ubDPCD_201, 0x1);
+		usleep_range(1000, 2000);
+		drm_dp_dpcd_read(&mtk_dp->aux, DPCD_00218, &ubDPCD_218, 0x1);
+		DPTXMSG("DPCD 218 = 0x%x\n", ubDPCD_218);
+
+		switch (ubDPCD_218 & 0xFF)	{
+		case BIT0://TEST_LINK_TRAINING:
+			DPTXMSG("TEST_LINK_TRAINING\n");
+			ubTempBuffer[0x0] = 0x01;
+			drm_dp_dpcd_write(&mtk_dp->aux, DPCD_00260,
+				ubTempBuffer, 0x1);
+			drm_dp_dpcd_read(&mtk_dp->aux, DPCD_00219,
+				&ubTEST_LINK_RATE, 0x1);
+			drm_dp_dpcd_read(&mtk_dp->aux, DPCD_00220,
+				&ubTEST_LANE_COUNT, 0x1);
+			mtk_dp->training_info.bDPTxAutoTest_EN = true;
+
+			if ((ubTEST_LINK_RATE != 0x0) &&
+				(ubTEST_LANE_COUNT != 0x0)) {
+				mtk_dp->training_info.ubLinkRate
+					= ubTEST_LINK_RATE;
+				mtk_dp->training_info.ubLinkLaneCount =
+					ubTEST_LANE_COUNT;
+				ubTempBuffer[0x0] = 0x0;
+				drm_dp_dpcd_write(&mtk_dp->aux, DPCD_00102,
+					ubTempBuffer, 0x1);
+				ubTempBuffer[0x0] = 0x2;
+				drm_dp_dpcd_write(&mtk_dp->aux, DPCD_00600,
+					ubTempBuffer, 0x1);
+				mdrv_DPTx_SetTrainingStart(mtk_dp);
+			}
+			return true;
+			break;
+
+		case BIT1: //TEST_VIDEO_PATTERN
+			DPTXMSG("TEST_PATTERN\n");
+			mtk_dp->training_info.bDPTxAutoTest_EN = true;
+			mdrv_DPTx_Video_PG_AutoTest(mtk_dp);
+/*
+ *			ubTempBuffer[0x0] = 0x01;
+ *			drm_dp_dpcd_write(&mtk_dp->aux, DPCD_00260,
+ *				ubTempBuffer, 0x1);
+ */
+			return true;
+			break;
+
+		case (BIT1 | BIT5)://(TEST_VIDEO_PATTERN | TEST_AUDIO_PATTERN)
+			DPTXMSG("TEST VIDEO/AUDIO PATTERN\n");
+			mtk_dp->training_info.bDPTxAutoTest_EN = true;
+			mdrv_DPTx_Video_PG_AutoTest(mtk_dp);
+			mdrv_DPTx_Audio_PG_AutoTest(mtk_dp);
+			ubTempBuffer[0x0] = 0x01;
+			drm_dp_dpcd_write(&mtk_dp->aux, DPCD_00260,
+				ubTempBuffer, 0x1);
+			return true;
+
+		case BIT2: //TEST_EDID_READ
+			DPTXMSG("TEST_EDID_R\n");
+			if (mtk_dp->edid)
+				kfree(mtk_dp->edid);
+			mtk_dp->edid = mtk_dp_handle_edid(mtk_dp);
+			msleep(20);
+			ubTempBuffer[0x0] = mtk_dp->edid->checksum;
+			drm_dp_dpcd_write(&mtk_dp->aux, DPCD_00261, ubTempBuffer, 0x1);
+			ubTempBuffer[0x0] = 0x05;
+			drm_dp_dpcd_write(&mtk_dp->aux, DPCD_00260, ubTempBuffer, 0x1);
+			return true;
+			break;
+
+		case BIT3://TEST_PHY_PATTERN
+			DPTXMSG("PHY_TEST_PATTERN");
+			drm_dp_dpcd_read(&mtk_dp->aux, 0x00248,
+				&ubDPCD_248, 0x1);
+			drm_dp_dpcd_read(&mtk_dp->aux, 0x00220,
+				&ubTEST_LANE_COUNT, 0x1);
+			mdrv_DPTx_PHY_AdjustSwingPre(mtk_dp, ubTEST_LANE_COUNT);
+			switch (ubDPCD_248&0x07) {
+			case PATTERN_NONE:
+				mdrv_DPTx_PHY_PatternSetting(mtk_dp,
+					PATTERN_NONE, ubTEST_LANE_COUNT);
+				ubTempBuffer[0x0] = 0x01;
+				drm_dp_dpcd_write(&mtk_dp->aux,
+					DPCD_00260, ubTempBuffer, 0x1);
+				break;
+			case PATTERN_D10_2:
+				mdrv_DPTx_PHY_PatternSetting(mtk_dp,
+					PATTERN_D10_2, ubTEST_LANE_COUNT);
+				usleep_range(2000, 3000);
+				ubTempBuffer[0x0] = 0x01;
+				drm_dp_dpcd_write(&mtk_dp->aux, DPCD_00260,
+					ubTempBuffer, 0x1);
+				break;
+			case PATTERN_SYMBOL_ERR:
+				mdrv_DPTx_PHY_PatternSetting(mtk_dp,
+					PATTERN_SYMBOL_ERR, ubTEST_LANE_COUNT);
+				ubTempBuffer[0x0] = 0x01;
+				drm_dp_dpcd_write(&mtk_dp->aux, DPCD_00260,
+					ubTempBuffer, 0x1);
+				usSYMERRCNT_N = 0x0005;
+				msleep(1000);
+				drm_dp_dpcd_read(&mtk_dp->aux, DPCD_00210,
+					ubDPCDRDBUF, 8);
+				break;
+			case PATTERN_PRBS7:
+				mdrv_DPTx_PHY_PatternSetting(mtk_dp,
+					PATTERN_PRBS7, ubTEST_LANE_COUNT);
+				ubTempBuffer[0x0] = 0x01;
+				drm_dp_dpcd_write(&mtk_dp->aux, DPCD_00260,
+					ubTempBuffer, 0x1);
+				msleep(1000);
+				drm_dp_dpcd_read(&mtk_dp->aux, DPCD_00210,
+					ubDPCDRDBUF, 8);
+				break;
+			case PATTERN_80B:
+				mdrv_DPTx_PHY_PatternSetting(mtk_dp,
+					PATTERN_80B, ubTEST_LANE_COUNT);
+				drm_dp_dpcd_read(&mtk_dp->aux, DPCD_00250,
+					ubDPCDRDBUF, 10);
+				ubTempBuffer[0x0] = 0x01;
+				drm_dp_dpcd_write(&mtk_dp->aux, DPCD_00260,
+					ubTempBuffer, 0x1);
+				break;
+
+			case PATTERN_HBR2_COM_EYE:
+				mdrv_DPTx_PHY_PatternSetting(mtk_dp,
+					PATTERN_HBR2_COM_EYE,
+					ubTEST_LANE_COUNT);
+				ubTempBuffer[0x0] = 0x01;
+				drm_dp_dpcd_write(&mtk_dp->aux, DPCD_00260,
+					ubTempBuffer, 0x1);
+				drm_dp_dpcd_read(&mtk_dp->aux, DPCD_00210,
+					ubDPCDRDBUF, 8);
+				ubTempBuffer[0x0] = 0x01;
+				drm_dp_dpcd_write(&mtk_dp->aux, DPCD_00260,
+					ubTempBuffer, 0x1);
+				break;
+			case CP2520_PATTERN3:
+				mhal_DPTx_SetTxTrainingPattern(mtk_dp, BIT(7));
+				mhal_DPTx_SetTxLane(mtk_dp,
+					ubTEST_LANE_COUNT / 2);
+				break;
+			default:
+				break;
+			};
+			break;
+
+		default:
+			DPTXMSG("DPCD 218 Not support\n");
+			return false;
+		}
+	} else {
+		bAutoTestIRQ = false;
+		return false;
+	}
+
+	usleep_range(1000, 2000);
+	mdrv_DPTx_CheckSSC(mtk_dp);
+	return true;
+}
+
+void mdrv_DPTx_CheckSinkESI(struct mtk_dp *mtk_dp, u8 *pDPCD20x, u8 *pDPCD2002)
+{
+	u8 ubTempValue;
+
+	if ((pDPCD20x[0x1]&BIT1) || (pDPCD2002[0x1]&BIT1)) {
+		if (!mdrv_DPTx_PHY_AutoTest(mtk_dp,
+			pDPCD20x[0x1] | pDPCD2002[0x1])) {
+			if (mtk_dp->training_state > DPTX_NTSTATE_TRAINING_PRE)
+				mtk_dp->training_state
+					= DPTX_NTSTATE_TRAINING_PRE;
+		}
+	}
+
+	if (pDPCD20x[0x1]&BIT0) { // not support, clrear it.
+		ubTempValue = BIT0;
+		drm_dp_dpcd_write(&mtk_dp->aux, DPCD_00201, &ubTempValue, 0x1);
+	}
+}
+
diff --git a/drivers/gpu/drm/mediatek/mtk_dp_common.h b/drivers/gpu/drm/mediatek/mtk_dp_common.h
new file mode 100644
index 0000000000000000000000000000000000000000..8d4ce50c5e5e1979311bc963c35ca4f4e0a45629
--- /dev/null
+++ b/drivers/gpu/drm/mediatek/mtk_dp_common.h
@@ -0,0 +1,220 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2019 MediaTek Inc.
+ */
+
+
+#ifndef __DRTX_TYPE_H__
+#define __DRTX_TYPE_H__
+#include "mtk_drm_ddp_comp.h"
+#include <drm/drm_bridge.h>
+#include <drm/drm_bridge_connector.h>
+#include <drm/drm_device.h>
+#include <drm/drm_dp_helper.h>
+#include "drm/mediatek_drm.h"
+#include <drm/drm_atomic_helper.h>
+#include <drm/drm_crtc_helper.h>
+#include <sound/hdmi-codec.h>
+
+#include "mtk_dp_hdcp.h"
+#include "mtk_dp_debug.h"
+
+
+#ifndef BYTE
+#define BYTE    unsigned char
+#endif
+#ifndef WORD
+#define WORD    unsigned short
+#endif
+#ifndef DWORD
+#define DWORD   unsigned long
+#endif
+
+#ifndef UINT32
+#define UINT32  unsigned int
+#endif
+
+#ifndef UINT8
+#define UINT8   unsigned char
+#endif
+
+
+#define EDID_SIZE 0x200
+#define ENABLE_DPTX_SSC_FORCEON		0
+#define ENABLE_DPTX_FIX_LRLC		0
+#define ENABLE_DPTX_SSC_OUTPUT		1
+#define ENABLE_DPTX_FIX_TPS2		0
+#define AUX_WRITE_READ_WAIT_TIME        20 //us
+#define DPTX_SUPPORT_DSC                0
+
+enum DP_ATF_CMD {
+	DP_ATF_DUMP = 0x20,
+	DP_ATF_VIDEO_UNMUTE = 0x20,
+	DP_ATF_EDP_VIDEO_UNMUTE,
+	DP_ATF_REG_WRITE,
+	DP_ATF_REG_READ,
+	DP_ATF_CMD_COUNT
+};
+
+union MISC_T {
+	struct {
+		BYTE is_sync_clock : 1;
+		BYTE color_format : 2;
+		BYTE spec_def1 : 2;
+		BYTE color_depth : 3;
+
+		BYTE interlaced : 1;
+		BYTE stereo_attr : 2;
+		BYTE reserved : 3;
+		BYTE is_vsc_sdp : 1;
+		BYTE spec_def2 : 1;
+
+	} dp_misc;
+	BYTE ucMISC[2];
+};
+
+struct DPTX_TIMING_PARAMETER {
+	WORD Htt;
+	WORD Hde;
+	WORD Hbk;
+	WORD Hfp;
+	WORD Hsw;
+
+	bool bHsp;
+	WORD Hbp;
+	WORD Vtt;
+	WORD Vde;
+	WORD Vbk;
+	WORD Vfp;
+	WORD Vsw;
+
+	bool bVsp;
+	WORD Vbp;
+	BYTE FrameRate;
+	DWORD PixRateKhz;
+	int Video_ip_mode;
+};
+
+struct DPTX_TRAINING_INFO {
+	bool bSinkEXTCAP_En;
+	bool bTPS3;
+	bool bTPS4;
+	bool bSinkSSC_En;
+	bool bDPTxAutoTest_EN;
+	bool bCablePlugIn;
+	bool bCableStateChange;
+	bool bDPMstCAP;
+	bool bDPMstBranch;
+	bool bDWN_STRM_PORT_PRESENT;
+	bool cr_done;
+	bool eq_done;
+
+	BYTE ubDPSysVersion;
+	BYTE ubSysMaxLinkRate;
+	BYTE ubLinkRate;
+	BYTE ubLinkLaneCount;
+	WORD usPHY_STS;
+	BYTE ubDPCD_REV;
+	BYTE ubSinkCountNum;
+	BYTE ucCheckCapTimes;
+};
+
+struct DPTX_INFO {
+	uint8_t input_src;
+	uint8_t depth;
+	uint8_t format;
+	uint8_t resolution;
+	unsigned int audio_caps;
+	unsigned int audio_config;
+	struct DPTX_TIMING_PARAMETER DPTX_OUTBL;
+
+	bool bPatternGen;
+	bool bSinkSSC_En;
+	bool bSetAudioMute;
+	bool bSetVideoMute;
+	bool bAudioMute;
+	bool bVideoMute;
+	bool bForceHDCP1x;
+
+#ifdef DPTX_HDCP_ENABLE
+	BYTE bAuthStatus;
+	struct HDCP1X_INFO hdcp1x_info;
+	struct HDCP2_INFO hdcp2_info;
+#endif
+
+};
+
+struct mtk_dp_driver_data {
+	bool is_edp;
+};
+
+enum dp_aud_mclk {
+	MCLK_128FS,
+	MCLK_192FS,
+	MCLK_256FS,
+	MCLK_384FS,
+	MCLK_512FS,
+	MCLK_768FS,
+	MCLK_1152FS,
+};
+
+struct mtk_dp {
+	struct device *dev;
+	struct mtk_ddp_comp ddp_comp;
+	struct drm_device *drm_dev;
+	struct drm_bridge bridge;
+	struct drm_bridge *next_bridge;
+	struct drm_connector conn;
+	struct drm_connector *curr_conn;
+	struct drm_encoder enc;
+	struct work_struct work;
+	struct workqueue_struct *workqueue;
+	u8 bridge_attached;
+	int id;
+	struct edid *edid;
+	struct drm_dp_aux aux;
+	u8 rx_cap[16];
+	struct drm_display_mode mode;
+	struct DPTX_INFO info;
+	int state;
+	int state_pre;
+	struct DPTX_TRAINING_INFO training_info;
+	int training_state;
+	int training_state_pre;
+
+	wait_queue_head_t irq_wq;
+	wait_queue_head_t control_wq;
+	wait_queue_head_t notify_wq;
+	u8 irq_status;
+	struct task_struct *task;
+	struct task_struct *control_task;
+	struct task_struct *notify_task;
+
+	u32 min_clock;
+	u32 max_clock;
+	u32 max_hdisplay;
+	u32 max_vdisplay;
+
+	void __iomem *regs;
+	struct clk *dp_tx_clk;
+
+	bool bUeventToHwc;
+	int disp_status;  //for DDP
+	bool bPowerOn;
+	bool audio_enable;
+	bool video_enable;
+	bool dp_ready;
+	bool has_dsc;
+	bool has_fec;
+	bool dsc_enable;
+	bool enabled;
+	bool powered;
+	struct mtk_drm_private *priv;
+	struct mutex dp_lock;
+	const struct mtk_dp_driver_data *driver_data;
+	hdmi_codec_plugged_cb plugged_cb;
+	struct device *codec_dev;
+	struct mutex update_plugged_status_lock;
+};
+#endif /*__DRTX_TYPE_H__*/
+
diff --git a/drivers/gpu/drm/mediatek/mtk_dp_debug.c b/drivers/gpu/drm/mediatek/mtk_dp_debug.c
new file mode 100755
index 0000000000000000000000000000000000000000..828d13c88c1d245c25225c6108017815d2d290d5
--- /dev/null
+++ b/drivers/gpu/drm/mediatek/mtk_dp_debug.c
@@ -0,0 +1,270 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2019 MediaTek Inc.
+ */
+
+#include "mtk_dp_debug.h"
+#include "mtk_dp.h"
+#include "mtk_dp_api.h"
+#include <linux/debugfs.h>
+
+static bool g_dptx_log;
+
+void mtk_dp_debug_enable(bool enable)
+{
+	g_dptx_log = enable;
+}
+
+bool mtk_dp_debug_get(void)
+{
+	return true;
+}
+
+void mtk_dp_debug(const char *opt)
+{
+	DPTXFUNC("[debug]: %s\n", opt);
+
+	if (strncmp(opt, "fakecablein:", 12) == 0) {
+		if (strncmp(opt + 12, "enable", 6) == 0) {
+			if (strncmp(opt + 12, "enable4k30P6", 12) == 0)
+				; //mtk_dp_fake_plugin(SINK_3840_2160_30, 0);
+			else if (strncmp(opt + 12, "enable4k30p8", 12) == 0)
+				; //mtk_dp_fake_plugin(SINK_3840_2160_30, 1);
+			else if (strncmp(opt + 12, "enable4k30p10", 13) == 0)
+				; //mtk_dp_fake_plugin(SINK_3840_2160_30, 2);
+
+			else if (strncmp(opt + 12, "enable4k60p6", 12) == 0)
+				; //mtk_dp_fake_plugin(SINK_3840_2160, 0);
+			else if (strncmp(opt + 12, "enable4k60p8", 12) == 0)
+				; //mtk_dp_fake_plugin(SINK_3840_2160, 1);
+			else if (strncmp(opt + 12, "enable4k60p10", 13) == 0)
+				; //mtk_dp_fake_plugin(SINK_3840_2160, 2);
+
+			else if (strncmp(opt + 12, "enable720p6", 11) == 0)
+				; //mtk_dp_fake_plugin(SINK_1280_720, 0);
+			else if (strncmp(opt + 12, "enable720p8", 11) == 0)
+				; //mtk_dp_fake_plugin(SINK_1280_720, 1);
+			else if (strncmp(opt + 12, "enable720p10", 12) == 0)
+				; //mtk_dp_fake_plugin(SINK_1280_720, 2);
+
+			else if (strncmp(opt + 12, "enable480p6", 11) == 0)
+				; //mtk_dp_fake_plugin(SINK_640_480, 0);
+			else if (strncmp(opt + 12, "enable480p8", 11) == 0)
+				; //mtk_dp_fake_plugin(SINK_640_480, 1);
+			else if (strncmp(opt + 12, "enable480p10", 12) == 0)
+				; //mtk_dp_fake_plugin(SINK_640_480, 2);
+
+			else if (strncmp(opt + 12, "enable1080p6", 12) == 0)
+				; //mtk_dp_fake_plugin(SINK_1920_1080, 0);
+			else if (strncmp(opt + 12, "enable1080p8", 12) == 0)
+				; //mtk_dp_fake_plugin(SINK_1920_1080, 1);
+			else if (strncmp(opt + 12, "enable1080p10", 13) == 0)
+				; //mtk_dp_fake_plugin(SINK_1920_1080, 2);
+		} else
+			DPTXMSG("fakecablein error msg\n");
+	} else if (strncmp(opt, "fec:", 4) == 0) {
+		if (strncmp(opt + 4, "enable", 6) == 0)
+			mtk_dp_fec_enable(1);
+		else if (strncmp(opt + 4, "disable", 7) == 0)
+			mtk_dp_fec_enable(0);
+		else
+			DPTXMSG("fec:enable/disable error msg\n");
+
+	} else if (strncmp(opt, "power:", 6) == 0) {
+		if (strncmp(opt + 6, "on", 2) == 0)
+			mtk_dp_power_save(0x1);
+		else if (strncmp(opt + 6, "off", 3) == 0)
+			mtk_dp_power_save(0x0);
+
+	} else if (strncmp(opt, "audio:", 6) == 0) {
+		if (strncmp(opt + 6, "2ch", 3) == 0)
+			mtk_dp_force_audio(0, 0xff, 0xff);
+		else if (strncmp(opt + 6, "8ch", 3) == 0)
+			mtk_dp_force_audio(6, 0xff, 0xff);
+
+		if (strncmp(opt + 9, "32fs", 4) == 0)
+			mtk_dp_force_audio(0xff, 0, 0xff);
+		else if (strncmp(opt + 9, "44fs", 4) == 0)
+			mtk_dp_force_audio(0xff, 1, 0xff);
+		else if (strncmp(opt + 9, "48fs", 4) == 0)
+			mtk_dp_force_audio(0xff, 2, 0xff);
+		else if (strncmp(opt + 9, "96fs", 4) == 0)
+			mtk_dp_force_audio(0xff, 3, 0xff);
+		else if (strncmp(opt + 9, "192f", 4) == 0)
+			mtk_dp_force_audio(0xff, 4, 0xff);
+
+		if (strncmp(opt + 13, "16bit", 5) == 0)
+			mtk_dp_force_audio(0xff, 0xff, 0);
+		else if (strncmp(opt + 13, "20bit", 5) == 0)
+			mtk_dp_force_audio(0xff, 0xff, 1);
+		else if (strncmp(opt + 13, "24bit", 5) == 0)
+			mtk_dp_force_audio(0xff, 0xff, 2);
+
+	} else if (strncmp(opt, "dptest:", 7) == 0) {
+		if (strncmp(opt + 7, "2", 1) == 0)
+			mtk_dp_test(2);
+		else if (strncmp(opt + 7, "4", 1) == 0)
+			mtk_dp_test(4);
+		else if (strncmp(opt + 7, "8", 1) == 0)
+			mtk_dp_test(8);
+		else
+			DPTXMSG("dptest error msg\n");
+	} else if (strncmp(opt, "debug_log:", 10) == 0) {
+		if (strncmp(opt + 10, "on", 2) == 0)
+			mtk_dp_debug_enable(true);
+		else if (strncmp(opt + 10, "off", 3) == 0)
+			mtk_dp_debug_enable(false);
+	} else if (strncmp(opt, "force_hdcp13:", 13) == 0) {
+		if (strncmp(opt + 13, "enable", 6) == 0)
+			;//mtk_dp_force_hdcp1x(true);
+		else
+			;//mtk_dp_force_hdcp1x(false);
+
+	} else if (strncmp(opt, "hdcp:", 5) == 0) {
+		if (strncmp(opt + 5, "enable", 6) == 0)
+			;//mtk_dp_hdcp_enable(true);
+		else if (strncmp(opt + 5, "disable", 7) == 0)
+			;//mtk_dp_hdcp_enable(false);
+	} else if (strncmp(opt, "adjust_phy:", 11) == 0) {
+		int ret = 0;
+		uint8_t c0 = 32, cp1;
+
+		ret = sscanf(opt, "adjust_phy:%hhd,%hhd\n", &c0, &cp1);
+		if (ret != 2) {
+			DPTXMSG("ret = %d\n", ret);
+			c0 = 32;
+			cp1 = 0;
+		}
+
+		DPTXMSG("g_c0 = %d, g_cp1 =%d\n", c0, cp1);
+		mtk_dp_set_adjust_phy(c0, cp1);
+	} else if (strncmp(opt, "setpowermode", 12) == 0) {
+		mtk_dp_SWInterruptSet(2);
+		mdelay(100);
+		mtk_dp_SWInterruptSet(4);
+	} else if (strncmp(opt, "pattern:", 8) == 0) {
+		int ret = 0;
+		uint8_t enable, resolution;
+
+		ret = sscanf(opt, "pattern:%hhd,%hhd\n", &enable, &resolution);
+		if (ret != 2) {
+			DPTXMSG("ret = %d\n", ret);
+			return;
+		}
+
+		DPTXMSG("Paterrn Gen:enable = %d, resolution =%d\n",
+			enable, resolution);
+		mdrv_DPTx_PatternSet(enable, resolution);
+	}
+}
+
+static struct dentry *mtkdp_dbgfs;
+
+struct mtk_dp_debug_info {
+	char *name;
+	uint8_t index;
+};
+
+enum mtk_dp_debug_index {
+	DP_INFO_HDCP      = 0,
+	DP_INFO_MAX       = 1,
+};
+
+static struct mtk_dp_debug_info dp_info[DP_INFO_MAX] = {
+	{"HDCP", DP_INFO_HDCP},
+};
+
+static uint8_t g_infoIndex = DP_INFO_HDCP;
+
+static int mtk_dp_debug_open(struct inode *inode, struct file *file)
+{
+	file->private_data = inode->i_private;
+
+	return 0;
+}
+
+static ssize_t mtk_dp_debug_read(struct file *file, char __user *ubuf,
+	size_t count, loff_t *ppos)
+{
+	int ret = 0;
+	char *buffer;
+
+	buffer = kmalloc(PAGE_SIZE/8, GFP_KERNEL);
+	if (!buffer)
+		return -ENOMEM;
+
+	switch (g_infoIndex) {
+	case DP_INFO_HDCP:
+		break;
+	default:
+		DPTXERR("Invalid inedx!");
+	}
+
+	if (ret > 0)
+		ret = simple_read_from_buffer(ubuf, count, ppos, buffer, ret);
+
+	kfree(buffer);
+	return ret;
+}
+
+static void mtk_dp_process_dbg_opt(const char *opt)
+{
+	int i = 0;
+
+	for (i = 0; i < DP_INFO_MAX; i++) {
+		if (!strncmp(opt, dp_info[i].name, strlen(dp_info[i].name))) {
+			g_infoIndex = dp_info[i].index;
+			break;
+		}
+	}
+
+	if (g_infoIndex == DP_INFO_MAX)
+		g_infoIndex = DP_INFO_HDCP;
+}
+
+static ssize_t mtk_dp_debug_write(struct file *file, const char __user *ubuf,
+	size_t count, loff_t *ppos)
+{
+	const int debug_bufmax = 512 - 1;
+	size_t ret;
+	char cmd_buffer[512];
+	char *tok;
+
+	ret = count;
+	if (count > debug_bufmax)
+		count = debug_bufmax;
+
+	if (copy_from_user(&cmd_buffer, ubuf, count))
+		return -EFAULT;
+
+	cmd_buffer[count] = 0;
+
+	DPTXMSG("[mtkdp_dbg] %s\n", cmd_buffer);
+	while ((tok = strsep((char **)&cmd_buffer, " ")) != NULL)
+		mtk_dp_process_dbg_opt(tok);
+
+	return ret;
+}
+
+static const struct file_operations dp_debug_fops = {
+	.read = mtk_dp_debug_read,
+	.write = mtk_dp_debug_write,
+	.open = mtk_dp_debug_open,
+};
+
+int mtk_dp_debugfs_init(void)
+{
+	mtkdp_dbgfs = debugfs_create_file("mtk_dpinfo", 0644,
+		NULL, NULL, &dp_debug_fops);
+	if (IS_ERR_OR_NULL(mtkdp_dbgfs))
+		return -ENOMEM;
+
+	return 0;
+}
+
+void mtk_dp_debugfs_deinit(void)
+{
+	debugfs_remove(mtkdp_dbgfs);
+}
+
+
diff --git a/drivers/gpu/drm/mediatek/mtk_dp_debug.h b/drivers/gpu/drm/mediatek/mtk_dp_debug.h
new file mode 100644
index 0000000000000000000000000000000000000000..44be798a9cfd96da90fb6d9afcfeda5a6b129d3c
--- /dev/null
+++ b/drivers/gpu/drm/mediatek/mtk_dp_debug.h
@@ -0,0 +1,33 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2019 MediaTek Inc.
+ */
+
+#ifndef __MTK_DP_DEBUG_H__
+#define __MTK_DP_DEBUG_H__
+#include <linux/types.h>
+
+void mtk_dp_debug_enable(bool enable);
+bool mtk_dp_debug_get(void);
+void mtk_dp_debug(const char *opt);
+int mtk_dp_debugfs_init(void);
+void mtk_dp_debugfs_deinit(void);
+
+
+#define DPTXFUNC(fmt, arg...)		\
+	pr_info("[DPTX][%s line:%d]"pr_fmt(fmt), __func__, __LINE__, ##arg)
+
+#define DPTXDBG(fmt, arg...)              \
+	do {                                 \
+			pr_info("[DPTX]"pr_fmt(fmt), ##arg);     \
+	} while (0)
+
+#define DPTXMSG(fmt, arg...)                                  \
+		pr_info("[DPTX]"pr_fmt(fmt), ##arg)
+
+#define DPTXERR(fmt, arg...)                                   \
+		pr_err("[DPTX][ERROR]"pr_fmt(fmt), ##arg)
+
+
+#endif
+
diff --git a/drivers/gpu/drm/mediatek/mtk_dp_hal.c b/drivers/gpu/drm/mediatek/mtk_dp_hal.c
new file mode 100644
index 0000000000000000000000000000000000000000..19c665174acabee0a3c784be41421665a1d55265
--- /dev/null
+++ b/drivers/gpu/drm/mediatek/mtk_dp_hal.c
@@ -0,0 +1,2272 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2019 MediaTek Inc.
+ */
+
+#include "mtk_dp_hal.h"
+#include <linux/io.h>
+#include <linux/of.h>
+#include <linux/of_platform.h>
+#include <linux/sched/clock.h>
+#include <linux/arm-smccc.h>
+#include <linux/nvmem-consumer.h>
+#include <linux/soc/mediatek/mtk_sip_svc.h>
+#include "mtk_dp_reg.h"
+
+u32 mtk_dp_read(struct mtk_dp *mtk_dp, u32 offset)
+{
+	u32 read_val = 0;
+
+	if (offset > 0x8000) {
+		pr_err("dptx %s, error reg 0x%p, offset 0x%x\n",
+			__func__, mtk_dp->regs, offset);
+		return 0;
+	}
+
+	read_val = readl(mtk_dp->regs + offset - (offset%4))
+			>> ((offset % 4) * 8);
+
+	return read_val;
+}
+
+void mtk_dp_write(struct mtk_dp *mtk_dp, u32 offset, u32 val)
+{
+	if ((offset % 4 != 0) || (offset > 0x8000)) {
+		pr_err("dptx %s, error reg 0x%p, offset 0x%x, value 0x%x\n",
+			__func__, mtk_dp->regs, offset, val);
+		return;
+	}
+
+	writel(val, mtk_dp->regs + offset);
+}
+
+void mtk_dp_mask(struct mtk_dp *mtk_dp, u32 offset, u32 val, u32 mask)
+{
+	void __iomem *reg = mtk_dp->regs + offset;
+	u32 tmp;
+
+	if ((offset % 4 != 0) || (offset > 0x8000)) {
+		pr_err("dptx %s, error reg 0x%p, offset 0x%x, value 0x%x\n",
+			__func__, mtk_dp->regs, offset, val);
+		return;
+	}
+
+	tmp = readl(reg);
+	tmp = (tmp & ~mask) | (val & mask);
+	writel(tmp, reg);
+}
+
+void mtk_dp_write_byte(struct mtk_dp *mtk_dp,
+	u32 addr, u8 val, u32 mask)
+{
+	if (addr % 2) {
+		mtk_dp_write(mtk_dp, DP_TX_TOP_APB_WSTRB, 0x12);
+		mtk_dp_mask(mtk_dp, addr - 1, (u32)(val << 8), (mask << 8));
+	} else {
+		mtk_dp_write(mtk_dp, DP_TX_TOP_APB_WSTRB, 0x11);
+		mtk_dp_mask(mtk_dp, addr, (u32)val, mask);
+	}
+
+	mtk_dp_write(mtk_dp, DP_TX_TOP_APB_WSTRB, 0x00);
+}
+
+static unsigned long mtk_dp_atf_call(unsigned int cmd, unsigned int para)
+{
+#if 1
+	struct arm_smccc_res res;
+
+#define MTK_SIP_DP_CONTROL_AARCH32 0x82000523
+
+	arm_smccc_smc(MTK_SIP_DP_CONTROL_AARCH32, cmd, para,
+		0, 0, 0, 0, 0, &res);
+
+	DPTXDBG("%s cmd 0x%x, p1 0x%x, ret 0x%x-0x%x",
+		__func__, cmd, para, res.a0, res.a1);
+	return res.a1;
+#else
+	return 0;
+#endif
+}
+
+void mhal_dump_reg(struct mtk_dp *mtk_dp)
+{
+	u32 i, val[4], reg;
+
+	for (i = 0x0; i < 0x600; i += 16) {
+		reg = 0x3000 + i;
+		val[0] = msRead4Byte(mtk_dp, reg);
+		val[1] = msRead4Byte(mtk_dp, reg + 4);
+		val[2] = msRead4Byte(mtk_dp, reg + 8);
+		val[3] = msRead4Byte(mtk_dp, reg + 12);
+		dev_info(mtk_dp->dev,"aux reg[0x%x] = 0x%x 0x%x 0x%x 0x%x",
+			reg, val[0], val[1], val[2], val[3]);
+	}
+}
+
+void mhal_DPTx_Verify_Clock(struct mtk_dp *mtk_dp)
+{
+	u32 m, n, Ls_clk, pix_clk;
+
+	m = msRead4Byte(mtk_dp, REG_33C8_DP_ENCODER1_P0);
+	n = 0x8000;
+	Ls_clk = mtk_dp->training_info.ubLinkRate;
+	Ls_clk *= 27;
+
+	pix_clk = m * Ls_clk / n;
+	dev_info(mtk_dp->dev,"DPTX calc pixel clock = %d MHz, dp_intf clock = %dMHz\n",
+		pix_clk, pix_clk/4);
+}
+
+void mhal_DPTx_InitialSetting(struct mtk_dp *mtk_dp)
+{
+	msWriteByte(mtk_dp, REG_342C_DP_TRANS_P0, 0x69);
+	msWrite4ByteMask(mtk_dp, REG_3540_DP_TRANS_P0, BIT3, BIT3);
+	msWrite4ByteMask(mtk_dp, REG_31EC_DP_ENCODER0_P0, BIT4, BIT4);
+	msWrite4ByteMask(mtk_dp, REG_304C_DP_ENCODER0_P0, 0, BIT8);
+	msWrite4ByteMask(mtk_dp, DP_TX_TOP_IRQ_MASK, BIT2, BIT2);
+}
+
+void mhal_DPTx_DataLanePNSwap(struct mtk_dp *mtk_dp, bool bENABLE)
+{
+	if (bENABLE) {
+		msWriteByteMask(mtk_dp, REG_3428_DP_TRANS_P0,
+			POST_MISC_PN_SWAP_EN_LANE0_DP_TRANS_P0_FLDMASK_POS,
+			POST_MISC_PN_SWAP_EN_LANE0_DP_TRANS_P0_FLDMASK);
+		msWriteByteMask(mtk_dp, REG_3428_DP_TRANS_P0,
+			POST_MISC_PN_SWAP_EN_LANE1_DP_TRANS_P0_FLDMASK_POS,
+			POST_MISC_PN_SWAP_EN_LANE1_DP_TRANS_P0_FLDMASK);
+		msWriteByteMask(mtk_dp, REG_3428_DP_TRANS_P0,
+			POST_MISC_PN_SWAP_EN_LANE2_DP_TRANS_P0_FLDMASK_POS,
+			POST_MISC_PN_SWAP_EN_LANE2_DP_TRANS_P0_FLDMASK);
+		msWriteByteMask(mtk_dp, REG_3428_DP_TRANS_P0,
+			POST_MISC_PN_SWAP_EN_LANE3_DP_TRANS_P0_FLDMASK_POS,
+			POST_MISC_PN_SWAP_EN_LANE3_DP_TRANS_P0_FLDMASK);
+	} else {
+		msWriteByteMask(mtk_dp, REG_3428_DP_TRANS_P0, 0,
+			POST_MISC_PN_SWAP_EN_LANE0_DP_TRANS_P0_FLDMASK);
+		msWriteByteMask(mtk_dp, REG_3428_DP_TRANS_P0, 0,
+			POST_MISC_PN_SWAP_EN_LANE1_DP_TRANS_P0_FLDMASK);
+		msWriteByteMask(mtk_dp, REG_3428_DP_TRANS_P0, 0,
+			POST_MISC_PN_SWAP_EN_LANE2_DP_TRANS_P0_FLDMASK);
+		msWriteByteMask(mtk_dp, REG_3428_DP_TRANS_P0, 0,
+			POST_MISC_PN_SWAP_EN_LANE3_DP_TRANS_P0_FLDMASK);
+	}
+}
+
+void mhal_DPTx_Set_Efuse_Value(struct mtk_dp *mtk_dp)
+{
+#if 0
+	u32 efuse = get_devinfo_with_index(114);
+
+	if (efuse) {
+		msWrite4ByteMask(mtk_dp, 0x0008, efuse >> 1, BITMASK(23 : 20));
+		msWrite4ByteMask(mtk_dp, 0x0000, efuse, BITMASK(20 : 16));
+		msWrite4ByteMask(mtk_dp, 0x0104, efuse, BITMASK(15 : 12));
+		msWrite4ByteMask(mtk_dp, 0x0104, efuse << 8, BITMASK(19 : 16));
+		msWrite4ByteMask(mtk_dp, 0x0204, efuse << 8, BITMASK(15 : 12));
+		msWrite4ByteMask(mtk_dp, 0x0204, efuse << 16, BITMASK(19 : 16));
+	}
+#endif
+}
+
+void mhal_DPTx_Set_VideoInterlance(struct mtk_dp *mtk_dp, bool bENABLE)
+{
+	if (bENABLE) {
+		msWriteByteMask(mtk_dp, REG_3030_DP_ENCODER0_P0 + 1,
+			BIT6|BIT5, BIT6|BIT5);
+		msWriteByteMask(mtk_dp, REG_3368_DP_ENCODER1_P0 + 1,
+			0, BIT5|BIT4);
+	} else {
+		msWriteByteMask(mtk_dp, REG_3030_DP_ENCODER0_P0 + 1,
+			BIT6, BIT6|BIT5);
+		msWriteByteMask(mtk_dp, REG_3368_DP_ENCODER1_P0 + 1,
+			BIT4, BIT5|BIT4);
+	}
+}
+
+void mhal_DPTx_EnableBypassMSA(struct mtk_dp *mtk_dp, bool bENABLE)
+{
+	if (bENABLE)
+		msWrite2ByteMask(mtk_dp, REG_3030_DP_ENCODER0_P0,
+			0, 0x03FF);
+	else
+		msWrite2ByteMask(mtk_dp, REG_3030_DP_ENCODER0_P0,
+			0x03FF, 0x03FF);
+}
+
+void mhal_DPTx_SetMSA(struct mtk_dp *mtk_dp)
+{
+	struct DPTX_TIMING_PARAMETER *DPTX_TBL = &mtk_dp->info.DPTX_OUTBL;
+
+	msWrite2Byte(mtk_dp, REG_3010_DP_ENCODER0_P0, DPTX_TBL->Htt);
+	msWrite2Byte(mtk_dp, REG_3018_DP_ENCODER0_P0,
+		DPTX_TBL->Hsw + DPTX_TBL->Hbp);
+	msWrite2ByteMask(mtk_dp, REG_3028_DP_ENCODER0_P0,
+		DPTX_TBL->Hsw << HSW_SW_DP_ENCODER0_P0_FLDMASK_POS,
+		HSW_SW_DP_ENCODER0_P0_FLDMASK);
+	msWrite2ByteMask(mtk_dp, REG_3028_DP_ENCODER0_P0,
+		DPTX_TBL->bHsp << HSP_SW_DP_ENCODER0_P0_FLDMASK_POS,
+		HSP_SW_DP_ENCODER0_P0_FLDMASK);
+	msWrite2Byte(mtk_dp, REG_3020_DP_ENCODER0_P0, DPTX_TBL->Hde);
+	msWrite2Byte(mtk_dp, REG_3014_DP_ENCODER0_P0, DPTX_TBL->Vtt);
+	msWrite2Byte(mtk_dp, REG_301C_DP_ENCODER0_P0,
+		DPTX_TBL->Vsw + DPTX_TBL->Vbp);
+	msWrite2ByteMask(mtk_dp, REG_302C_DP_ENCODER0_P0,
+		DPTX_TBL->Vsw << VSW_SW_DP_ENCODER0_P0_FLDMASK_POS,
+		VSW_SW_DP_ENCODER0_P0_FLDMASK);
+	msWrite2ByteMask(mtk_dp, REG_302C_DP_ENCODER0_P0,
+		DPTX_TBL->bVsp << VSP_SW_DP_ENCODER0_P0_FLDMASK_POS,
+		VSP_SW_DP_ENCODER0_P0_FLDMASK);
+	msWrite2Byte(mtk_dp, REG_3024_DP_ENCODER0_P0, DPTX_TBL->Vde);
+	msWrite2Byte(mtk_dp, REG_3064_DP_ENCODER0_P0, DPTX_TBL->Hde);
+	msWrite2Byte(mtk_dp, REG_3154_DP_ENCODER0_P0, (DPTX_TBL->Htt));
+	msWrite2Byte(mtk_dp, REG_3158_DP_ENCODER0_P0, (DPTX_TBL->Hfp));
+	msWrite2Byte(mtk_dp, REG_315C_DP_ENCODER0_P0, (DPTX_TBL->Hsw));
+	msWrite2Byte(mtk_dp, REG_3160_DP_ENCODER0_P0,
+		DPTX_TBL->Hbp + DPTX_TBL->Hsw);
+	msWrite2Byte(mtk_dp, REG_3164_DP_ENCODER0_P0, (DPTX_TBL->Hde));
+	msWrite2Byte(mtk_dp, REG_3168_DP_ENCODER0_P0, DPTX_TBL->Vtt);
+	msWrite2Byte(mtk_dp, REG_316C_DP_ENCODER0_P0, DPTX_TBL->Vfp);
+	msWrite2Byte(mtk_dp, REG_3170_DP_ENCODER0_P0, DPTX_TBL->Vsw);
+	msWrite2Byte(mtk_dp, REG_3174_DP_ENCODER0_P0,
+		DPTX_TBL->Vbp + DPTX_TBL->Vsw);
+	msWrite2Byte(mtk_dp, REG_3178_DP_ENCODER0_P0, DPTX_TBL->Vde);
+}
+
+void mhal_DPTx_SetColorFormat(struct mtk_dp *mtk_dp, BYTE  enOutColorFormat)
+{
+	msWriteByteMask(mtk_dp, REG_3034_DP_ENCODER0_P0,
+		(enOutColorFormat << 0x1), MASKBIT(2 : 1));  //MISC0
+
+	if ((enOutColorFormat == DP_COLOR_FORMAT_RGB_444)
+		|| (enOutColorFormat == DP_COLOR_FORMAT_YUV_444))
+		msWriteByteMask(mtk_dp, REG_303C_DP_ENCODER0_P0 + 1,
+			(0), MASKBIT(6 : 4));
+	else if (enOutColorFormat == DP_COLOR_FORMAT_YUV_422)
+		msWriteByteMask(mtk_dp, REG_303C_DP_ENCODER0_P0 + 1,
+			(BIT4), MASKBIT(6 : 4));
+	else if (enOutColorFormat == DP_COLOR_FORMAT_YUV_420)
+		msWriteByteMask(mtk_dp, REG_303C_DP_ENCODER0_P0 + 1, (BIT5),
+			MASKBIT(6 : 4));
+}
+
+void mhal_DPTx_SetColorDepth(struct mtk_dp *mtk_dp, BYTE coloer_depth)
+{
+	msWriteByteMask(mtk_dp, REG_3034_DP_ENCODER0_P0,
+		(coloer_depth << 0x5), 0xE0);
+
+	switch (coloer_depth) {
+	case DP_COLOR_DEPTH_6BIT:
+		msWriteByteMask(mtk_dp,
+			REG_303C_DP_ENCODER0_P0 + 1,
+			4,
+			0x07);
+		break;
+
+	case DP_COLOR_DEPTH_8BIT:
+		msWriteByteMask(mtk_dp,
+			REG_303C_DP_ENCODER0_P0 + 1,
+			3,
+			0x07);
+		break;
+
+	case DP_COLOR_DEPTH_10BIT:
+		msWriteByteMask(mtk_dp,
+			REG_303C_DP_ENCODER0_P0 + 1,
+			2,
+			0x07);
+		break;
+
+	case DP_COLOR_DEPTH_12BIT:
+		msWriteByteMask(mtk_dp,
+			REG_303C_DP_ENCODER0_P0 + 1,
+			1,
+			0x07);
+		break;
+
+	case DP_COLOR_DEPTH_16BIT:
+		msWriteByteMask(mtk_dp,
+			REG_303C_DP_ENCODER0_P0 + 1,
+			0,
+			0x07);
+		break;
+
+	default:
+		break;
+	}
+}
+
+
+void mhal_DPTx_SetMISC(struct mtk_dp *mtk_dp, BYTE ucMISC[2])
+{
+	msWriteByteMask(mtk_dp, REG_3034_DP_ENCODER0_P0,
+		ucMISC[0], 0xFE);
+	msWriteByteMask(mtk_dp, REG_3034_DP_ENCODER0_P0 + 1,
+		ucMISC[1], 0xFF);
+}
+
+void mhal_DPTx_Set_MVIDx2(struct mtk_dp *mtk_dp, bool bEnable)
+{
+	if (bEnable)
+		msWriteByteMask(mtk_dp, REG_300C_DP_ENCODER0_P0 + 1,
+			BIT4, BIT6|BIT5|BIT4);
+	else
+		msWriteByteMask(mtk_dp, REG_300C_DP_ENCODER0_P0 + 1,
+			0, BIT6|BIT5|BIT4);
+}
+
+bool mhal_DPTx_OverWrite_MN(struct mtk_dp *mtk_dp,
+	bool bEnable, DWORD ulVideo_M, DWORD ulVideo_N)
+{
+	if (bEnable) {
+		//Turn-on overwrite MN
+		msWrite2Byte(mtk_dp,
+			REG_3008_DP_ENCODER0_P0,
+			ulVideo_M & 0xFFFF);
+		msWriteByte(mtk_dp,
+			REG_300C_DP_ENCODER0_P0,
+			((ulVideo_M >> 16) & 0xFF));
+		msWrite2Byte(mtk_dp,
+			REG_3044_DP_ENCODER0_P0,
+			ulVideo_N & 0xFFFF);
+		msWriteByte(mtk_dp,
+			REG_3048_DP_ENCODER0_P0,
+			(ulVideo_N >> 16) & 0xFF);
+		msWrite2Byte(mtk_dp,
+			REG_3050_DP_ENCODER0_P0,
+			ulVideo_N & 0xFFFF);
+		// legerII add
+		msWriteByte(mtk_dp,
+			REG_3054_DP_ENCODER0_P0,
+			(ulVideo_N >> 16) & 0xFF);
+		//LegerII add
+		msWriteByteMask(mtk_dp,
+			REG_3004_DP_ENCODER0_P0 + 1,
+			BIT0,
+			BIT0);
+	} else {
+		//Turn-off overwrite MN
+		msWriteByteMask(mtk_dp,
+			REG_3004_DP_ENCODER0_P0 + 1,
+			0,
+			BIT0);
+	}
+
+	return true;
+}
+
+BYTE mhal_DPTx_GetColorBpp(struct mtk_dp *mtk_dp)
+{
+	BYTE ColorBpp;
+	BYTE ubDPTXColorDepth = mtk_dp->info.depth;
+	BYTE ubDPTXColorFormat = mtk_dp->info.format;
+
+	switch (ubDPTXColorDepth) {
+	case DP_COLOR_DEPTH_6BIT:
+		if (ubDPTXColorFormat == DP_COLOR_FORMAT_YUV_422)
+			ColorBpp = 16;
+		else if (ubDPTXColorFormat == DP_COLOR_FORMAT_YUV_420)
+			ColorBpp = 12;
+		else
+			ColorBpp = 18;
+		break;
+	case DP_COLOR_DEPTH_8BIT:
+		if (ubDPTXColorFormat == DP_COLOR_FORMAT_YUV_422)
+			ColorBpp = 16;
+		else if (ubDPTXColorFormat == DP_COLOR_FORMAT_YUV_420)
+			ColorBpp = 12;
+		else
+			ColorBpp = 24;
+		break;
+	case DP_COLOR_DEPTH_10BIT:
+		if (ubDPTXColorFormat == DP_COLOR_FORMAT_YUV_422)
+			ColorBpp = 20;
+		else if (ubDPTXColorFormat == DP_COLOR_FORMAT_YUV_420)
+			ColorBpp = 15;
+		else
+			ColorBpp = 30;
+		break;
+	case DP_COLOR_DEPTH_12BIT:
+		if (ubDPTXColorFormat == DP_COLOR_FORMAT_YUV_422)
+			ColorBpp = 24;
+		else if (ubDPTXColorFormat == DP_COLOR_FORMAT_YUV_420)
+			ColorBpp = 18;
+		else
+			ColorBpp = 36;
+		break;
+	case DP_COLOR_DEPTH_16BIT:
+		if (ubDPTXColorFormat == DP_COLOR_FORMAT_YUV_422)
+			ColorBpp = 32;
+		else if (ubDPTXColorFormat == DP_COLOR_FORMAT_YUV_420)
+			ColorBpp = 24;
+		else
+			ColorBpp = 48;
+		break;
+	default:
+		ColorBpp = 24;
+		break;
+	}
+
+	return ColorBpp;
+}
+
+void mhal_DPTx_SetTU_SramRdStart(struct mtk_dp *mtk_dp, WORD uwValue)
+{
+	//[5:0]video sram start address=>modify in 480P case only, default=0x1F
+	msWriteByteMask(mtk_dp, REG_303C_DP_ENCODER0_P0, uwValue, 0x3F);
+}
+
+void mhal_DPTx_SetSDP_DownCntinitInHblanking(struct mtk_dp *mtk_dp,
+	WORD uwValue)
+{
+	 //[11 : 0]mtk_dp, REG_sdp_down_cnt_init_in_hblank
+	msWrite2ByteMask(mtk_dp, REG_3364_DP_ENCODER1_P0, uwValue, 0x0FFF);
+
+}
+
+void mhal_DPTx_SetSDP_DownCntinit(struct mtk_dp *mtk_dp, WORD uwValue)
+{
+	//[11 : 0]mtk_dp, REG_sdp_down_cnt_init
+	msWrite2ByteMask(mtk_dp, REG_3040_DP_ENCODER0_P0, uwValue, 0x0FFF);
+}
+
+void mhal_DPTx_SetTU_SetEncoder(struct mtk_dp *mtk_dp)
+{
+	msWriteByteMask(mtk_dp, REG_303C_DP_ENCODER0_P0 + 1, BIT7, BIT7);
+	msWrite2Byte(mtk_dp, REG_3040_DP_ENCODER0_P0, 0x2020);
+	msWrite2ByteMask(mtk_dp, REG_3364_DP_ENCODER1_P0, 0x2020, 0x0FFF);
+	msWriteByteMask(mtk_dp, REG_3300_DP_ENCODER1_P0 + 1, 0x02, BIT1|BIT0);
+	msWriteByteMask(mtk_dp, REG_3364_DP_ENCODER1_P0 + 1, 0x40, 0x70);
+	msWrite2Byte(mtk_dp, REG_3368_DP_ENCODER1_P0, 0x1111);
+}
+
+void mhal_DPTx_PGEnable(struct mtk_dp *mtk_dp, bool bENABLE)
+{
+	if (bENABLE)
+		msWriteByteMask(mtk_dp,
+			REG_3038_DP_ENCODER0_P0 + 1,
+			BIT3,
+			BIT3);
+	else
+		msWriteByteMask(mtk_dp,
+			REG_3038_DP_ENCODER0_P0 + 1,
+			0,
+			BIT3);
+
+	msWriteByteMask(mtk_dp, REG_31B0_DP_ENCODER0_P0, BIT6, BIT6);
+}
+
+void mhal_DPTx_PG_Pure_Color(struct mtk_dp *mtk_dp, BYTE BGR, DWORD ColorDepth)
+{
+	msWriteByteMask(mtk_dp, REG_3038_DP_ENCODER0_P0 + 1, BIT3, BIT3);
+	msWriteByteMask(mtk_dp, REG_31B0_DP_ENCODER0_P0, 0, MASKBIT(6:4));
+
+	switch (BGR) {
+	case DPTX_PG_PURECOLOR_BLUE:
+		msWrite2ByteMask(mtk_dp, REG_317C_DP_ENCODER0_P0,
+			0, MASKBIT(11:0));
+		msWrite2ByteMask(mtk_dp, REG_3180_DP_ENCODER0_P0,
+			0, MASKBIT(11:0));
+		msWrite2ByteMask(mtk_dp, REG_3184_DP_ENCODER0_P0,
+			ColorDepth, MASKBIT(11:0));
+		break;
+
+	case DPTX_PG_PURECOLOR_GREEN:
+		msWrite2ByteMask(mtk_dp, REG_317C_DP_ENCODER0_P0,
+			0, MASKBIT(11:0));
+		msWrite2ByteMask(mtk_dp, REG_3180_DP_ENCODER0_P0,
+			ColorDepth, MASKBIT(11:0));
+		msWrite2ByteMask(mtk_dp, REG_3184_DP_ENCODER0_P0,
+			0, MASKBIT(11:0));
+		break;
+
+	case DPTX_PG_PURECOLOR_RED:
+		msWrite2ByteMask(mtk_dp, REG_317C_DP_ENCODER0_P0,
+			ColorDepth, MASKBIT(11:0));
+		msWrite2ByteMask(mtk_dp, REG_3180_DP_ENCODER0_P0,
+			0, MASKBIT(11:0));
+		msWrite2ByteMask(mtk_dp, REG_3184_DP_ENCODER0_P0,
+			0, MASKBIT(11:0));
+		break;
+
+	default:
+		msWrite2ByteMask(mtk_dp, REG_317C_DP_ENCODER0_P0,
+			ColorDepth, MASKBIT(11:0));
+		msWrite2ByteMask(mtk_dp, REG_3180_DP_ENCODER0_P0,
+			0, MASKBIT(11:0));
+		msWrite2ByteMask(mtk_dp, REG_3184_DP_ENCODER0_P0,
+			0, MASKBIT(11:0));
+		break;
+	}
+}
+
+void mhal_DPTx_PG_VerticalRamping(struct mtk_dp *mtk_dp, BYTE BGR,
+	DWORD ColorDepth, BYTE Location)
+{
+	msWriteByteMask(mtk_dp, REG_3038_DP_ENCODER0_P0 + 1, BIT3, BIT3);
+	msWriteByteMask(mtk_dp, REG_31B0_DP_ENCODER0_P0, BIT4, MASKBIT(6:4));
+	msWriteByteMask(mtk_dp, REG_31B0_DP_ENCODER0_P0, BIT7, BIT7);
+
+	switch (Location) {
+	case DPTX_PG_LOCATION_ALL:
+		msWrite2ByteMask(mtk_dp, REG_317C_DP_ENCODER0_P0,
+			0, MASKBIT(11:0));
+		msWrite2ByteMask(mtk_dp, REG_3180_DP_ENCODER0_P0,
+			0, MASKBIT(11:0));
+		msWrite2ByteMask(mtk_dp, REG_3184_DP_ENCODER0_P0,
+			ColorDepth, MASKBIT(11:0));
+		msWriteByteMask(mtk_dp, REG_31B0_DP_ENCODER0_P0,
+			BGR, MASKBIT(2:0));
+		msWrite2Byte(mtk_dp, REG_31A0_DP_ENCODER0_P0, 0x3FFF);
+		break;
+
+	case DPTX_PG_LOCATION_TOP:
+		msWrite2ByteMask(mtk_dp, REG_317C_DP_ENCODER0_P0,
+			0, MASKBIT(11:0));
+		msWrite2ByteMask(mtk_dp, REG_3180_DP_ENCODER0_P0,
+			ColorDepth, MASKBIT(11:0));
+		msWrite2ByteMask(mtk_dp, REG_3184_DP_ENCODER0_P0,
+			0, MASKBIT(11:0));
+		msWriteByteMask(mtk_dp, REG_31B0_DP_ENCODER0_P0,
+			BGR, MASKBIT(2:0));
+		msWrite2Byte(mtk_dp, REG_31A0_DP_ENCODER0_P0, 0x40);
+		break;
+
+	case DPTX_PG_LOCATION_BOTTOM:
+		msWrite2ByteMask(mtk_dp, REG_317C_DP_ENCODER0_P0,
+			ColorDepth, MASKBIT(11:0));
+		msWrite2ByteMask(mtk_dp, REG_3180_DP_ENCODER0_P0,
+			0, MASKBIT(11:0));
+		msWrite2ByteMask(mtk_dp, REG_3184_DP_ENCODER0_P0,
+			0, MASKBIT(11:0));
+		msWriteByteMask(mtk_dp, REG_31B0_DP_ENCODER0_P0,
+			BGR, MASKBIT(2:0));
+		msWrite2Byte(mtk_dp, REG_31A0_DP_ENCODER0_P0, 0x2FFF);
+		break;
+
+	default:
+		msWrite2ByteMask(mtk_dp, REG_317C_DP_ENCODER0_P0,
+			0, MASKBIT(11:0));
+		msWrite2ByteMask(mtk_dp, REG_3180_DP_ENCODER0_P0,
+			0, MASKBIT(11:0));
+		msWrite2ByteMask(mtk_dp, REG_3184_DP_ENCODER0_P0,
+			ColorDepth, MASKBIT(11:0));
+		msWriteByteMask(mtk_dp, REG_31B0_DP_ENCODER0_P0,
+			BGR, MASKBIT(2:0));
+		msWrite2Byte(mtk_dp, REG_31A0_DP_ENCODER0_P0, 0x3FFF);
+
+		break;
+	}
+}
+
+void mhal_DPTx_PG_HorizontalRamping(struct mtk_dp *mtk_dp, BYTE BGR,
+	DWORD ColorDepth, BYTE Location)
+{
+	DWORD Ramp = 0x3FFF;
+
+	//ColorDepth = 0x0000;
+
+	msWriteByteMask(mtk_dp, REG_3038_DP_ENCODER0_P0 + 1, BIT3, BIT3);
+	msWriteByteMask(mtk_dp, REG_31B0_DP_ENCODER0_P0, BIT5, MASKBIT(6:4));
+	msWriteByteMask(mtk_dp, REG_31B0_DP_ENCODER0_P0, BIT7, BIT7);
+	msWrite2Byte(mtk_dp, REG_31A0_DP_ENCODER0_P0, Ramp);
+
+	switch (Location) {
+	case DPTX_PG_LOCATION_ALL:
+		msWrite2ByteMask(mtk_dp, REG_317C_DP_ENCODER0_P0,
+			0, MASKBIT(11:0));
+		msWrite2ByteMask(mtk_dp, REG_3180_DP_ENCODER0_P0,
+			0, MASKBIT(11:0));
+		msWrite2ByteMask(mtk_dp, REG_3184_DP_ENCODER0_P0,
+			0, MASKBIT(11:0));
+		msWriteByteMask(mtk_dp, REG_31B0_DP_ENCODER0_P0,
+			BGR, MASKBIT(2:0));
+		break;
+
+	case DPTX_PG_LOCATION_LEFT_OF_TOP:
+		msWrite2ByteMask(mtk_dp, REG_317C_DP_ENCODER0_P0,
+			0, MASKBIT(11:0));
+		msWrite2ByteMask(mtk_dp, REG_3180_DP_ENCODER0_P0,
+			0, MASKBIT(11:0));
+		msWrite2ByteMask(mtk_dp, REG_3184_DP_ENCODER0_P0,
+			0, MASKBIT(11:0));
+		msWriteByteMask(mtk_dp, REG_31B0_DP_ENCODER0_P0,
+			BGR, MASKBIT(2:0));
+		msWrite2Byte(mtk_dp, REG_31A0_DP_ENCODER0_P0, 0x3FFF);
+		break;
+
+	case DPTX_PG_LOCATION_LEFT_OF_BOTTOM:
+		msWrite2ByteMask(mtk_dp, REG_317C_DP_ENCODER0_P0,
+			0, MASKBIT(11:0));
+		msWrite2ByteMask(mtk_dp, REG_3180_DP_ENCODER0_P0,
+			0, MASKBIT(11:0));
+		msWrite2ByteMask(mtk_dp, REG_3184_DP_ENCODER0_P0,
+			0, MASKBIT(11:0));
+		msWriteByteMask(mtk_dp, REG_31B0_DP_ENCODER0_P0,
+			BGR, MASKBIT(2:0));
+		msWrite2Byte(mtk_dp, REG_31A0_DP_ENCODER0_P0, 0x3FFF);
+		break;
+
+	default:
+		break;
+
+	}
+}
+
+void mhal_DPTx_PG_VerticalColorBar(struct mtk_dp *mtk_dp, BYTE Location)
+{
+	msWriteByteMask(mtk_dp, REG_3038_DP_ENCODER0_P0 + 1, BIT3, BIT3);
+	msWriteByteMask(mtk_dp, REG_31B0_DP_ENCODER0_P0,
+		BIT5|BIT4, MASKBIT(6:4));
+
+	switch (Location) {
+	case DPTX_PG_LOCATION_ALL:
+		msWriteByteMask(mtk_dp, REG_3190_DP_ENCODER0_P0,
+			0, MASKBIT(5:4));
+		msWriteByteMask(mtk_dp, REG_3190_DP_ENCODER0_P0,
+			0, MASKBIT(2:0));
+		break;
+
+	case DPTX_PG_LOCATION_LEFT:
+		msWriteByteMask(mtk_dp, REG_3190_DP_ENCODER0_P0,
+			BIT4, MASKBIT(5:4));
+		msWriteByteMask(mtk_dp, REG_3190_DP_ENCODER0_P0,
+			0, MASKBIT(2:0));
+		break;
+
+	case DPTX_PG_LOCATION_RIGHT:
+		msWriteByteMask(mtk_dp, REG_3190_DP_ENCODER0_P0,
+			BIT4, MASKBIT(5:4));
+		msWriteByteMask(mtk_dp, REG_3190_DP_ENCODER0_P0,
+			BIT2, MASKBIT(2:0));
+		break;
+
+	case DPTX_PG_LOCATION_LEFT_OF_LEFT:
+		msWriteByteMask(mtk_dp, REG_3190_DP_ENCODER0_P0,
+			BIT5|BIT4, MASKBIT(5:4));
+		msWriteByteMask(mtk_dp, REG_3190_DP_ENCODER0_P0,
+			0, MASKBIT(2:0));
+		break;
+
+	case DPTX_PG_LOCATION_RIGHT_OF_LEFT:
+		msWriteByteMask(mtk_dp, REG_3190_DP_ENCODER0_P0,
+			BIT5|BIT4, MASKBIT(5:4));
+		msWriteByteMask(mtk_dp, REG_3190_DP_ENCODER0_P0,
+			BIT1, MASKBIT(2:0));
+		break;
+
+	case DPTX_PG_LOCATION_LEFT_OF_RIGHT:
+		msWriteByteMask(mtk_dp, REG_3190_DP_ENCODER0_P0,
+			BIT5|BIT4, MASKBIT(5:4));
+		msWriteByteMask(mtk_dp, REG_3190_DP_ENCODER0_P0,
+			BIT2, MASKBIT(2:0));
+		break;
+
+	case DPTX_PG_LOCATION_RIGHT_OF_RIGHT:
+		msWriteByteMask(mtk_dp, REG_3190_DP_ENCODER0_P0,
+			BIT5|BIT4, MASKBIT(5:4));
+		msWriteByteMask(mtk_dp, REG_3190_DP_ENCODER0_P0,
+			BIT2|BIT1, MASKBIT(2:0));
+		break;
+
+	default:
+		break;
+	}
+}
+
+void mhal_DPTx_PG_HorizontalColorBar(struct mtk_dp *mtk_dp, BYTE Location)
+{
+	msWriteByteMask(mtk_dp, REG_3038_DP_ENCODER0_P0 + 1, BIT3, BIT3);
+	msWriteByteMask(mtk_dp, REG_31B0_DP_ENCODER0_P0, BIT6, MASKBIT(6:4));
+	switch (Location) {
+	case DPTX_PG_LOCATION_ALL:
+		msWriteByteMask(mtk_dp, REG_3190_DP_ENCODER0_P0,
+			0, MASKBIT(5:4));
+		msWriteByteMask(mtk_dp, REG_3190_DP_ENCODER0_P0,
+			0, MASKBIT(2:0));
+		break;
+
+	case DPTX_PG_LOCATION_TOP:
+		msWriteByteMask(mtk_dp, REG_3190_DP_ENCODER0_P0,
+			BIT4, MASKBIT(5:4));
+		msWriteByteMask(mtk_dp, REG_3190_DP_ENCODER0_P0,
+			0, MASKBIT(2:0));
+		break;
+
+	case DPTX_PG_LOCATION_BOTTOM:
+		msWriteByteMask(mtk_dp, REG_3190_DP_ENCODER0_P0,
+			BIT4, MASKBIT(5:4));
+		msWriteByteMask(mtk_dp, REG_3190_DP_ENCODER0_P0,
+			BIT2, MASKBIT(2:0));
+		break;
+
+	default:
+		break;
+	}
+}
+
+void mhal_DPTx_PG_Chessboard(struct mtk_dp *mtk_dp, BYTE Location,
+	WORD Hde, WORD Vde)
+{
+	msWriteByteMask(mtk_dp, REG_3038_DP_ENCODER0_P0 + 1, BIT3, BIT3);
+	msWriteByteMask(mtk_dp, REG_31B0_DP_ENCODER0_P0, BIT6|BIT4,
+		MASKBIT(6:4));
+
+	switch (Location) {
+	case DPTX_PG_LOCATION_ALL:
+		msWrite2ByteMask(mtk_dp, REG_317C_DP_ENCODER0_P0,
+			0xFFF, MASKBIT(11:0));
+		msWrite2ByteMask(mtk_dp, REG_3180_DP_ENCODER0_P0,
+			0xFFF, MASKBIT(11:0));
+		msWrite2ByteMask(mtk_dp, REG_3184_DP_ENCODER0_P0,
+			0xFFF, MASKBIT(11:0));
+		msWrite2ByteMask(mtk_dp, REG_3194_DP_ENCODER0_P0,
+			0, MASKBIT(11:0));
+		msWrite2ByteMask(mtk_dp, REG_3198_DP_ENCODER0_P0,
+			0, MASKBIT(11:0));
+		msWrite2ByteMask(mtk_dp, REG_319C_DP_ENCODER0_P0,
+			0, MASKBIT(11:0));
+		msWrite2ByteMask(mtk_dp, REG_31A8_DP_ENCODER0_P0,
+			(Hde/8), MASKBIT(13:0));
+		msWrite2ByteMask(mtk_dp, REG_31AC_DP_ENCODER0_P0,
+			(Vde/8), MASKBIT(13:0));
+		break;
+
+	default:
+		break;
+	}
+}
+
+void mhal_DPTx_PG_SubPixel(struct mtk_dp *mtk_dp, BYTE Location)
+{
+	msWriteByteMask(mtk_dp, REG_3038_DP_ENCODER0_P0 + 1, BIT3, BIT3);
+	msWriteByteMask(mtk_dp, REG_31B0_DP_ENCODER0_P0,
+		BIT6|BIT5, MASKBIT(6:4));
+
+	switch (Location) {
+	case DPTX_PG_PIXEL_ODD_MASK:
+		msWriteByteMask(mtk_dp, REG_31B0_DP_ENCODER0_P0 + 1, 0, BIT5);
+		break;
+
+	case DPTX_PG_PIXEL_EVEN_MASK:
+		msWriteByteMask(mtk_dp, REG_31B0_DP_ENCODER0_P0 + 1,
+			BIT5, BIT5);
+		break;
+
+	default:
+		break;
+	}
+}
+
+void mhal_DPTx_PG_Frame(struct mtk_dp *mtk_dp, BYTE Location,
+	WORD Hde, WORD Vde)
+{
+	msWriteByteMask(mtk_dp, REG_3038_DP_ENCODER0_P0 + 1, BIT3, BIT3);
+	msWriteByteMask(mtk_dp, REG_31B0_DP_ENCODER0_P0, BIT6|BIT5|BIT4,
+		MASKBIT(6:4));
+
+	switch (Location) {
+	case DPTX_PG_PIXEL_ODD_MASK:
+		msWriteByteMask(mtk_dp, REG_31B0_DP_ENCODER0_P0 + 1,
+			0, BIT5);
+		msWrite2ByteMask(mtk_dp, REG_317C_DP_ENCODER0_P0,
+			0xFFF, MASKBIT(11:0));
+		msWrite2ByteMask(mtk_dp, REG_3180_DP_ENCODER0_P0,
+			0xFFF, MASKBIT(11:0));
+		msWrite2ByteMask(mtk_dp, REG_3184_DP_ENCODER0_P0,
+			0xFFF, MASKBIT(11:0));
+		msWrite2ByteMask(mtk_dp, REG_3194_DP_ENCODER0_P0,
+			0xFFF, MASKBIT(11:0));
+		msWrite2ByteMask(mtk_dp, REG_3198_DP_ENCODER0_P0,
+			0xFFF, MASKBIT(11:0));
+		msWrite2ByteMask(mtk_dp, REG_319C_DP_ENCODER0_P0,
+			0, MASKBIT(11:0));
+		msWrite2ByteMask(mtk_dp, REG_31A8_DP_ENCODER0_P0,
+			((Hde/8)-12), MASKBIT(13:0));
+		msWrite2ByteMask(mtk_dp, REG_31AC_DP_ENCODER0_P0,
+			((Vde/8)-12), MASKBIT(13:0));
+		msWriteByteMask(mtk_dp, REG_31B4_DP_ENCODER0_P0,
+			0x0B, MASKBIT(3:0));
+		break;
+
+	default:
+		break;
+	}
+}
+
+void mhal_DPTx_Audio_PG_EN(struct mtk_dp *mtk_dp, BYTE Channel,
+	BYTE Fs, BYTE bEnable)
+{
+	if (bEnable) {
+		msWrite2ByteMask(mtk_dp, REG_3088_DP_ENCODER0_P0,
+			AU_GEN_EN_DP_ENCODER0_P0_FLDMASK,
+			AU_GEN_EN_DP_ENCODER0_P0_FLDMASK);
+		//[9 : 8] set 0x3 : PG	mtk_dp
+		msWrite2ByteMask(mtk_dp, REG_3324_DP_ENCODER1_P0,
+			AUDIO_SOURCE_MUX_DP_ENCODER1_P0_FLDMASK,
+			AUDIO_SOURCE_MUX_DP_ENCODER1_P0_FLDMASK);
+
+	} else {
+		msWrite2ByteMask(mtk_dp, REG_3088_DP_ENCODER0_P0,
+			0, AU_GEN_EN_DP_ENCODER0_P0_FLDMASK);
+		msWrite2ByteMask(mtk_dp, REG_3324_DP_ENCODER1_P0,
+			0, AUDIO_SOURCE_MUX_DP_ENCODER1_P0_FLDMASK);
+	}
+
+	//audio channel count change reset
+	msWriteByteMask(mtk_dp, REG_33F4_DP_ENCODER1_P0 + 1, BIT1, BIT1);
+
+	msWrite2ByteMask(mtk_dp, REG_3304_DP_ENCODER1_P0,
+		AU_PRTY_REGEN_DP_ENCODER1_P0_FLDMASK,
+		AU_PRTY_REGEN_DP_ENCODER1_P0_FLDMASK);
+	msWrite2ByteMask(mtk_dp, REG_3304_DP_ENCODER1_P0,
+		AU_CH_STS_REGEN_DP_ENCODER1_P0_FLDMASK,
+		AU_CH_STS_REGEN_DP_ENCODER1_P0_FLDMASK);
+	msWrite2ByteMask(mtk_dp, REG_3304_DP_ENCODER1_P0,
+		AUDIO_SAMPLE_PRSENT_REGEN_DP_ENCODER1_P0_FLDMASK,
+		AUDIO_SAMPLE_PRSENT_REGEN_DP_ENCODER1_P0_FLDMASK);
+
+	msWrite2ByteMask(mtk_dp, REG_3088_DP_ENCODER0_P0,
+		AUDIO_2CH_SEL_DP_ENCODER0_P0_FLDMASK,
+		AUDIO_2CH_SEL_DP_ENCODER0_P0_FLDMASK); //[15]
+	msWrite2ByteMask(mtk_dp, REG_3088_DP_ENCODER0_P0,
+		AUDIO_MN_GEN_EN_DP_ENCODER0_P0_FLDMASK,
+		AUDIO_MN_GEN_EN_DP_ENCODER0_P0_FLDMASK); // [12]
+	msWrite2ByteMask(mtk_dp, REG_3088_DP_ENCODER0_P0,
+		AUDIO_8CH_SEL_DP_ENCODER0_P0_FLDMASK,
+		AUDIO_8CH_SEL_DP_ENCODER0_P0_FLDMASK); //[8]
+	msWrite2ByteMask(mtk_dp, REG_3088_DP_ENCODER0_P0,
+		AU_EN_DP_ENCODER0_P0_FLDMASK,
+		AU_EN_DP_ENCODER0_P0_FLDMASK); //[6]
+
+	switch (Fs) {
+	case FS_44K:
+		msWrite2ByteMask(mtk_dp, REG_3324_DP_ENCODER1_P0,
+			0x0 << AUDIO_PATGEN_FS_SEL_DP_ENCODER1_P0_FLDMASK_POS,
+			AUDIO_PATTERN_GEN_FS_SEL_DP_ENCODER1_P0_FLDMASK);
+		break;
+	case FS_48K:
+		msWrite2ByteMask(mtk_dp, REG_3324_DP_ENCODER1_P0,
+			0x1 << AUDIO_PATGEN_FS_SEL_DP_ENCODER1_P0_FLDMASK_POS,
+			AUDIO_PATTERN_GEN_FS_SEL_DP_ENCODER1_P0_FLDMASK);
+		break;
+	case FS_192K:
+		msWrite2ByteMask(mtk_dp, REG_3324_DP_ENCODER1_P0,
+			0x2 << AUDIO_PATGEN_FS_SEL_DP_ENCODER1_P0_FLDMASK_POS,
+			AUDIO_PATTERN_GEN_FS_SEL_DP_ENCODER1_P0_FLDMASK);
+		break;
+	default:
+		msWrite2ByteMask(mtk_dp, REG_3324_DP_ENCODER1_P0,
+			0x0 << AUDIO_PATGEN_FS_SEL_DP_ENCODER1_P0_FLDMASK_POS,
+			AUDIO_PATTERN_GEN_FS_SEL_DP_ENCODER1_P0_FLDMASK);
+	break;
+	}
+
+	msWrite2ByteMask(mtk_dp, REG_3088_DP_ENCODER0_P0,
+		0, AUDIO_2CH_EN_DP_ENCODER0_P0_FLDMASK);
+	msWrite2ByteMask(mtk_dp, REG_3088_DP_ENCODER0_P0,
+		0, AUDIO_8CH_EN_DP_ENCODER0_P0_FLDMASK);
+
+	switch (Channel) {
+	case 2:
+		msWrite2ByteMask(mtk_dp, REG_3324_DP_ENCODER1_P0,
+			0x0 << AUDIO_PATGEN_CH_NUM_DP_ENCODER1_P0_FLDMASK_POS,
+			AUDIO_PATTERN_GEN_CH_NUM_DP_ENCODER1_P0_FLDMASK);
+		msWrite2ByteMask(mtk_dp, REG_3088_DP_ENCODER0_P0,
+			AUDIO_2CH_EN_DP_ENCODER0_P0_FLDMASK,
+			AUDIO_2CH_EN_DP_ENCODER0_P0_FLDMASK);
+		break;
+	case 8:
+		msWrite2ByteMask(mtk_dp, REG_3324_DP_ENCODER1_P0,
+			0x1 << AUDIO_PATGEN_CH_NUM_DP_ENCODER1_P0_FLDMASK_POS,
+			AUDIO_PATTERN_GEN_CH_NUM_DP_ENCODER1_P0_FLDMASK);
+		msWrite2ByteMask(mtk_dp, REG_3088_DP_ENCODER0_P0,
+			AUDIO_8CH_EN_DP_ENCODER0_P0_FLDMASK,
+			AUDIO_8CH_EN_DP_ENCODER0_P0_FLDMASK);
+		break;
+	case 16:
+		msWrite2ByteMask(mtk_dp, REG_3324_DP_ENCODER1_P0,
+			0x2 << AUDIO_PATGEN_CH_NUM_DP_ENCODER1_P0_FLDMASK_POS,
+			AUDIO_PATTERN_GEN_CH_NUM_DP_ENCODER1_P0_FLDMASK);
+		break;
+	case 32:
+		msWrite2ByteMask(mtk_dp, REG_3324_DP_ENCODER1_P0,
+			0x3 << AUDIO_PATGEN_CH_NUM_DP_ENCODER1_P0_FLDMASK_POS,
+			AUDIO_PATTERN_GEN_CH_NUM_DP_ENCODER1_P0_FLDMASK);
+		break;
+	default:
+		msWrite2ByteMask(mtk_dp, REG_3324_DP_ENCODER1_P0,
+			0x0 << AUDIO_PATGEN_CH_NUM_DP_ENCODER1_P0_FLDMASK_POS,
+			AUDIO_PATTERN_GEN_CH_NUM_DP_ENCODER1_P0_FLDMASK);
+	break;
+	}
+
+	//audio channel count change reset
+	msWriteByteMask(mtk_dp, REG_33F4_DP_ENCODER1_P0 + 1, 0, BIT1);
+
+	//enable audio reset
+	msWriteByteMask(mtk_dp, REG_33F4_DP_ENCODER1_P0, BIT(0), BIT(0));
+}
+
+void mhal_DPTx_Audio_Ch_Status_Set(struct mtk_dp *mtk_dp, BYTE Channel,
+	BYTE Fs, BYTE Wordlength)
+{
+	union DPRX_AUDIO_CHSTS AudChSts;
+
+	memset(&AudChSts, 0, sizeof(AudChSts));
+
+	switch (Fs) {
+	case FS_32K:
+		AudChSts.iec_ch_sts.SamplingFreq = 3;
+		break;
+	case FS_44K:
+		AudChSts.iec_ch_sts.SamplingFreq = 0;
+		break;
+	case FS_48K:
+		AudChSts.iec_ch_sts.SamplingFreq = 2;
+		break;
+	case FS_88K:
+		AudChSts.iec_ch_sts.SamplingFreq = 8;
+		break;
+	case FS_96K:
+		AudChSts.iec_ch_sts.SamplingFreq = 0xA;
+		break;
+	case FS_192K:
+		AudChSts.iec_ch_sts.SamplingFreq = 0xE;
+		break;
+	default:
+		AudChSts.iec_ch_sts.SamplingFreq = 0x1;
+		break;
+	}
+
+	switch (Wordlength) {
+	case WL_16bit:
+		AudChSts.iec_ch_sts.WordLen = 0x02;
+		break;
+	case WL_20bit:
+		AudChSts.iec_ch_sts.WordLen = 0x03;
+		break;
+	case WL_24bit:
+		AudChSts.iec_ch_sts.WordLen = 0x0B;
+		break;
+	}
+
+	msWrite2Byte(mtk_dp, REG_308C_DP_ENCODER0_P0,
+		AudChSts.AUD_CH_STS[1] << 8 | AudChSts.AUD_CH_STS[0]);
+	msWrite2Byte(mtk_dp, REG_3090_DP_ENCODER0_P0,
+		AudChSts.AUD_CH_STS[3] << 8 | AudChSts.AUD_CH_STS[2]);
+	msWriteByte(mtk_dp, REG_3094_DP_ENCODER0_P0,
+		AudChSts.AUD_CH_STS[4]);
+}
+
+void mhal_DPTx_Audio_SDP_Setting(struct mtk_dp *mtk_dp, BYTE Channel)
+{
+	msWriteByteMask(mtk_dp, REG_312C_DP_ENCODER0_P0,
+		0x00, 0xFF);	//[7 : 0] //HB2
+
+	if (Channel == 8)
+		msWrite2ByteMask(mtk_dp, REG_312C_DP_ENCODER0_P0,
+			0x0700, 0xFF00);//[15 : 8]channel-1
+	else
+		msWrite2ByteMask(mtk_dp, REG_312C_DP_ENCODER0_P0,
+			0x0100, 0xFF00);
+}
+
+void mhal_DPTx_Audio_M_Divider_Setting(struct mtk_dp *mtk_dp, BYTE Div)
+{
+	msWrite2ByteMask(mtk_dp, REG_30BC_DP_ENCODER0_P0,
+		Div << AUDIO_M_CODE_MULT_DIV_SEL_DP_ENCODER0_P0_FLDMASK_POS,
+		AUDIO_M_CODE_MULT_DIV_SEL_DP_ENCODER0_P0_FLDMASK);
+}
+
+bool mhal_DPTx_GetHPDPinLevel(struct mtk_dp *mtk_dp)
+{
+	bool ret = (msReadByte(mtk_dp, REG_3414_DP_TRANS_P0) & BIT2) ? 1 : 0;
+
+	return ret;
+}
+
+void mhal_DPTx_SPKG_SDP(struct mtk_dp *mtk_dp, bool bEnable, BYTE ucSDPType,
+	BYTE *pHB, BYTE *pDB)
+{
+	BYTE ucDBOffset;
+	WORD ucSTOffset;
+	BYTE ucpHBOffset;
+	BYTE bRegIndex;
+
+	if (bEnable) {
+		for (ucDBOffset = 0; ucDBOffset < 0x10; ucDBOffset++)
+			for (bRegIndex = 0; bRegIndex < 2; bRegIndex++) {
+				u32 addr = REG_3200_DP_ENCODER1_P0
+					+ ucDBOffset * 4 + bRegIndex;
+
+				msWriteByte(mtk_dp, addr,
+					pDB[ucDBOffset * 2 + bRegIndex]);
+			}
+
+		if (ucSDPType == DPTx_SDPTYP_DRM)
+			for (ucpHBOffset = 0; ucpHBOffset < 4/2; ucpHBOffset++)
+				for (bRegIndex = 0;
+					bRegIndex < 2; bRegIndex++) {
+					u32 addr = REG_3138_DP_ENCODER0_P0
+						+ ucpHBOffset * 4 + bRegIndex;
+					BYTE pOffset = ucpHBOffset * 2
+						+ bRegIndex;
+
+					msWriteByte(mtk_dp, addr, pHB[pOffset]);
+				}
+		else if (ucSDPType >= DPTx_SDPTYP_PPS0
+			&& ucSDPType <= DPTx_SDPTYP_PPS3) {
+			for (ucpHBOffset = 0; ucpHBOffset < (4/2);
+				ucpHBOffset++)
+				for (bRegIndex = 0; bRegIndex < 2;
+						bRegIndex++) {
+					u32 addr = REG_3130_DP_ENCODER0_P0
+						+ ucpHBOffset * 4 + bRegIndex;
+					BYTE pOffset = ucpHBOffset * 2
+						+ bRegIndex;
+
+					msWriteByte(mtk_dp, addr, pHB[pOffset]);
+				}
+		} else {
+			ucSTOffset = (ucSDPType - DPTx_SDPTYP_ACM) * 8;
+			for (ucpHBOffset = 0; ucpHBOffset < 4/2; ucpHBOffset++)
+				for (bRegIndex = 0; bRegIndex < 2;
+					bRegIndex++) {
+					u32 addr = REG_30D8_DP_ENCODER0_P0
+						+ ucSTOffset
+						+ ucpHBOffset * 4 + bRegIndex;
+					BYTE pOffset = ucpHBOffset * 2
+						+ bRegIndex;
+
+					msWriteByte(mtk_dp, addr, pHB[pOffset]);
+				}
+		}
+	}
+
+	switch (ucSDPType) {
+	case DPTx_SDPTYP_NONE:
+		break;
+	case DPTx_SDPTYP_ACM:
+		msWriteByte(mtk_dp, REG_30B4_DP_ENCODER0_P0, 0x00);
+
+		if (bEnable) {
+			msWriteByteMask(mtk_dp, REG_3280_DP_ENCODER1_P0,
+				DPTx_SDPTYP_ACM, BIT4|BIT3|BIT2|BIT1|BIT0);
+			msWriteByteMask(mtk_dp, REG_3280_DP_ENCODER1_P0,
+				BIT5, BIT5);
+			msWriteByte(mtk_dp, REG_30B4_DP_ENCODER0_P0, 0x05);
+		}
+		break;
+	case DPTx_SDPTYP_ISRC:
+		msWriteByte(mtk_dp, REG_30B4_DP_ENCODER0_P0 + 1, 0x00);
+		if (bEnable) {
+			msWriteByte(mtk_dp, REG_31EC_DP_ENCODER0_P0 + 1, 0x1C);
+			msWriteByteMask(mtk_dp, REG_3280_DP_ENCODER1_P0,
+				DPTx_SDPTYP_ISRC, BIT4|BIT3|BIT2|BIT1|BIT0);
+			if (pHB[3] & BIT2)
+				msWriteByteMask(mtk_dp, REG_30BC_DP_ENCODER0_P0,
+					BIT0, BIT0);
+			else
+				msWriteByteMask(mtk_dp, REG_30BC_DP_ENCODER0_P0,
+					0, BIT0);
+
+			msWriteByteMask(mtk_dp, REG_3280_DP_ENCODER1_P0,
+				BIT5, BIT5);
+			msWriteByte(mtk_dp, REG_30B4_DP_ENCODER0_P0 + 1, 0x05);
+		}
+		break;
+	case DPTx_SDPTYP_AVI:
+		msWriteByte(mtk_dp, REG_30A4_DP_ENCODER0_P0 + 1, 0x00);
+		if (bEnable) {
+			msWriteByteMask(mtk_dp, REG_3280_DP_ENCODER1_P0,
+				DPTx_SDPTYP_AVI, BIT4|BIT3|BIT2|BIT1|BIT0);
+			msWriteByteMask(mtk_dp, REG_3280_DP_ENCODER1_P0,
+				BIT5, BIT5);
+			msWriteByte(mtk_dp, REG_30A4_DP_ENCODER0_P0 + 1, 0x05);
+		}
+		break;
+	case DPTx_SDPTYP_AUI:
+		msWriteByte(mtk_dp, REG_30A8_DP_ENCODER0_P0, 0x00);
+		if (bEnable) {
+			msWriteByteMask(mtk_dp, REG_3280_DP_ENCODER1_P0,
+				DPTx_SDPTYP_AUI, BIT4|BIT3|BIT2|BIT1|BIT0);
+			msWriteByteMask(mtk_dp, REG_3280_DP_ENCODER1_P0,
+				BIT5, BIT5);
+			msWriteByte(mtk_dp, REG_30A8_DP_ENCODER0_P0, 0x05);
+		}
+		break;
+	case DPTx_SDPTYP_SPD:
+		msWriteByte(mtk_dp, REG_30A8_DP_ENCODER0_P0 + 1, 0x00);
+		if (bEnable) {
+			msWriteByteMask(mtk_dp, REG_3280_DP_ENCODER1_P0,
+				DPTx_SDPTYP_SPD, BIT4|BIT3|BIT2|BIT1|BIT0);
+			msWriteByteMask(mtk_dp, REG_3280_DP_ENCODER1_P0,
+				BIT5, BIT5);
+			msWriteByte(mtk_dp, REG_30A8_DP_ENCODER0_P0 + 1, 0x05);
+		}
+		break;
+	case DPTx_SDPTYP_MPEG:
+		msWriteByte(mtk_dp, REG_30AC_DP_ENCODER0_P0, 0x00);
+		if (bEnable) {
+			msWriteByteMask(mtk_dp, REG_3280_DP_ENCODER1_P0,
+				DPTx_SDPTYP_MPEG, BIT4|BIT3|BIT2|BIT1|BIT0);
+			msWriteByteMask(mtk_dp, REG_3280_DP_ENCODER1_P0,
+				BIT5, BIT5);
+			msWriteByte(mtk_dp, REG_30AC_DP_ENCODER0_P0, 0x05);
+		}
+		break;
+	case DPTx_SDPTYP_NTSC:
+		msWriteByte(mtk_dp, REG_30AC_DP_ENCODER0_P0 + 1, 0x00);
+		if (bEnable) {
+			msWriteByteMask(mtk_dp, REG_3280_DP_ENCODER1_P0,
+				DPTx_SDPTYP_NTSC, BIT4|BIT3|BIT2|BIT1|BIT0);
+			msWriteByteMask(mtk_dp, REG_3280_DP_ENCODER1_P0,
+				BIT5, BIT5);
+			msWriteByte(mtk_dp, REG_30AC_DP_ENCODER0_P0 + 1, 0x05);
+		}
+		break;
+	case DPTx_SDPTYP_VSP:
+		msWriteByte(mtk_dp, REG_30B0_DP_ENCODER0_P0, 0x00);
+		if (bEnable) {
+			msWriteByteMask(mtk_dp, REG_3280_DP_ENCODER1_P0,
+				DPTx_SDPTYP_VSP, BIT4|BIT3|BIT2|BIT1|BIT0);
+			msWriteByteMask(mtk_dp, REG_3280_DP_ENCODER1_P0,
+				BIT5, BIT5);
+			msWriteByte(mtk_dp, REG_30B0_DP_ENCODER0_P0, 0x05);
+		}
+		break;
+	case DPTx_SDPTYP_VSC:
+		msWriteByte(mtk_dp, REG_30B8_DP_ENCODER0_P0, 0x00);
+		if (bEnable) {
+			msWriteByteMask(mtk_dp, REG_3280_DP_ENCODER1_P0,
+				DPTx_SDPTYP_VSC, BIT4|BIT3|BIT2|BIT1|BIT0);
+			msWriteByteMask(mtk_dp, REG_3280_DP_ENCODER1_P0,
+				BIT5, BIT5);
+			msWriteByte(mtk_dp, REG_30B8_DP_ENCODER0_P0, 0x05);
+		}
+		break;
+	case DPTx_SDPTYP_EXT:
+		msWriteByte(mtk_dp, REG_30B0_DP_ENCODER0_P0 + 1, 0x00);
+		if (bEnable) {
+			msWriteByteMask(mtk_dp, REG_3280_DP_ENCODER1_P0,
+				DPTx_SDPTYP_EXT, BIT4|BIT3|BIT2|BIT1|BIT0);
+			msWriteByteMask(mtk_dp, REG_3280_DP_ENCODER1_P0,
+				BIT5, BIT5);
+			msWriteByte(mtk_dp, REG_30B0_DP_ENCODER0_P0 + 1, 0x05);
+		}
+		break;
+
+	case DPTx_SDPTYP_PPS0:
+		msWriteByte(mtk_dp, REG_31E8_DP_ENCODER0_P0, 0x00);
+		if (bEnable) {
+			msWriteByteMask(mtk_dp, REG_3280_DP_ENCODER1_P0,
+				DPTx_SDPTYP_PPS0, BIT4|BIT3|BIT2|BIT1|BIT0);
+			msWriteByteMask(mtk_dp, REG_3280_DP_ENCODER1_P0,
+				BIT5, BIT5);
+			msWriteByte(mtk_dp, REG_31E8_DP_ENCODER0_P0, 0x05);
+		}
+	break;
+
+	case DPTx_SDPTYP_PPS1:
+		msWriteByte(mtk_dp, REG_31E8_DP_ENCODER0_P0, 0x00);
+		if (bEnable) {
+			msWriteByteMask(mtk_dp, REG_3280_DP_ENCODER1_P0,
+				DPTx_SDPTYP_PPS1, BIT4|BIT3|BIT2|BIT1|BIT0);
+			msWriteByteMask(mtk_dp, REG_3280_DP_ENCODER1_P0,
+				BIT5, BIT5);
+			msWriteByte(mtk_dp, REG_31E8_DP_ENCODER0_P0, 0x05);
+		}
+	break;
+
+	case DPTx_SDPTYP_PPS2:
+		msWriteByte(mtk_dp, REG_31E8_DP_ENCODER0_P0, 0x00);
+		if (bEnable) {
+			msWriteByteMask(mtk_dp, REG_3280_DP_ENCODER1_P0,
+				DPTx_SDPTYP_PPS2, BIT4|BIT3|BIT2|BIT1|BIT0);
+			msWriteByteMask(mtk_dp, REG_3280_DP_ENCODER1_P0,
+				BIT5, BIT5);
+			msWriteByte(mtk_dp, REG_31E8_DP_ENCODER0_P0, 0x05);
+		}
+	break;
+
+	case DPTx_SDPTYP_PPS3:
+		msWriteByte(mtk_dp, REG_31E8_DP_ENCODER0_P0, 0x00);
+		if (bEnable) {
+			msWriteByteMask(mtk_dp, REG_3280_DP_ENCODER1_P0,
+				DPTx_SDPTYP_PPS3, BIT4|BIT3|BIT2|BIT1|BIT0);
+			msWriteByteMask(mtk_dp, REG_3280_DP_ENCODER1_P0,
+				BIT5, BIT5);
+			msWriteByte(mtk_dp, REG_31E8_DP_ENCODER0_P0, 0x05);
+		}
+	break;
+
+	case DPTx_SDPTYP_DRM:
+		msWriteByte(mtk_dp, REG_31DC_DP_ENCODER0_P0, 0x00);
+		if (bEnable) {
+			msWriteByte(mtk_dp, REG_3138_DP_ENCODER0_P0, pHB[0]);
+			msWriteByte(mtk_dp, REG_3138_DP_ENCODER0_P0 + 1,
+				pHB[1]);
+			msWriteByte(mtk_dp, REG_313C_DP_ENCODER0_P0, pHB[2]);
+			msWriteByte(mtk_dp, REG_313C_DP_ENCODER0_P0 + 1,
+				pHB[3]);
+			msWriteByteMask(mtk_dp, REG_3280_DP_ENCODER1_P0,
+				DPTx_SDPTYP_DRM, BIT4|BIT3|BIT2|BIT1|BIT0);
+			msWriteByteMask(mtk_dp, REG_3280_DP_ENCODER1_P0,
+				BIT5, BIT5);
+			msWriteByte(mtk_dp, REG_31DC_DP_ENCODER0_P0, 0x05);
+		}
+	break;
+	default:
+		break;
+	}
+}
+
+void mhal_DPTx_SPKG_VSC_EXT_VESA(struct mtk_dp *mtk_dp, bool bEnable,
+	BYTE ucHDR_NUM, BYTE *pDB)
+{
+
+	BYTE VSC_HB1 = 0x20;	// VESA : 0x20; CEA : 0x21
+	BYTE VSC_HB2;
+	BYTE ucPkgCnt;
+	WORD ucDBOffset;
+	BYTE ucDPloop;
+	BYTE ucpDBOffset;
+	BYTE bRegIndex;
+
+	if (!bEnable) {
+		msWriteByteMask(mtk_dp, REG_30A0_DP_ENCODER0_P0 + 1, 0, BIT0);
+		msWriteByteMask(mtk_dp, REG_328C_DP_ENCODER1_P0, 0, BIT7);
+		return;
+	}
+
+	VSC_HB2 = (ucHDR_NUM > 0) ? BIT6 : 0x00;
+
+	msWriteByte(mtk_dp, REG_31C8_DP_ENCODER0_P0, 0x00);
+	msWriteByte(mtk_dp, REG_31C8_DP_ENCODER0_P0 + 1, VSC_HB1);
+	msWriteByte(mtk_dp, REG_31CC_DP_ENCODER0_P0, VSC_HB2);
+	msWriteByte(mtk_dp, REG_31CC_DP_ENCODER0_P0 + 1, 0x00);
+	msWriteByte(mtk_dp, REG_31D8_DP_ENCODER0_P0, ucHDR_NUM);
+
+	msWriteByteMask(mtk_dp, REG_328C_DP_ENCODER1_P0, BIT0, BIT0);
+	msWriteByteMask(mtk_dp, REG_328C_DP_ENCODER1_P0, BIT2, BIT2);
+	udelay(50);
+	msWriteByteMask(mtk_dp, REG_328C_DP_ENCODER1_P0, 0, BIT2);
+	udelay(50);
+
+	for (ucPkgCnt = 0; ucPkgCnt < (ucHDR_NUM+1); ucPkgCnt++) {
+		ucDBOffset = 0;
+		for (ucDPloop = 0; ucDPloop < 4; ucDPloop++) {
+			for (ucpDBOffset = 0; ucpDBOffset < 8/2; ucpDBOffset++)
+				for (bRegIndex = 0; bRegIndex < 2;
+						bRegIndex++) {
+					u32 addr = REG_3290_DP_ENCODER1_P0
+						+ ucpDBOffset * 4 + bRegIndex;
+					BYTE pOffset = ucDBOffset
+						+ ucpDBOffset * 2 + bRegIndex;
+
+					msWriteByte(mtk_dp,
+					addr,
+					pDB[pOffset]);
+				}
+			msWriteByteMask(mtk_dp, REG_328C_DP_ENCODER1_P0,
+				BIT6, BIT6);
+			ucDBOffset += 8;
+		}
+	}
+
+	msWriteByteMask(mtk_dp, REG_30A0_DP_ENCODER0_P0 + 1, BIT0, BIT0);
+	msWriteByteMask(mtk_dp, REG_328C_DP_ENCODER1_P0, BIT7, BIT7);
+}
+
+void mhal_DPTx_SPKG_VSC_EXT_CEA(struct mtk_dp *mtk_dp, bool bEnable,
+	BYTE ucHDR_NUM, BYTE *pDB)
+{
+
+	BYTE VSC_HB1 = 0x21;
+	BYTE VSC_HB2;
+	BYTE ucPkgCnt;
+	WORD ucDBOffset;
+	BYTE ucDPloop;
+	BYTE ucpDBOffset;
+	BYTE bRegIndex;
+
+	if (!bEnable) {
+		msWriteByteMask(mtk_dp, REG_30A0_DP_ENCODER0_P0 + 1, 0, BIT4);
+		msWriteByteMask(mtk_dp, REG_32A0_DP_ENCODER1_P0, 0, BIT7);
+		return;
+	}
+
+	VSC_HB2 = (ucHDR_NUM > 0) ? 0x40 : 0x00;
+
+	msWriteByte(mtk_dp, REG_31D0_DP_ENCODER0_P0, 0x00);
+	msWriteByte(mtk_dp, REG_31D0_DP_ENCODER0_P0 + 1, VSC_HB1);
+	msWriteByte(mtk_dp, REG_31D4_DP_ENCODER0_P0, VSC_HB2);
+	msWriteByte(mtk_dp, REG_31D4_DP_ENCODER0_P0 + 1, 0x00);
+	msWriteByte(mtk_dp, REG_31D8_DP_ENCODER0_P0 + 1, ucHDR_NUM);
+
+	msWriteByteMask(mtk_dp, REG_32A0_DP_ENCODER1_P0, BIT0, BIT0);
+	msWriteByteMask(mtk_dp, REG_32A0_DP_ENCODER1_P0, BIT2, BIT2);
+	udelay(50);
+
+	msWriteByteMask(mtk_dp, REG_32A0_DP_ENCODER1_P0, 0, BIT2);
+
+	for (ucPkgCnt = 0; ucPkgCnt < (ucHDR_NUM+1); ucPkgCnt++) {
+		ucDBOffset = 0;
+		for (ucDPloop = 0; ucDPloop < 4; ucDPloop++) {
+			for (ucpDBOffset = 0; ucpDBOffset < 8/2; ucpDBOffset++)
+				for (bRegIndex = 0; bRegIndex < 2;
+						bRegIndex++) {
+					u32 addr = REG_32A4_DP_ENCODER1_P0
+						+ ucpDBOffset * 4 + bRegIndex;
+					BYTE pOffset = ucDBOffset
+						+ ucpDBOffset * 2 + bRegIndex;
+
+					msWriteByte(mtk_dp,
+						addr,
+						pDB[pOffset]);
+				}
+			msWriteByteMask(mtk_dp, REG_32A0_DP_ENCODER1_P0,
+				BIT6, BIT6);
+			ucDBOffset += 8;
+		}
+	}
+
+
+	msWriteByteMask(mtk_dp, REG_30A0_DP_ENCODER0_P0 + 1, BIT4, BIT4);
+	msWriteByteMask(mtk_dp, REG_32A0_DP_ENCODER1_P0, BIT7, BIT7);
+}
+
+bool mhal_DPTx_AuxRead_Bytes(struct mtk_dp *mtk_dp, BYTE ubCmd,
+	DWORD  usDPCDADDR, size_t ubLength, BYTE *pRxBuf)
+{
+	bool bVaildCmd = false;
+	BYTE ubReplyCmd = 0xFF;
+	BYTE ubRdCount = 0x0;
+	BYTE uAuxIrqStatus = 0;
+	unsigned int WaitReplyCount = AuxWaitReplyLpCntNum;
+
+	msWriteByte(mtk_dp, REG_3640_AUX_TX_P0, 0x7F);
+	udelay(AUX_WRITE_READ_WAIT_TIME);
+
+	if ((ubLength > 16) ||
+		((ubCmd == AUX_CMD_NATIVE_R) && (ubLength == 0x0)))
+		return bVaildCmd;
+
+	msWriteByte(mtk_dp, REG_3650_AUX_TX_P0 + 1, 0x01);
+	msWriteByte(mtk_dp, REG_3644_AUX_TX_P0, ubCmd);
+	msWrite2Byte(mtk_dp, REG_3648_AUX_TX_P0, usDPCDADDR&0x0000FFFF);
+	msWriteByte(mtk_dp, REG_364C_AUX_TX_P0, (usDPCDADDR>>16)&0x0000000F);
+
+	if (ubLength > 0) {
+		msWrite2ByteMask(mtk_dp, REG_3650_AUX_TX_P0,
+			(ubLength-1) << MCU_REQ_DATA_NUM_AUX_TX_P0_FLDMASK_POS,
+			MCU_REQUEST_DATA_NUM_AUX_TX_P0_FLDMASK);
+		msWriteByte(mtk_dp, REG_362C_AUX_TX_P0, 0x00);
+	}
+
+
+	if ((ubCmd == AUX_CMD_I2C_R) || (ubCmd == AUX_CMD_I2C_R_MOT0))
+		if (ubLength == 0x0)
+			msWrite2ByteMask(mtk_dp, REG_362C_AUX_TX_P0,
+				0x01 << AUX_NO_LENGTH_AUX_TX_P0_FLDMASK_POS,
+				AUX_NO_LENGTH_AUX_TX_P0_FLDMASK);
+
+	msWrite2ByteMask(mtk_dp, REG_3630_AUX_TX_P0,
+		0x01 << AUX_TX_REQUEST_READY_AUX_TX_P0_FLDMASK_POS,
+		AUX_TX_REQUEST_READY_AUX_TX_P0_FLDMASK);
+
+	while (--WaitReplyCount) {
+		if ((msReadByte(mtk_dp, REG_3618_AUX_TX_P0)
+			& AUX_RX_FIFO_WRITE_POINTER_AUX_TX_P0_FLDMASK)) {
+			bVaildCmd = true;
+			break;
+		}
+
+		if ((msRead2Byte(mtk_dp, REG_3618_AUX_TX_P0)
+			& AUX_RX_FIFO_FULL_AUX_TX_P0_FLDMASK)) {
+			bVaildCmd = true;
+			break;
+		}
+
+		uAuxIrqStatus = msReadByte(mtk_dp, REG_3640_AUX_TX_P0) & 0xFF;
+		if (uAuxIrqStatus & AUX_RX_RECV_COMPLETE_IRQ_TX_P0_FLDMASK) {
+			bVaildCmd = true;
+			break;
+		}
+
+		if (uAuxIrqStatus & AUX_400US_TIMEOUT_IRQ_AUX_TX_P0_FLDMASK)
+			break;
+	}
+
+	ubReplyCmd = msReadByte(mtk_dp, REG_3624_AUX_TX_P0) & 0x0F;
+
+	if ((WaitReplyCount == 0x0) || ubReplyCmd) {
+		BYTE phyStatus = 0x00;
+
+		phyStatus = msReadByte(mtk_dp, REG_3628_AUX_TX_P0);
+		if (phyStatus != 0x01)
+			pr_err("Aux R:Aux hang,need SW reset\n");
+
+		msWrite2ByteMask(mtk_dp, REG_3650_AUX_TX_P0,
+			0x01 << MCU_ACK_TRAN_COMPLETE_AUX_TX_P0_FLDMASK_POS,
+			MCU_ACK_TRANSACTION_COMPLETE_AUX_TX_P0_FLDMASK);
+		msWriteByte(mtk_dp, REG_3640_AUX_TX_P0, 0x7F);
+
+		udelay(AUX_WRITE_READ_WAIT_TIME);
+		return false;
+	}
+
+	if (ubLength == 0) {
+		msWriteByte(mtk_dp, REG_362C_AUX_TX_P0, 0x00);
+	} else {
+		if (bVaildCmd) {
+			msWrite2ByteMask(mtk_dp, REG_3620_AUX_TX_P0,
+				0x0 << AUX_RD_MODE_AUX_TX_P0_FLDMASK_POS,
+				AUX_RD_MODE_AUX_TX_P0_FLDMASK);
+
+			for (ubRdCount = 0x0; ubRdCount < ubLength;
+					ubRdCount++) {
+				msWrite2ByteMask(mtk_dp, REG_3620_AUX_TX_P0,
+				0x01 << AUX_RX_FIFO_R_PULSE_TX_P0_FLDMASK_POS,
+				AUX_RX_FIFO_READ_PULSE_TX_P0_FLDMASK);
+
+				if ((ubCmd == (DP_AUX_I2C_READ
+						| DP_AUX_I2C_MOT))
+					|| (ubCmd == DP_AUX_I2C_READ))
+					udelay(500);
+				else
+					udelay(100);
+
+				*(pRxBuf + ubRdCount)
+					= msReadByte(mtk_dp,
+						REG_3620_AUX_TX_P0);
+			}
+		} 
+	}
+
+	msWrite2ByteMask(mtk_dp, REG_3650_AUX_TX_P0,
+		0x01 << MCU_ACK_TRAN_COMPLETE_AUX_TX_P0_FLDMASK_POS,
+		MCU_ACK_TRANSACTION_COMPLETE_AUX_TX_P0_FLDMASK);
+	msWriteByte(mtk_dp, REG_3640_AUX_TX_P0, 0x7F);
+
+	udelay(AUX_WRITE_READ_WAIT_TIME);
+	return bVaildCmd;
+}
+
+bool mhal_DPTx_AuxWrite_Bytes(struct mtk_dp *mtk_dp,
+	BYTE ubCmd, DWORD  usDPCDADDR, size_t ubLength, BYTE *pData)
+{
+	bool bVaildCmd = false;
+	BYTE ubReplyCmd = 0x0;
+	BYTE i;
+	WORD WaitReplyCount = AuxWaitReplyLpCntNum;
+	BYTE bRegIndex;
+	unsigned long long cStart;
+
+	msWriteByteMask(mtk_dp, REG_3704_AUX_TX_P0,
+		1 << AUX_TX_FIFO_NEW_MODE_EN_AUX_TX_P0_FLDMASK_POS,
+		AUX_TX_FIFO_NEW_MODE_EN_AUX_TX_P0_FLDMASK);
+	msWriteByte(mtk_dp, REG_3650_AUX_TX_P0 + 1, 0x01);
+	msWriteByte(mtk_dp, REG_3640_AUX_TX_P0, 0x7F);
+	udelay(AUX_WRITE_READ_WAIT_TIME);
+
+	msWriteByte(mtk_dp, REG_3650_AUX_TX_P0 + 1, 0x01);
+	msWriteByte(mtk_dp, REG_3644_AUX_TX_P0, ubCmd);
+	msWriteByte(mtk_dp, REG_3648_AUX_TX_P0, usDPCDADDR & 0x00FF);
+	msWriteByte(mtk_dp, REG_3648_AUX_TX_P0 + 1, (usDPCDADDR >> 8) & 0x00FF);
+	msWriteByte(mtk_dp, REG_364C_AUX_TX_P0, (usDPCDADDR >> 16) & 0x000F);
+
+	if (ubLength > 0) {
+		msWriteByte(mtk_dp, REG_362C_AUX_TX_P0, 0x00);
+		for (i = 0x0; i < (ubLength+1)/2; i++)
+			for (bRegIndex = 0; bRegIndex < 2; bRegIndex++)
+				if ((i * 2 + bRegIndex) < ubLength)
+					msWriteByte(mtk_dp,
+					REG_3708_AUX_TX_P0 + i * 4 + bRegIndex,
+					pData[i * 2 + bRegIndex]);
+		msWriteByte(mtk_dp, REG_3650_AUX_TX_P0 + 1,
+			((ubLength - 1) & 0x0F) << 4);
+	} else
+		msWriteByte(mtk_dp, REG_362C_AUX_TX_P0, 0x01);
+
+	cStart = sched_clock();
+	msWriteByteMask(mtk_dp, REG_3704_AUX_TX_P0,
+		AUX_TX_FIFO_WRITE_DATA_NEW_MODE_TOGGLE_AUX_TX_P0_FLDMASK,
+		AUX_TX_FIFO_WRITE_DATA_NEW_MODE_TOGGLE_AUX_TX_P0_FLDMASK);
+	msWriteByte(mtk_dp, REG_3630_AUX_TX_P0, 0x08);
+
+	while (--WaitReplyCount) {
+		BYTE uAuxIrqStatus;
+
+		uAuxIrqStatus = msReadByte(mtk_dp, REG_3640_AUX_TX_P0) & 0xFF;
+		udelay(1);
+		if (uAuxIrqStatus & AUX_RX_RECV_COMPLETE_IRQ_TX_P0_FLDMASK) {
+			bVaildCmd = true;
+			break;
+		}
+
+		if (uAuxIrqStatus & AUX_400US_TIMEOUT_IRQ_AUX_TX_P0_FLDMASK)
+			break;
+	}
+
+	ubReplyCmd = msReadByte(mtk_dp, REG_3624_AUX_TX_P0) & 0x0F;
+
+	if ((WaitReplyCount == 0x0) || ubReplyCmd) {
+		BYTE phyStatus = 0x00;
+
+		phyStatus = msReadByte(mtk_dp, REG_3628_AUX_TX_P0);
+		if (phyStatus != 0x01)
+			pr_err("Aux Write: Aux hang, need SW reset!\n");
+
+		msWriteByte(mtk_dp, REG_3650_AUX_TX_P0 + 1, 0x01);
+		msWriteByte(mtk_dp, REG_3640_AUX_TX_P0, 0x7F);
+
+		udelay(AUX_WRITE_READ_WAIT_TIME);
+
+		return false;
+	}
+
+	msWriteByte(mtk_dp, REG_3650_AUX_TX_P0 + 1, 0x01);
+
+	if (ubLength == 0)
+		msWriteByte(mtk_dp, REG_362C_AUX_TX_P0, 0x00);
+
+	msWriteByte(mtk_dp, REG_3640_AUX_TX_P0, 0x7F);
+	udelay(AUX_WRITE_READ_WAIT_TIME);
+
+	return bVaildCmd;
+}
+
+bool mhal_DPTx_SetSwingtPreEmphasis(struct mtk_dp *mtk_dp, int lane_num,
+	int swingValue, int preEmphasis)
+{
+	switch (lane_num) {
+	case DPTx_LANE0:
+		msWrite4ByteMask(mtk_dp,
+			DP_TX_TOP_SWING_EMP,
+			swingValue << DP_TX0_VOLT_SWING_FLDMASK_POS,
+			DP_TX0_VOLT_SWING_FLDMASK);
+		msWrite4ByteMask(mtk_dp,
+			DP_TX_TOP_SWING_EMP,
+			preEmphasis << DP_TX0_PRE_EMPH_FLDMASK_POS,
+			DP_TX0_PRE_EMPH_FLDMASK);
+		break;
+	case DPTx_LANE1:
+		msWrite4ByteMask(mtk_dp,
+			DP_TX_TOP_SWING_EMP,
+			swingValue << DP_TX1_VOLT_SWING_FLDMASK_POS,
+			DP_TX1_VOLT_SWING_FLDMASK);
+		msWrite4ByteMask(mtk_dp,
+			DP_TX_TOP_SWING_EMP,
+			preEmphasis << DP_TX1_PRE_EMPH_FLDMASK_POS,
+			DP_TX1_PRE_EMPH_FLDMASK);
+		break;
+	case DPTx_LANE2:
+		msWrite4ByteMask(mtk_dp,
+			DP_TX_TOP_SWING_EMP,
+			swingValue << DP_TX2_VOLT_SWING_FLDMASK_POS,
+			DP_TX2_VOLT_SWING_FLDMASK);
+		msWrite4ByteMask(mtk_dp,
+			DP_TX_TOP_SWING_EMP,
+			preEmphasis << DP_TX2_PRE_EMPH_FLDMASK_POS,
+			DP_TX2_PRE_EMPH_FLDMASK);
+		break;
+	case DPTx_LANE3:
+		msWrite4ByteMask(mtk_dp,
+			DP_TX_TOP_SWING_EMP,
+			swingValue << DP_TX3_VOLT_SWING_FLDMASK_POS,
+			DP_TX3_VOLT_SWING_FLDMASK);
+		msWrite4ByteMask(mtk_dp,
+			DP_TX_TOP_SWING_EMP,
+			preEmphasis << DP_TX3_PRE_EMPH_FLDMASK_POS,
+			DP_TX3_PRE_EMPH_FLDMASK);
+		break;
+	default:
+		pr_err("lane number is error\n");
+		return false;
+	}
+
+	return true;
+}
+
+bool mhal_DPTx_ResetSwingtPreEmphasis(struct mtk_dp *mtk_dp)
+{
+	msWrite4ByteMask(mtk_dp,
+		DP_TX_TOP_SWING_EMP, 0, DP_TX0_VOLT_SWING_FLDMASK);
+	msWrite4ByteMask(mtk_dp,
+		DP_TX_TOP_SWING_EMP, 0, DP_TX1_VOLT_SWING_FLDMASK);
+	msWrite4ByteMask(mtk_dp,
+		DP_TX_TOP_SWING_EMP, 0, DP_TX2_VOLT_SWING_FLDMASK);
+	msWrite4ByteMask(mtk_dp,
+		DP_TX_TOP_SWING_EMP, 0, DP_TX3_VOLT_SWING_FLDMASK);
+	msWrite4ByteMask(mtk_dp,
+		DP_TX_TOP_SWING_EMP, 0, DP_TX0_PRE_EMPH_FLDMASK);
+	msWrite4ByteMask(mtk_dp,
+		DP_TX_TOP_SWING_EMP, 0, DP_TX1_PRE_EMPH_FLDMASK);
+	msWrite4ByteMask(mtk_dp,
+		DP_TX_TOP_SWING_EMP, 0, DP_TX2_PRE_EMPH_FLDMASK);
+	msWrite4ByteMask(mtk_dp,
+		DP_TX_TOP_SWING_EMP, 0, DP_TX3_PRE_EMPH_FLDMASK);
+	return true;
+}
+
+void mhal_DPTx_ISR(struct mtk_dp *mtk_dp)
+{
+	static DWORD AuxIrqCnt;
+	static DWORD TransIrqCnt;
+	static DWORD EncIrqCnt;
+
+	uint32_t int_status;
+
+	int_status = msRead4Byte(mtk_dp, DP_TX_TOP_IRQ_STATUS);
+
+	if (int_status & BIT2)
+		AuxIrqCnt++;
+
+	if (int_status & BIT1) {
+		mdrv_DPTx_HPD_ISREvent(mtk_dp);
+		TransIrqCnt++;
+	}
+
+	if (int_status & BIT0)
+		EncIrqCnt++;
+}
+
+void mhal_DPTx_EnableFEC(struct mtk_dp *mtk_dp, bool bENABLE)
+{
+	if (bENABLE)
+		msWriteByteMask(mtk_dp,
+			REG_3540_DP_TRANS_P0, BIT0, BIT0); // [0] : FEC Enable
+	else
+		msWriteByteMask(mtk_dp,
+			REG_3540_DP_TRANS_P0, 0, BIT0); // FEC Disable
+}
+
+void mhal_DPTx_EnableDSC(struct mtk_dp *mtk_dp, bool bENABLE)
+{
+	if (bENABLE) {
+		msWriteByteMask(mtk_dp,
+			REG_336C_DP_ENCODER1_P0,
+			BIT0,
+			BIT0); // [0] : DSC Enable
+		msWriteByteMask(mtk_dp,
+			REG_300C_DP_ENCODER0_P0 + 1,
+			BIT1,
+			BIT1); //300C [9] : VB-ID[6] DSC enable
+		msWriteByteMask(mtk_dp,
+			REG_303C_DP_ENCODER0_P0 + 1,
+			0x7,
+			MASKBIT(2 : 0)); //303C[10 : 8] : DSC color depth
+		msWriteByteMask(mtk_dp,
+			REG_303C_DP_ENCODER0_P0 + 1,
+			0x7 << 4,
+			MASKBIT(6 : 4)); //303C[14 : 12] : DSC color format
+		msWriteByteMask(mtk_dp,
+			REG_31FC_DP_ENCODER0_P0 + 1,
+			BIT4,
+			BIT4); //31FC[12] : HDE last num control
+	} else {
+		msWriteByteMask(mtk_dp,
+			REG_336C_DP_ENCODER1_P0,
+			0,
+			BIT0); // DSC Disable
+		msWriteByteMask(mtk_dp,
+			REG_300C_DP_ENCODER0_P0 + 1,
+			0,
+			BIT1);
+		msWriteByteMask(mtk_dp,
+			REG_303C_DP_ENCODER0_P0 + 1,
+			0x3,
+			MASKBIT(2 : 0)); //default 8bit
+		msWriteByteMask(mtk_dp,
+			REG_303C_DP_ENCODER0_P0 + 1,
+			0x0,
+			MASKBIT(6 : 4)); //default RGB
+		msWriteByteMask(mtk_dp,
+			REG_31FC_DP_ENCODER0_P0 + 1,
+			0x0,
+			BIT4);
+	}
+}
+
+void mhal_DPTx_SetChunkSize(struct mtk_dp *mtk_dp,
+	BYTE slice_num, WORD chunk_num, BYTE remainder,
+	BYTE lane_count, BYTE hde_last_num, BYTE hde_num_even)
+{
+	msWriteByteMask(mtk_dp,
+		REG_336C_DP_ENCODER1_P0,
+		slice_num << 4,
+		MASKBIT(7 : 4));
+	msWriteByteMask(mtk_dp,
+		REG_336C_DP_ENCODER1_P0 + 1,
+		remainder,
+		MASKBIT(3 : 0));
+	msWrite2Byte(mtk_dp,
+		REG_3370_DP_ENCODER1_P0,
+		chunk_num); //set chunk_num
+
+	if (lane_count == 1) {
+		msWriteByteMask(mtk_dp,
+			REG_31FC_DP_ENCODER0_P0,
+			hde_last_num,
+			MASKBIT(1 : 0)); //last data catch on lane 0
+		msWriteByteMask(mtk_dp,
+			REG_31FC_DP_ENCODER0_P0 + 1,
+			hde_num_even,
+			BIT0); //sram last data catch on lane 0
+	} else {
+		msWriteByteMask(mtk_dp,
+			REG_31FC_DP_ENCODER0_P0,
+			hde_last_num,
+			MASKBIT(1 : 0));
+		msWriteByteMask(mtk_dp,
+			REG_31FC_DP_ENCODER0_P0,
+			hde_last_num << 2,
+			MASKBIT(3 : 2));
+		msWriteByteMask(mtk_dp,
+			REG_31FC_DP_ENCODER0_P0 + 1,
+			hde_num_even,
+			BIT0);
+		msWriteByteMask(mtk_dp,
+			REG_31FC_DP_ENCODER0_P0 + 1,
+			hde_num_even << 1,
+			BIT1);
+	}
+}
+
+void mhal_DPTx_Fake_Plugin(struct mtk_dp *mtk_dp, bool conn)
+{
+	if (conn) {
+		msWriteByteMask(mtk_dp, REG_3414_DP_TRANS_P0, 0,
+			HPD_OVR_EN_DP_TRANS_P0_FLDMASK);
+		msWriteByteMask(mtk_dp, REG_3414_DP_TRANS_P0, 0,
+			HPD_SET_DP_TRANS_P0_FLDMASK);
+	} else {
+		msWriteByteMask(mtk_dp, REG_3414_DP_TRANS_P0,
+			HPD_OVR_EN_DP_TRANS_P0_FLDMASK,
+			HPD_OVR_EN_DP_TRANS_P0_FLDMASK);
+		msWriteByteMask(mtk_dp, REG_3414_DP_TRANS_P0, 0,
+			HPD_SET_DP_TRANS_P0_FLDMASK);
+	}
+}
+
+void mhal_DPTx_USBC_HPD(struct mtk_dp *mtk_dp, bool conn)
+{
+	msWriteByteMask(mtk_dp,
+		REG_3414_DP_TRANS_P0,
+		HPD_OVR_EN_DP_TRANS_P0_FLDMASK,
+		HPD_OVR_EN_DP_TRANS_P0_FLDMASK);
+
+	if (conn)
+		msWriteByteMask(mtk_dp,
+			REG_3414_DP_TRANS_P0,
+			HPD_SET_DP_TRANS_P0_FLDMASK,
+			HPD_SET_DP_TRANS_P0_FLDMASK);
+	else
+		msWriteByteMask(mtk_dp,
+			REG_3414_DP_TRANS_P0,
+			0,
+			HPD_SET_DP_TRANS_P0_FLDMASK);
+}
+
+WORD mhal_DPTx_GetSWIRQStatus(struct mtk_dp *mtk_dp)
+{
+	return msRead2Byte(mtk_dp, REG_35D0_DP_TRANS_P0);
+}
+
+void mhal_DPTx_SWInterruptSet(struct mtk_dp *mtk_dp, WORD bstatus)
+{
+	msWrite2Byte(mtk_dp, REG_35C0_DP_TRANS_P0, bstatus);
+
+}
+void mhal_DPTx_SWInterruptClr(struct mtk_dp *mtk_dp, WORD bstatus)
+{
+	msWrite2Byte(mtk_dp, REG_35C8_DP_TRANS_P0, bstatus);
+	msWrite2Byte(mtk_dp, REG_35C8_DP_TRANS_P0, 0);
+}
+
+void mhal_DPTx_SWInterruptEnable(struct mtk_dp *mtk_dp, bool enable)
+{
+	if (enable)
+		msWrite2Byte(mtk_dp, REG_35C4_DP_TRANS_P0, 0);
+	else
+		msWrite2Byte(mtk_dp, REG_35C4_DP_TRANS_P0, 0xFFFF);
+}
+
+BYTE mhal_DPTx_GetHPDIRQStatus(struct mtk_dp *mtk_dp)
+{
+	return (msReadByte(mtk_dp, REG_3418_DP_TRANS_P0 + 1) & 0xE0) >> 4;
+}
+
+void mhal_DPTx_HPDInterruptClr(struct mtk_dp *mtk_dp, BYTE bstatus)
+{
+	msWriteByteMask(mtk_dp,
+		REG_3418_DP_TRANS_P0,
+		bstatus,
+		BIT3|BIT2|BIT1);
+	msWriteByteMask(mtk_dp,
+		REG_3418_DP_TRANS_P0,
+		0,
+		BIT3|BIT2|BIT1);
+}
+
+void mhal_DPTx_HPDInterruptEnable(struct mtk_dp *mtk_dp, bool enable)
+{
+	// [7]:int[6]:Con[5]DisCon[4]No-Use:UnMASK HPD Port
+	if (enable)
+		msWriteByteMask(mtk_dp,
+			REG_3418_DP_TRANS_P0,
+			0,
+			BIT7|BIT6|BIT5);
+	else
+		msWriteByteMask(mtk_dp,
+			REG_3418_DP_TRANS_P0,
+			BIT7|BIT6|BIT5,
+			BIT7|BIT6|BIT5);
+}
+
+void mhal_DPTx_HPDDetectSetting(struct mtk_dp *mtk_dp)
+{
+	msWriteByteMask(mtk_dp,
+		REG_3410_DP_TRANS_P0,
+		0x8,
+		MASKBIT(3 : 0));
+	msWriteByteMask(mtk_dp,
+		REG_3410_DP_TRANS_P0,
+		(0x0A << 4),
+		MASKBIT(7 : 4));
+
+	// [7 : 4] Con Thd = 1.5ms+Vx0.1ms[3 : 0] : DisCon Thd = 1.5ms+Vx0.1ms
+	msWriteByte(mtk_dp,
+		REG_3410_DP_TRANS_P0 + 1,
+		0x55);
+	msWriteByte(mtk_dp,
+		REG_3430_DP_TRANS_P0,
+		0x02); //1113 MK
+}
+
+void mhal_DPTx_PHYSetting(struct mtk_dp *mtk_dp)
+{
+	msWrite4ByteMask(mtk_dp,
+		DP_TX_TOP_PWR_STATE,
+		0x3 << DP_PWR_STATE_FLDMASK_POS, DP_PWR_STATE_FLDMASK);
+
+	msWrite4ByteMask(mtk_dp, 0x0008, 0xf << 8, BITMASK(11 : 8));
+
+	msWrite4Byte(mtk_dp, 0x2000, 0x00000001);
+	msWrite4Byte(mtk_dp, 0x103C, 0x00000000);
+	msWrite4Byte(mtk_dp, 0x2000, 0x00000003);
+
+
+	msWrite4Byte(mtk_dp, 0x1138, 0x20181410);
+	msWrite4Byte(mtk_dp, 0x1238, 0x20181410);
+	msWrite4Byte(mtk_dp, 0x1338, 0x20181410);
+	msWrite4Byte(mtk_dp, 0x1438, 0x20181410);
+
+	msWrite4Byte(mtk_dp, 0x113C, 0x20241e18);
+	msWrite4Byte(mtk_dp, 0x123C, 0x20241e18);
+	msWrite4Byte(mtk_dp, 0x133C, 0x20241e18);
+	msWrite4Byte(mtk_dp, 0x143C, 0x20241e18);
+
+
+	msWrite4Byte(mtk_dp, 0x1140, 0x00003028);
+	msWrite4Byte(mtk_dp, 0x1240, 0x00003028);
+	msWrite4Byte(mtk_dp, 0x1340, 0x00003028);
+	msWrite4Byte(mtk_dp, 0x1440, 0x00003028);
+
+	msWrite4Byte(mtk_dp, 0x1144, 0x10080400);
+	msWrite4Byte(mtk_dp, 0x1244, 0x10080400);
+	msWrite4Byte(mtk_dp, 0x1344, 0x10080400);
+	msWrite4Byte(mtk_dp, 0x1444, 0x10080400);
+
+	msWrite4Byte(mtk_dp, 0x1148, 0x000c0600);
+	msWrite4Byte(mtk_dp, 0x1248, 0x000c0600);
+	msWrite4Byte(mtk_dp, 0x1348, 0x000c0600);
+	msWrite4Byte(mtk_dp, 0x1448, 0x000c0600);
+
+	msWrite4Byte(mtk_dp, 0x114C, 0x00000008);
+	msWrite4Byte(mtk_dp, 0x124C, 0x00000008);
+	msWrite4Byte(mtk_dp, 0x134C, 0x00000008);
+	msWrite4Byte(mtk_dp, 0x144C, 0x00000008);
+
+	msWrite4ByteMask(mtk_dp, 0x3690, BIT8, BIT8);
+}
+
+void mhal_DPTx_AdjustPHYSetting(struct mtk_dp *mtk_dp, BYTE c0, BYTE cp1)
+{
+	uint32_t reg = 0;
+	BYTE temp = 0;
+
+	temp = c0 & 0x3F;
+	reg = temp | (temp << 8) | (temp << 16) | (temp << 24);
+	msWrite4Byte(mtk_dp, 0x1138, reg);
+	msWrite4Byte(mtk_dp, 0x1238, reg);
+	msWrite4Byte(mtk_dp, 0x1338, reg);
+	msWrite4Byte(mtk_dp, 0x1438, reg);
+
+	msWrite4Byte(mtk_dp, 0x113C, reg);
+	msWrite4Byte(mtk_dp, 0x123C, reg);
+	msWrite4Byte(mtk_dp, 0x133C, reg);
+	msWrite4Byte(mtk_dp, 0x143C, reg);
+
+	reg = temp | (temp << 8);
+	msWrite4Byte(mtk_dp, 0x1140, reg);
+	msWrite4Byte(mtk_dp, 0x1240, reg);
+	msWrite4Byte(mtk_dp, 0x1340, reg);
+	msWrite4Byte(mtk_dp, 0x1440, reg);
+
+	temp = cp1 & 0x3F;
+	reg = temp | (temp << 8) | (temp << 16) | (temp << 24);
+	msWrite4Byte(mtk_dp, 0x1144, reg);
+	msWrite4Byte(mtk_dp, 0x1244, reg);
+	msWrite4Byte(mtk_dp, 0x1344, reg);
+	msWrite4Byte(mtk_dp, 0x1444, reg);
+
+	msWrite4Byte(mtk_dp, 0x1148, reg);
+	msWrite4Byte(mtk_dp, 0x1248, reg);
+	msWrite4Byte(mtk_dp, 0x1348, reg);
+	msWrite4Byte(mtk_dp, 0x1448, reg);
+
+	reg = temp | (temp << 8);
+	msWrite4Byte(mtk_dp, 0x114C, reg);
+	msWrite4Byte(mtk_dp, 0x124C, reg);
+	msWrite4Byte(mtk_dp, 0x134C, reg);
+	msWrite4Byte(mtk_dp, 0x144C, reg);
+}
+
+void mhal_DPTx_SSCOnOffSetting(struct mtk_dp *mtk_dp, bool bENABLE)
+{
+	msWrite4ByteMask(mtk_dp, 0x2000, BIT(0), BITMASK(0:1));
+
+	if (bENABLE)
+		msWrite4ByteMask(mtk_dp, 0x1014, BIT(3), BIT(3));
+	else
+		msWrite4ByteMask(mtk_dp, 0x1014, 0x0, BIT(3));
+
+	msWrite4ByteMask(mtk_dp, 0x2000, BIT(0)|BIT(1), BITMASK(0:1));
+
+	udelay(50);
+}
+
+void mhal_DPTx_AuxSetting(struct mtk_dp *mtk_dp)
+{
+	// modify timeout threshold = 1595 [12 : 8]
+	msWrite2ByteMask(mtk_dp,
+		REG_360C_AUX_TX_P0,
+		0x1595,
+		AUX_TIMEOUT_THR_AUX_TX_P0_FLDMASK);
+	msWriteByteMask(mtk_dp,
+		REG_3658_AUX_TX_P0,
+		0,
+		BIT0);    //[0]mtk_dp, REG_aux_tx_ov_en
+	msWriteByte(mtk_dp,
+		REG_3634_AUX_TX_P0 + 1,
+		0x19);  //  25 for 26M
+	msWriteByteMask(mtk_dp,
+		REG_3614_AUX_TX_P0,
+		0x0D,
+		MASKBIT(6 : 0));    // Modify, 13 for 26M
+	msWrite4ByteMask(mtk_dp,
+		REG_37C8_AUX_TX_P0,
+		0x01 << MTK_ATOP_EN_AUX_TX_P0_FLDMASK_POS,
+		MTK_ATOP_EN_AUX_TX_P0_FLDMASK);
+}
+
+
+void mhal_DPTx_DigitalSetting(struct mtk_dp *mtk_dp)
+{
+	msWriteByteMask(mtk_dp,
+		REG_304C_DP_ENCODER0_P0,
+		0,
+		VBID_VIDEO_MUTE_DP_ENCODER0_P0_FLDMASK);
+	mhal_DPTx_SetColorFormat(mtk_dp, DP_COLOR_FORMAT_RGB);//MISC0
+	// [13 : 12] : = 2b'01 VDE check BS2BS & set min value
+	mhal_DPTx_SetColorDepth(mtk_dp, DP_COLOR_DEPTH_8BIT);
+	msWriteByteMask(mtk_dp,
+		REG_3368_DP_ENCODER1_P0 + 1,
+		BIT4,
+		MASKBIT(5 : 4));
+	msWriteByteMask(mtk_dp,
+		REG_3004_DP_ENCODER0_P0 + 1,
+		BIT1,
+		BIT1);// dp tx encoder reset all sw
+	//DELAY_NOP(10);
+	mdelay(1);
+	// dp tx encoder reset all sw
+	msWriteByteMask(mtk_dp, REG_3004_DP_ENCODER0_P0 + 1, 0, BIT1);
+}
+
+
+void mhal_DPTx_DigitalSwReset(struct mtk_dp *mtk_dp)
+{
+	msWriteByteMask(mtk_dp, REG_340C_DP_TRANS_P0 + 1, BIT5, BIT5);
+	mdelay(1);
+	msWriteByteMask(mtk_dp, REG_340C_DP_TRANS_P0 + 1, 0, BIT5);
+}
+
+
+void mhal_DPTx_SetTxLaneToLane(struct mtk_dp *mtk_dp, BYTE ucLaneNum,
+	BYTE ucSetLaneNum)
+{
+	msWriteByteMask(mtk_dp,
+		REG_3408_DP_TRANS_P0 + 1,
+		(ucSetLaneNum << (ucLaneNum*2)),
+		(BIT1|BIT0) << (ucLaneNum*2)); // swap Lane A  to Lane B
+}
+
+void mhal_DPTx_PHYD_Reset(struct mtk_dp *mtk_dp)
+{
+	msWriteByteMask(mtk_dp, 0x1038, 0, BIT(0));
+	udelay(50);
+	msWriteByteMask(mtk_dp, 0x1038, BIT(0), BIT(0));
+}
+
+void mhal_DPTx_SetTxLane(struct mtk_dp *mtk_dp, int  Value)
+{
+	if (Value == 0)
+		msWriteByteMask(mtk_dp,
+			REG_35F0_DP_TRANS_P0,
+			0,
+			BIT3|BIT2);
+	else
+		msWriteByteMask(mtk_dp,
+			REG_35F0_DP_TRANS_P0,
+			BIT3,
+			BIT3|BIT2);
+
+	msWriteByteMask(mtk_dp,
+		REG_3000_DP_ENCODER0_P0,
+		Value,
+		BIT1|BIT0);
+
+	msWriteByteMask(mtk_dp,
+		REG_34A4_DP_TRANS_P0,
+		(Value << 2),
+		BIT3|BIT2);
+}
+
+
+void mhal_DPTx_SetTxRate(struct mtk_dp *mtk_dp, int Value)
+{
+	msWrite4Byte(mtk_dp, 0x2000, 0x00000001); // power off TPLL and Lane;
+	/// Set gear : 0x0 : RBR, 0x1 : HBR, 0x2 : HBR2, 0x3 : HBR3
+	switch (Value) {
+	case 0x06:
+		msWrite4Byte(mtk_dp,
+			0x103C,
+			0x00000000);
+		break;
+	case 0x0A:
+		msWrite4Byte(mtk_dp,
+			0x103C,
+			0x00000001);
+		break;
+	case 0x14:
+		msWrite4Byte(mtk_dp,
+			0x103C,
+			0x00000002);
+		break;
+	case 0x1E:
+		msWrite4Byte(mtk_dp,
+			0x103C,
+			0x00000003);
+		break;
+	default:
+		break;
+	}
+
+	msWrite4Byte(mtk_dp,
+		0x2000,
+		0x00000003); // power on BandGap, TPLL and Lane;
+}
+
+
+void mhal_DPTx_SetTxTrainingPattern(struct mtk_dp *mtk_dp, int  Value)
+{
+	if (Value == BIT4) // if Set TPS1
+		mhal_DPTx_PHY_SetIdlePattern(mtk_dp, false);
+
+	msWriteByteMask(mtk_dp,
+		REG_3400_DP_TRANS_P0 + 1,
+		Value,
+		MASKBIT(7 : 4));
+}
+
+
+
+void mhal_DPTx_PHY_SetIdlePattern(struct mtk_dp *mtk_dp, bool bENABLE)
+{
+	DPTXDBG("Idle pattern enable(%d)\n", bENABLE);
+	if (bENABLE) // if Set TPS1
+		msWriteByteMask(mtk_dp,
+			REG_3580_DP_TRANS_P0 + 1,
+			0x0F,
+			0x0F);  // enable programmable 80bit to zero
+	else
+		msWriteByteMask(mtk_dp,
+			REG_3580_DP_TRANS_P0 + 1,
+			0x0,
+			0x0F);  // disab
+}
+
+void mhal_DPTx_SetFreeSync(struct mtk_dp *mtk_dp, bool bENABLE)
+{
+	if (bENABLE)//mtk_dp, REG_bs2bs_mode, [13 : 12]  = 11 freesync on
+		msWriteByteMask(mtk_dp,
+			REG_3368_DP_ENCODER1_P0 + 1,
+			BIT5|BIT4,
+			BIT5|BIT4);
+	else//mtk_dp, REG_bs2bs_mode, [13 : 12] = 01 freesync off
+		msWriteByteMask(mtk_dp,
+			REG_3368_DP_ENCODER1_P0 + 1,
+			BIT4,
+			BIT5|BIT4);
+}
+
+void mhal_DPTx_SetEF_Mode(struct mtk_dp *mtk_dp, bool  bENABLE)
+{
+	if (bENABLE)//[4] REG_enhanced_frame_mode [1 : 0]mtk_dp, REG_lane_num
+		msWriteByteMask(mtk_dp,
+			REG_3000_DP_ENCODER0_P0,
+			BIT4,
+			BIT4);
+	else //[4]mtk_dp, REG_enhanced_frame_mode [1 : 0]mtk_dp, REG_lane_num
+		msWriteByteMask(mtk_dp,
+		REG_3000_DP_ENCODER0_P0,
+		0,
+		BIT4);
+
+}
+
+
+void mhal_DPTx_SetScramble(struct mtk_dp *mtk_dp, bool  bENABLE)
+{
+	if (bENABLE)
+		msWriteByteMask(mtk_dp,
+			REG_3404_DP_TRANS_P0,
+			BIT0,
+			BIT0); //[0]dp tx transmitter scramble enable
+	else
+		msWriteByteMask(mtk_dp,
+			REG_3404_DP_TRANS_P0,
+			0,
+			BIT0); //[0]dp tx transmitter scramble enable
+}
+
+
+void mhal_DPTx_SetScramble_Type(struct mtk_dp *mtk_dp, bool bSelType)
+{
+	//[1]scrambler reset data,0:DP 16'ffff, 1:eDP 16'fffe
+	if (bSelType)//eDP
+		msWriteByteMask(mtk_dp,
+			REG_3404_DP_TRANS_P0,
+			BIT1,
+			BIT1);
+	else // DP
+		msWriteByteMask(mtk_dp,
+			REG_3404_DP_TRANS_P0,
+			0,
+			BIT1);
+}
+
+
+void mhal_DPTx_VideoMute(struct mtk_dp *mtk_dp, bool bENABLE)
+{
+	if (bENABLE) {
+		msWriteByteMask(mtk_dp,
+			REG_3000_DP_ENCODER0_P0,
+			BIT3|BIT2,
+			BIT3|BIT2); //Video mute enable
+
+		if (mtk_dp->driver_data && mtk_dp->driver_data->is_edp)
+			mtk_dp_atf_call(DP_ATF_EDP_VIDEO_UNMUTE, 1);
+		else
+			mtk_dp_atf_call(DP_ATF_VIDEO_UNMUTE, 1);
+	} else {
+		msWriteByteMask(mtk_dp,
+			REG_3000_DP_ENCODER0_P0,
+			BIT3,
+			BIT3|BIT2);// [3] Sw ov Mode [2] mute value
+
+		if (mtk_dp->driver_data && mtk_dp->driver_data->is_edp)
+			mtk_dp_atf_call(DP_ATF_EDP_VIDEO_UNMUTE, 0);
+		else
+			mtk_dp_atf_call(DP_ATF_VIDEO_UNMUTE, 0);
+	}
+}
+
+void mhal_DPTx_VideoMuteSW(struct mtk_dp *mtk_dp, bool bENABLE)
+{
+	if (bENABLE)
+		msWriteByteMask(mtk_dp,
+			REG_304C_DP_ENCODER0_P0,
+			BIT2,
+			BIT2); //Video mute enable
+	else
+		msWriteByteMask(mtk_dp,
+			REG_304C_DP_ENCODER0_P0,
+			0,
+			BIT2);	// [3] Sw ov Mode [2] mute value
+}
+
+
+void mhal_DPTx_AudioMute(struct mtk_dp *mtk_dp, bool bENABLE)
+{
+	if (bENABLE) {
+		msWrite2ByteMask(mtk_dp,
+			REG_3030_DP_ENCODER0_P0,
+			0x01 << VBID_AUDIO_MUTE_SW_DP_ENCODER0_P0_FLDMASK_POS,
+			VBID_AUDIO_MUTE_FLAG_SW_DP_ENCODER0_P0_FLDMASK);
+
+		msWrite2ByteMask(mtk_dp,
+			REG_3030_DP_ENCODER0_P0,
+			0x01 << VBID_AUDIO_MUTE_SEL_DP_ENCODER0_P0_FLDMASK_POS,
+			VBID_AUDIO_MUTE_FLAG_SEL_DP_ENCODER0_P0_FLDMASK);
+
+		msWriteByteMask(mtk_dp,
+			REG_3088_DP_ENCODER0_P0,
+			0x0 << AU_EN_DP_ENCODER0_P0_FLDMASK_POS,
+			AU_EN_DP_ENCODER0_P0_FLDMASK);
+		msWriteByte(mtk_dp,
+			REG_30A4_DP_ENCODER0_P0,
+			0x00);
+
+	} else {
+		msWrite2ByteMask(mtk_dp,
+			REG_3030_DP_ENCODER0_P0,
+			0x00 << VBID_AUDIO_MUTE_SEL_DP_ENCODER0_P0_FLDMASK_POS,
+			VBID_AUDIO_MUTE_FLAG_SEL_DP_ENCODER0_P0_FLDMASK);
+
+		msWriteByteMask(mtk_dp, REG_3088_DP_ENCODER0_P0,
+			0x1 << AU_EN_DP_ENCODER0_P0_FLDMASK_POS,
+			AU_EN_DP_ENCODER0_P0_FLDMASK);
+		msWriteByte(mtk_dp,
+			REG_30A4_DP_ENCODER0_P0,
+			0x0F);
+	}
+}
+
+void mhal_DPTx_ShutDownDPTxPort(struct mtk_dp *mtk_dp)
+{
+	//Power Down Tx Aux
+	msWriteByteMask(mtk_dp, REG_367C_AUX_TX_P0 + 1, 0, BIT4);
+	msWriteByteMask(mtk_dp, REG_3670_AUX_TX_P0 + 1, BIT2, BIT2);
+}
+
+void mhal_DPTx_AnalogPowerOnOff(struct mtk_dp *mtk_dp, bool enable)
+{
+	if (enable) {
+		msWriteByteMask(mtk_dp, DP_TX_TOP_RESET_AND_PROBE, 0, BIT4);
+		udelay(10);
+		msWriteByteMask(mtk_dp, DP_TX_TOP_RESET_AND_PROBE, BIT4, BIT4);
+	} else {
+		msWrite2Byte(mtk_dp, TOP_OFFSET, 0x0);
+		udelay(10);
+		msWrite2Byte(mtk_dp, 0x0034, 0x4AA);
+		msWrite2Byte(mtk_dp, 0x1040, 0x0);
+		msWrite2Byte(mtk_dp, 0x0038, 0x555);
+	}
+}
+
+
diff --git a/drivers/gpu/drm/mediatek/mtk_dp_hal.h b/drivers/gpu/drm/mediatek/mtk_dp_hal.h
new file mode 100644
index 0000000000000000000000000000000000000000..2b02e5347c16252929a266179ca4571d263d4b7d
--- /dev/null
+++ b/drivers/gpu/drm/mediatek/mtk_dp_hal.h
@@ -0,0 +1,320 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2019 MediaTek Inc.
+ */
+
+#ifndef __DRTX_HAL_H__
+#define __DRTX_HAL_H__
+
+#include "mtk_dp_common.h"
+
+
+#define AUX_CMD_I2C_R_MOT0		0x01
+#define AUX_CMD_I2C_R			0x05
+#define AUX_CMD_NATIVE_R		0x09
+#define AuxWaitReplyLpCntNum		20000
+
+
+#define MASKBIT(a)			(BIT((1 ? a) + 1) - BIT((0 ? a)))
+#define _BITMASK(loc_msb, loc_lsb) \
+	((1U << (loc_msb)) - (1U << (loc_lsb)) + (1U << (loc_msb)))
+#define BITMASK(x) _BITMASK(1 ? x, 0 ? x)
+
+
+enum DPTx_LANE_NUM {
+	DPTx_LANE0 = 0x0,
+	DPTx_LANE1 = 0x1,
+	DPTx_LANE2 = 0x2,
+	DPTx_LANE3 = 0x3,
+	DPTx_LANE_MAX,
+};
+
+enum DPTx_LANE_Count {
+	DPTx_LANE_0 = 0x0,
+	DPTx_LANE_2 = 0x01,
+	DPTx_LANE_4 = 0x02,
+};
+
+enum DPTx_LINK_Rate {
+	DPTx_RATE_RBR  = 0x06,
+	DPTx_RATE_HBR  = 0x0A,
+	DPTx_RATE_HBR2 = 0x14,
+	DPTx_RATE_HBR3 = 0x1E,
+};
+
+enum DPTx_SDP_PKG_TYPE {
+	DPTx_SDPTYP_NONE = 0x00,
+	DPTx_SDPTYP_ACM  = 0x01,
+	DPTx_SDPTYP_ISRC = 0x02,
+	DPTx_SDPTYP_AVI  = 0x03,
+	DPTx_SDPTYP_AUI  = 0x04,
+	DPTx_SDPTYP_SPD  = 0x05,
+	DPTx_SDPTYP_MPEG = 0x06,
+	DPTx_SDPTYP_NTSC = 0x07,
+	DPTx_SDPTYP_VSP  = 0x08,
+	DPTx_SDPTYP_VSC  = 0x09,
+	DPTx_SDPTYP_EXT  = 0x0A,
+	DPTx_SDPTYP_PPS0 = 0x0B,
+	DPTx_SDPTYP_PPS1 = 0x0C,
+	DPTx_SDPTYP_PPS2 = 0x0D,
+	DPTx_SDPTYP_PPS3 = 0x0E,
+	DPTx_SDPTYP_DRM  = 0x10,
+	DPTx_SDPTYP_MAX_NUM
+};
+
+enum DPTx_SDP_HB1_PKG_TYPE {
+	DP_SPEC_SDPTYP_RESERVE	= 0x00,
+	DP_SPEC_SDPTYP_AUDIO_TS	= 0x01,
+	DP_SPEC_SDPTYP_AUDIO	= 0x02,
+	DP_SPEC_SDPTYP_EXT	= 0x04,
+	DP_SPEC_SDPTYP_ACM	= 0x05,
+	DP_SPEC_SDPTYP_ISRC	= 0x06,
+	DP_SPEC_SDPTYP_VSC	= 0x07,
+	DP_SPEC_SDPTYP_CAMERA   = 0x08,
+	DP_SPEC_SDPTYP_PPS      = 0x10,
+	DP_SPEC_SDPTYP_EXT_VESA = 0x20,
+	DP_SPEC_SDPTYP_EXT_CEA  = 0x21,
+	DP_SPEC_SDPTYP_NON_AINFO = 0x80,
+	DP_SPEC_SDPTYP_VS_INFO	= 0x81,
+	DP_SPEC_SDPTYP_AVI_INFO	= 0x82,
+	DP_SPEC_SDPTYP_SPD_INFO = 0x83,
+	DP_SPEC_SDPTYP_AINFO    = 0x84,
+	DP_SPEC_SDPTYP_MPG_INFO = 0x85,
+	DP_SPEC_SDPTYP_NTSC_INFO = 0x86,
+	DP_SPEC_SDPTYP_DRM_INFO = 0x87,
+	DP_SPEC_SDPTYP_MAX_NUM
+};
+
+enum DP_COLOR_FORMAT_TYPE {
+	DP_COLOR_FORMAT_RGB_444     = 0,
+	DP_COLOR_FORMAT_YUV_422     = 1,
+	DP_COLOR_FORMAT_YUV_444     = 2,
+	DP_COLOR_FORMAT_YUV_420     = 3,
+	DP_COLOR_FORMAT_YONLY       = 4,
+	DP_COLOR_FORMAT_RAW         = 5,
+	DP_COLOR_FORMAT_RESERVED    = 6,
+	DP_COLOR_FORMAT_DEFAULT     = DP_COLOR_FORMAT_RGB_444,
+	DP_COLOR_FORMAT_UNKNOWN     = 15,
+};
+
+enum DP_COLOR_DEPTH_TYPE {
+	DP_COLOR_DEPTH_6BIT       = 0,
+	DP_COLOR_DEPTH_8BIT       = 1,
+	DP_COLOR_DEPTH_10BIT      = 2,
+	DP_COLOR_DEPTH_12BIT      = 3,
+	DP_COLOR_DEPTH_16BIT      = 4,
+	DP_COLOR_DEPTH_UNKNOWN    = 5,
+};
+
+enum AUDIO_FS {
+	FS_22K = 0x0,
+	FS_32K = 0x1,
+	FS_44K = 0x2,
+	FS_48K = 0x3,
+	FS_88K = 0x4,
+	FS_96K = 0x5,
+	FS_176K = 0x6,
+	FS_192K = 0x7,
+	FS_MAX,
+};
+
+enum AUDIO_WORD_LEN {
+	WL_16bit = 1,
+	WL_20bit = 2,
+	WL_24bit = 3,
+	WL_MAX,
+};
+
+#define  IEC_CH_STATUS_LEN 5
+union DPRX_AUDIO_CHSTS {
+	struct{
+		BYTE rev : 1;
+		BYTE ISLPCM : 1;
+		BYTE CopyRight : 1;
+		BYTE AdditionFormatInfo : 3;
+		BYTE ChannelStatusMode : 2;
+		BYTE CategoryCode;
+		BYTE SourceNumber : 4;
+		BYTE ChannelNumber : 4;
+		BYTE SamplingFreq : 4;
+		BYTE ClockAccuary : 2;
+		BYTE rev2 : 2;
+		BYTE WordLen : 4;
+		BYTE OriginalSamplingFreq : 4;
+	} iec_ch_sts;
+
+	BYTE AUD_CH_STS[IEC_CH_STATUS_LEN];
+};
+
+enum DPTx_PG_PURECOLOR {
+	DPTX_PG_PURECOLOR_NONE		= 0x0,
+	DPTX_PG_PURECOLOR_BLUE		= 0x1,
+	DPTX_PG_PURECOLOR_GREEN		= 0x2,
+	DPTX_PG_PURECOLOR_RED		= 0x3,
+	DPTX_PG_PURECOLOR_MAX,
+};
+
+enum DPTx_PG_LOCATION {
+	DPTX_PG_LOCATION_NONE            = 0x0,
+	DPTX_PG_LOCATION_ALL             = 0x1,
+	DPTX_PG_LOCATION_TOP             = 0x2,
+	DPTX_PG_LOCATION_BOTTOM          = 0x3,
+	DPTX_PG_LOCATION_LEFT_OF_TOP     = 0x4,
+	DPTX_PG_LOCATION_LEFT_OF_BOTTOM  = 0x5,
+	DPTX_PG_LOCATION_LEFT            = 0x6,
+	DPTX_PG_LOCATION_RIGHT           = 0x7,
+	DPTX_PG_LOCATION_LEFT_OF_LEFT    = 0x8,
+	DPTX_PG_LOCATION_RIGHT_OF_LEFT   = 0x9,
+	DPTX_PG_LOCATION_LEFT_OF_RIGHT   = 0xA,
+	DPTX_PG_LOCATION_RIGHT_OF_RIGHT  = 0xB,
+	DPTX_PG_LOCATION_MAX,
+};
+
+enum DPTx_PG_PIXEL_MASK {
+	DPTX_PG_PIXEL_MASK_NONE         = 0x0,
+	DPTX_PG_PIXEL_ODD_MASK          = 0x1,
+	DPTX_PG_PIXEL_EVEN_MASK         = 0x2,
+	DPTX_PG_PIXEL_MASK_MAX,
+};
+
+enum DPTx_PG_TYPESEL {
+	DPTX_PG_NONE                    = 0x0,
+	DPTX_PG_PURE_COLOR              = 0x1,
+	DPTX_PG_VERTICAL_RAMPING        = 0x2,
+	DPTX_PG_HORIZONTAL_RAMPING      = 0x3,
+	DPTX_PG_VERTICAL_COLOR_BAR      = 0x4,
+	DPTX_PG_HORIZONTAL_COLOR_BAR    = 0x5,
+	DPTX_PG_CHESSBOARD_PATTERN      = 0x6,
+	DPTX_PG_SUB_PIXEL_PATTERN       = 0x7,
+	DPTX_PG_FRAME_PATTERN           = 0x8,
+	DPTX_PG_MAX,
+};
+
+
+u32 mtk_dp_read(struct mtk_dp *mtk_dp, u32 offset);
+void mtk_dp_write_byte(struct mtk_dp *mtk_dp, u32 addr, u8 val, u32 mask);
+void mtk_dp_mask(struct mtk_dp *mtk_dp, u32 offset, u32 val, u32 mask);
+void mtk_dp_write(struct mtk_dp *mtk_dp, u32 offset, u32 val);
+
+#define msReadByte(mtk_dp, u32Reg) mtk_dp_read(mtk_dp, u32Reg)
+#define msRead2Byte(mtk_dp, u32Reg) mtk_dp_read(mtk_dp, u32Reg)
+#define msRead4Byte(mtk_dp, u32Reg) mtk_dp_read(mtk_dp, u32Reg)
+#define msWriteByte(mtk_dp, u32Reg, u8Val) \
+	mtk_dp_write_byte(mtk_dp, u32Reg, u8Val, 0xFF)
+#define msWrite2Byte(mtk_dp, u32Reg, u16Val) \
+	mtk_dp_mask(mtk_dp, u32Reg, u16Val, 0xFFFF)
+#define msWrite4Byte(mtk_dp, u32Reg, u32Val) \
+	mtk_dp_write(mtk_dp, u32Reg, u32Val)
+#define msWriteByteMask(mtk_dp, addr, val, mask) \
+	mtk_dp_write_byte(mtk_dp, addr, val, mask)
+#define msWrite2ByteMask(mtk_dp, addr, val, mask) \
+	mtk_dp_mask(mtk_dp, addr, val, mask)
+#define msWrite4ByteMask(mtk_dp, addr, val, mask) \
+	mtk_dp_mask(mtk_dp, addr, val, mask)
+
+extern void mdrv_DPTx_HPD_ISREvent(struct mtk_dp *mtk_dp);
+void mhal_DPTx_USBC_HPD(struct mtk_dp *mtk_dp, bool conn);
+void mhal_DPTx_Fake_Plugin(struct mtk_dp *mtk_dp, bool conn);
+void mhal_dump_reg(struct mtk_dp *mtk_dp);
+void mhal_DPTx_Verify_Clock(struct mtk_dp *mtk_dp);
+void mhal_DPTx_ISR(struct mtk_dp *mtk_dp);
+BYTE mhal_DPTx_GetColorBpp(struct mtk_dp *mtk_dp);
+bool mhal_DPTx_AuxRead_Bytes(struct mtk_dp *mtk_dp,
+	BYTE ubCmd, DWORD usDPCDADDR, size_t ubLength, BYTE *pRxBuf);
+bool mhal_DPTx_AuxWrite_Bytes(struct mtk_dp *mtk_dp,
+	BYTE ubCmd, DWORD usDPCDADDR, size_t ubLength, BYTE *pData);
+bool mhal_DPTx_SetSwingtPreEmphasis(struct mtk_dp *mtk_dp, int lane_num,
+	int swingValue, int preEmphasis);
+bool mhal_DPTx_ResetSwingtPreEmphasis(struct mtk_dp *mtk_dp);
+void mhal_DPTx_DigitalSwReset(struct mtk_dp *mtk_dp);
+bool mhal_DPTx_GetHPDPinLevel(struct mtk_dp *mtk_dp);
+void mhal_DPTx_SSCOnOffSetting(struct mtk_dp *mtk_dp, bool bENABLE);
+void mhal_DPTx_SWInterruptSet(struct mtk_dp *mtk_dp, WORD bstatus);
+void mhal_DPTx_SWInterruptClr(struct mtk_dp *mtk_dp, WORD bstatus);
+void mhal_DPTx_SWInterruptEnable(struct mtk_dp *mtk_dp, bool enable);
+void mhal_DPTx_HPDInterruptClr(struct mtk_dp *mtk_dp, BYTE bstatus);
+void mhal_DPTx_HPDInterruptEnable(struct mtk_dp *mtk_dp, bool enable);
+void mhal_DPTx_HPDDetectSetting(struct mtk_dp *mtk_dp);
+void mhal_DPTx_PHYSetting(struct mtk_dp *mtk_dp);
+void mhal_DPTx_AuxSetting(struct mtk_dp *mtk_dp);
+void mhal_DPTx_AdjustPHYSetting(struct mtk_dp *mtk_dp, BYTE c0, BYTE cp1);
+void mhal_DPTx_DigitalSetting(struct mtk_dp *mtk_dp);
+void mhal_DPTx_PSCTRL(bool AUXNHighEnable);
+void mhal_DPTx_SetTxLane(struct mtk_dp *mtk_dp, int Value);
+void mhal_DPTx_SetTxLaneToLane(struct mtk_dp *mtk_dp,
+	BYTE ucLaneNum, BYTE ucSetLaneNum);
+void mhal_DPTx_SetPGMSA(struct mtk_dp *mtk_dp, BYTE Address, WORD Data);
+void mhal_DPTx_PHY_ResetPattern(struct mtk_dp *mtk_dp);
+void mhal_DPTx_PHY_SetIdlePattern(struct mtk_dp *mtk_dp, bool bENABLE);
+void mhal_DPTx_PHYD_Reset(struct mtk_dp *mtk_dp);
+void mhal_DPTx_PRBSEnable(struct mtk_dp *mtk_dp, bool bENABLE);
+void mhal_DPTx_PatternSelect(struct mtk_dp *mtk_dp, int Value);
+void mhal_DPTx_ComplianceEyeEnSetting(struct mtk_dp *mtk_dp,  bool bENABLE);
+void mhal_DPTx_SetProgramPattern(struct mtk_dp *mtk_dp,
+	BYTE Value, BYTE  *usData);
+void mhal_DPTx_ProgramPatternEnable(struct mtk_dp *mtk_dp, bool bENABLE);
+void mhal_DPTx_SetTxTrainingPattern(struct mtk_dp *mtk_dp, int  Value);
+void mhal_DPTx_SetEF_Mode(struct mtk_dp *mtk_dp, bool  bENABLE);
+void mhal_DPTx_SetScramble(struct mtk_dp *mtk_dp, bool  bENABLE);
+void mhal_DPTx_SetScramble_Type(struct mtk_dp *mtk_dp, bool bSelType);
+void mhal_DPTx_ShutDownDPTxPort(struct mtk_dp *mtk_dp);
+void mhal_DPTx_EnableFEC(struct mtk_dp *mtk_dp, bool bENABLE);
+void mhal_DPTx_EnableDSC(struct mtk_dp *mtk_dp, bool bENABLE);
+void mhal_DPTx_SetChunkSize(struct mtk_dp *mtk_dp,
+	BYTE slice_num, WORD chunk_num,
+	BYTE remainder, BYTE lane_count,
+	BYTE hde_last_num, BYTE hde_num_even);
+void mhal_DPTx_InitialSetting(struct mtk_dp *mtk_dp);
+void mhal_DPTx_Set_Efuse_Value(struct mtk_dp *mtk_dp);
+void mhal_DPTx_VideoMuteSW(struct mtk_dp *mtk_dp, bool bENABLE);
+void mhal_DPTx_VideoMute(struct mtk_dp *mtk_dp, bool bENABLE);
+void mhal_DPTx_AudioMute(struct mtk_dp *mtk_dp, bool bENABLE);
+void mhal_DPTx_SetFreeSync(struct mtk_dp *mtk_dp, bool bENABLE);
+void mhal_DPTx_Set_VideoInterlance(struct mtk_dp *mtk_dp, bool bENABLE);
+void mhal_DPTx_EnableBypassMSA(struct mtk_dp *mtk_dp, bool bENABLE);
+void mhal_DPTx_PGEnable(struct mtk_dp *mtk_dp, bool bENABLE);
+void mhal_DPTx_PG_Pure_Color(struct mtk_dp *mtk_dp, BYTE BGR, DWORD ColorDepth);
+void mhal_DPTx_PG_VerticalRamping(struct mtk_dp *mtk_dp, BYTE BGR,
+	DWORD ColorDepth, BYTE Location);
+void mhal_DPTx_PG_HorizontalRamping(struct mtk_dp *mtk_dp, BYTE BGR,
+	DWORD ColorDepth, BYTE Location);
+void mhal_DPTx_PG_VerticalColorBar(struct mtk_dp *mtk_dp, BYTE Location);
+void mhal_DPTx_PG_HorizontalColorBar(struct mtk_dp *mtk_dp, BYTE Location);
+void mhal_DPTx_PG_Chessboard(struct mtk_dp *mtk_dp, BYTE Location,
+	WORD Hde, WORD Vde);
+void mhal_DPTx_PG_SubPixel(struct mtk_dp *mtk_dp, BYTE Location);
+void mhal_DPTx_PG_Frame(struct mtk_dp *mtk_dp, BYTE Location,
+	WORD Hde, WORD Vde);
+void mhal_DPTx_Set_MVIDx2(struct mtk_dp *mtk_dp, bool bEnable);
+bool mhal_DPTx_OverWrite_MN(struct mtk_dp *mtk_dp,
+	bool bEnable, DWORD ulVideo_M, DWORD ulVideo_N);
+void mhal_DPTx_SetTU_SramRdStart(struct mtk_dp *mtk_dp, WORD uwValue);
+void mhal_DPTx_SetSDP_DownCntinitInHblanking(struct mtk_dp *mtk_dp,
+	WORD uwValue);
+void mhal_DPTx_SetSDP_DownCntinit(struct mtk_dp *mtk_dp, WORD uwValue);
+void mhal_DPTx_SetTU_SetEncoder(struct mtk_dp *mtk_dp);
+void mhal_DPTx_SetMSA(struct mtk_dp *mtk_dp);
+void mhal_DPTx_SetMISC(struct mtk_dp *mtk_dp, BYTE ucMISC[2]);
+void mhal_DPTx_SetColorDepth(struct mtk_dp *mtk_dp, BYTE coloer_depth);
+void mhal_DPTx_SetColorFormat(struct mtk_dp *mtk_dp, BYTE enOutColorFormat);
+void mhal_DPTx_SPKG_SDP(struct mtk_dp *mtk_dp, bool bEnable, BYTE ucSDPType,
+	BYTE *pHB, BYTE *pDB);
+void mhal_DPTx_SPKG_VSC_EXT_VESA(struct mtk_dp *mtk_dp, bool bEnable,
+	BYTE ucHDR_NUM, BYTE *pDB);
+void mhal_DPTx_SPKG_VSC_EXT_CEA(struct mtk_dp *mtk_dp, bool bEnable,
+	BYTE ucHDR_NUM, BYTE *pDB);
+BYTE mhal_DPTx_GetHPDIRQStatus(struct mtk_dp *mtk_dp);
+void mhal_DPTx_Audio_PG_EN(struct mtk_dp *mtk_dp, BYTE Channel, BYTE Fs,
+	BYTE bEnable);
+void mhal_DPTx_Audio_PG_EN(struct mtk_dp *mtk_dp, BYTE Channel, BYTE Fs,
+	BYTE bEnable);
+WORD mhal_DPTx_GetSWIRQStatus(struct mtk_dp *mtk_dp);
+void mhal_DPTx_Audio_Ch_Status_Set(struct mtk_dp *mtk_dp, BYTE Channel,
+	BYTE Fs, BYTE Wordlength);
+void mhal_DPTx_Audio_SDP_Setting(struct mtk_dp *mtk_dp, BYTE Channel);
+void mhal_DPTx_Audio_M_Divider_Setting(struct mtk_dp *mtk_dp, BYTE Div);
+void mhal_DPTx_SetTxRate(struct mtk_dp *mtk_dp, int Value);
+void mhal_DPTx_AnalogPowerOnOff(struct mtk_dp *mtk_dp, bool enable);
+void mhal_DPTx_DataLanePNSwap(struct mtk_dp *mtk_dp, bool bENABLE);
+
+#endif //__DRTX_HAL_H__
diff --git a/drivers/gpu/drm/mediatek/mtk_dp_hdcp.h b/drivers/gpu/drm/mediatek/mtk_dp_hdcp.h
new file mode 100644
index 0000000000000000000000000000000000000000..41b57185212eedc8701affbe2c3205a9277f4e93
--- /dev/null
+++ b/drivers/gpu/drm/mediatek/mtk_dp_hdcp.h
@@ -0,0 +1,56 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2019 MediaTek Inc.
+ */
+
+#ifndef __MTK_HDCP_H__
+#define __MTK_HDCP_H__
+
+#include <linux/types.h>
+
+
+#ifdef DPTX_HDCP_ENABLE
+
+struct HDCP1X_INFO {
+	int MainStates;
+	int SubStates;
+	unsigned char uRetryCount;
+	uint8_t bEnable:1;
+	uint8_t bRepeater:1;
+	uint8_t bR0Read:1;
+	uint8_t bKSV_READY:1;
+	uint8_t bMAX_CASCADE:1;
+	uint8_t bMAX_DEVS:1;
+	unsigned char ubBstatus;
+	unsigned char ubBksv[5];
+	unsigned char ubAksv[5];
+	unsigned char ubV[20];
+	unsigned char ubBinfo[2];
+	unsigned char ubKSVFIFO[5*127];
+	unsigned char ubDEVICE_COUNT;
+};
+
+struct HDCP2_INFO {
+	uint8_t bEnable:1;
+	uint8_t bRepeater:1;
+	uint8_t bReadcertrx:1;
+	uint8_t bReadHprime:1;
+	uint8_t bReadPairing:1;
+	uint8_t bReadLprime:1;
+	uint8_t bksExchangeDone:1;
+	uint8_t bReadVprime:1;
+	uint8_t uRetryCount;
+	uint8_t uDeviceCount;
+	uint8_t uStreamIDType;
+};
+
+enum HDCP_RESULT {
+	AUTH_ZERO     = 0,
+	AUTH_INIT     = 1,
+	AUTH_PASS     = 2,
+	AUTH_FAIL     = 3,
+};
+
+#endif
+#endif
+
diff --git a/drivers/gpu/drm/mediatek/mtk_dp_intf.c b/drivers/gpu/drm/mediatek/mtk_dp_intf.c
new file mode 100644
index 0000000000000000000000000000000000000000..801f1134d768aa7c69ffec7759ad4e6bb4a9d417
--- /dev/null
+++ b/drivers/gpu/drm/mediatek/mtk_dp_intf.c
@@ -0,0 +1,871 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Copyright (c) 2014 MediaTek Inc.
+ * Author: Jie Qiu <jie.qiu@mediatek.com>
+ */
+
+#include <linux/clk.h>
+#include <linux/component.h>
+#include <linux/interrupt.h>
+#include <linux/kernel.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_gpio.h>
+#include <linux/of_graph.h>
+#include <linux/platform_device.h>
+#include <linux/types.h>
+
+#include <video/videomode.h>
+
+#include <drm/drm_atomic_helper.h>
+#include <drm/drm_bridge.h>
+#include <drm/drm_bridge_connector.h>
+#include <drm/drm_crtc.h>
+#include <drm/drm_of.h>
+#include <drm/drm_simple_kms_helper.h>
+
+#include "mtk_disp_drv.h"
+#include "mtk_drm_ddp_comp.h"
+
+#define DPINTF_EN			0x00
+#define EN				BIT(0)
+
+#define DPINTF_RET			0x04
+#define RST				BIT(0)
+#define RST_SEL				BIT(16)
+
+#define DPINTF_INTEN		0x08
+#define INT_VSYNC_EN			BIT(0)
+#define INT_VDE_EN			BIT(1)
+#define INT_UNDERFLOW_EN		BIT(2)
+#define INT_TARGET_LINE_EN		BIT(3)
+
+#define DPINTF_INTSTA		0x0C
+#define INT_VSYNC_STA			BIT(0)
+#define INT_VDE_STA			BIT(1)
+#define INT_UNDERFLOW_STA		BIT(2)
+#define INT_TARGET_LINE_STA		BIT(3)
+
+#define DPINTF_CON			0x10
+#define BG_ENABLE			BIT(0)
+#define INTL_EN				BIT(2)
+#define TDFP_EN				BIT(3)
+#define VS_LODD_EN			BIT(16)
+#define VS_LEVEN_EN			BIT(17)
+#define VS_RODD_EN			BIT(18)
+#define VS_REVEN			BIT(19)
+#define FAKE_DE_LODD			BIT(20)
+#define FAKE_DE_LEVEN			BIT(21)
+#define FAKE_DE_RODD			BIT(22)
+#define FAKE_DE_REVEN			BIT(23)
+#define YUV422_EN			BIT(24)
+#define CLPF_EN				BIT(25)
+#define MATRIX_EN			BIT(26)
+#define INTERNAL_CG_EN			BIT(27)
+#define LOWPOWER_EN			BIT(28)
+#define INPUT_2P_EN			BIT(29)
+#define EXT_VSYNC_EN			BIT(30)
+
+#define DPINTF_OUTPUT_SETTING	0x14
+#define PIXEL_SWAP			BIT(0)
+#define CH_SWAP				BIT(1)
+#define CH_SWAP_MASK			(0x7 << 1)
+#define SWAP_RGB			(0x00 << 1)
+#define SWAP_GBR			(0x01 << 1)
+#define SWAP_BRG			(0x02 << 1)
+#define SWAP_RBG			(0x03 << 1)
+#define SWAP_GRB			(0x04 << 1)
+#define SWAP_BGR			(0x05 << 1)
+#define B_MASK				BIT(4)
+#define G_MASK				BIT(5)
+#define R_MASK				BIT(6)
+#define DE_MASK				BIT(8)
+#define HS_MASK				BIT(9)
+#define VS_MASK				BIT(10)
+#define HSYNC_POL			BIT(13)
+#define VSYNC_POL			BIT(14)
+#define OUT_BIT				BIT(16)
+#define OUT_BIT_MASK			(0x3 << 18)
+#define OUT_BIT_8			(0x00 << 18)
+#define OUT_BIT_10			(0x01 << 18)
+#define OUT_BIT_12			(0x02 << 18)
+#define OUT_BIT_16			(0x03 << 18)
+
+#define DPINTF_SIZE		0x18
+#define HSIZE				0
+#define HSIZE_MASK			(0xffff << 0)
+#define VSIZE				16
+#define VSIZE_MASK			(0xffff << 16)
+
+#define DPINTF_TGEN_HWIDTH		0x20
+#define HPW				0
+#define HPW_MASK			(0xffff << 0)
+
+#define DPINTF_TGEN_HPORCH		0x24
+#define HBP				0
+#define HBP_MASK			(0xffff << 0)
+#define HFP				16
+#define HFP_MASK			(0xffff << 16)
+
+#define DPINTF_TGEN_VWIDTH		0x28
+#define VSYNC_WIDTH_SHIFT		0
+#define VSYNC_WIDTH_MASK		(0xffff << 0)
+#define VSYNC_HALF_LINE_SHIFT		16
+#define VSYNC_HALF_LINE_MASK		BIT(16)
+
+
+#define DPINTF_TGEN_VPORCH		0x2C
+#define VSYNC_BACK_PORCH_SHIFT		0
+#define VSYNC_BACK_PORCH_MASK		(0xffff << 0)
+#define VSYNC_FRONT_PORCH_SHIFT		16
+#define VSYNC_FRONT_PORCH_MASK		(0xffff << 16)
+
+#define DPINTF_BG_HCNTL		0x30
+#define BG_RIGHT			(0xffff << 0)
+#define BG_LEFT				(0xffff << 16)
+
+#define DPINTF_BG_VCNTL		0x34
+#define BG_BOT				(0xffff << 0)
+#define BG_TOP				(0xffff << 16)
+
+#define DPINTF_BG_COLOR		0x38
+#define BG_B				(0x3ff << 0)
+#define BG_G				(0x3ff << 10)
+#define BG_R				(0x3ff << 20)
+
+#define DPINTF_FIFO_CTL		0x3C
+#define FIFO_VALID_SET			(0x1F << 0)
+#define FIFO_RST_SEL			BIT(8)
+#define FIFO_RD_MASK			BIT(12)
+
+#define DPINTF_STATUS		0x40
+#define VCOUNTER			(0x3ffff << 0)
+#define DPINTF_BUSY			BIT(24)
+#define FIELD				BIT(28)
+#define TDLR				BIT(29)
+
+#define DPINTF_TGEN_VWIDTH_LEVEN	0x68
+#define DPINTF_TGEN_VPORCH_LEVEN	0x6C
+#define DPINTF_TGEN_VWIDTH_RODD	0x70
+#define DPINTF_TGEN_VPORCH_RODD	0x74
+#define DPINTF_TGEN_VWIDTH_REVEN	0x78
+#define DPINTF_TGEN_VPORCH_REVEN	0x7C
+
+#define DPINTF_CLPF_SETTING	0x94
+#define CLPF_TYPE			(0x3 << 0)
+#define ROUND_EN			BIT(4)
+
+#define DPINTF_Y_LIMIT		0x98
+#define Y_LIMINT_BOT			0
+#define Y_LIMINT_BOT_MASK		(0xFFF << 0)
+#define Y_LIMINT_TOP			16
+#define Y_LIMINT_TOP_MASK		(0xFFF << 16)
+
+#define DPINTF_C_LIMIT		0x9C
+#define C_LIMIT_BOT			0
+#define C_LIMIT_BOT_MASK		(0xFFF << 0)
+#define C_LIMIT_TOP			16
+#define C_LIMIT_TOP_MASK		(0xFFF << 16)
+
+#define DPINTF_YUV422_SETTING	0xA0
+#define UV_SWAP				BIT(0)
+#define CR_DELSEL			BIT(4)
+#define CB_DELSEL			BIT(5)
+#define Y_DELSEL			BIT(6)
+#define DE_DELSEL			BIT(7)
+
+#define DPINTF_MATRIX_SET		0xB4
+#define INT_MATRIX_SEL_MASK	0x1f
+#define RGB_TO_JPEG			0x00
+#define RGB_TO_FULL709			0x01
+#define RGB_TO_BT601			0x02
+#define RGB_TO_BT709			0x03
+#define JPEG_TO_RGB			0x04
+#define FULL709_TO_RGB			0x05
+#define BT601_TO_RGB			0x06
+#define BT709_TO_RGB			0x07
+#define JPEG_TO_BT601			0x08
+#define JPEG_TO_BT709			0x09
+#define BT601_TO_JPEG			0xA
+#define BT709_TO_JPEG			0xB
+#define BT709_TO_BT601			0xC
+#define BT601_TO_BT709			0xD
+#define JPEG_TO_CERGB			0x14
+#define FULL709_TO_CERGB		0x15
+#define BT601_TO_CERGB			0x16
+#define BT709_TO_CERGB			0x17
+#define RGB_TO_CERGB			0x1C
+
+#define MATRIX_BIT_MASK	(0x3 << 8)
+#define EXT_MATRIX_EN	BIT(12)
+
+enum mtk_dpintf_out_bit_num {
+	MTK_DPINTF_OUT_BIT_NUM_8BITS,
+	MTK_DPINTF_OUT_BIT_NUM_10BITS,
+	MTK_DPINTF_OUT_BIT_NUM_12BITS,
+	MTK_DPINTF_OUT_BIT_NUM_16BITS
+};
+
+enum mtk_dpintf_out_yc_map {
+	MTK_DPINTF_OUT_YC_MAP_RGB,
+	MTK_DPINTF_OUT_YC_MAP_CYCY,
+	MTK_DPINTF_OUT_YC_MAP_YCYC,
+	MTK_DPINTF_OUT_YC_MAP_CY,
+	MTK_DPINTF_OUT_YC_MAP_YC
+};
+
+enum mtk_dpintf_out_channel_swap {
+	MTK_DPINTF_OUT_CHANNEL_SWAP_RGB,
+	MTK_DPINTF_OUT_CHANNEL_SWAP_GBR,
+	MTK_DPINTF_OUT_CHANNEL_SWAP_BRG,
+	MTK_DPINTF_OUT_CHANNEL_SWAP_RBG,
+	MTK_DPINTF_OUT_CHANNEL_SWAP_GRB,
+	MTK_DPINTF_OUT_CHANNEL_SWAP_BGR
+};
+
+enum mtk_dpintf_out_color_format {
+	MTK_DPINTF_COLOR_FORMAT_RGB,
+	MTK_DPINTF_COLOR_FORMAT_RGB_FULL,
+	MTK_DPINTF_COLOR_FORMAT_YCBCR_444,
+	MTK_DPINTF_COLOR_FORMAT_YCBCR_422,
+	MTK_DPINTF_COLOR_FORMAT_XV_YCC,
+	MTK_DPINTF_COLOR_FORMAT_YCBCR_444_FULL,
+	MTK_DPINTF_COLOR_FORMAT_YCBCR_422_FULL
+};
+
+enum TVDPLL_CLK {
+	TVDPLL_PLL = 0,
+	TVDPLL_D2 = 1,
+	TVDPLL_D4 = 2,
+	TVDPLL_D8 = 3,
+	TVDPLL_D16 = 4,
+};
+
+struct mtk_dpintf {
+	struct drm_encoder encoder;
+	struct drm_bridge bridge;
+	struct drm_bridge *next_bridge;
+	struct drm_connector *connector;
+	void __iomem *regs;
+	struct device *dev;
+	struct clk *hf_fmm_ck;
+	struct clk *hf_fdp_ck;
+	struct clk *pclk;
+	struct clk *pclk_src[5];
+	int irq;
+	struct drm_display_mode mode;
+	const struct mtk_dpintf_conf *conf;
+	enum mtk_dpintf_out_color_format color_format;
+	enum mtk_dpintf_out_yc_map yc_map;
+	enum mtk_dpintf_out_bit_num bit_num;
+	enum mtk_dpintf_out_channel_swap channel_swap;
+	int refcount;
+};
+
+static inline struct mtk_dpintf *bridge_to_dpintf(struct drm_bridge *b)
+{
+	return container_of(b, struct mtk_dpintf, bridge);
+}
+
+enum mtk_dpintf_polarity {
+	MTK_DPINTF_POLARITY_RISING,
+	MTK_DPINTF_POLARITY_FALLING,
+};
+
+struct mtk_dpintf_polarities {
+	enum mtk_dpintf_polarity de_pol;
+	enum mtk_dpintf_polarity ck_pol;
+	enum mtk_dpintf_polarity hsync_pol;
+	enum mtk_dpintf_polarity vsync_pol;
+};
+
+struct mtk_dpintf_sync_param {
+	u32 sync_width;
+	u32 front_porch;
+	u32 back_porch;
+	bool shift_half_line;
+};
+
+struct mtk_dpintf_yc_limit {
+	u16 y_top;
+	u16 y_bottom;
+	u16 c_top;
+	u16 c_bottom;
+};
+
+struct mtk_dpintf_conf {
+	unsigned int (*cal_factor)(int clock);
+	u32 reg_h_fre_con;
+	bool edge_sel_en;
+};
+
+static void mtk_dpintf_mask(struct mtk_dpintf *dpintf, u32 offset, u32 val, u32 mask)
+{
+	u32 tmp = readl(dpintf->regs + offset) & ~mask;
+
+	tmp |= (val & mask);
+	writel(tmp, dpintf->regs + offset);
+}
+
+static void mtk_dpintf_sw_reset(struct mtk_dpintf *dpintf, bool reset)
+{
+	mtk_dpintf_mask(dpintf, DPINTF_RET, reset ? RST : 0, RST);
+}
+
+static void mtk_dpintf_enable(struct mtk_dpintf *dpintf)
+{
+	mtk_dpintf_mask(dpintf, DPINTF_EN, EN, EN);
+}
+
+static void mtk_dpintf_disable(struct mtk_dpintf *dpintf)
+{
+	mtk_dpintf_mask(dpintf, DPINTF_EN, 0, EN);
+}
+
+static void mtk_dpintf_config_hsync(struct mtk_dpintf *dpintf,
+				 struct mtk_dpintf_sync_param *sync)
+{
+	mtk_dpintf_mask(dpintf, DPINTF_TGEN_HWIDTH,
+		     sync->sync_width << HPW, HPW_MASK);
+	mtk_dpintf_mask(dpintf, DPINTF_TGEN_HPORCH,
+		     sync->back_porch << HBP, HBP_MASK);
+	mtk_dpintf_mask(dpintf, DPINTF_TGEN_HPORCH, sync->front_porch << HFP,
+		     HFP_MASK);
+}
+
+static void mtk_dpintf_config_vsync(struct mtk_dpintf *dpintf,
+				 struct mtk_dpintf_sync_param *sync,
+				 u32 width_addr, u32 porch_addr)
+{
+	mtk_dpintf_mask(dpintf, width_addr,
+		     sync->sync_width << VSYNC_WIDTH_SHIFT,
+		     VSYNC_WIDTH_MASK);
+	mtk_dpintf_mask(dpintf, width_addr,
+		     sync->shift_half_line << VSYNC_HALF_LINE_SHIFT,
+		     VSYNC_HALF_LINE_MASK);
+	mtk_dpintf_mask(dpintf, porch_addr,
+		     sync->back_porch << VSYNC_BACK_PORCH_SHIFT,
+		     VSYNC_BACK_PORCH_MASK);
+	mtk_dpintf_mask(dpintf, porch_addr,
+		     sync->front_porch << VSYNC_FRONT_PORCH_SHIFT,
+		     VSYNC_FRONT_PORCH_MASK);
+}
+
+static void mtk_dpintf_config_vsync_lodd(struct mtk_dpintf *dpintf,
+				      struct mtk_dpintf_sync_param *sync)
+{
+	mtk_dpintf_config_vsync(dpintf, sync, DPINTF_TGEN_VWIDTH, DPINTF_TGEN_VPORCH);
+}
+
+static void mtk_dpintf_config_vsync_leven(struct mtk_dpintf *dpintf,
+				       struct mtk_dpintf_sync_param *sync)
+{
+	mtk_dpintf_config_vsync(dpintf, sync, DPINTF_TGEN_VWIDTH_LEVEN,
+			     DPINTF_TGEN_VPORCH_LEVEN);
+}
+
+static void mtk_dpintf_config_vsync_rodd(struct mtk_dpintf *dpintf,
+				      struct mtk_dpintf_sync_param *sync)
+{
+	mtk_dpintf_config_vsync(dpintf, sync, DPINTF_TGEN_VWIDTH_RODD,
+			     DPINTF_TGEN_VPORCH_RODD);
+}
+
+static void mtk_dpintf_config_vsync_reven(struct mtk_dpintf *dpintf,
+				       struct mtk_dpintf_sync_param *sync)
+{
+	mtk_dpintf_config_vsync(dpintf, sync, DPINTF_TGEN_VWIDTH_REVEN,
+			     DPINTF_TGEN_VPORCH_REVEN);
+}
+
+static void mtk_dpintf_config_pol(struct mtk_dpintf *dpintf,
+			       struct mtk_dpintf_polarities *dpintf_pol)
+{
+	unsigned int pol;
+
+	pol = (dpintf_pol->hsync_pol == MTK_DPINTF_POLARITY_RISING ? 0 : HSYNC_POL) |
+	      (dpintf_pol->vsync_pol == MTK_DPINTF_POLARITY_RISING ? 0 : VSYNC_POL);
+	mtk_dpintf_mask(dpintf, DPINTF_OUTPUT_SETTING, pol,
+		     HSYNC_POL | VSYNC_POL);
+}
+
+static void mtk_dpintf_config_3d(struct mtk_dpintf *dpintf, bool en_3d)
+{
+	mtk_dpintf_mask(dpintf, DPINTF_CON, en_3d ? TDFP_EN : 0, TDFP_EN);
+}
+
+static void mtk_dpintf_config_interface(struct mtk_dpintf *dpintf, bool inter)
+{
+	mtk_dpintf_mask(dpintf, DPINTF_CON, inter ? INTL_EN : 0, INTL_EN);
+}
+
+static void mtk_dpintf_config_fb_size(struct mtk_dpintf *dpintf, u32 width, u32 height)
+{
+	mtk_dpintf_mask(dpintf, DPINTF_SIZE, width << HSIZE, HSIZE_MASK);
+	mtk_dpintf_mask(dpintf, DPINTF_SIZE, height << VSIZE, VSIZE_MASK);
+}
+
+static void mtk_dpintf_config_channel_limit(struct mtk_dpintf *dpintf,
+					 struct mtk_dpintf_yc_limit *limit)
+{
+	mtk_dpintf_mask(dpintf, DPINTF_Y_LIMIT, limit->y_bottom << Y_LIMINT_BOT,
+		     Y_LIMINT_BOT_MASK);
+	mtk_dpintf_mask(dpintf, DPINTF_Y_LIMIT, limit->y_top << Y_LIMINT_TOP,
+		     Y_LIMINT_TOP_MASK);
+	mtk_dpintf_mask(dpintf, DPINTF_C_LIMIT, limit->c_bottom << C_LIMIT_BOT,
+		     C_LIMIT_BOT_MASK);
+	mtk_dpintf_mask(dpintf, DPINTF_C_LIMIT, limit->c_top << C_LIMIT_TOP,
+		     C_LIMIT_TOP_MASK);
+}
+
+static void mtk_dpintf_config_bit_num(struct mtk_dpintf *dpintf,
+				   enum mtk_dpintf_out_bit_num num)
+{
+	u32 val;
+
+	switch (num) {
+	case MTK_DPINTF_OUT_BIT_NUM_8BITS:
+		val = OUT_BIT_8;
+		break;
+	case MTK_DPINTF_OUT_BIT_NUM_10BITS:
+		val = OUT_BIT_10;
+		break;
+	case MTK_DPINTF_OUT_BIT_NUM_12BITS:
+		val = OUT_BIT_12;
+		break;
+	case MTK_DPINTF_OUT_BIT_NUM_16BITS:
+		val = OUT_BIT_16;
+		break;
+	default:
+		val = OUT_BIT_8;
+		break;
+	}
+	mtk_dpintf_mask(dpintf, DPINTF_OUTPUT_SETTING, val,
+		     OUT_BIT_MASK);
+}
+
+static void mtk_dpintf_config_channel_swap(struct mtk_dpintf *dpintf,
+					enum mtk_dpintf_out_channel_swap swap)
+{
+	u32 val;
+
+	switch (swap) {
+	case MTK_DPINTF_OUT_CHANNEL_SWAP_RGB:
+		val = SWAP_RGB;
+		break;
+	case MTK_DPINTF_OUT_CHANNEL_SWAP_GBR:
+		val = SWAP_GBR;
+		break;
+	case MTK_DPINTF_OUT_CHANNEL_SWAP_BRG:
+		val = SWAP_BRG;
+		break;
+	case MTK_DPINTF_OUT_CHANNEL_SWAP_RBG:
+		val = SWAP_RBG;
+		break;
+	case MTK_DPINTF_OUT_CHANNEL_SWAP_GRB:
+		val = SWAP_GRB;
+		break;
+	case MTK_DPINTF_OUT_CHANNEL_SWAP_BGR:
+		val = SWAP_BGR;
+		break;
+	default:
+		val = SWAP_RGB;
+		break;
+	}
+
+	mtk_dpintf_mask(dpintf, DPINTF_OUTPUT_SETTING, val, CH_SWAP_MASK);
+}
+
+static void mtk_dpintf_config_yuv422_enable(struct mtk_dpintf *dpintf, bool enable)
+{
+	mtk_dpintf_mask(dpintf, DPINTF_CON, enable ? YUV422_EN : 0, YUV422_EN);
+}
+
+static void mtk_dpintf_config_color_format(struct mtk_dpintf *dpintf,
+					enum mtk_dpintf_out_color_format format)
+{
+	if ((format == MTK_DPINTF_COLOR_FORMAT_YCBCR_444) ||
+	    (format == MTK_DPINTF_COLOR_FORMAT_YCBCR_444_FULL)) {
+		mtk_dpintf_config_yuv422_enable(dpintf, false);
+		mtk_dpintf_config_channel_swap(dpintf, MTK_DPINTF_OUT_CHANNEL_SWAP_BGR);
+	} else if ((format == MTK_DPINTF_COLOR_FORMAT_YCBCR_422) ||
+		   (format == MTK_DPINTF_COLOR_FORMAT_YCBCR_422_FULL)) {
+		mtk_dpintf_config_yuv422_enable(dpintf, true);
+		mtk_dpintf_config_channel_swap(dpintf, MTK_DPINTF_OUT_CHANNEL_SWAP_RGB);
+	} else {
+		mtk_dpintf_config_yuv422_enable(dpintf, false);
+		mtk_dpintf_config_channel_swap(dpintf, MTK_DPINTF_OUT_CHANNEL_SWAP_RGB);
+	}
+}
+
+static void mtk_dpintf_power_off(struct mtk_dpintf *dpintf)
+{
+	if (WARN_ON(dpintf->refcount == 0))
+		return;
+
+	if (--dpintf->refcount != 0)
+		return;
+
+	mtk_dpintf_disable(dpintf);
+	clk_disable_unprepare(dpintf->hf_fdp_ck);
+	clk_disable_unprepare(dpintf->hf_fmm_ck);
+	clk_disable_unprepare(dpintf->pclk);
+	clk_disable_unprepare(dpintf->pclk_src[TVDPLL_PLL]);
+}
+
+static int mtk_dpintf_power_on(struct mtk_dpintf *dpintf)
+{
+	int ret;
+	struct videomode vm = { 0 };
+	unsigned int clksrc = TVDPLL_D2;
+	unsigned long pll_rate;
+
+	pr_info("%s +", __func__);
+
+	drm_display_mode_to_videomode(&dpintf->mode, &vm);
+
+	if (++dpintf->refcount != 1) {
+
+		pr_info("%s -", __func__);
+		return 0;
+	}
+
+	if (vm.pixelclock < 70000000)
+		clksrc = TVDPLL_D16;
+	else if (vm.pixelclock < 200000000)
+		clksrc = TVDPLL_D8;
+	else
+		clksrc = TVDPLL_D4;
+
+	pll_rate = vm.pixelclock * (1 << clksrc);
+
+
+	clk_set_rate(dpintf->pclk_src[TVDPLL_PLL], pll_rate / 4);
+	clk_prepare_enable(dpintf->pclk_src[TVDPLL_PLL]);
+	clk_prepare_enable(dpintf->pclk);
+	clk_set_parent(dpintf->pclk, dpintf->pclk_src[clksrc]);
+
+	ret = clk_prepare_enable(dpintf->hf_fmm_ck);
+	if (ret < 0)
+		dev_err(dpintf->dev, "%s Failed to enable hf_fmm_ck clock: %d\n",
+			__func__, ret);
+	ret = clk_prepare_enable(dpintf->hf_fdp_ck);
+	if (ret < 0)
+		dev_err(dpintf->dev, "%s Failed to enable hf_fdp_ck clock: %d\n", __func__, ret);
+
+
+	pr_info("%s -", __func__);
+	return 0;
+
+//err_pixel:
+	clk_disable_unprepare(dpintf->hf_fdp_ck);
+	clk_disable_unprepare(dpintf->hf_fmm_ck);
+	clk_disable_unprepare(dpintf->pclk);
+	clk_disable_unprepare(dpintf->pclk_src[TVDPLL_PLL]);
+//err_refcount:
+	dpintf->refcount--;
+	return ret;
+}
+
+static int mtk_dpintf_set_display_mode(struct mtk_dpintf *dpintf,
+				    struct drm_display_mode *mode)
+{
+	struct mtk_dpintf_yc_limit limit;
+	struct mtk_dpintf_polarities dpintf_pol;
+	struct mtk_dpintf_sync_param hsync;
+	struct mtk_dpintf_sync_param vsync_lodd = { 0 };
+	struct mtk_dpintf_sync_param vsync_leven = { 0 };
+	struct mtk_dpintf_sync_param vsync_rodd = { 0 };
+	struct mtk_dpintf_sync_param vsync_reven = { 0 };
+	struct videomode vm = { 0 };
+
+	/* let pll_rate can fix the valid range of tvdpll (1G~2GHz) */
+	drm_display_mode_to_videomode(mode, &vm);
+
+	limit.c_bottom = 0x0000;
+	limit.c_top = 0xFFF;
+	limit.y_bottom = 0x0000;
+	limit.y_top = 0xFFF;
+
+	dpintf_pol.ck_pol = MTK_DPINTF_POLARITY_FALLING;
+	dpintf_pol.de_pol = MTK_DPINTF_POLARITY_RISING;
+	dpintf_pol.hsync_pol = vm.flags & DISPLAY_FLAGS_HSYNC_HIGH ?
+			    MTK_DPINTF_POLARITY_FALLING : MTK_DPINTF_POLARITY_RISING;
+	dpintf_pol.vsync_pol = vm.flags & DISPLAY_FLAGS_VSYNC_HIGH ?
+			    MTK_DPINTF_POLARITY_FALLING : MTK_DPINTF_POLARITY_RISING;
+	hsync.sync_width = vm.hsync_len / 4;
+	hsync.back_porch = vm.hback_porch / 4;
+	hsync.front_porch = vm.hfront_porch / 4;
+	hsync.shift_half_line = false;
+	vsync_lodd.sync_width = vm.vsync_len;
+	vsync_lodd.back_porch = vm.vback_porch;
+	vsync_lodd.front_porch = vm.vfront_porch;
+	vsync_lodd.shift_half_line = false;
+
+	if (vm.flags & DISPLAY_FLAGS_INTERLACED &&
+	    mode->flags & DRM_MODE_FLAG_3D_MASK) {
+		vsync_leven = vsync_lodd;
+		vsync_rodd = vsync_lodd;
+		vsync_reven = vsync_lodd;
+		vsync_leven.shift_half_line = true;
+		vsync_reven.shift_half_line = true;
+	} else if (vm.flags & DISPLAY_FLAGS_INTERLACED &&
+		   !(mode->flags & DRM_MODE_FLAG_3D_MASK)) {
+		vsync_leven = vsync_lodd;
+		vsync_leven.shift_half_line = true;
+	} else if (!(vm.flags & DISPLAY_FLAGS_INTERLACED) &&
+		   mode->flags & DRM_MODE_FLAG_3D_MASK) {
+		vsync_rodd = vsync_lodd;
+	}
+	mtk_dpintf_sw_reset(dpintf, true);
+	mtk_dpintf_config_pol(dpintf, &dpintf_pol);
+
+	mtk_dpintf_config_hsync(dpintf, &hsync);
+	mtk_dpintf_config_vsync_lodd(dpintf, &vsync_lodd);
+	mtk_dpintf_config_vsync_rodd(dpintf, &vsync_rodd);
+	mtk_dpintf_config_vsync_leven(dpintf, &vsync_leven);
+	mtk_dpintf_config_vsync_reven(dpintf, &vsync_reven);
+
+	mtk_dpintf_config_3d(dpintf, !!(mode->flags & DRM_MODE_FLAG_3D_MASK));
+	mtk_dpintf_config_interface(dpintf, !!(vm.flags &
+					 DISPLAY_FLAGS_INTERLACED));
+	if (vm.flags & DISPLAY_FLAGS_INTERLACED)
+		mtk_dpintf_config_fb_size(dpintf, vm.hactive, vm.vactive >> 1);
+	else
+		mtk_dpintf_config_fb_size(dpintf, vm.hactive, vm.vactive);
+
+	mtk_dpintf_config_channel_limit(dpintf, &limit);
+	mtk_dpintf_config_bit_num(dpintf, dpintf->bit_num);
+	mtk_dpintf_config_channel_swap(dpintf, dpintf->channel_swap);
+	mtk_dpintf_config_color_format(dpintf, dpintf->color_format);
+
+	mtk_dpintf_mask(dpintf, DPINTF_CON, INPUT_2P_EN, INPUT_2P_EN);
+	mtk_dpintf_sw_reset(dpintf, false);
+
+	mtk_dpintf_enable(dpintf);
+
+	return 0;
+}
+
+static int mtk_dpintf_bridge_attach(struct drm_bridge *bridge,
+				 enum drm_bridge_attach_flags flags)
+{
+	struct mtk_dpintf *dpintf = bridge_to_dpintf(bridge);
+
+	return drm_bridge_attach(bridge->encoder, dpintf->next_bridge,
+				 &dpintf->bridge, DRM_BRIDGE_ATTACH_NO_CONNECTOR);
+}
+
+static void mtk_dpintf_bridge_mode_set(struct drm_bridge *bridge,
+				const struct drm_display_mode *mode,
+				const struct drm_display_mode *adjusted_mode)
+{
+	struct mtk_dpintf *dpintf = bridge_to_dpintf(bridge);
+
+	drm_mode_copy(&dpintf->mode, adjusted_mode);
+}
+
+static void mtk_dpintf_bridge_disable(struct drm_bridge *bridge)
+{
+	struct mtk_dpintf *dpintf = bridge_to_dpintf(bridge);
+
+	mtk_dpintf_power_off(dpintf);
+}
+
+static void mtk_dpintf_bridge_enable(struct drm_bridge *bridge)
+{
+	struct mtk_dpintf *dpintf = bridge_to_dpintf(bridge);
+
+	pr_info("%s +", __func__);
+
+	mtk_dpintf_power_on(dpintf);
+	mtk_dpintf_set_display_mode(dpintf, &dpintf->mode);
+	pr_info("%s -", __func__);
+}
+
+static const struct drm_bridge_funcs mtk_dpintf_bridge_funcs = {
+	.attach = mtk_dpintf_bridge_attach,
+	.mode_set = mtk_dpintf_bridge_mode_set,
+	.disable = mtk_dpintf_bridge_disable,
+	.enable = mtk_dpintf_bridge_enable,
+};
+
+void mtk_dpintf_start(struct device *dev)
+{
+	struct mtk_dpintf *dpintf = dev_get_drvdata(dev);
+
+	pr_info("%s +", __func__);
+
+	mtk_dpintf_power_on(dpintf);
+
+	pr_info("%s -", __func__);
+}
+
+void mtk_dpintf_stop(struct device *dev)
+{
+	struct mtk_dpintf *dpintf = dev_get_drvdata(dev);
+
+	mtk_dpintf_power_off(dpintf);
+}
+
+int mtk_dpintf_encoder_index(struct device *dev)
+{
+	struct mtk_dpintf *dpintf = dev_get_drvdata(dev);
+	int encoder_index = drm_encoder_index(&dpintf->encoder);
+
+	dev_dbg(dev, "encoder index:%d", encoder_index);
+	return encoder_index;
+}
+
+static int mtk_dpintf_bind(struct device *dev, struct device *master, void *data)
+{
+	struct mtk_dpintf *dpintf = dev_get_drvdata(dev);
+	struct drm_device *drm_dev = data;
+	int ret;
+
+	ret = drm_simple_encoder_init(drm_dev, &dpintf->encoder,
+				      DRM_MODE_ENCODER_TMDS);
+	if (ret) {
+		dev_err(dev, "Failed to initialize decoder: %d\n", ret);
+		return ret;
+	}
+
+	dpintf->encoder.possible_crtcs = mtk_drm_find_possible_crtc_by_comp(drm_dev, dpintf->dev);
+
+	ret = drm_bridge_attach(&dpintf->encoder, &dpintf->bridge, NULL, DRM_BRIDGE_ATTACH_NO_CONNECTOR);
+	if (ret) {
+		dev_err(dev, "Failed to attach bridge: %d\n", ret);
+		goto err_cleanup;
+	}
+
+	dpintf->connector = drm_bridge_connector_init(drm_dev, &dpintf->encoder);
+	if (IS_ERR(dpintf->connector)) {
+		dev_err(dev, "Unable to create bridge connector\n");
+		ret = PTR_ERR(dpintf->connector);
+		goto err_cleanup;
+	}
+	drm_connector_attach_encoder(dpintf->connector, &dpintf->encoder);
+
+	dpintf->bit_num = MTK_DPINTF_OUT_BIT_NUM_8BITS;
+	dpintf->channel_swap = MTK_DPINTF_OUT_CHANNEL_SWAP_RGB;
+	dpintf->yc_map = MTK_DPINTF_OUT_YC_MAP_RGB;
+	dpintf->color_format = MTK_DPINTF_COLOR_FORMAT_RGB;
+
+	return 0;
+
+err_cleanup:
+	drm_encoder_cleanup(&dpintf->encoder);
+	return ret;
+}
+
+static void mtk_dpintf_unbind(struct device *dev, struct device *master,
+			   void *data)
+{
+	struct mtk_dpintf *dpintf = dev_get_drvdata(dev);
+
+	drm_encoder_cleanup(&dpintf->encoder);
+}
+
+static const struct component_ops mtk_dpintf_component_ops = {
+	.bind = mtk_dpintf_bind,
+	.unbind = mtk_dpintf_unbind,
+};
+
+static int mtk_dpintf_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct mtk_dpintf *dpintf;
+	struct resource *mem;
+	int ret;
+
+	dpintf = devm_kzalloc(dev, sizeof(*dpintf), GFP_KERNEL);
+	if (!dpintf)
+		return -ENOMEM;
+
+	dpintf->dev = dev;
+
+	mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	dpintf->regs = devm_ioremap_resource(dev, mem);
+	if (IS_ERR(dpintf->regs)) {
+		ret = PTR_ERR(dpintf->regs);
+		dev_err(dev, "Failed to ioremap mem resource: %d\n", ret);
+		return ret;
+	}
+
+	/* Get dp intf clk
+	 * Input pixel clock(hf_fmm_ck) frequency needs to be > hf_fdp_ck * 4
+	 * Otherwise FIFO will underflow
+	 */
+	dpintf->hf_fmm_ck = devm_clk_get(dev, "hf_fmm_ck");
+	if (IS_ERR(dpintf->hf_fmm_ck)) {
+		ret = PTR_ERR(dpintf->hf_fmm_ck);
+		dev_err(dev, "Failed to get hf_fmm_ck clock: %d\n", ret);
+		return ret;
+	}
+	dpintf->hf_fdp_ck = devm_clk_get(dev, "hf_fdp_ck");
+	if (IS_ERR(dpintf->hf_fdp_ck)) {
+		ret = PTR_ERR(dpintf->hf_fdp_ck);
+		dev_err(dev, "Failed to get hf_fdp_ck clock: %d\n", ret);
+		return ret;
+	}
+
+	dpintf->pclk = devm_clk_get(dev, "MUX_DP");
+	dpintf->pclk_src[0] = devm_clk_get(dev, "DPI_CK");
+	dpintf->pclk_src[1] = devm_clk_get(dev, "TVDPLL_D2");
+	dpintf->pclk_src[2] = devm_clk_get(dev, "TVDPLL_D4");
+	dpintf->pclk_src[3] = devm_clk_get(dev, "TVDPLL_D8");
+	dpintf->pclk_src[4] = devm_clk_get(dev, "TVDPLL_D16");
+
+	dpintf->irq = platform_get_irq(pdev, 0);
+	if (dpintf->irq <= 0) {
+		dev_err(dev, "Failed to get irq: %d\n", dpintf->irq);
+		return -EINVAL;
+	}
+
+	ret = drm_of_find_panel_or_bridge(dev->of_node, 0, 0,
+					  NULL, &dpintf->next_bridge);
+	if (ret)
+		return ret;
+
+	platform_set_drvdata(pdev, dpintf);
+
+	dpintf->bridge.funcs = &mtk_dpintf_bridge_funcs;
+	dpintf->bridge.of_node = dev->of_node;
+	dpintf->bridge.type = DRM_MODE_CONNECTOR_DPI;
+
+	drm_bridge_add(&dpintf->bridge);
+
+	ret = component_add(dev, &mtk_dpintf_component_ops);
+	if (ret) {
+		drm_bridge_remove(&dpintf->bridge);
+		dev_err(dev, "Failed to add component: %d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int mtk_dpintf_remove(struct platform_device *pdev)
+{
+	struct mtk_dpintf *dpintf = platform_get_drvdata(pdev);
+
+	component_del(&pdev->dev, &mtk_dpintf_component_ops);
+	drm_bridge_remove(&dpintf->bridge);
+
+	return 0;
+}
+
+static const struct of_device_id mtk_dpintf_of_ids[] = {
+	{ .compatible = "mediatek,mt8195-dpintf" },
+	{ },
+};
+
+struct platform_driver mtk_dpintf_driver = {
+	.probe = mtk_dpintf_probe,
+	.remove = mtk_dpintf_remove,
+	.driver = {
+		.name = "mediatek-dpintf",
+		.of_match_table = mtk_dpintf_of_ids,
+	},
+};
+
diff --git a/drivers/gpu/drm/mediatek/mtk_dp_reg.h b/drivers/gpu/drm/mediatek/mtk_dp_reg.h
new file mode 100644
index 0000000000000000000000000000000000000000..3640a02abf8d1c43de7e425f4351444d7b747292
--- /dev/null
+++ b/drivers/gpu/drm/mediatek/mtk_dp_reg.h
@@ -0,0 +1,4780 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2019 MediaTek Inc.
+ */
+
+#ifndef __MTK_DRTX_REG_H__
+#define __MTK_DRTX_REG_H__
+
+#define TOP_OFFSET		(0x2000)
+#define ENC0_OFFSET		(0x3000)
+#define ENC1_OFFSET		(0x3200)
+#define TRANS_OFFSET		(0x3400)
+#define AUX_OFFSET		(0x3600)
+#define SEC_OFFSET		(0x4000)
+
+#define REG_3000_DP_ENCODER0_P0              (0x3000)
+#define LANE_NUM_DP_ENCODER0_P0_FLDMASK                                 0x3
+#define LANE_NUM_DP_ENCODER0_P0_FLDMASK_POS                             0
+#define LANE_NUM_DP_ENCODER0_P0_FLDMASK_LEN                             2
+
+#define VIDEO_MUTE_SW_DP_ENCODER0_P0_FLDMASK                            0x4
+#define VIDEO_MUTE_SW_DP_ENCODER0_P0_FLDMASK_POS                        2
+#define VIDEO_MUTE_SW_DP_ENCODER0_P0_FLDMASK_LEN                        1
+
+#define VIDEO_MUTE_SEL_DP_ENCODER0_P0_FLDMASK                           0x8
+#define VIDEO_MUTE_SEL_DP_ENCODER0_P0_FLDMASK_POS                       3
+#define VIDEO_MUTE_SEL_DP_ENCODER0_P0_FLDMASK_LEN                       1
+
+#define ENHANCED_FRAME_EN_DP_ENCODER0_P0_FLDMASK                        0x10
+#define ENHANCED_FRAME_EN_DP_ENCODER0_P0_FLDMASK_POS                    4
+#define ENHANCED_FRAME_EN_DP_ENCODER0_P0_FLDMASK_LEN                    1
+
+#define HDCP_FRAME_EN_DP_ENCODER0_P0_FLDMASK                            0x20
+#define HDCP_FRAME_EN_DP_ENCODER0_P0_FLDMASK_POS                        5
+#define HDCP_FRAME_EN_DP_ENCODER0_P0_FLDMASK_LEN                        1
+
+#define IDP_EN_DP_ENCODER0_P0_FLDMASK                                   0x40
+#define IDP_EN_DP_ENCODER0_P0_FLDMASK_POS                               6
+#define IDP_EN_DP_ENCODER0_P0_FLDMASK_LEN                               1
+
+#define BS_SYMBOL_CNT_RESET_DP_ENCODER0_P0_FLDMASK                      0x80
+#define BS_SYMBOL_CNT_RESET_DP_ENCODER0_P0_FLDMASK_POS                  7
+#define BS_SYMBOL_CNT_RESET_DP_ENCODER0_P0_FLDMASK_LEN                  1
+
+#define MIXER_DUMMY_DATA_DP_ENCODER0_P0_FLDMASK                         0xff00
+#define MIXER_DUMMY_DATA_DP_ENCODER0_P0_FLDMASK_POS                     8
+#define MIXER_DUMMY_DATA_DP_ENCODER0_P0_FLDMASK_LEN                     8
+
+#define REG_3004_DP_ENCODER0_P0              (0x3004)
+#define MIXER_STUFF_DUMMY_DATA_DP_ENCODER0_P0_FLDMASK                   0xff
+#define MIXER_STUFF_DUMMY_DATA_DP_ENCODER0_P0_FLDMASK_POS               0
+#define MIXER_STUFF_DUMMY_DATA_DP_ENCODER0_P0_FLDMASK_LEN               8
+
+#define VIDEO_M_CODE_SEL_DP_ENCODER0_P0_FLDMASK                         0x100
+#define VIDEO_M_CODE_SEL_DP_ENCODER0_P0_FLDMASK_POS                     8
+#define VIDEO_M_CODE_SEL_DP_ENCODER0_P0_FLDMASK_LEN                     1
+
+#define DP_TX_ENCODER_4P_RESET_SW_DP_ENCODER0_P0_FLDMASK                0x200
+#define DP_TX_ENCODER_4P_RESET_SW_DP_ENCODER0_P0_FLDMASK_POS            9
+#define DP_TX_ENCODER_4P_RESET_SW_DP_ENCODER0_P0_FLDMASK_LEN            1
+
+#define MIXER_RESET_SW_DP_ENCODER0_P0_FLDMASK                           0x400
+#define MIXER_RESET_SW_DP_ENCODER0_P0_FLDMASK_POS                       10
+#define MIXER_RESET_SW_DP_ENCODER0_P0_FLDMASK_LEN                       1
+
+#define VIDEO_RESET_SW_DP_ENCODER0_P0_FLDMASK                           0x800
+#define VIDEO_RESET_SW_DP_ENCODER0_P0_FLDMASK_POS                       11
+#define VIDEO_RESET_SW_DP_ENCODER0_P0_FLDMASK_LEN                       1
+
+#define VIDEO_PATTERN_GEN_RESET_SW_DP_ENCODER0_P0_FLDMASK               0x1000
+#define VIDEO_PATTERN_GEN_RESET_SW_DP_ENCODER0_P0_FLDMASK_POS           12
+#define VIDEO_PATTERN_GEN_RESET_SW_DP_ENCODER0_P0_FLDMASK_LEN           1
+
+#define SDP_RESET_SW_DP_ENCODER0_P0_FLDMASK                             0x2000
+#define SDP_RESET_SW_DP_ENCODER0_P0_FLDMASK_POS                         13
+#define SDP_RESET_SW_DP_ENCODER0_P0_FLDMASK_LEN                         1
+
+#define DP_TX_MUX_DP_ENCODER0_P0_FLDMASK                                0x4000
+#define DP_TX_MUX_DP_ENCODER0_P0_FLDMASK_POS                            14
+#define DP_TX_MUX_DP_ENCODER0_P0_FLDMASK_LEN                            1
+
+#define MIXER_FSM_RESET_DP_ENCODER0_P0_FLDMASK                          0x8000
+#define MIXER_FSM_RESET_DP_ENCODER0_P0_FLDMASK_POS                      15
+#define MIXER_FSM_RESET_DP_ENCODER0_P0_FLDMASK_LEN                      1
+
+#define REG_3008_DP_ENCODER0_P0              (0x3008)
+#define VIDEO_M_CODE_SW_0_DP_ENCODER0_P0_FLDMASK                        0xffff
+#define VIDEO_M_CODE_SW_0_DP_ENCODER0_P0_FLDMASK_POS                    0
+#define VIDEO_M_CODE_SW_0_DP_ENCODER0_P0_FLDMASK_LEN                    16
+
+#define REG_300C_DP_ENCODER0_P0              (0x300C)
+#define VIDEO_M_CODE_SW_1_DP_ENCODER0_P0_FLDMASK                        0xff
+#define VIDEO_M_CODE_SW_1_DP_ENCODER0_P0_FLDMASK_POS                    0
+#define VIDEO_M_CODE_SW_1_DP_ENCODER0_P0_FLDMASK_LEN                    8
+
+#define VIDEO_M_CODE_PULSE_DP_ENCODER0_P0_FLDMASK                       0x100
+#define VIDEO_M_CODE_PULSE_DP_ENCODER0_P0_FLDMASK_POS                   8
+#define VIDEO_M_CODE_PULSE_DP_ENCODER0_P0_FLDMASK_LEN                   1
+
+#define COMPRESSEDSTREAM_FLAG_DP_ENCODER0_P0_FLDMASK                    0x200
+#define COMPRESSEDSTREAM_FLAG_DP_ENCODER0_P0_FLDMASK_POS                9
+#define COMPRESSEDSTREAM_FLAG_DP_ENCODER0_P0_FLDMASK_LEN                1
+
+#define SDP_SPLIT_EN_DP_ENCODER0_P0_FLDMASK                             0x400
+#define SDP_SPLIT_EN_DP_ENCODER0_P0_FLDMASK_POS                         10
+#define SDP_SPLIT_EN_DP_ENCODER0_P0_FLDMASK_LEN                         1
+
+#define SDP_SPLIT_FIFO_RST_DP_ENCODER0_P0_FLDMASK                       0x800
+#define SDP_SPLIT_FIFO_RST_DP_ENCODER0_P0_FLDMASK_POS                   11
+#define SDP_SPLIT_FIFO_RST_DP_ENCODER0_P0_FLDMASK_LEN                   1
+
+#define VIDEO_M_CODE_MULT_DIV_SEL_DP_ENCODER0_P0_FLDMASK                0x7000
+#define VIDEO_M_CODE_MULT_DIV_SEL_DP_ENCODER0_P0_FLDMASK_POS            12
+#define VIDEO_M_CODE_MULT_DIV_SEL_DP_ENCODER0_P0_FLDMASK_LEN            3
+
+#define SDP_AUDIO_ONE_SAMPLE_MODE_DP_ENCODER0_P0_FLDMASK                0x8000
+#define SDP_AUDIO_ONE_SAMPLE_MODE_DP_ENCODER0_P0_FLDMASK_POS            15
+#define SDP_AUDIO_ONE_SAMPLE_MODE_DP_ENCODER0_P0_FLDMASK_LEN            1
+
+#define REG_3010_DP_ENCODER0_P0              (0x3010)
+#define HTOTAL_SW_DP_ENCODER0_P0_FLDMASK                                0xffff
+#define HTOTAL_SW_DP_ENCODER0_P0_FLDMASK_POS                            0
+#define HTOTAL_SW_DP_ENCODER0_P0_FLDMASK_LEN                            16
+
+#define REG_3014_DP_ENCODER0_P0              (0x3014)
+#define VTOTAL_SW_DP_ENCODER0_P0_FLDMASK                                0xffff
+#define VTOTAL_SW_DP_ENCODER0_P0_FLDMASK_POS                            0
+#define VTOTAL_SW_DP_ENCODER0_P0_FLDMASK_LEN                            16
+
+#define REG_3018_DP_ENCODER0_P0              (0x3018)
+#define HSTART_SW_DP_ENCODER0_P0_FLDMASK                                0xffff
+#define HSTART_SW_DP_ENCODER0_P0_FLDMASK_POS                            0
+#define HSTART_SW_DP_ENCODER0_P0_FLDMASK_LEN                            16
+
+#define REG_301C_DP_ENCODER0_P0              (0x301C)
+#define VSTART_SW_DP_ENCODER0_P0_FLDMASK                                0xffff
+#define VSTART_SW_DP_ENCODER0_P0_FLDMASK_POS                            0
+#define VSTART_SW_DP_ENCODER0_P0_FLDMASK_LEN                            16
+
+#define REG_3020_DP_ENCODER0_P0              (0x3020)
+#define HWIDTH_SW_DP_ENCODER0_P0_FLDMASK                                0xffff
+#define HWIDTH_SW_DP_ENCODER0_P0_FLDMASK_POS                            0
+#define HWIDTH_SW_DP_ENCODER0_P0_FLDMASK_LEN                            16
+
+#define REG_3024_DP_ENCODER0_P0              (0x3024)
+#define VHEIGHT_SW_DP_ENCODER0_P0_FLDMASK                               0xffff
+#define VHEIGHT_SW_DP_ENCODER0_P0_FLDMASK_POS                           0
+#define VHEIGHT_SW_DP_ENCODER0_P0_FLDMASK_LEN                           16
+
+#define REG_3028_DP_ENCODER0_P0              (0x3028)
+#define HSW_SW_DP_ENCODER0_P0_FLDMASK                                   0x7fff
+#define HSW_SW_DP_ENCODER0_P0_FLDMASK_POS                               0
+#define HSW_SW_DP_ENCODER0_P0_FLDMASK_LEN                               15
+
+#define HSP_SW_DP_ENCODER0_P0_FLDMASK                                   0x8000
+#define HSP_SW_DP_ENCODER0_P0_FLDMASK_POS                               15
+#define HSP_SW_DP_ENCODER0_P0_FLDMASK_LEN                               1
+
+#define REG_302C_DP_ENCODER0_P0              (0x302C)
+#define VSW_SW_DP_ENCODER0_P0_FLDMASK                                   0x7fff
+#define VSW_SW_DP_ENCODER0_P0_FLDMASK_POS                               0
+#define VSW_SW_DP_ENCODER0_P0_FLDMASK_LEN                               15
+
+#define VSP_SW_DP_ENCODER0_P0_FLDMASK                                   0x8000
+#define VSP_SW_DP_ENCODER0_P0_FLDMASK_POS                               15
+#define VSP_SW_DP_ENCODER0_P0_FLDMASK_LEN                               1
+
+#define REG_3030_DP_ENCODER0_P0              (0x3030)
+#define HTOTAL_SEL_DP_ENCODER0_P0_FLDMASK                               0x1
+#define HTOTAL_SEL_DP_ENCODER0_P0_FLDMASK_POS                           0
+#define HTOTAL_SEL_DP_ENCODER0_P0_FLDMASK_LEN                           1
+
+#define VTOTAL_SEL_DP_ENCODER0_P0_FLDMASK                               0x2
+#define VTOTAL_SEL_DP_ENCODER0_P0_FLDMASK_POS                           1
+#define VTOTAL_SEL_DP_ENCODER0_P0_FLDMASK_LEN                           1
+
+#define HSTART_SEL_DP_ENCODER0_P0_FLDMASK                               0x4
+#define HSTART_SEL_DP_ENCODER0_P0_FLDMASK_POS                           2
+#define HSTART_SEL_DP_ENCODER0_P0_FLDMASK_LEN                           1
+
+#define VSTART_SEL_DP_ENCODER0_P0_FLDMASK                               0x8
+#define VSTART_SEL_DP_ENCODER0_P0_FLDMASK_POS                           3
+#define VSTART_SEL_DP_ENCODER0_P0_FLDMASK_LEN                           1
+
+#define HWIDTH_SEL_DP_ENCODER0_P0_FLDMASK                               0x10
+#define HWIDTH_SEL_DP_ENCODER0_P0_FLDMASK_POS                           4
+#define HWIDTH_SEL_DP_ENCODER0_P0_FLDMASK_LEN                           1
+
+#define VHEIGHT_SEL_DP_ENCODER0_P0_FLDMASK                              0x20
+#define VHEIGHT_SEL_DP_ENCODER0_P0_FLDMASK_POS                          5
+#define VHEIGHT_SEL_DP_ENCODER0_P0_FLDMASK_LEN                          1
+
+#define HSP_SEL_DP_ENCODER0_P0_FLDMASK                                  0x40
+#define HSP_SEL_DP_ENCODER0_P0_FLDMASK_POS                              6
+#define HSP_SEL_DP_ENCODER0_P0_FLDMASK_LEN                              1
+
+#define HSW_SEL_DP_ENCODER0_P0_FLDMASK                                  0x80
+#define HSW_SEL_DP_ENCODER0_P0_FLDMASK_POS                              7
+#define HSW_SEL_DP_ENCODER0_P0_FLDMASK_LEN                              1
+
+#define VSP_SEL_DP_ENCODER0_P0_FLDMASK                                  0x100
+#define VSP_SEL_DP_ENCODER0_P0_FLDMASK_POS                              8
+#define VSP_SEL_DP_ENCODER0_P0_FLDMASK_LEN                              1
+
+#define VSW_SEL_DP_ENCODER0_P0_FLDMASK                                  0x200
+#define VSW_SEL_DP_ENCODER0_P0_FLDMASK_POS                              9
+#define VSW_SEL_DP_ENCODER0_P0_FLDMASK_LEN                              1
+
+#define TX_VBID_SW_EN_DP_ENCODER0_P0_FLDMASK                            0x400
+#define TX_VBID_SW_EN_DP_ENCODER0_P0_FLDMASK_POS                        10
+#define TX_VBID_SW_EN_DP_ENCODER0_P0_FLDMASK_LEN                        1
+
+#define VBID_AUDIO_MUTE_FLAG_SW_DP_ENCODER0_P0_FLDMASK                  0x800
+#define VBID_AUDIO_MUTE_SW_DP_ENCODER0_P0_FLDMASK_POS                   11
+#define VBID_AUDIO_MUTE_FLAG_SW_DP_ENCODER0_P0_FLDMASK_LEN              1
+
+#define VBID_AUDIO_MUTE_FLAG_SEL_DP_ENCODER0_P0_FLDMASK                 0x1000
+#define VBID_AUDIO_MUTE_SEL_DP_ENCODER0_P0_FLDMASK_POS                  12
+#define VBID_AUDIO_MUTE_FLAG_SEL_DP_ENCODER0_P0_FLDMASK_LEN             1
+
+#define VBID_INTERLACE_FLAG_SW_DP_ENCODER0_P0_FLDMASK                   0x2000
+#define VBID_INTERLACE_FLAG_SW_DP_ENCODER0_P0_FLDMASK_POS               13
+#define VBID_INTERLACE_FLAG_SW_DP_ENCODER0_P0_FLDMASK_LEN               1
+
+#define VBID_INTERLACE_FLAG_SEL_DP_ENCODER0_P0_FLDMASK                  0x4000
+#define VBID_INTERLACE_FLAG_SEL_DP_ENCODER0_P0_FLDMASK_POS              14
+#define VBID_INTERLACE_FLAG_SEL_DP_ENCODER0_P0_FLDMASK_LEN              1
+
+#define MIXER_SDP_EN_DP_ENCODER0_P0_FLDMASK                             0x8000
+#define MIXER_SDP_EN_DP_ENCODER0_P0_FLDMASK_POS                         15
+#define MIXER_SDP_EN_DP_ENCODER0_P0_FLDMASK_LEN                         1
+
+#define REG_3034_DP_ENCODER0_P0              (0x3034)
+#define MISC0_DATA_DP_ENCODER0_P0_FLDMASK                               0xff
+#define MISC0_DATA_DP_ENCODER0_P0_FLDMASK_POS                           0
+#define MISC0_DATA_DP_ENCODER0_P0_FLDMASK_LEN                           8
+
+#define MISC1_DATA_DP_ENCODER0_P0_FLDMASK                               0xff00
+#define MISC1_DATA_DP_ENCODER0_P0_FLDMASK_POS                           8
+#define MISC1_DATA_DP_ENCODER0_P0_FLDMASK_LEN                           8
+
+#define REG_3038_DP_ENCODER0_P0              (0x3038)
+#define TX_VBID_SW_DP_ENCODER0_P0_FLDMASK                               0xff
+#define TX_VBID_SW_DP_ENCODER0_P0_FLDMASK_POS                           0
+#define TX_VBID_SW_DP_ENCODER0_P0_FLDMASK_LEN                           8
+
+#define VIDEO_DATA_SWAP_DP_ENCODER0_P0_FLDMASK                          0x700
+#define VIDEO_DATA_SWAP_DP_ENCODER0_P0_FLDMASK_POS                      8
+#define VIDEO_DATA_SWAP_DP_ENCODER0_P0_FLDMASK_LEN                      3
+
+#define VIDEO_SOURCE_SEL_DP_ENCODER0_P0_FLDMASK                         0x800
+#define VIDEO_SOURCE_SEL_DP_ENCODER0_P0_FLDMASK_POS                     11
+#define VIDEO_SOURCE_SEL_DP_ENCODER0_P0_FLDMASK_LEN                     1
+
+#define FIELD_VBID_SW_EN_DP_ENCODER0_P0_FLDMASK                         0x1000
+#define FIELD_VBID_SW_EN_DP_ENCODER0_P0_FLDMASK_POS                     12
+#define FIELD_VBID_SW_EN_DP_ENCODER0_P0_FLDMASK_LEN                     1
+
+#define FIELD_SW_DP_ENCODER0_P0_FLDMASK                                 0x2000
+#define FIELD_SW_DP_ENCODER0_P0_FLDMASK_POS                             13
+#define FIELD_SW_DP_ENCODER0_P0_FLDMASK_LEN                             1
+
+#define V3D_EN_SW_DP_ENCODER0_P0_FLDMASK                                0x4000
+#define V3D_EN_SW_DP_ENCODER0_P0_FLDMASK_POS                            14
+#define V3D_EN_SW_DP_ENCODER0_P0_FLDMASK_LEN                            1
+
+#define V3D_LR_HW_SWAP_DP_ENCODER0_P0_FLDMASK                           0x8000
+#define V3D_LR_HW_SWAP_DP_ENCODER0_P0_FLDMASK_POS                       15
+#define V3D_LR_HW_SWAP_DP_ENCODER0_P0_FLDMASK_LEN                       1
+
+#define REG_303C_DP_ENCODER0_P0              (0x303C)
+#define SRAM_START_READ_THRD_DP_ENCODER0_P0_FLDMASK                     0x3f
+#define SRAM_START_READ_THRD_DP_ENCODER0_P0_FLDMASK_POS                 0
+#define SRAM_START_READ_THRD_DP_ENCODER0_P0_FLDMASK_LEN                 6
+
+#define VIDEO_COLOR_DEPTH_DP_ENCODER0_P0_FLDMASK                        0x700
+#define VIDEO_COLOR_DEPTH_DP_ENCODER0_P0_FLDMASK_POS                    8
+#define VIDEO_COLOR_DEPTH_DP_ENCODER0_P0_FLDMASK_LEN                    3
+
+#define PIXEL_ENCODE_FORMAT_DP_ENCODER0_P0_FLDMASK                      0x7000
+#define PIXEL_ENCODE_FORMAT_DP_ENCODER0_P0_FLDMASK_POS                  12
+#define PIXEL_ENCODE_FORMAT_DP_ENCODER0_P0_FLDMASK_LEN                  3
+
+#define VIDEO_MN_GEN_EN_DP_ENCODER0_P0_FLDMASK                          0x8000
+#define VIDEO_MN_GEN_EN_DP_ENCODER0_P0_FLDMASK_POS                      15
+#define VIDEO_MN_GEN_EN_DP_ENCODER0_P0_FLDMASK_LEN                      1
+
+#define REG_3040_DP_ENCODER0_P0              (0x3040)
+#define SDP_DOWN_CNT_INIT_DP_ENCODER0_P0_FLDMASK                        0xfff
+#define SDP_DOWN_CNT_INIT_DP_ENCODER0_P0_FLDMASK_POS                    0
+#define SDP_DOWN_CNT_INIT_DP_ENCODER0_P0_FLDMASK_LEN                    12
+
+#define AUDIO_32CH_EN_DP_ENCODER0_P0_FLDMASK                            0x1000
+#define AUDIO_32CH_EN_DP_ENCODER0_P0_FLDMASK_POS                        12
+#define AUDIO_32CH_EN_DP_ENCODER0_P0_FLDMASK_LEN                        1
+
+#define AUDIO_32CH_SEL_DP_ENCODER0_P0_FLDMASK                           0x2000
+#define AUDIO_32CH_SEL_DP_ENCODER0_P0_FLDMASK_POS                       13
+#define AUDIO_32CH_SEL_DP_ENCODER0_P0_FLDMASK_LEN                       1
+
+#define AUDIO_16CH_EN_DP_ENCODER0_P0_FLDMASK                            0x4000
+#define AUDIO_16CH_EN_DP_ENCODER0_P0_FLDMASK_POS                        14
+#define AUDIO_16CH_EN_DP_ENCODER0_P0_FLDMASK_LEN                        1
+
+#define AUDIO_16CH_SEL_DP_ENCODER0_P0_FLDMASK                           0x8000
+#define AUDIO_16CH_SEL_DP_ENCODER0_P0_FLDMASK_POS                       15
+#define AUDIO_16CH_SEL_DP_ENCODER0_P0_FLDMASK_LEN                       1
+
+#define REG_3044_DP_ENCODER0_P0              (0x3044)
+#define VIDEO_N_CODE_0_DP_ENCODER0_P0_FLDMASK                           0xffff
+#define VIDEO_N_CODE_0_DP_ENCODER0_P0_FLDMASK_POS                       0
+#define VIDEO_N_CODE_0_DP_ENCODER0_P0_FLDMASK_LEN                       16
+
+#define REG_3048_DP_ENCODER0_P0              (0x3048)
+#define VIDEO_N_CODE_1_DP_ENCODER0_P0_FLDMASK                           0xff
+#define VIDEO_N_CODE_1_DP_ENCODER0_P0_FLDMASK_POS                       0
+#define VIDEO_N_CODE_1_DP_ENCODER0_P0_FLDMASK_LEN                       8
+
+#define REG_304C_DP_ENCODER0_P0              (0x304C)
+#define VIDEO_SRAM_MODE_DP_ENCODER0_P0_FLDMASK                          0x3
+#define VIDEO_SRAM_MODE_DP_ENCODER0_P0_FLDMASK_POS                      0
+#define VIDEO_SRAM_MODE_DP_ENCODER0_P0_FLDMASK_LEN                      2
+
+#define VBID_VIDEO_MUTE_DP_ENCODER0_P0_FLDMASK                          0x4
+#define VBID_VIDEO_MUTE_DP_ENCODER0_P0_FLDMASK_POS                      2
+#define VBID_VIDEO_MUTE_DP_ENCODER0_P0_FLDMASK_LEN                      1
+
+#define VBID_VIDEO_MUTE_IDLE_PATTERN_SYNC_EN_DP_ENCODER0_P0_FLDMASK     0x8
+#define VBID_VIDEO_MUTE_IDLE_PATTERN_SYNC_EN_DP_ENCODER0_P0_FLDMASK_POS 3
+#define VBID_VIDEO_MUTE_IDLE_PATTERN_SYNC_EN_DP_ENCODER0_P0_FLDMASK_LEN 1
+
+#define HDCP_SYNC_SEL_DP_ENCODER0_P0_FLDMASK                              0x10
+#define HDCP_SYNC_SEL_DP_ENCODER0_P0_FLDMASK_POS                          4
+#define HDCP_SYNC_SEL_DP_ENCODER0_P0_FLDMASK_LEN                          1
+
+#define HDCP_SYNC_SW_DP_ENCODER0_P0_FLDMASK                               0x20
+#define HDCP_SYNC_SW_DP_ENCODER0_P0_FLDMASK_POS                           5
+#define HDCP_SYNC_SW_DP_ENCODER0_P0_FLDMASK_LEN                           1
+
+#define SDP_VSYNC_RISING_MASK_DP_ENCODER0_P0_FLDMASK                      0x100
+#define SDP_VSYNC_RISING_MASK_DP_ENCODER0_P0_FLDMASK_POS                  8
+#define SDP_VSYNC_RISING_MASK_DP_ENCODER0_P0_FLDMASK_LEN                  1
+
+#define REG_3050_DP_ENCODER0_P0              (0x3050)
+#define VIDEO_N_CODE_MN_GEN_0_DP_ENCODER0_P0_FLDMASK                      0xffff
+#define VIDEO_N_CODE_MN_GEN_0_DP_ENCODER0_P0_FLDMASK_POS                  0
+#define VIDEO_N_CODE_MN_GEN_0_DP_ENCODER0_P0_FLDMASK_LEN                  16
+
+#define REG_3054_DP_ENCODER0_P0              (0x3054)
+#define VIDEO_N_CODE_MN_GEN_1_DP_ENCODER0_P0_FLDMASK                      0xff
+#define VIDEO_N_CODE_MN_GEN_1_DP_ENCODER0_P0_FLDMASK_POS                  0
+#define VIDEO_N_CODE_MN_GEN_1_DP_ENCODER0_P0_FLDMASK_LEN                  8
+
+#define REG_3058_DP_ENCODER0_P0              (0x3058)
+#define AUDIO_N_CODE_MN_GEN_0_DP_ENCODER0_P0_FLDMASK                      0xffff
+#define AUDIO_N_CODE_MN_GEN_0_DP_ENCODER0_P0_FLDMASK_POS                  0
+#define AUDIO_N_CODE_MN_GEN_0_DP_ENCODER0_P0_FLDMASK_LEN                  16
+
+#define REG_305C_DP_ENCODER0_P0              (0x305C)
+#define AUDIO_N_CODE_MN_GEN_1_DP_ENCODER0_P0_FLDMASK                      0xff
+#define AUDIO_N_CODE_MN_GEN_1_DP_ENCODER0_P0_FLDMASK_POS                  0
+#define AUDIO_N_CODE_MN_GEN_1_DP_ENCODER0_P0_FLDMASK_LEN                  8
+
+#define REG_3060_DP_ENCODER0_P0              (0x3060)
+#define NUM_INTERLACE_FRAME_DP_ENCODER0_P0_FLDMASK                        0x7
+#define NUM_INTERLACE_FRAME_DP_ENCODER0_P0_FLDMASK_POS                    0
+#define NUM_INTERLACE_FRAME_DP_ENCODER0_P0_FLDMASK_LEN                    3
+
+#define INTERLACE_DET_EVEN_EN_DP_ENCODER0_P0_FLDMASK                      0x8
+#define INTERLACE_DET_EVEN_EN_DP_ENCODER0_P0_FLDMASK_POS                  3
+#define INTERLACE_DET_EVEN_EN_DP_ENCODER0_P0_FLDMASK_LEN                  1
+
+#define FIELD_DETECT_EN_DP_ENCODER0_P0_FLDMASK                            0x10
+#define FIELD_DETECT_EN_DP_ENCODER0_P0_FLDMASK_POS                        4
+#define FIELD_DETECT_EN_DP_ENCODER0_P0_FLDMASK_LEN                        1
+
+#define FIELD_DETECT_UPDATE_THRD_DP_ENCODER0_P0_FLDMASK                   0xff00
+#define FIELD_DETECT_UPDATE_THRD_DP_ENCODER0_P0_FLDMASK_POS               8
+#define FIELD_DETECT_UPDATE_THRD_DP_ENCODER0_P0_FLDMASK_LEN               8
+
+#define REG_3064_DP_ENCODER0_P0              (0x3064)
+#define HDE_NUM_LAST_DP_ENCODER0_P0_FLDMASK                               0xffff
+#define HDE_NUM_LAST_DP_ENCODER0_P0_FLDMASK_POS                           0
+#define HDE_NUM_LAST_DP_ENCODER0_P0_FLDMASK_LEN                           16
+
+#define REG_3088_DP_ENCODER0_P0              (0x3088)
+#define AUDIO_DETECT_EN_DP_ENCODER0_P0_FLDMASK                            0x20
+#define AUDIO_DETECT_EN_DP_ENCODER0_P0_FLDMASK_POS                        5
+#define AUDIO_DETECT_EN_DP_ENCODER0_P0_FLDMASK_LEN                        1
+
+#define AU_EN_DP_ENCODER0_P0_FLDMASK                                      0x40
+#define AU_EN_DP_ENCODER0_P0_FLDMASK_POS                                  6
+#define AU_EN_DP_ENCODER0_P0_FLDMASK_LEN                                  1
+
+#define AUDIO_8CH_EN_DP_ENCODER0_P0_FLDMASK                               0x80
+#define AUDIO_8CH_EN_DP_ENCODER0_P0_FLDMASK_POS                           7
+#define AUDIO_8CH_EN_DP_ENCODER0_P0_FLDMASK_LEN                           1
+
+#define AUDIO_8CH_SEL_DP_ENCODER0_P0_FLDMASK                              0x100
+#define AUDIO_8CH_SEL_DP_ENCODER0_P0_FLDMASK_POS                          8
+#define AUDIO_8CH_SEL_DP_ENCODER0_P0_FLDMASK_LEN                          1
+
+#define AU_GEN_EN_DP_ENCODER0_P0_FLDMASK                                  0x200
+#define AU_GEN_EN_DP_ENCODER0_P0_FLDMASK_POS                              9
+#define AU_GEN_EN_DP_ENCODER0_P0_FLDMASK_LEN                              1
+
+#define AUDIO_MN_GEN_EN_DP_ENCODER0_P0_FLDMASK                            0x1000
+#define AUDIO_MN_GEN_EN_DP_ENCODER0_P0_FLDMASK_POS                        12
+#define AUDIO_MN_GEN_EN_DP_ENCODER0_P0_FLDMASK_LEN                        1
+
+#define DIS_ASP_DP_ENCODER0_P0_FLDMASK                                    0x2000
+#define DIS_ASP_DP_ENCODER0_P0_FLDMASK_POS                                13
+#define DIS_ASP_DP_ENCODER0_P0_FLDMASK_LEN                                1
+
+#define AUDIO_2CH_EN_DP_ENCODER0_P0_FLDMASK                               0x4000
+#define AUDIO_2CH_EN_DP_ENCODER0_P0_FLDMASK_POS                           14
+#define AUDIO_2CH_EN_DP_ENCODER0_P0_FLDMASK_LEN                           1
+
+#define AUDIO_2CH_SEL_DP_ENCODER0_P0_FLDMASK                              0x8000
+#define AUDIO_2CH_SEL_DP_ENCODER0_P0_FLDMASK_POS                          15
+#define AUDIO_2CH_SEL_DP_ENCODER0_P0_FLDMASK_LEN                          1
+
+#define REG_308C_DP_ENCODER0_P0              (0x308C)
+#define CH_STATUS_0_DP_ENCODER0_P0_FLDMASK                                0xffff
+#define CH_STATUS_0_DP_ENCODER0_P0_FLDMASK_POS                            0
+#define CH_STATUS_0_DP_ENCODER0_P0_FLDMASK_LEN                            16
+
+#define REG_3090_DP_ENCODER0_P0              (0x3090)
+#define CH_STATUS_1_DP_ENCODER0_P0_FLDMASK                                0xffff
+#define CH_STATUS_1_DP_ENCODER0_P0_FLDMASK_POS                            0
+#define CH_STATUS_1_DP_ENCODER0_P0_FLDMASK_LEN                            16
+
+#define REG_3094_DP_ENCODER0_P0              (0x3094)
+#define CH_STATUS_2_DP_ENCODER0_P0_FLDMASK                                0xff
+#define CH_STATUS_2_DP_ENCODER0_P0_FLDMASK_POS                            0
+#define CH_STATUS_2_DP_ENCODER0_P0_FLDMASK_LEN                            8
+
+#define REG_3098_DP_ENCODER0_P0              (0x3098)
+#define USER_DATA_0_DP_ENCODER0_P0_FLDMASK                                0xffff
+#define USER_DATA_0_DP_ENCODER0_P0_FLDMASK_POS                            0
+#define USER_DATA_0_DP_ENCODER0_P0_FLDMASK_LEN                            16
+
+#define REG_309C_DP_ENCODER0_P0              (0x309C)
+#define USER_DATA_1_DP_ENCODER0_P0_FLDMASK                                0xffff
+#define USER_DATA_1_DP_ENCODER0_P0_FLDMASK_POS                            0
+#define USER_DATA_1_DP_ENCODER0_P0_FLDMASK_LEN                            16
+
+#define REG_30A0_DP_ENCODER0_P0              (0x30A0)
+#define USER_DATA_2_DP_ENCODER0_P0_FLDMASK                                0xff
+#define USER_DATA_2_DP_ENCODER0_P0_FLDMASK_POS                            0
+#define USER_DATA_2_DP_ENCODER0_P0_FLDMASK_LEN                            8
+
+#define VSC_EXT_VESA_CFG_DP_ENCODER0_P0_FLDMASK                           0xf00
+#define VSC_EXT_VESA_CFG_DP_ENCODER0_P0_FLDMASK_POS                       8
+#define VSC_EXT_VESA_CFG_DP_ENCODER0_P0_FLDMASK_LEN                       4
+
+#define VSC_EXT_CEA_CFG_DP_ENCODER0_P0_FLDMASK                            0xf000
+#define VSC_EXT_CEA_CFG_DP_ENCODER0_P0_FLDMASK_POS                        12
+#define VSC_EXT_CEA_CFG_DP_ENCODER0_P0_FLDMASK_LEN                        4
+
+#define REG_30A4_DP_ENCODER0_P0              (0x30A4)
+#define AU_TS_CFG_DP_ENCODER0_P0_FLDMASK                                  0xff
+#define AU_TS_CFG_DP_ENCODER0_P0_FLDMASK_POS                              0
+#define AU_TS_CFG_DP_ENCODER0_P0_FLDMASK_LEN                              8
+
+#define AVI_CFG_DP_ENCODER0_P0_FLDMASK                                    0xff00
+#define AVI_CFG_DP_ENCODER0_P0_FLDMASK_POS                                8
+#define AVI_CFG_DP_ENCODER0_P0_FLDMASK_LEN                                8
+
+#define REG_30A8_DP_ENCODER0_P0              (0x30A8)
+#define AUI_CFG_DP_ENCODER0_P0_FLDMASK                                    0xff
+#define AUI_CFG_DP_ENCODER0_P0_FLDMASK_POS                                0
+#define AUI_CFG_DP_ENCODER0_P0_FLDMASK_LEN                                8
+
+#define SPD_CFG_DP_ENCODER0_P0_FLDMASK                                    0xff00
+#define SPD_CFG_DP_ENCODER0_P0_FLDMASK_POS                                8
+#define SPD_CFG_DP_ENCODER0_P0_FLDMASK_LEN                                8
+
+#define REG_30AC_DP_ENCODER0_P0              (0x30AC)
+#define MPEG_CFG_DP_ENCODER0_P0_FLDMASK                                   0xff
+#define MPEG_CFG_DP_ENCODER0_P0_FLDMASK_POS                               0
+#define MPEG_CFG_DP_ENCODER0_P0_FLDMASK_LEN                               8
+
+#define NTSC_CFG_DP_ENCODER0_P0_FLDMASK                                   0xff00
+#define NTSC_CFG_DP_ENCODER0_P0_FLDMASK_POS                               8
+#define NTSC_CFG_DP_ENCODER0_P0_FLDMASK_LEN                               8
+
+#define REG_30B0_DP_ENCODER0_P0              (0x30B0)
+#define VSP_CFG_DP_ENCODER0_P0_FLDMASK                                    0xff
+#define VSP_CFG_DP_ENCODER0_P0_FLDMASK_POS                                0
+#define VSP_CFG_DP_ENCODER0_P0_FLDMASK_LEN                                8
+
+#define EXT_CFG_DP_ENCODER0_P0_FLDMASK                                    0xff00
+#define EXT_CFG_DP_ENCODER0_P0_FLDMASK_POS                                8
+#define EXT_CFG_DP_ENCODER0_P0_FLDMASK_LEN                                8
+
+#define REG_30B4_DP_ENCODER0_P0              (0x30B4)
+#define ACM_CFG_DP_ENCODER0_P0_FLDMASK                                    0xff
+#define ACM_CFG_DP_ENCODER0_P0_FLDMASK_POS                                0
+#define ACM_CFG_DP_ENCODER0_P0_FLDMASK_LEN                                8
+
+#define ISRC_CFG_DP_ENCODER0_P0_FLDMASK                                   0xff00
+#define ISRC_CFG_DP_ENCODER0_P0_FLDMASK_POS                               8
+#define ISRC_CFG_DP_ENCODER0_P0_FLDMASK_LEN                               8
+
+#define REG_30B8_DP_ENCODER0_P0              (0x30B8)
+#define VSC_CFG_DP_ENCODER0_P0_FLDMASK                                    0xff
+#define VSC_CFG_DP_ENCODER0_P0_FLDMASK_POS                                0
+#define VSC_CFG_DP_ENCODER0_P0_FLDMASK_LEN                                8
+
+#define MSA_CFG_DP_ENCODER0_P0_FLDMASK                                    0xff00
+#define MSA_CFG_DP_ENCODER0_P0_FLDMASK_POS                                8
+#define MSA_CFG_DP_ENCODER0_P0_FLDMASK_LEN                                8
+
+#define REG_30BC_DP_ENCODER0_P0              (0x30BC)
+#define ISRC_CONT_DP_ENCODER0_P0_FLDMASK                                  0x1
+#define ISRC_CONT_DP_ENCODER0_P0_FLDMASK_POS                              0
+#define ISRC_CONT_DP_ENCODER0_P0_FLDMASK_LEN                              1
+
+#define MSA_BY_SDP_DP_ENCODER0_P0_FLDMASK                                 0x2
+#define MSA_BY_SDP_DP_ENCODER0_P0_FLDMASK_POS                             1
+#define MSA_BY_SDP_DP_ENCODER0_P0_FLDMASK_LEN                             1
+
+#define SDP_EN_DP_ENCODER0_P0_FLDMASK                                     0x4
+#define SDP_EN_DP_ENCODER0_P0_FLDMASK_POS                                 2
+#define SDP_EN_DP_ENCODER0_P0_FLDMASK_LEN                                 1
+
+#define NIBBLE_INTERLEAVER_EN_DP_ENCODER0_P0_FLDMASK                      0x8
+#define NIBBLE_INTERLEAVER_EN_DP_ENCODER0_P0_FLDMASK_POS                  3
+#define NIBBLE_INTERLEAVER_EN_DP_ENCODER0_P0_FLDMASK_LEN                  1
+
+#define ECC_EN_DP_ENCODER0_P0_FLDMASK                                     0x10
+#define ECC_EN_DP_ENCODER0_P0_FLDMASK_POS                                 4
+#define ECC_EN_DP_ENCODER0_P0_FLDMASK_LEN                                 1
+
+#define ASP_MIN_PL_SIZE_DP_ENCODER0_P0_FLDMASK                            0x60
+#define ASP_MIN_PL_SIZE_DP_ENCODER0_P0_FLDMASK_POS                        5
+#define ASP_MIN_PL_SIZE_DP_ENCODER0_P0_FLDMASK_LEN                        2
+
+#define AUDIO_M_CODE_MULT_DIV_SEL_DP_ENCODER0_P0_FLDMASK                  0x700
+#define AUDIO_M_CODE_MULT_DIV_SEL_DP_ENCODER0_P0_FLDMASK_POS              8
+#define AUDIO_M_CODE_MULT_DIV_SEL_DP_ENCODER0_P0_FLDMASK_LEN              3
+
+#define AUDIO_M_CODE_SEL_DP_ENCODER0_P0_FLDMASK                           0x4000
+#define AUDIO_M_CODE_SEL_DP_ENCODER0_P0_FLDMASK_POS                       14
+#define AUDIO_M_CODE_SEL_DP_ENCODER0_P0_FLDMASK_LEN                       1
+
+#define ASP_HB23_SEL_DP_ENCODER0_P0_FLDMASK                               0x8000
+#define ASP_HB23_SEL_DP_ENCODER0_P0_FLDMASK_POS                           15
+#define ASP_HB23_SEL_DP_ENCODER0_P0_FLDMASK_LEN                           1
+
+#define REG_30C0_DP_ENCODER0_P0              (0x30C0)
+#define AU_TS_HB0_DP_ENCODER0_P0_FLDMASK                                  0xff
+#define AU_TS_HB0_DP_ENCODER0_P0_FLDMASK_POS                              0
+#define AU_TS_HB0_DP_ENCODER0_P0_FLDMASK_LEN                              8
+
+#define AU_TS_HB1_DP_ENCODER0_P0_FLDMASK                                  0xff00
+#define AU_TS_HB1_DP_ENCODER0_P0_FLDMASK_POS                              8
+#define AU_TS_HB1_DP_ENCODER0_P0_FLDMASK_LEN                              8
+
+#define REG_30C4_DP_ENCODER0_P0              (0x30C4)
+#define AU_TS_HB2_DP_ENCODER0_P0_FLDMASK                                  0xff
+#define AU_TS_HB2_DP_ENCODER0_P0_FLDMASK_POS                              0
+#define AU_TS_HB2_DP_ENCODER0_P0_FLDMASK_LEN                              8
+
+#define AU_TS_HB3_DP_ENCODER0_P0_FLDMASK                                  0xff00
+#define AU_TS_HB3_DP_ENCODER0_P0_FLDMASK_POS                              8
+#define AU_TS_HB3_DP_ENCODER0_P0_FLDMASK_LEN                              8
+
+#define REG_30C8_DP_ENCODER0_P0              (0x30C8)
+#define AUDIO_M_CODE_SW_0_DP_ENCODER0_P0_FLDMASK                          0xffff
+#define AUDIO_M_CODE_SW_0_DP_ENCODER0_P0_FLDMASK_POS                      0
+#define AUDIO_M_CODE_SW_0_DP_ENCODER0_P0_FLDMASK_LEN                      16
+
+#define REG_30CC_DP_ENCODER0_P0              (0x30CC)
+#define AUDIO_M_CODE_SW_1_DP_ENCODER0_P0_FLDMASK                          0xff
+#define AUDIO_M_CODE_SW_1_DP_ENCODER0_P0_FLDMASK_POS                      0
+#define AUDIO_M_CODE_SW_1_DP_ENCODER0_P0_FLDMASK_LEN                      8
+
+#define REG_30D0_DP_ENCODER0_P0              (0x30D0)
+#define AUDIO_N_CODE_0_DP_ENCODER0_P0_FLDMASK                             0xffff
+#define AUDIO_N_CODE_0_DP_ENCODER0_P0_FLDMASK_POS                         0
+#define AUDIO_N_CODE_0_DP_ENCODER0_P0_FLDMASK_LEN                         16
+
+#define REG_30D4_DP_ENCODER0_P0              (0x30D4)
+#define AUDIO_N_CODE_1_DP_ENCODER0_P0_FLDMASK                             0xff
+#define AUDIO_N_CODE_1_DP_ENCODER0_P0_FLDMASK_POS                         0
+#define AUDIO_N_CODE_1_DP_ENCODER0_P0_FLDMASK_LEN                         8
+
+#define REG_30D8_DP_ENCODER0_P0              (0x30D8)
+#define ACM_HB0_DP_ENCODER0_P0_FLDMASK                                    0xff
+#define ACM_HB0_DP_ENCODER0_P0_FLDMASK_POS                                0
+#define ACM_HB0_DP_ENCODER0_P0_FLDMASK_LEN                                8
+
+#define ACM_HB1_DP_ENCODER0_P0_FLDMASK                                    0xff00
+#define ACM_HB1_DP_ENCODER0_P0_FLDMASK_POS                                8
+#define ACM_HB1_DP_ENCODER0_P0_FLDMASK_LEN                                8
+
+#define REG_30DC_DP_ENCODER0_P0              (0x30DC)
+#define ACM_HB2_DP_ENCODER0_P0_FLDMASK                                    0xff
+#define ACM_HB2_DP_ENCODER0_P0_FLDMASK_POS                                0
+#define ACM_HB2_DP_ENCODER0_P0_FLDMASK_LEN                                8
+
+#define ACM_HB3_DP_ENCODER0_P0_FLDMASK                                    0xff00
+#define ACM_HB3_DP_ENCODER0_P0_FLDMASK_POS                                8
+#define ACM_HB3_DP_ENCODER0_P0_FLDMASK_LEN                                8
+
+#define REG_30E0_DP_ENCODER0_P0              (0x30E0)
+#define ISRC_HB0_DP_ENCODER0_P0_FLDMASK                                   0xff
+#define ISRC_HB0_DP_ENCODER0_P0_FLDMASK_POS                               0
+#define ISRC_HB0_DP_ENCODER0_P0_FLDMASK_LEN                               8
+
+#define ISRC_HB1_DP_ENCODER0_P0_FLDMASK                                   0xff00
+#define ISRC_HB1_DP_ENCODER0_P0_FLDMASK_POS                               8
+#define ISRC_HB1_DP_ENCODER0_P0_FLDMASK_LEN                               8
+
+#define REG_30E4_DP_ENCODER0_P0              (0x30E4)
+#define ISRC_HB2_DP_ENCODER0_P0_FLDMASK                                   0xff
+#define ISRC_HB2_DP_ENCODER0_P0_FLDMASK_POS                               0
+#define ISRC_HB2_DP_ENCODER0_P0_FLDMASK_LEN                               8
+
+#define ISRC0_HB3_DP_ENCODER0_P0_FLDMASK                                  0xff00
+#define ISRC0_HB3_DP_ENCODER0_P0_FLDMASK_POS                              8
+#define ISRC0_HB3_DP_ENCODER0_P0_FLDMASK_LEN                              8
+
+#define REG_30E8_DP_ENCODER0_P0              (0x30E8)
+#define AVI_HB0_DP_ENCODER0_P0_FLDMASK                                    0xff
+#define AVI_HB0_DP_ENCODER0_P0_FLDMASK_POS                                0
+#define AVI_HB0_DP_ENCODER0_P0_FLDMASK_LEN                                8
+
+#define AVI_HB1_DP_ENCODER0_P0_FLDMASK                                    0xff00
+#define AVI_HB1_DP_ENCODER0_P0_FLDMASK_POS                                8
+#define AVI_HB1_DP_ENCODER0_P0_FLDMASK_LEN                                8
+
+#define REG_30EC_DP_ENCODER0_P0              (0x30EC)
+#define AVI_HB2_DP_ENCODER0_P0_FLDMASK                                    0xff
+#define AVI_HB2_DP_ENCODER0_P0_FLDMASK_POS                                0
+#define AVI_HB2_DP_ENCODER0_P0_FLDMASK_LEN                                8
+
+#define AVI_HB3_DP_ENCODER0_P0_FLDMASK                                    0xff00
+#define AVI_HB3_DP_ENCODER0_P0_FLDMASK_POS                                8
+#define AVI_HB3_DP_ENCODER0_P0_FLDMASK_LEN                                8
+
+#define REG_30F0_DP_ENCODER0_P0              (0x30F0)
+#define AUI_HB0_DP_ENCODER0_P0_FLDMASK                                    0xff
+#define AUI_HB0_DP_ENCODER0_P0_FLDMASK_POS                                0
+#define AUI_HB0_DP_ENCODER0_P0_FLDMASK_LEN                                8
+
+#define AUI_HB1_DP_ENCODER0_P0_FLDMASK                                    0xff00
+#define AUI_HB1_DP_ENCODER0_P0_FLDMASK_POS                                8
+#define AUI_HB1_DP_ENCODER0_P0_FLDMASK_LEN                                8
+
+#define REG_30F4_DP_ENCODER0_P0              (0x30F4)
+#define AUI_HB2_DP_ENCODER0_P0_FLDMASK                                    0xff
+#define AUI_HB2_DP_ENCODER0_P0_FLDMASK_POS                                0
+#define AUI_HB2_DP_ENCODER0_P0_FLDMASK_LEN                                8
+
+#define AUI_HB3_DP_ENCODER0_P0_FLDMASK                                    0xff00
+#define AUI_HB3_DP_ENCODER0_P0_FLDMASK_POS                                8
+#define AUI_HB3_DP_ENCODER0_P0_FLDMASK_LEN                                8
+
+#define REG_30F8_DP_ENCODER0_P0              (0x30F8)
+#define SPD_HB0_DP_ENCODER0_P0_FLDMASK                                    0xff
+#define SPD_HB0_DP_ENCODER0_P0_FLDMASK_POS                                0
+#define SPD_HB0_DP_ENCODER0_P0_FLDMASK_LEN                                8
+
+#define SPD_HB1_DP_ENCODER0_P0_FLDMASK                                    0xff00
+#define SPD_HB1_DP_ENCODER0_P0_FLDMASK_POS                                8
+#define SPD_HB1_DP_ENCODER0_P0_FLDMASK_LEN                                8
+
+#define REG_30FC_DP_ENCODER0_P0              (0x30FC)
+#define SPD_HB2_DP_ENCODER0_P0_FLDMASK                                    0xff
+#define SPD_HB2_DP_ENCODER0_P0_FLDMASK_POS                                0
+#define SPD_HB2_DP_ENCODER0_P0_FLDMASK_LEN                                8
+
+#define SPD_HB3_DP_ENCODER0_P0_FLDMASK                                    0xff00
+#define SPD_HB3_DP_ENCODER0_P0_FLDMASK_POS                                8
+#define SPD_HB3_DP_ENCODER0_P0_FLDMASK_LEN                                8
+
+#define REG_3100_DP_ENCODER0_P0              (0x3100)
+#define MPEG_HB0_DP_ENCODER0_P0_FLDMASK                                   0xff
+#define MPEG_HB0_DP_ENCODER0_P0_FLDMASK_POS                               0
+#define MPEG_HB0_DP_ENCODER0_P0_FLDMASK_LEN                               8
+
+#define MPEG_HB1_DP_ENCODER0_P0_FLDMASK                                   0xff00
+#define MPEG_HB1_DP_ENCODER0_P0_FLDMASK_POS                               8
+#define MPEG_HB1_DP_ENCODER0_P0_FLDMASK_LEN                               8
+
+#define REG_3104_DP_ENCODER0_P0              (0x3104)
+#define MPEG_HB2_DP_ENCODER0_P0_FLDMASK                                   0xff
+#define MPEG_HB2_DP_ENCODER0_P0_FLDMASK_POS                               0
+#define MPEG_HB2_DP_ENCODER0_P0_FLDMASK_LEN                               8
+
+#define MPEG_HB3_DP_ENCODER0_P0_FLDMASK                                   0xff00
+#define MPEG_HB3_DP_ENCODER0_P0_FLDMASK_POS                               8
+#define MPEG_HB3_DP_ENCODER0_P0_FLDMASK_LEN                               8
+
+#define REG_3108_DP_ENCODER0_P0              (0x3108)
+#define NTSC_HB0_DP_ENCODER0_P0_FLDMASK                                   0xff
+#define NTSC_HB0_DP_ENCODER0_P0_FLDMASK_POS                               0
+#define NTSC_HB0_DP_ENCODER0_P0_FLDMASK_LEN                               8
+
+#define NTSC_HB1_DP_ENCODER0_P0_FLDMASK                                   0xff00
+#define NTSC_HB1_DP_ENCODER0_P0_FLDMASK_POS                               8
+#define NTSC_HB1_DP_ENCODER0_P0_FLDMASK_LEN                               8
+
+#define REG_310C_DP_ENCODER0_P0              (0x310C)
+#define NTSC_HB2_DP_ENCODER0_P0_FLDMASK                                   0xff
+#define NTSC_HB2_DP_ENCODER0_P0_FLDMASK_POS                               0
+#define NTSC_HB2_DP_ENCODER0_P0_FLDMASK_LEN                               8
+
+#define NTSC_HB3_DP_ENCODER0_P0_FLDMASK                                   0xff00
+#define NTSC_HB3_DP_ENCODER0_P0_FLDMASK_POS                               8
+#define NTSC_HB3_DP_ENCODER0_P0_FLDMASK_LEN                               8
+
+#define REG_3110_DP_ENCODER0_P0              (0x3110)
+#define VSP_HB0_DP_ENCODER0_P0_FLDMASK                                    0xff
+#define VSP_HB0_DP_ENCODER0_P0_FLDMASK_POS                                0
+#define VSP_HB0_DP_ENCODER0_P0_FLDMASK_LEN                                8
+
+#define VSP_HB1_DP_ENCODER0_P0_FLDMASK                                    0xff00
+#define VSP_HB1_DP_ENCODER0_P0_FLDMASK_POS                                8
+#define VSP_HB1_DP_ENCODER0_P0_FLDMASK_LEN                                8
+
+#define REG_3114_DP_ENCODER0_P0              (0x3114)
+#define VSP_HB2_DP_ENCODER0_P0_FLDMASK                                    0xff
+#define VSP_HB2_DP_ENCODER0_P0_FLDMASK_POS                                0
+#define VSP_HB2_DP_ENCODER0_P0_FLDMASK_LEN                                8
+
+#define VSP_HB3_DP_ENCODER0_P0_FLDMASK                                    0xff00
+#define VSP_HB3_DP_ENCODER0_P0_FLDMASK_POS                                8
+#define VSP_HB3_DP_ENCODER0_P0_FLDMASK_LEN                                8
+
+#define REG_3118_DP_ENCODER0_P0              (0x3118)
+#define VSC_HB0_DP_ENCODER0_P0_FLDMASK                                    0xff
+#define VSC_HB0_DP_ENCODER0_P0_FLDMASK_POS                                0
+#define VSC_HB0_DP_ENCODER0_P0_FLDMASK_LEN                                8
+
+#define VSC_HB1_DP_ENCODER0_P0_FLDMASK                                    0xff00
+#define VSC_HB1_DP_ENCODER0_P0_FLDMASK_POS                                8
+#define VSC_HB1_DP_ENCODER0_P0_FLDMASK_LEN                                8
+
+#define REG_311C_DP_ENCODER0_P0              (0x311C)
+#define VSC_HB2_DP_ENCODER0_P0_FLDMASK                                    0xff
+#define VSC_HB2_DP_ENCODER0_P0_FLDMASK_POS                                0
+#define VSC_HB2_DP_ENCODER0_P0_FLDMASK_LEN                                8
+
+#define VSC_HB3_DP_ENCODER0_P0_FLDMASK                                    0xff00
+#define VSC_HB3_DP_ENCODER0_P0_FLDMASK_POS                                8
+#define VSC_HB3_DP_ENCODER0_P0_FLDMASK_LEN                                8
+
+#define REG_3120_DP_ENCODER0_P0              (0x3120)
+#define EXT_HB0_DP_ENCODER0_P0_FLDMASK                                    0xff
+#define EXT_HB0_DP_ENCODER0_P0_FLDMASK_POS                                0
+#define EXT_HB0_DP_ENCODER0_P0_FLDMASK_LEN                                8
+
+#define EXT_HB1_DP_ENCODER0_P0_FLDMASK                                    0xff00
+#define EXT_HB1_DP_ENCODER0_P0_FLDMASK_POS                                8
+#define EXT_HB1_DP_ENCODER0_P0_FLDMASK_LEN                                8
+
+#define REG_3124_DP_ENCODER0_P0              (0x3124)
+#define EXT_HB2_DP_ENCODER0_P0_FLDMASK                                    0xff
+#define EXT_HB2_DP_ENCODER0_P0_FLDMASK_POS                                0
+#define EXT_HB2_DP_ENCODER0_P0_FLDMASK_LEN                                8
+
+#define EXT_HB3_DP_ENCODER0_P0_FLDMASK                                    0xff00
+#define EXT_HB3_DP_ENCODER0_P0_FLDMASK_POS                                8
+#define EXT_HB3_DP_ENCODER0_P0_FLDMASK_LEN                                8
+
+#define REG_3128_DP_ENCODER0_P0              (0x3128)
+#define ASP_HB0_DP_ENCODER0_P0_FLDMASK                                    0xff
+#define ASP_HB0_DP_ENCODER0_P0_FLDMASK_POS                                0
+#define ASP_HB0_DP_ENCODER0_P0_FLDMASK_LEN                                8
+
+#define ASP_HB1_DP_ENCODER0_P0_FLDMASK                                    0xff00
+#define ASP_HB1_DP_ENCODER0_P0_FLDMASK_POS                                8
+#define ASP_HB1_DP_ENCODER0_P0_FLDMASK_LEN                                8
+
+#define REG_312C_DP_ENCODER0_P0              (0x312C)
+#define ASP_HB2_DP_ENCODER0_P0_FLDMASK                                    0xff
+#define ASP_HB2_DP_ENCODER0_P0_FLDMASK_POS                                0
+#define ASP_HB2_DP_ENCODER0_P0_FLDMASK_LEN                                8
+
+#define ASP_HB3_DP_ENCODER0_P0_FLDMASK                                    0xff00
+#define ASP_HB3_DP_ENCODER0_P0_FLDMASK_POS                                8
+#define ASP_HB3_DP_ENCODER0_P0_FLDMASK_LEN                                8
+
+#define REG_3130_DP_ENCODER0_P0              (0x3130)
+#define PPS_HB0_DP_ENCODER0_P0_FLDMASK                                    0xff
+#define PPS_HB0_DP_ENCODER0_P0_FLDMASK_POS                                0
+#define PPS_HB0_DP_ENCODER0_P0_FLDMASK_LEN                                8
+
+#define PPS_HB1_DP_ENCODER0_P0_FLDMASK                                    0xff00
+#define PPS_HB1_DP_ENCODER0_P0_FLDMASK_POS                                8
+#define PPS_HB1_DP_ENCODER0_P0_FLDMASK_LEN                                8
+
+#define REG_3134_DP_ENCODER0_P0              (0x3134)
+#define PPS_HB2_DP_ENCODER0_P0_FLDMASK                                    0xff
+#define PPS_HB2_DP_ENCODER0_P0_FLDMASK_POS                                0
+#define PPS_HB2_DP_ENCODER0_P0_FLDMASK_LEN                                8
+
+#define PPS_HB3_DP_ENCODER0_P0_FLDMASK                                    0xff00
+#define PPS_HB3_DP_ENCODER0_P0_FLDMASK_POS                                8
+#define PPS_HB3_DP_ENCODER0_P0_FLDMASK_LEN                                8
+
+#define REG_3138_DP_ENCODER0_P0              (0x3138)
+#define HDR0_HB0_DP_ENCODER0_P0_FLDMASK                                   0xff
+#define HDR0_HB0_DP_ENCODER0_P0_FLDMASK_POS                               0
+#define HDR0_HB0_DP_ENCODER0_P0_FLDMASK_LEN                               8
+
+#define HDR0_HB1_DP_ENCODER0_P0_FLDMASK                                   0xff00
+#define HDR0_HB1_DP_ENCODER0_P0_FLDMASK_POS                               8
+#define HDR0_HB1_DP_ENCODER0_P0_FLDMASK_LEN                               8
+
+#define REG_313C_DP_ENCODER0_P0              (0x313C)
+#define HDR0_HB2_DP_ENCODER0_P0_FLDMASK                                   0xff
+#define HDR0_HB2_DP_ENCODER0_P0_FLDMASK_POS                               0
+#define HDR0_HB2_DP_ENCODER0_P0_FLDMASK_LEN                               8
+
+#define HDR0_HB3_DP_ENCODER0_P0_FLDMASK                                   0xff00
+#define HDR0_HB3_DP_ENCODER0_P0_FLDMASK_POS                               8
+#define HDR0_HB3_DP_ENCODER0_P0_FLDMASK_LEN                               8
+
+#define REG_3140_DP_ENCODER0_P0              (0x3140)
+#define PGEN_CURSOR_V_DP_ENCODER0_P0_FLDMASK                              0x1fff
+#define PGEN_CURSOR_V_DP_ENCODER0_P0_FLDMASK_POS                          0
+#define PGEN_CURSOR_V_DP_ENCODER0_P0_FLDMASK_LEN                          13
+
+#define PGEN_TG_SEL_DP_ENCODER0_P0_FLDMASK                                0x2000
+#define PGEN_TG_SEL_DP_ENCODER0_P0_FLDMASK_POS                            13
+#define PGEN_TG_SEL_DP_ENCODER0_P0_FLDMASK_LEN                            1
+
+#define PGEN_PG_SEL_DP_ENCODER0_P0_FLDMASK                                0x4000
+#define PGEN_PG_SEL_DP_ENCODER0_P0_FLDMASK_POS                            14
+#define PGEN_PG_SEL_DP_ENCODER0_P0_FLDMASK_LEN                            1
+
+#define PGEN_CURSOR_EN_DP_ENCODER0_P0_FLDMASK                             0x8000
+#define PGEN_CURSOR_EN_DP_ENCODER0_P0_FLDMASK_POS                         15
+#define PGEN_CURSOR_EN_DP_ENCODER0_P0_FLDMASK_LEN                         1
+
+#define REG_3144_DP_ENCODER0_P0              (0x3144)
+#define PGEN_CURSOR_H_DP_ENCODER0_P0_FLDMASK                              0x3fff
+#define PGEN_CURSOR_H_DP_ENCODER0_P0_FLDMASK_POS                          0
+#define PGEN_CURSOR_H_DP_ENCODER0_P0_FLDMASK_LEN                          14
+
+#define REG_3148_DP_ENCODER0_P0              (0x3148)
+#define PGEN_CURSOR_RGB_COLOR_CODE_0_DP_ENCODER0_P0_FLDMASK               0xffff
+#define PGEN_CURSOR_RGB_COLOR_CODE_0_DP_ENCODER0_P0_FLDMASK_POS           0
+#define PGEN_CURSOR_RGB_COLOR_CODE_0_DP_ENCODER0_P0_FLDMASK_LEN           16
+
+#define REG_314C_DP_ENCODER0_P0              (0x314C)
+#define PGEN_CURSOR_RGB_COLOR_CODE_1_DP_ENCODER0_P0_FLDMASK               0xffff
+#define PGEN_CURSOR_RGB_COLOR_CODE_1_DP_ENCODER0_P0_FLDMASK_POS           0
+#define PGEN_CURSOR_RGB_COLOR_CODE_1_DP_ENCODER0_P0_FLDMASK_LEN           16
+
+#define REG_3150_DP_ENCODER0_P0              (0x3150)
+#define PGEN_CURSOR_RGB_COLOR_CODE_2_DP_ENCODER0_P0_FLDMASK               0xf
+#define PGEN_CURSOR_RGB_COLOR_CODE_2_DP_ENCODER0_P0_FLDMASK_POS           0
+#define PGEN_CURSOR_RGB_COLOR_CODE_2_DP_ENCODER0_P0_FLDMASK_LEN           4
+
+#define REG_3154_DP_ENCODER0_P0              (0x3154)
+#define PGEN_HTOTAL_DP_ENCODER0_P0_FLDMASK                                0x3fff
+#define PGEN_HTOTAL_DP_ENCODER0_P0_FLDMASK_POS                            0
+#define PGEN_HTOTAL_DP_ENCODER0_P0_FLDMASK_LEN                            14
+
+#define REG_3158_DP_ENCODER0_P0              (0x3158)
+#define PGEN_HSYNC_RISING_DP_ENCODER0_P0_FLDMASK                          0x3fff
+#define PGEN_HSYNC_RISING_DP_ENCODER0_P0_FLDMASK_POS                      0
+#define PGEN_HSYNC_RISING_DP_ENCODER0_P0_FLDMASK_LEN                      14
+
+#define REG_315C_DP_ENCODER0_P0              (0x315C)
+#define PGEN_HSYNC_PULSE_WIDTH_DP_ENCODER0_P0_FLDMASK                     0x3fff
+#define PGEN_HSYNC_PULSE_WIDTH_DP_ENCODER0_P0_FLDMASK_POS                 0
+#define PGEN_HSYNC_PULSE_WIDTH_DP_ENCODER0_P0_FLDMASK_LEN                 14
+
+#define REG_3160_DP_ENCODER0_P0              (0x3160)
+#define PGEN_HFDE_START_DP_ENCODER0_P0_FLDMASK                            0x3fff
+#define PGEN_HFDE_START_DP_ENCODER0_P0_FLDMASK_POS                        0
+#define PGEN_HFDE_START_DP_ENCODER0_P0_FLDMASK_LEN                        14
+
+#define REG_3164_DP_ENCODER0_P0              (0x3164)
+#define PGEN_HFDE_ACTIVE_WIDTH_DP_ENCODER0_P0_FLDMASK                     0x3fff
+#define PGEN_HFDE_ACTIVE_WIDTH_DP_ENCODER0_P0_FLDMASK_POS                 0
+#define PGEN_HFDE_ACTIVE_WIDTH_DP_ENCODER0_P0_FLDMASK_LEN                 14
+
+#define REG_3168_DP_ENCODER0_P0              (0x3168)
+#define PGEN_VTOTAL_DP_ENCODER0_P0_FLDMASK                                0x1fff
+#define PGEN_VTOTAL_DP_ENCODER0_P0_FLDMASK_POS                            0
+#define PGEN_VTOTAL_DP_ENCODER0_P0_FLDMASK_LEN                            13
+
+#define REG_316C_DP_ENCODER0_P0              (0x316C)
+#define PGEN_VSYNC_RISING_DP_ENCODER0_P0_FLDMASK                          0x1fff
+#define PGEN_VSYNC_RISING_DP_ENCODER0_P0_FLDMASK_POS                      0
+#define PGEN_VSYNC_RISING_DP_ENCODER0_P0_FLDMASK_LEN                      13
+
+#define REG_3170_DP_ENCODER0_P0              (0x3170)
+#define PGEN_VSYNC_PULSE_WIDTH_DP_ENCODER0_P0_FLDMASK                     0x1fff
+#define PGEN_VSYNC_PULSE_WIDTH_DP_ENCODER0_P0_FLDMASK_POS                 0
+#define PGEN_VSYNC_PULSE_WIDTH_DP_ENCODER0_P0_FLDMASK_LEN                 13
+
+#define REG_3174_DP_ENCODER0_P0              (0x3174)
+#define PGEN_VFDE_START_DP_ENCODER0_P0_FLDMASK                            0x1fff
+#define PGEN_VFDE_START_DP_ENCODER0_P0_FLDMASK_POS                        0
+#define PGEN_VFDE_START_DP_ENCODER0_P0_FLDMASK_LEN                        13
+
+#define REG_3178_DP_ENCODER0_P0              (0x3178)
+#define PGEN_VFDE_ACTIVE_WIDTH_DP_ENCODER0_P0_FLDMASK                     0x1fff
+#define PGEN_VFDE_ACTIVE_WIDTH_DP_ENCODER0_P0_FLDMASK_POS                 0
+#define PGEN_VFDE_ACTIVE_WIDTH_DP_ENCODER0_P0_FLDMASK_LEN                 13
+
+#define REG_317C_DP_ENCODER0_P0              (0x317C)
+#define PGEN_PAT_BASE_PIXEL_0_DP_ENCODER0_P0_FLDMASK                      0xfff
+#define PGEN_PAT_BASE_PIXEL_0_DP_ENCODER0_P0_FLDMASK_POS                  0
+#define PGEN_PAT_BASE_PIXEL_0_DP_ENCODER0_P0_FLDMASK_LEN                  12
+
+#define REG_3180_DP_ENCODER0_P0              (0x3180)
+#define PGEN_PAT_BASE_PIXEL_1_DP_ENCODER0_P0_FLDMASK                      0xfff
+#define PGEN_PAT_BASE_PIXEL_1_DP_ENCODER0_P0_FLDMASK_POS                  0
+#define PGEN_PAT_BASE_PIXEL_1_DP_ENCODER0_P0_FLDMASK_LEN                  12
+
+#define REG_3184_DP_ENCODER0_P0              (0x3184)
+#define PGEN_PAT_BASE_PIXEL_2_DP_ENCODER0_P0_FLDMASK                      0xfff
+#define PGEN_PAT_BASE_PIXEL_2_DP_ENCODER0_P0_FLDMASK_POS                  0
+#define PGEN_PAT_BASE_PIXEL_2_DP_ENCODER0_P0_FLDMASK_LEN                  12
+
+#define REG_3188_DP_ENCODER0_P0              (0x3188)
+#define PGEN_INITIAL_H_CNT_DP_ENCODER0_P0_FLDMASK                         0x3fff
+#define PGEN_INITIAL_H_CNT_DP_ENCODER0_P0_FLDMASK_POS                     0
+#define PGEN_INITIAL_H_CNT_DP_ENCODER0_P0_FLDMASK_LEN                     14
+
+#define REG_318C_DP_ENCODER0_P0              (0x318C)
+#define PGEN_INITIAL_V_CNT_DP_ENCODER0_P0_FLDMASK                         0x1fff
+#define PGEN_INITIAL_V_CNT_DP_ENCODER0_P0_FLDMASK_POS                     0
+#define PGEN_INITIAL_V_CNT_DP_ENCODER0_P0_FLDMASK_LEN                     13
+
+#define REG_3190_DP_ENCODER0_P0              (0x3190)
+#define PGEN_INITIAL_CB_SEL_DP_ENCODER0_P0_FLDMASK                        0x7
+#define PGEN_INITIAL_CB_SEL_DP_ENCODER0_P0_FLDMASK_POS                    0
+#define PGEN_INITIAL_CB_SEL_DP_ENCODER0_P0_FLDMASK_LEN                    3
+
+#define PGEN_FRAME_8K4K_MODE_EN_DP_ENCODER0_P0_FLDMASK                    0x10
+#define PGEN_FRAME_8K4K_MODE_EN_DP_ENCODER0_P0_FLDMASK_POS                4
+#define PGEN_FRAME_8K4K_MODE_EN_DP_ENCODER0_P0_FLDMASK_LEN                1
+
+#define PGEN_FRAME_8K4K_MODE_SET_DP_ENCODER0_P0_FLDMASK                   0x20
+#define PGEN_FRAME_8K4K_MODE_SET_DP_ENCODER0_P0_FLDMASK_POS               5
+#define PGEN_FRAME_8K4K_MODE_SET_DP_ENCODER0_P0_FLDMASK_LEN               1
+
+#define PGEN_INITIAL_H_GRAD_FLAG_DP_ENCODER0_P0_FLDMASK                   0x40
+#define PGEN_INITIAL_H_GRAD_FLAG_DP_ENCODER0_P0_FLDMASK_POS               6
+#define PGEN_INITIAL_H_GRAD_FLAG_DP_ENCODER0_P0_FLDMASK_LEN               1
+
+#define PGEN_INITIAL_V_GRAD_FLAG_DP_ENCODER0_P0_FLDMASK                   0x80
+#define PGEN_INITIAL_V_GRAD_FLAG_DP_ENCODER0_P0_FLDMASK_POS               7
+#define PGEN_INITIAL_V_GRAD_FLAG_DP_ENCODER0_P0_FLDMASK_LEN               1
+
+#define PGEN_FRAME_END_H_EN_DP_ENCODER0_P0_FLDMASK                        0x100
+#define PGEN_FRAME_END_H_EN_DP_ENCODER0_P0_FLDMASK_POS                    8
+#define PGEN_FRAME_END_H_EN_DP_ENCODER0_P0_FLDMASK_LEN                    1
+
+#define PGEN_FRAME_END_V_EN_DP_ENCODER0_P0_FLDMASK                        0x200
+#define PGEN_FRAME_END_V_EN_DP_ENCODER0_P0_FLDMASK_POS                    9
+#define PGEN_FRAME_END_V_EN_DP_ENCODER0_P0_FLDMASK_LEN                    1
+
+#define REG_3194_DP_ENCODER0_P0              (0x3194)
+#define PGEN_PAT_EXTRA_PIXEL_0_DP_ENCODER0_P0_FLDMASK                     0xfff
+#define PGEN_PAT_EXTRA_PIXEL_0_DP_ENCODER0_P0_FLDMASK_POS                 0
+#define PGEN_PAT_EXTRA_PIXEL_0_DP_ENCODER0_P0_FLDMASK_LEN                 12
+
+#define REG_3198_DP_ENCODER0_P0              (0x3198)
+#define PGEN_PAT_EXTRA_PIXEL_1_DP_ENCODER0_P0_FLDMASK                     0xfff
+#define PGEN_PAT_EXTRA_PIXEL_1_DP_ENCODER0_P0_FLDMASK_POS                 0
+#define PGEN_PAT_EXTRA_PIXEL_1_DP_ENCODER0_P0_FLDMASK_LEN                 12
+
+#define REG_319C_DP_ENCODER0_P0              (0x319C)
+#define PGEN_PAT_EXTRA_PIXEL_2_DP_ENCODER0_P0_FLDMASK                     0xfff
+#define PGEN_PAT_EXTRA_PIXEL_2_DP_ENCODER0_P0_FLDMASK_POS                 0
+#define PGEN_PAT_EXTRA_PIXEL_2_DP_ENCODER0_P0_FLDMASK_LEN                 12
+
+#define REG_31A0_DP_ENCODER0_P0              (0x31A0)
+#define PGEN_PAT_INCREMENT_0_DP_ENCODER0_P0_FLDMASK                       0xffff
+#define PGEN_PAT_INCREMENT_0_DP_ENCODER0_P0_FLDMASK_POS                   0
+#define PGEN_PAT_INCREMENT_0_DP_ENCODER0_P0_FLDMASK_LEN                   16
+
+#define REG_31A4_DP_ENCODER0_P0              (0x31A4)
+#define PGEN_PAT_INCREMENT_1_DP_ENCODER0_P0_FLDMASK                       0x1
+#define PGEN_PAT_INCREMENT_1_DP_ENCODER0_P0_FLDMASK_POS                   0
+#define PGEN_PAT_INCREMENT_1_DP_ENCODER0_P0_FLDMASK_LEN                   1
+
+#define REG_31A8_DP_ENCODER0_P0              (0x31A8)
+#define PGEN_PAT_HWIDTH_DP_ENCODER0_P0_FLDMASK                            0x3fff
+#define PGEN_PAT_HWIDTH_DP_ENCODER0_P0_FLDMASK_POS                        0
+#define PGEN_PAT_HWIDTH_DP_ENCODER0_P0_FLDMASK_LEN                        14
+
+#define REG_31AC_DP_ENCODER0_P0              (0x31AC)
+#define PGEN_PAT_VWIDTH_DP_ENCODER0_P0_FLDMASK                            0x1fff
+#define PGEN_PAT_VWIDTH_DP_ENCODER0_P0_FLDMASK_POS                        0
+#define PGEN_PAT_VWIDTH_DP_ENCODER0_P0_FLDMASK_LEN                        13
+
+#define REG_31B0_DP_ENCODER0_P0              (0x31B0)
+#define PGEN_PAT_RGB_ENABLE_DP_ENCODER0_P0_FLDMASK                        0x7
+#define PGEN_PAT_RGB_ENABLE_DP_ENCODER0_P0_FLDMASK_POS                    0
+#define PGEN_PAT_RGB_ENABLE_DP_ENCODER0_P0_FLDMASK_LEN                    3
+
+#define PGEN_PATTERN_SEL_DP_ENCODER0_P0_FLDMASK                           0x70
+#define PGEN_PATTERN_SEL_DP_ENCODER0_P0_FLDMASK_POS                       4
+#define PGEN_PATTERN_SEL_DP_ENCODER0_P0_FLDMASK_LEN                       3
+
+#define PGEN_PAT_DIRECTION_DP_ENCODER0_P0_FLDMASK                         0x80
+#define PGEN_PAT_DIRECTION_DP_ENCODER0_P0_FLDMASK_POS                     7
+#define PGEN_PAT_DIRECTION_DP_ENCODER0_P0_FLDMASK_LEN                     1
+
+#define PGEN_PAT_GRADIENT_NORMAL_MODE_DP_ENCODER0_P0_FLDMASK              0x100
+#define PGEN_PAT_GRADIENT_NORMAL_MODE_DP_ENCODER0_P0_FLDMASK_POS          8
+#define PGEN_PAT_GRADIENT_NORMAL_MODE_DP_ENCODER0_P0_FLDMASK_LEN          1
+
+#define PGEN_PAT_COLOR_BAR_GRADIENT_EN_DP_ENCODER0_P0_FLDMASK             0x200
+#define PGEN_PAT_COLOR_BAR_GRADIENT_EN_DP_ENCODER0_P0_FLDMASK_POS         9
+#define PGEN_PAT_COLOR_BAR_GRADIENT_EN_DP_ENCODER0_P0_FLDMASK_LEN         1
+
+#define PGEN_PAT_CHESSBOARD_NORMAL_MODE_DP_ENCODER0_P0_FLDMASK            0x400
+#define PGEN_PAT_CHESSBOARD_NORMAL_MODE_DP_ENCODER0_P0_FLDMASK_POS        10
+#define PGEN_PAT_CHESSBOARD_NORMAL_MODE_DP_ENCODER0_P0_FLDMASK_LEN        1
+
+#define PGEN_PAT_EXCHANGE_DP_ENCODER0_P0_FLDMASK                          0x800
+#define PGEN_PAT_EXCHANGE_DP_ENCODER0_P0_FLDMASK_POS                      11
+#define PGEN_PAT_EXCHANGE_DP_ENCODER0_P0_FLDMASK_LEN                      1
+
+#define PGEN_PAT_RGB_SUB_PIXEL_MASK_DP_ENCODER0_P0_FLDMASK                0x1000
+#define PGEN_PAT_RGB_SUB_PIXEL_MASK_DP_ENCODER0_P0_FLDMASK_POS            12
+#define PGEN_PAT_RGB_SUB_PIXEL_MASK_DP_ENCODER0_P0_FLDMASK_LEN            1
+
+#define REG_31B4_DP_ENCODER0_P0              (0x31B4)
+#define PGEN_PAT_THICKNESS_DP_ENCODER0_P0_FLDMASK                         0xf
+#define PGEN_PAT_THICKNESS_DP_ENCODER0_P0_FLDMASK_POS                     0
+#define PGEN_PAT_THICKNESS_DP_ENCODER0_P0_FLDMASK_LEN                     4
+
+#define REG_31C0_DP_ENCODER0_P0              (0x31C0)
+#define VIDEO_MUTE_CNT_THRD_DP_ENCODER0_P0_FLDMASK                        0xfff
+#define VIDEO_MUTE_CNT_THRD_DP_ENCODER0_P0_FLDMASK_POS                    0
+#define VIDEO_MUTE_CNT_THRD_DP_ENCODER0_P0_FLDMASK_LEN                    12
+
+#define REG_31C4_DP_ENCODER0_P0              (0x31C4)
+#define PPS_HW_BYPASS_MASK_DP_ENCODER0_P0_FLDMASK                         0x800
+#define PPS_HW_BYPASS_MASK_DP_ENCODER0_P0_FLDMASK_POS                     11
+#define PPS_HW_BYPASS_MASK_DP_ENCODER0_P0_FLDMASK_LEN                     1
+
+#define MST_EN_DP_ENCODER0_P0_FLDMASK                                     0x1000
+#define MST_EN_DP_ENCODER0_P0_FLDMASK_POS                                 12
+#define MST_EN_DP_ENCODER0_P0_FLDMASK_LEN                                 1
+
+#define DSC_BYPASS_EN_DP_ENCODER0_P0_FLDMASK                              0x2000
+#define DSC_BYPASS_EN_DP_ENCODER0_P0_FLDMASK_POS                          13
+#define DSC_BYPASS_EN_DP_ENCODER0_P0_FLDMASK_LEN                          1
+
+#define VSC_HW_BYPASS_MASK_DP_ENCODER0_P0_FLDMASK                         0x4000
+#define VSC_HW_BYPASS_MASK_DP_ENCODER0_P0_FLDMASK_POS                     14
+#define VSC_HW_BYPASS_MASK_DP_ENCODER0_P0_FLDMASK_LEN                     1
+
+#define HDR0_HW_BYPASS_MASK_DP_ENCODER0_P0_FLDMASK                        0x8000
+#define HDR0_HW_BYPASS_MASK_DP_ENCODER0_P0_FLDMASK_POS                    15
+#define HDR0_HW_BYPASS_MASK_DP_ENCODER0_P0_FLDMASK_LEN                    1
+
+#define REG_31C8_DP_ENCODER0_P0              (0x31C8)
+#define VSC_EXT_VESA_HB0_DP_ENCODER0_P0_FLDMASK                           0xff
+#define VSC_EXT_VESA_HB0_DP_ENCODER0_P0_FLDMASK_POS                       0
+#define VSC_EXT_VESA_HB0_DP_ENCODER0_P0_FLDMASK_LEN                       8
+
+#define VSC_EXT_VESA_HB1_DP_ENCODER0_P0_FLDMASK                           0xff00
+#define VSC_EXT_VESA_HB1_DP_ENCODER0_P0_FLDMASK_POS                       8
+#define VSC_EXT_VESA_HB1_DP_ENCODER0_P0_FLDMASK_LEN                       8
+
+#define REG_31CC_DP_ENCODER0_P0              (0x31CC)
+#define VSC_EXT_VESA_HB2_DP_ENCODER0_P0_FLDMASK                           0xff
+#define VSC_EXT_VESA_HB2_DP_ENCODER0_P0_FLDMASK_POS                       0
+#define VSC_EXT_VESA_HB2_DP_ENCODER0_P0_FLDMASK_LEN                       8
+
+#define VSC_EXT_VESA_HB3_DP_ENCODER0_P0_FLDMASK                           0xff00
+#define VSC_EXT_VESA_HB3_DP_ENCODER0_P0_FLDMASK_POS                       8
+#define VSC_EXT_VESA_HB3_DP_ENCODER0_P0_FLDMASK_LEN                       8
+
+#define REG_31D0_DP_ENCODER0_P0              (0x31D0)
+#define VSC_EXT_CEA_HB0_DP_ENCODER0_P0_FLDMASK                            0xff
+#define VSC_EXT_CEA_HB0_DP_ENCODER0_P0_FLDMASK_POS                        0
+#define VSC_EXT_CEA_HB0_DP_ENCODER0_P0_FLDMASK_LEN                        8
+
+#define VSC_EXT_CEA_HB1_DP_ENCODER0_P0_FLDMASK                            0xff00
+#define VSC_EXT_CEA_HB1_DP_ENCODER0_P0_FLDMASK_POS                        8
+#define VSC_EXT_CEA_HB1_DP_ENCODER0_P0_FLDMASK_LEN                        8
+
+#define REG_31D4_DP_ENCODER0_P0              (0x31D4)
+#define VSC_EXT_CEA_HB2_DP_ENCODER0_P0_FLDMASK                            0xff
+#define VSC_EXT_CEA_HB2_DP_ENCODER0_P0_FLDMASK_POS                        0
+#define VSC_EXT_CEA_HB2_DP_ENCODER0_P0_FLDMASK_LEN                        8
+
+#define VSC_EXT_CEA_HB3_DP_ENCODER0_P0_FLDMASK                            0xff00
+#define VSC_EXT_CEA_HB3_DP_ENCODER0_P0_FLDMASK_POS                        8
+#define VSC_EXT_CEA_HB3_DP_ENCODER0_P0_FLDMASK_LEN                        8
+
+#define REG_31D8_DP_ENCODER0_P0              (0x31D8)
+#define VSC_EXT_VESA_NUM_DP_ENCODER0_P0_FLDMASK                           0x3f
+#define VSC_EXT_VESA_NUM_DP_ENCODER0_P0_FLDMASK_POS                       0
+#define VSC_EXT_VESA_NUM_DP_ENCODER0_P0_FLDMASK_LEN                       6
+
+#define VSC_EXT_CEA_NUM_DP_ENCODER0_P0_FLDMASK                            0x3f00
+#define VSC_EXT_CEA_NUM_DP_ENCODER0_P0_FLDMASK_POS                        8
+#define VSC_EXT_CEA_NUM_DP_ENCODER0_P0_FLDMASK_LEN                        6
+
+#define REG_31DC_DP_ENCODER0_P0              (0x31DC)
+#define HDR0_CFG_DP_ENCODER0_P0_FLDMASK                                   0xff
+#define HDR0_CFG_DP_ENCODER0_P0_FLDMASK_POS                               0
+#define HDR0_CFG_DP_ENCODER0_P0_FLDMASK_LEN                               8
+
+#define RESERVED_CFG_DP_ENCODER0_P0_FLDMASK                               0xff00
+#define RESERVED_CFG_DP_ENCODER0_P0_FLDMASK_POS                           8
+#define RESERVED_CFG_DP_ENCODER0_P0_FLDMASK_LEN                           8
+
+#define REG_31E0_DP_ENCODER0_P0              (0x31E0)
+#define RESERVED_HB0_DP_ENCODER0_P0_FLDMASK                               0xff
+#define RESERVED_HB0_DP_ENCODER0_P0_FLDMASK_POS                           0
+#define RESERVED_HB0_DP_ENCODER0_P0_FLDMASK_LEN                           8
+
+#define RESERVED_HB1_DP_ENCODER0_P0_FLDMASK                               0xff00
+#define RESERVED_HB1_DP_ENCODER0_P0_FLDMASK_POS                           8
+#define RESERVED_HB1_DP_ENCODER0_P0_FLDMASK_LEN                           8
+
+#define REG_31E4_DP_ENCODER0_P0              (0x31E4)
+#define RESERVED_HB2_DP_ENCODER0_P0_FLDMASK                               0xff
+#define RESERVED_HB2_DP_ENCODER0_P0_FLDMASK_POS                           0
+#define RESERVED_HB2_DP_ENCODER0_P0_FLDMASK_LEN                           8
+
+#define RESERVED_HB3_DP_ENCODER0_P0_FLDMASK                               0xff00
+#define RESERVED_HB3_DP_ENCODER0_P0_FLDMASK_POS                           8
+#define RESERVED_HB3_DP_ENCODER0_P0_FLDMASK_LEN                           8
+
+#define REG_31E8_DP_ENCODER0_P0              (0x31E8)
+#define PPS_CFG_DP_ENCODER0_P0_FLDMASK                                    0xff
+#define PPS_CFG_DP_ENCODER0_P0_FLDMASK_POS                                0
+#define PPS_CFG_DP_ENCODER0_P0_FLDMASK_LEN                                8
+
+#define PPS_CFG_ONE_TIME_DP_ENCODER0_P0_FLDMASK                           0x100
+#define PPS_CFG_ONE_TIME_DP_ENCODER0_P0_FLDMASK_POS                       8
+#define PPS_CFG_ONE_TIME_DP_ENCODER0_P0_FLDMASK_LEN                       1
+
+#define SDP_SPLIT_FIFO_READ_START_POINT_DP_ENCODER0_P0_FLDMASK            0xf000
+#define SDP_SPLIT_FIFO_READ_START_POINT_DP_ENCODER0_P0_FLDMASK_POS        12
+#define SDP_SPLIT_FIFO_READ_START_POINT_DP_ENCODER0_P0_FLDMASK_LEN        4
+
+#define REG_31EC_DP_ENCODER0_P0              (0x31EC)
+#define VIDEO_M_CODE_FROM_DPRX_DP_ENCODER0_P0_FLDMASK                     0x1
+#define VIDEO_M_CODE_FROM_DPRX_DP_ENCODER0_P0_FLDMASK_POS                 0
+#define VIDEO_M_CODE_FROM_DPRX_DP_ENCODER0_P0_FLDMASK_LEN                 1
+
+#define MSA_MISC_FROM_DPRX_DP_ENCODER0_P0_FLDMASK                         0x2
+#define MSA_MISC_FROM_DPRX_DP_ENCODER0_P0_FLDMASK_POS                     1
+#define MSA_MISC_FROM_DPRX_DP_ENCODER0_P0_FLDMASK_LEN                     1
+
+#define ADS_CFG_DP_ENCODER0_P0_FLDMASK                                    0x4
+#define ADS_CFG_DP_ENCODER0_P0_FLDMASK_POS                                2
+#define ADS_CFG_DP_ENCODER0_P0_FLDMASK_LEN                                1
+
+#define ADS_MODE_DP_ENCODER0_P0_FLDMASK                                   0x8
+#define ADS_MODE_DP_ENCODER0_P0_FLDMASK_POS                               3
+#define ADS_MODE_DP_ENCODER0_P0_FLDMASK_LEN                               1
+
+#define AUDIO_CH_SRC_SEL_DP_ENCODER0_P0_FLDMASK                           0x10
+#define AUDIO_CH_SRC_SEL_DP_ENCODER0_P0_FLDMASK_POS                       4
+#define AUDIO_CH_SRC_SEL_DP_ENCODER0_P0_FLDMASK_LEN                       1
+
+#define ISRC1_HB3_DP_ENCODER0_P0_FLDMASK                                  0xff00
+#define ISRC1_HB3_DP_ENCODER0_P0_FLDMASK_POS                              8
+#define ISRC1_HB3_DP_ENCODER0_P0_FLDMASK_LEN                              8
+
+#define REG_31F0_DP_ENCODER0_P0              (0x31F0)
+#define ADS_HB0_DP_ENCODER0_P0_FLDMASK                                    0xff
+#define ADS_HB0_DP_ENCODER0_P0_FLDMASK_POS                                0
+#define ADS_HB0_DP_ENCODER0_P0_FLDMASK_LEN                                8
+
+#define ADS_HB1_DP_ENCODER0_P0_FLDMASK                                    0xff00
+#define ADS_HB1_DP_ENCODER0_P0_FLDMASK_POS                                8
+#define ADS_HB1_DP_ENCODER0_P0_FLDMASK_LEN                                8
+
+#define REG_31F8_DP_ENCODER0_P0              (0x31F8)
+#define ADS_HB2_DP_ENCODER0_P0_FLDMASK                                    0xff
+#define ADS_HB2_DP_ENCODER0_P0_FLDMASK_POS                                0
+#define ADS_HB2_DP_ENCODER0_P0_FLDMASK_LEN                                8
+
+#define ADS_HB3_DP_ENCODER0_P0_FLDMASK                                    0xff00
+#define ADS_HB3_DP_ENCODER0_P0_FLDMASK_POS                                8
+#define ADS_HB3_DP_ENCODER0_P0_FLDMASK_LEN                                8
+
+#define REG_31FC_DP_ENCODER0_P0              (0x31FC)
+#define VIDEO_ARBITER_DE_LAST_NUM0_SW_DP_ENCODER0_P0_FLDMASK              0x3
+#define VIDEO_ARBITER_DE_LAST_NUM0_SW_DP_ENCODER0_P0_FLDMASK_POS          0
+#define VIDEO_ARBITER_DE_LAST_NUM0_SW_DP_ENCODER0_P0_FLDMASK_LEN          2
+
+#define VIDEO_ARBITER_DE_LAST_NUM1_SW_DP_ENCODER0_P0_FLDMASK              0xc
+#define VIDEO_ARBITER_DE_LAST_NUM1_SW_DP_ENCODER0_P0_FLDMASK_POS          2
+#define VIDEO_ARBITER_DE_LAST_NUM1_SW_DP_ENCODER0_P0_FLDMASK_LEN          2
+
+#define VIDEO_ARBITER_DE_LAST_NUM2_SW_DP_ENCODER0_P0_FLDMASK              0x30
+#define VIDEO_ARBITER_DE_LAST_NUM2_SW_DP_ENCODER0_P0_FLDMASK_POS          4
+#define VIDEO_ARBITER_DE_LAST_NUM2_SW_DP_ENCODER0_P0_FLDMASK_LEN          2
+
+#define VIDEO_ARBITER_DE_LAST_NUM3_SW_DP_ENCODER0_P0_FLDMASK              0xc0
+#define VIDEO_ARBITER_DE_LAST_NUM3_SW_DP_ENCODER0_P0_FLDMASK_POS          6
+#define VIDEO_ARBITER_DE_LAST_NUM3_SW_DP_ENCODER0_P0_FLDMASK_LEN          2
+
+#define HDE_NUM_EVEN_EN_SW_LANE0_DP_ENCODER0_P0_FLDMASK                   0x100
+#define HDE_NUM_EVEN_EN_SW_LANE0_DP_ENCODER0_P0_FLDMASK_POS               8
+#define HDE_NUM_EVEN_EN_SW_LANE0_DP_ENCODER0_P0_FLDMASK_LEN               1
+
+#define HDE_NUM_EVEN_EN_SW_LANE1_DP_ENCODER0_P0_FLDMASK                   0x200
+#define HDE_NUM_EVEN_EN_SW_LANE1_DP_ENCODER0_P0_FLDMASK_POS               9
+#define HDE_NUM_EVEN_EN_SW_LANE1_DP_ENCODER0_P0_FLDMASK_LEN               1
+
+#define HDE_NUM_EVEN_EN_SW_LANE2_DP_ENCODER0_P0_FLDMASK                   0x400
+#define HDE_NUM_EVEN_EN_SW_LANE2_DP_ENCODER0_P0_FLDMASK_POS               10
+#define HDE_NUM_EVEN_EN_SW_LANE2_DP_ENCODER0_P0_FLDMASK_LEN               1
+
+#define HDE_NUM_EVEN_EN_SW_LANE3_DP_ENCODER0_P0_FLDMASK                   0x800
+#define HDE_NUM_EVEN_EN_SW_LANE3_DP_ENCODER0_P0_FLDMASK_POS               11
+#define HDE_NUM_EVEN_EN_SW_LANE3_DP_ENCODER0_P0_FLDMASK_LEN               1
+
+#define DE_LAST_NUM_SW_DP_ENCODER0_P0_FLDMASK                             0x1000
+#define DE_LAST_NUM_SW_DP_ENCODER0_P0_FLDMASK_POS                         12
+#define DE_LAST_NUM_SW_DP_ENCODER0_P0_FLDMASK_LEN                         1
+
+#define REG_3200_DP_ENCODER1_P0              (0x3200)
+#define SDP_DB0_DP_ENCODER1_P0_FLDMASK                                    0xff
+#define SDP_DB0_DP_ENCODER1_P0_FLDMASK_POS                                0
+#define SDP_DB0_DP_ENCODER1_P0_FLDMASK_LEN                                8
+
+#define SDP_DB1_DP_ENCODER1_P0_FLDMASK                                    0xff00
+#define SDP_DB1_DP_ENCODER1_P0_FLDMASK_POS                                8
+#define SDP_DB1_DP_ENCODER1_P0_FLDMASK_LEN                                8
+
+#define REG_3204_DP_ENCODER1_P0              (0x3204)
+#define SDP_DB2_DP_ENCODER1_P0_FLDMASK                                    0xff
+#define SDP_DB2_DP_ENCODER1_P0_FLDMASK_POS                                0
+#define SDP_DB2_DP_ENCODER1_P0_FLDMASK_LEN                                8
+
+#define SDP_DB3_DP_ENCODER1_P0_FLDMASK                                    0xff00
+#define SDP_DB3_DP_ENCODER1_P0_FLDMASK_POS                                8
+#define SDP_DB3_DP_ENCODER1_P0_FLDMASK_LEN                                8
+
+#define REG_3208_DP_ENCODER1_P0              (0x3208)
+#define SDP_DB4_DP_ENCODER1_P0_FLDMASK                                    0xff
+#define SDP_DB4_DP_ENCODER1_P0_FLDMASK_POS                                0
+#define SDP_DB4_DP_ENCODER1_P0_FLDMASK_LEN                                8
+
+#define SDP_DB5_DP_ENCODER1_P0_FLDMASK                                    0xff00
+#define SDP_DB5_DP_ENCODER1_P0_FLDMASK_POS                                8
+#define SDP_DB5_DP_ENCODER1_P0_FLDMASK_LEN                                8
+
+#define REG_320C_DP_ENCODER1_P0              (0x320C)
+#define SDP_DB6_DP_ENCODER1_P0_FLDMASK                                    0xff
+#define SDP_DB6_DP_ENCODER1_P0_FLDMASK_POS                                0
+#define SDP_DB6_DP_ENCODER1_P0_FLDMASK_LEN                                8
+
+#define SDP_DB7_DP_ENCODER1_P0_FLDMASK                                    0xff00
+#define SDP_DB7_DP_ENCODER1_P0_FLDMASK_POS                                8
+#define SDP_DB7_DP_ENCODER1_P0_FLDMASK_LEN                                8
+
+#define REG_3210_DP_ENCODER1_P0              (0x3210)
+#define SDP_DB8_DP_ENCODER1_P0_FLDMASK                                    0xff
+#define SDP_DB8_DP_ENCODER1_P0_FLDMASK_POS                                0
+#define SDP_DB8_DP_ENCODER1_P0_FLDMASK_LEN                                8
+
+#define SDP_DB9_DP_ENCODER1_P0_FLDMASK                                    0xff00
+#define SDP_DB9_DP_ENCODER1_P0_FLDMASK_POS                                8
+#define SDP_DB9_DP_ENCODER1_P0_FLDMASK_LEN                                8
+
+#define REG_3214_DP_ENCODER1_P0              (0x3214)
+#define SDP_DB10_DP_ENCODER1_P0_FLDMASK                                   0xff
+#define SDP_DB10_DP_ENCODER1_P0_FLDMASK_POS                               0
+#define SDP_DB10_DP_ENCODER1_P0_FLDMASK_LEN                               8
+
+#define SDP_DB11_DP_ENCODER1_P0_FLDMASK                                   0xff00
+#define SDP_DB11_DP_ENCODER1_P0_FLDMASK_POS                               8
+#define SDP_DB11_DP_ENCODER1_P0_FLDMASK_LEN                               8
+
+#define REG_3218_DP_ENCODER1_P0              (0x3218)
+#define SDP_DB12_DP_ENCODER1_P0_FLDMASK                                   0xff
+#define SDP_DB12_DP_ENCODER1_P0_FLDMASK_POS                               0
+#define SDP_DB12_DP_ENCODER1_P0_FLDMASK_LEN                               8
+
+#define SDP_DB13_DP_ENCODER1_P0_FLDMASK                                   0xff00
+#define SDP_DB13_DP_ENCODER1_P0_FLDMASK_POS                               8
+#define SDP_DB13_DP_ENCODER1_P0_FLDMASK_LEN                               8
+
+#define REG_321C_DP_ENCODER1_P0              (0x321C)
+#define SDP_DB14_DP_ENCODER1_P0_FLDMASK                                   0xff
+#define SDP_DB14_DP_ENCODER1_P0_FLDMASK_POS                               0
+#define SDP_DB14_DP_ENCODER1_P0_FLDMASK_LEN                               8
+
+#define SDP_DB15_DP_ENCODER1_P0_FLDMASK                                   0xff00
+#define SDP_DB15_DP_ENCODER1_P0_FLDMASK_POS                               8
+#define SDP_DB15_DP_ENCODER1_P0_FLDMASK_LEN                               8
+
+#define REG_3220_DP_ENCODER1_P0              (0x3220)
+#define SDP_DB16_DP_ENCODER1_P0_FLDMASK                                   0xff
+#define SDP_DB16_DP_ENCODER1_P0_FLDMASK_POS                               0
+#define SDP_DB16_DP_ENCODER1_P0_FLDMASK_LEN                               8
+
+#define SDP_DB17_DP_ENCODER1_P0_FLDMASK                                   0xff00
+#define SDP_DB17_DP_ENCODER1_P0_FLDMASK_POS                               8
+#define SDP_DB17_DP_ENCODER1_P0_FLDMASK_LEN                               8
+
+#define REG_3224_DP_ENCODER1_P0              (0x3224)
+#define SDP_DB18_DP_ENCODER1_P0_FLDMASK                                   0xff
+#define SDP_DB18_DP_ENCODER1_P0_FLDMASK_POS                               0
+#define SDP_DB18_DP_ENCODER1_P0_FLDMASK_LEN                               8
+
+#define SDP_DB19_DP_ENCODER1_P0_FLDMASK                                   0xff00
+#define SDP_DB19_DP_ENCODER1_P0_FLDMASK_POS                               8
+#define SDP_DB19_DP_ENCODER1_P0_FLDMASK_LEN                               8
+
+#define REG_3228_DP_ENCODER1_P0              (0x3228)
+#define SDP_DB20_DP_ENCODER1_P0_FLDMASK                                   0xff
+#define SDP_DB20_DP_ENCODER1_P0_FLDMASK_POS                               0
+#define SDP_DB20_DP_ENCODER1_P0_FLDMASK_LEN                               8
+
+#define SDP_DB21_DP_ENCODER1_P0_FLDMASK                                   0xff00
+#define SDP_DB21_DP_ENCODER1_P0_FLDMASK_POS                               8
+#define SDP_DB21_DP_ENCODER1_P0_FLDMASK_LEN                               8
+
+#define REG_322C_DP_ENCODER1_P0              (0x322C)
+#define SDP_DB22_DP_ENCODER1_P0_FLDMASK                                   0xff
+#define SDP_DB22_DP_ENCODER1_P0_FLDMASK_POS                               0
+#define SDP_DB22_DP_ENCODER1_P0_FLDMASK_LEN                               8
+
+#define SDP_DB23_DP_ENCODER1_P0_FLDMASK                                   0xff00
+#define SDP_DB23_DP_ENCODER1_P0_FLDMASK_POS                               8
+#define SDP_DB23_DP_ENCODER1_P0_FLDMASK_LEN                               8
+
+#define REG_3230_DP_ENCODER1_P0              (0x3230)
+#define SDP_DB24_DP_ENCODER1_P0_FLDMASK                                   0xff
+#define SDP_DB24_DP_ENCODER1_P0_FLDMASK_POS                               0
+#define SDP_DB24_DP_ENCODER1_P0_FLDMASK_LEN                               8
+
+#define SDP_DB25_DP_ENCODER1_P0_FLDMASK                                   0xff00
+#define SDP_DB25_DP_ENCODER1_P0_FLDMASK_POS                               8
+#define SDP_DB25_DP_ENCODER1_P0_FLDMASK_LEN                               8
+
+#define REG_3234_DP_ENCODER1_P0              (0x3234)
+#define SDP_DB26_DP_ENCODER1_P0_FLDMASK                                   0xff
+#define SDP_DB26_DP_ENCODER1_P0_FLDMASK_POS                               0
+#define SDP_DB26_DP_ENCODER1_P0_FLDMASK_LEN                               8
+
+#define SDP_DB27_DP_ENCODER1_P0_FLDMASK                                   0xff00
+#define SDP_DB27_DP_ENCODER1_P0_FLDMASK_POS                               8
+#define SDP_DB27_DP_ENCODER1_P0_FLDMASK_LEN                               8
+
+#define REG_3238_DP_ENCODER1_P0              (0x3238)
+#define SDP_DB28_DP_ENCODER1_P0_FLDMASK                                   0xff
+#define SDP_DB28_DP_ENCODER1_P0_FLDMASK_POS                               0
+#define SDP_DB28_DP_ENCODER1_P0_FLDMASK_LEN                               8
+
+#define SDP_DB29_DP_ENCODER1_P0_FLDMASK                                   0xff00
+#define SDP_DB29_DP_ENCODER1_P0_FLDMASK_POS                               8
+#define SDP_DB29_DP_ENCODER1_P0_FLDMASK_LEN                               8
+
+#define REG_323C_DP_ENCODER1_P0              (0x323C)
+#define SDP_DB30_DP_ENCODER1_P0_FLDMASK                                   0xff
+#define SDP_DB30_DP_ENCODER1_P0_FLDMASK_POS                               0
+#define SDP_DB30_DP_ENCODER1_P0_FLDMASK_LEN                               8
+
+#define SDP_DB31_DP_ENCODER1_P0_FLDMASK                                   0xff00
+#define SDP_DB31_DP_ENCODER1_P0_FLDMASK_POS                               8
+#define SDP_DB31_DP_ENCODER1_P0_FLDMASK_LEN                               8
+
+#define REG_3240_DP_ENCODER1_P0              (0x3240)
+#define SDP_DB0_R_DP_ENCODER1_P0_FLDMASK                                  0xff
+#define SDP_DB0_R_DP_ENCODER1_P0_FLDMASK_POS                              0
+#define SDP_DB0_R_DP_ENCODER1_P0_FLDMASK_LEN                              8
+
+#define SDP_DB1_R_DP_ENCODER1_P0_FLDMASK                                  0xff00
+#define SDP_DB1_R_DP_ENCODER1_P0_FLDMASK_POS                              8
+#define SDP_DB1_R_DP_ENCODER1_P0_FLDMASK_LEN                              8
+
+#define REG_3244_DP_ENCODER1_P0              (0x3244)
+#define SDP_DB2_R_DP_ENCODER1_P0_FLDMASK                                  0xff
+#define SDP_DB2_R_DP_ENCODER1_P0_FLDMASK_POS                              0
+#define SDP_DB2_R_DP_ENCODER1_P0_FLDMASK_LEN                              8
+
+#define SDP_DB3_R_DP_ENCODER1_P0_FLDMASK                                  0xff00
+#define SDP_DB3_R_DP_ENCODER1_P0_FLDMASK_POS                              8
+#define SDP_DB3_R_DP_ENCODER1_P0_FLDMASK_LEN                              8
+
+#define REG_3248_DP_ENCODER1_P0              (0x3248)
+#define SDP_DB4_R_DP_ENCODER1_P0_FLDMASK                                  0xff
+#define SDP_DB4_R_DP_ENCODER1_P0_FLDMASK_POS                              0
+#define SDP_DB4_R_DP_ENCODER1_P0_FLDMASK_LEN                              8
+
+#define SDP_DB5_R_DP_ENCODER1_P0_FLDMASK                                  0xff00
+#define SDP_DB5_R_DP_ENCODER1_P0_FLDMASK_POS                              8
+#define SDP_DB5_R_DP_ENCODER1_P0_FLDMASK_LEN                              8
+
+#define REG_324C_DP_ENCODER1_P0              (0x324C)
+#define SDP_DB6_R_DP_ENCODER1_P0_FLDMASK                                  0xff
+#define SDP_DB6_R_DP_ENCODER1_P0_FLDMASK_POS                              0
+#define SDP_DB6_R_DP_ENCODER1_P0_FLDMASK_LEN                              8
+
+#define SDP_DB7_R_DP_ENCODER1_P0_FLDMASK                                  0xff00
+#define SDP_DB7_R_DP_ENCODER1_P0_FLDMASK_POS                              8
+#define SDP_DB7_R_DP_ENCODER1_P0_FLDMASK_LEN                              8
+
+#define REG_3250_DP_ENCODER1_P0              (0x3250)
+#define SDP_DB8_R_DP_ENCODER1_P0_FLDMASK                                  0xff
+#define SDP_DB8_R_DP_ENCODER1_P0_FLDMASK_POS                              0
+#define SDP_DB8_R_DP_ENCODER1_P0_FLDMASK_LEN                              8
+
+#define SDP_DB9_R_DP_ENCODER1_P0_FLDMASK                                  0xff00
+#define SDP_DB9_R_DP_ENCODER1_P0_FLDMASK_POS                              8
+#define SDP_DB9_R_DP_ENCODER1_P0_FLDMASK_LEN                              8
+
+#define REG_3254_DP_ENCODER1_P0              (0x3254)
+#define SDP_DB10_R_DP_ENCODER1_P0_FLDMASK                                 0xff
+#define SDP_DB10_R_DP_ENCODER1_P0_FLDMASK_POS                             0
+#define SDP_DB10_R_DP_ENCODER1_P0_FLDMASK_LEN                             8
+
+#define SDP_DB11_R_DP_ENCODER1_P0_FLDMASK                                 0xff00
+#define SDP_DB11_R_DP_ENCODER1_P0_FLDMASK_POS                             8
+#define SDP_DB11_R_DP_ENCODER1_P0_FLDMASK_LEN                             8
+
+#define REG_3258_DP_ENCODER1_P0              (0x3258)
+#define SDP_DB12_R_DP_ENCODER1_P0_FLDMASK                                 0xff
+#define SDP_DB12_R_DP_ENCODER1_P0_FLDMASK_POS                             0
+#define SDP_DB12_R_DP_ENCODER1_P0_FLDMASK_LEN                             8
+
+#define SDP_DB13_R_DP_ENCODER1_P0_FLDMASK                                 0xff00
+#define SDP_DB13_R_DP_ENCODER1_P0_FLDMASK_POS                             8
+#define SDP_DB13_R_DP_ENCODER1_P0_FLDMASK_LEN                             8
+
+#define REG_325C_DP_ENCODER1_P0              (0x325C)
+#define SDP_DB14_R_DP_ENCODER1_P0_FLDMASK                                 0xff
+#define SDP_DB14_R_DP_ENCODER1_P0_FLDMASK_POS                             0
+#define SDP_DB14_R_DP_ENCODER1_P0_FLDMASK_LEN                             8
+
+#define SDP_DB15_R_DP_ENCODER1_P0_FLDMASK                                 0xff00
+#define SDP_DB15_R_DP_ENCODER1_P0_FLDMASK_POS                             8
+#define SDP_DB15_R_DP_ENCODER1_P0_FLDMASK_LEN                             8
+
+#define REG_3260_DP_ENCODER1_P0              (0x3260)
+#define SDP_DB16_R_DP_ENCODER1_P0_FLDMASK                                 0xff
+#define SDP_DB16_R_DP_ENCODER1_P0_FLDMASK_POS                             0
+#define SDP_DB16_R_DP_ENCODER1_P0_FLDMASK_LEN                             8
+
+#define SDP_DB17_R_DP_ENCODER1_P0_FLDMASK                                 0xff00
+#define SDP_DB17_R_DP_ENCODER1_P0_FLDMASK_POS                             8
+#define SDP_DB17_R_DP_ENCODER1_P0_FLDMASK_LEN                             8
+
+#define REG_3264_DP_ENCODER1_P0              (0x3264)
+#define SDP_DB18_R_DP_ENCODER1_P0_FLDMASK                                 0xff
+#define SDP_DB18_R_DP_ENCODER1_P0_FLDMASK_POS                             0
+#define SDP_DB18_R_DP_ENCODER1_P0_FLDMASK_LEN                             8
+
+#define SDP_DB19_R_DP_ENCODER1_P0_FLDMASK                                 0xff00
+#define SDP_DB19_R_DP_ENCODER1_P0_FLDMASK_POS                             8
+#define SDP_DB19_R_DP_ENCODER1_P0_FLDMASK_LEN                             8
+
+#define REG_3268_DP_ENCODER1_P0              (0x3268)
+#define SDP_DB20_R_DP_ENCODER1_P0_FLDMASK                                 0xff
+#define SDP_DB20_R_DP_ENCODER1_P0_FLDMASK_POS                             0
+#define SDP_DB20_R_DP_ENCODER1_P0_FLDMASK_LEN                             8
+
+#define SDP_DB21_R_DP_ENCODER1_P0_FLDMASK                                 0xff00
+#define SDP_DB21_R_DP_ENCODER1_P0_FLDMASK_POS                             8
+#define SDP_DB21_R_DP_ENCODER1_P0_FLDMASK_LEN                             8
+
+#define REG_326C_DP_ENCODER1_P0              (0x326C)
+#define SDP_DB22_R_DP_ENCODER1_P0_FLDMASK                                 0xff
+#define SDP_DB22_R_DP_ENCODER1_P0_FLDMASK_POS                             0
+#define SDP_DB22_R_DP_ENCODER1_P0_FLDMASK_LEN                             8
+
+#define SDP_DB23_R_DP_ENCODER1_P0_FLDMASK                                 0xff00
+#define SDP_DB23_R_DP_ENCODER1_P0_FLDMASK_POS                             8
+#define SDP_DB23_R_DP_ENCODER1_P0_FLDMASK_LEN                             8
+
+#define REG_3270_DP_ENCODER1_P0              (0x3270)
+#define SDP_DB24_R_DP_ENCODER1_P0_FLDMASK                                 0xff
+#define SDP_DB24_R_DP_ENCODER1_P0_FLDMASK_POS                             0
+#define SDP_DB24_R_DP_ENCODER1_P0_FLDMASK_LEN                             8
+
+#define SDP_DB25_R_DP_ENCODER1_P0_FLDMASK                                 0xff00
+#define SDP_DB25_R_DP_ENCODER1_P0_FLDMASK_POS                             8
+#define SDP_DB25_R_DP_ENCODER1_P0_FLDMASK_LEN                             8
+
+#define REG_3274_DP_ENCODER1_P0              (0x3274)
+#define SDP_DB26_R_DP_ENCODER1_P0_FLDMASK                                 0xff
+#define SDP_DB26_R_DP_ENCODER1_P0_FLDMASK_POS                             0
+#define SDP_DB26_R_DP_ENCODER1_P0_FLDMASK_LEN                             8
+
+#define SDP_DB27_R_DP_ENCODER1_P0_FLDMASK                                 0xff00
+#define SDP_DB27_R_DP_ENCODER1_P0_FLDMASK_POS                             8
+#define SDP_DB27_R_DP_ENCODER1_P0_FLDMASK_LEN                             8
+
+#define REG_3278_DP_ENCODER1_P0              (0x3278)
+#define SDP_DB28_R_DP_ENCODER1_P0_FLDMASK                                 0xff
+#define SDP_DB28_R_DP_ENCODER1_P0_FLDMASK_POS                             0
+#define SDP_DB28_R_DP_ENCODER1_P0_FLDMASK_LEN                             8
+
+#define SDP_DB29_R_DP_ENCODER1_P0_FLDMASK                                 0xff00
+#define SDP_DB29_R_DP_ENCODER1_P0_FLDMASK_POS                             8
+#define SDP_DB29_R_DP_ENCODER1_P0_FLDMASK_LEN                             8
+
+#define REG_327C_DP_ENCODER1_P0              (0x327C)
+#define SDP_DB30_R_DP_ENCODER1_P0_FLDMASK                                 0xff
+#define SDP_DB30_R_DP_ENCODER1_P0_FLDMASK_POS                             0
+#define SDP_DB30_R_DP_ENCODER1_P0_FLDMASK_LEN                             8
+
+#define SDP_DB31_R_DP_ENCODER1_P0_FLDMASK                                 0xff00
+#define SDP_DB31_R_DP_ENCODER1_P0_FLDMASK_POS                             8
+#define SDP_DB31_R_DP_ENCODER1_P0_FLDMASK_LEN                             8
+
+#define REG_3280_DP_ENCODER1_P0              (0x3280)
+#define SDP_PACKET_TYPE_DP_ENCODER1_P0_FLDMASK                            0x1f
+#define SDP_PACKET_TYPE_DP_ENCODER1_P0_FLDMASK_POS                        0
+#define SDP_PACKET_TYPE_DP_ENCODER1_P0_FLDMASK_LEN                        5
+
+#define SDP_PACKET_W_DP_ENCODER1_P0_FLDMASK                               0x20
+#define SDP_PACKET_W_DP_ENCODER1_P0_FLDMASK_POS                           5
+#define SDP_PACKET_W_DP_ENCODER1_P0_FLDMASK_LEN                           1
+
+#define SDP_PACKET_R_DP_ENCODER1_P0_FLDMASK                               0x40
+#define SDP_PACKET_R_DP_ENCODER1_P0_FLDMASK_POS                           6
+#define SDP_PACKET_R_DP_ENCODER1_P0_FLDMASK_LEN                           1
+
+#define REG_328C_DP_ENCODER1_P0              (0x328C)
+#define VSC_SW_HW_SEL_VESA_DP_ENCODER1_P0_FLDMASK                         0x1
+#define VSC_SW_HW_SEL_VESA_DP_ENCODER1_P0_FLDMASK_POS                     0
+#define VSC_SW_HW_SEL_VESA_DP_ENCODER1_P0_FLDMASK_LEN                     1
+
+#define VSC_SRAM_HW_RST_VESA_DP_ENCODER1_P0_FLDMASK                       0x2
+#define VSC_SRAM_HW_RST_VESA_DP_ENCODER1_P0_FLDMASK_POS                   1
+#define VSC_SRAM_HW_RST_VESA_DP_ENCODER1_P0_FLDMASK_LEN                   1
+
+#define VSC_SRAM_SW_RST_VESA_DP_ENCODER1_P0_FLDMASK                       0x4
+#define VSC_SRAM_SW_RST_VESA_DP_ENCODER1_P0_FLDMASK_POS                   2
+#define VSC_SRAM_SW_RST_VESA_DP_ENCODER1_P0_FLDMASK_LEN                   1
+
+#define VSC_SRAM_HW_EMPTY_VESA_DP_ENCODER1_P0_FLDMASK                     0x8
+#define VSC_SRAM_HW_EMPTY_VESA_DP_ENCODER1_P0_FLDMASK_POS                 3
+#define VSC_SRAM_HW_EMPTY_VESA_DP_ENCODER1_P0_FLDMASK_LEN                 1
+
+#define VSC_SRAM_HW_FULL_VESA_DP_ENCODER1_P0_FLDMASK                      0x10
+#define VSC_SRAM_HW_FULL_VESA_DP_ENCODER1_P0_FLDMASK_POS                  4
+#define VSC_SRAM_HW_FULL_VESA_DP_ENCODER1_P0_FLDMASK_LEN                  1
+
+#define VSC_SRAM_HW_FULL_CLR_VESA_DP_ENCODER1_P0_FLDMASK                  0x20
+#define VSC_SRAM_HW_FULL_CLR_VESA_DP_ENCODER1_P0_FLDMASK_POS              5
+#define VSC_SRAM_HW_FULL_CLR_VESA_DP_ENCODER1_P0_FLDMASK_LEN              1
+
+#define VSC_DATA_TOGGLE_VESA_DP_ENCODER1_P0_FLDMASK                       0x40
+#define VSC_DATA_TOGGLE_VESA_DP_ENCODER1_P0_FLDMASK_POS                   6
+#define VSC_DATA_TOGGLE_VESA_DP_ENCODER1_P0_FLDMASK_LEN                   1
+
+#define VSC_DATA_RDY_VESA_DP_ENCODER1_P0_FLDMASK                          0x80
+#define VSC_DATA_RDY_VESA_DP_ENCODER1_P0_FLDMASK_POS                      7
+#define VSC_DATA_RDY_VESA_DP_ENCODER1_P0_FLDMASK_LEN                      1
+
+#define VSC_SRAM_SW_EMPTY_VESA_DP_ENCODER1_P0_FLDMASK                     0x100
+#define VSC_SRAM_SW_EMPTY_VESA_DP_ENCODER1_P0_FLDMASK_POS                 8
+#define VSC_SRAM_SW_EMPTY_VESA_DP_ENCODER1_P0_FLDMASK_LEN                 1
+
+#define REG_3290_DP_ENCODER1_P0              (0x3290)
+#define VSC_DATA_BYTE0_VESA_DP_ENCODER1_P0_FLDMASK                        0xff
+#define VSC_DATA_BYTE0_VESA_DP_ENCODER1_P0_FLDMASK_POS                    0
+#define VSC_DATA_BYTE0_VESA_DP_ENCODER1_P0_FLDMASK_LEN                    8
+
+#define VSC_DATA_BYTE1_VESA_DP_ENCODER1_P0_FLDMASK                        0xff00
+#define VSC_DATA_BYTE1_VESA_DP_ENCODER1_P0_FLDMASK_POS                    8
+#define VSC_DATA_BYTE1_VESA_DP_ENCODER1_P0_FLDMASK_LEN                    8
+
+#define REG_3294_DP_ENCODER1_P0              (0x3294)
+#define VSC_DATA_BYTE2_VESA_DP_ENCODER1_P0_FLDMASK                        0xff
+#define VSC_DATA_BYTE2_VESA_DP_ENCODER1_P0_FLDMASK_POS                    0
+#define VSC_DATA_BYTE2_VESA_DP_ENCODER1_P0_FLDMASK_LEN                    8
+
+#define VSC_DATA_BYTE3_VESA_DP_ENCODER1_P0_FLDMASK                        0xff00
+#define VSC_DATA_BYTE3_VESA_DP_ENCODER1_P0_FLDMASK_POS                    8
+#define VSC_DATA_BYTE3_VESA_DP_ENCODER1_P0_FLDMASK_LEN                    8
+
+#define REG_3298_DP_ENCODER1_P0              (0x3298)
+#define VSC_DATA_BYTE4_VESA_DP_ENCODER1_P0_FLDMASK                        0xff
+#define VSC_DATA_BYTE4_VESA_DP_ENCODER1_P0_FLDMASK_POS                    0
+#define VSC_DATA_BYTE4_VESA_DP_ENCODER1_P0_FLDMASK_LEN                    8
+
+#define VSC_DATA_BYTE5_VESA_DP_ENCODER1_P0_FLDMASK                        0xff00
+#define VSC_DATA_BYTE5_VESA_DP_ENCODER1_P0_FLDMASK_POS                    8
+#define VSC_DATA_BYTE5_VESA_DP_ENCODER1_P0_FLDMASK_LEN                    8
+
+#define REG_329C_DP_ENCODER1_P0              (0x329C)
+#define VSC_DATA_BYTE6_VESA_DP_ENCODER1_P0_FLDMASK                        0xff
+#define VSC_DATA_BYTE6_VESA_DP_ENCODER1_P0_FLDMASK_POS                    0
+#define VSC_DATA_BYTE6_VESA_DP_ENCODER1_P0_FLDMASK_LEN                    8
+
+#define VSC_DATA_BYTE7_VESA_DP_ENCODER1_P0_FLDMASK                        0xff00
+#define VSC_DATA_BYTE7_VESA_DP_ENCODER1_P0_FLDMASK_POS                    8
+#define VSC_DATA_BYTE7_VESA_DP_ENCODER1_P0_FLDMASK_LEN                    8
+
+#define REG_32A0_DP_ENCODER1_P0              (0x32A0)
+#define VSC_SW_HW_SEL_CEA_DP_ENCODER1_P0_FLDMASK                          0x1
+#define VSC_SW_HW_SEL_CEA_DP_ENCODER1_P0_FLDMASK_POS                      0
+#define VSC_SW_HW_SEL_CEA_DP_ENCODER1_P0_FLDMASK_LEN                      1
+
+#define VSC_SRAM_HW_RST_CEA_DP_ENCODER1_P0_FLDMASK                        0x2
+#define VSC_SRAM_HW_RST_CEA_DP_ENCODER1_P0_FLDMASK_POS                    1
+#define VSC_SRAM_HW_RST_CEA_DP_ENCODER1_P0_FLDMASK_LEN                    1
+
+#define VSC_SRAM_SW_RST_CEA_DP_ENCODER1_P0_FLDMASK                        0x4
+#define VSC_SRAM_SW_RST_CEA_DP_ENCODER1_P0_FLDMASK_POS                    2
+#define VSC_SRAM_SW_RST_CEA_DP_ENCODER1_P0_FLDMASK_LEN                    1
+
+#define VSC_SRAM_HW_EMPTY_CEA_DP_ENCODER1_P0_FLDMASK                      0x8
+#define VSC_SRAM_HW_EMPTY_CEA_DP_ENCODER1_P0_FLDMASK_POS                  3
+#define VSC_SRAM_HW_EMPTY_CEA_DP_ENCODER1_P0_FLDMASK_LEN                  1
+
+#define VSC_SRAM_HW_FULL_CEA_DP_ENCODER1_P0_FLDMASK                       0x10
+#define VSC_SRAM_HW_FULL_CEA_DP_ENCODER1_P0_FLDMASK_POS                   4
+#define VSC_SRAM_HW_FULL_CEA_DP_ENCODER1_P0_FLDMASK_LEN                   1
+
+#define VSC_SRAM_HW_FULL_CLR_CEA_DP_ENCODER1_P0_FLDMASK                   0x20
+#define VSC_SRAM_HW_FULL_CLR_CEA_DP_ENCODER1_P0_FLDMASK_POS               5
+#define VSC_SRAM_HW_FULL_CLR_CEA_DP_ENCODER1_P0_FLDMASK_LEN               1
+
+#define VSC_DATA_TOGGLE_CEA_DP_ENCODER1_P0_FLDMASK                        0x40
+#define VSC_DATA_TOGGLE_CEA_DP_ENCODER1_P0_FLDMASK_POS                    6
+#define VSC_DATA_TOGGLE_CEA_DP_ENCODER1_P0_FLDMASK_LEN                    1
+
+#define VSC_DATA_RDY_CEA_DP_ENCODER1_P0_FLDMASK                           0x80
+#define VSC_DATA_RDY_CEA_DP_ENCODER1_P0_FLDMASK_POS                       7
+#define VSC_DATA_RDY_CEA_DP_ENCODER1_P0_FLDMASK_LEN                       1
+
+#define VSC_SRAM_SW_EMPTY_CEA_DP_ENCODER1_P0_FLDMASK                      0x100
+#define VSC_SRAM_SW_EMPTY_CEA_DP_ENCODER1_P0_FLDMASK_POS                  8
+#define VSC_SRAM_SW_EMPTY_CEA_DP_ENCODER1_P0_FLDMASK_LEN                  1
+
+#define REG_32A4_DP_ENCODER1_P0              (0x32A4)
+#define VSC_DATA_BYTE0_CEA_DP_ENCODER1_P0_FLDMASK                         0xff
+#define VSC_DATA_BYTE0_CEA_DP_ENCODER1_P0_FLDMASK_POS                     0
+#define VSC_DATA_BYTE0_CEA_DP_ENCODER1_P0_FLDMASK_LEN                     8
+
+#define VSC_DATA_BYTE1_CEA_DP_ENCODER1_P0_FLDMASK                         0xff00
+#define VSC_DATA_BYTE1_CEA_DP_ENCODER1_P0_FLDMASK_POS                     8
+#define VSC_DATA_BYTE1_CEA_DP_ENCODER1_P0_FLDMASK_LEN                     8
+
+#define REG_32A8_DP_ENCODER1_P0              (0x32A8)
+#define VSC_DATA_BYTE2_CEA_DP_ENCODER1_P0_FLDMASK                         0xff
+#define VSC_DATA_BYTE2_CEA_DP_ENCODER1_P0_FLDMASK_POS                     0
+#define VSC_DATA_BYTE2_CEA_DP_ENCODER1_P0_FLDMASK_LEN                     8
+
+#define VSC_DATA_BYTE3_CEA_DP_ENCODER1_P0_FLDMASK                         0xff00
+#define VSC_DATA_BYTE3_CEA_DP_ENCODER1_P0_FLDMASK_POS                     8
+#define VSC_DATA_BYTE3_CEA_DP_ENCODER1_P0_FLDMASK_LEN                     8
+
+#define REG_32AC_DP_ENCODER1_P0              (0x32AC)
+#define VSC_DATA_BYTE4_CEA_DP_ENCODER1_P0_FLDMASK                         0xff
+#define VSC_DATA_BYTE4_CEA_DP_ENCODER1_P0_FLDMASK_POS                     0
+#define VSC_DATA_BYTE4_CEA_DP_ENCODER1_P0_FLDMASK_LEN                     8
+
+#define VSC_DATA_BYTE5_CEA_DP_ENCODER1_P0_FLDMASK                         0xff00
+#define VSC_DATA_BYTE5_CEA_DP_ENCODER1_P0_FLDMASK_POS                     8
+#define VSC_DATA_BYTE5_CEA_DP_ENCODER1_P0_FLDMASK_LEN                     8
+
+#define REG_32B0_DP_ENCODER1_P0              (0x32B0)
+#define VSC_DATA_BYTE6_CEA_DP_ENCODER1_P0_FLDMASK                         0xff
+#define VSC_DATA_BYTE6_CEA_DP_ENCODER1_P0_FLDMASK_POS                     0
+#define VSC_DATA_BYTE6_CEA_DP_ENCODER1_P0_FLDMASK_LEN                     8
+
+#define VSC_DATA_BYTE7_CEA_DP_ENCODER1_P0_FLDMASK                         0xff00
+#define VSC_DATA_BYTE7_CEA_DP_ENCODER1_P0_FLDMASK_POS                     8
+#define VSC_DATA_BYTE7_CEA_DP_ENCODER1_P0_FLDMASK_LEN                     8
+
+#define REG_32B4_DP_ENCODER1_P0              (0x32B4)
+#define VSC_DATA_SW_CAN_WRITE_VESA_DP_ENCODER1_P0_FLDMASK                 0x1
+#define VSC_DATA_SW_CAN_WRITE_VESA_DP_ENCODER1_P0_FLDMASK_POS             0
+#define VSC_DATA_SW_CAN_WRITE_VESA_DP_ENCODER1_P0_FLDMASK_LEN             1
+
+#define VSC_DATA_SW_CAN_WRITE_CEA_DP_ENCODER1_P0_FLDMASK                  0x2
+#define VSC_DATA_SW_CAN_WRITE_CEA_DP_ENCODER1_P0_FLDMASK_POS              1
+#define VSC_DATA_SW_CAN_WRITE_CEA_DP_ENCODER1_P0_FLDMASK_LEN              1
+
+#define VSC_DATA_TRANSMIT_SEL_VESA_DP_ENCODER1_P0_FLDMASK                 0x4
+#define VSC_DATA_TRANSMIT_SEL_VESA_DP_ENCODER1_P0_FLDMASK_POS             2
+#define VSC_DATA_TRANSMIT_SEL_VESA_DP_ENCODER1_P0_FLDMASK_LEN             1
+
+#define VSC_DATA_TRANSMIT_SEL_CEA_DP_ENCODER1_P0_FLDMASK                  0x8
+#define VSC_DATA_TRANSMIT_SEL_CEA_DP_ENCODER1_P0_FLDMASK_POS              3
+#define VSC_DATA_TRANSMIT_SEL_CEA_DP_ENCODER1_P0_FLDMASK_LEN              1
+
+#define REG_32C0_DP_ENCODER1_P0              (0x32C0)
+#define IRQ_MASK_DP_ENCODER1_P0_FLDMASK                                   0xffff
+#define IRQ_MASK_DP_ENCODER1_P0_FLDMASK_POS                               0
+#define IRQ_MASK_DP_ENCODER1_P0_FLDMASK_LEN                               16
+
+#define REG_32C4_DP_ENCODER1_P0              (0x32C4)
+#define IRQ_CLR_DP_ENCODER1_P0_FLDMASK                                    0xffff
+#define IRQ_CLR_DP_ENCODER1_P0_FLDMASK_POS                                0
+#define IRQ_CLR_DP_ENCODER1_P0_FLDMASK_LEN                                16
+
+#define REG_32C8_DP_ENCODER1_P0              (0x32C8)
+#define IRQ_FORCE_DP_ENCODER1_P0_FLDMASK                                  0xffff
+#define IRQ_FORCE_DP_ENCODER1_P0_FLDMASK_POS                              0
+#define IRQ_FORCE_DP_ENCODER1_P0_FLDMASK_LEN                              16
+
+#define REG_32CC_DP_ENCODER1_P0              (0x32CC)
+#define IRQ_STATUS_DP_ENCODER1_P0_FLDMASK                                 0xffff
+#define IRQ_STATUS_DP_ENCODER1_P0_FLDMASK_POS                             0
+#define IRQ_STATUS_DP_ENCODER1_P0_FLDMASK_LEN                             16
+
+#define REG_32D0_DP_ENCODER1_P0              (0x32D0)
+#define IRQ_FINAL_STATUS_DP_ENCODER1_P0_FLDMASK                           0xffff
+#define IRQ_FINAL_STATUS_DP_ENCODER1_P0_FLDMASK_POS                       0
+#define IRQ_FINAL_STATUS_DP_ENCODER1_P0_FLDMASK_LEN                       16
+
+#define REG_32D4_DP_ENCODER1_P0              (0x32D4)
+#define IRQ_MASK_51_DP_ENCODER1_P0_FLDMASK                                0xffff
+#define IRQ_MASK_51_DP_ENCODER1_P0_FLDMASK_POS                            0
+#define IRQ_MASK_51_DP_ENCODER1_P0_FLDMASK_LEN                            16
+
+#define REG_32D8_DP_ENCODER1_P0              (0x32D8)
+#define IRQ_CLR_51_DP_ENCODER1_P0_FLDMASK                                 0xffff
+#define IRQ_CLR_51_DP_ENCODER1_P0_FLDMASK_POS                             0
+#define IRQ_CLR_51_DP_ENCODER1_P0_FLDMASK_LEN                             16
+
+#define REG_32DC_DP_ENCODER1_P0              (0x32DC)
+#define IRQ_FORCE_51_DP_ENCODER1_P0_FLDMASK                               0xffff
+#define IRQ_FORCE_51_DP_ENCODER1_P0_FLDMASK_POS                           0
+#define IRQ_FORCE_51_DP_ENCODER1_P0_FLDMASK_LEN                           16
+
+#define REG_32E0_DP_ENCODER1_P0              (0x32E0)
+#define IRQ_STATUS_51_DP_ENCODER1_P0_FLDMASK                              0xffff
+#define IRQ_STATUS_51_DP_ENCODER1_P0_FLDMASK_POS                          0
+#define IRQ_STATUS_51_DP_ENCODER1_P0_FLDMASK_LEN                          16
+
+#define REG_32E4_DP_ENCODER1_P0              (0x32E4)
+#define IRQ_FINAL_STATUS_51_DP_ENCODER1_P0_FLDMASK                        0xffff
+#define IRQ_FINAL_STATUS_51_DP_ENCODER1_P0_FLDMASK_POS                    0
+#define IRQ_FINAL_STATUS_51_DP_ENCODER1_P0_FLDMASK_LEN                    16
+
+#define REG_32E8_DP_ENCODER1_P0              (0x32E8)
+#define AUDIO_SRAM_WRITE_ADDR_0_DP_ENCODER1_P0_FLDMASK                    0x7f
+#define AUDIO_SRAM_WRITE_ADDR_0_DP_ENCODER1_P0_FLDMASK_POS                0
+#define AUDIO_SRAM_WRITE_ADDR_0_DP_ENCODER1_P0_FLDMASK_LEN                7
+
+#define AUDIO_SRAM_WRITE_ADDR_1_DP_ENCODER1_P0_FLDMASK                    0x7f00
+#define AUDIO_SRAM_WRITE_ADDR_1_DP_ENCODER1_P0_FLDMASK_POS                8
+#define AUDIO_SRAM_WRITE_ADDR_1_DP_ENCODER1_P0_FLDMASK_LEN                7
+
+#define REG_32EC_DP_ENCODER1_P0              (0x32EC)
+#define AUDIO_SRAM_WRITE_ADDR_2_DP_ENCODER1_P0_FLDMASK                    0x7f
+#define AUDIO_SRAM_WRITE_ADDR_2_DP_ENCODER1_P0_FLDMASK_POS                0
+#define AUDIO_SRAM_WRITE_ADDR_2_DP_ENCODER1_P0_FLDMASK_LEN                7
+
+#define AUDIO_SRAM_WRITE_ADDR_3_DP_ENCODER1_P0_FLDMASK                    0x7f00
+#define AUDIO_SRAM_WRITE_ADDR_3_DP_ENCODER1_P0_FLDMASK_POS                8
+#define AUDIO_SRAM_WRITE_ADDR_3_DP_ENCODER1_P0_FLDMASK_LEN                7
+
+#define REG_32F0_DP_ENCODER1_P0              (0x32F0)
+#define M_CODE_FEC_MERGE_0_DP_ENCODER1_P0_FLDMASK                         0xffff
+#define M_CODE_FEC_MERGE_0_DP_ENCODER1_P0_FLDMASK_POS                     0
+#define M_CODE_FEC_MERGE_0_DP_ENCODER1_P0_FLDMASK_LEN                     16
+
+#define REG_32F4_DP_ENCODER1_P0              (0x32F4)
+#define M_CODE_FEC_MERGE_1_DP_ENCODER1_P0_FLDMASK                         0xff
+#define M_CODE_FEC_MERGE_1_DP_ENCODER1_P0_FLDMASK_POS                     0
+#define M_CODE_FEC_MERGE_1_DP_ENCODER1_P0_FLDMASK_LEN                     8
+
+#define REG_32F8_DP_ENCODER1_P0              (0x32F8)
+#define MSA_UPDATE_LINE_CNT_THRD_DP_ENCODER1_P0_FLDMASK                   0xff
+#define MSA_UPDATE_LINE_CNT_THRD_DP_ENCODER1_P0_FLDMASK_POS               0
+#define MSA_UPDATE_LINE_CNT_THRD_DP_ENCODER1_P0_FLDMASK_LEN               8
+
+#define SDP_SPLIT_BUG_FIX_DP_ENCODER1_P0_FLDMASK                          0x200
+#define SDP_SPLIT_BUG_FIX_DP_ENCODER1_P0_FLDMASK_POS                      9
+#define SDP_SPLIT_BUG_FIX_DP_ENCODER1_P0_FLDMASK_LEN                      1
+
+#define MSA_MUTE_MASK_DP_ENCODER1_P0_FLDMASK                              0x400
+#define MSA_MUTE_MASK_DP_ENCODER1_P0_FLDMASK_POS                          10
+#define MSA_MUTE_MASK_DP_ENCODER1_P0_FLDMASK_LEN                          1
+
+#define MSA_UPDATE_SEL_DP_ENCODER1_P0_FLDMASK                             0x3000
+#define MSA_UPDATE_SEL_DP_ENCODER1_P0_FLDMASK_POS                         12
+#define MSA_UPDATE_SEL_DP_ENCODER1_P0_FLDMASK_LEN                         2
+
+#define VIDEO_MUTE_TOGGLE_SEL_DP_ENCODER1_P0_FLDMASK                      0xc000
+#define VIDEO_MUTE_TOGGLE_SEL_DP_ENCODER1_P0_FLDMASK_POS                  14
+#define VIDEO_MUTE_TOGGLE_SEL_DP_ENCODER1_P0_FLDMASK_LEN                  2
+
+#define REG_3300_DP_ENCODER1_P0              (0x3300)
+#define AUDIO_AFIFO_CNT_SEL_DP_ENCODER1_P0_FLDMASK                        0x1
+#define AUDIO_AFIFO_CNT_SEL_DP_ENCODER1_P0_FLDMASK_POS                    0
+#define AUDIO_AFIFO_CNT_SEL_DP_ENCODER1_P0_FLDMASK_LEN                    1
+
+#define AUDIO_SRAM_CNT_SEL_DP_ENCODER1_P0_FLDMASK                         0x2
+#define AUDIO_SRAM_CNT_SEL_DP_ENCODER1_P0_FLDMASK_POS                     1
+#define AUDIO_SRAM_CNT_SEL_DP_ENCODER1_P0_FLDMASK_LEN                     1
+
+#define AUDIO_AFIFO_CNT_DP_ENCODER1_P0_FLDMASK                            0xf0
+#define AUDIO_AFIFO_CNT_DP_ENCODER1_P0_FLDMASK_POS                        4
+#define AUDIO_AFIFO_CNT_DP_ENCODER1_P0_FLDMASK_LEN                        4
+
+#define VIDEO_AFIFO_RDY_SEL_DP_ENCODER1_P0_FLDMASK                        0x300
+#define VIDEO_AFIFO_RDY_SEL_DP_ENCODER1_P0_FLDMASK_POS                    8
+#define VIDEO_AFIFO_RDY_SEL_DP_ENCODER1_P0_FLDMASK_LEN                    2
+
+#define REG_3304_DP_ENCODER1_P0              (0x3304)
+#define AUDIO_SRAM_CNT_DP_ENCODER1_P0_FLDMASK                             0x7f
+#define AUDIO_SRAM_CNT_DP_ENCODER1_P0_FLDMASK_POS                         0
+#define AUDIO_SRAM_CNT_DP_ENCODER1_P0_FLDMASK_LEN                         7
+
+#define AU_PRTY_REGEN_DP_ENCODER1_P0_FLDMASK                              0x100
+#define AU_PRTY_REGEN_DP_ENCODER1_P0_FLDMASK_POS                          8
+#define AU_PRTY_REGEN_DP_ENCODER1_P0_FLDMASK_LEN                          1
+
+#define AU_CH_STS_REGEN_DP_ENCODER1_P0_FLDMASK                            0x200
+#define AU_CH_STS_REGEN_DP_ENCODER1_P0_FLDMASK_POS                        9
+#define AU_CH_STS_REGEN_DP_ENCODER1_P0_FLDMASK_LEN                        1
+
+#define AUDIO_VALIDITY_REGEN_DP_ENCODER1_P0_FLDMASK                       0x400
+#define AUDIO_VALIDITY_REGEN_DP_ENCODER1_P0_FLDMASK_POS                   10
+#define AUDIO_VALIDITY_REGEN_DP_ENCODER1_P0_FLDMASK_LEN                   1
+
+#define AUDIO_RESERVED_REGEN_DP_ENCODER1_P0_FLDMASK                       0x800
+#define AUDIO_RESERVED_REGEN_DP_ENCODER1_P0_FLDMASK_POS                   11
+#define AUDIO_RESERVED_REGEN_DP_ENCODER1_P0_FLDMASK_LEN                   1
+
+#define AUDIO_SAMPLE_PRSENT_REGEN_DP_ENCODER1_P0_FLDMASK                  0x1000
+#define AUDIO_SAMPLE_PRSENT_REGEN_DP_ENCODER1_P0_FLDMASK_POS              12
+#define AUDIO_SAMPLE_PRSENT_REGEN_DP_ENCODER1_P0_FLDMASK_LEN              1
+
+#define REG_3320_DP_ENCODER1_P0              (0x3320)
+#define AUDIO_PATTERN_GEN_DSTB_CNT_THRD_DP_ENCODER1_P0_FLDMASK            0x1ff
+#define AUDIO_PATTERN_GEN_DSTB_CNT_THRD_DP_ENCODER1_P0_FLDMASK_POS        0
+#define AUDIO_PATTERN_GEN_DSTB_CNT_THRD_DP_ENCODER1_P0_FLDMASK_LEN        9
+
+#define REG_3324_DP_ENCODER1_P0              (0x3324)
+#define AUDIO_SOURCE_MUX_DP_ENCODER1_P0_FLDMASK                           0x300
+#define AUDIO_SOURCE_MUX_DP_ENCODER1_P0_FLDMASK_POS                       8
+#define AUDIO_SOURCE_MUX_DP_ENCODER1_P0_FLDMASK_LEN                       2
+
+#define AUDIO_PATTERN_GEN_CH_NUM_DP_ENCODER1_P0_FLDMASK                   0x3000
+#define AUDIO_PATGEN_CH_NUM_DP_ENCODER1_P0_FLDMASK_POS                    12
+#define AUDIO_PATTERN_GEN_CH_NUM_DP_ENCODER1_P0_FLDMASK_LEN               2
+
+#define AUDIO_PATTERN_GEN_FS_SEL_DP_ENCODER1_P0_FLDMASK                   0xc000
+#define AUDIO_PATGEN_FS_SEL_DP_ENCODER1_P0_FLDMASK_POS                    14
+#define AUDIO_PATTERN_GEN_FS_SEL_DP_ENCODER1_P0_FLDMASK_LEN               2
+
+#define REG_3328_DP_ENCODER1_P0              (0x3328)
+#define VSYNC_DETECT_POL_DP_ENCODER1_P0_FLDMASK                           0x1
+#define VSYNC_DETECT_POL_DP_ENCODER1_P0_FLDMASK_POS                       0
+#define VSYNC_DETECT_POL_DP_ENCODER1_P0_FLDMASK_LEN                       1
+
+#define HSYNC_DETECT_POL_DP_ENCODER1_P0_FLDMASK                           0x2
+#define HSYNC_DETECT_POL_DP_ENCODER1_P0_FLDMASK_POS                       1
+#define HSYNC_DETECT_POL_DP_ENCODER1_P0_FLDMASK_LEN                       1
+
+#define HTOTAL_DETECT_STABLE_DP_ENCODER1_P0_FLDMASK                       0x4
+#define HTOTAL_DETECT_STABLE_DP_ENCODER1_P0_FLDMASK_POS                   2
+#define HTOTAL_DETECT_STABLE_DP_ENCODER1_P0_FLDMASK_LEN                   1
+
+#define HDE_DETECT_STABLE_DP_ENCODER1_P0_FLDMASK                          0x8
+#define HDE_DETECT_STABLE_DP_ENCODER1_P0_FLDMASK_POS                      3
+#define HDE_DETECT_STABLE_DP_ENCODER1_P0_FLDMASK_LEN                      1
+
+#define REG_332C_DP_ENCODER1_P0              (0x332C)
+#define VTOTAL_DETECT_DP_ENCODER1_P0_FLDMASK                              0xffff
+#define VTOTAL_DETECT_DP_ENCODER1_P0_FLDMASK_POS                          0
+#define VTOTAL_DETECT_DP_ENCODER1_P0_FLDMASK_LEN                          16
+
+#define REG_3330_DP_ENCODER1_P0              (0x3330)
+#define VDE_DETECT_DP_ENCODER1_P0_FLDMASK                                 0xffff
+#define VDE_DETECT_DP_ENCODER1_P0_FLDMASK_POS                             0
+#define VDE_DETECT_DP_ENCODER1_P0_FLDMASK_LEN                             16
+
+#define REG_3334_DP_ENCODER1_P0              (0x3334)
+#define HTOTAL_DETECT_DP_ENCODER1_P0_FLDMASK                              0xffff
+#define HTOTAL_DETECT_DP_ENCODER1_P0_FLDMASK_POS                          0
+#define HTOTAL_DETECT_DP_ENCODER1_P0_FLDMASK_LEN                          16
+
+#define REG_3338_DP_ENCODER1_P0              (0x3338)
+#define HDE_DETECT_DP_ENCODER1_P0_FLDMASK                                 0xffff
+#define HDE_DETECT_DP_ENCODER1_P0_FLDMASK_POS                             0
+#define HDE_DETECT_DP_ENCODER1_P0_FLDMASK_LEN                             16
+
+#define REG_3340_DP_ENCODER1_P0              (0x3340)
+#define BIST_FAIL_VIDEO_L0_DP_ENCODER1_P0_FLDMASK                         0x1
+#define BIST_FAIL_VIDEO_L0_DP_ENCODER1_P0_FLDMASK_POS                     0
+#define BIST_FAIL_VIDEO_L0_DP_ENCODER1_P0_FLDMASK_LEN                     1
+
+#define BIST_FAIL_VIDEO_L1_DP_ENCODER1_P0_FLDMASK                         0x2
+#define BIST_FAIL_VIDEO_L1_DP_ENCODER1_P0_FLDMASK_POS                     1
+#define BIST_FAIL_VIDEO_L1_DP_ENCODER1_P0_FLDMASK_LEN                     1
+
+#define BIST_FAIL_VIDEO_L2_DP_ENCODER1_P0_FLDMASK                         0x4
+#define BIST_FAIL_VIDEO_L2_DP_ENCODER1_P0_FLDMASK_POS                     2
+#define BIST_FAIL_VIDEO_L2_DP_ENCODER1_P0_FLDMASK_LEN                     1
+
+#define BIST_FAIL_VIDEO_L3_DP_ENCODER1_P0_FLDMASK                         0x8
+#define BIST_FAIL_VIDEO_L3_DP_ENCODER1_P0_FLDMASK_POS                     3
+#define BIST_FAIL_VIDEO_L3_DP_ENCODER1_P0_FLDMASK_LEN                     1
+
+#define BIST_FAIL_AUDIO_L0_DP_ENCODER1_P0_FLDMASK                         0x10
+#define BIST_FAIL_AUDIO_L0_DP_ENCODER1_P0_FLDMASK_POS                     4
+#define BIST_FAIL_AUDIO_L0_DP_ENCODER1_P0_FLDMASK_LEN                     1
+
+#define BIST_FAIL_AUDIO_L1_DP_ENCODER1_P0_FLDMASK                         0x20
+#define BIST_FAIL_AUDIO_L1_DP_ENCODER1_P0_FLDMASK_POS                     5
+#define BIST_FAIL_AUDIO_L1_DP_ENCODER1_P0_FLDMASK_LEN                     1
+
+#define BIST_FAIL_AUDIO_L2_DP_ENCODER1_P0_FLDMASK                         0x40
+#define BIST_FAIL_AUDIO_L2_DP_ENCODER1_P0_FLDMASK_POS                     6
+#define BIST_FAIL_AUDIO_L2_DP_ENCODER1_P0_FLDMASK_LEN                     1
+
+#define BIST_FAIL_AUDIO_L3_DP_ENCODER1_P0_FLDMASK                         0x80
+#define BIST_FAIL_AUDIO_L3_DP_ENCODER1_P0_FLDMASK_POS                     7
+#define BIST_FAIL_AUDIO_L3_DP_ENCODER1_P0_FLDMASK_LEN                     1
+
+#define BIST_FAIL_VSC_VESA_HW_DP_ENCODER1_P0_FLDMASK                      0x100
+#define BIST_FAIL_VSC_VESA_HW_DP_ENCODER1_P0_FLDMASK_POS                  8
+#define BIST_FAIL_VSC_VESA_HW_DP_ENCODER1_P0_FLDMASK_LEN                  1
+
+#define BIST_FAIL_VSC_CEA_HW_DP_ENCODER1_P0_FLDMASK                       0x200
+#define BIST_FAIL_VSC_CEA_HW_DP_ENCODER1_P0_FLDMASK_POS                   9
+#define BIST_FAIL_VSC_CEA_HW_DP_ENCODER1_P0_FLDMASK_LEN                   1
+
+#define BIST_FAIL_VSC_VESA_SW_DP_ENCODER1_P0_FLDMASK                      0x400
+#define BIST_FAIL_VSC_VESA_SW_DP_ENCODER1_P0_FLDMASK_POS                  10
+#define BIST_FAIL_VSC_VESA_SW_DP_ENCODER1_P0_FLDMASK_LEN                  1
+
+#define BIST_FAIL_VSC_CEA_SW_DP_ENCODER1_P0_FLDMASK                       0x800
+#define BIST_FAIL_VSC_CEA_SW_DP_ENCODER1_P0_FLDMASK_POS                   11
+#define BIST_FAIL_VSC_CEA_SW_DP_ENCODER1_P0_FLDMASK_LEN                   1
+
+#define LR_FIELD_SYNC_SEL_DP_ENCODER1_P0_FLDMASK                          0x7000
+#define LR_FIELD_SYNC_SEL_DP_ENCODER1_P0_FLDMASK_POS                      12
+#define LR_FIELD_SYNC_SEL_DP_ENCODER1_P0_FLDMASK_LEN                      3
+
+#define REG_3344_DP_ENCODER1_P0              (0x3344)
+#define DP_CH1_MATRIX_DP_ENCODER1_P0_FLDMASK                              0x1f
+#define DP_CH1_MATRIX_DP_ENCODER1_P0_FLDMASK_POS                          0
+#define DP_CH1_MATRIX_DP_ENCODER1_P0_FLDMASK_LEN                          5
+
+#define DP_CH2_MATRIX_DP_ENCODER1_P0_FLDMASK                              0x1f00
+#define DP_CH2_MATRIX_DP_ENCODER1_P0_FLDMASK_POS                          8
+#define DP_CH2_MATRIX_DP_ENCODER1_P0_FLDMASK_LEN                          5
+
+#define REG_3348_DP_ENCODER1_P0              (0x3348)
+#define DP_CH3_MATRIX_DP_ENCODER1_P0_FLDMASK                              0x1f
+#define DP_CH3_MATRIX_DP_ENCODER1_P0_FLDMASK_POS                          0
+#define DP_CH3_MATRIX_DP_ENCODER1_P0_FLDMASK_LEN                          5
+
+#define DP_CH4_MATRIX_DP_ENCODER1_P0_FLDMASK                              0x1f00
+#define DP_CH4_MATRIX_DP_ENCODER1_P0_FLDMASK_POS                          8
+#define DP_CH4_MATRIX_DP_ENCODER1_P0_FLDMASK_LEN                          5
+
+#define REG_334C_DP_ENCODER1_P0              (0x334C)
+#define DP_CH5_MATRIX_DP_ENCODER1_P0_FLDMASK                              0x1f
+#define DP_CH5_MATRIX_DP_ENCODER1_P0_FLDMASK_POS                          0
+#define DP_CH5_MATRIX_DP_ENCODER1_P0_FLDMASK_LEN                          5
+
+#define DP_CH6_MATRIX_DP_ENCODER1_P0_FLDMASK                              0x1f00
+#define DP_CH6_MATRIX_DP_ENCODER1_P0_FLDMASK_POS                          8
+#define DP_CH6_MATRIX_DP_ENCODER1_P0_FLDMASK_LEN                          5
+
+#define REG_3350_DP_ENCODER1_P0              (0x3350)
+#define DP_CH7_MATRIX_DP_ENCODER1_P0_FLDMASK                              0x1f
+#define DP_CH7_MATRIX_DP_ENCODER1_P0_FLDMASK_POS                          0
+#define DP_CH7_MATRIX_DP_ENCODER1_P0_FLDMASK_LEN                          5
+
+#define DP_CH8_MATRIX_DP_ENCODER1_P0_FLDMASK                              0x1f00
+#define DP_CH8_MATRIX_DP_ENCODER1_P0_FLDMASK_POS                          8
+#define DP_CH8_MATRIX_DP_ENCODER1_P0_FLDMASK_LEN                          5
+
+#define REG_3354_DP_ENCODER1_P0              (0x3354)
+#define DP_S2P_LAUNCH_CFG_DP_ENCODER1_P0_FLDMASK                          0x7f
+#define DP_S2P_LAUNCH_CFG_DP_ENCODER1_P0_FLDMASK_POS                      0
+#define DP_S2P_LAUNCH_CFG_DP_ENCODER1_P0_FLDMASK_LEN                      7
+
+#define AUDIO_HAYDN_EN_FORCE_DP_ENCODER1_P0_FLDMASK                       0x1000
+#define AUDIO_HAYDN_EN_FORCE_DP_ENCODER1_P0_FLDMASK_POS                   12
+#define AUDIO_HAYDN_EN_FORCE_DP_ENCODER1_P0_FLDMASK_LEN                   1
+
+#define AUDIO_HAYDN_FORMAT_DP_ENCODER1_P0_FLDMASK                         0xf00
+#define AUDIO_HAYDN_FORMAT_DP_ENCODER1_P0_FLDMASK_POS                     8
+#define AUDIO_HAYDN_FORMAT_DP_ENCODER1_P0_FLDMASK_LEN                     4
+
+#define REG_3358_DP_ENCODER1_P0              (0x3358)
+#define TU_SIZE_DP_ENCODER1_P0_FLDMASK                                    0x7f
+#define TU_SIZE_DP_ENCODER1_P0_FLDMASK_POS                                0
+#define TU_SIZE_DP_ENCODER1_P0_FLDMASK_LEN                                7
+
+#define TU_CALC_SW_DP_ENCODER1_P0_FLDMASK                                 0x80
+#define TU_CALC_SW_DP_ENCODER1_P0_FLDMASK_POS                             7
+#define TU_CALC_SW_DP_ENCODER1_P0_FLDMASK_LEN                             1
+
+#define REG_335C_DP_ENCODER1_P0              (0x335C)
+#define SYMBOL_DATA_PER_TU_SW_0_DP_ENCODER1_P0_FLDMASK                    0xffff
+#define SYMBOL_DATA_PER_TU_SW_0_DP_ENCODER1_P0_FLDMASK_POS                0
+#define SYMBOL_DATA_PER_TU_SW_0_DP_ENCODER1_P0_FLDMASK_LEN                16
+
+#define REG_3360_DP_ENCODER1_P0              (0x3360)
+#define SYMBOL_DATA_PER_TU_SW_1_DP_ENCODER1_P0_FLDMASK                    0x7fff
+#define SYMBOL_DATA_PER_TU_SW_1_DP_ENCODER1_P0_FLDMASK_POS                0
+#define SYMBOL_DATA_PER_TU_SW_1_DP_ENCODER1_P0_FLDMASK_LEN                15
+
+#define REG_3364_DP_ENCODER1_P0              (0x3364)
+#define SDP_DOWN_CNT_INIT_IN_HBLANK_DP_ENCODER1_P0_FLDMASK                0xfff
+#define SDP_DOWN_CNT_INIT_IN_HBLANK_DP_ENCODER1_P0_FLDMASK_POS            0
+#define SDP_DOWN_CNT_INIT_IN_HBLANK_DP_ENCODER1_P0_FLDMASK_LEN            12
+
+#define FIFO_READ_START_POINT_DP_ENCODER1_P0_FLDMASK                      0xf000
+#define FIFO_READ_START_POINT_DP_ENCODER1_P0_FLDMASK_POS                  12
+#define FIFO_READ_START_POINT_DP_ENCODER1_P0_FLDMASK_LEN                  4
+
+#define REG_3368_DP_ENCODER1_P0              (0x3368)
+#define VIDEO_SRAM_FIFO_CNT_RESET_SEL_DP_ENCODER1_P0_FLDMASK              0x3
+#define VIDEO_SRAM_FIFO_CNT_RESET_SEL_DP_ENCODER1_P0_FLDMASK_POS          0
+#define VIDEO_SRAM_FIFO_CNT_RESET_SEL_DP_ENCODER1_P0_FLDMASK_LEN          2
+
+#define VIDEO_STABLE_EN_DP_ENCODER1_P0_FLDMASK                            0x4
+#define VIDEO_STABLE_EN_DP_ENCODER1_P0_FLDMASK_POS                        2
+#define VIDEO_STABLE_EN_DP_ENCODER1_P0_FLDMASK_LEN                        1
+
+#define VIDEO_STABLE_CNT_THRD_DP_ENCODER1_P0_FLDMASK                      0xf0
+#define VIDEO_STABLE_CNT_THRD_DP_ENCODER1_P0_FLDMASK_POS                  4
+#define VIDEO_STABLE_CNT_THRD_DP_ENCODER1_P0_FLDMASK_LEN                  4
+
+#define SDP_DP13_EN_DP_ENCODER1_P0_FLDMASK                                0x100
+#define SDP_DP13_EN_DP_ENCODER1_P0_FLDMASK_POS                            8
+#define SDP_DP13_EN_DP_ENCODER1_P0_FLDMASK_LEN                            1
+
+#define VIDEO_PIXEL_SWAP_DP_ENCODER1_P0_FLDMASK                           0x600
+#define VIDEO_PIXEL_SWAP_DP_ENCODER1_P0_FLDMASK_POS                       9
+#define VIDEO_PIXEL_SWAP_DP_ENCODER1_P0_FLDMASK_LEN                       2
+
+#define BS2BS_MODE_DP_ENCODER1_P0_FLDMASK                                 0x3000
+#define BS2BS_MODE_DP_ENCODER1_P0_FLDMASK_POS                             12
+#define BS2BS_MODE_DP_ENCODER1_P0_FLDMASK_LEN                             2
+
+#define REG_336C_DP_ENCODER1_P0              (0x336C)
+#define DSC_EN_DP_ENCODER1_P0_FLDMASK                                     0x1
+#define DSC_EN_DP_ENCODER1_P0_FLDMASK_POS                                 0
+#define DSC_EN_DP_ENCODER1_P0_FLDMASK_LEN                                 1
+
+#define DSC_BYTE_SWAP_DP_ENCODER1_P0_FLDMASK                              0x2
+#define DSC_BYTE_SWAP_DP_ENCODER1_P0_FLDMASK_POS                          1
+#define DSC_BYTE_SWAP_DP_ENCODER1_P0_FLDMASK_LEN                          1
+
+#define DSC_SLICE_NUM_DP_ENCODER1_P0_FLDMASK                              0xf0
+#define DSC_SLICE_NUM_DP_ENCODER1_P0_FLDMASK_POS                          4
+#define DSC_SLICE_NUM_DP_ENCODER1_P0_FLDMASK_LEN                          4
+
+#define DSC_CHUNK_REMAINDER_DP_ENCODER1_P0_FLDMASK                        0xf00
+#define DSC_CHUNK_REMAINDER_DP_ENCODER1_P0_FLDMASK_POS                    8
+#define DSC_CHUNK_REMAINDER_DP_ENCODER1_P0_FLDMASK_LEN                    4
+
+#define REG_3370_DP_ENCODER1_P0              (0x3370)
+#define DSC_CHUNK_NUM_DP_ENCODER1_P0_FLDMASK                              0xffff
+#define DSC_CHUNK_NUM_DP_ENCODER1_P0_FLDMASK_POS                          0
+#define DSC_CHUNK_NUM_DP_ENCODER1_P0_FLDMASK_LEN                          16
+
+#define REG_33AC_DP_ENCODER1_P0              (0x33AC)
+#define TEST_CRC_R_CR_DP_ENCODER1_P0_FLDMASK                              0xffff
+#define TEST_CRC_R_CR_DP_ENCODER1_P0_FLDMASK_POS                          0
+#define TEST_CRC_R_CR_DP_ENCODER1_P0_FLDMASK_LEN                          16
+
+#define REG_33B0_DP_ENCODER1_P0              (0x33B0)
+#define TEST_CRC_G_Y_DP_ENCODER1_P0_FLDMASK                               0xffff
+#define TEST_CRC_G_Y_DP_ENCODER1_P0_FLDMASK_POS                           0
+#define TEST_CRC_G_Y_DP_ENCODER1_P0_FLDMASK_LEN                           16
+
+#define REG_33B4_DP_ENCODER1_P0              (0x33B4)
+#define TEST_CRC_B_CB_DP_ENCODER1_P0_FLDMASK                              0xffff
+#define TEST_CRC_B_CB_DP_ENCODER1_P0_FLDMASK_POS                          0
+#define TEST_CRC_B_CB_DP_ENCODER1_P0_FLDMASK_LEN                          16
+
+#define REG_33B8_DP_ENCODER1_P0              (0x33B8)
+#define TEST_CRC_WRAP_CNT_DP_ENCODER1_P0_FLDMASK                          0xf
+#define TEST_CRC_WRAP_CNT_DP_ENCODER1_P0_FLDMASK_POS                      0
+#define TEST_CRC_WRAP_CNT_DP_ENCODER1_P0_FLDMASK_LEN                      4
+
+#define CRC_COLOR_FORMAT_DP_ENCODER1_P0_FLDMASK                           0x1f0
+#define CRC_COLOR_FORMAT_DP_ENCODER1_P0_FLDMASK_POS                       4
+#define CRC_COLOR_FORMAT_DP_ENCODER1_P0_FLDMASK_LEN                       5
+
+#define CRC_TEST_SINK_START_DP_ENCODER1_P0_FLDMASK                        0x200
+#define CRC_TEST_SINK_START_DP_ENCODER1_P0_FLDMASK_POS                    9
+#define CRC_TEST_SINK_START_DP_ENCODER1_P0_FLDMASK_LEN                    1
+
+#define REG_33BC_DP_ENCODER1_P0              (0x33BC)
+#define CRC_TEST_CONFIG_DP_ENCODER1_P0_FLDMASK                            0x1fff
+#define CRC_TEST_CONFIG_DP_ENCODER1_P0_FLDMASK_POS                        0
+#define CRC_TEST_CONFIG_DP_ENCODER1_P0_FLDMASK_LEN                        13
+
+#define REG_33C0_DP_ENCODER1_P0              (0x33C0)
+#define VIDEO_TU_VALUE_DP_ENCODER1_P0_FLDMASK                             0x7f
+#define VIDEO_TU_VALUE_DP_ENCODER1_P0_FLDMASK_POS                         0
+#define VIDEO_TU_VALUE_DP_ENCODER1_P0_FLDMASK_LEN                         7
+
+#define DP_TX_MIXER_TESTBUS_SEL_DP_ENCODER1_P0_FLDMASK                    0xf00
+#define DP_TX_MIXER_TESTBUS_SEL_DP_ENCODER1_P0_FLDMASK_POS                8
+#define DP_TX_MIXER_TESTBUS_SEL_DP_ENCODER1_P0_FLDMASK_LEN                4
+
+#define DP_TX_SDP_TESTBUS_SEL_DP_ENCODER1_P0_FLDMASK                      0xf000
+#define DP_TX_SDP_TESTBUS_SEL_DP_ENCODER1_P0_FLDMASK_POS                  12
+#define DP_TX_SDP_TESTBUS_SEL_DP_ENCODER1_P0_FLDMASK_LEN                  4
+
+#define REG_33C4_DP_ENCODER1_P0              (0x33C4)
+#define DP_TX_VIDEO_TESTBUS_SEL_DP_ENCODER1_P0_FLDMASK                    0x1f
+#define DP_TX_VIDEO_TESTBUS_SEL_DP_ENCODER1_P0_FLDMASK_POS                0
+#define DP_TX_VIDEO_TESTBUS_SEL_DP_ENCODER1_P0_FLDMASK_LEN                5
+
+#define DP_TX_ENCODER_TESTBUS_SEL_DP_ENCODER1_P0_FLDMASK                  0x60
+#define DP_TX_ENCODER_TESTBUS_SEL_DP_ENCODER1_P0_FLDMASK_POS              5
+#define DP_TX_ENCODER_TESTBUS_SEL_DP_ENCODER1_P0_FLDMASK_LEN              2
+
+#define REG_33C8_DP_ENCODER1_P0              (0x33C8)
+#define VIDEO_M_CODE_READ_0_DP_ENCODER1_P0_FLDMASK                        0xffff
+#define VIDEO_M_CODE_READ_0_DP_ENCODER1_P0_FLDMASK_POS                    0
+#define VIDEO_M_CODE_READ_0_DP_ENCODER1_P0_FLDMASK_LEN                    16
+
+#define REG_33CC_DP_ENCODER1_P0              (0x33CC)
+#define VIDEO_M_CODE_READ_1_DP_ENCODER1_P0_FLDMASK                        0xff
+#define VIDEO_M_CODE_READ_1_DP_ENCODER1_P0_FLDMASK_POS                    0
+#define VIDEO_M_CODE_READ_1_DP_ENCODER1_P0_FLDMASK_LEN                    8
+
+#define REG_33D0_DP_ENCODER1_P0              (0x33D0)
+#define AUDIO_M_CODE_READ_0_DP_ENCODER1_P0_FLDMASK                        0xffff
+#define AUDIO_M_CODE_READ_0_DP_ENCODER1_P0_FLDMASK_POS                    0
+#define AUDIO_M_CODE_READ_0_DP_ENCODER1_P0_FLDMASK_LEN                    16
+
+#define REG_33D4_DP_ENCODER1_P0              (0x33D4)
+#define AUDIO_M_CODE_READ_1_DP_ENCODER1_P0_FLDMASK                        0xff
+#define AUDIO_M_CODE_READ_1_DP_ENCODER1_P0_FLDMASK_POS                    0
+#define AUDIO_M_CODE_READ_1_DP_ENCODER1_P0_FLDMASK_LEN                    8
+
+#define REG_33D8_DP_ENCODER1_P0              (0x33D8)
+#define VSC_EXT_CFG_DP_ENCODER1_P0_FLDMASK                                0xff
+#define VSC_EXT_CFG_DP_ENCODER1_P0_FLDMASK_POS                            0
+#define VSC_EXT_CFG_DP_ENCODER1_P0_FLDMASK_LEN                            8
+
+#define SDP_SPLIT_FIFO_EMPTY_DP_ENCODER1_P0_FLDMASK                       0x100
+#define SDP_SPLIT_FIFO_EMPTY_DP_ENCODER1_P0_FLDMASK_POS                   8
+#define SDP_SPLIT_FIFO_EMPTY_DP_ENCODER1_P0_FLDMASK_LEN                   1
+
+#define SDP_SPLIT_FIFO_FULL_DP_ENCODER1_P0_FLDMASK                        0x200
+#define SDP_SPLIT_FIFO_FULL_DP_ENCODER1_P0_FLDMASK_POS                    9
+#define SDP_SPLIT_FIFO_FULL_DP_ENCODER1_P0_FLDMASK_LEN                    1
+
+#define SDP_SPLIT_FIFO_FULL_CLR_DP_ENCODER1_P0_FLDMASK                    0x400
+#define SDP_SPLIT_FIFO_FULL_CLR_DP_ENCODER1_P0_FLDMASK_POS                10
+#define SDP_SPLIT_FIFO_FULL_CLR_DP_ENCODER1_P0_FLDMASK_LEN                1
+
+#define SDP_SPLIT_INSERT_INVALID_CNT_THRD_DP_ENCODER1_P0_FLDMASK          0xf000
+#define SDP_SPLIT_INSERT_INVALID_CNT_THRD_DP_ENCODER1_P0_FLDMASK_POS      12
+#define SDP_SPLIT_INSERT_INVALID_CNT_THRD_DP_ENCODER1_P0_FLDMASK_LEN      4
+
+#define REG_33DC_DP_ENCODER1_P0              (0x33DC)
+#define VIDEO_SRAM0_FULL_DP_ENCODER1_P0_FLDMASK                           0x1
+#define VIDEO_SRAM0_FULL_DP_ENCODER1_P0_FLDMASK_POS                       0
+#define VIDEO_SRAM0_FULL_DP_ENCODER1_P0_FLDMASK_LEN                       1
+
+#define VIDEO_SRAM0_FULL_CLR_DP_ENCODER1_P0_FLDMASK                       0x2
+#define VIDEO_SRAM0_FULL_CLR_DP_ENCODER1_P0_FLDMASK_POS                   1
+#define VIDEO_SRAM0_FULL_CLR_DP_ENCODER1_P0_FLDMASK_LEN                   1
+
+#define VIDEO_SRAM1_FULL_DP_ENCODER1_P0_FLDMASK                           0x4
+#define VIDEO_SRAM1_FULL_DP_ENCODER1_P0_FLDMASK_POS                       2
+#define VIDEO_SRAM1_FULL_DP_ENCODER1_P0_FLDMASK_LEN                       1
+
+#define VIDEO_SRAM1_FULL_CLR_DP_ENCODER1_P0_FLDMASK                       0x8
+#define VIDEO_SRAM1_FULL_CLR_DP_ENCODER1_P0_FLDMASK_POS                   3
+#define VIDEO_SRAM1_FULL_CLR_DP_ENCODER1_P0_FLDMASK_LEN                   1
+
+#define VIDEO_SRAM2_FULL_DP_ENCODER1_P0_FLDMASK                           0x10
+#define VIDEO_SRAM2_FULL_DP_ENCODER1_P0_FLDMASK_POS                       4
+#define VIDEO_SRAM2_FULL_DP_ENCODER1_P0_FLDMASK_LEN                       1
+
+#define VIDEO_SRAM2_FULL_CLR_DP_ENCODER1_P0_FLDMASK                       0x20
+#define VIDEO_SRAM2_FULL_CLR_DP_ENCODER1_P0_FLDMASK_POS                   5
+#define VIDEO_SRAM2_FULL_CLR_DP_ENCODER1_P0_FLDMASK_LEN                   1
+
+#define VIDEO_SRAM3_FULL_DP_ENCODER1_P0_FLDMASK                           0x40
+#define VIDEO_SRAM3_FULL_DP_ENCODER1_P0_FLDMASK_POS                       6
+#define VIDEO_SRAM3_FULL_DP_ENCODER1_P0_FLDMASK_LEN                       1
+
+#define VIDEO_SRAM3_FULL_CLR_DP_ENCODER1_P0_FLDMASK                       0x80
+#define VIDEO_SRAM3_FULL_CLR_DP_ENCODER1_P0_FLDMASK_POS                   7
+#define VIDEO_SRAM3_FULL_CLR_DP_ENCODER1_P0_FLDMASK_LEN                   1
+
+#define VIDEO_SRAM0_EMPTY_DP_ENCODER1_P0_FLDMASK                          0x100
+#define VIDEO_SRAM0_EMPTY_DP_ENCODER1_P0_FLDMASK_POS                      8
+#define VIDEO_SRAM0_EMPTY_DP_ENCODER1_P0_FLDMASK_LEN                      1
+
+#define VIDEO_SRAM0_EMPTY_CLR_DP_ENCODER1_P0_FLDMASK                      0x200
+#define VIDEO_SRAM0_EMPTY_CLR_DP_ENCODER1_P0_FLDMASK_POS                  9
+#define VIDEO_SRAM0_EMPTY_CLR_DP_ENCODER1_P0_FLDMASK_LEN                  1
+
+#define VIDEO_SRAM1_EMPTY_DP_ENCODER1_P0_FLDMASK                          0x400
+#define VIDEO_SRAM1_EMPTY_DP_ENCODER1_P0_FLDMASK_POS                      10
+#define VIDEO_SRAM1_EMPTY_DP_ENCODER1_P0_FLDMASK_LEN                      1
+
+#define VIDEO_SRAM1_EMPTY_CLR_DP_ENCODER1_P0_FLDMASK                      0x800
+#define VIDEO_SRAM1_EMPTY_CLR_DP_ENCODER1_P0_FLDMASK_POS                  11
+#define VIDEO_SRAM1_EMPTY_CLR_DP_ENCODER1_P0_FLDMASK_LEN                  1
+
+#define VIDEO_SRAM2_EMPTY_DP_ENCODER1_P0_FLDMASK                          0x1000
+#define VIDEO_SRAM2_EMPTY_DP_ENCODER1_P0_FLDMASK_POS                      12
+#define VIDEO_SRAM2_EMPTY_DP_ENCODER1_P0_FLDMASK_LEN                      1
+
+#define VIDEO_SRAM2_EMPTY_CLR_DP_ENCODER1_P0_FLDMASK                      0x2000
+#define VIDEO_SRAM2_EMPTY_CLR_DP_ENCODER1_P0_FLDMASK_POS                  13
+#define VIDEO_SRAM2_EMPTY_CLR_DP_ENCODER1_P0_FLDMASK_LEN                  1
+
+#define VIDEO_SRAM3_EMPTY_DP_ENCODER1_P0_FLDMASK                          0x4000
+#define VIDEO_SRAM3_EMPTY_DP_ENCODER1_P0_FLDMASK_POS                      14
+#define VIDEO_SRAM3_EMPTY_DP_ENCODER1_P0_FLDMASK_LEN                      1
+
+#define VIDEO_SRAM3_EMPTY_CLR_DP_ENCODER1_P0_FLDMASK                      0x8000
+#define VIDEO_SRAM3_EMPTY_CLR_DP_ENCODER1_P0_FLDMASK_POS                  15
+#define VIDEO_SRAM3_EMPTY_CLR_DP_ENCODER1_P0_FLDMASK_LEN                  1
+
+#define REG_33E0_DP_ENCODER1_P0              (0x33E0)
+#define BS2BS_CNT_SW_DP_ENCODER1_P0_FLDMASK                               0xffff
+#define BS2BS_CNT_SW_DP_ENCODER1_P0_FLDMASK_POS                           0
+#define BS2BS_CNT_SW_DP_ENCODER1_P0_FLDMASK_LEN                           16
+
+#define REG_33E4_DP_ENCODER1_P0              (0x33E4)
+#define MIXER_STATE_0_DP_ENCODER1_P0_FLDMASK                              0xffff
+#define MIXER_STATE_0_DP_ENCODER1_P0_FLDMASK_POS                          0
+#define MIXER_STATE_0_DP_ENCODER1_P0_FLDMASK_LEN                          16
+
+#define REG_33E8_DP_ENCODER1_P0              (0x33E8)
+#define MIXER_STATE_1_DP_ENCODER1_P0_FLDMASK                              0xffff
+#define MIXER_STATE_1_DP_ENCODER1_P0_FLDMASK_POS                          0
+#define MIXER_STATE_1_DP_ENCODER1_P0_FLDMASK_LEN                          16
+
+#define REG_33EC_DP_ENCODER1_P0              (0x33EC)
+#define MIXER_STATE_2_DP_ENCODER1_P0_FLDMASK                              0xff
+#define MIXER_STATE_2_DP_ENCODER1_P0_FLDMASK_POS                          0
+#define MIXER_STATE_2_DP_ENCODER1_P0_FLDMASK_LEN                          8
+
+#define VIDEO_PERIOD_ENABLE_DP_ENCODER1_P0_FLDMASK                        0x200
+#define VIDEO_PERIOD_ENABLE_DP_ENCODER1_P0_FLDMASK_POS                    9
+#define VIDEO_PERIOD_ENABLE_DP_ENCODER1_P0_FLDMASK_LEN                    1
+
+#define BS2BS_CNT_SW_SEL_DP_ENCODER1_P0_FLDMASK                           0x400
+#define BS2BS_CNT_SW_SEL_DP_ENCODER1_P0_FLDMASK_POS                       10
+#define BS2BS_CNT_SW_SEL_DP_ENCODER1_P0_FLDMASK_LEN                       1
+
+#define AUDIO_SRAM_FULL_DP_ENCODER1_P0_FLDMASK                            0x800
+#define AUDIO_SRAM_FULL_DP_ENCODER1_P0_FLDMASK_POS                        11
+#define AUDIO_SRAM_FULL_DP_ENCODER1_P0_FLDMASK_LEN                        1
+
+#define AUDIO_SRAM_FULL_CLR_DP_ENCODER1_P0_FLDMASK                        0x1000
+#define AUDIO_SRAM_FULL_CLR_DP_ENCODER1_P0_FLDMASK_POS                    12
+#define AUDIO_SRAM_FULL_CLR_DP_ENCODER1_P0_FLDMASK_LEN                    1
+
+#define AUDIO_SRAM_EMPTY_DP_ENCODER1_P0_FLDMASK                           0x2000
+#define AUDIO_SRAM_EMPTY_DP_ENCODER1_P0_FLDMASK_POS                       13
+#define AUDIO_SRAM_EMPTY_DP_ENCODER1_P0_FLDMASK_LEN                       1
+
+#define REG_33F0_DP_ENCODER1_P0              (0x33F0)
+#define DP_ENCODER_DUMMY_RW_0_DP_ENCODER1_P0_FLDMASK                      0xffff
+#define DP_ENCODER_DUMMY_RW_0_DP_ENCODER1_P0_FLDMASK_POS                  0
+#define DP_ENCODER_DUMMY_RW_0_DP_ENCODER1_P0_FLDMASK_LEN                  16
+
+#define REG_33F4_DP_ENCODER1_P0              (0x33F4)
+#define DP_ENCODER_DUMMY_RW_1_DP_ENCODER1_P0_FLDMASK                      0xffff
+#define DP_ENCODER_DUMMY_RW_1_DP_ENCODER1_P0_FLDMASK_POS                  0
+#define DP_ENCODER_DUMMY_RW_1_DP_ENCODER1_P0_FLDMASK_LEN                  16
+
+#define REG_33F8_DP_ENCODER1_P0              (0x33F8)
+#define DP_ENCODER_DUMMY_R_0_DP_ENCODER1_P0_FLDMASK                       0xffff
+#define DP_ENCODER_DUMMY_R_0_DP_ENCODER1_P0_FLDMASK_POS                   0
+#define DP_ENCODER_DUMMY_R_0_DP_ENCODER1_P0_FLDMASK_LEN                   16
+
+#define REG_33FC_DP_ENCODER1_P0              (0x33FC)
+#define DP_ENCODER_DUMMY_R_1_DP_ENCODER1_P0_FLDMASK                       0xffff
+#define DP_ENCODER_DUMMY_R_1_DP_ENCODER1_P0_FLDMASK_POS                   0
+#define DP_ENCODER_DUMMY_R_1_DP_ENCODER1_P0_FLDMASK_LEN                   16
+
+#define REG_3400_DP_TRANS_P0              (0x3400)
+#define PRE_MISC_LANE0_MUX_DP_TRANS_P0_FLDMASK                            0x3
+#define PRE_MISC_LANE0_MUX_DP_TRANS_P0_FLDMASK_POS                        0
+#define PRE_MISC_LANE0_MUX_DP_TRANS_P0_FLDMASK_LEN                        2
+
+#define PRE_MISC_LANE1_MUX_DP_TRANS_P0_FLDMASK                            0xc
+#define PRE_MISC_LANE1_MUX_DP_TRANS_P0_FLDMASK_POS                        2
+#define PRE_MISC_LANE1_MUX_DP_TRANS_P0_FLDMASK_LEN                        2
+
+#define PRE_MISC_LANE2_MUX_DP_TRANS_P0_FLDMASK                            0x30
+#define PRE_MISC_LANE2_MUX_DP_TRANS_P0_FLDMASK_POS                        4
+#define PRE_MISC_LANE2_MUX_DP_TRANS_P0_FLDMASK_LEN                        2
+
+#define PRE_MISC_LANE3_MUX_DP_TRANS_P0_FLDMASK                            0xc0
+#define PRE_MISC_LANE3_MUX_DP_TRANS_P0_FLDMASK_POS                        6
+#define PRE_MISC_LANE3_MUX_DP_TRANS_P0_FLDMASK_LEN                        2
+
+#define PRE_MISC_PORT_MUX_DP_TRANS_P0_FLDMASK                             0x700
+#define PRE_MISC_PORT_MUX_DP_TRANS_P0_FLDMASK_POS                         8
+#define PRE_MISC_PORT_MUX_DP_TRANS_P0_FLDMASK_LEN                         3
+
+#define HDCP_SEL_DP_TRANS_P0_FLDMASK                                      0x800
+#define HDCP_SEL_DP_TRANS_P0_FLDMASK_POS                                  11
+#define HDCP_SEL_DP_TRANS_P0_FLDMASK_LEN                                  1
+
+#define PATTERN1_EN_DP_TRANS_P0_FLDMASK                                   0x1000
+#define PATTERN1_EN_DP_TRANS_P0_FLDMASK_POS                               12
+#define PATTERN1_EN_DP_TRANS_P0_FLDMASK_LEN                               1
+
+#define PATTERN2_EN_DP_TRANS_P0_FLDMASK                                   0x2000
+#define PATTERN2_EN_DP_TRANS_P0_FLDMASK_POS                               13
+#define PATTERN2_EN_DP_TRANS_P0_FLDMASK_LEN                               1
+
+#define PATTERN3_EN_DP_TRANS_P0_FLDMASK                                   0x4000
+#define PATTERN3_EN_DP_TRANS_P0_FLDMASK_POS                               14
+#define PATTERN3_EN_DP_TRANS_P0_FLDMASK_LEN                               1
+
+#define PATTERN4_EN_DP_TRANS_P0_FLDMASK                                   0x8000
+#define PATTERN4_EN_DP_TRANS_P0_FLDMASK_POS                               15
+#define PATTERN4_EN_DP_TRANS_P0_FLDMASK_LEN                               1
+
+#define REG_3404_DP_TRANS_P0              (0x3404)
+#define DP_SCR_EN_DP_TRANS_P0_FLDMASK                                     0x1
+#define DP_SCR_EN_DP_TRANS_P0_FLDMASK_POS                                 0
+#define DP_SCR_EN_DP_TRANS_P0_FLDMASK_LEN                                 1
+
+#define ALTER_SCRAMBLER_RESET_EN_DP_TRANS_P0_FLDMASK                      0x2
+#define ALTER_SCRAMBLER_RESET_EN_DP_TRANS_P0_FLDMASK_POS                  1
+#define ALTER_SCRAMBLER_RESET_EN_DP_TRANS_P0_FLDMASK_LEN                  1
+
+#define SCRAMB_BYPASS_IN_EN_DP_TRANS_P0_FLDMASK                           0x4
+#define SCRAMB_BYPASS_IN_EN_DP_TRANS_P0_FLDMASK_POS                       2
+#define SCRAMB_BYPASS_IN_EN_DP_TRANS_P0_FLDMASK_LEN                       1
+
+#define SCRAMB_BYPASS_MASK_DP_TRANS_P0_FLDMASK                            0x8
+#define SCRAMB_BYPASS_MASK_DP_TRANS_P0_FLDMASK_POS                        3
+#define SCRAMB_BYPASS_MASK_DP_TRANS_P0_FLDMASK_LEN                        1
+
+#define INDEX_SCR_MODE_DP_TRANS_P0_FLDMASK                                0x30
+#define INDEX_SCR_MODE_DP_TRANS_P0_FLDMASK_POS                            4
+#define INDEX_SCR_MODE_DP_TRANS_P0_FLDMASK_LEN                            2
+
+#define PAT_INIT_DISPARITY_DP_TRANS_P0_FLDMASK                            0x40
+#define PAT_INIT_DISPARITY_DP_TRANS_P0_FLDMASK_POS                        6
+#define PAT_INIT_DISPARITY_DP_TRANS_P0_FLDMASK_LEN                        1
+
+#define TPS_DISPARITY_RESET_DP_TRANS_P0_FLDMASK                           0x80
+#define TPS_DISPARITY_RESET_DP_TRANS_P0_FLDMASK_POS                       7
+#define TPS_DISPARITY_RESET_DP_TRANS_P0_FLDMASK_LEN                       1
+
+#define REG_3408_DP_TRANS_P0              (0x3408)
+#define LANE_SKEW_SEL_LANE0_DP_TRANS_P0_FLDMASK                           0x3
+#define LANE_SKEW_SEL_LANE0_DP_TRANS_P0_FLDMASK_POS                       0
+#define LANE_SKEW_SEL_LANE0_DP_TRANS_P0_FLDMASK_LEN                       2
+
+#define LANE_SKEW_SEL_LANE1_DP_TRANS_P0_FLDMASK                           0xc
+#define LANE_SKEW_SEL_LANE1_DP_TRANS_P0_FLDMASK_POS                       2
+#define LANE_SKEW_SEL_LANE1_DP_TRANS_P0_FLDMASK_LEN                       2
+
+#define LANE_SKEW_SEL_LANE2_DP_TRANS_P0_FLDMASK                           0x30
+#define LANE_SKEW_SEL_LANE2_DP_TRANS_P0_FLDMASK_POS                       4
+#define LANE_SKEW_SEL_LANE2_DP_TRANS_P0_FLDMASK_LEN                       2
+
+#define LANE_SKEW_SEL_LANE3_DP_TRANS_P0_FLDMASK                           0xc0
+#define LANE_SKEW_SEL_LANE3_DP_TRANS_P0_FLDMASK_POS                       6
+#define LANE_SKEW_SEL_LANE3_DP_TRANS_P0_FLDMASK_LEN                       2
+
+#define POST_MISC_LANE0_MUX_DP_TRANS_P0_FLDMASK                           0x300
+#define POST_MISC_LANE0_MUX_DP_TRANS_P0_FLDMASK_POS                       8
+#define POST_MISC_LANE0_MUX_DP_TRANS_P0_FLDMASK_LEN                       2
+
+#define POST_MISC_LANE1_MUX_DP_TRANS_P0_FLDMASK                           0xc00
+#define POST_MISC_LANE1_MUX_DP_TRANS_P0_FLDMASK_POS                       10
+#define POST_MISC_LANE1_MUX_DP_TRANS_P0_FLDMASK_LEN                       2
+
+#define POST_MISC_LANE2_MUX_DP_TRANS_P0_FLDMASK                           0x3000
+#define POST_MISC_LANE2_MUX_DP_TRANS_P0_FLDMASK_POS                       12
+#define POST_MISC_LANE2_MUX_DP_TRANS_P0_FLDMASK_LEN                       2
+
+#define POST_MISC_LANE3_MUX_DP_TRANS_P0_FLDMASK                           0xc000
+#define POST_MISC_LANE3_MUX_DP_TRANS_P0_FLDMASK_POS                       14
+#define POST_MISC_LANE3_MUX_DP_TRANS_P0_FLDMASK_LEN                       2
+
+#define REG_340C_DP_TRANS_P0              (0x340C)
+#define TOP_RESET_SW_DP_TRANS_P0_FLDMASK                                  0x100
+#define TOP_RESET_SW_DP_TRANS_P0_FLDMASK_POS                              8
+#define TOP_RESET_SW_DP_TRANS_P0_FLDMASK_LEN                              1
+
+#define LANE0_RESET_SW_DP_TRANS_P0_FLDMASK                                0x200
+#define LANE0_RESET_SW_DP_TRANS_P0_FLDMASK_POS                            9
+#define LANE0_RESET_SW_DP_TRANS_P0_FLDMASK_LEN                            1
+
+#define LANE1_RESET_SW_DP_TRANS_P0_FLDMASK                                0x400
+#define LANE1_RESET_SW_DP_TRANS_P0_FLDMASK_POS                            10
+#define LANE1_RESET_SW_DP_TRANS_P0_FLDMASK_LEN                            1
+
+#define LANE2_RESET_SW_DP_TRANS_P0_FLDMASK                                0x800
+#define LANE2_RESET_SW_DP_TRANS_P0_FLDMASK_POS                            11
+#define LANE2_RESET_SW_DP_TRANS_P0_FLDMASK_LEN                            1
+
+#define LANE3_RESET_SW_DP_TRANS_P0_FLDMASK                                0x1000
+#define LANE3_RESET_SW_DP_TRANS_P0_FLDMASK_POS                            12
+#define LANE3_RESET_SW_DP_TRANS_P0_FLDMASK_LEN                            1
+
+#define DP_TX_TRANSMITTER_4P_RESET_SW_DP_TRANS_P0_FLDMASK                 0x2000
+#define DP_TX_TRANSMITTER_4P_RESET_SW_DP_TRANS_P0_FLDMASK_POS             13
+#define DP_TX_TRANSMITTER_4P_RESET_SW_DP_TRANS_P0_FLDMASK_LEN             1
+
+#define HDCP13_RST_SW_DP_TRANS_P0_FLDMASK                                 0x4000
+#define HDCP13_RST_SW_DP_TRANS_P0_FLDMASK_POS                             14
+#define HDCP13_RST_SW_DP_TRANS_P0_FLDMASK_LEN                             1
+
+#define HDCP22_RST_SW_DP_TRANS_P0_FLDMASK                                 0x8000
+#define HDCP22_RST_SW_DP_TRANS_P0_FLDMASK_POS                             15
+#define HDCP22_RST_SW_DP_TRANS_P0_FLDMASK_LEN                             1
+
+#define REG_3410_DP_TRANS_P0              (0x3410)
+#define HPD_DEB_THD_DP_TRANS_P0_FLDMASK                                   0xf
+#define HPD_DEB_THD_DP_TRANS_P0_FLDMASK_POS                               0
+#define HPD_DEB_THD_DP_TRANS_P0_FLDMASK_LEN                               4
+
+#define HPD_INT_THD_DP_TRANS_P0_FLDMASK                                   0xf0
+#define HPD_INT_THD_DP_TRANS_P0_FLDMASK_POS                               4
+#define HPD_INT_THD_DP_TRANS_P0_FLDMASK_LEN                               4
+
+#define HPD_DISC_THD_DP_TRANS_P0_FLDMASK                                  0xf00
+#define HPD_DISC_THD_DP_TRANS_P0_FLDMASK_POS                              8
+#define HPD_DISC_THD_DP_TRANS_P0_FLDMASK_LEN                              4
+
+#define HPD_CONN_THD_DP_TRANS_P0_FLDMASK                                  0xf000
+#define HPD_CONN_THD_DP_TRANS_P0_FLDMASK_POS                              12
+#define HPD_CONN_THD_DP_TRANS_P0_FLDMASK_LEN                              4
+
+#define REG_3414_DP_TRANS_P0              (0x3414)
+#define HPD_OVR_EN_DP_TRANS_P0_FLDMASK                                    0x1
+#define HPD_OVR_EN_DP_TRANS_P0_FLDMASK_POS                                0
+#define HPD_OVR_EN_DP_TRANS_P0_FLDMASK_LEN                                1
+
+#define HPD_SET_DP_TRANS_P0_FLDMASK                                       0x2
+#define HPD_SET_DP_TRANS_P0_FLDMASK_POS                                   1
+#define HPD_SET_DP_TRANS_P0_FLDMASK_LEN                                   1
+
+#define HPD_DB_DP_TRANS_P0_FLDMASK                                        0x4
+#define HPD_DB_DP_TRANS_P0_FLDMASK_POS                                    2
+#define HPD_DB_DP_TRANS_P0_FLDMASK_LEN                                    1
+
+#define REG_3418_DP_TRANS_P0              (0x3418)
+#define IRQ_CLR_DP_TRANS_P0_FLDMASK                                       0xf
+#define IRQ_CLR_DP_TRANS_P0_FLDMASK_POS                                   0
+#define IRQ_CLR_DP_TRANS_P0_FLDMASK_LEN                                   4
+
+#define IRQ_MASK_DP_TRANS_P0_FLDMASK                                      0xf0
+#define IRQ_MASK_DP_TRANS_P0_FLDMASK_POS                                  4
+#define IRQ_MASK_DP_TRANS_P0_FLDMASK_LEN                                  4
+
+#define IRQ_FORCE_DP_TRANS_P0_FLDMASK                                     0xf00
+#define IRQ_FORCE_DP_TRANS_P0_FLDMASK_POS                                 8
+#define IRQ_FORCE_DP_TRANS_P0_FLDMASK_LEN                                 4
+
+#define IRQ_STATUS_DP_TRANS_P0_FLDMASK                                    0xf000
+#define IRQ_STATUS_DP_TRANS_P0_FLDMASK_POS                                12
+#define IRQ_STATUS_DP_TRANS_P0_FLDMASK_LEN                                4
+
+#define REG_341C_DP_TRANS_P0              (0x341C)
+#define IRQ_CLR_51_DP_TRANS_P0_FLDMASK                                    0xf
+#define IRQ_CLR_51_DP_TRANS_P0_FLDMASK_POS                                0
+#define IRQ_CLR_51_DP_TRANS_P0_FLDMASK_LEN                                4
+
+#define IRQ_MASK_51_DP_TRANS_P0_FLDMASK                                   0xf0
+#define IRQ_MASK_51_DP_TRANS_P0_FLDMASK_POS                               4
+#define IRQ_MASK_51_DP_TRANS_P0_FLDMASK_LEN                               4
+
+#define IRQ_FORCE_51_DP_TRANS_P0_FLDMASK                                  0xf00
+#define IRQ_FORCE_51_DP_TRANS_P0_FLDMASK_POS                              8
+#define IRQ_FORCE_51_DP_TRANS_P0_FLDMASK_LEN                              4
+
+#define IRQ_STATUS_51_DP_TRANS_P0_FLDMASK                                 0xf000
+#define IRQ_STATUS_51_DP_TRANS_P0_FLDMASK_POS                             12
+#define IRQ_STATUS_51_DP_TRANS_P0_FLDMASK_LEN                             4
+
+#define REG_3420_DP_TRANS_P0              (0x3420)
+#define HPD_STATUS_DP_TRANS_P0_FLDMASK                                    0x1
+#define HPD_STATUS_DP_TRANS_P0_FLDMASK_POS                                0
+#define HPD_STATUS_DP_TRANS_P0_FLDMASK_LEN                                1
+
+#define REG_3428_DP_TRANS_P0              (0x3428)
+#define POST_MISC_BIT_REVERSE_EN_LANE0_DP_TRANS_P0_FLDMASK                0x1
+#define POST_MISC_BIT_REVERSE_EN_LANE0_DP_TRANS_P0_FLDMASK_POS            0
+#define POST_MISC_BIT_REVERSE_EN_LANE0_DP_TRANS_P0_FLDMASK_LEN            1
+
+#define POST_MISC_BIT_REVERSE_EN_LANE1_DP_TRANS_P0_FLDMASK                0x2
+#define POST_MISC_BIT_REVERSE_EN_LANE1_DP_TRANS_P0_FLDMASK_POS            1
+#define POST_MISC_BIT_REVERSE_EN_LANE1_DP_TRANS_P0_FLDMASK_LEN            1
+
+#define POST_MISC_BIT_REVERSE_EN_LANE2_DP_TRANS_P0_FLDMASK                0x4
+#define POST_MISC_BIT_REVERSE_EN_LANE2_DP_TRANS_P0_FLDMASK_POS            2
+#define POST_MISC_BIT_REVERSE_EN_LANE2_DP_TRANS_P0_FLDMASK_LEN            1
+
+#define POST_MISC_BIT_REVERSE_EN_LANE3_DP_TRANS_P0_FLDMASK                0x8
+#define POST_MISC_BIT_REVERSE_EN_LANE3_DP_TRANS_P0_FLDMASK_POS            3
+#define POST_MISC_BIT_REVERSE_EN_LANE3_DP_TRANS_P0_FLDMASK_LEN            1
+
+#define POST_MISC_PN_SWAP_EN_LANE0_DP_TRANS_P0_FLDMASK                    0x10
+#define POST_MISC_PN_SWAP_EN_LANE0_DP_TRANS_P0_FLDMASK_POS                4
+#define POST_MISC_PN_SWAP_EN_LANE0_DP_TRANS_P0_FLDMASK_LEN                1
+
+#define POST_MISC_PN_SWAP_EN_LANE1_DP_TRANS_P0_FLDMASK                    0x20
+#define POST_MISC_PN_SWAP_EN_LANE1_DP_TRANS_P0_FLDMASK_POS                5
+#define POST_MISC_PN_SWAP_EN_LANE1_DP_TRANS_P0_FLDMASK_LEN                1
+
+#define POST_MISC_PN_SWAP_EN_LANE2_DP_TRANS_P0_FLDMASK                    0x40
+#define POST_MISC_PN_SWAP_EN_LANE2_DP_TRANS_P0_FLDMASK_POS                6
+#define POST_MISC_PN_SWAP_EN_LANE2_DP_TRANS_P0_FLDMASK_LEN                1
+
+#define POST_MISC_PN_SWAP_EN_LANE3_DP_TRANS_P0_FLDMASK                    0x80
+#define POST_MISC_PN_SWAP_EN_LANE3_DP_TRANS_P0_FLDMASK_POS                7
+#define POST_MISC_PN_SWAP_EN_LANE3_DP_TRANS_P0_FLDMASK_LEN                1
+
+#define POST_MISC_DATA_SWAP_EN_LANE0_DP_TRANS_P0_FLDMASK                  0x100
+#define POST_MISC_DATA_SWAP_EN_LANE0_DP_TRANS_P0_FLDMASK_POS              8
+#define POST_MISC_DATA_SWAP_EN_LANE0_DP_TRANS_P0_FLDMASK_LEN              1
+
+#define POST_MISC_DATA_SWAP_EN_LANE1_DP_TRANS_P0_FLDMASK                  0x200
+#define POST_MISC_DATA_SWAP_EN_LANE1_DP_TRANS_P0_FLDMASK_POS              9
+#define POST_MISC_DATA_SWAP_EN_LANE1_DP_TRANS_P0_FLDMASK_LEN              1
+
+#define POST_MISC_DATA_SWAP_EN_LANE2_DP_TRANS_P0_FLDMASK                  0x400
+#define POST_MISC_DATA_SWAP_EN_LANE2_DP_TRANS_P0_FLDMASK_POS              10
+#define POST_MISC_DATA_SWAP_EN_LANE2_DP_TRANS_P0_FLDMASK_LEN              1
+
+#define POST_MISC_DATA_SWAP_EN_LANE3_DP_TRANS_P0_FLDMASK                  0x800
+#define POST_MISC_DATA_SWAP_EN_LANE3_DP_TRANS_P0_FLDMASK_POS              11
+#define POST_MISC_DATA_SWAP_EN_LANE3_DP_TRANS_P0_FLDMASK_LEN              1
+
+#define REG_342C_DP_TRANS_P0              (0x342C)
+#define XTAL_FREQ_DP_TRANS_P0_FLDMASK                                     0xff
+#define XTAL_FREQ_DP_TRANS_P0_FLDMASK_POS                                 0
+#define XTAL_FREQ_DP_TRANS_P0_FLDMASK_LEN                                 8
+
+#define REG_3430_DP_TRANS_P0              (0x3430)
+#define HPD_INT_THD_ECO_DP_TRANS_P0_FLDMASK                               0x3
+#define HPD_INT_THD_ECO_DP_TRANS_P0_FLDMASK_POS                           0
+#define HPD_INT_THD_ECO_DP_TRANS_P0_FLDMASK_LEN                           2
+
+#define REG_3440_DP_TRANS_P0              (0x3440)
+#define PGM_PAT_EN_DP_TRANS_P0_FLDMASK                                    0xf
+#define PGM_PAT_EN_DP_TRANS_P0_FLDMASK_POS                                0
+#define PGM_PAT_EN_DP_TRANS_P0_FLDMASK_LEN                                4
+
+#define PGM_PAT_SEL_L0_DP_TRANS_P0_FLDMASK                                0x70
+#define PGM_PAT_SEL_L0_DP_TRANS_P0_FLDMASK_POS                            4
+#define PGM_PAT_SEL_L0_DP_TRANS_P0_FLDMASK_LEN                            3
+
+#define PGM_PAT_SEL_L1_DP_TRANS_P0_FLDMASK                                0x700
+#define PGM_PAT_SEL_L1_DP_TRANS_P0_FLDMASK_POS                            8
+#define PGM_PAT_SEL_L1_DP_TRANS_P0_FLDMASK_LEN                            3
+
+#define PGM_PAT_SEL_L2_DP_TRANS_P0_FLDMASK                                0x7000
+#define PGM_PAT_SEL_L2_DP_TRANS_P0_FLDMASK_POS                            12
+#define PGM_PAT_SEL_L2_DP_TRANS_P0_FLDMASK_LEN                            3
+
+#define REG_3444_DP_TRANS_P0              (0x3444)
+#define PGM_PAT_SEL_L3_DP_TRANS_P0_FLDMASK                                0x7
+#define PGM_PAT_SEL_L3_DP_TRANS_P0_FLDMASK_POS                            0
+#define PGM_PAT_SEL_L3_DP_TRANS_P0_FLDMASK_LEN                            3
+
+#define PRBS_EN_DP_TRANS_P0_FLDMASK                                       0x8
+#define PRBS_EN_DP_TRANS_P0_FLDMASK_POS                                   3
+#define PRBS_EN_DP_TRANS_P0_FLDMASK_LEN                                   1
+
+#define REG_3448_DP_TRANS_P0              (0x3448)
+#define PGM_PAT_L0_0_DP_TRANS_P0_FLDMASK                                  0xffff
+#define PGM_PAT_L0_0_DP_TRANS_P0_FLDMASK_POS                              0
+#define PGM_PAT_L0_0_DP_TRANS_P0_FLDMASK_LEN                              16
+
+#define REG_344C_DP_TRANS_P0              (0x344C)
+#define PGM_PAT_L0_1_DP_TRANS_P0_FLDMASK                                  0xffff
+#define PGM_PAT_L0_1_DP_TRANS_P0_FLDMASK_POS                              0
+#define PGM_PAT_L0_1_DP_TRANS_P0_FLDMASK_LEN                              16
+
+#define REG_3450_DP_TRANS_P0              (0x3450)
+#define PGM_PAT_L0_2_DP_TRANS_P0_FLDMASK                                  0xff
+#define PGM_PAT_L0_2_DP_TRANS_P0_FLDMASK_POS                              0
+#define PGM_PAT_L0_2_DP_TRANS_P0_FLDMASK_LEN                              8
+
+#define REG_3454_DP_TRANS_P0              (0x3454)
+#define PGM_PAT_L1_0_DP_TRANS_P0_FLDMASK                                  0xffff
+#define PGM_PAT_L1_0_DP_TRANS_P0_FLDMASK_POS                              0
+#define PGM_PAT_L1_0_DP_TRANS_P0_FLDMASK_LEN                              16
+
+#define REG_3458_DP_TRANS_P0              (0x3458)
+#define PGM_PAT_L1_1_DP_TRANS_P0_FLDMASK                                  0xffff
+#define PGM_PAT_L1_1_DP_TRANS_P0_FLDMASK_POS                              0
+#define PGM_PAT_L1_1_DP_TRANS_P0_FLDMASK_LEN                              16
+
+#define REG_345C_DP_TRANS_P0              (0x345C)
+#define PGM_PAT_L1_2_DP_TRANS_P0_FLDMASK                                  0xff
+#define PGM_PAT_L1_2_DP_TRANS_P0_FLDMASK_POS                              0
+#define PGM_PAT_L1_2_DP_TRANS_P0_FLDMASK_LEN                              8
+
+#define REG_3460_DP_TRANS_P0              (0x3460)
+#define PGM_PAT_L2_0_DP_TRANS_P0_FLDMASK                                  0xffff
+#define PGM_PAT_L2_0_DP_TRANS_P0_FLDMASK_POS                              0
+#define PGM_PAT_L2_0_DP_TRANS_P0_FLDMASK_LEN                              16
+
+#define REG_3464_DP_TRANS_P0              (0x3464)
+#define PGM_PAT_L2_1_DP_TRANS_P0_FLDMASK                                  0xffff
+#define PGM_PAT_L2_1_DP_TRANS_P0_FLDMASK_POS                              0
+#define PGM_PAT_L2_1_DP_TRANS_P0_FLDMASK_LEN                              16
+
+#define REG_3468_DP_TRANS_P0              (0x3468)
+#define PGM_PAT_L2_2_DP_TRANS_P0_FLDMASK                                  0xff
+#define PGM_PAT_L2_2_DP_TRANS_P0_FLDMASK_POS                              0
+#define PGM_PAT_L2_2_DP_TRANS_P0_FLDMASK_LEN                              8
+
+#define REG_346C_DP_TRANS_P0              (0x346C)
+#define PGM_PAT_L3_0_DP_TRANS_P0_FLDMASK                                  0xffff
+#define PGM_PAT_L3_0_DP_TRANS_P0_FLDMASK_POS                              0
+#define PGM_PAT_L3_0_DP_TRANS_P0_FLDMASK_LEN                              16
+
+#define REG_3470_DP_TRANS_P0              (0x3470)
+#define PGM_PAT_L3_1_DP_TRANS_P0_FLDMASK                                  0xffff
+#define PGM_PAT_L3_1_DP_TRANS_P0_FLDMASK_POS                              0
+#define PGM_PAT_L3_1_DP_TRANS_P0_FLDMASK_LEN                              16
+
+#define REG_3474_DP_TRANS_P0              (0x3474)
+#define PGM_PAT_L3_2_DP_TRANS_P0_FLDMASK                                  0xff
+#define PGM_PAT_L3_2_DP_TRANS_P0_FLDMASK_POS                              0
+#define PGM_PAT_L3_2_DP_TRANS_P0_FLDMASK_LEN                              8
+
+#define REG_3478_DP_TRANS_P0              (0x3478)
+#define CP2520_PATTERN1_DP_TRANS_P0_FLDMASK                               0x1
+#define CP2520_PATTERN1_DP_TRANS_P0_FLDMASK_POS                           0
+#define CP2520_PATTERN1_DP_TRANS_P0_FLDMASK_LEN                           1
+
+#define CP2520_PATTERN2_DP_TRANS_P0_FLDMASK                               0x2
+#define CP2520_PATTERN2_DP_TRANS_P0_FLDMASK_POS                           1
+#define CP2520_PATTERN2_DP_TRANS_P0_FLDMASK_LEN                           1
+
+#define CP2520_PATTERN1_KCODE_ERROR_LANE0_DP_TRANS_P0_FLDMASK             0x10
+#define CP2520_PATTERN1_KCODE_ERROR_LANE0_DP_TRANS_P0_FLDMASK_POS         4
+#define CP2520_PATTERN1_KCODE_ERROR_LANE0_DP_TRANS_P0_FLDMASK_LEN         1
+
+#define CP2520_PATTERN1_KCODE_ERROR_LANE1_DP_TRANS_P0_FLDMASK             0x20
+#define CP2520_PATTERN1_KCODE_ERROR_LANE1_DP_TRANS_P0_FLDMASK_POS         5
+#define CP2520_PATTERN1_KCODE_ERROR_LANE1_DP_TRANS_P0_FLDMASK_LEN         1
+
+#define CP2520_PATTERN1_KCODE_ERROR_LANE2_DP_TRANS_P0_FLDMASK             0x40
+#define CP2520_PATTERN1_KCODE_ERROR_LANE2_DP_TRANS_P0_FLDMASK_POS         6
+#define CP2520_PATTERN1_KCODE_ERROR_LANE2_DP_TRANS_P0_FLDMASK_LEN         1
+
+#define CP2520_PATTERN1_KCODE_ERROR_LANE3_DP_TRANS_P0_FLDMASK             0x80
+#define CP2520_PATTERN1_KCODE_ERROR_LANE3_DP_TRANS_P0_FLDMASK_POS         7
+#define CP2520_PATTERN1_KCODE_ERROR_LANE3_DP_TRANS_P0_FLDMASK_LEN         1
+
+#define CP2520_PATTERN1_DCODE_ERROR_LANE0_DP_TRANS_P0_FLDMASK             0x100
+#define CP2520_PATTERN1_DCODE_ERROR_LANE0_DP_TRANS_P0_FLDMASK_POS         8
+#define CP2520_PATTERN1_DCODE_ERROR_LANE0_DP_TRANS_P0_FLDMASK_LEN         1
+
+#define CP2520_PATTERN1_DCODE_ERROR_LANE1_DP_TRANS_P0_FLDMASK             0x200
+#define CP2520_PATTERN1_DCODE_ERROR_LANE1_DP_TRANS_P0_FLDMASK_POS         9
+#define CP2520_PATTERN1_DCODE_ERROR_LANE1_DP_TRANS_P0_FLDMASK_LEN         1
+
+#define CP2520_PATTERN1_DCODE_ERROR_LANE2_DP_TRANS_P0_FLDMASK             0x400
+#define CP2520_PATTERN1_DCODE_ERROR_LANE2_DP_TRANS_P0_FLDMASK_POS         10
+#define CP2520_PATTERN1_DCODE_ERROR_LANE2_DP_TRANS_P0_FLDMASK_LEN         1
+
+#define CP2520_PATTERN1_DCODE_ERROR_LANE3_DP_TRANS_P0_FLDMASK             0x800
+#define CP2520_PATTERN1_DCODE_ERROR_LANE3_DP_TRANS_P0_FLDMASK_POS         11
+#define CP2520_PATTERN1_DCODE_ERROR_LANE3_DP_TRANS_P0_FLDMASK_LEN         1
+
+#define REG_347C_DP_TRANS_P0              (0x347C)
+#define CP2520_PATTERN2_KCODE_ERROR_LANE0_DP_TRANS_P0_FLDMASK             0x1
+#define CP2520_PATTERN2_KCODE_ERROR_LANE0_DP_TRANS_P0_FLDMASK_POS         0
+#define CP2520_PATTERN2_KCODE_ERROR_LANE0_DP_TRANS_P0_FLDMASK_LEN         1
+
+#define CP2520_PATTERN2_KCODE_ERROR_LANE1_DP_TRANS_P0_FLDMASK             0x2
+#define CP2520_PATTERN2_KCODE_ERROR_LANE1_DP_TRANS_P0_FLDMASK_POS         1
+#define CP2520_PATTERN2_KCODE_ERROR_LANE1_DP_TRANS_P0_FLDMASK_LEN         1
+
+#define CP2520_PATTERN2_KCODE_ERROR_LANE2_DP_TRANS_P0_FLDMASK             0x4
+#define CP2520_PATTERN2_KCODE_ERROR_LANE2_DP_TRANS_P0_FLDMASK_POS         2
+#define CP2520_PATTERN2_KCODE_ERROR_LANE2_DP_TRANS_P0_FLDMASK_LEN         1
+
+#define CP2520_PATTERN2_KCODE_ERROR_LANE3_DP_TRANS_P0_FLDMASK             0x8
+#define CP2520_PATTERN2_KCODE_ERROR_LANE3_DP_TRANS_P0_FLDMASK_POS         3
+#define CP2520_PATTERN2_KCODE_ERROR_LANE3_DP_TRANS_P0_FLDMASK_LEN         1
+
+#define CP2520_PATTERN2_DCODE_ERROR_LANE0_DP_TRANS_P0_FLDMASK             0x10
+#define CP2520_PATTERN2_DCODE_ERROR_LANE0_DP_TRANS_P0_FLDMASK_POS         4
+#define CP2520_PATTERN2_DCODE_ERROR_LANE0_DP_TRANS_P0_FLDMASK_LEN         1
+
+#define CP2520_PATTERN2_DCODE_ERROR_LANE1_DP_TRANS_P0_FLDMASK             0x20
+#define CP2520_PATTERN2_DCODE_ERROR_LANE1_DP_TRANS_P0_FLDMASK_POS         5
+#define CP2520_PATTERN2_DCODE_ERROR_LANE1_DP_TRANS_P0_FLDMASK_LEN         1
+
+#define CP2520_PATTERN2_DCODE_ERROR_LANE2_DP_TRANS_P0_FLDMASK             0x40
+#define CP2520_PATTERN2_DCODE_ERROR_LANE2_DP_TRANS_P0_FLDMASK_POS         6
+#define CP2520_PATTERN2_DCODE_ERROR_LANE2_DP_TRANS_P0_FLDMASK_LEN         1
+
+#define CP2520_PATTERN2_DCODE_ERROR_LANE3_DP_TRANS_P0_FLDMASK             0x80
+#define CP2520_PATTERN2_DCODE_ERROR_LANE3_DP_TRANS_P0_FLDMASK_POS         7
+#define CP2520_PATTERN2_DCODE_ERROR_LANE3_DP_TRANS_P0_FLDMASK_LEN         1
+
+#define CP2520_PATTERN3_KCODE_ERROR_LANE0_DP_TRANS_P0_FLDMASK             0x100
+#define CP2520_PATTERN3_KCODE_ERROR_LANE0_DP_TRANS_P0_FLDMASK_POS         8
+#define CP2520_PATTERN3_KCODE_ERROR_LANE0_DP_TRANS_P0_FLDMASK_LEN         1
+
+#define CP2520_PATTERN3_KCODE_ERROR_LANE1_DP_TRANS_P0_FLDMASK             0x200
+#define CP2520_PATTERN3_KCODE_ERROR_LANE1_DP_TRANS_P0_FLDMASK_POS         9
+#define CP2520_PATTERN3_KCODE_ERROR_LANE1_DP_TRANS_P0_FLDMASK_LEN         1
+
+#define CP2520_PATTERN3_KCODE_ERROR_LANE2_DP_TRANS_P0_FLDMASK             0x400
+#define CP2520_PATTERN3_KCODE_ERROR_LANE2_DP_TRANS_P0_FLDMASK_POS         10
+#define CP2520_PATTERN3_KCODE_ERROR_LANE2_DP_TRANS_P0_FLDMASK_LEN         1
+
+#define CP2520_PATTERN3_KCODE_ERROR_LANE3_DP_TRANS_P0_FLDMASK             0x800
+#define CP2520_PATTERN3_KCODE_ERROR_LANE3_DP_TRANS_P0_FLDMASK_POS         11
+#define CP2520_PATTERN3_KCODE_ERROR_LANE3_DP_TRANS_P0_FLDMASK_LEN         1
+
+#define CP2520_PATTERN3_DCODE_ERROR_LANE0_DP_TRANS_P0_FLDMASK             0x1000
+#define CP2520_PATTERN3_DCODE_ERROR_LANE0_DP_TRANS_P0_FLDMASK_POS         12
+#define CP2520_PATTERN3_DCODE_ERROR_LANE0_DP_TRANS_P0_FLDMASK_LEN         1
+
+#define CP2520_PATTERN3_DCODE_ERROR_LANE1_DP_TRANS_P0_FLDMASK             0x2000
+#define CP2520_PATTERN3_DCODE_ERROR_LANE1_DP_TRANS_P0_FLDMASK_POS         13
+#define CP2520_PATTERN3_DCODE_ERROR_LANE1_DP_TRANS_P0_FLDMASK_LEN         1
+
+#define CP2520_PATTERN3_DCODE_ERROR_LANE2_DP_TRANS_P0_FLDMASK             0x4000
+#define CP2520_PATTERN3_DCODE_ERROR_LANE2_DP_TRANS_P0_FLDMASK_POS         14
+#define CP2520_PATTERN3_DCODE_ERROR_LANE2_DP_TRANS_P0_FLDMASK_LEN         1
+
+#define CP2520_PATTERN3_DCODE_ERROR_LANE3_DP_TRANS_P0_FLDMASK             0x8000
+#define CP2520_PATTERN3_DCODE_ERROR_LANE3_DP_TRANS_P0_FLDMASK_POS         15
+#define CP2520_PATTERN3_DCODE_ERROR_LANE3_DP_TRANS_P0_FLDMASK_LEN         1
+
+#define REG_3480_DP_TRANS_P0              (0x3480)
+#define DP_EN_DP_TRANS_P0_FLDMASK                                         0x1
+#define DP_EN_DP_TRANS_P0_FLDMASK_POS                                     0
+#define DP_EN_DP_TRANS_P0_FLDMASK_LEN                                     1
+
+#define HDCP_CAPABLE_DP_TRANS_P0_FLDMASK                                  0x2
+#define HDCP_CAPABLE_DP_TRANS_P0_FLDMASK_POS                              1
+#define HDCP_CAPABLE_DP_TRANS_P0_FLDMASK_LEN                              1
+
+#define SELECT_INTERNAL_AN_DP_TRANS_P0_FLDMASK                            0x4
+#define SELECT_INTERNAL_AN_DP_TRANS_P0_FLDMASK_POS                        2
+#define SELECT_INTERNAL_AN_DP_TRANS_P0_FLDMASK_LEN                        1
+
+#define AN_FREERUN_DP_TRANS_P0_FLDMASK                                    0x8
+#define AN_FREERUN_DP_TRANS_P0_FLDMASK_POS                                3
+#define AN_FREERUN_DP_TRANS_P0_FLDMASK_LEN                                1
+
+#define KM_GENERATED_DP_TRANS_P0_FLDMASK                                  0x10
+#define KM_GENERATED_DP_TRANS_P0_FLDMASK_POS                              4
+#define KM_GENERATED_DP_TRANS_P0_FLDMASK_LEN                              1
+
+#define REQ_BLOCK_CIPHER_AUTH_DP_TRANS_P0_FLDMASK                         0x1000
+#define REQ_BLOCK_CIPHER_AUTH_DP_TRANS_P0_FLDMASK_POS                     12
+#define REQ_BLOCK_CIPHER_AUTH_DP_TRANS_P0_FLDMASK_LEN                     1
+
+#define HDCP_1LANE_SEL_DP_TRANS_P0_FLDMASK                                0x2000
+#define HDCP_1LANE_SEL_DP_TRANS_P0_FLDMASK_POS                            13
+#define HDCP_1LANE_SEL_DP_TRANS_P0_FLDMASK_LEN                            1
+
+#define HDCP_24LANE_SEL_DP_TRANS_P0_FLDMASK                               0x4000
+#define HDCP_24LANE_SEL_DP_TRANS_P0_FLDMASK_POS                           14
+#define HDCP_24LANE_SEL_DP_TRANS_P0_FLDMASK_LEN                           1
+
+#define MST_EN_DP_TRANS_P0_FLDMASK                                        0x8000
+#define MST_EN_DP_TRANS_P0_FLDMASK_POS                                    15
+#define MST_EN_DP_TRANS_P0_FLDMASK_LEN                                    1
+
+#define REG_34A4_DP_TRANS_P0              (0x34A4)
+#define EN_COPY_2LANE_MSA_DP_TRANS_P0_FLDMASK                             0x1
+#define EN_COPY_2LANE_MSA_DP_TRANS_P0_FLDMASK_POS                         0
+#define EN_COPY_2LANE_MSA_DP_TRANS_P0_FLDMASK_LEN                         1
+
+#define EN_COPY_4LANE_MSA_DP_TRANS_P0_FLDMASK                             0x2
+#define EN_COPY_4LANE_MSA_DP_TRANS_P0_FLDMASK_POS                         1
+#define EN_COPY_4LANE_MSA_DP_TRANS_P0_FLDMASK_LEN                         1
+
+#define LANE_NUM_DP_TRANS_P0_FLDMASK                                      0xc
+#define LANE_NUM_DP_TRANS_P0_FLDMASK_POS                                  2
+#define LANE_NUM_DP_TRANS_P0_FLDMASK_LEN                                  2
+
+#define HDCP22_AUTH_DONE_DP_TRANS_P0_FLDMASK                              0x10
+#define HDCP22_AUTH_DONE_DP_TRANS_P0_FLDMASK_POS                          4
+#define HDCP22_AUTH_DONE_DP_TRANS_P0_FLDMASK_LEN                          1
+
+#define DISCARD_UNUSED_CIPHER_DP_TRANS_P0_FLDMASK                         0x20
+#define DISCARD_UNUSED_CIPHER_DP_TRANS_P0_FLDMASK_POS                     5
+#define DISCARD_UNUSED_CIPHER_DP_TRANS_P0_FLDMASK_LEN                     1
+
+#define HDCP22_CIPHER_REVERSE_DP_TRANS_P0_FLDMASK                         0x40
+#define HDCP22_CIPHER_REVERSE_DP_TRANS_P0_FLDMASK_POS                     6
+#define HDCP22_CIPHER_REVERSE_DP_TRANS_P0_FLDMASK_LEN                     1
+
+#define MST_DELAY_CYCLE_FLAG_SEL_DP_TRANS_P0_FLDMASK                      0x80
+#define MST_DELAY_CYCLE_FLAG_SEL_DP_TRANS_P0_FLDMASK_POS                  7
+#define MST_DELAY_CYCLE_FLAG_SEL_DP_TRANS_P0_FLDMASK_LEN                  1
+
+#define TEST_CONFIG_HDCP22_DP_TRANS_P0_FLDMASK                            0xf00
+#define TEST_CONFIG_HDCP22_DP_TRANS_P0_FLDMASK_POS                        8
+#define TEST_CONFIG_HDCP22_DP_TRANS_P0_FLDMASK_LEN                        4
+
+#define R0_AVAILABLE_DP_TRANS_P0_FLDMASK                                  0x1000
+#define R0_AVAILABLE_DP_TRANS_P0_FLDMASK_POS                              12
+#define R0_AVAILABLE_DP_TRANS_P0_FLDMASK_LEN                              1
+
+#define DPES_TX_HDCP22_DP_TRANS_P0_FLDMASK                                0x2000
+#define DPES_TX_HDCP22_DP_TRANS_P0_FLDMASK_POS                            13
+#define DPES_TX_HDCP22_DP_TRANS_P0_FLDMASK_LEN                            1
+
+#define DP_AES_OUT_RDY_L_DP_TRANS_P0_FLDMASK                              0x4000
+#define DP_AES_OUT_RDY_L_DP_TRANS_P0_FLDMASK_POS                          14
+#define DP_AES_OUT_RDY_L_DP_TRANS_P0_FLDMASK_LEN                          1
+
+#define REPEATER_I_DP_TRANS_P0_FLDMASK                                    0x8000
+#define REPEATER_I_DP_TRANS_P0_FLDMASK_POS                                15
+#define REPEATER_I_DP_TRANS_P0_FLDMASK_LEN                                1
+
+#define REG_34A8_DP_TRANS_P0              (0x34A8)
+#define TEST_CONFIG_HDCP13_DP_TRANS_P0_FLDMASK                            0xff00
+#define TEST_CONFIG_HDCP13_DP_TRANS_P0_FLDMASK_POS                        8
+#define TEST_CONFIG_HDCP13_DP_TRANS_P0_FLDMASK_LEN                        8
+
+#define REG_34D0_DP_TRANS_P0              (0x34D0)
+#define TX_HDCP22_TYPE_DP_TRANS_P0_FLDMASK                                0xff
+#define TX_HDCP22_TYPE_DP_TRANS_P0_FLDMASK_POS                            0
+#define TX_HDCP22_TYPE_DP_TRANS_P0_FLDMASK_LEN                            8
+
+#define PIPE_DELAY_EN_CNT_DP_TRANS_P0_FLDMASK                             0xf00
+#define PIPE_DELAY_EN_CNT_DP_TRANS_P0_FLDMASK_POS                         8
+#define PIPE_DELAY_EN_CNT_DP_TRANS_P0_FLDMASK_LEN                         4
+
+#define PIPE_DELAY_DP_TRANS_P0_FLDMASK                                    0xf000
+#define PIPE_DELAY_DP_TRANS_P0_FLDMASK_POS                                12
+#define PIPE_DELAY_DP_TRANS_P0_FLDMASK_LEN                                4
+
+#define REG_34D4_DP_TRANS_P0              (0x34D4)
+#define DP_AES_INCTR_L_0_DP_TRANS_P0_FLDMASK                              0xffff
+#define DP_AES_INCTR_L_0_DP_TRANS_P0_FLDMASK_POS                          0
+#define DP_AES_INCTR_L_0_DP_TRANS_P0_FLDMASK_LEN                          16
+
+#define REG_34D8_DP_TRANS_P0              (0x34D8)
+#define DP_AES_INCTR_L_1_DP_TRANS_P0_FLDMASK                              0xffff
+#define DP_AES_INCTR_L_1_DP_TRANS_P0_FLDMASK_POS                          0
+#define DP_AES_INCTR_L_1_DP_TRANS_P0_FLDMASK_LEN                          16
+
+#define REG_34DC_DP_TRANS_P0              (0x34DC)
+#define DP_AES_INCTR_L_2_DP_TRANS_P0_FLDMASK                              0xffff
+#define DP_AES_INCTR_L_2_DP_TRANS_P0_FLDMASK_POS                          0
+#define DP_AES_INCTR_L_2_DP_TRANS_P0_FLDMASK_LEN                          16
+
+#define REG_34E0_DP_TRANS_P0              (0x34E0)
+#define DP_AES_INCTR_L_3_DP_TRANS_P0_FLDMASK                              0xffff
+#define DP_AES_INCTR_L_3_DP_TRANS_P0_FLDMASK_POS                          0
+#define DP_AES_INCTR_L_3_DP_TRANS_P0_FLDMASK_LEN                          16
+
+#define REG_34E4_DP_TRANS_P0              (0x34E4)
+#define HDCP_TYPE_TX_0_DP_TRANS_P0_FLDMASK                                0xffff
+#define HDCP_TYPE_TX_0_DP_TRANS_P0_FLDMASK_POS                            0
+#define HDCP_TYPE_TX_0_DP_TRANS_P0_FLDMASK_LEN                            16
+
+#define REG_34E8_DP_TRANS_P0              (0x34E8)
+#define HDCP_TYPE_TX_1_DP_TRANS_P0_FLDMASK                                0xffff
+#define HDCP_TYPE_TX_1_DP_TRANS_P0_FLDMASK_POS                            0
+#define HDCP_TYPE_TX_1_DP_TRANS_P0_FLDMASK_LEN                            16
+
+#define REG_34EC_DP_TRANS_P0              (0x34EC)
+#define HDCP_TYPE_TX_2_DP_TRANS_P0_FLDMASK                                0xffff
+#define HDCP_TYPE_TX_2_DP_TRANS_P0_FLDMASK_POS                            0
+#define HDCP_TYPE_TX_2_DP_TRANS_P0_FLDMASK_LEN                            16
+
+#define REG_34F0_DP_TRANS_P0              (0x34F0)
+#define HDCP_TYPE_TX_3_DP_TRANS_P0_FLDMASK                                0xffff
+#define HDCP_TYPE_TX_3_DP_TRANS_P0_FLDMASK_POS                            0
+#define HDCP_TYPE_TX_3_DP_TRANS_P0_FLDMASK_LEN                            16
+
+#define REG_34F4_DP_TRANS_P0              (0x34F4)
+#define SST_HDCP_TYPE_TX_DP_TRANS_P0_FLDMASK                              0xff
+#define SST_HDCP_TYPE_TX_DP_TRANS_P0_FLDMASK_POS                          0
+#define SST_HDCP_TYPE_TX_DP_TRANS_P0_FLDMASK_LEN                          8
+
+#define PIPE_OV_VALUE_DP_TRANS_P0_FLDMASK                                 0xf00
+#define PIPE_OV_VALUE_DP_TRANS_P0_FLDMASK_POS                             8
+#define PIPE_OV_VALUE_DP_TRANS_P0_FLDMASK_LEN                             4
+
+#define PIPE_OV_ENABLE_DP_TRANS_P0_FLDMASK                                0x1000
+#define PIPE_OV_ENABLE_DP_TRANS_P0_FLDMASK_POS                            12
+#define PIPE_OV_ENABLE_DP_TRANS_P0_FLDMASK_LEN                            1
+
+#define REG_34F8_DP_TRANS_P0              (0x34F8)
+#define DP_AES_OUT_RDY_H_DP_TRANS_P0_FLDMASK                              0x4000
+#define DP_AES_OUT_RDY_H_DP_TRANS_P0_FLDMASK_POS                          14
+#define DP_AES_OUT_RDY_H_DP_TRANS_P0_FLDMASK_LEN                          1
+
+#define REG_34FC_DP_TRANS_P0              (0x34FC)
+#define HDCP_4P_TO_2P_FIFO_RST_CHK_DP_TRANS_P0_FLDMASK                    0xff
+#define HDCP_4P_TO_2P_FIFO_RST_CHK_DP_TRANS_P0_FLDMASK_POS                0
+#define HDCP_4P_TO_2P_FIFO_RST_CHK_DP_TRANS_P0_FLDMASK_LEN                8
+
+#define HDCP_2P_TO_4P_FIFO_RST_CHK_DP_TRANS_P0_FLDMASK                    0xff00
+#define HDCP_2P_TO_4P_FIFO_RST_CHK_DP_TRANS_P0_FLDMASK_POS                8
+#define HDCP_2P_TO_4P_FIFO_RST_CHK_DP_TRANS_P0_FLDMASK_LEN                8
+
+#define REG_3500_DP_TRANS_P0              (0x3500)
+#define DP_AES_INCTR_H_0_DP_TRANS_P0_FLDMASK                              0xffff
+#define DP_AES_INCTR_H_0_DP_TRANS_P0_FLDMASK_POS                          0
+#define DP_AES_INCTR_H_0_DP_TRANS_P0_FLDMASK_LEN                          16
+
+#define REG_3504_DP_TRANS_P0              (0x3504)
+#define DP_AES_INCTR_H_1_DP_TRANS_P0_FLDMASK                              0xffff
+#define DP_AES_INCTR_H_1_DP_TRANS_P0_FLDMASK_POS                          0
+#define DP_AES_INCTR_H_1_DP_TRANS_P0_FLDMASK_LEN                          16
+
+#define REG_3508_DP_TRANS_P0              (0x3508)
+#define DP_AES_INCTR_H_2_DP_TRANS_P0_FLDMASK                              0xffff
+#define DP_AES_INCTR_H_2_DP_TRANS_P0_FLDMASK_POS                          0
+#define DP_AES_INCTR_H_2_DP_TRANS_P0_FLDMASK_LEN                          16
+
+#define REG_350C_DP_TRANS_P0              (0x350C)
+#define DP_AES_INCTR_H_3_DP_TRANS_P0_FLDMASK                              0xffff
+#define DP_AES_INCTR_H_3_DP_TRANS_P0_FLDMASK_POS                          0
+#define DP_AES_INCTR_H_3_DP_TRANS_P0_FLDMASK_LEN                          16
+
+#define REG_3510_DP_TRANS_P0              (0x3510)
+#define HDCP22_TYPE_DP_TRANS_P0_FLDMASK                                   0xff
+#define HDCP22_TYPE_DP_TRANS_P0_FLDMASK_POS                               0
+#define HDCP22_TYPE_DP_TRANS_P0_FLDMASK_LEN                               8
+
+#define REG_3540_DP_TRANS_P0              (0x3540)
+#define FEC_EN_DP_TRANS_P0_FLDMASK                                        0x1
+#define FEC_EN_DP_TRANS_P0_FLDMASK_POS                                    0
+#define FEC_EN_DP_TRANS_P0_FLDMASK_LEN                                    1
+
+#define FEC_END_MODE_DP_TRANS_P0_FLDMASK                                  0x6
+#define FEC_END_MODE_DP_TRANS_P0_FLDMASK_POS                              1
+#define FEC_END_MODE_DP_TRANS_P0_FLDMASK_LEN                              2
+
+#define FEC_CLOCK_EN_MODE_DP_TRANS_P0_FLDMASK                             0x8
+#define FEC_CLOCK_EN_MODE_DP_TRANS_P0_FLDMASK_POS                         3
+#define FEC_CLOCK_EN_MODE_DP_TRANS_P0_FLDMASK_LEN                         1
+
+#define FEC_FIFO_READ_START_DP_TRANS_P0_FLDMASK                           0xf0
+#define FEC_FIFO_READ_START_DP_TRANS_P0_FLDMASK_POS                       4
+#define FEC_FIFO_READ_START_DP_TRANS_P0_FLDMASK_LEN                       4
+
+#define FEC_FIFO_UNDER_POINT_DP_TRANS_P0_FLDMASK                          0xf00
+#define FEC_FIFO_UNDER_POINT_DP_TRANS_P0_FLDMASK_POS                      8
+#define FEC_FIFO_UNDER_POINT_DP_TRANS_P0_FLDMASK_LEN                      4
+
+#define FEC_FIFO_OVER_POINT_DP_TRANS_P0_FLDMASK                           0xf000
+#define FEC_FIFO_OVER_POINT_DP_TRANS_P0_FLDMASK_POS                       12
+#define FEC_FIFO_OVER_POINT_DP_TRANS_P0_FLDMASK_LEN                       4
+
+#define REG_3544_DP_TRANS_P0              (0x3544)
+#define FEC_FIFO_RST_DP_TRANS_P0_FLDMASK                                  0x1
+#define FEC_FIFO_RST_DP_TRANS_P0_FLDMASK_POS                              0
+#define FEC_FIFO_RST_DP_TRANS_P0_FLDMASK_LEN                              1
+
+#define FEC_SUPPORT_DP_TRANS_P0_FLDMASK                                   0x2
+#define FEC_SUPPORT_DP_TRANS_P0_FLDMASK_POS                               1
+#define FEC_SUPPORT_DP_TRANS_P0_FLDMASK_LEN                               1
+
+#define FEC_PATTERN_NEW_DP_TRANS_P0_FLDMASK                               0x4
+#define FEC_PATTERN_NEW_DP_TRANS_P0_FLDMASK_POS                           2
+#define FEC_PATTERN_NEW_DP_TRANS_P0_FLDMASK_LEN                           1
+
+#define FEC_INSERT_FIFO_EMPTY_DP_TRANS_P0_FLDMASK                         0x10
+#define FEC_INSERT_FIFO_EMPTY_DP_TRANS_P0_FLDMASK_POS                     4
+#define FEC_INSERT_FIFO_EMPTY_DP_TRANS_P0_FLDMASK_LEN                     1
+
+#define FEC_INSERT_FIFO_EMPTY_CLR_DP_TRANS_P0_FLDMASK                     0x20
+#define FEC_INSERT_FIFO_EMPTY_CLR_DP_TRANS_P0_FLDMASK_POS                 5
+#define FEC_INSERT_FIFO_EMPTY_CLR_DP_TRANS_P0_FLDMASK_LEN                 1
+
+#define FEC_INSERT_FIFO_FULL_DP_TRANS_P0_FLDMASK                          0x40
+#define FEC_INSERT_FIFO_FULL_DP_TRANS_P0_FLDMASK_POS                      6
+#define FEC_INSERT_FIFO_FULL_DP_TRANS_P0_FLDMASK_LEN                      1
+
+#define FEC_INSERT_FIFO_FULL_CLR_DP_TRANS_P0_FLDMASK                      0x80
+#define FEC_INSERT_FIFO_FULL_CLR_DP_TRANS_P0_FLDMASK_POS                  7
+#define FEC_INSERT_FIFO_FULL_CLR_DP_TRANS_P0_FLDMASK_LEN                  1
+
+#define PARITY_INTERLEAVER_DATA_INVERT_PIPE_SEL_DP_TRANS_P0_FLDMASK       0x700
+#define PARITY_INTERLEAVER_DATA_INVERT_PIPE_SEL_DP_TRANS_P0_FLDMASK_POS   8
+#define PARITY_INTERLEAVER_DATA_INVERT_PIPE_SEL_DP_TRANS_P0_FLDMASK_LEN   3
+
+#define PAT_INIT_DISPARITY_FEC_DP_TRANS_P0_FLDMASK                        0x800
+#define PAT_INIT_DISPARITY_FEC_DP_TRANS_P0_FLDMASK_POS                    11
+#define PAT_INIT_DISPARITY_FEC_DP_TRANS_P0_FLDMASK_LEN                    1
+
+#define FEC_PARITY_DATA_LANE_SWAP_DP_TRANS_P0_FLDMASK                     0x1000
+#define FEC_PARITY_DATA_LANE_SWAP_DP_TRANS_P0_FLDMASK_POS                 12
+#define FEC_PARITY_DATA_LANE_SWAP_DP_TRANS_P0_FLDMASK_LEN                 1
+
+#define REG_3548_DP_TRANS_P0              (0x3548)
+#define FEC_INSERT_SYMBOL_ERROR_CNT_LANE0_DP_TRANS_P0_FLDMASK             0x7
+#define FEC_INSERT_SYMBOL_ERROR_CNT_LANE0_DP_TRANS_P0_FLDMASK_POS         0
+#define FEC_INSERT_SYMBOL_ERROR_CNT_LANE0_DP_TRANS_P0_FLDMASK_LEN         3
+
+#define FEC_INSERT_SYMBOL_ERROR_LANE0_DP_TRANS_P0_FLDMASK                 0x8
+#define FEC_INSERT_SYMBOL_ERROR_LANE0_DP_TRANS_P0_FLDMASK_POS             3
+#define FEC_INSERT_SYMBOL_ERROR_LANE0_DP_TRANS_P0_FLDMASK_LEN             1
+
+#define FEC_INSERT_SYMBOL_ERROR_CNT_LANE1_DP_TRANS_P0_FLDMASK             0x70
+#define FEC_INSERT_SYMBOL_ERROR_CNT_LANE1_DP_TRANS_P0_FLDMASK_POS         4
+#define FEC_INSERT_SYMBOL_ERROR_CNT_LANE1_DP_TRANS_P0_FLDMASK_LEN         3
+
+#define FEC_INSERT_SYMBOL_ERROR_LANE1_DP_TRANS_P0_FLDMASK                 0x80
+#define FEC_INSERT_SYMBOL_ERROR_LANE1_DP_TRANS_P0_FLDMASK_POS             7
+#define FEC_INSERT_SYMBOL_ERROR_LANE1_DP_TRANS_P0_FLDMASK_LEN             1
+
+#define FEC_INSERT_SYMBOL_ERROR_CNT_LANE2_DP_TRANS_P0_FLDMASK             0x700
+#define FEC_INSERT_SYMBOL_ERROR_CNT_LANE2_DP_TRANS_P0_FLDMASK_POS         8
+#define FEC_INSERT_SYMBOL_ERROR_CNT_LANE2_DP_TRANS_P0_FLDMASK_LEN         3
+
+#define FEC_INSERT_SYMBOL_ERROR_LANE2_DP_TRANS_P0_FLDMASK                 0x800
+#define FEC_INSERT_SYMBOL_ERROR_LANE2_DP_TRANS_P0_FLDMASK_POS             11
+#define FEC_INSERT_SYMBOL_ERROR_LANE2_DP_TRANS_P0_FLDMASK_LEN             1
+
+#define FEC_INSERT_SYMBOL_ERROR_CNT_LANE3_DP_TRANS_P0_FLDMASK             0x7000
+#define FEC_INSERT_SYMBOL_ERROR_CNT_LANE3_DP_TRANS_P0_FLDMASK_POS         12
+#define FEC_INSERT_SYMBOL_ERROR_CNT_LANE3_DP_TRANS_P0_FLDMASK_LEN         3
+
+#define FEC_INSERT_SYMBOL_ERROR_LANE3_DP_TRANS_P0_FLDMASK                 0x8000
+#define FEC_INSERT_SYMBOL_ERROR_LANE3_DP_TRANS_P0_FLDMASK_POS             15
+#define FEC_INSERT_SYMBOL_ERROR_LANE3_DP_TRANS_P0_FLDMASK_LEN             1
+
+#define REG_354C_DP_TRANS_P0              (0x354C)
+#define FEC_CP_HIT_LANE0_DP_TRANS_P0_FLDMASK                              0x1
+#define FEC_CP_HIT_LANE0_DP_TRANS_P0_FLDMASK_POS                          0
+#define FEC_CP_HIT_LANE0_DP_TRANS_P0_FLDMASK_LEN                          1
+
+#define FEC_CP_HIT_LANE1_DP_TRANS_P0_FLDMASK                              0x2
+#define FEC_CP_HIT_LANE1_DP_TRANS_P0_FLDMASK_POS                          1
+#define FEC_CP_HIT_LANE1_DP_TRANS_P0_FLDMASK_LEN                          1
+
+#define FEC_CP_HIT_LANE2_DP_TRANS_P0_FLDMASK                              0x4
+#define FEC_CP_HIT_LANE2_DP_TRANS_P0_FLDMASK_POS                          2
+#define FEC_CP_HIT_LANE2_DP_TRANS_P0_FLDMASK_LEN                          1
+
+#define FEC_CP_HIT_LANE3_DP_TRANS_P0_FLDMASK                              0x8
+#define FEC_CP_HIT_LANE3_DP_TRANS_P0_FLDMASK_POS                          3
+#define FEC_CP_HIT_LANE3_DP_TRANS_P0_FLDMASK_LEN                          1
+
+#define FEC_CP_HIT_CLR_DP_TRANS_P0_FLDMASK                                0x10
+#define FEC_CP_HIT_CLR_DP_TRANS_P0_FLDMASK_POS                            4
+#define FEC_CP_HIT_CLR_DP_TRANS_P0_FLDMASK_LEN                            1
+
+#define FEC_ENCODE_TOP_TESTBUS_SEL_DP_TRANS_P0_FLDMASK                    0x300
+#define FEC_ENCODE_TOP_TESTBUS_SEL_DP_TRANS_P0_FLDMASK_POS                8
+#define FEC_ENCODE_TOP_TESTBUS_SEL_DP_TRANS_P0_FLDMASK_LEN                2
+
+#define FEC_INSERT_TOP_TESTBUS_SEL_DP_TRANS_P0_FLDMASK                    0xc00
+#define FEC_INSERT_TOP_TESTBUS_SEL_DP_TRANS_P0_FLDMASK_POS                10
+#define FEC_INSERT_TOP_TESTBUS_SEL_DP_TRANS_P0_FLDMASK_LEN                2
+
+#define REG_3550_DP_TRANS_P0              (0x3550)
+#define FEC_INSERT_FIFO_WCNT_DP_TRANS_P0_FLDMASK                          0x1f
+#define FEC_INSERT_FIFO_WCNT_DP_TRANS_P0_FLDMASK_POS                      0
+#define FEC_INSERT_FIFO_WCNT_DP_TRANS_P0_FLDMASK_LEN                      5
+
+#define FEC_INSERT_FIFO_RCNT_DP_TRANS_P0_FLDMASK                          0x1f00
+#define FEC_INSERT_FIFO_RCNT_DP_TRANS_P0_FLDMASK_POS                      8
+#define FEC_INSERT_FIFO_RCNT_DP_TRANS_P0_FLDMASK_LEN                      5
+
+#define REG_3554_DP_TRANS_P0              (0x3554)
+#define FEC_CLK_GATE_DATA_CNT_0_DP_TRANS_P0_FLDMASK                       0x7f
+#define FEC_CLK_GATE_DATA_CNT_0_DP_TRANS_P0_FLDMASK_POS                   0
+#define FEC_CLK_GATE_DATA_CNT_0_DP_TRANS_P0_FLDMASK_LEN                   7
+
+#define REG_3558_DP_TRANS_P0              (0x3558)
+#define FEC_CLK_GATE_DATA_CNT_1_0_DP_TRANS_P0_FLDMASK                     0xffff
+#define FEC_CLK_GATE_DATA_CNT_1_0_DP_TRANS_P0_FLDMASK_POS                 0
+#define FEC_CLK_GATE_DATA_CNT_1_0_DP_TRANS_P0_FLDMASK_LEN                 16
+
+#define REG_355C_DP_TRANS_P0              (0x355C)
+#define FEC_CLK_GATE_DATA_CNT_1_1_DP_TRANS_P0_FLDMASK                     0x3
+#define FEC_CLK_GATE_DATA_CNT_1_1_DP_TRANS_P0_FLDMASK_POS                 0
+#define FEC_CLK_GATE_DATA_CNT_1_1_DP_TRANS_P0_FLDMASK_LEN                 2
+
+#define REG_3580_DP_TRANS_P0              (0x3580)
+#define DP_TX_TRANS_TESTBUS_SEL_DP_TRANS_P0_FLDMASK                       0x1f
+#define DP_TX_TRANS_TESTBUS_SEL_DP_TRANS_P0_FLDMASK_POS                   0
+#define DP_TX_TRANS_TESTBUS_SEL_DP_TRANS_P0_FLDMASK_LEN                   5
+
+#define POST_MISC_DATA_LANE0_OV_DP_TRANS_P0_FLDMASK                       0x100
+#define POST_MISC_DATA_LANE0_OV_DP_TRANS_P0_FLDMASK_POS                   8
+#define POST_MISC_DATA_LANE0_OV_DP_TRANS_P0_FLDMASK_LEN                   1
+
+#define POST_MISC_DATA_LANE1_OV_DP_TRANS_P0_FLDMASK                       0x200
+#define POST_MISC_DATA_LANE1_OV_DP_TRANS_P0_FLDMASK_POS                   9
+#define POST_MISC_DATA_LANE1_OV_DP_TRANS_P0_FLDMASK_LEN                   1
+
+#define POST_MISC_DATA_LANE2_OV_DP_TRANS_P0_FLDMASK                       0x400
+#define POST_MISC_DATA_LANE2_OV_DP_TRANS_P0_FLDMASK_POS                   10
+#define POST_MISC_DATA_LANE2_OV_DP_TRANS_P0_FLDMASK_LEN                   1
+
+#define POST_MISC_DATA_LANE3_OV_DP_TRANS_P0_FLDMASK                       0x800
+#define POST_MISC_DATA_LANE3_OV_DP_TRANS_P0_FLDMASK_POS                   11
+#define POST_MISC_DATA_LANE3_OV_DP_TRANS_P0_FLDMASK_LEN                   1
+
+#define REG_3584_DP_TRANS_P0              (0x3584)
+#define POST_MISC_DATA_LANE0_0_DP_TRANS_P0_FLDMASK                        0xffff
+#define POST_MISC_DATA_LANE0_0_DP_TRANS_P0_FLDMASK_POS                    0
+#define POST_MISC_DATA_LANE0_0_DP_TRANS_P0_FLDMASK_LEN                    16
+
+#define REG_3588_DP_TRANS_P0              (0x3588)
+#define POST_MISC_DATA_LANE0_1_DP_TRANS_P0_FLDMASK                        0xffff
+#define POST_MISC_DATA_LANE0_1_DP_TRANS_P0_FLDMASK_POS                    0
+#define POST_MISC_DATA_LANE0_1_DP_TRANS_P0_FLDMASK_LEN                    16
+
+#define REG_358C_DP_TRANS_P0              (0x358C)
+#define POST_MISC_DATA_LANE0_2_DP_TRANS_P0_FLDMASK                        0xff
+#define POST_MISC_DATA_LANE0_2_DP_TRANS_P0_FLDMASK_POS                    0
+#define POST_MISC_DATA_LANE0_2_DP_TRANS_P0_FLDMASK_LEN                    8
+
+#define REG_3590_DP_TRANS_P0              (0x3590)
+#define POST_MISC_DATA_LANE1_0_DP_TRANS_P0_FLDMASK                        0xffff
+#define POST_MISC_DATA_LANE1_0_DP_TRANS_P0_FLDMASK_POS                    0
+#define POST_MISC_DATA_LANE1_0_DP_TRANS_P0_FLDMASK_LEN                    16
+
+#define REG_3594_DP_TRANS_P0              (0x3594)
+#define POST_MISC_DATA_LANE1_1_DP_TRANS_P0_FLDMASK                        0xffff
+#define POST_MISC_DATA_LANE1_1_DP_TRANS_P0_FLDMASK_POS                    0
+#define POST_MISC_DATA_LANE1_1_DP_TRANS_P0_FLDMASK_LEN                    16
+
+#define REG_3598_DP_TRANS_P0              (0x3598)
+#define POST_MISC_DATA_LANE1_2_DP_TRANS_P0_FLDMASK                        0xff
+#define POST_MISC_DATA_LANE1_2_DP_TRANS_P0_FLDMASK_POS                    0
+#define POST_MISC_DATA_LANE1_2_DP_TRANS_P0_FLDMASK_LEN                    8
+
+#define REG_359C_DP_TRANS_P0              (0x359C)
+#define POST_MISC_DATA_LANE2_0_DP_TRANS_P0_FLDMASK                        0xffff
+#define POST_MISC_DATA_LANE2_0_DP_TRANS_P0_FLDMASK_POS                    0
+#define POST_MISC_DATA_LANE2_0_DP_TRANS_P0_FLDMASK_LEN                    16
+
+#define REG_35A0_DP_TRANS_P0              (0x35A0)
+#define POST_MISC_DATA_LANE2_1_DP_TRANS_P0_FLDMASK                        0xffff
+#define POST_MISC_DATA_LANE2_1_DP_TRANS_P0_FLDMASK_POS                    0
+#define POST_MISC_DATA_LANE2_1_DP_TRANS_P0_FLDMASK_LEN                    16
+
+#define REG_35A4_DP_TRANS_P0              (0x35A4)
+#define POST_MISC_DATA_LANE2_2_DP_TRANS_P0_FLDMASK                        0xff
+#define POST_MISC_DATA_LANE2_2_DP_TRANS_P0_FLDMASK_POS                    0
+#define POST_MISC_DATA_LANE2_2_DP_TRANS_P0_FLDMASK_LEN                    8
+
+#define REG_35A8_DP_TRANS_P0              (0x35A8)
+#define POST_MISC_DATA_LANE3_0_DP_TRANS_P0_FLDMASK                        0xffff
+#define POST_MISC_DATA_LANE3_0_DP_TRANS_P0_FLDMASK_POS                    0
+#define POST_MISC_DATA_LANE3_0_DP_TRANS_P0_FLDMASK_LEN                    16
+
+#define REG_35AC_DP_TRANS_P0              (0x35AC)
+#define POST_MISC_DATA_LANE3_1_DP_TRANS_P0_FLDMASK                        0xffff
+#define POST_MISC_DATA_LANE3_1_DP_TRANS_P0_FLDMASK_POS                    0
+#define POST_MISC_DATA_LANE3_1_DP_TRANS_P0_FLDMASK_LEN                    16
+
+#define REG_35B0_DP_TRANS_P0              (0x35B0)
+#define POST_MISC_DATA_LANE3_2_DP_TRANS_P0_FLDMASK                        0xff
+#define POST_MISC_DATA_LANE3_2_DP_TRANS_P0_FLDMASK_POS                    0
+#define POST_MISC_DATA_LANE3_2_DP_TRANS_P0_FLDMASK_LEN                    8
+
+#define REG_35C0_DP_TRANS_P0              (0x35C0)
+#define SW_IRQ_SRC_DP_TRANS_P0_FLDMASK                                    0xffff
+#define SW_IRQ_SRC_DP_TRANS_P0_FLDMASK_POS                                0
+#define SW_IRQ_SRC_DP_TRANS_P0_FLDMASK_LEN                                16
+
+#define REG_35C4_DP_TRANS_P0              (0x35C4)
+#define SW_IRQ_MASK_DP_TRANS_P0_FLDMASK                                   0xffff
+#define SW_IRQ_MASK_DP_TRANS_P0_FLDMASK_POS                               0
+#define SW_IRQ_MASK_DP_TRANS_P0_FLDMASK_LEN                               16
+
+#define REG_35C8_DP_TRANS_P0              (0x35C8)
+#define SW_IRQ_CLR_DP_TRANS_P0_FLDMASK                                    0xffff
+#define SW_IRQ_CLR_DP_TRANS_P0_FLDMASK_POS                                0
+#define SW_IRQ_CLR_DP_TRANS_P0_FLDMASK_LEN                                16
+
+#define REG_35CC_DP_TRANS_P0              (0x35CC)
+#define SW_IRQ_STATUS_DP_TRANS_P0_FLDMASK                                 0xffff
+#define SW_IRQ_STATUS_DP_TRANS_P0_FLDMASK_POS                             0
+#define SW_IRQ_STATUS_DP_TRANS_P0_FLDMASK_LEN                             16
+
+#define REG_35D0_DP_TRANS_P0              (0x35D0)
+#define SW_IRQ_FINAL_STATUS_DP_TRANS_P0_FLDMASK                           0xffff
+#define SW_IRQ_FINAL_STATUS_DP_TRANS_P0_FLDMASK_POS                       0
+#define SW_IRQ_FINAL_STATUS_DP_TRANS_P0_FLDMASK_LEN                       16
+
+#define REG_35D4_DP_TRANS_P0              (0x35D4)
+#define SW_IRQ_RAW_STATUS_DP_TRANS_P0_FLDMASK                             0xffff
+#define SW_IRQ_RAW_STATUS_DP_TRANS_P0_FLDMASK_POS                         0
+#define SW_IRQ_RAW_STATUS_DP_TRANS_P0_FLDMASK_LEN                         16
+
+#define REG_35D8_DP_TRANS_P0              (0x35D8)
+#define SW_IRQ_FORCE_DP_TRANS_P0_FLDMASK                                  0xffff
+#define SW_IRQ_FORCE_DP_TRANS_P0_FLDMASK_POS                              0
+#define SW_IRQ_FORCE_DP_TRANS_P0_FLDMASK_LEN                              16
+
+#define REG_35F0_DP_TRANS_P0              (0x35F0)
+#define DP_TRANSMITTER_DUMMY_RW_0_DP_TRANS_P0_FLDMASK                     0xffff
+#define DP_TRANSMITTER_DUMMY_RW_0_DP_TRANS_P0_FLDMASK_POS                 0
+#define DP_TRANSMITTER_DUMMY_RW_0_DP_TRANS_P0_FLDMASK_LEN                 16
+
+#define REG_35F4_DP_TRANS_P0              (0x35F4)
+#define DP_TRANSMITTER_DUMMY_RW_1_DP_TRANS_P0_FLDMASK                     0xffff
+#define DP_TRANSMITTER_DUMMY_RW_1_DP_TRANS_P0_FLDMASK_POS                 0
+#define DP_TRANSMITTER_DUMMY_RW_1_DP_TRANS_P0_FLDMASK_LEN                 16
+
+#define REG_35F8_DP_TRANS_P0              (0x35F8)
+#define DP_TRANSMITTER_DUMMY_R_0_DP_TRANS_P0_FLDMASK                      0xffff
+#define DP_TRANSMITTER_DUMMY_R_0_DP_TRANS_P0_FLDMASK_POS                  0
+#define DP_TRANSMITTER_DUMMY_R_0_DP_TRANS_P0_FLDMASK_LEN                  16
+
+#define REG_35FC_DP_TRANS_P0              (0x35FC)
+#define DP_TRANSMITTER_DUMMY_R_1_DP_TRANS_P0_FLDMASK                      0xffff
+#define DP_TRANSMITTER_DUMMY_R_1_DP_TRANS_P0_FLDMASK_POS                  0
+#define DP_TRANSMITTER_DUMMY_R_1_DP_TRANS_P0_FLDMASK_LEN                  16
+
+#define REG_3600_AUX_TX_P0              (0x3600)
+#define DP_TX_SW_RESET_AUX_TX_P0_FLDMASK                                  0x1
+#define DP_TX_SW_RESET_AUX_TX_P0_FLDMASK_POS                              0
+#define DP_TX_SW_RESET_AUX_TX_P0_FLDMASK_LEN                              1
+
+#define AUX_TOP_RESET_AUX_TX_P0_FLDMASK                                   0x2
+#define AUX_TOP_RESET_AUX_TX_P0_FLDMASK_POS                               1
+#define AUX_TOP_RESET_AUX_TX_P0_FLDMASK_LEN                               1
+
+#define SOFTWARE_RESET_RESERVED_AUX_TX_P0_FLDMASK                         0x1c
+#define SOFTWARE_RESET_RESERVED_AUX_TX_P0_FLDMASK_POS                     2
+#define SOFTWARE_RESET_RESERVED_AUX_TX_P0_FLDMASK_LEN                     3
+
+#define AUX_CLK_EN_AUX_TX_P0_FLDMASK                                      0x100
+#define AUX_CLK_EN_AUX_TX_P0_FLDMASK_POS                                  8
+#define AUX_CLK_EN_AUX_TX_P0_FLDMASK_LEN                                  1
+
+#define AUX_CLK_INV_AUX_TX_P0_FLDMASK                                     0x200
+#define AUX_CLK_INV_AUX_TX_P0_FLDMASK_POS                                 9
+#define AUX_CLK_INV_AUX_TX_P0_FLDMASK_LEN                                 1
+
+#define AUX_CLK_SEL_AUX_TX_P0_FLDMASK                                     0xc00
+#define AUX_CLK_SEL_AUX_TX_P0_FLDMASK_POS                                 10
+#define AUX_CLK_SEL_AUX_TX_P0_FLDMASK_LEN                                 2
+
+#define REG_3604_AUX_TX_P0              (0x3604)
+#define AUX_TX_FSM_SOFTWARE_RESET_AUX_TX_P0_FLDMASK                       0x8000
+#define AUX_TX_FSM_SOFTWARE_RESET_AUX_TX_P0_FLDMASK_POS                   15
+#define AUX_TX_FSM_SOFTWARE_RESET_AUX_TX_P0_FLDMASK_LEN                   1
+
+#define AUX_TX_PHY_SOFTWARE_RESET_AUX_TX_P0_FLDMASK                       0x4000
+#define AUX_TX_PHY_SOFTWARE_RESET_AUX_TX_P0_FLDMASK_POS                   14
+#define AUX_TX_PHY_SOFTWARE_RESET_AUX_TX_P0_FLDMASK_LEN                   1
+
+#define AUX_RX_FSM_SOFTWARE_RESET_AUX_TX_P0_FLDMASK                       0x2000
+#define AUX_RX_FSM_SOFTWARE_RESET_AUX_TX_P0_FLDMASK_POS                   13
+#define AUX_RX_FSM_SOFTWARE_RESET_AUX_TX_P0_FLDMASK_LEN                   1
+
+#define AUX_RX_PHY_SOFTWARE_RESET_AUX_TX_P0_FLDMASK                       0x1000
+#define AUX_RX_PHY_SOFTWARE_RESET_AUX_TX_P0_FLDMASK_POS                   12
+#define AUX_RX_PHY_SOFTWARE_RESET_AUX_TX_P0_FLDMASK_LEN                   1
+
+#define DP_TX_TESTBUS_SEL_AUX_TX_P0_FLDMASK                               0xff
+#define DP_TX_TESTBUS_SEL_AUX_TX_P0_FLDMASK_POS                           0
+#define DP_TX_TESTBUS_SEL_AUX_TX_P0_FLDMASK_LEN                           8
+
+#define REG_3608_AUX_TX_P0              (0x3608)
+#define DP_TX_INT_STATUS_AUX_TX_P0_FLDMASK                                0xffff
+#define DP_TX_INT_STATUS_AUX_TX_P0_FLDMASK_POS                            0
+#define DP_TX_INT_STATUS_AUX_TX_P0_FLDMASK_LEN                            16
+
+#define REG_360C_AUX_TX_P0              (0x360C)
+#define AUX_SWAP_AUX_TX_P0_FLDMASK                                        0x8000
+#define AUX_SWAP_AUX_TX_P0_FLDMASK_POS                                    15
+#define AUX_SWAP_AUX_TX_P0_FLDMASK_LEN                                    1
+
+#define AUX_AUX_REPLY_MCU_AUX_TX_P0_FLDMASK                               0x4000
+#define AUX_AUX_REPLY_MCU_AUX_TX_P0_FLDMASK_POS                           14
+#define AUX_AUX_REPLY_MCU_AUX_TX_P0_FLDMASK_LEN                           1
+
+#define AUX_TIMEOUT_CMP_MASK_AUX_TX_P0_FLDMASK                            0x2000
+#define AUX_TIMEOUT_CMP_MASK_AUX_TX_P0_FLDMASK_POS                        13
+#define AUX_TIMEOUT_CMP_MASK_AUX_TX_P0_FLDMASK_LEN                        1
+
+#define AUX_TIMEOUT_THR_AUX_TX_P0_FLDMASK                                 0x1fff
+#define AUX_TIMEOUT_THR_AUX_TX_P0_FLDMASK_POS                             0
+#define AUX_TIMEOUT_THR_AUX_TX_P0_FLDMASK_LEN                             13
+
+#define REG_3610_AUX_TX_P0              (0x3610)
+#define AUX_EDID_REPLY_MCU_AUX_TX_P0_FLDMASK                              0x8000
+#define AUX_EDID_REPLY_MCU_AUX_TX_P0_FLDMASK_POS                          15
+#define AUX_EDID_REPLY_MCU_AUX_TX_P0_FLDMASK_LEN                          1
+
+#define AUX_EDID_ADDR_AUX_TX_P0_FLDMASK                                   0x7f00
+#define AUX_EDID_ADDR_AUX_TX_P0_FLDMASK_POS                               8
+#define AUX_EDID_ADDR_AUX_TX_P0_FLDMASK_LEN                               7
+
+#define AUX_MCCS_REPLY_MCU_AUX_TX_P0_FLDMASK                              0x80
+#define AUX_MCCS_REPLY_MCU_AUX_TX_P0_FLDMASK_POS                          7
+#define AUX_MCCS_REPLY_MCU_AUX_TX_P0_FLDMASK_LEN                          1
+
+#define AUX_MCCS_ADDR_AUX_TX_P0_FLDMASK                                   0x7f
+#define AUX_MCCS_ADDR_AUX_TX_P0_FLDMASK_POS                               0
+#define AUX_MCCS_ADDR_AUX_TX_P0_FLDMASK_LEN                               7
+
+#define REG_3614_AUX_TX_P0              (0x3614)
+#define AUX_TIMEOUT_THR_EXTEN_AUX_TX_P0_FLDMASK                           0x4000
+#define AUX_TIMEOUT_THR_EXTEN_AUX_TX_P0_FLDMASK_POS                       14
+#define AUX_TIMEOUT_THR_EXTEN_AUX_TX_P0_FLDMASK_LEN                       1
+
+#define AUX_RX_AVERAGE_SEL_AUX_TX_P0_FLDMASK                              0x3000
+#define AUX_RX_AVERAGE_SEL_AUX_TX_P0_FLDMASK_POS                          12
+#define AUX_RX_AVERAGE_SEL_AUX_TX_P0_FLDMASK_LEN                          2
+
+#define AUX_RX_SYNC_PATTERN_THR_AUX_TX_P0_FLDMASK                         0xf00
+#define AUX_RX_SYNC_PATTERN_THR_AUX_TX_P0_FLDMASK_POS                     8
+#define AUX_RX_SYNC_PATTERN_THR_AUX_TX_P0_FLDMASK_LEN                     4
+
+#define AUX_RX_DECODE_SEL_AUX_TX_P0_FLDMASK                               0x80
+#define AUX_RX_DECODE_SEL_AUX_TX_P0_FLDMASK_POS                           7
+#define AUX_RX_DECODE_SEL_AUX_TX_P0_FLDMASK_LEN                           1
+
+#define AUX_RX_UI_CNT_THR_AUX_TX_P0_FLDMASK                               0x7f
+#define AUX_RX_UI_CNT_THR_AUX_TX_P0_FLDMASK_POS                           0
+#define AUX_RX_UI_CNT_THR_AUX_TX_P0_FLDMASK_LEN                           7
+
+#define REG_3618_AUX_TX_P0              (0x3618)
+#define AUX_RX_DP_REV_AUX_TX_P0_FLDMASK                                   0x400
+#define AUX_RX_DP_REV_AUX_TX_P0_FLDMASK_POS                               10
+#define AUX_RX_DP_REV_AUX_TX_P0_FLDMASK_LEN                               1
+
+#define AUX_RX_FIFO_FULL_AUX_TX_P0_FLDMASK                                0x200
+#define AUX_RX_FIFO_FULL_AUX_TX_P0_FLDMASK_POS                            9
+#define AUX_RX_FIFO_FULL_AUX_TX_P0_FLDMASK_LEN                            1
+
+#define AUX_RX_FIFO_EMPTY_AUX_TX_P0_FLDMASK                               0x100
+#define AUX_RX_FIFO_EMPTY_AUX_TX_P0_FLDMASK_POS                           8
+#define AUX_RX_FIFO_EMPTY_AUX_TX_P0_FLDMASK_LEN                           1
+
+#define AUX_RX_FIFO_READ_POINTER_AUX_TX_P0_FLDMASK                        0xf0
+#define AUX_RX_FIFO_READ_POINTER_AUX_TX_P0_FLDMASK_POS                    4
+#define AUX_RX_FIFO_READ_POINTER_AUX_TX_P0_FLDMASK_LEN                    4
+
+#define AUX_RX_FIFO_WRITE_POINTER_AUX_TX_P0_FLDMASK                       0xf
+#define AUX_RX_FIFO_WRITE_POINTER_AUX_TX_P0_FLDMASK_POS                   0
+#define AUX_RX_FIFO_WRITE_POINTER_AUX_TX_P0_FLDMASK_LEN                   4
+
+#define REG_361C_AUX_TX_P0              (0x361C)
+#define AUX_RX_DATA_BYTE_CNT_AUX_TX_P0_FLDMASK                            0xff00
+#define AUX_RX_DATA_BYTE_CNT_AUX_TX_P0_FLDMASK_POS                        8
+#define AUX_RX_DATA_BYTE_CNT_AUX_TX_P0_FLDMASK_LEN                        8
+
+#define AUX_RESERVED_RO_0_AUX_TX_P0_FLDMASK                               0xff
+#define AUX_RESERVED_RO_0_AUX_TX_P0_FLDMASK_POS                           0
+#define AUX_RESERVED_RO_0_AUX_TX_P0_FLDMASK_LEN                           8
+
+#define REG_3620_AUX_TX_P0              (0x3620)
+#define AUX_RD_MODE_AUX_TX_P0_FLDMASK                                     0x200
+#define AUX_RD_MODE_AUX_TX_P0_FLDMASK_POS                                 9
+#define AUX_RD_MODE_AUX_TX_P0_FLDMASK_LEN                                 1
+
+#define AUX_RX_FIFO_READ_PULSE_TX_P0_FLDMASK                          0x100
+#define AUX_RX_FIFO_R_PULSE_TX_P0_FLDMASK_POS                      8
+#define AUX_RX_FIFO_READ_PULSE_AUX_TX_P0_FLDMASK_LEN                      1
+
+#define AUX_RX_FIFO_READ_DATA_AUX_TX_P0_FLDMASK                           0xff
+#define AUX_RX_FIFO_READ_DATA_AUX_TX_P0_FLDMASK_POS                       0
+#define AUX_RX_FIFO_READ_DATA_AUX_TX_P0_FLDMASK_LEN                       8
+
+#define REG_3624_AUX_TX_P0              (0x3624)
+#define AUX_RX_REPLY_COMMAND_AUX_TX_P0_FLDMASK                            0xf
+#define AUX_RX_REPLY_COMMAND_AUX_TX_P0_FLDMASK_POS                        0
+#define AUX_RX_REPLY_COMMAND_AUX_TX_P0_FLDMASK_LEN                        4
+
+#define AUX_RX_REPLY_ADDRESS_NONE_AUX_TX_P0_FLDMASK                       0xf00
+#define AUX_RX_REPLY_ADDRESS_NONE_AUX_TX_P0_FLDMASK_POS                   8
+#define AUX_RX_REPLY_ADDRESS_NONE_AUX_TX_P0_FLDMASK_LEN                   4
+
+#define REG_3628_AUX_TX_P0              (0x3628)
+#define AUX_RESERVED_RO_1_AUX_TX_P0_FLDMASK                               0xfc00
+#define AUX_RESERVED_RO_1_AUX_TX_P0_FLDMASK_POS                           10
+#define AUX_RESERVED_RO_1_AUX_TX_P0_FLDMASK_LEN                           6
+
+#define AUX_RX_PHY_STATE_AUX_TX_P0_FLDMASK                                0x3ff
+#define AUX_RX_PHY_STATE_AUX_TX_P0_FLDMASK_POS                            0
+#define AUX_RX_PHY_STATE_AUX_TX_P0_FLDMASK_LEN                            10
+
+#define REG_362C_AUX_TX_P0              (0x362C)
+#define AUX_NO_LENGTH_AUX_TX_P0_FLDMASK                                   0x1
+#define AUX_NO_LENGTH_AUX_TX_P0_FLDMASK_POS                               0
+#define AUX_NO_LENGTH_AUX_TX_P0_FLDMASK_LEN                               1
+
+#define AUX_TX_AUXTX_OV_EN_AUX_TX_P0_FLDMASK                              0x2
+#define AUX_TX_AUXTX_OV_EN_AUX_TX_P0_FLDMASK_POS                          1
+#define AUX_TX_AUXTX_OV_EN_AUX_TX_P0_FLDMASK_LEN                          1
+
+#define AUX_RESERVED_RW_0_AUX_TX_P0_FLDMASK                               0xfffc
+#define AUX_RESERVED_RW_0_AUX_TX_P0_FLDMASK_POS                           2
+#define AUX_RESERVED_RW_0_AUX_TX_P0_FLDMASK_LEN                           14
+
+#define REG_3630_AUX_TX_P0              (0x3630)
+#define AUX_TX_REQUEST_READY_AUX_TX_P0_FLDMASK                            0x8
+#define AUX_TX_REQUEST_READY_AUX_TX_P0_FLDMASK_POS                        3
+#define AUX_TX_REQUEST_READY_AUX_TX_P0_FLDMASK_LEN                        1
+
+#define AUX_TX_PRE_NUM_AUX_TX_P0_FLDMASK                                  0xff00
+#define AUX_TX_PRE_NUM_AUX_TX_P0_FLDMASK_POS                              8
+#define AUX_TX_PRE_NUM_AUX_TX_P0_FLDMASK_LEN                              8
+
+#define REG_3634_AUX_TX_P0              (0x3634)
+#define AUX_TX_OVER_SAMPLE_RATE_AUX_TX_P0_FLDMASK                         0xff00
+#define AUX_TX_OVER_SAMPLE_RATE_AUX_TX_P0_FLDMASK_POS                     8
+#define AUX_TX_OVER_SAMPLE_RATE_AUX_TX_P0_FLDMASK_LEN                     8
+
+#define AUX_TX_FIFO_WRITE_DATA_AUX_TX_P0_FLDMASK                          0xff
+#define AUX_TX_FIFO_WRITE_DATA_AUX_TX_P0_FLDMASK_POS                      0
+#define AUX_TX_FIFO_WRITE_DATA_AUX_TX_P0_FLDMASK_LEN                      8
+
+#define REG_3638_AUX_TX_P0              (0x3638)
+#define AUX_TX_FIFO_READ_POINTER_AUX_TX_P0_FLDMASK                        0xf0
+#define AUX_TX_FIFO_READ_POINTER_AUX_TX_P0_FLDMASK_POS                    4
+#define AUX_TX_FIFO_READ_POINTER_AUX_TX_P0_FLDMASK_LEN                    4
+
+#define AUX_TX_FIFO_WRITE_POINTER_AUX_TX_P0_FLDMASK                       0xf
+#define AUX_TX_FIFO_WRITE_POINTER_AUX_TX_P0_FLDMASK_POS                   0
+#define AUX_TX_FIFO_WRITE_POINTER_AUX_TX_P0_FLDMASK_LEN                   4
+
+#define REG_363C_AUX_TX_P0              (0x363C)
+#define AUX_TX_FIFO_FULL_AUX_TX_P0_FLDMASK                                0x1000
+#define AUX_TX_FIFO_FULL_AUX_TX_P0_FLDMASK_POS                            12
+#define AUX_TX_FIFO_FULL_AUX_TX_P0_FLDMASK_LEN                            1
+
+#define AUX_TX_FIFO_EMPTY_AUX_TX_P0_FLDMASK                               0x800
+#define AUX_TX_FIFO_EMPTY_AUX_TX_P0_FLDMASK_POS                           11
+#define AUX_TX_FIFO_EMPTY_AUX_TX_P0_FLDMASK_LEN                           1
+
+#define AUX_TX_PHY_STATE_AUX_TX_P0_FLDMASK                                0x7ff
+#define AUX_TX_PHY_STATE_AUX_TX_P0_FLDMASK_POS                            0
+#define AUX_TX_PHY_STATE_AUX_TX_P0_FLDMASK_LEN                            11
+
+#define REG_3640_AUX_TX_P0              (0x3640)
+#define AUX_RX_RECV_COMPLETE_IRQ_TX_P0_FLDMASK                    0x40
+#define AUX_RX_AUX_RECV_COMPLETE_IRQ_AUX_TX_P0_FLDMASK_POS                6
+#define AUX_RX_AUX_RECV_COMPLETE_IRQ_AUX_TX_P0_FLDMASK_LEN                1
+
+#define AUX_RX_EDID_RECV_COMPLETE_IRQ_AUX_TX_P0_FLDMASK                   0x20
+#define AUX_RX_EDID_RECV_COMPLETE_IRQ_AUX_TX_P0_FLDMASK_POS               5
+#define AUX_RX_EDID_RECV_COMPLETE_IRQ_AUX_TX_P0_FLDMASK_LEN               1
+
+#define AUX_RX_MCCS_RECV_COMPLETE_IRQ_AUX_TX_P0_FLDMASK                   0x10
+#define AUX_RX_MCCS_RECV_COMPLETE_IRQ_AUX_TX_P0_FLDMASK_POS               4
+#define AUX_RX_MCCS_RECV_COMPLETE_IRQ_AUX_TX_P0_FLDMASK_LEN               1
+
+#define AUX_RX_CMD_RECV_IRQ_AUX_TX_P0_FLDMASK                             0x8
+#define AUX_RX_CMD_RECV_IRQ_AUX_TX_P0_FLDMASK_POS                         3
+#define AUX_RX_CMD_RECV_IRQ_AUX_TX_P0_FLDMASK_LEN                         1
+
+#define AUX_RX_ADDR_RECV_IRQ_AUX_TX_P0_FLDMASK                            0x4
+#define AUX_RX_ADDR_RECV_IRQ_AUX_TX_P0_FLDMASK_POS                        2
+#define AUX_RX_ADDR_RECV_IRQ_AUX_TX_P0_FLDMASK_LEN                        1
+
+#define AUX_RX_DATA_RECV_IRQ_AUX_TX_P0_FLDMASK                            0x2
+#define AUX_RX_DATA_RECV_IRQ_AUX_TX_P0_FLDMASK_POS                        1
+#define AUX_RX_DATA_RECV_IRQ_AUX_TX_P0_FLDMASK_LEN                        1
+
+#define AUX_400US_TIMEOUT_IRQ_AUX_TX_P0_FLDMASK                           0x1
+#define AUX_400US_TIMEOUT_IRQ_AUX_TX_P0_FLDMASK_POS                       0
+#define AUX_400US_TIMEOUT_IRQ_AUX_TX_P0_FLDMASK_LEN                       1
+
+#define REG_3644_AUX_TX_P0              (0x3644)
+#define MCU_REQUEST_COMMAND_AUX_TX_P0_FLDMASK                             0xf
+#define MCU_REQUEST_COMMAND_AUX_TX_P0_FLDMASK_POS                         0
+#define MCU_REQUEST_COMMAND_AUX_TX_P0_FLDMASK_LEN                         4
+
+#define AUX_STATE_AUX_TX_P0_FLDMASK                                       0xf00
+#define AUX_STATE_AUX_TX_P0_FLDMASK_POS                                   8
+#define AUX_STATE_AUX_TX_P0_FLDMASK_LEN                                   4
+
+#define REG_3648_AUX_TX_P0              (0x3648)
+#define MCU_REQUEST_ADDRESS_LSB_AUX_TX_P0_FLDMASK                         0xffff
+#define MCU_REQUEST_ADDRESS_LSB_AUX_TX_P0_FLDMASK_POS                     0
+#define MCU_REQUEST_ADDRESS_LSB_AUX_TX_P0_FLDMASK_LEN                     16
+
+#define REG_364C_AUX_TX_P0              (0x364C)
+#define MCU_REQUEST_ADDRESS_MSB_AUX_TX_P0_FLDMASK                         0xf
+#define MCU_REQUEST_ADDRESS_MSB_AUX_TX_P0_FLDMASK_POS                     0
+#define MCU_REQUEST_ADDRESS_MSB_AUX_TX_P0_FLDMASK_LEN                     4
+
+#define REG_3650_AUX_TX_P0              (0x3650)
+#define MCU_REQUEST_DATA_NUM_AUX_TX_P0_FLDMASK                            0xf000
+#define MCU_REQ_DATA_NUM_AUX_TX_P0_FLDMASK_POS                        12
+#define MCU_REQUEST_DATA_NUM_AUX_TX_P0_FLDMASK_LEN                        4
+
+#define PHY_FIFO_RST_AUX_TX_P0_FLDMASK                                    0x200
+#define PHY_FIFO_RST_AUX_TX_P0_FLDMASK_POS                                9
+#define PHY_FIFO_RST_AUX_TX_P0_FLDMASK_LEN                                1
+
+#define MCU_ACK_TRANSACTION_COMPLETE_AUX_TX_P0_FLDMASK                    0x100
+#define MCU_ACK_TRAN_COMPLETE_AUX_TX_P0_FLDMASK_POS                8
+#define MCU_ACK_TRANSACTION_COMPLETE_AUX_TX_P0_FLDMASK_LEN                1
+
+#define AUX_TEST_CONFIG_AUX_TX_P0_FLDMASK                                 0xff
+#define AUX_TEST_CONFIG_AUX_TX_P0_FLDMASK_POS                             0
+#define AUX_TEST_CONFIG_AUX_TX_P0_FLDMASK_LEN                             8
+
+#define REG_3654_AUX_TX_P0              (0x3654)
+#define TST_AUXRX_AUX_TX_P0_FLDMASK                                       0xff
+#define TST_AUXRX_AUX_TX_P0_FLDMASK_POS                                   0
+#define TST_AUXRX_AUX_TX_P0_FLDMASK_LEN                                   8
+
+#define REG_3658_AUX_TX_P0              (0x3658)
+#define AUX_TX_OV_EN_AUX_TX_P0_FLDMASK                                    0x1
+#define AUX_TX_OV_EN_AUX_TX_P0_FLDMASK_POS                                0
+#define AUX_TX_OV_EN_AUX_TX_P0_FLDMASK_LEN                                1
+
+#define AUX_TX_VALUE_SET_AUX_TX_P0_FLDMASK                                0x2
+#define AUX_TX_VALUE_SET_AUX_TX_P0_FLDMASK_POS                            1
+#define AUX_TX_VALUE_SET_AUX_TX_P0_FLDMASK_LEN                            1
+
+#define AUX_TX_OEN_SET_AUX_TX_P0_FLDMASK                                  0x4
+#define AUX_TX_OEN_SET_AUX_TX_P0_FLDMASK_POS                              2
+#define AUX_TX_OEN_SET_AUX_TX_P0_FLDMASK_LEN                              1
+
+#define AUX_TX_OV_MODE_AUX_TX_P0_FLDMASK                                  0x8
+#define AUX_TX_OV_MODE_AUX_TX_P0_FLDMASK_POS                              3
+#define AUX_TX_OV_MODE_AUX_TX_P0_FLDMASK_LEN                              1
+
+#define AUX_TX_OFF_AUX_TX_P0_FLDMASK                                      0x10
+#define AUX_TX_OFF_AUX_TX_P0_FLDMASK_POS                                  4
+#define AUX_TX_OFF_AUX_TX_P0_FLDMASK_LEN                                  1
+
+#define EXT_AUX_PHY_MODE_AUX_TX_P0_FLDMASK                                0x20
+#define EXT_AUX_PHY_MODE_AUX_TX_P0_FLDMASK_POS                            5
+#define EXT_AUX_PHY_MODE_AUX_TX_P0_FLDMASK_LEN                            1
+
+#define EXT_TX_OEN_POLARITY_AUX_TX_P0_FLDMASK                             0x40
+#define EXT_TX_OEN_POLARITY_AUX_TX_P0_FLDMASK_POS                         6
+#define EXT_TX_OEN_POLARITY_AUX_TX_P0_FLDMASK_LEN                         1
+
+#define AUX_RX_OEN_SET_AUX_TX_P0_FLDMASK                                  0x80
+#define AUX_RX_OEN_SET_AUX_TX_P0_FLDMASK_POS                              7
+#define AUX_RX_OEN_SET_AUX_TX_P0_FLDMASK_LEN                              1
+
+#define REG_365C_AUX_TX_P0              (0x365C)
+#define AUX_RCTRL_AUX_TX_P0_FLDMASK                                       0x1f
+#define AUX_RCTRL_AUX_TX_P0_FLDMASK_POS                                   0
+#define AUX_RCTRL_AUX_TX_P0_FLDMASK_LEN                                   5
+
+#define AUX_RPD_AUX_TX_P0_FLDMASK                                         0x20
+#define AUX_RPD_AUX_TX_P0_FLDMASK_POS                                     5
+#define AUX_RPD_AUX_TX_P0_FLDMASK_LEN                                     1
+
+#define AUX_RX_SEL_AUX_TX_P0_FLDMASK                                      0x40
+#define AUX_RX_SEL_AUX_TX_P0_FLDMASK_POS                                  6
+#define AUX_RX_SEL_AUX_TX_P0_FLDMASK_LEN                                  1
+
+#define AUXRX_DEBOUNCE_SEL_AUX_TX_P0_FLDMASK                              0x80
+#define AUXRX_DEBOUNCE_SEL_AUX_TX_P0_FLDMASK_POS                          7
+#define AUXRX_DEBOUNCE_SEL_AUX_TX_P0_FLDMASK_LEN                          1
+
+#define AUXRXVALID_DEBOUNCE_SEL_AUX_TX_P0_FLDMASK                         0x100
+#define AUXRXVALID_DEBOUNCE_SEL_AUX_TX_P0_FLDMASK_POS                     8
+#define AUXRXVALID_DEBOUNCE_SEL_AUX_TX_P0_FLDMASK_LEN                     1
+
+#define AUX_DEBOUNCE_CLKSEL_AUX_TX_P0_FLDMASK                             0xe00
+#define AUX_DEBOUNCE_CLKSEL_AUX_TX_P0_FLDMASK_POS                         9
+#define AUX_DEBOUNCE_CLKSEL_AUX_TX_P0_FLDMASK_LEN                         3
+
+#define DATA_VALID_DEBOUNCE_SEL_AUX_TX_P0_FLDMASK                         0x1000
+#define DATA_VALID_DEBOUNCE_SEL_AUX_TX_P0_FLDMASK_POS                     12
+#define DATA_VALID_DEBOUNCE_SEL_AUX_TX_P0_FLDMASK_LEN                     1
+
+#define REG_3660_AUX_TX_P0              (0x3660)
+#define DP_TX_INT_MASK_AUX_TX_P0_FLDMASK                                  0xffff
+#define DP_TX_INT_MASK_AUX_TX_P0_FLDMASK_POS                              0
+#define DP_TX_INT_MASK_AUX_TX_P0_FLDMASK_LEN                              16
+
+#define REG_3664_AUX_TX_P0              (0x3664)
+#define DP_TX_INT_FORCE_AUX_TX_P0_FLDMASK                                 0xffff
+#define DP_TX_INT_FORCE_AUX_TX_P0_FLDMASK_POS                             0
+#define DP_TX_INT_FORCE_AUX_TX_P0_FLDMASK_LEN                             16
+
+#define REG_3668_AUX_TX_P0              (0x3668)
+#define DP_TX_INT_CLR_AUX_TX_P0_FLDMASK                                   0xffff
+#define DP_TX_INT_CLR_AUX_TX_P0_FLDMASK_POS                               0
+#define DP_TX_INT_CLR_AUX_TX_P0_FLDMASK_LEN                               16
+
+#define REG_366C_AUX_TX_P0              (0x366C)
+#define XTAL_FREQ_AUX_TX_P0_FLDMASK                                       0xff00
+#define XTAL_FREQ_AUX_TX_P0_FLDMASK_POS                                   8
+#define XTAL_FREQ_AUX_TX_P0_FLDMASK_LEN                                   8
+
+#define REG_3670_AUX_TX_P0              (0x3670)
+#define DPTX_GPIO_OEN_AUX_TX_P0_FLDMASK                                   0x7
+#define DPTX_GPIO_OEN_AUX_TX_P0_FLDMASK_POS                               0
+#define DPTX_GPIO_OEN_AUX_TX_P0_FLDMASK_LEN                               3
+
+#define DPTX_GPIO_OUT_AUX_TX_P0_FLDMASK                                   0x38
+#define DPTX_GPIO_OUT_AUX_TX_P0_FLDMASK_POS                               3
+#define DPTX_GPIO_OUT_AUX_TX_P0_FLDMASK_LEN                               3
+
+#define DPTX_GPIO_IN_AUX_TX_P0_FLDMASK                                    0x1c0
+#define DPTX_GPIO_IN_AUX_TX_P0_FLDMASK_POS                                6
+#define DPTX_GPIO_IN_AUX_TX_P0_FLDMASK_LEN                                3
+
+#define AUX_IN_AUX_TX_P0_FLDMASK                                          0x200
+#define AUX_IN_AUX_TX_P0_FLDMASK_POS                                      9
+#define AUX_IN_AUX_TX_P0_FLDMASK_LEN                                      1
+
+#define PD_AUX_RTERM_AUX_TX_P0_FLDMASK                                    0x400
+#define PD_AUX_RTERM_AUX_TX_P0_FLDMASK_POS                                10
+#define PD_AUX_RTERM_AUX_TX_P0_FLDMASK_LEN                                1
+
+#define DPTX_GPIO_EN_AUX_TX_P0_FLDMASK                                    0x7000
+#define DPTX_GPIO_EN_AUX_TX_P0_FLDMASK_POS                                12
+#define DPTX_GPIO_EN_AUX_TX_P0_FLDMASK_LEN                                3
+
+#define REG_3674_AUX_TX_P0              (0x3674)
+#define AUXTX_ISEL_AUX_TX_P0_FLDMASK                                      0x1f
+#define AUXTX_ISEL_AUX_TX_P0_FLDMASK_POS                                  0
+#define AUXTX_ISEL_AUX_TX_P0_FLDMASK_LEN                                  5
+
+#define AUXRX_VTH_AUX_TX_P0_FLDMASK                                       0x60
+#define AUXRX_VTH_AUX_TX_P0_FLDMASK_POS                                   5
+#define AUXRX_VTH_AUX_TX_P0_FLDMASK_LEN                                   2
+
+#define EN_RXCM_BOOST_AUX_TX_P0_FLDMASK                                   0x80
+#define EN_RXCM_BOOST_AUX_TX_P0_FLDMASK_POS                               7
+#define EN_RXCM_BOOST_AUX_TX_P0_FLDMASK_LEN                               1
+
+#define DPTX_AUX_R_CTRL_AUX_TX_P0_FLDMASK                                 0x1f00
+#define DPTX_AUX_R_CTRL_AUX_TX_P0_FLDMASK_POS                             8
+#define DPTX_AUX_R_CTRL_AUX_TX_P0_FLDMASK_LEN                             5
+
+#define I2C_EN_AUXN_AUX_TX_P0_FLDMASK                                     0x2000
+#define I2C_EN_AUXN_AUX_TX_P0_FLDMASK_POS                                 13
+#define I2C_EN_AUXN_AUX_TX_P0_FLDMASK_LEN                                 1
+
+#define I2C_EN_AUXP_AUX_TX_P0_FLDMASK                                     0x4000
+#define I2C_EN_AUXP_AUX_TX_P0_FLDMASK_POS                                 14
+#define I2C_EN_AUXP_AUX_TX_P0_FLDMASK_LEN                                 1
+
+#define REG_3678_AUX_TX_P0              (0x3678)
+#define TEST_AUXTX_AUX_TX_P0_FLDMASK                                      0xff00
+#define TEST_AUXTX_AUX_TX_P0_FLDMASK_POS                                  8
+#define TEST_AUXTX_AUX_TX_P0_FLDMASK_LEN                                  8
+
+#define REG_367C_AUX_TX_P0              (0x367C)
+#define DPTX_AUXRX_AUX_TX_P0_FLDMASK                                      0x4
+#define DPTX_AUXRX_AUX_TX_P0_FLDMASK_POS                                  2
+#define DPTX_AUXRX_AUX_TX_P0_FLDMASK_LEN                                  1
+
+#define DPTX_AUXRX_VALID_AUX_TX_P0_FLDMASK                                0x8
+#define DPTX_AUXRX_VALID_AUX_TX_P0_FLDMASK_POS                            3
+#define DPTX_AUXRX_VALID_AUX_TX_P0_FLDMASK_LEN                            1
+
+#define DPTX_AUXRX_WO_TH_AUX_TX_P0_FLDMASK                                0x10
+#define DPTX_AUXRX_WO_TH_AUX_TX_P0_FLDMASK_POS                            4
+#define DPTX_AUXRX_WO_TH_AUX_TX_P0_FLDMASK_LEN                            1
+
+#define DPTX_AUXRX_L_TEST_AUX_TX_P0_FLDMASK                               0x20
+#define DPTX_AUXRX_L_TEST_AUX_TX_P0_FLDMASK_POS                           5
+#define DPTX_AUXRX_L_TEST_AUX_TX_P0_FLDMASK_LEN                           1
+
+#define EN_AUXRX_AUX_TX_P0_FLDMASK                                        0x400
+#define EN_AUXRX_AUX_TX_P0_FLDMASK_POS                                    10
+#define EN_AUXRX_AUX_TX_P0_FLDMASK_LEN                                    1
+
+#define EN_AUXTX_AUX_TX_P0_FLDMASK                                        0x800
+#define EN_AUXTX_AUX_TX_P0_FLDMASK_POS                                    11
+#define EN_AUXTX_AUX_TX_P0_FLDMASK_LEN                                    1
+
+#define EN_AUX_AUX_TX_P0_FLDMASK                                          0x1000
+#define EN_AUX_AUX_TX_P0_FLDMASK_POS                                      12
+#define EN_AUX_AUX_TX_P0_FLDMASK_LEN                                      1
+
+#define EN_5V_TOL_AUX_TX_P0_FLDMASK                                       0x2000
+#define EN_5V_TOL_AUX_TX_P0_FLDMASK_POS                                   13
+#define EN_5V_TOL_AUX_TX_P0_FLDMASK_LEN                                   1
+
+#define AUXP_I_AUX_TX_P0_FLDMASK                                          0x4000
+#define AUXP_I_AUX_TX_P0_FLDMASK_POS                                      14
+#define AUXP_I_AUX_TX_P0_FLDMASK_LEN                                      1
+
+#define AUXN_I_AUX_TX_P0_FLDMASK                                          0x8000
+#define AUXN_I_AUX_TX_P0_FLDMASK_POS                                      15
+#define AUXN_I_AUX_TX_P0_FLDMASK_LEN                                      1
+
+#define REG_3680_AUX_TX_P0              (0x3680)
+#define AUX_SWAP_TX_AUX_TX_P0_FLDMASK                                     0x1
+#define AUX_SWAP_TX_AUX_TX_P0_FLDMASK_POS                                 0
+#define AUX_SWAP_TX_AUX_TX_P0_FLDMASK_LEN                                 1
+
+#define REG_3684_AUX_TX_P0              (0x3684)
+#define TEST_IO_LOOPBK_AUX_TX_P0_FLDMASK                                  0x1f
+#define TEST_IO_LOOPBK_AUX_TX_P0_FLDMASK_POS                              0
+#define TEST_IO_LOOPBK_AUX_TX_P0_FLDMASK_LEN                              5
+
+#define RO_IO_LOOPBKT_AUX_TX_P0_FLDMASK                                   0x300
+#define RO_IO_LOOPBKT_AUX_TX_P0_FLDMASK_POS                               8
+#define RO_IO_LOOPBKT_AUX_TX_P0_FLDMASK_LEN                               2
+
+#define SEL_TCLK_AUX_TX_P0_FLDMASK                                        0x3000
+#define SEL_TCLK_AUX_TX_P0_FLDMASK_POS                                    12
+#define SEL_TCLK_AUX_TX_P0_FLDMASK_LEN                                    2
+
+#define TESTEN_ASIO_AUX_TX_P0_FLDMASK                                     0x4000
+#define TESTEN_ASIO_AUX_TX_P0_FLDMASK_POS                                 14
+#define TESTEN_ASIO_AUX_TX_P0_FLDMASK_LEN                                 1
+
+#define REG_3688_AUX_TX_P0              (0x3688)
+#define TEST_AUXRX_VTH_AUX_TX_P0_FLDMASK                                  0x7
+#define TEST_AUXRX_VTH_AUX_TX_P0_FLDMASK_POS                              0
+#define TEST_AUXRX_VTH_AUX_TX_P0_FLDMASK_LEN                              3
+
+#define REG_368C_AUX_TX_P0              (0x368C)
+#define RX_FIFO_DONE_AUX_TX_P0_FLDMASK                                    0x1
+#define RX_FIFO_DONE_AUX_TX_P0_FLDMASK_POS                                0
+#define RX_FIFO_DONE_AUX_TX_P0_FLDMASK_LEN                                1
+
+#define RX_FIFO_DONE_CLR_AUX_TX_P0_FLDMASK                                0x2
+#define RX_FIFO_DONE_CLR_AUX_TX_P0_FLDMASK_POS                            1
+#define RX_FIFO_DONE_CLR_AUX_TX_P0_FLDMASK_LEN                            1
+
+#define TX_FIFO_DONE_AUX_TX_P0_FLDMASK                                    0x4
+#define TX_FIFO_DONE_AUX_TX_P0_FLDMASK_POS                                2
+#define TX_FIFO_DONE_AUX_TX_P0_FLDMASK_LEN                                1
+
+#define TX_FIFO_DONE_CLR_AUX_TX_P0_FLDMASK                                0x8
+#define TX_FIFO_DONE_CLR_AUX_TX_P0_FLDMASK_POS                            3
+#define TX_FIFO_DONE_CLR_AUX_TX_P0_FLDMASK_LEN                            1
+
+#define REG_3690_AUX_TX_P0              (0x3690)
+#define DATA_LOW_CNT_THRD_AUX_TX_P0_FLDMASK                               0x7f
+#define DATA_LOW_CNT_THRD_AUX_TX_P0_FLDMASK_POS                           0
+#define DATA_LOW_CNT_THRD_AUX_TX_P0_FLDMASK_LEN                           7
+
+#define RX_REPLY_COMPLETE_MODE_AUX_TX_P0_FLDMASK                          0x100
+#define RX_REPLY_COMPLETE_MODE_AUX_TX_P0_FLDMASK_POS                      8
+#define RX_REPLY_COMPLETE_MODE_AUX_TX_P0_FLDMASK_LEN                      1
+
+#define REG_36C0_AUX_TX_P0              (0x36C0)
+#define RX_GTC_VALUE_0_AUX_TX_P0_FLDMASK                                  0xffff
+#define RX_GTC_VALUE_0_AUX_TX_P0_FLDMASK_POS                              0
+#define RX_GTC_VALUE_0_AUX_TX_P0_FLDMASK_LEN                              16
+
+#define REG_36C4_AUX_TX_P0              (0x36C4)
+#define RX_GTC_VALUE_1_AUX_TX_P0_FLDMASK                                  0xffff
+#define RX_GTC_VALUE_1_AUX_TX_P0_FLDMASK_POS                              0
+#define RX_GTC_VALUE_1_AUX_TX_P0_FLDMASK_LEN                              16
+
+#define REG_36C8_AUX_TX_P0              (0x36C8)
+#define RX_GTC_MASTER_REQ_AUX_TX_P0_FLDMASK                               0x1
+#define RX_GTC_MASTER_REQ_AUX_TX_P0_FLDMASK_POS                           0
+#define RX_GTC_MASTER_REQ_AUX_TX_P0_FLDMASK_LEN                           1
+
+#define TX_GTC_VALUE_PHASE_SKEW_EN_AUX_TX_P0_FLDMASK                      0x2
+#define TX_GTC_VALUE_PHASE_SKEW_EN_AUX_TX_P0_FLDMASK_POS                  1
+#define TX_GTC_VALUE_PHASE_SKEW_EN_AUX_TX_P0_FLDMASK_LEN                  1
+
+#define RX_GTC_FREQ_LOCK_DONE_AUX_TX_P0_FLDMASK                           0x4
+#define RX_GTC_FREQ_LOCK_DONE_AUX_TX_P0_FLDMASK_POS                       2
+#define RX_GTC_FREQ_LOCK_DONE_AUX_TX_P0_FLDMASK_LEN                       1
+
+#define REG_36CC_AUX_TX_P0              (0x36CC)
+#define RX_GTC_PHASE_SKEW_OFFSET_AUX_TX_P0_FLDMASK                        0xffff
+#define RX_GTC_PHASE_SKEW_OFFSET_AUX_TX_P0_FLDMASK_POS                    0
+#define RX_GTC_PHASE_SKEW_OFFSET_AUX_TX_P0_FLDMASK_LEN                    16
+
+#define REG_36D0_AUX_TX_P0              (0x36D0)
+#define TX_GTC_VALUE_0_AUX_TX_P0_FLDMASK                                  0xffff
+#define TX_GTC_VALUE_0_AUX_TX_P0_FLDMASK_POS                              0
+#define TX_GTC_VALUE_0_AUX_TX_P0_FLDMASK_LEN                              16
+
+#define REG_36D4_AUX_TX_P0              (0x36D4)
+#define TX_GTC_VALUE_1_AUX_TX_P0_FLDMASK                                  0xffff
+#define TX_GTC_VALUE_1_AUX_TX_P0_FLDMASK_POS                              0
+#define TX_GTC_VALUE_1_AUX_TX_P0_FLDMASK_LEN                              16
+
+#define REG_36D8_AUX_TX_P0              (0x36D8)
+#define RX_GTC_VALUE_PHASE_SKEW_EN_AUX_TX_P0_FLDMASK                      0x1
+#define RX_GTC_VALUE_PHASE_SKEW_EN_AUX_TX_P0_FLDMASK_POS                  0
+#define RX_GTC_VALUE_PHASE_SKEW_EN_AUX_TX_P0_FLDMASK_LEN                  1
+
+#define TX_GTC_FREQ_LOCK_DONE_AUX_TX_P0_FLDMASK                           0x2
+#define TX_GTC_FREQ_LOCK_DONE_AUX_TX_P0_FLDMASK_POS                       1
+#define TX_GTC_FREQ_LOCK_DONE_AUX_TX_P0_FLDMASK_LEN                       1
+
+#define TX_GTC_VALUE_PHASE_ADJUST_EN_AUX_TX_P0_FLDMASK                    0x4
+#define TX_GTC_VALUE_PHASE_ADJUST_EN_AUX_TX_P0_FLDMASK_POS                2
+#define TX_GTC_VALUE_PHASE_ADJUST_EN_AUX_TX_P0_FLDMASK_LEN                1
+
+#define REG_36DC_AUX_TX_P0              (0x36DC)
+#define TX_GTC_PHASE_SKEW_OFFSET_AUX_TX_P0_FLDMASK                        0xffff
+#define TX_GTC_PHASE_SKEW_OFFSET_AUX_TX_P0_FLDMASK_POS                    0
+#define TX_GTC_PHASE_SKEW_OFFSET_AUX_TX_P0_FLDMASK_LEN                    16
+
+#define REG_36E0_AUX_TX_P0              (0x36E0)
+#define GTC_STATE_AUX_TX_P0_FLDMASK                                       0xf
+#define GTC_STATE_AUX_TX_P0_FLDMASK_POS                                   0
+#define GTC_STATE_AUX_TX_P0_FLDMASK_LEN                                   4
+
+#define RX_MASTER_LOCK_ACCQUI_CHKTIME_AUX_TX_P0_FLDMASK                   0xf0
+#define RX_MASTER_LOCK_ACCQUI_CHKTIME_AUX_TX_P0_FLDMASK_POS               4
+#define RX_MASTER_LOCK_ACCQUI_CHKTIME_AUX_TX_P0_FLDMASK_LEN               4
+
+#define FREQ_AUX_TX_P0_FLDMASK                                            0xff00
+#define FREQ_AUX_TX_P0_FLDMASK_POS                                        8
+#define FREQ_AUX_TX_P0_FLDMASK_LEN                                        8
+
+#define REG_36E4_AUX_TX_P0              (0x36E4)
+#define GTC_TX_1M_ADD_VAL_AUX_TX_P0_FLDMASK                               0x3ff
+#define GTC_TX_1M_ADD_VAL_AUX_TX_P0_FLDMASK_POS                           0
+#define GTC_TX_1M_ADD_VAL_AUX_TX_P0_FLDMASK_LEN                           10
+
+#define GTC_TX_10M_ADD_VAL_AUX_TX_P0_FLDMASK                              0xf000
+#define GTC_TX_10M_ADD_VAL_AUX_TX_P0_FLDMASK_POS                          12
+#define GTC_TX_10M_ADD_VAL_AUX_TX_P0_FLDMASK_LEN                          4
+
+#define REG_36E8_AUX_TX_P0              (0x36E8)
+#define CHK_TX_PH_ADJUST_CHK_EN_AUX_TX_P0_FLDMASK                         0x1
+#define CHK_TX_PH_ADJUST_CHK_EN_AUX_TX_P0_FLDMASK_POS                     0
+#define CHK_TX_PH_ADJUST_CHK_EN_AUX_TX_P0_FLDMASK_LEN                     1
+
+#define TX_SLAVE_WAIT_SKEW_EN_AUX_TX_P0_FLDMASK                           0x2
+#define TX_SLAVE_WAIT_SKEW_EN_AUX_TX_P0_FLDMASK_POS                       1
+#define TX_SLAVE_WAIT_SKEW_EN_AUX_TX_P0_FLDMASK_LEN                       1
+
+#define GTC_SEND_RCV_EN_AUX_TX_P0_FLDMASK                                 0x4
+#define GTC_SEND_RCV_EN_AUX_TX_P0_FLDMASK_POS                             2
+#define GTC_SEND_RCV_EN_AUX_TX_P0_FLDMASK_LEN                             1
+
+#define AUXTX_HW_ACCS_EN_AUX_TX_P0_FLDMASK                                0x8
+#define AUXTX_HW_ACCS_EN_AUX_TX_P0_FLDMASK_POS                            3
+#define AUXTX_HW_ACCS_EN_AUX_TX_P0_FLDMASK_LEN                            1
+
+#define GTC_TX_MASTER_EN_AUX_TX_P0_FLDMASK                                0x10
+#define GTC_TX_MASTER_EN_AUX_TX_P0_FLDMASK_POS                            4
+#define GTC_TX_MASTER_EN_AUX_TX_P0_FLDMASK_LEN                            1
+
+#define GTC_TX_SLAVE_EN_AUX_TX_P0_FLDMASK                                 0x20
+#define GTC_TX_SLAVE_EN_AUX_TX_P0_FLDMASK_POS                             5
+#define GTC_TX_SLAVE_EN_AUX_TX_P0_FLDMASK_LEN                             1
+
+#define OFFSET_TRY_NUM_AUX_TX_P0_FLDMASK                                  0xf00
+#define OFFSET_TRY_NUM_AUX_TX_P0_FLDMASK_POS                              8
+#define OFFSET_TRY_NUM_AUX_TX_P0_FLDMASK_LEN                              4
+
+#define HW_SW_ARBIT_AUX_TX_P0_FLDMASK                                     0xc000
+#define HW_SW_ARBIT_AUX_TX_P0_FLDMASK_POS                                 14
+#define HW_SW_ARBIT_AUX_TX_P0_FLDMASK_LEN                                 2
+
+#define REG_36EC_AUX_TX_P0              (0x36EC)
+#define GTC_DB_OPTION_AUX_TX_P0_FLDMASK                                   0x7
+#define GTC_DB_OPTION_AUX_TX_P0_FLDMASK_POS                               0
+#define GTC_DB_OPTION_AUX_TX_P0_FLDMASK_LEN                               3
+
+#define TX_SLAVE_CHK_RX_LCK_EN_AUX_TX_P0_FLDMASK                          0x8
+#define TX_SLAVE_CHK_RX_LCK_EN_AUX_TX_P0_FLDMASK_POS                      3
+#define TX_SLAVE_CHK_RX_LCK_EN_AUX_TX_P0_FLDMASK_LEN                      1
+
+#define GTC_PUL_DELAY_AUX_TX_P0_FLDMASK                                   0xff00
+#define GTC_PUL_DELAY_AUX_TX_P0_FLDMASK_POS                               8
+#define GTC_PUL_DELAY_AUX_TX_P0_FLDMASK_LEN                               8
+
+#define REG_36F0_AUX_TX_P0              (0x36F0)
+#define GTC_TX_LCK_ACQ_SEND_NUM_AUX_TX_P0_FLDMASK                         0x1f
+#define GTC_TX_LCK_ACQ_SEND_NUM_AUX_TX_P0_FLDMASK_POS                     0
+#define GTC_TX_LCK_ACQ_SEND_NUM_AUX_TX_P0_FLDMASK_LEN                     5
+
+#define REG_3700_AUX_TX_P0              (0x3700)
+#define AUX_PHYWAKE_MODE_AUX_TX_P0_FLDMASK                                0x1
+#define AUX_PHYWAKE_MODE_AUX_TX_P0_FLDMASK_POS                            0
+#define AUX_PHYWAKE_MODE_AUX_TX_P0_FLDMASK_LEN                            1
+
+#define AUX_PHYWAKE_ONLY_AUX_TX_P0_FLDMASK                                0x2
+#define AUX_PHYWAKE_ONLY_AUX_TX_P0_FLDMASK_POS                            1
+#define AUX_PHYWAKE_ONLY_AUX_TX_P0_FLDMASK_LEN                            1
+
+#define PHYWAKE_PRE_NUM_AUX_TX_P0_FLDMASK                                 0x70
+#define PHYWAKE_PRE_NUM_AUX_TX_P0_FLDMASK_POS                             4
+#define PHYWAKE_PRE_NUM_AUX_TX_P0_FLDMASK_LEN                             3
+
+#define REG_3704_AUX_TX_P0              (0x3704)
+#define AUX_PHYWAKE_ACK_RECV_COMPLETE_IRQ_AUX_TX_P0_FLDMASK               0x1
+#define AUX_PHYWAKE_ACK_RECV_COMPLETE_IRQ_AUX_TX_P0_FLDMASK_POS           0
+#define AUX_PHYWAKE_ACK_RECV_COMPLETE_IRQ_AUX_TX_P0_FLDMASK_LEN           1
+
+#define AUX_TX_FIFO_WRITE_DATA_NEW_MODE_TOGGLE_AUX_TX_P0_FLDMASK          0x2
+#define AUX_TX_FIFO_WRITE_DATA_NEW_MODE_TOGGLE_AUX_TX_P0_FLDMASK_POS      1
+#define AUX_TX_FIFO_WRITE_DATA_NEW_MODE_TOGGLE_AUX_TX_P0_FLDMASK_LEN      1
+
+#define AUX_TX_FIFO_NEW_MODE_EN_AUX_TX_P0_FLDMASK                         0x4
+#define AUX_TX_FIFO_NEW_MODE_EN_AUX_TX_P0_FLDMASK_POS                     2
+#define AUX_TX_FIFO_NEW_MODE_EN_AUX_TX_P0_FLDMASK_LEN                     1
+
+#define REG_3708_AUX_TX_P0              (0x3708)
+#define AUX_TX_FIFO_WRITE_DATA_BYTE0_AUX_TX_P0_FLDMASK                    0xff
+#define AUX_TX_FIFO_WRITE_DATA_BYTE0_AUX_TX_P0_FLDMASK_POS                0
+#define AUX_TX_FIFO_WRITE_DATA_BYTE0_AUX_TX_P0_FLDMASK_LEN                8
+
+#define AUX_TX_FIFO_WRITE_DATA_BYTE1_AUX_TX_P0_FLDMASK                    0xff00
+#define AUX_TX_FIFO_WRITE_DATA_BYTE1_AUX_TX_P0_FLDMASK_POS                8
+#define AUX_TX_FIFO_WRITE_DATA_BYTE1_AUX_TX_P0_FLDMASK_LEN                8
+
+#define REG_370C_AUX_TX_P0              (0x370C)
+#define AUX_TX_FIFO_WRITE_DATA_BYTE2_AUX_TX_P0_FLDMASK                    0xff
+#define AUX_TX_FIFO_WRITE_DATA_BYTE2_AUX_TX_P0_FLDMASK_POS                0
+#define AUX_TX_FIFO_WRITE_DATA_BYTE2_AUX_TX_P0_FLDMASK_LEN                8
+
+#define AUX_TX_FIFO_WRITE_DATA_BYTE3_AUX_TX_P0_FLDMASK                    0xff00
+#define AUX_TX_FIFO_WRITE_DATA_BYTE3_AUX_TX_P0_FLDMASK_POS                8
+#define AUX_TX_FIFO_WRITE_DATA_BYTE3_AUX_TX_P0_FLDMASK_LEN                8
+
+#define REG_3710_AUX_TX_P0              (0x3710)
+#define AUX_TX_FIFO_WRITE_DATA_BYTE4_AUX_TX_P0_FLDMASK                    0xff
+#define AUX_TX_FIFO_WRITE_DATA_BYTE4_AUX_TX_P0_FLDMASK_POS                0
+#define AUX_TX_FIFO_WRITE_DATA_BYTE4_AUX_TX_P0_FLDMASK_LEN                8
+
+#define AUX_TX_FIFO_WRITE_DATA_BYTE5_AUX_TX_P0_FLDMASK                    0xff00
+#define AUX_TX_FIFO_WRITE_DATA_BYTE5_AUX_TX_P0_FLDMASK_POS                8
+#define AUX_TX_FIFO_WRITE_DATA_BYTE5_AUX_TX_P0_FLDMASK_LEN                8
+
+#define REG_3714_AUX_TX_P0              (0x3714)
+#define AUX_TX_FIFO_WRITE_DATA_BYTE6_AUX_TX_P0_FLDMASK                    0xff
+#define AUX_TX_FIFO_WRITE_DATA_BYTE6_AUX_TX_P0_FLDMASK_POS                0
+#define AUX_TX_FIFO_WRITE_DATA_BYTE6_AUX_TX_P0_FLDMASK_LEN                8
+
+#define AUX_TX_FIFO_WRITE_DATA_BYTE7_AUX_TX_P0_FLDMASK                    0xff00
+#define AUX_TX_FIFO_WRITE_DATA_BYTE7_AUX_TX_P0_FLDMASK_POS                8
+#define AUX_TX_FIFO_WRITE_DATA_BYTE7_AUX_TX_P0_FLDMASK_LEN                8
+
+#define REG_3718_AUX_TX_P0              (0x3718)
+#define AUX_TX_FIFO_WRITE_DATA_BYTE8_AUX_TX_P0_FLDMASK                    0xff
+#define AUX_TX_FIFO_WRITE_DATA_BYTE8_AUX_TX_P0_FLDMASK_POS                0
+#define AUX_TX_FIFO_WRITE_DATA_BYTE8_AUX_TX_P0_FLDMASK_LEN                8
+
+#define AUX_TX_FIFO_WRITE_DATA_BYTE9_AUX_TX_P0_FLDMASK                    0xff00
+#define AUX_TX_FIFO_WRITE_DATA_BYTE9_AUX_TX_P0_FLDMASK_POS                8
+#define AUX_TX_FIFO_WRITE_DATA_BYTE9_AUX_TX_P0_FLDMASK_LEN                8
+
+#define REG_371C_AUX_TX_P0              (0x371C)
+#define AUX_TX_FIFO_WRITE_DATA_BYTE10_AUX_TX_P0_FLDMASK                   0xff
+#define AUX_TX_FIFO_WRITE_DATA_BYTE10_AUX_TX_P0_FLDMASK_POS               0
+#define AUX_TX_FIFO_WRITE_DATA_BYTE10_AUX_TX_P0_FLDMASK_LEN               8
+
+#define AUX_TX_FIFO_WRITE_DATA_BYTE11_AUX_TX_P0_FLDMASK                   0xff00
+#define AUX_TX_FIFO_WRITE_DATA_BYTE11_AUX_TX_P0_FLDMASK_POS               8
+#define AUX_TX_FIFO_WRITE_DATA_BYTE11_AUX_TX_P0_FLDMASK_LEN               8
+
+#define REG_3720_AUX_TX_P0              (0x3720)
+#define AUX_TX_FIFO_WRITE_DATA_BYTE12_AUX_TX_P0_FLDMASK                   0xff
+#define AUX_TX_FIFO_WRITE_DATA_BYTE12_AUX_TX_P0_FLDMASK_POS               0
+#define AUX_TX_FIFO_WRITE_DATA_BYTE12_AUX_TX_P0_FLDMASK_LEN               8
+
+#define AUX_TX_FIFO_WRITE_DATA_BYTE13_AUX_TX_P0_FLDMASK                   0xff00
+#define AUX_TX_FIFO_WRITE_DATA_BYTE13_AUX_TX_P0_FLDMASK_POS               8
+#define AUX_TX_FIFO_WRITE_DATA_BYTE13_AUX_TX_P0_FLDMASK_LEN               8
+
+#define REG_3724_AUX_TX_P0              (0x3724)
+#define AUX_TX_FIFO_WRITE_DATA_BYTE14_AUX_TX_P0_FLDMASK                   0xff
+#define AUX_TX_FIFO_WRITE_DATA_BYTE14_AUX_TX_P0_FLDMASK_POS               0
+#define AUX_TX_FIFO_WRITE_DATA_BYTE14_AUX_TX_P0_FLDMASK_LEN               8
+
+#define AUX_TX_FIFO_WRITE_DATA_BYTE15_AUX_TX_P0_FLDMASK                   0xff00
+#define AUX_TX_FIFO_WRITE_DATA_BYTE15_AUX_TX_P0_FLDMASK_POS               8
+#define AUX_TX_FIFO_WRITE_DATA_BYTE15_AUX_TX_P0_FLDMASK_LEN               8
+
+#define REG_3740_AUX_TX_P0              (0x3740)
+#define HPD_OEN_AUX_TX_P0_FLDMASK                                         0x1
+#define HPD_OEN_AUX_TX_P0_FLDMASK_POS                                     0
+#define HPD_OEN_AUX_TX_P0_FLDMASK_LEN                                     1
+
+#define HPD_I_AUX_TX_P0_FLDMASK                                           0x2
+#define HPD_I_AUX_TX_P0_FLDMASK_POS                                       1
+#define HPD_I_AUX_TX_P0_FLDMASK_LEN                                       1
+
+#define REG_3744_AUX_TX_P0              (0x3744)
+#define TEST_AUXRX_AUX_TX_P0_FLDMASK                                      0xffff
+#define TEST_AUXRX_AUX_TX_P0_FLDMASK_POS                                  0
+#define TEST_AUXRX_AUX_TX_P0_FLDMASK_LEN                                  16
+
+#define REG_3748_AUX_TX_P0              (0x3748)
+#define CK_XTAL_AUX_TX_P0_FLDMASK                                         0x1
+#define CK_XTAL_AUX_TX_P0_FLDMASK_POS                                     0
+#define CK_XTAL_AUX_TX_P0_FLDMASK_LEN                                     1
+
+#define EN_FT_MUX_AUX_TX_P0_FLDMASK                                       0x2
+#define EN_FT_MUX_AUX_TX_P0_FLDMASK_POS                                   1
+#define EN_FT_MUX_AUX_TX_P0_FLDMASK_LEN                                   1
+
+#define EN_GPIO_AUX_TX_P0_FLDMASK                                         0x4
+#define EN_GPIO_AUX_TX_P0_FLDMASK_POS                                     2
+#define EN_GPIO_AUX_TX_P0_FLDMASK_LEN                                     1
+
+#define EN_HBR3_AUX_TX_P0_FLDMASK                                         0x8
+#define EN_HBR3_AUX_TX_P0_FLDMASK_POS                                     3
+#define EN_HBR3_AUX_TX_P0_FLDMASK_LEN                                     1
+
+#define PD_NGATE_OV_AUX_TX_P0_FLDMASK                                     0x10
+#define PD_NGATE_OV_AUX_TX_P0_FLDMASK_POS                                 4
+#define PD_NGATE_OV_AUX_TX_P0_FLDMASK_LEN                                 1
+
+#define PD_NGATE_OVEN_AUX_TX_P0_FLDMASK                                   0x20
+#define PD_NGATE_OVEN_AUX_TX_P0_FLDMASK_POS                               5
+#define PD_NGATE_OVEN_AUX_TX_P0_FLDMASK_LEN                               1
+
+#define PD_VCM_OP_AUX_TX_P0_FLDMASK                                       0x40
+#define PD_VCM_OP_AUX_TX_P0_FLDMASK_POS                                   6
+#define PD_VCM_OP_AUX_TX_P0_FLDMASK_LEN                                   1
+
+#define CK_XTAL_SW_AUX_TX_P0_FLDMASK                                      0x80
+#define CK_XTAL_SW_AUX_TX_P0_FLDMASK_POS                                  7
+#define CK_XTAL_SW_AUX_TX_P0_FLDMASK_LEN                                  1
+
+#define SEL_FTMUX_AUX_TX_P0_FLDMASK                                       0x300
+#define SEL_FTMUX_AUX_TX_P0_FLDMASK_POS                                   8
+#define SEL_FTMUX_AUX_TX_P0_FLDMASK_LEN                                   2
+
+#define GTC_EN_AUX_TX_P0_FLDMASK                                          0x400
+#define GTC_EN_AUX_TX_P0_FLDMASK_POS                                      10
+#define GTC_EN_AUX_TX_P0_FLDMASK_LEN                                      1
+
+#define GTC_DATA_IN_MODE_AUX_TX_P0_FLDMASK                                0x800
+#define GTC_DATA_IN_MODE_AUX_TX_P0_FLDMASK_POS                            11
+#define GTC_DATA_IN_MODE_AUX_TX_P0_FLDMASK_LEN                            1
+
+#define REG_374C_AUX_TX_P0              (0x374C)
+#define AUX_VALID_DB_TH_AUX_TX_P0_FLDMASK                                 0xf
+#define AUX_VALID_DB_TH_AUX_TX_P0_FLDMASK_POS                             0
+#define AUX_VALID_DB_TH_AUX_TX_P0_FLDMASK_LEN                             4
+
+#define CLK_AUX_MUX_VALID_EN_AUX_TX_P0_FLDMASK                            0x100
+#define CLK_AUX_MUX_VALID_EN_AUX_TX_P0_FLDMASK_POS                        8
+#define CLK_AUX_MUX_VALID_EN_AUX_TX_P0_FLDMASK_LEN                        1
+
+#define CLK_AUX_MUX_VALID_INV_AUX_TX_P0_FLDMASK                           0x200
+#define CLK_AUX_MUX_VALID_INV_AUX_TX_P0_FLDMASK_POS                       9
+#define CLK_AUX_MUX_VALID_INV_AUX_TX_P0_FLDMASK_LEN                       1
+
+#define CLK_AUX_MUX_VALID_SEL_AUX_TX_P0_FLDMASK                           0xc00
+#define CLK_AUX_MUX_VALID_SEL_AUX_TX_P0_FLDMASK_POS                       10
+#define CLK_AUX_MUX_VALID_SEL_AUX_TX_P0_FLDMASK_LEN                       2
+
+#define CLK_AUX_MUX_DATA_EN_AUX_TX_P0_FLDMASK                             0x1000
+#define CLK_AUX_MUX_DATA_EN_AUX_TX_P0_FLDMASK_POS                         12
+#define CLK_AUX_MUX_DATA_EN_AUX_TX_P0_FLDMASK_LEN                         1
+
+#define CLK_AUX_MUX_DATA_INV_AUX_TX_P0_FLDMASK                            0x2000
+#define CLK_AUX_MUX_DATA_INV_AUX_TX_P0_FLDMASK_POS                        13
+#define CLK_AUX_MUX_DATA_INV_AUX_TX_P0_FLDMASK_LEN                        1
+
+#define CLK_AUX_MUX_DATA_SEL_AUX_TX_P0_FLDMASK                            0xc000
+#define CLK_AUX_MUX_DATA_SEL_AUX_TX_P0_FLDMASK_POS                        14
+#define CLK_AUX_MUX_DATA_SEL_AUX_TX_P0_FLDMASK_LEN                        2
+
+#define REG_3780_AUX_TX_P0              (0x3780)
+#define AUX_RX_FIFO_DATA0_AUX_TX_P0_FLDMASK                               0xff
+#define AUX_RX_FIFO_DATA0_AUX_TX_P0_FLDMASK_POS                           0
+#define AUX_RX_FIFO_DATA0_AUX_TX_P0_FLDMASK_LEN                           8
+
+#define AUX_RX_FIFO_DATA1_AUX_TX_P0_FLDMASK                               0xff00
+#define AUX_RX_FIFO_DATA1_AUX_TX_P0_FLDMASK_POS                           8
+#define AUX_RX_FIFO_DATA1_AUX_TX_P0_FLDMASK_LEN                           8
+
+#define REG_3784_AUX_TX_P0              (0x3784)
+#define AUX_RX_FIFO_DATA2_AUX_TX_P0_FLDMASK                               0xff
+#define AUX_RX_FIFO_DATA2_AUX_TX_P0_FLDMASK_POS                           0
+#define AUX_RX_FIFO_DATA2_AUX_TX_P0_FLDMASK_LEN                           8
+
+#define AUX_RX_FIFO_DATA3_AUX_TX_P0_FLDMASK                               0xff00
+#define AUX_RX_FIFO_DATA3_AUX_TX_P0_FLDMASK_POS                           8
+#define AUX_RX_FIFO_DATA3_AUX_TX_P0_FLDMASK_LEN                           8
+
+#define REG_3788_AUX_TX_P0              (0x3788)
+#define AUX_RX_FIFO_DATA4_AUX_TX_P0_FLDMASK                               0xff
+#define AUX_RX_FIFO_DATA4_AUX_TX_P0_FLDMASK_POS                           0
+#define AUX_RX_FIFO_DATA4_AUX_TX_P0_FLDMASK_LEN                           8
+
+#define AUX_RX_FIFO_DATA5_AUX_TX_P0_FLDMASK                               0xff00
+#define AUX_RX_FIFO_DATA5_AUX_TX_P0_FLDMASK_POS                           8
+#define AUX_RX_FIFO_DATA5_AUX_TX_P0_FLDMASK_LEN                           8
+
+#define REG_378C_AUX_TX_P0              (0x378C)
+#define AUX_RX_FIFO_DATA6_AUX_TX_P0_FLDMASK                               0xff
+#define AUX_RX_FIFO_DATA6_AUX_TX_P0_FLDMASK_POS                           0
+#define AUX_RX_FIFO_DATA6_AUX_TX_P0_FLDMASK_LEN                           8
+
+#define AUX_RX_FIFO_DATA7_AUX_TX_P0_FLDMASK                               0xff00
+#define AUX_RX_FIFO_DATA7_AUX_TX_P0_FLDMASK_POS                           8
+#define AUX_RX_FIFO_DATA7_AUX_TX_P0_FLDMASK_LEN                           8
+
+#define REG_3790_AUX_TX_P0              (0x3790)
+#define AUX_RX_FIFO_DATA8_AUX_TX_P0_FLDMASK                               0xff
+#define AUX_RX_FIFO_DATA8_AUX_TX_P0_FLDMASK_POS                           0
+#define AUX_RX_FIFO_DATA8_AUX_TX_P0_FLDMASK_LEN                           8
+
+#define AUX_RX_FIFO_DATA9_AUX_TX_P0_FLDMASK                               0xff00
+#define AUX_RX_FIFO_DATA9_AUX_TX_P0_FLDMASK_POS                           8
+#define AUX_RX_FIFO_DATA9_AUX_TX_P0_FLDMASK_LEN                           8
+
+#define REG_3794_AUX_TX_P0              (0x3794)
+#define AUX_RX_FIFO_DATA10_AUX_TX_P0_FLDMASK                              0xff
+#define AUX_RX_FIFO_DATA10_AUX_TX_P0_FLDMASK_POS                          0
+#define AUX_RX_FIFO_DATA10_AUX_TX_P0_FLDMASK_LEN                          8
+
+#define AUX_RX_FIFO_DATA11_AUX_TX_P0_FLDMASK                              0xff00
+#define AUX_RX_FIFO_DATA11_AUX_TX_P0_FLDMASK_POS                          8
+#define AUX_RX_FIFO_DATA11_AUX_TX_P0_FLDMASK_LEN                          8
+
+#define REG_3798_AUX_TX_P0              (0x3798)
+#define AUX_RX_FIFO_DATA12_AUX_TX_P0_FLDMASK                              0xff
+#define AUX_RX_FIFO_DATA12_AUX_TX_P0_FLDMASK_POS                          0
+#define AUX_RX_FIFO_DATA12_AUX_TX_P0_FLDMASK_LEN                          8
+
+#define AUX_RX_FIFO_DATA13_AUX_TX_P0_FLDMASK                              0xff00
+#define AUX_RX_FIFO_DATA13_AUX_TX_P0_FLDMASK_POS                          8
+#define AUX_RX_FIFO_DATA13_AUX_TX_P0_FLDMASK_LEN                          8
+
+#define REG_379C_AUX_TX_P0              (0x379C)
+#define AUX_RX_FIFO_DATA14_AUX_TX_P0_FLDMASK                              0xff
+#define AUX_RX_FIFO_DATA14_AUX_TX_P0_FLDMASK_POS                          0
+#define AUX_RX_FIFO_DATA14_AUX_TX_P0_FLDMASK_LEN                          8
+
+#define AUX_RX_FIFO_DATA15_AUX_TX_P0_FLDMASK                              0xff00
+#define AUX_RX_FIFO_DATA15_AUX_TX_P0_FLDMASK_POS                          8
+#define AUX_RX_FIFO_DATA15_AUX_TX_P0_FLDMASK_LEN                          8
+
+#define REG_37C0_AUX_TX_P0              (0x37C0)
+#define AUX_DRV_EN_TIME_THRD_AUX_TX_P0_FLDMASK                            0x1f
+#define AUX_DRV_EN_TIME_THRD_AUX_TX_P0_FLDMASK_POS                        0
+#define AUX_DRV_EN_TIME_THRD_AUX_TX_P0_FLDMASK_LEN                        5
+
+#define AUX_DRV_DIS_TIME_THRD_AUX_TX_P0_FLDMASK                           0x1f00
+#define AUX_DRV_DIS_TIME_THRD_AUX_TX_P0_FLDMASK_POS                       8
+#define AUX_DRV_DIS_TIME_THRD_AUX_TX_P0_FLDMASK_LEN                       5
+
+#define REG_37C4_AUX_TX_P0              (0x37C4)
+#define AUX_WAIT_TRANSFER_TIME_THRD_AUX_TX_P0_FLDMASK                     0xff
+#define AUX_WAIT_TRANSFER_TIME_THRD_AUX_TX_P0_FLDMASK_POS                 0
+#define AUX_WAIT_TRANSFER_TIME_THRD_AUX_TX_P0_FLDMASK_LEN                 8
+
+#define AUX_WAIT_RECEIVE_TIME_THRD_AUX_TX_P0_FLDMASK                      0xff00
+#define AUX_WAIT_RECEIVE_TIME_THRD_AUX_TX_P0_FLDMASK_POS                  8
+#define AUX_WAIT_RECEIVE_TIME_THRD_AUX_TX_P0_FLDMASK_LEN                  8
+
+#define REG_37C8_AUX_TX_P0              (0x37C8)
+#define MTK_ATOP_EN_AUX_TX_P0_FLDMASK                                     0x1
+#define MTK_ATOP_EN_AUX_TX_P0_FLDMASK_POS                                 0
+#define MTK_ATOP_EN_AUX_TX_P0_FLDMASK_LEN                                 1
+
+/*-----------------------------------------------------*/
+#define DP_TX_TOP_PWR_STATE              (TOP_OFFSET + 0x00)
+#define DP_PWR_STATE_FLDMASK                                              0x3
+#define DP_PWR_STATE_FLDMASK_POS                                          0
+#define DP_PWR_STATE_FLDMASK_LEN                                          2
+
+#define DP_SCRAMB_EN_FLDMASK                                              0x4
+#define DP_SCRAMB_EN_FLDMASK_POS                                          2
+#define DP_SCRAMB_EN_FLDMASK_LEN                                          1
+
+#define DP_DISP_RST_FLDMASK                                               0x8
+#define DP_DISP_RST_FLDMASK_POS                                           3
+#define DP_DISP_RST_FLDMASK_LEN                                           1
+
+#define DP_TX_TOP_SWING_EMP              (TOP_OFFSET + 0x04)
+#define DP_TX0_VOLT_SWING_FLDMASK                                         0x3
+#define DP_TX0_VOLT_SWING_FLDMASK_POS                                     0
+#define DP_TX0_VOLT_SWING_FLDMASK_LEN                                     2
+
+#define DP_TX0_PRE_EMPH_FLDMASK                                           0xc
+#define DP_TX0_PRE_EMPH_FLDMASK_POS                                       2
+#define DP_TX0_PRE_EMPH_FLDMASK_LEN                                       2
+
+#define DP_TX0_DATAK_FLDMASK                                              0xf0
+#define DP_TX0_DATAK_FLDMASK_POS                                          4
+#define DP_TX0_DATAK_FLDMASK_LEN                                          4
+
+#define DP_TX1_VOLT_SWING_FLDMASK                                         0x300
+#define DP_TX1_VOLT_SWING_FLDMASK_POS                                     8
+#define DP_TX1_VOLT_SWING_FLDMASK_LEN                                     2
+
+#define DP_TX1_PRE_EMPH_FLDMASK                                           0xc00
+#define DP_TX1_PRE_EMPH_FLDMASK_POS                                       10
+#define DP_TX1_PRE_EMPH_FLDMASK_LEN                                       2
+
+#define DP_TX1_DATAK_FLDMASK                                              0xf000
+#define DP_TX1_DATAK_FLDMASK_POS                                          12
+#define DP_TX1_DATAK_FLDMASK_LEN                                          4
+
+#define DP_TX2_VOLT_SWING_FLDMASK                              0x30000
+#define DP_TX2_VOLT_SWING_FLDMASK_POS                          16
+#define DP_TX2_VOLT_SWING_FLDMASK_LEN                          2
+
+#define DP_TX2_PRE_EMPH_FLDMASK                                0xc0000
+#define DP_TX2_PRE_EMPH_FLDMASK_POS                            18
+#define DP_TX2_PRE_EMPH_FLDMASK_LEN                            2
+
+#define DP_TX2_DATAK_FLDMASK                                   0xf00000
+#define DP_TX2_DATAK_FLDMASK_POS                               20
+#define DP_TX2_DATAK_FLDMASK_LEN                               4
+
+#define DP_TX3_VOLT_SWING_FLDMASK                              0x3000000
+#define DP_TX3_VOLT_SWING_FLDMASK_POS                          24
+#define DP_TX3_VOLT_SWING_FLDMASK_LEN                          2
+
+#define DP_TX3_PRE_EMPH_FLDMASK                                0xc000000
+#define DP_TX3_PRE_EMPH_FLDMASK_POS                            26
+#define DP_TX3_PRE_EMPH_FLDMASK_LEN                            2
+
+#define DP_TX3_DATAK_FLDMASK                                   0xf0000000L
+#define DP_TX3_DATAK_FLDMASK_POS                               28
+#define DP_TX3_DATAK_FLDMASK_LEN                               4
+
+#define DP_TX_TOP_APB_WSTRB              (TOP_OFFSET + 0x10)
+#define APB_WSTRB_FLDMASK                                      0xf
+#define APB_WSTRB_FLDMASK_POS                                  0
+#define APB_WSTRB_FLDMASK_LEN                                  4
+
+#define APB_WSTRB_EN_FLDMASK                                   0x10
+#define APB_WSTRB_EN_FLDMASK_POS                               4
+#define APB_WSTRB_EN_FLDMASK_LEN                               1
+
+#define DP_TX_TOP_RESERVED              (TOP_OFFSET + 0x14)
+#define RESERVED_FLDMASK                                       0xffffffffL
+#define RESERVED_FLDMASK_POS                                   0
+#define RESERVED_FLDMASK_LEN                                   32
+
+#define DP_TX_TOP_RESET_AND_PROBE              (TOP_OFFSET + 0x20)
+#define SW_RST_B_FLDMASK                                       0x1f
+#define SW_RST_B_FLDMASK_POS                                   0
+#define SW_RST_B_FLDMASK_LEN                                   5
+
+#define PROBE_LOW_SEL_FLDMASK                                  0x38000
+#define PROBE_LOW_SEL_FLDMASK_POS                              15
+#define PROBE_LOW_SEL_FLDMASK_LEN                              3
+
+#define PROBE_HIGH_SEL_FLDMASK                                 0x1c0000
+#define PROBE_HIGH_SEL_FLDMASK_POS                             18
+#define PROBE_HIGH_SEL_FLDMASK_LEN                             3
+
+#define PROBE_LOW_HIGH_SWAP_FLDMASK                            0x200000
+#define PROBE_LOW_HIGH_SWAP_FLDMASK_POS                        21
+#define PROBE_LOW_HIGH_SWAP_FLDMASK_LEN                        1
+
+#define DP_TX_TOP_SOFT_PROBE              (TOP_OFFSET + 0x24)
+#define SW_PROBE_VALUE_FLDMASK                                 0xffffffffL
+#define SW_PROBE_VALUE_FLDMASK_POS                             0
+#define SW_PROBE_VALUE_FLDMASK_LEN                             32
+
+#define DP_TX_TOP_IRQ_STATUS              (TOP_OFFSET + 0x28)
+#define RGS_IRQ_STATUS_FLDMASK                                            0x7
+#define RGS_IRQ_STATUS_FLDMASK_POS                                        0
+#define RGS_IRQ_STATUS_FLDMASK_LEN                                        3
+
+#define DP_TX_TOP_IRQ_MASK              (TOP_OFFSET + 0x2C)
+#define IRQ_MASK_FLDMASK                                                  0x7
+#define IRQ_MASK_FLDMASK_POS                                              0
+#define IRQ_MASK_FLDMASK_LEN                                              3
+
+#define IRQ_OUT_HIGH_ACTIVE_FLDMASK                                       0x100
+#define IRQ_OUT_HIGH_ACTIVE_FLDMASK_POS                                   8
+#define IRQ_OUT_HIGH_ACTIVE_FLDMASK_LEN                                   1
+
+#define DP_TX_TOP_BLACK_SCREEN              (TOP_OFFSET + 0x30)
+#define BLACK_SCREEN_ENABLE_FLDMASK                                       0x1
+#define BLACK_SCREEN_ENABLE_FLDMASK_POS                                   0
+#define BLACK_SCREEN_ENABLE_FLDMASK_LEN                                   1
+
+#define DP_TX_TOP_MEM_PD              (TOP_OFFSET + 0x38)
+#define MEM_ISO_EN_FLDMASK                                                0x1
+#define MEM_ISO_EN_FLDMASK_POS                                            0
+#define MEM_ISO_EN_FLDMASK_LEN                                            1
+
+#define MEM_PD_FLDMASK                                                    0x2
+#define MEM_PD_FLDMASK_POS                                                1
+#define MEM_PD_FLDMASK_LEN                                                1
+
+#define FUSE_SEL_FLDMASK                                                  0x4
+#define FUSE_SEL_FLDMASK_POS                                              2
+#define FUSE_SEL_FLDMASK_LEN                                              1
+
+#define LOAD_PREFUSE_FLDMASK                                              0x8
+#define LOAD_PREFUSE_FLDMASK_POS                                          3
+#define LOAD_PREFUSE_FLDMASK_LEN                                          1
+
+#define DP_TX_TOP_MBIST_PREFUSE              (TOP_OFFSET + 0x3C)
+#define RGS_PREFUSE_FLDMASK                                     0xffff
+#define RGS_PREFUSE_FLDMASK_POS                                 0
+#define RGS_PREFUSE_FLDMASK_LEN                                 16
+
+#define DP_TX_TOP_MEM_DELSEL_0              (TOP_OFFSET + 0x40)
+#define DELSEL_0_FLDMASK                                        0xfffff
+#define DELSEL_0_FLDMASK_POS                                    0
+#define DELSEL_0_FLDMASK_LEN                                    20
+
+#define USE_DEFAULT_DELSEL_0_FLDMASK                            0x100000
+#define USE_DEFAULT_DELSEL_0_FLDMASK_POS                        20
+#define USE_DEFAULT_DELSEL_0_FLDMASK_LEN                        1
+
+#define DP_TX_TOP_MEM_DELSEL_1              (TOP_OFFSET + 0x44)
+#define DELSEL_1_FLDMASK                                        0xfffff
+#define DELSEL_1_FLDMASK_POS                                    0
+#define DELSEL_1_FLDMASK_LEN                                    20
+
+#define USE_DEFAULT_DELSEL_1_FLDMASK                            0x100000
+#define USE_DEFAULT_DELSEL_1_FLDMASK_POS                        20
+#define USE_DEFAULT_DELSEL_1_FLDMASK_LEN                        1
+
+#define DP_TX_TOP_MEM_DELSEL_2              (TOP_OFFSET + 0x48)
+#define DELSEL_2_FLDMASK                                        0xfffff
+#define DELSEL_2_FLDMASK_POS                                    0
+#define DELSEL_2_FLDMASK_LEN                                    20
+
+#define USE_DEFAULT_DELSEL_2_FLDMASK                            0x100000
+#define USE_DEFAULT_DELSEL_2_FLDMASK_POS                        20
+#define USE_DEFAULT_DELSEL_2_FLDMASK_LEN                        1
+
+#define DP_TX_TOP_MEM_DELSEL_3              (TOP_OFFSET + 0x4C)
+#define DELSEL_3_FLDMASK                                        0xfffff
+#define DELSEL_3_FLDMASK_POS                                    0
+#define DELSEL_3_FLDMASK_LEN                                    20
+
+#define USE_DEFAULT_DELSEL_3_FLDMASK                            0x100000
+#define USE_DEFAULT_DELSEL_3_FLDMASK_POS                        20
+#define USE_DEFAULT_DELSEL_3_FLDMASK_LEN                        1
+
+#define DP_TX_TOP_MEM_DELSEL_4              (TOP_OFFSET + 0x50)
+#define DELSEL_4_FLDMASK                                        0xfffff
+#define DELSEL_4_FLDMASK_POS                                    0
+#define DELSEL_4_FLDMASK_LEN                                    20
+
+#define USE_DEFAULT_DELSEL_4_FLDMASK                            0x100000
+#define USE_DEFAULT_DELSEL_4_FLDMASK_POS                        20
+#define USE_DEFAULT_DELSEL_4_FLDMASK_LEN                        1
+
+#define DP_TX_TOP_MEM_DELSEL_5              (TOP_OFFSET + 0x54)
+#define DELSEL_5_FLDMASK                                        0xfffff
+#define DELSEL_5_FLDMASK_POS                                    0
+#define DELSEL_5_FLDMASK_LEN                                    20
+
+#define USE_DEFAULT_DELSEL_5_FLDMASK                            0x100000
+#define USE_DEFAULT_DELSEL_5_FLDMASK_POS                        20
+#define USE_DEFAULT_DELSEL_5_FLDMASK_LEN                        1
+
+#define DP_TX_TOP_MEM_DELSEL_6              (TOP_OFFSET + 0x58)
+#define DELSEL_6_FLDMASK                                        0xfffff
+#define DELSEL_6_FLDMASK_POS                                    0
+#define DELSEL_6_FLDMASK_LEN                                    20
+
+#define USE_DEFAULT_DELSEL_6_FLDMASK                            0x100000
+#define USE_DEFAULT_DELSEL_6_FLDMASK_POS                        20
+#define USE_DEFAULT_DELSEL_6_FLDMASK_LEN                        1
+
+#define DP_TX_TOP_MEM_DELSEL_7              (TOP_OFFSET + 0x5C)
+#define DELSEL_7_FLDMASK                                        0xfffff
+#define DELSEL_7_FLDMASK_POS                                    0
+#define DELSEL_7_FLDMASK_LEN                                    20
+
+#define USE_DEFAULT_DELSEL_7_FLDMASK                            0x100000
+#define USE_DEFAULT_DELSEL_7_FLDMASK_POS                        20
+#define USE_DEFAULT_DELSEL_7_FLDMASK_LEN                        1
+
+#define DP_TX_TOP_MEM_DELSEL_8              (TOP_OFFSET + 0x60)
+#define DELSEL_8_FLDMASK                                        0xfffff
+#define DELSEL_8_FLDMASK_POS                                    0
+#define DELSEL_8_FLDMASK_LEN                                    20
+
+#define USE_DEFAULT_DELSEL_8_FLDMASK                            0x100000
+#define USE_DEFAULT_DELSEL_8_FLDMASK_POS                        20
+#define USE_DEFAULT_DELSEL_8_FLDMASK_LEN                        1
+
+#define DP_TX_TOP_MEM_DELSEL_9              (TOP_OFFSET + 0x64)
+#define DELSEL_9_FLDMASK                                        0xfffff
+#define DELSEL_9_FLDMASK_POS                                    0
+#define DELSEL_9_FLDMASK_LEN                                    20
+
+#define USE_DEFAULT_DELSEL_9_FLDMASK                            0x100000
+#define USE_DEFAULT_DELSEL_9_FLDMASK_POS                        20
+#define USE_DEFAULT_DELSEL_9_FLDMASK_LEN                        1
+
+#define DP_TX_TOP_MEM_DELSEL_10              (TOP_OFFSET + 0x68)
+#define DELSEL_10_FLDMASK                                       0xfffff
+#define DELSEL_10_FLDMASK_POS                                   0
+#define DELSEL_10_FLDMASK_LEN                                   20
+
+#define USE_DEFAULT_DELSEL_10_FLDMASK                           0x100000
+#define USE_DEFAULT_DELSEL_10_FLDMASK_POS                       20
+#define USE_DEFAULT_DELSEL_10_FLDMASK_LEN                       1
+
+#define DP_TX_TOP_MEM_DELSEL_11              (TOP_OFFSET + 0x6C)
+#define DELSEL_11_FLDMASK                                       0xfffff
+#define DELSEL_11_FLDMASK_POS                                   0
+#define DELSEL_11_FLDMASK_LEN                                   20
+
+#define USE_DEFAULT_DELSEL_11_FLDMASK                           0x100000
+#define USE_DEFAULT_DELSEL_11_FLDMASK_POS                       20
+#define USE_DEFAULT_DELSEL_11_FLDMASK_LEN                       1
+
+#define DP_TX_TOP_MEM_DELSEL_12              (TOP_OFFSET + 0x70)
+#define DELSEL_12_FLDMASK                                       0xfffff
+#define DELSEL_12_FLDMASK_POS                                   0
+#define DELSEL_12_FLDMASK_LEN                                   20
+
+#define USE_DEFAULT_DELSEL_12_FLDMASK                           0x100000
+#define USE_DEFAULT_DELSEL_12_FLDMASK_POS                       20
+#define USE_DEFAULT_DELSEL_12_FLDMASK_LEN                       1
+
+#define DP_TX_TOP_PWR_ACK              (TOP_OFFSET + 0x80)
+#define RGS_DP_TX_PWR_ACK_FLDMASK                               0x1
+#define RGS_DP_TX_PWR_ACK_FLDMASK_POS                           0
+#define RGS_DP_TX_PWR_ACK_FLDMASK_LEN                           1
+
+#define RGS_DP_TX_PWR_ACK_2ND_FLDMASK                           0x2
+#define RGS_DP_TX_PWR_ACK_2ND_FLDMASK_POS                       1
+#define RGS_DP_TX_PWR_ACK_2ND_FLDMASK_LEN                       1
+
+/*-----------------------------------------------------*/
+#define DP_TX_SECURE_REG0              (SEC_OFFSET + 0x00)
+#define HDCP22_KS_XOR_LC128_KEY_0_FLDMASK                       0xffffffffL
+#define HDCP22_KS_XOR_LC128_KEY_0_FLDMASK_POS                   0
+#define HDCP22_KS_XOR_LC128_KEY_0_FLDMASK_LEN                   32
+
+#define DP_TX_SECURE_REG1              (SEC_OFFSET + 0x04)
+#define HDCP22_KS_XOR_LC128_KEY_1_FLDMASK                       0xffffffffL
+#define HDCP22_KS_XOR_LC128_KEY_1_FLDMASK_POS                   0
+#define HDCP22_KS_XOR_LC128_KEY_1_FLDMASK_LEN                   32
+
+#define DP_TX_SECURE_REG2              (SEC_OFFSET + 0x08)
+#define HDCP22_KS_XOR_LC128_KEY_2_FLDMASK                       0xffffffffL
+#define HDCP22_KS_XOR_LC128_KEY_2_FLDMASK_POS                   0
+#define HDCP22_KS_XOR_LC128_KEY_2_FLDMASK_LEN                   32
+
+#define DP_TX_SECURE_REG3              (SEC_OFFSET + 0x0c)
+#define HDCP22_KS_XOR_LC128_KEY_3_FLDMASK                       0xffffffffL
+#define HDCP22_KS_XOR_LC128_KEY_3_FLDMASK_POS                   0
+#define HDCP22_KS_XOR_LC128_KEY_3_FLDMASK_LEN                   32
+
+#define DP_TX_SECURE_REG4              (SEC_OFFSET + 0x10)
+#define HDCP22_RIV_0_FLDMASK                                    0xffffffffL
+#define HDCP22_RIV_0_FLDMASK_POS                                0
+#define HDCP22_RIV_0_FLDMASK_LEN                                32
+
+#define DP_TX_SECURE_REG5              (SEC_OFFSET + 0x14)
+#define HDCP22_RIV_1_FLDMASK                                    0xffffffffL
+#define HDCP22_RIV_1_FLDMASK_POS                                0
+#define HDCP22_RIV_1_FLDMASK_LEN                                32
+
+#define DP_TX_SECURE_REG6              (SEC_OFFSET + 0x18)
+#define HDCP13_LN_SEED_FLDMASK                                  0xff
+#define HDCP13_LN_SEED_FLDMASK_POS                              0
+#define HDCP13_LN_SEED_FLDMASK_LEN                              8
+
+#define DP_TX_SECURE_REG7              (SEC_OFFSET + 0x1C)
+#define HDCP13_LN_CODE_0_FLDMASK                                0xffffffffL
+#define HDCP13_LN_CODE_0_FLDMASK_POS                            0
+#define HDCP13_LN_CODE_0_FLDMASK_LEN                            32
+
+#define DP_TX_SECURE_REG8              (SEC_OFFSET + 0x20)
+#define HDCP13_LN_CODE_1_FLDMASK                                0xffffff
+#define HDCP13_LN_CODE_1_FLDMASK_POS                            0
+#define HDCP13_LN_CODE_1_FLDMASK_LEN                            24
+
+#define DP_TX_SECURE_REG9              (SEC_OFFSET + 0x24)
+#define HDCP13_AN_CODE_0_FLDMASK                                0xffffffffL
+#define HDCP13_AN_CODE_0_FLDMASK_POS                            0
+#define HDCP13_AN_CODE_0_FLDMASK_LEN                            32
+
+#define DP_TX_SECURE_REG10              (SEC_OFFSET + 0x28)
+#define HDCP13_AN_CODE_1_FLDMASK                                0xffffffffL
+#define HDCP13_AN_CODE_1_FLDMASK_POS                            0
+#define HDCP13_AN_CODE_1_FLDMASK_LEN                            32
+
+#define DP_TX_SECURE_REG11              (SEC_OFFSET + 0x2C)
+#define DP_TX_TRANSMITTER_4P_RESET_SW_SECURE_FLDMASK            0x1
+#define DP_TX_TRANSMITTER_4P_RESET_SW_SECURE_FLDMASK_POS        0
+#define DP_TX_TRANSMITTER_4P_RESET_SW_SECURE_FLDMASK_LEN        1
+
+#define HDCP22_RST_SW_SECURE_FLDMASK                            0x2
+#define HDCP22_RST_SW_SECURE_FLDMASK_POS                        1
+#define HDCP22_RST_SW_SECURE_FLDMASK_LEN                        1
+
+#define HDCP13_RST_SW_SECURE_FLDMASK                            0x4
+#define HDCP13_RST_SW_SECURE_FLDMASK_POS                        2
+#define HDCP13_RST_SW_SECURE_FLDMASK_LEN                        1
+
+#define VIDEO_MUTE_SW_SECURE_FLDMASK                            0x8
+#define VIDEO_MUTE_SW_SECURE_FLDMASK_POS                        3
+#define VIDEO_MUTE_SW_SECURE_FLDMASK_LEN                        1
+
+#define VIDEO_MUTE_SEL_SECURE_FLDMASK                           0x10
+#define VIDEO_MUTE_SEL_SECURE_FLDMASK_POS                       4
+#define VIDEO_MUTE_SEL_SECURE_FLDMASK_LEN                       1
+
+#define HDCP_FRAME_EN_SECURE_FLDMASK                            0x20
+#define HDCP_FRAME_EN_SECURE_FLDMASK_POS                        5
+#define HDCP_FRAME_EN_SECURE_FLDMASK_LEN                        1
+
+#define HDCP_FRAME_EN_SEL_SECURE_FLDMASK                        0x40
+#define HDCP_FRAME_EN_SEL_SECURE_FLDMASK_POS                    6
+#define HDCP_FRAME_EN_SEL_SECURE_FLDMASK_LEN                    1
+
+#define VSC_SEL_SECURE_FLDMASK                                  0x80
+#define VSC_SEL_SECURE_FLDMASK_POS                              7
+#define VSC_SEL_SECURE_FLDMASK_LEN                              1
+
+#define VSC_DATA_TOGGLE_VESA_SECURE_FLDMASK                     0x100
+#define VSC_DATA_TOGGLE_VESA_SECURE_FLDMASK_POS                 8
+#define VSC_DATA_TOGGLE_VESA_SECURE_FLDMASK_LEN                 1
+
+#define VSC_DATA_RDY_VESA_SECURE_FLDMASK                        0x200
+#define VSC_DATA_RDY_VESA_SECURE_FLDMASK_POS                    9
+#define VSC_DATA_RDY_VESA_SECURE_FLDMASK_LEN                    1
+
+#define VSC_DATA_TOGGLE_CEA_SECURE_FLDMASK                      0x400
+#define VSC_DATA_TOGGLE_CEA_SECURE_FLDMASK_POS                  10
+#define VSC_DATA_TOGGLE_CEA_SECURE_FLDMASK_LEN                  1
+
+#define VSC_DATA_RDY_CEA_SECURE_FLDMASK                         0x800
+#define VSC_DATA_RDY_CEA_SECURE_FLDMASK_POS                     11
+#define VSC_DATA_RDY_CEA_SECURE_FLDMASK_LEN                     1
+
+#define DP_TX_SECURE_REG12              (SEC_OFFSET + 0x30)
+#define VSC_DATA_BYTE7_CEA_SECURE_FLDMASK                       0xff000000L
+#define VSC_DATA_BYTE7_CEA_SECURE_FLDMASK_POS                   24
+#define VSC_DATA_BYTE7_CEA_SECURE_FLDMASK_LEN                   8
+
+#define VSC_DATA_BYTE6_CEA_SECURE_FLDMASK                       0xff0000
+#define VSC_DATA_BYTE6_CEA_SECURE_FLDMASK_POS                   16
+#define VSC_DATA_BYTE6_CEA_SECURE_FLDMASK_LEN                   8
+
+#define VSC_DATA_BYTE5_CEA_SECURE_FLDMASK                       0xff00
+#define VSC_DATA_BYTE5_CEA_SECURE_FLDMASK_POS                   8
+#define VSC_DATA_BYTE5_CEA_SECURE_FLDMASK_LEN                   8
+
+#define VSC_DATA_BYTE4_CEA_SECURE_FLDMASK                       0xff
+#define VSC_DATA_BYTE4_CEA_SECURE_FLDMASK_POS                   0
+#define VSC_DATA_BYTE4_CEA_SECURE_FLDMASK_LEN                   8
+
+#define DP_TX_SECURE_REG13              (SEC_OFFSET + 0x34)
+#define VSC_DATA_BYTE3_CEA_SECURE_FLDMASK                       0xff000000L
+#define VSC_DATA_BYTE3_CEA_SECURE_FLDMASK_POS                   24
+#define VSC_DATA_BYTE3_CEA_SECURE_FLDMASK_LEN                   8
+
+#define VSC_DATA_BYTE2_CEA_SECURE_FLDMASK                       0xff0000
+#define VSC_DATA_BYTE2_CEA_SECURE_FLDMASK_POS                   16
+#define VSC_DATA_BYTE2_CEA_SECURE_FLDMASK_LEN                   8
+
+#define VSC_DATA_BYTE1_CEA_SECURE_FLDMASK                       0xff00
+#define VSC_DATA_BYTE1_CEA_SECURE_FLDMASK_POS                   8
+#define VSC_DATA_BYTE1_CEA_SECURE_FLDMASK_LEN                   8
+
+#define VSC_DATA_BYTE0_CEA_SECURE_FLDMASK                       0xff
+#define VSC_DATA_BYTE0_CEA_SECURE_FLDMASK_POS                   0
+#define VSC_DATA_BYTE0_CEA_SECURE_FLDMASK_LEN                   8
+
+#define DP_TX_SECURE_REG14              (SEC_OFFSET + 0x38)
+#define VSC_DATA_BYTE7_VESA_SECURE_FLDMASK                      0xff000000L
+#define VSC_DATA_BYTE7_VESA_SECURE_FLDMASK_POS                  24
+#define VSC_DATA_BYTE7_VESA_SECURE_FLDMASK_LEN                  8
+
+#define VSC_DATA_BYTE6_VESA_SECURE_FLDMASK                      0xff0000
+#define VSC_DATA_BYTE6_VESA_SECURE_FLDMASK_POS                  16
+#define VSC_DATA_BYTE6_VESA_SECURE_FLDMASK_LEN                  8
+
+#define VSC_DATA_BYTE5_VESA_SECURE_FLDMASK                      0xff00
+#define VSC_DATA_BYTE5_VESA_SECURE_FLDMASK_POS                  8
+#define VSC_DATA_BYTE5_VESA_SECURE_FLDMASK_LEN                  8
+
+#define VSC_DATA_BYTE4_VESA_SECURE_FLDMASK                      0xff
+#define VSC_DATA_BYTE4_VESA_SECURE_FLDMASK_POS                  0
+#define VSC_DATA_BYTE4_VESA_SECURE_FLDMASK_LEN                  8
+
+#define DP_TX_SECURE_REG15              (SEC_OFFSET + 0x3C)
+#define VSC_DATA_BYTE3_VESA_SECURE_FLDMASK                      0xff000000L
+#define VSC_DATA_BYTE3_VESA_SECURE_FLDMASK_POS                  24
+#define VSC_DATA_BYTE3_VESA_SECURE_FLDMASK_LEN                  8
+
+#define VSC_DATA_BYTE2_VESA_SECURE_FLDMASK                      0xff0000
+#define VSC_DATA_BYTE2_VESA_SECURE_FLDMASK_POS                  16
+#define VSC_DATA_BYTE2_VESA_SECURE_FLDMASK_LEN                  8
+
+#define VSC_DATA_BYTE1_VESA_SECURE_FLDMASK                      0xff00
+#define VSC_DATA_BYTE1_VESA_SECURE_FLDMASK_POS                  8
+#define VSC_DATA_BYTE1_VESA_SECURE_FLDMASK_LEN                  8
+
+#define VSC_DATA_BYTE0_VESA_SECURE_FLDMASK                      0xff
+#define VSC_DATA_BYTE0_VESA_SECURE_FLDMASK_POS                  0
+#define VSC_DATA_BYTE0_VESA_SECURE_FLDMASK_LEN                  8
+
+#define DP_TX_SECURE_STATUS_0              (SEC_OFFSET + 0x80)
+#define RGS_DP_TX_HDCP13_HDCP_AN_0_FLDMASK                      0xffffffffL
+#define RGS_DP_TX_HDCP13_HDCP_AN_0_FLDMASK_POS                  0
+#define RGS_DP_TX_HDCP13_HDCP_AN_0_FLDMASK_LEN                  32
+
+#define DP_TX_SECURE_STATUS_1              (SEC_OFFSET + 0x84)
+#define RGS_DP_TX_HDCP13_HDCP_AN_1_FLDMASK                      0xffffffffL
+#define RGS_DP_TX_HDCP13_HDCP_AN_1_FLDMASK_POS                  0
+#define RGS_DP_TX_HDCP13_HDCP_AN_1_FLDMASK_LEN                  32
+
+#define DP_TX_SECURE_STATUS_2              (SEC_OFFSET + 0x88)
+#define RGS_DP_TX_HDCP13_HDCP_R0_FLDMASK                        0xffff
+#define RGS_DP_TX_HDCP13_HDCP_R0_FLDMASK_POS                    0
+#define RGS_DP_TX_HDCP13_HDCP_R0_FLDMASK_LEN                    16
+
+#define DP_TX_SECURE_STATUS_3              (SEC_OFFSET + 0x8C)
+#define RGS_DP_TX_HDCP13_HDCP_M0_0_FLDMASK                      0xffffffffL
+#define RGS_DP_TX_HDCP13_HDCP_M0_0_FLDMASK_POS                  0
+#define RGS_DP_TX_HDCP13_HDCP_M0_0_FLDMASK_LEN                  32
+
+#define DP_TX_SECURE_STATUS_4              (SEC_OFFSET + 0x90)
+#define RGS_DP_TX_HDCP13_HDCP_M0_1_FLDMASK                      0xffffffffL
+#define RGS_DP_TX_HDCP13_HDCP_M0_1_FLDMASK_POS                  0
+#define RGS_DP_TX_HDCP13_HDCP_M0_1_FLDMASK_LEN                  32
+
+#define DP_TX_SECURE_ACC_FAIL              (SEC_OFFSET + 0xf0)
+#define NO_AUTH_READ_VALUE_FLDMASK                              0xffffffffL
+#define NO_AUTH_READ_VALUE_FLDMASK_POS                          0
+#define NO_AUTH_READ_VALUE_FLDMASK_LEN                          32
+
+
+//DPCD address
+#define DPCD_00000		0x00000
+#define DPCD_00001		0x00001
+#define DPCD_00002		0x00002
+#define DPCD_00003		0x00003
+#define DPCD_00004		0x00004
+#define DPCD_00005		0x00005
+#define DPCD_0000A		0x0000A
+#define DPCD_0000E		0x0000E
+#define DPCD_00021		0x00021
+#define DPCD_00030		0x00030
+#define DPCD_00060		0x00060
+#define DPCD_00080		0x00080
+#define DPCD_00090		0x00090
+#define DPCD_00100		0x00100
+#define DPCD_00101		0x00101
+#define DPCD_00102		0x00102
+#define DPCD_00103		0x00103
+#define DPCD_00104		0x00104
+#define DPCD_00105		0x00105
+#define DPCD_00106		0x00106
+#define DPCD_00107		0x00107
+#define DPCD_00111		0x00111
+#define DPCD_00120		0x00120
+#define DPCD_00160		0x00160
+#define DPCD_001A1		0x001A1
+#define DPCD_001C0		0x001C0
+#define DPCD_00200		0x00200
+#define DPCD_00201		0x00201
+#define DPCD_00202		0x00202
+#define DPCD_00203		0x00203
+#define DPCD_00204		0x00204
+#define DPCD_00205		0x00205
+#define DPCD_00206		0x00206
+#define DPCD_00210		0x00210
+#define DPCD_00218		0x00218
+#define DPCD_00219		0x00219
+#define DPCD_00220		0x00220
+#define DPCD_00230		0x00230
+#define DPCD_00250		0x00250
+#define DPCD_00260		0x00260
+#define DPCD_00261		0x00261
+#define DPCD_00271		0x00271
+#define DPCD_00280		0x00280
+#define DPCD_00281		0x00281
+#define DPCD_00282		0x00282
+#define DPCD_002C0		0x002C0
+#define DPCD_00600		0x00600
+#define DPCD_01000		0x01000
+#define DPCD_01200		0x01200
+#define DPCD_01400		0x01400
+#define DPCD_01600		0x01600
+#define DPCD_02002		0x02002
+#define DPCD_02003		0x02003
+#define DPCD_0200C		0x0200C
+#define DPCD_0200D		0x0200D
+#define DPCD_0200E		0x0200E
+#define DPCD_0200F		0x0200F
+#define DPCD_02200		0x02200
+#define DPCD_02201		0x02201
+#define DPCD_02202		0x02202
+#define DPCD_02203		0x02203
+#define DPCD_02204		0x02204
+#define DPCD_02205		0x02205
+#define DPCD_02206		0x02206
+#define DPCD_02207		0x02207
+#define DPCD_02208		0x02208
+#define DPCD_02209		0x02209
+#define DPCD_0220A		0x0220A
+#define DPCD_0220B		0x0220B
+#define DPCD_0220C		0x0220C
+#define DPCD_0220D		0x0220D
+#define DPCD_0220E		0x0220E
+#define DPCD_0220F		0x0220F
+#define DPCD_02210		0x02210
+#define DPCD_02211		0x02211
+#define DPCD_68000		0x68000
+#define DPCD_68005		0x68005
+#define DPCD_68007		0x68007
+#define DPCD_6800C		0x6800C
+#define DPCD_68014		0x68014
+#define DPCD_68018		0x68018
+#define DPCD_6801C		0x6801C
+#define DPCD_68020		0x68020
+#define DPCD_68024		0x68024
+#define DPCD_68028		0x68028
+#define DPCD_68029		0x68029
+#define DPCD_6802A		0x6802A
+#define DPCD_6802C		0x6802C
+#define DPCD_6803B		0x6803B
+#define DPCD_6921D		0x6921D
+#define DPCD_69000		0x69000
+#define DPCD_69008		0x69008
+#define DPCD_6900B		0x6900B
+#define DPCD_69215		0x69215
+#define DPCD_6921D		0x6921D
+#define DPCD_69220		0x69220
+#define DPCD_692A0		0x692A0
+#define DPCD_692B0		0x692B0
+#define DPCD_692C0		0x692C0
+#define DPCD_692E0		0x692E0
+#define DPCD_692F0		0x692F0
+#define DPCD_692F8		0x692F8
+#define DPCD_69318		0x69318
+#define DPCD_69328		0x69328
+#define DPCD_69330		0x69330
+#define DPCD_69332		0x69332
+#define DPCD_69335		0x69335
+#define DPCD_69345		0x69345
+#define DPCD_693E0		0x693E0
+#define DPCD_693F0		0x693F0
+#define DPCD_693F3		0x693F3
+#define DPCD_693F5		0x693F5
+#define DPCD_69473		0x69473
+#define DPCD_69493		0x69493
+#define DPCD_69494		0x69494
+#define DPCD_69518		0x69518
+
+#define BIT0  0x00000001
+#define BIT1  0x00000002
+#define BIT2  0x00000004
+#define BIT3  0x00000008
+#define BIT4  0x00000010
+#define BIT5  0x00000020
+#define BIT6  0x00000040
+#define BIT7  0x00000080
+#define BIT8  0x00000100
+#define BIT9  0x00000200
+#define BIT10 0x00000400
+#define BIT11 0x00000800
+#define BIT12 0x00001000
+#define BIT13 0x00002000
+#define BIT14 0x00004000
+#define BIT15 0x00008000
+#define BIT16 0x00010000
+#define BIT17 0x00020000
+#define BIT18 0x00040000
+#define BIT19 0x00080000
+#define BIT20 0x00100000
+#define BIT21 0x00200000
+#define BIT22 0x00400000
+#define BIT23 0x00800000
+#define BIT24 0x01000000
+#define BIT25 0x02000000
+#define BIT26 0x04000000
+#define BIT27 0x08000000
+#define BIT28 0x10000000
+#define BIT29 0x20000000
+#define BIT30 0x40000000
+#define BIT31 0x80000000
+
+#endif /*__MTK_DRRX_REG_H__*/
+
diff --git a/drivers/gpu/drm/mediatek/mtk_dpi.c b/drivers/gpu/drm/mediatek/mtk_dpi.c
index e94738fe4db897c497812a0b347cba82adae7bc3..0999a50e62fca5f74564dbd42a903a47160f2c9f 100644
--- a/drivers/gpu/drm/mediatek/mtk_dpi.c
+++ b/drivers/gpu/drm/mediatek/mtk_dpi.c
@@ -14,6 +14,8 @@
 #include <linux/of_graph.h>
 #include <linux/pinctrl/consumer.h>
 #include <linux/platform_device.h>
+#include <linux/regmap.h>
+#include <linux/mfd/syscon.h>
 #include <linux/types.h>
 
 #include <video/videomode.h>
@@ -28,6 +30,7 @@
 #include "mtk_disp_drv.h"
 #include "mtk_dpi_regs.h"
 #include "mtk_drm_ddp_comp.h"
+#include "mediatek_v2/mtk_hdmi.h"
 
 enum mtk_dpi_out_bit_num {
 	MTK_DPI_OUT_BIT_NUM_8BITS,
@@ -53,6 +56,17 @@ enum mtk_dpi_out_channel_swap {
 	MTK_DPI_OUT_CHANNEL_SWAP_BGR
 };
 
+enum mtk_dpi_internal_matrix {
+	MTK_DPI_INT_MATRIX_COLOR_FORMAT_RGB, /* full-range sRGB */
+	MTK_DPI_INT_MATRIX_COLOR_FORMAT_JPEG, /* full-range BT601 */
+	MTK_DPI_INT_MATRIX_COLOR_FORMAT_FULL709, /* full-range BT709 */
+	MTK_DPI_INT_MATRIX_COLOR_FORMAT_BT601, /* limit-range BT601 */
+	MTK_DPI_INT_MATRIX_COLOR_FORMAT_BT709, /* limit-range BT709 */
+	MTK_DPI_INT_MATRIX_COLOR_FORMAT_2020LIMITED,
+	MTK_DPI_INT_MATRIX_COLOR_FORMAT_2020FULL,
+	MTK_DPI_INT_MATRIX_COLOR_FORMAT_CERGB /* limit-range sRGB */
+};
+
 enum mtk_dpi_out_color_format {
 	MTK_DPI_COLOR_FORMAT_RGB,
 	MTK_DPI_COLOR_FORMAT_RGB_FULL,
@@ -69,6 +83,8 @@ struct mtk_dpi {
 	struct drm_bridge *next_bridge;
 	struct drm_connector *connector;
 	void __iomem *regs;
+	struct regmap *vdosys1_regmap;
+	unsigned int vdosys1_offset;
 	struct device *dev;
 	struct clk *engine_clk;
 	struct clk *pixel_clk;
@@ -80,6 +96,9 @@ struct mtk_dpi {
 	enum mtk_dpi_out_yc_map yc_map;
 	enum mtk_dpi_out_bit_num bit_num;
 	enum mtk_dpi_out_channel_swap channel_swap;
+	enum mtk_dpi_internal_matrix in_format;
+	enum mtk_dpi_internal_matrix out_format;
+	bool bypass_matrix;
 	struct pinctrl *pinctrl;
 	struct pinctrl_state *pins_gpio;
 	struct pinctrl_state *pins_dpi;
@@ -127,6 +146,7 @@ struct mtk_dpi_conf {
 	u32 num_output_fmts;
 };
 
+struct mtk_dpi *mtk_global_dpi;
 static void mtk_dpi_mask(struct mtk_dpi *dpi, u32 offset, u32 val, u32 mask)
 {
 	u32 tmp = readl(dpi->regs + offset) & ~mask;
@@ -229,6 +249,16 @@ static void mtk_dpi_config_interface(struct mtk_dpi *dpi, bool inter)
 	mtk_dpi_mask(dpi, DPI_CON, inter ? INTL_EN : 0, INTL_EN);
 }
 
+static void mtk_dpi_config_input_2p(struct mtk_dpi *dpi, bool input_2p)
+{
+	mtk_dpi_mask(dpi, DPI_CON, input_2p ? INPUT_2P_EN : 0, INPUT_2P_EN);
+}
+
+static void mtk_dpi_config_output_1t1p(struct mtk_dpi *dpi, bool output_1t1p)
+{
+	mtk_dpi_mask(dpi, DPI_CON, output_1t1p ? OUTPUT_1T1P_EN : 0, OUTPUT_1T1P_EN);
+}
+
 static void mtk_dpi_config_fb_size(struct mtk_dpi *dpi, u32 width, u32 height)
 {
 	mtk_dpi_mask(dpi, DPI_SIZE, width << HSIZE, HSIZE_MASK);
@@ -355,10 +385,25 @@ static void mtk_dpi_config_2n_h_fre(struct mtk_dpi *dpi)
 	mtk_dpi_mask(dpi, dpi->conf->reg_h_fre_con, H_FRE_2N, H_FRE_2N);
 }
 
+void mtk_dpi_pattern_en(bool enable)
+{
+	struct mtk_dpi *dpi;
+
+	if (mtk_global_dpi == NULL)
+		return;
+
+	dpi = mtk_global_dpi;
+	if (enable == true)
+		mtk_dpi_mask(dpi, 0xf00, 0x41, 0xffffffff);
+	else
+		mtk_dpi_mask(dpi, 0xf00, 0x0, 0xffffffff);
+}
+EXPORT_SYMBOL(mtk_dpi_pattern_en);
+
 static void mtk_dpi_config_disable_edge(struct mtk_dpi *dpi)
 {
 	if (dpi->conf->edge_sel_en)
-		mtk_dpi_mask(dpi, dpi->conf->reg_h_fre_con, 0, EDGE_SEL_EN);
+		mtk_dpi_mask(dpi, dpi->conf->reg_h_fre_con, 0, EDGE_SEL);
 }
 
 static void mtk_dpi_config_color_format(struct mtk_dpi *dpi,
@@ -384,19 +429,207 @@ static void mtk_dpi_config_color_format(struct mtk_dpi *dpi,
 	}
 }
 
-static void mtk_dpi_dual_edge(struct mtk_dpi *dpi)
+static void mtk_dpi_get_output_format(struct mtk_dpi *dpi)
+{
+	enum hdmi_colorspace colorspace;
+	enum hdmi_colorimetry colorimtery;
+	enum hdmi_extended_colorimetry extended_colorimetry;
+	enum hdmi_quantization_range quantization_range;
+	enum hdmi_ycc_quantization_range ycc_quantization_range;
+
+	pr_notice("%s\n", __func__);
+
+#if 0
+	if (dpi->encoder.bridge == NULL) {
+		pr_notice("ERROR: %s: cannot get bridge\n", __func__);
+		return;
+	}
+#endif
+
+	if (dpi->bypass_matrix != true) {
+		get_hdmi_colorspace_colorimetry(&dpi->bridge,
+			&colorspace, &colorimtery, &extended_colorimetry,
+			&quantization_range, &ycc_quantization_range);
+
+		if (colorspace == HDMI_COLORSPACE_RGB) {
+			if ((quantization_range == HDMI_QUANTIZATION_RANGE_DEFAULT) ||
+				(quantization_range == HDMI_QUANTIZATION_RANGE_LIMITED)) {
+				dpi->out_format = MTK_DPI_INT_MATRIX_COLOR_FORMAT_CERGB;
+				//limited RGB
+			} else if (quantization_range == HDMI_QUANTIZATION_RANGE_FULL) {
+				dpi->out_format = MTK_DPI_INT_MATRIX_COLOR_FORMAT_RGB;
+				//full RGB
+			} else {
+				pr_notice("ERROR: %s: unknown RGB quantization\n", __func__);
+				dpi->out_format = MTK_DPI_INT_MATRIX_COLOR_FORMAT_CERGB;
+			}
+		} else if ((colorspace == HDMI_COLORSPACE_YUV422) ||
+			(colorspace == HDMI_COLORSPACE_YUV444) ||
+			(colorspace == HDMI_COLORSPACE_YUV420)) {
+			if (colorimtery == HDMI_COLORIMETRY_ITU_601) {
+				if (ycc_quantization_range == HDMI_YCC_QUANTIZATION_RANGE_LIMITED)
+					dpi->out_format = MTK_DPI_INT_MATRIX_COLOR_FORMAT_BT601;
+				else
+					dpi->out_format = MTK_DPI_INT_MATRIX_COLOR_FORMAT_JPEG;
+			} else if (colorimtery == HDMI_COLORIMETRY_ITU_709) {
+				if (ycc_quantization_range == HDMI_YCC_QUANTIZATION_RANGE_LIMITED)
+					dpi->out_format = MTK_DPI_INT_MATRIX_COLOR_FORMAT_BT709;
+				else
+					dpi->out_format = MTK_DPI_INT_MATRIX_COLOR_FORMAT_FULL709;
+			} else if ((colorimtery == HDMI_COLORIMETRY_EXTENDED) &&
+				(extended_colorimetry == HDMI_EXTENDED_COLORIMETRY_BT2020)) {
+				if (ycc_quantization_range == HDMI_YCC_QUANTIZATION_RANGE_LIMITED)
+					dpi->out_format =
+					MTK_DPI_INT_MATRIX_COLOR_FORMAT_2020LIMITED;
+				else
+					dpi->out_format = MTK_DPI_INT_MATRIX_COLOR_FORMAT_2020FULL;
+			} else {
+				pr_notice("ERROR: %s: un-supported Colorimetry\n", __func__);
+				dpi->out_format = MTK_DPI_INT_MATRIX_COLOR_FORMAT_BT601;
+			}
+
+			if (colorspace == HDMI_COLORSPACE_YUV422)
+				mtk_dpi_config_yuv422_enable(dpi, true);
+		} else {
+			pr_notice("ERROR: %s: unknown ColorSpace\n", __func__);
+			dpi->out_format = MTK_DPI_INT_MATRIX_COLOR_FORMAT_CERGB;
+		}
+	}
+
+	return;
+}
+
+static void mtk_dpi_internal_matrix_sel(struct mtk_dpi *dpi)
 {
-	if ((dpi->output_fmt == MEDIA_BUS_FMT_RGB888_2X12_LE) ||
-	    (dpi->output_fmt == MEDIA_BUS_FMT_RGB888_2X12_BE)) {
-		mtk_dpi_mask(dpi, DPI_DDR_SETTING, DDR_EN | DDR_4PHASE,
-			     DDR_EN | DDR_4PHASE);
-		mtk_dpi_mask(dpi, DPI_OUTPUT_SETTING,
-			     dpi->output_fmt == MEDIA_BUS_FMT_RGB888_2X12_LE ?
-			     EDGE_SEL : 0, EDGE_SEL);
+	u32 matrix_sel = 0x0;
+
+	return;
+
+	pr_notice("%s+\n", __func__);
+
+	if (dpi->bypass_matrix) {
+		mtk_dpi_config_csc_enable(dpi, false);
+		pr_notice("HDR mode, disable matrix_en\n");
 	} else {
-		mtk_dpi_mask(dpi, DPI_DDR_SETTING, DDR_EN | DDR_4PHASE, 0);
+		pr_notice("Not HDR mode, in_format=%d, out_format=%d\n",
+			dpi->in_format, dpi->out_format);
+		if ((dpi->in_format == MTK_DPI_INT_MATRIX_COLOR_FORMAT_RGB) &&
+		(dpi->out_format == MTK_DPI_INT_MATRIX_COLOR_FORMAT_JPEG)) {
+			/* MTX_RGB_TO_JPEG: full-range sRGB to full-range BT601 */
+			matrix_sel = 0x0;
+		} else if ((dpi->in_format == MTK_DPI_INT_MATRIX_COLOR_FORMAT_RGB) &&
+		(dpi->out_format == MTK_DPI_INT_MATRIX_COLOR_FORMAT_FULL709)) {
+			/* MTX_RGB_TO_FULL709: full-range sRGB to full-range BT709 */
+			matrix_sel = 0x1;
+		} else if ((dpi->in_format == MTK_DPI_INT_MATRIX_COLOR_FORMAT_RGB) &&
+		(dpi->out_format == MTK_DPI_INT_MATRIX_COLOR_FORMAT_BT601)) {
+			/* MTX_RGB_TO_BT601: full-range sRGB to limit-range BT601 */
+			matrix_sel = 0x2;
+		} else if ((dpi->in_format == MTK_DPI_INT_MATRIX_COLOR_FORMAT_RGB) &&
+		(dpi->out_format == MTK_DPI_INT_MATRIX_COLOR_FORMAT_BT709)) {
+			/* MTX_RGB_TO_BT709: full-range sRGB to limit-range BT709 */
+			matrix_sel = 0x3;
+		} else if ((dpi->in_format == MTK_DPI_INT_MATRIX_COLOR_FORMAT_JPEG) &&
+		(dpi->out_format == MTK_DPI_INT_MATRIX_COLOR_FORMAT_RGB)) {
+			/* MTX_JPEG_TO_RGB: full-range BT601 to full-range sRGB */
+			matrix_sel = 0x4;
+		} else if ((dpi->in_format == MTK_DPI_INT_MATRIX_COLOR_FORMAT_FULL709) &&
+		(dpi->out_format == MTK_DPI_INT_MATRIX_COLOR_FORMAT_RGB)) {
+			/* MTX_FULL709_TO_RGB: full-range BT709 to full-range sRGB */
+			matrix_sel = 0x5;
+		} else if ((dpi->in_format == MTK_DPI_INT_MATRIX_COLOR_FORMAT_BT601) &&
+		(dpi->out_format == MTK_DPI_INT_MATRIX_COLOR_FORMAT_RGB)) {
+			/* MTX_BT601_TO_RGB: limit-range BT601 to full-range sRGB */
+			matrix_sel = 0x6;
+		} else if ((dpi->in_format == MTK_DPI_INT_MATRIX_COLOR_FORMAT_BT709) &&
+		(dpi->out_format == MTK_DPI_INT_MATRIX_COLOR_FORMAT_RGB)) {
+			/* MTX_BT709_TO_RGB: limit-range BT709 to full-range sRGB */
+			matrix_sel = 0x7;
+		} else if ((dpi->in_format == MTK_DPI_INT_MATRIX_COLOR_FORMAT_JPEG) &&
+		(dpi->out_format == MTK_DPI_INT_MATRIX_COLOR_FORMAT_BT601)) {
+			/* MTX_JPEG_TO_BT601: full-range BT601 to limit-range BT601 */
+			matrix_sel = 0x8;
+		} else if ((dpi->in_format == MTK_DPI_INT_MATRIX_COLOR_FORMAT_JPEG) &&
+		(dpi->out_format == MTK_DPI_INT_MATRIX_COLOR_FORMAT_BT709)) {
+			/* MTX_JPEG_TO_BT709: full-range BT601 to limit-range BT709 */
+			matrix_sel = 0x9;
+		} else if ((dpi->in_format == MTK_DPI_INT_MATRIX_COLOR_FORMAT_BT601) &&
+		(dpi->out_format == MTK_DPI_INT_MATRIX_COLOR_FORMAT_JPEG)) {
+			/* MTX_BT601_TO_JPEG: limit-range BT601 to full-range BT601 */
+			matrix_sel = 0xA;
+		} else if ((dpi->in_format == MTK_DPI_INT_MATRIX_COLOR_FORMAT_BT709) &&
+		(dpi->out_format == MTK_DPI_INT_MATRIX_COLOR_FORMAT_JPEG)) {
+			/* MTX_BT709_TO_JPEG: limit-range BT709 to full-range BT601 */
+			matrix_sel = 0xB;
+		} else if ((dpi->in_format == MTK_DPI_INT_MATRIX_COLOR_FORMAT_BT709) &&
+		(dpi->out_format == MTK_DPI_INT_MATRIX_COLOR_FORMAT_BT601)) {
+			/* MTX_BT709_TO_BT601: limit-range BT709 to limit-range BT601 */
+			matrix_sel = 0xC;
+		} else if ((dpi->in_format == MTK_DPI_INT_MATRIX_COLOR_FORMAT_BT601) &&
+		(dpi->out_format == MTK_DPI_INT_MATRIX_COLOR_FORMAT_BT709)) {
+			/* MTX_BT601_TO_BT709: limit-range BT601 to limit-range BT709 */
+			matrix_sel = 0xD;
+		} else if ((dpi->in_format == MTK_DPI_INT_MATRIX_COLOR_FORMAT_RGB) &&
+		(dpi->out_format == MTK_DPI_INT_MATRIX_COLOR_FORMAT_2020LIMITED)) {
+			/* MTX_RGB_TO_2020LIMITED */
+			matrix_sel = 0x10;
+		} else if ((dpi->in_format == MTK_DPI_INT_MATRIX_COLOR_FORMAT_RGB) &&
+		(dpi->out_format == MTK_DPI_INT_MATRIX_COLOR_FORMAT_2020FULL)) {
+			/* MTX_RGB_TO_2020FULL */
+			matrix_sel = 0x11;
+		} else if ((dpi->in_format == MTK_DPI_INT_MATRIX_COLOR_FORMAT_2020LIMITED) &&
+		(dpi->out_format == MTK_DPI_INT_MATRIX_COLOR_FORMAT_RGB)) {
+			/* MTX_2020LIMITED_TO_RGB */
+			matrix_sel = 0x12;
+		} else if ((dpi->in_format == MTK_DPI_INT_MATRIX_COLOR_FORMAT_2020FULL) &&
+		(dpi->out_format == MTK_DPI_INT_MATRIX_COLOR_FORMAT_RGB)) {
+			/* MTX_2020FULL_TO_RGB */
+			matrix_sel = 0x13;
+		} else if ((dpi->in_format == MTK_DPI_INT_MATRIX_COLOR_FORMAT_JPEG) &&
+		(dpi->out_format == MTK_DPI_INT_MATRIX_COLOR_FORMAT_CERGB)) {
+			/*  MTX_JPEG_TO_CERGB: full-range BT601 to limit-range sRGB */
+			matrix_sel = 0x14;
+		} else if ((dpi->in_format == MTK_DPI_INT_MATRIX_COLOR_FORMAT_FULL709) &&
+		(dpi->out_format == MTK_DPI_INT_MATRIX_COLOR_FORMAT_CERGB)) {
+			/*  MTX_FULL709_TO_CERGB: full-range BT709 to limit-range sRGB */
+			matrix_sel = 0x15;
+		} else if ((dpi->in_format == MTK_DPI_INT_MATRIX_COLOR_FORMAT_BT601) &&
+		(dpi->out_format == MTK_DPI_INT_MATRIX_COLOR_FORMAT_CERGB)) {
+			/*  MTX_BT601_TO_CERGB: limit-range BT601 to limit-range sRGB */
+			matrix_sel = 0x16;
+		} else if ((dpi->in_format == MTK_DPI_INT_MATRIX_COLOR_FORMAT_BT709) &&
+		(dpi->out_format == MTK_DPI_INT_MATRIX_COLOR_FORMAT_CERGB)) {
+			/*  MTX_BT709_TO_CERGB: limit-range BT709 to limit-range sRGB */
+			matrix_sel = 0x17;
+		}  else if ((dpi->in_format == MTK_DPI_INT_MATRIX_COLOR_FORMAT_2020LIMITED) &&
+		(dpi->out_format == MTK_DPI_INT_MATRIX_COLOR_FORMAT_CERGB)) {
+			/*  MTX_BT709_TO_CERGB: limit-range BT709 to limit-range sRGB */
+			matrix_sel = 0x17;
+		} else if ((dpi->in_format == MTK_DPI_INT_MATRIX_COLOR_FORMAT_RGB) &&
+		(dpi->out_format == MTK_DPI_INT_MATRIX_COLOR_FORMAT_CERGB)) {
+			/*  MTX_RGB_TO_CERGB: full-range sRGB to limit-range sRGB */
+			matrix_sel = 0x1C;
+		}
+		mtk_dpi_config_csc_enable(dpi, true);
+		mtk_dpi_mask(dpi, DPI_MATRIX_SET, matrix_sel, INT_MATRIX_SEL_MASK);
 	}
+	mtk_dpi_config_channel_swap(dpi, MTK_DPI_OUT_CHANNEL_SWAP_GBR);
+}
+
+#if 0
+static void mtk_dpi_set_input_format(bool bypass_matrix,
+				enum mtk_dpi_internal_matrix in_format)
+{
+	if (!mtk_global_dpi)
+		return;
+
+	mtk_global_dpi->bypass_matrix = bypass_matrix;
+	mtk_global_dpi->in_format = in_format;
+
+	if (mtk_global_dpi->refcount)
+		mtk_dpi_internal_matrix_sel(mtk_global_dpi);
 }
+#endif
 
 static void mtk_dpi_power_off(struct mtk_dpi *dpi)
 {
@@ -410,6 +643,8 @@ static void mtk_dpi_power_off(struct mtk_dpi *dpi)
 		pinctrl_select_state(dpi->pinctrl, dpi->pins_gpio);
 
 	mtk_dpi_disable(dpi);
+	regmap_update_bits(dpi->vdosys1_regmap,
+		dpi->vdosys1_offset + VDOSYS1_DUMMY0, DPI_ON, ~DPI_ON);
 	clk_disable_unprepare(dpi->pixel_clk);
 	clk_disable_unprepare(dpi->engine_clk);
 }
@@ -433,10 +668,12 @@ static int mtk_dpi_power_on(struct mtk_dpi *dpi)
 		goto err_pixel;
 	}
 
+	regmap_update_bits(dpi->vdosys1_regmap,
+		dpi->vdosys1_offset + VDOSYS1_DUMMY0, DPI_ON, DPI_ON);
+
 	if (dpi->pinctrl && dpi->pins_dpi)
 		pinctrl_select_state(dpi->pinctrl, dpi->pins_dpi);
 
-	mtk_dpi_enable(dpi);
 	return 0;
 
 err_pixel:
@@ -460,34 +697,38 @@ static int mtk_dpi_set_display_mode(struct mtk_dpi *dpi,
 	unsigned long pll_rate;
 	unsigned int factor;
 
-	/* let pll_rate can fix the valid range of tvdpll (1G~2GHz) */
-	factor = dpi->conf->cal_factor(mode->clock);
 	drm_display_mode_to_videomode(mode, &vm);
-	pll_rate = vm.pixelclock * factor;
-
-	dev_dbg(dpi->dev, "Want PLL %lu Hz, pixel clock %lu Hz\n",
-		pll_rate, vm.pixelclock);
 
-	clk_set_rate(dpi->tvd_clk, pll_rate);
-	pll_rate = clk_get_rate(dpi->tvd_clk);
+	/* let pll_rate can fix the valid range of tvdpll (1G~2GHz) */
+	if (dpi->tvd_clk) {
+		factor = dpi->conf->cal_factor(mode->clock);
+		pll_rate = vm.pixelclock * factor;
 
-	vm.pixelclock = pll_rate / factor;
-	if ((dpi->output_fmt == MEDIA_BUS_FMT_RGB888_2X12_LE) ||
-	    (dpi->output_fmt == MEDIA_BUS_FMT_RGB888_2X12_BE))
-		clk_set_rate(dpi->pixel_clk, vm.pixelclock * 2);
-	else
-		clk_set_rate(dpi->pixel_clk, vm.pixelclock);
+		dev_dbg(dpi->dev, "Want PLL %lu Hz, pixel clock %lu Hz\n",
+			pll_rate, vm.pixelclock);
 
+		clk_set_rate(dpi->tvd_clk, pll_rate);
+		pll_rate = clk_get_rate(dpi->tvd_clk);
 
-	vm.pixelclock = clk_get_rate(dpi->pixel_clk);
+		vm.pixelclock = pll_rate / factor;
+		clk_set_rate(dpi->pixel_clk, vm.pixelclock);
+		vm.pixelclock = clk_get_rate(dpi->pixel_clk);
 
-	dev_dbg(dpi->dev, "Got  PLL %lu Hz, pixel clock %lu Hz\n",
-		pll_rate, vm.pixelclock);
+		dev_dbg(dpi->dev, "Got  PLL %lu Hz, pixel clock %lu Hz\n",
+			pll_rate, vm.pixelclock);
+	}
 
-	limit.c_bottom = 0x0010;
-	limit.c_top = 0x0FE0;
-	limit.y_bottom = 0x0010;
-	limit.y_top = 0x0FE0;
+	if (mtk_global_dpi->bypass_matrix) {
+		limit.c_bottom = 0x0000;
+		limit.c_top = 0x0FFF;
+		limit.y_bottom = 0x0000;
+		limit.y_top = 0x0FFF;
+	} else {
+		limit.c_bottom = 0x0010;
+		limit.c_top = 0x0FE0;
+		limit.y_bottom = 0x0010;
+		limit.y_top = 0x0FE0;
+	}
 
 	dpi_pol.ck_pol = MTK_DPI_POLARITY_FALLING;
 	dpi_pol.de_pol = MTK_DPI_POLARITY_RISING;
@@ -504,6 +745,9 @@ static int mtk_dpi_set_display_mode(struct mtk_dpi *dpi,
 	vsync_lodd.front_porch = vm.vfront_porch;
 	vsync_lodd.shift_half_line = false;
 
+	dpi->in_format = mtk_global_dpi->in_format;
+	dpi->out_format = MTK_DPI_INT_MATRIX_COLOR_FORMAT_RGB;
+
 	if (vm.flags & DISPLAY_FLAGS_INTERLACED &&
 	    mode->flags & DRM_MODE_FLAG_3D_MASK) {
 		vsync_leven = vsync_lodd;
@@ -536,15 +780,31 @@ static int mtk_dpi_set_display_mode(struct mtk_dpi *dpi,
 	else
 		mtk_dpi_config_fb_size(dpi, vm.hactive, vm.vactive);
 
+	mtk_dpi_config_input_2p(dpi, true);
+	mtk_dpi_config_output_1t1p(dpi, true);
 	mtk_dpi_config_channel_limit(dpi, &limit);
 	mtk_dpi_config_bit_num(dpi, dpi->bit_num);
 	mtk_dpi_config_channel_swap(dpi, dpi->channel_swap);
 	mtk_dpi_config_yc_map(dpi, dpi->yc_map);
 	mtk_dpi_config_color_format(dpi, dpi->color_format);
+	mtk_dpi_get_output_format(dpi); //get OUT_FORMAT from HDMI
+	/* DPI do conversion in following cases:
+ 	* 1. BT601 YCbCr -> RGB full
+ 	* 2. BT601 YCbCr -> RGB limited
+ 	* 3. BT709 YCbCr -> RGB full
+ 	* 4. BT709 YCbCr -> RGB limited
+ 	* 5. BT2020 YCbCr -> RGB full
+ 	* 6. BT2020 YCbCr -> RGB limited
+ 	* 7. specical case: Dolby Vision: bypass
+ 	* in other cases, DPI just bypass conversion, and front-ended module
+ 	* shall convert the content to right format prior to DPI
+ 	*/
+	mtk_dpi_internal_matrix_sel(dpi);
+
 	mtk_dpi_config_2n_h_fre(dpi);
-	mtk_dpi_dual_edge(dpi);
 	mtk_dpi_config_disable_edge(dpi);
 	mtk_dpi_sw_reset(dpi, false);
+	mtk_dpi_enable(dpi);
 
 	return 0;
 }
@@ -689,18 +949,22 @@ static const struct drm_bridge_funcs mtk_dpi_bridge_funcs = {
 
 void mtk_dpi_start(struct device *dev)
 {
-	struct mtk_dpi *dpi = dev_get_drvdata(dev);
-
-	mtk_dpi_power_on(dpi);
 }
 
 void mtk_dpi_stop(struct device *dev)
+{
+}
+
+int mtk_dpi_encoder_index(struct device *dev)
 {
 	struct mtk_dpi *dpi = dev_get_drvdata(dev);
+	int encoder_index = drm_encoder_index(&dpi->encoder);
 
-	mtk_dpi_power_off(dpi);
+	dev_dbg(dev, "encoder index:%d", encoder_index);
+	return encoder_index;
 }
 
+
 static int mtk_dpi_bind(struct device *dev, struct device *master, void *data)
 {
 	struct mtk_dpi *dpi = dev_get_drvdata(dev);
@@ -722,7 +986,7 @@ static int mtk_dpi_bind(struct device *dev, struct device *master, void *data)
 		dev_err(dev, "Failed to attach bridge: %d\n", ret);
 		goto err_cleanup;
 	}
-
+#if 0
 	dpi->connector = drm_bridge_connector_init(drm_dev, &dpi->encoder);
 	if (IS_ERR(dpi->connector)) {
 		dev_err(dev, "Unable to create bridge connector\n");
@@ -730,6 +994,11 @@ static int mtk_dpi_bind(struct device *dev, struct device *master, void *data)
 		goto err_cleanup;
 	}
 	drm_connector_attach_encoder(dpi->connector, &dpi->encoder);
+#endif
+	dpi->bit_num = MTK_DPI_OUT_BIT_NUM_8BITS;
+	dpi->channel_swap = MTK_DPI_OUT_CHANNEL_SWAP_RGB;
+	dpi->yc_map = MTK_DPI_OUT_YC_MAP_RGB;
+	dpi->color_format = MTK_DPI_COLOR_FORMAT_RGB;
 
 	return 0;
 
@@ -783,21 +1052,15 @@ static unsigned int mt8183_calculate_factor(int clock)
 		return 2;
 }
 
-static const u32 mt8173_output_fmts[] = {
-	MEDIA_BUS_FMT_RGB888_1X24,
-};
-
-static const u32 mt8183_output_fmts[] = {
-	MEDIA_BUS_FMT_RGB888_2X12_LE,
-	MEDIA_BUS_FMT_RGB888_2X12_BE,
-};
+static unsigned int mt8195_calculate_factor(int clock)
+{
+	return 1;
+}
 
 static const struct mtk_dpi_conf mt8173_conf = {
 	.cal_factor = mt8173_calculate_factor,
 	.reg_h_fre_con = 0xe0,
 	.max_clock_khz = 300000,
-	.output_fmts = mt8173_output_fmts,
-	.num_output_fmts = ARRAY_SIZE(mt8173_output_fmts),
 };
 
 static const struct mtk_dpi_conf mt2701_conf = {
@@ -805,24 +1068,23 @@ static const struct mtk_dpi_conf mt2701_conf = {
 	.reg_h_fre_con = 0xb0,
 	.edge_sel_en = true,
 	.max_clock_khz = 150000,
-	.output_fmts = mt8173_output_fmts,
-	.num_output_fmts = ARRAY_SIZE(mt8173_output_fmts),
 };
 
 static const struct mtk_dpi_conf mt8183_conf = {
 	.cal_factor = mt8183_calculate_factor,
 	.reg_h_fre_con = 0xe0,
 	.max_clock_khz = 100000,
-	.output_fmts = mt8183_output_fmts,
-	.num_output_fmts = ARRAY_SIZE(mt8183_output_fmts),
 };
 
 static const struct mtk_dpi_conf mt8192_conf = {
 	.cal_factor = mt8183_calculate_factor,
 	.reg_h_fre_con = 0xe0,
 	.max_clock_khz = 150000,
-	.output_fmts = mt8173_output_fmts,
-	.num_output_fmts = ARRAY_SIZE(mt8173_output_fmts),
+};
+
+static const struct mtk_dpi_conf mt8195_conf = {
+	.cal_factor = mt8195_calculate_factor,
+	.max_clock_khz = 594000,
 };
 
 static int mtk_dpi_probe(struct platform_device *pdev)
@@ -830,12 +1092,16 @@ static int mtk_dpi_probe(struct platform_device *pdev)
 	struct device *dev = &pdev->dev;
 	struct mtk_dpi *dpi;
 	struct resource *mem;
+	struct regmap *regmap;
 	int ret;
 
 	dpi = devm_kzalloc(dev, sizeof(*dpi), GFP_KERNEL);
 	if (!dpi)
 		return -ENOMEM;
 
+	mtk_global_dpi = dpi;
+	mtk_global_dpi->in_format = MTK_DPI_INT_MATRIX_COLOR_FORMAT_BT709;
+
 	dpi->dev = dev;
 	dpi->conf = (struct mtk_dpi_conf *)of_device_get_match_data(dev);
 	dpi->output_fmt = MEDIA_BUS_FMT_RGB888_1X24;
@@ -868,6 +1134,24 @@ static int mtk_dpi_probe(struct platform_device *pdev)
 		return ret;
 	}
 
+	/*
+	 * The mediatek,vdosys1-dpi property contains a phandle link to the
+	 * VDOSYS1_CONFIG device and the register offset of the VDOSYS1_DUMMY0
+	 * registers it contains.
+	 */
+	regmap = syscon_regmap_lookup_by_phandle(pdev->dev.of_node,
+			"mediatek,vdosys1-dpi");
+	ret = of_property_read_u32_index(pdev->dev.of_node,
+			"mediatek,vdosys1-dpi", 1,
+			&dpi->vdosys1_offset);
+	if (IS_ERR(regmap))
+		ret = PTR_ERR(regmap);
+	if (ret) {
+		ret = PTR_ERR(regmap);
+		pr_info("Failed to get vdosys1 registers: %d\n", ret);
+	}
+	dpi->vdosys1_regmap = regmap;
+
 	dpi->engine_clk = devm_clk_get(dev, "engine");
 	if (IS_ERR(dpi->engine_clk)) {
 		ret = PTR_ERR(dpi->engine_clk);
@@ -889,10 +1173,8 @@ static int mtk_dpi_probe(struct platform_device *pdev)
 	dpi->tvd_clk = devm_clk_get(dev, "pll");
 	if (IS_ERR(dpi->tvd_clk)) {
 		ret = PTR_ERR(dpi->tvd_clk);
-		if (ret != -EPROBE_DEFER)
 			dev_err(dev, "Failed to get tvdpll clock: %d\n", ret);
-
-		return ret;
+		dpi->tvd_clk = NULL;
 	}
 
 	dpi->irq = platform_get_irq(pdev, 0);
@@ -947,6 +1229,9 @@ static const struct of_device_id mtk_dpi_of_ids[] = {
 	{ .compatible = "mediatek,mt8192-dpi",
 	  .data = &mt8192_conf,
 	},
+	{ .compatible = "mediatek,mt8195-dpi",
+	  .data = &mt8195_conf,
+	},
 	{ },
 };
 MODULE_DEVICE_TABLE(of, mtk_dpi_of_ids);
diff --git a/drivers/gpu/drm/mediatek/mtk_dpi_regs.h b/drivers/gpu/drm/mediatek/mtk_dpi_regs.h
index 3a02fabe16627a3e6419675586d40c0a8a8598d8..90be17d23d59a06a515c79e0da12d4d743f405ec 100644
--- a/drivers/gpu/drm/mediatek/mtk_dpi_regs.h
+++ b/drivers/gpu/drm/mediatek/mtk_dpi_regs.h
@@ -40,6 +40,13 @@
 #define FAKE_DE_LEVEN			BIT(21)
 #define FAKE_DE_RODD			BIT(22)
 #define FAKE_DE_REVEN			BIT(23)
+/* 8195 add start */
+#define OUTPUT_1T1P_EN			BIT(24)
+#define INPUT_2P_EN			BIT(25)
+#define EXT_VSYNC_EN			BIT(26)
+#define RGB565_EN			BIT(27)
+#define RGB880_EN			BIT(28)
+/* 8195 add end */
 
 #define DPI_OUTPUT_SETTING	0x14
 #define CH_SWAP				0
@@ -215,6 +222,41 @@
 #define ESAV_CODE2			(0xFFF << 0)
 #define ESAV_CODE3_MSB			BIT(16)
 
-#define EDGE_SEL_EN			BIT(5)
+#define DPI_MATRIX_SET	0xB4
+#define INT_MATRIX_SEL			BIT(0)
+#define INT_MATRIX_SEL_MASK		(0x1F << 0)
+#define RGB_TO_JPEG			0x00
+#define RGB_TO_FULL709			0x01
+#define RGB_TO_BT601			0x02
+#define RGB_TO_BT709			0x03
+#define JPEG_TO_RGB			0x04
+#define FULL709_TO_RGB			0x05
+#define BT601_TO_RGB			0x06
+#define BT709_TO_RGB			0x07
+#define JPEG_TO_BT601			0x08
+#define JPEG_TO_BT709			0x09
+#define BT601_TO_JPEG			0xA
+#define BT709_TO_JPEG			0xB
+#define BT709_TO_BT601			0xC
+#define BT601_TO_BT709			0xD
+#define JPEG_TO_CERGB			0x14
+#define FULL709_TO_CERGB		0x15
+#define BT601_TO_CERGB			0x16
+#define BT709_TO_CERGB			0x17
+#define RGB_TO_CERGB			0x1C
+#define MATRIX_BIT			BIT(8)
+#define EXT_MATRIX_EN			BIT(12)
+
+#define DPI_H_FRE_CON		0xE0
 #define H_FRE_2N			BIT(25)
+
+/* 8195 add start */
+#define DPI_EXT_VSYNC		0xF08
+#define EXT_VFP_LIMIT			BIT(0)
+#define EXT_VFP_LIMIT_MASK		(0x1FFF << 0)
+/* 8195 add end */
+
+#define VDOSYS1_DUMMY0		0x400
+#define DPI_ON				(0x1 << 0)
+
 #endif /* __MTK_DPI_REGS_H */
diff --git a/drivers/gpu/drm/mediatek/mtk_drm_crtc.c b/drivers/gpu/drm/mediatek/mtk_drm_crtc.c
index 798cce90351b61d0307b5423a8bf02feef5edd9b..062ae5c23544010a1baab29e18caaf67380141e3 100644
--- a/drivers/gpu/drm/mediatek/mtk_drm_crtc.c
+++ b/drivers/gpu/drm/mediatek/mtk_drm_crtc.c
@@ -54,9 +54,15 @@ struct mtk_drm_crtc {
 #endif
 
 	struct device			*mmsys_dev;
+	struct device			*drm_dev;
 	struct mtk_mutex		*mutex;
+	unsigned int			ddp_comp_nr_ori;
+	unsigned int			max_ddp_comp_nr;
+
 	unsigned int			ddp_comp_nr;
 	struct mtk_ddp_comp		**ddp_comp;
+	unsigned int			conn_route_nr;
+	const struct mtk_drm_route	*conn_routes;
 
 	/* lock for display hardware access */
 	struct mutex			hw_lock;
@@ -88,7 +94,10 @@ static void mtk_drm_crtc_finish_page_flip(struct mtk_drm_crtc *mtk_crtc)
 	unsigned long flags;
 
 	spin_lock_irqsave(&crtc->dev->event_lock, flags);
-	drm_crtc_send_vblank_event(crtc, mtk_crtc->event);
+
+	if (mtk_crtc->event)
+		drm_crtc_send_vblank_event(crtc, mtk_crtc->event);
+
 	drm_crtc_vblank_put(crtc);
 	mtk_crtc->event = NULL;
 	spin_unlock_irqrestore(&crtc->dev->event_lock, flags);
@@ -108,7 +117,10 @@ static void mtk_drm_crtc_destroy(struct drm_crtc *crtc)
 	struct mtk_drm_crtc *mtk_crtc = to_mtk_crtc(crtc);
 
 	mtk_mutex_put(mtk_crtc->mutex);
-
+#if IS_REACHABLE(CONFIG_MTK_CMDQ)
+	device_link_remove(mtk_crtc->drm_dev,
+			   mtk_crtc->cmdq_client->chan->mbox->dev);
+#endif
 	drm_crtc_cleanup(crtc);
 }
 
@@ -559,6 +571,82 @@ static void mtk_drm_crtc_disable_vblank(struct drm_crtc *crtc)
 	mtk_ddp_comp_disable_vblank(comp);
 }
 
+static unsigned int mtk_drm_crtc_max_num_route_comp(struct mtk_drm_crtc *mtk_crtc)
+{
+	unsigned int max_num = 0;
+	unsigned int i;
+
+	if (!mtk_crtc->conn_route_nr)
+		return 0;
+
+	for (i = 0; i < mtk_crtc->conn_route_nr; i++) {
+		max_num = (max_num > mtk_crtc->conn_routes[i].route_len) ? max_num :
+				mtk_crtc->conn_routes[i].route_len;
+	}
+	return max_num;
+}
+
+static int mtk_drm_crtc_update_output(struct drm_crtc *crtc,
+				struct drm_atomic_state *state)
+{
+	struct mtk_drm_crtc *mtk_crtc = to_mtk_crtc(crtc);
+	int crtc_index = drm_crtc_index(crtc);
+	struct mtk_drm_private *priv = crtc->dev->dev_private;
+	struct device *dev = crtc->dev->dev;
+	struct drm_crtc_state *crtc_state = state->crtcs[crtc_index].new_state;
+	u32 encoder_mask = crtc_state->encoder_mask;
+	int i;
+	int route_index;
+	int route_len;
+	enum mtk_ddp_comp_id comp_id;
+	const struct mtk_drm_route *conn_routes;
+
+	if (!mtk_crtc->conn_route_nr)
+		return 0;
+
+	dev_dbg(dev, "connector change:%d, encoder mask0x%x for crtc%d",
+				crtc_state->connectors_changed, crtc_index,
+				encoder_mask);
+
+	if (!crtc_state->connectors_changed)
+		return 0;
+
+	conn_routes = mtk_crtc->conn_routes;
+
+	for (i = 0; i < mtk_crtc->conn_route_nr; i++) {
+		route_len = conn_routes[i].route_len;
+		comp_id = conn_routes[i].route_ddp[route_len - 1];
+		if (priv->comp_node[comp_id]) {
+			if ((1 << priv->ddp_comp[comp_id].encoder_index) == encoder_mask) {
+				route_index = i;
+				break;
+			}
+		}
+	}
+
+	for (i = 0; i < route_len; i++) {
+		struct mtk_ddp_comp *comp;
+		struct device_node *node;
+
+		comp_id = conn_routes[route_index].route_ddp[i];
+		node = priv->comp_node[comp_id];
+		comp = &priv->ddp_comp[comp_id];
+		if (!comp) {
+			dev_err(dev, "Component %pOF not initialized\n", node);
+			return -ENODEV;;
+		}
+
+		mtk_crtc->ddp_comp[mtk_crtc->ddp_comp_nr_ori + i] = comp;
+		dev_dbg(dev, "Add comp %d at path index %d",
+				comp_id, mtk_crtc->ddp_comp_nr_ori + i);
+	}
+
+	mtk_crtc->ddp_comp_nr = mtk_crtc->ddp_comp_nr_ori + route_len;
+	dev_dbg(dev, "Update total comp num:%d", mtk_crtc->ddp_comp_nr);
+
+	return 0;
+}
+
 int mtk_drm_crtc_plane_check(struct drm_crtc *crtc, struct drm_plane *plane,
 			     struct mtk_plane_state *state)
 {
@@ -591,6 +679,11 @@ static void mtk_drm_crtc_atomic_enable(struct drm_crtc *crtc,
 
 	DRM_DEBUG_DRIVER("%s %d\n", __func__, crtc->base.id);
 
+	ret = mtk_drm_crtc_update_output(crtc, state);
+	if (ret < 0)
+		DRM_DEV_ERROR(comp->dev, "Failed to update crtc output: %d\n",
+			      ret);
+
 	ret = pm_runtime_resume_and_get(comp->dev);
 	if (ret < 0)
 		DRM_DEV_ERROR(comp->dev, "Failed to enable power domain: %d\n",
@@ -779,21 +872,32 @@ static int mtk_drm_crtc_init_comp_planes(struct drm_device *drm_dev,
 }
 
 int mtk_drm_crtc_create(struct drm_device *drm_dev,
-			const enum mtk_ddp_comp_id *path, unsigned int path_len)
+			const enum mtk_ddp_comp_id *path, unsigned int path_len,
+			int priv_data_index, const struct mtk_drm_route *conn_routes,
+			unsigned int conn_routes_num)
 {
 	struct mtk_drm_private *priv = drm_dev->dev_private;
 	struct device *dev = drm_dev->dev;
+	struct device_link *link;
 	struct mtk_drm_crtc *mtk_crtc;
 	unsigned int num_comp_planes = 0;
-	int pipe = priv->num_pipes;
 	int ret;
 	int i;
 	bool has_ctm = false;
 	uint gamma_lut_size = 0;
+	struct drm_crtc *tmp;
+	int crtc_i = 0;
+	unsigned int max_route_comp_num;
+	unsigned int route_len;
 
 	if (!path)
 		return 0;
 
+	priv = priv->all_drm_private[priv_data_index];
+
+	drm_for_each_crtc(tmp, drm_dev)
+		crtc_i++;
+
 	for (i = 0; i < path_len; i++) {
 		enum mtk_ddp_comp_id comp_id = path[i];
 		struct device_node *node;
@@ -802,7 +906,7 @@ int mtk_drm_crtc_create(struct drm_device *drm_dev,
 		if (!node) {
 			dev_info(dev,
 				 "Not creating crtc %d because component %d is disabled or missing\n",
-				 pipe, comp_id);
+				 crtc_i, comp_id);
 			return 0;
 		}
 	}
@@ -811,9 +915,24 @@ int mtk_drm_crtc_create(struct drm_device *drm_dev,
 	if (!mtk_crtc)
 		return -ENOMEM;
 
+	mtk_crtc->drm_dev = dev;
 	mtk_crtc->mmsys_dev = priv->mmsys_dev;
-	mtk_crtc->ddp_comp_nr = path_len;
-	mtk_crtc->ddp_comp = devm_kmalloc_array(dev, mtk_crtc->ddp_comp_nr,
+	mtk_crtc->ddp_comp_nr_ori = mtk_crtc->ddp_comp_nr = path_len;
+	if (conn_routes) {
+		enum mtk_ddp_comp_id comp_id;
+
+		for (i = 0; i < conn_routes_num; i++) {
+			route_len = conn_routes[i].route_len;
+			comp_id = conn_routes[i].route_ddp[route_len - 1];
+			mtk_ddp_comp_encoder_index_set(&priv->ddp_comp[comp_id]);
+		}
+
+		mtk_crtc->conn_route_nr = conn_routes_num;
+		mtk_crtc->conn_routes = conn_routes;
+	}
+	max_route_comp_num = mtk_drm_crtc_max_num_route_comp(mtk_crtc);
+	mtk_crtc->max_ddp_comp_nr  = mtk_crtc->ddp_comp_nr + max_route_comp_num;
+	mtk_crtc->ddp_comp = devm_kmalloc_array(dev, mtk_crtc->max_ddp_comp_nr,
 						sizeof(*mtk_crtc->ddp_comp),
 						GFP_KERNEL);
 	if (!mtk_crtc->ddp_comp)
@@ -858,25 +977,25 @@ int mtk_drm_crtc_create(struct drm_device *drm_dev,
 
 	for (i = 0; i < mtk_crtc->ddp_comp_nr; i++) {
 		ret = mtk_drm_crtc_init_comp_planes(drm_dev, mtk_crtc, i,
-						    pipe);
+						    crtc_i);
 		if (ret)
 			return ret;
 	}
 
-	ret = mtk_drm_crtc_init(drm_dev, mtk_crtc, pipe);
+	ret = mtk_drm_crtc_init(drm_dev, mtk_crtc, crtc_i);
 	if (ret < 0)
 		return ret;
 
 	if (gamma_lut_size)
 		drm_mode_crtc_set_gamma_size(&mtk_crtc->base, gamma_lut_size);
 	drm_crtc_enable_color_mgmt(&mtk_crtc->base, 0, has_ctm, gamma_lut_size);
-	priv->num_pipes++;
 	mutex_init(&mtk_crtc->hw_lock);
 
 #if IS_REACHABLE(CONFIG_MTK_CMDQ)
+	i = (priv->data->mmsys_dev_num > 1) ? 0 : drm_crtc_index(&mtk_crtc->base);
+
 	mtk_crtc->cmdq_client =
-			cmdq_mbox_create(mtk_crtc->mmsys_dev,
-					 drm_crtc_index(&mtk_crtc->base));
+			cmdq_mbox_create(mtk_crtc->mmsys_dev, i);
 	if (IS_ERR(mtk_crtc->cmdq_client)) {
 		dev_dbg(dev, "mtk_crtc %d failed to create mailbox client, writing register by CPU now\n",
 			drm_crtc_index(&mtk_crtc->base));
@@ -884,9 +1003,16 @@ int mtk_drm_crtc_create(struct drm_device *drm_dev,
 	}
 
 	if (mtk_crtc->cmdq_client) {
+		/* add devlink to cmdq to make sure pm_suspend/resume order is correct */
+		link = device_link_add(dev, mtk_crtc->cmdq_client->chan->mbox->dev,
+				       DL_FLAG_PM_RUNTIME | DL_FLAG_STATELESS);
+		if (!link) {
+			dev_err(dev, "Unable to link cmdq dev\n");
+		}
+
 		ret = of_property_read_u32_index(priv->mutex_node,
 						 "mediatek,gce-events",
-						 drm_crtc_index(&mtk_crtc->base),
+						 i,
 						 &mtk_crtc->cmdq_event);
 		if (ret) {
 			dev_dbg(dev, "mtk_crtc %d failed to get mediatek,gce-events property\n",
diff --git a/drivers/gpu/drm/mediatek/mtk_drm_crtc.h b/drivers/gpu/drm/mediatek/mtk_drm_crtc.h
index cb9a36c48d4fdc096e9ce3c57e8f8078a6cef32c..905744155326517f07c8a134ba82442e6860d25d 100644
--- a/drivers/gpu/drm/mediatek/mtk_drm_crtc.h
+++ b/drivers/gpu/drm/mediatek/mtk_drm_crtc.h
@@ -7,6 +7,7 @@
 #define MTK_DRM_CRTC_H
 
 #include <drm/drm_crtc.h>
+#include "mtk_drm_drv.h"
 #include "mtk_drm_ddp_comp.h"
 #include "mtk_drm_plane.h"
 
@@ -17,7 +18,10 @@
 void mtk_drm_crtc_commit(struct drm_crtc *crtc);
 int mtk_drm_crtc_create(struct drm_device *drm_dev,
 			const enum mtk_ddp_comp_id *path,
-			unsigned int path_len);
+			unsigned int path_len,
+			int priv_data_index,
+			const struct mtk_drm_route *conn_routes,
+			unsigned int conn_routes_num);
 int mtk_drm_crtc_plane_check(struct drm_crtc *crtc, struct drm_plane *plane,
 			     struct mtk_plane_state *state);
 void mtk_drm_crtc_async_update(struct drm_crtc *crtc, struct drm_plane *plane,
diff --git a/drivers/gpu/drm/mediatek/mtk_drm_ddp_comp.c b/drivers/gpu/drm/mediatek/mtk_drm_ddp_comp.c
index 5860533ee9532a570838b5095e4e1428aa42ad56..74402720bb5210c13fea67a1f2cf228900d267e9 100644
--- a/drivers/gpu/drm/mediatek/mtk_drm_ddp_comp.c
+++ b/drivers/gpu/drm/mediatek/mtk_drm_ddp_comp.c
@@ -20,45 +20,40 @@
 #include "mtk_drm_ddp_comp.h"
 #include "mtk_drm_crtc.h"
 
-#define DISP_OD_EN				0x0000
-#define DISP_OD_INTEN				0x0008
-#define DISP_OD_INTSTA				0x000c
-#define DISP_OD_CFG				0x0020
-#define DISP_OD_SIZE				0x0030
-#define DISP_DITHER_5				0x0114
-#define DISP_DITHER_7				0x011c
-#define DISP_DITHER_15				0x013c
-#define DISP_DITHER_16				0x0140
 
-#define DISP_REG_UFO_START			0x0000
-
-#define DISP_DITHER_EN				0x0000
+#define DISP_REG_DITHER_EN			0x0000
 #define DITHER_EN				BIT(0)
-#define DISP_DITHER_CFG				0x0020
+#define DISP_REG_DITHER_CFG			0x0020
 #define DITHER_RELAY_MODE			BIT(0)
 #define DITHER_ENGINE_EN			BIT(1)
-#define DISP_DITHER_SIZE			0x0030
-
-#define LUT_10BIT_MASK				0x03ff
-
-#define OD_RELAYMODE				BIT(0)
-
-#define UFO_BYPASS				BIT(2)
 
 #define DISP_DITHERING				BIT(2)
+#define DISP_REG_DITHER_SIZE			0x0030
+#define DISP_REG_DITHER_5			0x0114
+#define DISP_REG_DITHER_7			0x011c
+#define DISP_REG_DITHER_15			0x013c
 #define DITHER_LSB_ERR_SHIFT_R(x)		(((x) & 0x7) << 28)
-#define DITHER_OVFLW_BIT_R(x)			(((x) & 0x7) << 24)
 #define DITHER_ADD_LSHIFT_R(x)			(((x) & 0x7) << 20)
-#define DITHER_ADD_RSHIFT_R(x)			(((x) & 0x7) << 16)
 #define DITHER_NEW_BIT_MODE			BIT(0)
+#define DISP_REG_DITHER_16			0x0140
 #define DITHER_LSB_ERR_SHIFT_B(x)		(((x) & 0x7) << 28)
-#define DITHER_OVFLW_BIT_B(x)			(((x) & 0x7) << 24)
 #define DITHER_ADD_LSHIFT_B(x)			(((x) & 0x7) << 20)
-#define DITHER_ADD_RSHIFT_B(x)			(((x) & 0x7) << 16)
 #define DITHER_LSB_ERR_SHIFT_G(x)		(((x) & 0x7) << 12)
-#define DITHER_OVFLW_BIT_G(x)			(((x) & 0x7) << 8)
 #define DITHER_ADD_LSHIFT_G(x)			(((x) & 0x7) << 4)
-#define DITHER_ADD_RSHIFT_G(x)			(((x) & 0x7) << 0)
+
+#define DISP_REG_DSC_CON			0x0000
+#define DSC_EN					BIT(0)
+#define DSC_DUAL_INOUT				BIT(2)
+#define DSC_BYPASS				BIT(4)
+#define DSC_UFOE_SEL				BIT(16)
+
+#define DISP_REG_OD_EN				0x0000
+#define DISP_REG_OD_CFG				0x0020
+#define OD_RELAYMODE				BIT(0)
+#define DISP_REG_OD_SIZE			0x0030
+
+#define DISP_REG_UFO_START			0x0000
+#define UFO_BYPASS				BIT(2)
 
 struct mtk_ddp_comp_dev {
 	struct clk *clk;
@@ -134,25 +129,52 @@ void mtk_dither_set_common(void __iomem *regs, struct cmdq_client_reg *cmdq_reg,
 		return;
 
 	if (bpc >= MTK_MIN_BPC) {
-		mtk_ddp_write(cmdq_pkt, 0, cmdq_reg, regs, DISP_DITHER_5);
-		mtk_ddp_write(cmdq_pkt, 0, cmdq_reg, regs, DISP_DITHER_7);
+		mtk_ddp_write(cmdq_pkt, 0, cmdq_reg, regs, DISP_REG_DITHER_5);
+		mtk_ddp_write(cmdq_pkt, 0, cmdq_reg, regs, DISP_REG_DITHER_7);
 		mtk_ddp_write(cmdq_pkt,
 			      DITHER_LSB_ERR_SHIFT_R(MTK_MAX_BPC - bpc) |
 			      DITHER_ADD_LSHIFT_R(MTK_MAX_BPC - bpc) |
 			      DITHER_NEW_BIT_MODE,
-			      cmdq_reg, regs, DISP_DITHER_15);
+			      cmdq_reg, regs, DISP_REG_DITHER_15);
 		mtk_ddp_write(cmdq_pkt,
 			      DITHER_LSB_ERR_SHIFT_B(MTK_MAX_BPC - bpc) |
 			      DITHER_ADD_LSHIFT_B(MTK_MAX_BPC - bpc) |
 			      DITHER_LSB_ERR_SHIFT_G(MTK_MAX_BPC - bpc) |
 			      DITHER_ADD_LSHIFT_G(MTK_MAX_BPC - bpc),
-			      cmdq_reg, regs, DISP_DITHER_16);
+			      cmdq_reg, regs, DISP_REG_DITHER_16);
 		mtk_ddp_write(cmdq_pkt, dither_en, cmdq_reg, regs, cfg);
 	}
 }
 
+static void mtk_dither_config(struct device *dev, unsigned int w,
+			      unsigned int h, unsigned int vrefresh,
+			      unsigned int bpc, struct cmdq_pkt *cmdq_pkt)
+{
+	struct mtk_ddp_comp_dev *priv = dev_get_drvdata(dev);
+
+	mtk_ddp_write(cmdq_pkt, h << 16 | w, &priv->cmdq_reg, priv->regs, DISP_REG_DITHER_SIZE);
+	mtk_ddp_write(cmdq_pkt, DITHER_RELAY_MODE, &priv->cmdq_reg, priv->regs,
+		      DISP_REG_DITHER_CFG);
+	mtk_dither_set_common(priv->regs, &priv->cmdq_reg, bpc, DISP_REG_DITHER_CFG,
+			      DITHER_ENGINE_EN, cmdq_pkt);
+}
+
+static void mtk_dither_start(struct device *dev)
+{
+	struct mtk_ddp_comp_dev *priv = dev_get_drvdata(dev);
+
+	writel(DITHER_EN, priv->regs + DISP_REG_DITHER_EN);
+}
+
+static void mtk_dither_stop(struct device *dev)
+{
+	struct mtk_ddp_comp_dev *priv = dev_get_drvdata(dev);
+
+	writel_relaxed(0x0, priv->regs + DISP_REG_DITHER_EN);
+}
+
 static void mtk_dither_set(struct device *dev, unsigned int bpc,
-		    unsigned int cfg, struct cmdq_pkt *cmdq_pkt)
+			   unsigned int cfg, struct cmdq_pkt *cmdq_pkt)
 {
 	struct mtk_ddp_comp_dev *priv = dev_get_drvdata(dev);
 
@@ -160,55 +182,59 @@ static void mtk_dither_set(struct device *dev, unsigned int bpc,
 			      DISP_DITHERING, cmdq_pkt);
 }
 
-static void mtk_od_config(struct device *dev, unsigned int w,
-			  unsigned int h, unsigned int vrefresh,
-			  unsigned int bpc, struct cmdq_pkt *cmdq_pkt)
+static void mtk_dsc_config(struct device *dev, unsigned int w,
+			   unsigned int h, unsigned int vrefresh,
+			   unsigned int bpc, struct cmdq_pkt *cmdq_pkt)
 {
 	struct mtk_ddp_comp_dev *priv = dev_get_drvdata(dev);
 
-	mtk_ddp_write(cmdq_pkt, w << 16 | h, &priv->cmdq_reg, priv->regs, DISP_OD_SIZE);
-	mtk_ddp_write(cmdq_pkt, OD_RELAYMODE, &priv->cmdq_reg, priv->regs, DISP_OD_CFG);
-	mtk_dither_set(dev, bpc, DISP_OD_CFG, cmdq_pkt);
+	/* dsc bypass mode */
+	mtk_ddp_write_mask(cmdq_pkt, DSC_BYPASS, &priv->cmdq_reg, priv->regs,
+			   DISP_REG_DSC_CON, DSC_BYPASS);
+	mtk_ddp_write_mask(cmdq_pkt, DSC_UFOE_SEL, &priv->cmdq_reg, priv->regs,
+			   DISP_REG_DSC_CON, DSC_UFOE_SEL);
+	mtk_ddp_write_mask(cmdq_pkt, DSC_DUAL_INOUT, &priv->cmdq_reg, priv->regs,
+			   DISP_REG_DSC_CON, DSC_DUAL_INOUT);
 }
 
-static void mtk_od_start(struct device *dev)
+static void mtk_dsc_start(struct device *dev)
 {
 	struct mtk_ddp_comp_dev *priv = dev_get_drvdata(dev);
 
-	writel(1, priv->regs + DISP_OD_EN);
+	/* write with mask to reserve the value set in mtk_dsc_config */
+	mtk_ddp_write_mask(NULL, DSC_EN, &priv->cmdq_reg, priv->regs, DISP_REG_DSC_CON, DSC_EN);
 }
 
-static void mtk_ufoe_start(struct device *dev)
+static void mtk_dsc_stop(struct device *dev)
 {
 	struct mtk_ddp_comp_dev *priv = dev_get_drvdata(dev);
 
-	writel(UFO_BYPASS, priv->regs + DISP_REG_UFO_START);
+	writel_relaxed(0x0, priv->regs + DISP_REG_DSC_CON);
 }
 
-static void mtk_dither_config(struct device *dev, unsigned int w,
-			      unsigned int h, unsigned int vrefresh,
-			      unsigned int bpc, struct cmdq_pkt *cmdq_pkt)
+static void mtk_od_config(struct device *dev, unsigned int w,
+			  unsigned int h, unsigned int vrefresh,
+			  unsigned int bpc, struct cmdq_pkt *cmdq_pkt)
 {
 	struct mtk_ddp_comp_dev *priv = dev_get_drvdata(dev);
 
-	mtk_ddp_write(cmdq_pkt, h << 16 | w, &priv->cmdq_reg, priv->regs, DISP_DITHER_SIZE);
-	mtk_ddp_write(cmdq_pkt, DITHER_RELAY_MODE, &priv->cmdq_reg, priv->regs, DISP_DITHER_CFG);
-	mtk_dither_set_common(priv->regs, &priv->cmdq_reg, bpc, DISP_DITHER_CFG,
-			      DITHER_ENGINE_EN, cmdq_pkt);
+	mtk_ddp_write(cmdq_pkt, w << 16 | h, &priv->cmdq_reg, priv->regs, DISP_REG_OD_SIZE);
+	mtk_ddp_write(cmdq_pkt, OD_RELAYMODE, &priv->cmdq_reg, priv->regs, DISP_REG_OD_CFG);
+	mtk_dither_set(dev, bpc, DISP_REG_OD_CFG, cmdq_pkt);
 }
 
-static void mtk_dither_start(struct device *dev)
+static void mtk_od_start(struct device *dev)
 {
 	struct mtk_ddp_comp_dev *priv = dev_get_drvdata(dev);
 
-	writel(DITHER_EN, priv->regs + DISP_DITHER_EN);
+	writel(1, priv->regs + DISP_REG_OD_EN);
 }
 
-static void mtk_dither_stop(struct device *dev)
+static void mtk_ufoe_start(struct device *dev)
 {
 	struct mtk_ddp_comp_dev *priv = dev_get_drvdata(dev);
 
-	writel_relaxed(0x0, priv->regs + DISP_DITHER_EN);
+	writel(UFO_BYPASS, priv->regs + DISP_REG_UFO_START);
 }
 
 static const struct mtk_ddp_comp_funcs ddp_aal = {
@@ -244,9 +270,24 @@ static const struct mtk_ddp_comp_funcs ddp_dither = {
 	.stop = mtk_dither_stop,
 };
 
+static const struct mtk_ddp_comp_funcs ddp_dp_intf = {
+        .start = mtk_dpintf_start,
+        .stop = mtk_dpintf_stop,
+	.encoder_index = mtk_dpintf_encoder_index,
+};
+
 static const struct mtk_ddp_comp_funcs ddp_dpi = {
 	.start = mtk_dpi_start,
 	.stop = mtk_dpi_stop,
+	.encoder_index = mtk_dpi_encoder_index,
+};
+
+static const struct mtk_ddp_comp_funcs ddp_dsc = {
+	.clk_enable = mtk_ddp_clk_enable,
+	.clk_disable = mtk_ddp_clk_disable,
+	.config = mtk_dsc_config,
+	.start = mtk_dsc_start,
+	.stop = mtk_dsc_stop,
 };
 
 static const struct mtk_ddp_comp_funcs ddp_dsi = {
@@ -263,6 +304,14 @@ static const struct mtk_ddp_comp_funcs ddp_gamma = {
 	.stop = mtk_gamma_stop,
 };
 
+static const struct mtk_ddp_comp_funcs ddp_merge = {
+	.clk_enable = mtk_merge_clk_enable,
+	.clk_disable = mtk_merge_clk_disable,
+	.start = mtk_merge_start,
+	.stop = mtk_merge_stop,
+	.config = mtk_merge_config,
+};
+
 static const struct mtk_ddp_comp_funcs ddp_od = {
 	.clk_enable = mtk_ddp_clk_enable,
 	.clk_disable = mtk_ddp_clk_disable,
@@ -304,23 +353,40 @@ static const struct mtk_ddp_comp_funcs ddp_ufoe = {
 	.start = mtk_ufoe_start,
 };
 
+static const struct mtk_ddp_comp_funcs ddp_ovl_adaptor = {
+	.clk_enable = mtk_ovl_adaptor_clk_enable,
+	.clk_disable = mtk_ovl_adaptor_clk_disable,
+	.config = mtk_ovl_adaptor_config,
+	.start = mtk_ovl_adaptor_start,
+	.stop = mtk_ovl_adaptor_stop,
+	.layer_nr = mtk_ovl_adaptor_layer_nr,
+	.layer_config = mtk_ovl_adaptor_layer_config,
+	.enable_vblank = mtk_ovl_adaptor_enable_vblank,
+	.disable_vblank = mtk_ovl_adaptor_disable_vblank,
+};
+
 static const char * const mtk_ddp_comp_stem[MTK_DDP_COMP_TYPE_MAX] = {
+	[MTK_DISP_AAL] = "aal",
+	[MTK_DISP_BLS] = "bls",
+	[MTK_DISP_CCORR] = "ccorr",
+	[MTK_DISP_COLOR] = "color",
+	[MTK_DISP_DITHER] = "dither",
+	[MTK_DISP_DPTX] = "dptx",
+	[MTK_DISP_DSC] = "dsc",
+	[MTK_DISP_GAMMA] = "gamma",
+	[MTK_DISP_MERGE] = "merge",
+	[MTK_DISP_MUTEX] = "mutex",
+	[MTK_DISP_OD] = "od",
 	[MTK_DISP_OVL] = "ovl",
 	[MTK_DISP_OVL_2L] = "ovl-2l",
+	[MTK_DISP_OVL_ADAPTOR] = "ovl_adaptor",
+	[MTK_DISP_PWM] = "pwm",
 	[MTK_DISP_RDMA] = "rdma",
-	[MTK_DISP_WDMA] = "wdma",
-	[MTK_DISP_COLOR] = "color",
-	[MTK_DISP_CCORR] = "ccorr",
-	[MTK_DISP_AAL] = "aal",
-	[MTK_DISP_GAMMA] = "gamma",
-	[MTK_DISP_DITHER] = "dither",
 	[MTK_DISP_UFOE] = "ufoe",
-	[MTK_DSI] = "dsi",
+	[MTK_DISP_WDMA] = "wdma",
+	[MTK_DP_INTF] = "dp-intf",
 	[MTK_DPI] = "dpi",
-	[MTK_DISP_PWM] = "pwm",
-	[MTK_DISP_MUTEX] = "mutex",
-	[MTK_DISP_OD] = "od",
-	[MTK_DISP_BLS] = "bls",
+	[MTK_DSI] = "dsi",
 };
 
 struct mtk_ddp_comp_match {
@@ -337,19 +403,31 @@ static const struct mtk_ddp_comp_match mtk_ddp_matches[DDP_COMPONENT_ID_MAX] = {
 	[DDP_COMPONENT_COLOR0]	= { MTK_DISP_COLOR,	0, &ddp_color },
 	[DDP_COMPONENT_COLOR1]	= { MTK_DISP_COLOR,	1, &ddp_color },
 	[DDP_COMPONENT_DITHER]	= { MTK_DISP_DITHER,	0, &ddp_dither },
+	[DDP_COMPONENT_DP_INTF0]= { MTK_DP_INTF,	0, &ddp_dp_intf },
+	[DDP_COMPONENT_DP_INTF1]= { MTK_DP_INTF,	1, &ddp_dp_intf },
 	[DDP_COMPONENT_DPI0]	= { MTK_DPI,		0, &ddp_dpi },
 	[DDP_COMPONENT_DPI1]	= { MTK_DPI,		1, &ddp_dpi },
+	[DDP_COMPONENT_DPTX]	= { MTK_DISP_DPTX,	0, NULL },
+	[DDP_COMPONENT_DSC0]	= { MTK_DISP_DSC,	0, &ddp_dsc },
+	[DDP_COMPONENT_DSC1]	= { MTK_DISP_DSC,	1, &ddp_dsc },
 	[DDP_COMPONENT_DSI0]	= { MTK_DSI,		0, &ddp_dsi },
 	[DDP_COMPONENT_DSI1]	= { MTK_DSI,		1, &ddp_dsi },
 	[DDP_COMPONENT_DSI2]	= { MTK_DSI,		2, &ddp_dsi },
 	[DDP_COMPONENT_DSI3]	= { MTK_DSI,		3, &ddp_dsi },
 	[DDP_COMPONENT_GAMMA]	= { MTK_DISP_GAMMA,	0, &ddp_gamma },
+	[DDP_COMPONENT_MERGE0]	= { MTK_DISP_MERGE,	0, &ddp_merge },
+	[DDP_COMPONENT_MERGE1]	= { MTK_DISP_MERGE,	1, &ddp_merge },
+	[DDP_COMPONENT_MERGE2]	= { MTK_DISP_MERGE,	2, &ddp_merge },
+	[DDP_COMPONENT_MERGE3]	= { MTK_DISP_MERGE,	3, &ddp_merge },
+	[DDP_COMPONENT_MERGE4]	= { MTK_DISP_MERGE,	4, &ddp_merge },
+	[DDP_COMPONENT_MERGE5]	= { MTK_DISP_MERGE,	5, &ddp_merge },
 	[DDP_COMPONENT_OD0]	= { MTK_DISP_OD,	0, &ddp_od },
 	[DDP_COMPONENT_OD1]	= { MTK_DISP_OD,	1, &ddp_od },
 	[DDP_COMPONENT_OVL0]	= { MTK_DISP_OVL,	0, &ddp_ovl },
 	[DDP_COMPONENT_OVL1]	= { MTK_DISP_OVL,	1, &ddp_ovl },
 	[DDP_COMPONENT_OVL_2L0]	= { MTK_DISP_OVL_2L,	0, &ddp_ovl },
 	[DDP_COMPONENT_OVL_2L1]	= { MTK_DISP_OVL_2L,	1, &ddp_ovl },
+	[DDP_COMPONENT_OVL_ADAPTOR] = { MTK_DISP_OVL_ADAPTOR,	0, &ddp_ovl_adaptor },
 	[DDP_COMPONENT_PWM0]	= { MTK_DISP_PWM,	0, NULL },
 	[DDP_COMPONENT_PWM1]	= { MTK_DISP_PWM,	1, NULL },
 	[DDP_COMPONENT_PWM2]	= { MTK_DISP_PWM,	2, NULL },
@@ -378,6 +456,24 @@ static bool mtk_drm_find_comp_in_ddp(struct device *dev,
 	return false;
 }
 
+static bool mtk_drm_find_comp_in_ddp_conn_path(struct device *dev,
+				     const struct mtk_drm_route *routes,
+				     unsigned int routes_num,
+				     struct mtk_ddp_comp *ddp_comp)
+{
+	unsigned int i;
+	bool ret = false;
+
+	if (routes == NULL)
+		return false;
+
+	for (i = 0U; i < routes_num; i++)
+		ret |= mtk_drm_find_comp_in_ddp(dev, routes[i].route_ddp,
+			routes[i].route_len, ddp_comp);
+
+	return ret;
+}
+
 int mtk_ddp_comp_get_id(struct device_node *node,
 			enum mtk_ddp_comp_type comp_type)
 {
@@ -405,6 +501,10 @@ unsigned int mtk_drm_find_possible_crtc_by_comp(struct drm_device *drm,
 	else if (mtk_drm_find_comp_in_ddp(dev, private->data->ext_path,
 					  private->data->ext_len, private->ddp_comp))
 		ret = BIT(1);
+	else if (mtk_drm_find_comp_in_ddp_conn_path(dev,
+					  private->data->ext_conn_routes,
+					  private->data->ext_conn_routes_num, private->ddp_comp))
+		ret = BIT(1);
 	else if (mtk_drm_find_comp_in_ddp(dev, private->data->third_path,
 					  private->data->third_len, private->ddp_comp))
 		ret = BIT(2);
@@ -439,13 +539,17 @@ int mtk_ddp_comp_init(struct device_node *node, struct mtk_ddp_comp *comp,
 	    type == MTK_DISP_BLS ||
 	    type == MTK_DISP_CCORR ||
 	    type == MTK_DISP_COLOR ||
+            type == MTK_DISP_DPTX ||
 	    type == MTK_DISP_GAMMA ||
-	    type == MTK_DPI ||
-	    type == MTK_DSI ||
+	    type == MTK_DISP_MERGE ||
 	    type == MTK_DISP_OVL ||
 	    type == MTK_DISP_OVL_2L ||
+	    type == MTK_DISP_OVL_ADAPTOR ||
 	    type == MTK_DISP_PWM ||
-	    type == MTK_DISP_RDMA)
+	    type == MTK_DISP_RDMA ||
+	    type == MTK_DP_INTF ||
+	    type == MTK_DPI ||
+	    type == MTK_DSI)
 		return 0;
 
 	priv = devm_kzalloc(comp->dev, sizeof(*priv), GFP_KERNEL);
diff --git a/drivers/gpu/drm/mediatek/mtk_drm_ddp_comp.h b/drivers/gpu/drm/mediatek/mtk_drm_ddp_comp.h
index 1b582262b682b19cbff28a626943939512531293..38fd27a85d7a400712357f4c6516da46c6c7f263 100644
--- a/drivers/gpu/drm/mediatek/mtk_drm_ddp_comp.h
+++ b/drivers/gpu/drm/mediatek/mtk_drm_ddp_comp.h
@@ -18,22 +18,27 @@ struct mtk_plane_state;
 struct drm_crtc_state;
 
 enum mtk_ddp_comp_type {
-	MTK_DISP_OVL,
-	MTK_DISP_OVL_2L,
-	MTK_DISP_RDMA,
-	MTK_DISP_WDMA,
-	MTK_DISP_COLOR,
+	MTK_DISP_AAL,
+	MTK_DISP_BLS,
 	MTK_DISP_CCORR,
+	MTK_DISP_COLOR,
 	MTK_DISP_DITHER,
-	MTK_DISP_AAL,
+	MTK_DISP_DSC,
+	MTK_DISP_DPTX,
 	MTK_DISP_GAMMA,
-	MTK_DISP_UFOE,
-	MTK_DSI,
-	MTK_DPI,
-	MTK_DISP_PWM,
+	MTK_DISP_MERGE,
 	MTK_DISP_MUTEX,
 	MTK_DISP_OD,
-	MTK_DISP_BLS,
+	MTK_DISP_OVL,
+	MTK_DISP_OVL_2L,
+	MTK_DISP_OVL_ADAPTOR,
+	MTK_DISP_PWM,
+	MTK_DISP_RDMA,
+	MTK_DISP_UFOE,
+	MTK_DISP_WDMA,
+	MTK_DP_INTF,
+	MTK_DPI,
+	MTK_DSI,
 	MTK_DDP_COMP_TYPE_MAX,
 };
 
@@ -65,6 +70,7 @@ struct mtk_ddp_comp_funcs {
 	void (*bgclr_in_off)(struct device *dev);
 	void (*ctm_set)(struct device *dev,
 			struct drm_crtc_state *state);
+	int (*encoder_index)(struct device *dev);
 };
 
 struct mtk_ddp_comp {
@@ -72,6 +78,7 @@ struct mtk_ddp_comp {
 	int irq;
 	enum mtk_ddp_comp_id id;
 	const struct mtk_ddp_comp_funcs *funcs;
+	int encoder_index;
 };
 
 static inline int mtk_ddp_comp_clk_enable(struct mtk_ddp_comp *comp)
@@ -184,6 +191,12 @@ static inline void mtk_ddp_ctm_set(struct mtk_ddp_comp *comp,
 		comp->funcs->ctm_set(comp->dev, state);
 }
 
+static inline void mtk_ddp_comp_encoder_index_set(struct mtk_ddp_comp *comp)
+{
+	if (comp->funcs && comp->funcs->encoder_index)
+		comp->encoder_index = comp->funcs->encoder_index(comp->dev);
+}
+
 int mtk_ddp_comp_get_id(struct device_node *node,
 			enum mtk_ddp_comp_type comp_type);
 unsigned int mtk_drm_find_possible_crtc_by_comp(struct drm_device *drm,
diff --git a/drivers/gpu/drm/mediatek/mtk_drm_drv.c b/drivers/gpu/drm/mediatek/mtk_drm_drv.c
index c0e56a89951832985efcb335fec2322db59d9db4..be47a581cb9bddc07a3990c6ae8657f8335253d2 100644
--- a/drivers/gpu/drm/mediatek/mtk_drm_drv.c
+++ b/drivers/gpu/drm/mediatek/mtk_drm_drv.c
@@ -149,12 +149,45 @@ static const enum mtk_ddp_comp_id mt8183_mtk_ddp_ext[] = {
 	DDP_COMPONENT_DPI0,
 };
 
+static const enum mtk_ddp_comp_id mt8195_mtk_ddp_main[] = {
+	DDP_COMPONENT_OVL0,
+	DDP_COMPONENT_RDMA0,
+	DDP_COMPONENT_COLOR0,
+	DDP_COMPONENT_CCORR,
+	DDP_COMPONENT_AAL0,
+	DDP_COMPONENT_GAMMA,
+	DDP_COMPONENT_DITHER,
+	DDP_COMPONENT_DSC0,
+	DDP_COMPONENT_MERGE0,
+	DDP_COMPONENT_DP_INTF0,
+};
+
+static const enum mtk_ddp_comp_id mt8195_mtk_ddp_ext[] = {
+	DDP_COMPONENT_OVL_ADAPTOR,
+	DDP_COMPONENT_MERGE5,
+};
+
+static const enum mtk_ddp_comp_id mt8195_mtk_ddp_ext_routes_0[] = {
+	DDP_COMPONENT_DP_INTF1
+};
+
+static const enum mtk_ddp_comp_id mt8195_mtk_ddp_ext_routes_1[] = {
+	DDP_COMPONENT_DPI1
+};
+
+static const struct mtk_drm_route mt8195_mtk_ddp_ext_routes[] = {
+	{ARRAY_SIZE(mt8195_mtk_ddp_ext_routes_0), mt8195_mtk_ddp_ext_routes_0},
+	{ARRAY_SIZE(mt8195_mtk_ddp_ext_routes_1), mt8195_mtk_ddp_ext_routes_1}
+};
+
 static const struct mtk_mmsys_driver_data mt2701_mmsys_driver_data = {
 	.main_path = mt2701_mtk_ddp_main,
 	.main_len = ARRAY_SIZE(mt2701_mtk_ddp_main),
 	.ext_path = mt2701_mtk_ddp_ext,
 	.ext_len = ARRAY_SIZE(mt2701_mtk_ddp_ext),
 	.shadow_register = true,
+	.mmsys_id = 0,
+	.mmsys_dev_num = 1,
 };
 
 static const struct mtk_mmsys_driver_data mt7623_mmsys_driver_data = {
@@ -163,6 +196,8 @@ static const struct mtk_mmsys_driver_data mt7623_mmsys_driver_data = {
 	.ext_path = mt7623_mtk_ddp_ext,
 	.ext_len = ARRAY_SIZE(mt7623_mtk_ddp_ext),
 	.shadow_register = true,
+	.mmsys_id = 0,
+	.mmsys_dev_num = 1,
 };
 
 static const struct mtk_mmsys_driver_data mt2712_mmsys_driver_data = {
@@ -172,6 +207,8 @@ static const struct mtk_mmsys_driver_data mt2712_mmsys_driver_data = {
 	.ext_len = ARRAY_SIZE(mt2712_mtk_ddp_ext),
 	.third_path = mt2712_mtk_ddp_third,
 	.third_len = ARRAY_SIZE(mt2712_mtk_ddp_third),
+	.mmsys_id = 0,
+	.mmsys_dev_num = 1,
 };
 
 static const struct mtk_mmsys_driver_data mt8173_mmsys_driver_data = {
@@ -179,6 +216,8 @@ static const struct mtk_mmsys_driver_data mt8173_mmsys_driver_data = {
 	.main_len = ARRAY_SIZE(mt8173_mtk_ddp_main),
 	.ext_path = mt8173_mtk_ddp_ext,
 	.ext_len = ARRAY_SIZE(mt8173_mtk_ddp_ext),
+	.mmsys_id = 0,
+	.mmsys_dev_num = 1,
 };
 
 static const struct mtk_mmsys_driver_data mt8183_mmsys_driver_data = {
@@ -186,27 +225,237 @@ static const struct mtk_mmsys_driver_data mt8183_mmsys_driver_data = {
 	.main_len = ARRAY_SIZE(mt8183_mtk_ddp_main),
 	.ext_path = mt8183_mtk_ddp_ext,
 	.ext_len = ARRAY_SIZE(mt8183_mtk_ddp_ext),
+	.mmsys_id = 0,
+	.mmsys_dev_num = 1,
+};
+
+static const struct mtk_mmsys_driver_data mt8195_vdosys0_driver_data = {
+	.main_path = mt8195_mtk_ddp_main,
+	.main_len = ARRAY_SIZE(mt8195_mtk_ddp_main),
+	.mmsys_id = 0,
+	.mmsys_dev_num = 2,
+};
+
+static const struct mtk_mmsys_driver_data mt8195_vdosys1_driver_data = {
+	.ext_path = mt8195_mtk_ddp_ext,
+	.ext_len = ARRAY_SIZE(mt8195_mtk_ddp_ext),
+	.mmsys_id = 1,
+	.mmsys_dev_num = 2,
+	.ext_conn_routes = mt8195_mtk_ddp_ext_routes,
+	.ext_conn_routes_num = ARRAY_SIZE(mt8195_mtk_ddp_ext_routes),
+};
+
+static const struct of_device_id mtk_drm_of_ids[] = {
+	{ .compatible = "mediatek,mt2701-mmsys",
+	  .data = &mt2701_mmsys_driver_data},
+	{ .compatible = "mediatek,mt7623-mmsys",
+	  .data = &mt7623_mmsys_driver_data},
+	{ .compatible = "mediatek,mt2712-mmsys",
+	  .data = &mt2712_mmsys_driver_data},
+	{ .compatible = "mediatek,mt8173-mmsys",
+	  .data = &mt8173_mmsys_driver_data},
+	{ .compatible = "mediatek,mt8183-mmsys",
+	  .data = &mt8183_mmsys_driver_data},
+	{ .compatible = "mediatek,mt8195-vdosys0",
+	  .data = &mt8195_vdosys0_driver_data},
+	{ .compatible = "mediatek,mt8195-vdosys1",
+	  .data = &mt8195_vdosys1_driver_data},
+	{ }
 };
+MODULE_DEVICE_TABLE(of, mtk_drm_of_ids);
+
+static int mtk_drm_match(struct device *dev, void *data)
+{
+	if (!strncmp(dev_name(dev), "mediatek-drm", sizeof("mediatek-drm") - 1))
+		return true;
+	return false;
+}
+
+static int mtk_drm_get_drm_priv(struct device *dev,
+				struct mtk_drm_private **all_drm_priv,
+				int num)
+{
+	struct device_node *phandle = dev->parent->of_node;
+	const struct of_device_id *of_id;
+	struct device_node *node;
+	int cnt = 0;
+	struct device *drm_dev;
+
+	for_each_child_of_node(phandle->parent, node) {
+		struct platform_device *pdev;
+
+		of_id = of_match_node(mtk_drm_of_ids, node);
+		if (!of_id)
+			continue;
+
+		pdev = of_find_device_by_node(node);
+		if (!pdev)
+			continue;
+
+		drm_dev = device_find_child(&pdev->dev, NULL, mtk_drm_match);
+		if (!drm_dev || !dev_get_drvdata(drm_dev))
+			continue;
+
+		all_drm_priv[cnt++] = dev_get_drvdata(drm_dev);
+		if (cnt == num)
+			break;
+	}
+
+	return 0;
+}
+
+static bool mtk_drm_check_last_drm_bind(struct device *dev)
+{
+	struct mtk_drm_private *drm_priv = dev_get_drvdata(dev);
+	struct mtk_drm_private *all_drm_priv[MAX_CRTC];
+	int cnt = 0;
+	int i;
+
+	mtk_drm_get_drm_priv(dev, all_drm_priv, drm_priv->data->mmsys_dev_num);
+
+	for (i = 0; i < MAX_CRTC; i++)
+		if (all_drm_priv[i] && all_drm_priv[i]->mtk_drm_bound)
+			cnt++;
+
+	return (drm_priv->data->mmsys_dev_num == cnt);
+}
+
+static bool mtk_drm_find_drm_dev(struct device *dev, struct drm_device **drm)
+{
+	struct mtk_drm_private *drm_priv = dev_get_drvdata(dev);
+	struct mtk_drm_private *all_drm_priv[MAX_CRTC];
+	int i;
+
+	if (!drm_priv->data->mmsys_dev_num)
+		return false;
+
+	mtk_drm_get_drm_priv(dev, all_drm_priv, drm_priv->data->mmsys_dev_num);
+
+	for (i = 0; i < MAX_CRTC; i++) {
+		if (all_drm_priv[i] && all_drm_priv[i]->mtk_drm_bound) {
+			*drm = all_drm_priv[i]->drm;
+			return true;
+		}
+	}
+
+	return false;
+}
+
+static int mtk_drm_setup_all_drm_private(struct device *dev)
+{
+	struct mtk_drm_private *drm_priv = dev_get_drvdata(dev);
+	struct mtk_drm_private *all_drm_priv[MAX_CRTC];
+	int mmsys_dev_num = drm_priv->data->mmsys_dev_num;
+	int i;
+	int j;
+
+	mtk_drm_get_drm_priv(dev, all_drm_priv, mmsys_dev_num);
+
+	for (i = 0; i < mmsys_dev_num; i++)
+		for (j = 0; j < mmsys_dev_num; j++)
+			all_drm_priv[j]->all_drm_private[i] = all_drm_priv[i];
+
+	return 0;
+}
+
+static bool mtk_drm_find_mmsys_comp(struct mtk_drm_private *private, int comp_id)
+{
+	const struct mtk_mmsys_driver_data *drv_data = private->data;
+	int ret = false;
+	int i;
+	int j;
+
+	if (drv_data->mmsys_dev_num == 1)
+		return true;
+
+	if (drv_data->main_path) {
+		for (i = 0; i < drv_data->main_len; i++)
+			if (drv_data->main_path[i] == comp_id)
+				ret |= true;
+
+		if (i == drv_data->main_len)
+			ret |= false;
+	}
+
+	if (drv_data->ext_path) {
+		for (i = 0; i < drv_data->ext_len; i++)
+			if (drv_data->ext_path[i] == comp_id)
+				ret |= true;
+
+		if (i == drv_data->ext_len)
+			ret |= false;
+	}
+
+	if (drv_data->ext_conn_routes_num) {
+		for (i = 0; i < drv_data->ext_conn_routes_num; i++) {
+			for (j = 0; j < drv_data->ext_conn_routes[i].route_len; j++)
+				if (drv_data->ext_conn_routes[i].route_ddp[j] == comp_id)
+					ret |= true;
+		}
+		if (i == drv_data->ext_conn_routes_num)
+			ret |= false;
+	}
+
+	if (drv_data->third_path) {
+		for (i = 0; i < drv_data->third_len; i++)
+			if (drv_data->third_path[i] == comp_id)
+				ret |= true;
+
+		if (i == drv_data->third_len)
+			ret |= false;
+	}
+
+	return ret;
+}
+
+static int mtk_drm_check_mutex_dev(struct mtk_drm_private *private)
+{
+	struct platform_device *pdev;
+	struct mtk_drm_private *priv_i;
+	int ret;
+	int i;
+
+	for (i = 0; i < private->data->mmsys_dev_num; i++) {
+		priv_i = private->all_drm_private[i];
+
+		pdev = of_find_device_by_node(priv_i->mutex_node);
+		if (!pdev) {
+			dev_err(priv_i->dev, "Waiting for disp-mutex device %pOF\n",
+				priv_i->mutex_node);
+			ret = -EPROBE_DEFER;
+			goto err_put_mutex;
+		}
+		priv_i->mutex_dev = &pdev->dev;
+	}
+
+	return 0;
+
+err_put_mutex:
+	for (i = 0; i < private->data->mmsys_dev_num; i++) {
+		priv_i = private->all_drm_private[i];
+		of_node_put(priv_i->mutex_node);
+	}
+
+	return ret;
+}
 
 static int mtk_drm_kms_init(struct drm_device *drm)
 {
 	struct mtk_drm_private *private = drm->dev_private;
+	struct mtk_drm_private *priv_n;
 	struct platform_device *pdev;
-	struct device_node *np;
+	struct device_node *np = NULL;
 	struct device *dma_dev;
 	int ret;
+	int i;
+	int j;
 
 	if (!iommu_present(&platform_bus_type))
 		return -EPROBE_DEFER;
 
-	pdev = of_find_device_by_node(private->mutex_node);
-	if (!pdev) {
-		dev_err(drm->dev, "Waiting for disp-mutex device %pOF\n",
-			private->mutex_node);
-		of_node_put(private->mutex_node);
-		return -EPROBE_DEFER;
-	}
-	private->mutex_dev = &pdev->dev;
+	ret = mtk_drm_check_mutex_dev(private);
+	if (ret)
+		return ret;
 
 	ret = drmm_mode_config_init(drm);
 	if (ret)
@@ -225,33 +474,59 @@ static int mtk_drm_kms_init(struct drm_device *drm)
 	drm->mode_config.funcs = &mtk_drm_mode_config_funcs;
 	drm->mode_config.helper_private = &mtk_drm_mode_config_helpers;
 
-	ret = component_bind_all(drm->dev, drm);
-	if (ret)
-		goto put_mutex_dev;
+	for (i = 0; i < private->data->mmsys_dev_num; i++) {
+		drm->dev_private = private->all_drm_private[i];
+		ret = component_bind_all(private->all_drm_private[i]->dev, drm);
+		if (ret)
+			goto put_mutex_dev;
+	}
 
 	/*
 	 * We currently support two fixed data streams, each optional,
 	 * and each statically assigned to a crtc:
 	 * OVL0 -> COLOR0 -> AAL -> OD -> RDMA0 -> UFOE -> DSI0 ...
 	 */
-	ret = mtk_drm_crtc_create(drm, private->data->main_path,
-				  private->data->main_len);
-	if (ret < 0)
-		goto err_component_unbind;
-	/* ... and OVL1 -> COLOR1 -> GAMMA -> RDMA1 -> DPI0. */
-	ret = mtk_drm_crtc_create(drm, private->data->ext_path,
-				  private->data->ext_len);
-	if (ret < 0)
-		goto err_component_unbind;
-
-	ret = mtk_drm_crtc_create(drm, private->data->third_path,
-				  private->data->third_len);
-	if (ret < 0)
-		goto err_component_unbind;
+	for (i = 0; i < MAX_CRTC; i++) {
+		for (j = 0; j < private->data->mmsys_dev_num; j++) {
+			priv_n = private->all_drm_private[j];
+
+			if (i == 0 && priv_n->data->main_len) {
+				ret = mtk_drm_crtc_create(drm, priv_n->data->main_path,
+							  priv_n->data->main_len, j, NULL, 0);
+				if (ret)
+					goto err_component_unbind;
+
+				if (!np)
+					np = priv_n->comp_node[priv_n->data->main_path[0]];
+
+				continue;
+			} else if (i == 1 && priv_n->data->ext_len) {
+				ret = mtk_drm_crtc_create(drm, priv_n->data->ext_path,
+							  priv_n->data->ext_len, j,
+							  priv_n->data->ext_conn_routes,
+							  priv_n->data->ext_conn_routes_num);
+				if (ret)
+					goto err_component_unbind;
+
+				if (!np)
+					np = priv_n->comp_node[priv_n->data->ext_path[0]];
+
+				continue;
+			} else if (i == 2 && priv_n->data->third_len) {
+				ret = mtk_drm_crtc_create(drm, priv_n->data->third_path,
+							  priv_n->data->third_len, j, NULL, 0);
+				if (ret)
+					goto err_component_unbind;
+
+				if (!np)
+					np = priv_n->comp_node[priv_n->data->third_path[0]];
+
+				continue;
+			}
+		}
+	}
 
 	/* Use OVL device for all DMA memory allocations */
-	np = private->comp_node[private->data->main_path[0]] ?:
-	     private->comp_node[private->data->ext_path[0]];
 	pdev = of_find_device_by_node(np);
 	if (!pdev) {
 		ret = -ENODEV;
@@ -260,7 +535,8 @@ static int mtk_drm_kms_init(struct drm_device *drm)
 	}
 
 	dma_dev = &pdev->dev;
-	private->dma_dev = dma_dev;
+	for (i = 0; i < private->data->mmsys_dev_num; i++)
+		private->all_drm_private[i]->dma_dev = dma_dev;
 
 	/*
 	 * Configure the DMA segment size to make sure we get contiguous IOVA
@@ -288,9 +564,12 @@ static int mtk_drm_kms_init(struct drm_device *drm)
 	return 0;
 
 err_component_unbind:
-	component_unbind_all(drm->dev, drm);
+	for (i = 0; i < private->data->mmsys_dev_num; i++)
+		component_unbind_all(private->all_drm_private[i]->dev, drm);
 put_mutex_dev:
-	put_device(private->mutex_dev);
+	for (i = 0; i < private->data->mmsys_dev_num; i++)
+		put_device(private->all_drm_private[i]->mutex_dev);
+
 	return ret;
 }
 
@@ -368,12 +647,22 @@ static int mtk_drm_bind(struct device *dev)
 	struct drm_device *drm;
 	int ret;
 
-	drm = drm_dev_alloc(&mtk_drm_driver, dev);
-	if (IS_ERR(drm))
-		return PTR_ERR(drm);
+	if (!mtk_drm_find_drm_dev(dev, &drm)) {
+		drm = drm_dev_alloc(&mtk_drm_driver, dev);
+		if (IS_ERR(drm))
+			return PTR_ERR(drm);
+		private->drm_master = true;
+		drm->dev_private = private;
+	}
 
-	drm->dev_private = private;
+	private->dev = dev;
 	private->drm = drm;
+	private->mtk_drm_bound = true;
+
+	if (!mtk_drm_check_last_drm_bind(dev))
+		return 0;
+
+	mtk_drm_setup_all_drm_private(dev);
 
 	ret = mtk_drm_kms_init(drm);
 	if (ret < 0)
@@ -398,10 +687,13 @@ static void mtk_drm_unbind(struct device *dev)
 {
 	struct mtk_drm_private *private = dev_get_drvdata(dev);
 
-	drm_dev_unregister(private->drm);
-	mtk_drm_kms_deinit(private->drm);
-	drm_dev_put(private->drm);
-	private->num_pipes = 0;
+	/* for multi mmsys dev, unregister drm dev in mmsys master */
+	if (private->data->mmsys_id == 0) {
+		drm_dev_unregister(private->drm);
+		mtk_drm_kms_deinit(private->drm);
+		drm_dev_put(private->drm);
+	}
+	private->mtk_drm_bound = false;
 	private->drm = NULL;
 }
 
@@ -411,52 +703,26 @@ static const struct component_master_ops mtk_drm_ops = {
 };
 
 static const struct of_device_id mtk_ddp_comp_dt_ids[] = {
-	{ .compatible = "mediatek,mt2701-disp-ovl",
-	  .data = (void *)MTK_DISP_OVL },
-	{ .compatible = "mediatek,mt8173-disp-ovl",
-	  .data = (void *)MTK_DISP_OVL },
-	{ .compatible = "mediatek,mt8183-disp-ovl",
-	  .data = (void *)MTK_DISP_OVL },
-	{ .compatible = "mediatek,mt8183-disp-ovl-2l",
-	  .data = (void *)MTK_DISP_OVL_2L },
-	{ .compatible = "mediatek,mt2701-disp-rdma",
-	  .data = (void *)MTK_DISP_RDMA },
-	{ .compatible = "mediatek,mt8173-disp-rdma",
-	  .data = (void *)MTK_DISP_RDMA },
-	{ .compatible = "mediatek,mt8183-disp-rdma",
-	  .data = (void *)MTK_DISP_RDMA },
-	{ .compatible = "mediatek,mt8173-disp-wdma",
-	  .data = (void *)MTK_DISP_WDMA },
+	{ .compatible = "mediatek,mt8173-disp-aal",
+	  .data = (void *)MTK_DISP_AAL},
 	{ .compatible = "mediatek,mt8183-disp-ccorr",
 	  .data = (void *)MTK_DISP_CCORR },
+	{ .compatible = "mediatek,mt8195-disp-ccorr",
+	  .data = (void *)MTK_DISP_CCORR },
 	{ .compatible = "mediatek,mt2701-disp-color",
 	  .data = (void *)MTK_DISP_COLOR },
 	{ .compatible = "mediatek,mt8173-disp-color",
 	  .data = (void *)MTK_DISP_COLOR },
-	{ .compatible = "mediatek,mt8173-disp-aal",
-	  .data = (void *)MTK_DISP_AAL},
-	{ .compatible = "mediatek,mt8183-disp-aal",
-	  .data = (void *)MTK_DISP_AAL},
+	{ .compatible = "mediatek,mt8183-disp-dither",
+	  .data = (void *)MTK_DISP_DITHER },
+	{ .compatible = "mediatek,mt8195-disp-dsc",
+	  .data = (void *)MTK_DISP_DSC },
 	{ .compatible = "mediatek,mt8173-disp-gamma",
 	  .data = (void *)MTK_DISP_GAMMA, },
 	{ .compatible = "mediatek,mt8183-disp-gamma",
 	  .data = (void *)MTK_DISP_GAMMA, },
-	{ .compatible = "mediatek,mt8183-disp-dither",
-	  .data = (void *)MTK_DISP_DITHER },
-	{ .compatible = "mediatek,mt8173-disp-ufoe",
-	  .data = (void *)MTK_DISP_UFOE },
-	{ .compatible = "mediatek,mt2701-dsi",
-	  .data = (void *)MTK_DSI },
-	{ .compatible = "mediatek,mt8173-dsi",
-	  .data = (void *)MTK_DSI },
-	{ .compatible = "mediatek,mt8183-dsi",
-	  .data = (void *)MTK_DSI },
-	{ .compatible = "mediatek,mt2701-dpi",
-	  .data = (void *)MTK_DPI },
-	{ .compatible = "mediatek,mt8173-dpi",
-	  .data = (void *)MTK_DPI },
-	{ .compatible = "mediatek,mt8183-dpi",
-	  .data = (void *)MTK_DPI },
+	{ .compatible = "mediatek,mt8195-disp-merge",
+	  .data = (void *)MTK_DISP_MERGE },
 	{ .compatible = "mediatek,mt2701-disp-mutex",
 	  .data = (void *)MTK_DISP_MUTEX },
 	{ .compatible = "mediatek,mt2712-disp-mutex",
@@ -465,57 +731,89 @@ static const struct of_device_id mtk_ddp_comp_dt_ids[] = {
 	  .data = (void *)MTK_DISP_MUTEX },
 	{ .compatible = "mediatek,mt8183-disp-mutex",
 	  .data = (void *)MTK_DISP_MUTEX },
+	{ .compatible = "mediatek,mt8195-disp-mutex",
+	  .data = (void *)MTK_DISP_MUTEX },
+	{ .compatible = "mediatek,mt8173-disp-od",
+	  .data = (void *)MTK_DISP_OD },
+	{ .compatible = "mediatek,mt2701-disp-ovl",
+	  .data = (void *)MTK_DISP_OVL },
+	{ .compatible = "mediatek,mt8173-disp-ovl",
+	  .data = (void *)MTK_DISP_OVL },
+	{ .compatible = "mediatek,mt8183-disp-ovl",
+	  .data = (void *)MTK_DISP_OVL },
+	{ .compatible = "mediatek,mt8183-disp-ovl-2l",
+	  .data = (void *)MTK_DISP_OVL_2L },
+	{ .compatible = "mediatek,mt8195-disp-ethdr",
+	  .data = (void *)MTK_DISP_OVL_ADAPTOR },
 	{ .compatible = "mediatek,mt2701-disp-pwm",
 	  .data = (void *)MTK_DISP_BLS },
 	{ .compatible = "mediatek,mt8173-disp-pwm",
 	  .data = (void *)MTK_DISP_PWM },
-	{ .compatible = "mediatek,mt8173-disp-od",
-	  .data = (void *)MTK_DISP_OD },
-	{ }
-};
-
-static const struct of_device_id mtk_drm_of_ids[] = {
-	{ .compatible = "mediatek,mt2701-mmsys",
-	  .data = &mt2701_mmsys_driver_data},
-	{ .compatible = "mediatek,mt7623-mmsys",
-	  .data = &mt7623_mmsys_driver_data},
-	{ .compatible = "mediatek,mt2712-mmsys",
-	  .data = &mt2712_mmsys_driver_data},
-	{ .compatible = "mediatek,mt8173-mmsys",
-	  .data = &mt8173_mmsys_driver_data},
-	{ .compatible = "mediatek,mt8183-mmsys",
-	  .data = &mt8183_mmsys_driver_data},
+	{ .compatible = "mediatek,mt2701-disp-rdma",
+	  .data = (void *)MTK_DISP_RDMA },
+	{ .compatible = "mediatek,mt8173-disp-rdma",
+	  .data = (void *)MTK_DISP_RDMA },
+	{ .compatible = "mediatek,mt8183-disp-rdma",
+	  .data = (void *)MTK_DISP_RDMA },
+	{ .compatible = "mediatek,mt8195-disp-rdma",
+	  .data = (void *)MTK_DISP_RDMA },
+	{ .compatible = "mediatek,mt8173-disp-ufoe",
+	  .data = (void *)MTK_DISP_UFOE },
+	{ .compatible = "mediatek,mt8173-disp-wdma",
+	  .data = (void *)MTK_DISP_WDMA },
+	{ .compatible = "mediatek,mt2701-dpi",
+	  .data = (void *)MTK_DPI },
+	{ .compatible = "mediatek,mt8173-dpi",
+	  .data = (void *)MTK_DPI },
+	{ .compatible = "mediatek,mt8183-dpi",
+	  .data = (void *)MTK_DPI },
+	{ .compatible = "mediatek,mt8195-dpi",
+          .data = (void *)MTK_DPI },
+	{ .compatible = "mediatek,mt8195-dpintf",
+          .data = (void *)MTK_DP_INTF },
+	{ .compatible = "mediatek,mt2701-dsi",
+	  .data = (void *)MTK_DSI },
+	{ .compatible = "mediatek,mt8173-dsi",
+	  .data = (void *)MTK_DSI },
+	{ .compatible = "mediatek,mt8183-dsi",
+	  .data = (void *)MTK_DSI },
 	{ }
 };
-MODULE_DEVICE_TABLE(of, mtk_drm_of_ids);
 
 static int mtk_drm_probe(struct platform_device *pdev)
 {
 	struct device *dev = &pdev->dev;
 	struct device_node *phandle = dev->parent->of_node;
 	const struct of_device_id *of_id;
+	const struct mtk_mmsys_driver_data *drv_data;
 	struct mtk_drm_private *private;
 	struct device_node *node;
 	struct component_match *match = NULL;
 	int ret;
 	int i;
 
+	of_id = of_match_node(mtk_drm_of_ids, phandle);
+	if (!of_id)
+		return -ENODEV;
+
+	drv_data = of_id->data;
 	private = devm_kzalloc(dev, sizeof(*private), GFP_KERNEL);
 	if (!private)
 		return -ENOMEM;
 
+	private->all_drm_private = devm_kmalloc_array(dev, drv_data->mmsys_dev_num,
+						      sizeof(*private->all_drm_private),
+						      GFP_KERNEL);
+	if (!private->all_drm_private)
+		return -ENOMEM;
+
+	private->data = drv_data;
 	private->mmsys_dev = dev->parent;
 	if (!private->mmsys_dev) {
 		dev_err(dev, "Failed to get MMSYS device\n");
 		return -ENODEV;
 	}
 
-	of_id = of_match_node(mtk_drm_of_ids, phandle);
-	if (!of_id)
-		return -ENODEV;
-
-	private->data = of_id->data;
-
 	/* Iterate over sibling DISP function blocks */
 	for_each_child_of_node(phandle->parent, node) {
 		const struct of_device_id *of_id;
@@ -535,7 +833,13 @@ static int mtk_drm_probe(struct platform_device *pdev)
 		comp_type = (enum mtk_ddp_comp_type)of_id->data;
 
 		if (comp_type == MTK_DISP_MUTEX) {
-			private->mutex_node = of_node_get(node);
+			int id;
+
+			id = of_alias_get_id(node, "mutex");
+			if (id < 0 || id == drv_data->mmsys_id) {
+				private->mutex_node = of_node_get(node);
+				dev_dbg(dev, "get mutex for mmsys %d", drv_data->mmsys_id);
+			}
 			continue;
 		}
 
@@ -546,22 +850,29 @@ static int mtk_drm_probe(struct platform_device *pdev)
 			continue;
 		}
 
+		if (!mtk_drm_find_mmsys_comp(private, comp_id))
+			continue;
+
 		private->comp_node[comp_id] = of_node_get(node);
 
 		/*
-		 * Currently only the AAL, CCORR, COLOR, GAMMA, OVL, RDMA, DSI, and DPI
+		 * Currently only the AAL, CCORR, COLOR, GAMMA, MERGE, OVL, RDMA, DSI, and DPI
 		 * blocks have separate component platform drivers and initialize their own
 		 * DDP component structure. The others are initialized here.
 		 */
 		if (comp_type == MTK_DISP_AAL ||
 		    comp_type == MTK_DISP_CCORR ||
 		    comp_type == MTK_DISP_COLOR ||
+		    comp_type == MTK_DISP_DPTX ||
 		    comp_type == MTK_DISP_GAMMA ||
+		    comp_type == MTK_DISP_MERGE ||
 		    comp_type == MTK_DISP_OVL ||
 		    comp_type == MTK_DISP_OVL_2L ||
+		    comp_type == MTK_DISP_OVL_ADAPTOR ||
 		    comp_type == MTK_DISP_RDMA ||
-		    comp_type == MTK_DSI ||
-		    comp_type == MTK_DPI) {
+		    comp_type == MTK_DP_INTF ||
+		    comp_type == MTK_DPI ||
+		    comp_type == MTK_DSI) {
 			dev_info(dev, "Adding component match for %pOF\n",
 				 node);
 			drm_of_component_match_add(dev, &match, compare_of,
@@ -619,9 +930,10 @@ static int mtk_drm_sys_suspend(struct device *dev)
 {
 	struct mtk_drm_private *private = dev_get_drvdata(dev);
 	struct drm_device *drm = private->drm;
-	int ret;
+	int ret = 0;
 
-	ret = drm_mode_config_helper_suspend(drm);
+	if (private->drm_master)
+		ret = drm_mode_config_helper_suspend(drm);
 
 	return ret;
 }
@@ -630,9 +942,10 @@ static int mtk_drm_sys_resume(struct device *dev)
 {
 	struct mtk_drm_private *private = dev_get_drvdata(dev);
 	struct drm_device *drm = private->drm;
-	int ret;
+	int ret = 0;
 
-	ret = drm_mode_config_helper_resume(drm);
+	if (private->drm_master)
+		ret = drm_mode_config_helper_resume(drm);
 
 	return ret;
 }
@@ -655,9 +968,13 @@ static struct platform_driver * const mtk_drm_drivers[] = {
 	&mtk_disp_ccorr_driver,
 	&mtk_disp_color_driver,
 	&mtk_disp_gamma_driver,
+	&mtk_disp_merge_driver,
+	&mtk_disp_ovl_adaptor_driver,
 	&mtk_disp_ovl_driver,
 	&mtk_disp_rdma_driver,
+	&mtk_dp_tx_driver,
 	&mtk_dpi_driver,
+	&mtk_dpintf_driver,
 	&mtk_drm_platform_driver,
 	&mtk_dsi_driver,
 };
diff --git a/drivers/gpu/drm/mediatek/mtk_drm_drv.h b/drivers/gpu/drm/mediatek/mtk_drm_drv.h
index 3e7d1e6fbe010e0852b1fa2e8a088ef02a7f746c..7f4c825238dccdba8f5b6549aadec28bfbfbffe5 100644
--- a/drivers/gpu/drm/mediatek/mtk_drm_drv.h
+++ b/drivers/gpu/drm/mediatek/mtk_drm_drv.h
@@ -20,23 +20,32 @@ struct drm_fb_helper;
 struct drm_property;
 struct regmap;
 
+struct mtk_drm_route {
+	unsigned int route_len;
+	const enum mtk_ddp_comp_id *route_ddp;
+};
+
 struct mtk_mmsys_driver_data {
 	const enum mtk_ddp_comp_id *main_path;
 	unsigned int main_len;
 	const enum mtk_ddp_comp_id *ext_path;
 	unsigned int ext_len;
+	const struct mtk_drm_route *ext_conn_routes;
+	unsigned int ext_conn_routes_num;
 	const enum mtk_ddp_comp_id *third_path;
 	unsigned int third_len;
 
 	bool shadow_register;
+	unsigned int mmsys_id;
+	unsigned int mmsys_dev_num;
 };
 
 struct mtk_drm_private {
 	struct drm_device *drm;
 	struct device *dma_dev;
-
-	unsigned int num_pipes;
-
+	bool mtk_drm_bound;
+	bool drm_master;
+	struct device *dev;
 	struct device_node *mutex_node;
 	struct device *mutex_dev;
 	struct device *mmsys_dev;
@@ -44,15 +53,20 @@ struct mtk_drm_private {
 	struct mtk_ddp_comp ddp_comp[DDP_COMPONENT_ID_MAX];
 	const struct mtk_mmsys_driver_data *data;
 	struct drm_atomic_state *suspend_state;
+	struct mtk_drm_private **all_drm_private;
 };
 
 extern struct platform_driver mtk_disp_aal_driver;
 extern struct platform_driver mtk_disp_ccorr_driver;
 extern struct platform_driver mtk_disp_color_driver;
 extern struct platform_driver mtk_disp_gamma_driver;
+extern struct platform_driver mtk_disp_merge_driver;
+extern struct platform_driver mtk_disp_ovl_adaptor_driver;
 extern struct platform_driver mtk_disp_ovl_driver;
 extern struct platform_driver mtk_disp_rdma_driver;
 extern struct platform_driver mtk_dpi_driver;
 extern struct platform_driver mtk_dsi_driver;
+extern struct platform_driver mtk_dpintf_driver;
+extern struct platform_driver mtk_dp_tx_driver;
 
 #endif /* MTK_DRM_DRV_H */
diff --git a/drivers/gpu/drm/mediatek/mtk_ethdr.c b/drivers/gpu/drm/mediatek/mtk_ethdr.c
new file mode 100644
index 0000000000000000000000000000000000000000..5772a9d47bd706a7e3ecbd36a6f3b0414e3a9155
--- /dev/null
+++ b/drivers/gpu/drm/mediatek/mtk_ethdr.c
@@ -0,0 +1,423 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Copyright (c) 2021 MediaTek Inc.
+ */
+
+#include <drm/drm_fourcc.h>
+#include <linux/clk.h>
+#include <linux/reset.h>
+#include <linux/component.h>
+#include <linux/of_device.h>
+#include <linux/of_address.h>
+#include <linux/pm_runtime.h>
+#include <linux/platform_device.h>
+#include <linux/soc/mediatek/mtk-cmdq.h>
+#include <linux/soc/mediatek/mtk-mmsys.h>
+
+#include "mtk_drm_crtc.h"
+#include "mtk_drm_ddp_comp.h"
+#include "mtk_drm_drv.h"
+#include "mtk_ethdr.h"
+
+#define MIX_INTEN		0x4
+	#define MIX_FME_CPL_INTEN	BIT(1)
+#define MIX_INTSTA		0x8
+#define MIX_EN			0xc
+#define MIX_RST			0x14
+#define MIX_ROI_SIZE		0x18
+#define MIX_DATAPATH_CON	0x1c
+	#define OUTPUT_NO_RND	BIT(3)
+	#define SOURCE_RGB_SEL	BIT(7)
+	#define BACKGROUND_RELAY	(4 << 9)
+#define MIX_ROI_BGCLR		0x20
+	#define BGCLR_BLACK	0xff000000
+#define MIX_SRC_CON		0x24
+	#define MIX_SRC_L0_EN	BIT(0)
+#define MIX_L_SRC_CON(n)	(0x28 + 0x18 * (n))
+	#define NON_PREMULTI_SOURCE (2 << 12)
+#define MIX_L_SRC_SIZE(n)	(0x30 + 0x18 * (n))
+#define MIX_L_SRC_OFFSET(n)	(0x34 + 0x18 * (n))
+#define MIX_FUNC_DCM0		0x120
+#define MIX_FUNC_DCM1		0x124
+	#define MIX_FUNC_DCM_ENABLE 0xffffffff
+
+#define HDR_VDO_FE_0804_HDR_DM_FE	0x804
+	#define HDR_VDO_FE_0804_BYPASS_ALL	0xfd
+#define HDR_GFX_FE_0204_GFX_HDR_FE	0x204
+	#define HDR_GFX_FE_0204_BYPASS_ALL	0xfd
+#define HDR_VDO_BE_0204_VDO_DM_BE	0x204
+	#define HDR_VDO_BE_0204_BYPASS_ALL	0x7e
+
+#define MIXER_INx_MODE_BYPASS 0
+#define MIXER_INx_MODE_EVEN_EXTEND 1
+#define MIXER_INx_MODE_ODD_EXTEND 2
+#define DEFAULT_9BIT_ALPHA	0x100
+#define	MIXER_ALPHA_AEN		BIT(8)
+#define	MIXER_ALPHA		0xff
+#define ETHDR_CLK_NUM		13
+
+enum mtk_ethdr_comp_id {
+	ETHDR_MIXER,
+	ETHDR_VDO_FE0,
+	ETHDR_VDO_FE1,
+	ETHDR_GFX_FE0,
+	ETHDR_GFX_FE1,
+	ETHDR_VDO_BE,
+	ETHDR_ADL_DS,
+	ETHDR_ID_MAX
+};
+
+struct mtk_ethdr_comp {
+	struct device *dev;
+	void __iomem *regs;
+	struct cmdq_client_reg cmdq_base;
+};
+
+struct mtk_ethdr {
+	struct mtk_ethdr_comp ethdr_comp[ETHDR_ID_MAX];
+	struct clk_bulk_data ethdr_clk[ETHDR_CLK_NUM];
+	struct device *ovl_adaptor_dev;
+	struct device *mmsys_dev;
+	spinlock_t lock; /* protects vblank_cb and vblank_cb_data */
+	void (*vblank_cb)(void *data);
+	void *vblank_cb_data;
+	int irq;
+};
+
+static const char * const ethdr_comp_str[] = {
+	"ETHDR_MIXER",
+	"ETHDR_VDO_FE0",
+	"ETHDR_VDO_FE1",
+	"ETHDR_GFX_FE0",
+	"ETHDR_GFX_FE1",
+	"ETHDR_VDO_BE",
+	"ETHDR_ADL_DS",
+	"ETHDR_ID_MAX"
+};
+
+static const char * const ethdr_clk_str[] = {
+	"ethdr_top",
+	"mixer",
+	"vdo_fe0",
+	"vdo_fe1",
+	"gfx_fe0",
+	"gfx_fe1",
+	"vdo_be",
+	"adl_ds",
+	"vdo_fe0_async",
+	"vdo_fe1_async",
+	"gfx_fe0_async",
+	"gfx_fe1_async",
+	"vdo_be_async",
+};
+
+void mtk_ethdr_enable_vblank(struct device *dev,
+			     void (*vblank_cb)(void *),
+			     void *vblank_cb_data)
+{
+	struct mtk_ethdr *priv = dev_get_drvdata(dev);
+	unsigned long flags;
+
+	spin_lock_irqsave(&priv->lock, flags);
+	priv->vblank_cb = vblank_cb;
+	priv->vblank_cb_data = vblank_cb_data;
+	spin_unlock_irqrestore(&priv->lock, flags);
+
+	writel(MIX_FME_CPL_INTEN, priv->ethdr_comp[ETHDR_MIXER].regs + MIX_INTEN);
+}
+
+void mtk_ethdr_disable_vblank(struct device *dev)
+{
+	struct mtk_ethdr *priv = dev_get_drvdata(dev);
+	unsigned long flags;
+
+	spin_lock_irqsave(&priv->lock, flags);
+	priv->vblank_cb = NULL;
+	priv->vblank_cb_data = NULL;
+	spin_unlock_irqrestore(&priv->lock, flags);
+
+	writel(0x0, priv->ethdr_comp[ETHDR_MIXER].regs + MIX_INTEN);
+}
+
+static irqreturn_t mtk_ethdr_irq_handler(int irq, void *dev_id)
+{
+	struct mtk_ethdr *priv = dev_id;
+	unsigned long flags;
+
+	writel(0x0, priv->ethdr_comp[ETHDR_MIXER].regs + MIX_INTSTA);
+
+	spin_lock_irqsave(&priv->lock, flags);
+	if (!priv->vblank_cb) {
+		spin_unlock_irqrestore(&priv->lock, flags);
+		return IRQ_NONE;
+	}
+
+	priv->vblank_cb(priv->vblank_cb_data);
+	spin_unlock_irqrestore(&priv->lock, flags);
+
+	return IRQ_HANDLED;
+}
+
+void mtk_ethdr_layer_config(struct device *dev, unsigned int idx,
+			    struct mtk_plane_state *state,
+			    struct cmdq_pkt *cmdq_pkt)
+{
+	struct mtk_ethdr *priv = dev_get_drvdata(dev);
+	struct mtk_ethdr_comp *mixer = &priv->ethdr_comp[ETHDR_MIXER];
+	struct mtk_plane_pending_state *pending = &state->pending;
+	unsigned int offset = (pending->y << 16) | pending->x;
+	unsigned int mixer_pad_mode = MIXER_INx_MODE_BYPASS;
+	unsigned int alpha_con = 0;
+	bool x_offset_odd = false;
+
+	dev_dbg(dev, "%s+ idx:%d", __func__, idx);
+
+	if (idx >= 4)
+		return;
+
+	if (!pending->enable) {
+		mtk_ddp_write(cmdq_pkt, 0, &mixer->cmdq_base, mixer->regs, MIX_L_SRC_SIZE(idx));
+		mtk_mmsys_ddp_config(priv->mmsys_dev, MMSYS_CONFIG_MIXER_IN_MODE,
+				     idx + 1, MIXER_INx_MODE_BYPASS, cmdq_pkt);
+		mtk_mmsys_ddp_config(priv->mmsys_dev, MMSYS_CONFIG_MIXER_IN_BIWIDTH,
+				     idx + 1, 0, cmdq_pkt);
+		return;
+	}
+
+	if (pending->x % 2) {
+		x_offset_odd = true;
+		mixer_pad_mode = MIXER_INx_MODE_EVEN_EXTEND;
+	}
+	mtk_mmsys_ddp_config(priv->mmsys_dev, MMSYS_CONFIG_MIXER_IN_MODE,
+			     idx + 1, mixer_pad_mode, cmdq_pkt);
+	mtk_mmsys_ddp_config(priv->mmsys_dev, MMSYS_CONFIG_MIXER_IN_BIWIDTH,
+			     idx + 1, pending->width / 2 - 1, cmdq_pkt);
+
+	if (state->base.fb && state->base.fb->format->has_alpha) {
+		alpha_con = MIXER_ALPHA_AEN | MIXER_ALPHA;
+		mtk_mmsys_ddp_config(priv->mmsys_dev, MMSYS_CONFIG_HDR_ALPHA_SEL,
+				     idx + 1, 0, cmdq_pkt);
+	} else {
+		mtk_mmsys_ddp_config(priv->mmsys_dev, MMSYS_CONFIG_HDR_ALPHA_SEL,
+				     idx + 1, 1, cmdq_pkt);
+	}
+	mtk_mmsys_ddp_config(priv->mmsys_dev, MMSYS_CONFIG_MIXER_IN_ALPHA_ODD, idx + 1,
+			     DEFAULT_9BIT_ALPHA, cmdq_pkt);
+	mtk_mmsys_ddp_config(priv->mmsys_dev, MMSYS_CONFIG_MIXER_IN_ALPHA_EVEN, idx + 1,
+			     DEFAULT_9BIT_ALPHA, cmdq_pkt);
+
+	mtk_ddp_write(cmdq_pkt, (pending->height << 16) | pending->width, &mixer->cmdq_base,
+		      mixer->regs, MIX_L_SRC_SIZE(idx));
+	mtk_ddp_write(cmdq_pkt, (x_offset_odd << 31) | offset, &mixer->cmdq_base,
+		      mixer->regs, MIX_L_SRC_OFFSET(idx));
+	mtk_ddp_write_mask(cmdq_pkt, alpha_con, &mixer->cmdq_base, mixer->regs, MIX_L_SRC_CON(idx),
+			   0x1ff);
+	mtk_ddp_write_mask(cmdq_pkt, BIT(idx), &mixer->cmdq_base, mixer->regs, MIX_SRC_CON,
+			   BIT(idx));
+}
+
+void mtk_ethdr_config(struct device *dev, unsigned int w,
+		      unsigned int h, unsigned int vrefresh,
+		      unsigned int bpc, struct cmdq_pkt *cmdq_pkt)
+{
+	struct mtk_ethdr *priv = dev_get_drvdata(dev);
+	struct mtk_ethdr_comp *vdo_fe0 = &priv->ethdr_comp[ETHDR_VDO_FE0];
+	struct mtk_ethdr_comp *vdo_fe1 = &priv->ethdr_comp[ETHDR_VDO_FE1];
+	struct mtk_ethdr_comp *gfx_fe0 = &priv->ethdr_comp[ETHDR_GFX_FE0];
+	struct mtk_ethdr_comp *gfx_fe1 = &priv->ethdr_comp[ETHDR_GFX_FE1];
+	struct mtk_ethdr_comp *vdo_be = &priv->ethdr_comp[ETHDR_VDO_BE];
+	struct mtk_ethdr_comp *mixer = &priv->ethdr_comp[ETHDR_MIXER];
+
+	dev_dbg(dev, "%s-w:%d, h:%d\n", __func__, w, h);
+
+	mtk_ddp_write(cmdq_pkt, HDR_VDO_FE_0804_BYPASS_ALL, &vdo_fe0->cmdq_base,
+		      vdo_fe0->regs, HDR_VDO_FE_0804_HDR_DM_FE);
+
+	mtk_ddp_write(cmdq_pkt, HDR_VDO_FE_0804_BYPASS_ALL, &vdo_fe1->cmdq_base,
+		      vdo_fe1->regs, HDR_VDO_FE_0804_HDR_DM_FE);
+
+	mtk_ddp_write(cmdq_pkt, HDR_GFX_FE_0204_BYPASS_ALL, &gfx_fe0->cmdq_base,
+		      gfx_fe0->regs, HDR_GFX_FE_0204_GFX_HDR_FE);
+
+	mtk_ddp_write(cmdq_pkt, HDR_GFX_FE_0204_BYPASS_ALL, &gfx_fe1->cmdq_base,
+		      gfx_fe1->regs, HDR_GFX_FE_0204_GFX_HDR_FE);
+
+	mtk_ddp_write(cmdq_pkt, HDR_VDO_BE_0204_BYPASS_ALL, &vdo_be->cmdq_base,
+		      vdo_be->regs, HDR_VDO_BE_0204_VDO_DM_BE);
+
+	mtk_ddp_write(cmdq_pkt, MIX_FUNC_DCM_ENABLE, &mixer->cmdq_base, mixer->regs, MIX_FUNC_DCM0);
+	mtk_ddp_write(cmdq_pkt, MIX_FUNC_DCM_ENABLE, &mixer->cmdq_base, mixer->regs, MIX_FUNC_DCM1);
+	mtk_ddp_write(cmdq_pkt, (h << 16 | w), &mixer->cmdq_base, mixer->regs, MIX_ROI_SIZE);
+	mtk_ddp_write(cmdq_pkt, BGCLR_BLACK, &mixer->cmdq_base, mixer->regs, MIX_ROI_BGCLR);
+	mtk_ddp_write(cmdq_pkt, NON_PREMULTI_SOURCE, &mixer->cmdq_base, mixer->regs,
+		      MIX_L_SRC_CON(0));
+	mtk_ddp_write(cmdq_pkt, NON_PREMULTI_SOURCE, &mixer->cmdq_base, mixer->regs,
+		      MIX_L_SRC_CON(1));
+	mtk_ddp_write(cmdq_pkt, NON_PREMULTI_SOURCE, &mixer->cmdq_base, mixer->regs,
+		      MIX_L_SRC_CON(2));
+	mtk_ddp_write(cmdq_pkt, NON_PREMULTI_SOURCE, &mixer->cmdq_base, mixer->regs,
+		      MIX_L_SRC_CON(3));
+	mtk_ddp_write(cmdq_pkt, 0x0, &mixer->cmdq_base, mixer->regs, MIX_L_SRC_SIZE(0));
+	mtk_ddp_write(cmdq_pkt, OUTPUT_NO_RND | SOURCE_RGB_SEL | BACKGROUND_RELAY,
+		      &mixer->cmdq_base, mixer->regs, MIX_DATAPATH_CON);
+	mtk_ddp_write_mask(cmdq_pkt, MIX_SRC_L0_EN, &mixer->cmdq_base, mixer->regs,
+			   MIX_SRC_CON, MIX_SRC_L0_EN);
+
+	mtk_mmsys_ddp_config(priv->mmsys_dev, MMSYS_CONFIG_HDR_BE_ASYNC_WIDTH, 0,
+			     w / 2, cmdq_pkt);
+	mtk_mmsys_ddp_config(priv->mmsys_dev, MMSYS_CONFIG_HDR_BE_ASYNC_HEIGHT, 0,
+			     h, cmdq_pkt);
+	mtk_mmsys_ddp_config(priv->mmsys_dev, MMSYS_CONFIG_MIXER_IN_CH_SWAP, 4, 0, cmdq_pkt);
+}
+
+void mtk_ethdr_start(struct device *dev)
+{
+	struct mtk_ethdr *priv = dev_get_drvdata(dev);
+	struct mtk_ethdr_comp *mixer = &priv->ethdr_comp[ETHDR_MIXER];
+
+	writel(1, mixer->regs + MIX_EN);
+}
+
+void mtk_ethdr_stop(struct device *dev)
+{
+	struct mtk_ethdr *priv = dev_get_drvdata(dev);
+	struct mtk_ethdr_comp *mixer = &priv->ethdr_comp[ETHDR_MIXER];
+
+	writel(0, mixer->regs + MIX_EN);
+	writel(1, mixer->regs + MIX_RST);
+	reset_control_reset(devm_reset_control_array_get(dev, true, true));
+	writel(0, mixer->regs + MIX_RST);
+}
+
+int mtk_ethdr_clk_enable(struct device *dev)
+{
+	int ret;
+	struct mtk_ethdr *priv = dev_get_drvdata(dev);
+
+	ret = clk_bulk_prepare_enable(ETHDR_CLK_NUM, priv->ethdr_clk);
+	if (ret)
+		dev_err(dev,
+			"ethdr_clk prepare enable failed\n");
+	return ret;
+}
+
+void mtk_ethdr_clk_disable(struct device *dev)
+{
+	struct mtk_ethdr *priv = dev_get_drvdata(dev);
+
+	clk_bulk_disable_unprepare(ETHDR_CLK_NUM, priv->ethdr_clk);
+}
+
+static int mtk_ethdr_bind(struct device *dev, struct device *master,
+			  void *data)
+{
+	struct mtk_ethdr *priv = dev_get_drvdata(dev);
+	struct platform_device *ovl_adaptor;
+	struct drm_device *drm_dev = data;
+	struct mtk_drm_private *drm_private = drm_dev->dev_private;
+
+	priv->mmsys_dev = drm_private->mmsys_dev;
+
+	/* Bring up ovl adaptor rdma and merge */
+	ovl_adaptor = platform_device_register_data(dev, "mediatek-disp-ovl-adaptor",
+						    PLATFORM_DEVID_NONE, (void *)priv->mmsys_dev,
+						    sizeof(*priv->mmsys_dev));
+	if (IS_ERR(ovl_adaptor))
+		return PTR_ERR(ovl_adaptor);
+
+	priv->ovl_adaptor_dev = &ovl_adaptor->dev;
+
+	return 0;
+}
+
+static void mtk_ethdr_unbind(struct device *dev, struct device *master, void *data)
+{
+}
+
+static const struct component_ops mtk_ethdr_component_ops = {
+	.bind	= mtk_ethdr_bind,
+	.unbind = mtk_ethdr_unbind,
+};
+
+static int mtk_ethdr_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct mtk_ethdr *priv;
+	int ret;
+	int i;
+
+	dev_info(dev, "%s+\n", __func__);
+
+	priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	for (i = 0; i < ETHDR_ID_MAX; i++) {
+		priv->ethdr_comp[i].dev = dev;
+		priv->ethdr_comp[i].regs = of_iomap(dev->of_node, i);
+#if IS_REACHABLE(CONFIG_MTK_CMDQ)
+		ret = cmdq_dev_get_client_reg(dev,
+					      &priv->ethdr_comp[i].cmdq_base, i);
+		if (ret)
+			dev_dbg(dev, "get mediatek,gce-client-reg fail!\n");
+#endif
+		dev_info(dev, "[DRM]regs:0x%x, node:%s\n",
+			 priv->ethdr_comp[i].regs, ethdr_comp_str[i]);
+	}
+
+	for (i = 0; i < ETHDR_CLK_NUM; i++)
+		priv->ethdr_clk[i].id = ethdr_clk_str[i];
+	ret = devm_clk_bulk_get_optional(dev, ETHDR_CLK_NUM, priv->ethdr_clk);
+	if (ret)
+		return ret;
+
+	priv->irq = platform_get_irq(pdev, 0);
+	if (priv->irq < 0)
+		priv->irq = 0;
+
+	if (priv->irq) {
+		ret = devm_request_irq(dev, priv->irq, mtk_ethdr_irq_handler,
+				       IRQF_TRIGGER_NONE, dev_name(dev), priv);
+		if (ret < 0) {
+			dev_err(dev, "Failed to request irq %d: %d\n", priv->irq, ret);
+			return ret;
+		}
+	}
+
+	spin_lock_init(&priv->lock);
+	platform_set_drvdata(pdev, priv);
+
+	ret = component_add(dev, &mtk_ethdr_component_ops);
+	if (ret)
+		dev_notice(dev, "Failed to add component: %d\n", ret);
+
+	dev_info(dev, "%s-\n", __func__);
+	pm_runtime_enable(dev);
+
+	return ret;
+}
+
+static int mtk_ethdr_remove(struct platform_device *pdev)
+{
+	component_del(&pdev->dev, &mtk_ethdr_component_ops);
+	pm_runtime_disable(&pdev->dev);
+	return 0;
+}
+
+static const struct of_device_id mtk_ethdr_driver_dt_match[] = {
+	{ .compatible = "mediatek,mt8195-disp-ethdr"},
+	{},
+};
+
+MODULE_DEVICE_TABLE(of, mtk_ethdr_driver_dt_match);
+
+struct platform_driver mtk_ethdr_driver = {
+	.probe = mtk_ethdr_probe,
+	.remove = mtk_ethdr_remove,
+	.driver = {
+			.name = "mediatek-disp-ethdr",
+			.owner = THIS_MODULE,
+			.of_match_table = mtk_ethdr_driver_dt_match,
+		},
+};
+module_platform_driver(mtk_ethdr_driver);
diff --git a/drivers/gpu/drm/mediatek/mtk_ethdr.h b/drivers/gpu/drm/mediatek/mtk_ethdr.h
new file mode 100644
index 0000000000000000000000000000000000000000..84eb9bf2ede02f444c9182e31bf451b58117acb4
--- /dev/null
+++ b/drivers/gpu/drm/mediatek/mtk_ethdr.h
@@ -0,0 +1,25 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (c) 2021 MediaTek Inc.
+ */
+
+#ifndef __MTK_ETHDR_H__
+#define __MTK_ETHDR_H__
+
+#include <drm/mediatek_drm.h>
+
+void mtk_ethdr_start(struct device *dev);
+void mtk_ethdr_stop(struct device *dev);
+int mtk_ethdr_clk_enable(struct device *dev);
+void mtk_ethdr_clk_disable(struct device *dev);
+void mtk_ethdr_config(struct device *dev, unsigned int w,
+		      unsigned int h, unsigned int vrefresh,
+		      unsigned int bpc, struct cmdq_pkt *cmdq_pkt);
+void mtk_ethdr_layer_config(struct device *dev, unsigned int idx,
+			    struct mtk_plane_state *state,
+			    struct cmdq_pkt *cmdq_pkt);
+void mtk_ethdr_enable_vblank(struct device *dev, void (*vblank_cb)(void *),
+			     void *vblank_cb_data);
+void mtk_ethdr_disable_vblank(struct device *dev);
+#endif
+
diff --git a/drivers/gpu/drm/mediatek/mtk_mdp_rdma.c b/drivers/gpu/drm/mediatek/mtk_mdp_rdma.c
new file mode 100644
index 0000000000000000000000000000000000000000..7a0996253cfc40f3e35194c327d32f24d0b3aca3
--- /dev/null
+++ b/drivers/gpu/drm/mediatek/mtk_mdp_rdma.c
@@ -0,0 +1,306 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Copyright (c) 2021 MediaTek Inc.
+ */
+
+#include <drm/drm_fourcc.h>
+#include <linux/clk.h>
+#include <linux/of_address.h>
+#include <linux/of_device.h>
+#include <linux/platform_device.h>
+#include <linux/pm_runtime.h>
+#include <linux/soc/mediatek/mtk-cmdq.h>
+
+#include "mtk_drm_drv.h"
+#include "mtk_disp_drv.h"
+#include "mtk_mdp_rdma.h"
+
+#define MDP_RDMA_EN                                            0x000
+	#define FLD_ROT_ENABLE                            BIT(0)
+
+#define MDP_RDMA_RESET                                         0x008
+
+#define MDP_RDMA_CON                                           0x020
+	#define FLD_OUTPUT_10B                            BIT(5)
+	#define FLD_SIMPLE_MODE                           BIT(4)
+
+#define MDP_RDMA_GMCIF_CON                                     0x028
+	#define FLD_COMMAND_DIV                           BIT(0)
+	#define FLD_EXT_PREULTRA_EN                       BIT(3)
+	#define FLD_RD_REQ_TYPE                           GENMASK(7, 4)
+		#define VAL_RD_REQ_TYPE_BURST_8_ACCESS    7
+	#define FLD_ULTRA_EN                              GENMASK(13, 12)
+		#define VAL_ULTRA_EN_ENABLE               1
+	#define FLD_PRE_ULTRA_EN                          GENMASK(17, 16)
+		#define VAL_PRE_ULTRA_EN_ENABLE           1
+	#define FLD_EXT_ULTRA_EN                          BIT(18)
+
+#define MDP_RDMA_SRC_CON                                       0x030
+	#define FLD_OUTPUT_ARGB                           BIT(25)
+	#define FLD_BIT_NUMBER                            GENMASK(19, 18)
+	#define FLD_UNIFORM_CONFIG                        BIT(17)
+	#define FLD_SWAP                                  BIT(14)
+	#define FLD_SRC_FORMAT                            GENMASK(3, 0)
+
+#define MDP_RDMA_COMP_CON                                      0x038
+	#define FLD_AFBC_EN                               BIT(22)
+	#define FLD_AFBC_YUV_TRANSFORM                    BIT(21)
+	#define FLD_UFBDC_EN                              BIT(12)
+
+#define MDP_RDMA_MF_BKGD_SIZE_IN_BYTE                          0x060
+	#define FLD_MF_BKGD_WB                            GENMASK(22, 0)
+
+#define MDP_RDMA_MF_SRC_SIZE                                   0x070
+	#define FLD_MF_SRC_H                              GENMASK(30, 16)
+	#define FLD_MF_SRC_W                              GENMASK(14, 0)
+
+#define MDP_RDMA_MF_CLIP_SIZE                                  0x078
+	#define FLD_MF_CLIP_H                             GENMASK(30, 16)
+	#define FLD_MF_CLIP_W                             GENMASK(14, 0)
+
+#define MDP_RDMA_TARGET_LINE                                   0x0a0
+	#define FLD_LINE_THRESHOLD                        GENMASK(31, 17)
+	#define FLD_TARGET_LINE_EN                        BIT(16)
+
+#define MDP_RDMA_SRC_OFFSET_0                                  0x118
+	#define FLD_SRC_OFFSET_0                          GENMASK(31, 0)
+
+#define MDP_RDMA_TRANSFORM_0                                   0x200
+	#define FLD_INT_MATRIX_SEL                        GENMASK(27, 23)
+	#define FLD_TRANS_EN                              BIT(16)
+
+#define MDP_RDMA_SRC_BASE_0                                    0xf00
+	#define FLD_SRC_BASE_0                            GENMASK(31, 0)
+
+#define RDMA_INPUT_SWAP		BIT(14)
+#define RDMA_INPUT_10BIT	BIT(18)
+
+enum rdma_format {
+	RDMA_INPUT_FORMAT_RGB565 = 0,
+	RDMA_INPUT_FORMAT_RGB888 = 1,
+	RDMA_INPUT_FORMAT_RGBA8888 = 2,
+	RDMA_INPUT_FORMAT_ARGB8888 = 3,
+	RDMA_INPUT_FORMAT_UYVY = 4,
+	RDMA_INPUT_FORMAT_YUY2 = 5,
+	RDMA_INPUT_FORMAT_Y8 = 7,
+	RDMA_INPUT_FORMAT_YV12 = 8,
+	RDMA_INPUT_FORMAT_UYVY_3PL = 9,
+	RDMA_INPUT_FORMAT_NV12 = 12,
+	RDMA_INPUT_FORMAT_UYVY_2PL = 13,
+	RDMA_INPUT_FORMAT_Y410 = 14
+};
+
+struct mtk_mdp_rdma {
+	void __iomem *regs;
+	struct clk *clk;
+	struct cmdq_client_reg		cmdq_reg;
+};
+
+static unsigned int rdma_fmt_convert(unsigned int fmt)
+{
+	switch (fmt) {
+	default:
+	case DRM_FORMAT_RGB565:
+		return RDMA_INPUT_FORMAT_RGB565;
+	case DRM_FORMAT_BGR565:
+		return RDMA_INPUT_FORMAT_RGB565 | RDMA_INPUT_SWAP;
+	case DRM_FORMAT_RGB888:
+		return RDMA_INPUT_FORMAT_RGB888;
+	case DRM_FORMAT_BGR888:
+		return RDMA_INPUT_FORMAT_RGB888 | RDMA_INPUT_SWAP;
+	case DRM_FORMAT_RGBX8888:
+	case DRM_FORMAT_RGBA8888:
+		return RDMA_INPUT_FORMAT_ARGB8888;
+	case DRM_FORMAT_BGRX8888:
+	case DRM_FORMAT_BGRA8888:
+		return RDMA_INPUT_FORMAT_ARGB8888 | RDMA_INPUT_SWAP;
+	case DRM_FORMAT_XRGB8888:
+	case DRM_FORMAT_ARGB8888:
+		return RDMA_INPUT_FORMAT_RGBA8888;
+	case DRM_FORMAT_XBGR8888:
+	case DRM_FORMAT_ABGR8888:
+		return RDMA_INPUT_FORMAT_RGBA8888 | RDMA_INPUT_SWAP;
+	case DRM_FORMAT_ABGR2101010:
+		return RDMA_INPUT_FORMAT_RGBA8888 | RDMA_INPUT_SWAP |
+				RDMA_INPUT_10BIT;
+	case DRM_FORMAT_ARGB2101010:
+		return RDMA_INPUT_FORMAT_RGBA8888 | RDMA_INPUT_10BIT;
+	case DRM_FORMAT_RGBA1010102:
+		return RDMA_INPUT_FORMAT_ARGB8888 | RDMA_INPUT_SWAP |
+				RDMA_INPUT_10BIT;
+	case DRM_FORMAT_BGRA1010102:
+		return RDMA_INPUT_FORMAT_ARGB8888 | RDMA_INPUT_10BIT;
+	case DRM_FORMAT_UYVY:
+		return RDMA_INPUT_FORMAT_UYVY;
+	case DRM_FORMAT_YUYV:
+		return RDMA_INPUT_FORMAT_YUY2;
+	}
+}
+
+static void mtk_mdp_rdma_fifo_config(struct device *dev, struct cmdq_pkt *cmdq_pkt)
+{
+	struct mtk_mdp_rdma *priv = dev_get_drvdata(dev);
+
+	mtk_ddp_write_mask(cmdq_pkt, FLD_EXT_ULTRA_EN | VAL_PRE_ULTRA_EN_ENABLE << 16 |
+			   VAL_ULTRA_EN_ENABLE << 12 | VAL_RD_REQ_TYPE_BURST_8_ACCESS << 4 |
+			   FLD_EXT_PREULTRA_EN | FLD_COMMAND_DIV, &priv->cmdq_reg,
+			   priv->regs, MDP_RDMA_GMCIF_CON, FLD_EXT_ULTRA_EN |
+			   FLD_PRE_ULTRA_EN | FLD_ULTRA_EN | FLD_RD_REQ_TYPE |
+			   FLD_EXT_PREULTRA_EN | FLD_COMMAND_DIV);
+}
+
+void mtk_mdp_rdma_start(struct device *dev, struct cmdq_pkt *cmdq_pkt)
+{
+	struct mtk_mdp_rdma *priv = dev_get_drvdata(dev);
+
+	mtk_ddp_write_mask(cmdq_pkt, FLD_ROT_ENABLE, &priv->cmdq_reg,
+			   priv->regs, MDP_RDMA_EN, FLD_ROT_ENABLE);
+}
+
+void mtk_mdp_rdma_stop(struct device *dev, struct cmdq_pkt *cmdq_pkt)
+{
+	struct mtk_mdp_rdma *priv = dev_get_drvdata(dev);
+
+	mtk_ddp_write_mask(cmdq_pkt, 0, &priv->cmdq_reg,
+			   priv->regs, MDP_RDMA_EN, FLD_ROT_ENABLE);
+	mtk_ddp_write(cmdq_pkt, 1, &priv->cmdq_reg, priv->regs, MDP_RDMA_RESET);
+	mtk_ddp_write(cmdq_pkt, 0, &priv->cmdq_reg, priv->regs, MDP_RDMA_RESET);
+}
+
+void mtk_mdp_rdma_config(struct device *dev, struct mtk_mdp_rdma_cfg *cfg,
+			 struct cmdq_pkt *cmdq_pkt)
+{
+	struct mtk_mdp_rdma *priv = dev_get_drvdata(dev);
+	const struct drm_format_info *fmt_info = drm_format_info(cfg->fmt);
+	unsigned int src_pitch_y = cfg->pitch;
+	unsigned int bpp_y = fmt_info->cpp[0] * 8;
+	unsigned int offset_y = 0;
+
+	mtk_mdp_rdma_fifo_config(dev, cmdq_pkt);
+
+	mtk_ddp_write_mask(cmdq_pkt, FLD_UNIFORM_CONFIG, &priv->cmdq_reg, priv->regs,
+			   MDP_RDMA_SRC_CON, FLD_UNIFORM_CONFIG);
+	mtk_ddp_write_mask(cmdq_pkt, rdma_fmt_convert(cfg->fmt), &priv->cmdq_reg, priv->regs,
+			   MDP_RDMA_SRC_CON, FLD_SWAP | FLD_SRC_FORMAT | FLD_BIT_NUMBER);
+
+	if (!cfg->csc_enable && fmt_info->has_alpha)
+		mtk_ddp_write_mask(cmdq_pkt, FLD_OUTPUT_ARGB, &priv->cmdq_reg,
+				   priv->regs, MDP_RDMA_SRC_CON, FLD_OUTPUT_ARGB);
+	else
+		mtk_ddp_write_mask(cmdq_pkt, 0, &priv->cmdq_reg, priv->regs,
+				   MDP_RDMA_SRC_CON, FLD_OUTPUT_ARGB);
+
+	mtk_ddp_write_mask(cmdq_pkt, cfg->addr0, &priv->cmdq_reg, priv->regs,
+			   MDP_RDMA_SRC_BASE_0, FLD_SRC_BASE_0);
+
+	mtk_ddp_write_mask(cmdq_pkt, src_pitch_y, &priv->cmdq_reg, priv->regs,
+			   MDP_RDMA_MF_BKGD_SIZE_IN_BYTE, FLD_MF_BKGD_WB);
+
+	mtk_ddp_write_mask(cmdq_pkt, 0, &priv->cmdq_reg, priv->regs, MDP_RDMA_COMP_CON,
+			   FLD_AFBC_YUV_TRANSFORM);
+	mtk_ddp_write_mask(cmdq_pkt, 0, &priv->cmdq_reg, priv->regs, MDP_RDMA_COMP_CON,
+			   FLD_UFBDC_EN);
+	mtk_ddp_write_mask(cmdq_pkt, 0, &priv->cmdq_reg, priv->regs, MDP_RDMA_COMP_CON,
+			   FLD_AFBC_EN);
+
+	mtk_ddp_write_mask(cmdq_pkt, FLD_OUTPUT_10B, &priv->cmdq_reg, priv->regs,
+			   MDP_RDMA_CON, FLD_OUTPUT_10B);
+	mtk_ddp_write_mask(cmdq_pkt, FLD_SIMPLE_MODE, &priv->cmdq_reg, priv->regs,
+			   MDP_RDMA_CON, FLD_SIMPLE_MODE);
+	mtk_ddp_write_mask(cmdq_pkt, cfg->csc_enable << 16, &priv->cmdq_reg, priv->regs,
+			   MDP_RDMA_TRANSFORM_0, FLD_TRANS_EN);
+	mtk_ddp_write_mask(cmdq_pkt, cfg->profile << 23, &priv->cmdq_reg, priv->regs,
+			   MDP_RDMA_TRANSFORM_0, FLD_INT_MATRIX_SEL);
+
+	offset_y  = (cfg->x_left * bpp_y >> 3) + cfg->y_top * src_pitch_y;
+
+	mtk_ddp_write_mask(cmdq_pkt, offset_y, &priv->cmdq_reg, priv->regs,
+			   MDP_RDMA_SRC_OFFSET_0, FLD_SRC_OFFSET_0);
+	mtk_ddp_write_mask(cmdq_pkt, cfg->width, &priv->cmdq_reg, priv->regs,
+			   MDP_RDMA_MF_SRC_SIZE, FLD_MF_SRC_W);
+	mtk_ddp_write_mask(cmdq_pkt, cfg->height << 16, &priv->cmdq_reg, priv->regs,
+			   MDP_RDMA_MF_SRC_SIZE, FLD_MF_SRC_H);
+	mtk_ddp_write_mask(cmdq_pkt, cfg->width, &priv->cmdq_reg, priv->regs,
+			   MDP_RDMA_MF_CLIP_SIZE, FLD_MF_CLIP_W);
+	mtk_ddp_write_mask(cmdq_pkt, cfg->height << 16, &priv->cmdq_reg, priv->regs,
+			   MDP_RDMA_MF_CLIP_SIZE, FLD_MF_CLIP_H);
+	mtk_ddp_write_mask(cmdq_pkt, cfg->height << 17, &priv->cmdq_reg, priv->regs,
+			   MDP_RDMA_TARGET_LINE, FLD_LINE_THRESHOLD);
+	mtk_ddp_write_mask(cmdq_pkt, FLD_TARGET_LINE_EN, &priv->cmdq_reg, priv->regs,
+			   MDP_RDMA_TARGET_LINE, FLD_TARGET_LINE_EN);
+}
+
+int mtk_mdp_rdma_clk_enable(struct device *dev)
+{
+	struct mtk_mdp_rdma *rdma = dev_get_drvdata(dev);
+
+	pm_runtime_get_sync(dev);
+	clk_prepare_enable(rdma->clk);
+	return 0;
+}
+
+void mtk_mdp_rdma_clk_disable(struct device *dev)
+{
+	struct mtk_mdp_rdma *rdma = dev_get_drvdata(dev);
+
+	clk_disable_unprepare(rdma->clk);
+	pm_runtime_put(dev);
+}
+
+static int mtk_mdp_rdma_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct resource *res;
+	struct mtk_mdp_rdma *priv;
+	int ret = 0;
+
+	priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	priv->regs = devm_ioremap_resource(dev, res);
+	if (IS_ERR(priv->regs)) {
+		dev_err(dev, "failed to ioremap rdma\n");
+		return PTR_ERR(priv->regs);
+	}
+
+	priv->clk = devm_clk_get(dev, NULL);
+	if (IS_ERR(priv->clk)) {
+		dev_err(dev, "failed to get rdma clk\n");
+		return PTR_ERR(priv->clk);
+	}
+
+#if IS_REACHABLE(CONFIG_MTK_CMDQ)
+	ret = cmdq_dev_get_client_reg(dev, &priv->cmdq_reg, 0);
+	if (ret)
+		dev_dbg(dev, "get mediatek,gce-client-reg fail!\n");
+#endif
+	platform_set_drvdata(pdev, priv);
+
+	pm_runtime_enable(dev);
+	return ret;
+}
+
+static int mtk_mdp_rdma_remove(struct platform_device *pdev)
+{
+	pm_runtime_disable(&pdev->dev);
+	return 0;
+}
+
+static const struct of_device_id mtk_mdp_rdma_driver_dt_match[] = {
+	{ .compatible = "mediatek,mt8195-vdo1-rdma", },
+	{},
+};
+MODULE_DEVICE_TABLE(of, mtk_mdp_rdma_driver_dt_match);
+
+struct platform_driver mtk_mdp_rdma_driver = {
+	.probe = mtk_mdp_rdma_probe,
+	.remove = mtk_mdp_rdma_remove,
+	.driver = {
+		.name = "mediatek-mdp-rdma",
+		.owner = THIS_MODULE,
+		.of_match_table = mtk_mdp_rdma_driver_dt_match,
+	},
+};
+module_platform_driver(mtk_mdp_rdma_driver);
diff --git a/drivers/gpu/drm/mediatek/mtk_mdp_rdma.h b/drivers/gpu/drm/mediatek/mtk_mdp_rdma.h
new file mode 100644
index 0000000000000000000000000000000000000000..df8e28f0e3a4b93cddbaf332e808255aa16cd287
--- /dev/null
+++ b/drivers/gpu/drm/mediatek/mtk_mdp_rdma.h
@@ -0,0 +1,37 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (c) 2021 MediaTek Inc.
+ */
+
+#ifndef __MTK_MDP_RDMA_H__
+#define __MTK_MDP_RDMA_H__
+
+enum mtk_mdp_rdma_profile {
+	RDMA_CSC_RGB_TO_JPEG = 0,
+	RDMA_CSC_RGB_TO_FULL709 = 1,
+	RDMA_CSC_RGB_TO_BT601 = 2,
+	RDMA_CSC_RGB_TO_BT709 = 3,
+	RDMA_CSC_JPEG_TO_RGB = 4,
+	RDMA_CSC_FULL709_TO_RGB = 5,
+	RDMA_CSC_BT601_TO_RGB = 6,
+	RDMA_CSC_BT709_TO_RGB = 7,
+	RDMA_CSC_JPEG_TO_BT601 = 8,
+	RDMA_CSC_JPEG_TO_BT709 = 9,
+	RDMA_CSC_BT601_TO_JPEG = 10,
+	RDMA_CSC_BT709_TO_BT601 = 11,
+	RDMA_CSC_BT601_TO_BT709 = 12
+};
+
+struct mtk_mdp_rdma_cfg {
+	enum mtk_mdp_rdma_profile profile;
+	unsigned int pitch;
+	unsigned int addr0;
+	unsigned int width;
+	unsigned int height;
+	unsigned int x_left;
+	unsigned int y_top;
+	bool csc_enable;
+	int fmt;
+};
+
+#endif // __MTK_MDP_RDMA_H__
diff --git a/drivers/gpu/drm/panel/panel-simple.c b/drivers/gpu/drm/panel/panel-simple.c
index 96db18d46fedbf1a83c260a1babbda5ea1fa1555..95395c1ec1161d6708a55f7bae93d2db03b6e6cd 100644
--- a/drivers/gpu/drm/panel/panel-simple.c
+++ b/drivers/gpu/drm/panel/panel-simple.c
@@ -797,9 +797,10 @@ static int panel_simple_probe(struct device *dev, const struct panel_desc *desc,
 	drm_panel_init(&panel->base, dev, &panel_simple_funcs, connector_type);
 
 	err = drm_panel_of_backlight(&panel->base);
-	if (err)
+	if (err) {
+		err = -EPROBE_DEFER;
 		goto disable_pm_runtime;
-
+	}
 	drm_panel_add(&panel->base);
 
 	return 0;
@@ -2893,6 +2894,11 @@ static const struct panel_desc lg_lp120up1 = {
 		.width = 267,
 		.height = 183,
 	},
+	.delay = {
+		.prepare = 200,
+		.enable = 50,
+		.unprepare = 500,
+	},
 	.connector_type = DRM_MODE_CONNECTOR_eDP,
 };
 
diff --git a/drivers/i2c/busses/i2c-mt65xx.c b/drivers/i2c/busses/i2c-mt65xx.c
index 835bffb5f74b3bdee59b28bffa76f60c631d9377..3b50f19190df9dfadceabbcfb69e61f1b7e8614c 100644
--- a/drivers/i2c/busses/i2c-mt65xx.c
+++ b/drivers/i2c/busses/i2c-mt65xx.c
@@ -15,6 +15,7 @@
 #include <linux/init.h>
 #include <linux/interrupt.h>
 #include <linux/io.h>
+#include <linux/iopoll.h>
 #include <linux/kernel.h>
 #include <linux/mm.h>
 #include <linux/module.h>
@@ -49,6 +50,9 @@
 #define I2C_RD_TRANAC_VALUE		0x0001
 #define I2C_SCL_MIS_COMP_VALUE		0x0000
 #define I2C_CHN_CLR_FLAG		0x0000
+#define I2C_CLR_DEBUGCTR		0x0000
+#define I2C_RELIABILITY			0x0010
+#define I2C_DMAACK_ENABLE		0x0008
 
 #define I2C_DMA_CON_TX			0x0000
 #define I2C_DMA_CON_RX			0x0001
@@ -129,6 +133,7 @@ enum I2C_REGS_OFFSET {
 	OFFSET_HS,
 	OFFSET_SOFTRESET,
 	OFFSET_DCM_EN,
+	OFFSET_MULTI_DMA,
 	OFFSET_PATH_DIR,
 	OFFSET_DEBUGSTAT,
 	OFFSET_DEBUGCTRL,
@@ -196,8 +201,9 @@ static const u16 mt_i2c_regs_v2[] = {
 	[OFFSET_TRANSFER_LEN_AUX] = 0x44,
 	[OFFSET_CLOCK_DIV] = 0x48,
 	[OFFSET_SOFTRESET] = 0x50,
+	[OFFSET_MULTI_DMA] = 0x8c,
 	[OFFSET_SCL_MIS_COMP_POINT] = 0x90,
-	[OFFSET_DEBUGSTAT] = 0xe0,
+	[OFFSET_DEBUGSTAT] = 0xe4,
 	[OFFSET_DEBUGCTRL] = 0xe8,
 	[OFFSET_FIFO_STAT] = 0xf4,
 	[OFFSET_FIFO_THRESH] = 0xf8,
@@ -921,6 +927,57 @@ static int mtk_i2c_set_speed_adjust_timing(struct mtk_i2c *i2c,
 	return 0;
 }
 
+static void i2c_dump_register(struct mtk_i2c *i2c)
+{
+	dev_err(i2c->dev, "SLAVE_ADDR: 0x%x, INTR_MASK: 0x%x\n",
+		mtk_i2c_readw(i2c, OFFSET_SLAVE_ADDR),
+		mtk_i2c_readw(i2c, OFFSET_INTR_MASK));
+	dev_err(i2c->dev, "INTR_STAT: 0x%x, CONTROL: 0x%x\n",
+		mtk_i2c_readw(i2c, OFFSET_INTR_STAT),
+		mtk_i2c_readw(i2c, OFFSET_CONTROL));
+	dev_err(i2c->dev, "TRANSFER_LEN: 0x%x, TRANSAC_LEN: 0x%x\n",
+		mtk_i2c_readw(i2c, OFFSET_TRANSFER_LEN),
+		mtk_i2c_readw(i2c, OFFSET_TRANSAC_LEN));
+	dev_err(i2c->dev, "DELAY_LEN: 0x%x, HTIMING: 0x%x\n",
+		mtk_i2c_readw(i2c, OFFSET_DELAY_LEN),
+		mtk_i2c_readw(i2c, OFFSET_TIMING));
+	dev_err(i2c->dev, "START: 0x%x, EXT_CONF: 0x%x\n",
+		mtk_i2c_readw(i2c, OFFSET_START),
+		mtk_i2c_readw(i2c, OFFSET_EXT_CONF));
+	dev_err(i2c->dev, "HS: 0x%x, IO_CONFIG: 0x%x\n",
+		mtk_i2c_readw(i2c, OFFSET_HS),
+		mtk_i2c_readw(i2c, OFFSET_IO_CONFIG));
+	dev_err(i2c->dev, "DCM_EN: 0x%x, TRANSFER_LEN_AUX: 0x%x\n",
+		mtk_i2c_readw(i2c, OFFSET_DCM_EN),
+		mtk_i2c_readw(i2c, OFFSET_TRANSFER_LEN_AUX));
+	dev_err(i2c->dev, "CLOCK_DIV: 0x%x, FIFO_STAT: 0x%x\n",
+		mtk_i2c_readw(i2c, OFFSET_CLOCK_DIV),
+		mtk_i2c_readw(i2c, OFFSET_FIFO_STAT));
+	dev_err(i2c->dev, "DEBUGCTRL : 0x%x, DEBUGSTAT: 0x%x\n",
+		mtk_i2c_readw(i2c, OFFSET_DEBUGCTRL),
+		mtk_i2c_readw(i2c, OFFSET_DEBUGSTAT));
+	if (i2c->dev_comp->regs == mt_i2c_regs_v2) {
+		dev_err(i2c->dev, "LTIMING: 0x%x, MULTI_DMA: 0x%x\n",
+			mtk_i2c_readw(i2c, OFFSET_LTIMING),
+			mtk_i2c_readw(i2c, OFFSET_MULTI_DMA));
+	}
+	dev_err(i2c->dev, "\nDMA_INT_FLAG: 0x%x, DMA_INT_EN: 0x%x\n",
+		readl(i2c->pdmabase + OFFSET_INT_FLAG),
+		readl(i2c->pdmabase + OFFSET_INT_EN));
+	dev_err(i2c->dev, "DMA_EN: 0x%x, DMA_CON: 0x%x\n",
+		readl(i2c->pdmabase + OFFSET_EN),
+		readl(i2c->pdmabase + OFFSET_CON));
+	dev_err(i2c->dev, "DMA_TX_MEM_ADDR: 0x%x, DMA_RX_MEM_ADDR: 0x%x\n",
+		readl(i2c->pdmabase + OFFSET_TX_MEM_ADDR),
+		readl(i2c->pdmabase + OFFSET_RX_MEM_ADDR));
+	dev_err(i2c->dev, "DMA_TX_LEN: 0x%x, DMA_RX_LEN: 0x%x\n",
+		readl(i2c->pdmabase + OFFSET_TX_LEN),
+		readl(i2c->pdmabase + OFFSET_RX_LEN));
+	dev_err(i2c->dev, "DMA_TX_4G_MODE: 0x%x, DMA_RX_4G_MODE: 0x%x",
+		readl(i2c->pdmabase + OFFSET_TX_4G_MODE),
+		readl(i2c->pdmabase + OFFSET_RX_4G_MODE));
+}
+
 static int mtk_i2c_do_transfer(struct mtk_i2c *i2c, struct i2c_msg *msgs,
 			       int num, int left_num)
 {
@@ -930,6 +987,7 @@ static int mtk_i2c_do_transfer(struct mtk_i2c *i2c, struct i2c_msg *msgs,
 	u16 restart_flag = 0;
 	u16 dma_sync = 0;
 	u32 reg_4g_mode;
+	u32 reg_dma_reset;
 	u8 *dma_rd_buf = NULL;
 	u8 *dma_wr_buf = NULL;
 	dma_addr_t rpaddr = 0;
@@ -943,6 +1001,27 @@ static int mtk_i2c_do_transfer(struct mtk_i2c *i2c, struct i2c_msg *msgs,
 
 	reinit_completion(&i2c->msg_complete);
 
+	if (i2c->dev_comp->apdma_sync && i2c->op != I2C_MASTER_WRRD && num > 1) {
+		mtk_i2c_writew(i2c, I2C_CLR_DEBUGCTR, OFFSET_DEBUGCTRL);
+		writel(I2C_DMA_HANDSHAKE_RST | I2C_DMA_WARM_RST,
+		       i2c->pdmabase + OFFSET_RST);
+
+		ret = readw_poll_timeout(i2c->pdmabase + OFFSET_RST,
+					 reg_dma_reset,
+					 !(reg_dma_reset & I2C_DMA_WARM_RST),
+					 0, 100);
+		if (ret) {
+			dev_err(i2c->dev, "DMA warm reset timeout\n");
+			return -ETIMEDOUT;
+		}
+
+		writel(I2C_DMA_CLR_FLAG, i2c->pdmabase + OFFSET_RST);
+		mtk_i2c_writew(i2c, I2C_HANDSHAKE_RST, OFFSET_SOFTRESET);
+		mtk_i2c_writew(i2c, I2C_CHN_CLR_FLAG, OFFSET_SOFTRESET);
+		mtk_i2c_writew(i2c, I2C_RELIABILITY | I2C_DMAACK_ENABLE,
+			       OFFSET_DEBUGCTRL);
+	}
+
 	control_reg = mtk_i2c_readw(i2c, OFFSET_CONTROL) &
 			~(I2C_CONTROL_DIR_CHANGE | I2C_CONTROL_RS);
 	if ((i2c->speed_hz > I2C_MAX_FAST_MODE_PLUS_FREQ) || (left_num >= 1))
@@ -1127,7 +1206,8 @@ static int mtk_i2c_do_transfer(struct mtk_i2c *i2c, struct i2c_msg *msgs,
 	}
 
 	if (ret == 0) {
-		dev_dbg(i2c->dev, "addr: %x, transfer timeout\n", msgs->addr);
+		dev_err(i2c->dev, "addr: %x, transfer timeout\n", msgs->addr);
+		i2c_dump_register(i2c);
 		mtk_i2c_init_hw(i2c);
 		return -ETIMEDOUT;
 	}
diff --git a/drivers/iommu/mtk_iommu.c b/drivers/iommu/mtk_iommu.c
index 30f54d37911caf4395af398c56dd957e5f5b9bfc..dd6ee3e5602830395276281af340be44669ed8dd 100644
--- a/drivers/iommu/mtk_iommu.c
+++ b/drivers/iommu/mtk_iommu.c
@@ -22,6 +22,7 @@
 #include <linux/of_iommu.h>
 #include <linux/of_irq.h>
 #include <linux/of_platform.h>
+#include <linux/pci.h>
 #include <linux/platform_device.h>
 #include <linux/pm_runtime.h>
 #include <linux/regmap.h>
@@ -53,6 +54,8 @@
 #define F_MMU_STANDARD_AXI_MODE_MASK		(BIT(3) | BIT(19))
 
 #define REG_MMU_DCM_DIS				0x050
+#define F_MMU_DCM				BIT(8)
+
 #define REG_MMU_WR_LEN_CTRL			0x054
 #define F_MMU_WR_THROT_DIS_MASK			(BIT(5) | BIT(21))
 
@@ -105,10 +108,15 @@
 #define REG_MMU1_INT_ID				0x154
 #define F_MMU_INT_ID_COMM_ID(a)			(((a) >> 9) & 0x7)
 #define F_MMU_INT_ID_SUB_COMM_ID(a)		(((a) >> 7) & 0x3)
+#define F_MMU_INT_ID_COMM_ID_EXT(a)		(((a) >> 10) & 0x7)
+#define F_MMU_INT_ID_SUB_COMM_ID_EXT(a)		(((a) >> 7) & 0x7)
 #define F_MMU_INT_ID_LARB_ID(a)			(((a) >> 7) & 0x7)
 #define F_MMU_INT_ID_PORT_ID(a)			(((a) >> 2) & 0x1f)
 
 #define MTK_PROTECT_PA_ALIGN			256
+#define MTK_IOMMU_BANK_SZ			0x1000
+
+#define PERICFG_IOMMU_1				0x714
 
 #define HAS_4GB_MODE			BIT(0)
 /* HW will use the EMI clock if there isn't the "bclk". */
@@ -116,25 +124,38 @@
 #define HAS_VLD_PA_RNG			BIT(2)
 #define RESET_AXI			BIT(3)
 #define OUT_ORDER_WR_EN			BIT(4)
-#define HAS_SUB_COMM			BIT(5)
-#define WR_THROT_EN			BIT(6)
-#define HAS_LEGACY_IVRP_PADDR		BIT(7)
-#define IOVA_34_EN			BIT(8)
-
-#define MTK_IOMMU_HAS_FLAG(pdata, _x) \
-		((((pdata)->flags) & (_x)) == (_x))
+#define HAS_SUB_COMM_2BITS		BIT(5)
+#define HAS_SUB_COMM_3BITS		BIT(6)
+#define WR_THROT_EN			BIT(7)
+#define HAS_LEGACY_IVRP_PADDR		BIT(8)
+#define IOVA_34_EN			BIT(9)
+#define SHARE_PGTABLE			BIT(10) /* 2 HW share pgtable */
+#define DCM_DISABLE			BIT(11)
+#define NOT_STD_AXI_MODE		BIT(12)
+/* 2 bits: iommu type */
+#define MTK_IOMMU_TYPE_MM		(0x0 << 13)
+#define MTK_IOMMU_TYPE_INFRA		(0x1 << 13)
+#define MTK_IOMMU_TYPE_MASK		(0x3 << 13)
+#define IFA_IOMMU_PCIe_SUPPORT		BIT(15)
+
+#define MTK_IOMMU_HAS_FLAG(pdata, _x)	(!!(((pdata)->flags) & (_x)))
+
+#define MTK_IOMMU_HAS_FLAG_MASK(pdata, _x, mask)	\
+				((((pdata)->flags) & (mask)) == (_x))
+#define MTK_IOMMU_IS_TYPE(pdata, _x)	MTK_IOMMU_HAS_FLAG_MASK(pdata, _x,\
+							MTK_IOMMU_TYPE_MASK)
 
 struct mtk_iommu_domain {
 	struct io_pgtable_cfg		cfg;
 	struct io_pgtable_ops		*iop;
 
-	struct mtk_iommu_data		*data;
+	struct mtk_iommu_bank_data	*bank;
 	struct iommu_domain		domain;
 };
 
 static const struct iommu_ops mtk_iommu_ops;
 
-static int mtk_iommu_hw_init(const struct mtk_iommu_data *data);
+static int mtk_iommu_hw_init(const struct mtk_iommu_data *data, unsigned int bankid);
 
 #define MTK_IOMMU_TLB_ADDR(iova) ({					\
 	dma_addr_t _addr = iova;					\
@@ -167,7 +188,7 @@ static int mtk_iommu_hw_init(const struct mtk_iommu_data *data);
 
 static LIST_HEAD(m4ulist);	/* List all the M4U HWs */
 
-#define for_each_m4u(data)	list_for_each_entry(data, &m4ulist, list)
+#define for_each_m4u(data, head)  list_for_each_entry(data, head, list)
 
 struct mtk_iommu_iova_region {
 	dma_addr_t		iova_base;
@@ -179,30 +200,21 @@ static const struct mtk_iommu_iova_region single_domain[] = {
 };
 
 static const struct mtk_iommu_iova_region mt8192_multi_dom[] = {
-	{ .iova_base = 0x0,		.size = SZ_4G},		/* disp: 0 ~ 4G */
+	{ .iova_base = 0x0,		.size = SZ_4G},		/* 0 ~ 4G */
 	#if IS_ENABLED(CONFIG_ARCH_DMA_ADDR_T_64BIT)
-	{ .iova_base = SZ_4G,		.size = SZ_4G},		/* vdec: 4G ~ 8G */
-	{ .iova_base = SZ_4G * 2,	.size = SZ_4G},		/* CAM/MDP: 8G ~ 12G */
+	{ .iova_base = SZ_4G,		.size = SZ_4G},		/* 4G ~ 8G */
+	{ .iova_base = SZ_4G * 2,	.size = SZ_4G},		/* 8G ~ 12G */
+	{ .iova_base = SZ_4G * 3,	.size = SZ_4G},		/* 12G ~ 16G */
+
 	{ .iova_base = 0x240000000ULL,	.size = 0x4000000},	/* CCU0 */
 	{ .iova_base = 0x244000000ULL,	.size = 0x4000000},	/* CCU1 */
 	#endif
 };
 
-/*
- * There may be 1 or 2 M4U HWs, But we always expect they are in the same domain
- * for the performance.
- *
- * Here always return the mtk_iommu_data of the first probed M4U where the
- * iommu domain information is recorded.
- */
-static struct mtk_iommu_data *mtk_iommu_get_m4u_data(void)
+/* If 2 M4U share a domain(use the same hwlist), Put the corresponding info in first data.*/
+static struct mtk_iommu_data *mtk_iommu_get_frst_data(struct list_head *hwlist)
 {
-	struct mtk_iommu_data *data;
-
-	for_each_m4u(data)
-		return data;
-
-	return NULL;
+	return list_first_entry(hwlist, struct mtk_iommu_data, list);
 }
 
 static struct mtk_iommu_domain *to_mtk_domain(struct iommu_domain *dom)
@@ -210,58 +222,71 @@ static struct mtk_iommu_domain *to_mtk_domain(struct iommu_domain *dom)
 	return container_of(dom, struct mtk_iommu_domain, domain);
 }
 
-static void mtk_iommu_tlb_flush_all(struct mtk_iommu_data *data)
+static void __mtk_iommu_tlb_flush_all(struct mtk_iommu_bank_data *bank)
 {
-	for_each_m4u(data) {
-		if (pm_runtime_get_if_in_use(data->dev) <= 0)
-			continue;
+	unsigned long flags;
 
-		writel_relaxed(F_INVLD_EN1 | F_INVLD_EN0,
-			       data->base + data->plat_data->inv_sel_reg);
-		writel_relaxed(F_ALL_INVLD, data->base + REG_MMU_INVALIDATE);
-		wmb(); /* Make sure the tlb flush all done */
+	spin_lock_irqsave(&bank->tlb_lock, flags);
+	writel_relaxed(F_INVLD_EN1 | F_INVLD_EN0,
+		       bank->base + bank->pdata->plat_data->inv_sel_reg);
+	writel_relaxed(F_ALL_INVLD, bank->base + REG_MMU_INVALIDATE);
+	wmb(); /* Make sure the tlb flush all done */
+	spin_unlock_irqrestore(&bank->tlb_lock, flags);
+}
 
-		pm_runtime_put(data->dev);
-	}
+static void mtk_iommu_tlb_flush_all(struct mtk_iommu_bank_data *bank)
+{
+	if (pm_runtime_get_if_in_use(bank->pdev) <= 0)
+		return;
+
+	__mtk_iommu_tlb_flush_all(bank);
+
+	pm_runtime_put(bank->pdev);
 }
 
 static void mtk_iommu_tlb_flush_range_sync(unsigned long iova, size_t size,
-					   size_t granule,
-					   struct mtk_iommu_data *data)
+					   struct mtk_iommu_bank_data *bank)
 {
-	bool has_pm = !!data->dev->pm_domain;
+	struct list_head *head = bank->pdata->hw_list;
+	bool has_pm = !!bank->pdev->pm_domain;
+	struct mtk_iommu_bank_data *curbank;
+	struct mtk_iommu_data *data;
 	unsigned long flags;
+	void __iomem *base;
 	int ret;
 	u32 tmp;
 
-	for_each_m4u(data) {
+	for_each_m4u(data, head) {
 		if (has_pm) {
 			if (pm_runtime_get_if_in_use(data->dev) <= 0)
 				continue;
 		}
 
-		spin_lock_irqsave(&data->tlb_lock, flags);
+		curbank = &data->bank[bank->id];
+		base = curbank->base;
+
+		spin_lock_irqsave(&curbank->tlb_lock, flags);
 		writel_relaxed(F_INVLD_EN1 | F_INVLD_EN0,
-			       data->base + data->plat_data->inv_sel_reg);
+			       base + data->plat_data->inv_sel_reg);
 
-		writel_relaxed(MTK_IOMMU_TLB_ADDR(iova),
-			       data->base + REG_MMU_INVLD_START_A);
+		writel_relaxed(MTK_IOMMU_TLB_ADDR(iova), base + REG_MMU_INVLD_START_A);
 		writel_relaxed(MTK_IOMMU_TLB_ADDR(iova + size - 1),
-			       data->base + REG_MMU_INVLD_END_A);
-		writel_relaxed(F_MMU_INV_RANGE,
-			       data->base + REG_MMU_INVALIDATE);
+			       base + REG_MMU_INVLD_END_A);
+		writel_relaxed(F_MMU_INV_RANGE, base + REG_MMU_INVALIDATE);
 
 		/* tlb sync */
-		ret = readl_poll_timeout_atomic(data->base + REG_MMU_CPE_DONE,
+		ret = readl_poll_timeout_atomic(base + REG_MMU_CPE_DONE,
 						tmp, tmp != 0, 10, 1000);
+
+		/* Clear the CPE status */
+		writel_relaxed(0, base + REG_MMU_CPE_DONE);
+		spin_unlock_irqrestore(&curbank->tlb_lock, flags);
+
 		if (ret) {
 			dev_warn(data->dev,
 				 "Partial TLB flush timed out, falling back to full flush\n");
-			mtk_iommu_tlb_flush_all(data);
+			__mtk_iommu_tlb_flush_all(curbank);
 		}
-		/* Clear the CPE status */
-		writel_relaxed(0, data->base + REG_MMU_CPE_DONE);
-		spin_unlock_irqrestore(&data->tlb_lock, flags);
 
 		if (has_pm)
 			pm_runtime_put(data->dev);
@@ -270,64 +295,96 @@ static void mtk_iommu_tlb_flush_range_sync(unsigned long iova, size_t size,
 
 static irqreturn_t mtk_iommu_isr(int irq, void *dev_id)
 {
-	struct mtk_iommu_data *data = dev_id;
-	struct mtk_iommu_domain *dom = data->m4u_dom;
-	unsigned int fault_larb, fault_port, sub_comm = 0;
+	struct mtk_iommu_bank_data *bank = dev_id;
+	struct mtk_iommu_data *data = bank->pdata;
+	struct mtk_iommu_domain *dom = bank->m4u_dom;
+	unsigned int fault_larb = 0, fault_port = 0, sub_comm = 0;
 	u32 int_state, regval, va34_32, pa34_32;
+	const struct mtk_iommu_plat_data *plat_data = data->plat_data;
+	void __iomem *base = bank->base;
 	u64 fault_iova, fault_pa;
 	bool layer, write;
 
 	/* Read error info from registers */
-	int_state = readl_relaxed(data->base + REG_MMU_FAULT_ST1);
+	int_state = readl_relaxed(base + REG_MMU_FAULT_ST1);
 	if (int_state & F_REG_MMU0_FAULT_MASK) {
-		regval = readl_relaxed(data->base + REG_MMU0_INT_ID);
-		fault_iova = readl_relaxed(data->base + REG_MMU0_FAULT_VA);
-		fault_pa = readl_relaxed(data->base + REG_MMU0_INVLD_PA);
+		regval = readl_relaxed(base + REG_MMU0_INT_ID);
+		fault_iova = readl_relaxed(base + REG_MMU0_FAULT_VA);
+		fault_pa = readl_relaxed(base + REG_MMU0_INVLD_PA);
 	} else {
-		regval = readl_relaxed(data->base + REG_MMU1_INT_ID);
-		fault_iova = readl_relaxed(data->base + REG_MMU1_FAULT_VA);
-		fault_pa = readl_relaxed(data->base + REG_MMU1_INVLD_PA);
+		regval = readl_relaxed(base + REG_MMU1_INT_ID);
+		fault_iova = readl_relaxed(base + REG_MMU1_FAULT_VA);
+		fault_pa = readl_relaxed(base + REG_MMU1_INVLD_PA);
 	}
 	layer = fault_iova & F_MMU_FAULT_VA_LAYER_BIT;
 	write = fault_iova & F_MMU_FAULT_VA_WRITE_BIT;
-	if (MTK_IOMMU_HAS_FLAG(data->plat_data, IOVA_34_EN)) {
+	if (MTK_IOMMU_HAS_FLAG(plat_data, IOVA_34_EN)) {
 		va34_32 = FIELD_GET(F_MMU_INVAL_VA_34_32_MASK, fault_iova);
-		pa34_32 = FIELD_GET(F_MMU_INVAL_PA_34_32_MASK, fault_iova);
 		fault_iova = fault_iova & F_MMU_INVAL_VA_31_12_MASK;
 		fault_iova |= (u64)va34_32 << 32;
-		fault_pa |= (u64)pa34_32 << 32;
 	}
-
-	fault_port = F_MMU_INT_ID_PORT_ID(regval);
-	if (MTK_IOMMU_HAS_FLAG(data->plat_data, HAS_SUB_COMM)) {
-		fault_larb = F_MMU_INT_ID_COMM_ID(regval);
-		sub_comm = F_MMU_INT_ID_SUB_COMM_ID(regval);
-	} else {
-		fault_larb = F_MMU_INT_ID_LARB_ID(regval);
+	pa34_32 = FIELD_GET(F_MMU_INVAL_PA_34_32_MASK, fault_iova);
+	fault_pa |= (u64)pa34_32 << 32;
+
+	if (MTK_IOMMU_IS_TYPE(plat_data, MTK_IOMMU_TYPE_MM)) {
+		fault_port = F_MMU_INT_ID_PORT_ID(regval);
+		if (MTK_IOMMU_HAS_FLAG(plat_data, HAS_SUB_COMM_2BITS)) {
+			fault_larb = F_MMU_INT_ID_COMM_ID(regval);
+			sub_comm = F_MMU_INT_ID_SUB_COMM_ID(regval);
+		} else if (MTK_IOMMU_HAS_FLAG(plat_data, HAS_SUB_COMM_3BITS)) {
+			fault_larb = F_MMU_INT_ID_COMM_ID_EXT(regval);
+			sub_comm = F_MMU_INT_ID_SUB_COMM_ID_EXT(regval);
+		} else {
+			fault_larb = F_MMU_INT_ID_LARB_ID(regval);
+		}
+		fault_larb = data->plat_data->larbid_remap[fault_larb][sub_comm];
 	}
-	fault_larb = data->plat_data->larbid_remap[fault_larb][sub_comm];
 
-	if (report_iommu_fault(&dom->domain, data->dev, fault_iova,
+	if (report_iommu_fault(&dom->domain, bank->pdev, fault_iova,
 			       write ? IOMMU_FAULT_WRITE : IOMMU_FAULT_READ)) {
 		dev_err_ratelimited(
-			data->dev,
-			"fault type=0x%x iova=0x%llx pa=0x%llx larb=%d port=%d layer=%d %s\n",
-			int_state, fault_iova, fault_pa, fault_larb, fault_port,
+			bank->pdev,
+			"fault type=0x%x iova=0x%llx pa=0x%llx master=0x%x(larb=%d port=%d) layer=%d %s\n",
+			int_state, fault_iova, fault_pa, regval, fault_larb, fault_port,
 			layer, write ? "write" : "read");
 	}
 
 	/* Interrupt clear */
-	regval = readl_relaxed(data->base + REG_MMU_INT_CONTROL0);
+	regval = readl_relaxed(base + REG_MMU_INT_CONTROL0);
 	regval |= F_INT_CLR_BIT;
-	writel_relaxed(regval, data->base + REG_MMU_INT_CONTROL0);
+	writel_relaxed(regval, base + REG_MMU_INT_CONTROL0);
 
-	mtk_iommu_tlb_flush_all(data);
+	mtk_iommu_tlb_flush_all(bank);
 
 	return IRQ_HANDLED;
 }
 
-static int mtk_iommu_get_domain_id(struct device *dev,
-				   const struct mtk_iommu_plat_data *plat_data)
+static unsigned int mtk_iommu_get_bank_id(struct device *dev,
+					  const struct mtk_iommu_plat_data *plat_data)
+{
+	struct iommu_fwspec *fwspec = dev_iommu_fwspec_get(dev);
+	unsigned int i, portmsk = 0, bankid = 0; /* bank default is 0 */
+
+	if (plat_data->bank_nr == 1)
+		return bankid;
+
+	for (i = 0; i < fwspec->num_ids; i++)
+		portmsk |= BIT(MTK_M4U_TO_PORT(fwspec->ids[i]));
+
+	for (i = 0; i < plat_data->bank_nr; i++) {
+		if (!plat_data->bank_enable[i])
+			continue;
+
+		if (portmsk & plat_data->bank_portmsk[i]) {
+			bankid = i;
+			break;
+		}
+	}
+	return bankid;
+}
+
+static int mtk_iommu_get_iova_region_id(struct device *dev,
+					const struct mtk_iommu_plat_data *plat_data)
 {
 	const struct mtk_iommu_iova_region *rgn = plat_data->iova_region;
 	const struct bus_dma_region *dma_rgn = dev->dma_range_map;
@@ -356,46 +413,66 @@ static int mtk_iommu_get_domain_id(struct device *dev,
 	return -EINVAL;
 }
 
-static void mtk_iommu_config(struct mtk_iommu_data *data, struct device *dev,
-			     bool enable, unsigned int domid)
+static int mtk_iommu_config(struct mtk_iommu_data *data, struct device *dev,
+			    bool enable, unsigned int regionid)
 {
 	struct mtk_smi_larb_iommu    *larb_mmu;
 	unsigned int                 larbid, portid;
 	struct iommu_fwspec *fwspec = dev_iommu_fwspec_get(dev);
 	const struct mtk_iommu_iova_region *region;
-	int i;
+	u32 peri_mmuen, peri_mmuen_msk;
+	int i, ret = 0;
 
 	for (i = 0; i < fwspec->num_ids; ++i) {
 		larbid = MTK_M4U_TO_LARB(fwspec->ids[i]);
 		portid = MTK_M4U_TO_PORT(fwspec->ids[i]);
 
-		larb_mmu = &data->larb_imu[larbid];
-
-		region = data->plat_data->iova_region + domid;
-		larb_mmu->bank[portid] = upper_32_bits(region->iova_base);
-
-		dev_dbg(dev, "%s iommu for larb(%s) port %d dom %d bank %d.\n",
-			enable ? "enable" : "disable", dev_name(larb_mmu->dev),
-			portid, domid, larb_mmu->bank[portid]);
-
-		if (enable)
-			larb_mmu->mmu |= MTK_SMI_MMU_EN(portid);
-		else
-			larb_mmu->mmu &= ~MTK_SMI_MMU_EN(portid);
+		if (MTK_IOMMU_IS_TYPE(data->plat_data, MTK_IOMMU_TYPE_MM)) {
+			larb_mmu = &data->larb_imu[larbid];
+
+			region = data->plat_data->iova_region + regionid;
+			larb_mmu->bank[portid] = upper_32_bits(region->iova_base);
+
+			dev_dbg(dev, "%s iommu for larb(%s) port %d region %d rgn-bank %d.\n",
+				enable ? "enable" : "disable", dev_name(larb_mmu->dev),
+				portid, regionid, larb_mmu->bank[portid]);
+
+			if (enable)
+				larb_mmu->mmu |= MTK_SMI_MMU_EN(portid);
+			else
+				larb_mmu->mmu &= ~MTK_SMI_MMU_EN(portid);
+		} else if (MTK_IOMMU_IS_TYPE(data->plat_data, MTK_IOMMU_TYPE_INFRA)) {
+			peri_mmuen_msk = BIT(portid);
+
+			/* PCIdev has only one output id, enable the next writing bit for PCIe */
+			if (dev_is_pci(dev))
+				peri_mmuen_msk |= BIT(portid + 1);
+
+			peri_mmuen = enable ? peri_mmuen_msk : 0;
+			ret = regmap_update_bits(data->pericfg, PERICFG_IOMMU_1,
+						 peri_mmuen_msk, peri_mmuen);
+			if (ret)
+				dev_err(dev, "%s iommu(%s) inframaster 0x%x fail(%d).\n",
+					enable ? "enable" : "disable",
+					dev_name(data->dev), peri_mmuen_msk, ret);
+		}
 	}
+	return ret;
 }
 
 static int mtk_iommu_domain_finalise(struct mtk_iommu_domain *dom,
 				     struct mtk_iommu_data *data,
-				     unsigned int domid)
+				     unsigned int region_id)
 {
 	const struct mtk_iommu_iova_region *region;
-
-	/* Use the exist domain as there is only one pgtable here. */
-	if (data->m4u_dom) {
-		dom->iop = data->m4u_dom->iop;
-		dom->cfg = data->m4u_dom->cfg;
-		dom->domain.pgsize_bitmap = data->m4u_dom->cfg.pgsize_bitmap;
+	struct mtk_iommu_domain	*m4u_dom;
+
+	/* Always use bank0 in sharing pgtable case */
+	m4u_dom = data->bank[0].m4u_dom;
+	if (m4u_dom) {
+		dom->iop = m4u_dom->iop;
+		dom->cfg = m4u_dom->cfg;
+		dom->domain.pgsize_bitmap = m4u_dom->cfg.pgsize_bitmap;
 		goto update_iova_region;
 	}
 
@@ -424,7 +501,7 @@ static int mtk_iommu_domain_finalise(struct mtk_iommu_domain *dom,
 
 update_iova_region:
 	/* Update the iova region for this domain */
-	region = data->plat_data->iova_region + domid;
+	region = data->plat_data->iova_region + region_id;
 	dom->domain.geometry.aperture_start = region->iova_base;
 	dom->domain.geometry.aperture_end = region->iova_base + region->size - 1;
 	dom->domain.geometry.force_aperture = true;
@@ -459,40 +536,47 @@ static void mtk_iommu_domain_free(struct iommu_domain *domain)
 static int mtk_iommu_attach_device(struct iommu_domain *domain,
 				   struct device *dev)
 {
-	struct mtk_iommu_data *data = dev_iommu_priv_get(dev);
+	struct mtk_iommu_data *data = dev_iommu_priv_get(dev), *frstdata;
 	struct mtk_iommu_domain *dom = to_mtk_domain(domain);
+	struct list_head *hw_list = data->hw_list;
+	struct mtk_iommu_bank_data *bank;
 	struct device *m4udev = data->dev;
-	int ret, domid;
+	unsigned int bankid;
+	int ret, region_id;
+
+	region_id = mtk_iommu_get_iova_region_id(dev, data->plat_data);
+	if (region_id < 0)
+		return region_id;
 
-	domid = mtk_iommu_get_domain_id(dev, data->plat_data);
-	if (domid < 0)
-		return domid;
+	bankid = mtk_iommu_get_bank_id(dev, data->plat_data);
+	bank = &data->bank[bankid];
+	if (!dom->bank) {
+		/* Data is in the frstdata in sharing pgtable case. */
+		frstdata = mtk_iommu_get_frst_data(hw_list);
 
-	if (!dom->data) {
-		if (mtk_iommu_domain_finalise(dom, data, domid))
+		if (mtk_iommu_domain_finalise(dom, frstdata, region_id))
 			return -ENODEV;
-		dom->data = data;
+		dom->bank = bank;
 	}
 
-	if (!data->m4u_dom) { /* Initialize the M4U HW */
+	if (!bank->m4u_dom) { /* Initialize the M4U HW for each a BANK */
 		ret = pm_runtime_resume_and_get(m4udev);
 		if (ret < 0)
 			return ret;
 
-		ret = mtk_iommu_hw_init(data);
+		ret = mtk_iommu_hw_init(data, bankid);
 		if (ret) {
 			pm_runtime_put(m4udev);
 			return ret;
 		}
-		data->m4u_dom = dom;
+		bank->m4u_dom = dom;
 		writel(dom->cfg.arm_v7s_cfg.ttbr & MMU_PT_ADDR_MASK,
-		       data->base + REG_MMU_PT_BASE_ADDR);
+		       bank->base + REG_MMU_PT_BASE_ADDR);
 
 		pm_runtime_put(m4udev);
 	}
 
-	mtk_iommu_config(data, dev, true, domid);
-	return 0;
+	return mtk_iommu_config(data, dev, true, region_id);
 }
 
 static void mtk_iommu_detach_device(struct iommu_domain *domain,
@@ -509,7 +593,7 @@ static int mtk_iommu_map(struct iommu_domain *domain, unsigned long iova,
 	struct mtk_iommu_domain *dom = to_mtk_domain(domain);
 
 	/* The "4GB mode" M4U physically can not use the lower remap of Dram. */
-	if (dom->data->enable_4GB)
+	if (dom->bank->pdata->enable_4GB)
 		paddr |= BIT_ULL(32);
 
 	/* Synchronize with the tlb_lock */
@@ -534,7 +618,7 @@ static void mtk_iommu_flush_iotlb_all(struct iommu_domain *domain)
 {
 	struct mtk_iommu_domain *dom = to_mtk_domain(domain);
 
-	mtk_iommu_tlb_flush_all(dom->data);
+	mtk_iommu_tlb_flush_all(dom->bank);
 }
 
 static void mtk_iommu_iotlb_sync(struct iommu_domain *domain,
@@ -543,8 +627,7 @@ static void mtk_iommu_iotlb_sync(struct iommu_domain *domain,
 	struct mtk_iommu_domain *dom = to_mtk_domain(domain);
 	size_t length = gather->end - gather->start + 1;
 
-	mtk_iommu_tlb_flush_range_sync(gather->start, length, gather->pgsize,
-				       dom->data);
+	mtk_iommu_tlb_flush_range_sync(gather->start, length, dom->bank);
 }
 
 static void mtk_iommu_sync_map(struct iommu_domain *domain, unsigned long iova,
@@ -552,7 +635,7 @@ static void mtk_iommu_sync_map(struct iommu_domain *domain, unsigned long iova,
 {
 	struct mtk_iommu_domain *dom = to_mtk_domain(domain);
 
-	mtk_iommu_tlb_flush_range_sync(iova, size, size, dom->data);
+	mtk_iommu_tlb_flush_range_sync(iova, size, dom->bank);
 }
 
 static phys_addr_t mtk_iommu_iova_to_phys(struct iommu_domain *domain,
@@ -562,7 +645,7 @@ static phys_addr_t mtk_iommu_iova_to_phys(struct iommu_domain *domain,
 	phys_addr_t pa;
 
 	pa = dom->iop->iova_to_phys(dom->iop, iova);
-	if (dom->data->enable_4GB && pa >= MTK_IOMMU_4GB_MODE_REMAP_BASE)
+	if (dom->bank->pdata->enable_4GB && pa >= MTK_IOMMU_4GB_MODE_REMAP_BASE)
 		pa &= ~BIT_ULL(32);
 
 	return pa;
@@ -586,12 +669,14 @@ static struct iommu_device *mtk_iommu_probe_device(struct device *dev)
 	 * The device in each a larb is a independent HW. thus only link
 	 * one larb here.
 	 */
-	larbid = MTK_M4U_TO_LARB(fwspec->ids[0]);
-	larbdev = data->larb_imu[larbid].dev;
-	link = device_link_add(dev, larbdev,
-			       DL_FLAG_PM_RUNTIME | DL_FLAG_STATELESS);
-	if (!link)
-		dev_err(dev, "Unable to link %s\n", dev_name(larbdev));
+	if (MTK_IOMMU_IS_TYPE(data->plat_data, MTK_IOMMU_TYPE_MM)) {
+		larbid = MTK_M4U_TO_LARB(fwspec->ids[0]);
+		larbdev = data->larb_imu[larbid].dev;
+		link = device_link_add(dev, larbdev,
+				DL_FLAG_PM_RUNTIME | DL_FLAG_STATELESS);
+		if (!link)
+			dev_err(dev, "Unable to link %s\n", dev_name(larbdev));
+	}
 	return &data->iommu;
 }
 
@@ -606,31 +691,43 @@ static void mtk_iommu_release_device(struct device *dev)
 		return;
 
 	data = dev_iommu_priv_get(dev);
-	larbid = MTK_M4U_TO_LARB(fwspec->ids[0]);
-	larbdev = data->larb_imu[larbid].dev;
-	device_link_remove(dev, larbdev);
+
+	if (MTK_IOMMU_IS_TYPE(data->plat_data, MTK_IOMMU_TYPE_MM)) {
+		larbid = MTK_M4U_TO_LARB(fwspec->ids[0]);
+		larbdev = data->larb_imu[larbid].dev;
+		device_link_remove(dev, larbdev);
+	}
 
 	iommu_fwspec_free(dev);
 }
 
 static struct iommu_group *mtk_iommu_device_group(struct device *dev)
 {
-	struct mtk_iommu_data *data = mtk_iommu_get_m4u_data();
+	struct mtk_iommu_data *c_data = dev_iommu_priv_get(dev), *data;
+	struct list_head *hw_list = c_data->hw_list;
 	struct iommu_group *group;
-	int domid;
+	unsigned int bankid, groupid;
+	int regionid;
 
+	data = mtk_iommu_get_frst_data(hw_list);
 	if (!data)
 		return ERR_PTR(-ENODEV);
 
-	domid = mtk_iommu_get_domain_id(dev, data->plat_data);
-	if (domid < 0)
-		return ERR_PTR(domid);
+	regionid = mtk_iommu_get_iova_region_id(dev, data->plat_data);
+	if (regionid < 0)
+		return ERR_PTR(regionid);
+	bankid = mtk_iommu_get_bank_id(dev, data->plat_data);
 
-	group = data->m4u_group[domid];
+	/*
+	 * If the bank function is enabled, each a bank is a iommu group/domain.
+	 * otherwise, each a iova region is a iommu group/domain.
+	 */
+	groupid = bankid ? bankid : regionid;
+	group = data->m4u_group[groupid];
 	if (!group) {
 		group = iommu_group_alloc();
 		if (!IS_ERR(group))
-			data->m4u_group[domid] = group;
+			data->m4u_group[groupid] = group;
 	} else {
 		iommu_group_ref_get(group);
 	}
@@ -663,14 +760,14 @@ static void mtk_iommu_get_resv_regions(struct device *dev,
 				       struct list_head *head)
 {
 	struct mtk_iommu_data *data = dev_iommu_priv_get(dev);
-	unsigned int domid = mtk_iommu_get_domain_id(dev, data->plat_data), i;
+	unsigned int regionid = mtk_iommu_get_iova_region_id(dev, data->plat_data), i;
 	const struct mtk_iommu_iova_region *resv, *curdom;
 	struct iommu_resv_region *region;
 	int prot = IOMMU_WRITE | IOMMU_READ;
 
-	if ((int)domid < 0)
+	if ((int)regionid < 0)
 		return;
-	curdom = data->plat_data->iova_region + domid;
+	curdom = data->plat_data->iova_region + regionid;
 	for (i = 0; i < data->plat_data->iova_region_nr; i++) {
 		resv = data->plat_data->iova_region + i;
 
@@ -709,42 +806,24 @@ static const struct iommu_ops mtk_iommu_ops = {
 	.owner		= THIS_MODULE,
 };
 
-static int mtk_iommu_hw_init(const struct mtk_iommu_data *data)
+static int mtk_iommu_hw_init(const struct mtk_iommu_data *data, unsigned int bankid)
 {
+	const struct mtk_iommu_bank_data *bankx = &data->bank[bankid];
+	const struct mtk_iommu_bank_data *bank0 = &data->bank[0];
 	u32 regval;
 
+	/*
+	 * Global control settings are in bank0. May re-init these global registers
+	 * since no sure if there is bank0 consumers.
+	 */
 	if (data->plat_data->m4u_plat == M4U_MT8173) {
 		regval = F_MMU_PREFETCH_RT_REPLACE_MOD |
 			 F_MMU_TF_PROT_TO_PROGRAM_ADDR_MT8173;
 	} else {
-		regval = readl_relaxed(data->base + REG_MMU_CTRL_REG);
+		regval = readl_relaxed(bank0->base + REG_MMU_CTRL_REG);
 		regval |= F_MMU_TF_PROT_TO_PROGRAM_ADDR;
 	}
-	writel_relaxed(regval, data->base + REG_MMU_CTRL_REG);
-
-	regval = F_L2_MULIT_HIT_EN |
-		F_TABLE_WALK_FAULT_INT_EN |
-		F_PREETCH_FIFO_OVERFLOW_INT_EN |
-		F_MISS_FIFO_OVERFLOW_INT_EN |
-		F_PREFETCH_FIFO_ERR_INT_EN |
-		F_MISS_FIFO_ERR_INT_EN;
-	writel_relaxed(regval, data->base + REG_MMU_INT_CONTROL0);
-
-	regval = F_INT_TRANSLATION_FAULT |
-		F_INT_MAIN_MULTI_HIT_FAULT |
-		F_INT_INVALID_PA_FAULT |
-		F_INT_ENTRY_REPLACEMENT_FAULT |
-		F_INT_TLB_MISS_FAULT |
-		F_INT_MISS_TRANSACTION_FIFO_FAULT |
-		F_INT_PRETETCH_TRANSATION_FIFO_FAULT;
-	writel_relaxed(regval, data->base + REG_MMU_INT_MAIN_CONTROL);
-
-	if (MTK_IOMMU_HAS_FLAG(data->plat_data, HAS_LEGACY_IVRP_PADDR))
-		regval = (data->protect_base >> 1) | (data->enable_4GB << 31);
-	else
-		regval = lower_32_bits(data->protect_base) |
-			 upper_32_bits(data->protect_base);
-	writel_relaxed(regval, data->base + REG_MMU_IVRP_PADDR);
+	writel_relaxed(regval, bank0->base + REG_MMU_CTRL_REG);
 
 	if (data->enable_4GB &&
 	    MTK_IOMMU_HAS_FLAG(data->plat_data, HAS_VLD_PA_RNG)) {
@@ -753,31 +832,61 @@ static int mtk_iommu_hw_init(const struct mtk_iommu_data *data)
 		 * 0x1_0000_0000 to 0x1_ffff_ffff. here record bit[32:30].
 		 */
 		regval = F_MMU_VLD_PA_RNG(7, 4);
-		writel_relaxed(regval, data->base + REG_MMU_VLD_PA_RNG);
+		writel_relaxed(regval, bank0->base + REG_MMU_VLD_PA_RNG);
 	}
-	writel_relaxed(0, data->base + REG_MMU_DCM_DIS);
+	if (MTK_IOMMU_HAS_FLAG(data->plat_data, DCM_DISABLE))
+		writel_relaxed(F_MMU_DCM, bank0->base + REG_MMU_DCM_DIS);
+	else
+		writel_relaxed(0, bank0->base + REG_MMU_DCM_DIS);
+
 	if (MTK_IOMMU_HAS_FLAG(data->plat_data, WR_THROT_EN)) {
 		/* write command throttling mode */
-		regval = readl_relaxed(data->base + REG_MMU_WR_LEN_CTRL);
+		regval = readl_relaxed(bank0->base + REG_MMU_WR_LEN_CTRL);
 		regval &= ~F_MMU_WR_THROT_DIS_MASK;
-		writel_relaxed(regval, data->base + REG_MMU_WR_LEN_CTRL);
+		writel_relaxed(regval, bank0->base + REG_MMU_WR_LEN_CTRL);
 	}
 
 	if (MTK_IOMMU_HAS_FLAG(data->plat_data, RESET_AXI)) {
 		/* The register is called STANDARD_AXI_MODE in this case */
 		regval = 0;
 	} else {
-		regval = readl_relaxed(data->base + REG_MMU_MISC_CTRL);
-		regval &= ~F_MMU_STANDARD_AXI_MODE_MASK;
+		regval = readl_relaxed(bank0->base + REG_MMU_MISC_CTRL);
+		if (MTK_IOMMU_HAS_FLAG(data->plat_data, NOT_STD_AXI_MODE))
+			regval &= ~F_MMU_STANDARD_AXI_MODE_MASK;
 		if (MTK_IOMMU_HAS_FLAG(data->plat_data, OUT_ORDER_WR_EN))
 			regval &= ~F_MMU_IN_ORDER_WR_EN_MASK;
 	}
-	writel_relaxed(regval, data->base + REG_MMU_MISC_CTRL);
+	writel_relaxed(regval, bank0->base + REG_MMU_MISC_CTRL);
+
+	/* Independent settings for each bank */
+	regval = F_L2_MULIT_HIT_EN |
+		F_TABLE_WALK_FAULT_INT_EN |
+		F_PREETCH_FIFO_OVERFLOW_INT_EN |
+		F_MISS_FIFO_OVERFLOW_INT_EN |
+		F_PREFETCH_FIFO_ERR_INT_EN |
+		F_MISS_FIFO_ERR_INT_EN;
+	writel_relaxed(regval, bankx->base + REG_MMU_INT_CONTROL0);
+
+	regval = F_INT_TRANSLATION_FAULT |
+		F_INT_MAIN_MULTI_HIT_FAULT |
+		F_INT_INVALID_PA_FAULT |
+		F_INT_ENTRY_REPLACEMENT_FAULT |
+		F_INT_TLB_MISS_FAULT |
+		F_INT_MISS_TRANSACTION_FIFO_FAULT |
+		F_INT_PRETETCH_TRANSATION_FIFO_FAULT;
+	writel_relaxed(regval, bankx->base + REG_MMU_INT_MAIN_CONTROL);
+
+	if (MTK_IOMMU_HAS_FLAG(data->plat_data, HAS_LEGACY_IVRP_PADDR))
+		regval = (data->protect_base >> 1) | (data->enable_4GB << 31);
+	else
+		regval = lower_32_bits(data->protect_base) |
+			 upper_32_bits(data->protect_base);
+	writel_relaxed(regval, bankx->base + REG_MMU_IVRP_PADDR);
 
-	if (devm_request_irq(data->dev, data->irq, mtk_iommu_isr, 0,
-			     dev_name(data->dev), (void *)data)) {
-		writel_relaxed(0, data->base + REG_MMU_PT_BASE_ADDR);
-		dev_err(data->dev, "Failed @ IRQ-%d Request\n", data->irq);
+	if (devm_request_irq(bankx->pdev, bankx->irq, mtk_iommu_isr, 0,
+			     dev_name(bankx->pdev), (void *)bankx)) {
+		writel_relaxed(0, bankx->base + REG_MMU_PT_BASE_ADDR);
+		dev_err(bankx->pdev, "Failed @ IRQ-%d Request\n", bankx->irq);
 		return -ENODEV;
 	}
 
@@ -789,21 +898,90 @@ static const struct component_master_ops mtk_iommu_com_ops = {
 	.unbind		= mtk_iommu_unbind,
 };
 
+static int mtk_iommu_mm_dts_parse(struct device *dev,
+				  struct component_match **match,
+				  struct mtk_iommu_data *data)
+{
+	struct platform_device	*plarbdev;
+	struct device_link	*link;
+	struct device_node *larbnode, *smicomm_node;
+	int i, larb_nr, ret;
+
+	larb_nr = of_count_phandle_with_args(dev->of_node, "mediatek,larbs", NULL);
+	if (larb_nr < 0)
+		return larb_nr;
+
+	for (i = 0; i < larb_nr; i++) {
+		u32 id;
+
+		larbnode = of_parse_phandle(dev->of_node, "mediatek,larbs", i);
+		if (!larbnode)
+			return -EINVAL;
+
+		if (!of_device_is_available(larbnode)) {
+			of_node_put(larbnode);
+			continue;
+		}
+
+		ret = of_property_read_u32(larbnode, "mediatek,larb-id", &id);
+		if (ret)/* The id is consecutive if there is no this property */
+			id = i;
+
+		plarbdev = of_find_device_by_node(larbnode);
+		if (!plarbdev || !plarbdev->dev.driver) {
+			of_node_put(larbnode);
+			return -EPROBE_DEFER;
+		}
+		data->larb_imu[id].dev = &plarbdev->dev;
+
+		component_match_add_release(dev, match, release_of,
+					    compare_of, larbnode);
+	}
+
+	/* Get smi-common dev from the last larb. */
+	smicomm_node = of_parse_phandle(larbnode, "mediatek,smi", 0);
+	if (!smicomm_node)
+		return -EINVAL;
+
+	/* Find smi-common again if this is smi-sub-common */
+	if (of_property_read_bool(smicomm_node, "mediatek,smi_sub_common")) {
+		of_node_put(smicomm_node); /* put the sub common */
+
+		smicomm_node = of_parse_phandle(smicomm_node, "mediatek,smi", 0);
+		if (!smicomm_node) {
+			dev_err(dev, "sub-comm has no common.\n");
+			return -EINVAL;
+		}
+	}
+
+	plarbdev = of_find_device_by_node(smicomm_node);
+	of_node_put(smicomm_node);
+	data->smicomm_dev = &plarbdev->dev;
+
+	link = device_link_add(data->smicomm_dev, dev,
+			       DL_FLAG_STATELESS | DL_FLAG_PM_RUNTIME);
+
+	if (!link) {
+		dev_err(dev, "Unable link %s.\n", dev_name(data->smicomm_dev));
+		return PTR_ERR(link);
+	}
+	return 0;
+}
+
 static int mtk_iommu_probe(struct platform_device *pdev)
 {
 	struct mtk_iommu_data   *data;
 	struct device           *dev = &pdev->dev;
-	struct device_node	*larbnode, *smicomm_node;
-	struct platform_device	*plarbdev;
-	struct device_link	*link;
 	struct resource         *res;
-	resource_size_t		ioaddr;
+	resource_size_t		ioaddr, size;
 	struct component_match  *match = NULL;
 	struct regmap		*infracfg;
 	void                    *protect;
-	int                     i, larb_nr, ret;
+	int                     ret, i = 0;
 	u32			val;
 	char                    *p;
+	struct mtk_iommu_bank_data *bank;
+	void __iomem		*base;
 
 	data = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);
 	if (!data)
@@ -841,14 +1019,31 @@ static int mtk_iommu_probe(struct platform_device *pdev)
 	}
 
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	data->base = devm_ioremap_resource(dev, res);
-	if (IS_ERR(data->base))
-		return PTR_ERR(data->base);
+	size = resource_size(res);
+	if (size < data->plat_data->bank_nr * MTK_IOMMU_BANK_SZ) {
+		dev_err(dev, "banknr %d. res %pR is not enough.\n",
+			data->plat_data->bank_nr, res);
+		return -EINVAL;
+	}
+	base = devm_ioremap_resource(dev, res);
+	if (IS_ERR(base))
+		return PTR_ERR(base);
 	ioaddr = res->start;
 
-	data->irq = platform_get_irq(pdev, 0);
-	if (data->irq < 0)
-		return data->irq;
+	do {
+		if (!data->plat_data->bank_enable[i])
+			continue;
+		bank = &data->bank[i];
+		bank->id = i;
+		bank->base = base + i * MTK_IOMMU_BANK_SZ;
+
+		bank->irq = platform_get_irq(pdev, i);
+		if (bank->irq < 0)
+			return bank->irq;
+		bank->pdev = dev;
+		bank->pdata = data;
+		spin_lock_init(&bank->tlb_lock);
+	} while (++i < data->plat_data->bank_nr);
 
 	if (MTK_IOMMU_HAS_FLAG(data->plat_data, HAS_BCLK)) {
 		data->bclk = devm_clk_get(dev, "bclk");
@@ -856,55 +1051,21 @@ static int mtk_iommu_probe(struct platform_device *pdev)
 			return PTR_ERR(data->bclk);
 	}
 
-	larb_nr = of_count_phandle_with_args(dev->of_node,
-					     "mediatek,larbs", NULL);
-	if (larb_nr < 0)
-		return larb_nr;
-
-	for (i = 0; i < larb_nr; i++) {
-		u32 id;
-
-		larbnode = of_parse_phandle(dev->of_node, "mediatek,larbs", i);
-		if (!larbnode)
-			return -EINVAL;
-
-		if (!of_device_is_available(larbnode)) {
-			of_node_put(larbnode);
-			continue;
-		}
-
-		ret = of_property_read_u32(larbnode, "mediatek,larb-id", &id);
-		if (ret)/* The id is consecutive if there is no this property */
-			id = i;
+	pm_runtime_enable(dev);
 
-		plarbdev = of_find_device_by_node(larbnode);
-		if (!plarbdev || !plarbdev->dev.driver) {
-			of_node_put(larbnode);
-			return -EPROBE_DEFER;
+	if (MTK_IOMMU_IS_TYPE(data->plat_data, MTK_IOMMU_TYPE_MM)) {
+		ret = mtk_iommu_mm_dts_parse(dev, &match, data);
+		if (ret)
+			goto out_runtime_disable;
+	} else if (MTK_IOMMU_IS_TYPE(data->plat_data, MTK_IOMMU_TYPE_INFRA) &&
+		   data->plat_data->pericfg_comp_str) {
+		infracfg = syscon_regmap_lookup_by_compatible(data->plat_data->pericfg_comp_str);
+		if (IS_ERR(infracfg)) {
+			ret = PTR_ERR(infracfg);
+			goto out_runtime_disable;
 		}
-		data->larb_imu[id].dev = &plarbdev->dev;
-
-		component_match_add_release(dev, &match, release_of,
-					    compare_of, larbnode);
-	}
-
-	/* Get smi-common dev from the last larb. */
-	smicomm_node = of_parse_phandle(larbnode, "mediatek,smi", 0);
-	if (!smicomm_node)
-		return -EINVAL;
-
-	plarbdev = of_find_device_by_node(smicomm_node);
-	of_node_put(smicomm_node);
-	data->smicomm_dev = &plarbdev->dev;
-
-	pm_runtime_enable(dev);
 
-	link = device_link_add(data->smicomm_dev, dev,
-			DL_FLAG_STATELESS | DL_FLAG_PM_RUNTIME);
-	if (!link) {
-		dev_err(dev, "Unable to link %s.\n", dev_name(data->smicomm_dev));
-		ret = -EINVAL;
-		goto out_runtime_disable;
+		data->pericfg = infracfg;
 	}
 
 	platform_set_drvdata(pdev, data);
@@ -921,8 +1082,14 @@ static int mtk_iommu_probe(struct platform_device *pdev)
 	if (ret)
 		goto out_sysfs_remove;
 
-	spin_lock_init(&data->tlb_lock);
-	list_add_tail(&data->list, &m4ulist);
+	if (MTK_IOMMU_HAS_FLAG(data->plat_data, SHARE_PGTABLE)) {
+		list_add_tail(&data->list, data->plat_data->hw_list);
+		data->hw_list = data->plat_data->hw_list;
+	} else {
+		INIT_LIST_HEAD(&data->hw_list_head);
+		list_add_tail(&data->list, &data->hw_list_head);
+		data->hw_list = &data->hw_list_head;
+	}
 
 	if (!iommu_present(&platform_bus_type)) {
 		ret = bus_set_iommu(&platform_bus_type, &mtk_iommu_ops);
@@ -930,9 +1097,20 @@ static int mtk_iommu_probe(struct platform_device *pdev)
 			goto out_list_del;
 	}
 
-	ret = component_master_add_with_match(dev, &mtk_iommu_com_ops, match);
-	if (ret)
-		goto out_bus_set_null;
+	if (MTK_IOMMU_IS_TYPE(data->plat_data, MTK_IOMMU_TYPE_MM)) {
+		ret = component_master_add_with_match(dev, &mtk_iommu_com_ops, match);
+		if (ret)
+			goto out_bus_set_null;
+	} else if (MTK_IOMMU_IS_TYPE(data->plat_data, MTK_IOMMU_TYPE_INFRA) &&
+		   MTK_IOMMU_HAS_FLAG(data->plat_data, IFA_IOMMU_PCIe_SUPPORT)) {
+		#ifdef CONFIG_PCI
+		if (!iommu_present(&pci_bus_type)) {
+			ret = bus_set_iommu(&pci_bus_type, &mtk_iommu_ops);
+			if (ret) /* PCIe fail don't affect platform_bus. */
+				goto out_list_del;
+		}
+		#endif
+	}
 	return ret;
 
 out_bus_set_null:
@@ -943,7 +1121,8 @@ static int mtk_iommu_probe(struct platform_device *pdev)
 out_sysfs_remove:
 	iommu_device_sysfs_remove(&data->iommu);
 out_link_remove:
-	device_link_remove(data->smicomm_dev, dev);
+	if (MTK_IOMMU_IS_TYPE(data->plat_data, MTK_IOMMU_TYPE_MM))
+		device_link_remove(data->smicomm_dev, dev);
 out_runtime_disable:
 	pm_runtime_disable(dev);
 	return ret;
@@ -952,18 +1131,30 @@ static int mtk_iommu_probe(struct platform_device *pdev)
 static int mtk_iommu_remove(struct platform_device *pdev)
 {
 	struct mtk_iommu_data *data = platform_get_drvdata(pdev);
+	struct mtk_iommu_bank_data *bank;
+	int i;
 
 	iommu_device_sysfs_remove(&data->iommu);
 	iommu_device_unregister(&data->iommu);
 
-	if (iommu_present(&platform_bus_type))
-		bus_set_iommu(&platform_bus_type, NULL);
+	list_del(&data->list);
+	if (MTK_IOMMU_IS_TYPE(data->plat_data, MTK_IOMMU_TYPE_MM)) {
+		device_link_remove(data->smicomm_dev, &pdev->dev);
+		component_master_del(&pdev->dev, &mtk_iommu_com_ops);
+	} else if (MTK_IOMMU_IS_TYPE(data->plat_data, MTK_IOMMU_TYPE_INFRA) &&
+		   MTK_IOMMU_HAS_FLAG(data->plat_data, IFA_IOMMU_PCIe_SUPPORT)) {
+		#ifdef CONFIG_PCI
+		bus_set_iommu(&pci_bus_type, NULL);
+		#endif
+	}
 
-	clk_disable_unprepare(data->bclk);
-	device_link_remove(data->smicomm_dev, &pdev->dev);
 	pm_runtime_disable(&pdev->dev);
-	devm_free_irq(&pdev->dev, data->irq, data);
-	component_master_del(&pdev->dev, &mtk_iommu_com_ops);
+	for (i = 0; i < data->plat_data->bank_nr; i++) {
+		bank = &data->bank[i];
+		if (!bank->m4u_dom)
+			continue;
+		devm_free_irq(&pdev->dev, bank->irq, bank);
+	}
 	return 0;
 }
 
@@ -971,16 +1162,23 @@ static int __maybe_unused mtk_iommu_runtime_suspend(struct device *dev)
 {
 	struct mtk_iommu_data *data = dev_get_drvdata(dev);
 	struct mtk_iommu_suspend_reg *reg = &data->reg;
-	void __iomem *base = data->base;
+	void __iomem *base;
+	int i = 0;
 
+	base = data->bank[i].base;
 	reg->wr_len_ctrl = readl_relaxed(base + REG_MMU_WR_LEN_CTRL);
 	reg->misc_ctrl = readl_relaxed(base + REG_MMU_MISC_CTRL);
 	reg->dcm_dis = readl_relaxed(base + REG_MMU_DCM_DIS);
 	reg->ctrl_reg = readl_relaxed(base + REG_MMU_CTRL_REG);
-	reg->int_control0 = readl_relaxed(base + REG_MMU_INT_CONTROL0);
-	reg->int_main_control = readl_relaxed(base + REG_MMU_INT_MAIN_CONTROL);
-	reg->ivrp_paddr = readl_relaxed(base + REG_MMU_IVRP_PADDR);
 	reg->vld_pa_rng = readl_relaxed(base + REG_MMU_VLD_PA_RNG);
+	do {
+		if (!data->plat_data->bank_enable[i])
+			continue;
+		base = data->bank[i].base;
+		reg->int_control[i] = readl_relaxed(base + REG_MMU_INT_CONTROL0);
+		reg->int_main_control[i] = readl_relaxed(base + REG_MMU_INT_MAIN_CONTROL);
+		reg->ivrp_paddr[i] = readl_relaxed(base + REG_MMU_IVRP_PADDR);
+	} while (++i < data->plat_data->bank_nr);
 	clk_disable_unprepare(data->bclk);
 	return 0;
 }
@@ -989,9 +1187,9 @@ static int __maybe_unused mtk_iommu_runtime_resume(struct device *dev)
 {
 	struct mtk_iommu_data *data = dev_get_drvdata(dev);
 	struct mtk_iommu_suspend_reg *reg = &data->reg;
-	struct mtk_iommu_domain *m4u_dom = data->m4u_dom;
-	void __iomem *base = data->base;
-	int ret;
+	struct mtk_iommu_domain *m4u_dom;
+	void __iomem *base;
+	int ret, i = 0;
 
 	ret = clk_prepare_enable(data->bclk);
 	if (ret) {
@@ -1003,18 +1201,36 @@ static int __maybe_unused mtk_iommu_runtime_resume(struct device *dev)
 	 * Uppon first resume, only enable the clk and return, since the values of the
 	 * registers are not yet set.
 	 */
-	if (!m4u_dom)
+	if (!reg->wr_len_ctrl)
 		return 0;
 
+	base = data->bank[i].base;
 	writel_relaxed(reg->wr_len_ctrl, base + REG_MMU_WR_LEN_CTRL);
 	writel_relaxed(reg->misc_ctrl, base + REG_MMU_MISC_CTRL);
 	writel_relaxed(reg->dcm_dis, base + REG_MMU_DCM_DIS);
 	writel_relaxed(reg->ctrl_reg, base + REG_MMU_CTRL_REG);
-	writel_relaxed(reg->int_control0, base + REG_MMU_INT_CONTROL0);
-	writel_relaxed(reg->int_main_control, base + REG_MMU_INT_MAIN_CONTROL);
-	writel_relaxed(reg->ivrp_paddr, base + REG_MMU_IVRP_PADDR);
 	writel_relaxed(reg->vld_pa_rng, base + REG_MMU_VLD_PA_RNG);
-	writel(m4u_dom->cfg.arm_v7s_cfg.ttbr & MMU_PT_ADDR_MASK, base + REG_MMU_PT_BASE_ADDR);
+	do {
+		m4u_dom = data->bank[i].m4u_dom;
+		if (!data->plat_data->bank_enable[i] || !m4u_dom)
+			continue;
+		base = data->bank[i].base;
+		writel_relaxed(reg->int_control[i], base + REG_MMU_INT_CONTROL0);
+		writel_relaxed(reg->int_main_control[i], base + REG_MMU_INT_MAIN_CONTROL);
+		writel_relaxed(reg->ivrp_paddr[i], base + REG_MMU_IVRP_PADDR);
+		writel(m4u_dom->cfg.arm_v7s_cfg.ttbr & MMU_PT_ADDR_MASK,
+		       base + REG_MMU_PT_BASE_ADDR);
+		/*
+		 * User may allocate dma buffer before they call pm_runtime_get,
+		 * then it will lack the necessary tlb flush.
+		 *
+		 * We have no good reason to request the user call dma_alloc_xx
+		 * after pm_runtime_get.
+		 *
+		 * Thus, Make sure the tlb always is clean after each PM resume.
+		 */
+		__mtk_iommu_tlb_flush_all(&data->bank[i]);
+	} while (++i < data->plat_data->bank_nr);
 	return 0;
 }
 
@@ -1026,8 +1242,12 @@ static const struct dev_pm_ops mtk_iommu_pm_ops = {
 
 static const struct mtk_iommu_plat_data mt2712_data = {
 	.m4u_plat     = M4U_MT2712,
-	.flags        = HAS_4GB_MODE | HAS_BCLK | HAS_VLD_PA_RNG,
+	.flags        = HAS_4GB_MODE | HAS_BCLK | HAS_VLD_PA_RNG | SHARE_PGTABLE |
+			NOT_STD_AXI_MODE | MTK_IOMMU_TYPE_MM,
+	.hw_list      = &m4ulist,
 	.inv_sel_reg  = REG_MMU_INV_SEL_GEN1,
+	.bank_nr      = 1,
+	.bank_enable  = {true},
 	.iova_region  = single_domain,
 	.iova_region_nr = ARRAY_SIZE(single_domain),
 	.larbid_remap = {{0}, {1}, {2}, {3}, {4}, {5}, {6}, {7}},
@@ -1035,8 +1255,11 @@ static const struct mtk_iommu_plat_data mt2712_data = {
 
 static const struct mtk_iommu_plat_data mt6779_data = {
 	.m4u_plat      = M4U_MT6779,
-	.flags         = HAS_SUB_COMM | OUT_ORDER_WR_EN | WR_THROT_EN,
+	.flags         = HAS_SUB_COMM_2BITS | OUT_ORDER_WR_EN | WR_THROT_EN |
+			 NOT_STD_AXI_MODE | MTK_IOMMU_TYPE_MM,
 	.inv_sel_reg   = REG_MMU_INV_SEL_GEN2,
+	.bank_nr       = 1,
+	.bank_enable   = {true},
 	.iova_region   = single_domain,
 	.iova_region_nr = ARRAY_SIZE(single_domain),
 	.larbid_remap  = {{0}, {1}, {2}, {3}, {5}, {7, 8}, {10}, {9}},
@@ -1044,8 +1267,11 @@ static const struct mtk_iommu_plat_data mt6779_data = {
 
 static const struct mtk_iommu_plat_data mt8167_data = {
 	.m4u_plat     = M4U_MT8167,
-	.flags        = RESET_AXI | HAS_LEGACY_IVRP_PADDR,
+	.flags        = RESET_AXI | HAS_LEGACY_IVRP_PADDR | NOT_STD_AXI_MODE |
+			MTK_IOMMU_TYPE_MM,
 	.inv_sel_reg  = REG_MMU_INV_SEL_GEN1,
+	.bank_nr      = 1,
+	.bank_enable  = {true},
 	.iova_region  = single_domain,
 	.iova_region_nr = ARRAY_SIZE(single_domain),
 	.larbid_remap = {{0}, {1}, {2}}, /* Linear mapping. */
@@ -1054,8 +1280,11 @@ static const struct mtk_iommu_plat_data mt8167_data = {
 static const struct mtk_iommu_plat_data mt8173_data = {
 	.m4u_plat     = M4U_MT8173,
 	.flags	      = HAS_4GB_MODE | HAS_BCLK | RESET_AXI |
-			HAS_LEGACY_IVRP_PADDR,
+			HAS_LEGACY_IVRP_PADDR | NOT_STD_AXI_MODE |
+			MTK_IOMMU_TYPE_MM,
 	.inv_sel_reg  = REG_MMU_INV_SEL_GEN1,
+	.bank_nr      = 1,
+	.bank_enable  = {true},
 	.iova_region  = single_domain,
 	.iova_region_nr = ARRAY_SIZE(single_domain),
 	.larbid_remap = {{0}, {1}, {2}, {3}, {4}, {5}}, /* Linear mapping. */
@@ -1063,8 +1292,10 @@ static const struct mtk_iommu_plat_data mt8173_data = {
 
 static const struct mtk_iommu_plat_data mt8183_data = {
 	.m4u_plat     = M4U_MT8183,
-	.flags        = RESET_AXI,
+	.flags        = RESET_AXI | MTK_IOMMU_TYPE_MM,
 	.inv_sel_reg  = REG_MMU_INV_SEL_GEN1,
+	.bank_nr      = 1,
+	.bank_enable  = {true},
 	.iova_region  = single_domain,
 	.iova_region_nr = ARRAY_SIZE(single_domain),
 	.larbid_remap = {{0}, {4}, {5}, {6}, {7}, {2}, {3}, {1}},
@@ -1072,15 +1303,66 @@ static const struct mtk_iommu_plat_data mt8183_data = {
 
 static const struct mtk_iommu_plat_data mt8192_data = {
 	.m4u_plat       = M4U_MT8192,
-	.flags          = HAS_BCLK | HAS_SUB_COMM | OUT_ORDER_WR_EN |
-			  WR_THROT_EN | IOVA_34_EN,
+	.flags          = HAS_BCLK | HAS_SUB_COMM_2BITS | OUT_ORDER_WR_EN |
+			  WR_THROT_EN | IOVA_34_EN | NOT_STD_AXI_MODE |
+			  MTK_IOMMU_TYPE_MM,
 	.inv_sel_reg    = REG_MMU_INV_SEL_GEN2,
+	.bank_nr        = 1,
+	.bank_enable    = {true},
 	.iova_region    = mt8192_multi_dom,
 	.iova_region_nr = ARRAY_SIZE(mt8192_multi_dom),
 	.larbid_remap   = {{0}, {1}, {4, 5}, {7}, {2}, {9, 11, 19, 20},
 			   {0, 14, 16}, {0, 13, 18, 17}},
 };
 
+static const struct mtk_iommu_plat_data mt8195_data_infra = {
+	.m4u_plat	  = M4U_MT8195,
+	.flags            = WR_THROT_EN | DCM_DISABLE |
+			    MTK_IOMMU_TYPE_INFRA | IFA_IOMMU_PCIe_SUPPORT,
+	.pericfg_comp_str = "mediatek,mt8195-pericfg_ao",
+	.bank_nr	  = 5,
+	.bank_enable      = {true, false, false, false, true},
+	.bank_portmsk     = {[0] = GENMASK(19, 16),     /* PCIe */
+			     [4] = GENMASK(31, 20),     /* USB */
+			    },
+	.inv_sel_reg      = REG_MMU_INV_SEL_GEN2,
+	.iova_region      = single_domain,
+	.iova_region_nr   = ARRAY_SIZE(single_domain),
+};
+
+static const struct mtk_iommu_plat_data mt8195_data_vdo = {
+	.m4u_plat	= M4U_MT8195,
+	.flags          = HAS_BCLK | HAS_SUB_COMM_2BITS | OUT_ORDER_WR_EN |
+			  WR_THROT_EN | NOT_STD_AXI_MODE | IOVA_34_EN |
+			  SHARE_PGTABLE | MTK_IOMMU_TYPE_MM,
+	.hw_list        = &m4ulist,
+	.inv_sel_reg    = REG_MMU_INV_SEL_GEN2,
+	.bank_nr	= 1,
+	.bank_enable    = {true},
+	.iova_region	= mt8192_multi_dom,
+	.iova_region_nr	= ARRAY_SIZE(mt8192_multi_dom),
+	.larbid_remap   = {{2, 0}, {21}, {24}, {7}, {19}, {9, 10, 11},
+			   {13, 17, 15/* 17b */, 25}, {5}},
+};
+
+static const struct mtk_iommu_plat_data mt8195_data_vpp = {
+	.m4u_plat	= M4U_MT8195,
+	.flags          = HAS_BCLK | HAS_SUB_COMM_3BITS | OUT_ORDER_WR_EN |
+			  WR_THROT_EN | NOT_STD_AXI_MODE | IOVA_34_EN |
+			  SHARE_PGTABLE | MTK_IOMMU_TYPE_MM,
+	.hw_list        = &m4ulist,
+	.inv_sel_reg    = REG_MMU_INV_SEL_GEN2,
+	.bank_nr	= 1,
+	.bank_enable    = {true},
+	.iova_region	= mt8192_multi_dom,
+	.iova_region_nr	= ARRAY_SIZE(mt8192_multi_dom),
+	.larbid_remap   = {{1}, {3}, {22, 0, 0, 0, 23}, {8},
+			   {20}, {12},
+			   /* 16: 16a; 29: 16b; 30: CCUtop0; 31: CCUtop1 */
+			   {14, 16, 29, 26, 30, 31, 18},
+			   {4, 0, 0, 0, 6}},
+};
+
 static const struct of_device_id mtk_iommu_of_ids[] = {
 	{ .compatible = "mediatek,mt2712-m4u", .data = &mt2712_data},
 	{ .compatible = "mediatek,mt6779-m4u", .data = &mt6779_data},
@@ -1088,6 +1370,9 @@ static const struct of_device_id mtk_iommu_of_ids[] = {
 	{ .compatible = "mediatek,mt8173-m4u", .data = &mt8173_data},
 	{ .compatible = "mediatek,mt8183-m4u", .data = &mt8183_data},
 	{ .compatible = "mediatek,mt8192-m4u", .data = &mt8192_data},
+	{ .compatible = "mediatek,mt8195-iommu-infra", .data = &mt8195_data_infra},
+	{ .compatible = "mediatek,mt8195-iommu-vdo",   .data = &mt8195_data_vdo},
+	{ .compatible = "mediatek,mt8195-iommu-vpp",   .data = &mt8195_data_vpp},
 	{}
 };
 
diff --git a/drivers/iommu/mtk_iommu.h b/drivers/iommu/mtk_iommu.h
index f81fa8862ed04b22f997bf45700e58dd90fc068b..279c6c3ee56fad52a87d3e65be16715af387ad5b 100644
--- a/drivers/iommu/mtk_iommu.h
+++ b/drivers/iommu/mtk_iommu.h
@@ -20,10 +20,12 @@
 #include <dt-bindings/memory/mtk-memory-port.h>
 
 #define MTK_LARB_COM_MAX	8
-#define MTK_LARB_SUBCOM_MAX	4
+#define MTK_LARB_SUBCOM_MAX	8
 
 #define MTK_IOMMU_GROUP_MAX	8
 
+#define MTK_IOMMU_BANK_MAX	5
+
 struct mtk_iommu_suspend_reg {
 	union {
 		u32			standard_axi_mode;/* v1 */
@@ -31,11 +33,19 @@ struct mtk_iommu_suspend_reg {
 	};
 	u32				dcm_dis;
 	u32				ctrl_reg;
-	u32				int_control0;
-	u32				int_main_control;
-	u32				ivrp_paddr;
 	u32				vld_pa_rng;
 	u32				wr_len_ctrl;
+	union {
+		struct { /* only for gen1 */
+			u32		int_control0;
+		};
+
+		struct { /* only for gen2 that support multi-banks */
+			u32		int_control[MTK_IOMMU_BANK_MAX];
+			u32		int_main_control[MTK_IOMMU_BANK_MAX];
+			u32		ivrp_paddr[MTK_IOMMU_BANK_MAX];
+		};
+	};
 };
 
 enum mtk_iommu_plat {
@@ -46,6 +56,7 @@ enum mtk_iommu_plat {
 	M4U_MT8173,
 	M4U_MT8183,
 	M4U_MT8192,
+	M4U_MT8195,
 };
 
 struct mtk_iommu_iova_region;
@@ -55,31 +66,61 @@ struct mtk_iommu_plat_data {
 	u32                 flags;
 	u32                 inv_sel_reg;
 
+	char					*pericfg_comp_str;
+	struct list_head			*hw_list;
 	unsigned int				iova_region_nr;
 	const struct mtk_iommu_iova_region	*iova_region;
+
+	unsigned int        bank_nr;
+	bool                bank_enable[MTK_IOMMU_BANK_MAX];
+	unsigned int        bank_portmsk[MTK_IOMMU_BANK_MAX];
 	unsigned char       larbid_remap[MTK_LARB_COM_MAX][MTK_LARB_SUBCOM_MAX];
 };
 
 struct mtk_iommu_domain;
 
-struct mtk_iommu_data {
+struct mtk_iommu_bank_data {
 	void __iomem			*base;
 	int				irq;
+	unsigned int			id;
+	struct device			*pdev;
+	struct mtk_iommu_data		*pdata;   /* parent data */
+	spinlock_t			tlb_lock; /* lock for tlb range flush */
+	struct mtk_iommu_domain		*m4u_dom; /* Each bank has a domain */
+};
+
+struct mtk_iommu_data {
+	union {
+		struct { /* only for gen1 */
+			void __iomem		*base;
+			int			irq;
+			struct mtk_iommu_domain	*m4u_dom;
+		};
+
+		/* only for gen2 that support multi-banks */
+		struct mtk_iommu_bank_data	bank[MTK_IOMMU_BANK_MAX];
+	};
 	struct device			*dev;
 	struct clk			*bclk;
 	phys_addr_t			protect_base; /* protect memory base */
 	struct mtk_iommu_suspend_reg	reg;
-	struct mtk_iommu_domain		*m4u_dom;
 	struct iommu_group		*m4u_group[MTK_IOMMU_GROUP_MAX];
 	bool                            enable_4GB;
-	spinlock_t			tlb_lock; /* lock for tlb range flush */
 
 	struct iommu_device		iommu;
 	const struct mtk_iommu_plat_data *plat_data;
 	struct device			*smicomm_dev;
 
 	struct dma_iommu_mapping	*mapping; /* For mtk_iommu_v1.c */
+	struct regmap			*pericfg;
+
 
+	/*
+	 * In the sharing pgtable case, list data->list to the global list like m4ulist.
+	 * In the non-sharing pgtable case, list data->list to the itself hw_list_head.
+	 */
+	struct list_head		*hw_list;
+	struct list_head		hw_list_head;
 	struct list_head		list;
 	struct mtk_smi_larb_iommu	larb_imu[MTK_LARB_NR_MAX];
 };
diff --git a/drivers/media/platform/mtk-isp/isp_50/dip/mtk_dip-sys.c b/drivers/media/platform/mtk-isp/isp_50/dip/mtk_dip-sys.c
index 34e9d5be3b050afe955a09f86ab706159d84c785..49cfec89ed8cedb73fa5730454c3a8f248f9e5c3 100644
--- a/drivers/media/platform/mtk-isp/isp_50/dip/mtk_dip-sys.c
+++ b/drivers/media/platform/mtk-isp/isp_50/dip/mtk_dip-sys.c
@@ -255,7 +255,7 @@ static void dip_runner_func(struct work_struct *work)
 	 */
 	pm_runtime_get_sync(dip_dev->dev);
 	mdp_cmdq_sendtask(dip_dev->mdp_pdev, config_data,
-			  &req->img_fparam.frameparam, NULL,
+			  &req->img_fparam.frameparam, NULL, true,
 			  dip_mdp_cb_func, req);
 }
 
diff --git a/drivers/media/platform/mtk-mdp3/Makefile b/drivers/media/platform/mtk-mdp3/Makefile
index 3c1ccb36ea9f570881e52104165f1b75f7b99f35..6caa9a26e9c553b5f87a6b1f83988c93d672ad2c 100644
--- a/drivers/media/platform/mtk-mdp3/Makefile
+++ b/drivers/media/platform/mtk-mdp3/Makefile
@@ -1,9 +1,9 @@
 # SPDX-License-Identifier: GPL-2.0
-mtk-mdp3-y += mtk-mdp3-core.o mtk-mdp3-vpu.o mtk-mdp3-regs.o
-mtk-mdp3-y += mtk-mdp3-m2m.o
-mtk-mdp3-y += mtk-mdp3-comp.o mtk-mdp3-cmdq.o
 
-mtk-mdp3-y += mtk-mdp3-debug.o
+mtk-mdp3-objs += mtk-mdp3-core.o mtk-mdp3-vpu.o mtk-mdp3-regs.o
+mtk-mdp3-objs += mtk-mdp3-m2m.o
+mtk-mdp3-objs += mtk-mdp3-comp.o mtk-mdp3-cmdq.o
 
-obj-$(CONFIG_VIDEO_MEDIATEK_MDP3) += mtk-mdp3.o
+mtk-mdp3-objs += mtk-mdp3-debug.o
 
+obj-$(CONFIG_VIDEO_MEDIATEK_MDP3) += mtk-mdp3.o
diff --git a/drivers/media/platform/mtk-mdp3/isp_reg.h b/drivers/media/platform/mtk-mdp3/isp_reg.h
index 89ba8dc484decae6959a907ac588fdc440f13f34..a8b2f22bae8c87239980c7e76cdb6baa87ebdf57 100644
--- a/drivers/media/platform/mtk-mdp3/isp_reg.h
+++ b/drivers/media/platform/mtk-mdp3/isp_reg.h
@@ -23,7 +23,7 @@ enum ISP_DIP_CQ {
 	ISP_DRV_DIP_CQ_NUM,
 	ISP_DRV_DIP_CQ_NONE,
 	/* we only need 12 CQ threads in this chip,
-	 * so we move the following enum behind ISP_DRV_DIP_CQ_NUM
+	 *so we move the following enum behind ISP_DRV_DIP_CQ_NUM
 	 */
 	ISP_DRV_DIP_CQ_THRE12,
 	ISP_DRV_DIP_CQ_THRE13,
diff --git a/drivers/media/platform/mtk-mdp3/mdp-platform.h b/drivers/media/platform/mtk-mdp3/mdp-platform.h
index d474580306b76c9a57a4ea47323e4dc3a9fcf635..f19bfff1d58a4872f2c529a6c2d1c07bacc4b901 100644
--- a/drivers/media/platform/mtk-mdp3/mdp-platform.h
+++ b/drivers/media/platform/mtk-mdp3/mdp-platform.h
@@ -14,9 +14,8 @@
 #define MDP_WPEO           MDP_COMP_WPEO
 #define MDP_WPEI2          MDP_COMP_WPEI2
 #define MDP_WPEO2          MDP_COMP_WPEO2
-#define MDP_IMGI           MDP_COMP_ISP_IMGI
-#define MDP_IMGO           MDP_COMP_ISP_IMGO
-#define MDP_IMG2O          MDP_COMP_ISP_IMG2O
+#define MDP_IMGI           MDP_COMP_NONE
+#define MDP_IMG2O          MDP_COMP_NONE
 
 /* IPU */
 #define MDP_IPUI           MDP_COMP_NONE
@@ -25,31 +24,78 @@
 /* MDP */
 #define MDP_CAMIN          MDP_COMP_CAMIN
 #define MDP_CAMIN2         MDP_COMP_CAMIN2
+#define MDP_SPLIT          MDP_COMP_SPLIT
+#define MDP_SPLIT2         MDP_COMP_SPLIT2
 #define MDP_RDMA0          MDP_COMP_RDMA0
-#define MDP_RDMA1          MDP_COMP_NONE
+#define MDP_RDMA1          MDP_COMP_RDMA1
+#define MDP_RDMA2          MDP_COMP_RDMA2
+#define MDP_RDMA3          MDP_COMP_RDMA3
+#define MDP_STITCH         MDP_COMP_STITCH
+#define MDP_FG0            MDP_COMP_FG0
+#define MDP_FG1            MDP_COMP_FG1
+#define MDP_FG2            MDP_COMP_FG2
+#define MDP_FG3            MDP_COMP_FG3
+#define MDP_HDR0           MDP_COMP_HDR0
+#define MDP_HDR1           MDP_COMP_HDR1
+#define MDP_HDR2           MDP_COMP_HDR2
+#define MDP_HDR3           MDP_COMP_HDR3
 #define MDP_AAL0           MDP_COMP_AAL0
-#define MDP_CCORR0         MDP_COMP_CCORR0
+#define MDP_AAL1           MDP_COMP_AAL1
+#define MDP_AAL2           MDP_COMP_AAL2
+#define MDP_AAL3           MDP_COMP_AAL3
 #define MDP_SCL0           MDP_COMP_RSZ0
 #define MDP_SCL1           MDP_COMP_RSZ1
-#define MDP_SCL2           MDP_COMP_NONE
+#define MDP_SCL2           MDP_COMP_RSZ2
+#define MDP_SCL3           MDP_COMP_RSZ3
 #define MDP_TDSHP0         MDP_COMP_TDSHP0
+#define MDP_TDSHP1         MDP_COMP_TDSHP1
+#define MDP_TDSHP2         MDP_COMP_TDSHP2
+#define MDP_TDSHP3         MDP_COMP_TDSHP3
 #define MDP_COLOR0         MDP_COMP_COLOR0
+#define MDP_COLOR1         MDP_COMP_COLOR1
+#define MDP_COLOR2         MDP_COMP_COLOR2
+#define MDP_COLOR3         MDP_COMP_COLOR3
+#define MDP_OVL0           MDP_COMP_OVL0
+#define MDP_OVL1           MDP_COMP_OVL1
+#define MDP_PAD0           MDP_COMP_PAD0
+#define MDP_PAD1           MDP_COMP_PAD1
+#define MDP_PAD2           MDP_COMP_PAD2
+#define MDP_PAD3           MDP_COMP_PAD3
+#define MDP_TCC0           MDP_COMP_TCC0
+#define MDP_TCC1           MDP_COMP_TCC1
 #define MDP_WROT0          MDP_COMP_WROT0
-#define MDP_WROT1          MDP_COMP_NONE
+#define MDP_WROT1          MDP_COMP_WROT1
+#define MDP_WROT2          MDP_COMP_WROT2
+#define MDP_WROT3          MDP_COMP_WROT3
+
+/* Dummy Engines */
+#define MDP_CCORR0         MDP_COMP_NONE
+#define MDP_PATH0_SOUT     MDP_COMP_NONE
+#define MDP_PATH1_SOUT     MDP_COMP_NONE
 #define MDP_WDMA           MDP_COMP_WDMA
-#define MDP_PATH0_SOUT     MDP_COMP_PATH0_SOUT
-#define MDP_PATH1_SOUT     MDP_COMP_PATH1_SOUT
 
-#define MDP_TOTAL          (MDP_COMP_WDMA + 1)
+/* Cross sys directlink engines */
+#define MDP_VPP0_SOUT      MDP_COMP_VPP0_SOUT
+#define MDP_VPP1_SOUT      MDP_COMP_VPP1_SOUT
+#define MDP_VDO0DL0        MDP_COMP_VDO0DL0
+#define MDP_VDO1DL0        MDP_COMP_VDO1DL0
+#define MDP_VDO0DL1        MDP_COMP_VDO0DL1
+#define MDP_VDO1DL1        MDP_COMP_VDO1DL1
+
+#define MDP_TOTAL          (MDP_VDO1DL1 + 1)
 
 /* Platform options */
-#define ESL_SETTING			1
-#define RDMA_SUPPORT_10BIT		1
-#define RDMA0_RSZ1_SRAM_SHARING		1
-#define RDMA_UPSAMPLE_REPEAT_ONLY	1
-#define RSZ_DISABLE_DCM_SMALL_TILE	0
-#define WROT_FILTER_CONSTRAINT		0
-#define WROT0_DISP_SRAM_SHARING		0
+#define ESL_SETTING			            1
+#define RDMA_SUPPORT_10BIT		        1
+#define RDMA0_RSZ1_SRAM_SHARING		    0
+#define RDMA_UPSAMPLE_REPEAT_ONLY	    0
+#define HW_SUPPORT_EXTEND_UFO_FORMAT    1
+#define HW_SUPPORT_10BIT_PATH           1
+#define DMA_SUPPORT_AFBC                1
+#define DMA_SUPPORT_HYFBC               1
+#define RSZ_DISABLE_DCM_SMALL_TILE	    1
+#define WROT_FILTER_CONSTRAINT		    0
+#define WROT0_DISP_SRAM_SHARING		    0
 
 #define MM_MUTEX_MOD_OFFSET	0x30
 #define MM_MUTEX_SOF_OFFSET	0x2c
diff --git a/drivers/media/platform/mtk-mdp3/mdp_reg_aal.h b/drivers/media/platform/mtk-mdp3/mdp_reg_aal.h
new file mode 100644
index 0000000000000000000000000000000000000000..84a3b068a2fdd1d8c7eda8aa7d6607393ef03a61
--- /dev/null
+++ b/drivers/media/platform/mtk-mdp3/mdp_reg_aal.h
@@ -0,0 +1,230 @@
+#ifndef __MDP_REG_AAL_H__
+#define __MDP_REG_AAL_H__
+
+#include "mmsys_reg_base.h"
+
+#define MDP_AAL_EN                            (0x000)
+#define MDP_AAL_RESET                         (0x004)
+#define MDP_AAL_INTEN                         (0x008)
+#define MDP_AAL_INTSTA                        (0x00C)
+#define MDP_AAL_STATUS                        (0x010)
+#define MDP_AAL_CFG                           (0x020)
+#define MDP_AAL_INPUT_COUNT                   (0x024)
+#define MDP_AAL_OUTPUT_COUNT                  (0x028)
+#define MDP_AAL_CHKSUM                        (0x02C)
+#define MDP_AAL_SIZE                          (0x030)
+#define MDP_AAL_OUTPUT_SIZE                   (0x034)
+#define MDP_AAL_OUTPUT_OFFSET                 (0x038)
+#define MDP_AAL_DUMMY_REG                     (0x0C0)
+#define MDP_AAL_SRAM_CFG                      (0x0C4)
+#define MDP_AAL_SRAM_STATUS                   (0x0C8)
+#define MDP_AAL_SRAM_RW_IF_0                  (0x0CC)
+#define MDP_AAL_SRAM_RW_IF_1                  (0x0D0)
+#define MDP_AAL_SRAM_RW_IF_2                  (0x0D4)
+#define MDP_AAL_SRAM_RW_IF_3                  (0x0D8)
+#define MDP_AAL_SHADOW_CTRL                   (0x0F0)
+#define MDP_AAL_TILE_02                       (0x0F4)
+#define MDP_AAL_DRE_BLOCK_INFO_07             (0x0F8)
+#define MDP_AAL_ATPG                          (0x0FC)
+#define MDP_AAL_DREI_PAT_GEN_SET              (0x100)
+#define MDP_AAL_DREI_PAT_GEN_COLOR0           (0x108)
+#define MDP_AAL_DREI_PAT_GEN_COLOR1           (0x10C)
+#define MDP_AAL_DREO_PAT_GEN_SET              (0x130)
+#define MDP_AAL_DREO_PAT_GEN_COLOR0           (0x138)
+#define MDP_AAL_DREO_PAT_GEN_COLOR1           (0x13C)
+#define MDP_AAL_DREO_PAT_GEN_POS              (0x144)
+#define MDP_AAL_DREO_PAT_GEN_CURSOR_RB0       (0x148)
+#define MDP_AAL_DREO_PAT_GEN_CURSOR_RB1       (0x14C)
+#define MDP_AAL_CABCO_PAT_GEN_SET             (0x160)
+#define MDP_AAL_CABCO_PAT_GEN_FRM_SIZE        (0x164)
+#define MDP_AAL_CABCO_PAT_GEN_COLOR0          (0x168)
+#define MDP_AAL_CABCO_PAT_GEN_COLOR1          (0x16C)
+#define MDP_AAL_CABCO_PAT_GEN_COLOR2          (0x170)
+#define MDP_AAL_CABCO_PAT_GEN_POS             (0x174)
+#define MDP_AAL_CABCO_PAT_GEN_CURSOR_RB0      (0x178)
+#define MDP_AAL_CABCO_PAT_GEN_CURSOR_RB1      (0x17C)
+#define MDP_AAL_CABCO_PAT_GEN_RAMP            (0x180)
+#define MDP_AAL_CABCO_PAT_GEN_TILE_POS        (0x184)
+#define MDP_AAL_CABCO_PAT_GEN_TILE_OV         (0x188)
+#define MDP_AAL_CFG_MAIN                      (0x200)
+#define MDP_AAL_MAX_HIST_CONFIG_00            (0x204)
+#define MDP_AAL_DRE_FLT_FORCE_00              (0x358)
+#define MDP_AAL_DRE_FLT_FORCE_01              (0x35C)
+#define MDP_AAL_DRE_FLT_FORCE_02              (0x360)
+#define MDP_AAL_DRE_FLT_FORCE_03              (0x364)
+#define MDP_AAL_DRE_FLT_FORCE_04              (0x368)
+#define MDP_AAL_DRE_FLT_FORCE_05              (0x36C)
+#define MDP_AAL_DRE_FLT_FORCE_06              (0x370)
+#define MDP_AAL_DRE_FLT_FORCE_07              (0x374)
+#define MDP_AAL_DRE_FLT_FORCE_08              (0x378)
+#define MDP_AAL_DRE_FLT_FORCE_09              (0x37C)
+#define MDP_AAL_DRE_FLT_FORCE_10              (0x380)
+#define MDP_AAL_DRE_FLT_FORCE_11              (0x384)
+#define MDP_AAL_DRE_MAPPING_00                (0x3B4)
+#define MDP_AAL_DBG_CFG_MAIN                  (0x45C)
+#define MDP_AAL_WIN_X_MAIN                    (0x460)
+#define MDP_AAL_WIN_Y_MAIN                    (0x464)
+#define MDP_AAL_DRE_BLOCK_INFO_00             (0x468)
+#define MDP_AAL_DRE_BLOCK_INFO_01             (0x46C)
+#define MDP_AAL_DRE_BLOCK_INFO_02             (0x470)
+#define MDP_AAL_DRE_BLOCK_INFO_03             (0x474)
+#define MDP_AAL_DRE_BLOCK_INFO_04             (0x478)
+#define MDP_AAL_DRE_CHROMA_HIST_00            (0x480)
+#define MDP_AAL_DRE_CHROMA_HIST_01            (0x484)
+#define MDP_AAL_DRE_ALPHA_BLEND_00            (0x488)
+#define MDP_AAL_DRE_BITPLUS_00                (0x48C)
+#define MDP_AAL_DRE_BITPLUS_01                (0x490)
+#define MDP_AAL_DRE_BITPLUS_02                (0x494)
+#define MDP_AAL_DRE_BITPLUS_03                (0x498)
+#define MDP_AAL_DRE_BITPLUS_04                (0x49C)
+#define MDP_AAL_DRE_BLOCK_INFO_05             (0x4B4)
+#define MDP_AAL_DRE_BLOCK_INFO_06             (0x4B8)
+#define MDP_AAL_Y2R_00                        (0x4BC)
+#define MDP_AAL_Y2R_01                        (0x4C0)
+#define MDP_AAL_Y2R_02                        (0x4C4)
+#define MDP_AAL_Y2R_03                        (0x4C8)
+#define MDP_AAL_Y2R_04                        (0x4CC)
+#define MDP_AAL_Y2R_05                        (0x4D0)
+#define MDP_AAL_R2Y_00                        (0x4D4)
+#define MDP_AAL_R2Y_01                        (0x4D8)
+#define MDP_AAL_R2Y_02                        (0x4DC)
+#define MDP_AAL_R2Y_03                        (0x4E0)
+#define MDP_AAL_R2Y_04                        (0x4E4)
+#define MDP_AAL_R2Y_05                        (0x4E8)
+#define MDP_AAL_TILE_00                       (0x4EC)
+#define MDP_AAL_TILE_01                       (0x4F0)
+#define MDP_AAL_DUAL_PIPE_00                  (0x500)
+#define MDP_AAL_DUAL_PIPE_01                  (0x504)
+#define MDP_AAL_DUAL_PIPE_02                  (0x508)
+#define MDP_AAL_DUAL_PIPE_03                  (0x50C)
+#define MDP_AAL_DUAL_PIPE_04                  (0x510)
+#define MDP_AAL_DUAL_PIPE_05                  (0x514)
+#define MDP_AAL_DUAL_PIPE_06                  (0x518)
+#define MDP_AAL_DUAL_PIPE_07                  (0x51C)
+#define MDP_AAL_DRE_ROI_00                    (0x520)
+#define MDP_AAL_DRE_ROI_01                    (0x524)
+#define MDP_AAL_DRE_CHROMA_HIST2_00           (0x528)
+#define MDP_AAL_DRE_CHROMA_HIST2_01           (0x52C)
+#define MDP_AAL_DRE_CHROMA_HIST3_00           (0x530)
+#define MDP_AAL_DRE_CHROMA_HIST3_01           (0x534)
+#define MDP_AAL_DRE_FLATLINE_DIR              (0x538)
+#define MDP_AAL_DRE_BILATERAL                 (0x53C)
+#define MDP_AAL_DRE_DISP_OUT                  (0x540)
+#define MDP_AAL_DUAL_PIPE_08                  (0x544)
+#define MDP_AAL_DUAL_PIPE_09                  (0x548)
+#define MDP_AAL_DUAL_PIPE_10                  (0x54C)
+#define MDP_AAL_DUAL_PIPE_11                  (0x550)
+#define MDP_AAL_DUAL_PIPE_12                  (0x554)
+#define MDP_AAL_DUAL_PIPE_13                  (0x558)
+#define MDP_AAL_DUAL_PIPE_14                  (0x55C)
+#define MDP_AAL_DUAL_PIPE_15                  (0x560)
+#define MDP_AAL_DRE_BILATERAL_BLENDING        (0x564)
+
+#define MDP_AAL_EN_MASK                       (0x01)
+#define MDP_AAL_RESET_MASK                    (0x01)
+#define MDP_AAL_INTEN_MASK                    (0x03)
+#define MDP_AAL_INTSTA_MASK                   (0x03)
+#define MDP_AAL_STATUS_MASK                   (0x3FFFFFF3)
+#define MDP_AAL_CFG_MASK                      (0x70FF00B3)
+#define MDP_AAL_INPUT_COUNT_MASK              (0x1FFF1FFF)
+#define MDP_AAL_OUTPUT_COUNT_MASK             (0x1FFF1FFF)
+#define MDP_AAL_CHKSUM_MASK                   (0x3FFFFFFF)
+#define MDP_AAL_SIZE_MASK                     (0x1FFF1FFF)
+#define MDP_AAL_OUTPUT_SIZE_MASK              (0x1FFF1FFF)
+#define MDP_AAL_OUTPUT_OFFSET_MASK            (0x0FF00FF)
+#define MDP_AAL_DUMMY_REG_MASK                (0xFFFFFFFF)
+#define MDP_AAL_SRAM_CFG_MASK                 (0x073F0073)
+#define MDP_AAL_SRAM_STATUS_MASK              (0x033101)
+#define MDP_AAL_SRAM_RW_IF_0_MASK             (0x01FFF)
+#define MDP_AAL_SRAM_RW_IF_1_MASK             (0xFFFFFFFF)
+#define MDP_AAL_SRAM_RW_IF_2_MASK             (0x01FFF)
+#define MDP_AAL_SRAM_RW_IF_3_MASK             (0xFFFFFFFF)
+#define MDP_AAL_SHADOW_CTRL_MASK              (0x07)
+#define MDP_AAL_TILE_02_MASK                  (0x03FFFFFF)
+#define MDP_AAL_DRE_BLOCK_INFO_07_MASK        (0x03FFFFFF)
+#define MDP_AAL_ATPG_MASK                     (0x03)
+#define MDP_AAL_DREI_PAT_GEN_SET_MASK         (0x0FF0001)
+#define MDP_AAL_DREI_PAT_GEN_COLOR0_MASK      (0x0FFF0FFF)
+#define MDP_AAL_DREI_PAT_GEN_COLOR1_MASK      (0x0FFF)
+#define MDP_AAL_DREO_PAT_GEN_SET_MASK         (0x0FF0003)
+#define MDP_AAL_DREO_PAT_GEN_COLOR0_MASK      (0x0FFF0FFF)
+#define MDP_AAL_DREO_PAT_GEN_COLOR1_MASK      (0x0FFF)
+#define MDP_AAL_DREO_PAT_GEN_POS_MASK         (0x1FFF1FFF)
+#define MDP_AAL_DREO_PAT_GEN_CURSOR_RB0_MASK  (0x0FFF0FFF)
+#define MDP_AAL_DREO_PAT_GEN_CURSOR_RB1_MASK  (0x0FFF)
+#define MDP_AAL_CABCO_PAT_GEN_SET_MASK        (0x0FF07FF)
+#define MDP_AAL_CABCO_PAT_GEN_FRM_SIZE_MASK   (0x1FFF1FFF)
+#define MDP_AAL_CABCO_PAT_GEN_COLOR0_MASK     (0x0FFF0FFF)
+#define MDP_AAL_CABCO_PAT_GEN_COLOR1_MASK     (0x0FFF0FFF)
+#define MDP_AAL_CABCO_PAT_GEN_COLOR2_MASK     (0x0FFF0FFF)
+#define MDP_AAL_CABCO_PAT_GEN_POS_MASK        (0x1FFF1FFF)
+#define MDP_AAL_CABCO_PAT_GEN_CURSOR_RB0_MASK (0x0FFF0FFF)
+#define MDP_AAL_CABCO_PAT_GEN_CURSOR_RB1_MASK (0x0FFF)
+#define MDP_AAL_CABCO_PAT_GEN_RAMP_MASK       (0x1FFF0FFF)
+#define MDP_AAL_CABCO_PAT_GEN_TILE_POS_MASK   (0x1FFF1FFF)
+#define MDP_AAL_CABCO_PAT_GEN_TILE_OV_MASK    (0x0FFFF)
+#define MDP_AAL_CFG_MAIN_MASK                 (0x0FE)
+#define MDP_AAL_MAX_HIST_CONFIG_00_MASK       (0x0F0000)
+#define MDP_AAL_DRE_FLT_FORCE_00_MASK         (0x0FFFFFFF)
+#define MDP_AAL_DRE_FLT_FORCE_01_MASK         (0x01FFFFFF)
+#define MDP_AAL_DRE_FLT_FORCE_02_MASK         (0x0FFFFFF)
+#define MDP_AAL_DRE_FLT_FORCE_03_MASK         (0x03FFFFF)
+#define MDP_AAL_DRE_FLT_FORCE_04_MASK         (0x03FFFFF)
+#define MDP_AAL_DRE_FLT_FORCE_05_MASK         (0x03FFFFF)
+#define MDP_AAL_DRE_FLT_FORCE_06_MASK         (0xFFFFFFFF)
+#define MDP_AAL_DRE_FLT_FORCE_07_MASK         (0x3FFFFFFF)
+#define MDP_AAL_DRE_FLT_FORCE_08_MASK         (0x1FFFFFFF)
+#define MDP_AAL_DRE_FLT_FORCE_09_MASK         (0x07FFFFFF)
+#define MDP_AAL_DRE_FLT_FORCE_10_MASK         (0x07FFFFFF)
+#define MDP_AAL_DRE_FLT_FORCE_11_MASK         (0x03FFFF)
+#define MDP_AAL_DRE_MAPPING_00_MASK           (0x01F)
+#define MDP_AAL_DBG_CFG_MAIN_MASK             (0x03)
+#define MDP_AAL_WIN_X_MAIN_MASK               (0x1FFF1FFF)
+#define MDP_AAL_WIN_Y_MAIN_MASK               (0x1FFF1FFF)
+#define MDP_AAL_DRE_BLOCK_INFO_00_MASK        (0x03FFFFFF)
+#define MDP_AAL_DRE_BLOCK_INFO_01_MASK        (0x03FF)
+#define MDP_AAL_DRE_BLOCK_INFO_02_MASK        (0x03FFFFFF)
+#define MDP_AAL_DRE_BLOCK_INFO_03_MASK        (0xFFFFFFFF)
+#define MDP_AAL_DRE_BLOCK_INFO_04_MASK        (0x07FFFFF)
+#define MDP_AAL_DRE_CHROMA_HIST_00_MASK       (0xFFFFFFFF)
+#define MDP_AAL_DRE_CHROMA_HIST_01_MASK       (0x1FFFFFFF)
+#define MDP_AAL_DRE_CHROMA_HIST2_00_MASK       (0xFFFFFFFF)
+#define MDP_AAL_DRE_CHROMA_HIST2_01_MASK       (0x1FFFFFFF)
+#define MDP_AAL_DRE_CHROMA_HIST3_00_MASK       (0xFFFFFFFF)
+#define MDP_AAL_DRE_CHROMA_HIST3_01_MASK       (0x1FFFFFFF)
+#define MDP_AAL_DRE_ALPHA_BLEND_00_MASK       (0x1FFF1FFF)
+#define MDP_AAL_DRE_BITPLUS_00_MASK           (0x0FFFF)
+#define MDP_AAL_DRE_BITPLUS_01_MASK           (0xFFFFFFFF)
+#define MDP_AAL_DRE_BITPLUS_02_MASK           (0xFFFFFFFF)
+#define MDP_AAL_DRE_BITPLUS_03_MASK           (0x0FFFFF)
+#define MDP_AAL_DRE_BITPLUS_04_MASK           (0x0FFFFFF)
+#define MDP_AAL_DRE_BLOCK_INFO_05_MASK        (0x0FFFFFF)
+#define MDP_AAL_DRE_BLOCK_INFO_06_MASK        (0x07FFFFFF)
+#define MDP_AAL_Y2R_00_MASK                   (0x01FF01FF)
+#define MDP_AAL_Y2R_01_MASK                   (0x1FFF01FF)
+#define MDP_AAL_Y2R_02_MASK                   (0x1FFF1FFF)
+#define MDP_AAL_Y2R_03_MASK                   (0x1FFF1FFF)
+#define MDP_AAL_Y2R_04_MASK                   (0x1FFF1FFF)
+#define MDP_AAL_Y2R_05_MASK                   (0x1FFF1FFF)
+#define MDP_AAL_R2Y_00_MASK                   (0x01FF01FF)
+#define MDP_AAL_R2Y_01_MASK                   (0x07FF01FF)
+#define MDP_AAL_R2Y_02_MASK                   (0x07FF07FF)
+#define MDP_AAL_R2Y_03_MASK                   (0x07FF07FF)
+#define MDP_AAL_R2Y_04_MASK                   (0x07FF07FF)
+#define MDP_AAL_R2Y_05_MASK                   (0x07FF07FF)
+#define MDP_AAL_TILE_00_MASK                  (0x0FFFFFF)
+#define MDP_AAL_TILE_01_MASK                  (0x03FFFFFF)
+#define MDP_AAL_DUAL_PIPE_00_MASK             (0x7FFFFFF)
+#define MDP_AAL_DUAL_PIPE_01_MASK             (0x7FFFFFF)
+#define MDP_AAL_DUAL_PIPE_02_MASK             (0x7FFFFFF)
+#define MDP_AAL_DUAL_PIPE_03_MASK             (0x7FFFFFF)
+#define MDP_AAL_DUAL_PIPE_04_MASK             (0x7FFFFFF)
+#define MDP_AAL_DUAL_PIPE_05_MASK             (0x7FFFFFF)
+#define MDP_AAL_DUAL_PIPE_06_MASK             (0x7FFFFFF)
+#define MDP_AAL_DUAL_PIPE_07_MASK             (0x7FFFFFF)
+#define MDP_AAL_DRE_ROI_00_MASK               (0x3FFFFFF)
+#define MDP_AAL_DRE_ROI_01_MASK               (0x3FFFFFF)
+#define MDP_AAL_DRE_BILATERAL_MASK            (0x00003F3)
+#define MDP_AAL_DRE_BILATERAL_BLENDING_MASK   (0x00001F3)
+
+#endif  // __MDP_REG_AAL_H__
diff --git a/drivers/media/platform/mtk-mdp3/mdp_reg_ccorr.h b/drivers/media/platform/mtk-mdp3/mdp_reg_ccorr.h
index 2e86244465023d4f0c44033d35b55b11cf8c328a..99b5dc82b2cce0539991fe91b613415bd12e8f39 100644
--- a/drivers/media/platform/mtk-mdp3/mdp_reg_ccorr.h
+++ b/drivers/media/platform/mtk-mdp3/mdp_reg_ccorr.h
@@ -9,67 +9,67 @@
 
 #include "mmsys_reg_base.h"
 
-#define MDP_CCORR_EN                0x000
-#define MDP_CCORR_RESET             0x004
-#define MDP_CCORR_INTEN             0x008
-#define MDP_CCORR_INTSTA            0x00c
-#define MDP_CCORR_STATUS            0x010
-#define MDP_CCORR_CFG               0x020
-#define MDP_CCORR_INPUT_COUNT       0x024
-#define MDP_CCORR_OUTPUT_COUNT      0x028
-#define MDP_CCORR_CHKSUM            0x02c
-#define MDP_CCORR_SIZE              0x030
-#define MDP_CCORR_Y2R_00            0x034
-#define MDP_CCORR_Y2R_01            0x038
-#define MDP_CCORR_Y2R_02            0x03c
-#define MDP_CCORR_Y2R_03            0x040
-#define MDP_CCORR_Y2R_04            0x044
-#define MDP_CCORR_Y2R_05            0x048
-#define MDP_CCORR_R2Y_00            0x04c
-#define MDP_CCORR_R2Y_01            0x050
-#define MDP_CCORR_R2Y_02            0x054
-#define MDP_CCORR_R2Y_03            0x058
-#define MDP_CCORR_R2Y_04            0x05c
-#define MDP_CCORR_R2Y_05            0x060
-#define MDP_CCORR_COEF_0            0x080
-#define MDP_CCORR_COEF_1            0x084
-#define MDP_CCORR_COEF_2            0x088
-#define MDP_CCORR_COEF_3            0x08c
-#define MDP_CCORR_COEF_4            0x090
-#define MDP_CCORR_SHADOW            0x0a0
-#define MDP_CCORR_DUMMY_REG         0x0c0
-#define MDP_CCORR_ATPG              0x0fc
+#define MDP_CCORR_EN                (0x000)
+#define MDP_CCORR_RESET             (0x004)
+#define MDP_CCORR_INTEN             (0x008)
+#define MDP_CCORR_INTSTA            (0x00C)
+#define MDP_CCORR_STATUS            (0x010)
+#define MDP_CCORR_CFG               (0x020)
+#define MDP_CCORR_INPUT_COUNT       (0x024)
+#define MDP_CCORR_OUTPUT_COUNT      (0x028)
+#define MDP_CCORR_CHKSUM            (0x02C)
+#define MDP_CCORR_SIZE              (0x030)
+#define MDP_CCORR_Y2R_00            (0x034)
+#define MDP_CCORR_Y2R_01            (0x038)
+#define MDP_CCORR_Y2R_02            (0x03C)
+#define MDP_CCORR_Y2R_03            (0x040)
+#define MDP_CCORR_Y2R_04            (0x044)
+#define MDP_CCORR_Y2R_05            (0x048)
+#define MDP_CCORR_R2Y_00            (0x04C)
+#define MDP_CCORR_R2Y_01            (0x050)
+#define MDP_CCORR_R2Y_02            (0x054)
+#define MDP_CCORR_R2Y_03            (0x058)
+#define MDP_CCORR_R2Y_04            (0x05C)
+#define MDP_CCORR_R2Y_05            (0x060)
+#define MDP_CCORR_COEF_0            (0x080)
+#define MDP_CCORR_COEF_1            (0x084)
+#define MDP_CCORR_COEF_2            (0x088)
+#define MDP_CCORR_COEF_3            (0x08C)
+#define MDP_CCORR_COEF_4            (0x090)
+#define MDP_CCORR_SHADOW            (0x0A0)
+#define MDP_CCORR_DUMMY_REG         (0x0C0)
+#define MDP_CCORR_ATPG              (0x0FC)
 
 /* MASK */
-#define MDP_CCORR_EN_MASK           0x00000001
-#define MDP_CCORR_RESET_MASK        0x00000001
-#define MDP_CCORR_INTEN_MASK        0x00000003
-#define MDP_CCORR_INTSTA_MASK       0x00000003
-#define MDP_CCORR_STATUS_MASK       0xfffffff3
-#define MDP_CCORR_CFG_MASK          0x70001317
-#define MDP_CCORR_INPUT_COUNT_MASK  0x1fff1fff
-#define MDP_CCORR_OUTPUT_COUNT_MASK 0x1fff1fff
-#define MDP_CCORR_CHKSUM_MASK       0xffffffff
-#define MDP_CCORR_SIZE_MASK         0x1fff1fff
-#define MDP_CCORR_Y2R_00_MASK       0x01ff01ff
-#define MDP_CCORR_Y2R_01_MASK       0x1fff01ff
-#define MDP_CCORR_Y2R_02_MASK       0x1fff1fff
-#define MDP_CCORR_Y2R_03_MASK       0x1fff1fff
-#define MDP_CCORR_Y2R_04_MASK       0x1fff1fff
-#define MDP_CCORR_Y2R_05_MASK       0x1fff1fff
-#define MDP_CCORR_R2Y_00_MASK       0x01ff01ff
-#define MDP_CCORR_R2Y_01_MASK       0x07ff01ff
-#define MDP_CCORR_R2Y_02_MASK       0x07ff07ff
-#define MDP_CCORR_R2Y_03_MASK       0x07ff07ff
-#define MDP_CCORR_R2Y_04_MASK       0x07ff07ff
-#define MDP_CCORR_R2Y_05_MASK       0x07ff07ff
-#define MDP_CCORR_COEF_0_MASK       0x1fff1fff
-#define MDP_CCORR_COEF_1_MASK       0x1fff1fff
-#define MDP_CCORR_COEF_2_MASK       0x1fff1fff
-#define MDP_CCORR_COEF_3_MASK       0x1fff1fff
-#define MDP_CCORR_COEF_4_MASK       0x1fff1fff
-#define MDP_CCORR_SHADOW_MASK       0x00000007
-#define MDP_CCORR_DUMMY_REG_MASK    0xffffffff
-#define MDP_CCORR_ATPG_MASK         0x00000003
+#define MDP_CCORR_EN_MASK           (0x01)
+#define MDP_CCORR_RESET_MASK        (0x01)
+#define MDP_CCORR_INTEN_MASK        (0x03)
+#define MDP_CCORR_INTSTA_MASK       (0x03)     
+#define MDP_CCORR_STATUS_MASK       (0xFFFFFFF3)
+#define MDP_CCORR_CFG_MASK          (0x70001317)
+#define MDP_CCORR_INPUT_COUNT_MASK  (0x1FFF1FFF)
+#define MDP_CCORR_OUTPUT_COUNT_MASK (0x1FFF1FFF)
+#define MDP_CCORR_CHKSUM_MASK       (0xFFFFFFFF)
+#define MDP_CCORR_SIZE_MASK         (0x1FFF1FFF)
+#define MDP_CCORR_Y2R_00_MASK       (0x01FF01FF)
+#define MDP_CCORR_Y2R_01_MASK       (0x1FFF01FF)
+#define MDP_CCORR_Y2R_02_MASK       (0x1FFF1FFF)
+#define MDP_CCORR_Y2R_03_MASK       (0x1FFF1FFF)
+#define MDP_CCORR_Y2R_04_MASK       (0x1FFF1FFF)
+#define MDP_CCORR_Y2R_05_MASK       (0x1FFF1FFF)
+#define MDP_CCORR_R2Y_00_MASK       (0x01FF01FF)
+#define MDP_CCORR_R2Y_01_MASK       (0x07FF01FF)
+#define MDP_CCORR_R2Y_02_MASK       (0x07FF07FF)
+#define MDP_CCORR_R2Y_03_MASK       (0x07FF07FF)
+#define MDP_CCORR_R2Y_04_MASK       (0x07FF07FF)
+#define MDP_CCORR_R2Y_05_MASK       (0x07FF07FF)
+#define MDP_CCORR_COEF_0_MASK       (0x1FFF1FFF)
+#define MDP_CCORR_COEF_1_MASK       (0x1FFF1FFF)
+#define MDP_CCORR_COEF_2_MASK       (0x1FFF1FFF)
+#define MDP_CCORR_COEF_3_MASK       (0x1FFF1FFF)
+#define MDP_CCORR_COEF_4_MASK       (0x1FFF1FFF)
+#define MDP_CCORR_SHADOW_MASK       (0x07)
+#define MDP_CCORR_DUMMY_REG_MASK    (0xFFFFFFFF)
+#define MDP_CCORR_ATPG_MASK         (0x03)
 
 #endif  // __MDP_REG_CCORR_H__
diff --git a/drivers/media/platform/mtk-mdp3/mdp_reg_color.h b/drivers/media/platform/mtk-mdp3/mdp_reg_color.h
new file mode 100644
index 0000000000000000000000000000000000000000..50ecfeb3ac5b0dbe648e8a2a92bfdf0a599afdeb
--- /dev/null
+++ b/drivers/media/platform/mtk-mdp3/mdp_reg_color.h
@@ -0,0 +1,315 @@
+#ifndef __MDP_REG_COLOR_H__
+#define __MDP_REG_COLOR_H__
+#include "mmsys_reg_base.h"
+#define DISP_COLOR_CFG_MAIN                  (0x400)
+#define DISP_COLOR_PXL_CNT_MAIN              (0x404)
+#define DISP_COLOR_LINE_CNT_MAIN             (0x408)
+#define DISP_COLOR_WIN_X_MAIN                (0x40C)
+#define DISP_COLOR_WIN_Y_MAIN                (0x410)
+#define DISP_COLOR_TIMING_DETECTION_0        (0x418)
+#define DISP_COLOR_TIMING_DETECTION_1        (0x41C)
+#define DISP_COLOR_DBG_CFG_MAIN              (0x420)
+#define DISP_COLOR_C_BOOST_MAIN              (0x428)
+#define DISP_COLOR_C_BOOST_MAIN_2            (0x42C)
+#define DISP_COLOR_LUMA_ADJ                  (0x430)
+#define DISP_COLOR_G_PIC_ADJ_MAIN_1          (0x434)
+#define DISP_COLOR_G_PIC_ADJ_MAIN_2          (0x438)
+#define DISP_COLOR_POS_MAIN                  (0x484)
+#define DISP_COLOR_INK_DATA_MAIN             (0x488)
+#define DISP_COLOR_INK_DATA_MAIN_CR          (0x48C)
+#define DISP_COLOR_CAP_IN_DATA_MAIN          (0x490)
+#define DISP_COLOR_CAP_IN_DATA_MAIN_CR       (0x494)
+#define DISP_COLOR_CAP_OUT_DATA_MAIN         (0x498)
+#define DISP_COLOR_CAP_OUT_DATA_MAIN_CR      (0x49C)
+#define DISP_COLOR_Y_SLOPE_1_0_MAIN          (0x4A0)
+#define DISP_COLOR_Y_SLOPE_3_2_MAIN          (0x4A4)
+#define DISP_COLOR_Y_SLOPE_5_4_MAIN          (0x4A8)
+#define DISP_COLOR_Y_SLOPE_7_6_MAIN          (0x4AC)
+#define DISP_COLOR_Y_SLOPE_9_8_MAIN          (0x4B0)
+#define DISP_COLOR_Y_SLOPE_11_10_MAIN        (0x4B4)
+#define DISP_COLOR_Y_SLOPE_13_12_MAIN        (0x4B8)
+#define DISP_COLOR_Y_SLOPE_15_14_MAIN        (0x4BC)
+#define DISP_COLOR_LOCAL_HUE_CD_0            (0x620)
+#define DISP_COLOR_LOCAL_HUE_CD_1            (0x624)
+#define DISP_COLOR_LOCAL_HUE_CD_2            (0x628)
+#define DISP_COLOR_LOCAL_HUE_CD_3            (0x62C)
+#define DISP_COLOR_LOCAL_HUE_CD_4            (0x630)
+#define DISP_COLOR_TWO_D_WINDOW_1            (0x740)
+#define DISP_COLOR_TWO_D_W1_RESULT           (0x74C)
+#define DISP_COLOR_SAT_HIST_X_CFG_MAIN       (0x768)
+#define DISP_COLOR_SAT_HIST_Y_CFG_MAIN       (0x76C)
+#define DISP_COLOR_BWS_2                     (0x79C)
+#define DISP_COLOR_CRC_0                     (0x7E0)
+#define DISP_COLOR_CRC_1                     (0x7E4)
+#define DISP_COLOR_CRC_2                     (0x7E8)
+#define DISP_COLOR_CRC_3                     (0x7EC)
+#define DISP_COLOR_CRC_4                     (0x7F0)
+#define DISP_COLOR_PARTIAL_SAT_GAIN1_0       (0x7FC)
+#define DISP_COLOR_PARTIAL_SAT_GAIN1_1       (0x800)
+#define DISP_COLOR_PARTIAL_SAT_GAIN1_2       (0x804)
+#define DISP_COLOR_PARTIAL_SAT_GAIN1_3       (0x808)
+#define DISP_COLOR_PARTIAL_SAT_GAIN1_4       (0x80C)
+#define DISP_COLOR_PARTIAL_SAT_GAIN2_0       (0x810)
+#define DISP_COLOR_PARTIAL_SAT_GAIN2_1       (0x814)
+#define DISP_COLOR_PARTIAL_SAT_GAIN2_2       (0x818)
+#define DISP_COLOR_PARTIAL_SAT_GAIN2_3       (0x81C)
+#define DISP_COLOR_PARTIAL_SAT_GAIN2_4       (0x820)
+#define DISP_COLOR_PARTIAL_SAT_GAIN3_0       (0x824)
+#define DISP_COLOR_PARTIAL_SAT_GAIN3_1       (0x828)
+#define DISP_COLOR_PARTIAL_SAT_GAIN3_2       (0x82C)
+#define DISP_COLOR_PARTIAL_SAT_GAIN3_3       (0x830)
+#define DISP_COLOR_PARTIAL_SAT_GAIN3_4       (0x834)
+#define DISP_COLOR_PARTIAL_SAT_POINT1_0      (0x838)
+#define DISP_COLOR_PARTIAL_SAT_POINT1_1      (0x83C)
+#define DISP_COLOR_PARTIAL_SAT_POINT1_2      (0x840)
+#define DISP_COLOR_PARTIAL_SAT_POINT1_3      (0x844)
+#define DISP_COLOR_PARTIAL_SAT_POINT1_4      (0x848)
+#define DISP_COLOR_PARTIAL_SAT_POINT2_0      (0x84C)
+#define DISP_COLOR_PARTIAL_SAT_POINT2_1      (0x850)
+#define DISP_COLOR_PARTIAL_SAT_POINT2_2      (0x854)
+#define DISP_COLOR_PARTIAL_SAT_POINT2_3      (0x858)
+#define DISP_COLOR_PARTIAL_SAT_POINT2_4      (0x85C)
+#define DISP_COLOR_CM_CONTROL                (0x860)
+#define DISP_COLOR_CM_W1_HUE_0               (0x864)
+#define DISP_COLOR_CM_W1_HUE_1               (0x868)
+#define DISP_COLOR_CM_W1_HUE_2               (0x86C)
+#define DISP_COLOR_CM_W1_HUE_3               (0x870)
+#define DISP_COLOR_CM_W1_HUE_4               (0x874)
+#define DISP_COLOR_CM_W1_LUMA_0              (0x878)
+#define DISP_COLOR_CM_W1_LUMA_1              (0x87C)
+#define DISP_COLOR_CM_W1_LUMA_2              (0x880)
+#define DISP_COLOR_CM_W1_LUMA_3              (0x884)
+#define DISP_COLOR_CM_W1_LUMA_4              (0x888)
+#define DISP_COLOR_CM_W1_SAT_0               (0x88C)
+#define DISP_COLOR_CM_W1_SAT_1               (0x890)
+#define DISP_COLOR_CM_W1_SAT_2               (0x894)
+#define DISP_COLOR_CM_W1_SAT_3               (0x898)
+#define DISP_COLOR_CM_W1_SAT_4               (0x89C)
+#define DISP_COLOR_CM_W2_HUE_0               (0x8A0)
+#define DISP_COLOR_CM_W2_HUE_1               (0x8A4)
+#define DISP_COLOR_CM_W2_HUE_2               (0x8A8)
+#define DISP_COLOR_CM_W2_HUE_3               (0x8AC)
+#define DISP_COLOR_CM_W2_HUE_4               (0x8B0)
+#define DISP_COLOR_CM_W2_LUMA_0              (0x8B4)
+#define DISP_COLOR_CM_W2_LUMA_1              (0x8B8)
+#define DISP_COLOR_CM_W2_LUMA_2              (0x8BC)
+#define DISP_COLOR_CM_W2_LUMA_3              (0x8C0)
+#define DISP_COLOR_CM_W2_LUMA_4              (0x8C4)
+#define DISP_COLOR_CM_W2_SAT_0               (0x8C8)
+#define DISP_COLOR_CM_W2_SAT_1               (0x8CC)
+#define DISP_COLOR_CM_W2_SAT_2               (0x8D0)
+#define DISP_COLOR_CM_W2_SAT_3               (0x8D4)
+#define DISP_COLOR_CM_W2_SAT_4               (0x8D8)
+#define DISP_COLOR_CM_W3_HUE_0               (0x8DC)
+#define DISP_COLOR_CM_W3_HUE_1               (0x8E0)
+#define DISP_COLOR_CM_W3_HUE_2               (0x8E4)
+#define DISP_COLOR_CM_W3_HUE_3               (0x8E8)
+#define DISP_COLOR_CM_W3_HUE_4               (0x8EC)
+#define DISP_COLOR_CM_W3_LUMA_0              (0x8F0)
+#define DISP_COLOR_CM_W3_LUMA_1              (0x8F4)
+#define DISP_COLOR_CM_W3_LUMA_2              (0x8F8)
+#define DISP_COLOR_CM_W3_LUMA_3              (0x8FC)
+#define DISP_COLOR_CM_W3_LUMA_4              (0x900)
+#define DISP_COLOR_CM_W3_SAT_0               (0x904)
+#define DISP_COLOR_CM_W3_SAT_1               (0x908)
+#define DISP_COLOR_CM_W3_SAT_2               (0x90C)
+#define DISP_COLOR_CM_W3_SAT_3               (0x910)
+#define DISP_COLOR_CM_W3_SAT_4               (0x914)
+#define DISP_COLOR_START                     (0xC00)
+#define DISP_COLOR_INTEN                     (0xC04)
+#define DISP_COLOR_INTSTA                    (0xC08)
+#define DISP_COLOR_OUT_SEL                   (0xC0C)
+#define DISP_COLOR_FRAME_DONE_DEL            (0xC10)
+#define DISP_COLOR_CRC                       (0xC14)
+#define DISP_COLOR_SW_SCRATCH                (0xC18)
+#define DISP_COLOR_CK_ON                     (0xC28)
+#define DISP_COLOR_INTERNAL_IP_WIDTH         (0xC50)
+#define DISP_COLOR_INTERNAL_IP_HEIGHT        (0xC54)
+#define DISP_COLOR_CM1_EN                    (0xC60)
+#define DISP_COLOR_CM2_EN                    (0xCA0)
+#define DISP_COLOR_SHADOW_CTRL               (0xCB0)
+#define DISP_COLOR_R0_CRC                    (0xCF0)
+#define DISP_COLOR_S_GAIN_BY_Y0_0            (0xCF4)
+#define DISP_COLOR_S_GAIN_BY_Y0_1            (0xCF8)
+#define DISP_COLOR_S_GAIN_BY_Y0_2            (0xCFC)
+#define DISP_COLOR_S_GAIN_BY_Y0_3            (0xD00)
+#define DISP_COLOR_S_GAIN_BY_Y0_4            (0xD04)
+#define DISP_COLOR_S_GAIN_BY_Y64_0           (0xD08)
+#define DISP_COLOR_S_GAIN_BY_Y64_1           (0xD0C)
+#define DISP_COLOR_S_GAIN_BY_Y64_2           (0xD10)
+#define DISP_COLOR_S_GAIN_BY_Y64_3           (0xD14)
+#define DISP_COLOR_S_GAIN_BY_Y64_4           (0xD18)
+#define DISP_COLOR_S_GAIN_BY_Y128_0          (0xD1C)
+#define DISP_COLOR_S_GAIN_BY_Y128_1          (0xD20)
+#define DISP_COLOR_S_GAIN_BY_Y128_2          (0xD24)
+#define DISP_COLOR_S_GAIN_BY_Y128_3          (0xD28)
+#define DISP_COLOR_S_GAIN_BY_Y128_4          (0xD2C)
+#define DISP_COLOR_S_GAIN_BY_Y192_0          (0xD30)
+#define DISP_COLOR_S_GAIN_BY_Y192_1          (0xD34)
+#define DISP_COLOR_S_GAIN_BY_Y192_2          (0xD38)
+#define DISP_COLOR_S_GAIN_BY_Y192_3          (0xD3C)
+#define DISP_COLOR_S_GAIN_BY_Y192_4          (0xD40)
+#define DISP_COLOR_S_GAIN_BY_Y256_0          (0xD44)
+#define DISP_COLOR_S_GAIN_BY_Y256_1          (0xD48)
+#define DISP_COLOR_S_GAIN_BY_Y256_2          (0xD4C)
+#define DISP_COLOR_S_GAIN_BY_Y256_3          (0xD50)
+#define DISP_COLOR_S_GAIN_BY_Y256_4          (0xD54)
+#define DISP_COLOR_LSP_1                     (0xD58)
+#define DISP_COLOR_LSP_2                     (0xD5C)
+// MASK
+#define DISP_COLOR_CFG_MAIN_MASK             (0x0FFA19F)
+#define DISP_COLOR_PXL_CNT_MAIN_MASK         (0x0FFFF)
+#define DISP_COLOR_LINE_CNT_MAIN_MASK        (0xFFFFFFFF)
+#define DISP_COLOR_WIN_X_MAIN_MASK           (0xFFFFFFFF)
+#define DISP_COLOR_WIN_Y_MAIN_MASK           (0xFFFFFFFF)
+#define DISP_COLOR_TIMING_DETECTION_0_MASK   (0xFFFFFFFF)
+#define DISP_COLOR_TIMING_DETECTION_1_MASK   (0xFFFFFFFF)
+#define DISP_COLOR_DBG_CFG_MAIN_MASK         (0x7FFF0F1D)
+#define DISP_COLOR_C_BOOST_MAIN_MASK         (0xFFFF20FF)
+#define DISP_COLOR_C_BOOST_MAIN_2_MASK       (0xFF0300FF)
+#define DISP_COLOR_LUMA_ADJ_MASK             (0x0FF7F)
+#define DISP_COLOR_G_PIC_ADJ_MAIN_1_MASK     (0x07FF03FF)
+#define DISP_COLOR_G_PIC_ADJ_MAIN_2_MASK     (0x03FF)
+#define DISP_COLOR_POS_MAIN_MASK             (0xFFFFFFFF)
+#define DISP_COLOR_INK_DATA_MAIN_MASK        (0x03FF03FF)
+#define DISP_COLOR_INK_DATA_MAIN_CR_MASK     (0x03FF)
+#define DISP_COLOR_CAP_IN_DATA_MAIN_MASK     (0x03FF03FF)
+#define DISP_COLOR_CAP_IN_DATA_MAIN_CR_MASK  (0x03FF)
+#define DISP_COLOR_CAP_OUT_DATA_MAIN_MASK    (0x0FFF03FF)
+#define DISP_COLOR_CAP_OUT_DATA_MAIN_CR_MASK (0x01FFF)
+#define DISP_COLOR_Y_SLOPE_1_0_MAIN_MASK     (0x0FF00FF)
+#define DISP_COLOR_Y_SLOPE_3_2_MAIN_MASK     (0x0FF00FF)
+#define DISP_COLOR_Y_SLOPE_5_4_MAIN_MASK     (0x0FF00FF)
+#define DISP_COLOR_Y_SLOPE_7_6_MAIN_MASK     (0x0FF00FF)
+#define DISP_COLOR_Y_SLOPE_9_8_MAIN_MASK     (0x0FF00FF)
+#define DISP_COLOR_Y_SLOPE_11_10_MAIN_MASK   (0x0FF00FF)
+#define DISP_COLOR_Y_SLOPE_13_12_MAIN_MASK   (0x0FF00FF)
+#define DISP_COLOR_Y_SLOPE_15_14_MAIN_MASK   (0x0FF00FF)
+#define DISP_COLOR_LOCAL_HUE_CD_0_MASK       (0xFFFFFFFF)
+#define DISP_COLOR_LOCAL_HUE_CD_1_MASK       (0xFFFFFFFF)
+#define DISP_COLOR_LOCAL_HUE_CD_2_MASK       (0xFFFFFFFF)
+#define DISP_COLOR_LOCAL_HUE_CD_3_MASK       (0xFFFFFFFF)
+#define DISP_COLOR_LOCAL_HUE_CD_4_MASK       (0xFFFFFFFF)
+#define DISP_COLOR_TWO_D_WINDOW_1_MASK       (0xFFFFFFFF)
+#define DISP_COLOR_TWO_D_W1_RESULT_MASK      (0x0FFFFFF)
+#define DISP_COLOR_SAT_HIST_X_CFG_MAIN_MASK  (0xFFFFFFFF)
+#define DISP_COLOR_SAT_HIST_Y_CFG_MAIN_MASK  (0xFFFFFFFF)
+#define DISP_COLOR_BWS_2_MASK                (0x0C000000)
+#define DISP_COLOR_CRC_0_MASK                (0x0FFFFF)
+#define DISP_COLOR_CRC_1_MASK                (0x1FFF1FFF)
+#define DISP_COLOR_CRC_2_MASK                (0x0FFF0FFF)
+#define DISP_COLOR_CRC_3_MASK                (0x3FFFFFFF)
+#define DISP_COLOR_CRC_4_MASK                (0xFFFFFFFF)
+#define DISP_COLOR_PARTIAL_SAT_GAIN1_0_MASK  (0xFFFFFFFF)
+#define DISP_COLOR_PARTIAL_SAT_GAIN1_1_MASK  (0xFFFFFFFF)
+#define DISP_COLOR_PARTIAL_SAT_GAIN1_2_MASK  (0xFFFFFFFF)
+#define DISP_COLOR_PARTIAL_SAT_GAIN1_3_MASK  (0xFFFFFFFF)
+#define DISP_COLOR_PARTIAL_SAT_GAIN1_4_MASK  (0xFFFFFFFF)
+#define DISP_COLOR_PARTIAL_SAT_GAIN2_0_MASK  (0xFFFFFFFF)
+#define DISP_COLOR_PARTIAL_SAT_GAIN2_1_MASK  (0xFFFFFFFF)
+#define DISP_COLOR_PARTIAL_SAT_GAIN2_2_MASK  (0xFFFFFFFF)
+#define DISP_COLOR_PARTIAL_SAT_GAIN2_3_MASK  (0xFFFFFFFF)
+#define DISP_COLOR_PARTIAL_SAT_GAIN2_4_MASK  (0xFFFFFFFF)
+#define DISP_COLOR_PARTIAL_SAT_GAIN3_0_MASK  (0xFFFFFFFF)
+#define DISP_COLOR_PARTIAL_SAT_GAIN3_1_MASK  (0xFFFFFFFF)
+#define DISP_COLOR_PARTIAL_SAT_GAIN3_2_MASK  (0xFFFFFFFF)
+#define DISP_COLOR_PARTIAL_SAT_GAIN3_3_MASK  (0xFFFFFFFF)
+#define DISP_COLOR_PARTIAL_SAT_GAIN3_4_MASK  (0xFFFFFFFF)
+#define DISP_COLOR_PARTIAL_SAT_POINT1_0_MASK (0xFFFFFFFF)
+#define DISP_COLOR_PARTIAL_SAT_POINT1_1_MASK (0xFFFFFFFF)
+#define DISP_COLOR_PARTIAL_SAT_POINT1_2_MASK (0xFFFFFFFF)
+#define DISP_COLOR_PARTIAL_SAT_POINT1_3_MASK (0xFFFFFFFF)
+#define DISP_COLOR_PARTIAL_SAT_POINT1_4_MASK (0xFFFFFFFF)
+#define DISP_COLOR_PARTIAL_SAT_POINT2_0_MASK (0xFFFFFFFF)
+#define DISP_COLOR_PARTIAL_SAT_POINT2_1_MASK (0xFFFFFFFF)
+#define DISP_COLOR_PARTIAL_SAT_POINT2_2_MASK (0xFFFFFFFF)
+#define DISP_COLOR_PARTIAL_SAT_POINT2_3_MASK (0xFFFFFFFF)
+#define DISP_COLOR_PARTIAL_SAT_POINT2_4_MASK (0xFFFFFFFF)
+#define DISP_COLOR_CM_CONTROL_MASK           (0x37FF)
+#define DISP_COLOR_CM_W1_HUE_0_MASK          (0x3FFFFFFF)
+#define DISP_COLOR_CM_W1_HUE_1_MASK          (0x3FFFFFFF)
+#define DISP_COLOR_CM_W1_HUE_2_MASK          (0xFFFFFFF)
+#define DISP_COLOR_CM_W1_HUE_3_MASK          (0xFFFFFFFF)
+#define DISP_COLOR_CM_W1_HUE_4_MASK          (0x3FFFFFF)
+#define DISP_COLOR_CM_W1_LUMA_0_MASK         (0x3FFFFFFF)
+#define DISP_COLOR_CM_W1_LUMA_1_MASK         (0x3FFFFFFF)
+#define DISP_COLOR_CM_W1_LUMA_2_MASK         (0xFFFFFFF)
+#define DISP_COLOR_CM_W1_LUMA_3_MASK         (0xFFFFFFFF)
+#define DISP_COLOR_CM_W1_LUMA_4_MASK         (0x3FFFFFF)
+#define DISP_COLOR_CM_W1_SAT_0_MASK          (0x3FFFFFFF)
+#define DISP_COLOR_CM_W1_SAT_1_MASK          (0x3FFFFFFF)
+#define DISP_COLOR_CM_W1_SAT_2_MASK          (0xFFFFFFF)
+#define DISP_COLOR_CM_W1_SAT_3_MASK          (0xFFFFFFFF)
+#define DISP_COLOR_CM_W1_SAT_4_MASK          (0x3FFFFFF)
+#define DISP_COLOR_CM_W2_HUE_0_MASK          (0x3FFFFFFF)
+#define DISP_COLOR_CM_W2_HUE_1_MASK          (0x3FFFFFFF)
+#define DISP_COLOR_CM_W2_HUE_2_MASK          (0xFFFFFFF)
+#define DISP_COLOR_CM_W2_HUE_3_MASK          (0xFFFFFFFF)
+#define DISP_COLOR_CM_W2_HUE_4_MASK          (0x3FFFFFF)
+#define DISP_COLOR_CM_W2_LUMA_0_MASK         (0x3FFFFFFF)
+#define DISP_COLOR_CM_W2_LUMA_1_MASK         (0x3FFFFFFF)
+#define DISP_COLOR_CM_W2_LUMA_2_MASK         (0xFFFFFFF)
+#define DISP_COLOR_CM_W2_LUMA_3_MASK         (0xFFFFFFFF)
+#define DISP_COLOR_CM_W2_LUMA_4_MASK         (0x3FFFFFF)
+#define DISP_COLOR_CM_W2_SAT_0_MASK          (0x3FFFFFFF)
+#define DISP_COLOR_CM_W2_SAT_1_MASK          (0x3FFFFFFF)
+#define DISP_COLOR_CM_W2_SAT_2_MASK          (0xFFFFFFF)
+#define DISP_COLOR_CM_W2_SAT_3_MASK          (0xFFFFFFFF)
+#define DISP_COLOR_CM_W2_SAT_4_MASK          (0x3FFFFFF)
+#define DISP_COLOR_CM_W3_HUE_0_MASK          (0x3FFFFFFF)
+#define DISP_COLOR_CM_W3_HUE_1_MASK          (0x3FFFFFFF)
+#define DISP_COLOR_CM_W3_HUE_2_MASK          (0xFFFFFFF)
+#define DISP_COLOR_CM_W3_HUE_3_MASK          (0xFFFFFFFF)
+#define DISP_COLOR_CM_W3_HUE_4_MASK          (0x3FFFFFF)
+#define DISP_COLOR_CM_W3_LUMA_0_MASK         (0x3FFFFFFF)
+#define DISP_COLOR_CM_W3_LUMA_1_MASK         (0x3FFFFFFF)
+#define DISP_COLOR_CM_W3_LUMA_2_MASK         (0xFFFFFFF)
+#define DISP_COLOR_CM_W3_LUMA_3_MASK         (0xFFFFFFFF)
+#define DISP_COLOR_CM_W3_LUMA_4_MASK         (0x3FFFFFF)
+#define DISP_COLOR_CM_W3_SAT_0_MASK          (0x3FFFFFFF)
+#define DISP_COLOR_CM_W3_SAT_1_MASK          (0x3FFFFFFF)
+#define DISP_COLOR_CM_W3_SAT_2_MASK          (0xFFFFFFF)
+#define DISP_COLOR_CM_W3_SAT_3_MASK          (0xFFFFFFFF)
+#define DISP_COLOR_CM_W3_SAT_4_MASK          (0x3FFFFFF)
+#define DISP_COLOR_START_MASK                (0x0FF013F)
+#define DISP_COLOR_INTEN_MASK                (0x07)
+#define DISP_COLOR_INTSTA_MASK               (0x07)
+#define DISP_COLOR_OUT_SEL_MASK              (0x0777)
+#define DISP_COLOR_FRAME_DONE_DEL_MASK       (0x0FF)
+#define DISP_COLOR_CRC_MASK                  (0x07)
+#define DISP_COLOR_SW_SCRATCH_MASK           (0xFFFFFFFF)
+#define DISP_COLOR_CK_ON_MASK                (0x01)
+#define DISP_COLOR_INTERNAL_IP_WIDTH_MASK    (0x03FFF)
+#define DISP_COLOR_INTERNAL_IP_HEIGHT_MASK   (0x03FFF)
+#define DISP_COLOR_CM1_EN_MASK               (0x03)
+#define DISP_COLOR_CM2_EN_MASK               (0x017)
+#define DISP_COLOR_SHADOW_CTRL_MASK          (0x03)
+#define DISP_COLOR_R0_CRC_MASK               (0x03FFFF)
+#define DISP_COLOR_S_GAIN_BY_Y0_0_MASK       (0xFFFFFFFF)
+#define DISP_COLOR_S_GAIN_BY_Y0_1_MASK       (0xFFFFFFFF)
+#define DISP_COLOR_S_GAIN_BY_Y0_2_MASK       (0xFFFFFFFF)
+#define DISP_COLOR_S_GAIN_BY_Y0_3_MASK       (0xFFFFFFFF)
+#define DISP_COLOR_S_GAIN_BY_Y0_4_MASK       (0xFFFFFFFF)
+#define DISP_COLOR_S_GAIN_BY_Y64_0_MASK      (0xFFFFFFFF)
+#define DISP_COLOR_S_GAIN_BY_Y64_1_MASK      (0xFFFFFFFF)
+#define DISP_COLOR_S_GAIN_BY_Y64_2_MASK      (0xFFFFFFFF)
+#define DISP_COLOR_S_GAIN_BY_Y64_3_MASK      (0xFFFFFFFF)
+#define DISP_COLOR_S_GAIN_BY_Y64_4_MASK      (0xFFFFFFFF)
+#define DISP_COLOR_S_GAIN_BY_Y128_0_MASK     (0xFFFFFFFF)
+#define DISP_COLOR_S_GAIN_BY_Y128_1_MASK     (0xFFFFFFFF)
+#define DISP_COLOR_S_GAIN_BY_Y128_2_MASK     (0xFFFFFFFF)
+#define DISP_COLOR_S_GAIN_BY_Y128_3_MASK     (0xFFFFFFFF)
+#define DISP_COLOR_S_GAIN_BY_Y128_4_MASK     (0xFFFFFFFF)
+#define DISP_COLOR_S_GAIN_BY_Y192_0_MASK     (0xFFFFFFFF)
+#define DISP_COLOR_S_GAIN_BY_Y192_1_MASK     (0xFFFFFFFF)
+#define DISP_COLOR_S_GAIN_BY_Y192_2_MASK     (0xFFFFFFFF)
+#define DISP_COLOR_S_GAIN_BY_Y192_3_MASK     (0xFFFFFFFF)
+#define DISP_COLOR_S_GAIN_BY_Y192_4_MASK     (0xFFFFFFFF)
+#define DISP_COLOR_S_GAIN_BY_Y256_0_MASK     (0xFFFFFFFF)
+#define DISP_COLOR_S_GAIN_BY_Y256_1_MASK     (0xFFFFFFFF)
+#define DISP_COLOR_S_GAIN_BY_Y256_2_MASK     (0xFFFFFFFF)
+#define DISP_COLOR_S_GAIN_BY_Y256_3_MASK     (0xFFFFFFFF)
+#define DISP_COLOR_S_GAIN_BY_Y256_4_MASK     (0xFFFFFFFF)
+#define DISP_COLOR_LSP_1_MASK                (0x1FFFFFFF)
+#define DISP_COLOR_LSP_2_MASK                (0x3FFF7F7F)
+#endif  // __MDP_REG_COLOR_H__
diff --git a/drivers/media/platform/mtk-mdp3/mdp_reg_colorex.h b/drivers/media/platform/mtk-mdp3/mdp_reg_colorex.h
new file mode 100644
index 0000000000000000000000000000000000000000..4790e17a7c22f328c2cecd0755671d72a7a1185d
--- /dev/null
+++ b/drivers/media/platform/mtk-mdp3/mdp_reg_colorex.h
@@ -0,0 +1,97 @@
+#ifndef __MDP_REG_COLOREX_H__
+#define __MDP_REG_COLOREX_H__
+
+#include "mmsys_reg_base.h"
+
+#define PURP_TONE    0
+#define SKIN_TONE    1
+#define GRASS_TONE   2
+#define SKY_TONE     3
+
+#define PURP_TONE_START    0
+#define PURP_TONE_END      2
+#define SKIN_TONE_START    3
+#define SKIN_TONE_END     10
+#define GRASS_TONE_START  11
+#define GRASS_TONE_END    16
+#define SKY_TONE_START    17
+#define SKY_TONE_END      19
+
+#define SG1 0
+#define SG2 1
+#define SG3 2
+#define SP1 3
+#define SP2 4
+
+#define COLOREX_COLOR_BASE      (0x1400C000)
+#define COLOREX_CCORR_BASE      (0x1400D000)
+#define COLOREX_AAL_BASE        (0x1400E000)
+#define COLOREX_GAMMA_BASE      (0x1400F000)
+#define COLOREX_DITHER_BASE     (0x14010000)
+
+#define COLOREX_COLOR_CFG_MAIN             (COLOREX_COLOR_BASE+0x400)
+#define COLOREX_COLOR_PXL_CNT_MAIN         (COLOREX_COLOR_BASE+0x404)
+#define COLOREX_COLOR_LINE_CNT_MAIN        (COLOREX_COLOR_BASE+0x408)
+#define COLOREX_COLOR_WIN_X_MAIN           (COLOREX_COLOR_BASE+0x40C)
+#define COLOREX_COLOR_WIN_Y_MAIN           (COLOREX_COLOR_BASE+0x410)
+#define COLOREX_COLOR_DBG_CFG_MAIN         (COLOREX_COLOR_BASE+0x420)
+#define COLOREX_COLOR_C_BOOST_MAIN         (COLOREX_COLOR_BASE+0x428)
+#define COLOREX_COLOR_C_BOOST_MAIN_2       (COLOREX_COLOR_BASE+0x42C)
+#define COLOREX_COLOR_G_PIC_ADJ_MAIN_1     (COLOREX_COLOR_BASE+0x434)
+#define COLOREX_COLOR_G_PIC_ADJ_MAIN_2     (COLOREX_COLOR_BASE+0x438)
+#define COLOREX_COLOR_Y_SLOPE_1_0_MAIN     (COLOREX_COLOR_BASE+0x4A0)
+#define COLOREX_COLOR_LOCAL_HUE_CD_0       (COLOREX_COLOR_BASE+0x620)
+#define COLOREX_COLOR_TWO_D_WINDOW_1       (COLOREX_COLOR_BASE+0x740)
+#define COLOREX_COLOR_TWO_D_W1_RESULT      (COLOREX_COLOR_BASE+0x74C)
+#define COLOREX_COLOR_PART_SAT_GAIN1_0     (COLOREX_COLOR_BASE+0x7FC)
+#define COLOREX_COLOR_PART_SAT_GAIN1_1     (COLOREX_COLOR_BASE+0x800)
+#define COLOREX_COLOR_PART_SAT_GAIN1_2     (COLOREX_COLOR_BASE+0x804)
+#define COLOREX_COLOR_PART_SAT_GAIN1_3     (COLOREX_COLOR_BASE+0x808)
+#define COLOREX_COLOR_PART_SAT_GAIN1_4     (COLOREX_COLOR_BASE+0x80C)
+#define COLOREX_COLOR_PART_SAT_GAIN2_0     (COLOREX_COLOR_BASE+0x810)
+#define COLOREX_COLOR_PART_SAT_GAIN2_1     (COLOREX_COLOR_BASE+0x814)
+#define COLOREX_COLOR_PART_SAT_GAIN2_2     (COLOREX_COLOR_BASE+0x818)
+#define COLOREX_COLOR_PART_SAT_GAIN2_3	   (COLOREX_COLOR_BASE+0x81C)
+#define COLOREX_COLOR_PART_SAT_GAIN2_4     (COLOREX_COLOR_BASE+0x820)
+#define COLOREX_COLOR_PART_SAT_GAIN3_0     (COLOREX_COLOR_BASE+0x824)
+#define COLOREX_COLOR_PART_SAT_GAIN3_1     (COLOREX_COLOR_BASE+0x828)
+#define COLOREX_COLOR_PART_SAT_GAIN3_2     (COLOREX_COLOR_BASE+0x82C)
+#define COLOREX_COLOR_PART_SAT_GAIN3_3     (COLOREX_COLOR_BASE+0x830)
+#define COLOREX_COLOR_PART_SAT_GAIN3_4     (COLOREX_COLOR_BASE+0x834)
+#define COLOREX_COLOR_PART_SAT_POINT1_0    (COLOREX_COLOR_BASE+0x838)
+#define COLOREX_COLOR_PART_SAT_POINT1_1    (COLOREX_COLOR_BASE+0x83C)
+#define COLOREX_COLOR_PART_SAT_POINT1_2    (COLOREX_COLOR_BASE+0x840)
+#define COLOREX_COLOR_PART_SAT_POINT1_3    (COLOREX_COLOR_BASE+0x844)
+#define COLOREX_COLOR_PART_SAT_POINT1_4    (COLOREX_COLOR_BASE+0x848)
+#define COLOREX_COLOR_PART_SAT_POINT2_0    (COLOREX_COLOR_BASE+0x84C)
+#define COLOREX_COLOR_PART_SAT_POINT2_1    (COLOREX_COLOR_BASE+0x850)
+#define COLOREX_COLOR_PART_SAT_POINT2_2    (COLOREX_COLOR_BASE+0x854)
+#define COLOREX_COLOR_PART_SAT_POINT2_3    (COLOREX_COLOR_BASE+0x858)
+#define COLOREX_COLOR_PART_SAT_POINT2_4    (COLOREX_COLOR_BASE+0x85C)
+
+#define COLOREX_COLOR_START        (COLOREX_COLOR_BASE+0xC00)
+#define COLOREX_COLOR_INTEN        (COLOREX_COLOR_BASE+0xC04)
+#define COLOREX_COLOR_OUT_SEL      (COLOREX_COLOR_BASE+0xC08)
+#define COLOREX_COLOR_CK_ON        (COLOREX_COLOR_BASE+0xC28)
+#define COLOREX_COLOR_INTERNAL_IP_WIDTH    (COLOREX_COLOR_BASE+0xC50)
+#define COLOREX_COLOR_INTERNAL_IP_HEIGHT   (COLOREX_COLOR_BASE+0xC54)
+#define COLOREX_COLOR_CM1_EN       (COLOREX_COLOR_BASE+0xC60)
+#define COLOREX_COLOR_CM2_EN       (COLOREX_COLOR_BASE+0xCA0)
+
+#define COLOREX_CCORR_EN            (COLOREX_CCORR_BASE+0x000)
+#define COLOREX_CCORR_CFG           (COLOREX_CCORR_BASE+0x020)
+#define COLOREX_CCORR_SIZE          (COLOREX_CCORR_BASE+0x030)
+
+#define COLOREX_AAL_EN              (COLOREX_AAL_BASE+0x000)
+#define COLOREX_AAL_CFG             (COLOREX_AAL_BASE+0x020)
+#define COLOREX_AAL_SIZE            (COLOREX_AAL_BASE+0x030)
+
+#define COLOREX_GAMMA_EN            (COLOREX_GAMMA_BASE+0x000)
+#define COLOREX_GAMMA_CFG           (COLOREX_GAMMA_BASE+0x020)
+#define COLOREX_GAMMA_SIZE          (COLOREX_GAMMA_BASE+0x030)
+
+#define COLOREX_DITHER_EN           (COLOREX_DITHER_BASE+0x000)
+#define COLOREX_DITHER_CFG          (COLOREX_DITHER_BASE+0x020)
+#define COLOREX_DITHER_SIZE         (COLOREX_DITHER_BASE+0x030)
+
+#endif  // __MDP_REG_TDSHP_H__
\ No newline at end of file
diff --git a/drivers/media/platform/mtk-mdp3/mdp_reg_fg.h b/drivers/media/platform/mtk-mdp3/mdp_reg_fg.h
new file mode 100644
index 0000000000000000000000000000000000000000..456f56a37b30ecdc7686d3e60e42561d37ca821f
--- /dev/null
+++ b/drivers/media/platform/mtk-mdp3/mdp_reg_fg.h
@@ -0,0 +1,74 @@
+#ifndef __MDP_REG_FG_H__
+#define __MDP_REG_FG_H__
+
+#include "mmsys_reg_base.h"
+
+
+#define MDP_FG_TRIGGER          (0x0)
+#define MDP_FG_STATUS           (0x4)
+#define MDP_FG_LUMA_TBL_BASE    (0x8)
+#define MDP_FG_CB_TBL_BASE      (0xc)
+#define MDP_FG_CR_TBL_BASE      (0x10)
+#define MDP_FG_LUT_BASE         (0x14)
+#define MDP_FG_IRQ_CTRL         (0x18)
+#define MDP_FG_IRQ_STATUS       (0x1c)
+#define MDP_FG_FG_CTRL_0        (0x20)
+#define MDP_FG_FG_CK_EN         (0x24)
+#define MDP_FG_BACK_DOOR_0      (0x2c)
+#define MDP_FG_CRC_TBL_0        (0x30)
+#define MDP_FG_CRC_TBL_1        (0x34)
+#define MDP_FG_CRC_DATA_0       (0x38)
+#define MDP_FG_CRC_DATA_1       (0x3c)
+#define MDP_FG_CRC_DATA_2       (0x40)
+#define MDP_FG_CRC_DATA_3       (0x44)
+#define MDP_FG_PIC_INFO_0       (0x400)
+#define MDP_FG_PIC_INFO_1       (0x404)
+#define MDP_FG_PPS_0            (0x408)
+#define MDP_FG_PPS_1            (0x40c)
+#define MDP_FG_PPS_2            (0x410)
+#define MDP_FG_PPS_3            (0x414)
+#define MDP_FG_TILE_INFO_0      (0x418)
+#define MDP_FG_TILE_INFO_1      (0x41c)
+#define MDP_FG_DEBUG_0          (0x500)
+#define MDP_FG_DEBUG_1          (0x504)
+#define MDP_FG_DEBUG_2          (0x508)
+#define MDP_FG_DEBUG_3          (0x50c)
+#define MDP_FG_DEBUG_4          (0x510)
+#define MDP_FG_DEBUG_5          (0x514)
+#define MDP_FG_DEBUG_6          (0x518)
+
+/* MASK */
+#define MDP_FG_TRIGGER_MASK          (0x00000007)
+#define MDP_FG_STATUS_MASK           (0x00000007)
+#define MDP_FG_LUMA_TBL_BASE_MASK    (0xFFFFFFFF)
+#define MDP_FG_CB_TBL_BASE_MASK      (0xFFFFFFFF)
+#define MDP_FG_CR_TBL_BASE_MASK      (0xFFFFFFFF)
+#define MDP_FG_LUT_BASE_MASK         (0xFFFFFFFF)
+#define MDP_FG_IRQ_CTRL_MASK         (0x00000071)
+#define MDP_FG_IRQ_STATUS_MASK       (0x00000070)
+#define MDP_FG_FG_CTRL_0_MASK        (0x00000033)
+#define MDP_FG_FG_CK_EN_MASK         (0x0000000F)
+#define MDP_FG_BACK_DOOR_0_MASK      (0x000000F3)
+#define MDP_FG_CRC_TBL_0_MASK        (0xFFFFFFFF)
+#define MDP_FG_CRC_TBL_1_MASK        (0xFFFFFFFF)
+#define MDP_FG_CRC_DATA_0_MASK       (0xFFFFFFFF)
+#define MDP_FG_CRC_DATA_1_MASK       (0xFFFFFFFF)
+#define MDP_FG_CRC_DATA_2_MASK       (0xFFFFFFFF)
+#define MDP_FG_CRC_DATA_3_MASK       (0xFFFFFFFF)
+#define MDP_FG_PIC_INFO_0_MASK       (0x0000001F)
+#define MDP_FG_PIC_INFO_1_MASK       (0xFFFFFFFF)
+#define MDP_FG_PPS_0_MASK            (0x1FFFFFFF)
+#define MDP_FG_PPS_1_MASK            (0x01FFFFFF)
+#define MDP_FG_PPS_2_MASK            (0x01FFFFFF)
+#define MDP_FG_PPS_3_MASK            (0x00FFFFFF)
+#define MDP_FG_TILE_INFO_0_MASK      (0xFFFFFFFF)
+#define MDP_FG_TILE_INFO_1_MASK      (0xFFFFFFFF)
+#define MDP_FG_DEBUG_0_MASK          (0xFFFFFFFF)
+#define MDP_FG_DEBUG_1_MASK          (0xFFFFFFFF)
+#define MDP_FG_DEBUG_2_MASK          (0xFFFFFFFF)
+#define MDP_FG_DEBUG_3_MASK          (0xFFFFFFFF)
+#define MDP_FG_DEBUG_4_MASK          (0x1007FF0F)
+#define MDP_FG_DEBUG_5_MASK          (0x00000007)
+#define MDP_FG_DEBUG_6_MASK          (0xFFFFFFFF)
+
+#endif  //__MDP_REG_FG_H__
diff --git a/drivers/media/platform/mtk-mdp3/mdp_reg_hdr.h b/drivers/media/platform/mtk-mdp3/mdp_reg_hdr.h
new file mode 100644
index 0000000000000000000000000000000000000000..9ca5b03b01ae1f3fe89e201c13ac35a628e37365
--- /dev/null
+++ b/drivers/media/platform/mtk-mdp3/mdp_reg_hdr.h
@@ -0,0 +1,268 @@
+#ifndef __MDP_REG_HDR_H__
+#define __MDP_REG_HDR_H__
+
+#include "mmsys_reg_base.h"
+
+#define MDP_HDR_TOP                 (0x000)
+#define MDP_HDR_RELAY               (0x004)
+#define MDP_HDR_INTERR              (0x008)
+#define MDP_HDR_INTSTA              (0x00C)
+#define MDP_HDR_ENGSTA              (0x010)
+#define MDP_HDR_SIZE_0              (0x014)
+#define MDP_HDR_SIZE_1              (0x018)
+#define MDP_HDR_SIZE_2              (0x01C)
+#define MDP_HDR_HIST_CTRL_0         (0x020)
+#define MDP_HDR_HIST_CTRL_1         (0x024)
+#define MDP_HDR_HIST_CTRL_2         (0x028)
+#define MDP_HDR_DEMO_CTRL_0         (0x02C)
+#define MDP_HDR_DEMO_CTRL_1         (0x030)
+#define MDP_HDR_DEMO_CTRL_2         (0x034)
+#define MDP_HDR_3x3_COEF_0          (0x038)
+#define MDP_HDR_3x3_COEF_1          (0x03C)
+#define MDP_HDR_3x3_COEF_2          (0x040)
+#define MDP_HDR_3x3_COEF_3          (0x044)
+#define MDP_HDR_3x3_COEF_4          (0x048)
+#define MDP_HDR_3x3_COEF_5          (0x04C)
+#define MDP_HDR_3x3_COEF_6          (0x050)
+#define MDP_HDR_3x3_COEF_7          (0x054)
+#define MDP_HDR_3x3_COEF_8          (0x058)
+#define MDP_HDR_3x3_COEF_9          (0x05C)
+#define MDP_HDR_3x3_COEF_10         (0x060)
+#define MDP_HDR_3x3_COEF_11         (0x064)
+#define MDP_HDR_3x3_COEF_12         (0x068)
+#define MDP_HDR_3x3_COEF_13         (0x06C)
+#define MDP_HDR_3x3_COEF_14         (0x070)
+#define MDP_HDR_3x3_COEF_15         (0x074)
+#define MDP_HDR_TONE_MAP_P01        (0x078)
+#define MDP_HDR_TONE_MAP_P02        (0x07C)
+#define MDP_HDR_TONE_MAP_P03        (0x080)
+#define MDP_HDR_TONE_MAP_P04        (0x084)
+#define MDP_HDR_TONE_MAP_P05        (0x088)
+#define MDP_HDR_TONE_MAP_P06        (0x08C)
+#define MDP_HDR_TONE_MAP_P07        (0x090)
+#define MDP_HDR_TONE_MAP_P08        (0x094)
+#define MDP_HDR_TONE_MAP_S00        (0x098)
+#define MDP_HDR_TONE_MAP_S01        (0x09C)
+#define MDP_HDR_TONE_MAP_S02        (0x0A0)
+#define MDP_HDR_TONE_MAP_S03        (0x0A4)
+#define MDP_HDR_TONE_MAP_S04        (0x0A8)
+#define MDP_HDR_TONE_MAP_S05        (0x0AC)
+#define MDP_HDR_TONE_MAP_S06        (0x0B0)
+#define MDP_HDR_TONE_MAP_S07        (0x0B4)
+#define MDP_HDR_TONE_MAP_S08        (0x0B8)
+#define MDP_HDR_TONE_MAP_S09        (0x0BC)
+#define MDP_HDR_TONE_MAP_S10        (0x0C0)
+#define MDP_HDR_TONE_MAP_S11        (0x0C4)
+#define MDP_HDR_TONE_MAP_S12        (0x0C8)
+#define MDP_HDR_TONE_MAP_S13        (0x0CC)
+#define MDP_HDR_TONE_MAP_S14        (0x0D0)
+#define MDP_HDR_TONE_MAP_S15        (0x0D4)
+#define MDP_HDR_B_CHANNEL_NR        (0x0D8)
+#define MDP_HDR_HIST_ADDR           (0x0DC)
+#define MDP_HDR_HIST_DATA           (0x0E0)
+#define MDP_HDR_A_LUMINANCE         (0x0E4)
+#define MDP_HDR_GAIN_TABLE_0        (0x0E8)
+#define MDP_HDR_GAIN_TABLE_1        (0x0EC)
+#define MDP_HDR_GAIN_TABLE_2        (0x0F0)
+#define MDP_HDR_LBOX_DET_1          (0x0F8)
+#define MDP_HDR_LBOX_DET_2          (0x0FC)
+#define MDP_HDR_LBOX_DET_3          (0x100)
+#define MDP_HDR_LBOX_DET_4          (0x104)
+#define MDP_HDR_LBOX_DET_5          (0x108)
+#define MDP_HDR_CURSOR_CTRL         (0x10C)
+#define MDP_HDR_CURSOR_POS          (0x110)
+#define MDP_HDR_CURSOR_COLOR        (0x114)
+#define MDP_HDR_TILE_POS            (0x118)
+#define MDP_HDR_CURSOR_BUF0         (0x11C)
+#define MDP_HDR_CURSOR_BUF1         (0x120)
+#define MDP_HDR_CURSOR_BUF2         (0x124)
+#define MDP_HDR_R2Y_00              (0x128)
+#define MDP_HDR_R2Y_01              (0x12C)
+#define MDP_HDR_R2Y_02              (0x130)
+#define MDP_HDR_R2Y_03              (0x134)
+#define MDP_HDR_R2Y_04              (0x138)
+#define MDP_HDR_R2Y_05              (0x13C)
+#define MDP_HDR_R2Y_06              (0x140)
+#define MDP_HDR_R2Y_07              (0x144)
+#define MDP_HDR_R2Y_08              (0x148)
+#define MDP_HDR_R2Y_09              (0x14C)
+#define MDP_HDR_Y2R_00              (0x150)
+#define MDP_HDR_Y2R_01              (0x154)
+#define MDP_HDR_Y2R_02              (0x15C)
+#define MDP_HDR_Y2R_03              (0x160)
+#define MDP_HDR_Y2R_04              (0x164)
+#define MDP_HDR_Y2R_05              (0x168)
+#define MDP_HDR_Y2R_06              (0x16C)
+#define MDP_HDR_Y2R_07              (0x170)
+#define MDP_HDR_Y2R_08              (0x174)
+#define MDP_HDR_Y2R_09              (0x178)
+#define MDP_HDR_Y2R_10              (0x17C)
+#define MDP_HDR_PROG_EOTF_0         (0x180)
+#define MDP_HDR_PROG_EOTF_1         (0x184)
+#define MDP_HDR_PROG_EOTF_2         (0x188)
+#define MDP_HDR_PROG_EOTF_3         (0x18C)
+#define MDP_HDR_PROG_EOTF_4         (0x190)
+#define MDP_HDR_PROG_EOTF_5         (0x194)
+#define MDP_HDR_EOTF_TABLE_0        (0x19C)
+#define MDP_HDR_EOTF_TABLE_1        (0x1A0)
+#define MDP_HDR_EOTF_TABLE_2        (0x1A4)
+#define MDP_HDR_OETF_TABLE_0        (0x1A8)
+#define MDP_HDR_OETF_TABLE_1        (0x1AC)
+#define MDP_TONE_MAP_TOP            (0x1B0)
+#define MDP_HDR_EOTF_ACCURACY_0     (0x1B4)
+#define MDP_HDR_EOTF_ACCURACY_1     (0x1B8)
+#define MDP_HDR_EOTF_ACCURACY_2     (0x1BC)
+#define MDP_HDR_L_MIX_0             (0x1C0)
+#define MDP_HDR_L_MIX_1             (0x1C4)
+#define MDP_HDR_L_MIX_2             (0x1C8)
+#define MDP_HDR_Y_GAIN_IDX_0        (0x1CC)
+#define MDP_HDR_Y_GAIN_IDX_1        (0x1D0)
+#define MDP_HDR_DUMMY0              (0x1D4)
+#define MDP_HDR_DUMMY1              (0x1D8)
+#define MDP_HDR_DUMMY2              (0x1DC)
+#define MDP_HDR_HLG_SG              (0x1E0)
+
+//TODO: OLD REGISTER TO REMOVE
+//#define MDP_HDR_PROG_EOTF           (0x154)
+//#define MDP_HDR_TONE_MDP_TOP        (0x16C)
+//TODO END
+
+// MASK
+#define MDP_HDR_RELAY_MASK          (0x01)
+#define MDP_HDR_TOP_MASK            (0xFF0FEB6D)
+#define MDP_HDR_INTERR_MASK         (0x0F)
+#define MDP_HDR_INTSTA_MASK         (0x0F)
+#define MDP_HDR_ENGSTA_MASK         (0x07)
+#define MDP_HDR_SIZE_0_MASK         (0x1FFF1FFF)
+#define MDP_HDR_SIZE_1_MASK         (0x1FFF1FFF)
+#define MDP_HDR_SIZE_2_MASK         (0x1FFF1FFF)
+#define MDP_HDR_HIST_CTRL_0_MASK    (0x1FFF1FFF)
+#define MDP_HDR_HIST_CTRL_1_MASK    (0x1FFF1FFF)
+#define MDP_HDR_HIST_CTRL_2_MASK    (0x1FFF1FFF)
+#define MDP_HDR_DEMO_CTRL_0_MASK    (0x1FFF1FFF)
+#define MDP_HDR_DEMO_CTRL_1_MASK    (0xDFFF1FFF)
+#define MDP_HDR_DEMO_CTRL_2_MASK    (0xDFFF1FFF)
+#define MDP_HDR_3x3_COEF_0_MASK     (0x03)
+#define MDP_HDR_3x3_COEF_1_MASK     (0xFFFFFFFF)
+#define MDP_HDR_3x3_COEF_2_MASK     (0xFFFFFFFF)
+#define MDP_HDR_3x3_COEF_3_MASK     (0xFFFFFFFF)
+#define MDP_HDR_3x3_COEF_4_MASK     (0xFFFFFFFF)
+#define MDP_HDR_3x3_COEF_5_MASK     (0x0FFFF)
+#define MDP_HDR_3x3_COEF_6_MASK     (0x01FFFF)
+#define MDP_HDR_3x3_COEF_7_MASK     (0x01FFFF)
+#define MDP_HDR_3x3_COEF_8_MASK     (0x01FFFF)
+#define MDP_HDR_3x3_COEF_9_MASK     (0x01FFFF)
+#define MDP_HDR_3x3_COEF_10_MASK    (0x01FFFF)
+#define MDP_HDR_3x3_COEF_11_MASK    (0x01FFFF)
+#define MDP_HDR_3x3_COEF_12_MASK    (0x01FFFF)
+#define MDP_HDR_3x3_COEF_13_MASK    (0x01FFFF)
+#define MDP_HDR_3x3_COEF_14_MASK    (0x01FFFF)
+#define MDP_HDR_3x3_COEF_15_MASK    (0x01FFFF)
+
+#define MDP_HDR_TONE_MAP_P01_MASK   (0xFFFFFFFF)
+#define MDP_HDR_TONE_MAP_P02_MASK   (0xFFFFFFFF)
+#define MDP_HDR_TONE_MAP_P03_MASK   (0xFFFFFFFF)
+#define MDP_HDR_TONE_MAP_P04_MASK   (0xFFFFFFFF)
+#define MDP_HDR_TONE_MAP_P05_MASK   (0xFFFFFFFF)
+#define MDP_HDR_TONE_MAP_P06_MASK   (0xFFFFFFFF)
+#define MDP_HDR_TONE_MAP_P07_MASK   (0xFFFFFFFF)
+#define MDP_HDR_TONE_MAP_P08_MASK   (0xFFFFFFFF)
+
+#define MDP_HDR_TONE_MAP_S00_MASK   (0x07FFFF)
+#define MDP_HDR_TONE_MAP_S01_MASK   (0x07FFFF)
+#define MDP_HDR_TONE_MAP_S02_MASK   (0x07FFFF)
+#define MDP_HDR_TONE_MAP_S03_MASK   (0x07FFFF)
+#define MDP_HDR_TONE_MAP_S04_MASK   (0x07FFFF)
+#define MDP_HDR_TONE_MAP_S05_MASK   (0x07FFFF)
+#define MDP_HDR_TONE_MAP_S06_MASK   (0x07FFFF)
+#define MDP_HDR_TONE_MAP_S07_MASK   (0x07FFFF)
+#define MDP_HDR_TONE_MAP_S08_MASK   (0x07FFFF)
+#define MDP_HDR_TONE_MAP_S09_MASK   (0x07FFFF)
+#define MDP_HDR_TONE_MAP_S10_MASK   (0x07FFFF)
+#define MDP_HDR_TONE_MAP_S11_MASK   (0x07FFFF)
+#define MDP_HDR_TONE_MAP_S12_MASK   (0x07FFFF)
+#define MDP_HDR_TONE_MAP_S13_MASK   (0x07FFFF)
+#define MDP_HDR_TONE_MAP_S14_MASK   (0x07FFFF)
+#define MDP_HDR_TONE_MAP_S15_MASK   (0x07FFFF)
+
+#define MDP_HDR_B_CHANNEL_NR_MASK   (0x0F3)
+#define MDP_HDR_HIST_ADDR_MASK      (0xBF3F2F3F)
+#define MDP_HDR_HIST_DATA_MASK      (0xFFFFFFFF)
+#define MDP_HDR_A_LUMINANCE_MASK    (0x0F1)
+#define MDP_HDR_GAIN_TABLE_0_MASK   (0x80003D7F)
+#define MDP_HDR_GAIN_TABLE_1_MASK   (0xFFFFFFFF)
+#define MDP_HDR_GAIN_TABLE_2_MASK   (0x007FFFFF)
+//#define MDP_HDR_Y2R_R2Y_MASK        (0x07)
+#define MDP_HDR_LBOX_DET_1_MASK     (0xFFFFFFF1)
+#define MDP_HDR_LBOX_DET_2_MASK     (0x0FF)
+#define MDP_HDR_LBOX_DET_3_MASK     (0x1FFF1FFF)
+#define MDP_HDR_LBOX_DET_4_MASK     (0x1FFF1FFF)
+#define MDP_HDR_LBOX_DET_5_MASK     (0x1FFF1FFF)
+#define MDP_HDR_CURSOR_CTRL_MASK    (0x0F1)
+#define MDP_HDR_CURSOR_POS_MASK     (0x1FFF1FFF)
+#define MDP_HDR_CURSOR_COLOR_MASK   (0x0FFF)
+#define MDP_HDR_TILE_POS_MASK       (0x1FFF1FFF)
+#define MDP_HDR_CURSOR_BUF0_MASK    (0xFFFFFFFF)
+#define MDP_HDR_CURSOR_BUF1_MASK    (0x0FFFF)
+#define MDP_HDR_CURSOR_BUF2_MASK    (0x0FFFF)
+
+#define MDP_HDR_R2Y_00_MASK         (0xFFFFFFFF)
+#define MDP_HDR_R2Y_01_MASK         (0xFFFFFFFF)
+#define MDP_HDR_R2Y_02_MASK         (0xFFFFFFFF)
+#define MDP_HDR_R2Y_03_MASK         (0xFFFFFFFF)
+#define MDP_HDR_R2Y_04_MASK         (0xFFFF)
+#define MDP_HDR_R2Y_05_MASK         (0x1FFF1FFF)
+#define MDP_HDR_R2Y_06_MASK         (0xFFFF8000)
+#define MDP_HDR_R2Y_07_MASK         (0x7FF07FF)
+#define MDP_HDR_R2Y_08_MASK         (0xFFFFFC00)
+#define MDP_HDR_R2Y_09_MASK         (0x0F)
+
+#define MDP_HDR_Y2R_00_MASK         (0xFFFFFFFF)
+#define MDP_HDR_Y2R_01_MASK         (0xFFFFFFFF)
+#define MDP_HDR_Y2R_02_MASK         (0xFFFFFFFF)
+#define MDP_HDR_Y2R_03_MASK         (0xFFFFFFFF)
+#define MDP_HDR_Y2R_04_MASK         (0xFFFF)
+#define MDP_HDR_Y2R_05_MASK         (0x7FF07FF)
+#define MDP_HDR_Y2R_06_MASK         (0x7FF)
+#define MDP_HDR_Y2R_07_MASK         (0x1FFF1FFF)
+#define MDP_HDR_Y2R_08_MASK         (0x1FFF)
+#define MDP_HDR_Y2R_09_MASK         (0x0F)
+#define MDP_HDR_Y2R_10_MASK         (0xFFFFFFFF)
+
+#define MDP_HDR_PROG_EOTF_0_MASK    (0x0007FFFFF)
+#define MDP_HDR_PROG_EOTF_1_MASK    (0x000001FF)
+#define MDP_HDR_PROG_EOTF_2_MASK    (0x0007FFFFF)
+#define MDP_HDR_PROG_EOTF_3_MASK    (0x000001FF)
+#define MDP_HDR_PROG_EOTF_4_MASK    (0x0007FFFFF)
+#define MDP_HDR_PROG_EOTF_5_MASK    (0x000001FF)
+
+#define MDP_HDR_PROG_EOTF_MASK      (0xFFE1FFFF)
+#define MDP_HDR_EOTF_TABLE_0_MASK   (0x8000F9FF)
+#define MDP_HDR_EOTF_TABLE_1_MASK   (0xFFFFFFFF)
+#define MDP_HDR_EOTF_TABLE_2_MASK   (0x003FFFFF)
+#define MDP_HDR_OETF_TABLE_0_MASK   (0x8000FBFF)
+#define MDP_HDR_OETF_TABLE_1_MASK   (0xFFFFFFFF)
+
+#define MDP_TONE_MAP_TOP_MASK       (0x00000001)
+#define MDP_HDR_EOTF_ACCURACY_0_MASK (0x00000001)
+#define MDP_HDR_EOTF_ACCURACY_1_MASK (0x03FF03FF)
+#define MDP_HDR_EOTF_ACCURACY_2_MASK (0x03FF03FF)
+
+#define MDP_HDR_L_MIX_0_MASK        (0x000000F1)
+#define MDP_HDR_L_MIX_1_MASK        (0x000003FF)
+#define MDP_HDR_L_MIX_2_MASK        (0x000003FF)
+
+#define MDP_HDR_Y_GAIN_IDX_0_MASK   (0x07FF07FF)
+#define MDP_HDR_Y_GAIN_IDX_1_MASK   (0x000007FF)
+
+#define MDP_HDR_DUMMY0_MASK         (0xFFFFFFFF)
+#define MDP_HDR_DUMMY1_MASK         (0xFFFFFFFF)
+#define MDP_HDR_DUMMY2_MASK         (0xFFFFFFFF)
+
+#define MDP_HDR_HLG_SG_MASK         (0x0000FFFF)
+
+#define MDP_HDR_TONE_MDP_TOP_MASK   (0x01)
+//#define MDP_HDR_DUMMY0_MASK         (0xFFFFFFFF)
+//#define MDP_HDR_DUMMY1_MASK         (0xFFFFFFFF)
+//#define MDP_HDR_DUMMY2_MASK         (0xFFFFFFFF)
+#endif // __MDP_REG_HDR_H__
\ No newline at end of file
diff --git a/drivers/media/platform/mtk-mdp3/mdp_reg_isp.h b/drivers/media/platform/mtk-mdp3/mdp_reg_isp.h
new file mode 100644
index 0000000000000000000000000000000000000000..5334cd932b55d26371b262ca65a191c18cca944a
--- /dev/null
+++ b/drivers/media/platform/mtk-mdp3/mdp_reg_isp.h
@@ -0,0 +1,27 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (c) 2021 MediaTek Inc.
+ * Author: Ping-Hsun Wu <ping-hsun.wu@mediatek.com>
+ */
+
+#ifndef __ISP_REG_H__
+#define __ISP_REG_H__
+
+enum isp_dip_cq {
+	ISP_DRV_DIP_CQ_THRE0 = 0,
+	ISP_DRV_DIP_CQ_THRE1,
+	ISP_DRV_DIP_CQ_THRE2,
+	ISP_DRV_DIP_CQ_THRE3,
+	ISP_DRV_DIP_CQ_THRE4,
+	ISP_DRV_DIP_CQ_THRE5,
+	ISP_DRV_DIP_CQ_THRE6,
+	ISP_DRV_DIP_CQ_THRE7,
+	ISP_DRV_DIP_CQ_THRE8,
+	ISP_DRV_DIP_CQ_THRE9,
+	ISP_DRV_DIP_CQ_THRE10,
+	ISP_DRV_DIP_CQ_THRE11,
+	ISP_DRV_DIP_CQ_NUM,
+	ISP_DRV_DIP_CQ_NONE,
+};
+
+#endif  // __ISP_REG_H__
diff --git a/drivers/media/platform/mtk-mdp3/mdp_reg_merge.h b/drivers/media/platform/mtk-mdp3/mdp_reg_merge.h
new file mode 100644
index 0000000000000000000000000000000000000000..84ade3d59393c5bc1624d836f16139aa49db2573
--- /dev/null
+++ b/drivers/media/platform/mtk-mdp3/mdp_reg_merge.h
@@ -0,0 +1,19 @@
+#ifndef __MDP_REG_MERGE_H__
+#define __MDP_REG_MERGE_H__
+
+#include "mmsys_reg_base.h"
+
+#define VPP_MERGE_ENABLE	(0x000)
+#define VPP_MERGE_CFG_0		(0x010)
+#define VPP_MERGE_CFG_4		(0x020)
+#define VPP_MERGE_CFG_12	(0x040)
+#define VPP_MERGE_CFG_24	(0x070)
+#define VPP_MERGE_CFG_25	(0x074)
+
+#define VPP_MERGE_ENABLE_MASK	(0xFFFFFFFF)
+#define VPP_MERGE_CFG_0_MASK	(0xFFFFFFFF)
+#define VPP_MERGE_CFG_4_MASK	(0xFFFFFFFF)
+#define VPP_MERGE_CFG_12_MASK	(0xFFFFFFFF)
+#define VPP_MERGE_CFG_24_MASK	(0xFFFFFFFF)
+#define VPP_MERGE_CFG_25_MASK	(0xFFFFFFFF)
+#endif
diff --git a/drivers/media/platform/mtk-mdp3/mdp_reg_ovl.h b/drivers/media/platform/mtk-mdp3/mdp_reg_ovl.h
new file mode 100644
index 0000000000000000000000000000000000000000..01475381c01dce720d25624a396fe1c47c1b7eed
--- /dev/null
+++ b/drivers/media/platform/mtk-mdp3/mdp_reg_ovl.h
@@ -0,0 +1,531 @@
+#ifndef __MDP_REG_OVL_H__
+#define __MDP_REG_OVL_H__
+
+#include "mmsys_reg_base.h"
+
+#define OVL_STA                         (0x000)
+#define OVL_INTEN                       (0x004)
+#define OVL_INTSTA                      (0x008)
+#define OVL_EN                          (0x00c)
+#define OVL_TRIG                        (0x010)
+#define OVL_RST                         (0x014)
+#define OVL_ROI_SIZE                    (0x020)
+#define OVL_DATAPATH_CON                (0x024)
+#define OVL_ROI_BGCLR                   (0x028)
+#define OVL_SRC_CON                     (0x02c)
+#define OVL_L0_CON                      (0x030)
+#define OVL_L0_CLRKEY                   (0x034)
+#define OVL_L0_SRC_SIZE                 (0x038)
+#define OVL_L0_OFFSET                   (0x03c)
+#define OVL_L0_ADDR                     (0xF40)
+#define OVL_L0_PITCH_MSB                (0x040)
+#define OVL_L0_PITCH                    (0x044)
+#define OVL_L0_TILE                     (0x048)
+#define OVL_L0_CLIP                     (0x04c)
+#define OVL_L1_CON                      (0x050)
+#define OVL_L1_CLRKEY                   (0x054)
+#define OVL_L1_SRC_SIZE                 (0x058)
+#define OVL_L1_OFFSET                   (0x05c)
+#define OVL_L1_ADDR                     (0xF60)
+#define OVL_L1_PITCH_MSB                (0x060)
+#define OVL_L1_PITCH                    (0x064)
+#define OVL_L1_TILE                     (0x068)
+#define OVL_L1_CLIP                     (0x06c)
+#define OVL_L2_CON                      (0x070)
+#define OVL_L2_CLRKEY                   (0x074)
+#define OVL_L2_SRC_SIZE                 (0x078)
+#define OVL_L2_OFFSET                   (0x07c)
+#define OVL_L2_ADDR                     (0xF80)
+#define OVL_L2_PITCH_MSB                (0x080)
+#define OVL_L2_PITCH                    (0x084)
+#define OVL_L2_TILE                     (0x088)
+#define OVL_L2_CLIP                     (0x08c)
+#define OVL_L3_CON                      (0x090)
+#define OVL_L3_CLRKEY                   (0x094)
+#define OVL_L3_SRC_SIZE                 (0x098)
+#define OVL_L3_OFFSET                   (0x09c)
+#define OVL_L3_ADDR                     (0xFa0)
+#define OVL_L3_PITCH_MSB                (0x0a0)
+#define OVL_L3_PITCH                    (0x0a4)
+#define OVL_L3_TILE                     (0x0a8)
+#define OVL_L3_CLIP                     (0x0ac)
+#define OVL_RDMA0_CTRL                  (0x0c0)
+#define OVL_RDMA0_MEM_TRIG              (0x0c4)
+#define OVL_RDMA0_MEM_GMC1              (0x0c8)
+#define OVL_RDMA0_MEM_SLOW              (0x0cc)
+#define OVL_RDMA0_FIFO_CTRL             (0x0d0)
+#define OVL_RDMA1_CTRL                  (0x0e0)
+#define OVL_RDMA1_MEM_TRIG              (0x0e4)
+#define OVL_RDMA1_MEM_GMC1              (0x0e8)
+#define OVL_RDMA1_MEM_SLOW              (0x0ec)
+#define OVL_RDMA1_FIFO_CTRL             (0x0f0)
+#define OVL_RDMA2_CTRL                  (0x100)
+#define OVL_RDMA2_MEM_TRIG              (0x104)
+#define OVL_RDMA2_MEM_GMC1              (0x108)
+#define OVL_RDMA2_MEM_SLOW              (0x10c)
+#define OVL_RDMA2_FIFO_CTRL             (0x110)
+#define OVL_RDMA3_CTRL                  (0x120)
+#define OVL_RDMA3_MEM_TRIG              (0x124)
+#define OVL_RDMA3_MEM_GMC1              (0x128)
+#define OVL_RDMA3_MEM_SLOW              (0x12c)
+#define OVL_RDMA3_FIFO_CTRL             (0x130)
+#define OVL_L0_Y2R_PARA_R0              (0x134)
+#define OVL_L0_Y2R_PARA_R1              (0x138)
+#define OVL_L0_Y2R_PARA_G0              (0x13c)
+#define OVL_L0_Y2R_PARA_G1              (0x140)
+#define OVL_L0_Y2R_PARA_B0              (0x144)
+#define OVL_L0_Y2R_PARA_B1              (0x148)
+#define OVL_L0_Y2R_PARA_YUV_A_0         (0x14c)
+#define OVL_L0_Y2R_PARA_YUV_A_1         (0x150)
+#define OVL_L0_Y2R_PARA_RGB_A_0         (0x154)
+#define OVL_L0_Y2R_PARA_RGB_A_1         (0x158)
+#define OVL_L1_Y2R_PARA_R0              (0x15c)
+#define OVL_L1_Y2R_PARA_R1              (0x160)
+#define OVL_L1_Y2R_PARA_G0              (0x164)
+#define OVL_L1_Y2R_PARA_G1              (0x168)
+#define OVL_L1_Y2R_PARA_B0              (0x16c)
+#define OVL_L1_Y2R_PARA_B1              (0x170)
+#define OVL_L1_Y2R_PARA_YUV_A_0         (0x174)
+#define OVL_L1_Y2R_PARA_YUV_A_1         (0x178)
+#define OVL_L1_Y2R_PARA_RGB_A_0         (0x17c)
+#define OVL_L1_Y2R_PARA_RGB_A_1         (0x180)
+#define OVL_L2_Y2R_PARA_R0              (0x184)
+#define OVL_L2_Y2R_PARA_R1              (0x188)
+#define OVL_L2_Y2R_PARA_G0              (0x18c)
+#define OVL_L2_Y2R_PARA_G1              (0x190)
+#define OVL_L2_Y2R_PARA_B0              (0x194)
+#define OVL_L2_Y2R_PARA_B1              (0x198)
+#define OVL_L2_Y2R_PARA_YUV_A_0         (0x19c)
+#define OVL_L2_Y2R_PARA_YUV_A_1         (0x1a0)
+#define OVL_L2_Y2R_PARA_RGB_A_0         (0x1a4)
+#define OVL_L2_Y2R_PARA_RGB_A_1         (0x1a8)
+#define OVL_L3_Y2R_PARA_R0              (0x1ac)
+#define OVL_L3_Y2R_PARA_R1              (0x1b0)
+#define OVL_L3_Y2R_PARA_G0              (0x1b4)
+#define OVL_L3_Y2R_PARA_G1              (0x1b8)
+#define OVL_L3_Y2R_PARA_B0              (0x1bc)
+#define OVL_L3_Y2R_PARA_B1              (0x1c0)
+#define OVL_L3_Y2R_PARA_YUV_A_0         (0x1c4)
+#define OVL_L3_Y2R_PARA_YUV_A_1         (0x1c8)
+#define OVL_L3_Y2R_PARA_RGB_A_0         (0x1cc)
+#define OVL_L3_Y2R_PARA_RGB_A_1         (0x1d0)
+#define OVL_DEBUG_SEL                   (0x1d4)
+#define OVL_BLD_EXT                     (0x1dc)
+#define OVL_RDMA0_MEM_GMC2              (0x1e0)
+#define OVL_RDMA1_MEM_GMC2              (0x1e4)
+#define OVL_RDMA2_MEM_GMC2              (0x1e8)
+#define OVL_RDMA3_MEM_GMC2              (0x1ec)
+#define OVL_RDMA_BURST_CON0             (0x1f0)
+#define OVL_RDMA_BURST_CON1             (0x1f4)
+#define OVL_RDMA_GREQ_NUM               (0x1f8)
+#define OVL_RDMA_GREQ_URG_NUM           (0x1fc)
+#define OVL_DUMMY_REG                   (0x200)
+#define OVL_GDRDY_PRD                   (0x208)
+#define OVL_RDMA_ULTRA_SRC              (0x20C)
+#define OVL_RDMA0_BUF_LOW_TH            (0x210)
+#define OVL_RDMA1_BUF_LOW_TH            (0x214)
+#define OVL_RDMA2_BUF_LOW_TH            (0x218)
+#define OVL_RDMA3_BUF_LOW_TH            (0x21c)
+#define OVL_RDMA0_BUF_HIGH_TH           (0x220)
+#define OVL_RDMA1_BUF_HIGH_TH           (0x224)
+#define OVL_RDMA2_BUF_HIGH_TH           (0x228)
+#define OVL_RDMA3_BUF_HIGH_TH           (0x22c)
+#define OVL_SMI_DBG                     (0x230)
+#define OVL_GREQ_LAYER_CNT              (0x234)
+#define OVL_GDRDY_PRD_NUM               (0x238)
+#define OVL_DEBUG_FLAG                  (0x23C)
+#define OVL_FLOW_CTRL_DBG               (0x240)
+#define OVL_ADDCON_DBG                  (0x244)
+#define OVL_RDMA_CH0_DBG                (0x24c)
+#define OVL_RDMA_CH1_DBG                (0x250)
+#define OVL_RDMA_CH2_DBG                (0x254)
+#define OVL_RDMA_CH3_DBG                (0x258)
+#define OVL_L0_CLR                      (0x25c)
+#define OVL_L1_CLR                      (0x260)
+#define OVL_L2_CLR                      (0x264)
+#define OVL_L3_CLR                      (0x268)
+#define OVL_LC_CLR                      (0x26C)
+#define OVL_CRC                         (0x270)
+#define OVL_LC_CON                      (0x280)
+#define OVL_LC_CLRKEY                   (0x284)
+#define OVL_LC_SRC_SIZE                 (0x288)
+#define OVL_LC_OFFSET                   (0x28C)
+#define OVL_LC_SRC_SEL                  (0x290)
+#define OVL_BANK_CON                    (0x29C)
+#define OVL_FUNC_DCM0                   (0x2a0)
+#define OVL_FUNC_DCM1                   (0x2a4)
+#define OVL_DVFS_L0_ROI                 (0x2b0)
+#define OVL_DVFS_L1_ROI                 (0x2b4)
+#define OVL_DVFS_L2_ROI                 (0x2b8)
+#define OVL_DVFS_L3_ROI                 (0x2bc)
+#define OVL_DVFS_EL0_ROI                (0x2c0)
+#define OVL_DVFS_EL1_ROI                (0x2c4)
+#define OVL_DVFS_EL2_ROI                (0x2c8)
+#define OVL_CLRFMT_EXT                  (0x2d0)
+#define OVL_WCG_CFG0                    (0x2d4)
+#define OVL_WCG_CFG1                    (0x2d8)
+#define OVL_WCG_CFG2                    (0x2dc)
+#define OVL_DATAPATH_EXT_CON            (0x324)
+#define OVL_EL0_CON                     (0x330)
+#define OVL_EL0_CLRKEY                  (0x334)
+#define OVL_EL0_SRC_SIZE                (0x338)
+#define OVL_EL0_OFFSET                  (0x33c)
+#define OVL_EL0_ADDR                    (0xFB0)
+#define OVL_EL0_PITCH_MSB               (0x340)
+#define OVL_EL0_PITCH                   (0x344)
+#define OVL_EL0_TILE                    (0x348)
+#define OVL_EL0_CLIP                    (0x34c)
+#define OVL_EL1_CON                     (0x350)
+#define OVL_EL1_CLRKEY                  (0x354)
+#define OVL_EL1_SRC_SIZE                (0x358)
+#define OVL_EL1_OFFSET                  (0x35c)
+#define OVL_EL1_ADDR                    (0xFB4)
+#define OVL_EL1_PITCH_MSB               (0x360)
+#define OVL_EL1_PITCH                   (0x364)
+#define OVL_EL1_TILE                    (0x368)
+#define OVL_EL1_CLIP                    (0x36c)
+#define OVL_EL2_CON                     (0x370)
+#define OVL_EL2_CLRKEY                  (0x374)
+#define OVL_EL2_SRC_SIZE                (0x378)
+#define OVL_EL2_OFFSET                  (0x37c)
+#define OVL_EL2_ADDR                    (0xFB8)
+#define OVL_EL2_PITCH_MSB               (0x380)
+#define OVL_EL2_PITCH                   (0x384)
+#define OVL_EL2_TILE                    (0x388)
+#define OVL_EL2_CLIP                    (0x38c)
+#define OVL_EL0_CLR                     (0x390)
+#define OVL_EL1_CLR                     (0x394)
+#define OVL_EL2_CLR                     (0x398)
+#define OVL_SBCH                        (0x3A0)
+#define OVL_SBCH_EXT                    (0x3A4)
+#define OVL_SBCH_STS                    (0x3A8)
+#define OVL_SBCH_L0_STS_LSB             (0x3B0)
+#define OVL_SBCH_L0_STS_MSB             (0x3B4)
+#define OVL_SBCH_L1_STS_LSB             (0x3B8)
+#define OVL_SBCH_L1_STS_MSB             (0x3BC)
+#define OVL_SBCH_L2_STS_LSB             (0x3C0)
+#define OVL_SBCH_L2_STS_MSB             (0x3C4)
+#define OVL_SBCH_L3_STS_LSB             (0x3C8)
+#define OVL_SBCH_L3_STS_MSB             (0x3CC)
+#define OVL_MBIST_BSEL                  (0x3FC)
+#define OVL_L0_Y2R_C00                  (0x400)
+#define OVL_L0_Y2R_C01                  (0x404)
+#define OVL_L0_Y2R_C02                  (0x408)
+#define OVL_L0_Y2R_C10                  (0x40C)
+#define OVL_L0_Y2R_C11                  (0x410)
+#define OVL_L0_Y2R_C12                  (0x414)
+#define OVL_L0_Y2R_C20                  (0x418)
+#define OVL_L0_Y2R_C21                  (0x41C)
+#define OVL_L0_Y2R_C22                  (0x420)
+#define OVL_L0_Y2R_PRE_ADD0             (0x424)
+#define OVL_L0_Y2R_PRE_ADD1             (0x428)
+#define OVL_L0_Y2R_PRE_ADD2             (0x42C)
+#define OVL_L0_Y2R_POST_ADD0            (0x430)
+#define OVL_L0_Y2R_POST_ADD1            (0x434)
+#define OVL_L0_Y2R_POST_ADD2            (0x438)
+#define OVL_L1_Y2R_C00                  (0x440)
+#define OVL_L1_Y2R_C01                  (0x444)
+#define OVL_L1_Y2R_C02                  (0x448)
+#define OVL_L1_Y2R_C10                  (0x44C)
+#define OVL_L1_Y2R_C11                  (0x450)
+#define OVL_L1_Y2R_C12                  (0x454)
+#define OVL_L1_Y2R_C20                  (0x458)
+#define OVL_L1_Y2R_C21                  (0x45C)
+#define OVL_L1_Y2R_C22                  (0x460)
+#define OVL_L1_Y2R_PRE_ADD0             (0x464)
+#define OVL_L1_Y2R_PRE_ADD1             (0x468)
+#define OVL_L1_Y2R_PRE_ADD2             (0x46C)
+#define OVL_L1_Y2R_POST_ADD0            (0x470)
+#define OVL_L1_Y2R_POST_ADD1            (0x474)
+#define OVL_L1_Y2R_POST_ADD2            (0x478)
+#define OVL_L2_Y2R_C00                  (0x480)
+#define OVL_L2_Y2R_C01                  (0x484)
+#define OVL_L2_Y2R_C02                  (0x488)
+#define OVL_L2_Y2R_C10                  (0x48C)
+#define OVL_L2_Y2R_C11                  (0x490)
+#define OVL_L2_Y2R_C12                  (0x494)
+#define OVL_L2_Y2R_C20                  (0x498)
+#define OVL_L2_Y2R_C21                  (0x49C)
+#define OVL_L2_Y2R_C22                  (0x4A0)
+#define OVL_L2_Y2R_PRE_ADD0             (0x4A4)
+#define OVL_L2_Y2R_PRE_ADD1             (0x4A8)
+#define OVL_L2_Y2R_PRE_ADD2             (0x4AC)
+#define OVL_L2_Y2R_POST_ADD0            (0x4B0)
+#define OVL_L2_Y2R_POST_ADD1            (0x4B4)
+#define OVL_L2_Y2R_POST_ADD2            (0x4B8)
+#define OVL_L3_Y2R_C00                  (0x4C0)
+#define OVL_L3_Y2R_C01                  (0x4C4)
+#define OVL_L3_Y2R_C02                  (0x4C8)
+#define OVL_L3_Y2R_C10                  (0x4CC)
+#define OVL_L3_Y2R_C11                  (0x4D0)
+#define OVL_L3_Y2R_C12                  (0x4D4)
+#define OVL_L3_Y2R_C20                  (0x4D8)
+#define OVL_L3_Y2R_C21                  (0x4DC)
+#define OVL_L3_Y2R_C22                  (0x4E0)
+#define OVL_L3_Y2R_PRE_ADD0             (0x4E4)
+#define OVL_L3_Y2R_PRE_ADD1             (0x4E8)
+#define OVL_L3_Y2R_PRE_ADD2             (0x4EC)
+#define OVL_L3_Y2R_POST_ADD0            (0x4F0)
+#define OVL_L3_Y2R_POST_ADD1            (0x4F4)
+#define OVL_L3_Y2R_POST_ADD2            (0x4F8)
+#define OVL_L0_R2R_PARA_R0              (0x500)
+#define OVL_L0_R2R_PARA_R1              (0x504)
+#define OVL_L0_R2R_PARA_R2              (0x508)
+#define OVL_L0_R2R_PARA_G0              (0x50C)
+#define OVL_L0_R2R_PARA_G1              (0x510)
+#define OVL_L0_R2R_PARA_G2              (0x514)
+#define OVL_L0_R2R_PARA_B0              (0x518)
+#define OVL_L0_R2R_PARA_B1              (0x51C)
+#define OVL_L0_R2R_PARA_B2              (0x520)
+#define OVL_L0_R2R_PARA_PRE_RGB_A_0     (0x524)
+#define OVL_L0_R2R_PARA_PRE_RGB_A_1     (0x528)
+#define OVL_L0_R2R_PARA_PRE_RGB_A_2     (0x52c)
+#define OVL_L0_R2R_PARA_POST_RGB_A_0	(0x530)
+#define OVL_L0_R2R_PARA_POST_RGB_A_1	(0x534)
+#define OVL_L0_R2R_PARA_POST_RGB_A_2	(0x538)
+#define OVL_L1_R2R_PARA_R0              (0x540)
+#define OVL_L1_R2R_PARA_R1              (0x544)
+#define OVL_L1_R2R_PARA_R2              (0x548)
+#define OVL_L1_R2R_PARA_G0              (0x54C)
+#define OVL_L1_R2R_PARA_G1              (0x550)
+#define OVL_L1_R2R_PARA_G2              (0x554)
+#define OVL_L1_R2R_PARA_B0              (0x558)
+#define OVL_L1_R2R_PARA_B1              (0x55C)
+#define OVL_L1_R2R_PARA_B2              (0x560)
+#define OVL_L1_R2R_PARA_PRE_RGB_A_0     (0x564)
+#define OVL_L1_R2R_PARA_PRE_RGB_A_1     (0x568)
+#define OVL_L1_R2R_PARA_PRE_RGB_A_2     (0x56c)
+#define OVL_L1_R2R_PARA_POST_RGB_A_0	(0x570)
+#define OVL_L1_R2R_PARA_POST_RGB_A_1	(0x574)
+#define OVL_L1_R2R_PARA_POST_RGB_A_2	(0x578)
+#define OVL_L2_R2R_PARA_R0              (0x580)
+#define OVL_L2_R2R_PARA_R1              (0x584)
+#define OVL_L2_R2R_PARA_R2              (0x588)
+#define OVL_L2_R2R_PARA_G0              (0x58C)
+#define OVL_L2_R2R_PARA_G1              (0x590)
+#define OVL_L2_R2R_PARA_G2              (0x594)
+#define OVL_L2_R2R_PARA_B0              (0x598)
+#define OVL_L2_R2R_PARA_B1              (0x59C)
+#define OVL_L2_R2R_PARA_B2              (0x5A0)
+#define OVL_L2_R2R_PARA_PRE_RGB_A_0     (0x5A4)
+#define OVL_L2_R2R_PARA_PRE_RGB_A_1     (0x5A8)
+#define OVL_L2_R2R_PARA_PRE_RGB_A_2     (0x5Ac)
+#define OVL_L2_R2R_PARA_POST_RGB_A_0	(0x5B0)
+#define OVL_L2_R2R_PARA_POST_RGB_A_1	(0x5B4)
+#define OVL_L2_R2R_PARA_POST_RGB_A_2	(0x5B8)
+#define OVL_L3_R2R_PARA_R0              (0x5C0)
+#define OVL_L3_R2R_PARA_R1              (0x5C4)
+#define OVL_L3_R2R_PARA_R2              (0x5C8)
+#define OVL_L3_R2R_PARA_G0              (0x5CC)
+#define OVL_L3_R2R_PARA_G1              (0x5D0)
+#define OVL_L3_R2R_PARA_G2              (0x5D4)
+#define OVL_L3_R2R_PARA_B0              (0x5D8)
+#define OVL_L3_R2R_PARA_B1              (0x5DC)
+#define OVL_L3_R2R_PARA_B2              (0x5E0)
+#define OVL_L3_R2R_PARA_PRE_RGB_A_0     (0x5E4)
+#define OVL_L3_R2R_PARA_PRE_RGB_A_1     (0x5E8)
+#define OVL_L3_R2R_PARA_PRE_RGB_A_2     (0x5Ec)
+#define OVL_L3_R2R_PARA_POST_RGB_A_0	(0x5F0)
+#define OVL_L3_R2R_PARA_POST_RGB_A_1	(0x5F4)
+#define OVL_L3_R2R_PARA_POST_RGB_A_2	(0x5F8)
+#define OVL_EL0_R2R_PARA_R0             (0x600)
+#define OVL_EL0_R2R_PARA_R1             (0x604)
+#define OVL_EL0_R2R_PARA_R2             (0x608)
+#define OVL_EL0_R2R_PARA_G0             (0x60C)
+#define OVL_EL0_R2R_PARA_G1             (0x610)
+#define OVL_EL0_R2R_PARA_G2             (0x614)
+#define OVL_EL0_R2R_PARA_B0             (0x618)
+#define OVL_EL0_R2R_PARA_B1             (0x61C)
+#define OVL_EL0_R2R_PARA_B2             (0x620)
+#define OVL_EL0_R2R_PARA_PRE_RGB_A_0	(0x624)
+#define OVL_EL0_R2R_PARA_PRE_RGB_A_1	(0x628)
+#define OVL_EL0_R2R_PARA_PRE_RGB_A_2	(0x62c)
+#define OVL_EL0_R2R_PARA_POST_RGB_A_0	(0x630)
+#define OVL_EL0_R2R_PARA_POST_RGB_A_1	(0x634)
+#define OVL_EL0_R2R_PARA_POST_RGB_A_2	(0x638)
+#define OVL_EL1_R2R_PARA_R0             (0x640)
+#define OVL_EL1_R2R_PARA_R1             (0x644)
+#define OVL_EL1_R2R_PARA_R2             (0x648)
+#define OVL_EL1_R2R_PARA_G0             (0x64C)
+#define OVL_EL1_R2R_PARA_G1             (0x650)
+#define OVL_EL1_R2R_PARA_G2             (0x654)
+#define OVL_EL1_R2R_PARA_B0             (0x658)
+#define OVL_EL1_R2R_PARA_B1             (0x65C)
+#define OVL_EL1_R2R_PARA_B2             (0x660)
+#define OVL_EL1_R2R_PARA_PRE_RGB_A_0	(0x664)
+#define OVL_EL1_R2R_PARA_PRE_RGB_A_1	(0x668)
+#define OVL_EL1_R2R_PARA_PRE_RGB_A_2	(0x66c)
+#define OVL_EL1_R2R_PARA_POST_RGB_A_0	(0x670)
+#define OVL_EL1_R2R_PARA_POST_RGB_A_1	(0x674)
+#define OVL_EL1_R2R_PARA_POST_RGB_A_2	(0x678)
+#define OVL_EL2_R2R_PARA_R0             (0x680)
+#define OVL_EL2_R2R_PARA_R1             (0x684)
+#define OVL_EL2_R2R_PARA_R2             (0x688)
+#define OVL_EL2_R2R_PARA_G0             (0x68C)
+#define OVL_EL2_R2R_PARA_G1             (0x690)
+#define OVL_EL2_R2R_PARA_G2             (0x694)
+#define OVL_EL2_R2R_PARA_B0             (0x698)
+#define OVL_EL2_R2R_PARA_B1             (0x69C)
+#define OVL_EL2_R2R_PARA_B2             (0x6A0)
+#define OVL_EL2_R2R_PARA_PRE_RGB_A_0	(0x6A4)
+#define OVL_EL2_R2R_PARA_PRE_RGB_A_1	(0x6A8)
+#define OVL_EL2_R2R_PARA_PRE_RGB_A_2	(0x6AC)
+#define OVL_EL2_R2R_PARA_POST_RGB_A_0	(0x6B0)
+#define OVL_EL2_R2R_PARA_POST_RGB_A_1	(0x6B4)
+#define OVL_EL2_R2R_PARA_POST_RGB_A_2	(0x6B8)
+#define OVL_LC_R2R_PARA_R0              (0x6C0)
+#define OVL_LC_R2R_PARA_R1              (0x6C4)
+#define OVL_LC_R2R_PARA_R2              (0x6C8)
+#define OVL_LC_R2R_PARA_G0              (0x6CC)
+#define OVL_LC_R2R_PARA_G1              (0x6D0)
+#define OVL_LC_R2R_PARA_G2              (0x6D4)
+#define OVL_LC_R2R_PARA_B0              (0x6D8)
+#define OVL_LC_R2R_PARA_B1              (0x6DC)
+#define OVL_LC_R2R_PARA_B2              (0x6E0)
+#define OVL_LC_R2R_PARA_PRE_RGB_A_0     (0x6E4)
+#define OVL_LC_R2R_PARA_PRE_RGB_A_1     (0x6E8)
+#define OVL_LC_R2R_PARA_PRE_RGB_A_2     (0x6EC)
+#define OVL_LC_R2R_PARA_POST_RGB_A_0	(0x6F0)
+#define OVL_LC_R2R_PARA_POST_RGB_A_1	(0x6F4)
+#define OVL_LC_R2R_PARA_POST_RGB_A_2	(0x6F8)
+#define OVL_OUT_R2R_PARA_R0             (0x700)
+#define OVL_OUT_R2R_PARA_R1             (0x704)
+#define OVL_OUT_R2R_PARA_R2             (0x708)
+#define OVL_OUT_R2R_PARA_G0             (0x70C)
+#define OVL_OUT_R2R_PARA_G1             (0x710)
+#define OVL_OUT_R2R_PARA_G2             (0x714)
+#define OVL_OUT_R2R_PARA_B0             (0x718)
+#define OVL_OUT_R2R_PARA_B1             (0x71C)
+#define OVL_OUT_R2R_PARA_B2             (0x720)
+#define OVL_OUT_R2R_PARA_PRE_RGB_A_0	(0x724)
+#define OVL_OUT_R2R_PARA_PRE_RGB_A_1	(0x728)
+#define OVL_OUT_R2R_PARA_PRE_RGB_A_2	(0x72C)
+#define OVL_OUT_R2R_PARA_POST_RGB_A_0	(0x730)
+#define OVL_OUT_R2R_PARA_POST_RGB_A_1	(0x734)
+#define OVL_OUT_R2R_PARA_POST_RGB_A_2	(0x738)
+#define OVL_ROI_TIMING_0                (0x740)
+#define OVL_ROI_TIMING_2                (0x744)
+#define OVL_ROI_TIMING_4                (0x748)
+#define OVL_ROI_TIMING_6                (0x74C)
+#define OVL_INTEN_2ND                   (0x750)
+#define OVL_INTSTA_2ND                  (0x754)
+#define OVL_FBDC_CFG0                   (0x800)
+#define OVL_FBDC_CFG1                   (0x804)
+#define OVL_FBDC_CFG2                   (0x808)
+#define OVL_L0_FBDC_CNST_CLR0           (0x810)
+#define OVL_L0_FBDC_CNST_CLR1           (0x814)
+#define OVL_L1_FBDC_CNST_CLR0           (0x818)
+#define OVL_L1_FBDC_CNST_CLR1           (0x81C)
+#define OVL_L2_FBDC_CNST_CLR0           (0x820)
+#define OVL_L2_FBDC_CNST_CLR1           (0x824)
+#define OVL_L3_FBDC_CNST_CLR0           (0x828)
+#define OVL_L3_FBDC_CNST_CLR1           (0x82C)
+#define OVL_EL0_FBDC_CNST_CLR0          (0x830)
+#define OVL_EL0_FBDC_CNST_CLR1          (0x834)
+#define OVL_EL1_FBDC_CNST_CLR0          (0x838)
+#define OVL_EL1_FBDC_CNST_CLR1          (0x83C)
+#define OVL_EL2_FBDC_CNST_CLR0          (0x840)
+#define OVL_EL2_FBDC_CNST_CLR1          (0x844)
+#define OVL_L0_SYSRAM_CFG               (0x880)
+#define OVL_L0_SYSRAM_BUF0_ADDR         (0x884)
+#define OVL_L0_SYSRAM_BUF1_ADDR         (0x888)
+#define OVL_L1_SYSRAM_CFG               (0x890)
+#define OVL_L1_SYSRAM_BUF0_ADDR         (0x894)
+#define OVL_L1_SYSRAM_BUF1_ADDR         (0x898)
+#define OVL_L2_SYSRAM_CFG               (0x8A0)
+#define OVL_L2_SYSRAM_BUF0_ADDR         (0x8A4)
+#define OVL_L2_SYSRAM_BUF1_ADDR         (0x8A8)
+#define OVL_L3_SYSRAM_CFG               (0x8B0)
+#define OVL_L3_SYSRAM_BUF0_ADDR         (0x8B4)
+#define OVL_L3_SYSRAM_BUF1_ADDR         (0x8B8)
+#define OVL_EL0_SYSRAM_CFG              (0x8C0)
+#define OVL_EL0_SYSRAM_BUF0_ADDR        (0x8C4)
+#define OVL_EL0_SYSRAM_BUF1_ADDR        (0x8C8)
+#define OVL_EL1_SYSRAM_CFG              (0x8D0)
+#define OVL_EL1_SYSRAM_BUF0_ADDR        (0x8D4)
+#define OVL_EL1_SYSRAM_BUF1_ADDR        (0x8D8)
+#define OVL_EL2_SYSRAM_CFG              (0x8E0)
+#define OVL_EL2_SYSRAM_BUF0_ADDR        (0x8E4)
+#define OVL_EL2_SYSRAM_BUF1_ADDR        (0x8E8)
+#define OVL_SMI_2ND_CFG                 (0x8F0)
+#define OVL_L0_SYSRAM_BUF0_CNT          (0x900)
+#define OVL_L0_SYSRAM_BUF1_CNT          (0x904)
+#define OVL_L1_SYSRAM_BUF0_CNT          (0x908)
+#define OVL_L1_SYSRAM_BUF1_CNT          (0x90C)
+#define OVL_L2_SYSRAM_BUF0_CNT          (0x910)
+#define OVL_L2_SYSRAM_BUF1_CNT          (0x914)
+#define OVL_L3_SYSRAM_BUF0_CNT          (0x918)
+#define OVL_L3_SYSRAM_BUF1_CNT          (0x91C)
+#define OVL_EL0_SYSRAM_BUF0_CNT         (0x920)
+#define OVL_EL0_SYSRAM_BUF1_CNT         (0x924)
+#define OVL_EL1_SYSRAM_BUF0_CNT         (0x928)
+#define OVL_EL1_SYSRAM_BUF1_CNT         (0x92C)
+#define OVL_EL2_SYSRAM_BUF0_CNT         (0x930)
+#define OVL_EL2_SYSRAM_BUF1_CNT         (0x934)
+#define OVL_SYSRAM_CNT_TH               (0x938)
+#define OVL_R2Y_CONTROL                 (0x9FC)
+#define OVL_R2Y_C00                     (0xA00)
+#define OVL_R2Y_C01                     (0xA04)
+#define OVL_R2Y_C02                     (0xA08)
+#define OVL_R2Y_C10                     (0xA0C)
+#define OVL_R2Y_C11                     (0xA10)
+#define OVL_R2Y_C12                     (0xA14)
+#define OVL_R2Y_C20                     (0xA18)
+#define OVL_R2Y_C21                     (0xA1C)
+#define OVL_R2Y_C22                     (0xA20)
+#define OVL_R2Y_PRE_ADD0                (0xA24)
+#define OVL_R2Y_PRE_ADD1                (0xA28)
+#define OVL_R2Y_PRE_ADD2                (0xA2C)
+#define OVL_R2Y_POST_ADD0               (0xA30)
+#define OVL_R2Y_POST_ADD1               (0xA34)
+#define OVL_R2Y_POST_ADD2               (0xA38)
+#define OVL_YUV1BIT_BIT_OFFSET          (0xA40)
+#define OVL_L0_PITCH_BIT                (0xA44)
+#define OVL_L1_PITCH_BIT                (0xA48)
+#define OVL_L2_PITCH_BIT                (0xA4C)
+#define OVL_L3_PITCH_BIT                (0xA50)
+#define OVL_EL0_PITCH_BIT               (0xA54)
+#define OVL_EL1_PITCH_BIT               (0xA58)
+#define OVL_EL2_PITCH_BIT               (0xA5C)
+#define OVL_L0_YUV1BIT_COLOR0           (0xA60)
+#define OVL_L0_YUV1BIT_COLOR1           (0xA64)
+#define OVL_L1_YUV1BIT_COLOR0           (0xA68)
+#define OVL_L1_YUV1BIT_COLOR1           (0xA6C)
+#define OVL_L2_YUV1BIT_COLOR0           (0xA70)
+#define OVL_L2_YUV1BIT_COLOR1           (0xA74)
+#define OVL_L3_YUV1BIT_COLOR0           (0xA78)
+#define OVL_L3_YUV1BIT_COLOR1           (0xA7C)
+#define OVL_EL0_YUV1BIT_COLOR0          (0xA80)
+#define OVL_EL0_YUV1BIT_COLOR1          (0xA84)
+#define OVL_EL1_YUV1BIT_COLOR0          (0xA88)
+#define OVL_EL1_YUV1BIT_COLOR1          (0xA8C)
+#define OVL_EL2_YUV1BIT_COLOR0          (0xA90)
+#define OVL_EL2_YUV1BIT_COLOR1          (0xA94)
+#define OVL_EL0_HDR_ADDR                (0xFD0)
+#define OVL_EL0_HDR_PITCH               (0xFD4)
+#define OVL_EL1_HDR_ADDR                (0xFD8)
+#define OVL_EL1_HDR_PITCH               (0xFDC)
+#define OVL_EL2_HDR_ADDR                (0xFE0)
+#define OVL_EL2_HDR_PITCH               (0xFE4)
+#define OVL_L0_HDR_ADDR                 (0xF44)
+#define OVL_L0_HDR_PITCH                (0xF48)
+#define OVL_L1_HDR_ADDR                 (0xF64)
+#define OVL_L1_HDR_PITCH                (0xF68)
+#define OVL_L2_HDR_ADDR                 (0xF84)
+#define OVL_L2_HDR_PITCH                (0xF88)
+#define OVL_L3_HDR_ADDR                 (0xFA4)
+#define OVL_L3_HDR_PITCH                (0xFA8)
+#define OVL_SECURE                      (0xfc0)
+#define OVL_DOMAIN                      (0xfc4)
+#define OVL_DOMAIN_EXT                  (0xfc8)
+
+#define OVL_DATAPATH_CON_MASK           (0x0FFFFFFF)
+#define OVL_EN_MASK                     (0xB07D07B1)
+#define OVL_FLOW_CTRL_DBG_MASK          (0xFFBFBFFF)
+#define OVL_L0_CON_MASK                 (0xFFFFFFFF)
+#define OVL_L0_SRC_SIZE_MASK            (0x1FFF1FFF)
+#define OVL_ROI_SIZE_MASK               (0x1FFF1FFF)
+#define OVL_RST_MASK                    (0xF0000001)
+#define OVL_SRC_CON_MASK                (0x0000031F)
+
+#endif  //__MDP_REG_OVL_H__
diff --git a/drivers/media/platform/mtk-mdp3/mdp_reg_pad.h b/drivers/media/platform/mtk-mdp3/mdp_reg_pad.h
new file mode 100644
index 0000000000000000000000000000000000000000..1c05743108fc7ea3cf83e22bc54818a08d38f982
--- /dev/null
+++ b/drivers/media/platform/mtk-mdp3/mdp_reg_pad.h
@@ -0,0 +1,24 @@
+#ifndef __MDP_REG_PAD_H__
+#define __MDP_REG_PAD_H__
+
+#include "mmsys_reg_base.h"
+
+#define VPP_PADDING0_PADDING_CON        (0x000)
+#define VPP_PADDING0_PADDING_PIC_SIZE   (0x004)
+#define VPP_PADDING0_W_PADDING_SIZE     (0x008)
+#define VPP_PADDING0_H_PADDING_SIZE     (0x00c)
+#define VPP_PADDING0_PADDING_PIXEL      (0x010)
+#define VPP_PADDING0_PADDING_IN_CNT     (0x014)
+#define VPP_PADDING0_PADDING_OUT_CNT    (0x018)
+#define VPP_PADDING0_PADDING_OUT_CNT_2  (0x01c)
+#define VPP_PADDING0_PADDING_INT_CON    (0x020)
+#define VPP_PADDING0_PADDING_STA        (0x024)
+#define VPP_PADDING0_PADDING_SHADOW     (0x028)
+#define VPP_PADDING0_PADDING_ALPHA      (0x02c)
+
+#define VPP_PADDING0_PADDING_CON_MASK      (0x00000007)
+#define VPP_PADDING0_PADDING_PIC_SIZE_MASK (0xFFFFFFFF)
+#define VPP_PADDING0_W_PADDING_SIZE_MASK   (0x1FFF1FFF)
+#define VPP_PADDING0_H_PADDING_SIZE_MASK   (0x1FFF1FFF)
+
+#endif  // __MDP_REG_PAD_H__
diff --git a/drivers/media/platform/mtk-mdp3/mdp_reg_rdma.h b/drivers/media/platform/mtk-mdp3/mdp_reg_rdma.h
index d7f5d9275d6d9c97a2dba4730c2261eb5100510f..d7ffcf77f33a685bea1dc699cc1681d926c6f402 100644
--- a/drivers/media/platform/mtk-mdp3/mdp_reg_rdma.h
+++ b/drivers/media/platform/mtk-mdp3/mdp_reg_rdma.h
@@ -9,198 +9,221 @@
 
 #include "mmsys_reg_base.h"
 
-#define MDP_RDMA_EN                     0x000
-#define MDP_RDMA_RESET                  0x008
-#define MDP_RDMA_INTERRUPT_ENABLE       0x010
-#define MDP_RDMA_INTERRUPT_STATUS       0x018
-#define MDP_RDMA_CON                    0x020
-#define MDP_RDMA_GMCIF_CON              0x028
-#define MDP_RDMA_SRC_CON                0x030
-#define MDP_RDMA_SRC_BASE_0             0xf00
-#define MDP_RDMA_SRC_BASE_1             0xf08
-#define MDP_RDMA_SRC_BASE_2             0xf10
-#define MDP_RDMA_UFO_DEC_LENGTH_BASE_Y  0xf20
-#define MDP_RDMA_UFO_DEC_LENGTH_BASE_C  0xf28
-#define MDP_RDMA_MF_BKGD_SIZE_IN_BYTE   0x060
-#define MDP_RDMA_MF_BKGD_SIZE_IN_PXL    0x068
-#define MDP_RDMA_MF_SRC_SIZE            0x070
-#define MDP_RDMA_MF_CLIP_SIZE           0x078
-#define MDP_RDMA_MF_OFFSET_1            0x080
-#define MDP_RDMA_MF_PAR                 0x088
-#define MDP_RDMA_SF_BKGD_SIZE_IN_BYTE   0x090
-#define MDP_RDMA_SF_PAR                 0x0b8
-#define MDP_RDMA_MB_DEPTH               0x0c0
-#define MDP_RDMA_MB_BASE                0x0c8
-#define MDP_RDMA_MB_CON                 0x0d0
-#define MDP_RDMA_SB_DEPTH               0x0d8
-#define MDP_RDMA_SB_BASE                0x0e0
-#define MDP_RDMA_SB_CON                 0x0e8
-#define MDP_RDMA_VC1_RANGE              0x0f0
-#define MDP_RDMA_SRC_END_0              0x100
-#define MDP_RDMA_SRC_END_1              0x108
-#define MDP_RDMA_SRC_END_2              0x110
-#define MDP_RDMA_SRC_OFFSET_0           0x118
-#define MDP_RDMA_SRC_OFFSET_1           0x120
-#define MDP_RDMA_SRC_OFFSET_2           0x128
-#define MDP_RDMA_SRC_OFFSET_W_0         0x130
-#define MDP_RDMA_SRC_OFFSET_W_1         0x138
-#define MDP_RDMA_SRC_OFFSET_W_2         0x140
-#define MDP_RDMA_SRC_OFFSET_0_P         0x148
-#define MDP_RDMA_TRANSFORM_0            0x200
-#define MDP_RDMA_TRANSFORM_1            0x208
-#define MDP_RDMA_TRANSFORM_2            0x210
-#define MDP_RDMA_TRANSFORM_3            0x218
-#define MDP_RDMA_TRANSFORM_4            0x220
-#define MDP_RDMA_TRANSFORM_5            0x228
-#define MDP_RDMA_TRANSFORM_6            0x230
-#define MDP_RDMA_TRANSFORM_7            0x238
-#define MDP_RDMA_DMABUF_CON_0           0x240
-#define MDP_RDMA_DMAULTRA_CON_0         0x248
-#define MDP_RDMA_DMABUF_CON_1           0x250
-#define MDP_RDMA_DMAULTRA_CON_1         0x258
-#define MDP_RDMA_DMABUF_CON_2           0x260
-#define MDP_RDMA_DMAULTRA_CON_2         0x268
-#define MDP_RDMA_DITHER_CON             0x288
-#define MDP_RDMA_RESV_DUMMY_0           0x2a0
-#define MDP_RDMA_CHKS_EXTR              0x300
-#define MDP_RDMA_CHKS_INTW              0x308
-#define MDP_RDMA_CHKS_INTR              0x310
-#define MDP_RDMA_CHKS_ROTO              0x318
-#define MDP_RDMA_CHKS_SRIY              0x320
-#define MDP_RDMA_CHKS_SRIU              0x328
-#define MDP_RDMA_CHKS_SRIV              0x330
-#define MDP_RDMA_CHKS_SROY              0x338
-#define MDP_RDMA_CHKS_SROU              0x340
-#define MDP_RDMA_CHKS_SROV              0x348
-#define MDP_RDMA_CHKS_VUPI              0x350
-#define MDP_RDMA_CHKS_VUPO              0x358
-#define MDP_RDMA_DEBUG_CON              0x380
-#define MDP_RDMA_MON_STA_0              0x400
-#define MDP_RDMA_MON_STA_1              0x408
-#define MDP_RDMA_MON_STA_2              0x410
-#define MDP_RDMA_MON_STA_3              0x418
-#define MDP_RDMA_MON_STA_4              0x420
-#define MDP_RDMA_MON_STA_5              0x428
-#define MDP_RDMA_MON_STA_6              0x430
-#define MDP_RDMA_MON_STA_7              0x438
-#define MDP_RDMA_MON_STA_8              0x440
-#define MDP_RDMA_MON_STA_9              0x448
-#define MDP_RDMA_MON_STA_10             0x450
-#define MDP_RDMA_MON_STA_11             0x458
-#define MDP_RDMA_MON_STA_12             0x460
-#define MDP_RDMA_MON_STA_13             0x468
-#define MDP_RDMA_MON_STA_14             0x470
-#define MDP_RDMA_MON_STA_15             0x478
-#define MDP_RDMA_MON_STA_16             0x480
-#define MDP_RDMA_MON_STA_17             0x488
-#define MDP_RDMA_MON_STA_18             0x490
-#define MDP_RDMA_MON_STA_19             0x498
-#define MDP_RDMA_MON_STA_20             0x4a0
-#define MDP_RDMA_MON_STA_21             0x4a8
-#define MDP_RDMA_MON_STA_22             0x4b0
-#define MDP_RDMA_MON_STA_23             0x4b8
-#define MDP_RDMA_MON_STA_24             0x4c0
-#define MDP_RDMA_MON_STA_25             0x4c8
-#define MDP_RDMA_MON_STA_26             0x4d0
-#define MDP_RDMA_MON_STA_27             0x4d8
-#define MDP_RDMA_MON_STA_28             0x4e0
+#define MDP_RDMA_EN                         (0x0000)
+#define MDP_RDMA_UFBDC_DCM_EN               (0x0004)
+#define MDP_RDMA_RESET                      (0x0008)
+#define MDP_RDMA_INTERRUPT_ENABLE           (0x0010)
+#define MDP_RDMA_INTERRUPT_STATUS           (0x0018)
+#define MDP_RDMA_CON                        (0x0020)
+#define MDP_RDMA_GMCIF_CON                  (0x0028)
+#define MDP_RDMA_SRC_CON                    (0x0030)
+#define MDP_RDMA_COMP_CON                   (0x0038)
+#define MDP_RDMA_PVRIC_CRYUVAL_0            (0x0040)
+#define MDP_RDMA_PVRIC_CRYUVAL_1            (0x0048)
+#define MDP_RDMA_PVRIC_CRCH0123VAL_0        (0x0050)
+#define MDP_RDMA_PVRIC_CRCH0123VAL_1        (0x0058)
+#define MDP_RDMA_MF_BKGD_SIZE_IN_BYTE       (0x0060)
+#define MDP_RDMA_MF_BKGD_SIZE_IN_PXL        (0x0068)
+#define MDP_RDMA_MF_SRC_SIZE                (0x0070)
+#define MDP_RDMA_MF_CLIP_SIZE               (0x0078)
+#define MDP_RDMA_MF_OFFSET_1                (0x0080)
+#define MDP_RDMA_MF_PAR                     (0x0088)
+#define MDP_RDMA_SF_BKGD_SIZE_IN_BYTE       (0x0090)
+#define MDP_RDMA_MF_BKGD_H_SIZE_IN_PXL      (0x0098)
+#define MDP_RDMA_SF_PAR                     (0x00B8)
+#define MDP_RDMA_MB_DEPTH                   (0x00C0)
+#define MDP_RDMA_MB_BASE                    (0x00C8)
+#define MDP_RDMA_MB_CON                     (0x00D0)
+#define MDP_RDMA_SB_DEPTH                   (0x00D8)
+#define MDP_RDMA_SB_BASE                    (0x00E0)
+#define MDP_RDMA_SB_CON                     (0x00E8)
+#define MDP_RDMA_VC1_RANGE                  (0x00F0)
+#define MDP_RDMA_SRC_END_0                  (0X0100)
+#define MDP_RDMA_SRC_END_1                  (0X0108)
+#define MDP_RDMA_SRC_END_2                  (0X0110)
+#define MDP_RDMA_SRC_OFFSET_0               (0x0118)
+#define MDP_RDMA_SRC_OFFSET_1               (0x0120)
+#define MDP_RDMA_SRC_OFFSET_2               (0x0128)
+#define MDP_RDMA_SRC_OFFSET_W_0             (0x0130)
+#define MDP_RDMA_SRC_OFFSET_W_1             (0x0138)
+#define MDP_RDMA_SRC_OFFSET_W_2             (0x0140)
+#define MDP_RDMA_SRC_OFFSET_WP              (0x0148)
+#define MDP_RDMA_SRC_OFFSET_HP              (0x0150)
+#define MDP_RDMA_TRANSFORM_0                (0x0200)
+#define MDP_RDMA_DMABUF_CON_0               (0x0240)
+#define MDP_RDMA_ULTRA_TH_HIGH_CON_0        (0x0248)
+#define MDP_RDMA_ULTRA_TH_LOW_CON_0         (0x0250)
+#define MDP_RDMA_DMABUF_CON_1               (0x0258)
+#define MDP_RDMA_ULTRA_TH_HIGH_CON_1        (0x0260)
+#define MDP_RDMA_ULTRA_TH_LOW_CON_1         (0x0268)
+#define MDP_RDMA_DMABUF_CON_2               (0x0270)
+#define MDP_RDMA_ULTRA_TH_HIGH_CON_2        (0x0278)
+#define MDP_RDMA_ULTRA_TH_LOW_CON_2         (0x0280)
+#define MDP_RDMA_DMABUF_CON_3               (0x0288)
+#define MDP_RDMA_ULTRA_TH_HIGH_CON_3        (0x0290)
+#define MDP_RDMA_ULTRA_TH_LOW_CON_3         (0x0298)
+#define MDP_RDMA_DITHER_CON                 (0x02a0)
+#define MDP_RDMA_RESV_DUMMY_0               (0x02a8)
+#define MDP_RDMA_UNCOMP_MON                 (0x02c0)
+#define MDP_RDMA_COMP_MON                   (0x02c8)
+#define MDP_RDMA_CHKS_EXTR                  (0x0300)
+#define MDP_RDMA_CHKS_INTW                  (0x0308)
+#define MDP_RDMA_CHKS_INTR                  (0x0310)
+#define MDP_RDMA_CHKS_ROTO                  (0x0318)
+#define MDP_RDMA_CHKS_SRIY                  (0x0320)
+#define MDP_RDMA_CHKS_SRIU                  (0x0328)
+#define MDP_RDMA_CHKS_SRIV                  (0x0330)
+#define MDP_RDMA_CHKS_SROY                  (0x0338)
+#define MDP_RDMA_CHKS_SROU                  (0x0340)
+#define MDP_RDMA_CHKS_SROV                  (0x0348)
+#define MDP_RDMA_CHKS_VUPI                  (0x0350)
+#define MDP_RDMA_CHKS_VUPO                  (0x0358)
+#define MDP_RDMA_DEBUG_CON                  (0x0380)
+#define MDP_RDMA_MON_STA_0                  (0x0400)
+#define MDP_RDMA_MON_STA_1                  (0x0408)
+#define MDP_RDMA_MON_STA_2                  (0x0410)
+#define MDP_RDMA_MON_STA_3                  (0x0418)
+#define MDP_RDMA_MON_STA_4                  (0x0420)
+#define MDP_RDMA_MON_STA_5                  (0x0428)
+#define MDP_RDMA_MON_STA_6                  (0x0430)
+#define MDP_RDMA_MON_STA_7                  (0x0438)
+#define MDP_RDMA_MON_STA_8                  (0x0440)
+#define MDP_RDMA_MON_STA_9                  (0x0448)
+#define MDP_RDMA_MON_STA_10                 (0x0450)
+#define MDP_RDMA_MON_STA_11                 (0x0458)
+#define MDP_RDMA_MON_STA_12                 (0x0460)
+#define MDP_RDMA_MON_STA_13                 (0x0468)
+#define MDP_RDMA_MON_STA_14                 (0x0470)
+#define MDP_RDMA_MON_STA_15                 (0x0478)
+#define MDP_RDMA_MON_STA_16                 (0x0480)
+#define MDP_RDMA_MON_STA_17                 (0x0488)
+#define MDP_RDMA_MON_STA_18                 (0x0490)
+#define MDP_RDMA_MON_STA_19                 (0x0498)
+#define MDP_RDMA_MON_STA_20                 (0x04a0)
+#define MDP_RDMA_MON_STA_21                 (0x04a8)
+#define MDP_RDMA_MON_STA_22                 (0x04b0)
+#define MDP_RDMA_MON_STA_23                 (0x04b8)
+#define MDP_RDMA_MON_STA_24                 (0x04c0)
+#define MDP_RDMA_MON_STA_25                 (0x04c8)
+#define MDP_RDMA_MON_STA_26                 (0x04d0)
+#define MDP_RDMA_MON_STA_27                 (0x04d8)
+#define MDP_RDMA_MON_STA_28                 (0x04e0)
+#define MDP_RDMA_SRC_BASE_0                 (0x0F00)
+#define MDP_RDMA_SRC_BASE_1                 (0x0F08)
+#define MDP_RDMA_SRC_BASE_2                 (0x0F10)
+#define MDP_RDMA_UFO_DEC_LENGTH_BASE_Y      (0x0F20)
+#define MDP_RDMA_UFO_DEC_LENGTH_BASE_C      (0x0F28)
+
+#define MDP_RDMA_SRC_OFFSET_0_P             MDP_RDMA_SRC_OFFSET_WP
+#define MDP_RDMA_SRC_OFFSET_0_P_MASK        MDP_RDMA_SRC_OFFSET_WP_MASK
+
 
 /* MASK */
-#define MDP_RDMA_EN_MASK                    0x00000001
-#define MDP_RDMA_RESET_MASK                 0x00000001
-#define MDP_RDMA_INTERRUPT_ENABLE_MASK      0x00000007
-#define MDP_RDMA_INTERRUPT_STATUS_MASK      0x00000007
-#define MDP_RDMA_CON_MASK                   0x00001110
-#define MDP_RDMA_GMCIF_CON_MASK             0xfffb3771
-#define MDP_RDMA_SRC_CON_MASK               0xf3ffffff
-#define MDP_RDMA_SRC_BASE_0_MASK            0xffffffff
-#define MDP_RDMA_SRC_BASE_1_MASK            0xffffffff
-#define MDP_RDMA_SRC_BASE_2_MASK            0xffffffff
-#define MDP_RDMA_UFO_DEC_LENGTH_BASE_Y_MASK 0xffffffff
-#define MDP_RDMA_UFO_DEC_LENGTH_BASE_C_MASK 0xffffffff
-#define MDP_RDMA_MF_BKGD_SIZE_IN_BYTE_MASK  0x001fffff
-#define MDP_RDMA_MF_BKGD_SIZE_IN_PXL_MASK   0x001fffff
-#define MDP_RDMA_MF_SRC_SIZE_MASK           0x1fff1fff
-#define MDP_RDMA_MF_CLIP_SIZE_MASK          0x1fff1fff
-#define MDP_RDMA_MF_OFFSET_1_MASK           0x003f001f
-#define MDP_RDMA_MF_PAR_MASK                0x1ffff3ff
-#define MDP_RDMA_SF_BKGD_SIZE_IN_BYTE_MASK  0x001fffff
-#define MDP_RDMA_SF_PAR_MASK                0x1ffff3ff
-#define MDP_RDMA_MB_DEPTH_MASK              0x0000007f
-#define MDP_RDMA_MB_BASE_MASK               0x0000ffff
-#define MDP_RDMA_MB_CON_MASK                0x3fff1fff
-#define MDP_RDMA_SB_DEPTH_MASK              0x0000007f
-#define MDP_RDMA_SB_BASE_MASK               0x0000ffff
-#define MDP_RDMA_SB_CON_MASK                0x3fff1fff
-#define MDP_RDMA_VC1_RANGE_MASK             0x001f1f11
-#define MDP_RDMA_SRC_END_0_MASK             0xffffffff
-#define MDP_RDMA_SRC_END_1_MASK             0xffffffff
-#define MDP_RDMA_SRC_END_2_MASK             0xffffffff
-#define MDP_RDMA_SRC_OFFSET_0_MASK          0xffffffff
-#define MDP_RDMA_SRC_OFFSET_1_MASK          0xffffffff
-#define MDP_RDMA_SRC_OFFSET_2_MASK          0xffffffff
-#define MDP_RDMA_SRC_OFFSET_W_0_MASK        0x0000ffff
-#define MDP_RDMA_SRC_OFFSET_W_1_MASK        0x0000ffff
-#define MDP_RDMA_SRC_OFFSET_W_2_MASK        0x0000ffff
-#define MDP_RDMA_SRC_OFFSET_0_P_MASK        0xffffffff
-#define MDP_RDMA_TRANSFORM_0_MASK           0xff110777
-#define MDP_RDMA_TRANSFORM_1_MASK           0x1ff7fdff
-#define MDP_RDMA_TRANSFORM_2_MASK           0x1ff7fdff
-#define MDP_RDMA_TRANSFORM_3_MASK           0x1fff1fff
-#define MDP_RDMA_TRANSFORM_4_MASK           0x1fff1fff
-#define MDP_RDMA_TRANSFORM_5_MASK           0x1fff1fff
-#define MDP_RDMA_TRANSFORM_6_MASK           0x1fff1fff
-#define MDP_RDMA_TRANSFORM_7_MASK           0x00001fff
-#define MDP_RDMA_DMABUF_CON_0_MASK          0x077f007f
-#define MDP_RDMA_DMAULTRA_CON_0_MASK        0x7f7f7f7f
-#define MDP_RDMA_DMABUF_CON_1_MASK          0x073f003f
-#define MDP_RDMA_DMAULTRA_CON_1_MASK        0x3f3f3f3f
-#define MDP_RDMA_DMABUF_CON_2_MASK          0x071f001f
-#define MDP_RDMA_DMAULTRA_CON_2_MASK        0x1f1f1f1f
+#define MDP_RDMA_EN_MASK                    (0x0FFFFF1)
+#define MDP_RDMA_UFBDC_DCM_EN_MASK          (0x0FFFFF0)
+#define MDP_RDMA_RESET_MASK                 (0x01)
+#define MDP_RDMA_INTERRUPT_ENABLE_MASK      (0x07)
+#define MDP_RDMA_INTERRUPT_STATUS_MASK      (0x07)
+#define MDP_RDMA_CON_MASK                   (0x01130)
+#define MDP_RDMA_GMCIF_CON_MASK             (0xFFFBFFF7)
+#define MDP_RDMA_SRC_CON_MASK               (0xFF9FFFFF)
+#define MDP_RDMA_COMP_CON_MASK              (0xFFFFC000)
+#define MDP_RDMA_PVRIC_CRYUVAL_0_MASK       (0x0FFFFF)
+#define MDP_RDMA_PVRIC_CRYUVAL_1_MASK       (0x0FFFFF)
+#define MDP_RDMA_PVRIC_CRCH0123VAL_0_MASK   (0xFFFFFFFF)
+#define MDP_RDMA_PVRIC_CRCH0123VAL_1_MASK   (0xFFFFFFFF)
+#define MDP_RDMA_MF_BKGD_SIZE_IN_BYTE_MASK  (0x07FFFFF)
+#define MDP_RDMA_MF_BKGD_SIZE_IN_PXL_MASK   (0x07FFFFF)
+#define MDP_RDMA_MF_SRC_SIZE_MASK           (0x7FFF7FFF)
+#define MDP_RDMA_MF_CLIP_SIZE_MASK          (0x7FFF7FFF)
+#define MDP_RDMA_MF_OFFSET_1_MASK           (0x03F001F)
+#define MDP_RDMA_MF_PAR_MASK                (0x7FFFF7FF)
+#define MDP_RDMA_SF_BKGD_SIZE_IN_BYTE_MASK  (0x07FFFFF)
+#define MDP_RDMA_MF_BKGD_H_SIZE_IN_PXL_MASK (0x07FFFFF)
+#define MDP_RDMA_SF_PAR_MASK                (0x7FFFF7FF)
+#define MDP_RDMA_MB_DEPTH_MASK              (0x07F)
+#define MDP_RDMA_MB_BASE_MASK               (0x0FFFF)
+#define MDP_RDMA_MB_CON_MASK                (0xFFFF7FFF)
+#define MDP_RDMA_SB_DEPTH_MASK              (0x07F)
+#define MDP_RDMA_SB_BASE_MASK               (0x0FFFF)
+#define MDP_RDMA_SB_CON_MASK                (0xFFFF7FFF)
+#define MDP_RDMA_VC1_RANGE_MASK             (0x01F1F11)
+#define MDP_RDMA_SRC_END_0_MASK             (0xFFFFFFFF)
+#define MDP_RDMA_SRC_END_1_MASK             (0xFFFFFFFF)
+#define MDP_RDMA_SRC_END_2_MASK             (0xFFFFFFFF)
+#define MDP_RDMA_SRC_OFFSET_0_MASK          (0xFFFFFFFF)
+#define MDP_RDMA_SRC_OFFSET_1_MASK          (0xFFFFFFFF)
+#define MDP_RDMA_SRC_OFFSET_2_MASK          (0xFFFFFFFF)
+#define MDP_RDMA_SRC_OFFSET_W_0_MASK        (0x0FFFF)
+#define MDP_RDMA_SRC_OFFSET_W_1_MASK        (0x0FFFF)
+#define MDP_RDMA_SRC_OFFSET_W_2_MASK        (0x0FFFF)
+#define MDP_RDMA_SRC_OFFSET_WP_MASK         (0xFFFFFFFF)
+#define MDP_RDMA_SRC_OFFSET_HP_MASK         (0xFFFFFFFF)
+#define MDP_RDMA_TRANSFORM_0_MASK           (0xFF810000)
+#define MDP_RDMA_DMABUF_CON_0_MASK          (0x0FFF00FF)
+#define MDP_RDMA_ULTRA_TH_HIGH_CON_0_MASK   (0x3FFFFFFF)
+#define MDP_RDMA_ULTRA_TH_LOW_CON_0_MASK    (0x3FFFFFFF)
+#define MDP_RDMA_DMABUF_CON_1_MASK          (0x0F7F007F)
+#define MDP_RDMA_ULTRA_TH_HIGH_CON_1_MASK   (0x3FFFFFFF)
+#define MDP_RDMA_ULTRA_TH_LOW_CON_1_MASK    (0x3FFFFFFF)
+#define MDP_RDMA_DMABUF_CON_2_MASK          (0x0F3F003F)
+#define MDP_RDMA_ULTRA_TH_HIGH_CON_2_MASK   (0x3FFFFFFF)
+#define MDP_RDMA_ULTRA_TH_LOW_CON_2_MASK    (0x3FFFFFFF)
+#define MDP_RDMA_DMABUF_CON_3_MASK          (0x0F3F003F)
+#define MDP_RDMA_ULTRA_TH_HIGH_CON_3_MASK   (0x3FFFFFFF)
+#define MDP_RDMA_ULTRA_TH_LOW_CON_3_MASK    (0x3FFFFFFF)
+
+#define MDP_RDMA_DITHER_CON_MASK            (0x0337)
+#define MDP_RDMA_RESV_DUMMY_0_MASK          (0xFFFFFFFF)
+#define MDP_RDMA_UNCOMP_MON_MASK            (0x03FFFFFF)
+#define MDP_RDMA_COMP_MON_MASK              (0x03FFFFFE)
+#define MDP_RDMA_CHKS_EXTR_MASK             (0xFFFFFF01)
+#define MDP_RDMA_CHKS_INTW_MASK             (0xFFFFFF01)
+#define MDP_RDMA_CHKS_INTR_MASK             (0xFFFFFF01)
+#define MDP_RDMA_CHKS_ROTO_MASK             (0xFFFFFF01)
+#define MDP_RDMA_CHKS_SRIY_MASK             (0xFFFFFF01)
+#define MDP_RDMA_CHKS_SRIU_MASK             (0xFFFFFF01)
+#define MDP_RDMA_CHKS_SRIV_MASK             (0xFFFFFF01)
+#define MDP_RDMA_CHKS_SROY_MASK             (0xFFFFFF01)
+#define MDP_RDMA_CHKS_SROU_MASK             (0xFFFFFF01)
+#define MDP_RDMA_CHKS_SROV_MASK             (0xFFFFFF01)
+#define MDP_RDMA_CHKS_VUPI_MASK             (0xFFFFFF01)
+#define MDP_RDMA_CHKS_VUPO_MASK             (0xFFFFFF01)
+#define MDP_RDMA_DEBUG_CON_MASK             (0x07FF3F)
+#define MDP_RDMA_MON_STA_0_MASK             (0xFFFFFFFF)
+#define MDP_RDMA_MON_STA_1_MASK             (0xFFFFFFFF)
+#define MDP_RDMA_MON_STA_2_MASK             (0xFFFFFFFF)
+#define MDP_RDMA_MON_STA_3_MASK             (0xFFFFFFFF)
+#define MDP_RDMA_MON_STA_4_MASK             (0xFFFFFFFF)
+#define MDP_RDMA_MON_STA_5_MASK             (0xFFFFFFFF)
+#define MDP_RDMA_MON_STA_6_MASK             (0xFFFFFFFF)
+#define MDP_RDMA_MON_STA_7_MASK             (0xFFFFFFFF)
+#define MDP_RDMA_MON_STA_8_MASK             (0xFFFFFFFF)
+#define MDP_RDMA_MON_STA_9_MASK             (0xFFFFFFFF)
+#define MDP_RDMA_MON_STA_10_MASK            (0xFFFFFFFF)
+#define MDP_RDMA_MON_STA_11_MASK            (0xFFFFFFFF)
+#define MDP_RDMA_MON_STA_12_MASK            (0xFFFFFFFF)
+#define MDP_RDMA_MON_STA_13_MASK            (0xFFFFFFFF)
+#define MDP_RDMA_MON_STA_14_MASK            (0xFFFFFFFF)
+#define MDP_RDMA_MON_STA_15_MASK            (0xFFFFFFFF)
+#define MDP_RDMA_MON_STA_16_MASK            (0xFFFFFFFF)
+#define MDP_RDMA_MON_STA_17_MASK            (0xFFFFFFFF)
+#define MDP_RDMA_MON_STA_18_MASK            (0xFFFFFFFF)
+#define MDP_RDMA_MON_STA_19_MASK            (0xFFFFFFFF)
+#define MDP_RDMA_MON_STA_20_MASK            (0xFFFFFFFF)
+#define MDP_RDMA_MON_STA_21_MASK            (0xFFFFFFFF)
+#define MDP_RDMA_MON_STA_22_MASK            (0xFFFFFFFF)
+#define MDP_RDMA_MON_STA_23_MASK            (0xFFFFFFFF)
+#define MDP_RDMA_MON_STA_24_MASK            (0xFFFFFFFF)
+#define MDP_RDMA_MON_STA_25_MASK            (0xFFFFFFFF)
+#define MDP_RDMA_MON_STA_26_MASK            (0xFFFFFFFF)
+#define MDP_RDMA_MON_STA_27_MASK            (0xFFFFFFFF)
+#define MDP_RDMA_MON_STA_28_MASK            (0xFFFFFFFF)
+#define MDP_RDMA_SRC_BASE_0_MASK            (0xFFFFFFFF)
+#define MDP_RDMA_SRC_BASE_1_MASK            (0xFFFFFFFF)
+#define MDP_RDMA_SRC_BASE_2_MASK            (0xFFFFFFFF)
+#define MDP_RDMA_UFO_DEC_LENGTH_BASE_Y_MASK (0xFFFFFFFF)
+#define MDP_RDMA_UFO_DEC_LENGTH_BASE_C_MASK (0xFFFFFFFF)
 
-#define MDP_RDMA_DITHER_CON_MASK            0xffffffff
-#define MDP_RDMA_RESV_DUMMY_0_MASK          0xffffffff
-#define MDP_RDMA_CHKS_EXTR_MASK             0xffffff01
-#define MDP_RDMA_CHKS_INTW_MASK             0xffffff01
-#define MDP_RDMA_CHKS_INTR_MASK             0xffffff01
-#define MDP_RDMA_CHKS_ROTO_MASK             0xffffff01
-#define MDP_RDMA_CHKS_SRIY_MASK             0xffffff01
-#define MDP_RDMA_CHKS_SRIU_MASK             0xffffff01
-#define MDP_RDMA_CHKS_SRIV_MASK             0xffffff01
-#define MDP_RDMA_CHKS_SROY_MASK             0xffffff01
-#define MDP_RDMA_CHKS_SROU_MASK             0xffffff01
-#define MDP_RDMA_CHKS_SROV_MASK             0xffffff01
-#define MDP_RDMA_CHKS_VUPI_MASK             0xffffff01
-#define MDP_RDMA_CHKS_VUPO_MASK             0xffffff01
-#define MDP_RDMA_DEBUG_CON_MASK             0x00001f11
-#define MDP_RDMA_MON_STA_0_MASK             0xffffffff
-#define MDP_RDMA_MON_STA_1_MASK             0xffffffff
-#define MDP_RDMA_MON_STA_2_MASK             0xffffffff
-#define MDP_RDMA_MON_STA_3_MASK             0xffffffff
-#define MDP_RDMA_MON_STA_4_MASK             0xffffffff
-#define MDP_RDMA_MON_STA_5_MASK             0xffffffff
-#define MDP_RDMA_MON_STA_6_MASK             0xffffffff
-#define MDP_RDMA_MON_STA_7_MASK             0xffffffff
-#define MDP_RDMA_MON_STA_8_MASK             0xffffffff
-#define MDP_RDMA_MON_STA_9_MASK             0xffffffff
-#define MDP_RDMA_MON_STA_10_MASK            0xffffffff
-#define MDP_RDMA_MON_STA_11_MASK            0xffffffff
-#define MDP_RDMA_MON_STA_12_MASK            0xffffffff
-#define MDP_RDMA_MON_STA_13_MASK            0xffffffff
-#define MDP_RDMA_MON_STA_14_MASK            0xffffffff
-#define MDP_RDMA_MON_STA_15_MASK            0xffffffff
-#define MDP_RDMA_MON_STA_16_MASK            0xffffffff
-#define MDP_RDMA_MON_STA_17_MASK            0xffffffff
-#define MDP_RDMA_MON_STA_18_MASK            0xffffffff
-#define MDP_RDMA_MON_STA_19_MASK            0xffffffff
-#define MDP_RDMA_MON_STA_20_MASK            0xffffffff
-#define MDP_RDMA_MON_STA_21_MASK            0xffffffff
-#define MDP_RDMA_MON_STA_22_MASK            0xffffffff
-#define MDP_RDMA_MON_STA_23_MASK            0xffffffff
-#define MDP_RDMA_MON_STA_24_MASK            0xffffffff
-#define MDP_RDMA_MON_STA_25_MASK            0xffffffff
-#define MDP_RDMA_MON_STA_26_MASK            0xffffffff
-#define MDP_RDMA_MON_STA_27_MASK            0xffffffff
-#define MDP_RDMA_MON_STA_28_MASK            0xffffffff
 
 #endif  // __MDP_REG_RDMA_H__
diff --git a/drivers/media/platform/mtk-mdp3/mdp_reg_rsz.h b/drivers/media/platform/mtk-mdp3/mdp_reg_rsz.h
index 7f0683f3c60d5226825566dc0ef46e5152146dd3..49d336d2dbb6b23962d9549e9864d5f23ecbf2aa 100644
--- a/drivers/media/platform/mtk-mdp3/mdp_reg_rsz.h
+++ b/drivers/media/platform/mtk-mdp3/mdp_reg_rsz.h
@@ -9,101 +9,123 @@
 
 #include "mmsys_reg_base.h"
 
-#define PRZ_ENABLE                                        0x000
-#define PRZ_CONTROL_1                                     0x004
-#define PRZ_CONTROL_2                                     0x008
-#define PRZ_INT_FLAG                                      0x00c
-#define PRZ_INPUT_IMAGE                                   0x010
-#define PRZ_OUTPUT_IMAGE                                  0x014
-#define PRZ_HORIZONTAL_COEFF_STEP                         0x018
-#define PRZ_VERTICAL_COEFF_STEP                           0x01c
-#define PRZ_LUMA_HORIZONTAL_INTEGER_OFFSET                0x020
-#define PRZ_LUMA_HORIZONTAL_SUBPIXEL_OFFSET               0x024
-#define PRZ_LUMA_VERTICAL_INTEGER_OFFSET                  0x028
-#define PRZ_LUMA_VERTICAL_SUBPIXEL_OFFSET                 0x02c
-#define PRZ_CHROMA_HORIZONTAL_INTEGER_OFFSET              0x030
-#define PRZ_CHROMA_HORIZONTAL_SUBPIXEL_OFFSET             0x034
-#define PRZ_RSV                                           0x040
-#define PRZ_DEBUG_SEL                                     0x044
-#define PRZ_DEBUG                                         0x048
-#define PRZ_TAP_ADAPT                                     0x04c
-#define PRZ_IBSE_SOFTCLIP                                 0x050
-#define PRZ_IBSE_YLEVEL_1                                 0x054
-#define PRZ_IBSE_YLEVEL_2                                 0x058
-#define PRZ_IBSE_YLEVEL_3                                 0x05c
-#define PRZ_IBSE_YLEVEL_4                                 0x060
-#define PRZ_IBSE_YLEVEL_5                                 0x064
-#define PRZ_IBSE_GAINCONTROL_1                            0x068
-#define PRZ_IBSE_GAINCONTROL_2                            0x06c
-#define PRZ_DEMO_IN_HMASK                                 0x070
-#define PRZ_DEMO_IN_VMASK                                 0x074
-#define PRZ_DEMO_OUT_HMASK                                0x078
-#define PRZ_DEMO_OUT_VMASK                                0x07c
-#define PRZ_ATPG                                          0x0fc
-#define PRZ_PAT1_GEN_SET                                  0x100
-#define PRZ_PAT1_GEN_FRM_SIZE                             0x104
-#define PRZ_PAT1_GEN_COLOR0                               0x108
-#define PRZ_PAT1_GEN_COLOR1                               0x10c
-#define PRZ_PAT1_GEN_COLOR2                               0x110
-#define PRZ_PAT1_GEN_POS                                  0x114
-#define PRZ_PAT1_GEN_TILE_POS                             0x124
-#define PRZ_PAT1_GEN_TILE_OV                              0x128
-#define PRZ_PAT2_GEN_SET                                  0x200
-#define PRZ_PAT2_GEN_COLOR0                               0x208
-#define PRZ_PAT2_GEN_COLOR1                               0x20c
-#define PRZ_PAT2_GEN_POS                                  0x214
-#define PRZ_PAT2_GEN_CURSOR_RB0                           0x218
-#define PRZ_PAT2_GEN_CURSOR_RB1                           0x21c
-#define PRZ_PAT2_GEN_TILE_POS                             0x224
-#define PRZ_PAT2_GEN_TILE_OV                              0x228
+#define PRZ_ENABLE                                        (0x00000000)
+#define PRZ_CONTROL_1                                     (0x00000004)
+#define PRZ_CONTROL_2                                     (0x00000008)
+#define PRZ_INT_FLAG                                      (0x0000000C)
+#define PRZ_INPUT_IMAGE                                   (0x00000010)
+#define PRZ_OUTPUT_IMAGE                                  (0x00000014)
+#define PRZ_HORIZONTAL_COEFF_STEP                         (0x00000018)
+#define PRZ_VERTICAL_COEFF_STEP                           (0x0000001C)
+#define PRZ_LUMA_HORIZONTAL_INTEGER_OFFSET                (0x00000020)
+#define PRZ_LUMA_HORIZONTAL_SUBPIXEL_OFFSET               (0x00000024)
+#define PRZ_LUMA_VERTICAL_INTEGER_OFFSET                  (0x00000028)
+#define PRZ_LUMA_VERTICAL_SUBPIXEL_OFFSET                 (0x0000002C)
+#define PRZ_CHROMA_HORIZONTAL_INTEGER_OFFSET              (0x00000030)
+#define PRZ_CHROMA_HORIZONTAL_SUBPIXEL_OFFSET             (0x00000034)
+#define PRZ_RSV                                           (0x00000040)
+#define PRZ_DEBUG_SEL                                     (0x00000044)
+#define PRZ_DEBUG                                         (0x00000048)
+#define PRZ_TAP_ADAPT                                     (0x0000004C)
+#define PRZ_IBSE_SOFTCLIP                                 (0x00000050)
+#define PRZ_IBSE_YLEVEL_1                                 (0x00000054)
+#define PRZ_IBSE_YLEVEL_2                                 (0x00000058)
+#define PRZ_IBSE_YLEVEL_3                                 (0x0000005C)
+#define PRZ_IBSE_YLEVEL_4                                 (0x00000060)
+#define PRZ_IBSE_YLEVEL_5                                 (0x00000064)
+#define PRZ_IBSE_GAINCONTROL_1                            (0x00000068)
+#define PRZ_IBSE_GAINCONTROL_2                            (0x0000006C)
+#define PRZ_DEMO_IN_HMASK                                 (0x00000070)
+#define PRZ_DEMO_IN_VMASK                                 (0x00000074)
+#define PRZ_DEMO_OUT_HMASK                                (0x00000078)
+#define PRZ_DEMO_OUT_VMASK                                (0x0000007C)
+#define PRZ_ATPG                                          (0x000000FC)
+#define PRZ_PAT1_GEN_SET                                  (0x00000100)
+#define PRZ_PAT1_GEN_FRM_SIZE                             (0x00000104)
+#define PRZ_PAT1_GEN_COLOR0                               (0x00000108)
+#define PRZ_PAT1_GEN_COLOR1                               (0x0000010C)
+#define PRZ_PAT1_GEN_COLOR2                               (0x00000110)
+#define PRZ_PAT1_GEN_POS                                  (0x00000114)
+#define PRZ_PAT1_GEN_TILE_POS                             (0x00000124)
+#define PRZ_PAT1_GEN_TILE_OV                              (0x00000128)
+#define PRZ_PAT2_GEN_SET                                  (0x00000200)
+#define PRZ_PAT2_GEN_COLOR0                               (0x00000208)
+#define PRZ_PAT2_GEN_COLOR1                               (0x0000020C)
+#define PRZ_PAT2_GEN_POS                                  (0x00000214)
+#define PRZ_PAT2_GEN_CURSOR_RB0                           (0x00000218)
+#define PRZ_PAT2_GEN_CURSOR_RB1                           (0x0000021C)
+#define PRZ_PAT2_GEN_TILE_POS                             (0x00000224)
+#define PRZ_PAT2_GEN_TILE_OV                              (0x00000228)
+#define RSZ_ETC_CONTROL                                   (0x0000022C)
+#define RSZ_ETC_SWITCH_MAX_MIN_1                          (0x00000230)
+#define RSZ_ETC_SWITCH_MAX_MIN_2                          (0x00000234)
+#define RSZ_ETC_RING_CONTROL                              (0x00000238)
+#define RSZ_ETC_RING_CONTROL_GAINCONTROL_1                (0x0000023C)
+#define RSZ_ETC_RING_CONTROL_GAINCONTROL_2                (0x00000240)
+#define RSZ_ETC_RING_CONTROL_GAINCONTROL_3                (0x00000244)
+#define RSZ_ETC_SIMILARITY_PROTECTION_GAINCONTROL_1       (0x00000248)
+#define RSZ_ETC_SIMILARITY_PROTECTION_GAINCONTROL_2       (0x0000024C)
+#define RSZ_ETC_SIMILARITY_PROTECTION_GAINCONTROL_3       (0x00000250)
+#define RSZ_ETC_BLEND                                     (0x00000254)
 
 /* MASK */
-#define PRZ_ENABLE_MASK                                   0x00010001
-#define PRZ_CONTROL_1_MASK                                0xfffffff3
-#define PRZ_CONTROL_2_MASK                                0x0ffffaff
-#define PRZ_INT_FLAG_MASK                                 0x00000033
-#define PRZ_INPUT_IMAGE_MASK                              0xffffffff
-#define PRZ_OUTPUT_IMAGE_MASK                             0xffffffff
-#define PRZ_HORIZONTAL_COEFF_STEP_MASK                    0x007fffff
-#define PRZ_VERTICAL_COEFF_STEP_MASK                      0x007fffff
-#define PRZ_LUMA_HORIZONTAL_INTEGER_OFFSET_MASK           0x0000ffff
-#define PRZ_LUMA_HORIZONTAL_SUBPIXEL_OFFSET_MASK          0x001fffff
-#define PRZ_LUMA_VERTICAL_INTEGER_OFFSET_MASK             0x0000ffff
-#define PRZ_LUMA_VERTICAL_SUBPIXEL_OFFSET_MASK            0x001fffff
-#define PRZ_CHROMA_HORIZONTAL_INTEGER_OFFSET_MASK         0x0000ffff
-#define PRZ_CHROMA_HORIZONTAL_SUBPIXEL_OFFSET_MASK        0x001fffff
-#define PRZ_RSV_MASK                                      0xffffffff
-#define PRZ_DEBUG_SEL_MASK                                0x0000000f
-#define PRZ_DEBUG_MASK                                    0xffffffff
-#define PRZ_TAP_ADAPT_MASK                                0x03ffffff
-#define PRZ_IBSE_SOFTCLIP_MASK                            0x000fffff
-#define PRZ_IBSE_YLEVEL_1_MASK                            0xffffffff
-#define PRZ_IBSE_YLEVEL_2_MASK                            0xffffffff
-#define PRZ_IBSE_YLEVEL_3_MASK                            0xffffffff
-#define PRZ_IBSE_YLEVEL_4_MASK                            0xffffffff
-#define PRZ_IBSE_YLEVEL_5_MASK                            0x0000ff3f
-#define PRZ_IBSE_GAINCONTROL_1_MASK                       0xffffffff
-#define PRZ_IBSE_GAINCONTROL_2_MASK                       0x0fffff0f
-#define PRZ_DEMO_IN_HMASK_MASK                            0xffffffff
-#define PRZ_DEMO_IN_VMASK_MASK                            0xffffffff
-#define PRZ_DEMO_OUT_HMASK_MASK                           0xffffffff
-#define PRZ_DEMO_OUT_VMASK_MASK                           0xffffffff
-#define PRZ_ATPG_MASK                                     0x00000003
-#define PRZ_PAT1_GEN_SET_MASK                             0x00ff00fd
-#define PRZ_PAT1_GEN_FRM_SIZE_MASK                        0x1fff1fff
-#define PRZ_PAT1_GEN_COLOR0_MASK                          0x00ff00ff
-#define PRZ_PAT1_GEN_COLOR1_MASK                          0x00ff00ff
-#define PRZ_PAT1_GEN_COLOR2_MASK                          0x00ff00ff
-#define PRZ_PAT1_GEN_POS_MASK                             0x1fff1fff
-#define PRZ_PAT1_GEN_TILE_POS_MASK                        0x1fff1fff
-#define PRZ_PAT1_GEN_TILE_OV_MASK                         0x0000ffff
-#define PRZ_PAT2_GEN_SET_MASK                             0x00ff0003
-#define PRZ_PAT2_GEN_COLOR0_MASK                          0x00ff00ff
-#define PRZ_PAT2_GEN_COLOR1_MASK                          0x000000ff
-#define PRZ_PAT2_GEN_POS_MASK                             0x1fff1fff
-#define PRZ_PAT2_GEN_CURSOR_RB0_MASK                      0x00ff00ff
-#define PRZ_PAT2_GEN_CURSOR_RB1_MASK                      0x000000ff
-#define PRZ_PAT2_GEN_TILE_POS_MASK                        0x1fff1fff
-#define PRZ_PAT2_GEN_TILE_OV_MASK                         0x0000ffff
+#define PRZ_ENABLE_MASK                                   (0x010001)
+#define PRZ_CONTROL_1_MASK                                (0xFFFFFFF3)
+#define PRZ_CONTROL_2_MASK                                (0x0FFFFAFF)
+#define PRZ_INT_FLAG_MASK                                 (0x033)
+#define PRZ_INPUT_IMAGE_MASK                              (0xFFFFFFFF)
+#define PRZ_OUTPUT_IMAGE_MASK                             (0xFFFFFFFF)
+#define PRZ_HORIZONTAL_COEFF_STEP_MASK                    (0x07FFFFF)
+#define PRZ_VERTICAL_COEFF_STEP_MASK                      (0x07FFFFF)
+#define PRZ_LUMA_HORIZONTAL_INTEGER_OFFSET_MASK           (0x0FFFF)
+#define PRZ_LUMA_HORIZONTAL_SUBPIXEL_OFFSET_MASK          (0x01FFFFF)
+#define PRZ_LUMA_VERTICAL_INTEGER_OFFSET_MASK             (0x0FFFF)
+#define PRZ_LUMA_VERTICAL_SUBPIXEL_OFFSET_MASK            (0x01FFFFF)
+#define PRZ_CHROMA_HORIZONTAL_INTEGER_OFFSET_MASK         (0x0FFFF)
+#define PRZ_CHROMA_HORIZONTAL_SUBPIXEL_OFFSET_MASK        (0x01FFFFF)
+#define PRZ_RSV_MASK                                      (0xFFFFFFFF)
+#define PRZ_DEBUG_SEL_MASK                                (0x0F)
+#define PRZ_DEBUG_MASK                                    (0xFFFFFFFF)
+#define PRZ_TAP_ADAPT_MASK                                (0x03FFFFFF)
+#define PRZ_IBSE_SOFTCLIP_MASK                            (0x0FFFFF)
+#define PRZ_IBSE_YLEVEL_1_MASK                            (0xFFFFFFFF)
+#define PRZ_IBSE_YLEVEL_2_MASK                            (0xFFFFFFFF)
+#define PRZ_IBSE_YLEVEL_3_MASK                            (0xFFFFFFFF)
+#define PRZ_IBSE_YLEVEL_4_MASK                            (0xFFFFFFFF)
+#define PRZ_IBSE_YLEVEL_5_MASK                            (0x0FF3F)
+#define PRZ_IBSE_GAINCONTROL_1_MASK                       (0xFFFFFFFF)
+#define PRZ_IBSE_GAINCONTROL_2_MASK                       (0x0FFFFF0F)
+#define PRZ_DEMO_IN_HMASK_MASK                            (0xFFFFFFFF)
+#define PRZ_DEMO_IN_VMASK_MASK                            (0xFFFFFFFF)
+#define PRZ_DEMO_OUT_HMASK_MASK                           (0xFFFFFFFF)
+#define PRZ_DEMO_OUT_VMASK_MASK                           (0xFFFFFFFF)
+#define PRZ_ATPG_MASK                                     (0x03)
+#define PRZ_PAT1_GEN_SET_MASK                             (0x0FF00FD)
+#define PRZ_PAT1_GEN_FRM_SIZE_MASK                        (0x1FFF1FFF)
+#define PRZ_PAT1_GEN_COLOR0_MASK                          (0x3FF03FF)
+#define PRZ_PAT1_GEN_COLOR1_MASK                          (0x3FF03FF)
+#define PRZ_PAT1_GEN_COLOR2_MASK                          (0x3FF03FF)
+#define PRZ_PAT1_GEN_POS_MASK                             (0x1FFF1FFF)
+#define PRZ_PAT1_GEN_TILE_POS_MASK                        (0x1FFF1FFF)
+#define PRZ_PAT1_GEN_TILE_OV_MASK                         (0x0FFFF)
+#define PRZ_PAT2_GEN_SET_MASK                             (0x0FF0003)
+#define PRZ_PAT2_GEN_COLOR0_MASK                          (0x3FF03FF)
+#define PRZ_PAT2_GEN_COLOR1_MASK                          (0x3FF)
+#define PRZ_PAT2_GEN_POS_MASK                             (0x1FFF1FFF)
+#define PRZ_PAT2_GEN_CURSOR_RB0_MASK                      (0x3FF03FF)
+#define PRZ_PAT2_GEN_CURSOR_RB1_MASK                      (0x3FF)
+#define PRZ_PAT2_GEN_TILE_POS_MASK                        (0x1FFF1FFF)
+#define PRZ_PAT2_GEN_TILE_OV_MASK                         (0x0FFFF)
+#define RSZ_ETC_CONTROL_MASK                              (0xFF770000)
+#define RSZ_ETC_SWITCH_MAX_MIN_1_MASK                     (0xFFFFFFC0)
+#define RSZ_ETC_SWITCH_MAX_MIN_2_MASK                     (0xFFFFFF00)
+#define RSZ_ETC_RING_CONTROL_MASK                         (0xFFFFFFFF)
+#define RSZ_ETC_RING_CONTROL_GAINCONTROL_1_MASK           (0xFFFFFF1F)
+#define RSZ_ETC_RING_CONTROL_GAINCONTROL_2_MASK           (0xFF1FFF00)
+#define RSZ_ETC_RING_CONTROL_GAINCONTROL_3_MASK           (0x1FF1FF0F)
+#define RSZ_ETC_SIMILARITY_PROTECTION_GAINCONTROL_1_MASK  (0xFFFFFF3F)
+#define RSZ_ETC_SIMILARITY_PROTECTION_GAINCONTROL_2_MASK  (0xFF3FFF00)
+#define RSZ_ETC_SIMILARITY_PROTECTION_GAINCONTROL_3_MASK  (0x7F0FF0F)
+#define RSZ_ETC_BLEND_MASK                                (0xFC000000)
 
 #endif // __MDP_REG_RSZ_H__
diff --git a/drivers/media/platform/mtk-mdp3/mdp_reg_split.h b/drivers/media/platform/mtk-mdp3/mdp_reg_split.h
new file mode 100644
index 0000000000000000000000000000000000000000..6151e2cf07a3c694b9a0ae4f0c4dcdc64b4b586c
--- /dev/null
+++ b/drivers/media/platform/mtk-mdp3/mdp_reg_split.h
@@ -0,0 +1,272 @@
+#ifndef __MDP_REG_SPLIT_H__
+#define __MDP_REG_SPLIT_H__
+
+#include "mmsys_reg_base.h"
+#define VPP_SPLIT_ENABLE	(0x000)
+#define VPP_SPLIT_RESET     (0x004)
+#define VPP_SPLIT_CFG_0     (0x010)
+#define VPP_SPLIT_CFG_1     (0x014)
+#define VPP_SPLIT_CFG_2     (0x018)
+#define VPP_SPLIT_CFG_3     (0x01c)
+#define VPP_SPLIT_CFG_4     (0x020)
+#define VPP_SPLIT_CFG_5     (0x024)
+#define VPP_SPLIT_CFG_6     (0x028)
+#define VPP_SPLIT_CFG_7     (0x02c)
+#define VPP_SPLIT_CFG_8     (0x030)
+#define VPP_SPLIT_CFG_9     (0x034)
+#define VPP_SPLIT_CFG_12	(0x040)
+#define VPP_SPLIT_CFG_13	(0x044)
+#define VPP_SPLIT_CFG_14	(0x048)
+#define VPP_SPLIT_CFG_15	(0x04c)
+#define VPP_SPLIT_CFG_16	(0x050)
+#define VPP_SPLIT_CFG_17	(0x054)
+#define VPP_SPLIT_CFG_20	(0x060)
+#define VPP_SPLIT_CFG_21	(0x064)
+#define VPP_SPLIT_CFG_22	(0x068)
+#define VPP_SPLIT_CFG_23	(0x06c)
+#define VPP_SPLIT_CFG_24	(0x070)
+#define VPP_SPLIT_CFG_25	(0x074)
+#define VPP_SPLIT_CFG_28	(0x080)
+#define VPP_SPLIT_CFG_29	(0x084)
+#define VPP_SPLIT_CFG_30	(0x088)
+#define VPP_SPLIT_CFG_31	(0x08c)
+#define VPP_SPLIT_CFG_32	(0x090)
+#define VPP_SPLIT_CFG_33	(0x094)
+#define VPP_SPLIT_CFG_36	(0x0a0)
+#define VPP_SPLIT_CFG_37	(0x0a4)
+#define VPP_SPLIT_CFG_38	(0x0a8)
+#define VPP_SPLIT_CFG_40	(0x0b0)
+#define VPP_SPLIT_CFG_41	(0x0b4)
+#define VPP_SPLIT_CFG_42	(0x0b8)
+#define VPP_SPLIT_CFG_43	(0x0bc)
+#define VPP_SPLIT_CFG_48	(0x0d0)
+#define VPP_SPLIT_CFG_49	(0x0d4)
+#define VPP_SPLIT_CFG_50	(0x0d8)
+#define VPP_SPLIT_CFG_51	(0x0dc)
+#define VPP_SPLIT_CFG_52	(0x0e0)
+#define VPP_SPLIT_CFG_53	(0x0e4)
+#define VPP_SPLIT_CFG_54	(0x0e8)
+#define VPP_SPLIT_CFG_55	(0x0ec)
+#define VPP_SPLIT_MON_0     (0x100)
+#define VPP_SPLIT_MON_1     (0x104)
+#define VPP_SPLIT_MON_2     (0x108)
+#define VPP_SPLIT_MON_4     (0x110)
+#define VPP_SPLIT_MON_5     (0x114)
+#define VPP_SPLIT_MON_6     (0x118)
+#define VPP_SPLIT_MON_8     (0x120)
+#define VPP_SPLIT_MON_9     (0x124)
+#define VPP_SPLIT_MON_10	(0x128)
+#define VPP_SPLIT_MON_12	(0x130)
+#define VPP_SPLIT_MON_13	(0x134)
+#define VPP_SPLIT_MON_14	(0x138)
+#define VPP_SPLIT_MON_16	(0x140)
+#define VPP_SPLIT_MON_17	(0x144)
+#define VPP_SPLIT_MON_18	(0x148)
+#define VPP_SPLIT_MON_19	(0x14c)
+#define VPP_SPLIT_CFG2_0	(0x180)
+#define VPP_SPLIT_CFG2_1	(0x184)
+#define VPP_SPLIT_CFG2_2	(0x188)
+#define VPP_SPLIT_CFG2_4	(0x190)
+#define VPP_SPLIT_CFG2_5	(0x194)
+#define VPP_SPLIT_CFG2_6	(0x198)
+#define VPP_SPLIT_CFG2_7	(0x19c)
+#define VPP_SPLIT_CFG2_8	(0x1A0)
+#define VPP_SPLIT_CFG2_9	(0x1A4)
+#define VPP_SPLIT_CFG2_10	(0x1A8)
+#define VPP_SPLIT_CFG2_11	(0x1Ac)
+#define VPP_SPLIT_CFG2_12	(0x1B0)
+#define VPP_SPLIT_CFG2_13	(0x1B4)
+#define VPP_SPLIT_CFG2_16	(0x1C0)
+#define VPP_SPLIT_CFG2_17	(0x1C4)
+#define VPP_SPLIT_CFG2_18	(0x1C8)
+#define VPP_SPLIT_CFG2_20	(0x1D0)
+#define VPP_SPLIT_CFG2_21	(0x1D4)
+#define VPP_SPLIT_CFG2_22	(0x1D8)
+#define VPP_SPLIT_CFG2_23	(0x1Dc)
+#define VPP_SPLIT_CFG2_24	(0x1E0)
+#define VPP_SPLIT_CFG2_25	(0x1E4)
+#define VPP_SPLIT_CFG2_26	(0x1E8)
+#define VPP_SPLIT_CFG2_27	(0x1Ec)
+#define VPP_SPLIT_CFG2_28	(0x1F0)
+#define VPP_SPLIT_CFG2_29	(0x1F4)
+#define VPP_SPLIT_PATG_0	(0x200)
+#define VPP_SPLIT_PATG_1	(0x204)
+#define VPP_SPLIT_PATG_2	(0x208)
+#define VPP_SPLIT_PATG_4	(0x210)
+#define VPP_SPLIT_PATG_5	(0x214)
+#define VPP_SPLIT_PATG_6	(0x218)
+#define VPP_SPLIT_PATG_7	(0x21c)
+#define VPP_SPLIT_PATG_8	(0x220)
+#define VPP_SPLIT_PATG_9	(0x224)
+#define VPP_SPLIT_PATG_10	(0x228)
+#define VPP_SPLIT_PATG_11	(0x22c)
+#define VPP_SPLIT_PATG_12	(0x230)
+#define VPP_SPLIT_PATG_13	(0x234)
+#define VPP_SPLIT_PATG_14	(0x238)
+#define VPP_SPLIT_PATG_16	(0x240)
+#define VPP_SPLIT_PATG_17	(0x244)
+#define VPP_SPLIT_PATG_18	(0x248)
+#define VPP_SPLIT_PATG_20	(0x250)
+#define VPP_SPLIT_PATG_21	(0x254)
+#define VPP_SPLIT_PATG_22	(0x258)
+#define VPP_SPLIT_PATG_24	(0x260)
+#define VPP_SPLIT_PATG_25	(0x264)
+#define VPP_SPLIT_PATG_26	(0x268)
+#define VPP_SPLIT_PATG_27	(0x26c)
+#define VPP_SPLIT_PATG_32	(0x280)
+#define VPP_SPLIT_PATG_33	(0x284)
+#define VPP_SPLIT_PATG_34	(0x288)
+#define VPP_SPLIT_PATG_35	(0x28c)
+#define VPP_SPLIT_PATG_36	(0x290)
+#define VPP_SPLIT_PATG_37	(0x294)
+#define VPP_SPLIT_PATG_38	(0x298)
+#define VPP_SPLIT_PATG_39	(0x29c)
+#define VPP_SPLIT_PATG_40	(0x2a0)
+#define VPP_SPLIT_PATG_41	(0x2a4)
+#define VPP_SPLIT_PATG_42	(0x2a8)
+#define VPP_SPLIT_PATG_44	(0x2b0)
+#define VPP_SPLIT_PATG_45	(0x2b4)
+#define VPP_SPLIT_PATG_46	(0x2b8)
+#define VPP_SPLIT_PATG_48	(0x2c0)
+#define VPP_SPLIT_PATG_49	(0x2c4)
+#define VPP_SPLIT_PATG_50	(0x2c8)
+#define VPP_SPLIT_PATG_52	(0x2d0)
+#define VPP_SPLIT_PATG_53	(0x2d4)
+#define VPP_SPLIT_PATG_54	(0x2d8)
+#define VPP_SPLIT_PATG_55	(0x2dc)
+
+// MASK
+#define VPP_SPLIT_ENABLE_MASK	(0x00000001)
+#define VPP_SPLIT_RESET_MASK	(0x00000001)
+#define VPP_SPLIT_CFG_0_MASK	(0xffffffff)
+#define VPP_SPLIT_CFG_1_MASK	(0xffffffff)
+#define VPP_SPLIT_CFG_2_MASK	(0xffffffff)
+#define VPP_SPLIT_CFG_3_MASK	(0xffffffff)
+#define VPP_SPLIT_CFG_4_MASK	(0x00010111)
+#define VPP_SPLIT_CFG_5_MASK	(0x00000111)
+#define VPP_SPLIT_CFG_6_MASK	(0x00000001)
+#define VPP_SPLIT_CFG_7_MASK	(0x00000001)
+#define VPP_SPLIT_CFG_8_MASK	(0xffffffff)
+#define VPP_SPLIT_CFG_9_MASK	(0xffffffff)
+#define VPP_SPLIT_CFG_12_MASK	(0x0000001f)
+#define VPP_SPLIT_CFG_13_MASK	(0x0000001f)
+#define VPP_SPLIT_CFG_14_MASK	(0x0000001f)
+#define VPP_SPLIT_CFG_15_MASK	(0x0000001f)
+#define VPP_SPLIT_CFG_16_MASK	(0x33333333)
+#define VPP_SPLIT_CFG_17_MASK	(0x00011111)
+#define VPP_SPLIT_CFG_20_MASK	(0x0000000f)
+#define VPP_SPLIT_CFG_21_MASK	(0x33310011)
+#define VPP_SPLIT_CFG_22_MASK	(0x0fff1333)
+#define VPP_SPLIT_CFG_23_MASK	(0x0fff0fff)
+#define VPP_SPLIT_CFG_24_MASK	(0x733313f1)
+#define VPP_SPLIT_CFG_25_MASK	(0x10ffffff)
+#define VPP_SPLIT_CFG_28_MASK	(0x0000000f)
+#define VPP_SPLIT_CFG_29_MASK	(0x33310011)
+#define VPP_SPLIT_CFG_30_MASK	(0x0fff1333)
+#define VPP_SPLIT_CFG_31_MASK	(0x0fff0fff)
+#define VPP_SPLIT_CFG_32_MASK	(0x733313f1)
+#define VPP_SPLIT_CFG_33_MASK	(0x10ffffff)
+#define VPP_SPLIT_CFG_36_MASK	(0xffffffff)
+#define VPP_SPLIT_CFG_37_MASK	(0xffffffff)
+#define VPP_SPLIT_CFG_38_MASK	(0xffffffff)
+#define VPP_SPLIT_CFG_40_MASK	(0x00000011)
+#define VPP_SPLIT_CFG_41_MASK	(0xffffffff)
+#define VPP_SPLIT_CFG_42_MASK	(0x00000011)
+#define VPP_SPLIT_CFG_43_MASK	(0xffffffff)
+#define VPP_SPLIT_CFG_48_MASK	(0xffffffff)
+#define VPP_SPLIT_CFG_49_MASK	(0xffffffff)
+#define VPP_SPLIT_CFG_50_MASK	(0xffffffff)
+#define VPP_SPLIT_CFG_51_MASK	(0xffffffff)
+#define VPP_SPLIT_CFG_52_MASK	(0xffffffff)
+#define VPP_SPLIT_CFG_53_MASK	(0xffffffff)
+#define VPP_SPLIT_CFG_54_MASK	(0xffffffff)
+#define VPP_SPLIT_CFG_55_MASK	(0xffffffff)
+#define VPP_SPLIT_MON_0_MASK	(0x00011111)
+#define VPP_SPLIT_MON_1_MASK	(0xffffffff)
+#define VPP_SPLIT_MON_2_MASK	(0xffffffff)
+#define VPP_SPLIT_MON_4_MASK	(0x00011111)
+#define VPP_SPLIT_MON_5_MASK	(0xffffffff)
+#define VPP_SPLIT_MON_6_MASK	(0xffffffff)
+#define VPP_SPLIT_MON_8_MASK	(0x00110111)
+#define VPP_SPLIT_MON_9_MASK	(0xffffffff)
+#define VPP_SPLIT_MON_10_MASK	(0xffffffff)
+#define VPP_SPLIT_MON_12_MASK	(0x00110111)
+#define VPP_SPLIT_MON_13_MASK	(0xffffffff)
+#define VPP_SPLIT_MON_14_MASK	(0xffffffff)
+#define VPP_SPLIT_MON_16_MASK	(0x0000ffff)
+#define VPP_SPLIT_MON_17_MASK	(0x0000ffff)
+#define VPP_SPLIT_MON_18_MASK	(0x0000ffff)
+#define VPP_SPLIT_MON_19_MASK	(0x0000ffff)
+#define VPP_SPLIT_CFG2_0_MASK	(0xffffffff)
+#define VPP_SPLIT_CFG2_1_MASK	(0xffffffff)
+#define VPP_SPLIT_CFG2_2_MASK	(0x00000001)
+#define VPP_SPLIT_CFG2_4_MASK	(0xffffffff)
+#define VPP_SPLIT_CFG2_5_MASK	(0xffffffff)
+#define VPP_SPLIT_CFG2_6_MASK	(0xffffffff)
+#define VPP_SPLIT_CFG2_7_MASK	(0xffffffff)
+#define VPP_SPLIT_CFG2_8_MASK	(0x00000001)
+#define VPP_SPLIT_CFG2_9_MASK	(0x0000000f)
+#define VPP_SPLIT_CFG2_10_MASK	(0x0000ffff)
+#define VPP_SPLIT_CFG2_11_MASK	(0x00000001)
+#define VPP_SPLIT_CFG2_12_MASK	(0xffffffff)
+#define VPP_SPLIT_CFG2_13_MASK	(0xffffffff)
+#define VPP_SPLIT_CFG2_16_MASK	(0xffffffff)
+#define VPP_SPLIT_CFG2_17_MASK	(0xffffffff)
+#define VPP_SPLIT_CFG2_18_MASK	(0x00000001)
+#define VPP_SPLIT_CFG2_20_MASK	(0xffffffff)
+#define VPP_SPLIT_CFG2_21_MASK	(0xffffffff)
+#define VPP_SPLIT_CFG2_22_MASK	(0xffffffff)
+#define VPP_SPLIT_CFG2_23_MASK	(0xffffffff)
+#define VPP_SPLIT_CFG2_24_MASK	(0x00000001)
+#define VPP_SPLIT_CFG2_25_MASK	(0x0000000f)
+#define VPP_SPLIT_CFG2_26_MASK	(0x0000000f)
+#define VPP_SPLIT_CFG2_27_MASK	(0x00000001)
+#define VPP_SPLIT_CFG2_28_MASK	(0xffffffff)
+#define VPP_SPLIT_CFG2_29_MASK	(0xffffffff)
+#define VPP_SPLIT_PATG_0_MASK	(0x00000001)
+#define VPP_SPLIT_PATG_1_MASK	(0x00000001)
+#define VPP_SPLIT_PATG_2_MASK	(0x00000001)
+#define VPP_SPLIT_PATG_4_MASK	(0x0001ffff)
+#define VPP_SPLIT_PATG_5_MASK	(0x0000ffff)
+#define VPP_SPLIT_PATG_6_MASK	(0x0000ffff)
+#define VPP_SPLIT_PATG_7_MASK	(0x0000ffff)
+#define VPP_SPLIT_PATG_8_MASK	(0x0011ffff)
+#define VPP_SPLIT_PATG_9_MASK	(0x0000ffff)
+#define VPP_SPLIT_PATG_10_MASK	(0x0000ffff)
+#define VPP_SPLIT_PATG_11_MASK	(0x0000ffff)
+#define VPP_SPLIT_PATG_12_MASK	(0xffffffff)
+#define VPP_SPLIT_PATG_13_MASK	(0x0000ffff)
+#define VPP_SPLIT_PATG_14_MASK	(0xffffffff)
+#define VPP_SPLIT_PATG_16_MASK	(0xffffffff)
+#define VPP_SPLIT_PATG_17_MASK	(0x0000ffff)
+#define VPP_SPLIT_PATG_18_MASK	(0xffffffff)
+#define VPP_SPLIT_PATG_20_MASK	(0xffffffff)
+#define VPP_SPLIT_PATG_21_MASK	(0x0000ffff)
+#define VPP_SPLIT_PATG_22_MASK	(0xffffffff)
+#define VPP_SPLIT_PATG_24_MASK	(0xffffffff)
+#define VPP_SPLIT_PATG_25_MASK	(0x0000ffff)
+#define VPP_SPLIT_PATG_26_MASK	(0x0000ffff)
+#define VPP_SPLIT_PATG_27_MASK	(0x0000ffff)
+#define VPP_SPLIT_PATG_32_MASK	(0x0000ffff)
+#define VPP_SPLIT_PATG_33_MASK	(0x0000ffff)
+#define VPP_SPLIT_PATG_34_MASK	(0x0000ffff)
+#define VPP_SPLIT_PATG_35_MASK	(0x0000ffff)
+#define VPP_SPLIT_PATG_36_MASK	(0x0011ffff)
+#define VPP_SPLIT_PATG_37_MASK	(0x0000ffff)
+#define VPP_SPLIT_PATG_38_MASK	(0x0000ffff)
+#define VPP_SPLIT_PATG_39_MASK	(0x0000ffff)
+#define VPP_SPLIT_PATG_40_MASK	(0xffffffff)
+#define VPP_SPLIT_PATG_41_MASK	(0x0000ffff)
+#define VPP_SPLIT_PATG_42_MASK	(0xffffffff)
+#define VPP_SPLIT_PATG_44_MASK	(0xffffffff)
+#define VPP_SPLIT_PATG_45_MASK	(0x0000ffff)
+#define VPP_SPLIT_PATG_46_MASK	(0xffffffff)
+#define VPP_SPLIT_PATG_48_MASK	(0xffffffff)
+#define VPP_SPLIT_PATG_49_MASK	(0x0000ffff)
+#define VPP_SPLIT_PATG_50_MASK	(0xffffffff)
+#define VPP_SPLIT_PATG_52_MASK	(0xffffffff)
+#define VPP_SPLIT_PATG_53_MASK	(0x0000ffff)
+#define VPP_SPLIT_PATG_54_MASK	(0x0000ffff)
+#define VPP_SPLIT_PATG_55_MASK	(0x0000ffff)
+
+#endif  // __MDP_REG_SPLIT_H__
diff --git a/drivers/media/platform/mtk-mdp3/mdp_reg_stitch.h b/drivers/media/platform/mtk-mdp3/mdp_reg_stitch.h
new file mode 100644
index 0000000000000000000000000000000000000000..698eed2339ca52bedfb01cf0c6da95f441b59bad
--- /dev/null
+++ b/drivers/media/platform/mtk-mdp3/mdp_reg_stitch.h
@@ -0,0 +1,36 @@
+#ifndef __MDP_REG_STITCH_H__
+#define __MDP_REG_STITCH_H__
+
+#include "mmsys_reg_base.h"
+
+#define STITCH_EN               (0x000)
+#define STITCH_RESET            (0x004)
+#define STITCH_INTEN            (0x008)
+#define STITCH_INTSTA           (0x00C)
+#define STITCH_STATUS           (0x010)
+#define STITCH_CFG              (0x014)
+#define STITCH_FIFO_CON         (0x018)
+#define STITCH_SRC_SIZE_L       (0x01C)
+#define STITCH_SRC_LOCATION_L   (0x020)
+#define STITCH_SRC_SIZE_R       (0x024)
+#define STITCH_SRC_LOCATION_R   (0x028)
+#define STITCH_SIZE             (0x02C)
+#define STITCH_INPUT_COUNT_L	(0x030)
+#define STITCH_INPUT_COUNT_R	(0x034)
+#define STITCH_OUTPUT_COUNT     (0x038)
+#define STITCH_CORE_COUNT       (0x03C)
+#define STITCH_CHKSUM           (0x040)
+#define STITCH_MON0             (0x044)
+#define STITCH_DEBUG            (0x080)
+#define STITCH_DUMMY            (0x0C0)
+
+#define STITCH_EN_MASK             (0xFFFFFFFF)
+#define STITCH_SIZE_MASK           (0xFFFFFFFF)
+#define STITCH_SRC_SIZE_L_MASK     (0xFFFFFFFF)
+#define STITCH_SRC_SIZE_R_MASK     (0xFFFFFFFF)
+#define STITCH_SRC_LOCATION_L_MASK (0xFFFFFFFF)
+#define STITCH_SRC_LOCATION_R_MASK (0xFFFFFFFF)
+
+/* MASK */
+
+#endif  //__MDP_REG_STITCH_H__
diff --git a/drivers/media/platform/mtk-mdp3/mdp_reg_tcc.h b/drivers/media/platform/mtk-mdp3/mdp_reg_tcc.h
new file mode 100644
index 0000000000000000000000000000000000000000..30b4a6949642ec423c218d73494a785bbaa82929
--- /dev/null
+++ b/drivers/media/platform/mtk-mdp3/mdp_reg_tcc.h
@@ -0,0 +1,679 @@
+#ifndef __MDP_REG_TCC_H__
+#define __MDP_REG_TCC_H__
+
+#include "mmsys_reg_base.h"
+
+#define MDP_TCC_CTRL          (0x00000000)
+#define MDP_TCC_LUT_0         (0x00000004)
+#define MDP_TCC_LUT_1         (0x00000008)
+#define MDP_TCC_LUT_2         (0x0000000C)
+#define MDP_TCC_LUT_3         (0x00000010)
+#define MDP_TCC_LUT_4         (0x00000014)
+#define MDP_TCC_LUT_5         (0x00000018)
+#define MDP_TCC_LUT_6         (0x0000001C)
+#define MDP_TCC_LUT_7         (0x00000020)
+#define MDP_TCC_LUT_8         (0x00000024)
+#define MDP_TCC_LUT_9         (0x00000028)
+#define MDP_TCC_LUT_10        (0x0000002C)
+#define MDP_TCC_LUT_11        (0x00000030)
+#define MDP_TCC_LUT_12        (0x00000034)
+#define MDP_TCC_LUT_13        (0x00000038)
+#define MDP_TCC_LUT_14        (0x0000003C)
+#define MDP_TCC_LUT_15        (0x00000040)
+#define MDP_TCC_LUT_16        (0x00000044)
+#define MDP_TCC_LUT_17        (0x00000048)
+#define MDP_TCC_LUT_18        (0x0000004C)
+#define MDP_TCC_LUT_19        (0x00000050)
+#define MDP_TCC_LUT_20        (0x00000054)
+#define MDP_TCC_LUT_21        (0x00000058)
+#define MDP_TCC_LUT_22        (0x0000005C)
+#define MDP_TCC_LUT_23        (0x00000060)
+#define MDP_TCC_LUT_24        (0x00000064)
+#define MDP_TCC_LUT_25        (0x00000068)
+#define MDP_TCC_LUT_26        (0x0000006C)
+#define MDP_TCC_LUT_27        (0x00000070)
+#define MDP_TCC_LUT_28        (0x00000074)
+#define MDP_TCC_LUT_29        (0x00000078)
+#define MDP_TCC_LUT_30        (0x0000007C)
+#define MDP_TCC_LUT_31        (0x00000080)
+#define MDP_TCC_LUT_32        (0x00000084)
+#define MDP_TCC_LUT_33        (0x00000088)
+#define MDP_TCC_LUT_34        (0x0000008C)
+#define MDP_TCC_LUT_35        (0x00000090)
+#define MDP_TCC_LUT_36        (0x00000094)
+#define MDP_TCC_LUT_37        (0x00000098)
+#define MDP_TCC_LUT_38        (0x0000009C)
+#define MDP_TCC_LUT_39        (0x000000A0)
+#define MDP_TCC_LUT_40        (0x000000A4)
+#define MDP_TCC_LUT_41        (0x000000A8)
+#define MDP_TCC_LUT_42        (0x000000AC)
+#define MDP_TCC_LUT_43        (0x000000B0)
+#define MDP_TCC_LUT_44        (0x000000B4)
+#define MDP_TCC_LUT_45        (0x000000B8)
+#define MDP_TCC_LUT_46        (0x000000BC)
+#define MDP_TCC_LUT_47        (0x000000C0)
+#define MDP_TCC_LUT_48        (0x000000C4)
+#define MDP_TCC_LUT_49        (0x000000C8)
+#define MDP_TCC_LUT_50        (0x000000CC)
+#define MDP_TCC_LUT_51        (0x000000D0)
+#define MDP_TCC_LUT_52        (0x000000D4)
+#define MDP_TCC_LUT_53        (0x000000D8)
+#define MDP_TCC_LUT_54        (0x000000DC)
+#define MDP_TCC_LUT_55        (0x000000E0)
+#define MDP_TCC_LUT_56        (0x000000E4)
+#define MDP_TCC_LUT_57        (0x000000E8)
+#define MDP_TCC_LUT_58        (0x000000EC)
+#define MDP_TCC_LUT_59        (0x000000F0)
+#define MDP_TCC_LUT_60        (0x000000F4)
+#define MDP_TCC_LUT_61        (0x000000F8)
+#define MDP_TCC_LUT_62        (0x000000FC)
+#define MDP_TCC_LUT_63        (0x00000100)
+#define MDP_TCC_LUT_64        (0x00000104)
+#define MDP_TCC_LUT_65        (0x00000108)
+#define MDP_TCC_LUT_66        (0x0000010C)
+#define MDP_TCC_LUT_67        (0x00000110)
+#define MDP_TCC_LUT_68        (0x00000114)
+#define MDP_TCC_LUT_69        (0x00000118)
+#define MDP_TCC_LUT_70        (0x0000011C)
+#define MDP_TCC_LUT_71        (0x00000120)
+#define MDP_TCC_LUT_72        (0x00000124)
+#define MDP_TCC_LUT_73        (0x00000128)
+#define MDP_TCC_LUT_74        (0x0000012C)
+#define MDP_TCC_LUT_75        (0x00000130)
+#define MDP_TCC_LUT_76        (0x00000134)
+#define MDP_TCC_LUT_77        (0x00000138)
+#define MDP_TCC_LUT_78        (0x0000013C)
+#define MDP_TCC_LUT_79        (0x00000140)
+#define MDP_TCC_LUT_80        (0x00000144)
+#define MDP_TCC_LUT_81        (0x00000148)
+#define MDP_TCC_LUT_82        (0x0000014C)
+#define MDP_TCC_LUT_83        (0x00000150)
+#define MDP_TCC_LUT_84        (0x00000154)
+#define MDP_TCC_LUT_85        (0x00000158)
+#define MDP_TCC_LUT_86        (0x0000015C)
+#define MDP_TCC_LUT_87        (0x00000160)
+#define MDP_TCC_LUT_88        (0x00000164)
+#define MDP_TCC_LUT_89        (0x00000168)
+#define MDP_TCC_LUT_90        (0x0000016C)
+#define MDP_TCC_LUT_91        (0x00000170)
+#define MDP_TCC_LUT_92        (0x00000174)
+#define MDP_TCC_LUT_93        (0x00000178)
+#define MDP_TCC_LUT_94        (0x0000017C)
+#define MDP_TCC_LUT_95        (0x00000180)
+#define MDP_TCC_LUT_96        (0x00000184)
+#define MDP_TCC_LUT_97        (0x00000188)
+#define MDP_TCC_LUT_98        (0x0000018C)
+#define MDP_TCC_LUT_99        (0x00000190)
+#define MDP_TCC_LUT_100       (0x00000194)
+#define MDP_TCC_LUT_101       (0x00000198)
+#define MDP_TCC_LUT_102       (0x0000019C)
+#define MDP_TCC_LUT_103       (0x000001A0)
+#define MDP_TCC_LUT_104       (0x000001A4)
+#define MDP_TCC_LUT_105       (0x000001A8)
+#define MDP_TCC_LUT_106       (0x000001AC)
+#define MDP_TCC_LUT_107       (0x000001B0)
+#define MDP_TCC_LUT_108       (0x000001B4)
+#define MDP_TCC_LUT_109       (0x000001B8)
+#define MDP_TCC_LUT_110       (0x000001BC)
+#define MDP_TCC_LUT_111       (0x000001C0)
+#define MDP_TCC_LUT_112       (0x000001C4)
+#define MDP_TCC_LUT_113       (0x000001C8)
+#define MDP_TCC_LUT_114       (0x000001CC)
+#define MDP_TCC_LUT_115       (0x000001D0)
+#define MDP_TCC_LUT_116       (0x000001D4)
+#define MDP_TCC_LUT_117       (0x000001D8)
+#define MDP_TCC_LUT_118       (0x000001DC)
+#define MDP_TCC_LUT_119       (0x000001E0)
+#define MDP_TCC_LUT_120       (0x000001E4)
+#define MDP_TCC_LUT_121       (0x000001E8)
+#define MDP_TCC_LUT_122       (0x000001EC)
+#define MDP_TCC_LUT_123       (0x000001F0)
+#define MDP_TCC_LUT_124       (0x000001F4)
+#define MDP_TCC_LUT_125       (0x000001F8)
+#define MDP_TCC_LUT_126       (0x000001FC)
+#define MDP_TCC_LUT_127       (0x00000200)
+#define MDP_TCC_LUT_128       (0x00000204)
+#define MDP_TCC_LUT_129       (0x00000208)
+#define MDP_TCC_LUT_130       (0x0000020C)
+#define MDP_TCC_LUT_131       (0x00000210)
+#define MDP_TCC_LUT_132       (0x00000214)
+#define MDP_TCC_LUT_133       (0x00000218)
+#define MDP_TCC_LUT_134       (0x0000021C)
+#define MDP_TCC_LUT_135       (0x00000220)
+#define MDP_TCC_LUT_136       (0x00000224)
+#define MDP_TCC_LUT_137       (0x00000228)
+#define MDP_TCC_LUT_138       (0x0000022C)
+#define MDP_TCC_LUT_139       (0x00000230)
+#define MDP_TCC_LUT_140       (0x00000234)
+#define MDP_TCC_LUT_141       (0x00000238)
+#define MDP_TCC_LUT_142       (0x0000023C)
+#define MDP_TCC_LUT_143       (0x00000240)
+#define MDP_TCC_LUT_144       (0x00000244)
+#define MDP_TCC_LUT_145       (0x00000248)
+#define MDP_TCC_LUT_146       (0x0000024C)
+#define MDP_TCC_LUT_147       (0x00000250)
+#define MDP_TCC_LUT_148       (0x00000254)
+#define MDP_TCC_LUT_149       (0x00000258)
+#define MDP_TCC_LUT_150       (0x0000025C)
+#define MDP_TCC_LUT_151       (0x00000260)
+#define MDP_TCC_LUT_152       (0x00000264)
+#define MDP_TCC_LUT_153       (0x00000268)
+#define MDP_TCC_LUT_154       (0x0000026C)
+#define MDP_TCC_LUT_155       (0x00000270)
+#define MDP_TCC_LUT_156       (0x00000274)
+#define MDP_TCC_LUT_157       (0x00000278)
+#define MDP_TCC_LUT_158       (0x0000027C)
+#define MDP_TCC_LUT_159       (0x00000280)
+#define MDP_TCC_LUT_160       (0x00000284)
+#define MDP_TCC_LUT_161       (0x00000288)
+#define MDP_TCC_LUT_162       (0x0000028C)
+#define MDP_TCC_LUT_163       (0x00000290)
+#define MDP_TCC_LUT_164       (0x00000294)
+#define MDP_TCC_LUT_165       (0x00000298)
+#define MDP_TCC_LUT_166       (0x0000029C)
+#define MDP_TCC_LUT_167       (0x000002A0)
+#define MDP_TCC_LUT_168       (0x000002A4)
+#define MDP_TCC_LUT_169       (0x000002A8)
+#define MDP_TCC_LUT_170       (0x000002AC)
+#define MDP_TCC_LUT_171       (0x000002B0)
+#define MDP_TCC_LUT_172       (0x000002B4)
+#define MDP_TCC_LUT_173       (0x000002B8)
+#define MDP_TCC_LUT_174       (0x000002BC)
+#define MDP_TCC_LUT_175       (0x000002C0)
+#define MDP_TCC_LUT_176       (0x000002C4)
+#define MDP_TCC_LUT_177       (0x000002C8)
+#define MDP_TCC_LUT_178       (0x000002CC)
+#define MDP_TCC_LUT_179       (0x000002D0)
+#define MDP_TCC_LUT_180       (0x000002D4)
+#define MDP_TCC_LUT_181       (0x000002D8)
+#define MDP_TCC_LUT_182       (0x000002DC)
+#define MDP_TCC_LUT_183       (0x000002E0)
+#define MDP_TCC_LUT_184       (0x000002E4)
+#define MDP_TCC_LUT_185       (0x000002E8)
+#define MDP_TCC_LUT_186       (0x000002EC)
+#define MDP_TCC_LUT_187       (0x000002F0)
+#define MDP_TCC_LUT_188       (0x000002F4)
+#define MDP_TCC_LUT_189       (0x000002F8)
+#define MDP_TCC_LUT_190       (0x000002FC)
+#define MDP_TCC_LUT_191       (0x00000300)
+#define MDP_TCC_LUT_192       (0x00000304)
+#define MDP_TCC_LUT_193       (0x00000308)
+#define MDP_TCC_LUT_194       (0x0000030C)
+#define MDP_TCC_LUT_195       (0x00000310)
+#define MDP_TCC_LUT_196       (0x00000314)
+#define MDP_TCC_LUT_197       (0x00000318)
+#define MDP_TCC_LUT_198       (0x0000031C)
+#define MDP_TCC_LUT_199       (0x00000320)
+#define MDP_TCC_LUT_200       (0x00000324)
+#define MDP_TCC_LUT_201       (0x00000328)
+#define MDP_TCC_LUT_202       (0x0000032C)
+#define MDP_TCC_LUT_203       (0x00000330)
+#define MDP_TCC_LUT_204       (0x00000334)
+#define MDP_TCC_LUT_205       (0x00000338)
+#define MDP_TCC_LUT_206       (0x0000033C)
+#define MDP_TCC_LUT_207       (0x00000340)
+#define MDP_TCC_LUT_208       (0x00000344)
+#define MDP_TCC_LUT_209       (0x00000348)
+#define MDP_TCC_LUT_210       (0x0000034C)
+#define MDP_TCC_LUT_211       (0x00000350)
+#define MDP_TCC_LUT_212       (0x00000354)
+#define MDP_TCC_LUT_213       (0x00000358)
+#define MDP_TCC_LUT_214       (0x0000035C)
+#define MDP_TCC_LUT_215       (0x00000360)
+#define MDP_TCC_LUT_216       (0x00000364)
+#define MDP_TCC_LUT_217       (0x00000368)
+#define MDP_TCC_LUT_218       (0x0000036C)
+#define MDP_TCC_LUT_219       (0x00000370)
+#define MDP_TCC_LUT_220       (0x00000374)
+#define MDP_TCC_LUT_221       (0x00000378)
+#define MDP_TCC_LUT_222       (0x0000037C)
+#define MDP_TCC_LUT_223       (0x00000380)
+#define MDP_TCC_LUT_224       (0x00000384)
+#define MDP_TCC_LUT_225       (0x00000388)
+#define MDP_TCC_LUT_226       (0x0000038C)
+#define MDP_TCC_LUT_227       (0x00000390)
+#define MDP_TCC_LUT_228       (0x00000394)
+#define MDP_TCC_LUT_229       (0x00000398)
+#define MDP_TCC_LUT_230       (0x0000039C)
+#define MDP_TCC_LUT_231       (0x000003A0)
+#define MDP_TCC_LUT_232       (0x000003A4)
+#define MDP_TCC_LUT_233       (0x000003A8)
+#define MDP_TCC_LUT_234       (0x000003AC)
+#define MDP_TCC_LUT_235       (0x000003B0)
+#define MDP_TCC_LUT_236       (0x000003B4)
+#define MDP_TCC_LUT_237       (0x000003B8)
+#define MDP_TCC_LUT_238       (0x000003BC)
+#define MDP_TCC_LUT_239       (0x000003C0)
+#define MDP_TCC_LUT_240       (0x000003C4)
+#define MDP_TCC_LUT_241       (0x000003C8)
+#define MDP_TCC_LUT_242       (0x000003CC)
+#define MDP_TCC_LUT_243       (0x000003D0)
+#define MDP_TCC_LUT_244       (0x000003D4)
+#define MDP_TCC_LUT_245       (0x000003D8)
+#define MDP_TCC_LUT_246       (0x000003DC)
+#define MDP_TCC_LUT_247       (0x000003E0)
+#define MDP_TCC_LUT_248       (0x000003E4)
+#define MDP_TCC_LUT_249       (0x000003E8)
+#define MDP_TCC_LUT_250       (0x000003EC)
+#define MDP_TCC_LUT_251       (0x000003F0)
+#define MDP_TCC_LUT_252       (0x000003F4)
+#define MDP_TCC_LUT_253       (0x000003F8)
+#define MDP_TCC_LUT_254       (0x000003FC)
+#define MDP_TCC_LUT_255       (0x00000400)
+#define MDP_TCC_C2G_CNV_0     (0x00000404)
+#define MDP_TCC_C2G_CNV_1     (0x00000408)
+#define MDP_TCC_C2G_CNV_2     (0x0000040C)
+#define MDP_TCC_C2G_CNV_3     (0x00000410)
+#define MDP_TCC_C2G_CNV_4     (0x00000414)
+#define MDP_TCC_C2G_CNV_5     (0x00000418)
+#define MDP_TCC_G2C_CNV_0     (0x0000041C)
+#define MDP_TCC_G2C_CNV_1     (0x00000420)
+#define MDP_TCC_G2C_CNV_2     (0x00000424)
+#define MDP_TCC_G2C_CNV_3     (0x00000428)
+#define MDP_TCC_G2C_CNV_4     (0x0000042C)
+#define MDP_TCC_G2C_CNV_5     (0x00000430)
+#define MDP_TCC_HIST_0        (0x00000434)
+#define MDP_TCC_HIST_1        (0x00000438)
+#define MDP_TCC_HIST_2        (0x0000043C)
+#define MDP_TCC_HIST_3        (0x00000440)
+#define MDP_TCC_HIST_4        (0x00000444)
+#define MDP_TCC_HIST_5        (0x00000448)
+#define MDP_TCC_HIST_6        (0x0000044C)
+#define MDP_TCC_HIST_7        (0x00000450)
+#define MDP_TCC_HIST_8        (0x00000454)
+#define MDP_TCC_HIST_9        (0x00000458)
+#define MDP_TCC_HIST_10       (0x0000045C)
+#define MDP_TCC_HIST_11       (0x00000460)
+#define MDP_TCC_HIST_12       (0x00000464)
+#define MDP_TCC_HIST_13       (0x00000468)
+#define MDP_TCC_HIST_14       (0x0000046C)
+#define MDP_TCC_HIST_15       (0x00000470)
+#define MDP_TCC_HIST_16       (0x00000474)
+#define MDP_TCC_HIST_17       (0x00000478)
+#define MDP_TCC_HIST_18       (0x0000047C)
+#define MDP_TCC_HIST_19       (0x00000480)
+#define MDP_TCC_HIST_20       (0x00000484)
+#define MDP_TCC_HIST_21       (0x00000488)
+#define MDP_TCC_HIST_22       (0x0000048C)
+#define MDP_TCC_HIST_23       (0x00000490)
+#define MDP_TCC_HIST_24       (0x00000494)
+#define MDP_TCC_HIST_25       (0x00000498)
+#define MDP_TCC_HIST_26       (0x0000049C)
+#define MDP_TCC_HIST_27       (0x000004A0)
+#define MDP_TCC_HIST_28       (0x000004A4)
+#define MDP_TCC_HIST_29       (0x000004A8)
+#define MDP_TCC_HIST_30       (0x000004AC)
+#define MDP_TCC_HIST_31       (0x000004B0)
+#define MDP_TCC_HIST_32       (0x000004B4)
+#define MDP_TCC_HIST_33       (0x000004B8)
+#define MDP_TCC_HIST_34       (0x000004BC)
+#define MDP_TCC_HIST_35       (0x000004C0)
+#define MDP_TCC_HIST_36       (0x000004C4)
+#define MDP_TCC_HIST_37       (0x000004C8)
+#define MDP_TCC_HIST_38       (0x000004CC)
+#define MDP_TCC_HIST_39       (0x000004D0)
+#define MDP_TCC_HIST_40       (0x000004D4)
+#define MDP_TCC_HIST_41       (0x000004D8)
+#define MDP_TCC_HIST_42       (0x000004DC)
+#define MDP_TCC_HIST_43       (0x000004E0)
+#define MDP_TCC_HIST_44       (0x000004E4)
+#define MDP_TCC_HIST_45       (0x000004E8)
+#define MDP_TCC_HIST_46       (0x000004EC)
+#define MDP_TCC_HIST_47       (0x000004F0)
+#define MDP_TCC_HIST_48       (0x000004F4)
+#define MDP_TCC_HIST_49       (0x000004F8)
+#define MDP_TCC_HIST_50       (0x000004FC)
+#define MDP_TCC_HIST_51       (0x00000500)
+#define MDP_TCC_HIST_52       (0x00000504)
+#define MDP_TCC_HIST_53       (0x00000508)
+#define MDP_TCC_HIST_54       (0x0000050C)
+#define MDP_TCC_HIST_55       (0x00000510)
+#define MDP_TCC_HIST_56       (0x00000514)
+#define MDP_TCC_HIST_DONE     (0x00000518)
+#define MDP_TCC_DCM           (0x0000051C)
+#define MDP_TCC_DEBUG         (0x00000520)
+#define MDP_TCC_INTEN         (0x00000524)
+#define MDP_TCC_INTST         (0x00000528)
+#define MDP_TCC_ST            (0x0000052C)
+#define MDP_TCC_CROP_X        (0x00000530)
+#define MDP_TCC_CROP_Y        (0x00000534)
+#define MDP_TCC_IN_SIZE       (0x00000600)
+
+/* MASK */
+
+#define MDP_TCC_CTRL_MASK               (0xFFFFFFFF)
+#define MDP_TCC_LUT_0_MASK              (0xFFFFFFFF)
+#define MDP_TCC_LUT_1_MASK              (0xFFFFFFFF)
+#define MDP_TCC_LUT_2_MASK              (0xFFFFFFFF)
+#define MDP_TCC_LUT_3_MASK              (0xFFFFFFFF)
+#define MDP_TCC_LUT_4_MASK              (0xFFFFFFFF)
+#define MDP_TCC_LUT_5_MASK              (0xFFFFFFFF)
+#define MDP_TCC_LUT_6_MASK              (0xFFFFFFFF)
+#define MDP_TCC_LUT_7_MASK              (0xFFFFFFFF)
+#define MDP_TCC_LUT_8_MASK              (0xFFFFFFFF)
+#define MDP_TCC_LUT_9_MASK              (0xFFFFFFFF)
+#define MDP_TCC_LUT_10_MASK             (0xFFFFFFFF)
+#define MDP_TCC_LUT_11_MASK             (0xFFFFFFFF)
+#define MDP_TCC_LUT_12_MASK             (0xFFFFFFFF)
+#define MDP_TCC_LUT_13_MASK             (0xFFFFFFFF)
+#define MDP_TCC_LUT_14_MASK             (0xFFFFFFFF)
+#define MDP_TCC_LUT_15_MASK             (0xFFFFFFFF)
+#define MDP_TCC_LUT_16_MASK             (0xFFFFFFFF)
+#define MDP_TCC_LUT_17_MASK             (0xFFFFFFFF)
+#define MDP_TCC_LUT_18_MASK             (0xFFFFFFFF)
+#define MDP_TCC_LUT_19_MASK             (0xFFFFFFFF)
+#define MDP_TCC_LUT_20_MASK             (0xFFFFFFFF)
+#define MDP_TCC_LUT_21_MASK             (0xFFFFFFFF)
+#define MDP_TCC_LUT_22_MASK             (0xFFFFFFFF)
+#define MDP_TCC_LUT_23_MASK             (0xFFFFFFFF)
+#define MDP_TCC_LUT_24_MASK             (0xFFFFFFFF)
+#define MDP_TCC_LUT_25_MASK             (0xFFFFFFFF)
+#define MDP_TCC_LUT_26_MASK             (0xFFFFFFFF)
+#define MDP_TCC_LUT_27_MASK             (0xFFFFFFFF)
+#define MDP_TCC_LUT_28_MASK             (0xFFFFFFFF)
+#define MDP_TCC_LUT_29_MASK             (0xFFFFFFFF)
+#define MDP_TCC_LUT_30_MASK             (0xFFFFFFFF)
+#define MDP_TCC_LUT_31_MASK             (0xFFFFFFFF)
+#define MDP_TCC_LUT_32_MASK             (0xFFFFFFFF)
+#define MDP_TCC_LUT_33_MASK             (0xFFFFFFFF)
+#define MDP_TCC_LUT_34_MASK             (0xFFFFFFFF)
+#define MDP_TCC_LUT_35_MASK             (0xFFFFFFFF)
+#define MDP_TCC_LUT_36_MASK             (0xFFFFFFFF)
+#define MDP_TCC_LUT_37_MASK             (0xFFFFFFFF)
+#define MDP_TCC_LUT_38_MASK             (0xFFFFFFFF)
+#define MDP_TCC_LUT_39_MASK             (0xFFFFFFFF)
+#define MDP_TCC_LUT_40_MASK             (0xFFFFFFFF)
+#define MDP_TCC_LUT_41_MASK             (0xFFFFFFFF)
+#define MDP_TCC_LUT_42_MASK             (0xFFFFFFFF)
+#define MDP_TCC_LUT_43_MASK             (0xFFFFFFFF)
+#define MDP_TCC_LUT_44_MASK             (0xFFFFFFFF)
+#define MDP_TCC_LUT_45_MASK             (0xFFFFFFFF)
+#define MDP_TCC_LUT_46_MASK             (0xFFFFFFFF)
+#define MDP_TCC_LUT_47_MASK             (0xFFFFFFFF)
+#define MDP_TCC_LUT_48_MASK             (0xFFFFFFFF)
+#define MDP_TCC_LUT_49_MASK             (0xFFFFFFFF)
+#define MDP_TCC_LUT_50_MASK             (0xFFFFFFFF)
+#define MDP_TCC_LUT_51_MASK             (0xFFFFFFFF)
+#define MDP_TCC_LUT_52_MASK             (0xFFFFFFFF)
+#define MDP_TCC_LUT_53_MASK             (0xFFFFFFFF)
+#define MDP_TCC_LUT_54_MASK             (0xFFFFFFFF)
+#define MDP_TCC_LUT_55_MASK             (0xFFFFFFFF)
+#define MDP_TCC_LUT_56_MASK             (0xFFFFFFFF)
+#define MDP_TCC_LUT_57_MASK             (0xFFFFFFFF)
+#define MDP_TCC_LUT_58_MASK             (0xFFFFFFFF)
+#define MDP_TCC_LUT_59_MASK             (0xFFFFFFFF)
+#define MDP_TCC_LUT_60_MASK             (0xFFFFFFFF)
+#define MDP_TCC_LUT_61_MASK             (0xFFFFFFFF)
+#define MDP_TCC_LUT_62_MASK             (0xFFFFFFFF)
+#define MDP_TCC_LUT_63_MASK             (0xFFFFFFFF)
+#define MDP_TCC_LUT_64_MASK             (0xFFFFFFFF)
+#define MDP_TCC_LUT_65_MASK             (0xFFFFFFFF)
+#define MDP_TCC_LUT_66_MASK             (0xFFFFFFFF)
+#define MDP_TCC_LUT_67_MASK             (0xFFFFFFFF)
+#define MDP_TCC_LUT_68_MASK             (0xFFFFFFFF)
+#define MDP_TCC_LUT_69_MASK             (0xFFFFFFFF)
+#define MDP_TCC_LUT_70_MASK             (0xFFFFFFFF)
+#define MDP_TCC_LUT_71_MASK             (0xFFFFFFFF)
+#define MDP_TCC_LUT_72_MASK             (0xFFFFFFFF)
+#define MDP_TCC_LUT_73_MASK             (0xFFFFFFFF)
+#define MDP_TCC_LUT_74_MASK             (0xFFFFFFFF)
+#define MDP_TCC_LUT_75_MASK             (0xFFFFFFFF)
+#define MDP_TCC_LUT_76_MASK             (0xFFFFFFFF)
+#define MDP_TCC_LUT_77_MASK             (0xFFFFFFFF)
+#define MDP_TCC_LUT_78_MASK             (0xFFFFFFFF)
+#define MDP_TCC_LUT_79_MASK             (0xFFFFFFFF)
+#define MDP_TCC_LUT_80_MASK             (0xFFFFFFFF)
+#define MDP_TCC_LUT_81_MASK             (0xFFFFFFFF)
+#define MDP_TCC_LUT_82_MASK             (0xFFFFFFFF)
+#define MDP_TCC_LUT_83_MASK             (0xFFFFFFFF)
+#define MDP_TCC_LUT_84_MASK             (0xFFFFFFFF)
+#define MDP_TCC_LUT_85_MASK             (0xFFFFFFFF)
+#define MDP_TCC_LUT_86_MASK             (0xFFFFFFFF)
+#define MDP_TCC_LUT_87_MASK             (0xFFFFFFFF)
+#define MDP_TCC_LUT_88_MASK             (0xFFFFFFFF)
+#define MDP_TCC_LUT_89_MASK             (0xFFFFFFFF)
+#define MDP_TCC_LUT_90_MASK             (0xFFFFFFFF)
+#define MDP_TCC_LUT_91_MASK             (0xFFFFFFFF)
+#define MDP_TCC_LUT_92_MASK             (0xFFFFFFFF)
+#define MDP_TCC_LUT_93_MASK             (0xFFFFFFFF)
+#define MDP_TCC_LUT_94_MASK             (0xFFFFFFFF)
+#define MDP_TCC_LUT_95_MASK             (0xFFFFFFFF)
+#define MDP_TCC_LUT_96_MASK             (0xFFFFFFFF)
+#define MDP_TCC_LUT_97_MASK             (0xFFFFFFFF)
+#define MDP_TCC_LUT_98_MASK             (0xFFFFFFFF)
+#define MDP_TCC_LUT_99_MASK             (0xFFFFFFFF)
+#define MDP_TCC_LUT_100_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_101_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_102_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_103_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_104_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_105_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_106_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_107_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_108_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_109_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_110_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_111_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_112_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_113_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_114_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_115_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_116_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_117_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_118_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_119_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_120_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_121_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_122_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_123_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_124_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_125_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_126_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_127_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_128_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_129_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_130_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_131_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_132_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_133_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_134_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_135_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_136_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_137_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_138_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_139_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_140_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_141_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_142_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_143_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_144_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_145_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_146_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_147_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_148_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_149_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_150_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_151_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_152_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_153_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_154_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_155_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_156_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_157_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_158_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_159_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_160_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_161_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_162_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_163_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_164_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_165_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_166_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_167_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_168_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_169_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_170_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_171_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_172_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_173_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_174_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_175_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_176_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_177_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_178_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_179_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_180_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_181_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_182_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_183_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_184_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_185_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_186_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_187_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_188_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_189_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_190_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_191_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_192_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_193_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_194_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_195_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_196_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_197_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_198_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_199_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_200_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_201_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_202_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_203_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_204_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_205_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_206_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_207_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_208_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_209_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_210_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_211_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_212_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_213_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_214_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_215_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_216_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_217_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_218_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_219_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_220_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_221_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_222_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_223_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_224_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_225_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_226_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_227_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_228_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_229_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_230_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_231_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_232_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_233_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_234_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_235_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_236_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_237_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_238_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_239_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_240_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_241_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_242_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_243_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_244_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_245_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_246_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_247_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_248_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_249_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_250_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_251_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_252_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_253_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_254_MASK            (0xFFFFFFFF)
+#define MDP_TCC_LUT_255_MASK            (0xFFFFFFFF)
+#define MDP_TCC_C2G_CNV_0_MASK          (0xFFFFFFFF)
+#define MDP_TCC_C2G_CNV_1_MASK          (0xFFFFFFFF)
+#define MDP_TCC_C2G_CNV_2_MASK          (0xFFFFFFFF)
+#define MDP_TCC_C2G_CNV_3_MASK          (0xFFFFFFFF)
+#define MDP_TCC_C2G_CNV_4_MASK          (0xFFFFFFFF)
+#define MDP_TCC_C2G_CNV_5_MASK          (0xFFFFFFFF)
+#define MDP_TCC_G2C_CNV_0_MASK          (0xFFFFFFFF)
+#define MDP_TCC_G2C_CNV_1_MASK          (0xFFFFFFFF)
+#define MDP_TCC_G2C_CNV_2_MASK          (0xFFFFFFFF)
+#define MDP_TCC_G2C_CNV_3_MASK          (0xFFFFFFFF)
+#define MDP_TCC_G2C_CNV_4_MASK          (0xFFFFFFFF)
+#define MDP_TCC_G2C_CNV_5_MASK          (0xFFFFFFFF)
+#define MDP_TCC_HIST_0_MASK             (0xFFFFFFFF)
+#define MDP_TCC_HIST_1_MASK             (0xFFFFFFFF)
+#define MDP_TCC_HIST_2_MASK             (0xFFFFFFFF)
+#define MDP_TCC_HIST_3_MASK             (0xFFFFFFFF)
+#define MDP_TCC_HIST_4_MASK             (0xFFFFFFFF)
+#define MDP_TCC_HIST_5_MASK             (0xFFFFFFFF)
+#define MDP_TCC_HIST_6_MASK             (0xFFFFFFFF)
+#define MDP_TCC_HIST_7_MASK             (0xFFFFFFFF)
+#define MDP_TCC_HIST_8_MASK             (0xFFFFFFFF)
+#define MDP_TCC_HIST_9_MASK             (0xFFFFFFFF)
+#define MDP_TCC_HIST_10_MASK            (0xFFFFFFFF)
+#define MDP_TCC_HIST_11_MASK            (0xFFFFFFFF)
+#define MDP_TCC_HIST_12_MASK            (0xFFFFFFFF)
+#define MDP_TCC_HIST_13_MASK            (0xFFFFFFFF)
+#define MDP_TCC_HIST_14_MASK            (0xFFFFFFFF)
+#define MDP_TCC_HIST_15_MASK            (0xFFFFFFFF)
+#define MDP_TCC_HIST_16_MASK            (0xFFFFFFFF)
+#define MDP_TCC_HIST_17_MASK            (0xFFFFFFFF)
+#define MDP_TCC_HIST_18_MASK            (0xFFFFFFFF)
+#define MDP_TCC_HIST_19_MASK            (0xFFFFFFFF)
+#define MDP_TCC_HIST_20_MASK            (0xFFFFFFFF)
+#define MDP_TCC_HIST_21_MASK            (0xFFFFFFFF)
+#define MDP_TCC_HIST_22_MASK            (0xFFFFFFFF)
+#define MDP_TCC_HIST_23_MASK            (0xFFFFFFFF)
+#define MDP_TCC_HIST_24_MASK            (0xFFFFFFFF)
+#define MDP_TCC_HIST_25_MASK            (0xFFFFFFFF)
+#define MDP_TCC_HIST_26_MASK            (0xFFFFFFFF)
+#define MDP_TCC_HIST_27_MASK            (0xFFFFFFFF)
+#define MDP_TCC_HIST_28_MASK            (0xFFFFFFFF)
+#define MDP_TCC_HIST_29_MASK            (0xFFFFFFFF)
+#define MDP_TCC_HIST_30_MASK            (0xFFFFFFFF)
+#define MDP_TCC_HIST_31_MASK            (0xFFFFFFFF)
+#define MDP_TCC_HIST_32_MASK            (0xFFFFFFFF)
+#define MDP_TCC_HIST_33_MASK            (0xFFFFFFFF)
+#define MDP_TCC_HIST_34_MASK            (0xFFFFFFFF)
+#define MDP_TCC_HIST_35_MASK            (0xFFFFFFFF)
+#define MDP_TCC_HIST_36_MASK            (0xFFFFFFFF)
+#define MDP_TCC_HIST_37_MASK            (0xFFFFFFFF)
+#define MDP_TCC_HIST_38_MASK            (0xFFFFFFFF)
+#define MDP_TCC_HIST_39_MASK            (0xFFFFFFFF)
+#define MDP_TCC_HIST_40_MASK            (0xFFFFFFFF)
+#define MDP_TCC_HIST_41_MASK            (0xFFFFFFFF)
+#define MDP_TCC_HIST_42_MASK            (0xFFFFFFFF)
+#define MDP_TCC_HIST_43_MASK            (0xFFFFFFFF)
+#define MDP_TCC_HIST_44_MASK            (0xFFFFFFFF)
+#define MDP_TCC_HIST_45_MASK            (0xFFFFFFFF)
+#define MDP_TCC_HIST_46_MASK            (0xFFFFFFFF)
+#define MDP_TCC_HIST_47_MASK            (0xFFFFFFFF)
+#define MDP_TCC_HIST_48_MASK            (0xFFFFFFFF)
+#define MDP_TCC_HIST_49_MASK            (0xFFFFFFFF)
+#define MDP_TCC_HIST_50_MASK            (0xFFFFFFFF)
+#define MDP_TCC_HIST_51_MASK            (0xFFFFFFFF)
+#define MDP_TCC_HIST_52_MASK            (0xFFFFFFFF)
+#define MDP_TCC_HIST_53_MASK            (0xFFFFFFFF)
+#define MDP_TCC_HIST_54_MASK            (0xFFFFFFFF)
+#define MDP_TCC_HIST_55_MASK            (0xFFFFFFFF)
+#define MDP_TCC_HIST_56_MASK            (0xFFFFFFFF)
+#define MDP_TCC_HIST_DONE_MASK          (0xFFFFFFFF)
+#define MDP_TCC_DCM_MASK                (0xFFFFFFFF)
+#define MDP_TCC_DEBUG_MASK              (0xFFFFFFFF)
+#define MDP_TCC_INTEN_MASK              (0xFFFFFFFF)
+#define MDP_TCC_INTST_MASK              (0xFFFFFFFF)
+#define MDP_TCC_ST_MASK                 (0xFFFFFFFF)
+#define MDP_TCC_CROP_X_MASK             (0xFFFFFFFF)
+#define MDP_TCC_CROP_Y_MASK             (0xFFFFFFFF)
+#define MDP_TCC_IN_SIZE_MASK            (0xFFFFFFFF)
+#endif  /*__MDP_REG_TCC_H__*/
diff --git a/drivers/media/platform/mtk-mdp3/mdp_reg_tdshp.h b/drivers/media/platform/mtk-mdp3/mdp_reg_tdshp.h
new file mode 100644
index 0000000000000000000000000000000000000000..09eb46ff3adf73bba03496d1511a46f20aff98b0
--- /dev/null
+++ b/drivers/media/platform/mtk-mdp3/mdp_reg_tdshp.h
@@ -0,0 +1,377 @@
+#ifndef __MDP_REG_TDSHP_H__
+#define __MDP_REG_TDSHP_H__
+
+#include "mmsys_reg_base.h"
+
+#define MDP_TDSHP_00                 (0x000)
+#define MDP_TDSHP_01                 (0x004)
+#define MDP_TDSHP_02                 (0x008)
+#define MDP_TDSHP_03                 (0x00C)
+#define MDP_TDSHP_05                 (0x014)
+#define MDP_TDSHP_06                 (0x018)
+#define MDP_TDSHP_07                 (0x01C)
+#define MDP_TDSHP_08                 (0x020)
+#define MDP_TDSHP_09                 (0x024)
+#define MDP_PBC_00                   (0x040)
+#define MDP_PBC_01                   (0x044)
+#define MDP_PBC_02                   (0x048)
+#define MDP_PBC_03                   (0x04C)
+#define MDP_PBC_04                   (0x050)
+#define MDP_PBC_05                   (0x054)
+#define MDP_PBC_06                   (0x058)
+#define MDP_PBC_07                   (0x05C)
+#define MDP_PBC_08                   (0x060)
+#define MDP_HIST_CFG_00              (0x064)
+#define MDP_HIST_CFG_01              (0x068)
+#define MDP_LUMA_HIST_00             (0x06C)
+#define MDP_LUMA_HIST_01             (0x070)
+#define MDP_LUMA_HIST_02             (0x074)
+#define MDP_LUMA_HIST_03             (0x078)
+#define MDP_LUMA_HIST_04             (0x07C)
+#define MDP_LUMA_HIST_05             (0x080)
+#define MDP_LUMA_HIST_06             (0x084)
+#define MDP_LUMA_HIST_07             (0x08C)
+#define MDP_LUMA_HIST_08             (0x090)
+#define MDP_LUMA_HIST_09             (0x094)
+#define MDP_LUMA_HIST_10             (0x098)
+#define MDP_LUMA_HIST_11             (0x09C)
+#define MDP_LUMA_HIST_12             (0x0A0)
+#define MDP_LUMA_HIST_13             (0x0A4)
+#define MDP_LUMA_HIST_14             (0x0A8)
+#define MDP_LUMA_HIST_15             (0x0AC)
+#define MDP_LUMA_HIST_16             (0x0B0)
+#define MDP_LUMA_SUM                 (0x0B4)
+#define MDP_Y_FTN_1_0_MAIN           (0x0BC)
+#define MDP_Y_FTN_3_2_MAIN           (0x0C0)
+#define MDP_Y_FTN_5_4_MAIN           (0x0C4)
+#define MDP_Y_FTN_7_6_MAIN           (0x0C8)
+#define MDP_Y_FTN_9_8_MAIN           (0x0CC)
+#define MDP_Y_FTN_11_10_MAIN         (0x0D0)
+#define MDP_Y_FTN_13_12_MAIN         (0x0D4)
+#define MDP_Y_FTN_15_14_MAIN         (0x0D8)
+#define MDP_Y_FTN_17_16_MAIN         (0x0DC)
+#define MDP_C_BOOST_MAIN             (0x0E0)
+#define MDP_C_BOOST_MAIN_2           (0x0E4)
+#define MDP_TDSHP_C_BOOST_MAIN       (0x0E8)
+#define MDP_TDSHP_C_BOOST_MAIN_2     (0x0EC)
+#define MDP_TDSHP_ATPG               (0x0FC)
+#define MDP_TDSHP_CTRL               (0x100)
+#define MDP_TDSHP_INTEN              (0x104)
+#define MDP_TDSHP_INTSTA             (0x108)
+#define MDP_TDSHP_STATUS             (0x10C)
+#define MDP_TDSHP_CFG                (0x110)
+#define MDP_TDSHP_INPUT_COUNT        (0x114)
+#define MDP_TDSHP_CHKSUM             (0x118)
+#define MDP_TDSHP_OUTPUT_COUNT       (0x11C)
+#define MDP_TDSHP_INPUT_SIZE         (0x120)
+#define MDP_TDSHP_OUTPUT_OFFSET      (0x124)
+#define MDP_TDSHP_OUTPUT_SIZE        (0x128)
+#define MDP_TDSHP_BLANK_WIDTH        (0x12C)
+#define MDP_TDSHP_DEMO_HMASK         (0x130)
+#define MDP_TDSHP_DEMO_VMASK         (0x134)
+#define MDP_TDSHP_DUMMY_REG          (0x14C)
+#define MDP_LUMA_HIST_INIT_00        (0x200)
+#define MDP_LUMA_HIST_INIT_01        (0x204)
+#define MDP_LUMA_HIST_INIT_02        (0x208)
+#define MDP_LUMA_HIST_INIT_03        (0x20C)
+#define MDP_LUMA_HIST_INIT_04        (0x210)
+#define MDP_LUMA_HIST_INIT_05        (0x214)
+#define MDP_LUMA_HIST_INIT_06        (0x218)
+#define MDP_LUMA_HIST_INIT_07        (0x21C)
+#define MDP_LUMA_HIST_INIT_08        (0x220)
+#define MDP_LUMA_HIST_INIT_09        (0x224)
+#define MDP_LUMA_HIST_INIT_10        (0x228)
+#define MDP_LUMA_HIST_INIT_11        (0x22C)
+#define MDP_LUMA_HIST_INIT_12        (0x230)
+#define MDP_LUMA_HIST_INIT_13        (0x234)
+#define MDP_LUMA_HIST_INIT_14        (0x238)
+#define MDP_LUMA_HIST_INIT_15        (0x23C)
+#define MDP_LUMA_HIST_INIT_16        (0x240)
+#define MDP_LUMA_SUM_INIT            (0x244)
+#define MDP_DC_DBG_CFG_MAIN          (0x250)
+#define MDP_DC_WIN_X_MAIN            (0x254)
+#define MDP_DC_WIN_Y_MAIN            (0x258)
+#define MDP_DC_TWO_D_W1              (0x25C)
+#define MDP_DC_TWO_D_W1_RESULT_INIT  (0x260)
+#define MDP_DC_TWO_D_W1_RESULT       (0x264)
+#define MDP_EDF_GAIN_00              (0x300)
+#define MDP_EDF_GAIN_01              (0x304)
+#define MDP_EDF_GAIN_02              (0x308)
+#define MDP_EDF_GAIN_03              (0x30C)
+#define MDP_EDF_GAIN_04              (0x310)
+#define MDP_EDF_GAIN_05              (0x314)
+#define MDP_TDSHP_10                 (0x320)
+#define MDP_TDSHP_11                 (0x324)
+#define MDP_TDSHP_12                 (0x328)
+#define MDP_TDSHP_13                 (0x32C)
+#define PAT1_GEN_SET                 (0x330)
+#define PAT1_GEN_FRM_SIZE            (0x334)
+#define PAT1_GEN_COLOR0              (0x338)
+#define PAT1_GEN_COLOR1              (0x33C)
+#define PAT1_GEN_COLOR2              (0x340)
+#define PAT1_GEN_POS                 (0x344)
+#define PAT1_GEN_TILE_POS            (0x354)
+#define PAT1_GEN_TILE_OV             (0x358)
+#define PAT2_GEN_SET                 (0x360)
+#define PAT2_GEN_COLOR0              (0x368)
+#define PAT2_GEN_COLOR1              (0x36C)
+#define PAT2_GEN_POS                 (0x374)
+#define PAT2_GEN_CURSOR_RB0          (0x378)
+#define PAT2_GEN_CURSOR_RB1          (0x37C)
+#define PAT2_GEN_TILE_POS            (0x384)
+#define PAT2_GEN_TILE_OV             (0x388)
+#define MDP_BITPLUS_00               (0x38C)
+#define MDP_BITPLUS_01               (0x390)
+#define MDP_BITPLUS_02               (0x394)
+#define MDP_DC_SKIN_RANGE0           (0x420)
+#define MDP_CONTOUR_HIST_INIT_00     (0x398)
+#define MDP_CONTOUR_HIST_INIT_01     (0x39C)
+#define MDP_CONTOUR_HIST_INIT_02     (0x3A0)
+#define MDP_CONTOUR_HIST_INIT_03     (0x3A4)
+#define MDP_CONTOUR_HIST_INIT_04     (0x3A8)
+#define MDP_CONTOUR_HIST_INIT_05     (0x3AC)
+#define MDP_CONTOUR_HIST_INIT_06     (0x3B0)
+#define MDP_CONTOUR_HIST_INIT_07     (0x3B4)
+#define MDP_CONTOUR_HIST_INIT_08     (0x3B8)
+#define MDP_CONTOUR_HIST_INIT_09     (0x3BC)
+#define MDP_CONTOUR_HIST_INIT_10     (0x3C0)
+#define MDP_CONTOUR_HIST_INIT_11     (0x3C4)
+#define MDP_CONTOUR_HIST_INIT_12     (0x3C8)
+#define MDP_CONTOUR_HIST_INIT_13     (0x3CC)
+#define MDP_CONTOUR_HIST_INIT_14     (0x3D0)
+#define MDP_CONTOUR_HIST_INIT_15     (0x3D4)
+#define MDP_CONTOUR_HIST_INIT_16     (0x3D8)
+#define MDP_CONTOUR_HIST_00          (0x3DC)
+#define MDP_CONTOUR_HIST_01          (0x3E0)
+#define MDP_CONTOUR_HIST_02          (0x3E4)
+#define MDP_CONTOUR_HIST_03          (0x3E8)
+#define MDP_CONTOUR_HIST_04          (0x3EC)
+#define MDP_CONTOUR_HIST_05          (0x3F0)
+#define MDP_CONTOUR_HIST_06          (0x3F4)
+#define MDP_CONTOUR_HIST_07          (0x3F8)
+#define MDP_CONTOUR_HIST_08          (0x3FC)
+#define MDP_CONTOUR_HIST_09          (0x400)
+#define MDP_CONTOUR_HIST_10          (0x404)
+#define MDP_CONTOUR_HIST_11          (0x408)
+#define MDP_CONTOUR_HIST_12          (0x40C)
+#define MDP_CONTOUR_HIST_13          (0x410)
+#define MDP_CONTOUR_HIST_14          (0x414)
+#define MDP_CONTOUR_HIST_15          (0x418)
+#define MDP_CONTOUR_HIST_16          (0x41C)
+#define MDP_DC_SKIN_RANGE1           (0x424)
+#define MDP_DC_SKIN_RANGE2           (0x428)
+#define MDP_DC_SKIN_RANGE3           (0x42C)
+#define MDP_DC_SKIN_RANGE4           (0x430)
+#define MDP_DC_SKIN_RANGE5           (0x434)
+#define MDP_POST_YLEV_00             (0x480)
+#define MDP_POST_YLEV_01             (0x484)
+#define MDP_POST_YLEV_02             (0x488)
+#define MDP_POST_YLEV_03             (0x48C)
+#define MDP_POST_YLEV_04             (0x490)
+#define MDP_HFG_CTRL                 (0x500)
+#define MDP_HFG_RAN_0                (0x504)
+#define MDP_HFG_RAN_1                (0x508)
+#define MDP_HFG_RAN_2                (0x50C)
+#define MDP_HFG_RAN_3                (0x510)
+#define MDP_HFG_RAN_4                (0x514)
+#define MDP_HFG_CROP_X               (0x518)
+#define MDP_HFG_CROP_Y               (0x51C)
+#define MDP_HFC_CON_0                (0x524)
+#define MDP_HFC_LUMA_0               (0x528)
+#define MDP_HFC_LUMA_1               (0x52C)
+#define MDP_HFC_LUMA_2               (0x530)
+#define MDP_HFC_SL2_0                (0x534)
+#define MDP_HFC_SL2_1                (0x538)
+#define MDP_HFC_SL2_2                (0x53C)
+#define MDP_SL2_CEN                  (0x544)
+#define MDP_SL2_RR_CON0              (0x548)
+#define MDP_SL2_RR_CON1              (0x54C)
+#define MDP_SL2_GAIN                 (0x550)
+#define MDP_SL2_RZ                   (0x554)
+#define MDP_SL2_XOFF                 (0x558)
+#define MDP_SL2_YOFF                 (0x55C)
+#define MDP_SL2_SLP_CON0             (0x560)
+#define MDP_SL2_SLP_CON1             (0x564)
+#define MDP_SL2_SLP_CON2             (0x568)
+#define MDP_SL2_SLP_CON3             (0x66C)
+#define MDP_SL2_SIZE                 (0x670)
+#define MDP_HFG_OUTPUT_COUNT         (0x678)
+
+// MASK
+#define MDP_TDSHP_00_MASK               (0xF7FFFFFF)
+#define MDP_TDSHP_01_MASK               (0xFFFF0FFF)
+#define MDP_TDSHP_02_MASK               (0xFFFFFF00)
+#define MDP_TDSHP_03_MASK               (0x9FFF0F3F)
+#define MDP_TDSHP_05_MASK               (0xFFFFFFFF)
+#define MDP_TDSHP_06_MASK               (0xFFFFFFFF)
+#define MDP_TDSHP_07_MASK               (0xFFFFFFFF)
+#define MDP_TDSHP_08_MASK               (0xFFFFFFFF)
+#define MDP_TDSHP_09_MASK               (0xFF3F4000)
+#define MDP_PBC_00_MASK                 (0xFFFFFFFF)
+#define MDP_PBC_01_MASK                 (0xFFFFFFFF)
+#define MDP_PBC_02_MASK                 (0xFFCF7F3F)
+#define MDP_PBC_03_MASK                 (0xFFFFFFFF)
+#define MDP_PBC_04_MASK                 (0xFFFFFFFF)
+#define MDP_PBC_05_MASK                 (0xFFCF7F3F)
+#define MDP_PBC_06_MASK                 (0xFFFFFFFF)
+#define MDP_PBC_07_MASK                 (0xFFFFFFFF)
+#define MDP_PBC_08_MASK                 (0xFFCF7F3F)
+#define MDP_HIST_CFG_00_MASK            (0xFFFFFFFF)
+#define MDP_HIST_CFG_01_MASK            (0xFFFFFFFF)
+#define MDP_LUMA_HIST_00_MASK           (0x07FFFFFF)
+#define MDP_LUMA_HIST_01_MASK           (0x07FFFFFF)
+#define MDP_LUMA_HIST_02_MASK           (0x07FFFFFF)
+#define MDP_LUMA_HIST_03_MASK           (0x07FFFFFF)
+#define MDP_LUMA_HIST_04_MASK           (0x07FFFFFF)
+#define MDP_LUMA_HIST_05_MASK           (0x07FFFFFF)
+#define MDP_LUMA_HIST_06_MASK           (0x07FFFFFF)
+#define MDP_LUMA_HIST_07_MASK           (0x07FFFFFF)
+#define MDP_LUMA_HIST_08_MASK           (0x07FFFFFF)
+#define MDP_LUMA_HIST_09_MASK           (0x07FFFFFF)
+#define MDP_LUMA_HIST_10_MASK           (0x07FFFFFF)
+#define MDP_LUMA_HIST_11_MASK           (0x07FFFFFF)
+#define MDP_LUMA_HIST_12_MASK           (0x07FFFFFF)
+#define MDP_LUMA_HIST_13_MASK           (0x07FFFFFF)
+#define MDP_LUMA_HIST_14_MASK           (0x07FFFFFF)
+#define MDP_LUMA_HIST_15_MASK           (0x07FFFFFF)
+#define MDP_LUMA_HIST_16_MASK           (0x07FFFFFF)
+#define MDP_LUMA_SUM_MASK               (0xFFFFFFFF)
+#define MDP_Y_FTN_1_0_MAIN_MASK         (0x01FF01FF)
+#define MDP_Y_FTN_3_2_MAIN_MASK         (0x01FF01FF)
+#define MDP_Y_FTN_5_4_MAIN_MASK         (0x01FF01FF)
+#define MDP_Y_FTN_7_6_MAIN_MASK         (0x01FF01FF)
+#define MDP_Y_FTN_9_8_MAIN_MASK         (0x01FF01FF)
+#define MDP_Y_FTN_11_10_MAIN_MASK       (0x01FF01FF)
+#define MDP_Y_FTN_13_12_MAIN_MASK       (0x01FF01FF)
+#define MDP_Y_FTN_15_14_MAIN_MASK       (0x01FF01FF)
+#define MDP_Y_FTN_17_16_MAIN_MASK       (0x03FF)
+#define MDP_C_BOOST_MAIN_MASK           (0xFFFF20FF)
+#define MDP_C_BOOST_MAIN_2_MASK         (0xFF03007F)
+#define MDP_TDSHP_C_BOOST_MAIN_MASK     (0xFFFF20FF)
+#define MDP_TDSHP_C_BOOST_MAIN_2_MASK   (0xFF03007F)
+#define MDP_TDSHP_ATPG_MASK             (0x03)
+#define MDP_TDSHP_CTRL_MASK             (0x07)
+#define MDP_TDSHP_INTEN_MASK            (0x07)
+#define MDP_TDSHP_INTSTA_MASK           (0x07)
+#define MDP_TDSHP_STATUS_MASK           (0x0F3)
+#define MDP_TDSHP_CFG_MASK              (0x03F7)
+#define MDP_TDSHP_INPUT_COUNT_MASK      (0x1FFF1FFF)
+#define MDP_TDSHP_CHKSUM_MASK           (0xB0FFFFFF)
+#define MDP_TDSHP_OUTPUT_COUNT_MASK     (0x1FFF1FFF)
+#define MDP_TDSHP_INPUT_SIZE_MASK       (0x1FFF1FFF)
+#define MDP_TDSHP_OUTPUT_OFFSET_MASK    (0x0FF00FF)
+#define MDP_TDSHP_OUTPUT_SIZE_MASK      (0x1FFF1FFF)
+#define MDP_TDSHP_BLANK_WIDTH_MASK      (0x0FFFFFF)
+#define MDP_TDSHP_DEMO_HMASK_MASK       (0x1FFF1FFF)
+#define MDP_TDSHP_DEMO_VMASK_MASK       (0x1FFF1FFF)
+
+#define MDP_LUMA_HIST_INIT_00_MASK      (0x07FFFFFF)
+#define MDP_LUMA_HIST_INIT_01_MASK      (0x07FFFFFF)
+#define MDP_LUMA_HIST_INIT_02_MASK      (0x07FFFFFF)
+#define MDP_LUMA_HIST_INIT_03_MASK      (0x07FFFFFF)
+#define MDP_LUMA_HIST_INIT_04_MASK      (0x07FFFFFF)
+#define MDP_LUMA_HIST_INIT_05_MASK      (0x07FFFFFF)
+#define MDP_LUMA_HIST_INIT_06_MASK      (0x07FFFFFF)
+#define MDP_LUMA_HIST_INIT_07_MASK      (0x07FFFFFF)
+#define MDP_LUMA_HIST_INIT_08_MASK      (0x07FFFFFF)
+#define MDP_LUMA_HIST_INIT_09_MASK      (0x07FFFFFF)
+#define MDP_LUMA_HIST_INIT_10_MASK      (0x07FFFFFF)
+#define MDP_LUMA_HIST_INIT_11_MASK      (0x07FFFFFF)
+#define MDP_LUMA_HIST_INIT_12_MASK      (0x07FFFFFF)
+#define MDP_LUMA_HIST_INIT_13_MASK      (0x07FFFFFF)
+#define MDP_LUMA_HIST_INIT_14_MASK      (0x07FFFFFF)
+#define MDP_LUMA_HIST_INIT_15_MASK      (0x07FFFFFF)
+#define MDP_LUMA_HIST_INIT_16_MASK      (0x07FFFFFF)
+#define MDP_LUMA_SUM_INIT_MASK          (0xFFFFFFFF)
+/*MT6755 New feature*/
+#define MDP_DC_DBG_CFG_MAIN_MASK            (0x07)
+#define MDP_DC_WIN_X_MAIN_MASK              (0xFFFFFFFF)
+#define MDP_DC_WIN_Y_MAIN_MASK              (0xFFFFFFFF)
+#define MDP_DC_TWO_D_W1_MASK                (0xFFFFFFFF)
+#define MDP_DC_TWO_D_W1_RESULT_INIT_MASK    (0x007FFFFF)
+#define MDP_DC_TWO_D_W1_RESULT_MASK         (0x007FFFFF)
+/*MT6797 New feature*/
+#define MDP_EDF_GAIN_00_MASK                (0x9FFF1F07)
+#define MDP_EDF_GAIN_01_MASK                (0x7EFFFFFF)
+#define MDP_EDF_GAIN_02_MASK                (0x07071F1F)
+#define MDP_EDF_GAIN_03_MASK                (0x1F1F7F0F)
+#define MDP_EDF_GAIN_04_MASK                (0x3F1F1F00)
+#define MDP_EDF_GAIN_05_MASK                (0x00FFFFFF)
+#define MDP_TDSHP_10_MASK                   (0xFFFF000F)
+#define MDP_TDSHP_11_MASK                   (0xFFFFFFFF)
+#define MDP_TDSHP_12_MASK                   (0xFFFF000F)
+#define MDP_TDSHP_13_MASK                   (0xFFFFFFFF)
+#define PAT1_GEN_SET_MASK               (0x00FF00FD)
+#define PAT1_GEN_FRM_SIZE_MASK          (0x1FFF1FFF)
+#define PAT1_GEN_COLOR0_MASK            (0x03FF03FF)
+#define PAT1_GEN_COLOR1_MASK            (0x03FF03FF)
+#define PAT1_GEN_COLOR2_MASK            (0x03FF03FF)
+#define PAT1_GEN_POS_MASK               (0x1FFF1FFF)
+#define PAT1_GEN_TILE_POS_MASK          (0x1FFF1FFF)
+#define PAT1_GEN_TILE_OV_MASK           (0x0000FFFF)
+#define PAT2_GEN_SET_MASK               (0x00FF0003)
+#define PAT2_GEN_COLOR0_MASK            (0x03FF03FF)
+#define PAT2_GEN_COLOR1_MASK            (0x000003FF)
+#define PAT2_GEN_POS_MASK               (0x1FFF1FFF)
+#define PAT2_GEN_CURSOR_RB0_MASK        (0x03FF03FF)
+#define PAT2_GEN_CURSOR_RB1_MASK        (0x000003FF)
+#define PAT2_GEN_TILE_POS_MASK          (0x1FFF1FFF)
+#define PAT2_GEN_TILE_OV_MASK           (0x0000FFFF)
+
+#define MDP_BITPLUS_01_MASK             (0x03FFFFFF)
+#define MDP_BITPLUS_02_MASK             (0x03FFFFFF)
+#define MDP_DC_SKIN_RANGE0_MASK         (0x003FFFFF)
+
+#define MDP_CONTOUR_HIST_INIT_00_MASK      (0x07FFFFFF)
+#define MDP_CONTOUR_HIST_INIT_01_MASK      (0x07FFFFFF)
+#define MDP_CONTOUR_HIST_INIT_02_MASK      (0x07FFFFFF)
+#define MDP_CONTOUR_HIST_INIT_03_MASK      (0x07FFFFFF)
+#define MDP_CONTOUR_HIST_INIT_04_MASK      (0x07FFFFFF)
+#define MDP_CONTOUR_HIST_INIT_05_MASK      (0x07FFFFFF)
+#define MDP_CONTOUR_HIST_INIT_06_MASK      (0x07FFFFFF)
+#define MDP_CONTOUR_HIST_INIT_07_MASK      (0x07FFFFFF)
+#define MDP_CONTOUR_HIST_INIT_08_MASK      (0x07FFFFFF)
+#define MDP_CONTOUR_HIST_INIT_09_MASK      (0x07FFFFFF)
+#define MDP_CONTOUR_HIST_INIT_10_MASK      (0x07FFFFFF)
+#define MDP_CONTOUR_HIST_INIT_11_MASK      (0x07FFFFFF)
+#define MDP_CONTOUR_HIST_INIT_12_MASK      (0x07FFFFFF)
+#define MDP_CONTOUR_HIST_INIT_13_MASK      (0x07FFFFFF)
+#define MDP_CONTOUR_HIST_INIT_14_MASK      (0x07FFFFFF)
+#define MDP_CONTOUR_HIST_INIT_15_MASK      (0x07FFFFFF)
+#define MDP_CONTOUR_HIST_INIT_16_MASK      (0x07FFFFFF)
+#define MDP_POST_YLEV_00_MASK              (0xFFFFFFFF)
+#define MDP_POST_YLEV_01_MASK              (0xFFFFFFFF)
+#define MDP_POST_YLEV_02_MASK              (0xFFFFFFFF)
+#define MDP_POST_YLEV_03_MASK              (0xFFFFFFFF)
+#define MDP_POST_YLEV_04_MASK              (0xFF3F4000)
+
+#define MDP_HFG_CTRL_MASK                  (0x303)
+#define MDP_HFG_RAN_0_MASK                 (0xFFFFFFFF)
+#define MDP_HFG_RAN_1_MASK                 (0xFFFFFFFF)
+#define MDP_HFG_RAN_2_MASK                 (0xFFFFFFFF)
+#define MDP_HFG_RAN_3_MASK                 (0xFFFF)
+#define MDP_HFG_RAN_4_MASK                 (0xFFFFFFFF)
+#define MDP_HFG_CROP_X_MASK                (0xFFFFFFFF)
+#define MDP_HFG_CROP_Y_MASK                (0xFFFFFFFF)
+#define MDP_HFC_CON_0_MASK                 (0xFF)
+#define MDP_HFC_LUMA_0_MASK                (0xFFFFFF)
+#define MDP_HFC_LUMA_1_MASK                (0x3F3F3F3F)
+#define MDP_HFC_LUMA_2_MASK                (0x1F1F1F1F)
+#define MDP_HFC_SL2_0_MASK                 (0x1FFFFFF)
+#define MDP_HFC_SL2_1_MASK                 (0x3F3F3F3F)
+#define MDP_HFC_SL2_2_MASK                 (0x1F1F1F1F)
+#define MDP_SL2_CEN_MASK                   (0x1FFF1FFF)
+#define MDP_SL2_RR_CON0_MASK               (0x1FFF1FFF)
+#define MDP_SL2_RR_CON1_MASK               (0xFFFF3FFF)
+#define MDP_SL2_GAIN_MASK                  (0x1FFFFFF)
+#define MDP_SL2_RZ_MASK                    (0x3FFF3FFF)
+#define MDP_SL2_XOFF_MASK                  (0xFFFFFFF)
+#define MDP_SL2_YOFF_MASK                  (0xFFFFFFF)
+#define MDP_SL2_SLP_CON0_MASK              (0xFFFFFF)
+#define MDP_SL2_SLP_CON1_MASK              (0xFFFFFF)
+#define MDP_SL2_SLP_CON2_MASK              (0xFFFFFF)
+#define MDP_SL2_SLP_CON3_MASK              (0xFFFFFF)
+#define MDP_SL2_SIZE_MASK                  (0x3FFF3FFF)
+#define MDP_HFG_OUTPUT_COUNT_MASK          (0x1FFF1FFF)
+
+#endif  // __MDP_REG_TDSHP_H__
diff --git a/drivers/media/platform/mtk-mdp3/mdp_reg_wrot.h b/drivers/media/platform/mtk-mdp3/mdp_reg_wrot.h
index b757a288267d7907e32b098d98e7805c61a2eb9f..6cda7d24247c852c1e2fb9a3164d3bb7c4398a64 100644
--- a/drivers/media/platform/mtk-mdp3/mdp_reg_wrot.h
+++ b/drivers/media/platform/mtk-mdp3/mdp_reg_wrot.h
@@ -9,107 +9,105 @@
 
 #include "mmsys_reg_base.h"
 
-#define VIDO_CTRL                   0x000
-#define VIDO_DMA_PERF               0x004
-#define VIDO_MAIN_BUF_SIZE          0x008
-#define VIDO_SOFT_RST               0x010
-#define VIDO_SOFT_RST_STAT          0x014
-#define VIDO_INT_EN                 0x018
-#define VIDO_INT                    0x01c
-#define VIDO_CROP_OFST              0x020
-#define VIDO_TAR_SIZE               0x024
-#define VIDO_BASE_ADDR              0xf00
-#define VIDO_OFST_ADDR              0x02c
-#define VIDO_STRIDE                 0x030
-#define VIDO_BASE_ADDR_C            0xf04
-#define VIDO_OFST_ADDR_C            0x038
-#define VIDO_STRIDE_C               0x03c
-#define VIDO_DITHER                 0x054
-#define VIDO_BASE_ADDR_V            0xf08
-#define VIDO_OFST_ADDR_V            0x068
-#define VIDO_STRIDE_V               0x06c
-#define VIDO_RSV_1                  0x070
-#define VIDO_DMA_PREULTRA           0x074
-#define VIDO_IN_SIZE                0x078
-#define VIDO_ROT_EN                 0x07c
-#define VIDO_FIFO_TEST              0x080
-#define VIDO_MAT_CTRL               0x084
-#define VIDO_MAT_RMY                0x088
-#define VIDO_MAT_RMV                0x08c
-#define VIDO_MAT_GMY                0x090
-#define VIDO_MAT_BMY                0x094
-#define VIDO_MAT_BMV                0x098
-#define VIDO_MAT_PREADD             0x09c
-#define VIDO_MAT_POSTADD            0x0a0
-#define VIDO_DITHER_00              0x0a4
-#define VIDO_DITHER_02              0x0ac
-#define VIDO_DITHER_03              0x0b0
-#define VIDO_DITHER_04              0x0b4
-#define VIDO_DITHER_05              0x0b8
-#define VIDO_DITHER_06              0x0bc
-#define VIDO_DITHER_07              0x0c0
-#define VIDO_DITHER_08              0x0c4
-#define VIDO_DITHER_09              0x0c8
-#define VIDO_DITHER_10              0x0cc
-#define VIDO_DEBUG                  0x0d0
-#define VIDO_ARB_SW_CTL             0x0d4
-#define MDP_WROT_TRACK_CTL          0x0e0
-#define MDP_WROT_TRACK_WINDOW       0x0e4
-#define MDP_WROT_TRACK_TARGET       0x0e8
-#define MDP_WROT_TRACK_STOP         0x0ec
-#define MDP_WROT_TRACK_PROC_CNT0    0x0f0
-#define MDP_WROT_TRACK_PROC_CNT1    0x0f4
+#define VIDO_CTRL                    (0x000)
+#define VIDO_DMA_PERF                (0x004)
+#define VIDO_MAIN_BUF_SIZE           (0x008)
+#define VIDO_SOFT_RST                (0x010)
+#define VIDO_SOFT_RST_STAT           (0x014)
+#define VIDO_INT_EN                  (0x018)
+#define VIDO_INT                     (0x01c)
+#define VIDO_CROP_OFST               (0x020)
+#define VIDO_TAR_SIZE                (0x024)
+#define VIDO_BASE_ADDR               (0xF00)
+#define VIDO_OFST_ADDR               (0x02c)
+#define VIDO_STRIDE                  (0x030)
+#define VIDO_BASE_ADDR_C             (0xF04)
+#define VIDO_OFST_ADDR_C             (0x038)
+#define VIDO_STRIDE_C                (0x03c)
+#define VIDO_DITHER                  (0x054)
+#define VIDO_BASE_ADDR_V             (0xF08)
+#define VIDO_OFST_ADDR_V             (0x068)
+#define VIDO_STRIDE_V                (0x06c)
+#define VIDO_RSV_1                   (0x070)
+#define VIDO_DMA_PREULTRA            (0x074)
+#define VIDO_IN_SIZE                 (0x078)
+#define VIDO_ROT_EN                  (0x07c)
+#define VIDO_FIFO_TEST               (0x080)
+#define VIDO_MAT_CTRL                (0x084)
+#define VIDO_DEBUG                   (0x0D0)
+#define VIDO_ARB_SW_CTL              (0x0D4)
+#define VIDO_CRC_CTRL                (0x0E8)
+#define VIDO_CRC_VALUE               (0x0EC)
+#define VIDO_FRAME_SIZE              (0x028)
+#define VIDO_BKGD                    (0x034)
+#define VIDO_ISSUE_REQ_TH            (0x040)
+#define VIDO_GROUP_REQ_TH            (0x044)
+#define VIDO_CTRL_2                  (0x048)
+#define VIDO_IN_LINE_ROT             (0x050)
+#define VIDO_PVRIC                   (0x0D8)
+#define VIDO_SCAN_10BIT              (0x0DC)
+#define VIDO_PENDING_ZERO            (0x0E0)
+#define VIDO_PVRIC_SETTING           (0x0E4)
+#define VIDO_PVRIC_FMT               (0xF0c)
+#define VIDO_FBC_FBDC_CR_CH0123_VAL0 (0xF10)
+#define VIDO_FBC_FBDC_CR_CH0123_VAL1 (0xF14)
+#define VIDO_FBC_FBDC_CR_Y_VAL0      (0xF18)
+#define VIDO_FBC_FBDC_CR_UV_VAL0     (0xF1c)
+#define VIDO_FBC_FBDC_CR_Y_VAL1      (0xF20)
+#define VIDO_FBC_FBDC_CR_UV_VAL1     (0xF24)
+#define VIDO_AFBC_VERSION            (0xF28)
+#define VIDO_AFBC_YUVTRANS           (0xF2C)
+#define VIDO_BUS_CTRL                (0xF30)
 
 /* MASK */
-#define VIDO_CTRL_MASK                  0xf530711f
-#define VIDO_DMA_PERF_MASK              0x3fffffff
-#define VIDO_MAIN_BUF_SIZE_MASK         0x1fff7f77
-#define VIDO_SOFT_RST_MASK              0x00000001
-#define VIDO_SOFT_RST_STAT_MASK         0x00000001
-#define VIDO_INT_EN_MASK                0x00003f07
-#define VIDO_INT_MASK                   0x00000007
-#define VIDO_CROP_OFST_MASK             0x1fff1fff
-#define VIDO_TAR_SIZE_MASK              0x1fff1fff
-#define VIDO_BASE_ADDR_MASK             0xffffffff
-#define VIDO_OFST_ADDR_MASK             0x0fffffff
-#define VIDO_STRIDE_MASK                0x0000ffff
-#define VIDO_BASE_ADDR_C_MASK           0xffffffff
-#define VIDO_OFST_ADDR_C_MASK           0x0fffffff
-#define VIDO_STRIDE_C_MASK              0x0000ffff
-#define VIDO_DITHER_MASK                0xff000001
-#define VIDO_BASE_ADDR_V_MASK           0xffffffff
-#define VIDO_OFST_ADDR_V_MASK           0x0fffffff
-#define VIDO_STRIDE_V_MASK              0x0000ffff
-#define VIDO_RSV_1_MASK                 0xffffffff
-#define VIDO_DMA_PREULTRA_MASK          0x00ffffff
-#define VIDO_IN_SIZE_MASK               0x1fff1fff
-#define VIDO_ROT_EN_MASK                0x00000001
-#define VIDO_FIFO_TEST_MASK             0x00000fff
-#define VIDO_MAT_CTRL_MASK              0x000000f3
-#define VIDO_MAT_RMY_MASK               0x1fff1fff
-#define VIDO_MAT_RMV_MASK               0x1fff1fff
-#define VIDO_MAT_GMY_MASK               0x1fff1fff
-#define VIDO_MAT_BMY_MASK               0x1fff1fff
-#define VIDO_MAT_BMV_MASK               0x00001fff
-#define VIDO_MAT_PREADD_MASK            0x1ff7fdff
-#define VIDO_MAT_POSTADD_MASK           0x1ff7fdff
-#define VIDO_DITHER_00_MASK             0x0000ff3f
-#define VIDO_DITHER_02_MASK             0xffff3fff
-#define VIDO_DITHER_03_MASK             0x0000003f
-#define VIDO_DITHER_04_MASK             0xbfffffff
-#define VIDO_DITHER_05_MASK             0xffff7fff
-#define VIDO_DITHER_06_MASK             0x003ff773
-#define VIDO_DITHER_07_MASK             0x00007777
-#define VIDO_DITHER_08_MASK             0x00007777
-#define VIDO_DITHER_09_MASK             0x00007777
-#define VIDO_DITHER_10_MASK             0x0001ffff
-#define VIDO_DEBUG_MASK                 0xffffffff
-#define VIDO_ARB_SW_CTL_MASK            0x00000007
-#define MDP_WROT_TRACK_CTL_MASK         0x0000001f
-#define MDP_WROT_TRACK_WINDOW_MASK      0x00000fff
-#define MDP_WROT_TRACK_TARGET_MASK      0x00ffffff
-#define MDP_WROT_TRACK_STOP_MASK        0x00ffffff
-#define MDP_WROT_TRACK_PROC_CNT0_MASK   0xffffffff
-#define MDP_WROT_TRACK_PROC_CNT1_MASK   0x00000001
+#define VIDO_CTRL_MASK                    (0xF531712F)
+#define VIDO_DMA_PERF_MASK                (0x3FFFFFFF)
+#define VIDO_MAIN_BUF_SIZE_MASK           (0x1FFF7F77)
+#define VIDO_SOFT_RST_MASK                (0x01)
+#define VIDO_SOFT_RST_STAT_MASK           (0x01)
+#define VIDO_INT_EN_MASK                  (0x03F07)
+#define VIDO_INT_MASK                     (0x07)
+#define VIDO_CROP_OFST_MASK               (0x1FFF1FFF)
+#define VIDO_TAR_SIZE_MASK                (0x1FFF1FFF)
+#define VIDO_BASE_ADDR_MASK               (0xFFFFFFFF)
+#define VIDO_OFST_ADDR_MASK               (0x0FFFFFFF)
+#define VIDO_STRIDE_MASK                  (0x0FFFF)
+#define VIDO_BASE_ADDR_C_MASK             (0xFFFFFFFF)
+#define VIDO_OFST_ADDR_C_MASK             (0x0FFFFFFF)
+#define VIDO_STRIDE_C_MASK                (0x0FFFF)
+#define VIDO_DITHER_MASK                  (0xFF000000)
+#define VIDO_BASE_ADDR_V_MASK             (0xFFFFFFFF)
+#define VIDO_OFST_ADDR_V_MASK             (0x0FFFFFFF)
+#define VIDO_STRIDE_V_MASK                (0x0FFFF)
+#define VIDO_RSV_1_MASK                   (0xFFFFFFFF)
+#define VIDO_DMA_PREULTRA_MASK            (0x0FFFFFF)
+#define VIDO_IN_SIZE_MASK                 (0x1FFF1FFF)
+#define VIDO_ROT_EN_MASK                  (0xFFFF007F)
+#define VIDO_FIFO_TEST_MASK               (0x0FFF)
+#define VIDO_MAT_CTRL_MASK                (0x0F1)
+#define VIDO_DEBUG_MASK                   (0xFFFFFFFF)
+#define VIDO_ARB_SW_CTL_MASK              (0x07)
+#define VIDO_CRC_CTRL_MASK                (0x0F)
+#define VIDO_CRC_VALUE_MASK               (0xFFFFFFFF)
+#define VIDO_FRAME_SIZE_MASK              (0xFFFFFFFF)
+#define VIDO_BKGD_MASK                    (0xFFFFFFFF)
+#define VIDO_ISSUE_REQ_TH_MASK            (0x0FFFFFF)
+#define VIDO_GROUP_REQ_TH_MASK            (0x0FFFFFF)
+#define VIDO_CTRL_2_MASK                  (0x0F)
+#define VIDO_IN_LINE_ROT_MASK             (0x03)
+#define VIDO_PVRIC_MASK                   (0x03)
+#define VIDO_SCAN_10BIT_MASK              (0x0F)
+#define VIDO_PENDING_ZERO_MASK            (0x07FFFFFF)
+#define VIDO_PVRIC_SETTING_MASK           (0x03F)
+#define VIDO_PVRIC_FMT_MASK               (0x0FF)
+#define VIDO_FBC_FBDC_CR_CH0123_VAL0_MASK (0xFFFFFFFF)
+#define VIDO_FBC_FBDC_CR_CH0123_VAL1_MASK (0xFFFFFFFF)
+#define VIDO_FBC_FBDC_CR_Y_VAL0_MASK      (0x03FF)
+#define VIDO_FBC_FBDC_CR_UV_VAL0_MASK     (0x03FF)
+#define VIDO_FBC_FBDC_CR_Y_VAL1_MASK      (0x03FF)
+#define VIDO_FBC_FBDC_CR_UV_VAL1_MASK     (0x03FF)
+#define VIDO_AFBC_VERSION_MASK            (0xFFFFFFFF)
+#define VIDO_AFBC_YUVTRANS_MASK           (0x01)
+#define VIDO_BUS_CTRL_MASK                (0xFFFFFFFF)
 
 #endif  // __MDP_REG_WROT_H__
diff --git a/drivers/media/platform/mtk-mdp3/mmsys_config.h b/drivers/media/platform/mtk-mdp3/mmsys_config.h
index 5cdfb864dadf289303bcb0e6a4c6a3cc75f68cb0..8a6d0121af68693608d00c74a171e9b2b4308212 100644
--- a/drivers/media/platform/mtk-mdp3/mmsys_config.h
+++ b/drivers/media/platform/mtk-mdp3/mmsys_config.h
@@ -8,181 +8,7 @@
 #define __MMSYS_CONFIG_H__
 
 #include "mmsys_reg_base.h"
-
-#define MMSYS_INTEN                   0x000
-#define MMSYS_INTSTA                  0x004
-#define MJC_APB_TX_CON                0x00c
-
-#define ISP_MOUT_EN                   0xf80
-#define MDP_RDMA0_MOUT_EN             0xf84
-#define MDP_RDMA1_MOUT_EN             0xf88
-#define MDP_PRZ0_MOUT_EN              0xf8c
-#define MDP_PRZ1_MOUT_EN              0xf90
-#define MDP_COLOR_MOUT_EN             0xf94
-#define IPU_MOUT_EN                   0xf98
-#define DISP_TO_WROT_SOUT_SEL         0xfa0
-#define MDP_COLOR_IN_SOUT_SEL         0xfa4
-#define MDP_PATH0_SOUT_SEL            0xfa8
-#define MDP_PATH1_SOUT_SEL            0xfac
-#define MDP_TDSHP_SOUT_SEL            0xfb0
-
-#define DISP_OVL0_MOUT_EN             0xf00
-#define DISP_OVL0_2L_MOUT_EN          0xf04
-#define DISP_OVL1_2L_MOUT_EN          0xf08
-#define DISP_DITHER0_MOUT_EN          0xf0c
-#define DISP_RSZ_MOUT_EN              0xf10
-
-#define MMSYS_MOUT_RST                0x048
-#define MDP_PRZ0_SEL_IN               0xfc0
-#define MDP_PRZ1_SEL_IN               0xfc4
-#define MDP_TDSHP_SEL_IN              0xfc8
-#define DISP_WDMA0_SEL_IN             0xfcc
-#define MDP_WROT0_SEL_IN              0xfd0
-#define MDP_WDMA_SEL_IN               0xfd4
-#define MDP_COLOR_OUT_SEL_IN          0xfd8
-#define MDP_COLOR_SEL_IN              0xfdc
-#define MDP_PATH0_SEL_IN              0xfe0
-#define MDP_PATH1_SEL_IN              0xfe4
-
-#define DISP_COLOR_OUT_SEL_IN         0xf20
-#define DISP_PATH0_SEL_IN             0xf24
-#define DISP_WDMA0_PRE_SEL_IN         0xf28
-#define DSI0_SEL_IN                   0xf2c
-#define DSI1_SEL_IN                   0xf30
-#define DISP_OVL0_SEL_IN              0xf34
-#define DISP_OVL0_2L_SEL_IN           0xf38
-#define OVL_TO_RSZ_SEL_IN             0xf3c
-#define OVL_TO_WDMA_SEL_IN            0xf40
-#define OVL_TO_WROT_SEL_IN            0xf44
-#define DISP_RSZ_SEL_IN               0xf48
-#define DISP_RDMA0_SOUT_SEL_IN        0xf50
-#define DISP_RDMA1_SOUT_SEL_IN        0xf54
-#define MDP_TO_DISP0_SOUT_SEL_IN      0xf58
-#define MDP_TO_DISP1_SOUT_SEL_IN      0xf5c
-#define DISP_RDMA0_RSZ_IN_SOUT_SEL_IN 0xf60
-#define DISP_RDMA0_RSZ_OUT_SEL_IN     0xf64
-#define MDP_AAL_MOUT_EN               0xfe8
-#define MDP_AAL_SEL_IN                0xfec
-#define MDP_CCORR_SEL_IN              0xff0
-#define MDP_CCORR_SOUT_SEL            0xff4
-
-#define MMSYS_MISC                    0x0f0
-#define MMSYS_SMI_LARB_SEL            0x0f4
-#define MMSYS_SODI_REQ_MASK           0x0f8
-#define MMSYS_CG_CON0                 0x100
-#define MMSYS_CG_SET0                 0x104
-#define MMSYS_CG_CLR0                 0x108
-#define MMSYS_CG_CON1                 0x110
-#define MMSYS_CG_SET1                 0x114
-#define MMSYS_CG_CLR1                 0x118
-#define MMSYS_HW_DCM_DIS0             0x120
-#define MMSYS_HW_DCM_DIS_SET0         0x124
-#define MMSYS_HW_DCM_DIS_CLR0         0x128
-#define MMSYS_HW_DCM_DIS1             0x130
-#define MMSYS_HW_DCM_DIS_SET1         0x134
-#define MMSYS_HW_DCM_DIS_CLR1         0x138
-#define MMSYS_HW_DCM_EVENT_CTL1       0x13c
-#define MMSYS_SW0_RST_B               0x140
-#define MMSYS_SW1_RST_B               0x144
-#define MMSYS_LCM_RST_B               0x150
-#define LARB6_AXI_ASIF_CFG_WD         0x180
-#define LARB6_AXI_ASIF_CFG_RD         0x184
-#define PROC_TRACK_EMI_BUSY_CON       0x190
-#define DISP_FAKE_ENG_EN              0x200
-#define DISP_FAKE_ENG_RST             0x204
-#define DISP_FAKE_ENG_CON0            0x208
-#define DISP_FAKE_ENG_CON1            0x20c
-#define DISP_FAKE_ENG_RD_ADDR         0x210
-#define DISP_FAKE_ENG_WR_ADDR         0x214
-#define DISP_FAKE_ENG_STATE           0x218
-#define DISP_FAKE_ENG2_EN             0x220
-#define DISP_FAKE_ENG2_RST            0x224
-#define DISP_FAKE_ENG2_CON0           0x228
-#define DISP_FAKE_ENG2_CON1           0x22c
-#define DISP_FAKE_ENG2_RD_ADDR        0x230
-#define DISP_FAKE_ENG2_WR_ADDR        0x234
-#define DISP_FAKE_ENG2_STATE          0x238
-#define MMSYS_MBIST_CON               0x800
-#define MMSYS_MBIST_DONE              0x804
-#define MMSYS_MBIST_HOLDB             0x808
-#define MMSYS_MBIST_MODE              0x80c
-#define MMSYS_MBIST_FAIL0             0x810
-#define MMSYS_MBIST_FAIL1             0x814
-#define MMSYS_MBIST_FAIL2             0x818
-#define MMSYS_MBIST_DEBUG             0x820
-#define MMSYS_MBIST_DIAG_SCANOUT      0x824
-#define MMSYS_MBIST_PRE_FUSE          0x828
-#define MMSYS_MBIST_BSEL0             0x82c
-#define MMSYS_MBIST_BSEL1             0x830
-#define MMSYS_MBIST_BSEL2             0x834
-#define MMSYS_MBIST_BSEL3             0x838
-#define MMSYS_MBIST_HDEN              0x83c
-#define MDP_RDMA0_MEM_DELSEL          0x840
-#define MDP_RDMA1_MEM_DELSEL          0x844
-#define MDP_RSZ_MEM_DELSEL            0x848
-#define MDP_TDSHP_MEM_DELSEL          0x84c
-#define MDP_AAL_MEM_DELSEL            0x850
-
-#define MDP_WROT0_MEM_DELSEL          0x854
-#define MDP_WDMA_MEM_DELSEL           0x858
-#define DISP_OVL_MEM_DELSEL           0x85c
-#define DISP_OVL_2L_MEM_DELSEL        0x860
-#define DISP_RDMA_MEM_DELSEL          0x864
-#define DISP_WDMA0_MEM_DELSEL         0x868
-#define DISP_GAMMA_MEM_DELSEL         0x870
-#define DSI_MEM_DELSEL                0x874
-#define DISP_SPLIT_MEM_DELSEL         0x878
-#define DISP_DSC_MEM_DELSEL           0x87c
-#define MMSYS_DEBUG_OUT_SEL           0x88c
-#define MMSYS_MBIST_RP_RST_B          0x890
-#define MMSYS_MBIST_RP_FAIL0          0x894
-#define MMSYS_MBIST_RP_FAIL1          0x898
-#define MMSYS_MBIST_RP_OK0            0x89c
-#define MMSYS_MBIST_RP_OK1            0x8a0
-#define MMSYS_DUMMY0                  0x8a4
-#define MMSYS_DUMMY1                  0x8a8
-#define MMSYS_DUMMY2                  0x8ac
-#define MMSYS_DUMMY3                  0x8b0
-#define DISP_DL_VALID_0               0x8b4
-#define DISP_DL_VALID_1               0x8b8
-#define DISP_DL_VALID_2               0x8bc
-#define DISP_DL_READY_0               0x8c0
-#define DISP_DL_READY_1               0x8c4
-#define DISP_DL_READY_2               0x8C8
-#define MDP_DL_VALID_0                0x8cc
-#define MDP_DL_VALID_1                0x8d0
-#define MDP_DL_READY_0                0x8d4
-#define MDP_DL_READY_1                0x8d8
-#define SMI_LARB0_GREQ                0x8dc
-#define DISP_MOUT_MASK                0x8e0
-#define DISP_MOUT_MASK1               0x8e4
-#define MDP_MOUT_MASK                 0x8e8
-#define MMSYS_POWER_READ              0x8ec
-#define TOP_RELAY_FSM_RD              0x960
-#define MDP_ASYNC_CFG_WD              0x934
-#define MDP_ASYNC_CFG_RD              0x938
-#define MDP_ASYNC_IPU_CFG_WD          0x93C
-#define MDP_ASYNC_CFG_IPU_RD          0x940
-#define MDP_ASYNC_CFG_OUT_RD          0x958
-#define MDP_ASYNC_IPU_CFG_OUT_RD      0x95C
-#define ISP_RELAY_CFG_WD              0x994
-#define ISP_RELAY_CNT_RD              0x998
-#define ISP_RELAY_CNT_LATCH_RD        0x99c
-#define IPU_RELAY_CFG_WD              0x9a0
-#define IPU_RELAY_CNT_RD              0x9a4
-#define IPU_RELAY_CNT_LATCH_RD        0x9a8
-
-/* MASK */
-#define MMSYS_SW0_RST_B_MASK          0xffffffff
-#define MMSYS_SW1_RST_B_MASK          0xffffffff
-#define MDP_COLOR_IN_SOUT_SEL_MASK    0x0000000f
-#define DISP_COLOR_OUT_SEL_IN_MASK    0xffffffff
-#define MDP_ASYNC_CFG_WD_MASK         0xffffffff
-#define MDP_ASYNC_IPU_CFG_WD_MASK     0xffffffff
-#define MMSYS_HW_DCM_DIS0_MASK        0xffffffff
-#define MMSYS_HW_DCM_DIS1_MASK        0xffffffff
-#define MDP_ASYNC_CFG_WD_MASK         0xffffffff
-#define ISP_RELAY_CFG_WD_MASK         0xffffffff
-#define IPU_RELAY_CFG_WD_MASK         0xffffffff
+#include "vppsys0_config.h"
+#include "vppsys1_config.h"
 
 #endif  // __MMSYS_CONFIG_H__
diff --git a/drivers/media/platform/mtk-mdp3/mmsys_mutex.h b/drivers/media/platform/mtk-mdp3/mmsys_mutex.h
index fb8c179f11af3e06e6ee908a60a9c3174b31f5eb..a86bb3ebf4f08a2d646660bbbabfbb61e3af70da 100644
--- a/drivers/media/platform/mtk-mdp3/mmsys_mutex.h
+++ b/drivers/media/platform/mtk-mdp3/mmsys_mutex.h
@@ -18,8 +18,12 @@
 #define MM_MUTEX_GET                (0x24 + mutex_id * 0x20)
 #define MM_MUTEX_RST                (0x28 + mutex_id * 0x20)
 #define MM_MUTEX_MOD                (MM_MUTEX_MOD_OFFSET + mutex_id * 0x20)
+#define MM_MUTEX_MOD1               (MM_MUTEX_MOD + 0x4)
 #define MM_MUTEX_SOF                (MM_MUTEX_SOF_OFFSET + mutex_id * 0x20)
 
+#define MM_MUTEX_CTL_SOF_SHIFT 		(0)
+#define MM_MUTEX_CTL_EOF_SHIFT 		(7)
+
 // MASK
 #define MM_MUTEX_INTEN_MASK         0x0fff
 #define MM_MUTEX_INTSTA_MASK        0x0fff
@@ -29,7 +33,39 @@
 #define MM_MUTEX_EN_MASK            0x01
 #define MM_MUTEX_GET_MASK           0x03
 #define MM_MUTEX_RST_MASK           0x01
-#define MM_MUTEX_MOD_MASK           0x07ffffff
+#define MM_MUTEX_MOD_MASK           0x0fffffff
+#define MM_MUTEX_MOD1_MASK          0x0fffffff
 #define MM_MUTEX_SOF_MASK           0x0f
 
+
+#define VPP_MUTEX_INTEN_OFFSET  (0x00)
+#define VPP_MUTEX_INTSTA_OFFSET (0x04)
+#define VPP_MUTEX_CFG_OFFSET    (0x08)
+#define VPP_MUTEX_EN_OFFSET     (0x20)
+#define VPP_MUTEX_RST_OFFSET    (0x28)
+#define VPP_MUTEX_CTL_OFFSET    (0x2C)
+#define VPP_MUTEX_MOD0_OFFSET   (0x30)
+#define VPP_MUTEX_MOD1_OFFSET   (0x34)
+#define VPP_MUTEX_CTL_SOF_SHIFT (0)
+#define VPP_MUTEX_CTL_EOF_SHIFT (7)
+
+#define VPP_MUTEX_INTEN              (VPP_MUTEX_INTEN_OFFSET)
+#define VPP_MUTEX_INTSTA             (VPP_MUTEX_INTSTA_OFFSET)
+#define VPP_MUTEX_CFG                (VPP_MUTEX_CFG_OFFSET)
+#define VPP_MUTEX_EN                 (VPP_MUTEX_EN_OFFSET + mutex2_id * 0x20)
+#define VPP_MUTEX_RST                (VPP_MUTEX_RST_OFFSET + mutex2_id * 0x20)
+#define VPP_MUTEX_SOF                (VPP_MUTEX_CTL_OFFSET + mutex2_id * 0x20)
+#define VPP_MUTEX_MOD                (VPP_MUTEX_MOD0_OFFSET + mutex2_id * 0x20)
+#define VPP_MUTEX_MOD1               (VPP_MUTEX_MOD1_OFFSET + mutex2_id * 0x20)
+
+#define VPP_MUTEX_INTEN_MASK         (0x0FFF)
+#define VPP_MUTEX_INTSTA_MASK        (0x0FFF)
+#define VPP_MUTEX_CFG_MASK           (0x01)
+#define VPP_MUTEX_EN_MASK            (0x01)
+#define VPP_MUTEX_GET_MASK           (0x03)
+#define VPP_MUTEX_RST_MASK           (0x01)
+#define VPP_MUTEX_SOF_MASK           (0x78F)
+#define VPP_MUTEX_MOD_MASK           (0x0FFFFFFF)
+#define VPP_MUTEX_MOD1_MASK          (0x0FFFFFFF)
+
 #endif  // __MMSYS_MUTEX_H__
diff --git a/drivers/media/platform/mtk-mdp3/mmsys_reg_base.h b/drivers/media/platform/mtk-mdp3/mmsys_reg_base.h
index fcf53a2b62032d5c13e3b2e609ab362575f4548d..8aca525ba7e8b6fe70564fd7a6ba2c5aa850e89a 100644
--- a/drivers/media/platform/mtk-mdp3/mmsys_reg_base.h
+++ b/drivers/media/platform/mtk-mdp3/mmsys_reg_base.h
@@ -7,32 +7,64 @@
 #ifndef __MMSYS_REG_BASE_H__
 #define __MMSYS_REG_BASE_H__
 
+#ifndef CMDQ_ADDR_HIGH
+#define CMDQ_ADDR_HIGH(addr) ((u32)(((addr) >> 16) & GENMASK(31, 0)))
+#endif
+#ifndef CMDQ_ADDR_LOW
+#define CMDQ_ADDR_LOW(addr)	((u16)(addr) | BIT(1))
+#endif
+#define UNUSED(x) (void)(x)
+
+#define CMDQ_THR_SPR_0	(0)
+#define CMDQ_THR_SPR_1	(1)
+#define CMDQ_THR_SPR_2	(2)
+#define CMDQ_THR_SPR_3	(3)
+#define GCE_GPR_R11     (11)
+/* CMDQ: P7: debug */
+#define GCE_GPR_R14		0x0E
+#define GCE_GPR_R15		0x0F
+
 #define MM_REG_WRITE_MASK(cmd, id, base, ofst, val, mask, ...) \
-	cmdq_pkt_write_mask((cmd)->pkt, id, \
+	cmdq_pkt_write_mask(cmd->pkt, id, \
 		(base) + (ofst), (val), (mask), ##__VA_ARGS__)
 #define MM_REG_WRITE(cmd, id, base, ofst, val, mask, ...) \
 	MM_REG_WRITE_MASK(cmd, id, base, ofst, val, \
 		(((mask) & (ofst##_MASK)) == (ofst##_MASK)) ? \
 			(0xffffffff) : (mask), ##__VA_ARGS__)
 
+#define MM_REG_WRITE_S(cmd, id, base, ofst, val, mask, ...) \
+do{ \
+    UNUSED(id); \
+    cmdq_pkt_assign(cmd->pkt, CMDQ_THR_SPR_0, \
+        CMDQ_ADDR_HIGH(base+ofst)); \
+	cmdq_pkt_write_s_mask_value(cmd->pkt, CMDQ_THR_SPR_0, \
+		CMDQ_ADDR_LOW(base+ofst), (val), (mask), ##__VA_ARGS__); \
+}while(0)
+
 #define MM_REG_WAIT(cmd, evt) \
-	cmdq_pkt_wfe((cmd)->pkt, (cmd)->event[(evt)], true)
+	cmdq_pkt_wfe(cmd->pkt, cmd->event[(evt)], true)
 
 #define MM_REG_WAIT_NO_CLEAR(cmd, evt) \
-	cmdq_pkt_wait_no_clear((cmd)->pkt, (cmd)->event[(evt)])
+	cmdq_pkt_wfe(cmd->pkt, cmd->event[(evt)], false)
 
 #define MM_REG_CLEAR(cmd, evt) \
-	cmdq_pkt_clear_event((cmd)->pkt, (cmd)->event[(evt)])
+	cmdq_pkt_clear_event(cmd->pkt, cmd->event[(evt)])
 
 #define MM_REG_SET_EVENT(cmd, evt) \
-	cmdq_pkt_set_event((cmd)->pkt, (cmd)->event[(evt)])
+	cmdq_pkt_set_event(cmd->pkt, cmd->event[(evt)])
 
 #define MM_REG_POLL_MASK(cmd, id, base, ofst, val, mask, ...) \
-	cmdq_pkt_poll_mask((cmd)->pkt, id, \
+	cmdq_pkt_poll_mask(cmd->pkt, id, \
 		(base) + (ofst), (val), (mask), ##__VA_ARGS__)
 #define MM_REG_POLL(cmd, id, base, ofst, val, mask, ...) \
-	MM_REG_POLL_MASK((cmd), id, base, ofst, val, \
+	MM_REG_POLL_MASK(cmd, id, base, ofst, val, \
 		(((mask) & (ofst##_MASK)) == (ofst##_MASK)) ? \
 			(0xffffffff) : (mask), ##__VA_ARGS__)
 
+#define MM_REG_POLL_S(cmd, id, base, ofst, val, mask, ...) \
+do{ \
+    UNUSED(id); \
+    cmdq_pkt_poll_addr(cmd->pkt, val, ((base) + (ofst)), mask, GCE_GPR_R14); \
+}while(0)
+
 #endif  // __MM_REG_BASE_H__
diff --git a/drivers/media/platform/mtk-mdp3/mtk-img-ipi.h b/drivers/media/platform/mtk-mdp3/mtk-img-ipi.h
index 6b44e6e58571cb194c60ebb3e1d792cadc4a171f..371a40b543dbfbe8f3206f895cdcfa4ca6fa8ccc 100644
--- a/drivers/media/platform/mtk-mdp3/mtk-img-ipi.h
+++ b/drivers/media/platform/mtk-mdp3/mtk-img-ipi.h
@@ -24,21 +24,21 @@
 #define IMG_IPI_DEBUG   4
 
 struct img_addr {
-	u64 va; /* Used for Linux OS access */
-	u32 pa; /* Used for CM4 access */
-	u32 iova; /* Used for IOMMU HW access */
+	u64 va; /* Used by Linux OS access */
+	u32 pa; /* Used by CM4 access */
+	u32 iova; /* Used by IOMMU HW access */
 } __attribute__ ((__packed__));
 
 struct tuning_addr {
 	u64	present;
-	u32	pa;	/* Used for CM4 access */
-	u32	iova;	/* Used for IOMMU HW access */
+	u32	pa;	/* Used by CM4 access */
+	u32	iova;	/* Used by IOMMU HW access */
 } __attribute__ ((__packed__));
 
 
 struct img_sw_addr {
-	u64 va; /* Used for APMCU access */
-	u32 pa; /* Used for CM4 access */
+	u64 va; /* Used by APMCU access */
+	u32 pa; /* Used by CM4 access */
 } __attribute__ ((__packed__));
 
 struct img_plane_format {
@@ -79,6 +79,7 @@ struct img_crop {
 #define IMG_CTRL_FLAG_SHARPNESS	BIT(4)
 #define IMG_CTRL_FLAG_HDR	BIT(5)
 #define IMG_CTRL_FLAG_DRE	BIT(6)
+#define IMG_CTRL_FLAG_RSZ	BIT(7)
 
 struct img_input {
 	struct img_image_buffer buffer;
@@ -90,6 +91,7 @@ struct img_output {
 	struct img_crop crop;
 	s16 rotation;
 	u16 flags; /* H-flip, sharpness, dither */
+	u64 pqId;
 } __attribute__ ((__packed__));
 
 struct img_ipi_frameparam {
@@ -107,11 +109,12 @@ struct img_ipi_frameparam {
 	struct img_addr subfrm_data;
 	struct img_sw_addr config_data;
 	struct img_sw_addr self_data;
+	u8 frame_change;
 } __attribute__ ((__packed__));
 
 struct img_sw_buffer {
-	u64	handle;		/* Used for APMCU access */
-	u32	scp_addr;	/* Used for CM4 access */
+	u64	handle;		/* Used by APMCU access */
+	u32	scp_addr;	/* Used by CM4 access */
 } __attribute__ ((__packed__));
 
 struct img_ipi_param {
@@ -127,8 +130,8 @@ struct img_frameparam {
 /* ISP-MDP generic output information */
 
 struct img_comp_frame {
-	u32 output_disable:1;
-	u32 bypass:1;
+	u32 output_disable;
+	u32 bypass;
 	u16 in_width;
 	u16 in_height;
 	u16 out_width;
@@ -153,7 +156,7 @@ struct img_offset {
 } __attribute__ ((__packed__));
 
 struct img_comp_subfrm {
-	u32 tile_disable:1;
+	u32 tile_disable;
 	struct img_region in;
 	struct img_region out;
 	struct img_offset luma;
@@ -170,10 +173,13 @@ struct mdp_rdma_subfrm {
 	u32 src;
 	u32 clip;
 	u32 clip_ofst;
+	u32 in_tile_xleft;
+	u32 in_tile_ytop;
 } __attribute__ ((__packed__));
 
 struct mdp_rdma_data {
 	u32 src_ctrl;
+	u32 comp_ctrl;
 	u32 control;
 	u32 iova[IMG_MAX_PLANES];
 	u32 iova_end[IMG_MAX_PLANES];
@@ -183,13 +189,72 @@ struct mdp_rdma_data {
 	u32 ufo_dec_y;
 	u32 ufo_dec_c;
 	u32 transform;
+    u32 dmabuf_con0;
+    u32 ultra_th_high_con0;
+    u32 ultra_th_low_con0;
+    u32 dmabuf_con1;
+    u32 ultra_th_high_con1;
+    u32 ultra_th_low_con1;
+    u32 dmabuf_con2;
+    u32 ultra_th_high_con2;
+    u32 ultra_th_low_con2;
+    u32 dmabuf_con3;
 	struct mdp_rdma_subfrm subfrms[IMG_MAX_SUBFRAMES];
 } __attribute__ ((__packed__));
 
+struct mdp_fg_subfrm {
+    u32 info_0;
+    u32 info_1;
+} __attribute__ ((__packed__));
+
+struct mdp_fg_data {
+    u32 ctrl_0;
+    u32 ck_en;
+	struct mdp_fg_subfrm subfrms[IMG_MAX_SUBFRAMES];
+} __attribute__ ((__packed__));
+
+struct mdp_hdr_subfrm {
+       u32 win_size;
+       u32 src;
+       u32 clip_ofst0;
+       u32 clip_ofst1;
+       u32 hist_ctrl_0;
+       u32 hist_ctrl_1;
+       u32 hdr_top;
+       u32 hist_addr;
+} __attribute__ ((__packed__));
+
+struct mdp_hdr_data {
+       u32 top;
+       u32 relay;
+       struct mdp_hdr_subfrm   subfrms[IMG_MAX_SUBFRAMES];
+} __attribute__ ((__packed__));
+
+struct mdp_aal_subfrm {
+       u32 src;
+       u32 clip;
+       u32 clip_ofst;
+} __attribute__ ((__packed__));
+
+struct mdp_aal_data {
+       u32 cfg_main;
+       u32 cfg;
+       struct mdp_aal_subfrm   subfrms[IMG_MAX_SUBFRAMES];
+} __attribute__ ((__packed__));
+
 struct mdp_rsz_subfrm {
 	u32 control2;
 	u32 src;
 	u32 clip;
+	u32 enHdmiRx;
+	u32 luma_h_int_ofst;
+	u32 luma_h_sub_ofst;
+	u32 luma_v_int_ofst;
+	u32 luma_v_sub_ofst;
+	u32 chroma_h_int_ofst;
+	u32 chroma_h_sub_ofst;
+	u32 rsz_switch;
+	u32 merge_cfg;
 } __attribute__ ((__packed__));
 
 struct mdp_rsz_data {
@@ -197,9 +262,70 @@ struct mdp_rsz_data {
 	u32 coeff_step_y;
 	u32 control1;
 	u32 control2;
+	u32 etc_control;
+	u32 prz_enable;
+	u32 ibse_softclip;
+	u32 tap_adapt;
+	u32 ibse_gaincontrol1;
+	u32 ibse_gaincontrol2;
+	u32 ibse_ylevel_1;
+	u32 ibse_ylevel_2;
+	u32 ibse_ylevel_3;
+	u32 ibse_ylevel_4;
+	u32 ibse_ylevel_5;
 	struct mdp_rsz_subfrm subfrms[IMG_MAX_SUBFRAMES];
 } __attribute__ ((__packed__));
 
+struct mdp_tdshp_subfrm {
+       u32 src;
+       u32 clip;
+       u32 clip_ofst;
+       u32 hist_cfg_0;
+       u32 hist_cfg_1;
+} __attribute__ ((__packed__));
+
+struct mdp_tdshp_data {
+       u32 cfg;
+       struct mdp_tdshp_subfrm subfrms[IMG_MAX_SUBFRAMES];
+} __attribute__ ((__packed__));
+
+struct mdp_color_subfrm {
+       u32 in_hsize;
+       u32 in_vsize;
+} __attribute__ ((__packed__));
+
+struct mdp_color_data {
+       u32 start;
+       struct mdp_color_subfrm subfrms[IMG_MAX_SUBFRAMES];
+} __attribute__ ((__packed__));
+
+struct mdp_ovl_subfrm {
+	u32 L0_src_size;
+    u32 roi_size;
+} __attribute__ ((__packed__));
+
+struct mdp_ovl_data {
+    u32 L0_con;
+    u32 src_con;
+	struct mdp_ovl_subfrm subfrms[IMG_MAX_SUBFRAMES];
+} __attribute__ ((__packed__));
+
+struct mdp_pad_subfrm {
+	u32 pic_size;
+} __attribute__ ((__packed__));
+
+struct mdp_pad_data {
+	struct mdp_pad_subfrm subfrms[IMG_MAX_SUBFRAMES];
+} __attribute__ ((__packed__));
+
+struct mdp_tcc_subfrm {
+	u32 pic_size;
+} __attribute__ ((__packed__));
+
+struct mdp_tcc_data {
+	struct mdp_tcc_subfrm subfrms[IMG_MAX_SUBFRAMES];
+} __attribute__ ((__packed__));
+
 struct mdp_wrot_subfrm {
 	u32 offset[IMG_MAX_PLANES];
 	u32 src;
@@ -215,6 +341,14 @@ struct mdp_wrot_data {
 	u32 mat_ctrl;
 	u32 fifo_test;
 	u32 filter;
+    u32 pre_ultra;
+    u32 framesize;
+    u32 afbc_yuvtrans;
+    u32 scan_10bit;
+    u32 pending_zero;
+    u32 bit_number;
+    u32 pvric;
+	u32 vpp02vpp1;
 	struct mdp_wrot_subfrm subfrms[IMG_MAX_SUBFRAMES];
 } __attribute__ ((__packed__));
 
@@ -251,11 +385,19 @@ struct img_compparam {
 	struct img_comp_subfrm subfrms[IMG_MAX_SUBFRAMES];
 	u32 num_subfrms;
 	union {
-		struct mdp_rdma_data rdma;
-		struct mdp_rsz_data rsz;
-		struct mdp_wrot_data wrot;
-		struct mdp_wdma_data wdma;
-		struct isp_data isp;
+		struct mdp_rdma_data	rdma;
+		struct mdp_fg_data		fg;
+		struct mdp_hdr_data		hdr;
+		struct mdp_aal_data		aal;
+		struct mdp_rsz_data		rsz;
+		struct mdp_tdshp_data	tdshp;
+		struct mdp_color_data	color;
+		struct mdp_ovl_data		ovl;
+		struct mdp_pad_data		pad;
+		struct mdp_tcc_data		tcc;
+		struct mdp_wrot_data	wrot;
+		struct mdp_wdma_data	wdma;
+		struct isp_data			isp;
 	};
 } __attribute__ ((__packed__));
 
@@ -264,6 +406,7 @@ struct img_compparam {
 struct img_mux {
 	u32 reg;
 	u32 value;
+	u32 vpp_id;
 };
 
 struct img_mmsys_ctrl {
diff --git a/drivers/media/platform/mtk-mdp3/mtk-mdp3-cmdq.c b/drivers/media/platform/mtk-mdp3/mtk-mdp3-cmdq.c
index 4c204e06f31dba20d68ad9748ea55a1e82f97c80..f61793b564a09cb21a37a2cd904f1ff5549592a5 100644
--- a/drivers/media/platform/mtk-mdp3/mtk-mdp3-cmdq.c
+++ b/drivers/media/platform/mtk-mdp3/mtk-mdp3-cmdq.c
@@ -5,18 +5,24 @@
  */
 
 #include <linux/platform_device.h>
+#include <linux/pm_runtime.h>
+#include <linux/pm_domain.h>
 #include "mtk-mdp3-cmdq.h"
 #include "mtk-mdp3-comp.h"
 #include "mtk-mdp3-core.h"
+#include "mtk-mdp3-debug.h"
 #include "mtk-mdp3-m2m.h"
 
 #include "mdp-platform.h"
 #include "mmsys_mutex.h"
-#include "mtk-mdp3-debug.h"
 
 #define DISP_MUTEX_MDP_FIRST	(5)
 #define DISP_MUTEX_MDP_COUNT	(5)
 
+#define MDP_DUAL_PIPE			(2)
+#define PATH_0					(0)
+#define PATH_1					(1)
+
 #define MDP_PATH_MAX_COMPS	IMG_MAX_COMPONENTS
 
 struct mdp_path {
@@ -30,15 +36,27 @@ struct mdp_path {
 };
 
 #define has_op(ctx, op) \
-	(ctx->comp->ops && (ctx)->comp->ops->op)
+	(ctx->comp->ops && ctx->comp->ops->op)
 #define call_op(ctx, op, ...) \
-	(has_op(ctx, op) ? (ctx)->comp->ops->op(ctx, ##__VA_ARGS__) : 0)
+	(has_op(ctx, op) ? ctx->comp->ops->op(ctx, ##__VA_ARGS__) : 0)
+
+#define is_dummy_engine(id) \
+    (mdp_comp_matches[id].type == MDP_COMP_TYPE_DUMMY)
+
+#define is_dual_pipe(scenario) \
+	(scenario == MDP_STREAM_TYPE_DUAL_BITBLT)
 
 struct mdp_path_subfrm {
 	s32	mutex_id;
 	u32	mutex_mod;
 	s32	sofs[MDP_PATH_MAX_COMPS];
 	u32	num_sofs;
+	u32 mutex_mod2;
+	u32 mutex2_id;
+	u32 mutex2_mod;
+	u32	mutex2_mod2;
+	s32	sof2s[MDP_PATH_MAX_COMPS];
+	u32	num_sof2s;
 };
 
 static bool is_output_disable(const struct img_compparam *param, u32 count)
@@ -55,99 +73,334 @@ static int mdp_path_subfrm_require(struct mdp_path_subfrm *subfrm,
 {
 	const struct img_config *config = path->config;
 	const struct mdp_comp_ctx *ctx;
-	phys_addr_t mm_mutex = path->mdp_dev->mm_mutex.reg_base;
+	phys_addr_t vpp0_mutex = path->mdp_dev->mm_mutex.reg_base;
+	phys_addr_t vpp1_mutex = path->mdp_dev->vpp_mutex.reg_base;
 	s32 mutex_id = -1;
+	s32 mutex2_id = -1;
 	u32 mutex_sof = 0;
-	int mdp_color = 0;
+	u32 mutex_sof2 = 0;
 	int index;
-	u8 subsys_id = path->mdp_dev->mm_mutex.subsys_id;
+	u16 vpp0_mutex_id = path->mdp_dev->mm_mutex.subsys_id;
+	u16 vpp1_mutex_id = path->mdp_dev->vpp_mutex.subsys_id;
+	uint32_t timing_src = SRC_SINGLE_TRIGGER;
 
 	/* Default value */
 	memset(subfrm, 0, sizeof(*subfrm));
 
 	for (index = 0; index < config->num_components; index++) {
+        if(is_dummy_engine(config->components[index].type))
+            continue;
+
 		ctx = &path->comps[index];
 		if (is_output_disable(ctx->param, count))
 			continue;
 		switch (ctx->comp->id) {
-		/**********************************************
-		 * Name            MSB LSB
-		 * DISP_MUTEX_MOD   23   0
-		 *
-		 * Specifies which modules are in this mutex.
-		 * Every bit denotes a module. Bit definition:
-		 *  2 mdp_rdma0
-		 *  4 mdp_rsz0
-		 *  5 mdp_rsz1
-		 *  6 mdp_tdshp
-		 *  7 mdp_wrot0
-		 *  8 mdp_wdma
-		 *  13 mdp_color
-		 *  23 mdp_aal
-		 *  24 mdp_ccorr
-		 **********************************************/
-		case MDP_AAL0:
-			subfrm->mutex_mod |= 1 << 23;
-			break;
-		case MDP_CCORR0:
-			subfrm->mutex_mod |= 1 << 24;
-			break;
-		case MDP_COLOR0:
-			if (mdp_color)
-				subfrm->mutex_mod |= 1 << 13;
-			break;
-		case MDP_WDMA:
-			subfrm->mutex_mod |= 1 << 8;
-			subfrm->sofs[subfrm->num_sofs++] = MDP_WDMA;
-			break;
-		case MDP_WROT0:
-			subfrm->mutex_mod |= 1 << 7;
-			subfrm->sofs[subfrm->num_sofs++] = MDP_WROT0;
-			break;
-		case MDP_TDSHP0:
-			subfrm->mutex_mod |= 1 << 6;
-			subfrm->sofs[subfrm->num_sofs++] = MDP_TDSHP0;
-			break;
-		case MDP_SCL1:
-			subfrm->mutex_mod |= 1 << 5;
-			subfrm->sofs[subfrm->num_sofs++] = MDP_SCL1;
+        /**********************************************
+             * Name            MSB LSB
+             * MDP_MUTEX_MOD0   31   0
+             * MDP_MUTEX_MOD1    7   0
+             *
+	         * Bit definition for vppsys0 :
+	         * 00 : mdp_rdma
+	         * 01 : mdp_fg
+	         * 02 : stitch
+	         * 03 : mdp_hdr
+	         * 04 : mdp_aal
+	         * 05 : mdp_rsz
+	         * 06 : mdp_tdshp
+	         * 07 : disp_color
+	         * 08 : disc_ovl_NOAFBC
+	         * 09 : vpp_padding_in_padding
+	         * 10 : mdp_tcc
+	         * 11 : mdp_wrot
+	         * 12 : mmsysram_top
+	         * 13 : warp0_mmsys_top_relay
+	         * 14 : warp1_mmsys_top_relay
+	         * 15 : vpp1_mmsys_top_relay
+	         * 16 : vpp1_in_mmsys_top_relay
+	         *
+	         * Bit definition for vppsys1 :
+	         * 00 : hdmi_meta
+	         * 01 : dgi
+	         * 02 : vpp_split
+	         * 03 : svpp1_mdp_tcc
+	         * 04 : svpp1_mdp_rdma
+	         * 05 : svpp2_mdp_rdma
+	         * 06 : svpp3_mdp_rdma
+	         * 07 : svpp1_mdp_fg
+	         * 08 : svpp2_mdp_fg
+	         * 09 : svpp2_mdp_fg
+	         * 10 : svpp1_mdp_hdr
+	         * 11 : svpp2_mdp_hdr
+	         * 12 : svpp3_mdp_hdr
+	         * 13 : svpp1_mdp_aal
+	         * 14 : svpp2_mdp_aal
+	         * 15 : svpp3_mdp_aal
+	         * 16 : svpp1_mdp_rsz
+	         * 17 : svpp2_mdp_rsz
+	         * 18 : svpp3_mdp_rsz
+	         * 19 : svpp1_tdshp
+	         * 20 : svpp2_tdshp
+	         * 21 : svpp3_tdshp
+	         * 22 : svpp2_vpp_merge
+	         * 23 : svpp3_vpp_merge
+	         * 24 : svpp1_mdp_color
+	         * 25 : svpp2_mdp_color
+	         * 26 : svpp3_mdp_color
+	         * 27 : svpp1_mdp_ovl
+	         * 28 : svpp1_vpp_pad
+	         * 29 : svpp2_vpp_pad
+	         * 30 : svpp3_vpp_pad
+	         * 31 : svpp1_mdp_wrot
+	         *
+	         * 8195 mutex MOD1
+	         * The value of this signal is updated by the design.
+	         * The following shows the module index
+	         * Bit definition for vppsys0 :
+	         * reserved
+	         *
+	         * Bit definition for vppsys1 :
+	         * 00 : svpp2_mdp_wrot
+	         * 01 : svpp3_mdp_wrot
+	         * 02 : vpp0_dl_irly
+	         * 03 : vpp0_dl_orly
+	         * 04 : vdo0_dl_orly_0
+	         * 05 : vdo0_dl_orly_1
+	         * 06 : vdo1_dl_orly_0
+	         * 07 : vdo1_dl_orly_1
+             **********************************************/
+		case MDP_WPEI:
+			mutex_id = 0;
+			subfrm->mutex_mod |= 1 << 13;
 			break;
-		case MDP_SCL0:
-			subfrm->mutex_mod |= 1 << 4;
-			subfrm->sofs[subfrm->num_sofs++] = MDP_SCL0;
+		case MDP_WPEI2:
+			mutex_id = 1;
+			subfrm->mutex_mod |= 1 << 14;
 			break;
 		case MDP_RDMA0:
-			mutex_id = DISP_MUTEX_MDP_FIRST + 1;
-			subfrm->mutex_mod |= 1 << 2;
+		    mutex_id = 2;
+			subfrm->mutex_mod |= 1 << 0;
 			subfrm->sofs[subfrm->num_sofs++] = MDP_RDMA0;
 			break;
-		case MDP_IMGI:
-			mutex_id = DISP_MUTEX_MDP_FIRST;
-			break;
-		case MDP_WPEI:
-			mutex_id = DISP_MUTEX_MDP_FIRST + 3;
-			break;
-		case MDP_WPEI2:
-			mutex_id = DISP_MUTEX_MDP_FIRST + 4;
-			break;
+        case MDP_VPP1_SOUT:
+		    mutex_id = 3;
+			subfrm->mutex_mod |= 1 << 16;
+			subfrm->mutex2_mod2 |= 1 << 3;
+            break;
+        case MDP_FG0:
+            subfrm->mutex_mod |= 1 << 1;
+            break;
+        case MDP_STITCH:
+            subfrm->mutex_mod |= 1 << 2;
+            break;
+        case MDP_HDR0:
+            subfrm->mutex_mod |= 1 << 3;
+            break;
+        case MDP_AAL0:
+            subfrm->mutex_mod |= 1 << 4;
+            break;
+        case MDP_SCL0:
+            subfrm->mutex_mod |= 1 << 5;
+            subfrm->sofs[subfrm->num_sofs++] = MDP_SCL0;
+            break;
+        case MDP_TDSHP0:
+            subfrm->mutex_mod |= 1 << 6;
+            subfrm->sofs[subfrm->num_sofs++] = MDP_TDSHP0;
+            break;
+        case MDP_COLOR0:
+            subfrm->mutex_mod |= 1 << 7;
+            break;
+        case MDP_OVL0:
+            subfrm->mutex_mod |= 1 << 8;
+            break;
+        case MDP_PAD0:
+            subfrm->mutex_mod |= 1 << 9;
+            break;
+        case MDP_TCC0:
+            subfrm->mutex_mod |= 1 << 10;
+            break;
+        case MDP_WROT0:
+            subfrm->mutex_mod |= 1 << 11;
+            subfrm->sofs[subfrm->num_sofs++] = MDP_WROT0;
+            break;
+        case MDP_SPLIT:
+            mutex2_id = 2;
+            subfrm->mutex2_mod |= 1 << 2;
+            subfrm->sof2s[subfrm->num_sof2s++] = MDP_SPLIT;
+            timing_src = SRC_HDMI_VSYNC_SPLIT;
+            break;
+        case MDP_SPLIT2:
+            mutex2_id = 3;
+            subfrm->mutex2_mod |= 1 << 2;
+            subfrm->sof2s[subfrm->num_sof2s++] = MDP_SPLIT2;
+            timing_src = SRC_HDMI_VSYNC_SPLIT;
+            break;
+        case MDP_RDMA1:
+            mutex2_id = 1;
+            subfrm->mutex2_mod |= 1 << 4;
+            subfrm->sof2s[subfrm->num_sof2s++] = MDP_RDMA1;
+            break;
+        case MDP_RDMA2:
+            mutex2_id = 2;
+            subfrm->mutex2_mod |= 1 << 5;
+            subfrm->sof2s[subfrm->num_sof2s++] = MDP_RDMA2;
+            break;
+        case MDP_RDMA3:
+            mutex2_id = 3;
+            subfrm->mutex2_mod |= 1 << 6;
+            subfrm->sof2s[subfrm->num_sof2s++] = MDP_RDMA3;
+            break;
+        case MDP_VPP0_SOUT:
+            subfrm->mutex_mod |= 1 << 15;
+            mutex2_id = 4;
+            subfrm->mutex2_mod2 |= 1 << 2;
+            break;
+        case MDP_TCC1:
+            subfrm->mutex2_mod |= 1 << 3;
+            break;
+        case MDP_FG1:
+            subfrm->mutex2_mod |= 1 << 7;
+            break;
+        case MDP_FG2:
+            subfrm->mutex2_mod |= 1 << 8;
+            break;
+        case MDP_FG3:
+            subfrm->mutex2_mod |= 1 << 9;
+            break;
+        case MDP_HDR1:
+            subfrm->mutex2_mod |= 1 << 10;
+            break;
+        case MDP_HDR2:
+            subfrm->mutex2_mod |= 1 << 11;
+            break;
+        case MDP_HDR3:
+            subfrm->mutex2_mod |= 1 << 12;
+            break;
+        case MDP_AAL1:
+            subfrm->mutex2_mod |= 1 << 13;
+            break;
+        case MDP_AAL2:
+            subfrm->mutex2_mod |= 1 << 14;
+            break;
+        case MDP_AAL3:
+            subfrm->mutex2_mod |= 1 << 15;
+            break;
+        case MDP_SCL1:
+            subfrm->mutex2_mod |= 1 << 16;
+            subfrm->sof2s[subfrm->num_sof2s++] = MDP_SCL1;
+            break;
+        case MDP_SCL2:
+            subfrm->mutex2_mod |= 1 << 17;
+            subfrm->mutex2_mod |= 1 << 22; // merge2
+            subfrm->sof2s[subfrm->num_sof2s++] = MDP_SCL2;
+            break;
+        case MDP_SCL3:
+            subfrm->mutex2_mod |= 1 << 18;
+            subfrm->mutex2_mod |= 1 << 23; // merge3
+            subfrm->sof2s[subfrm->num_sof2s++] = MDP_SCL3;
+            break;
+        case MDP_TDSHP1:
+            subfrm->mutex2_mod |= 1 << 19;
+            subfrm->sof2s[subfrm->num_sof2s++] = MDP_TDSHP1;
+            break;
+        case MDP_TDSHP2:
+            subfrm->mutex2_mod |= 1 << 20;
+            subfrm->sof2s[subfrm->num_sof2s++] = MDP_TDSHP2;
+            break;
+        case MDP_TDSHP3:
+            subfrm->mutex2_mod |= 1 << 21;
+            subfrm->sof2s[subfrm->num_sof2s++] = MDP_TDSHP3;
+            break;
+        case MDP_COLOR1:
+            subfrm->mutex2_mod |= 1 << 24;
+            break;
+        case MDP_COLOR2:
+            subfrm->mutex2_mod |= 1 << 25;
+            break;
+        case MDP_COLOR3:
+            subfrm->mutex2_mod |= 1 << 26;
+            break;
+        case MDP_OVL1:
+            subfrm->mutex2_mod |= 1 << 27;
+            break;
+        case MDP_PAD1:
+            subfrm->mutex2_mod |= 1 << 28;
+            break;
+        case MDP_PAD2:
+            subfrm->mutex2_mod |= 1 << 29;
+            break;
+        case MDP_PAD3:
+            subfrm->mutex2_mod |= 1 << 30;
+            break;
+        case MDP_WROT1:
+            subfrm->mutex2_mod |= 1 << 31;
+            subfrm->sof2s[subfrm->num_sof2s++] = MDP_WROT1;
+            break;
+        case MDP_WROT2:
+            subfrm->mutex2_mod2 |= 1 << 0;
+            subfrm->sof2s[subfrm->num_sof2s++] = MDP_WROT2;
+            break;
+        case MDP_WROT3:
+            subfrm->mutex2_mod2 |= 1 << 1;
+            subfrm->sof2s[subfrm->num_sof2s++] = MDP_WROT3;
+            break;
+        case MDP_VDO0DL0:
+            subfrm->mutex2_mod2 |= 1 << 4;
+            break;
+        case MDP_VDO1DL0:
+            subfrm->mutex2_mod2 |= 1 << 6;
+            break;
+        case MDP_VDO0DL1:
+            subfrm->mutex2_mod2 |= 1 << 5;
+            break;
+        case MDP_VDO1DL1:
+            subfrm->mutex2_mod2 |= 1 << 7;
+            break;
 		default:
 			break;
 		}
 	}
 
 	subfrm->mutex_id = mutex_id;
-	if (-1 == mutex_id) {
+	subfrm->mutex2_id = mutex2_id;
+
+	if ((-1 == mutex_id) && (-1 == mutex2_id)) {
 		mdp_err("No mutex assigned");
 		return -EINVAL;
 	}
 
-	if (subfrm->mutex_mod) {
+    if (mutex_id != -1)
+    {
+        mdp_dbg(2, "Acquire mutex_id: %d\n", mutex_id);
+    }
+
+    if (mutex2_id != -1)
+    {
+        mdp_dbg(2, "Acquire mutex2_id: %d\n", mutex2_id);
+    }
+
+	if ((subfrm->mutex_mod) || (subfrm->mutex_mod2)) {
 		/* Set mutex modules */
-		MM_REG_WRITE(cmd, subsys_id, mm_mutex, MM_MUTEX_MOD,
-			     subfrm->mutex_mod, 0x07FFFFFF);
-		MM_REG_WRITE(cmd, subsys_id, mm_mutex, MM_MUTEX_SOF,
+		MM_REG_WRITE(cmd, vpp0_mutex_id, vpp0_mutex, MM_MUTEX_MOD,
+			     subfrm->mutex_mod, 0x0FFFFFFF);
+		MM_REG_WRITE(cmd, vpp0_mutex_id, vpp0_mutex, MM_MUTEX_MOD1,
+			     subfrm->mutex_mod2, 0x0FFFFFFF);
+		MM_REG_WRITE(cmd, vpp0_mutex_id, vpp0_mutex, MM_MUTEX_SOF,
 			     mutex_sof, 0x00000007);
 	}
+
+	if ((subfrm->mutex2_mod) || (subfrm->mutex2_mod2)) {
+        // Set mutex modules
+        mutex_sof2 = timing_src << VPP_MUTEX_CTL_EOF_SHIFT | timing_src << VPP_MUTEX_CTL_SOF_SHIFT;
+
+		/* Set mutex modules */
+		MM_REG_WRITE(cmd, vpp1_mutex_id, vpp1_mutex, VPP_MUTEX_MOD,
+			     subfrm->mutex2_mod, 0x0FFFFFFF);
+		MM_REG_WRITE(cmd, vpp1_mutex_id, vpp1_mutex, VPP_MUTEX_MOD1,
+			     subfrm->mutex2_mod2, 0x0FFFFFFF);
+		MM_REG_WRITE(cmd, vpp1_mutex_id, vpp1_mutex, VPP_MUTEX_SOF,
+			     mutex_sof2, 0x00000007);
+	}
 	return 0;
 }
 
@@ -155,16 +408,20 @@ static int mdp_path_subfrm_run(const struct mdp_path_subfrm *subfrm,
 			       const struct mdp_path *path,
 			       struct mdp_cmd *cmd)
 {
-	phys_addr_t mm_mutex = path->mdp_dev->mm_mutex.reg_base;
+	phys_addr_t vpp0_mutex = path->mdp_dev->mm_mutex.reg_base;
+	phys_addr_t vpp1_mutex = path->mdp_dev->vpp_mutex.reg_base;
 	s32 mutex_id = subfrm->mutex_id;
-	u8 subsys_id = path->mdp_dev->mm_mutex.subsys_id;
+	s32 mutex2_id = subfrm->mutex2_id;
+	u16 vpp0_mutex_id = path->mdp_dev->mm_mutex.subsys_id;
+	u16 vpp1_mutex_id = path->mdp_dev->vpp_mutex.subsys_id;
 
-	if (-1 == mutex_id) {
+	if ((-1 == mutex_id) &&
+        (-1 == mutex2_id)){
 		mdp_err("Incorrect mutex id");
 		return -EINVAL;
 	}
 
-	if (subfrm->mutex_mod) {
+	if ((subfrm->mutex_mod) || (subfrm->mutex_mod2)) {
 		int index;
 
 		/* Wait WROT SRAM shared to DISP RDMA */
@@ -172,24 +429,22 @@ static int mdp_path_subfrm_run(const struct mdp_path_subfrm *subfrm,
 		for (index = 0; index < subfrm->num_sofs; index++) {
 			switch (subfrm->sofs[index]) {
 			case MDP_RDMA0:
-				MM_REG_CLEAR(cmd, RDMA0_SOF);
-				break;
-			case MDP_TDSHP0:
-				MM_REG_CLEAR(cmd, TDSHP0_SOF);
+				MM_REG_CLEAR(cmd, RDMA0_FRAME_DONE);
 				break;
-			case MDP_SCL0:
-				MM_REG_CLEAR(cmd, RSZ0_SOF);
+			case MDP_WROT0:
+				MM_REG_CLEAR(cmd, WROT0_FRAME_DONE);
 				break;
-			case MDP_SCL1:
-				MM_REG_CLEAR(cmd, RSZ1_SOF);
+			default:
 				break;
-			case MDP_WDMA:
-				MM_REG_CLEAR(cmd, WDMA0_SOF);
+			}
+		}
+
+		for (index = 0; index < subfrm->num_sofs; index++) {
+			switch (subfrm->sofs[index]) {
+			case MDP_RDMA0:
+				MM_REG_CLEAR(cmd, RDMA0_SOF);
 				break;
 			case MDP_WROT0:
-#if WROT0_DISP_SRAM_SHARING
-				MM_REG_WAIT_NO_CLEAR(cmd, WROT0_SRAM_READY);
-#endif
 				MM_REG_CLEAR(cmd, WROT0_SOF);
 				break;
 			default:
@@ -198,7 +453,7 @@ static int mdp_path_subfrm_run(const struct mdp_path_subfrm *subfrm,
 		}
 
 		/* Enable the mutex */
-		MM_REG_WRITE(cmd, subsys_id, mm_mutex, MM_MUTEX_EN, 0x1,
+		MM_REG_WRITE(cmd, vpp0_mutex_id, vpp0_mutex, MM_MUTEX_EN, 0x1,
 			     0x00000001);
 
 		/* Wait SOF events and clear mutex modules (optional) */
@@ -207,18 +462,6 @@ static int mdp_path_subfrm_run(const struct mdp_path_subfrm *subfrm,
 			case MDP_RDMA0:
 				MM_REG_WAIT(cmd, RDMA0_SOF);
 				break;
-			case MDP_TDSHP0:
-				MM_REG_WAIT(cmd, TDSHP0_SOF);
-				break;
-			case MDP_SCL0:
-				MM_REG_WAIT(cmd, RSZ0_SOF);
-				break;
-			case MDP_SCL1:
-				MM_REG_WAIT(cmd, RSZ1_SOF);
-				break;
-			case MDP_WDMA:
-				MM_REG_WAIT(cmd, WDMA0_SOF);
-				break;
 			case MDP_WROT0:
 				MM_REG_WAIT(cmd, WROT0_SOF);
 				break;
@@ -227,25 +470,66 @@ static int mdp_path_subfrm_run(const struct mdp_path_subfrm *subfrm,
 			}
 		}
 	}
-	return 0;
-}
 
-static int mdp_path_ctx_init(struct mdp_dev *mdp, struct mdp_path *path)
-{
-	const struct img_config *config = path->config;
-	int index, ret;
+	if ((subfrm->mutex2_mod) || (subfrm->mutex2_mod2)) {
+		int index;
 
-	if (config->num_components < 1)
-		return -EINVAL;
+		/* Clear SOF event for each engine */
+		for (index = 0; index < subfrm->num_sof2s; index++) {
+			switch (subfrm->sof2s[index]) {
+			case MDP_RDMA1:
+				MM_REG_CLEAR(cmd, RDMA1_SOF);
+				break;
+			case MDP_RDMA2:
+				MM_REG_CLEAR(cmd, RDMA2_SOF);
+				break;
+			case MDP_RDMA3:
+				MM_REG_CLEAR(cmd, RDMA3_SOF);
+				break;
+			case MDP_WROT1:
+				MM_REG_CLEAR(cmd, WROT1_SOF);
+				break;
+			case MDP_WROT2:
+				MM_REG_CLEAR(cmd, WROT2_SOF);
+				break;
+			case MDP_WROT3:
+				MM_REG_CLEAR(cmd, WROT3_SOF);
+				break;
+			default:
+				break;
+			}
+		}
 
-	for (index = 0; index < config->num_components; index++) {
-		ret = mdp_comp_ctx_init(mdp, &path->comps[index],
-					&config->components[index],
-					path->param);
-		if (ret)
-			return ret;
-	}
+		/* Enable the mutex */
+		MM_REG_WRITE(cmd, vpp1_mutex_id, vpp1_mutex, VPP_MUTEX_EN, 0x1,
+			     0x00000001);
 
+		/* Wait SOF events and clear mutex modules (optional) */
+		for (index = 0; index < subfrm->num_sof2s; index++) {
+			switch (subfrm->sof2s[index]) {
+			case MDP_RDMA1:
+				MM_REG_WAIT(cmd, RDMA1_SOF);
+				break;
+			case MDP_RDMA2:
+				MM_REG_WAIT(cmd, RDMA2_SOF);
+				break;
+			case MDP_RDMA3:
+				MM_REG_WAIT(cmd, RDMA3_SOF);
+				break;
+			case MDP_WROT1:
+				MM_REG_WAIT(cmd, WROT1_SOF);
+				break;
+			case MDP_WROT2:
+				MM_REG_WAIT(cmd, WROT2_SOF);
+				break;
+			case MDP_WROT3:
+				MM_REG_WAIT(cmd, WROT3_SOF);
+				break;
+			default:
+				break;
+			}
+		}
+	}
 	return 0;
 }
 
@@ -257,22 +541,34 @@ static int mdp_path_config_subfrm(struct mdp_cmd *cmd, struct mdp_path *path,
 	const struct img_mmsys_ctrl *ctrl = &config->ctrls[count];
 	const struct img_mux *set;
 	struct mdp_comp_ctx *ctx;
-	phys_addr_t mmsys = path->mdp_dev->mmsys.reg_base;
+	phys_addr_t vpp0 = path->mdp_dev->mmsys.reg_base;
+	u16 vpp0_subsys_id = path->mdp_dev->mmsys.subsys_id;
+
+	phys_addr_t vpp1 = path->mdp_dev->vppsys.reg_base;
+	u16 vpp1_subsys_id = path->mdp_dev->vppsys.subsys_id;
+
+	phys_addr_t mmsys = 0;
+	u16 subsys_id = 0;
 	int index, ret;
-	u8 subsys_id = path->mdp_dev->mmsys.subsys_id;
 
 	/* Acquire components */
 	ret = mdp_path_subfrm_require(&subfrm, path, cmd, count);
 	if (ret)
 		return ret;
+
 	/* Enable mux settings */
 	for (index = 0; index < ctrl->num_sets; index++) {
 		set = &ctrl->sets[index];
+        mmsys = (set->vpp_id)? vpp1 : vpp0;
+        subsys_id = (set->vpp_id)? vpp1_subsys_id : vpp0_subsys_id;
 		MM_REG_WRITE_MASK(cmd, subsys_id, mmsys, set->reg, set->value,
 				  0xFFFFFFFF);
 	}
 	/* Config sub-frame information */
 	for (index = (config->num_components - 1); index >= 0; index--) {
+        if(is_dummy_engine(config->components[index].type))
+            continue;
+
 		ctx = &path->comps[index];
 		if (is_output_disable(ctx->param, count))
 			continue;
@@ -286,6 +582,9 @@ static int mdp_path_config_subfrm(struct mdp_cmd *cmd, struct mdp_path *path,
 		return ret;
 	/* Wait components done */
 	for (index = 0; index < config->num_components; index++) {
+        if(is_dummy_engine(config->components[index].type))
+            continue;
+
 		ctx = &path->comps[index];
 		if (is_output_disable(ctx->param, count))
 			continue;
@@ -295,6 +594,9 @@ static int mdp_path_config_subfrm(struct mdp_cmd *cmd, struct mdp_path *path,
 	}
 	/* Advance to the next sub-frame */
 	for (index = 0; index < config->num_components; index++) {
+        if(is_dummy_engine(config->components[index].type))
+            continue;
+
 		ctx = &path->comps[index];
 		ret = call_op(ctx, advance_subfrm, cmd, count);
 		if (ret)
@@ -303,12 +605,33 @@ static int mdp_path_config_subfrm(struct mdp_cmd *cmd, struct mdp_path *path,
 	/* Disable mux settings */
 	for (index = 0; index < ctrl->num_sets; index++) {
 		set = &ctrl->sets[index];
+        mmsys = (set->vpp_id)? vpp1 : vpp0;
+        subsys_id = (set->vpp_id)? vpp1_subsys_id : vpp0_subsys_id;
 		MM_REG_WRITE_MASK(cmd, subsys_id, mmsys, set->reg, 0,
 				  0xFFFFFFFF);
 	}
 	return 0;
 }
 
+static int mdp_path_ctx_init(struct mdp_dev *mdp, struct mdp_path *path)
+{
+	const struct img_config *config = path->config;
+	int index, ret;
+
+	for (index = 0; index < config->num_components; index++) {
+        if(is_dummy_engine(config->components[index].type))
+            continue;
+
+		ret = mdp_comp_ctx_init(mdp, &path->comps[index],
+					&config->components[index],
+					path->param);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+}
+
 static int mdp_path_config(struct mdp_dev *mdp, struct mdp_cmd *cmd,
 			   struct mdp_path *path)
 {
@@ -319,15 +642,22 @@ static int mdp_path_config(struct mdp_dev *mdp, struct mdp_cmd *cmd,
 	/* Config path frame */
 	/* Reset components */
 	for (index = 0; index < config->num_components; index++) {
+        if(is_dummy_engine(config->components[index].type))
+            continue;
 		ctx = &path->comps[index];
 		ret = call_op(ctx, init_comp, cmd);
 		if (ret)
 			return ret;
 	}
+
 	/* Config frame mode */
 	for (index = 0; index < config->num_components; index++) {
-		const struct v4l2_rect *compose =
-			path->composes[ctx->param->outputs[0]];
+        const struct v4l2_rect *compose = NULL;
+
+        if(is_dummy_engine(config->components[index].type))
+            continue;
+
+		compose = path->composes[ctx->param->outputs[0]];
 
 		ctx = &path->comps[index];
 		ret = call_op(ctx, config_frame, cmd, compose);
@@ -341,33 +671,127 @@ static int mdp_path_config(struct mdp_dev *mdp, struct mdp_cmd *cmd,
 		if (ret)
 			return ret;
 	}
+
 	/* Post processing information */
 	for (index = 0; index < config->num_components; index++) {
+        if(is_dummy_engine(config->components[index].type))
+            continue;
+
 		ctx = &path->comps[index];
 		ret = call_op(ctx, post_process, cmd);
 		if (ret)
 			return ret;
 	}
+
 	return 0;
 }
 
+static int mdp_hyfbc_config(struct mdp_dev *mdp, struct mdp_cmd *cmd,
+	struct mdp_path *path, struct mdp_cmdq_param *param)
+{
+#define BYTE_PER_MB_Y				(4)
+#define BYTE_PER_MB_C				(2)
+
+#define CEIL(a, b) ((a%b==0)? (a/b): (a/b+1))
+#define ALIGN_UP(val, a)						\
+({												\
+	typeof(val) _a = (a);						\
+	(_a==0)? val : ((val+(_a-1))/(_a)*(_a));	\
+})
+
+#define is_rdma(id) \
+    (mdp_comp_matches[id].type == MDP_COMP_TYPE_RDMA)
+#define RDMA_WROT_ID_OFT			(45)
+
+	const struct img_config *config = path->config;
+	struct mdp_m2m_ctx *ctx;
+	struct mdp_comp_ctx *comp_ctx = &path->comps[0];
+	const struct mdp_rdma_data *rdma = &comp_ctx->param->rdma;
+	struct hyfbcPatchStruct hyfbc;
+	struct mdp_frame *frame;
+	enum mdp_comp_id wrot_id;
+	int ret = 0;
+
+	ctx = (struct mdp_m2m_ctx *)param->mdp_ctx;
+	frame = &ctx->curr_param.output;
+
+	if (!MDP_COLOR_IS_HYFBC_COMPRESS(frame->mdp_fmt->mdp_color) ||
+		frame->format.fmt.pix_mp.width % 32 == 0)
+	{
+		goto EXIT;
+	}
+
+	// First engine should be rdma engine
+	if (!is_rdma(config->components[0].type))
+	{
+		mdp_err("Not RDMA engine (id), end patch.", config->components[0].type);
+		goto EXIT;
+	}
+
+	wrot_id = config->components[0].type + RDMA_WROT_ID_OFT;
+
+	hyfbc.is10b = (MDP_COLOR_IS_10BIT(frame->mdp_fmt->mdp_color));
+	hyfbc.width_in_mb = CEIL(frame->format.fmt.pix_mp.width , 16);;
+	hyfbc.height_in_mb = CEIL(frame->format.fmt.pix_mp.height, 16);;
+	hyfbc.w_stride_in_mb = CEIL(ALIGN_UP(frame->stride.width, 32), 16);
+	hyfbc.h_stride_in_mb = CEIL(ALIGN_UP(frame->stride.height, 32), 16);
+	hyfbc.byte_per_mb = BYTE_PER_MB_Y;
+	hyfbc.pa_base = rdma->ufo_dec_y;
+
+	ret = mdp_hyfbc_patch(mdp, cmd, &hyfbc, wrot_id);
+	if (ret)
+	{
+		mdp_err("mdp_hyfbc_patch: y patch fail.");
+		goto EXIT;
+	}
+
+	hyfbc.byte_per_mb = BYTE_PER_MB_C;
+	hyfbc.pa_base = rdma->ufo_dec_c;
+
+	ret = mdp_hyfbc_patch(mdp, cmd, &hyfbc, wrot_id);
+	if (ret)
+	{
+		mdp_err("mdp_hyfbc_patch: c patch fail.");
+	}
+
+EXIT:
+	return ret;
+}
+
 static void mdp_auto_release_work(struct work_struct *work)
 {
 	struct mdp_cmdq_cb_param *cb_param;
 	struct mdp_dev *mdp;
+	int i = 0;
+	bool finalize;
 
 	cb_param = container_of(work, struct mdp_cmdq_cb_param,
 				auto_release_work);
 	mdp = cb_param->mdp;
+	finalize = cb_param->finalize;
 
-	mdp_comp_clocks_off(&mdp->pdev->dev, cb_param->comps,
-			    cb_param->num_comps);
+	if (cb_param->comps && cb_param->num_comps) {
+		for (i = 0; i < cb_param->num_comps; i++)
+			mdp_comp_clock_off(&mdp->pdev->dev,
+					   &cb_param->comps[i]);
+	}
+
+	if (finalize) {
+		mdp_comp_clock_off(&mdp->pdev->dev, &mdp->mm_mutex);
+		mdp_comp_clock_off(&mdp->pdev->dev, &mdp->vpp_mutex);
+
+		for (i = 0; i < mdp->pwr_domain_num; i++) {
+			pm_runtime_put_sync(mdp->pwr_devs[i]);
+		}
+	}
 
 	kfree(cb_param->comps);
 	kfree(cb_param);
 
-	atomic_dec(&mdp->job_count);
-	wake_up(&mdp->callback_wq);
+	if (finalize) {
+		atomic_dec(&mdp->job_count);
+		wake_up(&mdp->callback_wq);
+	}
 }
 
 static void mdp_handle_cmdq_callback(struct cmdq_cb_data data)
@@ -377,15 +801,16 @@ static void mdp_handle_cmdq_callback(struct cmdq_cb_data data)
 
 	if (!data.data) {
 		mdp_err("%s:no callback data\n", __func__);
-		return;
+		goto exit;
 	}
 
 	cb_param = (struct mdp_cmdq_cb_param *)data.data;
 	mdp = cb_param->mdp;
 
-	if (cb_param->mdp_ctx)
-		mdp_m2m_job_finish(cb_param->mdp_ctx);
+	cb_param->finalize = (atomic_dec_and_test(&mdp->cmdq_count));
 
+	if ((cb_param->finalize) && (cb_param->mdp_ctx))
+		mdp_m2m_job_finish(cb_param->mdp_ctx);
 #ifdef MDP_DEBUG
 	if (data.sta == CMDQ_CB_ERROR) {
 		struct mdp_func_struct *p_func = mdp_get_func();
@@ -405,32 +830,24 @@ static void mdp_handle_cmdq_callback(struct cmdq_cb_data data)
 
 	cmdq_pkt_destroy(cb_param->pkt);
 	INIT_WORK(&cb_param->auto_release_work, mdp_auto_release_work);
-	if (!queue_work(mdp->clock_wq, &cb_param->auto_release_work)) {
-		mdp_err("%s:queue_work fail!\n", __func__);
-		mdp_comp_clocks_off(&mdp->pdev->dev, cb_param->comps,
-				    cb_param->num_comps);
+	queue_work(mdp->clock_wq, &cb_param->auto_release_work);
 
-		kfree(cb_param->comps);
-		kfree(cb_param);
-
-		atomic_dec(&mdp->job_count);
-		wake_up(&mdp->callback_wq);
-	}
+exit:
+	return;
 }
 
 int mdp_cmdq_send(struct mdp_dev *mdp, struct mdp_cmdq_param *param)
 {
-	struct mdp_cmd cmd;
-	struct mdp_path path;
-	struct mdp_cmdq_cb_param *cb_param = NULL;
-	struct mdp_comp *comps = NULL;
-	int i, ret;
+	static struct mdp_path path_info[MDP_DUAL_PIPE];
+	struct mdp_cmd cmd, cmd_s;
+	int i, ret, path_id;
+	enum mdp_stream_type scenario = param->param->type;
 
 	if (atomic_read(&mdp->suspended))
 		return -ECANCELED;
 
 	atomic_inc(&mdp->job_count);
-
+    mbox_flush(mdp->cmdq_clt->chan, 2000);
 	cmd.pkt = cmdq_pkt_create(mdp->cmdq_clt, SZ_16K);
 	if (IS_ERR(cmd.pkt)) {
 		atomic_dec(&mdp->job_count);
@@ -439,84 +856,206 @@ int mdp_cmdq_send(struct mdp_dev *mdp, struct mdp_cmdq_param *param)
 	}
 	cmd.event = &mdp->event[0];
 
-	path.mdp_dev = mdp;
-	path.config = param->config;
-	path.param = param->param;
-	for (i = 0; i < param->param->num_outputs; i++) {
-		path.bounds[i].left = 0;
-		path.bounds[i].top = 0;
-		path.bounds[i].width =
-			param->param->outputs[i].buffer.format.width;
-		path.bounds[i].height =
-			param->param->outputs[i].buffer.format.height;
-		path.composes[i] = param->composes[i] ?
-			param->composes[i] : &path.bounds[i];
-	}
-
-	ret = mdp_path_ctx_init(mdp, &path);
-	if (ret) {
-		pr_info("%s mdp_path_ctx_init error\n", __func__);
-		goto err_destroy_pkt;
+	if (is_dual_pipe(scenario)) {
+	    mbox_flush(mdp->cmdq_s_clt->chan, 2000);
+		cmd_s.pkt = cmdq_pkt_create(mdp->cmdq_s_clt, SZ_16K);
+		if (IS_ERR(cmd_s.pkt)) {
+			atomic_dec(&mdp->job_count);
+			wake_up(&mdp->callback_wq);
+			return PTR_ERR(cmd_s.pkt);
+		}
+		cmd_s.event = &mdp->event[0];
+	}
+
+	for (path_id=0; path_id<MDP_DUAL_PIPE; path_id++) {
+		if ((path_id != 0) && (!is_dual_pipe(scenario)))
+			break;
+
+		path_info[path_id].mdp_dev = mdp;
+		path_info[path_id].config = &param->config[path_id];
+		path_info[path_id].param = param->param;
+		for (i = 0; i < param->param->num_outputs; i++) {
+			path_info[path_id].bounds[i].left = 0;
+			path_info[path_id].bounds[i].top = 0;
+			path_info[path_id].bounds[i].width =
+				param->param->outputs[i].buffer.format.width;
+			path_info[path_id].bounds[i].height =
+				param->param->outputs[i].buffer.format.height;
+			path_info[path_id].composes[i] = param->composes[i] ?
+				param->composes[i] : &path_info[path_id].bounds[i];
+		}
+
+		ret = mdp_path_ctx_init(mdp, &path_info[path_id]);
+		if (ret) {
+			pr_info("%s mdp_path_info_ctx_init error at path_info %d\n",__FUNCTION__,path_id);
+		}
 	}
 
-	for (i = 0; i < param->config->num_components; i++)
-			mdp_comp_clock_on(&mdp->pdev->dev, path.comps[i].comp);
+    // TODO: engine conflict dispatch
+	for (i = 0; i < mdp->pwr_domain_num; i++) {
+		if(IS_ERR(mdp->pwr_devs[i])) {
+			mdp_err("%s error power device\n",__func__);
+			return PTR_ERR(mdp->pwr_devs[i]);
+		}
+		pm_runtime_resume_and_get(mdp->pwr_devs[i]);
+	}
+	mdp_comp_clock_on(&mdp->pdev->dev, &mdp->mm_mutex);
+	mdp_comp_clock_on(&mdp->pdev->dev, &mdp->vpp_mutex);
 
-	ret = mdp_path_config(mdp, &cmd, &path);
+	for (i = 0; i < param->config[PATH_0].num_components; i++) {
+        if(is_dummy_engine(path_info[PATH_0].config->components[i].type))
+            continue;
+
+		mdp_comp_clock_on(&mdp->pdev->dev, path_info[PATH_0].comps[i].comp);
+    }
+
+	if (is_dual_pipe(scenario)) {
+		for (i = 0; i < param->config[PATH_1].num_components; i++) {
+	        if(is_dummy_engine(path_info[PATH_1].config->components[i].type))
+	            continue;
+
+			mdp_comp_clock_on(&mdp->pdev->dev, path_info[PATH_1].comps[i].comp);
+	    }
+	}
+
+	/* HYFBC Patch */
+	ret = mdp_hyfbc_config(mdp, &cmd, &path_info[PATH_0], param);
 	if (ret) {
-		pr_info("%s mdp_path_config error\n", __func__);
-		goto err_destroy_pkt;
-	}
-
-	cb_param = kzalloc(sizeof(*cb_param), GFP_KERNEL);
-	if (!cb_param) {
-		ret = -ENOMEM;
-		goto err_destroy_pkt;
-	}
-
-	comps = kcalloc(param->config->num_components, sizeof(*comps),
-			GFP_KERNEL);
-	if (!comps) {
-		ret = -ENOMEM;
-		goto err_destroy_pkt;
-	}
-
-	for (i = 0; i < param->config->num_components; i++)
-		memcpy(&comps[i], path.comps[i].comp,
-		       sizeof(struct mdp_comp));
-	cb_param->mdp = mdp;
-	cb_param->user_cmdq_cb = param->cmdq_cb;
-	cb_param->user_cb_data = param->cb_data;
-	cb_param->pkt = cmd.pkt;
-	cb_param->comps = comps;
-	cb_param->num_comps = param->config->num_components;
-	cb_param->mdp_ctx = param->mdp_ctx;
-
-	cmdq_pkt_finalize(cmd.pkt);
-	ret = cmdq_pkt_flush_async(cmd.pkt,
-				   mdp_handle_cmdq_callback,
-				   (void *)cb_param);
+		mdp_err("%s:mdp_hyfbc_config fail!\n", __func__);
+	}
+
+	ret = mdp_path_config(mdp, &cmd, &path_info[PATH_0]);
 	if (ret) {
-		mdp_err("%s:cmdq_pkt_flush_async fail!\n", __func__);
-		goto err_clock_off;
+		atomic_dec(&mdp->job_count);
+		wake_up(&mdp->callback_wq);
+		return ret;
 	}
-	return 0;
 
-err_clock_off:
-	mdp_comp_clocks_off(&mdp->pdev->dev, cb_param->comps,
-						cb_param->num_comps);
-err_destroy_pkt:
-	cmdq_pkt_destroy(cmd.pkt);
-	atomic_dec(&mdp->job_count);
-	wake_up(&mdp->callback_wq);
-	kfree(comps);
-	kfree(cb_param);
+	if (is_dual_pipe(scenario)) {
+		ret = mdp_path_config(mdp, &cmd_s, &path_info[PATH_1]);
+		if (ret) {
+			atomic_dec(&mdp->job_count);
+			wake_up(&mdp->callback_wq);
+			return ret;
+		}
+	}
+
+    cmdq_pkt_finalize(cmd.pkt);
+	if (is_dual_pipe(scenario))
+	    cmdq_pkt_finalize(cmd_s.pkt);
 
+	if (param->wait) {
+		ret = cmdq_pkt_flush_async(cmd.pkt, NULL, cmd.pkt);
+#ifdef MDP_DEBUG
+        if (ret) {
+                    struct mdp_func_struct *p_func = mdp_get_func();
+
+                    p_func->mdp_dump_mmsys_config();
+                    mdp_dump_info(~0, 1);
+                }
+#endif
+
+		if (!ret) { /* error handle in mdp_m2m_worker */
+			if (param->mdp_ctx)
+				mdp_m2m_job_finish(param->mdp_ctx);
+		}
+		//cmdq_pkt_destroy(cmd.pkt);
+
+		atomic_dec(&mdp->job_count);
+		wake_up(&mdp->callback_wq);
+	} else {
+		struct mdp_cmdq_cb_param *cb_param, *cb_param_s;
+		struct mdp_comp *comps, *comps_s;
+
+		cb_param = kzalloc(sizeof(*cb_param), GFP_KERNEL);
+		if (!cb_param)
+			return -ENOMEM;
+		comps = kcalloc(param->config[PATH_0].num_components, sizeof(*comps),
+				GFP_KERNEL);
+		if (!comps) {
+			kfree(cb_param);
+			mdp_err("%s:comps alloc fail!\n", __func__);
+			return -ENOMEM;
+		}
+
+		for (i = 0; i < param->config[PATH_0].num_components; i++) {
+            if(is_dummy_engine(param->config[PATH_0].components[i].type))
+                continue;
+
+			memcpy(&comps[i], path_info[PATH_0].comps[i].comp,
+			       sizeof(struct mdp_comp));
+        }
+
+		cb_param->mdp = mdp;
+		cb_param->user_cmdq_cb = param->cmdq_cb;
+		cb_param->user_cb_data = param->cb_data;
+		cb_param->pkt = cmd.pkt;
+		cb_param->comps = comps;
+		cb_param->num_comps = param->config[PATH_0].num_components;
+		cb_param->mdp_ctx = param->mdp_ctx;
+
+		if (is_dual_pipe(scenario)) {
+			cb_param_s = kzalloc(sizeof(*cb_param_s), GFP_KERNEL);
+			if (!cb_param_s)
+				return -ENOMEM;
+			comps_s = kcalloc(param->config[PATH_1].num_components, sizeof(*comps_s),
+					GFP_KERNEL);
+			if (!comps_s) {
+				kfree(cb_param_s);
+				mdp_err("%s:comps alloc fail!\n", __func__);
+				return -ENOMEM;
+			}
+
+
+			for (i = 0; i < param->config[PATH_1].num_components; i++) {
+	            if(is_dummy_engine(param->config[PATH_1].components[i].type))
+	                continue;
+
+				memcpy(&comps_s[i], path_info[PATH_1].comps[i].comp,
+				       sizeof(struct mdp_comp));
+	        }
+
+			cb_param_s->mdp = mdp;
+			cb_param_s->user_cmdq_cb = param->cmdq_cb;
+			cb_param_s->user_cb_data = param->cb_data;
+			cb_param_s->pkt = cmd_s.pkt;
+			cb_param_s->comps = comps_s;
+			cb_param_s->num_comps = param->config[PATH_1].num_components;
+			cb_param_s->mdp_ctx = param->mdp_ctx;
+		}
+
+		if (atomic_read(&mdp->cmdq_count)) {
+			mdp_err("%s: Warning: cmdq_count:%d !\n", __func__, atomic_read(&mdp->cmdq_count));
+		}
+
+		atomic_inc(&mdp->cmdq_count);
+		ret = cmdq_pkt_flush_async(cmd.pkt,
+					   mdp_handle_cmdq_callback,
+					   (void *)cb_param);
+		if (ret) {
+			mdp_err("%s:cmdq_pkt_flush_async fail!\n", __func__);
+			kfree(cb_param);
+			kfree(comps);
+		}
+
+		if (is_dual_pipe(scenario)) {
+			atomic_inc(&mdp->cmdq_count);
+			ret = cmdq_pkt_flush_async(cmd_s.pkt,
+						   mdp_handle_cmdq_callback,
+						   (void *)cb_param_s);
+			if (ret) {
+				mdp_err("%s:cmdq_pkt_flush_async fail!\n", __func__);
+				kfree(cb_param_s);
+				kfree(comps_s);
+			}
+		}
+	}
 	return ret;
 }
 
 int mdp_cmdq_sendtask(struct platform_device *pdev, struct img_config *config,
-		      struct img_ipi_frameparam *param, struct v4l2_rect *compose,
+		      struct img_ipi_frameparam *param,
+		      struct v4l2_rect *compose, unsigned int wait,
 		      void (*cmdq_cb)(struct cmdq_cb_data data), void *cb_data)
 {
 	struct mdp_dev *mdp = platform_get_drvdata(pdev);
@@ -524,6 +1063,7 @@ int mdp_cmdq_sendtask(struct platform_device *pdev, struct img_config *config,
 		.config = config,
 		.param = param,
 		.composes[0] = compose,
+		.wait = wait,
 		.cmdq_cb = cmdq_cb,
 		.cb_data = cb_data,
 	};
diff --git a/drivers/media/platform/mtk-mdp3/mtk-mdp3-cmdq.h b/drivers/media/platform/mtk-mdp3/mtk-mdp3-cmdq.h
index c721b0ce0f9ea30db68d23356aa87b19daf9ef7c..a3260420144ae782ceee77468192ec2eeabb9997 100644
--- a/drivers/media/platform/mtk-mdp3/mtk-mdp3-cmdq.h
+++ b/drivers/media/platform/mtk-mdp3/mtk-mdp3-cmdq.h
@@ -15,7 +15,8 @@
 struct platform_device *mdp_get_plat_device(struct platform_device *pdev);
 
 int mdp_cmdq_sendtask(struct platform_device *pdev, struct img_config *config,
-		      struct img_ipi_frameparam *param, struct v4l2_rect *compose,
+		      struct img_ipi_frameparam *param,
+		      struct v4l2_rect *compose, unsigned int wait,
 		      void (*cmdq_cb)(struct cmdq_cb_data data), void *cb_data);
 
 struct mdp_cmd {
@@ -27,6 +28,7 @@ struct mdp_cmdq_param {
 	struct img_config *config;
 	struct img_ipi_frameparam *param;
 	const struct v4l2_rect *composes[IMG_MAX_HW_OUTPUTS];
+	unsigned int wait;
 
 	void (*cmdq_cb)(struct cmdq_cb_data data);
 	void *cb_data;
@@ -42,6 +44,7 @@ struct mdp_cmdq_cb_param {
 	struct mdp_comp *comps;
 	u8 num_comps;
 	void *mdp_ctx;
+	bool finalize;
 };
 
 struct mdp_dev;
diff --git a/drivers/media/platform/mtk-mdp3/mtk-mdp3-comp.c b/drivers/media/platform/mtk-mdp3/mtk-mdp3-comp.c
index 95f876c6f825b356057be8eeb001d772fda3e7b3..95a9b1aedfb4a34028b78a0eef870e331a90ef16 100644
--- a/drivers/media/platform/mtk-mdp3/mtk-mdp3-comp.c
+++ b/drivers/media/platform/mtk-mdp3/mtk-mdp3-comp.c
@@ -15,11 +15,22 @@
 #include "mdp-platform.h"
 #include "mmsys_config.h"
 #include "mdp_reg_rdma.h"
-#include "mdp_reg_ccorr.h"
 #include "mdp_reg_rsz.h"
+#include "mdp_reg_fg.h"
 #include "mdp_reg_wrot.h"
-#include "mdp_reg_wdma.h"
+#include "mdp_reg_aal.h"
+#include "mdp_reg_tdshp.h"
+#include "mdp_reg_hdr.h"
+#include "mdp_reg_color.h"
+#include "mdp_reg_ovl.h"
+#include "mdp_reg_pad.h"
 #include "isp_reg.h"
+#include "mmsys_mutex.h"
+
+//Roy Define
+//p.Cflags = append(p.Cflags, "-DDYN_CONTRAST_VERSION=2")
+#define DYN_CONTRAST_VERSION        (2)
+
 
 static s64 get_comp_flag(const struct mdp_comp_ctx *ctx)
 {
@@ -33,8 +44,8 @@ static s64 get_comp_flag(const struct mdp_comp_ctx *ctx)
 static int init_rdma(struct mdp_comp_ctx *ctx, struct mdp_cmd *cmd)
 {
 	phys_addr_t base = ctx->comp->reg_base;
-	u8 subsys_id = ctx->comp->subsys_id;
-#if RDMA0_RSZ1_SRAM_SHARING
+	u16 subsys_id = ctx->comp->subsys_id;
+#if 0//RDMA0_RSZ1_SRAM_SHARING
 	struct mdp_comp *prz1 = ctx->comp->mdp_dev->comp[MDP_SCL1];
 
 	/* Disable RSZ1 */
@@ -42,6 +53,7 @@ static int init_rdma(struct mdp_comp_ctx *ctx, struct mdp_cmd *cmd)
 		MM_REG_WRITE(cmd, subsys_id, prz1->reg_base, PRZ_ENABLE,
 			     0x00000000, 0x00000001);
 #endif
+
 	/* Reset RDMA */
 	MM_REG_WRITE(cmd, subsys_id, base, MDP_RDMA_RESET, 0x00000001,
 		     0x00000001);
@@ -56,19 +68,26 @@ static int config_rdma_frame(struct mdp_comp_ctx *ctx, struct mdp_cmd *cmd,
 			     const struct v4l2_rect *compose)
 {
 	const struct mdp_rdma_data *rdma = &ctx->param->rdma;
+	u32 width = ctx->input->buffer.format.width;
+	u32 height = ctx->input->buffer.format.height;
 	u32 colorformat = ctx->input->buffer.format.colorformat;
 	bool block10bit = MDP_COLOR_IS_10BIT_PACKED(colorformat);
 	bool en_ufo = MDP_COLOR_IS_UFP(colorformat);
 	phys_addr_t base = ctx->comp->reg_base;
-	u8 subsys_id = ctx->comp->subsys_id;
+	u16 subsys_id = ctx->comp->subsys_id;
+#ifdef MDP_RDMA_COMP_CON
+    u32 writeMask = 0;
+#endif
 
 #if RDMA_SUPPORT_10BIT
-	if (block10bit)
+	if (block10bit) {
 		MM_REG_WRITE(cmd, subsys_id, base, MDP_RDMA_RESV_DUMMY_0,
 			     0x00000007, 0x00000007);
-	else
+    }
+	else {
 		MM_REG_WRITE(cmd, subsys_id, base, MDP_RDMA_RESV_DUMMY_0,
 			     0x00000000, 0x00000007);
+    }
 #endif
 
 	/* Setup smi control */
@@ -80,7 +99,12 @@ static int config_rdma_frame(struct mdp_comp_ctx *ctx, struct mdp_cmd *cmd,
 
 	/* Setup source frame info */
 	MM_REG_WRITE(cmd, subsys_id, base, MDP_RDMA_SRC_CON, rdma->src_ctrl,
-		     0x03C8FE0F);
+//#ifndef MDP_VERSION_6885
+//                                            0x03C8FE0F);
+//#else
+                                            0x038CFE0F);
+//#endif
+
 #if RDMA_SUPPORT_10BIT
 	if (en_ufo) {
 		/* Setup source buffer base */
@@ -98,7 +122,42 @@ static int config_rdma_frame(struct mdp_comp_ctx *ctx, struct mdp_cmd *cmd,
 	}
 #endif
 	MM_REG_WRITE(cmd, subsys_id, base, MDP_RDMA_CON, rdma->control,
-		     0x00001110);
+		     0x00001130);
+
+#ifdef MDP_RDMA_COMP_CON
+#if HW_SUPPORT_EXTEND_UFO_FORMAT
+    writeMask |= 0xB0000000;
+#endif
+
+#ifdef DMA_SUPPORT_HYFBC
+    if (MDP_COLOR_IS_HYFBC_COMPRESS(colorformat))
+    {
+		/* Setup source buffer base */
+		MM_REG_WRITE(cmd, subsys_id, base,
+			MDP_RDMA_UFO_DEC_LENGTH_BASE_Y, rdma->ufo_dec_y, 0xFFFFFFFF);
+		MM_REG_WRITE(cmd, subsys_id, base,
+			MDP_RDMA_UFO_DEC_LENGTH_BASE_C, rdma->ufo_dec_c, 0xFFFFFFFF);
+
+		MM_REG_WRITE(cmd, subsys_id, base,
+		    MDP_RDMA_MF_BKGD_SIZE_IN_PXL,   ((width + 31) >> 5) << 5, 0x001FFFFF);
+		MM_REG_WRITE(cmd, subsys_id, base,
+		    MDP_RDMA_MF_BKGD_H_SIZE_IN_PXL, ((height + 7) >> 3) << 3, 0x001FFFFF);
+    }
+#endif
+#ifdef DMA_SUPPORT_AFBC
+    writeMask |= 0x0603000;
+    if (MDP_COLOR_IS_COMPRESS(colorformat))
+    {
+		MM_REG_WRITE(cmd, subsys_id, base,
+            MDP_RDMA_MF_BKGD_SIZE_IN_PXL,   ((width + 31) >> 5) << 5, 0x001FFFFF);
+		MM_REG_WRITE(cmd, subsys_id, base,
+            MDP_RDMA_MF_BKGD_H_SIZE_IN_PXL, ((height + 7) >> 3) << 3, 0x001FFFFF);
+    }
+#endif
+    /* Setup Compression Control */
+	MM_REG_WRITE(cmd, subsys_id, base, MDP_RDMA_COMP_CON, rdma->comp_ctrl, writeMask);
+#endif // MDP_RDMA_COMP_CON
+
 	/* Setup source buffer base */
 	MM_REG_WRITE(cmd, subsys_id, base, MDP_RDMA_SRC_BASE_0, rdma->iova[0],
 		     0xFFFFFFFF);
@@ -106,6 +165,7 @@ static int config_rdma_frame(struct mdp_comp_ctx *ctx, struct mdp_cmd *cmd,
 		     0xFFFFFFFF);
 	MM_REG_WRITE(cmd, subsys_id, base, MDP_RDMA_SRC_BASE_2, rdma->iova[2],
 		     0xFFFFFFFF);
+
 	/* Setup source buffer end */
 	MM_REG_WRITE(cmd, subsys_id, base, MDP_RDMA_SRC_END_0,
 		     rdma->iova_end[0], 0xFFFFFFFF);
@@ -122,6 +182,41 @@ static int config_rdma_frame(struct mdp_comp_ctx *ctx, struct mdp_cmd *cmd,
 	MM_REG_WRITE(cmd, subsys_id, base, MDP_RDMA_TRANSFORM_0,
 		     rdma->transform, 0x0F110000);
 
+#if ESL_SETTING
+    MM_REG_WRITE(cmd, subsys_id, base, MDP_RDMA_DMABUF_CON_0,
+        rdma->dmabuf_con0, 0x0FFF00FF);
+    MM_REG_WRITE(cmd, subsys_id, base, MDP_RDMA_ULTRA_TH_HIGH_CON_0,
+        rdma->ultra_th_high_con0, 0x3FFFFFFF);
+    MM_REG_WRITE(cmd, subsys_id, base, MDP_RDMA_ULTRA_TH_LOW_CON_0,
+        rdma->ultra_th_low_con0, 0x3FFFFFFF);
+    MM_REG_WRITE(cmd, subsys_id, base, MDP_RDMA_DMABUF_CON_1,
+        rdma->dmabuf_con1, 0x0F7F007F);
+    MM_REG_WRITE(cmd, subsys_id, base, MDP_RDMA_ULTRA_TH_HIGH_CON_1,
+        rdma->ultra_th_high_con1, 0x3FFFFFFF);
+    MM_REG_WRITE(cmd, subsys_id, base, MDP_RDMA_ULTRA_TH_LOW_CON_1,
+        rdma->ultra_th_low_con1, 0x3FFFFFFF);
+    MM_REG_WRITE(cmd, subsys_id, base, MDP_RDMA_DMABUF_CON_2,
+        rdma->dmabuf_con2, 0x0F3F003F);
+    MM_REG_WRITE(cmd, subsys_id, base, MDP_RDMA_ULTRA_TH_HIGH_CON_2,
+        rdma->ultra_th_high_con2, 0x3FFFFFFF);
+    MM_REG_WRITE(cmd, subsys_id, base, MDP_RDMA_ULTRA_TH_LOW_CON_2,
+        rdma->ultra_th_low_con2, 0x3FFFFFFF);
+    MM_REG_WRITE(cmd, subsys_id, base, MDP_RDMA_DMABUF_CON_3,
+        rdma->dmabuf_con3, 0x0F3F003F);
+#else
+    MM_REG_WRITE(cmd, subsys_id, base, MDP_RDMA_DMAULTRA_CON_0,
+        0x08080808, 0xFFFFFFFF);
+    MM_REG_WRITE(cmd, subsys_id, base, MDP_RDMA_DMAULTRA_CON_1,
+        0x04040404, 0xFFFFFFFF);
+    MM_REG_WRITE(cmd, subsys_id, base, MDP_RDMA_DMAULTRA_CON_2,
+        0x04040404, 0xFFFFFFFF);
+    MM_REG_WRITE(cmd, subsys_id, base, MDP_RDMA_DMABUF_CON_0,
+        (7 << 24) + 0x24, 0x700007
+    MM_REG_WRITE(cmd, subsys_id, base, MDP_RDMA_DMABUF_CON_1,
+        (3 << 24) + 0x13, 0x700003
+    MM_REG_WRITE(cmd, subsys_id, base, MDP_RDMA_DMABUF_CON_2,
+        (3 << 24) + 0x13, 0x700001
+#endif
 	return 0;
 }
 
@@ -129,46 +224,58 @@ static int config_rdma_subfrm(struct mdp_comp_ctx *ctx,
 			      struct mdp_cmd *cmd, u32 index)
 {
 	const struct mdp_rdma_subfrm *subfrm = &ctx->param->rdma.subfrms[index];
+#if RDMA_UPSAMPLE_REPEAT_ONLY
 	const struct img_comp_subfrm *csf = &ctx->param->subfrms[index];
+#endif
 	u32 colorformat = ctx->input->buffer.format.colorformat;
 	bool block10bit = MDP_COLOR_IS_10BIT_PACKED(colorformat);
 	bool en_ufo = MDP_COLOR_IS_UFP(colorformat);
 	phys_addr_t base = ctx->comp->reg_base;
-	u8 subsys_id = ctx->comp->subsys_id;
+	u16 subsys_id = ctx->comp->subsys_id;
 
 	/* Enable RDMA */
 	MM_REG_WRITE(cmd, subsys_id, base, MDP_RDMA_EN, 0x00000001,
 		     0x00000001);
 
+    if (MDP_COLOR_IS_COMPRESS(colorformat) ||
+        MDP_COLOR_IS_HYFBC_COMPRESS(colorformat))
+    {
+    	MM_REG_WRITE(cmd, subsys_id, base, MDP_RDMA_SRC_OFFSET_WP,
+			subfrm->in_tile_xleft, 0xFFFFFFFF);
+    	MM_REG_WRITE(cmd, subsys_id, base, MDP_RDMA_SRC_OFFSET_HP,
+			subfrm->in_tile_ytop, 0xFFFFFFFF);
+    }
+
 	/* Set Y pixel offset */
 	MM_REG_WRITE(cmd, subsys_id, base, MDP_RDMA_SRC_OFFSET_0,
 		     subfrm->offset[0], 0xFFFFFFFF);
 #if RDMA_SUPPORT_10BIT
 	/* Set 10bit UFO mode */
-	if (block10bit && en_ufo)
+	if (block10bit && en_ufo) {
 		MM_REG_WRITE(cmd, subsys_id, base, MDP_RDMA_SRC_OFFSET_0_P,
-			     subfrm->offset_0_p, 0xFFFFFFFF);
+			subfrm->offset_0_p, 0xFFFFFFFF);
+	}
 #endif
 	/* Set U pixel offset */
 	MM_REG_WRITE(cmd, subsys_id, base, MDP_RDMA_SRC_OFFSET_1,
-		     subfrm->offset[1], 0xFFFFFFFF);
+			subfrm->offset[1], 0xFFFFFFFF);
 	/* Set V pixel offset */
 	MM_REG_WRITE(cmd, subsys_id, base, MDP_RDMA_SRC_OFFSET_2,
-		     subfrm->offset[2], 0xFFFFFFFF);
+			subfrm->offset[2], 0xFFFFFFFF);
 	/* Set source size */
-	MM_REG_WRITE(cmd, subsys_id, base, MDP_RDMA_MF_SRC_SIZE, subfrm->src,
-		     0x1FFF1FFF);
+	MM_REG_WRITE(cmd, subsys_id, base, MDP_RDMA_MF_SRC_SIZE,
+			subfrm->src, 0x1FFF1FFF);
 	/* Set target size */
 	MM_REG_WRITE(cmd, subsys_id, base, MDP_RDMA_MF_CLIP_SIZE,
-		     subfrm->clip, 0x1FFF1FFF);
+			subfrm->clip, 0x1FFF1FFF);
 	/* Set crop offset */
 	MM_REG_WRITE(cmd, subsys_id, base, MDP_RDMA_MF_OFFSET_1,
-		     subfrm->clip_ofst, 0x003F001F);
+			subfrm->clip_ofst, 0x003F001F);
 
 #if RDMA_UPSAMPLE_REPEAT_ONLY
 	if ((csf->in.right - csf->in.left + 1) > 320)
 		MM_REG_WRITE(cmd, subsys_id, base, MDP_RDMA_RESV_DUMMY_0,
-			     0x00000004, 0x00000004);
+			0x00000004, 0x00000004);
 #endif
 
 	return 0;
@@ -177,12 +284,25 @@ static int config_rdma_subfrm(struct mdp_comp_ctx *ctx,
 static int wait_rdma_event(struct mdp_comp_ctx *ctx, struct mdp_cmd *cmd)
 {
 	phys_addr_t base = ctx->comp->reg_base;
-	u8 subsys_id = ctx->comp->subsys_id;
-
-	if (ctx->comp->alias_id == 0)
-		MM_REG_WAIT(cmd, RDMA0_DONE);
-	else
-		pr_err("Do not support RDMA1_DONE event\n");
+	u16 subsys_id = ctx->comp->subsys_id;
+
+    switch (ctx->comp->alias_id)
+    {
+        case 0:
+            MM_REG_WAIT(cmd, RDMA0_FRAME_DONE);
+            break;
+        case 1:
+            MM_REG_WAIT(cmd, RDMA1_FRAME_DONE);
+            break;
+        case 2:
+            MM_REG_WAIT(cmd, RDMA2_FRAME_DONE);
+            break;
+        case 3:
+            MM_REG_WAIT(cmd, RDMA3_FRAME_DONE);
+            break;
+        default:
+    		pr_err("Invalid Engine!\n");
+    }
 
 	/* Disable RDMA */
 	MM_REG_WRITE(cmd, subsys_id, base, MDP_RDMA_EN, 0x00000000,
@@ -202,10 +322,121 @@ static const struct mdp_comp_ops rdma_ops = {
 	.post_process = NULL,
 };
 
+static int init_split(struct mdp_comp_ctx *ctx, struct mdp_cmd *cmd)
+{
+	return 0;
+}
+
+static int config_split_frame(struct mdp_comp_ctx *ctx, struct mdp_cmd *cmd,
+			    const struct v4l2_rect *compose)
+{
+	return 0;
+}
+
+static int config_split_subfrm(struct mdp_comp_ctx *ctx,
+			      struct mdp_cmd *cmd, u32 index)
+{
+	return 0;
+}
+
+static const struct mdp_comp_ops split_ops = {
+	.get_comp_flag = get_comp_flag,
+	.init_comp = init_split,
+	.config_frame = config_split_frame,
+	.config_subfrm = config_split_subfrm,
+	/* .reconfig_frame = NULL, */
+	/* .reconfig_subfrms = NULL, */
+	.wait_comp_event = NULL,
+	.advance_subfrm = NULL,
+	.post_process = NULL,
+};
+
+static int init_stitch(struct mdp_comp_ctx *ctx, struct mdp_cmd *cmd)
+{
+	return 0;
+}
+
+static int config_stitch_frame(struct mdp_comp_ctx *ctx, struct mdp_cmd *cmd,
+			    const struct v4l2_rect *compose)
+{
+	return 0;
+}
+
+static int config_stitch_subfrm(struct mdp_comp_ctx *ctx,
+			      struct mdp_cmd *cmd, u32 index)
+{
+	return 0;
+}
+
+static const struct mdp_comp_ops stitch_ops = {
+	.get_comp_flag = get_comp_flag,
+	.init_comp = init_stitch,
+	.config_frame = config_stitch_frame,
+	.config_subfrm = config_stitch_subfrm,
+	/* .reconfig_frame = NULL, */
+	/* .reconfig_subfrms = NULL, */
+	.wait_comp_event = NULL,
+	.advance_subfrm = NULL,
+	.post_process = NULL,
+};
+
+static int init_fg(struct mdp_comp_ctx *ctx, struct mdp_cmd *cmd)
+{
+	phys_addr_t base = ctx->comp->reg_base;
+	u16 subsys_id = ctx->comp->subsys_id;
+
+	MM_REG_WRITE_MASK(cmd, subsys_id, base, MDP_FG_TRIGGER, (0x00000001<<2),
+		     0x00000004);
+	MM_REG_WRITE_MASK(cmd, subsys_id, base, MDP_FG_TRIGGER, 0x00000000,
+		     0x00000004);
+
+	return 0;
+}
+
+static int config_fg_frame(struct mdp_comp_ctx *ctx, struct mdp_cmd *cmd,
+			    const struct v4l2_rect *compose)
+{
+	const struct mdp_fg_data *fg = &ctx->param->fg;
+	phys_addr_t base = ctx->comp->reg_base;
+	u16 subsys_id = ctx->comp->subsys_id;
+
+    MM_REG_WRITE_MASK(cmd, subsys_id, base, MDP_FG_FG_CTRL_0, fg->ctrl_0, 0x1);
+    MM_REG_WRITE_MASK(cmd, subsys_id, base, MDP_FG_FG_CK_EN, fg->ck_en, 0x7);
+	return 0;
+}
+
+static int config_fg_subfrm(struct mdp_comp_ctx *ctx,
+			      struct mdp_cmd *cmd, u32 index)
+{
+	const struct mdp_fg_subfrm *subfrm = &ctx->param->fg.subfrms[index];
+	phys_addr_t base = ctx->comp->reg_base;
+	u16 subsys_id = ctx->comp->subsys_id;
+
+    MM_REG_WRITE(cmd, subsys_id, base, MDP_FG_TILE_INFO_0, subfrm->info_0, 0xFFFFFFFF);
+    MM_REG_WRITE(cmd, subsys_id, base, MDP_FG_TILE_INFO_1, subfrm->info_1, 0xFFFFFFFF);
+
+	return 0;
+}
+
+static const struct mdp_comp_ops fg_ops = {
+	.get_comp_flag = get_comp_flag,
+	.init_comp = init_fg,
+	.config_frame = config_fg_frame,
+	.config_subfrm = config_fg_subfrm,
+	/* .reconfig_frame = NULL, */
+	/* .reconfig_subfrms = NULL, */
+	.wait_comp_event = NULL,
+	.advance_subfrm = NULL,
+	.post_process = NULL,
+};
+
 static int init_rsz(struct mdp_comp_ctx *ctx, struct mdp_cmd *cmd)
 {
 	phys_addr_t base = ctx->comp->reg_base;
-	u8 subsys_id = ctx->comp->subsys_id;
+	u16 subsys_id = ctx->comp->subsys_id;
+
+	phys_addr_t vpp1_base = ctx->comp->vpp1_base;
+	u16 vpp1_id = ctx->comp->vpp1_subsys_id;
 
 	/* Reset RSZ */
 	MM_REG_WRITE(cmd, subsys_id, base, PRZ_ENABLE, 0x00010000,
@@ -215,6 +446,14 @@ static int init_rsz(struct mdp_comp_ctx *ctx, struct mdp_cmd *cmd)
 	/* Enable RSZ */
 	MM_REG_WRITE(cmd, subsys_id, base, PRZ_ENABLE, 0x00000001,
 		     0x00000001);
+
+#if 1 // VPPSYS1 CONFIG RSZ DCM
+	MM_REG_WRITE_MASK(cmd, vpp1_id, vpp1_base, VPPSYS1_HW_DCM_1ST_DIS0, 1 << 25, 1 << 25);
+	MM_REG_WRITE_MASK(cmd, vpp1_id, vpp1_base, VPPSYS1_HW_DCM_1ST_DIS1, 1 << 4 | 1 << 5, 1 << 4 | 1 << 5);
+	MM_REG_WRITE_MASK(cmd, vpp1_id, vpp1_base, VPPSYS1_HW_DCM_2ND_DIS0, 1 << 25, 1 << 25);
+	MM_REG_WRITE_MASK(cmd, vpp1_id, vpp1_base, VPPSYS1_HW_DCM_2ND_DIS1, 1 << 4 | 1 << 5, 1 << 4 | 1 << 5);
+#endif
+
 	return 0;
 }
 
@@ -223,7 +462,11 @@ static int config_rsz_frame(struct mdp_comp_ctx *ctx, struct mdp_cmd *cmd,
 {
 	const struct mdp_rsz_data *rsz = &ctx->param->rsz;
 	phys_addr_t base = ctx->comp->reg_base;
-	u8 subsys_id = ctx->comp->subsys_id;
+	u16 subsys_id = ctx->comp->subsys_id;
+
+#ifdef RSZ_ETC_CONTROL
+		MM_REG_WRITE(cmd, subsys_id, base, RSZ_ETC_CONTROL, 0x0, 0xFFFFFFFF);
+#endif
 
 	if (ctx->param->frame.bypass) {
 		/* Disable RSZ */
@@ -233,14 +476,15 @@ static int config_rsz_frame(struct mdp_comp_ctx *ctx, struct mdp_cmd *cmd,
 		return 0;
 	}
 
-	MM_REG_WRITE(cmd, subsys_id, base, PRZ_CONTROL_1, rsz->control1,
-		     0x03FFFDF3);
-	MM_REG_WRITE(cmd, subsys_id, base, PRZ_CONTROL_2, rsz->control2,
-		     0x0FFFC290);
+	MM_REG_WRITE(cmd, subsys_id, base, PRZ_CONTROL_1,
+			rsz->control1, 0x03FFFDF3);
+	MM_REG_WRITE(cmd, subsys_id, base, PRZ_CONTROL_2,
+			rsz->control2, 0x0FFFC290);
 	MM_REG_WRITE(cmd, subsys_id, base, PRZ_HORIZONTAL_COEFF_STEP,
-		     rsz->coeff_step_x, 0x007FFFFF);
+			rsz->coeff_step_x, 0x007FFFFF);
 	MM_REG_WRITE(cmd, subsys_id, base, PRZ_VERTICAL_COEFF_STEP,
-		     rsz->coeff_step_y, 0x007FFFFF);
+			rsz->coeff_step_y, 0x007FFFFF);
+
 	return 0;
 }
 
@@ -250,36 +494,72 @@ static int config_rsz_subfrm(struct mdp_comp_ctx *ctx,
 	const struct mdp_rsz_subfrm *subfrm = &ctx->param->rsz.subfrms[index];
 	const struct img_comp_subfrm *csf = &ctx->param->subfrms[index];
 	phys_addr_t base = ctx->comp->reg_base;
-	u8 subsys_id = ctx->comp->subsys_id;
+	u16 subsys_id = ctx->comp->subsys_id;
+
+	phys_addr_t aux_base = ctx->comp->aux_base;
+	u16 aux_id = ctx->comp->aux_subsys_id;
+
+	phys_addr_t vpp1_base = ctx->comp->vpp1_base;
+	u16 vpp1_id = ctx->comp->vpp1_subsys_id;
 
-	MM_REG_WRITE(cmd, subsys_id, base, PRZ_CONTROL_2, subfrm->control2,
-		     0x00003800);
-	MM_REG_WRITE(cmd, subsys_id, base, PRZ_INPUT_IMAGE, subfrm->src,
-		     0xFFFFFFFF);
-#if RSZ_DISABLE_DCM_SMALL_TILE
-	if ((csf->in.right - csf->in.left + 1) <= 16)
-		MM_REG_WRITE(cmd, subsys_id, base, PRZ_CONTROL_1, 1 << 27,
-			     1 << 27);
-#endif
 	MM_REG_WRITE(cmd, subsys_id, base, PRZ_LUMA_HORIZONTAL_INTEGER_OFFSET,
 		     csf->luma.left, 0x0000FFFF);
-	MM_REG_WRITE(cmd, subsys_id,
-		     base, PRZ_LUMA_HORIZONTAL_SUBPIXEL_OFFSET,
+	MM_REG_WRITE(cmd, subsys_id, base, PRZ_LUMA_HORIZONTAL_SUBPIXEL_OFFSET,
 		     csf->luma.left_subpix, 0x001FFFFF);
 	MM_REG_WRITE(cmd, subsys_id, base, PRZ_LUMA_VERTICAL_INTEGER_OFFSET,
 		     csf->luma.top, 0x0000FFFF);
 	MM_REG_WRITE(cmd, subsys_id, base, PRZ_LUMA_VERTICAL_SUBPIXEL_OFFSET,
 		     csf->luma.top_subpix, 0x001FFFFF);
-	MM_REG_WRITE(cmd, subsys_id,
-		     base, PRZ_CHROMA_HORIZONTAL_INTEGER_OFFSET,
+	MM_REG_WRITE(cmd, subsys_id, base, PRZ_CHROMA_HORIZONTAL_INTEGER_OFFSET,
 		     csf->chroma.left, 0x0000FFFF);
-	MM_REG_WRITE(cmd, subsys_id,
-		     base, PRZ_CHROMA_HORIZONTAL_SUBPIXEL_OFFSET,
+	MM_REG_WRITE(cmd, subsys_id, base, PRZ_CHROMA_HORIZONTAL_SUBPIXEL_OFFSET,
 		     csf->chroma.left_subpix, 0x001FFFFF);
 
-	MM_REG_WRITE(cmd, subsys_id, base, PRZ_OUTPUT_IMAGE, subfrm->clip,
+	MM_REG_WRITE(cmd, subsys_id, base, PRZ_OUTPUT_IMAGE,
+             subfrm->clip, 0xFFFFFFFF);
+
+
+	MM_REG_WRITE(cmd, subsys_id, base, PRZ_CONTROL_2, subfrm->control2,
+		     0x00003800);
+	MM_REG_WRITE(cmd, subsys_id, base, PRZ_INPUT_IMAGE, subfrm->src,
 		     0xFFFFFFFF);
 
+#if RSZ_DISABLE_DCM_SMALL_TILE
+	if ((csf->in.right - csf->in.left + 1) <= 16)
+		MM_REG_WRITE(cmd, subsys_id, base, PRZ_CONTROL_1, 1 << 27,
+			     1 << 27);
+#endif
+
+#if 1 //def MDP_VERSION_8195
+#include "mdp_reg_merge.h"
+	if(ctx->comp->id == MDP_COMP_RSZ2) {
+		MM_REG_WRITE_MASK(cmd, vpp1_id, vpp1_base, SVPP2_BUF_BF_RSZ_SWITCH,
+			subfrm->rsz_switch, 0xFFFFFFFF);
+	}
+	else if(ctx->comp->id == MDP_COMP_RSZ3) {
+		MM_REG_WRITE_MASK(cmd, vpp1_id, vpp1_base, SVPP3_BUF_BF_RSZ_SWITCH,
+			subfrm->rsz_switch, 0xFFFFFFFF);
+	}
+	else {
+		goto subfrm_done;
+	}
+
+	MM_REG_WRITE(cmd, aux_id, aux_base, VPP_MERGE_CFG_0,
+		subfrm->merge_cfg, 0xFFFFFFFF);
+	MM_REG_WRITE(cmd, aux_id, aux_base, VPP_MERGE_CFG_4,
+		subfrm->merge_cfg, 0xFFFFFFFF);
+	MM_REG_WRITE(cmd, aux_id, aux_base, VPP_MERGE_CFG_24,
+		subfrm->merge_cfg, 0xFFFFFFFF);
+	MM_REG_WRITE(cmd, aux_id, aux_base, VPP_MERGE_CFG_25,
+		subfrm->merge_cfg, 0xFFFFFFFF);
+
+	MM_REG_WRITE(cmd, aux_id, aux_base, VPP_MERGE_CFG_12,
+		0x1, 0xFFFFFFFF); // bypass mode
+	MM_REG_WRITE(cmd, aux_id, aux_base, VPP_MERGE_ENABLE,
+		0x1, 0xFFFFFFFF);
+#endif
+
+subfrm_done:
 	return 0;
 }
 
@@ -289,7 +569,7 @@ static int advance_rsz_subfrm(struct mdp_comp_ctx *ctx,
 #if RSZ_DISABLE_DCM_SMALL_TILE
 	const struct img_comp_subfrm *csf = &ctx->param->subfrms[index];
 	phys_addr_t base = ctx->comp->reg_base;
-	u8 subsys_id = ctx->comp->subsys_id;
+	u16 subsys_id = ctx->comp->subsys_id;
 
 	if ((csf->in.right - csf->in.left + 1) <= 16)
 		MM_REG_WRITE(cmd, subsys_id, base, PRZ_CONTROL_1, 0, 1 << 27);
@@ -309,295 +589,641 @@ static const struct mdp_comp_ops rsz_ops = {
 	.post_process = NULL,
 };
 
-static int init_wrot(struct mdp_comp_ctx *ctx, struct mdp_cmd *cmd)
+static int init_aal(struct mdp_comp_ctx *ctx, struct mdp_cmd *cmd)
 {
 	phys_addr_t base = ctx->comp->reg_base;
-	u8 subsys_id = ctx->comp->subsys_id;
+	u16 subsys_id = ctx->comp->subsys_id;
+
+	// Always set MDP_AAL enable to 1
+    MM_REG_WRITE(cmd, subsys_id, base, MDP_AAL_EN, 0x1, 0x1);
 
-#if WROT_FILTER_CONSTRAINT
-	/* Wait WROT SRAM shared to DISP RDMA */
-	if (ctx->comp->alias_id == 0)
-		pr_err("Do not support WROT0_SRAM_READY event\n");
-	else
-		pr_err("Do not support WROT1_SRAM_READY event\n");
-#endif
-	/* Reset WROT */
-	MM_REG_WRITE(cmd, subsys_id, base, VIDO_SOFT_RST, 0x01, 0x00000001);
-	MM_REG_POLL(cmd, subsys_id, base, VIDO_SOFT_RST_STAT, 0x01,
-		    0x00000001);
-	MM_REG_WRITE(cmd, subsys_id, base, VIDO_SOFT_RST, 0x00, 0x00000001);
-	MM_REG_POLL(cmd, subsys_id, base, VIDO_SOFT_RST_STAT, 0x00,
-		    0x00000001);
 	return 0;
 }
 
-static int config_wrot_frame(struct mdp_comp_ctx *ctx, struct mdp_cmd *cmd,
-			     const struct v4l2_rect *compose)
+static int config_aal_frame(struct mdp_comp_ctx *ctx, struct mdp_cmd *cmd,
+			    const struct v4l2_rect *compose)
 {
-	const struct mdp_wrot_data *wrot = &ctx->param->wrot;
+	const struct mdp_aal_data *aal = &ctx->param->aal;
 	phys_addr_t base = ctx->comp->reg_base;
-	u8 subsys_id = ctx->comp->subsys_id;
+	u16 subsys_id = ctx->comp->subsys_id;
 
-	/* Write frame base address */
-	MM_REG_WRITE(cmd, subsys_id, base, VIDO_BASE_ADDR, wrot->iova[0],
-		     0xFFFFFFFF);
-	MM_REG_WRITE(cmd, subsys_id, base, VIDO_BASE_ADDR_C, wrot->iova[1],
-		     0xFFFFFFFF);
-	MM_REG_WRITE(cmd, subsys_id, base, VIDO_BASE_ADDR_V, wrot->iova[2],
-		     0xFFFFFFFF);
-	/* Write frame related registers */
-	MM_REG_WRITE(cmd, subsys_id, base, VIDO_CTRL, wrot->control,
-		     0xF131510F);
-	/* Write frame Y pitch */
-	MM_REG_WRITE(cmd, subsys_id, base, VIDO_STRIDE, wrot->stride[0],
-		     0x0000FFFF);
-	/* Write frame UV pitch */
-	MM_REG_WRITE(cmd, subsys_id, base, VIDO_STRIDE_C, wrot->stride[1],
-		     0x0000FFFF);
-	MM_REG_WRITE(cmd, subsys_id, base, VIDO_STRIDE_V, wrot->stride[2],
-		     0x0000FFFF);
-	/* Write matrix control */
-	MM_REG_WRITE(cmd, subsys_id, base, VIDO_MAT_CTRL, wrot->mat_ctrl,
-		     0x000000F3);
+    MM_REG_WRITE(cmd, subsys_id, base, MDP_AAL_CFG_MAIN, aal->cfg_main, 0x80);
+    MM_REG_WRITE(cmd, subsys_id, base, MDP_AAL_CFG, aal->cfg, 0x1);
 
-	/* Set the fixed ALPHA as 0xFF */
-	MM_REG_WRITE(cmd, subsys_id, base, VIDO_DITHER, 0xFF000000,
-		     0xFF000000);
-	/* Set VIDO_EOL_SEL */
-	MM_REG_WRITE(cmd, subsys_id, base, VIDO_RSV_1, 0x80000000,
-		     0x80000000);
-	/* Set VIDO_FIFO_TEST */
-	if (wrot->fifo_test != 0)
-		MM_REG_WRITE(cmd, subsys_id, base, VIDO_FIFO_TEST,
-			     wrot->fifo_test, 0x00000FFF);
+	return 0;
+}
 
-#if WROT_FILTER_CONSTRAINT
-	/* Filter enable */
-	MM_REG_WRITE(cmd, subsys_id, base, VIDO_MAIN_BUF_SIZE, wrot->filter,
-		     0x00000077);
+static int config_aal_subfrm(struct mdp_comp_ctx *ctx,
+			      struct mdp_cmd *cmd, u32 index)
+{
+	const struct mdp_aal_subfrm *subfrm = &ctx->param->aal.subfrms[index];
+	phys_addr_t base = ctx->comp->reg_base;
+	u16 subsys_id = ctx->comp->subsys_id;
+
+    MM_REG_WRITE(cmd, subsys_id, base, MDP_AAL_SIZE, subfrm->src, MDP_AAL_SIZE_MASK);
+    MM_REG_WRITE(cmd, subsys_id, base, MDP_AAL_OUTPUT_OFFSET, subfrm->clip_ofst, 0x00FF00FF);
+    MM_REG_WRITE(cmd, subsys_id, base, MDP_AAL_OUTPUT_SIZE, subfrm->clip, MDP_AAL_OUTPUT_SIZE_MASK);
+
+	return 0;
+}
+
+static const struct mdp_comp_ops aal_ops = {
+	.get_comp_flag = get_comp_flag,
+	.init_comp = init_aal,
+	.config_frame = config_aal_frame,
+	.config_subfrm = config_aal_subfrm,
+	/* .reconfig_frame = NULL, */
+	/* .reconfig_subfrms = NULL, */
+	.wait_comp_event = NULL,
+	.advance_subfrm = NULL,
+	.post_process = NULL,
+};
+
+static int init_hdr(struct mdp_comp_ctx *ctx, struct mdp_cmd *cmd)
+{
+	phys_addr_t base = ctx->comp->reg_base;
+	u16 subsys_id = ctx->comp->subsys_id;
+
+	// Always set MDP_HDR enable to 1
+    MM_REG_WRITE(cmd, subsys_id, base, MDP_HDR_TOP, 1, 0x1);
+
+	return 0;
+}
+
+static int config_hdr_frame(struct mdp_comp_ctx *ctx, struct mdp_cmd *cmd,
+			    const struct v4l2_rect *compose)
+{
+	const struct mdp_hdr_data *hdr = &ctx->param->hdr;
+	phys_addr_t base = ctx->comp->reg_base;
+	u16 subsys_id = ctx->comp->subsys_id;
+
+    MM_REG_WRITE(cmd, subsys_id, base, MDP_HDR_TOP, hdr->top, 0x30000000);
+    MM_REG_WRITE(cmd, subsys_id, base, MDP_HDR_RELAY, hdr->relay, 0x1);
+
+	return 0;
+}
+
+static int config_hdr_subfrm(struct mdp_comp_ctx *ctx,
+			      struct mdp_cmd *cmd, u32 index)
+{
+	const struct mdp_hdr_subfrm *subfrm = &ctx->param->hdr.subfrms[index];
+	phys_addr_t base = ctx->comp->reg_base;
+	u16 subsys_id = ctx->comp->subsys_id;
+
+    MM_REG_WRITE(cmd, subsys_id, base, MDP_HDR_TILE_POS, subfrm->win_size, MDP_HDR_TILE_POS_MASK);
+    MM_REG_WRITE(cmd, subsys_id, base, MDP_HDR_SIZE_0, subfrm->src, 0x1FFF1FFF);
+    MM_REG_WRITE(cmd, subsys_id, base, MDP_HDR_SIZE_1, subfrm->clip_ofst0, 0x1FFF1FFF);
+    MM_REG_WRITE(cmd, subsys_id, base, MDP_HDR_SIZE_2, subfrm->clip_ofst1, 0x1FFF1FFF);
+    MM_REG_WRITE(cmd, subsys_id, base, MDP_HDR_HIST_CTRL_0, subfrm->hist_ctrl_0, 0x00003FFF);
+    MM_REG_WRITE(cmd, subsys_id, base, MDP_HDR_HIST_CTRL_1, subfrm->hist_ctrl_1, 0x00003FFF);
+
+    MM_REG_WRITE(cmd, subsys_id, base, MDP_HDR_TOP, subfrm->hdr_top, 0x00000060);
+    MM_REG_WRITE(cmd, subsys_id, base, MDP_HDR_HIST_ADDR, subfrm->hist_addr, 0x00000200); //enable hist_clr_en
+
+	return 0;
+}
+
+static const struct mdp_comp_ops hdr_ops = {
+	.get_comp_flag = get_comp_flag,
+	.init_comp = init_hdr,
+	.config_frame = config_hdr_frame,
+	.config_subfrm = config_hdr_subfrm,
+	/* .reconfig_frame = NULL, */
+	/* .reconfig_subfrms = NULL, */
+	.wait_comp_event = NULL,
+	.advance_subfrm = NULL,
+	.post_process = NULL,
+};
+
+void resetLumaHist(struct mdp_comp_ctx *ctx, struct mdp_cmd *cmd)
+{
+	phys_addr_t base = ctx->comp->reg_base;
+	u16 subsys_id = ctx->comp->subsys_id;
+
+    // reset LUMA HIST
+    MM_REG_WRITE(cmd, subsys_id, base, MDP_LUMA_HIST_INIT_00, 0, 0xFFFFFFFF);
+    MM_REG_WRITE(cmd, subsys_id, base, MDP_LUMA_HIST_INIT_01, 0, 0xFFFFFFFF);
+    MM_REG_WRITE(cmd, subsys_id, base, MDP_LUMA_HIST_INIT_02, 0, 0xFFFFFFFF);
+    MM_REG_WRITE(cmd, subsys_id, base, MDP_LUMA_HIST_INIT_03, 0, 0xFFFFFFFF);
+    MM_REG_WRITE(cmd, subsys_id, base, MDP_LUMA_HIST_INIT_04, 0, 0xFFFFFFFF);
+    MM_REG_WRITE(cmd, subsys_id, base, MDP_LUMA_HIST_INIT_05, 0, 0xFFFFFFFF);
+    MM_REG_WRITE(cmd, subsys_id, base, MDP_LUMA_HIST_INIT_06, 0, 0xFFFFFFFF);
+    MM_REG_WRITE(cmd, subsys_id, base, MDP_LUMA_HIST_INIT_07, 0, 0xFFFFFFFF);
+    MM_REG_WRITE(cmd, subsys_id, base, MDP_LUMA_HIST_INIT_08, 0, 0xFFFFFFFF);
+    MM_REG_WRITE(cmd, subsys_id, base, MDP_LUMA_HIST_INIT_09, 0, 0xFFFFFFFF);
+    MM_REG_WRITE(cmd, subsys_id, base, MDP_LUMA_HIST_INIT_10, 0, 0xFFFFFFFF);
+    MM_REG_WRITE(cmd, subsys_id, base, MDP_LUMA_HIST_INIT_11, 0, 0xFFFFFFFF);
+    MM_REG_WRITE(cmd, subsys_id, base, MDP_LUMA_HIST_INIT_12, 0, 0xFFFFFFFF);
+    MM_REG_WRITE(cmd, subsys_id, base, MDP_LUMA_HIST_INIT_13, 0, 0xFFFFFFFF);
+    MM_REG_WRITE(cmd, subsys_id, base, MDP_LUMA_HIST_INIT_14, 0, 0xFFFFFFFF);
+    MM_REG_WRITE(cmd, subsys_id, base, MDP_LUMA_HIST_INIT_15, 0, 0xFFFFFFFF);
+    MM_REG_WRITE(cmd, subsys_id, base, MDP_LUMA_HIST_INIT_16, 0, 0xFFFFFFFF);
+    MM_REG_WRITE(cmd, subsys_id, base, MDP_LUMA_SUM_INIT, 0, 0xFFFFFFFF);
+#ifdef TDSHP_1_1
+    MM_REG_WRITE(cmd, subsys_id, base, MDP_DC_TWO_D_W1_RESULT_INIT, 0, 0xFFFFFFFF);
+#endif
+
+#if DYN_CONTRAST_VERSION == 2
+    MM_REG_WRITE(cmd, subsys_id, base, MDP_CONTOUR_HIST_INIT_00, 0, 0xFFFFFFFF);
+    MM_REG_WRITE(cmd, subsys_id, base, MDP_CONTOUR_HIST_INIT_01, 0, 0xFFFFFFFF);
+    MM_REG_WRITE(cmd, subsys_id, base, MDP_CONTOUR_HIST_INIT_02, 0, 0xFFFFFFFF);
+    MM_REG_WRITE(cmd, subsys_id, base, MDP_CONTOUR_HIST_INIT_03, 0, 0xFFFFFFFF);
+    MM_REG_WRITE(cmd, subsys_id, base, MDP_CONTOUR_HIST_INIT_04, 0, 0xFFFFFFFF);
+    MM_REG_WRITE(cmd, subsys_id, base, MDP_CONTOUR_HIST_INIT_05, 0, 0xFFFFFFFF);
+    MM_REG_WRITE(cmd, subsys_id, base, MDP_CONTOUR_HIST_INIT_06, 0, 0xFFFFFFFF);
+    MM_REG_WRITE(cmd, subsys_id, base, MDP_CONTOUR_HIST_INIT_07, 0, 0xFFFFFFFF);
+    MM_REG_WRITE(cmd, subsys_id, base, MDP_CONTOUR_HIST_INIT_08, 0, 0xFFFFFFFF);
+    MM_REG_WRITE(cmd, subsys_id, base, MDP_CONTOUR_HIST_INIT_09, 0, 0xFFFFFFFF);
+    MM_REG_WRITE(cmd, subsys_id, base, MDP_CONTOUR_HIST_INIT_10, 0, 0xFFFFFFFF);
+    MM_REG_WRITE(cmd, subsys_id, base, MDP_CONTOUR_HIST_INIT_11, 0, 0xFFFFFFFF);
+    MM_REG_WRITE(cmd, subsys_id, base, MDP_CONTOUR_HIST_INIT_12, 0, 0xFFFFFFFF);
+    MM_REG_WRITE(cmd, subsys_id, base, MDP_CONTOUR_HIST_INIT_13, 0, 0xFFFFFFFF);
+    MM_REG_WRITE(cmd, subsys_id, base, MDP_CONTOUR_HIST_INIT_14, 0, 0xFFFFFFFF);
+    MM_REG_WRITE(cmd, subsys_id, base, MDP_CONTOUR_HIST_INIT_15, 0, 0xFFFFFFFF);
+    MM_REG_WRITE(cmd, subsys_id, base, MDP_CONTOUR_HIST_INIT_16, 0, 0xFFFFFFFF);
 #endif
+}
+
+static int init_tdshp(struct mdp_comp_ctx *ctx, struct mdp_cmd *cmd)
+{
+	phys_addr_t base = ctx->comp->reg_base;
+	u16 subsys_id = ctx->comp->subsys_id;
+
+    MM_REG_WRITE(cmd, subsys_id, base, MDP_TDSHP_CTRL, 0x00000001,
+            0x00000001);
+
+    // Enable fifo
+    MM_REG_WRITE(cmd, subsys_id, base, MDP_TDSHP_CFG, 0x00000002,
+            0x00000002);
+
+    resetLumaHist(ctx, cmd);
 
 	return 0;
 }
 
-static int config_wrot_subfrm(struct mdp_comp_ctx *ctx,
+static int config_tdshp_frame(struct mdp_comp_ctx *ctx, struct mdp_cmd *cmd,
+			    const struct v4l2_rect *compose)
+{
+	const struct mdp_tdshp_data *tdshp = &ctx->param->tdshp;
+	phys_addr_t base = ctx->comp->reg_base;
+	u16 subsys_id = ctx->comp->subsys_id;
+
+    MM_REG_WRITE(cmd, subsys_id, base, MDP_TDSHP_CFG, tdshp->cfg, 0x00000001);
+
+	return 0;
+}
+
+static int config_tdshp_subfrm(struct mdp_comp_ctx *ctx,
 			      struct mdp_cmd *cmd, u32 index)
 {
-	const struct mdp_wrot_subfrm *subfrm = &ctx->param->wrot.subfrms[index];
+	const struct mdp_tdshp_subfrm *subfrm = &ctx->param->tdshp.subfrms[index];
 	phys_addr_t base = ctx->comp->reg_base;
-	u8 subsys_id = ctx->comp->subsys_id;
+	u16 subsys_id = ctx->comp->subsys_id;
+
+    MM_REG_WRITE(cmd, subsys_id, base, MDP_TDSHP_INPUT_SIZE, subfrm->src,
+        MDP_TDSHP_INPUT_SIZE_MASK);
+    MM_REG_WRITE(cmd, subsys_id, base, MDP_TDSHP_OUTPUT_OFFSET, subfrm->clip_ofst,
+        0x00FF00FF);
+    MM_REG_WRITE(cmd, subsys_id, base, MDP_TDSHP_OUTPUT_SIZE, subfrm->clip,
+        MDP_TDSHP_OUTPUT_SIZE_MASK);
+    MM_REG_WRITE(cmd, subsys_id, base, MDP_HIST_CFG_00, subfrm->hist_cfg_0,
+        0xFFFFFFFF);
+    MM_REG_WRITE(cmd, subsys_id, base, MDP_HIST_CFG_01, subfrm->hist_cfg_1,
+        0xFFFFFFFF);
 
-	/* Write Y pixel offset */
-	MM_REG_WRITE(cmd, subsys_id, base, VIDO_OFST_ADDR,
-		     subfrm->offset[0], 0x0FFFFFFF);
-	/* Write U pixel offset */
-	MM_REG_WRITE(cmd, subsys_id, base, VIDO_OFST_ADDR_C,
-		     subfrm->offset[1], 0x0FFFFFFF);
-	/* Write V pixel offset */
-	MM_REG_WRITE(cmd, subsys_id, base, VIDO_OFST_ADDR_V,
-		     subfrm->offset[2], 0x0FFFFFFF);
-	/* Write source size */
-	MM_REG_WRITE(cmd, subsys_id, base, VIDO_IN_SIZE, subfrm->src,
-		     0x1FFF1FFF);
-	/* Write target size */
-	MM_REG_WRITE(cmd, subsys_id, base, VIDO_TAR_SIZE, subfrm->clip,
-		     0x1FFF1FFF);
-	MM_REG_WRITE(cmd, subsys_id, base, VIDO_CROP_OFST, subfrm->clip_ofst,
-		     0x1FFF1FFF);
+	return 0;
+}
 
-	MM_REG_WRITE(cmd, subsys_id, base, VIDO_MAIN_BUF_SIZE,
-		     subfrm->main_buf, 0x1FFF7F00);
+static const struct mdp_comp_ops tdshp_ops = {
+	.get_comp_flag = get_comp_flag,
+	.init_comp = init_tdshp,
+	.config_frame = config_tdshp_frame,
+	.config_subfrm = config_tdshp_subfrm,
+	/* .reconfig_frame = NULL, */
+	/* .reconfig_subfrms = NULL, */
+	.wait_comp_event = NULL,
+	.advance_subfrm = NULL,
+	.post_process = NULL,
+};
 
-	/* Enable WROT */
-	MM_REG_WRITE(cmd, subsys_id, base, VIDO_ROT_EN, 0x01, 0x00000001);
+static int init_color(struct mdp_comp_ctx *ctx, struct mdp_cmd *cmd)
+{
+	phys_addr_t base = ctx->comp->reg_base;
+	u16 subsys_id = ctx->comp->subsys_id;
+
+    if (1)//(m_mdpColor)
+    {
+        MM_REG_WRITE(cmd, subsys_id, base, DISP_COLOR_START, 0x1, 0x3);
+        MM_REG_WRITE(cmd, subsys_id, base, DISP_COLOR_WIN_X_MAIN, 0xFFFF0000, 0xFFFFFFFF);
+        MM_REG_WRITE(cmd, subsys_id, base, DISP_COLOR_WIN_Y_MAIN, 0xFFFF0000, 0xFFFFFFFF);
+
+        // R2Y/Y2R are disabled in MDP
+        MM_REG_WRITE(cmd, subsys_id, base, DISP_COLOR_CM1_EN, 0x0, 0x1);
+        MM_REG_WRITE(cmd, subsys_id, base, DISP_COLOR_CM2_EN, 0x0, 0x1);
+
+        //enable interrupt
+        MM_REG_WRITE(cmd, subsys_id, base, DISP_COLOR_INTEN, 0x00000007, 0x00000007);
+
+        //Set 10bit->8bit Rounding
+        MM_REG_WRITE(cmd, subsys_id, base, DISP_COLOR_OUT_SEL, 0x333, 0x333);
+    }
 
 	return 0;
 }
 
-static int wait_wrot_event(struct mdp_comp_ctx *ctx, struct mdp_cmd *cmd)
+static int config_color_frame(struct mdp_comp_ctx *ctx, struct mdp_cmd *cmd,
+			    const struct v4l2_rect *compose)
 {
+	const struct mdp_color_data *color = &ctx->param->color;
 	phys_addr_t base = ctx->comp->reg_base;
-	u8 subsys_id = ctx->comp->subsys_id;
+	u16 subsys_id = ctx->comp->subsys_id;
 
-	if (ctx->comp->alias_id == 0)
-		MM_REG_WAIT(cmd, WROT0_DONE);
-	else
-		pr_err("Do not support WROT1_DONE event\n");
-#if WROT_FILTER_CONSTRAINT
-	/* Filter disable */
-	MM_REG_WRITE(cmd, subsys_id, base, VIDO_MAIN_BUF_SIZE,
-		     (0 << 4) +
-		(0 << 0),
-		0x00000077);
-#endif
-	/* Disable WROT */
-	MM_REG_WRITE(cmd, subsys_id, base, VIDO_ROT_EN, 0x00, 0x00000001);
+    MM_REG_WRITE(cmd, subsys_id, base, DISP_COLOR_START, color->start, DISP_COLOR_START_MASK);
 
 	return 0;
 }
 
-static const struct mdp_comp_ops wrot_ops = {
+static int config_color_subfrm(struct mdp_comp_ctx *ctx,
+			      struct mdp_cmd *cmd, u32 index)
+{
+	const struct mdp_color_subfrm *subfrm = &ctx->param->color.subfrms[index];
+	phys_addr_t base = ctx->comp->reg_base;
+	u16 subsys_id = ctx->comp->subsys_id;
+
+    MM_REG_WRITE(cmd, subsys_id, base, DISP_COLOR_INTERNAL_IP_WIDTH, subfrm->in_hsize,
+        0x00003FFF);
+    MM_REG_WRITE(cmd, subsys_id, base, DISP_COLOR_INTERNAL_IP_HEIGHT, subfrm->in_vsize,
+        0x00003FFF);
+
+	return 0;
+}
+
+static const struct mdp_comp_ops color_ops = {
 	.get_comp_flag = get_comp_flag,
-	.init_comp = init_wrot,
-	.config_frame = config_wrot_frame,
-	.config_subfrm = config_wrot_subfrm,
-	/* .reconfig_frame = reconfig_wrot_frame, */
-	/* .reconfig_subfrms = reconfig_wrot_subfrms, */
-	.wait_comp_event = wait_wrot_event,
+	.init_comp = init_color,
+	.config_frame = config_color_frame,
+	.config_subfrm = config_color_subfrm,
+	/* .reconfig_frame = NULL, */
+	/* .reconfig_subfrms = NULL, */
+	.wait_comp_event = NULL,
 	.advance_subfrm = NULL,
 	.post_process = NULL,
 };
 
-static int init_wdma(struct mdp_comp_ctx *ctx, struct mdp_cmd *cmd)
+static int init_ovl(struct mdp_comp_ctx *ctx, struct mdp_cmd *cmd)
 {
 	phys_addr_t base = ctx->comp->reg_base;
-	u8 subsys_id = ctx->comp->subsys_id;
+	u16 subsys_id = ctx->comp->subsys_id;
+
+    MM_REG_WRITE(cmd, subsys_id, base, OVL_EN, 0x1,
+        OVL_EN_MASK);
+
+    //Relay Mode
+    MM_REG_WRITE(cmd, subsys_id, base, OVL_SRC_CON, 0x200,
+        OVL_SRC_CON_MASK);
+
+    //Connect OVL, enable smi_id mode
+    MM_REG_WRITE(cmd, subsys_id, base, OVL_DATAPATH_CON, 0x1,
+        OVL_DATAPATH_CON_MASK);
 
-	/* Reset WDMA */
-	MM_REG_WRITE(cmd, subsys_id, base, WDMA_RST, 0x1, 0x00000001);
-	MM_REG_POLL(cmd, subsys_id, base, WDMA_FLOW_CTRL_DBG, 0x01,
-		    0x00000001);
-	MM_REG_WRITE(cmd, subsys_id, base, WDMA_RST, 0x0, 0x00000001);
 	return 0;
 }
 
-static int config_wdma_frame(struct mdp_comp_ctx *ctx, struct mdp_cmd *cmd,
-			     const struct v4l2_rect *compose)
+static int config_ovl_frame(struct mdp_comp_ctx *ctx, struct mdp_cmd *cmd,
+			    const struct v4l2_rect *compose)
 {
-	const struct mdp_wdma_data *wdma = &ctx->param->wdma;
+	const struct mdp_ovl_data *ovl = &ctx->param->ovl;
 	phys_addr_t base = ctx->comp->reg_base;
-	u8 subsys_id = ctx->comp->subsys_id;
+	u16 subsys_id = ctx->comp->subsys_id;
 
-	MM_REG_WRITE(cmd, subsys_id, base, WDMA_BUF_CON2, 0x10101050,
-		     0xFFFFFFFF);
+    //Layer0 for PQ-direct-in
+    MM_REG_WRITE(cmd, subsys_id, base, OVL_L0_CON, ovl->L0_con, 0x30000000);
+    //Enable Layer0
+    MM_REG_WRITE(cmd, subsys_id, base, OVL_SRC_CON, ovl->src_con, 0x1);
+
+	return 0;
+}
+
+static int config_ovl_subfrm(struct mdp_comp_ctx *ctx,
+			      struct mdp_cmd *cmd, u32 index)
+{
+	const struct mdp_ovl_subfrm *subfrm = &ctx->param->ovl.subfrms[index];
+	phys_addr_t base = ctx->comp->reg_base;
+	u16 subsys_id = ctx->comp->subsys_id;
+
+    //Setup Layer0 source size
+    MM_REG_WRITE(cmd, subsys_id, base, OVL_L0_SRC_SIZE, subfrm->L0_src_size, OVL_L0_SRC_SIZE_MASK);
+    //Setup ROI size (output size)
+    MM_REG_WRITE(cmd, subsys_id, base, OVL_ROI_SIZE, subfrm->roi_size, OVL_ROI_SIZE_MASK);
+
+	return 0;
+}
+
+static const struct mdp_comp_ops ovl_ops = {
+	.get_comp_flag = get_comp_flag,
+	.init_comp = init_ovl,
+	.config_frame = config_ovl_frame,
+	.config_subfrm = config_ovl_subfrm,
+	/* .reconfig_frame = NULL, */
+	/* .reconfig_subfrms = NULL, */
+	.wait_comp_event = NULL,
+	.advance_subfrm = NULL,
+	.post_process = NULL,
+};
+
+static int init_pad(struct mdp_comp_ctx *ctx, struct mdp_cmd *cmd)
+{
+	phys_addr_t base = ctx->comp->reg_base;
+	u16 subsys_id = ctx->comp->subsys_id;
+
+    MM_REG_WRITE(cmd, subsys_id, base, VPP_PADDING0_PADDING_CON, 0x2,
+        VPP_PADDING0_PADDING_CON_MASK);
+    //Clear padding area
+    MM_REG_WRITE(cmd, subsys_id, base, VPP_PADDING0_W_PADDING_SIZE, 0x0,
+    VPP_PADDING0_W_PADDING_SIZE_MASK);
+    MM_REG_WRITE(cmd, subsys_id, base, VPP_PADDING0_H_PADDING_SIZE, 0x0,
+        VPP_PADDING0_H_PADDING_SIZE_MASK);
+
+	return 0;
+}
+
+static int config_pad_frame(struct mdp_comp_ctx *ctx, struct mdp_cmd *cmd,
+			    const struct v4l2_rect *compose)
+{
+	return 0;
+}
+
+static int config_pad_subfrm(struct mdp_comp_ctx *ctx,
+			      struct mdp_cmd *cmd, u32 index)
+{
+	const struct mdp_pad_subfrm *subfrm = &ctx->param->pad.subfrms[index];
+	phys_addr_t base = ctx->comp->reg_base;
+	u16 subsys_id = ctx->comp->subsys_id;
+
+    MM_REG_WRITE(cmd, subsys_id, base, VPP_PADDING0_PADDING_PIC_SIZE, subfrm->pic_size,
+        VPP_PADDING0_PADDING_CON_MASK);
+
+	return 0;
+}
+
+static const struct mdp_comp_ops pad_ops = {
+	.get_comp_flag = get_comp_flag,
+	.init_comp = init_pad,
+	.config_frame = config_pad_frame,
+	.config_subfrm = config_pad_subfrm,
+	/* .reconfig_frame = NULL, */
+	/* .reconfig_subfrms = NULL, */
+	.wait_comp_event = NULL,
+	.advance_subfrm = NULL,
+	.post_process = NULL,
+};
+
+static int init_tcc(struct mdp_comp_ctx *ctx, struct mdp_cmd *cmd)
+{
+	return 0;
+}
+
+static int config_tcc_frame(struct mdp_comp_ctx *ctx, struct mdp_cmd *cmd,
+			    const struct v4l2_rect *compose)
+{
+	return 0;
+}
+
+static int config_tcc_subfrm(struct mdp_comp_ctx *ctx,
+			      struct mdp_cmd *cmd, u32 index)
+{
+	return 0;
+}
+
+static const struct mdp_comp_ops tcc_ops = {
+	.get_comp_flag = get_comp_flag,
+	.init_comp = init_tcc,
+	.config_frame = config_tcc_frame,
+	.config_subfrm = config_tcc_subfrm,
+	/* .reconfig_frame = NULL, */
+	/* .reconfig_subfrms = NULL, */
+	.wait_comp_event = NULL,
+	.advance_subfrm = NULL,
+	.post_process = NULL,
+};
+
+static int init_wrot(struct mdp_comp_ctx *ctx, struct mdp_cmd *cmd)
+{
+	phys_addr_t base = ctx->comp->reg_base;
+	u16 subsys_id = ctx->comp->subsys_id;
+
+	phys_addr_t vpp0_base = ctx->comp->vpp0_base;
+	u16 vpp0_id = ctx->comp->vpp0_subsys_id;
+
+#if WROT_FILTER_CONSTRAINT
+	/* Wait WROT SRAM shared to DISP RDMA */
+	if (ctx->comp->alias_id == 0)
+		pr_err("Do not support WROT0_SRAM_READY event\n");
+	else
+		pr_err("Do not support WROT1_SRAM_READY event\n");
+#endif
+
+	// Enable DCM (VPP02VPP1_RELAY)
+	MM_REG_WRITE_MASK(cmd, vpp0_id, vpp0_base, VPPSYS0_HW_DCM_1ST_DIS0, 0x0, 0x4000);
+
+	/* Reset WROT */
+	MM_REG_WRITE(cmd, subsys_id, base, VIDO_SOFT_RST, 0x01, 0x00000001);
+	MM_REG_POLL(cmd, subsys_id, base, VIDO_SOFT_RST_STAT, 0x01, 0x00000001);
+	/* Reset setting */
+	MM_REG_WRITE(cmd, subsys_id, base, VIDO_CTRL, 0x0, 0xFFFFFFFF);
+	MM_REG_WRITE(cmd, subsys_id, base, VIDO_SOFT_RST, 0x00, 0x00000001);
+	MM_REG_POLL(cmd, subsys_id, base, VIDO_SOFT_RST_STAT, 0x00, 0x00000001);
+	return 0;
+}
+
+static int config_wrot_frame(struct mdp_comp_ctx *ctx, struct mdp_cmd *cmd,
+			     const struct v4l2_rect *compose)
+{
+	u32 colorformat=0;
+	phys_addr_t base = 0, vpp0_base = 0, vpp1_base = 0;
+	u16 subsys_id = 0, vpp0_id = 0, vpp1_id;
+	bool comp=0, comp_10bit=0;
+	const struct mdp_wrot_data *wrot = &ctx->param->wrot;
+	colorformat = ctx->outputs[0]->buffer.format.colorformat;
+
+	base = ctx->comp->reg_base;
+	subsys_id = ctx->comp->subsys_id;
+	vpp0_base = ctx->comp->vpp0_base;
+	vpp0_id = ctx->comp->vpp0_subsys_id;
+	vpp1_base = ctx->comp->vpp1_base;
+	vpp1_id = ctx->comp->vpp1_subsys_id;
+
+	comp = MDP_COLOR_IS_COMPRESS(colorformat);
+	comp_10bit = (comp && MDP_COLOR_IS_UFP(colorformat));
+
+	/* Write frame base address */
+	MM_REG_WRITE(cmd, subsys_id, base, VIDO_BASE_ADDR, wrot->iova[0],
+			0xFFFFFFFF);
+	MM_REG_WRITE(cmd, subsys_id, base, VIDO_BASE_ADDR_C, wrot->iova[1],
+			0xFFFFFFFF);
+	MM_REG_WRITE(cmd, subsys_id, base, VIDO_BASE_ADDR_V, wrot->iova[2],
+			0xFFFFFFFF);
+
+#ifdef DMA_SUPPORT_AFBC
+	if (comp)
+	{
+		MM_REG_WRITE(cmd, subsys_id, base, VIDO_FRAME_SIZE, wrot->framesize, 0xFFFFFFFF);
+		MM_REG_WRITE(cmd, subsys_id, base, VIDO_AFBC_YUVTRANS, wrot->afbc_yuvtrans, 0x1);
+	}
+#endif
+
+	/* Write frame related registers */
+	MM_REG_WRITE(cmd, subsys_id, base, VIDO_CTRL, wrot->control,
+		     0xF131510F);
+
+#ifdef HW_SUPPORT_10BIT_PATH
+	MM_REG_WRITE(cmd, subsys_id, base, VIDO_SCAN_10BIT, wrot->scan_10bit, 0x0000000F);
+	MM_REG_WRITE(cmd, subsys_id, base, VIDO_PENDING_ZERO, wrot->pending_zero, 0x04000000);
+//#ifdef MDP_VERSION_6885
+	MM_REG_WRITE(cmd, subsys_id, base, VIDO_CTRL_2, wrot->bit_number, 0x00000007);
+//#endif
+#endif // HW_SUPPORT_10BIT_PATH
+
+#ifdef DMA_SUPPORT_AFBC
+	MM_REG_WRITE(cmd, subsys_id, base, VIDO_PVRIC,  wrot->pvric, 0x03);
+#endif
+
+
+	/* Write pre-ultra threshold */
+	MM_REG_WRITE(cmd, subsys_id, base, VIDO_DMA_PREULTRA, wrot->pre_ultra,
+			0x00FFFFFF);
+	/* Write frame Y pitch */
+	MM_REG_WRITE(cmd, subsys_id, base, VIDO_STRIDE, wrot->stride[0],
+			0x0000FFFF);
+	/* Write frame UV pitch */
+	MM_REG_WRITE(cmd, subsys_id, base, VIDO_STRIDE_C, wrot->stride[1],
+			0x0000FFFF);
+	MM_REG_WRITE(cmd, subsys_id, base, VIDO_STRIDE_V, wrot->stride[2],
+			0x0000FFFF);
+	/* Write matrix control */
+	MM_REG_WRITE(cmd, subsys_id, base, VIDO_MAT_CTRL, wrot->mat_ctrl,
+			0x000000F3);
 
-	/* Setup frame information */
-	MM_REG_WRITE(cmd, subsys_id, base, WDMA_CFG, wdma->wdma_cfg,
-		     0x0F01B8F0);
-	/* Setup frame base address */
-	MM_REG_WRITE(cmd, subsys_id, base, WDMA_DST_ADDR,   wdma->iova[0],
-		     0xFFFFFFFF);
-	MM_REG_WRITE(cmd, subsys_id, base, WDMA_DST_U_ADDR, wdma->iova[1],
-		     0xFFFFFFFF);
-	MM_REG_WRITE(cmd, subsys_id, base, WDMA_DST_V_ADDR, wdma->iova[2],
-		     0xFFFFFFFF);
-	/* Setup Y pitch */
-	MM_REG_WRITE(cmd, subsys_id, base, WDMA_DST_W_IN_BYTE,
-		     wdma->w_in_byte, 0x0000FFFF);
-	/* Setup UV pitch */
-	MM_REG_WRITE(cmd, subsys_id, base, WDMA_DST_UV_PITCH,
-		     wdma->uv_stride, 0x0000FFFF);
 	/* Set the fixed ALPHA as 0xFF */
-	MM_REG_WRITE(cmd, subsys_id, base, WDMA_ALPHA, 0x800000FF,
-		     0x800000FF);
+	MM_REG_WRITE(cmd, subsys_id, base, VIDO_DITHER, 0xFF000000,
+			0xFF000000);
+	/* Set VIDO_EOL_SEL */
+	MM_REG_WRITE(cmd, subsys_id, base, VIDO_RSV_1, 0x80000000,
+			0x80000000);
+	/* Set VIDO_FIFO_TEST */
+	if (wrot->fifo_test != 0)
+		MM_REG_WRITE(cmd, subsys_id, base, VIDO_FIFO_TEST,
+			     wrot->fifo_test, 0x00000FFF);
+
+	/* Filter enable */
+	MM_REG_WRITE(cmd, subsys_id, base, VIDO_MAIN_BUF_SIZE, wrot->filter,
+		     0x00000077);
+
+    /* Turn off WROT dma dcm */
+	MM_REG_WRITE(cmd, subsys_id, base, VIDO_ROT_EN, (0x1 << 23) +
+                                                    (0x1 << 20), 0x00900000);
+	if(wrot->vpp02vpp1)
+	{
+		// Disable DCM (VPP02VPP1_RELAY)
+		MM_REG_WRITE_MASK(cmd, vpp0_id, vpp0_base, VPPSYS0_HW_DCM_1ST_DIS0, 0x4000, 0xFFFFFFFF);
+		// Set default size
+		MM_REG_WRITE_MASK(cmd, vpp1_id, vpp1_base, VPP0_DL_IRELAY_WR, 0x0, 0xFFFFFFFF);
+	}
 
 	return 0;
 }
 
-static int config_wdma_subfrm(struct mdp_comp_ctx *ctx,
+static int config_wrot_subfrm(struct mdp_comp_ctx *ctx,
 			      struct mdp_cmd *cmd, u32 index)
 {
-	const struct mdp_wdma_subfrm *subfrm = &ctx->param->wdma.subfrms[index];
+	const struct mdp_wrot_subfrm *subfrm = &ctx->param->wrot.subfrms[index];
 	phys_addr_t base = ctx->comp->reg_base;
-	u8 subsys_id = ctx->comp->subsys_id;
+	u16 subsys_id = ctx->comp->subsys_id;
 
 	/* Write Y pixel offset */
-	MM_REG_WRITE(cmd, subsys_id, base, WDMA_DST_ADDR_OFFSET,
+	MM_REG_WRITE(cmd, subsys_id, base, VIDO_OFST_ADDR,
 		     subfrm->offset[0], 0x0FFFFFFF);
 	/* Write U pixel offset */
-	MM_REG_WRITE(cmd, subsys_id, base, WDMA_DST_U_ADDR_OFFSET,
+	MM_REG_WRITE(cmd, subsys_id, base, VIDO_OFST_ADDR_C,
 		     subfrm->offset[1], 0x0FFFFFFF);
 	/* Write V pixel offset */
-	MM_REG_WRITE(cmd, subsys_id, base, WDMA_DST_V_ADDR_OFFSET,
+	MM_REG_WRITE(cmd, subsys_id, base, VIDO_OFST_ADDR_V,
 		     subfrm->offset[2], 0x0FFFFFFF);
 	/* Write source size */
-	MM_REG_WRITE(cmd, subsys_id, base, WDMA_SRC_SIZE, subfrm->src,
-		     0x3FFF3FFF);
+	MM_REG_WRITE(cmd, subsys_id, base, VIDO_IN_SIZE, subfrm->src,
+		     0xFFFFFFFF);
 	/* Write target size */
-	MM_REG_WRITE(cmd, subsys_id, base, WDMA_CLIP_SIZE, subfrm->clip,
-		     0x3FFF3FFF);
-	/* Write clip offset */
-	MM_REG_WRITE(cmd, subsys_id, base, WDMA_CLIP_COORD, subfrm->clip_ofst,
-		     0x3FFF3FFF);
+	MM_REG_WRITE(cmd, subsys_id, base, VIDO_TAR_SIZE, subfrm->clip,
+		     0xFFFFFFFF);
+	MM_REG_WRITE(cmd, subsys_id, base, VIDO_CROP_OFST, subfrm->clip_ofst,
+		     0xFFFFFFFF);
 
-	/* Enable WDMA */
-	MM_REG_WRITE(cmd, subsys_id, base, WDMA_EN, 0x01, 0x00000001);
+	MM_REG_WRITE(cmd, subsys_id, base, VIDO_MAIN_BUF_SIZE,
+		     subfrm->main_buf, 0xFFFF7F00);
 
-	return 0;
-}
+    // Set wrot interrupt bit for debug, this bit will clear to 0 after wrot done.
+	MM_REG_WRITE(cmd, subsys_id, base, VIDO_INT, 0x1, VIDO_INT_MASK);
 
-static int wait_wdma_event(struct mdp_comp_ctx *ctx, struct mdp_cmd *cmd)
-{
-	phys_addr_t base = ctx->comp->reg_base;
-	u8 subsys_id = ctx->comp->subsys_id;
+	/* Enable WROT */
+	MM_REG_WRITE(cmd, subsys_id, base, VIDO_ROT_EN, 0x01, 0x00000001);
 
-	MM_REG_WAIT(cmd, WDMA0_DONE);
-	/* Disable WDMA */
-	MM_REG_WRITE(cmd, subsys_id, base, WDMA_EN, 0x00, 0x00000001);
 	return 0;
 }
 
-static const struct mdp_comp_ops wdma_ops = {
-	.get_comp_flag = get_comp_flag,
-	.init_comp = init_wdma,
-	.config_frame = config_wdma_frame,
-	.config_subfrm = config_wdma_subfrm,
-	.wait_comp_event = wait_wdma_event,
-	.advance_subfrm = NULL,
-	.post_process = NULL,
-};
-
-static int init_ccorr(struct mdp_comp_ctx *ctx, struct mdp_cmd *cmd)
+static int wait_wrot_event(struct mdp_comp_ctx *ctx, struct mdp_cmd *cmd)
 {
 	phys_addr_t base = ctx->comp->reg_base;
-	u8 subsys_id = ctx->comp->subsys_id;
-
-	/* CCORR enable */
-	MM_REG_WRITE(cmd, subsys_id, base, MDP_CCORR_EN, 0x1, 0x1);
-	/* Relay mode */
-	MM_REG_WRITE(cmd, subsys_id, base, MDP_CCORR_CFG, 0x1, 0x1);
-	return 0;
-}
-
-static int config_ccorr_frame(struct mdp_comp_ctx *ctx, struct mdp_cmd *cmd,
-			      const struct v4l2_rect *compose)
-{
-	/* Disabled function */
-	return 0;
-}
+	u16 subsys_id = ctx->comp->subsys_id;
+
+    switch (ctx->comp->alias_id)
+    {
+        case 0:
+            MM_REG_WAIT(cmd, WROT0_FRAME_DONE);
+            break;
+        case 1:
+            MM_REG_WAIT(cmd, WROT1_FRAME_DONE);
+            break;
+        case 2:
+            MM_REG_WAIT(cmd, WROT2_FRAME_DONE);
+            break;
+        case 3:
+            MM_REG_WAIT(cmd, WROT3_FRAME_DONE);
+            break;
+        default:
+    		pr_err("Invalid Engine!\n");
+    }
 
-static int config_ccorr_subfrm(struct mdp_comp_ctx *ctx,
-			       struct mdp_cmd *cmd, u32 index)
-{
-	const struct img_comp_subfrm *csf = &ctx->param->subfrms[index];
-	phys_addr_t base = ctx->comp->reg_base;
-	u8 subsys_id = ctx->comp->subsys_id;
-	u32 hsize, vsize;
+#if WROT_FILTER_CONSTRAINT
+	/* Filter disable */
+	MM_REG_WRITE(cmd, subsys_id, base, VIDO_MAIN_BUF_SIZE,
+			(0 << 4) +
+			(0 << 0), 0x00000077);
+#endif
+	/* Disable WROT */
+	MM_REG_WRITE(cmd, subsys_id, base, VIDO_ROT_EN, 0x00, 0x00000001);
 
-	hsize = csf->in.right - csf->in.left + 1;
-	vsize = csf->in.bottom - csf->in.top + 1;
-	MM_REG_WRITE(cmd, subsys_id, base, MDP_CCORR_SIZE,
-		     (hsize << 16) + (vsize <<  0), 0x1FFF1FFF);
 	return 0;
 }
 
-static const struct mdp_comp_ops ccorr_ops = {
+static const struct mdp_comp_ops wrot_ops = {
 	.get_comp_flag = get_comp_flag,
-	.init_comp = init_ccorr,
-	.config_frame = config_ccorr_frame,
-	.config_subfrm = config_ccorr_subfrm,
-	/* .reconfig_frame = NULL, */
-	/* .reconfig_subfrms = NULL, */
-	.wait_comp_event = NULL,
+	.init_comp = init_wrot,
+	.config_frame = config_wrot_frame,
+	.config_subfrm = config_wrot_subfrm,
+	/* .reconfig_frame = reconfig_wrot_frame, */
+	/* .reconfig_subfrms = reconfig_wrot_subfrms, */
+	.wait_comp_event = wait_wrot_event,
 	.advance_subfrm = NULL,
 	.post_process = NULL,
 };
 
 static int init_isp(struct mdp_comp_ctx *ctx, struct mdp_cmd *cmd)
 {
+#if 0
 	const struct isp_data *isp = &ctx->param->isp;
 	phys_addr_t mmsys = ctx->comp->mdp_dev->mmsys.reg_base;
-	u8 subsys_id = ctx->comp->mdp_dev->mmsys.subsys_id;
+	u16 subsys_id = ctx->comp->mdp_dev->mmsys.subsys_id;
+    // Roy
 
 	/* Direct link */
 	if (isp->dl_flags & (1 << MDP_CAMIN)) {
@@ -616,8 +1242,8 @@ static int init_isp(struct mdp_comp_ctx *ctx, struct mdp_cmd *cmd)
 			     0x00000400);
 
 		/* Enable sof mode */
-		MM_REG_WRITE(cmd, subsys_id, mmsys, ISP_RELAY_CFG_WD, 0 << 31,
-			     0x80000000);
+		//MM_REG_WRITE(cmd, subsys_id, mmsys, ISP_RELAY_CFG_WD, 0 << 31,
+		//	     0x80000000);
 	}
 
 	if (isp->dl_flags & (1 << MDP_CAMIN2)) {
@@ -636,10 +1262,10 @@ static int init_isp(struct mdp_comp_ctx *ctx, struct mdp_cmd *cmd)
 			     0x00000800);
 
 		/* Enable sof mode */
-		MM_REG_WRITE(cmd, subsys_id, mmsys, IPU_RELAY_CFG_WD, 0 << 31,
-			     0x80000000);
+		//MM_REG_WRITE(cmd, subsys_id, mmsys, IPU_RELAY_CFG_WD, 0 << 31,
+		//	     0x80000000);
 	}
-
+#endif
 	return 0;
 }
 
@@ -648,7 +1274,7 @@ static int config_isp_frame(struct mdp_comp_ctx *ctx, struct mdp_cmd *cmd,
 {
 	const struct isp_data *isp = &ctx->param->isp;
 	phys_addr_t base = ctx->comp->reg_base;
-	u8 subsys_id = ctx->comp->subsys_id;
+	u16 subsys_id = ctx->comp->subsys_id;
 
 	/* DIP_X_SMX1I_BASE_ADDR, DIP_X_SMX1O_BASE_ADDR */
 	MM_REG_WRITE_MASK(cmd, subsys_id, base, 0x2890, isp->smxi_iova[0],
@@ -745,7 +1371,7 @@ static int config_isp_subfrm(struct mdp_comp_ctx *ctx,
 			     struct mdp_cmd *cmd, u32 index)
 {
 	phys_addr_t base = ctx->comp->reg_base;
-	u8 subsys_id = ctx->comp->subsys_id;
+	u16 subsys_id = ctx->comp->subsys_id;
 
 	MM_REG_WRITE_MASK(cmd, subsys_id, base, 0x2304,
 			  ctx->param->isp.tpipe_iova[index], 0xFFFFFFFF);
@@ -756,7 +1382,7 @@ static int wait_isp_event(struct mdp_comp_ctx *ctx, struct mdp_cmd *cmd)
 {
 	const struct isp_data *isp = &ctx->param->isp;
 	phys_addr_t base = ctx->comp->reg_base;
-	u8 subsys_id = ctx->comp->subsys_id;
+	u16 subsys_id = ctx->comp->subsys_id;
 
 	/* MDP_DL_SEL: select MDP_CROP */
 	if (isp->dl_flags & (1 << MDP_CAMIN))
@@ -771,77 +1397,77 @@ static int wait_isp_event(struct mdp_comp_ctx *ctx, struct mdp_cmd *cmd)
 	case ISP_DRV_DIP_CQ_THRE0:
 		MM_REG_WRITE_MASK(cmd, subsys_id, base, 0x2000, 0x0001,
 				  0x00000001);
-		MM_REG_WAIT(cmd, ISP_P2_0_DONE);
+		//MM_REG_WAIT(cmd, ISP_P2_0_DONE);
 		break;
 	case ISP_DRV_DIP_CQ_THRE1:
 		MM_REG_WRITE_MASK(cmd, subsys_id, base, 0x2000, 0x0002,
 				  0x00000002);
-		MM_REG_WAIT(cmd, ISP_P2_1_DONE);
+		//MM_REG_WAIT(cmd, ISP_P2_1_DONE);
 		break;
 	case ISP_DRV_DIP_CQ_THRE2:
 		MM_REG_WRITE_MASK(cmd, subsys_id, base, 0x2000, 0x0004,
 				  0x00000004);
-		MM_REG_WAIT(cmd, ISP_P2_2_DONE);
+		//MM_REG_WAIT(cmd, ISP_P2_2_DONE);
 		break;
 	case ISP_DRV_DIP_CQ_THRE3:
 		MM_REG_WRITE_MASK(cmd, subsys_id, base, 0x2000, 0x0008,
 				  0x00000008);
-		MM_REG_WAIT(cmd, ISP_P2_3_DONE);
+		//MM_REG_WAIT(cmd, ISP_P2_3_DONE);
 		break;
 	case ISP_DRV_DIP_CQ_THRE4:
 		MM_REG_WRITE_MASK(cmd, subsys_id, base, 0x2000, 0x0010,
 				  0x00000010);
-		MM_REG_WAIT(cmd, ISP_P2_4_DONE);
+		//MM_REG_WAIT(cmd, ISP_P2_4_DONE);
 		break;
 	case ISP_DRV_DIP_CQ_THRE5:
 		MM_REG_WRITE_MASK(cmd, subsys_id, base, 0x2000, 0x0020,
 				  0x00000020);
-		MM_REG_WAIT(cmd, ISP_P2_5_DONE);
+		//MM_REG_WAIT(cmd, ISP_P2_5_DONE);
 		break;
 	case ISP_DRV_DIP_CQ_THRE6:
 		MM_REG_WRITE_MASK(cmd, subsys_id, base, 0x2000, 0x0040,
 				  0x00000040);
-		MM_REG_WAIT(cmd, ISP_P2_6_DONE);
+		///MM_REG_WAIT(cmd, ISP_P2_6_DONE);
 		break;
 	case ISP_DRV_DIP_CQ_THRE7:
 		MM_REG_WRITE_MASK(cmd, subsys_id, base, 0x2000, 0x0080,
 				  0x00000080);
-		MM_REG_WAIT(cmd, ISP_P2_7_DONE);
+		//MM_REG_WAIT(cmd, ISP_P2_7_DONE);
 		break;
 	case ISP_DRV_DIP_CQ_THRE8:
 		MM_REG_WRITE_MASK(cmd, subsys_id, base, 0x2000, 0x0100,
 				  0x00000100);
-		MM_REG_WAIT(cmd, ISP_P2_8_DONE);
+		//MM_REG_WAIT(cmd, ISP_P2_8_DONE);
 		break;
 	case ISP_DRV_DIP_CQ_THRE9:
 		MM_REG_WRITE_MASK(cmd, subsys_id, base, 0x2000, 0x0200,
 				  0x00000200);
-		MM_REG_WAIT(cmd, ISP_P2_9_DONE);
+		//MM_REG_WAIT(cmd, ISP_P2_9_DONE);
 		break;
 	case ISP_DRV_DIP_CQ_THRE10:
 		MM_REG_WRITE_MASK(cmd, subsys_id, base, 0x2000, 0x0400,
 				  0x00000400);
-		MM_REG_WAIT(cmd, ISP_P2_10_DONE);
+		//MM_REG_WAIT(cmd, ISP_P2_10_DONE);
 		break;
 	case ISP_DRV_DIP_CQ_THRE11:
 		MM_REG_WRITE_MASK(cmd, subsys_id, base, 0x2000, 0x0800,
 				  0x00000800);
-		MM_REG_WAIT(cmd, ISP_P2_11_DONE);
+		//MM_REG_WAIT(cmd, ISP_P2_11_DONE);
 		break;
 	case ISP_DRV_DIP_CQ_THRE12:
 		MM_REG_WRITE_MASK(cmd, subsys_id, base, 0x2000, 0x1000,
 				  0x00001000);
-		MM_REG_WAIT(cmd, ISP_P2_12_DONE);
+		//MM_REG_WAIT(cmd, ISP_P2_12_DONE);
 		break;
 	case ISP_DRV_DIP_CQ_THRE13:
 		MM_REG_WRITE_MASK(cmd, subsys_id, base, 0x2000, 0x2000,
 				  0x00002000);
-		MM_REG_WAIT(cmd, ISP_P2_13_DONE);
+		//MM_REG_WAIT(cmd, ISP_P2_13_DONE);
 		break;
 	case ISP_DRV_DIP_CQ_THRE14:
 		MM_REG_WRITE_MASK(cmd, subsys_id, base, 0x2000, 0x4000,
 				  0x00004000);
-		MM_REG_WAIT(cmd, ISP_P2_14_DONE);
+		//MM_REG_WAIT(cmd, ISP_P2_14_DONE);
 		break;
 	/* From CQ15 to CQ18, these do not connect to GCE */
 	default:
@@ -868,8 +1494,8 @@ static int config_camin_subfrm(struct mdp_comp_ctx *ctx,
 			       struct mdp_cmd *cmd, u32 index)
 {
 	const struct img_comp_subfrm *csf = &ctx->param->subfrms[index];
-	phys_addr_t base = ctx->comp->reg_base;
-	u8 subsys_id = ctx->comp->subsys_id;
+	//phys_addr_t base = ctx->comp->reg_base;
+	//u8 subsys_id = ctx->comp->subsys_id;
 	u32 isp_dl_w, isp_dl_h;
 
 	isp_dl_w = csf->in.right - csf->in.left + 1;
@@ -877,7 +1503,7 @@ static int config_camin_subfrm(struct mdp_comp_ctx *ctx,
 
 	/* Config for direct link */
 	if (ctx->comp->alias_id == 0) {
-#ifdef MDP_ASYNC_CFG_WD
+/*#ifdef MDP_ASYNC_CFG_WD
 		MM_REG_WRITE(cmd, subsys_id, base, MDP_ASYNC_CFG_WD,
 			     (isp_dl_h << 16) + isp_dl_w, 0x3FFF3FFF);
 #endif
@@ -893,7 +1519,7 @@ static int config_camin_subfrm(struct mdp_comp_ctx *ctx,
 #ifdef IPU_RELAY_CFG_WD
 		MM_REG_WRITE(cmd, subsys_id, base, IPU_RELAY_CFG_WD,
 			     (isp_dl_h << 16) + isp_dl_w, 0x3FFF3FFF);
-#endif
+#endif*/
 	}
 
 	return 0;
@@ -912,19 +1538,31 @@ static const struct mdp_comp_ops camin_ops = {
 };
 
 static const struct mdp_comp_ops *mdp_comp_ops[MDP_COMP_TYPE_COUNT] = {
-	[MDP_COMP_TYPE_RDMA] =		&rdma_ops,
-	[MDP_COMP_TYPE_RSZ] =		&rsz_ops,
-	[MDP_COMP_TYPE_WROT] =		&wrot_ops,
-	[MDP_COMP_TYPE_WDMA] =		&wdma_ops,
-	[MDP_COMP_TYPE_PATH] =		NULL,
-
-	[MDP_COMP_TYPE_CCORR] =		&ccorr_ops,
-
-	[MDP_COMP_TYPE_IMGI] =		&imgi_ops,
-	[MDP_COMP_TYPE_EXTO] =		NULL,
-	[MDP_COMP_TYPE_DL_PATH] =	&camin_ops,
+    [MDP_COMP_TYPE_IMGI]    = NULL,
+    [MDP_COMP_TYPE_WPEI]    = &camin_ops,
+    [MDP_COMP_TYPE_SPLIT]   = &split_ops,
+    [MDP_COMP_TYPE_STITCH]  = &stitch_ops,
+    [MDP_COMP_TYPE_RDMA]    = &rdma_ops,
+    [MDP_COMP_TYPE_FG]      = &fg_ops,
+    [MDP_COMP_TYPE_HDR]     = &hdr_ops,
+    [MDP_COMP_TYPE_AAL]     = &aal_ops,
+    [MDP_COMP_TYPE_RSZ]     = &rsz_ops,
+    [MDP_COMP_TYPE_TDSHP]   = &tdshp_ops,
+    [MDP_COMP_TYPE_COLOR]   = &color_ops,
+    [MDP_COMP_TYPE_DRE]     = NULL,
+    [MDP_COMP_TYPE_CCORR]   = NULL,
+    [MDP_COMP_TYPE_OVL]     = &ovl_ops,
+    [MDP_COMP_TYPE_PAD]     = &pad_ops,
+    [MDP_COMP_TYPE_TCC]     = &tcc_ops,
+    [MDP_COMP_TYPE_WROT]    = &wrot_ops,
+    [MDP_COMP_TYPE_MERGE]   = NULL,
+    [MDP_COMP_TYPE_WDMA]    = NULL,
+    [MDP_COMP_TYPE_PATH]    = NULL,
+    [MDP_COMP_TYPE_EXTO]    = NULL,
+    [MDP_COMP_TYPE_DL_PATH] = NULL,
+    [MDP_COMP_TYPE_DUMMY]   = NULL,
 };
-
+/*
 struct mdp_comp_match {
 	enum mdp_comp_type	type;
 	u32			alias_id;
@@ -935,118 +1573,145 @@ static const struct mdp_comp_match mdp_comp_matches[MDP_MAX_COMP_COUNT] = {
 	[MDP_COMP_WPEO] =	{ MDP_COMP_TYPE_EXTO, 2 },
 	[MDP_COMP_WPEI2] =	{ MDP_COMP_TYPE_WPEI, 1 },
 	[MDP_COMP_WPEO2] =	{ MDP_COMP_TYPE_EXTO, 3 },
-	[MDP_COMP_ISP_IMGI] =	{ MDP_COMP_TYPE_IMGI, 0 },
-	[MDP_COMP_ISP_IMGO] =	{ MDP_COMP_TYPE_EXTO, 0 },
-	[MDP_COMP_ISP_IMG2O] =	{ MDP_COMP_TYPE_EXTO, 1 },
-
 	[MDP_COMP_CAMIN] =	{ MDP_COMP_TYPE_DL_PATH, 0 },
 	[MDP_COMP_CAMIN2] =	{ MDP_COMP_TYPE_DL_PATH, 1 },
+	[MDP_COMP_SPLIT] =	{ MDP_COMP_TYPE_SPLIT, 0 },
+	[MDP_COMP_SPLIT2] =	{ MDP_COMP_TYPE_SPLIT, 1 },
 	[MDP_COMP_RDMA0] =	{ MDP_COMP_TYPE_RDMA, 0 },
-	[MDP_COMP_CCORR0] =	{ MDP_COMP_TYPE_CCORR, 0 },
+	[MDP_COMP_RDMA1] =	{ MDP_COMP_TYPE_RDMA, 1 },
+	[MDP_COMP_RDMA2] =	{ MDP_COMP_TYPE_RDMA, 2 },
+	[MDP_COMP_RDMA3] =	{ MDP_COMP_TYPE_RDMA, 3 },
+	[MDP_COMP_STITCH] =	{ MDP_COMP_TYPE_STITCH, 0 },
+	[MDP_COMP_FG0] =	{ MDP_COMP_TYPE_FG, 0 },
+	[MDP_COMP_FG1] =	{ MDP_COMP_TYPE_FG, 1 },
+	[MDP_COMP_FG2] =	{ MDP_COMP_TYPE_FG, 2 },
+	[MDP_COMP_FG3] =	{ MDP_COMP_TYPE_FG, 3 },
+	[MDP_COMP_HDR0] =	{ MDP_COMP_TYPE_HDR, 0 },
+	[MDP_COMP_HDR1] =	{ MDP_COMP_TYPE_HDR, 1 },
+	[MDP_COMP_HDR2] =	{ MDP_COMP_TYPE_HDR, 2 },
+	[MDP_COMP_HDR3] =	{ MDP_COMP_TYPE_HDR, 3 },
+	[MDP_COMP_AAL0] =	{ MDP_COMP_TYPE_AAL, 0 },
+	[MDP_COMP_AAL1] =	{ MDP_COMP_TYPE_AAL, 1 },
+	[MDP_COMP_AAL2] =	{ MDP_COMP_TYPE_AAL, 2 },
+	[MDP_COMP_AAL3] =	{ MDP_COMP_TYPE_AAL, 3 },
 	[MDP_COMP_RSZ0] =	{ MDP_COMP_TYPE_RSZ, 0 },
 	[MDP_COMP_RSZ1] =	{ MDP_COMP_TYPE_RSZ, 1 },
-	[MDP_COMP_PATH0_SOUT] =	{ MDP_COMP_TYPE_PATH, 0 },
-	[MDP_COMP_PATH1_SOUT] =	{ MDP_COMP_TYPE_PATH, 1 },
+	[MDP_COMP_RSZ2] =	{ MDP_COMP_TYPE_RSZ, 2 },
+	[MDP_COMP_RSZ3] =	{ MDP_COMP_TYPE_RSZ, 3 },
+	[MDP_COMP_TDSHP0] =	{ MDP_COMP_TYPE_TDSHP, 0 },
+	[MDP_COMP_TDSHP1] =	{ MDP_COMP_TYPE_TDSHP, 1 },
+	[MDP_COMP_TDSHP2] =	{ MDP_COMP_TYPE_TDSHP, 2 },
+	[MDP_COMP_TDSHP3] =	{ MDP_COMP_TYPE_TDSHP, 3 },
+	[MDP_COMP_COLOR0] =	{ MDP_COMP_TYPE_COLOR, 0 },
+	[MDP_COMP_COLOR1] =	{ MDP_COMP_TYPE_COLOR, 1 },
+	[MDP_COMP_COLOR2] =	{ MDP_COMP_TYPE_COLOR, 2 },
+	[MDP_COMP_COLOR3] =	{ MDP_COMP_TYPE_COLOR, 3 },
+	[MDP_COMP_OVL0] =	{ MDP_COMP_TYPE_OVL, 0 },
+	[MDP_COMP_OVL1] =	{ MDP_COMP_TYPE_OVL, 1 },
+	[MDP_COMP_PAD0] =	{ MDP_COMP_TYPE_PAD, 0 },
+	[MDP_COMP_PAD1] =	{ MDP_COMP_TYPE_PAD, 1 },
+	[MDP_COMP_PAD2] =	{ MDP_COMP_TYPE_PAD, 2 },
+	[MDP_COMP_PAD3] =	{ MDP_COMP_TYPE_PAD, 3 },
+	[MDP_COMP_TCC0] =	{ MDP_COMP_TYPE_TCC, 0 },
+	[MDP_COMP_TCC1] =	{ MDP_COMP_TYPE_TCC, 1 },
 	[MDP_COMP_WROT0] =	{ MDP_COMP_TYPE_WROT, 0 },
-	[MDP_COMP_WDMA] =	{ MDP_COMP_TYPE_WDMA, 0 },
-};
+	[MDP_COMP_WROT1] =	{ MDP_COMP_TYPE_WROT, 1 },
+	[MDP_COMP_WROT2] =	{ MDP_COMP_TYPE_WROT, 2 },
+	[MDP_COMP_WROT3] =	{ MDP_COMP_TYPE_WROT, 3 },
+	[MDP_COMP_PQ0_SOUT] =		{ MDP_COMP_TYPE_DUMMY, 0 },
+	[MDP_COMP_PQ1_SOUT] =		{ MDP_COMP_TYPE_DUMMY, 1 },
+	[MDP_COMP_TO_WARP0MOUT] =	{ MDP_COMP_TYPE_DUMMY, 2 },
+	[MDP_COMP_TO_WARP1MOUT] =	{ MDP_COMP_TYPE_DUMMY, 3 },
+	[MDP_COMP_TO_SVPP2MOUT] =	{ MDP_COMP_TYPE_DUMMY, 4 },
+	[MDP_COMP_TO_SVPP3MOUT] =	{ MDP_COMP_TYPE_DUMMY, 5 },
+	[MDP_COMP_VPP0_SOUT] =		{ MDP_COMP_TYPE_DUMMY, 6 },
+	[MDP_COMP_VPP1_SOUT] =		{ MDP_COMP_TYPE_DUMMY, 7 },
 
+};
+*/
 static const char * const gce_event_names[MDP_MAX_EVENT_COUNT] = {
-	[RDMA0_SOF] = "rdma0_sof",
-	[RDMA0_DONE] = "rdma0_done",
-	[RSZ0_SOF] = "rsz0_sof",
-	[RSZ1_SOF] = "rsz1_sof",
-	[TDSHP0_SOF] = "tdshp0_sof",
-	[WROT0_SOF] = "wrot0_sof",
-	[WROT0_DONE] = "wrot0_done",
-	[WDMA0_SOF] = "wdma0_sof",
-	[WDMA0_DONE] = "wdma0_done",
-
-	[ISP_P2_0_DONE] = "isp_p2_0_done",
-	[ISP_P2_1_DONE] = "isp_p2_1_done",
-	[ISP_P2_2_DONE] = "isp_p2_2_done",
-	[ISP_P2_3_DONE] = "isp_p2_3_done",
-	[ISP_P2_4_DONE] = "isp_p2_4_done",
-	[ISP_P2_5_DONE] = "isp_p2_5_done",
-	[ISP_P2_6_DONE] = "isp_p2_6_done",
-	[ISP_P2_7_DONE] = "isp_p2_7_done",
-	[ISP_P2_8_DONE] = "isp_p2_8_done",
-	[ISP_P2_9_DONE] = "isp_p2_9_done",
-	[ISP_P2_10_DONE] = "isp_p2_10_done",
-	[ISP_P2_11_DONE] = "isp_p2_11_done",
-	[ISP_P2_12_DONE] = "isp_p2_12_done",
-	[ISP_P2_13_DONE] = "isp_p2_13_done",
-	[ISP_P2_14_DONE] = "isp_p2_14_done",
-
-	[WPE_DONE] = "wpe_done",
-	[WPE_B_DONE] = "wpe_b_done",
+    [RDMA0_SOF]         = "RDMA0_SOF",
+    [RDMA0_FRAME_DONE]  = "RDMA0_FRAME_DONE",
+    [WROT0_SOF]         = "WROT0_SOF",
+    [WROT0_FRAME_DONE]  = "WROT0_FRAME_DONE",
+    [RDMA1_SOF]         = "RDMA1_SOF",
+    [RDMA2_SOF]         = "RDMA2_SOF",
+    [RDMA3_SOF]         = "RDMA3_SOF",
+    [WROT1_SOF]         = "WROT1_SOF",
+    [WROT2_SOF]         = "WROT2_SOF",
+    [WROT3_SOF]         = "WROT3_SOF",
+    [RDMA1_FRAME_DONE]  = "RDMA1_FRAME_DONE",
+    [RDMA2_FRAME_DONE]  = "RDMA2_FRAME_DONE",
+    [RDMA3_FRAME_DONE]  = "RDMA3_FRAME_DONE",
+    [WROT1_FRAME_DONE]  = "WROT1_FRAME_DONE",
+    [WROT2_FRAME_DONE]  = "WROT2_FRAME_DONE",
+    [WROT3_FRAME_DONE]  = "WROT3_FRAME_DONE",
 };
 
 static const struct of_device_id mdp_comp_dt_ids[] = {
 	{
-		.compatible = "mediatek,mt8183-mdp3-rdma",
+		.compatible = "mediatek,mt8195-mdp-rdma",
 		.data = (void *)MDP_COMP_TYPE_RDMA,
+	},  {
+	    .compatible = "mediatek,mt8195-mdp-stitch",
+		.data = (void *)MDP_COMP_TYPE_STITCH,
+	},{
+		.compatible = "mediatek,mt8195-mdp-fg",
+		.data = (void *)MDP_COMP_TYPE_FG,
 	}, {
-		.compatible = "mediatek,mt8183-mdp3-ccorr",
-		.data = (void *)MDP_COMP_TYPE_CCORR,
+	    .compatible = "mediatek,mt8195-mdp-hdr",
+		.data = (void *)MDP_COMP_TYPE_HDR,
 	}, {
-		.compatible = "mediatek,mt8183-mdp3-rsz",
+	    .compatible = "mediatek,mt8195-mdp-aal",
+		.data = (void *)MDP_COMP_TYPE_AAL,
+	}, {
+		.compatible = "mediatek,mt8195-mdp-rsz",
 		.data = (void *)MDP_COMP_TYPE_RSZ,
+	},  {
+		.compatible = "mediatek,mt8195-mdp-merge",
+		.data = (void *)MDP_COMP_TYPE_MERGE,
 	}, {
-		.compatible = "mediatek,mt8183-mdp3-wrot",
-		.data = (void *)MDP_COMP_TYPE_WROT,
+		.compatible = "mediatek,mt8195-mdp-tdshp",
+		.data = (void *)MDP_COMP_TYPE_TDSHP,
 	}, {
-		.compatible = "mediatek,mt8183-mdp3-wdma",
-		.data = (void *)MDP_COMP_TYPE_WDMA,
-	},
-	{}
-};
-
-static const struct of_device_id mdp_sub_comp_dt_ids[] = {
-	{
-		.compatible = "mediatek,mt8183-mdp3-path",
-		.data = (void *)MDP_COMP_TYPE_PATH,
+		.compatible = "mediatek,mt8195-mdp-color",
+		.data = (void *)MDP_COMP_TYPE_COLOR,
+	},{
+		.compatible = "mediatek,mt8195-mdp-ovl",
+		.data = (void *)MDP_COMP_TYPE_OVL,
+	}, {
+		.compatible = "mediatek,mt8195-mdp-pad",
+		.data = (void *)MDP_COMP_TYPE_PAD,
 	}, {
-		.compatible = "mediatek,mt8183-mdp3-imgi",
-		.data = (void *)MDP_COMP_TYPE_IMGI,
+		.compatible = "mediatek,mt8195-mdp-tcc",
+		.data = (void *)MDP_COMP_TYPE_TCC,
 	}, {
-		.compatible = "mediatek,mt8183-mdp3-exto",
-		.data = (void *)MDP_COMP_TYPE_EXTO,
+		.compatible = "mediatek,mt8195-mdp-wrot",
+		.data = (void *)MDP_COMP_TYPE_WROT,
 	}, {
-		.compatible = "mediatek,mt8183-mdp3-dl",
+		.compatible = "mediatek,mt8195-mdp-dl",
 		.data = (void *)MDP_COMP_TYPE_DL_PATH,
 	},
 	{}
 };
 
-/* Used to describe the item order in MDP property */
-struct mdp_comp_info {
-	u32	clk_num;
-	u32 clk_ofst;
-	u32	dts_reg_ofst;
-};
-
-static const struct mdp_comp_info mdp_comp_dt_info[MDP_COMP_TYPE_COUNT] = {
-	[MDP_COMP_TYPE_RDMA]		= {2, 0, 0},
-	[MDP_COMP_TYPE_RSZ]		= {1, 0, 0},
-	[MDP_COMP_TYPE_WROT]		= {1, 0, 0},
-	[MDP_COMP_TYPE_WDMA]		= {1, 0, 0},
-	[MDP_COMP_TYPE_PATH]		= {0, 0, 0},
-	[MDP_COMP_TYPE_CCORR]		= {1, 0, 0},
-	[MDP_COMP_TYPE_IMGI]		= {0, 0, 2},
-	[MDP_COMP_TYPE_EXTO]		= {0, 0, 2},
-	[MDP_COMP_TYPE_DL_PATH]	= {4, 2, 1},
-};
-
-static int mdp_comp_get_id(enum mdp_comp_type type, u32 alias_id)
+static int mdp_comp_get_id(struct device *dev, struct device_node *node,
+			   enum mdp_comp_type type)
 {
-	int i;
+	u32 alias_id;
+	int i, ret;
+
+	ret = of_property_read_u32(node, "mediatek,mdp-id", &alias_id);
+	if (ret)
+		return ret;
 
 	for (i = 0; i < ARRAY_SIZE(mdp_comp_matches); i++)
 		if (mdp_comp_matches[i].type == type &&
 		    mdp_comp_matches[i].alias_id == alias_id)
 			return i;
-	return -ENODEV;
+
+	dev_err(dev, "Failed to get id. type: %d, alias: %d\n", type, alias_id);
+	return -EINVAL;
 }
 
 void mdp_comp_clock_on(struct device *dev, struct mdp_comp *comp)
@@ -1054,10 +1719,10 @@ void mdp_comp_clock_on(struct device *dev, struct mdp_comp *comp)
 	int i, err;
 
 	if (comp->comp_dev) {
-		err = pm_runtime_get_sync(comp->comp_dev);
+		err = pm_runtime_resume_and_get(comp->comp_dev);
 		if (err < 0)
 			dev_err(dev,
-				"Failed to get power, err %d. type:%d id:%d\n",
+				"Failed to get larb, err %d. type:%d id:%d\n",
 				err, comp->type, comp->id);
 	}
 
@@ -1086,29 +1751,12 @@ void mdp_comp_clock_off(struct device *dev, struct mdp_comp *comp)
 		pm_runtime_put(comp->comp_dev);
 }
 
-void mdp_comp_clocks_on(struct device *dev, struct mdp_comp *comps, int num)
-{
-	int i;
-
-	for (i = 0; i < num; i++)
-		mdp_comp_clock_on(dev, &comps[i]);
-}
-
-void mdp_comp_clocks_off(struct device *dev, struct mdp_comp *comps, int num)
-{
-	int i;
-
-	for (i = 0; i < num; i++)
-		mdp_comp_clock_off(dev, &comps[i]);
-}
-
 static int mdp_get_subsys_id(struct device *dev, struct device_node *node,
 			     struct mdp_comp *comp)
 {
 	struct platform_device *comp_pdev;
 	struct cmdq_client_reg  *cmdq_reg;
 	int ret = 0;
-	int index = 0;
 
 	if (!dev || !node || !comp)
 		return -EINVAL;
@@ -1125,8 +1773,7 @@ static int mdp_get_subsys_id(struct device *dev, struct device_node *node,
 	if (!cmdq_reg)
 		return -ENOMEM;
 
-	index = mdp_comp_dt_info[comp->type].dts_reg_ofst;
-	ret = cmdq_dev_get_client_reg(&comp_pdev->dev, cmdq_reg, index);
+	ret = cmdq_dev_get_client_reg(&comp_pdev->dev, cmdq_reg, 0);
 	if (ret != 0) {
 		dev_err(&comp_pdev->dev,
 			"cmdq_dev_get_subsys fail!\n");
@@ -1135,7 +1782,7 @@ static int mdp_get_subsys_id(struct device *dev, struct device_node *node,
 	}
 
 	comp->subsys_id = cmdq_reg->subsys;
-	dev_info(&comp_pdev->dev, "subsys id=%d\n", cmdq_reg->subsys);
+	dev_err(&comp_pdev->dev, "subsys id=%d\n", cmdq_reg->subsys);
 
 	kfree(cmdq_reg);
 
@@ -1147,24 +1794,51 @@ static void __mdp_comp_init(struct mdp_dev *mdp, struct device_node *node,
 {
 	struct resource res;
 	phys_addr_t base;
-	int index = mdp_comp_dt_info[comp->type].dts_reg_ofst;
+	int i;
 
-	if (of_address_to_resource(node, index, &res) < 0)
+	if (of_address_to_resource(node, 0, &res) < 0)
 		base = 0L;
 	else
 		base = 0L | res.start;
 
 	comp->mdp_dev = mdp;
+	/* comp->dev_node = of_node_get(node); */
 	comp->regs = of_iomap(node, 0);
 	comp->reg_base = base;
+    for (i = 0; i < ARRAY_SIZE(comp->clks); i++) {
+        comp->clks[i] = of_clk_get(node, i);
+        if (IS_ERR(comp->clks[i]))
+            break;
+    }
 }
 
-static int mdp_comp_init(struct mdp_dev *mdp, struct device_node *node,
-			 struct mdp_comp *comp, enum mdp_comp_id id)
+static int mdp_mm_init(struct mdp_dev *mdp,
+		       struct mdp_comp *comp, const char *ref_name)
 {
+	struct device_node *node;
 	struct device *dev = &mdp->pdev->dev;
-	int clk_num;
-	int clk_ofst;
+
+	node = of_parse_phandle(dev->of_node, ref_name, 0);
+	if (!node) {
+		dev_err(dev, "Failed to parse dt %s\n", ref_name);
+		return -EINVAL;
+	}
+
+	__mdp_comp_init(mdp, node, comp);
+	mdp_get_subsys_id(dev, node, comp);
+	of_node_put(node);
+	if (!comp->reg_base) {
+		dev_err(dev, "Failed to init %s base\n", ref_name);
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int mdp_comp_init(struct device *dev, struct mdp_dev *mdp,
+			 struct device_node *node, struct mdp_comp *comp,
+			 enum mdp_comp_id id)
+{
+	struct platform_device *pdev;
 	int i;
 
 	if (id < 0 || id >= MDP_MAX_COMP_COUNT) {
@@ -1172,130 +1846,45 @@ static int mdp_comp_init(struct mdp_dev *mdp, struct device_node *node,
 		return -EINVAL;
 	}
 
+	__mdp_comp_init(mdp, node, comp);
 	comp->type = mdp_comp_matches[id].type;
 	comp->id = id;
 	comp->alias_id = mdp_comp_matches[id].alias_id;
 	comp->ops = mdp_comp_ops[comp->type];
-	__mdp_comp_init(mdp, node, comp);
 
-	clk_num = mdp_comp_dt_info[comp->type].clk_num;
-	clk_ofst = mdp_comp_dt_info[comp->type].clk_ofst;
-
-	for (i = 0; i < clk_num; i++) {
-		comp->clks[i] = of_clk_get(node, i + clk_ofst);
+	for (i = 0; i < ARRAY_SIZE(comp->clks); i++) {
+		comp->clks[i] = of_clk_get(node, i);
 		if (IS_ERR(comp->clks[i]))
 			break;
 	}
 
 	mdp_get_subsys_id(dev, node, comp);
 
-	return 0;
-}
-
-static struct mdp_comp *mdp_comp_create(struct mdp_dev *mdp,
-					struct device_node *node,
-					enum mdp_comp_id id)
-{
-	struct device *dev = &mdp->pdev->dev;
-	struct mdp_comp *comp;
-	int ret;
-
-	if (mdp->comp[id])
-		return ERR_PTR(-EEXIST);
-
-	comp = devm_kzalloc(dev, sizeof(*comp), GFP_KERNEL);
-	if (!comp)
-		return ERR_PTR(-ENOMEM);
+	/* Only DMA capable components need the pm control */
+	comp->comp_dev = NULL;
+	if (comp->type != MDP_COMP_TYPE_RDMA &&
+	    comp->type != MDP_COMP_TYPE_WROT &&
+		comp->type != MDP_COMP_TYPE_WDMA)
+		return 0;
 
-	ret = mdp_comp_init(mdp, node, comp, id);
-	if (ret) {
-		kfree(comp);
-		return ERR_PTR(ret);
+	pdev = of_find_device_by_node(node);
+	if (!pdev) {
+		dev_warn(dev, "can't find platform device of node:%s\n",
+			 node->name);
+		return -ENODEV;
 	}
-	mdp->comp[id] = comp;
-
-	dev_info(dev, "%s type:%d alias:%d id:%d base:%#x regs:%p\n",
-		dev->of_node->name, comp->type, comp->alias_id, id,
-		(u32)comp->reg_base, comp->regs);
-	return comp;
-}
-
-static int mdp_sub_comps_create(struct mdp_dev *mdp, struct device_node *node)
-{
-	struct device *dev = &mdp->pdev->dev;
-	struct property *prop;
-	const char *name;
-	int index = 0;
-
-	of_property_for_each_string(node, "mdp3-comps", prop, name) {
-		const struct of_device_id *matches = mdp_sub_comp_dt_ids;
-		enum mdp_comp_type type = MDP_COMP_NONE;
-		u32 alias_id;
-		int id, ret;
-		struct mdp_comp *comp;
-
-		for (; matches->compatible[0]; matches++) {
-			if (of_compat_cmp(name, matches->compatible,
-					 strlen(matches->compatible)) == 0) {
-				type = (enum mdp_comp_type)matches->data;
-				break;
-			}
-		}
-
-		ret = of_property_read_u32_index(node, "mdp3-comp-ids",
-						index, &alias_id);
-		if (ret) {
-			dev_warn(dev, "Skipping unknown component %s\n", name);
-			return ret;
-		}
 
-		id = mdp_comp_get_id(type, alias_id);
-		if (id < 0) {
-			dev_err(dev, "Failed to get component id: "
-				"%s type %d, alias %d\n", name, type, alias_id);
-			return -ENODEV;
-		}
+	comp->comp_dev = &pdev->dev;
+	pm_runtime_enable(comp->comp_dev);
 
-		comp = mdp_comp_create(mdp, node, id);
-		if (IS_ERR(comp))
-			return PTR_ERR(comp);
 
-		index++;
-	}
 	return 0;
 }
 
 static void mdp_comp_deinit(struct mdp_comp *comp)
 {
-	if (!comp)
-		return;
-
-	if (comp->regs)
-		iounmap(comp->regs);
-}
-
-static int mdp_mm_init(struct mdp_dev *mdp, struct mdp_comp *comp,
-		       const char *ref_name)
-{
-	struct device_node *node;
-	struct device *dev = &mdp->pdev->dev;
-
-	node = of_parse_phandle(dev->of_node, ref_name, 0);
-	if (!node) {
-		dev_err(dev, "Failed to parse dt %s\n", ref_name);
-		return -EINVAL;
-	}
-
-	__mdp_comp_init(mdp, node, comp);
-	mdp_get_subsys_id(dev, node, comp);
-	of_node_put(node);
-	if (!comp->reg_base) {
-		dev_err(dev, "Failed to init %s base\n", ref_name);
-		of_node_put(node);
-		return -EINVAL;
-	}
-
-	return 0;
+	iounmap(comp->regs);
+	/* of_node_put(comp->dev_node); */
 }
 
 void mdp_component_deinit(struct mdp_dev *mdp)
@@ -1316,8 +1905,6 @@ int mdp_component_init(struct mdp_dev *mdp)
 {
 	struct device *dev = &mdp->pdev->dev;
 	struct device_node *node, *parent;
-	struct platform_device *pdev;
-	u32 alias_id;
 	int i, ret;
 
 	for (i = RDMA0_SOF; i < MDP_MAX_EVENT_COUNT; i++) {
@@ -1325,7 +1912,6 @@ int mdp_component_init(struct mdp_dev *mdp)
 
 		if (!dev)
 			return -EINVAL;
-
 		if (of_property_read_u32_index(dev->of_node,
 					       "mediatek,gce-events",
 					       i, &event_id)) {
@@ -1339,12 +1925,18 @@ int mdp_component_init(struct mdp_dev *mdp)
 	}
 
 	ret = mdp_mm_init(mdp, &mdp->mmsys, "mediatek,mmsys");
+	if (ret)
+		goto err_init_mm;
+	ret = mdp_mm_init(mdp, &mdp->vppsys, "mediatek,mmsys2");
 	if (ret)
 		goto err_init_mm;
 
 	ret = mdp_mm_init(mdp, &mdp->mm_mutex, "mediatek,mm-mutex");
 	if (ret)
-		goto err_init_comps;
+		goto err_init_mm;
+	ret = mdp_mm_init(mdp, &mdp->vpp_mutex, "mediatek,mm-mutex2");
+	if (ret)
+		goto err_init_mm;
 
 	parent = dev->of_node->parent;
 	/* Iterate over sibling MDP function blocks */
@@ -1365,45 +1957,43 @@ int mdp_component_init(struct mdp_dev *mdp)
 		}
 
 		type = (enum mdp_comp_type)of_id->data;
-		ret = of_property_read_u32(node, "mediatek,mdp3-id", &alias_id);
-		if (ret) {
+		id = mdp_comp_get_id(dev, node, type);
+		if (id < 0) {
 			dev_warn(dev, "Skipping unknown component %pOF\n",
 				 node);
 			continue;
 		}
-		id = mdp_comp_get_id(type, alias_id);
-		if (id < 0) {
-			dev_err(dev,
-				"Fail to get component id: type %d alias %d\n",
-				type, alias_id);
-			continue;
-		}
 
-		comp = mdp_comp_create(mdp, node, id);
-		if (IS_ERR(comp))
+		comp = devm_kzalloc(dev, sizeof(*comp), GFP_KERNEL);
+		if (!comp) {
+			ret = -ENOMEM;
 			goto err_init_comps;
+		}
+		mdp->comp[id] = comp;
 
-		ret = mdp_sub_comps_create(mdp, node);
+		ret = mdp_comp_init(dev, mdp, node, comp, id);
 		if (ret)
 			goto err_init_comps;
 
-		/* Only DMA capable components need the pm control */
-		comp->comp_dev = NULL;
-		if (comp->type != MDP_COMP_TYPE_RDMA &&
-		    comp->type != MDP_COMP_TYPE_WROT &&
-			comp->type != MDP_COMP_TYPE_WDMA)
-			continue;
+		/* Assign VPPSYS base addr and subsys id */
+		comp->aux_base = 0;
+		comp->aux_subsys_id = 0;
+		comp->vpp0_base = mdp->mmsys.reg_base;
+		comp->vpp0_subsys_id = mdp->mmsys.subsys_id;
+		comp->vpp1_base = mdp->vppsys.reg_base;
+		comp->vpp1_subsys_id = mdp->vppsys.subsys_id;
+
+		dev_info(dev, "%s type:%d alias:%d id:%d base:%#x regs:%p\n",
+			 of_id->compatible, type, comp->alias_id, id,
+			(u32)comp->reg_base, comp->regs);
+	}
+	/* Assign aux base addr and subsys id for specific engine */
+	mdp->comp[MDP_COMP_RSZ2]->aux_base = mdp->comp[MDP_COMP_MERGE2]->reg_base;
+	mdp->comp[MDP_COMP_RSZ2]->aux_subsys_id = mdp->comp[MDP_COMP_MERGE2]->subsys_id;
 
-		pdev = of_find_device_by_node(node);
-		if (!pdev) {
-			dev_warn(dev, "can't find platform device of node:%s\n",
-				 node->name);
-			return -ENODEV;
-		}
+	mdp->comp[MDP_COMP_RSZ3]->aux_base = mdp->comp[MDP_COMP_MERGE3]->reg_base;
+	mdp->comp[MDP_COMP_RSZ3]->aux_subsys_id = mdp->comp[MDP_COMP_MERGE3]->subsys_id;
 
-		comp->comp_dev = &pdev->dev;
-		pm_runtime_enable(comp->comp_dev);
-	}
 	return 0;
 
 err_init_comps:
@@ -1433,6 +2023,219 @@ int mdp_comp_ctx_init(struct mdp_dev *mdp, struct mdp_comp_ctx *ctx,
 	ctx->input = &frame->inputs[param->input];
 	for (i = 0; i < param->num_outputs; i++)
 		ctx->outputs[i] = &frame->outputs[param->outputs[i]];
+
 	return 0;
 }
 
+int mdp_hyfbc_patch(struct mdp_dev *mdp, struct mdp_cmd *cmd,
+		struct hyfbcPatchStruct *hyfbc, enum mdp_comp_id wrot)
+{
+#define is_wrot(id) \
+    (mdp_comp_matches[id].type == MDP_COMP_TYPE_WROT)
+#define is_wrot0(id) \
+    (mdp_comp_matches[id].type == MDP_COMP_TYPE_WROT) && \
+    (mdp_comp_matches[id].alias_id == 0)
+
+#define byte2pixel(byte) (byte/2)
+
+	phys_addr_t base = mdp->comp[wrot]->reg_base;
+	u16 subsys_id = mdp->comp[wrot]->subsys_id;
+
+	phys_addr_t vpp0_base = mdp->mmsys.reg_base;
+	u16 vpp0_id = mdp->mmsys.subsys_id;
+
+	phys_addr_t vpp0_mutex = mdp->mm_mutex.reg_base;
+	u16 vpp0_mutex_id = mdp->mm_mutex.subsys_id;
+
+	phys_addr_t vpp1_mutex = mdp->vpp_mutex.reg_base;
+	u16 vpp1_mutex_id = mdp->vpp_mutex.subsys_id;
+
+	u32 offset = hyfbc->width_in_mb * hyfbc->byte_per_mb;
+	u32 mutex_id;
+	u32 mutex2_id;
+
+	if(!is_wrot(wrot))
+	{
+		mdp_err("Invalid wrot id %d",wrot);
+		return -EINVAL;
+	}
+
+	mdp_dbg(2, "10b(%d), size_mb(%d, %d), stride(%d, %d), byte(%d), addr(0x%x)\n",
+		hyfbc->is10b,
+		hyfbc->width_in_mb,
+		hyfbc->height_in_mb,
+		hyfbc->w_stride_in_mb,
+		hyfbc->h_stride_in_mb,
+		hyfbc->byte_per_mb,
+		hyfbc->pa_base);
+
+	// Enable DCM (VPP02VPP1_RELAY)
+	MM_REG_WRITE_MASK(cmd, vpp0_id, vpp0_base, VPPSYS0_HW_DCM_1ST_DIS0, 0x0, 0x4000);
+
+	/* Reset WROT */
+	MM_REG_WRITE(cmd, subsys_id, base, VIDO_SOFT_RST, 0x01, 0x00000001);
+	MM_REG_POLL(cmd, subsys_id, base, VIDO_SOFT_RST_STAT, 0x01, 0x00000001);
+	MM_REG_WRITE(cmd, subsys_id, base, VIDO_SOFT_RST, 0x00, 0x00000001);
+	MM_REG_POLL(cmd, subsys_id, base, VIDO_SOFT_RST_STAT, 0x00, 0x00000001);
+
+	/* Write frame base address */
+	MM_REG_WRITE(cmd, subsys_id, base, VIDO_BASE_ADDR, (hyfbc->pa_base + offset),
+			0xFFFFFFFF);
+	MM_REG_WRITE(cmd, subsys_id, base, VIDO_BASE_ADDR_C, 0x0,
+			0xFFFFFFFF);
+	MM_REG_WRITE(cmd, subsys_id, base, VIDO_BASE_ADDR_V, 0x0,
+			0xFFFFFFFF);
+
+	/* Write frame related registers */
+	MM_REG_WRITE(cmd, subsys_id, base, VIDO_CTRL, 0x5020,
+			0xF131512F);
+	MM_REG_WRITE(cmd, subsys_id, base, VIDO_BKGD,
+			((hyfbc->is10b)? 0xC8E438 : 0x18f4f8), 0xFFFFFFFF);
+
+	MM_REG_WRITE(cmd, subsys_id, base, VIDO_SCAN_10BIT, 0x0, 0x0000000F);
+	MM_REG_WRITE(cmd, subsys_id, base, VIDO_PENDING_ZERO, 0x0, 0x04000000);
+	MM_REG_WRITE(cmd, subsys_id, base, VIDO_CTRL_2, 0x0, 0x00000007);
+
+	MM_REG_WRITE(cmd, subsys_id, base, VIDO_PVRIC,  0x0, 0x03);
+	/* Write pre-ultra threshold */
+	MM_REG_WRITE(cmd, subsys_id, base, VIDO_DMA_PREULTRA, 0x8804c,
+			0x00FFFFFF);
+	/* Write frame Y pitch */
+	MM_REG_WRITE(cmd, subsys_id, base, VIDO_STRIDE,
+			(hyfbc->w_stride_in_mb * hyfbc->byte_per_mb), 0x0000FFFF);
+	/* Write frame UV pitch */
+	MM_REG_WRITE(cmd, subsys_id, base, VIDO_STRIDE_C, 0x0,
+			0x0000FFFF);
+	MM_REG_WRITE(cmd, subsys_id, base, VIDO_STRIDE_V, 0x0,
+			0x0000FFFF);
+	/* Write matrix control */
+	MM_REG_WRITE(cmd, subsys_id, base, VIDO_MAT_CTRL, 0x60,
+			0x000000F3);
+
+	/* Set the fixed ALPHA as 0xFF */
+	MM_REG_WRITE(cmd, subsys_id, base, VIDO_DITHER, 0xFF000000,
+			0xFF000000);
+	/* Set VIDO_EOL_SEL */
+	MM_REG_WRITE(cmd, subsys_id, base, VIDO_RSV_1, 0x80000000,
+			0x80000000);
+	/* Set VIDO_FIFO_TEST */
+	MM_REG_WRITE(cmd, subsys_id, base, VIDO_FIFO_TEST,
+		     0x200, 0x00000FFF);
+
+	/* Filter enable */
+	MM_REG_WRITE(cmd, subsys_id, base, VIDO_MAIN_BUF_SIZE, 0x0,
+		     0x00000077);
+
+	/* Turn off WROT dma dcm */
+	MM_REG_WRITE(cmd, subsys_id, base, VIDO_ROT_EN, (0x1 << 23) +
+                                                    (0x1 << 20), 0x00900000);
+
+	/* Set mutex modules */
+	switch(wrot)
+	{
+		case MDP_COMP_WROT0:
+			mutex_id = 2;
+			MM_REG_WRITE(cmd, vpp0_mutex_id, vpp0_mutex, MM_MUTEX_MOD,
+				     0x800, 0x0FFFFFFF);
+			MM_REG_WRITE(cmd, vpp0_mutex_id, vpp0_mutex, MM_MUTEX_MOD1,
+				     0x0, 0x0FFFFFFF);
+			MM_REG_WRITE(cmd, vpp0_mutex_id, vpp0_mutex, MM_MUTEX_SOF,
+				     0x0, 0x00000007);
+			break;
+		case MDP_COMP_WROT1:
+			mutex2_id = 1;
+			MM_REG_WRITE(cmd, vpp1_mutex_id, vpp1_mutex, VPP_MUTEX_MOD,
+				     0x80000000, 0x0FFFFFFF);
+			MM_REG_WRITE(cmd, vpp1_mutex_id, vpp1_mutex, VPP_MUTEX_MOD1,
+				     0x0, 0x0FFFFFFF);
+			MM_REG_WRITE(cmd, vpp1_mutex_id, vpp1_mutex, VPP_MUTEX_SOF,
+				     0x0, 0x00000007);
+			break;
+		case MDP_COMP_WROT2:
+			mutex2_id = 2;
+			MM_REG_WRITE(cmd, vpp1_mutex_id, vpp1_mutex, VPP_MUTEX_MOD,
+				     0x0, 0x0FFFFFFF);
+			MM_REG_WRITE(cmd, vpp1_mutex_id, vpp1_mutex, VPP_MUTEX_MOD1,
+				     0x1, 0x0FFFFFFF);
+			MM_REG_WRITE(cmd, vpp1_mutex_id, vpp1_mutex, VPP_MUTEX_SOF,
+				     0x0, 0x00000007);
+			break;
+		case MDP_COMP_WROT3:
+			mutex2_id = 3;
+			MM_REG_WRITE(cmd, vpp1_mutex_id, vpp1_mutex, VPP_MUTEX_MOD,
+				     0x0, 0x0FFFFFFF);
+			MM_REG_WRITE(cmd, vpp1_mutex_id, vpp1_mutex, VPP_MUTEX_MOD1,
+				     0x2, 0x0FFFFFFF);
+			MM_REG_WRITE(cmd, vpp1_mutex_id, vpp1_mutex, VPP_MUTEX_SOF,
+				     0x0, 0x00000007);
+			break;
+		default:
+			break;
+	}
+
+	/* Write Y pixel offset */
+	MM_REG_WRITE(cmd, subsys_id, base, VIDO_OFST_ADDR,
+		     0x0, 0x0FFFFFFF);
+	/* Write U pixel offset */
+	MM_REG_WRITE(cmd, subsys_id, base, VIDO_OFST_ADDR_C,
+		     0x0, 0x0FFFFFFF);
+	/* Write V pixel offset */
+	MM_REG_WRITE(cmd, subsys_id, base, VIDO_OFST_ADDR_V,
+		     0x0, 0x0FFFFFFF);
+	/* Write source size */
+	MM_REG_WRITE(cmd, subsys_id, base, VIDO_IN_SIZE,
+		(hyfbc->height_in_mb << 16) | byte2pixel(hyfbc->byte_per_mb), 0xFFFFFFFF);
+	/* Write target size */
+	MM_REG_WRITE(cmd, subsys_id, base, VIDO_TAR_SIZE,
+		(hyfbc->height_in_mb << 16) | byte2pixel(hyfbc->byte_per_mb), 0xFFFFFFFF);
+	MM_REG_WRITE(cmd, subsys_id, base, VIDO_CROP_OFST, 0x0,
+		0xFFFFFFFF);
+
+	MM_REG_WRITE(cmd, subsys_id, base, VIDO_MAIN_BUF_SIZE,
+		((byte2pixel(hyfbc->byte_per_mb) << 16) | 0x400), 0xFFFF7F00);
+
+	// Set wrot interrupt bit for debug, this bit will clear to 0 after wrot done.
+	MM_REG_WRITE(cmd, subsys_id, base, VIDO_INT, 0x1, VIDO_INT_MASK);
+
+	/* Enable WROT */
+	MM_REG_WRITE(cmd, subsys_id, base, VIDO_ROT_EN, 0x01, 0x00000001);
+
+	switch(wrot)
+	{
+		case MDP_COMP_WROT0:
+			MM_REG_CLEAR(cmd, WROT0_SOF);
+			MM_REG_WRITE(cmd, vpp0_mutex_id, vpp0_mutex, MM_MUTEX_EN, 0x1,
+				     0x00000001);
+			MM_REG_WAIT(cmd, WROT0_SOF);
+		    MM_REG_WAIT(cmd, WROT0_FRAME_DONE);
+			break;
+		case MDP_COMP_WROT1:
+			MM_REG_CLEAR(cmd, WROT1_SOF);
+			MM_REG_WRITE(cmd, vpp1_mutex_id, vpp1_mutex, VPP_MUTEX_EN, 0x1,
+				     0x00000001);
+			MM_REG_WAIT(cmd, WROT1_SOF);
+		    MM_REG_WAIT(cmd, WROT1_FRAME_DONE);
+			break;
+		case MDP_COMP_WROT2:
+			MM_REG_CLEAR(cmd, WROT2_SOF);
+			MM_REG_WRITE(cmd, vpp1_mutex_id, vpp1_mutex, VPP_MUTEX_EN, 0x1,
+				     0x00000001);
+			MM_REG_WAIT(cmd, WROT2_SOF);
+		    MM_REG_WAIT(cmd, WROT2_FRAME_DONE);
+			break;
+		case MDP_COMP_WROT3:
+			MM_REG_CLEAR(cmd, WROT3_SOF);
+			MM_REG_WRITE(cmd, vpp1_mutex_id, vpp1_mutex, VPP_MUTEX_EN, 0x1,
+				     0x00000001);
+			MM_REG_WAIT(cmd, WROT3_SOF);
+		    MM_REG_WAIT(cmd, WROT3_FRAME_DONE);
+			break;
+		default:
+			break;
+	}
+
+	/* Disable WROT */
+	MM_REG_WRITE(cmd, subsys_id, base, VIDO_ROT_EN, 0x00, 0x00000001);
+
+	return 0;
+}
diff --git a/drivers/media/platform/mtk-mdp3/mtk-mdp3-comp.h b/drivers/media/platform/mtk-mdp3/mtk-mdp3-comp.h
index 21af4933fb8cdeba886026e810c594e92257c3ae..e35c8cea8111de19144881317d6f5ae5a9fd3a3b 100644
--- a/drivers/media/platform/mtk-mdp3/mtk-mdp3-comp.h
+++ b/drivers/media/platform/mtk-mdp3/mtk-mdp3-comp.h
@@ -12,22 +12,29 @@
 enum mdp_comp_type {
 	MDP_COMP_TYPE_INVALID = 0,
 
+	MDP_COMP_TYPE_IMGI,
+	MDP_COMP_TYPE_WPEI,
+	MDP_COMP_TYPE_SPLIT,
+	MDP_COMP_TYPE_STITCH,
 	MDP_COMP_TYPE_RDMA,
+	MDP_COMP_TYPE_FG,
+	MDP_COMP_TYPE_HDR,
+	MDP_COMP_TYPE_AAL,
 	MDP_COMP_TYPE_RSZ,
-	MDP_COMP_TYPE_WROT,
-	MDP_COMP_TYPE_WDMA,
-	MDP_COMP_TYPE_PATH,
-
 	MDP_COMP_TYPE_TDSHP,
 	MDP_COMP_TYPE_COLOR,
 	MDP_COMP_TYPE_DRE,
 	MDP_COMP_TYPE_CCORR,
-	MDP_COMP_TYPE_HDR,
-
-	MDP_COMP_TYPE_IMGI,
-	MDP_COMP_TYPE_WPEI,
+	MDP_COMP_TYPE_OVL,
+	MDP_COMP_TYPE_PAD,
+	MDP_COMP_TYPE_TCC,
+	MDP_COMP_TYPE_WROT,
+    MDP_COMP_TYPE_MERGE,
+    MDP_COMP_TYPE_WDMA,
+    MDP_COMP_TYPE_PATH,
 	MDP_COMP_TYPE_EXTO,	/* External path */
 	MDP_COMP_TYPE_DL_PATH,	/* Direct-link path */
+	MDP_COMP_TYPE_DUMMY,
 
 	MDP_COMP_TYPE_COUNT	/* ALWAYS keep at the end */
 };
@@ -37,82 +44,179 @@ enum mdp_comp_id {
 
 	/* ISP */
 	MDP_COMP_WPEI = 0,
-	MDP_COMP_WPEO,		/* 1 */
-	MDP_COMP_WPEI2,		/* 2 */
-	MDP_COMP_WPEO2,		/* 3 */
-	MDP_COMP_ISP_IMGI,	/* 4 */
-	MDP_COMP_ISP_IMGO,	/* 5 */
-	MDP_COMP_ISP_IMG2O,	/* 6 */
-
-	/* IPU */
-	MDP_COMP_IPUI,		/* 7 */
-	MDP_COMP_IPUO,		/* 8 */
+	MDP_COMP_WPEO,			  /* 1 */
+	MDP_COMP_WPEI2,			  /* 2 */
+	MDP_COMP_WPEO2,			  /* 3 */
 
 	/* MDP */
-	MDP_COMP_CAMIN,		/* 9 */
-	MDP_COMP_CAMIN2,	/* 10 */
-	MDP_COMP_RDMA0,		/* 11 */
-	MDP_COMP_AAL0,		/* 12 */
-	MDP_COMP_CCORR0,	/* 13 */
-	MDP_COMP_RSZ0,		/* 14 */
-	MDP_COMP_RSZ1,		/* 15 */
-	MDP_COMP_TDSHP0,	/* 16 */
-	MDP_COMP_COLOR0,	/* 17 */
-	MDP_COMP_PATH0_SOUT,	/* 18 */
-	MDP_COMP_PATH1_SOUT,	/* 19 */
-	MDP_COMP_WROT0,		/* 20 */
-	MDP_COMP_WDMA,		/* 21 */
+	MDP_COMP_CAMIN,			  /* 4 */
+	MDP_COMP_CAMIN2,	   	  /* 5 */
+	MDP_COMP_SPLIT,           /* 6 */
+	MDP_COMP_SPLIT2,          /* 7 */
+	MDP_COMP_RDMA0,           /* 8 */
+	MDP_COMP_RDMA1,           /* 9 */
+	MDP_COMP_RDMA2,           /* 10 */
+	MDP_COMP_RDMA3,           /* 11 */
+	MDP_COMP_STITCH,          /* 12 */
+	MDP_COMP_FG0,             /* 13 */
+	MDP_COMP_FG1,             /* 14 */
+	MDP_COMP_FG2,             /* 15 */
+	MDP_COMP_FG3,             /* 16 */
+	MDP_COMP_TO_SVPP2MOUT,    /* 17 */
+	MDP_COMP_TO_SVPP3MOUT,    /* 18 */
+	MDP_COMP_TO_WARP0MOUT,    /* 19 */
+	MDP_COMP_TO_WARP1MOUT,    /* 20 */
+	MDP_COMP_VPP0_SOUT,       /* 21 */
+	MDP_COMP_VPP1_SOUT,       /* 22 */
+	MDP_COMP_PQ0_SOUT,        /* 23 */
+	MDP_COMP_PQ1_SOUT,        /* 24 */
+	MDP_COMP_HDR0,            /* 25 */
+	MDP_COMP_HDR1,            /* 26 */
+	MDP_COMP_HDR2,            /* 27 */
+	MDP_COMP_HDR3,            /* 28 */
+	MDP_COMP_AAL0,            /* 29 */
+	MDP_COMP_AAL1,            /* 30 */
+	MDP_COMP_AAL2,            /* 31 */
+	MDP_COMP_AAL3,            /* 32 */
+	MDP_COMP_RSZ0,            /* 33 */
+	MDP_COMP_RSZ1,            /* 34 */
+	MDP_COMP_RSZ2,            /* 35 */
+	MDP_COMP_RSZ3,            /* 36 */
+	MDP_COMP_TDSHP0,          /* 37 */
+	MDP_COMP_TDSHP1,          /* 38 */
+	MDP_COMP_TDSHP2,          /* 39 */
+	MDP_COMP_TDSHP3,          /* 40 */
+	MDP_COMP_COLOR0,          /* 41 */
+	MDP_COMP_COLOR1,          /* 42 */
+	MDP_COMP_COLOR2,          /* 43 */
+	MDP_COMP_COLOR3,          /* 44 */
+	MDP_COMP_OVL0,            /* 45 */
+	MDP_COMP_OVL1,            /* 46 */
+	MDP_COMP_PAD0,            /* 47 */
+	MDP_COMP_PAD1,            /* 48 */
+	MDP_COMP_PAD2,            /* 49 */
+	MDP_COMP_PAD3,            /* 50 */
+	MDP_COMP_TCC0,            /* 51 */
+	MDP_COMP_TCC1,            /* 52 */
+	MDP_COMP_WROT0,           /* 53 */
+	MDP_COMP_WROT1,           /* 54 */
+	MDP_COMP_WROT2,           /* 55 */
+	MDP_COMP_WROT3,           /* 56 */
+	MDP_COMP_MERGE2,          /* 57 */
+	MDP_COMP_MERGE3,          /* 58 */
 
+	MDP_COMP_VDO0DL0,         /* 59 */
+	MDP_COMP_VDO1DL0,         /* 60 */
+	MDP_COMP_VDO0DL1,         /* 61 */
+	MDP_COMP_VDO1DL1,         /* 62 */
 	/* Dummy Engine */
-	MDP_COMP_RDMA1,		/* 22 */
-	MDP_COMP_RSZ2,		/* 23 */
-	MDP_COMP_TDSHP1,	/* 24 */
-	MDP_COMP_WROT1,		/* 25 */
+	MDP_COMP_WDMA,
 
 	MDP_MAX_COMP_COUNT	/* ALWAYS keep at the end */
 };
 
 enum mdp_comp_event {
-	RDMA0_SOF,
-	RDMA0_DONE,
-	RSZ0_SOF,
-	RSZ1_SOF,
-	TDSHP0_SOF,
-	WROT0_SOF,
-	WROT0_DONE,
-	WDMA0_SOF,
-	WDMA0_DONE,
-
-	ISP_P2_0_DONE,
-	ISP_P2_1_DONE,
-	ISP_P2_2_DONE,
-	ISP_P2_3_DONE,
-	ISP_P2_4_DONE,
-	ISP_P2_5_DONE,
-	ISP_P2_6_DONE,
-	ISP_P2_7_DONE,
-	ISP_P2_8_DONE,
-	ISP_P2_9_DONE,
-	ISP_P2_10_DONE,
-	ISP_P2_11_DONE,
-	ISP_P2_12_DONE,
-	ISP_P2_13_DONE,
-	ISP_P2_14_DONE,
-
-	WPE_DONE,
-	WPE_B_DONE,
-
+    RDMA0_SOF,
+    WROT0_SOF,
+    RDMA0_FRAME_DONE,
+    WROT0_FRAME_DONE,
+    RDMA1_SOF,
+    RDMA2_SOF,
+    RDMA3_SOF,
+    WROT1_SOF,
+    WROT2_SOF,
+    WROT3_SOF,
+    RDMA1_FRAME_DONE,
+    RDMA2_FRAME_DONE,
+    RDMA3_FRAME_DONE,
+    WROT1_FRAME_DONE,
+    WROT2_FRAME_DONE,
+    WROT3_FRAME_DONE,
 	MDP_MAX_EVENT_COUNT	/* ALWAYS keep at the end */
 };
 
+struct mdp_comp_match {
+	enum mdp_comp_type	type;
+	u32			alias_id;
+};
+
+static const struct mdp_comp_match mdp_comp_matches[MDP_MAX_COMP_COUNT] = {
+	[MDP_COMP_WPEI] =	{ MDP_COMP_TYPE_WPEI, 0 },
+	[MDP_COMP_WPEO] =	{ MDP_COMP_TYPE_EXTO, 2 },
+	[MDP_COMP_WPEI2] =	{ MDP_COMP_TYPE_WPEI, 1 },
+	[MDP_COMP_WPEO2] =	{ MDP_COMP_TYPE_EXTO, 3 },
+	[MDP_COMP_CAMIN] =	{ MDP_COMP_TYPE_DL_PATH, 0 },
+	[MDP_COMP_CAMIN2] =	{ MDP_COMP_TYPE_DL_PATH, 1 },
+	[MDP_COMP_SPLIT] =	{ MDP_COMP_TYPE_SPLIT, 0 },
+	[MDP_COMP_SPLIT2] =	{ MDP_COMP_TYPE_SPLIT, 1 },
+	[MDP_COMP_RDMA0] =	{ MDP_COMP_TYPE_RDMA, 0 },
+	[MDP_COMP_RDMA1] =	{ MDP_COMP_TYPE_RDMA, 1 },
+	[MDP_COMP_RDMA2] =	{ MDP_COMP_TYPE_RDMA, 2 },
+	[MDP_COMP_RDMA3] =	{ MDP_COMP_TYPE_RDMA, 3 },
+	[MDP_COMP_STITCH] =	{ MDP_COMP_TYPE_STITCH, 0 },
+	[MDP_COMP_FG0] =	{ MDP_COMP_TYPE_FG, 0 },
+	[MDP_COMP_FG1] =	{ MDP_COMP_TYPE_FG, 1 },
+	[MDP_COMP_FG2] =	{ MDP_COMP_TYPE_FG, 2 },
+	[MDP_COMP_FG3] =	{ MDP_COMP_TYPE_FG, 3 },
+	[MDP_COMP_HDR0] =	{ MDP_COMP_TYPE_HDR, 0 },
+	[MDP_COMP_HDR1] =	{ MDP_COMP_TYPE_HDR, 1 },
+	[MDP_COMP_HDR2] =	{ MDP_COMP_TYPE_HDR, 2 },
+	[MDP_COMP_HDR3] =	{ MDP_COMP_TYPE_HDR, 3 },
+	[MDP_COMP_AAL0] =	{ MDP_COMP_TYPE_AAL, 0 },
+	[MDP_COMP_AAL1] =	{ MDP_COMP_TYPE_AAL, 1 },
+	[MDP_COMP_AAL2] =	{ MDP_COMP_TYPE_AAL, 2 },
+	[MDP_COMP_AAL3] =	{ MDP_COMP_TYPE_AAL, 3 },
+	[MDP_COMP_RSZ0] =	{ MDP_COMP_TYPE_RSZ, 0 },
+	[MDP_COMP_RSZ1] =	{ MDP_COMP_TYPE_RSZ, 1 },
+	[MDP_COMP_RSZ2] =	{ MDP_COMP_TYPE_RSZ, 2 },
+	[MDP_COMP_RSZ3] =	{ MDP_COMP_TYPE_RSZ, 3 },
+	[MDP_COMP_TDSHP0] =	{ MDP_COMP_TYPE_TDSHP, 0 },
+	[MDP_COMP_TDSHP1] =	{ MDP_COMP_TYPE_TDSHP, 1 },
+	[MDP_COMP_TDSHP2] =	{ MDP_COMP_TYPE_TDSHP, 2 },
+	[MDP_COMP_TDSHP3] =	{ MDP_COMP_TYPE_TDSHP, 3 },
+	[MDP_COMP_COLOR0] =	{ MDP_COMP_TYPE_COLOR, 0 },
+	[MDP_COMP_COLOR1] =	{ MDP_COMP_TYPE_COLOR, 1 },
+	[MDP_COMP_COLOR2] =	{ MDP_COMP_TYPE_COLOR, 2 },
+	[MDP_COMP_COLOR3] =	{ MDP_COMP_TYPE_COLOR, 3 },
+	[MDP_COMP_OVL0] =	{ MDP_COMP_TYPE_OVL, 0 },
+	[MDP_COMP_OVL1] =	{ MDP_COMP_TYPE_OVL, 1 },
+	[MDP_COMP_PAD0] =	{ MDP_COMP_TYPE_PAD, 0 },
+	[MDP_COMP_PAD1] =	{ MDP_COMP_TYPE_PAD, 1 },
+	[MDP_COMP_PAD2] =	{ MDP_COMP_TYPE_PAD, 2 },
+	[MDP_COMP_PAD3] =	{ MDP_COMP_TYPE_PAD, 3 },
+	[MDP_COMP_TCC0] =	{ MDP_COMP_TYPE_TCC, 0 },
+	[MDP_COMP_TCC1] =	{ MDP_COMP_TYPE_TCC, 1 },
+	[MDP_COMP_WROT0] =	{ MDP_COMP_TYPE_WROT, 0 },
+	[MDP_COMP_WROT1] =	{ MDP_COMP_TYPE_WROT, 1 },
+	[MDP_COMP_WROT2] =	{ MDP_COMP_TYPE_WROT, 2 },
+	[MDP_COMP_WROT3] =	{ MDP_COMP_TYPE_WROT, 3 },
+	[MDP_COMP_MERGE2] =	{ MDP_COMP_TYPE_MERGE, 2 },
+	[MDP_COMP_MERGE3] =	{ MDP_COMP_TYPE_MERGE, 3 },
+	[MDP_COMP_PQ0_SOUT] =		{ MDP_COMP_TYPE_DUMMY, 0 },
+	[MDP_COMP_PQ1_SOUT] =		{ MDP_COMP_TYPE_DUMMY, 1 },
+	[MDP_COMP_TO_WARP0MOUT] =	{ MDP_COMP_TYPE_DUMMY, 2 },
+	[MDP_COMP_TO_WARP1MOUT] =	{ MDP_COMP_TYPE_DUMMY, 3 },
+	[MDP_COMP_TO_SVPP2MOUT] =	{ MDP_COMP_TYPE_DUMMY, 4 },
+	[MDP_COMP_TO_SVPP3MOUT] =	{ MDP_COMP_TYPE_DUMMY, 5 },
+	[MDP_COMP_VPP0_SOUT] =		{ MDP_COMP_TYPE_DUMMY, 6 },
+	[MDP_COMP_VPP1_SOUT] =		{ MDP_COMP_TYPE_DUMMY, 7 },
+
+};
+
 struct mdp_comp_ops;
 
 struct mdp_comp {
 	struct mdp_dev			*mdp_dev;
 	void __iomem			*regs;
 	phys_addr_t			reg_base;
-	u8				subsys_id;
-	struct clk			*clks[6];
+	u16				subsys_id;
+	phys_addr_t			aux_base;
+	u16				aux_subsys_id;
+	phys_addr_t			vpp0_base;
+	u16				vpp0_subsys_id;
+	phys_addr_t			vpp1_base;
+	u16				vpp1_subsys_id;
+	struct clk			*clks[20];
 	struct device			*comp_dev;
 	enum mdp_comp_type		type;
 	enum mdp_comp_id		id;
@@ -141,17 +245,27 @@ struct mdp_comp_ops {
 	int (*post_process)(struct mdp_comp_ctx *ctx, struct mdp_cmd *cmd);
 };
 
+struct hyfbcPatchStruct {
+    bool is10b;
+    u32 width_in_mb;
+    u32 height_in_mb;
+    u32 w_stride_in_mb;
+    u32 h_stride_in_mb;
+    u32 byte_per_mb;
+    u32 pa_base;
+};
+
 struct mdp_dev;
 
 int mdp_component_init(struct mdp_dev *mdp);
 void mdp_component_deinit(struct mdp_dev *mdp);
 void mdp_comp_clock_on(struct device *dev, struct mdp_comp *comp);
 void mdp_comp_clock_off(struct device *dev, struct mdp_comp *comp);
-void mdp_comp_clocks_on(struct device *dev, struct mdp_comp *comps, int num);
-void mdp_comp_clocks_off(struct device *dev, struct mdp_comp *comps, int num);
 int mdp_comp_ctx_init(struct mdp_dev *mdp, struct mdp_comp_ctx *ctx,
-		      const struct img_compparam *param,
-	const struct img_ipi_frameparam *frame);
+							const struct img_compparam *param,
+							const struct img_ipi_frameparam *frame);
+int mdp_hyfbc_patch(struct mdp_dev *mdp, struct mdp_cmd *cmd,
+					struct hyfbcPatchStruct *hyfbc, enum mdp_comp_id wrot);
 
 #endif  /* __MTK_MDP3_COMP_H__ */
 
diff --git a/drivers/media/platform/mtk-mdp3/mtk-mdp3-core.c b/drivers/media/platform/mtk-mdp3/mtk-mdp3-core.c
index 7f0a6be3a3a21543f480f7845e1366f7d522b613..74fb63309c07e3b957287efb843a196a195f73ab 100644
--- a/drivers/media/platform/mtk-mdp3/mtk-mdp3-core.c
+++ b/drivers/media/platform/mtk-mdp3/mtk-mdp3-core.c
@@ -9,20 +9,21 @@
 #include <linux/of_platform.h>
 #include <linux/platform_device.h>
 #include <linux/pm_runtime.h>
+#include <linux/pm_domain.h>
 #include <linux/remoteproc.h>
 #include <linux/remoteproc/mtk_scp.h>
 #include <media/videobuf2-dma-contig.h>
 #include "mtk-mdp3-core.h"
-#include "mtk-mdp3-m2m.h"
 #include "mtk-mdp3-debug.h"
+#include "mtk-mdp3-m2m.h"
 
 /* MDP debug log level (0-3). 3 shows all the logs. */
 int mtk_mdp_debug;
 EXPORT_SYMBOL(mtk_mdp_debug);
 module_param_named(debug, mtk_mdp_debug, int, 0644);
 
-static const struct of_device_id mdp_of_ids[] = {
-	{ .compatible = "mediatek,mt8183-mdp3", },
+static struct of_device_id mdp_of_ids[] = {
+	{ .compatible = "mediatek,mt8195-mdp3", },
 	{},
 };
 MODULE_DEVICE_TABLE(of, mdp_of_ids);
@@ -94,21 +95,40 @@ void mdp_vpu_put_locked(struct mdp_dev *mdp)
 
 static int mdp_probe(struct platform_device *pdev)
 {
+	//struct device *devs[3];
 	struct device *dev = &pdev->dev;
 	struct mdp_dev *mdp;
-	int ret;
+	int ret = 0, i, id = 0;
 
 	mdp = devm_kzalloc(dev, sizeof(*mdp), GFP_KERNEL);
 	if (!mdp)
 		return -ENOMEM;
 
 	mdp->pdev = pdev;
+
+	ret = of_property_read_u32(dev->of_node, "mediatek,mdp-id", &id);
+	if (ret) {
+		dev_err(dev, "Failed to get mdp-id\n");
+		goto err_return;
+	}
+
+	if (id == MDP_RDMA1_NODE) {
+		platform_set_drvdata(pdev, mdp);
+		goto err_return;
+	}
+
 	ret = mdp_component_init(mdp);
 	if (ret) {
 		dev_err(dev, "Failed to initialize mdp components\n");
 		goto err_return;
 	}
 
+	mdp->pwr_domain_num = of_count_phandle_with_args(dev->of_node,
+						"power-domains","#power-domain-cells");
+	for (i = 0; i < mdp->pwr_domain_num; i++) {
+		mdp->pwr_devs[i] = dev_pm_domain_attach_by_id(&mdp->pdev->dev, i);
+	}
+
 	mdp->job_wq = alloc_workqueue(MDP_MODULE_NAME, WQ_FREEZABLE, 0);
 	if (!mdp->job_wq) {
 		dev_err(dev, "Unable to create job workqueue\n");
@@ -143,9 +163,16 @@ static int mdp_probe(struct platform_device *pdev)
 		goto err_put_scp;
 	}
 
+	mdp->cmdq_s_clt = cmdq_mbox_create(dev, 1);
+	if (IS_ERR(mdp->cmdq_s_clt)) {
+		ret = PTR_ERR(mdp->cmdq_s_clt);
+		goto err_mbox_destroy;
+	}
+
 	init_waitqueue_head(&mdp->callback_wq);
 	ida_init(&mdp->mdp_ida);
 	platform_set_drvdata(pdev, mdp);
+
 #ifdef MDP_DEBUG
 	mdp_debug_init(pdev);
 #endif
@@ -156,7 +183,7 @@ static int mdp_probe(struct platform_device *pdev)
 	if (ret) {
 		dev_err(dev, "Failed to register v4l2 device\n");
 		ret = -EINVAL;
-		goto err_mbox_destroy;
+		goto err_dual_mbox_destroy;
 	}
 
 	ret = mdp_m2m_device_register(mdp);
@@ -170,6 +197,8 @@ static int mdp_probe(struct platform_device *pdev)
 
 err_unregister_device:
 	v4l2_device_unregister(&mdp->v4l2_dev);
+err_dual_mbox_destroy:
+	cmdq_mbox_destroy(mdp->cmdq_s_clt);
 err_mbox_destroy:
 	cmdq_mbox_destroy(mdp->cmdq_clt);
 err_put_scp:
@@ -247,17 +276,16 @@ static const struct dev_pm_ops mdp_pm_ops = {
 	SET_SYSTEM_SLEEP_PM_OPS(mdp_suspend, mdp_resume)
 };
 
-static struct platform_driver mdp_driver = {
+static struct platform_driver mdp_driver3 = {
 	.probe		= mdp_probe,
 	.remove		= mdp_remove,
 	.driver = {
 		.name	= MDP_MODULE_NAME,
 		.pm	= &mdp_pm_ops,
-		.of_match_table = of_match_ptr(mdp_of_ids),
+		.of_match_table = mdp_of_ids,
 	},
 };
-
-module_platform_driver(mdp_driver);
+module_platform_driver(mdp_driver3);
 
 MODULE_AUTHOR("Ping-Hsun Wu <ping-hsun.wu@mediatek.com>");
 MODULE_DESCRIPTION("Mediatek image processor 3 driver");
diff --git a/drivers/media/platform/mtk-mdp3/mtk-mdp3-core.h b/drivers/media/platform/mtk-mdp3/mtk-mdp3-core.h
index 19f46da487aa8c8d1901bd133d5382ad7becc2c2..9cfa40a0da64c8394137b2abb5267b41c2a68178 100644
--- a/drivers/media/platform/mtk-mdp3/mtk-mdp3-core.h
+++ b/drivers/media/platform/mtk-mdp3/mtk-mdp3-core.h
@@ -7,12 +7,19 @@
 #ifndef __MTK_MDP3_CORE_H__
 #define __MTK_MDP3_CORE_H__
 
+#include <linux/videodev2.h>
+#include <media/v4l2-ctrls.h>
 #include <media/v4l2-device.h>
 #include <media/v4l2-mem2mem.h>
+#include <media/videobuf2-core.h>
+#include <media/videobuf2-dma-contig.h>
+
 #include "mtk-mdp3-comp.h"
 #include "mtk-mdp3-vpu.h"
 
 #define MDP_MODULE_NAME	"mtk-mdp3"
+#define MDP_RDMA1_NODE		(1)
+#define MDP_PWR_DOMAIN_MAX	(2)
 
 enum mdp_buffer_usage {
 	MDP_BUFFER_USAGE_HW_READ,
@@ -22,6 +29,13 @@ enum mdp_buffer_usage {
 	MDP_BUFFER_USAGE_WPE,
 };
 
+enum MUTEX_SRC_ENUM
+{
+    SRC_SINGLE_TRIGGER = 0,
+    SRC_HDMI_VSYNC_SPLIT = 7,
+    SRC_HDMI_DELAYED_VSYNC_SPLIT = 9,
+};
+
 struct mdp_dev {
 	struct platform_device	*pdev;
 	struct mdp_comp		mmsys;
@@ -49,6 +63,12 @@ struct mdp_dev {
 	struct mutex		m2m_lock;
 	atomic_t		suspended;
 	atomic_t		job_count;
+	struct mdp_comp		vppsys;
+	struct mdp_comp		vpp_mutex;
+	struct device		*pwr_devs[MDP_PWR_DOMAIN_MAX];
+	u32         pwr_domain_num;
+	struct cmdq_client	*cmdq_s_clt;
+	atomic_t		cmdq_count;
 };
 
 int mdp_vpu_get_locked(struct mdp_dev *mdp);
@@ -64,12 +84,12 @@ extern int mtk_mdp_debug;
 #define mdp_dbg(level, fmt, ...)\
 	do {\
 		if (mtk_mdp_debug >= (level))\
-			pr_info("[MTK-MDP3] %d %s:%d: " fmt,\
+			pr_info("[MTK-MDP3] %d %s:%d: " fmt "\n",\
 				level, __func__, __LINE__, ##__VA_ARGS__);\
 	} while (0)
 
 #define mdp_err(fmt, ...)\
-	pr_err("[MTK-MDP3][ERR] %s:%d: " fmt, __func__, __LINE__,\
+	pr_err("[MTK-MDP3][ERR] %s:%d: " fmt "\n", __func__, __LINE__,\
 		##__VA_ARGS__)
 
 #else
diff --git a/drivers/media/platform/mtk-mdp3/mtk-mdp3-debug.c b/drivers/media/platform/mtk-mdp3/mtk-mdp3-debug.c
index fb2c727ee286d813e865b3b76eb75b783302b22f..ef515d83d684e029815e3b1c5f1ebefe33327dab 100644
--- a/drivers/media/platform/mtk-mdp3/mtk-mdp3-debug.c
+++ b/drivers/media/platform/mtk-mdp3/mtk-mdp3-debug.c
@@ -24,15 +24,22 @@
 
 struct mdp_module_base_va {
 	void __iomem *MDP_RDMA0;
+	void __iomem *MDP_RDMA1;
+	void __iomem *MDP_RDMA2;
+	void __iomem *MDP_RDMA3;
+	void __iomem *MDP_AAL0;
+	void __iomem *MDP_AAL1;
+	void __iomem *MDP_HDR0;
+	void __iomem *MDP_HDR1;
 	void __iomem *MDP_RSZ0;
 	void __iomem *MDP_RSZ1;
-	void __iomem *MDP_TDSHP;
-	void __iomem *MDP_COLOR;
-	void __iomem *MDP_AAL;
-	void __iomem *MDP_CCORR;
 	void __iomem *MDP_WROT0;
-	void __iomem *MDP_WDMA;
-	void __iomem *SMI_LARB0;
+	void __iomem *MDP_WROT1;
+	void __iomem *MDP_TDSHP0;
+	void __iomem *MDP_TDSHP1;
+	void __iomem *MDP_COLOR0;
+	void __iomem *MDP_COLOR1;
+	void __iomem *SMI_LARB2;
 };
 
 struct RegDef {
@@ -51,14 +58,19 @@ static struct mdp_debug_context g_mdp_debug;
 
 #define MMSYS_CONFIG_BASE	g_mdp_debug.mdp_mmsys_base_va
 #define MDP_RDMA0_BASE		g_mdp_debug.mdp_mod_base_va.MDP_RDMA0
+#define MDP_RDMA1_BASE		g_mdp_debug.mdp_mod_base_va.MDP_RDMA1
+#define MDP_AAL0_BASE		g_mdp_debug.mdp_mod_base_va.MDP_AAL0
+#define MDP_AAL1_BASE		g_mdp_debug.mdp_mod_base_va.MDP_AAL1
+#define MDP_HDR0_BASE		g_mdp_debug.mdp_mod_base_va.MDP_HDR0
+#define MDP_HDR1_BASE		g_mdp_debug.mdp_mod_base_va.MDP_HDR1
 #define MDP_RSZ0_BASE		g_mdp_debug.mdp_mod_base_va.MDP_RSZ0
 #define MDP_RSZ1_BASE		g_mdp_debug.mdp_mod_base_va.MDP_RSZ1
-#define MDP_TDSHP_BASE		g_mdp_debug.mdp_mod_base_va.MDP_TDSHP
-#define MDP_COLOR_BASE		g_mdp_debug.mdp_mod_base_va.MDP_COLOR
-#define MDP_AAL_BASE		g_mdp_debug.mdp_mod_base_va.MDP_AAL
-#define MDP_CCORR_BASE		g_mdp_debug.mdp_mod_base_va.MDP_CCORR
 #define MDP_WROT0_BASE		g_mdp_debug.mdp_mod_base_va.MDP_WROT0
-#define MDP_WDMA_BASE		g_mdp_debug.mdp_mod_base_va.MDP_WDMA
+#define MDP_WROT1_BASE		g_mdp_debug.mdp_mod_base_va.MDP_WROT1
+#define MDP_TDSHP0_BASE		g_mdp_debug.mdp_mod_base_va.MDP_TDSHP0
+#define MDP_TDSHP1_BASE		g_mdp_debug.mdp_mod_base_va.MDP_TDSHP1
+#define MDP_COLOR0_BASE		g_mdp_debug.mdp_mod_base_va.MDP_COLOR0
+#define MDP_COLOR1_BASE		g_mdp_debug.mdp_mod_base_va.MDP_COLOR1
 
 #define MDP_REG_GET32(addr)	(readl((void *)addr) & 0xffffffff)
 #define MDP_REG_SET32(addr, val)	writel(val, addr)
@@ -108,32 +120,39 @@ static void mdp_init_module_base_VA(void)
 	} else
 		mdp_err("%s:MDP_RDMA node missing!\n", __func__);
 
-	mod_base_va->MDP_RSZ0 = mdp_alloc_reference_VA_by_name("mdp3-rsz0");
-	mod_base_va->MDP_RSZ1 = mdp_alloc_reference_VA_by_name("mdp3-rsz1");
-	mod_base_va->MDP_WROT0 = mdp_alloc_reference_VA_by_name("mdp3-wrot0");
-	mod_base_va->MDP_WDMA = mdp_alloc_reference_VA_by_name("mdp3-wdma0");
-	mod_base_va->MDP_TDSHP = mdp_alloc_reference_VA_by_name("mdp3-tdshp0");
-	mod_base_va->MDP_COLOR = mdp_alloc_reference_VA_by_name("mdp3-color0");
-	mod_base_va->MDP_AAL = mdp_alloc_reference_VA_by_name("mdp3-aal0");
-	mod_base_va->MDP_CCORR = mdp_alloc_reference_VA_by_name("mdp3-ccorr0");
-	mod_base_va->SMI_LARB0 =
-		mdp_alloc_reference_VA_by_name("mediatek,larb");
+    mod_base_va->MDP_RDMA1 = mdp_alloc_reference_VA_by_name("mdp_rdma1");
+	mod_base_va->MDP_AAL0 = mdp_alloc_reference_VA_by_name("mdp_aal0");
+	mod_base_va->MDP_AAL1 = mdp_alloc_reference_VA_by_name("mdp_aal1");
+	mod_base_va->MDP_HDR0 = mdp_alloc_reference_VA_by_name("mdp_hdr0");
+	mod_base_va->MDP_HDR1 = mdp_alloc_reference_VA_by_name("mdp_hdr1");
+	mod_base_va->MDP_RSZ0 = mdp_alloc_reference_VA_by_name("mdp_rsz0");
+	mod_base_va->MDP_RSZ1 = mdp_alloc_reference_VA_by_name("mdp_rsz1");
+	mod_base_va->MDP_WROT0 = mdp_alloc_reference_VA_by_name("mdp_wrot0");
+	mod_base_va->MDP_WROT1 = mdp_alloc_reference_VA_by_name("mdp_wrot1");
+	mod_base_va->MDP_TDSHP0 = mdp_alloc_reference_VA_by_name("mdp_tdshp0");
+	mod_base_va->MDP_TDSHP1 = mdp_alloc_reference_VA_by_name("mdp_tdshp1");
+	mod_base_va->MDP_COLOR0 = mdp_alloc_reference_VA_by_name("mdp_color0");
+	mod_base_va->MDP_COLOR1 = mdp_alloc_reference_VA_by_name("mdp_color1");
 }
 
 static void mdp_deinit_module_base_VA(void)
 {
 	struct mdp_module_base_va *mod_base_va = &(g_mdp_debug.mdp_mod_base_va);
 
-	mdp_free_module_base_VA(mod_base_va->MDP_RDMA0);
-	mdp_free_module_base_VA(mod_base_va->MDP_RSZ0);
-	mdp_free_module_base_VA(mod_base_va->MDP_RSZ1);
-	mdp_free_module_base_VA(mod_base_va->MDP_WROT0);
-	mdp_free_module_base_VA(mod_base_va->MDP_WDMA);
-	mdp_free_module_base_VA(mod_base_va->MDP_TDSHP);
-	mdp_free_module_base_VA(mod_base_va->MDP_COLOR);
-	mdp_free_module_base_VA(mod_base_va->MDP_AAL);
-	mdp_free_module_base_VA(mod_base_va->MDP_CCORR);
-	mdp_free_module_base_VA(mod_base_va->SMI_LARB0);
+	mdp_free_module_base_VA(mod_base_va->MDP_RDMA1);
+    mdp_free_module_base_VA(mod_base_va->MDP_AAL0);
+    mdp_free_module_base_VA(mod_base_va->MDP_AAL1);
+    mdp_free_module_base_VA(mod_base_va->MDP_HDR0);
+    mdp_free_module_base_VA(mod_base_va->MDP_HDR1);
+    mdp_free_module_base_VA(mod_base_va->MDP_RSZ0);
+    mdp_free_module_base_VA(mod_base_va->MDP_RSZ1);
+    mdp_free_module_base_VA(mod_base_va->MDP_WROT0);
+    mdp_free_module_base_VA(mod_base_va->MDP_WROT1);
+    mdp_free_module_base_VA(mod_base_va->MDP_TDSHP0);
+    mdp_free_module_base_VA(mod_base_va->MDP_TDSHP1);
+    mdp_free_module_base_VA(mod_base_va->MDP_COLOR0);
+    mdp_free_module_base_VA(mod_base_va->MDP_COLOR1);
+    mdp_free_module_base_VA(mod_base_va->SMI_LARB2);
 	memset(mod_base_va, 0, sizeof(struct mdp_module_base_va));
 }
 
@@ -270,77 +289,208 @@ static void mdp_dump_mmsys_config(void)
 	int i;
 	uint32_t value;
 	static const struct RegDef configRegisters[] = {
-		{0xF80, "ISP_MOUT_EN"},
-		{0xF84, "MDP_RDMA0_MOUT_EN"},
-		{0xF8C, "MDP_PRZ0_MOUT_EN"},
-		{0xF90, "MDP_PRZ1_MOUT_EN"},
-		{0xF94, "MDP_COLOR_MOUT_EN"},
-		{0xF98, "IPU_MOUT_EN"},
-		{0xFE8, "MDP_AAL_MOUT_EN"},
-		/* {0x02C, "MDP_TDSHP_MOUT_EN"}, */
-		{0xF00, "DISP_OVL0_MOUT_EN"},
-		{0xF04, "DISP_OVL0_2L_MOUT_EN"},
-		{0xF08, "DISP_OVL1_2L_MOUT_EN"},
-		{0xF0C, "DISP_DITHER0_MOUT_EN"},
-		{0xF10, "DISP_RSZ_MOUT_EN"},
-		/* {0x040, "DISP_UFOE_MOUT_EN"}, */
-		/* {0x040, "MMSYS_MOUT_RST"}, */
-		{0xFA0, "DISP_TO_WROT_SOUT_SEL"},
-		{0xFA4, "MDP_COLOR_IN_SOUT_SEL"},
-		{0xFA8, "MDP_PATH0_SOUT_SEL"},
-		{0xFAC, "MDP_PATH1_SOUT_SEL"},
-		{0xFB0, "MDP_TDSHP_SOUT_SEL"},
-		{0xFC0, "MDP_PRZ0_SEL_IN"},
-		{0xFC4, "MDP_PRZ1_SEL_IN"},
-		{0xFC8, "MDP_TDSHP_SEL_IN"},
-		{0xFCC, "DISP_WDMA0_SEL_IN"},
-		{0xFDC, "MDP_COLOR_SEL_IN"},
-		{0xF20, "DISP_COLOR_OUT_SEL_IN"},
-		{0xFD0, "MDP_WROT0_SEL_IN"},
-		{0xFD4, "MDP_WDMA_SEL_IN"},
-		{0xFD8, "MDP_COLOR_OUT_SEL_IN"},
-		{0xFDC, "MDP_COLOR_SEL_IN "},
-		/* {0xFDC, "DISP_COLOR_SEL_IN"}, */
-		{0xFE0, "MDP_PATH0_SEL_IN"},
-		{0xFE4, "MDP_PATH1_SEL_IN"},
-		{0xFEC, "MDP_AAL_SEL_IN"},
-		{0xFF0, "MDP_CCORR_SEL_IN"},
-		{0xFF4, "MDP_CCORR_SOUT_SEL"},
-		/* {0x070, "DISP_WDMA1_SEL_IN"}, */
-		/* {0x074, "DISP_UFOE_SEL_IN"}, */
-		{0xF2C, "DSI0_SEL_IN"},
-		{0xF30, "DSI1_SEL_IN"},
-		{0xF50, "DISP_RDMA0_SOUT_SEL_IN"},
-		{0xF54, "DISP_RDMA1_SOUT_SEL_IN"},
-		{0x0F0, "MMSYS_MISC"},
-		/* ACK and REQ related */
-		{0x8B4, "DISP_DL_VALID_0"},
-		{0x8B8, "DISP_DL_VALID_1"},
-		{0x8C0, "DISP_DL_READY_0"},
-		{0x8C4, "DISP_DL_READY_1"},
-		{0x8CC, "MDP_DL_VALID_0"},
-		{0x8D0, "MDP_DL_VALID_1"},
-		{0x8D4, "MDP_DL_READY_0"},
-		{0x8D8, "MDP_DL_READY_1"},
-		{0x8E8, "MDP_MOUT_MASK"},
-		{0x948, "MDP_DL_VALID_2"},
-		{0x94C, "MDP_DL_READY_2"},
-		{0x950, "DISP_DL_VALID_2"},
-		{0x954, "DISP_DL_READY_2"},
-		{0x100, "MMSYS_CG_CON0"},
-		{0x110, "MMSYS_CG_CON1"},
-		/* Async DL related */
-		{0x960, "TOP_RELAY_FSM_RD"},
-		{0x934, "MDP_ASYNC_CFG_WD"},
-		{0x938, "MDP_ASYNC_CFG_RD"},
-		{0x958, "MDP_ASYNC_CFG_OUT_RD"},
-		{0x95C, "MDP_ASYNC_IPU_CFG_OUT_RD"},
-		{0x994, "ISP_RELAY_CFG_WD"},
-		{0x998, "ISP_RELAY_CNT_RD"},
-		{0x99C, "ISP_RELAY_CNT_LATCH_RD"},
-		{0x9A0, "IPU_RELAY_CFG_WD"},
-		{0x9A4, "IPU_RELAY_CNT_RD"},
-		{0x9A8, "IPU_RELAY_CNT_LATCH_RD"}
+		{0x000, "MMSYS_INTEN"},
+        {0x004, "MMSYS_INTSTA"},
+        {0x0F0, "MMSYS_MISC"},
+        {0x0F4, "MMSYS_MODULE_DBG"},
+        {0x0F8, "MMSYS_EMI_REQ_CTL"},
+        {0x0FC, "MMSYS_RPT"},
+        {0x100, "MMSYS_CG_CON0"},
+        {0x104, "MMSYS_CG_SET0"},
+        {0x108, "MMSYS_CG_CLR0"},
+        {0x110, "MMSYS_CG_CON1"},
+        {0x114, "MMSYS_CG_SET1"},
+        {0x118, "MMSYS_CG_CLR1"},
+        {0x120, "MMSYS_CG_CON2"},
+        {0x124, "MMSYS_CG_SET2"},
+        {0x128, "MMSYS_CG_CLR2"},
+        {0x130, "MMSYS_CG_CON3"},
+        {0x134, "MMSYS_CG_SET3"},
+        {0x138, "MMSYS_CG_CLR3"},
+        {0x140, "MMSYS_CG_CON4"},
+        {0x144, "MMSYS_CG_SET4"},
+        {0x148, "MMSYS_CG_CLR4"},
+        {0x150, "MMSYS_HW_DCM_1ST_DIS0"},
+        {0x154, "MMSYS_HW_DCM_1ST_DIS_SET0"},
+        {0x158, "MMSYS_HW_DCM_1ST_DIS_CLR0"},
+        {0x160, "MMSYS_HW_DCM_1ST_DIS1"},
+        {0x164, "MMSYS_HW_DCM_1ST_DIS_SET1"},
+        {0x168, "MMSYS_HW_DCM_1ST_DIS_CLR1"},
+        {0x170, "MMSYS_HW_DCM_1ST_DIS2"},
+        {0x174, "MMSYS_HW_DCM_1ST_DIS_SET2"},
+        {0x178, "MMSYS_HW_DCM_1ST_DIS_CLR2"},
+        {0x180, "MMSYS_HW_DCM_1ST_DIS3"},
+        {0x184, "MMSYS_HW_DCM_1ST_DIS_SET3"},
+        {0x188, "MMSYS_HW_DCM_1ST_DIS_CLR3"},
+        {0x190, "MMSYS_HW_DCM_1ST_DIS4"},
+        {0x194, "MMSYS_HW_DCM_1ST_DIS_SET4"},
+        {0x198, "MMSYS_HW_DCM_1ST_DIS_CLR4"},
+        {0x1a0, "MMSYS_HW_DCM_2ND_DIS0"},
+        {0x1a4, "MMSYS_HW_DCM_2ND_DIS_SET0"},
+        {0x1a8, "MMSYS_HW_DCM_2ND_DIS_CLR0"},
+        {0x1b0, "MMSYS_HW_DCM_2ND_DIS1"},
+        {0x1b4, "MMSYS_HW_DCM_2ND_DIS_SET1"},
+        {0x1b8, "MMSYS_HW_DCM_2ND_DIS_CLR1"},
+        {0x1c0, "MMSYS_HW_DCM_2ND_DIS2"},
+        {0x1c4, "MMSYS_HW_DCM_2ND_DIS_SET2"},
+        {0x1c8, "MMSYS_HW_DCM_2ND_DIS_CLR2"},
+        {0x1d0, "MMSYS_HW_DCM_2ND_DIS3"},
+        {0x1d4, "MMSYS_HW_DCM_2ND_DIS_SET3"},
+        {0x1d8, "MMSYS_HW_DCM_2ND_DIS_CLR3"},
+        {0x1e0, "MMSYS_HW_DCM_2ND_DIS4"},
+        {0x1e4, "MMSYS_HW_DCM_2ND_DIS_SET4"},
+        {0x1e8, "MMSYS_HW_DCM_2ND_DIS_CLR4"},
+        {0x700, "MMSYS_SW0_RST_B"},
+        {0x704, "MMSYS_SW1_RST_B"},
+        {0x708, "MMSYS_SW2_RST_B"},
+        {0x70c, "MMSYS_SW3_RST_B"},
+        {0x710, "MMSYS_SW4_RST_B"},
+        {0x1f0, "MMSYS_LCM_RST_B"},
+        {0x1f4, "MMSYS_PROC_TRACK_EMI_BUSY_CON"},
+        {0x200, "MDP_FAKE_ENG0_EN"},
+        {0x204, "MDP_FAKE_ENG0_RST"},
+        {0x208, "MDP_FAKE_ENG0_CON0"},
+        {0x20C, "MDP_FAKE_ENG0_CON1"},
+        {0x210, "MDP_FAKE_ENG0_RD_ADDR"},
+        {0x214, "MDP_FAKE_ENG0_WR_ADDR"},
+        {0x218, "MDP_FAKE_ENG0_STATE"},
+        {0x220, "MDP_FAKE_ENG1_EN"},
+        {0x224, "MDP_FAKE_ENG1_RST"},
+        {0x228, "MDP_FAKE_ENG1_CON0"},
+        {0x22C, "MDP_FAKE_ENG1_CON1"},
+        {0x230, "MDP_FAKE_ENG1_RD_ADDR"},
+        {0x234, "MDP_FAKE_ENG1_WR_ADDR"},
+        {0x238, "MDP_FAKE_ENG1_STATE"},
+        {0x240, "MMSYS_APMCU_GALS_ctrl"},
+        {0x300, "MMSYS_DEBUG_OUT_SEL"},
+        {0x400, "MMSYS_DUMMY0"},
+        {0x404, "MMSYS_DUMMY1"},
+        {0x408, "MMSYS_DUMMY2"},
+        {0x40C, "MMSYS_DUMMY3"},
+        {0x600, "MMSYS_MBIST_CON"},
+        {0x604, "MMSYS_MBIST_DONE0"},
+        {0x608, "MMSYS_MBIST_DONE1"},
+        {0x60C, "MMSYS_MBIST_HOLDB"},
+        {0x610, "MMSYS_MBIST_MODE0"},
+        {0x614, "MMSYS_MBIST_MODE1"},
+        {0x618, "MMSYS_MBIST_DIAG_SCANOUT0"},
+        {0x61C, "MMSYS_MBIST_DIAG_SCANOUT1"},
+        {0x620, "MMSYS_MBIST_FAIL0"},
+        {0x624, "MMSYS_MBIST_FAIL1"},
+        {0x628, "MMSYS_MBIST_FAIL2"},
+        {0x62C, "MMSYS_MBIST_FAIL3"},
+        {0x630, "MMSYS_MBIST_DEBUG"},
+        {0x638, "MMSYS_MBIST_PRE_FUSE"},
+        {0x640, "MMSYS_MBIST_BSEL0"},
+        {0x644, "MMSYS_MBIST_BSEL1"},
+        {0x660, "MMSYS_MBIST_HDEN0"},
+        {0x664, "MMSYS_MBIST_HDEN1"},
+        {0x668, "MMSYS_MBIST_HDEN2"},
+        {0x66C, "MMSYS_MBIST_HDEN3"},
+        {0x670, "MMSYS_MBIST_DREQ0"},
+        {0x674, "MMSYS_MBIST_DREQ1"},
+        {0x678, "MMSYS_MBIST_DREQ2"},
+        {0x67C, "MMSYS_MBIST_DREQ3"},
+        {0x680, "MMSYS_MBIST_DELSEL0"},
+        {0x684, "MMSYS_MBIST_DELSEL1"},
+        {0x688, "MMSYS_MBIST_DELSEL2"},
+        {0x68C, "MMSYS_MBIST_DELSEL3"},
+        {0x690, "MMSYS_MBIST_DELSEL4"},
+        {0x694, "MMSYS_MBIST_DELSEL5"},
+        {0x698, "MMSYS_MBIST_DELSEL6"},
+        {0x69C, "MMSYS_MBIST_DELSEL7"},
+        {0x6A0, "MMSYS_MBIST_DELSEL8"},
+        {0x6B0, "MMSYS_MBIST_DELSEL9"},
+        {0x6B4, "MMSYS_MBIST_DELSEL10"},
+        {0x6B8, "MMSYS_MBIST_DELSEL11"},
+        {0x6BC, "MMSYS_MBIST_DELSEL12"},
+        {0x6C0, "MMSYS_MBIST_DELSEL13"},
+        {0x6C4, "MMSYS_MBIST_DELSEL14"},
+        {0x6C8, "MMSYS_MBIST_DELSEL15"},
+        {0x720, "MMSYS_MBIST_DELSEL16"},
+        {0x724, "MMSYS_MBIST_DELSEL17"},
+        {0x728, "MMSYS_MBIST_DELSEL18"},
+        {0x72C, "MMSYS_MBIST_DELSEL19"},
+        {0x730, "MMSYS_MBIST_DELSEL20"},
+        {0x734, "MMSYS_MBIST_DELSEL21"},
+        {0x738, "MMSYS_MBIST_DELSEL22"},
+        {0x73C, "MMSYS_MBIST_DELSEL23"},
+        {0x740, "MMSYS_MBIST_DELSEL24"},
+        {0x744, "MMSYS_MBIST_DELSEL25"},
+        {0x748, "MMSYS_MBIST_DELSEL26"},
+        {0x74C, "MMSYS_MBIST_DELSEL27"},
+        {0x750, "MMSYS_MBIST_DELSEL28"},
+        {0x754, "MMSYS_MBIST_DELSEL29"},
+        {0x6D0, "MMSYS_MBIST_RP_RST_B"},
+        {0x6E0, "MMSYS_MBIST_RP_FAIL0"},
+        {0x6E4, "MMSYS_MBIST_RP_FAIL1"},
+        {0x6E8, "MMSYS_MBIST_RP_FAIL2"},
+        {0x6EC, "MMSYS_MBIST_RP_FAIL3"},
+        {0x6F0, "MMSYS_MBIST_RP_OK0"},
+        {0x6F4, "MMSYS_MBIST_RP_OK1"},
+        {0x6F8, "MMSYS_MBIST_RP_OK2"},
+        {0x6FC, "MMSYS_MBIST_RP_OK3"},
+        {0x804, "MMSYS_SMI_BIST"},
+        {0x808, "MMSYS_SMI_TX_IDLE"},
+        {0x8DC, "MMSYS_SMI_LARB_GREQ"},
+        {0x8F0, "MMSYS_HRT_WEIGHT_READ"},
+        {0x900, "MMSYS_PWR_METER_CTL0"},
+        {0x904, "MMSYS_PWR_METER_CTL1"},
+        {0x920, "MDP_DL_RELAY0_CFG_WD"},
+        {0x924, "MDP_DL_RELAY1_CFG_WD"},
+        {0x928, "MDP_DL_RELAY2_CFG_WD"},
+        {0x92c, "MDP_DL_RELAY3_CFG_WD"},
+        {0x930, "MDP_DL_RELAY0_CFG_RD"},
+        {0x934, "MDP_DL_RELAY1_CFG_RD"},
+        {0x938, "MDP_DL_RELAY2_CFG_RD"},
+        {0x93C, "MDP_DL_RELAY3_CFG_RD"},
+        {0x940, "MDP_DL_ASYNC_CFG_RD0"},
+        {0x948, "MDP_DL_ASYNC_CFG_RD1"},
+        {0x950, "MDP_DL_ASYNC1_CFG_RD0"},
+        {0x954, "MDP_DL_ASYNC1_CFG_RD1"},
+        {0x960, "MDP_DL_ASYNC2_CFG_RD0"},
+        {0x964, "MDP_DL_ASYNC2_CFG_RD1"},
+        {0x970, "MDP_DL_ASYNC3_CFG_RD0"},
+        {0x974, "MDP_DL_ASYNC3_CFG_RD1"},
+        {0xE00, "MMSYS_BUF_UNDERRUN"},
+        {0xE04, "MMSYS_BUF_UNDERRUN_ID"},
+        {0xF00, "MMSYS_MOUT_RST"},
+        {0xF10, "ISP0_MOUT_EN"},
+        {0xF14, "ISP1_MOUT_EN"},
+        {0xF20, "MDP_RDMA0_MOUT_EN"},
+        {0xF24, "MDP_RDMA1_MOUT_EN"},
+        {0xF30, "MDP_PQ0_SEL_IN"},
+        {0xF34, "MDP_PQ1_SEL_IN"},
+        {0xF70, "MDP_WROT0_SEL_IN"},
+        {0xF74, "MDP_WROT1_SEL_IN"},
+        {0xFD0, "MMSYS_MOUT_MASK0"},
+        {0xFD4, "MMSYS_MOUT_MASK1"},
+        {0xFD8, "MMSYS_MOUT_MASK2"},
+        {0xFE0, "MMSYS_DL_VALID0"},
+        {0xFE4, "MMSYS_DL_VALID1"},
+        {0xFE8, "MMSYS_DL_VALID2"},
+        {0xFF0, "MMSYS_DL_READY0"},
+        {0xFF4, "MMSYS_DL_READY1"},
+        {0xFF8, "MMSYS_DL_READY2"},
+        {0x770, "MMSYS_FUSE_0"},
+        {0x774, "MMSYS_FUSE_1"},
+        {0x778, "MMSYS_FUSE_2"},
+        {0x77C, "MMSYS_FUSE_3"},
+        {0x780, "MMSYS_FUSE_4"},
+        {0x784, "MMSYS_FUSE_5"},
+        {0x788, "MMSYS_FUSE_6"},
+        {0x78C, "MMSYS_FUSE_7"},
+        {0x790, "MMSYS_FUSE_8"},
+        {0x794, "MMSYS_FUSE_9"},
+        {0x798, "MMSYS_FUSE_10"},
+        {0x79C, "MMSYS_FUSE_11"},
+        {0x7A0, "MMSYS_FUSE_12"},
+        {0x7A4, "MMSYS_FUSE_13"},
+        {0x7A8, "MMSYS_FUSE_14"},
+        {0x7AC, "MMSYS_FUSE_15"},
+        {0x7B0, "MMSYS_FUSE_16"},
+        {0x7B4, "MMSYS_FUSE_CTRL"},
+        {0x6D4, "MMSYS_USE_DEFAULT_DELSEL"}
 	};
 
 	if (!MMSYS_CONFIG_BASE) {
@@ -397,34 +547,6 @@ static const char *mdp_get_rsz_state(const uint32_t state)
 	}
 }
 
-static const char *mdp_get_wdma_state(uint32_t state)
-{
-	switch (state) {
-	case 0x1:
-		return "idle";
-	case 0x2:
-		return "clear";
-	case 0x4:
-		return "prepare";
-	case 0x8:
-		return "prepare";
-	case 0x10:
-		return "data running";
-	case 0x20:
-		return "eof wait";
-	case 0x40:
-		return "soft reset wait";
-	case 0x80:
-		return "eof done";
-	case 0x100:
-		return "sof reset done";
-	case 0x200:
-		return "frame complete";
-	default:
-		return "";
-	}
-}
-
 static void mdp_dump_rdma_common(void __iomem *base, const char *label)
 {
 	uint32_t value[17];
@@ -680,80 +802,6 @@ static void mdp_dump_color_common(void __iomem *base, const char *label)
 	     value[11], value[12]);
 }
 
-static void mdp_dump_wdma_common(void __iomem *base, const char *label)
-{
-	uint32_t value[56];
-	uint32_t state;
-	/* grep bit = 1, WDMA has sent request to SMI,
-	 *and not receive done yet
-	 */
-	uint32_t grep;
-	uint32_t isFIFOFull;	/* 1 for WDMA FIFO full */
-	int i;
-
-	if (!base) {
-		mdp_err("=============== [MDP] %s Status ===============\n",
-			label);
-		mdp_err("%s:base=0!\n", __func__);
-		return;
-	}
-
-	value[0] = MDP_REG_GET32(base + 0x014);
-	value[1] = MDP_REG_GET32(base + 0x018);
-	value[2] = MDP_REG_GET32(base + 0x028);
-	value[3] = MDP_REG_GET32(base +
-		   mdp_get_func()->mdp_wdma_get_reg_offset_dst_addr());
-	value[4] = MDP_REG_GET32(base + 0x078);
-	value[5] = MDP_REG_GET32(base + 0x080);
-	value[6] = MDP_REG_GET32(base + 0x0A0);
-	value[7] = MDP_REG_GET32(base + 0x0A8);
-
-	for (i = 0; i < 16; i++) {
-		MDP_REG_SET32(base + 0x014, (0x10000000 * i) |
-			      (value[0] & (0x0FFFFFFF)));
-		value[8 + (3 * i)] = MDP_REG_GET32(base + 0x014);
-		value[9 + (3 * i)] = MDP_REG_GET32(base + 0x0AC);
-		value[10 + (3 * i)] = MDP_REG_GET32(base + 0x0B8);
-	}
-
-	mdp_err("=============== [MDP] %s Status ===============\n",
-		label);
-	mdp_err("[MDP]WDMA_CFG: 0x%08x, WDMA_SRC_SIZE: 0x%08x\n",
-		 value[0], value[1]);
-	mdp_err("WDMA_DST_W_IN_BYTE = 0x%08x, [MDP]WDMA_DST_ADDR0: 0x%08x\n",
-		 value[2], value[3]);
-	mdp_err
-	    ("WDMA_DST_UV_PITCH: 0x%08x, WDMA_DST_ADDR_OFFSET0 = 0x%08x\n",
-	     value[4], value[5]);
-	mdp_err("[MDP]WDMA_STATUS: 0x%08x, WDMA_INPUT_CNT: 0x%08x\n",
-		value[6], value[7]);
-
-	/* Dump Addtional WDMA debug info */
-	for (i = 0; i < 16; i++) {
-		mdp_err("WDMA_DEBUG_%x 014:0x%08x, 0ac:0x%08x, 0b8:0x%08x\n",
-			i, value[8 + (3 * i)], value[9 + (3 * i)],
-			value[10 + (3 * i)]);
-	}
-
-	/* parse WDMA state */
-	state = value[6] & 0x3FF;
-	grep = (value[6] >> 13) & 0x1;
-	isFIFOFull = (value[6] >> 12) & 0x1;
-
-	mdp_err("WDMA state:0x%x (%s)\n", state, mdp_get_wdma_state(state));
-	mdp_err("WDMA in_req:%d in_ack:%d\n", (value[6] >> 15) & 0x1,
-		(value[6] >> 14) & 0x1);
-
-	/* note WDMA send request(i.e command) to SMI first,
-	 * then SMI takes request data from WDMA FIFO
-	 */
-	/* if SMI dose not process request and upstream HWs */
-	/* such as MDP_RSZ send data to WDMA, WDMA FIFO will full finally */
-	mdp_err("WDMA grep:%d, FIFO full:%d\n", grep, isFIFOFull);
-	mdp_err("WDMA suggest: Need SMI help:%d, Need check WDMA config:%d\n",
-		(grep), ((grep == 0) && (isFIFOFull == 1)));
-}
-
 static void mdp_dump_rsz(void __iomem *base, const char *label)
 {
 	uint32_t value[11];
@@ -873,32 +921,6 @@ static void mdp_dump_aal(void __iomem *base, const char *label)
 		value[7], value[8]);
 }
 
-static void mdp_dump_ccorr(void __iomem *base, const char *label)
-{
-	uint32_t value[5];
-
-	if (!base) {
-		mdp_err("=============== [MDP] %s Status ===============\n",
-			label);
-		mdp_err("%s:base=0!\n", __func__);
-		return;
-	}
-
-	value[0] = MDP_REG_GET32(base + 0x00C);/* MDP_CCORR_INTSTA         */
-	value[1] = MDP_REG_GET32(base + 0x010);/* MDP_CCORR_STATUS         */
-	value[2] = MDP_REG_GET32(base + 0x024);/* MDP_CCORR_INPUT_COUNT    */
-	value[3] = MDP_REG_GET32(base + 0x028);/* MDP_CCORR_OUTPUT_COUNT   */
-	value[4] = MDP_REG_GET32(base + 0x030);/* MDP_CCORR_SIZE       */
-	mdp_err("=============== [MDP] %s Status ===============\n",
-		label);
-	mdp_err("CCORR_INTSTA: 0x%08x, CCORR_STATUS: 0x%08x\n",
-		value[0], value[1]);
-	mdp_err("CCORR_INPUT_COUNT: 0x%08x, CCORR_OUTPUT_COUNT: 0x%08x\n",
-		value[2], value[3]);
-	mdp_err("CCORR_SIZE: 0x%08x\n",
-		value[4]);
-}
-
 static uint32_t mdp_rdma_get_reg_offset_src_addr(void)
 {
 	return 0xF00;
@@ -933,21 +955,17 @@ int32_t mdp_dump_info(uint64_t comp_flag, int log_level)
 	if (comp_flag & (1LL << MDP_COMP_RDMA0))
 		mdp_dump_rdma_common(MDP_RDMA0_BASE, "RDMA0");
 	if (comp_flag & (1LL << MDP_COMP_AAL0))
-		mdp_dump_aal(MDP_AAL_BASE, "AAL0");
-	if (comp_flag & (1LL << MDP_COMP_CCORR0))
-		mdp_dump_ccorr(MDP_CCORR_BASE, "CCORR0");
+		mdp_dump_aal(MDP_AAL0_BASE, "AAL0");
 	if (comp_flag & (1LL << MDP_COMP_RSZ0))
 		mdp_get_func()->mdp_dump_rsz(MDP_RSZ0_BASE, "RSZ0");
 	if (comp_flag & (1LL << MDP_COMP_RSZ1))
 		mdp_get_func()->mdp_dump_rsz(MDP_RSZ1_BASE, "RSZ1");
 	if (comp_flag & (1LL << MDP_COMP_TDSHP0))
-		mdp_get_func()->mdp_dump_tdshp(MDP_TDSHP_BASE, "TDSHP");
+		mdp_get_func()->mdp_dump_tdshp(MDP_TDSHP0_BASE, "TDSHP");
 	if (comp_flag & (1LL << MDP_COMP_COLOR0))
-		mdp_dump_color_common(MDP_COLOR_BASE, "COLOR0");
+		mdp_dump_color_common(MDP_COLOR0_BASE, "COLOR0");
 	if (comp_flag & (1LL << MDP_COMP_WROT0))
 		mdp_dump_rot_common(MDP_WROT0_BASE, "WROT0");
-	if (comp_flag & (1LL << MDP_COMP_WDMA))
-		mdp_dump_wdma_common(MDP_WDMA_BASE, "WDMA");
 
 	return 0;
 }
diff --git a/drivers/media/platform/mtk-mdp3/mtk-mdp3-m2m.c b/drivers/media/platform/mtk-mdp3/mtk-mdp3-m2m.c
index 350a0707bfba54bcd440bdf62ad0dbcb0bb073fb..2751be68558c9229d05a5d7688a8b9310b284696 100644
--- a/drivers/media/platform/mtk-mdp3/mtk-mdp3-m2m.c
+++ b/drivers/media/platform/mtk-mdp3/mtk-mdp3-m2m.c
@@ -111,10 +111,12 @@ static void mdp_m2m_worker(struct work_struct *work)
 	param.type = ctx->curr_param.type;
 	param.num_inputs = 1;
 	param.num_outputs = 1;
+	param.frame_change = (ctx->frame_count == 0)? true : false;
 
 	frame = ctx_get_frame(ctx, V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE);
 	src_vb = v4l2_m2m_next_src_buf(ctx->m2m_ctx);
 	mdp_set_src_config(&param.inputs[0], frame, &src_vb->vb2_buf);
+	mdp_set_scenario(&param, frame);
 
 	frame = ctx_get_frame(ctx, V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE);
 	dst_vb = v4l2_m2m_next_dst_buf(ctx->m2m_ctx);
@@ -133,6 +135,7 @@ static void mdp_m2m_worker(struct work_struct *work)
 	task.config = ctx->vpu.config;
 	task.param = &param;
 	task.composes[0] = &frame->compose;
+	task.wait = 0;
 	task.cmdq_cb = NULL;
 	task.cb_data = NULL;
 	task.mdp_ctx = ctx;
@@ -160,6 +163,11 @@ static void mdp_m2m_device_run(void *priv)
 static int mdp_m2m_start_streaming(struct vb2_queue *q, unsigned int count)
 {
 	struct mdp_m2m_ctx *ctx = vb2_get_drv_priv(q);
+	int ret;
+
+	ret = 0;//pm_runtime_get_sync(&ctx->mdp_dev->pdev->dev);
+	if (ret < 0)
+		mdp_dbg(1, "[%d] pm_runtime_get_sync failed:%d", ctx->id, ret);
 
 	ctx->frame_count = 0;
 
@@ -187,6 +195,8 @@ static void mdp_m2m_stop_streaming(struct vb2_queue *q)
 		v4l2_m2m_buf_done(vb, VB2_BUF_STATE_ERROR);
 		vb = mdp_m2m_buf_remove(ctx, q->type);
 	}
+
+	//pm_runtime_put(&ctx->mdp_dev->pdev->dev);
 }
 
 static int mdp_m2m_queue_setup(struct vb2_queue *q,
@@ -275,7 +285,7 @@ static int mdp_m2m_querycap(struct file *file, void *fh,
 
 	strlcpy(cap->driver, MDP_MODULE_NAME, sizeof(cap->driver));
 	strlcpy(cap->card, ctx->mdp_dev->pdev->name, sizeof(cap->card));
-	strlcpy(cap->bus_info, "platform:mtk-mdp3", sizeof(cap->bus_info));
+	strlcpy(cap->bus_info, "platform:mt8183", sizeof(cap->bus_info));
 	cap->capabilities = V4L2_CAP_VIDEO_M2M_MPLANE | V4L2_CAP_STREAMING |
 			V4L2_CAP_DEVICE_CAPS; /* | V4L2_CAP_META_OUTPUT */
 	cap->device_caps = V4L2_CAP_VIDEO_M2M_MPLANE | V4L2_CAP_STREAMING;
@@ -318,8 +328,6 @@ static int mdp_m2m_s_fmt_mplane(struct file *file, void *fh,
 	const struct mdp_format *fmt;
 	struct vb2_queue *vq;
 
-	mdp_dbg(2, "[%d] type:%d", ctx->id, f->type);
-
 	fmt = mdp_try_fmt_mplane(f, &ctx->curr_param, ctx->id);
 	if (!fmt) {
 		mdp_err("[%d] try_fmt failed, type:%d", ctx->id, f->type);
@@ -338,7 +346,7 @@ static int mdp_m2m_s_fmt_mplane(struct file *file, void *fh,
 	frame->usage = V4L2_TYPE_IS_OUTPUT(f->type) ?
 		MDP_BUFFER_USAGE_HW_READ : MDP_BUFFER_USAGE_MDP;
 
-	capture = ctx_get_frame(ctx, V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE);
+	capture = ctx_get_frame(ctx, f->type);
 	if (V4L2_TYPE_IS_OUTPUT(f->type)) {
 		capture->crop.c.left = 0;
 		capture->crop.c.top = 0;
@@ -348,6 +356,9 @@ static int mdp_m2m_s_fmt_mplane(struct file *file, void *fh,
 		ctx->curr_param.ycbcr_enc = f->fmt.pix_mp.ycbcr_enc;
 		ctx->curr_param.quant = f->fmt.pix_mp.quantization;
 		ctx->curr_param.xfer_func = f->fmt.pix_mp.xfer_func;
+
+		capture->stride.width = ((f->fmt.pix_mp.width + 63) >> 6) << 6;
+		capture->stride.height = ((f->fmt.pix_mp.height + 31) >> 5) << 5;
 	} else {
 		capture->compose.left = 0;
 		capture->compose.top = 0;
@@ -359,6 +370,7 @@ static int mdp_m2m_s_fmt_mplane(struct file *file, void *fh,
 
 	mdp_dbg(2, "[%d] type:%d, frame:%ux%u", ctx->id, f->type,
 		f->fmt.pix_mp.width, f->fmt.pix_mp.height);
+
 	return 0;
 }
 
@@ -413,7 +425,7 @@ static int mdp_m2m_streamon(struct file *file, void *fh,
 			return ret;
 
 		ret = mdp_vpu_ctx_init(&ctx->vpu, &ctx->mdp_dev->vpu,
-				       MDP_DEV_M2M);
+				       MDP_DEV_M2M_2ND);
 		if (ret) {
 			dev_err(&ctx->mdp_dev->pdev->dev,
 				"VPU init failed %d\n", ret);
diff --git a/drivers/media/platform/mtk-mdp3/mtk-mdp3-regs.c b/drivers/media/platform/mtk-mdp3/mtk-mdp3-regs.c
index 333f5117088bb9a0ca9e9259a46778f4c55dab9d..f62b86cb3071b3fda49d104c78044f17db576a2f 100644
--- a/drivers/media/platform/mtk-mdp3/mtk-mdp3-regs.c
+++ b/drivers/media/platform/mtk-mdp3/mtk-mdp3-regs.c
@@ -10,6 +10,17 @@
 #include "mtk-mdp3-core.h"
 #include "mtk-mdp3-regs.h"
 
+#define BYTE_PER_MB_Y				(4)
+#define BYTE_PER_MB_C				(2)
+#define DMA_HYFBC_HWPATCH_DUMP			(0)
+
+#define CEIL(a, b) ((a%b==0)? (a/b): (a/b+1))
+#define ALIGN_UP(val, a)						\
+({												\
+	typeof(val) _a = (a);						\
+	(_a==0)? val : ((val+(_a-1))/(_a)*(_a));	\
+})
+
 static const struct mdp_format mdp_formats[] = {
 	{
 		.pixelformat	= V4L2_PIX_FMT_GREY,
@@ -160,16 +171,16 @@ static const struct mdp_format mdp_formats[] = {
 		.flags		= MDP_FMT_FLAG_OUTPUT,
 	}, {
 		.pixelformat	= V4L2_PIX_FMT_MT21C,
-		.mdp_color	= MDP_COLOR_420_BLK_UFO,
+		.mdp_color	= MDP_COLOR_NV12_HYFBC,
 		.depth		= { 8, 4 },
 		.row_depth	= { 8, 8 },
-		.num_planes	= 2,
+		.num_planes	= 1,
 		.walign		= 4,
-		.halign		= 5,
+		.halign		= 4,
 		.flags		= MDP_FMT_FLAG_OUTPUT,
 	}, {
 		.pixelformat	= V4L2_PIX_FMT_MM21,
-		.mdp_color	= MDP_COLOR_420_BLK,
+		.mdp_color	= MDP_COLOR_420_BLKP,
 		.depth		= { 8, 4 },
 		.row_depth	= { 8, 8 },
 		.num_planes	= 2,
@@ -368,6 +379,49 @@ int mdp_enum_fmt_mplane(struct v4l2_fmtdesc *f)
 	return 0;
 }
 
+static u32 mdp_fmt_get_hyfbc_plane_size(u32 width, u32 height, u32 color)
+{
+	u32 yDataSize = 0;
+	u32 cDataSize = 0;
+	u32 yHeaderSize = 0;
+	u32 cHeaderSize = 0;
+	u32 yDataOfst = 0;
+	u32 yHdrOfst = 0;
+	u32 cDataOfst = 0;
+	u32 cHdrOfst = 0;
+
+	yDataSize = (((width + 63) >> 6) << 6) * (((height + 63) >> 6) << 6);
+	yHeaderSize = yDataSize >> 6;
+	if (MDP_COLOR_IS_10BIT_PACKED(color))
+	{
+		yDataSize = (yDataSize * 6) >> 2;
+	}
+	cDataSize = yDataSize >> 1;
+	cHeaderSize = (((yHeaderSize >> 1) + 63) >> 6) << 6;
+
+	// Setup source buffer base
+	yDataOfst = ((yHeaderSize + 4095) >> 12) << 12; // align 4k
+	yHdrOfst = yDataOfst - yHeaderSize;
+	cDataOfst = ((yDataOfst + yDataSize + cHeaderSize + 4095) >> 12) << 12; // align 4k
+	cHdrOfst = cDataOfst - cHeaderSize;
+
+	return (cDataOfst + cDataSize);
+}
+
+static u32 mdp_fmt_get_afbc_plane_size(u32 width, u32 height, u32 color)
+{
+	u32 align_w = ((width + 31) >> 5) << 5;
+	u32 align_h = ((height + 31) >> 5) << 5;
+	if(MDP_COLOR_IS_10BIT_PACKED(color))
+	{
+		return ((align_w >> 4) * (align_h >> 4) * (16+512));
+	}
+	else
+	{
+		return ((align_w >> 4) * (align_h >> 4) * (16+384));
+	}
+}
+
 const struct mdp_format *mdp_try_fmt_mplane(struct v4l2_format *f,
 					    struct mdp_frameparam *param,
 					    u32 ctx_id)
@@ -377,6 +431,8 @@ const struct mdp_format *mdp_try_fmt_mplane(struct v4l2_format *f,
 	const struct mdp_pix_limit *pix_limit;
 	u32 wmin, wmax, hmin, hmax, org_w, org_h;
 	unsigned int i;
+	u32 ysize;
+	u32 exsize;
 
 	if (!V4L2_TYPE_IS_MULTIPLANAR(f->type))
 		return NULL;
@@ -423,6 +479,7 @@ const struct mdp_format *mdp_try_fmt_mplane(struct v4l2_format *f,
 	if (pix_mp->num_planes && pix_mp->num_planes != fmt->num_planes)
 		mdp_dbg(1, "[%d] num of planes change: %u to %u", ctx_id,
 			pix_mp->num_planes, fmt->num_planes);
+
 	pix_mp->num_planes = fmt->num_planes;
 
 	for (i = 0; i < pix_mp->num_planes; ++i) {
@@ -434,6 +491,32 @@ const struct mdp_format *mdp_try_fmt_mplane(struct v4l2_format *f,
 			bpl = min_bpl;
 		si = (bpl * pix_mp->height * fmt->depth[i]) / fmt->row_depth[i];
 
+		if(MDP_COLOR_IS_HYFBC_COMPRESS(fmt->mdp_color))
+		{
+			si = mdp_fmt_get_hyfbc_plane_size(pix_mp->width,
+				pix_mp->height,fmt->mdp_color);
+		}
+		else if(MDP_COLOR_IS_COMPRESS(fmt->mdp_color))
+		{
+			si = mdp_fmt_get_afbc_plane_size(pix_mp->width,
+				pix_mp->height,fmt->mdp_color);
+		}
+		else if(MDP_COLOR_IS_UFP(fmt->mdp_color))
+		{
+			if(i == 0)
+				ysize = si;
+
+			exsize = (((ysize + 255) >> 8) + 128);
+			exsize = ((exsize + 63) >> 6) << 6;
+
+			if(i == 1)
+			{
+				exsize = exsize / 2 + 128;
+				exsize = ((exsize + 15) >> 4) << 4;
+			}
+			si += exsize;
+		}
+
 		pix_mp->plane_fmt[i].bytesperline = bpl;
 		if (pix_mp->plane_fmt[i].sizeimage < si)
 			pix_mp->plane_fmt[i].sizeimage = si;
@@ -445,7 +528,6 @@ const struct mdp_format *mdp_try_fmt_mplane(struct v4l2_format *f,
 
 	return fmt;
 }
-
 static int mdp_clamp_start(s32 *x, int min, int max, unsigned int align,
 			   u32 flags)
 {
@@ -548,8 +630,16 @@ static u32 mdp_fmt_get_stride(const struct mdp_format *fmt,
 	enum mdp_color c = fmt->mdp_color;
 	u32 stride;
 
-	stride = (bytesperline * MDP_COLOR_BITS_PER_PIXEL(c))
-		/ fmt->row_depth[0];
+	if(MDP_COLOR_IS_COMPRESS(c)) {
+		bytesperline = ((bytesperline + 31) >> 5) << 5;
+		stride = (bytesperline * MDP_COLOR_BITS_PER_PIXEL(c))
+			/ fmt->row_depth[0];
+	}
+	else {
+		stride = (bytesperline * MDP_COLOR_BITS_PER_PIXEL(c))
+			/ fmt->row_depth[0];
+	}
+
 	if (plane == 0)
 		return stride;
 	if (plane < MDP_COLOR_GET_PLANE_COUNT(c)) {
@@ -598,11 +688,172 @@ static u32 mdp_fmt_get_plane_size(const struct mdp_format *fmt,
 	return 0;
 }
 
+void mdp_set_scenario(struct img_ipi_frameparam *param,
+			struct mdp_frame *frame)
+{
+	u32 width = frame->format.fmt.pix_mp.width;
+	u32 height = frame->format.fmt.pix_mp.height;
+
+	if((width * height) >= (2560 * 1440))
+	{
+		param->type = MDP_STREAM_TYPE_DUAL_BITBLT;
+	}
+	mdp_dbg(2, "Scenario: %d\n",param->type);
+}
+
+static void mdp_set_hyfbc_patch(struct img_image_buffer *b,
+			       struct mdp_frame *frame, struct vb2_buffer *vb)
+{
+#define _DUMP_BUFF(st, sz) \
+do \
+{ \
+	uint8_t *_stva = (uint8_t *)st; \
+	uint8_t *_edva = (uint8_t *)(_stva+sz); \
+	mdp_dbg(0, "dump range[%p][%p] \n",_stva,_edva); \
+	while(_stva < _edva) { \
+		mdp_dbg(0, "[%p] [%02x][%02x][%02x][%02x][%02x][%02x][%02x][%02x] [%02x][%02x][%02x][%02x][%02x][%02x][%02x][%02x] \n", \
+			_stva, \
+			*(_stva+0), *(_stva+1), *(_stva+2), *(_stva+3), \
+			*(_stva+4), *(_stva+5), *(_stva+6), *(_stva+7), \
+			*(_stva+8), *(_stva+9), *(_stva+10), *(_stva+11),   \
+			*(_stva+12), *(_stva+13), *(_stva+14), *(_stva+15)); \
+		_stva+=16; \
+	} \
+}while(0)
+
+	uint32_t src_width;
+	uint32_t src_height;
+	uint32_t src_width_stride;
+	uint32_t src_height_stride;
+	uint32_t pitch_in_mb;
+	uint32_t pic_width_in_mb;
+	uint32_t pic_height_in_mb;
+	uint32_t byte_per_mb_row;
+	uint32_t yDataSize;
+	uint32_t yHeaderSize;
+	uint32_t cDataSize;
+	uint32_t cHeaderSize;
+	uint32_t srcBufSize;
+	uint32_t srcDataSize;
+	uintptr_t yDataAddr;
+	uintptr_t yHeaderAddr;
+	uintptr_t cDataAddr;
+	uintptr_t cHeaderAddr;
+	uintptr_t init_start_byte;
+
+	int i;
+	void *va_base;
+	uint32_t va_size = b->format.plane_fmt[0].size;
+
+	src_width = frame->format.fmt.pix_mp.width;
+	src_height = frame->format.fmt.pix_mp.height;
+	src_width_stride = frame->stride.width;
+	src_height_stride = frame->stride.height;
+
+	if (MDP_COLOR_IS_HYFBC_COMPRESS(frame->mdp_fmt->mdp_color) &&
+		src_width % 32 != 0)
+	{
+		mdp_dbg(1, "src[%d %d] stride[%d %d] f[%x] 10b[%d] 10bPack[%d] \n",
+			src_width,
+			src_height,
+			src_width_stride,
+			src_height_stride,
+			frame->mdp_fmt->mdp_color,
+			MDP_COLOR_IS_10BIT(frame->mdp_fmt->mdp_color),
+			MDP_COLOR_IS_10BIT_PACKED(frame->mdp_fmt->mdp_color));
+
+		/* Addressing */
+		va_base = vb2_plane_vaddr(vb, 0);
+		if(!va_base)
+		{
+			mdp_dbg(0, "[%s] Error: vb2_plane_vaddr\n",__FUNCTION__);
+			return;
+		}
+
+		/* Calculate Offset */
+		yDataSize = (((src_width_stride + 63) >> 6) << 6) * (((src_height_stride + 63) >> 6) << 6);
+		yHeaderSize = yDataSize >> 6;
+		if (MDP_COLOR_IS_10BIT_PACKED(frame->mdp_fmt->mdp_color))
+		{
+			yDataSize = (yDataSize * 6) >> 2;
+		}
+		cDataSize = yDataSize >> 1;
+		cHeaderSize = (((yHeaderSize >> 1) + 63) >> 6) << 6;
+		yDataAddr = (((uintptr_t)va_base + yHeaderSize + 4095) >> 12) << 12;
+		yHeaderAddr = yDataAddr - yHeaderSize;
+		cDataAddr = ((yDataAddr + yDataSize + cHeaderSize + 4095) >> 12) << 12;
+		cHeaderAddr = cDataAddr - cHeaderSize;
+
+		mdp_dbg(1, "Y: HdrAddr[0x%08x] HdrSz[0x%08x] DataAddr[0x%08x] DataSz[0x%08x] \n",
+				yHeaderAddr, yHeaderSize, yDataAddr, yDataSize);
+		mdp_dbg(1, "C: HdrAddr[0x%08x] HdrSz[0x%08x] DataAddr[0x%08x] DataSz[0x%08x] \n",
+				cHeaderAddr, cHeaderSize, cDataAddr, cDataSize);
+		mdp_dbg(1, "SrcBuf Base[0x%08x], Sz[0x%08x]\n",
+				va_base, va_size);
+
+		return;
+
+		srcBufSize = va_size;
+		srcDataSize = yHeaderSize + yDataSize + cHeaderSize + cDataSize;
+		if(srcDataSize > srcBufSize)
+		{
+			mdp_dbg(1, "Warning !! buffer size not match. Data[%x] Src[%x]\n",
+				srcDataSize, srcBufSize);
+		}
+
+		/* Fill in Y header */
+		pic_width_in_mb = CEIL(src_width , 16);
+		pic_height_in_mb = CEIL(src_height, 16);
+
+		pitch_in_mb = CEIL(ALIGN_UP(src_width_stride, 32), 16);
+		byte_per_mb_row = pitch_in_mb * BYTE_PER_MB_Y;
+
+		mdp_dbg(1, "width_in_mb[%d] height_in_mb[%d] pitch_in_mb[%d] byte_per_mb_row[%d]\n",
+			pic_width_in_mb, pic_height_in_mb, pitch_in_mb, byte_per_mb_row);
+
+		for (i=0 ; i<pic_height_in_mb ; i++) // loop of MB row
+		{
+			init_start_byte = yHeaderAddr + (pic_width_in_mb*BYTE_PER_MB_Y) + (i*byte_per_mb_row);
+			if (MDP_COLOR_IS_10BIT(frame->mdp_fmt->mdp_color))
+				*(uint32_t *)init_start_byte = 0xcf27cf27;
+			else
+				*(uint32_t *)init_start_byte = 0x1fbf1fbf;
+		}
+
+		/* Fill in C header */
+		pitch_in_mb = CEIL(ALIGN_UP(src_width_stride, 32), 16);
+		byte_per_mb_row = pitch_in_mb * BYTE_PER_MB_C;
+
+		mdp_dbg(1, "width_in_mb[%d] height_in_mb[%d] pitch_in_mb[%d] byte_per_mb_row[%d]\n",
+				pic_width_in_mb, pic_height_in_mb, pitch_in_mb, byte_per_mb_row);
+
+		for (i=0 ; i<pic_height_in_mb ; i++) // loop of MB row
+		{
+			init_start_byte = cHeaderAddr + (pic_width_in_mb*BYTE_PER_MB_C) + (i*byte_per_mb_row);
+			if (MDP_COLOR_IS_10BIT(frame->mdp_fmt->mdp_color))
+				*(uint16_t *)init_start_byte = 0xcf27;
+			else
+				*(uint16_t *)init_start_byte = 0x1fbf;
+		}
+
+#if DMA_HYFBC_HWPATCH_DUMP
+		/* Dump New Header */
+		mdp_dbg(0, "Dump Y hdr [%x][%x]\n", yHeaderAddr, yHeaderSize);
+		_DUMP_BUFF(yHeaderAddr, yHeaderSize);
+
+		mdp_dbg(0, "Dump C hdr [%x][%x]\n", cHeaderAddr, cHeaderSize);
+		_DUMP_BUFF(cHeaderAddr, cHeaderSize);
+#endif
+    }
+
+}
+
 static void mdp_prepare_buffer(struct img_image_buffer *b,
 			       struct mdp_frame *frame, struct vb2_buffer *vb)
 {
 	struct v4l2_pix_format_mplane *pix_mp = &frame->format.fmt.pix_mp;
 	unsigned int i;
+	u32 exsize;
 
 	b->format.colorformat = frame->mdp_fmt->mdp_color;
 	b->format.ycbcr_prof = frame->ycbcr_prof;
@@ -612,8 +863,8 @@ static void mdp_prepare_buffer(struct img_image_buffer *b,
 
 		b->format.plane_fmt[i].stride = stride;
 		/*
-		 * TODO : The way to pass an offset within a DMA-buf
-		 * is not defined in V4L2 specification, so we abuse
+		 * TODO(crbug.com/901264): The way to pass an offset within a
+		 * DMA-buf is not defined in V4L2 specification, so we abuse
 		 * data_offset for now. Fix it when we have the right interface,
 		 * including any necessary validation and potential alignment
 		 * issues.
@@ -622,6 +873,32 @@ static void mdp_prepare_buffer(struct img_image_buffer *b,
 			mdp_fmt_get_plane_size(frame->mdp_fmt, stride,
 					       pix_mp->height, i) -
 					       vb->planes[i].data_offset;
+
+		if(MDP_COLOR_IS_HYFBC_COMPRESS(b->format.colorformat))
+		{
+			b->format.plane_fmt[i].size =
+				mdp_fmt_get_hyfbc_plane_size(pix_mp->width,
+					pix_mp->height, b->format.colorformat);
+		}
+		else if(MDP_COLOR_IS_COMPRESS(b->format.colorformat))
+		{
+			b->format.plane_fmt[i].size =
+				mdp_fmt_get_afbc_plane_size(pix_mp->width,
+					pix_mp->height, b->format.colorformat);
+		}
+		else if(MDP_COLOR_IS_UFP(b->format.colorformat))
+		{
+			exsize = (((b->format.plane_fmt[0].size + 255)>>8) + 128);
+			exsize = ((exsize + 63) >> 6) << 6;
+
+			if(i == 1)
+			{
+				exsize = exsize / 2 + 128;
+				exsize = ((exsize + 15) >> 4) << 4;
+			}
+			b->format.plane_fmt[i].size += exsize;
+		}
+
 		b->iova[i] = vb2_dma_contig_plane_dma_addr(vb, i) +
 			     vb->planes[i].data_offset;
 	}
@@ -633,6 +910,31 @@ static void mdp_prepare_buffer(struct img_image_buffer *b,
 		b->format.plane_fmt[i].size =
 			mdp_fmt_get_plane_size(frame->mdp_fmt, stride,
 					       pix_mp->height, i);
+
+		if(MDP_COLOR_IS_HYFBC_COMPRESS(b->format.colorformat))
+		{
+			b->format.plane_fmt[i].size =
+				mdp_fmt_get_hyfbc_plane_size(pix_mp->width,
+					pix_mp->height, b->format.colorformat);
+		}
+		else if(MDP_COLOR_IS_COMPRESS(b->format.colorformat))
+		{
+			b->format.plane_fmt[i].size =
+				mdp_fmt_get_afbc_plane_size(pix_mp->width,
+					pix_mp->height, b->format.colorformat);
+		}
+		else if(MDP_COLOR_IS_UFP(b->format.colorformat))
+		{
+			exsize = (((b->format.plane_fmt[0].size + 255)>>8) + 128);
+			exsize = ((exsize + 63) >> 6) << 6;
+
+			if(i == 1)
+			{
+				exsize = exsize / 2 + 128;
+				exsize = ((exsize + 15) >> 4) << 4;
+			}
+			b->format.plane_fmt[i].size += exsize;
+		}
 		b->iova[i] = b->iova[i - 1] + b->format.plane_fmt[i - 1].size;
 	}
 	b->usage = frame->usage;
@@ -644,6 +946,9 @@ void mdp_set_src_config(struct img_input *in,
 	in->buffer.format.width = frame->format.fmt.pix_mp.width;
 	in->buffer.format.height = frame->format.fmt.pix_mp.height;
 	mdp_prepare_buffer(&in->buffer, frame, vb);
+	mdp_set_hyfbc_patch(&in->buffer, frame, vb);
+
+	/* in->flags |= ; */	/* HDR, DRE, dither */
 }
 
 static u32 mdp_to_fixed(u32 *r, struct v4l2_fract *f)
@@ -703,6 +1008,7 @@ void mdp_set_dst_config(struct img_output *out,
 	out->buffer.format.height = frame->compose.height;
 	mdp_prepare_buffer(&out->buffer, frame, vb);
 	mdp_set_src_crop(&out->crop, &frame->crop);
+
 	mdp_set_orientation(out, frame->rotation, frame->hflip, frame->vflip);
 
 	/* out->flags |= ; */	/* sharpness, dither */
diff --git a/drivers/media/platform/mtk-mdp3/mtk-mdp3-regs.h b/drivers/media/platform/mtk-mdp3/mtk-mdp3-regs.h
index b41c419afb101699fd6166966d534804d0bead94..02c04c7974922e1b46025b484388c3782d8b5da8 100644
--- a/drivers/media/platform/mtk-mdp3/mtk-mdp3-regs.h
+++ b/drivers/media/platform/mtk-mdp3/mtk-mdp3-regs.h
@@ -18,172 +18,167 @@
  * V-subsample: 0, 1
  * Color group: 0-RGB, 1-YUV, 2-raw
  */
-#define MDP_COLOR(PACKED, LOOSE, VIDEO, PLANE, HF, VF, BITS, GROUP, SWAP, ID)\
-	(((PACKED) << 27) | ((LOOSE) << 26) | ((VIDEO) << 23) |\
+#define MDP_COLOR(COMPRESS, PACKED, LOOSE, VIDEO, PLANE, HF, VF, BITS, GROUP, SWAP, ID)\
+	(((COMPRESS) << 29) | ((PACKED) << 28) | ((LOOSE) << 27) | ((VIDEO) << 23) |\
 	 ((PLANE) << 21) | ((HF) << 19) | ((VF) << 18) | ((BITS) << 8) |\
 	 ((GROUP) << 6) | ((SWAP) << 5) | ((ID) << 0))
 
-#define MDP_COLOR_IS_10BIT_PACKED(c)    ((0x08000000 & (c)) >> 27)
-#define MDP_COLOR_IS_10BIT_LOOSE(c)    (((0x0c000000 & (c)) >> 26) == 1)
-#define MDP_COLOR_IS_10BIT_TILE(c)     (((0x0c000000 & (c)) >> 26) == 3)
-#define MDP_COLOR_IS_UFP(c)             ((0x02000000 & (c)) >> 25)
-#define MDP_COLOR_IS_INTERLACED(c)      ((0x01000000 & (c)) >> 24)
-#define MDP_COLOR_IS_BLOCK_MODE(c)      ((0x00800000 & (c)) >> 23)
-#define MDP_COLOR_GET_PLANE_COUNT(c)    ((0x00600000 & (c)) >> 21)
-#define MDP_COLOR_GET_H_SUBSAMPLE(c)    ((0x00180000 & (c)) >> 19)
-#define MDP_COLOR_GET_V_SUBSAMPLE(c)    ((0x00040000 & (c)) >> 18)
-#define MDP_COLOR_BITS_PER_PIXEL(c)     ((0x0003ff00 & (c)) >>  8)
-#define MDP_COLOR_GET_GROUP(c)          ((0x000000c0 & (c)) >>  6)
-#define MDP_COLOR_IS_SWAPPED(c)         ((0x00000020 & (c)) >>  5)
-#define MDP_COLOR_GET_UNIQUE_ID(c)      ((0x0000001f & (c)) >>  0)
-#define MDP_COLOR_GET_HW_FORMAT(c)      ((0x0000001f & (c)) >>  0)
-
-#define MDP_COLOR_IS_RGB(c)		(MDP_COLOR_GET_GROUP(c) == 0)
-#define MDP_COLOR_IS_YUV(c)		(MDP_COLOR_GET_GROUP(c) == 1)
-#define MDP_COLOR_IS_UV_COPLANE(c)	((MDP_COLOR_GET_PLANE_COUNT(c) == 2) &&\
-					 MDP_COLOR_IS_YUV(c))
+#define MDP_COLOR_IS_HYFBC_COMPRESS(c)  ((0x40000000 & c) >> 30)
+#define MDP_COLOR_IS_COMPRESS(c)        ((0x20000000 & c) >> 29)
+#define MDP_COLOR_IS_10BIT_PACKED(c)    ((0x10000000 & c) >> 28)
+#define MDP_COLOR_IS_10BIT_LOOSE(c)     (((0x18000000 & c) >> 27) == 1)
+#define MDP_COLOR_IS_10BIT_TILE(c)      (((0x18000000 & c) >> 27) == 3)
+#define MDP_COLOR_IS_10BIT_JUMP(c)      ((0x04000000 & c) >> 26)
+#define MDP_COLOR_IS_UFP(c)             ((0x02000000 & c) >> 25)
+#define MDP_COLOR_IS_INTERLACED(c)      ((0x01000000 & c) >> 24)
+#define MDP_COLOR_IS_BLOCK_MODE(c)      ((0x00800000 & c) >> 23)
+#define MDP_COLOR_GET_PLANE_COUNT(c)    ((0x00600000 & c) >> 21) /* 1-3 */
+#define MDP_COLOR_GET_H_SUBSAMPLE(c)    ((0x00180000 & c) >> 19) /* 0-2 */
+#define MDP_COLOR_GET_V_SUBSAMPLE(c)    ((0x00040000 & c) >> 18) /* 0-1 */
+#define MDP_COLOR_BITS_PER_PIXEL(c)     ((0x0003FF00 & c) >>  8)
+#define MDP_COLOR_GET_GROUP(c)          ((0x000000C0 & c) >>  6)
+#define MDP_COLOR_IS_SWAPPED(c)         ((0x00000020 & c) >>  5)
+#define MDP_COLOR_GET_UNIQUE_ID(c)      ((0x0000001F & c) >>  0)
+#define MDP_COLOR_GET_HW_FORMAT(c)      ((0x0000001F & c) >>  0)
+
+#define MDP_COLOR_IS_RGB(c)		        (MDP_COLOR_GET_GROUP(c) == 0)
+#define MDP_COLOR_IS_YUV(c)		        (MDP_COLOR_GET_GROUP(c) == 1)
+#define MDP_COLOR_IS_UV_COPLANE(c)	    ((MDP_COLOR_GET_PLANE_COUNT(c) == 2) &&\
+    					                        MDP_COLOR_IS_YUV(c))
+#define MDP_COLOR_IS_10BIT(c)            (((0x18000000 & c) >> 27) != 0)
+#define MDP_COLOR_GET_AUO_MODE(c)        (MDP_COLOR_IS_10BIT_JUMP(c))
 
 enum mdp_color {
-	MDP_COLOR_UNKNOWN	= 0,
-
-	//MDP_COLOR_FULLG8,
-	MDP_COLOR_FULLG8_RGGB	= MDP_COLOR(0, 0, 0, 1, 0, 0,  8, 2,  0, 21),
-	MDP_COLOR_FULLG8_GRBG	= MDP_COLOR(0, 0, 0, 1, 0, 1,  8, 2,  0, 21),
-	MDP_COLOR_FULLG8_GBRG	= MDP_COLOR(0, 0, 0, 1, 1, 0,  8, 2,  0, 21),
-	MDP_COLOR_FULLG8_BGGR	= MDP_COLOR(0, 0, 0, 1, 1, 1,  8, 2,  0, 21),
-	MDP_COLOR_FULLG8	= MDP_COLOR_FULLG8_BGGR,
-
-	//MDP_COLOR_FULLG10,
-	MDP_COLOR_FULLG10_RGGB	= MDP_COLOR(0, 0, 0, 1, 0, 0, 10, 2,  0, 21),
-	MDP_COLOR_FULLG10_GRBG	= MDP_COLOR(0, 0, 0, 1, 0, 1, 10, 2,  0, 21),
-	MDP_COLOR_FULLG10_GBRG	= MDP_COLOR(0, 0, 0, 1, 1, 0, 10, 2,  0, 21),
-	MDP_COLOR_FULLG10_BGGR	= MDP_COLOR(0, 0, 0, 1, 1, 1, 10, 2,  0, 21),
-	MDP_COLOR_FULLG10	= MDP_COLOR_FULLG10_BGGR,
-
-	//MDP_COLOR_FULLG12,
-	MDP_COLOR_FULLG12_RGGB	= MDP_COLOR(0, 0, 0, 1, 0, 0, 12, 2,  0, 21),
-	MDP_COLOR_FULLG12_GRBG	= MDP_COLOR(0, 0, 0, 1, 0, 1, 12, 2,  0, 21),
-	MDP_COLOR_FULLG12_GBRG	= MDP_COLOR(0, 0, 0, 1, 1, 0, 12, 2,  0, 21),
-	MDP_COLOR_FULLG12_BGGR	= MDP_COLOR(0, 0, 0, 1, 1, 1, 12, 2,  0, 21),
-	MDP_COLOR_FULLG12	= MDP_COLOR_FULLG12_BGGR,
-
-	//MDP_COLOR_FULLG14,
-	MDP_COLOR_FULLG14_RGGB	= MDP_COLOR(0, 0, 0, 1, 0, 0, 14, 2,  0, 21),
-	MDP_COLOR_FULLG14_GRBG	= MDP_COLOR(0, 0, 0, 1, 0, 1, 14, 2,  0, 21),
-	MDP_COLOR_FULLG14_GBRG	= MDP_COLOR(0, 0, 0, 1, 1, 0, 14, 2,  0, 21),
-	MDP_COLOR_FULLG14_BGGR	= MDP_COLOR(0, 0, 0, 1, 1, 1, 14, 2,  0, 21),
-	MDP_COLOR_FULLG14	= MDP_COLOR_FULLG14_BGGR,
-
-	MDP_COLOR_UFO10		= MDP_COLOR(0, 0, 0, 1, 0, 0, 10, 2,  0, 24),
-
-	//MDP_COLOR_BAYER8,
-	MDP_COLOR_BAYER8_RGGB	= MDP_COLOR(0, 0, 0, 1, 0, 0,  8, 2,  0, 20),
-	MDP_COLOR_BAYER8_GRBG	= MDP_COLOR(0, 0, 0, 1, 0, 1,  8, 2,  0, 20),
-	MDP_COLOR_BAYER8_GBRG	= MDP_COLOR(0, 0, 0, 1, 1, 0,  8, 2,  0, 20),
-	MDP_COLOR_BAYER8_BGGR	= MDP_COLOR(0, 0, 0, 1, 1, 1,  8, 2,  0, 20),
-	MDP_COLOR_BAYER8	= MDP_COLOR_BAYER8_BGGR,
-
-	//MDP_COLOR_BAYER10,
-	MDP_COLOR_BAYER10_RGGB	= MDP_COLOR(0, 0, 0, 1, 0, 0, 10, 2,  0, 20),
-	MDP_COLOR_BAYER10_GRBG	= MDP_COLOR(0, 0, 0, 1, 0, 1, 10, 2,  0, 20),
-	MDP_COLOR_BAYER10_GBRG	= MDP_COLOR(0, 0, 0, 1, 1, 0, 10, 2,  0, 20),
-	MDP_COLOR_BAYER10_BGGR	= MDP_COLOR(0, 0, 0, 1, 1, 1, 10, 2,  0, 20),
-	MDP_COLOR_BAYER10	= MDP_COLOR_BAYER10_BGGR,
-
-	//MDP_COLOR_BAYER12,
-	MDP_COLOR_BAYER12_RGGB	= MDP_COLOR(0, 0, 0, 1, 0, 0, 12, 2,  0, 20),
-	MDP_COLOR_BAYER12_GRBG	= MDP_COLOR(0, 0, 0, 1, 0, 1, 12, 2,  0, 20),
-	MDP_COLOR_BAYER12_GBRG	= MDP_COLOR(0, 0, 0, 1, 1, 0, 12, 2,  0, 20),
-	MDP_COLOR_BAYER12_BGGR	= MDP_COLOR(0, 0, 0, 1, 1, 1, 12, 2,  0, 20),
-	MDP_COLOR_BAYER12	= MDP_COLOR_BAYER12_BGGR,
-
-	//MDP_COLOR_BAYER14,
-	MDP_COLOR_BAYER14_RGGB	= MDP_COLOR(0, 0, 0, 1, 0, 0, 14, 2,  0, 20),
-	MDP_COLOR_BAYER14_GRBG	= MDP_COLOR(0, 0, 0, 1, 0, 1, 14, 2,  0, 20),
-	MDP_COLOR_BAYER14_GBRG	= MDP_COLOR(0, 0, 0, 1, 1, 0, 14, 2,  0, 20),
-	MDP_COLOR_BAYER14_BGGR	= MDP_COLOR(0, 0, 0, 1, 1, 1, 14, 2,  0, 20),
-	MDP_COLOR_BAYER14	= MDP_COLOR_BAYER14_BGGR,
-
-	MDP_COLOR_RGB48		= MDP_COLOR(0, 0, 0, 1, 0, 0, 48, 0,  0, 23),
-	/* For bayer+mono raw-16 */
-	MDP_COLOR_RGB565_RAW	= MDP_COLOR(0, 0, 0, 1, 0, 0, 16, 2,  0, 0),
-
-	MDP_COLOR_BAYER8_UNPAK	= MDP_COLOR(0, 0, 0, 1, 0, 0,  8, 2,  0, 22),
-	MDP_COLOR_BAYER10_UNPAK	= MDP_COLOR(0, 0, 0, 1, 0, 0, 10, 2,  0, 22),
-	MDP_COLOR_BAYER12_UNPAK	= MDP_COLOR(0, 0, 0, 1, 0, 0, 12, 2,  0, 22),
-	MDP_COLOR_BAYER14_UNPAK	= MDP_COLOR(0, 0, 0, 1, 0, 0, 14, 2,  0, 22),
-
-	/* Unified formats */
-	MDP_COLOR_GREY		= MDP_COLOR(0, 0, 0, 1, 0, 0,  8, 1,  0, 7),
-
-	MDP_COLOR_RGB565	= MDP_COLOR(0, 0, 0, 1, 0, 0, 16, 0,  0, 0),
-	MDP_COLOR_BGR565	= MDP_COLOR(0, 0, 0, 1, 0, 0, 16, 0,  1, 0),
-	MDP_COLOR_RGB888	= MDP_COLOR(0, 0, 0, 1, 0, 0, 24, 0,  1, 1),
-	MDP_COLOR_BGR888	= MDP_COLOR(0, 0, 0, 1, 0, 0, 24, 0,  0, 1),
-	MDP_COLOR_RGBA8888	= MDP_COLOR(0, 0, 0, 1, 0, 0, 32, 0,  1, 2),
-	MDP_COLOR_BGRA8888	= MDP_COLOR(0, 0, 0, 1, 0, 0, 32, 0,  0, 2),
-	MDP_COLOR_ARGB8888	= MDP_COLOR(0, 0, 0, 1, 0, 0, 32, 0,  1, 3),
-	MDP_COLOR_ABGR8888	= MDP_COLOR(0, 0, 0, 1, 0, 0, 32, 0,  0, 3),
-
-	MDP_COLOR_UYVY		= MDP_COLOR(0, 0, 0, 1, 1, 0, 16, 1,  0, 4),
-	MDP_COLOR_VYUY		= MDP_COLOR(0, 0, 0, 1, 1, 0, 16, 1,  1, 4),
-	MDP_COLOR_YUYV		= MDP_COLOR(0, 0, 0, 1, 1, 0, 16, 1,  0, 5),
-	MDP_COLOR_YVYU		= MDP_COLOR(0, 0, 0, 1, 1, 0, 16, 1,  1, 5),
-
-	MDP_COLOR_I420		= MDP_COLOR(0, 0, 0, 3, 1, 1,  8, 1,  0, 8),
-	MDP_COLOR_YV12		= MDP_COLOR(0, 0, 0, 3, 1, 1,  8, 1,  1, 8),
-	MDP_COLOR_I422		= MDP_COLOR(0, 0, 0, 3, 1, 0,  8, 1,  0, 9),
-	MDP_COLOR_YV16		= MDP_COLOR(0, 0, 0, 3, 1, 0,  8, 1,  1, 9),
-	MDP_COLOR_I444		= MDP_COLOR(0, 0, 0, 3, 0, 0,  8, 1,  0, 10),
-	MDP_COLOR_YV24		= MDP_COLOR(0, 0, 0, 3, 0, 0,  8, 1,  1, 10),
-
-	MDP_COLOR_NV12		= MDP_COLOR(0, 0, 0, 2, 1, 1,  8, 1,  0, 12),
-	MDP_COLOR_NV21		= MDP_COLOR(0, 0, 0, 2, 1, 1,  8, 1,  1, 12),
-	MDP_COLOR_NV16		= MDP_COLOR(0, 0, 0, 2, 1, 0,  8, 1,  0, 13),
-	MDP_COLOR_NV61		= MDP_COLOR(0, 0, 0, 2, 1, 0,  8, 1,  1, 13),
-	MDP_COLOR_NV24		= MDP_COLOR(0, 0, 0, 2, 0, 0,  8, 1,  0, 14),
-	MDP_COLOR_NV42		= MDP_COLOR(0, 0, 0, 2, 0, 0,  8, 1,  1, 14),
-
-	/* Mediatek proprietary formats */
-	/* UFO encoded block mode */
-	MDP_COLOR_420_BLK_UFO	= MDP_COLOR(0, 0, 5, 2, 1, 1, 256, 1, 0, 12),
-	/* Block mode */
-	MDP_COLOR_420_BLK	= MDP_COLOR(0, 0, 1, 2, 1, 1, 256, 1, 0, 12),
-	/* Block mode + field mode */
-	MDP_COLOR_420_BLKI	= MDP_COLOR(0, 0, 3, 2, 1, 1, 256, 1, 0, 12),
-	/* Block mode */
-	MDP_COLOR_422_BLK	= MDP_COLOR(0, 0, 1, 1, 1, 0, 512, 1, 0, 4),
-
-	MDP_COLOR_IYU2		= MDP_COLOR(0, 0, 0, 1, 0, 0, 24,  1, 0, 25),
-	MDP_COLOR_YUV444	= MDP_COLOR(0, 0, 0, 1, 0, 0, 24,  1, 0, 30),
-
-	/* Packed 10-bit formats */
-	MDP_COLOR_RGBA1010102	= MDP_COLOR(1, 0, 0, 1, 0, 0, 32,  0, 1, 2),
-	MDP_COLOR_BGRA1010102	= MDP_COLOR(1, 0, 0, 1, 0, 0, 32,  0, 0, 2),
-	/* Packed 10-bit UYVY */
-	MDP_COLOR_UYVY_10P	= MDP_COLOR(1, 0, 0, 1, 1, 0, 20,  1, 0, 4),
-	/* Packed 10-bit NV21 */
-	MDP_COLOR_NV21_10P	= MDP_COLOR(1, 0, 0, 2, 1, 1, 10,  1, 1, 12),
-	/* 10-bit block mode */
-	MDP_COLOR_420_BLK_10_H	= MDP_COLOR(1, 0, 1, 2, 1, 1, 320, 1, 0, 12),
-	/* 10-bit HEVC tile mode */
-	MDP_COLOR_420_BLK_10_V	= MDP_COLOR(1, 1, 1, 2, 1, 1, 320, 1, 0, 12),
-	/* UFO encoded 10-bit block mode */
-	MDP_COLOR_420_BLK_U10_H	= MDP_COLOR(1, 0, 5, 2, 1, 1, 320, 1, 0, 12),
-	/* UFO encoded 10-bit HEVC tile mode */
-	MDP_COLOR_420_BLK_U10_V	= MDP_COLOR(1, 1, 5, 2, 1, 1, 320, 1, 0, 12),
-
-	/* Loose 10-bit formats */
-	MDP_COLOR_UYVY_10L	= MDP_COLOR(0, 1, 0, 1, 1, 0, 20,  1, 0, 4),
-	MDP_COLOR_VYUY_10L	= MDP_COLOR(0, 1, 0, 1, 1, 0, 20,  1, 1, 4),
-	MDP_COLOR_YUYV_10L	= MDP_COLOR(0, 1, 0, 1, 1, 0, 20,  1, 0, 5),
-	MDP_COLOR_YVYU_10L	= MDP_COLOR(0, 1, 0, 1, 1, 0, 20,  1, 1, 5),
-	MDP_COLOR_NV12_10L	= MDP_COLOR(0, 1, 0, 2, 1, 1, 10,  1, 0, 12),
-	MDP_COLOR_NV21_10L	= MDP_COLOR(0, 1, 0, 2, 1, 1, 10,  1, 1, 12),
-	MDP_COLOR_NV16_10L	= MDP_COLOR(0, 1, 0, 2, 1, 0, 10,  1, 0, 13),
-	MDP_COLOR_NV61_10L	= MDP_COLOR(0, 1, 0, 2, 1, 0, 10,  1, 1, 13),
-	MDP_COLOR_YV12_10L	= MDP_COLOR(0, 1, 0, 3, 1, 1, 10,  1, 1, 8),
-	MDP_COLOR_I420_10L	= MDP_COLOR(0, 1, 0, 3, 1, 1, 10,  1, 0, 8),
+    MDP_COLOR_UNKNOWN        = 0,
+
+    MDP_COLOR_FULLG8         = MDP_COLOR(0, 0, 0, 0, 1, 0, 0,  8, 2,  0, 21),
+    MDP_COLOR_FULLG10        = MDP_COLOR(0, 0, 0, 0, 1, 0, 0, 10, 2,  0, 21),
+    MDP_COLOR_FULLG12        = MDP_COLOR(0, 0, 0, 0, 1, 0, 0, 12, 2,  0, 21),
+    MDP_COLOR_FULLG14        = MDP_COLOR(0, 0, 0, 0, 1, 0, 0, 14, 2,  0, 21),
+    MDP_COLOR_UFO10          = MDP_COLOR(0, 0, 0, 0, 1, 0, 0, 10, 2,  0, 24),
+
+    MDP_COLOR_BAYER8         = MDP_COLOR(0, 0, 0, 0, 1, 0, 0,  8, 2,  0, 20),
+    MDP_COLOR_BAYER10        = MDP_COLOR(0, 0, 0, 0, 1, 0, 0, 10, 2,  0, 20),
+    MDP_COLOR_BAYER12        = MDP_COLOR(0, 0, 0, 0, 1, 0, 0, 12, 2,  0, 20),
+    MDP_COLOR_BAYER22        = MDP_COLOR(0, 0, 0, 0, 1, 0, 0, 24, 2,  0, 20), // fix 24 bits for pixel
+    MDP_COLOR_RGB48          = MDP_COLOR(0, 0, 0, 0, 1, 0, 0, 48, 0,  0, 23),
+    //for Bayer+Mono raw-16
+    MDP_COLOR_RGB565_RAW     = MDP_COLOR(0, 0, 0, 0, 1, 0, 0, 16, 2,  0, 0),
+
+    MDP_COLOR_BAYER8_UNPAK   = MDP_COLOR(0, 0, 0, 0, 1, 0, 0,  8, 2,  0, 22), // fix 16 bits for pixel
+    MDP_COLOR_BAYER10_UNPAK  = MDP_COLOR(0, 0, 0, 0, 1, 0, 0, 10, 2,  0, 22), // fix 16 bits for pixel
+    MDP_COLOR_BAYER12_UNPAK  = MDP_COLOR(0, 0, 0, 0, 1, 0, 0, 12, 2,  0, 22), // fix 16 bits for pixel
+    MDP_COLOR_BAYER14_UNPAK  = MDP_COLOR(0, 0, 0, 0, 1, 0, 0, 14, 2,  0, 22), // fix 16 bits for pixel
+    MDP_COLOR_BAYER16_UNPAK  = MDP_COLOR(0, 0, 0, 0, 1, 0, 0, 16, 2,  0, 22), // fix 16 bits for pixel
+
+    // Unified format
+    MDP_COLOR_GREY           = MDP_COLOR(0, 0, 0, 0, 1, 0, 0,  8, 1,  0, 7),
+
+    MDP_COLOR_RGB565         = MDP_COLOR(0, 0, 0, 0, 1, 0, 0, 16, 0,  0, 0),
+    MDP_COLOR_BGR565         = MDP_COLOR(0, 0, 0, 0, 1, 0, 0, 16, 0,  1, 0),
+    MDP_COLOR_RGB888         = MDP_COLOR(0, 0, 0, 0, 1, 0, 0, 24, 0,  1, 1),
+    MDP_COLOR_BGR888         = MDP_COLOR(0, 0, 0, 0, 1, 0, 0, 24, 0,  0, 1),
+    MDP_COLOR_RGBA8888       = MDP_COLOR(0, 0, 0, 0, 1, 0, 0, 32, 0,  1, 2),
+    MDP_COLOR_BGRA8888       = MDP_COLOR(0, 0, 0, 0, 1, 0, 0, 32, 0,  0, 2),
+    MDP_COLOR_ARGB8888       = MDP_COLOR(0, 0, 0, 0, 1, 0, 0, 32, 0,  1, 3),
+    MDP_COLOR_ABGR8888       = MDP_COLOR(0, 0, 0, 0, 1, 0, 0, 32, 0,  0, 3),
+
+    MDP_COLOR_UYVY           = MDP_COLOR(0, 0, 0, 0, 1, 1, 0, 16, 1,  0, 4),
+    MDP_COLOR_VYUY           = MDP_COLOR(0, 0, 0, 0, 1, 1, 0, 16, 1,  1, 4),
+    MDP_COLOR_YUYV           = MDP_COLOR(0, 0, 0, 0, 1, 1, 0, 16, 1,  0, 5),
+    MDP_COLOR_YVYU           = MDP_COLOR(0, 0, 0, 0, 1, 1, 0, 16, 1,  1, 5),
+
+    MDP_COLOR_I420           = MDP_COLOR(0, 0, 0, 0, 3, 1, 1,  8, 1,  0, 8),
+    MDP_COLOR_YV12           = MDP_COLOR(0, 0, 0, 0, 3, 1, 1,  8, 1,  1, 8),
+    MDP_COLOR_I422           = MDP_COLOR(0, 0, 0, 0, 3, 1, 0,  8, 1,  0, 9),
+    MDP_COLOR_YV16           = MDP_COLOR(0, 0, 0, 0, 3, 1, 0,  8, 1,  1, 9),
+    MDP_COLOR_I444           = MDP_COLOR(0, 0, 0, 0, 3, 0, 0,  8, 1,  0, 10),
+    MDP_COLOR_YV24           = MDP_COLOR(0, 0, 0, 0, 3, 0, 0,  8, 1,  1, 10),
+
+    MDP_COLOR_NV12           = MDP_COLOR(0, 0, 0, 0, 2, 1, 1,  8, 1,  0, 12),
+    MDP_COLOR_NV21           = MDP_COLOR(0, 0, 0, 0, 2, 1, 1,  8, 1,  1, 12),
+    MDP_COLOR_NV16           = MDP_COLOR(0, 0, 0, 0, 2, 1, 0,  8, 1,  0, 13),
+    MDP_COLOR_NV61           = MDP_COLOR(0, 0, 0, 0, 2, 1, 0,  8, 1,  1, 13),
+    MDP_COLOR_NV24           = MDP_COLOR(0, 0, 0, 0, 2, 0, 0,  8, 1,  0, 14),
+    MDP_COLOR_NV42           = MDP_COLOR(0, 0, 0, 0, 2, 0, 0,  8, 1,  1, 14),
+
+    // Mediatek proprietary format
+    //Frame mode + Block mode + UFO
+    MDP_COLOR_420_BLKP_UFO   = MDP_COLOR(0, 0, 0, 5, 2, 1, 1, 256, 1, 0, 12),
+    //Frame mode + Block mode + UFO AUO
+    MDP_COLOR_420_BLKP_UFO_AUO   = MDP_COLOR(0, 0, 0, 13, 2, 1, 1, 256, 1, 0, 12),
+    //Frame mode + Block mode
+    MDP_COLOR_420_BLKP       = MDP_COLOR(0, 0, 0, 1, 2, 1, 1, 256, 1, 0, 12),
+    //Field mode + Block mode
+    MDP_COLOR_420_BLKI       = MDP_COLOR(0, 0, 0, 3, 2, 1, 1, 256, 1, 0, 12),
+    //Frame mode
+    MDP_COLOR_422_BLKP       = MDP_COLOR(0, 0, 0, 1, 1, 1, 0, 512, 1, 0, 4),
+
+    MDP_COLOR_IYU2           = MDP_COLOR(0, 0, 0, 0, 1, 0, 0, 24,  1, 0, 25),
+    MDP_COLOR_YUV444         = MDP_COLOR(0, 0, 0, 0, 1, 0, 0, 24,  1, 0, 30),
+
+    // Mediatek proprietary 10bit format
+    MDP_COLOR_RGBA1010102    = MDP_COLOR(0, 1, 0, 0, 1, 0, 0, 32,  0, 1, 2),
+    MDP_COLOR_BGRA1010102    = MDP_COLOR(0, 1, 0, 0, 1, 0, 0, 32,  0, 0, 2),
+    MDP_COLOR_ARGB1010102    = MDP_COLOR(0, 1, 0, 0, 1, 0, 0, 32,  0, 1, 3),
+    MDP_COLOR_ABGR1010102    = MDP_COLOR(0, 1, 0, 0, 1, 0, 0, 32,  0, 0, 3),
+    //Packed 10bit UYVY
+    MDP_COLOR_UYVY_10P       = MDP_COLOR(0, 1, 0, 0, 1, 1, 0, 20,  1, 0, 4),
+    //Packed 10bit NV21
+    MDP_COLOR_NV12_10P       = MDP_COLOR(0, 1, 0, 0, 2, 1, 1, 10,  1, 0, 12),
+    MDP_COLOR_NV21_10P       = MDP_COLOR(0, 1, 0, 0, 2, 1, 1, 10,  1, 1, 12),
+    //Frame mode + Block mode
+    MDP_COLOR_420_BLKP_10_H          = MDP_COLOR(0, 1, 0, 1, 2, 1, 1, 320, 1, 0, 12),
+    //Frame mode + HEVC tile mode
+    MDP_COLOR_420_BLKP_10_V          = MDP_COLOR(0, 1, 1, 1, 2, 1, 1, 320, 1, 0, 12),
+    //Frame mode + Block mode + Jump
+    MDP_COLOR_420_BLKP_10_H_JUMP     = MDP_COLOR(0, 1, 0, 9, 2, 1, 1, 320, 1, 0, 12),
+    //Frame mode + HEVC tile mode + Jump
+    MDP_COLOR_420_BLKP_10_V_JUMP     = MDP_COLOR(0, 1, 1, 9, 2, 1, 1, 320, 1, 0, 12),
+    //Frame mode + Block mode
+    MDP_COLOR_420_BLKP_UFO_10_H      = MDP_COLOR(0, 1, 0, 5, 2, 1, 1, 320, 1, 0, 12),
+    //Frame mode + HEVC tile mode
+    MDP_COLOR_420_BLKP_UFO_10_V      = MDP_COLOR(0, 1, 1, 5, 2, 1, 1, 320, 1, 0, 12),
+    //Frame mode + Block mode + Jump
+    MDP_COLOR_420_BLKP_UFO_10_H_JUMP = MDP_COLOR(0, 1, 0, 13, 2, 1, 1, 320, 1, 0, 12),
+    //Frame mode + HEVC tile mode + Jump
+    MDP_COLOR_420_BLKP_UFO_10_V_JUMP = MDP_COLOR(0, 1, 1, 13, 2, 1, 1, 320, 1, 0, 12),
+
+    // Loose 10bit format
+    MDP_COLOR_UYVY_10L       = MDP_COLOR(0, 0, 1, 0, 1, 1, 0, 20,  1, 0, 4),
+    MDP_COLOR_VYUY_10L       = MDP_COLOR(0, 0, 1, 0, 1, 1, 0, 20,  1, 1, 4),
+    MDP_COLOR_YUYV_10L       = MDP_COLOR(0, 0, 1, 0, 1, 1, 0, 20,  1, 0, 5),
+    MDP_COLOR_YVYU_10L       = MDP_COLOR(0, 0, 1, 0, 1, 1, 0, 20,  1, 1, 5),
+    MDP_COLOR_NV12_10L       = MDP_COLOR(0, 0, 1, 0, 2, 1, 1, 16,  1, 0, 12),
+    MDP_COLOR_NV21_10L       = MDP_COLOR(0, 0, 1, 0, 2, 1, 1, 16,  1, 1, 12),
+    MDP_COLOR_NV16_10L       = MDP_COLOR(0, 0, 1, 0, 2, 1, 0, 16,  1, 0, 13),
+    MDP_COLOR_NV61_10L       = MDP_COLOR(0, 0, 1, 0, 2, 1, 0, 16,  1, 1, 13),
+    MDP_COLOR_YV12_10L       = MDP_COLOR(0, 0, 1, 0, 3, 1, 1, 16,  1, 1, 8),
+    MDP_COLOR_I420_10L       = MDP_COLOR(0, 0, 1, 0, 3, 1, 1, 16,  1, 0, 8),
+
+    MDP_COLOR_YV12_10P       = MDP_COLOR(0, 1, 0, 0, 3, 1, 1, 10,  1, 1, 8),
+    MDP_COLOR_I422_10P       = MDP_COLOR(0, 1, 0, 0, 3, 1, 0, 10,  1, 0, 9),
+    MDP_COLOR_NV16_10P       = MDP_COLOR(0, 1, 0, 0, 2, 1, 0, 10,  1, 0, 13),
+    MDP_COLOR_NV61_10P       = MDP_COLOR(0, 1, 0, 0, 2, 1, 0, 10,  1, 1, 13),
+
+    MDP_COLOR_I422_10L       = MDP_COLOR(0, 0, 1, 0, 3, 1, 0, 16,  1, 0, 9),
+
+    MDP_COLOR_RGBA8888_AFBC       = MDP_COLOR(1, 0, 0, 0, 1, 0, 0, 32, 0, 1, 2),
+    MDP_COLOR_BGRA8888_AFBC       = MDP_COLOR(1, 0, 0, 0, 1, 0, 0, 32, 0, 0, 2),
+    MDP_COLOR_ARGB8888_AFBC       = MDP_COLOR(1, 0, 0, 0, 1, 0, 0, 32, 0, 1, 3),
+    MDP_COLOR_ABGR8888_AFBC       = MDP_COLOR(1, 0, 0, 0, 1, 0, 0, 32, 0, 0, 3),
+    MDP_COLOR_RGBA1010102_AFBC    = MDP_COLOR(1, 1, 0, 0, 1, 0, 0, 32, 0, 1, 2),
+    MDP_COLOR_BGRA1010102_AFBC    = MDP_COLOR(1, 1, 0, 0, 1, 0, 0, 32, 0, 0, 2),
+    MDP_COLOR_ARGB1010102_AFBC    = MDP_COLOR(1, 1, 0, 0, 1, 0, 0, 32, 0, 1, 3),
+    MDP_COLOR_ABGR1010102_AFBC    = MDP_COLOR(1, 1, 0, 0, 1, 0, 0, 32, 0, 0, 3),
+
+    MDP_COLOR_NV12_AFBC          = MDP_COLOR(1, 0, 0, 0, 2, 1, 1,  12,  1, 0, 12),
+    MDP_COLOR_P010_AFBC          = MDP_COLOR(1, 1, 0, 0, 2, 1, 1,  10,  1, 0, 12),
+
+    MDP_COLOR_NV12_HYFBC          = MDP_COLOR(2, 0, 0, 0, 2, 1, 1,  8,  1, 0, 12),
+    MDP_COLOR_NV21_HYFBC          = MDP_COLOR(2, 0, 0, 0, 2, 1, 1,  8,  1, 1, 12),
+    MDP_COLOR_NV12_10P_HYFBC      = MDP_COLOR(2, 1, 0, 0, 2, 1, 1, 10,  1, 0, 12),
+    MDP_COLOR_NV21_10P_HYFBC      = MDP_COLOR(2, 1, 0, 0, 2, 1, 1, 10,  1, 1, 12),
 };
 
 /* Minimum Y stride that is accepted by MDP HW */
@@ -313,6 +308,8 @@ struct mdp_frame {
 	u32			dre:1;
 	u32			sharpness:1;
 	u32			dither:1;
+	/* H and V stride, only for HYFBC format */
+	struct v4l2_rect	stride;
 };
 
 static inline bool mdp_target_is_crop(u32 target)
@@ -362,6 +359,8 @@ int mdp_try_crop(struct v4l2_rect *r, const struct v4l2_selection *s,
 int mdp_check_scaling_ratio(const struct v4l2_rect *crop,
 			    const struct v4l2_rect *compose, s32 rotation,
 	const struct mdp_limit *limit);
+void mdp_set_scenario(struct img_ipi_frameparam *param,
+			struct mdp_frame *frame);
 void mdp_set_src_config(struct img_input *in,
 			struct mdp_frame *frame, struct vb2_buffer *vb);
 void mdp_set_dst_config(struct img_output *out,
diff --git a/drivers/media/platform/mtk-mdp3/mtk-mdp3-vpu.c b/drivers/media/platform/mtk-mdp3/mtk-mdp3-vpu.c
index 3009066cd779397e8e9cb44520635415efe339fb..783e6a08d5fa8ac8d246481eeb7a79733c251d77 100644
--- a/drivers/media/platform/mtk-mdp3/mtk-mdp3-vpu.c
+++ b/drivers/media/platform/mtk-mdp3/mtk-mdp3-vpu.c
@@ -10,7 +10,7 @@
 #include "mtk-mdp3-core.h"
 
 #define MDP_VPU_MESSAGE_TIMEOUT 500U
-#define vpu_alloc_size		0x600000
+#define vpu_alloc_size         0x7F8000
 
 static inline struct mdp_dev *vpu_to_mdp(struct mdp_vpu_dev *vpu)
 {
@@ -132,14 +132,15 @@ static int mdp_vpu_sendmsg(struct mdp_vpu_dev *vpu, enum scp_ipi_id id,
 		dev_dbg(&mdp->pdev->dev, "vpu scp is NULL");
 		return -EINVAL;
 	}
+
 	ret = scp_ipi_send(vpu->scp, id, buf, len, 2000);
 
 	if (ret) {
 		dev_err(&mdp->pdev->dev, "scp_ipi_send failed %d\n", ret);
 		return -EPERM;
 	}
-	ret = wait_for_completion_timeout(&vpu->ipi_acked,
-				msecs_to_jiffies(MDP_VPU_MESSAGE_TIMEOUT));
+	ret = wait_for_completion_timeout(
+		&vpu->ipi_acked, msecs_to_jiffies(MDP_VPU_MESSAGE_TIMEOUT));
 	if (!ret)
 		ret = -ETIME;
 	else if (vpu->status)
@@ -307,6 +308,7 @@ int mdp_vpu_process(struct mdp_vpu_ctx *ctx, struct img_ipi_frameparam *param)
 	memcpy((void *)ctx->vpu_dev->work, param, sizeof(*param));
 	addr.pa = ctx->vpu_dev->work_addr;
 	addr.va = (phys_addr_t)ctx->vpu_dev->work;
+
 	return mdp_vpu_sendmsg(ctx->vpu_dev, SCP_IPI_MDP_FRAME,
 		&addr, sizeof(addr));
 }
diff --git a/drivers/media/platform/mtk-mdp3/mtk-mdp3-vpu.h b/drivers/media/platform/mtk-mdp3/mtk-mdp3-vpu.h
index 4be8f861a93eddc834ddc1c853055c74ffaeb5d9..442cc02334d323700803f43c5161a3dd72321974 100644
--- a/drivers/media/platform/mtk-mdp3/mtk-mdp3-vpu.h
+++ b/drivers/media/platform/mtk-mdp3/mtk-mdp3-vpu.h
@@ -39,6 +39,7 @@ struct mdp_ipi_deinit_msg {
 
 enum mdp_config_id {
 	MDP_DEV_M2M = 0,
+	MDP_DEV_M2M_2ND = 1,
 	MDP_CONFIG_POOL_SIZE	/* ALWAYS keep at the end */
 };
 
diff --git a/drivers/media/platform/mtk-mdp3/vppsys0_config.h b/drivers/media/platform/mtk-mdp3/vppsys0_config.h
new file mode 100644
index 0000000000000000000000000000000000000000..ddeef2b2c2a04514620f5e00f18bedd77257d7f5
--- /dev/null
+++ b/drivers/media/platform/mtk-mdp3/vppsys0_config.h
@@ -0,0 +1,145 @@
+#ifndef __VPPSYS0_CONFIG_H__
+#define __VPPSYS0_CONFIG_H__
+
+#include "mmsys_reg_base.h"
+
+#define VPPSYS0_INTEN                       (0x000)
+#define VPPSYS0_INTSTA                      (0x004)
+#define VPP1_APB_TX_CON                     (0x008)
+#define IMG_APB_TX_CON                      (0x00c)
+#define CAM_APB_TX_CON                      (0x010)
+#define WARP_APB_TX_CON                     (0x014)
+#define CCU_APB_TX_CON                      (0x018)
+#define VPPSYS0_MISC                        (0x01c)
+#define VPPSYS0_CG0                         (0x020)
+#define VPPSYS0_CG_SET0                     (0x024)
+#define VPPSYS0_CG_CLR0                     (0x028)
+#define VPPSYS0_CG1                         (0x02c)
+#define VPPSYS0_CG_SET1                     (0x030)
+#define VPPSYS0_CG_CLR1                     (0x034)
+#define VPPSYS0_CG2                         (0x038)
+#define VPPSYS0_CG_SET2                     (0x03c)
+#define VPPSYS0_CG_CLR2                     (0x040)
+#define VPPSYS0_CG3                         (0x044)
+#define VPPSYS0_CG_SET3                     (0x048)
+#define VPPSYS0_CG_CLR3                     (0x04c)
+#define VPPSYS0_HW_DCM_1ST_DIS0            	(0x050)
+#define VPPSYS0_HW_DCM_1ST_DIS_SET0         (0x054)
+#define VPPSYS0_HW_DCM_1ST_DIS_CLR0         (0x058)
+#define VPPSYS0_HW_DCM_1ST_DIS1             (0x05c)
+#define VPPSYS0_HW_DCM_1ST_DIS_SET1         (0x060)
+#define VPPSYS0_HW_DCM_1ST_DIS_CLR1         (0x064)
+#define VPPSYS0_HW_DCM_1ST_DIS2             (0x068)
+#define VPPSYS0_HW_DCM_1ST_DIS_SET2         (0x06c)
+#define VPPSYS0_HW_DCM_1ST_DIS_CLR2         (0x070)
+#define VPPSYS0_HW_DCM_1ST_DIS3             (0x074)
+#define VPPSYS0_HW_DCM_1ST_DIS_SET3         (0x078)
+#define VPPSYS0_HW_DCM_1ST_DIS_CLR3         (0x07c)
+#define VPPSYS0_HW_DCM_2ND_DIS0             (0x080)
+#define VPPSYS0_HW_DCM_2ND_DIS_SET0         (0x084)
+#define VPPSYS0_HW_DCM_2ND_DIS_CLR0         (0x088)
+#define VPPSYS0_HW_DCM_2ND_DIS1             (0x08c)
+#define VPPSYS0_HW_DCM_2ND_DIS_SET1         (0x090)
+#define VPPSYS0_HW_DCM_2ND_DIS_CLR1         (0x094)
+#define VPPSYS0_HW_DCM_2ND_DIS2             (0x098)
+#define VPPSYS0_HW_DCM_2ND_DIS_SET2         (0x09c)
+#define VPPSYS0_HW_DCM_2ND_DIS_CLR2         (0x0a0)
+#define VPPSYS0_HW_DCM_2ND_DIS3             (0x0a4)
+#define VPPSYS0_HW_DCM_2ND_DIS_SET3         (0x0a8)
+#define VPPSYS0_HW_DCM_2ND_DIS_CLR3         (0x0ac)
+#define VPPSYS0_DUMMY0                      (0x0b0)
+#define VPPSYS0_DUMMY1                      (0x0b4)
+#define VPPSYS0_DUMMY2                      (0x0b8)
+#define VPPSYS0_DUMMY3                      (0x0bc)
+#define VPPSYS0_ASYNC_CFG0_WD               (0x0c0)
+#define VPPSYS0_ASYNC_CFG0_OUT_RD           (0x0c4)
+#define VPPSYS0_ASYNC_CFG0_IN_RD            (0x0c8)
+#define VPPSYS0_ASYNC_CFG1_WD               (0x0cc)
+#define VPPSYS0_ASYNC_CFG1_OUT_RD           (0x0d0)
+#define VPPSYS0_ASYNC_CFG1_IN_RD            (0x0d4)
+#define VPPSYS0_ASYNC_CFG2_WD               (0x0d8)
+#define VPPSYS0_ASYNC_CFG2_OUT_RD           (0x0dc)
+#define VPPSYS0_ASYNC_CFG2_IN_RD            (0x0e0)
+#define VPPSYS0_RELAY0_CFG_WD               (0x0e4)
+#define VPPSYS0_RELAY0_CNT_RD               (0x0e8)
+#define VPPSYS0_RELAY1_CFG_WD               (0x0ec)
+#define VPPSYS0_RELAY1_CNT_RD               (0x0f0)
+#define VPPSYS0_RELAY2_CFG_WD               (0x0f4)
+#define VPPSYS0_RELAY2_CNT_RD               (0x0f8)
+#define VPPSYS0_RELAY3_CFG_WD               (0x0fc)
+#define VPPSYS0_RELAY3_CNT_RD               (0x100)
+#define VPPSYS0_DEBUG_OUT_SEL               (0x104)
+#define VPPSYS0_SMI_BIST                    (0x108)
+#define VPPSYS0_SPM_DRAM_ACCESS_CG_MASK0	(0x10c)
+#define VPPSYS0_SPM_DRAM_ACCESS_CG_MASK1	(0x110)
+#define VPPSYS0_SPM_DRAM_ACCESS_CG_MASK2	(0x114)
+#define VPPSYS0_SPM_DRAM_ACCESS_CG_MASK3	(0x118)
+#define VPPSYS0_SPM_MAIN_PLL_CG_MASK0      	(0x11c)
+#define VPPSYS0_SPM_MAIN_PLL_CG_MASK1       (0x120)
+#define VPPSYS0_SPM_MAIN_PLL_CG_MASK2       (0x124)
+#define VPPSYS0_SPM_MAIN_PLL_CG_MASK3       (0x128)
+#define SMI_LARB4_GREQ                      (0x12c)
+#define VPPSYS0_FAKE_ENG_EN                	(0x130)
+#define VPPSYS0_FAKE_ENG_RST                (0x134)
+#define VPPSYS0_FAKE_ENG_CON0               (0x138)
+#define VPPSYS0_FAKE_ENG_CON1               (0x13c)
+#define VPPSYS0_FAKE_ENG_RD_ADDR            (0x140)
+#define VPPSYS0_FAKE_ENG_WR_ADDR           	(0x144)
+#define VPPSYS0_FAKE_ENG_STATE             	(0x148)
+#define VPPSYS0_BUF_UNDERRUN              	(0x14c)
+#define VPPSYS0_BUF_UNDERRUN_ID0        	(0x150)
+#define VPPSYS0_BUF_UNDERRUN_ID1        	(0x154)
+#define VPPSYS0_BUF_UNDERRUN_ID2        	(0x158)
+#define VPPSYS0_BUF_UNDERRUN_ID3        	(0x15c)
+#define VPPSYS0_PWR_METER_CTL0              (0x160)
+#define VPPSYS0_PWR_METER_CTL1             	(0x164)
+#define VPPSYS0_SLPPROT_AXI_IDLE_ASYNC_STA	(0x168)
+#define VPPSYS0_IN_AXI_IDLE_ASYNC_STA      	(0x16c)
+#define VPPSYS0_DL_VALID0                	(0x170)
+#define VPPSYS0_DL_READY0                	(0x174)
+#define VPPSYS0_DL_VALID1                	(0x178)
+#define VPPSYS0_DL_READY1                	(0x17c)
+#define VPPSYS0_TX_BIST_STA                	(0x180)
+#define VPPSYS0_MOUT_MASK                	(0x184)
+#define VPPSYS0_DELSEL0                    	(0x188)
+#define VPPSYS0_DELSEL1                 	(0x18c)
+#define VPPSYS0_DELSEL2                 	(0x190)
+#define VPPSYS0_DELSEL3                 	(0x194)
+#define VPPSYS0_DELSEL4                 	(0x198)
+#define VPPSYS0_DELSEL5                 	(0x19c)
+#define VPPSYS0_DELSEL6                 	(0x1a0)
+#define VPPSYS0_DELSEL7                 	(0x1a4)
+#define VPPSYS0_DELSEL8                 	(0x1a8)
+#define VPPSYS0_DELSEL9                 	(0x1ac)
+#define VPPSYS0_USE_DEFAULT_DELSEL      	(0x1b0)
+#define VPPSYS0_PRE_FUSE_01             	(0x1c0)
+#define VPPSYS0_PRE_FUSE_23             	(0x1c4)
+#define VPPSYS0_PRE_FUSE_45             	(0x1c8)
+#define VPPSYS0_PRE_FUSE_67             	(0x1cc)
+#define VPPSYS0_PRE_FUSE_89             	(0x1d0)
+#define VPPSYS0_MBIST_CTRL                	(0x1d4)
+#define VPPSYS0_SW0_RST_B                   (0x1d8)
+#define VPPSYS0_SW1_RST_B                   (0x1dc)
+#define VPPSYS0_SW2_RST_B                   (0x1e0)
+#define VPPSYS0_SW3_RST_B                   (0x1e4)
+#define VPPSYS0_SW4_RST_B                   (0x1e8)
+#define VPPSYS0_MOUT_RST                    (0xf00)
+#define VPPSYS0_PQ_SEL_IN                   (0xf04)
+#define VPPSYS0_VPP1_SEL_IN                 (0xf08)
+#define VPPSYS0_HDR_SEL_IN                  (0xf0c)
+#define VPPSYS0_TCC_SEL_IN                  (0xf10)
+#define VPPSYS0_WROT_SEL_IN                 (0xf14)
+#define VPPSYS0_AAL_SEL_IN                  (0xf18)
+#define VPPSYS0_MDP_RDMA_SOUT_SEL_IN    	(0xf1c)
+#define VPPSYS0_WARP0_SOUT_SEL_IN       	(0xf20)
+#define VPPSYS0_WARP1_SOUT_SEL_IN       	(0xf24)
+#define VPPSYS0_PQ_SOUT_SEL_IN          	(0xf28)
+#define VPPSYS0_PADDING_SOUT_SEL_IN         (0xf2c)
+#define VPPSYS0_TCC_SOUT_SEL_IN          	(0xf30)
+#define VPPSYS0_VPP1_IN_SOUT_SEL_IN         (0xf34)
+#define VPPSYS0_STITCH_MOUT_EN          	(0xf38)
+#define VPPSYS0_WARP0_MOUT_EN               (0xf3c)
+#define VPPSYS0_WARP1_MOUT_EN               (0xf40)
+#define VPPSYS0_FG_MOUT_EN                  (0xf44)
+
+#endif  // __VPPSYS0_CONFIG_H__
diff --git a/drivers/media/platform/mtk-mdp3/vppsys1_config.h b/drivers/media/platform/mtk-mdp3/vppsys1_config.h
new file mode 100644
index 0000000000000000000000000000000000000000..3a724ff0e58927175ebbaac7a98126ca8d3bce4b
--- /dev/null
+++ b/drivers/media/platform/mtk-mdp3/vppsys1_config.h
@@ -0,0 +1,237 @@
+#ifndef __VPPSYS1_CONFIG_H__
+#define __VPPSYS1_CONFIG_H__
+
+#include "mmsys_reg_base.h"
+
+#define VPPSYS1_INTEN               (0x000)
+#define VPPSYS1_INTSTA              (0x004)
+#define VPPSYS1_MISC                (0x0f0)
+#define VPPSYS1_MODULE_DBG          (0x0f4)
+#define VPPSYS1_URGENT_CTL          (0x0f8)
+#define VPPSYS1_RPT                 (0x0fc)
+#define VPPSYS1_CG_CON0             (0x100)
+#define VPPSYS1_CG_SET0             (0x104)
+#define VPPSYS1_CG_CLR0             (0x108)
+#define VPPSYS1_CG_CON1             (0x110)
+#define VPPSYS1_CG_SET1             (0x114)
+#define VPPSYS1_CG_CLR1             (0x118)
+#define VPPSYS1_CG_CON2             (0x120)
+#define VPPSYS1_CG_SET2             (0x124)
+#define VPPSYS1_CG_CLR2             (0x128)
+#define VPPSYS1_CG_CON3             (0x130)
+#define VPPSYS1_CG_SET3             (0x134)
+#define VPPSYS1_CG_CLR3             (0x138)
+#define VPPSYS1_CG_CON4             (0x140)
+#define VPPSYS1_CG_SET4             (0x144)
+#define VPPSYS1_CG_CLR4             (0x148)
+#define VPPSYS1_HW_DCM_1ST_DIS0     (0x150)
+#define VPPSYS1_HW_DCM_1ST_DIS_SET0 (0x154)
+#define VPPSYS1_HW_DCM_1ST_DIS_CLR0 (0x158)
+#define VPPSYS1_HW_DCM_1ST_DIS1     (0x160)
+#define VPPSYS1_HW_DCM_1ST_DIS_SET1 (0x164)
+#define VPPSYS1_HW_DCM_1ST_DIS_CLR1 (0x168)
+#define VPPSYS1_HW_DCM_1ST_DIS2     (0x170)
+#define VPPSYS1_HW_DCM_1ST_DIS_SET2 (0x174)
+#define VPPSYS1_HW_DCM_1ST_DIS_CLR2 (0x178)
+#define VPPSYS1_HW_DCM_1ST_DIS3     (0x180)
+#define VPPSYS1_HW_DCM_1ST_DIS_SET3 (0x184)
+#define VPPSYS1_HW_DCM_1ST_DIS_CLR3 (0x188)
+#define VPPSYS1_HW_DCM_1ST_DIS4     (0x190)
+#define VPPSYS1_HW_DCM_1ST_DIS_SET4 (0x194)
+#define VPPSYS1_HW_DCM_1ST_DIS_CLR4 (0x198)
+#define VPPSYS1_HW_DCM_2ND_DIS0     (0x1a0)
+#define VPPSYS1_HW_DCM_2ND_DIS_SET0 (0x1a4)
+#define VPPSYS1_HW_DCM_2ND_DIS_CLR0 (0x1a8)
+#define VPPSYS1_HW_DCM_2ND_DIS1     (0x1b0)
+#define VPPSYS1_HW_DCM_2ND_DIS_SET1 (0x1b4)
+#define VPPSYS1_HW_DCM_2ND_DIS_CLR1 (0x1b8)
+#define VPPSYS1_HW_DCM_2ND_DIS2     (0x1c0)
+#define VPPSYS1_HW_DCM_2ND_DIS_SET2 (0x1c4)
+#define VPPSYS1_HW_DCM_2ND_DIS_CLR2 (0x1c8)
+#define VPPSYS1_HW_DCM_2ND_DIS3     (0x1d0)
+#define VPPSYS1_HW_DCM_2ND_DIS_SET3 (0x1d4)
+#define VPPSYS1_HW_DCM_2ND_DIS_CLR3 (0x1d8)
+#define VPPSYS1_HW_DCM_2ND_DIS4     (0x1e0)
+#define VPPSYS1_HW_DCM_2ND_DIS_SET4 (0x1e4)
+#define VPPSYS1_HW_DCM_2ND_DIS_CLR4 (0x1e8)
+#define VPPSYS1_SW0_RST_B           (0x700)
+#define VPPSYS1_SW1_RST_B           (0x704)
+#define VPPSYS1_SW2_RST_B           (0x708)
+#define VPPSYS1_SW3_RST_B           (0x70c)
+#define VPPSYS1_SW4_RST_B           (0x710)
+#define VPP_FAKE_ENG0_EN            (0x200)
+#define VPP_FAKE_ENG0_RST           (0x204)
+#define VPP_FAKE_ENG0_CON0          (0x208)
+#define VPP_FAKE_ENG0_CON1          (0x20c)
+#define VPP_FAKE_ENG0_RD_ADDR       (0x210)
+#define VPP_FAKE_ENG0_WR_ADDR       (0x214)
+#define VPP_FAKE_ENG0_STATE         (0x218)
+#define VPP_FAKE_ENG1_EN            (0x220)
+#define VPP_FAKE_ENG1_RST           (0x224)
+#define VPP_FAKE_ENG1_CON0          (0x228)
+#define VPP_FAKE_ENG1_CON1          (0x22c)
+#define VPP_FAKE_ENG1_RD_ADDR       (0x230)
+#define VPP_FAKE_ENG1_WR_ADDR       (0x234)
+#define VPP_FAKE_ENG1_STATE         (0x238)
+#define VPPSYS1_APMCU_GALS_CTRL     (0x240)
+#define VPPSYS1_EXT_ULTRA_SEL       (0x250)
+#define VPPSYS1_DEBUG_OUT_SEL       (0x300)
+#define CFG_REG_VPP_AXI_ASIF_WD     (0x304)
+#define CFG_REG_VPP_AXI_ASIF_RD     (0x308)
+#define VPPSYS1_DUMMY0              (0x400)
+#define VPPSYS1_DUMMY1              (0x404)
+#define VPPSYS1_DUMMY2              (0x408)
+#define VPPSYS1_DUMMY3              (0x40c)
+#define VPPSYS1_MBIST_CON           (0x600)
+#define VPPSYS1_MBIST_DONE0         (0x604)
+#define VPPSYS1_MBIST_DONE1         (0x608)
+#define VPPSYS1_MBIST_HOLDB         (0x60c)
+#define VPPSYS1_MBIST_MODE0         (0x610)
+#define VPPSYS1_MBIST_MODE1         (0x614)
+#define VPPSYS1_MBIST_DIAG_SCANOUT0 (0x618)
+#define VPPSYS1_MBIST_DIAG_SCANOUT1 (0x61c)
+#define VPPSYS1_MBIST_FAIL0         (0x620)
+#define VPPSYS1_MBIST_FAIL1         (0x624)
+#define VPPSYS1_MBIST_FAIL2         (0x628)
+#define VPPSYS1_MBIST_FAIL3         (0x62c)
+#define VPPSYS1_MBIST_DEBUG         (0x630)
+#define VPPSYS1_MBIST_PRE_FUSE01    (0x638)
+#define VPPSYS1_MBIST_PRE_FUSE23    (0x63c)
+#define VPPSYS1_MBIST_PRE_FUSE45    (0x640)
+#define VPPSYS1_MBIST_PRE_FUSE67    (0x644)
+#define VPPSYS1_MBIST_HDEN0         (0x660)
+#define VPPSYS1_MBIST_HDEN1         (0x664)
+#define VPPSYS1_MBIST_HDEN2         (0x668)
+#define VPPSYS1_MBIST_HDEN3         (0x66c)
+#define VPPSYS1_MBIST_DREQ0         (0x670)
+#define VPPSYS1_MBIST_DREQ1         (0x674)
+#define VPPSYS1_MBIST_DREQ2         (0x678)
+#define VPPSYS1_MBIST_DREQ3         (0x67c)
+#define VPPSYS1_MBIST_DELSEL0       (0x680)
+#define VPPSYS1_MBIST_DELSEL1       (0x684)
+#define VPPSYS1_MBIST_DELSEL2       (0x688)
+#define VPPSYS1_MBIST_DELSEL3       (0x68c)
+#define VPPSYS1_MBIST_DELSEL4       (0x690)
+#define VPPSYS1_MBIST_DELSEL5       (0x694)
+#define VPPSYS1_MBIST_DELSEL6       (0x698)
+#define VPPSYS1_MBIST_DELSEL7       (0x69c)
+#define VPPSYS1_MBIST_DELSEL8       (0x6a0)
+#define VPPSYS1_MBIST_DELSEL9       (0x6b0)
+#define VPPSYS1_MBIST_DELSEL10      (0x6b4)
+#define VPPSYS1_MBIST_DELSEL11      (0x6b8)
+#define VPPSYS1_MBIST_DELSEL12      (0x6bc)
+#define VPPSYS1_MBIST_DELSEL13      (0x6c0)
+#define VPPSYS1_MBIST_DELSEL14      (0x6c4)
+#define VPPSYS1_MBIST_DELSEL15      (0x6c8)
+#define VPPSYS1_MBIST_DELSEL16      (0x720)
+#define VPPSYS1_MBIST_DELSEL17      (0x724)
+#define VPPSYS1_MBIST_DELSEL18      (0x728)
+#define VPPSYS1_MBIST_DELSEL19      (0x72c)
+#define VPPSYS1_MBIST_DELSEL20      (0x730)
+#define VPPSYS1_MBIST_DELSEL21      (0x734)
+#define VPPSYS1_MBIST_DELSEL22      (0x738)
+#define VPPSYS1_MBIST_DELSEL23      (0x73c)
+#define VPPSYS1_MBIST_DELSEL24      (0x740)
+#define VPPSYS1_MBIST_DELSEL25      (0x744)
+#define VPPSYS1_MBIST_DELSEL26      (0x748)
+#define VPPSYS1_MBIST_DELSEL27      (0x74c)
+#define VPPSYS1_MBIST_DELSEL28      (0x750)
+#define VPPSYS1_MBIST_DELSEL29      (0x754)
+#define VPPSYS1_MBIST_RP_RST_B      (0x6d0)
+#define VPPSYS1_MBIST_RP_FAIL0      (0x6e0)
+#define VPPSYS1_MBIST_RP_FAIL1      (0x6e4)
+#define VPPSYS1_MBIST_RP_FAIL2      (0x6e8)
+#define VPPSYS1_MBIST_RP_FAIL3      (0x6ec)
+#define VPPSYS1_MBIST_RP_OK0        (0x6f0)
+#define VPPSYS1_MBIST_RP_OK1        (0x6f4)
+#define VPPSYS1_MBIST_RP_OK2        (0x6f8)
+#define VPPSYS1_MBIST_RP_OK3        (0x6fc)
+#define VPPSYS1_AXI_BIST_EN         (0x804)
+#define VPPSYS1_AXI_BIST_STS        (0x808)
+#define VPPSYS1_SMI_LARB_GREQ       (0x8dc)
+#define VPPSYS1_HRT_WEIGHT_READ     (0x8f0)
+#define VPPSYS1_PWR_METER_CTL0      (0x900)
+#define VPPSYS1_PWR_METER_CTL1      (0x904)
+#define VPP0_DL_IRELAY_WR           (0x920)
+#define VPP0_DL_ORELAY_0_WR         (0x924)
+#define VDO0_DL_ORELAY_0_WR         (0x928)
+#define VDO0_DL_ORELAY_1_WR         (0x92c)
+#define VDO1_DL_ORELAY_0_WR         (0x930)
+#define VDO1_DL_ORELAY_1_WR         (0x934)
+#define VPP0_DL_IRELAY_RD           (0x938)
+#define VPP0_DL_ORELAY_0_RD         (0x93c)
+#define VDO0_DL_ORELAY_0_RD         (0x940)
+#define VDO0_DL_ORELAY_1_RD         (0x944)
+#define VDO1_DL_ORELAY_0_RD         (0x948)
+#define VDO1_DL_ORELAY_1_RD         (0x94c)
+#define VPP_DL_ASYNC_CFG_RD0        (0x950)
+#define VPP_DL_ASYNC_CFG_RD1        (0x954)
+#define VPPSYS1_BUF_UNDERRUN        (0xe00)
+#define VPPSYS1_BUF_UNDERRUN_ID0    (0xe04)
+#define VPPSYS1_BUF_UNDERRUN_ID1    (0xe08)
+#define VPPSYS1_BUF_UNDERRUN_ID2    (0xe0c)
+#define VPPSYS1_BUF_UNDERRUN_ID3    (0xe10)
+#define VPPSYS1_MOUT_RST            (0xf00)
+#define VPP_SPLIT_OUT0_SOUT_SEL     (0xf10)
+#define VPP_SPLIT_OUT1_SOUT_SEL     (0xf14)
+#define SVPP1_MDP_RDMA_SOUT_SEL     (0xf18)
+#define SVPP1_SRC_SEL_IN            (0xf1c)
+#define SVPP1_SRC_SEL_SOUT_SEL      (0xf20)
+#define SVPP1_HDR_SRC_SEL_IN        (0xf24)
+#define SVPP1_PATH_SOUT_SEL         (0xf28)
+#define SVPP1_WROT_SRC_SEL_IN       (0xf2c)
+#define SVPP1_TCC_SEL_IN            (0xf30)
+#define SVPP1_TCC_SOUT_SEL          (0xf34)
+#define SVPP2_SRC_SEL_IN            (0xf38)
+#define SVPP2_COLOR_SOUT_SEL        (0xf3c)
+#define SVPP2_WROT_SRC_SEL_IN       (0xf40)
+#define SVPP2_RSZ_MERGE_IN_SEL_IN   (0xf44)
+#define SVPP2_BUF_BF_RSZ_SWITCH     (0xf48)
+#define SVPP2_MDP_HDR_MOUT_EN       (0xf4c)
+#define SVPP2_SRC_SEL_MOUT_EN       (0xf50)
+#define SVPP1_MDP_AAL_SEL_IN        (0xf54)
+#define SVPP3_MDP_RDMA_SOUT_SEL     (0xf60)
+#define SVPP3_SRC_SEL_IN            (0xf64)
+#define SVPP3_COLOR_SOUT_SEL        (0xf68)
+#define SVPP3_WROT_SRC_SEL_IN       (0xf6c)
+#define SVPP3_RSZ_MERGE_IN_SEL_IN   (0xf70)
+#define SVPP3_BUF_BF_RSZ_SWITCH     (0xf74)
+#define SVPP3_MDP_HDR_MOUT_EN       (0xf78)
+#define SVPP3_SRC_SEL_MOUT_EN       (0xf7c)
+#define VPP0_DL1_SRC_SEL_IN         (0xf80)
+#define VPP0_SRC_SOUT_SEL           (0xf8c)
+#define SVPP2_MDP_RDMA_SOUT_SEL     (0xf90)
+#define DUMMY_SEL_REG_0             (0xfc0)
+#define DUMMY_SEL_REG_1             (0xfc4)
+#define DUMMY_SEL_REG_2             (0xfc8)
+#define VPPSYS1_MOUT_MASK0          (0xfd0)
+#define VPPSYS1_MOUT_MASK1          (0xfd4)
+#define VPPSYS1_MOUT_MASK2          (0xfd8)
+#define VPPSYS1_DL_VALID0           (0xfe0)
+#define VPPSYS1_DL_VALID1           (0xfe4)
+#define VPPSYS1_DL_VALID2           (0xfe8)
+#define VPPSYS1_DL_READY0           (0xff0)
+#define VPPSYS1_DL_READY1           (0xff4)
+#define VPPSYS1_DL_READY2           (0xff8)
+#define VPPSYS1_FUSE_0              (0x770)
+#define VPPSYS1_FUSE_1              (0x774)
+#define VPPSYS1_FUSE_2              (0x778)
+#define VPPSYS1_FUSE_3              (0x77c)
+#define VPPSYS1_FUSE_4              (0x780)
+#define VPPSYS1_FUSE_5              (0x784)
+#define VPPSYS1_FUSE_6              (0x788)
+#define VPPSYS1_FUSE_7              (0x78c)
+#define VPPSYS1_FUSE_8              (0x790)
+#define VPPSYS1_FUSE_9              (0x794)
+#define VPPSYS1_FUSE_10             (0x798)
+#define VPPSYS1_FUSE_11             (0x79c)
+#define VPPSYS1_FUSE_12             (0x7a0)
+#define VPPSYS1_FUSE_13             (0x7a4)
+#define VPPSYS1_FUSE_14             (0x7a8)
+#define VPPSYS1_FUSE_15             (0x7ac)
+#define VPPSYS1_FUSE_16             (0x7b0)
+#define VPPSYS1_FUSE_CTRL           (0x7b4)
+#define VPPSYS1_USE_DEFAULT_DELSEL  (0x6d4)
+#define VPPSYS1_VERSION             (0xffc)
+
+#endif  // __VPPSYS1_CONFIG_H__
diff --git a/drivers/media/platform/mtk-vcodec/Makefile b/drivers/media/platform/mtk-vcodec/Makefile
index ca8e9e7a9c4eedbb5d3eb010ebe97ca3798176f3..dec68023db04585a1a44f942f2586aa5fc25f996 100644
--- a/drivers/media/platform/mtk-vcodec/Makefile
+++ b/drivers/media/platform/mtk-vcodec/Makefile
@@ -6,15 +6,21 @@ obj-$(CONFIG_VIDEO_MEDIATEK_VCODEC) += mtk-vcodec-dec.o \
 
 mtk-vcodec-dec-y := vdec/vdec_h264_if.o \
 		vdec/vdec_vp8_if.o \
+		vdec/vdec_vp8_req_if.o \
 		vdec/vdec_vp9_if.o \
+		vdec/vdec_vp9_req_lat_if.o \
 		vdec/vdec_h264_req_if.o \
+		vdec/vdec_h264_req_common.o \
+		vdec/vdec_h264_req_lat_if.o \
 		mtk_vcodec_dec_drv.o \
 		vdec_drv_if.o \
 		vdec_vpu_if.o \
+		vdec_msg_queue.o \
 		mtk_vcodec_dec.o \
 		mtk_vcodec_dec_stateful.o \
 		mtk_vcodec_dec_stateless.o \
 		mtk_vcodec_dec_pm.o \
+		mtk_vcodec_dec_hw.o \
 
 mtk-vcodec-enc-y := venc/venc_vp8_if.o \
 		venc/venc_h264_if.o \
diff --git a/drivers/media/platform/mtk-vcodec/mtk_vcodec_dec.c b/drivers/media/platform/mtk-vcodec/mtk_vcodec_dec.c
index 6c8abbeaba9d3c6fb1f0a63d8bfb95d9094f391e..ed796eb145047fe2b303620b33f50936acfedf06 100644
--- a/drivers/media/platform/mtk-vcodec/mtk_vcodec_dec.c
+++ b/drivers/media/platform/mtk-vcodec/mtk_vcodec_dec.c
@@ -25,7 +25,7 @@ static const struct mtk_video_fmt *mtk_vdec_find_format(struct v4l2_format *f,
 	const struct mtk_video_fmt *fmt;
 	unsigned int k;
 
-	for (k = 0; k < dec_pdata->num_formats; k++) {
+	for (k = 0; k < *dec_pdata->num_formats; k++) {
 		fmt = &dec_pdata->vdec_formats[k];
 		if (fmt->fourcc == f->fmt.pix_mp.pixelformat)
 			return fmt;
@@ -34,6 +34,44 @@ static const struct mtk_video_fmt *mtk_vdec_find_format(struct v4l2_format *f,
 	return NULL;
 }
 
+static bool mtk_vdec_get_cap_fmt(struct mtk_vcodec_ctx *ctx, int format_index)
+{
+	const struct mtk_vcodec_dec_pdata *dec_pdata = ctx->dev->vdec_pdata;
+	const struct mtk_video_fmt *fmt;
+	struct mtk_q_data *q_data;
+	int num_frame_count = 0, i;
+	bool ret = true;
+
+	for (i = 0; i < *dec_pdata->num_formats; i++) {
+		if (dec_pdata->vdec_formats[i].type != MTK_FMT_FRAME)
+			continue;
+
+		num_frame_count++;
+	}
+
+	if (num_frame_count == 1)
+		return true;
+
+	fmt = &dec_pdata->vdec_formats[format_index];
+	q_data = &ctx->q_data[MTK_Q_DATA_SRC];
+	switch(q_data->fmt->fourcc) {
+	case V4L2_PIX_FMT_VP8_FRAME:
+		if (fmt->fourcc == V4L2_PIX_FMT_MM21)
+			ret = true;
+		break;
+	case V4L2_PIX_FMT_H264_SLICE:
+	case V4L2_PIX_FMT_VP9_FRAME:
+		if (fmt->fourcc == V4L2_PIX_FMT_MM21)
+			ret = false;
+		break;
+	default:
+		ret = true;
+		break;
+	};
+
+	return ret;
+}
+
 static struct mtk_q_data *mtk_vdec_get_q_data(struct mtk_vcodec_ctx *ctx,
 					      enum v4l2_buf_type type)
 {
@@ -103,12 +141,12 @@ static int vidioc_decoder_cmd(struct file *file, void *priv,
 
 void mtk_vdec_unlock(struct mtk_vcodec_ctx *ctx)
 {
-	mutex_unlock(&ctx->dev->dec_mutex);
+	mutex_unlock(&ctx->dev->dec_mutex[ctx->hw_id]);
 }
 
 void mtk_vdec_lock(struct mtk_vcodec_ctx *ctx)
 {
-	mutex_lock(&ctx->dev->dec_mutex);
+	mutex_lock(&ctx->dev->dec_mutex[ctx->hw_id]);
 }
 
 void mtk_vcodec_dec_release(struct mtk_vcodec_ctx *ctx)
@@ -150,13 +188,15 @@ void mtk_vcodec_dec_set_default_params(struct mtk_vcodec_ctx *ctx)
 	q_data->coded_height = DFT_CFG_HEIGHT;
 	q_data->fmt = ctx->dev->vdec_pdata->default_cap_fmt;
 	q_data->field = V4L2_FIELD_NONE;
+	ctx->max_width = MTK_VDEC_MAX_W;
+	ctx->max_height = MTK_VDEC_MAX_H;
 
 	v4l_bound_align_image(&q_data->coded_width,
 				MTK_VDEC_MIN_W,
-				MTK_VDEC_MAX_W, 4,
+				ctx->max_width, 4,
 				&q_data->coded_height,
 				MTK_VDEC_MIN_H,
-				MTK_VDEC_MAX_H, 5, 6);
+				ctx->max_height, 5, 6);
 
 	q_data->sizeimage[0] = q_data->coded_width * q_data->coded_height;
 	q_data->bytesperline[0] = q_data->coded_width;
@@ -215,8 +255,8 @@ static int vidioc_vdec_subscribe_evt(struct v4l2_fh *fh,
 	}
 }
 
-static int vidioc_try_fmt(struct v4l2_format *f,
-			  const struct mtk_video_fmt *fmt)
+static int vidioc_try_fmt(struct mtk_vcodec_ctx *ctx,
+	struct v4l2_format *f, const struct mtk_video_fmt *fmt)
 {
 	struct v4l2_pix_format_mplane *pix_fmt_mp = &f->fmt.pix_mp;
 	int i;
@@ -225,10 +265,10 @@ static int vidioc_try_fmt(struct v4l2_format *f,
 
 	pix_fmt_mp->width = clamp(pix_fmt_mp->width,
 				MTK_VDEC_MIN_W,
-				MTK_VDEC_MAX_W);
+				ctx->max_width);
 	pix_fmt_mp->height = clamp(pix_fmt_mp->height,
 				MTK_VDEC_MIN_H,
-				MTK_VDEC_MAX_H);
+				ctx->max_height);
 
 	if (f->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) {
 		pix_fmt_mp->num_planes = 1;
@@ -246,16 +286,16 @@ static int vidioc_try_fmt(struct v4l2_format *f,
 		tmp_h = pix_fmt_mp->height;
 		v4l_bound_align_image(&pix_fmt_mp->width,
 					MTK_VDEC_MIN_W,
-					MTK_VDEC_MAX_W, 6,
+					ctx->max_width, 6,
 					&pix_fmt_mp->height,
 					MTK_VDEC_MIN_H,
-					MTK_VDEC_MAX_H, 6, 9);
+					ctx->max_height, 6, 9);
 
 		if (pix_fmt_mp->width < tmp_w &&
-			(pix_fmt_mp->width + 64) <= MTK_VDEC_MAX_W)
+			(pix_fmt_mp->width + 64) <= ctx->max_width)
 			pix_fmt_mp->width += 64;
 		if (pix_fmt_mp->height < tmp_h &&
-			(pix_fmt_mp->height + 64) <= MTK_VDEC_MAX_H)
+			(pix_fmt_mp->height + 64) <= ctx->max_height)
 			pix_fmt_mp->height += 64;
 
 		mtk_v4l2_debug(0,
@@ -300,7 +340,7 @@ static int vidioc_try_fmt_vid_cap_mplane(struct file *file, void *priv,
 		fmt = mtk_vdec_find_format(f, dec_pdata);
 	}
 
-	return vidioc_try_fmt(f, fmt);
+	return vidioc_try_fmt(ctx, f, fmt);
 }
 
 static int vidioc_try_fmt_vid_out_mplane(struct file *file, void *priv,
@@ -323,7 +363,7 @@ static int vidioc_try_fmt_vid_out_mplane(struct file *file, void *priv,
 		return -EINVAL;
 	}
 
-	return vidioc_try_fmt(f, fmt);
+	return vidioc_try_fmt(ctx, f, fmt);
 }
 
 static int vidioc_vdec_g_selection(struct file *file, void *priv,
@@ -451,7 +491,7 @@ static int vidioc_vdec_s_fmt(struct file *file, void *priv,
 		return -EINVAL;
 
 	q_data->fmt = fmt;
-	vidioc_try_fmt(f, q_data->fmt);
+	vidioc_try_fmt(ctx, f, q_data->fmt);
 	if (f->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) {
 		q_data->sizeimage[0] = pix_mp->plane_fmt[0].sizeimage;
 		q_data->coded_width = pix_mp->width;
@@ -472,6 +512,8 @@ static int vidioc_vdec_s_fmt(struct file *file, void *priv,
 			}
 			ctx->state = MTK_STATE_INIT;
 		}
+	} else {
+		ctx->capture_fourcc = fmt->fourcc;
 	}
 
 	/*
@@ -482,11 +524,14 @@ static int vidioc_vdec_s_fmt(struct file *file, void *priv,
 		ctx->picinfo.pic_w = pix_mp->width;
 		ctx->picinfo.pic_h = pix_mp->height;
 
+		/*
+		 * If get pic info fail, need to use the default pic info params, or
+		 * v4l2-compliance will fail
+		 */
 		ret = vdec_if_get_param(ctx, GET_PARAM_PIC_INFO, &ctx->picinfo);
 		if (ret) {
 			mtk_v4l2_err("[%d]Error!! Get GET_PARAM_PICTURE_INFO Fail",
 				ctx->id);
-			return -EINVAL;
 		}
 
 		ctx->last_decoded_picinfo = ctx->picinfo;
@@ -530,7 +575,7 @@ static int vidioc_enum_framesizes(struct file *file, void *priv,
 	if (fsize->index != 0)
 		return -EINVAL;
 
-	for (i = 0; i < dec_pdata->num_framesizes; ++i) {
+	for (i = 0; i < *dec_pdata->num_framesizes; ++i) {
 		if (fsize->pixel_format != dec_pdata->vdec_framesizes[i].fourcc)
 			continue;
 
@@ -552,6 +597,9 @@ static int vidioc_enum_framesizes(struct file *file, void *priv,
 				fsize->stepwise.min_height,
 				fsize->stepwise.max_height,
 				fsize->stepwise.step_height);
+
+		ctx->max_width = fsize->stepwise.max_width;
+		ctx->max_height = fsize->stepwise.max_height;
 		return 0;
 	}
 
@@ -566,7 +614,7 @@ static int vidioc_enum_fmt(struct v4l2_fmtdesc *f, void *priv,
 	const struct mtk_video_fmt *fmt;
 	int i, j = 0;
 
-	for (i = 0; i < dec_pdata->num_formats; i++) {
+	for (i = 0; i < *dec_pdata->num_formats; i++) {
 		if (output_queue &&
 			(dec_pdata->vdec_formats[i].type != MTK_FMT_DEC))
 			continue;
@@ -574,12 +622,15 @@ static int vidioc_enum_fmt(struct v4l2_fmtdesc *f, void *priv,
 			(dec_pdata->vdec_formats[i].type != MTK_FMT_FRAME))
 			continue;
 
+		if (!output_queue && !mtk_vdec_get_cap_fmt(ctx, i))
+			continue;
+
 		if (j == f->index)
 			break;
 		++j;
 	}
 
-	if (i == dec_pdata->num_formats)
+	if (i == *dec_pdata->num_formats)
 		return -EINVAL;
 
 	fmt = &dec_pdata->vdec_formats[i];
diff --git a/drivers/media/platform/mtk-vcodec/mtk_vcodec_dec.h b/drivers/media/platform/mtk-vcodec/mtk_vcodec_dec.h
index bb0dfa9795b83321ff3f6d7cbb81887fc2a53281..a4a73d3d45ed7b5ec761860adcfe92e0e2372706 100644
--- a/drivers/media/platform/mtk-vcodec/mtk_vcodec_dec.h
+++ b/drivers/media/platform/mtk-vcodec/mtk_vcodec_dec.h
@@ -8,7 +8,10 @@
 #ifndef _MTK_VCODEC_DEC_H_
 #define _MTK_VCODEC_DEC_H_
 
+#include "mtk_vcodec_util.h"
+
 #include <media/videobuf2-core.h>
+#include <media/v4l2-ctrls.h>
 #include <media/v4l2-mem2mem.h>
 
 #define VCODEC_CAPABILITY_4K_DISABLED	0x10
@@ -67,6 +70,7 @@ extern const struct v4l2_ioctl_ops mtk_vdec_ioctl_ops;
 extern const struct v4l2_m2m_ops mtk_vdec_m2m_ops;
 extern const struct media_device_ops mtk_vcodec_media_ops;
 
+extern struct platform_driver mtk_vdec_comp_driver;
 
 /*
  * mtk_vdec_lock/mtk_vdec_unlock are for ctx instance to
diff --git a/drivers/media/platform/mtk-vcodec/mtk_vcodec_dec_drv.c b/drivers/media/platform/mtk-vcodec/mtk_vcodec_dec_drv.c
index 00f160ca0f129e0899df4317ef421619c6f6d7be..b7a6e0ed26b0284afb087235bab0127fff37a4b9 100644
--- a/drivers/media/platform/mtk-vcodec/mtk_vcodec_dec_drv.c
+++ b/drivers/media/platform/mtk-vcodec/mtk_vcodec_dec_drv.c
@@ -23,14 +23,58 @@
 #include "mtk_vcodec_util.h"
 #include "mtk_vcodec_fw.h"
 
-#define VDEC_HW_ACTIVE	0x10
-#define VDEC_IRQ_CFG	0x11
-#define VDEC_IRQ_CLR	0x10
-#define VDEC_IRQ_CFG_REG	0xa4
-
 module_param(mtk_v4l2_dbg_level, int, 0644);
 module_param(mtk_vcodec_dbg, bool, 0644);
 
+static struct of_device_id mtk_vdec_drv_ids[] = {
+	{
+		.compatible = "mediatek,mtk-vcodec-lat",
+		.data = (void *)MTK_VDEC_LAT0,
+	},
+	{
+		.compatible = "mediatek,mtk-vcodec-core",
+		.data = (void *)MTK_VDEC_CORE,
+	},
+	{
+		.compatible = "mediatek,mtk-vcodec-lat-soc",
+		.data = (void *)MTK_VDEC_LAT_SOC,
+	},
+	{
+		.compatible = "mediatek,mtk-vcodec-core1",
+		.data = (void *)MTK_VDEC_CORE1,
+	},
+	{},
+};
+
+static inline int mtk_vdec_compare_of(struct device *dev, void *data)
+{
+	return dev->of_node == data;
+}
+
+static inline void mtk_vdec_release_of(struct device *dev, void *data)
+{
+	of_node_put(data);
+}
+
+static inline int mtk_vdec_bind(struct device *dev)
+{
+	struct mtk_vcodec_dev *data = dev_get_drvdata(dev);
+
+	return component_bind_all(dev, data);
+}
+
+static inline void mtk_vdec_unbind(struct device *dev)
+{
+	struct mtk_vcodec_dev *data = dev_get_drvdata(dev);
+
+	component_unbind_all(dev, data);
+}
+
+static const struct component_master_ops mtk_vdec_ops = {
+	.bind = mtk_vdec_bind,
+	.unbind = mtk_vdec_unbind,
+};
+
 /* Wake up context wait_queue */
 static void wake_up_ctx(struct mtk_vcodec_ctx *ctx)
 {
@@ -38,6 +82,59 @@ static void wake_up_ctx(struct mtk_vcodec_ctx *ctx)
 	wake_up_interruptible(&ctx->queue);
 }
 
+static int mtk_vcodec_get_hw_count(struct mtk_vcodec_dev *dev)
+{
+	if (dev->vdec_pdata->hw_arch == MTK_VDEC_PURE_SINGLE_CORE)
+		return 1;
+	else if(dev->vdec_pdata->hw_arch == MTK_VDEC_LAT_SINGLE_CORE)
+		return 2;
+	else if(dev->vdec_pdata->hw_arch == MTK_VDEC_LAT_DUAL_CORE)
+		return 3;
+	else
+		return 0;
+}
+
+static struct component_match *mtk_vcodec_match_add(
+	struct mtk_vcodec_dev *vdec_dev)
+{
+	struct platform_device *pdev = vdec_dev->plat_dev;
+	struct component_match *match = NULL;
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(mtk_vdec_drv_ids); i++) {
+		struct device_node *comp_node;
+		enum mtk_vdec_hw_id comp_idx;
+		const struct of_device_id *of_id;
+
+		comp_node = of_find_compatible_node(NULL, NULL,
+			mtk_vdec_drv_ids[i].compatible);
+		if (!comp_node)
+			continue;
+
+		if (!of_device_is_available(comp_node)) {
+			of_node_put(comp_node);
+			dev_err(&pdev->dev, "Fail to get MMSYS node\n");
+			continue;
+		}
+
+		of_id = of_match_node(mtk_vdec_drv_ids, comp_node);
+		if (!of_id) {
+			dev_err(&pdev->dev, "Failed to get match node\n");
+			return ERR_PTR(-EINVAL);
+		}
+
+		comp_idx = (enum mtk_vdec_hw_id)of_id->data;
+		mtk_v4l2_debug(4, "Get component:hw_id(%d),vdec_dev(0x%p),comp_node(0x%p)\n",
+			comp_idx, vdec_dev, comp_node);
+		vdec_dev->component_node[comp_idx] = comp_node;
+
+		component_match_add_release(&pdev->dev, &match, mtk_vdec_release_of,
+			mtk_vdec_compare_of, comp_node);
+	}
+
+	return match;
+}
+
 static irqreturn_t mtk_vcodec_dec_irq_handler(int irq, void *priv)
 {
 	struct mtk_vcodec_dev *dev = priv;
@@ -47,7 +144,7 @@ static irqreturn_t mtk_vcodec_dec_irq_handler(int irq, void *priv)
 	void __iomem *vdec_misc_addr = dev->reg_base[VDEC_MISC] +
 					VDEC_IRQ_CFG_REG;
 
-	ctx = mtk_vcodec_get_curr_ctx(dev);
+	ctx = mtk_vcodec_get_curr_ctx(dev, MTK_VDEC_CORE);
 
 	/* check if HW active or not */
 	cg_status = readl(dev->reg_base[0]);
@@ -78,11 +175,92 @@ static irqreturn_t mtk_vcodec_dec_irq_handler(int irq, void *priv)
 	return IRQ_HANDLED;
 }
 
+static int mtk_vcodec_get_reg_bases(struct mtk_vcodec_dev *dev)
+{
+	struct platform_device *pdev = dev->plat_dev;
+	int reg_num, i, ret = 0;
+
+	/* Sizeof(u32) * 4 bytes for each register base. */
+	reg_num = of_property_count_elems_of_size(pdev->dev.of_node, "reg",
+		sizeof(u32) * 4);
+	if (!reg_num || reg_num >= NUM_MAX_VDEC_REG_BASE) {
+		dev_err(&pdev->dev, "Invalid register property size: %d\n", reg_num);
+		return -EINVAL;
+	}
+
+	for (i = 0; i < reg_num; i++) {
+		dev->reg_base[i] = devm_platform_ioremap_resource(pdev, i);
+		if (IS_ERR((__force void *)dev->reg_base[i])) {
+			ret = PTR_ERR((__force void *)dev->reg_base[i]);
+			break;
+		}
+		mtk_v4l2_debug(2, "reg[%d] base=%p", i, dev->reg_base[i]);
+	}
+
+	return ret;
+}
+
+static int mtk_vcodec_init_master(struct mtk_vcodec_dev *dev)
+{
+	struct platform_device *pdev = dev->plat_dev;
+	struct component_match *match;
+	int ret = 0;
+
+	match = mtk_vcodec_match_add(dev);
+	if (IS_ERR_OR_NULL(match))
+		return -EINVAL;
+
+	platform_set_drvdata(pdev, dev);
+	ret = component_master_add_with_match(&pdev->dev, &mtk_vdec_ops, match);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static int mtk_vcodec_init_dec_params(struct mtk_vcodec_dev *dev)
+{
+	struct platform_device *pdev = dev->plat_dev;
+	struct resource *res;
+	int ret = 0;
+
+	if (!dev->is_support_comp) {
+		res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+		if (res == NULL) {
+			dev_err(&pdev->dev, "failed to get irq resource");
+			return -ENOENT;
+		}
+
+		dev->dec_irq = platform_get_irq(dev->plat_dev, 0);
+		irq_set_status_flags(dev->dec_irq, IRQ_NOAUTOEN);
+		ret = devm_request_irq(&pdev->dev, dev->dec_irq,
+				mtk_vcodec_dec_irq_handler, 0, pdev->name, dev);
+		if (ret) {
+			dev_err(&pdev->dev, "failed to install dev->dec_irq %d (%d)",
+				dev->dec_irq,
+				ret);
+			return ret;
+		}
+
+		ret = mtk_vcodec_init_dec_pm(dev->plat_dev, &dev->pm);
+		if (ret < 0) {
+			dev_err(&pdev->dev, "failed to get mt vcodec clock source");
+			return ret;
+		}
+	}
+
+	ret = mtk_vcodec_get_reg_bases(dev);
+	if (ret && !dev->is_support_comp)
+		mtk_vcodec_release_dec_pm(&dev->pm);
+
+	return ret;
+}
+
 static int fops_vcodec_open(struct file *file)
 {
 	struct mtk_vcodec_dev *dev = video_drvdata(file);
 	struct mtk_vcodec_ctx *ctx = NULL;
-	int ret = 0;
+	int ret = 0, i, hw_count;
 	struct vb2_queue *src_vq;
 
 	ctx = kzalloc(sizeof(*ctx), GFP_KERNEL);
@@ -96,7 +274,19 @@ static int fops_vcodec_open(struct file *file)
 	v4l2_fh_add(&ctx->fh);
 	INIT_LIST_HEAD(&ctx->list);
 	ctx->dev = dev;
-	init_waitqueue_head(&ctx->queue);
+
+	if (ctx->dev->is_support_comp) {
+		hw_count = mtk_vcodec_get_hw_count(dev);
+		if (!hw_count) {
+			ret = -EINVAL;
+			goto err_init_queue;
+		}
+		for (i = 0; i < hw_count; i++)
+			init_waitqueue_head(&ctx->core_queue[i]);
+	} else {
+		init_waitqueue_head(&ctx->queue);
+	}
+
 	mutex_init(&ctx->lock);
 
 	ctx->type = MTK_INST_DECODER;
@@ -119,9 +309,6 @@ static int fops_vcodec_open(struct file *file)
 	mtk_vcodec_dec_set_default_params(ctx);
 
 	if (v4l2_fh_is_singular(&ctx->fh)) {
-		ret = mtk_vcodec_dec_pw_on(&dev->pm);
-		if (ret < 0)
-			goto err_load_fw;
 		/*
 		 * Does nothing if firmware was already loaded.
 		 */
@@ -153,6 +340,7 @@ static int fops_vcodec_open(struct file *file)
 err_m2m_ctx_init:
 	v4l2_ctrl_handler_free(&ctx->ctrl_hdl);
 err_ctrls_setup:
+err_init_queue:
 	v4l2_fh_del(&ctx->fh);
 	v4l2_fh_exit(&ctx->fh);
 	kfree(ctx);
@@ -178,8 +366,6 @@ static int fops_vcodec_release(struct file *file)
 	v4l2_m2m_ctx_release(ctx->m2m_ctx);
 	mtk_vcodec_dec_release(ctx);
 
-	if (v4l2_fh_is_singular(&ctx->fh))
-		mtk_vcodec_dec_pw_off(&dev->pm);
 	v4l2_fh_del(&ctx->fh);
 	v4l2_fh_exit(&ctx->fh);
 	v4l2_ctrl_handler_free(&ctx->ctrl_hdl);
@@ -203,7 +389,6 @@ static int mtk_vcodec_probe(struct platform_device *pdev)
 {
 	struct mtk_vcodec_dev *dev;
 	struct video_device *vfd_dec;
-	struct resource *res;
 	phandle rproc_phandle;
 	enum mtk_vcodec_fw_type fw_type;
 	int i, ret;
@@ -232,40 +417,31 @@ static int mtk_vcodec_probe(struct platform_device *pdev)
 	if (IS_ERR(dev->fw_handler))
 		return PTR_ERR(dev->fw_handler);
 
-	ret = mtk_vcodec_init_dec_pm(dev);
-	if (ret < 0) {
-		dev_err(&pdev->dev, "Failed to get mt vcodec clock source");
-		goto err_dec_pm;
-	}
+	if (!of_find_compatible_node(NULL, NULL, "mediatek,mtk-vcodec-core"))
+		dev->is_support_comp = false;
+	else
+		dev->is_support_comp = true;
 
-	for (i = 0; i < NUM_MAX_VDEC_REG_BASE; i++) {
-		dev->reg_base[i] = devm_platform_ioremap_resource(pdev, i);
-		if (IS_ERR((__force void *)dev->reg_base[i])) {
-			ret = PTR_ERR((__force void *)dev->reg_base[i]);
-			goto err_res;
-		}
-		mtk_v4l2_debug(2, "reg[%d] base=%p", i, dev->reg_base[i]);
-	}
-
-	res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
-	if (res == NULL) {
-		dev_err(&pdev->dev, "failed to get irq resource");
-		ret = -ENOENT;
+	if (mtk_vcodec_init_dec_params(dev)) {
+		dev_err(&pdev->dev, "Failed to init pm and registers");
+		ret = -EINVAL;
 		goto err_res;
 	}
 
-	dev->dec_irq = platform_get_irq(pdev, 0);
-	irq_set_status_flags(dev->dec_irq, IRQ_NOAUTOEN);
-	ret = devm_request_irq(&pdev->dev, dev->dec_irq,
-			mtk_vcodec_dec_irq_handler, 0, pdev->name, dev);
-	if (ret) {
-		dev_err(&pdev->dev, "Failed to install dev->dec_irq %d (%d)",
-			dev->dec_irq,
-			ret);
-		goto err_res;
+	if (VDEC_LAT_ARCH(dev->vdec_pdata->hw_arch)) {
+		init_waitqueue_head(&dev->core_read);
+		INIT_LIST_HEAD(&dev->core_queue);
+		spin_lock_init(&dev->core_lock);
+		dev->kthread_core = kthread_run(vdec_msg_queue_core_thead, dev,
+			"mtk-%s", "core");
+		dev->num_core = 0;
 	}
 
-	mutex_init(&dev->dec_mutex);
+	if (of_get_property(pdev->dev.of_node, "dma-ranges", NULL))
+		dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(34));
+
+	for (i = 0; i < MTK_VDEC_HW_MAX; i++)
+		mutex_init(&dev->dec_mutex[i]);
 	mutex_init(&dev->dev_mutex);
 	spin_lock_init(&dev->irqlock);
 
@@ -299,7 +475,6 @@ static int mtk_vcodec_probe(struct platform_device *pdev)
 		MTK_VCODEC_DEC_NAME);
 	video_set_drvdata(vfd_dec, dev);
 	dev->vfd_dec = vfd_dec;
-	platform_set_drvdata(pdev, dev);
 
 	dev->m2m_dev_dec = v4l2_m2m_init(&mtk_vdec_m2m_ops);
 	if (IS_ERR((__force void *)dev->m2m_dev_dec)) {
@@ -351,8 +526,17 @@ static int mtk_vcodec_probe(struct platform_device *pdev)
 	mtk_v4l2_debug(0, "decoder registered as /dev/video%d",
 		vfd_dec->num);
 
-	return 0;
+	if(dev->is_support_comp) {
+		ret = mtk_vcodec_init_master(dev);
+		if (ret < 0)
+			goto err_component_match;
+	} else {
+		platform_set_drvdata(pdev, dev);
+	}
 
+	return 0;
+err_component_match:
+	video_unregister_device(vfd_dec);
 err_dec_reg:
 	if (dev->vdec_pdata->uses_stateless_api)
 		media_device_unregister(&dev->mdev_dec);
@@ -368,14 +552,15 @@ static int mtk_vcodec_probe(struct platform_device *pdev)
 err_dec_alloc:
 	v4l2_device_unregister(&dev->v4l2_dev);
 err_res:
-	mtk_vcodec_release_dec_pm(dev);
-err_dec_pm:
 	mtk_vcodec_fw_release(dev->fw_handler);
+
 	return ret;
 }
 
 extern const struct mtk_vcodec_dec_pdata mtk_vdec_8173_pdata;
 extern const struct mtk_vcodec_dec_pdata mtk_vdec_8183_pdata;
+extern const struct mtk_vcodec_dec_pdata mtk_lat_sig_core_pdata;
+extern const struct mtk_vcodec_dec_pdata mtk_lat_dual_core_pdata;
 
 static const struct of_device_id mtk_vcodec_match[] = {
 	{
@@ -386,6 +571,14 @@ static const struct of_device_id mtk_vcodec_match[] = {
 		.compatible = "mediatek,mt8183-vcodec-dec",
 		.data = &mtk_vdec_8183_pdata,
 	},
+	{
+		.compatible = "mediatek,mt8192-vcodec-dec",
+		.data = &mtk_lat_sig_core_pdata,
+	},
+	{
+		.compatible = "mediatek,mt8195-vcodec-dec",
+		.data = &mtk_lat_dual_core_pdata,
+	},
 	{},
 };
 
@@ -411,7 +604,7 @@ static int mtk_vcodec_dec_remove(struct platform_device *pdev)
 		video_unregister_device(dev->vfd_dec);
 
 	v4l2_device_unregister(&dev->v4l2_dev);
-	mtk_vcodec_release_dec_pm(dev);
+	mtk_vcodec_release_dec_pm(&dev->pm);
 	mtk_vcodec_fw_release(dev->fw_handler);
 	return 0;
 }
@@ -425,7 +618,25 @@ static struct platform_driver mtk_vcodec_dec_driver = {
 	},
 };
 
-module_platform_driver(mtk_vcodec_dec_driver);
+static struct platform_driver * const mtk_vdec_drivers[] = {
+	&mtk_vdec_comp_driver,
+	&mtk_vcodec_dec_driver,
+};
+
+static int __init mtk_vdec_init(void)
+{
+	return platform_register_drivers(mtk_vdec_drivers,
+					 ARRAY_SIZE(mtk_vdec_drivers));
+}
+
+static void __exit mtk_vdec_exit(void)
+{
+	platform_unregister_drivers(mtk_vdec_drivers,
+				    ARRAY_SIZE(mtk_vdec_drivers));
+}
+
+module_init(mtk_vdec_init);
+module_exit(mtk_vdec_exit);
 
 MODULE_LICENSE("GPL v2");
 MODULE_DESCRIPTION("Mediatek video codec V4L2 decoder driver");
diff --git a/drivers/media/platform/mtk-vcodec/mtk_vcodec_dec_hw.c b/drivers/media/platform/mtk-vcodec/mtk_vcodec_dec_hw.c
new file mode 100644
index 0000000000000000000000000000000000000000..8d126c29e5576388aaf7e3c3187562099f4b5878
--- /dev/null
+++ b/drivers/media/platform/mtk-vcodec/mtk_vcodec_dec_hw.c
@@ -0,0 +1,200 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2021 MediaTek Inc.
+ * Author: Yunfei Dong <yunfei.dong@mediatek.com>
+ */
+
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/slab.h>
+
+#include "mtk_vcodec_drv.h"
+#include "mtk_vcodec_dec.h"
+#include "mtk_vcodec_dec_hw.h"
+#include "mtk_vcodec_dec_pm.h"
+#include "mtk_vcodec_intr.h"
+#include "mtk_vcodec_util.h"
+
+static int mtk_vdec_comp_bind(struct device *dev, struct device *master,
+	void *data)
+{
+	struct mtk_vdec_comp_dev *comp_dev = dev_get_drvdata(dev);
+	struct mtk_vcodec_dev *master_dev = data;
+	int i;
+
+	for (i = 0; i < MTK_VDEC_HW_MAX; i++) {
+		if (dev->of_node != master_dev->component_node[i])
+			continue;
+
+		master_dev->comp_dev[i] = comp_dev;
+		comp_dev->comp_idx = i;
+		comp_dev->master_dev = master_dev;
+		break;
+	}
+
+	if (i == MTK_VDEC_HW_MAX) {
+		dev_err(dev, "Failed to get component node\n");
+		return -EINVAL;
+	}
+
+	comp_dev->reg_base[VDEC_COMP_SYS] =
+		master_dev->reg_base[VDEC_COMP_SYS];
+	set_bit(comp_dev->comp_idx, master_dev->hardware_bitmap);
+
+	return 0;
+}
+
+static void mtk_vdec_comp_unbind(struct device *dev, struct device *master,
+	void *data)
+{
+	struct mtk_vdec_comp_dev *comp_dev = dev_get_drvdata(dev);
+
+	comp_dev->reg_base[VDEC_COMP_SYS] = NULL;
+}
+
+static const struct component_ops mtk_vdec_hw_component_ops = {
+	.bind = mtk_vdec_comp_bind,
+	.unbind = mtk_vdec_comp_unbind,
+};
+
+/* Wake up core context wait_queue */
+static void mtk_vdec_comp_wake_up_ctx(struct mtk_vcodec_ctx *ctx,
+	unsigned int hw_id)
+{
+	ctx->int_core_cond[hw_id] = 1;
+	wake_up_interruptible(&ctx->core_queue[hw_id]);
+}
+
+static irqreturn_t mtk_vdec_comp_irq_handler(int irq, void *priv)
+{
+	struct mtk_vdec_comp_dev *dev = priv;
+	struct mtk_vcodec_ctx *ctx;
+	u32 cg_status;
+	unsigned int dec_done_status;
+	void __iomem *vdec_misc_addr = dev->reg_base[VDEC_COMP_MISC] +
+					VDEC_IRQ_CFG_REG;
+
+	ctx = mtk_vcodec_get_curr_ctx(dev->master_dev, dev->comp_idx);
+
+	/* check if HW active or not */
+	cg_status = readl(dev->reg_base[VDEC_COMP_SYS]);
+	if ((cg_status & VDEC_HW_ACTIVE) != 0) {
+		mtk_v4l2_err("vdec active is not 0x0 (0x%08x)",
+			cg_status);
+		return IRQ_HANDLED;
+	}
+
+	dec_done_status = readl(vdec_misc_addr);
+	if ((dec_done_status & MTK_VDEC_IRQ_STATUS_DEC_SUCCESS) !=
+		MTK_VDEC_IRQ_STATUS_DEC_SUCCESS)
+		return IRQ_HANDLED;
+
+	/* clear interrupt */
+	writel((readl(vdec_misc_addr) | VDEC_IRQ_CFG), vdec_misc_addr);
+	writel((readl(vdec_misc_addr) & ~VDEC_IRQ_CLR), vdec_misc_addr);
+
+	mtk_vdec_comp_wake_up_ctx(ctx, dev->comp_idx);
+
+	mtk_v4l2_debug(3, "wake up ctx %d, dec_done_status=%x",
+		ctx->id, dec_done_status);
+
+	return IRQ_HANDLED;
+}
+
+static int mtk_vdec_comp_init_irq(struct mtk_vdec_comp_dev *dev)
+{
+	struct platform_device *pdev = dev->plat_dev;
+	int ret;
+
+	dev->dec_irq = platform_get_irq(pdev, 0);
+	if (dev->dec_irq < 0) {
+		dev_err(&pdev->dev, "Failed to get irq resource");
+		return dev->dec_irq;
+	}
+
+	ret = devm_request_irq(&pdev->dev, dev->dec_irq,
+				mtk_vdec_comp_irq_handler, 0, pdev->name, dev);
+	if (ret) {
+		dev_err(&pdev->dev, "Failed to install dev->dec_irq %d (%d)",
+			dev->dec_irq, ret);
+		return -ENOENT;
+	}
+
+	disable_irq(dev->dec_irq);
+	return 0;
+}
+
+static int mtk_vdec_comp_probe(struct platform_device *pdev)
+{
+	struct mtk_vdec_comp_dev *dev;
+	int ret;
+
+	dev = devm_kzalloc(&pdev->dev, sizeof(*dev), GFP_KERNEL);
+	if (!dev)
+		return -ENOMEM;
+
+	dev->plat_dev = pdev;
+	spin_lock_init(&dev->irqlock);
+
+	ret = mtk_vcodec_init_dec_pm(dev->plat_dev, &dev->pm);
+	if (ret) {
+		dev_err(&pdev->dev, "Failed to get mt vcodec clock source");
+		return ret;
+	}
+
+	dev->reg_base[VDEC_COMP_MISC] =
+		devm_platform_ioremap_resource(pdev, 0);
+	if (IS_ERR((__force void *)dev->reg_base[VDEC_COMP_MISC])) {
+		ret = PTR_ERR((__force void *)dev->reg_base[VDEC_COMP_MISC]);
+		goto err;
+	}
+
+	if (of_get_property(pdev->dev.of_node, "dma-ranges", NULL))
+		dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(34));
+
+	ret = mtk_vdec_comp_init_irq(dev);
+	if (ret) {
+		dev_err(&pdev->dev, "Failed to register irq handler.\n");
+	}
+
+	platform_set_drvdata(pdev, dev);
+
+	ret = component_add(&pdev->dev, &mtk_vdec_hw_component_ops);
+	if (ret) {
+		dev_err(&pdev->dev, "Failed to add component: %d\n", ret);
+		goto err;
+	}
+
+	return 0;
+err:
+	mtk_vcodec_release_dec_pm(&dev->pm);
+	return ret;
+}
+
+static const struct of_device_id mtk_vdec_comp_ids[] = {
+	{
+		.compatible = "mediatek,mtk-vcodec-lat",
+	},
+	{
+		.compatible = "mediatek,mtk-vcodec-core",
+	},
+	{
+		.compatible = "mediatek,mtk-vcodec-lat-soc",
+	},
+	{
+		.compatible = "mediatek,mtk-vcodec-core1",
+	},
+	{},
+};
+MODULE_DEVICE_TABLE(of, mtk_vdec_comp_ids);
+
+struct platform_driver mtk_vdec_comp_driver = {
+	.probe	= mtk_vdec_comp_probe,
+	.driver	= {
+		.name	= "mtk-vdec-comp",
+		.of_match_table = mtk_vdec_comp_ids,
+	},
+};
diff --git a/drivers/media/platform/mtk-vcodec/mtk_vcodec_dec_hw.h b/drivers/media/platform/mtk-vcodec/mtk_vcodec_dec_hw.h
new file mode 100644
index 0000000000000000000000000000000000000000..7d19c4d461c5b847ddc8a563c7da55682170b9e2
--- /dev/null
+++ b/drivers/media/platform/mtk-vcodec/mtk_vcodec_dec_hw.h
@@ -0,0 +1,51 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2021 MediaTek Inc.
+ * Author: Yunfei Dong <yunfei.dong@mediatek.com>
+ */
+
+#ifndef _MTK_VCODEC_DEC_HW_H_
+#define _MTK_VCODEC_DEC_HW_H_
+
+#include <linux/component.h>
+#include <linux/io.h>
+#include <linux/platform_device.h>
+
+#include "mtk_vcodec_drv.h"
+
+/**
+ * enum mtk_comp_hw_reg_idx - component register base index
+ */
+enum mtk_comp_hw_reg_idx {
+	VDEC_COMP_SYS,
+	VDEC_COMP_MISC,
+	NUM_MAX_COMP_VCODEC_REG_BASE
+};
+
+/**
+ * struct mtk_vdec_comp_dev - component framwork driver data
+ * @plat_dev: platform device
+ * @master_dev: master device
+ * @irqlock: protect data access by irq handler and work thread
+ * @reg_base: Mapped address of MTK Vcodec registers.
+ *
+ * @curr_ctx: The context that is waiting for codec hardware
+ *
+ * @dec_irq: decoder irq resource
+ * @pm: power management control
+ * @comp_idx: component index
+ */
+struct mtk_vdec_comp_dev {
+	struct platform_device *plat_dev;
+	struct mtk_vcodec_dev *master_dev;
+	spinlock_t irqlock;
+	void __iomem *reg_base[NUM_MAX_COMP_VCODEC_REG_BASE];
+
+	struct mtk_vcodec_ctx *curr_ctx;
+
+	int dec_irq;
+	struct mtk_vcodec_pm pm;
+	int comp_idx;
+};
+
+#endif /* _MTK_VCODEC_DEC_HW_H_ */
diff --git a/drivers/media/platform/mtk-vcodec/mtk_vcodec_dec_pm.c b/drivers/media/platform/mtk-vcodec/mtk_vcodec_dec_pm.c
index d0bf9aa3b29d1dfa022539737c2d3d3d36cb3983..7ae5f0f2e34c7390272ab79e25415b5fb48c1afc 100644
--- a/drivers/media/platform/mtk-vcodec/mtk_vcodec_dec_pm.c
+++ b/drivers/media/platform/mtk-vcodec/mtk_vcodec_dec_pm.c
@@ -5,27 +5,23 @@
  */
 
 #include <linux/clk.h>
+#include <linux/interrupt.h>
 #include <linux/of_address.h>
 #include <linux/of_platform.h>
 #include <linux/pm_runtime.h>
 
+#include "mtk_vcodec_dec_hw.h"
 #include "mtk_vcodec_dec_pm.h"
 #include "mtk_vcodec_util.h"
 
-int mtk_vcodec_init_dec_pm(struct mtk_vcodec_dev *mtkdev)
+int mtk_vcodec_init_dec_pm(struct platform_device *pdev,
+	struct mtk_vcodec_pm *pm)
 {
-	struct platform_device *pdev;
-	struct mtk_vcodec_pm *pm;
 	struct mtk_vcodec_clk *dec_clk;
 	struct mtk_vcodec_clk_info *clk_info;
 	int i = 0, ret = 0;
 
-	pdev = mtkdev->plat_dev;
-	pm = &mtkdev->pm;
-	pm->mtkdev = mtkdev;
 	dec_clk = &pm->vdec_clk;
-
-	pdev = mtkdev->plat_dev;
 	pm->dev = &pdev->dev;
 
 	dec_clk->clk_num =
@@ -59,39 +55,83 @@ int mtk_vcodec_init_dec_pm(struct mtk_vcodec_dev *mtkdev)
 	}
 
 	pm_runtime_enable(&pdev->dev);
-	return 0;
+
+	return ret;
 }
 
-void mtk_vcodec_release_dec_pm(struct mtk_vcodec_dev *dev)
+void mtk_vcodec_release_dec_pm(struct mtk_vcodec_pm *pm)
 {
-	pm_runtime_disable(dev->pm.dev);
+	pm_runtime_disable(pm->dev);
 }
 
-int mtk_vcodec_dec_pw_on(struct mtk_vcodec_pm *pm)
+static void mtk_vcodec_dec_pw_on(struct mtk_vcodec_dev *vdec_dev, int comp_idx)
 {
+	struct mtk_vdec_comp_dev *comp_dev;
+	struct mtk_vcodec_pm *pm;
 	int ret;
 
+	if (vdec_dev->is_support_comp) {
+		if (!test_bit(comp_idx, vdec_dev->hardware_bitmap))
+			return;
+
+		comp_dev = mtk_vcodec_get_hw_dev(vdec_dev, comp_idx);
+		if (!comp_dev) {
+			mtk_v4l2_err("Failed to get hw dev\n");
+			return;
+		}
+		pm = &comp_dev->pm;
+	} else {
+		pm = &vdec_dev->pm;
+	}
 	ret = pm_runtime_resume_and_get(pm->dev);
-	if (ret)
+	if (ret < 0)
 		mtk_v4l2_err("pm_runtime_resume_and_get fail %d", ret);
-
-	return ret;
 }
 
-void mtk_vcodec_dec_pw_off(struct mtk_vcodec_pm *pm)
+static void mtk_vcodec_dec_pw_off(struct mtk_vcodec_dev *vdec_dev, int comp_idx)
 {
-	int ret;
+	struct mtk_vdec_comp_dev *comp_dev;
+	struct mtk_vcodec_pm *pm;
+
+	if (vdec_dev->is_support_comp) {
+		if (!test_bit(comp_idx, vdec_dev->hardware_bitmap))
+			return;
+
+		comp_dev = mtk_vcodec_get_hw_dev(vdec_dev, comp_idx);
+		if (!comp_dev) {
+			mtk_v4l2_err("Failed to get hw dev\n");
+			return;
+		}
+		pm = &comp_dev->pm;
+	} else {
+		pm = &vdec_dev->pm;
+	}
 
-	ret = pm_runtime_put_sync(pm->dev);
-	if (ret)
-		mtk_v4l2_err("pm_runtime_put_sync fail %d", ret);
+	pm_runtime_put_sync(pm->dev);
 }
 
-void mtk_vcodec_dec_clock_on(struct mtk_vcodec_pm *pm)
+static void mtk_vcodec_dec_clock_on(struct mtk_vcodec_dev *vdec_dev, int comp_idx)
 {
-	struct mtk_vcodec_clk *dec_clk = &pm->vdec_clk;
-	int ret, i = 0;
+	struct mtk_vdec_comp_dev *comp_dev;
+	struct mtk_vcodec_pm *pm;
+	struct mtk_vcodec_clk *dec_clk;
+	int ret, i;
+
+	if (vdec_dev->is_support_comp) {
+		if (!test_bit(comp_idx, vdec_dev->hardware_bitmap))
+			return;
 
+		comp_dev = mtk_vcodec_get_hw_dev(vdec_dev, comp_idx);
+		if (!comp_dev) {
+			mtk_v4l2_err("Failed to get hw dev\n");
+			return;
+		}
+		pm = &comp_dev->pm;
+	} else {
+		pm = &vdec_dev->pm;
+	}
+
+	dec_clk = &pm->vdec_clk;
 	for (i = 0; i < dec_clk->clk_num; i++) {
 		ret = clk_prepare_enable(dec_clk->clk_info[i].vcodec_clk);
 		if (ret) {
@@ -102,17 +142,133 @@ void mtk_vcodec_dec_clock_on(struct mtk_vcodec_pm *pm)
 	}
 
 	return;
-
 error:
 	for (i -= 1; i >= 0; i--)
 		clk_disable_unprepare(dec_clk->clk_info[i].vcodec_clk);
 }
 
-void mtk_vcodec_dec_clock_off(struct mtk_vcodec_pm *pm)
+static void mtk_vcodec_dec_clock_off(struct mtk_vcodec_dev *vdec_dev, int comp_idx)
 {
-	struct mtk_vcodec_clk *dec_clk = &pm->vdec_clk;
-	int i = 0;
+	struct mtk_vdec_comp_dev *comp_dev;
+	struct mtk_vcodec_pm *pm;
+	struct mtk_vcodec_clk *dec_clk;
+	int i;
+
+	if (vdec_dev->is_support_comp) {
+		if (!test_bit(comp_idx, vdec_dev->hardware_bitmap))
+			return;
+
+		comp_dev = mtk_vcodec_get_hw_dev(vdec_dev, comp_idx);
+		if (!comp_dev) {
+			mtk_v4l2_err("Failed to get hw dev\n");
+			return;
+		}
+		pm = &comp_dev->pm;
+	} else {
+		pm = &vdec_dev->pm;
+	}
 
+	dec_clk = &pm->vdec_clk;
 	for (i = dec_clk->clk_num - 1; i >= 0; i--)
 		clk_disable_unprepare(dec_clk->clk_info[i].vcodec_clk);
 }
+
+static void mtk_vcodec_dec_enable_irq(struct mtk_vcodec_dev *vdec_dev,
+	int comp_idx)
+{
+	struct mtk_vdec_comp_dev *comp_dev;
+
+	if (vdec_dev->is_support_comp) {
+		if (!test_bit(comp_idx, vdec_dev->hardware_bitmap))
+			return;
+
+		comp_dev = mtk_vcodec_get_hw_dev(vdec_dev, comp_idx);
+		if (!comp_dev) {
+			mtk_v4l2_err("Failed to get hw dev\n");
+			return;
+		}
+		if (!vdec_dev->vdec_inter_in_scp)
+			enable_irq(comp_dev->dec_irq);
+	} else {
+		enable_irq(vdec_dev->dec_irq);
+	}
+}
+
+static void mtk_vcodec_dec_disable_irq(struct mtk_vcodec_dev *vdec_dev,
+	int comp_idx)
+{
+	struct mtk_vdec_comp_dev *comp_dev;
+
+	if (vdec_dev->is_support_comp) {
+		if (!test_bit(comp_idx, vdec_dev->hardware_bitmap))
+			return;
+
+		comp_dev = mtk_vcodec_get_hw_dev(vdec_dev, comp_idx);
+		if (!comp_dev) {
+			mtk_v4l2_err("Failed to get hw dev\n");
+			return;
+		}
+		if (!vdec_dev->vdec_inter_in_scp)
+			disable_irq(comp_dev->dec_irq);
+	} else {
+		disable_irq(vdec_dev->dec_irq);
+	}
+}
+
+void mtk_vcodec_dec_enable_hardware(struct mtk_vcodec_ctx *ctx,
+	int comp_idx)
+{
+	mutex_lock(&ctx->dev->dec_mutex[comp_idx]);
+	if (VDEC_LAT_ARCH(ctx->dev->vdec_pdata->hw_arch) &&
+		comp_idx == MTK_VDEC_CORE) {
+		mtk_vcodec_dec_pw_on(ctx->dev, MTK_VDEC_LAT0);
+		mtk_vcodec_dec_clock_on(ctx->dev, MTK_VDEC_LAT0);
+		mtk_vcodec_dec_pw_on(ctx->dev, MTK_VDEC_LAT_SOC);
+		mtk_vcodec_dec_clock_on(ctx->dev, MTK_VDEC_LAT_SOC);
+	}
+	mtk_vcodec_dec_pw_on(ctx->dev, comp_idx);
+	mtk_vcodec_dec_clock_on(ctx->dev, comp_idx);
+
+	mtk_vcodec_dec_enable_irq(ctx->dev, comp_idx);
+
+	if (VDEC_LAT_ARCH(ctx->dev->vdec_pdata->hw_arch) &&
+		comp_idx == MTK_VDEC_CORE) {
+		mtk_vcodec_dec_pw_on(ctx->dev, MTK_VDEC_CORE1);
+		mtk_vcodec_dec_clock_on(ctx->dev, MTK_VDEC_CORE1);
+	}
+
+	if (VDEC_LAT_ARCH(ctx->dev->vdec_pdata->hw_arch) &&
+		comp_idx != MTK_VDEC_CORE) {
+		mtk_vcodec_dec_pw_on(ctx->dev, MTK_VDEC_LAT_SOC);
+		mtk_vcodec_dec_clock_on(ctx->dev, MTK_VDEC_LAT_SOC);
+	}
+}
+
+void mtk_vcodec_dec_disable_hardware(struct mtk_vcodec_ctx *ctx,
+	int comp_idx)
+{
+	mtk_vcodec_dec_disable_irq(ctx->dev, comp_idx);
+
+	if (VDEC_LAT_ARCH(ctx->dev->vdec_pdata->hw_arch) &&
+		comp_idx != MTK_VDEC_CORE) {
+		mtk_vcodec_dec_clock_off(ctx->dev, MTK_VDEC_LAT_SOC);
+		mtk_vcodec_dec_pw_off(ctx->dev, MTK_VDEC_LAT_SOC);
+	}
+
+	if (VDEC_LAT_ARCH(ctx->dev->vdec_pdata->hw_arch) &&
+		comp_idx == MTK_VDEC_CORE) {
+		mtk_vcodec_dec_clock_off(ctx->dev, MTK_VDEC_CORE1);
+		mtk_vcodec_dec_pw_off(ctx->dev, MTK_VDEC_CORE1);
+	}
+	mtk_vcodec_dec_clock_off(ctx->dev, comp_idx);
+	mtk_vcodec_dec_pw_off(ctx->dev, comp_idx);
+
+	if (VDEC_LAT_ARCH(ctx->dev->vdec_pdata->hw_arch) &&
+		comp_idx == MTK_VDEC_CORE) {
+		mtk_vcodec_dec_clock_off(ctx->dev, MTK_VDEC_LAT_SOC);
+		mtk_vcodec_dec_pw_off(ctx->dev, MTK_VDEC_LAT_SOC);
+		mtk_vcodec_dec_clock_off(ctx->dev, MTK_VDEC_LAT0);
+		mtk_vcodec_dec_pw_off(ctx->dev, MTK_VDEC_LAT0);
+	}
+	mutex_unlock(&ctx->dev->dec_mutex[comp_idx]);
+}
diff --git a/drivers/media/platform/mtk-vcodec/mtk_vcodec_dec_pm.h b/drivers/media/platform/mtk-vcodec/mtk_vcodec_dec_pm.h
index 280aeaefdb6514d976adf1fda0e0120917376f50..a8f9caea7bd5f4f9d2bceba295b18ea4ab49d465 100644
--- a/drivers/media/platform/mtk-vcodec/mtk_vcodec_dec_pm.h
+++ b/drivers/media/platform/mtk-vcodec/mtk_vcodec_dec_pm.h
@@ -9,12 +9,13 @@
 
 #include "mtk_vcodec_drv.h"
 
-int mtk_vcodec_init_dec_pm(struct mtk_vcodec_dev *dev);
-void mtk_vcodec_release_dec_pm(struct mtk_vcodec_dev *dev);
+int mtk_vcodec_init_dec_pm(struct platform_device *pdev,
+	struct mtk_vcodec_pm *pm);
+void mtk_vcodec_release_dec_pm(struct mtk_vcodec_pm *pm);
 
-int mtk_vcodec_dec_pw_on(struct mtk_vcodec_pm *pm);
-void mtk_vcodec_dec_pw_off(struct mtk_vcodec_pm *pm);
-void mtk_vcodec_dec_clock_on(struct mtk_vcodec_pm *pm);
-void mtk_vcodec_dec_clock_off(struct mtk_vcodec_pm *pm);
+void mtk_vcodec_dec_enable_hardware(struct mtk_vcodec_ctx *ctx,
+	int comp_idx);
+void mtk_vcodec_dec_disable_hardware(struct mtk_vcodec_ctx *ctx,
+	int comp_idx);
 
 #endif /* _MTK_VCODEC_DEC_PM_H_ */
diff --git a/drivers/media/platform/mtk-vcodec/mtk_vcodec_dec_stateful.c b/drivers/media/platform/mtk-vcodec/mtk_vcodec_dec_stateful.c
index 1f68d92e5c3a1144be1f3b0d104e0ef8b0b81691..280df39667d5f51db9e6561e97b98202a23f9cd4 100644
--- a/drivers/media/platform/mtk-vcodec/mtk_vcodec_dec_stateful.c
+++ b/drivers/media/platform/mtk-vcodec/mtk_vcodec_dec_stateful.c
@@ -37,7 +37,8 @@ static const struct mtk_video_fmt mtk_video_formats[] = {
 	},
 };
 
-#define NUM_FORMATS ARRAY_SIZE(mtk_video_formats)
+static const unsigned int num_supported_formats =
+	ARRAY_SIZE(mtk_video_formats);
 #define DEFAULT_OUT_FMT_IDX	0
 #define DEFAULT_CAP_FMT_IDX	3
 
@@ -59,7 +60,8 @@ static const struct mtk_codec_framesizes mtk_vdec_framesizes[] = {
 	},
 };
 
-#define NUM_SUPPORTED_FRAMESIZE ARRAY_SIZE(mtk_vdec_framesizes)
+static const unsigned int num_supported_framesize =
+	ARRAY_SIZE(mtk_vdec_framesizes);
 
 /*
  * This function tries to clean all display buffers, the buffers will return
@@ -252,7 +254,7 @@ static void mtk_vdec_update_fmt(struct mtk_vcodec_ctx *ctx,
 	unsigned int k;
 
 	dst_q_data = &ctx->q_data[MTK_Q_DATA_DST];
-	for (k = 0; k < NUM_FORMATS; k++) {
+	for (k = 0; k < num_supported_formats; k++) {
 		fmt = &mtk_video_formats[k];
 		if (fmt->fourcc == pixelformat) {
 			mtk_v4l2_debug(1, "Update cap fourcc(%d -> %d)",
@@ -652,16 +654,16 @@ static struct vb2_ops mtk_vdec_frame_vb2_ops = {
 };
 
 const struct mtk_vcodec_dec_pdata mtk_vdec_8173_pdata = {
-	.chip = MTK_MT8173,
 	.init_vdec_params = mtk_init_vdec_params,
 	.ctrls_setup = mtk_vcodec_dec_ctrls_setup,
 	.vdec_vb2_ops = &mtk_vdec_frame_vb2_ops,
 	.vdec_formats = mtk_video_formats,
-	.num_formats = NUM_FORMATS,
+	.num_formats = &num_supported_formats,
 	.default_out_fmt = &mtk_video_formats[DEFAULT_OUT_FMT_IDX],
 	.default_cap_fmt = &mtk_video_formats[DEFAULT_CAP_FMT_IDX],
 	.vdec_framesizes = mtk_vdec_framesizes,
-	.num_framesizes = NUM_SUPPORTED_FRAMESIZE,
+	.num_framesizes = &num_supported_framesize,
 	.worker = mtk_vdec_worker,
 	.flush_decoder = mtk_vdec_flush_decoder,
+	.hw_arch = MTK_VDEC_PURE_SINGLE_CORE,
 };
diff --git a/drivers/media/platform/mtk-vcodec/mtk_vcodec_dec_stateless.c b/drivers/media/platform/mtk-vcodec/mtk_vcodec_dec_stateless.c
index 75ddf53e2876ae5545db14ac98c246052b00d08c..73253bd6c9fe70474ac21ead3f6512caf9185ac5 100644
--- a/drivers/media/platform/mtk-vcodec/mtk_vcodec_dec_stateless.c
+++ b/drivers/media/platform/mtk-vcodec/mtk_vcodec_dec_stateless.c
@@ -76,68 +76,140 @@ static const struct mtk_stateless_control mtk_stateless_controls[] = {
 			.max = V4L2_STATELESS_H264_START_CODE_ANNEX_B,
 		},
 		.codec_type = V4L2_PIX_FMT_H264_SLICE,
-	}
-};
-#define NUM_CTRLS ARRAY_SIZE(mtk_stateless_controls)
-
-static const struct mtk_video_fmt mtk_video_formats[] = {
+	},
 	{
-		.fourcc = V4L2_PIX_FMT_H264_SLICE,
-		.type = MTK_FMT_DEC,
-		.num_planes = 1,
+		.cfg = {
+			.id = V4L2_CID_STATELESS_VP8_FRAME,
+		},
+		.codec_type = V4L2_PIX_FMT_VP8_FRAME,
 	},
 	{
-		.fourcc = V4L2_PIX_FMT_MM21,
-		.type = MTK_FMT_FRAME,
-		.num_planes = 2,
+		.cfg = {
+			.id = V4L2_CID_MPEG_VIDEO_VP8_PROFILE,
+			.min = V4L2_MPEG_VIDEO_VP8_PROFILE_0,
+			.def = V4L2_MPEG_VIDEO_VP8_PROFILE_0,
+			.max = V4L2_MPEG_VIDEO_VP8_PROFILE_3,
+		},
+		.codec_type = V4L2_PIX_FMT_VP8_FRAME,
+	},
+	{
+		.cfg = {
+			.id = V4L2_CID_MPEG_VIDEO_VP9_FRAME_DECODE_PARAMS,
+		},
+		.codec_type = V4L2_PIX_FMT_VP9_FRAME,
 	},
-};
-#define NUM_FORMATS ARRAY_SIZE(mtk_video_formats)
-#define DEFAULT_OUT_FMT_IDX    0
-#define DEFAULT_CAP_FMT_IDX    1
-
-static const struct mtk_codec_framesizes mtk_vdec_framesizes[] = {
 	{
-		.fourcc	= V4L2_PIX_FMT_H264_SLICE,
-		.stepwise = {  MTK_VDEC_MIN_W, MTK_VDEC_MAX_W, 16,
-				MTK_VDEC_MIN_H, MTK_VDEC_MAX_H, 16 },
+		.cfg = {
+			.id = V4L2_CID_MPEG_VIDEO_VP9_PROFILE,
+			.min = V4L2_MPEG_VIDEO_VP9_PROFILE_0,
+			.def = V4L2_MPEG_VIDEO_VP9_PROFILE_0,
+			.max = V4L2_MPEG_VIDEO_VP9_PROFILE_3,
+		},
+		.codec_type = V4L2_PIX_FMT_VP9_FRAME,
 	},
 };
+#define NUM_CTRLS ARRAY_SIZE(mtk_stateless_controls)
 
-#define NUM_SUPPORTED_FRAMESIZE ARRAY_SIZE(mtk_vdec_framesizes)
+static struct mtk_video_fmt mtk_video_formats[5];
+static struct mtk_codec_framesizes mtk_vdec_framesizes[3];
+
+struct mtk_video_fmt default_out_format;
+struct mtk_video_fmt default_cap_format;
+static unsigned int num_formats = 0;
+static unsigned int num_framesizes = 0;
+
+struct v4l2_frmsize_stepwise stepwise_fhd =	{
+	.min_width = MTK_VDEC_MIN_W,
+	.max_width = MTK_VDEC_MAX_W,
+	.step_width = 16,
+	.min_height = MTK_VDEC_MIN_H,
+	.max_height = MTK_VDEC_MAX_H,
+	.step_height = 16
+};
 
-static void mtk_vdec_stateless_set_dst_payload(struct mtk_vcodec_ctx *ctx,
-					       struct vdec_fb *fb)
+static void mtk_vdec_stateless_out_to_done(struct mtk_vcodec_ctx *ctx,
+					   struct mtk_vcodec_mem *bs, int error)
 {
-	struct mtk_video_dec_buf *vdec_frame_buf =
-		container_of(fb, struct mtk_video_dec_buf, frame_buffer);
-	struct vb2_v4l2_buffer *vb = &vdec_frame_buf->m2m_buf.vb;
-	unsigned int cap_y_size = ctx->q_data[MTK_Q_DATA_DST].sizeimage[0];
+	struct mtk_video_dec_buf *out_buf;
+	struct vb2_v4l2_buffer *vb;
 
-	vb2_set_plane_payload(&vb->vb2_buf, 0, cap_y_size);
-	if (ctx->q_data[MTK_Q_DATA_DST].fmt->num_planes == 2) {
-		unsigned int cap_c_size =
-			ctx->q_data[MTK_Q_DATA_DST].sizeimage[1];
+	if (!bs) {
+		mtk_v4l2_err("Free bitstream buffer fail.");
+		return;
+	}
+	out_buf = container_of(bs, struct mtk_video_dec_buf, bs_buffer);
+	vb = &out_buf->m2m_buf.vb;
+
+	mtk_v4l2_debug(2,
+		"Free bitsteam buffer id = %d to done_list",
+		vb->vb2_buf.index);
+
+	v4l2_m2m_src_buf_remove(ctx->m2m_ctx);
+	if (error) {
+		v4l2_m2m_buf_done(vb, VB2_BUF_STATE_ERROR);
+		if (error == -EIO)
+			out_buf->error = true;
+	} else {
+		v4l2_m2m_buf_done(vb, VB2_BUF_STATE_DONE);
+	}
+}
 
-		vb2_set_plane_payload(&vb->vb2_buf, 1, cap_c_size);
+static void mtk_vdec_stateless_cap_to_disp(struct mtk_vcodec_ctx *ctx,
+					   struct vdec_fb *fb, int error)
+{
+	struct mtk_video_dec_buf *vdec_frame_buf;
+	struct vb2_v4l2_buffer *vb;
+	unsigned int cap_y_size, cap_c_size;
+
+	if (!fb) {
+		mtk_v4l2_err("Free frame buffer fail.");
+		return;
 	}
+	vdec_frame_buf = container_of(fb, struct mtk_video_dec_buf,
+				      frame_buffer);
+	vb = &vdec_frame_buf->m2m_buf.vb;
+
+	cap_y_size = ctx->q_data[MTK_Q_DATA_DST].sizeimage[0];
+	cap_c_size = ctx->q_data[MTK_Q_DATA_DST].sizeimage[1];
+
+	v4l2_m2m_dst_buf_remove(ctx->m2m_ctx);
+
+	vb2_set_plane_payload(&vb->vb2_buf, 0, cap_y_size);
+	if (ctx->q_data[MTK_Q_DATA_DST].fmt->num_planes == 2)
+		vb2_set_plane_payload(&vb->vb2_buf, 1, cap_c_size);
+
+	mtk_v4l2_debug(2,
+		"Free frame buffer id = %d to done_list",
+		vb->vb2_buf.index);
+	if (error)
+		v4l2_m2m_buf_done(vb, VB2_BUF_STATE_ERROR);
+	else
+		v4l2_m2m_buf_done(vb, VB2_BUF_STATE_DONE);
 }
 
-static struct vdec_fb *vdec_get_cap_buffer(struct mtk_vcodec_ctx *ctx,
-					   struct vb2_v4l2_buffer *vb2_v4l2)
+static struct vdec_fb *vdec_get_cap_buffer(struct mtk_vcodec_ctx *ctx)
 {
-	struct mtk_video_dec_buf *framebuf =
-		container_of(vb2_v4l2, struct mtk_video_dec_buf, m2m_buf.vb);
-	struct vdec_fb *pfb = &framebuf->frame_buffer;
-	struct vb2_buffer *dst_buf = &vb2_v4l2->vb2_buf;
+	struct mtk_video_dec_buf *framebuf;
+	struct vb2_v4l2_buffer *vb2_v4l2;
+	struct vb2_buffer *dst_buf;
+	struct vdec_fb *pfb;
+
+	vb2_v4l2 = v4l2_m2m_next_dst_buf(ctx->m2m_ctx);
+	if (!vb2_v4l2) {
+		mtk_v4l2_debug(1, "[%d] dst_buf empty!!", ctx->id);
+		return NULL;
+	}
+
+	dst_buf = &vb2_v4l2->vb2_buf;
+	framebuf = container_of(vb2_v4l2, struct mtk_video_dec_buf, m2m_buf.vb);
 
 	pfb = &framebuf->frame_buffer;
-	pfb->base_y.va = NULL;
+	pfb->base_y.va = vb2_plane_vaddr(dst_buf, 0);
 	pfb->base_y.dma_addr = vb2_dma_contig_plane_dma_addr(dst_buf, 0);
 	pfb->base_y.size = ctx->q_data[MTK_Q_DATA_DST].sizeimage[0];
 
 	if (ctx->q_data[MTK_Q_DATA_DST].fmt->num_planes == 2) {
-		pfb->base_c.va = NULL;
+		pfb->base_c.va = vb2_plane_vaddr(dst_buf, 1);
 		pfb->base_c.dma_addr =
 			vb2_dma_contig_plane_dma_addr(dst_buf, 1);
 		pfb->base_c.size = ctx->q_data[MTK_Q_DATA_DST].sizeimage[1];
@@ -184,12 +256,11 @@ static void mtk_vdec_worker(struct work_struct *work)
 	struct mtk_vcodec_ctx *ctx =
 		container_of(work, struct mtk_vcodec_ctx, decode_work);
 	struct mtk_vcodec_dev *dev = ctx->dev;
-	struct vb2_v4l2_buffer *vb2_v4l2_src, *vb2_v4l2_dst;
+	struct vb2_v4l2_buffer *vb2_v4l2_src;
 	struct vb2_buffer *vb2_src;
 	struct mtk_vcodec_mem *bs_src;
 	struct mtk_video_dec_buf *dec_buf_src;
 	struct media_request *src_buf_req;
-	struct vdec_fb *dst_buf;
 	bool res_chg = false;
 	int ret;
 
@@ -200,28 +271,27 @@ static void mtk_vdec_worker(struct work_struct *work)
 		return;
 	}
 
-	vb2_v4l2_dst = v4l2_m2m_next_dst_buf(ctx->m2m_ctx);
-	if (vb2_v4l2_dst == NULL) {
-		v4l2_m2m_job_finish(dev->m2m_dev_dec, ctx->m2m_ctx);
-		mtk_v4l2_debug(1, "[%d] no available destination buffer", ctx->id);
-		return;
-	}
-
 	vb2_src = &vb2_v4l2_src->vb2_buf;
 	dec_buf_src = container_of(vb2_v4l2_src, struct mtk_video_dec_buf,
 				   m2m_buf.vb);
 	bs_src = &dec_buf_src->bs_buffer;
 
 	mtk_v4l2_debug(3, "[%d] (%d) id=%d, vb=%p buf_info = %p",
-			ctx->id, src_buf->vb2_queue->type,
-			src_buf->index, src_buf, src_buf_info);
+			ctx->id, vb2_src->vb2_queue->type,
+			vb2_src->index, vb2_src, dec_buf_src);
 
-	bs_src->va = NULL;
+	bs_src->va = vb2_plane_vaddr(vb2_src, 0);
 	bs_src->dma_addr = vb2_dma_contig_plane_dma_addr(vb2_src, 0);
 	bs_src->size = (size_t)vb2_src->planes[0].bytesused;
+	if (!bs_src->va) {
+		v4l2_m2m_job_finish(dev->m2m_dev_dec, ctx->m2m_ctx);
+		mtk_v4l2_err("[%d] id=%d source buffer is NULL", ctx->id,
+			     vb2_src->index);
+		return;
+	}
 
 	mtk_v4l2_debug(3, "[%d] Bitstream VA=%p DMA=%pad Size=%zx vb=%p",
-			ctx->id, buf->va, &buf->dma_addr, buf->size, src_buf);
+			ctx->id, bs_src->va, &bs_src->dma_addr, bs_src->size, vb2_src);
 	/* Apply request controls. */
 	src_buf_req = vb2_src->req_obj.req;
 	if (src_buf_req)
@@ -229,10 +299,8 @@ static void mtk_vdec_worker(struct work_struct *work)
 	else
 		mtk_v4l2_err("vb2 buffer media request is NULL");
 
-	dst_buf = vdec_get_cap_buffer(ctx, vb2_v4l2_dst);
-	v4l2_m2m_buf_copy_metadata(vb2_v4l2_src, vb2_v4l2_dst, true);
-	ret = vdec_if_decode(ctx, bs_src, dst_buf, &res_chg);
-	if (ret) {
+	ret = vdec_if_decode(ctx, bs_src, NULL, &res_chg);
+	if (ret < 0) {
 		mtk_v4l2_err(
 			" <===[%d], src_buf[%d] sz=0x%zx pts=%llu vdec_if_decode() ret=%d res_chg=%d===>",
 			ctx->id, vb2_src->index, bs_src->size,
@@ -244,23 +312,25 @@ static void mtk_vdec_worker(struct work_struct *work)
 		}
 	}
 
-	mtk_vdec_stateless_set_dst_payload(ctx, dst_buf);
-
-	v4l2_m2m_buf_done_and_job_finish(dev->m2m_dev_dec, ctx->m2m_ctx,
-		ret ? VB2_BUF_STATE_ERROR : VB2_BUF_STATE_DONE);
+	if (ret <= 0) {
+		mtk_vdec_stateless_out_to_done(ctx, bs_src, ret);
+		v4l2_ctrl_request_complete(src_buf_req, &ctx->ctrl_hdl);
+	}
 
-	v4l2_ctrl_request_complete(src_buf_req, &ctx->ctrl_hdl);
+	v4l2_m2m_job_finish(dev->m2m_dev_dec, ctx->m2m_ctx);
 }
 
 static void vb2ops_vdec_stateless_buf_queue(struct vb2_buffer *vb)
 {
 	struct mtk_vcodec_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);
 	struct vb2_v4l2_buffer *vb2_v4l2 = to_vb2_v4l2_buffer(vb);
+	struct mtk_video_dec_buf *dec_buf;
 
 	mtk_v4l2_debug(3, "[%d] (%d) id=%d, vb=%p",
 			ctx->id, vb->vb2_queue->type,
 			vb->index, vb);
 
+	dec_buf = container_of(vb2_v4l2, struct mtk_video_dec_buf, m2m_buf.vb);
 	mutex_lock(&ctx->lock);
 	v4l2_m2m_buf_queue(ctx->m2m_ctx, vb2_v4l2);
 	mutex_unlock(&ctx->lock);
@@ -268,7 +338,7 @@ static void vb2ops_vdec_stateless_buf_queue(struct vb2_buffer *vb)
 		return;
 
 	mtk_v4l2_debug(3, "(%d) id=%d, bs=%p",
-		vb->vb2_queue->type, vb->index, src_buf);
+		vb->vb2_queue->type, vb->index, dec_buf);
 
 	/* If an OUTPUT buffer, we may need to update the state */
 	if (ctx->state == MTK_STATE_INIT) {
@@ -318,6 +388,78 @@ const struct media_device_ops mtk_vcodec_media_ops = {
 	.req_queue	= v4l2_m2m_request_queue,
 };
 
+static void mtk_vcodec_add_formats(unsigned int fourcc,
+	struct mtk_vcodec_ctx *ctx)
+{
+	struct mtk_vcodec_dev *dev = ctx->dev;
+	const struct mtk_vcodec_dec_pdata *pdata = dev->vdec_pdata;
+	int count_formats = *pdata->num_formats;
+	int count_framesizes = *pdata->num_framesizes;
+
+	switch (fourcc) {
+	case V4L2_PIX_FMT_H264_SLICE:
+	case V4L2_PIX_FMT_VP8_FRAME:
+	case V4L2_PIX_FMT_VP9_FRAME:
+		mtk_video_formats[count_formats].fourcc = fourcc;
+		mtk_video_formats[count_formats].type = MTK_FMT_DEC;
+		mtk_video_formats[count_formats].num_planes = 1;
+
+		mtk_vdec_framesizes[count_framesizes].fourcc = fourcc;
+		mtk_vdec_framesizes[count_framesizes].stepwise = stepwise_fhd;
+		num_framesizes++;
+		break;
+	case V4L2_PIX_FMT_MM21:
+	case V4L2_PIX_FMT_MT21C:
+		mtk_video_formats[count_formats].fourcc = fourcc;
+		mtk_video_formats[count_formats].type = MTK_FMT_FRAME;
+		mtk_video_formats[count_formats].num_planes = 2;
+		break;
+	default:
+		mtk_v4l2_err("Can not add unsupported format type");
+		return;
+	}
+
+	num_formats++;
+	mtk_v4l2_debug(3, "num_formats: %d num_frames:%d dec_capability: 0x%x",
+		*(pdata->num_formats), *(pdata->num_framesizes),
+		ctx->dev->dec_capability);
+}
+
+static void mtk_vcodec_get_supported_formats(struct mtk_vcodec_ctx *ctx)
+{
+	int cap_format_count = 0, out_format_count = 0;
+
+	if (num_formats && num_framesizes)
+		return;
+
+	if (ctx->dev->dec_capability & MTK_VDEC_FORMAT_MM21) {
+		mtk_vcodec_add_formats(V4L2_PIX_FMT_MM21, ctx);
+		cap_format_count++;
+	}
+	if (ctx->dev->dec_capability & MTK_VDEC_FORMAT_MT21C) {
+		mtk_vcodec_add_formats(V4L2_PIX_FMT_MT21C, ctx);
+		cap_format_count++;
+	}
+	if (ctx->dev->dec_capability & MTK_VDEC_FORMAT_H264_SLICE) {
+		mtk_vcodec_add_formats(V4L2_PIX_FMT_H264_SLICE, ctx);
+		out_format_count++;
+	}
+	if (ctx->dev->dec_capability & MTK_VDEC_FORMAT_VP8_FRAME) {
+		mtk_vcodec_add_formats(V4L2_PIX_FMT_VP8_FRAME, ctx);
+		out_format_count++;
+	}
+	if (ctx->dev->dec_capability & MTK_VDEC_FORMAT_VP9_FRAME) {
+		mtk_vcodec_add_formats(V4L2_PIX_FMT_VP9_FRAME, ctx);
+		out_format_count++;
+	}
+
+	if (cap_format_count)
+		default_cap_format = mtk_video_formats[cap_format_count - 1];
+	if (out_format_count)
+		default_out_format =
+			mtk_video_formats[cap_format_count + out_format_count - 1];
+}
+
 static void mtk_init_vdec_params(struct mtk_vcodec_ctx *ctx)
 {
 	struct vb2_queue *src_vq;
@@ -325,6 +467,21 @@ static void mtk_init_vdec_params(struct mtk_vcodec_ctx *ctx)
 	src_vq = v4l2_m2m_get_vq(ctx->m2m_ctx,
 				 V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE);
 
+	if (ctx->dev->vdec_pdata->hw_arch != MTK_VDEC_PURE_SINGLE_CORE) {
+		v4l2_m2m_set_dst_buffered(ctx->m2m_ctx, 1);
+		mtk_vcodec_get_supported_formats(ctx);
+	} else {
+		mtk_vcodec_add_formats(V4L2_PIX_FMT_H264_SLICE, ctx);
+		mtk_vcodec_add_formats(V4L2_PIX_FMT_MM21, ctx);
+	}
+
+	if (ctx->dev->dec_capability & MTK_VCODEC_INTER_IN_SCP)
+		ctx->dev->vdec_inter_in_scp = true;
+
+	mtk_v4l2_debug(3, "vdec_inter_in_scp:%d dec_capability: 0x%x",
+		ctx->dev->vdec_inter_in_scp,
+		ctx->dev->dec_capability);
+
 	/* Support request api for output plane */
 	src_vq->supports_requests = true;
 	src_vq->requires_requests = true;
@@ -354,17 +511,55 @@ static struct vb2_ops mtk_vdec_request_vb2_ops = {
 };
 
 const struct mtk_vcodec_dec_pdata mtk_vdec_8183_pdata = {
-	.chip = MTK_MT8183,
 	.init_vdec_params = mtk_init_vdec_params,
 	.ctrls_setup = mtk_vcodec_dec_ctrls_setup,
 	.vdec_vb2_ops = &mtk_vdec_request_vb2_ops,
 	.vdec_formats = mtk_video_formats,
-	.num_formats = NUM_FORMATS,
-	.default_out_fmt = &mtk_video_formats[DEFAULT_OUT_FMT_IDX],
-	.default_cap_fmt = &mtk_video_formats[DEFAULT_CAP_FMT_IDX],
+	.num_formats = &num_formats,
+	.default_out_fmt = &default_out_format,
+	.default_cap_fmt = &default_cap_format,
+	.vdec_framesizes = mtk_vdec_framesizes,
+	.num_framesizes = &num_framesizes,
+	.uses_stateless_api = true,
+	.worker = mtk_vdec_worker,
+	.flush_decoder = mtk_vdec_flush_decoder,
+	.cap_to_disp = mtk_vdec_stateless_cap_to_disp,
+	.get_cap_buffer = vdec_get_cap_buffer,
+	.hw_arch = MTK_VDEC_PURE_SINGLE_CORE,
+};
+
+const struct mtk_vcodec_dec_pdata mtk_lat_sig_core_pdata = {
+	.init_vdec_params = mtk_init_vdec_params,
+	.ctrls_setup = mtk_vcodec_dec_ctrls_setup,
+	.vdec_vb2_ops = &mtk_vdec_request_vb2_ops,
+	.vdec_formats = mtk_video_formats,
+	.num_formats = &num_formats,
+	.default_out_fmt = &default_out_format,
+	.default_cap_fmt = &default_cap_format,
+	.vdec_framesizes = mtk_vdec_framesizes,
+	.num_framesizes = &num_framesizes,
+	.uses_stateless_api = true,
+	.worker = mtk_vdec_worker,
+	.flush_decoder = mtk_vdec_flush_decoder,
+	.cap_to_disp = mtk_vdec_stateless_cap_to_disp,
+	.get_cap_buffer = vdec_get_cap_buffer,
+	.hw_arch = MTK_VDEC_LAT_SINGLE_CORE,
+};
+
+const struct mtk_vcodec_dec_pdata mtk_lat_dual_core_pdata = {
+	.init_vdec_params = mtk_init_vdec_params,
+	.ctrls_setup = mtk_vcodec_dec_ctrls_setup,
+	.vdec_vb2_ops = &mtk_vdec_request_vb2_ops,
+	.vdec_formats = mtk_video_formats,
+	.num_formats = &num_formats,
+	.default_out_fmt = &default_out_format,
+	.default_cap_fmt = &default_cap_format,
 	.vdec_framesizes = mtk_vdec_framesizes,
-	.num_framesizes = NUM_SUPPORTED_FRAMESIZE,
+	.num_framesizes = &num_framesizes,
 	.uses_stateless_api = true,
 	.worker = mtk_vdec_worker,
 	.flush_decoder = mtk_vdec_flush_decoder,
+	.cap_to_disp = mtk_vdec_stateless_cap_to_disp,
+	.get_cap_buffer = vdec_get_cap_buffer,
+	.hw_arch = MTK_VDEC_LAT_DUAL_CORE,
 };
diff --git a/drivers/media/platform/mtk-vcodec/mtk_vcodec_drv.h b/drivers/media/platform/mtk-vcodec/mtk_vcodec_drv.h
index 17d95675236044fa594a575a51cc0e998e4d11f0..6ea23ad5189749e67cdc4f1c53c3842838564046 100644
--- a/drivers/media/platform/mtk-vcodec/mtk_vcodec_drv.h
+++ b/drivers/media/platform/mtk-vcodec/mtk_vcodec_drv.h
@@ -8,6 +8,8 @@
 #ifndef _MTK_VCODEC_DRV_H_
 #define _MTK_VCODEC_DRV_H_
 
+#include <linux/component.h>
+#include <linux/io.h>
 #include <linux/platform_device.h>
 #include <linux/videodev2.h>
 #include <media/v4l2-ctrls.h>
@@ -15,7 +17,14 @@
 #include <media/v4l2-ioctl.h>
 #include <media/v4l2-mem2mem.h>
 #include <media/videobuf2-core.h>
+
 #include "mtk_vcodec_util.h"
+#include "vdec_msg_queue.h"
+
+#define VDEC_HW_ACTIVE	0x10
+#define VDEC_IRQ_CFG	0x11
+#define VDEC_IRQ_CLR	0x10
+#define VDEC_IRQ_CFG_REG	0xa4
 
 #define MTK_VCODEC_DRV_NAME	"mtk_vcodec_drv"
 #define MTK_VCODEC_DEC_NAME	"mtk-vcodec-dec"
@@ -25,6 +34,9 @@
 #define MTK_VCODEC_MAX_PLANES	3
 #define MTK_V4L2_BENCHMARK	0
 #define WAIT_INTR_TIMEOUT_MS	1000
+#define VDEC_LAT_ARCH(hw_arch) ((hw_arch) >= MTK_VDEC_LAT_SINGLE_CORE)
+
+#define MTK_VCODEC_INTER_IN_SCP BIT(16)
 
 /**
  * enum mtk_hw_reg_idx - MTK hw register base index
@@ -93,6 +105,19 @@ enum mtk_fmt_type {
 	MTK_FMT_FRAME = 2,
 };
 
+/**
+ * struct mtk_vdec_hw_id - Hardware index used to separate
+ *                         different hardware
+ */
+enum mtk_vdec_hw_id {
+	MTK_VDEC_CORE,
+	MTK_VDEC_CORE1,
+	MTK_VDEC_LAT0,
+	MTK_VDEC_LAT1,
+	MTK_VDEC_LAT_SOC,
+	MTK_VDEC_HW_MAX,
+};
+
 /**
  * struct mtk_video_fmt - Structure used to store information about pixelformats
  */
@@ -192,7 +217,6 @@ struct mtk_vcodec_pm {
 	struct mtk_vcodec_clk	vdec_clk;
 	struct mtk_vcodec_clk	venc_clk;
 	struct device	*dev;
-	struct mtk_vcodec_dev	*mtkdev;
 };
 
 /**
@@ -243,6 +267,11 @@ struct vdec_pic_info {
  *	   finish
  * @irq_status: irq status
  *
+ * @int_core_cond: variable used by the waitqueue  for component arch
+ * @int_core_type: type of the last interrupt for component arch
+ * @core_queue: waitqueue that can be used to wait for this context to
+ *	   finish for component arch
+ *
  * @ctrl_hdl: handler for v4l2 framework
  * @decode_work: worker for the decoding
  * @encode_work: worker for the encoding
@@ -251,13 +280,22 @@ struct vdec_pic_info {
  *		     to be used with encoder and stateful decoder.
  * @is_flushing: set to true if flushing is in progress.
  * @current_codec: current set input codec, in V4L2 pixel format
+ * @capture_fourcc: capture queue type, in V4L2 pixel format
  *
  * @colorspace: enum v4l2_colorspace; supplemental to pixelformat
  * @ycbcr_enc: enum v4l2_ycbcr_encoding, Y'CbCr encoding
  * @quantization: enum v4l2_quantization, colorspace quantization
  * @xfer_func: enum v4l2_xfer_func, colorspace transfer function
+ *
+ * @decoded_frame_cnt: already decoded frame count
  * @lock: protect variables accessed by V4L2 threads and worker thread such as
  *	  mtk_video_dec_buf.
+ * @hw_id: hardware index used to identify different hardware
+ *
+ * @max_width: hardware supported max width
+ * @max_height: hardware supported max height
+ *
+ * @msg_queue: msg queue used to store lat buffer information
  */
 struct mtk_vcodec_ctx {
 	enum mtk_instance_type type;
@@ -284,6 +322,10 @@ struct mtk_vcodec_ctx {
 	wait_queue_head_t queue;
 	unsigned int irq_status;
 
+	int int_core_cond[MTK_VDEC_HW_MAX];
+	int int_core_type[MTK_VDEC_HW_MAX];
+	wait_queue_head_t core_queue[MTK_VDEC_HW_MAX];
+
 	struct v4l2_ctrl_handler ctrl_hdl;
 	struct work_struct decode_work;
 	struct work_struct encode_work;
@@ -292,6 +334,7 @@ struct mtk_vcodec_ctx {
 	bool is_flushing;
 
 	u32 current_codec;
+	u32 capture_fourcc;
 
 	enum v4l2_colorspace colorspace;
 	enum v4l2_ycbcr_encoding ycbcr_enc;
@@ -300,7 +343,11 @@ struct mtk_vcodec_ctx {
 
 	int decoded_frame_cnt;
 	struct mutex lock;
+	int hw_id;
 
+	unsigned int max_width;
+	unsigned int max_height;
+	struct vdec_msg_queue msg_queue;
 };
 
 enum mtk_chip {
@@ -310,13 +357,35 @@ enum mtk_chip {
 	MTK_MT8195,
 };
 
+/**
+ * struct mtk_vdec_hw_arch - Used to separate different hardware architecture
+ */
+enum mtk_vdec_hw_arch {
+	MTK_VDEC_PURE_SINGLE_CORE,
+	MTK_VDEC_LAT_SINGLE_CORE,
+	MTK_VDEC_LAT_DUAL_CORE,
+};
+
+/**
+ * struct mtk_vdec_format_types - Structure used to get supported
+ *		  format types according to decoder capability
+ */
+enum mtk_vdec_format_types {
+	MTK_VDEC_FORMAT_MM21 = 0x20,
+	MTK_VDEC_FORMAT_MT21C = 0x40,
+	MTK_VDEC_FORMAT_H264_SLICE = 0x100,
+	MTK_VDEC_FORMAT_VP8_FRAME = 0x200,
+	MTK_VDEC_FORMAT_VP9_FRAME = 0x400,
+};
+
 /**
  * struct mtk_vcodec_dec_pdata - compatible data for each IC
  * @init_vdec_params: init vdec params
  * @ctrls_setup: init vcodec dec ctrls
  * @worker: worker to start a decode job
  * @flush_decoder: function that flushes the decoder
- *
+ * @get_cap_buffer: get capture buffer from capture queue
+ * @cap_to_disp: put capture buffer to disp list
  * @vdec_vb2_ops: struct vb2_ops
  *
  * @vdec_formats: supported video decoder formats
@@ -328,6 +397,7 @@ enum mtk_chip {
  * @num_framesizes: count of video decoder frame sizes
  *
  * @chip: chip this decoder is compatible with
+ * @hw_arch: hardware arch is used to separate pure_sin_core and lat_sin_core
  *
  * @uses_stateless_api: whether the decoder uses the stateless API with requests
  */
@@ -337,19 +407,20 @@ struct mtk_vcodec_dec_pdata {
 	int (*ctrls_setup)(struct mtk_vcodec_ctx *ctx);
 	void (*worker)(struct work_struct *work);
 	int (*flush_decoder)(struct mtk_vcodec_ctx *ctx);
+	struct vdec_fb *(*get_cap_buffer)(struct mtk_vcodec_ctx *ctx);
+	void (*cap_to_disp)(struct mtk_vcodec_ctx *ctx, struct vdec_fb *fb, int error);
 
 	struct vb2_ops *vdec_vb2_ops;
 
 	const struct mtk_video_fmt *vdec_formats;
-	const int num_formats;
+	const int *num_formats;
 	const struct mtk_video_fmt *default_out_fmt;
 	const struct mtk_video_fmt *default_cap_fmt;
 
 	const struct mtk_codec_framesizes *vdec_framesizes;
-	const int num_framesizes;
-
-	enum mtk_chip chip;
+	const int *num_framesizes;
 
+	enum mtk_vdec_hw_arch hw_arch;
 	bool uses_stateless_api;
 };
 
@@ -401,6 +472,7 @@ struct mtk_vcodec_enc_pdata {
  *
  * @fw_handler: used to communicate with the firmware.
  * @id_counter: used to identify current opened instance
+ * @is_support_comp: 1: using compoent framework, 0: not support
  *
  * @encode_workqueue: encode work queue
  *
@@ -418,6 +490,18 @@ struct mtk_vcodec_enc_pdata {
  * @pm: power management control
  * @dec_capability: used to identify decode capability, ex: 4k
  * @enc_capability: used to identify encode capability
+ *
+ * comp_dev: component hardware device
+ * component_node: component node
+ * comp_idx: component index
+ *
+ * core_read: Wait queue used to signalize when core get useful lat buffer
+ * core_queue: List of V4L2 lat_buf
+ * core_lock: spin lock to protect the struct usage
+ * num_core: number of buffers ready to be processed
+ *
+ * @vdec_inter_in_scp: hardwate irq handler in scp or not
+ * @hardware_bitmap: used to record hardware is exist
  */
 struct mtk_vcodec_dev {
 	struct v4l2_device v4l2_dev;
@@ -438,6 +522,7 @@ struct mtk_vcodec_dev {
 	struct mtk_vcodec_fw *fw_handler;
 
 	unsigned long id_counter;
+	bool is_support_comp;
 
 	struct workqueue_struct *decode_workqueue;
 	struct workqueue_struct *encode_workqueue;
@@ -449,12 +534,25 @@ struct mtk_vcodec_dev {
 	int dec_irq;
 	int enc_irq;
 
-	struct mutex dec_mutex;
+	struct mutex dec_mutex[MTK_VDEC_HW_MAX];
 	struct mutex enc_mutex;
 
 	struct mtk_vcodec_pm pm;
 	unsigned int dec_capability;
 	unsigned int enc_capability;
+
+	void *comp_dev[MTK_VDEC_HW_MAX];
+	struct device_node *component_node[MTK_VDEC_HW_MAX];
+	int comp_idx;
+
+	struct task_struct *kthread_core;
+	wait_queue_head_t core_read;
+	struct list_head core_queue;
+	spinlock_t core_lock;
+	int num_core;
+
+	int vdec_inter_in_scp;
+	DECLARE_BITMAP(hardware_bitmap, MTK_VDEC_HW_MAX);
 };
 
 static inline struct mtk_vcodec_ctx *fh_to_ctx(struct v4l2_fh *fh)
diff --git a/drivers/media/platform/mtk-vcodec/mtk_vcodec_enc_pm.c b/drivers/media/platform/mtk-vcodec/mtk_vcodec_enc_pm.c
index dffb190267edf9a7ce7858745af76e8151856b27..863fced19feb04488facd956e0037f3c1c2d24b9 100644
--- a/drivers/media/platform/mtk-vcodec/mtk_vcodec_enc_pm.c
+++ b/drivers/media/platform/mtk-vcodec/mtk_vcodec_enc_pm.c
@@ -23,7 +23,6 @@ int mtk_vcodec_init_enc_pm(struct mtk_vcodec_dev *mtkdev)
 	pdev = mtkdev->plat_dev;
 	pm = &mtkdev->pm;
 	memset(pm, 0, sizeof(struct mtk_vcodec_pm));
-	pm->mtkdev = mtkdev;
 	pm->dev = &pdev->dev;
 	enc_clk = &pm->venc_clk;
 
diff --git a/drivers/media/platform/mtk-vcodec/mtk_vcodec_fw.c b/drivers/media/platform/mtk-vcodec/mtk_vcodec_fw.c
index 94b39ae5c2e1e05ac0e8bce3c4a52823b4da64f8..556e54aadac9a676f7ebdac8b05e53efd7740432 100644
--- a/drivers/media/platform/mtk-vcodec/mtk_vcodec_fw.c
+++ b/drivers/media/platform/mtk-vcodec/mtk_vcodec_fw.c
@@ -65,3 +65,9 @@ int mtk_vcodec_fw_ipi_send(struct mtk_vcodec_fw *fw, int id, void *buf,
 	return fw->ops->ipi_send(fw, id, buf, len, wait);
 }
 EXPORT_SYMBOL_GPL(mtk_vcodec_fw_ipi_send);
+
+int mtk_vcodec_fw_get_type(struct mtk_vcodec_fw *fw)
+{
+	return fw->type;
+}
+EXPORT_SYMBOL_GPL(mtk_vcodec_fw_get_type);
diff --git a/drivers/media/platform/mtk-vcodec/mtk_vcodec_fw.h b/drivers/media/platform/mtk-vcodec/mtk_vcodec_fw.h
index 539bb626772cc5d9a00ed386a197644a8dd73aec..acd355961e3a5e93a8bee399c496f49cb810e10b 100644
--- a/drivers/media/platform/mtk-vcodec/mtk_vcodec_fw.h
+++ b/drivers/media/platform/mtk-vcodec/mtk_vcodec_fw.h
@@ -39,5 +39,6 @@ int mtk_vcodec_fw_ipi_register(struct mtk_vcodec_fw *fw, int id,
 			       const char *name, void *priv);
 int mtk_vcodec_fw_ipi_send(struct mtk_vcodec_fw *fw, int id,
 			   void *buf, unsigned int len, unsigned int wait);
+int mtk_vcodec_fw_get_type(struct mtk_vcodec_fw *fw);
 
 #endif /* _MTK_VCODEC_FW_H_ */
diff --git a/drivers/media/platform/mtk-vcodec/mtk_vcodec_intr.c b/drivers/media/platform/mtk-vcodec/mtk_vcodec_intr.c
index a3c7a380c9308481256cfd5a97fdfb43050df0dc..4e7816c85d6e0f3db8560e80f7dfd869e3493940 100644
--- a/drivers/media/platform/mtk-vcodec/mtk_vcodec_intr.c
+++ b/drivers/media/platform/mtk-vcodec/mtk_vcodec_intr.c
@@ -43,3 +43,33 @@ int mtk_vcodec_wait_for_done_ctx(struct mtk_vcodec_ctx  *ctx, int command,
 	return status;
 }
 EXPORT_SYMBOL(mtk_vcodec_wait_for_done_ctx);
+
+int mtk_vcodec_wait_for_comp_done_ctx(struct mtk_vcodec_ctx  *ctx,
+	int command, unsigned int timeout_ms, unsigned hw_id)
+{
+	long timeout_jiff, ret;
+	int status = 0;
+
+	timeout_jiff = msecs_to_jiffies(timeout_ms);
+	ret = wait_event_interruptible_timeout(ctx->core_queue[hw_id],
+				ctx->int_core_cond[hw_id],
+				timeout_jiff);
+
+	if (!ret) {
+		status = -1;	/* timeout */
+		mtk_v4l2_err("[%d] cmd=%d, type=%d, dec timeout=%ums (%d %d)",
+				ctx->id, command, ctx->type, timeout_ms,
+				ctx->int_core_cond[hw_id], ctx->int_core_type[hw_id]);
+	} else if (-ERESTARTSYS == ret) {
+		status = -1;
+		mtk_v4l2_err("[%d] cmd=%d, type=%d, dec inter fail (%d %d)",
+				ctx->id, command, ctx->type,
+				ctx->int_core_cond[hw_id], ctx->int_core_type[hw_id]);
+	}
+
+	ctx->int_core_cond[hw_id] = 0;
+	ctx->int_core_type[hw_id] = 0;
+
+	return status;
+}
+EXPORT_SYMBOL(mtk_vcodec_wait_for_comp_done_ctx);
diff --git a/drivers/media/platform/mtk-vcodec/mtk_vcodec_intr.h b/drivers/media/platform/mtk-vcodec/mtk_vcodec_intr.h
index 638cd1f3526af6b5754e82759375dfc486b94584..345f63953fa1fa81a602f9e9541034dc6350299f 100644
--- a/drivers/media/platform/mtk-vcodec/mtk_vcodec_intr.h
+++ b/drivers/media/platform/mtk-vcodec/mtk_vcodec_intr.h
@@ -14,5 +14,7 @@ struct mtk_vcodec_ctx;
 /* timeout is ms */
 int mtk_vcodec_wait_for_done_ctx(struct mtk_vcodec_ctx *data, int command,
 				unsigned int timeout_ms);
+int mtk_vcodec_wait_for_comp_done_ctx(struct mtk_vcodec_ctx  *ctx,
+				int command, unsigned int timeout_ms, unsigned int hw_id);
 
 #endif /* _MTK_VCODEC_INTR_H_ */
diff --git a/drivers/media/platform/mtk-vcodec/mtk_vcodec_util.c b/drivers/media/platform/mtk-vcodec/mtk_vcodec_util.c
index ac5973b6735f169321608aa4bcc5dd517156ac29..99ccbc73a85ee0ee0b27e26fd4c38b9779dfa77d 100644
--- a/drivers/media/platform/mtk-vcodec/mtk_vcodec_util.c
+++ b/drivers/media/platform/mtk-vcodec/mtk_vcodec_util.c
@@ -6,7 +6,10 @@
 */
 
 #include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
 
+#include "mtk_vcodec_dec_hw.h"
 #include "mtk_vcodec_drv.h"
 #include "mtk_vcodec_util.h"
 
@@ -81,25 +84,87 @@ void mtk_vcodec_mem_free(struct mtk_vcodec_ctx *data,
 }
 EXPORT_SYMBOL(mtk_vcodec_mem_free);
 
-void mtk_vcodec_set_curr_ctx(struct mtk_vcodec_dev *dev,
-	struct mtk_vcodec_ctx *ctx)
+void *mtk_vcodec_get_hw_dev(struct mtk_vcodec_dev *dev, int comp_idx)
 {
-	unsigned long flags;
+	struct platform_device *hw_pdev;
+	struct device_node *node;
+	struct mtk_vdec_comp_dev *master_dev;
+
+	if (comp_idx >= MTK_VDEC_HW_MAX || comp_idx < 0) {
+		mtk_v4l2_err("Comp idx is out of range:%d", comp_idx);
+		return NULL;
+	}
+
+	if (dev->comp_dev[comp_idx])
+		return dev->comp_dev[comp_idx];
+
+	node = dev->component_node[comp_idx];
+	if (!node) {
+		mtk_v4l2_err("Get lat node fail:%d", comp_idx);
+		return NULL;
+	}
+
+	hw_pdev = of_find_device_by_node(node);
+	of_node_put(node);
+
+	if (WARN_ON(!hw_pdev)) {
+		mtk_v4l2_err("Get hw id(%d) node fail", comp_idx);
+		return NULL;
+	}
+
+	master_dev = platform_get_drvdata(hw_pdev);
+	if (!master_dev) {
+		mtk_v4l2_err("Get hw id(%d) pdev fail", comp_idx);
+		return NULL;
+	}
 
-	spin_lock_irqsave(&dev->irqlock, flags);
-	dev->curr_ctx = ctx;
-	spin_unlock_irqrestore(&dev->irqlock, flags);
+	dev->comp_dev[master_dev->comp_idx] = master_dev;
+	return master_dev;
+}
+EXPORT_SYMBOL(mtk_vcodec_get_hw_dev);
+
+void mtk_vcodec_set_curr_ctx(struct mtk_vcodec_dev *vdec_dev,
+	struct mtk_vcodec_ctx *ctx, int comp_idx)
+{
+	unsigned long flags;
+	struct mtk_vdec_comp_dev *comp_dev;
+
+	spin_lock_irqsave(&vdec_dev->irqlock, flags);
+	if (vdec_dev->is_support_comp) {
+		comp_dev = mtk_vcodec_get_hw_dev(vdec_dev, comp_idx);
+		if (!comp_dev) {
+			mtk_v4l2_err("Failed to get hw dev");
+			spin_unlock_irqrestore(&vdec_dev->irqlock, flags);
+			return;
+		}
+		comp_dev->curr_ctx = ctx;
+	} else {
+		vdec_dev->curr_ctx = ctx;
+	}
+	spin_unlock_irqrestore(&vdec_dev->irqlock, flags);
 }
 EXPORT_SYMBOL(mtk_vcodec_set_curr_ctx);
 
-struct mtk_vcodec_ctx *mtk_vcodec_get_curr_ctx(struct mtk_vcodec_dev *dev)
+struct mtk_vcodec_ctx *mtk_vcodec_get_curr_ctx(struct mtk_vcodec_dev *vdec_dev,
+	unsigned int comp_idx)
 {
 	unsigned long flags;
 	struct mtk_vcodec_ctx *ctx;
-
-	spin_lock_irqsave(&dev->irqlock, flags);
-	ctx = dev->curr_ctx;
-	spin_unlock_irqrestore(&dev->irqlock, flags);
+	struct mtk_vdec_comp_dev *comp_dev;
+
+	spin_lock_irqsave(&vdec_dev->irqlock, flags);
+	if (vdec_dev->is_support_comp) {
+		comp_dev = mtk_vcodec_get_hw_dev(vdec_dev, comp_idx);
+		if (!comp_dev) {
+			mtk_v4l2_err("Failed to get hw dev");
+			spin_unlock_irqrestore(&vdec_dev->irqlock, flags);
+			return NULL;
+		}
+		ctx = comp_dev->curr_ctx;
+	} else {
+		ctx = vdec_dev->curr_ctx;
+	}
+	spin_unlock_irqrestore(&vdec_dev->irqlock, flags);
 	return ctx;
 }
 EXPORT_SYMBOL(mtk_vcodec_get_curr_ctx);
diff --git a/drivers/media/platform/mtk-vcodec/mtk_vcodec_util.h b/drivers/media/platform/mtk-vcodec/mtk_vcodec_util.h
index b999d7b84ed18d0d6bf753758ec89137f42e8e08..0d036f30c742b2b72cd540ecd05549830a1c3b93 100644
--- a/drivers/media/platform/mtk-vcodec/mtk_vcodec_util.h
+++ b/drivers/media/platform/mtk-vcodec/mtk_vcodec_util.h
@@ -38,7 +38,7 @@ extern bool mtk_vcodec_dbg;
 	       ((struct mtk_vcodec_ctx *)h->ctx)->id, __func__, ##args)
 
 
-#if defined(DEBUG)
+#if 1
 
 #define mtk_v4l2_debug(level, fmt, args...)				 \
 	do {								 \
@@ -79,8 +79,10 @@ int mtk_vcodec_mem_alloc(struct mtk_vcodec_ctx *data,
 				struct mtk_vcodec_mem *mem);
 void mtk_vcodec_mem_free(struct mtk_vcodec_ctx *data,
 				struct mtk_vcodec_mem *mem);
-void mtk_vcodec_set_curr_ctx(struct mtk_vcodec_dev *dev,
-	struct mtk_vcodec_ctx *ctx);
-struct mtk_vcodec_ctx *mtk_vcodec_get_curr_ctx(struct mtk_vcodec_dev *dev);
+void mtk_vcodec_set_curr_ctx(struct mtk_vcodec_dev *vdec_dev,
+				struct mtk_vcodec_ctx *ctx, int comp_idx);
+struct mtk_vcodec_ctx * mtk_vcodec_get_curr_ctx(struct mtk_vcodec_dev *vdec_dev,
+	unsigned int comp_idx);
+void *mtk_vcodec_get_hw_dev(struct mtk_vcodec_dev *dev, int comp_idx);
 
 #endif /* _MTK_VCODEC_UTIL_H_ */
diff --git a/drivers/media/platform/mtk-vcodec/vdec/vdec_h264_req_common.c b/drivers/media/platform/mtk-vcodec/vdec/vdec_h264_req_common.c
new file mode 100644
index 0000000000000000000000000000000000000000..7e248e247628525768d5425c6a914db60b514a8e
--- /dev/null
+++ b/drivers/media/platform/mtk-vcodec/vdec/vdec_h264_req_common.c
@@ -0,0 +1,303 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2021 MediaTek Inc.
+ * Author: Yunfei Dong <yunfei.dong@mediatek.com>
+ */
+
+#include "vdec_h264_req_common.h"
+
+/* get used parameters for sps/pps */
+#define GET_MTK_VDEC_FLAG(cond, flag) \
+	{ dst_param->cond = ((src_param->flags & flag) ? (1) : (0)); }
+#define GET_MTK_VDEC_PARAM(param) \
+	{ dst_param->param = src_param->param; }
+
+void *mtk_vdec_h264_get_ctrl_ptr(struct mtk_vcodec_ctx *ctx, int id)
+{
+	struct v4l2_ctrl *ctrl = v4l2_ctrl_find(&ctx->ctrl_hdl, id);
+
+	return ctrl->p_cur.p;
+}
+
+void mtk_vdec_h264_fill_dpb_info(struct mtk_vcodec_ctx *ctx,
+	struct slice_api_h264_decode_param *decode_params,
+	struct mtk_h264_dpb_info *h264_dpb_info)
+{
+	struct vb2_queue *vq;
+	struct vb2_buffer *vb;
+	struct vb2_v4l2_buffer *vb2_v4l2;
+	int index;
+
+	vq = v4l2_m2m_get_vq(ctx->m2m_ctx, V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE);
+
+	for (index = 0; index < V4L2_H264_NUM_DPB_ENTRIES; index++) {
+		const struct slice_h264_dpb_entry *dpb;
+		int vb2_index;
+
+		dpb = &decode_params->dpb[index];
+		if (!(dpb->flags & V4L2_H264_DPB_ENTRY_FLAG_ACTIVE)) {
+			h264_dpb_info[index].reference_flag = 0;
+			continue;
+		}
+
+		vb2_index = vb2_find_timestamp(vq, dpb->reference_ts, 0);
+		if (vb2_index < 0) {
+			dev_err(&ctx->dev->plat_dev->dev,
+				"Reference invalid: dpb_index(%d) reference_ts(%lld)",
+				index, dpb->reference_ts);
+			continue;
+		}
+
+		/* 1 for short term reference, 2 for long term reference */
+		if (!(dpb->flags & V4L2_H264_DPB_ENTRY_FLAG_LONG_TERM))
+			h264_dpb_info[index].reference_flag = 1;
+		else
+			h264_dpb_info[index].reference_flag = 2;
+
+		vb = vq->bufs[vb2_index];
+		vb2_v4l2 = container_of(vb, struct vb2_v4l2_buffer, vb2_buf);
+		h264_dpb_info[index].field = vb2_v4l2->field;
+
+		h264_dpb_info[index].y_dma_addr =
+			vb2_dma_contig_plane_dma_addr(vb, 0);
+		if (ctx->q_data[MTK_Q_DATA_DST].fmt->num_planes == 2)
+			h264_dpb_info[index].c_dma_addr =
+				vb2_dma_contig_plane_dma_addr(vb, 1);
+		else
+			h264_dpb_info[index].c_dma_addr =
+				h264_dpb_info[index].y_dma_addr +
+				ctx->picinfo.fb_sz[0];
+	}
+}
+
+void mtk_vdec_h264_copy_sps_params(struct mtk_h264_sps_param *dst_param,
+	const struct v4l2_ctrl_h264_sps *src_param)
+{
+	GET_MTK_VDEC_PARAM(chroma_format_idc);
+	GET_MTK_VDEC_PARAM(bit_depth_luma_minus8);
+	GET_MTK_VDEC_PARAM(bit_depth_chroma_minus8);
+	GET_MTK_VDEC_PARAM(log2_max_frame_num_minus4);
+	GET_MTK_VDEC_PARAM(pic_order_cnt_type);
+	GET_MTK_VDEC_PARAM(log2_max_pic_order_cnt_lsb_minus4);
+	GET_MTK_VDEC_PARAM(max_num_ref_frames);
+	GET_MTK_VDEC_PARAM(pic_width_in_mbs_minus1);
+	GET_MTK_VDEC_PARAM(pic_height_in_map_units_minus1);
+
+	GET_MTK_VDEC_FLAG(separate_colour_plane_flag,
+		V4L2_H264_SPS_FLAG_SEPARATE_COLOUR_PLANE);
+	GET_MTK_VDEC_FLAG(qpprime_y_zero_transform_bypass_flag,
+		V4L2_H264_SPS_FLAG_QPPRIME_Y_ZERO_TRANSFORM_BYPASS);
+	GET_MTK_VDEC_FLAG(delta_pic_order_always_zero_flag,
+		V4L2_H264_SPS_FLAG_DELTA_PIC_ORDER_ALWAYS_ZERO);
+	GET_MTK_VDEC_FLAG(frame_mbs_only_flag,
+		V4L2_H264_SPS_FLAG_FRAME_MBS_ONLY);
+	GET_MTK_VDEC_FLAG(mb_adaptive_frame_field_flag,
+		V4L2_H264_SPS_FLAG_MB_ADAPTIVE_FRAME_FIELD);
+	GET_MTK_VDEC_FLAG(direct_8x8_inference_flag,
+		V4L2_H264_SPS_FLAG_DIRECT_8X8_INFERENCE);
+}
+
+void mtk_vdec_h264_copy_pps_params(struct mtk_h264_pps_param *dst_param,
+	const struct v4l2_ctrl_h264_pps *src_param)
+{
+	GET_MTK_VDEC_PARAM(num_ref_idx_l0_default_active_minus1);
+	GET_MTK_VDEC_PARAM(num_ref_idx_l1_default_active_minus1);
+	GET_MTK_VDEC_PARAM(weighted_bipred_idc);
+	GET_MTK_VDEC_PARAM(pic_init_qp_minus26);
+	GET_MTK_VDEC_PARAM(chroma_qp_index_offset);
+	GET_MTK_VDEC_PARAM(second_chroma_qp_index_offset);
+
+	GET_MTK_VDEC_FLAG(entropy_coding_mode_flag,
+		V4L2_H264_PPS_FLAG_ENTROPY_CODING_MODE);
+	GET_MTK_VDEC_FLAG(pic_order_present_flag,
+		V4L2_H264_PPS_FLAG_BOTTOM_FIELD_PIC_ORDER_IN_FRAME_PRESENT);
+	GET_MTK_VDEC_FLAG(weighted_pred_flag,
+		V4L2_H264_PPS_FLAG_WEIGHTED_PRED);
+	GET_MTK_VDEC_FLAG(deblocking_filter_control_present_flag,
+		V4L2_H264_PPS_FLAG_DEBLOCKING_FILTER_CONTROL_PRESENT);
+	GET_MTK_VDEC_FLAG(constrained_intra_pred_flag,
+		V4L2_H264_PPS_FLAG_CONSTRAINED_INTRA_PRED);
+	GET_MTK_VDEC_FLAG(redundant_pic_cnt_present_flag,
+		V4L2_H264_PPS_FLAG_REDUNDANT_PIC_CNT_PRESENT);
+	GET_MTK_VDEC_FLAG(transform_8x8_mode_flag,
+		V4L2_H264_PPS_FLAG_TRANSFORM_8X8_MODE);
+	GET_MTK_VDEC_FLAG(scaling_matrix_present_flag,
+		V4L2_H264_PPS_FLAG_SCALING_MATRIX_PRESENT);
+}
+
+void mtk_vdec_h264_copy_slice_hd_params(
+	struct mtk_h264_slice_hd_param *dst_param,
+	const struct v4l2_ctrl_h264_slice_params *src_param,
+	const struct v4l2_ctrl_h264_decode_params *dec_param)
+{
+	int temp;
+
+	GET_MTK_VDEC_PARAM(first_mb_in_slice);
+	GET_MTK_VDEC_PARAM(slice_type);
+	GET_MTK_VDEC_PARAM(cabac_init_idc);
+	GET_MTK_VDEC_PARAM(slice_qp_delta);
+	GET_MTK_VDEC_PARAM(disable_deblocking_filter_idc);
+	GET_MTK_VDEC_PARAM(slice_alpha_c0_offset_div2);
+	GET_MTK_VDEC_PARAM(slice_beta_offset_div2);
+	GET_MTK_VDEC_PARAM(num_ref_idx_l0_active_minus1);
+	GET_MTK_VDEC_PARAM(num_ref_idx_l1_active_minus1);
+
+	dst_param->frame_num = dec_param->frame_num;
+	dst_param->pic_order_cnt_lsb = dec_param->pic_order_cnt_lsb;
+
+	dst_param->delta_pic_order_cnt_bottom =
+		dec_param->delta_pic_order_cnt_bottom;
+	dst_param->delta_pic_order_cnt0 =
+		dec_param->delta_pic_order_cnt0;
+	dst_param->delta_pic_order_cnt1 =
+		dec_param->delta_pic_order_cnt1;
+
+	temp = dec_param->flags & V4L2_H264_DECODE_PARAM_FLAG_FIELD_PIC;
+	dst_param->field_pic_flag = temp ? 1 : 0;
+
+	temp = dec_param->flags & V4L2_H264_DECODE_PARAM_FLAG_BOTTOM_FIELD;
+	dst_param->bottom_field_flag = temp ? 1 : 0;
+
+	GET_MTK_VDEC_FLAG(direct_spatial_mv_pred_flag,
+		V4L2_H264_SLICE_FLAG_DIRECT_SPATIAL_MV_PRED);
+}
+
+void mtk_vdec_h264_copy_scaling_matrix(
+	struct slice_api_h264_scaling_matrix *dst_matrix,
+	const struct v4l2_ctrl_h264_scaling_matrix *src_matrix)
+{
+	memcpy(dst_matrix->scaling_list_4x4, src_matrix->scaling_list_4x4,
+	       sizeof(dst_matrix->scaling_list_4x4));
+
+	memcpy(dst_matrix->scaling_list_8x8, src_matrix->scaling_list_8x8,
+	       sizeof(dst_matrix->scaling_list_8x8));
+}
+
+void mtk_vdec_h264_copy_decode_params(
+	struct slice_api_h264_decode_param *dst_params,
+	const struct v4l2_ctrl_h264_decode_params *src_params,
+	const struct v4l2_h264_dpb_entry dpb[V4L2_H264_NUM_DPB_ENTRIES])
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(dst_params->dpb); i++) {
+		struct slice_h264_dpb_entry *dst_entry = &dst_params->dpb[i];
+		const struct v4l2_h264_dpb_entry *src_entry = &dpb[i];
+
+		dst_entry->reference_ts = src_entry->reference_ts;
+		dst_entry->frame_num = src_entry->frame_num;
+		dst_entry->pic_num = src_entry->pic_num;
+		dst_entry->top_field_order_cnt = src_entry->top_field_order_cnt;
+		dst_entry->bottom_field_order_cnt =
+			src_entry->bottom_field_order_cnt;
+		dst_entry->flags = src_entry->flags;
+	}
+
+	/* num_slices is a leftover from the old H.264 support and is ignored
+	 * by the firmware.
+	 */
+	dst_params->num_slices = 0;
+	dst_params->nal_ref_idc = src_params->nal_ref_idc;
+	dst_params->top_field_order_cnt = src_params->top_field_order_cnt;
+	dst_params->bottom_field_order_cnt = src_params->bottom_field_order_cnt;
+	dst_params->flags = src_params->flags;
+}
+
+static bool mtk_vdec_h264_dpb_entry_match(
+	const struct v4l2_h264_dpb_entry *a,
+	const struct v4l2_h264_dpb_entry *b)
+{
+	return a->top_field_order_cnt == b->top_field_order_cnt &&
+	       a->bottom_field_order_cnt == b->bottom_field_order_cnt;
+}
+
+/*
+ * Move DPB entries of dec_param that refer to a frame already existing in dpb
+ * into the already existing slot in dpb, and move other entries into new slots.
+ *
+ * This function is an adaptation of the similarly-named function in
+ * hantro_h264.c.
+ */
+void mtk_vdec_h264_update_dpb(const struct v4l2_ctrl_h264_decode_params *dec_param,
+	struct v4l2_h264_dpb_entry *dpb)
+{
+	DECLARE_BITMAP(new, ARRAY_SIZE(dec_param->dpb)) = { 0, };
+	DECLARE_BITMAP(in_use, ARRAY_SIZE(dec_param->dpb)) = { 0, };
+	DECLARE_BITMAP(used, ARRAY_SIZE(dec_param->dpb)) = { 0, };
+	unsigned int i, j;
+
+	/* Disable all entries by default, and mark the ones in use. */
+	for (i = 0; i < ARRAY_SIZE(dec_param->dpb); i++) {
+		if (dpb[i].flags & V4L2_H264_DPB_ENTRY_FLAG_ACTIVE)
+			set_bit(i, in_use);
+		dpb[i].flags &= ~V4L2_H264_DPB_ENTRY_FLAG_ACTIVE;
+	}
+
+	/* Try to match new DPB entries with existing ones by their POCs. */
+	for (i = 0; i < ARRAY_SIZE(dec_param->dpb); i++) {
+		const struct v4l2_h264_dpb_entry *ndpb = &dec_param->dpb[i];
+
+		if (!(ndpb->flags & V4L2_H264_DPB_ENTRY_FLAG_ACTIVE))
+			continue;
+
+		/*
+		 * To cut off some comparisons, iterate only on target DPB
+		 * entries were already used.
+		 */
+		for_each_set_bit(j, in_use, ARRAY_SIZE(dec_param->dpb)) {
+			struct v4l2_h264_dpb_entry *cdpb;
+
+			cdpb = &dpb[j];
+			if (!mtk_vdec_h264_dpb_entry_match(cdpb, ndpb))
+				continue;
+
+			*cdpb = *ndpb;
+			set_bit(j, used);
+			/* Don't reiterate on this one. */
+			clear_bit(j, in_use);
+			break;
+		}
+
+		if (j == ARRAY_SIZE(dec_param->dpb))
+			set_bit(i, new);
+	}
+
+	/* For entries that could not be matched, use remaining free slots. */
+	for_each_set_bit(i, new, ARRAY_SIZE(dec_param->dpb)) {
+		const struct v4l2_h264_dpb_entry *ndpb = &dec_param->dpb[i];
+		struct v4l2_h264_dpb_entry *cdpb;
+
+		/*
+		 * Both arrays are of the same sizes, so there is no way
+		 * we can end up with no space in target array, unless
+		 * something is buggy.
+		 */
+		j = find_first_zero_bit(used, ARRAY_SIZE(dec_param->dpb));
+		if (WARN_ON(j >= ARRAY_SIZE(dec_param->dpb)))
+			return;
+
+		cdpb = &dpb[j];
+		*cdpb = *ndpb;
+		set_bit(j, used);
+	}
+}
+
+unsigned int mtk_vdec_h264_get_mv_buf_size(
+	unsigned int width, unsigned int height)
+{
+	int unit_size = (width / MB_UNIT_LEN) * (height / MB_UNIT_LEN) + 8;
+
+	return HW_MB_STORE_SZ * unit_size;
+}
+
+int mtk_vdec_h264_find_start_code(unsigned char *data, unsigned int data_sz)
+{
+	if (data_sz > 3 && data[0] == 0 && data[1] == 0 && data[2] == 1)
+		return 3;
+
+	if (data_sz > 4 && data[0] == 0 && data[1] == 0 && data[2] == 0 &&
+	    data[3] == 1)
+		return 4;
+
+	return -1;
+}
diff --git a/drivers/media/platform/mtk-vcodec/vdec/vdec_h264_req_common.h b/drivers/media/platform/mtk-vcodec/vdec/vdec_h264_req_common.h
new file mode 100644
index 0000000000000000000000000000000000000000..f4f438f10e107e93634962dc33492078ec83ee1c
--- /dev/null
+++ b/drivers/media/platform/mtk-vcodec/vdec/vdec_h264_req_common.h
@@ -0,0 +1,250 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2021 MediaTek Inc.
+ * Author: Yunfei Dong <yunfei.dong@mediatek.com>
+ */
+
+#ifndef _VDEC_H264_REQ_COMMON_H_
+#define _VDEC_H264_REQ_COMMON_H_
+
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <media/v4l2-h264.h>
+#include <media/v4l2-mem2mem.h>
+#include <media/videobuf2-dma-contig.h>
+
+#include "../mtk_vcodec_dec.h"
+#include "../vdec_drv_if.h"
+#include "../vdec_msg_queue.h"
+#include "../vdec_vpu_if.h"
+
+#define NAL_NON_IDR_SLICE			0x01
+#define NAL_IDR_SLICE				0x05
+#define NAL_TYPE(value)				((value) & 0x1F)
+
+#define BUF_PREDICTION_SZ			(64 * 4096)
+#define MB_UNIT_LEN				16
+
+/* motion vector size (bytes) for every macro block */
+#define HW_MB_STORE_SZ				64
+
+#define H264_MAX_MV_NUM				32
+
+/**
+ * struct mtk_h264_dpb_info  - h264 dpb information
+ * @y_dma_addr: Y bitstream physical address
+ * @c_dma_addr: CbCr bitstream physical address
+ * @reference_flag: reference picture flag (short/long term reference picture)
+ * @field: field picture flag
+ */
+struct mtk_h264_dpb_info {
+	dma_addr_t y_dma_addr;
+	dma_addr_t c_dma_addr;
+	int reference_flag;
+	int field;
+};
+
+/**
+ * struct mtk_h264_sps_param  - parameters for sps
+ */
+struct mtk_h264_sps_param {
+	unsigned char chroma_format_idc;
+	unsigned char bit_depth_luma_minus8;
+	unsigned char bit_depth_chroma_minus8;
+	unsigned char log2_max_frame_num_minus4;
+	unsigned char pic_order_cnt_type;
+	unsigned char log2_max_pic_order_cnt_lsb_minus4;
+	unsigned char max_num_ref_frames;
+	unsigned char separate_colour_plane_flag;
+	unsigned short pic_width_in_mbs_minus1;
+	unsigned short pic_height_in_map_units_minus1;
+	unsigned int max_frame_nums;
+	unsigned char qpprime_y_zero_transform_bypass_flag;
+	unsigned char delta_pic_order_always_zero_flag;
+	unsigned char frame_mbs_only_flag;
+	unsigned char mb_adaptive_frame_field_flag;
+	unsigned char direct_8x8_inference_flag;
+	unsigned char reserved[3];
+};
+
+/**
+ * struct mtk_h264_pps_param  - parameters for pps
+ */
+struct mtk_h264_pps_param {
+	unsigned char num_ref_idx_l0_default_active_minus1;
+	unsigned char num_ref_idx_l1_default_active_minus1;
+	unsigned char weighted_bipred_idc;
+	char pic_init_qp_minus26;
+	char chroma_qp_index_offset;
+	char second_chroma_qp_index_offset;
+	unsigned char entropy_coding_mode_flag;
+	unsigned char pic_order_present_flag;
+	unsigned char deblocking_filter_control_present_flag;
+	unsigned char constrained_intra_pred_flag;
+	unsigned char weighted_pred_flag;
+	unsigned char redundant_pic_cnt_present_flag;
+	unsigned char transform_8x8_mode_flag;
+	unsigned char scaling_matrix_present_flag;
+	unsigned char reserved[2];
+};
+
+/**
+ * struct mtk_h264_slice_hd_param  - parameters for slice header
+ */
+struct mtk_h264_slice_hd_param {
+	unsigned int first_mb_in_slice;
+	unsigned int field_pic_flag;
+	unsigned int slice_type;
+	unsigned int frame_num;
+	int pic_order_cnt_lsb;
+	int delta_pic_order_cnt_bottom;
+	unsigned int bottom_field_flag;
+	unsigned int direct_spatial_mv_pred_flag;
+	int delta_pic_order_cnt0;
+	int delta_pic_order_cnt1;
+	unsigned int cabac_init_idc;
+	int slice_qp_delta;
+	unsigned int disable_deblocking_filter_idc;
+	int slice_alpha_c0_offset_div2;
+	int slice_beta_offset_div2;
+	unsigned int num_ref_idx_l0_active_minus1;
+	unsigned int num_ref_idx_l1_active_minus1;
+	unsigned int reserved;
+};
+
+struct slice_api_h264_scaling_matrix {
+	unsigned char scaling_list_4x4[6][16];
+	unsigned char scaling_list_8x8[6][64];
+};
+
+struct slice_h264_dpb_entry {
+	unsigned long long reference_ts;
+	unsigned short frame_num;
+	unsigned short pic_num;
+	/* Note that field is indicated by v4l2_buffer.field */
+	int top_field_order_cnt;
+	int bottom_field_order_cnt;
+	unsigned int flags; /* V4L2_H264_DPB_ENTRY_FLAG_* */
+};
+
+/**
+ * struct slice_api_h264_decode_param - parameters for decode.
+ */
+struct slice_api_h264_decode_param {
+	struct slice_h264_dpb_entry dpb[V4L2_H264_NUM_DPB_ENTRIES];
+	unsigned short num_slices;
+	unsigned short nal_ref_idc;
+	unsigned char ref_pic_list_p0[32];
+	unsigned char ref_pic_list_b0[32];
+	unsigned char ref_pic_list_b1[32];
+	int top_field_order_cnt;
+	int bottom_field_order_cnt;
+	unsigned int flags; /* V4L2_H264_DECODE_PARAM_FLAG_* */
+};
+
+/**
+ * struct h264_fb - h264 decode frame buffer information
+ * @vdec_fb_va  : virtual address of struct vdec_fb
+ * @y_fb_dma    : dma address of Y frame buffer (luma)
+ * @c_fb_dma    : dma address of C frame buffer (chroma)
+ * @poc         : picture order count of frame buffer
+ * @reserved    : for 8 bytes alignment
+ */
+struct h264_fb {
+	uint64_t vdec_fb_va;
+	uint64_t y_fb_dma;
+	uint64_t c_fb_dma;
+	int32_t poc;
+	uint32_t reserved;
+};
+
+/**
+ * mtk_vdec_h264_get_ctrl_ptr - get each CID contrl address.
+ * @ctx: v4l2 ctx
+ * @id: CID control ID
+ */
+void *mtk_vdec_h264_get_ctrl_ptr(struct mtk_vcodec_ctx *ctx, int id);
+
+/**
+ * mtk_vdec_h264_fill_dpb_info - get each CID contrl address.
+ * @ctx: v4l2 ctx
+ * @decode_params: slice decode params
+ * @h264_dpb_info: dpb buffer information
+ */
+void mtk_vdec_h264_fill_dpb_info(struct mtk_vcodec_ctx *ctx,
+	struct slice_api_h264_decode_param *decode_params,
+	struct mtk_h264_dpb_info *h264_dpb_info);
+
+/**
+ * mtk_vdec_h264_copy_sps_params - get sps params.
+ * @dst_params: sps params for hw decoder
+ * @src_params: sps params from user driver
+ */
+void mtk_vdec_h264_copy_sps_params(struct mtk_h264_sps_param *dst_param,
+	const struct v4l2_ctrl_h264_sps *src_param);
+
+/**
+ * mtk_vdec_h264_copy_pps_params - get pps params.
+ * @dst_params: pps params for hw decoder
+ * @src_params: pps params from user driver
+ */
+void mtk_vdec_h264_copy_pps_params(struct mtk_h264_pps_param *dst_param,
+	const struct v4l2_ctrl_h264_pps *src_param);
+
+/**
+ * mtk_vdec_h264_copy_slice_hd_params - get slice header params.
+ * @dst_params: slice params for hw decoder
+ * @src_params: slice params from user driver
+ * @dec_param: decode params from user driver
+ */
+void mtk_vdec_h264_copy_slice_hd_params(
+	struct mtk_h264_slice_hd_param *dst_param,
+	const struct v4l2_ctrl_h264_slice_params *src_param,
+	const struct v4l2_ctrl_h264_decode_params *dec_param);
+
+/**
+ * mtk_vdec_h264_copy_scaling_matrix - get each CID contrl address.
+ * @dst_matrix: scaling list params for hw decoder
+ * @src_matrix: scaling list params from user driver
+ */
+void mtk_vdec_h264_copy_scaling_matrix(
+	struct slice_api_h264_scaling_matrix *dst_matrix,
+	const struct v4l2_ctrl_h264_scaling_matrix *src_matrix);
+
+/**
+ * mtk_vdec_h264_copy_decode_params - get decode params.
+ * @dst_params: dst params for hw decoder
+ * @src_params: decode params from user driver
+ * @dpb: dpb information
+ */
+void mtk_vdec_h264_copy_decode_params(
+	struct slice_api_h264_decode_param *dst_params,
+	const struct v4l2_ctrl_h264_decode_params *src_params,
+	const struct v4l2_h264_dpb_entry dpb[V4L2_H264_NUM_DPB_ENTRIES]);
+
+
+/**
+ * mtk_vdec_h264_update_dpb - updata dpb list.
+ * @dec_param: v4l2 control decode params
+ * @dpb: dpb entry informaton
+ */
+void mtk_vdec_h264_update_dpb(
+	const struct v4l2_ctrl_h264_decode_params *dec_param,
+	struct v4l2_h264_dpb_entry *dpb);
+
+/**
+ * mtk_vdec_h264_find_start_code - find h264 start code using sofeware.
+ * @data: input buffer address
+ * @data_sz: input buffer size
+ */
+int mtk_vdec_h264_find_start_code(unsigned char *data, unsigned int data_sz);
+
+/**
+ * mtk_vdec_h264_get_mv_buf_size - get mv buffer size.
+ * @width: picture width
+ * @height: picture height
+ */
+unsigned int mtk_vdec_h264_get_mv_buf_size(
+	unsigned int width, unsigned int height);
+
+#endif
diff --git a/drivers/media/platform/mtk-vcodec/vdec/vdec_h264_req_if.c b/drivers/media/platform/mtk-vcodec/vdec/vdec_h264_req_if.c
index 8ec8da469ef3abf6b025f64dd84413902c99c1d0..715e00b6428f4c988ea8292084ff3731535de020 100644
--- a/drivers/media/platform/mtk-vcodec/vdec/vdec_h264_req_if.c
+++ b/drivers/media/platform/mtk-vcodec/vdec/vdec_h264_req_if.c
@@ -12,109 +12,7 @@
 #include "../mtk_vcodec_intr.h"
 #include "../vdec_vpu_if.h"
 #include "../vdec_drv_base.h"
-
-#define BUF_PREDICTION_SZ			(64 * 4096)
-#define MB_UNIT_LEN				16
-
-/* get used parameters for sps/pps */
-#define GET_MTK_VDEC_FLAG(cond, flag) \
-	{ dst_param->cond = ((src_param->flags & flag) ? (1) : (0)); }
-#define GET_MTK_VDEC_PARAM(param) \
-	{ dst_param->param = src_param->param; }
-/* motion vector size (bytes) for every macro block */
-#define HW_MB_STORE_SZ				64
-
-#define H264_MAX_FB_NUM				17
-#define H264_MAX_MV_NUM				32
-#define HDR_PARSING_BUF_SZ			1024
-
-/**
- * struct mtk_h264_dpb_info  - h264 dpb information
- * @y_dma_addr: Y bitstream physical address
- * @c_dma_addr: CbCr bitstream physical address
- * @reference_flag: reference picture flag (short/long term reference picture)
- * @field: field picture flag
- */
-struct mtk_h264_dpb_info {
-	dma_addr_t y_dma_addr;
-	dma_addr_t c_dma_addr;
-	int reference_flag;
-	int field;
-};
-
-/**
- * struct mtk_h264_sps_param  - parameters for sps
- */
-struct mtk_h264_sps_param {
-	unsigned char chroma_format_idc;
-	unsigned char bit_depth_luma_minus8;
-	unsigned char bit_depth_chroma_minus8;
-	unsigned char log2_max_frame_num_minus4;
-	unsigned char pic_order_cnt_type;
-	unsigned char log2_max_pic_order_cnt_lsb_minus4;
-	unsigned char max_num_ref_frames;
-	unsigned char separate_colour_plane_flag;
-	unsigned short pic_width_in_mbs_minus1;
-	unsigned short pic_height_in_map_units_minus1;
-	unsigned int max_frame_nums;
-	unsigned char qpprime_y_zero_transform_bypass_flag;
-	unsigned char delta_pic_order_always_zero_flag;
-	unsigned char frame_mbs_only_flag;
-	unsigned char mb_adaptive_frame_field_flag;
-	unsigned char direct_8x8_inference_flag;
-	unsigned char reserved[3];
-};
-
-/**
- * struct mtk_h264_pps_param  - parameters for pps
- */
-struct mtk_h264_pps_param {
-	unsigned char num_ref_idx_l0_default_active_minus1;
-	unsigned char num_ref_idx_l1_default_active_minus1;
-	unsigned char weighted_bipred_idc;
-	char pic_init_qp_minus26;
-	char chroma_qp_index_offset;
-	char second_chroma_qp_index_offset;
-	unsigned char entropy_coding_mode_flag;
-	unsigned char pic_order_present_flag;
-	unsigned char deblocking_filter_control_present_flag;
-	unsigned char constrained_intra_pred_flag;
-	unsigned char weighted_pred_flag;
-	unsigned char redundant_pic_cnt_present_flag;
-	unsigned char transform_8x8_mode_flag;
-	unsigned char scaling_matrix_present_flag;
-	unsigned char reserved[2];
-};
-
-struct slice_api_h264_scaling_matrix {
-	unsigned char scaling_list_4x4[6][16];
-	unsigned char scaling_list_8x8[6][64];
-};
-
-struct slice_h264_dpb_entry {
-	unsigned long long reference_ts;
-	unsigned short frame_num;
-	unsigned short pic_num;
-	/* Note that field is indicated by v4l2_buffer.field */
-	int top_field_order_cnt;
-	int bottom_field_order_cnt;
-	unsigned int flags; /* V4L2_H264_DPB_ENTRY_FLAG_* */
-};
-
-/**
- * struct slice_api_h264_decode_param - parameters for decode.
- */
-struct slice_api_h264_decode_param {
-	struct slice_h264_dpb_entry dpb[16];
-	unsigned short num_slices;
-	unsigned short nal_ref_idc;
-	unsigned char ref_pic_list_p0[32];
-	unsigned char ref_pic_list_b0[32];
-	unsigned char ref_pic_list_b1[32];
-	int top_field_order_cnt;
-	int bottom_field_order_cnt;
-	unsigned int flags; /* V4L2_H264_DECODE_PARAM_FLAG_* */
-};
+#include "vdec_h264_req_common.h"
 
 /**
  * struct mtk_h264_dec_slice_param  - parameters for decode current frame
@@ -124,23 +22,7 @@ struct mtk_h264_dec_slice_param {
 	struct mtk_h264_pps_param			pps;
 	struct slice_api_h264_scaling_matrix		scaling_matrix;
 	struct slice_api_h264_decode_param		decode_params;
-	struct mtk_h264_dpb_info h264_dpb_info[16];
-};
-
-/**
- * struct h264_fb - h264 decode frame buffer information
- * @vdec_fb_va  : virtual address of struct vdec_fb
- * @y_fb_dma    : dma address of Y frame buffer (luma)
- * @c_fb_dma    : dma address of C frame buffer (chroma)
- * @poc         : picture order count of frame buffer
- * @reserved    : for 8 bytes alignment
- */
-struct h264_fb {
-	uint64_t vdec_fb_va;
-	uint64_t y_fb_dma;
-	uint64_t c_fb_dma;
-	int32_t poc;
-	uint32_t reserved;
+	struct mtk_h264_dpb_info h264_dpb_info[V4L2_H264_NUM_DPB_ENTRIES];
 };
 
 /**
@@ -209,235 +91,6 @@ struct vdec_h264_slice_inst {
 	struct v4l2_h264_dpb_entry dpb[16];
 };
 
-static void *get_ctrl_ptr(struct mtk_vcodec_ctx *ctx,
-				 int id)
-{
-	struct v4l2_ctrl *ctrl = v4l2_ctrl_find(&ctx->ctrl_hdl, id);
-
-	return ctrl->p_cur.p;
-}
-
-static void get_h264_dpb_list(struct vdec_h264_slice_inst *inst,
-			      struct mtk_h264_dec_slice_param *slice_param)
-{
-	struct vb2_queue *vq;
-	struct vb2_buffer *vb;
-	struct vb2_v4l2_buffer *vb2_v4l2;
-	u64 index;
-
-	vq = v4l2_m2m_get_vq(inst->ctx->m2m_ctx,
-		V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE);
-
-	for (index = 0; index < ARRAY_SIZE(slice_param->decode_params.dpb); index++) {
-		const struct slice_h264_dpb_entry *dpb;
-		int vb2_index;
-
-		dpb = &slice_param->decode_params.dpb[index];
-		if (!(dpb->flags & V4L2_H264_DPB_ENTRY_FLAG_ACTIVE)) {
-			slice_param->h264_dpb_info[index].reference_flag = 0;
-			continue;
-		}
-
-		vb2_index = vb2_find_timestamp(vq, dpb->reference_ts, 0);
-		if (vb2_index < 0) {
-			mtk_vcodec_err(inst, "Reference invalid: dpb_index(%lld) reference_ts(%lld)",
-				index, dpb->reference_ts);
-			continue;
-		}
-		/* 1 for short term reference, 2 for long term reference */
-		if (!(dpb->flags & V4L2_H264_DPB_ENTRY_FLAG_LONG_TERM))
-			slice_param->h264_dpb_info[index].reference_flag = 1;
-		else
-			slice_param->h264_dpb_info[index].reference_flag = 2;
-
-		vb = vq->bufs[vb2_index];
-		vb2_v4l2 = container_of(vb, struct vb2_v4l2_buffer, vb2_buf);
-		slice_param->h264_dpb_info[index].field = vb2_v4l2->field;
-
-		slice_param->h264_dpb_info[index].y_dma_addr =
-			vb2_dma_contig_plane_dma_addr(vb, 0);
-		if (inst->ctx->q_data[MTK_Q_DATA_DST].fmt->num_planes == 2) {
-			slice_param->h264_dpb_info[index].c_dma_addr =
-				vb2_dma_contig_plane_dma_addr(vb, 1);
-		}
-	}
-}
-
-static void get_h264_sps_parameters(struct mtk_h264_sps_param *dst_param,
-	const struct v4l2_ctrl_h264_sps *src_param)
-{
-	GET_MTK_VDEC_PARAM(chroma_format_idc);
-	GET_MTK_VDEC_PARAM(bit_depth_luma_minus8);
-	GET_MTK_VDEC_PARAM(bit_depth_chroma_minus8);
-	GET_MTK_VDEC_PARAM(log2_max_frame_num_minus4);
-	GET_MTK_VDEC_PARAM(pic_order_cnt_type);
-	GET_MTK_VDEC_PARAM(log2_max_pic_order_cnt_lsb_minus4);
-	GET_MTK_VDEC_PARAM(max_num_ref_frames);
-	GET_MTK_VDEC_PARAM(pic_width_in_mbs_minus1);
-	GET_MTK_VDEC_PARAM(pic_height_in_map_units_minus1);
-
-	GET_MTK_VDEC_FLAG(separate_colour_plane_flag,
-		V4L2_H264_SPS_FLAG_SEPARATE_COLOUR_PLANE);
-	GET_MTK_VDEC_FLAG(qpprime_y_zero_transform_bypass_flag,
-		V4L2_H264_SPS_FLAG_QPPRIME_Y_ZERO_TRANSFORM_BYPASS);
-	GET_MTK_VDEC_FLAG(delta_pic_order_always_zero_flag,
-		V4L2_H264_SPS_FLAG_DELTA_PIC_ORDER_ALWAYS_ZERO);
-	GET_MTK_VDEC_FLAG(frame_mbs_only_flag,
-		V4L2_H264_SPS_FLAG_FRAME_MBS_ONLY);
-	GET_MTK_VDEC_FLAG(mb_adaptive_frame_field_flag,
-		V4L2_H264_SPS_FLAG_MB_ADAPTIVE_FRAME_FIELD);
-	GET_MTK_VDEC_FLAG(direct_8x8_inference_flag,
-		V4L2_H264_SPS_FLAG_DIRECT_8X8_INFERENCE);
-}
-
-static void get_h264_pps_parameters(struct mtk_h264_pps_param *dst_param,
-	const struct v4l2_ctrl_h264_pps *src_param)
-{
-	GET_MTK_VDEC_PARAM(num_ref_idx_l0_default_active_minus1);
-	GET_MTK_VDEC_PARAM(num_ref_idx_l1_default_active_minus1);
-	GET_MTK_VDEC_PARAM(weighted_bipred_idc);
-	GET_MTK_VDEC_PARAM(pic_init_qp_minus26);
-	GET_MTK_VDEC_PARAM(chroma_qp_index_offset);
-	GET_MTK_VDEC_PARAM(second_chroma_qp_index_offset);
-
-	GET_MTK_VDEC_FLAG(entropy_coding_mode_flag,
-		V4L2_H264_PPS_FLAG_ENTROPY_CODING_MODE);
-	GET_MTK_VDEC_FLAG(pic_order_present_flag,
-		V4L2_H264_PPS_FLAG_BOTTOM_FIELD_PIC_ORDER_IN_FRAME_PRESENT);
-	GET_MTK_VDEC_FLAG(weighted_pred_flag,
-		V4L2_H264_PPS_FLAG_WEIGHTED_PRED);
-	GET_MTK_VDEC_FLAG(deblocking_filter_control_present_flag,
-		V4L2_H264_PPS_FLAG_DEBLOCKING_FILTER_CONTROL_PRESENT);
-	GET_MTK_VDEC_FLAG(constrained_intra_pred_flag,
-		V4L2_H264_PPS_FLAG_CONSTRAINED_INTRA_PRED);
-	GET_MTK_VDEC_FLAG(redundant_pic_cnt_present_flag,
-		V4L2_H264_PPS_FLAG_REDUNDANT_PIC_CNT_PRESENT);
-	GET_MTK_VDEC_FLAG(transform_8x8_mode_flag,
-		V4L2_H264_PPS_FLAG_TRANSFORM_8X8_MODE);
-	GET_MTK_VDEC_FLAG(scaling_matrix_present_flag,
-		V4L2_H264_PPS_FLAG_SCALING_MATRIX_PRESENT);
-}
-
-static void
-get_h264_scaling_matrix(struct slice_api_h264_scaling_matrix *dst_matrix,
-			const struct v4l2_ctrl_h264_scaling_matrix *src_matrix)
-{
-	memcpy(dst_matrix->scaling_list_4x4, src_matrix->scaling_list_4x4,
-	       sizeof(dst_matrix->scaling_list_4x4));
-
-	memcpy(dst_matrix->scaling_list_8x8, src_matrix->scaling_list_8x8,
-	       sizeof(dst_matrix->scaling_list_8x8));
-}
-
-static void get_h264_decode_parameters(
-	struct slice_api_h264_decode_param *dst_params,
-	const struct v4l2_ctrl_h264_decode_params *src_params,
-	const struct v4l2_h264_dpb_entry dpb[V4L2_H264_NUM_DPB_ENTRIES])
-{
-	int i;
-
-	for (i = 0; i < ARRAY_SIZE(dst_params->dpb); i++) {
-		struct slice_h264_dpb_entry *dst_entry = &dst_params->dpb[i];
-		const struct v4l2_h264_dpb_entry *src_entry = &dpb[i];
-
-		dst_entry->reference_ts = src_entry->reference_ts;
-		dst_entry->frame_num = src_entry->frame_num;
-		dst_entry->pic_num = src_entry->pic_num;
-		dst_entry->top_field_order_cnt = src_entry->top_field_order_cnt;
-		dst_entry->bottom_field_order_cnt =
-			src_entry->bottom_field_order_cnt;
-		dst_entry->flags = src_entry->flags;
-	}
-
-	/*
-	 * num_slices is a leftover from the old H.264 support and is ignored
-	 * by the firmware.
-	 */
-	dst_params->num_slices = 0;
-	dst_params->nal_ref_idc = src_params->nal_ref_idc;
-	dst_params->top_field_order_cnt = src_params->top_field_order_cnt;
-	dst_params->bottom_field_order_cnt = src_params->bottom_field_order_cnt;
-	dst_params->flags = src_params->flags;
-}
-
-static bool dpb_entry_match(const struct v4l2_h264_dpb_entry *a,
-			    const struct v4l2_h264_dpb_entry *b)
-{
-	return a->top_field_order_cnt == b->top_field_order_cnt &&
-	       a->bottom_field_order_cnt == b->bottom_field_order_cnt;
-}
-
-/*
- * Move DPB entries of dec_param that refer to a frame already existing in dpb
- * into the already existing slot in dpb, and move other entries into new slots.
- *
- * This function is an adaptation of the similarly-named function in
- * hantro_h264.c.
- */
-static void update_dpb(const struct v4l2_ctrl_h264_decode_params *dec_param,
-		       struct v4l2_h264_dpb_entry *dpb)
-{
-	DECLARE_BITMAP(new, ARRAY_SIZE(dec_param->dpb)) = { 0, };
-	DECLARE_BITMAP(in_use, ARRAY_SIZE(dec_param->dpb)) = { 0, };
-	DECLARE_BITMAP(used, ARRAY_SIZE(dec_param->dpb)) = { 0, };
-	unsigned int i, j;
-
-	/* Disable all entries by default, and mark the ones in use. */
-	for (i = 0; i < ARRAY_SIZE(dec_param->dpb); i++) {
-		if (dpb[i].flags & V4L2_H264_DPB_ENTRY_FLAG_ACTIVE)
-			set_bit(i, in_use);
-		dpb[i].flags &= ~V4L2_H264_DPB_ENTRY_FLAG_ACTIVE;
-	}
-
-	/* Try to match new DPB entries with existing ones by their POCs. */
-	for (i = 0; i < ARRAY_SIZE(dec_param->dpb); i++) {
-		const struct v4l2_h264_dpb_entry *ndpb = &dec_param->dpb[i];
-
-		if (!(ndpb->flags & V4L2_H264_DPB_ENTRY_FLAG_ACTIVE))
-			continue;
-
-		/*
-		 * To cut off some comparisons, iterate only on target DPB
-		 * entries were already used.
-		 */
-		for_each_set_bit(j, in_use, ARRAY_SIZE(dec_param->dpb)) {
-			struct v4l2_h264_dpb_entry *cdpb;
-
-			cdpb = &dpb[j];
-			if (!dpb_entry_match(cdpb, ndpb))
-				continue;
-
-			*cdpb = *ndpb;
-			set_bit(j, used);
-			/* Don't reiterate on this one. */
-			clear_bit(j, in_use);
-			break;
-		}
-
-		if (j == ARRAY_SIZE(dec_param->dpb))
-			set_bit(i, new);
-	}
-
-	/* For entries that could not be matched, use remaining free slots. */
-	for_each_set_bit(i, new, ARRAY_SIZE(dec_param->dpb)) {
-		const struct v4l2_h264_dpb_entry *ndpb = &dec_param->dpb[i];
-		struct v4l2_h264_dpb_entry *cdpb;
-
-		/*
-		 * Both arrays are of the same sizes, so there is no way
-		 * we can end up with no space in target array, unless
-		 * something is buggy.
-		 */
-		j = find_first_zero_bit(used, ARRAY_SIZE(dec_param->dpb));
-		if (WARN_ON(j >= ARRAY_SIZE(dec_param->dpb)))
-			return;
-
-		cdpb = &dpb[j];
-		*cdpb = *ndpb;
-		set_bit(j, used);
-	}
-}
-
 /*
  * The firmware expects unused reflist entries to have the value 0x20.
  */
@@ -449,27 +102,32 @@ static void fixup_ref_list(u8 *ref_list, size_t num_valid)
 static void get_vdec_decode_parameters(struct vdec_h264_slice_inst *inst)
 {
 	const struct v4l2_ctrl_h264_decode_params *dec_params =
-		get_ctrl_ptr(inst->ctx, V4L2_CID_STATELESS_H264_DECODE_PARAMS);
+		mtk_vdec_h264_get_ctrl_ptr(inst->ctx,
+		V4L2_CID_STATELESS_H264_DECODE_PARAMS);
 	const struct v4l2_ctrl_h264_sps *sps =
-		get_ctrl_ptr(inst->ctx, V4L2_CID_STATELESS_H264_SPS);
+		mtk_vdec_h264_get_ctrl_ptr(inst->ctx,
+		V4L2_CID_STATELESS_H264_SPS);
 	const struct v4l2_ctrl_h264_pps *pps =
-		get_ctrl_ptr(inst->ctx, V4L2_CID_STATELESS_H264_PPS);
+		mtk_vdec_h264_get_ctrl_ptr(inst->ctx, V4L2_CID_STATELESS_H264_PPS);
 	const struct v4l2_ctrl_h264_scaling_matrix *scaling_matrix =
-		get_ctrl_ptr(inst->ctx, V4L2_CID_STATELESS_H264_SCALING_MATRIX);
+		mtk_vdec_h264_get_ctrl_ptr(inst->ctx,
+		V4L2_CID_STATELESS_H264_SCALING_MATRIX);
 	struct mtk_h264_dec_slice_param *slice_param = &inst->h264_slice_param;
 	struct v4l2_h264_reflist_builder reflist_builder;
 	u8 *p0_reflist = slice_param->decode_params.ref_pic_list_p0;
 	u8 *b0_reflist = slice_param->decode_params.ref_pic_list_b0;
 	u8 *b1_reflist = slice_param->decode_params.ref_pic_list_b1;
 
-	update_dpb(dec_params, inst->dpb);
+	mtk_vdec_h264_update_dpb(dec_params, inst->dpb);
 
-	get_h264_sps_parameters(&slice_param->sps, sps);
-	get_h264_pps_parameters(&slice_param->pps, pps);
-	get_h264_scaling_matrix(&slice_param->scaling_matrix, scaling_matrix);
-	get_h264_decode_parameters(&slice_param->decode_params, dec_params,
-				   inst->dpb);
-	get_h264_dpb_list(inst, slice_param);
+	mtk_vdec_h264_copy_sps_params(&slice_param->sps, sps);
+	mtk_vdec_h264_copy_pps_params(&slice_param->pps, pps);
+	mtk_vdec_h264_copy_scaling_matrix(&slice_param->scaling_matrix,
+		scaling_matrix);
+	mtk_vdec_h264_copy_decode_params(&slice_param->decode_params,
+		dec_params, inst->dpb);
+	mtk_vdec_h264_fill_dpb_info(inst->ctx, &slice_param->decode_params,
+		slice_param->h264_dpb_info);
 
 	/* Build the reference lists */
 	v4l2_h264_init_reflist_builder(&reflist_builder, dec_params, sps,
@@ -485,13 +143,6 @@ static void get_vdec_decode_parameters(struct vdec_h264_slice_inst *inst)
 	       sizeof(inst->vsi_ctx.h264_slice_params));
 }
 
-static unsigned int get_mv_buf_size(unsigned int width, unsigned int height)
-{
-	int unit_size = (width / MB_UNIT_LEN) * (height / MB_UNIT_LEN) + 8;
-
-	return HW_MB_STORE_SZ * unit_size;
-}
-
 static int allocate_predication_buf(struct vdec_h264_slice_inst *inst)
 {
 	int err = 0;
@@ -525,7 +176,8 @@ static int alloc_mv_buf(struct vdec_h264_slice_inst *inst,
 	int i;
 	int err;
 	struct mtk_vcodec_mem *mem = NULL;
-	unsigned int buf_sz = get_mv_buf_size(pic->buf_w, pic->buf_h);
+	unsigned int buf_sz = mtk_vdec_h264_get_mv_buf_size(
+		pic->buf_w, pic->buf_h);
 
 	mtk_v4l2_debug(3, "size = 0x%lx", buf_sz);
 	for (i = 0; i < H264_MAX_MV_NUM; i++) {
@@ -673,33 +325,44 @@ static void vdec_h264_slice_deinit(void *h_vdec)
 }
 
 static int vdec_h264_slice_decode(void *h_vdec, struct mtk_vcodec_mem *bs,
-				  struct vdec_fb *fb, bool *res_chg)
+				  struct vdec_fb *unused, bool *res_chg)
 {
 	struct vdec_h264_slice_inst *inst =
 		(struct vdec_h264_slice_inst *)h_vdec;
 	const struct v4l2_ctrl_h264_decode_params *dec_params =
-		get_ctrl_ptr(inst->ctx, V4L2_CID_STATELESS_H264_DECODE_PARAMS);
+		mtk_vdec_h264_get_ctrl_ptr(inst->ctx,
+		V4L2_CID_STATELESS_H264_DECODE_PARAMS);
 	struct vdec_vpu_inst *vpu = &inst->vpu;
+	struct mtk_video_dec_buf *src_buf_info;
+	struct mtk_video_dec_buf *dst_buf_info;
+	struct vdec_fb *fb;
 	uint32_t data[2];
 	uint64_t y_fb_dma;
 	uint64_t c_fb_dma;
 	int err;
 
-	mtk_vcodec_debug(inst, "+ [%d] FB y_dma=%llx c_dma=%llx va=%p",
-			 ++inst->num_nalu, y_fb_dma, c_fb_dma, fb);
+	inst->num_nalu++;
 
 	/* bs NULL means flush decoder */
-	if (bs == NULL)
+	if (!bs)
 		return vpu_dec_reset(vpu);
 
+	fb = inst->ctx->dev->vdec_pdata->get_cap_buffer(inst->ctx);
+	src_buf_info = container_of(bs, struct mtk_video_dec_buf, bs_buffer);
+	dst_buf_info = container_of(fb, struct mtk_video_dec_buf, frame_buffer);
+
 	y_fb_dma = fb ? (u64)fb->base_y.dma_addr : 0;
 	c_fb_dma = fb ? (u64)fb->base_c.dma_addr : 0;
+	mtk_vcodec_debug(inst, "+ [%d] FB y_dma=%llx c_dma=%llx va=%p",
+		inst->num_nalu, y_fb_dma, c_fb_dma, fb);
 
 	inst->vsi_ctx.dec.bs_dma = (uint64_t)bs->dma_addr;
 	inst->vsi_ctx.dec.y_fb_dma = y_fb_dma;
 	inst->vsi_ctx.dec.c_fb_dma = c_fb_dma;
 	inst->vsi_ctx.dec.vdec_fb_va = (u64)(uintptr_t)fb;
 
+	v4l2_m2m_buf_copy_metadata(&src_buf_info->m2m_buf.vb,
+		&dst_buf_info->m2m_buf.vb, true);
 	get_vdec_decode_parameters(inst);
 	data[0] = bs->size;
 	/*
@@ -737,7 +400,9 @@ static int vdec_h264_slice_decode(void *h_vdec, struct mtk_vcodec_mem *bs,
 	vpu_dec_end(vpu);
 
 	memcpy(&inst->vsi_ctx, inst->vpu.vsi, sizeof(inst->vsi_ctx));
-	mtk_vcodec_debug(inst, "\n - NALU[%d] -\n", inst->num_nalu, nal_type);
+	mtk_vcodec_debug(inst, "\n - NALU[%d] type=%d -\n", inst->num_nalu);
+
+	inst->ctx->dev->vdec_pdata->cap_to_disp(inst->ctx, fb, 0);
 	return 0;
 
 err_free_fb_out:
diff --git a/drivers/media/platform/mtk-vcodec/vdec/vdec_h264_req_lat_if.c b/drivers/media/platform/mtk-vcodec/vdec/vdec_h264_req_lat_if.c
new file mode 100644
index 0000000000000000000000000000000000000000..f2d568d3536160d3971f14a229237e557ba6cd93
--- /dev/null
+++ b/drivers/media/platform/mtk-vcodec/vdec/vdec_h264_req_lat_if.c
@@ -0,0 +1,638 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2021 MediaTek Inc.
+ * Author: Yunfei Dong <yunfei.dong@mediatek.com>
+ */
+
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <media/v4l2-h264.h>
+#include <media/v4l2-mem2mem.h>
+#include <media/videobuf2-dma-contig.h>
+
+#include "../mtk_vcodec_dec.h"
+#include "../mtk_vcodec_intr.h"
+#include "../mtk_vcodec_util.h"
+#include "../vdec_drv_base.h"
+#include "../vdec_drv_if.h"
+#include "vdec_h264_req_common.h"
+#include "../vdec_msg_queue.h"
+#include "../vdec_vpu_if.h"
+
+/**
+ * enum vdec_h264_dec_err_type  - core decode error type
+ */
+enum vdec_h264_core_dec_err_type {
+	TRANS_BUFFER_FULL = 1,
+	SLICE_HEADER_FULL,
+};
+
+/**
+ * struct vdec_h264_slice_lat_dec_param  - parameters for decode current frame
+ */
+struct vdec_h264_slice_lat_dec_param {
+	struct mtk_h264_sps_param sps;
+	struct mtk_h264_pps_param pps;
+	struct mtk_h264_slice_hd_param slice_header;
+	struct slice_api_h264_scaling_matrix scaling_matrix;
+	struct slice_api_h264_decode_param decode_params;
+	struct mtk_h264_dpb_info h264_dpb_info[V4L2_H264_NUM_DPB_ENTRIES];
+};
+
+/**
+ * struct vdec_h264_slice_info - decode information
+ * @nal_info    : nal info of current picture
+ * @timeout     : Decode timeout: 1 timeout, 0 no timeount
+ * @bs_buf_size : bitstream size
+ * @bs_buf_addr : bitstream buffer dma address
+ * @y_fb_dma    : Y frame buffer dma address
+ * @c_fb_dma    : C frame buffer dma address
+ * @vdec_fb_va  : VDEC frame buffer struct virtual address
+ * @crc         : Used to check whether hardware's status is right
+ */
+struct vdec_h264_slice_info {
+	uint16_t nal_info;
+	uint16_t timeout;
+	uint32_t bs_buf_size;
+	uint64_t bs_buf_addr;
+	uint64_t y_fb_dma;
+	uint64_t c_fb_dma;
+	uint64_t vdec_fb_va;
+	uint32_t crc[8];
+};
+
+/**
+ * struct vdec_h264_slice_vsi - shared memory for decode information exchange
+ *        between VPU and Host. The memory is allocated by VPU then mapping to
+ *        Host in vdec_h264_slice_init() and freed in vdec_h264_slice_deinit()
+ *        by VPU. AP-W/R : AP is writer/reader on this item. VPU-W/R: VPU is
+ *        write/reader on this item.
+ * @wdma_err_addr       : wdma error dma address
+ * @wdma_start_addr     : wdma start dma address
+ * @wdma_end_addr       : wdma end dma address
+ * @slice_bc_start_addr : slice bc start dma address
+ * @slice_bc_end_addr   : slice bc end dma address
+ * @row_info_start_addr : row info start dma address
+ * @row_info_end_addr   : row info end dma address
+ * @trans_start         : trans start dma address
+ * @trans_end           : trans end dma address
+ * @wdma_end_addr_offset: wdma end address offset
+ * @mv_buf_dma          : HW working motion vector buffer
+ *                        dma address (AP-W, VPU-R)
+ * @dec                 : decode information (AP-R, VPU-W)
+ * @h264_slice_params   : decode parameters for hw used
+ */
+struct vdec_h264_slice_vsi {
+	/* LAT dec addr */
+	uint64_t wdma_err_addr;
+	uint64_t wdma_start_addr;
+	uint64_t wdma_end_addr;
+	uint64_t slice_bc_start_addr;
+	uint64_t slice_bc_end_addr;
+	uint64_t row_info_start_addr;
+	uint64_t row_info_end_addr;
+	uint64_t trans_start;
+	uint64_t trans_end;
+	uint64_t wdma_end_addr_offset;
+
+	uint64_t mv_buf_dma[H264_MAX_MV_NUM];
+	struct vdec_h264_slice_info dec;
+	struct vdec_h264_slice_lat_dec_param h264_slice_params;
+};
+
+/**
+ * struct vdec_h264_slice_share_info - shared information used to exchange
+ *                                     message between lat and core
+ * @sps	              : sequence header information from user space
+ * @dec_params        : decoder params from user space
+ * @h264_slice_params : decoder params used for hardware
+ * @trans_start       : trans start dma address
+ * @trans_end         : trans end dma address
+ * @nal_info          : nal info of current picture
+ */
+struct vdec_h264_slice_share_info {
+	struct v4l2_ctrl_h264_sps sps;
+	struct v4l2_ctrl_h264_decode_params dec_params;
+	struct vdec_h264_slice_lat_dec_param h264_slice_params;
+	uint64_t trans_start;
+	uint64_t trans_end;
+	uint16_t nal_info;
+};
+
+/**
+ * struct vdec_h264_slice_inst - h264 decoder instance
+ * @num_nalu            : how many nalus be decoded
+ * @ctx                 : point to mtk_vcodec_ctx
+ * @pred_buf            : HW working predication buffer
+ * @mv_buf              : HW working motion vector buffer
+ * @vpu                 : VPU instance
+ * @vsi                 : vsi used for lat
+ * @vsi_core            : vsi used for core
+ * @resolution_changed  : resolution changed
+ * @realloc_mv_buf      : reallocate mv buffer
+ * @cap_num_planes      : number of capture queue plane
+ */
+struct vdec_h264_slice_inst {
+	unsigned int num_nalu;
+	struct mtk_vcodec_ctx *ctx;
+	struct mtk_vcodec_mem pred_buf;
+	struct mtk_vcodec_mem mv_buf[H264_MAX_MV_NUM];
+	struct vdec_vpu_inst vpu;
+	struct vdec_h264_slice_vsi *vsi;
+	struct vdec_h264_slice_vsi *vsi_core;
+
+	unsigned int resolution_changed;
+	unsigned int realloc_mv_buf;
+	unsigned int cap_num_planes;
+
+	struct v4l2_h264_dpb_entry dpb[16];
+};
+
+static void vdec_h264_slice_fill_decode_parameters(
+	struct vdec_h264_slice_inst *inst,
+	struct vdec_h264_slice_share_info *share_info)
+{
+	struct vdec_h264_slice_lat_dec_param *slice_param =
+		&inst->vsi->h264_slice_params;
+	const struct v4l2_ctrl_h264_decode_params *dec_params =
+		mtk_vdec_h264_get_ctrl_ptr(inst->ctx,
+			V4L2_CID_STATELESS_H264_DECODE_PARAMS);
+	const struct v4l2_ctrl_h264_scaling_matrix *src_matrix =
+		mtk_vdec_h264_get_ctrl_ptr(inst->ctx,
+			V4L2_CID_STATELESS_H264_SCALING_MATRIX);
+	const struct v4l2_ctrl_h264_sps *sps =
+		mtk_vdec_h264_get_ctrl_ptr(inst->ctx,
+			V4L2_CID_STATELESS_H264_SPS);
+	const struct v4l2_ctrl_h264_pps *pps =
+		mtk_vdec_h264_get_ctrl_ptr(inst->ctx,
+			V4L2_CID_STATELESS_H264_PPS);
+
+	mtk_vdec_h264_copy_sps_params(&slice_param->sps,sps);
+	mtk_vdec_h264_copy_pps_params(&slice_param->pps, pps);
+	mtk_vdec_h264_copy_scaling_matrix(
+		&slice_param->scaling_matrix, src_matrix);
+
+	memcpy(&share_info->sps, sps, sizeof(*sps));
+	memcpy(&share_info->dec_params, dec_params, sizeof(*dec_params));
+}
+
+/*
+ * The firmware expects unused reflist entries to have the value 0x20.
+ */
+static void fixup_ref_list(u8 *ref_list, size_t num_valid)
+{
+	memset(&ref_list[num_valid], 0x20, 32 - num_valid);
+}
+
+static void vdec_h264_slice_fill_decode_reflist(
+	struct vdec_h264_slice_inst *inst,
+	struct vdec_h264_slice_lat_dec_param *slice_param,
+	struct vdec_h264_slice_share_info *share_info)
+{
+	struct v4l2_ctrl_h264_decode_params *dec_params = &share_info->dec_params;
+	struct v4l2_ctrl_h264_sps *sps = &share_info->sps;
+	struct v4l2_h264_reflist_builder reflist_builder;
+	u8 *p0_reflist = slice_param->decode_params.ref_pic_list_p0;
+	u8 *b0_reflist = slice_param->decode_params.ref_pic_list_b0;
+	u8 *b1_reflist = slice_param->decode_params.ref_pic_list_b1;
+
+	mtk_vdec_h264_update_dpb(dec_params, inst->dpb);
+
+	mtk_vdec_h264_copy_decode_params(&slice_param->decode_params, dec_params,
+		inst->dpb);
+	mtk_vdec_h264_fill_dpb_info(inst->ctx, &slice_param->decode_params,
+		slice_param->h264_dpb_info);
+
+	mtk_v4l2_debug(3, "cur poc = %d\n", dec_params->bottom_field_order_cnt);
+	/* Build the reference lists */
+	v4l2_h264_init_reflist_builder(&reflist_builder, dec_params, sps,
+				       inst->dpb);
+	v4l2_h264_build_p_ref_list(&reflist_builder, p0_reflist);
+	v4l2_h264_build_b_ref_lists(&reflist_builder, b0_reflist, b1_reflist);
+
+	/* Adapt the built lists to the firmware's expectations */
+	fixup_ref_list(p0_reflist, reflist_builder.num_valid);
+	fixup_ref_list(b0_reflist, reflist_builder.num_valid);
+	fixup_ref_list(b1_reflist, reflist_builder.num_valid);
+}
+
+static int vdec_h264_slice_alloc_mv_buf(struct vdec_h264_slice_inst *inst,
+	struct vdec_pic_info *pic)
+{
+	int i;
+	int err;
+	struct mtk_vcodec_mem *mem;
+	unsigned int buf_sz = mtk_vdec_h264_get_mv_buf_size(
+		pic->buf_w, pic->buf_h);
+
+	mtk_v4l2_debug(3, "size = 0x%lx", buf_sz);
+	for (i = 0; i < H264_MAX_MV_NUM; i++) {
+		mem = &inst->mv_buf[i];
+		if (mem->va)
+			mtk_vcodec_mem_free(inst->ctx, mem);
+		mem->size = buf_sz;
+		err = mtk_vcodec_mem_alloc(inst->ctx, mem);
+		if (err) {
+			mtk_vcodec_err(inst, "failed to allocate mv buf");
+			return err;
+		}
+	}
+
+	return 0;
+}
+
+static void vdec_h264_slice_free_mv_buf(struct vdec_h264_slice_inst *inst)
+{
+	int i;
+	struct mtk_vcodec_mem *mem;
+
+	for (i = 0; i < H264_MAX_MV_NUM; i++) {
+		mem = &inst->mv_buf[i];
+		if (mem->va)
+			mtk_vcodec_mem_free(inst->ctx, mem);
+	}
+}
+
+static void vdec_h264_slice_get_pic_info(struct vdec_h264_slice_inst *inst)
+{
+	struct mtk_vcodec_ctx *ctx = inst->ctx;
+	unsigned int data[3];
+
+	data[0] = ctx->picinfo.pic_w;
+	data[1] = ctx->picinfo.pic_h;
+	data[2] = ctx->capture_fourcc;
+	vpu_dec_get_param(&inst->vpu, data, 3, GET_PARAM_PIC_INFO);
+
+	ctx->picinfo.buf_w = ALIGN(ctx->picinfo.pic_w, 64);
+	ctx->picinfo.buf_h = ALIGN(ctx->picinfo.pic_h, 64);
+	ctx->picinfo.fb_sz[0] = inst->vpu.fb_sz[0];
+	ctx->picinfo.fb_sz[1] = inst->vpu.fb_sz[1];
+	inst->cap_num_planes =
+		ctx->q_data[MTK_Q_DATA_DST].fmt->num_planes;
+
+	mtk_vcodec_debug(inst, "pic(%d, %d), buf(%d, %d)",
+			 ctx->picinfo.pic_w, ctx->picinfo.pic_h,
+			 ctx->picinfo.buf_w, ctx->picinfo.buf_h);
+	mtk_vcodec_debug(inst, "Y/C(%d, %d)", ctx->picinfo.fb_sz[0],
+		ctx->picinfo.fb_sz[1]);
+
+	if ((ctx->last_decoded_picinfo.pic_w != ctx->picinfo.pic_w) ||
+		(ctx->last_decoded_picinfo.pic_h != ctx->picinfo.pic_h)) {
+		inst->resolution_changed = true;
+		if ((ctx->last_decoded_picinfo.buf_w != ctx->picinfo.buf_w) ||
+			(ctx->last_decoded_picinfo.buf_h != ctx->picinfo.buf_h))
+			inst->realloc_mv_buf = true;
+
+		mtk_v4l2_debug(1, "resChg: (%d %d) : old(%d, %d) -> new(%d, %d)",
+			inst->resolution_changed,
+			inst->realloc_mv_buf,
+			ctx->last_decoded_picinfo.pic_w,
+			ctx->last_decoded_picinfo.pic_h,
+			ctx->picinfo.pic_w, ctx->picinfo.pic_h);
+	}
+}
+
+static void vdec_h264_slice_get_crop_info(struct vdec_h264_slice_inst *inst,
+	struct v4l2_rect *cr)
+{
+	cr->left = 0;
+	cr->top = 0;
+	cr->width = inst->ctx->picinfo.pic_w;
+	cr->height = inst->ctx->picinfo.pic_h;
+
+	mtk_vcodec_debug(inst, "l=%d, t=%d, w=%d, h=%d",
+			 cr->left, cr->top, cr->width, cr->height);
+}
+
+static int vdec_h264_slice_init(struct mtk_vcodec_ctx *ctx)
+{
+	struct vdec_h264_slice_inst *inst;
+	int err, vsi_size;
+
+	inst = kzalloc(sizeof(*inst), GFP_KERNEL);
+	if (!inst)
+		return -ENOMEM;
+
+	inst->ctx = ctx;
+
+	inst->vpu.id = SCP_IPI_VDEC_LAT;
+	inst->vpu.core_id = SCP_IPI_VDEC_CORE;
+	inst->vpu.ctx = ctx;
+	inst->vpu.codec_type = ctx->current_codec;
+	inst->vpu.capture_type = ctx->capture_fourcc;
+
+	err = vpu_dec_init(&inst->vpu);
+	if (err) {
+		mtk_vcodec_err(inst, "vdec_h264 init err=%d", err);
+		goto error_free_inst;
+	}
+
+	vsi_size = round_up(sizeof(struct vdec_h264_slice_vsi), 64);
+	inst->vsi = inst->vpu.vsi;
+	inst->vsi_core =
+		(struct vdec_h264_slice_vsi *)(((char *)inst->vpu.vsi) + vsi_size);
+	inst->resolution_changed = true;
+	inst->realloc_mv_buf = true;
+	inst->ctx->msg_queue.init_done = false;
+
+	mtk_vcodec_debug(inst, "lat struct size = %d,%d,%d,%d vsi: %d\n",
+		sizeof(struct mtk_h264_sps_param),
+		sizeof(struct mtk_h264_pps_param),
+		sizeof(struct vdec_h264_slice_lat_dec_param),
+		sizeof(struct mtk_h264_dpb_info),
+		vsi_size);
+	mtk_vcodec_debug(inst, "lat H264 instance >> %p, codec_type = 0x%x",
+		inst, inst->vpu.codec_type);
+
+	ctx->drv_handle = inst;
+	return 0;
+
+error_free_inst:
+	kfree(inst);
+	return err;
+}
+
+static void vdec_h264_slice_deinit(void *h_vdec)
+{
+	struct vdec_h264_slice_inst *inst = h_vdec;
+
+	mtk_vcodec_debug_enter(inst);
+
+	vpu_dec_deinit(&inst->vpu);
+	vdec_h264_slice_free_mv_buf(inst);
+	vdec_msg_queue_deinit(inst->ctx, &inst->ctx->msg_queue);
+
+	kfree(inst);
+}
+
+static int vdec_h264_slice_core_decode(struct vdec_lat_buf *lat_buf)
+{
+	struct vdec_fb *fb;
+	uint64_t vdec_fb_va;
+	uint64_t y_fb_dma, c_fb_dma;
+	int err, timeout, i, dec_err;
+	struct vdec_vpu_inst *vpu;
+	struct mtk_video_dec_buf *dst_buf_info;
+	struct mtk_vcodec_ctx *ctx = lat_buf->ctx;
+	struct vdec_h264_slice_inst *inst = ctx->drv_handle;
+	struct vb2_v4l2_buffer *vb2_v4l2;
+	struct vdec_h264_slice_share_info *share_info = lat_buf->private_data;
+	struct mtk_vcodec_mem *mem;
+
+	mtk_vcodec_debug(inst, "[h264-core] vdec_h264 core decode");
+	memcpy(&inst->vsi_core->h264_slice_params, &share_info->h264_slice_params,
+		sizeof(share_info->h264_slice_params));
+	fb = ctx->dev->vdec_pdata->get_cap_buffer(ctx);
+	vpu = &inst->vpu;
+	dst_buf_info = container_of(fb, struct mtk_video_dec_buf, frame_buffer);
+	vdec_fb_va = (u64)fb;
+	y_fb_dma = fb ? (u64)fb->base_y.dma_addr : 0;
+
+	if (ctx->q_data[MTK_Q_DATA_DST].fmt->num_planes == 1)
+		c_fb_dma =
+			y_fb_dma + inst->ctx->picinfo.buf_w * inst->ctx->picinfo.buf_h;
+	else
+		c_fb_dma = fb ? (u64)fb->base_c.dma_addr : 0;
+
+	mtk_vcodec_debug(inst, "[h264-core] y/c addr = 0x%x 0x%x", y_fb_dma,
+		c_fb_dma);
+
+	inst->vsi_core->dec.y_fb_dma = y_fb_dma;
+	inst->vsi_core->dec.c_fb_dma = c_fb_dma;
+	inst->vsi_core->dec.vdec_fb_va = vdec_fb_va;
+	inst->vsi_core->dec.nal_info = share_info->nal_info;
+	inst->vsi_core->wdma_start_addr =
+		lat_buf->ctx->msg_queue.wdma_addr.dma_addr;
+	inst->vsi_core->wdma_end_addr =
+		lat_buf->ctx->msg_queue.wdma_addr.dma_addr +
+		lat_buf->ctx->msg_queue.wdma_addr.size;
+	inst->vsi_core->wdma_err_addr = lat_buf->wdma_err_addr.dma_addr;
+	inst->vsi_core->slice_bc_start_addr = lat_buf->slice_bc_addr.dma_addr;
+	inst->vsi_core->slice_bc_end_addr = lat_buf->slice_bc_addr.dma_addr +
+		lat_buf->slice_bc_addr.size;
+	inst->vsi_core->trans_start = share_info->trans_start;
+	inst->vsi_core->trans_end = share_info->trans_end;
+	for (i = 0; i < H264_MAX_MV_NUM; i++) {
+		mem = &inst->mv_buf[i];
+		inst->vsi_core->mv_buf_dma[i] = mem->dma_addr;
+	}
+
+	vb2_v4l2 = v4l2_m2m_next_dst_buf(ctx->m2m_ctx);
+
+	vb2_v4l2->vb2_buf.timestamp = lat_buf->ts_info.vb2_buf.timestamp;
+	vb2_v4l2->timecode = lat_buf->ts_info.timecode;
+	vb2_v4l2->field = lat_buf->ts_info.field;
+	vb2_v4l2->flags = lat_buf->ts_info.flags;
+	vb2_v4l2->vb2_buf.copied_timestamp =
+		lat_buf->ts_info.vb2_buf.copied_timestamp;
+
+	vdec_h264_slice_fill_decode_reflist(inst,
+		&inst->vsi_core->h264_slice_params, share_info);
+
+	err = vpu_dec_core(vpu);
+	if (err) {
+		dec_err = 1;
+		mtk_vcodec_err(inst, "core decode err=%d", err);
+		goto vdec_dec_end;
+	} else {
+		dec_err = 0;
+	}
+
+	if (!inst->ctx->dev->vdec_inter_in_scp) {
+		/* wait decoder done interrupt */
+		timeout = mtk_vcodec_wait_for_comp_done_ctx(
+			inst->ctx, MTK_INST_IRQ_RECEIVED,
+			WAIT_INTR_TIMEOUT_MS, MTK_VDEC_CORE);
+		if (timeout)
+			mtk_vcodec_err(inst, "core decode timeout: pic_%d",
+				ctx->decoded_frame_cnt);
+		inst->vsi_core->dec.timeout = !!timeout;
+
+		vpu_dec_core_end(vpu);
+	}
+	mtk_vcodec_debug(inst, "y_crc: 0x%x 0x%x 0x%x 0x%x",
+		inst->vsi_core->dec.crc[0],
+		inst->vsi_core->dec.crc[1],
+		inst->vsi_core->dec.crc[2],
+		inst->vsi_core->dec.crc[3]);
+
+	mtk_vcodec_debug(inst, "c_crc: 0x%x 0x%x 0x%x 0x%x",
+		inst->vsi_core->dec.crc[4],
+		inst->vsi_core->dec.crc[5],
+		inst->vsi_core->dec.crc[6],
+		inst->vsi_core->dec.crc[7]);
+
+vdec_dec_end:
+	vdec_msg_queue_update_ube_rptr(&lat_buf->ctx->msg_queue,
+		inst->vsi_core->trans_end);
+	ctx->dev->vdec_pdata->cap_to_disp(ctx, fb, dec_err);
+	mtk_vcodec_debug(inst, "core decode done err=%d", err);
+	ctx->decoded_frame_cnt++;
+
+	return 0;
+}
+
+static int vdec_h264_slice_decode(void *h_vdec, struct mtk_vcodec_mem *bs,
+	struct vdec_fb *fb, bool *res_chg)
+{
+	struct vdec_h264_slice_inst *inst = h_vdec;
+	struct vdec_vpu_inst *vpu = &inst->vpu;
+	struct mtk_video_dec_buf *src_buf_info;
+	int nal_start_idx, err, timeout = 0, i;
+	unsigned int nal_type, data[2];
+	struct vdec_lat_buf *lat_buf;
+	struct vdec_h264_slice_share_info *share_info;
+	unsigned char *buf;
+	struct mtk_vcodec_mem *mem;
+
+	mtk_vcodec_debug(inst, "+ [%d] ", ++inst->num_nalu);
+
+	if (!inst->ctx->msg_queue.init_done) {
+		if (vdec_msg_queue_init(inst->ctx, &inst->ctx->msg_queue,
+			vdec_h264_slice_core_decode, sizeof(*share_info)))
+		return -ENOMEM;
+	}
+
+	/* bs NULL means flush decoder */
+	if (!bs) {
+		vdec_msg_queue_wait_lat_buf_full(&inst->ctx->msg_queue);
+		return vpu_dec_reset(vpu);
+	}
+
+	lat_buf = vdec_msg_queue_get_lat_buf(&inst->ctx->msg_queue);
+	if (!lat_buf) {
+		mtk_vcodec_err(inst, "failed to get lat buffer");
+		return -EINVAL;
+	}
+	share_info = lat_buf->private_data;
+	src_buf_info = container_of(bs, struct mtk_video_dec_buf, bs_buffer);
+
+	buf = (unsigned char *)bs->va;
+	nal_start_idx = mtk_vdec_h264_find_start_code(buf, bs->size);
+	if (nal_start_idx < 0) {
+		err = -EINVAL;
+		goto err_free_fb_out;
+	}
+
+	inst->vsi->dec.nal_info = buf[nal_start_idx];
+	nal_type = NAL_TYPE(buf[nal_start_idx]);
+	mtk_vcodec_debug(inst, "\n + NALU[%d] type %d +\n", inst->num_nalu,
+			 nal_type);
+
+	inst->vsi->dec.bs_buf_addr = (uint64_t)bs->dma_addr;
+	inst->vsi->dec.bs_buf_size = bs->size;
+
+	v4l2_m2m_buf_copy_metadata(&src_buf_info->m2m_buf.vb,
+		&lat_buf->ts_info, true);
+
+	vdec_h264_slice_fill_decode_parameters(inst, share_info);
+	*res_chg = inst->resolution_changed;
+	if (inst->resolution_changed) {
+		mtk_vcodec_debug(inst, "- resolution changed -");
+		if (inst->realloc_mv_buf) {
+			err = vdec_h264_slice_alloc_mv_buf(inst, &inst->ctx->picinfo);
+			inst->realloc_mv_buf = false;
+			if (err)
+				goto err_free_fb_out;
+		}
+		inst->resolution_changed = false;
+	}
+	for (i = 0; i < H264_MAX_MV_NUM; i++) {
+		mem = &inst->mv_buf[i];
+		inst->vsi->mv_buf_dma[i] = mem->dma_addr;
+	}
+	inst->vsi->wdma_start_addr = lat_buf->ctx->msg_queue.wdma_addr.dma_addr;
+	inst->vsi->wdma_end_addr = lat_buf->ctx->msg_queue.wdma_addr.dma_addr +
+		lat_buf->ctx->msg_queue.wdma_addr.size;
+	inst->vsi->wdma_err_addr = lat_buf->wdma_err_addr.dma_addr;
+	inst->vsi->slice_bc_start_addr = lat_buf->slice_bc_addr.dma_addr;
+	inst->vsi->slice_bc_end_addr = lat_buf->slice_bc_addr.dma_addr +
+		lat_buf->slice_bc_addr.size;
+
+	inst->vsi->trans_end = inst->ctx->msg_queue.wdma_rptr_addr;
+	inst->vsi->trans_start = inst->ctx->msg_queue.wdma_wptr_addr;
+	mtk_vcodec_debug(inst, "lat:trans(0x%llx 0x%llx)err:0x%llx",
+		inst->vsi->wdma_start_addr,
+		inst->vsi->wdma_end_addr,
+		inst->vsi->wdma_err_addr);
+
+	mtk_vcodec_debug(inst, "slice(0x%llx 0x%llx) rprt((0x%llx 0x%llx))",
+		inst->vsi->slice_bc_start_addr,
+		inst->vsi->slice_bc_end_addr,
+		inst->vsi->trans_start,
+		inst->vsi->trans_end);
+	err = vpu_dec_start(vpu, data, 2);
+	if (err) {
+		mtk_vcodec_debug(inst, "lat decode err: %d", err);
+		goto err_free_fb_out;
+	}
+	if (!inst->ctx->dev->vdec_inter_in_scp) {
+		if (nal_type == NAL_NON_IDR_SLICE ||
+			nal_type == NAL_IDR_SLICE) {
+			/* wait decoder done interrupt */
+			timeout = mtk_vcodec_wait_for_comp_done_ctx(
+				inst->ctx, MTK_INST_IRQ_RECEIVED,
+				WAIT_INTR_TIMEOUT_MS, MTK_VDEC_LAT0);
+			inst->vsi->dec.timeout = !!timeout;
+		}
+		err = vpu_dec_end(vpu);
+	}
+
+	if (err == SLICE_HEADER_FULL || timeout || (err == TRANS_BUFFER_FULL &&
+		inst->ctx->msg_queue.wdma_rptr_addr ==
+		inst->ctx->msg_queue.wdma_wptr_addr)) {
+		err = -EINVAL;
+		goto err_free_fb_out;
+	} else if (err == TRANS_BUFFER_FULL){
+		goto err_free_fb_out;
+	}
+
+	share_info->trans_end = inst->ctx->msg_queue.wdma_addr.dma_addr +
+		inst->vsi->wdma_end_addr_offset;
+	share_info->trans_start = inst->ctx->msg_queue.wdma_wptr_addr;
+	share_info->nal_info = inst->vsi->dec.nal_info;
+	vdec_msg_queue_update_ube_wptr(&lat_buf->ctx->msg_queue,
+		share_info->trans_end);
+
+	memcpy(&share_info->h264_slice_params, &inst->vsi->h264_slice_params,
+		sizeof(share_info->h264_slice_params));
+	vdec_msg_queue_buf_to_core(inst->ctx->dev, lat_buf);
+	mtk_vcodec_debug(inst, "- NALU[%d] type=%d -\n", inst->num_nalu,
+			 nal_type);
+	return 0;
+
+err_free_fb_out:
+	if (lat_buf)
+		vdec_msg_queue_buf_to_lat(lat_buf);
+	mtk_vcodec_err(inst, "- NALU[%d] err=%d -\n", inst->num_nalu, err);
+	return err;
+}
+
+static int vdec_h264_slice_get_param(void *h_vdec,
+	enum vdec_get_param_type type, void *out)
+{
+	struct vdec_h264_slice_inst *inst = h_vdec;
+
+	switch (type) {
+	case GET_PARAM_PIC_INFO:
+		vdec_h264_slice_get_pic_info(inst);
+		break;
+	case GET_PARAM_DPB_SIZE:
+		*(unsigned int *)out = 6;
+		break;
+	case GET_PARAM_CROP_INFO:
+		vdec_h264_slice_get_crop_info(inst, out);
+		break;
+	default:
+		mtk_vcodec_err(inst, "invalid get parameter type=%d", type);
+		return -EINVAL;
+	}
+	return 0;
+}
+
+const struct vdec_common_if vdec_h264_slice_lat_if = {
+	.init		= vdec_h264_slice_init,
+	.decode		= vdec_h264_slice_decode,
+	.get_param	= vdec_h264_slice_get_param,
+	.deinit		= vdec_h264_slice_deinit,
+};
diff --git a/drivers/media/platform/mtk-vcodec/vdec/vdec_vp8_req_if.c b/drivers/media/platform/mtk-vcodec/vdec/vdec_vp8_req_if.c
new file mode 100644
index 0000000000000000000000000000000000000000..ac9387befef9eeb1122fbf26301062481ffad9fc
--- /dev/null
+++ b/drivers/media/platform/mtk-vcodec/vdec/vdec_vp8_req_if.c
@@ -0,0 +1,460 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2021 MediaTek Inc.
+ * Author: Yunfei Dong <yunfei.dong@mediatek.com>
+ */
+
+#include <linux/slab.h>
+#include <media/v4l2-mem2mem.h>
+#include <media/videobuf2-dma-contig.h>
+#include <uapi/linux/v4l2-controls.h>
+
+#include "../mtk_vcodec_dec.h"
+#include "../mtk_vcodec_intr.h"
+#include "../mtk_vcodec_util.h"
+#include "../vdec_drv_base.h"
+#include "../vdec_drv_if.h"
+#include "../vdec_vpu_if.h"
+
+/* Decoding picture buffer size (3 reference frames plus current frame) */
+#define VP8_DPB_SIZE			4
+
+/* HW working buffer size (bytes) */
+#define VP8_SEG_ID_SZ		(256 * 1024)
+#define VP8_PP_WRAPY_SZ		(64 * 1024)
+#define VP8_PP_WRAPC_SZ		(64 * 1024)
+#define VP8_VLD_PRED_SZ		(64 * 1024)
+
+/**
+ * struct vdec_vp8_slice_info - decode misc information
+ * @vld_wrapper_dma   : vld wrapper dma address
+ * @seg_id_buf_dma    : seg id dma address
+ * @wrap_y_dma        : wrap y dma address
+ * @wrap_c_dma        : wrap y dma address
+ * @cur_y_fb_dma      : current plane Y frame buffer dma address
+ * @cur_c_fb_dma      : current plane C frame buffer dma address
+ * @bs_dma            : bitstream dma address
+ * @bs_sz             : bitstream size
+ * @resolution_changed: resolution change flag 1 - changed,  0 - not change
+ * @frame_header_type : current frame header type
+ * @wait_key_frame    : wait key frame coming
+ * @crc               : Used to check whether hardware's status is right
+ * @timeout           : Decode timeout: 1 timeout, 0 no timeount
+ */
+struct vdec_vp8_slice_info {
+	uint64_t vld_wrapper_dma;
+	uint64_t seg_id_buf_dma;
+	uint64_t wrap_y_dma;
+	uint64_t wrap_c_dma;
+	uint64_t cur_y_fb_dma;
+	uint64_t cur_c_fb_dma;
+	uint64_t bs_dma;
+	uint32_t bs_sz;
+	uint32_t resolution_changed;
+	uint32_t frame_header_type;
+	uint32_t crc[8];
+	uint32_t reserved;
+};
+
+/**
+ * struct vdec_vp8_slice_dpb_info  - vp8 reference information
+ * @y_dma_addr    : Y bitstream physical address
+ * @c_dma_addr    : CbCr bitstream physical address
+ * @reference_flag: reference picture flag
+ * @reserved      : 64bit align
+ */
+struct vdec_vp8_slice_dpb_info {
+	dma_addr_t y_dma_addr;
+	dma_addr_t c_dma_addr;
+	int reference_flag;
+	int reserved;
+};
+
+/**
+ * struct vdec_vp8_slice_vsi - VPU shared information
+ * @dec          : decoding information
+ * @pic          : picture information
+ * @vp8_dpb_info : reference buffer information
+ */
+struct vdec_vp8_slice_vsi {
+	struct vdec_vp8_slice_info dec;
+	struct vdec_pic_info pic;
+	struct vdec_vp8_slice_dpb_info vp8_dpb_info[3];
+};
+
+/**
+ * struct vdec_vp8_slice_inst - VP8 decoder instance
+ * @seg_id_buf     : seg buffer
+ * @wrap_y_buf     : wrapper y buffer
+ * @wrap_c_buf     : wrapper c buffer
+ * @vld_wrapper_buf: vld wrapper buffer
+ * @ctx            : V4L2 context
+ * @vpu            : VPU instance for decoder
+ * @vsi            : VPU share information
+ */
+struct vdec_vp8_slice_inst {
+	struct mtk_vcodec_mem seg_id_buf;
+	struct mtk_vcodec_mem wrap_y_buf;
+	struct mtk_vcodec_mem wrap_c_buf;
+	struct mtk_vcodec_mem vld_wrapper_buf;
+	struct mtk_vcodec_ctx *ctx;
+	struct vdec_vpu_inst vpu;
+	struct vdec_vp8_slice_vsi *vsi;
+};
+
+static void *vdec_vp8_slice_get_ctrl_ptr(struct mtk_vcodec_ctx *ctx, int id)
+{
+	struct v4l2_ctrl *ctrl = v4l2_ctrl_find(&ctx->ctrl_hdl, id);
+
+	return ctrl->p_cur.p;
+}
+
+static void vdec_vp8_slice_get_crop_info(struct vdec_vp8_slice_inst *inst,
+	struct v4l2_rect *cr)
+{
+	cr->left = 0;
+	cr->top = 0;
+	cr->width = inst->vsi->pic.pic_w;
+	cr->height = inst->vsi->pic.pic_h;
+	mtk_vcodec_debug(inst, "get crop info l=%d, t=%d, w=%d, h=%d",
+			 cr->left, cr->top, cr->width, cr->height);
+}
+
+static void vdec_vp8_slice_get_pic_info(struct vdec_vp8_slice_inst *inst)
+{
+	struct mtk_vcodec_ctx *ctx = inst->ctx;
+	unsigned int data[3];
+
+	data[0] = ctx->picinfo.pic_w;
+	data[1] = ctx->picinfo.pic_h;
+	data[2] = ctx->capture_fourcc;
+	vpu_dec_get_param(&inst->vpu, data, 3, GET_PARAM_PIC_INFO);
+
+	ctx->picinfo.buf_w = ALIGN(ctx->picinfo.pic_w, 64);
+	ctx->picinfo.buf_h = ALIGN(ctx->picinfo.pic_h, 64);
+	ctx->picinfo.fb_sz[0] = inst->vpu.fb_sz[0];
+	ctx->picinfo.fb_sz[1] = inst->vpu.fb_sz[1];
+
+	inst->vsi->pic.pic_w = ctx->picinfo.pic_w;
+	inst->vsi->pic.pic_h = ctx->picinfo.pic_h;
+	inst->vsi->pic.buf_w = ctx->picinfo.buf_w;
+	inst->vsi->pic.buf_h = ctx->picinfo.buf_h;
+	inst->vsi->pic.fb_sz[0] = ctx->picinfo.fb_sz[0];
+	inst->vsi->pic.fb_sz[1] = ctx->picinfo.fb_sz[1];
+	mtk_vcodec_debug(inst, "pic(%d, %d), buf(%d, %d)",
+		ctx->picinfo.pic_w, ctx->picinfo.pic_h,
+		ctx->picinfo.buf_w, ctx->picinfo.buf_h);
+	mtk_vcodec_debug(inst, "fb size: Y(%d), C(%d)",
+		ctx->picinfo.fb_sz[0], ctx->picinfo.fb_sz[1]);
+}
+
+static int vdec_vp8_slice_alloc_working_buf(struct vdec_vp8_slice_inst *inst)
+{
+	int err;
+	struct mtk_vcodec_mem *mem;
+
+	mem = &inst->seg_id_buf;
+	mem->size = VP8_SEG_ID_SZ;
+	err = mtk_vcodec_mem_alloc(inst->ctx, mem);
+	if (err) {
+		mtk_vcodec_err(inst, "Cannot allocate working buffer");
+		return err;
+	}
+	inst->vsi->dec.seg_id_buf_dma = (uint64_t)mem->dma_addr;
+
+	mem = &inst->wrap_y_buf;
+	mem->size = VP8_PP_WRAPY_SZ;
+	err = mtk_vcodec_mem_alloc(inst->ctx, mem);
+	if (err) {
+		mtk_vcodec_err(inst, "cannot allocate WRAP Y buffer");
+		return err;
+	}
+	inst->vsi->dec.wrap_y_dma = (uint64_t)mem->dma_addr;
+
+	mem = &inst->wrap_c_buf;
+	mem->size = VP8_PP_WRAPC_SZ;
+	err = mtk_vcodec_mem_alloc(inst->ctx, mem);
+	if (err) {
+		mtk_vcodec_err(inst, "cannot allocate WRAP C buffer");
+		return err;
+	}
+	inst->vsi->dec.wrap_c_dma = (uint64_t)mem->dma_addr;
+
+	mem = &inst->vld_wrapper_buf;
+	mem->size = VP8_VLD_PRED_SZ;
+	err = mtk_vcodec_mem_alloc(inst->ctx, mem);
+	if (err) {
+		mtk_vcodec_err(inst, "cannot allocate vld wrapper buffer");
+		return err;
+	}
+	inst->vsi->dec.vld_wrapper_dma = (uint64_t)mem->dma_addr;
+
+	return 0;
+}
+
+static void vdec_vp8_slice_free_working_buf(struct vdec_vp8_slice_inst *inst)
+{
+	struct mtk_vcodec_mem *mem;
+
+	mem = &inst->seg_id_buf;
+	if (mem->va)
+		mtk_vcodec_mem_free(inst->ctx, mem);
+	inst->vsi->dec.seg_id_buf_dma = 0;
+
+	mem = &inst->wrap_y_buf;
+	if (mem->va)
+		mtk_vcodec_mem_free(inst->ctx, mem);
+	inst->vsi->dec.wrap_y_dma = 0;
+
+	mem = &inst->wrap_c_buf;
+	if (mem->va)
+		mtk_vcodec_mem_free(inst->ctx, mem);
+	inst->vsi->dec.wrap_c_dma = 0;
+
+	mem = &inst->vld_wrapper_buf;
+	if (mem->va)
+		mtk_vcodec_mem_free(inst->ctx, mem);
+	inst->vsi->dec.vld_wrapper_dma= 0;
+}
+
+static u64 vdec_vp8_slice_get_ref_by_ts(
+	const struct v4l2_ctrl_vp8_frame *frame_header,
+	int index)
+{
+	switch (index) {
+	case 0:
+		return frame_header->last_frame_ts;
+	case 1:
+		return frame_header->golden_frame_ts;
+	case 2:
+		return frame_header->alt_frame_ts;
+	default:
+		break;
+	}
+
+	return -1;
+}
+
+static void vdec_vp8_slice_get_decode_parameters(
+	struct vdec_vp8_slice_inst *inst)
+{
+	const struct v4l2_ctrl_vp8_frame *frame_header =
+		vdec_vp8_slice_get_ctrl_ptr(inst->ctx,
+			V4L2_CID_STATELESS_VP8_FRAME);
+	struct mtk_vcodec_ctx *ctx = inst->ctx;
+	struct vb2_queue *vq;
+	struct vb2_buffer *vb;
+	u64 referenct_ts;
+	int index, vb2_index;
+
+	vq = v4l2_m2m_get_vq(ctx->m2m_ctx, V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE);
+	for (index = 0; index < 3; index++) {
+		referenct_ts = vdec_vp8_slice_get_ref_by_ts(frame_header, index);
+		vb2_index = vb2_find_timestamp(vq, referenct_ts, 0);
+		if (vb2_index < 0) {
+			if (!V4L2_VP8_FRAME_IS_KEY_FRAME(frame_header))
+				mtk_vcodec_err(inst, "reference invalid: index(%d) ts(%lld)",
+					index, referenct_ts);
+			inst->vsi->vp8_dpb_info[index].reference_flag = 0;
+			continue;
+		}
+		inst->vsi->vp8_dpb_info[index].reference_flag = 1;
+
+		vb = vq->bufs[vb2_index];
+		inst->vsi->vp8_dpb_info[index].y_dma_addr =
+			vb2_dma_contig_plane_dma_addr(vb, 0);
+		if (ctx->q_data[MTK_Q_DATA_DST].fmt->num_planes == 2)
+			inst->vsi->vp8_dpb_info[index].c_dma_addr =
+				vb2_dma_contig_plane_dma_addr(vb, 1);
+		else
+			inst->vsi->vp8_dpb_info[index].c_dma_addr =
+				inst->vsi->vp8_dpb_info[index].y_dma_addr +
+				ctx->picinfo.fb_sz[0];
+	}
+
+	inst->vsi->dec.frame_header_type = frame_header->flags >> 1;
+}
+
+static int vdec_vp8_slice_init(struct mtk_vcodec_ctx *ctx)
+{
+	struct vdec_vp8_slice_inst *inst;
+	int err;
+
+	inst = kzalloc(sizeof(*inst), GFP_KERNEL);
+	if (!inst)
+		return -ENOMEM;
+
+	inst->ctx = ctx;
+
+	inst->vpu.id = SCP_IPI_VDEC_LAT;
+	inst->vpu.core_id = SCP_IPI_VDEC_CORE;
+	inst->vpu.ctx = ctx;
+	inst->vpu.codec_type = ctx->current_codec;
+	inst->vpu.capture_type = ctx->capture_fourcc;
+
+	err = vpu_dec_init(&inst->vpu);
+	if (err) {
+		mtk_vcodec_err(inst, "vdec_vp8 init err=%d", err);
+		goto error_free_inst;
+	}
+
+	inst->vsi = inst->vpu.vsi;
+	err = vdec_vp8_slice_alloc_working_buf(inst);
+	if (err)
+		goto error_deinit;
+
+	mtk_vcodec_debug(inst, "vp8 struct size = %d vsi: %d\n",
+		sizeof(struct v4l2_ctrl_vp8_frame),
+		sizeof(struct vdec_vp8_slice_vsi));
+	mtk_vcodec_debug(inst, "vp8:%p, codec_type = 0x%x vsi: 0x%p",
+		inst, inst->vpu.codec_type, inst->vpu.vsi);
+
+	ctx->drv_handle = inst;
+	return 0;
+
+error_deinit:
+	vpu_dec_deinit(&inst->vpu);
+error_free_inst:
+	kfree(inst);
+	return err;
+}
+
+static int vdec_vp8_slice_decode(void *h_vdec, struct mtk_vcodec_mem *bs,
+	struct vdec_fb *fb, bool *res_chg)
+{
+	struct vdec_vp8_slice_inst *inst = h_vdec;
+	struct vdec_vpu_inst *vpu = &inst->vpu;
+	struct mtk_video_dec_buf *src_buf_info, *dst_buf_info;
+	unsigned char *bs_va;
+	unsigned int data;
+	uint64_t y_fb_dma, c_fb_dma;
+	int err;
+
+	/* Resolution changes are never initiated by us */
+	*res_chg = false;
+
+	/* bs NULL means flush decoder */
+	if (!bs)
+		return vpu_dec_reset(vpu);
+
+	src_buf_info = container_of(bs, struct mtk_video_dec_buf, bs_buffer);
+
+	fb = inst->ctx->dev->vdec_pdata->get_cap_buffer(inst->ctx);
+	dst_buf_info = container_of(fb, struct mtk_video_dec_buf, frame_buffer);
+
+	y_fb_dma = fb ? (u64)fb->base_y.dma_addr : 0;
+	if (inst->ctx->q_data[MTK_Q_DATA_DST].fmt->num_planes == 1)
+		c_fb_dma = y_fb_dma +
+			inst->ctx->picinfo.buf_w * inst->ctx->picinfo.buf_h;
+	else
+		c_fb_dma = fb ? (u64)fb->base_c.dma_addr : 0;
+
+	inst->vsi->dec.bs_dma = (unsigned long)bs->dma_addr;
+	inst->vsi->dec.bs_sz = bs->size;
+	inst->vsi->dec.cur_y_fb_dma = y_fb_dma;
+	inst->vsi->dec.cur_c_fb_dma = c_fb_dma;
+
+	mtk_vcodec_debug(inst, "frame[%d] bs(%d 0x%lx) y/c(0x%llx 0x%llx)",
+		inst->ctx->decoded_frame_cnt,
+		bs->size, (unsigned long)bs->dma_addr,
+		y_fb_dma, c_fb_dma);
+
+	bs_va = (unsigned char *)bs->va;
+	v4l2_m2m_buf_copy_metadata(&src_buf_info->m2m_buf.vb,
+			&dst_buf_info->m2m_buf.vb, true);
+
+	vdec_vp8_slice_get_decode_parameters(inst);
+	err = vpu_dec_start(vpu, &data, 1);
+	if (err) {
+		mtk_vcodec_debug(inst, "vp8 dec start err!");
+		goto error;
+	}
+
+	if (inst->vsi->dec.resolution_changed) {
+		mtk_vcodec_debug(inst, "- resolution_changed -");
+		*res_chg = true;
+		return 0;
+	}
+
+	if (!inst->ctx->dev->vdec_inter_in_scp) {
+		/* wait decoder done interrupt */
+		err = mtk_vcodec_wait_for_comp_done_ctx(
+				inst->ctx, MTK_INST_IRQ_RECEIVED,
+				50, MTK_VDEC_CORE);
+		if (err) {
+			mtk_vcodec_debug(inst, "error while waiting for core: %d", err);
+			vpu_dec_end(vpu);
+			goto error;
+		}
+
+		err = vpu_dec_end(vpu);
+		if (err) {
+			mtk_vcodec_debug(inst, "error while calling vpu_dec_end: %d",
+				inst->ctx->decoded_frame_cnt, err);
+			goto error;
+		}
+	}
+
+	mtk_vcodec_debug(inst, "y_crc: 0x%x 0x%x 0x%x 0x%x",
+		inst->vsi->dec.crc[0],
+		inst->vsi->dec.crc[1],
+		inst->vsi->dec.crc[2],
+		inst->vsi->dec.crc[3]);
+
+	mtk_vcodec_debug(inst, "c_crc: 0x%x 0x%x 0x%x 0x%x",
+			inst->vsi->dec.crc[4],
+			inst->vsi->dec.crc[5],
+			inst->vsi->dec.crc[6],
+			inst->vsi->dec.crc[7]);
+
+	inst->ctx->decoded_frame_cnt++;
+error:
+	if (err) {
+		mtk_vcodec_err(inst, "\n - FRAME[%d] err=%d\n",
+			inst->ctx->decoded_frame_cnt, err);
+	}
+
+	inst->ctx->dev->vdec_pdata->cap_to_disp(inst->ctx, fb, !!err);
+	return err;
+}
+
+static int vdec_vp8_slice_get_param(void *h_vdec,
+	enum vdec_get_param_type type, void *out)
+{
+	struct vdec_vp8_slice_inst *inst = h_vdec;
+
+	switch (type) {
+	case GET_PARAM_PIC_INFO:
+		vdec_vp8_slice_get_pic_info(inst);
+		break;
+	case GET_PARAM_CROP_INFO:
+		vdec_vp8_slice_get_crop_info(inst, out);
+		break;
+	case GET_PARAM_DPB_SIZE:
+		*((unsigned int *)out) = VP8_DPB_SIZE;
+		break;
+	default:
+		mtk_vcodec_err(inst, "invalid get parameter type=%d", type);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static void vdec_vp8_slice_deinit(void *h_vdec)
+{
+	struct vdec_vp8_slice_inst *inst = h_vdec;
+
+	mtk_vcodec_debug_enter(inst);
+
+	vpu_dec_deinit(&inst->vpu);
+	vdec_vp8_slice_free_working_buf(inst);
+	kfree(inst);
+}
+
+const struct vdec_common_if vdec_vp8_slice_if = {
+	.init		= vdec_vp8_slice_init,
+	.decode		= vdec_vp8_slice_decode,
+	.get_param	= vdec_vp8_slice_get_param,
+	.deinit		= vdec_vp8_slice_deinit,
+};
diff --git a/drivers/media/platform/mtk-vcodec/vdec/vdec_vp9_req_lat_if.c b/drivers/media/platform/mtk-vcodec/vdec/vdec_vp9_req_lat_if.c
new file mode 100644
index 0000000000000000000000000000000000000000..49c5936db6e9b32cd21101b320fbc8782aef53a9
--- /dev/null
+++ b/drivers/media/platform/mtk-vcodec/vdec/vdec_vp9_req_lat_if.c
@@ -0,0 +1,2082 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2021 MediaTek Inc.
+ * Author: George Sun <george.sun@mediatek.com>
+ */
+
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <media/videobuf2-dma-contig.h>
+
+#include "../mtk_vcodec_dec.h"
+#include "../mtk_vcodec_intr.h"
+#include "../mtk_vcodec_util.h"
+#include "../vdec_drv_base.h"
+#include "../vdec_drv_if.h"
+#include "../vdec_msg_queue.h"
+#include "../vdec_vpu_if.h"
+
+/* reset_frame_context defined in VP9 spec */
+#define VP9_RESET_FRAME_CONTEXT_NONE0 0
+#define VP9_RESET_FRAME_CONTEXT_NONE1 1
+#define VP9_RESET_FRAME_CONTEXT_SPEC 2
+#define VP9_RESET_FRAME_CONTEXT_ALL 3
+
+#define VP9_TILE_BUF_SIZE 4096
+#define VP9_PROB_BUF_SIZE 2560
+#define VP9_COUNTS_BUF_SIZE 16384
+
+#define FOR_EACH_COEF_PROBS_BAND(t, i, j, k) \
+	for (t = 0; t < 4; t++) \
+		for (i = 0; i < 2; i++) \
+			for (j = 0; j < 2; j++) \
+				for (k = 0; k < 6; k++)
+
+#define HDR_FLAG(x) (!!((hdr)->flags & V4L2_VP9_FRAME_FLAG_##x))
+#define LF_FLAG(x) (!!((lf)->flags & V4L2_VP9_LOOP_FILTER_FLAG_##x))
+#define SEG_FLAG(x) (!!((seg)->flags & V4L2_VP9_SEGMENTATION_FLAG_##x))
+
+/**
+ * struct vdec_vp9_slice_frame_ctx - vp9 prob tables footprint
+ */
+struct vdec_vp9_slice_frame_ctx {
+	struct {
+		__u8 probs[6][3];
+		__u8 padding[2];
+	} coef_probs[4][2][2][6];
+
+	__u8 y_mode_prob[4][16];
+	__u8 switch_interp_prob[4][16];
+	__u8 seg[32];  /* ignore */
+	__u8 comp_inter_prob[16];
+	__u8 comp_ref_prob[16];
+	__u8 single_ref_prob[5][2];
+	__u8 single_ref_prob_padding[6];
+
+	__u8 joint[3];
+	__u8 joint_padding[13];
+	struct {
+		__u8 sign;
+		__u8 classes[10];
+		__u8 padding[5];
+	} sign_classes[2];
+	struct {
+		__u8 class0[1];
+		__u8 bits[10];
+		__u8 padding[5];
+	} class0_bits[2];
+	struct {
+		__u8 class0_fp[2][3];
+		__u8 fp[3];
+		__u8 class0_hp;
+		__u8 hp;
+		__u8 padding[5];
+	} class0_fp_hp[2];
+
+	__u8 uv_mode_prob[10][16];
+	__u8 uv_mode_prob_padding[2][16];
+
+	__u8 partition_prob[16][4];
+
+	__u8 inter_mode_probs[7][4];
+	__u8 skip_probs[4];
+
+	__u8 tx_p8x8[2][4];
+	__u8 tx_p16x16[2][4];
+	__u8 tx_p32x32[2][4];
+	__u8 intra_inter_prob[8];
+};
+
+/**
+ * struct vdec_vp9_slice_frame_counts - vp9 counts tables footprint
+ */
+struct vdec_vp9_slice_frame_counts {
+	union {
+		struct {
+			__u32 band_0[3];
+			__u32 padding0[1];
+			__u32 band_1_5[5][6];
+			__u32 padding1[2];
+		} eob_branch[4][2][2];
+		__u32 eob_branch_space[256 * 4];
+	};
+
+	struct {
+		__u32 band_0[3][4];
+		__u32 band_1_5[5][6][4];
+	} coef_probs[4][2][2];
+
+	__u32 intra_inter[4][2];
+	__u32 comp_inter[5][2];
+	__u32 comp_inter_padding[2];
+	__u32 comp_ref[5][2];
+	__u32 comp_ref_padding[2];
+	__u32 single_ref[5][2][2];
+	__u32 inter_mode[7][4];
+	__u32 y_mode[4][12];
+	__u32 uv_mode[10][10];
+	__u32 partition[16][4];
+	__u32 switchable_interp[4][4];
+
+	__u32 tx_p8x8[2][2];
+	__u32 tx_p16x16[2][4];
+	__u32 tx_p32x32[2][4];
+
+	__u32 skip[3][4];
+
+	__u32 joint[4];
+
+	struct {
+		__u32 sign[2];
+		__u32 class0[2];
+		__u32 classes[12];
+		__u32 bits[10][2];
+		__u32 padding[4];
+		__u32 class0_fp[2][4];
+		__u32 fp[4];
+		__u32 class0_hp[2];
+		__u32 hp[2];
+	} mvcomp[2];
+
+	__u32 reserved[126][4];
+};
+
+/**
+ * struct vdec_vp9_slice_uncompressed_header - vp9 uncompressed header syntax
+ *                                             used for decoding
+ */
+struct vdec_vp9_slice_uncompressed_header {
+	__u8 profile;
+	__u8 last_frame_type;
+	__u8 frame_type;
+
+	__u8 last_show_frame;
+	__u8 show_frame;
+	__u8 error_resilient_mode;
+
+	__u8 bit_depth;
+	__u8 padding0[1];
+	__u16 last_frame_width;
+	__u16 last_frame_height;
+	__u16 frame_width;
+	__u16 frame_height;
+
+	__u8 intra_only;
+	__u8 reset_frame_context;
+	__u8 ref_frame_sign_bias[4];
+	__u8 allow_high_precision_mv;
+	__u8 interpolation_filter;
+
+	__u8 refresh_frame_context;
+	__u8 frame_parallel_decoding_mode;
+	__u8 frame_context_idx;
+
+	/* loop_filter_params */
+	__u8 loop_filter_level;
+	__u8 loop_filter_sharpness;
+	__u8 loop_filter_delta_enabled;
+	__s8 loop_filter_ref_deltas[4];
+	__s8 loop_filter_mode_deltas[2];
+
+	/* quantization_params */
+	__u8 base_q_idx;
+	__s8 delta_q_y_dc;
+	__s8 delta_q_uv_dc;
+	__s8 delta_q_uv_ac;
+
+	/* segmentation_params */
+	__u8 segmentation_enabled;
+	__u8 segmentation_update_map;
+	__u8 segmentation_tree_probs[7];
+	__u8 padding1[1];
+	__u8 segmentation_temporal_udpate;
+	__u8 segmentation_pred_prob[3];
+	__u8 segmentation_update_data;
+	__u8 segmentation_abs_or_delta_update;
+	__u8 feature_enabled[8];
+	__s16 feature_value[8][4];
+
+	/* tile_info */
+	__u8 tile_cols_log2;
+	__u8 tile_rows_log2;
+	__u8 padding2[2];
+
+	__u16 uncompressed_header_size;
+	__u16 header_size_in_bytes;
+
+	/* LAT OUT, CORE IN */
+	__u32 dequant[8][4];
+};
+
+/**
+ * struct vdec_vp9_slice_compressed_header - vp9 compressed header syntax
+ *                                           used for decoding.
+ */
+struct vdec_vp9_slice_compressed_header {
+	__u8 tx_mode;
+	__u8 ref_mode;
+	__u8 comp_fixed_ref;
+	__u8 comp_var_ref[2];
+	__u8 padding[3];
+};
+
+/**
+ * struct vdec_vp9_slice_tiles - vp9 tile syntax
+ */
+struct vdec_vp9_slice_tiles {
+	__u32 size[4][64];
+	__u32 mi_rows[4];
+	__u32 mi_cols[64];
+	__u8 actual_rows;
+	__u8 padding[7];
+};
+
+/**
+ * struct vdec_vp9_slice_reference - vp9 reference frame information
+ */
+struct vdec_vp9_slice_reference {
+	__u16 frame_width;
+	__u16 frame_height;
+	__u8 bit_depth;
+	__u8 subsampling_x;
+	__u8 subsampling_y;
+	__u8 padding;
+};
+
+/**
+ * struct vdec_vp9_slice_frame - vp9 syntax used for decoding
+ */
+struct vdec_vp9_slice_frame {
+	struct vdec_vp9_slice_uncompressed_header uh;
+	struct vdec_vp9_slice_compressed_header ch;
+	struct vdec_vp9_slice_tiles tiles;
+	struct vdec_vp9_slice_reference ref[3];
+};
+
+/**
+ * struct vdec_vp9_slice_init_vsi - VSI used to initialize instance
+ */
+struct vdec_vp9_slice_init_vsi {
+	unsigned int architecture;
+	unsigned int reserved;
+	uint64_t core_vsi;
+	/* default frame context's position in MicroP */
+	uint64_t default_frame_ctx;
+};
+
+/**
+ * struct vdec_vp9_slice_mem - memory address and size
+ */
+struct vdec_vp9_slice_mem {
+	union {
+		uint64_t buf;
+		dma_addr_t dma_addr;
+	};
+	union {
+		size_t size;
+		dma_addr_t dma_addr_end;
+		uint64_t padding;
+	};
+};
+
+/**
+ * struct vdec_vp9_slice_bs - input buffer for decoding
+ */
+struct vdec_vp9_slice_bs {
+	struct vdec_vp9_slice_mem buf;
+	struct vdec_vp9_slice_mem frame;
+};
+
+/**
+ * struct vdec_vp9_slice_fb - frame buffer for decoding
+ */
+struct vdec_vp9_slice_fb {
+	struct vdec_vp9_slice_mem y;
+	struct vdec_vp9_slice_mem c;
+};
+
+/**
+ * struct vdec_vp9_slice_state - decoding state
+ */
+struct vdec_vp9_slice_state {
+	int err;
+	unsigned int full;
+	unsigned int timeout;
+	unsigned int perf;
+
+	unsigned int crc[12];
+};
+
+/*
+ * struct vdec_vp9_slice_vsi - exchange decoding information
+ *                             between Main CPU and MicroP
+ * @bs          : input buffer
+ * @fb          : output buffer
+ * @ref         : 3 reference buffers
+ * @mv          : mv working buffer
+ * @seg         : segmentation working buffer
+ * @tile        : tile buffer
+ * @prob        : prob table buffer, used to set/update prob table
+ * @counts      : counts table buffer, used to update prob table
+ * @ube         : general buffer
+ * @trans       : trans buffer position in general buffer
+ * @err_map     : error buffer
+ * @row_info    : row info buffer
+ * @frame       : decoding syntax
+ * @state       : decoding state
+ */
+struct vdec_vp9_slice_vsi {
+	/* used in LAT stage */
+	struct vdec_vp9_slice_bs bs;
+	/* used in Core stage */
+	struct vdec_vp9_slice_fb fb;
+	struct vdec_vp9_slice_fb ref[3];
+
+	struct vdec_vp9_slice_mem mv[2];
+	struct vdec_vp9_slice_mem seg[2];
+	struct vdec_vp9_slice_mem tile;
+	struct vdec_vp9_slice_mem prob;
+	struct vdec_vp9_slice_mem counts;
+
+	/* LAT stage's output, Core stage's input */
+	struct vdec_vp9_slice_mem ube;
+	struct vdec_vp9_slice_mem trans;
+	struct vdec_vp9_slice_mem err_map;
+	struct vdec_vp9_slice_mem row_info;
+
+	/* decoding parameters */
+	struct vdec_vp9_slice_frame frame;
+
+	struct vdec_vp9_slice_state state;
+};
+
+/*
+ * struct vdec_vp9_slice_pfc - per-frame context that contains a local vsi.
+ *                             pass it from lat to core
+ * @vsi         : local vsi. copy to/from remote vsi before/after decoding
+ * @ref_idx     : reference buffer index
+ * @seq         : picture sequence
+ * @state       : decoding state
+ */
+struct vdec_vp9_slice_pfc {
+	struct vdec_vp9_slice_vsi vsi;
+
+	u64 ref_idx[3];
+
+	int seq;
+
+	/* LAT/Core CRC */
+	struct vdec_vp9_slice_state state[2];
+};
+
+/*
+ * enum vdec_vp9_slice_resolution_level
+ */
+enum vdec_vp9_slice_resolution_level {
+	VP9_RES_NONE,
+	VP9_RES_FHD,
+	VP9_RES_4K,
+	VP9_RES_8K,
+};
+
+/*
+ * struct vdec_vp9_slice_ref - picture's width & height should kept
+ *                             for later decoding as reference picture
+ */
+struct vdec_vp9_slice_ref {
+	unsigned int width;
+	unsigned int height;
+};
+
+/*
+ * struct vdec_vp9_slice_instance - represent one vp9 instance
+ * @ctx         : pointer to codec's context
+ * @vpu         : VPU instance
+ * @seq         : global picture sequence
+ * @level       : level of current resolution
+ * @width       : width of last picture
+ * @height      : height of last picture
+ * @frame_type  : frame_type of last picture
+ * @irq         : irq to Main CPU or MicroP
+ * @show_frame  : show_frame of last picture
+ * @dpb         : picture information (width/height) for reference
+ * @mv          : mv working buffer
+ * @seg         : segmentation working buffer
+ * @tile        : tile buffer
+ * @prob        : prob table buffer, used to set/update prob table
+ * @counts      : counts table buffer, used to update prob table
+ * @frame_ctx   : 4 frame context according to VP9 Spec
+ * @dirty       : state of each frame context
+ * @init_vsi    : vsi used for initialized VP9 instance
+ * @vsi         : vsi used for decoding/flush ...
+ * @core_vsi    : vsi used for Core stage
+ */
+struct vdec_vp9_slice_instance {
+	struct mtk_vcodec_ctx *ctx;
+	struct vdec_vpu_inst vpu;
+
+	int seq;
+
+	enum vdec_vp9_slice_resolution_level level;
+
+	/* for resolution change and get_pic_info */
+	unsigned int width;
+	unsigned int height;
+
+	/* for last_frame_type */
+	unsigned int frame_type;
+	unsigned int irq;
+
+	unsigned int show_frame;
+
+	/* maintain vp9 reference frame state */
+	struct vdec_vp9_slice_ref dpb[VB2_MAX_FRAME];
+
+	/*
+	 * normal working buffers
+	 * mv[0]/seg[0]/tile/prob/counts is used for LAT
+	 * mv[1]/seg[1] is used for CORE
+	 */
+	struct mtk_vcodec_mem mv[2];
+	struct mtk_vcodec_mem seg[2];
+	struct mtk_vcodec_mem tile;
+	struct mtk_vcodec_mem prob;
+	struct mtk_vcodec_mem counts;
+
+	/* 4 prob tables */
+	struct vdec_vp9_slice_frame_ctx frame_ctx[4];
+	unsigned char dirty[4];
+
+	/* MicroP vsi */
+	union {
+		struct vdec_vp9_slice_init_vsi *init_vsi;
+		struct vdec_vp9_slice_vsi *vsi;
+	};
+	struct vdec_vp9_slice_vsi *core_vsi;
+};
+
+/*
+ * (2, (0, (1, 3)))
+ * max level = 2
+ */
+static const signed char vdec_vp9_slice_inter_mode_tree[6] = {
+	-2, 2, 0, 4, -1, -3
+};
+
+/* max level = 6 */
+static const signed char vdec_vp9_slice_intra_mode_tree[18] = {
+	0, 2, -9, 4, -1, 6, 8, 12, -2, 10, -4, -5, -3, 14, -8, 16, -6, -7
+};
+
+/* max level = 2 */
+static const signed char vdec_vp9_slice_partition_tree[6] = {
+	0, 2, -1, 4, -2, -3
+};
+
+/* max level = 1 */
+static const signed char vdec_vp9_slice_switchable_interp_tree[4] = {
+	0, 2, -1, -2
+};
+
+/* max level = 2 */
+static const signed char vdec_vp9_slice_mv_joint_tree[6] = {
+	0, 2, -1, 4, -2, -3
+};
+
+/* max level = 6 */
+static const signed char vdec_vp9_slice_mv_class_tree[20] = {
+	0, 2, -1, 4, 6, 8, -2, -3, 10, 12,
+	-4, -5, -6, 14, 16, 18, -7, -8, -9, -10
+};
+
+/* max level = 0 */
+static const signed char vdec_vp9_slice_mv_class0_tree[2] = {
+	0, -1
+};
+
+/* max level = 2 */
+static const signed char vdec_vp9_slice_mv_fp_tree[6] = {
+	0, 2, -1, 4, -2, -3
+};
+
+/*
+ * all VP9 instances could share this default frame context.
+ */
+static struct vdec_vp9_slice_frame_ctx *vdec_vp9_slice_default_frame_ctx;
+static DEFINE_MUTEX(vdec_vp9_slice_frame_ctx_lock);
+
+static int vdec_vp9_slice_core_decode(
+	struct vdec_lat_buf *lat_buf);
+
+static int vdec_vp9_slice_init_default_frame_ctx(
+	struct vdec_vp9_slice_instance *instance)
+{
+	struct vdec_vp9_slice_frame_ctx *remote_frame_ctx;
+	struct vdec_vp9_slice_frame_ctx *frame_ctx;
+	struct mtk_vcodec_ctx *ctx;
+	struct vdec_vp9_slice_init_vsi *vsi;
+	int ret = 0;
+
+	ctx = instance->ctx;
+	vsi = instance->vpu.vsi;
+	if (!ctx || !vsi) {
+		mtk_vcodec_err(instance, "invalid ctx or vsi 0x%px 0x%px\n",
+			ctx, vsi);
+		return -EINVAL;
+	}
+
+	remote_frame_ctx = mtk_vcodec_fw_map_dm_addr(ctx->dev->fw_handler,
+		(u32)vsi->default_frame_ctx);
+	if (!remote_frame_ctx) {
+		mtk_vcodec_err(instance, "failed to map default frame ctx\n");
+		return -EINVAL;
+	}
+
+	mtk_vcodec_debug(instance, "map default frame ctx to 0x%px\n",
+		remote_frame_ctx);
+
+	mutex_lock(&vdec_vp9_slice_frame_ctx_lock);
+
+	if (vdec_vp9_slice_default_frame_ctx)
+		goto out;
+
+	frame_ctx = kmalloc(sizeof(*frame_ctx), GFP_KERNEL);
+	if (!frame_ctx) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	memcpy_fromio(frame_ctx, remote_frame_ctx, sizeof(*frame_ctx));
+	vdec_vp9_slice_default_frame_ctx = frame_ctx;
+
+out:
+	mutex_unlock(&vdec_vp9_slice_frame_ctx_lock);
+
+	return ret;
+}
+
+static int vdec_vp9_slice_alloc_working_buffer(
+	struct vdec_vp9_slice_instance *instance,
+	struct vdec_vp9_slice_vsi *vsi)
+{
+	struct mtk_vcodec_ctx *ctx = instance->ctx;
+	enum vdec_vp9_slice_resolution_level level;
+	/* super blocks */
+	unsigned int max_sb_w;
+	unsigned int max_sb_h;
+	unsigned int max_w;
+	unsigned int max_h;
+	unsigned int w;
+	unsigned int h;
+	size_t size;
+	int ret;
+	int i;
+
+	w = vsi->frame.uh.frame_width;
+	h = vsi->frame.uh.frame_height;
+
+	if (w > VCODEC_DEC_4K_CODED_WIDTH ||
+		h > VCODEC_DEC_4K_CODED_HEIGHT) {
+		/* 8K? */
+		return -EINVAL;
+	} else if (w > MTK_VDEC_MAX_W || h > MTK_VDEC_MAX_H) {
+		/* 4K */
+		level = VP9_RES_4K;
+		max_w = VCODEC_DEC_4K_CODED_WIDTH;
+		max_h = VCODEC_DEC_4K_CODED_HEIGHT;
+	} else {
+		/* FHD */
+		level = VP9_RES_FHD;
+		max_w = MTK_VDEC_MAX_W;
+		max_h = MTK_VDEC_MAX_H;
+	}
+
+	if (level == instance->level)
+		return 0;
+
+	mtk_vcodec_debug(instance,
+		"resolution level changed, from %u to %u, %ux%u",
+		instance->level, level, w, h);
+
+	max_sb_w = DIV_ROUND_UP(max_w, 64);
+	max_sb_h = DIV_ROUND_UP(max_h, 64);
+	ret = -ENOMEM;
+
+	/*
+	 * Lat-flush must wait core idle, otherwise core will
+	 * use released buffers
+	 */
+
+	size = (max_sb_w * max_sb_h + 2) * 576;
+	for (i = 0; i < 2; i++) {
+		if (instance->mv[i].va)
+			mtk_vcodec_mem_free(ctx, &instance->mv[i]);
+		instance->mv[i].size = size;
+		if (mtk_vcodec_mem_alloc(ctx, &instance->mv[i]))
+			goto err;
+	}
+
+	size = (max_sb_w * max_sb_h * 32) + 256;
+	for (i = 0; i < 2; i++) {
+		if (instance->seg[i].va)
+			mtk_vcodec_mem_free(ctx, &instance->seg[i]);
+		instance->seg[i].size = size;
+		if (mtk_vcodec_mem_alloc(ctx, &instance->seg[i]))
+			goto err;
+	}
+
+	if (!instance->tile.va) {
+		instance->tile.size = VP9_TILE_BUF_SIZE;
+		if (mtk_vcodec_mem_alloc(ctx, &instance->tile))
+			goto err;
+	}
+
+	if (!instance->prob.va) {
+		instance->prob.size = VP9_PROB_BUF_SIZE;
+		if (mtk_vcodec_mem_alloc(ctx, &instance->prob))
+			goto err;
+	}
+
+	if (!instance->counts.va) {
+		instance->counts.size = VP9_COUNTS_BUF_SIZE;
+		if (mtk_vcodec_mem_alloc(ctx, &instance->counts))
+			goto err;
+	}
+
+	instance->level = level;
+	return 0;
+
+err:
+	instance->level = VP9_RES_NONE;
+	return ret;
+}
+
+static void vdec_vp9_slice_free_working_buffer(
+	struct vdec_vp9_slice_instance *instance)
+{
+	struct mtk_vcodec_ctx *ctx = instance->ctx;
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(instance->mv); i++) {
+		if (instance->mv[i].va)
+			mtk_vcodec_mem_free(ctx, &instance->mv[i]);
+	}
+	for (i = 0; i < ARRAY_SIZE(instance->seg); i++) {
+		if (instance->seg[i].va)
+			mtk_vcodec_mem_free(ctx, &instance->seg[i]);
+	}
+	if (instance->tile.va)
+		mtk_vcodec_mem_free(ctx, &instance->tile);
+	if (instance->prob.va)
+		mtk_vcodec_mem_free(ctx, &instance->prob);
+	if (instance->counts.va)
+		mtk_vcodec_mem_free(ctx, &instance->counts);
+
+	instance->level = VP9_RES_NONE;
+}
+
+static void vdec_vp9_slice_vsi_from_remote(
+	struct vdec_vp9_slice_vsi *vsi,
+	struct vdec_vp9_slice_vsi *remote_vsi,
+	int skip)
+{
+	struct vdec_vp9_slice_frame *rf;
+	struct vdec_vp9_slice_frame *f;
+
+	/*
+	 * compressed header
+	 * dequant
+	 * buffer position
+	 * decode state
+	 */
+	if (!skip) {
+		rf = &remote_vsi->frame;
+		f = &vsi->frame;
+		memcpy_fromio(&f->ch, &rf->ch, sizeof(f->ch));
+		memcpy_fromio(&f->uh.dequant, &rf->uh.dequant,
+			sizeof(f->uh.dequant));
+		memcpy_fromio(&vsi->trans, &remote_vsi->trans,
+			sizeof(vsi->trans));
+	}
+
+	memcpy_fromio(&vsi->state, &remote_vsi->state, sizeof(vsi->state));
+}
+
+static void vdec_vp9_slice_vsi_to_remote(
+	struct vdec_vp9_slice_vsi *vsi,
+	struct vdec_vp9_slice_vsi *remote_vsi)
+{
+	memcpy_toio(remote_vsi, vsi, sizeof(*vsi));
+}
+
+static int vdec_vp9_slice_tile_offset(int idx,
+	int mi_num, int tile_log2)
+{
+	int sbs = (mi_num + 7) >> 3;
+	int offset = ((idx * sbs) >> tile_log2) << 3;
+	return offset < mi_num ? offset : mi_num;
+}
+
+static int vdec_vp9_slice_setup_lat_from_src_buf(
+	struct vdec_vp9_slice_instance *instance,
+	struct vdec_lat_buf *lat_buf)
+{
+	struct vb2_v4l2_buffer *src;
+	struct vb2_v4l2_buffer *dst;
+
+	src = v4l2_m2m_next_src_buf(instance->ctx->m2m_ctx);
+	if (!src)
+		return -EINVAL;
+
+	dst = &lat_buf->ts_info;
+	v4l2_m2m_buf_copy_metadata(src, dst, true);
+	return 0;
+}
+
+static void vdec_vp9_slice_setup_hdr(
+	struct vdec_vp9_slice_instance *instance,
+	struct vdec_vp9_slice_uncompressed_header *uh,
+	struct v4l2_ctrl_vp9_frame_decode_params *hdr)
+{
+	int i;
+
+	uh->profile = hdr->profile;
+	uh->last_frame_type = instance->frame_type;
+	uh->frame_type = !HDR_FLAG(KEY_FRAME);
+	uh->last_show_frame = instance->show_frame;
+	uh->show_frame = HDR_FLAG(SHOW_FRAME);
+	uh->error_resilient_mode = HDR_FLAG(ERROR_RESILIENT);
+	uh->bit_depth = hdr->bit_depth;
+	uh->last_frame_width = instance->width;
+	uh->last_frame_height = instance->height;
+	uh->frame_width = hdr->frame_width_minus_1 + 1;
+	uh->frame_height = hdr->frame_height_minus_1 + 1;
+	uh->intra_only = HDR_FLAG(INTRA_ONLY);
+	/* map v4l2 enum to values defined in VP9 spec for firmware */
+	switch (hdr->reset_frame_context) {
+	case V4L2_VP9_RESET_FRAME_CTX_NONE:
+		uh->reset_frame_context = VP9_RESET_FRAME_CONTEXT_NONE0;
+		break;
+	case V4L2_VP9_RESET_FRAME_CTX_SPEC:
+		uh->reset_frame_context = VP9_RESET_FRAME_CONTEXT_SPEC;
+		break;
+	case V4L2_VP9_RESET_FRAME_CTX_ALL:
+		uh->reset_frame_context = VP9_RESET_FRAME_CONTEXT_ALL;
+		break;
+	default:
+		uh->reset_frame_context = VP9_RESET_FRAME_CONTEXT_NONE0;
+		break;
+	}
+	/*
+	 * ref_frame_sign_bias specifies the intended direction
+	 * of the motion vector in time for each reference frame.
+	 * - INTRA_FRAME = 0,
+	 * - LAST_FRAME = 1,
+	 * - GOLDEN_FRAME = 2,
+	 * - ALTREF_FRAME = 3,
+	 * ref_frame_sign_biases[INTRA_FRAME] is always 0
+	 * and VDA only passes another 3 directions
+	 */
+	uh->ref_frame_sign_bias[0] = 0;
+	for (i = 0; i < 3; i++)
+		uh->ref_frame_sign_bias[i + 1] =
+			!!(hdr->ref_frame_sign_biases & (1 << i));
+	uh->allow_high_precision_mv = HDR_FLAG(ALLOW_HIGH_PREC_MV);
+	uh->interpolation_filter = hdr->interpolation_filter;
+	uh->refresh_frame_context = HDR_FLAG(REFRESH_FRAME_CTX);
+	uh->frame_parallel_decoding_mode = HDR_FLAG(PARALLEL_DEC_MODE);
+	uh->frame_context_idx = hdr->frame_context_idx;
+
+	/* tile info */
+	uh->tile_cols_log2 = hdr->tile_cols_log2;
+	uh->tile_rows_log2 = hdr->tile_rows_log2;
+
+	uh->uncompressed_header_size = hdr->uncompressed_header_size;
+	uh->header_size_in_bytes = hdr->compressed_header_size;
+}
+
+static void vdec_vp9_slice_setup_frame_ctx(
+	struct vdec_vp9_slice_instance *instance,
+	struct vdec_vp9_slice_uncompressed_header *uh,
+	struct v4l2_ctrl_vp9_frame_decode_params *hdr)
+{
+	int error_resilient_mode;
+	int reset_frame_context;
+	int key_frame;
+	int intra_only;
+	int i;
+
+	key_frame = HDR_FLAG(KEY_FRAME);
+	intra_only = HDR_FLAG(INTRA_ONLY);
+	error_resilient_mode = HDR_FLAG(ERROR_RESILIENT);
+	reset_frame_context = uh->reset_frame_context;
+
+	/*
+	 * according to "6.2 Uncompressed header syntax" in
+	 * "VP9 Bitstream & Decoding Process Specification",
+	 * reset @frame_context_idx when (FrameIsIntra || error_resilient_mode)
+	 */
+	if (key_frame || intra_only || error_resilient_mode) {
+		/*
+		 * @reset_frame_context specifies
+		 * whether the frame context should be
+		 * reset to default values:
+		 * 0 or 1 means do not reset any frame context
+		 * 2 resets just the context specified in the frame header
+		 * 3 resets all contexts
+		 */
+		if (key_frame || error_resilient_mode ||
+			reset_frame_context == 3) {
+			/* use default table */
+			for (i = 0; i < 4; i++)
+				instance->dirty[i] = 0;
+		} else if (reset_frame_context == 2) {
+			instance->dirty[uh->frame_context_idx] = 0;
+		} else {
+			;
+		}
+		uh->frame_context_idx = 0;
+	}
+}
+
+static void vdec_vp9_slice_setup_loop_filter(
+	struct vdec_vp9_slice_uncompressed_header *uh,
+	struct v4l2_vp9_loop_filter *lf)
+{
+	int i;
+
+	uh->loop_filter_level = lf->level;
+	uh->loop_filter_sharpness = lf->sharpness;
+	uh->loop_filter_delta_enabled = LF_FLAG(DELTA_ENABLED);
+	for (i = 0; i < 4; i++)
+		uh->loop_filter_ref_deltas[i] = lf->ref_deltas[i];
+	for (i = 0; i < 2; i++)
+		uh->loop_filter_mode_deltas[i] = lf->mode_deltas[i];
+}
+
+static void vdec_vp9_slice_setup_quantization(
+	struct vdec_vp9_slice_uncompressed_header *uh,
+	struct v4l2_vp9_quantization *quant)
+{
+	uh->base_q_idx = quant->base_q_idx;
+	uh->delta_q_y_dc = quant->delta_q_y_dc;
+	uh->delta_q_uv_dc = quant->delta_q_uv_dc;
+	uh->delta_q_uv_ac = quant->delta_q_uv_ac;
+}
+
+static void vdec_vp9_slice_setup_segmentation(
+	struct vdec_vp9_slice_uncompressed_header *uh,
+	struct v4l2_vp9_segmentation *seg)
+{
+	int i;
+	int j;
+
+	uh->segmentation_enabled = SEG_FLAG(ENABLED);
+	uh->segmentation_update_map = SEG_FLAG(UPDATE_MAP);
+	for (i = 0; i < 7; i++)
+		uh->segmentation_tree_probs[i] = seg->tree_probs[i];
+	uh->segmentation_temporal_udpate = SEG_FLAG(TEMPORAL_UPDATE);
+	for (i = 0; i < 3; i++)
+		uh->segmentation_pred_prob[i] = seg->pred_probs[i];
+	uh->segmentation_update_data = SEG_FLAG(UPDATE_DATA);
+	uh->segmentation_abs_or_delta_update = SEG_FLAG(ABS_OR_DELTA_UPDATE);
+	for (i = 0; i < 8; i++) {
+		uh->feature_enabled[i] = seg->feature_enabled[i];
+		for (j = 0; j < 4; j++)
+			uh->feature_value[i][j] = seg->feature_data[i][j];
+	}
+}
+
+static int vdec_vp9_slice_setup_tile(struct vdec_vp9_slice_vsi *vsi,
+	struct v4l2_ctrl_vp9_frame_decode_params *hdr)
+{
+	unsigned int rows_log2;
+	unsigned int cols_log2;
+	unsigned int rows;
+	unsigned int cols;
+	unsigned int mi_rows;
+	unsigned int mi_cols;
+	struct vdec_vp9_slice_tiles *tiles;
+	int offset;
+	int start;
+	int end;
+	int i;
+
+	rows_log2 = hdr->tile_rows_log2;
+	cols_log2 = hdr->tile_cols_log2;
+	rows = 1 << rows_log2;
+	cols = 1 << cols_log2;
+	tiles = &vsi->frame.tiles;
+	tiles->actual_rows = 0;
+
+	if (rows > 4 || cols > 64)
+		return -EINVAL;
+
+	/* setup mi rows/cols information */
+	mi_rows = (hdr->frame_height_minus_1 + 1 + 7) >> 3;
+	mi_cols = (hdr->frame_width_minus_1 + 1 + 7) >> 3;
+
+	for (i = 0; i < rows; i++) {
+		start = vdec_vp9_slice_tile_offset(i, mi_rows, rows_log2);
+		end = vdec_vp9_slice_tile_offset(i + 1, mi_rows, rows_log2);
+		offset = end - start;
+		tiles->mi_rows[i] = (offset + 7) >> 3;
+		if (tiles->mi_rows[i])
+			tiles->actual_rows++;
+	}
+
+	for (i = 0; i < cols; i++) {
+		start = vdec_vp9_slice_tile_offset(i, mi_cols, cols_log2);
+		end = vdec_vp9_slice_tile_offset(i + 1, mi_cols, cols_log2);
+		offset = end - start;
+		tiles->mi_cols[i] = (offset + 7) >> 3;
+	}
+
+	return 0;
+}
+
+static void vdec_vp9_slice_setup_state(struct vdec_vp9_slice_vsi *vsi)
+{
+	memset(&vsi->state, 0, sizeof(vsi->state));
+}
+
+static void vdec_vp9_slice_setup_ref_idx(
+	struct vdec_vp9_slice_pfc *pfc,
+	struct v4l2_ctrl_vp9_frame_decode_params *hdr)
+{
+	int i;
+
+	for (i = 0; i < 3; i++)
+		pfc->ref_idx[i] = hdr->refs[i];
+}
+
+static int vdec_vp9_slice_setup_pfc(
+	struct vdec_vp9_slice_instance *instance,
+	struct vdec_vp9_slice_pfc *pfc)
+{
+	struct v4l2_ctrl_vp9_frame_decode_params *hdr;
+	struct vdec_vp9_slice_uncompressed_header *uh;
+	struct v4l2_ctrl *hdr_ctrl;
+	struct vdec_vp9_slice_vsi *vsi;
+	int ret;
+
+	/* frame header */
+	hdr_ctrl = v4l2_ctrl_find(&instance->ctx->ctrl_hdl,
+		V4L2_CID_MPEG_VIDEO_VP9_FRAME_DECODE_PARAMS);
+	if (!hdr_ctrl || !hdr_ctrl->p_cur.p)
+		return -EINVAL;
+	hdr = hdr_ctrl->p_cur.p;
+
+	vsi = &pfc->vsi;
+	uh = &vsi->frame.uh;
+
+	/* setup vsi information */
+	vdec_vp9_slice_setup_hdr(instance, uh, hdr);
+	vdec_vp9_slice_setup_frame_ctx(instance, uh, hdr);
+	vdec_vp9_slice_setup_loop_filter(uh, &hdr->lf);
+	vdec_vp9_slice_setup_quantization(uh, &hdr->quant);
+	vdec_vp9_slice_setup_segmentation(uh, &hdr->seg);
+	ret = vdec_vp9_slice_setup_tile(vsi, hdr);
+	if (ret)
+		return ret;
+	vdec_vp9_slice_setup_state(vsi);
+
+	/* core stage needs buffer index to get ref y/c ... */
+	vdec_vp9_slice_setup_ref_idx(pfc, hdr);
+
+	pfc->seq = instance->seq;
+	instance->seq++;
+
+	return 0;
+}
+
+static int vdec_vp9_slice_setup_lat_buffer(
+	struct vdec_vp9_slice_instance *instance,
+	struct vdec_vp9_slice_vsi *vsi,
+	struct mtk_vcodec_mem *bs,
+	struct vdec_lat_buf *lat_buf)
+{
+	int i;
+
+	vsi->bs.buf.dma_addr = bs->dma_addr;
+	vsi->bs.buf.size = bs->size;
+	vsi->bs.frame.dma_addr = bs->dma_addr;
+	vsi->bs.frame.size = bs->size;
+
+	for (i = 0; i < 2; i++) {
+		vsi->mv[i].dma_addr = instance->mv[i].dma_addr;
+		vsi->mv[i].size = instance->mv[i].size;
+	}
+	for (i = 0; i < 2; i++) {
+		vsi->seg[i].dma_addr = instance->seg[i].dma_addr;
+		vsi->seg[i].size = instance->seg[i].size;
+	}
+	vsi->tile.dma_addr = instance->tile.dma_addr;
+	vsi->tile.size = instance->tile.size;
+	vsi->prob.dma_addr = instance->prob.dma_addr;
+	vsi->prob.size = instance->prob.size;
+	vsi->counts.dma_addr = instance->counts.dma_addr;
+	vsi->counts.size = instance->counts.size;
+
+	vsi->ube.dma_addr = lat_buf->ctx->msg_queue.wdma_addr.dma_addr;
+	vsi->ube.size = lat_buf->ctx->msg_queue.wdma_addr.size;
+	vsi->trans.dma_addr = lat_buf->ctx->msg_queue.wdma_wptr_addr;
+	/* used to store trans end */
+	vsi->trans.dma_addr_end = lat_buf->ctx->msg_queue.wdma_rptr_addr;
+	vsi->err_map.dma_addr = lat_buf->wdma_err_addr.dma_addr;
+	vsi->err_map.size = lat_buf->wdma_err_addr.size;
+
+	vsi->row_info.buf = lat_buf->roy_buf_addr.dma_addr;
+	vsi->row_info.size = lat_buf->roy_buf_addr.size;
+
+	return 0;
+}
+
+static int vdec_vp9_slice_setup_prob_buffer(
+	struct vdec_vp9_slice_instance *instance,
+	struct vdec_vp9_slice_vsi *vsi)
+{
+	struct vdec_vp9_slice_frame_ctx *frame_ctx;
+	struct vdec_vp9_slice_uncompressed_header *uh;
+
+	uh = &vsi->frame.uh;
+
+	mtk_vcodec_debug(instance, "ctx dirty %u idx %d\n",
+		instance->dirty[uh->frame_context_idx], uh->frame_context_idx);
+
+	if (instance->dirty[uh->frame_context_idx])
+		frame_ctx = &instance->frame_ctx[uh->frame_context_idx];
+	else
+		frame_ctx = vdec_vp9_slice_default_frame_ctx;
+	memcpy(instance->prob.va, frame_ctx, sizeof(*frame_ctx));
+
+	return 0;
+}
+
+static void vdec_vp9_slice_setup_seg_buffer(
+	struct vdec_vp9_slice_instance *instance,
+	struct vdec_vp9_slice_vsi *vsi,
+	struct mtk_vcodec_mem *buf)
+{
+	struct vdec_vp9_slice_uncompressed_header *uh;
+
+	/* reset segment buffer */
+	uh = &vsi->frame.uh;
+	if (uh->frame_type == 0 ||
+		uh->intra_only ||
+		uh->error_resilient_mode ||
+		uh->frame_width != instance->width ||
+		uh->frame_height != instance->height) {
+		mtk_vcodec_debug(instance, "reset seg\n");
+		memset(buf->va, 0, buf->size);
+	}
+}
+
+/*
+ * parse tiles according to `6.4 Decode tiles syntax`
+ * in "vp9-bitstream-specification"
+ *
+ * frame contains uncompress header, compressed header and several tiles.
+ * this function parses tiles' position and size, stores them to tile buffer
+ * for decoding.
+ */
+static int vdec_vp9_slice_setup_tile_buffer(
+	struct vdec_vp9_slice_instance *instance,
+	struct vdec_vp9_slice_vsi * vsi,
+	struct mtk_vcodec_mem *bs)
+{
+	struct vdec_vp9_slice_uncompressed_header *uh;
+	unsigned int rows_log2;
+	unsigned int cols_log2;
+	unsigned int rows;
+	unsigned int cols;
+	unsigned int mi_row;
+	unsigned int mi_col;
+	unsigned int offset;
+	unsigned int pa;
+	unsigned int size;
+	struct vdec_vp9_slice_tiles *tiles;
+	unsigned char *pos;
+	unsigned char *end;
+	unsigned char *va;
+	unsigned int *tb;
+	int i;
+	int j;
+
+	uh = &vsi->frame.uh;
+	rows_log2 = uh->tile_rows_log2;
+	cols_log2 = uh->tile_cols_log2;
+	rows = 1 << rows_log2;
+	cols = 1 << cols_log2;
+
+	if (rows > 4 || cols > 64) {
+		mtk_vcodec_err(instance, "tile_rows %u tile_cols %u\n",
+			rows, cols);
+		return -EINVAL;
+	}
+
+	offset = uh->uncompressed_header_size +
+		uh->header_size_in_bytes;
+	if (bs->size <= offset) {
+		mtk_vcodec_err(instance, "bs size %zu tile offset %u\n",
+			bs->size, offset);
+		return -EINVAL;
+	}
+
+	tiles = &vsi->frame.tiles;
+	/* setup tile buffer */
+
+	va = (unsigned char *)bs->va;
+	pos = va + offset;
+	end = va + bs->size;
+	/* truncated */
+	pa = (unsigned int)bs->dma_addr + offset;
+	tb = instance->tile.va;
+	for (i = 0; i < rows; i++) {
+		for (j = 0; j < cols; j++) {
+			if (i == rows - 1 &&
+				j == cols - 1) {
+				size = (unsigned int)(end - pos);
+			} else {
+				if (end - pos < 4) {
+					mtk_vcodec_err(instance,
+						"tile %px %px\n", end, pos);
+					return -EINVAL;
+				}
+				size = (pos[0] << 24) | (pos[1] << 16) |
+					(pos[2] << 8) | pos[3];
+				pos += 4;
+				pa += 4;
+				offset += 4;
+				if (end - pos < size) {
+					mtk_vcodec_err(instance,
+						"tile %px %px %u\n",
+						end, pos, size);
+					return -EINVAL;
+				}
+			}
+			tiles->size[i][j] = size;
+			if (tiles->mi_rows[i]) {
+				*tb++ = (size << 3) + ((offset << 3) & 0x7f);
+				*tb++ = pa &~0xf;
+				*tb++ = (pa << 3) & 0x7f;
+				mi_row = (tiles->mi_rows[i] - 1) & 0x1ff;
+				mi_col = (tiles->mi_cols[j] - 1) & 0x3f;
+				*tb++ = (mi_row << 6) + mi_col;
+			}
+			pos += size;
+			pa += size;
+			offset += size;
+		}
+	}
+
+	return 0;
+}
+
+static int vdec_vp9_slice_setup_lat(
+	struct vdec_vp9_slice_instance *instance,
+	struct mtk_vcodec_mem *bs,
+	struct vdec_lat_buf *lat_buf,
+	struct vdec_vp9_slice_pfc *pfc)
+{
+	struct vdec_vp9_slice_vsi *vsi = &pfc->vsi;
+	int ret;
+
+	ret = vdec_vp9_slice_setup_lat_from_src_buf(instance, lat_buf);
+	if (ret)
+		goto err;
+
+	ret = vdec_vp9_slice_setup_pfc(instance, pfc);
+	if (ret)
+		goto err;
+
+	ret = vdec_vp9_slice_alloc_working_buffer(instance, vsi);
+	if (ret)
+		goto err;
+
+	ret = vdec_vp9_slice_setup_lat_buffer(instance, vsi, bs, lat_buf);
+	if (ret)
+		goto err;
+
+	vdec_vp9_slice_setup_seg_buffer(instance, vsi, &instance->seg[0]);
+
+	/* setup prob/tile buffers for LAT */
+
+	ret = vdec_vp9_slice_setup_prob_buffer(instance, vsi);
+	if (ret)
+		goto err;
+
+	ret = vdec_vp9_slice_setup_tile_buffer(instance, vsi, bs);
+	if (ret)
+		goto err;
+
+	return 0;
+
+err:
+	return ret;
+}
+
+/* implement merge prob process defined in 8.4.1 */
+static unsigned char vdec_vp9_slice_merge_prob(unsigned char pre,
+	unsigned int ct0,
+	unsigned int ct1,
+	unsigned int cs,
+	unsigned int uf)
+{
+	unsigned int den;
+	unsigned int prob;
+	unsigned int count;
+	unsigned int factor;
+
+	/*
+	 * The variable den representing the total times
+	 * this boolean has been decoded is set equal to ct0 + ct1.
+	 */
+	den = ct0 + ct1;
+	if (!den)
+		return pre;  /* => count = 0 => factor = 0 */
+	/*
+	 * The variable prob estimating the probability that
+	 * the boolean is decoded as a 0 is set equal to
+	 * (den == 0) ? 128 : Clip3(1, 255, (ct0 * 256 + (den >> 1)) / den).
+	 */
+	prob = ((ct0 << 8) + (den >> 1)) / den;
+	prob = prob < 1 ? 1 : (prob > 255 ? 255 : prob);
+	/* The variable count is set equal to Min(ct0 + ct1, countSat) */
+	count = den < cs ? den : cs;
+	/*
+	 * The variable factor is set equal to
+	 * maxUpdateFactor * count / countSat.
+	 */
+	factor = uf * count / cs;
+	/*
+	 * The return variable outProb is set equal to
+	 * Round2(preProb * (256 - factor) + prob * factor, 8).
+	 */
+	return pre + (((prob - pre) * factor + 128) >> 8);
+}
+
+static inline unsigned char vdec_vp9_slice_adapt_prob(
+	unsigned char pre,
+	unsigned int ct0,
+	unsigned int ct1)
+{
+	return vdec_vp9_slice_merge_prob(pre, ct0, ct1, 20, 128);
+}
+
+/* implement merge probs process defined in 8.4.2 */
+static unsigned int vdec_vp9_slice_merge_probs(
+	const signed char *tree,
+	int location,
+	unsigned char *pre_probs,
+	unsigned int *counts,
+	unsigned char *probs,
+	unsigned int cs,
+	unsigned int uf)
+{
+	int left = tree[location];
+	int right = tree[location + 1];
+	unsigned int left_count;
+	unsigned int right_count;
+
+	if (left <= 0)
+		left_count = counts[-left];
+	else
+		left_count = vdec_vp9_slice_merge_probs(tree, left,
+			pre_probs, counts, probs, cs, uf);
+
+	if (right <= 0)
+		right_count = counts[-right];
+	else
+		right_count = vdec_vp9_slice_merge_probs(tree, right,
+			pre_probs, counts, probs, cs, uf);
+
+	/* merge left and right */
+	probs[location >> 1] =
+		vdec_vp9_slice_merge_prob(pre_probs[location >> 1],
+			left_count, right_count, cs, uf);
+	return left_count + right_count;
+}
+
+static inline void vdec_vp9_slice_adapt_probs(
+	const signed char *tree,
+	unsigned char *pre_probs,
+	unsigned int *counts,
+	unsigned char *probs)
+{
+	vdec_vp9_slice_merge_probs(tree, 0, pre_probs, counts, probs, 20, 128);
+}
+
+/* 8.4 Probability adaptation process */
+static void vdec_vp9_slice_adapt_table(
+	struct vdec_vp9_slice_vsi *vsi,
+	struct vdec_vp9_slice_frame_ctx *ctx,
+	struct vdec_vp9_slice_frame_ctx *pre_ctx,
+	struct vdec_vp9_slice_frame_counts *counts)
+{
+	unsigned char *pp;
+	unsigned char *p;
+	unsigned int *c;
+	unsigned int *e;
+	unsigned int uf;
+	int t, i, j, k, l;
+
+	uf = 128;
+	if (!vsi->frame.uh.frame_type || vsi->frame.uh.intra_only ||
+		vsi->frame.uh.last_frame_type)
+		uf = 112;
+
+	p = (unsigned char *)&ctx->coef_probs;
+	pp = (unsigned char *)&pre_ctx->coef_probs;
+	c = (unsigned int *)&counts->coef_probs;
+	e = (unsigned int *)&counts->eob_branch;
+
+	/* 8.4.3 Coefficient probability adaption process */
+	FOR_EACH_COEF_PROBS_BAND(t, i, j, k) {
+		for (l = 0; l < (k == 0 ? 3 : 6); l++) {
+			p[0] = vdec_vp9_slice_merge_prob(pp[0],
+				c[3], e[0] - c[3], 24, uf);
+			p[1] = vdec_vp9_slice_merge_prob(pp[1],
+				c[0], c[1] + c[2], 24, uf);
+			p[2] = vdec_vp9_slice_merge_prob(pp[2],
+				c[1], c[2], 24, uf);
+			p += 3;
+			pp += 3;
+			c += 4;
+			e++;
+		}
+		if (k == 0) {
+			/* 3*3 unused values and 2 bytes padding */
+			p += 11;
+			pp += 11;
+			e++;
+		} else {
+			/* extra 2 bytes could make 4 bytes align (3*6+2) */
+			p += 2;
+			pp += 2;
+			/* 5*6=30, extra 2 int */
+			if (k == 5)
+				e += 2;
+		}
+	}
+
+	if (!vsi->frame.uh.frame_type || vsi->frame.uh.intra_only)
+		return;
+
+	/* 8.4.4 Non coefficient probability adaption process */
+
+	for (i = 0; i < 4; i++) {
+		ctx->intra_inter_prob[i] = vdec_vp9_slice_adapt_prob(
+			pre_ctx->intra_inter_prob[i],
+			counts->intra_inter[i][0],
+			counts->intra_inter[i][1]);
+	}
+
+	for (i = 0; i < 5; i++) {
+		ctx->comp_inter_prob[i] = vdec_vp9_slice_adapt_prob(
+			pre_ctx->comp_inter_prob[i],
+			counts->comp_inter[i][0],
+			counts->comp_inter[i][1]);
+	}
+
+	for (i = 0; i < 5; i++) {
+		ctx->comp_ref_prob[i] = vdec_vp9_slice_adapt_prob(
+			pre_ctx->comp_ref_prob[i],
+			counts->comp_ref[i][0],
+			counts->comp_ref[i][1]);
+	}
+
+	for (i = 0; i < 5; i++) {
+		for (j = 0; j < 2; j++) {
+			ctx->single_ref_prob[i][j] =
+				vdec_vp9_slice_adapt_prob(
+					pre_ctx->single_ref_prob[i][j],
+					counts->single_ref[i][j][0],
+					counts->single_ref[i][j][1]);
+		}
+	}
+
+	for (i = 0; i < 7; i++) {
+		vdec_vp9_slice_adapt_probs(vdec_vp9_slice_inter_mode_tree,
+			&pre_ctx->inter_mode_probs[i][0],
+			&counts->inter_mode[i][0],
+			&ctx->inter_mode_probs[i][0]);
+	}
+
+	for (i = 0; i < 4; i++) {
+		vdec_vp9_slice_adapt_probs(vdec_vp9_slice_intra_mode_tree,
+			&pre_ctx->y_mode_prob[i][0],
+			&counts->y_mode[i][0],
+			&ctx->y_mode_prob[i][0]);
+	}
+
+	for (i = 0; i < 10; i++) {
+		vdec_vp9_slice_adapt_probs(vdec_vp9_slice_intra_mode_tree,
+			&pre_ctx->uv_mode_prob[i][0],
+			&counts->uv_mode[i][0],
+			&ctx->uv_mode_prob[i][0]);
+	}
+
+	for (i = 0; i < 16; i++) {
+		vdec_vp9_slice_adapt_probs(vdec_vp9_slice_partition_tree,
+			&pre_ctx->partition_prob[i][0],
+			&counts->partition[i][0],
+			&ctx->partition_prob[i][0]);
+	}
+
+	if (vsi->frame.uh.interpolation_filter == 4) {
+		for (i = 0; i < 4; i++) {
+			vdec_vp9_slice_adapt_probs(
+				vdec_vp9_slice_switchable_interp_tree,
+				&pre_ctx->switch_interp_prob[i][0],
+				&counts->switchable_interp[i][0],
+				&ctx->switch_interp_prob[i][0]);
+		}
+	}
+
+	if (vsi->frame.ch.tx_mode == 4) {
+		for (i = 0; i < 2; i++) {
+			ctx->tx_p8x8[i][0] = vdec_vp9_slice_adapt_prob(
+				pre_ctx->tx_p8x8[i][0],
+				counts->tx_p8x8[i][0],
+				counts->tx_p8x8[i][1]);
+			ctx->tx_p16x16[i][0] = vdec_vp9_slice_adapt_prob(
+				pre_ctx->tx_p16x16[i][0],
+				counts->tx_p16x16[i][0],
+				counts->tx_p16x16[i][1] +
+				counts->tx_p16x16[i][2]);
+			ctx->tx_p16x16[i][1] = vdec_vp9_slice_adapt_prob(
+				pre_ctx->tx_p16x16[i][1],
+				counts->tx_p16x16[i][1],
+				counts->tx_p16x16[i][2]);
+			ctx->tx_p32x32[i][0] = vdec_vp9_slice_adapt_prob(
+				pre_ctx->tx_p32x32[i][0],
+				counts->tx_p32x32[i][0],
+				counts->tx_p32x32[i][1] +
+				counts->tx_p32x32[i][2] +
+				counts->tx_p32x32[i][3]);
+			ctx->tx_p32x32[i][1] = vdec_vp9_slice_adapt_prob(
+				pre_ctx->tx_p32x32[i][1],
+				counts->tx_p32x32[i][1],
+				counts->tx_p32x32[i][2] +
+				counts->tx_p32x32[i][3]);
+			ctx->tx_p32x32[i][2] = vdec_vp9_slice_adapt_prob(
+				pre_ctx->tx_p32x32[i][2],
+				counts->tx_p32x32[i][2],
+				counts->tx_p32x32[i][3]);
+		}
+	}
+
+	for (i = 0; i < 3; i++) {
+		ctx->skip_probs[i] = vdec_vp9_slice_adapt_prob(
+			pre_ctx->skip_probs[i],
+			counts->skip[i][0],
+			counts->skip[i][1]);
+	}
+
+	vdec_vp9_slice_adapt_probs(vdec_vp9_slice_mv_joint_tree,
+		&pre_ctx->joint[0],
+		&counts->joint[0],
+		&ctx->joint[0]);
+
+	for (i = 0; i < 2; i++) {
+		ctx->sign_classes[i].sign = vdec_vp9_slice_adapt_prob(
+			pre_ctx->sign_classes[i].sign,
+			counts->mvcomp[i].sign[0],
+			counts->mvcomp[i].sign[1]);
+		vdec_vp9_slice_adapt_probs(vdec_vp9_slice_mv_class_tree,
+			&pre_ctx->sign_classes[i].classes[0],
+			&counts->mvcomp[i].classes[0],
+			&ctx->sign_classes[i].classes[0]);
+
+		vdec_vp9_slice_adapt_probs(vdec_vp9_slice_mv_class0_tree,
+			pre_ctx->class0_bits[i].class0,
+			counts->mvcomp[i].class0,
+			ctx->class0_bits[i].class0);
+		for (j = 0; j < 10; j++) {
+			ctx->class0_bits[i].bits[j] =
+				vdec_vp9_slice_adapt_prob(
+					pre_ctx->class0_bits[i].bits[j],
+					counts->mvcomp[i].bits[j][0],
+					counts->mvcomp[i].bits[j][1]);
+		}
+
+		for (j = 0; j < 2; ++j) {
+			vdec_vp9_slice_adapt_probs(vdec_vp9_slice_mv_fp_tree,
+				pre_ctx->class0_fp_hp[i].class0_fp[j],
+				counts->mvcomp[i].class0_fp[j],
+				ctx->class0_fp_hp[i].class0_fp[j]);
+		}
+		vdec_vp9_slice_adapt_probs(vdec_vp9_slice_mv_fp_tree,
+			pre_ctx->class0_fp_hp[i].fp,
+			counts->mvcomp[i].fp,
+			ctx->class0_fp_hp[i].fp);
+		if (vsi->frame.uh.allow_high_precision_mv) {
+			ctx->class0_fp_hp[i].class0_hp =
+				vdec_vp9_slice_adapt_prob(
+					pre_ctx->class0_fp_hp[i].class0_hp,
+					counts->mvcomp[i].class0_hp[0],
+					counts->mvcomp[i].class0_hp[1]);
+			ctx->class0_fp_hp[i].hp =
+				vdec_vp9_slice_adapt_prob(
+					pre_ctx->class0_fp_hp[i].hp,
+					counts->mvcomp[i].hp[0],
+					counts->mvcomp[i].hp[1]);
+		}
+	}
+}
+
+static int vdec_vp9_slice_update_prob(
+	struct vdec_vp9_slice_instance *instance,
+	struct vdec_vp9_slice_vsi *vsi)
+{
+	struct vdec_vp9_slice_frame_ctx *pre_frame_ctx;
+	struct vdec_vp9_slice_frame_ctx *frame_ctx;
+	struct vdec_vp9_slice_frame_counts *counts;
+	struct vdec_vp9_slice_uncompressed_header *uh;
+
+	uh = &vsi->frame.uh;
+	pre_frame_ctx = &instance->frame_ctx[uh->frame_context_idx];
+	frame_ctx = (struct vdec_vp9_slice_frame_ctx *)instance->prob.va;
+	counts = (struct vdec_vp9_slice_frame_counts *)instance->counts.va;
+
+	if (!uh->refresh_frame_context)
+		return 0;
+
+	if (!uh->frame_parallel_decoding_mode) {
+		/* uh->error_resilient_mode must be 0 */
+		vdec_vp9_slice_adapt_table(vsi,
+			frame_ctx,
+			/* use default frame ctx? */
+			instance->dirty[uh->frame_context_idx] ?
+				pre_frame_ctx :
+				vdec_vp9_slice_default_frame_ctx,
+			counts);
+	}
+
+	memcpy(pre_frame_ctx, frame_ctx, sizeof(*frame_ctx));
+	instance->dirty[uh->frame_context_idx] = 1;
+
+	return 0;
+}
+
+static int vdec_vp9_slice_update_lat(
+	struct vdec_vp9_slice_instance *instance,
+	struct vdec_lat_buf *lat_buf,
+	struct vdec_vp9_slice_pfc *pfc)
+{
+	struct vdec_vp9_slice_vsi *vsi;
+
+	vsi = &pfc->vsi;
+	memcpy(&pfc->state[0], &vsi->state, sizeof(vsi->state));
+
+	mtk_vcodec_debug(instance,
+		"Frame %u LAT CRC 0x%08x\n", pfc->seq, vsi->state.crc[0]);
+
+	/* buffer full, need to re-decode */
+	if (vsi->state.full) {
+		/* buffer not enough */
+		if (vsi->trans.dma_addr_end - vsi->trans.dma_addr ==
+			vsi->ube.size)
+			return -ENOMEM;
+		return -EAGAIN;
+	}
+
+	vdec_vp9_slice_update_prob(instance, vsi);
+
+	instance->width = vsi->frame.uh.frame_width;
+	instance->height = vsi->frame.uh.frame_height;
+	instance->frame_type = vsi->frame.uh.frame_type;
+	instance->show_frame = vsi->frame.uh.show_frame;
+
+	return 0;
+}
+
+static int vdec_vp9_slice_setup_core_to_dst_buf(
+	struct vdec_vp9_slice_instance *instance,
+	struct vdec_lat_buf *lat_buf)
+{
+	struct vb2_v4l2_buffer *src;
+	struct vb2_v4l2_buffer *dst;
+
+	dst = v4l2_m2m_next_dst_buf(instance->ctx->m2m_ctx);
+	if (!dst)
+		return -EINVAL;
+
+	src = &lat_buf->ts_info;
+	dst->vb2_buf.timestamp = src->vb2_buf.timestamp;
+	dst->timecode = src->timecode;
+	dst->field = src->field;
+	dst->flags = src->flags;
+	dst->vb2_buf.copied_timestamp = src->vb2_buf.copied_timestamp;
+	return 0;
+}
+
+static int vdec_vp9_slice_setup_core_buffer(
+	struct vdec_vp9_slice_instance *instance,
+	struct vdec_vp9_slice_pfc *pfc,
+	struct vdec_vp9_slice_vsi *vsi,
+	struct vdec_fb *fb,
+	struct vdec_lat_buf *lat_buf)
+{
+	struct vb2_buffer *vb;
+	struct vb2_queue *vq;
+	struct vdec_vp9_slice_reference *ref;
+	int plane;
+	int size;
+	int idx;
+	int w;
+	int h;
+	int i;
+
+	plane = instance->ctx->q_data[MTK_Q_DATA_DST].fmt->num_planes;
+	w = vsi->frame.uh.frame_width;
+	h = vsi->frame.uh.frame_height;
+	size = ALIGN(w, 64) * ALIGN(h, 64);
+
+	/* frame buffer */
+	vsi->fb.y.dma_addr = fb->base_y.dma_addr;
+	if (plane == 1)
+		vsi->fb.c.dma_addr = fb->base_y.dma_addr + size;
+	else
+		vsi->fb.c.dma_addr = fb->base_c.dma_addr;
+
+	/* reference buffers */
+	vq = v4l2_m2m_get_vq(instance->ctx->m2m_ctx,
+		V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE);
+	if (!vq)
+		return -EINVAL;
+
+	/* get current output buffer */
+	vb = &v4l2_m2m_next_dst_buf(instance->ctx->m2m_ctx)->vb2_buf;
+	if (!vb)
+		return -EINVAL;
+
+	/* update internal buffer's width/height */
+	for (i = 0; i < vq->num_buffers; i++) {
+		if (vb == vq->bufs[i]) {
+			instance->dpb[i].width = w;
+			instance->dpb[i].height = h;
+			break;
+		}
+	}
+
+	/*
+	 * get buffer's width/height from instance
+	 * get buffer address from vb2buf
+	 */
+	for (i = 0; i < 3; i++) {
+		ref = &vsi->frame.ref[i];
+		idx = vb2_find_timestamp(vq, pfc->ref_idx[i], 0);
+		if (idx < 0) {
+			ref->frame_width = w;
+			ref->frame_height = h;
+			memset(&vsi->ref[i], 0, sizeof(vsi->ref[i]));
+		} else {
+			ref->frame_width = instance->dpb[idx].width;
+			ref->frame_height = instance->dpb[idx].height;
+			vb = vq->bufs[idx];
+			vsi->ref[i].y.dma_addr =
+				vb2_dma_contig_plane_dma_addr(vb, 0);
+			if (plane == 1)
+				vsi->ref[i].c.dma_addr =
+					vsi->ref[i].y.dma_addr + size;
+			else
+				vsi->ref[i].c.dma_addr =
+					vb2_dma_contig_plane_dma_addr(vb, 1);
+		}
+	}
+
+	return 0;
+}
+
+static int vdec_vp9_slice_setup_core(
+	struct vdec_vp9_slice_instance *instance,
+	struct vdec_fb *fb,
+	struct vdec_lat_buf *lat_buf,
+	struct vdec_vp9_slice_pfc *pfc)
+{
+	struct vdec_vp9_slice_vsi *vsi = &pfc->vsi;
+	int ret;
+
+	vdec_vp9_slice_setup_state(vsi);
+
+	ret = vdec_vp9_slice_setup_core_to_dst_buf(instance, lat_buf);
+	if (ret)
+		goto err;
+
+	ret = vdec_vp9_slice_setup_core_buffer(instance, pfc, vsi,
+		fb, lat_buf);
+	if (ret)
+		goto err;
+
+	vdec_vp9_slice_setup_seg_buffer(instance, vsi, &instance->seg[1]);
+
+	return 0;
+
+err:
+	return ret;
+}
+
+static int vdec_vp9_slice_update_core(
+	struct vdec_vp9_slice_instance *instance,
+	struct vdec_lat_buf *lat_buf,
+	struct vdec_vp9_slice_pfc *pfc)
+{
+	struct vdec_vp9_slice_vsi *vsi;
+
+	vsi = &pfc->vsi;
+	memcpy(&pfc->state[1], &vsi->state, sizeof(vsi->state));
+
+	mtk_vcodec_debug(instance, "Frame %u Y_CRC %08x %08x %08x %08x\n",
+		pfc->seq,
+		vsi->state.crc[0], vsi->state.crc[1],
+		vsi->state.crc[2], vsi->state.crc[3]);
+	mtk_vcodec_debug(instance, "Frame %u C_CRC %08x %08x %08x %08x\n",
+		pfc->seq,
+		vsi->state.crc[4], vsi->state.crc[5],
+		vsi->state.crc[6], vsi->state.crc[7]);
+
+	return 0;
+}
+
+static int vdec_vp9_slice_init(struct mtk_vcodec_ctx *ctx)
+{
+	struct vdec_vp9_slice_instance *instance;
+	struct vdec_vp9_slice_init_vsi *vsi;
+	int ret;
+
+	instance = kzalloc(sizeof(*instance), GFP_KERNEL);
+	if (!instance)
+		return -ENOMEM;
+
+	instance->ctx = ctx;
+	instance->vpu.id = SCP_IPI_VDEC_LAT;
+	instance->vpu.core_id = SCP_IPI_VDEC_CORE;
+	instance->vpu.ctx = ctx;
+	instance->vpu.codec_type = ctx->current_codec;
+
+	ret = vpu_dec_init(&instance->vpu);
+	if (ret) {
+		mtk_vcodec_err(instance, "failed to init vpu dec, ret %d\n",
+			ret);
+		goto error_vpu_init;
+	}
+
+	/* init vsi and global flags */
+
+	vsi = instance->vpu.vsi;
+	if (!vsi) {
+		mtk_vcodec_err(instance, "failed to get VP9 vsi\n");
+		ret = -EINVAL;
+		goto error_vsi;
+	}
+	instance->init_vsi = vsi;
+	instance->core_vsi = mtk_vcodec_fw_map_dm_addr(ctx->dev->fw_handler,
+		(u32)vsi->core_vsi);
+	if (!instance->core_vsi) {
+		mtk_vcodec_err(instance, "failed to get VP9 core vsi\n");
+		ret = -EINVAL;
+		goto error_vsi;
+	}
+
+	instance->irq = 1;
+
+	mtk_vcodec_debug(instance, "vsi 0x%px core_vsi 0x%llx 0x%px\n",
+		vsi, vsi->core_vsi, instance->core_vsi);
+
+	ret = vdec_vp9_slice_init_default_frame_ctx(instance);
+	if (ret)
+		goto error_default_frame_ctx;
+
+	ctx->drv_handle = instance;
+	instance->irq = !ctx->dev->vdec_inter_in_scp;
+
+	return 0;
+
+error_default_frame_ctx:
+error_vsi:
+	vpu_dec_deinit(&instance->vpu);
+error_vpu_init:
+	kfree(instance);
+	return ret;
+}
+
+static void vdec_vp9_slice_deinit(void *h_vdec)
+{
+	struct vdec_vp9_slice_instance *instance = h_vdec;
+
+	if (!instance)
+		return;
+
+	mtk_vcodec_debug(instance, "h_vdec 0x%px\n", h_vdec);
+
+	vpu_dec_deinit(&instance->vpu);
+	vdec_vp9_slice_free_working_buffer(instance);
+	vdec_msg_queue_deinit(instance->ctx, &instance->ctx->msg_queue);
+	kfree(instance);
+}
+
+static int vdec_vp9_slice_flush(void *h_vdec, struct mtk_vcodec_mem *bs,
+	struct vdec_fb *fb, bool *res_chg)
+{
+	struct vdec_vp9_slice_instance *instance = h_vdec;
+
+	mtk_vcodec_debug(instance, "flush ...\n");
+
+	vdec_msg_queue_wait_lat_buf_full(&instance->ctx->msg_queue);
+	return vpu_dec_reset(&instance->vpu);
+}
+
+static void vdec_vp9_slice_get_pic_info(
+	struct vdec_vp9_slice_instance *instance)
+{
+	struct mtk_vcodec_ctx *ctx = instance->ctx;
+	unsigned int data[3];
+
+	mtk_vcodec_debug(instance, "w %u h %u\n",
+		ctx->picinfo.pic_w, ctx->picinfo.pic_h);
+
+	data[0] = ctx->picinfo.pic_w;
+	data[1] = ctx->picinfo.pic_h;
+	data[2] = ctx->capture_fourcc;
+	vpu_dec_get_param(&instance->vpu, data, 3, GET_PARAM_PIC_INFO);
+
+	ctx->picinfo.buf_w = ALIGN(ctx->picinfo.pic_w, 64);
+	ctx->picinfo.buf_h = ALIGN(ctx->picinfo.pic_h, 64);
+	ctx->picinfo.fb_sz[0] = instance->vpu.fb_sz[0];
+	ctx->picinfo.fb_sz[1] = instance->vpu.fb_sz[1];
+}
+
+static void vdec_vp9_slice_get_dpb_size(
+	struct vdec_vp9_slice_instance *instance,
+	unsigned int *dpb_sz)
+{
+	/* refer VP9 specification */
+	*dpb_sz = 9;
+}
+
+static void vdec_vp9_slice_get_crop_info(
+	struct vdec_vp9_slice_instance *instance,
+	struct v4l2_rect *cr)
+{
+	struct mtk_vcodec_ctx *ctx = instance->ctx;
+
+	cr->left = 0;
+	cr->top = 0;
+	cr->width = ctx->picinfo.pic_w;
+	cr->height = ctx->picinfo.pic_h;
+
+	mtk_vcodec_debug(instance, "l=%d, t=%d, w=%d, h=%d\n",
+		cr->left, cr->top, cr->width, cr->height);
+}
+
+static int vdec_vp9_slice_get_param(void *h_vdec,
+	enum vdec_get_param_type type, void *out)
+{
+	struct vdec_vp9_slice_instance *instance = h_vdec;
+
+	switch (type) {
+	case GET_PARAM_PIC_INFO:
+		vdec_vp9_slice_get_pic_info(instance);
+		break;
+	case GET_PARAM_DPB_SIZE:
+		vdec_vp9_slice_get_dpb_size(instance, out);
+		break;
+	case GET_PARAM_CROP_INFO:
+		vdec_vp9_slice_get_crop_info(instance, out);
+		break;
+	default:
+		mtk_vcodec_err(instance, "invalid get parameter type=%d\n",
+			type);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int vdec_vp9_slice_lat_decode(void *h_vdec,
+	struct mtk_vcodec_mem *bs,
+	struct vdec_fb *fb,
+	bool *res_chg)
+{
+	struct vdec_vp9_slice_instance *instance = h_vdec;
+	struct vdec_lat_buf *lat_buf;
+	struct vdec_vp9_slice_pfc *pfc;
+	struct vdec_vp9_slice_vsi *vsi;
+	struct mtk_vcodec_ctx *ctx;
+	int ret;
+
+	if (!instance || !instance->ctx)
+		return -EINVAL;
+	ctx = instance->ctx;
+
+	/* init msgQ for the first time */
+	if (!ctx->msg_queue.init_done) {
+		if (vdec_msg_queue_init(ctx, &ctx->msg_queue,
+			vdec_vp9_slice_core_decode, sizeof(*pfc))) {
+			mtk_vcodec_err(instance,
+				"Failed to init VP9 msg queue\n");
+			return -ENOMEM;
+		}
+	}
+
+	/* bs NULL means flush decoder */
+	if (!bs)
+		return vdec_vp9_slice_flush(h_vdec, bs, fb, res_chg);
+
+	lat_buf = vdec_msg_queue_get_lat_buf(&ctx->msg_queue);
+	if (!lat_buf) {
+		mtk_vcodec_err(instance, "Failed to get VP9 lat buf\n");
+		return -EBUSY;
+	}
+	pfc = (struct vdec_vp9_slice_pfc *)lat_buf->private_data;
+	if (!pfc)
+		return -EINVAL;
+	vsi = &pfc->vsi;
+
+	ret = vdec_vp9_slice_setup_lat(instance, bs, lat_buf, pfc);
+	if (ret) {
+		mtk_vcodec_err(instance,
+			"Failed to setup VP9 lat ret %d\n", ret);
+		return ret;
+	}
+	vdec_vp9_slice_vsi_to_remote(vsi, instance->vsi);
+
+	ret = vpu_dec_start(&instance->vpu, 0, 0);
+	if (ret) {
+		mtk_vcodec_err(instance,
+			"Failed to dec VP9 ret %d\n", ret);
+		return ret;
+	}
+
+	if (instance->irq) {
+		ret = mtk_vcodec_wait_for_comp_done_ctx(ctx,
+			MTK_INST_IRQ_RECEIVED,
+			WAIT_INTR_TIMEOUT_MS, MTK_VDEC_LAT0);
+		/* update remote vsi if decode timeout */
+		if (ret) {
+			mtk_vcodec_err(instance,
+				"VP9 decode timeout %d\n", ret);
+			writel(1, &instance->vsi->state.timeout);
+		}
+		vpu_dec_end(&instance->vpu);
+	}
+
+	vdec_vp9_slice_vsi_from_remote(vsi, instance->vsi, 0);
+	ret = vdec_vp9_slice_update_lat(instance, lat_buf, pfc);
+
+	/* LAT trans full, re-decode */
+	if (ret == -EAGAIN) {
+		mtk_vcodec_err(instance, "VP9 trans full\n");
+		vdec_msg_queue_buf_to_lat(lat_buf);
+		return 0;
+	}
+
+	/*
+	 * LAT trans full, no more UBE
+	 * decode timeout
+	 */
+	if (ret == -ENOMEM || vsi->state.timeout) {
+		mtk_vcodec_err(instance,
+			"VP9 insufficient buffer or timeout\n");
+		vdec_msg_queue_buf_to_lat(lat_buf);
+		return -EBUSY;
+	}
+
+	mtk_vcodec_debug(instance, "lat dma 1 0x%lx 0x%lx\n",
+		pfc->vsi.trans.dma_addr, pfc->vsi.trans.dma_addr_end);
+
+	vdec_msg_queue_update_ube_wptr(&ctx->msg_queue,
+		vsi->trans.dma_addr_end  + ctx->msg_queue.wdma_addr.dma_addr);
+	vdec_msg_queue_buf_to_core(ctx->dev, lat_buf);
+
+	return 0;
+}
+
+static int vdec_vp9_slice_core_decode(
+	struct vdec_lat_buf *lat_buf)
+{
+	struct vdec_vp9_slice_instance *instance;
+	struct vdec_vp9_slice_pfc *pfc;
+	struct mtk_vcodec_ctx *ctx = NULL;
+	struct vdec_fb *fb = NULL;
+	int ret = -EINVAL;
+
+	if (!lat_buf)
+		goto err;
+
+	pfc = lat_buf->private_data;
+	ctx = lat_buf->ctx;
+	if (!pfc || !ctx)
+		goto err;
+
+	instance = ctx->drv_handle;
+	if (!instance)
+		goto err;
+
+	fb = ctx->dev->vdec_pdata->get_cap_buffer(ctx);
+	if (!fb) {
+		ret = -EBUSY;
+		goto err;
+	}
+
+	ret = vdec_vp9_slice_setup_core(instance, fb, lat_buf, pfc);
+	if (ret) {
+		mtk_vcodec_err(instance, "vdec_vp9_slice_setup_core\n");
+		goto err;
+	}
+	vdec_vp9_slice_vsi_to_remote(&pfc->vsi, instance->core_vsi);
+
+	ret = vpu_dec_core(&instance->vpu);
+	if (ret) {
+		mtk_vcodec_err(instance, "vpu_dec_core\n");
+		goto err;
+	}
+
+	if (instance->irq) {
+		ret = mtk_vcodec_wait_for_comp_done_ctx(ctx,
+			MTK_INST_IRQ_RECEIVED,
+			WAIT_INTR_TIMEOUT_MS, MTK_VDEC_CORE);
+		/* update remote vsi if decode timeout */
+		if (ret) {
+			mtk_vcodec_err(instance, "VP9 core timeout\n");
+			writel(1, &instance->core_vsi->state.timeout);
+		}
+		vpu_dec_core_end(&instance->vpu);
+	}
+
+	vdec_vp9_slice_vsi_from_remote(&pfc->vsi, instance->core_vsi, 1);
+	ret = vdec_vp9_slice_update_core(instance, lat_buf, pfc);
+	if (ret) {
+		mtk_vcodec_err(instance, "vdec_vp9_slice_update_core\n");
+		goto err;
+	}
+
+	pfc->vsi.trans.dma_addr_end += ctx->msg_queue.wdma_addr.dma_addr;
+	mtk_vcodec_debug(instance, "core dma_addr_end 0x%lx\n",
+		pfc->vsi.trans.dma_addr_end);
+	vdec_msg_queue_update_ube_rptr(&ctx->msg_queue,
+		pfc->vsi.trans.dma_addr_end);
+	ctx->dev->vdec_pdata->cap_to_disp(ctx, fb, 0);
+
+	return 0;
+
+err:
+	if (ctx) {
+		/* always update read pointer */
+		vdec_msg_queue_update_ube_rptr(&ctx->msg_queue,
+			pfc->vsi.trans.dma_addr_end);
+
+		if (fb)
+			ctx->dev->vdec_pdata->cap_to_disp(ctx, fb, 1);
+	}
+	return ret;
+}
+
+const struct vdec_common_if vdec_vp9_slice_lat_if = {
+	.init		= vdec_vp9_slice_init,
+	.decode		= vdec_vp9_slice_lat_decode,
+	.get_param	= vdec_vp9_slice_get_param,
+	.deinit		= vdec_vp9_slice_deinit,
+};
diff --git a/drivers/media/platform/mtk-vcodec/vdec_drv_if.c b/drivers/media/platform/mtk-vcodec/vdec_drv_if.c
index 42008243ceac1cab8fa3c9676fb5a7c7a2049f81..2d3a45781359dc74ed70daf6a3e8a0d256c4b7e6 100644
--- a/drivers/media/platform/mtk-vcodec/vdec_drv_if.c
+++ b/drivers/media/platform/mtk-vcodec/vdec_drv_if.c
@@ -20,26 +20,41 @@ int vdec_if_init(struct mtk_vcodec_ctx *ctx, unsigned int fourcc)
 
 	switch (fourcc) {
 	case V4L2_PIX_FMT_H264_SLICE:
-		ctx->dec_if = &vdec_h264_slice_if;
+		if (ctx->dev->vdec_pdata->hw_arch == MTK_VDEC_PURE_SINGLE_CORE) {
+			ctx->dec_if = &vdec_h264_slice_if;
+			ctx->hw_id = MTK_VDEC_CORE;
+		} else {
+			ctx->dec_if = &vdec_h264_slice_lat_if;
+			ctx->hw_id = MTK_VDEC_LAT0;
+		}
 		break;
 	case V4L2_PIX_FMT_H264:
 		ctx->dec_if = &vdec_h264_if;
+		ctx->hw_id = MTK_VDEC_CORE;
+		break;
+	case V4L2_PIX_FMT_VP8_FRAME:
+		ctx->dec_if = &vdec_vp8_slice_if;
+		ctx->hw_id = MTK_VDEC_CORE;
 		break;
 	case V4L2_PIX_FMT_VP8:
 		ctx->dec_if = &vdec_vp8_if;
+		ctx->hw_id = MTK_VDEC_CORE;
 		break;
 	case V4L2_PIX_FMT_VP9:
 		ctx->dec_if = &vdec_vp9_if;
+		ctx->hw_id = MTK_VDEC_CORE;
+		break;
+	case V4L2_PIX_FMT_VP9_FRAME:
+		ctx->dec_if = &vdec_vp9_slice_lat_if;
+		ctx->hw_id = MTK_VDEC_LAT0;
 		break;
 	default:
 		return -EINVAL;
 	}
 
-	mtk_vdec_lock(ctx);
-	mtk_vcodec_dec_clock_on(&ctx->dev->pm);
+	mtk_vcodec_dec_enable_hardware(ctx, ctx->hw_id);
 	ret = ctx->dec_if->init(ctx);
-	mtk_vcodec_dec_clock_off(&ctx->dev->pm);
-	mtk_vdec_unlock(ctx);
+	mtk_vcodec_dec_disable_hardware(ctx, ctx->hw_id);
 
 	return ret;
 }
@@ -67,17 +82,11 @@ int vdec_if_decode(struct mtk_vcodec_ctx *ctx, struct mtk_vcodec_mem *bs,
 	if (!ctx->drv_handle)
 		return -EIO;
 
-	mtk_vdec_lock(ctx);
-
-	mtk_vcodec_set_curr_ctx(ctx->dev, ctx);
-	mtk_vcodec_dec_clock_on(&ctx->dev->pm);
-	enable_irq(ctx->dev->dec_irq);
+	mtk_vcodec_dec_enable_hardware(ctx, ctx->hw_id);
+	mtk_vcodec_set_curr_ctx(ctx->dev, ctx, ctx->hw_id);
 	ret = ctx->dec_if->decode(ctx->drv_handle, bs, fb, res_chg);
-	disable_irq(ctx->dev->dec_irq);
-	mtk_vcodec_dec_clock_off(&ctx->dev->pm);
-	mtk_vcodec_set_curr_ctx(ctx->dev, NULL);
-
-	mtk_vdec_unlock(ctx);
+	mtk_vcodec_set_curr_ctx(ctx->dev, NULL, ctx->hw_id);
+	mtk_vcodec_dec_disable_hardware(ctx, ctx->hw_id);
 
 	return ret;
 }
@@ -102,11 +111,9 @@ void vdec_if_deinit(struct mtk_vcodec_ctx *ctx)
 	if (!ctx->drv_handle)
 		return;
 
-	mtk_vdec_lock(ctx);
-	mtk_vcodec_dec_clock_on(&ctx->dev->pm);
+	mtk_vcodec_dec_enable_hardware(ctx, ctx->hw_id);
 	ctx->dec_if->deinit(ctx->drv_handle);
-	mtk_vcodec_dec_clock_off(&ctx->dev->pm);
-	mtk_vdec_unlock(ctx);
+	mtk_vcodec_dec_disable_hardware(ctx, ctx->hw_id);
 
 	ctx->drv_handle = NULL;
 }
diff --git a/drivers/media/platform/mtk-vcodec/vdec_drv_if.h b/drivers/media/platform/mtk-vcodec/vdec_drv_if.h
index 961b2b6072b5e57ceb9a1011d9a66ca5d7ad6694..888285a98c3fc2749d10d634a36affc18cec8e63 100644
--- a/drivers/media/platform/mtk-vcodec/vdec_drv_if.h
+++ b/drivers/media/platform/mtk-vcodec/vdec_drv_if.h
@@ -56,8 +56,11 @@ struct vdec_fb_node {
 
 extern const struct vdec_common_if vdec_h264_if;
 extern const struct vdec_common_if vdec_h264_slice_if;
+extern const struct vdec_common_if vdec_h264_slice_lat_if;
 extern const struct vdec_common_if vdec_vp8_if;
+extern const struct vdec_common_if vdec_vp8_slice_if;
 extern const struct vdec_common_if vdec_vp9_if;
+extern const struct vdec_common_if vdec_vp9_slice_lat_if;
 
 /**
  * vdec_if_init() - initialize decode driver
diff --git a/drivers/media/platform/mtk-vcodec/vdec_ipi_msg.h b/drivers/media/platform/mtk-vcodec/vdec_ipi_msg.h
index a0e773ae3ab3414a81ea331ac8599ff4fb12b63c..0408dbe47aa3d7e60eb6f5f51c51c4b640499153 100644
--- a/drivers/media/platform/mtk-vcodec/vdec_ipi_msg.h
+++ b/drivers/media/platform/mtk-vcodec/vdec_ipi_msg.h
@@ -18,12 +18,18 @@ enum vdec_ipi_msgid {
 	AP_IPIMSG_DEC_END = 0xA002,
 	AP_IPIMSG_DEC_DEINIT = 0xA003,
 	AP_IPIMSG_DEC_RESET = 0xA004,
+	AP_IPIMSG_DEC_CORE = 0xA005,
+	AP_IPIMSG_DEC_CORE_END = 0xA006,
+	AP_IPIMSG_DEC_GET_PARAM = 0xA007,
 
 	VPU_IPIMSG_DEC_INIT_ACK = 0xB000,
 	VPU_IPIMSG_DEC_START_ACK = 0xB001,
 	VPU_IPIMSG_DEC_END_ACK = 0xB002,
 	VPU_IPIMSG_DEC_DEINIT_ACK = 0xB003,
 	VPU_IPIMSG_DEC_RESET_ACK = 0xB004,
+	VPU_IPIMSG_DEC_CORE_ACK = 0xB005,
+	VPU_IPIMSG_DEC_CORE_END_ACK = 0xB006,
+	VPU_IPIMSG_DEC_GET_PARAM_ACK = 0xB007,
 };
 
 /**
@@ -31,6 +37,8 @@ enum vdec_ipi_msgid {
  * @msg_id	: vdec_ipi_msgid
  * @vpu_inst_addr : VPU decoder instance address. Used if ABI version < 2.
  * @inst_id     : instance ID. Used if the ABI version >= 2.
+ * @codec_type	: Codec fourcc
+ * @reserved	: reserved param
  */
 struct vdec_ap_ipi_cmd {
 	uint32_t msg_id;
@@ -38,6 +46,8 @@ struct vdec_ap_ipi_cmd {
 		uint32_t vpu_inst_addr;
 		uint32_t inst_id;
 	};
+	uint32_t codec_type;
+	uint32_t reserved;
 };
 
 /**
@@ -55,12 +65,12 @@ struct vdec_vpu_ipi_ack {
 /**
  * struct vdec_ap_ipi_init - for AP_IPIMSG_DEC_INIT
  * @msg_id	: AP_IPIMSG_DEC_INIT
- * @reserved	: Reserved field
+ * @codec_type	: Codec fourcc
  * @ap_inst_addr	: AP video decoder instance address
  */
 struct vdec_ap_ipi_init {
 	uint32_t msg_id;
-	uint32_t reserved;
+	uint32_t codec_type;
 	uint64_t ap_inst_addr;
 };
 
@@ -73,7 +83,7 @@ struct vdec_ap_ipi_init {
  *	H264 decoder [0]:buf_sz [1]:nal_start
  *	VP8 decoder  [0]:width/height
  *	VP9 decoder  [0]:profile, [1][2] width/height
- * @reserved	: Reserved field
+ * @codec_type	: Codec fourcc
  */
 struct vdec_ap_ipi_dec_start {
 	uint32_t msg_id;
@@ -82,7 +92,7 @@ struct vdec_ap_ipi_dec_start {
 		uint32_t inst_id;
 	};
 	uint32_t data[3];
-	uint32_t reserved;
+	uint32_t codec_type;
 };
 
 /**
@@ -106,4 +116,38 @@ struct vdec_vpu_ipi_init_ack {
 	uint32_t inst_id;
 };
 
+/**
+ * struct vdec_ap_ipi_get_param - for AP_IPIMSG_SET_PARAM
+ * @msg_id	: AP_IPIMSG_DEC_START
+ * @inst_id     : instance ID. Used if the ABI version >= 2.
+ * @data	: picture information
+ * @param_type	: get param type
+ * @codec_type	: Codec fourcc
+ */
+struct vdec_ap_ipi_get_param {
+	uint32_t msg_id;
+	uint32_t inst_id;
+	uint32_t data[4];
+	uint32_t param_type;
+	uint32_t codec_type;
+};
+
+
+/**
+ * struct vdec_vpu_ipi_init_ack - for VPU_IPIMSG_DEC_INIT_ACK
+ * @msg_id	: VPU_IPIMSG_DEC_INIT_ACK
+ * @status	: VPU exeuction result
+ * @ap_inst_addr	: AP vcodec_vpu_inst instance address
+ * @data     : picture information from SCP.
+ * @param_type	: get param type
+ */
+struct vdec_vpu_ipi_get_param_ack {
+	uint32_t msg_id;
+	int32_t status;
+	uint64_t ap_inst_addr;
+	uint32_t data[4];
+	uint32_t param_type;
+	uint32_t reserved;
+};
+
 #endif
diff --git a/drivers/media/platform/mtk-vcodec/vdec_msg_queue.c b/drivers/media/platform/mtk-vcodec/vdec_msg_queue.c
new file mode 100644
index 0000000000000000000000000000000000000000..b011ba4c85125416fc93c6f6cfe30660dfc99b7d
--- /dev/null
+++ b/drivers/media/platform/mtk-vcodec/vdec_msg_queue.c
@@ -0,0 +1,284 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2021 MediaTek Inc.
+ * Author: Yunfei Dong <yunfei.dong@mediatek.com>
+ */
+
+#include <linux/freezer.h>
+#include <linux/interrupt.h>
+#include <linux/kthread.h>
+
+#include "mtk_vcodec_dec_pm.h"
+#include "mtk_vcodec_drv.h"
+#include "vdec_msg_queue.h"
+
+#define VDEC_LAT_SLICE_HEADER_SZ    (640 * 1024)
+#define VDEC_ERR_MAP_SZ_AVC         ((8192 / 16) * (4352 / 16) / 8)
+#define VDEC_LAT_ROY_BUF_SZ    (4 * 1024 * 1024)
+
+static int vde_msg_queue_get_trans_size(int width, int height)
+{
+	if (width > 1920 || height > 1088)
+		return (30 * 1024 * 1024);
+	else
+		return 6 * 1024 * 1024;
+}
+
+int vdec_msg_queue_init(
+	struct mtk_vcodec_ctx *ctx,
+	struct vdec_msg_queue *msg_queue,
+	core_decode_cb_t core_decode,
+	int private_size)
+{
+	struct vdec_lat_buf *lat_buf;
+	int i, err;
+
+	init_waitqueue_head(&msg_queue->lat_read);
+	INIT_LIST_HEAD(&msg_queue->lat_queue);
+	spin_lock_init(&msg_queue->lat_lock);
+	msg_queue->num_lat = 0;
+
+	msg_queue->wdma_addr.size = vde_msg_queue_get_trans_size(
+		ctx->picinfo.buf_w, ctx->picinfo.buf_h);
+
+	err = mtk_vcodec_mem_alloc(ctx, &msg_queue->wdma_addr);
+	if (err) {
+		mtk_v4l2_err("failed to allocate wdma_addr buf");
+		return -ENOMEM;
+	}
+	msg_queue->wdma_rptr_addr = msg_queue->wdma_addr.dma_addr;
+	msg_queue->wdma_wptr_addr = msg_queue->wdma_addr.dma_addr;
+
+	for (i = 0; i < NUM_BUFFER_COUNT; i++) {
+		lat_buf = &msg_queue->lat_buf[i];
+
+		lat_buf->wdma_err_addr.size = VDEC_ERR_MAP_SZ_AVC;
+		err = mtk_vcodec_mem_alloc(ctx, &lat_buf->wdma_err_addr);
+		if (err) {
+			mtk_v4l2_err("failed to allocate wdma_err_addr buf[%d]", i);
+			return -ENOMEM;
+		}
+
+		lat_buf->slice_bc_addr.size = VDEC_LAT_SLICE_HEADER_SZ;
+		err = mtk_vcodec_mem_alloc(ctx, &lat_buf->slice_bc_addr);
+		if (err) {
+			mtk_v4l2_err("failed to allocate wdma_addr buf[%d]", i);
+			return -ENOMEM;
+		}
+
+		if (ctx->dev->vdec_pdata->hw_arch == MTK_VDEC_LAT_DUAL_CORE) {
+			lat_buf->roy_buf_addr.size = VDEC_LAT_ROY_BUF_SZ;
+			err = mtk_vcodec_mem_alloc(ctx, &lat_buf->roy_buf_addr);
+			if (err) {
+				mtk_v4l2_err("failed to allocate roy_buf_addr[%d]", i);
+				return -ENOMEM;
+			}
+		}
+
+		lat_buf->private_data = kzalloc(private_size, GFP_KERNEL);
+		if (!lat_buf->private_data) {
+			mtk_v4l2_err("failed to allocate private_data[%d]", i);
+			return -ENOMEM;
+		}
+
+		lat_buf->ctx = ctx;
+		lat_buf->core_decode = core_decode;
+		vdec_msg_queue_buf_to_lat(lat_buf);
+	}
+
+	msg_queue->init_done = true;
+	return 0;
+}
+
+struct vdec_lat_buf *vdec_msg_queue_get_lat_buf(
+	struct vdec_msg_queue *msg_queue)
+{
+	struct vdec_lat_buf *buf;
+	long timeout_jiff;
+	int ret;
+
+	spin_lock(&msg_queue->lat_lock);
+	if (list_empty(&msg_queue->lat_queue)) {
+		mtk_v4l2_debug(3, "lat queue is NULL, num_lat = %d", msg_queue->num_lat);
+		spin_unlock(&msg_queue->lat_lock);
+		timeout_jiff = msecs_to_jiffies(1500);
+		ret = wait_event_timeout(msg_queue->lat_read,
+			!list_empty(&msg_queue->lat_queue), timeout_jiff);
+		if (!ret)
+			return NULL;
+		spin_lock(&msg_queue->lat_lock);
+	}
+
+	buf = list_first_entry(&msg_queue->lat_queue, struct vdec_lat_buf,
+		lat_list);
+	list_del(&buf->lat_list);
+	msg_queue->num_lat--;
+
+	mtk_v4l2_debug(4, "lat num in msg queue = %d", msg_queue->num_lat);
+	mtk_v4l2_debug(3, "get lat(0x%p) trans(0x%llx) err:0x%llx slice(0x%llx)\n",
+		buf, msg_queue->wdma_addr.dma_addr,
+		buf->wdma_err_addr.dma_addr,
+		buf->slice_bc_addr.dma_addr);
+
+	spin_unlock(&msg_queue->lat_lock);
+	return buf;
+}
+
+struct vdec_lat_buf *vdec_msg_queue_get_core_buf(
+	struct mtk_vcodec_dev *dev)
+{
+	struct vdec_lat_buf *buf;
+	int ret;
+
+	spin_lock(&dev->core_lock);
+	if (list_empty(&dev->core_queue)) {
+		mtk_v4l2_debug(3, "core queue is NULL, num_core = %d", dev->num_core);
+		spin_unlock(&dev->core_lock);
+		ret = wait_event_freezable(dev->core_read,
+			!list_empty(&dev->core_queue));
+		if (ret)
+			return NULL;
+		spin_lock(&dev->core_lock);
+	}
+
+	buf = list_first_entry(&dev->core_queue, struct vdec_lat_buf,
+		core_list);
+	mtk_v4l2_debug(3, "get core buf addr: (0x%p)", buf);
+	list_del(&buf->core_list);
+	dev->num_core--;
+	spin_unlock(&dev->core_lock);
+	return buf;
+}
+
+void vdec_msg_queue_buf_to_lat(struct vdec_lat_buf *buf)
+{
+	struct vdec_msg_queue *msg_queue = &buf->ctx->msg_queue;
+
+	spin_lock(&msg_queue->lat_lock);
+	list_add_tail(&buf->lat_list, &msg_queue->lat_queue);
+	msg_queue->num_lat++;
+	wake_up_all(&msg_queue->lat_read);
+	mtk_v4l2_debug(3, "queue buf addr: (0x%p) lat num = %d",
+		buf, msg_queue->num_lat);
+	spin_unlock(&msg_queue->lat_lock);
+}
+
+void vdec_msg_queue_buf_to_core(struct mtk_vcodec_dev *dev,
+	struct vdec_lat_buf *buf)
+{
+	spin_lock(&dev->core_lock);
+	list_add_tail(&buf->core_list, &dev->core_queue);
+	dev->num_core++;
+	wake_up_all(&dev->core_read);
+	mtk_v4l2_debug(3, "queu buf addr: (0x%p)", buf);
+	spin_unlock(&dev->core_lock);
+}
+
+void vdec_msg_queue_update_ube_rptr(struct vdec_msg_queue *msg_queue,
+	uint64_t ube_rptr)
+{
+	spin_lock(&msg_queue->lat_lock);
+	msg_queue->wdma_rptr_addr = ube_rptr;
+	mtk_v4l2_debug(3, "update ube rprt (0x%llx)", ube_rptr);
+	spin_unlock(&msg_queue->lat_lock);
+}
+
+void vdec_msg_queue_update_ube_wptr(struct vdec_msg_queue *msg_queue,
+	uint64_t ube_wptr)
+{
+	spin_lock(&msg_queue->lat_lock);
+	msg_queue->wdma_wptr_addr = ube_wptr;
+	mtk_v4l2_debug(3, "update ube wprt: (0x%llx 0x%llx) offset: 0x%llx",
+		msg_queue->wdma_rptr_addr, msg_queue->wdma_wptr_addr, ube_wptr);
+	spin_unlock(&msg_queue->lat_lock);
+}
+
+bool vdec_msg_queue_wait_lat_buf_full(struct vdec_msg_queue *msg_queue)
+{
+	long timeout_jiff;
+	int ret, i;
+
+	for (i = 0; i < NUM_BUFFER_COUNT + 2; i++) {
+		timeout_jiff = msecs_to_jiffies(1000);
+		ret = wait_event_timeout(msg_queue->lat_read,
+			msg_queue->num_lat == NUM_BUFFER_COUNT, timeout_jiff);
+		if (ret) {
+			mtk_v4l2_debug(3, "success to get lat buf: %d",
+				msg_queue->num_lat);
+			return true;
+		}
+	}
+
+	mtk_v4l2_err("failed with lat buf isn't full: %d",
+		msg_queue->num_lat);
+	return false;
+}
+
+void vdec_msg_queue_deinit(
+	struct mtk_vcodec_ctx *ctx,
+	struct vdec_msg_queue *msg_queue)
+{
+	struct vdec_lat_buf *lat_buf;
+	struct mtk_vcodec_mem *mem;
+	int i;
+
+	mem = &msg_queue->wdma_addr;
+	if (mem->va)
+		mtk_vcodec_mem_free(ctx, mem);
+	for (i = 0; i < NUM_BUFFER_COUNT; i++) {
+		lat_buf = &msg_queue->lat_buf[i];
+
+		mem = &lat_buf->wdma_err_addr;
+		if (mem->va)
+			mtk_vcodec_mem_free(ctx, mem);
+
+		mem = &lat_buf->slice_bc_addr;
+		if (mem->va)
+			mtk_vcodec_mem_free(ctx, mem);
+
+		if (ctx->dev->vdec_pdata->hw_arch == MTK_VDEC_LAT_DUAL_CORE) {
+			mem = &lat_buf->roy_buf_addr;
+			if (mem->va)
+				mtk_vcodec_mem_free(ctx, mem);
+		}
+
+		if (lat_buf->private_data)
+			kfree(lat_buf->private_data);
+	}
+
+	msg_queue->init_done = false;
+}
+
+int vdec_msg_queue_core_thead(void *data)
+{
+	struct mtk_vcodec_dev *dev = data;
+	struct vdec_lat_buf *lat_buf;
+	struct mtk_vcodec_ctx *ctx;
+
+	set_freezable();
+	for (;;) {
+		try_to_freeze();
+		if (kthread_should_stop())
+			break;
+
+		lat_buf = vdec_msg_queue_get_core_buf(dev);
+		if (!lat_buf)
+			continue;
+
+		ctx = lat_buf->ctx;
+		mtk_vcodec_dec_enable_hardware(ctx, MTK_VDEC_CORE);
+		mtk_vcodec_set_curr_ctx(dev, ctx, MTK_VDEC_CORE);
+
+		if (!lat_buf->core_decode)
+			mtk_v4l2_err("Core decode callback func is NULL");
+		else
+			lat_buf->core_decode(lat_buf);
+
+		mtk_vcodec_set_curr_ctx(dev, NULL, MTK_VDEC_CORE);
+		mtk_vcodec_dec_disable_hardware(ctx, MTK_VDEC_CORE);
+		vdec_msg_queue_buf_to_lat(lat_buf);
+	}
+
+	mtk_v4l2_debug(3, "Video Capture Thread End");
+	return 0;
+}
diff --git a/drivers/media/platform/mtk-vcodec/vdec_msg_queue.h b/drivers/media/platform/mtk-vcodec/vdec_msg_queue.h
new file mode 100644
index 0000000000000000000000000000000000000000..18d75977e2422e92a7c9fd5bd4958583198f2a92
--- /dev/null
+++ b/drivers/media/platform/mtk-vcodec/vdec_msg_queue.h
@@ -0,0 +1,137 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2021 MediaTek Inc.
+ * Author: Yunfei Dong <yunfei.dong@mediatek.com>
+ */
+
+#ifndef _VDEC_MSG_QUEUE_H_
+#define _VDEC_MSG_QUEUE_H_
+
+#include <linux/sched.h>
+#include <linux/semaphore.h>
+#include <linux/slab.h>
+#include <media/videobuf2-v4l2.h>
+
+#include "mtk_vcodec_util.h"
+
+#define NUM_BUFFER_COUNT 3
+
+struct vdec_lat_buf;
+struct mtk_vcodec_ctx;
+struct mtk_vcodec_dev;
+typedef int (*core_decode_cb_t)(struct vdec_lat_buf *lat_buf);
+
+/**
+ * struct vdec_lat_buf - lat buffer message used to store lat
+ *                       info for core decode
+ */
+struct vdec_lat_buf {
+	struct mtk_vcodec_mem wdma_err_addr;
+	struct mtk_vcodec_mem slice_bc_addr;
+	struct mtk_vcodec_mem roy_buf_addr;
+	struct vb2_v4l2_buffer ts_info;
+
+	void *private_data;
+	struct mtk_vcodec_ctx *ctx;
+	core_decode_cb_t core_decode;
+	struct list_head lat_list;
+	struct list_head core_list;
+};
+
+/**
+ * struct vdec_msg_queue - used to store lat buffer message
+ */
+struct vdec_msg_queue {
+	struct vdec_lat_buf lat_buf[NUM_BUFFER_COUNT];
+
+	struct mtk_vcodec_mem wdma_addr;
+	uint64_t wdma_rptr_addr;
+	uint64_t wdma_wptr_addr;
+
+	wait_queue_head_t lat_read;
+	struct list_head lat_queue;
+	spinlock_t lat_lock;
+	int num_lat;
+	bool init_done;
+};
+
+/**
+ * vdec_msg_queue_init - init lat buffer information.
+ * @ctx: v4l2 ctx
+ * @msg_queue: used to store the lat buffer information
+ * @core_decode: core decode callback for each codec
+ * @private_size: the private data size used to share with core
+ */
+int vdec_msg_queue_init(
+	struct mtk_vcodec_ctx *ctx,
+	struct vdec_msg_queue *msg_queue,
+	core_decode_cb_t core_decode,
+	int private_size);
+
+/**
+ * vdec_msg_queue_get_lat_buf - get used lat buffer for core decode.
+ * @msg_queue: used to store the lat buffer information
+ */
+struct vdec_lat_buf *vdec_msg_queue_get_lat_buf(
+	struct vdec_msg_queue *msg_queue);
+
+/**
+ * vdec_msg_queue_get_core_buf - get used core buffer for lat decode.
+ * @dev: mtk vcodec device
+ */
+struct vdec_lat_buf *vdec_msg_queue_get_core_buf(
+	struct mtk_vcodec_dev *dev);
+
+/**
+ * vdec_msg_queue_buf_to_core - queue buf to the core for core decode.
+ * @dev: mtk vcodec device
+ * @buf: current lat buffer
+ */
+void vdec_msg_queue_buf_to_core(struct mtk_vcodec_dev *dev,
+	struct vdec_lat_buf *buf);
+
+/**
+ * vdec_msg_queue_buf_to_lat - queue buf to lat for lat decode.
+ * @buf: current lat buffer
+ */
+void vdec_msg_queue_buf_to_lat(struct vdec_lat_buf *buf);
+
+/**
+ * vdec_msg_queue_update_ube_rptr - used to updata the ube read point.
+ * @msg_queue: used to store the lat buffer information
+ * @ube_rptr: current ube read point
+ */
+void vdec_msg_queue_update_ube_rptr(struct vdec_msg_queue *msg_queue,
+	uint64_t ube_rptr);
+
+/**
+ * vdec_msg_queue_update_ube_wptr - used to updata the ube write point.
+ * @msg_queue: used to store the lat buffer information
+ * @ube_wptr: current ube write point
+ */
+void vdec_msg_queue_update_ube_wptr(struct vdec_msg_queue *msg_queue,
+	uint64_t ube_wptr);
+
+/**
+ * vdec_msg_queue_wait_lat_buf_full - used to check whether all lat buffer
+ *                                    in lat list.
+ * @msg_queue: used to store the lat buffer information
+ */
+bool vdec_msg_queue_wait_lat_buf_full(struct vdec_msg_queue *msg_queue);
+
+/**
+ * vdec_msg_queue_deinit - deinit lat buffer information.
+ * @ctx: v4l2 ctx
+ * @msg_queue: used to store the lat buffer information
+ */
+void vdec_msg_queue_deinit(
+	struct mtk_vcodec_ctx *ctx,
+	struct vdec_msg_queue *msg_queue);
+
+/**
+ * vdec_msg_queue_core_thead - used for core decoder.
+ * @data: private data used for each codec
+ */
+int vdec_msg_queue_core_thead(void *data);
+
+#endif
diff --git a/drivers/media/platform/mtk-vcodec/vdec_vpu_if.c b/drivers/media/platform/mtk-vcodec/vdec_vpu_if.c
index 5dffc459a33dd215b0f0a90c1110b9ac9e4ed1bc..14b97eb05033831e1c95221f67e679944b5b04c3 100644
--- a/drivers/media/platform/mtk-vcodec/vdec_vpu_if.c
+++ b/drivers/media/platform/mtk-vcodec/vdec_vpu_if.c
@@ -33,8 +33,8 @@ static void handle_init_ack_msg(const struct vdec_vpu_ipi_init_ack *msg)
 	 */
 	vpu->inst_id = 0xdeadbeef;
 
-	/* Firmware version field does not exist on MT8173. */
-	if (vpu->ctx->dev->vdec_pdata->chip == MTK_MT8173)
+	/* VPU firmware does not contain a version field. */
+	if (mtk_vcodec_fw_get_type(vpu->ctx->dev->fw_handler) == VPU)
 		return;
 
 	/* Check firmware version. */
@@ -54,6 +54,27 @@ static void handle_init_ack_msg(const struct vdec_vpu_ipi_init_ack *msg)
 	}
 }
 
+static void handle_get_param_msg_ack(
+	const struct vdec_vpu_ipi_get_param_ack *msg)
+{
+	struct vdec_vpu_inst *vpu = (struct vdec_vpu_inst *)
+					(unsigned long)msg->ap_inst_addr;
+
+	mtk_vcodec_debug(vpu, "+ ap_inst_addr = 0x%llx", msg->ap_inst_addr);
+
+	/* param_type is enum vdec_get_param_type */
+	switch(msg->param_type) {
+	case 2:
+		vpu->fb_sz[0] = msg->data[0];
+		vpu->fb_sz[1] = msg->data[1];
+		break;
+	default:
+		mtk_vcodec_err(vpu, "invalid get param type=%d", msg->param_type);
+		vpu->failure = 1;
+		break;
+	}
+}
+
 /*
  * vpu_dec_ipi_handler - Handler for VPU ipi message.
  *
@@ -85,8 +106,13 @@ static void vpu_dec_ipi_handler(void *data, unsigned int len, void *priv)
 		case VPU_IPIMSG_DEC_END_ACK:
 		case VPU_IPIMSG_DEC_DEINIT_ACK:
 		case VPU_IPIMSG_DEC_RESET_ACK:
+		case VPU_IPIMSG_DEC_CORE_ACK:
+		case VPU_IPIMSG_DEC_CORE_END_ACK:
 			break;
 
+		case VPU_IPIMSG_DEC_GET_PARAM_ACK:
+			handle_get_param_msg_ack(data);
+			break;
 		default:
 			mtk_vcodec_err(vpu, "invalid msg=%X", msg->msg_id);
 			break;
@@ -98,18 +124,29 @@ static void vpu_dec_ipi_handler(void *data, unsigned int len, void *priv)
 
 static int vcodec_vpu_send_msg(struct vdec_vpu_inst *vpu, void *msg, int len)
 {
-	int err;
+	int err, id, msgid;
 
-	mtk_vcodec_debug(vpu, "id=%X", *(uint32_t *)msg);
+	msgid = *(uint32_t *)msg;
+	mtk_vcodec_debug(vpu, "id=%X", msgid);
 
 	vpu->failure = 0;
 	vpu->signaled = 0;
 
-	err = mtk_vcodec_fw_ipi_send(vpu->ctx->dev->fw_handler, vpu->id, msg,
+	if (VDEC_LAT_ARCH(vpu->ctx->dev->vdec_pdata->hw_arch)) {
+		if (msgid == AP_IPIMSG_DEC_CORE ||
+			msgid == AP_IPIMSG_DEC_CORE_END)
+			id = vpu->core_id;
+		else
+			id = vpu->id;
+	} else {
+		id = vpu->id;
+	}
+
+	err = mtk_vcodec_fw_ipi_send(vpu->ctx->dev->fw_handler, id, msg,
 				     len, 2000);
 	if (err) {
 		mtk_vcodec_err(vpu, "send fail vpu_id=%d msg_id=%X status=%d",
-			       vpu->id, *(uint32_t *)msg, err);
+			       id, msgid, err);
 		return err;
 	}
 
@@ -129,6 +166,7 @@ static int vcodec_send_ap_ipi(struct vdec_vpu_inst *vpu, unsigned int msg_id)
 		msg.vpu_inst_addr = vpu->inst_addr;
 	else
 		msg.inst_id = vpu->inst_id;
+	msg.codec_type = vpu->codec_type;
 
 	err = vcodec_vpu_send_msg(vpu, &msg, sizeof(msg));
 	mtk_vcodec_debug(vpu, "- id=%X ret=%d", msg_id, err);
@@ -147,14 +185,25 @@ int vpu_dec_init(struct vdec_vpu_inst *vpu)
 
 	err = mtk_vcodec_fw_ipi_register(vpu->ctx->dev->fw_handler, vpu->id,
 					 vpu->handler, "vdec", NULL);
-	if (err != 0) {
+	if (err) {
 		mtk_vcodec_err(vpu, "vpu_ipi_register fail status=%d", err);
 		return err;
 	}
 
+	if (VDEC_LAT_ARCH(vpu->ctx->dev->vdec_pdata->hw_arch)) {
+		err = mtk_vcodec_fw_ipi_register(vpu->ctx->dev->fw_handler,
+					 vpu->core_id, vpu->handler,
+					 "vdec", NULL);
+		if (err) {
+			mtk_vcodec_err(vpu, "vpu_ipi_register core fail status=%d", err);
+			return err;
+		}
+	}
+
 	memset(&msg, 0, sizeof(msg));
 	msg.msg_id = AP_IPIMSG_DEC_INIT;
 	msg.ap_inst_addr = (unsigned long)vpu;
+	msg.codec_type = vpu->codec_type;
 
 	mtk_vcodec_debug(vpu, "vdec_inst=%p", vpu);
 
@@ -185,17 +234,55 @@ int vpu_dec_start(struct vdec_vpu_inst *vpu, uint32_t *data, unsigned int len)
 
 	for (i = 0; i < len; i++)
 		msg.data[i] = data[i];
+	msg.codec_type = vpu->codec_type;
+
+	err = vcodec_vpu_send_msg(vpu, (void *)&msg, sizeof(msg));
+	mtk_vcodec_debug(vpu, "- ret=%d", err);
+	return err;
+}
+
+int vpu_dec_get_param(struct vdec_vpu_inst *vpu, uint32_t *data,
+	unsigned int len, unsigned int param_type)
+{
+	struct vdec_ap_ipi_get_param msg;
+	int i;
+	int err;
+
+	mtk_vcodec_debug_enter(vpu);
+
+	if (len > ARRAY_SIZE(msg.data)) {
+		mtk_vcodec_err(vpu, "invalid len = %d\n", len);
+		return -EINVAL;
+	}
+
+	memset(&msg, 0, sizeof(msg));
+	msg.msg_id = AP_IPIMSG_DEC_GET_PARAM;
+	msg.inst_id = vpu->inst_id;
+	for (i = 0; i < len; i++)
+		msg.data[i] = data[i];
+	msg.param_type = param_type;
+	msg.codec_type = vpu->codec_type;
 
 	err = vcodec_vpu_send_msg(vpu, (void *)&msg, sizeof(msg));
 	mtk_vcodec_debug(vpu, "- ret=%d", err);
 	return err;
 }
 
+int vpu_dec_core(struct vdec_vpu_inst *vpu)
+{
+	return vcodec_send_ap_ipi(vpu, AP_IPIMSG_DEC_CORE);
+}
+
 int vpu_dec_end(struct vdec_vpu_inst *vpu)
 {
 	return vcodec_send_ap_ipi(vpu, AP_IPIMSG_DEC_END);
 }
 
+int vpu_dec_core_end(struct vdec_vpu_inst *vpu)
+{
+	return vcodec_send_ap_ipi(vpu, AP_IPIMSG_DEC_CORE_END);
+}
+
 int vpu_dec_deinit(struct vdec_vpu_inst *vpu)
 {
 	return vcodec_send_ap_ipi(vpu, AP_IPIMSG_DEC_DEINIT);
diff --git a/drivers/media/platform/mtk-vcodec/vdec_vpu_if.h b/drivers/media/platform/mtk-vcodec/vdec_vpu_if.h
index c2ed5b6cab8bff5fd9a284abdcc9c904c7b425be..5adc2908dffe5cf3144538d79e65d3779b49e282 100644
--- a/drivers/media/platform/mtk-vcodec/vdec_vpu_if.h
+++ b/drivers/media/platform/mtk-vcodec/vdec_vpu_if.h
@@ -14,6 +14,7 @@ struct mtk_vcodec_ctx;
 /**
  * struct vdec_vpu_inst - VPU instance for video codec
  * @id          : ipi msg id for each decoder
+ * @core_id     : core id used to separate different hardware
  * @vsi         : driver structure allocated by VPU side and shared to AP side
  *                for control and info share
  * @failure     : VPU execution result status, 0: success, others: fail
@@ -26,9 +27,13 @@ struct mtk_vcodec_ctx;
  * @dev		: platform device of VPU
  * @wq          : wait queue to wait VPU message ack
  * @handler     : ipi handler for each decoder
+ * @codec_type     : used codec type to separate different codecs
+ * @capture_type	 : used capture type to separate different capture format
+ * @fb_sz 	: frame buffer size of each plane
  */
 struct vdec_vpu_inst {
 	int id;
+	int core_id;
 	void *vsi;
 	int32_t failure;
 	uint32_t inst_addr;
@@ -38,6 +43,9 @@ struct vdec_vpu_inst {
 	struct mtk_vcodec_ctx *ctx;
 	wait_queue_head_t wq;
 	mtk_vcodec_ipi_handler handler;
+	unsigned int codec_type;
+	unsigned int capture_type;
+	unsigned int fb_sz[2];
 };
 
 /**
@@ -82,4 +90,33 @@ int vpu_dec_deinit(struct vdec_vpu_inst *vpu);
  */
 int vpu_dec_reset(struct vdec_vpu_inst *vpu);
 
+/**
+ * vpu_dec_core - core start decoding, basically the function will be invoked once
+ *                 every frame.
+ *
+ * @vpu : instance for vdec_vpu_inst
+ */
+int vpu_dec_core(struct vdec_vpu_inst *vpu);
+
+/**
+ * vpu_dec_core_end - core end decoding, basically the function will be invoked once
+ *               when core HW decoding done and receive interrupt successfully. The
+ *               decoder in VPU will updata hardware information and deinit hardware
+ *               and check if there is a new decoded frame available to display.
+ *
+ * @vpu : instance for vdec_vpu_inst
+ */
+int vpu_dec_core_end(struct vdec_vpu_inst *vpu);
+
+/**
+ * vpu_dec_get_param - get param from scp
+ *
+ * @vpu : instance for vdec_vpu_inst
+ * @data: meta data to pass bitstream info to VPU decoder
+ * @len : meta data length
+ * @param_type : get param type
+ */
+int vpu_dec_get_param(struct vdec_vpu_inst *vpu, uint32_t *data,
+	unsigned int len, unsigned int param_type);
+
 #endif
diff --git a/drivers/media/v4l2-core/v4l2-ctrls.c b/drivers/media/v4l2-core/v4l2-ctrls.c
index fb388c1e2a0955645197a66dd2cf7baa74cc891c..cc329172444d443fd30263466acc982899a8185a 100644
--- a/drivers/media/v4l2-core/v4l2-ctrls.c
+++ b/drivers/media/v4l2-core/v4l2-ctrls.c
@@ -1700,6 +1700,7 @@ static void std_init_compound(const struct v4l2_ctrl *ctrl, u32 idx,
 {
 	struct v4l2_ctrl_mpeg2_slice_params *p_mpeg2_slice_params;
 	struct v4l2_ctrl_vp8_frame *p_vp8_frame;
+	struct v4l2_ctrl_vp9_frame_decode_params *p_vp9_frame_dec_params;
 	struct v4l2_ctrl_fwht_params *p_fwht_params;
 	void *p = ptr.p + idx * ctrl->elem_size;
 
@@ -1727,6 +1728,14 @@ static void std_init_compound(const struct v4l2_ctrl *ctrl, u32 idx,
 		p_vp8_frame = p;
 		p_vp8_frame->num_dct_parts = 1;
 		break;
+	case V4L2_CTRL_TYPE_VP9_FRAME_DECODE_PARAMS:
+		p_vp9_frame_dec_params = p;
+		p_vp9_frame_dec_params->profile = 0;
+		p_vp9_frame_dec_params->bit_depth = 8;
+		p_vp9_frame_dec_params->flags |=
+			(V4L2_VP9_FRAME_FLAG_X_SUBSAMPLING |
+			V4L2_VP9_FRAME_FLAG_Y_SUBSAMPLING);
+		break;
 	case V4L2_CTRL_TYPE_FWHT_PARAMS:
 		p_fwht_params = p;
 		p_fwht_params->version = V4L2_FWHT_VERSION;
diff --git a/drivers/memory/mtk-smi.c b/drivers/memory/mtk-smi.c
index 3f4a3c00826f7d95dc0a349ee3996758dfcbb88e..ccb00451a1b24e69a146b29cada20a0fa19cf836 100644
--- a/drivers/memory/mtk-smi.c
+++ b/drivers/memory/mtk-smi.c
@@ -17,13 +17,33 @@
 #include <dt-bindings/memory/mt2701-larb-port.h>
 #include <dt-bindings/memory/mtk-memory-port.h>
 
-/* mt8173 */
-#define SMI_LARB_MMU_EN		0xf00
+/* SMI COMMON */
+#define SMI_L1LEN			0x100
 
-/* mt8167 */
-#define MT8167_SMI_LARB_MMU_EN	0xfc0
+#define SMI_BUS_SEL			0x220
+#define SMI_BUS_LARB_SHIFT(larbid)	((larbid) << 1)
+/* All are MMU0 defaultly. Only specialize mmu1 here. */
+#define F_MMU1_LARB(larbid)		(0x1 << SMI_BUS_LARB_SHIFT(larbid))
+
+#define SMI_M4U_TH			0x234
+#define SMI_FIFO_TH1			0x238
+#define SMI_FIFO_TH2			0x23c
+#define SMI_DCM				0x300
+#define SMI_DUMMY			0x444
 
-/* mt2701 */
+/* SMI LARB */
+#define SMI_LARB_CMD_THRT_CON		0x24
+#define SMI_LARB_THRT_RD_NU_LMT_MSK	GENMASK(7, 4)
+#define SMI_LARB_THRT_RD_NU_LMT		(5 << 4)
+
+#define SMI_LARB_SW_FLAG		0x40
+#define SMI_LARB_SW_FLAG_1		0x1
+
+#define SMI_LARB_OSTDL_PORT		0x200
+#define SMI_LARB_OSTDL_PORTx(id)	(SMI_LARB_OSTDL_PORT + (((id) & 0x1f) << 2))
+
+/* Below are about mmu enable registers, they are different in SoCs */
+/* gen1: mt2701 */
 #define REG_SMI_SECUR_CON_BASE		0x5c0
 
 /* every register control 8 port, register offset 0x4 */
@@ -41,99 +61,94 @@
 /* mt2701 domain should be set to 3 */
 #define SMI_SECUR_CON_VAL_DOMAIN(id)	(0x3 << ((((id) & 0x7) << 2) + 1))
 
-/* mt2712 */
-#define SMI_LARB_NONSEC_CON(id)	(0x380 + ((id) * 4))
-#define F_MMU_EN		BIT(0)
-#define BANK_SEL(id)		({			\
+/* gen2: */
+/* mt8167 */
+#define MT8167_SMI_LARB_MMU_EN		0xfc0
+
+/* mt8173 */
+#define MT8173_SMI_LARB_MMU_EN		0xf00
+
+/* general */
+#define SMI_LARB_NONSEC_CON(id)		(0x380 + ((id) * 4))
+#define F_MMU_EN			BIT(0)
+#define BANK_SEL(id)			({		\
 	u32 _id = (id) & 0x3;				\
 	(_id << 8 | _id << 10 | _id << 12 | _id << 14);	\
 })
 
-/* SMI COMMON */
-#define SMI_BUS_SEL			0x220
-#define SMI_BUS_LARB_SHIFT(larbid)	((larbid) << 1)
-/* All are MMU0 defaultly. Only specialize mmu1 here. */
-#define F_MMU1_LARB(larbid)		(0x1 << SMI_BUS_LARB_SHIFT(larbid))
+#define SMI_COMMON_INIT_REGS_NR		6
+#define SMI_LARB_PORT_NR_MAX		32
+
+#define MTK_SMI_FLAG_THRT_UPDATE	BIT(0)
+#define MTK_SMI_FLAG_SW_FLAG		BIT(1)
+#define MTK_SMI_CAPS(flags, _x)		(!!((flags) & (_x)))
+
+struct mtk_smi_reg_pair {
+	unsigned int		offset;
+	u32			value;
+};
 
-enum mtk_smi_gen {
+enum mtk_smi_type {
 	MTK_SMI_GEN1,
-	MTK_SMI_GEN2
+	MTK_SMI_GEN2,		/* gen2 smi common */
+	MTK_SMI_GEN2_SUB_COMM,	/* gen2 smi sub common */
 };
 
+#define MTK_SMI_CLK_NR_MAX			4
+
+/* larbs: Require apb/smi clocks while gals is optional. */
+static const char * const mtk_smi_larb_clks[] = {"apb", "smi", "gals"};
+#define MTK_SMI_LARB_REQ_CLK_NR		2
+#define MTK_SMI_LARB_OPT_CLK_NR		1
+
+/*
+ * common: Require these four clocks in has_gals case. Otherwise, only apb/smi are required.
+ * sub common: Require apb/smi/gals0 clocks in has_gals case. Otherwise, only apb/smi are required.
+ */
+static const char * const mtk_smi_common_clks[] = {"apb", "smi", "gals0", "gals1"};
+#define MTK_SMI_COM_REQ_CLK_NR		2
+#define MTK_SMI_COM_GALS_REQ_CLK_NR	MTK_SMI_CLK_NR_MAX
+#define MTK_SMI_SUB_COM_GALS_REQ_CLK_NR 3
+
 struct mtk_smi_common_plat {
-	enum mtk_smi_gen gen;
-	bool             has_gals;
-	u32              bus_sel; /* Balance some larbs to enter mmu0 or mmu1 */
+	enum mtk_smi_type	type;
+	bool			has_gals;
+	u32			bus_sel; /* Balance some larbs to enter mmu0 or mmu1 */
+
+	const struct mtk_smi_reg_pair	*init;
 };
 
 struct mtk_smi_larb_gen {
 	int port_in_larb[MTK_LARB_NR_MAX + 1];
 	void (*config_port)(struct device *dev);
 	unsigned int			larb_direct_to_common_mask;
-	bool				has_gals;
+	unsigned int			flags_general;
+	const u8			(*ostd)[SMI_LARB_PORT_NR_MAX];
 };
 
 struct mtk_smi {
 	struct device			*dev;
-	struct clk			*clk_apb, *clk_smi;
-	struct clk			*clk_gals0, *clk_gals1;
+	unsigned int			clk_num;
+	struct clk_bulk_data		clks[MTK_SMI_CLK_NR_MAX];
 	struct clk			*clk_async; /*only needed by mt2701*/
 	union {
 		void __iomem		*smi_ao_base; /* only for gen1 */
 		void __iomem		*base;	      /* only for gen2 */
 	};
+	struct device			*smi_common_dev; /* for sub common */
 	const struct mtk_smi_common_plat *plat;
 };
 
 struct mtk_smi_larb { /* larb: local arbiter */
 	struct mtk_smi			smi;
 	void __iomem			*base;
-	struct device			*smi_common_dev;
+	struct device			*smi_common_dev; /* common or sub-common dev */
 	const struct mtk_smi_larb_gen	*larb_gen;
 	int				larbid;
 	u32				*mmu;
 	unsigned char			*bank;
 };
 
-static int mtk_smi_clk_enable(const struct mtk_smi *smi)
-{
-	int ret;
-
-	ret = clk_prepare_enable(smi->clk_apb);
-	if (ret)
-		return ret;
-
-	ret = clk_prepare_enable(smi->clk_smi);
-	if (ret)
-		goto err_disable_apb;
-
-	ret = clk_prepare_enable(smi->clk_gals0);
-	if (ret)
-		goto err_disable_smi;
-
-	ret = clk_prepare_enable(smi->clk_gals1);
-	if (ret)
-		goto err_disable_gals0;
-
-	return 0;
-
-err_disable_gals0:
-	clk_disable_unprepare(smi->clk_gals0);
-err_disable_smi:
-	clk_disable_unprepare(smi->clk_smi);
-err_disable_apb:
-	clk_disable_unprepare(smi->clk_apb);
-	return ret;
-}
-
-static void mtk_smi_clk_disable(const struct mtk_smi *smi)
-{
-	clk_disable_unprepare(smi->clk_gals1);
-	clk_disable_unprepare(smi->clk_gals0);
-	clk_disable_unprepare(smi->clk_smi);
-	clk_disable_unprepare(smi->clk_apb);
-}
-
 static int
 mtk_smi_larb_bind(struct device *dev, struct device *master, void *data)
 {
@@ -152,36 +167,16 @@ mtk_smi_larb_bind(struct device *dev, struct device *master, void *data)
 	return -ENODEV;
 }
 
-static void mtk_smi_larb_config_port_gen2_general(struct device *dev)
-{
-	struct mtk_smi_larb *larb = dev_get_drvdata(dev);
-	u32 reg;
-	int i;
-
-	if (BIT(larb->larbid) & larb->larb_gen->larb_direct_to_common_mask)
-		return;
-
-	for_each_set_bit(i, (unsigned long *)larb->mmu, 32) {
-		reg = readl_relaxed(larb->base + SMI_LARB_NONSEC_CON(i));
-		reg |= F_MMU_EN;
-		reg |= BANK_SEL(larb->bank[i]);
-		writel(reg, larb->base + SMI_LARB_NONSEC_CON(i));
-	}
-}
-
-static void mtk_smi_larb_config_port_mt8173(struct device *dev)
+static void
+mtk_smi_larb_unbind(struct device *dev, struct device *master, void *data)
 {
-	struct mtk_smi_larb *larb = dev_get_drvdata(dev);
-
-	writel(*larb->mmu, larb->base + SMI_LARB_MMU_EN);
+	/* Do nothing as the iommu is always enabled. */
 }
 
-static void mtk_smi_larb_config_port_mt8167(struct device *dev)
-{
-	struct mtk_smi_larb *larb = dev_get_drvdata(dev);
-
-	writel(*larb->mmu, larb->base + MT8167_SMI_LARB_MMU_EN);
-}
+static const struct component_ops mtk_smi_larb_component_ops = {
+	.bind = mtk_smi_larb_bind,
+	.unbind = mtk_smi_larb_unbind,
+};
 
 static void mtk_smi_larb_config_port_gen1(struct device *dev)
 {
@@ -214,25 +209,94 @@ static void mtk_smi_larb_config_port_gen1(struct device *dev)
 	}
 }
 
-static void
-mtk_smi_larb_unbind(struct device *dev, struct device *master, void *data)
+static void mtk_smi_larb_config_port_mt8167(struct device *dev)
 {
-	/* Do nothing as the iommu is always enabled. */
+	struct mtk_smi_larb *larb = dev_get_drvdata(dev);
+
+	writel(*larb->mmu, larb->base + MT8167_SMI_LARB_MMU_EN);
 }
 
-static const struct component_ops mtk_smi_larb_component_ops = {
-	.bind = mtk_smi_larb_bind,
-	.unbind = mtk_smi_larb_unbind,
-};
+static void mtk_smi_larb_config_port_mt8173(struct device *dev)
+{
+	struct mtk_smi_larb *larb = dev_get_drvdata(dev);
 
-static const struct mtk_smi_larb_gen mtk_smi_larb_mt8173 = {
-	/* mt8173 do not need the port in larb */
-	.config_port = mtk_smi_larb_config_port_mt8173,
-};
+	writel(*larb->mmu, larb->base + MT8173_SMI_LARB_MMU_EN);
+}
 
-static const struct mtk_smi_larb_gen mtk_smi_larb_mt8167 = {
-	/* mt8167 do not need the port in larb */
-	.config_port = mtk_smi_larb_config_port_mt8167,
+static void mtk_smi_larb_config_port_gen2_general(struct device *dev)
+{
+	struct mtk_smi_larb *larb = dev_get_drvdata(dev);
+	u32 reg, flags_general = larb->larb_gen->flags_general;
+	const u8 *larbostd = larb->larb_gen->ostd[larb->larbid];
+	int i;
+
+	if (BIT(larb->larbid) & larb->larb_gen->larb_direct_to_common_mask)
+		return;
+
+	if (MTK_SMI_CAPS(flags_general, MTK_SMI_FLAG_THRT_UPDATE)) {
+		reg = readl_relaxed(larb->base + SMI_LARB_CMD_THRT_CON);
+		reg &= ~SMI_LARB_THRT_RD_NU_LMT_MSK;
+		reg |= SMI_LARB_THRT_RD_NU_LMT;
+		writel_relaxed(reg, larb->base + SMI_LARB_CMD_THRT_CON);
+	}
+
+	if (MTK_SMI_CAPS(flags_general, MTK_SMI_FLAG_SW_FLAG))
+		writel_relaxed(SMI_LARB_SW_FLAG_1, larb->base + SMI_LARB_SW_FLAG);
+
+	for (i = 0; i < SMI_LARB_PORT_NR_MAX && larbostd && !!larbostd[i]; i++)
+		writel_relaxed(larbostd[i], larb->base + SMI_LARB_OSTDL_PORTx(i));
+
+	for_each_set_bit(i, (unsigned long *)larb->mmu, 32) {
+		reg = readl_relaxed(larb->base + SMI_LARB_NONSEC_CON(i));
+		reg |= F_MMU_EN;
+		reg |= BANK_SEL(larb->bank[i]);
+		writel(reg, larb->base + SMI_LARB_NONSEC_CON(i));
+	}
+}
+
+static const u8 mtk_smi_larb_mt8195_ostd[][SMI_LARB_PORT_NR_MAX] = {
+	[0] = {0x0a, 0xc, 0x22, 0x22, 0x01, 0x0a,}, /* larb0 */
+	[1] = {0x0a, 0xc, 0x22, 0x22, 0x01, 0x0a,}, /* larb1 */
+	[2] = {0x12, 0x12, 0x12, 0x12, 0x0a,},      /* ... */
+	[3] = {0x12, 0x12, 0x12, 0x12, 0x28, 0x28, 0x0a,},
+	[4] = {0x06, 0x01, 0x17, 0x06, 0x0a,},
+	[5] = {0x06, 0x01, 0x17, 0x06, 0x06, 0x01, 0x06, 0x0a,},
+	[6] = {0x06, 0x01, 0x06, 0x0a,},
+	[7] = {0x0c, 0x0c, 0x12,},
+	[8] = {0x0c, 0x0c, 0x12,},
+	[9] = {0x0a, 0x08, 0x04, 0x06, 0x01, 0x01, 0x10, 0x18, 0x11, 0x0a,
+		0x08, 0x04, 0x11, 0x06, 0x02, 0x06, 0x01, 0x11, 0x11, 0x06,},
+	[10] = {0x18, 0x08, 0x01, 0x01, 0x20, 0x12, 0x18, 0x06, 0x05, 0x10,
+		0x08, 0x08, 0x10, 0x08, 0x08, 0x18, 0x0c, 0x09, 0x0b, 0x0d,
+		0x0d, 0x06, 0x10, 0x10,},
+	[11] = {0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x01, 0x01, 0x01, 0x01,},
+	[12] = {0x09, 0x09, 0x05, 0x05, 0x0c, 0x18, 0x02, 0x02, 0x04, 0x02,},
+	[13] = {0x02, 0x02, 0x12, 0x12, 0x02, 0x02, 0x02, 0x02, 0x08, 0x01,},
+	[14] = {0x12, 0x12, 0x02, 0x02, 0x02, 0x02, 0x16, 0x01, 0x16, 0x01,
+		0x01, 0x02, 0x02, 0x08, 0x02,},
+	[15] = {},
+	[16] = {0x28, 0x02, 0x02, 0x12, 0x02, 0x12, 0x10, 0x02, 0x02, 0x0a,
+		0x12, 0x02, 0x0a, 0x16, 0x02, 0x04,},
+	[17] = {0x1a, 0x0e, 0x0a, 0x0a, 0x0c, 0x0e, 0x10,},
+	[18] = {0x12, 0x06, 0x12, 0x06,},
+	[19] = {0x01, 0x04, 0x01, 0x01, 0x01, 0x01, 0x01, 0x04, 0x04, 0x01,
+		0x01, 0x01, 0x04, 0x0a, 0x06, 0x01, 0x01, 0x01, 0x0a, 0x06,
+		0x01, 0x01, 0x05, 0x03, 0x03, 0x04, 0x01,},
+	[20] = {0x01, 0x04, 0x01, 0x01, 0x01, 0x01, 0x01, 0x04, 0x04, 0x01,
+		0x01, 0x01, 0x04, 0x0a, 0x06, 0x01, 0x01, 0x01, 0x0a, 0x06,
+		0x01, 0x01, 0x05, 0x03, 0x03, 0x04, 0x01,},
+	[21] = {0x28, 0x19, 0x0c, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x04,},
+	[22] = {0x28, 0x19, 0x0c, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x04,},
+	[23] = {0x18, 0x01,},
+	[24] = {0x01, 0x01, 0x04, 0x01, 0x01, 0x01, 0x01, 0x01, 0x04, 0x01,
+		0x01, 0x01,},
+	[25] = {0x02, 0x02, 0x02, 0x28, 0x16, 0x02, 0x02, 0x02, 0x12, 0x16,
+		0x02, 0x01,},
+	[26] = {0x02, 0x02, 0x02, 0x28, 0x16, 0x02, 0x02, 0x02, 0x12, 0x16,
+		0x02, 0x01,},
+	[27] = {0x02, 0x02, 0x02, 0x28, 0x16, 0x02, 0x02, 0x02, 0x12, 0x16,
+		0x02, 0x01,},
+	[28] = {0x1a, 0x0e, 0x0a, 0x0a, 0x0c, 0x0e, 0x10,},
 };
 
 static const struct mtk_smi_larb_gen mtk_smi_larb_mt2701 = {
@@ -255,8 +319,17 @@ static const struct mtk_smi_larb_gen mtk_smi_larb_mt6779 = {
 		/* DUMMY | IPU0 | IPU1 | CCU | MDLA */
 };
 
+static const struct mtk_smi_larb_gen mtk_smi_larb_mt8167 = {
+	/* mt8167 do not need the port in larb */
+	.config_port = mtk_smi_larb_config_port_mt8167,
+};
+
+static const struct mtk_smi_larb_gen mtk_smi_larb_mt8173 = {
+	/* mt8173 do not need the port in larb */
+	.config_port = mtk_smi_larb_config_port_mt8173,
+};
+
 static const struct mtk_smi_larb_gen mtk_smi_larb_mt8183 = {
-	.has_gals                   = true,
 	.config_port                = mtk_smi_larb_config_port_gen2_general,
 	.larb_direct_to_common_mask = BIT(2) | BIT(3) | BIT(7),
 				      /* IPU0 | IPU1 | CCU */
@@ -266,99 +339,114 @@ static const struct mtk_smi_larb_gen mtk_smi_larb_mt8192 = {
 	.config_port                = mtk_smi_larb_config_port_gen2_general,
 };
 
+static const struct mtk_smi_larb_gen mtk_smi_larb_mt8195 = {
+	.config_port                = mtk_smi_larb_config_port_gen2_general,
+	.flags_general	            = MTK_SMI_FLAG_THRT_UPDATE | MTK_SMI_FLAG_SW_FLAG,
+	.ostd		            = mtk_smi_larb_mt8195_ostd,
+};
+
 static const struct of_device_id mtk_smi_larb_of_ids[] = {
-	{
-		.compatible = "mediatek,mt8167-smi-larb",
-		.data = &mtk_smi_larb_mt8167
-	},
-	{
-		.compatible = "mediatek,mt8173-smi-larb",
-		.data = &mtk_smi_larb_mt8173
-	},
-	{
-		.compatible = "mediatek,mt2701-smi-larb",
-		.data = &mtk_smi_larb_mt2701
-	},
-	{
-		.compatible = "mediatek,mt2712-smi-larb",
-		.data = &mtk_smi_larb_mt2712
-	},
-	{
-		.compatible = "mediatek,mt6779-smi-larb",
-		.data = &mtk_smi_larb_mt6779
-	},
-	{
-		.compatible = "mediatek,mt8183-smi-larb",
-		.data = &mtk_smi_larb_mt8183
-	},
-	{
-		.compatible = "mediatek,mt8192-smi-larb",
-		.data = &mtk_smi_larb_mt8192
-	},
+	{.compatible = "mediatek,mt2701-smi-larb", .data = &mtk_smi_larb_mt2701},
+	{.compatible = "mediatek,mt2712-smi-larb", .data = &mtk_smi_larb_mt2712},
+	{.compatible = "mediatek,mt6779-smi-larb", .data = &mtk_smi_larb_mt6779},
+	{.compatible = "mediatek,mt8167-smi-larb", .data = &mtk_smi_larb_mt8167},
+	{.compatible = "mediatek,mt8173-smi-larb", .data = &mtk_smi_larb_mt8173},
+	{.compatible = "mediatek,mt8183-smi-larb", .data = &mtk_smi_larb_mt8183},
+	{.compatible = "mediatek,mt8192-smi-larb", .data = &mtk_smi_larb_mt8192},
+	{.compatible = "mediatek,mt8195-smi-larb", .data = &mtk_smi_larb_mt8195},
 	{}
 };
 
-static int mtk_smi_larb_probe(struct platform_device *pdev)
+static int mtk_smi_device_link_common(struct device *dev, struct device **com_dev)
 {
-	struct mtk_smi_larb *larb;
-	struct resource *res;
-	struct device *dev = &pdev->dev;
-	struct device_node *smi_node;
-	struct platform_device *smi_pdev;
+	struct platform_device *smi_com_pdev;
+	struct device_node *smi_com_node;
+	struct device *smi_com_dev;
 	struct device_link *link;
 
-	larb = devm_kzalloc(dev, sizeof(*larb), GFP_KERNEL);
-	if (!larb)
-		return -ENOMEM;
-
-	larb->larb_gen = of_device_get_match_data(dev);
-	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	larb->base = devm_ioremap_resource(dev, res);
-	if (IS_ERR(larb->base))
-		return PTR_ERR(larb->base);
-
-	larb->smi.clk_apb = devm_clk_get(dev, "apb");
-	if (IS_ERR(larb->smi.clk_apb))
-		return PTR_ERR(larb->smi.clk_apb);
-
-	larb->smi.clk_smi = devm_clk_get(dev, "smi");
-	if (IS_ERR(larb->smi.clk_smi))
-		return PTR_ERR(larb->smi.clk_smi);
-
-	if (larb->larb_gen->has_gals) {
-		/* The larbs may still haven't gals even if the SoC support.*/
-		larb->smi.clk_gals0 = devm_clk_get(dev, "gals");
-		if (PTR_ERR(larb->smi.clk_gals0) == -ENOENT)
-			larb->smi.clk_gals0 = NULL;
-		else if (IS_ERR(larb->smi.clk_gals0))
-			return PTR_ERR(larb->smi.clk_gals0);
-	}
-	larb->smi.dev = dev;
-
-	smi_node = of_parse_phandle(dev->of_node, "mediatek,smi", 0);
-	if (!smi_node)
+	smi_com_node = of_parse_phandle(dev->of_node, "mediatek,smi", 0);
+	if (!smi_com_node)
 		return -EINVAL;
 
-	smi_pdev = of_find_device_by_node(smi_node);
-	of_node_put(smi_node);
-	if (smi_pdev) {
-		if (!platform_get_drvdata(smi_pdev))
+	smi_com_pdev = of_find_device_by_node(smi_com_node);
+	of_node_put(smi_com_node);
+	if (smi_com_pdev) {
+		/* smi common is the supplier, Make sure it is ready before */
+		if (!platform_get_drvdata(smi_com_pdev))
 			return -EPROBE_DEFER;
-		larb->smi_common_dev = &smi_pdev->dev;
-		link = device_link_add(dev, larb->smi_common_dev,
+		smi_com_dev = &smi_com_pdev->dev;
+		link = device_link_add(dev, smi_com_dev,
 				       DL_FLAG_PM_RUNTIME | DL_FLAG_STATELESS);
 		if (!link) {
 			dev_err(dev, "Unable to link smi-common dev\n");
 			return -ENODEV;
 		}
+		*com_dev = smi_com_dev;
 	} else {
 		dev_err(dev, "Failed to get the smi_common device\n");
 		return -EINVAL;
 	}
+	return 0;
+}
+
+static int mtk_smi_dts_clk_init(struct device *dev, struct mtk_smi *smi,
+				const char * const clks[],
+				unsigned int clk_nr_required,
+				unsigned int clk_nr_optional)
+{
+	int i, ret;
+
+	for (i = 0; i < clk_nr_required; i++)
+		smi->clks[i].id = clks[i];
+	ret = devm_clk_bulk_get(dev, clk_nr_required, smi->clks);
+	if (ret)
+		return ret;
+
+	for (i = clk_nr_required; i < clk_nr_required + clk_nr_optional; i++)
+		smi->clks[i].id = clks[i];
+	ret = devm_clk_bulk_get_optional(dev, clk_nr_optional,
+					 smi->clks + clk_nr_required);
+	smi->clk_num = clk_nr_required + clk_nr_optional;
+	return ret;
+}
+
+static int mtk_smi_larb_probe(struct platform_device *pdev)
+{
+	struct mtk_smi_larb *larb;
+	struct device *dev = &pdev->dev;
+	int ret;
+
+	larb = devm_kzalloc(dev, sizeof(*larb), GFP_KERNEL);
+	if (!larb)
+		return -ENOMEM;
+
+	larb->larb_gen = of_device_get_match_data(dev);
+	larb->base = devm_platform_ioremap_resource(pdev, 0);
+	if (IS_ERR(larb->base))
+		return PTR_ERR(larb->base);
+
+	ret = mtk_smi_dts_clk_init(dev, &larb->smi, mtk_smi_larb_clks,
+				   MTK_SMI_LARB_REQ_CLK_NR, MTK_SMI_LARB_OPT_CLK_NR);
+	if (ret)
+		return ret;
+
+	larb->smi.dev = dev;
+
+	ret = mtk_smi_device_link_common(dev, &larb->smi_common_dev);
+	if (ret < 0)
+		return ret;
 
 	pm_runtime_enable(dev);
 	platform_set_drvdata(pdev, larb);
-	return component_add(dev, &mtk_smi_larb_component_ops);
+	ret = component_add(dev, &mtk_smi_larb_component_ops);
+	if (ret)
+		goto err_pm_disable;
+	return 0;
+
+err_pm_disable:
+	pm_runtime_disable(dev);
+	device_link_remove(dev, larb->smi_common_dev);
+	return ret;
 }
 
 static int mtk_smi_larb_remove(struct platform_device *pdev)
@@ -377,11 +465,9 @@ static int __maybe_unused mtk_smi_larb_resume(struct device *dev)
 	const struct mtk_smi_larb_gen *larb_gen = larb->larb_gen;
 	int ret;
 
-	ret = mtk_smi_clk_enable(&larb->smi);
-	if (ret < 0) {
-		dev_err(dev, "Failed to enable clock(%d).\n", ret);
+	ret = clk_bulk_prepare_enable(larb->smi.clk_num, larb->smi.clks);
+	if (ret < 0)
 		return ret;
-	}
 
 	/* Configure the basic setting for this larb */
 	larb_gen->config_port(dev);
@@ -393,7 +479,7 @@ static int __maybe_unused mtk_smi_larb_suspend(struct device *dev)
 {
 	struct mtk_smi_larb *larb = dev_get_drvdata(dev);
 
-	mtk_smi_clk_disable(&larb->smi);
+	clk_bulk_disable_unprepare(larb->smi.clk_num, larb->smi.clks);
 	return 0;
 }
 
@@ -413,64 +499,75 @@ static struct platform_driver mtk_smi_larb_driver = {
 	}
 };
 
+static const struct mtk_smi_reg_pair mtk_smi_common_mt8195_init[SMI_COMMON_INIT_REGS_NR] = {
+	{SMI_L1LEN, 0xb},
+	{SMI_M4U_TH, 0xe100e10},
+	{SMI_FIFO_TH1, 0x506090a},
+	{SMI_FIFO_TH2, 0x506090a},
+	{SMI_DCM, 0x4f1},
+	{SMI_DUMMY, 0x1},
+};
+
 static const struct mtk_smi_common_plat mtk_smi_common_gen1 = {
-	.gen = MTK_SMI_GEN1,
+	.type     = MTK_SMI_GEN1,
 };
 
 static const struct mtk_smi_common_plat mtk_smi_common_gen2 = {
-	.gen = MTK_SMI_GEN2,
+	.type	  = MTK_SMI_GEN2,
 };
 
 static const struct mtk_smi_common_plat mtk_smi_common_mt6779 = {
-	.gen		= MTK_SMI_GEN2,
-	.has_gals	= true,
-	.bus_sel	= F_MMU1_LARB(1) | F_MMU1_LARB(2) | F_MMU1_LARB(4) |
-			  F_MMU1_LARB(5) | F_MMU1_LARB(6) | F_MMU1_LARB(7),
+	.type	  = MTK_SMI_GEN2,
+	.has_gals = true,
+	.bus_sel  = F_MMU1_LARB(1) | F_MMU1_LARB(2) | F_MMU1_LARB(4) |
+		    F_MMU1_LARB(5) | F_MMU1_LARB(6) | F_MMU1_LARB(7),
 };
 
 static const struct mtk_smi_common_plat mtk_smi_common_mt8183 = {
-	.gen      = MTK_SMI_GEN2,
+	.type     = MTK_SMI_GEN2,
 	.has_gals = true,
 	.bus_sel  = F_MMU1_LARB(1) | F_MMU1_LARB(2) | F_MMU1_LARB(5) |
 		    F_MMU1_LARB(7),
 };
 
 static const struct mtk_smi_common_plat mtk_smi_common_mt8192 = {
-	.gen      = MTK_SMI_GEN2,
+	.type     = MTK_SMI_GEN2,
 	.has_gals = true,
 	.bus_sel  = F_MMU1_LARB(1) | F_MMU1_LARB(2) | F_MMU1_LARB(5) |
 		    F_MMU1_LARB(6),
 };
 
+static const struct mtk_smi_common_plat mtk_smi_common_mt8195_vdo = {
+	.type     = MTK_SMI_GEN2,
+	.has_gals = true,
+	.bus_sel  = F_MMU1_LARB(1) | F_MMU1_LARB(3) | F_MMU1_LARB(5) |
+		    F_MMU1_LARB(7),
+	.init     = mtk_smi_common_mt8195_init,
+};
+
+static const struct mtk_smi_common_plat mtk_smi_common_mt8195_vpp = {
+	.type     = MTK_SMI_GEN2,
+	.has_gals = true,
+	.bus_sel  = F_MMU1_LARB(1) | F_MMU1_LARB(2) | F_MMU1_LARB(7),
+	.init     = mtk_smi_common_mt8195_init,
+};
+
+static const struct mtk_smi_common_plat mtk_smi_sub_common_mt8195 = {
+	.type     = MTK_SMI_GEN2_SUB_COMM,
+	.has_gals = true,
+};
+
 static const struct of_device_id mtk_smi_common_of_ids[] = {
-	{
-		.compatible = "mediatek,mt8173-smi-common",
-		.data = &mtk_smi_common_gen2,
-	},
-	{
-		.compatible = "mediatek,mt8167-smi-common",
-		.data = &mtk_smi_common_gen2,
-	},
-	{
-		.compatible = "mediatek,mt2701-smi-common",
-		.data = &mtk_smi_common_gen1,
-	},
-	{
-		.compatible = "mediatek,mt2712-smi-common",
-		.data = &mtk_smi_common_gen2,
-	},
-	{
-		.compatible = "mediatek,mt6779-smi-common",
-		.data = &mtk_smi_common_mt6779,
-	},
-	{
-		.compatible = "mediatek,mt8183-smi-common",
-		.data = &mtk_smi_common_mt8183,
-	},
-	{
-		.compatible = "mediatek,mt8192-smi-common",
-		.data = &mtk_smi_common_mt8192,
-	},
+	{.compatible = "mediatek,mt2701-smi-common", .data = &mtk_smi_common_gen1},
+	{.compatible = "mediatek,mt2712-smi-common", .data = &mtk_smi_common_gen2},
+	{.compatible = "mediatek,mt6779-smi-common", .data = &mtk_smi_common_mt6779},
+	{.compatible = "mediatek,mt8167-smi-common", .data = &mtk_smi_common_gen2},
+	{.compatible = "mediatek,mt8173-smi-common", .data = &mtk_smi_common_gen2},
+	{.compatible = "mediatek,mt8183-smi-common", .data = &mtk_smi_common_mt8183},
+	{.compatible = "mediatek,mt8192-smi-common", .data = &mtk_smi_common_mt8192},
+	{.compatible = "mediatek,mt8195-smi-common-vdo", .data = &mtk_smi_common_mt8195_vdo},
+	{.compatible = "mediatek,mt8195-smi-common-vpp", .data = &mtk_smi_common_mt8195_vpp},
+	{.compatible = "mediatek,mt8195-smi-sub-common", .data = &mtk_smi_sub_common_mt8195},
 	{}
 };
 
@@ -478,8 +575,7 @@ static int mtk_smi_common_probe(struct platform_device *pdev)
 {
 	struct device *dev = &pdev->dev;
 	struct mtk_smi *common;
-	struct resource *res;
-	int ret;
+	int ret, clk_required = MTK_SMI_COM_REQ_CLK_NR;
 
 	common = devm_kzalloc(dev, sizeof(*common), GFP_KERNEL);
 	if (!common)
@@ -487,23 +583,15 @@ static int mtk_smi_common_probe(struct platform_device *pdev)
 	common->dev = dev;
 	common->plat = of_device_get_match_data(dev);
 
-	common->clk_apb = devm_clk_get(dev, "apb");
-	if (IS_ERR(common->clk_apb))
-		return PTR_ERR(common->clk_apb);
-
-	common->clk_smi = devm_clk_get(dev, "smi");
-	if (IS_ERR(common->clk_smi))
-		return PTR_ERR(common->clk_smi);
-
 	if (common->plat->has_gals) {
-		common->clk_gals0 = devm_clk_get(dev, "gals0");
-		if (IS_ERR(common->clk_gals0))
-			return PTR_ERR(common->clk_gals0);
-
-		common->clk_gals1 = devm_clk_get(dev, "gals1");
-		if (IS_ERR(common->clk_gals1))
-			return PTR_ERR(common->clk_gals1);
+		if (common->plat->type == MTK_SMI_GEN2)
+			clk_required = MTK_SMI_COM_GALS_REQ_CLK_NR;
+		else if (common->plat->type == MTK_SMI_GEN2_SUB_COMM)
+			clk_required = MTK_SMI_SUB_COM_GALS_REQ_CLK_NR;
 	}
+	ret = mtk_smi_dts_clk_init(dev, common, mtk_smi_common_clks, clk_required, 0);
+	if (ret)
+		return ret;
 
 	/*
 	 * for mtk smi gen 1, we need to get the ao(always on) base to config
@@ -511,9 +599,8 @@ static int mtk_smi_common_probe(struct platform_device *pdev)
 	 * clock into emi clock domain, but for mtk smi gen2, there's no smi ao
 	 * base.
 	 */
-	if (common->plat->gen == MTK_SMI_GEN1) {
-		res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-		common->smi_ao_base = devm_ioremap_resource(dev, res);
+	if (common->plat->type == MTK_SMI_GEN1) {
+		common->smi_ao_base = devm_platform_ioremap_resource(pdev, 0);
 		if (IS_ERR(common->smi_ao_base))
 			return PTR_ERR(common->smi_ao_base);
 
@@ -525,11 +612,18 @@ static int mtk_smi_common_probe(struct platform_device *pdev)
 		if (ret)
 			return ret;
 	} else {
-		res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-		common->base = devm_ioremap_resource(dev, res);
+		common->base = devm_platform_ioremap_resource(pdev, 0);
 		if (IS_ERR(common->base))
 			return PTR_ERR(common->base);
 	}
+
+	/* link its smi-common if this is smi-sub-common */
+	if (common->plat->type == MTK_SMI_GEN2_SUB_COMM) {
+		ret = mtk_smi_device_link_common(dev, &common->smi_common_dev);
+		if (ret < 0)
+			return ret;
+	}
+
 	pm_runtime_enable(dev);
 	platform_set_drvdata(pdev, common);
 	return 0;
@@ -537,6 +631,10 @@ static int mtk_smi_common_probe(struct platform_device *pdev)
 
 static int mtk_smi_common_remove(struct platform_device *pdev)
 {
+	struct mtk_smi *common = dev_get_drvdata(&pdev->dev);
+
+	if (common->plat->type == MTK_SMI_GEN2_SUB_COMM)
+		device_link_remove(&pdev->dev, common->smi_common_dev);
 	pm_runtime_disable(&pdev->dev);
 	return 0;
 }
@@ -544,17 +642,21 @@ static int mtk_smi_common_remove(struct platform_device *pdev)
 static int __maybe_unused mtk_smi_common_resume(struct device *dev)
 {
 	struct mtk_smi *common = dev_get_drvdata(dev);
-	u32 bus_sel = common->plat->bus_sel;
-	int ret;
+	const struct mtk_smi_reg_pair *init = common->plat->init;
+	u32 bus_sel = common->plat->bus_sel; /* default is 0 */
+	int ret, i;
 
-	ret = mtk_smi_clk_enable(common);
-	if (ret) {
-		dev_err(common->dev, "Failed to enable clock(%d).\n", ret);
+	ret = clk_bulk_prepare_enable(common->clk_num, common->clks);
+	if (ret)
 		return ret;
-	}
 
-	if (common->plat->gen == MTK_SMI_GEN2 && bus_sel)
-		writel(bus_sel, common->base + SMI_BUS_SEL);
+	if (common->plat->type != MTK_SMI_GEN2)
+		return 0;
+
+	for (i = 0; i < SMI_COMMON_INIT_REGS_NR && init && init[i].offset; i++)
+		writel_relaxed(init[i].value, common->base + init[i].offset);
+
+	writel(bus_sel, common->base + SMI_BUS_SEL);
 	return 0;
 }
 
@@ -562,7 +664,7 @@ static int __maybe_unused mtk_smi_common_suspend(struct device *dev)
 {
 	struct mtk_smi *common = dev_get_drvdata(dev);
 
-	mtk_smi_clk_disable(common);
+	clk_bulk_disable_unprepare(common->clk_num, common->clks);
 	return 0;
 }
 
diff --git a/drivers/phy/mediatek/Kconfig b/drivers/phy/mediatek/Kconfig
index 671f5637cde78228b46b8864c85bb6f3f415e029..3a6810b29e0ffeab7b651d02ebf8cb9b91396611 100644
--- a/drivers/phy/mediatek/Kconfig
+++ b/drivers/phy/mediatek/Kconfig
@@ -53,3 +53,11 @@ config PHY_MTK_MIPI_DSI
 	select GENERIC_PHY
 	help
 	  Support MIPI DSI for Mediatek SoCs.
+
+config PHY_MTK_PCIE
+	tristate "MediaTek PCIe-PHY Driver"
+	depends on ARCH_MEDIATEK && OF
+	select GENERIC_PHY
+	help
+	  Say 'Y' here to add support for MediaTeck PCIe PHY driver,
+	  This driver support for PCIe GEN3 port.
diff --git a/drivers/phy/mediatek/Makefile b/drivers/phy/mediatek/Makefile
index ace660fbed3a12d08949b6e8787cc1d602e989a1..788c13147f636e77a517f37f0f3b8aee993e9df5 100644
--- a/drivers/phy/mediatek/Makefile
+++ b/drivers/phy/mediatek/Makefile
@@ -6,6 +6,7 @@
 obj-$(CONFIG_PHY_MTK_TPHY)		+= phy-mtk-tphy.o
 obj-$(CONFIG_PHY_MTK_UFS)		+= phy-mtk-ufs.o
 obj-$(CONFIG_PHY_MTK_XSPHY)		+= phy-mtk-xsphy.o
+obj-$(CONFIG_PHY_MTK_PCIE)		+= phy-mtk-pcie.o
 
 phy-mtk-hdmi-drv-y			:= phy-mtk-hdmi.o
 phy-mtk-hdmi-drv-y			+= phy-mtk-hdmi-mt2701.o
diff --git a/drivers/phy/mediatek/phy-mtk-pcie.c b/drivers/phy/mediatek/phy-mtk-pcie.c
new file mode 100644
index 0000000000000000000000000000000000000000..ffec9fb9376c1fbbe5c869d7d7f6bc55bb7a5fdc
--- /dev/null
+++ b/drivers/phy/mediatek/phy-mtk-pcie.c
@@ -0,0 +1,136 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2020 MediaTek Inc.
+ * Author: Jianjun Wang <jianjun.wang@mediatek.com>
+ */
+
+#include <dt-bindings/phy/phy.h>
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/io.h>
+#include <linux/iopoll.h>
+#include <linux/module.h>
+#include <linux/of_address.h>
+#include <linux/of_device.h>
+#include <linux/phy/phy.h>
+#include <linux/pm_domain.h>
+#include <linux/platform_device.h>
+#include <linux/sysfs.h>
+
+#define PCIE_PHY_CKM_REG04		0x04
+#define CKM_PT0_CKTX_SLEW_MASK		GENMASK(9, 8)
+#define CKM_PT0_CKTX_SLEW(val)		((val << 8) & GENMASK(9, 8))
+#define CKM_PT0_CKTX_OFFSET_MASK	GENMASK(11, 10)
+#define CKM_PT0_CKTX_OFFSET(val)	((val << 10) & GENMASK(11, 10))
+#define CKM_PT0_CKTX_AMP_MASK		GENMASK(15, 12)
+#define CKM_PT0_CKTX_AMP(val)		((val << 12) & GENMASK(15, 12))
+
+struct mtk_pcie_phy {
+	struct device *dev;
+	struct phy *phy;
+	void __iomem *sif_base;
+	void __iomem *ckm_base;
+	struct clk *pipe_clk;
+};
+
+static int mtk_pcie_phy_power_on(struct phy *phy)
+{
+	struct mtk_pcie_phy *pcie_phy = phy_get_drvdata(phy);
+	int ret;
+	u32 val;
+
+	pm_runtime_enable(pcie_phy->dev);
+	pm_runtime_get_sync(pcie_phy->dev);
+
+	val = readl(pcie_phy->ckm_base + PCIE_PHY_CKM_REG04);
+	val &= ~GENMASK(11, 10);
+	val |= CKM_PT0_CKTX_OFFSET(0x2) | CKM_PT0_CKTX_AMP(0xf);
+	writel(val, pcie_phy->ckm_base + PCIE_PHY_CKM_REG04);
+
+	if (pcie_phy->pipe_clk) {
+		ret = clk_prepare_enable(pcie_phy->pipe_clk);
+		if (ret) {
+			dev_err(pcie_phy->dev, "failed to enable pipe_clk\n");
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
+static int mtk_pcie_phy_power_off(struct phy *phy)
+{
+	struct mtk_pcie_phy *pcie_phy = phy_get_drvdata(phy);
+
+	if (pcie_phy->pipe_clk)
+		clk_disable_unprepare(pcie_phy->pipe_clk);
+
+	pm_runtime_put_sync(pcie_phy->dev);
+	pm_runtime_disable(pcie_phy->dev);
+
+	return 0;
+}
+
+static const struct phy_ops mtk_pcie_phy_ops = {
+	.power_on	= mtk_pcie_phy_power_on,
+	.power_off	= mtk_pcie_phy_power_off,
+	.owner		= THIS_MODULE,
+};
+
+static int mtk_pcie_phy_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct phy_provider *provider;
+	struct resource *reg_res;
+	struct mtk_pcie_phy *pcie_phy;
+
+	pcie_phy = devm_kzalloc(dev, sizeof(*pcie_phy), GFP_KERNEL);
+	if (!pcie_phy)
+		return -ENOMEM;
+
+	pcie_phy->dev = dev;
+
+	pcie_phy->pipe_clk = devm_clk_get_optional(pcie_phy->dev, "pipe_clk");
+	if (IS_ERR(pcie_phy->pipe_clk)) {
+		dev_warn(dev, "failed to get pipe_clk\n");
+		return PTR_ERR(pcie_phy->pipe_clk);
+	}
+
+	reg_res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "phy-ckm");
+	pcie_phy->ckm_base = devm_ioremap_resource(dev, reg_res);
+	if (IS_ERR(pcie_phy->ckm_base)) {
+		dev_warn(dev, "failed to map pcie phy base\n");
+		return PTR_ERR(pcie_phy->ckm_base);
+	}
+
+	platform_set_drvdata(pdev, pcie_phy);
+
+	pcie_phy->phy = devm_phy_create(dev, dev->of_node, &mtk_pcie_phy_ops);
+	if (IS_ERR(pcie_phy->phy)) {
+		dev_err(dev, "failed to create pcie phy\n");
+		return PTR_ERR(pcie_phy->phy);
+	}
+
+	phy_set_drvdata(pcie_phy->phy, pcie_phy);
+
+	provider = devm_of_phy_provider_register(dev, of_phy_simple_xlate);
+
+	return PTR_ERR_OR_ZERO(provider);
+}
+
+static const struct of_device_id mtk_pcie_phy_id_table[] = {
+	{ .compatible = "mediatek,mt8192-pcie-phy" },
+	{ .compatible = "mediatek,mt8195-pcie-phy" },
+	{ },
+};
+
+static struct platform_driver mtk_pcie_phy_driver = {
+	.probe	= mtk_pcie_phy_probe,
+	.driver	= {
+		.name	= "mtk-pcie-phy",
+		.of_match_table = mtk_pcie_phy_id_table,
+	},
+};
+
+module_platform_driver(mtk_pcie_phy_driver);
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/phy/mediatek/phy-mtk-tphy.c b/drivers/phy/mediatek/phy-mtk-tphy.c
index 33000b38fd1bf2834a0a211873e78280ba42b8a0..ab50d0e333a324103580f4e3c90c81ff35ffb895 100644
--- a/drivers/phy/mediatek/phy-mtk-tphy.c
+++ b/drivers/phy/mediatek/phy-mtk-tphy.c
@@ -1263,6 +1263,8 @@ static int mtk_tphy_probe(struct platform_device *pdev)
 		}
 	}
 
+	device_init_wakeup(dev, true);
+
 	provider = devm_of_phy_provider_register(dev, mtk_phy_xlate);
 
 	return PTR_ERR_OR_ZERO(provider);
diff --git a/drivers/pinctrl/mediatek/pinctrl-mt8195.c b/drivers/pinctrl/mediatek/pinctrl-mt8195.c
index a7500e18bb1de47129d577a029c88e13636259a4..84b3a74d00a8de30e7ca3b12b3005dc35f7758c7 100644
--- a/drivers/pinctrl/mediatek/pinctrl-mt8195.c
+++ b/drivers/pinctrl/mediatek/pinctrl-mt8195.c
@@ -779,6 +779,25 @@ static const struct mtk_pin_field_calc mt8195_pin_drv_adv_range[] = {
 	PIN_FIELD_BASE(45, 45, 1, 0x040, 0x10, 9, 3),
 };
 
+static const struct mtk_pin_field_calc mt8195_pin_rsel_range[] = {
+	PIN_FIELD_BASE(8, 8, 4, 0x0c0, 0x10, 15, 3),
+	PIN_FIELD_BASE(9, 9, 4, 0x0c0, 0x10, 0, 3),
+	PIN_FIELD_BASE(10, 10, 4, 0x0c0, 0x10, 18, 3),
+	PIN_FIELD_BASE(11, 11, 4, 0x0c0, 0x10, 3, 3),
+	PIN_FIELD_BASE(12, 12, 4, 0x0c0, 0x10, 21, 3),
+	PIN_FIELD_BASE(13, 13, 4, 0x0c0, 0x10, 6, 3),
+	PIN_FIELD_BASE(14, 14, 4, 0x0c0, 0x10, 24, 3),
+	PIN_FIELD_BASE(15, 15, 4, 0x0c0, 0x10, 9, 3),
+	PIN_FIELD_BASE(16, 16, 4, 0x0c0, 0x10, 27, 3),
+	PIN_FIELD_BASE(17, 17, 4, 0x0c0, 0x10, 12, 3),
+	PIN_FIELD_BASE(29, 29, 2, 0x080, 0x10, 0, 3),
+	PIN_FIELD_BASE(30, 30, 2, 0x080, 0x10, 3, 3),
+	PIN_FIELD_BASE(34, 34, 1, 0x0e0, 0x10, 0, 3),
+	PIN_FIELD_BASE(35, 35, 1, 0x0e0, 0x10, 3, 3),
+	PIN_FIELD_BASE(44, 44, 1, 0x0e0, 0x10, 6, 3),
+	PIN_FIELD_BASE(45, 45, 1, 0x0e0, 0x10, 9, 3),
+};
+
 static const struct mtk_pin_reg_calc mt8195_reg_cals[PINCTRL_PIN_REG_MAX] = {
 	[PINCTRL_PIN_REG_MODE] = MTK_RANGE(mt8195_pin_mode_range),
 	[PINCTRL_PIN_REG_DIR] = MTK_RANGE(mt8195_pin_dir_range),
@@ -793,6 +812,7 @@ static const struct mtk_pin_reg_calc mt8195_reg_cals[PINCTRL_PIN_REG_MAX] = {
 	[PINCTRL_PIN_REG_R0] = MTK_RANGE(mt8195_pin_r0_range),
 	[PINCTRL_PIN_REG_R1] = MTK_RANGE(mt8195_pin_r1_range),
 	[PINCTRL_PIN_REG_DRV_ADV] = MTK_RANGE(mt8195_pin_drv_adv_range),
+	[PINCTRL_PIN_REG_RSEL] = MTK_RANGE(mt8195_pin_rsel_range),
 };
 
 static const char * const mt8195_pinctrl_register_base_names[] = {
@@ -823,6 +843,8 @@ static const struct mtk_pin_soc mt8195_data = {
 	.drive_get = mtk_pinconf_drive_get_rev1,
 	.adv_drive_get = mtk_pinconf_adv_drive_get_raw,
 	.adv_drive_set = mtk_pinconf_adv_drive_set_raw,
+	.rsel_set = mtk_pinconf_rsel_set,
+	.rsel_get = mtk_pinconf_rsel_get,
 };
 
 static const struct of_device_id mt8195_pinctrl_of_match[] = {
@@ -839,6 +861,7 @@ static struct platform_driver mt8195_pinctrl_driver = {
 	.driver = {
 		.name = "mt8195-pinctrl",
 		.of_match_table = mt8195_pinctrl_of_match,
+		.pm = &mtk_paris_pinctrl_pm_ops,
 	},
 	.probe = mt8195_pinctrl_probe,
 };
diff --git a/drivers/pinctrl/mediatek/pinctrl-mtk-common-v2.c b/drivers/pinctrl/mediatek/pinctrl-mtk-common-v2.c
index c81e5afe80a98ae825d4012f353dba110d6a0fe5..901a650d266b677e0d62f5b440dee24e33e5fc60 100644
--- a/drivers/pinctrl/mediatek/pinctrl-mtk-common-v2.c
+++ b/drivers/pinctrl/mediatek/pinctrl-mtk-common-v2.c
@@ -1039,6 +1039,20 @@ int mtk_pinconf_adv_drive_get_raw(struct mtk_pinctrl *hw,
 }
 EXPORT_SYMBOL_GPL(mtk_pinconf_adv_drive_get_raw);
 
+int mtk_pinconf_rsel_set(struct mtk_pinctrl *hw,
+			 const struct mtk_pin_desc *desc, u32 arg)
+{
+	return mtk_hw_set_value(hw, desc, PINCTRL_PIN_REG_RSEL, arg);
+}
+EXPORT_SYMBOL_GPL(mtk_pinconf_rsel_set);
+
+int mtk_pinconf_rsel_get(struct mtk_pinctrl *hw,
+			 const struct mtk_pin_desc *desc, u32 *val)
+{
+	return mtk_hw_get_value(hw, desc, PINCTRL_PIN_REG_RSEL, val);
+}
+EXPORT_SYMBOL_GPL(mtk_pinconf_rsel_get);
+
 MODULE_LICENSE("GPL v2");
 MODULE_AUTHOR("Sean Wang <sean.wang@mediatek.com>");
 MODULE_DESCRIPTION("Pin configuration library module for mediatek SoCs");
diff --git a/drivers/pinctrl/mediatek/pinctrl-mtk-common-v2.h b/drivers/pinctrl/mediatek/pinctrl-mtk-common-v2.h
index fd5ce9c5dcbdc6d9d61136720f7f2029c8a48a2b..44511fc4735900c7473d1523918347d244954af9 100644
--- a/drivers/pinctrl/mediatek/pinctrl-mtk-common-v2.h
+++ b/drivers/pinctrl/mediatek/pinctrl-mtk-common-v2.h
@@ -11,6 +11,8 @@
 
 #include <linux/gpio/driver.h>
 
+#define CONFIG_PINCTRL_MTK_DEBUG
+
 #define MTK_INPUT      0
 #define MTK_OUTPUT     1
 #define MTK_DISABLE    0
@@ -67,6 +69,7 @@ enum {
 	PINCTRL_PIN_REG_DRV_E0,
 	PINCTRL_PIN_REG_DRV_E1,
 	PINCTRL_PIN_REG_DRV_ADV,
+	PINCTRL_PIN_REG_RSEL,
 	PINCTRL_PIN_REG_MAX,
 };
 
@@ -237,6 +240,10 @@ struct mtk_pin_soc {
 			     const struct mtk_pin_desc *desc, u32 arg);
 	int (*adv_drive_get)(struct mtk_pinctrl *hw,
 			     const struct mtk_pin_desc *desc, u32 *val);
+	int (*rsel_set)(struct mtk_pinctrl *hw,
+			const struct mtk_pin_desc *desc, u32 arg);
+	int (*rsel_get)(struct mtk_pinctrl *hw,
+			const struct mtk_pin_desc *desc, u32 *val);
 
 	/* Specific driver data */
 	void				*driver_data;
@@ -252,6 +259,9 @@ struct mtk_pinctrl {
 	struct mtk_eint			*eint;
 	struct mtk_pinctrl_group	*groups;
 	const char          **grp_names;
+#if defined(CONFIG_PINCTRL_MTK_DEBUG)
+	u32 dbg_start;
+#endif
 };
 
 void mtk_rmw(struct mtk_pinctrl *pctl, u8 i, u32 reg, u32 mask, u32 set);
@@ -320,5 +330,10 @@ int mtk_pinconf_adv_drive_set_raw(struct mtk_pinctrl *hw,
 int mtk_pinconf_adv_drive_get_raw(struct mtk_pinctrl *hw,
 				  const struct mtk_pin_desc *desc, u32 *val);
 
+int mtk_pinconf_rsel_set(struct mtk_pinctrl *hw,
+			 const struct mtk_pin_desc *desc, u32 arg);
+int mtk_pinconf_rsel_get(struct mtk_pinctrl *hw,
+			 const struct mtk_pin_desc *desc, u32 *val);
+
 bool mtk_is_virt_gpio(struct mtk_pinctrl *hw, unsigned int gpio_n);
 #endif /* __PINCTRL_MTK_COMMON_V2_H */
diff --git a/drivers/pinctrl/mediatek/pinctrl-paris.c b/drivers/pinctrl/mediatek/pinctrl-paris.c
index da1f19288aa6d428d3e50261a70679db55aa434b..e7b4911d52b9ddb8dcf8f48b6f7208d2963616d4 100644
--- a/drivers/pinctrl/mediatek/pinctrl-paris.c
+++ b/drivers/pinctrl/mediatek/pinctrl-paris.c
@@ -22,6 +22,8 @@
 #define MTK_PIN_CONFIG_PU_ADV	(PIN_CONFIG_END + 3)
 #define MTK_PIN_CONFIG_PD_ADV	(PIN_CONFIG_END + 4)
 #define MTK_PIN_CONFIG_DRV_ADV	(PIN_CONFIG_END + 5)
+#define MTK_PIN_CONFIG_RSEL	(PIN_CONFIG_END + 6)
+
 
 static const struct pinconf_generic_params mtk_custom_bindings[] = {
 	{"mediatek,tdsel",	MTK_PIN_CONFIG_TDSEL,		0},
@@ -29,6 +31,7 @@ static const struct pinconf_generic_params mtk_custom_bindings[] = {
 	{"mediatek,pull-up-adv", MTK_PIN_CONFIG_PU_ADV,		1},
 	{"mediatek,pull-down-adv", MTK_PIN_CONFIG_PD_ADV,	1},
 	{"mediatek,drive-strength-adv", MTK_PIN_CONFIG_DRV_ADV,	2},
+	{"mediatek,rsel",		MTK_PIN_CONFIG_RSEL,	2},
 };
 
 #ifdef CONFIG_DEBUG_FS
@@ -38,6 +41,7 @@ static const struct pin_config_item mtk_conf_items[] = {
 	PCONFDUMP(MTK_PIN_CONFIG_PU_ADV, "pu-adv", NULL, true),
 	PCONFDUMP(MTK_PIN_CONFIG_PD_ADV, "pd-adv", NULL, true),
 	PCONFDUMP(MTK_PIN_CONFIG_DRV_ADV, "drive-strength-adv", NULL, true),
+	PCONFDUMP(MTK_PIN_CONFIG_RSEL, "rsel", NULL, true),
 };
 #endif
 
@@ -48,6 +52,7 @@ static const char * const mtk_gpio_functions[] = {
 	"func12", "func13", "func14", "func15",
 };
 
+
 static int mtk_pinmux_gpio_request_enable(struct pinctrl_dev *pctldev,
 					  struct pinctrl_gpio_range *range,
 					  unsigned int pin)
@@ -176,6 +181,12 @@ static int mtk_pinconf_get(struct pinctrl_dev *pctldev,
 		else
 			err = -ENOTSUPP;
 		break;
+	case MTK_PIN_CONFIG_RSEL:
+		if (hw->soc->rsel_get)
+			err = hw->soc->rsel_get(hw, desc, &ret);
+		else
+			err = -EOPNOTSUPP;
+		break;
 	default:
 		err = -ENOTSUPP;
 	}
@@ -295,6 +306,12 @@ static int mtk_pinconf_set(struct pinctrl_dev *pctldev, unsigned int pin,
 		else
 			err = -ENOTSUPP;
 		break;
+	case MTK_PIN_CONFIG_RSEL:
+		if (hw->soc->rsel_set)
+			err = hw->soc->rsel_set(hw, desc, arg);
+		else
+			err = -EOPNOTSUPP;
+		break;
 	default:
 		err = -ENOTSUPP;
 	}
@@ -935,6 +952,734 @@ static int mtk_pctrl_build_state(struct platform_device *pdev)
 	return 0;
 }
 
+#if defined(CONFIG_PINCTRL_MTK_DEBUG)
+#define MT8192 1
+#define MT8183 0
+static int mtk_gpio_get_out(struct gpio_chip *chip, unsigned int gpio)
+{
+	struct mtk_pinctrl *hw = gpiochip_get_data(chip);
+	const struct mtk_pin_desc *desc;
+	int value, err;
+
+	desc = (const struct mtk_pin_desc *)&hw->soc->pins[gpio];
+
+	err = mtk_hw_get_value(hw, desc, PINCTRL_PIN_REG_DO, &value);
+	if (err)
+		return err;
+
+	return !!value;
+}
+
+static int mtk_pullen_get(struct gpio_chip *chip, unsigned int gpio)
+{
+	struct mtk_pinctrl *hw = gpiochip_get_data(chip);
+	const struct mtk_pin_desc *desc;
+	int value, err;
+
+	desc = (const struct mtk_pin_desc *)&hw->soc->pins[gpio];
+
+	err = mtk_hw_get_value(hw, desc, PINCTRL_PIN_REG_PULLEN, &value);
+	if (err)
+		return err;
+
+	return !!value;
+}
+
+static int mtk_ies_get(struct gpio_chip *chip, unsigned int gpio)
+{
+	struct mtk_pinctrl *hw = gpiochip_get_data(chip);
+	const struct mtk_pin_desc *desc;
+	int value, err;
+
+	desc = (const struct mtk_pin_desc *)&hw->soc->pins[gpio];
+
+	err = mtk_hw_get_value(hw, desc, PINCTRL_PIN_REG_IES, &value);
+	if (err)
+		return err;
+
+	return !!value;
+}
+
+static int mtk_smt_get(struct gpio_chip *chip, unsigned int gpio)
+{
+	struct mtk_pinctrl *hw = gpiochip_get_data(chip);
+	const struct mtk_pin_desc *desc;
+	int value, err;
+
+	desc = (const struct mtk_pin_desc *)&hw->soc->pins[gpio];
+
+	err = mtk_hw_get_value(hw, desc, PINCTRL_PIN_REG_SMT, &value);
+	if (err)
+		return err;
+
+	return !!value;
+}
+
+static int mtk_driving_get(struct gpio_chip *chip, unsigned int gpio)
+{
+	struct mtk_pinctrl *hw = gpiochip_get_data(chip);
+	const struct mtk_pin_desc *desc;
+	int value, err;
+
+	desc = (const struct mtk_pin_desc *)&hw->soc->pins[gpio];
+
+	err = mtk_hw_get_value(hw, desc, PINCTRL_PIN_REG_DRV, &value);
+	if (err)
+		return err;
+
+	return value;
+}
+
+static int mtk_pinmux_get(struct gpio_chip *chip, unsigned int gpio)
+{
+	struct mtk_pinctrl *hw = gpiochip_get_data(chip);
+	const struct mtk_pin_desc *desc;
+	int value, err;
+
+	desc = (const struct mtk_pin_desc *)&hw->soc->pins[gpio];
+
+	err = mtk_hw_get_value(hw, desc, PINCTRL_PIN_REG_MODE, &value);
+	if (err)
+		return err;
+
+	return value;
+}
+
+static int mtk_pullsel_get(struct gpio_chip *chip, unsigned int gpio)
+{
+	struct mtk_pinctrl *hw = gpiochip_get_data(chip);
+	const struct mtk_pin_desc *desc;
+	int value, err;
+
+	desc = (const struct mtk_pin_desc *)&hw->soc->pins[gpio];
+
+	err = mtk_hw_get_value(hw, desc, PINCTRL_PIN_REG_PULLSEL, &value);
+	if (err)
+		return err;
+
+	return !!value;
+}
+
+static int mtk_pullup_get(struct gpio_chip *chip, unsigned int gpio)
+{
+	struct mtk_pinctrl *hw = gpiochip_get_data(chip);
+	const struct mtk_pin_desc *desc;
+	int value, err;
+
+	desc = (const struct mtk_pin_desc *)&hw->soc->pins[gpio];
+
+	err = mtk_hw_get_value(hw, desc, PINCTRL_PIN_REG_PU, &value);
+	if (err)
+		return err;
+
+	return !!value;
+}
+
+static int mtk_pulldown_get(struct gpio_chip *chip, unsigned int gpio)
+{
+	struct mtk_pinctrl *hw = gpiochip_get_data(chip);
+	const struct mtk_pin_desc *desc;
+	int value, err;
+
+	desc = (const struct mtk_pin_desc *)&hw->soc->pins[gpio];
+
+	err = mtk_hw_get_value(hw, desc, PINCTRL_PIN_REG_PD, &value);
+	if (err)
+		return err;
+
+	return !!value;
+}
+
+
+static int mtk_pupd_get(struct gpio_chip *chip, unsigned int gpio)
+{
+	struct mtk_pinctrl *hw = gpiochip_get_data(chip);
+	const struct mtk_pin_desc *desc;
+	int value, err;
+
+	desc = (const struct mtk_pin_desc *)&hw->soc->pins[gpio];
+
+	err = mtk_hw_get_value(hw, desc, PINCTRL_PIN_REG_PUPD, &value);
+	if (err)
+		return err;
+
+	return !!value;
+}
+
+static int mtk_r0_get(struct gpio_chip *chip, unsigned int gpio)
+{
+	struct mtk_pinctrl *hw = gpiochip_get_data(chip);
+	const struct mtk_pin_desc *desc;
+	int value, err;
+
+	desc = (const struct mtk_pin_desc *)&hw->soc->pins[gpio];
+
+	err = mtk_hw_get_value(hw, desc, PINCTRL_PIN_REG_R0, &value);
+	if (err)
+		return err;
+
+	return !!value;
+}
+
+static int mtk_r1_get(struct gpio_chip *chip, unsigned int gpio)
+{
+	struct mtk_pinctrl *hw = gpiochip_get_data(chip);
+	const struct mtk_pin_desc *desc;
+	int value, err;
+
+	desc = (const struct mtk_pin_desc *)&hw->soc->pins[gpio];
+
+	err = mtk_hw_get_value(hw, desc, PINCTRL_PIN_REG_R1, &value);
+	if (err)
+		return err;
+
+	return !!value;
+}
+
+static int mtk_i2c_r0_get(struct gpio_chip *chip, unsigned int gpio)
+{
+	struct mtk_pinctrl *hw = gpiochip_get_data(chip);
+	const struct mtk_pin_desc *desc;
+	int value, err;
+
+	desc = (const struct mtk_pin_desc *)&hw->soc->pins[gpio];
+
+	err = mtk_hw_get_value(hw, desc, PINCTRL_PIN_REG_R0, &value);
+	if (err)
+		return err;
+
+	return !!value;
+}
+
+static int mtk_i2c_r1_get(struct gpio_chip *chip, unsigned int gpio)
+{
+	struct mtk_pinctrl *hw = gpiochip_get_data(chip);
+	const struct mtk_pin_desc *desc;
+	int value, err;
+
+	desc = (const struct mtk_pin_desc *)&hw->soc->pins[gpio];
+
+	err = mtk_hw_get_value(hw, desc, PINCTRL_PIN_REG_R1, &value);
+	if (err)
+		return err;
+
+	return !!value;
+}
+
+static int mtk_i2c_drv_e0_get(struct gpio_chip *chip, unsigned int gpio)
+{
+	struct mtk_pinctrl *hw = gpiochip_get_data(chip);
+	const struct mtk_pin_desc *desc;
+	int value, err;
+
+	desc = (const struct mtk_pin_desc *)&hw->soc->pins[gpio];
+
+	err = mtk_hw_get_value(hw, desc, PINCTRL_PIN_REG_DRV_E0, &value);
+	if (err)
+		return err;
+
+	return !!value;
+}
+
+static int mtk_i2c_drv_e1_get(struct gpio_chip *chip, unsigned int gpio)
+{
+	struct mtk_pinctrl *hw = gpiochip_get_data(chip);
+	const struct mtk_pin_desc *desc;
+	int value, err;
+
+	desc = (const struct mtk_pin_desc *)&hw->soc->pins[gpio];
+
+	err = mtk_hw_get_value(hw, desc, PINCTRL_PIN_REG_DRV_E1, &value);
+	if (err)
+		return err;
+
+	return !!value;
+}
+
+static int mtk_i2c_drv_en_dis_get(struct gpio_chip *chip, unsigned int gpio)
+{
+	struct mtk_pinctrl *hw = gpiochip_get_data(chip);
+	const struct mtk_pin_desc *desc;
+	int value, err;
+
+	desc = (const struct mtk_pin_desc *)&hw->soc->pins[gpio];
+
+	err = mtk_hw_get_value(hw, desc, PINCTRL_PIN_REG_DRV_EN, &value);
+	if (err)
+		return err;
+
+	return !!value;
+}
+
+static ssize_t mtk_gpio_show_pin(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	int len = 0;
+	int bufLen = (int)PAGE_SIZE;
+	struct mtk_pinctrl *hw = dev_get_drvdata(dev);
+	struct gpio_chip *chip = &(hw->chip);
+	unsigned int i;
+	int pull_sel, pull_en, pull_up, pull_down;
+
+	len += snprintf(buf+len, bufLen-len,
+			"regmap[index]:[base register]\n");
+
+	len += snprintf(buf+len, bufLen-len, "[%d]:[%x]\n", 0, 0x10005000);
+	len += snprintf(buf+len, bufLen-len, "[%d]:[%x]\n", 1, 0x11f20000);
+	len += snprintf(buf+len, bufLen-len, "[%d]:[%x]\n", 2, 0x11e80000);
+	len += snprintf(buf+len, bufLen-len, "[%d]:[%x]\n", 3, 0x11e70000);
+	len += snprintf(buf+len, bufLen-len, "[%d]:[%x]\n", 4, 0x11e90000);
+	len += snprintf(buf+len, bufLen-len, "[%d]:[%x]\n", 5, 0x11d30000);
+	len += snprintf(buf+len, bufLen-len, "[%d]:[%x]\n", 6, 0x11d20000);
+	len += snprintf(buf+len, bufLen-len, "[%d]:[%x]\n", 7, 0x11c50000);
+	len += snprintf(buf+len, bufLen-len, "[%d]:[%x]\n", 8, 0x11f30000);
+
+	len += snprintf(buf+len, bufLen-len,
+		"sample cmd: echo wr index offset val > mt_gpio .\n");
+	len += snprintf(buf+len, bufLen-len,
+		"sample cmd: echo rr index offset > mt_gpio .\n");
+
+
+	len += snprintf(buf+len, bufLen-len,
+		"gpio base is %d, total num is %d\n",
+		chip->base, chip->ngpio);
+
+	len += snprintf(buf+len, bufLen-len,
+		"PIN: [MODE] [DIR] [DOUT] [DIN] [PULL_EN] [PULL_SEL] [PULL_UP] [PULL_DOWN] [IES] [SMT] [DRIVE] ( [PUPD] [R1] [R0] ) ([E1] [E0] [EN])\n");
+
+	if (hw->dbg_start >= chip->ngpio) {
+		len += snprintf(buf+len, bufLen-len,
+		"wrong gpio-range: start should less than %d!\n",
+		chip->ngpio);
+		return len;
+	}
+
+	for (i = hw->dbg_start; i < chip->ngpio; i++) {
+		pull_sel = mtk_pullsel_get(chip, i);
+		pull_en = mtk_pullen_get(chip, i);
+		pull_up = mtk_pullup_get(chip, i);
+		pull_down = mtk_pulldown_get(chip, i);
+		if ((len+32) >= bufLen)
+			break;
+
+		len += snprintf(buf+len, bufLen-len,
+				"%4d:% d% d% d% d% d% d% d% d% d",
+				i,
+				mtk_pinmux_get(chip, i),
+				!mtk_gpio_get_direction(chip, i),
+				mtk_gpio_get_out(chip, i),
+				mtk_gpio_get(chip, i),
+#if MT8183
+				(pull_en >= 0) ? (pull_en & 1) : -1,
+				(pull_sel >= 0) ? (pull_sel & 1) : -1,
+#elif MT8192
+				(pull_up >= 0) ? (pull_up & 1) : -1,
+				(pull_down >= 0) ? (pull_down & 1) : -1,
+#endif
+				mtk_ies_get(chip, i),
+				mtk_smt_get(chip, i),
+				mtk_driving_get(chip, i));
+		if (((pull_sel & 8) != 0) && (pull_sel >= 0))
+			len += snprintf(buf+len, bufLen-len, " %d %d",
+					!!(pull_sel & 4), !!(pull_sel & 2));
+		if (pull_sel < 0)
+			len += snprintf(buf+len, bufLen-len, "(%d %d %d)",
+				(mtk_pupd_get(chip, i) >= 0)? (mtk_pupd_get(chip, i) & 1) : -1,
+				(mtk_r1_get(chip, i) >= 0)? (mtk_r1_get(chip, i) & 1) : -1,
+				(mtk_r0_get(chip, i) >= 0)? (mtk_r0_get(chip, i) & 1) : -1);
+#if MT8183
+		if (((i >= 48) && (i <= 51)) || ((i >= 81) && (i <= 84))
+			|| ((i >= 103) && (i <= 106))) {
+			len += snprintf(buf+len, bufLen-len, "(%d %d %d)",
+				-1, mtk_i2c_r1_get(chip, i),
+				mtk_i2c_r0_get(chip, i));
+			len += snprintf(buf+len, bufLen-len, "(%d %d %d)",
+				mtk_i2c_drv_e1_get(chip, i),
+				mtk_i2c_drv_e0_get(chip, i),
+				mtk_i2c_drv_en_dis_get(chip, i));
+		}
+#elif MT8192
+		if (((i >= 118) && (i <= 125)) || ((i >= 139) && (i <= 142))
+			|| ((i >= 160) && (i <= 161)) || ((i >= 200) && (i <= 205))) {
+			len += snprintf(buf+len, bufLen-len, "(%d %d %d)",
+				-1, mtk_i2c_r1_get(chip, i),
+				mtk_i2c_r0_get(chip, i));
+			len += snprintf(buf+len, bufLen-len, "(%d %d %d)",
+				mtk_i2c_drv_e1_get(chip, i),
+				mtk_i2c_drv_e0_get(chip, i),
+				mtk_i2c_drv_en_dis_get(chip, i));
+		}
+#endif
+		len += snprintf(buf+len, bufLen-len, "\n");
+	}
+
+	return len;
+}
+
+static int mtk_mode_set(struct gpio_chip *chip, unsigned int gpio,
+	unsigned int value)
+{
+	struct mtk_pinctrl *hw = gpiochip_get_data(chip);
+	const struct mtk_pin_desc *desc;
+	int err;
+
+	desc = (const struct mtk_pin_desc *)&hw->soc->pins[gpio];
+
+	err = mtk_hw_set_value(hw, desc, PINCTRL_PIN_REG_MODE, value);
+	if (err)
+		return err;
+
+	return 0;
+}
+
+static int mtk_ies_set(struct gpio_chip *chip, unsigned int gpio,
+	unsigned int value)
+{
+	struct mtk_pinctrl *hw = gpiochip_get_data(chip);
+	const struct mtk_pin_desc *desc;
+	int err;
+
+	desc = (const struct mtk_pin_desc *)&hw->soc->pins[gpio];
+
+	err = mtk_hw_set_value(hw, desc, PINCTRL_PIN_REG_IES, value);
+	if (err)
+		return err;
+
+	return 0;
+}
+
+static int mtk_smt_set(struct gpio_chip *chip, unsigned int gpio,
+	unsigned int value)
+{
+	struct mtk_pinctrl *hw = gpiochip_get_data(chip);
+	const struct mtk_pin_desc *desc;
+	int err;
+
+	desc = (const struct mtk_pin_desc *)&hw->soc->pins[gpio];
+
+	err = mtk_hw_set_value(hw, desc, PINCTRL_PIN_REG_SMT, value);
+	if (err)
+		return err;
+
+	return 0;
+}
+
+static int mtk_pullen_set(struct gpio_chip *chip, unsigned int gpio,
+	unsigned int value)
+{
+	struct mtk_pinctrl *hw = gpiochip_get_data(chip);
+	const struct mtk_pin_desc *desc;
+	int err;
+
+	desc = (const struct mtk_pin_desc *)&hw->soc->pins[gpio];
+
+	err = mtk_hw_set_value(hw, desc, PINCTRL_PIN_REG_PULLEN, value);
+	if (err)
+		return err;
+
+	return 0;
+}
+
+static int mtk_pullsel_set(struct gpio_chip *chip, unsigned int gpio,
+	unsigned int value)
+{
+	struct mtk_pinctrl *hw = gpiochip_get_data(chip);
+	const struct mtk_pin_desc *desc;
+	int err;
+
+	desc = (const struct mtk_pin_desc *)&hw->soc->pins[gpio];
+
+	err = mtk_hw_set_value(hw, desc, PINCTRL_PIN_REG_PULLSEL, value);
+	if (err)
+		return err;
+
+	return 0;
+}
+
+static int mtk_pullup_set(struct gpio_chip *chip, unsigned int gpio,
+	unsigned int value)
+{
+	struct mtk_pinctrl *hw = gpiochip_get_data(chip);
+	const struct mtk_pin_desc *desc;
+	int err;
+
+	desc = (const struct mtk_pin_desc *)&hw->soc->pins[gpio];
+
+	err = mtk_hw_set_value(hw, desc, PINCTRL_PIN_REG_PU, value);
+	if (err)
+		return err;
+
+	return 0;
+}
+
+static int mtk_pulldown_set(struct gpio_chip *chip, unsigned int gpio,
+	unsigned int value)
+{
+	struct mtk_pinctrl *hw = gpiochip_get_data(chip);
+	const struct mtk_pin_desc *desc;
+	int err;
+
+	desc = (const struct mtk_pin_desc *)&hw->soc->pins[gpio];
+
+	err = mtk_hw_set_value(hw, desc, PINCTRL_PIN_REG_PD, value);
+	if (err)
+		return err;
+
+	return 0;
+}
+
+static int mtk_drv_set(struct gpio_chip *chip, unsigned int gpio,
+	unsigned int value)
+{
+	struct mtk_pinctrl *hw = gpiochip_get_data(chip);
+	const struct mtk_pin_desc *desc;
+	int err;
+
+	desc = (const struct mtk_pin_desc *)&hw->soc->pins[gpio];
+
+	err = mtk_hw_set_value(hw, desc, PINCTRL_PIN_REG_DRV, value);
+	if (err)
+		return err;
+
+	return 0;
+}
+
+static int mtk_pupd_set(struct gpio_chip *chip, unsigned int gpio,
+	unsigned int pupd, unsigned int r1, unsigned int r0)
+{
+	struct mtk_pinctrl *hw = gpiochip_get_data(chip);
+	const struct mtk_pin_desc *desc;
+	int err;
+
+	desc = (const struct mtk_pin_desc *)&hw->soc->pins[gpio];
+
+	err = mtk_hw_set_value(hw, desc, PINCTRL_PIN_REG_R1, r1);
+	if (err)
+		return err;
+
+	err = mtk_hw_set_value(hw, desc, PINCTRL_PIN_REG_R0, r0);
+	if (err)
+		return err;
+
+	err = mtk_hw_set_value(hw, desc, PINCTRL_PIN_REG_PUPD, pupd);
+	if (err)
+		return err;
+
+	return 0;
+}
+
+static int mtk_drv_adv_set(struct gpio_chip *chip, unsigned int gpio,
+	unsigned int en, unsigned int e1, unsigned int e0)
+{
+	struct mtk_pinctrl *hw = gpiochip_get_data(chip);
+	const struct mtk_pin_desc *desc;
+	int err;
+
+	desc = (const struct mtk_pin_desc *)&hw->soc->pins[gpio];
+
+	err = mtk_hw_set_value(hw, desc, PINCTRL_PIN_REG_DRV_EN, en);
+	if (err)
+		return err;
+
+	err = mtk_hw_set_value(hw, desc, PINCTRL_PIN_REG_DRV_E1, e1);
+	if (err)
+		return err;
+
+	err = mtk_hw_set_value(hw, desc, PINCTRL_PIN_REG_DRV_E0, e0);
+	if (err)
+		return err;
+
+	return 0;
+}
+
+static ssize_t mtk_gpio_store_pin(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	u32 index, offset, old_val, val, new_val, pin, pupd, r1, r0, en, e1, e0;
+	int val_set;
+
+	struct mtk_pinctrl *hw = dev_get_drvdata(dev);
+	struct pinctrl_dev *pctldev = hw->pctrl;
+	struct gpio_chip *chip = &(hw->chip);
+
+	if ((strncmp(buf, "wr", 2) == 0)
+	    && (sscanf(buf+2, "%d %x %x", &index, &offset, &val) == 3)) {
+		if ((index == 0) && (offset > 0xf60)) {
+			pr_err("index(%d),offset(0x%x) invalid.\n",
+				index, offset);
+			goto err_return;
+		} else if ((index == 1) && (offset > 0xf0)) {
+			pr_err("index(%d),offset(0x%x) invalid.\n",
+				index, offset);
+			goto err_return;
+		} else if ((index == 2) && (offset > 0xf0)) {
+			pr_err("index(%d),offset(0x%x) invalid.\n",
+				index, offset);
+			goto err_return;
+		} else if ((index == 3) && (offset > 0xf0)) {
+			pr_err("index(%d),offset(0x%x) invalid.\n",
+				index, offset);
+			goto err_return;
+		} else if ((index == 4) && (offset > 0xf0)) {
+			pr_err("index(%d),offset(0x%x) invalid.\n",
+				index, offset);
+			goto err_return;
+		} else if ((index == 5) && (offset > 0xf0)) {
+			pr_err("index(%d),offset(0x%x) invalid.\n",
+				index, offset);
+			goto err_return;
+		} else if ((index == 6) && (offset > 0xf0)) {
+			pr_err("index(%d),offset(0x%x) invalid.\n",
+				index, offset);
+			goto err_return;
+		} else if ((index == 7) && (offset > 0xf0)) {
+			pr_err("index(%d),offset(0x%x) invalid.\n",
+				index, offset);
+			goto err_return;
+		} else if ((index == 8) && (offset > 0xf0)) {
+			pr_err("index(%d),offset(0x%x) invalid.\n",
+				index, offset);
+			goto err_return;
+		} else if ((index == 9) && (offset > 0xf0)) {
+			pr_err("index(%d),offset(0x%x) invalid.\n",
+				index, offset);
+			goto err_return;
+		} else if ((index == 10) && (offset > 0xf0)) {
+			pr_err("index(%d),offset(0x%x) invalid.\n",
+				index, offset);
+			goto err_return;
+		}
+
+		old_val = readl_relaxed(hw->base[index] + offset);
+		writel_relaxed(val, hw->base[index] + offset);
+		new_val = readl_relaxed(hw->base[index] + offset);
+		pr_err("old_val(0x%x)->new_val(0x%x).\n", old_val, new_val);
+	} else if ((strncmp(buf, "rr", 2) == 0)
+	    && (sscanf(buf+2, "%d %x", &index, &offset) == 2)) {
+		if ((index == 0) && (offset > 0xf60)) {
+			pr_err("index(%d),offset(0x%x) invalid.\n",
+				index, offset);
+			goto err_return;
+		} else if ((index == 1) && (offset > 0xf0)) {
+			pr_err("index(%d),offset(0x%x) invalid.\n",
+				index, offset);
+			goto err_return;
+		} else if ((index == 2) && (offset > 0xf0)) {
+			pr_err("index(%d),offset(0x%x) invalid.\n",
+				index, offset);
+			goto err_return;
+		} else if ((index == 3) && (offset > 0xf0)) {
+			pr_err("index(%d),offset(0x%x) invalid.\n",
+				index, offset);
+			goto err_return;
+		} else if ((index == 4) && (offset > 0xf0)) {
+			pr_err("index(%d),offset(0x%x) invalid.\n",
+				index, offset);
+			goto err_return;
+		} else if ((index == 5) && (offset > 0xf0)) {
+			pr_err("index(%d),offset(0x%x) invalid.\n",
+				index, offset);
+			goto err_return;
+		} else if ((index == 6) && (offset > 0xf0)) {
+			pr_err("index(%d),offset(0x%x) invalid.\n",
+				index, offset);
+			goto err_return;
+		} else if ((index == 7) && (offset > 0xf0)) {
+			pr_err("index(%d),offset(0x%x) invalid.\n",
+				index, offset);
+			goto err_return;
+		} else if ((index == 8) && (offset > 0xf0)) {
+			pr_err("index(%d),offset(0x%x) invalid.\n",
+				index, offset);
+			goto err_return;
+		} else if ((index == 9) && (offset > 0xf0)) {
+			pr_err("index(%d),offset(0x%x) invalid.\n",
+				index, offset);
+			goto err_return;
+		} else if ((index == 10) && (offset > 0xf0)) {
+			pr_err("index(%d),offset(0x%x) invalid.\n",
+				index, offset);
+			goto err_return;
+		}
+		val = readl_relaxed(hw->base[index] + offset);
+		pr_err("regmap[%d]+offset(%x)=0x%x.\n", index, offset, val);
+	} else if ((strncmp(buf, "mode", 4) == 0)
+	    && (sscanf(buf+4, "%d %d", &pin, &val) == 2)) {
+		val_set = mtk_mode_set(chip, pin, val);
+	} else if ((strncmp(buf, "dir", 3) == 0)
+		   && (sscanf(buf+3, "%d %d", &pin, &val) == 2)) {
+		val_set  = mtk_pinmux_gpio_set_direction(pctldev,
+			NULL, pin, !(bool)val);
+	} else if ((strncmp(buf, "out", 3) == 0)
+		   && (sscanf(buf+3, "%d %d", &pin, &val) == 2)) {
+		val_set  = mtk_pinmux_gpio_set_direction(pctldev,
+			NULL, pin, false);
+		mtk_gpio_set(chip, pin, val);
+	} else if ((strncmp(buf, "pullen", 6) == 0)
+		   && (sscanf(buf+6, "%d %d", &pin, &val) == 2)) {
+		val_set = mtk_pullen_set(chip, pin, val);
+	} else if ((strncmp(buf, "pullsel", 7) == 0)
+		   && (sscanf(buf+7, "%d %d", &pin, &val) == 2)) {
+		val_set = mtk_pullsel_set(chip, pin, val);
+	} else if ((strncmp(buf, "pullup", 6) == 0)
+		   && (sscanf(buf+6, "%d %d", &pin, &val) == 2)) {
+		val_set = mtk_pullup_set(chip, pin, val);
+	} else if ((strncmp(buf, "pulldn", 6) == 0)
+		   && (sscanf(buf+6, "%d %d", &pin, &val) == 2)) {
+		val_set = mtk_pulldown_set(chip, pin, val);
+	} else if ((strncmp(buf, "ies", 3) == 0)
+		   && (sscanf(buf+3, "%d %d", &pin, &val) == 2)) {
+		val_set = mtk_ies_set(chip, pin, val);
+	} else if ((strncmp(buf, "smt", 3) == 0)
+		   && (sscanf(buf+3, "%d %d", &pin, &val) == 2)) {
+		val_set = mtk_smt_set(chip, pin, val);
+	} else if ((strncmp(buf, "drv", 3) == 0)
+		   && (sscanf(buf+3, "%d %d", &pin, &val) == 2)) {
+		val_set = mtk_drv_set(chip, pin, val);
+	} else if ((strncmp(buf, "pupd", 4) == 0)
+		   && (sscanf(buf+4, "%d %d %d %d", &pin, &pupd, &r1, &r0) == 4)) {
+		val_set = mtk_pupd_set(chip, pin, pupd, r1, r0);
+	} else if ((strncmp(buf, "drv_adv", 7) == 0)
+		   && (sscanf(buf+7, "%d %d %d %d", &pin, &en, &e1, &e0) == 4)) {
+		val_set = mtk_drv_adv_set(chip, pin, en, e1, e0);
+	} else if ((strncmp(buf, "start", 5) == 0)
+		   && (sscanf(buf+5, "%d", &val) == 1)) {
+		hw->dbg_start = (u32)val;
+	} else {
+	}
+
+	return (ssize_t)count;
+
+err_return:
+
+	return (ssize_t)0;
+}
+
+static DEVICE_ATTR(mt_gpio, 0664, mtk_gpio_show_pin, mtk_gpio_store_pin);
+
+static struct device_attribute *gpio_attr_list[] = {
+	&dev_attr_mt_gpio,
+};
+
+static int mtk_gpio_create_attr(struct device *dev)
+{
+	int idx, err = 0;
+	int num = (int)ARRAY_SIZE(gpio_attr_list);
+
+	if (dev == NULL)
+		return -EINVAL;
+
+	for (idx = 0; idx < num; idx++) {
+		err = device_create_file(dev, gpio_attr_list[idx]);
+		if (err > 0)
+			break;
+	}
+
+	return err;
+}
+
+#endif
+
 int mtk_paris_pinctrl_probe(struct platform_device *pdev,
 			    const struct mtk_pin_soc *soc)
 {
@@ -1019,6 +1764,12 @@ int mtk_paris_pinctrl_probe(struct platform_device *pdev,
 
 	platform_set_drvdata(pdev, hw);
 
+#if defined(CONFIG_PINCTRL_MTK_DEBUG)
+		err = mtk_gpio_create_attr(&pdev->dev);
+		if (err < 0)
+			pr_warn("mtk_gpio create attribute error\n");
+#endif
+
 	return 0;
 }
 EXPORT_SYMBOL_GPL(mtk_paris_pinctrl_probe);
diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 0db7490d4d00f020909d38b473d0670fa47f43ba..eeb046503d79b1d3ab81261b4d02a6586a67784a 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -2714,6 +2714,9 @@ int regulator_enable(struct regulator *regulator)
 	ret = _regulator_enable(regulator);
 	regulator_unlock_dependent(rdev, &ww_ctx);
 
+  if (ret < 0)
+    dump_stack();
+
 	return ret;
 }
 EXPORT_SYMBOL_GPL(regulator_enable);
diff --git a/drivers/regulator/helpers.c b/drivers/regulator/helpers.c
index e4bb09bbd3fa6e63d78ba8ab68c2c63d6ac2c25b..6038d3f952a8193bcdd9b21ef6d9ea7fa9f59d18 100644
--- a/drivers/regulator/helpers.c
+++ b/drivers/regulator/helpers.c
@@ -59,6 +59,7 @@ EXPORT_SYMBOL_GPL(regulator_is_enabled_regmap);
 int regulator_enable_regmap(struct regulator_dev *rdev)
 {
 	unsigned int val;
+	int ret;
 
 	if (rdev->desc->enable_is_inverted) {
 		val = rdev->desc->disable_val;
@@ -68,8 +69,12 @@ int regulator_enable_regmap(struct regulator_dev *rdev)
 			val = rdev->desc->enable_mask;
 	}
 
-	return regmap_update_bits(rdev->regmap, rdev->desc->enable_reg,
+	ret = regmap_update_bits(rdev->regmap, rdev->desc->enable_reg,
 				  rdev->desc->enable_mask, val);
+  if (ret < 0)
+    dump_stack();
+
+  return ret;
 }
 EXPORT_SYMBOL_GPL(regulator_enable_regmap);
 
diff --git a/drivers/remoteproc/mtk_common.h b/drivers/remoteproc/mtk_common.h
index 61901f5efa051e7d2875b9abe36b67a3a48afce1..5ff3867c72f373c37aa5d28156fbeb67fbbe71d4 100644
--- a/drivers/remoteproc/mtk_common.h
+++ b/drivers/remoteproc/mtk_common.h
@@ -72,6 +72,7 @@ struct scp_ipi_desc {
 struct mtk_scp;
 
 struct mtk_scp_of_data {
+	int (*scp_clk_get)(struct mtk_scp *scp);
 	int (*scp_before_load)(struct mtk_scp *scp);
 	void (*scp_irq_handler)(struct mtk_scp *scp);
 	void (*scp_reset_assert)(struct mtk_scp *scp);
diff --git a/drivers/remoteproc/mtk_scp.c b/drivers/remoteproc/mtk_scp.c
index 9679cc26895e578b0eb0fa604acba40db71f3eeb..36e48cf58ed63a72d4f660144456a0e566c488e0 100644
--- a/drivers/remoteproc/mtk_scp.c
+++ b/drivers/remoteproc/mtk_scp.c
@@ -312,6 +312,32 @@ static int scp_elf_read_ipi_buf_addr(struct mtk_scp *scp,
 	return -ENOENT;
 }
 
+static int mt8183_scp_clk_get(struct mtk_scp *scp)
+{
+	struct device *dev = scp->dev;
+	int ret = 0;
+
+	scp->clk = devm_clk_get(dev, "main");
+	if (IS_ERR(scp->clk)) {
+		dev_err(dev, "Failed to get clock\n");
+		ret = PTR_ERR(scp->clk);
+	}
+
+	return ret;
+}
+
+static int mt8192_scp_clk_get(struct mtk_scp *scp)
+{
+	return mt8183_scp_clk_get(scp);
+}
+
+static int mt8195_scp_clk_get(struct mtk_scp *scp)
+{
+	scp->clk = NULL;
+
+	return 0;
+}
+
 static int mt8183_scp_before_load(struct mtk_scp *scp)
 {
 	/* Clear SCP to host interrupt */
@@ -785,12 +811,9 @@ static int scp_probe(struct platform_device *pdev)
 	if (ret)
 		goto destroy_mutex;
 
-	scp->clk = devm_clk_get(dev, "main");
-	if (IS_ERR(scp->clk)) {
-		dev_err(dev, "Failed to get clock\n");
-		ret = PTR_ERR(scp->clk);
+	ret = scp->data->scp_clk_get(scp);
+	if (ret)
 		goto release_dev_mem;
-	}
 
 	/* register SCP initialization IPI */
 	ret = scp_ipi_register(scp, SCP_IPI_INIT, scp_init_ipi_handler, scp);
@@ -852,6 +875,7 @@ static int scp_remove(struct platform_device *pdev)
 }
 
 static const struct mtk_scp_of_data mt8183_of_data = {
+	.scp_clk_get = mt8183_scp_clk_get,
 	.scp_before_load = mt8183_scp_before_load,
 	.scp_irq_handler = mt8183_scp_irq_handler,
 	.scp_reset_assert = mt8183_scp_reset_assert,
@@ -864,6 +888,19 @@ static const struct mtk_scp_of_data mt8183_of_data = {
 };
 
 static const struct mtk_scp_of_data mt8192_of_data = {
+	.scp_clk_get = mt8192_scp_clk_get,
+	.scp_before_load = mt8192_scp_before_load,
+	.scp_irq_handler = mt8192_scp_irq_handler,
+	.scp_reset_assert = mt8192_scp_reset_assert,
+	.scp_reset_deassert = mt8192_scp_reset_deassert,
+	.scp_stop = mt8192_scp_stop,
+	.scp_da_to_va = mt8192_scp_da_to_va,
+	.host_to_scp_reg = MT8192_GIPC_IN_SET,
+	.host_to_scp_int_bit = MT8192_HOST_IPC_INT_BIT,
+};
+
+static const struct mtk_scp_of_data mt8195_of_data = {
+	.scp_clk_get = mt8195_scp_clk_get,
 	.scp_before_load = mt8192_scp_before_load,
 	.scp_irq_handler = mt8192_scp_irq_handler,
 	.scp_reset_assert = mt8192_scp_reset_assert,
@@ -877,6 +914,7 @@ static const struct mtk_scp_of_data mt8192_of_data = {
 static const struct of_device_id mtk_scp_of_match[] = {
 	{ .compatible = "mediatek,mt8183-scp", .data = &mt8183_of_data },
 	{ .compatible = "mediatek,mt8192-scp", .data = &mt8192_of_data },
+	{ .compatible = "mediatek,mt8195-scp", .data = &mt8195_of_data },
 	{},
 };
 MODULE_DEVICE_TABLE(of, mtk_scp_of_match);
diff --git a/drivers/remoteproc/mtk_scp_ipi.c b/drivers/remoteproc/mtk_scp_ipi.c
index 6dc955ecab80f98c319bf67b500bdf32399f2209..8236802ea5b8dba6e5dba43a0a576baf2456522e 100644
--- a/drivers/remoteproc/mtk_scp_ipi.c
+++ b/drivers/remoteproc/mtk_scp_ipi.c
@@ -169,7 +169,8 @@ int scp_ipi_send(struct mtk_scp *scp, u32 id, void *buf, unsigned int len,
 	ret = clk_prepare_enable(scp->clk);
 	if (ret) {
 		dev_err(scp->dev, "failed to enable clock\n");
-		goto unlock_mutex;
+		mutex_unlock(&scp->send_lock);
+		return -EINVAL;
 	}
 
 	 /* Wait until SCP receives the last command */
@@ -191,6 +192,7 @@ int scp_ipi_send(struct mtk_scp *scp, u32 id, void *buf, unsigned int len,
 	/* send the command to SCP */
 	writel(scp->data->host_to_scp_int_bit,
 	       scp->reg_base + scp->data->host_to_scp_reg);
+	mutex_unlock(&scp->send_lock);
 
 	if (wait) {
 		/* wait for SCP's ACK */
@@ -207,8 +209,6 @@ int scp_ipi_send(struct mtk_scp *scp, u32 id, void *buf, unsigned int len,
 
 clock_disable:
 	clk_disable_unprepare(scp->clk);
-unlock_mutex:
-	mutex_unlock(&scp->send_lock);
 
 	return ret;
 }
diff --git a/drivers/soc/mediatek/Kconfig b/drivers/soc/mediatek/Kconfig
index d3902daa24fb3ea33342ff40767ce2c1e0149392..8964da28c6823dc03d554a78af49671db1b300e1 100644
--- a/drivers/soc/mediatek/Kconfig
+++ b/drivers/soc/mediatek/Kconfig
@@ -72,5 +72,11 @@ config MTK_SVS
 	  voltage to different power domains(CPU/GPU/CCI) according to
 	  chip process corner, temperatures and other factors. Then DVFS
 	  driver could apply SVS bank voltage to PMIC/Buck.
+	  
+	  
+source "drivers/soc/mediatek/dfd/Kconfig"
+source "drivers/soc/mediatek/dbgtop/Kconfig"
 
 endmenu
+
+
diff --git a/drivers/soc/mediatek/Makefile b/drivers/soc/mediatek/Makefile
index d96ed1b41c35525d2e273c1ee1588e6f058412cf..29aaa16fce15b734348bff524225ce227a758026 100644
--- a/drivers/soc/mediatek/Makefile
+++ b/drivers/soc/mediatek/Makefile
@@ -7,3 +7,5 @@ obj-$(CONFIG_MTK_SCPSYS_PM_DOMAINS) += mtk-pm-domains.o
 obj-$(CONFIG_MTK_MMSYS) += mtk-mmsys.o
 obj-$(CONFIG_MTK_MMSYS) += mtk-mutex.o
 obj-$(CONFIG_MTK_SVS) += mtk-svs.o
+obj-$(CONFIG_MTK_DFD) += dfd/
+obj-$(CONFIG_MTK_DBGTOP) += dbgtop/
diff --git a/drivers/soc/mediatek/dbgtop/Kconfig b/drivers/soc/mediatek/dbgtop/Kconfig
new file mode 100644
index 0000000000000000000000000000000000000000..e482a93a55c2f01d1e8bb8db4c5d444221873e12
--- /dev/null
+++ b/drivers/soc/mediatek/dbgtop/Kconfig
@@ -0,0 +1,15 @@
+config MTK_DBGTOP
+	bool "MTK DBGTOP driver"
+	help
+	  This config enable/disable the dbgtop module,
+	  which controls the reset flow of debugging
+	  features, including DDR reserve mode, DFD,
+	  and data latch.
+
+config MTK_PLATFORM
+        string "Platform name"
+        default "devicetree"
+        help
+          Enter the name of the desired platform configuration directory to
+          include in the build.
+
diff --git a/drivers/soc/mediatek/dbgtop/Makefile b/drivers/soc/mediatek/dbgtop/Makefile
new file mode 100644
index 0000000000000000000000000000000000000000..d626cb1500bb2e1bd2e5ee440f87c2d6b4821778
--- /dev/null
+++ b/drivers/soc/mediatek/dbgtop/Makefile
@@ -0,0 +1,16 @@
+#
+# Copyright (C) 2019 MediaTek Inc.
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU General Public License version 2 as
+# published by the Free Software Foundation.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+# GNU General Public License for more details.
+#
+
+ccflags-y += -I$(srctree)/drivers/soc/mediatek/dbgtop/mt8195
+
+obj-$(CONFIG_MTK_DBGTOP) += dbgtop.o
diff --git a/drivers/soc/mediatek/dbgtop/dbgtop.c b/drivers/soc/mediatek/dbgtop/dbgtop.c
new file mode 100644
index 0000000000000000000000000000000000000000..97ff1c35d61674d68f1ce0794d6f49e6e0b750fb
--- /dev/null
+++ b/drivers/soc/mediatek/dbgtop/dbgtop.c
@@ -0,0 +1,476 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2019 MediaTek Inc.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <linux/of.h>
+#include <linux/of_irq.h>
+#include <linux/of_address.h>
+#include <linux/printk.h>
+#include <linux/delay.h>
+#include <linux/io.h>
+#include <sync_write.h>
+#include <mtk_dbgtop.h>
+#include <dbgtop.h>
+#if MTK_DBGTOP_TEST
+#include <mt-plat/mtk_wd_api.h>
+#endif
+
+/* only for arm64 */
+#ifdef CONFIG_ARM64
+#define IOMEM(a)  ((void __force __iomem *)((a)))
+#endif
+
+static void __iomem *DBGTOP_BASE;
+static unsigned int dfd_timeout;
+
+static int mtk_dbgtop_probe(struct platform_device *pdev);
+
+static int mtk_dbgtop_remove(struct platform_device *dev)
+{
+	return 0;
+}
+
+#ifdef CONFIG_OF
+static const struct of_device_id mtk_dbgtop_of_ids[] = {
+	{.compatible = "mediatek,dbgtop",},
+	{}
+};
+#endif
+
+static struct platform_driver mtk_dbgtop = {
+	.probe = mtk_dbgtop_probe,
+	.remove = mtk_dbgtop_remove,
+	.driver = {
+		.name = "mtk_dbgtop",
+		.owner = THIS_MODULE,
+#ifdef CONFIG_OF
+		.of_match_table = mtk_dbgtop_of_ids,
+#endif
+	},
+};
+
+static int mtk_dbgtop_probe(struct platform_device *pdev)
+{
+	struct resource *res;
+
+	if (DBGTOP_BASE) {
+		pr_info("%s: already got the base addr\n", __func__);
+		return 0;
+	}
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	DBGTOP_BASE = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(DBGTOP_BASE)) {
+		pr_info("[DBGTOP] unable to map DBGTOP_BASE");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static ssize_t dbgtop_config_show(struct device_driver *driver, char *buf)
+{
+	ssize_t ret = 0;
+
+	ret += snprintf(buf + ret, PAGE_SIZE - ret,
+		"%s,0x%x\n%s,0x%x\n%s,0x%x\n%s,0x%x\n",
+		"MTK_DBGTOP_MODE", readl(IOMEM(MTK_DBGTOP_MODE)),
+		"MTK_DBGTOP_LATCH_CTL", readl(IOMEM(MTK_DBGTOP_LATCH_CTL)),
+		"MTK_DBGTOP_DEBUG_CTL", readl(IOMEM(MTK_DBGTOP_DEBUG_CTL)),
+		"MTK_DBGTOP_DEBUG_CTL2", readl(IOMEM(MTK_DBGTOP_DEBUG_CTL2)));
+
+	return strlen(buf);
+}
+
+static ssize_t dbgtop_config_store
+	(struct device_driver *driver, const char *buf, size_t count)
+{
+#if MTK_DBGTOP_TEST
+	char *ptr;
+	char *command;
+
+	if ((strlen(buf) + 1) > DBGTOP_MAX_CMD_LEN) {
+		pr_info("[DBGTOP] store command overflow\n");
+		return count;
+	}
+
+	command = kmalloc((size_t) DBGTOP_MAX_CMD_LEN, GFP_KERNEL);
+	if (!command)
+		return count;
+	strncpy(command, buf, (size_t) DBGTOP_MAX_CMD_LEN);
+
+	ptr = strsep(&command, " ");
+
+	if (!strncmp(buf, "0", strlen("0"))) {
+		mtk_dbgtop_dram_reserved(0);
+		mtk_dbgtop_cfg_dvfsrc(0);
+		mtk_dbgtop_pause_dvfsrc(0);
+		goto dbgtop_config_store;
+	} else if (!strncmp(buf, "1", strlen("1"))) {
+		mtk_dbgtop_dram_reserved(1);
+		mtk_dbgtop_cfg_dvfsrc(1);
+		mtk_dbgtop_pause_dvfsrc(1);
+	}
+
+dbgtop_config_store:
+	kfree(command);
+#endif
+
+	return count;
+}
+
+static DRIVER_ATTR_RW(dbgtop_config);
+
+/*
+ * emi_ctrl_init: module init function.
+ */
+static int __init mtk_dbgtop_init(void)
+{
+	int ret;
+
+	/* register DBGTOP interface */
+	ret = platform_driver_register(&mtk_dbgtop);
+	if (ret)
+		pr_info("[DBGTOP] fail to register mtk_dbgtop driver");
+
+	ret = driver_create_file(&mtk_dbgtop.driver,
+		&driver_attr_dbgtop_config);
+	if (ret)
+		pr_info("[DBGTOP] fail to create dbgtop_config");
+
+	dfd_timeout = readl(IOMEM(MTK_DBGTOP_LATCH_CTL2)) &
+		MTK_DBGTOP_DFD_TIMEOUT_MASK;
+
+	return 0;
+}
+
+/*
+ * mtk_dbgtop_exit: module exit function.
+ */
+static void __exit mtk_dbgtop_exit(void)
+{
+}
+
+#if MTK_DBGTOP_TEST
+int mtk_dbgtop_dram_reserved(int enable)
+{
+	unsigned int tmp, ret;
+	struct wd_api *wd_api = NULL;
+
+	if (DBGTOP_BASE == NULL)
+		return -1;
+
+	if (enable == 1) {
+		/* get watchdog api */
+		ret = get_wd_api(&wd_api);
+		if (ret < 0)
+			return ret;
+
+		wd_api->wd_dfd_count_en(1);
+		wd_api->wd_dfd_timeout(0x1ffff);
+
+		/* enable DDR reserved mode */
+		tmp = readl(IOMEM(MTK_DBGTOP_MODE));
+		tmp |= (MTK_DBGTOP_MODE_DDR_RESERVE | MTK_DBGTOP_MODE_KEY);
+		mt_reg_sync_writel(tmp, MTK_DBGTOP_MODE);
+	} else if (enable == 0) {
+		/* disable DDR reserved mode */
+		tmp = readl(IOMEM(MTK_DBGTOP_MODE));
+		tmp &= (~MTK_DBGTOP_MODE_DDR_RESERVE);
+		tmp |= MTK_DBGTOP_MODE_KEY;
+		mt_reg_sync_writel(tmp, MTK_DBGTOP_MODE);
+	}
+	pr_info("%s: MTK_DBGTOP_MODE(0x%x)\n",
+		__func__, readl(IOMEM(MTK_DBGTOP_MODE)));
+
+	return 0;
+}
+EXPORT_SYMBOL(mtk_dbgtop_dram_reserved);
+#endif
+
+int mtk_dbgtop_cfg_dvfsrc(int enable)
+{
+	unsigned int debug_ctl2, latch_ctl;
+
+	if (DBGTOP_BASE == NULL)
+		return -1;
+
+	debug_ctl2 = readl(IOMEM(MTK_DBGTOP_DEBUG_CTL2));
+	latch_ctl = readl(IOMEM(MTK_DBGTOP_LATCH_CTL));
+
+	if (enable == 1) {
+		/* enable dvfsrc_en */
+		debug_ctl2 |= MTK_DBGTOP_DVFSRC_EN;
+
+		/* set dvfsrc_latch */
+		latch_ctl |= MTK_DBGTOP_DVFSRC_LATCH_EN;
+	} else {
+		/* disable is not allowed */
+		return -1;
+	}
+
+	debug_ctl2 |= MTK_DBGTOP_DEBUG_CTL2_KEY;
+	mt_reg_sync_writel(debug_ctl2, MTK_DBGTOP_DEBUG_CTL2);
+
+	latch_ctl |= MTK_DBGTOP_LATCH_CTL_KEY;
+	mt_reg_sync_writel(latch_ctl, MTK_DBGTOP_LATCH_CTL);
+
+	pr_info("%s: MTK_DBGTOP_DEBUG_CTL2(0x%x)\n",
+		__func__, readl(IOMEM(MTK_DBGTOP_DEBUG_CTL2)));
+	pr_info("%s: MTK_DBGTOP_LATCH_CTL(0x%x)\n",
+		__func__, readl(IOMEM(MTK_DBGTOP_LATCH_CTL)));
+
+	return 0;
+}
+EXPORT_SYMBOL(mtk_dbgtop_cfg_dvfsrc);
+
+int mtk_dbgtop_pause_dvfsrc(int enable)
+{
+	unsigned int tmp;
+	unsigned int count = 100;
+
+	if (DBGTOP_BASE == NULL)
+		return -1;
+
+	if (!(readl(IOMEM(MTK_DBGTOP_DEBUG_CTL2))
+		& MTK_DBGTOP_DVFSRC_EN)) {
+		pr_info("%s: not enable DVFSRC\n", __func__);
+		return 0;
+	}
+
+	if (enable == 1) {
+		/* enable DVFSRC pause */
+		tmp = readl(IOMEM(MTK_DBGTOP_DEBUG_CTL));
+		tmp |= MTK_DBGTOP_DVFSRC_PAUSE_PULSE;
+		tmp |= MTK_DBGTOP_DEBUG_CTL_KEY;
+		mt_reg_sync_writel(tmp, MTK_DBGTOP_DEBUG_CTL);
+		while (count--) {
+			if ((readl(IOMEM(MTK_DBGTOP_DEBUG_CTL))
+				& MTK_DBGTOP_DVFSRC_SUCECESS_ACK))
+				break;
+			udelay(10);
+		}
+
+		pr_info("%s: DVFSRC pause result(0x%x)\n",
+			__func__, readl(IOMEM(MTK_DBGTOP_DEBUG_CTL)));
+	} else if (enable == 0) {
+		/* disable DVFSRC pause */
+		tmp = readl(IOMEM(MTK_DBGTOP_DEBUG_CTL));
+		tmp &= (~MTK_DBGTOP_DVFSRC_PAUSE_PULSE);
+		tmp |= MTK_DBGTOP_DEBUG_CTL_KEY;
+		mt_reg_sync_writel(tmp, MTK_DBGTOP_DEBUG_CTL);
+	}
+
+	pr_info("%s: MTK_DBGTOP_DEBUG_CTL(0x%x)\n",
+		__func__, readl(IOMEM(MTK_DBGTOP_DEBUG_CTL)));
+
+	return 0;
+}
+EXPORT_SYMBOL(mtk_dbgtop_pause_dvfsrc);
+
+static int __init mtk_dbgtop_get_base_addr(void)
+{
+	struct device_node *np_dbgtop;
+
+	for_each_matching_node(np_dbgtop, mtk_dbgtop_of_ids) {
+		pr_info("%s: compatible node found: %s\n",
+			__func__, np_dbgtop->name);
+		break;
+	}
+
+	if (!DBGTOP_BASE) {
+		DBGTOP_BASE = of_iomap(np_dbgtop, 0);
+		if (!DBGTOP_BASE)
+			pr_info("%s: dbgtop iomap failed\n", __func__);
+	}
+
+	return 0;
+}
+
+int mtk_dbgtop_dfd_count_en(int value)
+{
+	unsigned int tmp;
+
+	/* dfd_count_en is obsolete, enable dfd_en only here */
+
+	if (value == 1) {
+		/* enable dfd_en */
+		tmp = readl(IOMEM(MTK_DBGTOP_LATCH_CTL2));
+		tmp |= (MTK_DBGTOP_DFD_EN | MTK_DBGTOP_LATCH_CTL2_KEY);
+		mt_reg_sync_writel(tmp, MTK_DBGTOP_LATCH_CTL2);
+	} else if (value == 0) {
+		/* disable dfd_en */
+		tmp = readl(IOMEM(MTK_DBGTOP_LATCH_CTL2));
+		tmp &= ~MTK_DBGTOP_DFD_EN;
+		tmp |= MTK_DBGTOP_LATCH_CTL2_KEY;
+		mt_reg_sync_writel(tmp, MTK_DBGTOP_LATCH_CTL2);
+	}
+
+	pr_debug("%s: MTK_DBGTOP_LATCH_CTL2(0x%x)\n", __func__,
+		readl(IOMEM(MTK_DBGTOP_LATCH_CTL2)));
+
+	return 0;
+}
+EXPORT_SYMBOL(mtk_dbgtop_dfd_count_en);
+
+int mtk_dbgtop_dfd_therm1_dis(int value)
+{
+	unsigned int tmp;
+
+	if (value == 1) {
+		/* enable dfd count */
+		tmp = readl(IOMEM(MTK_DBGTOP_LATCH_CTL2));
+		tmp |= MTK_DBGTOP_DFD_THERM1_DIS | MTK_DBGTOP_LATCH_CTL2_KEY;
+		mt_reg_sync_writel(tmp, MTK_DBGTOP_LATCH_CTL2);
+	} else if (value == 0) {
+		/* disable dfd count */
+		tmp = readl(IOMEM(MTK_DBGTOP_LATCH_CTL2));
+		tmp &= ~MTK_DBGTOP_DFD_THERM1_DIS;
+		tmp |= MTK_DBGTOP_LATCH_CTL2_KEY;
+		mt_reg_sync_writel(tmp, MTK_DBGTOP_LATCH_CTL2);
+	}
+
+	pr_debug("%s: MTK_DBGTOP_LATCH_CTL2(0x%x)\n", __func__,
+		readl(IOMEM(MTK_DBGTOP_LATCH_CTL2)));
+
+	return 0;
+}
+EXPORT_SYMBOL(mtk_dbgtop_dfd_therm1_dis);
+
+int mtk_dbgtop_dfd_therm2_dis(int value)
+{
+	unsigned int tmp;
+
+	if (value == 1) {
+		/* enable dfd count */
+		tmp = readl(IOMEM(MTK_DBGTOP_LATCH_CTL2));
+		tmp |= MTK_DBGTOP_DFD_THERM2_DIS | MTK_DBGTOP_LATCH_CTL2_KEY;
+		mt_reg_sync_writel(tmp, MTK_DBGTOP_LATCH_CTL2);
+	} else if (value == 0) {
+		tmp = readl(IOMEM(MTK_DBGTOP_LATCH_CTL2));
+		tmp &= ~MTK_DBGTOP_DFD_THERM2_DIS;
+		tmp |= MTK_DBGTOP_LATCH_CTL2_KEY;
+		mt_reg_sync_writel(tmp, MTK_DBGTOP_LATCH_CTL2);
+	}
+
+	pr_debug("%s: MTK_DBGTOP_LATCH_CTL2(0x%x)\n", __func__,
+		readl(IOMEM(MTK_DBGTOP_LATCH_CTL2)));
+
+	return 0;
+}
+EXPORT_SYMBOL(mtk_dbgtop_dfd_therm2_dis);
+
+/*
+ * Set the required timeout value of each caller before RGU reset,
+ * and take the maximum as timeout value.
+ * Note: caller needs to set normal timeout value to 0 by default
+ */
+int mtk_dbgtop_dfd_timeout(int value_abnormal, int value_normal)
+{
+	unsigned int tmp;
+
+	value_normal <<= MTK_DBGTOP_DFD_TIMEOUT_SHIFT;
+	value_normal &= MTK_DBGTOP_DFD_TIMEOUT_MASK;
+
+	if (dfd_timeout < (unsigned int)value_normal)
+		dfd_timeout = (unsigned int)value_normal;
+
+	value_abnormal <<= MTK_DBGTOP_DFD_TIMEOUT_SHIFT;
+	value_abnormal &= MTK_DBGTOP_DFD_TIMEOUT_MASK;
+
+	/* break if dfd timeout >= target value_abnormal */
+	tmp = readl(IOMEM(MTK_DBGTOP_LATCH_CTL2));
+	if ((tmp & MTK_DBGTOP_DFD_TIMEOUT_MASK) >=
+		(unsigned int)value_abnormal)
+		return 0;
+
+	/* set dfd timeout */
+	tmp &= ~MTK_DBGTOP_DFD_TIMEOUT_MASK;
+	tmp |= value_abnormal | MTK_DBGTOP_LATCH_CTL2_KEY;
+	mt_reg_sync_writel(tmp, MTK_DBGTOP_LATCH_CTL2);
+
+	pr_debug("%s: MTK_DBGTOP_LATCH_CTL2(0x%x)\n", __func__,
+		readl(IOMEM(MTK_DBGTOP_LATCH_CTL2)));
+
+	return 0;
+}
+EXPORT_SYMBOL(mtk_dbgtop_dfd_timeout);
+
+int mtk_dbgtop_dfd_timeout_reset(void)
+{
+	unsigned int tmp;
+
+	if (!dfd_timeout)
+		return -1;
+
+	tmp = readl(IOMEM(MTK_DBGTOP_LATCH_CTL2));
+	tmp &= ~MTK_DBGTOP_DFD_TIMEOUT_MASK;
+	tmp |= dfd_timeout | MTK_DBGTOP_LATCH_CTL2_KEY;
+	mt_reg_sync_writel(tmp, MTK_DBGTOP_LATCH_CTL2);
+
+	pr_notice("%s: MTK_DBGTOP_LATCH_CTL2(0x%x)\n", __func__,
+		readl(IOMEM(MTK_DBGTOP_LATCH_CTL2)));
+
+	return 0;
+}
+EXPORT_SYMBOL(mtk_dbgtop_dfd_timeout_reset);
+
+int mtk_dbgtop_mfg_pwr_on(int value)
+{
+	unsigned int tmp;
+
+	if (!DBGTOP_BASE)
+		return -1;
+
+	if (value == 1) {
+		/* set mfg pwr on */
+		tmp = readl(IOMEM(MTK_DBGTOP_MFG_REG));
+		tmp |= MTK_DBGTOP_MFG_PWR_ON;
+		tmp |= MTK_DBGTOP_MFG_REG_KEY;
+		mt_reg_sync_writel(tmp, MTK_DBGTOP_MFG_REG);
+	} else if (value == 0) {
+		tmp = readl(IOMEM(MTK_DBGTOP_MFG_REG));
+		tmp &= ~MTK_DBGTOP_MFG_PWR_ON;
+		tmp |= MTK_DBGTOP_MFG_REG_KEY;
+		mt_reg_sync_writel(tmp, MTK_DBGTOP_MFG_REG);
+	} else
+		return -1;
+
+	return 0;
+}
+EXPORT_SYMBOL(mtk_dbgtop_mfg_pwr_on);
+
+int mtk_dbgtop_mfg_pwr_en(int value)
+{
+	unsigned int tmp;
+
+	if (!DBGTOP_BASE)
+		return -1;
+
+	if (value == 1) {
+		/* set mfg pwr en */
+		tmp = readl(IOMEM(MTK_DBGTOP_MFG_REG));
+		tmp |= MTK_DBGTOP_MFG_PWR_EN;
+		tmp |= MTK_DBGTOP_MFG_REG_KEY;
+		mt_reg_sync_writel(tmp, MTK_DBGTOP_MFG_REG);
+	} else if (value == 0) {
+		tmp = readl(IOMEM(MTK_DBGTOP_MFG_REG));
+		tmp &= ~MTK_DBGTOP_MFG_PWR_EN;
+		tmp |= MTK_DBGTOP_MFG_REG_KEY;
+		mt_reg_sync_writel(tmp, MTK_DBGTOP_MFG_REG);
+	} else
+		return -1;
+
+	return 0;
+}
+EXPORT_SYMBOL(mtk_dbgtop_mfg_pwr_en);
+
+core_initcall(mtk_dbgtop_get_base_addr);
+module_init(mtk_dbgtop_init);
+module_exit(mtk_dbgtop_exit);
+
diff --git a/drivers/soc/mediatek/dbgtop/dbgtop.h b/drivers/soc/mediatek/dbgtop/dbgtop.h
new file mode 100644
index 0000000000000000000000000000000000000000..9bfda741afee7a7f6ba773333f33bb05d7bedad1
--- /dev/null
+++ b/drivers/soc/mediatek/dbgtop/dbgtop.h
@@ -0,0 +1,20 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) 2019 MediaTek Inc.
+ */
+
+#ifndef __DBGTOP_H__
+#define __DBGTOP_H__
+
+int mtk_dbgtop_dram_reserved(int enable);
+int mtk_dbgtop_cfg_dvfsrc(int enable);
+int mtk_dbgtop_pause_dvfsrc(int enable);
+int mtk_dbgtop_dfd_count_en(int value);
+int mtk_dbgtop_dfd_therm1_dis(int value);
+int mtk_dbgtop_dfd_therm2_dis(int value);
+int mtk_dbgtop_dfd_timeout(int value_abnormal, int value_normal);
+int mtk_dbgtop_dfd_timeout_reset(void);
+int mtk_dbgtop_mfg_pwr_on(int value);
+int mtk_dbgtop_mfg_pwr_en(int value);
+
+#endif
diff --git a/drivers/soc/mediatek/dbgtop/mt8195/mtk_dbgtop.h b/drivers/soc/mediatek/dbgtop/mt8195/mtk_dbgtop.h
new file mode 100644
index 0000000000000000000000000000000000000000..7d07240381033d4b1efa4ab36eb226c9dc77b9af
--- /dev/null
+++ b/drivers/soc/mediatek/dbgtop/mt8195/mtk_dbgtop.h
@@ -0,0 +1,51 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) 2021 MediaTek Inc.
+ */
+
+#ifndef __MTK_DBGTOP_H__
+#define __MTK_DBGTOP_H__
+
+#define MTK_DBGTOP_TEST			0
+#define DBGTOP_MAX_CMD_LEN		4
+
+#define MTK_DBGTOP_MODE			(DBGTOP_BASE+0x0000)
+#define MTK_DBGTOP_DEBUG_CTL		(DBGTOP_BASE+0x0030)
+#define MTK_DBGTOP_DEBUG_CTL2		(DBGTOP_BASE+0x0034)
+#define MTK_DBGTOP_LATCH_CTL		(DBGTOP_BASE+0x0040)
+#define MTK_DBGTOP_LATCH_CTL2		(DBGTOP_BASE+0x0044)
+#define MTK_DBGTOP_MFG_REG		(DBGTOP_BASE+0x0060)
+
+/* DBGTOP_MODE */
+#define MTK_DBGTOP_MODE_KEY		(0x22000000)
+#define MTK_DBGTOP_MODE_DDR_RESERVE	(0x00000001)
+
+/* DBGTOP_DEBUG_CTL */
+#define MTK_DBGTOP_DEBUG_CTL_KEY	(0x59000000)
+#define MTK_DBGTOP_DVFSRC_PAUSE_PULSE	(0x00080000)
+#define MTK_DBGTOP_DVFSRC_SUCECESS_ACK	(0x00800000)
+
+/* DBGTOP_DEBUG_CTL2 */
+#define MTK_DBGTOP_DEBUG_CTL2_KEY	(0x55000000)
+#define MTK_DBGTOP_DVFSRC_EN		(0x00000200)
+
+/* DBGTOP_LATCH_CTL */
+#define MTK_DBGTOP_LATCH_CTL_KEY	(0x95000000)
+#define MTK_DBGTOP_DVFSRC_LATCH_EN	(0x00002000)
+
+/* DBGTOP_LATCH_CTL2 */
+#define MTK_DBGTOP_LATCH_CTL2_KEY	(0x95000000)
+#define MTK_DBGTOP_DFD_EN		(0x00020000)
+#define MTK_DBGTOP_DFD_THERM1_DIS	(0x00040000)
+#define MTK_DBGTOP_DFD_THERM2_DIS	(0x00080000)
+
+#define MTK_DBGTOP_DFD_TIMEOUT_SHIFT	(0)
+#define MTK_DBGTOP_DFD_TIMEOUT_MASK \
+	(0x1FFFF << MTK_DBGTOP_DFD_TIMEOUT_SHIFT)
+
+/* DBGTOP_MFG_REG */
+#define MTK_DBGTOP_MFG_REG_KEY		(0x77000000)
+#define MTK_DBGTOP_MFG_PWR_ON		(0x00000001)
+#define MTK_DBGTOP_MFG_PWR_EN		(0x00000002)
+
+#endif
diff --git a/drivers/soc/mediatek/dbgtop/sync_write.h b/drivers/soc/mediatek/dbgtop/sync_write.h
new file mode 100644
index 0000000000000000000000000000000000000000..1329d212e93c8791d1048eabd7d52e4b7dcb5d51
--- /dev/null
+++ b/drivers/soc/mediatek/dbgtop/sync_write.h
@@ -0,0 +1,80 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2019 MediaTek Inc.
+ */
+
+#ifndef MT_SYNC_WRITE_H
+#define MT_SYNC_WRITE_H
+
+#if defined(__KERNEL__)
+
+#include <linux/io.h>
+#include <asm/cacheflush.h>
+
+/*
+ * Define macros.
+ */
+#define mt_reg_sync_writel(v, a) \
+	do {    \
+		__raw_writel((v), (void __force __iomem *)((a)));   \
+		dsb(sy);  \
+	} while (0)
+
+#define mt_reg_sync_writew(v, a) \
+	do {    \
+		__raw_writew((v), (void __force __iomem *)((a)));   \
+		dsb(sy);  \
+	} while (0)
+
+#define mt_reg_sync_writeb(v, a) \
+	do {    \
+		__raw_writeb((v), (void __force __iomem *)((a)));   \
+		dsb(sy);  \
+	} while (0)
+
+#ifdef CONFIG_64BIT
+#define mt_reg_sync_writeq(v, a) \
+	do {    \
+		__raw_writeq((v), (void __force __iomem *)((a)));   \
+		dsb(sy);  \
+	} while (0)
+#endif
+
+#else				/* __KERNEL__ */
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <string.h>
+
+#define mt_reg_sync_writel(v, a)        mt65xx_reg_sync_writel(v, a)
+#define mt_reg_sync_writew(v, a)        mt65xx_reg_sync_writew(v, a)
+#define mt_reg_sync_writeb(v, a)        mt65xx_reg_sync_writeb(v, a)
+
+#define dsb() \
+	{    \
+		__asm__ __volatile__("dsb sy" : : : "memory"); \
+	}
+
+#define mt65xx_reg_sync_writel(v, a) \
+	do {    \
+		*(volatile unsigned int *)(a) = (v);    \
+		dsb(); \
+	} while (0)
+
+#define mt65xx_reg_sync_writew(v, a) \
+	do {    \
+		*(volatile unsigned short *)(a) = (v);    \
+		dsb(); \
+	} while (0)
+
+#define mt65xx_reg_sync_writeb(v, a) \
+	do {    \
+		*(volatile unsigned char *)(a) = (v);    \
+		dsb(); \
+	} while (0)
+
+#endif				/* __KERNEL__ */
+
+#endif				/* !MT_SYNC_WRITE_H */
diff --git a/drivers/soc/mediatek/dfd/Kconfig b/drivers/soc/mediatek/dfd/Kconfig
new file mode 100644
index 0000000000000000000000000000000000000000..5ed36741d898e56928f1efcc8bed1a300ea22dfd
--- /dev/null
+++ b/drivers/soc/mediatek/dfd/Kconfig
@@ -0,0 +1,9 @@
+config MTK_DFD
+	bool "Enable MediaTek DFD internal dump"
+	default n
+	help
+	  DFD (Design for Debug) is a debugging tool,
+	  which scans flip-flops and dumps to internal
+	  RAM on the WDT reset. After system reboots,
+	  those values could be showed in exception db
+	  for debugging.
diff --git a/drivers/soc/mediatek/dfd/Makefile b/drivers/soc/mediatek/dfd/Makefile
new file mode 100644
index 0000000000000000000000000000000000000000..50878e7ac5163fa84b1be0c256c43fdc0280017c
--- /dev/null
+++ b/drivers/soc/mediatek/dfd/Makefile
@@ -0,0 +1,3 @@
+ccflags-y += -I$(srctree)/drivers/soc/mediatek/dfd/mt8195
+obj-y += mt8195/
+obj-y += dfd.o
\ No newline at end of file
diff --git a/drivers/soc/mediatek/dfd/dfd.c b/drivers/soc/mediatek/dfd/dfd.c
new file mode 100644
index 0000000000000000000000000000000000000000..b4cc10516782679962ede2645e404a9cbf877aca
--- /dev/null
+++ b/drivers/soc/mediatek/dfd/dfd.c
@@ -0,0 +1,226 @@
+/*
+ * Copyright (C) 2016 MediaTek Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See http://www.gnu.org/licenses/gpl-2.0.html for more details.
+ */
+
+#include <linux/module.h>
+#include <linux/of_fdt.h>
+#include <linux/of.h>
+#include <linux/slab.h>
+#include <linux/of_address.h>
+#include <linux/fs.h>
+#include <linux/seq_file.h>
+#include <linux/proc_fs.h>
+#include <linux/arm-smccc.h>
+
+#include "dfd.h"
+#include "dfd_platform.h"
+
+static struct dfd_drv *drv;
+const struct plt_cfg_dfd cfg_dfd;
+
+/* return -1 for error indication */
+int dfd_setup(void)
+{
+	struct arm_smccc_res res;
+
+	if (drv && (drv->enabled == 1) && (drv->base_addr > 0)) {
+		/* check support or not first */
+		if (check_dfd_support() == 0) {
+			pr_err("dfd not support\n");
+			return -1;
+		}
+
+		mtk_dbgtop_dfd_count_en(1);
+		mtk_dbgtop_dfd_therm1_dis(1);
+		mtk_dbgtop_dfd_therm2_dis(0);
+		mtk_dbgtop_dfd_timeout(drv->rg_dfd_timeout,0);
+
+		arm_smccc_smc(MTK_SIP_KERNEL_DFD,
+			DFD_SMC_MAGIC_SETUP,
+			(u64) drv->base_addr, drv->chain_length, 0, 0, 0, 0,  &res);
+
+		pr_info("dfd_setup done\n");
+		return 0;
+	} else {
+		pr_err("dfd not enabled or base_addr not set\n");
+		return -1;
+	}
+}
+
+int dfd_get(void **data)
+{
+	unsigned int i;
+	unsigned long paddr;
+	void *vaddr;
+	int len = 0;
+
+	if (data == NULL)
+		return 0;
+
+	*data = NULL;
+
+	//if (dfd_internal_dump_check_triggered_or_not()) {
+	if(1) {
+		paddr = drv->base_addr;
+		/* check pa */
+		if (paddr == 0) {
+			pr_err("[dfd] pa is invalid -> skip\npa = 0x%llx\n",
+			        paddr);
+			return 0;
+		}
+
+		vaddr = ioremap_wc(paddr, cfg_dfd.buffer_length);
+		if (vaddr) {
+			pr_info("[dfd] pa = 0x%lx, va = 0x%p, length = 0x%lx\n",
+				paddr, vaddr, cfg_dfd.buffer_length);
+
+			*data = vaddr;
+
+			//pr_err("dump buffer first\n");
+			//for (i = 0; i <= 20; ++i)
+				//pr_err("%c\n", *(char *)(*data + i));
+
+			/* insert chip id */
+			for (i = 0; i <= 7; ++i)
+				*(char *)(*data + cfg_dfd.chip_id_offset + i) = cfg_dfd.chip_id[i];
+			len = cfg_dfd.buffer_length;
+		} else {
+			pr_err("[dfd] ioremap fail\n");
+		}
+
+	}
+
+	return len;
+}
+
+static int dfd_data_show(struct seq_file *m, void *v)
+{
+	char *buf = NULL;
+	int len = 0;
+
+	/* Save dfd buffer */
+	len = dfd_get((void **)&buf);
+
+	if (buf != NULL) {
+		if (len > 0) {
+			seq_write(m, buf, len);
+		}
+	}
+	return 0;
+}
+
+static int dfd_dump_file_open(struct inode *inode, struct file *file)
+{
+        return single_open(file, dfd_data_show, inode->i_private);
+}
+
+
+#if 0
+static const struct file_operations  dfd_dump_file_ops = {
+        .owner = THIS_MODULE,
+        .open = dfd_dump_file_open,
+        .read = seq_read,
+        .llseek = seq_lseek,
+        .release = single_release,
+};
+#endif
+
+
+static const struct proc_ops dfd_dump_file_ops = {
+	.proc_open = dfd_dump_file_open,
+	.proc_read = seq_read,
+	.proc_lseek = seq_lseek,
+	.proc_release = single_release,
+};
+
+
+static int __init dfd_init(void)
+{
+	struct device_node *dev_node, *infra_node;
+	unsigned int val;
+	struct proc_dir_entry *entry;
+
+	drv = kzalloc(sizeof(struct dfd_drv), GFP_KERNEL);
+	if (!drv) {
+		pr_err("dfd_init kzalloc fail\n");
+		return -ENOMEM;
+	}
+
+	/* get dfd settings */
+	dev_node = of_find_compatible_node(NULL, NULL, "mediatek,dfd");
+	if (dev_node) {
+		if (of_property_read_u32(dev_node, "mediatek,enabled", &val))
+			drv->enabled = 0;
+		else
+			drv->enabled = val;
+
+		if (of_property_read_u32(dev_node,
+					"mediatek,chain_length", &val))
+			drv->chain_length = 0;
+		else
+			drv->chain_length = val;
+
+		if (of_property_read_u32(dev_node,
+					"mediatek,rg_dfd_timeout", &val))
+			drv->rg_dfd_timeout = 0;
+		else
+			drv->rg_dfd_timeout = val;
+
+		if (of_property_read_u32(dev_node,
+					"dfd,base_addr_msb", &val))
+			drv->base_addr_msb = 0;
+		else
+			drv->base_addr_msb = val;
+
+		if (of_property_read_u32(dev_node,
+				"dfd,base_addr", &val))
+			return -ENODEV;
+		else
+			drv->base_addr = val;
+
+		pr_info("dfd_init: from dts: base_addr_msb: 0x%x, base_addr: 0x%x\n",
+			drv->base_addr_msb,  drv->base_addr);
+	} else
+		return -ENODEV;
+
+
+	if (drv->enabled == 0) {
+		pr_err("dfd not enabled\n");
+		return 0;
+	}
+
+	infra_node = of_find_compatible_node(NULL, NULL,
+			"mediatek,mt8195-infracfg_ao");
+	if (infra_node) {
+		void __iomem *infra = of_iomap(infra_node, 0);
+
+		if (infra && drv->base_addr_msb) {
+			pr_err("dfd: infra before: 0x%x\n", readl(infra));
+			//infra += dfd_infra_base();
+			infra += 0x390;
+			writel(readl(infra)
+				| (drv->base_addr_msb >> dfd_ap_addr_offset()),
+				infra);
+			pr_err("dfd: infra after: 0x%x\n", readl(infra));
+		}
+	}
+
+	entry = proc_create("dfd_dump", 0444, NULL, &dfd_dump_file_ops);
+	if (!entry) {
+		pr_err("dfd_dump: failed to create proc entry\n");
+	}
+	dfd_setup();
+
+	return 0;
+}
+
+late_initcall(dfd_init);
diff --git a/drivers/soc/mediatek/dfd/dfd.h b/drivers/soc/mediatek/dfd/dfd.h
new file mode 100644
index 0000000000000000000000000000000000000000..ea2900451cc1d095de3547781412b52fa238379a
--- /dev/null
+++ b/drivers/soc/mediatek/dfd/dfd.h
@@ -0,0 +1,65 @@
+/*
+ * Copyright (C) 2016 MediaTek Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See http://www.gnu.org/licenses/gpl-2.0.html for more details.
+ */
+
+#ifndef __DFD_H__
+#define __DFD_H__
+
+#define DFD_SMC_MAGIC_SETUP (0x99716150)
+#define DFD_CACHE_DUMP_ENABLE	1
+#define DFD_PARITY_ERR_TRIGGER	2
+
+struct dfd_drv {
+	unsigned long base_addr;
+	unsigned int base_addr_msb;
+	unsigned long chain_length;
+	unsigned long rg_dfd_timeout;
+	unsigned int enabled;
+	unsigned int cachedump_en;
+	unsigned int mem_reserve;
+	unsigned int l2c_trigger;
+};
+
+struct plt_cfg_dfd {
+	unsigned int version;
+	unsigned int sw_version;
+	unsigned int nr_header_row;
+	unsigned long long buffer_addr;
+	unsigned long buffer_length;
+	unsigned long large_buffer_length;
+	unsigned long plat_sram_flag1;
+	unsigned long plat_sram_flag2;
+	unsigned long dfd_bypass_efuse_check;
+	long dfd_disable_devinfo_index;
+	long dfd_disable_bit;
+	unsigned long chip_id_offset;
+	char chip_id[8];
+};
+
+extern unsigned int check_dfd_support(void);
+extern unsigned int dfd_infra_base(void);
+extern unsigned int dfd_ap_addr_offset(void);
+extern int mtk_dbgtop_dfd_count_en(int value);
+extern int mtk_dbgtop_dfd_therm1_dis(int value);
+extern int mtk_dbgtop_dfd_therm2_dis(int value);
+extern int mtk_dbgtop_dfd_timeout(int value_abnormal, int value_normal);
+
+#ifdef CONFIG_ARM64
+#define MTK_SIP_SMC_AARCH_BIT                   0x40000000
+#else
+#define MTK_SIP_SMC_AARCH_BIT                   0x00000000
+#endif
+#define MTK_SIP_KERNEL_DFD \
+        (0x82000205 | MTK_SIP_SMC_AARCH_BIT)
+
+
+#endif
diff --git a/drivers/soc/mediatek/dfd/mt8195/Makefile b/drivers/soc/mediatek/dfd/mt8195/Makefile
new file mode 100644
index 0000000000000000000000000000000000000000..b006dfd898a26a130fb67690b510bf2eb0d98e54
--- /dev/null
+++ b/drivers/soc/mediatek/dfd/mt8195/Makefile
@@ -0,0 +1 @@
+obj-y += plat_dfd.o
diff --git a/drivers/soc/mediatek/dfd/mt8195/dfd_platform.h b/drivers/soc/mediatek/dfd/mt8195/dfd_platform.h
new file mode 100644
index 0000000000000000000000000000000000000000..0d8e385274f00b49346fb4aaf0d4d3aaff64f257
--- /dev/null
+++ b/drivers/soc/mediatek/dfd/mt8195/dfd_platform.h
@@ -0,0 +1,27 @@
+/*
+ * Copyright (C) 2016 MediaTek Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See http://www.gnu.org/licenses/gpl-2.0.html for more details.
+ */
+
+const struct plt_cfg_dfd cfg_dfd = {
+//	.version = DFD_V3_0,
+//	.sw_version = DFD_SW_V3,
+	.nr_header_row = 0,
+	.buffer_addr = 0x0c600000,
+	.buffer_length = 0x9d000,
+	.large_buffer_length = 0x800000,
+	.plat_sram_flag1 = 0,
+	.plat_sram_flag2 = 0,
+	.dfd_disable_devinfo_index = 25,
+	.dfd_disable_bit = 12,
+	.chip_id_offset = 0x18,
+	.chip_id = {'8','1','9','5',0,0,0,0},
+};
\ No newline at end of file
diff --git a/drivers/soc/mediatek/dfd/mt8195/plat_dfd.c b/drivers/soc/mediatek/dfd/mt8195/plat_dfd.c
new file mode 100644
index 0000000000000000000000000000000000000000..53909a27a6580f7d9e07d972b09b91e7de9c44f3
--- /dev/null
+++ b/drivers/soc/mediatek/dfd/mt8195/plat_dfd.c
@@ -0,0 +1,30 @@
+/*
+ * Copyright (C) 2017 MediaTek Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See http://www.gnu.org/licenses/gpl-2.0.html for more details.
+ */
+
+unsigned int check_dfd_support(void)
+{
+	return 1;
+}
+
+unsigned int dfd_infra_base(void)
+{
+	return 0x34;
+}
+
+/* DFD_V30_BASE_ADDR_IN_INFRA
+ * bit[10:0] : AP address bit[34:24]
+ */
+unsigned int dfd_ap_addr_offset(void)
+{
+	return 24;
+}
diff --git a/drivers/soc/mediatek/mt8173-pm-domains.h b/drivers/soc/mediatek/mt8173-pm-domains.h
index 654c717e546711e94286e0141b103918ce04d5e0..a4f58c2b44b1f16dbea29262af2289b4261d76e9 100644
--- a/drivers/soc/mediatek/mt8173-pm-domains.h
+++ b/drivers/soc/mediatek/mt8173-pm-domains.h
@@ -15,6 +15,8 @@ static const struct scpsys_domain_data scpsys_domain_data_mt8173[] = {
 		.name = "vdec",
 		.sta_mask = PWR_STATUS_VDEC,
 		.ctl_offs = SPM_VDE_PWR_CON,
+		.pwr_sta_offs = SPM_PWR_STATUS,
+		.pwr_sta2nd_offs = SPM_PWR_STATUS_2ND,
 		.sram_pdn_bits = GENMASK(11, 8),
 		.sram_pdn_ack_bits = GENMASK(12, 12),
 	},
@@ -22,6 +24,8 @@ static const struct scpsys_domain_data scpsys_domain_data_mt8173[] = {
 		.name = "venc",
 		.sta_mask = PWR_STATUS_VENC,
 		.ctl_offs = SPM_VEN_PWR_CON,
+		.pwr_sta_offs = SPM_PWR_STATUS,
+		.pwr_sta2nd_offs = SPM_PWR_STATUS_2ND,
 		.sram_pdn_bits = GENMASK(11, 8),
 		.sram_pdn_ack_bits = GENMASK(15, 12),
 	},
@@ -29,6 +33,8 @@ static const struct scpsys_domain_data scpsys_domain_data_mt8173[] = {
 		.name = "isp",
 		.sta_mask = PWR_STATUS_ISP,
 		.ctl_offs = SPM_ISP_PWR_CON,
+		.pwr_sta_offs = SPM_PWR_STATUS,
+		.pwr_sta2nd_offs = SPM_PWR_STATUS_2ND,
 		.sram_pdn_bits = GENMASK(11, 8),
 		.sram_pdn_ack_bits = GENMASK(13, 12),
 	},
@@ -36,6 +42,8 @@ static const struct scpsys_domain_data scpsys_domain_data_mt8173[] = {
 		.name = "mm",
 		.sta_mask = PWR_STATUS_DISP,
 		.ctl_offs = SPM_DIS_PWR_CON,
+		.pwr_sta_offs = SPM_PWR_STATUS,
+		.pwr_sta2nd_offs = SPM_PWR_STATUS_2ND,
 		.sram_pdn_bits = GENMASK(11, 8),
 		.sram_pdn_ack_bits = GENMASK(12, 12),
 		.bp_infracfg = {
@@ -47,6 +55,8 @@ static const struct scpsys_domain_data scpsys_domain_data_mt8173[] = {
 		.name = "venc_lt",
 		.sta_mask = PWR_STATUS_VENC_LT,
 		.ctl_offs = SPM_VEN2_PWR_CON,
+		.pwr_sta_offs = SPM_PWR_STATUS,
+		.pwr_sta2nd_offs = SPM_PWR_STATUS_2ND,
 		.sram_pdn_bits = GENMASK(11, 8),
 		.sram_pdn_ack_bits = GENMASK(15, 12),
 	},
@@ -54,6 +64,8 @@ static const struct scpsys_domain_data scpsys_domain_data_mt8173[] = {
 		.name = "audio",
 		.sta_mask = PWR_STATUS_AUDIO,
 		.ctl_offs = SPM_AUDIO_PWR_CON,
+		.pwr_sta_offs = SPM_PWR_STATUS,
+		.pwr_sta2nd_offs = SPM_PWR_STATUS_2ND,
 		.sram_pdn_bits = GENMASK(11, 8),
 		.sram_pdn_ack_bits = GENMASK(15, 12),
 	},
@@ -61,6 +73,8 @@ static const struct scpsys_domain_data scpsys_domain_data_mt8173[] = {
 		.name = "usb",
 		.sta_mask = PWR_STATUS_USB,
 		.ctl_offs = SPM_USB_PWR_CON,
+		.pwr_sta_offs = SPM_PWR_STATUS,
+		.pwr_sta2nd_offs = SPM_PWR_STATUS_2ND,
 		.sram_pdn_bits = GENMASK(11, 8),
 		.sram_pdn_ack_bits = GENMASK(15, 12),
 		.caps = MTK_SCPD_ACTIVE_WAKEUP,
@@ -69,6 +83,8 @@ static const struct scpsys_domain_data scpsys_domain_data_mt8173[] = {
 		.name = "mfg_async",
 		.sta_mask = PWR_STATUS_MFG_ASYNC,
 		.ctl_offs = SPM_MFG_ASYNC_PWR_CON,
+		.pwr_sta_offs = SPM_PWR_STATUS,
+		.pwr_sta2nd_offs = SPM_PWR_STATUS_2ND,
 		.sram_pdn_bits = GENMASK(11, 8),
 		.sram_pdn_ack_bits = 0,
 	},
@@ -76,6 +92,8 @@ static const struct scpsys_domain_data scpsys_domain_data_mt8173[] = {
 		.name = "mfg_2d",
 		.sta_mask = PWR_STATUS_MFG_2D,
 		.ctl_offs = SPM_MFG_2D_PWR_CON,
+		.pwr_sta_offs = SPM_PWR_STATUS,
+		.pwr_sta2nd_offs = SPM_PWR_STATUS_2ND,
 		.sram_pdn_bits = GENMASK(11, 8),
 		.sram_pdn_ack_bits = GENMASK(13, 12),
 	},
@@ -83,6 +101,8 @@ static const struct scpsys_domain_data scpsys_domain_data_mt8173[] = {
 		.name = "mfg",
 		.sta_mask = PWR_STATUS_MFG,
 		.ctl_offs = SPM_MFG_PWR_CON,
+		.pwr_sta_offs = SPM_PWR_STATUS,
+		.pwr_sta2nd_offs = SPM_PWR_STATUS_2ND,
 		.sram_pdn_bits = GENMASK(13, 8),
 		.sram_pdn_ack_bits = GENMASK(21, 16),
 		.bp_infracfg = {
@@ -97,8 +117,6 @@ static const struct scpsys_domain_data scpsys_domain_data_mt8173[] = {
 static const struct scpsys_soc_data mt8173_scpsys_data = {
 	.domains_data = scpsys_domain_data_mt8173,
 	.num_domains = ARRAY_SIZE(scpsys_domain_data_mt8173),
-	.pwr_sta_offs = SPM_PWR_STATUS,
-	.pwr_sta2nd_offs = SPM_PWR_STATUS_2ND,
 };
 
 #endif /* __SOC_MEDIATEK_MT8173_PM_DOMAINS_H */
diff --git a/drivers/soc/mediatek/mt8183-mmsys.h b/drivers/soc/mediatek/mt8183-mmsys.h
index 9dee485807c9400225a063dfbb6ae14f619c12a4..c490cc1b10720cd96f82cf1f3d571883a56b9c19 100644
--- a/drivers/soc/mediatek/mt8183-mmsys.h
+++ b/drivers/soc/mediatek/mt8183-mmsys.h
@@ -12,6 +12,32 @@
 #define MT8183_DISP_DPI0_SEL_IN			0xf30
 #define MT8183_DISP_RDMA0_SOUT_SEL_IN		0xf50
 #define MT8183_DISP_RDMA1_SOUT_SEL_IN		0xf54
+#define MT8183_MDP_ISP_MOUT_EN			0xf80
+#define MT8183_MDP_RDMA0_MOUT_EN		0xf84
+#define MT8183_MDP_PRZ0_MOUT_EN			0xf8c
+#define MT8183_MDP_PRZ1_MOUT_EN			0xf90
+#define MT8183_MDP_COLOR_MOUT_EN		0xf94
+#define MT8183_MDP_IPU_MOUT_EN			0xf98
+#define MT8183_MDP_PATH0_SOUT_SEL		0xfa8
+#define MT8183_MDP_PATH1_SOUT_SEL		0xfac
+#define MT8183_MDP_PRZ0_SEL_IN			0xfc0
+#define MT8183_MDP_PRZ1_SEL_IN			0xfc4
+#define MT8183_MDP_TDSHP_SEL_IN			0xfc8
+#define MT8183_MDP_WROT0_SEL_IN			0xfd0
+#define MT8183_MDP_WDMA_SEL_IN			0xfd4
+#define MT8183_MDP_PATH0_SEL_IN			0xfe0
+#define MT8183_MDP_PATH1_SEL_IN			0xfe4
+#define MT8183_MDP_AAL_MOUT_EN			0xfe8
+#define MT8183_MDP_AAL_SEL_IN			0xfec
+#define MT8183_MDP_CCORR_SEL_IN			0xff0
+#define MT8183_MDP_CCORR_SOUT_SEL		0xff4
+
+#define MT8183_ISP_CTRL_MMSYS_SW0_RST_B		0x140
+#define MT8183_ISP_CTRL_MMSYS_SW1_RST_B		0x144
+#define MT8183_ISP_CTRL_MDP_ASYNC_CFG_WD	0x934
+#define MT8183_ISP_CTRL_MDP_ASYNC_IPU_CFG_WD	0x93C
+#define MT8183_ISP_CTRL_ISP_RELAY_CFG_WD	0x994
+#define MT8183_ISP_CTRL_IPU_RELAY_CFG_WD	0x9a0
 
 #define MT8183_OVL0_MOUT_EN_OVL0_2L		BIT(4)
 #define MT8183_OVL0_2L_MOUT_EN_DISP_PATH0	BIT(0)
@@ -24,6 +50,55 @@
 #define MT8183_DPI0_SEL_IN_RDMA1		0x2
 #define MT8183_RDMA0_SOUT_COLOR0		0x1
 #define MT8183_RDMA1_SOUT_DSI0			0x1
+#define MT8183_MDP_ISP_MOUT_EN_CCORR0		BIT(0)
+#define MT8183_MDP_ISP_MOUT_EN_RSZ1		BIT(1)
+#define MT8183_MDP_ISP_MOUT_EN_AAL0		BIT(2)
+#define MT8183_MDP_IPU_MOUT_EN_CCORR0		BIT(0)
+#define MT8183_MDP_IPU_MOUT_EN_RSZ1		BIT(1)
+#define MT8183_MDP_IPU_MOUT_EN_AAL0		BIT(2)
+#define MT8183_MDP_RDMA0_MOUT_EN_CCORR0		BIT(0)
+#define MT8183_MDP_RDMA0_MOUT_EN_RSZ1		BIT(1)
+#define MT8183_MDP_RDMA0_MOUT_EN_PATH0_OUT	BIT(2)
+#define MT8183_MDP_RDMA0_MOUT_EN_AAL0		BIT(3)
+#define MT8183_MDP_AAL_MOUT_EN_CCORR0		BIT(0)
+#define MT8183_MDP_AAL_MOUT_EN_RSZ1		BIT(1)
+#define MT8183_MDP_AAL_MOUT_EN_RSZ0		BIT(2)
+#define MT8183_MDP_PRZ0_MOUT_EN_PATH0_OUT	BIT(0)
+#define MT8183_MDP_PRZ0_MOUT_EN_TDSHP0		BIT(1)
+#define MT8183_MDP_PRZ1_MOUT_EN_PATH0_OUT	BIT(0)
+#define MT8183_MDP_PRZ1_MOUT_EN_TDSHP0		BIT(1)
+#define MT8183_MDP_PRZ1_MOUT_EN_PATH1_OUT	BIT(2)
+#define MT8183_MDP_PRZ1_MOUT_EN_COLOR0		BIT(4)
+#define MT8183_MDP_COLOR_MOUT_EN_PATH0_OUT	BIT(0)
+#define MT8183_MDP_COLOR_MOUT_EN_PATH1_OUT	BIT(1)
+#define MT8183_MDP_AAL_SEL_IN_CAMIN		0
+#define MT8183_MDP_AAL_SEL_IN_RDMA0		1
+#define MT8183_MDP_AAL_SEL_IN_CAMIN2		2
+#define MT8183_MDP_AAL_SEL_IN_CCORR0		3
+#define MT8183_MDP_CCORR_SEL_IN_CAMIN		0
+#define MT8183_MDP_CCORR_SEL_IN_RDMA0		1
+#define MT8183_MDP_CCORR_SEL_IN_CAMIN2		3
+#define MT8183_MDP_CCORR_SEL_IN_AAL0		4
+#define MT8183_MDP_PRZ0_SEL_IN_AAL0		0
+#define MT8183_MDP_PRZ0_SEL_IN_CCORR0		1
+#define MT8183_MDP_PRZ1_SEL_IN_CAMIN		0
+#define MT8183_MDP_PRZ1_SEL_IN_RDMA0		1
+#define MT8183_MDP_PRZ1_SEL_IN_CAMIN2		4
+#define MT8183_MDP_PRZ1_SEL_IN_AAL0		5
+#define MT8183_MDP_TDSHP_SEL_IN_RSZ0		0
+#define MT8183_MDP_TDSHP_SEL_IN_RSZ1		1
+#define MT8183_MDP_PATH0_SEL_IN_RSZ0		0
+#define MT8183_MDP_PATH0_SEL_IN_RSZ1		1
+#define MT8183_MDP_PATH0_SEL_IN_COLOR0		2
+#define MT8183_MDP_PATH0_SEL_IN_RDMA0		3
+#define MT8183_MDP_PATH1_SEL_IN_RSZ1		0
+#define MT8183_MDP_PATH1_SEL_IN_COLOR0		1
+#define MT8183_MDP_WROT0_SEL_IN_PATH0_OUT	0
+#define MT8183_MDP_WDMA_SEL_IN_PATH1_OUT	0
+#define MT8183_MDP_CCORR_SOUT_SEL_AAL0		0
+#define MT8183_MDP_CCORR_SOUT_SEL_RSZ0		1
+#define MT8183_MDP_PATH0_SOUT_SEL_WROT0		0
+#define MT8183_MDP_PATH1_SOUT_SEL_WDMA		0
 
 static const struct mtk_mmsys_routes mmsys_mt8183_routing_table[] = {
 	{
@@ -57,5 +132,165 @@ static const struct mtk_mmsys_routes mmsys_mt8183_routing_table[] = {
 	}
 };
 
+static const struct mtk_mmsys_routes mmsys_mt8183_mdp_routing_table[] = {
+	{
+		MDP_COMP_CAMIN, MDP_COMP_CCORR0,
+		MT8183_MDP_ISP_MOUT_EN, MT8183_MDP_ISP_MOUT_EN_CCORR0
+	}, {
+		MDP_COMP_CAMIN, MDP_COMP_RSZ1,
+		MT8183_MDP_ISP_MOUT_EN, MT8183_MDP_ISP_MOUT_EN_RSZ1
+	}, {
+		MDP_COMP_CAMIN, MDP_COMP_AAL0,
+		MT8183_MDP_ISP_MOUT_EN, MT8183_MDP_ISP_MOUT_EN_AAL0
+	}, {
+		MDP_COMP_CAMIN2, MDP_COMP_CCORR0,
+		MT8183_MDP_IPU_MOUT_EN, MT8183_MDP_IPU_MOUT_EN_CCORR0
+	}, {
+		MDP_COMP_CAMIN2, MDP_COMP_RSZ1,
+		MT8183_MDP_IPU_MOUT_EN, MT8183_MDP_IPU_MOUT_EN_RSZ1
+	}, {
+		MDP_COMP_CAMIN2, MDP_COMP_AAL0,
+		MT8183_MDP_IPU_MOUT_EN, MT8183_MDP_IPU_MOUT_EN_AAL0
+	}, {
+		MDP_COMP_RDMA0, MDP_COMP_CCORR0,
+		MT8183_MDP_RDMA0_MOUT_EN, MT8183_MDP_RDMA0_MOUT_EN_CCORR0
+	}, {
+		MDP_COMP_RDMA0, MDP_COMP_RSZ1,
+		MT8183_MDP_RDMA0_MOUT_EN, MT8183_MDP_RDMA0_MOUT_EN_RSZ1
+	}, {
+		MDP_COMP_RDMA0, MDP_COMP_PATH0_SOUT,
+		MT8183_MDP_RDMA0_MOUT_EN, MT8183_MDP_RDMA0_MOUT_EN_PATH0_OUT
+	}, {
+		MDP_COMP_RDMA0, MDP_COMP_AAL0,
+		MT8183_MDP_RDMA0_MOUT_EN, MT8183_MDP_RDMA0_MOUT_EN_AAL0
+	}, {
+		MDP_COMP_AAL0, MDP_COMP_CCORR0,
+		MT8183_MDP_AAL_MOUT_EN, MT8183_MDP_AAL_MOUT_EN_CCORR0
+	}, {
+		MDP_COMP_AAL0, MDP_COMP_RSZ1,
+		MT8183_MDP_AAL_MOUT_EN, MT8183_MDP_AAL_MOUT_EN_RSZ1
+	}, {
+		MDP_COMP_AAL0, MDP_COMP_RSZ0,
+		MT8183_MDP_AAL_MOUT_EN, MT8183_MDP_AAL_MOUT_EN_RSZ0
+	}, {
+		MDP_COMP_RSZ0, MDP_COMP_PATH0_SOUT,
+		MT8183_MDP_PRZ0_MOUT_EN, MT8183_MDP_PRZ0_MOUT_EN_PATH0_OUT
+	}, {
+		MDP_COMP_RSZ0, MDP_COMP_TDSHP0,
+		MT8183_MDP_PRZ0_MOUT_EN, MT8183_MDP_PRZ0_MOUT_EN_TDSHP0
+	}, {
+		MDP_COMP_RSZ1, MDP_COMP_PATH0_SOUT,
+		MT8183_MDP_PRZ1_MOUT_EN, MT8183_MDP_PRZ1_MOUT_EN_PATH0_OUT
+	}, {
+		MDP_COMP_RSZ1, MDP_COMP_TDSHP0,
+		MT8183_MDP_PRZ1_MOUT_EN, MT8183_MDP_PRZ1_MOUT_EN_TDSHP0
+	}, {
+		MDP_COMP_RSZ1, MDP_COMP_PATH1_SOUT,
+		MT8183_MDP_PRZ1_MOUT_EN, MT8183_MDP_PRZ1_MOUT_EN_PATH1_OUT
+	}, {
+		MDP_COMP_RSZ1, MDP_COMP_COLOR0,
+		MT8183_MDP_PRZ1_MOUT_EN, MT8183_MDP_PRZ1_MOUT_EN_COLOR0
+	}, {
+		MDP_COMP_COLOR0, MDP_COMP_PATH0_SOUT,
+		MT8183_MDP_COLOR_MOUT_EN, MT8183_MDP_COLOR_MOUT_EN_PATH0_OUT
+	}, {
+		MDP_COMP_COLOR0, MDP_COMP_PATH1_SOUT,
+		MT8183_MDP_COLOR_MOUT_EN, MT8183_MDP_COLOR_MOUT_EN_PATH1_OUT
+	}, {
+		MDP_COMP_CAMIN, MDP_COMP_AAL0,
+		MT8183_MDP_AAL_SEL_IN, MT8183_MDP_AAL_SEL_IN_CAMIN
+	}, {
+		MDP_COMP_RDMA0, MDP_COMP_AAL0,
+		MT8183_MDP_AAL_SEL_IN, MT8183_MDP_AAL_SEL_IN_RDMA0
+	}, {
+		MDP_COMP_CAMIN2, MDP_COMP_AAL0,
+		MT8183_MDP_AAL_SEL_IN, MT8183_MDP_AAL_SEL_IN_CAMIN2
+	}, {
+		MDP_COMP_CCORR0, MDP_COMP_AAL0,
+		MT8183_MDP_AAL_SEL_IN, MT8183_MDP_AAL_SEL_IN_CCORR0
+	}, {
+		MDP_COMP_CAMIN, MDP_COMP_CCORR0,
+		MT8183_MDP_CCORR_SEL_IN, MT8183_MDP_CCORR_SEL_IN_CAMIN
+	}, {
+		MDP_COMP_RDMA0, MDP_COMP_CCORR0,
+		MT8183_MDP_CCORR_SEL_IN, MT8183_MDP_CCORR_SEL_IN_RDMA0
+	}, {
+		MDP_COMP_CAMIN2, MDP_COMP_CCORR0,
+		MT8183_MDP_CCORR_SEL_IN, MT8183_MDP_CCORR_SEL_IN_CAMIN2
+	}, {
+		MDP_COMP_AAL0, MDP_COMP_CCORR0,
+		MT8183_MDP_CCORR_SEL_IN, MT8183_MDP_CCORR_SEL_IN_AAL0
+	}, {
+		MDP_COMP_AAL0, MDP_COMP_RSZ0,
+		MT8183_MDP_PRZ0_SEL_IN, MT8183_MDP_PRZ0_SEL_IN_AAL0
+	}, {
+		MDP_COMP_CCORR0, MDP_COMP_RSZ0,
+		MT8183_MDP_PRZ0_SEL_IN, MT8183_MDP_PRZ0_SEL_IN_CCORR0
+	}, {
+		MDP_COMP_CAMIN, MDP_COMP_RSZ1,
+		MT8183_MDP_PRZ1_SEL_IN, MT8183_MDP_PRZ1_SEL_IN_CAMIN
+	}, {
+		MDP_COMP_RDMA0, MDP_COMP_RSZ1,
+		MT8183_MDP_PRZ1_SEL_IN, MT8183_MDP_PRZ1_SEL_IN_RDMA0
+	}, {
+		MDP_COMP_CAMIN2, MDP_COMP_RSZ1,
+		MT8183_MDP_PRZ1_SEL_IN, MT8183_MDP_PRZ1_SEL_IN_CAMIN2
+	}, {
+		MDP_COMP_AAL0, MDP_COMP_RSZ1,
+		MT8183_MDP_PRZ1_SEL_IN, MT8183_MDP_PRZ1_SEL_IN_AAL0
+	}, {
+		MDP_COMP_RSZ0, MDP_COMP_TDSHP0,
+		MT8183_MDP_TDSHP_SEL_IN, MT8183_MDP_TDSHP_SEL_IN_RSZ0
+	}, {
+		MDP_COMP_RSZ1, MDP_COMP_TDSHP0,
+		MT8183_MDP_TDSHP_SEL_IN, MT8183_MDP_TDSHP_SEL_IN_RSZ1
+	}, {
+		MDP_COMP_RSZ0, MDP_COMP_PATH0_SOUT,
+		MT8183_MDP_PATH0_SEL_IN, MT8183_MDP_PATH0_SEL_IN_RSZ0
+	}, {
+		MDP_COMP_RSZ1, MDP_COMP_PATH0_SOUT,
+		MT8183_MDP_PATH0_SEL_IN, MT8183_MDP_PATH0_SEL_IN_RSZ1
+	}, {
+		MDP_COMP_COLOR0, MDP_COMP_PATH0_SOUT,
+		MT8183_MDP_PATH0_SEL_IN, MT8183_MDP_PATH0_SEL_IN_COLOR0
+	}, {
+		MDP_COMP_RDMA0, MDP_COMP_PATH0_SOUT,
+		MT8183_MDP_PATH0_SEL_IN, MT8183_MDP_PATH0_SEL_IN_RDMA0
+	}, {
+		MDP_COMP_RSZ1, MDP_COMP_PATH1_SOUT,
+		MT8183_MDP_PATH1_SEL_IN, MT8183_MDP_PATH1_SEL_IN_RSZ1
+	}, {
+		MDP_COMP_COLOR0, MDP_COMP_PATH1_SOUT,
+		MT8183_MDP_PATH1_SEL_IN, MT8183_MDP_PATH1_SEL_IN_COLOR0
+	}, {
+		MDP_COMP_PATH0_SOUT, MDP_COMP_WROT0,
+		MT8183_MDP_WROT0_SEL_IN, MT8183_MDP_WROT0_SEL_IN_PATH0_OUT
+	}, {
+		MDP_COMP_PATH1_SOUT, MDP_COMP_WDMA,
+		MT8183_MDP_WDMA_SEL_IN, MT8183_MDP_WDMA_SEL_IN_PATH1_OUT
+	}, {
+		MDP_COMP_CCORR0, MDP_COMP_AAL0,
+		MT8183_MDP_CCORR_SOUT_SEL, MT8183_MDP_CCORR_SOUT_SEL_AAL0
+	}, {
+		MDP_COMP_CCORR0, MDP_COMP_RSZ0,
+		MT8183_MDP_CCORR_SOUT_SEL, MT8183_MDP_CCORR_SOUT_SEL_RSZ0
+	}, {
+		MDP_COMP_PATH0_SOUT, MDP_COMP_WROT0,
+		MT8183_MDP_PATH0_SOUT_SEL, MT8183_MDP_PATH0_SOUT_SEL_WROT0
+	}, {
+		MDP_COMP_PATH1_SOUT, MDP_COMP_WDMA,
+		MT8183_MDP_PATH1_SOUT_SEL, MT8183_MDP_PATH1_SOUT_SEL_WDMA
+	}
+};
+
+static const unsigned int mmsys_mt8183_mdp_isp_ctrl_table[ISP_CTRL_MAX] = {
+	[ISP_CTRL_MMSYS_SW0_RST_B] = MT8183_ISP_CTRL_MMSYS_SW0_RST_B,
+	[ISP_CTRL_MMSYS_SW1_RST_B] = MT8183_ISP_CTRL_MMSYS_SW1_RST_B,
+	[ISP_CTRL_MDP_ASYNC_CFG_WD] = MT8183_ISP_CTRL_MDP_ASYNC_CFG_WD,
+	[ISP_CTRL_MDP_ASYNC_IPU_CFG_WD] = MT8183_ISP_CTRL_MDP_ASYNC_IPU_CFG_WD,
+	[ISP_CTRL_ISP_RELAY_CFG_WD] = MT8183_ISP_CTRL_ISP_RELAY_CFG_WD,
+	[ISP_CTRL_IPU_RELAY_CFG_WD] = MT8183_ISP_CTRL_IPU_RELAY_CFG_WD,
+};
+
 #endif /* __SOC_MEDIATEK_MT8183_MMSYS_H */
 
diff --git a/drivers/soc/mediatek/mt8183-pm-domains.h b/drivers/soc/mediatek/mt8183-pm-domains.h
index 98a9940d05fbbb8e1334eec0dc2536f1e344a5ee..71b8757e552d6e249b212945cdca9840dfcb41a4 100644
--- a/drivers/soc/mediatek/mt8183-pm-domains.h
+++ b/drivers/soc/mediatek/mt8183-pm-domains.h
@@ -15,6 +15,8 @@ static const struct scpsys_domain_data scpsys_domain_data_mt8183[] = {
 		.name = "audio",
 		.sta_mask = PWR_STATUS_AUDIO,
 		.ctl_offs = 0x0314,
+		.pwr_sta_offs = 0x0180,
+		.pwr_sta2nd_offs = 0x0184,
 		.sram_pdn_bits = GENMASK(11, 8),
 		.sram_pdn_ack_bits = GENMASK(15, 12),
 	},
@@ -22,6 +24,8 @@ static const struct scpsys_domain_data scpsys_domain_data_mt8183[] = {
 		.name = "conn",
 		.sta_mask = PWR_STATUS_CONN,
 		.ctl_offs = 0x032c,
+		.pwr_sta_offs = 0x0180,
+		.pwr_sta2nd_offs = 0x0184,
 		.sram_pdn_bits = 0,
 		.sram_pdn_ack_bits = 0,
 		.bp_infracfg = {
@@ -33,6 +37,8 @@ static const struct scpsys_domain_data scpsys_domain_data_mt8183[] = {
 		.name = "mfg_async",
 		.sta_mask = PWR_STATUS_MFG_ASYNC,
 		.ctl_offs = 0x0334,
+		.pwr_sta_offs = 0x0180,
+		.pwr_sta2nd_offs = 0x0184,
 		.sram_pdn_bits = 0,
 		.sram_pdn_ack_bits = 0,
 	},
@@ -40,6 +46,8 @@ static const struct scpsys_domain_data scpsys_domain_data_mt8183[] = {
 		.name = "mfg",
 		.sta_mask = PWR_STATUS_MFG,
 		.ctl_offs = 0x0338,
+		.pwr_sta_offs = 0x0180,
+		.pwr_sta2nd_offs = 0x0184,
 		.sram_pdn_bits = GENMASK(8, 8),
 		.sram_pdn_ack_bits = GENMASK(12, 12),
 		.caps = MTK_SCPD_DOMAIN_SUPPLY,
@@ -48,6 +56,8 @@ static const struct scpsys_domain_data scpsys_domain_data_mt8183[] = {
 		.name = "mfg_core0",
 		.sta_mask = BIT(7),
 		.ctl_offs = 0x034c,
+		.pwr_sta_offs = 0x0180,
+		.pwr_sta2nd_offs = 0x0184,
 		.sram_pdn_bits = GENMASK(8, 8),
 		.sram_pdn_ack_bits = GENMASK(12, 12),
 	},
@@ -55,6 +65,8 @@ static const struct scpsys_domain_data scpsys_domain_data_mt8183[] = {
 		.name = "mfg_core1",
 		.sta_mask = BIT(20),
 		.ctl_offs = 0x0310,
+		.pwr_sta_offs = 0x0180,
+		.pwr_sta2nd_offs = 0x0184,
 		.sram_pdn_bits = GENMASK(8, 8),
 		.sram_pdn_ack_bits = GENMASK(12, 12),
 	},
@@ -62,6 +74,8 @@ static const struct scpsys_domain_data scpsys_domain_data_mt8183[] = {
 		.name = "mfg_2d",
 		.sta_mask = PWR_STATUS_MFG_2D,
 		.ctl_offs = 0x0348,
+		.pwr_sta_offs = 0x0180,
+		.pwr_sta2nd_offs = 0x0184,
 		.sram_pdn_bits = GENMASK(8, 8),
 		.sram_pdn_ack_bits = GENMASK(12, 12),
 		.bp_infracfg = {
@@ -75,6 +89,8 @@ static const struct scpsys_domain_data scpsys_domain_data_mt8183[] = {
 		.name = "disp",
 		.sta_mask = PWR_STATUS_DISP,
 		.ctl_offs = 0x030c,
+		.pwr_sta_offs = 0x0180,
+		.pwr_sta2nd_offs = 0x0184,
 		.sram_pdn_bits = GENMASK(8, 8),
 		.sram_pdn_ack_bits = GENMASK(12, 12),
 		.bp_infracfg = {
@@ -94,6 +110,8 @@ static const struct scpsys_domain_data scpsys_domain_data_mt8183[] = {
 		.name = "cam",
 		.sta_mask = BIT(25),
 		.ctl_offs = 0x0344,
+		.pwr_sta_offs = 0x0180,
+		.pwr_sta2nd_offs = 0x0184,
 		.sram_pdn_bits = GENMASK(9, 8),
 		.sram_pdn_ack_bits = GENMASK(13, 12),
 		.bp_infracfg = {
@@ -117,6 +135,8 @@ static const struct scpsys_domain_data scpsys_domain_data_mt8183[] = {
 		.name = "isp",
 		.sta_mask = PWR_STATUS_ISP,
 		.ctl_offs = 0x0308,
+		.pwr_sta_offs = 0x0180,
+		.pwr_sta2nd_offs = 0x0184,
 		.sram_pdn_bits = GENMASK(9, 8),
 		.sram_pdn_ack_bits = GENMASK(13, 12),
 		.bp_infracfg = {
@@ -140,6 +160,8 @@ static const struct scpsys_domain_data scpsys_domain_data_mt8183[] = {
 		.name = "vdec",
 		.sta_mask = BIT(31),
 		.ctl_offs = 0x0300,
+		.pwr_sta_offs = 0x0180,
+		.pwr_sta2nd_offs = 0x0184,
 		.sram_pdn_bits = GENMASK(8, 8),
 		.sram_pdn_ack_bits = GENMASK(12, 12),
 		.bp_smi = {
@@ -153,6 +175,8 @@ static const struct scpsys_domain_data scpsys_domain_data_mt8183[] = {
 		.name = "venc",
 		.sta_mask = PWR_STATUS_VENC,
 		.ctl_offs = 0x0304,
+		.pwr_sta_offs = 0x0180,
+		.pwr_sta2nd_offs = 0x0184,
 		.sram_pdn_bits = GENMASK(11, 8),
 		.sram_pdn_ack_bits = GENMASK(15, 12),
 		.bp_smi = {
@@ -166,6 +190,8 @@ static const struct scpsys_domain_data scpsys_domain_data_mt8183[] = {
 		.name = "vpu_top",
 		.sta_mask = BIT(26),
 		.ctl_offs = 0x0324,
+		.pwr_sta_offs = 0x0180,
+		.pwr_sta2nd_offs = 0x0184,
 		.sram_pdn_bits = GENMASK(8, 8),
 		.sram_pdn_ack_bits = GENMASK(12, 12),
 		.bp_infracfg = {
@@ -193,6 +219,8 @@ static const struct scpsys_domain_data scpsys_domain_data_mt8183[] = {
 		.name = "vpu_core0",
 		.sta_mask = BIT(27),
 		.ctl_offs = 0x33c,
+		.pwr_sta_offs = 0x0180,
+		.pwr_sta2nd_offs = 0x0184,
 		.sram_pdn_bits = GENMASK(11, 8),
 		.sram_pdn_ack_bits = GENMASK(13, 12),
 		.bp_infracfg = {
@@ -211,6 +239,8 @@ static const struct scpsys_domain_data scpsys_domain_data_mt8183[] = {
 		.name = "vpu_core1",
 		.sta_mask = BIT(28),
 		.ctl_offs = 0x0340,
+		.pwr_sta_offs = 0x0180,
+		.pwr_sta2nd_offs = 0x0184,
 		.sram_pdn_bits = GENMASK(11, 8),
 		.sram_pdn_ack_bits = GENMASK(13, 12),
 		.bp_infracfg = {
@@ -230,8 +260,6 @@ static const struct scpsys_domain_data scpsys_domain_data_mt8183[] = {
 static const struct scpsys_soc_data mt8183_scpsys_data = {
 	.domains_data = scpsys_domain_data_mt8183,
 	.num_domains = ARRAY_SIZE(scpsys_domain_data_mt8183),
-	.pwr_sta_offs = 0x0180,
-	.pwr_sta2nd_offs = 0x0184
 };
 
 #endif /* __SOC_MEDIATEK_MT8183_PM_DOMAINS_H */
diff --git a/drivers/soc/mediatek/mt8192-pm-domains.h b/drivers/soc/mediatek/mt8192-pm-domains.h
index 543dda70de01465ef51512f95be5b9cee3938923..558c4ee4784aecd5e94877859180e183a6b38762 100644
--- a/drivers/soc/mediatek/mt8192-pm-domains.h
+++ b/drivers/soc/mediatek/mt8192-pm-domains.h
@@ -15,6 +15,8 @@ static const struct scpsys_domain_data scpsys_domain_data_mt8192[] = {
 		.name = "audio",
 		.sta_mask = BIT(21),
 		.ctl_offs = 0x0354,
+		.pwr_sta_offs = 0x016c,
+		.pwr_sta2nd_offs = 0x0170,
 		.sram_pdn_bits = GENMASK(8, 8),
 		.sram_pdn_ack_bits = GENMASK(12, 12),
 		.bp_infracfg = {
@@ -28,6 +30,8 @@ static const struct scpsys_domain_data scpsys_domain_data_mt8192[] = {
 		.name = "conn",
 		.sta_mask = PWR_STATUS_CONN,
 		.ctl_offs = 0x0304,
+		.pwr_sta_offs = 0x016c,
+		.pwr_sta2nd_offs = 0x0170,
 		.sram_pdn_bits = 0,
 		.sram_pdn_ack_bits = 0,
 		.bp_infracfg = {
@@ -50,6 +54,8 @@ static const struct scpsys_domain_data scpsys_domain_data_mt8192[] = {
 		.name = "mfg0",
 		.sta_mask = BIT(2),
 		.ctl_offs = 0x0308,
+		.pwr_sta_offs = 0x016c,
+		.pwr_sta2nd_offs = 0x0170,
 		.sram_pdn_bits = GENMASK(8, 8),
 		.sram_pdn_ack_bits = GENMASK(12, 12),
 	},
@@ -57,6 +63,8 @@ static const struct scpsys_domain_data scpsys_domain_data_mt8192[] = {
 		.name = "mfg1",
 		.sta_mask = BIT(3),
 		.ctl_offs = 0x030c,
+		.pwr_sta_offs = 0x016c,
+		.pwr_sta2nd_offs = 0x0170,
 		.sram_pdn_bits = GENMASK(8, 8),
 		.sram_pdn_ack_bits = GENMASK(12, 12),
 		.bp_infracfg = {
@@ -82,6 +90,8 @@ static const struct scpsys_domain_data scpsys_domain_data_mt8192[] = {
 		.name = "mfg2",
 		.sta_mask = BIT(4),
 		.ctl_offs = 0x0310,
+		.pwr_sta_offs = 0x016c,
+		.pwr_sta2nd_offs = 0x0170,
 		.sram_pdn_bits = GENMASK(8, 8),
 		.sram_pdn_ack_bits = GENMASK(12, 12),
 	},
@@ -89,6 +99,8 @@ static const struct scpsys_domain_data scpsys_domain_data_mt8192[] = {
 		.name = "mfg3",
 		.sta_mask = BIT(5),
 		.ctl_offs = 0x0314,
+		.pwr_sta_offs = 0x016c,
+		.pwr_sta2nd_offs = 0x0170,
 		.sram_pdn_bits = GENMASK(8, 8),
 		.sram_pdn_ack_bits = GENMASK(12, 12),
 	},
@@ -96,6 +108,8 @@ static const struct scpsys_domain_data scpsys_domain_data_mt8192[] = {
 		.name = "mfg4",
 		.sta_mask = BIT(6),
 		.ctl_offs = 0x0318,
+		.pwr_sta_offs = 0x016c,
+		.pwr_sta2nd_offs = 0x0170,
 		.sram_pdn_bits = GENMASK(8, 8),
 		.sram_pdn_ack_bits = GENMASK(12, 12),
 	},
@@ -103,6 +117,8 @@ static const struct scpsys_domain_data scpsys_domain_data_mt8192[] = {
 		.name = "mfg5",
 		.sta_mask = BIT(7),
 		.ctl_offs = 0x031c,
+		.pwr_sta_offs = 0x016c,
+		.pwr_sta2nd_offs = 0x0170,
 		.sram_pdn_bits = GENMASK(8, 8),
 		.sram_pdn_ack_bits = GENMASK(12, 12),
 	},
@@ -110,6 +126,8 @@ static const struct scpsys_domain_data scpsys_domain_data_mt8192[] = {
 		.name = "mfg6",
 		.sta_mask = BIT(8),
 		.ctl_offs = 0x0320,
+		.pwr_sta_offs = 0x016c,
+		.pwr_sta2nd_offs = 0x0170,
 		.sram_pdn_bits = GENMASK(8, 8),
 		.sram_pdn_ack_bits = GENMASK(12, 12),
 	},
@@ -117,6 +135,8 @@ static const struct scpsys_domain_data scpsys_domain_data_mt8192[] = {
 		.name = "disp",
 		.sta_mask = BIT(20),
 		.ctl_offs = 0x0350,
+		.pwr_sta_offs = 0x016c,
+		.pwr_sta2nd_offs = 0x0170,
 		.sram_pdn_bits = GENMASK(8, 8),
 		.sram_pdn_ack_bits = GENMASK(12, 12),
 		.bp_infracfg = {
@@ -146,6 +166,8 @@ static const struct scpsys_domain_data scpsys_domain_data_mt8192[] = {
 		.name = "ipe",
 		.sta_mask = BIT(14),
 		.ctl_offs = 0x0338,
+		.pwr_sta_offs = 0x016c,
+		.pwr_sta2nd_offs = 0x0170,
 		.sram_pdn_bits = GENMASK(8, 8),
 		.sram_pdn_ack_bits = GENMASK(12, 12),
 		.bp_infracfg = {
@@ -163,6 +185,8 @@ static const struct scpsys_domain_data scpsys_domain_data_mt8192[] = {
 		.name = "isp",
 		.sta_mask = BIT(12),
 		.ctl_offs = 0x0330,
+		.pwr_sta_offs = 0x016c,
+		.pwr_sta2nd_offs = 0x0170,
 		.sram_pdn_bits = GENMASK(8, 8),
 		.sram_pdn_ack_bits = GENMASK(12, 12),
 		.bp_infracfg = {
@@ -180,6 +204,8 @@ static const struct scpsys_domain_data scpsys_domain_data_mt8192[] = {
 		.name = "isp2",
 		.sta_mask = BIT(13),
 		.ctl_offs = 0x0334,
+		.pwr_sta_offs = 0x016c,
+		.pwr_sta2nd_offs = 0x0170,
 		.sram_pdn_bits = GENMASK(8, 8),
 		.sram_pdn_ack_bits = GENMASK(12, 12),
 		.bp_infracfg = {
@@ -197,6 +223,8 @@ static const struct scpsys_domain_data scpsys_domain_data_mt8192[] = {
 		.name = "mdp",
 		.sta_mask = BIT(19),
 		.ctl_offs = 0x034c,
+		.pwr_sta_offs = 0x016c,
+		.pwr_sta2nd_offs = 0x0170,
 		.sram_pdn_bits = GENMASK(8, 8),
 		.sram_pdn_ack_bits = GENMASK(12, 12),
 		.bp_infracfg = {
@@ -214,6 +242,8 @@ static const struct scpsys_domain_data scpsys_domain_data_mt8192[] = {
 		.name = "venc",
 		.sta_mask = BIT(17),
 		.ctl_offs = 0x0344,
+		.pwr_sta_offs = 0x016c,
+		.pwr_sta2nd_offs = 0x0170,
 		.sram_pdn_bits = GENMASK(8, 8),
 		.sram_pdn_ack_bits = GENMASK(12, 12),
 		.bp_infracfg = {
@@ -231,6 +261,8 @@ static const struct scpsys_domain_data scpsys_domain_data_mt8192[] = {
 		.name = "vdec",
 		.sta_mask = BIT(15),
 		.ctl_offs = 0x033c,
+		.pwr_sta_offs = 0x016c,
+		.pwr_sta2nd_offs = 0x0170,
 		.sram_pdn_bits = GENMASK(8, 8),
 		.sram_pdn_ack_bits = GENMASK(12, 12),
 		.bp_infracfg = {
@@ -248,6 +280,8 @@ static const struct scpsys_domain_data scpsys_domain_data_mt8192[] = {
 		.name = "vdec2",
 		.sta_mask = BIT(16),
 		.ctl_offs = 0x0340,
+		.pwr_sta_offs = 0x016c,
+		.pwr_sta2nd_offs = 0x0170,
 		.sram_pdn_bits = GENMASK(8, 8),
 		.sram_pdn_ack_bits = GENMASK(12, 12),
 	},
@@ -255,6 +289,8 @@ static const struct scpsys_domain_data scpsys_domain_data_mt8192[] = {
 		.name = "cam",
 		.sta_mask = BIT(23),
 		.ctl_offs = 0x035c,
+		.pwr_sta_offs = 0x016c,
+		.pwr_sta2nd_offs = 0x0170,
 		.sram_pdn_bits = GENMASK(8, 8),
 		.sram_pdn_ack_bits = GENMASK(12, 12),
 		.bp_infracfg = {
@@ -284,6 +320,8 @@ static const struct scpsys_domain_data scpsys_domain_data_mt8192[] = {
 		.name = "cam_rawa",
 		.sta_mask = BIT(24),
 		.ctl_offs = 0x0360,
+		.pwr_sta_offs = 0x016c,
+		.pwr_sta2nd_offs = 0x0170,
 		.sram_pdn_bits = GENMASK(8, 8),
 		.sram_pdn_ack_bits = GENMASK(12, 12),
 	},
@@ -291,6 +329,8 @@ static const struct scpsys_domain_data scpsys_domain_data_mt8192[] = {
 		.name = "cam_rawb",
 		.sta_mask = BIT(25),
 		.ctl_offs = 0x0364,
+		.pwr_sta_offs = 0x016c,
+		.pwr_sta2nd_offs = 0x0170,
 		.sram_pdn_bits = GENMASK(8, 8),
 		.sram_pdn_ack_bits = GENMASK(12, 12),
 	},
@@ -298,6 +338,8 @@ static const struct scpsys_domain_data scpsys_domain_data_mt8192[] = {
 		.name = "cam_rawc",
 		.sta_mask = BIT(26),
 		.ctl_offs = 0x0368,
+		.pwr_sta_offs = 0x016c,
+		.pwr_sta2nd_offs = 0x0170,
 		.sram_pdn_bits = GENMASK(8, 8),
 		.sram_pdn_ack_bits = GENMASK(12, 12),
 	},
@@ -306,8 +348,6 @@ static const struct scpsys_domain_data scpsys_domain_data_mt8192[] = {
 static const struct scpsys_soc_data mt8192_scpsys_data = {
 	.domains_data = scpsys_domain_data_mt8192,
 	.num_domains = ARRAY_SIZE(scpsys_domain_data_mt8192),
-	.pwr_sta_offs = 0x016c,
-	.pwr_sta2nd_offs = 0x0170,
 };
 
 #endif /* __SOC_MEDIATEK_MT8192_PM_DOMAINS_H */
diff --git a/drivers/soc/mediatek/mt8195-mmsys.h b/drivers/soc/mediatek/mt8195-mmsys.h
new file mode 100644
index 0000000000000000000000000000000000000000..aebdab9658d8010b562d35e132283eaf00109d14
--- /dev/null
+++ b/drivers/soc/mediatek/mt8195-mmsys.h
@@ -0,0 +1,309 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+
+#ifndef __SOC_MEDIATEK_MT8195_MMSYS_H
+#define __SOC_MEDIATEK_MT8195_MMSYS_H
+
+#define MT8195_VDO0_OVL_MOUT_EN					0xf14
+#define MT8195_MOUT_DISP_OVL0_TO_DISP_RDMA0			BIT(0)
+#define MT8195_MOUT_DISP_OVL0_TO_DISP_WDMA0			BIT(1)
+#define MT8195_MOUT_DISP_OVL0_TO_DISP_OVL1			BIT(2)
+#define MT8195_MOUT_DISP_OVL1_TO_DISP_RDMA1			BIT(4)
+#define MT8195_MOUT_DISP_OVL1_TO_DISP_WDMA1			BIT(5)
+#define MT8195_MOUT_DISP_OVL1_TO_DISP_OVL0			BIT(6)
+
+#define MT8195_VDO0_SEL_IN					0xf34
+#define MT8195_SEL_IN_VPP_MERGE_FROM_DSC_WRAP0_OUT		(0 << 0)
+#define MT8195_SEL_IN_VPP_MERGE_FROM_DISP_DITHER1		(1 << 0)
+#define MT8195_SEL_IN_VPP_MERGE_FROM_VDO1_VIRTUAL0		(2 << 0)
+#define MT8195_SEL_IN_DSC_WRAP0_IN_FROM_DISP_DITHER0		(0 << 4)
+#define MT8195_SEL_IN_DSC_WRAP0_IN_FROM_VPP_MERGE		(1 << 4)
+#define MT8195_SEL_IN_DSC_WRAP1_IN_FROM_DISP_DITHER1		(0 << 5)
+#define MT8195_SEL_IN_DSC_WRAP1_IN_FROM_VPP_MERGE		(1 << 5)
+#define MT8195_SEL_IN_SINA_VIRTUAL0_FROM_VPP_MERGE		(0 << 8)
+#define MT8195_SEL_IN_SINA_VIRTUAL0_FROM_DSC_WRAP1_OUT		(1 << 8)
+#define MT8195_SEL_IN_SINB_VIRTUAL0_FROM_DSC_WRAP0_OUT		(0 << 9)
+#define MT8195_SEL_IN_DP_INTF0_FROM_DSC_WRAP1_OUT		(0 << 12)
+#define MT8195_SEL_IN_DP_INTF0_FROM_VPP_MERGE			(1 << 12)
+#define MT8195_SEL_IN_DP_INTF0_FROM_VDO1_VIRTUAL0		(2 << 12)
+#define MT8195_SEL_IN_DSI0_FROM_DSC_WRAP0_OUT			(0 << 16)
+#define MT8195_SEL_IN_DSI0_FROM_DISP_DITHER0			(1 << 16)
+#define MT8195_SEL_IN_DSI1_FROM_DSC_WRAP1_OUT			(0 << 17)
+#define MT8195_SEL_IN_DSI1_FROM_VPP_MERGE			(1 << 17)
+#define MT8195_SEL_IN_DISP_WDMA1_FROM_DISP_OVL1			(0 << 20)
+#define MT8195_SEL_IN_DISP_WDMA1_FROM_VPP_MERGE			(1 << 20)
+#define MT8195_SEL_IN_DSC_WRAP1_OUT_FROM_DSC_WRAP1_IN		(0 << 21)
+#define MT8195_SEL_IN_DSC_WRAP1_OUT_FROM_DISP_DITHER1		(1 << 21)
+#define MT8195_SEL_IN_DISP_WDMA0_FROM_DISP_OVL0			(0 << 22)
+#define MT8195_SEL_IN_DISP_WDMA0_FROM_VPP_MERGE			(1 << 22)
+
+#define MT8195_VDO0_SEL_OUT					0xf38
+#define MT8195_SOUT_DISP_DITHER0_TO_DSC_WRAP0_IN		(0 << 0)
+#define MT8195_SOUT_DISP_DITHER0_TO_DSI0			(1 << 0)
+#define MT8195_SOUT_DISP_DITHER1_TO_DSC_WRAP1_IN		(0 << 1)
+#define MT8195_SOUT_DISP_DITHER1_TO_VPP_MERGE			(1 << 1)
+#define MT8195_SOUT_DISP_DITHER1_TO_DSC_WRAP1_OUT		(2 << 1)
+#define MT8195_SOUT_VDO1_VIRTUAL0_TO_VPP_MERGE			(0 << 4)
+#define MT8195_SOUT_VDO1_VIRTUAL0_TO_DP_INTF0			(1 << 4)
+#define MT8195_SOUT_VPP_MERGE_TO_DSI1				(0 << 8)
+#define MT8195_SOUT_VPP_MERGE_TO_DP_INTF0			(1 << 8)
+#define MT8195_SOUT_VPP_MERGE_TO_SINA_VIRTUAL0			(2 << 8)
+#define MT8195_SOUT_VPP_MERGE_TO_DISP_WDMA1			(3 << 8)
+#define MT8195_SOUT_VPP_MERGE_TO_DSC_WRAP0_IN			(4 << 8)
+#define MT8195_SOUT_VPP_MERGE_TO_DSC_WRAP1_IN			(0 << 11)
+#define MT8195_SOUT_VPP_MERGE_TO_DISP_WDMA0			(1 << 11)
+#define MT8195_SOUT_DSC_WRAP0_OUT_TO_DSI0			(0 << 12)
+#define MT8195_SOUT_DSC_WRAP0_OUT_TO_SINB_VIRTUAL0		(1 << 12)
+#define MT8195_SOUT_DSC_WRAP0_OUT_TO_VPP_MERGE			(2 << 12)
+#define MT8195_SOUT_DSC_WRAP1_OUT_TO_DSI1			(0 << 16)
+#define MT8195_SOUT_DSC_WRAP1_OUT_TO_DP_INTF0			(1 << 16)
+#define MT8195_SOUT_DSC_WRAP1_OUT_TO_SINA_VIRTUAL0		(2 << 16)
+#define MT8195_SOUT_DSC_WRAP1_OUT_TO_VPP_MERGE			(3 << 16)
+
+#define MT8195_VDO1_VPP_MERGE0_P0_SEL_IN			0xf04
+#define MT8195_VPP_MERGE0_P0_SEL_IN_FROM_MDP_RDMA0		(1 << 0)
+
+#define MT8195_VDO1_VPP_MERGE0_P1_SEL_IN			0xf08
+#define MT8195_VPP_MERGE0_P1_SEL_IN_FROM_MDP_RDMA1		(1 << 0)
+
+#define MT8195_VDO1_DISP_DPI1_SEL_IN				0xf10
+#define MT8195_DISP_DPI1_SEL_IN_FROM_VPP_MERGE4_MOUT		(0 << 0)
+
+#define MT8195_VDO1_DISP_DP_INTF0_SEL_IN			0xf14
+#define MT8195_DISP_DP_INTF0_SEL_IN_FROM_VPP_MERGE4_MOUT	(0 << 0)
+
+#define MT8195_VDO1_MERGE4_SOUT_SEL				0xf18
+#define MT8195_MERGE4_SOUT_TO_DPI1_SEL				(2 << 0)
+#define MT8195_MERGE4_SOUT_TO_DP_INTF0_SEL			(3 << 0)
+
+#define MT8195_VDO1_MIXER_IN1_SEL_IN				0xf24
+#define MT8195_MIXER_IN1_SEL_IN_FROM_MERGE0_ASYNC_SOUT		(1 << 0)
+
+#define MT8195_VDO1_MIXER_IN2_SEL_IN				0xf28
+#define MT8195_MIXER_IN2_SEL_IN_FROM_MERGE1_ASYNC_SOUT		(1 << 0)
+
+#define MT8195_VDO1_MIXER_IN3_SEL_IN				0xf2c
+#define MT8195_MIXER_IN3_SEL_IN_FROM_MERGE2_ASYNC_SOUT		(1 << 0)
+
+#define MT8195_VDO1_MIXER_IN4_SEL_IN				0xf30
+#define MT8195_MIXER_IN4_SEL_IN_FROM_MERGE3_ASYNC_SOUT		(1 << 0)
+
+#define MT8195_VDO1_MIXER_OUT_SOUT_SEL				0xf34
+#define MT8195_MIXER_SOUT_TO_MERGE4_ASYNC_SEL			(1 << 0)
+
+#define MT8195_VDO1_VPP_MERGE1_P0_SEL_IN			0xf3c
+#define MT8195_VPP_MERGE1_P0_SEL_IN_FROM_MDP_RDMA2		(1 << 0)
+
+#define MT8195_VDO1_MERGE0_ASYNC_SOUT_SEL			0xf40
+#define MT8195_SOUT_TO_MIXER_IN1_SEL				(1 << 0)
+
+#define MT8195_VDO1_MERGE1_ASYNC_SOUT_SEL			0xf44
+#define MT8195_SOUT_TO_MIXER_IN2_SEL				(1 << 0)
+
+#define MT8195_VDO1_MERGE2_ASYNC_SOUT_SEL			0xf48
+#define MT8195_SOUT_TO_MIXER_IN3_SEL				(1 << 0)
+
+#define MT8195_VDO1_MERGE3_ASYNC_SOUT_SEL			0xf4c
+#define MT8195_SOUT_TO_MIXER_IN4_SEL				(1 << 0)
+
+#define MT8195_VDO1_MERGE4_ASYNC_SEL_IN				0xf50
+#define MT8195_MERGE4_ASYNC_SEL_IN_FROM_MIXER_OUT_SOUT		(1 << 0)
+
+#define MT8195_VDO1_MIXER_IN1_SOUT_SEL				0xf58
+#define MT8195_MIXER_IN1_SOUT_TO_DISP_MIXER			(0 << 0)
+
+#define MT8195_VDO1_MIXER_IN2_SOUT_SEL				0xf5c
+#define MT8195_MIXER_IN2_SOUT_TO_DISP_MIXER			(0 << 0)
+
+#define MT8195_VDO1_MIXER_IN3_SOUT_SEL				0xf60
+#define MT8195_MIXER_IN3_SOUT_TO_DISP_MIXER			(0 << 0)
+
+#define MT8195_VDO1_MIXER_IN4_SOUT_SEL				0xf64
+#define MT8195_MIXER_IN4_SOUT_TO_DISP_MIXER			(0 << 0)
+
+#define MT8195_VDO1_MIXER_SOUT_SEL_IN				0xf68
+#define MT8195_MIXER_SOUT_SEL_IN_FROM_DISP_MIXER		(0 << 0)
+
+#define MT8195_VDO1_SW0_RST_B           0x1d0
+#define MT8195_VDO1_MERGE0_ASYNC_CFG_WD	0xe30
+#define MT8195_VDO1_MERGE1_ASYNC_CFG_WD	0xe40
+#define MT8195_VDO1_MERGE2_ASYNC_CFG_WD	0xe50
+#define MT8195_VDO1_MERGE3_ASYNC_CFG_WD	0xe60
+#define MT8195_VDO1_HDRBE_ASYNC_CFG_WD	0xe70
+#define MT8195_VDO1_HDR_TOP_CFG		0xd00
+#define MT8195_VDO1_MIXER_IN1_ALPHA	0xd30
+#define MT8195_VDO1_MIXER_IN2_ALPHA	0xd34
+#define MT8195_VDO1_MIXER_IN3_ALPHA	0xd38
+#define MT8195_VDO1_MIXER_IN4_ALPHA	0xd3c
+#define MT8195_VDO1_MIXER_IN1_PAD	0xd40
+#define MT8195_VDO1_MIXER_IN2_PAD	0xd44
+#define MT8195_VDO1_MIXER_IN3_PAD	0xd48
+#define MT8195_VDO1_MIXER_IN4_PAD	0xd4c
+
+static const struct mtk_mmsys_routes mmsys_mt8195_routing_table[] = {
+	{
+		DDP_COMPONENT_OVL0, DDP_COMPONENT_RDMA0,
+		MT8195_VDO0_OVL_MOUT_EN, MT8195_MOUT_DISP_OVL0_TO_DISP_RDMA0,
+		MT8195_MOUT_DISP_OVL0_TO_DISP_RDMA0
+	}, {
+		DDP_COMPONENT_OVL1, DDP_COMPONENT_RDMA1,
+		MT8195_VDO0_OVL_MOUT_EN, MT8195_MOUT_DISP_OVL1_TO_DISP_RDMA1,
+		MT8195_MOUT_DISP_OVL1_TO_DISP_RDMA1
+	}, {
+		DDP_COMPONENT_DSC0, DDP_COMPONENT_MERGE0,
+		MT8195_VDO0_SEL_IN, MT8195_SEL_IN_VPP_MERGE_FROM_DSC_WRAP0_OUT,
+		MT8195_SEL_IN_VPP_MERGE_FROM_DSC_WRAP0_OUT
+	}, {
+		DDP_COMPONENT_MERGE0, DDP_COMPONENT_DP_INTF0,
+		MT8195_VDO0_SEL_IN, MT8195_SEL_IN_DP_INTF0_FROM_VPP_MERGE,
+		MT8195_SEL_IN_DP_INTF0_FROM_VPP_MERGE
+	}, {
+		DDP_COMPONENT_DITHER, DDP_COMPONENT_DSC0,
+		MT8195_VDO0_SEL_IN, MT8195_SEL_IN_DSC_WRAP0_IN_FROM_DISP_DITHER0,
+		MT8195_SEL_IN_DSC_WRAP0_IN_FROM_DISP_DITHER0
+	}, {
+		DDP_COMPONENT_DSC0, DDP_COMPONENT_DSI0,
+		MT8195_VDO0_SEL_IN, MT8195_SEL_IN_DSI0_FROM_DSC_WRAP0_OUT,
+		MT8195_SEL_IN_DSI0_FROM_DSC_WRAP0_OUT
+	}, {
+		DDP_COMPONENT_DITHER, DDP_COMPONENT_DSI0,
+		MT8195_VDO0_SEL_IN, MT8195_SEL_IN_DSI0_FROM_DISP_DITHER0,
+		MT8195_SEL_IN_DSI0_FROM_DISP_DITHER0
+	}, {
+		DDP_COMPONENT_DITHER, DDP_COMPONENT_DSC0,
+		MT8195_VDO0_SEL_OUT, MT8195_SOUT_DISP_DITHER0_TO_DSC_WRAP0_IN,
+		MT8195_SOUT_DISP_DITHER0_TO_DSC_WRAP0_IN
+	}, {
+		DDP_COMPONENT_DITHER, DDP_COMPONENT_DSI0,
+		MT8195_VDO0_SEL_OUT, MT8195_SOUT_DSC_WRAP0_OUT_TO_DSI0,
+		MT8195_SOUT_DSC_WRAP0_OUT_TO_DSI0
+	}, {
+		DDP_COMPONENT_DSC0, DDP_COMPONENT_MERGE0,
+		MT8195_VDO0_SEL_OUT, MT8195_SOUT_DSC_WRAP0_OUT_TO_VPP_MERGE,
+		MT8195_SOUT_DSC_WRAP0_OUT_TO_VPP_MERGE
+	}, {
+		DDP_COMPONENT_MERGE0, DDP_COMPONENT_DP_INTF0,
+		MT8195_VDO0_SEL_OUT, MT8195_SOUT_VPP_MERGE_TO_DP_INTF0,
+		MT8195_SOUT_VPP_MERGE_TO_DP_INTF0
+	}, {
+		DDP_COMPONENT_OVL_ADAPTOR, DDP_COMPONENT_MERGE5,
+		MT8195_VDO1_VPP_MERGE0_P0_SEL_IN, GENMASK(0, 0),
+		MT8195_VPP_MERGE0_P0_SEL_IN_FROM_MDP_RDMA0
+	}, {
+		DDP_COMPONENT_OVL_ADAPTOR, DDP_COMPONENT_MERGE5,
+		MT8195_VDO1_VPP_MERGE0_P1_SEL_IN, GENMASK(0, 0),
+		MT8195_VPP_MERGE0_P1_SEL_IN_FROM_MDP_RDMA1
+	}, {
+		DDP_COMPONENT_OVL_ADAPTOR, DDP_COMPONENT_MERGE5,
+		MT8195_VDO1_VPP_MERGE1_P0_SEL_IN, GENMASK(0, 0),
+		MT8195_VPP_MERGE1_P0_SEL_IN_FROM_MDP_RDMA2
+	}, {
+		DDP_COMPONENT_OVL_ADAPTOR, DDP_COMPONENT_MERGE5,
+		MT8195_VDO1_MERGE0_ASYNC_SOUT_SEL, GENMASK(1, 0),
+		MT8195_SOUT_TO_MIXER_IN1_SEL
+	}, {
+		DDP_COMPONENT_OVL_ADAPTOR, DDP_COMPONENT_MERGE5,
+		MT8195_VDO1_MERGE1_ASYNC_SOUT_SEL, GENMASK(1, 0),
+		MT8195_SOUT_TO_MIXER_IN2_SEL
+	}, {
+		DDP_COMPONENT_OVL_ADAPTOR, DDP_COMPONENT_MERGE5,
+		MT8195_VDO1_MERGE2_ASYNC_SOUT_SEL, GENMASK(1, 0),
+		MT8195_SOUT_TO_MIXER_IN3_SEL
+	}, {
+		DDP_COMPONENT_OVL_ADAPTOR, DDP_COMPONENT_MERGE5,
+		MT8195_VDO1_MERGE3_ASYNC_SOUT_SEL, GENMASK(1, 0),
+		MT8195_SOUT_TO_MIXER_IN4_SEL
+	}, {
+		DDP_COMPONENT_OVL_ADAPTOR, DDP_COMPONENT_MERGE5,
+		MT8195_VDO1_MIXER_OUT_SOUT_SEL, GENMASK(0, 0),
+		MT8195_MIXER_SOUT_TO_MERGE4_ASYNC_SEL
+	}, {
+		DDP_COMPONENT_OVL_ADAPTOR, DDP_COMPONENT_MERGE5,
+		MT8195_VDO1_MIXER_IN1_SEL_IN, GENMASK(0, 0),
+		MT8195_MIXER_IN1_SEL_IN_FROM_MERGE0_ASYNC_SOUT
+	}, {
+		DDP_COMPONENT_OVL_ADAPTOR, DDP_COMPONENT_MERGE5,
+		MT8195_VDO1_MIXER_IN2_SEL_IN, GENMASK(0, 0),
+		MT8195_MIXER_IN2_SEL_IN_FROM_MERGE1_ASYNC_SOUT
+	}, {
+		DDP_COMPONENT_OVL_ADAPTOR, DDP_COMPONENT_MERGE5,
+		MT8195_VDO1_MIXER_IN3_SEL_IN, GENMASK(0, 0),
+		MT8195_MIXER_IN3_SEL_IN_FROM_MERGE2_ASYNC_SOUT
+	}, {
+		DDP_COMPONENT_OVL_ADAPTOR, DDP_COMPONENT_MERGE5,
+		MT8195_VDO1_MIXER_IN4_SEL_IN, GENMASK(0, 0),
+		MT8195_MIXER_IN4_SEL_IN_FROM_MERGE3_ASYNC_SOUT
+	}, {
+		DDP_COMPONENT_OVL_ADAPTOR, DDP_COMPONENT_MERGE5,
+		MT8195_VDO1_MIXER_SOUT_SEL_IN, GENMASK(2, 0),
+		MT8195_MIXER_SOUT_SEL_IN_FROM_DISP_MIXER
+	}, {
+		DDP_COMPONENT_OVL_ADAPTOR, DDP_COMPONENT_MERGE5,
+		MT8195_VDO1_MERGE4_ASYNC_SEL_IN, GENMASK(2, 0),
+		MT8195_MERGE4_ASYNC_SEL_IN_FROM_MIXER_OUT_SOUT
+	}, {
+		DDP_COMPONENT_MERGE5, DDP_COMPONENT_DPI1,
+		MT8195_VDO1_DISP_DPI1_SEL_IN, GENMASK(1, 0),
+		MT8195_DISP_DPI1_SEL_IN_FROM_VPP_MERGE4_MOUT
+	}, {
+		DDP_COMPONENT_MERGE5, DDP_COMPONENT_DPI1,
+		MT8195_VDO1_MERGE4_SOUT_SEL, GENMASK(1, 0),
+		MT8195_MERGE4_SOUT_TO_DPI1_SEL
+	}, {
+		DDP_COMPONENT_MERGE5, DDP_COMPONENT_DP_INTF1,
+		MT8195_VDO1_DISP_DP_INTF0_SEL_IN, GENMASK(1, 0),
+		MT8195_DISP_DP_INTF0_SEL_IN_FROM_VPP_MERGE4_MOUT
+	}, {
+		DDP_COMPONENT_MERGE5, DDP_COMPONENT_DP_INTF1,
+		MT8195_VDO1_MERGE4_SOUT_SEL, GENMASK(1, 0),
+		MT8195_MERGE4_SOUT_TO_DP_INTF0_SEL
+	}
+};
+
+/*
+ * mtk_mmsys_config table is used for config mmsys reg in runtime.
+ * MMSYS_CONFIG_MERGE_ASYNC_WIDTH: config merge async width
+ * MMSYS_CONFIG_MERGE_ASYNC_HEIGHT: config merge async height
+ * MMSYS_CONFIG_HDR_BE_ASYNC_WIDTH: config hdr_be async width
+ * MMSYS_CONFIG_HDR_BE_ASYNC_HEIGHT: config hdr_be async height
+ * MMSYS_CONFIG_MIXER_IN_ALPHA_ODD: config mixer odd channel 9bit alpha value
+ * MMSYS_CONFIG_MIXER_IN_ALPHA_EVEN: config mixer even channel 9bit alpha value
+ * MMSYS_CONFIG_MIXER_IN_CH_SWAP: config mixer input RGB channel swap
+ * MMSYS_CONFIG_HDR_ALPHA_SEL: config alpha source
+ * MMSYS_CONFIG_MIXER_IN_MODE: config mixer pad mode(bypass/even extend mode)
+ * MMSYS_CONFIG_MIXER_IN_BIWIDTH: config mixer pad width. formula: width / 2 - 1
+ */
+static const struct mtk_mmsys_config mmsys_mt8195_config_table[] = {
+	{ MMSYS_CONFIG_MERGE_ASYNC_WIDTH, 0, MT8195_VDO1_MERGE0_ASYNC_CFG_WD, GENMASK(13, 0), 0},
+	{ MMSYS_CONFIG_MERGE_ASYNC_HEIGHT, 0, MT8195_VDO1_MERGE0_ASYNC_CFG_WD, GENMASK(29, 16), 16},
+	{ MMSYS_CONFIG_MERGE_ASYNC_WIDTH, 1, MT8195_VDO1_MERGE1_ASYNC_CFG_WD, GENMASK(13, 0), 0},
+	{ MMSYS_CONFIG_MERGE_ASYNC_HEIGHT, 1, MT8195_VDO1_MERGE1_ASYNC_CFG_WD, GENMASK(29, 16), 16},
+	{ MMSYS_CONFIG_MERGE_ASYNC_WIDTH, 2, MT8195_VDO1_MERGE2_ASYNC_CFG_WD, GENMASK(13, 0), 0},
+	{ MMSYS_CONFIG_MERGE_ASYNC_HEIGHT, 2, MT8195_VDO1_MERGE2_ASYNC_CFG_WD, GENMASK(29, 16), 16},
+	{ MMSYS_CONFIG_MERGE_ASYNC_WIDTH, 3, MT8195_VDO1_MERGE3_ASYNC_CFG_WD, GENMASK(13, 0), 0},
+	{ MMSYS_CONFIG_MERGE_ASYNC_HEIGHT, 3, MT8195_VDO1_MERGE3_ASYNC_CFG_WD, GENMASK(29, 16), 16},
+	{ MMSYS_CONFIG_HDR_BE_ASYNC_WIDTH, 0, MT8195_VDO1_HDRBE_ASYNC_CFG_WD, GENMASK(13, 0), 0},
+	{ MMSYS_CONFIG_HDR_BE_ASYNC_HEIGHT, 0, MT8195_VDO1_HDRBE_ASYNC_CFG_WD, GENMASK(29, 16), 16},
+	{ MMSYS_CONFIG_MIXER_IN_ALPHA_ODD, 1, MT8195_VDO1_MIXER_IN1_ALPHA, GENMASK(8, 0), 0},
+	{ MMSYS_CONFIG_MIXER_IN_ALPHA_EVEN, 1, MT8195_VDO1_MIXER_IN1_ALPHA, GENMASK(24, 16), 16},
+	{ MMSYS_CONFIG_MIXER_IN_ALPHA_ODD, 2, MT8195_VDO1_MIXER_IN2_ALPHA, GENMASK(8, 0), 0},
+	{ MMSYS_CONFIG_MIXER_IN_ALPHA_EVEN, 2, MT8195_VDO1_MIXER_IN2_ALPHA, GENMASK(24, 16), 16},
+	{ MMSYS_CONFIG_MIXER_IN_ALPHA_ODD, 3, MT8195_VDO1_MIXER_IN3_ALPHA, GENMASK(8, 0), 0},
+	{ MMSYS_CONFIG_MIXER_IN_ALPHA_EVEN, 3, MT8195_VDO1_MIXER_IN3_ALPHA, GENMASK(24, 16), 16},
+	{ MMSYS_CONFIG_MIXER_IN_ALPHA_ODD, 4, MT8195_VDO1_MIXER_IN4_ALPHA, GENMASK(8, 0), 0},
+	{ MMSYS_CONFIG_MIXER_IN_ALPHA_EVEN, 4, MT8195_VDO1_MIXER_IN4_ALPHA, GENMASK(24, 16), 16},
+	{ MMSYS_CONFIG_MIXER_IN_CH_SWAP, 4, MT8195_VDO1_MIXER_IN4_PAD, GENMASK(4, 4), 4},
+	{ MMSYS_CONFIG_HDR_ALPHA_SEL, 1, MT8195_VDO1_HDR_TOP_CFG, GENMASK(20, 20), 20},
+	{ MMSYS_CONFIG_HDR_ALPHA_SEL, 2, MT8195_VDO1_HDR_TOP_CFG, GENMASK(21, 21), 21},
+	{ MMSYS_CONFIG_HDR_ALPHA_SEL, 3, MT8195_VDO1_HDR_TOP_CFG, GENMASK(22, 22), 22},
+	{ MMSYS_CONFIG_HDR_ALPHA_SEL, 4, MT8195_VDO1_HDR_TOP_CFG, GENMASK(23, 23), 23},
+	{ MMSYS_CONFIG_MIXER_IN_MODE, 1, MT8195_VDO1_MIXER_IN1_PAD, GENMASK(1, 0), 0},
+	{ MMSYS_CONFIG_MIXER_IN_MODE, 2, MT8195_VDO1_MIXER_IN2_PAD, GENMASK(1, 0), 0},
+	{ MMSYS_CONFIG_MIXER_IN_MODE, 3, MT8195_VDO1_MIXER_IN3_PAD, GENMASK(1, 0), 0},
+	{ MMSYS_CONFIG_MIXER_IN_MODE, 4, MT8195_VDO1_MIXER_IN4_PAD, GENMASK(1, 0), 0},
+	{ MMSYS_CONFIG_MIXER_IN_BIWIDTH, 1, MT8195_VDO1_MIXER_IN1_PAD, GENMASK(31, 16), 16},
+	{ MMSYS_CONFIG_MIXER_IN_BIWIDTH, 2, MT8195_VDO1_MIXER_IN2_PAD, GENMASK(31, 16), 16},
+	{ MMSYS_CONFIG_MIXER_IN_BIWIDTH, 3, MT8195_VDO1_MIXER_IN3_PAD, GENMASK(31, 16), 16},
+	{ MMSYS_CONFIG_MIXER_IN_BIWIDTH, 4, MT8195_VDO1_MIXER_IN4_PAD, GENMASK(31, 16), 16},
+};
+
+#endif /* __SOC_MEDIATEK_MT8195_MMSYS_H */
diff --git a/drivers/soc/mediatek/mt8195-pm-domains.h b/drivers/soc/mediatek/mt8195-pm-domains.h
new file mode 100644
index 0000000000000000000000000000000000000000..bb1637c740f69d338f035e1489ae0764a16f7ac2
--- /dev/null
+++ b/drivers/soc/mediatek/mt8195-pm-domains.h
@@ -0,0 +1,613 @@
+/* SPDX-License-Identifier: (GPL-2.0 OR MIT) */
+/*
+ * Copyright (c) 2021 MediaTek Inc.
+ * Author: Chun-Jie Chen <chun-jie.chen@mediatek.com>
+ */
+
+#ifndef __SOC_MEDIATEK_MT8195_PM_DOMAINS_H
+#define __SOC_MEDIATEK_MT8195_PM_DOMAINS_H
+
+#include "mtk-pm-domains.h"
+#include <dt-bindings/power/mt8195-power.h>
+
+/*
+ * MT8195 power domain support
+ */
+
+static const struct scpsys_domain_data scpsys_domain_data_mt8195[] = {
+	[MT8195_POWER_DOMAIN_PCIE_MAC_P0] = {
+		.name = "pcie_mac_p0",
+		.sta_mask = BIT(11),
+		.ctl_offs = 0x328,
+		.pwr_sta_offs = 0x174,
+		.pwr_sta2nd_offs = 0x178,
+		.sram_pdn_bits = GENMASK(8, 8),
+		.sram_pdn_ack_bits = GENMASK(12, 12),
+		.bp_infracfg = {
+			BUS_PROT_WR(MT8195_TOP_AXI_PROT_EN_VDNR_PCIE_MAC_P0,
+				    MT8195_TOP_AXI_PROT_EN_VDNR_SET,
+				    MT8195_TOP_AXI_PROT_EN_VDNR_CLR,
+				    MT8195_TOP_AXI_PROT_EN_VDNR_STA1),
+			BUS_PROT_WR(MT8195_TOP_AXI_PROT_EN_VDNR_1_PCIE_MAC_P0,
+				    MT8195_TOP_AXI_PROT_EN_VDNR_1_SET,
+				    MT8195_TOP_AXI_PROT_EN_VDNR_1_CLR,
+				    MT8195_TOP_AXI_PROT_EN_VDNR_1_STA1),
+		},
+	},
+	[MT8195_POWER_DOMAIN_PCIE_MAC_P1] = {
+		.name = "pcie_mac_p1",
+		.sta_mask = BIT(12),
+		.ctl_offs = 0x32C,
+		.pwr_sta_offs = 0x174,
+		.pwr_sta2nd_offs = 0x178,
+		.sram_pdn_bits = GENMASK(8, 8),
+		.sram_pdn_ack_bits = GENMASK(12, 12),
+		.bp_infracfg = {
+			BUS_PROT_WR(MT8195_TOP_AXI_PROT_EN_VDNR_PCIE_MAC_P1,
+				    MT8195_TOP_AXI_PROT_EN_VDNR_SET,
+				    MT8195_TOP_AXI_PROT_EN_VDNR_CLR,
+				    MT8195_TOP_AXI_PROT_EN_VDNR_STA1),
+			BUS_PROT_WR(MT8195_TOP_AXI_PROT_EN_VDNR_1_PCIE_MAC_P1,
+				    MT8195_TOP_AXI_PROT_EN_VDNR_1_SET,
+				    MT8195_TOP_AXI_PROT_EN_VDNR_1_CLR,
+				    MT8195_TOP_AXI_PROT_EN_VDNR_1_STA1),
+		},
+	},
+	[MT8195_POWER_DOMAIN_PCIE_PHY] = {
+		.name = "pcie_phy",
+		.sta_mask = BIT(13),
+		.ctl_offs = 0x330,
+		.pwr_sta_offs = 0x174,
+		.pwr_sta2nd_offs = 0x178,
+		.caps = MTK_SCPD_ACTIVE_WAKEUP,
+	},
+	[MT8195_POWER_DOMAIN_SSUSB_PCIE_PHY] = {
+		.name = "ssusb_pcie_phy",
+		.sta_mask = BIT(14),
+		.ctl_offs = 0x334,
+		.pwr_sta_offs = 0x174,
+		.pwr_sta2nd_offs = 0x178,
+		.caps = MTK_SCPD_ACTIVE_WAKEUP,
+	},
+	[MT8195_POWER_DOMAIN_CSI_RX_TOP] = {
+		.name = "csi_rx_top",
+		.sta_mask = BIT(18),
+		.ctl_offs = 0x3C4,
+		.pwr_sta_offs = 0x174,
+		.pwr_sta2nd_offs = 0x178,
+		.caps = MTK_SCPD_KEEP_DEFAULT_OFF,
+	},
+	[MT8195_POWER_DOMAIN_ETHER] = {
+		.name = "ether",
+		.sta_mask = BIT(3),
+		.ctl_offs = 0x344,
+		.pwr_sta_offs = 0x16c,
+		.pwr_sta2nd_offs = 0x170,
+		.sram_pdn_bits = GENMASK(8, 8),
+		.sram_pdn_ack_bits = GENMASK(12, 12),
+		.caps = MTK_SCPD_ACTIVE_WAKEUP,
+	},
+	[MT8195_POWER_DOMAIN_ADSP] = {
+		.name = "adsp",
+		.sta_mask = BIT(10),
+		.ctl_offs = 0x360,
+		.pwr_sta_offs = 0x16c,
+		.pwr_sta2nd_offs = 0x170,
+		.sram_pdn_bits = GENMASK(8, 8),
+		.sram_pdn_ack_bits = GENMASK(12, 12),
+		.bp_infracfg = {
+			BUS_PROT_WR(MT8195_TOP_AXI_PROT_EN_2_ADSP,
+				    MT8195_TOP_AXI_PROT_EN_2_SET,
+				    MT8195_TOP_AXI_PROT_EN_2_CLR,
+				    MT8195_TOP_AXI_PROT_EN_2_STA1),
+		},
+		.caps = MTK_SCPD_SRAM_ISO | MTK_SCPD_ACTIVE_WAKEUP,
+	},
+	[MT8195_POWER_DOMAIN_AUDIO] = {
+		.name = "audio",
+		.sta_mask = BIT(8),
+		.ctl_offs = 0x358,
+		.pwr_sta_offs = 0x16c,
+		.pwr_sta2nd_offs = 0x170,
+		.sram_pdn_bits = GENMASK(8, 8),
+		.sram_pdn_ack_bits = GENMASK(12, 12),
+		.bp_infracfg = {
+			BUS_PROT_WR(MT8195_TOP_AXI_PROT_EN_2_AUDIO,
+				    MT8195_TOP_AXI_PROT_EN_2_SET,
+				    MT8195_TOP_AXI_PROT_EN_2_CLR,
+				    MT8195_TOP_AXI_PROT_EN_2_STA1),
+		},
+	},
+	[MT8195_POWER_DOMAIN_MFG0] = {
+		.name = "mfg0",
+		.sta_mask = BIT(1),
+		.ctl_offs = 0x300,
+		.pwr_sta_offs = 0x174,
+		.pwr_sta2nd_offs = 0x178,
+		.sram_pdn_bits = GENMASK(8, 8),
+		.sram_pdn_ack_bits = GENMASK(12, 12),
+		.caps = MTK_SCPD_KEEP_DEFAULT_OFF | MTK_SCPD_DOMAIN_SUPPLY,
+	},
+	[MT8195_POWER_DOMAIN_MFG1] = {
+		.name = "mfg1",
+		.sta_mask = BIT(2),
+		.ctl_offs = 0x304,
+		.pwr_sta_offs = 0x174,
+		.pwr_sta2nd_offs = 0x178,
+		.sram_pdn_bits = GENMASK(8, 8),
+		.sram_pdn_ack_bits = GENMASK(12, 12),
+		.bp_infracfg = {
+			BUS_PROT_WR(MT8195_TOP_AXI_PROT_EN_MFG1,
+				    MT8195_TOP_AXI_PROT_EN_SET,
+				    MT8195_TOP_AXI_PROT_EN_CLR,
+				    MT8195_TOP_AXI_PROT_EN_STA1),
+			BUS_PROT_WR(MT8195_TOP_AXI_PROT_EN_2_MFG1,
+				    MT8195_TOP_AXI_PROT_EN_2_SET,
+				    MT8195_TOP_AXI_PROT_EN_2_CLR,
+				    MT8195_TOP_AXI_PROT_EN_2_STA1),
+			BUS_PROT_WR(MT8195_TOP_AXI_PROT_EN_1_MFG1,
+				    MT8195_TOP_AXI_PROT_EN_1_SET,
+				    MT8195_TOP_AXI_PROT_EN_1_CLR,
+				    MT8195_TOP_AXI_PROT_EN_1_STA1),
+			BUS_PROT_WR(MT8195_TOP_AXI_PROT_EN_2_MFG1_2ND,
+				    MT8195_TOP_AXI_PROT_EN_2_SET,
+				    MT8195_TOP_AXI_PROT_EN_2_CLR,
+				    MT8195_TOP_AXI_PROT_EN_2_STA1),
+			BUS_PROT_WR(MT8195_TOP_AXI_PROT_EN_MFG1_2ND,
+				    MT8195_TOP_AXI_PROT_EN_SET,
+				    MT8195_TOP_AXI_PROT_EN_CLR,
+				    MT8195_TOP_AXI_PROT_EN_STA1),
+			BUS_PROT_WR(MT8195_TOP_AXI_PROT_EN_SUB_INFRA_VDNR_MFG1,
+				    MT8195_TOP_AXI_PROT_EN_SUB_INFRA_VDNR_SET,
+				    MT8195_TOP_AXI_PROT_EN_SUB_INFRA_VDNR_CLR,
+				    MT8195_TOP_AXI_PROT_EN_SUB_INFRA_VDNR_STA1),
+		},
+		.caps = MTK_SCPD_KEEP_DEFAULT_OFF,
+	},
+	[MT8195_POWER_DOMAIN_MFG2] = {
+		.name = "mfg2",
+		.sta_mask = BIT(3),
+		.ctl_offs = 0x308,
+		.pwr_sta_offs = 0x174,
+		.pwr_sta2nd_offs = 0x178,
+		.sram_pdn_bits = GENMASK(8, 8),
+		.sram_pdn_ack_bits = GENMASK(12, 12),
+		.caps = MTK_SCPD_KEEP_DEFAULT_OFF,
+	},
+	[MT8195_POWER_DOMAIN_MFG3] = {
+		.name = "mfg3",
+		.sta_mask = BIT(4),
+		.ctl_offs = 0x30C,
+		.pwr_sta_offs = 0x174,
+		.pwr_sta2nd_offs = 0x178,
+		.sram_pdn_bits = GENMASK(8, 8),
+		.sram_pdn_ack_bits = GENMASK(12, 12),
+		.caps = MTK_SCPD_KEEP_DEFAULT_OFF,
+	},
+	[MT8195_POWER_DOMAIN_MFG4] = {
+		.name = "mfg4",
+		.sta_mask = BIT(5),
+		.ctl_offs = 0x310,
+		.pwr_sta_offs = 0x174,
+		.pwr_sta2nd_offs = 0x178,
+		.sram_pdn_bits = GENMASK(8, 8),
+		.sram_pdn_ack_bits = GENMASK(12, 12),
+		.caps = MTK_SCPD_KEEP_DEFAULT_OFF,
+	},
+	[MT8195_POWER_DOMAIN_MFG5] = {
+		.name = "mfg5",
+		.sta_mask = BIT(6),
+		.ctl_offs = 0x314,
+		.pwr_sta_offs = 0x174,
+		.pwr_sta2nd_offs = 0x178,
+		.sram_pdn_bits = GENMASK(8, 8),
+		.sram_pdn_ack_bits = GENMASK(12, 12),
+		.caps = MTK_SCPD_KEEP_DEFAULT_OFF,
+	},
+	[MT8195_POWER_DOMAIN_MFG6] = {
+		.name = "mfg6",
+		.sta_mask = BIT(7),
+		.ctl_offs = 0x318,
+		.pwr_sta_offs = 0x174,
+		.pwr_sta2nd_offs = 0x178,
+		.sram_pdn_bits = GENMASK(8, 8),
+		.sram_pdn_ack_bits = GENMASK(12, 12),
+		.caps = MTK_SCPD_KEEP_DEFAULT_OFF,
+	},
+	[MT8195_POWER_DOMAIN_VPPSYS0] = {
+		.name = "vppsys0",
+		.sta_mask = BIT(11),
+		.ctl_offs = 0x364,
+		.pwr_sta_offs = 0x16c,
+		.pwr_sta2nd_offs = 0x170,
+		.sram_pdn_bits = GENMASK(8, 8),
+		.sram_pdn_ack_bits = GENMASK(12, 12),
+		.bp_infracfg = {
+			BUS_PROT_WR(MT8195_TOP_AXI_PROT_EN_VPPSYS0,
+				    MT8195_TOP_AXI_PROT_EN_SET,
+				    MT8195_TOP_AXI_PROT_EN_CLR,
+				    MT8195_TOP_AXI_PROT_EN_STA1),
+			BUS_PROT_WR(MT8195_TOP_AXI_PROT_EN_MM_2_VPPSYS0,
+				    MT8195_TOP_AXI_PROT_EN_MM_2_SET,
+				    MT8195_TOP_AXI_PROT_EN_MM_2_CLR,
+				    MT8195_TOP_AXI_PROT_EN_MM_2_STA1),
+			BUS_PROT_WR(MT8195_TOP_AXI_PROT_EN_VPPSYS0_2ND,
+				    MT8195_TOP_AXI_PROT_EN_SET,
+				    MT8195_TOP_AXI_PROT_EN_CLR,
+				    MT8195_TOP_AXI_PROT_EN_STA1),
+			BUS_PROT_WR(MT8195_TOP_AXI_PROT_EN_MM_2_VPPSYS0_2ND,
+				    MT8195_TOP_AXI_PROT_EN_MM_2_SET,
+				    MT8195_TOP_AXI_PROT_EN_MM_2_CLR,
+				    MT8195_TOP_AXI_PROT_EN_MM_2_STA1),
+			BUS_PROT_WR(MT8195_TOP_AXI_PROT_EN_SUB_INFRA_VDNR_VPPSYS0,
+				    MT8195_TOP_AXI_PROT_EN_SUB_INFRA_VDNR_SET,
+				    MT8195_TOP_AXI_PROT_EN_SUB_INFRA_VDNR_CLR,
+				    MT8195_TOP_AXI_PROT_EN_SUB_INFRA_VDNR_STA1),
+		},
+	},
+	[MT8195_POWER_DOMAIN_VDOSYS0] = {
+		.name = "vdosys0",
+		.sta_mask = BIT(13),
+		.ctl_offs = 0x36C,
+		.pwr_sta_offs = 0x16c,
+		.pwr_sta2nd_offs = 0x170,
+		.sram_pdn_bits = GENMASK(8, 8),
+		.sram_pdn_ack_bits = GENMASK(12, 12),
+		.bp_infracfg = {
+			BUS_PROT_WR(MT8195_TOP_AXI_PROT_EN_MM_VDOSYS0,
+				    MT8195_TOP_AXI_PROT_EN_MM_SET,
+				    MT8195_TOP_AXI_PROT_EN_MM_CLR,
+				    MT8195_TOP_AXI_PROT_EN_MM_STA1),
+			BUS_PROT_WR(MT8195_TOP_AXI_PROT_EN_VDOSYS0,
+				    MT8195_TOP_AXI_PROT_EN_SET,
+				    MT8195_TOP_AXI_PROT_EN_CLR,
+				    MT8195_TOP_AXI_PROT_EN_STA1),
+			BUS_PROT_WR(MT8195_TOP_AXI_PROT_EN_SUB_INFRA_VDNR_VDOSYS0,
+				    MT8195_TOP_AXI_PROT_EN_SUB_INFRA_VDNR_SET,
+				    MT8195_TOP_AXI_PROT_EN_SUB_INFRA_VDNR_CLR,
+				    MT8195_TOP_AXI_PROT_EN_SUB_INFRA_VDNR_STA1),
+		},
+	},
+	[MT8195_POWER_DOMAIN_VPPSYS1] = {
+		.name = "vppsys1",
+		.sta_mask = BIT(12),
+		.ctl_offs = 0x368,
+		.pwr_sta_offs = 0x16c,
+		.pwr_sta2nd_offs = 0x170,
+		.sram_pdn_bits = GENMASK(8, 8),
+		.sram_pdn_ack_bits = GENMASK(12, 12),
+		.bp_infracfg = {
+			BUS_PROT_WR(MT8195_TOP_AXI_PROT_EN_MM_VPPSYS1,
+				    MT8195_TOP_AXI_PROT_EN_MM_SET,
+				    MT8195_TOP_AXI_PROT_EN_MM_CLR,
+				    MT8195_TOP_AXI_PROT_EN_MM_STA1),
+			BUS_PROT_WR(MT8195_TOP_AXI_PROT_EN_MM_VPPSYS1_2ND,
+				    MT8195_TOP_AXI_PROT_EN_MM_SET,
+				    MT8195_TOP_AXI_PROT_EN_MM_CLR,
+				    MT8195_TOP_AXI_PROT_EN_MM_STA1),
+			BUS_PROT_WR(MT8195_TOP_AXI_PROT_EN_MM_2_VPPSYS1,
+				    MT8195_TOP_AXI_PROT_EN_MM_2_SET,
+				    MT8195_TOP_AXI_PROT_EN_MM_2_CLR,
+				    MT8195_TOP_AXI_PROT_EN_MM_2_STA1),
+		},
+	},
+	[MT8195_POWER_DOMAIN_VDOSYS1] = {
+		.name = "vdosys1",
+		.sta_mask = BIT(14),
+		.ctl_offs = 0x370,
+		.pwr_sta_offs = 0x16c,
+		.pwr_sta2nd_offs = 0x170,
+		.sram_pdn_bits = GENMASK(8, 8),
+		.sram_pdn_ack_bits = GENMASK(12, 12),
+		.bp_infracfg = {
+			BUS_PROT_WR(MT8195_TOP_AXI_PROT_EN_MM_VDOSYS1,
+				    MT8195_TOP_AXI_PROT_EN_MM_SET,
+				    MT8195_TOP_AXI_PROT_EN_MM_CLR,
+				    MT8195_TOP_AXI_PROT_EN_MM_STA1),
+			BUS_PROT_WR(MT8195_TOP_AXI_PROT_EN_MM_VDOSYS1_2ND,
+				    MT8195_TOP_AXI_PROT_EN_MM_SET,
+				    MT8195_TOP_AXI_PROT_EN_MM_CLR,
+				    MT8195_TOP_AXI_PROT_EN_MM_STA1),
+			BUS_PROT_WR(MT8195_TOP_AXI_PROT_EN_MM_2_VDOSYS1,
+				    MT8195_TOP_AXI_PROT_EN_MM_2_SET,
+				    MT8195_TOP_AXI_PROT_EN_MM_2_CLR,
+				    MT8195_TOP_AXI_PROT_EN_MM_2_STA1),
+		},
+	},
+	[MT8195_POWER_DOMAIN_DP_TX] = {
+		.name = "dp_tx",
+		.sta_mask = BIT(16),
+		.ctl_offs = 0x378,
+		.pwr_sta_offs = 0x16c,
+		.pwr_sta2nd_offs = 0x170,
+		.sram_pdn_bits = GENMASK(8, 8),
+		.sram_pdn_ack_bits = GENMASK(12, 12),
+		.bp_infracfg = {
+			BUS_PROT_WR(MT8195_TOP_AXI_PROT_EN_VDNR_1_DP_TX,
+				    MT8195_TOP_AXI_PROT_EN_VDNR_1_SET,
+				    MT8195_TOP_AXI_PROT_EN_VDNR_1_CLR,
+				    MT8195_TOP_AXI_PROT_EN_VDNR_1_STA1),
+		},
+		.caps = MTK_SCPD_KEEP_DEFAULT_OFF,
+	},
+	[MT8195_POWER_DOMAIN_EPD_TX] = {
+		.name = "epd_tx",
+		.sta_mask = BIT(17),
+		.ctl_offs = 0x37C,
+		.pwr_sta_offs = 0x16c,
+		.pwr_sta2nd_offs = 0x170,
+		.sram_pdn_bits = GENMASK(8, 8),
+		.sram_pdn_ack_bits = GENMASK(12, 12),
+		.bp_infracfg = {
+			BUS_PROT_WR(MT8195_TOP_AXI_PROT_EN_VDNR_1_EPD_TX,
+				    MT8195_TOP_AXI_PROT_EN_VDNR_1_SET,
+				    MT8195_TOP_AXI_PROT_EN_VDNR_1_CLR,
+				    MT8195_TOP_AXI_PROT_EN_VDNR_1_STA1),
+		},
+		.caps = MTK_SCPD_KEEP_DEFAULT_OFF,
+	},
+	[MT8195_POWER_DOMAIN_HDMI_TX] = {
+		.name = "hdmi_tx",
+		.sta_mask = BIT(18),
+		.ctl_offs = 0x380,
+		.pwr_sta_offs = 0x16c,
+		.pwr_sta2nd_offs = 0x170,
+		.sram_pdn_bits = GENMASK(8, 8),
+		.sram_pdn_ack_bits = GENMASK(12, 12),
+		.caps = MTK_SCPD_KEEP_DEFAULT_OFF | MTK_SCPD_ACTIVE_WAKEUP,
+	},
+	[MT8195_POWER_DOMAIN_WPESYS] = {
+		.name = "wpesys",
+		.sta_mask = BIT(15),
+		.ctl_offs = 0x374,
+		.pwr_sta_offs = 0x16c,
+		.pwr_sta2nd_offs = 0x170,
+		.sram_pdn_bits = GENMASK(8, 8),
+		.sram_pdn_ack_bits = GENMASK(12, 12),
+		.bp_infracfg = {
+			BUS_PROT_WR(MT8195_TOP_AXI_PROT_EN_MM_2_WPESYS,
+				    MT8195_TOP_AXI_PROT_EN_MM_2_SET,
+				    MT8195_TOP_AXI_PROT_EN_MM_2_CLR,
+				    MT8195_TOP_AXI_PROT_EN_MM_2_STA1),
+			BUS_PROT_WR(MT8195_TOP_AXI_PROT_EN_MM_WPESYS,
+				    MT8195_TOP_AXI_PROT_EN_MM_SET,
+				    MT8195_TOP_AXI_PROT_EN_MM_CLR,
+				    MT8195_TOP_AXI_PROT_EN_MM_STA1),
+			BUS_PROT_WR(MT8195_TOP_AXI_PROT_EN_MM_2_WPESYS_2ND,
+				    MT8195_TOP_AXI_PROT_EN_MM_2_SET,
+				    MT8195_TOP_AXI_PROT_EN_MM_2_CLR,
+				    MT8195_TOP_AXI_PROT_EN_MM_2_STA1),
+		},
+	},
+	[MT8195_POWER_DOMAIN_VDEC0] = {
+		.name = "vdec0",
+		.sta_mask = BIT(20),
+		.ctl_offs = 0x388,
+		.pwr_sta_offs = 0x16c,
+		.pwr_sta2nd_offs = 0x170,
+		.sram_pdn_bits = GENMASK(8, 8),
+		.sram_pdn_ack_bits = GENMASK(12, 12),
+		.bp_infracfg = {
+			BUS_PROT_WR(MT8195_TOP_AXI_PROT_EN_MM_VDEC0,
+				    MT8195_TOP_AXI_PROT_EN_MM_SET,
+				    MT8195_TOP_AXI_PROT_EN_MM_CLR,
+				    MT8195_TOP_AXI_PROT_EN_MM_STA1),
+			BUS_PROT_WR(MT8195_TOP_AXI_PROT_EN_MM_2_VDEC0,
+				    MT8195_TOP_AXI_PROT_EN_MM_2_SET,
+				    MT8195_TOP_AXI_PROT_EN_MM_2_CLR,
+				    MT8195_TOP_AXI_PROT_EN_MM_2_STA1),
+			BUS_PROT_WR(MT8195_TOP_AXI_PROT_EN_MM_VDEC0_2ND,
+				    MT8195_TOP_AXI_PROT_EN_MM_SET,
+				    MT8195_TOP_AXI_PROT_EN_MM_CLR,
+				    MT8195_TOP_AXI_PROT_EN_MM_STA1),
+			BUS_PROT_WR(MT8195_TOP_AXI_PROT_EN_MM_2_VDEC0_2ND,
+				    MT8195_TOP_AXI_PROT_EN_MM_2_SET,
+				    MT8195_TOP_AXI_PROT_EN_MM_2_CLR,
+				    MT8195_TOP_AXI_PROT_EN_MM_2_STA1),
+		},
+		.caps = MTK_SCPD_KEEP_DEFAULT_OFF,
+	},
+	[MT8195_POWER_DOMAIN_VDEC1] = {
+		.name = "vdec1",
+		.sta_mask = BIT(21),
+		.ctl_offs = 0x38C,
+		.pwr_sta_offs = 0x16c,
+		.pwr_sta2nd_offs = 0x170,
+		.sram_pdn_bits = GENMASK(8, 8),
+		.sram_pdn_ack_bits = GENMASK(12, 12),
+		.bp_infracfg = {
+			BUS_PROT_WR(MT8195_TOP_AXI_PROT_EN_MM_VDEC1,
+				    MT8195_TOP_AXI_PROT_EN_MM_SET,
+				    MT8195_TOP_AXI_PROT_EN_MM_CLR,
+				    MT8195_TOP_AXI_PROT_EN_MM_STA1),
+			BUS_PROT_WR(MT8195_TOP_AXI_PROT_EN_MM_VDEC1_2ND,
+				    MT8195_TOP_AXI_PROT_EN_MM_SET,
+				    MT8195_TOP_AXI_PROT_EN_MM_CLR,
+				    MT8195_TOP_AXI_PROT_EN_MM_STA1),
+		},
+		.caps = MTK_SCPD_KEEP_DEFAULT_OFF,
+	},
+	[MT8195_POWER_DOMAIN_VDEC2] = {
+		.name = "vdec2",
+		.sta_mask = BIT(22),
+		.ctl_offs = 0x390,
+		.pwr_sta_offs = 0x16c,
+		.pwr_sta2nd_offs = 0x170,
+		.sram_pdn_bits = GENMASK(8, 8),
+		.sram_pdn_ack_bits = GENMASK(12, 12),
+		.bp_infracfg = {
+			BUS_PROT_WR(MT8195_TOP_AXI_PROT_EN_MM_2_VDEC2,
+				    MT8195_TOP_AXI_PROT_EN_MM_2_SET,
+				    MT8195_TOP_AXI_PROT_EN_MM_2_CLR,
+				    MT8195_TOP_AXI_PROT_EN_MM_2_STA1),
+			BUS_PROT_WR(MT8195_TOP_AXI_PROT_EN_MM_2_VDEC2_2ND,
+				    MT8195_TOP_AXI_PROT_EN_MM_2_SET,
+				    MT8195_TOP_AXI_PROT_EN_MM_2_CLR,
+				    MT8195_TOP_AXI_PROT_EN_MM_2_STA1),
+		},
+		.caps = MTK_SCPD_KEEP_DEFAULT_OFF,
+	},
+	[MT8195_POWER_DOMAIN_VENC] = {
+		.name = "venc",
+		.sta_mask = BIT(23),
+		.ctl_offs = 0x394,
+		.pwr_sta_offs = 0x16c,
+		.pwr_sta2nd_offs = 0x170,
+		.sram_pdn_bits = GENMASK(8, 8),
+		.sram_pdn_ack_bits = GENMASK(12, 12),
+		.bp_infracfg = {
+			BUS_PROT_WR(MT8195_TOP_AXI_PROT_EN_MM_VENC,
+				    MT8195_TOP_AXI_PROT_EN_MM_SET,
+				    MT8195_TOP_AXI_PROT_EN_MM_CLR,
+				    MT8195_TOP_AXI_PROT_EN_MM_STA1),
+			BUS_PROT_WR(MT8195_TOP_AXI_PROT_EN_MM_VENC_2ND,
+				    MT8195_TOP_AXI_PROT_EN_MM_SET,
+				    MT8195_TOP_AXI_PROT_EN_MM_CLR,
+				    MT8195_TOP_AXI_PROT_EN_MM_STA1),
+			BUS_PROT_WR(MT8195_TOP_AXI_PROT_EN_MM_2_VENC,
+				    MT8195_TOP_AXI_PROT_EN_MM_2_SET,
+				    MT8195_TOP_AXI_PROT_EN_MM_2_CLR,
+				    MT8195_TOP_AXI_PROT_EN_MM_2_STA1),
+		},
+		.caps = MTK_SCPD_KEEP_DEFAULT_OFF,
+	},
+	[MT8195_POWER_DOMAIN_VENC_CORE1] = {
+		.name = "venc_core1",
+		.sta_mask = BIT(24),
+		.ctl_offs = 0x398,
+		.pwr_sta_offs = 0x16c,
+		.pwr_sta2nd_offs = 0x170,
+		.sram_pdn_bits = GENMASK(8, 8),
+		.sram_pdn_ack_bits = GENMASK(12, 12),
+		.bp_infracfg = {
+			BUS_PROT_WR(MT8195_TOP_AXI_PROT_EN_MM_VENC_CORE1,
+				    MT8195_TOP_AXI_PROT_EN_MM_SET,
+				    MT8195_TOP_AXI_PROT_EN_MM_CLR,
+				    MT8195_TOP_AXI_PROT_EN_MM_STA1),
+			BUS_PROT_WR(MT8195_TOP_AXI_PROT_EN_MM_2_VENC_CORE1,
+				    MT8195_TOP_AXI_PROT_EN_MM_2_SET,
+				    MT8195_TOP_AXI_PROT_EN_MM_2_CLR,
+				    MT8195_TOP_AXI_PROT_EN_MM_2_STA1),
+		},
+		.caps = MTK_SCPD_KEEP_DEFAULT_OFF,
+	},
+	[MT8195_POWER_DOMAIN_IMG] = {
+		.name = "img",
+		.sta_mask = BIT(29),
+		.ctl_offs = 0x3AC,
+		.pwr_sta_offs = 0x16c,
+		.pwr_sta2nd_offs = 0x170,
+		.sram_pdn_bits = GENMASK(8, 8),
+		.sram_pdn_ack_bits = GENMASK(12, 12),
+		.bp_infracfg = {
+			BUS_PROT_WR(MT8195_TOP_AXI_PROT_EN_MM_IMG,
+				    MT8195_TOP_AXI_PROT_EN_MM_SET,
+				    MT8195_TOP_AXI_PROT_EN_MM_CLR,
+				    MT8195_TOP_AXI_PROT_EN_MM_STA1),
+			BUS_PROT_WR(MT8195_TOP_AXI_PROT_EN_MM_IMG_2ND,
+				    MT8195_TOP_AXI_PROT_EN_MM_SET,
+				    MT8195_TOP_AXI_PROT_EN_MM_CLR,
+				    MT8195_TOP_AXI_PROT_EN_MM_STA1),
+		},
+		.caps = MTK_SCPD_KEEP_DEFAULT_OFF,
+	},
+	[MT8195_POWER_DOMAIN_DIP] = {
+		.name = "dip",
+		.sta_mask = BIT(30),
+		.ctl_offs = 0x3B0,
+		.pwr_sta_offs = 0x16c,
+		.pwr_sta2nd_offs = 0x170,
+		.sram_pdn_bits = GENMASK(8, 8),
+		.sram_pdn_ack_bits = GENMASK(12, 12),
+		.caps = MTK_SCPD_KEEP_DEFAULT_OFF,
+	},
+	[MT8195_POWER_DOMAIN_IPE] = {
+		.name = "ipe",
+		.sta_mask = BIT(31),
+		.ctl_offs = 0x3B4,
+		.pwr_sta_offs = 0x16c,
+		.pwr_sta2nd_offs = 0x170,
+		.sram_pdn_bits = GENMASK(8, 8),
+		.sram_pdn_ack_bits = GENMASK(12, 12),
+		.bp_infracfg = {
+			BUS_PROT_WR(MT8195_TOP_AXI_PROT_EN_MM_IPE,
+				    MT8195_TOP_AXI_PROT_EN_MM_SET,
+				    MT8195_TOP_AXI_PROT_EN_MM_CLR,
+				    MT8195_TOP_AXI_PROT_EN_MM_STA1),
+			BUS_PROT_WR(MT8195_TOP_AXI_PROT_EN_MM_2_IPE,
+				    MT8195_TOP_AXI_PROT_EN_MM_2_SET,
+				    MT8195_TOP_AXI_PROT_EN_MM_2_CLR,
+				    MT8195_TOP_AXI_PROT_EN_MM_2_STA1),
+		},
+		.caps = MTK_SCPD_KEEP_DEFAULT_OFF,
+	},
+	[MT8195_POWER_DOMAIN_CAM] = {
+		.name = "cam",
+		.sta_mask = BIT(25),
+		.ctl_offs = 0x39C,
+		.pwr_sta_offs = 0x16c,
+		.pwr_sta2nd_offs = 0x170,
+		.sram_pdn_bits = GENMASK(8, 8),
+		.sram_pdn_ack_bits = GENMASK(12, 12),
+		.bp_infracfg = {
+			BUS_PROT_WR(MT8195_TOP_AXI_PROT_EN_2_CAM,
+				    MT8195_TOP_AXI_PROT_EN_2_SET,
+				    MT8195_TOP_AXI_PROT_EN_2_CLR,
+				    MT8195_TOP_AXI_PROT_EN_2_STA1),
+			BUS_PROT_WR(MT8195_TOP_AXI_PROT_EN_MM_CAM,
+				    MT8195_TOP_AXI_PROT_EN_MM_SET,
+				    MT8195_TOP_AXI_PROT_EN_MM_CLR,
+				    MT8195_TOP_AXI_PROT_EN_MM_STA1),
+			BUS_PROT_WR(MT8195_TOP_AXI_PROT_EN_1_CAM,
+				    MT8195_TOP_AXI_PROT_EN_1_SET,
+				    MT8195_TOP_AXI_PROT_EN_1_CLR,
+				    MT8195_TOP_AXI_PROT_EN_1_STA1),
+			BUS_PROT_WR(MT8195_TOP_AXI_PROT_EN_MM_CAM_2ND,
+				    MT8195_TOP_AXI_PROT_EN_MM_SET,
+				    MT8195_TOP_AXI_PROT_EN_MM_CLR,
+				    MT8195_TOP_AXI_PROT_EN_MM_STA1),
+			BUS_PROT_WR(MT8195_TOP_AXI_PROT_EN_MM_2_CAM,
+				    MT8195_TOP_AXI_PROT_EN_MM_2_SET,
+				    MT8195_TOP_AXI_PROT_EN_MM_2_CLR,
+				    MT8195_TOP_AXI_PROT_EN_MM_2_STA1),
+		},
+		.caps = MTK_SCPD_KEEP_DEFAULT_OFF,
+	},
+	[MT8195_POWER_DOMAIN_CAM_RAWA] = {
+		.name = "cam_rawa",
+		.sta_mask = BIT(26),
+		.ctl_offs = 0x3A0,
+		.pwr_sta_offs = 0x16c,
+		.pwr_sta2nd_offs = 0x170,
+		.sram_pdn_bits = GENMASK(8, 8),
+		.sram_pdn_ack_bits = GENMASK(12, 12),
+		.caps = MTK_SCPD_KEEP_DEFAULT_OFF,
+	},
+	[MT8195_POWER_DOMAIN_CAM_RAWB] = {
+		.name = "cam_rawb",
+		.sta_mask = BIT(27),
+		.ctl_offs = 0x3A4,
+		.pwr_sta_offs = 0x16c,
+		.pwr_sta2nd_offs = 0x170,
+		.sram_pdn_bits = GENMASK(8, 8),
+		.sram_pdn_ack_bits = GENMASK(12, 12),
+		.caps = MTK_SCPD_KEEP_DEFAULT_OFF,
+	},
+	[MT8195_POWER_DOMAIN_CAM_MRAW] = {
+		.name = "cam_mraw",
+		.sta_mask = BIT(28),
+		.ctl_offs = 0x3A8,
+		.pwr_sta_offs = 0x16c,
+		.pwr_sta2nd_offs = 0x170,
+		.sram_pdn_bits = GENMASK(8, 8),
+		.sram_pdn_ack_bits = GENMASK(12, 12),
+		.caps = MTK_SCPD_KEEP_DEFAULT_OFF,
+	},
+};
+
+static const struct scpsys_soc_data mt8195_scpsys_data = {
+	.domains_data = scpsys_domain_data_mt8195,
+	.num_domains = ARRAY_SIZE(scpsys_domain_data_mt8195),
+};
+
+#endif /* __SOC_MEDIATEK_MT8195_PM_DOMAINS_H */
diff --git a/drivers/soc/mediatek/mt8365-mmsys.h b/drivers/soc/mediatek/mt8365-mmsys.h
new file mode 100644
index 0000000000000000000000000000000000000000..2475aeb797914261501c266e71c95c1900b25e5f
--- /dev/null
+++ b/drivers/soc/mediatek/mt8365-mmsys.h
@@ -0,0 +1,60 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+
+#ifndef __SOC_MEDIATEK_MT8365_MMSYS_H
+#define __SOC_MEDIATEK_MT8365_MMSYS_H
+
+#define MT8365_DISP_REG_CONFIG_DISP_OVL0_MOUT_EN	0xf3c
+#define MT8365_DISP_REG_CONFIG_DISP_RDMA0_SOUT_SEL	0xf4c
+#define MT8365_DISP_REG_CONFIG_DISP_DITHER0_MOUT_EN	0xf50
+#define MT8365_DISP_REG_CONFIG_DISP_RDMA0_SEL_IN	0xf54
+#define MT8365_DISP_REG_CONFIG_DISP_RDMA0_RSZ0_SEL_IN	0xf60
+#define MT8365_DISP_REG_CONFIG_DISP_COLOR0_SEL_IN	0xf64
+#define MT8365_DISP_REG_CONFIG_DISP_DSI0_SEL_IN		0xf68
+
+#define MT8365_RDMA0_SOUT_COLOR0			0x1
+#define MT8365_DITHER_MOUT_EN_DSI0			0x1
+#define MT8365_DSI0_SEL_IN_DITHER			0x1
+#define MT8365_RDMA0_SEL_IN_OVL0			0x0
+#define MT8365_RDMA0_RSZ0_SEL_IN_RDMA0			0x0
+#define MT8365_DISP_COLOR_SEL_IN_COLOR0			0x0
+#define MT8365_OVL0_MOUT_PATH0_SEL			BIT(0)
+
+static const struct mtk_mmsys_routes mt8365_mmsys_routing_table[] = {
+	{
+		DDP_COMPONENT_OVL0, DDP_COMPONENT_RDMA0,
+		MT8365_DISP_REG_CONFIG_DISP_OVL0_MOUT_EN,
+		MT8365_OVL0_MOUT_PATH0_SEL
+	},
+	{
+		DDP_COMPONENT_OVL0, DDP_COMPONENT_RDMA0,
+		MT8365_DISP_REG_CONFIG_DISP_RDMA0_SEL_IN,
+		MT8365_RDMA0_SEL_IN_OVL0
+	},
+	{
+		DDP_COMPONENT_RDMA0, DDP_COMPONENT_COLOR0,
+		MT8365_DISP_REG_CONFIG_DISP_RDMA0_SOUT_SEL,
+		MT8365_RDMA0_SOUT_COLOR0
+	},
+	{
+		DDP_COMPONENT_COLOR0, DDP_COMPONENT_CCORR,
+		MT8365_DISP_REG_CONFIG_DISP_COLOR0_SEL_IN,
+		MT8365_DISP_COLOR_SEL_IN_COLOR0
+	},
+	{
+		DDP_COMPONENT_DITHER, DDP_COMPONENT_DSI0,
+		MT8365_DISP_REG_CONFIG_DISP_DITHER0_MOUT_EN,
+		MT8365_DITHER_MOUT_EN_DSI0
+	},
+	{
+		DDP_COMPONENT_DITHER, DDP_COMPONENT_DSI0,
+		MT8365_DISP_REG_CONFIG_DISP_DSI0_SEL_IN,
+		MT8365_DSI0_SEL_IN_DITHER
+	},
+	{
+		DDP_COMPONENT_RDMA0, DDP_COMPONENT_COLOR0,
+		MT8365_DISP_REG_CONFIG_DISP_RDMA0_RSZ0_SEL_IN,
+		MT8365_RDMA0_RSZ0_SEL_IN_RDMA0
+	},
+};
+
+#endif /* __SOC_MEDIATEK_MT8365_MMSYS_H */
diff --git a/drivers/soc/mediatek/mtk-mmsys.c b/drivers/soc/mediatek/mtk-mmsys.c
index a24b4ca1655cbbb8b5e6462211d0df044c7096f4..722566d5eadd0414c88e61a7793775e348b0e87d 100644
--- a/drivers/soc/mediatek/mtk-mmsys.c
+++ b/drivers/soc/mediatek/mtk-mmsys.c
@@ -4,14 +4,22 @@
  * Author: James Liao <jamesjj.liao@mediatek.com>
  */
 
+#include <linux/delay.h>
 #include <linux/device.h>
 #include <linux/io.h>
 #include <linux/of_device.h>
+#include <linux/of_address.h>
 #include <linux/platform_device.h>
+#include <linux/reset-controller.h>
 #include <linux/soc/mediatek/mtk-mmsys.h>
+#include <linux/soc/mediatek/mtk-cmdq.h>
 
 #include "mtk-mmsys.h"
 #include "mt8183-mmsys.h"
+#include "mt8365-mmsys.h"
+#include "mt8195-mmsys.h"
+
+#define MMSYS_SW_RESET_PER_REG 32
 
 static const struct mtk_mmsys_driver_data mt2701_mmsys_driver_data = {
 	.clk_driver = "clk-mt2701-mm",
@@ -43,11 +51,40 @@ static const struct mtk_mmsys_driver_data mt8183_mmsys_driver_data = {
 	.clk_driver = "clk-mt8183-mm",
 	.routes = mmsys_mt8183_routing_table,
 	.num_routes = ARRAY_SIZE(mmsys_mt8183_routing_table),
+	.mdp_routes = mmsys_mt8183_mdp_routing_table,
+	.mdp_num_routes = ARRAY_SIZE(mmsys_mt8183_mdp_routing_table),
+	.mdp_isp_ctrl = mmsys_mt8183_mdp_isp_ctrl_table,
+};
+
+static const struct mtk_mmsys_driver_data mt8365_mmsys_driver_data = {
+	.clk_driver = "clk-mt8365-mm",
+	.routes = mt8365_mmsys_routing_table,
+	.num_routes = ARRAY_SIZE(mt8365_mmsys_routing_table),
+};
+
+static const struct mtk_mmsys_driver_data mt8195_vdosys0_driver_data = {
+	.clk_driver = "clk-mt8195-vdo0",
+	.routes = mmsys_mt8195_routing_table,
+	.num_routes = ARRAY_SIZE(mmsys_mt8195_routing_table),
+};
+
+static const struct mtk_mmsys_driver_data mt8195_vdosys1_driver_data = {
+	.clk_driver = "clk-mt8195-vdo1",
+	.routes = mmsys_mt8195_routing_table,
+	.num_routes = ARRAY_SIZE(mmsys_mt8195_routing_table),
+	.config = mmsys_mt8195_config_table,
+	.num_configs = ARRAY_SIZE(mmsys_mt8195_config_table),
+	.sw_reset_start = MT8195_VDO1_SW0_RST_B,
 };
 
 struct mtk_mmsys {
 	void __iomem *regs;
 	const struct mtk_mmsys_driver_data *data;
+	struct cmdq_client_reg cmdq_base;
+	spinlock_t lock; /* protects mmsys_sw_rst_b reg */
+	struct reset_controller_dev rcdev;
+	phys_addr_t addr;
+	u8 subsys_id;
 };
 
 void mtk_mmsys_ddp_connect(struct device *dev,
@@ -87,12 +124,253 @@ void mtk_mmsys_ddp_disconnect(struct device *dev,
 }
 EXPORT_SYMBOL_GPL(mtk_mmsys_ddp_disconnect);
 
+void mtk_mmsys_ddp_config(struct device *dev, enum mtk_mmsys_config_type config,
+			  u32 id, u32 val, struct cmdq_pkt *cmdq_pkt)
+{
+	struct mtk_mmsys *mmsys = dev_get_drvdata(dev);
+	const struct mtk_mmsys_config *mmsys_config = mmsys->data->config;
+	u32 reg_val;
+	u32 mask;
+	u32 offset;
+	int i;
+
+	if (!mmsys->data->num_configs)
+		return;
+
+	for (i = 0; i < mmsys->data->num_configs; i++)
+		if (config == mmsys_config[i].config && id == mmsys_config[i].id)
+			break;
+
+	if (i == mmsys->data->num_configs)
+		return;
+
+	offset = mmsys_config[i].addr;
+	mask = mmsys_config[i].mask;
+	reg_val = val << mmsys_config[i].shift;
+
+#if IS_REACHABLE(CONFIG_MTK_CMDQ)
+	if (cmdq_pkt && mmsys->cmdq_base.size) {
+		cmdq_pkt_write_mask(cmdq_pkt, mmsys->cmdq_base.subsys,
+				    mmsys->cmdq_base.offset + offset, reg_val,
+				    mask);
+	} else {
+#endif
+		u32 tmp = readl(mmsys->regs + offset);
+
+		tmp = (tmp & ~mask) | reg_val;
+		writel(tmp, mmsys->regs + offset);
+#if IS_REACHABLE(CONFIG_MTK_CMDQ)
+	}
+#endif
+}
+EXPORT_SYMBOL_GPL(mtk_mmsys_ddp_config);
+
+static int mtk_mmsys_reset_update(struct reset_controller_dev *rcdev, unsigned long id,
+				  bool assert)
+{
+	struct mtk_mmsys *mmsys = container_of(rcdev, struct mtk_mmsys, rcdev);
+	unsigned long flags;
+	u32 reg;
+	u32 offset;
+
+	offset = (id / MMSYS_SW_RESET_PER_REG) * sizeof(u32);
+	id = id % MMSYS_SW_RESET_PER_REG;
+
+	spin_lock_irqsave(&mmsys->lock, flags);
+
+	reg = readl_relaxed(mmsys->regs + mmsys->data->sw_reset_start + offset);
+
+	if (assert)
+		reg &= ~BIT(id);
+	else
+		reg |= BIT(id);
+
+	writel_relaxed(reg, mmsys->regs + mmsys->data->sw_reset_start + offset);
+
+	spin_unlock_irqrestore(&mmsys->lock, flags);
+
+	return 0;
+}
+
+static int mtk_mmsys_reset_assert(struct reset_controller_dev *rcdev, unsigned long id)
+{
+	return mtk_mmsys_reset_update(rcdev, id, true);
+}
+
+static int mtk_mmsys_reset_deassert(struct reset_controller_dev *rcdev, unsigned long id)
+{
+	return mtk_mmsys_reset_update(rcdev, id, false);
+}
+
+static int mtk_mmsys_reset(struct reset_controller_dev *rcdev, unsigned long id)
+{
+	int ret;
+
+	ret = mtk_mmsys_reset_assert(rcdev, id);
+	if (ret)
+		return ret;
+
+	usleep_range(1000, 1100);
+
+	return mtk_mmsys_reset_deassert(rcdev, id);
+}
+
+static const struct reset_control_ops mtk_mmsys_reset_ops = {
+	.assert = mtk_mmsys_reset_assert,
+	.deassert = mtk_mmsys_reset_deassert,
+	.reset = mtk_mmsys_reset,
+};
+
+void mtk_mmsys_mdp_connect(struct device *dev, struct mmsys_cmdq_cmd *cmd,
+			   enum mtk_mdp_comp_id cur,
+			   enum mtk_mdp_comp_id next)
+{
+	struct mtk_mmsys *mmsys = dev_get_drvdata(dev);
+	const struct mtk_mmsys_routes *routes = mmsys->data->mdp_routes;
+	int i;
+
+	WARN_ON(routes == NULL);
+	WARN_ON(mmsys->subsys_id == 0);
+	for (i = 0; i < mmsys->data->mdp_num_routes; i++)
+		if (cur == routes[i].from_comp && next == routes[i].to_comp)
+			cmdq_pkt_write_mask(cmd->pkt, mmsys->subsys_id,
+					    mmsys->addr + routes[i].addr,
+					    routes[i].val, 0xFFFFFFFF);
+}
+EXPORT_SYMBOL_GPL(mtk_mmsys_mdp_connect);
+
+void mtk_mmsys_mdp_disconnect(struct device *dev, struct mmsys_cmdq_cmd *cmd,
+			      enum mtk_mdp_comp_id cur,
+			      enum mtk_mdp_comp_id next)
+{
+	struct mtk_mmsys *mmsys = dev_get_drvdata(dev);
+	const struct mtk_mmsys_routes *routes = mmsys->data->mdp_routes;
+	int i;
+
+	WARN_ON(mmsys->subsys_id == 0);
+	for (i = 0; i < mmsys->data->mdp_num_routes; i++)
+		if (cur == routes[i].from_comp && next == routes[i].to_comp)
+			cmdq_pkt_write_mask(cmd->pkt, mmsys->subsys_id,
+					    mmsys->addr + routes[i].addr,
+					    0, 0xFFFFFFFF);
+}
+EXPORT_SYMBOL_GPL(mtk_mmsys_mdp_disconnect);
+
+void mtk_mmsys_mdp_isp_ctrl(struct device *dev, struct mmsys_cmdq_cmd *cmd,
+			    enum mtk_mdp_comp_id id)
+{
+	struct mtk_mmsys *mmsys = dev_get_drvdata(dev);
+	const unsigned int *isp_ctrl = mmsys->data->mdp_isp_ctrl;
+	u32 reg;
+
+	WARN_ON(mmsys->subsys_id == 0);
+	/* Direct link */
+	if (id == MDP_COMP_CAMIN) {
+		/* Reset MDP_DL_ASYNC_TX */
+		/* Bit  3: MDP_DL_ASYNC_TX / MDP_RELAY */
+		if (isp_ctrl[ISP_CTRL_MMSYS_SW0_RST_B]) {
+			reg = mmsys->addr + isp_ctrl[ISP_CTRL_MMSYS_SW0_RST_B];
+			cmdq_pkt_write_mask(cmd->pkt, mmsys->subsys_id, reg,
+					    0x0, 0x00000008);
+			cmdq_pkt_write_mask(cmd->pkt, mmsys->subsys_id, reg,
+					    1 << 3, 0x00000008);
+		}
+
+		/* Reset MDP_DL_ASYNC_RX */
+		/* Bit  10: MDP_DL_ASYNC_RX */
+		if (isp_ctrl[ISP_CTRL_MMSYS_SW1_RST_B]) {
+			reg = mmsys->addr + isp_ctrl[ISP_CTRL_MMSYS_SW1_RST_B];
+			cmdq_pkt_write_mask(cmd->pkt, mmsys->subsys_id, reg,
+					    0x0, 0x00000400);
+			cmdq_pkt_write_mask(cmd->pkt, mmsys->subsys_id, reg,
+					    1 << 10, 0x00000400);
+		}
+
+		/* Enable sof mode */
+		if (isp_ctrl[ISP_CTRL_ISP_RELAY_CFG_WD]) {
+			reg = mmsys->addr + isp_ctrl[ISP_CTRL_ISP_RELAY_CFG_WD];
+			cmdq_pkt_write_mask(cmd->pkt, mmsys->subsys_id, reg,
+					    0 << 31, 0x80000000);
+		}
+	}
+
+	if (id == MDP_COMP_CAMIN2) {
+		/* Reset MDP_DL_ASYNC2_TX */
+		/* Bit  4: MDP_DL_ASYNC2_TX / MDP_RELAY2 */
+		if (isp_ctrl[ISP_CTRL_MMSYS_SW0_RST_B]) {
+			reg = mmsys->addr + isp_ctrl[ISP_CTRL_MMSYS_SW0_RST_B];
+			cmdq_pkt_write_mask(cmd->pkt, mmsys->subsys_id, reg,
+					    0x0, 0x00000010);
+			cmdq_pkt_write_mask(cmd->pkt, mmsys->subsys_id, reg,
+					    1 << 4, 0x00000010);
+		}
+
+		/* Reset MDP_DL_ASYNC2_RX */
+		/* Bit  11: MDP_DL_ASYNC2_RX */
+		if (isp_ctrl[ISP_CTRL_MMSYS_SW1_RST_B]) {
+			reg = mmsys->addr + isp_ctrl[ISP_CTRL_MMSYS_SW1_RST_B];
+			cmdq_pkt_write_mask(cmd->pkt, mmsys->subsys_id, reg,
+					    0x0, 0x00000800);
+			cmdq_pkt_write_mask(cmd->pkt, mmsys->subsys_id, reg,
+					    1 << 11, 0x00000800);
+		}
+
+		/* Enable sof mode */
+		if (isp_ctrl[ISP_CTRL_IPU_RELAY_CFG_WD]) {
+			reg = mmsys->addr + isp_ctrl[ISP_CTRL_IPU_RELAY_CFG_WD];
+			cmdq_pkt_write_mask(cmd->pkt, mmsys->subsys_id, reg,
+					    0 << 31, 0x80000000);
+		}
+	}
+}
+EXPORT_SYMBOL_GPL(mtk_mmsys_mdp_isp_ctrl);
+
+void mtk_mmsys_mdp_camin_ctrl(struct device *dev, struct mmsys_cmdq_cmd *cmd,
+			      enum mtk_mdp_comp_id id, u32 camin_w, u32 camin_h)
+{
+	struct mtk_mmsys *mmsys = dev_get_drvdata(dev);
+	const unsigned int *isp_ctrl = mmsys->data->mdp_isp_ctrl;
+	u32 reg;
+
+	WARN_ON(mmsys->subsys_id == 0);
+	/* Config for direct link */
+	if (id == MDP_COMP_CAMIN) {
+		if (isp_ctrl[ISP_CTRL_MDP_ASYNC_CFG_WD]) {
+			reg = mmsys->addr + isp_ctrl[ISP_CTRL_MDP_ASYNC_CFG_WD];
+			cmdq_pkt_write_mask(cmd->pkt, mmsys->subsys_id, reg,
+				     (camin_h << 16) + camin_w, 0x3FFF3FFF);
+		}
+
+		if (isp_ctrl[ISP_CTRL_ISP_RELAY_CFG_WD]) {
+			reg = mmsys->addr + isp_ctrl[ISP_CTRL_ISP_RELAY_CFG_WD];
+			cmdq_pkt_write_mask(cmd->pkt, mmsys->subsys_id, reg,
+				     (camin_h << 16) + camin_w, 0x3FFF3FFF);
+		}
+	}
+	if (id == MDP_COMP_CAMIN2) {
+		if (isp_ctrl[ISP_CTRL_MDP_ASYNC_IPU_CFG_WD]) {
+			reg = mmsys->addr +
+			      isp_ctrl[ISP_CTRL_MDP_ASYNC_IPU_CFG_WD];
+			cmdq_pkt_write_mask(cmd->pkt, mmsys->subsys_id, reg,
+				     (camin_h << 16) + camin_w, 0x3FFF3FFF);
+		}
+		if (isp_ctrl[ISP_CTRL_IPU_RELAY_CFG_WD]) {
+			reg = mmsys->addr + isp_ctrl[ISP_CTRL_IPU_RELAY_CFG_WD];
+			cmdq_pkt_write_mask(cmd->pkt, mmsys->subsys_id, reg,
+				     (camin_h << 16) + camin_w, 0x3FFF3FFF);
+		}
+	}
+}
+EXPORT_SYMBOL_GPL(mtk_mmsys_mdp_camin_ctrl);
+
 static int mtk_mmsys_probe(struct platform_device *pdev)
 {
 	struct device *dev = &pdev->dev;
 	struct platform_device *clks;
 	struct platform_device *drm;
 	struct mtk_mmsys *mmsys;
+	struct resource res;
+	struct cmdq_client_reg cmdq_reg;
 	int ret;
 
 	mmsys = devm_kzalloc(dev, sizeof(*mmsys), GFP_KERNEL);
@@ -106,7 +384,35 @@ static int mtk_mmsys_probe(struct platform_device *pdev)
 		return ret;
 	}
 
+	if (of_address_to_resource(dev->of_node, 0, &res) < 0)
+		mmsys->addr = 0L;
+	else
+		mmsys->addr = res.start;
+
+	if (cmdq_dev_get_client_reg(dev, &cmdq_reg, 0) != 0)
+		dev_info(dev, "cmdq subsys id has not been set\n");
+	mmsys->subsys_id = cmdq_reg.subsys;
+
 	mmsys->data = of_device_get_match_data(&pdev->dev);
+
+#if IS_REACHABLE(CONFIG_MTK_CMDQ)
+	ret = cmdq_dev_get_client_reg(dev, &mmsys->cmdq_base, 0);
+	if (ret)
+		dev_dbg(dev, "No mediatek,gce-client-reg!\n");
+#endif
+
+	spin_lock_init(&mmsys->lock);
+
+	mmsys->rcdev.owner = THIS_MODULE;
+	mmsys->rcdev.nr_resets = 64;
+	mmsys->rcdev.ops = &mtk_mmsys_reset_ops;
+	mmsys->rcdev.of_node = pdev->dev.of_node;
+	ret = devm_reset_controller_register(&pdev->dev, &mmsys->rcdev);
+	if (ret) {
+		dev_err(&pdev->dev, "Couldn't register mmsys reset controller: %d\n", ret);
+		return ret;
+	}
+
 	platform_set_drvdata(pdev, mmsys);
 
 	clks = platform_device_register_data(&pdev->dev, mmsys->data->clk_driver,
@@ -149,6 +455,18 @@ static const struct of_device_id of_match_mtk_mmsys[] = {
 		.compatible = "mediatek,mt8183-mmsys",
 		.data = &mt8183_mmsys_driver_data,
 	},
+	{
+		.compatible = "mediatek,mt8365-mmsys",
+		.data = &mt8365_mmsys_driver_data,
+	},
+	{
+		.compatible = "mediatek,mt8195-vdosys0",
+		.data = &mt8195_vdosys0_driver_data,
+	},
+	{
+		.compatible = "mediatek,mt8195-vdosys1",
+		.data = &mt8195_vdosys1_driver_data,
+	},
 	{ }
 };
 
diff --git a/drivers/soc/mediatek/mtk-mmsys.h b/drivers/soc/mediatek/mtk-mmsys.h
index 9e2b81bd38db1a07bb7297342aa17c8bcd744748..56c264e305299000139f033d732c7b734d127ee8 100644
--- a/drivers/soc/mediatek/mtk-mmsys.h
+++ b/drivers/soc/mediatek/mtk-mmsys.h
@@ -86,10 +86,24 @@ struct mtk_mmsys_routes {
 	u32 val;
 };
 
+struct mtk_mmsys_config {
+	enum mtk_mmsys_config_type config;
+	u32 id;
+	u32 addr;
+	u32 mask;
+	u32 shift;
+};
+
 struct mtk_mmsys_driver_data {
 	const char *clk_driver;
 	const struct mtk_mmsys_routes *routes;
 	const unsigned int num_routes;
+	const struct mtk_mmsys_config *config;
+	const unsigned int num_configs;
+	u32 sw_reset_start;
+	const struct mtk_mmsys_routes *mdp_routes;
+	const unsigned int mdp_num_routes;
+	const unsigned int *mdp_isp_ctrl;
 };
 
 /*
diff --git a/drivers/soc/mediatek/mtk-mutex.c b/drivers/soc/mediatek/mtk-mutex.c
index 718a41beb6afbab5d2ddb469ed1d6a924760ad73..5407e3ff162f7b81cecee6aed39aa4fb7bbaa1c6 100644
--- a/drivers/soc/mediatek/mtk-mutex.c
+++ b/drivers/soc/mediatek/mtk-mutex.c
@@ -7,9 +7,11 @@
 #include <linux/iopoll.h>
 #include <linux/module.h>
 #include <linux/of_device.h>
+#include <linux/of_address.h>
 #include <linux/platform_device.h>
 #include <linux/regmap.h>
 #include <linux/soc/mediatek/mtk-mmsys.h>
+#include <linux/soc/mediatek/mtk-cmdq.h>
 #include <linux/soc/mediatek/mtk-mutex.h>
 
 #define MT2701_MUTEX0_MOD0			0x2c
@@ -17,6 +19,9 @@
 #define MT8183_MUTEX0_MOD0			0x30
 #define MT8183_MUTEX0_SOF0			0x2c
 
+#define MT8195_DISP_MUTEX0_MOD0			0x30
+#define MT8195_DISP_MUTEX0_SOF			0x2c
+
 #define DISP_REG_MUTEX_EN(n)			(0x20 + 0x20 * (n))
 #define DISP_REG_MUTEX(n)			(0x24 + 0x20 * (n))
 #define DISP_REG_MUTEX_RST(n)			(0x28 + 0x20 * (n))
@@ -26,71 +31,130 @@
 
 #define INT_MUTEX				BIT(1)
 
-#define MT8167_MUTEX_MOD_DISP_PWM		1
-#define MT8167_MUTEX_MOD_DISP_OVL0		6
-#define MT8167_MUTEX_MOD_DISP_OVL1		7
-#define MT8167_MUTEX_MOD_DISP_RDMA0		8
-#define MT8167_MUTEX_MOD_DISP_RDMA1		9
-#define MT8167_MUTEX_MOD_DISP_WDMA0		10
-#define MT8167_MUTEX_MOD_DISP_CCORR		11
-#define MT8167_MUTEX_MOD_DISP_COLOR		12
-#define MT8167_MUTEX_MOD_DISP_AAL		13
-#define MT8167_MUTEX_MOD_DISP_GAMMA		14
-#define MT8167_MUTEX_MOD_DISP_DITHER		15
-#define MT8167_MUTEX_MOD_DISP_UFOE		16
-
-#define MT8183_MUTEX_MOD_DISP_RDMA0		0
-#define MT8183_MUTEX_MOD_DISP_RDMA1		1
-#define MT8183_MUTEX_MOD_DISP_OVL0		9
-#define MT8183_MUTEX_MOD_DISP_OVL0_2L		10
-#define MT8183_MUTEX_MOD_DISP_OVL1_2L		11
-#define MT8183_MUTEX_MOD_DISP_WDMA0		12
-#define MT8183_MUTEX_MOD_DISP_COLOR0		13
-#define MT8183_MUTEX_MOD_DISP_CCORR0		14
-#define MT8183_MUTEX_MOD_DISP_AAL0		15
-#define MT8183_MUTEX_MOD_DISP_GAMMA0		16
-#define MT8183_MUTEX_MOD_DISP_DITHER0		17
-
-#define MT8173_MUTEX_MOD_DISP_OVL0		11
-#define MT8173_MUTEX_MOD_DISP_OVL1		12
-#define MT8173_MUTEX_MOD_DISP_RDMA0		13
-#define MT8173_MUTEX_MOD_DISP_RDMA1		14
-#define MT8173_MUTEX_MOD_DISP_RDMA2		15
-#define MT8173_MUTEX_MOD_DISP_WDMA0		16
-#define MT8173_MUTEX_MOD_DISP_WDMA1		17
-#define MT8173_MUTEX_MOD_DISP_COLOR0		18
-#define MT8173_MUTEX_MOD_DISP_COLOR1		19
-#define MT8173_MUTEX_MOD_DISP_AAL		20
-#define MT8173_MUTEX_MOD_DISP_GAMMA		21
-#define MT8173_MUTEX_MOD_DISP_UFOE		22
-#define MT8173_MUTEX_MOD_DISP_PWM0		23
-#define MT8173_MUTEX_MOD_DISP_PWM1		24
-#define MT8173_MUTEX_MOD_DISP_OD		25
-
-#define MT2712_MUTEX_MOD_DISP_PWM2		10
-#define MT2712_MUTEX_MOD_DISP_OVL0		11
-#define MT2712_MUTEX_MOD_DISP_OVL1		12
-#define MT2712_MUTEX_MOD_DISP_RDMA0		13
-#define MT2712_MUTEX_MOD_DISP_RDMA1		14
-#define MT2712_MUTEX_MOD_DISP_RDMA2		15
-#define MT2712_MUTEX_MOD_DISP_WDMA0		16
-#define MT2712_MUTEX_MOD_DISP_WDMA1		17
-#define MT2712_MUTEX_MOD_DISP_COLOR0		18
-#define MT2712_MUTEX_MOD_DISP_COLOR1		19
-#define MT2712_MUTEX_MOD_DISP_AAL0		20
-#define MT2712_MUTEX_MOD_DISP_UFOE		22
-#define MT2712_MUTEX_MOD_DISP_PWM0		23
-#define MT2712_MUTEX_MOD_DISP_PWM1		24
-#define MT2712_MUTEX_MOD_DISP_OD0		25
-#define MT2712_MUTEX_MOD2_DISP_AAL1		33
-#define MT2712_MUTEX_MOD2_DISP_OD1		34
-
-#define MT2701_MUTEX_MOD_DISP_OVL		3
-#define MT2701_MUTEX_MOD_DISP_WDMA		6
-#define MT2701_MUTEX_MOD_DISP_COLOR		7
-#define MT2701_MUTEX_MOD_DISP_BLS		9
-#define MT2701_MUTEX_MOD_DISP_RDMA0		10
-#define MT2701_MUTEX_MOD_DISP_RDMA1		12
+#define MT8167_MUTEX_MOD_DISP_PWM		BIT(1)
+#define MT8167_MUTEX_MOD_DISP_OVL0		BIT(6)
+#define MT8167_MUTEX_MOD_DISP_OVL1		BIT(7)
+#define MT8167_MUTEX_MOD_DISP_RDMA0		BIT(8)
+#define MT8167_MUTEX_MOD_DISP_RDMA1		BIT(9)
+#define MT8167_MUTEX_MOD_DISP_WDMA0		BIT(10)
+#define MT8167_MUTEX_MOD_DISP_CCORR		BIT(11)
+#define MT8167_MUTEX_MOD_DISP_COLOR		BIT(12)
+#define MT8167_MUTEX_MOD_DISP_AAL		BIT(13)
+#define MT8167_MUTEX_MOD_DISP_GAMMA		BIT(14)
+#define MT8167_MUTEX_MOD_DISP_DITHER		BIT(15)
+#define MT8167_MUTEX_MOD_DISP_UFOE		BIT(16)
+
+#define MT8183_MUTEX_MOD_DISP_RDMA0		BIT(0)
+#define MT8183_MUTEX_MOD_DISP_RDMA1		BIT(1)
+#define MT8183_MUTEX_MOD_DISP_OVL0		BIT(9)
+#define MT8183_MUTEX_MOD_DISP_OVL0_2L		BIT(10)
+#define MT8183_MUTEX_MOD_DISP_OVL1_2L		BIT(11)
+#define MT8183_MUTEX_MOD_DISP_WDMA0		BIT(12)
+#define MT8183_MUTEX_MOD_DISP_COLOR0		BIT(13)
+#define MT8183_MUTEX_MOD_DISP_CCORR0		BIT(14)
+#define MT8183_MUTEX_MOD_DISP_AAL0		BIT(15)
+#define MT8183_MUTEX_MOD_DISP_GAMMA0		BIT(16)
+#define MT8183_MUTEX_MOD_DISP_DITHER0		BIT(17)
+
+#define MT8173_MUTEX_MOD_DISP_OVL0		BIT(11)
+#define MT8173_MUTEX_MOD_DISP_OVL1		BIT(12)
+#define MT8173_MUTEX_MOD_DISP_RDMA0		BIT(13)
+#define MT8173_MUTEX_MOD_DISP_RDMA1		BIT(14)
+#define MT8173_MUTEX_MOD_DISP_RDMA2		BIT(15)
+#define MT8173_MUTEX_MOD_DISP_WDMA0		BIT(16)
+#define MT8173_MUTEX_MOD_DISP_WDMA1		BIT(17)
+#define MT8173_MUTEX_MOD_DISP_COLOR0		BIT(18)
+#define MT8173_MUTEX_MOD_DISP_COLOR1		BIT(19)
+#define MT8173_MUTEX_MOD_DISP_AAL		BIT(20)
+#define MT8173_MUTEX_MOD_DISP_GAMMA		BIT(21)
+#define MT8173_MUTEX_MOD_DISP_UFOE		BIT(22)
+#define MT8173_MUTEX_MOD_DISP_PWM0		BIT(23)
+#define MT8173_MUTEX_MOD_DISP_PWM1		BIT(24)
+#define MT8173_MUTEX_MOD_DISP_OD		BIT(25)
+
+#define MT8195_MUTEX_MOD_DISP_OVL0		BIT(0)
+#define MT8195_MUTEX_MOD_DISP_WDMA0		BIT(1)
+#define MT8195_MUTEX_MOD_DISP_RDMA0		BIT(2)
+#define MT8195_MUTEX_MOD_DISP_COLOR0		BIT(3)
+#define MT8195_MUTEX_MOD_DISP_CCORR0		BIT(4)
+#define MT8195_MUTEX_MOD_DISP_AAL0		BIT(5)
+#define MT8195_MUTEX_MOD_DISP_GAMMA0		BIT(6)
+#define MT8195_MUTEX_MOD_DISP_DITHER0		BIT(7)
+#define MT8195_MUTEX_MOD_DISP_DSI0		BIT(8)
+#define MT8195_MUTEX_MOD_DISP_DSC_WRAP0_CORE0	BIT(9)
+#define MT8195_MUTEX_MOD_DISP_OVL1		BIT(10)
+#define MT8195_MUTEX_MOD_DISP_WDMA1		BIT(11)
+#define MT8195_MUTEX_MOD_DISP_RDMA1		BIT(12)
+#define MT8195_MUTEX_MOD_DISP_COLOR1		BIT(13)
+#define MT8195_MUTEX_MOD_DISP_CCORR1		BIT(14)
+#define MT8195_MUTEX_MOD_DISP_AAL1		BIT(15)
+#define MT8195_MUTEX_MOD_DISP_GAMMA1		BIT(16)
+#define MT8195_MUTEX_MOD_DISP_DITHER1		BIT(17)
+#define MT8195_MUTEX_MOD_DISP_DSI1		BIT(18)
+#define MT8195_MUTEX_MOD_DISP_DSC_WRAP0_CORE1	BIT(19)
+#define MT8195_MUTEX_MOD_DISP_VPP_MERGE		BIT(20)
+#define MT8195_MUTEX_MOD_DISP_DP_INTF0		BIT(21)
+#define MT8195_MUTEX_MOD_DISP_VPP1_DL_RELAY0	BIT(22)
+#define MT8195_MUTEX_MOD_DISP_VPP1_DL_RELAY1	BIT(23)
+#define MT8195_MUTEX_MOD_DISP_VDO1_DL_RELAY2	BIT(24)
+#define MT8195_MUTEX_MOD_DISP_VDO0_DL_RELAY3	BIT(25)
+#define MT8195_MUTEX_MOD_DISP_VDO0_DL_RELAY4	BIT(26)
+#define MT8195_MUTEX_MOD_DISP_PWM0		BIT(27)
+#define MT8195_MUTEX_MOD_DISP_PWM1		BIT(28)
+
+#define MT8195_MUTEX_MOD_DISP1_MDP_RDMA0 BIT(0)
+#define MT8195_MUTEX_MOD_DISP1_MDP_RDMA1 BIT(1)
+#define MT8195_MUTEX_MOD_DISP1_MDP_RDMA2 BIT(2)
+#define MT8195_MUTEX_MOD_DISP1_MDP_RDMA3 BIT(3)
+#define MT8195_MUTEX_MOD_DISP1_MDP_RDMA4 BIT(4)
+#define MT8195_MUTEX_MOD_DISP1_MDP_RDMA5 BIT(5)
+#define MT8195_MUTEX_MOD_DISP1_MDP_RDMA6 BIT(6)
+#define MT8195_MUTEX_MOD_DISP1_MDP_RDMA7 BIT(7)
+#define MT8195_MUTEX_MOD_DISP1_VPP_MERGE0 BIT(8)
+#define MT8195_MUTEX_MOD_DISP1_VPP_MERGE1 BIT(9)
+#define MT8195_MUTEX_MOD_DISP1_VPP_MERGE2 BIT(10)
+#define MT8195_MUTEX_MOD_DISP1_VPP_MERGE3 BIT(11)
+#define MT8195_MUTEX_MOD_DISP1_VPP_MERGE4 BIT(12)
+#define MT8195_MUTEX_MOD_DISP1_VPP2_DL_RELAY BIT(13)
+#define MT8195_MUTEX_MOD_DISP1_VPP3_DL_RELAY BIT(14)
+#define MT8195_MUTEX_MOD_DISP1_VDO0_DSC_DL_ASYNC BIT(15)
+#define MT8195_MUTEX_MOD_DISP1_VDO0_MERGE_DL_ASYNC BIT(16)
+#define MT8195_MUTEX_MOD_DISP1_VDO1_OUT_DL_RELAY BIT(17)
+#define MT8195_MUTEX_MOD_DISP1_DISP_MIXER BIT(18)
+#define MT8195_MUTEX_MOD_DISP1_HDR_VDO_FE0 BIT(19)
+#define MT8195_MUTEX_MOD_DISP1_HDR_VDO_FE1 BIT(20)
+#define MT8195_MUTEX_MOD_DISP1_HDR_GFX_FE0 BIT(21)
+#define MT8195_MUTEX_MOD_DISP1_HDR_GFX_FE1 BIT(22)
+#define MT8195_MUTEX_MOD_DISP1_HDR_VDO_BE0 BIT(23)
+#define MT8195_MUTEX_MOD_DISP1_HDR_MLOAD BIT(24)
+#define MT8195_MUTEX_MOD_DISP1_DPI0 BIT(25)
+#define MT8195_MUTEX_MOD_DISP1_DPI1 BIT(26)
+#define MT8195_MUTEX_MOD_DISP1_DP_INTF0 BIT(27)
+
+#define MT2712_MUTEX_MOD_DISP_PWM2		BIT(10)
+#define MT2712_MUTEX_MOD_DISP_OVL0		BIT(11)
+#define MT2712_MUTEX_MOD_DISP_OVL1		BIT(12)
+#define MT2712_MUTEX_MOD_DISP_RDMA0		BIT(13)
+#define MT2712_MUTEX_MOD_DISP_RDMA1		BIT(14)
+#define MT2712_MUTEX_MOD_DISP_RDMA2		BIT(15)
+#define MT2712_MUTEX_MOD_DISP_WDMA0		BIT(16)
+#define MT2712_MUTEX_MOD_DISP_WDMA1		BIT(17)
+#define MT2712_MUTEX_MOD_DISP_COLOR0		BIT(18)
+#define MT2712_MUTEX_MOD_DISP_COLOR1		BIT(19)
+#define MT2712_MUTEX_MOD_DISP_AAL0		BIT(20)
+#define MT2712_MUTEX_MOD_DISP_UFOE		BIT(22)
+#define MT2712_MUTEX_MOD_DISP_PWM0		BIT(23)
+#define MT2712_MUTEX_MOD_DISP_PWM1		BIT(24)
+#define MT2712_MUTEX_MOD_DISP_OD0		BIT(25)
+#define MT2712_MUTEX_MOD2_DISP_AAL1		BIT(33)
+#define MT2712_MUTEX_MOD2_DISP_OD1		BIT(34)
+
+#define MT2701_MUTEX_MOD_DISP_OVL		BIT(3)
+#define MT2701_MUTEX_MOD_DISP_WDMA		BIT(6)
+#define MT2701_MUTEX_MOD_DISP_COLOR		BIT(7)
+#define MT2701_MUTEX_MOD_DISP_BLS		BIT(9)
+#define MT2701_MUTEX_MOD_DISP_RDMA0		BIT(10)
+#define MT2701_MUTEX_MOD_DISP_RDMA1		BIT(12)
 
 #define MT2712_MUTEX_SOF_SINGLE_MODE		0
 #define MT2712_MUTEX_SOF_DSI0			1
@@ -101,11 +165,29 @@
 #define MT2712_MUTEX_SOF_DSI3			6
 #define MT8167_MUTEX_SOF_DPI0			2
 #define MT8167_MUTEX_SOF_DPI1			3
+
 #define MT8183_MUTEX_SOF_DSI0			1
 #define MT8183_MUTEX_SOF_DPI0			2
 
 #define MT8183_MUTEX_EOF_DSI0			(MT8183_MUTEX_SOF_DSI0 << 6)
 #define MT8183_MUTEX_EOF_DPI0			(MT8183_MUTEX_SOF_DPI0 << 6)
+#define MT8183_MUTEX_MDP_START			5
+#define MT8183_MUTEX_MDP_MOD_MASK		0x07FFFFFF
+#define MT8183_MUTEX_MDP_SOF_MASK		0x00000007
+
+#define MT8195_MUTEX_SOF_DSI0			1
+#define MT8195_MUTEX_SOF_DSI1			2
+#define MT8195_MUTEX_SOF_DP_INTF0		3
+#define MT8195_MUTEX_SOF_DP_INTF1		4
+#define MT8195_MUTEX_SOF_DPI0			6 /* for HDMI_TX */
+#define MT8195_MUTEX_SOF_DPI1			5 /* for digital video out */
+
+#define MT8195_MUTEX_EOF_DSI0			(MT8195_MUTEX_SOF_DSI0 << 7)
+#define MT8195_MUTEX_EOF_DSI1			(MT8195_MUTEX_SOF_DSI1 << 7)
+#define MT8195_MUTEX_EOF_DP_INTF0		(MT8195_MUTEX_SOF_DP_INTF0 << 7)
+#define MT8195_MUTEX_EOF_DP_INTF1		(MT8195_MUTEX_SOF_DP_INTF1 << 7)
+#define MT8195_MUTEX_EOF_DPI0			(MT8195_MUTEX_SOF_DPI0 << 7)
+#define MT8195_MUTEX_EOF_DPI1			(MT8195_MUTEX_SOF_DPI1 << 7)
 
 struct mtk_mutex {
 	int id;
@@ -120,13 +202,19 @@ enum mtk_mutex_sof_id {
 	MUTEX_SOF_DPI1,
 	MUTEX_SOF_DSI2,
 	MUTEX_SOF_DSI3,
+	MUTEX_SOF_DP_INTF0,
+	MUTEX_SOF_DP_INTF1,
+	DDP_MUTEX_SOF_MAX,
 };
 
 struct mtk_mutex_data {
-	const unsigned int *mutex_mod;
+	const unsigned long *mutex_mod;
 	const unsigned int *mutex_sof;
 	const unsigned int mutex_mod_reg;
 	const unsigned int mutex_sof_reg;
+	const unsigned int *mutex_mdp_offset;
+	const unsigned int mutex_mdp_mod_mask;
+	const unsigned int mutex_mdp_sof_mask;
 	const bool no_clk;
 };
 
@@ -136,9 +224,11 @@ struct mtk_mutex_ctx {
 	void __iomem			*regs;
 	struct mtk_mutex		mutex[10];
 	const struct mtk_mutex_data	*data;
+	phys_addr_t			addr;
+	u8				subsys_id;
 };
 
-static const unsigned int mt2701_mutex_mod[DDP_COMPONENT_ID_MAX] = {
+static const unsigned long mt2701_mutex_mod[DDP_COMPONENT_ID_MAX] = {
 	[DDP_COMPONENT_BLS] = MT2701_MUTEX_MOD_DISP_BLS,
 	[DDP_COMPONENT_COLOR0] = MT2701_MUTEX_MOD_DISP_COLOR,
 	[DDP_COMPONENT_OVL0] = MT2701_MUTEX_MOD_DISP_OVL,
@@ -147,7 +237,7 @@ static const unsigned int mt2701_mutex_mod[DDP_COMPONENT_ID_MAX] = {
 	[DDP_COMPONENT_WDMA0] = MT2701_MUTEX_MOD_DISP_WDMA,
 };
 
-static const unsigned int mt2712_mutex_mod[DDP_COMPONENT_ID_MAX] = {
+static const unsigned long mt2712_mutex_mod[DDP_COMPONENT_ID_MAX] = {
 	[DDP_COMPONENT_AAL0] = MT2712_MUTEX_MOD_DISP_AAL0,
 	[DDP_COMPONENT_AAL1] = MT2712_MUTEX_MOD2_DISP_AAL1,
 	[DDP_COMPONENT_COLOR0] = MT2712_MUTEX_MOD_DISP_COLOR0,
@@ -167,7 +257,7 @@ static const unsigned int mt2712_mutex_mod[DDP_COMPONENT_ID_MAX] = {
 	[DDP_COMPONENT_WDMA1] = MT2712_MUTEX_MOD_DISP_WDMA1,
 };
 
-static const unsigned int mt8167_mutex_mod[DDP_COMPONENT_ID_MAX] = {
+static const unsigned long mt8167_mutex_mod[DDP_COMPONENT_ID_MAX] = {
 	[DDP_COMPONENT_AAL0] = MT8167_MUTEX_MOD_DISP_AAL,
 	[DDP_COMPONENT_CCORR] = MT8167_MUTEX_MOD_DISP_CCORR,
 	[DDP_COMPONENT_COLOR0] = MT8167_MUTEX_MOD_DISP_COLOR,
@@ -182,7 +272,7 @@ static const unsigned int mt8167_mutex_mod[DDP_COMPONENT_ID_MAX] = {
 	[DDP_COMPONENT_WDMA0] = MT8167_MUTEX_MOD_DISP_WDMA0,
 };
 
-static const unsigned int mt8173_mutex_mod[DDP_COMPONENT_ID_MAX] = {
+static const unsigned long mt8173_mutex_mod[DDP_COMPONENT_ID_MAX] = {
 	[DDP_COMPONENT_AAL0] = MT8173_MUTEX_MOD_DISP_AAL,
 	[DDP_COMPONENT_COLOR0] = MT8173_MUTEX_MOD_DISP_COLOR0,
 	[DDP_COMPONENT_COLOR1] = MT8173_MUTEX_MOD_DISP_COLOR1,
@@ -200,7 +290,7 @@ static const unsigned int mt8173_mutex_mod[DDP_COMPONENT_ID_MAX] = {
 	[DDP_COMPONENT_WDMA1] = MT8173_MUTEX_MOD_DISP_WDMA1,
 };
 
-static const unsigned int mt8183_mutex_mod[DDP_COMPONENT_ID_MAX] = {
+static const unsigned long mt8183_mutex_mod[DDP_COMPONENT_ID_MAX] = {
 	[DDP_COMPONENT_AAL0] = MT8183_MUTEX_MOD_DISP_AAL0,
 	[DDP_COMPONENT_CCORR] = MT8183_MUTEX_MOD_DISP_CCORR0,
 	[DDP_COMPONENT_COLOR0] = MT8183_MUTEX_MOD_DISP_COLOR0,
@@ -214,7 +304,44 @@ static const unsigned int mt8183_mutex_mod[DDP_COMPONENT_ID_MAX] = {
 	[DDP_COMPONENT_WDMA0] = MT8183_MUTEX_MOD_DISP_WDMA0,
 };
 
-static const unsigned int mt2712_mutex_sof[MUTEX_SOF_DSI3 + 1] = {
+static const unsigned long mt8195_mutex_mod[DDP_COMPONENT_ID_MAX] = {
+	[DDP_COMPONENT_OVL0] = MT8195_MUTEX_MOD_DISP_OVL0,
+	[DDP_COMPONENT_WDMA0] = MT8195_MUTEX_MOD_DISP_WDMA0,
+	[DDP_COMPONENT_RDMA0] = MT8195_MUTEX_MOD_DISP_RDMA0,
+	[DDP_COMPONENT_COLOR0] = MT8195_MUTEX_MOD_DISP_COLOR0,
+	[DDP_COMPONENT_CCORR] = MT8195_MUTEX_MOD_DISP_CCORR0,
+	[DDP_COMPONENT_AAL0] = MT8195_MUTEX_MOD_DISP_AAL0,
+	[DDP_COMPONENT_GAMMA] = MT8195_MUTEX_MOD_DISP_GAMMA0,
+	[DDP_COMPONENT_DITHER] = MT8195_MUTEX_MOD_DISP_DITHER0,
+	[DDP_COMPONENT_MERGE0] = MT8195_MUTEX_MOD_DISP_VPP_MERGE,
+	[DDP_COMPONENT_DSC0] = MT8195_MUTEX_MOD_DISP_DSC_WRAP0_CORE0,
+	[DDP_COMPONENT_DSI0] = MT8195_MUTEX_MOD_DISP_DSI0,
+	[DDP_COMPONENT_PWM0] = MT8195_MUTEX_MOD_DISP_PWM0,
+	[DDP_COMPONENT_DP_INTF0] = MT8195_MUTEX_MOD_DISP_DP_INTF0,
+	[DDP_COMPONENT_OVL_ADAPTOR] = MT8195_MUTEX_MOD_DISP1_MDP_RDMA0 |
+				      MT8195_MUTEX_MOD_DISP1_MDP_RDMA1 |
+				      MT8195_MUTEX_MOD_DISP1_MDP_RDMA2 |
+				      MT8195_MUTEX_MOD_DISP1_MDP_RDMA3 |
+				      MT8195_MUTEX_MOD_DISP1_MDP_RDMA4 |
+				      MT8195_MUTEX_MOD_DISP1_MDP_RDMA5 |
+				      MT8195_MUTEX_MOD_DISP1_MDP_RDMA6 |
+				      MT8195_MUTEX_MOD_DISP1_MDP_RDMA7 |
+				      MT8195_MUTEX_MOD_DISP1_VPP_MERGE0 |
+				      MT8195_MUTEX_MOD_DISP1_VPP_MERGE1 |
+				      MT8195_MUTEX_MOD_DISP1_VPP_MERGE2 |
+				      MT8195_MUTEX_MOD_DISP1_VPP_MERGE3 |
+				      MT8195_MUTEX_MOD_DISP1_HDR_VDO_FE0 |
+				      MT8195_MUTEX_MOD_DISP1_HDR_VDO_FE1 |
+				      MT8195_MUTEX_MOD_DISP1_HDR_GFX_FE0 |
+				      MT8195_MUTEX_MOD_DISP1_HDR_GFX_FE1 |
+				      MT8195_MUTEX_MOD_DISP1_HDR_VDO_BE0 |
+				      MT8195_MUTEX_MOD_DISP1_HDR_MLOAD |
+				      MT8195_MUTEX_MOD_DISP1_DISP_MIXER,
+	[DDP_COMPONENT_MERGE5] = MT8195_MUTEX_MOD_DISP1_VPP_MERGE4,
+	[DDP_COMPONENT_DP_INTF1] = MT8195_MUTEX_MOD_DISP1_DP_INTF0,
+};
+
+static const unsigned int mt2712_mutex_sof[DDP_MUTEX_SOF_MAX] = {
 	[MUTEX_SOF_SINGLE_MODE] = MUTEX_SOF_SINGLE_MODE,
 	[MUTEX_SOF_DSI0] = MUTEX_SOF_DSI0,
 	[MUTEX_SOF_DSI1] = MUTEX_SOF_DSI1,
@@ -224,7 +351,7 @@ static const unsigned int mt2712_mutex_sof[MUTEX_SOF_DSI3 + 1] = {
 	[MUTEX_SOF_DSI3] = MUTEX_SOF_DSI3,
 };
 
-static const unsigned int mt8167_mutex_sof[MUTEX_SOF_DSI3 + 1] = {
+static const unsigned int mt8167_mutex_sof[DDP_MUTEX_SOF_MAX] = {
 	[MUTEX_SOF_SINGLE_MODE] = MUTEX_SOF_SINGLE_MODE,
 	[MUTEX_SOF_DSI0] = MUTEX_SOF_DSI0,
 	[MUTEX_SOF_DPI0] = MT8167_MUTEX_SOF_DPI0,
@@ -232,12 +359,32 @@ static const unsigned int mt8167_mutex_sof[MUTEX_SOF_DSI3 + 1] = {
 };
 
 /* Add EOF setting so overlay hardware can receive frame done irq */
-static const unsigned int mt8183_mutex_sof[MUTEX_SOF_DSI3 + 1] = {
+static const unsigned int mt8183_mutex_sof[DDP_MUTEX_SOF_MAX] = {
 	[MUTEX_SOF_SINGLE_MODE] = MUTEX_SOF_SINGLE_MODE,
 	[MUTEX_SOF_DSI0] = MUTEX_SOF_DSI0 | MT8183_MUTEX_EOF_DSI0,
 	[MUTEX_SOF_DPI0] = MT8183_MUTEX_SOF_DPI0 | MT8183_MUTEX_EOF_DPI0,
 };
 
+/* indicate which mutex is used by each pipepline */
+static const unsigned int mt8183_mutex_mdp_offset[MDP_PIPE_MAX] = {
+	[MDP_PIPE_IMGI] = MT8183_MUTEX_MDP_START,
+	[MDP_PIPE_RDMA0] = MT8183_MUTEX_MDP_START + 1,
+	[MDP_PIPE_WPEI] = MT8183_MUTEX_MDP_START + 2,
+	[MDP_PIPE_WPEI2] = MT8183_MUTEX_MDP_START + 3
+};
+
+static const unsigned int mt8195_mutex_sof[DDP_MUTEX_SOF_MAX] = {
+	[MUTEX_SOF_SINGLE_MODE] = MUTEX_SOF_SINGLE_MODE,
+	[MUTEX_SOF_DSI0] = MT8195_MUTEX_SOF_DSI0 | MT8195_MUTEX_EOF_DSI0,
+	[MUTEX_SOF_DSI1] = MT8195_MUTEX_SOF_DSI1 | MT8195_MUTEX_EOF_DSI1,
+	[MUTEX_SOF_DPI0] = MT8195_MUTEX_SOF_DPI0 | MT8195_MUTEX_EOF_DPI0,
+	[MUTEX_SOF_DPI1] = MT8195_MUTEX_SOF_DPI1 | MT8195_MUTEX_EOF_DPI1,
+	[MUTEX_SOF_DP_INTF0] =
+		MT8195_MUTEX_SOF_DP_INTF0 | MT8195_MUTEX_EOF_DP_INTF0,
+	[MUTEX_SOF_DP_INTF1] =
+		MT8195_MUTEX_SOF_DP_INTF1 | MT8195_MUTEX_EOF_DP_INTF1,
+};
+
 static const struct mtk_mutex_data mt2701_mutex_driver_data = {
 	.mutex_mod = mt2701_mutex_mod,
 	.mutex_sof = mt2712_mutex_sof,
@@ -272,9 +419,19 @@ static const struct mtk_mutex_data mt8183_mutex_driver_data = {
 	.mutex_sof = mt8183_mutex_sof,
 	.mutex_mod_reg = MT8183_MUTEX0_MOD0,
 	.mutex_sof_reg = MT8183_MUTEX0_SOF0,
+	.mutex_mdp_offset = mt8183_mutex_mdp_offset,
+	.mutex_mdp_mod_mask = MT8183_MUTEX_MDP_MOD_MASK,
+	.mutex_mdp_sof_mask = MT8183_MUTEX_MDP_SOF_MASK,
 	.no_clk = true,
 };
 
+static const struct mtk_mutex_data mt8195_mutex_driver_data = {
+	.mutex_mod = mt8195_mutex_mod,
+	.mutex_sof = mt8195_mutex_sof,
+	.mutex_mod_reg = MT8195_DISP_MUTEX0_MOD0,
+	.mutex_sof_reg = MT8195_DISP_MUTEX0_SOF,
+};
+
 struct mtk_mutex *mtk_mutex_get(struct device *dev)
 {
 	struct mtk_mutex_ctx *mtx = dev_get_drvdata(dev);
@@ -290,6 +447,21 @@ struct mtk_mutex *mtk_mutex_get(struct device *dev)
 }
 EXPORT_SYMBOL_GPL(mtk_mutex_get);
 
+struct mtk_mutex *mtk_mutex_mdp_get(struct device *dev,
+				    enum mtk_mdp_pipe_id id)
+{
+	struct mtk_mutex_ctx *mtx = dev_get_drvdata(dev);
+	int i = mtx->data->mutex_mdp_offset[id];
+
+	if (!mtx->mutex[i].claimed) {
+		mtx->mutex[i].claimed = true;
+		return &mtx->mutex[i];
+	}
+
+	return ERR_PTR(-EBUSY);
+}
+EXPORT_SYMBOL_GPL(mtk_mutex_mdp_get);
+
 void mtk_mutex_put(struct mtk_mutex *mutex)
 {
 	struct mtk_mutex_ctx *mtx = container_of(mutex, struct mtk_mutex_ctx,
@@ -347,17 +519,23 @@ void mtk_mutex_add_comp(struct mtk_mutex *mutex,
 	case DDP_COMPONENT_DPI1:
 		sof_id = MUTEX_SOF_DPI1;
 		break;
+	case DDP_COMPONENT_DP_INTF0:
+		sof_id = MUTEX_SOF_DP_INTF0;
+		break;
+	case DDP_COMPONENT_DP_INTF1:
+		sof_id = MUTEX_SOF_DP_INTF1;
+		break;
 	default:
-		if (mtx->data->mutex_mod[id] < 32) {
+		if (mtx->data->mutex_mod[id] <= BIT(31)) {
 			offset = DISP_REG_MUTEX_MOD(mtx->data->mutex_mod_reg,
 						    mutex->id);
 			reg = readl_relaxed(mtx->regs + offset);
-			reg |= 1 << mtx->data->mutex_mod[id];
+			reg |= mtx->data->mutex_mod[id];
 			writel_relaxed(reg, mtx->regs + offset);
 		} else {
 			offset = DISP_REG_MUTEX_MOD2(mutex->id);
 			reg = readl_relaxed(mtx->regs + offset);
-			reg |= 1 << (mtx->data->mutex_mod[id] - 32);
+			reg |= (mtx->data->mutex_mod[id] >> 32);
 			writel_relaxed(reg, mtx->regs + offset);
 		}
 		return;
@@ -369,6 +547,25 @@ void mtk_mutex_add_comp(struct mtk_mutex *mutex,
 }
 EXPORT_SYMBOL_GPL(mtk_mutex_add_comp);
 
+void mtk_mutex_add_mdp_mod(struct mtk_mutex *mutex, u32 mod,
+			   struct mmsys_cmdq_cmd *cmd)
+{
+	struct mtk_mutex_ctx *mtx = container_of(mutex, struct mtk_mutex_ctx,
+						 mutex[mutex->id]);
+	unsigned int offset;
+
+	WARN_ON(&mtx->mutex[mutex->id] != mutex);
+
+	offset = DISP_REG_MUTEX_MOD(mtx->data->mutex_mod_reg, mutex->id);
+	cmdq_pkt_write_mask(cmd->pkt, mtx->subsys_id, mtx->addr + offset,
+			    mod, mtx->data->mutex_mdp_mod_mask);
+
+	offset = DISP_REG_MUTEX_SOF(mtx->data->mutex_sof_reg, mutex->id);
+	cmdq_pkt_write_mask(cmd->pkt, mtx->subsys_id, mtx->addr + offset,
+			    0, mtx->data->mutex_mdp_sof_mask);
+}
+EXPORT_SYMBOL_GPL(mtk_mutex_add_mdp_mod);
+
 void mtk_mutex_remove_comp(struct mtk_mutex *mutex,
 			   enum mtk_ddp_comp_id id)
 {
@@ -386,22 +583,24 @@ void mtk_mutex_remove_comp(struct mtk_mutex *mutex,
 	case DDP_COMPONENT_DSI3:
 	case DDP_COMPONENT_DPI0:
 	case DDP_COMPONENT_DPI1:
+	case DDP_COMPONENT_DP_INTF0:
+	case DDP_COMPONENT_DP_INTF1:
 		writel_relaxed(MUTEX_SOF_SINGLE_MODE,
 			       mtx->regs +
 			       DISP_REG_MUTEX_SOF(mtx->data->mutex_sof_reg,
 						  mutex->id));
 		break;
 	default:
-		if (mtx->data->mutex_mod[id] < 32) {
+		if (mtx->data->mutex_mod[id] <= BIT(31)) {
 			offset = DISP_REG_MUTEX_MOD(mtx->data->mutex_mod_reg,
 						    mutex->id);
 			reg = readl_relaxed(mtx->regs + offset);
-			reg &= ~(1 << mtx->data->mutex_mod[id]);
+			reg &= ~(mtx->data->mutex_mod[id]);
 			writel_relaxed(reg, mtx->regs + offset);
 		} else {
 			offset = DISP_REG_MUTEX_MOD2(mutex->id);
 			reg = readl_relaxed(mtx->regs + offset);
-			reg &= ~(1 << (mtx->data->mutex_mod[id] - 32));
+			reg &= ~(mtx->data->mutex_mod[id] >> 32);
 			writel_relaxed(reg, mtx->regs + offset);
 		}
 		break;
@@ -420,6 +619,20 @@ void mtk_mutex_enable(struct mtk_mutex *mutex)
 }
 EXPORT_SYMBOL_GPL(mtk_mutex_enable);
 
+void mtk_mutex_enable_by_cmdq(struct mtk_mutex *mutex,
+			      struct mmsys_cmdq_cmd *cmd)
+{
+	struct mtk_mutex_ctx *mtx = container_of(mutex, struct mtk_mutex_ctx,
+						 mutex[mutex->id]);
+
+	WARN_ON(&mtx->mutex[mutex->id] != mutex);
+
+	cmdq_pkt_write_mask(cmd->pkt, mtx->subsys_id,
+			    mtx->addr + DISP_REG_MUTEX_EN(mutex->id),
+			    0x1, 0x00000001);
+}
+EXPORT_SYMBOL_GPL(mtk_mutex_enable_by_cmdq);
+
 void mtk_mutex_disable(struct mtk_mutex *mutex)
 {
 	struct mtk_mutex_ctx *mtx = container_of(mutex, struct mtk_mutex_ctx,
@@ -431,6 +644,20 @@ void mtk_mutex_disable(struct mtk_mutex *mutex)
 }
 EXPORT_SYMBOL_GPL(mtk_mutex_disable);
 
+void mtk_mutex_disable_by_cmdq(struct mtk_mutex *mutex,
+			       struct mmsys_cmdq_cmd *cmd)
+{
+	struct mtk_mutex_ctx *mtx = container_of(mutex, struct mtk_mutex_ctx,
+						 mutex[mutex->id]);
+
+	WARN_ON(&mtx->mutex[mutex->id] != mutex);
+
+	cmdq_pkt_write_mask(cmd->pkt, mtx->subsys_id,
+			    mtx->addr + DISP_REG_MUTEX_EN(mutex->id),
+			    0x0, 0x00000001);
+}
+EXPORT_SYMBOL_GPL(mtk_mutex_disable_by_cmdq);
+
 void mtk_mutex_acquire(struct mtk_mutex *mutex)
 {
 	struct mtk_mutex_ctx *mtx = container_of(mutex, struct mtk_mutex_ctx,
@@ -458,7 +685,8 @@ static int mtk_mutex_probe(struct platform_device *pdev)
 {
 	struct device *dev = &pdev->dev;
 	struct mtk_mutex_ctx *mtx;
-	struct resource *regs;
+	struct cmdq_client_reg cmdq_reg;
+	struct resource *regs, addr;
 	int i;
 
 	mtx = devm_kzalloc(dev, sizeof(*mtx), GFP_KERNEL);
@@ -479,6 +707,15 @@ static int mtk_mutex_probe(struct platform_device *pdev)
 		}
 	}
 
+	if (of_address_to_resource(dev->of_node, 0, &addr) < 0)
+		mtx->addr = 0L;
+	else
+		mtx->addr = addr.start;
+
+	if (cmdq_dev_get_client_reg(dev, &cmdq_reg, 0) != 0)
+		dev_info(dev, "cmdq subsys id has not been set\n");
+	mtx->subsys_id = cmdq_reg.subsys;
+
 	regs = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	mtx->regs = devm_ioremap_resource(dev, regs);
 	if (IS_ERR(mtx->regs)) {
@@ -507,6 +744,8 @@ static const struct of_device_id mutex_driver_dt_match[] = {
 	  .data = &mt8173_mutex_driver_data},
 	{ .compatible = "mediatek,mt8183-disp-mutex",
 	  .data = &mt8183_mutex_driver_data},
+	{ .compatible = "mediatek,mt8195-disp-mutex",
+	  .data = &mt8195_mutex_driver_data},
 	{},
 };
 MODULE_DEVICE_TABLE(of, mutex_driver_dt_match);
diff --git a/drivers/soc/mediatek/mtk-pm-domains.c b/drivers/soc/mediatek/mtk-pm-domains.c
index d5f991ba4ba6bebecf611c3c223d7d06cf6d55c4..9c8f92a55897a9753f869e7196d2615f18fbe29d 100644
--- a/drivers/soc/mediatek/mtk-pm-domains.c
+++ b/drivers/soc/mediatek/mtk-pm-domains.c
@@ -19,6 +19,7 @@
 #include "mt8173-pm-domains.h"
 #include "mt8183-pm-domains.h"
 #include "mt8192-pm-domains.h"
+#include "mt8195-pm-domains.h"
 
 #define MTK_POLL_DELAY_US		10
 #define MTK_POLL_TIMEOUT		USEC_PER_SEC
@@ -59,10 +60,10 @@ static bool scpsys_domain_is_on(struct scpsys_domain *pd)
 	struct scpsys *scpsys = pd->scpsys;
 	u32 status, status2;
 
-	regmap_read(scpsys->base, scpsys->soc_data->pwr_sta_offs, &status);
+	regmap_read(scpsys->base, pd->data->pwr_sta_offs, &status);
 	status &= pd->data->sta_mask;
 
-	regmap_read(scpsys->base, scpsys->soc_data->pwr_sta2nd_offs, &status2);
+	regmap_read(scpsys->base, pd->data->pwr_sta2nd_offs, &status2);
 	status2 &= pd->data->sta_mask;
 
 	/* A domain is on when both status bits are set. */
@@ -442,6 +443,9 @@ generic_pm_domain *scpsys_add_one_domain(struct scpsys *scpsys, struct device_no
 	pd->genpd.power_off = scpsys_power_off;
 	pd->genpd.power_on = scpsys_power_on;
 
+	if (MTK_SCPD_CAPS(pd, MTK_SCPD_ACTIVE_WAKEUP))
+		pd->genpd.flags |= GENPD_FLAG_ACTIVE_WAKEUP;
+
 	if (MTK_SCPD_CAPS(pd, MTK_SCPD_KEEP_DEFAULT_OFF))
 		pm_genpd_init(&pd->genpd, NULL, true);
 	else
@@ -560,6 +564,10 @@ static const struct of_device_id scpsys_of_match[] = {
 		.compatible = "mediatek,mt8192-power-controller",
 		.data = &mt8192_scpsys_data,
 	},
+	{
+		.compatible = "mediatek,mt8195-power-controller",
+		.data = &mt8195_scpsys_data,
+	},
 	{ }
 };
 
diff --git a/drivers/soc/mediatek/mtk-pm-domains.h b/drivers/soc/mediatek/mtk-pm-domains.h
index 6f4b0f75be9b204cd98b66e281e501c1e305b160..f68aded010ce1df6684080580c01e8685258efa5 100644
--- a/drivers/soc/mediatek/mtk-pm-domains.h
+++ b/drivers/soc/mediatek/mtk-pm-domains.h
@@ -36,7 +36,7 @@
 #define PWR_STATUS_AUDIO		BIT(24)
 #define PWR_STATUS_USB			BIT(25)
 
-#define SPM_MAX_BUS_PROT_DATA		5
+#define SPM_MAX_BUS_PROT_DATA		6
 
 #define _BUS_PROT(_mask, _set, _clr, _sta, _update, _ignore) {	\
 		.bus_prot_mask = (_mask),			\
@@ -71,8 +71,6 @@ struct scpsys_bus_prot_data {
 	bool ignore_clr_ack;
 };
 
-#define MAX_SUBSYS_CLKS 10
-
 /**
  * struct scpsys_domain_data - scp domain data for power on/off flow
  * @name: The name of the power domain.
@@ -93,13 +91,13 @@ struct scpsys_domain_data {
 	u8 caps;
 	const struct scpsys_bus_prot_data bp_infracfg[SPM_MAX_BUS_PROT_DATA];
 	const struct scpsys_bus_prot_data bp_smi[SPM_MAX_BUS_PROT_DATA];
+	int pwr_sta_offs;
+	int pwr_sta2nd_offs;
 };
 
 struct scpsys_soc_data {
 	const struct scpsys_domain_data *domains_data;
 	int num_domains;
-	int pwr_sta_offs;
-	int pwr_sta2nd_offs;
 };
 
 #endif /* __SOC_MEDIATEK_MTK_PM_DOMAINS_H */
diff --git a/drivers/soc/mediatek/mtk-pmic-wrap.c b/drivers/soc/mediatek/mtk-pmic-wrap.c
index 952bc554f443ababa8d9612b2ee6807357bd0d67..8df363f21bcedc99b765231e1e63a7c5450407f6 100644
--- a/drivers/soc/mediatek/mtk-pmic-wrap.c
+++ b/drivers/soc/mediatek/mtk-pmic-wrap.c
@@ -1197,8 +1197,12 @@ static int pwrap_wait_for_state(struct pmic_wrapper *wrp,
 	timeout = jiffies + usecs_to_jiffies(10000);
 
 	do {
-		if (time_after(jiffies, timeout))
-			return fp(wrp) ? 0 : -ETIMEDOUT;
+		if (time_after(jiffies, timeout)) {
+      if (fp(wrp) == 0) {
+        dev_err(wrp->dev, "[PWRAP] FSM Timeout\n");
+      }
+ 			return fp(wrp) ? 0 : -ETIMEDOUT;
+		}
 		if (fp(wrp))
 			return 0;
 	} while (1);
diff --git a/drivers/soc/mediatek/mtk-svs.c b/drivers/soc/mediatek/mtk-svs.c
index 8794a2d87baa7f0e4f467bfba357234e05703590..62a8565e34287d387ae9163f7543840c590362eb 100644
--- a/drivers/soc/mediatek/mtk-svs.c
+++ b/drivers/soc/mediatek/mtk-svs.c
@@ -36,6 +36,10 @@
 #define SVSB_CCI			BIT(2)
 #define SVSB_GPU			BIT(3)
 
+/* svs bank 2-line type */
+#define SVSB_LOW			BIT(4)
+#define SVSB_HIGH			BIT(5)
+
 /* svs bank mode support */
 #define SVSB_MODE_ALL_DISABLE		0
 #define SVSB_MODE_INIT01		BIT(1)
@@ -323,6 +327,7 @@ struct svs_platform {
  * @volts: bank voltages
  * @reg_data: bank register data of each phase
  * @freq_base: reference frequency for bank init
+ * @turn_freq_base: refenrece frequency for turn point
  * @vboot: voltage request for bank init01 stage only
  * @volt_step: bank voltage step
  * @volt_base: bank voltage base
@@ -343,6 +348,8 @@ struct svs_platform {
  * @hw_id: bank hardware identification
  * @ctl0: bank thermal sensor selection
  * @cpu_id: cpu core id for SVS CPU only
+ * @turn_pt: turn point informs which opp_volt calculated by high/low bank.
+ * @type: bank type to represent it is 2-line (high/low) bank or 1-line bank.
  *
  * Other structure members which are not listed above are svs platform
  * efuse data for bank init
@@ -371,6 +378,7 @@ struct svs_bank {
 	u32 volts[16];
 	u32 reg_data[SVSB_PHASE_NUM][SVS_REG_NUM];
 	u32 freq_base;
+	u32 turn_freq_base;
 	u32 vboot;
 	u32 volt_step;
 	u32 volt_base;
@@ -410,6 +418,8 @@ struct svs_bank {
 	u32 hw_id;
 	u32 ctl0;
 	u32 cpu_id;
+	u32 turn_pt;
+	u32 type;
 };
 
 static u32 percent(u32 numerator, u32 denominator)
@@ -445,6 +455,37 @@ static u32 svs_bank_volt_to_opp_volt(u32 svsb_volt, u32 svsb_volt_step,
 	return (svsb_volt * svsb_volt_step) + svsb_volt_base;
 }
 
+static u32 svs_opp_volt_to_bank_volt(u32 opp_u_volt, u32 svsb_volt_step,
+				     u32 svsb_volt_base)
+{
+	return (opp_u_volt - svsb_volt_base) / svsb_volt_step;
+}
+
+static int svs_sync_bank_volts_from_opp(struct svs_bank *svsb)
+{
+	struct dev_pm_opp *opp;
+	u32 i, opp_u_volt;
+
+	for (i = 0; i < svsb->opp_count; i++) {
+		opp = dev_pm_opp_find_freq_exact(svsb->opp_dev,
+						 svsb->opp_freqs[i],
+						 true);
+		if (IS_ERR(opp)) {
+			dev_err(svsb->dev, "cannot find freq = %u (%ld)\n",
+				svsb->opp_freqs[i], PTR_ERR(opp));
+			return PTR_ERR(opp);
+		}
+
+		opp_u_volt = dev_pm_opp_get_voltage(opp);
+		svsb->volts[i] = svs_opp_volt_to_bank_volt(opp_u_volt,
+							   svsb->volt_step,
+							   svsb->volt_base);
+		dev_pm_opp_put(opp);
+	}
+
+	return 0;
+}
+
 static int svs_get_bank_zone_temperature(const char *tzone_name,
 					 int *tzone_temp)
 {
@@ -460,7 +501,7 @@ static int svs_get_bank_zone_temperature(const char *tzone_name,
 static int svs_adjust_pm_opp_volts(struct svs_bank *svsb, bool force_update)
 {
 	int tzone_temp = 0, ret = -EPERM;
-	u32 i, svsb_volt, opp_volt, temp_offset = 0;
+	u32 i, svsb_volt, opp_volt, temp_offset = 0, opp_start, opp_stop;
 
 	mutex_lock(&svsb->lock);
 
@@ -474,6 +515,21 @@ static int svs_adjust_pm_opp_volts(struct svs_bank *svsb, bool force_update)
 		goto unlock_mutex;
 	}
 
+	/*
+	 * 2-line bank updates its corresponding opp volts.
+	 * 1-line bank updates all opp volts.
+	 */
+	if (svsb->type == SVSB_HIGH) {
+		opp_start = 0;
+		opp_stop = svsb->turn_pt;
+	} else if (svsb->type == SVSB_LOW) {
+		opp_start = svsb->turn_pt;
+		opp_stop = svsb->opp_count;
+	} else {
+		opp_start = 0;
+		opp_stop = svsb->opp_count;
+	}
+
 	/* Get thermal effect */
 	if (svsb->phase == SVSB_PHASE_MON) {
 		if (svsb->temp > svsb->temp_upper_bound &&
@@ -495,10 +551,16 @@ static int svs_adjust_pm_opp_volts(struct svs_bank *svsb, bool force_update)
 			temp_offset += svsb->tzone_high_temp_offset;
 		else if (tzone_temp <= svsb->tzone_low_temp)
 			temp_offset += svsb->tzone_low_temp_offset;
+
+		/* 2-line bank takes thermal factor to update all opp volts */
+		if (svsb->type == SVSB_HIGH || svsb->type == SVSB_LOW) {
+			opp_start = 0;
+			opp_stop = svsb->opp_count;
+		}
 	}
 
 	/* vmin <= svsb_volt (opp_volt) <= signed-off (default) voltage */
-	for (i = 0; i < svsb->opp_count; i++) {
+	for (i = opp_start; i < opp_stop; i++) {
 		if (svsb->phase == SVSB_PHASE_MON) {
 			svsb_volt = max(svsb->volts[i] + svsb->volt_offset +
 					temp_offset, svsb->vmin);
@@ -549,6 +611,187 @@ static u32 interpolate(u32 f0, u32 f1, u32 v0, u32 v1, u32 fx)
 	return DIV_ROUND_UP(vx, 100);
 }
 
+static void svs_get_vops_v3(struct svs_platform *svsp)
+{
+	struct svs_bank *svsb = svsp->pbank;
+	u32 i, vop_i, *vop, vop74, vop30, mask7_0 = GENMASK(7, 0);
+	u32 b_sft, bits8 = 8, shift_byte = 0, reg_4bytes = 4;
+	u32 middle_index = (svsb->opp_count / 2);
+	u32 opp_start = 0, opp_stop = 0, turn_pt = svsb->turn_pt;
+
+	if (svsb->phase == SVSB_PHASE_MON &&
+	    svsb->volt_flags & SVSB_MON_VOLT_IGNORE)
+		return;
+
+	vop74 = svs_readl(svsp, VOP74);
+	vop30 = svs_readl(svsp, VOP30);
+
+	if (turn_pt < middle_index) {
+		if (svsb->type == SVSB_HIGH) {
+			/* We attain volts[0 ~ (turn_pt - 1)] */
+			for (i = 0; i < turn_pt; i++) {
+				b_sft = bits8 * (shift_byte % reg_4bytes);
+				vop = (shift_byte < reg_4bytes) ? &vop30 :
+								  &vop74;
+				svsb->volts[i] = (*vop >> b_sft) & mask7_0;
+				shift_byte++;
+			}
+		} else if (svsb->type == SVSB_LOW) {
+			/*
+			 * We attain volts[turn_pt] +
+			 * volts[vop_i ~ (opp_count - 1)]
+			 */
+			vop_i = svsb->opp_count - 7;
+			svsb->volts[turn_pt] = vop30 & mask7_0;
+			shift_byte++;
+			for (i = vop_i; i < svsb->opp_count; i++) {
+				b_sft = bits8 * (shift_byte % reg_4bytes);
+				vop = (shift_byte < reg_4bytes) ? &vop30 :
+								  &vop74;
+				svsb->volts[i] = (*vop >> b_sft) & mask7_0;
+				shift_byte++;
+			}
+
+			/*
+			 * We attain volts[turn_pt + 1 ~ (vop_i - 1)]
+			 * by interpolate
+			 */
+			for (i = turn_pt + 1; i < vop_i; i++)
+				svsb->volts[i] =
+					interpolate(svsb->freqs_pct[turn_pt],
+						    svsb->freqs_pct[vop_i],
+						    svsb->volts[turn_pt],
+						    svsb->volts[vop_i],
+						    svsb->freqs_pct[i]);
+		}
+	} else {
+		if (svsb->type == SVSB_HIGH) {
+			/* We attain volts[0] + volts[vop_i ~ (turn_pt - 1)] */
+			vop_i = turn_pt - 7;
+			svsb->volts[0] = vop30 & mask7_0;
+			shift_byte++;
+			for (i = vop_i; i < turn_pt; i++) {
+				b_sft = bits8 * (shift_byte % reg_4bytes);
+				vop = (shift_byte < reg_4bytes) ? &vop30 :
+								  &vop74;
+				svsb->volts[i] = (*vop >> b_sft) & mask7_0;
+				shift_byte++;
+			}
+
+			/* We attain volts[1 ~ (vop_i - 1)] by interpolate */
+			for (i = 1; i < vop_i; i++)
+				svsb->volts[i] =
+					interpolate(svsb->freqs_pct[0],
+						    svsb->freqs_pct[vop_i],
+						    svsb->volts[0],
+						    svsb->volts[vop_i],
+						    svsb->freqs_pct[i]);
+		} else if (svsb->type == SVSB_LOW) {
+			/* We attain volts[turn_pt ~ (opp_count - 1)] */
+			for (i = turn_pt; i < svsb->opp_count; i++) {
+				b_sft = bits8 * (shift_byte % reg_4bytes);
+				vop = (shift_byte < reg_4bytes) ? &vop30 :
+								  &vop74;
+				svsb->volts[i] = (*vop >> b_sft) & mask7_0;
+				shift_byte++;
+			}
+		}
+	}
+
+	if (svsb->volt_flags & SVSB_INIT02_RM_DVTFIXED) {
+		if (svsb->type == SVSB_HIGH) {
+			opp_start = 0;
+			opp_stop = svsb->turn_pt;
+		} else if (svsb->type == SVSB_LOW) {
+			opp_start = svsb->turn_pt;
+			opp_stop = svsb->opp_count;
+		}
+
+		for (i = opp_start; i < opp_stop; i++)
+			svsb->volts[i] -= svsb->dvt_fixed;
+	}
+}
+
+static void svs_set_freqs_pct_v3(struct svs_platform *svsp)
+{
+	struct svs_bank *svsb = svsp->pbank;
+	u32 i, freq_i, *freq_pct, freq_pct74 = 0, freq_pct30 = 0;
+	u32 b_sft, bits8 = 8, shift_byte = 0, reg_4bytes = 4;
+	u32 middle_index = (svsb->opp_count / 2);
+	u32 turn_pt = middle_index;
+
+	for (i = 0; i < svsb->opp_count; i++) {
+		if (svsb->opp_freqs[i] <= svsb->turn_freq_base) {
+			svsb->turn_pt = i;
+			break;
+		}
+	}
+
+	turn_pt = svsb->turn_pt;
+
+	/* Target is to fill out freq_pct74 / freq_pct30 */
+	if (turn_pt < middle_index) {
+		if (svsb->type == SVSB_HIGH) {
+			/* Edge case for preventing freq_pct30 from being 0 */
+			if (turn_pt == 0)
+				freq_pct30 = svsb->freqs_pct[0];
+
+			/* We select freqs_pct[0 ~ (turn_pt - 1)] */
+			for (i = 0; i < turn_pt; i++) {
+				b_sft = bits8 * (shift_byte % reg_4bytes);
+				freq_pct = (shift_byte < reg_4bytes) ?
+					   &freq_pct30 : &freq_pct74;
+				*freq_pct |= (svsb->freqs_pct[i] << b_sft);
+				shift_byte++;
+			}
+		} else if (svsb->type == SVSB_LOW) {
+			/*
+			 * We select freqs_pct[turn_pt] +
+			 * freqs_pct[(opp_count - 7) ~ (opp_count -1)]
+			 */
+			freq_pct30 = svsb->freqs_pct[turn_pt];
+			shift_byte++;
+			freq_i = svsb->opp_count - 7;
+			for (i = freq_i; i < svsb->opp_count; i++) {
+				b_sft = bits8 * (shift_byte % reg_4bytes);
+				freq_pct = (shift_byte < reg_4bytes) ?
+					   &freq_pct30 : &freq_pct74;
+				*freq_pct |= (svsb->freqs_pct[i] << b_sft);
+				shift_byte++;
+			}
+		}
+	} else {
+		if (svsb->type == SVSB_HIGH) {
+			/*
+			 * We select freqs_pct[0] +
+			 * freqs_pct[(turn_pt - 7) ~ (turn_pt - 1)]
+			 */
+			freq_pct30 = svsb->freqs_pct[0];
+			shift_byte++;
+			freq_i = turn_pt - 7;
+			for (i = freq_i; i < turn_pt; i++) {
+				b_sft = bits8 * (shift_byte % reg_4bytes);
+				freq_pct = (shift_byte < reg_4bytes) ?
+					   &freq_pct30 : &freq_pct74;
+				*freq_pct |= (svsb->freqs_pct[i] << b_sft);
+				shift_byte++;
+			}
+		} else if (svsb->type == SVSB_LOW) {
+			/* We select freqs_pct[turn_pt ~ (opp_count - 1)] */
+			for (i = turn_pt; i < svsb->opp_count; i++) {
+				b_sft = bits8 * (shift_byte % reg_4bytes);
+				freq_pct = (shift_byte < reg_4bytes) ?
+					   &freq_pct30 : &freq_pct74;
+				*freq_pct |= (svsb->freqs_pct[i] << b_sft);
+				shift_byte++;
+			}
+		}
+	}
+
+	svs_writel(svsp, freq_pct74, FREQPCT74);
+	svs_writel(svsp, freq_pct30, FREQPCT30);
+}
+
 static void svs_get_vops_v2(struct svs_platform *svsp)
 {
 	struct svs_bank *svsb = svsp->pbank;
@@ -868,6 +1111,25 @@ static int svs_init02(struct svs_platform *svsp)
 		}
 	}
 
+	/*
+	 * 2-line high/low bank update its corresponding opp voltages only.
+	 * Therefore, we sync voltages from opp for high/low bank voltages
+	 * consistency.
+	 */
+	for (idx = 0; idx < svsp->bank_num; idx++) {
+		svsb = &svsp->banks[idx];
+
+		if (!(svsb->mode_support & SVSB_MODE_INIT02))
+			continue;
+
+		if (svsb->type == SVSB_HIGH || svsb->type == SVSB_LOW) {
+			if (svs_sync_bank_volts_from_opp(svsb)) {
+				dev_err(svsb->dev, "sync volt fail\n");
+				return -EPERM;
+			}
+		}
+	}
+
 	return 0;
 }
 
@@ -1114,7 +1376,12 @@ static int svs_resource_setup(struct svs_platform *svsp)
 			svsb->name = "SVSB_CCI";
 			break;
 		case SVSB_GPU:
-			svsb->name = "SVSB_GPU";
+			if (svsb->type == SVSB_HIGH)
+				svsb->name = "SVSB_GPU_HIGH";
+			else if (svsb->type == SVSB_LOW)
+				svsb->name = "SVSB_GPU_LOW";
+			else
+				svsb->name = "SVSB_GPU";
 			break;
 		default:
 			WARN_ON(1);
@@ -1176,6 +1443,170 @@ static int svs_resource_setup(struct svs_platform *svsp)
 	return 0;
 }
 
+static bool svs_mt8195_efuse_parsing(struct svs_platform *svsp)
+{
+	struct svs_bank *svsb;
+	struct nvmem_cell *cell;
+	u32 idx, i, ft_pgm, vmin, golden_temp;
+
+	for (i = 0; i < svsp->efuse_num; i++)
+		if (svsp->efuse[i])
+			dev_info(svsp->dev, "M_HW_RES%d: 0x%08x\n",
+				 i, svsp->efuse[i]);
+
+	/* Svs efuse parsing */
+	ft_pgm = svsp->efuse[0] & GENMASK(7, 0);
+	vmin = (svsp->efuse[19] >> 4) & GENMASK(1, 0);
+
+	for (idx = 0; idx < svsp->bank_num; idx++) {
+		svsb = &svsp->banks[idx];
+
+		if (svsb->sw_id != SVSB_GPU)
+			return false;
+
+		if (vmin == 0x1)
+			svsb->vmin = 0x1e;
+
+		if (ft_pgm == 0)
+			svsb->volt_flags |= SVSB_INIT01_VOLT_IGNORE;
+
+		if (svsb->type == SVSB_LOW) {
+			svsb->mtdes = svsp->efuse[10] & GENMASK(7, 0);
+			svsb->bdes = (svsp->efuse[10] >> 16) & GENMASK(7, 0);
+			svsb->mdes = (svsp->efuse[10] >> 24) & GENMASK(7, 0);
+			svsb->dcbdet = (svsp->efuse[8]) & GENMASK(7, 0);
+			svsb->dcmdet = (svsp->efuse[8] >> 8) & GENMASK(7, 0);
+			svsb->vmax += svsb->dvt_fixed;
+		} else if (svsb->type == SVSB_HIGH) {
+			svsb->mtdes = svsp->efuse[9] & GENMASK(7, 0);
+			svsb->bdes = (svsp->efuse[9] >> 16) & GENMASK(7, 0);
+			svsb->mdes = (svsp->efuse[9] >> 24) & GENMASK(7, 0);
+			svsb->dcbdet = (svsp->efuse[8]) & GENMASK(7, 0);
+			svsb->dcmdet = (svsp->efuse[8] >> 8) & GENMASK(7, 0);
+			svsb->vmax += svsb->dvt_fixed;
+		}
+	}
+
+	/* Thermal efuse parsing */
+	cell = nvmem_cell_get(svsp->dev, "t-calibration-data");
+	if (IS_ERR_OR_NULL(cell)) {
+		dev_err(svsp->dev, "no thermal cell, no mon mode\n");
+		for (idx = 0; idx < svsp->bank_num; idx++) {
+			svsb = &svsp->banks[idx];
+			svsb->mode_support &= ~SVSB_MODE_MON;
+		}
+
+		return true;
+	}
+
+	svsp->tefuse = nvmem_cell_read(cell, &svsp->tefuse_num);
+	svsp->tefuse_num /= sizeof(u32);
+	nvmem_cell_put(cell);
+
+	for (i = 0; i < svsp->tefuse_num; i++)
+		if (svsp->tefuse[i] != 0)
+			break;
+
+	if (i == svsp->tefuse_num)
+		golden_temp = 50; /* All thermal efuse data are 0 */
+	else
+		golden_temp = (svsp->tefuse[0] >> 24) & GENMASK(7, 0);
+
+	for (idx = 0; idx < svsp->bank_num; idx++) {
+		svsb = &svsp->banks[idx];
+
+		if (svsb->sw_id != SVSB_GPU)
+			return false;
+
+		svsb->mts = 500;
+		svsb->bts = (((500 * golden_temp + 250460) / 1000) - 25) * 4;
+	}
+
+	return true;
+}
+
+static bool svs_mt8192_efuse_parsing(struct svs_platform *svsp)
+{
+	struct svs_bank *svsb;
+	struct nvmem_cell *cell;
+	u32 idx, i, ft_pgm, vmin, golden_temp;
+
+	for (i = 0; i < svsp->efuse_num; i++)
+		if (svsp->efuse[i])
+			dev_info(svsp->dev, "M_HW_RES%d: 0x%08x\n",
+				 i, svsp->efuse[i]);
+
+	/* Svs efuse parsing */
+	ft_pgm = svsp->efuse[0] & GENMASK(7, 0);
+	vmin = (svsp->efuse[19] >> 4) & GENMASK(1, 0);
+
+	for (idx = 0; idx < svsp->bank_num; idx++) {
+		svsb = &svsp->banks[idx];
+
+		if (svsb->sw_id != SVSB_GPU)
+			return false;
+
+		if (vmin == 0x1)
+			svsb->vmin = 0x1e;
+
+		if (ft_pgm == 0)
+			svsb->volt_flags |= SVSB_INIT01_VOLT_IGNORE;
+
+		if (svsb->type == SVSB_LOW) {
+			svsb->mtdes = svsp->efuse[10] & GENMASK(7, 0);
+			svsb->bdes = (svsp->efuse[10] >> 16) & GENMASK(7, 0);
+			svsb->mdes = (svsp->efuse[10] >> 24) & GENMASK(7, 0);
+			svsb->dcbdet = (svsp->efuse[17]) & GENMASK(7, 0);
+			svsb->dcmdet = (svsp->efuse[17] >> 8) & GENMASK(7, 0);
+			svsb->vmax += svsb->dvt_fixed;
+		} else if (svsb->type == SVSB_HIGH) {
+			svsb->mtdes = svsp->efuse[9] & GENMASK(7, 0);
+			svsb->bdes = (svsp->efuse[9] >> 16) & GENMASK(7, 0);
+			svsb->mdes = (svsp->efuse[9] >> 24) & GENMASK(7, 0);
+			svsb->dcbdet = (svsp->efuse[17] >> 16) & GENMASK(7, 0);
+			svsb->dcmdet = (svsp->efuse[17] >> 24) & GENMASK(7, 0);
+			svsb->vmax += svsb->dvt_fixed;
+		}
+	}
+
+	/* Thermal efuse parsing */
+	cell = nvmem_cell_get(svsp->dev, "t-calibration-data");
+	if (IS_ERR_OR_NULL(cell)) {
+		dev_err(svsp->dev, "no thermal cell, no mon mode\n");
+		for (idx = 0; idx < svsp->bank_num; idx++) {
+			svsb = &svsp->banks[idx];
+			svsb->mode_support &= ~SVSB_MODE_MON;
+		}
+
+		return true;
+	}
+
+	svsp->tefuse = nvmem_cell_read(cell, &svsp->tefuse_num);
+	svsp->tefuse_num /= sizeof(u32);
+	nvmem_cell_put(cell);
+
+	for (i = 0; i < svsp->tefuse_num; i++)
+		if (svsp->tefuse[i] != 0)
+			break;
+
+	if (i == svsp->tefuse_num)
+		golden_temp = 50; /* All thermal efuse data are 0 */
+	else
+		golden_temp = (svsp->tefuse[0] >> 24) & GENMASK(7, 0);
+
+	for (idx = 0; idx < svsp->bank_num; idx++) {
+		svsb = &svsp->banks[idx];
+
+		if (svsb->sw_id != SVSB_GPU)
+			return false;
+
+		svsb->mts = 500;
+		svsb->bts = (((500 * golden_temp + 250460) / 1000) - 25) * 4;
+	}
+
+	return true;
+}
+
 static bool svs_mt8183_efuse_parsing(struct svs_platform *svsp)
 {
 	struct thermal_parameter tp;
@@ -1425,12 +1856,10 @@ static int svs_suspend(struct device *dev)
 		}
 	}
 
-	if (svsp->rst) {
-		ret = reset_control_assert(svsp->rst);
-		if (ret) {
-			dev_err(svsp->dev, "cannot assert reset %d\n", ret);
-			return ret;
-		}
+	ret = reset_control_assert(svsp->rst);
+	if (ret) {
+		dev_err(svsp->dev, "cannot assert reset %d\n", ret);
+		return ret;
 	}
 
 	clk_disable_unprepare(svsp->main_clk);
@@ -1451,12 +1880,10 @@ static int svs_resume(struct device *dev)
 		return ret;
 	}
 
-	if (svsp->rst) {
-		ret = reset_control_deassert(svsp->rst);
-		if (ret) {
-			dev_err(svsp->dev, "cannot deassert reset %d\n", ret);
-			return ret;
-		}
+	ret = reset_control_deassert(svsp->rst);
+	if (ret) {
+		dev_err(svsp->dev, "cannot deassert reset %d\n", ret);
+		return ret;
 	}
 
 	for (idx = 0; idx < svsp->bank_num; idx++) {
@@ -1598,10 +2025,11 @@ static int svs_status_debug_show(struct seq_file *m, void *v)
 
 	ret = svs_get_bank_zone_temperature(svsb->tzone_name, &tzone_temp);
 	if (ret)
-		seq_printf(m, "%s: no \"%s\" zone?\n", svsb->name,
-			   svsb->tzone_name);
+		seq_printf(m, "%s: no \"%s\" zone? turn_pt = %u\n",
+			   svsb->name, svsb->tzone_name, svsb->turn_pt);
 	else
-		seq_printf(m, "%s: temperature = %d\n", svsb->name, tzone_temp);
+		seq_printf(m, "%s: temperature = %d, turn_pt = %u\n",
+			   svsb->name, tzone_temp, svsb->turn_pt);
 
 	for (i = 0; i < svsb->opp_count; i++) {
 		opp = dev_pm_opp_find_freq_exact(svsb->opp_dev,
@@ -1734,6 +2162,171 @@ static int svs_create_svs_debug_cmds(struct svs_platform *svsp)
 	return 0;
 }
 
+static struct svs_bank svs_mt8195_banks[] = {
+	{
+		.sw_id			= SVSB_GPU,
+		.set_freqs_pct		= svs_set_freqs_pct_v3,
+		.get_vops		= svs_get_vops_v3,
+		.hw_id			= 0,
+		.tzone_name		= "gpu1",
+		.buck_name		= "mali",
+		.volt_flags		= SVSB_INIT02_RM_DVTFIXED |
+					  SVSB_MON_VOLT_IGNORE,
+		.mode_support		= SVSB_MODE_INIT02,
+		.opp_count		= 16,
+		.freq_base		= 640000000,
+		.turn_freq_base		= 640000000,
+		.vboot			= 0x38,
+		.volt_step		= 6250,
+		.volt_base		= 400000,
+		.volt_offset		= 0,
+		.vmax			= 0x38,
+		.vmin			= 0x14,
+		.dthi			= 0x1,
+		.dtlo			= 0xfe,
+		.det_window		= 0xa28,
+		.det_max		= 0xffff,
+		.age_config		= 0x555555,
+		.agem			= 0,
+		.dc_config		= 0x1,
+		.dvt_fixed		= 0x1,
+		.vco			= 0x18,
+		.chk_shift		= 0x87,
+		.temp_upper_bound	= 0x64,
+		.temp_lower_bound	= 0xb2,
+		.tzone_high_temp	= 85000,
+		.tzone_high_temp_offset	= 0,
+		.tzone_low_temp		= 25000,
+		.tzone_low_temp_offset	= 7,
+		.core_sel		= 0x0fff0100,
+		.int_st			= BIT(0),
+		.ctl0			= 0x00540003,
+		.type			= SVSB_LOW,
+	},
+	{
+		.sw_id			= SVSB_GPU,
+		.set_freqs_pct		= svs_set_freqs_pct_v3,
+		.get_vops		= svs_get_vops_v3,
+		.hw_id			= 1,
+		.tzone_name		= "gpu1",
+		.buck_name		= "mali",
+		.volt_flags		= SVSB_INIT02_RM_DVTFIXED |
+					  SVSB_MON_VOLT_IGNORE,
+		.mode_support		= SVSB_MODE_INIT02 | SVSB_MODE_MON,
+		.opp_count		= 16,
+		.freq_base		= 880000000,
+		.turn_freq_base		= 640000000,
+		.vboot			= 0x38,
+		.volt_step		= 6250,
+		.volt_base		= 400000,
+		.volt_offset		= 0,
+		.vmax			= 0x38,
+		.vmin			= 0x14,
+		.dthi			= 0x1,
+		.dtlo			= 0xfe,
+		.det_window		= 0xa28,
+		.det_max		= 0xffff,
+		.age_config		= 0x555555,
+		.agem			= 0,
+		.dc_config		= 0x1,
+		.dvt_fixed		= 0x6,
+		.vco			= 0x18,
+		.chk_shift		= 0x87,
+		.temp_upper_bound	= 0x64,
+		.temp_lower_bound	= 0xb2,
+		.tzone_high_temp	= 85000,
+		.tzone_high_temp_offset	= 0,
+		.tzone_low_temp		= 25000,
+		.tzone_low_temp_offset	= 7,
+		.core_sel		= 0x0fff0101,
+		.int_st			= BIT(1),
+		.ctl0			= 0x00540003,
+		.type			= SVSB_HIGH,
+	},
+};
+
+static struct svs_bank svs_mt8192_banks[] = {
+	{
+		.sw_id			= SVSB_GPU,
+		.set_freqs_pct		= svs_set_freqs_pct_v3,
+		.get_vops		= svs_get_vops_v3,
+		.hw_id			= 0,
+		.tzone_name		= "gpu1",
+		.buck_name		= "mali",
+		.volt_flags		= SVSB_INIT02_RM_DVTFIXED,
+		.mode_support		= SVSB_MODE_INIT02,
+		.opp_count		= 16,
+		.freq_base		= 688000000,
+		.turn_freq_base		= 688000000,
+		.vboot			= 0x38,
+		.volt_step		= 6250,
+		.volt_base		= 400000,
+		.volt_offset		= 0,
+		.vmax			= 0x60,
+		.vmin			= 0x1a,
+		.dthi			= 0x1,
+		.dtlo			= 0xfe,
+		.det_window		= 0xa28,
+		.det_max		= 0xffff,
+		.age_config		= 0x555555,
+		.agem			= 0,
+		.dc_config		= 0x1,
+		.dvt_fixed		= 0x1,
+		.vco			= 0x18,
+		.chk_shift		= 0x87,
+		.temp_upper_bound	= 0x64,
+		.temp_lower_bound	= 0xb2,
+		.tzone_high_temp	= 85000,
+		.tzone_high_temp_offset	= 0,
+		.tzone_low_temp		= 25000,
+		.tzone_low_temp_offset	= 7,
+		.core_sel		= 0x0fff0100,
+		.int_st			= BIT(0),
+		.ctl0			= 0x00540003,
+		.type			= SVSB_LOW,
+	},
+	{
+		.sw_id			= SVSB_GPU,
+		.set_freqs_pct		= svs_set_freqs_pct_v3,
+		.get_vops		= svs_get_vops_v3,
+		.hw_id			= 1,
+		.tzone_name		= "gpu1",
+		.buck_name		= "mali",
+		.volt_flags		= SVSB_INIT02_RM_DVTFIXED |
+					  SVSB_MON_VOLT_IGNORE,
+		.mode_support		= SVSB_MODE_INIT02 | SVSB_MODE_MON,
+		.opp_count		= 16,
+		.freq_base		= 902000000,
+		.turn_freq_base		= 688000000,
+		.vboot			= 0x38,
+		.volt_step		= 6250,
+		.volt_base		= 400000,
+		.volt_offset		= 0,
+		.vmax			= 0x60,
+		.vmin			= 0x1a,
+		.dthi			= 0x1,
+		.dtlo			= 0xfe,
+		.det_window		= 0xa28,
+		.det_max		= 0xffff,
+		.age_config		= 0x555555,
+		.agem			= 0,
+		.dc_config		= 0x1,
+		.dvt_fixed		= 0x6,
+		.vco			= 0x18,
+		.chk_shift		= 0x87,
+		.temp_upper_bound	= 0x64,
+		.temp_lower_bound	= 0xb2,
+		.tzone_high_temp	= 85000,
+		.tzone_high_temp_offset	= 0,
+		.tzone_low_temp		= 25000,
+		.tzone_low_temp_offset	= 7,
+		.core_sel		= 0x0fff0101,
+		.int_st			= BIT(1),
+		.ctl0			= 0x00540003,
+		.type			= SVSB_HIGH,
+	},
+};
+
 static struct svs_bank svs_mt8183_banks[] = {
 	{
 		.sw_id			= SVSB_CPU_LITTLE,
@@ -1888,6 +2481,86 @@ static struct svs_bank svs_mt8183_banks[] = {
 	},
 };
 
+static int svs_get_svs_mt8195_platform_data(struct svs_platform *svsp)
+{
+	struct device *dev;
+	struct svs_bank *svsb;
+	u32 idx;
+
+	svsp->name = "mt8195-svs";
+	svsp->banks = svs_mt8195_banks;
+	svsp->efuse_parsing = svs_mt8195_efuse_parsing;
+	svsp->regs = svs_regs_v2;
+	svsp->irqflags = IRQF_TRIGGER_HIGH;
+	svsp->bank_num = ARRAY_SIZE(svs_mt8195_banks);
+	svsp->efuse_check = 10;
+
+	svsp->rst = devm_reset_control_get_optional(svsp->dev, "svs_rst");
+	if (IS_ERR(svsp->rst)) {
+		dev_err_probe(svsp->dev, PTR_ERR(svsp->rst),
+			      "cannot get svs reset control\n");
+		return PTR_ERR(svsp->rst);
+	}
+
+	dev = svs_add_device_link(svsp, "lvts");
+	if (IS_ERR(dev))
+		return PTR_ERR(dev);
+
+	for (idx = 0; idx < svsp->bank_num; idx++) {
+		svsb = &svsp->banks[idx];
+
+		if (svsb->type == SVSB_HIGH)
+			svsb->opp_dev = svs_add_device_link(svsp, "mali");
+		else if (svsb->type == SVSB_LOW)
+			svsb->opp_dev = svs_get_subsys_device(svsp, "mali");
+
+		if (IS_ERR(svsb->opp_dev))
+			return PTR_ERR(svsb->opp_dev);
+	}
+
+	return 0;
+}
+
+static int svs_get_svs_mt8192_platform_data(struct svs_platform *svsp)
+{
+	struct device *dev;
+	struct svs_bank *svsb;
+	u32 idx;
+
+	svsp->name = "mt8192-svs";
+	svsp->banks = svs_mt8192_banks;
+	svsp->efuse_parsing = svs_mt8192_efuse_parsing;
+	svsp->regs = svs_regs_v2;
+	svsp->irqflags = IRQF_TRIGGER_HIGH;
+	svsp->bank_num = ARRAY_SIZE(svs_mt8192_banks);
+	svsp->efuse_check = 9;
+
+	svsp->rst = devm_reset_control_get_optional(svsp->dev, "svs_rst");
+	if (IS_ERR(svsp->rst)) {
+		dev_err_probe(svsp->dev, PTR_ERR(svsp->rst),
+			      "cannot get svs reset control\n");
+		return PTR_ERR(svsp->rst);
+	}
+
+	dev = svs_add_device_link(svsp, "lvts");
+	if (IS_ERR(dev))
+		return PTR_ERR(dev);
+
+	for (idx = 0; idx < svsp->bank_num; idx++) {
+		svsb = &svsp->banks[idx];
+
+		if (svsb->type == SVSB_HIGH)
+			svsb->opp_dev = svs_add_device_link(svsp, "mali");
+		else if (svsb->type == SVSB_LOW)
+			svsb->opp_dev = svs_get_subsys_device(svsp, "mali");
+
+		if (IS_ERR(svsb->opp_dev))
+			return PTR_ERR(svsb->opp_dev);
+	}
+
+	return 0;
+}
+
 static int svs_get_svs_mt8183_platform_data(struct svs_platform *svsp)
 {
 	struct device *dev;
@@ -1898,7 +2571,7 @@ static int svs_get_svs_mt8183_platform_data(struct svs_platform *svsp)
 	svsp->banks = svs_mt8183_banks;
 	svsp->efuse_parsing = svs_mt8183_efuse_parsing;
 	svsp->regs = svs_regs_v2;
-	svsp->irqflags = IRQF_TRIGGER_LOW | IRQF_ONESHOT;
+	svsp->irqflags = IRQF_TRIGGER_LOW;
 	svsp->rst = NULL;
 	svsp->bank_num = ARRAY_SIZE(svs_mt8183_banks);
 	svsp->efuse_check = 2;
@@ -1941,6 +2614,12 @@ static const struct of_device_id mtk_svs_of_match[] = {
 	{
 		.compatible = "mediatek,mt8183-svs",
 		.data = &svs_get_svs_mt8183_platform_data,
+	}, {
+		.compatible = "mediatek,mt8192-svs",
+		.data = &svs_get_svs_mt8192_platform_data,
+	}, {
+		.compatible = "mediatek,mt8195-svs",
+		.data = &svs_get_svs_mt8195_platform_data,
 	}, {
 		/* Sentinel */
 	},
@@ -1983,7 +2662,8 @@ static int svs_probe(struct platform_device *pdev)
 
 	svsp_irq = irq_of_parse_and_map(svsp->dev->of_node, 0);
 	ret = devm_request_threaded_irq(svsp->dev, svsp_irq, NULL, svs_isr,
-					svsp->irqflags, svsp->name, svsp);
+					svsp->irqflags | IRQF_ONESHOT,
+					svsp->name, svsp);
 	if (ret) {
 		dev_err(svsp->dev, "register irq(%d) failed: %d\n",
 			svsp_irq, ret);
diff --git a/drivers/spmi/Kconfig b/drivers/spmi/Kconfig
index a53bad541f1a34686cb5b14a60708923db823de1..692bac98a12030e83404ca4fe4c6d9137e3ce629 100644
--- a/drivers/spmi/Kconfig
+++ b/drivers/spmi/Kconfig
@@ -25,4 +25,14 @@ config SPMI_MSM_PMIC_ARB
 	  This is required for communicating with Qualcomm PMICs and
 	  other devices that have the SPMI interface.
 
+config SPMI_MTK_PMIF
+	tristate "Mediatek SPMI Controller (PMIC Arbiter)"
+	help
+	  If you say yes to this option, support will be included for the
+	  built-in SPMI PMIC Arbiter interface on Mediatek family
+	  processors.
+
+	  This is required for communicating with Mediatek PMICs and
+	  other devices that have the SPMI interface.
+
 endif
diff --git a/drivers/spmi/Makefile b/drivers/spmi/Makefile
index 55a94cadeffe4b0a955b48ef7219f53db3f8e959..76fb3b3ab51030768ed44b4f3626058c6d7abff5 100644
--- a/drivers/spmi/Makefile
+++ b/drivers/spmi/Makefile
@@ -5,3 +5,5 @@
 obj-$(CONFIG_SPMI)	+= spmi.o
 
 obj-$(CONFIG_SPMI_MSM_PMIC_ARB)	+= spmi-pmic-arb.o
+obj-$(CONFIG_SPMI_MTK_PMIF)	+= spmi-mtk-pmif.o
+
diff --git a/drivers/spmi/spmi-mtk-pmif.c b/drivers/spmi/spmi-mtk-pmif.c
new file mode 100644
index 0000000000000000000000000000000000000000..0c320801c9d514f5758a3fe6c3ff9fbaa6f1da78
--- /dev/null
+++ b/drivers/spmi/spmi-mtk-pmif.c
@@ -0,0 +1,555 @@
+// SPDX-License-Identifier: GPL-2.0
+//
+// Copyright (c) 2021 MediaTek Inc.
+
+#include <linux/clk.h>
+#include <linux/iopoll.h>
+#include <linux/module.h>
+#include <linux/of_device.h>
+#include <linux/spmi.h>
+
+#define SWINF_IDLE	0x00
+#define SWINF_WFVLDCLR	0x06
+
+#define GET_SWINF(x)	(((x) >> 1) & 0x7)
+
+#define PMIF_CMD_REG_0		0
+#define PMIF_CMD_REG		1
+#define PMIF_CMD_EXT_REG	2
+#define PMIF_CMD_EXT_REG_LONG	3
+
+#define PMIF_DELAY_US   10
+#define PMIF_TIMEOUT_US (10 * 1000)
+
+#define PMIF_CHAN_OFFSET 0x5
+
+#define PMIF_MAX_CLKS	3
+
+#define SPMI_OP_ST_BUSY 1
+
+struct ch_reg {
+	u32 ch_sta;
+	u32 wdata;
+	u32 rdata;
+	u32 ch_send;
+	u32 ch_rdy;
+};
+
+struct pmif_data {
+	const u32	*regs;
+	const u32	*spmimst_regs;
+	u32	soc_chan;
+};
+
+struct pmif {
+	void __iomem	*base;
+	void __iomem	*spmimst_base;
+	struct ch_reg	chan;
+	struct clk_bulk_data clks[PMIF_MAX_CLKS];
+	u32 nclks;
+	const struct pmif_data *data;
+};
+
+static const char * const pmif_clock_names[] = {
+	"pmif_sys_ck", "pmif_tmr_ck", "spmimst_clk_mux",
+};
+
+enum pmif_regs {
+	PMIF_INIT_DONE,
+	PMIF_INF_EN,
+	PMIF_ARB_EN,
+	PMIF_CMDISSUE_EN,
+	PMIF_TIMER_CTRL,
+	PMIF_SPI_MODE_CTRL,
+	PMIF_IRQ_EVENT_EN_0,
+	PMIF_IRQ_FLAG_0,
+	PMIF_IRQ_CLR_0,
+	PMIF_IRQ_EVENT_EN_1,
+	PMIF_IRQ_FLAG_1,
+	PMIF_IRQ_CLR_1,
+	PMIF_IRQ_EVENT_EN_2,
+	PMIF_IRQ_FLAG_2,
+	PMIF_IRQ_CLR_2,
+	PMIF_IRQ_EVENT_EN_3,
+	PMIF_IRQ_FLAG_3,
+	PMIF_IRQ_CLR_3,
+	PMIF_IRQ_EVENT_EN_4,
+	PMIF_IRQ_FLAG_4,
+	PMIF_IRQ_CLR_4,
+	PMIF_WDT_EVENT_EN_0,
+	PMIF_WDT_FLAG_0,
+	PMIF_WDT_EVENT_EN_1,
+	PMIF_WDT_FLAG_1,
+	PMIF_SWINF_0_STA,
+	PMIF_SWINF_0_WDATA_31_0,
+	PMIF_SWINF_0_RDATA_31_0,
+	PMIF_SWINF_0_ACC,
+	PMIF_SWINF_0_VLD_CLR,
+	PMIF_SWINF_1_STA,
+	PMIF_SWINF_1_WDATA_31_0,
+	PMIF_SWINF_1_RDATA_31_0,
+	PMIF_SWINF_1_ACC,
+	PMIF_SWINF_1_VLD_CLR,
+	PMIF_SWINF_2_STA,
+	PMIF_SWINF_2_WDATA_31_0,
+	PMIF_SWINF_2_RDATA_31_0,
+	PMIF_SWINF_2_ACC,
+	PMIF_SWINF_2_VLD_CLR,
+	PMIF_SWINF_3_STA,
+	PMIF_SWINF_3_WDATA_31_0,
+	PMIF_SWINF_3_RDATA_31_0,
+	PMIF_SWINF_3_ACC,
+	PMIF_SWINF_3_VLD_CLR,
+};
+
+static const u32 mt6873_regs[] = {
+	[PMIF_INIT_DONE] =	0x0000,
+	[PMIF_INF_EN] =		0x0024,
+	[PMIF_ARB_EN] =		0x0150,
+	[PMIF_CMDISSUE_EN] =	0x03B4,
+	[PMIF_TIMER_CTRL] =	0x03E0,
+	[PMIF_SPI_MODE_CTRL] =	0x0400,
+	[PMIF_IRQ_EVENT_EN_0] =	0x0418,
+	[PMIF_IRQ_FLAG_0] =	0x0420,
+	[PMIF_IRQ_CLR_0] =	0x0424,
+	[PMIF_IRQ_EVENT_EN_1] =	0x0428,
+	[PMIF_IRQ_FLAG_1] =	0x0430,
+	[PMIF_IRQ_CLR_1] =	0x0434,
+	[PMIF_IRQ_EVENT_EN_2] =	0x0438,
+	[PMIF_IRQ_FLAG_2] =	0x0440,
+	[PMIF_IRQ_CLR_2] =	0x0444,
+	[PMIF_IRQ_EVENT_EN_3] =	0x0448,
+	[PMIF_IRQ_FLAG_3] =	0x0450,
+	[PMIF_IRQ_CLR_3] =	0x0454,
+	[PMIF_IRQ_EVENT_EN_4] =	0x0458,
+	[PMIF_IRQ_FLAG_4] =	0x0460,
+	[PMIF_IRQ_CLR_4] =	0x0464,
+	[PMIF_WDT_EVENT_EN_0] =	0x046C,
+	[PMIF_WDT_FLAG_0] =	0x0470,
+	[PMIF_WDT_EVENT_EN_1] =	0x0474,
+	[PMIF_WDT_FLAG_1] =	0x0478,
+	[PMIF_SWINF_0_ACC] =	0x0C00,
+	[PMIF_SWINF_0_WDATA_31_0] =	0x0C04,
+	[PMIF_SWINF_0_RDATA_31_0] =	0x0C14,
+	[PMIF_SWINF_0_VLD_CLR] =	0x0C24,
+	[PMIF_SWINF_0_STA] =	0x0C28,
+	[PMIF_SWINF_1_ACC] =	0x0C40,
+	[PMIF_SWINF_1_WDATA_31_0] =	0x0C44,
+	[PMIF_SWINF_1_RDATA_31_0] =	0x0C54,
+	[PMIF_SWINF_1_VLD_CLR] =	0x0C64,
+	[PMIF_SWINF_1_STA] =	0x0C68,
+	[PMIF_SWINF_2_ACC] =	0x0C80,
+	[PMIF_SWINF_2_WDATA_31_0] =	0x0C84,
+	[PMIF_SWINF_2_RDATA_31_0] =	0x0C94,
+	[PMIF_SWINF_2_VLD_CLR] =	0x0CA4,
+	[PMIF_SWINF_2_STA] =	0x0CA8,
+	[PMIF_SWINF_3_ACC] =	0x0CC0,
+	[PMIF_SWINF_3_WDATA_31_0] =	0x0CC4,
+	[PMIF_SWINF_3_RDATA_31_0] =	0x0CD4,
+	[PMIF_SWINF_3_VLD_CLR] =	0x0CE4,
+	[PMIF_SWINF_3_STA] =	0x0CE8,
+};
+
+static const u32 mt8195_regs[] = {
+	[PMIF_INIT_DONE] =			0x0000,
+	[PMIF_INF_EN] =				0x0024,
+	[PMIF_ARB_EN] =				0x0150,
+	[PMIF_CMDISSUE_EN] =			0x03B8,
+	[PMIF_TIMER_CTRL] =			0x03E4,
+	[PMIF_SPI_MODE_CTRL] =			0x0408,
+	[PMIF_IRQ_EVENT_EN_0] =			0x0420,
+	[PMIF_IRQ_FLAG_0] =			0x0428,
+	[PMIF_IRQ_CLR_0] =			0x042C,
+	[PMIF_IRQ_EVENT_EN_1] =			0x0430,
+	[PMIF_IRQ_FLAG_1] =			0x0438,
+	[PMIF_IRQ_CLR_1] =			0x043C,
+	[PMIF_IRQ_EVENT_EN_2] =			0x0440,
+	[PMIF_IRQ_FLAG_2] =			0x0448,
+	[PMIF_IRQ_CLR_2] =			0x044C,
+	[PMIF_IRQ_EVENT_EN_3] =			0x0450,
+	[PMIF_IRQ_FLAG_3] =			0x0458,
+	[PMIF_IRQ_CLR_3] =			0x045C,
+	[PMIF_IRQ_EVENT_EN_4] =			0x0460,
+	[PMIF_IRQ_FLAG_4] =			0x0468,
+	[PMIF_IRQ_CLR_4] =			0x046C,
+	[PMIF_WDT_EVENT_EN_0] =			0x0474,
+	[PMIF_WDT_FLAG_0] =			0x0478,
+	[PMIF_WDT_EVENT_EN_1] =			0x047C,
+	[PMIF_WDT_FLAG_1] =			0x0480,
+	[PMIF_SWINF_0_ACC] =			0x0800,
+	[PMIF_SWINF_0_WDATA_31_0] =		0x0804,
+	[PMIF_SWINF_0_RDATA_31_0] =		0x0814,
+	[PMIF_SWINF_0_VLD_CLR] =		0x0824,
+	[PMIF_SWINF_0_STA] =			0x0828,
+	[PMIF_SWINF_1_ACC] =			0x0840,
+	[PMIF_SWINF_1_WDATA_31_0] =		0x0844,
+	[PMIF_SWINF_1_RDATA_31_0] =		0x0854,
+	[PMIF_SWINF_1_VLD_CLR] =		0x0864,
+	[PMIF_SWINF_1_STA] =			0x0868,
+	[PMIF_SWINF_2_ACC] =			0x0880,
+	[PMIF_SWINF_2_WDATA_31_0] =		0x0884,
+	[PMIF_SWINF_2_RDATA_31_0] =		0x0894,
+	[PMIF_SWINF_2_VLD_CLR] =		0x08A4,
+	[PMIF_SWINF_2_STA] =			0x08A8,
+	[PMIF_SWINF_3_ACC] =			0x08C0,
+	[PMIF_SWINF_3_WDATA_31_0] =		0x08C4,
+	[PMIF_SWINF_3_RDATA_31_0] =		0x08D4,
+	[PMIF_SWINF_3_VLD_CLR] =		0x08E4,
+	[PMIF_SWINF_3_STA] =			0x08E8,
+};
+
+enum spmi_regs {
+	SPMI_OP_ST_CTRL,
+	SPMI_GRP_ID_EN,
+	SPMI_OP_ST_STA,
+	SPMI_MST_SAMPL,
+	SPMI_MST_REQ_EN,
+	SPMI_REC_CTRL,
+	SPMI_REC0,
+	SPMI_REC1,
+	SPMI_REC2,
+	SPMI_REC3,
+	SPMI_REC4,
+	SPMI_MST_DBG,
+
+	/* MT8195 spmi regs */
+	SPMI_MST_RCS_CTRL,
+	SPMI_SLV_3_0_EINT,
+	SPMI_SLV_7_4_EINT,
+	SPMI_SLV_B_8_EINT,
+	SPMI_SLV_F_C_EINT,
+	SPMI_REC_CMD_DEC,
+	SPMI_DEC_DBG,
+};
+
+static const u32 mt6873_spmi_regs[] = {
+	[SPMI_OP_ST_CTRL] =	0x0000,
+	[SPMI_GRP_ID_EN] =	0x0004,
+	[SPMI_OP_ST_STA] =	0x0008,
+	[SPMI_MST_SAMPL] =	0x000c,
+	[SPMI_MST_REQ_EN] =	0x0010,
+	[SPMI_REC_CTRL] =	0x0040,
+	[SPMI_REC0] =		0x0044,
+	[SPMI_REC1] =		0x0048,
+	[SPMI_REC2] =		0x004c,
+	[SPMI_REC3] =		0x0050,
+	[SPMI_REC4] =		0x0054,
+	[SPMI_MST_DBG] =	0x00fc,
+};
+
+static const u32 mt8195_spmi_regs[] = {
+	[SPMI_OP_ST_CTRL] =	0x0000,
+	[SPMI_GRP_ID_EN] =	0x0004,
+	[SPMI_OP_ST_STA] =	0x0008,
+	[SPMI_MST_SAMPL] =	0x000C,
+	[SPMI_MST_REQ_EN] =	0x0010,
+	[SPMI_MST_RCS_CTRL] =	0x0014,
+	[SPMI_SLV_3_0_EINT] =	0x0020,
+	[SPMI_SLV_7_4_EINT] =	0x0024,
+	[SPMI_SLV_B_8_EINT] =	0x0028,
+	[SPMI_SLV_F_C_EINT] =	0x002C,
+	[SPMI_REC_CTRL] =	0x0040,
+	[SPMI_REC0] =		0x0044,
+	[SPMI_REC1] =		0x0048,
+	[SPMI_REC2] =		0x004C,
+	[SPMI_REC3] =		0x0050,
+	[SPMI_REC4] =		0x0054,
+	[SPMI_REC_CMD_DEC] =	0x005C,
+	[SPMI_DEC_DBG] =	0x00F8,
+	[SPMI_MST_DBG] =	0x00FC,
+};
+
+static u32 pmif_readl(struct pmif *arb, enum pmif_regs reg)
+{
+	return readl(arb->base + arb->data->regs[reg]);
+}
+
+static void pmif_writel(struct pmif *arb, u32 val, enum pmif_regs reg)
+{
+	writel(val, arb->base + arb->data->regs[reg]);
+}
+
+static void mtk_spmi_writel(struct pmif *arb, u32 val, enum spmi_regs reg)
+{
+	writel(val, arb->spmimst_base + arb->data->spmimst_regs[reg]);
+}
+
+static bool pmif_is_fsm_vldclr(struct pmif *arb)
+{
+	u32 reg_rdata;
+
+	reg_rdata = pmif_readl(arb, arb->chan.ch_sta);
+	return GET_SWINF(reg_rdata) == SWINF_WFVLDCLR;
+}
+
+static int pmif_arb_cmd(struct spmi_controller *ctrl, u8 opc, u8 sid)
+{
+	struct pmif *arb = spmi_controller_get_drvdata(ctrl);
+	u32 rdata, cmd;
+	int ret;
+
+	/* Check the opcode */
+	if (opc < SPMI_CMD_RESET || opc > SPMI_CMD_WAKEUP)
+		return -EINVAL;
+
+	cmd = opc - SPMI_CMD_RESET;
+
+	mtk_spmi_writel(arb, (cmd << 0x4) | sid, SPMI_OP_ST_CTRL);
+	ret = readl_poll_timeout_atomic(arb->spmimst_base + arb->data->spmimst_regs[SPMI_OP_ST_STA],
+					rdata, (rdata & SPMI_OP_ST_BUSY) == SPMI_OP_ST_BUSY,
+					PMIF_DELAY_US, PMIF_TIMEOUT_US);
+	if (ret < 0)
+		dev_err(&ctrl->dev, "timeout, err = %d\n", ret);
+
+	return ret;
+}
+
+static int pmif_spmi_read_cmd(struct spmi_controller *ctrl, u8 opc, u8 sid,
+			      u16 addr, u8 *buf, size_t len)
+{
+	struct pmif *arb = spmi_controller_get_drvdata(ctrl);
+	struct ch_reg *inf_reg;
+	int ret;
+	u32 data, cmd;
+
+	/* Check for argument validation. */
+	if (sid & ~0xf) {
+		dev_err(&ctrl->dev, "exceed the max slv id\n");
+		return -EINVAL;
+	}
+
+	if (len > 4) {
+		dev_err(&ctrl->dev, "pmif supports 1..4 bytes per trans, but:%zu requested", len);
+		return -EINVAL;
+	}
+
+	if (opc >= 0x60 && opc <= 0x7f)
+		opc = PMIF_CMD_REG;
+	else if ((opc >= 0x20 && opc <= 0x2f) || (opc >= 0x38 && opc <= 0x3f))
+		opc = PMIF_CMD_EXT_REG_LONG;
+	else
+		return -EINVAL;
+
+	/* Wait for Software Interface FSM state to be IDLE. */
+	inf_reg = &arb->chan;
+	ret = readl_poll_timeout_atomic(arb->base + arb->data->regs[inf_reg->ch_sta],
+					data, GET_SWINF(data) == SWINF_IDLE,
+					PMIF_DELAY_US, PMIF_TIMEOUT_US);
+	if (ret < 0) {
+		/* set channel ready if the data has transferred */
+		if (pmif_is_fsm_vldclr(arb))
+			pmif_writel(arb, 1, inf_reg->ch_rdy);
+		dev_err(&ctrl->dev, "failed to wait for SWINF_IDLE\n");
+		goto out;
+	}
+
+	/* Send the command. */
+	cmd = (opc << 30) | (sid << 24) | ((len - 1) << 16) | addr;
+	pmif_writel(arb, cmd, inf_reg->ch_send);
+
+	/*
+	 * Wait for Software Interface FSM state to be WFVLDCLR,
+	 * read the data and clear the valid flag.
+	 */
+	ret = readl_poll_timeout_atomic(arb->base + arb->data->regs[inf_reg->ch_sta],
+					data, GET_SWINF(data) == SWINF_WFVLDCLR,
+					PMIF_DELAY_US, PMIF_TIMEOUT_US);
+	if (ret < 0) {
+		dev_err(&ctrl->dev, "failed to wait for SWINF_WFVLDCLR\n");
+		goto out;
+	}
+
+	data = pmif_readl(arb, inf_reg->rdata);
+	memcpy(buf, &data, len);
+	pmif_writel(arb, 1, inf_reg->ch_rdy);
+
+out:
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static int pmif_spmi_write_cmd(struct spmi_controller *ctrl, u8 opc, u8 sid,
+			       u16 addr, const u8 *buf, size_t len)
+{
+	struct pmif *arb = spmi_controller_get_drvdata(ctrl);
+	struct ch_reg *inf_reg;
+	int ret;
+	u32 data, cmd;
+
+	if (len > 4) {
+		dev_err(&ctrl->dev, "pmif supports 1..4 bytes per trans, but:%zu requested", len);
+		return -EINVAL;
+	}
+
+	/* Check the opcode */
+	if (opc >= 0x40 && opc <= 0x5F)
+		opc = PMIF_CMD_REG;
+	else if ((opc <= 0xF) || (opc >= 0x30 && opc <= 0x37))
+		opc = PMIF_CMD_EXT_REG_LONG;
+	else if (opc >= 0x80)
+		opc = PMIF_CMD_REG_0;
+	else
+		return -EINVAL;
+
+	/* Wait for Software Interface FSM state to be IDLE. */
+	inf_reg = &arb->chan;
+	ret = readl_poll_timeout_atomic(arb->base + arb->data->regs[inf_reg->ch_sta],
+					data, GET_SWINF(data) == SWINF_IDLE,
+					PMIF_DELAY_US, PMIF_TIMEOUT_US);
+	if (ret < 0) {
+		/* set channel ready if the data has transferred */
+		if (pmif_is_fsm_vldclr(arb))
+			pmif_writel(arb, 1, inf_reg->ch_rdy);
+		dev_err(&ctrl->dev, "failed to wait for SWINF_IDLE\n");
+		goto out;
+	}
+
+	/* Set the write data. */
+	memcpy(&data, buf, len);
+	pmif_writel(arb, data, inf_reg->wdata);
+
+	/* Send the command. */
+	cmd = (opc << 30) | BIT(29) | (sid << 24) | ((len - 1) << 16) | addr;
+	pmif_writel(arb, cmd, inf_reg->ch_send);
+
+out:
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static const struct pmif_data mt6873_pmif_arb = {
+	.regs = mt6873_regs,
+	.spmimst_regs = mt6873_spmi_regs,
+	.soc_chan = 2,
+};
+
+static const struct pmif_data mt8195_pmif_arb[] = {
+	{
+		.regs = mt8195_regs,
+		.spmimst_regs = mt8195_spmi_regs,
+		.soc_chan = 2,
+	},
+};
+
+static int mtk_spmi_probe(struct platform_device *pdev)
+{
+	struct pmif *arb;
+	struct spmi_controller *ctrl;
+	int err, i;
+	u32 chan_offset;
+
+	ctrl = spmi_controller_alloc(&pdev->dev, sizeof(*arb));
+	if (!ctrl)
+		return -ENOMEM;
+
+	arb = spmi_controller_get_drvdata(ctrl);
+	arb->data = of_device_get_match_data(&pdev->dev);
+	if (!arb->data) {
+		err = -EINVAL;
+		dev_err(&pdev->dev, "Cannot get drv_data\n");
+		goto err_put_ctrl;
+	}
+
+	arb->base = devm_platform_ioremap_resource_byname(pdev, "pmif");
+	if (IS_ERR(arb->base)) {
+		err = PTR_ERR(arb->base);
+		dev_err(&pdev->dev, "pmif failed to get the remappped memory\n");
+		goto err_put_ctrl;
+	}
+
+	arb->spmimst_base = devm_platform_ioremap_resource_byname(pdev, "spmimst");
+	if (IS_ERR(arb->spmimst_base)) {
+		err = PTR_ERR(arb->spmimst_base);
+		dev_err(&pdev->dev, "spmimst failed to get the remappped memory\n");
+		goto err_put_ctrl;
+	}
+
+	arb->nclks = ARRAY_SIZE(pmif_clock_names);
+	if (arb->nclks > PMIF_MAX_CLKS) {
+		err = -EINVAL;
+		dev_err(&pdev->dev, "exceed the max clock numbers\n");
+		goto err_put_ctrl;
+	}
+
+	for (i = 0; i < arb->nclks; i++)
+		arb->clks[i].id = pmif_clock_names[i];
+
+	err = devm_clk_bulk_get(&pdev->dev, arb->nclks, arb->clks);
+	if (err) {
+		dev_err(&pdev->dev, "Failed to get clocks: %d\n", err);
+		goto err_put_ctrl;
+	}
+
+	err = clk_bulk_prepare_enable(arb->nclks, arb->clks);
+	if (err) {
+		dev_err(&pdev->dev, "Failed to enable clocks: %d\n", err);
+		goto err_put_ctrl;
+	}
+
+	ctrl->cmd = pmif_arb_cmd;
+	ctrl->read_cmd = pmif_spmi_read_cmd;
+	ctrl->write_cmd = pmif_spmi_write_cmd;
+
+	chan_offset = PMIF_CHAN_OFFSET * arb->data->soc_chan;
+	arb->chan.ch_sta = PMIF_SWINF_0_STA + chan_offset;
+	arb->chan.wdata = PMIF_SWINF_0_WDATA_31_0 + chan_offset;
+	arb->chan.rdata = PMIF_SWINF_0_RDATA_31_0 + chan_offset;
+	arb->chan.ch_send = PMIF_SWINF_0_ACC + chan_offset;
+	arb->chan.ch_rdy = PMIF_SWINF_0_VLD_CLR + chan_offset;
+
+	platform_set_drvdata(pdev, ctrl);
+
+	err = spmi_controller_add(ctrl);
+	if (err)
+		goto err_domain_remove;
+
+	return 0;
+
+err_domain_remove:
+	clk_bulk_disable_unprepare(arb->nclks, arb->clks);
+err_put_ctrl:
+	spmi_controller_put(ctrl);
+	return err;
+}
+
+static int mtk_spmi_remove(struct platform_device *pdev)
+{
+	struct spmi_controller *ctrl = platform_get_drvdata(pdev);
+	struct pmif *arb = spmi_controller_get_drvdata(ctrl);
+
+	clk_bulk_disable_unprepare(arb->nclks, arb->clks);
+	spmi_controller_remove(ctrl);
+	spmi_controller_put(ctrl);
+	return 0;
+}
+
+static const struct of_device_id mtk_spmi_match_table[] = {
+	{
+		.compatible = "mediatek,mt6873-spmi",
+		.data = &mt6873_pmif_arb,
+	}, {
+		.compatible = "mediatek,mt8195-spmi",
+		.data = &mt8195_pmif_arb,
+	}, {
+		/* sentinel */
+	},
+};
+MODULE_DEVICE_TABLE(of, mtk_spmi_match_table);
+
+static struct platform_driver mtk_spmi_driver = {
+	.driver		= {
+		.name	= "spmi-mtk",
+		.of_match_table = of_match_ptr(mtk_spmi_match_table),
+	},
+	.probe		= mtk_spmi_probe,
+	.remove		= mtk_spmi_remove,
+};
+module_platform_driver(mtk_spmi_driver);
+
+MODULE_AUTHOR("Hsin-Hsiung Wang <hsin-hsiung.wang@mediatek.com>");
+MODULE_DESCRIPTION("MediaTek SPMI Driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/thermal/Kconfig b/drivers/thermal/Kconfig
index 7edc8dc6bbabe81d088fe6ef60dc63f531717237..b2da0a1bda3424daae3e7ce8d4438bdc4815e7c3 100644
--- a/drivers/thermal/Kconfig
+++ b/drivers/thermal/Kconfig
@@ -401,16 +401,10 @@ config DA9062_THERMAL
 	  zone.
 	  Compatible with the DA9062 and DA9061 PMICs.
 
-config MTK_THERMAL
-	tristate "Temperature sensor driver for mediatek SoCs"
-	depends on ARCH_MEDIATEK || COMPILE_TEST
-	depends on HAS_IOMEM
-	depends on NVMEM || NVMEM=n
-	depends on RESET_CONTROLLER
-	default y
-	help
-	  Enable this option if you want to have support for thermal management
-	  controller present in Mediatek SoCs
+menu "Mediatek thermal drivers"
+depends on ARCH_MEDIATEK || COMPILE_TEST
+source "drivers/thermal/mediatek/Kconfig"
+endmenu
 
 config AMLOGIC_THERMAL
 	tristate "Amlogic Thermal Support"
diff --git a/drivers/thermal/Makefile b/drivers/thermal/Makefile
index b64dd50a662922cd5e9b118b0681e668bc166910..f9e07c3f529eedeb9479fad1243b429775e8fe4b 100644
--- a/drivers/thermal/Makefile
+++ b/drivers/thermal/Makefile
@@ -55,7 +55,7 @@ obj-y				+= st/
 obj-$(CONFIG_QCOM_TSENS)	+= qcom/
 obj-y				+= tegra/
 obj-$(CONFIG_HISI_THERMAL)     += hisi_thermal.o
-obj-$(CONFIG_MTK_THERMAL)	+= mtk_thermal.o
+obj-$(CONFIG_MTK_THERMAL)	+= mediatek/
 obj-$(CONFIG_GENERIC_ADC_THERMAL)	+= thermal-generic-adc.o
 obj-$(CONFIG_ZX2967_THERMAL)	+= zx2967_thermal.o
 obj-$(CONFIG_UNIPHIER_THERMAL)	+= uniphier_thermal.o
diff --git a/drivers/thermal/mediatek/Kconfig b/drivers/thermal/mediatek/Kconfig
new file mode 100644
index 0000000000000000000000000000000000000000..d716d0372e1ea36daaf805d9d2a776489072ba80
--- /dev/null
+++ b/drivers/thermal/mediatek/Kconfig
@@ -0,0 +1,33 @@
+config MTK_THERMAL
+	tristate "Mediatek thermal drivers"
+	depends on THERMAL_OF
+	help
+	  This is the option for Mediatek thermal software
+	  solutions. Please enable corresponding options to
+	  get temperature information from thermal sensors or
+	  turn on throttle mechaisms for thermal mitigation.
+
+if MTK_THERMAL
+
+config MTK_SOC_THERMAL
+	tristate "Temperature sensor driver for mediatek SoCs"
+	depends on HAS_IOMEM
+	depends on NVMEM
+	depends on RESET_CONTROLLER
+	help
+	  Enable this option if you want to get SoC temperature
+	  information for Mediatek platforms. This driver
+	  configures thermal controllers to collect temperature
+	  via AUXADC interface.
+
+config MTK_SOC_THERMAL_LVTS
+        tristate "LVTS (Low voltage thermal sensor) driver for Mediatek SoCs"
+        depends on HAS_IOMEM
+        depends on NVMEM
+        depends on RESET_TI_SYSCON
+        help
+          Enable this option if you want to get SoC temperature
+          information for Mediatek platforms. This driver
+          configures LVTS thermal controllers to collect temperatures
+          via Analog Serial Interface(ASIF).
+endif
diff --git a/drivers/thermal/mediatek/Makefile b/drivers/thermal/mediatek/Makefile
new file mode 100644
index 0000000000000000000000000000000000000000..16ce166e59162e3d5649650ddaf5c699ea6cf647
--- /dev/null
+++ b/drivers/thermal/mediatek/Makefile
@@ -0,0 +1,2 @@
+obj-$(CONFIG_MTK_SOC_THERMAL)	+= soc_temp.o
+obj-$(CONFIG_MTK_SOC_THERMAL_LVTS)	+= soc_temp_lvts.o
diff --git a/drivers/thermal/mtk_thermal.c b/drivers/thermal/mediatek/soc_temp.c
similarity index 100%
rename from drivers/thermal/mtk_thermal.c
rename to drivers/thermal/mediatek/soc_temp.c
diff --git a/drivers/thermal/mediatek/soc_temp_lvts.c b/drivers/thermal/mediatek/soc_temp_lvts.c
new file mode 100644
index 0000000000000000000000000000000000000000..cdec17aba9c3bd1566c745e682e5c762d8976206
--- /dev/null
+++ b/drivers/thermal/mediatek/soc_temp_lvts.c
@@ -0,0 +1,1462 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2020 MediaTek Inc.
+ */
+
+#include <linux/bits.h>
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/iopoll.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/nvmem-consumer.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_device.h>
+#include <linux/of_irq.h>
+#include <linux/platform_device.h>
+#include <linux/reset.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/thermal.h>
+#include "soc_temp_lvts.h"
+
+/*==================================================
+ * Definition or macro function
+ *==================================================
+ */
+#define STOP_COUNTING_V4 (DEVICE_WRITE | RG_TSFM_CTRL_0 << 8 | 0x00)
+#define SET_RG_TSFM_LPDLY_V4 (DEVICE_WRITE | RG_TSFM_CTRL_4 << 8 | 0xA6)
+#define SET_COUNTING_WINDOW_20US1_V4 (DEVICE_WRITE | RG_TSFM_CTRL_2 << 8 | 0x00)
+#define SET_COUNTING_WINDOW_20US2_V4 (DEVICE_WRITE | RG_TSFM_CTRL_1 << 8 | 0x20)
+#define TSV2F_CHOP_CKSEL_AND_TSV2F_EN_V4 (DEVICE_WRITE | RG_TSV2F_CTRL_2 << 8 | 0x84)
+#define TSBG_DEM_CKSEL_X_TSBG_CHOP_EN_V4 (DEVICE_WRITE | RG_TSV2F_CTRL_4 << 8 | 0x7C)
+#define SET_TS_RSV_V4 (DEVICE_WRITE | RG_TSV2F_CTRL_1 << 8 | 0x8D)
+#define SET_TS_EN_V4 (DEVICE_WRITE | RG_TSV2F_CTRL_0 << 8 | 0xF4)
+#define TOGGLE_RG_TSV2F_VCO_RST1_V4 (DEVICE_WRITE | RG_TSV2F_CTRL_0 << 8 | 0xFC)
+#define TOGGLE_RG_TSV2F_VCO_RST2_V4 (DEVICE_WRITE | RG_TSV2F_CTRL_0 << 8 | 0xF4)
+
+#define SET_LVTS_AUTO_RCK_V4 (DEVICE_WRITE | RG_TSV2F_CTRL_6 << 8 | 0x01)
+#define SELECT_SENSOR_RCK_V4(id) (DEVICE_WRITE | RG_TSV2F_CTRL_5 << 8 | (id))
+#define SET_DEVICE_SINGLE_MODE_V4 (DEVICE_WRITE | RG_TSFM_CTRL_3 << 8 | 0x78)
+#define KICK_OFF_RCK_COUNTING_V4 (DEVICE_WRITE | RG_TSFM_CTRL_0 << 8 | 0x02)
+#define SET_SENSOR_NO_RCK_V4 (DEVICE_WRITE | RG_TSV2F_CTRL_5 << 8 | 0x10)
+#define SET_DEVICE_LOW_POWER_SINGLE_MODE_V4 (DEVICE_WRITE | RG_TSFM_CTRL_3 << 8	| 0xB8)
+
+#define ENABLE_FEATURE(feature)		(lvts_data->feature_bitmap |= (feature))
+#define DISABLE_FEATURE(feature)	(lvts_data->feature_bitmap &= (~(feature)))
+#define IS_ENABLE(feature)		(lvts_data->feature_bitmap & (feature))
+
+#define DISABLE_THERMAL_HW_REBOOT (-274000)
+
+#define CLOCK_26MHZ_CYCLE_NS	(38)
+#define BUS_ACCESS_US		(2)
+#define GOLDEN_TEMP_MAX		(62)
+
+#define FEATURE_DEVICE_AUTO_RCK	(BIT(0))
+#define FEATURE_CK26M_ACTIVE	(BIT(1))
+#define CK26M_ACTIVE   (((lvts_data->feature_bitmap & FEATURE_CK26M_ACTIVE)    \
+			? 1 : 0) << 30)
+#define GET_BASE_ADDR(tc_id)	\
+	(lvts_data->domain[lvts_data->tc[tc_id].domain_index].base	\
+	+ lvts_data->tc[tc_id].addr_offset)
+
+#define SET_TC_SPEED_IN_US(pu, gd, fd, sd) \
+	{	\
+		.period_unit = (((pu) * 1000) / (256 * CLOCK_26MHZ_CYCLE_NS)),	\
+		.group_interval_delay = ((gd) / (pu)),	\
+		.filter_interval_delay = ((fd) / (pu)),	\
+		.sensor_interval_delay = ((sd) / (pu)),	\
+	}
+
+#define GET_CAL_DATA_BITMASK(index, h, l)	\
+	(((index) < lvts_data->num_efuse_addr)	\
+	? ((lvts_data->efuse[(index)] & GENMASK(h, l)) >> l)	\
+	: 0)
+
+#define GET_CAL_DATA_BIT(index, bit)	\
+	(((index) < lvts_data->num_efuse_addr)	\
+	? ((lvts_data->efuse[index] & BIT(bit)) >> (bit))	\
+	: 0)
+
+#define GET_TC_SENSOR_NUM(tc_id)	\
+	(lvts_data->tc[tc_id].num_sensor)
+
+#define ONE_SAMPLE (lvts_data->counting_window_us + 2 * BUS_ACCESS_US)
+
+#define NUM_OF_SAMPLE(tc_id)	\
+	((lvts_data->tc[tc_id].hw_filter < LVTS_FILTER_2) ? 1 :	\
+	((lvts_data->tc[tc_id].hw_filter > LVTS_FILTER_16_OF_18) ? 1 :	\
+	((lvts_data->tc[tc_id].hw_filter == LVTS_FILTER_16_OF_18) ? 18 :\
+	((lvts_data->tc[tc_id].hw_filter == LVTS_FILTER_8_OF_10) ? 10 :	\
+	(lvts_data->tc[tc_id].hw_filter * 2)))))
+
+#define PERIOD_UNIT_US(tc_id)	\
+	((lvts_data->tc[tc_id].tc_speed.period_unit * 256 *	\
+	CLOCK_26MHZ_CYCLE_NS) / 1000)
+#define FILTER_INT_US(tc_id)	\
+	(lvts_data->tc[tc_id].tc_speed.filter_interval_delay	\
+	* PERIOD_UNIT_US(tc_id))
+#define SENSOR_INT_US(tc_id)	\
+	(lvts_data->tc[tc_id].tc_speed.sensor_interval_delay	\
+	* PERIOD_UNIT_US(tc_id))
+#define GROUP_INT_US(tc_id)	\
+	(lvts_data->tc[tc_id].tc_speed.group_interval_delay	\
+	* PERIOD_UNIT_US(tc_id))
+
+#define SENSOR_LATENCY_US(tc_id) \
+	((NUM_OF_SAMPLE(tc_id) - 1) * FILTER_INT_US(tc_id)	\
+	+ NUM_OF_SAMPLE(tc_id) * ONE_SAMPLE)
+
+#define GROUP_LATENCY_US(tc_id)	\
+	(GET_TC_SENSOR_NUM(tc_id) * SENSOR_LATENCY_US(tc_id)	\
+	+ (GET_TC_SENSOR_NUM(tc_id) - 1) * SENSOR_INT_US(tc_id)	\
+	+ GROUP_INT_US(tc_id))
+
+/*==================================================
+ * LVTS local common code
+ *==================================================
+ */
+static int lvts_raw_to_temp(struct formula_coeff *co, unsigned int msr_raw)
+{
+	/* This function returns degree mC */
+
+	int temp;
+
+	temp = (co->a * ((unsigned long long)msr_raw)) >> 14;
+	temp = temp + co->golden_temp * 500 + co->b;
+
+	return temp;
+}
+
+static unsigned int lvts_temp_to_raw(struct formula_coeff *co, int temp)
+{
+	unsigned int msr_raw;
+
+	msr_raw = ((long long)((co->golden_temp * 500 + co->b - temp)) << 14)
+		/ (-1 * co->a);
+
+	return msr_raw;
+}
+
+static int lvts_read_all_tc_temperature(struct lvts_data *lvts_data)
+{
+	struct tc_settings *tc = lvts_data->tc;
+	unsigned int i, j, s_index, msr_raw;
+	int max_temp = 0, current_temp;
+	void __iomem *base;
+
+	for (i = 0; i < lvts_data->num_tc; i++) {
+		base = GET_BASE_ADDR(i);
+		for (j = 0; j < tc[i].num_sensor; j++) {
+			s_index = tc[i].sensor_map[j];
+
+			msr_raw = readl(LVTSMSR0_0 + base + 0x4 * j) & MRS_RAW_MASK;
+			current_temp = lvts_raw_to_temp(&lvts_data->coeff, msr_raw);
+
+			if (msr_raw == 0)
+				current_temp = THERMAL_TEMP_INVALID;
+			max_temp = max(max_temp, current_temp);
+
+			lvts_data->sen_data[s_index].msr_raw = msr_raw;
+			lvts_data->sen_data[s_index].temp = current_temp;
+		}
+	}
+
+	return max_temp;
+}
+
+static int soc_temp_lvts_read_temp(void *data, int *temperature)
+{
+	struct soc_temp_tz *lvts_tz = (struct soc_temp_tz *)data;
+	struct lvts_data *lvts_data = lvts_tz->lvts_data;
+
+	if (lvts_tz->id == 0)
+		*temperature = lvts_read_all_tc_temperature(lvts_data);
+	else if (lvts_tz->id - 1 < lvts_data->num_sensor)
+		*temperature = lvts_data->sen_data[lvts_tz->id - 1].temp;
+	else
+		return -EINVAL;
+
+	return 0;
+}
+
+static const struct thermal_zone_of_device_ops soc_temp_lvts_ops = {
+	.get_temp = soc_temp_lvts_read_temp,
+};
+
+static void lvts_write_device(struct lvts_data *lvts_data, unsigned int data,
+			      int tc_id)
+{
+	void __iomem *base;
+
+	base = GET_BASE_ADDR(tc_id);
+
+	writel(data, LVTS_CONFIG_0 + base);
+
+	usleep_range(5, 15);
+}
+
+static unsigned int lvts_read_device(struct lvts_data *lvts_data,
+				     unsigned int reg_idx, int tc_id)
+{
+	struct device *dev = lvts_data->dev;
+	void __iomem *base;
+	unsigned int data;
+	int ret;
+
+	base = GET_BASE_ADDR(tc_id);
+	writel(READ_DEVICE_REG(reg_idx), LVTS_CONFIG_0 + base);
+
+	ret = readl_poll_timeout(LVTS_CONFIG_0 + base, data,
+				 !(data & DEVICE_ACCESS_STARTUS),
+				 2, 200);
+	if (ret)
+		dev_err(dev,
+			"Error: LVTS %d DEVICE_ACCESS_START didn't ready\n", tc_id);
+
+	data = readl(LVTSRDATA0_0 + base);
+
+	return data;
+}
+
+static void wait_all_tc_sensing_point_idle(struct lvts_data *lvts_data)
+{
+	struct device *dev = lvts_data->dev;
+	unsigned int mask, error_code, is_error;
+	void __iomem *base;
+	int i, cnt, ret;
+
+	mask = BIT(10) | BIT(7) | BIT(0);
+
+	for (cnt = 0; cnt < 2; cnt++) {
+		is_error = 0;
+		for (i = 0; i < lvts_data->num_tc; i++) {
+			base = GET_BASE_ADDR(i);
+			ret = readl_poll_timeout(LVTSMSRCTL1_0 + base, error_code,
+						 !(error_code & mask), 2, 200);
+			/*
+			 * Error code
+			 * 000: IDLE
+			 * 001: Write transaction
+			 * 010: Waiting for read after Write
+			 * 011: Disable Continue fetching on Device
+			 * 100: Read transaction
+			 * 101: Set Device special Register for Voltage threshold
+			 * 111: Set TSMCU number for Fetch
+			 */
+			error_code = ((error_code & BIT(10)) >> 8) +
+				((error_code & BIT(7)) >> 6) +
+				(error_code & BIT(0));
+
+			if (ret)
+				dev_err(dev,
+					"Error LVTS %d sensing points aren't idle, error_code %d\n",
+					i, error_code);
+
+			if (error_code != 0)
+				is_error = 1;
+		}
+
+		if (is_error == 0)
+			break;
+	}
+}
+
+static void lvts_reset(struct lvts_data *lvts_data)
+{
+	int i;
+
+	for (i = 0; i < lvts_data->num_domain; i++) {
+		if (lvts_data->domain[i].reset)
+			reset_control_assert(lvts_data->domain[i].reset);
+
+		if (lvts_data->domain[i].reset)
+			reset_control_deassert(lvts_data->domain[i].reset);
+	}
+}
+
+static void device_identification(struct lvts_data *lvts_data)
+{
+	struct device *dev = lvts_data->dev;
+	unsigned int i, data;
+	void __iomem *base;
+
+	for (i = 0; i < lvts_data->num_tc; i++) {
+		base = GET_BASE_ADDR(i);
+
+		writel(ENABLE_LVTS_CTRL_CLK, LVTSCLKEN_0 + base);
+
+		lvts_write_device(lvts_data, RESET_ALL_DEVICES, i);
+
+		lvts_write_device(lvts_data, READ_BACK_DEVICE_ID, i);
+
+		/* Check LVTS device ID */
+		data = (readl(LVTS_ID_0 + base) & GENMASK(7, 0));
+		if (data != (0x81 + i))
+			dev_err(dev, "LVTS_TC_%d, Device ID should be 0x%x, but 0x%x\n",
+				i, (0x81 + i), data);
+	}
+}
+
+static void disable_all_sensing_points(struct lvts_data *lvts_data)
+{
+	unsigned int i;
+	void __iomem *base;
+
+	for (i = 0; i < lvts_data->num_tc; i++) {
+		base = GET_BASE_ADDR(i);
+		writel(DISABLE_SENSING_POINT, LVTSMONCTL0_0 + base);
+	}
+}
+
+static void enable_all_sensing_points(struct lvts_data *lvts_data)
+{
+	struct device *dev = lvts_data->dev;
+	struct tc_settings *tc = lvts_data->tc;
+	unsigned int i, num;
+	void __iomem *base;
+
+	for (i = 0; i < lvts_data->num_tc; i++) {
+		base = GET_BASE_ADDR(i);
+		num = tc[i].num_sensor;
+
+		if (num > ALL_SENSING_POINTS) {
+			dev_err(dev,
+				"%s, LVTS%d, illegal number of sensors: %d\n",
+				__func__, i, tc[i].num_sensor);
+			continue;
+		}
+
+		writel(ENABLE_SENSING_POINT(num), LVTSMONCTL0_0 + base);
+	}
+}
+
+static void set_polling_speed(struct lvts_data *lvts_data, int tc_id)
+{
+	struct device *dev = lvts_data->dev;
+	struct tc_settings *tc = lvts_data->tc;
+	unsigned int lvts_mon_ctl_1, lvts_mon_ctl_2;
+	void __iomem *base;
+
+	base = GET_BASE_ADDR(tc_id);
+
+	lvts_mon_ctl_1 = ((tc[tc_id].tc_speed.group_interval_delay << 20) & GENMASK(29, 20)) |
+			(tc[tc_id].tc_speed.period_unit & GENMASK(9, 0));
+	lvts_mon_ctl_2 = ((tc[tc_id].tc_speed.filter_interval_delay << 16) & GENMASK(25, 16)) |
+			(tc[tc_id].tc_speed.sensor_interval_delay & GENMASK(9, 0));
+	/*
+	 * Clock source of LVTS thermal controller is 26MHz.
+	 * Period unit is a base for all interval delays
+	 * All interval delays must multiply it to convert a setting to time.
+	 * Filter interval delay is a delay between two samples of the same sensor
+	 * Sensor interval delay is a delay between two samples of differnet sensors
+	 * Group interval delay is a delay between different rounds.
+	 * For example:
+	 *     If Period unit = C, filter delay = 1, sensor delay = 2, group delay = 1,
+	 *     and two sensors, TS1 and TS2, are in a LVTS thermal controller
+	 *     and then
+	 *     Period unit = C * 1/26M * 256 = 12 * 38.46ns * 256 = 118.149us
+	 *     Filter interval delay = 1 * Period unit = 118.149us
+	 *     Sensor interval delay = 2 * Period unit = 236.298us
+	 *     Group interval delay = 1 * Period unit = 118.149us
+	 *
+	 *     TS1    TS1 ... TS1    TS2    TS2 ... TS2    TS1...
+	 *        <--> Filter interval delay
+	 *                       <--> Sensor interval delay
+	 *                                             <--> Group interval delay
+	 */
+	writel(lvts_mon_ctl_1, LVTSMONCTL1_0 + base);
+	writel(lvts_mon_ctl_2, LVTSMONCTL2_0 + base);
+
+	dev_info(dev, "%s %d, LVTSMONCTL1_0= 0x%x,LVTSMONCTL2_0= 0x%x\n",
+		 __func__, tc_id, readl(LVTSMONCTL1_0 + base),
+		 readl(LVTSMONCTL2_0 + base));
+}
+
+static void set_hw_filter(struct lvts_data *lvts_data, int tc_id)
+{
+	struct device *dev = lvts_data->dev;
+	struct tc_settings *tc = lvts_data->tc;
+	unsigned int option;
+	void __iomem *base;
+
+	base = GET_BASE_ADDR(tc_id);
+	option = tc[tc_id].hw_filter & 0x7;
+	/* hw filter
+	 * 000: Get one sample
+	 * 001: Get 2 samples and average them
+	 * 010: Get 4 samples, drop max and min, then average the rest of 2 samples
+	 * 011: Get 6 samples, drop max and min, then average the rest of 4 samples
+	 * 100: Get 10 samples, drop max and min, then average the rest of 8 samples
+	 * 101: Get 18 samples, drop max and min, then average the rest of 16 samples
+	 */
+	option = (option << 9) | (option << 6) | (option << 3) | option;
+
+	writel(option, LVTSMSRCTL0_0 + base);
+	dev_info(dev, "%s %d, LVTSMSRCTL0_0= 0x%x\n",
+		 __func__, tc_id, readl(LVTSMSRCTL0_0 + base));
+}
+
+static int get_dominator_index(struct lvts_data *lvts_data, int tc_id)
+{
+	struct device *dev = lvts_data->dev;
+	struct tc_settings *tc = lvts_data->tc;
+	int d_index;
+
+	if (tc[tc_id].dominator_sensing_point == ALL_SENSING_POINTS) {
+		d_index = ALL_SENSING_POINTS;
+	} else if (tc[tc_id].dominator_sensing_point <
+		tc[tc_id].num_sensor){
+		d_index = tc[tc_id].dominator_sensing_point;
+	} else {
+		dev_err(dev,
+			"Error: LVTS%d, dominator_sensing_point= %d should smaller than num_sensor= %d\n",
+			tc_id, tc[tc_id].dominator_sensing_point,
+			tc[tc_id].num_sensor);
+
+		dev_err(dev, "Use the sensing point 0 as the dominated sensor\n");
+		d_index = SENSING_POINT0;
+	}
+
+	return d_index;
+}
+
+static void disable_hw_reboot_interrupt(struct lvts_data *lvts_data, int tc_id)
+{
+	unsigned int temp;
+	void __iomem *base;
+
+	base = GET_BASE_ADDR(tc_id);
+
+	/* LVTS thermal controller has two interrupts for thermal HW reboot
+	 * One is for AP SW and the other is for RGU
+	 * The interrupt of AP SW can turn off by a bit of a register, but
+	 * the other for RGU cannot.
+	 * To prevent rebooting device accidentally, we are going to add
+	 * a huge offset to LVTS and make LVTS always report extremely low
+	 * temperature.
+	 */
+
+	/* After adding the huge offset 0x3FFF, LVTS alawys adds the
+	 * offset to MSR_RAW.
+	 * When MSR_RAW is larger, SW will convert lower temperature/
+	 */
+	temp = readl(LVTSPROTCTL_0 + base);
+	writel(temp | 0x3FFF, LVTSPROTCTL_0 + base);
+
+	/* Disable the interrupt of AP SW */
+	temp = readl(LVTSMONINT_0 + base);
+	writel(temp & ~(STAGE3_INT_EN), LVTSMONINT_0 + base);
+}
+
+static void enable_hw_reboot_interrupt(struct lvts_data *lvts_data, int tc_id)
+{
+	unsigned int temp;
+	void __iomem *base;
+
+	base = GET_BASE_ADDR(tc_id);
+
+	/* Enable the interrupt of AP SW */
+	temp = readl(LVTSMONINT_0 + base);
+	writel(temp | STAGE3_INT_EN, LVTSMONINT_0 + base);
+	/* Clear the offset */
+	temp = readl(LVTSPROTCTL_0 + base);
+	writel(temp & ~PROTOFFSET, LVTSPROTCTL_0 + base);
+}
+
+static void set_tc_hw_reboot_threshold(struct lvts_data *lvts_data,
+				       int trip_point, int tc_id)
+{
+	struct device *dev = lvts_data->dev;
+	unsigned int msr_raw, temp, config, d_index;
+	void __iomem *base;
+
+	base = GET_BASE_ADDR(tc_id);
+	d_index = get_dominator_index(lvts_data, tc_id);
+
+	dev_info(dev, "%s: LVTS%d, the dominator sensing point= %d\n",
+		 __func__, tc_id, d_index);
+
+	disable_hw_reboot_interrupt(lvts_data, tc_id);
+
+	temp = readl(LVTSPROTCTL_0 + base);
+	if (d_index == ALL_SENSING_POINTS) {
+		/* Maximum of 4 sensing points */
+		config = (0x1 << 16);
+		writel(config | temp, LVTSPROTCTL_0 + base);
+	} else {
+		/* Select protection sensor */
+		config = ((d_index << 2) + 0x2) << 16;
+		writel(config | temp, LVTSPROTCTL_0 + base);
+	}
+
+	msr_raw = lvts_temp_to_raw(&lvts_data->coeff, trip_point);
+	writel(msr_raw, LVTSPROTTC_0 + base);
+
+	enable_hw_reboot_interrupt(lvts_data, tc_id);
+}
+
+static void set_all_tc_hw_reboot(struct lvts_data *lvts_data)
+{
+	struct tc_settings *tc = lvts_data->tc;
+	int i, trip_point;
+
+	for (i = 0; i < lvts_data->num_tc; i++) {
+		trip_point = tc[i].hw_reboot_trip_point;
+
+		if (tc[i].num_sensor == 0)
+			continue;
+
+		if (trip_point == DISABLE_THERMAL_HW_REBOOT)
+			continue;
+
+		set_tc_hw_reboot_threshold(lvts_data, trip_point, i);
+	}
+}
+
+static int lvts_init(struct lvts_data *lvts_data)
+{
+	struct platform_ops *ops = &lvts_data->ops;
+	struct device *dev = lvts_data->dev;
+	int ret;
+
+	ret = clk_prepare_enable(lvts_data->clk);
+	if (ret) {
+		dev_err(dev,
+			"Error: Failed to enable lvts controller clock: %d\n",
+			ret);
+		return ret;
+	}
+
+	lvts_reset(lvts_data);
+
+	device_identification(lvts_data);
+	if (ops->device_enable_and_init)
+		ops->device_enable_and_init(lvts_data);
+
+	if (IS_ENABLE(FEATURE_DEVICE_AUTO_RCK)) {
+		if (ops->device_enable_auto_rck)
+			ops->device_enable_auto_rck(lvts_data);
+	} else {
+		if (ops->device_read_count_rc_n)
+			ops->device_read_count_rc_n(lvts_data);
+	}
+
+	if (ops->set_cal_data)
+		ops->set_cal_data(lvts_data);
+
+	disable_all_sensing_points(lvts_data);
+	wait_all_tc_sensing_point_idle(lvts_data);
+	if (ops->init_controller)
+		ops->init_controller(lvts_data);
+	enable_all_sensing_points(lvts_data);
+
+	set_all_tc_hw_reboot(lvts_data);
+
+	return 0;
+}
+
+static int prepare_calibration_data(struct lvts_data *lvts_data)
+{
+	struct device *dev = lvts_data->dev;
+	struct sensor_cal_data *cal_data = &lvts_data->cal_data;
+	struct platform_ops *ops = &lvts_data->ops;
+	int i, offset, size;
+	char buffer[512];
+
+	cal_data->count_r = devm_kcalloc(dev, lvts_data->num_sensor,
+					 sizeof(*cal_data->count_r), GFP_KERNEL);
+	if (!cal_data->count_r)
+		return -ENOMEM;
+
+	cal_data->count_rc = devm_kcalloc(dev, lvts_data->num_sensor,
+					  sizeof(*cal_data->count_rc), GFP_KERNEL);
+	if (!cal_data->count_rc)
+		return -ENOMEM;
+
+	if (ops->efuse_to_cal_data && !cal_data->use_fake_efuse)
+		ops->efuse_to_cal_data(lvts_data);
+	if (cal_data->golden_temp == 0 || cal_data->golden_temp > GOLDEN_TEMP_MAX)
+		cal_data->use_fake_efuse = 1;
+
+	if (cal_data->use_fake_efuse) {
+		/* It means all efuse data are equal to 0 */
+		dev_err(dev,
+			"[lvts_cal] This sample is not calibrated, fake !!\n");
+
+		cal_data->golden_temp = cal_data->default_golden_temp;
+		for (i = 0; i < lvts_data->num_sensor; i++) {
+			cal_data->count_r[i] = cal_data->default_count_r;
+			cal_data->count_rc[i] = cal_data->default_count_rc;
+		}
+	}
+
+	lvts_data->coeff.golden_temp = cal_data->golden_temp;
+
+	dev_info(dev, "[lvts_cal] golden_temp = %d\n", cal_data->golden_temp);
+
+	size = sizeof(buffer);
+	offset = snprintf(buffer, size, "[lvts_cal] num:g_count:g_count_rc ");
+	for (i = 0; i < lvts_data->num_sensor; i++)
+		offset += snprintf(buffer + offset, size - offset, "%d:%d:%d ",
+				   i, cal_data->count_r[i], cal_data->count_rc[i]);
+
+	buffer[offset] = '\0';
+	dev_info(dev, "%s\n", buffer);
+
+	return 0;
+}
+
+static int get_calibration_data(struct lvts_data *lvts_data)
+{
+	struct device *dev = lvts_data->dev;
+	char cell_name[8];
+	struct nvmem_cell *cell;
+	u32 *buf;
+	size_t len;
+	int i, j, index = 0, ret;
+
+	lvts_data->efuse = devm_kcalloc(dev, lvts_data->num_efuse_addr,
+					sizeof(*lvts_data->efuse), GFP_KERNEL);
+	if (!lvts_data->efuse)
+		return -ENOMEM;
+
+	for (i = 0; i < lvts_data->num_efuse_block; i++) {
+		snprintf(cell_name, sizeof(cell_name), "e_data%d", i + 1);
+		cell = nvmem_cell_get(dev, cell_name);
+		if (IS_ERR(cell)) {
+			dev_err(dev, "Error: Failed to get nvmem cell %s\n", cell_name);
+			return PTR_ERR(cell);
+		}
+
+		buf = (u32 *)nvmem_cell_read(cell, &len);
+		nvmem_cell_put(cell);
+
+		if (IS_ERR(buf))
+			return PTR_ERR(buf);
+
+		for (j = 0; j < (len / sizeof(u32)); j++) {
+			if (index >= lvts_data->num_efuse_addr) {
+				dev_err(dev, "Array efuse is going to overflow");
+				kfree(buf);
+				return -EINVAL;
+			}
+
+			lvts_data->efuse[index] = buf[j];
+			index++;
+		}
+
+		kfree(buf);
+	}
+
+	ret = prepare_calibration_data(lvts_data);
+
+	return ret;
+}
+
+static int of_update_lvts_data(struct lvts_data *lvts_data,
+			       struct platform_device *pdev)
+{
+	struct device *dev = lvts_data->dev;
+	struct power_domain *domain;
+	struct resource *res;
+	unsigned int i;
+	int ret;
+
+	lvts_data->clk = devm_clk_get(dev, "lvts_clk");
+	if (IS_ERR(lvts_data->clk))
+		return PTR_ERR(lvts_data->clk);
+
+	domain = devm_kcalloc(dev, lvts_data->num_domain, sizeof(*domain), GFP_KERNEL);
+	if (!domain)
+		return -ENOMEM;
+
+	for (i = 0; i < lvts_data->num_domain; i++) {
+		/* Get base address */
+		res = platform_get_resource(pdev, IORESOURCE_MEM, i);
+		if (!res) {
+			dev_err(dev, "No IO resource, index %d\n", i);
+			return -ENXIO;
+		}
+
+		domain[i].base = devm_ioremap_resource(dev, res);
+		if (IS_ERR(domain[i].base)) {
+			dev_err(dev, "Failed to remap io, index %d\n", i);
+			return PTR_ERR(domain[i].base);
+		}
+
+		/* Get interrupt number */
+		res = platform_get_resource(pdev, IORESOURCE_IRQ, i);
+		if (!res) {
+			dev_err(dev, "No irq resource, index %d\n", i);
+			return -EINVAL;
+		}
+		domain[i].irq_num = res->start;
+
+		/* Get reset control */
+		domain[i].reset = devm_reset_control_get_by_index(dev, i);
+		if (IS_ERR(domain[i].reset)) {
+			dev_err(dev, "Failed to get, index %d\n", i);
+			return PTR_ERR(domain[i].reset);
+		}
+	}
+
+	lvts_data->domain = domain;
+
+	lvts_data->sen_data = devm_kcalloc(dev, lvts_data->num_sensor,
+					   sizeof(*lvts_data->sen_data), GFP_KERNEL);
+	if (!lvts_data->sen_data)
+		return -ENOMEM;
+
+	ret = get_calibration_data(lvts_data);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+static void lvts_device_close(struct lvts_data *lvts_data)
+{
+	unsigned int i;
+	void __iomem *base;
+
+	for (i = 0; i < lvts_data->num_tc; i++) {
+		base = GET_BASE_ADDR(i);
+		lvts_write_device(lvts_data, RESET_ALL_DEVICES, i);
+		writel(DISABLE_LVTS_CTRL_CLK, LVTSCLKEN_0 + base);
+	}
+}
+
+static void lvts_close(struct lvts_data *lvts_data)
+{
+	disable_all_sensing_points(lvts_data);
+	wait_all_tc_sensing_point_idle(lvts_data);
+	lvts_device_close(lvts_data);
+	clk_disable_unprepare(lvts_data->clk);
+}
+
+static void tc_irq_handler(struct lvts_data *lvts_data, int tc_id)
+{
+	struct device *dev = lvts_data->dev;
+	unsigned int ret = 0;
+	void __iomem *base;
+
+	base = GET_BASE_ADDR(tc_id);
+
+	ret = readl(LVTSMONINTSTS_0 + base);
+	/* Write back to clear interrupt status */
+	writel(ret, LVTSMONINTSTS_0 + base);
+
+	dev_info(dev, "[Thermal IRQ] LVTS thermal controller %d, LVTSMONINTSTS=0x%08x\n",
+		 tc_id, ret);
+
+	if (ret & THERMAL_PROTECTION_STAGE_3)
+		dev_info(dev,
+			 "[Thermal IRQ]: Thermal protection stage 3 interrupt triggered\n");
+}
+
+static irqreturn_t irq_handler(int irq, void *dev_id)
+{
+	struct lvts_data *lvts_data = (struct lvts_data *)dev_id;
+	struct device *dev = lvts_data->dev;
+	struct tc_settings *tc = lvts_data->tc;
+	unsigned int i, *irq_bitmap;
+	void __iomem *base;
+
+	irq_bitmap = kcalloc(lvts_data->num_domain, sizeof(*irq_bitmap), GFP_ATOMIC);
+
+	if (!irq_bitmap)
+		return IRQ_NONE;
+
+	for (i = 0; i < lvts_data->num_domain; i++) {
+		base = lvts_data->domain[i].base;
+		irq_bitmap[i] = readl(THERMINTST + base);
+		dev_info(dev, "%s : THERMINTST = 0x%x\n", __func__, irq_bitmap[i]);
+	}
+
+	for (i = 0; i < lvts_data->num_tc; i++) {
+		if ((irq_bitmap[tc[i].domain_index] & tc[i].irq_bit) == 0)
+			tc_irq_handler(lvts_data, i);
+	}
+
+	kfree(irq_bitmap);
+
+	return IRQ_HANDLED;
+}
+
+static int lvts_register_irq_handler(struct lvts_data *lvts_data)
+{
+	struct device *dev = lvts_data->dev;
+	unsigned int i;
+	int ret;
+
+	for (i = 0; i < lvts_data->num_domain; i++) {
+		ret = devm_request_irq(dev, lvts_data->domain[i].irq_num, irq_handler,
+				       IRQF_TRIGGER_HIGH, "mtk_lvts", lvts_data);
+
+		if (ret) {
+			dev_err(dev, "Failed to register LVTS IRQ, ret %d, domain %d irq_num %d\n",
+				ret, i, lvts_data->domain[i].irq_num);
+			lvts_close(lvts_data);
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
+static int lvts_register_thermal_zones(struct lvts_data *lvts_data)
+{
+	struct device *dev = lvts_data->dev;
+	struct thermal_zone_device *tzdev;
+	struct soc_temp_tz *lvts_tz;
+	int i, ret;
+
+	for (i = 0; i < lvts_data->num_sensor + 1; i++) {
+		lvts_tz = devm_kzalloc(dev, sizeof(*lvts_tz), GFP_KERNEL);
+		if (!lvts_tz) {
+			lvts_close(lvts_data);
+			return -ENOMEM;
+		}
+
+		lvts_tz->id = i;
+		lvts_tz->lvts_data = lvts_data;
+
+		tzdev = devm_thermal_zone_of_sensor_register(dev, lvts_tz->id,
+							     lvts_tz, &soc_temp_lvts_ops);
+
+		if (IS_ERR(tzdev)) {
+			if (lvts_tz->id != 0)
+				return 0;
+
+			ret = PTR_ERR(tzdev);
+			dev_err(dev, "Error: Failed to register lvts tz %d, ret = %d\n",
+				lvts_tz->id, ret);
+			lvts_close(lvts_data);
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
+static int lvts_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct lvts_data *lvts_data;
+	int ret;
+
+	lvts_data = (struct lvts_data *)of_device_get_match_data(dev);
+
+	if (!lvts_data)	{
+		dev_err(dev, "Error: Failed to get lvts platform data\n");
+		return -ENODATA;
+	}
+	lvts_data->dev = &pdev->dev;
+
+	ret = of_update_lvts_data(lvts_data, pdev);
+	if (ret)
+		return ret;
+
+	platform_set_drvdata(pdev, lvts_data);
+	ret = lvts_init(lvts_data);
+	if (ret)
+		return ret;
+
+	ret = lvts_register_irq_handler(lvts_data);
+	if (ret)
+		return ret;
+
+	ret = lvts_register_thermal_zones(lvts_data);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+static int lvts_remove(struct platform_device *pdev)
+{
+	struct lvts_data *lvts_data;
+
+	lvts_data = (struct lvts_data *)platform_get_drvdata(pdev);
+
+	lvts_close(lvts_data);
+
+	return 0;
+}
+
+static int lvts_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	struct lvts_data *lvts_data;
+
+	lvts_data = (struct lvts_data *)platform_get_drvdata(pdev);
+
+	lvts_close(lvts_data);
+
+	return 0;
+}
+
+static int lvts_resume(struct platform_device *pdev)
+{
+	int ret;
+	struct lvts_data *lvts_data;
+
+	lvts_data = (struct lvts_data *)platform_get_drvdata(pdev);
+
+	ret = lvts_init(lvts_data);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+/*==================================================
+ * LVTS v4 common code
+ *==================================================
+ */
+static void device_enable_and_init_v4(struct lvts_data *lvts_data)
+{
+	unsigned int i;
+
+	for (i = 0; i < lvts_data->num_tc; i++) {
+		lvts_write_device(lvts_data, STOP_COUNTING_V4, i);
+		lvts_write_device(lvts_data, SET_RG_TSFM_LPDLY_V4, i);
+		lvts_write_device(lvts_data, SET_COUNTING_WINDOW_20US1_V4, i);
+		lvts_write_device(lvts_data, SET_COUNTING_WINDOW_20US2_V4, i);
+		lvts_write_device(lvts_data, TSV2F_CHOP_CKSEL_AND_TSV2F_EN_V4, i);
+		lvts_write_device(lvts_data, TSBG_DEM_CKSEL_X_TSBG_CHOP_EN_V4, i);
+		lvts_write_device(lvts_data, SET_TS_RSV_V4, i);
+		lvts_write_device(lvts_data, SET_TS_EN_V4, i);
+		lvts_write_device(lvts_data, TOGGLE_RG_TSV2F_VCO_RST1_V4, i);
+		lvts_write_device(lvts_data, TOGGLE_RG_TSV2F_VCO_RST2_V4, i);
+	}
+
+	lvts_data->counting_window_us = 20;
+}
+
+static void device_enable_auto_rck_v4(struct lvts_data *lvts_data)
+{
+	unsigned int i;
+
+	for (i = 0; i < lvts_data->num_tc; i++)
+		lvts_write_device(lvts_data, SET_LVTS_AUTO_RCK_V4, i);
+}
+
+static int device_read_count_rc_n_v4(struct lvts_data *lvts_data)
+{
+	/* Resistor-Capacitor Calibration */
+	/* count_RC_N: count RC now */
+	struct device *dev = lvts_data->dev;
+	struct tc_settings *tc = lvts_data->tc;
+	struct sensor_cal_data *cal_data = &lvts_data->cal_data;
+	unsigned int offset, size, s_index, data;
+	void __iomem *base;
+	int ret, i, j;
+	char buffer[512];
+
+	cal_data->count_rc_now = devm_kcalloc(dev, lvts_data->num_sensor,
+					      sizeof(*cal_data->count_rc_now), GFP_KERNEL);
+	if (!cal_data->count_rc_now)
+		return -ENOMEM;
+
+	for (i = 0; i < lvts_data->num_tc; i++) {
+		base = GET_BASE_ADDR(i);
+		for (j = 0; j < tc[i].num_sensor; j++) {
+			s_index = tc[i].sensor_map[j];
+
+			lvts_write_device(lvts_data, SELECT_SENSOR_RCK_V4(j), i);
+			lvts_write_device(lvts_data, SET_DEVICE_SINGLE_MODE_V4, i);
+			usleep_range(10, 20);
+
+			lvts_write_device(lvts_data, KICK_OFF_RCK_COUNTING_V4, i);
+			usleep_range(30, 40);
+
+			ret = readl_poll_timeout(LVTS_CONFIG_0 + base, data,
+						 !(data & DEVICE_SENSING_STATUS), 2, 200);
+			if (ret)
+				dev_err(dev,
+					"Error: LVTS %d DEVICE_SENSING_STATUS didn't ready\n", i);
+
+			data = lvts_read_device(lvts_data, 0x00, i);
+
+			cal_data->count_rc_now[s_index] = (data & GENMASK(23, 0));
+		}
+
+		/* Recover Setting for Normal Access on
+		 * temperature fetch
+		 */
+		lvts_write_device(lvts_data, SET_SENSOR_NO_RCK_V4, i);
+		lvts_write_device(lvts_data, SET_DEVICE_LOW_POWER_SINGLE_MODE_V4, i);
+	}
+
+	size = sizeof(buffer);
+	offset = snprintf(buffer, size, "[COUNT_RC_NOW] ");
+	for (i = 0; i < lvts_data->num_sensor; i++)
+		offset += snprintf(buffer + offset, size - offset, "%d:%d ",
+				   i, cal_data->count_rc_now[i]);
+
+	buffer[offset] = '\0';
+	dev_info(dev, "%s\n", buffer);
+
+	return 0;
+}
+
+static void set_calibration_data_v4(struct lvts_data *lvts_data)
+{
+	struct tc_settings *tc = lvts_data->tc;
+	struct sensor_cal_data *cal_data = &lvts_data->cal_data;
+	unsigned int i, j, s_index, e_data;
+	void __iomem *base;
+
+	for (i = 0; i < lvts_data->num_tc; i++) {
+		base = GET_BASE_ADDR(i);
+
+		for (j = 0; j < tc[i].num_sensor; j++) {
+			s_index = tc[i].sensor_map[j];
+			if (IS_ENABLE(FEATURE_DEVICE_AUTO_RCK))
+				e_data = cal_data->count_r[s_index];
+			else
+				e_data = (((unsigned long long)
+					cal_data->count_rc_now[s_index]) *
+					cal_data->count_r[s_index]) >> 14;
+
+			writel(e_data, LVTSEDATA00_0 + base + 0x4 * j);
+		}
+	}
+}
+
+static void init_controller_v4(struct lvts_data *lvts_data)
+{
+	struct device *dev = lvts_data->dev;
+	unsigned int i;
+	void __iomem *base;
+
+	for (i = 0; i < lvts_data->num_tc; i++) {
+		base = GET_BASE_ADDR(i);
+
+		lvts_write_device(lvts_data, SET_DEVICE_LOW_POWER_SINGLE_MODE_V4, i);
+
+		writel(SET_SENSOR_INDEX, LVTSTSSEL_0 + base);
+		writel(SET_CALC_SCALE_RULES, LVTSCALSCALE_0 + base);
+
+		set_polling_speed(lvts_data, i);
+		set_hw_filter(lvts_data, i);
+
+		dev_info(dev, "lvts%d: read all %d sensors in %d us, one in %d us\n",
+			 i, GET_TC_SENSOR_NUM(i), GROUP_LATENCY_US(i), SENSOR_LATENCY_US(i));
+	}
+}
+
+/*==================================================
+ * LVTS MT6873
+ *==================================================
+ */
+
+#define MT6873_NUM_LVTS (ARRAY_SIZE(mt6873_tc_settings))
+
+enum mt6873_lvts_domain {
+	MT6873_AP_DOMAIN,
+	MT6873_MCU_DOMAIN,
+	MT6873_NUM_DOMAIN
+};
+
+enum mt6873_lvts_sensor_enum {
+	MT6873_TS1_0,
+	MT6873_TS1_1,
+	MT6873_TS2_0,
+	MT6873_TS2_1,
+	MT6873_TS3_0,
+	MT6873_TS3_1,
+	MT6873_TS3_2,
+	MT6873_TS3_3,
+	MT6873_TS4_0,
+	MT6873_TS4_1,
+	MT6873_TS5_0,
+	MT6873_TS5_1,
+	MT6873_TS6_0,
+	MT6873_TS6_1,
+	MT6873_TS7_0,
+	MT6873_TS7_1,
+	MT6873_TS7_2,
+	MT6873_NUM_TS
+};
+
+static void mt6873_efuse_to_cal_data(struct lvts_data *lvts_data)
+{
+	struct sensor_cal_data *cal_data = &lvts_data->cal_data;
+
+	cal_data->golden_temp = GET_CAL_DATA_BITMASK(0, 31, 24);
+	cal_data->count_r[MT6873_TS1_0] = GET_CAL_DATA_BITMASK(1, 23, 0);
+	cal_data->count_r[MT6873_TS1_1] = GET_CAL_DATA_BITMASK(2, 23, 0);
+	cal_data->count_r[MT6873_TS2_0] = GET_CAL_DATA_BITMASK(3, 23, 0);
+	cal_data->count_r[MT6873_TS2_1] = GET_CAL_DATA_BITMASK(4, 23, 0);
+	cal_data->count_r[MT6873_TS3_0] = GET_CAL_DATA_BITMASK(5, 23, 0);
+	cal_data->count_r[MT6873_TS3_1] = GET_CAL_DATA_BITMASK(6, 23, 0);
+	cal_data->count_r[MT6873_TS3_2] = GET_CAL_DATA_BITMASK(7, 23, 0);
+	cal_data->count_r[MT6873_TS3_3] = GET_CAL_DATA_BITMASK(8, 23, 0);
+	cal_data->count_r[MT6873_TS4_0] = GET_CAL_DATA_BITMASK(9, 23, 0);
+	cal_data->count_r[MT6873_TS4_1] = GET_CAL_DATA_BITMASK(10, 23, 0);
+	cal_data->count_r[MT6873_TS5_0] = GET_CAL_DATA_BITMASK(11, 23, 0);
+	cal_data->count_r[MT6873_TS5_1] = GET_CAL_DATA_BITMASK(12, 23, 0);
+	cal_data->count_r[MT6873_TS6_0] = GET_CAL_DATA_BITMASK(13, 23, 0);
+	cal_data->count_r[MT6873_TS6_1] = GET_CAL_DATA_BITMASK(14, 23, 0);
+	cal_data->count_r[MT6873_TS7_0] = GET_CAL_DATA_BITMASK(15, 23, 0);
+	cal_data->count_r[MT6873_TS7_1] = GET_CAL_DATA_BITMASK(16, 23, 0);
+	cal_data->count_r[MT6873_TS7_2] = GET_CAL_DATA_BITMASK(17, 23, 0);
+
+	cal_data->count_rc[MT6873_TS1_0] = GET_CAL_DATA_BITMASK(21, 23, 0);
+
+	cal_data->count_rc[MT6873_TS2_0] = (GET_CAL_DATA_BITMASK(1, 31, 24) << 16) +
+					   (GET_CAL_DATA_BITMASK(2, 31, 24) << 8) +
+					    GET_CAL_DATA_BITMASK(3, 31, 24);
+
+	cal_data->count_rc[MT6873_TS3_0] = (GET_CAL_DATA_BITMASK(4, 31, 24) << 16) +
+					   (GET_CAL_DATA_BITMASK(5, 31, 24) << 8) +
+					    GET_CAL_DATA_BITMASK(6, 31, 24);
+
+	cal_data->count_rc[MT6873_TS4_0] = (GET_CAL_DATA_BITMASK(7, 31, 24) << 16) +
+					   (GET_CAL_DATA_BITMASK(8, 31, 24) << 8) +
+					    GET_CAL_DATA_BITMASK(9, 31, 24);
+
+	cal_data->count_rc[MT6873_TS5_0] = (GET_CAL_DATA_BITMASK(10, 31, 24) << 16) +
+					   (GET_CAL_DATA_BITMASK(11, 31, 24) << 8) +
+					    GET_CAL_DATA_BITMASK(12, 31, 24);
+
+	cal_data->count_rc[MT6873_TS6_0] = (GET_CAL_DATA_BITMASK(13, 31, 24) << 16) +
+					   (GET_CAL_DATA_BITMASK(14, 31, 24) << 8) +
+					    GET_CAL_DATA_BITMASK(15, 31, 24);
+
+	cal_data->count_rc[MT6873_TS7_0] = (GET_CAL_DATA_BITMASK(16, 31, 24) << 16) +
+					   (GET_CAL_DATA_BITMASK(17, 31, 24) << 8) +
+					    GET_CAL_DATA_BITMASK(18, 31, 24);
+}
+
+static struct tc_settings mt6873_tc_settings[] = {
+	[0] = {
+		.domain_index = MT6873_MCU_DOMAIN,
+		.addr_offset = 0x0,
+		.num_sensor = 2,
+		.sensor_map = {MT6873_TS1_0, MT6873_TS1_1},
+		.tc_speed = SET_TC_SPEED_IN_US(118, 118, 118, 118),
+		.hw_filter = LVTS_FILTER_2_OF_4,
+		.dominator_sensing_point = SENSING_POINT1,
+		.hw_reboot_trip_point = 117000,
+		.irq_bit = BIT(3),
+	},
+	[1] = {
+		.domain_index = MT6873_MCU_DOMAIN,
+		.addr_offset = 0x100,
+		.num_sensor = 2,
+		.sensor_map = {MT6873_TS2_0, MT6873_TS2_1},
+		.tc_speed = SET_TC_SPEED_IN_US(118, 118, 118, 118),
+		.hw_filter = LVTS_FILTER_2_OF_4,
+		.dominator_sensing_point = SENSING_POINT0,
+		.hw_reboot_trip_point = 117000,
+		.irq_bit = BIT(4),
+	},
+	[2] = {
+		.domain_index = MT6873_MCU_DOMAIN,
+		.addr_offset = 0x200,
+		.num_sensor = 4,
+		.sensor_map = {MT6873_TS3_0, MT6873_TS3_1, MT6873_TS3_2, MT6873_TS3_3},
+		.tc_speed = SET_TC_SPEED_IN_US(118, 118, 118, 118),
+		.hw_filter = LVTS_FILTER_2_OF_4,
+		.dominator_sensing_point = SENSING_POINT0,
+		.hw_reboot_trip_point = 117000,
+		.irq_bit = BIT(5),
+	},
+	[3] = {
+		.domain_index = MT6873_AP_DOMAIN,
+		.addr_offset = 0x0,
+		.num_sensor = 2,
+		.sensor_map = {MT6873_TS4_0, MT6873_TS4_1},
+		.tc_speed = SET_TC_SPEED_IN_US(118, 118, 118, 118),
+		.hw_filter = LVTS_FILTER_2_OF_4,
+		.dominator_sensing_point = SENSING_POINT0,
+		.hw_reboot_trip_point = 117000,
+		.irq_bit = BIT(3),
+	},
+	[4] = {
+		.domain_index = MT6873_AP_DOMAIN,
+		.addr_offset = 0x100,
+		.num_sensor = 2,
+		.sensor_map = {MT6873_TS5_0, MT6873_TS5_1},
+		.tc_speed = SET_TC_SPEED_IN_US(118, 118, 118, 118),
+		.hw_filter = LVTS_FILTER_2_OF_4,
+		.dominator_sensing_point = SENSING_POINT1,
+		.hw_reboot_trip_point = 117000,
+		.irq_bit = BIT(4),
+	},
+	[5] = {
+		.domain_index = MT6873_AP_DOMAIN,
+		.addr_offset = 0x200,
+		.num_sensor = 2,
+		.sensor_map = {MT6873_TS6_0, MT6873_TS6_1},
+		.tc_speed = SET_TC_SPEED_IN_US(118, 118, 118, 118),
+		.hw_filter = LVTS_FILTER_2_OF_4,
+		.dominator_sensing_point = SENSING_POINT1,
+		.hw_reboot_trip_point = 117000,
+		.irq_bit = BIT(5),
+	},
+	[6] = {
+		.domain_index = MT6873_AP_DOMAIN,
+		.addr_offset = 0x300,
+		.num_sensor = 3,
+		.sensor_map = {MT6873_TS7_0, MT6873_TS7_1, MT6873_TS7_2},
+		.tc_speed = SET_TC_SPEED_IN_US(118, 118, 118, 118),
+		.hw_filter = LVTS_FILTER_2_OF_4,
+		.dominator_sensing_point = SENSING_POINT2,
+		.hw_reboot_trip_point = 117000,
+		.irq_bit = BIT(6),
+	}
+};
+
+static struct lvts_data mt6873_lvts_data = {
+	.num_domain = MT6873_NUM_DOMAIN,
+	.num_tc = MT6873_NUM_LVTS,
+	.tc = mt6873_tc_settings,
+	.num_sensor = MT6873_NUM_TS,
+	.ops = {
+		.efuse_to_cal_data = mt6873_efuse_to_cal_data,
+		.device_enable_and_init = device_enable_and_init_v4,
+		.device_enable_auto_rck = device_enable_auto_rck_v4,
+		.device_read_count_rc_n = device_read_count_rc_n_v4,
+		.set_cal_data = set_calibration_data_v4,
+		.init_controller = init_controller_v4,
+	},
+	.feature_bitmap = FEATURE_DEVICE_AUTO_RCK,
+	.num_efuse_addr = 22,
+	.num_efuse_block = 1,
+	.cal_data = {
+		.default_golden_temp = 50,
+		.default_count_r = 35000,
+		.default_count_rc = 2750,
+	},
+	.coeff = {
+		.a = -250460,
+		.b = 250460,
+	},
+};
+
+/*==================================================
+ * LVTS MT8195
+ *==================================================
+ */
+
+#define MT8195_NUM_LVTS (ARRAY_SIZE(mt8195_tc_settings))
+
+enum mt8195_lvts_domain {
+	MT8195_AP_DOMAIN,
+	MT8195_MCU_DOMAIN,
+	MT8195_NUM_DOMAIN
+};
+
+enum mt8195_lvts_sensor_enum {
+	MT8195_TS1_0,
+	MT8195_TS1_1,
+	MT8195_TS2_0,
+	MT8195_TS2_1,
+	MT8195_TS3_0,
+	MT8195_TS3_1,
+	MT8195_TS3_2,
+	MT8195_TS3_3,
+	MT8195_TS4_0,
+	MT8195_TS4_1,
+	MT8195_TS5_0,
+	MT8195_TS5_1,
+	MT8195_TS6_0,
+	MT8195_TS6_1,
+	MT8195_TS6_2,
+	MT8195_TS7_0,
+	MT8195_TS7_1,
+	MT8195_NUM_TS
+};
+
+static void mt8195_efuse_to_cal_data(struct lvts_data *lvts_data)
+{
+	struct sensor_cal_data *cal_data = &lvts_data->cal_data;
+
+	cal_data->golden_temp = GET_CAL_DATA_BITMASK(0, 31, 24);
+	cal_data->count_r[MT8195_TS1_0] = GET_CAL_DATA_BITMASK(1, 23, 0);
+	cal_data->count_r[MT8195_TS1_1] = (GET_CAL_DATA_BITMASK(2, 15, 0) << 8) +
+					   GET_CAL_DATA_BITMASK(1, 31, 24);
+	cal_data->count_r[MT8195_TS2_0] = GET_CAL_DATA_BITMASK(3, 31, 8);
+	cal_data->count_r[MT8195_TS2_1] = GET_CAL_DATA_BITMASK(4, 23, 0);
+	cal_data->count_r[MT8195_TS3_0] = (GET_CAL_DATA_BITMASK(6, 7, 0) << 16) +
+					   GET_CAL_DATA_BITMASK(5, 31, 16);
+	cal_data->count_r[MT8195_TS3_1] = GET_CAL_DATA_BITMASK(6, 31, 8);
+	cal_data->count_r[MT8195_TS3_2] = GET_CAL_DATA_BITMASK(7, 23, 0);
+	cal_data->count_r[MT8195_TS3_3] = (GET_CAL_DATA_BITMASK(8, 15, 0) << 8) +
+					   GET_CAL_DATA_BITMASK(7, 31, 24);
+	cal_data->count_r[MT8195_TS4_0] = GET_CAL_DATA_BITMASK(9, 31, 8);
+	cal_data->count_r[MT8195_TS4_1] = GET_CAL_DATA_BITMASK(10, 23, 0);
+	cal_data->count_r[MT8195_TS5_0] = (GET_CAL_DATA_BITMASK(12, 7, 0) << 16) +
+					   GET_CAL_DATA_BITMASK(11, 31, 16);
+	cal_data->count_r[MT8195_TS5_1] = GET_CAL_DATA_BITMASK(12, 31, 8);
+	cal_data->count_r[MT8195_TS6_0] = (GET_CAL_DATA_BITMASK(14, 15, 0) << 8) +
+					   GET_CAL_DATA_BITMASK(13, 31, 24);
+	cal_data->count_r[MT8195_TS6_1] = (GET_CAL_DATA_BITMASK(15, 7, 0) << 16) +
+					   GET_CAL_DATA_BITMASK(14, 31, 16);
+	cal_data->count_r[MT8195_TS6_2] = GET_CAL_DATA_BITMASK(15, 31, 8);
+	cal_data->count_r[MT8195_TS7_0] = (GET_CAL_DATA_BITMASK(17, 15, 0) << 8) +
+					   GET_CAL_DATA_BITMASK(16, 31, 24);
+	cal_data->count_r[MT8195_TS7_1] = (GET_CAL_DATA_BITMASK(18, 7, 0) << 16) +
+					   GET_CAL_DATA_BITMASK(17, 31, 16);
+	cal_data->count_rc[MT8195_TS1_0] = (GET_CAL_DATA_BITMASK(3, 7, 0) << 16) +
+					    GET_CAL_DATA_BITMASK(2, 31, 16);
+	cal_data->count_rc[MT8195_TS2_0] = (GET_CAL_DATA_BITMASK(5, 15, 0) << 8) +
+					    GET_CAL_DATA_BITMASK(4, 31, 24);
+	cal_data->count_rc[MT8195_TS3_0] = (GET_CAL_DATA_BITMASK(9, 7, 0) << 16) +
+					    GET_CAL_DATA_BITMASK(8, 31, 16);
+	cal_data->count_rc[MT8195_TS4_0] = (GET_CAL_DATA_BITMASK(11, 15, 0) << 8) +
+					    GET_CAL_DATA_BITMASK(10, 31, 24);
+	cal_data->count_rc[MT8195_TS5_0] = GET_CAL_DATA_BITMASK(13, 23, 0);
+	cal_data->count_rc[MT8195_TS6_0] = GET_CAL_DATA_BITMASK(16, 23, 0);
+	cal_data->count_rc[MT8195_TS7_0] = GET_CAL_DATA_BITMASK(18, 31, 8);
+}
+
+static struct tc_settings mt8195_tc_settings[] = {
+	[0] = {
+		.domain_index = MT8195_MCU_DOMAIN,
+		.addr_offset = 0x0,
+		.num_sensor = 2,
+		.sensor_map = {MT8195_TS1_0, MT8195_TS1_1},
+		.tc_speed = SET_TC_SPEED_IN_US(118, 118, 118, 118),
+		.hw_filter = LVTS_FILTER_2_OF_4,
+		.dominator_sensing_point = SENSING_POINT1,
+		.hw_reboot_trip_point = 117000,
+		.irq_bit = BIT(3),
+	},
+	[1] = {
+		.domain_index = MT8195_MCU_DOMAIN,
+		.addr_offset = 0x100,
+		.num_sensor = 2,
+		.sensor_map = {MT8195_TS2_0, MT8195_TS2_1},
+		.tc_speed = SET_TC_SPEED_IN_US(118, 118, 118, 118),
+		.hw_filter = LVTS_FILTER_2_OF_4,
+		.dominator_sensing_point = SENSING_POINT0,
+		.hw_reboot_trip_point = 117000,
+		.irq_bit = BIT(4),
+	},
+	[2] = {
+		.domain_index = MT8195_MCU_DOMAIN,
+		.addr_offset = 0x200,
+		.num_sensor = 4,
+		.sensor_map = {MT8195_TS3_0, MT8195_TS3_1, MT8195_TS3_2, MT8195_TS3_3},
+		.tc_speed = SET_TC_SPEED_IN_US(118, 118, 118, 118),
+		.hw_filter = LVTS_FILTER_2_OF_4,
+		.dominator_sensing_point = SENSING_POINT0,
+		.hw_reboot_trip_point = 117000,
+		.irq_bit = BIT(5),
+	},
+	[3] = {
+		.domain_index = MT8195_AP_DOMAIN,
+		.addr_offset = 0x0,
+		.num_sensor = 2,
+		.sensor_map = {MT8195_TS4_0, MT8195_TS4_1},
+		.tc_speed = SET_TC_SPEED_IN_US(118, 118, 118, 118),
+		.hw_filter = LVTS_FILTER_2_OF_4,
+		.dominator_sensing_point = SENSING_POINT0,
+		.hw_reboot_trip_point = 117000,
+		.irq_bit = BIT(3),
+	},
+	[4] = {
+		.domain_index = MT8195_AP_DOMAIN,
+		.addr_offset = 0x100,
+		.num_sensor = 2,
+		.sensor_map = {MT8195_TS5_0, MT8195_TS5_1},
+		.tc_speed = SET_TC_SPEED_IN_US(118, 118, 118, 118),
+		.hw_filter = LVTS_FILTER_2_OF_4,
+		.dominator_sensing_point = SENSING_POINT1,
+		.hw_reboot_trip_point = 117000,
+		.irq_bit = BIT(4),
+	},
+	[5] = {
+		.domain_index = MT8195_AP_DOMAIN,
+		.addr_offset = 0x200,
+		.num_sensor = 3,
+		.sensor_map = {MT8195_TS6_0, MT8195_TS6_1, MT8195_TS6_2},
+		.tc_speed = SET_TC_SPEED_IN_US(118, 118, 118, 118),
+		.hw_filter = LVTS_FILTER_2_OF_4,
+		.dominator_sensing_point = SENSING_POINT1,
+		.hw_reboot_trip_point = 117000,
+		.irq_bit = BIT(5),
+	},
+	[6] = {
+		.domain_index = MT8195_AP_DOMAIN,
+		.addr_offset = 0x300,
+		.num_sensor = 2,
+		.sensor_map = {MT8195_TS7_0, MT8195_TS7_1},
+		.tc_speed = SET_TC_SPEED_IN_US(118, 118, 118, 118),
+		.hw_filter = LVTS_FILTER_2_OF_4,
+		.dominator_sensing_point = SENSING_POINT0,
+		.hw_reboot_trip_point = 117000,
+		.irq_bit = BIT(6),
+	}
+};
+
+static struct lvts_data mt8195_lvts_data = {
+	.num_domain = MT8195_NUM_DOMAIN,
+	.num_tc = MT8195_NUM_LVTS,
+	.tc = mt8195_tc_settings,
+	.num_sensor = MT8195_NUM_TS,
+	.ops = {
+		.efuse_to_cal_data = mt8195_efuse_to_cal_data,
+		.device_enable_and_init = device_enable_and_init_v4,
+		.device_enable_auto_rck = device_enable_auto_rck_v4,
+		.device_read_count_rc_n = device_read_count_rc_n_v4,
+		.set_cal_data = set_calibration_data_v4,
+		.init_controller = init_controller_v4,
+	},
+	.feature_bitmap = FEATURE_DEVICE_AUTO_RCK,
+	.num_efuse_addr = 22,
+	.num_efuse_block = 2,
+	.cal_data = {
+		.default_golden_temp = 50,
+		.default_count_r = 35000,
+		.default_count_rc = 2750,
+	},
+	.coeff = {
+		.a = -250460,
+		.b = 250460,
+	},
+};
+
+/*==================================================
+ *==================================================
+ * Support chips
+ *==================================================
+ */
+static const struct of_device_id lvts_of_match[] = {
+	{
+		.compatible = "mediatek,mt6873-lvts",
+		.data = (void *)&mt6873_lvts_data,
+	},
+	{
+		.compatible = "mediatek,mt8195-lvts",
+		.data = (void *)&mt8195_lvts_data,
+	},
+	{
+	},
+};
+MODULE_DEVICE_TABLE(of, lvts_of_match);
+/*==================================================*/
+static struct platform_driver soc_temp_lvts = {
+	.probe = lvts_probe,
+	.remove = lvts_remove,
+	.suspend = lvts_suspend,
+	.resume = lvts_resume,
+	.driver = {
+		.name = "mtk-soc-temp-lvts",
+		.of_match_table = lvts_of_match,
+	},
+};
+
+module_platform_driver(soc_temp_lvts);
+MODULE_AUTHOR("Yu-Chia Chang <ethan.chang@mediatek.com>");
+MODULE_AUTHOR("Michael Kao <michael.kao@mediatek.com>");
+MODULE_DESCRIPTION("Mediatek soc temperature driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/thermal/mediatek/soc_temp_lvts.h b/drivers/thermal/mediatek/soc_temp_lvts.h
new file mode 100644
index 0000000000000000000000000000000000000000..1d90bdec53c6f1cd664fd5fcfe5cc4613bc2fed5
--- /dev/null
+++ b/drivers/thermal/mediatek/soc_temp_lvts.h
@@ -0,0 +1,312 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2020 MediaTek Inc.
+ */
+
+#ifndef __MTK_SOC_TEMP_LVTS_H__
+#define __MTK_SOC_TEMP_LVTS_H__
+
+/* LVTS HW filter settings
+ * 000: Get one sample
+ * 001: Get 2 samples and average them
+ * 010: Get 4 samples, drop max and min, then average the rest of 2 samples
+ * 011: Get 6 samples, drop max and min, then average the rest of 4 samples
+ * 100: Get 10 samples, drop max and min, then average the rest of 8 samples
+ * 101: Get 18 samples, drop max and min, then average the rest of 16 samples
+ */
+enum lvts_hw_filter {
+	LVTS_FILTER_1,
+	LVTS_FILTER_2,
+	LVTS_FILTER_2_OF_4,
+	LVTS_FILTER_4_OF_6,
+	LVTS_FILTER_8_OF_10,
+	LVTS_FILTER_16_OF_18
+};
+
+enum lvts_sensing_point {
+	SENSING_POINT0,
+	SENSING_POINT1,
+	SENSING_POINT2,
+	SENSING_POINT3,
+	ALL_SENSING_POINTS
+};
+
+/*==================================================
+ * Data structure
+ *==================================================
+ */
+struct lvts_data;
+
+struct speed_settings {
+	unsigned int period_unit;
+	unsigned int group_interval_delay;
+	unsigned int filter_interval_delay;
+	unsigned int sensor_interval_delay;
+};
+
+struct tc_settings {
+	unsigned int domain_index;
+	unsigned int addr_offset;
+	unsigned int num_sensor;
+	unsigned int sensor_map[ALL_SENSING_POINTS]; /* In sensor ID */
+	struct speed_settings tc_speed;
+	/* HW filter setting
+	 * 000: Get one sample
+	 * 001: Get 2 samples and average them
+	 * 010: Get 4 samples, drop max and min, then average the rest of 2 samples
+	 * 011: Get 6 samples, drop max and min, then average the rest of 4 samples
+	 * 100: Get 10 samples, drop max and min, then average the rest of 8 samples
+	 * 101: Get 18 samples, drop max and min, then average the rest of 16 samples
+	 */
+	unsigned int hw_filter;
+	/* Dominator_sensing point is used to select a sensing point
+	 * and reference its temperature to trigger Thermal HW Reboot
+	 * When it is ALL_SENSING_POINTS, it will select all sensing points
+	 */
+	int dominator_sensing_point;
+	int hw_reboot_trip_point; /* -274000: Disable HW reboot */
+	unsigned int irq_bit;
+};
+
+struct formula_coeff {
+	int a;
+	int b;
+	unsigned int golden_temp;
+};
+
+struct sensor_cal_data {
+	int use_fake_efuse;	/* 1: Use fake efuse, 0: Use real efuse */
+	unsigned int golden_temp;
+	unsigned int *count_r;
+	unsigned int *count_rc;
+	unsigned int *count_rc_now;
+
+	unsigned int default_golden_temp;
+	unsigned int default_count_r;
+	unsigned int default_count_rc;
+};
+
+struct platform_ops {
+	void (*efuse_to_cal_data)(struct lvts_data *lvts_data);
+	void (*device_enable_and_init)(struct lvts_data *lvts_data);
+	void (*device_enable_auto_rck)(struct lvts_data *lvts_data);
+	int (*device_read_count_rc_n)(struct lvts_data *lvts_data);
+	void (*set_cal_data)(struct lvts_data *lvts_data);
+	void (*init_controller)(struct lvts_data *lvts_data);
+};
+
+struct power_domain {
+	void __iomem *base;	/* LVTS base addresses */
+	unsigned int irq_num;	/* LVTS interrupt numbers */
+	struct reset_control *reset;
+};
+
+struct sensor_data {
+	int temp;		/* Current temperature */
+	unsigned int msr_raw;	/* MSR raw data from LVTS */
+};
+
+struct lvts_data {
+	struct device *dev;
+	struct clk *clk;
+	unsigned int num_domain;
+	struct power_domain *domain;
+
+	int num_tc;			/* Number of LVTS thermal controllers */
+	struct tc_settings *tc;
+	int counting_window_us;		/* LVTS device counting window */
+
+	int num_sensor;			/* Number of sensors in this platform */
+	struct sensor_data *sen_data;
+
+	struct platform_ops ops;
+	int feature_bitmap;		/* Show what features are enabled */
+
+	unsigned int num_efuse_addr;
+	unsigned int *efuse;
+	unsigned int num_efuse_block;	/* Number of contiguous efuse indexes */
+	struct sensor_cal_data cal_data;
+	struct formula_coeff coeff;
+};
+
+struct soc_temp_tz {
+	unsigned int id; /* if id is 0, get max temperature of all sensors */
+	struct lvts_data *lvts_data;
+};
+
+struct match_entry {
+	char	chip[32];
+	struct lvts_data *lvts_data;
+};
+
+struct lvts_match_data {
+	unsigned int hw_version;
+	struct match_entry *table;
+	void (*set_up_common_callbacks)(struct lvts_data *lvts_data);
+	struct list_head node;
+};
+
+struct lvts_id {
+	unsigned int hw_version;
+	char	chip[32];
+};
+
+/*==================================================
+ * LVTS device register
+ *==================================================
+ */
+#define RG_TSFM_DATA_0	0x00
+#define RG_TSFM_DATA_1	0x01
+#define RG_TSFM_DATA_2	0x02
+#define RG_TSFM_CTRL_0	0x03
+#define RG_TSFM_CTRL_1	0x04
+#define RG_TSFM_CTRL_2	0x05
+#define RG_TSFM_CTRL_3	0x06
+#define RG_TSFM_CTRL_4	0x07
+#define RG_TSV2F_CTRL_0	0x08
+#define RG_TSV2F_CTRL_1	0x09
+#define RG_TSV2F_CTRL_2	0x0A
+#define RG_TSV2F_CTRL_3	0x0B
+#define RG_TSV2F_CTRL_4	0x0C
+#define RG_TSV2F_CTRL_5	0x0D
+#define RG_TSV2F_CTRL_6	0x0E
+#define RG_TEMP_DATA_0	0x10
+#define RG_TEMP_DATA_1	0x11
+#define RG_TEMP_DATA_2	0x12
+#define RG_TEMP_DATA_3	0x13
+#define RG_RC_DATA_0	0x14
+#define RG_RC_DATA_1	0x15
+#define RG_RC_DATA_2	0x16
+#define RG_RC_DATA_3	0x17
+#define RG_DIV_DATA_0	0x18
+#define RG_DIV_DATA_1	0x19
+#define RG_DIV_DATA_2	0x1A
+#define RG_DIV_DATA_3	0x1B
+#define RG_TST_DATA_0	0x70
+#define RG_TST_DATA_1	0x71
+#define RG_TST_DATA_2	0x72
+#define RG_TST_CTRL	0x73
+#define RG_DBG_FQMTR	0xF0
+#define RG_DBG_LPSEQ	0xF1
+#define RG_DBG_STATE	0xF2
+#define RG_DBG_CHKSUM	0xF3
+#define RG_DID_LVTS	0xFC
+#define RG_DID_REV	0xFD
+#define RG_TSFM_RST	0xFF
+/*==================================================
+ * LVTS controller register
+ *==================================================
+ */
+#define LVTSMONCTL0_0	0x000
+#define LVTS_SINGLE_SENSE	BIT(9)
+#define ENABLE_SENSING_POINT(num)	(LVTS_SINGLE_SENSE | GENMASK(((num) - 1), 0))
+#define DISABLE_SENSING_POINT	(LVTS_SINGLE_SENSE | 0x0)
+#define LVTSMONCTL1_0	0x004
+#define LVTSMONCTL2_0	0x008
+#define LVTSMONINT_0	0x00C
+#define STAGE3_INT_EN	BIT(31)
+#define LVTSMONINTSTS_0	0x010
+#define LVTSMONIDET0_0	0x014
+#define LVTSMONIDET1_0	0x018
+#define LVTSMONIDET2_0	0x01C
+#define LVTSMONIDET3_0	0x020
+#define LVTSH2NTHRE_0	0x024
+#define LVTSHTHRE_0	0x028
+#define LVTSCTHRE_0	0x02C
+#define LVTSOFFSETH_0	0x030
+#define LVTSOFFSETL_0	0x034
+#define LVTSMSRCTL0_0	0x038
+#define LVTSMSRCTL1_0	0x03C
+#define LVTSTSSEL_0	0x040
+#define SET_SENSOR_INDEX	0x13121110
+#define LVTSDEVICETO_0	0x044
+#define LVTSCALSCALE_0	0x048
+#define SET_CALC_SCALE_RULES	0x00000300
+#define LVTS_ID_0	0x04C
+#define LVTS_CONFIG_0	0x050
+
+#define BROADCAST_ID_UPDATE	BIT(26)
+#define DEVICE_SENSING_STATUS	BIT(25)
+#define DEVICE_ACCESS_STARTUS	BIT(24)
+#define WRITE_ACCESS		BIT(16)
+#define DEVICE_WRITE		(BIT(31) | CK26M_ACTIVE | DEVICE_ACCESS_STARTUS \
+				| BIT(17) | WRITE_ACCESS)
+#define DEVICE_READ		(BIT(31) | CK26M_ACTIVE | DEVICE_ACCESS_STARTUS \
+				| 1 << 17)
+#define RESET_ALL_DEVICES	(DEVICE_WRITE | RG_TSFM_RST << 8 | 0xFF)
+#define READ_BACK_DEVICE_ID	(BIT(31) | CK26M_ACTIVE | BROADCAST_ID_UPDATE	\
+				| DEVICE_ACCESS_STARTUS | BIT(17)	\
+				| RG_DID_LVTS << 8)
+#define READ_DEVICE_REG(reg_idx)	(DEVICE_READ | (reg_idx) << 8 | 0x00)
+#define LVTSEDATA00_0	0x054
+#define LVTSEDATA01_0	0x058
+#define LVTSEDATA02_0	0x05C
+#define LVTSEDATA03_0	0x060
+#define LVTSMSR0_0	0x090
+#define MRS_RAW_MASK		GENMASK(15, 0)
+#define MRS_RAW_VALID_BIT	BIT(16)
+#define LVTSMSR1_0	0x094
+#define LVTSMSR2_0	0x098
+#define LVTSMSR3_0	0x09C
+#define LVTSIMMD0_0	0x0A0
+#define LVTSIMMD1_0	0x0A4
+#define LVTSIMMD2_0	0x0A8
+#define LVTSIMMD3_0	0x0AC
+#define LVTSRDATA0_0	0x0B0
+#define LVTSRDATA1_0	0x0B4
+#define LVTSRDATA2_0	0x0B8
+#define LVTSRDATA3_0	0x0BC
+#define LVTSPROTCTL_0	0x0C0
+#define PROTOFFSET	GENMASK(15, 0)
+#define LVTSPROTTA_0	0x0C4
+#define LVTSPROTTB_0	0x0C8
+#define LVTSPROTTC_0	0x0CC
+#define LVTSCLKEN_0	0x0E4
+#define ENABLE_LVTS_CTRL_CLK	(1)
+#define DISABLE_LVTS_CTRL_CLK	(0)
+#define LVTSDBGSEL_0	0x0E8
+#define LVTSDBGSIG_0	0x0EC
+#define LVTSSPARE0_0	0x0F0
+#define LVTSSPARE1_0	0x0F4
+#define LVTSSPARE2_0	0x0F8
+#define LVTSSPARE3_0	0x0FC
+
+#define THERMINTST	0xF04
+/*==================================================
+ * LVTS register mask
+ *==================================================
+ */
+#define THERMAL_COLD_INTERRUPT_0		0x00000001
+#define THERMAL_HOT_INTERRUPT_0			0x00000002
+#define THERMAL_LOW_OFFSET_INTERRUPT_0		0x00000004
+#define THERMAL_HIGH_OFFSET_INTERRUPT_0		0x00000008
+#define THERMAL_HOT2NORMAL_INTERRUPT_0		0x00000010
+#define THERMAL_COLD_INTERRUPT_1		0x00000020
+#define THERMAL_HOT_INTERRUPT_1			0x00000040
+#define THERMAL_LOW_OFFSET_INTERRUPT_1		0x00000080
+#define THERMAL_HIGH_OFFSET_INTERRUPT_1		0x00000100
+#define THERMAL_HOT2NORMAL_INTERRUPT_1		0x00000200
+#define THERMAL_COLD_INTERRUPT_2		0x00000400
+#define THERMAL_HOT_INTERRUPT_2			0x00000800
+#define THERMAL_LOW_OFFSET_INTERRUPT_2		0x00001000
+#define THERMAL_HIGH_OFFSET_INTERRUPT_2		0x00002000
+#define THERMAL_HOT2NORMAL_INTERRUPT_2		0x00004000
+#define THERMAL_AHB_TIMEOUT_INTERRUPT		0x00008000
+#define THERMAL_DEVICE_TIMEOUT_INTERRUPT	0x00008000
+#define THERMAL_IMMEDIATE_INTERRUPT_0		0x00010000
+#define THERMAL_IMMEDIATE_INTERRUPT_1		0x00020000
+#define THERMAL_IMMEDIATE_INTERRUPT_2		0x00040000
+#define THERMAL_FILTER_INTERRUPT_0		0x00080000
+#define THERMAL_FILTER_INTERRUPT_1		0x00100000
+#define THERMAL_FILTER_INTERRUPT_2		0x00200000
+#define THERMAL_COLD_INTERRUPT_3		0x00400000
+#define THERMAL_HOT_INTERRUPT_3			0x00800000
+#define THERMAL_LOW_OFFSET_INTERRUPT_3		0x01000000
+#define THERMAL_HIGH_OFFSET_INTERRUPT_3		0x02000000
+#define THERMAL_HOT2NORMAL_INTERRUPT_3		0x04000000
+#define THERMAL_IMMEDIATE_INTERRUPT_3		0x08000000
+#define THERMAL_FILTER_INTERRUPT_3		0x10000000
+#define THERMAL_PROTECTION_STAGE_1		0x20000000
+#define THERMAL_PROTECTION_STAGE_2		0x40000000
+#define THERMAL_PROTECTION_STAGE_3		0x80000000
+#endif /* __MTK_SOC_TEMP_LVTS_H__ */
diff --git a/drivers/usb/host/xhci-mtk.c b/drivers/usb/host/xhci-mtk.c
index c53f6f276d5c614461fb0422e3ab9f86fd0bb8e5..4e836b0c8d47cbdaa7dfb0690bf247008d8289ad 100644
--- a/drivers/usb/host/xhci-mtk.c
+++ b/drivers/usb/host/xhci-mtk.c
@@ -91,6 +91,13 @@
 #define WC0_IS_P	BIT(12)	/* polarity */
 #define WC0_IS_EN	BIT(6)
 
+/* mt8195 */
+#define PERI_WK_CTRL2	0x20
+#define WC1_IS_EN_P1	BIT(24)
+#define WC1_IS_EN_P3	BIT(26)
+#define WC2_IS_C(x)	((u32)(((x) & 0x7) << 27))  /* cycle debounce */
+#define WC2_IS_P	BIT(30)	/* polarity */
+
 /* mt8192 */
 #define WC0_SSUSB0_CDEN		BIT(6)
 #define WC0_IS_SPM_EN		BIT(1)
@@ -105,6 +112,10 @@ enum ssusb_uwk_vers {
 	SSUSB_UWK_V2,
 	SSUSB_UWK_V1_1 = 101,	/* specific revision 1.01 */
 	SSUSB_UWK_V1_2,		/* specific revision 1.2 */
+	SSUSB_UWK_V1_3,
+	SSUSB_UWK_V1_4,
+	SSUSB_UWK_V1_5,
+	SSUSB_UWK_V1_6,
 };
 
 /*
@@ -248,7 +259,9 @@ static int xhci_mtk_host_disable(struct xhci_hcd_mtk *mtk)
 	if (ret) {
 		dev_err(mtk->dev, "ip sleep failed!!!\n");
 		return ret;
-	}
+	} else
+		usleep_range(200, 250);
+
 	return 0;
 }
 
@@ -307,6 +320,25 @@ static void usb_wakeup_ip_sleep_set(struct xhci_hcd_mtk *mtk, bool enable)
 		msk = WC0_SSUSB0_CDEN | WC0_IS_SPM_EN;
 		val = enable ? msk : 0;
 		break;
+	case SSUSB_UWK_V1_3:
+		reg = mtk->uwk_reg_base + PERI_WK_CTRL2;
+		msk = WC0_IS_EN | WC0_IS_C(0xf) | WC0_IS_P;
+		val = enable ? (WC0_IS_EN | WC0_IS_C(0x8)) : 0;
+		break;
+	case SSUSB_UWK_V1_4:
+		reg = mtk->uwk_reg_base + PERI_WK_CTRL1;
+		msk = WC1_IS_EN_P1 | WC2_IS_C(0x7) | WC2_IS_P;
+		val = enable ? (WC1_IS_EN_P1 | WC2_IS_C(0x4)) : 0;
+		break;
+	case SSUSB_UWK_V1_5:
+		reg = mtk->uwk_reg_base + PERI_WK_CTRL1;
+		msk = WC1_IS_EN | WC2_IS_C(0x7) | WC2_IS_P;
+		val = enable ? (WC1_IS_EN | WC2_IS_C(0x4)) : 0;
+	case SSUSB_UWK_V1_6:
+		reg = mtk->uwk_reg_base + PERI_WK_CTRL1;
+		msk = WC1_IS_EN_P3 | WC2_IS_C(0x7) | WC2_IS_P;
+		val = enable ? (WC1_IS_EN_P3 | WC2_IS_C(0x4)) : 0;
+		break;
 	case SSUSB_UWK_V2:
 		reg = mtk->uwk_reg_base + PERI_SSUSB_SPM_CTRL;
 		msk = SSC_IP_SLEEP_EN | SSC_SPM_INT_EN;
diff --git a/drivers/watchdog/mtk_wdt.c b/drivers/watchdog/mtk_wdt.c
index 9bb7edbde11046f0f9d7322386567f25950750e9..73a406418747d2fb96655a60ba2dc0115222606a 100644
--- a/drivers/watchdog/mtk_wdt.c
+++ b/drivers/watchdog/mtk_wdt.c
@@ -22,6 +22,7 @@
 #include <linux/moduleparam.h>
 #include <linux/of.h>
 #include <linux/of_device.h>
+#include <linux/of_address.h>
 #include <linux/platform_device.h>
 #include <linux/reset-controller.h>
 #include <linux/types.h>
@@ -64,6 +65,7 @@ struct mtk_wdt_dev {
 	void __iomem *wdt_base;
 	spinlock_t lock; /* protects WDT_SWSYSRST reg */
 	struct reset_controller_dev rcdev;
+	bool disable_wdt_extrst;
 };
 
 struct mtk_wdt_data {
@@ -224,6 +226,7 @@ static int mtk_wdt_start(struct watchdog_device *wdt_dev)
 	u32 reg;
 	struct mtk_wdt_dev *mtk_wdt = watchdog_get_drvdata(wdt_dev);
 	void __iomem *wdt_base = mtk_wdt->wdt_base;
+
 	int ret;
 
 	ret = mtk_wdt_set_timeout(wdt_dev, wdt_dev->timeout);
@@ -232,9 +235,25 @@ static int mtk_wdt_start(struct watchdog_device *wdt_dev)
 
 	reg = ioread32(wdt_base + WDT_MODE);
 	reg &= ~(WDT_MODE_IRQ_EN | WDT_MODE_DUAL_EN);
+	if (mtk_wdt->disable_wdt_extrst)
+		reg &= ~WDT_MODE_EXRST_EN;
 	reg |= (WDT_MODE_EN | WDT_MODE_KEY);
 	iowrite32(reg, wdt_base + WDT_MODE);
 
+	{
+		struct device_node *drm_node;
+		void __iomem *drm_base;
+		drm_node = of_find_compatible_node(NULL, NULL, "mediatek,dbgtop");
+		drm_base = of_iomap(drm_node, 0);
+
+		 writel(0x95021e71, wdt_base + 0x44);
+		 //writel(0x9503ffff, wdt_base + 0x48);
+		 writel(0x22000001, wdt_base);
+		 writel(0x66000fff, wdt_base + 0x10);
+		 //writel(0x22000001, drm_base);
+		 writel(0x95027e71, drm_base + 0x40);
+	}
+
 	return 0;
 }
 
@@ -301,6 +320,10 @@ static int mtk_wdt_probe(struct platform_device *pdev)
 		if (err)
 			return err;
 	}
+
+	mtk_wdt->disable_wdt_extrst =
+		of_property_read_bool(dev->of_node, "disable_extrst");
+
 	return 0;
 }
 
diff --git a/include/dt-bindings/memory/mt8195-memory-port.h b/include/dt-bindings/memory/mt8195-memory-port.h
new file mode 100644
index 0000000000000000000000000000000000000000..9882877cda9d8687ee79d84158fce9d2dedfa2df
--- /dev/null
+++ b/include/dt-bindings/memory/mt8195-memory-port.h
@@ -0,0 +1,408 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (c) 2021 MediaTek Inc.
+ * Author: Yong Wu <yong.wu@mediatek.com>
+ */
+#ifndef _DT_BINDINGS_MEMORY_MT8195_LARB_PORT_H_
+#define _DT_BINDINGS_MEMORY_MT8195_LARB_PORT_H_
+
+#include <dt-bindings/memory/mtk-memory-port.h>
+
+/*
+ * MM IOMMU supports 16GB dma address. We separate it to four ranges:
+ * 0 ~ 4G; 4G ~ 8G; 8G ~ 12G; 12G ~ 16G. we could adjust these master
+ * locate an banks. BUT:
+ * a) Make sure all the ports inside a larb are in one range.
+ * b) The iova of any master can NOT cross the 4G/8G/12G boundary.
+ *
+ * This is the suggested mapping in this SoC:
+ *
+ * modules    dma-address-region	larbs-ports
+ * disp         0 ~ 4G                  larb0/1/2/3
+ * vcodec      4G ~ 8G                  larb19/20/21/22/23/24
+ * cam/mdp     8G ~ 12G                 the other larbs.
+ * N/A         12G ~ 16G
+ * CCU0   0x24000_0000 ~ 0x243ff_ffff   larb18: port 0/1
+ * CCU1   0x24400_0000 ~ 0x247ff_ffff   larb18: port 2/3
+ *
+ * This SoC have two IOMMU HWs, this is the detailed connected information:
+ * iommu-vdo: larb0/2/5/7/9/10/11/13/17/19/21/24/25/28
+ * iommu-vpp: larb1/3/4/6/8/12/14/16/18/20/22/23/26/27
+ */
+
+/* mm iommu ports */
+/* larb0 */
+#define M4U_PORT_L0_DISP_RDMA0			MTK_M4U_ID(0, 0)
+#define M4U_PORT_L0_DISP_WDMA0			MTK_M4U_ID(0, 1)
+#define M4U_PORT_L0_DISP_OVL0_RDMA0		MTK_M4U_ID(0, 2)
+#define M4U_PORT_L0_DISP_OVL0_RDMA1		MTK_M4U_ID(0, 3)
+#define M4U_PORT_L0_DISP_OVL0_HDR		MTK_M4U_ID(0, 4)
+#define M4U_PORT_L0_DISP_FAKE0			MTK_M4U_ID(0, 5)
+
+/* larb1 */
+#define M4U_PORT_L1_DISP_RDMA0			MTK_M4U_ID(1, 0)
+#define M4U_PORT_L1_DISP_WDMA0			MTK_M4U_ID(1, 1)
+#define M4U_PORT_L1_DISP_OVL0_RDMA0		MTK_M4U_ID(1, 2)
+#define M4U_PORT_L1_DISP_OVL0_RDMA1		MTK_M4U_ID(1, 3)
+#define M4U_PORT_L1_DISP_OVL0_HDR		MTK_M4U_ID(1, 4)
+#define M4U_PORT_L1_DISP_FAKE0			MTK_M4U_ID(1, 5)
+
+/* larb2 */
+#define M4U_PORT_L2_MDP_RDMA0			MTK_M4U_ID(2, 0)
+#define M4U_PORT_L2_MDP_RDMA2			MTK_M4U_ID(2, 1)
+#define M4U_PORT_L2_MDP_RDMA4			MTK_M4U_ID(2, 2)
+#define M4U_PORT_L2_MDP_RDMA6			MTK_M4U_ID(2, 3)
+#define M4U_PORT_L2_DISP_FAKE1			MTK_M4U_ID(2, 4)
+
+/* larb3 */
+#define M4U_PORT_L3_MDP_RDMA1			MTK_M4U_ID(3, 0)
+#define M4U_PORT_L3_MDP_RDMA3			MTK_M4U_ID(3, 1)
+#define M4U_PORT_L3_MDP_RDMA5			MTK_M4U_ID(3, 2)
+#define M4U_PORT_L3_MDP_RDMA7			MTK_M4U_ID(3, 3)
+#define M4U_PORT_L3_HDR_DS			MTK_M4U_ID(3, 4)
+#define M4U_PORT_L3_HDR_ADL			MTK_M4U_ID(3, 5)
+#define M4U_PORT_L3_DISP_FAKE1			MTK_M4U_ID(3, 6)
+
+/* larb4 */
+#define M4U_PORT_L4_MDP_RDMA			MTK_M4U_ID(4, 0)
+#define M4U_PORT_L4_MDP_FG			MTK_M4U_ID(4, 1)
+#define M4U_PORT_L4_MDP_OVL			MTK_M4U_ID(4, 2)
+#define M4U_PORT_L4_MDP_WROT			MTK_M4U_ID(4, 3)
+#define M4U_PORT_L4_FAKE			MTK_M4U_ID(4, 4)
+
+/* larb5 */
+#define M4U_PORT_L5_SVPP1_MDP_RDMA		MTK_M4U_ID(5, 0)
+#define M4U_PORT_L5_SVPP1_MDP_FG		MTK_M4U_ID(5, 1)
+#define M4U_PORT_L5_SVPP1_MDP_OVL		MTK_M4U_ID(5, 2)
+#define M4U_PORT_L5_SVPP1_MDP_WROT		MTK_M4U_ID(5, 3)
+#define M4U_PORT_L5_SVPP2_MDP_RDMA		MTK_M4U_ID(5, 4)
+#define M4U_PORT_L5_SVPP2_MDP_FG		MTK_M4U_ID(5, 5)
+#define M4U_PORT_L5_SVPP2_MDP_WROT		MTK_M4U_ID(5, 6)
+#define M4U_PORT_L5_FAKE			MTK_M4U_ID(5, 7)
+
+/* larb6 */
+#define M4U_PORT_L6_SVPP3_MDP_RDMA		MTK_M4U_ID(6, 0)
+#define M4U_PORT_L6_SVPP3_MDP_FG		MTK_M4U_ID(6, 1)
+#define M4U_PORT_L6_SVPP3_MDP_WROT		MTK_M4U_ID(6, 2)
+#define M4U_PORT_L6_FAKE			MTK_M4U_ID(6, 3)
+
+/* larb7 */
+#define M4U_PORT_L7_IMG_WPE_RDMA0		MTK_M4U_ID(7, 0)
+#define M4U_PORT_L7_IMG_WPE_RDMA1		MTK_M4U_ID(7, 1)
+#define M4U_PORT_L7_IMG_WPE_WDMA0		MTK_M4U_ID(7, 2)
+
+/* larb8 */
+#define M4U_PORT_L8_IMG_WPE_RDMA0		MTK_M4U_ID(8, 0)
+#define M4U_PORT_L8_IMG_WPE_RDMA1		MTK_M4U_ID(8, 1)
+#define M4U_PORT_L8_IMG_WPE_WDMA0		MTK_M4U_ID(8, 2)
+
+/* larb9 */
+#define M4U_PORT_L9_IMG_IMGI_T1_A		MTK_M4U_ID(9, 0)
+#define M4U_PORT_L9_IMG_IMGBI_T1_A		MTK_M4U_ID(9, 1)
+#define M4U_PORT_L9_IMG_IMGCI_T1_A		MTK_M4U_ID(9, 2)
+#define M4U_PORT_L9_IMG_SMTI_T1_A		MTK_M4U_ID(9, 3)
+#define M4U_PORT_L9_IMG_TNCSTI_T1_A		MTK_M4U_ID(9, 4)
+#define M4U_PORT_L9_IMG_TNCSTI_T4_A		MTK_M4U_ID(9, 5)
+#define M4U_PORT_L9_IMG_YUVO_T1_A		MTK_M4U_ID(9, 6)
+#define M4U_PORT_L9_IMG_TIMGO_T1_A		MTK_M4U_ID(9, 7)
+#define M4U_PORT_L9_IMG_YUVO_T2_A		MTK_M4U_ID(9, 8)
+#define M4U_PORT_L9_IMG_IMGI_T1_B		MTK_M4U_ID(9, 9)
+#define M4U_PORT_L9_IMG_IMGBI_T1_B		MTK_M4U_ID(9, 10)
+#define M4U_PORT_L9_IMG_IMGCI_T1_B		MTK_M4U_ID(9, 11)
+#define M4U_PORT_L9_IMG_YUVO_T5_A		MTK_M4U_ID(9, 12)
+#define M4U_PORT_L9_IMG_SMTI_T1_B		MTK_M4U_ID(9, 13)
+#define M4U_PORT_L9_IMG_TNCSO_T1_A		MTK_M4U_ID(9, 14)
+#define M4U_PORT_L9_IMG_SMTO_T1_A		MTK_M4U_ID(9, 15)
+#define M4U_PORT_L9_IMG_TNCSTO_T1_A		MTK_M4U_ID(9, 16)
+#define M4U_PORT_L9_IMG_YUVO_T2_B		MTK_M4U_ID(9, 17)
+#define M4U_PORT_L9_IMG_YUVO_T5_B		MTK_M4U_ID(9, 18)
+#define M4U_PORT_L9_IMG_SMTO_T1_B		MTK_M4U_ID(9, 19)
+
+/* larb10 */
+#define M4U_PORT_L10_IMG_IMGI_D1_A		MTK_M4U_ID(10, 0)
+#define M4U_PORT_L10_IMG_IMGCI_D1_A		MTK_M4U_ID(10, 1)
+#define M4U_PORT_L10_IMG_DEPI_D1_A		MTK_M4U_ID(10, 2)
+#define M4U_PORT_L10_IMG_DMGI_D1_A		MTK_M4U_ID(10, 3)
+#define M4U_PORT_L10_IMG_VIPI_D1_A		MTK_M4U_ID(10, 4)
+#define M4U_PORT_L10_IMG_TNRWI_D1_A		MTK_M4U_ID(10, 5)
+#define M4U_PORT_L10_IMG_RECI_D1_A		MTK_M4U_ID(10, 6)
+#define M4U_PORT_L10_IMG_SMTI_D1_A		MTK_M4U_ID(10, 7)
+#define M4U_PORT_L10_IMG_SMTI_D6_A		MTK_M4U_ID(10, 8)
+#define M4U_PORT_L10_IMG_PIMGI_P1_A		MTK_M4U_ID(10, 9)
+#define M4U_PORT_L10_IMG_PIMGBI_P1_A		MTK_M4U_ID(10, 10)
+#define M4U_PORT_L10_IMG_PIMGCI_P1_A		MTK_M4U_ID(10, 11)
+#define M4U_PORT_L10_IMG_PIMGI_P1_B		MTK_M4U_ID(10, 12)
+#define M4U_PORT_L10_IMG_PIMGBI_P1_B		MTK_M4U_ID(10, 13)
+#define M4U_PORT_L10_IMG_PIMGCI_P1_B		MTK_M4U_ID(10, 14)
+#define M4U_PORT_L10_IMG_IMG3O_D1_A		MTK_M4U_ID(10, 15)
+#define M4U_PORT_L10_IMG_IMG4O_D1_A		MTK_M4U_ID(10, 16)
+#define M4U_PORT_L10_IMG_IMG3CO_D1_A		MTK_M4U_ID(10, 17)
+#define M4U_PORT_L10_IMG_FEO_D1_A		MTK_M4U_ID(10, 18)
+#define M4U_PORT_L10_IMG_IMG2O_D1_A		MTK_M4U_ID(10, 19)
+#define M4U_PORT_L10_IMG_TNRWO_D1_A		MTK_M4U_ID(10, 20)
+#define M4U_PORT_L10_IMG_SMTO_D1_A		MTK_M4U_ID(10, 21)
+#define M4U_PORT_L10_IMG_WROT_P1_A		MTK_M4U_ID(10, 22)
+#define M4U_PORT_L10_IMG_WROT_P1_B		MTK_M4U_ID(10, 23)
+
+/* larb11 */
+#define M4U_PORT_L11_IMG_WPE_EIS_RDMA0_A	MTK_M4U_ID(11, 0)
+#define M4U_PORT_L11_IMG_WPE_EIS_RDMA1_A	MTK_M4U_ID(11, 1)
+#define M4U_PORT_L11_IMG_WPE_EIS_WDMA0_A	MTK_M4U_ID(11, 2)
+#define M4U_PORT_L11_IMG_WPE_TNR_RDMA0_A	MTK_M4U_ID(11, 3)
+#define M4U_PORT_L11_IMG_WPE_TNR_RDMA1_A	MTK_M4U_ID(11, 4)
+#define M4U_PORT_L11_IMG_WPE_TNR_WDMA0_A	MTK_M4U_ID(11, 5)
+#define M4U_PORT_L11_IMG_WPE_EIS_CQ0_A		MTK_M4U_ID(11, 6)
+#define M4U_PORT_L11_IMG_WPE_EIS_CQ1_A		MTK_M4U_ID(11, 7)
+#define M4U_PORT_L11_IMG_WPE_TNR_CQ0_A		MTK_M4U_ID(11, 8)
+#define M4U_PORT_L11_IMG_WPE_TNR_CQ1_A		MTK_M4U_ID(11, 9)
+
+/* larb12 */
+#define M4U_PORT_L12_IMG_FDVT_RDA		MTK_M4U_ID(12, 0)
+#define M4U_PORT_L12_IMG_FDVT_RDB		MTK_M4U_ID(12, 1)
+#define M4U_PORT_L12_IMG_FDVT_WRA		MTK_M4U_ID(12, 2)
+#define M4U_PORT_L12_IMG_FDVT_WRB		MTK_M4U_ID(12, 3)
+#define M4U_PORT_L12_IMG_ME_RDMA		MTK_M4U_ID(12, 4)
+#define M4U_PORT_L12_IMG_ME_WDMA		MTK_M4U_ID(12, 5)
+#define M4U_PORT_L12_IMG_DVS_RDMA		MTK_M4U_ID(12, 6)
+#define M4U_PORT_L12_IMG_DVS_WDMA		MTK_M4U_ID(12, 7)
+#define M4U_PORT_L12_IMG_DVP_RDMA		MTK_M4U_ID(12, 8)
+#define M4U_PORT_L12_IMG_DVP_WDMA		MTK_M4U_ID(12, 9)
+
+/* larb13 */
+#define M4U_PORT_L13_CAM_CAMSV_CQI_E1		MTK_M4U_ID(13, 0)
+#define M4U_PORT_L13_CAM_CAMSV_CQI_E2		MTK_M4U_ID(13, 1)
+#define M4U_PORT_L13_CAM_GCAMSV_A_IMGO_0	MTK_M4U_ID(13, 2)
+#define M4U_PORT_L13_CAM_SCAMSV_A_IMGO_0	MTK_M4U_ID(13, 3)
+#define M4U_PORT_L13_CAM_GCAMSV_B_IMGO_0	MTK_M4U_ID(13, 4)
+#define M4U_PORT_L13_CAM_GCAMSV_B_IMGO_1	MTK_M4U_ID(13, 5)
+#define M4U_PORT_L13_CAM_GCAMSV_A_UFEO_0	MTK_M4U_ID(13, 6)
+#define M4U_PORT_L13_CAM_GCAMSV_B_UFEO_0	MTK_M4U_ID(13, 7)
+#define M4U_PORT_L13_CAM_PDAI_0			MTK_M4U_ID(13, 8)
+#define M4U_PORT_L13_CAM_FAKE			MTK_M4U_ID(13, 9)
+
+/* larb14 */
+#define M4U_PORT_L14_CAM_GCAMSV_A_IMGO_1	MTK_M4U_ID(14, 0)
+#define M4U_PORT_L14_CAM_SCAMSV_A_IMGO_1	MTK_M4U_ID(14, 1)
+#define M4U_PORT_L14_CAM_GCAMSV_B_IMGO_0	MTK_M4U_ID(14, 2)
+#define M4U_PORT_L14_CAM_GCAMSV_B_IMGO_1	MTK_M4U_ID(14, 3)
+#define M4U_PORT_L14_CAM_SCAMSV_B_IMGO_0	MTK_M4U_ID(14, 4)
+#define M4U_PORT_L14_CAM_SCAMSV_B_IMGO_1	MTK_M4U_ID(14, 5)
+#define M4U_PORT_L14_CAM_IPUI			MTK_M4U_ID(14, 6)
+#define M4U_PORT_L14_CAM_IPU2I			MTK_M4U_ID(14, 7)
+#define M4U_PORT_L14_CAM_IPUO			MTK_M4U_ID(14, 8)
+#define M4U_PORT_L14_CAM_IPU2O			MTK_M4U_ID(14, 9)
+#define M4U_PORT_L14_CAM_IPU3O			MTK_M4U_ID(14, 10)
+#define M4U_PORT_L14_CAM_GCAMSV_A_UFEO_1	MTK_M4U_ID(14, 11)
+#define M4U_PORT_L14_CAM_GCAMSV_B_UFEO_1	MTK_M4U_ID(14, 12)
+#define M4U_PORT_L14_CAM_PDAI_1			MTK_M4U_ID(14, 13)
+#define M4U_PORT_L14_CAM_PDAO			MTK_M4U_ID(14, 14)
+
+/* larb15: null */
+
+/* larb16 */
+#define M4U_PORT_L16_CAM_IMGO_R1		MTK_M4U_ID(16, 0)
+#define M4U_PORT_L16_CAM_CQI_R1			MTK_M4U_ID(16, 1)
+#define M4U_PORT_L16_CAM_CQI_R2			MTK_M4U_ID(16, 2)
+#define M4U_PORT_L16_CAM_BPCI_R1		MTK_M4U_ID(16, 3)
+#define M4U_PORT_L16_CAM_LSCI_R1		MTK_M4U_ID(16, 4)
+#define M4U_PORT_L16_CAM_RAWI_R2		MTK_M4U_ID(16, 5)
+#define M4U_PORT_L16_CAM_RAWI_R3		MTK_M4U_ID(16, 6)
+#define M4U_PORT_L16_CAM_UFDI_R2		MTK_M4U_ID(16, 7)
+#define M4U_PORT_L16_CAM_UFDI_R3		MTK_M4U_ID(16, 8)
+#define M4U_PORT_L16_CAM_RAWI_R4		MTK_M4U_ID(16, 9)
+#define M4U_PORT_L16_CAM_RAWI_R5		MTK_M4U_ID(16, 10)
+#define M4U_PORT_L16_CAM_AAI_R1			MTK_M4U_ID(16, 11)
+#define M4U_PORT_L16_CAM_FHO_R1			MTK_M4U_ID(16, 12)
+#define M4U_PORT_L16_CAM_AAO_R1			MTK_M4U_ID(16, 13)
+#define M4U_PORT_L16_CAM_TSFSO_R1		MTK_M4U_ID(16, 14)
+#define M4U_PORT_L16_CAM_FLKO_R1		MTK_M4U_ID(16, 15)
+
+/* larb17 */
+#define M4U_PORT_L17_CAM_YUVO_R1		MTK_M4U_ID(17, 0)
+#define M4U_PORT_L17_CAM_YUVO_R3		MTK_M4U_ID(17, 1)
+#define M4U_PORT_L17_CAM_YUVCO_R1		MTK_M4U_ID(17, 2)
+#define M4U_PORT_L17_CAM_YUVO_R2		MTK_M4U_ID(17, 3)
+#define M4U_PORT_L17_CAM_RZH1N2TO_R1		MTK_M4U_ID(17, 4)
+#define M4U_PORT_L17_CAM_DRZS4NO_R1		MTK_M4U_ID(17, 5)
+#define M4U_PORT_L17_CAM_TNCSO_R1		MTK_M4U_ID(17, 6)
+
+/* larb18 */
+#define M4U_PORT_L18_CAM_CCUI			MTK_M4U_ID(18, 0)
+#define M4U_PORT_L18_CAM_CCUO			MTK_M4U_ID(18, 1)
+#define M4U_PORT_L18_CAM_CCUI2			MTK_M4U_ID(18, 2)
+#define M4U_PORT_L18_CAM_CCUO2			MTK_M4U_ID(18, 3)
+
+/* larb19 */
+#define M4U_PORT_L19_VENC_RCPU			MTK_M4U_ID(19, 0)
+#define M4U_PORT_L19_VENC_REC			MTK_M4U_ID(19, 1)
+#define M4U_PORT_L19_VENC_BSDMA			MTK_M4U_ID(19, 2)
+#define M4U_PORT_L19_VENC_SV_COMV		MTK_M4U_ID(19, 3)
+#define M4U_PORT_L19_VENC_RD_COMV		MTK_M4U_ID(19, 4)
+#define M4U_PORT_L19_VENC_NBM_RDMA		MTK_M4U_ID(19, 5)
+#define M4U_PORT_L19_VENC_NBM_RDMA_LITE		MTK_M4U_ID(19, 6)
+#define M4U_PORT_L19_JPGENC_Y_RDMA		MTK_M4U_ID(19, 7)
+#define M4U_PORT_L19_JPGENC_C_RDMA		MTK_M4U_ID(19, 8)
+#define M4U_PORT_L19_JPGENC_Q_TABLE		MTK_M4U_ID(19, 9)
+#define M4U_PORT_L19_VENC_SUB_W_LUMA		MTK_M4U_ID(19, 10)
+#define M4U_PORT_L19_VENC_FCS_NBM_RDMA		MTK_M4U_ID(19, 11)
+#define M4U_PORT_L19_JPGENC_BSDMA		MTK_M4U_ID(19, 12)
+#define M4U_PORT_L19_JPGDEC_WDMA0		MTK_M4U_ID(19, 13)
+#define M4U_PORT_L19_JPGDEC_BSDMA0		MTK_M4U_ID(19, 14)
+#define M4U_PORT_L19_VENC_NBM_WDMA		MTK_M4U_ID(19, 15)
+#define M4U_PORT_L19_VENC_NBM_WDMA_LITE		MTK_M4U_ID(19, 16)
+#define M4U_PORT_L19_VENC_FCS_NBM_WDMA		MTK_M4U_ID(19, 17)
+#define M4U_PORT_L19_JPGDEC_WDMA1		MTK_M4U_ID(19, 18)
+#define M4U_PORT_L19_JPGDEC_BSDMA1		MTK_M4U_ID(19, 19)
+#define M4U_PORT_L19_JPGDEC_BUFF_OFFSET1	MTK_M4U_ID(19, 20)
+#define M4U_PORT_L19_JPGDEC_BUFF_OFFSET0	MTK_M4U_ID(19, 21)
+#define M4U_PORT_L19_VENC_CUR_LUMA		MTK_M4U_ID(19, 22)
+#define M4U_PORT_L19_VENC_CUR_CHROMA		MTK_M4U_ID(19, 23)
+#define M4U_PORT_L19_VENC_REF_LUMA		MTK_M4U_ID(19, 24)
+#define M4U_PORT_L19_VENC_REF_CHROMA		MTK_M4U_ID(19, 25)
+#define M4U_PORT_L19_VENC_SUB_R_CHROMA		MTK_M4U_ID(19, 26)
+
+/* larb20 */
+#define M4U_PORT_L20_VENC_RCPU			MTK_M4U_ID(20, 0)
+#define M4U_PORT_L20_VENC_REC			MTK_M4U_ID(20, 1)
+#define M4U_PORT_L20_VENC_BSDMA			MTK_M4U_ID(20, 2)
+#define M4U_PORT_L20_VENC_SV_COMV		MTK_M4U_ID(20, 3)
+#define M4U_PORT_L20_VENC_RD_COMV		MTK_M4U_ID(20, 4)
+#define M4U_PORT_L20_VENC_NBM_RDMA		MTK_M4U_ID(20, 5)
+#define M4U_PORT_L20_VENC_NBM_RDMA_LITE		MTK_M4U_ID(20, 6)
+#define M4U_PORT_L20_JPGENC_Y_RDMA		MTK_M4U_ID(20, 7)
+#define M4U_PORT_L20_JPGENC_C_RDMA		MTK_M4U_ID(20, 8)
+#define M4U_PORT_L20_JPGENC_Q_TABLE		MTK_M4U_ID(20, 9)
+#define M4U_PORT_L20_VENC_SUB_W_LUMA		MTK_M4U_ID(20, 10)
+#define M4U_PORT_L20_VENC_FCS_NBM_RDMA		MTK_M4U_ID(20, 11)
+#define M4U_PORT_L20_JPGENC_BSDMA		MTK_M4U_ID(20, 12)
+#define M4U_PORT_L20_JPGDEC_WDMA0		MTK_M4U_ID(20, 13)
+#define M4U_PORT_L20_JPGDEC_BSDMA0		MTK_M4U_ID(20, 14)
+#define M4U_PORT_L20_VENC_NBM_WDMA		MTK_M4U_ID(20, 15)
+#define M4U_PORT_L20_VENC_NBM_WDMA_LITE		MTK_M4U_ID(20, 16)
+#define M4U_PORT_L20_VENC_FCS_NBM_WDMA		MTK_M4U_ID(20, 17)
+#define M4U_PORT_L20_JPGDEC_WDMA1		MTK_M4U_ID(20, 18)
+#define M4U_PORT_L20_JPGDEC_BSDMA1		MTK_M4U_ID(20, 19)
+#define M4U_PORT_L20_JPGDEC_BUFF_OFFSET1	MTK_M4U_ID(20, 20)
+#define M4U_PORT_L20_JPGDEC_BUFF_OFFSET0	MTK_M4U_ID(20, 21)
+#define M4U_PORT_L20_VENC_CUR_LUMA		MTK_M4U_ID(20, 22)
+#define M4U_PORT_L20_VENC_CUR_CHROMA		MTK_M4U_ID(20, 23)
+#define M4U_PORT_L20_VENC_REF_LUMA		MTK_M4U_ID(20, 24)
+#define M4U_PORT_L20_VENC_REF_CHROMA		MTK_M4U_ID(20, 25)
+#define M4U_PORT_L20_VENC_SUB_R_CHROMA		MTK_M4U_ID(20, 26)
+
+/* larb21 */
+#define M4U_PORT_L21_VDEC_MC_EXT		MTK_M4U_ID(21, 0)
+#define M4U_PORT_L21_VDEC_UFO_EXT		MTK_M4U_ID(21, 1)
+#define M4U_PORT_L21_VDEC_PP_EXT		MTK_M4U_ID(21, 2)
+#define M4U_PORT_L21_VDEC_PRED_RD_EXT		MTK_M4U_ID(21, 3)
+#define M4U_PORT_L21_VDEC_PRED_WR_EXT		MTK_M4U_ID(21, 4)
+#define M4U_PORT_L21_VDEC_PPWRAP_EXT		MTK_M4U_ID(21, 5)
+#define M4U_PORT_L21_VDEC_TILE_EXT		MTK_M4U_ID(21, 6)
+#define M4U_PORT_L21_VDEC_VLD_EXT		MTK_M4U_ID(21, 7)
+#define M4U_PORT_L21_VDEC_VLD2_EXT		MTK_M4U_ID(21, 8)
+#define M4U_PORT_L21_VDEC_AVC_MV_EXT		MTK_M4U_ID(21, 9)
+
+/* larb22 */
+#define M4U_PORT_L22_VDEC_MC_EXT		MTK_M4U_ID(22, 0)
+#define M4U_PORT_L22_VDEC_UFO_EXT		MTK_M4U_ID(22, 1)
+#define M4U_PORT_L22_VDEC_PP_EXT		MTK_M4U_ID(22, 2)
+#define M4U_PORT_L22_VDEC_PRED_RD_EXT		MTK_M4U_ID(22, 3)
+#define M4U_PORT_L22_VDEC_PRED_WR_EXT		MTK_M4U_ID(22, 4)
+#define M4U_PORT_L22_VDEC_PPWRAP_EXT		MTK_M4U_ID(22, 5)
+#define M4U_PORT_L22_VDEC_TILE_EXT		MTK_M4U_ID(22, 6)
+#define M4U_PORT_L22_VDEC_VLD_EXT		MTK_M4U_ID(22, 7)
+#define M4U_PORT_L22_VDEC_VLD2_EXT		MTK_M4U_ID(22, 8)
+#define M4U_PORT_L22_VDEC_AVC_MV_EXT		MTK_M4U_ID(22, 9)
+
+/* larb23 */
+#define M4U_PORT_L23_VDEC_UFO_ENC_EXT		MTK_M4U_ID(23, 0)
+#define M4U_PORT_L23_VDEC_RDMA_EXT		MTK_M4U_ID(23, 1)
+
+/* larb24 */
+#define M4U_PORT_L24_VDEC_LAT0_VLD_EXT		MTK_M4U_ID(24, 0)
+#define M4U_PORT_L24_VDEC_LAT0_VLD2_EXT		MTK_M4U_ID(24, 1)
+#define M4U_PORT_L24_VDEC_LAT0_AVC_MC_EXT	MTK_M4U_ID(24, 2)
+#define M4U_PORT_L24_VDEC_LAT0_PRED_RD_EXT	MTK_M4U_ID(24, 3)
+#define M4U_PORT_L24_VDEC_LAT0_TILE_EXT		MTK_M4U_ID(24, 4)
+#define M4U_PORT_L24_VDEC_LAT0_WDMA_EXT		MTK_M4U_ID(24, 5)
+#define M4U_PORT_L24_VDEC_LAT1_VLD_EXT		MTK_M4U_ID(24, 6)
+#define M4U_PORT_L24_VDEC_LAT1_VLD2_EXT		MTK_M4U_ID(24, 7)
+#define M4U_PORT_L24_VDEC_LAT1_AVC_MC_EXT	MTK_M4U_ID(24, 8)
+#define M4U_PORT_L24_VDEC_LAT1_PRED_RD_EXT	MTK_M4U_ID(24, 9)
+#define M4U_PORT_L24_VDEC_LAT1_TILE_EXT		MTK_M4U_ID(24, 10)
+#define M4U_PORT_L24_VDEC_LAT1_WDMA_EXT		MTK_M4U_ID(24, 11)
+
+/* larb25 */
+#define M4U_PORT_L25_CAM_MRAW0_LSCI_M1		MTK_M4U_ID(25, 0)
+#define M4U_PORT_L25_CAM_MRAW0_CQI_M1		MTK_M4U_ID(25, 1)
+#define M4U_PORT_L25_CAM_MRAW0_CQI_M2		MTK_M4U_ID(25, 2)
+#define M4U_PORT_L25_CAM_MRAW0_IMGO_M1		MTK_M4U_ID(25, 3)
+#define M4U_PORT_L25_CAM_MRAW0_IMGBO_M1		MTK_M4U_ID(25, 4)
+#define M4U_PORT_L25_CAM_MRAW2_LSCI_M1		MTK_M4U_ID(25, 5)
+#define M4U_PORT_L25_CAM_MRAW2_CQI_M1		MTK_M4U_ID(25, 6)
+#define M4U_PORT_L25_CAM_MRAW2_CQI_M2		MTK_M4U_ID(25, 7)
+#define M4U_PORT_L25_CAM_MRAW2_IMGO_M1		MTK_M4U_ID(25, 8)
+#define M4U_PORT_L25_CAM_MRAW2_IMGBO_M1		MTK_M4U_ID(25, 9)
+#define M4U_PORT_L25_CAM_MRAW0_AFO_M1		MTK_M4U_ID(25, 10)
+#define M4U_PORT_L25_CAM_MRAW2_AFO_M1		MTK_M4U_ID(25, 11)
+
+/* larb26 */
+#define M4U_PORT_L26_CAM_MRAW1_LSCI_M1		MTK_M4U_ID(26, 0)
+#define M4U_PORT_L26_CAM_MRAW1_CQI_M1		MTK_M4U_ID(26, 1)
+#define M4U_PORT_L26_CAM_MRAW1_CQI_M2		MTK_M4U_ID(26, 2)
+#define M4U_PORT_L26_CAM_MRAW1_IMGO_M1		MTK_M4U_ID(26, 3)
+#define M4U_PORT_L26_CAM_MRAW1_IMGBO_M1		MTK_M4U_ID(26, 4)
+#define M4U_PORT_L26_CAM_MRAW3_LSCI_M1		MTK_M4U_ID(26, 5)
+#define M4U_PORT_L26_CAM_MRAW3_CQI_M1		MTK_M4U_ID(26, 6)
+#define M4U_PORT_L26_CAM_MRAW3_CQI_M2		MTK_M4U_ID(26, 7)
+#define M4U_PORT_L26_CAM_MRAW3_IMGO_M1		MTK_M4U_ID(26, 8)
+#define M4U_PORT_L26_CAM_MRAW3_IMGBO_M1		MTK_M4U_ID(26, 9)
+#define M4U_PORT_L26_CAM_MRAW1_AFO_M1		MTK_M4U_ID(26, 10)
+#define M4U_PORT_L26_CAM_MRAW3_AFO_M1		MTK_M4U_ID(26, 11)
+
+/* larb27 */
+#define M4U_PORT_L27_CAM_IMGO_R1		MTK_M4U_ID(27, 0)
+#define M4U_PORT_L27_CAM_CQI_R1			MTK_M4U_ID(27, 1)
+#define M4U_PORT_L27_CAM_CQI_R2			MTK_M4U_ID(27, 2)
+#define M4U_PORT_L27_CAM_BPCI_R1		MTK_M4U_ID(27, 3)
+#define M4U_PORT_L27_CAM_LSCI_R1		MTK_M4U_ID(27, 4)
+#define M4U_PORT_L27_CAM_RAWI_R2		MTK_M4U_ID(27, 5)
+#define M4U_PORT_L27_CAM_RAWI_R3		MTK_M4U_ID(27, 6)
+#define M4U_PORT_L27_CAM_UFDI_R2		MTK_M4U_ID(27, 7)
+#define M4U_PORT_L27_CAM_UFDI_R3		MTK_M4U_ID(27, 8)
+#define M4U_PORT_L27_CAM_RAWI_R4		MTK_M4U_ID(27, 9)
+#define M4U_PORT_L27_CAM_RAWI_R5		MTK_M4U_ID(27, 10)
+#define M4U_PORT_L27_CAM_AAI_R1			MTK_M4U_ID(27, 11)
+#define M4U_PORT_L27_CAM_FHO_R1			MTK_M4U_ID(27, 12)
+#define M4U_PORT_L27_CAM_AAO_R1			MTK_M4U_ID(27, 13)
+#define M4U_PORT_L27_CAM_TSFSO_R1		MTK_M4U_ID(27, 14)
+#define M4U_PORT_L27_CAM_FLKO_R1		MTK_M4U_ID(27, 15)
+
+/* larb28 */
+#define M4U_PORT_L28_CAM_YUVO_R1		MTK_M4U_ID(28, 0)
+#define M4U_PORT_L28_CAM_YUVO_R3		MTK_M4U_ID(28, 1)
+#define M4U_PORT_L28_CAM_YUVCO_R1		MTK_M4U_ID(28, 2)
+#define M4U_PORT_L28_CAM_YUVO_R2		MTK_M4U_ID(28, 3)
+#define M4U_PORT_L28_CAM_RZH1N2TO_R1		MTK_M4U_ID(28, 4)
+#define M4U_PORT_L28_CAM_DRZS4NO_R1		MTK_M4U_ID(28, 5)
+#define M4U_PORT_L28_CAM_TNCSO_R1		MTK_M4U_ID(28, 6)
+
+/* Infra iommu ports */
+/* PCIe1: read: BIT16; write BIT17. */
+#define IOMMU_PORT_INFRA_PCIE1			MTK_IFAIOMMU_PERI_ID(16)
+/* PCIe0: read: BIT18; write BIT19. */
+#define IOMMU_PORT_INFRA_PCIE0			MTK_IFAIOMMU_PERI_ID(18)
+#define IOMMU_PORT_INFRA_SSUSB_P3_R		MTK_IFAIOMMU_PERI_ID(20)
+#define IOMMU_PORT_INFRA_SSUSB_P3_W		MTK_IFAIOMMU_PERI_ID(21)
+#define IOMMU_PORT_INFRA_SSUSB_P2_R		MTK_IFAIOMMU_PERI_ID(22)
+#define IOMMU_PORT_INFRA_SSUSB_P2_W		MTK_IFAIOMMU_PERI_ID(23)
+#define IOMMU_PORT_INFRA_SSUSB_P1_1_R		MTK_IFAIOMMU_PERI_ID(24)
+#define IOMMU_PORT_INFRA_SSUSB_P1_1_W		MTK_IFAIOMMU_PERI_ID(25)
+#define IOMMU_PORT_INFRA_SSUSB_P1_0_R		MTK_IFAIOMMU_PERI_ID(26)
+#define IOMMU_PORT_INFRA_SSUSB_P1_0_W		MTK_IFAIOMMU_PERI_ID(27)
+#define IOMMU_PORT_INFRA_SSUSB2_R		MTK_IFAIOMMU_PERI_ID(28)
+#define IOMMU_PORT_INFRA_SSUSB2_W		MTK_IFAIOMMU_PERI_ID(29)
+#define IOMMU_PORT_INFRA_SSUSB_R		MTK_IFAIOMMU_PERI_ID(30)
+#define IOMMU_PORT_INFRA_SSUSB_W		MTK_IFAIOMMU_PERI_ID(31)
+
+#endif
diff --git a/include/dt-bindings/memory/mtk-memory-port.h b/include/dt-bindings/memory/mtk-memory-port.h
index 7d64103209afcdc75b689441fe49d9172ee77325..2f68a0511a2578e2e4354b50b64b1380357b657b 100644
--- a/include/dt-bindings/memory/mtk-memory-port.h
+++ b/include/dt-bindings/memory/mtk-memory-port.h
@@ -12,4 +12,6 @@
 #define MTK_M4U_TO_LARB(id)		(((id) >> 5) & 0x1f)
 #define MTK_M4U_TO_PORT(id)		((id) & 0x1f)
 
+#define MTK_IFAIOMMU_PERI_ID(port)	MTK_M4U_ID(0, port)
+
 #endif
diff --git a/include/dt-bindings/power/mt8195-power.h b/include/dt-bindings/power/mt8195-power.h
new file mode 100644
index 0000000000000000000000000000000000000000..b20ca4b3e3a89c718c5eee0bd7cca72b4bb0f5a3
--- /dev/null
+++ b/include/dt-bindings/power/mt8195-power.h
@@ -0,0 +1,46 @@
+/* SPDX-License-Identifier: (GPL-2.0 OR MIT) */
+/*
+ * Copyright (c) 2021 MediaTek Inc.
+ * Author: Chun-Jie Chen <chun-jie.chen@mediatek.com>
+ */
+
+#ifndef _DT_BINDINGS_POWER_MT8195_POWER_H
+#define _DT_BINDINGS_POWER_MT8195_POWER_H
+
+#define MT8195_POWER_DOMAIN_PCIE_MAC_P0		0
+#define MT8195_POWER_DOMAIN_PCIE_MAC_P1		1
+#define MT8195_POWER_DOMAIN_PCIE_PHY		2
+#define MT8195_POWER_DOMAIN_SSUSB_PCIE_PHY	3
+#define MT8195_POWER_DOMAIN_CSI_RX_TOP		4
+#define MT8195_POWER_DOMAIN_ETHER		5
+#define MT8195_POWER_DOMAIN_ADSP		6
+#define MT8195_POWER_DOMAIN_AUDIO		7
+#define MT8195_POWER_DOMAIN_MFG0		8
+#define MT8195_POWER_DOMAIN_MFG1		9
+#define MT8195_POWER_DOMAIN_MFG2		10
+#define MT8195_POWER_DOMAIN_MFG3		11
+#define MT8195_POWER_DOMAIN_MFG4		12
+#define MT8195_POWER_DOMAIN_MFG5		13
+#define MT8195_POWER_DOMAIN_MFG6		14
+#define MT8195_POWER_DOMAIN_VPPSYS0		15
+#define MT8195_POWER_DOMAIN_VDOSYS0		16
+#define MT8195_POWER_DOMAIN_VPPSYS1		17
+#define MT8195_POWER_DOMAIN_VDOSYS1		18
+#define MT8195_POWER_DOMAIN_DP_TX		19
+#define MT8195_POWER_DOMAIN_EPD_TX		20
+#define MT8195_POWER_DOMAIN_HDMI_TX		21
+#define MT8195_POWER_DOMAIN_WPESYS		22
+#define MT8195_POWER_DOMAIN_VDEC0		23
+#define MT8195_POWER_DOMAIN_VDEC1		24
+#define MT8195_POWER_DOMAIN_VDEC2		25
+#define MT8195_POWER_DOMAIN_VENC		26
+#define MT8195_POWER_DOMAIN_VENC_CORE1		27
+#define MT8195_POWER_DOMAIN_IMG			28
+#define MT8195_POWER_DOMAIN_DIP			29
+#define MT8195_POWER_DOMAIN_IPE			30
+#define MT8195_POWER_DOMAIN_CAM			31
+#define MT8195_POWER_DOMAIN_CAM_RAWA		32
+#define MT8195_POWER_DOMAIN_CAM_RAWB		33
+#define MT8195_POWER_DOMAIN_CAM_MRAW		34
+
+#endif /* _DT_BINDINGS_POWER_MT8195_POWER_H */
diff --git a/include/dt-bindings/reset/mt8195-resets.h b/include/dt-bindings/reset/mt8195-resets.h
index a26bccc8b957a70b8f0189a59d60d9daeac9fad2..eaaa882c09bdf9bcdd63a53ab5edf5f76d576d95 100644
--- a/include/dt-bindings/reset/mt8195-resets.h
+++ b/include/dt-bindings/reset/mt8195-resets.h
@@ -26,4 +26,16 @@
 
 #define MT8195_TOPRGU_SW_RST_NUM               16
 
+/* VDOSYS1 */
+#define MT8195_VDOSYS1_SW0_RST_B_MERGE0_DL_ASYNC 25
+#define MT8195_VDOSYS1_SW0_RST_B_MERGE1_DL_ASYNC 26
+#define MT8195_VDOSYS1_SW0_RST_B_MERGE2_DL_ASYNC 27
+#define MT8195_VDOSYS1_SW0_RST_B_MERGE3_DL_ASYNC 28
+#define MT8195_VDOSYS1_SW0_RST_B_MERGE4_DL_ASYNC 29
+#define MT8195_VDOSYS1_SW1_RST_B_HDR_VDO_FE0_DL_ASYNC 51
+#define MT8195_VDOSYS1_SW1_RST_B_HDR_VDO_FE1_DL_ASYNC 52
+#define MT8195_VDOSYS1_SW1_RST_B_HDR_GFX_FE0_DL_ASYNC 53
+#define MT8195_VDOSYS1_SW1_RST_B_HDR_GFX_FE1_DL_ASYNC 54
+#define MT8195_VDOSYS1_SW1_RST_B_HDR_VDO_BE_DL_ASYNC 55
+
 #endif  /* _DT_BINDINGS_RESET_CONTROLLER_MT8195 */
diff --git a/include/linux/remoteproc/mtk_scp.h b/include/linux/remoteproc/mtk_scp.h
index b47416f7aeb8412d5d0304cee4f63b9e3ceda6d6..7c2b7cc9fe6c122f3d4e6cb409ff462ec2844aaf 100644
--- a/include/linux/remoteproc/mtk_scp.h
+++ b/include/linux/remoteproc/mtk_scp.h
@@ -41,6 +41,8 @@ enum scp_ipi_id {
 	SCP_IPI_ISP_FRAME,
 	SCP_IPI_FD_CMD,
 	SCP_IPI_CROS_HOST_CMD,
+	SCP_IPI_VDEC_LAT,
+	SCP_IPI_VDEC_CORE,
 	SCP_IPI_NS_SERVICE = 0xFF,
 	SCP_IPI_MAX = 0x100,
 };
diff --git a/include/linux/soc/mediatek/infracfg.h b/include/linux/soc/mediatek/infracfg.h
index e7842debc05d53b2e62ffcdb1e7fe5e1364221db..498aa891b88cc4cb8981c5e5870afbcc9f960805 100644
--- a/include/linux/soc/mediatek/infracfg.h
+++ b/include/linux/soc/mediatek/infracfg.h
@@ -2,6 +2,88 @@
 #ifndef __SOC_MEDIATEK_INFRACFG_H
 #define __SOC_MEDIATEK_INFRACFG_H
 
+#define MT8195_TOP_AXI_PROT_EN_STA1                     0x228
+#define MT8195_TOP_AXI_PROT_EN_1_STA1                   0x258
+#define MT8195_TOP_AXI_PROT_EN_SET			0x2a0
+#define MT8195_TOP_AXI_PROT_EN_CLR                      0x2a4
+#define MT8195_TOP_AXI_PROT_EN_1_SET                    0x2a8
+#define MT8195_TOP_AXI_PROT_EN_1_CLR                    0x2ac
+#define MT8195_TOP_AXI_PROT_EN_MM_SET                   0x2d4
+#define MT8195_TOP_AXI_PROT_EN_MM_CLR                   0x2d8
+#define MT8195_TOP_AXI_PROT_EN_MM_STA1                  0x2ec
+#define MT8195_TOP_AXI_PROT_EN_2_SET                    0x714
+#define MT8195_TOP_AXI_PROT_EN_2_CLR                    0x718
+#define MT8195_TOP_AXI_PROT_EN_2_STA1                   0x724
+#define MT8195_TOP_AXI_PROT_EN_VDNR_SET                 0xb84
+#define MT8195_TOP_AXI_PROT_EN_VDNR_CLR                 0xb88
+#define MT8195_TOP_AXI_PROT_EN_VDNR_STA1                0xb90
+#define MT8195_TOP_AXI_PROT_EN_VDNR_1_SET               0xba4
+#define MT8195_TOP_AXI_PROT_EN_VDNR_1_CLR               0xba8
+#define MT8195_TOP_AXI_PROT_EN_VDNR_1_STA1              0xbb0
+#define MT8195_TOP_AXI_PROT_EN_VDNR_2_SET               0xbb8
+#define MT8195_TOP_AXI_PROT_EN_VDNR_2_CLR               0xbbc
+#define MT8195_TOP_AXI_PROT_EN_VDNR_2_STA1              0xbc4
+#define MT8195_TOP_AXI_PROT_EN_SUB_INFRA_VDNR_SET       0xbcc
+#define MT8195_TOP_AXI_PROT_EN_SUB_INFRA_VDNR_CLR       0xbd0
+#define MT8195_TOP_AXI_PROT_EN_SUB_INFRA_VDNR_STA1      0xbd8
+#define MT8195_TOP_AXI_PROT_EN_MM_2_SET                 0xdcc
+#define MT8195_TOP_AXI_PROT_EN_MM_2_CLR                 0xdd0
+#define MT8195_TOP_AXI_PROT_EN_MM_2_STA1                0xdd8
+
+#define MT8195_TOP_AXI_PROT_EN_VDOSYS0			BIT(6)
+#define MT8195_TOP_AXI_PROT_EN_VPPSYS0			BIT(10)
+#define MT8195_TOP_AXI_PROT_EN_MFG1			BIT(11)
+#define MT8195_TOP_AXI_PROT_EN_MFG1_2ND			GENMASK(22, 21)
+#define MT8195_TOP_AXI_PROT_EN_VPPSYS0_2ND		BIT(23)
+#define MT8195_TOP_AXI_PROT_EN_1_MFG1			GENMASK(20, 19)
+#define MT8195_TOP_AXI_PROT_EN_1_CAM			BIT(22)
+#define MT8195_TOP_AXI_PROT_EN_2_CAM			BIT(0)
+#define MT8195_TOP_AXI_PROT_EN_2_MFG1_2ND		GENMASK(6, 5)
+#define MT8195_TOP_AXI_PROT_EN_2_MFG1			BIT(7)
+#define MT8195_TOP_AXI_PROT_EN_2_AUDIO			(BIT(9) | BIT(11))
+#define MT8195_TOP_AXI_PROT_EN_2_ADSP			(BIT(12) | GENMASK(16, 14))
+#define MT8195_TOP_AXI_PROT_EN_MM_CAM			(BIT(0) | BIT(2) | BIT(4))
+#define MT8195_TOP_AXI_PROT_EN_MM_IPE			BIT(1)
+#define MT8195_TOP_AXI_PROT_EN_MM_IMG			BIT(3)
+#define MT8195_TOP_AXI_PROT_EN_MM_VDOSYS0		GENMASK(21, 17)
+#define MT8195_TOP_AXI_PROT_EN_MM_VPPSYS1		GENMASK(8, 5)
+#define MT8195_TOP_AXI_PROT_EN_MM_VENC			(BIT(9) | BIT(11))
+#define MT8195_TOP_AXI_PROT_EN_MM_VENC_CORE1		(BIT(10) | BIT(12))
+#define MT8195_TOP_AXI_PROT_EN_MM_VDEC0			BIT(13)
+#define MT8195_TOP_AXI_PROT_EN_MM_VDEC1			BIT(14)
+#define MT8195_TOP_AXI_PROT_EN_MM_VDOSYS1_2ND		BIT(22)
+#define MT8195_TOP_AXI_PROT_EN_MM_VPPSYS1_2ND		BIT(23)
+#define MT8195_TOP_AXI_PROT_EN_MM_CAM_2ND		BIT(24)
+#define MT8195_TOP_AXI_PROT_EN_MM_IMG_2ND		BIT(25)
+#define MT8195_TOP_AXI_PROT_EN_MM_VENC_2ND		BIT(26)
+#define MT8195_TOP_AXI_PROT_EN_MM_WPESYS		BIT(27)
+#define MT8195_TOP_AXI_PROT_EN_MM_VDEC0_2ND		BIT(28)
+#define MT8195_TOP_AXI_PROT_EN_MM_VDEC1_2ND		BIT(29)
+#define MT8195_TOP_AXI_PROT_EN_MM_VDOSYS1		GENMASK(31, 30)
+#define MT8195_TOP_AXI_PROT_EN_MM_2_VPPSYS0_2ND		(GENMASK(1, 0) | BIT(4) | BIT(11))
+#define MT8195_TOP_AXI_PROT_EN_MM_2_VENC		BIT(2)
+#define MT8195_TOP_AXI_PROT_EN_MM_2_VENC_CORE1		(BIT(3) | BIT(15))
+#define MT8195_TOP_AXI_PROT_EN_MM_2_CAM			(BIT(5) | BIT(17))
+#define MT8195_TOP_AXI_PROT_EN_MM_2_VPPSYS1		(GENMASK(7, 6) | BIT(18))
+#define MT8195_TOP_AXI_PROT_EN_MM_2_VPPSYS0		GENMASK(9, 8)
+#define MT8195_TOP_AXI_PROT_EN_MM_2_VDOSYS1		BIT(10)
+#define MT8195_TOP_AXI_PROT_EN_MM_2_VDEC2_2ND		BIT(12)
+#define MT8195_TOP_AXI_PROT_EN_MM_2_VDEC0_2ND		BIT(13)
+#define MT8195_TOP_AXI_PROT_EN_MM_2_WPESYS_2ND		BIT(14)
+#define MT8195_TOP_AXI_PROT_EN_MM_2_IPE			BIT(16)
+#define MT8195_TOP_AXI_PROT_EN_MM_2_VDEC2		BIT(21)
+#define MT8195_TOP_AXI_PROT_EN_MM_2_VDEC0		BIT(22)
+#define MT8195_TOP_AXI_PROT_EN_MM_2_WPESYS		GENMASK(24, 23)
+#define MT8195_TOP_AXI_PROT_EN_VDNR_1_EPD_TX		BIT(1)
+#define MT8195_TOP_AXI_PROT_EN_VDNR_1_DP_TX		BIT(2)
+#define MT8195_TOP_AXI_PROT_EN_VDNR_PCIE_MAC_P0		(BIT(11) | BIT(28))
+#define MT8195_TOP_AXI_PROT_EN_VDNR_PCIE_MAC_P1		(BIT(12) | BIT(29))
+#define MT8195_TOP_AXI_PROT_EN_VDNR_1_PCIE_MAC_P0	BIT(13)
+#define MT8195_TOP_AXI_PROT_EN_VDNR_1_PCIE_MAC_P1	BIT(14)
+#define MT8195_TOP_AXI_PROT_EN_SUB_INFRA_VDNR_MFG1	(BIT(17) | BIT(19))
+#define MT8195_TOP_AXI_PROT_EN_SUB_INFRA_VDNR_VPPSYS0	BIT(20)
+#define MT8195_TOP_AXI_PROT_EN_SUB_INFRA_VDNR_VDOSYS0	BIT(21)
+
 #define MT8192_TOP_AXI_PROT_EN_STA1			0x228
 #define MT8192_TOP_AXI_PROT_EN_1_STA1			0x258
 #define MT8192_TOP_AXI_PROT_EN_SET			0x2a0
diff --git a/include/linux/soc/mediatek/mtk-mmsys.h b/include/linux/soc/mediatek/mtk-mmsys.h
index 2228bf6133da29ccd56e055b96021ca950542f7a..5882dc4cc88707cd0cbd31e48ed09a5559887828 100644
--- a/include/linux/soc/mediatek/mtk-mmsys.h
+++ b/include/linux/soc/mediatek/mtk-mmsys.h
@@ -6,7 +6,17 @@
 #ifndef __MTK_MMSYS_H
 #define __MTK_MMSYS_H
 
+#include <linux/mailbox_controller.h>
+#include <linux/mailbox/mtk-cmdq-mailbox.h>
+#include <linux/soc/mediatek/mtk-cmdq.h>
+
+struct mmsys_cmdq_cmd {
+	struct cmdq_pkt *pkt;
+	s32 *event;
+};
+
 enum mtk_ddp_comp_id;
+enum mtk_mdp_comp_id;
 struct device;
 
 enum mtk_ddp_comp_id {
@@ -17,18 +27,30 @@ enum mtk_ddp_comp_id {
 	DDP_COMPONENT_COLOR0,
 	DDP_COMPONENT_COLOR1,
 	DDP_COMPONENT_DITHER,
+	DDP_COMPONENT_DP_INTF0,
+	DDP_COMPONENT_DP_INTF1,
 	DDP_COMPONENT_DPI0,
 	DDP_COMPONENT_DPI1,
+	DDP_COMPONENT_DPTX,
+	DDP_COMPONENT_DSC0,
+	DDP_COMPONENT_DSC1,
 	DDP_COMPONENT_DSI0,
 	DDP_COMPONENT_DSI1,
 	DDP_COMPONENT_DSI2,
 	DDP_COMPONENT_DSI3,
 	DDP_COMPONENT_GAMMA,
+	DDP_COMPONENT_MERGE0,
+	DDP_COMPONENT_MERGE1,
+	DDP_COMPONENT_MERGE2,
+	DDP_COMPONENT_MERGE3,
+	DDP_COMPONENT_MERGE4,
+	DDP_COMPONENT_MERGE5,
 	DDP_COMPONENT_OD0,
 	DDP_COMPONENT_OD1,
 	DDP_COMPONENT_OVL0,
 	DDP_COMPONENT_OVL_2L0,
 	DDP_COMPONENT_OVL_2L1,
+	DDP_COMPONENT_OVL_ADAPTOR,
 	DDP_COMPONENT_OVL1,
 	DDP_COMPONENT_PWM0,
 	DDP_COMPONENT_PWM1,
@@ -42,6 +64,77 @@ enum mtk_ddp_comp_id {
 	DDP_COMPONENT_ID_MAX,
 };
 
+enum mtk_mmsys_config_type {
+	MMSYS_CONFIG_MERGE_ASYNC_WIDTH,
+	MMSYS_CONFIG_MERGE_ASYNC_HEIGHT,
+	MMSYS_CONFIG_HDR_BE_ASYNC_WIDTH,
+	MMSYS_CONFIG_HDR_BE_ASYNC_HEIGHT,
+	MMSYS_CONFIG_HDR_ALPHA_SEL,
+	MMSYS_CONFIG_MIXER_IN_ALPHA_ODD,
+	MMSYS_CONFIG_MIXER_IN_ALPHA_EVEN,
+	MMSYS_CONFIG_MIXER_IN_CH_SWAP,
+	MMSYS_CONFIG_MIXER_IN_MODE,
+	MMSYS_CONFIG_MIXER_IN_BIWIDTH,
+};
+
+enum mtk_mdp_comp_id {
+	MDP_COMP_NONE = -1,	/* Invalid engine */
+
+	/* ISP */
+	MDP_COMP_WPEI = 0,
+	MDP_COMP_WPEO,		/* 1 */
+	MDP_COMP_WPEI2,		/* 2 */
+	MDP_COMP_WPEO2,		/* 3 */
+	MDP_COMP_ISP_IMGI,	/* 4 */
+	MDP_COMP_ISP_IMGO,	/* 5 */
+	MDP_COMP_ISP_IMG2O,	/* 6 */
+
+	/* IPU */
+	MDP_COMP_IPUI,		/* 7 */
+	MDP_COMP_IPUO,		/* 8 */
+
+	/* MDP */
+	MDP_COMP_CAMIN,		/* 9 */
+	MDP_COMP_CAMIN2,	/* 10 */
+	MDP_COMP_RDMA0,		/* 11 */
+	MDP_COMP_AAL0,		/* 12 */
+	MDP_COMP_CCORR0,	/* 13 */
+	MDP_COMP_RSZ0,		/* 14 */
+	MDP_COMP_RSZ1,		/* 15 */
+	MDP_COMP_TDSHP0,	/* 16 */
+	MDP_COMP_COLOR0,	/* 17 */
+	MDP_COMP_PATH0_SOUT,	/* 18 */
+	MDP_COMP_PATH1_SOUT,	/* 19 */
+	MDP_COMP_WROT0,		/* 20 */
+	MDP_COMP_WDMA,		/* 21 */
+
+	/* Dummy Engine */
+	MDP_COMP_RDMA1,		/* 22 */
+	MDP_COMP_RSZ2,		/* 23 */
+	MDP_COMP_TDSHP1,	/* 24 */
+	MDP_COMP_WROT1,		/* 25 */
+
+	MDP_MAX_COMP_COUNT	/* ALWAYS keep at the end */
+};
+
+enum mtk_mdp_pipe_id {
+	MDP_PIPE_RDMA0,
+	MDP_PIPE_IMGI,
+	MDP_PIPE_WPEI,
+	MDP_PIPE_WPEI2,
+	MDP_PIPE_MAX
+};
+
+enum mtk_isp_ctrl {
+	ISP_CTRL_MMSYS_SW0_RST_B,
+	ISP_CTRL_MMSYS_SW1_RST_B,
+	ISP_CTRL_MDP_ASYNC_CFG_WD,
+	ISP_CTRL_MDP_ASYNC_IPU_CFG_WD,
+	ISP_CTRL_ISP_RELAY_CFG_WD,
+	ISP_CTRL_IPU_RELAY_CFG_WD,
+	ISP_CTRL_MAX
+};
+
 void mtk_mmsys_ddp_connect(struct device *dev,
 			   enum mtk_ddp_comp_id cur,
 			   enum mtk_ddp_comp_id next);
@@ -50,4 +143,24 @@ void mtk_mmsys_ddp_disconnect(struct device *dev,
 			      enum mtk_ddp_comp_id cur,
 			      enum mtk_ddp_comp_id next);
 
+void mtk_mmsys_ddp_config(struct device *dev, enum mtk_mmsys_config_type config,
+			  u32 id, u32 val, struct cmdq_pkt *cmdq_pkt);
+
+void mtk_mmsys_mdp_connect(struct device *dev,
+			   struct mmsys_cmdq_cmd *cmd,
+			   enum mtk_mdp_comp_id cur,
+			   enum mtk_mdp_comp_id next);
+
+void mtk_mmsys_mdp_disconnect(struct device *dev,
+			      struct mmsys_cmdq_cmd *cmd,
+			      enum mtk_mdp_comp_id cur,
+			      enum mtk_mdp_comp_id next);
+
+void mtk_mmsys_mdp_isp_ctrl(struct device *dev, struct mmsys_cmdq_cmd *cmd,
+			    enum mtk_mdp_comp_id id);
+
+void mtk_mmsys_mdp_camin_ctrl(struct device *dev, struct mmsys_cmdq_cmd *cmd,
+			      enum mtk_mdp_comp_id id,
+			      u32 camin_w, u32 camin_h);
+
 #endif /* __MTK_MMSYS_H */
diff --git a/include/linux/soc/mediatek/mtk-mutex.h b/include/linux/soc/mediatek/mtk-mutex.h
index 6fe4ffbde290a1438a36f52462f8463289e7f3bf..d08b98419dd91363dd177a4301df136d0745e93f 100644
--- a/include/linux/soc/mediatek/mtk-mutex.h
+++ b/include/linux/soc/mediatek/mtk-mutex.h
@@ -11,11 +11,19 @@ struct device;
 struct mtk_mutex;
 
 struct mtk_mutex *mtk_mutex_get(struct device *dev);
+struct mtk_mutex *mtk_mutex_mdp_get(struct device *dev,
+				    enum mtk_mdp_pipe_id id);
 int mtk_mutex_prepare(struct mtk_mutex *mutex);
 void mtk_mutex_add_comp(struct mtk_mutex *mutex,
 			enum mtk_ddp_comp_id id);
+void mtk_mutex_add_mdp_mod(struct mtk_mutex *mutex, u32 mod,
+			   struct mmsys_cmdq_cmd *cmd);
 void mtk_mutex_enable(struct mtk_mutex *mutex);
+void mtk_mutex_enable_by_cmdq(struct mtk_mutex *mutex,
+			      struct mmsys_cmdq_cmd *cmd);
 void mtk_mutex_disable(struct mtk_mutex *mutex);
+void mtk_mutex_disable_by_cmdq(struct mtk_mutex *mutex,
+			       struct mmsys_cmdq_cmd *cmd);
 void mtk_mutex_remove_comp(struct mtk_mutex *mutex,
 			   enum mtk_ddp_comp_id id);
 void mtk_mutex_unprepare(struct mtk_mutex *mutex);
diff --git a/include/sound/sof.h b/include/sound/sof.h
index 6a1cd8e783d8f4e0875a2eea615d14bbfc1665ca..dc3cbb93041bdc771dc93507c91956ace86f27fd 100644
--- a/include/sound/sof.h
+++ b/include/sound/sof.h
@@ -67,6 +67,7 @@ struct sof_dev_desc {
 	struct snd_soc_acpi_mach *alt_machines;
 
 	bool use_acpi_target_states;
+	bool no_ignore_machine;
 
 	/* Platform resource indexes in BAR / ACPI resources. */
 	/* Must set to -1 if not used - add new items to end */
diff --git a/include/sound/sof/dai-mediatek.h b/include/sound/sof/dai-mediatek.h
new file mode 100644
index 0000000000000000000000000000000000000000..d9732b50a5caa407f4a4ae21ffe9062feeaa1624
--- /dev/null
+++ b/include/sound/sof/dai-mediatek.h
@@ -0,0 +1,26 @@
+/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause) */
+/*
+ *Copyright(c) 2021 Mediatek
+ *
+ * Author: Bo Pan <bo.pan@mediatek.com>
+ */
+
+#ifndef __IPC_DAI_MEDIATEK_H__
+#define __IPC_DAI_MEDIATEK_H__
+
+//#include <linux/types.h>
+#include <sound/sof/header.h>
+
+struct sof_ipc_dai_afe_params {
+	struct sof_ipc_hdr hdr;
+
+	u32 channels;
+	u32 rate;
+	u32 format;
+	u32 stream_id;
+
+	u32 reserved[4]; /* reserve for future */
+} __packed;
+
+#endif /* __IPC_DAI_MEDIATEK_H__ */
+
diff --git a/include/sound/sof/dai.h b/include/sound/sof/dai.h
index 6bb403e8c5ee796038393b2bcf005f72def5e932..8c09251db51d60a7835ceedf7dc6dd834f877d59 100644
--- a/include/sound/sof/dai.h
+++ b/include/sound/sof/dai.h
@@ -12,6 +12,7 @@
 #include <sound/sof/header.h>
 #include <sound/sof/dai-intel.h>
 #include <sound/sof/dai-imx.h>
+#include <sound/sof/dai-mediatek.h>
 
 /*
  * DAI Configuration.
@@ -59,6 +60,7 @@ enum sof_ipc_dai_type {
 	SOF_DAI_INTEL_ALH,		/**< Intel ALH  */
 	SOF_DAI_IMX_SAI,		/**< i.MX SAI */
 	SOF_DAI_IMX_ESAI,		/**< i.MX ESAI */
+	SOF_DAI_MEDIATEK_AFE,		/**< Mediatek AFE */
 };
 
 /* general purpose DAI configuration */
@@ -82,6 +84,7 @@ struct sof_ipc_dai_config {
 		struct sof_ipc_dai_alh_params alh;
 		struct sof_ipc_dai_esai_params esai;
 		struct sof_ipc_dai_sai_params sai;
+		struct sof_ipc_dai_afe_params afe;
 	};
 } __packed;
 
diff --git a/include/uapi/linux/v4l2-controls.h b/include/uapi/linux/v4l2-controls.h
index 6c94225b15a458df75570af2283956056cf92f48..3e32d912b103c9cb6472fd732fb1ec5e2fa95bd0 100644
--- a/include/uapi/linux/v4l2-controls.h
+++ b/include/uapi/linux/v4l2-controls.h
@@ -1815,7 +1815,9 @@ struct v4l2_vp8_entropy_coder_state {
 #define V4L2_VP8_FRAME_IS_KEY_FRAME(hdr) \
 	(!!((hdr)->flags & V4L2_VP8_FRAME_FLAG_KEY_FRAME))
 
-#define V4L2_CID_STATELESS_VP8_FRAME (V4L2_CID_CODEC_STATELESS_BASE + 200)
+/* XXX Hack this to match old staging VP8 stateless API */
+#define V4L2_CID_STATELESS_VP8_FRAME (V4L2_CID_CODEC_BASE + 2000)
+
 /**
  * struct v4l2_vp8_frame - VP8 frame parameters
  *
diff --git a/include/uapi/sound/sof/tokens.h b/include/uapi/sound/sof/tokens.h
index a642bf30c027855e28f5e7cc24905f0a0b8d9c98..ef86626371f89b3ea920e3b77b1875a33f6d25bc 100644
--- a/include/uapi/sound/sof/tokens.h
+++ b/include/uapi/sound/sof/tokens.h
@@ -139,4 +139,9 @@
 #define SOF_TKN_INTEL_HDA_RATE			1500
 #define SOF_TKN_INTEL_HDA_CH			1501
 
+/* AFE */
+#define SOF_TKN_MEDIATEK_AFE_RATE		1600
+#define SOF_TKN_MEDIATEK_AFE_CH			1601
+#define SOF_TKN_MEDIATEK_AFE_FORMAT		1602
+
 #endif
diff --git a/sound/soc/codecs/mt6359.c b/sound/soc/codecs/mt6359.c
index 6de0d744fa9eb3611eabbbd35a02f29853e8273a..f8532aa7e4aa03704b03e63232061e0452e61a90 100644
--- a/sound/soc/codecs/mt6359.c
+++ b/sound/soc/codecs/mt6359.c
@@ -239,7 +239,7 @@ static void zcd_disable(struct mt6359_priv *priv)
 
 static void hp_main_output_ramp(struct mt6359_priv *priv, bool up)
 {
-	int i = 0, stage = 0;
+	int i, stage;
 	int target = 7;
 
 	/* Enable/Reduce HPL/R main output stage step by step */
@@ -257,7 +257,7 @@ static void hp_main_output_ramp(struct mt6359_priv *priv, bool up)
 
 static void hp_aux_feedback_loop_gain_ramp(struct mt6359_priv *priv, bool up)
 {
-	int i = 0, stage = 0;
+	int i, stage;
 	int target = 0xf;
 
 	/* Enable/Reduce HP aux feedback loop gain step by step */
@@ -271,7 +271,7 @@ static void hp_aux_feedback_loop_gain_ramp(struct mt6359_priv *priv, bool up)
 
 static void hp_in_pair_current(struct mt6359_priv *priv, bool increase)
 {
-	int i = 0, stage = 0;
+	int i, stage;
 	int target = 0x3;
 
 	/* Set input diff pair bias select (Hi-Fi mode) */
@@ -2697,7 +2697,7 @@ static int mt6359_codec_probe(struct snd_soc_component *cmpnt)
 
 static void mt6359_codec_remove(struct snd_soc_component *cmpnt)
 {
-	snd_soc_component_exit_regmap(cmpnt);
+	cmpnt->regmap = NULL;
 }
 
 static const DECLARE_TLV_DB_SCALE(hp_playback_tlv, -2200, 100, 0);
@@ -2754,7 +2754,8 @@ static int mt6359_parse_dt(struct mt6359_priv *priv)
 	ret = of_property_read_u32(np, "mediatek,dmic-mode",
 				   &priv->dmic_one_wire_mode);
 	if (ret) {
-		dev_warn(priv->dev, "%s() failed to read dmic-mode\n",
+		dev_info(priv->dev,
+			 "%s() failed to read dmic-mode, use default (0)\n",
 			 __func__);
 		priv->dmic_one_wire_mode = 0;
 	}
@@ -2762,24 +2763,27 @@ static int mt6359_parse_dt(struct mt6359_priv *priv)
 	ret = of_property_read_u32(np, "mediatek,mic-type-0",
 				   &priv->mux_select[MUX_MIC_TYPE_0]);
 	if (ret) {
-		dev_warn(priv->dev, "%s() failed to read mic-type-0\n",
-			 __func__);
+		dev_info(priv->dev,
+			 "%s() failed to read mic-type-0, use default (%d)\n",
+			 __func__, MIC_TYPE_MUX_IDLE);
 		priv->mux_select[MUX_MIC_TYPE_0] = MIC_TYPE_MUX_IDLE;
 	}
 
 	ret = of_property_read_u32(np, "mediatek,mic-type-1",
 				   &priv->mux_select[MUX_MIC_TYPE_1]);
 	if (ret) {
-		dev_warn(priv->dev, "%s() failed to read mic-type-1\n",
-			 __func__);
+		dev_info(priv->dev,
+			 "%s() failed to read mic-type-1, use default (%d)\n",
+			 __func__, MIC_TYPE_MUX_IDLE);
 		priv->mux_select[MUX_MIC_TYPE_1] = MIC_TYPE_MUX_IDLE;
 	}
 
 	ret = of_property_read_u32(np, "mediatek,mic-type-2",
 				   &priv->mux_select[MUX_MIC_TYPE_2]);
 	if (ret) {
-		dev_warn(priv->dev, "%s() failed to read mic-type-2\n",
-			 __func__);
+		dev_info(priv->dev,
+			 "%s() failed to read mic-type-2, use default (%d)\n",
+			 __func__, MIC_TYPE_MUX_IDLE);
 		priv->mux_select[MUX_MIC_TYPE_2] = MIC_TYPE_MUX_IDLE;
 	}
 
diff --git a/sound/soc/codecs/rt1011.c b/sound/soc/codecs/rt1011.c
index 098ecf13814d6b527af63ef11ed3d2f06e07e7a6..508597866dffa6949ad8686e1ecfef7901b02696 100644
--- a/sound/soc/codecs/rt1011.c
+++ b/sound/soc/codecs/rt1011.c
@@ -1089,25 +1089,21 @@ static int rt1011_recv_spk_mode_put(struct snd_kcontrol *kcontrol,
 
 static bool rt1011_validate_bq_drc_coeff(unsigned short reg)
 {
-	if ((reg == RT1011_DAC_SET_1) |
-		(reg >= RT1011_ADC_SET && reg <= RT1011_ADC_SET_1) |
-		(reg == RT1011_ADC_SET_4) | (reg == RT1011_ADC_SET_5) |
-		(reg == RT1011_MIXER_1) |
-		(reg == RT1011_A_TIMING_1) | (reg >= RT1011_POWER_7 &&
-		reg <= RT1011_POWER_8) |
-		(reg == RT1011_CLASS_D_POS) | (reg == RT1011_ANALOG_CTRL) |
-		(reg >= RT1011_SPK_TEMP_PROTECT_0 &&
-		reg <= RT1011_SPK_TEMP_PROTECT_6) |
-		(reg >= RT1011_SPK_PRO_DC_DET_5 && reg <= RT1011_BAT_GAIN_1) |
-		(reg >= RT1011_RT_DRC_CROSS && reg <= RT1011_RT_DRC_POS_8) |
-		(reg >= RT1011_CROSS_BQ_SET_1 && reg <= RT1011_BQ_10_A2_15_0) |
-		(reg >= RT1011_SMART_BOOST_TIMING_1 &&
-		reg <= RT1011_SMART_BOOST_TIMING_36) |
-		(reg == RT1011_SINE_GEN_REG_1) |
-		(reg >= RT1011_STP_ALPHA_RECIPROCAL_MSB &&
-		reg <= RT1011_BQ_6_PARAMS_CHECK_5) |
-		(reg >= RT1011_BQ_7_PARAMS_CHECK_1 &&
-		reg <= RT1011_BQ_10_PARAMS_CHECK_5))
+	if ((reg == RT1011_DAC_SET_1) ||
+		(reg >= RT1011_ADC_SET && reg <= RT1011_ADC_SET_1) ||
+		(reg == RT1011_ADC_SET_4) || (reg == RT1011_ADC_SET_5) ||
+		(reg == RT1011_MIXER_1) ||
+		(reg == RT1011_A_TIMING_1) ||
+		(reg >= RT1011_POWER_7 && reg <= RT1011_POWER_8) ||
+		(reg == RT1011_CLASS_D_POS) || (reg == RT1011_ANALOG_CTRL) ||
+		(reg >= RT1011_SPK_TEMP_PROTECT_0 && reg <= RT1011_SPK_TEMP_PROTECT_6) ||
+		(reg >= RT1011_SPK_PRO_DC_DET_5 && reg <= RT1011_BAT_GAIN_1) ||
+		(reg >= RT1011_RT_DRC_CROSS && reg <= RT1011_RT_DRC_POS_8) ||
+		(reg >= RT1011_CROSS_BQ_SET_1 && reg <= RT1011_BQ_10_A2_15_0) ||
+		(reg >= RT1011_SMART_BOOST_TIMING_1 && reg <= RT1011_SMART_BOOST_TIMING_36) ||
+		(reg == RT1011_SINE_GEN_REG_1) ||
+		(reg >= RT1011_STP_ALPHA_RECIPROCAL_MSB && reg <= RT1011_BQ_6_PARAMS_CHECK_5) ||
+		(reg >= RT1011_BQ_7_PARAMS_CHECK_1 && reg <= RT1011_BQ_10_PARAMS_CHECK_5))
 		return true;
 
 	return false;
@@ -1315,6 +1311,57 @@ static int rt1011_r0_load_info(struct snd_kcontrol *kcontrol,
 	.put = rt1011_r0_load_mode_put \
 }
 
+static const char * const rt1011_i2s_ref[] = {
+	"None", "Left Channel", "Right Channel"
+};
+
+static SOC_ENUM_SINGLE_DECL(rt1011_i2s_ref_enum, 0, 0,
+	rt1011_i2s_ref);
+
+static int rt1011_i2s_ref_put(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component =
+		snd_soc_kcontrol_component(kcontrol);
+	struct rt1011_priv *rt1011 =
+		snd_soc_component_get_drvdata(component);
+	int i2s_ref_ch = ucontrol->value.integer.value[0];
+
+	switch (i2s_ref_ch) {
+	case RT1011_I2S_REF_LEFT_CH:
+		regmap_write(rt1011->regmap, RT1011_TDM_TOTAL_SET, 0x0240);
+		regmap_write(rt1011->regmap, RT1011_TDM1_SET_2, 0x8);
+		regmap_write(rt1011->regmap, RT1011_TDM1_SET_1, 0x1022);
+		regmap_write(rt1011->regmap, RT1011_ADCDAT_OUT_SOURCE, 0x4);
+		break;
+	case RT1011_I2S_REF_RIGHT_CH:
+		regmap_write(rt1011->regmap, RT1011_TDM_TOTAL_SET, 0x0240);
+		regmap_write(rt1011->regmap, RT1011_TDM1_SET_2, 0x8);
+		regmap_write(rt1011->regmap, RT1011_TDM1_SET_1, 0x10a2);
+		regmap_write(rt1011->regmap, RT1011_ADCDAT_OUT_SOURCE, 0x4);
+		break;
+	default:
+		dev_info(component->dev, "I2S Reference: Do nothing\n");
+	}
+
+	rt1011->i2s_ref = ucontrol->value.integer.value[0];
+
+	return 0;
+}
+
+static int rt1011_i2s_ref_get(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component =
+		snd_soc_kcontrol_component(kcontrol);
+	struct rt1011_priv *rt1011 =
+		snd_soc_component_get_drvdata(component);
+
+	ucontrol->value.integer.value[0] = rt1011->i2s_ref;
+
+	return 0;
+}
+
 static const struct snd_kcontrol_new rt1011_snd_controls[] = {
 	/* I2S Data In Selection */
 	SOC_ENUM("DIN Source", rt1011_din_source_enum),
@@ -1353,6 +1400,9 @@ static const struct snd_kcontrol_new rt1011_snd_controls[] = {
 	/* R0 temperature */
 	SOC_SINGLE("R0 Temperature", RT1011_STP_INITIAL_RESISTANCE_TEMP,
 		2, 255, 0),
+	/* I2S Reference */
+	SOC_ENUM_EXT("I2S Reference", rt1011_i2s_ref_enum,
+		rt1011_i2s_ref_get, rt1011_i2s_ref_put),
 };
 
 static int rt1011_is_sys_clk_from_pll(struct snd_soc_dapm_widget *source,
@@ -1782,8 +1832,9 @@ static int rt1011_set_component_pll(struct snd_soc_component *component,
 		pll_code.n_code, pll_code.k_code);
 
 	snd_soc_component_write(component, RT1011_PLL_1,
-		(pll_code.m_bp ? 0 : pll_code.m_code) << RT1011_PLL1_QM_SFT |
-		pll_code.m_bp << RT1011_PLL1_BPM_SFT | pll_code.n_code);
+		((pll_code.m_bp ? 0 : pll_code.m_code) << RT1011_PLL1_QM_SFT) |
+		(pll_code.m_bp << RT1011_PLL1_BPM_SFT) |
+		pll_code.n_code);
 	snd_soc_component_write(component, RT1011_PLL_2,
 		pll_code.k_code);
 
@@ -1991,10 +2042,10 @@ static int rt1011_set_tdm_slot(struct snd_soc_dai *dai,
 		RT1011_TDM_I2S_DOCK_EN_1_MASK, tdm_en);
 	snd_soc_component_update_bits(component, RT1011_TDM2_SET_2,
 		RT1011_TDM_I2S_DOCK_EN_2_MASK, tdm_en);
-	if (tx_slotnum)
-		snd_soc_component_update_bits(component, RT1011_TDM_TOTAL_SET,
-			RT1011_ADCDAT1_PIN_CONFIG | RT1011_ADCDAT2_PIN_CONFIG,
-			RT1011_ADCDAT1_OUTPUT | RT1011_ADCDAT2_OUTPUT);
+
+	snd_soc_component_update_bits(component, RT1011_TDM_TOTAL_SET,
+		RT1011_ADCDAT1_PIN_CONFIG | RT1011_ADCDAT2_PIN_CONFIG,
+		RT1011_ADCDAT1_OUTPUT | RT1011_ADCDAT2_OUTPUT);
 
 _set_tdm_err_:
 	snd_soc_dapm_mutex_unlock(dapm);
@@ -2151,7 +2202,7 @@ MODULE_DEVICE_TABLE(of, rt1011_of_match);
 #endif
 
 #ifdef CONFIG_ACPI
-static struct acpi_device_id rt1011_acpi_match[] = {
+static const struct acpi_device_id rt1011_acpi_match[] = {
 	{"10EC1011", 0,},
 	{},
 };
@@ -2239,18 +2290,9 @@ static int rt1011_calibrate(struct rt1011_priv *rt1011, unsigned char cali_flag)
 	dc_offset |= (value & 0xffff);
 	dev_info(dev, "Gain1 offset=0x%x\n", dc_offset);
 
-	/* check the package info. */
-	regmap_read(rt1011->regmap, RT1011_EFUSE_MATCH_DONE, &value);
-	if (value & 0x4)
-		rt1011->pack_id = 1;
-
 	if (cali_flag) {
 
-		if (rt1011->pack_id)
-			regmap_write(rt1011->regmap, RT1011_ADC_SET_1, 0x292c);
-		else
-			regmap_write(rt1011->regmap, RT1011_ADC_SET_1, 0x2925);
-
+		regmap_write(rt1011->regmap, RT1011_ADC_SET_1, 0x2925);
 		/* Class D on */
 		regmap_write(rt1011->regmap, RT1011_CLASS_D_POS, 0x010e);
 		regmap_write(rt1011->regmap,
@@ -2376,10 +2418,7 @@ static void rt1011_calibration_work(struct work_struct *work)
 		rt1011_r0_load(rt1011);
 	}
 
-	if (rt1011->pack_id)
-		snd_soc_component_write(component, RT1011_ADC_SET_1, 0x292c);
-	else
-		snd_soc_component_write(component, RT1011_ADC_SET_1, 0x2925);
+	snd_soc_component_write(component, RT1011_ADC_SET_1, 0x2925);
 }
 
 static int rt1011_parse_dp(struct rt1011_priv *rt1011, struct device *dev)
diff --git a/sound/soc/codecs/rt1011.h b/sound/soc/codecs/rt1011.h
index f3a9a96640f114ea4f691c295318b0226a34c822..afb2fad94216fdf172746d4c7b7072d3691d9c30 100644
--- a/sound/soc/codecs/rt1011.h
+++ b/sound/soc/codecs/rt1011.h
@@ -654,6 +654,12 @@ enum {
 	RT1011_AIFS
 };
 
+enum {
+	RT1011_I2S_REF_NONE,
+	RT1011_I2S_REF_LEFT_CH,
+	RT1011_I2S_REF_RIGHT_CH,
+};
+
 /* BiQual & DRC related settings */
 #define RT1011_BQ_DRC_NUM 128
 struct rt1011_bq_drc_params {
@@ -692,7 +698,7 @@ struct rt1011_priv {
 	unsigned int r0_reg, cali_done;
 	unsigned int r0_calib, temperature_calib;
 	int recv_spk_mode;
-	unsigned int pack_id; /* 0: WLCSP; 1: QFN */
+	unsigned int i2s_ref;
 };
 
 #endif		/* end of _RT1011_H_ */
diff --git a/sound/soc/codecs/rt1015.c b/sound/soc/codecs/rt1015.c
index ded1ef4eedf99c56a0f2eeb92b4295ac6f007eda..570c1cc09491e5b68dbbc9e06a100a4911e28a6d 100644
--- a/sound/soc/codecs/rt1015.c
+++ b/sound/soc/codecs/rt1015.c
@@ -1120,7 +1120,7 @@ MODULE_DEVICE_TABLE(of, rt1015_of_match);
 #endif
 
 #ifdef CONFIG_ACPI
-static struct acpi_device_id rt1015_acpi_match[] = {
+static const struct acpi_device_id rt1015_acpi_match[] = {
 	{"10EC1015", 0,},
 	{},
 };
diff --git a/sound/soc/codecs/rt1016.c b/sound/soc/codecs/rt1016.c
index 483375fc16cac0d99e756de09d4920842ceb755f..c14a809da52bba4023e2c8a03d952ec990b24374 100644
--- a/sound/soc/codecs/rt1016.c
+++ b/sound/soc/codecs/rt1016.c
@@ -623,7 +623,7 @@ MODULE_DEVICE_TABLE(of, rt1016_of_match);
 #endif
 
 #ifdef CONFIG_ACPI
-static struct acpi_device_id rt1016_acpi_match[] = {
+static const struct acpi_device_id rt1016_acpi_match[] = {
 	{"10EC1016", 0,},
 	{},
 };
diff --git a/sound/soc/codecs/rt1305.c b/sound/soc/codecs/rt1305.c
index 4e9dfd235e59abbb38bc3ab3759bf692fc6e96e9..16aa405fb8f09589bcdba201b1c6f051aa976a4f 100644
--- a/sound/soc/codecs/rt1305.c
+++ b/sound/soc/codecs/rt1305.c
@@ -975,7 +975,7 @@ MODULE_DEVICE_TABLE(of, rt1305_of_match);
 #endif
 
 #ifdef CONFIG_ACPI
-static struct acpi_device_id rt1305_acpi_match[] = {
+static const struct acpi_device_id rt1305_acpi_match[] = {
 	{"10EC1305", 0,},
 	{"10EC1306", 0,},
 	{},
diff --git a/sound/soc/codecs/rt1308.c b/sound/soc/codecs/rt1308.c
index b75931a69a1cc0bcf513a7cc053239995957d36d..76e65844543d4756483ecba29f6fd917d88285bb 100644
--- a/sound/soc/codecs/rt1308.c
+++ b/sound/soc/codecs/rt1308.c
@@ -790,7 +790,7 @@ MODULE_DEVICE_TABLE(of, rt1308_of_match);
 #endif
 
 #ifdef CONFIG_ACPI
-static struct acpi_device_id rt1308_acpi_match[] = {
+static const struct acpi_device_id rt1308_acpi_match[] = {
 	{ "10EC1308", 0, },
 	{ },
 };
diff --git a/sound/soc/mediatek/Kconfig b/sound/soc/mediatek/Kconfig
index 955b39567dec713abae7f9bb77f29c5c3c7222c1..29cd3b9d1fda177e4042a2b6727d000db4d445a5 100644
--- a/sound/soc/mediatek/Kconfig
+++ b/sound/soc/mediatek/Kconfig
@@ -209,3 +209,18 @@ config SND_SOC_MT8195_MT6359_RT1019_RT5682
 	  with the MT6359 RT1019 RT5682 audio codec.
 	  Select Y if you have such device.
 	  If unsure select "N".
+
+config SND_SOC_MT8195_MT6359_RT1011_RT5682
+	tristate "ASoC Audio driver for MT8195 with MT6359 RT1011 RT5682 codec"
+	depends on I2C
+	depends on SND_SOC_MT8195 && MTK_PMIC_WRAP
+	select SND_SOC_MT6359
+	select SND_SOC_RT1011
+	select SND_SOC_RT5682_I2C
+	select SND_SOC_DMIC
+	select SND_SOC_HDMI_CODEC
+	help
+	  This adds ASoC driver for Mediatek MT8195 boards
+	  with the MT6359 RT1011 RT5682 audio codec.
+	  Select Y if you have such device.
+	  If unsure select "N".
diff --git a/sound/soc/mediatek/mt8195/Makefile b/sound/soc/mediatek/mt8195/Makefile
index 44775f400b4042bc7a5a369c9e6170f296c0c647..e5f0df5010b6b36e66c041f4c95703a5d5f47f51 100644
--- a/sound/soc/mediatek/mt8195/Makefile
+++ b/sound/soc/mediatek/mt8195/Makefile
@@ -13,3 +13,4 @@ obj-$(CONFIG_SND_SOC_MT8195) += snd-soc-mt8195-afe.o
 
 # machine driver
 obj-$(CONFIG_SND_SOC_MT8195_MT6359_RT1019_RT5682) += mt8195-mt6359-rt1019-rt5682.o
+obj-$(CONFIG_SND_SOC_MT8195_MT6359_RT1011_RT5682) += mt8195-mt6359-rt1011-rt5682.o
diff --git a/sound/soc/mediatek/mt8195/mt8195-afe-pcm.c b/sound/soc/mediatek/mt8195/mt8195-afe-pcm.c
index 6635c3f72eccc02d1d964509880ad51e641ffb4c..27cc2efbc20688b6465de238271c5918ec08fb2b 100644
--- a/sound/soc/mediatek/mt8195/mt8195-afe-pcm.c
+++ b/sound/soc/mediatek/mt8195/mt8195-afe-pcm.c
@@ -3188,6 +3188,10 @@ static int mt8195_afe_pcm_dev_probe(struct platform_device *pdev)
 		goto err_pm_put;
 	}
 
+#if IS_ENABLED(CONFIG_SND_SOC_SOF_MT8195)
+	mt8195_afe_enable_main_clock(afe);
+#endif
+
 	/* register component */
 	ret = devm_snd_soc_register_component(dev, &mt8195_afe_component,
 					      NULL, 0);
diff --git a/sound/soc/mediatek/mt8195/mt8195-audsys-clk.c b/sound/soc/mediatek/mt8195/mt8195-audsys-clk.c
index 740aa6ddda0ec71ce18844d9815634e3b386af2b..e0670e0dbd5b0d2f5a7adb0ee00686e9f0ff7351 100644
--- a/sound/soc/mediatek/mt8195/mt8195-audsys-clk.c
+++ b/sound/soc/mediatek/mt8195/mt8195-audsys-clk.c
@@ -59,93 +59,93 @@ struct afe_gate {
 
 static const struct afe_gate aud_clks[CLK_AUD_NR_CLK] = {
 	/* AUD0 */
-	GATE_AUD0(CLK_AUD_AFE, "aud_afe", "a1sys_hp_sel", 2),
-	GATE_AUD0(CLK_AUD_LRCK_CNT, "aud_lrck_cnt", "a1sys_hp_sel", 4),
-	GATE_AUD0(CLK_AUD_SPDIFIN_TUNER_APLL, "aud_spdifin_tuner_apll", "apll4_sel", 10),
-	GATE_AUD0(CLK_AUD_SPDIFIN_TUNER_DBG, "aud_spdifin_tuner_dbg", "apll4_sel", 11),
-	GATE_AUD0(CLK_AUD_UL_TML, "aud_ul_tml", "a1sys_hp_sel", 18),
-	GATE_AUD0(CLK_AUD_APLL1_TUNER, "aud_apll1_tuner", "apll1_sel", 19),
-	GATE_AUD0(CLK_AUD_APLL2_TUNER, "aud_apll2_tuner", "apll2_sel", 20),
-	GATE_AUD0(CLK_AUD_TOP0_SPDF, "aud_top0_spdf", "aud_iec_sel", 21),
-	GATE_AUD0(CLK_AUD_APLL, "aud_apll", "apll1_sel", 23),
-	GATE_AUD0(CLK_AUD_APLL2, "aud_apll2", "apll2_sel", 24),
-	GATE_AUD0(CLK_AUD_DAC, "aud_dac", "a1sys_hp_sel", 25),
-	GATE_AUD0(CLK_AUD_DAC_PREDIS, "aud_dac_predis", "a1sys_hp_sel", 26),
-	GATE_AUD0(CLK_AUD_TML, "aud_tml", "a1sys_hp_sel", 27),
-	GATE_AUD0(CLK_AUD_ADC, "aud_adc", "a1sys_hp_sel", 28),
-	GATE_AUD0(CLK_AUD_DAC_HIRES, "aud_dac_hires", "audio_h_sel", 31),
+	GATE_AUD0(CLK_AUD_AFE, "aud_afe", "top_a1sys_hp", 2),
+	GATE_AUD0(CLK_AUD_LRCK_CNT, "aud_lrck_cnt", "top_a1sys_hp", 4),
+	GATE_AUD0(CLK_AUD_SPDIFIN_TUNER_APLL, "aud_spdifin_tuner_apll", "top_apll4", 10),
+	GATE_AUD0(CLK_AUD_SPDIFIN_TUNER_DBG, "aud_spdifin_tuner_dbg", "top_apll4", 11),
+	GATE_AUD0(CLK_AUD_UL_TML, "aud_ul_tml", "top_a1sys_hp", 18),
+	GATE_AUD0(CLK_AUD_APLL1_TUNER, "aud_apll1_tuner", "top_apll1", 19),
+	GATE_AUD0(CLK_AUD_APLL2_TUNER, "aud_apll2_tuner", "top_apll2", 20),
+	GATE_AUD0(CLK_AUD_TOP0_SPDF, "aud_top0_spdf", "top_aud_iec_clk", 21),
+	GATE_AUD0(CLK_AUD_APLL, "aud_apll", "top_apll1", 23),
+	GATE_AUD0(CLK_AUD_APLL2, "aud_apll2", "top_apll2", 24),
+	GATE_AUD0(CLK_AUD_DAC, "aud_dac", "top_a1sys_hp", 25),
+	GATE_AUD0(CLK_AUD_DAC_PREDIS, "aud_dac_predis", "top_a1sys_hp", 26),
+	GATE_AUD0(CLK_AUD_TML, "aud_tml", "top_a1sys_hp", 27),
+	GATE_AUD0(CLK_AUD_ADC, "aud_adc", "top_a1sys_hp", 28),
+	GATE_AUD0(CLK_AUD_DAC_HIRES, "aud_dac_hires", "top_audio_h", 31),
 
 	/* AUD1 */
-	GATE_AUD1(CLK_AUD_A1SYS_HP, "aud_a1sys_hp", "a1sys_hp_sel", 2),
-	GATE_AUD1(CLK_AUD_AFE_DMIC1, "aud_afe_dmic1", "a1sys_hp_sel", 10),
-	GATE_AUD1(CLK_AUD_AFE_DMIC2, "aud_afe_dmic2", "a1sys_hp_sel", 11),
-	GATE_AUD1(CLK_AUD_AFE_DMIC3, "aud_afe_dmic3", "a1sys_hp_sel", 12),
-	GATE_AUD1(CLK_AUD_AFE_DMIC4, "aud_afe_dmic4", "a1sys_hp_sel", 13),
-	GATE_AUD1(CLK_AUD_AFE_26M_DMIC_TM, "aud_afe_26m_dmic_tm", "a1sys_hp_sel", 14),
-	GATE_AUD1(CLK_AUD_UL_TML_HIRES, "aud_ul_tml_hires", "audio_h_sel", 16),
-	GATE_AUD1(CLK_AUD_ADC_HIRES, "aud_adc_hires", "audio_h_sel", 17),
-	GATE_AUD1(CLK_AUD_ADDA6_ADC, "aud_adda6_adc", "a1sys_hp_sel", 18),
-	GATE_AUD1(CLK_AUD_ADDA6_ADC_HIRES, "aud_adda6_adc_hires", "audio_h_sel", 19),
+	GATE_AUD1(CLK_AUD_A1SYS_HP, "aud_a1sys_hp", "top_a1sys_hp", 2),
+	GATE_AUD1(CLK_AUD_AFE_DMIC1, "aud_afe_dmic1", "top_a1sys_hp", 10),
+	GATE_AUD1(CLK_AUD_AFE_DMIC2, "aud_afe_dmic2", "top_a1sys_hp", 11),
+	GATE_AUD1(CLK_AUD_AFE_DMIC3, "aud_afe_dmic3", "top_a1sys_hp", 12),
+	GATE_AUD1(CLK_AUD_AFE_DMIC4, "aud_afe_dmic4", "top_a1sys_hp", 13),
+	GATE_AUD1(CLK_AUD_AFE_26M_DMIC_TM, "aud_afe_26m_dmic_tm", "top_a1sys_hp", 14),
+	GATE_AUD1(CLK_AUD_UL_TML_HIRES, "aud_ul_tml_hires", "top_audio_h", 16),
+	GATE_AUD1(CLK_AUD_ADC_HIRES, "aud_adc_hires", "top_audio_h", 17),
+	GATE_AUD1(CLK_AUD_ADDA6_ADC, "aud_adda6_adc", "top_a1sys_hp", 18),
+	GATE_AUD1(CLK_AUD_ADDA6_ADC_HIRES, "aud_adda6_adc_hires", "top_audio_h", 19),
 
 	/* AUD3 */
-	GATE_AUD3(CLK_AUD_LINEIN_TUNER, "aud_linein_tuner", "apll5_sel", 5),
-	GATE_AUD3(CLK_AUD_EARC_TUNER, "aud_earc_tuner", "apll3_sel", 7),
+	GATE_AUD3(CLK_AUD_LINEIN_TUNER, "aud_linein_tuner", "top_apll5", 5),
+	GATE_AUD3(CLK_AUD_EARC_TUNER, "aud_earc_tuner", "top_apll3", 7),
 
 	/* AUD4 */
-	GATE_AUD4(CLK_AUD_I2SIN, "aud_i2sin", "a1sys_hp_sel", 0),
-	GATE_AUD4(CLK_AUD_TDM_IN, "aud_tdm_in", "a1sys_hp_sel", 1),
-	GATE_AUD4(CLK_AUD_I2S_OUT, "aud_i2s_out", "a1sys_hp_sel", 6),
-	GATE_AUD4(CLK_AUD_TDM_OUT, "aud_tdm_out", "a1sys_hp_sel", 7),
-	GATE_AUD4(CLK_AUD_HDMI_OUT, "aud_hdmi_out", "a1sys_hp_sel", 8),
-	GATE_AUD4(CLK_AUD_ASRC11, "aud_asrc11", "a1sys_hp_sel", 16),
-	GATE_AUD4(CLK_AUD_ASRC12, "aud_asrc12", "a1sys_hp_sel", 17),
+	GATE_AUD4(CLK_AUD_I2SIN, "aud_i2sin", "top_a1sys_hp", 0),
+	GATE_AUD4(CLK_AUD_TDM_IN, "aud_tdm_in", "top_a1sys_hp", 1),
+	GATE_AUD4(CLK_AUD_I2S_OUT, "aud_i2s_out", "top_a1sys_hp", 6),
+	GATE_AUD4(CLK_AUD_TDM_OUT, "aud_tdm_out", "top_a1sys_hp", 7),
+	GATE_AUD4(CLK_AUD_HDMI_OUT, "aud_hdmi_out", "top_a1sys_hp", 8),
+	GATE_AUD4(CLK_AUD_ASRC11, "aud_asrc11", "top_a1sys_hp", 16),
+	GATE_AUD4(CLK_AUD_ASRC12, "aud_asrc12", "top_a1sys_hp", 17),
 	GATE_AUD4(CLK_AUD_MULTI_IN, "aud_multi_in", "mphone_slave_b", 19),
-	GATE_AUD4(CLK_AUD_INTDIR, "aud_intdir", "intdir_sel", 20),
-	GATE_AUD4(CLK_AUD_A1SYS, "aud_a1sys", "a1sys_hp_sel", 21),
-	GATE_AUD4(CLK_AUD_A2SYS, "aud_a2sys", "a2sys_sel", 22),
-	GATE_AUD4(CLK_AUD_PCMIF, "aud_pcmif", "a1sys_hp_sel", 24),
-	GATE_AUD4(CLK_AUD_A3SYS, "aud_a3sys", "a3sys_sel", 30),
-	GATE_AUD4(CLK_AUD_A4SYS, "aud_a4sys", "a4sys_sel", 31),
+	GATE_AUD4(CLK_AUD_INTDIR, "aud_intdir", "top_intdir", 20),
+	GATE_AUD4(CLK_AUD_A1SYS, "aud_a1sys", "top_a1sys_hp", 21),
+	GATE_AUD4(CLK_AUD_A2SYS, "aud_a2sys", "top_a2sys_hf", 22),
+	GATE_AUD4(CLK_AUD_PCMIF, "aud_pcmif", "top_a1sys_hp", 24),
+	GATE_AUD4(CLK_AUD_A3SYS, "aud_a3sys", "top_a3sys_hf", 30),
+	GATE_AUD4(CLK_AUD_A4SYS, "aud_a4sys", "top_a4sys_hf", 31),
 
 	/* AUD5 */
-	GATE_AUD5(CLK_AUD_MEMIF_UL1, "aud_memif_ul1", "a1sys_hp_sel", 0),
-	GATE_AUD5(CLK_AUD_MEMIF_UL2, "aud_memif_ul2", "a1sys_hp_sel", 1),
-	GATE_AUD5(CLK_AUD_MEMIF_UL3, "aud_memif_ul3", "a1sys_hp_sel", 2),
-	GATE_AUD5(CLK_AUD_MEMIF_UL4, "aud_memif_ul4", "a1sys_hp_sel", 3),
-	GATE_AUD5(CLK_AUD_MEMIF_UL5, "aud_memif_ul5", "a1sys_hp_sel", 4),
-	GATE_AUD5(CLK_AUD_MEMIF_UL6, "aud_memif_ul6", "a1sys_hp_sel", 5),
-	GATE_AUD5(CLK_AUD_MEMIF_UL8, "aud_memif_ul8", "a1sys_hp_sel", 7),
-	GATE_AUD5(CLK_AUD_MEMIF_UL9, "aud_memif_ul9", "a1sys_hp_sel", 8),
-	GATE_AUD5(CLK_AUD_MEMIF_UL10, "aud_memif_ul10", "a1sys_hp_sel", 9),
-	GATE_AUD5(CLK_AUD_MEMIF_DL2, "aud_memif_dl2", "a1sys_hp_sel", 18),
-	GATE_AUD5(CLK_AUD_MEMIF_DL3, "aud_memif_dl3", "a1sys_hp_sel", 19),
-	GATE_AUD5(CLK_AUD_MEMIF_DL6, "aud_memif_dl6", "a1sys_hp_sel", 22),
-	GATE_AUD5(CLK_AUD_MEMIF_DL7, "aud_memif_dl7", "a1sys_hp_sel", 23),
-	GATE_AUD5(CLK_AUD_MEMIF_DL8, "aud_memif_dl8", "a1sys_hp_sel", 24),
-	GATE_AUD5(CLK_AUD_MEMIF_DL10, "aud_memif_dl10", "a1sys_hp_sel", 26),
-	GATE_AUD5(CLK_AUD_MEMIF_DL11, "aud_memif_dl11", "a1sys_hp_sel", 27),
+	GATE_AUD5(CLK_AUD_MEMIF_UL1, "aud_memif_ul1", "top_a1sys_hp", 0),
+	GATE_AUD5(CLK_AUD_MEMIF_UL2, "aud_memif_ul2", "top_a1sys_hp", 1),
+	GATE_AUD5(CLK_AUD_MEMIF_UL3, "aud_memif_ul3", "top_a1sys_hp", 2),
+	GATE_AUD5(CLK_AUD_MEMIF_UL4, "aud_memif_ul4", "top_a1sys_hp", 3),
+	GATE_AUD5(CLK_AUD_MEMIF_UL5, "aud_memif_ul5", "top_a1sys_hp", 4),
+	GATE_AUD5(CLK_AUD_MEMIF_UL6, "aud_memif_ul6", "top_a1sys_hp", 5),
+	GATE_AUD5(CLK_AUD_MEMIF_UL8, "aud_memif_ul8", "top_a1sys_hp", 7),
+	GATE_AUD5(CLK_AUD_MEMIF_UL9, "aud_memif_ul9", "top_a1sys_hp", 8),
+	GATE_AUD5(CLK_AUD_MEMIF_UL10, "aud_memif_ul10", "top_a1sys_hp", 9),
+	GATE_AUD5(CLK_AUD_MEMIF_DL2, "aud_memif_dl2", "top_a1sys_hp", 18),
+	GATE_AUD5(CLK_AUD_MEMIF_DL3, "aud_memif_dl3", "top_a1sys_hp", 19),
+	GATE_AUD5(CLK_AUD_MEMIF_DL6, "aud_memif_dl6", "top_a1sys_hp", 22),
+	GATE_AUD5(CLK_AUD_MEMIF_DL7, "aud_memif_dl7", "top_a1sys_hp", 23),
+	GATE_AUD5(CLK_AUD_MEMIF_DL8, "aud_memif_dl8", "top_a1sys_hp", 24),
+	GATE_AUD5(CLK_AUD_MEMIF_DL10, "aud_memif_dl10", "top_a1sys_hp", 26),
+	GATE_AUD5(CLK_AUD_MEMIF_DL11, "aud_memif_dl11", "top_a1sys_hp", 27),
 
 	/* AUD6 */
-	GATE_AUD6(CLK_AUD_GASRC0, "aud_gasrc0", "asm_h_sel", 0),
-	GATE_AUD6(CLK_AUD_GASRC1, "aud_gasrc1", "asm_h_sel", 1),
-	GATE_AUD6(CLK_AUD_GASRC2, "aud_gasrc2", "asm_h_sel", 2),
-	GATE_AUD6(CLK_AUD_GASRC3, "aud_gasrc3", "asm_h_sel", 3),
-	GATE_AUD6(CLK_AUD_GASRC4, "aud_gasrc4", "asm_h_sel", 4),
-	GATE_AUD6(CLK_AUD_GASRC5, "aud_gasrc5", "asm_h_sel", 5),
-	GATE_AUD6(CLK_AUD_GASRC6, "aud_gasrc6", "asm_h_sel", 6),
-	GATE_AUD6(CLK_AUD_GASRC7, "aud_gasrc7", "asm_h_sel", 7),
-	GATE_AUD6(CLK_AUD_GASRC8, "aud_gasrc8", "asm_h_sel", 8),
-	GATE_AUD6(CLK_AUD_GASRC9, "aud_gasrc9", "asm_h_sel", 9),
-	GATE_AUD6(CLK_AUD_GASRC10, "aud_gasrc10", "asm_h_sel", 10),
-	GATE_AUD6(CLK_AUD_GASRC11, "aud_gasrc11", "asm_h_sel", 11),
-	GATE_AUD6(CLK_AUD_GASRC12, "aud_gasrc12", "asm_h_sel", 12),
-	GATE_AUD6(CLK_AUD_GASRC13, "aud_gasrc13", "asm_h_sel", 13),
-	GATE_AUD6(CLK_AUD_GASRC14, "aud_gasrc14", "asm_h_sel", 14),
-	GATE_AUD6(CLK_AUD_GASRC15, "aud_gasrc15", "asm_h_sel", 15),
-	GATE_AUD6(CLK_AUD_GASRC16, "aud_gasrc16", "asm_h_sel", 16),
-	GATE_AUD6(CLK_AUD_GASRC17, "aud_gasrc17", "asm_h_sel", 17),
-	GATE_AUD6(CLK_AUD_GASRC18, "aud_gasrc18", "asm_h_sel", 18),
-	GATE_AUD6(CLK_AUD_GASRC19, "aud_gasrc19", "asm_h_sel", 19),
+	GATE_AUD6(CLK_AUD_GASRC0, "aud_gasrc0", "top_asm_h", 0),
+	GATE_AUD6(CLK_AUD_GASRC1, "aud_gasrc1", "top_asm_h", 1),
+	GATE_AUD6(CLK_AUD_GASRC2, "aud_gasrc2", "top_asm_h", 2),
+	GATE_AUD6(CLK_AUD_GASRC3, "aud_gasrc3", "top_asm_h", 3),
+	GATE_AUD6(CLK_AUD_GASRC4, "aud_gasrc4", "top_asm_h", 4),
+	GATE_AUD6(CLK_AUD_GASRC5, "aud_gasrc5", "top_asm_h", 5),
+	GATE_AUD6(CLK_AUD_GASRC6, "aud_gasrc6", "top_asm_h", 6),
+	GATE_AUD6(CLK_AUD_GASRC7, "aud_gasrc7", "top_asm_h", 7),
+	GATE_AUD6(CLK_AUD_GASRC8, "aud_gasrc8", "top_asm_h", 8),
+	GATE_AUD6(CLK_AUD_GASRC9, "aud_gasrc9", "top_asm_h", 9),
+	GATE_AUD6(CLK_AUD_GASRC10, "aud_gasrc10", "top_asm_h", 10),
+	GATE_AUD6(CLK_AUD_GASRC11, "aud_gasrc11", "top_asm_h", 11),
+	GATE_AUD6(CLK_AUD_GASRC12, "aud_gasrc12", "top_asm_h", 12),
+	GATE_AUD6(CLK_AUD_GASRC13, "aud_gasrc13", "top_asm_h", 13),
+	GATE_AUD6(CLK_AUD_GASRC14, "aud_gasrc14", "top_asm_h", 14),
+	GATE_AUD6(CLK_AUD_GASRC15, "aud_gasrc15", "top_asm_h", 15),
+	GATE_AUD6(CLK_AUD_GASRC16, "aud_gasrc16", "top_asm_h", 16),
+	GATE_AUD6(CLK_AUD_GASRC17, "aud_gasrc17", "top_asm_h", 17),
+	GATE_AUD6(CLK_AUD_GASRC18, "aud_gasrc18", "top_asm_h", 18),
+	GATE_AUD6(CLK_AUD_GASRC19, "aud_gasrc19", "top_asm_h", 19),
 };
 
 int mt8195_audsys_clk_register(struct mtk_base_afe *afe)
diff --git a/sound/soc/mediatek/mt8195/mt8195-mt6359-rt1011-rt5682.c b/sound/soc/mediatek/mt8195/mt8195-mt6359-rt1011-rt5682.c
new file mode 100644
index 0000000000000000000000000000000000000000..a84ba77d6432f8e67319e097dbfbcdc0f397aba5
--- /dev/null
+++ b/sound/soc/mediatek/mt8195/mt8195-mt6359-rt1011-rt5682.c
@@ -0,0 +1,1140 @@
+// SPDX-License-Identifier: GPL-2.0
+//
+// mt8195-mt6359-rt1011-rt5682.c  --
+//	MT8195-MT6359-RT1011-RT6358 ALSA SoC machine driver
+//
+// Copyright (c) 2021 MediaTek Inc.
+// Author: Trevor Wu <trevor.wu@mediatek.com>
+//
+
+#include <linux/input.h>
+#include <linux/module.h>
+#include <linux/pm_runtime.h>
+#include <sound/jack.h>
+#include <sound/pcm_params.h>
+#include <sound/rt5682.h>
+#include <sound/soc.h>
+#include "../../codecs/mt6359.h"
+#include "../../codecs/rt1011.h"
+#include "../../codecs/rt5682.h"
+#include "../common/mtk-afe-platform-driver.h"
+#include "mt8195-afe-common.h"
+
+#define RT1011_CODEC_DAI	"rt1011-aif"
+#define RT1011_DEV0_NAME	"rt1011.2-0038"
+#define RT1011_DEV1_NAME	"rt1011.2-0039"
+
+#define RT5682_CODEC_DAI	"rt5682-aif1"
+#define RT5682_DEV0_NAME	"rt5682.2-001a"
+
+struct mt8195_mt6359_rt1011_rt5682_priv {
+	struct snd_soc_jack headset_jack;
+	struct snd_soc_jack dp_jack;
+	struct snd_soc_jack hdmi_jack;
+};
+
+static const struct snd_soc_dapm_widget
+mt8195_mt6359_rt1011_rt5682_widgets[] = {
+	SND_SOC_DAPM_SPK("Left Speaker", NULL),
+	SND_SOC_DAPM_SPK("Right Speaker", NULL),
+	SND_SOC_DAPM_HP("Headphone Jack", NULL),
+	SND_SOC_DAPM_MIC("Headset Mic", NULL),
+};
+
+static const struct snd_soc_dapm_route mt8195_mt6359_rt1011_rt5682_routes[] = {
+	/* speaker */
+	{ "Left Speaker", NULL, "Left SPO" },
+	{ "Right Speaker", NULL, "Right SPO" },
+	/* headset */
+	{ "Headphone Jack", NULL, "HPOL" },
+	{ "Headphone Jack", NULL, "HPOR" },
+	{ "IN1P", NULL, "Headset Mic" },
+};
+
+static const struct snd_kcontrol_new mt8195_mt6359_rt1011_rt5682_controls[] = {
+	SOC_DAPM_PIN_SWITCH("Left Speaker"),
+	SOC_DAPM_PIN_SWITCH("Right Speaker"),
+	SOC_DAPM_PIN_SWITCH("Headphone Jack"),
+	SOC_DAPM_PIN_SWITCH("Headset Mic"),
+};
+
+static int mt8195_rt5682_etdm_hw_params(struct snd_pcm_substream *substream,
+					struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_card *card = rtd->card;
+	struct snd_soc_dai *cpu_dai = asoc_rtd_to_cpu(rtd, 0);
+	struct snd_soc_dai *codec_dai = asoc_rtd_to_codec(rtd, 0);
+	unsigned int rate = params_rate(params);
+	unsigned int mclk_fs_ratio = 128;
+	unsigned int mclk_fs = rate * mclk_fs_ratio;
+	int bitwidth;
+	int ret;
+
+	bitwidth = snd_pcm_format_width(params_format(params));
+	if (bitwidth < 0) {
+		dev_err(card->dev, "invalid bit width: %d\n", bitwidth);
+		return bitwidth;
+	}
+
+	ret = snd_soc_dai_set_tdm_slot(codec_dai, 0x00, 0x0, 0x2, bitwidth);
+	if (ret) {
+		dev_err(card->dev, "failed to set tdm slot\n");
+		return ret;
+	}
+
+	ret = snd_soc_dai_set_pll(codec_dai, RT5682_PLL1,
+				  RT5682_PLL1_S_BCLK1,
+				  params_rate(params) * 64,
+				  params_rate(params) * 512);
+	if (ret) {
+		dev_err(card->dev, "failed to set pll\n");
+		return ret;
+	}
+
+	ret = snd_soc_dai_set_sysclk(codec_dai,
+				     RT5682_SCLK_S_PLL1,
+				     params_rate(params) * 512,
+				     SND_SOC_CLOCK_IN);
+	if (ret) {
+		dev_err(card->dev, "failed to set sysclk\n");
+		return ret;
+	}
+
+	return snd_soc_dai_set_sysclk(cpu_dai, 0, mclk_fs, SND_SOC_CLOCK_OUT);
+}
+
+static const struct snd_soc_ops mt8195_rt5682_etdm_ops = {
+	.hw_params = mt8195_rt5682_etdm_hw_params,
+};
+
+static int mt8195_rt1011_etdm_hw_params(struct snd_pcm_substream *substream,
+					struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);
+	struct snd_soc_dai *codec_dai;
+	struct snd_soc_card *card = rtd->card;
+	int srate, i, ret = 0;
+
+	srate = params_rate(params);
+
+	for_each_rtd_codec_dais(rtd, i, codec_dai) {
+		ret = snd_soc_dai_set_pll(codec_dai, 0, RT1011_PLL1_S_BCLK,
+					  64 * srate, 256 * srate);
+		if (ret < 0) {
+			dev_err(card->dev, "codec_dai clock not set\n");
+			return ret;
+		}
+
+		ret = snd_soc_dai_set_sysclk(codec_dai,
+					     RT1011_FS_SYS_PRE_S_PLL1,
+					     256 * srate, SND_SOC_CLOCK_IN);
+		if (ret < 0) {
+			dev_err(card->dev, "codec_dai clock not set\n");
+			return ret;
+		}
+	}
+	return ret;
+}
+
+static const struct snd_soc_ops mt8195_rt1011_etdm_ops = {
+	.hw_params = mt8195_rt1011_etdm_hw_params,
+};
+
+#define CKSYS_AUD_TOP_CFG 0x032c
+#define CKSYS_AUD_TOP_MON 0x0330
+
+static int mt8195_mt6359_mtkaif_calibration(struct snd_soc_pcm_runtime *rtd)
+{
+	struct snd_soc_component *cmpnt_afe =
+		snd_soc_rtdcom_lookup(rtd, AFE_PCM_NAME);
+	struct snd_soc_component *cmpnt_codec =
+		asoc_rtd_to_codec(rtd, 0)->component;
+	struct mtk_base_afe *afe = snd_soc_component_get_drvdata(cmpnt_afe);
+	struct mt8195_afe_private *afe_priv = afe->platform_priv;
+	struct mtkaif_param *param = &afe_priv->mtkaif_params;
+	int phase;
+	unsigned int monitor;
+	int mtkaif_calibration_num_phase;
+	int test_done_1, test_done_2, test_done_3;
+	int cycle_1, cycle_2, cycle_3;
+	int prev_cycle_1, prev_cycle_2, prev_cycle_3;
+	int chosen_phase_1, chosen_phase_2, chosen_phase_3;
+	int counter;
+	bool mtkaif_calibration_ok;
+	int mtkaif_chosen_phase[MT8195_MTKAIF_MISO_NUM];
+	int mtkaif_phase_cycle[MT8195_MTKAIF_MISO_NUM];
+	int i;
+
+	dev_info(afe->dev, "%s(), start\n", __func__);
+
+	param->mtkaif_calibration_ok = false;
+	for (i = 0; i < MT8195_MTKAIF_MISO_NUM; i++) {
+		param->mtkaif_chosen_phase[i] = -1;
+		param->mtkaif_phase_cycle[i] = 0;
+		mtkaif_chosen_phase[i] = -1;
+		mtkaif_phase_cycle[i] = 0;
+	}
+
+	if (IS_ERR(afe_priv->topckgen)) {
+		dev_info(afe->dev, "%s() Cannot find topckgen controller\n",
+			 __func__);
+		return 0;
+	}
+
+	pm_runtime_get_sync(afe->dev);
+	mt6359_mtkaif_calibration_enable(cmpnt_codec);
+
+	/* set test type to synchronizer pulse */
+	regmap_update_bits(afe_priv->topckgen,
+			   CKSYS_AUD_TOP_CFG, 0xffff, 0x4);
+	mtkaif_calibration_num_phase = 42;	/* mt6359: 0 ~ 42 */
+	mtkaif_calibration_ok = true;
+
+	for (phase = 0;
+	     phase <= mtkaif_calibration_num_phase && mtkaif_calibration_ok;
+	     phase++) {
+		mt6359_set_mtkaif_calibration_phase(cmpnt_codec,
+						    phase, phase, phase);
+
+		regmap_update_bits(afe_priv->topckgen,
+				   CKSYS_AUD_TOP_CFG, 0x1, 0x1);
+
+		test_done_1 = 0;
+		test_done_2 = 0;
+		test_done_3 = 0;
+		cycle_1 = -1;
+		cycle_2 = -1;
+		cycle_3 = -1;
+		counter = 0;
+		while (!(test_done_1 & test_done_2 & test_done_3)) {
+			regmap_read(afe_priv->topckgen,
+				    CKSYS_AUD_TOP_MON, &monitor);
+			test_done_1 = (monitor >> 28) & 0x1;
+			test_done_2 = (monitor >> 29) & 0x1;
+			test_done_3 = (monitor >> 30) & 0x1;
+			if (test_done_1 == 1)
+				cycle_1 = monitor & 0xf;
+
+			if (test_done_2 == 1)
+				cycle_2 = (monitor >> 4) & 0xf;
+
+			if (test_done_3 == 1)
+				cycle_3 = (monitor >> 8) & 0xf;
+
+			/* handle if never test done */
+			if (++counter > 10000) {
+				dev_info(afe->dev, "%s(), test fail, cycle_1 %d, cycle_2 %d, cycle_3 %d, monitor 0x%x\n",
+					 __func__,
+					 cycle_1, cycle_2, cycle_3, monitor);
+				mtkaif_calibration_ok = false;
+				break;
+			}
+		}
+
+		if (phase == 0) {
+			prev_cycle_1 = cycle_1;
+			prev_cycle_2 = cycle_2;
+			prev_cycle_3 = cycle_3;
+		}
+
+		if (cycle_1 != prev_cycle_1 &&
+		    mtkaif_chosen_phase[MT8195_MTKAIF_MISO_0] < 0) {
+			mtkaif_chosen_phase[MT8195_MTKAIF_MISO_0] = phase - 1;
+			mtkaif_phase_cycle[MT8195_MTKAIF_MISO_0] = prev_cycle_1;
+		}
+
+		if (cycle_2 != prev_cycle_2 &&
+		    mtkaif_chosen_phase[MT8195_MTKAIF_MISO_1] < 0) {
+			mtkaif_chosen_phase[MT8195_MTKAIF_MISO_1] = phase - 1;
+			mtkaif_phase_cycle[MT8195_MTKAIF_MISO_1] = prev_cycle_2;
+		}
+
+		if (cycle_3 != prev_cycle_3 &&
+		    mtkaif_chosen_phase[MT8195_MTKAIF_MISO_2] < 0) {
+			mtkaif_chosen_phase[MT8195_MTKAIF_MISO_2] = phase - 1;
+			mtkaif_phase_cycle[MT8195_MTKAIF_MISO_2] = prev_cycle_3;
+		}
+
+		regmap_update_bits(afe_priv->topckgen,
+				   CKSYS_AUD_TOP_CFG, 0x1, 0x0);
+
+		if (mtkaif_chosen_phase[MT8195_MTKAIF_MISO_0] >= 0 &&
+		    mtkaif_chosen_phase[MT8195_MTKAIF_MISO_1] >= 0 &&
+		    mtkaif_chosen_phase[MT8195_MTKAIF_MISO_2] >= 0)
+			break;
+	}
+
+	if (mtkaif_chosen_phase[MT8195_MTKAIF_MISO_0] < 0) {
+		mtkaif_calibration_ok = false;
+		chosen_phase_1 = 0;
+	} else {
+		chosen_phase_1 = mtkaif_chosen_phase[MT8195_MTKAIF_MISO_0];
+	}
+
+	if (mtkaif_chosen_phase[MT8195_MTKAIF_MISO_1] < 0) {
+		mtkaif_calibration_ok = false;
+		chosen_phase_2 = 0;
+	} else {
+		chosen_phase_2 = mtkaif_chosen_phase[MT8195_MTKAIF_MISO_1];
+	}
+
+	if (mtkaif_chosen_phase[MT8195_MTKAIF_MISO_2] < 0) {
+		mtkaif_calibration_ok = false;
+		chosen_phase_3 = 0;
+	} else {
+		chosen_phase_3 = mtkaif_chosen_phase[MT8195_MTKAIF_MISO_2];
+	}
+
+	mt6359_set_mtkaif_calibration_phase(cmpnt_codec,
+					    chosen_phase_1,
+					    chosen_phase_2,
+					    chosen_phase_3);
+
+	mt6359_mtkaif_calibration_disable(cmpnt_codec);
+	pm_runtime_put(afe->dev);
+
+	param->mtkaif_calibration_ok = mtkaif_calibration_ok;
+	param->mtkaif_chosen_phase[MT8195_MTKAIF_MISO_0] = chosen_phase_1;
+	param->mtkaif_chosen_phase[MT8195_MTKAIF_MISO_1] = chosen_phase_2;
+	param->mtkaif_chosen_phase[MT8195_MTKAIF_MISO_2] = chosen_phase_3;
+	for (i = 0; i < MT8195_MTKAIF_MISO_NUM; i++)
+		param->mtkaif_phase_cycle[i] = mtkaif_phase_cycle[i];
+
+	dev_info(afe->dev, "%s(), end, calibration ok %d\n",
+		 __func__, param->mtkaif_calibration_ok);
+
+	return 0;
+}
+
+static int mt8195_mt6359_init(struct snd_soc_pcm_runtime *rtd)
+{
+	struct snd_soc_component *cmpnt_codec =
+		asoc_rtd_to_codec(rtd, 0)->component;
+
+	/* set mtkaif protocol */
+	mt6359_set_mtkaif_protocol(cmpnt_codec,
+				   MT6359_MTKAIF_PROTOCOL_2_CLK_P2);
+
+	/* mtkaif calibration */
+	mt8195_mt6359_mtkaif_calibration(rtd);
+
+	return 0;
+}
+
+static int mt8195_rt5682_init(struct snd_soc_pcm_runtime *rtd)
+{
+	struct snd_soc_component *cmpnt_codec =
+		asoc_rtd_to_codec(rtd, 0)->component;
+	struct mt8195_mt6359_rt1011_rt5682_priv *priv =
+		snd_soc_card_get_drvdata(rtd->card);
+	struct snd_soc_jack *jack = &priv->headset_jack;
+	int ret;
+
+	ret = snd_soc_card_jack_new(rtd->card, "Headset Jack",
+				    SND_JACK_HEADSET | SND_JACK_BTN_0 |
+				    SND_JACK_BTN_1 | SND_JACK_BTN_2 |
+				    SND_JACK_BTN_3,
+				    jack, NULL, 0);
+	if (ret) {
+		dev_err(rtd->dev, "Headset Jack creation failed: %d\n", ret);
+		return ret;
+	}
+
+	snd_jack_set_key(jack->jack, SND_JACK_BTN_0, KEY_PLAYPAUSE);
+	snd_jack_set_key(jack->jack, SND_JACK_BTN_1, KEY_VOICECOMMAND);
+	snd_jack_set_key(jack->jack, SND_JACK_BTN_2, KEY_VOLUMEUP);
+	snd_jack_set_key(jack->jack, SND_JACK_BTN_3, KEY_VOLUMEDOWN);
+
+	ret = snd_soc_component_set_jack(cmpnt_codec, jack, NULL);
+	if (ret) {
+		dev_err(rtd->dev, "Headset Jack set failed: %d\n", ret);
+		return ret;
+	}
+
+	return 0;
+};
+
+static int mt8195_etdm_hw_params_fixup(struct snd_soc_pcm_runtime *rtd,
+				       struct snd_pcm_hw_params *params)
+{
+	/* fix BE i2s format to 32bit, clean param mask first */
+	snd_mask_reset_range(hw_param_mask(params, SNDRV_PCM_HW_PARAM_FORMAT),
+			     0, (__force unsigned int)SNDRV_PCM_FORMAT_LAST);
+
+	params_set_format(params, SNDRV_PCM_FORMAT_S24_LE);
+
+	return 0;
+}
+
+static int mt8195_hdmitx_dptx_startup(struct snd_pcm_substream *substream)
+{
+	static const unsigned int rates[] = {
+		48000
+	};
+	static const unsigned int channels[] = {
+		2, 4, 6, 8
+	};
+	static const struct snd_pcm_hw_constraint_list constraints_rates = {
+		.count = ARRAY_SIZE(rates),
+		.list  = rates,
+		.mask = 0,
+	};
+	static const struct snd_pcm_hw_constraint_list constraints_channels = {
+		.count = ARRAY_SIZE(channels),
+		.list  = channels,
+		.mask = 0,
+	};
+
+	struct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	int ret;
+
+	ret = snd_pcm_hw_constraint_list(runtime, 0,
+					 SNDRV_PCM_HW_PARAM_RATE,
+					 &constraints_rates);
+	if (ret < 0) {
+		dev_err(rtd->dev, "hw_constraint_list rate failed\n");
+		return ret;
+	}
+
+	ret = snd_pcm_hw_constraint_list(runtime, 0,
+					 SNDRV_PCM_HW_PARAM_CHANNELS,
+					 &constraints_channels);
+	if (ret < 0) {
+		dev_err(rtd->dev, "hw_constraint_list channel failed\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+static const struct snd_soc_ops mt8195_hdmitx_dptx_playback_ops = {
+	.startup = mt8195_hdmitx_dptx_startup,
+};
+
+static int mt8195_dptx_hw_params(struct snd_pcm_substream *substream,
+				 struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *cpu_dai = asoc_rtd_to_cpu(rtd, 0);
+	unsigned int rate = params_rate(params);
+	unsigned int mclk_fs_ratio = 256;
+	unsigned int mclk_fs = rate * mclk_fs_ratio;
+
+	return snd_soc_dai_set_sysclk(cpu_dai, 0, mclk_fs,
+				      SND_SOC_CLOCK_OUT);
+}
+
+static struct snd_soc_ops mt8195_dptx_ops = {
+	.hw_params = mt8195_dptx_hw_params,
+};
+
+static int mt8195_dptx_codec_init(struct snd_soc_pcm_runtime *rtd)
+{
+	struct mt8195_mt6359_rt1011_rt5682_priv *priv =
+		snd_soc_card_get_drvdata(rtd->card);
+	struct snd_soc_component *cmpnt_codec =
+		asoc_rtd_to_codec(rtd, 0)->component;
+	int ret = 0;
+
+	ret = snd_soc_card_jack_new(rtd->card, "DP Jack", SND_JACK_LINEOUT,
+				    &priv->dp_jack, NULL, 0);
+	if (ret)
+		return ret;
+
+	return snd_soc_component_set_jack(cmpnt_codec, &priv->dp_jack, NULL);
+}
+
+static int mt8195_hdmi_codec_init(struct snd_soc_pcm_runtime *rtd)
+{
+	struct mt8195_mt6359_rt1011_rt5682_priv *priv =
+		snd_soc_card_get_drvdata(rtd->card);
+	struct snd_soc_component *cmpnt_codec =
+		asoc_rtd_to_codec(rtd, 0)->component;
+	int ret = 0;
+
+	ret = snd_soc_card_jack_new(rtd->card, "HDMI Jack", SND_JACK_LINEOUT,
+				    &priv->hdmi_jack, NULL, 0);
+	if (ret)
+		return ret;
+
+	return snd_soc_component_set_jack(cmpnt_codec, &priv->hdmi_jack, NULL);
+}
+
+static int mt8195_hdmitx_dptx_hw_params_fixup(struct snd_soc_pcm_runtime *rtd,
+					      struct snd_pcm_hw_params *params)
+
+{
+	/* fix BE i2s format to 32bit, clean param mask first */
+	snd_mask_reset_range(hw_param_mask(params, SNDRV_PCM_HW_PARAM_FORMAT),
+			     0, (__force unsigned int)SNDRV_PCM_FORMAT_LAST);
+
+	params_set_format(params, SNDRV_PCM_FORMAT_S24_LE);
+
+	return 0;
+}
+
+static int mt8195_playback_startup(struct snd_pcm_substream *substream)
+{
+	static const unsigned int rates[] = {
+		48000
+	};
+	static const unsigned int channels[] = {
+		2
+	};
+	static const struct snd_pcm_hw_constraint_list constraints_rates = {
+		.count = ARRAY_SIZE(rates),
+		.list  = rates,
+		.mask = 0,
+	};
+	static const struct snd_pcm_hw_constraint_list constraints_channels = {
+		.count = ARRAY_SIZE(channels),
+		.list  = channels,
+		.mask = 0,
+	};
+
+	struct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	int ret;
+
+	ret = snd_pcm_hw_constraint_list(runtime, 0,
+					 SNDRV_PCM_HW_PARAM_RATE,
+					 &constraints_rates);
+	if (ret < 0) {
+		dev_err(rtd->dev, "hw_constraint_list rate failed\n");
+		return ret;
+	}
+
+	ret = snd_pcm_hw_constraint_list(runtime, 0,
+					 SNDRV_PCM_HW_PARAM_CHANNELS,
+					 &constraints_channels);
+	if (ret < 0) {
+		dev_err(rtd->dev, "hw_constraint_list channel failed\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+static const struct snd_soc_ops mt8195_playback_ops = {
+	.startup = mt8195_playback_startup,
+};
+
+static int mt8195_capture_startup(struct snd_pcm_substream *substream)
+{
+	static const unsigned int rates[] = {
+		48000
+	};
+	static const unsigned int channels[] = {
+		1, 2
+	};
+	static const struct snd_pcm_hw_constraint_list constraints_rates = {
+		.count = ARRAY_SIZE(rates),
+		.list  = rates,
+		.mask = 0,
+	};
+	static const struct snd_pcm_hw_constraint_list constraints_channels = {
+		.count = ARRAY_SIZE(channels),
+		.list  = channels,
+		.mask = 0,
+	};
+
+	struct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	int ret;
+
+	ret = snd_pcm_hw_constraint_list(runtime, 0,
+					 SNDRV_PCM_HW_PARAM_RATE,
+					 &constraints_rates);
+	if (ret < 0) {
+		dev_err(rtd->dev, "hw_constraint_list rate failed\n");
+		return ret;
+	}
+
+	ret = snd_pcm_hw_constraint_list(runtime, 0,
+					 SNDRV_PCM_HW_PARAM_CHANNELS,
+					 &constraints_channels);
+	if (ret < 0) {
+		dev_err(rtd->dev, "hw_constraint_list channel failed\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+static const struct snd_soc_ops mt8195_capture_ops = {
+	.startup = mt8195_capture_startup,
+};
+
+enum {
+	DAI_LINK_DL2_FE,
+	DAI_LINK_DL3_FE,
+	DAI_LINK_DL6_FE,
+	DAI_LINK_DL7_FE,
+	DAI_LINK_DL8_FE,
+	DAI_LINK_DL10_FE,
+	DAI_LINK_DL11_FE,
+	DAI_LINK_UL1_FE,
+	DAI_LINK_UL2_FE,
+	DAI_LINK_UL3_FE,
+	DAI_LINK_UL4_FE,
+	DAI_LINK_UL5_FE,
+	DAI_LINK_UL6_FE,
+	DAI_LINK_UL8_FE,
+	DAI_LINK_UL9_FE,
+	DAI_LINK_UL10_FE,
+	DAI_LINK_DL_SRC_BE,
+	DAI_LINK_DPTX_BE,
+	DAI_LINK_ETDM1_IN_BE,
+	DAI_LINK_ETDM2_IN_BE,
+	DAI_LINK_ETDM1_OUT_BE,
+	DAI_LINK_ETDM2_OUT_BE,
+	DAI_LINK_ETDM3_OUT_BE,
+	DAI_LINK_PCM1_BE,
+	DAI_LINK_UL_SRC1_BE,
+	DAI_LINK_UL_SRC2_BE,
+};
+
+/* FE */
+SND_SOC_DAILINK_DEFS(DL2_FE,
+		     DAILINK_COMP_ARRAY(COMP_CPU("DL2")),
+		     DAILINK_COMP_ARRAY(COMP_DUMMY()),
+		     DAILINK_COMP_ARRAY(COMP_EMPTY()));
+
+SND_SOC_DAILINK_DEFS(DL3_FE,
+		     DAILINK_COMP_ARRAY(COMP_CPU("DL3")),
+		     DAILINK_COMP_ARRAY(COMP_DUMMY()),
+		     DAILINK_COMP_ARRAY(COMP_EMPTY()));
+
+SND_SOC_DAILINK_DEFS(DL6_FE,
+		     DAILINK_COMP_ARRAY(COMP_CPU("DL6")),
+		     DAILINK_COMP_ARRAY(COMP_DUMMY()),
+		     DAILINK_COMP_ARRAY(COMP_EMPTY()));
+
+SND_SOC_DAILINK_DEFS(DL7_FE,
+		     DAILINK_COMP_ARRAY(COMP_CPU("DL7")),
+		     DAILINK_COMP_ARRAY(COMP_DUMMY()),
+		     DAILINK_COMP_ARRAY(COMP_EMPTY()));
+
+SND_SOC_DAILINK_DEFS(DL8_FE,
+		     DAILINK_COMP_ARRAY(COMP_CPU("DL8")),
+		     DAILINK_COMP_ARRAY(COMP_DUMMY()),
+		     DAILINK_COMP_ARRAY(COMP_EMPTY()));
+
+SND_SOC_DAILINK_DEFS(DL10_FE,
+		     DAILINK_COMP_ARRAY(COMP_CPU("DL10")),
+		     DAILINK_COMP_ARRAY(COMP_DUMMY()),
+		     DAILINK_COMP_ARRAY(COMP_EMPTY()));
+
+SND_SOC_DAILINK_DEFS(DL11_FE,
+		     DAILINK_COMP_ARRAY(COMP_CPU("DL11")),
+		     DAILINK_COMP_ARRAY(COMP_DUMMY()),
+		     DAILINK_COMP_ARRAY(COMP_EMPTY()));
+
+SND_SOC_DAILINK_DEFS(UL1_FE,
+		     DAILINK_COMP_ARRAY(COMP_CPU("UL1")),
+		     DAILINK_COMP_ARRAY(COMP_DUMMY()),
+		     DAILINK_COMP_ARRAY(COMP_EMPTY()));
+
+SND_SOC_DAILINK_DEFS(UL2_FE,
+		     DAILINK_COMP_ARRAY(COMP_CPU("UL2")),
+		     DAILINK_COMP_ARRAY(COMP_DUMMY()),
+		     DAILINK_COMP_ARRAY(COMP_EMPTY()));
+
+SND_SOC_DAILINK_DEFS(UL3_FE,
+		     DAILINK_COMP_ARRAY(COMP_CPU("UL3")),
+		     DAILINK_COMP_ARRAY(COMP_DUMMY()),
+		     DAILINK_COMP_ARRAY(COMP_EMPTY()));
+
+SND_SOC_DAILINK_DEFS(UL4_FE,
+		     DAILINK_COMP_ARRAY(COMP_CPU("UL4")),
+		     DAILINK_COMP_ARRAY(COMP_DUMMY()),
+		     DAILINK_COMP_ARRAY(COMP_EMPTY()));
+
+SND_SOC_DAILINK_DEFS(UL5_FE,
+		     DAILINK_COMP_ARRAY(COMP_CPU("UL5")),
+		     DAILINK_COMP_ARRAY(COMP_DUMMY()),
+		     DAILINK_COMP_ARRAY(COMP_EMPTY()));
+
+SND_SOC_DAILINK_DEFS(UL6_FE,
+		     DAILINK_COMP_ARRAY(COMP_CPU("UL6")),
+		     DAILINK_COMP_ARRAY(COMP_DUMMY()),
+		     DAILINK_COMP_ARRAY(COMP_EMPTY()));
+
+SND_SOC_DAILINK_DEFS(UL8_FE,
+		     DAILINK_COMP_ARRAY(COMP_CPU("UL8")),
+		     DAILINK_COMP_ARRAY(COMP_DUMMY()),
+		     DAILINK_COMP_ARRAY(COMP_EMPTY()));
+
+SND_SOC_DAILINK_DEFS(UL9_FE,
+		     DAILINK_COMP_ARRAY(COMP_CPU("UL9")),
+		     DAILINK_COMP_ARRAY(COMP_DUMMY()),
+		     DAILINK_COMP_ARRAY(COMP_EMPTY()));
+
+SND_SOC_DAILINK_DEFS(UL10_FE,
+		     DAILINK_COMP_ARRAY(COMP_CPU("UL10")),
+		     DAILINK_COMP_ARRAY(COMP_DUMMY()),
+		     DAILINK_COMP_ARRAY(COMP_EMPTY()));
+
+/* BE */
+SND_SOC_DAILINK_DEFS(DL_SRC_BE,
+		     DAILINK_COMP_ARRAY(COMP_CPU("DL_SRC")),
+		     DAILINK_COMP_ARRAY(COMP_CODEC("mt6359-sound",
+						   "mt6359-snd-codec-aif1")),
+		     DAILINK_COMP_ARRAY(COMP_EMPTY()));
+
+SND_SOC_DAILINK_DEFS(DPTX_BE,
+		     DAILINK_COMP_ARRAY(COMP_CPU("DPTX")),
+		     DAILINK_COMP_ARRAY(COMP_DUMMY()),
+		     DAILINK_COMP_ARRAY(COMP_EMPTY()));
+
+SND_SOC_DAILINK_DEFS(ETDM1_IN_BE,
+		     DAILINK_COMP_ARRAY(COMP_CPU("ETDM1_IN")),
+		     DAILINK_COMP_ARRAY(COMP_DUMMY()),
+		     DAILINK_COMP_ARRAY(COMP_EMPTY()));
+
+SND_SOC_DAILINK_DEFS(ETDM2_IN_BE,
+		     DAILINK_COMP_ARRAY(COMP_CPU("ETDM2_IN")),
+		     DAILINK_COMP_ARRAY(COMP_CODEC(RT5682_DEV0_NAME,
+						   RT5682_CODEC_DAI)),
+		     DAILINK_COMP_ARRAY(COMP_EMPTY()));
+
+SND_SOC_DAILINK_DEFS(ETDM1_OUT_BE,
+		     DAILINK_COMP_ARRAY(COMP_CPU("ETDM1_OUT")),
+		     DAILINK_COMP_ARRAY(COMP_CODEC(RT5682_DEV0_NAME,
+						   RT5682_CODEC_DAI)),
+		     DAILINK_COMP_ARRAY(COMP_EMPTY()));
+
+SND_SOC_DAILINK_DEFS(ETDM2_OUT_BE,
+		     DAILINK_COMP_ARRAY(COMP_CPU("ETDM2_OUT")),
+		     DAILINK_COMP_ARRAY(COMP_CODEC(RT1011_DEV0_NAME,
+						   RT1011_CODEC_DAI),
+					COMP_CODEC(RT1011_DEV1_NAME,
+						   RT1011_CODEC_DAI)),
+		     DAILINK_COMP_ARRAY(COMP_EMPTY()));
+
+SND_SOC_DAILINK_DEFS(ETDM3_OUT_BE,
+		     DAILINK_COMP_ARRAY(COMP_CPU("ETDM3_OUT")),
+		     DAILINK_COMP_ARRAY(COMP_DUMMY()),
+		     DAILINK_COMP_ARRAY(COMP_EMPTY()));
+
+SND_SOC_DAILINK_DEFS(PCM1_BE,
+		     DAILINK_COMP_ARRAY(COMP_CPU("PCM1")),
+		     DAILINK_COMP_ARRAY(COMP_DUMMY()),
+		     DAILINK_COMP_ARRAY(COMP_EMPTY()));
+
+SND_SOC_DAILINK_DEFS(UL_SRC1_BE,
+		     DAILINK_COMP_ARRAY(COMP_CPU("UL_SRC1")),
+		     DAILINK_COMP_ARRAY(COMP_CODEC("mt6359-sound",
+						   "mt6359-snd-codec-aif1"),
+					COMP_CODEC("dmic-codec",
+						   "dmic-hifi")),
+		     DAILINK_COMP_ARRAY(COMP_EMPTY()));
+
+SND_SOC_DAILINK_DEFS(UL_SRC2_BE,
+		     DAILINK_COMP_ARRAY(COMP_CPU("UL_SRC2")),
+		     DAILINK_COMP_ARRAY(COMP_CODEC("mt6359-sound",
+						   "mt6359-snd-codec-aif2")),
+		     DAILINK_COMP_ARRAY(COMP_EMPTY()));
+
+static struct snd_soc_dai_link mt8195_mt6359_rt1011_rt5682_dai_links[] = {
+	/* FE */
+	[DAI_LINK_DL2_FE] = {
+		.name = "DL2_FE",
+		.stream_name = "DL2 Playback",
+		.trigger = {
+			SND_SOC_DPCM_TRIGGER_POST,
+			SND_SOC_DPCM_TRIGGER_POST,
+		},
+		.dynamic = 1,
+		.dpcm_playback = 1,
+		.ops = &mt8195_playback_ops,
+		SND_SOC_DAILINK_REG(DL2_FE),
+	},
+	[DAI_LINK_DL3_FE] = {
+		.name = "DL3_FE",
+		.stream_name = "DL3 Playback",
+		.trigger = {
+			SND_SOC_DPCM_TRIGGER_POST,
+			SND_SOC_DPCM_TRIGGER_POST,
+		},
+		.dynamic = 1,
+		.dpcm_playback = 1,
+		.ops = &mt8195_playback_ops,
+		SND_SOC_DAILINK_REG(DL3_FE),
+	},
+	[DAI_LINK_DL6_FE] = {
+		.name = "DL6_FE",
+		.stream_name = "DL6 Playback",
+		.trigger = {
+			SND_SOC_DPCM_TRIGGER_POST,
+			SND_SOC_DPCM_TRIGGER_POST,
+		},
+		.dynamic = 1,
+		.dpcm_playback = 1,
+		.ops = &mt8195_playback_ops,
+		SND_SOC_DAILINK_REG(DL6_FE),
+	},
+	[DAI_LINK_DL7_FE] = {
+		.name = "DL7_FE",
+		.stream_name = "DL7 Playback",
+		.trigger = {
+			SND_SOC_DPCM_TRIGGER_PRE,
+			SND_SOC_DPCM_TRIGGER_PRE,
+		},
+		.dynamic = 1,
+		.dpcm_playback = 1,
+		SND_SOC_DAILINK_REG(DL7_FE),
+	},
+	[DAI_LINK_DL8_FE] = {
+		.name = "DL8_FE",
+		.stream_name = "DL8 Playback",
+		.trigger = {
+			SND_SOC_DPCM_TRIGGER_POST,
+			SND_SOC_DPCM_TRIGGER_POST,
+		},
+		.dynamic = 1,
+		.dpcm_playback = 1,
+		.ops = &mt8195_playback_ops,
+		SND_SOC_DAILINK_REG(DL8_FE),
+	},
+	[DAI_LINK_DL10_FE] = {
+		.name = "DL10_FE",
+		.stream_name = "DL10 Playback",
+		.trigger = {
+			SND_SOC_DPCM_TRIGGER_POST,
+			SND_SOC_DPCM_TRIGGER_POST,
+		},
+		.dynamic = 1,
+		.dpcm_playback = 1,
+		.ops = &mt8195_hdmitx_dptx_playback_ops,
+		SND_SOC_DAILINK_REG(DL10_FE),
+	},
+	[DAI_LINK_DL11_FE] = {
+		.name = "DL11_FE",
+		.stream_name = "DL11 Playback",
+		.trigger = {
+			SND_SOC_DPCM_TRIGGER_POST,
+			SND_SOC_DPCM_TRIGGER_POST,
+		},
+		.dynamic = 1,
+		.dpcm_playback = 1,
+		.ops = &mt8195_playback_ops,
+		SND_SOC_DAILINK_REG(DL11_FE),
+	},
+	[DAI_LINK_UL1_FE] = {
+		.name = "UL1_FE",
+		.stream_name = "UL1 Capture",
+		.trigger = {
+			SND_SOC_DPCM_TRIGGER_PRE,
+			SND_SOC_DPCM_TRIGGER_PRE,
+		},
+		.dynamic = 1,
+		.dpcm_capture = 1,
+		SND_SOC_DAILINK_REG(UL1_FE),
+	},
+	[DAI_LINK_UL2_FE] = {
+		.name = "UL2_FE",
+		.stream_name = "UL2 Capture",
+		.trigger = {
+			SND_SOC_DPCM_TRIGGER_POST,
+			SND_SOC_DPCM_TRIGGER_POST,
+		},
+		.dynamic = 1,
+		.dpcm_capture = 1,
+		.ops = &mt8195_capture_ops,
+		SND_SOC_DAILINK_REG(UL2_FE),
+	},
+	[DAI_LINK_UL3_FE] = {
+		.name = "UL3_FE",
+		.stream_name = "UL3 Capture",
+		.trigger = {
+			SND_SOC_DPCM_TRIGGER_POST,
+			SND_SOC_DPCM_TRIGGER_POST,
+		},
+		.dynamic = 1,
+		.dpcm_capture = 1,
+		.ops = &mt8195_capture_ops,
+		SND_SOC_DAILINK_REG(UL3_FE),
+	},
+	[DAI_LINK_UL4_FE] = {
+		.name = "UL4_FE",
+		.stream_name = "UL4 Capture",
+		.trigger = {
+			SND_SOC_DPCM_TRIGGER_POST,
+			SND_SOC_DPCM_TRIGGER_POST,
+		},
+		.dynamic = 1,
+		.dpcm_capture = 1,
+		.ops = &mt8195_capture_ops,
+		SND_SOC_DAILINK_REG(UL4_FE),
+	},
+	[DAI_LINK_UL5_FE] = {
+		.name = "UL5_FE",
+		.stream_name = "UL5 Capture",
+		.trigger = {
+			SND_SOC_DPCM_TRIGGER_POST,
+			SND_SOC_DPCM_TRIGGER_POST,
+		},
+		.dynamic = 1,
+		.dpcm_capture = 1,
+		.ops = &mt8195_capture_ops,
+		SND_SOC_DAILINK_REG(UL5_FE),
+	},
+	[DAI_LINK_UL6_FE] = {
+		.name = "UL6_FE",
+		.stream_name = "UL6 Capture",
+		.trigger = {
+			SND_SOC_DPCM_TRIGGER_PRE,
+			SND_SOC_DPCM_TRIGGER_PRE,
+		},
+		.dynamic = 1,
+		.dpcm_capture = 1,
+		SND_SOC_DAILINK_REG(UL6_FE),
+	},
+	[DAI_LINK_UL8_FE] = {
+		.name = "UL8_FE",
+		.stream_name = "UL8 Capture",
+		.trigger = {
+			SND_SOC_DPCM_TRIGGER_POST,
+			SND_SOC_DPCM_TRIGGER_POST,
+		},
+		.dynamic = 1,
+		.dpcm_capture = 1,
+		.ops = &mt8195_capture_ops,
+		SND_SOC_DAILINK_REG(UL8_FE),
+	},
+	[DAI_LINK_UL9_FE] = {
+		.name = "UL9_FE",
+		.stream_name = "UL9 Capture",
+		.trigger = {
+			SND_SOC_DPCM_TRIGGER_POST,
+			SND_SOC_DPCM_TRIGGER_POST,
+		},
+		.dynamic = 1,
+		.dpcm_capture = 1,
+		.ops = &mt8195_capture_ops,
+		SND_SOC_DAILINK_REG(UL9_FE),
+	},
+	[DAI_LINK_UL10_FE] = {
+		.name = "UL10_FE",
+		.stream_name = "UL10 Capture",
+		.trigger = {
+			SND_SOC_DPCM_TRIGGER_POST,
+			SND_SOC_DPCM_TRIGGER_POST,
+		},
+		.dynamic = 1,
+		.dpcm_capture = 1,
+		.ops = &mt8195_capture_ops,
+		SND_SOC_DAILINK_REG(UL10_FE),
+	},
+	/* BE */
+	[DAI_LINK_DL_SRC_BE] = {
+		.name = "DL_SRC_BE",
+		.init = mt8195_mt6359_init,
+		.no_pcm = 1,
+		.dpcm_playback = 1,
+		SND_SOC_DAILINK_REG(DL_SRC_BE),
+	},
+	[DAI_LINK_DPTX_BE] = {
+		.name = "DPTX_BE",
+		.no_pcm = 1,
+		.dpcm_playback = 1,
+		.ops = &mt8195_dptx_ops,
+		.be_hw_params_fixup = mt8195_hdmitx_dptx_hw_params_fixup,
+		SND_SOC_DAILINK_REG(DPTX_BE),
+	},
+	[DAI_LINK_ETDM1_IN_BE] = {
+		.name = "ETDM1_IN_BE",
+		.no_pcm = 1,
+		.dai_fmt = SND_SOC_DAIFMT_I2S |
+			SND_SOC_DAIFMT_NB_NF |
+			SND_SOC_DAIFMT_CBS_CFS,
+		.dpcm_capture = 1,
+		SND_SOC_DAILINK_REG(ETDM1_IN_BE),
+	},
+	[DAI_LINK_ETDM2_IN_BE] = {
+		.name = "ETDM2_IN_BE",
+		.no_pcm = 1,
+		.dai_fmt = SND_SOC_DAIFMT_I2S |
+			SND_SOC_DAIFMT_NB_NF |
+			SND_SOC_DAIFMT_CBS_CFS,
+		.dpcm_capture = 1,
+		.init = mt8195_rt5682_init,
+		.ops = &mt8195_rt5682_etdm_ops,
+		.be_hw_params_fixup = mt8195_etdm_hw_params_fixup,
+		SND_SOC_DAILINK_REG(ETDM2_IN_BE),
+	},
+	[DAI_LINK_ETDM1_OUT_BE] = {
+		.name = "ETDM1_OUT_BE",
+		.no_pcm = 1,
+		.dai_fmt = SND_SOC_DAIFMT_I2S |
+			SND_SOC_DAIFMT_NB_NF |
+			SND_SOC_DAIFMT_CBS_CFS,
+		.dpcm_playback = 1,
+		.ops = &mt8195_rt5682_etdm_ops,
+		.be_hw_params_fixup = mt8195_etdm_hw_params_fixup,
+		SND_SOC_DAILINK_REG(ETDM1_OUT_BE),
+	},
+	[DAI_LINK_ETDM2_OUT_BE] = {
+		.name = "ETDM2_OUT_BE",
+		.no_pcm = 1,
+		.dai_fmt = SND_SOC_DAIFMT_I2S |
+			SND_SOC_DAIFMT_NB_NF |
+			SND_SOC_DAIFMT_CBS_CFS,
+		.dpcm_playback = 1,
+		.ops = &mt8195_rt1011_etdm_ops,
+		.be_hw_params_fixup = mt8195_etdm_hw_params_fixup,
+		SND_SOC_DAILINK_REG(ETDM2_OUT_BE),
+	},
+	[DAI_LINK_ETDM3_OUT_BE] = {
+		.name = "ETDM3_OUT_BE",
+		.no_pcm = 1,
+		.dai_fmt = SND_SOC_DAIFMT_I2S |
+			SND_SOC_DAIFMT_NB_NF |
+			SND_SOC_DAIFMT_CBS_CFS,
+		.dpcm_playback = 1,
+		.be_hw_params_fixup = mt8195_hdmitx_dptx_hw_params_fixup,
+		SND_SOC_DAILINK_REG(ETDM3_OUT_BE),
+	},
+	[DAI_LINK_PCM1_BE] = {
+		.name = "PCM1_BE",
+		.no_pcm = 1,
+		.dai_fmt = SND_SOC_DAIFMT_I2S |
+			SND_SOC_DAIFMT_NB_NF |
+			SND_SOC_DAIFMT_CBS_CFS,
+		.dpcm_capture = 1,
+		SND_SOC_DAILINK_REG(PCM1_BE),
+	},
+	[DAI_LINK_UL_SRC1_BE] = {
+		.name = "UL_SRC1_BE",
+		.no_pcm = 1,
+		.dpcm_capture = 1,
+		SND_SOC_DAILINK_REG(UL_SRC1_BE),
+	},
+	[DAI_LINK_UL_SRC2_BE] = {
+		.name = "UL_SRC2_BE",
+		.no_pcm = 1,
+		.dpcm_capture = 1,
+		SND_SOC_DAILINK_REG(UL_SRC2_BE),
+	},
+};
+
+static struct snd_soc_codec_conf rt1011_amp_conf[] = {
+	{
+		.dlc = COMP_CODEC_CONF(RT1011_DEV0_NAME),
+		.name_prefix = "Left",
+	},
+	{
+		.dlc = COMP_CODEC_CONF(RT1011_DEV1_NAME),
+		.name_prefix = "Right",
+	},
+};
+
+static struct snd_soc_card mt8195_mt6359_rt1011_rt5682_soc_card = {
+	.name = "mt8195_r1011_5682",
+	.owner = THIS_MODULE,
+	.dai_link = mt8195_mt6359_rt1011_rt5682_dai_links,
+	.num_links = ARRAY_SIZE(mt8195_mt6359_rt1011_rt5682_dai_links),
+	.controls = mt8195_mt6359_rt1011_rt5682_controls,
+	.num_controls = ARRAY_SIZE(mt8195_mt6359_rt1011_rt5682_controls),
+	.dapm_widgets = mt8195_mt6359_rt1011_rt5682_widgets,
+	.num_dapm_widgets = ARRAY_SIZE(mt8195_mt6359_rt1011_rt5682_widgets),
+	.dapm_routes = mt8195_mt6359_rt1011_rt5682_routes,
+	.num_dapm_routes = ARRAY_SIZE(mt8195_mt6359_rt1011_rt5682_routes),
+	.codec_conf = rt1011_amp_conf,
+	.num_configs = ARRAY_SIZE(rt1011_amp_conf),
+};
+
+static int mt8195_mt6359_rt1011_rt5682_dev_probe(struct platform_device *pdev)
+{
+	struct snd_soc_card *card = &mt8195_mt6359_rt1011_rt5682_soc_card;
+	struct device_node *platform_node;
+	struct snd_soc_dai_link *dai_link;
+	struct mt8195_mt6359_rt1011_rt5682_priv *priv = NULL;
+	int ret, i;
+
+	card->dev = &pdev->dev;
+
+	platform_node = of_parse_phandle(pdev->dev.of_node,
+					 "mediatek,platform", 0);
+	if (!platform_node) {
+		dev_dbg(&pdev->dev, "Property 'platform' missing or invalid\n");
+		return -EINVAL;
+	}
+
+	for_each_card_prelinks(card, i, dai_link) {
+		if (!dai_link->platforms->name)
+			dai_link->platforms->of_node = platform_node;
+
+		if (strcmp(dai_link->name, "DPTX_BE") == 0) {
+			dai_link->codecs->of_node =
+				of_parse_phandle(pdev->dev.of_node,
+						 "mediatek,dptx-codec", 0);
+			if (!dai_link->codecs->of_node) {
+				dev_dbg(&pdev->dev, "No property 'dptx-codec'\n");
+			} else {
+				dai_link->codecs->name = NULL;
+				dai_link->codecs->dai_name = "i2s-hifi";
+				dai_link->init = mt8195_dptx_codec_init;
+			}
+		}
+
+		if (strcmp(dai_link->name, "ETDM3_OUT_BE") == 0) {
+			dai_link->codecs->of_node =
+				of_parse_phandle(pdev->dev.of_node,
+						 "mediatek,hdmi-codec", 0);
+			if (!dai_link->codecs->of_node) {
+				dev_dbg(&pdev->dev, "No property 'hdmi-codec'\n");
+			} else {
+				dai_link->codecs->name = NULL;
+				dai_link->codecs->dai_name = "i2s-hifi";
+				dai_link->init = mt8195_hdmi_codec_init;
+			}
+		}
+	}
+
+	priv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	snd_soc_card_set_drvdata(card, priv);
+
+	ret = devm_snd_soc_register_card(&pdev->dev, card);
+	if (ret)
+		dev_err(&pdev->dev, "%s snd_soc_register_card fail %d\n",
+			__func__, ret);
+	return ret;
+}
+
+#ifdef CONFIG_OF
+static const struct of_device_id mt8195_mt6359_rt1011_rt5682_dt_match[] = {
+	{.compatible = "mediatek,mt8195_mt6359_rt1011_rt5682",},
+	{}
+};
+#endif
+
+static const struct dev_pm_ops mt8195_mt6359_rt1011_rt5682_pm_ops = {
+	.poweroff = snd_soc_poweroff,
+	.restore = snd_soc_resume,
+};
+
+static struct platform_driver mt8195_mt6359_rt1011_rt5682_driver = {
+	.driver = {
+		.name = "mt8195_mt6359_rt1011_rt5682",
+#ifdef CONFIG_OF
+		.of_match_table = mt8195_mt6359_rt1011_rt5682_dt_match,
+#endif
+		.pm = &mt8195_mt6359_rt1011_rt5682_pm_ops,
+	},
+	.probe = mt8195_mt6359_rt1011_rt5682_dev_probe,
+};
+
+module_platform_driver(mt8195_mt6359_rt1011_rt5682_driver);
+
+/* Module information */
+MODULE_DESCRIPTION("MT8195-MT6359-RT1011-RT5682 ALSA SoC machine driver");
+MODULE_AUTHOR("Trevor Wu <trevor.wu@mediatek.com>");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("mt8195_mt6359_rt1011_rt5682 soc card");
diff --git a/sound/soc/mediatek/mt8195/mt8195-mt6359-rt1019-rt5682.c b/sound/soc/mediatek/mt8195/mt8195-mt6359-rt1019-rt5682.c
index c97ace7387b4cdce5f506f17789a8c67ecb6cede..c3f58e1f271dd4bb49bd3f1edb2c2a35ad734a54 100644
--- a/sound/soc/mediatek/mt8195/mt8195-mt6359-rt1019-rt5682.c
+++ b/sound/soc/mediatek/mt8195/mt8195-mt6359-rt1019-rt5682.c
@@ -25,6 +25,21 @@
 #define RT5682_CODEC_DAI	"rt5682-aif1"
 #define RT5682_DEV0_NAME	"rt5682.2-001a"
 
+#if IS_ENABLED(CONFIG_SND_SOC_SOF_MT8195)
+#include <sound/sof.h>
+#define SOF_DMA_DL2 "SOF_DMA_DL2"
+#define SOF_DMA_DL3 "SOF_DMA_DL3"
+#define SOF_DMA_UL4 "SOF_DMA_UL4"
+#define SOF_DMA_UL5 "SOF_DMA_UL5"
+
+struct sof_conn_stream {
+	const char *normal_link;
+	const char *sof_link;
+	const char *sof_dma;
+	int stream_dir;
+};
+#endif
+
 struct mt8195_mt6359_rt1019_rt5682_priv {
 	struct snd_soc_jack headset_jack;
 	struct snd_soc_jack dp_jack;
@@ -36,6 +51,12 @@ static const struct snd_soc_dapm_widget
 	SND_SOC_DAPM_SPK("Speakers", NULL),
 	SND_SOC_DAPM_HP("Headphone Jack", NULL),
 	SND_SOC_DAPM_MIC("Headset Mic", NULL),
+#if IS_ENABLED(CONFIG_SND_SOC_SOF_MT8195)
+	SND_SOC_DAPM_MIXER(SOF_DMA_DL2, SND_SOC_NOPM, 0, 0, NULL, 0),
+	SND_SOC_DAPM_MIXER(SOF_DMA_DL3, SND_SOC_NOPM, 0, 0, NULL, 0),
+	SND_SOC_DAPM_MIXER(SOF_DMA_UL4, SND_SOC_NOPM, 0, 0, NULL, 0),
+	SND_SOC_DAPM_MIXER(SOF_DMA_UL5, SND_SOC_NOPM, 0, 0, NULL, 0),
+#endif
 };
 
 static const struct snd_soc_dapm_route mt8195_mt6359_rt1019_rt5682_routes[] = {
@@ -45,6 +66,18 @@ static const struct snd_soc_dapm_route mt8195_mt6359_rt1019_rt5682_routes[] = {
 	{ "Headphone Jack", NULL, "HPOL" },
 	{ "Headphone Jack", NULL, "HPOR" },
 	{ "IN1P", NULL, "Headset Mic" },
+#if IS_ENABLED(CONFIG_SND_SOC_SOF_MT8195)
+	/* SOF Uplink */
+	{SOF_DMA_UL4, NULL, "O034"},
+	{SOF_DMA_UL4, NULL, "O035"},
+	{SOF_DMA_UL5, NULL, "O036"},
+	{SOF_DMA_UL5, NULL, "O037"},
+	/* SOF Downlink */
+	{"I070", NULL, SOF_DMA_DL2},
+	{"I071", NULL, SOF_DMA_DL2},
+	{"I020", NULL, SOF_DMA_DL3},
+	{"I021", NULL, SOF_DMA_DL3},
+#endif
 };
 
 static const struct snd_kcontrol_new mt8195_mt6359_rt1019_rt5682_controls[] = {
@@ -157,7 +190,7 @@ static int mt8195_mt6359_mtkaif_calibration(struct snd_soc_pcm_runtime *rtd)
 	     phase <= mtkaif_calibration_num_phase && mtkaif_calibration_ok;
 	     phase++) {
 		mt6359_set_mtkaif_calibration_phase(cmpnt_codec,
-						    phase, phase, phase);
+						 phase, phase, phase);
 
 		regmap_update_bits(afe_priv->topckgen,
 				   CKSYS_AUD_TOP_CFG, 0x1, 0x1);
@@ -556,6 +589,12 @@ enum {
 	DAI_LINK_PCM1_BE,
 	DAI_LINK_UL_SRC1_BE,
 	DAI_LINK_UL_SRC2_BE,
+#if IS_ENABLED(CONFIG_SND_SOC_SOF_MT8195)
+	DAI_LINK_SOF_DL2_BE,
+	DAI_LINK_SOF_DL3_BE,
+	DAI_LINK_SOF_UL4_BE,
+	DAI_LINK_SOF_UL5_BE,
+#endif
 };
 
 /* FE */
@@ -698,6 +737,172 @@ SND_SOC_DAILINK_DEFS(UL_SRC2_BE,
 						   "mt6359-snd-codec-aif2")),
 		     DAILINK_COMP_ARRAY(COMP_EMPTY()));
 
+#if IS_ENABLED(CONFIG_SND_SOC_SOF_MT8195)
+SND_SOC_DAILINK_DEFS(AFE_SOF_DL2,
+		     DAILINK_COMP_ARRAY(COMP_CPU("SOF_DL2")),
+		     DAILINK_COMP_ARRAY(COMP_DUMMY()),
+		     DAILINK_COMP_ARRAY(COMP_PLATFORM("10803000.adsp")));
+
+SND_SOC_DAILINK_DEFS(AFE_SOF_DL3,
+		     DAILINK_COMP_ARRAY(COMP_CPU("SOF_DL3")),
+		     DAILINK_COMP_ARRAY(COMP_DUMMY()),
+		     DAILINK_COMP_ARRAY(COMP_PLATFORM("10803000.adsp")));
+
+SND_SOC_DAILINK_DEFS(AFE_SOF_UL4,
+		     DAILINK_COMP_ARRAY(COMP_CPU("SOF_UL4")),
+		     DAILINK_COMP_ARRAY(COMP_DUMMY()),
+		     DAILINK_COMP_ARRAY(COMP_PLATFORM("10803000.adsp")));
+
+SND_SOC_DAILINK_DEFS(AFE_SOF_UL5,
+		     DAILINK_COMP_ARRAY(COMP_CPU("SOF_UL5")),
+		     DAILINK_COMP_ARRAY(COMP_DUMMY()),
+		     DAILINK_COMP_ARRAY(COMP_PLATFORM("10803000.adsp")));
+#endif
+
+#if IS_ENABLED(CONFIG_SND_SOC_SOF_MT8195)
+static const struct sof_conn_stream g_sof_conn_streams[] = {
+	{ "ETDM2_OUT_BE", "AFE_SOF_DL2", SOF_DMA_DL2, SNDRV_PCM_STREAM_PLAYBACK},
+	{ "ETDM1_OUT_BE", "AFE_SOF_DL3", SOF_DMA_DL3, SNDRV_PCM_STREAM_PLAYBACK},
+	{ "UL_SRC1_BE", "AFE_SOF_UL4", SOF_DMA_UL4, SNDRV_PCM_STREAM_CAPTURE},
+	{ "ETDM2_IN_BE", "AFE_SOF_UL5", SOF_DMA_UL5, SNDRV_PCM_STREAM_CAPTURE},
+};
+
+/* fixup the BE DAI link to match any values from topology */
+static int mt8195_dai_link_fixup(struct snd_soc_pcm_runtime *rtd,
+				 struct snd_pcm_hw_params *params)
+{
+	int i, j, ret = 0;
+	struct snd_soc_card *card = rtd->card;
+
+	for (i = 0; i < ARRAY_SIZE(g_sof_conn_streams); i++) {
+		const struct sof_conn_stream *conn = &g_sof_conn_streams[i];
+
+		if (!strcmp(rtd->dai_link->name, conn->normal_link)) {
+			struct snd_soc_dai_link *sof_dai_link = NULL;
+			struct snd_soc_pcm_runtime *runtime;
+
+			for_each_card_rtds(card, runtime) {
+				if (!strcmp(runtime->dai_link->name, conn->sof_link)) {
+					struct snd_soc_dai *cpu_dai;
+
+					for_each_rtd_cpu_dais(runtime, j, cpu_dai) {
+						if (cpu_dai->stream_active[conn->stream_dir] > 0) {
+							sof_dai_link = runtime->dai_link;
+							break;
+						}
+					}
+					break;
+				}
+			}
+
+			if (sof_dai_link && sof_dai_link->be_hw_params_fixup) {
+				ret = sof_dai_link->be_hw_params_fixup(runtime, params);
+				if (!strcmp(rtd->dai_link->name, "ETDM2_IN_BE") ||
+				    !strcmp(rtd->dai_link->name, "ETDM1_OUT_BE")) {
+					mt8195_etdm_hw_params_fixup(runtime, params);
+				}
+			}
+			break;
+		}
+	}
+
+	return ret;
+}
+
+static int mt8195_mt6359_rt1019_rt5682_card_late_probe(struct snd_soc_card *card)
+{
+	int i = 0;
+	struct snd_soc_pcm_runtime *runtime = NULL;
+	struct snd_soc_component *sof_comp = NULL;
+
+	/* 1. find sof component */
+	for_each_card_rtds(card, runtime) {
+		for (i = 0; i < runtime->num_components; i++) {
+			if (!runtime->components[i]->driver->name)
+				continue;
+			if (!strcmp(runtime->components[i]->driver->name,
+			    "sof-audio-component")) {
+				sof_comp = runtime->components[i];
+				break;
+			}
+		}
+	}
+
+	if (!sof_comp) {
+		dev_info(card->dev, " probe without component\n");
+		return 0;
+	}
+	/* 2. add route path and fixup callback */
+	for (i = 0; i < ARRAY_SIZE(g_sof_conn_streams); i++) {
+		const struct sof_conn_stream *conn = &g_sof_conn_streams[i];
+		struct snd_soc_pcm_runtime *sof_rtd = NULL;
+		struct snd_soc_pcm_runtime *normal_rtd = NULL;
+		struct snd_soc_pcm_runtime *rtd = NULL;
+
+		for_each_card_rtds(card, rtd) {
+			if (!strcmp(rtd->dai_link->stream_name, conn->sof_link)) {
+				sof_rtd = rtd;
+				continue;
+			}
+			if (!strcmp(rtd->dai_link->name, conn->normal_link)) {
+				normal_rtd = rtd;
+				continue;
+			}
+			if (normal_rtd && sof_rtd)
+				break;
+		}
+		if (normal_rtd && sof_rtd) {
+			int j;
+			struct snd_soc_dai *cpu_dai;
+
+			for_each_rtd_cpu_dais(sof_rtd, j, cpu_dai) {
+				struct snd_soc_dapm_route route;
+				struct snd_soc_dapm_path *p = NULL;
+				struct snd_soc_dapm_widget *play_widget =
+					cpu_dai->playback_widget;
+				struct snd_soc_dapm_widget *cap_widget =
+					cpu_dai->capture_widget;
+				memset(&route, 0, sizeof(route));
+				if (conn->stream_dir == SNDRV_PCM_STREAM_CAPTURE &&
+				    cap_widget) {
+					snd_soc_dapm_widget_for_each_sink_path(cap_widget, p) {
+						route.source = conn->sof_dma;
+						route.sink = p->sink->name;
+						snd_soc_dapm_add_routes(&card->dapm, &route, 1);
+					}
+				} else if (conn->stream_dir == SNDRV_PCM_STREAM_PLAYBACK &&
+						play_widget){
+					snd_soc_dapm_widget_for_each_source_path(play_widget, p) {
+						route.source = p->source->name;
+						route.sink = conn->sof_dma;
+						snd_soc_dapm_add_routes(&card->dapm, &route, 1);
+					}
+				} else {
+					dev_err(cpu_dai->dev, "stream dir and widget not pair\n");
+				}
+			}
+			normal_rtd->dai_link->be_hw_params_fixup = mt8195_dai_link_fixup;
+			sof_rtd->dai_link->be_hw_params_fixup =
+				sof_comp->driver->be_hw_params_fixup;
+		}
+	}
+
+	return 0;
+}
+
+static int mt8195_mt6359_rt1019_rt5682_card_probe(struct snd_soc_card *card)
+{
+	int i;
+	struct snd_soc_dai_link *dai_link;
+
+	for_each_card_prelinks(card, i, dai_link) {
+		if (dai_link->no_pcm && !dai_link->stream_name && dai_link->name)
+			dai_link->stream_name = dai_link->name;
+	}
+	return 0;
+}
+#endif
+
 static struct snd_soc_dai_link mt8195_mt6359_rt1019_rt5682_dai_links[] = {
 	/* FE */
 	[DAI_LINK_DL2_FE] = {
@@ -977,6 +1182,33 @@ static struct snd_soc_dai_link mt8195_mt6359_rt1019_rt5682_dai_links[] = {
 		.dpcm_capture = 1,
 		SND_SOC_DAILINK_REG(UL_SRC2_BE),
 	},
+#if IS_ENABLED(CONFIG_SND_SOC_SOF_MT8195)
+	/* SOF BE */
+	[DAI_LINK_SOF_DL2_BE] = {
+		.name = "AFE_SOF_DL2",
+		.no_pcm = 1,
+		.dpcm_playback = 1,
+		SND_SOC_DAILINK_REG(AFE_SOF_DL2),
+	},
+	[DAI_LINK_SOF_DL3_BE] = {
+		.name = "AFE_SOF_DL3",
+		.no_pcm = 1,
+		.dpcm_playback = 1,
+		SND_SOC_DAILINK_REG(AFE_SOF_DL3),
+	},
+	[DAI_LINK_SOF_UL4_BE] = {
+		.name = "AFE_SOF_UL4",
+		.no_pcm = 1,
+		.dpcm_capture = 1,
+		SND_SOC_DAILINK_REG(AFE_SOF_UL4),
+	},
+	[DAI_LINK_SOF_UL5_BE] = {
+		.name = "AFE_SOF_UL5",
+		.no_pcm = 1,
+		.dpcm_capture = 1,
+		SND_SOC_DAILINK_REG(AFE_SOF_UL5),
+	},
+#endif
 };
 
 static struct snd_soc_card mt8195_mt6359_rt1019_rt5682_soc_card = {
@@ -990,6 +1222,10 @@ static struct snd_soc_card mt8195_mt6359_rt1019_rt5682_soc_card = {
 	.num_dapm_widgets = ARRAY_SIZE(mt8195_mt6359_rt1019_rt5682_widgets),
 	.dapm_routes = mt8195_mt6359_rt1019_rt5682_routes,
 	.num_dapm_routes = ARRAY_SIZE(mt8195_mt6359_rt1019_rt5682_routes),
+#if IS_ENABLED(CONFIG_SND_SOC_SOF_MT8195)
+	.late_probe = mt8195_mt6359_rt1019_rt5682_card_late_probe,
+	.probe = mt8195_mt6359_rt1019_rt5682_card_probe,
+#endif
 };
 
 static int mt8195_mt6359_rt1019_rt5682_dev_probe(struct platform_device *pdev)
@@ -998,12 +1234,25 @@ static int mt8195_mt6359_rt1019_rt5682_dev_probe(struct platform_device *pdev)
 	struct device_node *platform_node;
 	struct snd_soc_dai_link *dai_link;
 	struct mt8195_mt6359_rt1019_rt5682_priv *priv = NULL;
+
+#if IS_ENABLED(CONFIG_SND_SOC_SOF_MT8195)
+	struct device_node *machine_node;
+	struct snd_soc_acpi_mach *mach;
+#endif
+
 	int ret, i;
 
 	card->dev = &pdev->dev;
 
+#if IS_ENABLED(CONFIG_SND_SOC_SOF_MT8195)
+	mach = pdev->dev.platform_data;
+	machine_node = mach->pdata;
+	platform_node = of_parse_phandle(machine_node, "mediatek,platform", 0);
+#else
 	platform_node = of_parse_phandle(pdev->dev.of_node,
 					 "mediatek,platform", 0);
+#endif
+
 	if (!platform_node) {
 		dev_dbg(&pdev->dev, "Property 'platform' missing or invalid\n");
 		return -EINVAL;
@@ -1013,10 +1262,20 @@ static int mt8195_mt6359_rt1019_rt5682_dev_probe(struct platform_device *pdev)
 		if (!dai_link->platforms->name)
 			dai_link->platforms->of_node = platform_node;
 
+#if IS_ENABLED(CONFIG_SND_SOC_SOF_MT8195)
+			dai_link->num_platforms = 1;
+#endif
+
 		if (strcmp(dai_link->name, "DPTX_BE") == 0) {
+#if IS_ENABLED(CONFIG_SND_SOC_SOF_MT8195)
+			dai_link->codecs->of_node =
+				of_parse_phandle(machine_node,
+						 "mediatek,dptx-codec", 0);
+#else
 			dai_link->codecs->of_node =
 				of_parse_phandle(pdev->dev.of_node,
 						 "mediatek,dptx-codec", 0);
+#endif
 			if (!dai_link->codecs->of_node) {
 				dev_dbg(&pdev->dev, "No property 'dptx-codec'\n");
 			} else {
@@ -1027,9 +1286,15 @@ static int mt8195_mt6359_rt1019_rt5682_dev_probe(struct platform_device *pdev)
 		}
 
 		if (strcmp(dai_link->name, "ETDM3_OUT_BE") == 0) {
+#if IS_ENABLED(CONFIG_SND_SOC_SOF_MT8195)
+                        dai_link->codecs->of_node =
+                                of_parse_phandle(machine_node,
+                                                 "mediatek,hdmi-codec", 0);
+#else
 			dai_link->codecs->of_node =
 				of_parse_phandle(pdev->dev.of_node,
 						 "mediatek,hdmi-codec", 0);
+#endif
 			if (!dai_link->codecs->of_node) {
 				dev_dbg(&pdev->dev, "No property 'hdmi-codec'\n");
 			} else {
diff --git a/sound/soc/sof/Kconfig b/sound/soc/sof/Kconfig
index cd659493b5dfe30b02d16ba5fa5ede6a4207ed4b..bef3d9a26d2c5dc9e359311358d243ec8cf879e0 100644
--- a/sound/soc/sof/Kconfig
+++ b/sound/soc/sof/Kconfig
@@ -46,6 +46,16 @@ config SND_SOC_SOF_OF
 	  required to enable i.MX8 devices.
 	  Say Y if you need this option. If unsure select "N".
 
+config SND_SOC_SOF_MTK
+	tristate "SOF MTK enumeration support"
+	depends on OF || COMPILE_TEST
+	select SND_SOC_SOF
+	select SND_SOC_SOF_OF
+	help
+	  This adds support for Device Tree enumeration. This option is
+	  required to enable MTK devices.
+	  Say Y if you need this option. If unsure select "N".
+
 config SND_SOC_SOF_DEBUG_PROBES
 	bool "SOF enable data probing"
 	select SND_SOC_COMPRESS
@@ -222,5 +232,6 @@ config SND_SOC_SOF_PROBE_WORK_QUEUE
 source "sound/soc/sof/imx/Kconfig"
 source "sound/soc/sof/intel/Kconfig"
 source "sound/soc/sof/xtensa/Kconfig"
+source "sound/soc/sof/mediatek/Kconfig"
 
 endif
diff --git a/sound/soc/sof/Makefile b/sound/soc/sof/Makefile
index 606d8137cd98878add1a833397c4f7799de73ad5..866c66a3a6ee8ec49ac2aeb13710e9874e4dd4d4 100644
--- a/sound/soc/sof/Makefile
+++ b/sound/soc/sof/Makefile
@@ -21,3 +21,4 @@ obj-$(CONFIG_SND_SOC_SOF_PCI_DEV) += snd-sof-pci.o
 obj-$(CONFIG_SND_SOC_SOF_INTEL_TOPLEVEL) += intel/
 obj-$(CONFIG_SND_SOC_SOF_IMX_TOPLEVEL) += imx/
 obj-$(CONFIG_SND_SOC_SOF_XTENSA) += xtensa/
+obj-$(CONFIG_SND_SOC_SOF_MTK_TOPLEVEL) += snd-sof.o mediatek/
diff --git a/sound/soc/sof/mediatek/Kconfig b/sound/soc/sof/mediatek/Kconfig
new file mode 100644
index 0000000000000000000000000000000000000000..8eaf2b3d663468560bbb12c0225b8558ea3f2575
--- /dev/null
+++ b/sound/soc/sof/mediatek/Kconfig
@@ -0,0 +1,20 @@
+# SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause)
+
+config SND_SOC_SOF_MTK_TOPLEVEL
+	bool "SOF support for MTK audio DSPs"
+	depends on ARM64|| COMPILE_TEST
+	depends on SND_SOC_SOF_MTK
+	help
+	  This adds support for Sound Open Firmware for Mediatek platforms.
+	  Say Y if you have such a device.
+	  If unsure select "N".
+
+if SND_SOC_SOF_MTK_TOPLEVEL
+config SND_SOC_SOF_MT8195
+	tristate "SOF support for MT8195 audio DSP"
+	select SND_SOC_SOF_XTENSA
+	help
+	  This option is not user-selectable but automagically handled by
+	  'select' statements at a higher level
+
+endif ## SND_SOC_SOF_MTK_TOPLEVEL
diff --git a/sound/soc/sof/mediatek/Makefile b/sound/soc/sof/mediatek/Makefile
new file mode 100755
index 0000000000000000000000000000000000000000..4305036d8c07675d4608adbd2bf971194da7a79f
--- /dev/null
+++ b/sound/soc/sof/mediatek/Makefile
@@ -0,0 +1,4 @@
+# SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause)
+snd-sof-mtk-dsp-objs := adsp_ipc.o adsp_pcm.o
+obj-$(CONFIG_SND_SOC_SOF_MT8195) += snd-sof-mtk-dsp.o mt8195/
+#obj-$(CONFIG_SND_SOC_SOF_MTK) += snd-sof-mtk-dsp.o
diff --git a/sound/soc/sof/mediatek/adsp_helper.h b/sound/soc/sof/mediatek/adsp_helper.h
new file mode 100644
index 0000000000000000000000000000000000000000..ea454b2085993fabf46ee02e439624f65ee6089d
--- /dev/null
+++ b/sound/soc/sof/mediatek/adsp_helper.h
@@ -0,0 +1,60 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+
+/*
+ * Copyright (c) 2021 MediaTek Inc.
+ */
+
+#ifndef __ADSP_HELPER_H__
+#define __ADSP_HELPER_H__
+
+#include "adsp_ipc.h"
+#include "adsp_pcm.h"
+#include <linux/of_irq.h>
+#include <linux/platform_device.h>
+
+/*
+ * Global important adsp data structure.
+ */
+struct adsp_chip_info {
+	phys_addr_t pa_sram;
+	phys_addr_t pa_dram; /* adsp dram physical base */
+	phys_addr_t pa_shared_dram; /* adsp dram physical base */
+	phys_addr_t pa_cfgreg;
+	phys_addr_t pa_mboxreg[DSP_MBOX_NUM];
+	u32 srammsize;
+	u32 dramsize;
+	u32 cfgregsize;
+	void __iomem *va_sram; /* corresponding to pa_sram */
+	void __iomem *va_dram; /* corresponding to pa_dram */
+	void __iomem *va_cfgreg;
+	void __iomem *va_mboxreg[DSP_MBOX_NUM];
+	void __iomem *shared_sram; /* part of  va_sram */
+	void __iomem *shared_dram; /* part of  va_dram */
+	phys_addr_t adsp_bootup_addr;
+	int dram_offset; /*dram offset between system and dsp view*/
+};
+
+struct adsp_priv {
+	struct device *dev;
+	struct snd_sof_dev *sdev;
+
+	/* DSP IPC handler */
+	struct mbox_controller *adsp_mbox;
+	struct mtk_adsp_ipi ipi[DSP_MBOX_NUM];
+
+	/* Power domain handling */
+	int num_domains;
+	struct device **pd_dev;
+	struct device_link **link;
+
+	struct adsp_chip_info *adsp;
+
+	u32 (*ap2adsp_addr)(u32 addr);
+	u32 (*adsp2ap_addr)(u32 addr);
+	struct adsp_mem_pool mem_pool;
+
+	void *private_data;
+};
+
+extern int g_dsp_wdt_irq_id;
+#endif
diff --git a/sound/soc/sof/mediatek/adsp_ipc.c b/sound/soc/sof/mediatek/adsp_ipc.c
new file mode 100644
index 0000000000000000000000000000000000000000..402cceb94766f9cb0afb9302ade5a2b228b7d7e2
--- /dev/null
+++ b/sound/soc/sof/mediatek/adsp_ipc.c
@@ -0,0 +1,63 @@
+// SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause)
+//
+// Copyright(c) 2021 Mediatek
+//
+// The Mediatek ADSP IPC implementation
+//
+
+#include <linux/firmware.h>
+#include <linux/of_platform.h>
+#include <linux/of_address.h>
+#include <linux/of_irq.h>
+#include <linux/mailbox_controller.h>
+#include <linux/mailbox_client.h>
+#include <linux/module.h>
+#include <sound/sof.h>
+#include <sound/sof/xtensa.h>
+#include "adsp_helper.h"
+
+
+/* DSP SOF IPC API */
+
+static void adsp_ipi_recv(struct mbox_client *c, void *mssg)
+{
+	struct mtk_adsp_ipi *ipi = container_of(c, struct mtk_adsp_ipi, cl);
+
+	if (ipi->ops && ipi->ops->handle_recv)
+		ipi->ops->handle_recv(ipi);
+}
+
+void adsp_ipi_send(struct snd_sof_dev *sdev, int idx, uint32_t op)
+{
+	struct adsp_priv *priv = sdev->pdata->hw_pdata;
+	struct adsp_mbox_ch_info *ch_info = priv->ipi[idx].chan->con_priv;
+
+	ch_info->ipi_op_val = op;
+	mbox_send_message(priv->ipi[idx].chan, NULL);
+}
+
+void adsp_ipi_request(struct snd_sof_dev *sdev, int idx, struct mtk_adsp_ipi_ops *ops)
+{
+	struct adsp_priv *priv = sdev->pdata->hw_pdata;
+	struct mbox_client *cl;
+
+	cl = &priv->ipi[idx].cl;
+	cl->dev = sdev->dev;
+	cl->tx_block = false;
+	cl->knows_txdone = false;
+	cl->tx_prepare = NULL;
+	cl->rx_callback = adsp_ipi_recv;
+
+	priv->ipi[idx].chan = mbox_request_channel(cl, idx);
+	priv->ipi[idx].ops = ops;
+	priv->ipi[idx].private_data = priv;
+}
+
+void *adsp_ipi_get_data(struct mtk_adsp_ipi *ipi)
+{
+	if (!ipi)
+		return NULL;
+
+	return ipi->private_data;
+}
+
diff --git a/sound/soc/sof/mediatek/adsp_ipc.h b/sound/soc/sof/mediatek/adsp_ipc.h
new file mode 100644
index 0000000000000000000000000000000000000000..a8db996725908dfb40074ed44df56128757ec2ef
--- /dev/null
+++ b/sound/soc/sof/mediatek/adsp_ipc.h
@@ -0,0 +1,47 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * Copyright 2021 Mediatek
+ *
+ * Header file for the DSP IPC implementation
+ */
+
+#ifndef ADSP_IPC_H
+#define ADSP_IPC_H
+
+#include <linux/device.h>
+#include <linux/types.h>
+#include <linux/mailbox_controller.h>
+#include <linux/mailbox_client.h>
+#include <sound/sof.h>
+#include "../ops.h"
+
+struct mtk_adsp_ipi;
+
+struct mtk_adsp_ipi_ops {
+	void (*handle_recv)(struct mtk_adsp_ipi *ipc);
+};
+
+struct mtk_adsp_ipi {
+	struct mbox_client cl;
+	struct mbox_chan *chan;
+	struct mtk_adsp_ipi_ops *ops;
+	void *private_data;
+};
+
+struct adsp_mbox_ch_info {
+	u32 id;
+	u32 ipi_op_val;
+	struct adsp_priv *priv;
+};
+
+#define DSP_MBOX_NUM	  3
+
+#define ADSP_IPI_MBOX_REQ 0
+#define ADSP_IPI_MBOX_RSP 1
+#define ADSP_IPI_OP_REQ 0x1
+#define ADSP_IPI_OP_RSP 0x2
+
+void adsp_ipi_request(struct snd_sof_dev *sdev, int idx, struct mtk_adsp_ipi_ops *ops);
+void *adsp_ipi_get_data(struct mtk_adsp_ipi *ipi);
+void adsp_ipi_send(struct snd_sof_dev *sdev, int idx, uint32_t op);
+#endif /* ADSP_IPC_H */
diff --git a/sound/soc/sof/mediatek/adsp_pcm.c b/sound/soc/sof/mediatek/adsp_pcm.c
new file mode 100644
index 0000000000000000000000000000000000000000..05f0540873d890ad4beef07175b0a81388f19060
--- /dev/null
+++ b/sound/soc/sof/mediatek/adsp_pcm.c
@@ -0,0 +1,247 @@
+// SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause)
+//
+// Copyright(c) 2021 Mediatek
+//
+// The Mediatek ADSP PCM implementation
+//
+
+#include "adsp_pcm.h"
+#include "adsp_helper.h"
+
+int adsp_genpool_create(struct adsp_mem_pool *mem_pool,
+			struct adsp_mem *mem_info)
+{
+	int ret = 0;
+	unsigned long va_start;
+	size_t va_chunk;
+
+	mem_pool->dram_pool = gen_pool_create(SOF_MIN_ADSP_SHIFT, -1);
+	if (!mem_pool->dram_pool)
+		return -ENOMEM;
+
+	va_start = mem_info->va_addr;
+	va_chunk = mem_info->size;
+	if (!va_start || !va_chunk) {
+		ret = -EINVAL;
+		goto out;
+	}
+	ret = gen_pool_add_virt(mem_pool->dram_pool, va_start,
+				mem_info->phy_addr, va_chunk, -1);
+	if (ret)
+		goto out;
+
+	mem_pool->dram = mem_info;
+
+	return 0;
+
+out:
+	gen_pool_destroy(mem_pool->dram_pool);
+	mem_pool->dram_pool = NULL;
+	return ret;
+}
+
+int adsp_genpool_destroy(struct adsp_mem_pool *mem_pool)
+{
+	gen_pool_destroy(mem_pool->dram_pool);
+	mem_pool->dram_pool = NULL;
+	mem_pool->dram = NULL;
+	return 0;
+}
+
+int adsp_genpool_alloc(struct adsp_mem_pool *mem_pool, unsigned char **vaddr,
+		       dma_addr_t *paddr, unsigned int size)
+{
+	*vaddr = NULL;
+
+	if (!mem_pool)
+		return -EINVAL;
+
+	if (!mem_pool->dram_pool)
+		return -EINVAL;
+
+	*vaddr = (unsigned char *)gen_pool_dma_alloc(mem_pool->dram_pool,
+			size, paddr);
+	if (!*vaddr)
+		return -ENOMEM;
+
+	return 0;
+}
+
+int adsp_genpool_alloc_align(struct adsp_mem_pool *mem_pool,
+			     unsigned char **vaddr, dma_addr_t *paddr,
+			     unsigned int size, int align)
+{
+	*vaddr = NULL;
+
+	if (!mem_pool)
+		return -EINVAL;
+
+	if (!mem_pool->dram_pool)
+		return -EINVAL;
+
+	*vaddr = (unsigned char *)gen_pool_dma_alloc_align(mem_pool->dram_pool,
+					size, paddr, align);
+	if (!*vaddr)
+		return -ENOMEM;
+
+	return 0;
+}
+
+int adsp_genpool_free(struct adsp_mem_pool *mem_pool,
+		      unsigned char *vaddr, size_t size)
+{
+	if (!mem_pool)
+		return -EINVAL;
+
+	if (!mem_pool->dram_pool)
+		return -EINVAL;
+
+	/* allocate VA with gen pool */
+	if (*vaddr) {
+		gen_pool_free(mem_pool->dram_pool, (unsigned long)vaddr, size);
+		size = 0;
+	}
+	return 0;
+}
+
+int adsp_pcm_hw_params(struct snd_sof_dev *sdev,
+		       struct snd_pcm_substream *substream,
+		       struct snd_pcm_hw_params *params,
+		       struct sof_ipc_stream_params *ipc_params)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);
+	struct snd_soc_component *scomp = sdev->component;
+	struct device *dev = sdev->dev;
+	struct snd_sof_pcm *spcm;
+	struct snd_dma_buffer *dmab;
+	struct snd_dma_buffer *pg_table;
+	struct snd_dma_buffer *pg_table_backup;
+	struct adsp_priv *priv = sdev->pdata->hw_pdata;
+	struct adsp_mem_pool *mem_pool = &priv->mem_pool;
+	size_t dma_bytes;
+	int ret = 0;
+
+	dev_info(sdev->dev, "%s\n", __func__);
+
+	dma_bytes = runtime->dma_bytes;
+
+	spcm = snd_sof_find_spcm_dai(scomp, rtd);
+	if (!spcm) {
+		dev_warn(sdev->dev, "%s warn: can't find PCM with DAI ID %d\n",
+			 __func__, rtd->dai_link->id);
+		return -EINVAL;
+	}
+
+	pg_table = &spcm->stream[substream->stream].page_table;
+
+	if (runtime->buffer_changed && substream->managed_buffer_alloc) {
+		/* free dma pages allocated by common layer
+		 * if page table private data is not NULL,
+		 * this hw_params may be trigged by PCM xrun
+		 */
+		if (pg_table->private_data)
+			return 0;
+
+		snd_pcm_lib_free_pages(substream);
+
+		/* prepare dma buf struct for dsp runtime dma and page table*/
+		dmab = kzalloc(sizeof(*dmab) * 2, GFP_KERNEL);
+		if (!dmab)
+			return -ENOMEM;
+		pg_table_backup = dmab + 1;
+		/* backup original page table address */
+		pg_table_backup->area = pg_table->area;
+		pg_table_backup->addr = pg_table->addr;
+		pg_table->private_data = pg_table_backup;
+
+		ret = adsp_genpool_alloc(mem_pool,
+					 &pg_table->area,
+					 &pg_table->addr,
+					 pg_table->bytes);
+		if (ret != 0)
+			goto out;
+
+		pg_table->addr = priv->ap2adsp_addr(pg_table->addr);
+		dmab->dev.type = SNDRV_DMA_TYPE_DEV;
+		dmab->dev.dev = substream->pcm->card->dev;
+		dmab->bytes = dma_bytes;
+		/* allocate dma pages from dsp share buffer */
+		ret = adsp_genpool_alloc_align(mem_pool,
+					       &dmab->area,
+					       &dmab->addr,
+					       dma_bytes,
+					       PAGE_SIZE);
+		if (ret != 0)
+			goto out;
+
+		dmab->addr = priv->ap2adsp_addr(dmab->addr);
+		snd_pcm_set_runtime_buffer(substream, dmab);
+		snd_sof_create_page_table(dev, dmab,
+					  pg_table->area, dma_bytes);
+
+		/* replace ipc parameters for dma buffer */
+		ipc_params->buffer.phy_addr = pg_table->addr;
+	}
+
+	return 0;
+out:
+	if (dmab) {
+		if (dmab->area)
+			adsp_genpool_free(mem_pool, dmab->area, dmab->bytes);
+
+		if (pg_table_backup->area && pg_table->area) {
+			adsp_genpool_free(mem_pool, pg_table->area,
+					  pg_table->bytes);
+			pg_table->area = pg_table_backup->area;
+			pg_table->addr = pg_table_backup->addr;
+			pg_table->private_data = NULL;
+		}
+
+		kfree(dmab);
+	}
+	return ret;
+}
+
+int adsp_pcm_hw_free(struct snd_sof_dev *sdev,
+		     struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);
+	struct snd_soc_component *scomp = sdev->component;
+	struct snd_dma_buffer *dmab;
+	struct snd_dma_buffer *pg_table;
+	struct snd_dma_buffer *pg_table_backup;
+	struct adsp_priv *priv = sdev->pdata->hw_pdata;
+	struct adsp_mem_pool *mem_pool = &priv->mem_pool;
+	struct snd_sof_pcm *spcm;
+
+	dev_info(sdev->dev, "%s\n", __func__);
+
+	spcm = snd_sof_find_spcm_dai(scomp, rtd);
+	if (!spcm) {
+		dev_warn(sdev->dev, "%s warn: can't find PCM with DAI ID %d\n",
+			 __func__, rtd->dai_link->id);
+		return -EINVAL;
+	}
+
+	pg_table = &spcm->stream[substream->stream].page_table;
+
+	if (substream->managed_buffer_alloc) {
+		pg_table_backup = pg_table->private_data;
+		dmab = snd_pcm_get_dma_buf(substream);
+		if (dmab && dmab->area)
+			adsp_genpool_free(mem_pool, dmab->area, dmab->bytes);
+		snd_pcm_set_runtime_buffer(substream, NULL);
+		if (pg_table_backup && pg_table->area) {
+			adsp_genpool_free(mem_pool, pg_table->area,
+					  pg_table->bytes);
+			pg_table->area = pg_table_backup->area;
+			pg_table->addr = pg_table_backup->addr;
+			pg_table->private_data = NULL;
+		}
+
+		kfree(dmab);
+	}
+	return 0;
+}
+
diff --git a/sound/soc/sof/mediatek/adsp_pcm.h b/sound/soc/sof/mediatek/adsp_pcm.h
new file mode 100644
index 0000000000000000000000000000000000000000..0cc9cd650150df3ff0fbfffc9d695496bea7dd47
--- /dev/null
+++ b/sound/soc/sof/mediatek/adsp_pcm.h
@@ -0,0 +1,66 @@
+/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause) */
+/*
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ * redistributing this file, you may do so under either license.
+ *
+ * Copyright(c) 2021 Mediatek Corporation. All rights reserved.
+ *
+ * Author: Bo Pan <bo.pan@mediatek.com>
+ */
+
+#ifndef __SOF_ADSP_PCM_H
+#define __SOF_ADSP_PCM_H
+#include <linux/module.h>
+#include <sound/sof.h>
+#include <sound/sof/xtensa.h>
+#include <linux/genalloc.h>
+#include "../ops.h"
+#include "../sof-audio.h"
+
+#define SOF_MIN_ADSP_SHIFT (8)
+#define SOF_MIN_ADSP_POOL_SIZE BIT(SOF_MIN_ADSP_SHIFT)
+
+struct adsp_mem {
+	unsigned long long phy_addr;
+	unsigned long long va_addr;
+	unsigned long long size;
+	unsigned char *vir_addr;
+};
+
+struct adsp_mem_pool {
+	struct gen_pool *dram_pool;
+	struct adsp_mem *dram;
+};
+
+/* adsp share memory manage */
+int adsp_genpool_create(struct adsp_mem_pool *mem_pool,
+			struct adsp_mem *mem_info);
+
+int adsp_genpool_destroy(struct adsp_mem_pool *mem_pool);
+
+int adsp_genpool_alloc(struct adsp_mem_pool *mem_pool,
+		       unsigned char **vaddr,
+		       dma_addr_t *paddr,
+		       unsigned int size);
+
+int adsp_genpool_alloc_align(struct adsp_mem_pool *mem_pool,
+			     unsigned char **vaddr,
+			     dma_addr_t *paddr,
+			     unsigned int size,
+			     int align);
+
+int adsp_genpool_free(struct adsp_mem_pool *mem_pool,
+		      unsigned char *vaddr,
+		      size_t size);
+
+/* SOF adsp pcm */
+int adsp_pcm_hw_params(struct snd_sof_dev *sdev,
+		       struct snd_pcm_substream *substream,
+		       struct snd_pcm_hw_params *params,
+		       struct sof_ipc_stream_params *ipc_params);
+
+int adsp_pcm_hw_free(struct snd_sof_dev *sdev,
+		     struct snd_pcm_substream *substream);
+
+#endif /* __SOF_ADSP_PCM_H */
+
diff --git a/sound/soc/sof/mediatek/mt8195/Makefile b/sound/soc/sof/mediatek/mt8195/Makefile
new file mode 100644
index 0000000000000000000000000000000000000000..2748f743dc2b8a5093793406c38142bcb977cf18
--- /dev/null
+++ b/sound/soc/sof/mediatek/mt8195/Makefile
@@ -0,0 +1,5 @@
+# SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause)
+snd-sof-mt8195-objs := mt8195.o mt8195-loader.o mt8195-clk.o mt8195-ipc.o
+
+obj-$(CONFIG_SND_SOC_SOF_MT8195) += snd-sof-mt8195.o
+
diff --git a/sound/soc/sof/mediatek/mt8195/mt8195-clk.c b/sound/soc/sof/mediatek/mt8195/mt8195-clk.c
new file mode 100644
index 0000000000000000000000000000000000000000..4a164636beec3be2473b8617dcdc9ba390ed6fc6
--- /dev/null
+++ b/sound/soc/sof/mediatek/mt8195/mt8195-clk.c
@@ -0,0 +1,202 @@
+// SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause)
+//
+// Copyright 2021 Mediatek
+//
+// Author: YC Hung <yc.hung@mediatek.com>
+//
+// Hardware interface for mt8195 DSP clock
+
+#include <linux/clk.h>
+#include <linux/pm_runtime.h>
+#include <linux/io.h>
+#include "mt8195.h"
+#include "mt8195-clk.h"
+
+struct clk *clk_handle[ADSP_CLK_NUM];
+
+int platform_parse_clock(struct device *dev)
+{
+	clk_handle[CLK_TOP_DSP_SEL] = devm_clk_get(dev, "dsp_sel");
+	if (IS_ERR(clk_handle[CLK_TOP_DSP_SEL])) {
+		dev_info(dev, "clk_get(\"dsp_sel\") failed\n");
+		return PTR_ERR(clk_handle[CLK_TOP_DSP_SEL]);
+	}
+
+	clk_handle[CLK_TOP_CLK26M] = devm_clk_get(dev, "clk26m_ck");
+	if (IS_ERR(clk_handle[CLK_TOP_CLK26M])) {
+		dev_info(dev, "clk_get(\"clk26m_ck\") failed\n");
+		return PTR_ERR(clk_handle[CLK_TOP_CLK26M]);
+	}
+
+	clk_handle[CLK_TOP_AUDIO_LOCAL_BUS_SEL] = devm_clk_get(dev,
+							       "audio_local_bus");
+	if (IS_ERR(clk_handle[CLK_TOP_AUDIO_LOCAL_BUS_SEL])) {
+		dev_info(dev, "clk_get(\"audio_local_bus\") failed\n");
+		return PTR_ERR(clk_handle[CLK_TOP_AUDIO_LOCAL_BUS_SEL]);
+	}
+
+	clk_handle[CLK_TOP_MAINPLL_D7_D2] = devm_clk_get(dev, "mainpll_d7_d2");
+	if (IS_ERR(clk_handle[CLK_TOP_MAINPLL_D7_D2])) {
+		dev_info(dev, "clk_get(\"mainpll_d7_d2\") failed\n");
+		return PTR_ERR(clk_handle[CLK_TOP_MAINPLL_D7_D2]);
+	}
+
+	clk_handle[CLK_SCP_ADSP_AUDIODSP] = devm_clk_get(dev,
+							 "scp_adsp_audiodsp");
+	if (IS_ERR(clk_handle[CLK_SCP_ADSP_AUDIODSP])) {
+		dev_info(dev, "clk_get(\"scp_adsp_audiodsp\") failed\n");
+		return PTR_ERR(clk_handle[CLK_SCP_ADSP_AUDIODSP]);
+	}
+
+	clk_handle[CLK_TOP_AUDIO_H_SEL] = devm_clk_get(dev, "audio_h_sel");
+	if (IS_ERR(clk_handle[CLK_TOP_AUDIO_H_SEL])) {
+		dev_info(dev, "clk_get(\"audio_h_sel\") failed\n");
+		return PTR_ERR(clk_handle[CLK_TOP_AUDIO_H_SEL]);
+	}
+
+	return 0;
+}
+
+int adsp_enable_clock(struct device *dev)
+{
+	int ret = 0;
+
+	ret = clk_prepare_enable(clk_handle[CLK_TOP_MAINPLL_D7_D2]);
+	if (ret) {
+		dev_info(dev, "%s clk_prepare_enable(mainpll_d7_d2) fail %d\n",
+			 __func__, ret);
+		return ret;
+	}
+
+	ret = clk_prepare_enable(clk_handle[CLK_TOP_DSP_SEL]);
+	if (ret) {
+		dev_info(dev, "%s clk_prepare_enable(dsp_sel) fail %d\n",
+			 __func__, ret);
+		return ret;
+	}
+
+	ret = clk_prepare_enable(clk_handle[CLK_TOP_AUDIO_LOCAL_BUS_SEL]);
+	if (ret) {
+		dev_info(dev, "%s clk_prepare_enable(audio_local_bus) fail %d\n",
+			 __func__, ret);
+		return ret;
+	}
+
+	ret = clk_prepare_enable(clk_handle[CLK_SCP_ADSP_AUDIODSP]);
+	if (ret) {
+		dev_info(dev, "%s clk_prepare_enable(scp_adsp_audiodsp) fail %d\n",
+			 __func__, ret);
+		return ret;
+	}
+
+	ret = clk_prepare_enable(clk_handle[CLK_TOP_AUDIO_H_SEL]);
+	if (ret) {
+		dev_info(dev, "%s clk_prepare_enable(audio_h_sel) fail %d\n",
+			 __func__, ret);
+		return ret;
+	}
+
+	return ret;
+}
+
+int adsp_sram_power_on(struct device *dev, bool val)
+{
+	void __iomem **va_dspsysreg;
+
+	va_dspsysreg = devm_ioremap(dev, ADSP_SRAM_POOL_CON, 0x4);
+
+	if (!va_dspsysreg) {
+		dev_err(dev, "error: failed to ioremap sram pool base 0x%x\n",
+			ADSP_SRAM_POOL_CON);
+		return -ENOMEM;
+	}
+
+	if (val) { /* Power on ADSP SRAM */
+		writel(readl(va_dspsysreg) & ~DSP_SRAM_POOL_PD_MASK,
+		       va_dspsysreg);
+	} else { /* Power down ADSP SRAM */
+		writel(readl(va_dspsysreg) | DSP_SRAM_POOL_PD_MASK,
+		       va_dspsysreg);
+	}
+
+	return 0;
+}
+
+void adsp_disable_clock(struct device *dev)
+{
+	clk_disable_unprepare(clk_handle[CLK_TOP_AUDIO_H_SEL]);
+	clk_disable_unprepare(clk_handle[CLK_SCP_ADSP_AUDIODSP]);
+	clk_disable_unprepare(clk_handle[CLK_TOP_AUDIO_LOCAL_BUS_SEL]);
+	clk_disable_unprepare(clk_handle[CLK_TOP_DSP_SEL]);
+	clk_disable_unprepare(clk_handle[CLK_TOP_MAINPLL_D7_D2]);
+}
+
+int adsp_default_clk_init(struct device *dev, int enable)
+{
+	int ret = 0;
+
+	dev_info(dev, "%s: %s\n", __func__, enable ? "on" : "off");
+
+	if (enable) {
+		ret = clk_set_parent(clk_handle[CLK_TOP_DSP_SEL],
+				     clk_handle[CLK_TOP_CLK26M]);
+		if (ret) {
+			dev_info(dev, "failed to set dsp_sel to clk26m: %d\n",
+				 ret);
+			goto TAIL;
+		}
+
+		ret = clk_set_parent(clk_handle[CLK_TOP_AUDIO_LOCAL_BUS_SEL],
+				     clk_handle[CLK_TOP_MAINPLL_D7_D2]);
+		if (ret) {
+			dev_info(dev, "set audio_local_bus failed %d\n", ret);
+			goto TAIL;
+		}
+
+		ret = adsp_enable_clock(dev);
+		if (ret) {
+			dev_info(dev, "failed to adsp_enable_clock: %d\n", ret);
+			goto TAIL;
+		}
+	} else {
+		adsp_disable_clock(dev);
+	}
+
+TAIL:
+	return ret;
+}
+
+int adsp_clock_on(struct device *dev)
+{
+	int ret = 0;
+
+	dev_info(dev, "%s\n", __func__);
+
+	/* Open ADSP clock */
+	ret = adsp_default_clk_init(dev, 1);
+	if (ret) {
+		dev_err(dev, "%s [ADSP] adsp_default_clk_init fail ret : %d\n",
+			__func__, ret);
+		return ret;
+	}
+
+	return ret;
+}
+
+int adsp_clock_off(struct device *dev)
+{
+	int ret = 0;
+
+	dev_info(dev, "%s\n", __func__);
+
+	/* Close ADSP clock */
+	ret = adsp_default_clk_init(dev, 0);
+	if (ret) {
+		dev_err(dev, "%s [ADSP] adsp_default_clk_init fail ret : %d\n",
+			__func__, ret);
+		return ret;
+	}
+
+	return ret;
+}
+
diff --git a/sound/soc/sof/mediatek/mt8195/mt8195-clk.h b/sound/soc/sof/mediatek/mt8195/mt8195-clk.h
new file mode 100644
index 0000000000000000000000000000000000000000..4e48d7721e213047ef53853b4c9055fb35a05856
--- /dev/null
+++ b/sound/soc/sof/mediatek/mt8195/mt8195-clk.h
@@ -0,0 +1,30 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+
+/*
+ * Copyright (c) 2021 MediaTek Inc.
+ *
+ *  Header file for the mt8195 DSP clock  definition
+ */
+
+#ifndef __MT8195_CLK_H
+#define __MT8195_CLK_H
+
+/*DSP clock*/
+enum ADSP_CLK_ID {
+	CLK_TOP_DSP_SEL,
+	CLK_TOP_CLK26M,
+	CLK_TOP_AUDIO_LOCAL_BUS_SEL,
+	CLK_TOP_MAINPLL_D7_D2,
+	CLK_SCP_ADSP_AUDIODSP,
+	CLK_TOP_AUDIO_H_SEL,
+	ADSP_CLK_NUM
+};
+
+int platform_parse_clock(struct device *dev);
+int adsp_default_clk_init(struct device *dev, int enable);
+int adsp_enable_clock(struct device *dev);
+void adsp_disable_clock(struct device *dev);
+int adsp_clock_on(struct device *dev);
+int adsp_clock_off(struct device *dev);
+int adsp_sram_power_on(struct device *dev, bool val);
+#endif
diff --git a/sound/soc/sof/mediatek/mt8195/mt8195-ipc.c b/sound/soc/sof/mediatek/mt8195/mt8195-ipc.c
new file mode 100644
index 0000000000000000000000000000000000000000..ca8a5c7394d4e7a052e91085cb564754b8ae05cb
--- /dev/null
+++ b/sound/soc/sof/mediatek/mt8195/mt8195-ipc.c
@@ -0,0 +1,242 @@
+// SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause)
+//
+// Copyright(c) 2021 Mediatek
+//
+// The Mediatek ADSP IPC implementation
+//
+
+#include <linux/firmware.h>
+#include <linux/of_platform.h>
+#include <linux/of_address.h>
+#include <linux/of_irq.h>
+#include <linux/mailbox_controller.h>
+#include <linux/mailbox_client.h>
+#include <linux/module.h>
+#include <sound/sof.h>
+#include <sound/sof/xtensa.h>
+#include "../adsp_ipc.h"
+#include "../adsp_helper.h"
+#include "mt8195-ipc.h"
+#include "mt8195.h"
+
+int trace_boot_event;
+
+static void mt8195_get_reply(struct snd_sof_dev *sdev)
+{
+	struct snd_sof_ipc_msg *msg = sdev->msg;
+	struct sof_ipc_reply reply;
+	int ret = 0;
+
+	if (!msg) {
+		dev_warn(sdev->dev, "unexpected ipc interrupt\n");
+		return;
+	}
+
+	/* get reply */
+	sof_mailbox_read(sdev, sdev->host_box.offset, &reply, sizeof(reply));
+
+	if (reply.error < 0) {
+		memcpy(msg->reply_data, &reply, sizeof(reply));
+		ret = reply.error;
+	} else {
+		/* reply has correct size? */
+		if (reply.hdr.size != msg->reply_size) {
+			dev_err(sdev->dev, "error: reply expected %zu got %u bytes\n",
+				msg->reply_size, reply.hdr.size);
+			ret = -EINVAL;
+		}
+
+		/* read the message */
+		if (msg->reply_size > 0)
+			sof_mailbox_read(sdev, sdev->host_box.offset,
+					 msg->reply_data, msg->reply_size);
+	}
+
+	msg->reply_error = ret;
+}
+
+static void mt8195_dsp_handle_reply(struct mtk_adsp_ipi *ipi)
+{
+	struct adsp_priv *priv = adsp_ipi_get_data(ipi);
+	unsigned long flags;
+
+	spin_lock_irqsave(&priv->sdev->ipc_lock, flags);
+	mt8195_get_reply(priv->sdev);
+	snd_sof_ipc_reply(priv->sdev, 0);
+	spin_unlock_irqrestore(&priv->sdev->ipc_lock, flags);
+}
+
+static void mt8195_dsp_handle_request(struct mtk_adsp_ipi *ipi)
+{
+	struct adsp_priv *priv = adsp_ipi_get_data(ipi);
+	u32 p; /* panic code */
+
+	/* Read the message from the debug box. */
+	sof_mailbox_read(priv->sdev, priv->sdev->debug_box.offset + 4,
+			 &p, sizeof(p));
+
+	/* Check to see if the message is a panic code 0x0dead*** */
+	if ((p & SOF_IPC_PANIC_MAGIC_MASK) == SOF_IPC_PANIC_MAGIC) {
+		snd_sof_dsp_panic(priv->sdev, p);
+	} else {
+		snd_sof_ipc_msgs_rx(priv->sdev);
+
+		/* tell DSP cmd is done */
+		adsp_ipi_send(priv->sdev, ADSP_IPI_MBOX_RSP, ADSP_IPI_OP_RSP);
+	}
+}
+
+static void mt8195_dsp_handle_debug_message(struct mtk_adsp_ipi *ipi)
+{
+	trace_boot_event = *(u32 *)DSP_MBOX_OUT_MSG0(2);
+}
+
+static struct mtk_adsp_ipi_ops mt8195_ipi_dsp_reply = {
+	.handle_recv		= mt8195_dsp_handle_reply,
+};
+
+static struct mtk_adsp_ipi_ops mt8195_ipi_dsp_request = {
+	.handle_recv		= mt8195_dsp_handle_request,
+};
+
+static struct mtk_adsp_ipi_ops mt8195_debug_dsp_message = {
+	.handle_recv		= mt8195_dsp_handle_debug_message,
+};
+
+
+static irqreturn_t mt8195_ipi_irq_handler(int irq, void *data)
+{
+	struct mbox_chan *ch = (struct mbox_chan *)data;
+	struct adsp_mbox_ch_info *ch_info = ch->con_priv;
+	u32 id = ch_info->id;
+	u32 op = *(u32 *)DSP_MBOX_OUT_CMD(id);
+
+	*(u32 *)DSP_MBOX_OUT_CMD_CLR(id) = op; /* clear DSP->CPU int */
+	return IRQ_WAKE_THREAD;
+}
+
+static irqreturn_t mt8195_ipi_handler(int irq, void *data)
+{
+	struct mbox_chan *ch = (struct mbox_chan *)data;
+	struct adsp_mbox_ch_info *ch_info = ch->con_priv;
+	struct mbox_controller  *mbox = ch->mbox;
+
+	mbox_chan_received_data(ch, ch_info);
+
+	return IRQ_HANDLED;
+}
+
+
+static struct mbox_chan *mt8195_mbox_xlate(struct mbox_controller *mbox,
+					 const struct of_phandle_args *sp)
+{
+	return &mbox->chans[sp->args[0]];
+}
+
+static int mt8195_mbox_startup(struct mbox_chan *chan)
+{
+	struct adsp_mbox_ch_info *ch_info = chan->con_priv;
+	struct device *dev = chan->mbox->dev;
+	struct snd_sof_dev *sdev;
+	struct platform_device *pdev;
+	int ret;
+	int irq;
+	char name[6] = {'m', 'b', 'o', 'x', ' ', 0};
+
+	sdev = ch_info->priv->sdev;
+	pdev = container_of(sdev->dev, struct platform_device, dev);
+
+	name[4] = '0' + ch_info->id;
+
+	irq = platform_get_irq_byname(pdev, name);
+	if (irq < 0) {
+		dev_err(sdev->dev, "Failed to get ipc irq\n");
+		return -ENODEV;
+	}
+
+	ret = devm_request_threaded_irq(dev, irq,
+					mt8195_ipi_irq_handler, mt8195_ipi_handler,
+					IRQF_TRIGGER_NONE, name,
+					chan);
+	if (ret < 0)
+		dev_err(dev, "failed to request irq %d\n", irq);
+
+	return ret;
+}
+
+static void mt8195_mbox_shutdown(struct mbox_chan *chan)
+{
+}
+
+static int mt8195_mbox_send_data(struct mbox_chan *chan, void *data)
+{
+	struct adsp_mbox_ch_info *ch_info = chan->con_priv;
+
+	*(u32 *)DSP_MBOX_IN_CMD(ch_info->id) = ch_info->ipi_op_val;
+
+	return 0;
+}
+
+static bool mt8195_mbox_last_tx_done(struct mbox_chan *chan)
+{
+	return true;
+}
+
+static const struct mbox_chan_ops adsp_mbox_chan_ops = {
+	.send_data	= mt8195_mbox_send_data,
+	.startup	= mt8195_mbox_startup,
+	.shutdown	= mt8195_mbox_shutdown,
+	.last_tx_done	= mt8195_mbox_last_tx_done,
+};
+
+
+int mt8195_mbox_init(struct snd_sof_dev *sdev)
+{
+	struct device *dev = sdev->dev;
+	struct adsp_priv *priv = sdev->pdata->hw_pdata;
+	struct mbox_controller *mbox;
+	int ret;
+	int i;
+
+	mbox = devm_kzalloc(dev, sizeof(*mbox), GFP_KERNEL);
+	if (!mbox)
+		return -ENOMEM;
+
+	priv->adsp_mbox = mbox;
+	mbox->dev = dev;
+	mbox->ops = &adsp_mbox_chan_ops;
+	mbox->txdone_irq = false;
+	mbox->txdone_poll = true;
+	mbox->of_xlate = mt8195_mbox_xlate;
+	mbox->num_chans = DSP_MBOX_NUM;
+	mbox->chans = devm_kcalloc(mbox->dev, mbox->num_chans,
+				   sizeof(*mbox->chans), GFP_KERNEL);
+	if (!mbox->chans)
+		return -ENOMEM;
+
+	for (i = 0; i < mbox->num_chans; i++) {
+		struct adsp_mbox_ch_info *ch_info;
+
+		ch_info = devm_kzalloc(mbox->dev, sizeof(*ch_info), GFP_KERNEL);
+		if (!ch_info)
+			return -ENOMEM;
+
+		ch_info->id = i;
+		ch_info->priv = priv;
+		mbox->chans[i].con_priv = ch_info;
+	}
+
+	ret = mbox_controller_register(mbox);
+	if (ret < 0) {
+		dev_err(dev, "error: failed to register mailbox:%d\n", ret);
+		return ret;
+	}
+
+	// init value;
+	trace_boot_event = 0xffff;
+	adsp_ipi_request(sdev, 0, &mt8195_ipi_dsp_reply);
+	adsp_ipi_request(sdev, 1, &mt8195_ipi_dsp_request);
+	adsp_ipi_request(sdev, 2, &mt8195_debug_dsp_message);
+
+	return ret;
+}
diff --git a/sound/soc/sof/mediatek/mt8195/mt8195-ipc.h b/sound/soc/sof/mediatek/mt8195/mt8195-ipc.h
new file mode 100644
index 0000000000000000000000000000000000000000..bd1f89b381a3ae83812611babb1aa7fda9c0b40e
--- /dev/null
+++ b/sound/soc/sof/mediatek/mt8195/mt8195-ipc.h
@@ -0,0 +1,14 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * Copyright 2021 Mediatek
+ *
+ * Header file for the DSP IPC implementation
+ */
+
+#ifndef MT8195_IPC_H
+#define MT8195_IPC_H
+#include "../../sof-priv.h"
+
+int mt8195_mbox_init(struct snd_sof_dev *sdev);
+
+#endif /* MT8195_IPC_H */
diff --git a/sound/soc/sof/mediatek/mt8195/mt8195-loader.c b/sound/soc/sof/mediatek/mt8195/mt8195-loader.c
new file mode 100644
index 0000000000000000000000000000000000000000..3bdea4428ec6f82ce656c841dc79b18d88b823b0
--- /dev/null
+++ b/sound/soc/sof/mediatek/mt8195/mt8195-loader.c
@@ -0,0 +1,73 @@
+// SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause)
+//
+// Copyright 2021 Mediatek
+//
+// Author: YC Hung <yc.hung@mediatek.com>
+//
+// Hardware interface for mt8195 DSP code loader
+
+#include <linux/firmware.h>
+#include <linux/of_platform.h>
+#include <linux/of_address.h>
+#include <linux/of_irq.h>
+#include <linux/pm_domain.h>
+#include <linux/delay.h>
+
+#include <linux/module.h>
+#include <sound/sof.h>
+#include <sound/sof/xtensa.h>
+#include "mt8195.h"
+
+void hifixdsp_boot_sequence(u32 boot_addr)
+{
+	u32 val;
+
+	/* ADSP bootup base */
+	writel(boot_addr, DSP_ALTRESETVEC);
+
+	/* pull high RunStall (set bit3 to 1) */
+	val = readl(DSP_RESET_SW);
+	val |= (0x1 << RUNSTALL);
+	writel(val, DSP_RESET_SW);
+
+	/* pull high StatVectorSel to use AltResetVec (set bit4 to 1) */
+	val = readl(DSP_RESET_SW);
+	val |= (0x1 << STATVECTOR_SEL);
+	writel(val, DSP_RESET_SW);
+
+	/* toggle  Dreset & BReset */
+	/* pull high DReset & BReset */
+	val = readl(DSP_RESET_SW);
+	val |= (0x1 << BRESET_SW) | (0x1 << DRESET_SW);
+	writel(val, DSP_RESET_SW);
+
+	/* pull low DReset & BReset */
+	val = readl(DSP_RESET_SW);
+	val &= ~((u32)((0x1 << BRESET_SW) | (0x1 << DRESET_SW)));
+	writel(val, DSP_RESET_SW);
+
+	/* Enable PDebug */
+	val = readl(DSP_PDEBUGBUS0);
+	val |= (0x1 << PDEBUG_ENABLE);
+	writel(val, DSP_PDEBUGBUS0);
+
+	/* release RunStall (set bit3 to 0) */
+	val = readl(DSP_RESET_SW);
+	val &= ~((u32)(0x1 << RUNSTALL));
+	writel(val, DSP_RESET_SW);
+}
+
+void hifixdsp_shutdown(void)
+{
+	u32 val;
+
+	/* Clear to 0 firstly */
+	val = 0x0;
+	writel(val, DSP_RESET_SW);
+
+	/* RUN_STALL pull high again to reset */
+	val = readl(DSP_RESET_SW);
+	val |= (0x1 << RUNSTALL);
+	writel(val, DSP_RESET_SW);
+}
+
diff --git a/sound/soc/sof/mediatek/mt8195/mt8195-reg.h b/sound/soc/sof/mediatek/mt8195/mt8195-reg.h
new file mode 100644
index 0000000000000000000000000000000000000000..cd4aedb981d70c15718d197b7548688a3a001592
--- /dev/null
+++ b/sound/soc/sof/mediatek/mt8195/mt8195-reg.h
@@ -0,0 +1,130 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+
+/*
+ * Copyright (c) 2021 MediaTek Inc.
+ *
+ *  Header file for the DSP register definition
+ */
+
+#ifndef __ADSP_REG_H
+#define __ADSP_REG_H
+
+//extern void __iomem *get_adsp_reg_base(void);
+//extern void __iomem *get_mbox_reg_base(u32 id);
+void __iomem *get_adsp_reg_base(void);
+void __iomem *get_mbox_reg_base(u32 id);
+
+#define DSP_REG_BASE         (get_adsp_reg_base())
+#define DSP_MBOX_REG_BASE(x)     (get_mbox_reg_base(x))
+#define DSP_SYSAO_BASE  0x1080C000
+
+/*****************************************************************************
+ *                  R E G I S T E R       TABLE
+ *****************************************************************************/
+#define DSP_JTAGMUX          (DSP_REG_BASE + 0x0000)
+#define DSP_ALTRESETVEC      (DSP_REG_BASE + 0x0004)
+#define DSP_PDEBUGDATA       (DSP_REG_BASE + 0x0008)
+#define DSP_PDEBUGBUS0       (DSP_REG_BASE + 0x000c)
+	#define PDEBUG_ENABLE		 0
+#define DSP_PDEBUGBUS1       (DSP_REG_BASE + 0x0010)
+#define DSP_PDEBUGINST       (DSP_REG_BASE + 0x0014)
+#define DSP_PDEBUGLS0STAT    (DSP_REG_BASE + 0x0018)
+#define DSP_PDEBUGLS1STAT    (DSP_REG_BASE + 0x001c)
+#define DSP_PDEBUGPC         (DSP_REG_BASE + 0x0020)
+#define DSP_RESET_SW         (DSP_REG_BASE + 0x0024)
+	/*reset sw*/
+	#define BRESET_SW			 0
+	#define DRESET_SW			 1
+	#define RUNSTALL			 3
+	#define STATVECTOR_SEL		 4
+#define DSP_PFAULTBUS        (DSP_REG_BASE + 0x0028)
+#define DSP_PFAULTINFO       (DSP_REG_BASE + 0x002c)
+#define DSP_GPR00            (DSP_REG_BASE + 0x0030)
+#define DSP_GPR01            (DSP_REG_BASE + 0x0034)
+#define DSP_GPR02            (DSP_REG_BASE + 0x0038)
+#define DSP_GPR03            (DSP_REG_BASE + 0x003c)
+#define DSP_GPR04            (DSP_REG_BASE + 0x0040)
+#define DSP_GPR05            (DSP_REG_BASE + 0x0044)
+#define DSP_GPR06            (DSP_REG_BASE + 0x0048)
+#define DSP_GPR07            (DSP_REG_BASE + 0x004c)
+#define DSP_GPR08            (DSP_REG_BASE + 0x0050)
+#define DSP_GPR09            (DSP_REG_BASE + 0x0054)
+#define DSP_GPR0A            (DSP_REG_BASE + 0x0058)
+#define DSP_GPR0B            (DSP_REG_BASE + 0x005c)
+#define DSP_GPR0C            (DSP_REG_BASE + 0x0060)
+#define DSP_GPR0D            (DSP_REG_BASE + 0x0064)
+#define DSP_GPR0E            (DSP_REG_BASE + 0x0068)
+#define DSP_GPR0F            (DSP_REG_BASE + 0x006c)
+#define DSP_GPR10            (DSP_REG_BASE + 0x0070)
+#define DSP_GPR11            (DSP_REG_BASE + 0x0074)
+#define DSP_GPR12            (DSP_REG_BASE + 0x0078)
+#define DSP_GPR13            (DSP_REG_BASE + 0x007c)
+#define DSP_GPR14            (DSP_REG_BASE + 0x0080)
+#define DSP_GPR15            (DSP_REG_BASE + 0x0084)
+#define DSP_GPR16            (DSP_REG_BASE + 0x0088)
+#define DSP_GPR17            (DSP_REG_BASE + 0x008c)
+#define DSP_GPR18            (DSP_REG_BASE + 0x0090)
+#define DSP_GPR19            (DSP_REG_BASE + 0x0094)
+#define DSP_GPR1A            (DSP_REG_BASE + 0x0098)
+#define DSP_GPR1B            (DSP_REG_BASE + 0x009c)
+#define DSP_GPR1C            (DSP_REG_BASE + 0x00a0)
+#define DSP_GPR1D            (DSP_REG_BASE + 0x00a4)
+#define DSP_GPR1E            (DSP_REG_BASE + 0x00a8)
+#define DSP_GPR1F            (DSP_REG_BASE + 0x00ac)
+#define DSP_TCM_OFFSET       (DSP_REG_BASE + 0x00b0)    /* not used */
+#define DSP_DDR_OFFSET       (DSP_REG_BASE + 0x00b4)    /* not used */
+#define DSP_INTFDSP          (DSP_REG_BASE + 0x00d0)
+#define DSP_INTFDSP_CLR      (DSP_REG_BASE + 0x00d4)
+#define DSP_SRAM_PD_SW1      (DSP_REG_BASE + 0x00d8)
+#define DSP_SRAM_PD_SW2      (DSP_REG_BASE + 0x00dc)
+#define DSP_OCD              (DSP_REG_BASE + 0x00e0)
+#define DSP_RG_DSP_IRQ_POL   (DSP_REG_BASE + 0x00f0)    /* not used */
+#define DSP_DSP_IRQ_EN       (DSP_REG_BASE + 0x00f4)    /* not used */
+#define DSP_DSP_IRQ_LEVEL    (DSP_REG_BASE + 0x00f8)    /* not used */
+#define DSP_DSP_IRQ_STATUS   (DSP_REG_BASE + 0x00fc)    /* not used */
+#define DSP_RG_INT2CIRQ      (DSP_REG_BASE + 0x0114)
+#define DSP_RG_INT_POL_CTL0  (DSP_REG_BASE + 0x0120)
+#define DSP_RG_INT_EN_CTL0   (DSP_REG_BASE + 0x0130)
+#define DSP_RG_INT_LV_CTL0   (DSP_REG_BASE + 0x0140)
+#define DSP_RG_INT_STATUS0   (DSP_REG_BASE + 0x0150)
+#define DSP_PDEBUGSTATUS0    (DSP_REG_BASE + 0x0200)
+#define DSP_PDEBUGSTATUS1    (DSP_REG_BASE + 0x0204)
+#define DSP_PDEBUGSTATUS2    (DSP_REG_BASE + 0x0208)
+#define DSP_PDEBUGSTATUS3    (DSP_REG_BASE + 0x020c)
+#define DSP_PDEBUGSTATUS4    (DSP_REG_BASE + 0x0210)
+#define DSP_PDEBUGSTATUS5    (DSP_REG_BASE + 0x0214)
+#define DSP_PDEBUGSTATUS6    (DSP_REG_BASE + 0x0218)
+#define DSP_PDEBUGSTATUS7    (DSP_REG_BASE + 0x021c)
+#define DSP_DSP2PSRAM_PRIORITY           (DSP_REG_BASE + 0x0220)  /* not used */
+#define DSP_AUDIO_DSP2SPM_INT            (DSP_REG_BASE + 0x0224)
+#define DSP_AUDIO_DSP2SPM_INT_ACK        (DSP_REG_BASE + 0x0228)
+#define DSP_AUDIO_DSP_DEBUG_SEL          (DSP_REG_BASE + 0x022C)
+#define DSP_AUDIO_DSP_EMI_BASE_ADDR      (DSP_REG_BASE + 0x02E0)  /* not used */
+#define DSP_AUDIO_DSP_SHARED_IRAM        (DSP_REG_BASE + 0x02E4)
+#define DSP_AUDIO_DSP_CKCTRL_P2P_CK_CON  (DSP_REG_BASE + 0x02F0)
+#define DSP_RG_SEMAPHORE00   (DSP_REG_BASE + 0x0300)
+#define DSP_RG_SEMAPHORE01   (DSP_REG_BASE + 0x0304)
+#define DSP_RG_SEMAPHORE02   (DSP_REG_BASE + 0x0308)
+#define DSP_RG_SEMAPHORE03   (DSP_REG_BASE + 0x030C)
+#define DSP_RG_SEMAPHORE04   (DSP_REG_BASE + 0x0310)
+#define DSP_RG_SEMAPHORE05   (DSP_REG_BASE + 0x0314)
+#define DSP_RG_SEMAPHORE06   (DSP_REG_BASE + 0x0318)
+#define DSP_RG_SEMAPHORE07   (DSP_REG_BASE + 0x031C)
+#define DSP_RESERVED_0       (DSP_REG_BASE + 0x03F0)
+#define DSP_RESERVED_1       (DSP_REG_BASE + 0x03F4)
+
+/* dsp wdt */
+#define DSP_WDT_MODE         (DSP_REG_BASE + 0x0400)
+
+#define DSP_MBOX_NUM			3
+#define DSP_MBOX_IN_CMD(x)		(DSP_MBOX_REG_BASE(x) + 0x0)
+#define DSP_MBOX_IN_CMD_CLR(x)		(DSP_MBOX_REG_BASE(x) + 0x04)
+#define DSP_MBOX_OUT_CMD(x)		(DSP_MBOX_REG_BASE(x) + 0x1c)
+#define DSP_MBOX_OUT_CMD_CLR(x)		(DSP_MBOX_REG_BASE(x) + 0x20)
+
+#define DSP_MBOX_IN_MSG0(x)		(DSP_MBOX_REG_BASE(x) + 0x08)
+#define DSP_MBOX_IN_MSG1(x)		(DSP_MBOX_REG_BASE(x) + 0x0C)
+
+#define DSP_MBOX_OUT_MSG0(x)		(DSP_MBOX_REG_BASE(x) + 0x24)
+#define DSP_MBOX_OUT_MSG1(x)		(DSP_MBOX_REG_BASE(x) + 0x28)
+#endif
diff --git a/sound/soc/sof/mediatek/mt8195/mt8195.c b/sound/soc/sof/mediatek/mt8195/mt8195.c
new file mode 100644
index 0000000000000000000000000000000000000000..414eb4c4e009e5ab6880a606988d1dfbf36699d8
--- /dev/null
+++ b/sound/soc/sof/mediatek/mt8195/mt8195.c
@@ -0,0 +1,650 @@
+// SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause)
+//
+// Copyright(c) 2021 Mediatek Inc. All rights reserved.
+//
+// Author: YC Hung <yc.hung@mediatek.com>
+//
+
+/*
+ * Hardware interface for audio DSP on mt8195
+ */
+
+#include <linux/firmware.h>
+#include <linux/of_platform.h>
+#include <linux/of_address.h>
+#include <linux/of_irq.h>
+#include <linux/pm_domain.h>
+#include <linux/delay.h>
+#include <linux/of_reserved_mem.h>
+
+#include <linux/module.h>
+#include <sound/sof.h>
+#include <sound/sof/xtensa.h>
+#include "mt8195-ipc.h"
+#include "../adsp_helper.h"
+#include "mt8195.h"
+#include "mt8195-clk.h"
+#include "../../ops.h"
+#include "../../sof-audio.h"
+
+static struct adsp_chip_info *adsp_info;
+
+static struct snd_soc_acpi_mach sof_mt8195_mach = {
+	.id = "819501",
+	.drv_name = "mt8195_mt6359_rt1019_rt5682",
+	.sof_tplg_filename = "sof-mt8195-mt6359-rt1019-rt5682.tplg",
+};
+
+static void *get_adsp_chip_data(void)
+{
+	return (void *)adsp_info;
+}
+
+void __iomem *get_adsp_reg_base(void)
+{
+	struct adsp_chip_info *adsp;
+
+	adsp = get_adsp_chip_data();
+	if (!adsp)
+		return NULL;
+
+	return adsp->va_cfgreg;
+}
+EXPORT_SYMBOL(get_adsp_reg_base);
+
+void __iomem *get_mbox_reg_base(u32 id)
+{
+	struct adsp_chip_info *adsp;
+
+	adsp = get_adsp_chip_data();
+	if (!adsp)
+		return NULL;
+
+	if (id >= DSP_MBOX_NUM)
+		return NULL;
+
+	return adsp->va_mboxreg[id];
+}
+EXPORT_SYMBOL(get_mbox_reg_base);
+
+static int mt8195_get_mailbox_offset(struct snd_sof_dev *sdev)
+{
+	return MBOX_OFFSET;
+}
+
+static int mt8195_get_window_offset(struct snd_sof_dev *sdev, u32 id)
+{
+	return MBOX_OFFSET;
+}
+
+
+static int mt8195_ipi_init(struct snd_sof_dev *sdev)
+{
+	int ret;
+
+	ret = mt8195_mbox_init(sdev);
+	if (ret < 0) {
+		dev_err(sdev->dev, "error: failed to init adsp ipi device:%d\n",
+			ret);
+		return ret;
+	}
+
+	return ret;
+}
+
+static int mt8195_send_msg(struct snd_sof_dev *sdev,
+			   struct snd_sof_ipc_msg *msg)
+{
+	sof_mailbox_write(sdev, sdev->host_box.offset, msg->msg_data,
+			  msg->msg_size);
+
+	adsp_ipi_send(sdev, ADSP_IPI_MBOX_REQ, ADSP_IPI_OP_REQ);
+
+	return 0;
+}
+
+static int platform_parse_resource(struct platform_device *pdev, void *data)
+{
+	int ret = 0;
+	struct resource *res;
+	struct resource resource;
+	struct device_node *mem_region;
+	struct device *dev = &pdev->dev;
+	struct adsp_chip_info *adsp = data;
+	int i = 0;
+
+	res = &resource;
+	mem_region = of_parse_phandle(dev->of_node, "memory-region", 0);
+	if (!mem_region) {
+		dev_info(dev, "no 'memory-region' phandle\n");
+		return -ENODEV;
+	}
+
+	ret = of_address_to_resource(mem_region, 0, res);
+	if (ret) {
+		dev_info(dev, "of_address_to_resource failed\n");
+		return ret;
+	}
+
+	dev_info(dev, "[ADSP][DMA] pbase=0x%x, size=0x%x\n",
+		 (phys_addr_t)res->start,
+		 resource_size(res));
+
+	ret = of_reserved_mem_device_init(dev);
+
+	if (ret) {
+		dev_info(dev, "of_reserved_mem_device_init failed\n");
+		return ret;
+	}
+
+	mem_region = of_parse_phandle(dev->of_node, "memory-region", 1);
+	if (!mem_region) {
+		dev_info(dev, "no 'memory-region' phandle\n");
+		return -ENODEV;
+	}
+
+	ret = of_address_to_resource(mem_region, 0, res);
+	if (ret) {
+		dev_info(dev, "of_address_to_resource failed\n");
+		return ret;
+	}
+
+	adsp->pa_dram = (phys_addr_t)res->start;
+	adsp->dramsize = (u32)resource_size(res);
+
+	if (((u32)adsp->pa_dram) & 0x1000) {
+		dev_info(dev, "adsp memory(0x%x) is not 4K-aligned\n",
+			 (u32)adsp->pa_dram);
+		return -EINVAL;
+	}
+
+	if (adsp->dramsize < TOTAL_SIZE_SHARED_DRAM_FROM_TAIL) {
+		dev_info(dev, "adsp memroy(0x%x) is not enough for share\n",
+			 (u32)adsp->dramsize);
+		return -EINVAL;
+	}
+
+	dev_info(dev, "[ADSP] dram pbase=%pa, dramsize=0x%x\n",
+		 &adsp->pa_dram,
+		 adsp->dramsize);
+
+	/* Parse CFG base */
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		dev_info(dev, "no ADSP-CFG register resource\n");
+		return -ENXIO;
+	}
+	/* remap for DSP register accessing */
+	adsp->va_cfgreg = devm_ioremap_resource(dev, res);
+	if (IS_ERR(adsp->va_cfgreg))
+		return PTR_ERR(adsp->va_cfgreg);
+
+	adsp->pa_cfgreg = (phys_addr_t)res->start;
+	adsp->cfgregsize = (u32)resource_size(res);
+
+	dev_info(dev, "[ADSP] cfgreg-vbase=%p, cfgregsize=0x%x\n",
+		 adsp->va_cfgreg, adsp->cfgregsize);
+
+	/* Parse SRAM */
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 1);
+	if (!res) {
+		dev_info(dev, "no SRAM resource\n");
+		return -ENXIO;
+	}
+	adsp->pa_sram = (phys_addr_t)res->start;
+	adsp->srammsize = (u32)resource_size(res);
+	if (adsp->srammsize < TOTAL_SIZE_SHARED_SRAM_FROM_TAIL) {
+		dev_info(dev, "adsp SRAM(0x%x) is not enough for share\n",
+			 (u32)adsp->srammsize);
+		return -EINVAL;
+	}
+
+	dev_info(dev, "[ADSP] sram pbase=%pa,0x%x\n", &adsp->pa_sram,
+		 adsp->srammsize);
+
+	/* Parse MBOX base */
+	for (i = 0; i < DSP_MBOX_NUM; i++) {
+		res = platform_get_resource(pdev, IORESOURCE_MEM, 2 + i);
+		if (!res) {
+			dev_err(dev, "no MBOX resource %d\n", i);
+			return -ENXIO;
+		}
+
+		adsp->pa_mboxreg[i] = (phys_addr_t)res->start;
+		adsp->va_mboxreg[i] = devm_ioremap_resource(dev, res);
+		if (IS_ERR(adsp->va_mboxreg[i]))
+			return PTR_ERR(adsp->va_mboxreg[i]);
+
+		dev_info(dev, "[ADSP]MBOX%d pa_mboxreg:%pa, va_mboxreg:%p\n",
+			 i, &adsp->pa_mboxreg[i], adsp->va_mboxreg[i]);
+	}
+
+	return ret;
+}
+
+/*  Init the basic DSP DRAM address */
+static int adsp_memory_remap_init(struct device *dev)
+{
+	int err = 0;
+	void __iomem *vaddr_emi_map;
+	struct adsp_chip_info *adsp;
+	int offset;
+
+	adsp = get_adsp_chip_data();
+	dev_info(dev, "%s: 0x%llx\n", __func__, adsp->pa_dram);
+
+	if (!adsp)
+		return -EBUSY;
+
+	vaddr_emi_map = devm_ioremap(dev, DSP_EMI_MAP_ADDR, 0x4);
+	if (!vaddr_emi_map) {
+		dev_err(dev, "error: failed to ioremap emi map base 0x%x\n",
+			DSP_EMI_MAP_ADDR);
+		return -ENOMEM;
+	}
+
+	offset = adsp->pa_dram - DRAM_PHYS_BASE_FROM_DSP_VIEW;
+	adsp->dram_offset  =  offset;
+	offset >>= 12;
+	dev_info(dev, "adsp->pa_dram %llx, offset 0x%x\n", adsp->pa_dram,
+		 offset);
+	WARN_ON(offset < 0);
+	writel(offset, vaddr_emi_map);
+	dev_info(dev, "After vaddr_emi_map 0x%x\n", readl(vaddr_emi_map));
+
+	return err;
+}
+
+static int adsp_shared_base_ioremap(struct platform_device *pdev, void *data)
+{
+	int ret = 0;
+	u32 shared_size;
+	struct device *dev = &pdev->dev;
+	struct adsp_chip_info *adsp = data;
+
+	/* remap shared-dram base to be non-cachable */
+	shared_size = TOTAL_SIZE_SHARED_DRAM_FROM_TAIL;
+	//adsp->pa_shared_dram = adsp->pa_dram + DSP_DRAM_SIZE ;
+	adsp->pa_shared_dram = adsp->pa_dram + adsp->dramsize - shared_size;
+	if (adsp->va_dram) {
+		adsp->shared_dram = adsp->va_dram + DSP_DRAM_SIZE - shared_size;
+	} else {
+		adsp->shared_dram = devm_ioremap(dev, adsp->pa_shared_dram,
+						 shared_size);
+		if (!adsp->shared_dram) {
+			dev_info(dev, "ioremap failed at line %d\n", __LINE__);
+			ret = -ENOMEM;
+			goto tail;
+		}
+	}
+	dev_info(dev, "[ADSP] shared-dram vbase=%p, phy addr :%llx,  size=0x%x\n",
+		 adsp->shared_dram, adsp->pa_shared_dram, shared_size);
+tail:
+	return ret;
+}
+
+static int mt8195_run(struct snd_sof_dev *sdev)
+{
+	u32 adsp_bootup_addr;
+	int ret = 0;
+
+	adsp_bootup_addr = SRAM_PHYS_BASE_FROM_DSP_VIEW;
+	dev_info(sdev->dev, "[ADSP] HIFIxDSP boot from base : 0x%08X\n",
+		adsp_bootup_addr);
+	hifixdsp_boot_sequence(adsp_bootup_addr);
+
+	return ret;
+}
+
+/* TODO temp use, we hope a formal api can convert all the address */
+static u32 dram_remap_to_dsp(u32 dram_addr)
+{
+	struct adsp_chip_info *adsp = get_adsp_chip_data();
+	u32 dsp_dram_addr;
+
+	dsp_dram_addr = dram_addr - adsp->dram_offset;
+
+	return dsp_dram_addr;
+}
+
+static u32 dram_remap_to_ap(u32 dram_addr)
+{
+	struct adsp_chip_info *adsp = get_adsp_chip_data();
+	u32 dsp_dram_addr;
+
+	dsp_dram_addr = dram_addr + adsp->dram_offset;
+
+	return dsp_dram_addr;
+}
+
+static int mt8195_dsp_probe(struct snd_sof_dev *sdev)
+{
+	struct platform_device *pdev =
+		container_of(sdev->dev, struct platform_device, dev);
+	struct adsp_priv *priv;
+	struct adsp_mem share_dram;
+	int ret = 0, mailbox_type;
+
+	priv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	sdev->pdata->hw_pdata = priv;
+	priv->dev = sdev->dev;
+	priv->sdev = sdev;
+	dev_info(sdev->dev, "%s\n", __func__);
+
+	priv->adsp = devm_kzalloc(&pdev->dev, sizeof(struct adsp_chip_info),
+				  GFP_KERNEL);
+
+	if (!priv->adsp)
+		return -ENOMEM;
+
+	adsp_info = priv->adsp;
+
+	ret = platform_parse_resource(pdev, adsp_info);
+	if (ret) {
+		dev_err(sdev->dev, "platform_parse_resource failed\n");
+		return ret;
+	}
+
+	ret = platform_parse_clock(&pdev->dev);
+	if (ret) {
+		dev_err(sdev->dev, "platform_parse_clock failed\n");
+		return -EINVAL;
+	}
+
+	pm_runtime_enable(&pdev->dev);
+	pm_runtime_get_sync(&pdev->dev);
+
+	ret = adsp_clock_on(&pdev->dev);
+	if (ret) {
+		dev_err(sdev->dev, "adsp_clock_on fail!\n");
+		goto err_pm_disable;
+
+	}
+
+	ret = adsp_sram_power_on(sdev->dev, true);
+	if (ret) {
+		dev_err(sdev->dev, "adsp_sram_power_on fail!\n");
+		ret = -EINVAL;
+		goto err_pm_disable;
+	}
+
+	ret =  adsp_memory_remap_init(&pdev->dev);
+	if (ret) {
+		dev_err(sdev->dev, "adsp_memory_remap_init fail!\n");
+		ret = -EINVAL;
+		goto err_pm_disable;
+	}
+
+	ret = mt8195_ipi_init(sdev);
+	if (ret < 0) {
+		dev_err(sdev->dev, "error: failed to init adsp ipi:%d\n", ret);
+		goto err_pm_disable;
+
+	}
+
+	sdev->bar[SOF_FW_BLK_TYPE_IRAM] = devm_ioremap(sdev->dev,
+						       priv->adsp->pa_sram,
+						       priv->adsp->srammsize);
+	if (!sdev->bar[SOF_FW_BLK_TYPE_IRAM]) {
+		dev_err(sdev->dev, "failed to ioremap base %pa size 0x%x\n",
+			&priv->adsp->pa_sram, priv->adsp->srammsize);
+		ret = -EINVAL;
+		goto err_pm_disable;
+	}
+
+#ifdef ADSP_USE_DRAM
+	sdev->bar[SOF_FW_BLK_TYPE_SRAM] = devm_ioremap_wc(sdev->dev,
+							  priv->adsp->pa_dram,
+							  priv->adsp->dramsize);
+	if (!sdev->bar[SOF_FW_BLK_TYPE_SRAM]) {
+		dev_err(sdev->dev, "failed to ioremap base %pa size 0x%x\n",
+			&priv->adsp->pa_dram, priv->adsp->dramsize);
+		ret = -EINVAL;
+		goto err_pm_disable;
+	}
+	adsp_info->va_dram = sdev->bar[SOF_FW_BLK_TYPE_SRAM];
+	mailbox_type = SOF_FW_BLK_TYPE_SRAM;
+#else
+	mailbox_type = SOF_FW_BLK_TYPE_IRAM;
+#endif
+
+	ret = adsp_shared_base_ioremap(pdev, adsp_info);
+	if (ret) {
+		dev_err(sdev->dev, "adsp_shared_base_ioremap fail!\n");
+		ret = -EINVAL;
+		goto err_pm_disable;
+	}
+
+	sdev->mmio_bar = mailbox_type;
+	sdev->mailbox_bar = mailbox_type;
+
+	/* set default mailbox offset for FW ready message */
+	sdev->dsp_box.offset = mt8195_get_mailbox_offset(sdev);
+
+	/* TODO temp use */
+	priv->adsp2ap_addr = dram_remap_to_ap;
+	priv->ap2adsp_addr = dram_remap_to_dsp;
+	share_dram.phy_addr = priv->adsp->pa_shared_dram;
+	share_dram.va_addr = (unsigned long long)priv->adsp->shared_dram;
+	share_dram.vir_addr = (unsigned char *)priv->adsp->shared_dram;
+	share_dram.size = SIZE_SHARED_DRAM_UL + SIZE_SHARED_DRAM_DL;
+
+	ret = adsp_genpool_create(&priv->mem_pool, &share_dram);
+	if (ret) {
+		dev_err(sdev->dev, "adsp_genpool_create fail!\n");
+		ret = -ENOMEM;
+		goto err_pm_disable;
+	}
+
+err_pm_disable:
+	pm_runtime_disable(&pdev->dev);
+
+	return ret;
+}
+
+static int mt8195_dsp_remove(struct snd_sof_dev *sdev)
+{
+	struct platform_device *pdev =
+		container_of(sdev->dev, struct platform_device, dev);
+	struct adsp_priv *priv = sdev->pdata->hw_pdata;
+
+	dev_info(sdev->dev, "%s\n", __func__);
+
+	adsp_clock_off(&pdev->dev);
+	adsp_sram_power_on(&pdev->dev, false);
+	pm_runtime_put_sync(&pdev->dev);
+	adsp_genpool_destroy(&priv->mem_pool);
+	return 0;
+}
+
+static int mt8195_dsp_suspend(struct snd_sof_dev *sdev, u32 target_state)
+{
+	struct platform_device *pdev =
+		container_of(sdev->dev, struct platform_device, dev);
+
+	dev_info(sdev->dev, "%s\n", __func__);
+
+	/*stall and reset dsp*/
+	hifixdsp_shutdown();
+
+	/*turn off adsp clock*/
+	adsp_clock_off(&pdev->dev);
+
+	/*power down adsp sram*/
+	adsp_sram_power_on(&pdev->dev, false);
+
+	/* power down DSP */
+	pm_runtime_put_sync(&pdev->dev);
+
+	return 0;
+}
+
+static int mt8195_dsp_resume(struct snd_sof_dev *sdev)
+{
+	struct platform_device *pdev =
+		container_of(sdev->dev, struct platform_device, dev);
+	int ret = 0;
+
+	dev_info(sdev->dev, "%s pm_runtime_enable\n", __func__);
+
+	/* power on DSP */
+	pm_runtime_get_sync(&pdev->dev);
+
+	/*turn on adsp clock*/
+	ret = adsp_clock_on(&pdev->dev);
+	if (ret) {
+		dev_err(sdev->dev, "adsp_clock_on fail!\n");
+		return -EINVAL;
+	}
+
+	/*power on adsp sram*/
+	ret = adsp_sram_power_on(sdev->dev, true);
+	if (ret) {
+		dev_err(sdev->dev, "[ADSP] adsp_sram_power_on fail!\n");
+		return -EINVAL;
+	}
+
+	return ret;
+}
+
+/* mt8195 mapping between type and BAR idx */
+static int mt8195_get_bar_index(struct snd_sof_dev *sdev, u32 type)
+{
+#ifndef ADSP_USE_DRAM
+	if (type == SOF_FW_BLK_TYPE_SRAM)
+		type = SOF_FW_BLK_TYPE_IRAM;
+#endif
+	return type;
+}
+
+static void mt8195_ipc_msg_data(struct snd_sof_dev *sdev,
+				struct snd_pcm_substream *substream,
+				void *p, size_t sz)
+{
+	sof_mailbox_read(sdev, sdev->dsp_box.offset, p, sz);
+}
+
+static int mt8195_ipc_pcm_params(struct snd_sof_dev *sdev,
+				 struct snd_pcm_substream *substream,
+				 const struct sof_ipc_pcm_params_reply *reply)
+{
+	return 0;
+}
+
+static void mt8195_machine_select(struct snd_sof_dev *sdev)
+{
+	struct snd_sof_pdata *sof_pdata = sdev->pdata;
+	struct snd_soc_acpi_mach *mach;
+
+	mach = &sof_mt8195_mach;
+	if (!mach) {
+		dev_warn(sdev->dev, "warning: No matching ASoC machine driver found\n");
+		return;
+	}
+
+	sof_pdata->tplg_filename = mach->sof_tplg_filename;
+	sof_pdata->machine = mach;
+
+	/* get machine node and save it to mach->pdata */
+	mach->pdata = of_get_child_by_name(sdev->dev->of_node, "sound");
+	if (!mach->pdata)
+		dev_warn(sdev->dev, "warning: get child machine node \"sound\" failed\n");
+}
+
+static struct snd_soc_dai_driver mt8195_dai[] = {
+{
+	.name = "SOF_DL2",
+	.playback = {
+		.channels_min = 1,
+		.channels_max = 2,
+	},
+},
+{
+	.name = "SOF_DL3",
+	.playback = {
+		.channels_min = 1,
+		.channels_max = 2,
+	},
+},
+{
+	.name = "SOF_UL4",
+	.capture = {
+		.channels_min = 1,
+		.channels_max = 2,
+	},
+},
+{
+	.name = "SOF_UL5",
+	.capture = {
+		.channels_min = 1,
+		.channels_max = 2,
+	},
+},
+};
+
+/* mt8195 ops */
+struct snd_sof_dsp_ops sof_mt8195_ops = {
+	/* probe and remove */
+	.probe		= mt8195_dsp_probe,
+	.remove		= mt8195_dsp_remove,
+	/* DSP core boot */
+	.run		= mt8195_run,
+
+	/* Block IO */
+	.block_read	= sof_block_read,
+	.block_write	= sof_block_write,
+
+	/* Module IO */
+	.read64	= sof_io_read64,
+
+	/* ipc */
+	.send_msg	= mt8195_send_msg,
+	.fw_ready	= sof_fw_ready,
+	.get_mailbox_offset	= mt8195_get_mailbox_offset,
+	.get_window_offset	= mt8195_get_window_offset,
+
+	.ipc_msg_data	= mt8195_ipc_msg_data,
+	.ipc_pcm_params	= mt8195_ipc_pcm_params,
+
+	/* machine driver */
+	.machine_select = mt8195_machine_select,
+	.machine_register = sof_machine_register,
+
+	/* module loading */
+	.load_module	= snd_sof_parse_module_memcpy,
+	.get_bar_index	= mt8195_get_bar_index,
+	/* firmware loading */
+	.load_firmware	= snd_sof_load_firmware_memcpy,
+
+	/* Debug information */
+	//.dbg_dump = mt8195_dump,
+
+	/* stream callbacks */
+	.pcm_hw_params	= adsp_pcm_hw_params,
+	.pcm_hw_free	= adsp_pcm_hw_free,
+
+	/* Firmware ops */
+	.arch_ops = &sof_xtensa_arch_ops,
+
+	/* DAI drivers */
+	.drv = mt8195_dai,
+	.num_drv = ARRAY_SIZE(mt8195_dai),
+
+	/* PM */
+	.suspend		= mt8195_dsp_suspend,
+	.resume			= mt8195_dsp_resume,
+
+	/* ALSA HW info flags */
+	.hw_info =	SNDRV_PCM_INFO_MMAP |
+			SNDRV_PCM_INFO_MMAP_VALID |
+			SNDRV_PCM_INFO_INTERLEAVED |
+			SNDRV_PCM_INFO_PAUSE |
+			SNDRV_PCM_INFO_NO_PERIOD_WAKEUP,
+};
+EXPORT_SYMBOL(sof_mt8195_ops);
+
+MODULE_IMPORT_NS(SND_SOC_SOF_XTENSA);
+MODULE_LICENSE("Dual BSD/GPL");
diff --git a/sound/soc/sof/mediatek/mt8195/mt8195.h b/sound/soc/sof/mediatek/mt8195/mt8195.h
new file mode 100644
index 0000000000000000000000000000000000000000..298a279c2afdd238b0b43f6ed67e167568c01a07
--- /dev/null
+++ b/sound/soc/sof/mediatek/mt8195/mt8195.h
@@ -0,0 +1,167 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+
+/*
+ * Copyright (c) 2021 MediaTek Inc.
+ *
+ *  Header file for the mt8195 DSP register definition
+ */
+
+#ifndef __MT8195_H
+#define __MT8195_H
+
+#define ADSP_USE_DRAM
+//extern void __iomem *get_adsp_reg_base(void);
+//extern void __iomem *get_mbox_reg_base(u32 id);
+
+void __iomem *get_adsp_reg_base(void);
+void __iomem *get_mbox_reg_base(u32 id);
+
+#define DSP_REG_BASE         (get_adsp_reg_base())
+#define DSP_MBOX_REG_BASE(x)     (get_mbox_reg_base(x))
+
+#define SCP_CFGREG_BASE  0x10724000
+#define DSP_SYSAO_BASE  0x1080C000
+
+/*****************************************************************************
+ *                  R E G I S T E R       TABLE
+ *****************************************************************************/
+#define DSP_JTAGMUX          (DSP_REG_BASE + 0x0000)
+#define DSP_ALTRESETVEC      (DSP_REG_BASE + 0x0004)
+#define DSP_PDEBUGDATA       (DSP_REG_BASE + 0x0008)
+#define DSP_PDEBUGBUS0       (DSP_REG_BASE + 0x000c)
+	#define PDEBUG_ENABLE		 0
+#define DSP_PDEBUGBUS1       (DSP_REG_BASE + 0x0010)
+#define DSP_PDEBUGINST       (DSP_REG_BASE + 0x0014)
+#define DSP_PDEBUGLS0STAT    (DSP_REG_BASE + 0x0018)
+#define DSP_PDEBUGLS1STAT    (DSP_REG_BASE + 0x001c)
+#define DSP_PDEBUGPC         (DSP_REG_BASE + 0x0020)
+#define DSP_RESET_SW         (DSP_REG_BASE + 0x0024)
+	/*reset sw*/
+	#define BRESET_SW			 0
+	#define DRESET_SW			 1
+	#define RUNSTALL			 3
+	#define STATVECTOR_SEL		 4
+#define DSP_PFAULTBUS        (DSP_REG_BASE + 0x0028)
+#define DSP_PFAULTINFO       (DSP_REG_BASE + 0x002c)
+#define DSP_GPR00            (DSP_REG_BASE + 0x0030)
+#define DSP_GPR01            (DSP_REG_BASE + 0x0034)
+#define DSP_GPR02            (DSP_REG_BASE + 0x0038)
+#define DSP_GPR03            (DSP_REG_BASE + 0x003c)
+#define DSP_GPR04            (DSP_REG_BASE + 0x0040)
+#define DSP_GPR05            (DSP_REG_BASE + 0x0044)
+#define DSP_GPR06            (DSP_REG_BASE + 0x0048)
+#define DSP_GPR07            (DSP_REG_BASE + 0x004c)
+#define DSP_GPR08            (DSP_REG_BASE + 0x0050)
+#define DSP_GPR09            (DSP_REG_BASE + 0x0054)
+#define DSP_GPR0A            (DSP_REG_BASE + 0x0058)
+#define DSP_GPR0B            (DSP_REG_BASE + 0x005c)
+#define DSP_GPR0C            (DSP_REG_BASE + 0x0060)
+#define DSP_GPR0D            (DSP_REG_BASE + 0x0064)
+#define DSP_GPR0E            (DSP_REG_BASE + 0x0068)
+#define DSP_GPR0F            (DSP_REG_BASE + 0x006c)
+#define DSP_GPR10            (DSP_REG_BASE + 0x0070)
+#define DSP_GPR11            (DSP_REG_BASE + 0x0074)
+#define DSP_GPR12            (DSP_REG_BASE + 0x0078)
+#define DSP_GPR13            (DSP_REG_BASE + 0x007c)
+#define DSP_GPR14            (DSP_REG_BASE + 0x0080)
+#define DSP_GPR15            (DSP_REG_BASE + 0x0084)
+#define DSP_GPR16            (DSP_REG_BASE + 0x0088)
+#define DSP_GPR17            (DSP_REG_BASE + 0x008c)
+#define DSP_GPR18            (DSP_REG_BASE + 0x0090)
+#define DSP_GPR19            (DSP_REG_BASE + 0x0094)
+#define DSP_GPR1A            (DSP_REG_BASE + 0x0098)
+#define DSP_GPR1B            (DSP_REG_BASE + 0x009c)
+#define DSP_GPR1C            (DSP_REG_BASE + 0x00a0)
+#define DSP_GPR1D            (DSP_REG_BASE + 0x00a4)
+#define DSP_GPR1E            (DSP_REG_BASE + 0x00a8)
+#define DSP_GPR1F            (DSP_REG_BASE + 0x00ac)
+#define DSP_TCM_OFFSET       (DSP_REG_BASE + 0x00b0)    /* not used */
+#define DSP_DDR_OFFSET       (DSP_REG_BASE + 0x00b4)    /* not used */
+#define DSP_INTFDSP          (DSP_REG_BASE + 0x00d0)
+#define DSP_INTFDSP_CLR      (DSP_REG_BASE + 0x00d4)
+#define DSP_SRAM_PD_SW1      (DSP_REG_BASE + 0x00d8)
+#define DSP_SRAM_PD_SW2      (DSP_REG_BASE + 0x00dc)
+#define DSP_OCD              (DSP_REG_BASE + 0x00e0)
+#define DSP_RG_DSP_IRQ_POL   (DSP_REG_BASE + 0x00f0)    /* not used */
+#define DSP_DSP_IRQ_EN       (DSP_REG_BASE + 0x00f4)    /* not used */
+#define DSP_DSP_IRQ_LEVEL    (DSP_REG_BASE + 0x00f8)    /* not used */
+#define DSP_DSP_IRQ_STATUS   (DSP_REG_BASE + 0x00fc)    /* not used */
+#define DSP_RG_INT2CIRQ      (DSP_REG_BASE + 0x0114)
+#define DSP_RG_INT_POL_CTL0  (DSP_REG_BASE + 0x0120)
+#define DSP_RG_INT_EN_CTL0   (DSP_REG_BASE + 0x0130)
+#define DSP_RG_INT_LV_CTL0   (DSP_REG_BASE + 0x0140)
+#define DSP_RG_INT_STATUS0   (DSP_REG_BASE + 0x0150)
+#define DSP_PDEBUGSTATUS0    (DSP_REG_BASE + 0x0200)
+#define DSP_PDEBUGSTATUS1    (DSP_REG_BASE + 0x0204)
+#define DSP_PDEBUGSTATUS2    (DSP_REG_BASE + 0x0208)
+#define DSP_PDEBUGSTATUS3    (DSP_REG_BASE + 0x020c)
+#define DSP_PDEBUGSTATUS4    (DSP_REG_BASE + 0x0210)
+#define DSP_PDEBUGSTATUS5    (DSP_REG_BASE + 0x0214)
+#define DSP_PDEBUGSTATUS6    (DSP_REG_BASE + 0x0218)
+#define DSP_PDEBUGSTATUS7    (DSP_REG_BASE + 0x021c)
+#define DSP_DSP2PSRAM_PRIORITY           (DSP_REG_BASE + 0x0220)  /* not used */
+#define DSP_AUDIO_DSP2SPM_INT            (DSP_REG_BASE + 0x0224)
+#define DSP_AUDIO_DSP2SPM_INT_ACK        (DSP_REG_BASE + 0x0228)
+#define DSP_AUDIO_DSP_DEBUG_SEL          (DSP_REG_BASE + 0x022C)
+#define DSP_AUDIO_DSP_EMI_BASE_ADDR      (DSP_REG_BASE + 0x02E0)  /* not used */
+#define DSP_AUDIO_DSP_SHARED_IRAM        (DSP_REG_BASE + 0x02E4)
+#define DSP_AUDIO_DSP_CKCTRL_P2P_CK_CON  (DSP_REG_BASE + 0x02F0)
+#define DSP_RG_SEMAPHORE00   (DSP_REG_BASE + 0x0300)
+#define DSP_RG_SEMAPHORE01   (DSP_REG_BASE + 0x0304)
+#define DSP_RG_SEMAPHORE02   (DSP_REG_BASE + 0x0308)
+#define DSP_RG_SEMAPHORE03   (DSP_REG_BASE + 0x030C)
+#define DSP_RG_SEMAPHORE04   (DSP_REG_BASE + 0x0310)
+#define DSP_RG_SEMAPHORE05   (DSP_REG_BASE + 0x0314)
+#define DSP_RG_SEMAPHORE06   (DSP_REG_BASE + 0x0318)
+#define DSP_RG_SEMAPHORE07   (DSP_REG_BASE + 0x031C)
+#define DSP_RESERVED_0       (DSP_REG_BASE + 0x03F0)
+#define DSP_RESERVED_1       (DSP_REG_BASE + 0x03F4)
+
+/* dsp wdt */
+#define DSP_WDT_MODE         (DSP_REG_BASE + 0x0400)
+
+/* dsp mbox */
+#define DSP_MBOX_IN_CMD(x)		(DSP_MBOX_REG_BASE(x) + 0x0)
+#define DSP_MBOX_IN_CMD_CLR(x)		(DSP_MBOX_REG_BASE(x) + 0x04)
+#define DSP_MBOX_OUT_CMD(x)		(DSP_MBOX_REG_BASE(x) + 0x1c)
+#define DSP_MBOX_OUT_CMD_CLR(x)		(DSP_MBOX_REG_BASE(x) + 0x20)
+
+#define DSP_MBOX_IN_MSG0(x)		(DSP_MBOX_REG_BASE(x) + 0x08)
+#define DSP_MBOX_IN_MSG1(x)		(DSP_MBOX_REG_BASE(x) + 0x0C)
+#define DSP_MBOX_OUT_MSG0(x)		(DSP_MBOX_REG_BASE(x) + 0x24)
+#define DSP_MBOX_OUT_MSG1(x)		(DSP_MBOX_REG_BASE(x) + 0x28)
+
+/*dsp sys ao*/
+#define ADSP_SRAM_POOL_CON   (DSP_SYSAO_BASE + 0x30)
+#define DSP_SRAM_POOL_PD_MASK 0xf
+#define DSP_EMI_MAP_ADDR		(DSP_SYSAO_BASE + 0x81c)
+
+/* DSP memories */
+#ifdef ADSP_USE_DRAM
+#define MBOX_OFFSET	0x800000 // DRAM
+#else
+#define MBOX_OFFSET	(0x23000  + 0x2000)// SRAM
+#endif
+#define MBOX_SIZE	0x1000 // memory.h in sof fw
+
+#ifdef ADSP_USE_DRAM
+#define DSP_DRAM_SIZE     0x1000000 /*16M*/
+#else
+#define DSP_DRAM_SIZE  0x0
+#endif
+
+#define TOTAL_SIZE_SHARED_SRAM_FROM_TAIL  0x0
+
+#define SIZE_SHARED_DRAM_DL 0x40000 /*Shared buffer for Downlink*/
+#define SIZE_SHARED_DRAM_UL 0x40000 /*Shared buffer for Uplink*/
+
+#define TOTAL_SIZE_SHARED_DRAM_FROM_TAIL  \
+	(SIZE_SHARED_DRAM_DL + SIZE_SHARED_DRAM_UL)
+
+#define SRAM_PHYS_BASE_FROM_DSP_VIEW  (0x40000000) /* MT8195 DSP view */
+#define DRAM_PHYS_BASE_FROM_DSP_VIEW  (0x60000000) /* MT8195 DSP view */
+
+/*DSP boot */
+void hifixdsp_boot_sequence(u32 boot_addr);
+void hifixdsp_shutdown(void);
+#endif
diff --git a/sound/soc/sof/pcm.c b/sound/soc/sof/pcm.c
index 9893b182da43347245b5159661345198783b062a..a9068a909a914d178828b3e640cf64702921b686 100644
--- a/sound/soc/sof/pcm.c
+++ b/sound/soc/sof/pcm.c
@@ -38,7 +38,8 @@ static int create_page_table(struct snd_soc_component *component,
 		spcm->stream[stream].page_table.area, size);
 }
 
-static int sof_pcm_dsp_params(struct snd_sof_pcm *spcm, struct snd_pcm_substream *substream,
+static int sof_pcm_dsp_params(struct snd_sof_pcm *spcm,
+			      struct snd_pcm_substream *substream,
 			      const struct sof_ipc_pcm_params_reply *reply)
 {
 	struct snd_soc_component *scomp = spcm->scomp;
@@ -475,7 +476,6 @@ static int sof_pcm_open(struct snd_soc_component *component,
 	dev_dbg(component->dev, "pcm: open stream %d dir %d\n",
 		spcm->pcm.pcm_id, substream->stream);
 
-
 	caps = &spcm->pcm.caps[substream->stream];
 
 	/* set runtime config */
@@ -755,6 +755,14 @@ int sof_pcm_dai_link_fixup(struct snd_soc_pcm_runtime *rtd, struct snd_pcm_hw_pa
 			"channels_min: %d channels_max: %d\n",
 			channels->min, channels->max);
 		break;
+	case SOF_DAI_MEDIATEK_AFE:
+		rate->min = dai->dai_config->afe.rate;
+		rate->max = dai->dai_config->afe.rate;
+		channels->min = dai->dai_config->afe.channels;
+		channels->max = dai->dai_config->afe.channels;
+		dev_dbg(component->dev,
+			"rate_min: %d rate_max: %d\n", rate->min, rate->max);
+		break;
 	case SOF_DAI_IMX_SAI:
 		rate->min = dai->dai_config->sai.fsync_rate;
 		rate->max = dai->dai_config->sai.fsync_rate;
@@ -837,7 +845,8 @@ void snd_sof_new_platform_drv(struct snd_sof_dev *sdev)
 	pd->compress_ops = &sof_probe_compressed_ops;
 #endif
 	pd->pcm_construct = sof_pcm_new;
-	pd->ignore_machine = drv_name;
+	if (!plat_data->desc->no_ignore_machine)
+		pd->ignore_machine = drv_name;
 	pd->be_hw_params_fixup = sof_pcm_dai_link_fixup;
 	pd->be_pcm_base = SOF_BE_PCM_BASE;
 	pd->use_dai_pcm_id = true;
diff --git a/sound/soc/sof/sof-of-dev.c b/sound/soc/sof/sof-of-dev.c
index c9c70645b37774892ddd237c1dc8fc55168be056..706b6ff4a0a313ac5c81b1f1a2224ca31d5e0457 100644
--- a/sound/soc/sof/sof-of-dev.c
+++ b/sound/soc/sof/sof-of-dev.c
@@ -15,6 +15,7 @@
 extern struct snd_sof_dsp_ops sof_imx8_ops;
 extern struct snd_sof_dsp_ops sof_imx8x_ops;
 extern struct snd_sof_dsp_ops sof_imx8m_ops;
+extern struct snd_sof_dsp_ops sof_mt8195_ops;
 
 /* platform specific devices */
 #if IS_ENABLED(CONFIG_SND_SOC_SOF_IMX8)
@@ -44,6 +45,16 @@ static struct sof_dev_desc sof_of_imx8mp_desc = {
 	.ops = &sof_imx8m_ops,
 };
 #endif
+#if IS_ENABLED(CONFIG_SND_SOC_SOF_MT8195)
+static struct sof_dev_desc sof_of_mt8195_desc = {
+	.no_ignore_machine = true,
+	.default_fw_path = "mt8195/sof",
+	.default_tplg_path = "mt8195/sof-tplg",
+	.default_fw_filename = "sof-mt8195.ri",
+	.nocodec_tplg_filename = "sof-mt8195-nocodec.tplg",
+	.ops = &sof_mt8195_ops,
+};
+#endif
 
 static const struct dev_pm_ops sof_of_pm = {
 	.prepare = snd_sof_prepare,
@@ -121,6 +132,9 @@ static const struct of_device_id sof_of_ids[] = {
 #endif
 #if IS_ENABLED(CONFIG_SND_SOC_SOF_IMX8M)
 	{ .compatible = "fsl,imx8mp-dsp", .data = &sof_of_imx8mp_desc},
+#endif
+#if IS_ENABLED(CONFIG_SND_SOC_SOF_MT8195)
+	{ .compatible = "mediatek,mt8195-audio_dsp", .data = &sof_of_mt8195_desc},
 #endif
 	{ }
 };
diff --git a/sound/soc/sof/topology.c b/sound/soc/sof/topology.c
index 59abcfc9bd5584de6ae00957e42669764e0c905b..d555deab9a9f790ed8f705dd6fff277b682618b8 100644
--- a/sound/soc/sof/topology.c
+++ b/sound/soc/sof/topology.c
@@ -376,6 +376,7 @@ static const struct sof_dai_types sof_dais[] = {
 	{"ALH", SOF_DAI_INTEL_ALH},
 	{"SAI", SOF_DAI_IMX_SAI},
 	{"ESAI", SOF_DAI_IMX_ESAI},
+	{"AFE", SOF_DAI_MEDIATEK_AFE},
 };
 
 static enum sof_ipc_dai_type find_dai(const char *name)
@@ -797,6 +798,19 @@ static const struct sof_topology_token led_tokens[] = {
 	 get_token_u32, offsetof(struct snd_sof_led_control, direction), 0},
 };
 
+/* AFE */
+static const struct sof_topology_token afe_tokens[] = {
+	{SOF_TKN_MEDIATEK_AFE_RATE,
+		SND_SOC_TPLG_TUPLE_TYPE_WORD, get_token_u32,
+		offsetof(struct sof_ipc_dai_afe_params, rate), 0},
+	{SOF_TKN_MEDIATEK_AFE_CH,
+		SND_SOC_TPLG_TUPLE_TYPE_WORD, get_token_u32,
+		offsetof(struct sof_ipc_dai_afe_params, channels), 0},
+	{SOF_TKN_MEDIATEK_AFE_FORMAT,
+		SND_SOC_TPLG_TUPLE_TYPE_STRING, get_token_comp_format,
+		offsetof(struct sof_ipc_dai_afe_params, format), 0},
+};
+
 static int sof_parse_uuid_tokens(struct snd_soc_component *scomp,
 				 void *object,
 				 const struct sof_topology_token *tokens,
@@ -3075,6 +3089,52 @@ static int sof_link_esai_load(struct snd_soc_component *scomp, int index,
 	return ret;
 }
 
+static int sof_link_afe_load(struct snd_soc_component *scomp, int index,
+			     struct snd_soc_dai_link *link,
+			     struct snd_soc_tplg_link_config *cfg,
+			     struct snd_soc_tplg_hw_config *hw_config,
+			     struct sof_ipc_dai_config *config)
+{
+	struct snd_sof_dev *sdev = snd_soc_component_get_drvdata(scomp);
+	struct snd_soc_tplg_private *private = &cfg->priv;
+	struct snd_soc_dai *dai;
+	u32 size = sizeof(*config);
+	int ret;
+
+	/* init IPC */
+	memset(&config->afe, 0, sizeof(struct sof_ipc_dai_afe_params));
+	config->hdr.size = size;
+
+	/* get any bespoke DAI tokens */
+	ret = sof_parse_tokens(scomp, &config->afe, afe_tokens,
+			       ARRAY_SIZE(afe_tokens), private->array,
+			       le32_to_cpu(private->size));
+	if (ret != 0) {
+		dev_err(scomp->dev, "error: parse afe tokens failed %d\n",
+			le32_to_cpu(private->size));
+		return ret;
+	}
+
+	dev_info(scomp->dev, "AFE config rate %d channes %d format:%d\n",
+		 config->afe.rate, config->afe.channels, config->afe.format);
+
+	dai = snd_soc_find_dai(link->cpus);
+	if (!dai) {
+		dev_err(scomp->dev, "error: failed to find dai %s in %s",
+			link->cpus->dai_name, __func__);
+		return -EINVAL;
+	}
+
+	config->afe.stream_id = DMA_CHAN_INVALID;
+
+	ret = sof_set_dai_config(sdev, size, link, config);
+	if (ret < 0)
+		dev_err(scomp->dev, "error: failed to process afe dai link %s",
+			link->name);
+
+	return ret;
+}
+
 static int sof_link_dmic_load(struct snd_soc_component *scomp, int index,
 			      struct snd_soc_dai_link *link,
 			      struct snd_soc_tplg_link_config *cfg,
@@ -3360,6 +3420,9 @@ static int sof_link_load(struct snd_soc_component *scomp, int index,
 	case SOF_DAI_IMX_ESAI:
 		ret = sof_link_esai_load(scomp, index, link, cfg, hw_config + curr_conf, config);
 		break;
+	case SOF_DAI_MEDIATEK_AFE:
+		ret = sof_link_afe_load(scomp, index, link, cfg, hw_config, config);
+		break;
 	default:
 		dev_err(scomp->dev, "error: invalid DAI type %d\n", common_config.type);
 		ret = -EINVAL;
