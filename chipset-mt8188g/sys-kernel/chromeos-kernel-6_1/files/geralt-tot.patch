diff --git a/.cop/build.yaml b/.cop/build.yaml
new file mode 100644
index 0000000000000000000000000000000000000000..96b4e12de4b470bb52cffe1434f701010c92e1d8
--- /dev/null
+++ b/.cop/build.yaml
@@ -0,0 +1,55 @@
+# SPDX-License-Identifier: (GPL-2.0 OR BSD-2-Clause)
+steps:
+- name: 'gcr.io/${PROJECT_ID}/kernel-aarch64'
+  entrypoint: 'bash'
+  id: 'format_patch'
+  args:
+  - '-c'
+  - |
+        set -ve
+        git checkout -b CUT #CL under test
+        git format-patch -1
+- name: 'gcr.io/${PROJECT_ID}/kernel-aarch64'
+  entrypoint: 'bash'
+  id: 'build_parent'
+  allowFailure: true
+  args:
+  - '-c'
+  - |
+        set -ve
+        git checkout CUT~1
+        CHROMEOS_KERNEL_FAMILY=chromeos ./chromeos/scripts/prepareconfig ${_CONFIG}
+        ./scripts/config -d CONFIG_WERROR -d LOCALVERSION_AUTO
+        CROSS_COMPILE=${_CROSS_COMPILE} ARCH=${_ARCH} make olddefconfig 2> /dev/null
+        CROSS_COMPILE=${_CROSS_COMPILE} ARCH=${_ARCH} make -j $(nproc) W=1 C=1
+- name: 'gcr.io/${PROJECT_ID}/kernel-aarch64'
+  entrypoint: 'bash'
+  id: 'build_sparse'
+  args:
+  - '-c'
+  - |
+        set -ve
+        git checkout CUT
+        CHROMEOS_KERNEL_FAMILY=chromeos ./chromeos/scripts/prepareconfig ${_CONFIG}
+        ./scripts/config -d CONFIG_WERROR -d LOCALVERSION_AUTO
+        CROSS_COMPILE=${_CROSS_COMPILE} ARCH=${_ARCH} make olddefconfig 2> /dev/null
+        CROSS_COMPILE=${_CROSS_COMPILE} ARCH=${_ARCH} make -j $(nproc) W=1 C=1 2>&1 | tee build_sparse.txt
+        ! grep -i -e "error:" -e "warning:" build_sparse.txt
+- name: 'gcr.io/${PROJECT_ID}/kernel-aarch64'
+  entrypoint: 'bash'
+  id: 'checkpatch'
+  args:
+  - '-c'
+  - |
+        set -v
+        scripts/checkpatch.pl --show-types --strict --ignore GERRIT_CHANGE_ID \
+                --ignore UNKNOWN_COMMIT_ID --ignore COMMIT_LOG_LONG_LINE \
+                --ignore FILE_PATH_CHANGES  *patch
+substitutions:
+  _CONFIG: "chromiumos-mediatek"
+  _ARCH: "arm64"
+  _CROSS_COMPILE: "aarch64-linux-gnu-"
+  _FETCH_DEPTH: "2"
+options:
+ machineType: 'E2_HIGHCPU_32'
+
diff --git a/.gitignore b/.gitignore
index 47229f98b327b5d5aeb0bf764188edf0f2189cd5..24ca8c07b891123952aac9fe044ac2fec1a2f5e4 100644
--- a/.gitignore
+++ b/.gitignore
@@ -100,6 +100,7 @@ modules.order
 !.gitignore
 !.mailmap
 !.rustfmt.toml
+!.cop
 
 #
 # Generated include files
diff --git a/Documentation/ABI/testing/sysfs-kernel-dmaheap b/Documentation/ABI/testing/sysfs-kernel-dmaheap
new file mode 100644
index 0000000000000000000000000000000000000000..f496181e9bf87431fc21412b0c38e99d3e999495
--- /dev/null
+++ b/Documentation/ABI/testing/sysfs-kernel-dmaheap
@@ -0,0 +1,7 @@
+What:		/sys/kernel/dma_heap/total_pools_kb
+Date:		Feb 2021
+KernelVersion:	5.10
+Contact:	Hridya Valsaraju <hridya@google.com>,
+Description:
+		The total_pools_kb file is read-only and specifies how much
+		memory in Kb is allocated to DMA-BUF heap pools.
diff --git a/Documentation/devicetree/bindings/arm/mediatek/mediatek,mmsys.yaml b/Documentation/devicetree/bindings/arm/mediatek/mediatek,mmsys.yaml
index d1410345ef180c5df9597f6e506fdd10f68d8dd9..8180199d65731580d41a760857f6c455d66bf0b7 100644
--- a/Documentation/devicetree/bindings/arm/mediatek/mediatek,mmsys.yaml
+++ b/Documentation/devicetree/bindings/arm/mediatek/mediatek,mmsys.yaml
@@ -32,6 +32,7 @@ properties:
               - mediatek,mt8183-mmsys
               - mediatek,mt8186-mmsys
               - mediatek,mt8188-vdosys0
+              - mediatek,mt8188-vdosys1
               - mediatek,mt8192-mmsys
               - mediatek,mt8195-vdosys1
               - mediatek,mt8195-vppsys0
diff --git a/Documentation/devicetree/bindings/display/mediatek/mediatek,ethdr.yaml b/Documentation/devicetree/bindings/display/mediatek/mediatek,ethdr.yaml
index 801fa66ae61501961f8e48ce8b98a228f704e60d..677882348eded7e65ff766fd16160030479dfe04 100644
--- a/Documentation/devicetree/bindings/display/mediatek/mediatek,ethdr.yaml
+++ b/Documentation/devicetree/bindings/display/mediatek/mediatek,ethdr.yaml
@@ -23,7 +23,11 @@ description:
 
 properties:
   compatible:
-    const: mediatek,mt8195-disp-ethdr
+    oneOf:
+      - const: mediatek,mt8195-disp-ethdr
+      - items:
+          - const: mediatek,mt8188-disp-ethdr
+          - const: mediatek,mt8195-disp-ethdr
 
   reg:
     maxItems: 7
diff --git a/Documentation/devicetree/bindings/display/mediatek/mediatek,mdp-rdma.yaml b/Documentation/devicetree/bindings/display/mediatek/mediatek,mdp-rdma.yaml
index dd12e2ff685c2f4f62df30342f17d6a88bcfeea8..7570a0684967ad40022b8cd250ffe4d55ea96146 100644
--- a/Documentation/devicetree/bindings/display/mediatek/mediatek,mdp-rdma.yaml
+++ b/Documentation/devicetree/bindings/display/mediatek/mediatek,mdp-rdma.yaml
@@ -21,7 +21,11 @@ description:
 
 properties:
   compatible:
-    const: mediatek,mt8195-vdo1-rdma
+    oneOf:
+      - const: mediatek,mt8195-vdo1-rdma
+      - items:
+          - const: mediatek,mt8188-vdo1-rdma
+          - const: mediatek,mt8195-vdo1-rdma
 
   reg:
     maxItems: 1
diff --git a/Documentation/devicetree/bindings/display/mediatek/mediatek,merge.yaml b/Documentation/devicetree/bindings/display/mediatek/mediatek,merge.yaml
index eead5cb8636edbf3a64ea208fbdff9348a9f7984..5c678695162e98968c5ae38cf49531b591398583 100644
--- a/Documentation/devicetree/bindings/display/mediatek/mediatek,merge.yaml
+++ b/Documentation/devicetree/bindings/display/mediatek/mediatek,merge.yaml
@@ -27,6 +27,9 @@ properties:
       - items:
           - const: mediatek,mt6795-disp-merge
           - const: mediatek,mt8173-disp-merge
+      - items:
+          - const: mediatek,mt8188-disp-merge
+          - const: mediatek,mt8195-disp-merge
 
   reg:
     maxItems: 1
diff --git a/Documentation/devicetree/bindings/display/mediatek/mediatek,padding.yaml b/Documentation/devicetree/bindings/display/mediatek/mediatek,padding.yaml
new file mode 100644
index 0000000000000000000000000000000000000000..db24801ebc484e184df1bdc3e75af0661c105753
--- /dev/null
+++ b/Documentation/devicetree/bindings/display/mediatek/mediatek,padding.yaml
@@ -0,0 +1,81 @@
+# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/display/mediatek/mediatek,padding.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: MediaTek Display Padding
+
+maintainers:
+  - Chun-Kuang Hu <chunkuang.hu@kernel.org>
+  - Philipp Zabel <p.zabel@pengutronix.de>
+
+description:
+  Padding provides ability to add pixels to width and height of a layer with
+  specified colors. Due to hardware design, Mixer in VDOSYS1 requires
+  width of a layer to be 2-pixel-align, or 4-pixel-align when ETHDR is enabled,
+  we need Padding to deal with odd width.
+  Please notice that even if the Padding is in bypass mode, settings in
+  register must be cleared to 0, or undefined behaviors could happen.
+
+properties:
+  compatible:
+    const: mediatek,mt8188-padding
+
+  reg:
+    maxItems: 1
+
+  power-domains:
+    maxItems: 1
+
+  clocks:
+    items:
+      - description: RDMA Clock
+
+  mediatek,gce-client-reg:
+    description:
+      GCE (Global Command Engine) is a multi-core micro processor that helps
+      its clients to execute commands without interrupting CPU. This property
+      describes GCE client's information that is composed by 4 fields.
+      1. Phandle of the GCE (there may be several GCE processors)
+      2. Sub-system ID defined in the dt-binding like a user ID
+         (Please refer to include/dt-bindings/gce/<chip>-gce.h)
+      3. Offset from base address of the subsys you are at
+      4. Size of the register the client needs
+    $ref: /schemas/types.yaml#/definitions/phandle-array
+    items:
+      items:
+        - description: Phandle of the GCE
+        - description: Subsys ID defined in the dt-binding
+        - description: Offset from base address of the subsys
+        - description: Size of register
+    maxItems: 1
+
+required:
+  - compatible
+  - reg
+  - power-domains
+  - clocks
+  - mediatek,gce-client-reg
+
+additionalProperties: false
+
+examples:
+  - |
+    #include <dt-bindings/interrupt-controller/arm-gic.h>
+    #include <dt-bindings/clock/mediatek,mt8188-clk.h>
+    #include <dt-bindings/power/mediatek,mt8188-power.h>
+    #include <dt-bindings/gce/mt8195-gce.h>
+
+    soc {
+        #address-cells = <2>;
+        #size-cells = <2>;
+
+        padding0: padding@1c11d000 {
+            compatible = "mediatek,mt8188-padding";
+            reg = <0 0x1c11d000 0 0x1000>;
+            clocks = <&vdosys1 CLK_VDO1_PADDING0>;
+            power-domains = <&spm MT8188_POWER_DOMAIN_VDOSYS1>;
+            mediatek,gce-client-reg = <&gce0 SUBSYS_1c11XXXX 0xd000 0x1000>;
+        };
+    };
diff --git a/Documentation/devicetree/bindings/pci/mediatek-pcie-gen3.yaml b/Documentation/devicetree/bindings/pci/mediatek-pcie-gen3.yaml
index c00be39af64e53e801a5d4d551235b5e16f504fe..2e055e06bed1495c310d3dc4a4fa484336be3870 100644
--- a/Documentation/devicetree/bindings/pci/mediatek-pcie-gen3.yaml
+++ b/Documentation/devicetree/bindings/pci/mediatek-pcie-gen3.yaml
@@ -80,6 +80,29 @@ properties:
       - const: phy
       - const: mac
 
+  pcie1v8-supply:
+    description:
+      The regulator phandle that provides 1.8V power to downstream component.
+
+  pcie3v3-supply:
+    description:
+      The regulator phandle that provides 3.3V power to downstream component.
+
+  pcie12v-supply:
+    description:
+      The regulator phandle that provides 12V power to downstream component.
+
+  dsc-reset-gpios:
+    description:
+      The reset GPIO of a downstream component.
+    maxItems: 1
+
+  dsc-reset-msleep:
+    description:
+      The delay time between assertion and de-assertion of a downstream
+      component's reset GPIO.
+    maxItems: 1
+
   clocks:
     maxItems: 6
 
diff --git a/Documentation/devicetree/bindings/thermal/mediatek,mt8188-lvts.yaml b/Documentation/devicetree/bindings/thermal/mediatek,mt8188-lvts.yaml
new file mode 100644
index 0000000000000000000000000000000000000000..d270db378419cf0a3b0eb8fe23509526da8e975e
--- /dev/null
+++ b/Documentation/devicetree/bindings/thermal/mediatek,mt8188-lvts.yaml
@@ -0,0 +1,71 @@
+# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/thermal/mediatek,mt8188-lvts.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: MediaTek SoC LVTS thermal controller
+
+maintainers:
+  - Yu-Chia Chang <ethan.chang@mediatek.com>
+  - Ben Tseng <ben.tseng@mediatek.com>
+
+properties:
+  compatible:
+    enum:
+      - mediatek,mt8188-lvts-ap
+      - mediatek,mt8188-lvts-mcu
+
+  "#thermal-sensor-cells":
+    const: 1
+
+  reg:
+    maxItems: 2
+
+  interrupts:
+    maxItems: 1
+
+  clocks:
+    maxItems: 1
+
+  resets:
+    items:
+      - description: SW reset HW AP/MCU domain for clean temporary data when HW initialization and resume.
+
+  nvmem-cells:
+    maxItems: 1
+
+  nvmem-cell-names:
+    maxItems: 1
+
+required:
+  - compatible
+  - '#thermal-sensor-cells'
+  - reg
+  - interrupts
+  - clocks
+  - resets
+  - nvmem-cells
+  - nvmem-cell-names
+
+additionalProperties: false
+
+examples:
+  - |
+    #include <dt-bindings/thermal/thermal.h>
+    #include <dt-bindings/interrupt-controller/arm-gic.h>
+    #include <dt-bindings/clock/mt8188-clk.h>
+    #include <dt-bindings/reset/mt8188-resets.h>
+
+    lvtsmcu: thermal-sensor@11278000 {
+      compatible = "mediatek,mt8188-lvts-mcu";
+      #thermal-sensor-cells = <1>;
+      reg = <0 0x11278000 0 0x1000>;
+      interrupts = <GIC_SPI 202 IRQ_TYPE_LEVEL_HIGH 0>;
+      clocks = <&infracfg_ao CLK_INFRA_AO_THERM>;
+      resets = <&infracfg_ao MT8188_INFRA_RST1_THERMAL_MCU_RST>;
+      nvmem-cells = <&lvts_efuse_data1>;
+      nvmem-cell-names = "lvts_calib_data1";
+    };
+
+...
diff --git a/Documentation/devicetree/bindings/thermal/mediatek,mt8192-lvts.yaml b/Documentation/devicetree/bindings/thermal/mediatek,mt8192-lvts.yaml
new file mode 100644
index 0000000000000000000000000000000000000000..8c5a02eb97c5c575a056d05606326597dd71ca15
--- /dev/null
+++ b/Documentation/devicetree/bindings/thermal/mediatek,mt8192-lvts.yaml
@@ -0,0 +1,73 @@
+# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/thermal/mediatek,mt8192-lvts.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: MediaTek SoC LVTS thermal controller
+
+maintainers:
+  - Yu-Chia Chang <ethan.chang@mediatek.com>
+  - Ben Tseng <ben.tseng@mediatek.com>
+
+properties:
+  compatible:
+    enum:
+      - mediatek,mt8192-lvts-ap
+      - mediatek,mt8192-lvts-mcu
+
+  "#thermal-sensor-cells":
+    const: 1
+
+  reg:
+    maxItems: 2
+
+  interrupts:
+    maxItems: 1
+
+  clocks:
+    maxItems: 1
+
+  resets:
+    items:
+      - description: SW reset HW AP/MCU domain for clean temporary data when HW initialization and resume.
+
+  nvmem-cells:
+    items:
+      - description: LVTS calibration data for thermal sensors
+
+  nvmem-cell-names:
+    items:
+      - const: lvts_calib_data
+
+required:
+  - compatible
+  - '#thermal-sensor-cells'
+  - reg
+  - interrupts
+  - clocks
+  - resets
+  - nvmem-cells
+  - nvmem-cell-names
+
+additionalProperties: false
+
+examples:
+  - |
+    #include <dt-bindings/thermal/thermal.h>
+    #include <dt-bindings/interrupt-controller/arm-gic.h>
+    #include <dt-bindings/clock/mt8192-clk.h>
+    #include <dt-bindings/reset/mt8192-resets.h>
+
+      lvtsmcu: thermal-sensor@11278000 {
+        compatible = "mediatek,mt8192-lvts-mcu";
+        #thermal-sensor-cells = <1>;
+        reg = <0 0x11278000 0 0x400>;
+        interrupts = <GIC_SPI 170 IRQ_TYPE_LEVEL_HIGH 0>;
+        clocks = <&infracfg_ao CLK_INFRA_THERM>;
+        resets = <&infracfg_ao MT8192_INFRA_RST4_THERM_CTRL_MCU_SWRST>;
+        nvmem-cells = <&lvts_efuse_data>;
+        nvmem-cell-names = "lvts_calib_data";
+      };
+
+...
diff --git a/Documentation/devicetree/bindings/thermal/mediatek,mt8195-lvts.yaml b/Documentation/devicetree/bindings/thermal/mediatek,mt8195-lvts.yaml
new file mode 100644
index 0000000000000000000000000000000000000000..6b0b53a33272b2c54cf55f1b9a66387f0aae7d9b
--- /dev/null
+++ b/Documentation/devicetree/bindings/thermal/mediatek,mt8195-lvts.yaml
@@ -0,0 +1,75 @@
+# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/thermal/mediatek,mt8195-lvts.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: MediaTek SoC LVTS thermal controller
+
+maintainers:
+  - Yu-Chia Chang <ethan.chang@mediatek.com>
+  - Ben Tseng <ben.tseng@mediatek.com>
+
+properties:
+  compatible:
+    enum:
+      - mediatek,mt8195-lvts-ap
+      - mediatek,mt8195-lvts-mcu
+
+  "#thermal-sensor-cells":
+    const: 1
+
+  reg:
+    maxItems: 2
+
+  interrupts:
+    maxItems: 1
+
+  clocks:
+    maxItems: 1
+
+  resets:
+    items:
+      - description: SW reset HW AP/MCU domain for clean temporary data when HW initialization and resume.
+
+  nvmem-cells:
+    items:
+      - description: LVTS calibration data 1 for thermal sensors
+      - description: LVTS calibration data 2 for thermal sensors
+
+  nvmem-cell-names:
+    items:
+      - const: lvts_calib_data1
+      - const: lvts_calib_data2
+
+required:
+  - compatible
+  - '#thermal-sensor-cells'
+  - reg
+  - interrupts
+  - clocks
+  - resets
+  - nvmem-cells
+  - nvmem-cell-names
+
+additionalProperties: false
+
+examples:
+  - |
+    #include <dt-bindings/thermal/thermal.h>
+    #include <dt-bindings/interrupt-controller/arm-gic.h>
+    #include <dt-bindings/clock/mt8195-clk.h>
+    #include <dt-bindings/reset/mt8195-resets.h>
+
+      lvtsmcu: thermal-sensor@11278000 {
+        compatible = "mediatek,mt8195-lvts-mcu";
+        #thermal-sensor-cells = <1>;
+        reg = <0 0x11278000 0 0x400>;
+        interrupts = <GIC_SPI 170 IRQ_TYPE_LEVEL_HIGH 0>;
+        clocks = <&infracfg_ao CLK_INFRA_AO_THERM>;
+        resets = <&infracfg_ao MT8195_INFRA_RST4_THERM_CTRL_MCU_SWRST>;
+        nvmem-cells = <&lvts_efuse_data1 &lvts_efuse_data2>;
+        nvmem-cell-names = "lvts_calib_data1", "lvts_calib_data2";
+      };
+
+...
diff --git a/README b/README
index 669ac7c32292798644b21dbb5a0dc657125f444d..c523fbf54309bbd31f3d175863bcd1ffa132f84d 100644
--- a/README
+++ b/README
@@ -13,6 +13,9 @@ In order to build the documentation, use ``make htmldocs`` or
 There are various text files in the Documentation/ subdirectory,
 several of them using the Restructured Text markup notation.
 
+TMP-TOT-DMABUF-FOR_CAM
+
 Please read the Documentation/process/changes.rst file, as it contains the
 requirements for building and running the kernel, and information about
 the problems which may result by upgrading your kernel.
+
diff --git a/arch/arm64/boot/dts/mediatek/Makefile b/arch/arm64/boot/dts/mediatek/Makefile
index 8b651bcacacc5ba85b0e81753159ac9ee85d9b3d..6c2c2db35be8ea8b91750633128a5bb4eb8b24a8 100644
--- a/arch/arm64/boot/dts/mediatek/Makefile
+++ b/arch/arm64/boot/dts/mediatek/Makefile
@@ -71,6 +71,8 @@ dtb-$(CONFIG_ARCH_MEDIATEK) += mt8186-corsola-voltorb-sku589824.dtb
 dtb-$(CONFIG_ARCH_MEDIATEK) += mt8186-corsola-voltorb-sku589825.dtb
 dtb-$(CONFIG_ARCH_MEDIATEK) += mt8186-corsola-tentacruel.dtb
 dtb-$(CONFIG_ARCH_MEDIATEK) += mt8186-evb.dtb
+dtb-$(CONFIG_ARCH_MEDIATEK) += mt8188-evb.dtb
+dtb-$(CONFIG_ARCH_MEDIATEK) += mt8188-geralt.dtb
 dtb-$(CONFIG_ARCH_MEDIATEK) += mt8192-asurada-hayato-r1.dtb
 dtb-$(CONFIG_ARCH_MEDIATEK) += mt8192-asurada-spherion-r0.dtb
 dtb-$(CONFIG_ARCH_MEDIATEK) += mt8192-evb.dtb
diff --git a/arch/arm64/boot/dts/mediatek/mt6359.dtsi b/arch/arm64/boot/dts/mediatek/mt6359.dtsi
index df3e822232d340ca1a4885f5f57a0a408e6024de..8550c7918f18e08ae5ae70637c2352100cf25ed4 100644
--- a/arch/arm64/boot/dts/mediatek/mt6359.dtsi
+++ b/arch/arm64/boot/dts/mediatek/mt6359.dtsi
@@ -143,6 +143,7 @@ mt6359_vcn18_ldo_reg: ldo_vcn18 {
 				regulator-min-microvolt = <1800000>;
 				regulator-max-microvolt = <1800000>;
 				regulator-enable-ramp-delay = <240>;
+				regulator-always-on;
 			};
 			mt6359_vfe28_ldo_reg: ldo_vfe28 {
 				regulator-name = "vfe28";
diff --git a/arch/arm64/boot/dts/mediatek/mt8173.dtsi b/arch/arm64/boot/dts/mediatek/mt8173.dtsi
index 6bde4041e0b33a4e018374244efb14f2214ec5e0..2c10cb0f678077bf7c171fb2297939d9ea51a5f4 100644
--- a/arch/arm64/boot/dts/mediatek/mt8173.dtsi
+++ b/arch/arm64/boot/dts/mediatek/mt8173.dtsi
@@ -596,9 +596,6 @@ efuse: efuse@10206000 {
 			reg = <0 0x10206000 0 0x1000>;
 			#address-cells = <1>;
 			#size-cells = <1>;
-			svs_calibration: calib@100 {
-				reg = <0x100 0x8c>;
-			};
 			thermal_calibration: calib@528 {
 				reg = <0x528 0xc>;
 			};
@@ -778,22 +775,14 @@ thermal: thermal@1100b000 {
 			#thermal-sensor-cells = <0>;
 			compatible = "mediatek,mt8173-thermal";
 			reg = <0 0x1100b000 0 0x1000>;
-			interrupts = <0 70 IRQ_TYPE_LEVEL_LOW>,
-				     <0 117 IRQ_TYPE_LEVEL_LOW>;
-			clocks = <&pericfg CLK_PERI_THERM>,
-				 <&pericfg CLK_PERI_AUXADC>,
-				 <&topckgen CLK_TOP_SYSPLL1_D2>,
-				 <&topckgen CLK_TOP_AXI_SEL>;
-			clock-names = "therm", "auxadc", "svs_pll", "svs_mux";
+			interrupts = <0 70 IRQ_TYPE_LEVEL_LOW>;
+			clocks = <&pericfg CLK_PERI_THERM>, <&pericfg CLK_PERI_AUXADC>;
+			clock-names = "therm", "auxadc";
 			resets = <&pericfg MT8173_PERI_THERM_SW_RST>;
 			mediatek,auxadc = <&auxadc>;
 			mediatek,apmixedsys = <&apmixedsys>;
-			nvmem-cells = <&thermal_calibration>,
-				      <&svs_calibration>;
-			mediatek,svs-little-core-id = <0>;
-			mediatek,svs-big-core-id = <2>;
-			nvmem-cell-names = "calibration-data",
-					   "svs-calibration-data";
+			nvmem-cells = <&thermal_calibration>;
+			nvmem-cell-names = "calibration-data";
 		};
 
 		nor_flash: spi@1100d000 {
diff --git a/arch/arm64/boot/dts/mediatek/mt8186.dtsi b/arch/arm64/boot/dts/mediatek/mt8186.dtsi
index 0f15a83c0bdf6d8283f9969bd7496048c4722d7d..8e98600b2415f98d75334618612fef341482609c 100644
--- a/arch/arm64/boot/dts/mediatek/mt8186.dtsi
+++ b/arch/arm64/boot/dts/mediatek/mt8186.dtsi
@@ -1845,7 +1845,6 @@ vcodec_dec: vcodec_dec@16000000 {
 			reg = <0 0x16000000 0 0x1000>;		/* VDEC_SYS */
 			mediatek,scp = <&scp>;
 			iommus = <&iommu_mm IOMMU_PORT_L4_HW_VDEC_MC_EXT>;
-			dma-ranges = <0x1 0x0 0x0 0x40000000 0x0 0xfff00000>;
 			#address-cells = <2>;
 			#size-cells = <2>;
 			ranges;
@@ -1897,7 +1896,6 @@ jpgenc: jpgenc@17030000 {
 			clocks = <&vencsys CLK_VENC_CKE2_JPGENC>;
 			clock-names = "jpgenc";
 			power-domains = <&spm MT8186_POWER_DOMAIN_VENC>;
-			dma-ranges = <0x1 0x0 0x1 0x0 0x1 0x0>;
 			iommus = <&iommu_mm IOMMU_PORT_L7_JPGENC_Y_RDMA>,
 				 <&iommu_mm IOMMU_PORT_L7_JPGENC_C_RDMA>,
 				 <&iommu_mm IOMMU_PORT_L7_JPGENC_Q_TABLE>,
@@ -1919,7 +1917,6 @@ venc: venc@17000000 {
 				 <&iommu_mm IOMMU_PORT_L7_VENC_CUR_CHROMA>,
 				 <&iommu_mm IOMMU_PORT_L7_VENC_REF_LUMA>,
 				 <&iommu_mm IOMMU_PORT_L7_VENC_REF_CHROMA>;
-			dma-ranges = <0x1 0x0 0x1 0x0 0x1 0x0>;
 			mediatek,scp = <&scp>;
 			clocks = <&vencsys CLK_VENC_CKE1_VENC>;
 			clock-names = "MT_CG_VENC";
diff --git a/arch/arm64/boot/dts/mediatek/mt8188-evb.dts b/arch/arm64/boot/dts/mediatek/mt8188-evb.dts
new file mode 100644
index 0000000000000000000000000000000000000000..39b99b693187c96db975210b1a4efaa8ed2512b1
--- /dev/null
+++ b/arch/arm64/boot/dts/mediatek/mt8188-evb.dts
@@ -0,0 +1,442 @@
+// SPDX-License-Identifier: (GPL-2.0 OR MIT)
+/*
+ * Copyright (C) 2022 MediaTek Inc.
+ */
+/dts-v1/;
+#include "mt8188.dtsi"
+#include "mt6359.dtsi"
+
+/ {
+	model = "MediaTek MT8188 evaluation board";
+	compatible = "mediatek,mt8188-evb", "mediatek,mt8188";
+
+	aliases {
+		serial0 = &uart0;
+		i2c0 = &i2c0;
+		i2c1 = &i2c1;
+		i2c2 = &i2c2;
+		i2c3 = &i2c3;
+		i2c4 = &i2c4;
+		i2c5 = &i2c5;
+		i2c6 = &i2c6;
+		mmc0 = &mmc0;
+	};
+
+	/* chosen */
+	chosen: chosen {
+		stdout-path = "serial0:115200n8";
+		kaslr-seed = <0 0>;
+	};
+
+	memory {
+		device_type = "memory";
+		reg = <0 0x40000000 0 0x80000000>;
+	};
+
+	reserved_memory: reserved-memory {
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+
+		scp_mem_reserved: scp_mem_region {
+			compatible = "shared-dma-pool";
+			reg = <0 0x50000000 0 0x2900000>;
+			no-map;
+		};
+
+		scp_dual_mem_reserved: scp-dual-mem-region {
+			compatible = "shared-dma-pool";
+			reg = <0 0x70000000 0 0xd000000>;
+			no-map;
+		};
+	};
+};
+
+&auxadc {
+	status = "okay";
+};
+
+&cam_vcore {
+	domain-supply = <&mt6359_vproc1_buck_reg>;
+};
+
+&i2c0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c0_pin>;
+	clock-frequency = <400000>;
+	status = "okay";
+};
+
+&i2c1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c1_pin>;
+	clock-frequency = <400000>;
+	status = "okay";
+};
+
+&i2c2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c2_pin>;
+	clock-frequency = <400000>;
+	status = "okay";
+};
+
+&i2c3 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c3_pin>;
+	clock-frequency = <400000>;
+	status = "okay";
+};
+
+&i2c4 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c4_pin>;
+	clock-frequency = <400000>;
+	status = "okay";
+};
+
+&i2c5 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c5_pin>;
+	clock-frequency = <400000>;
+	status = "okay";
+};
+
+&i2c6 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c6_pin>;
+	clock-frequency = <400000>;
+	status = "okay";
+};
+
+&img_vcore {
+	domain-supply = <&mt6359_vproc1_buck_reg>;
+};
+
+&mmc0 {
+	status = "okay";
+	pinctrl-names = "default", "state_uhs";
+	pinctrl-0 = <&mmc0_pins_default>;
+	pinctrl-1 = <&mmc0_pins_uhs>;
+	bus-width = <8>;
+	max-frequency = <200000000>;
+	cap-mmc-highspeed;
+	mmc-hs200-1_8v;
+	mmc-hs400-1_8v;
+	supports-cqe;
+	cap-mmc-hw-reset;
+	no-sdio;
+	no-sd;
+	hs400-ds-delay = <0x1481b>;
+	vmmc-supply = <&mt6359_vemc_1_ldo_reg>;
+	vqmmc-supply = <&mt6359_vufs_ldo_reg>;
+	non-removable;
+};
+
+&mt6359_vbbck_ldo_reg {
+	regulator-always-on;
+};
+
+&mt6359_vcn33_2_bt_ldo_reg {
+	regulator-always-on;
+};
+
+&mt6359_vcore_buck_reg {
+	regulator-always-on;
+};
+
+&mt6359_vgpu11_buck_reg {
+	regulator-always-on;
+};
+
+&mt6359_vpu_buck_reg {
+	regulator-always-on;
+};
+
+&mt6359_vrf12_ldo_reg {
+	regulator-always-on;
+};
+
+&mt6359_vufs_ldo_reg {
+	regulator-always-on;
+};
+
+&nor_flash {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&nor_pins_default>;
+
+	flash@0 {
+		compatible = "jedec,spi-nor";
+		reg = <0>;
+		spi-max-frequency = <52000000>;
+	};
+};
+
+&pio {
+	pinctrl-names = "default";
+
+	adsp_uart_pin: adsp_uart_pin {
+		adsp_uart_pins {
+			pinmux = <PINMUX_GPIO35__FUNC_O_ADSP_UTXD0>,
+				 <PINMUX_GPIO36__FUNC_I1_ADSP_URXD0>;
+		};
+	};
+
+	i2c0_pin: i2c0_pin {
+		pins_bus {
+			pinmux = <PINMUX_GPIO56__FUNC_B1_SDA0>,
+				 <PINMUX_GPIO55__FUNC_B1_SCL0>;
+			bias-pull-up = <MTK_PULL_SET_RSEL_011>;
+		};
+	};
+
+	i2c1_pin: i2c1_pin {
+		pins_bus {
+			pinmux = <PINMUX_GPIO58__FUNC_B1_SDA1>,
+				 <PINMUX_GPIO57__FUNC_B1_SCL1>;
+			bias-pull-up = <MTK_PULL_SET_RSEL_011>;
+		};
+	};
+
+	i2c2_pin: i2c2_pin {
+		pins_bus {
+			pinmux = <PINMUX_GPIO60__FUNC_B1_SDA2>,
+				 <PINMUX_GPIO59__FUNC_B1_SCL2>;
+			bias-pull-up = <MTK_PULL_SET_RSEL_011>;
+		};
+	};
+
+	i2c3_pin: i2c3_pin {
+		pins_bus {
+			pinmux = <PINMUX_GPIO62__FUNC_B1_SDA3>,
+				 <PINMUX_GPIO61__FUNC_B1_SCL3>;
+			bias-pull-up = <MTK_PULL_SET_RSEL_011>;
+		};
+	};
+
+	i2c4_pin: i2c4_pin {
+		pins_bus {
+			pinmux = <PINMUX_GPIO64__FUNC_B1_SDA4>,
+				 <PINMUX_GPIO63__FUNC_B1_SCL4>;
+			bias-pull-up = <MTK_PULL_SET_RSEL_011>;
+		};
+	};
+
+	i2c5_pin: i2c5_pin {
+		pins_bus {
+			pinmux = <PINMUX_GPIO66__FUNC_B1_SDA5>,
+				 <PINMUX_GPIO65__FUNC_B1_SCL5>;
+			bias-pull-up = <MTK_PULL_SET_RSEL_011>;
+		};
+	};
+
+	i2c6_pin: i2c6_pin {
+		pins_bus {
+			pinmux = <PINMUX_GPIO68__FUNC_B1_SDA6>,
+				 <PINMUX_GPIO67__FUNC_B1_SCL6>;
+			bias-pull-up = <MTK_PULL_SET_RSEL_011>;
+		};
+	};
+
+	mmc0_pins_default: mmc0default {
+		pins_cmd_dat {
+			pinmux = <PINMUX_GPIO161__FUNC_B1_MSDC0_DAT0>,
+				 <PINMUX_GPIO160__FUNC_B1_MSDC0_DAT1>,
+				 <PINMUX_GPIO159__FUNC_B1_MSDC0_DAT2>,
+				 <PINMUX_GPIO158__FUNC_B1_MSDC0_DAT3>,
+				 <PINMUX_GPIO154__FUNC_B1_MSDC0_DAT4>,
+				 <PINMUX_GPIO153__FUNC_B1_MSDC0_DAT5>,
+				 <PINMUX_GPIO152__FUNC_B1_MSDC0_DAT6>,
+				 <PINMUX_GPIO151__FUNC_B1_MSDC0_DAT7>,
+				 <PINMUX_GPIO156__FUNC_B1_MSDC0_CMD>;
+			input-enable;
+			drive-strength = <MTK_DRIVE_6mA>;
+			bias-pull-up = <MTK_PUPD_SET_R1R0_01>;
+		};
+
+		pins_clk {
+			pinmux = <PINMUX_GPIO157__FUNC_B1_MSDC0_CLK>;
+			drive-strength = <MTK_DRIVE_6mA>;
+			bias-pull-down = <MTK_PUPD_SET_R1R0_10>;
+		};
+
+		pins_rst {
+			pinmux = <PINMUX_GPIO155__FUNC_O_MSDC0_RSTB>;
+			drive-strength = <MTK_DRIVE_6mA>;
+			bias-pull-up = <MTK_PUPD_SET_R1R0_01>;
+		};
+	};
+
+	mmc0_pins_uhs: mmc0uhs {
+		pins_cmd_dat {
+			pinmux = <PINMUX_GPIO161__FUNC_B1_MSDC0_DAT0>,
+				 <PINMUX_GPIO160__FUNC_B1_MSDC0_DAT1>,
+				 <PINMUX_GPIO159__FUNC_B1_MSDC0_DAT2>,
+				 <PINMUX_GPIO158__FUNC_B1_MSDC0_DAT3>,
+				 <PINMUX_GPIO154__FUNC_B1_MSDC0_DAT4>,
+				 <PINMUX_GPIO153__FUNC_B1_MSDC0_DAT5>,
+				 <PINMUX_GPIO152__FUNC_B1_MSDC0_DAT6>,
+				 <PINMUX_GPIO151__FUNC_B1_MSDC0_DAT7>,
+				 <PINMUX_GPIO156__FUNC_B1_MSDC0_CMD>;
+			input-enable;
+			drive-strength = <MTK_DRIVE_8mA>;
+			bias-pull-up = <MTK_PUPD_SET_R1R0_01>;
+		};
+
+		pins_clk {
+			pinmux = <PINMUX_GPIO157__FUNC_B1_MSDC0_CLK>;
+			drive-strength = <MTK_DRIVE_8mA>;
+			bias-pull-down = <MTK_PUPD_SET_R1R0_10>;
+		};
+
+		pins_ds {
+			pinmux = <PINMUX_GPIO162__FUNC_B0_MSDC0_DSL>;
+			drive-strength = <MTK_DRIVE_8mA>;
+			bias-pull-down = <MTK_PUPD_SET_R1R0_10>;
+		};
+
+		pins_rst {
+			pinmux = <PINMUX_GPIO155__FUNC_O_MSDC0_RSTB>;
+			drive-strength = <MTK_DRIVE_8mA>;
+			bias-pull-up = <MTK_PUPD_SET_R1R0_01>;
+		};
+	};
+
+	nor_pins_default: nor-pins {
+		pins0 {
+			pinmux = <PINMUX_GPIO127__FUNC_B0_SPINOR_IO0>,
+				 <PINMUX_GPIO125__FUNC_O_SPINOR_CK>,
+				 <PINMUX_GPIO128__FUNC_B0_SPINOR_IO1>;
+			bias-pull-down;
+		};
+
+		pins1 {
+			pinmux = <PINMUX_GPIO126__FUNC_O_SPINOR_CS>,
+				 <PINMUX_GPIO129__FUNC_B0_SPINOR_IO2>,
+				 <PINMUX_GPIO130__FUNC_B0_SPINOR_IO3>;
+			bias-pull-up;
+		};
+	};
+
+	scp_pins: scp {
+		pins_scp_vreq {
+			pinmux = <PINMUX_GPIO98__FUNC_O_SCP_VREQ_VAO>;
+			bias-disable;
+			input-enable;
+		};
+	};
+
+	spi0_pins: spi0_pins {
+		pins_spi {
+			pinmux = <PINMUX_GPIO69__FUNC_O_SPIM0_CSB>,
+				 <PINMUX_GPIO70__FUNC_O_SPIM0_CLK>,
+				 <PINMUX_GPIO71__FUNC_B0_SPIM0_MOSI>,
+				 <PINMUX_GPIO72__FUNC_B0_SPIM0_MISO>;
+			bias-disable;
+		};
+	};
+
+	spi1_pins: spi1_pins {
+		pins_spi {
+			pinmux = <PINMUX_GPIO75__FUNC_O_SPIM1_CSB>,
+				 <PINMUX_GPIO76__FUNC_O_SPIM1_CLK>,
+				 <PINMUX_GPIO77__FUNC_B0_SPIM1_MOSI>,
+				 <PINMUX_GPIO78__FUNC_B0_SPIM1_MISO>;
+			bias-disable;
+		};
+	};
+
+	spi2_pins: spi2_pins {
+		pins_spi {
+			pinmux = <PINMUX_GPIO79__FUNC_O_SPIM2_CSB>,
+				 <PINMUX_GPIO80__FUNC_O_SPIM2_CLK>,
+				 <PINMUX_GPIO81__FUNC_B0_SPIM2_MOSI>,
+				 <PINMUX_GPIO82__FUNC_B0_SPIM2_MISO>;
+			bias-disable;
+		};
+	};
+
+	uart0_pin: uart0_pin {
+		uart0_pins {
+			pinmux = <PINMUX_GPIO31__FUNC_O_UTXD0>,
+				 <PINMUX_GPIO32__FUNC_I1_URXD0>;
+			bias-pull-up;
+		};
+	};
+};
+
+&pmic {
+	interrupt-parent = <&pio>;
+	interrupts = <222 IRQ_TYPE_LEVEL_HIGH>;
+};
+
+&mt6359_vgpu11_sshub_buck_reg {
+	regulator-always-on;
+	regulator-min-microvolt = <550000>;
+	regulator-max-microvolt = <550000>;
+};
+
+&scp {
+	pinctrl-names = "default";
+	pinctrl-0 = <&scp_pins>;
+	memory-region = <&scp_mem_reserved>;
+	status = "okay";
+
+	mediatek,scp-core = <&scp_dual 0>;
+};
+
+&scp_dual {
+	status = "okay";
+	memory-region = <&scp_dual_mem_reserved>;
+	mediatek,scp-core = <&scp 1>;
+	firmware-name = "scp-dual.img";
+};
+
+&spi0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&spi0_pins>;
+	status = "okay";
+};
+
+&spi1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&spi1_pins>;
+	status = "okay";
+};
+
+&spi2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&spi2_pins>;
+	status = "okay";
+};
+
+&u3phy0 {
+	status="okay";
+};
+
+&u3phy1 {
+	status="okay";
+};
+
+&u3phy2 {
+	status="okay";
+};
+
+&uart0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&uart0_pin>;
+	status = "okay";
+};
+
+&xhci0 {
+	status = "okay";
+};
+
+&xhci1 {
+	status = "okay";
+};
+
+&xhci2 {
+	status = "okay";
+};
diff --git a/arch/arm64/boot/dts/mediatek/mt8188-geralt.dts b/arch/arm64/boot/dts/mediatek/mt8188-geralt.dts
new file mode 100755
index 0000000000000000000000000000000000000000..00d0e66c22818fd90a86a4bfc483bc3b5e79ec19
--- /dev/null
+++ b/arch/arm64/boot/dts/mediatek/mt8188-geralt.dts
@@ -0,0 +1,1455 @@
+// SPDX-License-Identifier: (GPL-2.0 OR MIT)
+/*
+ * Copyright (C) 2022 MediaTek Inc.
+ */
+/dts-v1/;
+#include <dt-bindings/gpio/gpio.h>
+#include "mt8188.dtsi"
+#include "mt6359.dtsi"
+#include "mt8188_geralt_camera_v4l2.dtsi"
+
+/ {
+	model = "Google Geralt board";
+	compatible = "google,geralt", "mediatek,mt8188";
+
+	aliases {
+		serial0 = &uart0;
+		i2c0 = &i2c0;
+		i2c1 = &i2c1;
+		i2c2 = &i2c2;
+		i2c3 = &i2c3;
+		i2c4 = &i2c4;
+		i2c5 = &i2c5;
+		i2c6 = &i2c6;
+		mmc0 = &mmc0;
+		mmc1 = &mmc1;
+	};
+
+	avdd_lcd: avdd-lcd {
+		compatible = "regulator-fixed";
+		regulator-name = "avdd_lcd";
+		gpio = <&pio 3 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+		pinctrl-names = "default";
+		pinctrl-0 = <&avdd_lcd_en>;
+	};
+
+	avee_lcd: avee-lcd {
+		compatible = "regulator-fixed";
+		regulator-name = "avee_lcd";
+		gpio = <&pio 4 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+		pinctrl-names = "default";
+		pinctrl-0 = <&avee_lcd_en>;
+		regulator-enable-ramp-delay = <10000>;
+	};
+
+	backlight_lcd0: backlight_lcd0 {
+		compatible = "pwm-backlight";
+		pwms = <&disp_pwm1 0 500000>;
+		power-supply = <&bl_pp5000>;
+		enable-gpios = <&pio 110 0>;
+		brightness-levels = <0 1023>;
+		num-interpolated-steps = <1023>;
+		default-brightness-level = <576>;
+		status = "disabled";
+	};
+
+	backlight_lcd1: backlight_lcd1 {
+		compatible = "pwm-backlight";
+		pwms = <&disp_pwm0 0 500000>;
+		power-supply = <&bl_pp5000>;
+		enable-gpios = <&pio 1 0>;
+		brightness-levels = <0 1023>;
+		num-interpolated-steps = <1023>;
+		default-brightness-level = <576>;
+		status = "okay";
+	};
+
+	bl_pp5000: regulator2 {
+		compatible = "regulator-fixed";
+		regulator-name = "bl_pp5000";
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		regulator-always-on;
+		regulator-boot-on;
+		enable-active-high;
+	};
+
+	/* chosen */
+	chosen: chosen {
+		stdout-path = "serial0:115200n8";
+		kaslr-seed = <0 0>;
+	};
+
+	dmic-codec {
+		compatible = "dmic-codec";
+		num-channels = <2>;
+		wakeup-delay-ms = <50>;
+	};
+
+	dx_pp3300: regulator3 {
+		compatible = "regulator-fixed";
+		regulator-name = "dx_pp3300";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		regulator-always-on;
+		regulator-boot-on;
+		enable-active-high;
+	};
+
+	memory {
+		device_type = "memory";
+		reg = <0 0x40000000 0 0x80000000>;
+	};
+
+	panel: panel {
+		compatible = "lg,lp120up1";
+		status = "disabled";
+		pinctrl-names = "default";
+		pinctrl-0 = <&panel_pin_default>;
+		backlight = <&backlight_lcd0>;
+		port {
+			panel_in: endpoint {
+				remote-endpoint = <&edp_out>;
+			};
+		};
+	};
+
+	pcie_3v3_en: pcie-3v3-en-regulator {
+		compatible = "regulator-fixed";
+		regulator-name = "pcie_3v3_en";
+		regulator-always-on;
+		gpio = <&pio 12 0>;
+		enable-active-high;
+	};
+
+	pp3300_dx_edp: pp3300-dx-edp-regulator {
+		compatible = "regulator-fixed";
+		regulator-name = "pp3300_dx_edp";
+		pinctrl-names = "default";
+		pinctrl-0 = <&en_pp3300_dxedp>;
+		enable-active-high;
+		regulator-boot-on;
+		gpio = <&pio 27 GPIO_ACTIVE_HIGH>;
+		vin-supply = <&dx_pp3300>;
+	};
+
+	pp3300_mipi: regulator-pp3300-mipi {
+		compatible = "regulator-fixed";
+		regulator-name = "pp3300_mipi";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		regulator-always-on;
+		regulator-boot-on;
+		enable-active-high;
+	};
+
+	pp3300_s3: pp3300-s3-regulator {
+		compatible = "regulator-fixed";
+		regulator-name = "pp3300_s3";
+		pinctrl-names = "default";
+		pinctrl-0 = <&en_pp3300_mipi>;
+		enable-active-high;
+		regulator-boot-on;
+		gpio = <&pio 144 GPIO_ACTIVE_HIGH>;
+		vin-supply = <&pp3300_mipi>;
+	};
+
+	reserved_memory: reserved-memory {
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+
+		adsp_dma_mem_reserved: adsp_dma_mem_region {
+			compatible = "shared-dma-pool";
+			reg = <0 0x61000000 0 0x100000>;
+			no-map;
+		};
+
+		adsp_mem_reserved: adsp_mem_region {
+			compatible = "mediatek,adsp-reserved-memory";
+			no-map;
+			reg = <0 0x60000000 0 0xA00000>;
+		};
+
+		scp_mem_reserved: scp_mem_region {
+			compatible = "shared-dma-pool";
+			reg = <0 0x50000000 0 0x2900000>;
+			no-map;
+		};
+
+		afe_dma_mem_reserved: snd_dma_mem_region {
+			compatible = "shared-dma-pool";
+			no-map;
+			reg = <0 0x60F00000 0 0x100000>;
+		};
+
+		scp_dual_mem_reserved: scp-dual-mem-region {
+			compatible = "shared-dma-pool";
+			reg = <0 0x70000000 0 0xA000000>;
+			no-map;
+		};
+
+		scp_dual_cma_reserved: dma_buf_reserved_cma {
+			compatible = "dma-buf-heap-cma";
+			reg = <0 0x7A000000 0 0x03000000>;
+			reusable;
+		};
+	};
+
+	usb_p1_vbus: regulator-usb-p1-vbus {
+		compatible = "regulator-fixed";
+		regulator-name = "vbus0";
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		enable-active-high;
+		gpio = <&pio 150 GPIO_ACTIVE_HIGH>;
+	};
+};
+
+&adsp {
+	memory-region = <&adsp_dma_mem_reserved>,
+		<&adsp_mem_reserved>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&adsp_uart_pin>;
+	status = "okay";
+};
+
+&afe {
+	memory-region = <&afe_dma_mem_reserved>;
+	mediatek,etdm-out1-cowork-source = <0>; /* in1 */
+	mediatek,etdm-in2-cowork-source = <3>; /* out2 */
+	status = "okay";
+};
+
+&auxadc {
+	status = "okay";
+};
+
+&cam_vcore {
+	domain-supply = <&mt6359_vproc1_buck_reg>;
+};
+
+&disp_dsi0 {
+	#address-cells = <1>;
+	#size-cells = <0>;
+	status = "okay";
+
+	panel1@0 {
+		compatible = "boe,tv110c9m-ll3";
+		reg = <0>;
+		enable-gpios = <&pio 25 0>;
+		avdd-supply = <&avdd_lcd>;
+		avee-supply = <&avee_lcd>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&panel_pins_default>;
+		pp1800-supply = <&mt6359_vm18_ldo_reg>;
+		backlight = <&backlight_lcd1>;
+		rotation = <270>;
+		status = "okay";
+
+		port {
+			panel1_in: endpoint {
+				remote-endpoint = <&dsi_out>;
+			};
+		};
+	};
+
+	ports {
+		port {
+			dsi_out: endpoint {
+				remote-endpoint = <&panel1_in>;
+			};
+		};
+	};
+};
+
+&disp_pwm0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pwm0_gpio_def_cfg>;
+	status = "okay";
+};
+
+&disp_pwm1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pwm1_gpio_def_cfg>;
+	status = "okay";
+};
+
+&dp_intf0 {
+	status = "disabled";
+
+	port {
+		dp_intf0_out: endpoint {
+			remote-endpoint = <&edp_in>;
+		};
+	};
+};
+
+&dp_intf1 {
+	status = "okay";
+
+	port {
+		dp_intf1_out: endpoint {
+			remote-endpoint = <&dptx_in>;
+		};
+	};
+};
+
+&dp_tx {
+	status = "okay";
+
+	pinctrl-names = "default";
+	pinctrl-0 = <&dptx_pin>;
+
+	ports {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		port@0 {
+			reg = <0>;
+			dptx_in: endpoint {
+				remote-endpoint = <&dp_intf1_out>;
+			};
+		};
+
+		port@1 {
+			reg = <1>;
+			dptx_out: endpoint {
+				data-lanes = <0 1 2 3>;
+			};
+		};
+	};
+};
+
+&edp_tx {
+	status = "disabled";
+
+	pinctrl-names = "default";
+	pinctrl-0 = <&edp_pins_default>;
+
+	ports {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		port@0 {
+			reg = <0>;
+			edp_in: endpoint {
+				remote-endpoint = <&dp_intf0_out>;
+			};
+		};
+
+		port@1 {
+			reg = <1>;
+			edp_out: endpoint {
+				remote-endpoint = <&panel_in>;
+				data-lanes = <0 1 2 3>;
+			};
+		};
+	};
+};
+
+&gpu {
+	supply-names = "mali","mali_sram";
+	mali-supply = <&mt6359_vproc2_buck_reg>;
+	mali_sram-supply = <&mt6359_vsram_others_ldo_reg>;
+	operating-points-v2 = <&gpu_opp_table>;
+	volt-bin-mapping = <3 4 5 6>;
+
+	power_model@0 {
+		compatible = "arm,mali-simple-power-model";
+		static-coefficient = <2427750>;
+		dynamic-coefficient = <4687>;
+		ts = <20000 2000 (-20) 2>;
+		thermal-zone = "soc_max";
+	};
+
+	power_model@1 {
+		compatible = "arm,mali-tnax-power-model";
+		scale = <5>;
+	};
+};
+
+&i2c0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c0_pin>;
+	clock-frequency = <400000>;
+	status = "okay";
+
+	nau8825: nau8825@1a {
+		#sound-dai-cells = <0>;
+		compatible = "nuvoton,nau8825";
+		reg = <0x1a>;
+		interrupt-parent = <&pio>;
+		interrupts = <108 IRQ_TYPE_LEVEL_LOW>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&nau8825_pins_default>;
+
+		nuvoton,jkdet-enable;
+		nuvoton,jkdet-polarity = <1>;
+		nuvoton,vref-impedance = <2>;
+		nuvoton,micbias-voltage = <6>;
+		nuvoton,sar-hysteresis = <1>;
+		nuvoton,sar-voltage = <6>;
+		nuvoton,sar-compare-time = <0>;
+		nuvoton,sar-sampling-time = <0>;
+		nuvoton,short-key-debounce = <2>;
+		nuvoton,jack-insert-debounce = <7>;
+		nuvoton,jack-eject-debounce = <7>;
+		nuvoton,adc-delay-ms = <300>;
+		status = "okay";
+	};
+
+	max98390_rr: max98390@38 {
+		#sound-dai-cells = <0>;
+		compatible = "maxim,max98390";
+		reg = <0x38>;
+		sound-name-prefix = "Rear Right";
+		reset-gpios = <&pio 118 1>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&max98390_pins_default>;
+		status = "okay";
+	};
+
+	max98390_rl: max98390@39 {
+		#sound-dai-cells = <0>;
+		compatible = "maxim,max98390";
+		reg = <0x39>;
+		sound-name-prefix = "Rear Left";
+		status = "okay";
+	};
+
+	max98390_fr: max98390@3A {
+		#sound-dai-cells = <0>;
+		compatible = "maxim,max98390";
+		reg = <0x3A>;
+		sound-name-prefix = "Front Left";
+		status = "okay";
+	};
+
+	max98390_fl: max98390@3B {
+		#sound-dai-cells = <0>;
+		compatible = "maxim,max98390";
+		reg = <0x3B>;
+		sound-name-prefix = "Front Right";
+		status = "okay";
+	};
+};
+
+&i2c1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c1_pin>;
+	clock-frequency = <400000>;
+	status = "okay";
+
+	cr50@50 {
+		compatible = "google,cr50";
+		reg = <0x50>;
+		interrupt-parent = <&pio>;
+		interrupts = <0 IRQ_TYPE_EDGE_RISING>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&gsc_ap_int_odl>;
+	};
+};
+
+&i2c2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c2_pin>;
+	clock-frequency = <400000>;
+	status = "okay";
+
+	touchscreen@1 {
+		status = "okay";
+		compatible = "hid-over-i2c";
+		reg = <0x1>;
+		interrupt-parent = <&pio>;
+		interrupts = <143 IRQ_TYPE_EDGE_FALLING>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&touchscreen_pins>;
+		vdd-supply = <&pp3300_s3>;
+		vddl-supply = <&mt6359_vm18_ldo_reg>;
+		post-power-on-delay-ms = <500>;
+		hid-descr-addr = <0x0001>;
+	};
+};
+
+&i2c3 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c3_pin>;
+	clock-frequency = <400000>;
+	status = "okay";
+
+	ap_sar_sensor: proximity@28 {
+		compatible = "semtech,sx9324";
+		reg = <0x28>;
+		#io-channel-cells = <1>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&sar_sensor_pins>;
+		interrupt-parent = <&pio>;
+		interrupts = <88 IRQ_TYPE_LEVEL_LOW>;
+		vdd-supply = <&mt6359_vio18_ldo_reg>;
+		svdd-supply = <&mt6359_vio18_ldo_reg>;
+	};
+};
+
+&i2c4 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c4_pin>;
+	clock-frequency = <400000>;
+	status = "okay";
+
+	touchpad@56 {
+		status = "okay";
+		compatible = "hid-over-i2c";
+		reg = <0x56>;
+		interrupt-parent = <&pio>;
+		interrupts = <148 IRQ_TYPE_LEVEL_LOW>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&touchpad_pins>;
+		hid-descr-addr = <0x0001>;
+		wakeup-source;
+	};
+};
+
+&i2c5 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c5_pin>;
+	clock-frequency = <400000>;
+	status = "okay";
+};
+
+&i2c6 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c6_pin>;
+	clock-frequency = <400000>;
+	status = "okay";
+};
+
+&img_vcore {
+	domain-supply = <&mt6359_vproc1_buck_reg>;
+};
+
+&mfg0 {
+	domain-supply = <&mt6359_vproc2_buck_reg>;
+};
+
+&mipi_tx_config0 {
+	status = "okay";
+};
+
+&mmc0 {
+	status = "okay";
+	pinctrl-names = "default", "state_uhs";
+	pinctrl-0 = <&mmc0_pins_default>;
+	pinctrl-1 = <&mmc0_pins_uhs>;
+	bus-width = <8>;
+	max-frequency = <200000000>;
+	cap-mmc-highspeed;
+	mmc-hs200-1_8v;
+	mmc-hs400-1_8v;
+	supports-cqe;
+	cap-mmc-hw-reset;
+	no-sdio;
+	no-sd;
+	hs400-ds-delay = <0x1481b>;
+	vmmc-supply = <&mt6359_vemc_1_ldo_reg>;
+	vqmmc-supply = <&mt6359_vufs_ldo_reg>;
+	non-removable;
+};
+
+&mmc1 {
+	status = "okay";
+	pinctrl-names = "default", "state_uhs";
+	pinctrl-0 = <&mmc1_pins_default>;
+	pinctrl-1 = <&mmc1_pins_uhs>;
+	bus-width = <4>;
+	max-frequency = <200000000>;
+	cap-sd-highspeed;
+	sd-uhs-sdr50;
+	sd-uhs-sdr104;
+	no-mmc;
+	no-sdio;
+	cd-gpios = <&pio 107 GPIO_ACTIVE_LOW>;
+	vmmc-supply = <&mt6359_vpa_buck_reg>;
+	vqmmc-supply = <&mt6359_vsim1_ldo_reg>;
+};
+
+&mt6359codec {
+	mediatek,dmic-mode = <1>; /* one-wire */
+	mediatek,mic-type-0 = <2>; /* DMIC */
+	mediatek,mic-type-2 = <2>; /* DMIC */
+};
+
+&mt6359_vcore_buck_reg {
+	regulator-always-on;
+};
+
+&mt6359_vgpu11_buck_reg {
+	regulator-always-on;
+};
+
+&mt6359_vgpu11_sshub_buck_reg {
+	regulator-always-on;
+	regulator-min-microvolt = <550000>;
+	regulator-max-microvolt = <550000>;
+};
+
+&mt6359_vio28_ldo_reg {
+	/delete-property/ regulator-always-on;
+};
+
+&mt6359_vm18_ldo_reg {
+	/delete-property/ regulator-always-on;
+};
+
+&mt6359_vpu_buck_reg {
+	regulator-always-on;
+};
+
+&mt6359_vrf12_ldo_reg {
+	regulator-always-on;
+};
+
+&mt6359_vufs_ldo_reg {
+	regulator-always-on;
+};
+
+&mt6359_vpa_buck_reg {
+	regulator-max-microvolt = <3100000>;
+};
+
+&nor_flash {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&nor_pins_default>;
+
+	flash@0 {
+		compatible = "jedec,spi-nor";
+		reg = <0>;
+		spi-max-frequency = <52000000>;
+	};
+};
+
+&pcie {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pcie_pins_default>;
+	pcie3v3-supply = <&pcie_3v3_en>;
+	pcie1v8-supply = <&mt6359_vcn18_ldo_reg>;
+	dsc-reset-gpios = <&pio 145 1>;
+	status = "okay";
+};
+
+&pciephy {
+	status = "okay";
+};
+
+&pio {
+	pinctrl-names = "default";
+
+	gpio-line-names =
+		"GSC_AP_INT_ODL",
+		"AP_DISP_BKLTEN",
+		"",
+		"EN_PPVAR_MIPI_DISP",
+		"EN_PPVAR_MIPI_DISP_150MA",
+		"TCHSCR_RST_1V8_L",
+		"TCHSRC_REPORT_DISABLE",
+		"",
+		"",
+		"",
+		"",
+		"I2S_SPKR_DATAOUT",
+		"EN_PP3300_WLAN_X",
+		"WIFI_KILL_1V8_L",
+		"BT_KILL_1V8_L",
+		"AP_FLASH_WP_L",
+		"",
+		"EDP_HDP_1V8",
+		"WCAM_PWDN_L",
+		"WCAM_RST_L",
+		"UCAM_PWDM_L",
+		"UCAM_RST_L",
+		"WCAM_24M_CLK",
+		"UCAM_24M_CLK",
+		"MT6319_INT",
+		"DISP_RST_1V8_L",
+		"DSIO_DSI_TE",
+		"EN_PP3300_EDP_DISP_X",
+		"TP",
+		"MIPI_BL_PWM_1V8",
+		"EDP_BL_PWM_1V8",
+		"UART_AP_TX_GSC_RX",
+		"UART_GSC_TX_AP_RX",
+		"UART_SSPM_TX_DBGCON_RX",
+		"UART_DBGCON_TX_SSPM_RX",
+		"UART_ADSP_TX_DBGCON_RX",
+		"UART_DBGCON_TX_ADSP_RX",
+		"JTAG_AP_TMS",
+		"JTAG_AP_TCK",
+		"JTAG_AP_TDI",
+		"JTAG_AP_TDO",
+		"JTAG_AP_TRST",
+		"AP_KPCOLO",
+		"TP",
+		"BEEP_ON_OD",
+		"TP",
+		"EC_AP_HPD_OD",
+		"PCIE_WAKE_1V8_ODL",
+		"PCIE_RST_1V8_L",
+		"PCIE_CLKREQ_1V8_ODL",
+		"MIPI_DISP_ID0",
+		"MIPI_DISP_ID1",
+		"",
+		"",
+		"",
+		"AP_I2C_AUD_SCL_1V8",
+		"AP_I2C_AUD_SDA_1V8",
+		"AP_I2C_TPM_SCL_1V8",
+		"AP_I2C_TPM_SDA_1V8",
+		"AP_I2C_TCHSCR_SCL_1V8",
+		"AP_I2C_TCHSCR_SDA_1V8",
+		"AP_I2C_PMIC_SAR_SCL_1V8",
+		"AP_I2C_PMIC_SAR_SDA_1V8",
+		"AP_I2C_EC_HID_KB_SCL_1V8",
+		"AP_I2C_EC_HID_KB_SDA_1V8",
+		"AP_I2C_UCAM_SCL_1V8",
+		"AP_I2C_UCAM_SDA_1V8",
+		"AP_I2C_WCAM_SCL_1V8",
+		"AP_I2C_WCAM_SDA_1V8",
+		"SPI_AP_CS_EC_L",
+		"SPI_AP_CLK_EC",
+		"SPI_AP_DO_EC_DI",
+		"SPI_AP_DI_EC_DO",
+		"TP",
+		"TP",
+		"SPI_AP_CS_TCHSCR_L",
+		"SPI_AP_CLK_TCHSCR",
+		"SPI_AP_DO_TCHSCR_DI",
+		"SPI_AP_DI_TCHSCR_DO",
+		"TP",
+		"TP",
+		"TP",
+		"TP",
+		"",
+		"",
+		"",
+		"TP",
+		"",
+		"SAR_INT_ODL",
+		"",
+		"",
+		"",
+		"PWRAP_SPI_CS_L",
+		"PWRAP_SPI_CK",
+		"PWRAP_SPI_MOSI",
+		"PWRAP_SPI_MISO",
+		"SRCLKENA0",
+		"SRCLKENA1",
+		"SCP_VREQ_VAO",
+		"AP_RTC_CLK32K",
+		"AP_PMIC_WDTRST_L",
+		"AUD_CLK_MOSI",
+		"AUD_SYNC_MOSI",
+		"AUD_DAT_MOSI0",
+		"AUD_DAT_MOSI1",
+		"AUD_DAT_MISO0",
+		"AUD_DAT_MISO1",
+		"SD_CD_ODL",
+		"HP_INT_ODL",
+		"SPKR_INT_ODL",
+		"I2S_HP_DATAIN",
+		"EN_SPKR",
+		"I2S_SPKR_MCLK",
+		"I2S_SPKR_BCLK",
+		"I2S_HP_MCLK",
+		"I2S_HP_BCLK",
+		"I2S_HP_LRCK",
+		"I2S_HP_DATAOUT",
+		"RST_SPKR_L",
+		"I2S_SPKR_LRCK",
+		"I2S_SPKR_DATAIN",
+		"",
+		"",
+		"",
+		"",
+		"SPI_AP_CLK_ROM",
+		"SPI_AP_CS_ROM_L",
+		"SPI_AP_DO_ROM_DI",
+		"SPI_AP_DI_ROM_DO",
+		"TP",
+		"TP",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"",
+		"EN_PP2800A_UCAM_X",
+		"EN_PP1200_UCAM_X",
+		"EN_PP2800A_WCAM_X",
+		"EN_PP1100_WCAM_X",
+		"TCHSCR_INI_1V8_L",
+		"EN_PP300_MIPI_TCHSRC_X",
+		"MT7921_PMU_EN_1V8",
+		"EN_PP3300_EDP_TCHSCR_X",
+		"AP_EC_WARM_RST_REQ",
+		"EC_AP_HID_INT_ODL",
+		"EC_AP_INT_ODL",
+		"AP_XHCI_INIT_DONE",
+		"EMMC_DAT7",
+		"EMMC_DAT6",
+		"EMMC_DAT5",
+		"EMMC_DAT4",
+		"EMMC_RST_L",
+		"EMMC_CMD",
+		"EMMC_CLK",
+		"EMMC_DAT3",
+		"EMMC_DAT2",
+		"EMMC_DAT1",
+		"EMMC_DAT0",
+		"EMMC_DSL",
+		"SD_CMD",
+		"SD_CLK",
+		"SD_DAT0",
+		"SD_DAT1",
+		"SD_DAT2",
+		"SD_DAT3",
+		"",
+		"",
+		"USB3_HUB_RST_L",
+		"EC_AP_RSVD0_ODL",
+		"",
+		"",
+		"SPMI_SCL",
+		"SPMI_SDA";
+
+	adsp_uart_pin: adsp_uart_pin {
+		adsp_uart_pins {
+			pinmux = <PINMUX_GPIO35__FUNC_O_ADSP_UTXD0>,
+				 <PINMUX_GPIO36__FUNC_I1_ADSP_URXD0>;
+		};
+	};
+
+	aud_etdm_hp_on: aud_etdm_hp_on {
+		pins-cmd-dat {
+			pinmux = <PINMUX_GPIO110__FUNC_I0_I2SIN_D0>,
+				 <PINMUX_GPIO115__FUNC_B0_I2SO2_BCK>,
+				 <PINMUX_GPIO116__FUNC_B0_I2SO2_WS>,
+				 <PINMUX_GPIO117__FUNC_O_I2SO2_D0>;
+		};
+	};
+
+	aud_etdm_hp_off: aud_etdm_hp_off {
+		pins-cmd-dat {
+			pinmux = <PINMUX_GPIO110__FUNC_B_GPIO110>,
+				 <PINMUX_GPIO115__FUNC_B_GPIO115>,
+				 <PINMUX_GPIO116__FUNC_B_GPIO116>,
+				 <PINMUX_GPIO117__FUNC_B_GPIO117>;
+			bias-pull-down;
+			input-enable;
+		};
+	};
+
+	aud_etdm_spk_on: aud_etdm_spk_on {
+		pins-cmd-dat {
+			pinmux = <PINMUX_GPIO11__FUNC_O_I2SO1_D0>,
+				 <PINMUX_GPIO113__FUNC_B0_TDMIN_BCK>,
+				 <PINMUX_GPIO119__FUNC_B0_TDMIN_LRCK>,
+				 <PINMUX_GPIO120__FUNC_I0_TDMIN_DI>;
+		};
+	};
+
+	aud_etdm_spk_off: aud_etdm_spk_off {
+		pins-cmd-dat {
+			pinmux = <PINMUX_GPIO11__FUNC_B_GPIO11>,
+				 <PINMUX_GPIO113__FUNC_B_GPIO113>,
+				 <PINMUX_GPIO119__FUNC_B_GPIO119>,
+				 <PINMUX_GPIO120__FUNC_B_GPIO120>;
+			bias-pull-down;
+			input-enable;
+		};
+	};
+
+	aud_mtkaif_on: aud_mtkaif_on {
+		pins_cmd_dat {
+			pinmux = <PINMUX_GPIO101__FUNC_O_AUD_CLK_MOSI>,
+				 <PINMUX_GPIO102__FUNC_O_AUD_SYNC_MOSI>,
+				 <PINMUX_GPIO103__FUNC_O_AUD_DAT_MOSI0>,
+				 <PINMUX_GPIO104__FUNC_O_AUD_DAT_MOSI1>,
+				 <PINMUX_GPIO105__FUNC_I0_AUD_DAT_MISO0>,
+				 <PINMUX_GPIO106__FUNC_I0_AUD_DAT_MISO1>;
+		};
+	};
+
+	aud_mtkaif_off: aud_mtkaif_off {
+		pins_cmd_dat {
+			pinmux = <PINMUX_GPIO101__FUNC_B_GPIO101>,
+				 <PINMUX_GPIO102__FUNC_B_GPIO102>,
+				 <PINMUX_GPIO103__FUNC_B_GPIO103>,
+				 <PINMUX_GPIO104__FUNC_B_GPIO104>,
+				 <PINMUX_GPIO105__FUNC_B_GPIO105>,
+				 <PINMUX_GPIO106__FUNC_B_GPIO106>;
+			bias-pull-down;
+			input-enable;
+		};
+	};
+
+	avdd_lcd_en: avdd-lcd-en {
+		pins1 {
+			pinmux = <PINMUX_GPIO3__FUNC_B_GPIO3>;
+			output-low;
+		};
+	};
+
+	avee_lcd_en: avee-lcd-en {
+		pins1 {
+			pinmux = <PINMUX_GPIO4__FUNC_B_GPIO4>;
+			output-low;
+		};
+	};
+
+	dptx_pin: dptx-default-pins {
+		pins-cmd-dat {
+			pinmux = <PINMUX_GPIO46__FUNC_I0_DP_TX_HPD>;
+		};
+	};
+
+	ec_ap_int: cros-ec-irq-default-pins {
+		pins1 {
+			pinmux = <PINMUX_GPIO149__FUNC_B_GPIO149>;
+			input-enable;
+		};
+	};
+
+	edp_pins_default: edp-default-pins {
+		pins-cmd-dat {
+			pinmux = <PINMUX_GPIO17__FUNC_I0_EDP_TX_HPD>;
+		};
+	};
+
+	en_pp3300_dxedp: en-pp3300-dxedp {
+		pins1 {
+			pinmux = <PINMUX_GPIO27__FUNC_B_GPIO27>;
+			output-low;
+		};
+	};
+
+	en_pp3300_mipi: en-pp3300-mipi {
+		pins1 {
+			pinmux = <PINMUX_GPIO144__FUNC_B_GPIO144>;
+			output-low;
+		};
+	};
+
+	gsc_ap_int_odl: gsc_ap_int_odl {
+		pin {
+			pinmux = <PINMUX_GPIO0__FUNC_B_GPIO0>;
+			input-enable;
+		};
+	};
+
+	i2c0_pin: i2c0_pin {
+		pins_bus {
+			pinmux = <PINMUX_GPIO56__FUNC_B1_SDA0>,
+				 <PINMUX_GPIO55__FUNC_B1_SCL0>;
+		};
+	};
+
+	i2c1_pin: i2c1_pin {
+		pins_bus {
+			pinmux = <PINMUX_GPIO58__FUNC_B1_SDA1>,
+				 <PINMUX_GPIO57__FUNC_B1_SCL1>;
+		};
+	};
+
+	i2c2_pin: i2c2_pin {
+		pins_bus {
+			pinmux = <PINMUX_GPIO60__FUNC_B1_SDA2>,
+				 <PINMUX_GPIO59__FUNC_B1_SCL2>;
+			bias-disable;
+			drive-strength = <MTK_DRIVE_12mA>;
+		};
+	};
+
+	i2c3_pin: i2c3_pin {
+		pins_bus {
+			pinmux = <PINMUX_GPIO62__FUNC_B1_SDA3>,
+				 <PINMUX_GPIO61__FUNC_B1_SCL3>;
+		};
+	};
+
+	i2c4_pin: i2c4_pin {
+		pins_bus {
+			pinmux = <PINMUX_GPIO64__FUNC_B1_SDA4>,
+				 <PINMUX_GPIO63__FUNC_B1_SCL4>;
+		};
+	};
+
+	i2c5_pin: i2c5_pin {
+		pins_bus {
+			pinmux = <PINMUX_GPIO66__FUNC_B1_SDA5>,
+				 <PINMUX_GPIO65__FUNC_B1_SCL5>;
+		};
+	};
+
+	i2c6_pin: i2c6_pin {
+		pins_bus {
+			pinmux = <PINMUX_GPIO68__FUNC_B1_SDA6>,
+				 <PINMUX_GPIO67__FUNC_B1_SCL6>;
+		};
+	};
+
+	uart0_pin: uart0_pin {
+		uart0_pins {
+			pinmux = <PINMUX_GPIO31__FUNC_O_UTXD0>,
+				 <PINMUX_GPIO32__FUNC_I1_URXD0>;
+			bias-pull-up;
+		};
+	};
+
+	max98390_pins_default: max98390_rst {
+		pins_rst {
+			pinmux = <PINMUX_GPIO111__FUNC_B_GPIO111>;
+		};
+	};
+
+	mmc0_pins_default: mmc0default {
+		pins_cmd_dat {
+			pinmux = <PINMUX_GPIO161__FUNC_B1_MSDC0_DAT0>,
+				 <PINMUX_GPIO160__FUNC_B1_MSDC0_DAT1>,
+				 <PINMUX_GPIO159__FUNC_B1_MSDC0_DAT2>,
+				 <PINMUX_GPIO158__FUNC_B1_MSDC0_DAT3>,
+				 <PINMUX_GPIO154__FUNC_B1_MSDC0_DAT4>,
+				 <PINMUX_GPIO153__FUNC_B1_MSDC0_DAT5>,
+				 <PINMUX_GPIO152__FUNC_B1_MSDC0_DAT6>,
+				 <PINMUX_GPIO151__FUNC_B1_MSDC0_DAT7>,
+				 <PINMUX_GPIO156__FUNC_B1_MSDC0_CMD>;
+			input-enable;
+			drive-strength = <MTK_DRIVE_6mA>;
+			bias-pull-up = <MTK_PUPD_SET_R1R0_01>;
+		};
+
+		pins_clk {
+			pinmux = <PINMUX_GPIO157__FUNC_B1_MSDC0_CLK>;
+			drive-strength = <MTK_DRIVE_6mA>;
+			bias-pull-down = <MTK_PUPD_SET_R1R0_10>;
+		};
+
+		pins_rst {
+			pinmux = <PINMUX_GPIO155__FUNC_O_MSDC0_RSTB>;
+			drive-strength = <MTK_DRIVE_6mA>;
+			bias-pull-up = <MTK_PUPD_SET_R1R0_01>;
+		};
+	};
+
+	mmc0_pins_uhs: mmc0uhs {
+		pins_cmd_dat {
+			pinmux = <PINMUX_GPIO161__FUNC_B1_MSDC0_DAT0>,
+				 <PINMUX_GPIO160__FUNC_B1_MSDC0_DAT1>,
+				 <PINMUX_GPIO159__FUNC_B1_MSDC0_DAT2>,
+				 <PINMUX_GPIO158__FUNC_B1_MSDC0_DAT3>,
+				 <PINMUX_GPIO154__FUNC_B1_MSDC0_DAT4>,
+				 <PINMUX_GPIO153__FUNC_B1_MSDC0_DAT5>,
+				 <PINMUX_GPIO152__FUNC_B1_MSDC0_DAT6>,
+				 <PINMUX_GPIO151__FUNC_B1_MSDC0_DAT7>,
+				 <PINMUX_GPIO156__FUNC_B1_MSDC0_CMD>;
+			input-enable;
+			drive-strength = <MTK_DRIVE_8mA>;
+			bias-pull-up = <MTK_PUPD_SET_R1R0_01>;
+		};
+
+		pins_clk {
+			pinmux = <PINMUX_GPIO157__FUNC_B1_MSDC0_CLK>;
+			drive-strength = <MTK_DRIVE_8mA>;
+			bias-pull-down = <MTK_PUPD_SET_R1R0_10>;
+		};
+
+		pins_ds {
+			pinmux = <PINMUX_GPIO162__FUNC_B0_MSDC0_DSL>;
+			drive-strength = <MTK_DRIVE_8mA>;
+			bias-pull-down = <MTK_PUPD_SET_R1R0_10>;
+		};
+
+		pins_rst {
+			pinmux = <PINMUX_GPIO155__FUNC_O_MSDC0_RSTB>;
+			drive-strength = <MTK_DRIVE_8mA>;
+			bias-pull-up = <MTK_PUPD_SET_R1R0_01>;
+		};
+	};
+
+	nau8825_pins_default: nau8825_irq {
+		pins-irq {
+			pinmux = <PINMUX_GPIO108__FUNC_B_GPIO108>;
+			input-enable;
+			};
+	};
+
+	mmc1_pins_default: mmc1-pins-default {
+		pins_cmd_dat {
+			pinmux = <PINMUX_GPIO163__FUNC_B1_MSDC1_CMD>,
+				 <PINMUX_GPIO165__FUNC_B1_MSDC1_DAT0>,
+				 <PINMUX_GPIO166__FUNC_B1_MSDC1_DAT1>,
+				 <PINMUX_GPIO167__FUNC_B1_MSDC1_DAT2>,
+				 <PINMUX_GPIO168__FUNC_B1_MSDC1_DAT3>;
+			input-enable;
+			drive-strength = <MTK_DRIVE_6mA>;
+			bias-pull-up = <MTK_PUPD_SET_R1R0_01>;
+		};
+		pins_clk {
+			pinmux = <PINMUX_GPIO164__FUNC_B1_MSDC1_CLK>;
+			drive-strength = <MTK_DRIVE_6mA>;
+			bias-pull-down = <MTK_PUPD_SET_R1R0_10>;
+		};
+		pins_insert {
+			pinmux = <PINMUX_GPIO107__FUNC_B_GPIO107>;
+			bias-pull-up;
+		};
+	};
+
+	mmc1_pins_uhs: mmc1-pins-uhs {
+		pins_cmd_dat {
+			pinmux = <PINMUX_GPIO163__FUNC_B1_MSDC1_CMD>,
+				 <PINMUX_GPIO165__FUNC_B1_MSDC1_DAT0>,
+				 <PINMUX_GPIO166__FUNC_B1_MSDC1_DAT1>,
+				 <PINMUX_GPIO167__FUNC_B1_MSDC1_DAT2>,
+				 <PINMUX_GPIO168__FUNC_B1_MSDC1_DAT3>;
+			input-enable;
+			drive-strength = <MTK_DRIVE_10mA>;
+			bias-pull-up = <MTK_PUPD_SET_R1R0_01>;
+		};
+		pins_clk {
+			pinmux = <PINMUX_GPIO164__FUNC_B1_MSDC1_CLK>;
+			drive-strength = <MTK_DRIVE_6mA>;
+			bias-pull-down = <MTK_PUPD_SET_R1R0_10>;
+		};
+	};
+
+	nor_pins_default: nor-pins {
+		pins0 {
+			pinmux = <PINMUX_GPIO127__FUNC_B0_SPINOR_IO0>,
+				 <PINMUX_GPIO125__FUNC_O_SPINOR_CK>,
+				 <PINMUX_GPIO128__FUNC_B0_SPINOR_IO1>;
+			bias-pull-down;
+		};
+
+		pins1 {
+			pinmux = <PINMUX_GPIO126__FUNC_O_SPINOR_CS>;
+			bias-pull-up;
+		};
+	};
+
+	panel_pin_default: panel-default-pins {
+		pins-cmd-dat {
+			pinmux = <PINMUX_GPIO30__FUNC_B_GPIO30>;
+			output-low;
+		};
+	};
+
+	panel_pins_default: panel_pins_default {
+		pins_cmd_dat {
+			pinmux = <PINMUX_GPIO25__FUNC_B_GPIO25>,
+				 <PINMUX_GPIO1__FUNC_B_GPIO1>;
+			output-low;
+		};
+	};
+
+	pcie_pins_default: pcie-default {
+		mux {
+			pinmux = <PINMUX_GPIO47__FUNC_I1_WAKEN>,
+				 <PINMUX_GPIO48__FUNC_O_PERSTN>,
+				 <PINMUX_GPIO49__FUNC_B1_CLKREQN>;
+		};
+	};
+
+	pwm0_gpio_def_cfg: pwm0default {
+		pins_cmd_dat {
+			pinmux = <PINMUX_GPIO29__FUNC_O_DISP_PWM0>;
+			output-high;
+		};
+	};
+
+	pwm1_gpio_def_cfg: pwm1default {
+		pins_cmd_dat {
+			pinmux = <PINMUX_GPIO30__FUNC_O_DISP_PWM1>;
+			output-high;
+		};
+	};
+
+	sar_sensor_pins: sar-sensor-pins {
+		pins-irq {
+			pinmux = <PINMUX_GPIO88__FUNC_B_GPIO88>;
+			input-enable;
+			bias-pull-up;
+		};
+	};
+
+	scp_pins: scp {
+		pins_scp_vreq {
+			pinmux = <PINMUX_GPIO98__FUNC_O_SCP_VREQ_VAO>;
+			bias-disable;
+			input-enable;
+		};
+	};
+
+	spi0_pins: spi0_pins {
+		pins_spi {
+			pinmux = <PINMUX_GPIO69__FUNC_O_SPIM0_CSB>,
+				 <PINMUX_GPIO70__FUNC_O_SPIM0_CLK>,
+				 <PINMUX_GPIO71__FUNC_B0_SPIM0_MOSI>,
+				 <PINMUX_GPIO72__FUNC_B0_SPIM0_MISO>;
+			bias-disable;
+		};
+	};
+
+	spi1_pins: spi1_pins {
+		pins_spi {
+			pinmux = <PINMUX_GPIO75__FUNC_O_SPIM1_CSB>,
+				 <PINMUX_GPIO76__FUNC_O_SPIM1_CLK>,
+				 <PINMUX_GPIO77__FUNC_B0_SPIM1_MOSI>,
+				 <PINMUX_GPIO78__FUNC_B0_SPIM1_MISO>;
+			bias-disable;
+		};
+	};
+
+	spi2_pins: spi2_pins {
+		pins_spi {
+			pinmux = <PINMUX_GPIO79__FUNC_O_SPIM2_CSB>,
+				 <PINMUX_GPIO80__FUNC_O_SPIM2_CLK>,
+				 <PINMUX_GPIO81__FUNC_B0_SPIM2_MOSI>,
+				 <PINMUX_GPIO82__FUNC_B0_SPIM2_MISO>;
+			bias-disable;
+		};
+	};
+
+	touchscreen_pins: touchscreen-pins {
+		pins-irq {
+			pinmux = <PINMUX_GPIO143__FUNC_B_GPIO143>;
+			input-enable;
+		};
+	};
+
+	touchpad_pins: touchpad-pins {
+		pins-irq {
+			pinmux = <PINMUX_GPIO148__FUNC_B_GPIO148>;
+			input-enable;
+			bias-disable;
+		};
+	};
+};
+
+&pmic {
+	interrupt-parent = <&pio>;
+	interrupts = <222 IRQ_TYPE_LEVEL_HIGH>;
+};
+
+&scp {
+	firmware-name = "mediatek/mt8188/scp.img";
+	pinctrl-names = "default";
+	pinctrl-0 = <&scp_pins>;
+	memory-region = <&scp_mem_reserved>;
+	status = "okay";
+
+	mediatek,scp-core = <&scp_dual 0>;
+};
+
+&scp_dual {
+	status = "okay";
+	memory-region = <&scp_dual_mem_reserved>;
+	mediatek,scp-core = <&scp 1>;
+	firmware-name = "mediatek/mt8188/scp-dual.img";
+};
+
+&sound {
+	compatible = "mediatek,mt8188-nau8825";
+	model = "mt8188_m98390_8825";
+	mediatek,adsp = <&adsp>;
+	mediatek,dai-link = "DL10_FE", "ETDM1_IN_BE", "ETDM2_IN_BE",
+			"ETDM1_OUT_BE", "ETDM2_OUT_BE", "DPTX_BE", "UL_SRC_BE",
+			"AFE_SOF_DL2", "AFE_SOF_DL3", "AFE_SOF_UL4", "AFE_SOF_UL5";
+	pinctrl-names = "aud_etdm_hp_on",
+			"aud_etdm_hp_off",
+			"aud_etdm_spk_on",
+			"aud_etdm_spk_off",
+			"aud_mtkaif_on",
+			"aud_mtkaif_off";
+	pinctrl-0 = <&aud_etdm_hp_on>;
+	pinctrl-1 = <&aud_etdm_hp_off>;
+	pinctrl-2 = <&aud_etdm_spk_on>;
+	pinctrl-3 = <&aud_etdm_spk_off>;
+	pinctrl-4 = <&aud_mtkaif_on>;
+	pinctrl-5 = <&aud_mtkaif_off>;
+	audio-routing =
+		"ETDM1_OUT", "ETDM_SPK_PIN",
+		"ETDM2_OUT", "ETDM_HP_PIN",
+		"ETDM1_IN", "ETDM_SPK_PIN",
+		"ETDM2_IN", "ETDM_HP_PIN",
+		"ADDA Capture", "MTKAIF_PIN",
+		"Headphone Jack", "HPOL",
+		"Headphone Jack", "HPOR",
+		"MIC", "Headset Mic",
+		"Left Spk", "Front Left BE_OUT",
+		"Right Spk", "Front Right BE_OUT",
+		"Rear Left Spk", "Rear Left BE_OUT",
+		"Rear Right Spk", "Rear Right BE_OUT";
+	status = "okay";
+
+	dai-link-0 {
+		link-name = "ETDM2_OUT_BE";
+		mediatek,clk-provider = "cpu";
+		codec {
+			sound-dai = <&nau8825>;
+		};
+	};
+
+	dai-link-1 {
+		link-name = "ETDM2_IN_BE";
+		mediatek,clk-provider = "cpu";
+		codec {
+			sound-dai = <&nau8825>;
+		};
+	};
+
+	dai-link-2 {
+		link-name = "ETDM1_OUT_BE";
+		dai-format = "dsp_b";
+		mediatek,clk-provider = "cpu";
+		codec {
+			sound-dai = <&max98390_rr>,
+				    <&max98390_rl>,
+				    <&max98390_fr>,
+				    <&max98390_fl>;
+		};
+	};
+
+	dai-link-3 {
+		link-name = "ETDM1_IN_BE";
+		dai-format = "dsp_b";
+		mediatek,clk-provider = "cpu";
+	};
+
+	dai-link-4 {
+		link-name = "DPTX_BE";
+		codec {
+			sound-dai = <&dp_tx>;
+		};
+
+	};
+};
+
+&spi0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&spi0_pins>;
+	status = "okay";
+
+	cros_ec: cros-ec@0 {
+		compatible = "google,cros-ec-spi";
+		reg = <0>;
+		spi-max-frequency = <3000000>;
+		interrupt-parent = <&pio>;
+		interrupts = <149 IRQ_TYPE_LEVEL_LOW>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&ec_ap_int>;
+
+		i2c_tunnel: i2c-tunnel {
+			compatible = "google,cros-ec-i2c-tunnel";
+			google,remote-bus = <1>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+		};
+	};
+};
+
+&spi1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&spi1_pins>;
+	status = "okay";
+};
+
+&spi2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&spi2_pins>;
+	status = "okay";
+};
+
+&uart0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&uart0_pin>;
+	status = "okay";
+};
+
+&u2port0 {
+        status = "okay";
+};
+
+&u2port1 {
+        status = "okay";
+};
+
+&u2port2 {
+        status = "okay";
+};
+
+&u3port1 {
+        status = "okay";
+};
+
+&u3phy0 {
+	status="okay";
+};
+
+&u3phy1 {
+	status="okay";
+};
+
+&u3phy2 {
+	status="okay";
+};
+
+&xhci0 {
+	status = "okay";
+};
+
+&xhci1 {
+	status = "okay";
+	vbus-supply = <&usb_p1_vbus>;
+};
+
+&xhci2 {
+	status = "okay";
+	usb2-lpm-disable;
+};
+
+#include <arm/cros-ec-keyboard.dtsi>
+#include <arm/cros-ec-sbs.dtsi>
+
+&keyboard_controller {
+	function-row-physmap = <
+		MATRIX_KEY(0x00, 0x02, 0)	/* T1 */
+		MATRIX_KEY(0x03, 0x02, 0)	/* T2 */
+		MATRIX_KEY(0x02, 0x02, 0)	/* T3 */
+		MATRIX_KEY(0x01, 0x02, 0)	/* T4 */
+		MATRIX_KEY(0x03, 0x04, 0)	/* T5 */
+		MATRIX_KEY(0x02, 0x04, 0)	/* T6 */
+		MATRIX_KEY(0x01, 0x04, 0)	/* T7 */
+		MATRIX_KEY(0x02, 0x09, 0)	/* T8 */
+		MATRIX_KEY(0x01, 0x09, 0)	/* T9 */
+		MATRIX_KEY(0x00, 0x04, 0)	/* T10 */
+	>;
+
+	linux,keymap = <
+		MATRIX_KEY(0x00, 0x02, KEY_BACK)
+		MATRIX_KEY(0x03, 0x02, KEY_REFRESH)
+		MATRIX_KEY(0x02, 0x02, KEY_ZOOM)
+		MATRIX_KEY(0x01, 0x02, KEY_SCALE)
+		MATRIX_KEY(0x03, 0x04, KEY_BRIGHTNESSDOWN)
+		MATRIX_KEY(0x02, 0x04, KEY_BRIGHTNESSUP)
+		MATRIX_KEY(0x01, 0x04, KEY_MICMUTE)
+		MATRIX_KEY(0x02, 0x09, KEY_MUTE)
+		MATRIX_KEY(0x01, 0x09, KEY_VOLUMEDOWN)
+		MATRIX_KEY(0x00, 0x04, KEY_VOLUMEUP)
+		CROS_STD_MAIN_KEYMAP
+	>;
+};
diff --git a/arch/arm64/boot/dts/mediatek/mt8188.dtsi b/arch/arm64/boot/dts/mediatek/mt8188.dtsi
new file mode 100644
index 0000000000000000000000000000000000000000..e829c884316827c291498cb37e6361a43f9009ee
--- /dev/null
+++ b/arch/arm64/boot/dts/mediatek/mt8188.dtsi
@@ -0,0 +1,4809 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (c) 2022 MediaTek Inc.
+ *
+ */
+
+/dts-v1/;
+#include <dt-bindings/clock/mediatek,mt8188-clk.h>
+#include <dt-bindings/interrupt-controller/arm-gic.h>
+#include <dt-bindings/interrupt-controller/irq.h>
+#include <dt-bindings/mailbox/mediatek,mt8188-gce.h>
+#include <dt-bindings/memory/mediatek,mt8188-memory-port.h>
+#include <dt-bindings/phy/phy.h>
+#include <dt-bindings/pinctrl/mediatek,mt8188-pinfunc.h>
+#include <dt-bindings/power/mediatek,mt8188-power.h>
+#include <dt-bindings/reset/mt8188-resets.h>
+#include <dt-bindings/thermal/thermal.h>
+
+/ {
+	compatible = "mediatek,mt8188";
+	interrupt-parent = <&gic>;
+	#address-cells = <2>;
+	#size-cells = <2>;
+
+	aliases {
+		dp-intf1 = &dp_intf1;
+		ethdr0 = &ethdr0;
+		gce0 = &gce0;
+		gce1 = &gce1;
+		merge1 = &merge1;
+		merge2 = &merge2;
+		merge3 = &merge3;
+		merge4 = &merge4;
+		merge5 = &merge5;
+		mutex0 = &mutex;
+		mutex1 = &mutex1;
+		padding0 = &padding0;
+		padding1 = &padding1;
+		padding2 = &padding2;
+		padding3 = &padding3;
+		padding4 = &padding4;
+		padding5 = &padding5;
+		padding6 = &padding6;
+		padding7 = &padding7;
+		vdo1-rdma0 = &vdo1_rdma0;
+		vdo1-rdma1 = &vdo1_rdma1;
+		vdo1-rdma2 = &vdo1_rdma2;
+		vdo1-rdma3 = &vdo1_rdma3;
+		vdo1-rdma4 = &vdo1_rdma4;
+		vdo1-rdma5 = &vdo1_rdma5;
+		vdo1-rdma6 = &vdo1_rdma6;
+		vdo1-rdma7 = &vdo1_rdma7;
+	};
+
+	cpus {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		cpu0: cpu@0 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a55", "arm,armv8";
+			reg = <0x000>;
+			enable-method = "psci";
+			performance-domains = <&performance 0>;
+			clock-frequency = <2000000000>;
+			capacity-dmips-mhz = <282>;
+			cpu-idle-states = <&cpuoff_l &clusteroff_l>;
+			next-level-cache = <&l2_0>;
+			#cooling-cells = <2>;
+		};
+
+		cpu1: cpu@100 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a55", "arm,armv8";
+			reg = <0x100>;
+			enable-method = "psci";
+			performance-domains = <&performance 0>;
+			clock-frequency = <2000000000>;
+			capacity-dmips-mhz = <282>;
+			cpu-idle-states = <&cpuoff_l &clusteroff_l>;
+			next-level-cache = <&l2_0>;
+			#cooling-cells = <2>;
+		};
+
+		cpu2: cpu@200 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a55", "arm,armv8";
+			reg = <0x200>;
+			enable-method = "psci";
+			performance-domains = <&performance 0>;
+			clock-frequency = <2000000000>;
+			capacity-dmips-mhz = <282>;
+			cpu-idle-states = <&cpuoff_l &clusteroff_l>;
+			next-level-cache = <&l2_0>;
+			#cooling-cells = <2>;
+		};
+
+		cpu3: cpu@300 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a55", "arm,armv8";
+			reg = <0x300>;
+			enable-method = "psci";
+			performance-domains = <&performance 0>;
+			clock-frequency = <2000000000>;
+			capacity-dmips-mhz = <282>;
+			cpu-idle-states = <&cpuoff_l &clusteroff_l>;
+			next-level-cache = <&l2_0>;
+			#cooling-cells = <2>;
+		};
+
+		cpu4: cpu@400 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a55", "arm,armv8";
+			reg = <0x400>;
+			enable-method = "psci";
+			performance-domains = <&performance 0>;
+			clock-frequency = <2000000000>;
+			capacity-dmips-mhz = <282>;
+			cpu-idle-states = <&cpuoff_l &clusteroff_l>;
+			next-level-cache = <&l2_0>;
+			#cooling-cells = <2>;
+		};
+
+		cpu5: cpu@500 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a55", "arm,armv8";
+			reg = <0x500>;
+			enable-method = "psci";
+			performance-domains = <&performance 0>;
+			clock-frequency = <2000000000>;
+			capacity-dmips-mhz = <282>;
+			cpu-idle-states = <&cpuoff_l &clusteroff_l>;
+			next-level-cache = <&l2_0>;
+			#cooling-cells = <2>;
+		};
+
+		cpu6: cpu@600 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a78", "arm,armv8";
+			reg = <0x600>;
+			enable-method = "psci";
+			performance-domains = <&performance 1>;
+			clock-frequency = <2600000000>;
+			capacity-dmips-mhz = <1024>;
+			cpu-idle-states = <&cpuoff_b &clusteroff_b>;
+			next-level-cache = <&l2_1>;
+			#cooling-cells = <2>;
+		};
+
+		cpu7: cpu@700 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a78", "arm,armv8";
+			reg = <0x700>;
+			enable-method = "psci";
+			performance-domains = <&performance 1>;
+			clock-frequency = <2600000000>;
+			capacity-dmips-mhz = <1024>;
+			cpu-idle-states = <&cpuoff_b &clusteroff_b>;
+			next-level-cache = <&l2_1>;
+			#cooling-cells = <2>;
+		};
+
+		cpu-map {
+			cluster0 {
+				core0 {
+					cpu = <&cpu0>;
+				};
+
+				core1 {
+					cpu = <&cpu1>;
+				};
+
+				core2 {
+					cpu = <&cpu2>;
+				};
+
+				core3 {
+					cpu = <&cpu3>;
+				};
+
+				core4 {
+					cpu = <&cpu4>;
+				};
+
+				core5 {
+					cpu = <&cpu5>;
+				};
+			};
+
+			cluster1 {
+				core0 {
+					cpu = <&cpu6>;
+				};
+
+				core1 {
+					cpu = <&cpu7>;
+				};
+			};
+		};
+
+		idle-states {
+			entry-method = "arm,psci";
+
+			cpuoff_l: cpuoff_l {
+				compatible = "arm,idle-state";
+				arm,psci-suspend-param = <0x00010000>;
+				local-timer-stop;
+				entry-latency-us = <50>;
+				exit-latency-us = <95>;
+				min-residency-us = <580>;
+			};
+
+			cpuoff_b: cpuoff_b {
+				compatible = "arm,idle-state";
+				arm,psci-suspend-param = <0x00010000>;
+				local-timer-stop;
+				entry-latency-us = <45>;
+				exit-latency-us = <140>;
+				min-residency-us = <740>;
+			};
+
+			clusteroff_l: clusteroff_l {
+				compatible = "arm,idle-state";
+				arm,psci-suspend-param = <0x01010010>;
+				local-timer-stop;
+				entry-latency-us = <55>;
+				exit-latency-us = <155>;
+				min-residency-us = <840>;
+			};
+
+			clusteroff_b: clusteroff_b {
+				compatible = "arm,idle-state";
+				arm,psci-suspend-param = <0x01010010>;
+				local-timer-stop;
+				entry-latency-us = <50>;
+				exit-latency-us = <200>;
+				min-residency-us = <1000>;
+			};
+
+			mcusysoff: mcusysoff {
+				compatible = "arm,idle-state";
+				arm,psci-suspend-param = <0x01010024>;
+				local-timer-stop;
+				entry-latency-us = <640>;
+				exit-latency-us = <1400>;
+				min-residency-us = <13200>;
+			};
+
+			system_mem: system_mem {
+				compatible = "arm,idle-state";
+				arm,psci-suspend-param = <0x01010030>;
+				local-timer-stop;
+				entry-latency-us = <640>;
+				exit-latency-us = <1800>;
+				min-residency-us = <13200>;
+			};
+
+			system_pll: system_pll {
+				compatible = "arm,idle-state";
+				arm,psci-suspend-param = <0x01010040>;
+				local-timer-stop;
+				entry-latency-us = <640>;
+				exit-latency-us = <1850>;
+				min-residency-us = <13200>;
+			};
+
+			system_bus: system_bus {
+				compatible = "arm,idle-state";
+				arm,psci-suspend-param = <0x01010050>;
+				local-timer-stop;
+				entry-latency-us = <640>;
+				exit-latency-us = <2800>;
+				min-residency-us = <13200>;
+			};
+
+			s2idle: s2idle {
+				compatible = "arm,idle-state";
+				arm,psci-suspend-param = <0x01011f01>;
+				local-timer-stop;
+				entry-latency-us = <10000>;
+				exit-latency-us = <10000>;
+				min-residency-us = <4294967295>;
+			};
+		};
+
+		l2_0: l2-cache0 {
+			compatible = "cache";
+			cache-level = <2>;
+			next-level-cache = <&l3_0>;
+		};
+
+		l2_1: l2-cache1 {
+			compatible = "cache";
+			cache-level = <2>;
+			next-level-cache = <&l3_0>;
+		};
+
+		l3_0: l3-cache {
+			compatible = "cache";
+			cache-level = <3>;
+		};
+	};
+
+	clk13m: oscillator-13m {
+		compatible = "fixed-clock";
+		#clock-cells = <0>;
+		clock-frequency = <13000000>;
+		clock-output-names = "clk13m";
+	};
+
+
+	clk26m: oscillator-26m {
+		compatible = "fixed-clock";
+		#clock-cells = <0>;
+		clock-frequency = <26000000>;
+		clock-output-names = "clk26m";
+	};
+
+	clk32k: oscillator-32k {
+		compatible = "fixed-clock";
+		#clock-cells = <0>;
+		clock-frequency = <32768>;
+		clock-output-names = "clk32k";
+	};
+
+	gpu_opp_table: opp_table0 {
+		compatible = "operating-points-v2", "operating-points-v2-mali";
+		opp-shared;
+
+		opp-390000000 {
+			opp-hz = /bits/ 64 <390000000>;
+			opp-hz-real = /bits/ 64 <390000000>,
+				      /bits/ 64 <390000000>;
+			opp-microvolt = <575000>, <750000>;
+		};
+
+		opp-431000000 {
+			opp-hz = /bits/ 64 <431000000>;
+			opp-hz-real = /bits/ 64 <431000000>,
+				      /bits/ 64 <531000000>;
+			opp-microvolt = <587500>, <750000>;
+		};
+
+		opp-473000000 {
+			opp-hz = /bits/ 64 <473000000>;
+			opp-hz-real = /bits/ 64 <473000000>,
+				      /bits/ 64 <473000000>;
+			opp-microvolt = <600000>, <750000>;
+		};
+
+		opp-515000000 {
+			opp-hz = /bits/ 64 <515000000>;
+			opp-hz-real = /bits/ 64 <515000000>,
+				      /bits/ 64 <515000000>;
+			opp-microvolt = <612500>, <750000>;
+		};
+
+		opp-556000000 {
+			opp-hz = /bits/ 64 <556000000>;
+			opp-hz-real = /bits/ 64 <556000000>,
+				      /bits/ 64 <556000000>;
+			opp-microvolt = <625000>, <750000>;
+		};
+
+		opp-598000000 {
+			opp-hz = /bits/ 64 <598000000>;
+			opp-hz-real = /bits/ 64 <598000000>,
+				      /bits/ 64 <598000000>;
+			opp-microvolt = <637500>, <750000>;
+		};
+
+		opp-640000000 {
+			opp-hz = /bits/ 64 <640000000>;
+			opp-hz-real = /bits/ 64 <640000000>,
+				      /bits/ 64 <640000000>;
+			opp-microvolt = <650000>, <750000>;
+		};
+
+		opp-670000000 {
+			opp-hz = /bits/ 64 <670000000>;
+			opp-hz-real = /bits/ 64 <670000000>,
+				      /bits/ 64 <670000000>;
+			opp-microvolt = <662500>, <750000>;
+		};
+
+		opp-700000000 {
+			opp-hz = /bits/ 64 <700000000>;
+			opp-hz-real = /bits/ 64 <700000000>,
+				      /bits/ 64 <700000000>;
+			opp-microvolt = <675000>, <750000>;
+		};
+
+		opp-730000000 {
+			opp-hz = /bits/ 64 <730000000>;
+			opp-hz-real = /bits/ 64 <730000000>,
+				      /bits/ 64 <730000000>;
+			opp-microvolt = <687500>, <750000>;
+		};
+
+		opp-760000000 {
+			opp-hz = /bits/ 64 <760000000>;
+			opp-hz-real = /bits/ 64 <760000000>,
+				      /bits/ 64 <760000000>;
+			opp-microvolt = <700000>, <750000>;
+		};
+
+		opp-790000000 {
+			opp-hz = /bits/ 64 <790000000>;
+			opp-hz-real = /bits/ 64 <790000000>,
+				      /bits/ 64 <790000000>;
+			opp-microvolt = <712500>, <750000>;
+		};
+
+		opp-835000000 {
+			opp-hz = /bits/ 64 <835000000>;
+			opp-hz-real = /bits/ 64 <835000000>,
+				      /bits/ 64 <835000000>;
+			opp-microvolt = <731250>, <750000>;
+		};
+
+		opp-880000000 {
+			opp-hz = /bits/ 64 <880000000>;
+			opp-hz-real = /bits/ 64 <880000000>,
+				      /bits/ 64 <880000000>;
+			opp-microvolt = <750000>, <750000>;
+		};
+
+		opp-915000000 {
+			opp-hz = /bits/ 64 <915000000>;
+			opp-hz-real = /bits/ 64 <915000000>,
+				      /bits/ 64 <915000000>;
+			opp-microvolt = <775000>, <775000>;
+			opp-microvolt-bin5 = <762500>, <762500>;
+			opp-microvolt-bin6 = <750000>, <750000>;
+		};
+
+		opp-950000000 {
+			opp-hz = /bits/ 64 <950000000>;
+			opp-hz-real = /bits/ 64 <950000000>,
+				      /bits/ 64 <950000000>;
+			opp-microvolt = <800000>, <800000>;
+			opp-microvolt-bin5 = <775000>, <775000>;
+			opp-microvolt-bin6 = <750000>, <750000>;
+		};
+	};
+
+	pmu-a55 {
+		compatible = "arm,cortex-a55-pmu";
+		interrupt-parent = <&gic>;
+		interrupts = <GIC_PPI 7 IRQ_TYPE_LEVEL_HIGH &ppi_cluster0>;
+	};
+
+	pmu-a78 {
+		compatible = "arm,cortex-a78-pmu";
+		interrupt-parent = <&gic>;
+		interrupts = <GIC_PPI 7 IRQ_TYPE_LEVEL_HIGH &ppi_cluster1>;
+	};
+
+	psci {
+		compatible = "arm,psci-1.0";
+		method = "smc";
+	};
+
+	sound: sound {
+		mediatek,platform = <&afe>;
+		status = "disabled";
+	};
+
+	vtemp: vtemp {
+		compatible = "mediatek,virtual-temp";
+		#thermal-sensor-cells = <1>;
+	};
+
+	thermal_zones: thermal-zones {
+		cpu_little1 {
+			polling-delay = <0>; /* milliseconds */
+			polling-delay-passive = <0>; /* milliseconds */
+			thermal-sensors = <&lvtsmcu 0>;
+
+			trips {
+				cpu_little1_crit: cpu-little1-crit {
+					temperature = <119000>;
+					hysteresis = <2000>;
+					type = "critical";
+				};
+			};
+		};
+
+		cpu_little2 {
+			polling-delay = <0>; /* milliseconds */
+			polling-delay-passive = <0>; /* milliseconds */
+			thermal-sensors = <&lvtsmcu 1>;
+
+			trips {
+				cpu_little2_crit: cpu-little2-crit {
+					temperature = <119000>;
+					hysteresis = <2000>;
+					type = "critical";
+				};
+			};
+		};
+
+		cpu_little3 {
+			polling-delay = <0>; /* milliseconds */
+			polling-delay-passive = <0>; /* milliseconds */
+			thermal-sensors = <&lvtsmcu 2>;
+
+			trips {
+				cpu_little3_crit: cpu-little3-crit {
+					temperature = <119000>;
+					hysteresis = <2000>;
+					type = "critical";
+				};
+			};
+		};
+
+		cpu_little4 {
+			polling-delay = <0>; /* milliseconds */
+			polling-delay-passive = <0>; /* milliseconds */
+			thermal-sensors = <&lvtsmcu 3>;
+
+			trips {
+				cpu_little4_crit: cpu-little4-crit {
+					temperature = <119000>;
+					hysteresis = <2000>;
+					type = "critical";
+				};
+			};
+		};
+
+		cpu_big0 {
+			polling-delay = <0>; /* milliseconds */
+			polling-delay-passive = <0>; /* milliseconds */
+			thermal-sensors = <&lvtsmcu 4>;
+
+			trips {
+				cpu_big0_crit: cpu-big0-crit {
+					temperature = <119000>;
+					hysteresis = <2000>;
+					type = "critical";
+				};
+			};
+		};
+
+		cpu_big1 {
+			polling-delay = <0>; /* milliseconds */
+			polling-delay-passive = <0>; /* milliseconds */
+			thermal-sensors = <&lvtsmcu 5>;
+
+			trips {
+				cpu_big1_crit: cpu-big1-crit {
+					temperature = <119000>;
+					hysteresis = <2000>;
+					type = "critical";
+				};
+			};
+		};
+
+		apu {
+			polling-delay = <0>; /* milliseconds */
+			polling-delay-passive = <0>; /* milliseconds */
+			thermal-sensors = <&lvtsap 0>;
+
+			trips {
+				apu_crit: apu-crit {
+					temperature = <119000>;
+					hysteresis = <2000>;
+					type = "critical";
+				};
+			};
+		};
+
+		gpu1 {
+			polling-delay = <0>; /* milliseconds */
+			polling-delay-passive = <0>; /* milliseconds */
+			thermal-sensors = <&lvtsap 1>;
+
+			trips {
+				gpu1_crit: gpu1-crit {
+					temperature = <119000>;
+					hysteresis = <2000>;
+					type = "critical";
+				};
+			};
+		};
+
+		gpu2 {
+			polling-delay = <0>; /* milliseconds */
+			polling-delay-passive = <0>; /* milliseconds */
+			thermal-sensors = <&lvtsap 2>;
+
+			trips {
+				gpu2_crit: gpu2-crit {
+					temperature = <119000>;
+					hysteresis = <2000>;
+					type = "critical";
+				};
+			};
+		};
+
+		soc1 {
+			polling-delay = <0>; /* milliseconds */
+			polling-delay-passive = <0>; /* milliseconds */
+			thermal-sensors = <&lvtsap 3>;
+
+			trips {
+				soc1_crit: soc1-crit {
+					temperature = <119000>;
+					hysteresis = <2000>;
+					type = "critical";
+				};
+			};
+		};
+
+		soc2 {
+			polling-delay = <0>; /* milliseconds */
+			polling-delay-passive = <0>; /* milliseconds */
+			thermal-sensors = <&lvtsap 4>;
+
+			trips {
+				soc2_crit: soc2-crit {
+					temperature = <119000>;
+					hysteresis = <2000>;
+					type = "critical";
+				};
+			};
+		};
+
+		soc3 {
+			polling-delay = <0>; /* milliseconds */
+			polling-delay-passive = <0>; /* milliseconds */
+			thermal-sensors = <&lvtsap 5>;
+
+			trips {
+				soc3_crit: soc3-crit {
+					temperature = <119000>;
+					hysteresis = <2000>;
+					type = "critical";
+				};
+			};
+		};
+
+		cam1 {
+			polling-delay = <0>; /* milliseconds */
+			polling-delay-passive = <0>; /* milliseconds */
+			thermal-sensors = <&lvtsap 6>;
+
+			trips {
+				cam1_crit: cam1-crit {
+					temperature = <119000>;
+					hysteresis = <2000>;
+					type = "critical";
+				};
+			};
+		};
+
+		cam2 {
+			polling-delay = <0>; /* milliseconds */
+			polling-delay-passive = <0>; /* milliseconds */
+			thermal-sensors = <&lvtsap 7>;
+
+			trips {
+				cam2_crit: cam2-crit {
+					temperature = <119000>;
+					hysteresis = <2000>;
+					type = "critical";
+				};
+			};
+		};
+
+		soc_max {
+			polling-delay = <1000>; /* milliseconds */
+			polling-delay-passive = <100>; /* milliseconds */
+			thermal-sensors = <&vtemp 0>;
+			sustainable-power = <1500>;
+
+			trips {
+				threshold: trip-point@0 {
+					temperature = <68000>;
+					hysteresis = <2000>;
+					type = "passive";
+				};
+
+				target: target@1 {
+					temperature = <85000>;
+					hysteresis = <2000>;
+					type = "passive";
+				};
+
+				soc_max_crit: soc_max_crit@0 {
+					temperature = <115000>;
+					hysteresis = <2000>;
+					type = "critical";
+				};
+			};
+
+			cooling_map: cooling-maps {
+				map0 {
+					trip = <&target>;
+					cooling-device = <&cpu0
+						THERMAL_NO_LIMIT
+						THERMAL_NO_LIMIT>,
+							<&cpu1
+						THERMAL_NO_LIMIT
+						THERMAL_NO_LIMIT>,
+							<&cpu2
+						THERMAL_NO_LIMIT
+						THERMAL_NO_LIMIT>,
+							<&cpu3
+						THERMAL_NO_LIMIT
+						THERMAL_NO_LIMIT>,
+							<&cpu4
+						THERMAL_NO_LIMIT
+						THERMAL_NO_LIMIT>,
+							<&cpu5
+						THERMAL_NO_LIMIT
+						THERMAL_NO_LIMIT>;
+					contribution = <2345>;
+				};
+
+				map1 {
+					trip = <&target>;
+					cooling-device = <&cpu6
+						THERMAL_NO_LIMIT
+						THERMAL_NO_LIMIT>,
+							<&cpu7
+						THERMAL_NO_LIMIT
+						THERMAL_NO_LIMIT>;
+					contribution = <1024>;
+				};
+			};
+		};
+	};
+
+	timer: timer {
+		compatible = "arm,armv8-timer";
+		interrupt-parent = <&gic>;
+		interrupts = <GIC_PPI 13 IRQ_TYPE_LEVEL_HIGH 0>,
+			     <GIC_PPI 14 IRQ_TYPE_LEVEL_HIGH 0>,
+			     <GIC_PPI 11 IRQ_TYPE_LEVEL_HIGH 0>,
+			     <GIC_PPI 10 IRQ_TYPE_LEVEL_HIGH 0>;
+		clock-frequency = <13000000>;
+	};
+
+	soc {
+		#address-cells = <2>;
+		#size-cells = <2>;
+		compatible = "simple-bus";
+		dma-ranges = <0x0 0x0 0x0 0x0 0x4 0x0>;
+		ranges;
+
+		performance: performance-controller@11bc10 {
+			compatible = "mediatek,cpufreq-hw";
+			reg = <0 0x0011bc10 0 0x120>, <0 0x0011bd30 0 0x120>;
+			#performance-domain-cells = <1>;
+		};
+
+		gic: interrupt-controller@c000000 {
+			compatible = "arm,gic-v3";
+			#interrupt-cells = <4>;
+			#address-cells = <2>;
+			#size-cells = <2>;
+			#redistributor-regions = <1>;
+			interrupt-parent = <&gic>;
+			interrupt-controller;
+			reg = <0 0x0c000000 0 0x40000>,
+			      <0 0x0c040000 0 0x200000>;
+			interrupts = <GIC_PPI 9 IRQ_TYPE_LEVEL_HIGH 0>;
+
+			ppi-partitions {
+				ppi_cluster0: interrupt-partition-0 {
+					affinity = <&cpu0 &cpu1 &cpu2 &cpu3 &cpu4 &cpu5>;
+				};
+
+				ppi_cluster1: interrupt-partition-1 {
+					affinity = <&cpu6 &cpu7>;
+				};
+			};
+		};
+
+		topckgen: syscon@10000000 {
+			compatible = "mediatek,mt8188-topckgen", "syscon";
+			reg = <0 0x10000000 0 0x1000>;
+			#clock-cells = <1>;
+		};
+
+		infracfg_ao: syscon@10001000 {
+			compatible = "mediatek,mt8188-infracfg-ao", "syscon", "simple-mfd";
+			reg = <0 0x10001000 0 0x1000>;
+			#clock-cells = <1>;
+			#reset-cells = <1>;
+		};
+
+		pericfg: syscon@10003000 {
+			compatible = "mediatek,mt8188-pericfg", "syscon";
+			reg = <0 0x10003000 0 0x1000>;
+			#clock-cells = <1>;
+		};
+
+		pio: pinctrl@10005000 {
+			compatible = "mediatek,mt8188-pinctrl";
+			reg = <0 0x10005000 0 0x1000>,
+			      <0 0x11c00000 0 0x1000>,
+			      <0 0x11e10000 0 0x1000>,
+			      <0 0x11e20000 0 0x1000>,
+			      <0 0x11ea0000 0 0x1000>,
+			      <0 0x1000b000 0 0x1000>;
+			reg-names = "iocfg0", "iocfg_rm",
+				    "iocfg_lt", "iocfg_lm", "iocfg_rt",
+				    "eint";
+			gpio-controller;
+			#gpio-cells = <2>;
+			gpio-ranges = <&pio 0 0 176>;
+			interrupt-controller;
+			interrupts = <GIC_SPI 235 IRQ_TYPE_LEVEL_HIGH 0>;
+			#interrupt-cells = <2>;
+		};
+
+		scpsys: syscon@10006000 {
+			compatible = "syscon", "simple-mfd";
+			reg = <0 0x10006000 0 0x1000>;
+			#power-domain-cells = <1>;
+
+			/* System Power Manager */
+			spm: power-controller {
+				compatible = "mediatek,mt8188-power-controller";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				#power-domain-cells = <1>;
+
+				/* power domain of the SoC */
+				mfg0: mfg0@MT8188_POWER_DOMAIN_MFG0 {
+					reg = <MT8188_POWER_DOMAIN_MFG0>;
+					#address-cells = <1>;
+					#size-cells = <0>;
+					#power-domain-cells = <1>;
+
+					mfg1@MT8188_POWER_DOMAIN_MFG1 {
+						reg = <MT8188_POWER_DOMAIN_MFG1>;
+						clocks = <&topckgen CLK_TOP_MFG_CK_FAST_REF>,
+							 <&topckgen CLK_TOP_MFG_CORE_TMP>;
+						clock-names= "mfg10", "mfg11";
+						mediatek,infracfg = <&infracfg_ao>;
+						#address-cells = <1>;
+						#size-cells = <0>;
+						#power-domain-cells = <1>;
+
+						mfg2@MT8188_POWER_DOMAIN_MFG2 {
+							reg = <MT8188_POWER_DOMAIN_MFG2>;
+							#power-domain-cells = <0>;
+						};
+
+						mfg3@MT8188_POWER_DOMAIN_MFG3 {
+							reg = <MT8188_POWER_DOMAIN_MFG3>;
+							#power-domain-cells = <0>;
+						};
+
+						mfg4@MT8188_POWER_DOMAIN_MFG4 {
+							reg = <MT8188_POWER_DOMAIN_MFG4>;
+							#power-domain-cells = <0>;
+						};
+					};
+				};
+
+				vppsys0@MT8188_POWER_DOMAIN_VPPSYS0 {
+					reg = <MT8188_POWER_DOMAIN_VPPSYS0>;
+					clocks = <&topckgen CLK_TOP_VPP>,
+						 <&topckgen CLK_TOP_CAM>,
+						 <&topckgen CLK_TOP_CCU>,
+						 <&topckgen CLK_TOP_IMG>,
+						 <&topckgen CLK_TOP_VENC>,
+						 <&topckgen CLK_TOP_VDEC>,
+						 <&topckgen CLK_TOP_WPE_VPP>,
+						 <&topckgen CLK_TOP_CFGREG_CLOCK_EN_VPP0>,
+						 <&topckgen CLK_TOP_CFGREG_F26M_VPP0>,
+						 <&vppsys0 CLK_VPP0_SMI_COMMON_MMSRAM>,
+						 <&vppsys0 CLK_VPP0_GALS_VDO0_LARB0_MMSRAM>,
+						 <&vppsys0 CLK_VPP0_GALS_VDO0_LARB1_MMSRAM>,
+						 <&vppsys0 CLK_VPP0_GALS_VENCSYS_MMSRAM>,
+						 <&vppsys0 CLK_VPP0_GALS_VENCSYS_CORE1_MMSRAM>,
+						 <&vppsys0 CLK_VPP0_GALS_INFRA_MMSRAM>,
+						 <&vppsys0 CLK_VPP0_GALS_CAMSYS_MMSRAM>,
+						 <&vppsys0 CLK_VPP0_GALS_VPP1_LARB5_MMSRAM>,
+						 <&vppsys0 CLK_VPP0_GALS_VPP1_LARB6_MMSRAM>,
+						 <&vppsys0 CLK_VPP0_SMI_REORDER_MMSRAM>,
+						 <&vppsys0 CLK_VPP0_SMI_IOMMU>,
+						 <&vppsys0 CLK_VPP0_GALS_IMGSYS_CAMSYS>,
+						 <&vppsys0 CLK_VPP0_GALS_EMI0_EMI1>,
+						 <&vppsys0 CLK_VPP0_SMI_SUB_COMMON_REORDER>,
+						 <&vppsys0 CLK_VPP0_SMI_RSI>,
+						 <&vppsys0 CLK_VPP0_SMI_COMMON_LARB4>,
+						 <&vppsys0 CLK_VPP0_GALS_VDEC_VDEC_CORE1>,
+						 <&vppsys0 CLK_VPP0_GALS_VPP1_WPESYS>,
+						 <&vppsys0 CLK_VPP0_GALS_VDO0_VDO1_VENCSYS_CORE1>;
+					clock-names = "vppsys00", "vppsys01", "vppsys02", "vppsys03",
+						      "vppsys04", "vppsys05", "vppsys06", "vppsys07",
+						      "vppsys08", "vppsys0-0", "vppsys0-1", "vppsys0-2",
+						      "vppsys0-3", "vppsys0-4", "vppsys0-5", "vppsys0-6",
+						      "vppsys0-7", "vppsys0-8", "vppsys0-9", "vppsys0-10",
+						      "vppsys0-11", "vppsys0-12", "vppsys0-13", "vppsys0-14",
+						      "vppsys0-15", "vppsys0-16", "vppsys0-17", "vppsys0-18";
+					mediatek,infracfg = <&infracfg_ao>;
+					#address-cells = <1>;
+					#size-cells = <0>;
+					#power-domain-cells = <1>;
+
+					vdosys0@MT8188_POWER_DOMAIN_VDOSYS0 {
+						reg = <MT8188_POWER_DOMAIN_VDOSYS0>;
+						clocks = <&topckgen CLK_TOP_CFGREG_CLOCK_EN_VDO0>,
+							 <&topckgen CLK_TOP_CFGREG_F26M_VDO0>,
+							 <&vdosys0 CLK_VDO0_SMI_GALS>,
+							 <&vdosys0 CLK_VDO0_SMI_COMMON>,
+							 <&vdosys0 CLK_VDO0_SMI_EMI>,
+							 <&vdosys0 CLK_VDO0_SMI_IOMMU>,
+							 <&vdosys0 CLK_VDO0_SMI_LARB>,
+							 <&vdosys0 CLK_VDO0_SMI_RSI>,
+							 <&vdosys0 CLK_VDO0_APB_BUS>;
+						clock-names = "vdosys00", "vdosys01", "vdosys0-0",
+							      "vdosys0-1", "vdosys0-2", "vdosys0-3",
+							      "vdosys0-4", "vdosys0-5", "vdosys0-6";
+						mediatek,infracfg = <&infracfg_ao>;
+						#address-cells = <1>;
+						#size-cells = <0>;
+						#power-domain-cells = <1>;
+
+						vppsys1@MT8188_POWER_DOMAIN_VPPSYS1 {
+							reg = <MT8188_POWER_DOMAIN_VPPSYS1>;
+							clocks = <&topckgen CLK_TOP_CFGREG_CLOCK_EN_VPP1>,
+								 <&topckgen CLK_TOP_CFGREG_F26M_VPP1>,
+								 <&vppsys1 CLK_VPP1_GALS5>,
+								 <&vppsys1 CLK_VPP1_GALS6>,
+								 <&vppsys1 CLK_VPP1_LARB5>,
+								 <&vppsys1 CLK_VPP1_LARB6>;
+							clock-names = "vppsys10", "vppsys11", "vppsys1-0",
+								      "vppsys1-1", "vppsys1-2", "vppsys1-3";
+							mediatek,infracfg = <&infracfg_ao>;
+							#power-domain-cells = <0>;
+						};
+
+						vdec0@MT8188_POWER_DOMAIN_VDEC0 {
+							reg = <MT8188_POWER_DOMAIN_VDEC0>;
+							clocks = <&vdecsys_soc CLK_VDEC1_SOC_LARB1>;
+							clock-names = "vdec0-0";
+							mediatek,infracfg = <&infracfg_ao>;
+							#address-cells = <1>;
+							#size-cells = <0>;
+							#power-domain-cells = <1>;
+
+							vdec1@MT8188_POWER_DOMAIN_VDEC1 {
+								reg = <MT8188_POWER_DOMAIN_VDEC1>;
+								clocks = <&vdecsys CLK_VDEC2_LARB1>;
+								clock-names = "vdec1-0";
+								mediatek,infracfg = <&infracfg_ao>;
+								#power-domain-cells = <0>;
+							};
+						};
+
+						cam_vcore: cam_vcore@MT8188_POWER_DOMAIN_CAM_VCORE {
+							reg = <MT8188_POWER_DOMAIN_CAM_VCORE>;
+							clocks = <&topckgen CLK_TOP_CAM>,
+								 <&topckgen CLK_TOP_CCU>,
+								 <&topckgen CLK_TOP_CCU_AHB>,
+								 <&topckgen CLK_TOP_CFGREG_CLOCK_ISP_AXI_GALS>;
+							clock-names = "cam_vcore0", "cam_vcore1",
+								      "cam_vcore2", "cam_vcore3";
+							mediatek,infracfg = <&infracfg_ao>;
+							#address-cells = <1>;
+							#size-cells = <0>;
+							#power-domain-cells = <1>;
+
+							cam_main@MT8188_POWER_DOMAIN_CAM_MAIN {
+								reg = <MT8188_POWER_DOMAIN_CAM_MAIN>;
+								clocks = <&camsys CLK_CAM_MAIN_LARB13>,
+									 <&camsys CLK_CAM_MAIN_LARB14>,
+									 <&camsys CLK_CAM_MAIN_CAM2MM0_GALS>,
+									 <&camsys CLK_CAM_MAIN_CAM2MM1_GALS>,
+									 <&camsys CLK_CAM_MAIN_CAM2SYS_GALS>;
+								clock-names= "cam_main-0", "cam_main-1",
+									     "cam_main-2", "cam_main-3",
+									     "cam_main-4";
+								mediatek,infracfg = <&infracfg_ao>;
+								#address-cells = <1>;
+								#size-cells = <0>;
+								#power-domain-cells = <1>;
+
+								cam_subb@MT8188_POWER_DOMAIN_CAM_SUBB {
+									reg =<MT8188_POWER_DOMAIN_CAM_SUBB>;
+									clocks = <&camsys CLK_CAM_MAIN_CAM_SUBB>,
+										 <&camsys_rawb CLK_CAM_RAWB_LARBX>,
+										 <&camsys_yuvb CLK_CAM_YUVB_LARBX>;
+									clock-names = "cam_subb-0", "cam_subb-1", "cam_subb-2";
+									mediatek,smi = <&smi_cam0>;
+									mediatek,larb = <&camsys_rawb &camsys_yuvb>;
+									#power-domain-cells = <0>;
+								};
+
+								cam_suba@MT8188_POWER_DOMAIN_CAM_SUBA {
+									reg =<MT8188_POWER_DOMAIN_CAM_SUBA>;
+									clocks = <&camsys CLK_CAM_MAIN_CAM_SUBA>,
+										 <&camsys_rawa CLK_CAM_RAWA_LARBX>,
+										 <&camsys_yuva CLK_CAM_YUVA_LARBX>;
+									clock-names = "cam_suba-0", "cam_suba-1", "cam_suba-2";
+									mediatek,smi = <&smi_cam1>;
+									mediatek,larb = <&camsys_rawa &camsys_yuva>;
+									#power-domain-cells = <0>;
+								};
+							};
+						};
+
+						vdosys1@MT8188_POWER_DOMAIN_VDOSYS1 {
+							reg = <MT8188_POWER_DOMAIN_VDOSYS1>;
+							clocks = <&topckgen CLK_TOP_CFGREG_CLOCK_EN_VDO1>,
+								 <&topckgen CLK_TOP_CFGREG_F26M_VDO1>,
+								 <&vdosys1 CLK_VDO1_SMI_LARB2>,
+								 <&vdosys1 CLK_VDO1_SMI_LARB3>,
+								 <&vdosys1 CLK_VDO1_GALS>;
+							clock-names = "vdosys10", "vdosys11", "vdosys1-0",
+								      "vdosys1-1", "vdosys1-2";
+							mediatek,infracfg = <&infracfg_ao>;
+							#address-cells = <1>;
+							#size-cells = <0>;
+							#power-domain-cells = <1>;
+
+							hdmi_tx@MT8188_POWER_DOMAIN_HDMI_TX {
+								reg = <MT8188_POWER_DOMAIN_HDMI_TX>;
+								clocks = <&topckgen CLK_TOP_HDMI_APB>,
+									 <&topckgen CLK_TOP_HDCP_24M>;
+								clock-names = "hdmi_tx0", "hdmi_tx1";
+								mediatek,infracfg = <&infracfg_ao>;
+								#power-domain-cells = <0>;
+							};
+
+							dp_tx@MT8188_POWER_DOMAIN_DP_TX {
+								reg = <MT8188_POWER_DOMAIN_DP_TX>;
+								mediatek,infracfg = <&infracfg_ao>;
+								#power-domain-cells = <0>;
+							};
+
+							edp_tx@MT8188_POWER_DOMAIN_EDP_TX {
+								reg = <MT8188_POWER_DOMAIN_EDP_TX>;
+								mediatek,infracfg = <&infracfg_ao>;
+								#power-domain-cells = <0>;
+							};
+						};
+
+						venc@MT8188_POWER_DOMAIN_VENC {
+							reg = <MT8188_POWER_DOMAIN_VENC>;
+							clocks = <&vencsys CLK_VENC1_LARB>,
+								 <&vencsys CLK_VENC1_VENC>,
+								 <&vencsys CLK_VENC1_GALS>,
+								 <&vencsys CLK_VENC1_GALS_SRAM>;
+							clock-names = "venc-0", "venc-1", "venc-2", "venc-3";
+							mediatek,infracfg = <&infracfg_ao>;
+							#power-domain-cells = <0>;
+						};
+
+						wpe@MT8188_POWER_DOMAIN_WPE {
+							reg = <MT8188_POWER_DOMAIN_WPE>;
+							clocks = <&wpesys CLK_WPE_TOP_SMI_LARB7>,
+								 <&wpesys CLK_WPE_TOP_SMI_LARB7_PCLK_EN>;
+							clock-names = "wpe-0", "wpe-1";
+							mediatek,infracfg = <&infracfg_ao>;
+							#power-domain-cells = <0>;
+						};
+
+						img_vcore: img_vcore@MT8188_POWER_DOMAIN_IMG_VCORE {
+							reg = <MT8188_POWER_DOMAIN_IMG_VCORE>;
+							clocks = <&topckgen CLK_TOP_IMG>,
+								 <&topckgen CLK_TOP_CFGREG_CLOCK_ISP_AXI_GALS>;
+							clock-names = "img_vcore0", "img_vcore1";
+							mediatek,infracfg = <&infracfg_ao>;
+							#address-cells = <1>;
+							#size-cells = <0>;
+							#power-domain-cells = <1>;
+
+							img_main@MT8188_POWER_DOMAIN_IMG_MAIN {
+								reg = <MT8188_POWER_DOMAIN_IMG_MAIN>;
+								clocks = <&imgsys CLK_IMGSYS_MAIN_LARB9>,
+									 <&imgsys CLK_IMGSYS_MAIN_VCORE_GALS>,
+									 <&imgsys CLK_IMGSYS_MAIN_DIP0>,
+									 <&imgsys CLK_IMGSYS_MAIN_GALS>;
+								clock-names = "img_main-0", "img_main-1",
+									      "img_main-2", "img_main-3";
+								mediatek,infracfg = <&infracfg_ao>;
+								#address-cells = <1>;
+								#size-cells = <0>;
+								#power-domain-cells = <1>;
+
+								dip@MT8188_POWER_DOMAIN_DIP {
+									reg = <MT8188_POWER_DOMAIN_DIP>;
+									clocks = <&imgsys CLK_IMGSYS_MAIN_WPE0>,
+										 <&imgsys CLK_IMGSYS_MAIN_IPE>,
+										 <&imgsys CLK_IMGSYS_MAIN_WPE1>,
+										 <&imgsys CLK_IMGSYS_MAIN_WPE2>,
+										 <&imgsys1_dip_top CLK_IMGSYS1_DIP_TOP_LARB10>,
+										 <&imgsys_wpe1 CLK_IMGSYS_WPE1_LARB11>,
+										 <&imgsys_wpe2 CLK_IMGSYS_WPE2_LARB11>,
+										 <&imgsys_wpe3 CLK_IMGSYS_WPE3_LARB11>,
+										 <&imgsys1_dip_nr CLK_IMGSYS1_DIP_NR_LARB15>;
+									clock-names = "dip-0", "dip-1", "dip-2",
+										      "dip-3", "dip-4", "dip-5",
+										      "dip-6", "dip-7", "dip-8";
+									mediatek,smi = <&smi_img0 &smi_img1>;
+									mediatek,larb = <&imgsys1_dip_top &imgsys_wpe1
+											 &imgsys_wpe3 &imgsys_wpe2
+											 &imgsys1_dip_nr>;
+									#power-domain-cells = <0>;
+								};
+
+								ipe@MT8188_POWER_DOMAIN_IPE {
+									reg = <MT8188_POWER_DOMAIN_IPE>;
+									clocks = <&topckgen CLK_TOP_IPE>,
+										 <&imgsys CLK_IMGSYS_MAIN_IPE>,
+										 <&ipesys CLK_IPE_SMI_LARB12>;
+									clock-names= "ipe0", "ipe-0", "ipe-1";
+									mediatek,smi = <&smi_img1>;
+									mediatek,larb = <&ipesys>;
+									#power-domain-cells = <0>;
+								};
+							};
+						};
+					};
+				};
+
+				pextp_mac_p0@MT8188_POWER_DOMAIN_PEXTP_MAC_P0 {
+					reg = <MT8188_POWER_DOMAIN_PEXTP_MAC_P0>;
+					mediatek,infracfg = <&infracfg_ao>;
+					clocks = <&pericfg_ao CLK_PERI_AO_PCIE_P0_FMEM>;
+					clock-names = "pextp_mac_p0-0";
+					#power-domain-cells = <0>;
+				};
+
+				csirx_top@MT8188_POWER_DOMAIN_CSIRX_TOP {
+					reg = <MT8188_POWER_DOMAIN_CSIRX_TOP>;
+					clocks = <&topckgen CLK_TOP_SENINF>,
+						 <&topckgen CLK_TOP_SENINF1>;
+					clock-names = "csirx_top0", "csirx_top1";
+					#power-domain-cells = <0>;
+				};
+
+				pextp_phy_top@MT8188_POWER_DOMAIN_PEXTP_PHY_TOP {
+					reg = <MT8188_POWER_DOMAIN_PEXTP_PHY_TOP>;
+					#power-domain-cells = <0>;
+				};
+
+				adsp_ao@MT8188_POWER_DOMAIN_ADSP_AO {
+					reg = <MT8188_POWER_DOMAIN_ADSP_AO>;
+					mediatek,infracfg = <&infracfg_ao>;
+					#address-cells = <1>;
+					#size-cells = <0>;
+					#power-domain-cells = <1>;
+
+					adsp_infra@MT8188_POWER_DOMAIN_ADSP_INFRA {
+						reg = <MT8188_POWER_DOMAIN_ADSP_INFRA>;
+						clocks = <&topckgen CLK_TOP_AUDIO_LOCAL_BUS>,
+							 <&topckgen CLK_TOP_ADSP>;
+						clock-names = "adsp_infra0", "adsp_infra1";
+						mediatek,infracfg = <&infracfg_ao>;
+						#address-cells = <1>;
+						#size-cells = <0>;
+						#power-domain-cells = <1>;
+
+						audio_asrc@MT8188_POWER_DOMAIN_AUDIO_ASRC {
+							reg = <MT8188_POWER_DOMAIN_AUDIO_ASRC>;
+							clocks = <&topckgen CLK_TOP_ASM_H>;
+							clock-names = "audio_asrc0";
+							mediatek,infracfg = <&infracfg_ao>;
+							#power-domain-cells = <0>;
+						};
+
+						audio@MT8188_POWER_DOMAIN_AUDIO {
+							reg = <MT8188_POWER_DOMAIN_AUDIO>;
+							clocks = <&topckgen CLK_TOP_A1SYS_HP>,
+								 <&topckgen CLK_TOP_AUD_INTBUS>,
+								 <&adsp_audio26m CLK_AUDIODSP_AUDIO26M>;
+							clock-names = "audio0", "audio1", "audio2";
+							mediatek,infracfg = <&infracfg_ao>;
+							#power-domain-cells = <0>;
+						};
+
+						adsp@MT8188_POWER_DOMAIN_ADSP {
+							reg = <MT8188_POWER_DOMAIN_ADSP>;
+							clocks = <&apmixedsys CLK_APMIXED_ADSPPLL>;
+							clock-names = "clk_apmixed_adsppll";
+							mediatek,infracfg = <&infracfg_ao>;
+							#power-domain-cells = <0>;
+						};
+					};
+				};
+
+				ether@MT8188_POWER_DOMAIN_ETHER {
+					reg = <MT8188_POWER_DOMAIN_ETHER>;
+					clocks = <&pericfg_ao CLK_PERI_AO_ETHERNET_MAC>;
+					clock-names = "ether0";
+					mediatek,infracfg = <&infracfg_ao>;
+					#power-domain-cells = <0>;
+				};
+			};
+		};
+
+		watchdog: watchdog@10007000 {
+			compatible = "mediatek,mt8188-wdt",
+				     "mediatek,mt6589-wdt";
+			mediatek,disable-extrst;
+			reg = <0 0x10007000 0 0x100>;
+			#reset-cells = <1>;
+		};
+
+		apmixedsys: syscon@1000c000 {
+			compatible = "mediatek,mt8188-apmixedsys", "syscon";
+			reg = <0 0x1000c000 0 0x1000>;
+			#clock-cells = <1>;
+		};
+
+		systimer: timer@10017000 {
+			compatible = "mediatek,mt8188-timer",
+				     "mediatek,mt6765-timer";
+			reg = <0 0x10017000 0 0x1000>;
+			reg-names = "sys_timer_base";
+			interrupts = <GIC_SPI 265 IRQ_TYPE_LEVEL_HIGH 0>;
+			clocks = <&clk13m>;
+		};
+
+		pwrap: pwrap@10024000 {
+			compatible = "mediatek,mt8195-pwrap", "syscon";
+			reg = <0 0x10024000 0 0x1000>;
+			reg-names = "pwrap";
+			interrupts = <GIC_SPI 243 IRQ_TYPE_LEVEL_HIGH 0>;
+			clocks = <&infracfg_ao CLK_INFRA_AO_PMIC_AP>,
+				 <&infracfg_ao CLK_INFRA_AO_PMIC_TMR>;
+			clock-names = "spi", "wrap";
+		};
+
+		spmi: spmi@10027000 {
+			compatible = "mediatek,mt8188-spmi",
+				     "mediatek,mt8195-spmi";
+			reg = <0 0x10027000 0 0x000e00>,
+			      <0 0x10029000 0 0x000100>;
+			reg-names = "pmif", "spmimst";
+			interrupts = <GIC_SPI 244 IRQ_TYPE_LEVEL_HIGH 0>,
+				     <GIC_SPI 256 IRQ_TYPE_LEVEL_HIGH 0>;
+			irq_event_en = <0x18000000 0x0001c000 0x0 0x0 0x0>;
+			clocks = <&infracfg_ao CLK_INFRA_AO_PMIC_AP>,
+				 <&infracfg_ao CLK_INFRA_AO_PMIC_TMR>,
+				 <&topckgen CLK_TOP_SPMI_M_MST>;
+			clock-names = "pmif_sys_ck",
+				      "pmif_tmr_ck",
+				      "spmimst_clk_mux";
+			assigned-clocks = <&topckgen CLK_TOP_SPMI_M_MST>;
+			assigned-clock-parents = <&topckgen CLK_TOP_MAINPLL_D7_D8>;
+		};
+
+		systracker: systracker@10208000 {
+			compatible = "mediatek,bus_dbg-v2";
+			reg = <0 0x10208000 0 0x1000>,
+			      <0 0x10001000 0 0x1000>;
+			mediatek,bus_dbg_con_offset = <0x2fc>;
+			interrupts = <GIC_SPI 207 IRQ_TYPE_LEVEL_HIGH 0>;
+		};
+
+		infra_iommu: iommu@10315000 {
+			compatible = "mediatek,mt8188-iommu-infra";
+			reg = <0 0x10315000 0 0x1000>;
+			interrupts = <GIC_SPI 795 IRQ_TYPE_LEVEL_HIGH 0>;
+			#iommu-cells = <1>;
+		};
+
+		gce0: mailbox@10320000 {
+			compatible = "mediatek,mt8188-gce";
+			reg = <0 0x10320000 0 0x4000>;
+			interrupts = <GIC_SPI 226 IRQ_TYPE_LEVEL_HIGH 0>;
+			#mbox-cells = <2>;
+			clocks = <&infracfg_ao CLK_INFRA_AO_GCE>;
+		};
+
+		gce1: mailbox@10330000 {
+			compatible = "mediatek,mt8188-gce";
+			reg = <0 0x10330000 0 0x4000>;
+			interrupts = <GIC_SPI 228 IRQ_TYPE_LEVEL_HIGH 0>;
+			#mbox-cells = <2>;
+			clocks = <&infracfg_ao CLK_INFRA_AO_GCE2>;
+		};
+
+		scp: scp@10500000 {
+			compatible = "mediatek,mt8188-scp";
+			reg = <0 0x10500000 0 0x100000>,
+			      <0 0x10720000 0 0xe0000>;
+			reg-names = "sram", "cfg";
+			interrupts = <GIC_SPI 462 IRQ_TYPE_LEVEL_HIGH 0>;
+		};
+
+		scp_dual: scp-dual@105af000 {
+			compatible = "mediatek,mt8195-scp-dual";
+			reg = <0 0x105e0000 0 0x1f000>,
+			      <0 0x10720000 0 0xe0000>;
+			reg-names = "sram", "cfg";
+			interrupts = <GIC_SPI 463 IRQ_TYPE_LEVEL_HIGH 0>;
+			status = "disabled";
+		};
+
+		adsp_audio26m: clock-controller@10b91100 {
+			compatible = "mediatek,mt8188-adsp-audio26m";
+			reg = <0 0x10b91100 0 0x100>;
+			#clock-cells = <1>;
+		};
+
+		afe: afe@10b10000 {
+			compatible = "mediatek,mt8188-afe";
+			mediatek,topckgen = <&topckgen>;
+			mediatek,infracfg = <&infracfg_ao>;
+			power-domains = <&spm MT8188_POWER_DOMAIN_AUDIO>;
+			interrupts = <GIC_SPI 822 IRQ_TYPE_LEVEL_HIGH 0>;
+			resets = <&watchdog 14>;
+			reset-names = "audiosys";
+			reg = <0 0x10b10000 0 0x10000>;
+			clocks = <&clk26m>,
+				 <&apmixedsys CLK_APMIXED_APLL1>,
+				 <&apmixedsys CLK_APMIXED_APLL2>,
+				 <&topckgen CLK_TOP_APLL12_CK_DIV0>,
+				 <&topckgen CLK_TOP_APLL12_CK_DIV1>,
+				 <&topckgen CLK_TOP_APLL12_CK_DIV2>,
+				 <&topckgen CLK_TOP_APLL12_CK_DIV3>,
+				 <&topckgen CLK_TOP_APLL12_CK_DIV9>,
+				 <&topckgen CLK_TOP_A1SYS_HP>,
+				 <&topckgen CLK_TOP_AUD_INTBUS>,
+				 <&topckgen CLK_TOP_AUDIO_H>,
+				 <&topckgen CLK_TOP_AUDIO_LOCAL_BUS>,
+				 <&topckgen CLK_TOP_DPTX>,
+				 <&topckgen CLK_TOP_I2SO1>,
+				 <&topckgen CLK_TOP_I2SO2>,
+				 <&topckgen CLK_TOP_I2SI1>,
+				 <&topckgen CLK_TOP_I2SI2>,
+				 <&adsp_audio26m CLK_AUDIODSP_AUDIO26M>,
+				 <&topckgen CLK_TOP_APLL1_D4>,
+				 <&topckgen CLK_TOP_APLL2_D4>,
+				 <&topckgen CLK_TOP_APLL12_CK_DIV4>,
+				 <&topckgen CLK_TOP_A2SYS>,
+				 <&topckgen CLK_TOP_AUD_IEC>;
+			clock-names = "clk26m",
+				      "apll1",
+				      "apll2",
+				      "apll12_div0",
+				      "apll12_div1",
+				      "apll12_div2",
+				      "apll12_div3",
+				      "apll12_div9",
+				      "top_a1sys_hp",
+				      "top_aud_intbus",
+				      "top_audio_h",
+				      "top_audio_local_bus",
+				      "top_dptx",
+				      "top_i2so1",
+				      "top_i2so2",
+				      "top_i2si1",
+				      "top_i2si2",
+				      "adsp_audio_26m",
+				      "apll1_d4",
+				      "apll2_d4",
+				      "apll12_div4",
+				      "top_a2sys",
+				      "top_aud_iec";
+			assigned-clocks = <&topckgen CLK_TOP_A1SYS_HP>;
+			assigned-clock-parents =  <&clk26m>;
+			status = "disabled";
+		};
+
+		adsp: adsp@10b80000 {
+			compatible = "mediatek,mt8188-dsp";
+			reg = <0 0x10b80000 0 0x2000>,
+			      <0 0x10d00000 0 0x80000>,
+			      <0 0x10b8b000 0 0x100>,
+			      <0 0x10b8f000 0 0x1000>;
+			reg-names = "cfg", "sram", "sec", "bus";
+			interrupts = <GIC_SPI 474 IRQ_TYPE_LEVEL_HIGH 0>;
+			interrupt-names = "wdt";
+			clocks = <&topckgen CLK_TOP_ADSP>,
+				 <&topckgen CLK_TOP_AUDIO_LOCAL_BUS>;
+			clock-names = "audiodsp",
+				      "adsp_bus";
+			assigned-clocks = <&topckgen CLK_TOP_ADSP>;
+			power-domains = <&spm MT8188_POWER_DOMAIN_ADSP>;
+			mbox-names = "rx", "tx";
+			mboxes = <&adsp_mailbox0>, <&adsp_mailbox1>;
+			status = "disabled";
+		};
+
+		adsp_mailbox0: mailbox@10b86000 {
+			compatible = "mediatek,mt8186-adsp-mbox";
+			#mbox-cells = <0>;
+			reg = <0 0x10b86100 0 0x1000>;
+			interrupts = <GIC_SPI 478 IRQ_TYPE_LEVEL_HIGH 0>;
+		};
+
+		adsp_mailbox1: mailbox@10b87000 {
+			compatible = "mediatek,mt8186-adsp-mbox";
+			#mbox-cells = <0>;
+			reg = <0 0x10b87100 0 0x1000>;
+			interrupts = <GIC_SPI 479 IRQ_TYPE_LEVEL_HIGH 0>;
+		};
+
+		uart0: serial@11001100 {
+			compatible = "mediatek,mt8188-uart",
+				     "mediatek,mt6577-uart";
+			reg = <0 0x11001100 0 0x100>;
+			interrupts = <GIC_SPI 141 IRQ_TYPE_LEVEL_HIGH 0>;
+			clocks = <&clk26m>, <&infracfg_ao CLK_INFRA_AO_UART0>;
+			clock-names = "baud", "bus";
+			status = "disabled";
+		};
+
+		uart1: serial@11001200 {
+			compatible = "mediatek,mt8188-uart",
+				     "mediatek,mt6577-uart";
+			reg = <0 0x11001200 0 0x100>;
+			interrupts = <GIC_SPI 142 IRQ_TYPE_LEVEL_HIGH 0>;
+			clocks = <&clk26m>, <&infracfg_ao CLK_INFRA_AO_UART1>;
+			clock-names = "baud", "bus";
+			status = "disabled";
+		};
+
+		uart2: serial@11001300 {
+			compatible = "mediatek,mt8188-uart",
+				     "mediatek,mt6577-uart";
+			reg = <0 0x11001300 0 0x100>;
+			interrupts = <GIC_SPI 143 IRQ_TYPE_LEVEL_HIGH 0>;
+			clocks = <&clk26m>, <&infracfg_ao CLK_INFRA_AO_UART2>;
+			clock-names = "baud", "bus";
+			status = "disabled";
+		};
+
+		uart3: serial@11001400 {
+			compatible = "mediatek,mt8188-uart",
+				     "mediatek,mt6577-uart";
+			reg = <0 0x11001400 0 0x100>;
+			interrupts = <GIC_SPI 723 IRQ_TYPE_LEVEL_HIGH 0>;
+			clocks = <&clk26m>, <&infracfg_ao CLK_INFRA_AO_UART3>;
+			clock-names = "baud", "bus";
+			status = "disabled";
+		};
+
+		auxadc: adc@11002000 {
+			compatible = "mediatek,mt8188-auxadc",
+				     "mediatek,mt8173-auxadc";
+			reg = <0 0x11002000 0 0x1000>;
+			clocks = <&infracfg_ao CLK_INFRA_AO_AUXADC>;
+			clock-names = "main";
+			#io-channel-cells = <1>;
+			status = "disabled";
+		};
+
+		pericfg_ao: syscon@11003000 {
+			compatible = "mediatek,mt8188-pericfg-ao", "syscon";
+			reg = <0 0x11003000 0 0x1000>;
+			#clock-cells = <1>;
+		};
+
+		spi0: spi0@1100a000 {
+			compatible = "mediatek,mt8188-spi-ipm",
+				     "mediatek,spi-ipm";
+			reg = <0 0x1100a000 0 0x1000>;
+			interrupts = <GIC_SPI 191 IRQ_TYPE_LEVEL_HIGH 0>;
+			clocks = <&topckgen CLK_TOP_UNIVPLL_D6_D2>,
+				 <&topckgen CLK_TOP_SPI>,
+				 <&infracfg_ao CLK_INFRA_AO_SPI0>;
+			clock-names = "parent-clk", "sel-clk", "spi-clk";
+			status = "disabled";
+		};
+
+		lvtsap: lvts@1100b000 {
+			compatible = "mediatek,mt8188-lvts-ap";
+			#thermal-sensor-cells = <1>;
+			reg = <0 0x1100b000 0 0x1000>;
+			interrupts = <GIC_SPI 200 IRQ_TYPE_LEVEL_HIGH 0>;
+			clocks = <&infracfg_ao CLK_INFRA_AO_THERM>;
+			resets = <&infracfg_ao MT8188_INFRA_RST1_THERMAL_CTRL_RST>;
+			nvmem-cells = <&lvts_efuse_data1>;
+			nvmem-cell-names = "lvts_calib_data1";
+		};
+
+		disp_pwm0: disp_pwm0@1100e000 {
+			compatible = "mediatek,mt8188-disp-pwm",
+				     "mediatek,mt8183-disp-pwm";
+			reg = <0 0x1100e000 0 0x1000>;
+			interrupts = <GIC_SPI 203 IRQ_TYPE_LEVEL_HIGH 0>;
+			#pwm-cells = <2>;
+			clocks = <&topckgen CLK_TOP_DISP_PWM0>,
+				 <&infracfg_ao CLK_INFRA_AO_DISP_PWM>,
+				 <&topckgen CLK_TOP_ULPOSC1_D4>;
+			clock-names = "main", "mm", "pwm_src";
+			status = "disabled";
+		};
+
+		disp_pwm1: disp_pwm1@1100f000 {
+			compatible = "mediatek,mt8188-disp-pwm",
+				     "mediatek,mt8183-disp-pwm";
+			reg = <0 0x1100f000 0 0x1000>;
+			interrupts = <GIC_SPI 793 IRQ_TYPE_LEVEL_HIGH 0>;
+			#pwm-cells = <2>;
+			clocks = <&topckgen CLK_TOP_DISP_PWM1>,
+				 <&infracfg_ao CLK_INFRA_AO_DISP_PWM1>,
+				 <&topckgen CLK_TOP_ULPOSC1_D4>;
+			clock-names = "main", "mm", "pwm_src";
+			status = "disabled";
+		};
+
+		spi1: spi1@11010000 {
+			compatible = "mediatek,mt8188-spi-ipm",
+				     "mediatek,spi-ipm";
+			reg = <0 0x11010000 0 0x1000>;
+			interrupts = <GIC_SPI 192 IRQ_TYPE_LEVEL_HIGH 0>;
+			clocks = <&topckgen CLK_TOP_UNIVPLL_D6_D2>,
+				 <&topckgen CLK_TOP_SPI>,
+				 <&infracfg_ao CLK_INFRA_AO_SPI1>;
+			clock-names = "parent-clk", "sel-clk", "spi-clk";
+			status = "disabled";
+		};
+
+		spi2: spi2@11012000 {
+			compatible = "mediatek,mt8188-spi-ipm",
+				     "mediatek,spi-ipm";
+			reg = <0 0x11012000 0 0x1000>;
+			interrupts = <GIC_SPI 193 IRQ_TYPE_LEVEL_HIGH 0>;
+			clocks = <&topckgen CLK_TOP_UNIVPLL_D6_D2>,
+				 <&topckgen CLK_TOP_SPI>,
+				 <&infracfg_ao CLK_INFRA_AO_SPI2>;
+			clock-names = "parent-clk", "sel-clk", "spi-clk";
+			status = "disabled";
+		};
+
+		spi3: spi3@11013000 {
+			compatible = "mediatek,mt8188-spi-ipm",
+				     "mediatek,spi-ipm";
+			reg = <0 0x11013000 0 0x1000>;
+			interrupts = <GIC_SPI 194 IRQ_TYPE_LEVEL_HIGH 0>;
+			clocks = <&topckgen CLK_TOP_UNIVPLL_D6_D2>,
+				 <&topckgen CLK_TOP_SPI>,
+				 <&infracfg_ao CLK_INFRA_AO_SPI3>;
+			clock-names = "parent-clk", "sel-clk", "spi-clk";
+			status = "disabled";
+		};
+
+		spi4: spi4@11018000 {
+			compatible = "mediatek,mt8188-spi-ipm",
+				     "mediatek,spi-ipm";
+			reg = <0 0x11018000 0 0x1000>;
+			interrupts = <GIC_SPI 195 IRQ_TYPE_LEVEL_HIGH 0>;
+			clocks = <&topckgen CLK_TOP_UNIVPLL_D6_D2>,
+				 <&topckgen CLK_TOP_SPI>,
+				 <&infracfg_ao CLK_INFRA_AO_SPI4>;
+			clock-names = "parent-clk", "sel-clk", "spi-clk";
+			status = "disabled";
+		};
+
+		spi5: spi5@11019000 {
+			compatible = "mediatek,mt8188-spi-ipm",
+				     "mediatek,spi-ipm";
+			reg = <0 0x11019000 0 0x1000>;
+			interrupts = <GIC_SPI 196 IRQ_TYPE_LEVEL_HIGH 0>;
+			clocks = <&topckgen CLK_TOP_UNIVPLL_D6_D2>,
+				 <&topckgen CLK_TOP_SPI>,
+				 <&infracfg_ao CLK_INFRA_AO_SPI5>;
+			clock-names = "parent-clk", "sel-clk", "spi-clk";
+			status = "disabled";
+		};
+
+		svs: svs@1100b000 {
+			compatible = "mediatek,mt8188-svs";
+			reg = <0 0x1100b000 0 0x1000>;
+			interrupts = <GIC_SPI 199 IRQ_TYPE_LEVEL_HIGH 0>;
+			clocks = <&infracfg_ao CLK_INFRA_AO_THERM>;
+			clock-names = "main";
+			nvmem-cells = <&svs_calibration>,
+				      <&lvts_efuse_data1>;
+			nvmem-cell-names = "svs-calibration-data",
+					   "t-calibration-data";
+			resets = <&infracfg_ao MT8188_INFRA_RST3_PTP_CTRL_RST>;
+			reset-names = "svs_rst";
+		};
+
+		xhci1: usb@11200000 {
+			compatible = "mediatek,mt8188-xhci",
+				     "mediatek,mtk-xhci";
+			reg = <0 0x11200000 0 0x1000>,
+			      <0 0x11203e00 0 0x0100>;
+			reg-names = "mac", "ippc";
+			interrupts = <GIC_SPI 129 IRQ_TYPE_LEVEL_HIGH 0>;
+			phys = <&u2port1 PHY_TYPE_USB2>,
+			       <&u3port1 PHY_TYPE_USB3>;
+			assigned-clocks = <&topckgen CLK_TOP_USB_TOP>,
+					  <&topckgen CLK_TOP_SSUSB_XHCI>;
+			assigned-clock-parents = <&topckgen CLK_TOP_UNIVPLL_D5_D4>,
+						 <&topckgen CLK_TOP_UNIVPLL_D5_D4>;
+			clocks = <&pericfg_ao CLK_PERI_AO_SSUSB_BUS>,
+				 <&topckgen CLK_TOP_SSUSB_TOP_REF>,
+				 <&pericfg_ao CLK_PERI_AO_SSUSB_XHCI>;
+			clock-names = "sys_ck", "ref_ck", "mcu_ck";
+			mediatek,syscon-wakeup = <&pericfg 0x468 2>;
+			wakeup-source;
+			status = "disabled";
+		};
+
+		mmc0: mmc@11230000 {
+			compatible = "mediatek,mt8188-mmc",
+				     "mediatek,mt8183-mmc";
+			reg = <0 0x11230000 0 0x10000>,
+			      <0 0x11f50000 0 0x1000>;
+			interrupts = <GIC_SPI 131 IRQ_TYPE_LEVEL_HIGH 0>;
+			clocks = <&topckgen CLK_TOP_MSDC50_0>,
+				 <&infracfg_ao CLK_INFRA_AO_MSDC0>,
+				 <&infracfg_ao CLK_INFRA_AO_MSDC0_SRC>,
+				 <&infracfg_ao CLK_INFRA_AO_RG_AES_MSDCFDE_CK_0P>;
+			clock-names = "source", "hclk", "source_cg", "crypto_clk";
+			status = "disabled";
+		};
+
+		mmc1: mmc@11240000 {
+			compatible = "mediatek,mt8188-mmc",
+				     "mediatek,mt8183-mmc";
+			reg = <0 0x11240000 0 0x1000>,
+			      <0 0x11eb0000 0 0x1000>;
+			interrupts = <GIC_SPI 135 IRQ_TYPE_LEVEL_HIGH 0>;
+			clocks = <&topckgen CLK_TOP_MSDC30_1>,
+				 <&infracfg_ao CLK_INFRA_AO_MSDC1>,
+				 <&infracfg_ao CLK_INFRA_AO_MSDC1_SRC>;
+			clock-names = "source", "hclk", "source_cg";
+			assigned-clocks = <&topckgen CLK_TOP_MSDC30_1>;
+			assigned-clock-parents = <&topckgen CLK_TOP_MSDCPLL_D2>;
+			status = "disabled";
+		};
+
+		lvtsmcu: thermal-sensor@11278000 {
+			compatible = "mediatek,mt8188-lvts-mcu";
+			#thermal-sensor-cells = <1>;
+			reg = <0 0x11278000 0 0x1000>;
+			interrupts = <GIC_SPI 202 IRQ_TYPE_LEVEL_HIGH 0>;
+			clocks = <&infracfg_ao CLK_INFRA_AO_THERM>;
+			resets = <&infracfg_ao MT8188_INFRA_RST1_THERMAL_MCU_RST>;
+			nvmem-cells = <&lvts_efuse_data1>;
+			nvmem-cell-names = "lvts_calib_data1";
+		};
+
+		i2c0: i2c@11280000 {
+			compatible = "mediatek,mt8188-i2c";
+			reg = <0 0x11280000 0 0x1000>,
+			      <0 0x10220080 0 0x80>;
+			interrupts = <GIC_SPI 151 IRQ_TYPE_LEVEL_HIGH 0>;
+			clock-div = <1>;
+			clocks = <&imp_iic_wrap_c CLK_IMP_IIC_WRAP_C_AP_CLOCK_I2C0>,
+				 <&infracfg_ao CLK_INFRA_AO_APDMA_BCLK>;
+			clock-names = "main", "dma";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			status = "disabled";
+		};
+
+		i2c2: i2c@11281000 {
+			compatible = "mediatek,mt8188-i2c";
+			reg = <0 0x11281000 0 0x1000>,
+			      <0 0x10220180 0 0x80>;
+			interrupts = <GIC_SPI 146 IRQ_TYPE_LEVEL_HIGH 0>;
+			clock-div = <1>;
+			clocks = <&imp_iic_wrap_c CLK_IMP_IIC_WRAP_C_AP_CLOCK_I2C2>,
+				 <&infracfg_ao CLK_INFRA_AO_APDMA_BCLK>;
+			clock-names = "main", "dma";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			status = "disabled";
+		};
+
+		i2c3: i2c@11282000 {
+			compatible = "mediatek,mt8188-i2c";
+			reg = <0 0x11282000 0 0x1000>,
+			      <0 0x10220280 0 0x80>;
+			interrupts = <GIC_SPI 147 IRQ_TYPE_LEVEL_HIGH 0>;
+			clock-div = <1>;
+			clocks = <&imp_iic_wrap_c CLK_IMP_IIC_WRAP_C_AP_CLOCK_I2C3>,
+				 <&infracfg_ao CLK_INFRA_AO_APDMA_BCLK>;
+			clock-names = "main", "dma";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			status = "disabled";
+		};
+
+		imp_iic_wrap_c: syscon@11283000 {
+			compatible = "mediatek,mt8188-imp-iic-wrap-c", "syscon";
+			reg = <0 0x11283000 0 0x1000>;
+			#clock-cells = <1>;
+		};
+
+		xhci2: usb@112a0000 {
+			compatible = "mediatek,mt8188-xhci",
+				     "mediatek,mtk-xhci";
+			reg = <0 0x112a0000 0 0x1000>,
+			      <0 0x112a3e00 0 0x0100>;
+			reg-names = "mac", "ippc";
+			interrupts = <GIC_SPI 536 IRQ_TYPE_LEVEL_HIGH 0>;
+			phys = <&u2port2 PHY_TYPE_USB2>;
+			assigned-clocks = <&topckgen CLK_TOP_SSUSB_XHCI_3P>,
+					  <&topckgen CLK_TOP_USB_TOP_3P>;
+			assigned-clock-parents = <&topckgen CLK_TOP_UNIVPLL_D5_D4>,
+						 <&topckgen CLK_TOP_UNIVPLL_D5_D4>;
+			clocks = <&pericfg_ao CLK_PERI_AO_SSUSB_3P_BUS>,
+				 <&topckgen CLK_TOP_SSUSB_TOP_P3_REF>,
+				 <&pericfg_ao CLK_PERI_AO_SSUSB_3P_XHCI>;
+			clock-names = "sys_ck", "ref_ck", "mcu_ck";
+			mediatek,syscon-wakeup = <&pericfg 0x470 2>;
+			wakeup-source;
+			status = "disabled";
+		};
+
+		xhci0: usb@112b0000 {
+			compatible = "mediatek,mt8188-xhci",
+				     "mediatek,mtk-xhci";
+			reg = <0 0x112b0000 0 0x1000>,
+			      <0 0x112b3e00 0 0x0100>;
+			reg-names = "mac", "ippc";
+			interrupts = <GIC_SPI 533 IRQ_TYPE_LEVEL_HIGH 0>;
+			phys = <&u2port0 PHY_TYPE_USB2>;
+			assigned-clocks = <&topckgen CLK_TOP_SSUSB_XHCI_2P>,
+					  <&topckgen CLK_TOP_USB_TOP_2P>;
+			assigned-clock-parents = <&topckgen CLK_TOP_UNIVPLL_D5_D4>,
+						 <&topckgen CLK_TOP_UNIVPLL_D5_D4>;
+			clocks = <&pericfg_ao CLK_PERI_AO_SSUSB_2P_BUS>,
+				 <&topckgen CLK_TOP_SSUSB_TOP_P2_REF>,
+				 <&pericfg_ao CLK_PERI_AO_SSUSB_2P_XHCI>;
+			clock-names = "sys_ck", "ref_ck", "mcu_ck";
+			mediatek,syscon-wakeup = <&pericfg 0x460 2>;
+			wakeup-source;
+			status = "disabled";
+		};
+
+		pcie: pcie@112f0000 {
+			device_type = "pci";
+			compatible = "mediatek,mt8188-pcie",
+				     "mediatek,mt8192-pcie";
+			reg = <0 0x112f0000 0 0x2000>;
+			reg-names = "pcie-mac";
+			linux,pci-domain = <0>;
+			#address-cells = <3>;
+			#size-cells = <2>;
+			interrupts = <GIC_SPI 791 IRQ_TYPE_LEVEL_HIGH 0>;
+			bus-range = <0x00 0xff>;
+			ranges = <0x82000000 0 0x20000000
+				  0x0 0x20000000 0 0x04000000>;
+			iommu-map = <0x0000 &infra_iommu IFR_IOMMU_PORT_PCIE_0
+				     0xFFFF>;
+			iommu-map-mask = <0x0>;
+			status = "disabled";
+			clocks = <&infracfg_ao CLK_INFRA_AO_PCIE_TL_26M>,
+				 <&infracfg_ao CLK_INFRA_AO_PCIE_TL_96M>,
+				 <&infracfg_ao CLK_INFRA_AO_PCIE_TL_32K>,
+				 <&infracfg_ao CLK_INFRA_AO_PCIE_PERI_26M>,
+				 <&pericfg_ao CLK_PERI_AO_PCIE_P0_FMEM>,
+				 <&infracfg_ao CLK_INFRA_AO_PCIE_PL_P_250M_P0>;
+			phys = <&pcieport PHY_TYPE_PCIE>;
+			phy-names = "pcie-phy";
+			power-domains = <&spm MT8188_POWER_DOMAIN_PEXTP_MAC_P0>;
+			#interrupt-cells = <1>;
+			interrupt-map-mask = <0 0 0 7>;
+			interrupt-map = <0 0 0 1 &pcie_intc 0>,
+					<0 0 0 2 &pcie_intc 1>,
+					<0 0 0 3 &pcie_intc 2>,
+					<0 0 0 4 &pcie_intc 3>;
+
+			pcie_intc: interrupt-controller {
+				interrupt-controller;
+				#address-cells = <0>;
+				#interrupt-cells = <1>;
+			};
+		};
+
+		nor_flash: spi@1132c000 {
+			compatible = "mediatek,mt8188-nor",
+				     "mediatek,mt8186-nor";
+			reg = <0 0x1132c000 0 0x1000>;
+			clocks = <&topckgen CLK_TOP_SPINOR>,
+				 <&pericfg_ao CLK_PERI_AO_FLASHIFLASHCK>,
+				 <&pericfg_ao CLK_PERI_AO_FLASHIF_BUS>;
+			clock-names = "spi", "sf", "axi";
+			assigned-clocks = <&topckgen CLK_TOP_SPINOR>;
+			interrupts = <GIC_SPI 825 IRQ_TYPE_LEVEL_HIGH 0>;
+			status = "disabled";
+		};
+
+		pciephy: t-phy@11c20700 {
+			compatible = "mediatek,generic-tphy-v2";
+			#address-cells = <1>;
+			#size-cells = <1>;
+			ranges = <0x0 0x0 0x11c20700 0x700>;
+			power-domains = <&spm MT8188_POWER_DOMAIN_PEXTP_PHY_TOP>;
+			status = "disabled";
+
+			pcieport: pcie-phy@0 {
+				reg = <0 0x700>;
+				clocks = <&topckgen CLK_TOP_CFGREG_F_PCIE_PHY_REF>;
+				clock-names = "ref";
+				#phy-cells = <1>;
+			};
+		};
+
+		mipi_tx_config0: mipi_dphy0@11c80000 {
+			compatible = "mediatek,mt8188-mipi-tx",
+				     "mediatek,mt8183-mipi-tx";
+			reg = <0 0x11c80000 0 0x1000>;
+			clocks = <&clk26m>;
+			clock-output-names = "mipi_tx0_pll";
+			status = "disabled";
+			#clock-cells = <0>;
+			#phy-cells = <0>;
+		};
+
+		i2c1: i2c@11e00000 {
+			compatible = "mediatek,mt8188-i2c";
+			reg = <0 0x11e00000 0 0x1000>,
+			      <0 0x10220100 0 0x80>;
+			interrupts = <GIC_SPI 152 IRQ_TYPE_LEVEL_HIGH 0>;
+			clock-div = <1>;
+			clocks = <&imp_iic_wrap_w CLK_IMP_IIC_WRAP_W_AP_CLOCK_I2C1>,
+				 <&infracfg_ao CLK_INFRA_AO_APDMA_BCLK>;
+			clock-names = "main", "dma";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			status = "disabled";
+		};
+
+		i2c4: i2c@11e01000 {
+			compatible = "mediatek,mt8188-i2c";
+			reg = <0 0x11e01000 0 0x1000>,
+			      <0 0x10220380 0 0x80>;
+			interrupts = <GIC_SPI 148 IRQ_TYPE_LEVEL_HIGH 0>;
+			clock-div = <1>;
+			clocks = <&imp_iic_wrap_w CLK_IMP_IIC_WRAP_W_AP_CLOCK_I2C4>,
+				 <&infracfg_ao CLK_INFRA_AO_APDMA_BCLK>;
+			clock-names = "main", "dma";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			status = "disabled";
+		};
+
+		imp_iic_wrap_w: syscon@11e02000 {
+			compatible = "mediatek,mt8188-imp-iic-wrap-w", "syscon";
+			reg = <0 0x11e02000 0 0x1000>;
+			#clock-cells = <1>;
+		};
+
+		u3phy0: usb-phy0@11e30000 {
+			compatible = "mediatek,mt8188-tphy",
+				     "mediatek,generic-tphy-v2";
+			#address-cells = <2>;
+			#size-cells = <2>;
+			ranges;
+			status = "disabled";
+
+			u2port0: usb2-phy0@11e30000 {
+				reg = <0 0x11e30000 0 0x700>;
+				clocks = <&topckgen CLK_TOP_SSUSB_PHY_P2_REF>,
+					 <&apmixedsys CLK_APMIXED_PLL_SSUSB26M_EN>;
+				clock-names = "ref", "da_ref";
+				#phy-cells = <1>;
+			};
+		};
+
+		u3phy1: usb-phy1@11e40000 {
+			compatible = "mediatek,mt8188-tphy",
+				     "mediatek,generic-tphy-v2";
+			#address-cells = <2>;
+			#size-cells = <2>;
+			ranges;
+			status = "disabled";
+
+			u2port1: usb2-phy1@11e40000 {
+				reg = <0 0x11e40000 0 0x700>;
+				clocks = <&topckgen CLK_TOP_SSUSB_PHY_REF>,
+					 <&apmixedsys CLK_APMIXED_PLL_SSUSB26M_EN>;
+				clock-names = "ref", "da_ref";
+				#phy-cells = <1>;
+			};
+
+			u3port1: usb3-phy1@11e40700 {
+				reg = <0 0x11e40700 0 0x700>;
+				clocks = <&apmixedsys CLK_APMIXED_PLL_SSUSB26M_EN>,
+					 <&clk26m>;
+				clock-names = "ref", "da_ref";
+				#phy-cells = <1>;
+				status = "disabled";
+			};
+		};
+
+		u3phy2: usb-phy2@11e80000 {
+			compatible = "mediatek,mt8188-tphy",
+				     "mediatek,generic-tphy-v2";
+			#address-cells = <2>;
+			#size-cells = <2>;
+			ranges;
+			status = "disabled";
+
+			u2port2: usb2-phy2@11e80000 {
+				reg = <0 0x11e80000 0 0x700>;
+				clocks = <&topckgen CLK_TOP_SSUSB_PHY_P3_REF>,
+					 <&apmixedsys CLK_APMIXED_PLL_SSUSB26M_EN>;
+				clock-names = "ref", "da_ref";
+				#phy-cells = <1>;
+			};
+		};
+
+		i2c5: i2c@11ec0000 {
+			compatible = "mediatek,mt8188-i2c";
+			reg = <0 0x11ec0000 0 0x1000>,
+			      <0 0x10220480 0 0x80>;
+			interrupts = <GIC_SPI 149 IRQ_TYPE_LEVEL_HIGH 0>;
+			clock-div = <1>;
+			clocks = <&imp_iic_wrap_en CLK_IMP_IIC_WRAP_EN_AP_CLOCK_I2C5>,
+				 <&infracfg_ao CLK_INFRA_AO_APDMA_BCLK>;
+			clock-names = "main", "dma";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			status = "disabled";
+		};
+
+		i2c6: i2c@11ec1000 {
+			compatible = "mediatek,mt8188-i2c";
+			reg = <0 0x11ec1000 0 0x1000>,
+			      <0 0x10220600 0 0x80>;
+			interrupts = <GIC_SPI 150 IRQ_TYPE_LEVEL_HIGH 0>;
+			clock-div = <1>;
+			clocks = <&imp_iic_wrap_en CLK_IMP_IIC_WRAP_EN_AP_CLOCK_I2C6>,
+				 <&infracfg_ao CLK_INFRA_AO_APDMA_BCLK>;
+			clock-names = "main", "dma";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			status = "disabled";
+		};
+
+		imp_iic_wrap_en: syscon@11ec2000 {
+			compatible = "mediatek,mt8188-imp-iic-wrap-en", "syscon";
+			reg = <0 0x11ec2000 0 0x1000>;
+			#clock-cells = <1>;
+		};
+
+		efuse: efuse@11f20000 {
+			compatible = "mediatek,mt8188-efuse",
+				     "mediatek,efuse";
+			reg = <0 0x11f20000 0 0x1000>;
+			#address-cells = <1>;
+			#size-cells = <1>;
+
+			dp_calibration: dp_data {
+				reg = <0x1a0 0x10>;
+			};
+
+			lvts_efuse_data1: lvts1-calib@1ac {
+				reg = <0x1ac 0x40>;
+			};
+
+			hdmirx_efuse: data2 {
+				reg = <0x50 0xc>;
+			};
+
+			hdmirx_rterm: data3 {
+				reg = <0x1ac 0x4>;
+			};
+
+			hdmitx_efuse: calib@184 {
+				reg = <0x184 0x4>;
+			};
+
+			csi_efuse0: csi_data0 {
+				reg = <0x18c 0x4>;
+			};
+
+			csi_efuse1: csi_data1 {
+				reg = <0x190 0x4>;
+			};
+
+			svs_calibration: calib@534 {
+				reg = <0x534 0x68>;
+			};
+
+			gpu_segment_table0: gpu_efuse0 {
+				reg = <0x40 0x4>;
+			};
+
+			gpu_segment_table1: gpu_efuse1 {
+				reg = <0x4c 0x4>;
+			};
+
+			gpu_segment_table2: gpu_efuse2 {
+				reg = <0x4c 0x4>;
+			};
+
+			gpu_volt_bin: volt-bin {
+				reg = <0x581 0x1>;
+				bits = <0 3>;
+			};
+
+			socinfo_data1: socinfo_data1 {
+				reg = <0x7a0 0x4>;
+			};
+
+			socinfo_data2: socinfo_data2 {
+				reg = <0x7e0 0x4>;
+			};
+		};
+
+		mtk_socinfo: mtk_socinfo {
+			compatible = "mediatek,mt8188-socinfo";
+			nvmem-cells = <&socinfo_data1 &socinfo_data2>;
+			nvmem-cell-names = "socinfo-data1", "socinfo-data2";
+		};
+
+		gpu: gpu@13000000 {
+			compatible = "mediatek,mt8188-mali", "arm,mali-valhall";
+			reg = <0 0x13000000 0 0x4000>;
+			interrupts = <GIC_SPI 383 IRQ_TYPE_LEVEL_HIGH 0>,
+				     <GIC_SPI 382 IRQ_TYPE_LEVEL_HIGH 0>,
+				     <GIC_SPI 381 IRQ_TYPE_LEVEL_HIGH 0>;
+			interrupt-names = "JOB", "MMU", "GPU";
+			clocks = <&topckgen CLK_TOP_MFG_CK_FAST_REF>,
+				 <&apmixedsys CLK_APMIXED_MFGPLL>,
+				 <&apmixedsys CLK_APMIXED_MFGPLL>,
+				 <&topckgen CLK_TOP_MFG_CORE_TMP>,
+				 <&mfgcfg CLK_MFGCFG_BG3D>;
+			clock-names = "clk_mux",
+				      "clk_pll_src",
+				      "clk_main_parent",
+				      "clk_sub_parent",
+				      "subsys_bg3d";
+			power-domains = <&spm MT8188_POWER_DOMAIN_MFG2>,
+					<&spm MT8188_POWER_DOMAIN_MFG3>,
+					<&spm MT8188_POWER_DOMAIN_MFG4>;
+			power-domain-names = "core0", "core1", "core2";
+			nvmem-cells = <&gpu_volt_bin>;
+			nvmem-cell-names = "volt-bin";
+			#cooling-cells = <2>;
+		};
+
+		mfgcfg: syscon@13fbf000 {
+			compatible = "mediatek,mt8188-mfgcfg", "syscon";
+			reg = <0 0x13fbf000 0 0x1000>;
+			#clock-cells = <1>;
+		};
+
+		vppsys0: syscon@14000000 {
+			compatible = "mediatek,mt8188-vppsys0", "syscon";
+			reg = <0 0x14000000 0 0x1000>;
+			#clock-cells = <1>;
+		};
+
+		vpp_smi_common: smi@14012000 {
+			compatible = "mediatek,mt8188-smi-common-vpp";
+			reg = <0 0x14012000 0 0x1000>;
+			clocks = <&vppsys0 CLK_VPP0_SMI_COMMON_LARB4>,
+				 <&vppsys0 CLK_VPP0_SMI_SUB_COMMON_REORDER>;
+			clock-names = "apb", "smi";
+			power-domains = <&spm MT8188_POWER_DOMAIN_VPPSYS0>;
+		};
+
+		larb4: larb@14013000 {
+			compatible = "mediatek,mt8188-smi-larb";
+			reg = <0 0x14013000 0 0x1000>;
+			mediatek,larb-id = <SMI_L4_ID>;
+			mediatek,smi = <&vpp_smi_common>;
+			clocks = <&vppsys0 CLK_VPP0_SMI_COMMON_LARB4>,
+				 <&vppsys0 CLK_VPP0_SMI_COMMON_LARB4>;
+			clock-names = "apb", "smi";
+			power-domains = <&spm MT8188_POWER_DOMAIN_VPPSYS0>;
+		};
+
+		vpp_iommu: iommu@14018000 {
+			compatible = "mediatek,mt8188-iommu-vpp";
+			reg = <0 0x14018000 0 0x5000>;
+			mediatek,larbs = <&larb1 &larb3 &larb4 &larb6 &larb7
+					  &larb11b &larb12 &larb14 &larb15
+					  &larb16a &larb17a &larb23 &larb27>;
+			interrupts = <GIC_SPI 594 IRQ_TYPE_LEVEL_HIGH 0>,
+				     <GIC_SPI 595 IRQ_TYPE_LEVEL_HIGH 0>,
+				     <GIC_SPI 596 IRQ_TYPE_LEVEL_HIGH 0>,
+				     <GIC_SPI 597 IRQ_TYPE_LEVEL_HIGH 0>,
+				     <GIC_SPI 598 IRQ_TYPE_LEVEL_HIGH 0>;
+			clocks = <&vppsys0 CLK_VPP0_SMI_IOMMU>;
+			clock-names = "bclk";
+			#iommu-cells = <1>;
+			power-domains = <&spm MT8188_POWER_DOMAIN_VPPSYS0>;
+		};
+
+		wpesys: syscon@14e00000 {
+			compatible = "mediatek,mt8188-wpesys", "syscon";
+			reg = <0 0x14e00000 0 0x1000>;
+			#clock-cells = <1>;
+		};
+
+		wpesys_vpp0: syscon@14e02000 {
+			compatible = "mediatek,mt8188-wpesys-vpp0", "syscon";
+			reg = <0 0x14e02000 0 0x1000>;
+			#clock-cells = <1>;
+		};
+
+		larb7: larb@14e04000 {
+			compatible = "mediatek,mt8188-smi-larb";
+			reg = <0 0x14e04000 0 0x1000>;
+			mediatek,larb-id = <SMI_L7_ID>;
+			mediatek,smi = <&vpp_smi_common>;
+			clocks = <&wpesys CLK_WPE_TOP_SMI_LARB7>,
+				 <&wpesys CLK_WPE_TOP_SMI_LARB7>;
+			clock-names = "apb", "smi";
+			power-domains = <&spm MT8188_POWER_DOMAIN_WPE>;
+		};
+
+		vppsys1: syscon@14f00000 {
+			compatible = "mediatek,mt8188-vppsys1", "syscon";
+			reg = <0 0x14f00000 0 0x1000>;
+			#clock-cells = <1>;
+		};
+
+		larb5: larb@14f02000 {
+			compatible = "mediatek,mt8188-smi-larb";
+			reg = <0 0x14f02000 0 0x1000>;
+			mediatek,larb-id = <SMI_L5_ID>;
+			mediatek,smi = <&vdo_smi_common>;
+			clocks = <&vppsys1 CLK_VPP1_GALS5>,
+				 <&vppsys1 CLK_VPP1_LARB5>;
+			clock-names = "apb", "smi";
+			power-domains = <&spm MT8188_POWER_DOMAIN_VPPSYS1>;
+		};
+
+		larb6: larb@14f03000 {
+			compatible = "mediatek,mt8188-smi-larb";
+			reg = <0 0x14f03000 0 0x1000>;
+			mediatek,larb-id = <SMI_L6_ID>;
+			mediatek,smi = <&vpp_smi_common>;
+			clocks = <&vppsys1 CLK_VPP1_GALS6>,
+				 <&vppsys1 CLK_VPP1_LARB6>;
+			clock-names = "apb", "smi";
+			power-domains = <&spm MT8188_POWER_DOMAIN_VPPSYS1>;
+		};
+
+		imgsys: syscon@15000000 {
+			compatible = "mediatek,mt8188-imgsys", "syscon";
+			reg = <0 0x15000000 0 0x1000>;
+			#clock-cells = <1>;
+		};
+
+		larb9: larb@15001000 {
+			compatible = "mediatek,mt8188-smi-larb";
+			reg = <0 0x15001000 0 0x1000>;
+			mediatek,larb-id = <SMI_L9_ID>;
+			mediatek,smi = <&vdo_smi_common>;
+			clocks = <&imgsys CLK_IMGSYS_MAIN_LARB9>,
+				 <&imgsys CLK_IMGSYS_MAIN_LARB9>;
+			clock-names = "apb", "smi";
+			power-domains = <&spm MT8188_POWER_DOMAIN_IMG_MAIN>;
+		};
+
+		smi_img0: syscon@15002000 {
+			compatible = "mediatek,mt8188-smi-img0", "syscon";
+			reg = <0 0x15002000 0 0x1000>;
+		};
+
+		smi_img1: syscon@15003000 {
+			compatible = "mediatek,mt8188-smi-img1", "syscon";
+			reg = <0 0x15003000 0 0x1000>;
+		};
+
+		imgsys1_dip_top: syscon@15110000 {
+			compatible = "mediatek,mt8188-imgsys1-dip-top", "syscon";
+			reg = <0 0x15110000 0 0x1000>;
+			#clock-cells = <1>;
+		};
+
+		larb10: larb@15120000 {
+			compatible = "mediatek,mt8188-smi-larb";
+			reg = <0 0x15120000 0 0x1000>;
+			mediatek,larb-id = <SMI_L10_ID>;
+			mediatek,smi = <&vdo_smi_common>;
+			clocks = <&imgsys CLK_IMGSYS_MAIN_DIP0>,
+				 <&imgsys1_dip_top CLK_IMGSYS1_DIP_TOP_LARB10>;
+			clock-names = "apb", "smi";
+			power-domains = <&spm MT8188_POWER_DOMAIN_DIP>;
+		};
+
+		imgsys1_dip_nr: syscon@15130000 {
+			compatible = "mediatek,mt8188-imgsys1-dip-nr", "syscon";
+			reg = <0 0x15130000 0 0x1000>;
+			#clock-cells = <1>;
+		};
+
+		larb15: larb@15140000 {
+			compatible = "mediatek,mt8188-smi-larb";
+			reg = <0 0x15140000 0 0x1000>;
+			mediatek,larb-id = <SMI_L15_ID>;
+			mediatek,smi = <&vpp_smi_common>;
+			clocks = <&imgsys1_dip_top CLK_IMGSYS1_DIP_TOP_LARB10>,
+				 <&imgsys1_dip_nr CLK_IMGSYS1_DIP_NR_LARB15>;
+			clock-names = "apb", "smi";
+			power-domains = <&spm MT8188_POWER_DOMAIN_DIP>;
+		};
+
+		imgsys_wpe1: syscon@15220000 {
+			compatible = "mediatek,mt8188-imgsys-wpe1", "syscon";
+			reg = <0 0x15220000 0 0x1000>;
+			#clock-cells = <1>;
+		};
+
+		larb11a: larb@15230000 {
+			compatible = "mediatek,mt8188-smi-larb";
+			reg = <0 0x15230000 0 0x1000>;
+			mediatek,larb-id = <SMI_L11A_ID>;
+			mediatek,smi = <&vdo_smi_common>;
+			clocks = <&imgsys CLK_IMGSYS_MAIN_WPE0>,
+				 <&imgsys_wpe1 CLK_IMGSYS_WPE1_LARB11>;
+			clock-names = "apb", "smi";
+			power-domains = <&spm MT8188_POWER_DOMAIN_DIP>;
+		};
+
+		vmm_proxy_label: vmm-proxy {
+			regulator-name = "dvfs-vmm";
+			regulator-min-microvolt = <550000>;
+			regulator-max-microvolt = <725000>;
+		};
+
+		opp_table_img: opp-table-img {
+			compatible = "operating-points-v2";
+			opp-0 {
+				opp-hz = /bits/ 64 <273000000>;
+				opp-microvolt = <550000>;
+			};
+			opp-1 {
+				opp-hz = /bits/ 64 <364000000>;
+				opp-microvolt = <600000>;
+			};
+			opp-2 {
+				opp-hz = /bits/ 64 <546000000>;
+				opp-microvolt = <650000>;
+			};
+			opp-3 {
+				opp-hz = /bits/ 64 <660000000>;
+				opp-microvolt = <725000>;
+			};
+		};
+
+		opp_table_ipe: opp-table-ipe {
+			compatible = "operating-points-v2";
+			opp-0 {
+				opp-hz = /bits/ 64 <273000000>;
+				opp-microvolt = <550000>;
+			};
+			opp-1 {
+				opp-hz = /bits/ 64 <364000000>;
+				opp-microvolt = <600000>;
+			};
+			opp-2 {
+				opp-hz = /bits/ 64 <458000000>;
+				opp-microvolt = <650000>;
+			};
+			opp-3 {
+				opp-hz = /bits/ 64 <546000000>;
+				opp-microvolt = <725000>;
+			};
+		};
+
+		hcp: hcp@0 {
+			compatible = "mediatek,hcp";
+			dma-ranges = <0x2 0x0 0x0 0x40000000 0x1 0x0>;
+			iommus = <&vpp_iommu M4U_PORT_L11B_WPE_RDMA_0>,
+				 <&vpp_iommu M4U_PORT_L11B_WPE_RDMA_1>,
+				 <&vpp_iommu M4U_PORT_L11B_WPE_RDMA_4P_0>,
+				 <&vpp_iommu M4U_PORT_L11B_WPE_RDMA_4P_1>,
+				 <&vpp_iommu M4U_PORT_L11B_WPE_CQ0>,
+				 <&vpp_iommu M4U_PORT_L11B_WPE_CQ1>,
+				 <&vpp_iommu M4U_PORT_L11B_PIMGI_P1>,
+				 <&vpp_iommu M4U_PORT_L11B_PIMGBI_P1>,
+				 <&vpp_iommu M4U_PORT_L11B_PIMGCI_P1>,
+				 <&vpp_iommu M4U_PORT_L11B_IMGI_T1_C>,
+				 <&vpp_iommu M4U_PORT_L11B_IMGBI_T1_C>,
+				 <&vpp_iommu M4U_PORT_L11B_IMGCI_T1_C>,
+				 <&vpp_iommu M4U_PORT_L11B_SMTI_T1_C>,
+				 <&vpp_iommu M4U_PORT_L11B_SMTI_T4_C>,
+				 <&vpp_iommu M4U_PORT_L11B_SMTI_T6_C>,
+				 <&vpp_iommu M4U_PORT_L11B_YUVO_T1_C>,
+				 <&vpp_iommu M4U_PORT_L11B_YUVBO_T1_C>,
+				 <&vpp_iommu M4U_PORT_L11B_YUVCO_T1_C>,
+				 <&vpp_iommu M4U_PORT_L11B_WPE_WDMA_0>,
+				 <&vpp_iommu M4U_PORT_L11B_WPE_WDMA_4P_0>,
+				 <&vpp_iommu M4U_PORT_L11B_WROT_P1>,
+				 <&vpp_iommu M4U_PORT_L11B_TCCSO_P1>,
+				 <&vpp_iommu M4U_PORT_L11B_TCCSI_P1>,
+				 <&vpp_iommu M4U_PORT_L11B_TIMGO_T1_C>,
+				 <&vpp_iommu M4U_PORT_L11B_YUVO_T2_C>,
+				 <&vpp_iommu M4U_PORT_L11B_YUVO_T5_C>,
+				 <&vpp_iommu M4U_PORT_L11B_SMTO_T1_C>,
+				 <&vpp_iommu M4U_PORT_L11B_SMTO_T4_C>,
+				 <&vpp_iommu M4U_PORT_L11B_SMTO_T6_C>,
+				 <&vpp_iommu M4U_PORT_L11B_DBGO_T1_C>;
+		};
+
+		hcp_l15 {
+			compatible = "mediatek,imgsys-larb";
+			dma-ranges = <0x2 0x0 0x0 0x40000000 0x1 0x0>;
+			iommus = <&vpp_iommu M4U_PORT_L15_VIPI_D1>,
+				 <&vpp_iommu M4U_PORT_L15_VIPBI_D1>,
+				 <&vpp_iommu M4U_PORT_L15_SMTI_D6>,
+				 <&vpp_iommu M4U_PORT_L15_TNCSTI_D1>,
+				 <&vpp_iommu M4U_PORT_L15_TNCSTI_D4>,
+				 <&vpp_iommu M4U_PORT_L15_SMTI_D4>,
+				 <&vpp_iommu M4U_PORT_L15_IMG3O_D1>,
+				 <&vpp_iommu M4U_PORT_L15_IMG3BO_D1>,
+				 <&vpp_iommu M4U_PORT_L15_IMG3CO_D1>,
+				 <&vpp_iommu M4U_PORT_L15_IMG2O_D1>,
+				 <&vpp_iommu M4U_PORT_L15_SMTI_D9>,
+				 <&vpp_iommu M4U_PORT_L15_SMTO_D4>,
+				 <&vpp_iommu M4U_PORT_L15_FEO_D1>,
+				 <&vpp_iommu M4U_PORT_L15_TNCSO_D1>,
+				 <&vpp_iommu M4U_PORT_L15_TNCSTO_D1>,
+				 <&vpp_iommu M4U_PORT_L15_SMTO_D6>,
+				 <&vpp_iommu M4U_PORT_L15_SMTO_D9>,
+				 <&vpp_iommu M4U_PORT_L15_TNCO_D1>,
+				 <&vpp_iommu M4U_PORT_L15_TNCO_D1_N>;
+		};
+
+		imgsys_fw: imgsys_fw@15000000 {
+			compatible = "mediatek,imgsys";
+			dma-ranges = <0x2 0x0 0x0 0x40000000 0x1 0x0>;
+			reg = <0 0x15000000 0 0x4000>,	/* 0 IMGSYS_TOP */
+			      <0 0x15020000 0 0x10000>,	/* 1 IMGSYS_TRAW */
+			      <0 0x15040000 0 0x10000>,	/* 2 IMGSYS_LTRAW */
+			      <0 0x15640000 0 0x10000>,	/* 3 IMGSYS_XTRAW */
+			      <0 0x15100000 0 0x10000>,	/* 4 IMGSYS_DIP */
+			      <0 0x15150000 0 0x10000>,	/* 4 IMGSYS_DIP_NR */
+			      <0 0x15210000 0 0x10000>,	/* 5 IMGSYS_PQDIP_A */
+			      <0 0x15510000 0 0x10000>,	/* 6 IMGSYS_PQDIP_B */
+			      <0 0x15200000 0 0x10000>,	/* 7 IMGSYS_WPE_EIS */
+			      <0 0x15500000 0 0x10000>,	/* 8 IMGSYS_WPE_TNR */
+			      <0 0x15600000 0 0x10000>,	/* 9 IMGSYS_WPE_LITE */
+			      <0 0x15220000 0 0x00100>,	/* 10 IMGSYS_WPE1_DIP1 */
+			      <0 0x15320000 0 0x10000>,	/* 11 IMGSYS_ME */
+			      <0 0x00000000 0 0x01000>,	/* 12 IMGSYS_ADL_A */
+			      <0 0x00000000 0 0x01000>,	/* 13 IMGSYS_ADL_B */
+			      <0 0x15520000 0 0x00100>,	/* 14 IMGSYS_WPE2_DIP1 */
+			      <0 0x15620000 0 0x00100>,	/* 15 IMGSYS_WPE3_DIP1 */
+			      <0 0x15110000 0 0x00100>,	/* 16 IMGSYS_DIP_TOP */
+			      <0 0x15130000 0 0x00100>;	/* 17 IMGSYS_DIP_TOP_NR */
+			mediatek,hcp = <&hcp>;
+			mediatek,larbs = <&larb9>,
+					 <&larb10>,
+					 <&larb11a>,
+					 <&larb11b>,
+					 <&larb11c>,
+					 <&larb15>;
+			iommus = <&vdo_iommu M4U_PORT_L9_IMGI_T1_A>,
+				 <&vdo_iommu M4U_PORT_L9_UFDI_T1_A>,
+				 <&vdo_iommu M4U_PORT_L9_IMGBI_T1_A>,
+				 <&vdo_iommu M4U_PORT_L9_IMGCI_T1_A>,
+				 <&vdo_iommu M4U_PORT_L9_SMTI_T1_A>,
+				 <&vdo_iommu M4U_PORT_L9_SMTI_T4_A>,
+				 <&vdo_iommu M4U_PORT_L9_TNCSTI_T1_A>,
+				 <&vdo_iommu M4U_PORT_L9_TNCSTI_T4_A>,
+				 <&vdo_iommu M4U_PORT_L9_YUVO_T1_A>,
+				 <&vdo_iommu M4U_PORT_L9_YUVBO_T1_A>,
+				 <&vdo_iommu M4U_PORT_L9_YUVCO_T1_A>,
+				 <&vdo_iommu M4U_PORT_L9_TIMGO_T1_A>,
+				 <&vdo_iommu M4U_PORT_L9_YUVO_T2_A>,
+				 <&vdo_iommu M4U_PORT_L9_YUVO_T5_A>,
+				 <&vdo_iommu M4U_PORT_L9_IMGI_T1_B>,
+				 <&vdo_iommu M4U_PORT_L9_IMGBI_T1_B>,
+				 <&vdo_iommu M4U_PORT_L9_IMGCI_T1_B>,
+				 <&vdo_iommu M4U_PORT_L9_SMTI_T4_B>,
+				 <&vdo_iommu M4U_PORT_L9_TNCSO_T1_A>,
+				 <&vdo_iommu M4U_PORT_L9_SMTO_T1_A>,
+				 <&vdo_iommu M4U_PORT_L9_SMTO_T4_A>,
+				 <&vdo_iommu M4U_PORT_L9_TNCSTO_T1_A>,
+				 <&vdo_iommu M4U_PORT_L9_YUVO_T2_B>,
+				 <&vdo_iommu M4U_PORT_L9_YUVO_T5_B>,
+				 <&vdo_iommu M4U_PORT_L9_SMTO_T4_B>;
+			mboxes = <&gce1 13 CMDQ_THR_PRIO_2>,
+				 <&gce1 14 CMDQ_THR_PRIO_2>,
+				 <&gce1 19 CMDQ_THR_PRIO_2>,
+				 <&gce1 20 CMDQ_THR_PRIO_2>,
+				 <&gce1 21 CMDQ_THR_PRIO_2>,
+				 <&gce1 24 CMDQ_THR_PRIO_2>,
+				 <&gce1 25 CMDQ_THR_PRIO_2>,
+				 <&gce1 26 CMDQ_THR_PRIO_1>,
+				 <&gce1 27 CMDQ_THR_PRIO_1>,
+				 <&gce1 28 CMDQ_THR_PRIO_1>;
+			traw_cq_thread0_frame_done =
+				/bits/ 16 <CMDQ_EVENT_IMG_TRAW0_CQ_THR_DONE_0>;
+			traw_cq_thread1_frame_done =
+				/bits/ 16 <CMDQ_EVENT_IMG_TRAW0_CQ_THR_DONE_1>;
+			traw_cq_thread2_frame_done =
+				/bits/ 16 <CMDQ_EVENT_IMG_TRAW0_CQ_THR_DONE_2>;
+			traw_cq_thread3_frame_done =
+				/bits/ 16 <CMDQ_EVENT_IMG_TRAW0_CQ_THR_DONE_3>;
+			traw_cq_thread4_frame_done =
+				/bits/ 16 <CMDQ_EVENT_IMG_TRAW0_CQ_THR_DONE_4>;
+			traw_cq_thread5_frame_done =
+				/bits/ 16 <CMDQ_EVENT_IMG_TRAW0_CQ_THR_DONE_5>;
+			traw_cq_thread6_frame_done =
+				/bits/ 16 <CMDQ_EVENT_IMG_TRAW0_CQ_THR_DONE_6>;
+			traw_cq_thread7_frame_done =
+				/bits/ 16 <CMDQ_EVENT_IMG_TRAW0_CQ_THR_DONE_7>;
+			traw_cq_thread8_frame_done =
+				/bits/ 16 <CMDQ_EVENT_IMG_TRAW0_CQ_THR_DONE_8>;
+			traw_cq_thread9_frame_done =
+				/bits/ 16 <CMDQ_EVENT_IMG_TRAW0_CQ_THR_DONE_9>;
+			ltraw_cq_thread0_frame_done =
+				/bits/ 16 <CMDQ_EVENT_IMG_TRAW1_CQ_THR_DONE_0>;
+			ltraw_cq_thread1_frame_done =
+				/bits/ 16 <CMDQ_EVENT_IMG_TRAW1_CQ_THR_DONE_1>;
+			ltraw_cq_thread2_frame_done =
+				/bits/ 16 <CMDQ_EVENT_IMG_TRAW1_CQ_THR_DONE_2>;
+			ltraw_cq_thread3_frame_done =
+				/bits/ 16 <CMDQ_EVENT_IMG_TRAW1_CQ_THR_DONE_3>;
+			ltraw_cq_thread4_frame_done =
+				/bits/ 16 <CMDQ_EVENT_IMG_TRAW1_CQ_THR_DONE_4>;
+			ltraw_cq_thread5_frame_done =
+				/bits/ 16 <CMDQ_EVENT_IMG_TRAW1_CQ_THR_DONE_5>;
+			ltraw_cq_thread6_frame_done =
+				/bits/ 16 <CMDQ_EVENT_IMG_TRAW1_CQ_THR_DONE_6>;
+			ltraw_cq_thread7_frame_done =
+				/bits/ 16 <CMDQ_EVENT_IMG_TRAW1_CQ_THR_DONE_7>;
+			ltraw_cq_thread8_frame_done =
+				/bits/ 16 <CMDQ_EVENT_IMG_TRAW1_CQ_THR_DONE_8>;
+			ltraw_cq_thread9_frame_done =
+				/bits/ 16 <CMDQ_EVENT_IMG_TRAW1_CQ_THR_DONE_9>;
+			xtraw_cq_thread0_frame_done =
+				/bits/ 16 <CMDQ_EVENT_IMG_XTRAW_CQ_THR_DONE_0>;
+			xtraw_cq_thread1_frame_done =
+				/bits/ 16 <CMDQ_EVENT_IMG_XTRAW_CQ_THR_DONE_1>;
+			xtraw_cq_thread2_frame_done =
+				/bits/ 16 <CMDQ_EVENT_IMG_XTRAW_CQ_THR_DONE_2>;
+			xtraw_cq_thread3_frame_done =
+				/bits/ 16 <CMDQ_EVENT_IMG_XTRAW_CQ_THR_DONE_3>;
+			xtraw_cq_thread4_frame_done =
+				/bits/ 16 <CMDQ_EVENT_IMG_XTRAW_CQ_THR_DONE_4>;
+			xtraw_cq_thread5_frame_done =
+				/bits/ 16 <CMDQ_EVENT_IMG_XTRAW_CQ_THR_DONE_5>;
+			xtraw_cq_thread6_frame_done =
+				/bits/ 16 <CMDQ_EVENT_IMG_XTRAW_CQ_THR_DONE_6>;
+			xtraw_cq_thread7_frame_done =
+				/bits/ 16 <CMDQ_EVENT_IMG_XTRAW_CQ_THR_DONE_7>;
+			xtraw_cq_thread8_frame_done =
+				/bits/ 16 <CMDQ_EVENT_IMG_XTRAW_CQ_THR_DONE_8>;
+			xtraw_cq_thread9_frame_done =
+				/bits/ 16 <CMDQ_EVENT_IMG_XTRAW_CQ_THR_DONE_9>;
+			dip_cq_thread0_frame_done =
+				/bits/ 16 <CMDQ_EVENT_IMG_DIP_CQ_THR_DONE_0>;
+			dip_cq_thread1_frame_done =
+				/bits/ 16 <CMDQ_EVENT_IMG_DIP_CQ_THR_DONE_1>;
+			dip_cq_thread2_frame_done =
+				/bits/ 16 <CMDQ_EVENT_IMG_DIP_CQ_THR_DONE_2>;
+			dip_cq_thread3_frame_done =
+				/bits/ 16 <CMDQ_EVENT_IMG_DIP_CQ_THR_DONE_3>;
+			dip_cq_thread4_frame_done =
+				/bits/ 16 <CMDQ_EVENT_IMG_DIP_CQ_THR_DONE_4>;
+			dip_cq_thread5_frame_done =
+				/bits/ 16 <CMDQ_EVENT_IMG_DIP_CQ_THR_DONE_5>;
+			dip_cq_thread6_frame_done =
+				/bits/ 16 <CMDQ_EVENT_IMG_DIP_CQ_THR_DONE_6>;
+			dip_cq_thread7_frame_done =
+				/bits/ 16 <CMDQ_EVENT_IMG_DIP_CQ_THR_DONE_7>;
+			dip_cq_thread8_frame_done =
+				/bits/ 16 <CMDQ_EVENT_IMG_DIP_CQ_THR_DONE_8>;
+			dip_cq_thread9_frame_done =
+				/bits/ 16 <CMDQ_EVENT_IMG_DIP_CQ_THR_DONE_9>;
+			pqa_cq_thread0_frame_done =
+				/bits/ 16 <CMDQ_EVENT_IMG_PQDIP_A_CQ_THR_DONE_0>;
+			pqa_cq_thread1_frame_done =
+				/bits/ 16 <CMDQ_EVENT_IMG_PQDIP_A_CQ_THR_DONE_1>;
+			pqa_cq_thread2_frame_done =
+				/bits/ 16 <CMDQ_EVENT_IMG_PQDIP_A_CQ_THR_DONE_2>;
+			pqa_cq_thread3_frame_done =
+				/bits/ 16 <CMDQ_EVENT_IMG_PQDIP_A_CQ_THR_DONE_3>;
+			pqa_cq_thread4_frame_done =
+				/bits/ 16 <CMDQ_EVENT_IMG_PQDIP_A_CQ_THR_DONE_4>;
+			pqa_cq_thread5_frame_done =
+				/bits/ 16 <CMDQ_EVENT_IMG_PQDIP_A_CQ_THR_DONE_5>;
+			pqa_cq_thread6_frame_done =
+				/bits/ 16 <CMDQ_EVENT_IMG_PQDIP_A_CQ_THR_DONE_6>;
+			pqa_cq_thread7_frame_done =
+				/bits/ 16 <CMDQ_EVENT_IMG_PQDIP_A_CQ_THR_DONE_7>;
+			pqa_cq_thread8_frame_done =
+				/bits/ 16 <CMDQ_EVENT_IMG_PQDIP_A_CQ_THR_DONE_8>;
+			pqa_cq_thread9_frame_done =
+				/bits/ 16 <CMDQ_EVENT_IMG_PQDIP_A_CQ_THR_DONE_9>;
+			pqb_cq_thread0_frame_done =
+				/bits/ 16 <CMDQ_EVENT_IMG_PQDIP_B_CQ_THR_DONE_0>;
+			pqb_cq_thread1_frame_done =
+				/bits/ 16 <CMDQ_EVENT_IMG_PQDIP_B_CQ_THR_DONE_1>;
+			pqb_cq_thread2_frame_done =
+				/bits/ 16 <CMDQ_EVENT_IMG_PQDIP_B_CQ_THR_DONE_2>;
+			pqb_cq_thread3_frame_done =
+				/bits/ 16 <CMDQ_EVENT_IMG_PQDIP_B_CQ_THR_DONE_3>;
+			pqb_cq_thread4_frame_done =
+				/bits/ 16 <CMDQ_EVENT_IMG_PQDIP_B_CQ_THR_DONE_4>;
+			pqb_cq_thread5_frame_done =
+				/bits/ 16 <CMDQ_EVENT_IMG_PQDIP_B_CQ_THR_DONE_5>;
+			pqb_cq_thread6_frame_done =
+				/bits/ 16 <CMDQ_EVENT_IMG_PQDIP_B_CQ_THR_DONE_6>;
+			pqb_cq_thread7_frame_done =
+				/bits/ 16 <CMDQ_EVENT_IMG_PQDIP_B_CQ_THR_DONE_7>;
+			pqb_cq_thread8_frame_done =
+				/bits/ 16 <CMDQ_EVENT_IMG_PQDIP_B_CQ_THR_DONE_8>;
+			pqb_cq_thread9_frame_done =
+				/bits/ 16 <CMDQ_EVENT_IMG_PQDIP_B_CQ_THR_DONE_9>;
+			wpe_eis_cq_thread0_frame_done =
+				/bits/ 16 <CMDQ_EVENT_IMG_WPE_EIS_CQ_THR_DONE_0>;
+			wpe_eis_cq_thread1_frame_done =
+				/bits/ 16 <CMDQ_EVENT_IMG_WPE_EIS_CQ_THR_DONE_1>;
+			wpe_eis_cq_thread2_frame_done =
+				/bits/ 16 <CMDQ_EVENT_IMG_WPE_EIS_CQ_THR_DONE_2>;
+			wpe_eis_cq_thread3_frame_done =
+				/bits/ 16 <CMDQ_EVENT_IMG_WPE_EIS_CQ_THR_DONE_3>;
+			wpe_eis_cq_thread4_frame_done =
+				/bits/ 16 <CMDQ_EVENT_IMG_WPE_EIS_CQ_THR_DONE_4>;
+			wpe_eis_cq_thread5_frame_done =
+				/bits/ 16 <CMDQ_EVENT_IMG_WPE_EIS_CQ_THR_DONE_5>;
+			wpe_eis_cq_thread6_frame_done =
+				/bits/ 16 <CMDQ_EVENT_IMG_WPE_EIS_CQ_THR_DONE_6>;
+			wpe_eis_cq_thread7_frame_done =
+				/bits/ 16 <CMDQ_EVENT_IMG_WPE_EIS_CQ_THR_DONE_7>;
+			wpe_eis_cq_thread8_frame_done =
+				/bits/ 16 <CMDQ_EVENT_IMG_WPE_EIS_CQ_THR_DONE_8>;
+			wpe_eis_cq_thread9_frame_done =
+				/bits/ 16 <CMDQ_EVENT_IMG_WPE_EIS_CQ_THR_DONE_9>;
+			wpe_tnr_cq_thread0_frame_done =
+				/bits/ 16 <CMDQ_EVENT_IMG_WPE_TNR_CQ_THR_DONE_0>;
+			wpe_tnr_cq_thread1_frame_done =
+				/bits/ 16 <CMDQ_EVENT_IMG_WPE_TNR_CQ_THR_DONE_1>;
+			wpe_tnr_cq_thread2_frame_done =
+				/bits/ 16 <CMDQ_EVENT_IMG_WPE_TNR_CQ_THR_DONE_2>;
+			wpe_tnr_cq_thread3_frame_done =
+				/bits/ 16 <CMDQ_EVENT_IMG_WPE_TNR_CQ_THR_DONE_3>;
+			wpe_tnr_cq_thread4_frame_done =
+				/bits/ 16 <CMDQ_EVENT_IMG_WPE_TNR_CQ_THR_DONE_4>;
+			wpe_tnr_cq_thread5_frame_done =
+				/bits/ 16 <CMDQ_EVENT_IMG_WPE_TNR_CQ_THR_DONE_5>;
+			wpe_tnr_cq_thread6_frame_done =
+				/bits/ 16 <CMDQ_EVENT_IMG_WPE_TNR_CQ_THR_DONE_6>;
+			wpe_tnr_cq_thread7_frame_done =
+				/bits/ 16 <CMDQ_EVENT_IMG_WPE_TNR_CQ_THR_DONE_7>;
+			wpe_tnr_cq_thread8_frame_done =
+				/bits/ 16 <CMDQ_EVENT_IMG_WPE_TNR_CQ_THR_DONE_8>;
+			wpe_tnr_cq_thread9_frame_done =
+				/bits/ 16 <CMDQ_EVENT_IMG_WPE_TNR_CQ_THR_DONE_9>;
+			wpe_lite_cq_thread0_frame_done =
+				/bits/ 16 <CMDQ_EVENT_IMG_WPE_LITE_CQ_THR_DONE_0>;
+			wpe_lite_cq_thread1_frame_done =
+				/bits/ 16 <CMDQ_EVENT_IMG_WPE_LITE_CQ_THR_DONE_1>;
+			wpe_lite_cq_thread2_frame_done =
+				/bits/ 16 <CMDQ_EVENT_IMG_WPE_LITE_CQ_THR_DONE_2>;
+			wpe_lite_cq_thread3_frame_done =
+				/bits/ 16 <CMDQ_EVENT_IMG_WPE_LITE_CQ_THR_DONE_3>;
+			wpe_lite_cq_thread4_frame_done =
+				/bits/ 16 <CMDQ_EVENT_IMG_WPE_LITE_CQ_THR_DONE_4>;
+			wpe_lite_cq_thread5_frame_done =
+				/bits/ 16 <CMDQ_EVENT_IMG_WPE_LITE_CQ_THR_DONE_5>;
+			wpe_lite_cq_thread6_frame_done =
+				/bits/ 16 <CMDQ_EVENT_IMG_WPE_LITE_CQ_THR_DONE_6>;
+			wpe_lite_cq_thread7_frame_done =
+				/bits/ 16 <CMDQ_EVENT_IMG_WPE_LITE_CQ_THR_DONE_7>;
+			wpe_lite_cq_thread8_frame_done =
+				/bits/ 16 <CMDQ_EVENT_IMG_WPE_LITE_CQ_THR_DONE_8>;
+			wpe_lite_cq_thread9_frame_done =
+				/bits/ 16 <CMDQ_EVENT_IMG_WPE_LITE_CQ_THR_DONE_9>;
+			me_done =
+				/bits/ 16 <CMDQ_EVENT_IMG_IMGSYS_IPE_ME_DONE>;
+			adl_tile_done =
+				/bits/ 16 <CMDQ_EVENT_IMG_ADL_RESERVED>;
+			wpe_eis_sync_token =
+				/bits/ 16 <CMDQ_SYNC_TOKEN_IMGSYS_WPE_EIS>;
+			wpe_tnr_sync_token =
+				/bits/ 16 <CMDQ_SYNC_TOKEN_IMGSYS_WPE_TNR>;
+			wpe_lite_sync_token =
+				/bits/ 16 <CMDQ_SYNC_TOKEN_IMGSYS_WPE_LITE>;
+			traw_sync_token =
+				/bits/ 16 <CMDQ_SYNC_TOKEN_IMGSYS_TRAW>;
+			ltraw_sync_token =
+				/bits/ 16 <CMDQ_SYNC_TOKEN_IMGSYS_LTRAW>;
+			xtraw_sync_token =
+				/bits/ 16 <CMDQ_SYNC_TOKEN_IMGSYS_XTRAW>;
+			dip_sync_token =
+				/bits/ 16 <CMDQ_SYNC_TOKEN_IMGSYS_DIP>;
+			pqdip_a_sync_token =
+				/bits/ 16 <CMDQ_SYNC_TOKEN_IMGSYS_PQDIP_A>;
+			pqdip_b_sync_token =
+				/bits/ 16 <CMDQ_SYNC_TOKEN_IMGSYS_PQDIP_B>;
+			me_sync_token =
+				/bits/ 16 <CMDQ_SYNC_TOKEN_IPESYS_ME>;
+			vss_traw_sync_token =
+				/bits/ 16 <CMDQ_SYNC_TOKEN_IMGSYS_VSS_TRAW>;
+			vss_ltraw_sync_token =
+				/bits/ 16 <CMDQ_SYNC_TOKEN_IMGSYS_VSS_LTRAW>;
+			vss_xtraw_sync_token =
+				/bits/ 16 <CMDQ_SYNC_TOKEN_IMGSYS_VSS_XTRAW>;
+			vss_dip_sync_token =
+				/bits/ 16 <CMDQ_SYNC_TOKEN_IMGSYS_VSS_DIP>;
+			sw_sync_token_pool_1 =
+				/bits/ 16 <CMDQ_SYNC_TOKEN_IMGSYS_POOL_1>;
+			sw_sync_token_pool_2 =
+				/bits/ 16 <CMDQ_SYNC_TOKEN_IMGSYS_POOL_2>;
+			sw_sync_token_pool_3 =
+				/bits/ 16 <CMDQ_SYNC_TOKEN_IMGSYS_POOL_3>;
+			sw_sync_token_pool_4 =
+				/bits/ 16 <CMDQ_SYNC_TOKEN_IMGSYS_POOL_4>;
+			sw_sync_token_pool_5 =
+				/bits/ 16 <CMDQ_SYNC_TOKEN_IMGSYS_POOL_5>;
+			sw_sync_token_pool_6 =
+				/bits/ 16 <CMDQ_SYNC_TOKEN_IMGSYS_POOL_6>;
+			sw_sync_token_pool_7 =
+				/bits/ 16 <CMDQ_SYNC_TOKEN_IMGSYS_POOL_7>;
+			sw_sync_token_pool_8 =
+				/bits/ 16 <CMDQ_SYNC_TOKEN_IMGSYS_POOL_8>;
+			sw_sync_token_pool_9 =
+				/bits/ 16 <CMDQ_SYNC_TOKEN_IMGSYS_POOL_9>;
+			sw_sync_token_pool_10 =
+				/bits/ 16 <CMDQ_SYNC_TOKEN_IMGSYS_POOL_10>;
+			sw_sync_token_pool_11 =
+				/bits/ 16 <CMDQ_SYNC_TOKEN_IMGSYS_POOL_11>;
+			sw_sync_token_pool_12 =
+				/bits/ 16 <CMDQ_SYNC_TOKEN_IMGSYS_POOL_12>;
+			sw_sync_token_pool_13 =
+				/bits/ 16 <CMDQ_SYNC_TOKEN_IMGSYS_POOL_13>;
+			sw_sync_token_pool_14 =
+				/bits/ 16 <CMDQ_SYNC_TOKEN_IMGSYS_POOL_14>;
+			sw_sync_token_pool_15 =
+				/bits/ 16 <CMDQ_SYNC_TOKEN_IMGSYS_POOL_15>;
+			sw_sync_token_pool_16 =
+				/bits/ 16 <CMDQ_SYNC_TOKEN_IMGSYS_POOL_16>;
+			sw_sync_token_pool_17 =
+				/bits/ 16 <CMDQ_SYNC_TOKEN_IMGSYS_POOL_17>;
+			sw_sync_token_pool_18 =
+				/bits/ 16 <CMDQ_SYNC_TOKEN_IMGSYS_POOL_18>;
+			sw_sync_token_pool_19 =
+				/bits/ 16 <CMDQ_SYNC_TOKEN_IMGSYS_POOL_19>;
+			sw_sync_token_pool_20 =
+				/bits/ 16 <CMDQ_SYNC_TOKEN_IMGSYS_POOL_20>;
+			sw_sync_token_pool_21 =
+				/bits/ 16 <CMDQ_SYNC_TOKEN_IMGSYS_POOL_21>;
+			sw_sync_token_pool_22 =
+				/bits/ 16 <CMDQ_SYNC_TOKEN_IMGSYS_POOL_22>;
+			sw_sync_token_pool_23 =
+				/bits/ 16 <CMDQ_SYNC_TOKEN_IMGSYS_POOL_23>;
+			sw_sync_token_pool_24 =
+				/bits/ 16 <CMDQ_SYNC_TOKEN_IMGSYS_POOL_24>;
+			sw_sync_token_pool_25 =
+				/bits/ 16 <CMDQ_SYNC_TOKEN_IMGSYS_POOL_25>;
+			sw_sync_token_pool_26 =
+				/bits/ 16 <CMDQ_SYNC_TOKEN_IMGSYS_POOL_26>;
+			sw_sync_token_pool_27 =
+				/bits/ 16 <CMDQ_SYNC_TOKEN_IMGSYS_POOL_27>;
+			sw_sync_token_pool_28 =
+				/bits/ 16 <CMDQ_SYNC_TOKEN_IMGSYS_POOL_28>;
+			sw_sync_token_pool_29 =
+				/bits/ 16 <CMDQ_SYNC_TOKEN_IMGSYS_POOL_29>;
+			sw_sync_token_pool_30 =
+				/bits/ 16 <CMDQ_SYNC_TOKEN_IMGSYS_POOL_30>;
+			sw_sync_token_pool_31 =
+				/bits/ 16 <CMDQ_SYNC_TOKEN_IMGSYS_POOL_31>;
+			sw_sync_token_pool_32 =
+				/bits/ 16 <CMDQ_SYNC_TOKEN_IMGSYS_POOL_32>;
+			sw_sync_token_pool_33 =
+				/bits/ 16 <CMDQ_SYNC_TOKEN_IMGSYS_POOL_33>;
+			sw_sync_token_pool_34 =
+				/bits/ 16 <CMDQ_SYNC_TOKEN_IMGSYS_POOL_34>;
+			sw_sync_token_pool_35 =
+				/bits/ 16 <CMDQ_SYNC_TOKEN_IMGSYS_POOL_35>;
+			sw_sync_token_pool_36 =
+				/bits/ 16 <CMDQ_SYNC_TOKEN_IMGSYS_POOL_36>;
+			sw_sync_token_pool_37 =
+				/bits/ 16 <CMDQ_SYNC_TOKEN_IMGSYS_POOL_37>;
+			sw_sync_token_pool_38 =
+				/bits/ 16 <CMDQ_SYNC_TOKEN_IMGSYS_POOL_38>;
+			sw_sync_token_pool_39 =
+				/bits/ 16 <CMDQ_SYNC_TOKEN_IMGSYS_POOL_39>;
+			sw_sync_token_pool_40 =
+				/bits/ 16 <CMDQ_SYNC_TOKEN_IMGSYS_POOL_40>;
+			sw_sync_token_pool_41 =
+				/bits/ 16 <CMDQ_SYNC_TOKEN_IMGSYS_POOL_41>;
+			sw_sync_token_pool_42 =
+				/bits/ 16 <CMDQ_SYNC_TOKEN_IMGSYS_POOL_42>;
+			sw_sync_token_pool_43 =
+				/bits/ 16 <CMDQ_SYNC_TOKEN_IMGSYS_POOL_43>;
+			sw_sync_token_pool_44 =
+				/bits/ 16 <CMDQ_SYNC_TOKEN_IMGSYS_POOL_44>;
+			sw_sync_token_pool_45 =
+				/bits/ 16 <CMDQ_SYNC_TOKEN_IMGSYS_POOL_45>;
+			sw_sync_token_pool_46 =
+				/bits/ 16 <CMDQ_SYNC_TOKEN_IMGSYS_POOL_46>;
+			sw_sync_token_pool_47 =
+				/bits/ 16 <CMDQ_SYNC_TOKEN_IMGSYS_POOL_47>;
+			sw_sync_token_pool_48 =
+				/bits/ 16 <CMDQ_SYNC_TOKEN_IMGSYS_POOL_48>;
+			sw_sync_token_pool_49 =
+				/bits/ 16 <CMDQ_SYNC_TOKEN_IMGSYS_POOL_49>;
+			sw_sync_token_pool_50 =
+				/bits/ 16 <CMDQ_SYNC_TOKEN_IMGSYS_POOL_50>;
+			sw_sync_token_pool_51 =
+				/bits/ 16 <CMDQ_SYNC_TOKEN_IMGSYS_POOL_51>;
+			sw_sync_token_pool_52 =
+				/bits/ 16 <CMDQ_SYNC_TOKEN_IMGSYS_POOL_52>;
+			sw_sync_token_pool_53 =
+				/bits/ 16 <CMDQ_SYNC_TOKEN_IMGSYS_POOL_53>;
+			sw_sync_token_pool_54 =
+				/bits/ 16 <CMDQ_SYNC_TOKEN_IMGSYS_POOL_54>;
+			sw_sync_token_pool_55 =
+				/bits/ 16 <CMDQ_SYNC_TOKEN_IMGSYS_POOL_55>;
+			sw_sync_token_pool_56 =
+				/bits/ 16 <CMDQ_SYNC_TOKEN_IMGSYS_POOL_56>;
+			sw_sync_token_pool_57 =
+				/bits/ 16 <CMDQ_SYNC_TOKEN_IMGSYS_POOL_57>;
+			sw_sync_token_pool_58 =
+				/bits/ 16 <CMDQ_SYNC_TOKEN_IMGSYS_POOL_58>;
+			sw_sync_token_pool_59 =
+				/bits/ 16 <CMDQ_SYNC_TOKEN_IMGSYS_POOL_59>;
+			sw_sync_token_pool_60 =
+				/bits/ 16 <CMDQ_SYNC_TOKEN_IMGSYS_POOL_60>;
+			sw_sync_token_tzmp_isp_wait =
+				/bits/ 16 <CMDQ_SYNC_TOKEN_TZMP_ISP_WAIT>;
+			sw_sync_token_tzmp_isp_set =
+				/bits/ 16 <CMDQ_SYNC_TOKEN_TZMP_ISP_SET>;
+#if 0
+			sw_sync_token_pool_61 =
+				/bits/ 16 <CMDQ_SYNC_TOKEN_IMGSYS_POOL_61>;
+			sw_sync_token_pool_62 =
+				/bits/ 16 <CMDQ_SYNC_TOKEN_IMGSYS_POOL_62>;
+			sw_sync_token_pool_63 =
+				/bits/ 16 <CMDQ_SYNC_TOKEN_IMGSYS_POOL_63>;
+			sw_sync_token_pool_64 =
+				/bits/ 16 <CMDQ_SYNC_TOKEN_IMGSYS_POOL_64>;
+			sw_sync_token_pool_65 =
+				/bits/ 16 <CMDQ_SYNC_TOKEN_IMGSYS_POOL_65>;
+			sw_sync_token_pool_66 =
+				/bits/ 16 <CMDQ_SYNC_TOKEN_IMGSYS_POOL_66>;
+			sw_sync_token_pool_67 =
+				/bits/ 16 <CMDQ_SYNC_TOKEN_IMGSYS_POOL_67>;
+			sw_sync_token_pool_68 =
+				/bits/ 16 <CMDQ_SYNC_TOKEN_IMGSYS_POOL_68>;
+			sw_sync_token_pool_69 =
+				/bits/ 16 <CMDQ_SYNC_TOKEN_IMGSYS_POOL_69>;
+			sw_sync_token_pool_70 =
+				/bits/ 16 <CMDQ_SYNC_TOKEN_IMGSYS_POOL_70>;
+			sw_sync_token_pool_71 =
+				/bits/ 16 <CMDQ_SYNC_TOKEN_IMGSYS_POOL_71>;
+			sw_sync_token_pool_72 =
+				/bits/ 16 <CMDQ_SYNC_TOKEN_IMGSYS_POOL_72>;
+			sw_sync_token_pool_73 =
+				/bits/ 16 <CMDQ_SYNC_TOKEN_IMGSYS_POOL_73>;
+			sw_sync_token_pool_74 =
+				/bits/ 16 <CMDQ_SYNC_TOKEN_IMGSYS_POOL_74>;
+			sw_sync_token_pool_75 =
+				/bits/ 16 <CMDQ_SYNC_TOKEN_IMGSYS_POOL_75>;
+			sw_sync_token_pool_76 =
+				/bits/ 16 <CMDQ_SYNC_TOKEN_IMGSYS_POOL_76>;
+			sw_sync_token_pool_77 =
+				/bits/ 16 <CMDQ_SYNC_TOKEN_IMGSYS_POOL_77>;
+			sw_sync_token_pool_78 =
+				/bits/ 16 <CMDQ_SYNC_TOKEN_IMGSYS_POOL_78>;
+			sw_sync_token_pool_79 =
+				/bits/ 16 <CMDQ_SYNC_TOKEN_IMGSYS_POOL_79>;
+			sw_sync_token_pool_80 =
+				/bits/ 16 <CMDQ_SYNC_TOKEN_IMGSYS_POOL_80>;
+			sw_sync_token_pool_81 =
+				/bits/ 16 <CMDQ_SYNC_TOKEN_IMGSYS_POOL_81>;
+			sw_sync_token_pool_82 =
+				/bits/ 16 <CMDQ_SYNC_TOKEN_IMGSYS_POOL_82>;
+			sw_sync_token_pool_83 =
+				/bits/ 16 <CMDQ_SYNC_TOKEN_IMGSYS_POOL_83>;
+			sw_sync_token_pool_84 =
+				/bits/ 16 <CMDQ_SYNC_TOKEN_IMGSYS_POOL_84>;
+			sw_sync_token_pool_85 =
+				/bits/ 16 <CMDQ_SYNC_TOKEN_IMGSYS_POOL_85>;
+			sw_sync_token_pool_86 =
+				/bits/ 16 <CMDQ_SYNC_TOKEN_IMGSYS_POOL_86>;
+			sw_sync_token_pool_87 =
+				/bits/ 16 <CMDQ_SYNC_TOKEN_IMGSYS_POOL_87>;
+			sw_sync_token_pool_88 =
+				/bits/ 16 <CMDQ_SYNC_TOKEN_IMGSYS_POOL_88>;
+			sw_sync_token_pool_89 =
+				/bits/ 16 <CMDQ_SYNC_TOKEN_IMGSYS_POOL_89>;
+			sw_sync_token_pool_90 =
+				/bits/ 16 <CMDQ_SYNC_TOKEN_IMGSYS_POOL_90>;
+			sw_sync_token_pool_91 =
+				/bits/ 16 <CMDQ_SYNC_TOKEN_IMGSYS_POOL_91>;
+			sw_sync_token_pool_92 =
+				/bits/ 16 <CMDQ_SYNC_TOKEN_IMGSYS_POOL_92>;
+			sw_sync_token_pool_93 =
+				/bits/ 16 <CMDQ_SYNC_TOKEN_IMGSYS_POOL_93>;
+			sw_sync_token_pool_94 =
+				/bits/ 16 <CMDQ_SYNC_TOKEN_IMGSYS_POOL_94>;
+			sw_sync_token_pool_95 =
+				/bits/ 16 <CMDQ_SYNC_TOKEN_IMGSYS_POOL_95>;
+			sw_sync_token_pool_96 =
+				/bits/ 16 <CMDQ_SYNC_TOKEN_IMGSYS_POOL_96>;
+			sw_sync_token_pool_97 =
+				/bits/ 16 <CMDQ_SYNC_TOKEN_IMGSYS_POOL_97>;
+			sw_sync_token_pool_98 =
+				/bits/ 16 <CMDQ_SYNC_TOKEN_IMGSYS_POOL_98>;
+			sw_sync_token_pool_99 =
+				/bits/ 16 <CMDQ_SYNC_TOKEN_IMGSYS_POOL_99>;
+			sw_sync_token_pool_100 =
+				/bits/ 16 <CMDQ_SYNC_TOKEN_IMGSYS_POOL_100>;
+#endif
+			sw_sync_token_camsys_pool_1 =
+				/bits/ 16 <CMDQ_SYNC_TOKEN_CAMSYS_POOL_1>;
+			sw_sync_token_camsys_pool_2 =
+				/bits/ 16 <CMDQ_SYNC_TOKEN_CAMSYS_POOL_2>;
+			sw_sync_token_camsys_pool_3 =
+				/bits/ 16 <CMDQ_SYNC_TOKEN_CAMSYS_POOL_3>;
+			sw_sync_token_camsys_pool_4 =
+				/bits/ 16 <CMDQ_SYNC_TOKEN_CAMSYS_POOL_4>;
+			sw_sync_token_camsys_pool_5 =
+				/bits/ 16 <CMDQ_SYNC_TOKEN_CAMSYS_POOL_5>;
+			sw_sync_token_camsys_pool_6 =
+				/bits/ 16 <CMDQ_SYNC_TOKEN_CAMSYS_POOL_6>;
+			sw_sync_token_camsys_pool_7 =
+				/bits/ 16 <CMDQ_SYNC_TOKEN_CAMSYS_POOL_7>;
+			sw_sync_token_camsys_pool_8 =
+				/bits/ 16 <CMDQ_SYNC_TOKEN_CAMSYS_POOL_8>;
+			sw_sync_token_camsys_pool_9 =
+				/bits/ 16 <CMDQ_SYNC_TOKEN_CAMSYS_POOL_9>;
+			sw_sync_token_camsys_pool_10 =
+				/bits/ 16 <CMDQ_SYNC_TOKEN_CAMSYS_POOL_10>;
+			clocks = <&imgsys CLK_IMGSYS_MAIN_TRAW0>,
+				 <&imgsys CLK_IMGSYS_MAIN_TRAW1>,
+				 <&imgsys CLK_IMGSYS_MAIN_VCORE_GALS>,
+				 <&imgsys CLK_IMGSYS_MAIN_DIP0>,
+				 <&imgsys CLK_IMGSYS_MAIN_WPE0>,
+				 <&imgsys CLK_IMGSYS_MAIN_WPE1>,
+				 <&imgsys CLK_IMGSYS_MAIN_WPE2>,
+				 <&imgsys CLK_IMGSYS_MAIN_WPE0>,
+				 <&imgsys CLK_IMGSYS_MAIN_WPE1>,
+				 <&imgsys CLK_IMGSYS_MAIN_WPE2>,
+				 <&imgsys CLK_IMGSYS_MAIN_GALS>,
+				 <&imgsys1_dip_top CLK_IMGSYS1_DIP_TOP_DIP_TOP>,
+				 <&imgsys1_dip_nr CLK_IMGSYS1_DIP_NR_DIP_NR>,
+				 <&imgsys_wpe1 CLK_IMGSYS_WPE1>,
+				 <&imgsys_wpe2 CLK_IMGSYS_WPE2>,
+				 <&imgsys_wpe3 CLK_IMGSYS_WPE3>,
+				 <&imgsys CLK_IMGSYS_MAIN_IPE>;
+
+			clock-names = "IMGSYS_CG_IMG_TRAW0",
+				      "IMGSYS_CG_IMG_TRAW1",
+				      "IMGSYS_CG_IMG_VCORE_GALS",
+				      "IMGSYS_CG_IMG_DIP0",
+				      "IMGSYS_CG_IMG_WPE0",
+				      "IMGSYS_CG_IMG_WPE1",
+				      "IMGSYS_CG_IMG_WPE2",
+				      "IMGSYS_CG_IMG_ADL_LARB",
+				      "IMGSYS_CG_IMG_ADL_TOP0",
+				      "IMGSYS_CG_IMG_ADL_TOP1",
+				      "IMGSYS_CG_IMG_GALS",
+				      "DIP_TOP_DIP_TOP",
+				      "DIP_NR_DIP_NR",
+				      "WPE1_CG_DIP1_WPE",
+				      "WPE2_CG_DIP1_WPE",
+				      "WPE3_CG_DIP1_WPE",
+				      "ME_CG_IPE";
+
+			operating-points-v2 = <&opp_table_img>, <&opp_table_ipe>;
+			dvfsrc-vmm-supply = <&vmm_proxy_label>;
+			assigned-clocks = <&topckgen CLK_TOP_IMG>;
+			assigned-clock-parents = <&apmixedsys CLK_APMIXED_IMGPLL>;
+#if 0
+			interconnects =
+				<&mmqos MASTER_LARB_PORT(M4U_PORT_L9_IMGI_T1_A)
+					&mmqos SLAVE_COMMON(0)>,
+				<&mmqos MASTER_LARB_PORT(M4U_PORT_L9_UFDI_T1_A)
+					&mmqos SLAVE_COMMON(0)>,
+				<&mmqos MASTER_LARB_PORT(M4U_PORT_L9_IMGBI_T1_A)
+					&mmqos SLAVE_COMMON(0)>,
+				<&mmqos MASTER_LARB_PORT(M4U_PORT_L9_IMGCI_T1_A)
+					&mmqos SLAVE_COMMON(0)>,
+				<&mmqos MASTER_LARB_PORT(M4U_PORT_L9_SMTI_T1_A)
+					&mmqos SLAVE_COMMON(0)>,
+				<&mmqos MASTER_LARB_PORT(M4U_PORT_L9_SMTI_T4_A)
+					&mmqos SLAVE_COMMON(0)>,
+				<&mmqos MASTER_LARB_PORT(M4U_PORT_L9_TNCSTI_T1_A)
+					&mmqos SLAVE_COMMON(0)>,
+				<&mmqos MASTER_LARB_PORT(M4U_PORT_L9_TNCSTI_T4_A)
+					&mmqos SLAVE_COMMON(0)>,
+				<&mmqos MASTER_LARB_PORT(M4U_PORT_L9_YUVO_T1_A)
+					&mmqos SLAVE_COMMON(0)>,
+				<&mmqos MASTER_LARB_PORT(M4U_PORT_L9_YUVBO_T1_A)
+					&mmqos SLAVE_COMMON(0)>,
+				<&mmqos MASTER_LARB_PORT(M4U_PORT_L9_YUVCO_T1_A)
+					&mmqos SLAVE_COMMON(0)>,
+				<&mmqos MASTER_LARB_PORT(M4U_PORT_L9_TIMGO_T1_A)
+					&mmqos SLAVE_COMMON(0)>,
+				<&mmqos MASTER_LARB_PORT(M4U_PORT_L9_YUVO_T2_A)
+					&mmqos SLAVE_COMMON(0)>,
+				<&mmqos MASTER_LARB_PORT(M4U_PORT_L9_YUVO_T5_A)
+					&mmqos SLAVE_COMMON(0)>,
+				<&mmqos MASTER_LARB_PORT(M4U_PORT_L9_IMGI_T1_B)
+					&mmqos SLAVE_COMMON(0)>,
+				<&mmqos MASTER_LARB_PORT(M4U_PORT_L9_IMGBI_T1_B)
+					&mmqos SLAVE_COMMON(0)>,
+				<&mmqos MASTER_LARB_PORT(M4U_PORT_L9_IMGCI_T1_B)
+					&mmqos SLAVE_COMMON(0)>,
+				<&mmqos MASTER_LARB_PORT(M4U_PORT_L9_SMTI_T4_B)
+					&mmqos SLAVE_COMMON(0)>,
+				<&mmqos MASTER_LARB_PORT(M4U_PORT_L9_TNCSO_T1_A)
+					&mmqos SLAVE_COMMON(0)>,
+				<&mmqos MASTER_LARB_PORT(M4U_PORT_L9_SMTO_T1_A)
+					&mmqos SLAVE_COMMON(0)>,
+				<&mmqos MASTER_LARB_PORT(M4U_PORT_L9_SMTO_T4_A)
+					&mmqos SLAVE_COMMON(0)>,
+				<&mmqos MASTER_LARB_PORT(M4U_PORT_L9_TNCSTO_T1_A)
+					&mmqos SLAVE_COMMON(0)>,
+				<&mmqos MASTER_LARB_PORT(M4U_PORT_L9_YUVO_T2_B)
+					&mmqos SLAVE_COMMON(0)>,
+				<&mmqos MASTER_LARB_PORT(M4U_PORT_L9_YUVO_T5_B)
+					&mmqos SLAVE_COMMON(0)>,
+				<&mmqos MASTER_LARB_PORT(M4U_PORT_L9_SMTO_T4_B)
+					&mmqos SLAVE_COMMON(0)>,
+				<&mmqos MASTER_LARB_PORT(M4U_PORT_L11A_IMGI_T1_C)
+					&mmqos SLAVE_COMMON(0)>,
+				<&mmqos MASTER_LARB_PORT(M4U_PORT_L11A_IMGBI_T1_C)
+					&mmqos SLAVE_COMMON(0)>,
+				<&mmqos MASTER_LARB_PORT(M4U_PORT_L11A_IMGCI_T1_C)
+					&mmqos SLAVE_COMMON(0)>,
+				<&mmqos MASTER_LARB_PORT(M4U_PORT_L11A_SMTI_T1_C)
+					&mmqos SLAVE_COMMON(0)>,
+				<&mmqos MASTER_LARB_PORT(M4U_PORT_L11A_SMTI_T4_C)
+					&mmqos SLAVE_COMMON(0)>,
+				<&mmqos MASTER_LARB_PORT(M4U_PORT_L11A_SMTI_T6_C)
+					&mmqos SLAVE_COMMON(0)>,
+				<&mmqos MASTER_LARB_PORT(M4U_PORT_L11A_YUVO_T1_C)
+					&mmqos SLAVE_COMMON(0)>,
+				<&mmqos MASTER_LARB_PORT(M4U_PORT_L11A_YUVBO_T1_C)
+					&mmqos SLAVE_COMMON(0)>,
+				<&mmqos MASTER_LARB_PORT(M4U_PORT_L11A_YUVCO_T1_C)
+					&mmqos SLAVE_COMMON(0)>,
+				<&mmqos MASTER_LARB_PORT(M4U_PORT_L11A_TIMGO_T1_C)
+					&mmqos SLAVE_COMMON(0)>,
+				<&mmqos MASTER_LARB_PORT(M4U_PORT_L11A_YUVO_T2_C)
+					&mmqos SLAVE_COMMON(0)>,
+				<&mmqos MASTER_LARB_PORT(M4U_PORT_L11A_YUVO_T5_C)
+					&mmqos SLAVE_COMMON(0)>,
+				<&mmqos MASTER_LARB_PORT(M4U_PORT_L11A_SMTO_T1_C)
+					&mmqos SLAVE_COMMON(0)>,
+				<&mmqos MASTER_LARB_PORT(M4U_PORT_L11A_SMTO_T4_C)
+					&mmqos SLAVE_COMMON(0)>,
+				<&mmqos MASTER_LARB_PORT(M4U_PORT_L11A_SMTO_T6_C)
+					&mmqos SLAVE_COMMON(0)>,
+				<&mmqos MASTER_LARB_PORT(M4U_PORT_L11A_DBGO_T1_C)
+					&mmqos SLAVE_COMMON(0)>,
+				<&mmqos MASTER_LARB_PORT(M4U_PORT_L10_IMGI_D1)
+					&mmqos SLAVE_COMMON(0)>,
+				<&mmqos MASTER_LARB_PORT(M4U_PORT_L10_IMGBI_D1)
+					&mmqos SLAVE_COMMON(0)>,
+				<&mmqos MASTER_LARB_PORT(M4U_PORT_L10_IMGCI_D1)
+					&mmqos SLAVE_COMMON(0)>,
+				<&mmqos MASTER_LARB_PORT(M4U_PORT_L10_IMGDI_D1)
+					&mmqos SLAVE_COMMON(0)>,
+				<&mmqos MASTER_LARB_PORT(M4U_PORT_L10_DEPI_D1)
+					&mmqos SLAVE_COMMON(0)>,
+				<&mmqos MASTER_LARB_PORT(M4U_PORT_L10_DMGI_D1)
+					&mmqos SLAVE_COMMON(0)>,
+				<&mmqos MASTER_LARB_PORT(M4U_PORT_L10_SMTI_D1)
+					&mmqos SLAVE_COMMON(0)>,
+				<&mmqos MASTER_LARB_PORT(M4U_PORT_L10_RECI_D1)
+					&mmqos SLAVE_COMMON(0)>,
+				<&mmqos MASTER_LARB_PORT(M4U_PORT_L10_RECI_D1_N)
+					&mmqos SLAVE_COMMON(0)>,
+				<&mmqos MASTER_LARB_PORT(M4U_PORT_L10_TNRWI_D1)
+					&mmqos SLAVE_COMMON(0)>,
+				<&mmqos MASTER_LARB_PORT(M4U_PORT_L10_TNRCI_D1)
+					&mmqos SLAVE_COMMON(0)>,
+				<&mmqos MASTER_LARB_PORT(M4U_PORT_L10_TNRCI_D1_N)
+					&mmqos SLAVE_COMMON(0)>,
+				<&mmqos MASTER_LARB_PORT(M4U_PORT_L10_IMG4O_D1)
+					&mmqos SLAVE_COMMON(0)>,
+				<&mmqos MASTER_LARB_PORT(M4U_PORT_L10_IMG4BO_D1)
+					&mmqos SLAVE_COMMON(0)>,
+				<&mmqos MASTER_LARB_PORT(M4U_PORT_L10_SMTI_D8)
+					&mmqos SLAVE_COMMON(0)>,
+				<&mmqos MASTER_LARB_PORT(M4U_PORT_L10_SMTO_D1)
+					&mmqos SLAVE_COMMON(0)>,
+				<&mmqos MASTER_LARB_PORT(M4U_PORT_L10_TNRMO_D1)
+					&mmqos SLAVE_COMMON(0)>,
+				<&mmqos MASTER_LARB_PORT(M4U_PORT_L10_TNRMO_D1_N)
+					&mmqos SLAVE_COMMON(0)>,
+				<&mmqos MASTER_LARB_PORT(M4U_PORT_L10_SMTO_D8)
+					&mmqos SLAVE_COMMON(0)>,
+				<&mmqos MASTER_LARB_PORT(M4U_PORT_L10_DBGO_D1)
+					&mmqos SLAVE_COMMON(0)>,
+				<&mmqos MASTER_LARB_PORT(M4U_PORT_L15_VIPI_D1)
+					&mmqos SLAVE_COMMON(1)>,
+				<&mmqos MASTER_LARB_PORT(M4U_PORT_L15_VIPBI_D1)
+					&mmqos SLAVE_COMMON(1)>,
+				<&mmqos MASTER_LARB_PORT(M4U_PORT_L15_SMTI_D6)
+					&mmqos SLAVE_COMMON(1)>,
+				<&mmqos MASTER_LARB_PORT(M4U_PORT_L15_TNCSTI_D1)
+					&mmqos SLAVE_COMMON(1)>,
+				<&mmqos MASTER_LARB_PORT(M4U_PORT_L15_TNCSTI_D4)
+					&mmqos SLAVE_COMMON(1)>,
+				<&mmqos MASTER_LARB_PORT(M4U_PORT_L15_SMTI_D4)
+					&mmqos SLAVE_COMMON(1)>,
+				<&mmqos MASTER_LARB_PORT(M4U_PORT_L15_IMG3O_D1)
+					&mmqos SLAVE_COMMON(1)>,
+				<&mmqos MASTER_LARB_PORT(M4U_PORT_L15_IMG3BO_D1)
+					&mmqos SLAVE_COMMON(1)>,
+				<&mmqos MASTER_LARB_PORT(M4U_PORT_L15_IMG3CO_D1)
+					&mmqos SLAVE_COMMON(1)>,
+				<&mmqos MASTER_LARB_PORT(M4U_PORT_L15_IMG2O_D1)
+					&mmqos SLAVE_COMMON(1)>,
+				<&mmqos MASTER_LARB_PORT(M4U_PORT_L15_SMTI_D9)
+					&mmqos SLAVE_COMMON(1)>,
+				<&mmqos MASTER_LARB_PORT(M4U_PORT_L15_SMTO_D4)
+					&mmqos SLAVE_COMMON(1)>,
+				<&mmqos MASTER_LARB_PORT(M4U_PORT_L15_FEO_D1)
+					&mmqos SLAVE_COMMON(1)>,
+				<&mmqos MASTER_LARB_PORT(M4U_PORT_L15_TNCSO_D1)
+					&mmqos SLAVE_COMMON(1)>,
+				<&mmqos MASTER_LARB_PORT(M4U_PORT_L15_TNCSTO_D1)
+					&mmqos SLAVE_COMMON(1)>,
+				<&mmqos MASTER_LARB_PORT(M4U_PORT_L15_SMTO_D6)
+					&mmqos SLAVE_COMMON(1)>,
+				<&mmqos MASTER_LARB_PORT(M4U_PORT_L15_SMTO_D9)
+					&mmqos SLAVE_COMMON(1)>,
+				<&mmqos MASTER_LARB_PORT(M4U_PORT_L15_TNCO_D1)
+					&mmqos SLAVE_COMMON(1)>,
+				<&mmqos MASTER_LARB_PORT(M4U_PORT_L15_TNCO_D1_N)
+					&mmqos SLAVE_COMMON(1)>,
+				<&mmqos MASTER_LARB_PORT(M4U_PORT_L11A_PIMGI_P1)
+					&mmqos SLAVE_COMMON(0)>,
+				<&mmqos MASTER_LARB_PORT(M4U_PORT_L11A_PIMGBI_P1)
+					&mmqos SLAVE_COMMON(0)>,
+				<&mmqos MASTER_LARB_PORT(M4U_PORT_L11A_PIMGCI_P1)
+					&mmqos SLAVE_COMMON(0)>,
+				<&mmqos MASTER_LARB_PORT(M4U_PORT_L11A_WROT_P1)
+					&mmqos SLAVE_COMMON(0)>,
+				<&mmqos MASTER_LARB_PORT(M4U_PORT_L11A_TCCSO_P1)
+					&mmqos SLAVE_COMMON(0)>,
+				<&mmqos MASTER_LARB_PORT(M4U_PORT_L11A_TCCSI_P1)
+					&mmqos SLAVE_COMMON(0)>,
+				<&mmqos MASTER_LARB_PORT(M4U_PORT_L11B_PIMGI_P1)
+					&mmqos SLAVE_COMMON(1)>,
+				<&mmqos MASTER_LARB_PORT(M4U_PORT_L11B_PIMGBI_P1)
+					&mmqos SLAVE_COMMON(1)>,
+				<&mmqos MASTER_LARB_PORT(M4U_PORT_L11B_PIMGCI_P1)
+					&mmqos SLAVE_COMMON(1)>,
+				<&mmqos MASTER_LARB_PORT(M4U_PORT_L11B_WROT_P1)
+					&mmqos SLAVE_COMMON(1)>,
+				<&mmqos MASTER_LARB_PORT(M4U_PORT_L11B_TCCSO_P1)
+					&mmqos SLAVE_COMMON(1)>,
+				<&mmqos MASTER_LARB_PORT(M4U_PORT_L11B_TCCSI_P1)
+					&mmqos SLAVE_COMMON(1)>,
+				<&mmqos MASTER_LARB_PORT(M4U_PORT_L11A_WPE_RDMA_0)
+					&mmqos SLAVE_COMMON(0)>,
+				<&mmqos MASTER_LARB_PORT(M4U_PORT_L11A_WPE_RDMA_1)
+					&mmqos SLAVE_COMMON(0)>,
+				<&mmqos MASTER_LARB_PORT(M4U_PORT_L11A_WPE_RDMA_4P_0)
+					&mmqos SLAVE_COMMON(0)>,
+				<&mmqos MASTER_LARB_PORT(M4U_PORT_L11A_WPE_RDMA_4P_1)
+					&mmqos SLAVE_COMMON(0)>,
+				<&mmqos MASTER_LARB_PORT(M4U_PORT_L11A_WPE_CQ0)
+					&mmqos SLAVE_COMMON(0)>,
+				<&mmqos MASTER_LARB_PORT(M4U_PORT_L11A_WPE_CQ1)
+					&mmqos SLAVE_COMMON(0)>,
+				<&mmqos MASTER_LARB_PORT(M4U_PORT_L11A_WPE_WDMA_0)
+					&mmqos SLAVE_COMMON(0)>,
+				<&mmqos MASTER_LARB_PORT(M4U_PORT_L11A_WPE_WDMA_4P_0)
+					&mmqos SLAVE_COMMON(0)>,
+				<&mmqos MASTER_LARB_PORT(M4U_PORT_L11B_WPE_RDMA_0)
+					&mmqos SLAVE_COMMON(1)>,
+				<&mmqos MASTER_LARB_PORT(M4U_PORT_L11B_WPE_RDMA_1)
+					&mmqos SLAVE_COMMON(1)>,
+				<&mmqos MASTER_LARB_PORT(M4U_PORT_L11B_WPE_RDMA_4P_0)
+					&mmqos SLAVE_COMMON(1)>,
+				<&mmqos MASTER_LARB_PORT(M4U_PORT_L11B_WPE_RDMA_4P_1)
+					&mmqos SLAVE_COMMON(1)>,
+				<&mmqos MASTER_LARB_PORT(M4U_PORT_L11B_WPE_CQ0)
+					&mmqos SLAVE_COMMON(1)>,
+				<&mmqos MASTER_LARB_PORT(M4U_PORT_L11B_WPE_CQ1)
+					&mmqos SLAVE_COMMON(1)>,
+				<&mmqos MASTER_LARB_PORT(M4U_PORT_L11B_WPE_WDMA_0)
+					&mmqos SLAVE_COMMON(1)>,
+				<&mmqos MASTER_LARB_PORT(M4U_PORT_L11B_WPE_WDMA_4P_0)
+					&mmqos SLAVE_COMMON(1)>,
+				<&mmqos MASTER_LARB_PORT(M4U_PORT_L11C_WPE_RDMA_0)
+					&mmqos SLAVE_COMMON(0)>,
+				<&mmqos MASTER_LARB_PORT(M4U_PORT_L11C_WPE_RDMA_1)
+					&mmqos SLAVE_COMMON(0)>,
+				<&mmqos MASTER_LARB_PORT(M4U_PORT_L11C_WPE_RDMA_4P_0)
+					&mmqos SLAVE_COMMON(0)>,
+				<&mmqos MASTER_LARB_PORT(M4U_PORT_L11C_WPE_RDMA_4P_1)
+					&mmqos SLAVE_COMMON(0)>,
+				<&mmqos MASTER_LARB_PORT(M4U_PORT_L11C_WPE_CQ0)
+					&mmqos SLAVE_COMMON(0)>,
+				<&mmqos MASTER_LARB_PORT(M4U_PORT_L11C_WPE_CQ1)
+					&mmqos SLAVE_COMMON(0)>,
+				<&mmqos MASTER_LARB_PORT(M4U_PORT_L11C_WPE_WDMA_0)
+					&mmqos SLAVE_COMMON(0)>,
+				<&mmqos MASTER_LARB_PORT(M4U_PORT_L11C_WPE_WDMA_4P_0)
+					&mmqos SLAVE_COMMON(0)>,
+				<&mmqos MASTER_LARB_PORT(M4U_PORT_L12_ME_RDMA)
+					&mmqos SLAVE_COMMON(1)>,
+				<&mmqos MASTER_LARB_PORT(M4U_PORT_L12_ME_WDMA)
+					&mmqos SLAVE_COMMON(1)>,
+				<&mmqos SLAVE_LARB(SMI_L9_ID)
+					&mmqos SLAVE_COMMON(0)>,
+				<&mmqos SLAVE_LARB(SMI_L12_ID)
+					&mmqos SLAVE_COMMON(1)>;
+#endif
+			interconnect-names =
+				"l9_imgi_t1_a",
+				"l9_ufdi_t1_a",
+				"l9_imgbi_t1_a",
+				"l9_imgci_t1_a",
+				"l9_smti_t1_a",
+				"l9_smti_t4_a",
+				"l9_tncsti_t1_a",
+				"l9_tncsti_t4_a",
+				"l9_yuvo_t1_a",
+				"l9_yuvbo_t1_a",
+				"l9_yuvco_t1_a",
+				"l9_timgo_t1_a",
+				"l9_yuvo_t2_a",
+				"l9_yuvo_t5_a",
+				"l9_tncso_t1_a",
+				"l9_smto_t1_a",
+				"l9_smto_t4_a",
+				"l9_tncsto_t1_a",
+				"l9_imgi_t1_b",
+				"l9_imgbi_t1_b",
+				"l9_imgci_t1_b",
+				"l9_smti_t4_b",
+				"l9_yuvo_t2_b",
+				"l9_yuvo_t5_b",
+				"l9_smto_t4_b",
+				"l11a_imgi_t1_c",
+				"l11a_imgbi_t1_c",
+				"l11a_imgci_t1_c",
+				"l11a_smti_t1_c",
+				"l11a_smti_t4_c",
+				"l11a_smti_t6_c",
+				"l11a_yuvo_t1_c",
+				"l11a_yuvbo_t1_c",
+				"l11a_yuvco_t1_c",
+				"l11a_timgo_t1_c",
+				"l11a_yuvo_t2_c",
+				"l11a_yuvo_t5_c",
+				"l11a_smto_t1_c",
+				"l11a_smto_t4_c",
+				"l11a_smto_t6_c",
+				"l11a_dbgo_t1_c",
+				"l10_imgi_d1",
+				"l10_imgbi_d1",
+				"l10_imgci_d1",
+				"l10_imgdi_d1",
+				"l10_depi_d1",
+				"l10_dmgi_d1",
+				"l10_smti_d1",
+				"l10_reci_d1",
+				"l10_reci_d1_n",
+				"l10_tnrwi_d1",
+				"l10_tnrci_d1",
+				"l10_tnrci_d1_n",
+				"l10_img4o_d1",
+				"l10_img4bo_d1",
+				"l10_smti_d8",
+				"l10_smto_d1",
+				"l10_tnrmo_d1",
+				"l10_tnrmo_d1_n",
+				"l10_smto_d8",
+				"l10_dbgo_d1",
+				"l15_vipi_d1",
+				"l15_vipbi_d1",
+				"l15_smti_d6",
+				"l15_tncsti_d1",
+				"l15_tncsti_d4",
+				"l15_smti_d4",
+				"l15_img3o_d1",
+				"l15_img3bo_d1",
+				"l15_img3co_d1",
+				"l15_img2o_d1",
+				"l15_smti_d9",
+				"l15_smto_d4",
+				"l15_feo_d1",
+				"l15_tncso_d1",
+				"l15_tncsto_d1",
+				"l15_smto_d6",
+				"l15_smto_d9",
+				"l15_tnco_d1",
+				"l15_tnco_d1_n",
+				"l11a_pimgi_p1",
+				"l11a_pimgbi_p1",
+				"l11a_pimgci_p1",
+				"l11a_wrot_p1",
+				"l11a_tccso_p1",
+				"l11a_tccsi_p1",
+				"l11b_pimgi_p1",
+				"l11b_pimgbi_p1",
+				"l11b_pimgci_p1",
+				"l11b_wrot_p1",
+				"l11b_tccso_p1",
+				"l11b_tccsi_p1",
+				"l11a_wpe_rdma0",
+				"l11a_wpe_rdma1",
+				"l11a_wpe_rdma_4p0",
+				"l11a_wpe_rdma_4p1",
+				"l11a_wpe_cq0",
+				"l11a_wpe_cq1",
+				"l11a_wpe_wdma0",
+				"l11a_wpe_wdma_4p0",
+				"l11b_wpe_rdma0",
+				"l11b_wpe_rdma1",
+				"l11b_wpe_rdma_4p0",
+				"l11b_wpe_rdma_4p1",
+				"l11b_wpe_cq0",
+				"l11b_wpe_cq1",
+				"l11b_wpe_wdma0",
+				"l11b_wpe_wdma_4p0",
+				"l11c_wpe_rdma0",
+				"l11c_wpe_rdma1",
+				"l11c_wpe_rdma_4p0",
+				"l11c_wpe_rdma_4p1",
+				"l11c_wpe_cq0",
+				"l11c_wpe_cq1",
+				"l11c_wpe_wdma0",
+				"l11c_wpe_wdma_4p0",
+				"l12_me_rdma",
+				"l12_me_wdma",
+				"l9_common_0",
+				"l12_common_1";
+		};
+
+		imgsys_l10 {
+			compatible = "mediatek,imgsys-larb";
+			dma-ranges = <0x2 0x0 0x0 0x40000000 0x1 0x0>;
+			iommus = <&vdo_iommu M4U_PORT_L10_IMGI_D1>,
+				 <&vdo_iommu M4U_PORT_L10_IMGBI_D1>,
+				 <&vdo_iommu M4U_PORT_L10_IMGCI_D1>,
+				 <&vdo_iommu M4U_PORT_L10_IMGDI_D1>,
+				 <&vdo_iommu M4U_PORT_L10_DEPI_D1>,
+				 <&vdo_iommu M4U_PORT_L10_DMGI_D1>,
+				 <&vdo_iommu M4U_PORT_L10_SMTI_D1>,
+				 <&vdo_iommu M4U_PORT_L10_RECI_D1>,
+				 <&vdo_iommu M4U_PORT_L10_RECI_D1_N>,
+				 <&vdo_iommu M4U_PORT_L10_TNRWI_D1>,
+				 <&vdo_iommu M4U_PORT_L10_TNRCI_D1>,
+				 <&vdo_iommu M4U_PORT_L10_TNRCI_D1_N>,
+				 <&vdo_iommu M4U_PORT_L10_IMG4O_D1>,
+				 <&vdo_iommu M4U_PORT_L10_IMG4BO_D1>,
+				 <&vdo_iommu M4U_PORT_L10_SMTI_D8>,
+				 <&vdo_iommu M4U_PORT_L10_SMTO_D1>,
+				 <&vdo_iommu M4U_PORT_L10_TNRMO_D1>,
+				 <&vdo_iommu M4U_PORT_L10_TNRMO_D1_N>,
+				 <&vdo_iommu M4U_PORT_L10_SMTO_D8>,
+				 <&vdo_iommu M4U_PORT_L10_DBGO_D1>;
+		};
+
+		imgsys_l11A {
+			compatible = "mediatek,imgsys-larb";
+			dma-ranges = <0x2 0x0 0x0 0x40000000 0x1 0x0>;
+			iommus = <&vdo_iommu M4U_PORT_L11A_WPE_RDMA_0>,
+				 <&vdo_iommu M4U_PORT_L11A_WPE_RDMA_1>,
+				 <&vdo_iommu M4U_PORT_L11A_WPE_RDMA_4P_0>,
+				 <&vdo_iommu M4U_PORT_L11A_WPE_RDMA_4P_1>,
+				 <&vdo_iommu M4U_PORT_L11A_WPE_CQ0>,
+				 <&vdo_iommu M4U_PORT_L11A_WPE_CQ1>,
+				 <&vdo_iommu M4U_PORT_L11A_PIMGI_P1>,
+				 <&vdo_iommu M4U_PORT_L11A_PIMGBI_P1>,
+				 <&vdo_iommu M4U_PORT_L11A_PIMGCI_P1>,
+				 <&vdo_iommu M4U_PORT_L11A_IMGI_T1_C>,
+				 <&vdo_iommu M4U_PORT_L11A_IMGBI_T1_C>,
+				 <&vdo_iommu M4U_PORT_L11A_IMGCI_T1_C>,
+				 <&vdo_iommu M4U_PORT_L11A_SMTI_T1_C>,
+				 <&vdo_iommu M4U_PORT_L11A_SMTI_T4_C>,
+				 <&vdo_iommu M4U_PORT_L11A_SMTI_T6_C>,
+				 <&vdo_iommu M4U_PORT_L11A_YUVO_T1_C>,
+				 <&vdo_iommu M4U_PORT_L11A_YUVBO_T1_C>,
+				 <&vdo_iommu M4U_PORT_L11A_YUVCO_T1_C>,
+				 <&vdo_iommu M4U_PORT_L11A_WPE_WDMA_0>,
+				 <&vdo_iommu M4U_PORT_L11A_WPE_WDMA_4P_0>,
+				 <&vdo_iommu M4U_PORT_L11A_WROT_P1>,
+				 <&vdo_iommu M4U_PORT_L11A_TCCSO_P1>,
+				 <&vdo_iommu M4U_PORT_L11A_TCCSI_P1>,
+				 <&vdo_iommu M4U_PORT_L11A_TIMGO_T1_C>,
+				 <&vdo_iommu M4U_PORT_L11A_YUVO_T2_C>,
+				 <&vdo_iommu M4U_PORT_L11A_YUVO_T5_C>,
+				 <&vdo_iommu M4U_PORT_L11A_SMTO_T1_C>,
+				 <&vdo_iommu M4U_PORT_L11A_SMTO_T4_C>,
+				 <&vdo_iommu M4U_PORT_L11A_SMTO_T6_C>,
+				 <&vdo_iommu M4U_PORT_L11A_DBGO_T1_C>;
+		};
+
+		imgsys_l11C {
+			compatible = "mediatek,imgsys-larb";
+			dma-ranges = <0x2 0x0 0x0 0x40000000 0x1 0x0>;
+			iommus = <&vdo_iommu M4U_PORT_L11C_WPE_RDMA_0>,
+				 <&vdo_iommu M4U_PORT_L11C_WPE_RDMA_1>,
+				 <&vdo_iommu M4U_PORT_L11C_WPE_RDMA_4P_0>,
+				 <&vdo_iommu M4U_PORT_L11C_WPE_RDMA_4P_1>,
+				 <&vdo_iommu M4U_PORT_L11C_WPE_CQ0>,
+				 <&vdo_iommu M4U_PORT_L11C_WPE_CQ1>,
+				 <&vdo_iommu M4U_PORT_L11C_PIMGI_P1>,
+				 <&vdo_iommu M4U_PORT_L11C_PIMGBI_P1>,
+				 <&vdo_iommu M4U_PORT_L11C_PIMGCI_P1>,
+				 <&vdo_iommu M4U_PORT_L11C_IMGI_T1_C>,
+				 <&vdo_iommu M4U_PORT_L11C_IMGBI_T1_C>,
+				 <&vdo_iommu M4U_PORT_L11C_IMGCI_T1_C>,
+				 <&vdo_iommu M4U_PORT_L11C_SMTI_T1_C>,
+				 <&vdo_iommu M4U_PORT_L11C_SMTI_T4_C>,
+				 <&vdo_iommu M4U_PORT_L11C_SMTI_T6_C>,
+				 <&vdo_iommu M4U_PORT_L11C_YUVO_T1_C>,
+				 <&vdo_iommu M4U_PORT_L11C_YUVBO_T1_C>,
+				 <&vdo_iommu M4U_PORT_L11C_YUVCO_T1_C>,
+				 <&vdo_iommu M4U_PORT_L11C_WPE_WDMA_0>,
+				 <&vdo_iommu M4U_PORT_L11C_WPE_WDMA_4P_0>,
+				 <&vdo_iommu M4U_PORT_L11C_WROT_P1>,
+				 <&vdo_iommu M4U_PORT_L11C_TCCSO_P1>,
+				 <&vdo_iommu M4U_PORT_L11C_TCCSI_P1>,
+				 <&vdo_iommu M4U_PORT_L11C_TIMGO_T1_C>,
+				 <&vdo_iommu M4U_PORT_L11C_YUVO_T2_C>,
+				 <&vdo_iommu M4U_PORT_L11C_YUVO_T5_C>,
+				 <&vdo_iommu M4U_PORT_L11C_SMTO_T1_C>,
+				 <&vdo_iommu M4U_PORT_L11C_SMTO_T4_C>,
+				 <&vdo_iommu M4U_PORT_L11C_SMTO_T6_C>,
+				 <&vdo_iommu M4U_PORT_L11C_DBGO_T1_C>;
+		};
+
+		ipesys_me: ipesys_me@15320000 {
+			compatible = "mediatek,ipesys-me";
+			reg = <0 0x15320000 0 0x10000>;	/* IPESYS_ME */
+			mediatek,larb = <&larb12>;
+			dma-ranges = <0x2 0x0 0x0 0x40000000 0x1 0x0>;
+			iommus = <&vpp_iommu M4U_PORT_L12_ME_RDMA>,
+				 <&vpp_iommu M4U_PORT_L12_ME_WDMA>;
+			clocks =
+				<&imgsys CLK_IMGSYS_MAIN_IPE>,
+				<&ipesys CLK_IPESYS_TOP>,
+				<&ipesys CLK_IPE_ME>,
+				<&ipesys CLK_IPE_SMI_LARB12>;
+			clock-names =
+				"ME_CG_IPE",
+				"ME_CG_IPE_TOP",
+				"ME_CG",
+				"ME_CG_LARB12";
+			assigned-clocks = <&topckgen CLK_TOP_IPE>;
+			assigned-clock-parents = <&topckgen CLK_TOP_MAINPLL_D4>;
+		};
+		aie: aie@15310000 {
+			compatible = "mediatek,mt8188-aie", "mediatek,aie-hw3.1";
+			reg = <0 0x15310000 0 0x1000>;
+			interrupts = <GIC_SPI 787 IRQ_TYPE_LEVEL_HIGH 0>;
+			mediatek,larb = <&larb12>;
+			dma-ranges = <0x2 0x0 0x0 0x40000000 0x1 0x0>;
+			iommus = <&vpp_iommu M4U_PORT_L12_FDVT_RDA_0>,
+				 <&vpp_iommu M4U_PORT_L12_FDVT_RDB_0>,
+				 <&vpp_iommu M4U_PORT_L12_FDVT_WRA_0>,
+				 <&vpp_iommu M4U_PORT_L12_FDVT_WRB_0>;
+			power-domains = <&spm MT8188_POWER_DOMAIN_IPE>;
+			clocks = <&imgsys CLK_IMGSYS_MAIN_IPE>,
+				 <&ipesys CLK_IPE_FDVT>,
+				 <&ipesys CLK_IPE_SMI_LARB12>,
+				 <&ipesys CLK_IPESYS_TOP>;
+			clock-names = "IMG_IPE",
+				      "IPE_FDVT",
+				      "IPE_SMI_LARB12",
+				      "IPE_TOP";
+			operating-points-v2 = <&opp_table_ipe>;
+			dvfsrc-vcore-supply = <&vmm_proxy_label>;
+/*
+			interconnects =
+				<&mmqos MASTER_LARB_PORT(M4U_PORT_L12_FDVT_RDA_0)
+				 &mmqos SLAVE_COMMON(1)>,
+				<&mmqos MASTER_LARB_PORT(M4U_PORT_L12_FDVT_RDB_0)
+				 &mmqos SLAVE_COMMON(1)>,
+				<&mmqos MASTER_LARB_PORT(M4U_PORT_L12_FDVT_WRA_0)
+				 &mmqos SLAVE_COMMON(1)>,
+				<&mmqos MASTER_LARB_PORT(M4U_PORT_L12_FDVT_WRB_0)
+				 &mmqos SLAVE_COMMON(1)>;
+			interconnect-names = "l12_fdvt_rda",
+					     "l12_fdvt_rdb",
+					     "l12_fdvt_wra",
+					     "l12_fdvt_wrb";
+*/
+			};
+
+		ipesys: syscon@15330000 {
+			compatible = "mediatek,mt8188-ipesys", "syscon";
+			reg = <0 0x15330000 0 0x1000>;
+			#clock-cells = <1>;
+		};
+
+		larb12: larb@15340000 {
+			compatible = "mediatek,mt8188-smi-larb";
+			reg = <0 0x15340000 0 0x1000>;
+			mediatek,larb-id = <SMI_L12_ID>;
+			mediatek,smi = <&vpp_smi_common>;
+			clocks = <&imgsys CLK_IMGSYS_MAIN_IPE>,
+				 <&ipesys CLK_IPE_SMI_LARB12>;
+			clock-names = "apb", "smi";
+			power-domains = <&spm MT8188_POWER_DOMAIN_IPE>;
+		};
+
+		imgsys_wpe2: syscon@15520000 {
+			compatible = "mediatek,mt8188-imgsys-wpe2", "syscon";
+			reg = <0 0x15520000 0 0x1000>;
+			#clock-cells = <1>;
+		};
+
+		larb11b: larb@15530000 {
+			compatible = "mediatek,mt8188-smi-larb";
+			reg = <0 0x15530000 0 0x1000>;
+			mediatek,larb-id = <SMI_L11B_ID>;
+			mediatek,smi = <&vpp_smi_common>;
+			clocks = <&imgsys CLK_IMGSYS_MAIN_WPE1>,
+				 <&imgsys_wpe2 CLK_IMGSYS_WPE2_LARB11>;
+			clock-names = "apb", "smi";
+			power-domains = <&spm MT8188_POWER_DOMAIN_DIP>;
+		};
+
+		imgsys_wpe3: syscon@15620000 {
+			compatible = "mediatek,mt8188-imgsys-wpe3", "syscon";
+			reg = <0 0x15620000 0 0x1000>;
+			#clock-cells = <1>;
+		};
+
+		larb11c: larb@15630000 {
+			compatible = "mediatek,mt8188-smi-larb";
+			reg = <0 0x15630000 0 0x1000>;
+			mediatek,larb-id = <SMI_L11C_ID>;
+			mediatek,smi = <&vdo_smi_common>;
+			clocks = <&imgsys CLK_IMGSYS_MAIN_WPE2>,
+				 <&imgsys_wpe3 CLK_IMGSYS_WPE3_LARB11>;
+			clock-names = "apb", "smi";
+			power-domains = <&spm MT8188_POWER_DOMAIN_DIP>;
+		};
+
+		camsys: syscon@16000000 {
+			compatible = "mediatek,mt8188-camsys", "syscon";
+			reg = <0 0x16000000 0 0x1000>;
+			#clock-cells = <1>;
+		};
+
+		camisp: camisp@16000000 {
+			compatible = "mediatek,camisp";
+			reg = <0 0x16000000 0 0x1000>;
+			reg-names = "base";
+			mediatek,scp = <&scp_dual>;
+			power-domains = <&spm MT8188_POWER_DOMAIN_CAM_MAIN>;
+		};
+
+		camisp_l13 {
+			compatible = "mediatek,camisp-larb";
+			mediatek,larb-id = <13>;
+			dma-ranges = <0x2 0x0 0x0 0x40000000 0x1 0x0>;
+			iommus = <&vdo_iommu M4U_PORT_L13_CAMSV_CQI_E1>,
+					<&vdo_iommu M4U_PORT_L13_CAMSV_CQI_E2>,
+					<&vdo_iommu M4U_PORT_L13_GCAMSV_A_IMGO_1>,
+					<&vdo_iommu M4U_PORT_L13_GCAMSV_C_IMGO_1>,
+					<&vdo_iommu M4U_PORT_L13_GCAMSV_A_IMGO_2>,
+					<&vdo_iommu M4U_PORT_L13_GCAMSV_C_IMGO_2>,
+					<&vdo_iommu M4U_PORT_L13_PDAI_A_0>,
+					<&vdo_iommu M4U_PORT_L13_PDAI_A_1>,
+					<&vdo_iommu M4U_PORT_L13_CAMSV_CQI_B_E1>,
+					<&vdo_iommu M4U_PORT_L13_CAMSV_CQI_B_E2>,
+					<&vdo_iommu M4U_PORT_L13_CAMSV_CQI_C_E1>,
+					<&vdo_iommu M4U_PORT_L13_CAMSV_CQI_C_E2>,
+					<&vdo_iommu M4U_PORT_L13_GCAMSV_E_IMGO_1>,
+					<&vdo_iommu M4U_PORT_L13_GCAMSV_E_IMGO_2>,
+					<&vdo_iommu M4U_PORT_L13_GCAMSV_A_UFEO_1>,
+					<&vdo_iommu M4U_PORT_L13_GCAMSV_C_UFEO_1>,
+					<&vdo_iommu M4U_PORT_L13_GCAMSV_A_UFEO_2>,
+					<&vdo_iommu M4U_PORT_L13_GCAMSV_C_UFEO_2>,
+					<&vdo_iommu M4U_PORT_L13_GCAMSV_E_UFEO_1>,
+					<&vdo_iommu M4U_PORT_L13_GCAMSV_E_UFEO_2>,
+					<&vdo_iommu M4U_PORT_L13_GCAMSV_G_IMGO_1>,
+					<&vdo_iommu M4U_PORT_L13_GCAMSV_G_IMGO_2>,
+					<&vdo_iommu M4U_PORT_L13_PDAO_A>,
+					<&vdo_iommu M4U_PORT_L13_PDAO_C>;
+		};
+
+		camisp_l14 {
+			compatible = "mediatek,camisp-larb";
+			mediatek,larb-id = <14>;
+			dma-ranges = <0x2 0x0 0x0 0x40000000 0x1 0x0>;
+			iommus = <&vpp_iommu M4U_PORT_L14_GCAMSV_B_IMGO_1>,
+					<&vpp_iommu M4U_PORT_L14_GCAMSV_B_IMGO_2>,
+					<&vpp_iommu M4U_PORT_L14_SCAMSV_A_IMGO_1>,
+					<&vpp_iommu M4U_PORT_L14_SCAMSV_A_IMGO_2>,
+					<&vpp_iommu M4U_PORT_L14_SCAMSV_B_IMGO_1>,
+					<&vpp_iommu M4U_PORT_L14_SCAMSV_B_IMGO_2>,
+					<&vpp_iommu M4U_PORT_L14_PDAI_B_0>,
+					<&vpp_iommu M4U_PORT_L14_PDAI_B_1>,
+					<&vpp_iommu M4U_PORT_L14_GCAMSV_D_IMGO_1>,
+					<&vpp_iommu M4U_PORT_L14_GCAMSV_D_IMGO_2>,
+					<&vpp_iommu M4U_PORT_L14_GCAMSV_F_IMGO_1>,
+					<&vpp_iommu M4U_PORT_L14_GCAMSV_F_IMGO_2>,
+					<&vpp_iommu M4U_PORT_L14_GCAMSV_H_IMGO_1>,
+					<&vpp_iommu M4U_PORT_L14_GCAMSV_B_UFEO_1>,
+					<&vpp_iommu M4U_PORT_L14_GCAMSV_B_UFEO_2>,
+					<&vpp_iommu M4U_PORT_L14_GCAMSV_D_UFEO_1>,
+					<&vpp_iommu M4U_PORT_L14_GCAMSV_D_UFEO_2>,
+					<&vpp_iommu M4U_PORT_L14_PDAO_B>,
+					<&vpp_iommu M4U_PORT_L14_IPUI>,
+					<&vpp_iommu M4U_PORT_L14_IPUO>,
+					<&vpp_iommu M4U_PORT_L14_IPU3O>,
+					<&vpp_iommu M4U_PORT_L14_FAKE>;
+		};
+
+		larb13: larb@16001000 {
+			compatible = "mediatek,mt8188-smi-larb";
+			reg = <0 0x16001000 0 0x1000>;
+			mediatek,larb-id = <SMI_L13_ID>;
+			mediatek,smi = <&vdo_smi_common>;
+			clocks = <&camsys CLK_CAM_MAIN_LARB13>,
+				 <&camsys CLK_CAM_MAIN_LARB13>;
+			clock-names = "apb", "smi";
+			power-domains = <&spm MT8188_POWER_DOMAIN_CAM_MAIN>;
+		};
+
+		larb14: larb@16002000 {
+			compatible = "mediatek,mt8188-smi-larb";
+			reg = <0 0x16002000 0 0x1000>;
+			mediatek,larb-id = <SMI_L14_ID>;
+			mediatek,smi = <&vpp_smi_common>;
+			clocks = <&camsys CLK_CAM_MAIN_LARB14>,
+				 <&camsys CLK_CAM_MAIN_LARB14>;
+			clock-names = "apb", "smi";
+			power-domains = <&spm MT8188_POWER_DOMAIN_CAM_MAIN>;
+		};
+
+		smi_cam0: syscon@16005000 {
+			compatible = "mediatek,mt8188-smi-cam0", "syscon";
+			reg = <0 0x16005000 0 0x1000>;
+		};
+
+		smi_cam1: syscon@16006000 {
+			compatible = "mediatek,mt8188-smi-cam1", "syscon";
+			reg = <0 0x16006000 0 0x1000>;
+		};
+
+		larb16a: larb@16008000 {
+			compatible = "mediatek,mt8188-smi-larb";
+			reg = <0 0x16008000 0 0x1000>;
+			mediatek,larb-id = <SMI_L16A_ID>;
+			mediatek,smi = <&vpp_smi_common>;
+			clocks = <&camsys CLK_CAM_MAIN_CAM_SUBA>,
+				 <&camsys_rawa CLK_CAM_RAWA_LARBX>;
+			clock-names = "apb", "smi";
+			power-domains = <&spm MT8188_POWER_DOMAIN_CAM_SUBA>;
+		};
+
+		larb17a: larb@16009000 {
+			compatible = "mediatek,mt8188-smi-larb";
+			reg = <0 0x16009000 0 0x1000>;
+			mediatek,larb-id = <SMI_L17A_ID>;
+			mediatek,smi = <&vpp_smi_common>;
+			clocks = <&camsys CLK_CAM_MAIN_CAM_SUBA>,
+				 <&camsys_yuva CLK_CAM_YUVA_LARBX>;
+			clock-names = "apb", "smi";
+			power-domains = <&spm MT8188_POWER_DOMAIN_CAM_SUBA>;
+		};
+
+		larb16b: larb@1600a000 {
+			compatible = "mediatek,mt8188-smi-larb";
+			reg = <0 0x1600a000 0 0x1000>;
+			mediatek,larb-id = <SMI_L16B_ID>;
+			mediatek,smi = <&vdo_smi_common>;
+			clocks = <&camsys CLK_CAM_MAIN_CAM_SUBB>,
+				 <&camsys_rawb CLK_CAM_RAWB_LARBX>;
+			clock-names = "apb", "smi";
+			power-domains = <&spm MT8188_POWER_DOMAIN_CAM_SUBB>;
+		};
+
+		larb17b: larb@1600b000 {
+			compatible = "mediatek,mt8188-smi-larb";
+			reg = <0 0x1600b000 0 0x1000>;
+			mediatek,larb-id = <SMI_L17B_ID>;
+			mediatek,smi = <&vdo_smi_common>;
+			clocks = <&camsys CLK_CAM_MAIN_CAM_SUBB>,
+				 <&camsys_yuvb CLK_CAM_YUVB_LARBX>;
+			clock-names = "apb", "smi";
+			power-domains = <&spm MT8188_POWER_DOMAIN_CAM_SUBB>;
+		};
+
+		seninf_top: seninf_top@16010000 {
+			compatible = "mediatek,seninf-core";
+			reg = <0 0x16010000 0 0x8000>,
+			      <0 0x11ed0000 0 0xc000>;
+			reg-names = "base", "ana-rx";
+			mtk_csi_phy_ver = "mtk_csi_phy_2_0";
+			interrupts = <GIC_SPI 316 IRQ_TYPE_LEVEL_HIGH 0>;
+			power-domains = <&spm MT8188_POWER_DOMAIN_CSIRX_TOP>,
+							<&spm MT8188_POWER_DOMAIN_CAM_VCORE>,
+							<&spm MT8188_POWER_DOMAIN_CAM_MAIN>;
+			clocks = <&camsys CLK_CAM_MAIN_SENINF>,
+					 <&topckgen CLK_TOP_SENINF>,
+					 <&topckgen CLK_TOP_SENINF1>,
+					 <&topckgen CLK_TOP_CAMTM>;
+			clock-names = "clk_cam_seninf",
+				      "clk_top_seninf",
+				      "clk_top_seninf1",
+				      "clk_top_camtm";
+		};
+
+		cam_raw_a@16030000 {
+			compatible = "mediatek,cam-raw";
+			reg = <0 0x16030000 0 0x8000>,
+			      <0 0x16038000 0 0x8000>;
+			reg-names = "base", "inner_base";
+			mediatek,cam-id = <0>;
+			mediatek,larbs = <&larb16a>;
+			interrupts = <GIC_SPI 300 IRQ_TYPE_LEVEL_HIGH 0>;
+			dma-ranges = <0x2 0x0 0x0 0x40000000 0x1 0x0>;
+			power-domains = <&spm MT8188_POWER_DOMAIN_CAM_SUBA>;
+			clocks = <&camsys CLK_CAM_MAIN_CAM2MM0_GALS>,
+					<&camsys CLK_CAM_MAIN_CAM2MM1_GALS>,
+					<&camsys CLK_CAM_MAIN_CAM2SYS_GALS>,
+					<&camsys CLK_CAM_MAIN_CAM>,
+					<&camsys CLK_CAM_MAIN_CAMTG>,
+					<&camsys_rawa CLK_CAM_RAWA_LARBX>,
+					<&camsys_rawa CLK_CAM_RAWA_CAM>,
+					<&camsys_rawa CLK_CAM_RAWA_CAMTG>,
+					<&topckgen CLK_TOP_CAM>,
+					<&topckgen CLK_TOP_CAMTG>,
+					<&topckgen CLK_TOP_CAMTM>;
+			clock-names = "camsys_cam2mm0_cgpdn",
+					"camsys_cam2mm1_cgpdn",
+					"camsys_cam2sys_cgpdn",
+					"camsys_cam_cgpdn",
+					"camsys_camtg_cgpdn",
+					"camsys_rawa_larbx_cgpdn",
+					"camsys_rawa_cam_cgpdn",
+					"camsys_rawa_camtg_cgpdn",
+					"topckgen_top_cam",
+					"topckgen_top_camtg",
+					"topckgen_top_camtm";
+			assigned-clocks = <&topckgen CLK_TOP_CAM>;
+			assigned-clock-parents = <&topckgen CLK_TOP_UNIVPLL_D5>;
+			iommus = <&vpp_iommu M4U_PORT_L16A_IMGO_R1>,
+					<&vpp_iommu M4U_PORT_L16A_CQI_R1>,
+					<&vpp_iommu M4U_PORT_L16A_CQI_R2>,
+					<&vpp_iommu M4U_PORT_L16A_BPCI_R1>,
+					<&vpp_iommu M4U_PORT_L16A_LSCI_R1>,
+					<&vpp_iommu M4U_PORT_L16A_RAWI_R2>,
+					<&vpp_iommu M4U_PORT_L16A_RAWI_R3>,
+					<&vpp_iommu M4U_PORT_L16A_UFDI_R2>,
+					<&vpp_iommu M4U_PORT_L16A_UFDI_R3>,
+					<&vpp_iommu M4U_PORT_L16A_RAWI_R4>,
+					<&vpp_iommu M4U_PORT_L16A_RAWI_R5>,
+					<&vpp_iommu M4U_PORT_L16A_AAI_R1>,
+					<&vpp_iommu M4U_PORT_L16A_UFDI_R5>,
+					<&vpp_iommu M4U_PORT_L16A_FHO_R1>,
+					<&vpp_iommu M4U_PORT_L16A_AAO_R1>,
+					<&vpp_iommu M4U_PORT_L16A_TSFSO_R1>,
+					<&vpp_iommu M4U_PORT_L16A_FLKO_R1>;
+		};
+
+		camsys_rawa: syscon@1604f000 {
+			compatible = "mediatek,mt8188-camsys-rawa", "syscon";
+			reg = <0 0x1604f000 0 0x1000>;
+			#clock-cells = <1>;
+		};
+
+		cam_yuv_a@16050000 {
+			compatible = "mediatek,cam-yuv";
+			reg = <0 0x16050000 0 0x8000>;
+			reg-names = "base";
+			mediatek,cam-id = <0>;
+			mediatek,larbs = <&larb17a>;
+			interrupts = <GIC_SPI 301 IRQ_TYPE_LEVEL_HIGH 0>;
+			dma-ranges = <0x2 0x0 0x0 0x40000000 0x1 0x0>;
+			power-domains = <&spm MT8188_POWER_DOMAIN_CAM_SUBA>;
+			clocks = <&camsys CLK_CAM_MAIN_CAM2MM0_GALS>,
+					<&camsys CLK_CAM_MAIN_CAM2MM1_GALS>,
+					<&camsys CLK_CAM_MAIN_CAM2SYS_GALS>,
+					<&camsys_yuva CLK_CAM_YUVA_LARBX>,
+					<&camsys_yuva CLK_CAM_YUVA_CAM>,
+					<&camsys_yuva CLK_CAM_YUVA_CAMTG>;
+			clock-names = "camsys_cam2mm0_cgpdn",
+					"camsys_cam2mm1_cgpdn",
+					"camsys_cam2sys_cgpdn",
+					"camsys_yuva_larbx_cgpdn",
+					"camsys_yuva_cam_cgpdn",
+					"camsys_yuva_camtg_cgpdn";
+			assigned-clocks = <&topckgen CLK_TOP_CAM>;
+			assigned-clock-parents = <&topckgen CLK_TOP_UNIVPLL_D5>;
+			iommus = <&vpp_iommu M4U_PORT_L17A_YUVO_R1>,
+					<&vpp_iommu M4U_PORT_L17A_YUVO_R3>,
+					<&vpp_iommu M4U_PORT_L17A_YUVCO_R1>,
+					<&vpp_iommu M4U_PORT_L17A_YUVO_R2>,
+					<&vpp_iommu M4U_PORT_L17A_RZH1N2TO_R1>,
+					<&vpp_iommu M4U_PORT_L17A_DRZS4NO_R1>,
+					<&vpp_iommu M4U_PORT_L17A_TNCSO_R1>;
+		};
+
+		camsys_yuva: syscon@1606f000 {
+			compatible = "mediatek,mt8188-camsys-yuva", "syscon";
+			reg = <0 0x1606f000 0 0x1000>;
+			#clock-cells = <1>;
+		};
+
+		cam_raw_b@16070000 {
+			compatible = "mediatek,cam-raw";
+			reg = <0 0x16070000 0 0x8000>,
+			      <0 0x16078000 0 0x8000>;
+			reg-names = "base", "inner_base";
+			mediatek,cam-id = <1>;
+			mediatek,larbs = <&larb16b>;
+			dma-ranges = <0x2 0x0 0x0 0x40000000 0x1 0x0>;
+			interrupts = <GIC_SPI 302 IRQ_TYPE_LEVEL_HIGH 0>;
+			power-domains = <&spm MT8188_POWER_DOMAIN_CAM_SUBB>;
+			clocks = <&camsys CLK_CAM_MAIN_CAM2MM0_GALS>,
+					 <&camsys CLK_CAM_MAIN_CAM2MM1_GALS>,
+					 <&camsys CLK_CAM_MAIN_CAM2SYS_GALS>,
+					 <&camsys CLK_CAM_MAIN_CAM>,
+					 <&camsys CLK_CAM_MAIN_CAMTG>,
+					 <&camsys_rawb CLK_CAM_RAWB_LARBX>,
+					 <&camsys_rawb CLK_CAM_RAWB_CAM>,
+					 <&camsys_rawb CLK_CAM_RAWB_CAMTG>,
+					 <&topckgen CLK_TOP_CAM>,
+					 <&topckgen CLK_TOP_CAMTG>,
+					 <&topckgen CLK_TOP_CAMTM>;
+			clock-names = "camsys_cam2mm0_cgpdn",
+					"camsys_cam2mm1_cgpdn",
+					"camsys_cam2sys_cgpdn",
+					"camsys_cam_cgpdn",
+					"camsys_camtg_cgpdn",
+					"camsys_rawb_larbx_cgpdn",
+					"camsys_rawb_cam_cgpdn",
+					"camsys_rawb_camtg_cgpdn",
+					"topckgen_top_cam",
+					"topckgen_top_camtg",
+					"topckgen_top_camtm";
+			assigned-clocks = <&topckgen CLK_TOP_CAM>;
+			assigned-clock-parents = <&topckgen CLK_TOP_UNIVPLL_D5>;
+			iommus = <&vdo_iommu M4U_PORT_L16B_IMGO_R1>,
+					 <&vdo_iommu M4U_PORT_L16B_CQI_R1>,
+					 <&vdo_iommu M4U_PORT_L16B_CQI_R2>,
+					 <&vdo_iommu M4U_PORT_L16B_BPCI_R1>,
+					 <&vdo_iommu M4U_PORT_L16B_LSCI_R1>,
+					 <&vdo_iommu M4U_PORT_L16B_RAWI_R2>,
+					 <&vdo_iommu M4U_PORT_L16B_RAWI_R3>,
+					 <&vdo_iommu M4U_PORT_L16B_UFDI_R2>,
+					 <&vdo_iommu M4U_PORT_L16B_UFDI_R3>,
+					 <&vdo_iommu M4U_PORT_L16B_RAWI_R4>,
+					 <&vdo_iommu M4U_PORT_L16B_RAWI_R5>,
+					 <&vdo_iommu M4U_PORT_L16B_AAI_R1>,
+					 <&vdo_iommu M4U_PORT_L16B_UFDI_R5>,
+					 <&vdo_iommu M4U_PORT_L16B_FHO_R1>,
+					 <&vdo_iommu M4U_PORT_L16B_AAO_R1>,
+					 <&vdo_iommu M4U_PORT_L16B_TSFSO_R1>,
+					 <&vdo_iommu M4U_PORT_L16B_FLKO_R1>;
+		};
+
+		camsys_rawb: syscon@1608f000 {
+			compatible = "mediatek,mt8188-camsys-rawb", "syscon";
+			reg = <0 0x1608f000 0 0x1000>;
+			#clock-cells = <1>;
+		};
+
+		cam_yuv_b@16090000 {
+			compatible = "mediatek,cam-yuv";
+			reg = <0 0x16090000 0 0x8000>;
+			reg-names = "base";
+			mediatek,cam-id = <1>;
+			mediatek,larbs = <&larb17b>;
+			interrupts = <GIC_SPI 303 IRQ_TYPE_LEVEL_HIGH 0>;
+			dma-ranges = <0x2 0x0 0x0 0x40000000 0x1 0x0>;
+			power-domains = <&spm MT8188_POWER_DOMAIN_CAM_SUBB>;
+			clocks = <&camsys CLK_CAM_MAIN_CAM2MM0_GALS>,
+					<&camsys CLK_CAM_MAIN_CAM2MM1_GALS>,
+					<&camsys CLK_CAM_MAIN_CAM2SYS_GALS>,
+					<&camsys_yuvb CLK_CAM_YUVB_LARBX>,
+					<&camsys_yuvb CLK_CAM_YUVB_CAM>,
+					<&camsys_yuvb CLK_CAM_YUVB_CAMTG>;
+			clock-names = "camsys_cam2mm0_cgpdn",
+					"camsys_cam2mm1_cgpdn",
+					"camsys_cam2sys_cgpdn",
+					"camsys_yuvb_larbx_cgpdn",
+					"camsys_yuvb_cam_cgpdn",
+					"camsys_yuvb_camtg_cgpdn";
+			assigned-clocks = <&topckgen CLK_TOP_CAM>;
+			assigned-clock-parents = <&topckgen CLK_TOP_UNIVPLL_D5>;
+			iommus = <&vdo_iommu M4U_PORT_L17B_YUVO_R1>,
+					 <&vdo_iommu M4U_PORT_L17B_YUVO_R3>,
+					 <&vdo_iommu M4U_PORT_L17B_YUVCO_R1>,
+					 <&vdo_iommu M4U_PORT_L17B_YUVO_R2>,
+					 <&vdo_iommu M4U_PORT_L17B_RZH1N2TO_R1>,
+					 <&vdo_iommu M4U_PORT_L17B_DRZS4NO_R1>,
+					 <&vdo_iommu M4U_PORT_L17B_TNCSO_R1>;
+		};
+
+		camsys_yuvb: syscon@160af000 {
+			compatible = "mediatek,mt8188-camsys-yuvb", "syscon";
+			reg = <0 0x160af000 0 0x1000>;
+			#clock-cells = <1>;
+		};
+
+		camsv1@16110000 {
+			compatible = "mediatek,camsv";
+			reg = <0 0x16110000 0 0x1000>,
+				  <0 0x16118000 0 0x1000>;
+			reg-names = "base", "inner_base";
+			mediatek,camsv-id = <0>;
+			mediatek,camsv-hwcap = <0x110051>;
+			mediatek,cammux-id = <2>;
+			interrupts = <GIC_SPI 317 IRQ_TYPE_LEVEL_HIGH 0>;
+			power-domains = <&spm MT8188_POWER_DOMAIN_CAM_MAIN>;
+			clocks = <&camsys CLK_CAM_MAIN_CAM2MM0_GALS>,
+					 <&camsys CLK_CAM_MAIN_CAM2MM1_GALS>,
+					 <&camsys CLK_CAM_MAIN_CAM2SYS_GALS>,
+					 <&camsys CLK_CAM_MAIN_CAM>,
+					 <&camsys CLK_CAM_MAIN_CAMTG>,
+					 <&camsys CLK_CAM_MAIN_LARB13>,
+					 <&camsys CLK_CAM_MAIN_GCAMSVA>,
+					 <&camsys CLK_CAM_MAIN_CAMSV_TOP>,
+					 <&camsys CLK_CAM_MAIN_CAMSV_CQ_A>,
+					 <&topckgen CLK_TOP_CAM>,
+					 <&topckgen CLK_TOP_CAMTG>,
+					 <&topckgen CLK_TOP_CAMTM>;
+			clock-names = "cam_main_cam2mm0_gals_con",
+						"cam_main_cam2mm1_gals_con",
+						"cam_main_cam2sys_gals_con",
+						"cam_main_cam_con",
+						"cam_main_camtg_con",
+						"cam_main_larb13_con",
+						"cam_main_gcamsva_con",
+						"cam_main_camsv_top_con",
+						"cam_main_camsv_cq_a_con",
+						"topckgen_top_cam",
+						"topckgen_top_camtg",
+						"topckgen_top_camtm";
+			assigned-clocks = <&topckgen CLK_TOP_CAM>;
+			assigned-clock-parents = <&topckgen CLK_TOP_UNIVPLL_D5>;
+		};
+		camsv2@16111000 {
+			compatible = "mediatek,camsv";
+			reg = <0 0x16111000 0 0x1000>,
+				  <0 0x16119000 0 0x1000>;
+			reg-names = "base", "inner_base";
+			mediatek,camsv-id = <1>;
+			mediatek,camsv-hwcap = <0x210051>;
+			mediatek,cammux-id = <3>;
+			interrupts = <GIC_SPI 318 IRQ_TYPE_LEVEL_HIGH 0>;
+			power-domains = <&spm MT8188_POWER_DOMAIN_CAM_MAIN>;
+			clocks = <&camsys CLK_CAM_MAIN_CAM2MM0_GALS>,
+					 <&camsys CLK_CAM_MAIN_CAM2MM1_GALS>,
+					 <&camsys CLK_CAM_MAIN_CAM2SYS_GALS>,
+					 <&camsys CLK_CAM_MAIN_CAM>,
+					 <&camsys CLK_CAM_MAIN_CAMTG>,
+					 <&camsys CLK_CAM_MAIN_LARB13>,
+					 <&camsys CLK_CAM_MAIN_GCAMSVA>,
+					 <&camsys CLK_CAM_MAIN_CAMSV_TOP>,
+					 <&camsys CLK_CAM_MAIN_CAMSV_CQ_A>,
+					 <&topckgen CLK_TOP_CAM>,
+					 <&topckgen CLK_TOP_CAMTG>,
+					 <&topckgen CLK_TOP_CAMTM>;
+			clock-names = "cam_main_cam2mm0_gals_con",
+						"cam_main_cam2mm1_gals_con",
+						"cam_main_cam2sys_gals_con",
+						"cam_main_cam_con",
+						"cam_main_camtg_con",
+						"cam_main_larb13_con",
+						"cam_main_gcamsva_con",
+						"cam_main_camsv_top_con",
+						"cam_main_camsv_cq_a_con",
+						"topckgen_top_cam",
+						"topckgen_top_camtg",
+						"topckgen_top_camtm";
+		};
+		camsv3@16112000 {
+			compatible = "mediatek,camsv";
+			reg = <0 0x16112000 0 0x1000>,
+				  <0 0x1611a000 0 0x1000>;
+			reg-names = "base", "inner_base";
+			mediatek,camsv-id = <2>;
+			mediatek,camsv-hwcap = <0x120051>;
+			mediatek,cammux-id = <4>;
+			interrupts = <GIC_SPI 319 IRQ_TYPE_LEVEL_HIGH 0>;
+			power-domains = <&spm MT8188_POWER_DOMAIN_CAM_MAIN>;
+			clocks = <&camsys CLK_CAM_MAIN_CAM2MM0_GALS>,
+					<&camsys CLK_CAM_MAIN_CAM2MM1_GALS>,
+					<&camsys CLK_CAM_MAIN_CAM2SYS_GALS>,
+					<&camsys CLK_CAM_MAIN_CAM>,
+					<&camsys CLK_CAM_MAIN_CAMTG>,
+					<&camsys CLK_CAM_MAIN_LARB14>,
+					<&camsys CLK_CAM_MAIN_GCAMSVB>,
+					<&camsys CLK_CAM_MAIN_CAMSV_TOP>,
+					<&camsys CLK_CAM_MAIN_CAMSV_CQ_A>,
+					<&topckgen CLK_TOP_CAM>,
+					<&topckgen CLK_TOP_CAMTG>,
+					<&topckgen CLK_TOP_CAMTM>;
+			clock-names = "cam_main_cam2mm0_gals_con",
+						"cam_main_cam2mm1_gals_con",
+						"cam_main_cam2sys_gals_con",
+						"cam_main_cam_con",
+						"cam_main_camtg_con",
+						"cam_main_larb14_con",
+						"cam_main_gcamsvb_con",
+						"cam_main_camsv_top_con",
+						"cam_main_camsv_cq_a_con",
+						"topckgen_top_cam",
+						"topckgen_top_camtg",
+						"topckgen_top_camtm";
+			assigned-clocks = <&topckgen CLK_TOP_CAM>;
+			assigned-clock-parents = <&topckgen CLK_TOP_UNIVPLL_D5>;
+		};
+		camsv4@16113000 {
+			compatible = "mediatek,camsv";
+			reg = <0 0x16113000 0 0x1000>,
+				  <0 0x1611b000 0 0x1000>;
+			reg-names = "base", "inner_base";
+			mediatek,camsv-id = <3>;
+			mediatek,camsv-hwcap = <0x220051>;
+			mediatek,cammux-id = <5>;
+			interrupts = <GIC_SPI 320 IRQ_TYPE_LEVEL_HIGH 0>;
+			power-domains = <&spm MT8188_POWER_DOMAIN_CAM_MAIN>;
+			clocks = <&camsys CLK_CAM_MAIN_CAM2MM0_GALS>,
+					<&camsys CLK_CAM_MAIN_CAM2MM1_GALS>,
+					<&camsys CLK_CAM_MAIN_CAM2SYS_GALS>,
+					<&camsys CLK_CAM_MAIN_CAM>,
+					<&camsys CLK_CAM_MAIN_CAMTG>,
+					<&camsys CLK_CAM_MAIN_LARB14>,
+					<&camsys CLK_CAM_MAIN_GCAMSVB>,
+					<&camsys CLK_CAM_MAIN_CAMSV_TOP>,
+					<&camsys CLK_CAM_MAIN_CAMSV_CQ_A>,
+					<&topckgen CLK_TOP_CAM>,
+					<&topckgen CLK_TOP_CAMTG>,
+					<&topckgen CLK_TOP_CAMTM>;
+			clock-names = "cam_main_cam2mm0_gals_con",
+						"cam_main_cam2mm1_gals_con",
+						"cam_main_cam2sys_gals_con",
+						"cam_main_cam_con",
+						"cam_main_camtg_con",
+						"cam_main_larb14_con",
+						"cam_main_gcamsvb_con",
+						"cam_main_camsv_top_con",
+						"cam_main_camsv_cq_a_con",
+						"topckgen_top_cam",
+						"topckgen_top_camtg",
+						"topckgen_top_camtm";
+			assigned-clocks = <&topckgen CLK_TOP_CAM>;
+			assigned-clock-parents = <&topckgen CLK_TOP_UNIVPLL_D5>;
+		};
+		camsv5@16184000 {
+			compatible = "mediatek,camsv";
+			reg = <0 0x16184000 0 0x1000>,
+				  <0 0x1618c000 0 0x1000>;
+			reg-names = "base", "inner_base";
+			mediatek,camsv-id = <4>;
+			mediatek,camsv-hwcap = <0x1>;
+			mediatek,cammux-id = <6>;
+			interrupts = <GIC_SPI 329 IRQ_TYPE_LEVEL_HIGH 0>;
+			power-domains = <&spm MT8188_POWER_DOMAIN_CAM_MAIN>;
+			clocks = <&camsys CLK_CAM_MAIN_CAM2MM0_GALS>,
+					<&camsys CLK_CAM_MAIN_CAM2MM1_GALS>,
+					<&camsys CLK_CAM_MAIN_CAM2SYS_GALS>,
+					<&camsys CLK_CAM_MAIN_CAM>,
+					<&camsys CLK_CAM_MAIN_CAMTG>,
+					<&camsys CLK_CAM_MAIN_LARB13>,
+					<&camsys CLK_CAM_MAIN_GCAMSVG>,
+					<&camsys CLK_CAM_MAIN_CAMSV_TOP>,
+					<&topckgen CLK_TOP_CAM>,
+					<&topckgen CLK_TOP_CAMTG>,
+					<&topckgen CLK_TOP_CAMTM>;
+			clock-names = "cam_main_cam2mm0_gals_con",
+						"cam_main_cam2mm1_gals_con",
+						"cam_main_cam2sys_gals_con",
+						"cam_main_cam_con",
+						"cam_main_camtg_con",
+						"cam_main_larb13_con",
+						"cam_main_gcamsvg_con",
+						"cam_main_camsv_top_con",
+						"topckgen_top_cam",
+						"topckgen_top_camtg",
+						"topckgen_top_camtm";
+			assigned-clocks = <&topckgen CLK_TOP_CAM>;
+			assigned-clock-parents = <&topckgen CLK_TOP_UNIVPLL_D5>;
+		};
+		camsv6@16185000 {
+			compatible = "mediatek,camsv";
+			reg = <0 0x16185000 0 0x1000>,
+				  <0 0x1618d000 0 0x1000>;
+			reg-names = "base", "inner_base";
+			mediatek,camsv-id = <5>;
+			mediatek,camsv-hwcap = <0x1>;
+			mediatek,cammux-id = <7>;
+			interrupts = <GIC_SPI 330 IRQ_TYPE_LEVEL_HIGH 0>;
+			power-domains = <&spm MT8188_POWER_DOMAIN_CAM_MAIN>;
+			clocks = <&camsys CLK_CAM_MAIN_CAM2MM0_GALS>,
+					<&camsys CLK_CAM_MAIN_CAM2MM1_GALS>,
+					<&camsys CLK_CAM_MAIN_CAM2SYS_GALS>,
+					<&camsys CLK_CAM_MAIN_CAM>,
+					<&camsys CLK_CAM_MAIN_CAMTG>,
+					<&camsys CLK_CAM_MAIN_LARB13>,
+					<&camsys CLK_CAM_MAIN_GCAMSVG>,
+					<&camsys CLK_CAM_MAIN_CAMSV_TOP>,
+					<&topckgen CLK_TOP_CAM>,
+					<&topckgen CLK_TOP_CAMTG>,
+					<&topckgen CLK_TOP_CAMTM>;
+			clock-names = "cam_main_cam2mm0_gals_con",
+						"cam_main_cam2mm1_gals_con",
+						"cam_main_cam2sys_gals_con",
+						"cam_main_cam_con",
+						"cam_main_camtg_con",
+						"cam_main_larb13_con",
+						"cam_main_gcamsvg_con",
+						"cam_main_camsv_top_con",
+						"topckgen_top_cam",
+						"topckgen_top_camtg",
+						"topckgen_top_camtm";
+			assigned-clocks = <&topckgen CLK_TOP_CAM>;
+			assigned-clock-parents = <&topckgen CLK_TOP_UNIVPLL_D5>;
+		};
+		camsv7@16186000 {
+			compatible = "mediatek,camsv";
+			reg = <0 0x16186000 0 0x1000>,
+				  <0 0x1618e000 0 0x1000>;
+			reg-names = "base", "inner_base";
+			mediatek,camsv-id = <6>;
+			mediatek,camsv-hwcap = <0x1>;
+			mediatek,cammux-id = <8>;
+			interrupts = <GIC_SPI 331 IRQ_TYPE_LEVEL_HIGH 0>;
+			power-domains = <&spm MT8188_POWER_DOMAIN_CAM_MAIN>;
+			clocks = <&camsys CLK_CAM_MAIN_CAM2MM0_GALS>,
+					<&camsys CLK_CAM_MAIN_CAM2MM1_GALS>,
+					<&camsys CLK_CAM_MAIN_CAM2SYS_GALS>,
+					<&camsys CLK_CAM_MAIN_CAM>,
+					<&camsys CLK_CAM_MAIN_CAMTG>,
+					<&camsys CLK_CAM_MAIN_LARB14>,
+					<&camsys CLK_CAM_MAIN_GCAMSVH>,
+					<&camsys CLK_CAM_MAIN_CAMSV_TOP>,
+					<&topckgen CLK_TOP_CAM>,
+					<&topckgen CLK_TOP_CAMTG>,
+					<&topckgen CLK_TOP_CAMTM>;
+			clock-names = "cam_main_cam2mm0_gals_con",
+						"cam_main_cam2mm1_gals_con",
+						"cam_main_cam2sys_gals_con",
+						"cam_main_cam_con",
+						"cam_main_camtg_con",
+						"cam_main_larb14_con",
+						"cam_main_gcamsvh_con",
+						"cam_main_camsv_top_con",
+						"topckgen_top_cam",
+						"topckgen_top_camtg",
+						"topckgen_top_camtm";
+			assigned-clocks = <&topckgen CLK_TOP_CAM>;
+			assigned-clock-parents = <&topckgen CLK_TOP_UNIVPLL_D5>;
+		};
+		camsv8@16187000 {
+			compatible = "mediatek,camsv";
+			reg = <0 0x16187000 0 0x1000>,
+				  <0 0x1618f000 0 0x1000>;
+			reg-names = "base", "inner_base";
+			mediatek,camsv-id = <7>;
+			mediatek,camsv-hwcap = <0x1>;
+			mediatek,cammux-id = <9>;
+			interrupts = <GIC_SPI 332 IRQ_TYPE_LEVEL_HIGH 0>;
+			power-domains = <&spm MT8188_POWER_DOMAIN_CAM_MAIN>;
+			clocks = <&camsys CLK_CAM_MAIN_CAM2MM0_GALS>,
+					<&camsys CLK_CAM_MAIN_CAM2MM1_GALS>,
+					<&camsys CLK_CAM_MAIN_CAM2SYS_GALS>,
+					<&camsys CLK_CAM_MAIN_CAM>,
+					<&camsys CLK_CAM_MAIN_CAMTG>,
+					<&camsys CLK_CAM_MAIN_LARB14>,
+					<&camsys CLK_CAM_MAIN_GCAMSVH>,
+					<&camsys CLK_CAM_MAIN_CAMSV_TOP>,
+					<&topckgen CLK_TOP_CAM>,
+					<&topckgen CLK_TOP_CAMTG>,
+					<&topckgen CLK_TOP_CAMTM>;
+			clock-names = "cam_main_cam2mm0_gals_con",
+						"cam_main_cam2mm1_gals_con",
+						"cam_main_cam2sys_gals_con",
+						"cam_main_cam_con",
+						"cam_main_camtg_con",
+						"cam_main_larb14_con",
+						"cam_main_gcamsvh_con",
+						"cam_main_camsv_top_con",
+						"topckgen_top_cam",
+						"topckgen_top_camtg",
+						"topckgen_top_camtm";
+			assigned-clocks = <&topckgen CLK_TOP_CAM>;
+			assigned-clock-parents = <&topckgen CLK_TOP_UNIVPLL_D5>;
+		};
+
+		ccusys: syscon@17200000 {
+			compatible = "mediatek,mt8188-ccusys", "syscon";
+			reg = <0 0x17200000 0 0x1000>;
+			#clock-cells = <1>;
+		};
+
+		larb27: larb@17201000 {
+			compatible = "mediatek,mt8188-smi-larb";
+			reg = <0 0x17201000 0 0x1000>;
+			mediatek,larb-id = <SMI_L27_ID>;
+			mediatek,smi = <&vpp_smi_common>;
+			clocks = <&ccusys CLK_CCU_CCU0>,
+				 <&ccusys CLK_CCU_LARB27>;
+			clock-names = "apb", "smi";
+			power-domains = <&spm MT8188_POWER_DOMAIN_CAM_MAIN>;
+		};
+
+		video-codec@18000000 {
+			compatible = "mediatek,mt8188-vcodec-dec";
+			reg = <0 0x18000000 0 0x1000>,          /* VDEC_SYS */
+			      <0 0x18004000 0 0x1000>;      /* VDEC_RACING_CTRL */
+			mediatek,scp = <&scp>;
+			iommus = <&vpp_iommu M4U_PORT_L23_HW_VDEC_UFO_ENC_EXT>;
+			#address-cells = <1>;
+			#size-cells = <1>;
+			ranges = <0 0 0x18000000 0x26000>;
+			assigned-clocks = <&topckgen CLK_TOP_VDEC>;
+			assigned-clock-parents = <&topckgen CLK_TOP_UNIVPLL_D6>;
+
+			vcodec-lat@10000 {
+				compatible = "mediatek,mtk-vcodec-lat";
+				reg = <0x10000 0x800>;          /* VDEC_MISC */
+				interrupts = <GIC_SPI 708 IRQ_TYPE_LEVEL_HIGH 0>;
+				iommus = <&vpp_iommu M4U_PORT_L23_HW_VDEC_LAT0_VLD_EXT>,
+					 <&vpp_iommu M4U_PORT_L23_HW_VDEC_LAT0_VLD2_EXT>,
+					 <&vpp_iommu M4U_PORT_L23_HW_VDEC_LAT0_AVC_MV_EXT>,
+					 <&vpp_iommu M4U_PORT_L23_HW_VDEC_LAT0_PRED_RD_EXT>,
+					 <&vpp_iommu M4U_PORT_L23_HW_VDEC_LAT0_TILE_EXT>,
+					 <&vpp_iommu M4U_PORT_L23_HW_VDEC_LAT0_WDMA_EXT>,
+					 <&vpp_iommu M4U_PORT_L23_HW_VDEC_UFO_ENC_EXT>,
+					 <&vpp_iommu M4U_PORT_L23_HW_VDEC_UFO_ENC_EXT_C>,
+					 <&vpp_iommu M4U_PORT_L23_HW_VDEC_MC_EXT_C>;
+				clocks = <&vdecsys_soc CLK_VDEC1_SOC_VDEC>,
+					 <&vdecsys_soc CLK_VDEC1_SOC_LAT>;
+				clock-names = "vdec-soc-vdec", "vdec-soc-lat";
+				power-domains = <&spm MT8188_POWER_DOMAIN_VDEC0>;
+			};
+
+			vcodec-core@25000 {
+				compatible = "mediatek,mtk-vcodec-core";
+				reg = <0x25000 0x1000>;         /* VDEC_CORE_MISC */
+				interrupts = <GIC_SPI 707 IRQ_TYPE_LEVEL_HIGH 0>;
+				iommus = <&vdo_iommu M4U_PORT_L21_HW_VDEC_MC_EXT>,
+					 <&vdo_iommu M4U_PORT_L21_HW_VDEC_UFO_EXT>,
+					 <&vdo_iommu M4U_PORT_L21_HW_VDEC_PP_EXT>,
+					 <&vdo_iommu M4U_PORT_L21_HW_VDEC_PRED_RD_EXT>,
+					 <&vdo_iommu M4U_PORT_L21_HW_VDEC_PRED_WR_EXT>,
+					 <&vdo_iommu M4U_PORT_L21_HW_VDEC_PPWRAP_EXT>,
+					 <&vdo_iommu M4U_PORT_L21_HW_VDEC_TILE_EXT>,
+					 <&vdo_iommu M4U_PORT_L21_HW_VDEC_VLD_EXT>,
+					 <&vdo_iommu M4U_PORT_L21_HW_VDEC_VLD2_EXT>,
+					 <&vdo_iommu M4U_PORT_L21_HW_VDEC_AVC_MV_EXT>,
+					 <&vdo_iommu M4U_PORT_L21_HW_VDEC_UFO_EXT_C>;
+				clocks = <&vdecsys CLK_VDEC2_VDEC>,
+					 <&vdecsys CLK_VDEC2_LAT>;
+				clock-names = "vdec-vdec", "vdec-lat";
+				power-domains = <&spm MT8188_POWER_DOMAIN_VDEC1>;
+			};
+		};
+
+		larb23: larb@1800d000 {
+			compatible = "mediatek,mt8188-smi-larb";
+			reg = <0 0x1800d000 0 0x1000>;
+			mediatek,larb-id = <SMI_L23_ID>;
+			mediatek,smi = <&vpp_smi_common>;
+			clocks = <&vdecsys_soc CLK_VDEC1_SOC_LARB1>,
+				 <&vdecsys_soc CLK_VDEC1_SOC_LARB1>;
+			clock-names = "apb", "smi";
+			power-domains = <&spm MT8188_POWER_DOMAIN_VDEC0>;
+		};
+
+		vdecsys_soc: syscon@1800f000 {
+			compatible = "mediatek,mt8188-vdecsys-soc", "syscon";
+			reg = <0 0x1800f000 0 0x1000>;
+			#clock-cells = <1>;
+		};
+
+		larb21: larb@1802e000 {
+			compatible = "mediatek,mt8188-smi-larb";
+			reg = <0 0x1802e000 0 0x1000>;
+			mediatek,larb-id = <SMI_L21_ID>;
+			mediatek,smi = <&vdo_smi_common>;
+			clocks = <&vdecsys CLK_VDEC2_LARB1>,
+				 <&vdecsys CLK_VDEC2_LARB1>;
+			clock-names = "apb", "smi";
+			power-domains = <&spm MT8188_POWER_DOMAIN_VDEC1>;
+		};
+
+		vdecsys: syscon@1802f000 {
+			compatible = "mediatek,mt8188-vdecsys", "syscon";
+			reg = <0 0x1802f000 0 0x1000>;
+			#clock-cells = <1>;
+		};
+
+		vencsys: syscon@1a000000 {
+			compatible = "mediatek,mt8188-vencsys", "syscon";
+			reg = <0 0x1a000000 0 0x1000>;
+			#clock-cells = <1>;
+		};
+
+		larb19: larb@1a010000 {
+			compatible = "mediatek,mt8188-smi-larb";
+			reg = <0 0x1a010000 0 0x1000>;
+			mediatek,larb-id = <SMI_L19_ID>;
+			mediatek,smi = <&vdo_smi_common>;
+			clocks = <&vencsys CLK_VENC1_VENC>,
+				 <&vencsys CLK_VENC1_VENC>;
+			clock-names = "apb", "smi";
+			power-domains = <&spm MT8188_POWER_DOMAIN_VENC>;
+		};
+
+		venc: venc@1a020000 {
+			compatible = "mediatek,mt8188-vcodec-enc";
+			reg = <0 0x1a020000 0 0x10000>;
+			iommus = <&vdo_iommu M4U_PORT_L19_VENC_RCPU>,
+				 <&vdo_iommu M4U_PORT_L19_VENC_REC>,
+				 <&vdo_iommu M4U_PORT_L19_VENC_BSDMA>,
+				 <&vdo_iommu M4U_PORT_L19_VENC_SV_COMV>,
+				 <&vdo_iommu M4U_PORT_L19_VENC_RD_COMV>,
+				 <&vdo_iommu M4U_PORT_L19_VENC_CUR_LUMA>,
+				 <&vdo_iommu M4U_PORT_L19_VENC_CUR_CHROMA>,
+				 <&vdo_iommu M4U_PORT_L19_VENC_REF_LUMA>,
+				 <&vdo_iommu M4U_PORT_L19_VENC_REF_CHROMA>,
+				 <&vdo_iommu M4U_PORT_L19_VENC_SUB_W_LUMA>,
+				 <&vdo_iommu M4U_PORT_L19_VENC_SUB_R_LUMA>;
+			interrupts = <GIC_SPI 353 IRQ_TYPE_LEVEL_HIGH 0>;
+			mediatek,scp = <&scp>;
+			clocks = <&vencsys CLK_VENC1_VENC>;
+			clock-names = "venc_clk";
+			assigned-clocks = <&topckgen CLK_TOP_VENC>;
+			assigned-clock-parents = <&topckgen CLK_TOP_UNIVPLL_D4>;
+			power-domains = <&spm MT8188_POWER_DOMAIN_VENC>;
+			#address-cells = <2>;
+			#size-cells = <2>;
+		};
+
+		jpgenc@1a030000 {
+			compatible = "mediatek,mt8188-jpgenc",
+				     "mediatek,mtk-jpgenc";
+			reg = <0 0x1a030000 0 0x10000>;
+			mediatek,larb = <SMI_L19_ID>;
+			iommus = <&vdo_iommu M4U_PORT_L19_JPGENC_Y_RDMA>,
+				 <&vdo_iommu M4U_PORT_L19_JPGENC_C_RDMA>,
+				 <&vdo_iommu M4U_PORT_L19_JPGENC_Q_TABLE>,
+				 <&vdo_iommu M4U_PORT_L19_JPGENC_BSDMA>;
+			interrupts = <GIC_SPI 354 IRQ_TYPE_LEVEL_HIGH 0>;
+			clocks = <&vencsys CLK_VENC1_JPGENC>;
+			clock-names = "jpgenc";
+			power-domains = <&spm MT8188_POWER_DOMAIN_VENC>;
+		};
+
+		jpgdec@1a040000 {
+			compatible = "mediatek,mt8188-jpgdec",
+				     "mediatek,mt2701-jpgdec";
+			reg = <0 0x1a040000 0 0x10000>;/* JPGDEC_C0 */
+			mediatek,larb = <SMI_L19_ID>;
+			iommus = <&vdo_iommu M4U_PORT_L19_JPGDEC_WDMA_0>,
+				 <&vdo_iommu M4U_PORT_L19_JPGDEC_BSDMA_0>,
+				 <&vdo_iommu M4U_PORT_L19_JPGDEC_WDMA_1>,
+				 <&vdo_iommu M4U_PORT_L19_JPGDEC_BSDMA_1>,
+				 <&vdo_iommu M4U_PORT_L19_JPGDEC_HUFF_OFFSET_1>,
+				 <&vdo_iommu M4U_PORT_L19_JPGDEC_HUFF_OFFSET_0>;
+			interrupts = <GIC_SPI 355 IRQ_TYPE_LEVEL_HIGH 0>;
+			clocks = <&vencsys CLK_VENC1_LARB>,
+				 <&vencsys CLK_VENC1_JPGDEC>;
+			clock-names = "jpgdec-smi", "jpgdec";
+			power-domains = <&spm MT8188_POWER_DOMAIN_VDEC0>;
+		};
+
+		ovl0: ovl@1c000000 {
+			compatible = "mediatek,mt8188-disp-ovl",
+				     "mediatek,mt8192-disp-ovl";
+			reg = <0 0x1c000000 0 0x1000>;
+			interrupts = <GIC_SPI 636 IRQ_TYPE_LEVEL_HIGH 0>;
+			power-domains = <&spm MT8188_POWER_DOMAIN_VDOSYS0>;
+			clocks = <&vdosys0 CLK_VDO0_DISP_OVL0>;
+			iommus = <&vdo_iommu M4U_PORT_L0_DISP_OVL0_RDMA0>;
+			mediatek,gce-client-reg =
+				<&gce0 SUBSYS_1c00XXXX 0x0000 0x1000>;
+		};
+
+		rdma0: rdma@1c002000 {
+			compatible = "mediatek,mt8188-disp-rdma",
+				     "mediatek,mt8195-disp-rdma";
+			reg = <0 0x1c002000 0 0x1000>;
+			interrupts = <GIC_SPI 638 IRQ_TYPE_LEVEL_HIGH 0>;
+			power-domains = <&spm MT8188_POWER_DOMAIN_VDOSYS0>;
+			clocks = <&vdosys0 CLK_VDO0_DISP_RDMA0>;
+			iommus = <&vdo_iommu M4U_PORT_L1_DISP_RDMA0>;
+			mediatek,gce-client-reg =
+				<&gce0 SUBSYS_1c00XXXX 0x2000 0x1000>;
+		};
+
+		color0: color@1c003000 {
+			compatible = "mediatek,mt8188-disp-color",
+				     "mediatek,mt8173-disp-color";
+			reg = <0 0x1c003000 0 0x1000>;
+			interrupts = <GIC_SPI 639 IRQ_TYPE_LEVEL_HIGH 0>;
+			power-domains = <&spm MT8188_POWER_DOMAIN_VDOSYS0>;
+			clocks = <&vdosys0 CLK_VDO0_DISP_COLOR0>;
+			mediatek,gce-client-reg =
+				<&gce0 SUBSYS_1c00XXXX 0x3000 0x1000>;
+		};
+
+		ccorr0: ccorr@1c004000 {
+			compatible = "mediatek,mt8188-disp-ccorr",
+				     "mediatek,mt8192-disp-ccorr";
+			reg = <0 0x1c004000 0 0x1000>;
+			interrupts = <GIC_SPI 640 IRQ_TYPE_LEVEL_HIGH 0>;
+			power-domains = <&spm MT8188_POWER_DOMAIN_VDOSYS0>;
+			clocks = <&vdosys0 CLK_VDO0_DISP_CCORR0>;
+			mediatek,gce-client-reg =
+				<&gce0 SUBSYS_1c00XXXX 0x4000 0x1000>;
+		};
+
+		aal0: aal@1c005000 {
+			compatible = "mediatek,mt8188-disp-aal",
+				     "mediatek,mt8173-disp-aal";
+			reg = <0 0x1c005000 0 0x1000>;
+			interrupts = <GIC_SPI 641 IRQ_TYPE_LEVEL_HIGH 0>;
+			power-domains = <&spm MT8188_POWER_DOMAIN_VDOSYS0>;
+			clocks = <&vdosys0 CLK_VDO0_DISP_AAL0>;
+			mediatek,gce-client-reg =
+				<&gce0 SUBSYS_1c00XXXX 0x5000 0x1000>;
+		};
+
+		gamma0: gamma@1c006000 {
+			compatible = "mediatek,mt8188-disp-gamma",
+				     "mediatek,mt8173-disp-gamma";
+			reg = <0 0x1c006000 0 0x1000>;
+			interrupts = <GIC_SPI 642 IRQ_TYPE_LEVEL_HIGH 0>;
+			power-domains = <&spm MT8188_POWER_DOMAIN_VDOSYS0>;
+			clocks = <&vdosys0 CLK_VDO0_DISP_GAMMA0>;
+			mediatek,gce-client-reg =
+				<&gce0 SUBSYS_1c00XXXX 0x6000 0x1000>;
+		};
+
+		dither0: dither@1c007000 {
+			compatible = "mediatek,mt8188-disp-dither",
+				     "mediatek,mt8183-disp-dither";
+			reg = <0 0x1c007000 0 0x1000>;
+			interrupts = <GIC_SPI 643 IRQ_TYPE_LEVEL_HIGH 0>;
+			power-domains = <&spm MT8188_POWER_DOMAIN_VDOSYS0>;
+			clocks = <&vdosys0 CLK_VDO0_DISP_DITHER0>;
+			mediatek,gce-client-reg =
+				<&gce0 SUBSYS_1c00XXXX 0x7000 0x1000>;
+		};
+
+		disp_dsi0: dsi@1c008000 {
+			compatible = "mediatek,mt8188-dsi";
+			reg = <0 0x1c008000 0 0x1000>, <0 0x1c01d000 0 0x1000>;
+			interrupts = <GIC_SPI 644 IRQ_TYPE_LEVEL_HIGH 0>;
+			power-domains = <&spm MT8188_POWER_DOMAIN_VDOSYS0>;
+			clocks = <&vdosys0 CLK_VDO0_DSI0>,
+				 <&vdosys0 CLK_VDO0_DSI0_DSI>,
+				 <&mipi_tx_config0>;
+			clock-names = "engine", "digital", "hs";
+			phys = <&mipi_tx_config0>;
+			phy-names = "dphy";
+			resets = <&vdosys0 MT8188_VDO0_RST_DSI0>;
+			status = "disabled";
+		};
+
+		dp_intf0: dp-intf@1c015000 {
+			compatible = "mediatek,mt8188-dp-intf";
+			reg = <0 0x1c015000 0 0x1000>;
+			interrupts = <GIC_SPI 657 IRQ_TYPE_LEVEL_HIGH 0>;
+			clocks = <&vdosys0 CLK_VDO0_DP_INTF0>,
+				 <&vdosys0 CLK_VDO0_DP_INTF0_DP_INTF>,
+				 <&apmixedsys CLK_APMIXED_TVDPLL1>;
+			clock-names = "engine", "pixel", "pll";
+			status = "disabled";
+		};
+
+		mutex: mutex@1c016000 {
+			compatible = "mediatek,mt8188-disp-mutex";
+			reg = <0 0x1c016000 0 0x1000>;
+			reg-names = "vdo0_mutex";
+			interrupts = <GIC_SPI 658 IRQ_TYPE_LEVEL_HIGH 0>;
+			power-domains = <&spm MT8188_POWER_DOMAIN_VDOSYS0>;
+			clocks = <&vdosys0 CLK_VDO0_DISP_MUTEX0>;
+			clock-names = "vdo0_mutex";
+			mediatek,gce-events =
+				<CMDQ_EVENT_VDO0_DISP_STREAM_DONE_0>;
+		};
+
+		postmask0: postmask@1c01a000 {
+			compatible = "mediatek,mt8188-disp-postmask",
+				     "mediatek,mt8192-disp-postmask";
+			reg = <0 0x1c01a000 0 0x1000>;
+			interrupts = <GIC_SPI 661 IRQ_TYPE_LEVEL_HIGH 0>;
+			clocks = <&vdosys0 CLK_VDO0_DISP_POSTMASK0>;
+			mediatek,gce-client-reg =
+				<&gce0 SUBSYS_1c01XXXX 0xa000 0x1000>;
+		};
+
+		vdosys0: syscon@1c01d000 {
+			compatible = "mediatek,mt8188-vdosys0", "syscon";
+			reg = <0 0x1c01d000 0 0x1000>;
+			mboxes = <&gce0 0 CMDQ_THR_PRIO_4>;
+			#clock-cells = <1>;
+			#reset-cells = <1>;
+			mediatek,gce-events =
+				<CMDQ_EVENT_VDO0_DISP_STREAM_DONE_0>;
+		};
+
+		larb0: larb@1c022000 {
+			compatible = "mediatek,mt8188-smi-larb";
+			reg = <0 0x1c022000 0 0x1000>;
+			mediatek,larb-id = <SMI_L0_ID>;
+			mediatek,smi = <&vdo_smi_common>;
+			clocks = <&vdosys0 CLK_VDO0_SMI_LARB>,
+				 <&vdosys0 CLK_VDO0_SMI_LARB>;
+			clock-names = "apb", "smi";
+			power-domains = <&spm MT8188_POWER_DOMAIN_VDOSYS0>;
+		};
+
+		larb1: larb@1c023000 {
+			compatible = "mediatek,mt8188-smi-larb";
+			reg = <0 0x1c023000 0 0x1000>;
+			mediatek,larb-id = <SMI_L1_ID>;
+			mediatek,smi = <&vpp_smi_common>;
+			clocks = <&vdosys0 CLK_VDO0_SMI_LARB>,
+				 <&vdosys0 CLK_VDO0_SMI_LARB>;
+			clock-names = "apb", "smi";
+			power-domains = <&spm MT8188_POWER_DOMAIN_VDOSYS0>;
+		};
+
+		vdo_smi_common: smi@1c024000 {
+			compatible = "mediatek,mt8188-smi-common-vdo";
+			reg = <0 0x1c024000 0 0x1000>;
+			clocks = <&vdosys0 CLK_VDO0_SMI_COMMON>,
+				 <&vdosys0 CLK_VDO0_SMI_GALS>;
+			clock-names = "apb", "smi";
+			power-domains = <&spm MT8188_POWER_DOMAIN_VDOSYS0>;
+		};
+
+		vdo_iommu: iommu@1c028000 {
+			compatible = "mediatek,mt8188-iommu-vdo";
+			reg = <0 0x1c028000 0 0x5000>;
+			mediatek,larbs = <&larb0 &larb2 &larb5 &larb9 &larb10
+					  &larb11a &larb11c &larb13 &larb16b
+					  &larb17b &larb19 &larb21>;
+			interrupts = <GIC_SPI 673 IRQ_TYPE_LEVEL_HIGH 0>,
+				     <GIC_SPI 674 IRQ_TYPE_LEVEL_HIGH 0>,
+				     <GIC_SPI 675 IRQ_TYPE_LEVEL_HIGH 0>,
+				     <GIC_SPI 676 IRQ_TYPE_LEVEL_HIGH 0>,
+				     <GIC_SPI 677 IRQ_TYPE_LEVEL_HIGH 0>;
+			clocks = <&vdosys0 CLK_VDO0_SMI_IOMMU>;
+			clock-names = "bclk";
+			#iommu-cells = <1>;
+			power-domains = <&spm MT8188_POWER_DOMAIN_VDOSYS0>;
+		};
+
+		vdosys1: syscon@1c100000 {
+			compatible = "mediatek,mt8188-vdosys1", "syscon";
+			reg = <0 0x1c100000 0 0x1000>;
+			mboxes = <&gce0 1 CMDQ_THR_PRIO_4>;
+			mediatek,gce-client-reg =
+				<&gce0 SUBSYS_1c10XXXX 0x0000 0x1000>;
+			#clock-cells = <1>;
+			#reset-cells = <1>;
+		};
+
+		mutex1: mutex@1c101000 {
+			compatible = "mediatek,mt8188-disp-mutex";
+			reg = <0 0x1c101000 0 0x1000>;
+			reg-names = "vdo1_mutex";
+			interrupts = <GIC_SPI 494 IRQ_TYPE_LEVEL_HIGH 0>;
+			power-domains = <&spm MT8188_POWER_DOMAIN_VDOSYS1>;
+			clocks = <&vdosys1 CLK_VDO1_DISP_MUTEX>;
+			clock-names = "vdo1_mutex";
+			mediatek,gce-events =
+				<CMDQ_EVENT_VDO1_STREAM_DONE_ENG_0>;
+		};
+
+		larb2: larb@1c102000 {
+			compatible = "mediatek,mt8188-smi-larb";
+			reg = <0 0x1c102000 0 0x1000>;
+			mediatek,larb-id = <SMI_L2_ID>;
+			mediatek,smi = <&vdo_smi_common>;
+			clocks = <&vdosys1 CLK_VDO1_SMI_LARB2>,
+				 <&vdosys1 CLK_VDO1_SMI_LARB2>;
+			clock-names = "apb", "smi";
+			power-domains = <&spm MT8188_POWER_DOMAIN_VDOSYS1>;
+		};
+
+		larb3: larb@1c103000 {
+			compatible = "mediatek,mt8188-smi-larb";
+			reg = <0 0x1c103000 0 0x1000>;
+			mediatek,larb-id = <SMI_L3_ID>;
+			mediatek,smi = <&vpp_smi_common>;
+			clocks = <&vdosys1 CLK_VDO1_SMI_LARB3>,
+				 <&vdosys1 CLK_VDO1_SMI_LARB3>;
+			clock-names = "apb", "smi";
+			power-domains = <&spm MT8188_POWER_DOMAIN_VDOSYS1>;
+		};
+
+		vdo1_rdma0: mdp-rdma@1c104000 {
+			compatible = "mediatek,mt8188-vdo1-rdma", "mediatek,mt8195-vdo1-rdma";
+			reg = <0 0x1c104000 0 0x1000>;
+			interrupts = <GIC_SPI 495 IRQ_TYPE_LEVEL_HIGH 0>;
+			clocks = <&vdosys1 CLK_VDO1_MDP_RDMA0>;
+			power-domains = <&spm MT8188_POWER_DOMAIN_VDOSYS1>;
+			iommus = <&vdo_iommu M4U_PORT_L2_MDP_RDMA0>;
+			mediatek,gce-client-reg =
+				<&gce0 SUBSYS_1c10XXXX 0x4000 0x1000>;
+		};
+
+		vdo1_rdma1: mdp-rdma@1c105000 {
+			compatible = "mediatek,mt8188-vdo1-rdma", "mediatek,mt8195-vdo1-rdma";
+			reg = <0 0x1c105000 0 0x1000>;
+			interrupts = <GIC_SPI 496 IRQ_TYPE_LEVEL_HIGH 0>;
+			clocks = <&vdosys1 CLK_VDO1_MDP_RDMA1>;
+			power-domains = <&spm MT8188_POWER_DOMAIN_VDOSYS1>;
+			iommus = <&vpp_iommu M4U_PORT_L3_MDP_RDMA1>;
+			mediatek,gce-client-reg =
+				<&gce0 SUBSYS_1c10XXXX 0x5000 0x1000>;
+		};
+
+		vdo1_rdma2: mdp-rdma@1c106000 {
+			compatible = "mediatek,mt8188-vdo1-rdma", "mediatek,mt8195-vdo1-rdma";
+			reg = <0 0x1c106000 0 0x1000>;
+			interrupts = <GIC_SPI 497 IRQ_TYPE_LEVEL_HIGH 0>;
+			clocks = <&vdosys1 CLK_VDO1_MDP_RDMA2>;
+			power-domains = <&spm MT8188_POWER_DOMAIN_VDOSYS1>;
+			iommus = <&vdo_iommu M4U_PORT_L2_MDP_RDMA2>;
+			mediatek,gce-client-reg =
+				<&gce0 SUBSYS_1c10XXXX 0x6000 0x1000>;
+		};
+
+		vdo1_rdma3: mdp-rdma@1c107000 {
+			compatible = "mediatek,mt8188-vdo1-rdma", "mediatek,mt8195-vdo1-rdma";
+			reg = <0 0x1c107000 0 0x1000>;
+			interrupts = <GIC_SPI 498 IRQ_TYPE_LEVEL_HIGH 0>;
+			clocks = <&vdosys1 CLK_VDO1_MDP_RDMA3>;
+			power-domains = <&spm MT8188_POWER_DOMAIN_VDOSYS1>;
+			iommus = <&vpp_iommu M4U_PORT_L3_MDP_RDMA3>;
+			mediatek,gce-client-reg =
+				<&gce0 SUBSYS_1c10XXXX 0x7000 0x1000>;
+		};
+
+		vdo1_rdma4: mdp-rdma@1c108000 {
+			compatible = "mediatek,mt8188-vdo1-rdma", "mediatek,mt8195-vdo1-rdma";
+			reg = <0 0x1c108000 0 0x1000>;
+			interrupts = <GIC_SPI 499 IRQ_TYPE_LEVEL_HIGH 0>;
+			clocks = <&vdosys1 CLK_VDO1_MDP_RDMA4>;
+			power-domains = <&spm MT8188_POWER_DOMAIN_VDOSYS1>;
+			iommus = <&vdo_iommu M4U_PORT_L2_MDP_RDMA4>;
+			mediatek,gce-client-reg =
+				<&gce0 SUBSYS_1c10XXXX 0x8000 0x1000>;
+		};
+
+		vdo1_rdma5: mdp-rdma@1c109000 {
+			compatible = "mediatek,mt8188-vdo1-rdma", "mediatek,mt8195-vdo1-rdma";
+			reg = <0 0x1c109000 0 0x1000>;
+			interrupts = <GIC_SPI 500 IRQ_TYPE_LEVEL_HIGH 0>;
+			clocks = <&vdosys1 CLK_VDO1_MDP_RDMA5>;
+			power-domains = <&spm MT8188_POWER_DOMAIN_VDOSYS1>;
+			iommus = <&vpp_iommu M4U_PORT_L3_MDP_RDMA5>;
+			mediatek,gce-client-reg =
+				<&gce0 SUBSYS_1c10XXXX 0x9000 0x1000>;
+		};
+
+		vdo1_rdma6: mdp-rdma@1c10a000 {
+			compatible = "mediatek,mt8188-vdo1-rdma", "mediatek,mt8195-vdo1-rdma";
+			reg = <0 0x1c10a000 0 0x1000>;
+			interrupts = <GIC_SPI 501 IRQ_TYPE_LEVEL_HIGH 0>;
+			clocks = <&vdosys1 CLK_VDO1_MDP_RDMA6>;
+			power-domains = <&spm MT8188_POWER_DOMAIN_VDOSYS1>;
+			iommus = <&vdo_iommu M4U_PORT_L2_MDP_RDMA6>;
+			mediatek,gce-client-reg =
+				<&gce0 SUBSYS_1c10XXXX 0xa000 0x1000>;
+		};
+
+		vdo1_rdma7: mdp-rdma@1c10b000 {
+			compatible = "mediatek,mt8188-vdo1-rdma", "mediatek,mt8195-vdo1-rdma";
+			reg = <0 0x1c10b000 0 0x1000>;
+			interrupts = <GIC_SPI 502 IRQ_TYPE_LEVEL_HIGH 0>;
+			clocks = <&vdosys1 CLK_VDO1_MDP_RDMA7>;
+			power-domains = <&spm MT8188_POWER_DOMAIN_VDOSYS1>;
+			iommus = <&vpp_iommu M4U_PORT_L3_MDP_RDMA7>;
+			mediatek,gce-client-reg =
+				<&gce0 SUBSYS_1c10XXXX 0xb000 0x1000>;
+		};
+
+		merge1: merge@1c10c000 {
+			compatible = "mediatek,mt8188-disp-merge", "mediatek,mt8195-disp-merge";
+			reg = <0 0x1c10c000 0 0x1000>;
+			interrupts = <GIC_SPI 503 IRQ_TYPE_LEVEL_HIGH 0>;
+			clocks = <&vdosys1 CLK_VDO1_VPP_MERGE0>,
+				 <&vdosys1 CLK_VDO1_MERGE0_DL_ASYNC>;
+			clock-names = "merge","merge_async";
+			power-domains = <&spm MT8188_POWER_DOMAIN_VDOSYS1>;
+			mediatek,gce-client-reg =
+				<&gce0 SUBSYS_1c10XXXX 0xc000 0x1000>;
+			mediatek,merge-mute = <1>;
+			resets = <&vdosys1 MT8188_VDO1_RST_MERGE0_DL_ASYNC>;
+		};
+
+		merge2: merge@1c10d000 {
+			compatible = "mediatek,mt8188-disp-merge", "mediatek,mt8195-disp-merge";
+			reg = <0 0x1c10d000 0 0x1000>;
+			interrupts = <GIC_SPI 504 IRQ_TYPE_LEVEL_HIGH 0>;
+			clocks = <&vdosys1 CLK_VDO1_VPP_MERGE1>,
+				 <&vdosys1 CLK_VDO1_MERGE1_DL_ASYNC>;
+			clock-names = "merge","merge_async";
+			power-domains = <&spm MT8188_POWER_DOMAIN_VDOSYS1>;
+			mediatek,gce-client-reg =
+				<&gce0 SUBSYS_1c10XXXX 0xd000 0x1000>;
+			mediatek,merge-mute = <1>;
+			resets = <&vdosys1 MT8188_VDO1_RST_MERGE1_DL_ASYNC>;
+		};
+
+		merge3: merge@1c10e000 {
+			compatible = "mediatek,mt8188-disp-merge", "mediatek,mt8195-disp-merge";
+			reg = <0 0x1c10e000 0 0x1000>;
+			interrupts = <GIC_SPI 505 IRQ_TYPE_LEVEL_HIGH 0>;
+			clocks = <&vdosys1 CLK_VDO1_VPP_MERGE2>,
+				 <&vdosys1 CLK_VDO1_MERGE2_DL_ASYNC>;
+			clock-names = "merge","merge_async";
+			power-domains = <&spm MT8188_POWER_DOMAIN_VDOSYS1>;
+			mediatek,gce-client-reg =
+				<&gce0 SUBSYS_1c10XXXX 0xe000 0x1000>;
+			mediatek,merge-mute = <1>;
+			resets = <&vdosys1 MT8188_VDO1_RST_MERGE2_DL_ASYNC>;
+		};
+
+		merge4: merge@1c10f000 {
+			compatible = "mediatek,mt8188-disp-merge", "mediatek,mt8195-disp-merge";
+			reg = <0 0x1c10f000 0 0x1000>;
+			interrupts = <GIC_SPI 506 IRQ_TYPE_LEVEL_HIGH 0>;
+			clocks = <&vdosys1 CLK_VDO1_VPP_MERGE3>,
+				 <&vdosys1 CLK_VDO1_MERGE3_DL_ASYNC>;
+			clock-names = "merge","merge_async";
+			power-domains = <&spm MT8188_POWER_DOMAIN_VDOSYS1>;
+			mediatek,gce-client-reg =
+				<&gce0 SUBSYS_1c10XXXX 0xf000 0x1000>;
+			mediatek,merge-mute = <1>;
+			resets = <&vdosys1 MT8188_VDO1_RST_MERGE3_DL_ASYNC>;
+		};
+
+		merge5: merge@1c110000 {
+			compatible = "mediatek,mt8188-disp-merge", "mediatek,mt8195-disp-merge";
+			reg = <0 0x1c110000 0 0x1000>;
+			interrupts = <GIC_SPI 507 IRQ_TYPE_LEVEL_HIGH 0>;
+			clocks = <&vdosys1 CLK_VDO1_VPP_MERGE4>,
+				 <&vdosys1 CLK_VDO1_MERGE4_DL_ASYNC>;
+			clock-names = "merge","merge_async";
+			power-domains = <&spm MT8188_POWER_DOMAIN_VDOSYS1>;
+			mediatek,gce-client-reg =
+				<&gce0 SUBSYS_1c11XXXX 0x0000 0x1000>;
+			mediatek,merge-fifo-en = <1>;
+			resets = <&vdosys1 MT8188_VDO1_RST_MERGE4_DL_ASYNC>;
+		};
+
+		dp_intf1: dp-intf@1c113000 {
+			compatible = "mediatek,mt8188-dp-intf";
+			reg = <0 0x1c113000 0 0x1000>;
+			interrupts = <GIC_SPI 513 IRQ_TYPE_LEVEL_HIGH 0>;
+			power-domains = <&spm MT8188_POWER_DOMAIN_VDOSYS1>;
+			clocks = <&vdosys1 CLK_VDO1_DP_INTF0_MMCK>,
+				 <&vdosys1 CLK_VDO1_DPINTF>,
+				 <&apmixedsys CLK_APMIXED_TVDPLL2>;
+			clock-names = "engine", "pixel", "pll";
+			status = "disabled";
+		};
+
+		ethdr0: ethdr@1c114000 {
+			compatible = "mediatek,mt8188-disp-ethdr", "mediatek,mt8195-disp-ethdr";
+			reg = <0 0x1c114000 0 0x1000>,
+			      <0 0x1c115000 0 0x1000>,
+			      <0 0x1c117000 0 0x1000>,
+			      <0 0x1c119000 0 0x1000>,
+			      <0 0x1c11A000 0 0x1000>,
+			      <0 0x1c11B000 0 0x1000>,
+			      <0 0x1c11C000 0 0x1000>;
+			reg-names = "mixer", "vdo_fe0", "vdo_fe1",
+				    "gfx_fe0", "gfx_fe1", "vdo_be", "adl_ds";
+			mediatek,gce-client-reg =
+				<&gce0 SUBSYS_1c11XXXX 0x4000 0x1000>,
+				<&gce0 SUBSYS_1c11XXXX 0x5000 0x1000>,
+				<&gce0 SUBSYS_1c11XXXX 0x7000 0x1000>,
+				<&gce0 SUBSYS_1c11XXXX 0x9000 0x1000>,
+				<&gce0 SUBSYS_1c11XXXX 0xA000 0x1000>,
+				<&gce0 SUBSYS_1c11XXXX 0xB000 0x1000>,
+				<&gce0 SUBSYS_1c11XXXX 0xC000 0x1000>;
+			clocks = <&vdosys1 CLK_VDO1_DISP_MIXER>,
+				 <&vdosys1 CLK_VDO1_HDR_VDO_FE0>,
+				 <&vdosys1 CLK_VDO1_HDR_VDO_FE1>,
+				 <&vdosys1 CLK_VDO1_HDR_GFX_FE0>,
+				 <&vdosys1 CLK_VDO1_HDR_GFX_FE1>,
+				 <&vdosys1 CLK_VDO1_HDR_VDO_BE>,
+				 <&vdosys1 CLK_VDO1_26M_SLOW>,
+				 <&vdosys1 CLK_VDO1_HDR_VDO_FE0_DL_ASYNC>,
+				 <&vdosys1 CLK_VDO1_HDR_VDO_FE1_DL_ASYNC>,
+				 <&vdosys1 CLK_VDO1_HDR_GFX_FE0_DL_ASYNC>,
+				 <&vdosys1 CLK_VDO1_HDR_GFX_FE1_DL_ASYNC>,
+				 <&vdosys1 CLK_VDO1_HDR_VDO_BE_DL_ASYNC>,
+				 <&topckgen CLK_TOP_ETHDR>;
+			clock-names = "mixer", "vdo_fe0", "vdo_fe1",
+				      "gfx_fe0", "gfx_fe1", "vdo_be",
+				      "adl_ds", "vdo_fe0_async", "vdo_fe1_async",
+				      "gfx_fe0_async", "gfx_fe1_async","vdo_be_async",
+				      "ethdr_top";
+			power-domains = <&spm MT8188_POWER_DOMAIN_VDOSYS1>;
+			iommus = <&vpp_iommu M4U_PORT_L3_HDR_DS_SMI>,
+				 <&vpp_iommu M4U_PORT_L3_HDR_ADL_SMI>;
+			interrupts = <GIC_SPI 566 IRQ_TYPE_LEVEL_HIGH 0>;
+			resets = <&vdosys1 MT8188_VDO1_RST_HDR_VDO_FE0_DL_ASYNC>,
+				 <&vdosys1 MT8188_VDO1_RST_HDR_VDO_FE1_DL_ASYNC>,
+				 <&vdosys1 MT8188_VDO1_RST_HDR_GFX_FE0_DL_ASYNC>,
+				 <&vdosys1 MT8188_VDO1_RST_HDR_GFX_FE1_DL_ASYNC>,
+				 <&vdosys1 MT8188_VDO1_RST_HDR_VDO_BE_DL_ASYNC>;
+		};
+
+		padding0: padding@1c11d000 {
+			compatible = "mediatek,mt8188-padding";
+			reg = <0 0x1c11d000 0 0x1000>;
+			clocks = <&vdosys1 CLK_VDO1_PADDING0>;
+			power-domains = <&spm MT8188_POWER_DOMAIN_VDOSYS1>;
+			mediatek,gce-client-reg =
+				<&gce0 SUBSYS_1c11XXXX 0xd000 0x1000>;
+		};
+
+		padding1: padding@1c11e000 {
+			compatible = "mediatek,mt8188-padding";
+			reg = <0 0x1c11e000 0 0x1000>;
+			clocks = <&vdosys1 CLK_VDO1_PADDING1>;
+			power-domains = <&spm MT8188_POWER_DOMAIN_VDOSYS1>;
+			mediatek,gce-client-reg =
+				<&gce0 SUBSYS_1c11XXXX 0xe000 0x1000>;
+		};
+
+		padding2: padding@1c11f000 {
+			compatible = "mediatek,mt8188-padding";
+			reg = <0 0x1c11f000 0 0x1000>;
+			clocks = <&vdosys1 CLK_VDO1_PADDING2>;
+			power-domains = <&spm MT8188_POWER_DOMAIN_VDOSYS1>;
+			mediatek,gce-client-reg =
+				<&gce0 SUBSYS_1c11XXXX 0xf000 0x1000>;
+		};
+
+		padding3: padding@1c120000 {
+			compatible = "mediatek,mt8188-padding";
+			reg = <0 0x1c120000 0 0x1000>;
+			clocks = <&vdosys1 CLK_VDO1_PADDING3>;
+			power-domains = <&spm MT8188_POWER_DOMAIN_VDOSYS1>;
+			mediatek,gce-client-reg =
+				<&gce0 SUBSYS_1c12XXXX 0x0000 0x1000>;
+		};
+
+		padding4: padding@1c121000 {
+			compatible = "mediatek,mt8188-padding";
+			reg = <0 0x1c121000 0 0x1000>;
+			clocks = <&vdosys1 CLK_VDO1_PADDING4>;
+			power-domains = <&spm MT8188_POWER_DOMAIN_VDOSYS1>;
+			mediatek,gce-client-reg =
+				<&gce0 SUBSYS_1c12XXXX 0x1000 0x1000>;
+		};
+
+		padding5: padding@1c122000 {
+			compatible = "mediatek,mt8188-padding";
+			reg = <0 0x1c122000 0 0x1000>;
+			clocks = <&vdosys1 CLK_VDO1_PADDING5>;
+			power-domains = <&spm MT8188_POWER_DOMAIN_VDOSYS1>;
+			mediatek,gce-client-reg =
+				<&gce0 SUBSYS_1c12XXXX 0x2000 0x1000>;
+		};
+
+		padding6: padding@1c123000 {
+			compatible = "mediatek,mt8188-padding";
+			reg = <0 0x1c123000 0 0x1000>;
+			clocks = <&vdosys1 CLK_VDO1_PADDING6>;
+			power-domains = <&spm MT8188_POWER_DOMAIN_VDOSYS1>;
+			mediatek,gce-client-reg =
+				<&gce0 SUBSYS_1c12XXXX 0x3000 0x1000>;
+		};
+
+		padding7: padding@1c124000 {
+			compatible = "mediatek,mt8188-padding";
+			reg = <0 0x1c124000 0 0x1000>;
+			clocks = <&vdosys1 CLK_VDO1_PADDING7>;
+			power-domains = <&spm MT8188_POWER_DOMAIN_VDOSYS1>;
+			mediatek,gce-client-reg =
+				<&gce0 SUBSYS_1c12XXXX 0x4000 0x1000>;
+		};
+
+		edp_tx: edp-tx@1c500000 {
+			compatible = "mediatek,mt8188-edp-tx";
+			reg = <0 0x1c500000 0 0x8000>;
+			nvmem-cells = <&dp_calibration>;
+			nvmem-cell-names = "dp_calibration_data";
+			power-domains = <&spm MT8188_POWER_DOMAIN_EDP_TX>;
+			interrupts = <GIC_SPI 676 IRQ_TYPE_LEVEL_HIGH 0>;
+			max-linkrate-mhz = <8100>;
+			status = "disabled";
+		};
+
+		dp_tx: dp-tx@1c600000 {
+			#sound-dai-cells = <0>;
+			compatible = "mediatek,mt8188-dp-tx";
+			reg = <0 0x1c600000 0 0x8000>;
+			max-lanes = <4>;
+			max-linkrate = <5400>;
+			nvmem-cells = <&dp_calibration>;
+			nvmem-cell-names = "dp_calibration_data";
+			power-domains = <&spm MT8188_POWER_DOMAIN_DP_TX>;
+			interrupts = <GIC_SPI 458 IRQ_TYPE_LEVEL_HIGH 0>;
+			max-linkrate-mhz = <5400>;
+			status = "disabled";
+		};
+
+		bring-up {
+			compatible = "mediatek,clk-bring-up";
+			clocks = <&infracfg_ao CLK_INFRA_AO_UART0>;
+		};
+	};
+};
diff --git a/arch/arm64/boot/dts/mediatek/mt8188_geralt_camera_v4l2.dtsi b/arch/arm64/boot/dts/mediatek/mt8188_geralt_camera_v4l2.dtsi
new file mode 100755
index 0000000000000000000000000000000000000000..aa8591c84ecbeeb21e86c8b927a4f9eb52c630b4
--- /dev/null
+++ b/arch/arm64/boot/dts/mediatek/mt8188_geralt_camera_v4l2.dtsi
@@ -0,0 +1,277 @@
+// SPDX-License-Identifier: GPL-2.0
+/* Copyright (c) 2020 MediaTek Inc. */
+
+//#include <dt-bindings/clock/mt8188-clk.h>
+#include <dt-bindings/gpio/gpio.h>
+
+#define HI1339_GT9768  1
+#define GC08A3_GT9769  0
+
+
+&seninf_top {
+		seninf_csi_port_1: seninf_csi_port_1 {
+			compatible = "mediatek,seninf";
+            hs_trail_parameter = <0x28>;
+			csi-port = "1";
+			port {
+				seninf_csi_port_1_in_1: endpoint {
+					data-lanes = <1 2 3 4>;
+					link-frequencies = /bits/ 64 <336000000 207000000>;
+					remote-endpoint = <&sensor1_out_1>;
+				};
+				seninf_csi_port_1_in_2: endpoint@2 {
+					data-lanes = <1 4>;
+					link-frequencies = /bits/ 64 <448000000 224000000>;
+					remote-endpoint = <&sensor1_out_2>;
+				};
+			};
+		};
+		seninf_csi_port_0: seninf_csi_port_0 {
+			compatible = "mediatek,seninf";
+			csi-port = "0";
+			port {
+				seninf_csi_port_0_in_1: endpoint {
+					data-lanes = <1 2 3 4>;
+					link-frequencies = /bits/ 64 <1440000000 624000000>;
+					remote-endpoint = <&sensor0_out_1>;
+				};
+				seninf_csi_port_0_in_2: endpoint@2 {
+					data-lanes = <1 2 3 4>;
+					link-frequencies = /bits/ 64 <336000000 207000000>;
+					remote-endpoint = <&sensor0_out_2>;
+				};
+			};
+		};
+};
+
+/*up stream*/
+&pio {
+	camera_pins_cam1: cam1@1 {
+		pins_cmd_dat {
+			pinmux = <PINMUX_GPIO23__FUNC_O_CMMCLK1>;
+			drive-strength = <MTK_DRIVE_2mA>;
+		};
+		pins_reset {
+			pinmux = <PINMUX_GPIO21__FUNC_B_GPIO21>;
+			output-low;
+		};
+		pins_dvdd_en {
+			pinmux = <PINMUX_GPIO140__FUNC_B_GPIO140>;
+			output-high;
+		};
+	};
+
+	camera_pins_cam0: cam0@0 {
+		pins_cmd_dat {
+			pinmux = <PINMUX_GPIO22__FUNC_O_CMMCLK0>;
+			drive-strength = <MTK_DRIVE_2mA>;
+		};
+		pins_reset {
+			pinmux = <PINMUX_GPIO19__FUNC_B_GPIO19>;
+			output-low;
+		};
+		pins_dvdd_en {
+			pinmux = <PINMUX_GPIO142__FUNC_B_GPIO142>;
+			output-high;
+		};
+	};
+};
+
+&mt6359_vibr_ldo_reg {
+	regulator-min-microvolt = <2800000>;
+	regulator-max-microvolt = <2800000>;
+};
+
+&mt6359_vrf18_ldo_reg {
+	regulator-always-on;
+};
+
+&i2c6 {
+	status = "okay";
+	clock-frequency = <400000>;
+
+    //================================================
+#if HI1339_GT9768
+	camera_main_af_1: camera_main_af@1 {
+		compatible = "giantec,gt9768";
+		reg = <0x0c>;
+
+		vdd-supply = <&mt6359_vibr_ldo_reg>;
+	};
+#endif
+
+	sensor0@1 {
+		status = "okay";
+		compatible = "Hynix,hi1339";
+		reg = <0x20>;
+
+		clocks = <&topckgen CLK_TOP_CAMTG>,
+			 <&topckgen CLK_TOP_UNIVPLL_192M_D8>;
+		clock-names = "xvclk", "freq_mux";
+		clock-frequency = <24000000>;
+
+		assigned-clocks = <&topckgen CLK_TOP_CAMTG>,
+				  <&topckgen CLK_TOP_UNIVPLL_192M_D8>;
+		assigned-clock-parents = <&topckgen CLK_TOP_UNIVPLL_192M_D8>;
+		assigned-clock-rates = <0>, <24000000>;
+
+		enable-gpios = <&pio 19 GPIO_ACTIVE_HIGH>;
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&camera_pins_cam0>;
+
+		/*dovdd-supply = <&mt6359_vrf18_ldo_reg>;*/
+		avdd-supply = <&mt6359_vfe28_ldo_reg>;
+
+#if HI1339_GT9768
+        lens-focus = <&camera_main_af_1>;
+#endif
+
+		port {
+			sensor0_out_1: endpoint {
+				data-lanes = <1 2 3 4>;
+				link-frequencies = /bits/ 64 <1440000000 624000000>;
+				remote-endpoint = <&seninf_csi_port_0_in_1>;
+			};
+		};
+	};
+    //================================================
+
+    //================================================
+#if GC08A3_GT9769
+	camera_main_af_2: camera_main_af@2 {
+		compatible = "giantec,gt9769";
+		reg = <0x0c>;
+
+		vdd-supply = <&mt6359_vibr_ldo_reg>;
+	};
+#endif
+
+	sensor0@2 {
+		status = "okay";
+		compatible = "GalaxyCore,gc08a3";
+		reg = <0x31>;
+
+		clocks = <&topckgen CLK_TOP_CAMTG>,
+			 <&topckgen CLK_TOP_UNIVPLL_192M_D8>;
+		clock-names = "xvclk", "freq_mux";
+		clock-frequency = <24000000>;
+
+		assigned-clocks = <&topckgen CLK_TOP_CAMTG>,
+				  <&topckgen CLK_TOP_UNIVPLL_192M_D8>;
+		assigned-clock-parents = <&topckgen CLK_TOP_UNIVPLL_192M_D8>;
+		assigned-clock-rates = <0>, <24000000>;
+
+		enable-gpios = <&pio 19 GPIO_ACTIVE_HIGH>;
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&camera_pins_cam0>;
+
+		/*dovdd-supply = <&mt6359_vrf18_ldo_reg>;*/
+		avdd-supply = <&mt6359_vfe28_ldo_reg>;
+
+#if GC08A3_GT9769
+        lens-focus = <&camera_main_af_2>;
+#endif
+		port {
+			sensor0_out_2: endpoint {
+				data-lanes = <1 2 3 4>;
+				link-frequencies = /bits/ 64 <336000000 207000000>;
+				remote-endpoint = <&seninf_csi_port_0_in_2>;
+			};
+		};
+	};
+    //================================================
+
+
+	eeprom@58 {
+		compatible = "atmel,24c64";
+		reg = <0x58>;
+		pagesize = <32>;
+		vcc-supply = <&mt6359_vibr_ldo_reg>;
+		device-id = <0>;
+	};
+};
+
+&i2c5 {
+	status = "okay";
+	clock-frequency = <400000>;
+
+    //================================================
+	sensor1@1 {
+		status = "okay";
+		compatible = "GalaxyCore,gc08a3";
+		reg = <0x31>;
+
+		clocks = <&topckgen CLK_TOP_CAMTG2>,
+			 <&topckgen CLK_TOP_UNIVPLL_192M_D8>;
+		clock-names = "xvclk", "freq_mux";
+		clock-frequency = <24000000>;
+
+		assigned-clocks = <&topckgen CLK_TOP_CAMTG2>,
+				  <&topckgen CLK_TOP_UNIVPLL_192M_D8>;
+		assigned-clock-parents = <&topckgen CLK_TOP_UNIVPLL_192M_D8>;
+		assigned-clock-rates = <0>, <24000000>;
+
+		enable-gpios = <&pio 21 GPIO_ACTIVE_HIGH>;
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&camera_pins_cam1>;
+
+		dovdd-supply = <&mt6359_vcamio_ldo_reg>;
+		avdd-supply = <&mt6359_vio28_ldo_reg>;
+
+		port {
+			sensor1_out_1: endpoint {
+				data-lanes = <1 2 3 4>;
+				link-frequencies = /bits/ 64 <336000000 207000000>;
+				remote-endpoint = <&seninf_csi_port_1_in_1>;
+			};
+		};
+	};
+    //================================================
+
+    //================================================
+	sensor1@2 {
+		status = "okay";
+		compatible =  "GalaxyCore,gc05a2";
+		reg = <0x37>;
+
+		clocks = <&topckgen CLK_TOP_CAMTG2>,
+			 <&topckgen CLK_TOP_UNIVPLL_192M_D8>;
+		clock-names = "xvclk", "freq_mux";
+		clock-frequency = <24000000>;
+
+		assigned-clocks = <&topckgen CLK_TOP_CAMTG2>,
+				  <&topckgen CLK_TOP_UNIVPLL_192M_D8>;
+		assigned-clock-parents = <&topckgen CLK_TOP_UNIVPLL_192M_D8>;
+		assigned-clock-rates = <0>, <24000000>;
+
+		enable-gpios = <&pio 21 GPIO_ACTIVE_HIGH>;
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&camera_pins_cam1>;
+
+		dovdd-supply = <&mt6359_vcamio_ldo_reg>;
+		avdd-supply = <&mt6359_vio28_ldo_reg>;
+
+		port {
+			sensor1_out_2: endpoint {
+				data-lanes = <1 4>;
+				link-frequencies = /bits/ 64 <448000000 224000000>;
+				remote-endpoint = <&seninf_csi_port_1_in_2>;
+			};
+		};
+	};
+    //================================================
+
+
+	eeprom@51 {
+		compatible = "atmel,24c64";
+		reg = <0x51>;
+		pagesize = <32>;
+		vcc-supply = <&mt6359_vcamio_ldo_reg>;
+		device-id = <0>;
+	};
+};
+
diff --git a/chromeos/config/chromeos/arm64/chromiumos-arm64.flavour.config b/chromeos/config/chromeos/arm64/chromiumos-arm64.flavour.config
index 36975105058db864ad94397f96af284ded83734a..359061d70a236051e16092e8004fefaebccde893 100644
--- a/chromeos/config/chromeos/arm64/chromiumos-arm64.flavour.config
+++ b/chromeos/config/chromeos/arm64/chromiumos-arm64.flavour.config
@@ -25,6 +25,7 @@ CONFIG_BT_HCIUART_RTL=y
 CONFIG_BT_MRVL=m
 CONFIG_BT_MRVL_SDIO=m
 CONFIG_BT_MTKSDIO=m
+CONFIG_CMA=y
 # CONFIG_COMMON_CLK_MT2712 is not set
 # CONFIG_COMMON_CLK_MT6765 is not set
 # CONFIG_COMMON_CLK_MT6779 is not set
@@ -49,6 +50,10 @@ CONFIG_CROS_EC_RPMSG=m
 CONFIG_CRYPTO_DEV_VIRTIO=m
 CONFIG_CRYPTO_MICHAEL_MIC=y
 CONFIG_DEVFREQ_THERMAL=y
+CONFIG_DMABUF_HEAPS=y
+CONFIG_DMABUF_HEAPS_CMA=y
+CONFIG_DMABUF_HEAPS_SYSTEM=y
+CONFIG_DMA_CMA=y
 CONFIG_DRM_ANALOGIX_ANX7625=m
 CONFIG_DRM_ANALOGIX_ANX78XX=y
 CONFIG_DRM_ITE_IT6505=m
@@ -295,6 +300,9 @@ CONFIG_USB_ULPI=y
 CONFIG_VIDEO_DW9768=m
 CONFIG_VIDEO_HANTRO=y
 CONFIG_VIDEO_MEDIATEK_JPEG=m
+# CONFIG_VIDEO_MTK_ISP_70_CAMSYS is not set
+CONFIG_VIDEO_MTK_ISP_71_CAMSYS=y
+CONFIG_VIDEO_MTK_ISP_71_IMGSYS=y
 CONFIG_VIDEO_MEDIATEK_MDP=m
 CONFIG_VIDEO_MEDIATEK_MDP3=m
 CONFIG_VIDEO_MEDIATEK_VCODEC=m
diff --git a/chromeos/config/chromeos/arm64/chromiumos-mediatek.flavour.config b/chromeos/config/chromeos/arm64/chromiumos-mediatek.flavour.config
index 84d2fbc07ec5c779e257d442c8a11dcbe17a8662..2e7c5148956f04902180baa23b567921e52dd25e 100644
--- a/chromeos/config/chromeos/arm64/chromiumos-mediatek.flavour.config
+++ b/chromeos/config/chromeos/arm64/chromiumos-mediatek.flavour.config
@@ -3,6 +3,7 @@
 #
 CONFIG_ARCH_MEDIATEK=y
 CONFIG_ARM_MEDIATEK_CPUFREQ=y
+CONFIG_ARM_MEDIATEK_CPUFREQ_HW=y
 CONFIG_ARM_SMC_WATCHDOG=y
 CONFIG_ATH10K_SDIO=m
 CONFIG_ATH10K_TRACING=y
@@ -12,6 +13,7 @@ CONFIG_BT_HCIUART_RTL=y
 CONFIG_BT_MRVL=m
 CONFIG_BT_MRVL_SDIO=m
 CONFIG_BT_MTKSDIO=m
+CONFIG_CMA=y
 # CONFIG_COMMON_CLK_MT2712 is not set
 # CONFIG_COMMON_CLK_MT6765 is not set
 # CONFIG_COMMON_CLK_MT6779 is not set
@@ -24,11 +26,16 @@ CONFIG_BT_MTKSDIO=m
 # CONFIG_COMMON_CLK_MT8516 is not set
 CONFIG_CONFIGFS_FS=y
 CONFIG_CROS_EC_RPMSG=m
+CONFIG_DMABUF_HEAPS=y
+CONFIG_DMABUF_HEAPS_CMA=y
+CONFIG_DMABUF_HEAPS_SYSTEM=y
+CONFIG_DMA_CMA=y
 CONFIG_DMA_RESTRICTED_POOL=y
 CONFIG_DRM_ANALOGIX_ANX7625=y
 CONFIG_DRM_ANALOGIX_ANX78XX=y
 CONFIG_DRM_ITE_IT6505=y
 CONFIG_DRM_MEDIATEK=y
+CONFIG_DRM_MEDIATEK_DP=y
 CONFIG_DRM_MEDIATEK_HDMI=y
 CONFIG_DRM_PANEL_BOE_TV101WUM_NL6=y
 CONFIG_DRM_PANEL_INNOLUX_P079ZCA=y
@@ -41,6 +48,7 @@ CONFIG_I2C_HID_OF=y
 CONFIG_I2C_HID_OF_GOODIX=y
 CONFIG_I2C_MT65XX=y
 CONFIG_IIO_CROS_EC_SENSORS_LID_ANGLE=m
+CONFIG_LVTS_MT8188=y
 CONFIG_MALI=y
 CONFIG_MALI_EXPERT=y
 CONFIG_MALI_PLATFORM_NAME="mediatek"
@@ -57,6 +65,7 @@ CONFIG_MTK_PMIC_WRAP=y
 CONFIG_MTK_SCP=m
 CONFIG_MTK_SOC_THERMAL=y
 CONFIG_MTK_SOC_THERMAL_LVTS=y
+CONFIG_MTK_SYSTRACKER_V2=y
 CONFIG_MTK_THERMAL=y
 CONFIG_MWIFIEX_SDIO=m
 CONFIG_NVMEM_MTK_EFUSE=y
@@ -64,7 +73,6 @@ CONFIG_PCI=y
 CONFIG_PCIEAER=y
 CONFIG_PCIEASPM_POWER_SUPERSAVE=y
 CONFIG_PCIEPORTBUS=y
-CONFIG_PCIE_MEDIATEK=y
 CONFIG_PCIE_MEDIATEK_GEN3=y
 CONFIG_PHY_MTK_PCIE=y
 CONFIG_PHY_MTK_TPHY=y
@@ -104,6 +112,8 @@ CONFIG_SND_SOC_MT8183_MT6358_TS3A227E_MAX98357A=y
 CONFIG_SND_SOC_MT8186=y
 CONFIG_SND_SOC_MT8186_MT6366_DA7219_MAX98357=y
 CONFIG_SND_SOC_MT8186_MT6366_RT1019_RT5682S=y
+CONFIG_SND_SOC_MT8188=y
+CONFIG_SND_SOC_MT8188_MT6359=y
 CONFIG_SND_SOC_MT8192=y
 CONFIG_SND_SOC_MT8192_MT6359_RT1015_RT5682=y
 CONFIG_SND_SOC_SOF_MT8186=m
@@ -119,17 +129,27 @@ CONFIG_STAGING_MEDIA=y
 CONFIG_SX9324=m
 CONFIG_TCG_TIS_I2C_CR50=y
 CONFIG_TCG_TIS_I2C_INFINEON=y
+CONFIG_TCG_VTPM_PROXY=y
 CONFIG_TMPFS=y
 CONFIG_TOUCHSCREEN_MELFAS_MIP4=y
 CONFIG_TYPEC=y
 CONFIG_USB_MTU3=y
 CONFIG_USB_MTU3_HOST=y
 CONFIG_VIDEO_DW9768=m
+CONFIG_VIDEO_GC05A2=y
+CONFIG_VIDEO_GC08A3=y
+CONFIG_VIDEO_GT97XX=y
+CONFIG_VIDEO_HI1339=y
 CONFIG_VIDEO_MEDIATEK_JPEG=m
+# CONFIG_VIDEO_MTK_ISP_70_CAMSYS is not set
+CONFIG_VIDEO_MTK_ISP_71_CAMSYS=y
+CONFIG_VIDEO_MTK_ISP_71_IMGSYS=y
 CONFIG_VIDEO_MEDIATEK_MDP=m
 CONFIG_VIDEO_MEDIATEK_MDP3=m
 CONFIG_VIDEO_MEDIATEK_VCODEC=m
 CONFIG_VIDEO_MEDIATEK_VPU=y
+CONFIG_VIDEO_MTK_AIE=y
 CONFIG_VIDEO_OV02A10=m
 CONFIG_VIDEO_OV5695=m
 CONFIG_VIDEO_OV8856=m
+CONFIG_MTK_SVS=y
diff --git a/drivers/clk/mediatek/clk-mt8188-topckgen.c b/drivers/clk/mediatek/clk-mt8188-topckgen.c
old mode 100644
new mode 100755
index c56ec42cb15f3061a76cc039aba80653e49c1a8e..dd385bf1ff24a25be5dca2e6f035fc82283c4f14
--- a/drivers/clk/mediatek/clk-mt8188-topckgen.c
+++ b/drivers/clk/mediatek/clk-mt8188-topckgen.c
@@ -487,6 +487,64 @@ static const char * const dp_parents[] = {
 	"tvdpll2_d16"
 };
 
+static int mt8188_dp_clk_determine_rate(struct clk_hw *hw,
+					   struct clk_rate_request *req)
+{
+	const char *clk_hw_name = clk_hw_get_name(hw);
+	unsigned int pow, parent_id, is_edp = 0;
+	struct clk_rate_request parent_req = *req;
+	struct clk_hw *parent_hw = clk_hw_get_parent(hw);
+	unsigned long parent_rate = clk_hw_get_rate(parent_hw);
+	int ret = 0;
+
+	if (!strncmp(clk_hw_name, "top_edp", 7))
+		is_edp = 1;
+
+	if(req->rate < 8000000)
+		pow = 4; //D16
+	else if (req->rate < 200000000)
+		pow = 3; //D8
+	else
+		pow = 2; //D4
+
+	if (is_edp)
+		parent_id = (pow << 1) - 1; // 3, 5, 7
+	else
+		parent_id = pow << 1; // 4, 6, 8
+
+	// re-parenting and determine rate
+	if (clk_hw_can_set_rate_parent(hw)) {
+		parent_hw = clk_hw_get_parent_by_index(hw, parent_id);
+		ret = __clk_determine_rate(parent_hw, &parent_req);
+		if (ret)
+			return ret;
+
+		req->best_parent_hw = parent_hw;
+		req->rate = req->best_parent_rate = parent_req.rate;
+	} else {
+		req->best_parent_hw = parent_hw;
+		req->rate = req->best_parent_rate = parent_rate;
+	}
+
+	return ret;
+}
+
+static struct clk_ops mt8188_dp_clk_ops;
+
+static void mt8188_dp_clk_ops_init(void) {
+	mt8188_dp_clk_ops = mtk_mux_gate_clr_set_upd_ops;
+	mt8188_dp_clk_ops.determine_rate = mt8188_dp_clk_determine_rate;
+}
+
+#define MT8188_DP_MUX(_id, _name, _parents, _mux_ofs, _mux_set_ofs,	\
+			 _mux_clr_ofs, _shift, _width, _gate, _upd_ofs, \
+			 _upd)	\
+		GATE_CLR_SET_UPD_FLAGS(_id, _name, _parents, _mux_ofs,		\
+			_mux_set_ofs, _mux_clr_ofs, _shift, _width,		\
+			_gate, _upd_ofs, _upd, CLK_SET_RATE_PARENT,		\
+			mt8188_dp_clk_ops)
+
+
 static const char * const edp_parents[] = {
 	"clk26m",
 	"tvdpll1_d2",
@@ -1034,9 +1092,9 @@ static const struct mtk_mux top_mtk_muxes[] = {
 	MUX_GATE_CLR_SET_UPD(CLK_TOP_SSPM, "top_sspm",
 			     sspm_parents, 0x080, 0x084, 0x088, 24, 4, 31, 0x08, 3),
 	/* CLK_CFG_9 */
-	MUX_GATE_CLR_SET_UPD(CLK_TOP_DP, "top_dp",
+	MT8188_DP_MUX(CLK_TOP_DP, "top_dp",
 			     dp_parents, 0x08C, 0x090, 0x094, 0, 4, 7, 0x08, 4),
-	MUX_GATE_CLR_SET_UPD(CLK_TOP_EDP, "top_edp",
+	MT8188_DP_MUX(CLK_TOP_EDP, "top_edp",
 			     edp_parents, 0x08C, 0x090, 0x094, 8, 4, 15, 0x08, 5),
 	MUX_GATE_CLR_SET_UPD(CLK_TOP_DPI, "top_dpi",
 			     dpi_parents, 0x08C, 0x090, 0x094, 16, 4, 23, 0x08, 6),
@@ -1259,6 +1317,8 @@ static int clk_mt8188_topck_probe(struct platform_device *pdev)
 		goto free_top_data;
 	}
 
+	mt8188_dp_clk_ops_init();
+
 	r = mtk_clk_register_fixed_clks(top_fixed_clks, ARRAY_SIZE(top_fixed_clks),
 					top_clk_data);
 	if (r)
diff --git a/drivers/clk/mediatek/clk-mt8188-vpp0.c b/drivers/clk/mediatek/clk-mt8188-vpp0.c
index 07bdedf6a21ac4a27372fb3470e654687e81a59c..165e49e43d75aabd77410cada2351897333bbce8 100644
--- a/drivers/clk/mediatek/clk-mt8188-vpp0.c
+++ b/drivers/clk/mediatek/clk-mt8188-vpp0.c
@@ -96,6 +96,15 @@ static const struct mtk_clk_desc vpp0_desc = {
 	.num_clks = ARRAY_SIZE(vpp0_clks),
 };
 
+static const struct of_device_id of_match_clk_mt8188_vpp0[] = {
+	{
+		.compatible = "mediatek,mt8188-vppsys0",
+		.data = &vpp0_desc,
+	}, {
+		/* sentinel */
+	}
+};
+
 static const struct platform_device_id clk_mt8188_vpp0_id_table[] = {
 	{ .name = "clk-mt8188-vpp0", .driver_data = (kernel_ulong_t)&vpp0_desc },
 	{ /* sentinel */ }
@@ -103,12 +112,12 @@ static const struct platform_device_id clk_mt8188_vpp0_id_table[] = {
 MODULE_DEVICE_TABLE(platform, clk_mt8188_vpp0_id_table);
 
 static struct platform_driver clk_mt8188_vpp0_drv = {
-	.probe = mtk_clk_pdev_probe,
-	.remove = mtk_clk_pdev_remove,
+	.probe = mtk_clk_simple_probe,
 	.driver = {
 		.name = "clk-mt8188-vpp0",
+		.of_match_table = of_match_clk_mt8188_vpp0,
 	},
-	.id_table = clk_mt8188_vpp0_id_table,
+	//.id_table = clk_mt8188_vpp0_id_table,
 };
 module_platform_driver(clk_mt8188_vpp0_drv);
 MODULE_LICENSE("GPL");
diff --git a/drivers/clk/mediatek/clk-mt8188-vpp1.c b/drivers/clk/mediatek/clk-mt8188-vpp1.c
index d4e66b2405733d9819d8f575753f4de5107d1dd9..8256f219d8b80b1f047130afbc09596f01085b19 100644
--- a/drivers/clk/mediatek/clk-mt8188-vpp1.c
+++ b/drivers/clk/mediatek/clk-mt8188-vpp1.c
@@ -91,6 +91,15 @@ static const struct mtk_clk_desc vpp1_desc = {
 	.num_clks = ARRAY_SIZE(vpp1_clks),
 };
 
+static const struct of_device_id of_match_clk_mt8188_vpp1[] = {
+	{
+		.compatible = "mediatek,mt8188-vppsys1",
+		.data = &vpp1_desc,
+	}, {
+		/* sentinel */
+	}
+};
+
 static const struct platform_device_id clk_mt8188_vpp1_id_table[] = {
 	{ .name = "clk-mt8188-vpp1", .driver_data = (kernel_ulong_t)&vpp1_desc },
 	{ /* sentinel */ }
@@ -98,12 +107,12 @@ static const struct platform_device_id clk_mt8188_vpp1_id_table[] = {
 MODULE_DEVICE_TABLE(platform, clk_mt8188_vpp1_id_table);
 
 static struct platform_driver clk_mt8188_vpp1_drv = {
-	.probe = mtk_clk_pdev_probe,
-	.remove = mtk_clk_pdev_remove,
+	.probe = mtk_clk_simple_probe,
 	.driver = {
 		.name = "clk-mt8188-vpp1",
+		.of_match_table = of_match_clk_mt8188_vpp1,
 	},
-	.id_table = clk_mt8188_vpp1_id_table,
+	//.id_table = clk_mt8188_vpp1_id_table,
 };
 module_platform_driver(clk_mt8188_vpp1_drv);
 MODULE_LICENSE("GPL");
diff --git a/drivers/dma-buf/dma-heap.c b/drivers/dma-buf/dma-heap.c
index 59d158873f4cb451b5a5db4f0691e25d6a56909c..2989b719dcf30d7c457cb7564260d3eb4f695c84 100644
--- a/drivers/dma-buf/dma-heap.c
+++ b/drivers/dma-buf/dma-heap.c
@@ -31,6 +31,7 @@
  * @heap_devt		heap device node
  * @list		list head connecting to list of heaps
  * @heap_cdev		heap char device
+ * @heap_dev		heap device struct
  *
  * Represents a heap of memory from which buffers can be made.
  */
@@ -41,6 +42,8 @@ struct dma_heap {
 	dev_t heap_devt;
 	struct list_head list;
 	struct cdev heap_cdev;
+	struct kref refcount;
+	struct device *heap_dev;
 };
 
 static LIST_HEAD(heap_list);
@@ -49,22 +52,60 @@ static dev_t dma_heap_devt;
 static struct class *dma_heap_class;
 static DEFINE_XARRAY_ALLOC(dma_heap_minors);
 
-static int dma_heap_buffer_alloc(struct dma_heap *heap, size_t len,
-				 unsigned int fd_flags,
-				 unsigned int heap_flags)
+struct dma_heap *dma_heap_find(const char *name)
 {
-	struct dma_buf *dmabuf;
-	int fd;
+	struct dma_heap *h;
+
+	mutex_lock(&heap_list_lock);
+	list_for_each_entry(h, &heap_list, list) {
+		if (!strcmp(h->name, name)) {
+			kref_get(&h->refcount);
+			mutex_unlock(&heap_list_lock);
+			return h;
+		}
+	}
+	mutex_unlock(&heap_list_lock);
+	return NULL;
+}
+EXPORT_SYMBOL_GPL(dma_heap_find);
+
+
+void dma_heap_buffer_free(struct dma_buf *dmabuf)
+{
+	dma_buf_put(dmabuf);
+}
+EXPORT_SYMBOL_GPL(dma_heap_buffer_free);
+
+struct dma_buf *dma_heap_buffer_alloc(struct dma_heap *heap, size_t len,
+				      unsigned int fd_flags,
+				      unsigned int heap_flags)
+{
+	if (fd_flags & ~DMA_HEAP_VALID_FD_FLAGS)
+		return ERR_PTR(-EINVAL);
 
+	if (heap_flags & ~DMA_HEAP_VALID_HEAP_FLAGS)
+		return ERR_PTR(-EINVAL);
 	/*
 	 * Allocations from all heaps have to begin
 	 * and end on page boundaries.
 	 */
 	len = PAGE_ALIGN(len);
 	if (!len)
-		return -EINVAL;
+		return ERR_PTR(-EINVAL);
+
+	return heap->ops->allocate(heap, len, fd_flags, heap_flags);
+}
+EXPORT_SYMBOL_GPL(dma_heap_buffer_alloc);
+
+int dma_heap_bufferfd_alloc(struct dma_heap *heap, size_t len,
+			    unsigned int fd_flags,
+			    unsigned int heap_flags)
+{
+	struct dma_buf *dmabuf;
+	int fd;
+
+	dmabuf = dma_heap_buffer_alloc(heap, len, fd_flags, heap_flags);
 
-	dmabuf = heap->ops->allocate(heap, len, fd_flags, heap_flags);
 	if (IS_ERR(dmabuf))
 		return PTR_ERR(dmabuf);
 
@@ -74,7 +115,9 @@ static int dma_heap_buffer_alloc(struct dma_heap *heap, size_t len,
 		/* just return, as put will call release and that will free */
 	}
 	return fd;
+
 }
+EXPORT_SYMBOL_GPL(dma_heap_bufferfd_alloc);
 
 static int dma_heap_open(struct inode *inode, struct file *file)
 {
@@ -102,15 +145,9 @@ static long dma_heap_ioctl_allocate(struct file *file, void *data)
 	if (heap_allocation->fd)
 		return -EINVAL;
 
-	if (heap_allocation->fd_flags & ~DMA_HEAP_VALID_FD_FLAGS)
-		return -EINVAL;
-
-	if (heap_allocation->heap_flags & ~DMA_HEAP_VALID_HEAP_FLAGS)
-		return -EINVAL;
-
-	fd = dma_heap_buffer_alloc(heap, heap_allocation->len,
-				   heap_allocation->fd_flags,
-				   heap_allocation->heap_flags);
+	fd = dma_heap_bufferfd_alloc(heap, heap_allocation->len,
+				     heap_allocation->fd_flags,
+				     heap_allocation->heap_flags);
 	if (fd < 0)
 		return fd;
 
@@ -203,6 +240,20 @@ void *dma_heap_get_drvdata(struct dma_heap *heap)
 {
 	return heap->priv;
 }
+EXPORT_SYMBOL_GPL(dma_heap_get_drvdata);
+
+/**
+ * dma_heap_get_dev() - get device struct for the heap
+ * @heap: DMA-Heap to retrieve device struct from
+ *
+ * Returns:
+ * The device struct for the heap.
+ */
+struct device *dma_heap_get_dev(struct dma_heap *heap)
+{
+	return heap->heap_dev;
+}
+EXPORT_SYMBOL_GPL(dma_heap_get_dev);
 
 /**
  * dma_heap_get_name() - get heap name
@@ -215,11 +266,38 @@ const char *dma_heap_get_name(struct dma_heap *heap)
 {
 	return heap->name;
 }
+EXPORT_SYMBOL_GPL(dma_heap_get_name);
+
+static void dma_heap_release(struct kref *ref)
+{
+	struct dma_heap *heap = container_of(ref, struct dma_heap, refcount);
+	int minor = MINOR(heap->heap_devt);
+
+	/* Note, we already holding the heap_list_lock here */
+	list_del(&heap->list);
+
+	device_destroy(dma_heap_class, heap->heap_devt);
+	cdev_del(&heap->heap_cdev);
+	xa_erase(&dma_heap_minors, minor);
+
+	kfree(heap);
+}
+
+void dma_heap_put(struct dma_heap *h)
+{
+	/*
+	 * Take the heap_list_lock now to avoid racing with code
+	 * scanning the list and then taking a kref.
+	 */
+	mutex_lock(&heap_list_lock);
+	kref_put(&h->refcount, dma_heap_release);
+	mutex_unlock(&heap_list_lock);
+}
+EXPORT_SYMBOL_GPL(dma_heap_put);
 
 struct dma_heap *dma_heap_add(const struct dma_heap_export_info *exp_info)
 {
 	struct dma_heap *heap, *h, *err_ret;
-	struct device *dev_ret;
 	unsigned int minor;
 	int ret;
 
@@ -237,6 +315,7 @@ struct dma_heap *dma_heap_add(const struct dma_heap_export_info *exp_info)
 	if (!heap)
 		return ERR_PTR(-ENOMEM);
 
+	kref_init(&heap->refcount);
 	heap->name = exp_info->name;
 	heap->ops = exp_info->ops;
 	heap->priv = exp_info->priv;
@@ -261,30 +340,32 @@ struct dma_heap *dma_heap_add(const struct dma_heap_export_info *exp_info)
 		goto err1;
 	}
 
-	dev_ret = device_create(dma_heap_class,
-				NULL,
-				heap->heap_devt,
-				NULL,
-				heap->name);
-	if (IS_ERR(dev_ret)) {
+	heap->heap_dev = device_create(dma_heap_class,
+				       NULL,
+				       heap->heap_devt,
+				       NULL,
+				       heap->name);
+	if (IS_ERR(heap->heap_dev)) {
 		pr_err("dma_heap: Unable to create device\n");
-		err_ret = ERR_CAST(dev_ret);
+		err_ret = ERR_CAST(heap->heap_dev);
 		goto err2;
 	}
 
-	mutex_lock(&heap_list_lock);
+	/* Make sure it doesn't disappear on us */
+	heap->heap_dev = get_device(heap->heap_dev);
+
 	/* check the name is unique */
-	list_for_each_entry(h, &heap_list, list) {
-		if (!strcmp(h->name, exp_info->name)) {
-			mutex_unlock(&heap_list_lock);
-			pr_err("dma_heap: Already registered heap named %s\n",
-			       exp_info->name);
-			err_ret = ERR_PTR(-EINVAL);
-			goto err3;
-		}
+	h = dma_heap_find(exp_info->name);
+	if (h) {
+		pr_err("dma_heap: Already registered heap named %s\n",
+		       exp_info->name);
+		dma_heap_put(h);
+		err_ret = ERR_PTR(-EINVAL);
+		goto err3;
 	}
 
 	/* Add heap to the list */
+	mutex_lock(&heap_list_lock);
 	list_add(&heap->list, &heap_list);
 	mutex_unlock(&heap_list_lock);
 
@@ -300,27 +381,88 @@ struct dma_heap *dma_heap_add(const struct dma_heap_export_info *exp_info)
 	kfree(heap);
 	return err_ret;
 }
+EXPORT_SYMBOL_GPL(dma_heap_add);
 
 static char *dma_heap_devnode(struct device *dev, umode_t *mode)
 {
 	return kasprintf(GFP_KERNEL, "dma_heap/%s", dev_name(dev));
 }
 
+static ssize_t total_pools_kb_show(struct kobject *kobj,
+				   struct kobj_attribute *attr, char *buf)
+{
+	struct dma_heap *heap;
+	u64 total_pool_size = 0;
+
+	mutex_lock(&heap_list_lock);
+	list_for_each_entry(heap, &heap_list, list) {
+		if (heap->ops->get_pool_size)
+			total_pool_size += heap->ops->get_pool_size(heap);
+	}
+	mutex_unlock(&heap_list_lock);
+
+	return sysfs_emit(buf, "%llu\n", total_pool_size / 1024);
+}
+
+static struct kobj_attribute total_pools_kb_attr =
+	__ATTR_RO(total_pools_kb);
+
+static struct attribute *dma_heap_sysfs_attrs[] = {
+	&total_pools_kb_attr.attr,
+	NULL,
+};
+
+ATTRIBUTE_GROUPS(dma_heap_sysfs);
+
+static struct kobject *dma_heap_kobject;
+
+static int dma_heap_sysfs_setup(void)
+{
+	int ret;
+
+	dma_heap_kobject = kobject_create_and_add("dma_heap", kernel_kobj);
+	if (!dma_heap_kobject)
+		return -ENOMEM;
+
+	ret = sysfs_create_groups(dma_heap_kobject, dma_heap_sysfs_groups);
+	if (ret) {
+		kobject_put(dma_heap_kobject);
+		return ret;
+	}
+
+	return 0;
+}
+
+static void dma_heap_sysfs_teardown(void)
+{
+	kobject_put(dma_heap_kobject);
+}
+
 static int dma_heap_init(void)
 {
 	int ret;
 
-	ret = alloc_chrdev_region(&dma_heap_devt, 0, NUM_HEAP_MINORS, DEVNAME);
+	ret = dma_heap_sysfs_setup();
 	if (ret)
 		return ret;
 
+	ret = alloc_chrdev_region(&dma_heap_devt, 0, NUM_HEAP_MINORS, DEVNAME);
+	if (ret)
+		goto err_chrdev;
+
 	dma_heap_class = class_create(THIS_MODULE, DEVNAME);
 	if (IS_ERR(dma_heap_class)) {
-		unregister_chrdev_region(dma_heap_devt, NUM_HEAP_MINORS);
-		return PTR_ERR(dma_heap_class);
+		ret = PTR_ERR(dma_heap_class);
+		goto err_class;
 	}
 	dma_heap_class->devnode = dma_heap_devnode;
 
 	return 0;
+
+err_class:
+	unregister_chrdev_region(dma_heap_devt, NUM_HEAP_MINORS);
+err_chrdev:
+	dma_heap_sysfs_teardown();
+	return ret;
 }
 subsys_initcall(dma_heap_init);
diff --git a/drivers/dma-buf/heaps/Kconfig b/drivers/dma-buf/heaps/Kconfig
index a5eef06c422644e8aadaf5aff2bd9a33c49c1ba3..e273fb18feca091ccd9b406e68f86c12efb339e9 100644
--- a/drivers/dma-buf/heaps/Kconfig
+++ b/drivers/dma-buf/heaps/Kconfig
@@ -1,12 +1,12 @@
 config DMABUF_HEAPS_SYSTEM
-	bool "DMA-BUF System Heap"
+	tristate "DMA-BUF System Heap"
 	depends on DMABUF_HEAPS
 	help
 	  Choose this option to enable the system dmabuf heap. The system heap
 	  is backed by pages from the buddy allocator. If in doubt, say Y.
 
 config DMABUF_HEAPS_CMA
-	bool "DMA-BUF CMA Heap"
+	tristate "DMA-BUF CMA Heap"
 	depends on DMABUF_HEAPS && DMA_CMA
 	help
 	  Choose this option to enable dma-buf CMA heap. This heap is backed
diff --git a/drivers/dma-buf/heaps/cma_heap.c b/drivers/dma-buf/heaps/cma_heap.c
index 1131fb943992f33d9ee76481475f1267b5b558ac..5d4ee6e51558e89a97f56227e5cfdb8fc3cf7686 100644
--- a/drivers/dma-buf/heaps/cma_heap.c
+++ b/drivers/dma-buf/heaps/cma_heap.c
@@ -19,6 +19,8 @@
 #include <linux/io.h>
 #include <linux/mm.h>
 #include <linux/module.h>
+#include <linux/of_fdt.h>
+#include <linux/of_reserved_mem.h>
 #include <linux/scatterlist.h>
 #include <linux/slab.h>
 #include <linux/vmalloc.h>
@@ -395,6 +397,13 @@ static int __add_cma_heap(struct cma *cma, void *data)
 	return 0;
 }
 
+/* TODO, defined in cma.h after 5.10 */
+#ifndef CMA_MIN_ALIGNMENT_BYTES
+#define CMA_MIN_ALIGNMENT_BYTES 0x200000
+#endif
+
+static struct cma *dma_buf_cma;
+
 static int add_default_cma_heap(void)
 {
 	struct cma *default_cma = dev_get_cma_area(NULL);
@@ -403,8 +412,47 @@ static int add_default_cma_heap(void)
 	if (default_cma)
 		ret = __add_cma_heap(default_cma, NULL);
 
+	pr_info("dmabuf heaps add cma:%s heap ret%d.", cma_get_name(default_cma), ret);
+
+	if (dma_buf_cma) {
+		ret = __add_cma_heap(dma_buf_cma, NULL);
+		pr_info("dmabuf heaps add cma:%s heap ret%d.", cma_get_name(dma_buf_cma), ret);
+	}
 	return ret;
 }
 module_init(add_default_cma_heap);
+
+static int __init dma_buf_heap_cma_init(struct reserved_mem *rmem)
+{
+	unsigned long node = rmem->fdt_node;
+	struct cma *cma;
+	int err;
+
+	if (!of_get_flat_dt_prop(node, "reusable", NULL) ||
+	    of_get_flat_dt_prop(node, "no-map", NULL)) {
+		pr_err("Reserved memory: incorrect flag\n");
+		return -EINVAL;
+	}
+
+	if (!IS_ALIGNED(rmem->base | rmem->size, CMA_MIN_ALIGNMENT_BYTES)) {
+		pr_err("Reserved memory: incorrect alignment of CMA region %lx.\n",
+			CMA_MIN_ALIGNMENT_BYTES);
+		return -EINVAL;
+	}
+
+	err = cma_init_reserved_mem(rmem->base, rmem->size, 0, rmem->name, &cma);
+	if (err) {
+		pr_err("Reserved memory: unable to setup CMA region\n");
+		return err;
+	}
+
+	dma_buf_cma = cma;
+
+	pr_info("Reserved memory for Dmabuf: created CMA memory pool at %pa, size %ld MiB\n",
+		&rmem->base, (unsigned long)rmem->size / SZ_1M);
+	return 0;
+}
+RESERVEDMEM_OF_DECLARE(cma, "dma-buf-heap-cma", dma_buf_heap_cma_init);
+
 MODULE_DESCRIPTION("DMA-BUF CMA Heap");
 MODULE_LICENSE("GPL v2");
diff --git a/drivers/gpu/arm/mali/Kconfig b/drivers/gpu/arm/mali/Kconfig
index 0fc2dd0eec163f09fe7abd447e472fad0d37146c..18db639f01ccf086b595f2bbe40b31c90eaada15 100644
--- a/drivers/gpu/arm/mali/Kconfig
+++ b/drivers/gpu/arm/mali/Kconfig
@@ -25,7 +25,6 @@ menuconfig MALI
 	select GPU_TRACEPOINTS if ANDROID
 	select DMA_SHARED_BUFFER
 	select PM_DEVFREQ
-	select DEVFREQ_THERMAL
 	select FW_LOADER
 	default n
 	help
diff --git a/drivers/gpu/arm/mali/backend/gpu/mali_kbase_devfreq.c b/drivers/gpu/arm/mali/backend/gpu/mali_kbase_devfreq.c
index 1012fd76acd52e72d4cce0c2d1e8f54dea1e058f..fa336c6f3ce9711c4a1aa1fc354c12404a789f14 100644
--- a/drivers/gpu/arm/mali/backend/gpu/mali_kbase_devfreq.c
+++ b/drivers/gpu/arm/mali/backend/gpu/mali_kbase_devfreq.c
@@ -642,6 +642,12 @@ static int kbase_devfreq_init_core_mask_table(struct kbase_device *kbdev)
 		dev_info(kbdev->dev, "OPP %d : opp_freq=%llu core_mask=%llx\n",
 				i, opp_freq, core_mask);
 
+		for (idx = 0; idx < kbdev->nr_regulators; idx++)
+			dev_pm_opp_adjust_voltage_supply(kbdev->dev, opp_freq,
+							 opp_volts[idx],
+							 opp_volts[idx],
+							 opp_volts[idx], idx);
+
 		i++;
 	}
 
diff --git a/drivers/gpu/drm/mediatek/Makefile b/drivers/gpu/drm/mediatek/Makefile
index d4d193f60271cbda6254975496e45863aa033c8c..5e4436403b8d227c8f1c8777b384167563f6667c 100644
--- a/drivers/gpu/drm/mediatek/Makefile
+++ b/drivers/gpu/drm/mediatek/Makefile
@@ -16,7 +16,8 @@ mediatek-drm-y := mtk_disp_aal.o \
 		  mtk_dsi.o \
 		  mtk_dpi.o \
 		  mtk_ethdr.o \
-		  mtk_mdp_rdma.o
+		  mtk_mdp_rdma.o \
+		  mtk_padding.o
 
 obj-$(CONFIG_DRM_MEDIATEK) += mediatek-drm.o
 
diff --git a/drivers/gpu/drm/mediatek/mtk_disp_drv.h b/drivers/gpu/drm/mediatek/mtk_disp_drv.h
index fdaa21b6a9daaf422682136c7fcf01bc32c49b58..eb738f14f09e3e296b975ebbe41857635e23a95b 100644
--- a/drivers/gpu/drm/mediatek/mtk_disp_drv.h
+++ b/drivers/gpu/drm/mediatek/mtk_disp_drv.h
@@ -109,6 +109,8 @@ void mtk_ovl_adaptor_connect(struct device *dev, struct device *mmsys_dev,
 			     unsigned int next);
 void mtk_ovl_adaptor_disconnect(struct device *dev, struct device *mmsys_dev,
 				unsigned int next);
+int mtk_ovl_adaptor_power_on(struct device *dev);
+void mtk_ovl_adaptor_power_off(struct device *dev);
 int mtk_ovl_adaptor_clk_enable(struct device *dev);
 void mtk_ovl_adaptor_clk_disable(struct device *dev);
 void mtk_ovl_adaptor_config(struct device *dev, unsigned int w,
@@ -150,6 +152,8 @@ void mtk_rdma_disable_vblank(struct device *dev);
 const u32 *mtk_rdma_get_formats(struct device *dev);
 size_t mtk_rdma_get_num_formats(struct device *dev);
 
+int mtk_mdp_rdma_power_on(struct device *dev);
+void mtk_mdp_rdma_power_off(struct device *dev);
 int mtk_mdp_rdma_clk_enable(struct device *dev);
 void mtk_mdp_rdma_clk_disable(struct device *dev);
 void mtk_mdp_rdma_start(struct device *dev, struct cmdq_pkt *cmdq_pkt);
@@ -159,4 +163,8 @@ void mtk_mdp_rdma_config(struct device *dev, struct mtk_mdp_rdma_cfg *cfg,
 const u32 *mtk_mdp_rdma_get_formats(struct device *dev);
 size_t mtk_mdp_rdma_get_num_formats(struct device *dev);
 
+int mtk_padding_clk_enable(struct device *dev);
+void mtk_padding_clk_disable(struct device *dev);
+void mtk_padding_start(struct device *dev);
+void mtk_padding_stop(struct device *dev);
 #endif
diff --git a/drivers/gpu/drm/mediatek/mtk_disp_merge.c b/drivers/gpu/drm/mediatek/mtk_disp_merge.c
index fd14a59bc9516e915e99c2e28c179c890a1e4ac5..c19fb1836034de58636305325367159a7b400173 100644
--- a/drivers/gpu/drm/mediatek/mtk_disp_merge.c
+++ b/drivers/gpu/drm/mediatek/mtk_disp_merge.c
@@ -104,7 +104,7 @@ void mtk_merge_stop_cmdq(struct device *dev, struct cmdq_pkt *cmdq_pkt)
 	mtk_ddp_write(cmdq_pkt, 0, &priv->cmdq_reg, priv->regs,
 		      DISP_REG_MERGE_CTRL);
 
-	if (priv->async_clk)
+	if (!cmdq_pkt && priv->async_clk)
 		reset_control_reset(priv->reset_ctl);
 }
 
diff --git a/drivers/gpu/drm/mediatek/mtk_disp_ovl_adaptor.c b/drivers/gpu/drm/mediatek/mtk_disp_ovl_adaptor.c
index f2f6a5c01a6d2b99da765e07a4cf7dd1dba7ab75..35bbce35b7b587302b64e4780fc95e7a87b8badc 100644
--- a/drivers/gpu/drm/mediatek/mtk_disp_ovl_adaptor.c
+++ b/drivers/gpu/drm/mediatek/mtk_disp_ovl_adaptor.c
@@ -26,13 +26,15 @@
 #define MTK_OVL_ADAPTOR_LAYER_NUM 4
 
 enum mtk_ovl_adaptor_comp_type {
-	OVL_ADAPTOR_TYPE_RDMA = 0,
-	OVL_ADAPTOR_TYPE_MERGE,
 	OVL_ADAPTOR_TYPE_ETHDR,
+	OVL_ADAPTOR_TYPE_MDP_RDMA,
+	OVL_ADAPTOR_TYPE_MERGE,
+	OVL_ADAPTOR_TYPE_PADDING,
 	OVL_ADAPTOR_TYPE_NUM,
 };
 
 enum mtk_ovl_adaptor_comp_id {
+	OVL_ADAPTOR_ETHDR0,
 	OVL_ADAPTOR_MDP_RDMA0,
 	OVL_ADAPTOR_MDP_RDMA1,
 	OVL_ADAPTOR_MDP_RDMA2,
@@ -45,13 +47,22 @@ enum mtk_ovl_adaptor_comp_id {
 	OVL_ADAPTOR_MERGE1,
 	OVL_ADAPTOR_MERGE2,
 	OVL_ADAPTOR_MERGE3,
-	OVL_ADAPTOR_ETHDR0,
+	OVL_ADAPTOR_PADDING0,
+	OVL_ADAPTOR_PADDING1,
+	OVL_ADAPTOR_PADDING2,
+	OVL_ADAPTOR_PADDING3,
+	OVL_ADAPTOR_PADDING4,
+	OVL_ADAPTOR_PADDING5,
+	OVL_ADAPTOR_PADDING6,
+	OVL_ADAPTOR_PADDING7,
 	OVL_ADAPTOR_ID_MAX
 };
 
 struct ovl_adaptor_comp_match {
 	enum mtk_ovl_adaptor_comp_type type;
+	enum mtk_ddp_comp_id comp_id;
 	int alias_id;
+	const struct mtk_ddp_comp_funcs *funcs;
 };
 
 struct mtk_disp_ovl_adaptor {
@@ -61,25 +72,60 @@ struct mtk_disp_ovl_adaptor {
 };
 
 static const char * const private_comp_stem[OVL_ADAPTOR_TYPE_NUM] = {
-	[OVL_ADAPTOR_TYPE_RDMA]		= "vdo1-rdma",
-	[OVL_ADAPTOR_TYPE_MERGE]	= "merge",
 	[OVL_ADAPTOR_TYPE_ETHDR]	= "ethdr",
+	[OVL_ADAPTOR_TYPE_MDP_RDMA]	= "vdo1-rdma",
+	[OVL_ADAPTOR_TYPE_MERGE]	= "merge",
+	[OVL_ADAPTOR_TYPE_PADDING]	= "padding",
+};
+
+static const struct mtk_ddp_comp_funcs ethdr = {
+	.clk_enable = mtk_ethdr_clk_enable,
+	.clk_disable = mtk_ethdr_clk_disable,
+	.start = mtk_ethdr_start,
+	.stop = mtk_ethdr_stop,
+};
+
+static const struct mtk_ddp_comp_funcs merge = {
+	.clk_enable = mtk_merge_clk_enable,
+	.clk_disable = mtk_merge_clk_disable,
+};
+
+static const struct mtk_ddp_comp_funcs padding = {
+	.clk_enable = mtk_padding_clk_enable,
+	.clk_disable = mtk_padding_clk_disable,
+	.start = mtk_padding_start,
+	.stop = mtk_padding_stop,
+};
+
+static const struct mtk_ddp_comp_funcs rdma = {
+	.power_on = mtk_mdp_rdma_power_on,
+	.power_off = mtk_mdp_rdma_power_off,
+	.clk_enable = mtk_mdp_rdma_clk_enable,
+	.clk_disable = mtk_mdp_rdma_clk_disable,
 };
 
 static const struct ovl_adaptor_comp_match comp_matches[OVL_ADAPTOR_ID_MAX] = {
-	[OVL_ADAPTOR_MDP_RDMA0]	= { OVL_ADAPTOR_TYPE_RDMA, 0 },
-	[OVL_ADAPTOR_MDP_RDMA1]	= { OVL_ADAPTOR_TYPE_RDMA, 1 },
-	[OVL_ADAPTOR_MDP_RDMA2]	= { OVL_ADAPTOR_TYPE_RDMA, 2 },
-	[OVL_ADAPTOR_MDP_RDMA3]	= { OVL_ADAPTOR_TYPE_RDMA, 3 },
-	[OVL_ADAPTOR_MDP_RDMA4]	= { OVL_ADAPTOR_TYPE_RDMA, 4 },
-	[OVL_ADAPTOR_MDP_RDMA5]	= { OVL_ADAPTOR_TYPE_RDMA, 5 },
-	[OVL_ADAPTOR_MDP_RDMA6]	= { OVL_ADAPTOR_TYPE_RDMA, 6 },
-	[OVL_ADAPTOR_MDP_RDMA7]	= { OVL_ADAPTOR_TYPE_RDMA, 7 },
-	[OVL_ADAPTOR_MERGE0]	= { OVL_ADAPTOR_TYPE_MERGE, 1 },
-	[OVL_ADAPTOR_MERGE1]	= { OVL_ADAPTOR_TYPE_MERGE, 2 },
-	[OVL_ADAPTOR_MERGE2]	= { OVL_ADAPTOR_TYPE_MERGE, 3 },
-	[OVL_ADAPTOR_MERGE3]	= { OVL_ADAPTOR_TYPE_MERGE, 4 },
-	[OVL_ADAPTOR_ETHDR0]	= { OVL_ADAPTOR_TYPE_ETHDR, 0 },
+	[OVL_ADAPTOR_ETHDR0] = { OVL_ADAPTOR_TYPE_ETHDR, DDP_COMPONENT_ETHDR_MIXER, 0, &ethdr },
+	[OVL_ADAPTOR_MDP_RDMA0] = { OVL_ADAPTOR_TYPE_MDP_RDMA, DDP_COMPONENT_MDP_RDMA0, 0, &rdma },
+	[OVL_ADAPTOR_MDP_RDMA1] = { OVL_ADAPTOR_TYPE_MDP_RDMA, DDP_COMPONENT_MDP_RDMA1, 1, &rdma },
+	[OVL_ADAPTOR_MDP_RDMA2] = { OVL_ADAPTOR_TYPE_MDP_RDMA, DDP_COMPONENT_MDP_RDMA2, 2, &rdma },
+	[OVL_ADAPTOR_MDP_RDMA3] = { OVL_ADAPTOR_TYPE_MDP_RDMA, DDP_COMPONENT_MDP_RDMA3, 3, &rdma },
+	[OVL_ADAPTOR_MDP_RDMA4] = { OVL_ADAPTOR_TYPE_MDP_RDMA, DDP_COMPONENT_MDP_RDMA4, 4, &rdma },
+	[OVL_ADAPTOR_MDP_RDMA5] = { OVL_ADAPTOR_TYPE_MDP_RDMA, DDP_COMPONENT_MDP_RDMA5, 5, &rdma },
+	[OVL_ADAPTOR_MDP_RDMA6] = { OVL_ADAPTOR_TYPE_MDP_RDMA, DDP_COMPONENT_MDP_RDMA6, 6, &rdma },
+	[OVL_ADAPTOR_MDP_RDMA7] = { OVL_ADAPTOR_TYPE_MDP_RDMA, DDP_COMPONENT_MDP_RDMA7, 7, &rdma },
+	[OVL_ADAPTOR_MERGE0] = { OVL_ADAPTOR_TYPE_MERGE, DDP_COMPONENT_MERGE1, 1, &merge },
+	[OVL_ADAPTOR_MERGE1] = { OVL_ADAPTOR_TYPE_MERGE, DDP_COMPONENT_MERGE2, 2, &merge },
+	[OVL_ADAPTOR_MERGE2] = { OVL_ADAPTOR_TYPE_MERGE, DDP_COMPONENT_MERGE3, 3, &merge },
+	[OVL_ADAPTOR_MERGE3] = { OVL_ADAPTOR_TYPE_MERGE, DDP_COMPONENT_MERGE4, 4, &merge },
+	[OVL_ADAPTOR_PADDING0] = { OVL_ADAPTOR_TYPE_PADDING, DDP_COMPONENT_PADDING0, 0, &padding },
+	[OVL_ADAPTOR_PADDING1] = { OVL_ADAPTOR_TYPE_PADDING, DDP_COMPONENT_PADDING1, 1, &padding },
+	[OVL_ADAPTOR_PADDING2] = { OVL_ADAPTOR_TYPE_PADDING, DDP_COMPONENT_PADDING2, 2, &padding },
+	[OVL_ADAPTOR_PADDING3] = { OVL_ADAPTOR_TYPE_PADDING, DDP_COMPONENT_PADDING3, 3, &padding },
+	[OVL_ADAPTOR_PADDING4] = { OVL_ADAPTOR_TYPE_PADDING, DDP_COMPONENT_PADDING4, 4, &padding },
+	[OVL_ADAPTOR_PADDING5] = { OVL_ADAPTOR_TYPE_PADDING, DDP_COMPONENT_PADDING5, 5, &padding },
+	[OVL_ADAPTOR_PADDING6] = { OVL_ADAPTOR_TYPE_PADDING, DDP_COMPONENT_PADDING6, 6, &padding },
+	[OVL_ADAPTOR_PADDING7] = { OVL_ADAPTOR_TYPE_PADDING, DDP_COMPONENT_PADDING7, 7, &padding },
 };
 
 void mtk_ovl_adaptor_layer_config(struct device *dev, unsigned int idx,
@@ -171,87 +217,123 @@ void mtk_ovl_adaptor_config(struct device *dev, unsigned int w,
 
 void mtk_ovl_adaptor_start(struct device *dev)
 {
+	int i;
 	struct mtk_disp_ovl_adaptor *ovl_adaptor = dev_get_drvdata(dev);
 
-	mtk_ethdr_start(ovl_adaptor->ovl_adaptor_comp[OVL_ADAPTOR_ETHDR0]);
+	for (i = 0; i < OVL_ADAPTOR_ID_MAX; i++) {
+		if (!ovl_adaptor->ovl_adaptor_comp[i] ||
+		    !comp_matches[i].funcs->start)
+			continue;
+
+		comp_matches[i].funcs->start(ovl_adaptor->ovl_adaptor_comp[i]);
+	}
 }
 
 void mtk_ovl_adaptor_stop(struct device *dev)
 {
+	int i;
 	struct mtk_disp_ovl_adaptor *ovl_adaptor = dev_get_drvdata(dev);
 
-	mtk_ethdr_stop(ovl_adaptor->ovl_adaptor_comp[OVL_ADAPTOR_ETHDR0]);
+	for (i = 0; i < OVL_ADAPTOR_ID_MAX; i++) {
+		if (!ovl_adaptor->ovl_adaptor_comp[i] ||
+		    !comp_matches[i].funcs->stop)
+			continue;
+
+		comp_matches[i].funcs->stop(ovl_adaptor->ovl_adaptor_comp[i]);
+	}
 }
 
-int mtk_ovl_adaptor_clk_enable(struct device *dev)
+/**
+ * power_off - Power off the devices in OVL adaptor
+ * @dev: Device to be powered off
+ * @num: Number of the devices to be powered off
+ *
+ * Calls the .power_off() ovl_adaptor component callback if it is present.
+ */
+static inline void power_off(struct device *dev, unsigned int num)
 {
-	struct mtk_disp_ovl_adaptor *ovl_adaptor = dev_get_drvdata(dev);
-	struct device *comp;
-	int ret;
 	int i;
+	struct mtk_disp_ovl_adaptor *ovl_adaptor = dev_get_drvdata(dev);
 
-	for (i = 0; i < OVL_ADAPTOR_MERGE0; i++) {
-		comp = ovl_adaptor->ovl_adaptor_comp[i];
-		ret = pm_runtime_get_sync(comp);
-		if (ret < 0) {
-			dev_err(dev, "Failed to enable power domain %d, err %d\n", i, ret);
-			goto pwr_err;
-		}
+	if (num > OVL_ADAPTOR_ID_MAX)
+		num = OVL_ADAPTOR_ID_MAX;
+
+	for (i = num - 1; i >= 0; i--) {
+		if (!ovl_adaptor->ovl_adaptor_comp[i] ||
+		    !comp_matches[i].funcs->power_off)
+			continue;
+
+		comp_matches[i].funcs->power_off(ovl_adaptor->ovl_adaptor_comp[i]);
 	}
+}
+
+/**
+ * mtk_ovl_adaptor_power_on - Power on the devices in OVL adaptor
+ * @dev: Device to be powered on
+ *
+ * Different from OVL, OVL adaptor is a pseudo device so
+ * we didn't define it in the device tree, pm_runtime_resume_and_get()
+ * called by .atomic_enable() power on no device in OVL adaptor,
+ * we have to implement a function to do the job instead.
+ *
+ * Return: Zero for success or negative number for failure.
+ */
+int mtk_ovl_adaptor_power_on(struct device *dev)
+{
+	int i, ret;
+	struct mtk_disp_ovl_adaptor *ovl_adaptor = dev_get_drvdata(dev);
 
 	for (i = 0; i < OVL_ADAPTOR_ID_MAX; i++) {
-		comp = ovl_adaptor->ovl_adaptor_comp[i];
-
-		if (i < OVL_ADAPTOR_MERGE0)
-			ret = mtk_mdp_rdma_clk_enable(comp);
-		else if (i < OVL_ADAPTOR_ETHDR0)
-			ret = mtk_merge_clk_enable(comp);
-		else
-			ret = mtk_ethdr_clk_enable(comp);
-		if (ret) {
-			dev_err(dev, "Failed to enable clock %d, err %d\n", i, ret);
-			goto clk_err;
+		if (!ovl_adaptor->ovl_adaptor_comp[i] ||
+		    !comp_matches[i].funcs->power_on)
+			continue;
+
+		ret = comp_matches[i].funcs->power_on(ovl_adaptor->ovl_adaptor_comp[i]);
+		if (ret < 0) {
+			dev_err(ovl_adaptor->ovl_adaptor_comp[i],
+				"Failed to power on: %d\n", ret);
+			power_off(dev, i);
+			return ret;
 		}
 	}
+	return 0;
+}
 
-	return ret;
-
-clk_err:
-	while (--i >= 0) {
-		comp = ovl_adaptor->ovl_adaptor_comp[i];
-		if (i < OVL_ADAPTOR_MERGE0)
-			mtk_mdp_rdma_clk_disable(comp);
-		else if (i < OVL_ADAPTOR_ETHDR0)
-			mtk_merge_clk_disable(comp);
-		else
-			mtk_ethdr_clk_disable(comp);
-	}
-	i = OVL_ADAPTOR_MERGE0;
+void mtk_ovl_adaptor_power_off(struct device *dev)
+{
+	power_off(dev, OVL_ADAPTOR_ID_MAX);
+}
 
-pwr_err:
-	while (--i >= 0)
-		pm_runtime_put(ovl_adaptor->ovl_adaptor_comp[i]);
+int mtk_ovl_adaptor_clk_enable(struct device *dev)
+{
+	int i;
+	int ret;
+	struct mtk_disp_ovl_adaptor *ovl_adaptor = dev_get_drvdata(dev);
 
-	return ret;
+	for (i = 0; i < OVL_ADAPTOR_ID_MAX; i++) {
+		dev = ovl_adaptor->ovl_adaptor_comp[i];
+		if (!dev)
+			continue;
+		ret = comp_matches[i].funcs->clk_enable(dev);
+		if (ret) {
+			while (--i >= 0)
+				comp_matches[i].funcs->clk_disable(dev);
+			return ret;
+		}
+	}
+	return 0;
 }
 
 void mtk_ovl_adaptor_clk_disable(struct device *dev)
 {
-	struct mtk_disp_ovl_adaptor *ovl_adaptor = dev_get_drvdata(dev);
-	struct device *comp;
 	int i;
+	struct mtk_disp_ovl_adaptor *ovl_adaptor = dev_get_drvdata(dev);
 
 	for (i = 0; i < OVL_ADAPTOR_ID_MAX; i++) {
-		comp = ovl_adaptor->ovl_adaptor_comp[i];
-
-		if (i < OVL_ADAPTOR_MERGE0) {
-			mtk_mdp_rdma_clk_disable(comp);
-			pm_runtime_put(comp);
-		} else if (i < OVL_ADAPTOR_ETHDR0) {
-			mtk_merge_clk_disable(comp);
-		} else {
-			mtk_ethdr_clk_disable(comp);
-		}
+		dev = ovl_adaptor->ovl_adaptor_comp[i];
+		if (!dev)
+			continue;
+		comp_matches[i].funcs->clk_disable(dev);
 	}
 }
 
@@ -313,40 +395,31 @@ size_t mtk_ovl_adaptor_get_num_formats(struct device *dev)
 
 void mtk_ovl_adaptor_add_comp(struct device *dev, struct mtk_mutex *mutex)
 {
-	mtk_mutex_add_comp(mutex, DDP_COMPONENT_MDP_RDMA0);
-	mtk_mutex_add_comp(mutex, DDP_COMPONENT_MDP_RDMA1);
-	mtk_mutex_add_comp(mutex, DDP_COMPONENT_MDP_RDMA2);
-	mtk_mutex_add_comp(mutex, DDP_COMPONENT_MDP_RDMA3);
-	mtk_mutex_add_comp(mutex, DDP_COMPONENT_MDP_RDMA4);
-	mtk_mutex_add_comp(mutex, DDP_COMPONENT_MDP_RDMA5);
-	mtk_mutex_add_comp(mutex, DDP_COMPONENT_MDP_RDMA6);
-	mtk_mutex_add_comp(mutex, DDP_COMPONENT_MDP_RDMA7);
-	mtk_mutex_add_comp(mutex, DDP_COMPONENT_MERGE1);
-	mtk_mutex_add_comp(mutex, DDP_COMPONENT_MERGE2);
-	mtk_mutex_add_comp(mutex, DDP_COMPONENT_MERGE3);
-	mtk_mutex_add_comp(mutex, DDP_COMPONENT_MERGE4);
-	mtk_mutex_add_comp(mutex, DDP_COMPONENT_ETHDR_MIXER);
+	int i;
+	struct mtk_disp_ovl_adaptor *ovl_adaptor = dev_get_drvdata(dev);
+
+	for (i = 0; i < OVL_ADAPTOR_ID_MAX; i++) {
+		if (!ovl_adaptor->ovl_adaptor_comp[i])
+			continue;
+		mtk_mutex_add_comp(mutex, comp_matches[i].comp_id);
+	}
 }
 
 void mtk_ovl_adaptor_remove_comp(struct device *dev, struct mtk_mutex *mutex)
 {
-	mtk_mutex_remove_comp(mutex, DDP_COMPONENT_MDP_RDMA0);
-	mtk_mutex_remove_comp(mutex, DDP_COMPONENT_MDP_RDMA1);
-	mtk_mutex_remove_comp(mutex, DDP_COMPONENT_MDP_RDMA2);
-	mtk_mutex_remove_comp(mutex, DDP_COMPONENT_MDP_RDMA3);
-	mtk_mutex_remove_comp(mutex, DDP_COMPONENT_MDP_RDMA4);
-	mtk_mutex_remove_comp(mutex, DDP_COMPONENT_MDP_RDMA5);
-	mtk_mutex_remove_comp(mutex, DDP_COMPONENT_MDP_RDMA6);
-	mtk_mutex_remove_comp(mutex, DDP_COMPONENT_MDP_RDMA7);
-	mtk_mutex_remove_comp(mutex, DDP_COMPONENT_MERGE1);
-	mtk_mutex_remove_comp(mutex, DDP_COMPONENT_MERGE2);
-	mtk_mutex_remove_comp(mutex, DDP_COMPONENT_MERGE3);
-	mtk_mutex_remove_comp(mutex, DDP_COMPONENT_MERGE4);
-	mtk_mutex_remove_comp(mutex, DDP_COMPONENT_ETHDR_MIXER);
+	int i;
+	struct mtk_disp_ovl_adaptor *ovl_adaptor = dev_get_drvdata(dev);
+
+	for (i = 0; i < OVL_ADAPTOR_ID_MAX; i++) {
+		if (!ovl_adaptor->ovl_adaptor_comp[i])
+			continue;
+		mtk_mutex_remove_comp(mutex, comp_matches[i].comp_id);
+	}
 }
 
 void mtk_ovl_adaptor_connect(struct device *dev, struct device *mmsys_dev, unsigned int next)
 {
+	mtk_mmsys_ddp_connect(mmsys_dev, DDP_COMPONENT_ETHDR_MIXER, next);
 	mtk_mmsys_ddp_connect(mmsys_dev, DDP_COMPONENT_MDP_RDMA0, DDP_COMPONENT_MERGE1);
 	mtk_mmsys_ddp_connect(mmsys_dev, DDP_COMPONENT_MDP_RDMA1, DDP_COMPONENT_MERGE1);
 	mtk_mmsys_ddp_connect(mmsys_dev, DDP_COMPONENT_MDP_RDMA2, DDP_COMPONENT_MERGE2);
@@ -354,11 +427,11 @@ void mtk_ovl_adaptor_connect(struct device *dev, struct device *mmsys_dev, unsig
 	mtk_mmsys_ddp_connect(mmsys_dev, DDP_COMPONENT_MERGE2, DDP_COMPONENT_ETHDR_MIXER);
 	mtk_mmsys_ddp_connect(mmsys_dev, DDP_COMPONENT_MERGE3, DDP_COMPONENT_ETHDR_MIXER);
 	mtk_mmsys_ddp_connect(mmsys_dev, DDP_COMPONENT_MERGE4, DDP_COMPONENT_ETHDR_MIXER);
-	mtk_mmsys_ddp_connect(mmsys_dev, DDP_COMPONENT_ETHDR_MIXER, next);
 }
 
 void mtk_ovl_adaptor_disconnect(struct device *dev, struct device *mmsys_dev, unsigned int next)
 {
+	mtk_mmsys_ddp_disconnect(mmsys_dev, DDP_COMPONENT_ETHDR_MIXER, next);
 	mtk_mmsys_ddp_disconnect(mmsys_dev, DDP_COMPONENT_MDP_RDMA0, DDP_COMPONENT_MERGE1);
 	mtk_mmsys_ddp_disconnect(mmsys_dev, DDP_COMPONENT_MDP_RDMA1, DDP_COMPONENT_MERGE1);
 	mtk_mmsys_ddp_disconnect(mmsys_dev, DDP_COMPONENT_MDP_RDMA2, DDP_COMPONENT_MERGE2);
@@ -366,7 +439,6 @@ void mtk_ovl_adaptor_disconnect(struct device *dev, struct device *mmsys_dev, un
 	mtk_mmsys_ddp_disconnect(mmsys_dev, DDP_COMPONENT_MERGE2, DDP_COMPONENT_ETHDR_MIXER);
 	mtk_mmsys_ddp_disconnect(mmsys_dev, DDP_COMPONENT_MERGE3, DDP_COMPONENT_ETHDR_MIXER);
 	mtk_mmsys_ddp_disconnect(mmsys_dev, DDP_COMPONENT_MERGE4, DDP_COMPONENT_ETHDR_MIXER);
-	mtk_mmsys_ddp_disconnect(mmsys_dev, DDP_COMPONENT_ETHDR_MIXER, next);
 }
 
 static int ovl_adaptor_comp_get_id(struct device *dev, struct device_node *node,
@@ -385,17 +457,11 @@ static int ovl_adaptor_comp_get_id(struct device *dev, struct device_node *node,
 }
 
 static const struct of_device_id mtk_ovl_adaptor_comp_dt_ids[] = {
-	{
-		.compatible = "mediatek,mt8195-vdo1-rdma",
-		.data = (void *)OVL_ADAPTOR_TYPE_RDMA,
-	}, {
-		.compatible = "mediatek,mt8195-disp-merge",
-		.data = (void *)OVL_ADAPTOR_TYPE_MERGE,
-	}, {
-		.compatible = "mediatek,mt8195-disp-ethdr",
-		.data = (void *)OVL_ADAPTOR_TYPE_ETHDR,
-	},
-	{},
+	{ .compatible = "mediatek,mt8188-padding", .data = (void *)OVL_ADAPTOR_TYPE_PADDING },
+	{ .compatible = "mediatek,mt8195-disp-ethdr", .data = (void *)OVL_ADAPTOR_TYPE_ETHDR },
+	{ .compatible = "mediatek,mt8195-disp-merge", .data = (void *)OVL_ADAPTOR_TYPE_MERGE },
+	{ .compatible = "mediatek,mt8195-vdo1-rdma", .data = (void *)OVL_ADAPTOR_TYPE_MDP_RDMA },
+	{ /* sentinel */ }
 };
 
 static int compare_of(struct device *dev, void *data)
diff --git a/drivers/gpu/drm/mediatek/mtk_dp.c b/drivers/gpu/drm/mediatek/mtk_dp.c
index e4c16ba9902dc0fe29b4af504487cf6c238d75d5..6e4b7bbe7de0eba196f06cbeed679671c8e5267c 100644
--- a/drivers/gpu/drm/mediatek/mtk_dp.c
+++ b/drivers/gpu/drm/mediatek/mtk_dp.c
@@ -145,6 +145,172 @@ struct mtk_dp_data {
 	u16 audio_m_div2_bit;
 };
 
+static const struct mtk_dp_efuse_fmt mt8188_edp_efuse_fmt[MTK_DP_CAL_MAX] = {
+	[MTK_DP_CAL_GLB_BIAS_TRIM] = {
+		.idx = 0,
+		.shift = 19,
+		.mask = 0x1f,
+		.min_val = 1,
+		.max_val = 0x1e,
+		.default_val = 0xf,
+	},
+	[MTK_DP_CAL_CLKTX_IMPSE] = {
+		.idx = 0,
+		.shift = 24,
+		.mask = 0xf,
+		.min_val = 1,
+		.max_val = 0xe,
+		.default_val = 0x8,
+	},
+	[MTK_DP_CAL_LN_TX_IMPSEL_PMOS_0] = {
+		.idx = 2,
+		.shift = 0,
+		.mask = 0xf,
+		.min_val = 1,
+		.max_val = 0xe,
+		.default_val = 0x8,
+	},
+	[MTK_DP_CAL_LN_TX_IMPSEL_PMOS_1] = {
+		.idx = 2,
+		.shift = 8,
+		.mask = 0xf,
+		.min_val = 1,
+		.max_val = 0xe,
+		.default_val = 0x8,
+	},
+	[MTK_DP_CAL_LN_TX_IMPSEL_PMOS_2] = {
+		.idx = 2,
+		.shift = 16,
+		.mask = 0xf,
+		.min_val = 1,
+		.max_val = 0xe,
+		.default_val = 0x8,
+	},
+	[MTK_DP_CAL_LN_TX_IMPSEL_PMOS_3] = {
+		.idx = 2,
+		.shift = 24,
+		.mask = 0xf,
+		.min_val = 1,
+		.max_val = 0xe,
+		.default_val = 0x8,
+	},
+	[MTK_DP_CAL_LN_TX_IMPSEL_NMOS_0] = {
+		.idx = 2,
+		.shift = 4,
+		.mask = 0xf,
+		.min_val = 1,
+		.max_val = 0xe,
+		.default_val = 0x8,
+	},
+	[MTK_DP_CAL_LN_TX_IMPSEL_NMOS_1] = {
+		.idx = 2,
+		.shift = 12,
+		.mask = 0xf,
+		.min_val = 1,
+		.max_val = 0xe,
+		.default_val = 0x8,
+	},
+	[MTK_DP_CAL_LN_TX_IMPSEL_NMOS_2] = {
+		.idx = 2,
+		.shift = 20,
+		.mask = 0xf,
+		.min_val = 1,
+		.max_val = 0xe,
+		.default_val = 0x8,
+	},
+	[MTK_DP_CAL_LN_TX_IMPSEL_NMOS_3] = {
+		.idx = 2,
+		.shift = 28,
+		.mask = 0xf,
+		.min_val = 1,
+		.max_val = 0xe,
+		.default_val = 0x8,
+	},
+};
+
+static const struct mtk_dp_efuse_fmt mt8188_dp_efuse_fmt[MTK_DP_CAL_MAX] = {
+	[MTK_DP_CAL_GLB_BIAS_TRIM] = {
+		.idx = 0,
+		.shift = 10,
+		.mask = 0x1f,
+		.min_val = 1,
+		.max_val = 0x1e,
+		.default_val = 0xf,
+	},
+	[MTK_DP_CAL_CLKTX_IMPSE] = {
+		.idx = 0,
+		.shift = 15,
+		.mask = 0xf,
+		.min_val = 1,
+		.max_val = 0xe,
+		.default_val = 0x8,
+	},
+	[MTK_DP_CAL_LN_TX_IMPSEL_PMOS_0] = {
+		.idx = 1,
+		.shift = 0,
+		.mask = 0xf,
+		.min_val = 1,
+		.max_val = 0xe,
+		.default_val = 0x8,
+	},
+	[MTK_DP_CAL_LN_TX_IMPSEL_PMOS_1] = {
+		.idx = 1,
+		.shift = 8,
+		.mask = 0xf,
+		.min_val = 1,
+		.max_val = 0xe,
+		.default_val = 0x8,
+	},
+	[MTK_DP_CAL_LN_TX_IMPSEL_PMOS_2] = {
+		.idx = 1,
+		.shift = 16,
+		.mask = 0xf,
+		.min_val = 1,
+		.max_val = 0xe,
+		.default_val = 0x8,
+	},
+	[MTK_DP_CAL_LN_TX_IMPSEL_PMOS_3] = {
+		.idx = 1,
+		.shift = 24,
+		.mask = 0xf,
+		.min_val = 1,
+		.max_val = 0xe,
+		.default_val = 0x8,
+	},
+	[MTK_DP_CAL_LN_TX_IMPSEL_NMOS_0] = {
+		.idx = 1,
+		.shift = 4,
+		.mask = 0xf,
+		.min_val = 1,
+		.max_val = 0xe,
+		.default_val = 0x8,
+	},
+	[MTK_DP_CAL_LN_TX_IMPSEL_NMOS_1] = {
+		.idx = 1,
+		.shift = 12,
+		.mask = 0xf,
+		.min_val = 1,
+		.max_val = 0xe,
+		.default_val = 0x8,
+	},
+	[MTK_DP_CAL_LN_TX_IMPSEL_NMOS_2] = {
+		.idx = 1,
+		.shift = 20,
+		.mask = 0xf,
+		.min_val = 1,
+		.max_val = 0xe,
+		.default_val = 0x8,
+	},
+	[MTK_DP_CAL_LN_TX_IMPSEL_NMOS_3] = {
+		.idx = 1,
+		.shift = 28,
+		.mask = 0xf,
+		.min_val = 1,
+		.max_val = 0xe,
+		.default_val = 0x8,
+	},
+};
+
 static const struct mtk_dp_efuse_fmt mt8195_edp_efuse_fmt[MTK_DP_CAL_MAX] = {
 	[MTK_DP_CAL_GLB_BIAS_TRIM] = {
 		.idx = 3,
@@ -2310,14 +2476,16 @@ mtk_dp_bridge_mode_valid(struct drm_bridge *bridge,
 {
 	struct mtk_dp *mtk_dp = mtk_dp_from_bridge(bridge);
 	u32 bpp = info->color_formats & DRM_COLOR_FORMAT_YCBCR422 ? 16 : 24;
+	u32 lane_count_min = min_t(u32, drm_dp_max_lane_count(mtk_dp->rx_cap),
+		mtk_dp->max_lanes);
 	u32 rate = min_t(u32, drm_dp_max_link_rate(mtk_dp->rx_cap) *
-			      drm_dp_max_lane_count(mtk_dp->rx_cap),
+			      lane_count_min,
 			 drm_dp_bw_code_to_link_rate(mtk_dp->max_linkrate) *
-			 mtk_dp->max_lanes);
+			 lane_count_min);
 
-	if (rate < mode->clock * bpp / 8)
+	if (rate * 97 / 100 < (mode->clock * bpp / 8) ) {
 		return MODE_CLOCK_HIGH;
-
+	}
 	return MODE_OK;
 }
 
@@ -2755,10 +2923,18 @@ static int mtk_dp_resume(struct device *dev)
 
 static SIMPLE_DEV_PM_OPS(mtk_dp_pm_ops, mtk_dp_suspend, mtk_dp_resume);
 
+static const struct mtk_dp_data mt8188_edp_data = {
+	.bridge_type = DRM_MODE_CONNECTOR_eDP,
+	.smc_cmd = MTK_DP_SIP_ATF_EDP_VIDEO_UNMUTE,
+	.efuse_fmt = mt8188_edp_efuse_fmt,
+	.audio_supported = false,
+	.audio_m_div2_bit = MT8188_AUDIO_M_CODE_MULT_DIV_SEL_DP_ENC0_P0_DIV_2,
+};
+
 static const struct mtk_dp_data mt8188_dp_data = {
 	.bridge_type = DRM_MODE_CONNECTOR_DisplayPort,
 	.smc_cmd = MTK_DP_SIP_ATF_VIDEO_UNMUTE,
-	.efuse_fmt = mt8195_dp_efuse_fmt,
+	.efuse_fmt = mt8188_dp_efuse_fmt,
 	.audio_supported = true,
 	.audio_pkt_in_hblank_area = true,
 	.audio_m_div2_bit = MT8188_AUDIO_M_CODE_MULT_DIV_SEL_DP_ENC0_P0_DIV_2,
@@ -2783,7 +2959,7 @@ static const struct mtk_dp_data mt8195_dp_data = {
 static const struct of_device_id mtk_dp_of_match[] = {
 	{
 		.compatible = "mediatek,mt8188-edp-tx",
-		.data = &mt8195_edp_data,
+		.data = &mt8188_edp_data,
 	},
 	{
 		.compatible = "mediatek,mt8188-dp-tx",
diff --git a/drivers/gpu/drm/mediatek/mtk_dpi.c b/drivers/gpu/drm/mediatek/mtk_dpi.c
index e09edffd91a69bf8aeaf70093f1d8b52016f2ffb..b83c147cbb11452169989a589f884f10939f26ce 100644
--- a/drivers/gpu/drm/mediatek/mtk_dpi.c
+++ b/drivers/gpu/drm/mediatek/mtk_dpi.c
@@ -967,20 +967,6 @@ static const struct mtk_dpi_conf mt8186_conf = {
 	.csc_enable_bit = CSC_ENABLE,
 };
 
-static const struct mtk_dpi_conf mt8188_dpintf_conf = {
-	.cal_factor = mt8195_dpintf_calculate_factor,
-	.max_clock_khz = 600000,
-	.output_fmts = mt8195_output_fmts,
-	.num_output_fmts = ARRAY_SIZE(mt8195_output_fmts),
-	.pixels_per_iter = 4,
-	.input_2pixel = false,
-	.dimension_mask = DPINTF_HPW_MASK,
-	.hvsize_mask = DPINTF_HSIZE_MASK,
-	.channel_swap_shift = DPINTF_CH_SWAP,
-	.yuv422_en_bit = DPINTF_YUV422_EN,
-	.csc_enable_bit = DPINTF_CSC_ENABLE,
-};
-
 static const struct mtk_dpi_conf mt8192_conf = {
 	.cal_factor = mt8183_calculate_factor,
 	.reg_h_fre_con = 0xe0,
@@ -1104,7 +1090,7 @@ static const struct of_device_id mtk_dpi_of_ids[] = {
 	{ .compatible = "mediatek,mt8173-dpi", .data = &mt8173_conf },
 	{ .compatible = "mediatek,mt8183-dpi", .data = &mt8183_conf },
 	{ .compatible = "mediatek,mt8186-dpi", .data = &mt8186_conf },
-	{ .compatible = "mediatek,mt8188-dp-intf", .data = &mt8188_dpintf_conf },
+	{ .compatible = "mediatek,mt8188-dp-intf", .data = &mt8195_dpintf_conf },
 	{ .compatible = "mediatek,mt8192-dpi", .data = &mt8192_conf },
 	{ .compatible = "mediatek,mt8195-dp-intf", .data = &mt8195_dpintf_conf },
 	{ /* sentinel */ },
diff --git a/drivers/gpu/drm/mediatek/mtk_drm_crtc.c b/drivers/gpu/drm/mediatek/mtk_drm_crtc.c
index aa21c947e67314ef6b5e148f2db1ebcff44fc718..94f6debc29e6240acbddf197986eca809484806c 100644
--- a/drivers/gpu/drm/mediatek/mtk_drm_crtc.c
+++ b/drivers/gpu/drm/mediatek/mtk_drm_crtc.c
@@ -6,7 +6,6 @@
 #include <linux/clk.h>
 #include <linux/dma-mapping.h>
 #include <linux/mailbox_controller.h>
-#include <linux/pm_runtime.h>
 #include <linux/soc/mediatek/mtk-cmdq.h>
 #include <linux/soc/mediatek/mtk-mmsys.h>
 #include <linux/soc/mediatek/mtk-mutex.h>
@@ -359,22 +358,16 @@ static int mtk_crtc_ddp_hw_init(struct mtk_drm_crtc *mtk_crtc)
 		drm_connector_list_iter_end(&conn_iter);
 	}
 
-	ret = pm_runtime_resume_and_get(crtc->dev->dev);
-	if (ret < 0) {
-		DRM_ERROR("Failed to enable power domain: %d\n", ret);
-		return ret;
-	}
-
 	ret = mtk_mutex_prepare(mtk_crtc->mutex);
 	if (ret < 0) {
 		DRM_ERROR("Failed to enable mutex clock: %d\n", ret);
-		goto err_pm_runtime_put;
+		goto error;
 	}
 
 	ret = mtk_crtc_ddp_clk_enable(mtk_crtc);
 	if (ret < 0) {
 		DRM_ERROR("Failed to enable component clocks: %d\n", ret);
-		goto err_mutex_unprepare;
+		goto error;
 	}
 
 	for (i = 0; i < mtk_crtc->ddp_comp_nr - 1; i++) {
@@ -420,16 +413,13 @@ static int mtk_crtc_ddp_hw_init(struct mtk_drm_crtc *mtk_crtc)
 
 	return 0;
 
-err_mutex_unprepare:
+error:
 	mtk_mutex_unprepare(mtk_crtc->mutex);
-err_pm_runtime_put:
-	pm_runtime_put(crtc->dev->dev);
 	return ret;
 }
 
 static void mtk_crtc_ddp_hw_fini(struct mtk_drm_crtc *mtk_crtc)
 {
-	struct drm_device *drm = mtk_crtc->base.dev;
 	struct drm_crtc *crtc = &mtk_crtc->base;
 	int i;
 
@@ -459,8 +449,6 @@ static void mtk_crtc_ddp_hw_fini(struct mtk_drm_crtc *mtk_crtc)
 	mtk_crtc_ddp_clk_disable(mtk_crtc);
 	mtk_mutex_unprepare(mtk_crtc->mutex);
 
-	pm_runtime_put(drm->dev);
-
 	if (crtc->state->event && !crtc->state->active) {
 		spin_lock_irq(&crtc->dev->event_lock);
 		drm_crtc_send_vblank_event(crtc, crtc->state->event);
@@ -720,7 +708,7 @@ static void mtk_drm_crtc_atomic_enable(struct drm_crtc *crtc,
 
 	DRM_DEBUG_DRIVER("%s %d\n", __func__, crtc->base.id);
 
-	ret = pm_runtime_resume_and_get(comp->dev);
+	ret = mtk_ddp_comp_power_on(comp);
 	if (ret < 0) {
 		DRM_DEV_ERROR(comp->dev, "Failed to enable power domain: %d\n", ret);
 		return;
@@ -730,7 +718,7 @@ static void mtk_drm_crtc_atomic_enable(struct drm_crtc *crtc,
 
 	ret = mtk_crtc_ddp_hw_init(mtk_crtc);
 	if (ret) {
-		pm_runtime_put(comp->dev);
+		mtk_ddp_comp_power_off(comp);
 		return;
 	}
 
@@ -743,7 +731,7 @@ static void mtk_drm_crtc_atomic_disable(struct drm_crtc *crtc,
 {
 	struct mtk_drm_crtc *mtk_crtc = to_mtk_crtc(crtc);
 	struct mtk_ddp_comp *comp = mtk_crtc->ddp_comp[0];
-	int i, ret;
+	int i;
 
 	DRM_DEBUG_DRIVER("%s %d\n", __func__, crtc->base.id);
 	if (!mtk_crtc->enabled)
@@ -773,9 +761,7 @@ static void mtk_drm_crtc_atomic_disable(struct drm_crtc *crtc,
 
 	drm_crtc_vblank_off(crtc);
 	mtk_crtc_ddp_hw_fini(mtk_crtc);
-	ret = pm_runtime_put(comp->dev);
-	if (ret < 0)
-		DRM_DEV_ERROR(comp->dev, "Failed to disable power domain: %d\n", ret);
+	mtk_ddp_comp_power_off(comp);
 
 	mtk_crtc->enabled = false;
 }
diff --git a/drivers/gpu/drm/mediatek/mtk_drm_ddp_comp.c b/drivers/gpu/drm/mediatek/mtk_drm_ddp_comp.c
index f3345af12cb82ab762a18f94a38851624ab621b9..9633e860cc3ce9220be4caa2ef0931f6b8f17934 100644
--- a/drivers/gpu/drm/mediatek/mtk_drm_ddp_comp.c
+++ b/drivers/gpu/drm/mediatek/mtk_drm_ddp_comp.c
@@ -396,6 +396,8 @@ static const struct mtk_ddp_comp_funcs ddp_ufoe = {
 };
 
 static const struct mtk_ddp_comp_funcs ddp_ovl_adaptor = {
+	.power_on = mtk_ovl_adaptor_power_on,
+	.power_off = mtk_ovl_adaptor_power_off,
 	.clk_enable = mtk_ovl_adaptor_clk_enable,
 	.clk_disable = mtk_ovl_adaptor_clk_disable,
 	.config = mtk_ovl_adaptor_config,
diff --git a/drivers/gpu/drm/mediatek/mtk_drm_ddp_comp.h b/drivers/gpu/drm/mediatek/mtk_drm_ddp_comp.h
index 0797b3ac75d8c41d424fcdf53cfa1de500d50a76..f8c7e8d8ddc12efa49f2395975b5d10437bd08ba 100644
--- a/drivers/gpu/drm/mediatek/mtk_drm_ddp_comp.h
+++ b/drivers/gpu/drm/mediatek/mtk_drm_ddp_comp.h
@@ -7,6 +7,7 @@
 #define MTK_DRM_DDP_COMP_H
 
 #include <linux/io.h>
+#include <linux/pm_runtime.h>
 #include <linux/soc/mediatek/mtk-cmdq.h>
 #include <linux/soc/mediatek/mtk-mmsys.h>
 #include <linux/soc/mediatek/mtk-mutex.h>
@@ -46,6 +47,8 @@ enum mtk_ddp_comp_type {
 struct mtk_ddp_comp;
 struct cmdq_pkt;
 struct mtk_ddp_comp_funcs {
+	int (*power_on)(struct device *dev);
+	void (*power_off)(struct device *dev);
 	int (*clk_enable)(struct device *dev);
 	void (*clk_disable)(struct device *dev);
 	void (*config)(struct device *dev, unsigned int w,
@@ -91,6 +94,23 @@ struct mtk_ddp_comp {
 	const struct mtk_ddp_comp_funcs *funcs;
 };
 
+static inline int mtk_ddp_comp_power_on(struct mtk_ddp_comp *comp)
+{
+	if (comp->funcs && comp->funcs->power_on)
+		return comp->funcs->power_on(comp->dev);
+	else
+		return pm_runtime_resume_and_get(comp->dev);
+	return 0;
+}
+
+static inline void mtk_ddp_comp_power_off(struct mtk_ddp_comp *comp)
+{
+	if (comp->funcs && comp->funcs->power_off)
+		comp->funcs->power_off(comp->dev);
+	else
+		pm_runtime_put(comp->dev);
+}
+
 static inline int mtk_ddp_comp_clk_enable(struct mtk_ddp_comp *comp)
 {
 	if (comp->funcs && comp->funcs->clk_enable)
diff --git a/drivers/gpu/drm/mediatek/mtk_drm_drv.c b/drivers/gpu/drm/mediatek/mtk_drm_drv.c
index e6bb94bf4726349fc94f71c85327cc0bd66bf9c3..f63847feb47fe7b85bc8ad35d21338c0d7c1923f 100644
--- a/drivers/gpu/drm/mediatek/mtk_drm_drv.c
+++ b/drivers/gpu/drm/mediatek/mtk_drm_drv.c
@@ -295,7 +295,7 @@ static const struct mtk_mmsys_driver_data mt8188_vdosys0_driver_data = {
 	.main_len = ARRAY_SIZE(mt8188_mtk_ddp_main),
 	.conn_routes = mt8188_mtk_ddp_main_routes,
 	.num_conn_routes = ARRAY_SIZE(mt8188_mtk_ddp_main_routes),
-	.mmsys_dev_num = 1,
+	.mmsys_dev_num = 2,
 };
 
 static const struct mtk_mmsys_driver_data mt8192_mmsys_driver_data = {
@@ -336,6 +336,8 @@ static const struct of_device_id mtk_drm_of_ids[] = {
 	  .data = &mt8186_mmsys_driver_data},
 	{ .compatible = "mediatek,mt8188-vdosys0",
 	  .data = &mt8188_vdosys0_driver_data},
+	{ .compatible = "mediatek,mt8188-vdosys1",
+	  .data = &mt8195_vdosys1_driver_data},
 	{ .compatible = "mediatek,mt8192-mmsys",
 	  .data = &mt8192_mmsys_driver_data},
 	{ .compatible = "mediatek,mt8195-mmsys",
@@ -1024,6 +1026,7 @@ static struct platform_driver * const mtk_drm_drivers[] = {
 	&mtk_dsi_driver,
 	&mtk_ethdr_driver,
 	&mtk_mdp_rdma_driver,
+	&mtk_padding_driver,
 };
 
 static int __init mtk_drm_init(void)
diff --git a/drivers/gpu/drm/mediatek/mtk_drm_drv.h b/drivers/gpu/drm/mediatek/mtk_drm_drv.h
index 6f98fff4f1a4c757e739df2e42d70a2ed3912fe7..33fadb08dc1c7be52ae3eceba7d392adbd2a914e 100644
--- a/drivers/gpu/drm/mediatek/mtk_drm_drv.h
+++ b/drivers/gpu/drm/mediatek/mtk_drm_drv.h
@@ -77,5 +77,5 @@ extern struct platform_driver mtk_dpi_driver;
 extern struct platform_driver mtk_dsi_driver;
 extern struct platform_driver mtk_ethdr_driver;
 extern struct platform_driver mtk_mdp_rdma_driver;
-
+extern struct platform_driver mtk_padding_driver;
 #endif /* MTK_DRM_DRV_H */
diff --git a/drivers/gpu/drm/mediatek/mtk_dsi.c b/drivers/gpu/drm/mediatek/mtk_dsi.c
index dc0d4bae4ff8a4e67b4ee5e5434238919e46bf55..cc69abd19e9d8f8b4b22a9c8a8b18d127d4e4ad7 100644
--- a/drivers/gpu/drm/mediatek/mtk_dsi.c
+++ b/drivers/gpu/drm/mediatek/mtk_dsi.c
@@ -83,6 +83,7 @@
 #define DSI_HSA_WC		0x50
 #define DSI_HBP_WC		0x54
 #define DSI_HFP_WC		0x58
+#define DSI_BLLP_WC		0x5C
 
 #define DSI_CMDQ_SIZE		0x60
 #define CMDQ_SIZE			0x3f
@@ -210,6 +211,7 @@ struct mtk_dsi {
 	u32 irq_data;
 	wait_queue_head_t irq_wait_queue;
 	const struct mtk_dsi_driver_data *driver_data;
+	unsigned int vdo_per_frame_lp_enable;
 };
 
 static inline struct mtk_dsi *bridge_to_dsi(struct drm_bridge *b)
@@ -239,7 +241,7 @@ static void mtk_dsi_phy_timconfig(struct mtk_dsi *dsi)
 	timing->da_hs_prepare = (80 * data_rate_mhz + 4 * 1000) / 8000;
 	timing->da_hs_zero = (170 * data_rate_mhz + 10 * 1000) / 8000 + 1 -
 			     timing->da_hs_prepare;
-	timing->da_hs_trail = timing->da_hs_prepare + 1;
+	timing->da_hs_trail = timing->da_hs_prepare;
 
 	timing->ta_go = 4 * timing->lpx - 2;
 	timing->ta_sure = timing->lpx + 2;
@@ -257,7 +259,7 @@ static void mtk_dsi_phy_timconfig(struct mtk_dsi *dsi)
 	timcon1 = timing->ta_go | timing->ta_sure << 8 |
 		  timing->ta_get << 16 | timing->da_hs_exit << 24;
 	timcon2 = 1 << 8 | timing->clk_hs_zero << 16 |
-		  timing->clk_hs_trail << 24;
+			  (timing->clk_hs_trail+2) << 24;
 	timcon3 = timing->clk_hs_prepare | timing->clk_hs_post << 8 |
 		  timing->clk_hs_exit << 16;
 
@@ -265,6 +267,8 @@ static void mtk_dsi_phy_timconfig(struct mtk_dsi *dsi)
 	writel(timcon1, dsi->regs + DSI_PHY_TIMECON1);
 	writel(timcon2, dsi->regs + DSI_PHY_TIMECON2);
 	writel(timcon3, dsi->regs + DSI_PHY_TIMECON3);
+	pr_notice("[###]222con0=0x%x \n", readl(dsi->regs + DSI_PHY_TIMECON0));
+	pr_notice("[###]222con2=0x%x \n", readl(dsi->regs + DSI_PHY_TIMECON2));
 }
 
 static void mtk_dsi_enable(struct mtk_dsi *dsi)
@@ -516,6 +520,83 @@ static void mtk_dsi_config_vdo_timing(struct mtk_dsi *dsi)
 			(vm->hactive * dsi_tmp_buf_bpp + 2) % dsi->lanes;
 	}
 
+	if (dsi->vdo_per_frame_lp_enable) {
+		unsigned int lpx = 0, da_hs_exit = 0, da_hs_prep = 0, da_hs_trail = 0;
+		unsigned int da_hs_zero = 0, ps_wc = 0, hs_vb_ps_wc = 0;
+		u32 bllp_wc, bllp_en, v_active_roundup, hstx_cklp_wc, hstx_cklp_wc_max, hstx_cklp_wc_min;
+
+		da_hs_trail = (readl(dsi->regs + DSI_PHY_TIMECON0) >> 24) & 0xff;
+		bllp_en = (readl(dsi->regs + DSI_TXRX_CTRL) >> 7) & 0x1;
+		if (dsi->mode_flags & MIPI_DSI_MODE_VIDEO_SYNC_PULSE) {
+			horizontal_sync_active_byte = (vm->hsync_len * dsi_tmp_buf_bpp - 10);
+
+			horizontal_backporch_byte = (vm->hback_porch * dsi_tmp_buf_bpp - 10);
+			horizontal_frontporch_byte = (vm->hfront_porch * dsi_tmp_buf_bpp - 12);
+
+			ps_wc = readl(dsi->regs + DSI_PSCTRL) & 0x7fff;
+			v_active_roundup = (32 + horizontal_sync_active_byte + horizontal_backporch_byte + ps_wc +
+				horizontal_frontporch_byte) % dsi->lanes;
+			if (v_active_roundup)
+				horizontal_backporch_byte = horizontal_backporch_byte + dsi->lanes - v_active_roundup;
+			hstx_cklp_wc_min = (DIV_ROUND_UP((12 + 4 + 4 + horizontal_sync_active_byte), dsi->lanes) + da_hs_trail + 1) * dsi->lanes / 6 - 1;
+			hstx_cklp_wc_max = (DIV_ROUND_UP((20 + 6 + 4 + horizontal_sync_active_byte + horizontal_backporch_byte + ps_wc)
+									, dsi->lanes) + da_hs_trail + 1) * dsi->lanes / 6 - 1;
+		} else {
+			horizontal_sync_active_byte = vm->hsync_len * dsi_tmp_buf_bpp - 4;
+
+			horizontal_backporch_byte =(vm->hback_porch + vm->hsync_len) * dsi_tmp_buf_bpp - 10;
+			hstx_cklp_wc_min = (DIV_ROUND_UP(4, dsi->lanes) + da_hs_trail + 1) * dsi->lanes / 6 - 1;
+
+			if (dsi->mode_flags & MIPI_DSI_MODE_VIDEO_BURST) {
+				ps_wc = readl(dsi->regs + DSI_PSCTRL) & 0x7fff;
+				bllp_wc = readl(dsi->regs + DSI_BLLP_WC) & 0xfff;
+				horizontal_frontporch_byte =(vm->hfront_porch * dsi_tmp_buf_bpp - 18);
+
+				v_active_roundup = (28 + horizontal_backporch_byte + ps_wc +
+					horizontal_frontporch_byte + bllp_wc) % dsi->lanes;
+				if (v_active_roundup)
+					horizontal_backporch_byte = horizontal_backporch_byte + dsi->lanes - v_active_roundup;
+				if (bllp_en) {
+					hstx_cklp_wc_max = (DIV_ROUND_UP((16 + 6 + 4 + horizontal_backporch_byte + bllp_wc + ps_wc)
+						, dsi->lanes) + da_hs_trail + 1) * dsi->lanes / 6 - 1;
+				} else {
+					hstx_cklp_wc_max = (DIV_ROUND_UP((12 + 4 + 4 + horizontal_backporch_byte + bllp_wc + ps_wc)
+						, dsi->lanes) + da_hs_trail + 1) * dsi->lanes / 6 - 1;
+				}
+			} else {
+				ps_wc = readl(dsi->regs + DSI_PSCTRL) & 0x7fff;
+				horizontal_frontporch_byte =(vm->hfront_porch * dsi_tmp_buf_bpp - 12);
+
+				v_active_roundup = (22 + horizontal_backporch_byte + ps_wc +
+					horizontal_frontporch_byte) % dsi->lanes;
+				if (v_active_roundup)
+					horizontal_backporch_byte = horizontal_backporch_byte + dsi->lanes - v_active_roundup;
+
+				hstx_cklp_wc_max = (DIV_ROUND_UP((12 + 4 + 4 + horizontal_backporch_byte + ps_wc)
+										, dsi->lanes) + da_hs_trail + 1) * dsi->lanes / 6 - 1;
+			}
+		}
+		hstx_cklp_wc = (readl(dsi->regs + DSI_HSTX_CKL_WC) >> 2) & 0x3fff;
+		if (hstx_cklp_wc <= hstx_cklp_wc_min || hstx_cklp_wc >= hstx_cklp_wc_max) {
+			hstx_cklp_wc = (hstx_cklp_wc_max / 2) << 2;
+			writel(hstx_cklp_wc, dsi->regs + DSI_HSTX_CKL_WC);
+		}
+		hstx_cklp_wc = hstx_cklp_wc >> 2;
+		if (hstx_cklp_wc <= hstx_cklp_wc_min || hstx_cklp_wc >= hstx_cklp_wc_max)
+			DRM_WARN("Wrong setting of hstx_ckl_wc will cause clock keep hs or fps to be inaccurate \n");
+
+		lpx = readl(dsi->regs + DSI_PHY_TIMECON0) & 0xff;
+		da_hs_exit = (readl(dsi->regs + DSI_PHY_TIMECON1) >> 24) & 0xff;
+		da_hs_prep = (readl(dsi->regs + DSI_PHY_TIMECON0) >> 8) & 0xff;
+		da_hs_zero = (readl(dsi->regs + DSI_PHY_TIMECON0) >> 16) & 0xff;
+		ps_wc = readl(dsi->regs + DSI_PSCTRL) & 0x7fff;
+		hs_vb_ps_wc = ps_wc -
+			(lpx + da_hs_exit + da_hs_prep + da_hs_zero + 2)
+			* dsi->lanes;
+		horizontal_frontporch_byte = (1 << 31)
+			| (hs_vb_ps_wc << 16)
+			| (horizontal_frontporch_byte);
+	}
 	writel(horizontal_sync_active_byte, dsi->regs + DSI_HSA_WC);
 	writel(horizontal_backporch_byte, dsi->regs + DSI_HBP_WC);
 	writel(horizontal_frontporch_byte, dsi->regs + DSI_HFP_WC);
@@ -932,6 +1013,8 @@ static int mtk_dsi_host_attach(struct mipi_dsi_host *host,
 	dsi->lanes = device->lanes;
 	dsi->format = device->format;
 	dsi->mode_flags = device->mode_flags;
+	dsi->vdo_per_frame_lp_enable = device->vdo_per_frame_lp_enable;
+
 	dsi->next_bridge = devm_drm_of_get_bridge(dev, dev->of_node, 0, 0);
 	if (IS_ERR(dsi->next_bridge))
 		return PTR_ERR(dsi->next_bridge);
diff --git a/drivers/gpu/drm/mediatek/mtk_mdp_rdma.c b/drivers/gpu/drm/mediatek/mtk_mdp_rdma.c
index 5746f06220c12e8398da6f6f76ac41cc3264451f..8feeb6dce217775b03d16eec0828545e0366885c 100644
--- a/drivers/gpu/drm/mediatek/mtk_mdp_rdma.c
+++ b/drivers/gpu/drm/mediatek/mtk_mdp_rdma.c
@@ -243,12 +243,27 @@ size_t mtk_mdp_rdma_get_num_formats(struct device *dev)
 	return ARRAY_SIZE(formats);
 }
 
+int mtk_mdp_rdma_power_on(struct device *dev)
+{
+	int ret = pm_runtime_resume_and_get(dev);
+
+	if (ret < 0) {
+		dev_err(dev, "Failed to power on: %d\n", ret);
+		return ret;
+	}
+	return 0;
+}
+
+void mtk_mdp_rdma_power_off(struct device *dev)
+{
+	pm_runtime_put(dev);
+}
+
 int mtk_mdp_rdma_clk_enable(struct device *dev)
 {
 	struct mtk_mdp_rdma *rdma = dev_get_drvdata(dev);
 
-	clk_prepare_enable(rdma->clk);
-	return 0;
+	return clk_prepare_enable(rdma->clk);
 }
 
 void mtk_mdp_rdma_clk_disable(struct device *dev)
diff --git a/drivers/gpu/drm/mediatek/mtk_padding.c b/drivers/gpu/drm/mediatek/mtk_padding.c
new file mode 100644
index 0000000000000000000000000000000000000000..14efb6ab2341a74a22c09dec59471d1590961a25
--- /dev/null
+++ b/drivers/gpu/drm/mediatek/mtk_padding.c
@@ -0,0 +1,160 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Copyright (c) 2023 MediaTek Inc.
+ */
+
+#include <linux/clk.h>
+#include <linux/component.h>
+#include <linux/module.h>
+#include <linux/of_device.h>
+#include <linux/platform_device.h>
+#include <linux/pm_runtime.h>
+#include <linux/soc/mediatek/mtk-cmdq.h>
+
+#include "mtk_disp_drv.h"
+#include "mtk_drm_crtc.h"
+#include "mtk_drm_ddp_comp.h"
+
+#define PADDING_CONTROL_REG	0x00
+#define PADDING_BYPASS			BIT(0)
+#define PADDING_ENABLE			BIT(1)
+#define PADDING_PIC_SIZE_REG	0x04
+#define PADDING_H_REG		0x08 /* horizontal */
+#define PADDING_V_REG		0x0c /* vertical */
+#define PADDING_COLOR_REG	0x10
+
+/**
+ * struct mtk_padding - Basic information of the Padding
+ * @clk: Clock of the module
+ * @reg: Virtual address of the Padding for CPU to access
+ * @cmdq_reg: CMDQ setting of the Padding
+ *
+ * Every Padding should have different clock source, register base, and
+ * CMDQ settings, we stored these differences all together.
+ */
+struct mtk_padding {
+	struct clk		*clk;
+	void __iomem		*reg;
+	struct cmdq_client_reg	cmdq_reg;
+};
+
+int mtk_padding_clk_enable(struct device *dev)
+{
+	struct mtk_padding *padding = dev_get_drvdata(dev);
+
+	return clk_prepare_enable(padding->clk);
+}
+
+void mtk_padding_clk_disable(struct device *dev)
+{
+	struct mtk_padding *padding = dev_get_drvdata(dev);
+
+	clk_disable_unprepare(padding->clk);
+}
+
+void mtk_padding_start(struct device *dev)
+{
+	struct mtk_padding *padding = dev_get_drvdata(dev);
+
+	writel(PADDING_ENABLE | PADDING_BYPASS,
+	       padding->reg + PADDING_CONTROL_REG);
+
+	/*
+	 * Notice that even the padding is in bypass mode,
+	 * all the settings must be cleared to 0 or
+	 * undefined behaviors could happen
+	 */
+	writel(0, padding->reg + PADDING_PIC_SIZE_REG);
+	writel(0, padding->reg + PADDING_H_REG);
+	writel(0, padding->reg + PADDING_V_REG);
+	writel(0, padding->reg + PADDING_COLOR_REG);
+}
+
+void mtk_padding_stop(struct device *dev)
+{
+	struct mtk_padding *padding = dev_get_drvdata(dev);
+
+	writel(0, padding->reg + PADDING_CONTROL_REG);
+}
+
+static int mtk_padding_bind(struct device *dev, struct device *master, void *data)
+{
+	return 0;
+}
+
+static void mtk_padding_unbind(struct device *dev, struct device *master, void *data)
+{
+}
+
+static const struct component_ops mtk_padding_component_ops = {
+	.bind	= mtk_padding_bind,
+	.unbind = mtk_padding_unbind,
+};
+
+static int mtk_padding_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct mtk_padding *priv;
+	struct resource *res;
+	int ret;
+
+	priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	priv->clk = devm_clk_get(dev, NULL);
+	if (IS_ERR(priv->clk)) {
+		dev_err(dev, "failed to get clk\n");
+		return PTR_ERR(priv->clk);
+	}
+
+	priv->reg = devm_platform_get_and_ioremap_resource(pdev, 0, &res);
+	if (IS_ERR(priv->reg)) {
+		dev_err(dev, "failed to do ioremap\n");
+		return PTR_ERR(priv->reg);
+	}
+
+#if IS_REACHABLE(CONFIG_MTK_CMDQ)
+	ret = cmdq_dev_get_client_reg(dev, &priv->cmdq_reg, 0);
+	if (ret) {
+		dev_err(dev, "failed to get gce client reg\n");
+		return ret;
+	}
+#endif
+
+	platform_set_drvdata(pdev, priv);
+
+	ret = devm_pm_runtime_enable(dev);
+	if (ret)
+		return ret;
+
+	ret = component_add(dev, &mtk_padding_component_ops);
+	if (ret) {
+		pm_runtime_disable(dev);
+		return dev_err_probe(dev, ret, "failed to add component\n");
+	}
+
+	return 0;
+}
+
+static int mtk_padding_remove(struct platform_device *pdev)
+{
+	component_del(&pdev->dev, &mtk_padding_component_ops);
+	return 0;
+}
+
+static const struct of_device_id mtk_padding_driver_dt_match[] = {
+	{ .compatible = "mediatek,mt8188-padding" },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, mtk_padding_driver_dt_match);
+
+struct platform_driver mtk_padding_driver = {
+	.probe		= mtk_padding_probe,
+	.remove		= mtk_padding_remove,
+	.driver		= {
+		.name	= "mediatek-disp-padding",
+		.owner	= THIS_MODULE,
+		.of_match_table = mtk_padding_driver_dt_match,
+	},
+};
diff --git a/drivers/gpu/drm/panel/panel-boe-tv101wum-nl6.c b/drivers/gpu/drm/panel/panel-boe-tv101wum-nl6.c
index df7727a58e7fddb8cb50b85a7eb4387c4a98f03e..7d4d823ee3250883e37e2c9a4fd328fc7ee5909c 100644
--- a/drivers/gpu/drm/panel/panel-boe-tv101wum-nl6.c
+++ b/drivers/gpu/drm/panel/panel-boe-tv101wum-nl6.c
@@ -37,6 +37,7 @@ struct panel_desc {
 	unsigned int lanes;
 	bool discharge_on_disable;
 	bool lp11_before_reset;
+	unsigned int vdo_per_frame_lp_enable;
 };
 
 struct boe_panel {
@@ -1573,6 +1574,7 @@ static const struct panel_desc boe_tv110c9m_desc = {
 			| MIPI_DSI_CLOCK_NON_CONTINUOUS
 			| MIPI_DSI_MODE_VIDEO_BURST,
 	.init_cmds = boe_tv110c9m_init_cmd,
+	.vdo_per_frame_lp_enable = 1,
 };
 
 static const struct drm_display_mode inx_hj110iz_default_mode = {
@@ -1904,6 +1906,8 @@ static int boe_panel_probe(struct mipi_dsi_device *dsi)
 	dsi->lanes = desc->lanes;
 	dsi->format = desc->format;
 	dsi->mode_flags = desc->mode_flags;
+	dsi->vdo_per_frame_lp_enable = desc->vdo_per_frame_lp_enable;
+
 	boe->desc = desc;
 	boe->dsi = dsi;
 	ret = boe_panel_add(boe);
diff --git a/drivers/mailbox/mtk-cmdq-mailbox.c b/drivers/mailbox/mtk-cmdq-mailbox.c
old mode 100644
new mode 100755
index 41bc650896ebee7b740a2a5704f0cc79fe30de24..ea0d418a0c8e358a2ee0970c409db8032df32fb9
--- a/drivers/mailbox/mtk-cmdq-mailbox.c
+++ b/drivers/mailbox/mtk-cmdq-mailbox.c
@@ -12,6 +12,9 @@
 #include <linux/iopoll.h>
 #include <linux/kernel.h>
 #include <linux/module.h>
+#include <linux/timer.h>
+#include <linux/workqueue.h>
+#include <linux/sched/clock.h>
 #include <linux/platform_device.h>
 #include <linux/mailbox_controller.h>
 #include <linux/mailbox/mtk-cmdq-mailbox.h>
@@ -22,6 +25,8 @@
 #define CMDQ_GCE_NUM_MAX		(2)
 
 #define CMDQ_CURR_IRQ_STATUS		0x10
+#define CMDQ_SYNC_TOKEN_ID 		0x60
+#define CMDQ_SYNC_TOKEN_VALUE		0x64
 #define CMDQ_SYNC_TOKEN_UPDATE		0x68
 #define CMDQ_THR_SLOT_CYCLES		0x30
 #define CMDQ_THR_BASE			0x100
@@ -36,7 +41,6 @@
 #define CMDQ_THR_END_ADDR		0x24
 #define CMDQ_THR_WAIT_TOKEN		0x30
 #define CMDQ_THR_PRIORITY		0x40
-#define CMDQ_THR_INSTN_TIMEOUT_CYCLES	0x50
 
 #define GCE_GCTL_VALUE			0x48
 #define GCE_CTRL_BY_SW				GENMASK(2, 0)
@@ -57,20 +61,16 @@
 #define CMDQ_JUMP_BY_OFFSET		0x10000000
 #define CMDQ_JUMP_BY_PA			0x10000001
 
-/*
- * instruction time-out
- * cycles to issue instruction time-out interrupt for wait and poll instructions
- * GCE axi_clock 156MHz
- * 1 cycle = 6.41ns
- * instruction time out 2^22*2*6.41ns = 53ms
- */
-#define CMDQ_INSTN_TIMEOUT_CYCLES	22
-
 struct cmdq_thread {
 	struct mbox_chan	*chan;
 	void __iomem		*base;
 	struct list_head	task_busy_list;
+	struct timer_list	timeout;
+	u32			timeout_ms;
+	struct work_struct	timeout_work;
+	u64			timer_mod;
 	u32			priority;
+	u32			idx;
 };
 
 struct cmdq_task {
@@ -94,6 +94,9 @@ struct cmdq {
 	bool			control_by_sw;
 	bool			sw_ddr_en;
 	u32			gce_num;
+	struct workqueue_struct	*timeout_wq;
+	spinlock_t		event_lock;
+	struct cmdq_backup_event_list	*cmdq_backup_event_list;
 };
 
 struct gce_plat {
@@ -106,14 +109,10 @@ struct gce_plat {
 
 static void cmdq_sw_ddr_enable(struct cmdq *cmdq, bool enable)
 {
-	WARN_ON(clk_bulk_enable(cmdq->gce_num, cmdq->clocks));
-
 	if (enable)
 		writel(GCE_DDR_EN | GCE_CTRL_BY_SW, cmdq->base + GCE_GCTL_VALUE);
 	else
 		writel(GCE_CTRL_BY_SW, cmdq->base + GCE_GCTL_VALUE);
-
-	clk_bulk_disable(cmdq->gce_num, cmdq->clocks);
 }
 
 u8 cmdq_get_shift_pa(struct mbox_chan *chan)
@@ -124,6 +123,38 @@ u8 cmdq_get_shift_pa(struct mbox_chan *chan)
 }
 EXPORT_SYMBOL(cmdq_get_shift_pa);
 
+void cmdq_set_event(void *chan, u16 event_id)
+{
+	struct cmdq *cmdq = container_of(((struct mbox_chan *)chan)->mbox,
+		typeof(*cmdq), mbox);
+	unsigned long flags;
+
+	spin_lock_irqsave(&cmdq->event_lock, flags);
+
+	writel((1L << 16) | event_id, cmdq->base + CMDQ_SYNC_TOKEN_UPDATE);
+
+	spin_unlock_irqrestore(&cmdq->event_lock, flags);
+}
+EXPORT_SYMBOL(cmdq_set_event);
+
+u32 cmdq_get_event(void *chan, u16 event_id)
+{
+	struct cmdq *cmdq = container_of(((struct mbox_chan *)chan)->mbox,
+		typeof(*cmdq), mbox);
+	unsigned long flags;
+	u32 val = 0;
+
+	spin_lock_irqsave(&cmdq->event_lock, flags);
+
+	writel(0x3FF & event_id, cmdq->base + CMDQ_SYNC_TOKEN_ID);
+	val = readl(cmdq->base + CMDQ_SYNC_TOKEN_VALUE);
+
+	spin_unlock_irqrestore(&cmdq->event_lock, flags);
+
+	return val;
+}
+EXPORT_SYMBOL(cmdq_get_event);
+
 static int cmdq_thread_suspend(struct cmdq *cmdq, struct cmdq_thread *thread)
 {
 	u32 status;
@@ -154,7 +185,6 @@ static void cmdq_init(struct cmdq *cmdq)
 	int i;
 	u32 gctl_regval = 0;
 
-	WARN_ON(clk_bulk_enable(cmdq->gce_num, cmdq->clocks));
 	if (cmdq->control_by_sw)
 		gctl_regval = GCE_CTRL_BY_SW;
 	if (cmdq->sw_ddr_en)
@@ -169,7 +199,6 @@ static void cmdq_init(struct cmdq *cmdq)
 	writel(CMDQ_THR_ACTIVE_SLOT_CYCLES, cmdq->base + CMDQ_THR_SLOT_CYCLES);
 	for (i = 0; i <= CMDQ_MAX_EVENT; i++)
 		writel(i, cmdq->base + CMDQ_SYNC_TOKEN_UPDATE);
-	clk_bulk_disable(cmdq->gce_num, cmdq->clocks);
 }
 
 static int cmdq_thread_reset(struct cmdq *cmdq, struct cmdq_thread *thread)
@@ -300,9 +329,157 @@ static void cmdq_thread_irq_handler(struct cmdq *cmdq,
 			break;
 	}
 
-	if (list_empty(&thread->task_busy_list)) {
+	if (!task) {
 		cmdq_thread_disable(cmdq, thread);
-		clk_bulk_disable(cmdq->gce_num, cmdq->clocks);
+		pr_debug("empty task thread:%u", thread->idx);
+	} else {
+		mod_timer(&thread->timeout, jiffies +
+			  msecs_to_jiffies(thread->timeout_ms));
+		thread->timer_mod = sched_clock();
+		pr_debug("mod_timer pkt:0x%p timeout:%u thread:%u",
+		         task->pkt, thread->timeout_ms, thread->idx);
+	}
+}
+
+static bool cmdq_thread_timeout_excceed(struct cmdq_thread *thread)
+{
+	u64 duration;
+
+	/* If first time exec time stamp smaller than timeout value,
+	* it is last round timeout. Skip it.
+	*/
+	duration = div_s64(sched_clock() - thread->timer_mod, 1000000);
+	if (duration < thread->timeout_ms) {
+	    mod_timer(&thread->timeout, jiffies +
+		    msecs_to_jiffies(thread->timeout_ms - duration));
+	    thread->timer_mod = sched_clock();
+	    pr_info("thread:%u mod time:%llu dur:%llu timeout not excceed",
+		    thread->idx, thread->timer_mod, duration);
+	    return false;
+	}
+
+	return true;
+}
+
+static void cmdq_thread_handle_timeout_work(struct work_struct *work_item)
+{
+	struct cmdq_thread *thread = container_of(work_item,
+	    struct cmdq_thread, timeout_work);
+	struct cmdq *cmdq = container_of(thread->chan->mbox, struct cmdq, mbox);
+	struct cmdq_task *task, *tmp, *timeout_task = NULL;
+	unsigned long flags;
+	dma_addr_t pa_curr;
+	struct list_head removes;
+
+	INIT_LIST_HEAD(&removes);
+
+	spin_lock_irqsave(&thread->chan->lock, flags);
+	if (list_empty(&thread->task_busy_list)) {
+	    spin_unlock_irqrestore(&thread->chan->lock, flags);
+	    return;
+	}
+
+	/* Check before suspend thread to prevent hurt performance. */
+	if (!cmdq_thread_timeout_excceed(thread)) {
+	    spin_unlock_irqrestore(&thread->chan->lock, flags);
+	    return;
+	}
+
+	WARN_ON(cmdq_thread_suspend(cmdq, thread) < 0);
+
+	/*
+	* Although IRQ is disabled, GCE continues to execute.
+	* It may have pending IRQ before GCE thread is suspended,
+	* so check this condition again.
+	*/
+	cmdq_thread_irq_handler(cmdq, thread);
+
+	if (list_empty(&thread->task_busy_list)) {
+	    pr_err("thread:%u empty after irq handle in timeout", thread->idx);
+	    goto unlock_free_done;
+	}
+
+	/* After IRQ, first task may change. */
+	if (!cmdq_thread_timeout_excceed(thread)) {
+	    cmdq_thread_resume(thread);
+	    goto unlock_free_done;
+	}
+
+	pr_err("timeout for thread:0x%p idx:%u", thread->base, thread->idx);
+
+	pa_curr = readl(thread->base + CMDQ_THR_CURR_ADDR) << cmdq->shift_pa;
+
+	list_for_each_entry_safe(task, tmp, &thread->task_busy_list,
+				 list_entry) {
+		u32 task_end_pa = task->pa_base + task->pkt->cmd_buf_size;
+
+		if (pa_curr >= task->pa_base && pa_curr < task_end_pa) {
+			timeout_task = task;
+			break;
+		}
+
+		pr_info("ending not curr in timeout pkt:0x%p curr_pa:%pa", task->pkt, &pa_curr);
+		cmdq_task_exec_done(task, 0);
+		kfree(task);
+	}
+
+	if (timeout_task) {
+		spin_unlock_irqrestore(&thread->chan->lock, flags);
+
+		cmdq_task_exec_done(timeout_task, -ETIMEDOUT);
+
+		spin_lock_irqsave(&thread->chan->lock, flags);
+
+		task = list_first_entry_or_null(&thread->task_busy_list,
+		    struct cmdq_task, list_entry);
+		if (timeout_task == task) {
+			cmdq_task_exec_done(task, -ETIMEDOUT);
+			kfree(task);
+		} else {
+			pr_err("task list changed");
+		}
+	}
+
+	task = list_first_entry_or_null(&thread->task_busy_list,
+					struct cmdq_task, list_entry);
+	if (task) {
+	    mod_timer(&thread->timeout, jiffies +
+		    msecs_to_jiffies(thread->timeout_ms));
+	    thread->timer_mod = sched_clock();
+	    cmdq_thread_reset(cmdq, thread);
+	    cmdq_thread_resume(thread);
+	} else {
+	    cmdq_thread_resume(thread);
+	    cmdq_thread_disable(cmdq, thread);
+	}
+
+unlock_free_done:
+	spin_unlock_irqrestore(&thread->chan->lock, flags);
+
+	list_for_each_entry_safe(task, tmp, &removes, list_entry) {
+	    list_del(&task->list_entry);
+	    kfree(task);
+	}
+}
+
+static void cmdq_thread_handle_timeout(struct timer_list *t)
+{
+	struct cmdq_thread *thread = from_timer(thread, t, timeout);
+	struct cmdq *cmdq = container_of(thread->chan->mbox, struct cmdq, mbox);
+	unsigned long flags;
+	bool empty;
+
+	spin_lock_irqsave(&thread->chan->lock, flags);
+	empty = list_empty(&thread->task_busy_list);
+	spin_unlock_irqrestore(&thread->chan->lock, flags);
+	if (empty)
+	    return;
+
+	if (!work_pending(&thread->timeout_work)) {
+	    pr_debug("queue cmdq timeout thread:%u", thread->idx);
+	    queue_work(cmdq->timeout_wq, &thread->timeout_work);
+	} else {
+	    pr_info("ignore cmdq timeout thread:%u", thread->idx);
 	}
 }
 
@@ -350,7 +527,7 @@ static int cmdq_suspend(struct device *dev)
 	if (cmdq->sw_ddr_en)
 		cmdq_sw_ddr_enable(cmdq, false);
 
-	clk_bulk_unprepare(cmdq->gce_num, cmdq->clocks);
+	clk_bulk_disable_unprepare(cmdq->gce_num, cmdq->clocks);
 
 	return 0;
 }
@@ -359,7 +536,7 @@ static int cmdq_resume(struct device *dev)
 {
 	struct cmdq *cmdq = dev_get_drvdata(dev);
 
-	WARN_ON(clk_bulk_prepare(cmdq->gce_num, cmdq->clocks));
+	WARN_ON(clk_bulk_prepare_enable(cmdq->gce_num, cmdq->clocks));
 	cmdq->suspended = false;
 
 	if (cmdq->sw_ddr_en)
@@ -375,7 +552,7 @@ static int cmdq_remove(struct platform_device *pdev)
 	if (cmdq->sw_ddr_en)
 		cmdq_sw_ddr_enable(cmdq, false);
 
-	clk_bulk_unprepare(cmdq->gce_num, cmdq->clocks);
+	clk_bulk_disable_unprepare(cmdq->gce_num, cmdq->clocks);
 	return 0;
 }
 
@@ -401,8 +578,6 @@ static int cmdq_mbox_send_data(struct mbox_chan *chan, void *data)
 	task->pkt = pkt;
 
 	if (list_empty(&thread->task_busy_list)) {
-		WARN_ON(clk_bulk_enable(cmdq->gce_num, cmdq->clocks));
-
 		/*
 		 * The thread reset will clear thread related register to 0,
 		 * including pc, end, priority, irq, suspend and enable. Thus
@@ -416,10 +591,14 @@ static int cmdq_mbox_send_data(struct mbox_chan *chan, void *data)
 		writel((task->pa_base + pkt->cmd_buf_size) >> cmdq->shift_pa,
 		       thread->base + CMDQ_THR_END_ADDR);
 
-		writel(CMDQ_INSTN_TIMEOUT_CYCLES, thread->base + CMDQ_THR_INSTN_TIMEOUT_CYCLES);
 		writel(thread->priority, thread->base + CMDQ_THR_PRIORITY);
 		writel(CMDQ_THR_IRQ_EN, thread->base + CMDQ_THR_IRQ_ENABLE);
 		writel(CMDQ_THR_ENABLED, thread->base + CMDQ_THR_ENABLE_TASK);
+		if (thread->timeout_ms != 0) {
+			mod_timer(&thread->timeout, jiffies +
+				msecs_to_jiffies(thread->timeout_ms));
+			thread->timer_mod = sched_clock();
+		}
 	} else {
 		WARN_ON(cmdq_thread_suspend(cmdq, thread) < 0);
 		curr_pa = readl(thread->base + CMDQ_THR_CURR_ADDR) <<
@@ -475,8 +654,6 @@ static void cmdq_mbox_shutdown(struct mbox_chan *chan)
 	}
 
 	cmdq_thread_disable(cmdq, thread);
-	clk_bulk_disable(cmdq->gce_num, cmdq->clocks);
-
 done:
 	/*
 	 * The thread->task_busy_list empty means thread already disable. The
@@ -515,7 +692,6 @@ static int cmdq_mbox_flush(struct mbox_chan *chan, unsigned long timeout)
 
 	cmdq_thread_resume(thread);
 	cmdq_thread_disable(cmdq, thread);
-	clk_bulk_disable(cmdq->gce_num, cmdq->clocks);
 
 out:
 	spin_unlock_irqrestore(&thread->chan->lock, flags);
@@ -647,10 +823,14 @@ static int cmdq_probe(struct platform_device *pdev)
 		return -ENOMEM;
 
 	for (i = 0; i < cmdq->thread_nr; i++) {
+		cmdq->thread[i].idx = i;
 		cmdq->thread[i].base = cmdq->base + CMDQ_THR_BASE +
 				CMDQ_THR_SIZE * i;
+		cmdq->thread[i].timeout_ms = CMDQ_TIMEOUT_DEFAULT;
 		INIT_LIST_HEAD(&cmdq->thread[i].task_busy_list);
 		cmdq->mbox.chans[i].con_priv = (void *)&cmdq->thread[i];
+		timer_setup(&cmdq->thread[i].timeout, cmdq_thread_handle_timeout, 0);
+		INIT_WORK(&cmdq->thread[i].timeout_work, cmdq_thread_handle_timeout_work);
 	}
 
 	err = devm_mbox_controller_register(dev, &cmdq->mbox);
@@ -659,9 +839,12 @@ static int cmdq_probe(struct platform_device *pdev)
 		return err;
 	}
 
+	cmdq->timeout_wq = create_singlethread_workqueue("cmdq_timeout_handler");
+
 	platform_set_drvdata(pdev, cmdq);
 
-	WARN_ON(clk_bulk_prepare(cmdq->gce_num, cmdq->clocks));
+	WARN_ON(clk_bulk_prepare_enable(cmdq->gce_num, cmdq->clocks));
+	spin_lock_init(&cmdq->event_lock);
 
 	cmdq_init(cmdq);
 
@@ -716,6 +899,14 @@ static const struct gce_plat gce_plat_v7 = {
 	.gce_num = 1
 };
 
+static const struct gce_plat gce_plat_v8 = {
+        .thread_nr = 32,
+        .shift = 3,
+        .control_by_sw = true,
+        .sw_ddr_en = true,
+        .gce_num = 2
+};
+
 static const struct of_device_id cmdq_of_ids[] = {
 	{.compatible = "mediatek,mt8173-gce", .data = (void *)&gce_plat_v2},
 	{.compatible = "mediatek,mt8183-gce", .data = (void *)&gce_plat_v3},
@@ -723,6 +914,7 @@ static const struct of_device_id cmdq_of_ids[] = {
 	{.compatible = "mediatek,mt6779-gce", .data = (void *)&gce_plat_v4},
 	{.compatible = "mediatek,mt8192-gce", .data = (void *)&gce_plat_v5},
 	{.compatible = "mediatek,mt8195-gce", .data = (void *)&gce_plat_v6},
+	{.compatible = "mediatek,mt8188-gce", .data = (void *)&gce_plat_v8},
 	{}
 };
 
diff --git a/drivers/media/i2c/Kconfig b/drivers/media/i2c/Kconfig
old mode 100644
new mode 100755
index 8ecd9bdc5b45d6f9253958b25b7f2b1211d0f492..c282fcf773116dab207d0946fe036a0e0450409f
--- a/drivers/media/i2c/Kconfig
+++ b/drivers/media/i2c/Kconfig
@@ -93,6 +93,19 @@ config VIDEO_HI847
           To compile this driver as a module, choose M here: the
           module will be called hi847.
 
+config VIDEO_HI1339
+	tristate "Hynix Hi-1339 sensor support"
+	depends on I2C && VIDEO_DEV
+	select MEDIA_CONTROLLER
+	select VIDEO_V4L2_SUBDEV_API
+	select V4L2_FWNODE
+	help
+	  This is a Video4Linux2 sensor driver for the Hynix
+	  Hi-1339 camera.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called hi1339.
+
 config VIDEO_IMX208
 	tristate "Sony IMX208 sensor support"
 	depends on I2C && VIDEO_DEV
@@ -865,6 +878,18 @@ config VIDEO_DW9807_VCM
 	  capability. This is designed for linear control of
 	  voice coil motors, controlled via I2C serial interface.
 
+config VIDEO_GT97XX
+	tristate "GT97xx lens voice coil support"
+	depends on I2C && VIDEO_DEV
+	select MEDIA_CONTROLLER
+	select VIDEO_V4L2_SUBDEV_API
+	select V4L2_FWNODE
+	help
+	  This is a driver for the GT97xx camera lens voice coil.
+	  GT97xx is a 10 bit DAC with 100mA output current sink
+	  capability. It is designed for linear control of
+	  voice coil motors, controlled via I2C serial interface.	  
+	  
 endmenu
 
 menu "Flash devices"
@@ -1613,6 +1638,34 @@ config VIDEO_THS7303
 	  To compile this driver as a module, choose M here: the
 	  module will be called ths7303.
 
+config VIDEO_GC05A2
+	tristate "GalaxyCore gc05a2 sensor support"
+	depends on GPIOLIB && I2C && VIDEO_DEV
+	select V4L2_FWNODE
+	select MEDIA_CONTROLLER
+	select VIDEO_V4L2_SUBDEV_API
+	select REGMAP_I2C
+	help
+	  This is a Video4Linux2 sensor driver for the GalaxyCore gc05a2
+	  camera.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called gc05a2.	  	  
+	  
+config VIDEO_GC08A3
+	tristate "GalaxyCore gc08a3 sensor support"
+	depends on GPIOLIB && I2C && VIDEO_DEV
+	select V4L2_FWNODE
+	select MEDIA_CONTROLLER
+	select VIDEO_V4L2_SUBDEV_API
+	select REGMAP_I2C
+	help
+	  This is a Video4Linux2 sensor driver for the GalaxyCore gc08a3
+	  camera.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called gc08a3.	  
+
 endmenu
 
 endif # VIDEO_DEV
diff --git a/drivers/media/i2c/Makefile b/drivers/media/i2c/Makefile
old mode 100644
new mode 100755
index 83be451ef326a5d0056c7ab4a0391fab0b691d19..491c94c69c08fc864aa136290f490fddf01d9343
--- a/drivers/media/i2c/Makefile
+++ b/drivers/media/i2c/Makefile
@@ -33,9 +33,13 @@ obj-$(CONFIG_VIDEO_DW9714) += dw9714.o
 obj-$(CONFIG_VIDEO_DW9768) += dw9768.o
 obj-$(CONFIG_VIDEO_DW9807_VCM) += dw9807-vcm.o
 obj-$(CONFIG_VIDEO_ET8EK8) += et8ek8/
+obj-$(CONFIG_VIDEO_GC05A2) += gc05a2.o
+obj-$(CONFIG_VIDEO_GC08A3) += gc08a3.o
+obj-$(CONFIG_VIDEO_GT97XX) += gt97xx.o
 obj-$(CONFIG_VIDEO_HI556) += hi556.o
 obj-$(CONFIG_VIDEO_HI846) += hi846.o
 obj-$(CONFIG_VIDEO_HI847) += hi847.o
+obj-$(CONFIG_VIDEO_HI1339) += hi1339.o
 obj-$(CONFIG_VIDEO_I2C) += video-i2c.o
 obj-$(CONFIG_VIDEO_IMX208) += imx208.o
 obj-$(CONFIG_VIDEO_IMX214) += imx214.o
diff --git a/drivers/media/i2c/gc05a2.c b/drivers/media/i2c/gc05a2.c
new file mode 100755
index 0000000000000000000000000000000000000000..4348f75452c24fc4e0f9408edcd380321dd606f2
--- /dev/null
+++ b/drivers/media/i2c/gc05a2.c
@@ -0,0 +1,1904 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * gc05a2.c - gc05a2 sensor driver
+ *
+ * Copyright 2023 Mediatek
+ *
+ * Zhi Mao <zhi.mao@mediatek.com>
+ */
+
+#include <asm/unaligned.h>
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/gpio/consumer.h>
+#include <linux/i2c.h>
+#include <linux/module.h>
+#include <linux/pm_runtime.h>
+#include <linux/regmap.h>
+#include <linux/regulator/consumer.h>
+#include <media/media-entity.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-fwnode.h>
+#include <media/v4l2-subdev.h>
+
+//=========================================
+#define GC05A2_REG_VALUE_08BIT		1
+#define GC05A2_REG_VALUE_16BIT		2
+//#define GC05A2_REG_VALUE_24BIT		3
+
+#define GC05A2_REG_CHIP_ID			0x03f0
+#define GC05A2_CHIP_ID				0x05a2
+
+#define GC05A2_REG_TEST_PATTERN_EN	0x008c
+#define GC05A2_REG_TEST_PATTERN_IDX	0x008d
+#define GC05A2_TEST_PATTERN_EN	    0x01
+
+#define GC05A2_STRAEMING_REG		0x0100
+
+#define GC05A2_SCLK					224000000LL
+
+#define GC05A2_DEFAULT_CLK_FREQ		24000000
+#define GC05A2_FPS					30
+#define GC05A2_MBUS_CODE			MEDIA_BUS_FMT_SGRBG10_1X10
+
+#define GC05A2_DATA_LANES			2
+
+//for 1280*720@60fps
+#define GC05A2_LINK_FREQ_224MHZ		224000000ULL
+//for 2592*1944@30fps
+#define GC05A2_LINK_FREQ_448MHZ		448000000ULL
+
+
+#define GC05A2_RGB_DEPTH			10
+
+//frame length
+#define GC05A2_FL_REG				0x0340
+#define GC05A2_VTS_30FPS			2032
+#define GC05A2_VTS_30FPS_MIN		2032
+#define GC05A2_VTS_60FPS			1032
+#define GC05A2_VTS_60FPS_MIN		1032
+#define GC05A2_VTS_MAX				0xffff
+
+// line length
+#define GC05A2_LL_REG				0x0342
+#define GC05A2_HTS_30FPS			3664
+#define GC05A2_HTS_60FPS			3616
+
+
+#define GC05A2_EXP_REG				0x0202
+#define GC05A2_EXP_MARGIN			16
+#define GC05A2_EXP_MIN		        4
+#define GC05A2_EXP_STEP		        1
+
+#define GC05A2_FLIP_REG				0x0101
+#define GC05A2_FLIP_H_MASK			0x1
+#define GC05A2_FLIP_V_MASK			0x2
+
+#define GC05A2_AGAIN_REG			0x0204
+#define GC05A2_AGAIN_MIN			1024
+#define GC05A2_AGAIN_MAX			1024*16
+#define GC05A2_AGAIN_STEP			1
+//============================================================
+
+//============================================================
+static const char *const gc05a2_test_pattern_menu[] = {
+	"No Pattern",
+	"Color Bar",
+	"Fade_to_gray_Color Bar",
+	"PN9",
+	"Horizental_gradient",
+	"Checkboard Pattern",
+	"Slant",
+	"Resolution",
+	"Solid Black",
+	"Solid White",
+};
+
+enum {
+	GC05A2_LINK_FREQ_448MHZ_CFG,
+	GC05A2_LINK_FREQ_224MHZ_CFG,
+};
+
+static const s64 link_freq_menu_items[] = {
+    GC05A2_LINK_FREQ_448MHZ,
+    GC05A2_LINK_FREQ_224MHZ,
+};
+
+static const char *const gc05a2_supply_name[] = {
+	"avdd",
+	"dvdd",
+	"dovdd",
+};
+
+#define GC05A2_NUM_SUPPLIES ARRAY_SIZE(gc05a2_supply_name)
+
+struct gc05a2 {
+	struct device *dev;
+	struct v4l2_subdev sd;
+	struct media_pad pad;
+	struct v4l2_mbus_framefmt fmt;
+	struct i2c_client *client;
+
+	struct v4l2_rect crop;
+
+	struct clk *xclk;
+	struct regulator_bulk_data	supplies[GC05A2_NUM_SUPPLIES];
+	struct gpio_desc *enable_gpio;
+
+//	struct regmap *regmap;
+
+	struct v4l2_ctrl_handler ctrls;
+	struct v4l2_ctrl *pixel_rate;
+	struct v4l2_ctrl *link_freq;
+	struct v4l2_ctrl *exposure;
+	struct v4l2_ctrl *vblank;
+	struct v4l2_ctrl *hblank;
+
+	/*
+	 * Serialize control access, get/set format, get selection
+	 * and start streaming.
+	 */
+	struct mutex mutex;
+
+	bool streaming;
+
+	/* Current mode */
+	const struct gc05a2_mode *cur_mode;
+};
+
+
+struct reg_8 {
+	u16 address;
+	u8 val;
+};
+
+struct gc05a2_reg_list {
+	u32 num_of_regs;
+	const struct reg_8 *regs;
+};
+
+struct gc05a2_link_freq_config {
+	const struct gc05a2_reg_list reg_list;
+};
+
+enum {
+	GC05A2_TABLE_WAIT_MS = 0,
+	GC05A2_TABLE_END,
+};
+
+static const struct reg_8 mode_2592x1944[] = {
+    /*system*/
+    {0x0135, 0x01},
+
+    /*pre_setting*/
+    {0x0084, 0x21},
+    {0x0d05, 0xcc},
+    {0x0218, 0x00},
+    {0x005e, 0x48},
+    {0x0d06, 0x01},
+    {0x0007, 0x16},
+    {0x0101, 0x00},
+
+    /*analog*/
+    {0x0342, 0x07},
+    {0x0343, 0x28},
+    {0x0220, 0x07},
+    {0x0221, 0xd0},
+    {0x0202, 0x07},
+    {0x0203, 0x32},
+    {0x0340, 0x07},
+    {0x0341, 0xf0},
+    {0x0219, 0x00},
+    {0x0346, 0x00},
+    {0x0347, 0x04},
+    {0x0d14, 0x00},
+    {0x0d13, 0x05},
+    {0x0d16, 0x05},
+    {0x0d15, 0x1d},
+    {0x00c0, 0x0a},
+    {0x00c1, 0x30},
+    {0x034a, 0x07},
+    {0x034b, 0xa8},
+    {0x0e0a, 0x00},
+    {0x0e0b, 0x00},
+    {0x0e0e, 0x03},
+    {0x0e0f, 0x00},
+    {0x0e06, 0x0a},
+    {0x0e23, 0x15},
+    {0x0e24, 0x15},
+    {0x0e2a, 0x10},
+    {0x0e2b, 0x10},
+    {0x0e17, 0x49},
+    {0x0e1b, 0x1c},
+    {0x0e3a, 0x36},
+    {0x0d11, 0x84},
+    {0x0e52, 0x14},
+    {0x000b, 0x10},
+    {0x0008, 0x08},
+    {0x0223, 0x17},
+    {0x0d27, 0x39},
+    {0x0d22, 0x00},
+    {0x03f6, 0x0d},
+    {0x0d04, 0x07},
+    {0x03f3, 0x72},
+    {0x03f4, 0xb8},
+    {0x03f5, 0xbc},
+    {0x0d02, 0x73},
+
+    /*auto load  start*/
+    {0x00cb, 0x00},
+
+    /*OUT 2592*1944*/
+    {0x0350, 0x01},
+    {0x0353, 0x00},
+    {0x0354, 0x08},
+    {0x034c, 0x0a},
+    {0x034d, 0x20},
+    {0x021f, 0x14},
+
+    /*MIPI*/
+    {0x0107, 0x05},
+    {0x0117, 0x01},
+    {0x0d81, 0x00},
+    {0x0d84, 0x0c},
+    {0x0d85, 0xa8},
+    {0x0d86, 0x06},
+    {0x0d87, 0x55},
+    {0x0db3, 0x06},
+    {0x0db4, 0x08},
+    {0x0db5, 0x1e},
+    {0x0db6, 0x02},
+    {0x0db8, 0x12},
+    {0x0db9, 0x0a},
+    {0x0d93, 0x06},
+    {0x0d94, 0x09},
+    {0x0d95, 0x0d},
+    {0x0d99, 0x0b},
+    {0x0084, 0x01},
+
+    /*OUT*/
+    {0x0110, 0x01},
+
+	{GC05A2_TABLE_END, 0x00}
+};
+
+static const struct reg_8 mode_1280x720[] = {
+    /*system*/
+    {0x0135, 0x05},
+
+    /*pre_setting*/
+    {0x0084, 0x21},
+    {0x0d05, 0xcc},
+    {0x0218, 0x80},
+    {0x005e, 0x49},
+    {0x0d06, 0x81},
+    {0x0007, 0x16},
+    {0x0101, 0x00},
+
+    /*analog*/
+    {0x0342, 0x07},
+    {0x0343, 0x10},
+    {0x0220, 0x07},
+    {0x0221, 0xd0},
+    {0x0202, 0x03},
+    {0x0203, 0x32},
+    {0x0340, 0x04},
+    {0x0341, 0x08},
+    {0x0219, 0x00},
+    {0x0346, 0x01},
+    {0x0347, 0x00},
+    {0x0d14, 0x00},
+    {0x0d13, 0x05},
+    {0x0d16, 0x05},
+    {0x0d15, 0x1d},
+    {0x00c0, 0x0a},
+    {0x00c1, 0x30},
+    {0x034a, 0x05},
+    {0x034b, 0xb0},
+    {0x0e0a, 0x00},
+    {0x0e0b, 0x00},
+    {0x0e0e, 0x03},
+    {0x0e0f, 0x00},
+    {0x0e06, 0x0a},
+    {0x0e23, 0x15},
+    {0x0e24, 0x15},
+    {0x0e2a, 0x10},
+    {0x0e2b, 0x10},
+    {0x0e17, 0x49},
+    {0x0e1b, 0x1c},
+    {0x0e3a, 0x36},
+    {0x0d11, 0x84},
+    {0x0e52, 0x14},
+    {0x000b, 0x0e},
+    {0x0008, 0x03},
+    {0x0223, 0x16},
+    {0x0d27, 0x39},
+    {0x0d22, 0x00},
+    {0x03f6, 0x0d},
+    {0x0d04, 0x07},
+    {0x03f3, 0x72},
+    {0x03f4, 0xb8},
+    {0x03f5, 0xbc},
+    {0x0d02, 0x73},
+
+    /*auto load start*/
+    {0x00cb, 0xfc},
+
+    /*OUT 1280x720*/
+    {0x0350, 0x01},
+    {0x0353, 0x00},
+    {0x0354, 0x0c},
+    {0x034c, 0x05},
+    {0x034d, 0x00},
+    {0x021f, 0x14},
+
+    /*MIPI*/
+    {0x0107, 0x05},
+    {0x0117, 0x01},
+    {0x0d81, 0x00},
+    {0x0d84, 0x06},
+    {0x0d85, 0x40},
+    {0x0d86, 0x03},
+    {0x0d87, 0x21},
+    {0x0db3, 0x03},
+    {0x0db4, 0x04},
+    {0x0db5, 0x0d},
+    {0x0db6, 0x01},
+    {0x0db8, 0x04},
+    {0x0db9, 0x06},
+    {0x0d93, 0x03},
+    {0x0d94, 0x04},
+    {0x0d95, 0x05},
+    {0x0d99, 0x06},
+    {0x0084, 0x01},
+
+    /*OUT*/
+    {0x0110, 0x01},
+
+	{GC05A2_TABLE_END, 0x00}
+};
+
+
+static const struct reg_8 mode_table_common[] = {
+
+	{GC05A2_STRAEMING_REG, 0x00},
+    /*system*/
+    {0x0315, 0xd4},
+    {0x0d06, 0x01},
+    {0x0a70, 0x80},
+    {0x031a, 0x00},
+    {0x0314, 0x00},
+    {0x0130, 0x08},
+    {0x0132, 0x01},
+
+    {0x0136, 0x38},
+    {0x0137, 0x03},
+    {0x0134, 0x5b},
+    {0x031c, 0xe0},
+    {0x0d82, 0x14},
+    {0x0dd1, 0x56},
+
+    /*gate_mode*/
+    {0x0af4, 0x01},
+    {0x0002, 0x10},
+    {0x00c3, 0x34},
+
+    /*auto load start*/
+    {0x00c4, 0x00},
+    {0x00c5, 0x01},
+    {0x0af6, 0x00},
+    {0x0ba0, 0x17},
+    {0x0ba1, 0x00},
+    {0x0ba2, 0x00},
+    {0x0ba3, 0x00},
+    {0x0ba4, 0x03},
+    {0x0ba5, 0x00},
+    {0x0ba6, 0x00},
+    {0x0ba7, 0x00},
+    {0x0ba8, 0x40},
+    {0x0ba9, 0x00},
+    {0x0baa, 0x00},
+    {0x0bab, 0x00},
+    {0x0bac, 0x40},
+    {0x0bad, 0x00},
+    {0x0bae, 0x00},
+    {0x0baf, 0x00},
+    {0x0bb0, 0x02},
+    {0x0bb1, 0x00},
+    {0x0bb2, 0x00},
+    {0x0bb3, 0x00},
+    {0x0bb8, 0x02},
+    {0x0bb9, 0x00},
+    {0x0bba, 0x00},
+    {0x0bbb, 0x00},
+    {0x0a70, 0x80},
+    {0x0a71, 0x00},
+    {0x0a72, 0x00},
+    {0x0a66, 0x00},
+    {0x0a67, 0x80},
+    {0x0a4d, 0x4e},
+    {0x0a50, 0x00},
+    {0x0a4f, 0x0c},
+    {0x0a66, 0x00},
+    {0x00ca, 0x00},
+
+    {0x00cc, 0x00},
+    {0x00cd, 0x00},
+    {0x0aa1, 0x00},
+    {0x0aa2, 0xe0},
+    {0x0aa3, 0x00},
+    {0x0aa4, 0x40},
+    {0x0a90, 0x03},
+    {0x0a91, 0x0e},
+    {0x0a94, 0x80},
+
+    /*standby*/
+    {0x0af6, 0x20},
+    {0x0b00, 0x91},
+    {0x0b01, 0x17},
+    {0x0b02, 0x01},
+    {0x0b03, 0x00},
+    {0x0b04, 0x01},
+    {0x0b05, 0x17},
+    {0x0b06, 0x01},
+    {0x0b07, 0x00},
+    {0x0ae9, 0x01},
+    {0x0aea, 0x02},
+    {0x0ae8, 0x53},
+    {0x0ae8, 0x43},
+
+    /*gain_partition*/
+    {0x0af6, 0x30},
+    {0x0b00, 0x08},
+    {0x0b01, 0x0f},
+    {0x0b02, 0x00},
+    {0x0b04, 0x1c},
+    {0x0b05, 0x24},
+    {0x0b06, 0x00},
+    {0x0b08, 0x30},
+    {0x0b09, 0x40},
+    {0x0b0a, 0x00},
+    {0x0b0c, 0x0e},
+    {0x0b0d, 0x2a},
+    {0x0b0e, 0x00},
+    {0x0b10, 0x0e},
+    {0x0b11, 0x2b},
+    {0x0b12, 0x00},
+    {0x0b14, 0x0e},
+    {0x0b15, 0x23},
+    {0x0b16, 0x00},
+    {0x0b18, 0x0e},
+    {0x0b19, 0x24},
+    {0x0b1a, 0x00},
+    {0x0b1c, 0x0c},
+    {0x0b1d, 0x0c},
+    {0x0b1e, 0x00},
+    {0x0b20, 0x03},
+    {0x0b21, 0x03},
+    {0x0b22, 0x00},
+    {0x0b24, 0x0e},
+    {0x0b25, 0x0e},
+    {0x0b26, 0x00},
+    {0x0b28, 0x03},
+    {0x0b29, 0x03},
+    {0x0b2a, 0x00},
+    {0x0b2c, 0x12},
+    {0x0b2d, 0x12},
+    {0x0b2e, 0x00},
+    {0x0b30, 0x08},
+    {0x0b31, 0x08},
+    {0x0b32, 0x00},
+    {0x0b34, 0x14},
+    {0x0b35, 0x14},
+    {0x0b36, 0x00},
+    {0x0b38, 0x10},
+    {0x0b39, 0x10},
+    {0x0b3a, 0x00},
+    {0x0b3c, 0x16},
+    {0x0b3d, 0x16},
+    {0x0b3e, 0x00},
+    {0x0b40, 0x10},
+    {0x0b41, 0x10},
+    {0x0b42, 0x00},
+    {0x0b44, 0x19},
+    {0x0b45, 0x19},
+    {0x0b46, 0x00},
+    {0x0b48, 0x16},
+    {0x0b49, 0x16},
+    {0x0b4a, 0x00},
+    {0x0b4c, 0x19},
+    {0x0b4d, 0x19},
+    {0x0b4e, 0x00},
+    {0x0b50, 0x16},
+    {0x0b51, 0x16},
+    {0x0b52, 0x00},
+    {0x0b80, 0x01},
+    {0x0b81, 0x00},
+    {0x0b82, 0x00},
+    {0x0b84, 0x00},
+    {0x0b85, 0x00},
+    {0x0b86, 0x00},
+    {0x0b88, 0x01},
+    {0x0b89, 0x6a},
+    {0x0b8a, 0x00},
+    {0x0b8c, 0x00},
+    {0x0b8d, 0x01},
+    {0x0b8e, 0x00},
+    {0x0b90, 0x01},
+    {0x0b91, 0xf6},
+    {0x0b92, 0x00},
+    {0x0b94, 0x00},
+    {0x0b95, 0x02},
+    {0x0b96, 0x00},
+    {0x0b98, 0x02},
+    {0x0b99, 0xc4},
+    {0x0b9a, 0x00},
+    {0x0b9c, 0x00},
+    {0x0b9d, 0x03},
+    {0x0b9e, 0x00},
+    {0x0ba0, 0x03},
+    {0x0ba1, 0xd8},
+    {0x0ba2, 0x00},
+    {0x0ba4, 0x00},
+    {0x0ba5, 0x04},
+    {0x0ba6, 0x00},
+    {0x0ba8, 0x05},
+    {0x0ba9, 0x4d},
+    {0x0baa, 0x00},
+    {0x0bac, 0x00},
+    {0x0bad, 0x05},
+    {0x0bae, 0x00},
+    {0x0bb0, 0x07},
+    {0x0bb1, 0x3e},
+    {0x0bb2, 0x00},
+    {0x0bb4, 0x00},
+    {0x0bb5, 0x06},
+    {0x0bb6, 0x00},
+    {0x0bb8, 0x0a},
+    {0x0bb9, 0x1a},
+    {0x0bba, 0x00},
+    {0x0bbc, 0x09},
+    {0x0bbd, 0x36},
+    {0x0bbe, 0x00},
+    {0x0bc0, 0x0e},
+    {0x0bc1, 0x66},
+    {0x0bc2, 0x00},
+    {0x0bc4, 0x10},
+    {0x0bc5, 0x06},
+    {0x0bc6, 0x00},
+    {0x02c1, 0xe0},
+    {0x0207, 0x04},
+    {0x02c2, 0x10},
+    {0x02c3, 0x74},
+    {0x02c5, 0x09},
+    {0x02c1, 0xe0},
+    {0x0207, 0x04},
+    {0x02c2, 0x10},
+    {0x02c5, 0x09},
+    {0x02c1, 0xe0},
+    {0x0207, 0x04},
+    {0x02c2, 0x10},
+    {0x02c5, 0x09},
+
+    /*auto load CH_GAIN*/
+    {0x0aa1, 0x15},
+    {0x0aa2, 0x50},
+    {0x0aa3, 0x00},
+    {0x0aa4, 0x09},
+    {0x0a90, 0x25},
+    {0x0a91, 0x0e},
+    {0x0a94, 0x80},
+
+    /*ISP*/
+    {0x0050, 0x00},
+    {0x0089, 0x83},
+    {0x005a, 0x40},
+    {0x00c3, 0x35},
+    {0x00c4, 0x80},
+    {0x0080, 0x10},
+    {0x0040, 0x12},
+    {0x0053, 0x0a},
+    {0x0054, 0x44},
+    {0x0055, 0x32},
+    {0x0058, 0x89},
+    {0x004a, 0x03},
+    {0x0048, 0xf0},
+    {0x0049, 0x0f},
+    {0x0041, 0x20},
+    {0x0043, 0x0a},
+    {0x009d, 0x08},
+    {0x0236, 0x40},
+
+    /*gain*/
+    {0x0204, 0x04},
+    {0x0205, 0x00},
+    {0x02b3, 0x00},
+    {0x02b4, 0x00},
+    {0x009e, 0x01},
+    {0x009f, 0x94},
+
+    /*auto load REG*/
+    {0x0aa1, 0x10},
+    {0x0aa2, 0xf8},
+    {0x0aa3, 0x00},
+    {0x0aa4, 0x1f},
+    {0x0a90, 0x11},
+    {0x0a91, 0x0e},
+    {0x0a94, 0x80},
+    {0x03fe, 0x00},
+    {0x03fe, 0x00},
+    {0x03fe, 0x00},
+    {0x03fe, 0x00},
+    {0x03fe, 0x00},
+    {0x03fe, 0x00},
+    {0x03fe, 0x00},
+    {0x03fe, 0x00},
+    {0x03fe, 0x00},
+    {0x03fe, 0x00},
+    {0x03fe, 0x00},
+    {0x03fe, 0x00},
+    {0x0a90, 0x00},
+    {0x0a70, 0x00},
+    {0x0a67, 0x00},
+    {0x0af4, 0x29},
+
+    /*DPHY*/
+    {0x0d80, 0x07},
+    {0x0dd3, 0x18},
+
+    /*CISCTL_Reset*/
+    {0x031c, 0x80},
+    {0x03fe, 0x30},
+    {0x0d17, 0x06},
+    {0x03fe, 0x00},
+    {0x0d17, 0x00},
+    {0x031c, 0x93},
+    {0x03fe, 0x00},
+    {0x03fe, 0x00},
+    {0x03fe, 0x00},
+    {0x03fe, 0x00},
+    {0x031c, 0x80},
+    {0x03fe, 0x30},
+    {0x0d17, 0x06},
+    {0x03fe, 0x00},
+    {0x0d17, 0x00},
+    {0x031c, 0x93},
+
+	{GC05A2_TABLE_END, 0x00}
+};
+
+static const struct gc05a2_link_freq_config link_freq_configs[] = {
+	[GC05A2_LINK_FREQ_448MHZ_CFG] = {
+		.reg_list = {
+			.num_of_regs = ARRAY_SIZE(mode_table_common),
+			.regs = mode_table_common,
+		}
+	},
+	[GC05A2_LINK_FREQ_224MHZ_CFG] = {
+		.reg_list = {
+			.num_of_regs = ARRAY_SIZE(mode_table_common),
+			.regs = mode_table_common,
+		}
+	},
+
+	// TODO:
+};
+
+enum {
+	GC05A2_PREV,
+	GC05A2_HS,
+};
+
+/*
+ * Declare modes in order, from biggest
+ * to smallest height.
+ */
+static const struct gc05a2_mode {
+	u8  mode_id;
+	u32 width;
+	u32 height;
+	const struct gc05a2_reg_list reg_list;
+
+	u32 hts; /* Horizontal timining size */
+	u32 vts_def; /* Default vertical timining size */
+	u32 vts_min; /* Min vertical timining size */
+	u32 link_freq_index; /* Link frequency needed for this resolution */
+	u32 max_framerate;
+
+} gc05a2_modes[] = {
+	{
+		.mode_id = GC05A2_PREV,
+		.width = 2592,
+		.height = 1944,
+		.reg_list = {
+			.num_of_regs = ARRAY_SIZE(mode_2592x1944),
+			.regs = mode_2592x1944,
+		},
+		.link_freq_index = GC05A2_LINK_FREQ_448MHZ_CFG,
+
+		.hts = GC05A2_HTS_30FPS,
+		.vts_def = GC05A2_VTS_30FPS,
+		.vts_min = GC05A2_VTS_30FPS_MIN,
+		.max_framerate = 300,
+	},
+	{
+		.mode_id = GC05A2_HS,
+		.width = 1280,
+		.height = 720,
+		.reg_list = {
+			.num_of_regs = ARRAY_SIZE(mode_1280x720),
+			.regs = mode_1280x720,
+		},
+		.link_freq_index = GC05A2_LINK_FREQ_224MHZ_CFG,
+
+		.hts = GC05A2_HTS_60FPS,
+		.vts_def = GC05A2_VTS_60FPS,
+		.vts_min = GC05A2_VTS_60FPS_MIN,
+		.max_framerate = 600,
+	},
+};
+
+static u64 to_pixel_rate(u32 f_index)
+{
+	u64 pixel_rate = link_freq_menu_items[f_index] * 2 * GC05A2_DATA_LANES;
+
+	do_div(pixel_rate, GC05A2_RGB_DEPTH);
+
+	return pixel_rate;
+}
+
+static u64 __maybe_unused to_pixels_per_line(u32 hts, u32 f_index)
+{
+	u64 ppl = hts * to_pixel_rate(f_index);
+
+	do_div(ppl, GC05A2_SCLK);
+
+	return ppl;
+}
+
+static int gc05a2_read_reg(struct gc05a2 *gc05a2, u16 reg, u16 len, u32 *val)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&gc05a2->sd);
+	struct i2c_msg msgs[2];
+	u8 addr_buf[2];
+	u8 data_buf[4] = {0};
+	int ret;
+
+	if (len > 4)
+		return -EINVAL;
+
+	put_unaligned_be16(reg, addr_buf);
+	msgs[0].addr = client->addr;
+	msgs[0].flags = 0;
+	msgs[0].len = sizeof(addr_buf);
+	msgs[0].buf = addr_buf;
+	msgs[1].addr = client->addr;
+	msgs[1].flags = I2C_M_RD;
+	msgs[1].len = len;
+	msgs[1].buf = &data_buf[4 - len];
+
+	ret = i2c_transfer(client->adapter, msgs, ARRAY_SIZE(msgs));
+	if (ret != ARRAY_SIZE(msgs))
+		return -EIO;
+
+	*val = get_unaligned_be32(data_buf);
+
+	return 0;
+}
+
+static int gc05a2_write_reg(struct gc05a2 *gc05a2, u16 reg, u16 len, u32 val)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&gc05a2->sd);
+	u8 buf[6];
+
+	if (len > 4)
+		return -EINVAL;
+
+	put_unaligned_be16(reg, buf);
+	put_unaligned_be32(val << 8 * (4 - len), buf + 2);
+	if (i2c_master_send(client, buf, len + 2) != len + 2)
+		return -EIO;
+
+	return 0;
+}
+
+static int gc05a2_write_reg_list(struct gc05a2 *gc05a2,
+                                 const struct gc05a2_reg_list *r_list)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&gc05a2->sd);
+	unsigned int i;
+	int ret;
+
+	for (i = 0; i < r_list->num_of_regs; i++) {
+
+		if (r_list->regs[i].address == GC05A2_TABLE_WAIT_MS) {
+			usleep_range(r_list->regs[i].val * 1000,
+			             r_list->regs[i].val * 1000 + 500);
+			continue;
+		}
+
+		if (r_list->regs[i].address == GC05A2_TABLE_END) {
+			break;
+		}
+
+		ret = gc05a2_write_reg(gc05a2, r_list->regs[i].address,
+		                       GC05A2_REG_VALUE_08BIT,
+		                       r_list->regs[i].val);
+		if (ret) {
+			dev_err_ratelimited(&client->dev,
+			                    "failed to write reg 0x%4.4x. error = %d",
+			                    r_list->regs[i].address, ret);
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
+static int gc05a2_identify_module(struct gc05a2 *gc05a2)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&gc05a2->sd);
+	int ret;
+	u32 val;
+	uint retry = 2;
+
+	do {
+		ret = gc05a2_read_reg(gc05a2, GC05A2_REG_CHIP_ID,
+							  GC05A2_REG_VALUE_16BIT, &val);
+
+		if (val == GC05A2_CHIP_ID) {
+			dev_info(&client->dev, "sensor_id: 0x%04x\n", val);
+			return 0;
+		}
+
+		dev_err(&client->dev, "chip id mismatch: 0x%x!=0x%x",
+				GC05A2_CHIP_ID, val);
+
+		msleep(10);
+		retry --;
+	} while (retry > 0);
+
+	return -ENXIO;
+}
+
+static inline struct gc05a2 *to_gc05a2(struct v4l2_subdev *sd)
+{
+	return container_of(sd, struct gc05a2, sd);
+}
+
+static int __maybe_unused gc05a2_power_on(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct gc05a2 *gc05a2 = to_gc05a2(sd);
+	int ret;
+
+	dev_info(dev, "--- %s +", __func__);
+
+	gpiod_set_value_cansleep(gc05a2->enable_gpio, 0);
+	usleep_range(2000, 3000);
+
+	ret = regulator_bulk_enable(GC05A2_NUM_SUPPLIES, gc05a2->supplies);
+	if (ret < 0) {
+		dev_err(gc05a2->dev, "failed to enable regulators: %d\n", ret);
+		return ret;
+	}
+
+	//usleep_range(2000, 3000);
+
+	ret = clk_prepare_enable(gc05a2->xclk);
+	if (ret < 0) {
+		regulator_bulk_disable(GC05A2_NUM_SUPPLIES, gc05a2->supplies);
+		dev_err(gc05a2->dev, "clk prepare enable failed\n");
+		return ret;
+	}
+
+	usleep_range(2000, 3000);
+
+	gpiod_set_value_cansleep(gc05a2->enable_gpio, 1);
+	usleep_range(12000, 15000);
+
+	dev_info(dev, "--- %s -", __func__);
+
+	return 0;
+}
+
+static int __maybe_unused gc05a2_power_off(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct gc05a2 *gc05a2 = to_gc05a2(sd);
+
+	dev_info(dev, "--- %s +", __func__);
+
+	gpiod_set_value_cansleep(gc05a2->enable_gpio, 0);
+
+	clk_disable_unprepare(gc05a2->xclk);
+
+	regulator_bulk_disable(GC05A2_NUM_SUPPLIES, gc05a2->supplies);
+	usleep_range(10, 20);
+
+	dev_info(dev, "--- %s -", __func__);
+
+	return 0;
+}
+
+static int gc05a2_enum_mbus_code(struct v4l2_subdev *sd,
+                                 struct v4l2_subdev_state *sd_state,
+                                 struct v4l2_subdev_mbus_code_enum *code)
+{
+	if (code->index > 0)
+		return -EINVAL;
+
+	code->code = GC05A2_MBUS_CODE;
+
+	return 0;
+}
+
+static int gc05a2_enum_frame_size(struct v4l2_subdev *subdev,
+                                  struct v4l2_subdev_state *sd_state,
+                                  struct v4l2_subdev_frame_size_enum *fse)
+{
+	if (fse->code != GC05A2_MBUS_CODE)
+		return -EINVAL;
+
+	if (fse->index >= ARRAY_SIZE(gc05a2_modes))
+		return -EINVAL;
+
+	fse->min_width = fse->max_width = gc05a2_modes[fse->index].width;
+	fse->min_height = fse->max_height = gc05a2_modes[fse->index].height;
+
+	return 0;
+}
+
+#ifdef CONFIG_VIDEO_ADV_DEBUG
+static int gc05a2_g_register(struct v4l2_subdev *subdev,
+                             struct v4l2_dbg_register *reg)
+{
+	int ret;
+	u32 val;
+	struct gc05a2 *gc05a2 = container_of(subdev, struct gc05a2, sd);
+
+	ret = gc05a2_read_reg(gc05a2, reg->reg,
+	                      GC05A2_REG_VALUE_08BIT, &val);
+	if (ret < 0)
+		return ret;
+
+	reg->val = val;
+	reg->size = 1;
+
+	return 0;
+}
+
+static int gc05a2_s_register(struct v4l2_subdev *subdev,
+                             const struct v4l2_dbg_register *reg)
+{
+	struct gc05a2 *gc05a2 = container_of(subdev, struct gc05a2, sd);
+
+	return gc05a2_write_reg(gc05a2, reg->reg,
+	                        GC05A2_REG_VALUE_08BIT, reg->val & 0xff);
+}
+
+#endif
+
+static const struct v4l2_subdev_core_ops gc05a2_core_ops = {
+#ifdef CONFIG_VIDEO_ADV_DEBUG
+	.g_register = gc05a2_g_register,
+	.s_register = gc05a2_s_register,
+#endif
+};
+
+static struct v4l2_mbus_framefmt *
+__gc05a2_get_pad_format(struct gc05a2 *gc05a2,
+                        struct v4l2_subdev_state *sd_state,
+                        unsigned int pad,
+                        enum v4l2_subdev_format_whence which)
+{
+	switch (which) {
+	case V4L2_SUBDEV_FORMAT_TRY:
+		return v4l2_subdev_get_try_format(&gc05a2->sd, sd_state, pad);
+	case V4L2_SUBDEV_FORMAT_ACTIVE:
+		return &gc05a2->fmt;
+	default:
+		return NULL;
+	}
+}
+
+static int gc05a2_get_format(struct v4l2_subdev *sd,
+                             struct v4l2_subdev_state *sd_state,
+                             struct v4l2_subdev_format *format)
+{
+	struct gc05a2 *gc05a2 = to_gc05a2(sd);
+
+	mutex_lock(&gc05a2->mutex);
+	format->format = *__gc05a2_get_pad_format(gc05a2, sd_state,
+	                 format->pad,
+	                 format->which);
+	mutex_unlock(&gc05a2->mutex);
+
+	return 0;
+}
+
+static struct v4l2_rect *
+__gc05a2_get_pad_crop(struct gc05a2 *gc05a2,
+                      struct v4l2_subdev_state *sd_state,
+                      unsigned int pad, enum v4l2_subdev_format_whence which)
+{
+	switch (which) {
+	case V4L2_SUBDEV_FORMAT_TRY:
+		return v4l2_subdev_get_try_crop(&gc05a2->sd, sd_state, pad);
+	case V4L2_SUBDEV_FORMAT_ACTIVE:
+		return &gc05a2->crop;
+	default:
+		return NULL;
+	}
+}
+
+static int gc05a2_update_cur_mode_controls(struct gc05a2 *gc05a2)
+{
+	s64 exposure_max, h_blank;
+	int ret = 0;
+
+	ret = __v4l2_ctrl_modify_range(gc05a2->vblank,
+						   gc05a2->cur_mode->vts_min - gc05a2->cur_mode->height,
+						   GC05A2_VTS_MAX - gc05a2->cur_mode->height,
+						   1,
+						   gc05a2->cur_mode->vts_def - gc05a2->cur_mode->height);
+	if (ret) {
+		dev_err(gc05a2->dev, "VB ctrl range update failed\n");
+	}
+
+	h_blank = gc05a2->cur_mode->hts - gc05a2->cur_mode->width;
+	ret = __v4l2_ctrl_modify_range(gc05a2->hblank,
+						   h_blank, h_blank, 1, h_blank);
+	if (ret) {
+		dev_err(gc05a2->dev, "HB ctrl range update failed\n");
+	}
+
+	exposure_max = gc05a2->cur_mode->vts_def - GC05A2_EXP_MARGIN;
+	ret = __v4l2_ctrl_modify_range(gc05a2->exposure,
+						 GC05A2_EXP_MIN,
+						 exposure_max,
+						 GC05A2_EXP_STEP,
+						 exposure_max);
+	if (ret) {
+		dev_err(gc05a2->dev, "exposure ctrl range update failed\n");
+	}
+	return ret;
+}
+
+
+static int gc05a2_set_format(struct v4l2_subdev *sd,
+                             struct v4l2_subdev_state *sd_state,
+                             struct v4l2_subdev_format *format)
+{
+	struct gc05a2 *gc05a2 = to_gc05a2(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(&gc05a2->sd);
+	struct device *dev = &client->dev;
+	struct v4l2_mbus_framefmt *__format;
+	struct v4l2_rect *__crop;
+	const struct gc05a2_mode *mode;
+
+	mutex_lock(&gc05a2->mutex);
+
+	dev_dbg(dev, "---- %s, format(W x H:%d x %d)  +",
+	         __func__, format->format.width, format->format.height);
+
+	__crop = __gc05a2_get_pad_crop(gc05a2, sd_state, format->pad,
+	                               format->which);
+
+	mode = v4l2_find_nearest_size(gc05a2_modes,
+	                              ARRAY_SIZE(gc05a2_modes), width, height,
+	                              format->format.width,
+	                              format->format.height);
+
+	dev_dbg(dev, "----nearest mode(W x H:%d x %d)",
+	         mode->width, mode->height);
+
+	__crop->width = mode->width;
+	__crop->height = mode->height;
+
+	__format = __gc05a2_get_pad_format(gc05a2, sd_state, format->pad,
+	                                   format->which);
+	__format->width = __crop->width;
+	__format->height = __crop->height;
+	__format->code = GC05A2_MBUS_CODE;
+	__format->field = V4L2_FIELD_NONE;
+	__format->colorspace = V4L2_COLORSPACE_SRGB;
+	__format->ycbcr_enc = V4L2_MAP_YCBCR_ENC_DEFAULT(__format->colorspace);
+	__format->quantization = V4L2_MAP_QUANTIZATION_DEFAULT(true,
+	                         __format->colorspace, __format->ycbcr_enc);
+	__format->xfer_func = V4L2_MAP_XFER_FUNC_DEFAULT(__format->colorspace);
+
+	format->format = *__format;
+
+	gc05a2->cur_mode = mode;
+    gc05a2_update_cur_mode_controls(gc05a2);
+
+	mutex_unlock(&gc05a2->mutex);
+
+	return 0;
+}
+
+static int gc05a2_get_selection(struct v4l2_subdev *sd,
+                                struct v4l2_subdev_state *sd_state,
+                                struct v4l2_subdev_selection *sel)
+{
+	struct gc05a2 *gc05a2 = to_gc05a2(sd);
+
+	if (sel->target != V4L2_SEL_TGT_CROP)
+		return -EINVAL;
+
+	mutex_lock(&gc05a2->mutex);
+	sel->r = *__gc05a2_get_pad_crop(gc05a2, sd_state, sel->pad,
+	                                sel->which);
+	mutex_unlock(&gc05a2->mutex);
+	return 0;
+}
+
+static int gc05a2_entity_init_cfg(struct v4l2_subdev *subdev,
+                                  struct v4l2_subdev_state *sd_state)
+{
+	struct v4l2_subdev_format fmt = { };
+
+	fmt.which = sd_state ? V4L2_SUBDEV_FORMAT_TRY : V4L2_SUBDEV_FORMAT_ACTIVE;
+	fmt.format.width = gc05a2_modes[0].width;
+	fmt.format.height = gc05a2_modes[0].height;
+
+	gc05a2_set_format(subdev, sd_state, &fmt);
+
+	return 0;
+}
+
+static int gc05a2_set_ctrl_hflip(struct gc05a2 *gc05a2, u32 ctrl_val)
+{
+	int ret;
+	u32 val;
+
+	ret = gc05a2_read_reg(gc05a2, GC05A2_FLIP_REG,
+	                      GC05A2_REG_VALUE_08BIT, &val);
+	if (ret) {
+		dev_err(gc05a2->dev, "read hflip register failed: %d\n", ret);
+		return ret;
+	}
+
+	val = (ctrl_val) ? (val | GC05A2_FLIP_H_MASK)
+	      : (val & ~GC05A2_FLIP_H_MASK);
+	ret = gc05a2_write_reg(gc05a2, GC05A2_FLIP_REG,
+	                       GC05A2_REG_VALUE_08BIT, val);
+	if (ret < 0)
+		dev_err(gc05a2->dev, "Error %d\n", ret);
+
+	return ret;
+
+}
+
+static int gc05a2_set_ctrl_vflip(struct gc05a2 *gc05a2, u32 ctrl_val)
+{
+	int ret;
+	u32 val;
+
+	ret = gc05a2_read_reg(gc05a2, GC05A2_FLIP_REG,
+	                      GC05A2_REG_VALUE_08BIT, &val);
+	if (ret) {
+		dev_err(gc05a2->dev, "read vflip register failed: %d\n", ret);
+		return ret;
+	}
+
+	val = (ctrl_val) ? (val | GC05A2_FLIP_V_MASK)
+	      : (val & ~GC05A2_FLIP_V_MASK);
+	ret = gc05a2_write_reg(gc05a2, GC05A2_FLIP_REG,
+	                       GC05A2_REG_VALUE_08BIT, val);
+	if (ret < 0)
+		dev_err(gc05a2->dev, "Error %d\n", ret);
+
+	return ret;
+}
+
+static int gc05a2_test_pattern(struct gc05a2 *gc05a2, u32 pattern_menu)
+{
+	int ret = 0;
+	u32 pattern = 0;
+	if (pattern_menu) {
+		// write bit16:0x0110 -> color bar
+		switch (pattern_menu) {
+		case 1:
+		case 2:
+		case 3:
+		case 4:
+		case 5:
+		case 6:
+		case 7:
+			pattern = pattern_menu << 4;
+			break;
+
+		case 8:
+			pattern = 0;
+			break;
+
+		case 9:
+			pattern = 4;
+			break;
+
+		default:
+			dev_dbg(gc05a2->dev, "invalid pattern menu!\n");
+			break;
+		}
+
+		ret = gc05a2_write_reg(gc05a2, GC05A2_REG_TEST_PATTERN_EN,
+							GC05A2_REG_VALUE_08BIT, GC05A2_TEST_PATTERN_EN);
+		ret = gc05a2_write_reg(gc05a2, GC05A2_REG_TEST_PATTERN_IDX,
+							GC05A2_REG_VALUE_08BIT, pattern);
+
+	} else {
+		ret = gc05a2_write_reg(gc05a2, GC05A2_REG_TEST_PATTERN_EN,
+							GC05A2_REG_VALUE_08BIT, 0x00);
+	}
+
+	return ret;
+}
+
+static int set_ext_ctrl(struct v4l2_ctrl *ctrl)
+{
+	int ret = 0;
+//	struct gc05a2 *gc05a2 = container_of(ctrl->handler, struct gc05a2, ctrls);
+//	struct i2c_client *client = v4l2_get_subdevdata(&gc05a2->sd);
+
+	switch (ctrl->id) {
+    // TODO: add extension CMD
+
+	}
+
+	return ret;
+}
+
+static int gc05a2_set_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct gc05a2 *gc05a2 = container_of(ctrl->handler,
+	                                     struct gc05a2, ctrls);
+	int ret = 0;
+	s64 exposure_max;
+
+	if (ctrl->id == V4L2_CID_VBLANK) {
+		/* Update max exposure while meeting expected vblanking */
+		exposure_max = gc05a2->cur_mode->height + ctrl->val - GC05A2_EXP_MARGIN;
+		__v4l2_ctrl_modify_range(gc05a2->exposure,
+		                         gc05a2->exposure->minimum,
+		                         exposure_max, gc05a2->exposure->step,
+		                         exposure_max);
+	}
+
+	/*
+	 * Applying V4L2 control value only happens
+	 * when power is up for streaming
+	 */
+	if (!pm_runtime_get_if_in_use(gc05a2->dev))
+		return 0;
+
+	switch (ctrl->id) {
+	case V4L2_CID_EXPOSURE:
+		//dev_info(gc05a2->dev, "V4L2_CID_EXPOSURE:0x%x\n", ctrl->val);
+		ret = gc05a2_write_reg(gc05a2, GC05A2_EXP_REG,
+		                       GC05A2_REG_VALUE_16BIT, ctrl->val);
+		break;
+
+	case V4L2_CID_ANALOGUE_GAIN:
+		//dev_info(gc05a2->dev, "V4L2_CID_ANALOGUE_GAIN:0x%x\n", ctrl->val);
+		ret = gc05a2_write_reg(gc05a2, GC05A2_AGAIN_REG,
+		                       GC05A2_REG_VALUE_16BIT, ctrl->val);
+		break;
+
+	case V4L2_CID_VBLANK:
+		dev_info(gc05a2->dev, "V4L2_CID_VBLANK:height:%d, V_BLNK:%d\n",
+        		 gc05a2->cur_mode->height, ctrl->val);
+		ret = gc05a2_write_reg(gc05a2, GC05A2_FL_REG,
+		                       GC05A2_REG_VALUE_16BIT,
+		                       gc05a2->cur_mode->height + ctrl->val);
+		break;
+
+	case V4L2_CID_HFLIP:
+		gc05a2_set_ctrl_hflip(gc05a2, ctrl->val);
+		break;
+
+	case V4L2_CID_VFLIP:
+		gc05a2_set_ctrl_vflip(gc05a2, ctrl->val);
+		break;
+
+	case V4L2_CID_TEST_PATTERN:
+		ret = gc05a2_test_pattern(gc05a2, ctrl->val);
+		break;
+
+	default:
+		ret = set_ext_ctrl(ctrl);
+		break;
+	}
+
+	pm_runtime_put(gc05a2->dev);
+
+	return ret;
+}
+
+static int get_volatile_ext_ctrl(struct v4l2_ctrl *ctrl)
+{
+	int ret = 0;
+	struct gc05a2 *gc05a2 = container_of(ctrl->handler, struct gc05a2, ctrls);
+	struct i2c_client *client = v4l2_get_subdevdata(&gc05a2->sd);
+
+	dev_dbg(&client->dev, "---- %s, CMD:0x%x\n", __func__, ctrl->id);
+	switch (ctrl->id) {
+	default:
+		dev_info(&client->dev, "[gc05a2] %s, un-support CMD: 0x%x\n", __func__, ctrl->id);
+		break;
+	}
+
+	return ret;
+}
+
+static int gc05a2_g_volatile_ctrl(struct v4l2_ctrl *ctrl)
+{
+	int ret = 0;
+
+	switch (ctrl->id) {
+	default:
+		ret = get_volatile_ext_ctrl(ctrl);
+		break;
+	}
+
+	return ret;
+}
+
+static int try_ext_ctrl(struct v4l2_ctrl *ctrl)
+{
+	int ret = 0;
+	struct gc05a2 *gc05a2 = container_of(ctrl->handler, struct gc05a2, ctrls);
+	struct i2c_client *client = v4l2_get_subdevdata(&gc05a2->sd);
+
+	switch (ctrl->id) {
+	default:
+		dev_dbg(&client->dev, "[gc05a2] un-handle CMD: 0x%x (%s : %d)\n",
+		        ctrl->id, __func__, __LINE__);
+		break;
+	}
+
+	return ret;
+}
+
+static int gc05a2_try_ctrl(struct v4l2_ctrl *ctrl)
+{
+	int ret = 0;
+
+	switch (ctrl->id) {
+	case V4L2_CID_EXPOSURE:
+	case V4L2_CID_ANALOGUE_GAIN:
+//	case V4L2_CID_DIGITAL_GAIN:
+	case V4L2_CID_VBLANK:
+	case V4L2_CID_HFLIP:
+	case V4L2_CID_VFLIP:
+	case V4L2_CID_TEST_PATTERN:
+		return 0;
+
+	default:
+		ret = try_ext_ctrl(ctrl);
+		break;
+	}
+
+	return ret;
+}
+
+
+const struct v4l2_ctrl_ops gc05a2_ctrl_ops = {
+	.g_volatile_ctrl = gc05a2_g_volatile_ctrl,
+	.try_ctrl = gc05a2_try_ctrl,
+	.s_ctrl = gc05a2_set_ctrl,
+};
+
+//============================================================
+static int gc05a2_init_ext_controls(struct v4l2_ctrl_handler *ctrl_hdlr)
+{
+	return 0;
+}
+//============================================================
+
+static int gc05a2_start_streaming(struct gc05a2 *gc05a2)
+{
+	const struct gc05a2_mode *mode;
+	const struct gc05a2_reg_list *reg_list;
+	int link_freq_index;
+	int ret;
+
+	dev_info(gc05a2->dev, "%s ++\n", __func__);
+
+	mutex_lock(&gc05a2->mutex);
+
+	link_freq_index = gc05a2->cur_mode->link_freq_index;
+	dev_info(gc05a2->dev, "----link_freq_index = %d ",
+	         link_freq_index);
+
+	reg_list = &link_freq_configs[link_freq_index].reg_list;
+	ret = gc05a2_write_reg_list(gc05a2, reg_list);
+	if (ret) {
+		dev_err(gc05a2->dev, "could not sent common table %d\n", ret);
+		goto error;
+	}
+
+	mode = gc05a2->cur_mode;
+	dev_info(gc05a2->dev, "----write regtbl: mode(id:%d, WxH:%dx%d)",
+            mode->mode_id,
+            mode->width, mode->height);
+	reg_list = &mode->reg_list;
+
+	ret = gc05a2_write_reg_list(gc05a2,  reg_list);
+	if (ret < 0) {
+		dev_err(gc05a2->dev, "could not sent mode table %d\n", ret);
+		goto error;
+	}
+	ret = __v4l2_ctrl_handler_setup(&gc05a2->ctrls);
+	if (ret < 0) {
+		dev_err(gc05a2->dev, "could not sync v4l2 controls\n");
+		goto error;
+	}
+
+	ret = gc05a2_write_reg(gc05a2, GC05A2_STRAEMING_REG,
+	                       GC05A2_REG_VALUE_08BIT, 1);
+	if (ret < 0) {
+		dev_err(gc05a2->dev, "write STRAEMING_REG failed: %d\n", ret);
+		goto error;
+	}
+
+	mutex_unlock(&gc05a2->mutex);
+
+	dev_info(gc05a2->dev, "%s --\n", __func__);
+
+	return 0;
+
+error:
+	mutex_unlock(&gc05a2->mutex);
+	return ret;
+}
+
+static int gc05a2_stop_streaming(struct gc05a2 *gc05a2)
+{
+	int ret;
+
+	dev_info(gc05a2->dev, "%s ++\n", __func__);
+
+	ret = gc05a2_write_reg(gc05a2, GC05A2_STRAEMING_REG,
+	                       GC05A2_REG_VALUE_08BIT, 0);
+	if (ret < 0)
+		dev_err(gc05a2->dev, "could not sent stop streaming %d\n", ret);
+
+	dev_info(gc05a2->dev, "%s --\n", __func__);
+
+	return ret;
+}
+
+static int gc05a2_s_stream(struct v4l2_subdev *subdev, int enable)
+{
+	struct gc05a2 *gc05a2 = to_gc05a2(subdev);
+	int ret;
+
+	if (gc05a2->streaming == enable)
+		return 0;
+
+	if (enable) {
+		ret = pm_runtime_resume_and_get(gc05a2->dev);
+		if (ret < 0)
+			return ret;
+
+		ret = gc05a2_start_streaming(gc05a2);
+		if (ret < 0)
+			goto err_rpm_put;
+	} else {
+		ret = gc05a2_stop_streaming(gc05a2);
+		if (ret < 0)
+			goto err_rpm_put;
+		pm_runtime_put(gc05a2->dev);
+	}
+
+	gc05a2->streaming = enable;
+	return 0;
+
+err_rpm_put:
+	pm_runtime_put(gc05a2->dev);
+	return ret;
+}
+
+static int gc05a2_g_mbus_config(struct v4l2_subdev *sd, unsigned int pad,
+                                struct v4l2_mbus_config *config)
+{
+	config->type = V4L2_MBUS_CSI2_DPHY;
+	config->bus.mipi_csi2.num_data_lanes = GC05A2_DATA_LANES;
+	config->bus.mipi_csi2.flags = 0;
+	return 0;
+}
+
+static int gc05a2_g_frame_interval(struct v4l2_subdev *subdev,
+                                   struct v4l2_subdev_frame_interval *fival)
+{
+	struct gc05a2 *gc05a2 = to_gc05a2(subdev);
+
+	fival->interval.numerator = 1;
+	fival->interval.denominator = gc05a2->cur_mode->max_framerate / 10;
+
+	return 0;
+}
+
+static int gc05a2_enum_frame_interval(struct v4l2_subdev *subdev,
+                                      struct v4l2_subdev_state *sd_state,
+                                      struct v4l2_subdev_frame_interval_enum *fie)
+{
+	const struct gc05a2_mode *mode;
+
+	if (fie->index != 0)
+		return -EINVAL;
+
+	mode = v4l2_find_nearest_size(gc05a2_modes,
+	                              ARRAY_SIZE(gc05a2_modes), width, height,
+	                              fie->width, fie->height);
+
+	fie->code = GC05A2_MBUS_CODE;
+	fie->width = mode->width;
+	fie->height = mode->height;
+	fie->interval.numerator = 1;
+	fie->interval.denominator = mode->max_framerate / 10;
+
+	return 0;
+}
+
+static const struct v4l2_subdev_video_ops gc05a2_video_ops = {
+	.s_stream = gc05a2_s_stream,
+	.g_frame_interval = gc05a2_g_frame_interval,
+	.s_frame_interval = gc05a2_g_frame_interval,
+};
+
+static const struct v4l2_subdev_pad_ops gc05a2_subdev_pad_ops = {
+	.enum_mbus_code = gc05a2_enum_mbus_code,
+	.enum_frame_size = gc05a2_enum_frame_size,
+	.enum_frame_interval = gc05a2_enum_frame_interval,
+	.get_fmt = gc05a2_get_format,
+	.set_fmt = gc05a2_set_format,
+	.get_selection = gc05a2_get_selection,
+	.init_cfg = gc05a2_entity_init_cfg,
+	.get_mbus_config = gc05a2_g_mbus_config,
+};
+
+static const struct v4l2_subdev_ops gc05a2_subdev_ops = {
+	.core = &gc05a2_core_ops,
+	.video = &gc05a2_video_ops,
+	.pad = &gc05a2_subdev_pad_ops,
+};
+
+static const struct regmap_config sensor_regmap_config = {
+	.reg_bits = 16,
+	.val_bits = 16,
+	.cache_type = REGCACHE_RBTREE,
+};
+
+static int gc05a2_get_regulators(struct device *dev, struct gc05a2 *gc05a2)
+{
+	unsigned int i;
+
+	for (i = 0; i < GC05A2_NUM_SUPPLIES; i++)
+		gc05a2->supplies[i].supply = gc05a2_supply_name[i];
+
+	return devm_regulator_bulk_get(dev, GC05A2_NUM_SUPPLIES,
+	                               gc05a2->supplies);
+}
+
+static int gc05a2_parse_fwnode(struct device *dev)
+{
+	struct fwnode_handle *endpoint;
+	struct v4l2_fwnode_endpoint bus_cfg = {
+		.bus_type = V4L2_MBUS_CSI2_DPHY,
+	};
+	unsigned int i, j;
+	int ret;
+
+	endpoint = fwnode_graph_get_next_endpoint(dev_fwnode(dev), NULL);
+	if (!endpoint) {
+		dev_err(dev, "endpoint node not found\n");
+		return -EINVAL;
+	}
+
+	ret = v4l2_fwnode_endpoint_alloc_parse(endpoint, &bus_cfg);
+	if (ret) {
+		dev_err(dev, "parsing endpoint node failed\n");
+		goto done;
+	}
+
+	if (!bus_cfg.nr_of_link_frequencies) {
+		dev_err(dev, "no link frequencies defined");
+		ret = -EINVAL;
+		goto done;
+	}
+
+	for (i = 0; i < ARRAY_SIZE(link_freq_menu_items); i++) {
+		for (j = 0; j < bus_cfg.nr_of_link_frequencies; j++) {
+			if (link_freq_menu_items[i] == bus_cfg.link_frequencies[j])
+				break;
+		}
+
+		if (j == bus_cfg.nr_of_link_frequencies) {
+			dev_err(dev, "no link frequency %lld supported, please check DT",
+			        link_freq_menu_items[i]);
+			ret = -EINVAL;
+			goto done;
+		}
+	}
+
+done:
+	v4l2_fwnode_endpoint_free(&bus_cfg);
+	fwnode_handle_put(endpoint);
+	return ret;
+}
+
+static int __maybe_unused gc05a2_suspend(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct gc05a2 *gc05a2 = to_gc05a2(sd);
+
+	if (gc05a2->streaming)
+		gc05a2_stop_streaming(gc05a2);
+
+	return 0;
+}
+
+static int __maybe_unused gc05a2_resume(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct gc05a2 *gc05a2 = to_gc05a2(sd);
+	int ret;
+
+	if (gc05a2->streaming) {
+		ret = gc05a2_start_streaming(gc05a2);
+		if (ret)
+			goto error;
+	}
+
+	return 0;
+
+error:
+	gc05a2_stop_streaming(gc05a2);
+	gc05a2->streaming = 0;
+	return ret;
+}
+
+static int gc05a2_init_controls(struct gc05a2 *gc05a2)
+{
+	struct v4l2_ctrl_handler *ctrl_hdlr;
+	s64 exposure_max, h_blank;
+	int ret;
+
+	ctrl_hdlr = &gc05a2->ctrls;
+	ret = v4l2_ctrl_handler_init(ctrl_hdlr, 10);
+	if (ret)
+		return ret;
+
+	ctrl_hdlr->lock = &gc05a2->mutex;
+
+	gc05a2->link_freq = v4l2_ctrl_new_int_menu(ctrl_hdlr, &gc05a2_ctrl_ops,
+	                    V4L2_CID_LINK_FREQ,
+	                    ARRAY_SIZE(link_freq_menu_items) - 1,
+	                    0, link_freq_menu_items);
+	if (gc05a2->link_freq)
+		gc05a2->link_freq->flags |= V4L2_CTRL_FLAG_READ_ONLY;
+
+	gc05a2->pixel_rate = v4l2_ctrl_new_std(ctrl_hdlr, &gc05a2_ctrl_ops,
+	                      V4L2_CID_PIXEL_RATE, 0,
+	                      to_pixel_rate(GC05A2_LINK_FREQ_448MHZ_CFG),
+	                      1,
+	                      to_pixel_rate(GC05A2_LINK_FREQ_448MHZ_CFG));
+
+	gc05a2->vblank = v4l2_ctrl_new_std(&gc05a2->ctrls, &gc05a2_ctrl_ops,
+	                                   V4L2_CID_VBLANK,
+	                                   gc05a2->cur_mode->vts_min -
+	                                   gc05a2->cur_mode->height,
+	                                   GC05A2_VTS_MAX -
+	                                   gc05a2->cur_mode->height, 1,
+	                                   gc05a2->cur_mode->vts_def -
+	                                   gc05a2->cur_mode->height);
+
+	h_blank = gc05a2->cur_mode->hts - gc05a2->cur_mode->width;
+	gc05a2->hblank = v4l2_ctrl_new_std(&gc05a2->ctrls, &gc05a2_ctrl_ops,
+	                                   V4L2_CID_HBLANK, h_blank, h_blank, 1,
+	                                   h_blank);
+	if (gc05a2->hblank)
+		gc05a2->hblank->flags |= V4L2_CTRL_FLAG_READ_ONLY;
+
+	v4l2_ctrl_new_std(&gc05a2->ctrls, &gc05a2_ctrl_ops, V4L2_CID_ANALOGUE_GAIN,
+	                  GC05A2_AGAIN_MIN, GC05A2_AGAIN_MAX,
+	                  GC05A2_AGAIN_STEP, GC05A2_AGAIN_MIN);
+
+	exposure_max = gc05a2->cur_mode->vts_def - GC05A2_EXP_MARGIN;
+	gc05a2->exposure = v4l2_ctrl_new_std(ctrl_hdlr, &gc05a2_ctrl_ops,
+	                                     V4L2_CID_EXPOSURE,
+	                                     GC05A2_EXP_MIN, exposure_max,
+	                                     GC05A2_EXP_STEP,
+	                                     exposure_max);
+
+	v4l2_ctrl_new_std_menu_items(ctrl_hdlr, &gc05a2_ctrl_ops,
+	                             V4L2_CID_TEST_PATTERN,
+	                             ARRAY_SIZE(gc05a2_test_pattern_menu) - 1,
+	                             0, 0, gc05a2_test_pattern_menu);
+
+	v4l2_ctrl_new_std(&gc05a2->ctrls, &gc05a2_ctrl_ops,
+	                  V4L2_CID_HFLIP, 0, 1, 1, 0);
+
+	v4l2_ctrl_new_std(&gc05a2->ctrls, &gc05a2_ctrl_ops,
+	                  V4L2_CID_VFLIP, 0, 1, 1, 0);
+
+	if (ctrl_hdlr->error)
+		return ctrl_hdlr->error;
+
+	gc05a2->sd.ctrl_handler = ctrl_hdlr;
+
+	return 0;
+
+}
+
+
+
+static int gc05a2_probe(struct i2c_client *client)
+{
+	struct device *dev = &client->dev;
+	struct gc05a2 *gc05a2;
+	int ret;
+
+	dev_info(dev, "--- %s +", __func__);
+
+	ret = gc05a2_parse_fwnode(dev);
+	if (ret)
+		return ret;
+
+	gc05a2 = devm_kzalloc(dev, sizeof(*gc05a2), GFP_KERNEL);
+	if (!gc05a2)
+		return -ENOMEM;
+
+	gc05a2->dev = dev;
+
+	gc05a2->xclk = devm_clk_get(dev, NULL);
+	if (IS_ERR(gc05a2->xclk)) {
+		dev_err(dev, "could not get xclk\n");
+		return PTR_ERR(gc05a2->xclk);
+	}
+
+	ret = clk_set_rate(gc05a2->xclk, GC05A2_DEFAULT_CLK_FREQ);
+	if (ret) {
+		dev_err(dev, "could not set xclk frequency\n");
+		return ret;
+	}
+
+	ret = gc05a2_get_regulators(dev, gc05a2);
+	if (ret < 0) {
+		dev_err(dev, "cannot get regulators\n");
+		return ret;
+	}
+
+	gc05a2->enable_gpio = devm_gpiod_get(dev, "enable", GPIOD_OUT_LOW);
+	if (IS_ERR(gc05a2->enable_gpio)) {
+		dev_err(dev, "cannot get enable gpio\n");
+		return PTR_ERR(gc05a2->enable_gpio);
+	}
+
+	v4l2_i2c_subdev_init(&gc05a2->sd, client, &gc05a2_subdev_ops);
+
+	gc05a2_power_on(gc05a2->dev);
+
+	ret = gc05a2_identify_module(gc05a2);
+	if (ret) {
+		dev_err(&client->dev, "failed to find sensor: %d\n", ret);
+        gc05a2_power_off(gc05a2->dev);
+		return ret;
+	}
+
+	mutex_init(&gc05a2->mutex);
+	gc05a2->cur_mode = &gc05a2_modes[0];
+
+	ret = gc05a2_init_controls(gc05a2);
+	if (ret) {
+		dev_err(&client->dev, "failed to init controls: %d", ret);
+		goto free_ctrl;
+	}
+
+	gc05a2->sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+	gc05a2->pad.flags = MEDIA_PAD_FL_SOURCE;
+	gc05a2->sd.dev = &client->dev;
+	gc05a2->sd.entity.function = MEDIA_ENT_F_CAM_SENSOR;
+
+	// Init ExtCMD
+	ret = gc05a2_init_ext_controls(&gc05a2->ctrls);
+	if (ret) {
+		dev_err(&client->dev, "failed to init controls: %d", ret);
+		goto free_ctrl;
+	}
+
+	dev_dbg(&client->dev, "gc05a2->sd.name: %s, dev->of_node->name: %s\n",
+	        gc05a2->sd.name, dev->of_node->name);
+	if (V4L2_SUBDEV_NAME_SIZE - strlen(gc05a2->sd.name) - 2
+	    < strlen(dev->of_node->name)) {
+		dev_err(&client->dev,
+		        "the string length of (sd.name + of_node->name) is too long.\n");
+		return -EINVAL;
+	}
+	strncat(gc05a2->sd.name, " ", 1);
+	strncat(gc05a2->sd.name, dev->of_node->name,
+	        V4L2_SUBDEV_NAME_SIZE - strlen(gc05a2->sd.name) - 2);
+	dev_dbg(&client->dev, "after: gc05a2->sd.name: %s\n", gc05a2->sd.name);
+
+
+	ret = media_entity_pads_init(&gc05a2->sd.entity, 1, &gc05a2->pad);
+	if (ret < 0) {
+		dev_err(dev, "could not register media entity\n");
+		goto free_ctrl;
+	}
+
+
+	ret = v4l2_async_register_subdev_sensor(&gc05a2->sd);
+	if (ret < 0) {
+		dev_err(dev, "could not register v4l2 device\n");
+		goto free_entity;
+	}
+
+	pm_runtime_set_active(gc05a2->dev);
+	pm_runtime_enable(gc05a2->dev);
+	pm_runtime_idle(gc05a2->dev);
+
+	dev_info(dev, "--- %s -", __func__);
+
+	return 0;
+
+free_entity:
+	media_entity_cleanup(&gc05a2->sd.entity);
+free_ctrl:
+	mutex_destroy(&gc05a2->mutex);
+	v4l2_ctrl_handler_free(&gc05a2->ctrls);
+	pm_runtime_disable(gc05a2->dev);
+
+	return ret;
+}
+
+static void gc05a2_remove(struct i2c_client *client)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct gc05a2 *gc05a2 = to_gc05a2(sd);
+
+	v4l2_async_unregister_subdev(&gc05a2->sd);
+	media_entity_cleanup(&gc05a2->sd.entity);
+	v4l2_ctrl_handler_free(&gc05a2->ctrls);
+
+	pm_runtime_disable(&client->dev);
+	pm_runtime_set_suspended(&client->dev);
+
+	mutex_destroy(&gc05a2->mutex);
+
+	return;
+}
+
+static const struct of_device_id gc05a2_of_match[] = {
+	{ .compatible = "GalaxyCore,gc05a2" },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, gc05a2_of_match);
+
+static const struct dev_pm_ops gc05a2_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(gc05a2_suspend, gc05a2_resume)
+	SET_RUNTIME_PM_OPS(gc05a2_power_off, gc05a2_power_on, NULL)
+};
+
+static struct i2c_driver gc05a2_i2c_driver = {
+	.driver = {
+		.of_match_table = gc05a2_of_match,
+		.pm = &gc05a2_pm_ops,
+		.name  = "gc05a2",
+	},
+	.probe_new  = gc05a2_probe,
+	.remove = gc05a2_remove,
+};
+
+module_i2c_driver(gc05a2_i2c_driver);
+
+MODULE_DESCRIPTION("GalaxyCore gc05a2 Camera driver");
+MODULE_AUTHOR("Zhi Mao <zhi.mao@mediatek.com>");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/media/i2c/gc08a3.c b/drivers/media/i2c/gc08a3.c
new file mode 100755
index 0000000000000000000000000000000000000000..7fcdc401f05ac496a8e975593c9d2be4ba845e95
--- /dev/null
+++ b/drivers/media/i2c/gc08a3.c
@@ -0,0 +1,2072 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * gc08a3.c - gc08a3 sensor driver
+ *
+ * Copyright 2023 Mediatek
+ *
+ * Zhi Mao <zhi.mao@mediatek.com>
+ */
+
+
+#include <asm/unaligned.h>
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/gpio/consumer.h>
+#include <linux/i2c.h>
+#include <linux/module.h>
+#include <linux/pm_runtime.h>
+#include <linux/regmap.h>
+#include <linux/regulator/consumer.h>
+#include <media/media-entity.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-fwnode.h>
+#include <media/v4l2-subdev.h>
+
+//=========================================
+#define GC08A3_REG_VALUE_08BIT		1
+#define GC08A3_REG_VALUE_16BIT		2
+#define GC08A3_REG_VALUE_24BIT		3
+
+#define GC08A3_REG_CHIP_ID			0x03f0
+#define GC08A3_CHIP_ID				0x08a3
+
+#define GC08A3_REG_TEST_PATTERN_EN	0x008c
+#define GC08A3_REG_TEST_PATTERN_IDX	0x008d
+#define GC08A3_TEST_PATTERN_EN	    0x01
+
+
+#define GC08A3_STRAEMING_REG		0x0100
+
+#define GC08A3_SCLK					280000000LL
+
+#define GC08A3_DEFAULT_CLK_FREQ		24000000
+#define GC08A3_FPS					30
+#define GC08A3_MBUS_CODE			MEDIA_BUS_FMT_SRGGB10_1X10
+#define GC08A3_DATA_LANES			4
+
+//for 1920*1080
+#define GC08A3_LINK_FREQ_207MHZ		207000000ULL
+//for 3264*2448
+#define GC08A3_LINK_FREQ_336MHZ		336000000ULL
+
+
+#define GC08A3_RGB_DEPTH			10
+
+//frame length
+#define GC08A3_FL_REG				0x0340
+#define GC08A3_VTS_30FPS			2548
+#define GC08A3_VTS_30FPS_MIN		2548
+#define GC08A3_VTS_60FPS			1276
+#define GC08A3_VTS_60FPS_MIN		1276
+#define GC08A3_VTS_MAX				0xfff0
+#define GC08A3_FL_MARGIN			48
+
+// line length
+#define GC08A3_LL_REG				0x0342
+#define GC08A3_HTS_30FPS			3640
+#define GC08A3_HTS_60FPS			3640
+
+
+#define GC08A3_EXP_REG				0x0202
+#define GC08A3_EXP_MARGIN			16
+#define GC08A3_EXP_MIN		        4
+#define GC08A3_EXP_STEP		        1
+
+#define GC08A3_FLIP_REG				0x0101
+#define GC08A3_FLIP_H_MASK			0x1
+#define GC08A3_FLIP_V_MASK			0x2
+
+#define GC08A3_AGAIN_REG			0x0204
+#define GC08A3_AGAIN_MIN			1024
+#define GC08A3_AGAIN_MAX			1024*16
+#define GC08A3_AGAIN_STEP			1
+
+#define GC08A3_DGAIN_REG			0x020e
+#define GC08A3_DGAIN_MIN			1024
+#define GC08A3_DGAIN_MAX			1024
+#define GC08A3_DGAIN_STEP			1
+//============================================================
+
+//============================================================
+static const char *const gc08a3_test_pattern_menu[] = {
+	"No Pattern",
+	"Solid Black",
+	"Solid White",
+	"Solid Red",
+	"Solid Green",
+	"Solid Blue",
+	"Solid Yellow",
+	"Colour Bar",
+};
+
+enum {
+	GC08A3_LINK_FREQ_336MHZ_CFG,
+	GC08A3_LINK_FREQ_207MHZ_CFG,
+};
+
+static const s64 link_freq_menu_items[] = {
+    GC08A3_LINK_FREQ_336MHZ,
+    GC08A3_LINK_FREQ_207MHZ,
+};
+
+static const char *const gc08a3_supply_name[] = {
+	"avdd",
+	"dvdd",
+	"dovdd",
+};
+
+#define GC08A3_NUM_SUPPLIES ARRAY_SIZE(gc08a3_supply_name)
+
+struct gc08a3 {
+	struct device *dev;
+	struct v4l2_subdev sd;
+	struct media_pad pad;
+	struct v4l2_mbus_framefmt fmt;
+	struct i2c_client *client;
+
+	struct v4l2_rect crop;
+
+	struct clk *xclk;
+	struct regulator_bulk_data	supplies[GC08A3_NUM_SUPPLIES];
+	struct gpio_desc *enable_gpio;
+
+	struct regmap *regmap;
+
+	struct v4l2_ctrl_handler ctrls;
+	struct v4l2_ctrl *pixel_rate;
+	struct v4l2_ctrl *link_freq;
+	struct v4l2_ctrl *exposure;
+	struct v4l2_ctrl *vblank;
+	struct v4l2_ctrl *hblank;
+
+	/*
+	 * Serialize control access, get/set format, get selection
+	 * and start streaming.
+	 */
+	struct mutex mutex;
+
+	bool streaming;
+
+	/* Current mode */
+	const struct gc08a3_mode *cur_mode;
+};
+
+
+struct reg_8 {
+	u16 address;
+	u8 val;
+};
+
+struct gc08a3_reg_list {
+	u32 num_of_regs;
+	const struct reg_8 *regs;
+};
+
+struct gc08a3_link_freq_config {
+	const struct gc08a3_reg_list reg_list;
+};
+
+enum {
+	GC08A3_TABLE_WAIT_MS = 0,
+	GC08A3_TABLE_END,
+};
+
+/*From gc08a3_mode_tbls.h*/
+static const struct reg_8 mode_3264x2448[] = {
+
+	/*system*/
+	{0x031c, 0x60},
+	{0x0337, 0x04},
+	{0x0335, 0x51},
+	{0x0336, 0x70},
+	{0x0383, 0xbb},
+	{0x031a, 0x00},
+	{0x0321, 0x10},
+	{0x0327, 0x03},
+	{0x0325, 0x40},
+	{0x0326, 0x23},
+	{0x0314, 0x11},
+	{0x0315, 0xd6},
+	{0x0316, 0x01},
+	{0x0334, 0x40},
+	{0x0324, 0x42},
+	{0x031c, 0x00},
+	{0x031c, 0x9f},
+	{0x0344, 0x00},
+	{0x0345, 0x06},
+	{0x0346, 0x00},
+	{0x0347, 0x04},
+	{0x0348, 0x0c},
+	{0x0349, 0xd0}, //3280
+	{0x034a, 0x09},
+	{0x034b, 0x9c}, //2460
+	{0x0202, 0x09},
+	{0x0203, 0x04}, //Exp
+	{0x0340, 0x09},
+	{0x0341, 0xf4}, //FL
+	{0x0342, 0x07},
+	{0x0343, 0x1c}, //LineLength
+
+	{0x0226, 0x00}, //min vb[15:8]
+	{0x0227, 0x28}, //min vb[7:0]
+	{0x0e38, 0x49},
+	{0x0210, 0x13},
+	{0x0218, 0x00},
+	{0x0241, 0x88},
+	{0x0392, 0x60},
+
+	/*ISP*/
+	{0x031c, 0x80},
+	{0x03fe, 0x10}, //CISCTL_rst
+	{0x03fe, 0x00},
+	{0x031c, 0x9f},
+	{0x03fe, 0x00},
+	{0x03fe, 0x00},
+	{0x03fe, 0x00},
+	{0x03fe, 0x00},
+	{0x031c, 0x80},
+	{0x03fe, 0x10},
+	{0x03fe, 0x00},
+	{0x031c, 0x9f},
+	{0x00a2, 0x00},
+	{0x00a3, 0x00},
+	{0x00ab, 0x00},
+	{0x00ac, 0x00},
+	{0x05a0, 0x82},
+	{0x05ac, 0x00},
+	{0x05ad, 0x01},
+	{0x05ae, 0x00},
+	{0x0800, 0x0a},
+	{0x0801, 0x14},
+	{0x0802, 0x28},
+	{0x0803, 0x34},
+	{0x0804, 0x0e},
+	{0x0805, 0x33},
+	{0x0806, 0x03},
+	{0x0807, 0x8a},
+	{0x0808, 0x50},
+	{0x0809, 0x00},
+	{0x080a, 0x34},
+	{0x080b, 0x03},
+	{0x080c, 0x26},
+	{0x080d, 0x03},
+	{0x080e, 0x18},
+	{0x080f, 0x03},
+	{0x0810, 0x10},
+	{0x0811, 0x03},
+	{0x0812, 0x00},
+	{0x0813, 0x00},
+	{0x0814, 0x01},
+	{0x0815, 0x00},
+	{0x0816, 0x01},
+	{0x0817, 0x00},
+	{0x0818, 0x00},
+	{0x0819, 0x0a},
+	{0x081a, 0x01},
+	{0x081b, 0x6c},
+	{0x081c, 0x00},
+	{0x081d, 0x0b},
+	{0x081e, 0x02},
+	{0x081f, 0x00},
+	{0x0820, 0x00},
+	{0x0821, 0x0c},
+	{0x0822, 0x02},
+	{0x0823, 0xd9},
+	{0x0824, 0x00},
+	{0x0825, 0x0d},
+	{0x0826, 0x03},
+	{0x0827, 0xf0},
+	{0x0828, 0x00},
+	{0x0829, 0x0e},
+	{0x082a, 0x05},
+	{0x082b, 0x94},
+	{0x082c, 0x09},
+	{0x082d, 0x6e},
+	{0x082e, 0x07},
+	{0x082f, 0xe6},
+	{0x0830, 0x10},
+	{0x0831, 0x0e},
+	{0x0832, 0x0b},
+	{0x0833, 0x2c},
+	{0x0834, 0x14},
+	{0x0835, 0xae},
+	{0x0836, 0x0f},
+	{0x0837, 0xc4},
+	{0x0838, 0x18},
+	{0x0839, 0x0e},
+	{0x05ac, 0x01},
+	{0x059a, 0x00},
+	{0x059b, 0x00},
+	{0x059c, 0x01},
+	{0x0598, 0x00},
+	{0x0597, 0x14},
+	{0x05ab, 0x09},
+	{0x05a4, 0x02},
+	{0x05a3, 0x05},
+	{0x05a0, 0xc2},
+	{0x0207, 0xc4},
+
+	/*GAIN*/
+	{0x0204, 0x04},
+	{0x0205, 0x00},
+	{0x0050, 0x5c},
+	{0x0051, 0x44},
+
+	/*out window*/
+	{0x009a, 0x66},
+	{0x0351, 0x00},
+	{0x0352, 0x06}, //out_win_y1
+	{0x0353, 0x00},
+	{0x0354, 0x08}, //out_win_x1
+	{0x034c, 0x0c},
+	{0x034d, 0xc0}, //3264
+	{0x034e, 0x09},
+	{0x034f, 0x90}, //2448
+
+	/*MIPI*/
+	{0x0114, 0x03}, //0:1lane 1:2lane 3:4lane
+	{0x0180, 0x65}, //[3:0]dphy_mipi_diff
+	{0x0181, 0xf0},
+	{0x0185, 0x01},
+	{0x0115, 0x30},
+	{0x011b, 0x12},
+	{0x011c, 0x12},
+	{0x0121, 0x06}, //T_LPX
+	{0x0122, 0x06}, //T_CLK_HS_PREPARE
+	{0x0123, 0x15}, //T_CLK_zero
+	{0x0124, 0x01}, //T_CLK_PRE
+	{0x0125, 0x0b}, //T_CLK_POST
+	{0x0126, 0x08}, //T_CLK_TRAIL
+	{0x0129, 0x06}, //T_HS_PREPARE
+	{0x012a, 0x08}, //T_HS_Zero
+	{0x012b, 0x08}, //T_HS_TRAIL
+
+	{0x0a73, 0x60},
+	{0x0a70, 0x11},
+	{0x0313, 0x80},
+	{0x0aff, 0x00},
+	{0x0aff, 0x00},
+	{0x0aff, 0x00},
+	{0x0aff, 0x00},
+	{0x0aff, 0x00},
+	{0x0aff, 0x00},
+	{0x0aff, 0x00},
+	{0x0aff, 0x00},
+	{0x0a70, 0x00},
+	{0x00a4, 0x80},
+	{0x0316, 0x01},
+	{0x0a67, 0x00},
+	{0x0084, 0x10},
+	{0x0102, 0x09},
+
+	{GC08A3_TABLE_END, 0x00}
+};
+
+static const struct reg_8 mode_1920x1080[] = {
+
+	/*system*/
+	{0x031c, 0x60},
+	{0x0337, 0x04},
+	{0x0335, 0x51},
+	{0x0336, 0x45},
+	{0x0383, 0x8b},
+	{0x031a, 0x00},
+	{0x0321, 0x10},
+	{0x0327, 0x03},
+	{0x0325, 0x40},
+	{0x0326, 0x23},
+	{0x0314, 0x11},
+	{0x0315, 0xd6},
+	{0x0316, 0x01},
+	{0x0334, 0x40},
+	{0x0324, 0x42},
+	{0x031c, 0x00},
+	{0x031c, 0x9f},
+	{0x0344, 0x02},
+	{0x0345, 0xa6},
+	{0x0346, 0x02},
+	{0x0347, 0xb0},
+	{0x0348, 0x07},
+	{0x0349, 0x90}, //1936
+	{0x034a, 0x04},
+	{0x034b, 0x44}, //1092
+	{0x0202, 0x03},
+	{0x0203, 0x00}, //Exp
+	{0x0340, 0x04},
+	{0x0341, 0xfc}, //FL
+	{0x0342, 0x07},
+	{0x0343, 0x1c}, //LineLength
+
+	{0x0226, 0x00}, //min vb[15:8]
+	{0x0227, 0x88}, //min vb[7:0]
+	{0x0e38, 0x49},
+	{0x0210, 0x13},
+	{0x0218, 0x00},
+	{0x0241, 0x88},
+	{0x0392, 0x60},
+
+	/*ISP*/
+	{0x031c, 0x80},
+	{0x03fe, 0x10}, //CISCTL_rst
+	{0x03fe, 0x00},
+	{0x031c, 0x9f},
+	{0x03fe, 0x00},
+	{0x03fe, 0x00},
+	{0x03fe, 0x00},
+	{0x03fe, 0x00},
+	{0x031c, 0x80},
+	{0x03fe, 0x10},
+	{0x03fe, 0x00},
+	{0x031c, 0x9f},
+	{0x00a2, 0xac},
+	{0x00a3, 0x02},
+	{0x00ab, 0xa0},
+	{0x00ac, 0x02},
+	{0x05a0, 0x82},
+	{0x05ac, 0x00},
+	{0x05ad, 0x01},
+	{0x05ae, 0x00},
+	{0x0800, 0x0a},
+	{0x0801, 0x14},
+	{0x0802, 0x28},
+	{0x0803, 0x34},
+	{0x0804, 0x0e},
+	{0x0805, 0x33},
+	{0x0806, 0x03},
+	{0x0807, 0x8a},
+	{0x0808, 0x50},
+	{0x0809, 0x00},
+	{0x080a, 0x34},
+	{0x080b, 0x03},
+	{0x080c, 0x26},
+	{0x080d, 0x03},
+	{0x080e, 0x18},
+	{0x080f, 0x03},
+	{0x0810, 0x10},
+	{0x0811, 0x03},
+	{0x0812, 0x00},
+	{0x0813, 0x00},
+	{0x0814, 0x01},
+	{0x0815, 0x00},
+	{0x0816, 0x01},
+	{0x0817, 0x00},
+	{0x0818, 0x00},
+	{0x0819, 0x0a},
+	{0x081a, 0x01},
+	{0x081b, 0x6c},
+	{0x081c, 0x00},
+	{0x081d, 0x0b},
+	{0x081e, 0x02},
+	{0x081f, 0x00},
+	{0x0820, 0x00},
+	{0x0821, 0x0c},
+	{0x0822, 0x02},
+	{0x0823, 0xd9},
+	{0x0824, 0x00},
+	{0x0825, 0x0d},
+	{0x0826, 0x03},
+	{0x0827, 0xf0},
+	{0x0828, 0x00},
+	{0x0829, 0x0e},
+	{0x082a, 0x05},
+	{0x082b, 0x94},
+	{0x082c, 0x09},
+	{0x082d, 0x6e},
+	{0x082e, 0x07},
+	{0x082f, 0xe6},
+	{0x0830, 0x10},
+	{0x0831, 0x0e},
+	{0x0832, 0x0b},
+	{0x0833, 0x2c},
+	{0x0834, 0x14},
+	{0x0835, 0xae},
+	{0x0836, 0x0f},
+	{0x0837, 0xc4},
+	{0x0838, 0x18},
+	{0x0839, 0x0e},
+	{0x05ac, 0x01},
+	{0x059a, 0x00},
+	{0x059b, 0x00},
+	{0x059c, 0x01},
+	{0x0598, 0x00},
+	{0x0597, 0x14},
+	{0x05ab, 0x09},
+	{0x05a4, 0x02},
+	{0x05a3, 0x05},
+	{0x05a0, 0xc2},
+	{0x0207, 0xc4},
+
+	/*GAIN*/
+	{0x0204, 0x04},
+	{0x0205, 0x00},
+	{0x0050, 0x38},
+	{0x0051, 0x20},
+
+	/*out window*/
+	{0x009a, 0x66},
+	{0x0351, 0x00},
+	{0x0352, 0x06}, //out_win_y1
+	{0x0353, 0x00},
+	{0x0354, 0x08}, //out_win_x1
+	{0x034c, 0x07},
+	{0x034d, 0x80}, //1920
+	{0x034e, 0x04},
+	{0x034f, 0x38}, //1080
+
+	/*MIPI*/
+	{0x0114, 0x03}, //0:1lane 1:2lane 3:4lane
+	{0x0180, 0x65}, //[3:0]dphy_mipi_diff
+	{0x0181, 0xf0},
+	{0x0185, 0x01},
+	{0x0115, 0x30},
+	{0x011b, 0x12},
+	{0x011c, 0x12},
+	{0x0121, 0x02}, //T_LPX
+	{0x0122, 0x03}, //T_CLK_HS_PREPARE
+	{0x0123, 0x0c}, //T_CLK_zero
+	{0x0124, 0x00}, //T_CLK_PRE
+	{0x0125, 0x09}, //T_CLK_POST
+	{0x0126, 0x06}, //T_CLK_TRAIL
+	{0x0129, 0x04}, //T_HS_PREPARE
+	{0x012a, 0x03}, //T_HS_Zero
+	{0x012b, 0x06}, //T_HS_TRAIL
+
+	{0x0a73, 0x60},
+	{0x0a70, 0x11},
+	{0x0313, 0x80},
+	{0x0aff, 0x00},
+	{0x0aff, 0x00},
+	{0x0aff, 0x00},
+	{0x0aff, 0x00},
+	{0x0aff, 0x00},
+	{0x0aff, 0x00},
+	{0x0aff, 0x00},
+	{0x0aff, 0x00},
+	{0x0a70, 0x00},
+	{0x00a4, 0x80},
+	{0x0316, 0x01},
+	{0x0a67, 0x00},
+	{0x0084, 0x10},
+	{0x0102, 0x09},
+
+	{GC08A3_TABLE_END, 0x00}
+};
+
+static const struct reg_8 mode_table_common[] = {
+
+	{GC08A3_STRAEMING_REG, 0x00},
+	/*system*/
+	{0x031c, 0x60},
+	{0x0337, 0x04},
+	{0x0335, 0x51},
+	{0x0336, 0x70},
+	{0x0383, 0xbb},
+	{0x031a, 0x00},
+	{0x0321, 0x10},
+	{0x0327, 0x03},
+	{0x0325, 0x40},
+	{0x0326, 0x23},
+	{0x0314, 0x11},
+	{0x0315, 0xd6},
+	{0x0316, 0x01},
+	{0x0334, 0x40},
+	{0x0324, 0x42},
+	{0x031c, 0x00},
+	{0x031c, 0x9f},
+	{0x039a, 0x13},
+	{0x0084, 0x30},
+	{0x02b3, 0x08},
+	{0x0057, 0x0c},
+	{0x05c3, 0x50},
+	{0x0311, 0x90},
+	{0x05a0, 0x02},
+	{0x0074, 0x0a},
+	{0x0059, 0x11},
+	{0x0070, 0x05},
+	{0x0101, 0x00}, //[1]updown [0]mirror
+
+	/*analog*/
+	{0x0344, 0x00},
+	{0x0345, 0x06},
+	{0x0346, 0x00},
+	{0x0347, 0x04},
+	{0x0348, 0x0c},
+	{0x0349, 0xd0}, //3280
+	{0x034a, 0x09},
+	{0x034b, 0x9c}, //2460
+	{0x0202, 0x09},
+	{0x0203, 0x04}, //Exp
+
+	{0x0219, 0x05}, //[4]FL_depend_exp
+	{0x0226, 0x00}, //min vb[15:8]
+	{0x0227, 0x28}, //min vb[7:0]
+	{0x0e0a, 0x00},
+	{0x0e0b, 0x00},
+	{0x0e24, 0x04},
+	{0x0e25, 0x04},
+	{0x0e26, 0x00},
+	{0x0e27, 0x10},
+	{0x0e01, 0x74},
+	{0x0e03, 0x47},
+	{0x0e04, 0x33},
+	{0x0e05, 0x44},
+	{0x0e06, 0x44},
+	{0x0e0c, 0x1e},
+	{0x0e17, 0x3a},
+	{0x0e18, 0x3c},
+	{0x0e19, 0x40},
+	{0x0e1a, 0x42},
+	{0x0e28, 0x21},
+	{0x0e2b, 0x68},
+	{0x0e2c, 0x0d},
+	{0x0e2d, 0x08},
+	{0x0e34, 0xf4},
+	{0x0e35, 0x44},
+	{0x0e36, 0x07},
+	{0x0e38, 0x49},
+	{0x0210, 0x13},
+	{0x0218, 0x00},
+	{0x0241, 0x88},
+	{0x0e32, 0x00},
+	{0x0e33, 0x18},
+	{0x0e42, 0x03},
+	{0x0e43, 0x80},
+	{0x0e44, 0x04},
+	{0x0e45, 0x00},
+	{0x0e4f, 0x04},
+	{0x057a, 0x20},
+	{0x0381, 0x7c},
+	{0x0382, 0x9b},
+	{0x0384, 0xfb},
+	{0x0389, 0x38},
+	{0x038a, 0x03},
+	{0x0390, 0x6a},
+	{0x0391, 0x0b},
+	{0x0392, 0x60},
+	{0x0393, 0xc1},
+	{0x0396, 0xff},
+	{0x0398, 0x62},
+
+	/*cisctl reset*/
+	{0x031c, 0x80},
+	{0x03fe, 0x10}, //CISCTL_rst
+	{0x03fe, 0x00},
+	{0x031c, 0x9f},
+	{0x03fe, 0x00},
+	{0x03fe, 0x00},
+	{0x03fe, 0x00},
+	{0x03fe, 0x00},
+	{0x031c, 0x80},
+	{0x03fe, 0x10}, //CISCTL_rst
+	{0x03fe, 0x00},
+	{0x031c, 0x9f},
+	{0x0360, 0x01},
+	{0x0360, 0x00},
+	{0x0316, 0x09},
+	{0x0a67, 0x80},
+	{0x0313, 0x00},
+	{0x0a53, 0x0e},
+	{0x0a65, 0x17},
+	{0x0a68, 0xa1},
+	{0x0a58, 0x00},
+	{0x0ace, 0x0c},
+	{0x00a4, 0x00},
+	{0x00a5, 0x01},
+	{0x00a7, 0x09},
+	{0x00a8, 0x9c},
+	{0x00a9, 0x0c},
+	{0x00aa, 0xd0},
+	{0x0a8a, 0x00},
+	{0x0a8b, 0xe0},
+	{0x0a8c, 0x13},
+	{0x0a8d, 0xe8},
+	{0x0a90, 0x0a},
+	{0x0a91, 0x10},
+	{0x0a92, 0xf8},
+	{0x0a71, 0xf2},
+	{0x0a72, 0x12},
+	{0x0a73, 0x64},
+	{0x0a75, 0x41},
+	{0x0a70, 0x07},
+	{0x0313, 0x80},
+
+	/*ISP*/
+	{0x00a0, 0x01},
+	{0x0080, 0xd2},
+	{0x0081, 0x3f},
+	{0x0087, 0x51},
+	{0x0089, 0x03},
+	{0x009b, 0x40},
+	{0x05a0, 0x82},
+	{0x05ac, 0x00},
+	{0x05ad, 0x01},
+	{0x05ae, 0x00},
+	{0x0800, 0x0a},
+	{0x0801, 0x14},
+	{0x0802, 0x28},
+	{0x0803, 0x34},
+	{0x0804, 0x0e},
+	{0x0805, 0x33},
+	{0x0806, 0x03},
+	{0x0807, 0x8a},
+	{0x0808, 0x50},
+	{0x0809, 0x00},
+	{0x080a, 0x34},
+	{0x080b, 0x03},
+	{0x080c, 0x26},
+	{0x080d, 0x03},
+	{0x080e, 0x18},
+	{0x080f, 0x03},
+	{0x0810, 0x10},
+	{0x0811, 0x03},
+	{0x0812, 0x00},
+	{0x0813, 0x00},
+	{0x0814, 0x01},
+	{0x0815, 0x00},
+	{0x0816, 0x01},
+	{0x0817, 0x00},
+	{0x0818, 0x00},
+	{0x0819, 0x0a},
+	{0x081a, 0x01},
+	{0x081b, 0x6c},
+	{0x081c, 0x00},
+	{0x081d, 0x0b},
+	{0x081e, 0x02},
+	{0x081f, 0x00},
+	{0x0820, 0x00},
+	{0x0821, 0x0c},
+	{0x0822, 0x02},
+	{0x0823, 0xd9},
+	{0x0824, 0x00},
+	{0x0825, 0x0d},
+	{0x0826, 0x03},
+	{0x0827, 0xf0},
+	{0x0828, 0x00},
+	{0x0829, 0x0e},
+	{0x082a, 0x05},
+	{0x082b, 0x94},
+	{0x082c, 0x09},
+	{0x082d, 0x6e},
+	{0x082e, 0x07},
+	{0x082f, 0xe6},
+	{0x0830, 0x10},
+	{0x0831, 0x0e},
+	{0x0832, 0x0b},
+	{0x0833, 0x2c},
+	{0x0834, 0x14},
+	{0x0835, 0xae},
+	{0x0836, 0x0f},
+	{0x0837, 0xc4},
+	{0x0838, 0x18},
+	{0x0839, 0x0e},
+	{0x05ac, 0x01},
+	{0x059a, 0x00},
+	{0x059b, 0x00},
+	{0x059c, 0x01},
+	{0x0598, 0x00},
+	{0x0597, 0x14},
+	{0x05ab, 0x09},
+	{0x05a4, 0x02},
+	{0x05a3, 0x05},
+	{0x05a0, 0xc2},
+	{0x0207, 0xc4},
+
+	/*GAIN*/
+	{0x0208, 0x01},
+	{0x0209, 0x72},
+	{0x0204, 0x04},
+	{0x0205, 0x00},
+
+	{0x0040, 0x22},
+	{0x0041, 0x20},
+	{0x0043, 0x10},
+	{0x0044, 0x00},
+	{0x0046, 0x08},
+	{0x0047, 0xf0},
+	{0x0048, 0x0f},
+	{0x004b, 0x0f},
+	{0x004c, 0x00},
+	{0x0050, 0x5c},
+	{0x0051, 0x44},
+	{0x005b, 0x03},
+	{0x00c0, 0x00},
+	{0x00c1, 0x80},
+	{0x00c2, 0x31},
+	{0x00c3, 0x00},
+	{0x0460, 0x04},
+	{0x0462, 0x08},
+	{0x0464, 0x0e},
+	{0x0466, 0x0a},
+	{0x0468, 0x12},
+	{0x046a, 0x12},
+	{0x046c, 0x10},
+	{0x046e, 0x0c},
+	{0x0461, 0x03},
+	{0x0463, 0x03},
+	{0x0465, 0x03},
+	{0x0467, 0x03},
+	{0x0469, 0x04},
+	{0x046b, 0x04},
+	{0x046d, 0x04},
+	{0x046f, 0x04},
+	{0x0470, 0x04},
+	{0x0472, 0x10},
+	{0x0474, 0x26},
+	{0x0476, 0x38},
+	{0x0478, 0x20},
+	{0x047a, 0x30},
+	{0x047c, 0x38},
+	{0x047e, 0x60},
+	{0x0471, 0x05},
+	{0x0473, 0x05},
+	{0x0475, 0x05},
+	{0x0477, 0x05},
+	{0x0479, 0x04},
+	{0x047b, 0x04},
+	{0x047d, 0x04},
+	{0x047f, 0x04},
+
+	{GC08A3_TABLE_END, 0x00}
+};
+
+static const struct gc08a3_link_freq_config link_freq_configs[] = {
+	[GC08A3_LINK_FREQ_336MHZ_CFG] = {
+		.reg_list = {
+			.num_of_regs = ARRAY_SIZE(mode_table_common),
+			.regs = mode_table_common,
+		}
+	},
+	[GC08A3_LINK_FREQ_207MHZ_CFG] = {
+		.reg_list = {
+			.num_of_regs = ARRAY_SIZE(mode_table_common),
+			.regs = mode_table_common,
+		}
+	},
+
+	// TODO:
+};
+
+enum {
+	GC08A3_PREV,
+	GC08A3_HS,
+};
+
+/*
+ * Declare modes in order, from biggest
+ * to smallest height.
+ */
+static const struct gc08a3_mode {
+	u8  mode_id;
+	u32 width;
+	u32 height;
+	const struct gc08a3_reg_list reg_list;
+
+	u32 hts; /* Horizontal timining size */
+	u32 vts_def; /* Default vertical timining size */
+	u32 vts_min; /* Min vertical timining size */
+	u32 link_freq_index; /* Link frequency needed for this resolution */
+	u32 max_framerate;
+
+} gc08a3_modes[] = {
+	{
+		.mode_id = GC08A3_PREV,
+		.width = 3264,
+		.height = 2448,
+		.reg_list = {
+			.num_of_regs = ARRAY_SIZE(mode_3264x2448),
+			.regs = mode_3264x2448,
+		},
+		.link_freq_index = GC08A3_LINK_FREQ_336MHZ_CFG,
+
+		.hts = GC08A3_HTS_30FPS,
+		.vts_def = GC08A3_VTS_30FPS,
+		.vts_min = GC08A3_VTS_30FPS_MIN,
+		.max_framerate = 300,
+	},
+	{
+		.mode_id = GC08A3_HS,
+		.width = 1920,
+		.height = 1080,
+		.reg_list = {
+			.num_of_regs = ARRAY_SIZE(mode_1920x1080),
+			.regs = mode_1920x1080,
+		},
+		.link_freq_index = GC08A3_LINK_FREQ_207MHZ_CFG,
+
+		.hts = GC08A3_HTS_60FPS,
+		.vts_def = GC08A3_VTS_60FPS,
+		.vts_min = GC08A3_VTS_60FPS_MIN,
+		.max_framerate = 600,
+	},
+};
+
+static u64 to_pixel_rate(u32 f_index)
+{
+	u64 pixel_rate = link_freq_menu_items[f_index] * 2 * GC08A3_DATA_LANES;
+
+	do_div(pixel_rate, GC08A3_RGB_DEPTH);
+
+	return pixel_rate;
+}
+
+static u64 __maybe_unused to_pixels_per_line(u32 hts, u32 f_index)
+{
+	u64 ppl = hts * to_pixel_rate(f_index);
+
+	do_div(ppl, GC08A3_SCLK);
+
+	return ppl;
+}
+
+static int gc08a3_read_reg(struct gc08a3 *gc08a3, u16 reg, u16 len, u32 *val)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&gc08a3->sd);
+	struct i2c_msg msgs[2];
+	u8 addr_buf[2];
+	u8 data_buf[4] = {0};
+	int ret;
+
+	if (len > 4)
+		return -EINVAL;
+
+	put_unaligned_be16(reg, addr_buf);
+	msgs[0].addr = client->addr;
+	msgs[0].flags = 0;
+	msgs[0].len = sizeof(addr_buf);
+	msgs[0].buf = addr_buf;
+	msgs[1].addr = client->addr;
+	msgs[1].flags = I2C_M_RD;
+	msgs[1].len = len;
+	msgs[1].buf = &data_buf[4 - len];
+
+	ret = i2c_transfer(client->adapter, msgs, ARRAY_SIZE(msgs));
+	if (ret != ARRAY_SIZE(msgs))
+		return -EIO;
+
+	*val = get_unaligned_be32(data_buf);
+
+	return 0;
+}
+
+static int gc08a3_write_reg(struct gc08a3 *gc08a3, u16 reg, u16 len, u32 val)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&gc08a3->sd);
+	u8 buf[6];
+
+	if (len > 4)
+		return -EINVAL;
+
+	put_unaligned_be16(reg, buf);
+	put_unaligned_be32(val << 8 * (4 - len), buf + 2);
+	if (i2c_master_send(client, buf, len + 2) != len + 2)
+		return -EIO;
+
+	return 0;
+}
+
+static int gc08a3_write_reg_list(struct gc08a3 *gc08a3,
+                                 const struct gc08a3_reg_list *r_list)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&gc08a3->sd);
+	unsigned int i;
+	int ret;
+
+	for (i = 0; i < r_list->num_of_regs; i++) {
+
+		if (r_list->regs[i].address == GC08A3_TABLE_WAIT_MS) {
+			usleep_range(r_list->regs[i].val * 1000,
+			             r_list->regs[i].val * 1000 + 500);
+			continue;
+		}
+
+		if (r_list->regs[i].address == GC08A3_TABLE_END) {
+			break;
+		}
+
+		ret = gc08a3_write_reg(gc08a3, r_list->regs[i].address,
+		                       GC08A3_REG_VALUE_08BIT,
+		                       r_list->regs[i].val);
+		if (ret) {
+			dev_err_ratelimited(&client->dev,
+			                    "failed to write reg 0x%4.4x. error = %d",
+			                    r_list->regs[i].address, ret);
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
+static int gc08a3_identify_module(struct gc08a3 *gc08a3)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&gc08a3->sd);
+	int ret;
+	u32 val;
+
+	ret = gc08a3_read_reg(gc08a3, GC08A3_REG_CHIP_ID,
+	                      GC08A3_REG_VALUE_16BIT, &val);
+
+	if (val != GC08A3_CHIP_ID) {
+		dev_err(&client->dev, "chip id mismatch: 0x%x!=0x%x",
+		        GC08A3_CHIP_ID, val);
+		return -ENXIO;
+	}
+
+	dev_info(&client->dev, "sensor_id: 0x%04x\n", val);
+	return 0;
+}
+
+static inline struct gc08a3 *to_gc08a3(struct v4l2_subdev *sd)
+{
+	return container_of(sd, struct gc08a3, sd);
+}
+
+static int __maybe_unused gc08a3_power_on(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct gc08a3 *gc08a3 = to_gc08a3(sd);
+	int ret;
+
+	dev_info(dev, "--- %s +", __func__);
+
+	gpiod_set_value_cansleep(gc08a3->enable_gpio, 0);
+	usleep_range(2000, 3000);
+
+	ret = regulator_bulk_enable(GC08A3_NUM_SUPPLIES, gc08a3->supplies);
+	if (ret < 0) {
+		dev_err(gc08a3->dev, "failed to enable regulators: %d\n", ret);
+		return ret;
+	}
+
+	//usleep_range(2000, 3000);
+
+	ret = clk_prepare_enable(gc08a3->xclk);
+	if (ret < 0) {
+		regulator_bulk_disable(GC08A3_NUM_SUPPLIES, gc08a3->supplies);
+		dev_err(gc08a3->dev, "clk prepare enable failed\n");
+		return ret;
+	}
+
+	usleep_range(2000, 3000);
+
+	gpiod_set_value_cansleep(gc08a3->enable_gpio, 1);
+	usleep_range(12000, 15000);
+
+	dev_info(dev, "--- %s -", __func__);
+
+	return 0;
+}
+
+static int __maybe_unused gc08a3_power_off(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct gc08a3 *gc08a3 = to_gc08a3(sd);
+
+	dev_info(dev, "--- %s +", __func__);
+
+	gpiod_set_value_cansleep(gc08a3->enable_gpio, 0);
+
+	clk_disable_unprepare(gc08a3->xclk);
+
+	regulator_bulk_disable(GC08A3_NUM_SUPPLIES, gc08a3->supplies);
+	usleep_range(10, 20);
+
+	dev_info(dev, "--- %s -", __func__);
+
+	return 0;
+}
+
+static int gc08a3_enum_mbus_code(struct v4l2_subdev *sd,
+                                 struct v4l2_subdev_state *sd_state,
+                                 struct v4l2_subdev_mbus_code_enum *code)
+{
+	if (code->index > 0)
+		return -EINVAL;
+
+	code->code = GC08A3_MBUS_CODE;
+
+	return 0;
+}
+
+static int gc08a3_enum_frame_size(struct v4l2_subdev *subdev,
+                                  struct v4l2_subdev_state *sd_state,
+                                  struct v4l2_subdev_frame_size_enum *fse)
+{
+	if (fse->code != GC08A3_MBUS_CODE)
+		return -EINVAL;
+
+	if (fse->index >= ARRAY_SIZE(gc08a3_modes))
+		return -EINVAL;
+
+	fse->min_width = fse->max_width = gc08a3_modes[fse->index].width;
+	fse->min_height = fse->max_height = gc08a3_modes[fse->index].height;
+
+	return 0;
+}
+
+#ifdef CONFIG_VIDEO_ADV_DEBUG
+static int gc08a3_g_register(struct v4l2_subdev *subdev,
+                             struct v4l2_dbg_register *reg)
+{
+	int ret;
+	u32 val;
+	struct gc08a3 *gc08a3 = container_of(subdev, struct gc08a3, sd);
+
+	ret = gc08a3_read_reg(gc08a3, reg->reg,
+	                      GC08A3_REG_VALUE_08BIT, &val);
+	if (ret < 0)
+		return ret;
+
+	reg->val = val;
+	reg->size = 1;
+
+	return 0;
+}
+
+static int gc08a3_s_register(struct v4l2_subdev *subdev,
+                             const struct v4l2_dbg_register *reg)
+{
+	struct gc08a3 *gc08a3 = container_of(subdev, struct gc08a3, sd);
+
+	return gc08a3_write_reg(gc08a3, reg->reg,
+	                        GC08A3_REG_VALUE_08BIT, reg->val & 0xff);
+}
+
+#endif
+
+static const struct v4l2_subdev_core_ops gc08a3_core_ops = {
+#ifdef CONFIG_VIDEO_ADV_DEBUG
+	.g_register = gc08a3_g_register,
+	.s_register = gc08a3_s_register,
+#endif
+};
+
+static struct v4l2_mbus_framefmt *
+__gc08a3_get_pad_format(struct gc08a3 *gc08a3,
+                        struct v4l2_subdev_state *sd_state,
+                        unsigned int pad,
+                        enum v4l2_subdev_format_whence which)
+{
+	switch (which) {
+	case V4L2_SUBDEV_FORMAT_TRY:
+		return v4l2_subdev_get_try_format(&gc08a3->sd, sd_state, pad);
+	case V4L2_SUBDEV_FORMAT_ACTIVE:
+		return &gc08a3->fmt;
+	default:
+		return NULL;
+	}
+}
+
+static int gc08a3_get_format(struct v4l2_subdev *sd,
+                             struct v4l2_subdev_state *sd_state,
+                             struct v4l2_subdev_format *format)
+{
+	struct gc08a3 *gc08a3 = to_gc08a3(sd);
+
+	mutex_lock(&gc08a3->mutex);
+	format->format = *__gc08a3_get_pad_format(gc08a3, sd_state,
+	                 format->pad,
+	                 format->which);
+	mutex_unlock(&gc08a3->mutex);
+
+	return 0;
+}
+
+static struct v4l2_rect *
+__gc08a3_get_pad_crop(struct gc08a3 *gc08a3,
+                      struct v4l2_subdev_state *sd_state,
+                      unsigned int pad, enum v4l2_subdev_format_whence which)
+{
+	switch (which) {
+	case V4L2_SUBDEV_FORMAT_TRY:
+		return v4l2_subdev_get_try_crop(&gc08a3->sd, sd_state, pad);
+	case V4L2_SUBDEV_FORMAT_ACTIVE:
+		return &gc08a3->crop;
+	default:
+		return NULL;
+	}
+}
+
+static int gc08a3_update_cur_mode_controls(struct gc08a3 *gc08a3)
+{
+	s64 exposure_max, h_blank;
+	int ret = 0;
+
+	ret = __v4l2_ctrl_modify_range(gc08a3->vblank,
+						   gc08a3->cur_mode->vts_min - gc08a3->cur_mode->height,
+						   GC08A3_VTS_MAX - gc08a3->cur_mode->height,
+						   1,
+						   gc08a3->cur_mode->vts_def - gc08a3->cur_mode->height);
+	if (ret) {
+		dev_err(gc08a3->dev, "VB ctrl range update failed\n");
+	}
+
+	h_blank = gc08a3->cur_mode->hts - gc08a3->cur_mode->width;
+	ret = __v4l2_ctrl_modify_range(gc08a3->hblank,
+						   h_blank, h_blank, 1, h_blank);
+	if (ret) {
+		dev_err(gc08a3->dev, "HB ctrl range update failed\n");
+	}
+
+	exposure_max = gc08a3->cur_mode->vts_def - GC08A3_EXP_MARGIN;
+	ret = __v4l2_ctrl_modify_range(gc08a3->exposure,
+						 GC08A3_EXP_MIN,
+						 exposure_max,
+						 GC08A3_EXP_STEP,
+						 exposure_max);
+	if (ret) {
+		dev_err(gc08a3->dev, "exposure ctrl range update failed\n");
+	}
+	return ret;
+}
+
+
+static int gc08a3_set_format(struct v4l2_subdev *sd,
+                             struct v4l2_subdev_state *sd_state,
+                             struct v4l2_subdev_format *format)
+{
+	struct gc08a3 *gc08a3 = to_gc08a3(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(&gc08a3->sd);
+	struct device *dev = &client->dev;
+	struct v4l2_mbus_framefmt *__format;
+	struct v4l2_rect *__crop;
+	const struct gc08a3_mode *mode;
+
+	mutex_lock(&gc08a3->mutex);
+
+	dev_dbg(dev, "---- %s, format(W x H:%d x %d)  +",
+	         __func__, format->format.width, format->format.height);
+
+	__crop = __gc08a3_get_pad_crop(gc08a3, sd_state, format->pad,
+	                               format->which);
+
+	mode = v4l2_find_nearest_size(gc08a3_modes,
+	                              ARRAY_SIZE(gc08a3_modes), width, height,
+	                              format->format.width,
+	                              format->format.height);
+
+	dev_dbg(dev, "----nearest mode(W x H:%d x %d)",
+	         mode->width, mode->height);
+
+	__crop->width = mode->width;
+	__crop->height = mode->height;
+
+	__format = __gc08a3_get_pad_format(gc08a3, sd_state, format->pad,
+	                                   format->which);
+	__format->width = __crop->width;
+	__format->height = __crop->height;
+	__format->code = GC08A3_MBUS_CODE;
+	__format->field = V4L2_FIELD_NONE;
+	__format->colorspace = V4L2_COLORSPACE_SRGB;
+	__format->ycbcr_enc = V4L2_MAP_YCBCR_ENC_DEFAULT(__format->colorspace);
+	__format->quantization = V4L2_MAP_QUANTIZATION_DEFAULT(true,
+	                         __format->colorspace, __format->ycbcr_enc);
+	__format->xfer_func = V4L2_MAP_XFER_FUNC_DEFAULT(__format->colorspace);
+
+	format->format = *__format;
+
+	gc08a3->cur_mode = mode;
+    gc08a3_update_cur_mode_controls(gc08a3);
+
+	mutex_unlock(&gc08a3->mutex);
+
+	return 0;
+}
+
+static int gc08a3_get_selection(struct v4l2_subdev *sd,
+                                struct v4l2_subdev_state *sd_state,
+                                struct v4l2_subdev_selection *sel)
+{
+	struct gc08a3 *gc08a3 = to_gc08a3(sd);
+
+	if (sel->target != V4L2_SEL_TGT_CROP)
+		return -EINVAL;
+
+	mutex_lock(&gc08a3->mutex);
+	sel->r = *__gc08a3_get_pad_crop(gc08a3, sd_state, sel->pad,
+	                                sel->which);
+	mutex_unlock(&gc08a3->mutex);
+	return 0;
+}
+
+static int gc08a3_entity_init_cfg(struct v4l2_subdev *subdev,
+                                  struct v4l2_subdev_state *sd_state)
+{
+	struct v4l2_subdev_format fmt = { };
+
+	fmt.which = sd_state ? V4L2_SUBDEV_FORMAT_TRY : V4L2_SUBDEV_FORMAT_ACTIVE;
+	fmt.format.width = gc08a3_modes[0].width;
+	fmt.format.height = gc08a3_modes[0].height;
+
+	gc08a3_set_format(subdev, sd_state, &fmt);
+
+	return 0;
+}
+
+static int gc08a3_set_ctrl_hflip(struct gc08a3 *gc08a3, u32 ctrl_val)
+{
+	int ret;
+	u32 val;
+
+	ret = gc08a3_read_reg(gc08a3, GC08A3_FLIP_REG,
+	                      GC08A3_REG_VALUE_08BIT, &val);
+	if (ret) {
+		dev_err(gc08a3->dev, "read hflip register failed: %d\n", ret);
+		return ret;
+	}
+
+	val = (ctrl_val) ? (val | GC08A3_FLIP_H_MASK)
+	      : (val & ~GC08A3_FLIP_H_MASK);
+	ret = gc08a3_write_reg(gc08a3, GC08A3_FLIP_REG,
+	                       GC08A3_REG_VALUE_08BIT, val);
+	if (ret < 0)
+		dev_err(gc08a3->dev, "Error %d\n", ret);
+
+	return ret;
+
+}
+
+static int gc08a3_set_ctrl_vflip(struct gc08a3 *gc08a3, u32 ctrl_val)
+{
+	int ret;
+	u32 val;
+
+	ret = gc08a3_read_reg(gc08a3, GC08A3_FLIP_REG,
+	                      GC08A3_REG_VALUE_08BIT, &val);
+	if (ret) {
+		dev_err(gc08a3->dev, "read vflip register failed: %d\n", ret);
+		return ret;
+	}
+
+	val = (ctrl_val) ? (val | GC08A3_FLIP_V_MASK)
+	      : (val & ~GC08A3_FLIP_V_MASK);
+	ret = gc08a3_write_reg(gc08a3, GC08A3_FLIP_REG,
+	                       GC08A3_REG_VALUE_08BIT, val);
+	if (ret < 0)
+		dev_err(gc08a3->dev, "Error %d\n", ret);
+
+	return ret;
+}
+
+static int gc08a3_test_pattern(struct gc08a3 *gc08a3, u32 pattern_menu)
+{
+	int ret = 0;
+	u32 pattern = 0;
+	if (pattern_menu) {
+		// write bit16:0x0110 -> color bar
+		switch (pattern_menu) {
+		case 1:
+			pattern = 0x00;
+			break;
+		case 2:
+		case 3:
+		case 4:
+		case 5:
+		case 6:
+			pattern = pattern_menu + 2;
+			break;
+		case 7:
+			pattern = 0x10;
+			break;
+
+		default:
+			dev_dbg(gc08a3->dev, "invalid pattern menu!\n");
+			break;
+		}
+
+		ret = gc08a3_write_reg(gc08a3, GC08A3_REG_TEST_PATTERN_EN,
+							GC08A3_REG_VALUE_08BIT, GC08A3_TEST_PATTERN_EN);
+		ret = gc08a3_write_reg(gc08a3, GC08A3_REG_TEST_PATTERN_IDX,
+							GC08A3_REG_VALUE_08BIT, pattern);
+
+	} else {
+		ret = gc08a3_write_reg(gc08a3, GC08A3_REG_TEST_PATTERN_EN,
+							GC08A3_REG_VALUE_08BIT, 0x00);
+	}
+
+	return ret;
+}
+
+static int set_ext_ctrl(struct v4l2_ctrl *ctrl)
+{
+	int ret = 0;
+//	struct gc08a3 *gc08a3 = container_of(ctrl->handler, struct gc08a3, ctrls);
+//	struct i2c_client *client = v4l2_get_subdevdata(&gc08a3->sd);
+
+	switch (ctrl->id) {
+	// TODO: add extension CMD
+
+	}
+
+	return ret;
+}
+
+static int gc08a3_set_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct gc08a3 *gc08a3 = container_of(ctrl->handler,
+	                                     struct gc08a3, ctrls);
+	int ret = 0;
+	s64 exposure_max;
+
+	if (ctrl->id == V4L2_CID_VBLANK) {
+		/* Update max exposure while meeting expected vblanking */
+		exposure_max = gc08a3->cur_mode->height + ctrl->val - GC08A3_EXP_MARGIN;
+		__v4l2_ctrl_modify_range(gc08a3->exposure,
+		                         gc08a3->exposure->minimum,
+		                         exposure_max, gc08a3->exposure->step,
+		                         exposure_max);
+	}
+
+	/*
+	 * Applying V4L2 control value only happens
+	 * when power is up for streaming
+	 */
+	if (!pm_runtime_get_if_in_use(gc08a3->dev))
+		return 0;
+
+	switch (ctrl->id) {
+	case V4L2_CID_EXPOSURE:
+		//dev_info(gc08a3->dev, "V4L2_CID_EXPOSURE:0x%x\n", ctrl->val);
+		ret = gc08a3_write_reg(gc08a3, GC08A3_EXP_REG,
+		                       GC08A3_REG_VALUE_16BIT, ctrl->val);
+		break;
+
+	case V4L2_CID_ANALOGUE_GAIN:
+		//dev_info(gc08a3->dev, "V4L2_CID_ANALOGUE_GAIN:0x%x\n", ctrl->val);
+		ret = gc08a3_write_reg(gc08a3, GC08A3_AGAIN_REG,
+		                       GC08A3_REG_VALUE_16BIT, ctrl->val);
+		break;
+
+	case V4L2_CID_DIGITAL_GAIN:
+		ret = gc08a3_write_reg(gc08a3, GC08A3_DGAIN_REG,
+		                       GC08A3_REG_VALUE_16BIT, ctrl->val);
+		break;
+
+	case V4L2_CID_VBLANK:
+		dev_info(gc08a3->dev, "V4L2_CID_VBLANK:height:%d, V_BLNK:%d\n",
+        		 gc08a3->cur_mode->height, ctrl->val);
+		ret = gc08a3_write_reg(gc08a3, GC08A3_FL_REG,
+		                       GC08A3_REG_VALUE_16BIT,
+		                       gc08a3->cur_mode->height + ctrl->val);
+		break;
+
+	case V4L2_CID_HFLIP:
+		gc08a3_set_ctrl_hflip(gc08a3, ctrl->val);
+		break;
+
+	case V4L2_CID_VFLIP:
+		gc08a3_set_ctrl_vflip(gc08a3, ctrl->val);
+		break;
+
+	case V4L2_CID_TEST_PATTERN:
+		ret = gc08a3_test_pattern(gc08a3, ctrl->val);
+		break;
+
+	default:
+		ret = set_ext_ctrl(ctrl);
+		break;
+	}
+
+	pm_runtime_put(gc08a3->dev);
+
+	return ret;
+}
+
+static int get_volatile_ext_ctrl(struct v4l2_ctrl *ctrl)
+{
+	int ret = 0;
+	struct gc08a3 *gc08a3 = container_of(ctrl->handler, struct gc08a3, ctrls);
+	struct i2c_client *client = v4l2_get_subdevdata(&gc08a3->sd);
+
+	dev_dbg(&client->dev, "---- %s, CMD:0x%x\n", __func__, ctrl->id);
+	switch (ctrl->id) {
+	default:
+		dev_info(&client->dev, "[gc08a3] %s, un-support CMD: 0x%x\n", __func__, ctrl->id);
+		break;
+	}
+
+	return ret;
+}
+
+static int gc08a3_g_volatile_ctrl(struct v4l2_ctrl *ctrl)
+{
+	int ret = 0;
+
+	switch (ctrl->id) {
+	default:
+		ret = get_volatile_ext_ctrl(ctrl);
+		break;
+	}
+
+	return ret;
+}
+
+static int try_ext_ctrl(struct v4l2_ctrl *ctrl)
+{
+	int ret = 0;
+	struct gc08a3 *gc08a3 = container_of(ctrl->handler, struct gc08a3, ctrls);
+	struct i2c_client *client = v4l2_get_subdevdata(&gc08a3->sd);
+
+	switch (ctrl->id) {
+	default:
+		dev_dbg(&client->dev, "[gc08a3] un-handle CMD: 0x%x (%s : %d)\n",
+		        ctrl->id, __func__, __LINE__);
+		break;
+	}
+
+	return ret;
+}
+
+static int gc08a3_try_ctrl(struct v4l2_ctrl *ctrl)
+{
+	int ret = 0;
+
+	switch (ctrl->id) {
+	case V4L2_CID_EXPOSURE:
+	case V4L2_CID_ANALOGUE_GAIN:
+	case V4L2_CID_DIGITAL_GAIN:
+	case V4L2_CID_VBLANK:
+	case V4L2_CID_HFLIP:
+	case V4L2_CID_VFLIP:
+	case V4L2_CID_TEST_PATTERN:
+		return 0;
+
+	default:
+		ret = try_ext_ctrl(ctrl);
+		break;
+	}
+
+	return ret;
+}
+
+
+const struct v4l2_ctrl_ops gc08a3_ctrl_ops = {
+	.g_volatile_ctrl = gc08a3_g_volatile_ctrl,
+	.try_ctrl = gc08a3_try_ctrl,
+	.s_ctrl = gc08a3_set_ctrl,
+};
+
+//============================================================
+static int gc08a3_init_ext_controls(struct v4l2_ctrl_handler *ctrl_hdlr)
+{
+	return 0;
+}
+//============================================================
+
+static int gc08a3_start_streaming(struct gc08a3 *gc08a3)
+{
+	const struct gc08a3_mode *mode;
+	const struct gc08a3_reg_list *reg_list;
+	int link_freq_index;
+	int ret;
+
+	dev_info(gc08a3->dev, "%s ++\n", __func__);
+
+	mutex_lock(&gc08a3->mutex);
+
+	link_freq_index = gc08a3->cur_mode->link_freq_index;
+	dev_info(gc08a3->dev, "----link_freq_index = %d ",
+	         link_freq_index);
+
+	reg_list = &link_freq_configs[link_freq_index].reg_list;
+	ret = gc08a3_write_reg_list(gc08a3, reg_list);
+	if (ret) {
+		dev_err(gc08a3->dev, "could not sent common table %d\n", ret);
+		goto error;
+	}
+
+	mode = gc08a3->cur_mode;
+	dev_info(gc08a3->dev, "----write regtbl: mode(id:%d, WxH:%dx%d)",
+            mode->mode_id,
+            mode->width, mode->height);
+	reg_list = &mode->reg_list;
+
+	ret = gc08a3_write_reg_list(gc08a3,  reg_list);
+	if (ret < 0) {
+		dev_err(gc08a3->dev, "could not sent mode table %d\n", ret);
+		goto error;
+	}
+	ret = __v4l2_ctrl_handler_setup(&gc08a3->ctrls);
+	if (ret < 0) {
+		dev_err(gc08a3->dev, "could not sync v4l2 controls\n");
+		goto error;
+	}
+
+	ret = gc08a3_write_reg(gc08a3, GC08A3_STRAEMING_REG,
+	                       GC08A3_REG_VALUE_08BIT, 1);
+	if (ret < 0) {
+		dev_err(gc08a3->dev, "write STRAEMING_REG failed: %d\n", ret);
+		goto error;
+	}
+
+
+	mutex_unlock(&gc08a3->mutex);
+
+	dev_info(gc08a3->dev, "%s --\n", __func__);
+
+	return 0;
+
+error:
+	mutex_unlock(&gc08a3->mutex);
+	return ret;
+}
+
+static int gc08a3_stop_streaming(struct gc08a3 *gc08a3)
+{
+	int ret;
+
+	dev_info(gc08a3->dev, "%s ++\n", __func__);
+
+	ret = gc08a3_write_reg(gc08a3, GC08A3_STRAEMING_REG,
+	                       GC08A3_REG_VALUE_08BIT, 0);
+	if (ret < 0)
+		dev_err(gc08a3->dev, "could not sent stop streaming %d\n", ret);
+
+	dev_info(gc08a3->dev, "%s --\n", __func__);
+
+	return ret;
+}
+
+static int gc08a3_s_stream(struct v4l2_subdev *subdev, int enable)
+{
+	struct gc08a3 *gc08a3 = to_gc08a3(subdev);
+	int ret;
+
+	if (gc08a3->streaming == enable)
+		return 0;
+
+	if (enable) {
+		ret = pm_runtime_resume_and_get(gc08a3->dev);
+		if (ret < 0)
+			return ret;
+
+		ret = gc08a3_start_streaming(gc08a3);
+		if (ret < 0)
+			goto err_rpm_put;
+	} else {
+		ret = gc08a3_stop_streaming(gc08a3);
+		if (ret < 0)
+			goto err_rpm_put;
+		pm_runtime_put(gc08a3->dev);
+	}
+
+	gc08a3->streaming = enable;
+	return 0;
+
+err_rpm_put:
+	pm_runtime_put(gc08a3->dev);
+	return ret;
+}
+
+static int gc08a3_g_mbus_config(struct v4l2_subdev *sd, unsigned int pad,
+                                struct v4l2_mbus_config *config)
+{
+	config->type = V4L2_MBUS_CSI2_DPHY;
+	config->bus.mipi_csi2.num_data_lanes = 4;
+	config->bus.mipi_csi2.flags = 0;
+	return 0;
+}
+
+static int gc08a3_g_frame_interval(struct v4l2_subdev *subdev,
+                                   struct v4l2_subdev_frame_interval *fival)
+{
+	struct gc08a3 *gc08a3 = to_gc08a3(subdev);
+
+	fival->interval.numerator = 1;
+	fival->interval.denominator = gc08a3->cur_mode->max_framerate / 10;
+
+	return 0;
+}
+
+static int gc08a3_enum_frame_interval(struct v4l2_subdev *subdev,
+                                      struct v4l2_subdev_state *sd_state,
+                                      struct v4l2_subdev_frame_interval_enum *fie)
+{
+	const struct gc08a3_mode *mode;
+
+	if (fie->index != 0)
+		return -EINVAL;
+
+	mode = v4l2_find_nearest_size(gc08a3_modes,
+	                              ARRAY_SIZE(gc08a3_modes), width, height,
+	                              fie->width, fie->height);
+
+	fie->code = GC08A3_MBUS_CODE;
+	fie->width = mode->width;
+	fie->height = mode->height;
+	fie->interval.numerator = 1;
+	fie->interval.denominator = mode->max_framerate / 10;
+
+	return 0;
+}
+
+static const struct v4l2_subdev_video_ops gc08a3_video_ops = {
+	.s_stream = gc08a3_s_stream,
+	.g_frame_interval = gc08a3_g_frame_interval,
+	.s_frame_interval = gc08a3_g_frame_interval,
+};
+
+static const struct v4l2_subdev_pad_ops gc08a3_subdev_pad_ops = {
+	.enum_mbus_code = gc08a3_enum_mbus_code,
+	.enum_frame_size = gc08a3_enum_frame_size,
+	.enum_frame_interval = gc08a3_enum_frame_interval,
+	.get_fmt = gc08a3_get_format,
+	.set_fmt = gc08a3_set_format,
+	.get_selection = gc08a3_get_selection,
+	.init_cfg = gc08a3_entity_init_cfg,
+	.get_mbus_config = gc08a3_g_mbus_config,
+};
+
+static const struct v4l2_subdev_ops gc08a3_subdev_ops = {
+	.core = &gc08a3_core_ops,
+	.video = &gc08a3_video_ops,
+	.pad = &gc08a3_subdev_pad_ops,
+};
+
+static const struct regmap_config sensor_regmap_config = {
+	.reg_bits = 16,
+	.val_bits = 8,
+	.cache_type = REGCACHE_RBTREE,
+};
+
+static int gc08a3_get_regulators(struct device *dev, struct gc08a3 *gc08a3)
+{
+	unsigned int i;
+
+	for (i = 0; i < GC08A3_NUM_SUPPLIES; i++)
+		gc08a3->supplies[i].supply = gc08a3_supply_name[i];
+
+	return devm_regulator_bulk_get(dev, GC08A3_NUM_SUPPLIES,
+	                               gc08a3->supplies);
+}
+
+static int gc08a3_parse_fwnode(struct device *dev)
+{
+	struct fwnode_handle *endpoint;
+	struct v4l2_fwnode_endpoint bus_cfg = {
+		.bus_type = V4L2_MBUS_CSI2_DPHY,
+	};
+	unsigned int i, j;
+	int ret;
+
+	endpoint = fwnode_graph_get_next_endpoint(dev_fwnode(dev), NULL);
+	if (!endpoint) {
+		dev_err(dev, "endpoint node not found\n");
+		return -EINVAL;
+	}
+
+	ret = v4l2_fwnode_endpoint_alloc_parse(endpoint, &bus_cfg);
+	if (ret) {
+		dev_err(dev, "parsing endpoint node failed\n");
+		goto done;
+	}
+
+	if (!bus_cfg.nr_of_link_frequencies) {
+		dev_err(dev, "no link frequencies defined");
+		ret = -EINVAL;
+		goto done;
+	}
+
+	for (i = 0; i < ARRAY_SIZE(link_freq_menu_items); i++) {
+		for (j = 0; j < bus_cfg.nr_of_link_frequencies; j++) {
+			if (link_freq_menu_items[i] == bus_cfg.link_frequencies[j])
+				break;
+		}
+
+		if (j == bus_cfg.nr_of_link_frequencies) {
+			dev_err(dev, "no link frequency %lld supported, please check DT",
+			        link_freq_menu_items[i]);
+			ret = -EINVAL;
+			goto done;
+		}
+	}
+
+done:
+	v4l2_fwnode_endpoint_free(&bus_cfg);
+	fwnode_handle_put(endpoint);
+	return ret;
+}
+
+static int __maybe_unused gc08a3_suspend(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct gc08a3 *gc08a3 = to_gc08a3(sd);
+
+	if (gc08a3->streaming)
+		gc08a3_stop_streaming(gc08a3);
+
+	return 0;
+}
+
+static int __maybe_unused gc08a3_resume(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct gc08a3 *gc08a3 = to_gc08a3(sd);
+	int ret;
+
+	if (gc08a3->streaming) {
+		ret = gc08a3_start_streaming(gc08a3);
+		if (ret)
+			goto error;
+	}
+
+	return 0;
+
+error:
+	gc08a3_stop_streaming(gc08a3);
+	gc08a3->streaming = 0;
+	return ret;
+}
+
+static int gc08a3_init_controls(struct gc08a3 *gc08a3)
+{
+	struct v4l2_ctrl_handler *ctrl_hdlr;
+	s64 exposure_max, h_blank;
+	int ret;
+
+	ctrl_hdlr = &gc08a3->ctrls;
+	ret = v4l2_ctrl_handler_init(ctrl_hdlr, 10);
+	if (ret)
+		return ret;
+
+	ctrl_hdlr->lock = &gc08a3->mutex;
+
+	gc08a3->link_freq = v4l2_ctrl_new_int_menu(ctrl_hdlr, &gc08a3_ctrl_ops,
+	                    V4L2_CID_LINK_FREQ,
+	                    ARRAY_SIZE(link_freq_menu_items) - 1,
+	                    0, link_freq_menu_items);
+	if (gc08a3->link_freq)
+		gc08a3->link_freq->flags |= V4L2_CTRL_FLAG_READ_ONLY;
+
+	gc08a3->pixel_rate = v4l2_ctrl_new_std(ctrl_hdlr, &gc08a3_ctrl_ops,
+	                      V4L2_CID_PIXEL_RATE, 0,
+	                      to_pixel_rate(GC08A3_LINK_FREQ_336MHZ_CFG),
+	                      1,
+	                      to_pixel_rate(GC08A3_LINK_FREQ_336MHZ_CFG));
+
+	gc08a3->vblank = v4l2_ctrl_new_std(&gc08a3->ctrls, &gc08a3_ctrl_ops,
+	                                   V4L2_CID_VBLANK,
+	                                   gc08a3->cur_mode->vts_min -
+	                                   gc08a3->cur_mode->height,
+	                                   GC08A3_VTS_MAX -
+	                                   gc08a3->cur_mode->height, 1,
+	                                   gc08a3->cur_mode->vts_def -
+	                                   gc08a3->cur_mode->height);
+
+	h_blank = gc08a3->cur_mode->hts - gc08a3->cur_mode->width;
+	gc08a3->hblank = v4l2_ctrl_new_std(&gc08a3->ctrls, &gc08a3_ctrl_ops,
+	                                   V4L2_CID_HBLANK, h_blank, h_blank, 1,
+	                                   h_blank);
+	if (gc08a3->hblank)
+		gc08a3->hblank->flags |= V4L2_CTRL_FLAG_READ_ONLY;
+
+	v4l2_ctrl_new_std(&gc08a3->ctrls, &gc08a3_ctrl_ops, V4L2_CID_ANALOGUE_GAIN,
+	                  GC08A3_AGAIN_MIN, GC08A3_AGAIN_MAX,
+	                  GC08A3_AGAIN_STEP, GC08A3_AGAIN_MIN);
+
+	v4l2_ctrl_new_std(&gc08a3->ctrls, &gc08a3_ctrl_ops, V4L2_CID_DIGITAL_GAIN,
+	                  GC08A3_DGAIN_MIN, GC08A3_DGAIN_MAX,
+	                  GC08A3_DGAIN_STEP, GC08A3_DGAIN_MIN);
+
+
+	exposure_max = gc08a3->cur_mode->vts_def - GC08A3_EXP_MARGIN;
+	gc08a3->exposure = v4l2_ctrl_new_std(ctrl_hdlr, &gc08a3_ctrl_ops,
+	                                     V4L2_CID_EXPOSURE,
+	                                     GC08A3_EXP_MIN, exposure_max,
+	                                     GC08A3_EXP_STEP,
+	                                     exposure_max);
+
+	v4l2_ctrl_new_std_menu_items(ctrl_hdlr, &gc08a3_ctrl_ops,
+	                             V4L2_CID_TEST_PATTERN,
+	                             ARRAY_SIZE(gc08a3_test_pattern_menu) - 1,
+	                             0, 0, gc08a3_test_pattern_menu);
+
+	v4l2_ctrl_new_std(&gc08a3->ctrls, &gc08a3_ctrl_ops,
+	                  V4L2_CID_HFLIP, 0, 1, 1, 0);
+
+	v4l2_ctrl_new_std(&gc08a3->ctrls, &gc08a3_ctrl_ops,
+	                  V4L2_CID_VFLIP, 0, 1, 1, 0);
+
+	if (ctrl_hdlr->error)
+		return ctrl_hdlr->error;
+
+	gc08a3->sd.ctrl_handler = ctrl_hdlr;
+
+	return 0;
+
+}
+
+
+
+static int gc08a3_probe(struct i2c_client *client)
+{
+	struct device *dev = &client->dev;
+	struct gc08a3 *gc08a3;
+	int ret;
+
+	dev_info(dev, "--- %s +", __func__);
+
+	ret = gc08a3_parse_fwnode(dev);
+	if (ret)
+		return ret;
+
+	gc08a3 = devm_kzalloc(dev, sizeof(*gc08a3), GFP_KERNEL);
+	if (!gc08a3)
+		return -ENOMEM;
+
+	gc08a3->dev = dev;
+
+	gc08a3->xclk = devm_clk_get(dev, NULL);
+	if (IS_ERR(gc08a3->xclk)) {
+		dev_err(dev, "could not get xclk\n");
+		return PTR_ERR(gc08a3->xclk);
+	}
+
+	ret = clk_set_rate(gc08a3->xclk, GC08A3_DEFAULT_CLK_FREQ);
+	if (ret) {
+		dev_err(dev, "could not set xclk frequency\n");
+		return ret;
+	}
+
+	ret = gc08a3_get_regulators(dev, gc08a3);
+	if (ret < 0) {
+		dev_err(dev, "cannot get regulators\n");
+		return ret;
+	}
+
+	gc08a3->enable_gpio = devm_gpiod_get(dev, "enable", GPIOD_OUT_LOW);
+	if (IS_ERR(gc08a3->enable_gpio)) {
+		dev_err(dev, "cannot get enable gpio\n");
+		return PTR_ERR(gc08a3->enable_gpio);
+	}
+
+	gc08a3->regmap = devm_regmap_init_i2c(client, &sensor_regmap_config);
+	if (IS_ERR(gc08a3->regmap)) {
+		dev_err(dev, "regmap init failed\n");
+		return PTR_ERR(gc08a3->regmap);
+	}
+
+	v4l2_i2c_subdev_init(&gc08a3->sd, client, &gc08a3_subdev_ops);
+
+	gc08a3_power_on(gc08a3->dev);
+
+	ret = gc08a3_identify_module(gc08a3);
+	if (ret) {
+		dev_err(&client->dev, "failed to find sensor: %d\n", ret);
+		gc08a3_power_off(gc08a3->dev);
+		return ret;
+	}
+
+	mutex_init(&gc08a3->mutex);
+	gc08a3->cur_mode = &gc08a3_modes[0];
+
+	ret = gc08a3_init_controls(gc08a3);
+	if (ret) {
+		dev_err(&client->dev, "failed to init controls: %d", ret);
+		goto free_ctrl;
+	}
+
+	gc08a3->sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+	gc08a3->pad.flags = MEDIA_PAD_FL_SOURCE;
+	gc08a3->sd.dev = &client->dev;
+	gc08a3->sd.entity.function = MEDIA_ENT_F_CAM_SENSOR;
+
+	// Init ExtCMD
+	ret = gc08a3_init_ext_controls(&gc08a3->ctrls);
+	if (ret) {
+		dev_err(&client->dev, "failed to init controls: %d", ret);
+		goto free_ctrl;
+	}
+
+	dev_dbg(&client->dev, "gc08a3->sd.name: %s, dev->of_node->name: %s\n",
+	        gc08a3->sd.name, dev->of_node->name);
+	if (V4L2_SUBDEV_NAME_SIZE - strlen(gc08a3->sd.name) - 2
+	    < strlen(dev->of_node->name)) {
+		dev_err(&client->dev,
+		        "the string length of (sd.name + of_node->name) is too long.\n");
+		return -EINVAL;
+	}
+	strncat(gc08a3->sd.name, " ", 1);
+	strncat(gc08a3->sd.name, dev->of_node->name,
+	        V4L2_SUBDEV_NAME_SIZE - strlen(gc08a3->sd.name) - 2);
+	dev_dbg(&client->dev, "after: gc08a3->sd.name: %s\n", gc08a3->sd.name);
+
+
+	ret = media_entity_pads_init(&gc08a3->sd.entity, 1, &gc08a3->pad);
+	if (ret < 0) {
+		dev_err(dev, "could not register media entity\n");
+		goto free_ctrl;
+	}
+
+
+	ret = v4l2_async_register_subdev_sensor(&gc08a3->sd);
+	if (ret < 0) {
+		dev_err(dev, "could not register v4l2 device\n");
+		goto free_entity;
+	}
+
+	pm_runtime_set_active(gc08a3->dev);
+	pm_runtime_enable(gc08a3->dev);
+	pm_runtime_idle(gc08a3->dev);
+
+	dev_info(dev, "--- %s -", __func__);
+
+	return 0;
+
+free_entity:
+	media_entity_cleanup(&gc08a3->sd.entity);
+free_ctrl:
+	mutex_destroy(&gc08a3->mutex);
+	v4l2_ctrl_handler_free(&gc08a3->ctrls);
+	pm_runtime_disable(gc08a3->dev);
+
+	return ret;
+}
+
+static void gc08a3_remove(struct i2c_client *client)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct gc08a3 *gc08a3 = to_gc08a3(sd);
+
+	v4l2_async_unregister_subdev(&gc08a3->sd);
+	media_entity_cleanup(&gc08a3->sd.entity);
+	v4l2_ctrl_handler_free(&gc08a3->ctrls);
+
+	pm_runtime_disable(&client->dev);
+	pm_runtime_set_suspended(&client->dev);
+
+	mutex_destroy(&gc08a3->mutex);
+
+	return;
+}
+
+static const struct of_device_id gc08a3_of_match[] = {
+	{ .compatible = "GalaxyCore,gc08a3" },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, gc08a3_of_match);
+
+static const struct dev_pm_ops gc08a3_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(gc08a3_suspend, gc08a3_resume)
+	SET_RUNTIME_PM_OPS(gc08a3_power_off, gc08a3_power_on, NULL)
+};
+
+static struct i2c_driver gc08a3_i2c_driver = {
+	.driver = {
+		.of_match_table = gc08a3_of_match,
+		.pm = &gc08a3_pm_ops,
+		.name  = "gc08a3",
+	},
+	.probe_new  = gc08a3_probe,
+	.remove = gc08a3_remove,
+};
+
+module_i2c_driver(gc08a3_i2c_driver);
+
+MODULE_DESCRIPTION("GalaxyCore gc08a3 Camera driver");
+MODULE_AUTHOR("Zhi Mao <zhi.mao@mediatek.com>");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/media/i2c/gt97xx.c b/drivers/media/i2c/gt97xx.c
new file mode 100755
index 0000000000000000000000000000000000000000..593af1e7b5b56c9c221020fc08347a6b8268052f
--- /dev/null
+++ b/drivers/media/i2c/gt97xx.c
@@ -0,0 +1,716 @@
+// SPDX-License-Identifier: GPL-2.0
+// Copyright (c) 2020 MediaTek Inc.
+
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/module.h>
+#include <linux/pm_runtime.h>
+#include <linux/regulator/consumer.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <media/v4l2-async.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-fwnode.h>
+#include <media/v4l2-subdev.h>
+
+
+//============================================
+#define GT9768_ID				0xE9
+#define GT9769_ID				0xE1
+
+
+//============================================
+#define GT97XX_NAME				"gt97xx"
+
+#define GT97XX_IC_INFO_REG		0x00
+
+/*
+ * Ring control and Power control register
+ * Bit[1] RING_EN
+ * 0: Direct mode
+ * 1: AAC mode (ringing control mode)
+ * Bit[0] PD
+ * 0: Normal operation mode
+ * 1: Power down mode
+ * gt97xx requires waiting time of Topr after PD reset takes place.
+ */
+#define GT97XX_RING_PD_CONTROL_REG		0x02
+#define GT97XX_PD_MODE_OFF			0x00
+#define GT97XX_PD_MODE_EN			BIT(0)
+#define GT97XX_AAC_MODE_EN			BIT(1)
+
+/*
+ * gt97xx separates two registers to control the VCM position.
+ * One for MSB value, another is LSB value.
+ * DAC_MSB: D[9:8] (ADD: 0x03)
+ * DAC_LSB: D[7:0] (ADD: 0x04)
+ * D[9:0] DAC data input: positive output current = D[9:0] / 1023 * 100[mA]
+ */
+#define GT97XX_MSB_ADDR_REG				0x03
+#define GT97XX_LSB_ADDR_REG				0x04
+#define GT97XX_STATUS_ADDR_REG			0x05
+
+/*
+ * AAC mode control & prescale register
+ * Bit[7:5] Namely AC[2:0], decide the VCM mode and operation time.
+ * 001 AAC2 0.48 x Tvib
+ * 010 AAC3 0.70 x Tvib
+ * 011 AAC4 0.75 x Tvib
+ * 101 AAC8 1.13 x Tvib
+ * Bit[2:0] Namely PRESC[2:0], set the internal clock dividing rate as follow.
+ * 000 2
+ * 001 1
+ * 010 1/2
+ * 011 1/4
+ * 100 8
+ * 101 4
+ */
+#define GT97XX_AAC_PRESC_REG			0x06
+#define GT97XX_AAC_MODE_SEL_MASK		GENMASK(7, 5)
+#define GT97XX_CLOCK_PRE_SCALE_SEL_MASK		GENMASK(2, 0)
+
+/*
+ * VCM period of vibration register
+ * Bit[5:0] Defined as VCM rising periodic time (Tvib) together with PRESC[2:0]
+ * Tvib = (6.3ms + AACT[5:0] * 0.1ms) * Dividing Rate
+ * Dividing Rate is the internal clock dividing rate that is defined at
+ * PRESCALE register (ADD: 0x06)
+ */
+#define GT97XX_AAC_TIME_REG			0x07
+
+/*
+ * gt97xx requires waiting time (delay time) of t_OPR after power-up,
+ * or in the case of PD reset taking place.
+ */
+#define GT97XX_T_OPR_US				1000
+#define GT97XX_TVIB_MS_BASE10			(64 - 1)
+#define GT97XX_AAC_MODE_DEFAULT			2
+#define GT97XX_AAC_TIME_DEFAULT			0x20
+#define GT97XX_CLOCK_PRE_SCALE_DEFAULT		1
+
+/*
+ * This acts as the minimum granularity of lens movement.
+ * Keep this value power of 2, so the control steps can be
+ * uniformly adjusted for gradual lens movement, with desired
+ * number of control steps.
+ */
+#define GT97XX_MOVE_STEPS			16
+
+#define GT97XX_MAX_FOCUS_POS			(1024 - 1)
+/*
+ * This sets the minimum granularity for the focus positions.
+ * A value of 1 gives maximum accuracy for a desired focus position
+ */
+#define GT97XX_FOCUS_STEPS			1
+
+
+enum vcm_giantec_reg_desc {
+    //========================
+	GT_IC_COM_REGS_START,
+	GT_IC_INFO_REG = GT_IC_COM_REGS_START,
+	GT_RING_PD_CONTROL_REG,
+	GT_MSB_ADDR_REG,
+	GT_LSB_ADDR_REG,
+	GT_STATUS_ADDR_REG,
+	GT_AAC_PRESC_REG,
+	GT_AAC_TIME_REG,
+	GT_IC_COM_REGS_END = GT_AAC_TIME_REG,
+    //========================
+    //========================
+    GT_IC_DIFF_REGS_START,
+
+    GT_IC_DIFF_REGS_END,
+    //========================
+	GT_MAX_REG,
+};
+
+struct vcm_giantec_of_data {
+	unsigned int id;
+    unsigned int regs[GT_MAX_REG];
+};
+
+static const char * const gt97xx_supply_names[] = {
+	"vin",	/* Digital I/O power */
+	"vdd",	/* Digital core power */
+};
+
+/* gt97xx device structure */
+struct gt97xx {
+	struct v4l2_subdev sd;
+
+	struct regulator_bulk_data supplies[ARRAY_SIZE(gt97xx_supply_names)];
+
+	struct v4l2_ctrl_handler ctrls;
+	struct v4l2_ctrl *focus;
+
+	u32 aac_mode;
+	u32 aac_timing;
+	u32 clock_presc;
+	u32 move_delay_us;
+
+	const struct vcm_giantec_of_data *chip;
+};
+
+static inline struct gt97xx *sd_to_gt97xx(struct v4l2_subdev *subdev)
+{
+	return container_of(subdev, struct gt97xx, sd);
+}
+
+struct regval_list {
+	u8 reg_num;
+	u8 value;
+};
+
+struct gt97xx_aac_mode_ot_multi {
+	u32 aac_mode_enum;
+	u32 ot_multi_base100;
+};
+
+struct gt97xx_clk_presc_dividing_rate {
+	u32 clk_presc_enum;
+	u32 dividing_rate_base100;
+};
+
+static const struct vcm_giantec_of_data gt97xx_com_regs = {
+    .regs[GT_IC_INFO_REG] = GT97XX_IC_INFO_REG,
+    .regs[GT_RING_PD_CONTROL_REG] = GT97XX_RING_PD_CONTROL_REG,
+    .regs[GT_MSB_ADDR_REG] = GT97XX_MSB_ADDR_REG,
+    .regs[GT_LSB_ADDR_REG] = GT97XX_LSB_ADDR_REG,
+    .regs[GT_STATUS_ADDR_REG] = GT97XX_STATUS_ADDR_REG,
+    .regs[GT_AAC_PRESC_REG] = GT97XX_AAC_PRESC_REG,
+    .regs[GT_AAC_TIME_REG] = GT97XX_AAC_TIME_REG,
+};
+
+static const struct gt97xx_aac_mode_ot_multi aac_mode_ot_multi[] = {
+	{1,  48},
+	{2,  70},
+	{3,  75},
+	{5, 113},
+};
+
+static const struct gt97xx_clk_presc_dividing_rate presc_dividing_rate[] = {
+	{0, 200},
+	{1, 100},
+	{2,  50},
+	{3,  25},
+	{4, 800},
+	{5, 400},
+};
+
+static u32 gt97xx_find_ot_multi(u32 aac_mode_param)
+{
+	u32 cur_ot_multi_base100 = 70;
+	unsigned int i;
+
+	for (i = 0; i < ARRAY_SIZE(aac_mode_ot_multi); i++) {
+		if (aac_mode_ot_multi[i].aac_mode_enum == aac_mode_param) {
+			cur_ot_multi_base100 =
+				aac_mode_ot_multi[i].ot_multi_base100;
+		}
+	}
+
+	return cur_ot_multi_base100;
+}
+
+static u32 gt97xx_find_dividing_rate(u32 presc_param)
+{
+	u32 cur_clk_dividing_rate_base100 = 100;
+	unsigned int i;
+
+	for (i = 0; i < ARRAY_SIZE(presc_dividing_rate); i++) {
+		if (presc_dividing_rate[i].clk_presc_enum == presc_param) {
+			cur_clk_dividing_rate_base100 =
+				presc_dividing_rate[i].dividing_rate_base100;
+		}
+	}
+
+	return cur_clk_dividing_rate_base100;
+}
+
+/*
+ * GT97xx_AAC_PRESC_REG & GT97xx_AAC_TIME_REG determine VCM operation time.
+ * For current VCM mode: AAC3, Operation Time would be 0.70 x Tvib.
+ * Tvib = (6.3ms + AACT[5:0] * 0.1MS) * Dividing Rate.
+ * Below is calculation of the operation delay for each step.
+ */
+static inline u32 gt97xx_cal_move_delay(u32 aac_mode_param, u32 presc_param,
+					u32 aac_timing_param)
+{
+	u32 Tvib_us;
+	u32 ot_multi_base100;
+	u32 clk_dividing_rate_base100;
+
+	ot_multi_base100 = gt97xx_find_ot_multi(aac_mode_param);
+
+	clk_dividing_rate_base100 = gt97xx_find_dividing_rate(presc_param);
+
+	Tvib_us = (GT97XX_TVIB_MS_BASE10 + aac_timing_param) *
+		  clk_dividing_rate_base100;
+
+	return Tvib_us * ot_multi_base100 / 100;
+}
+
+static int gt97xx_mod_reg(struct gt97xx *gt97xx, u8 reg, u8 mask, u8 val)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&gt97xx->sd);
+	int ret;
+
+	ret = i2c_smbus_read_byte_data(client, reg);
+	if (ret < 0)
+		return ret;
+
+	val = ((unsigned char)ret & ~mask) | (val & mask);
+
+	return i2c_smbus_write_byte_data(client, reg, val);
+}
+
+static int gt97xx_set_dac(struct gt97xx *gt97xx, u16 val)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&gt97xx->sd);
+
+	/* Write VCM position to registers */
+	return i2c_smbus_write_word_swapped(client,
+                                        gt97xx->chip->regs[GT_MSB_ADDR_REG],
+                                        val);
+}
+
+static int gt97xx_identify_module(struct gt97xx *gt97xx)
+{
+    int ic_id = 0xff;
+	struct i2c_client *client = v4l2_get_subdevdata(&gt97xx->sd);
+
+    ic_id = i2c_smbus_read_byte_data(client,
+                gt97xx->chip->regs[GT_IC_INFO_REG]);
+    dev_info(&client->dev, "chip_id: 0x%x", ic_id);
+    if (ic_id == gt97xx->chip->id)
+        dev_info(&client->dev, "gt97xx_id OK!");
+    else {
+        dev_info(&client->dev, "gt97xx_id:0x%x fail!!!",gt97xx->chip->id);
+        return -1;
+    }
+    return 0;
+}
+
+static int gt97xx_init(struct gt97xx *gt97xx)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&gt97xx->sd);
+	int ret, val;
+
+	ret = gt97xx_identify_module(gt97xx);
+	if (ret < 0)
+		return ret;
+
+	/* Reset GT97xx_RING_PD_CONTROL_REG to default status 0x00 */
+	ret = i2c_smbus_write_byte_data(client,
+                	gt97xx->chip->regs[GT_RING_PD_CONTROL_REG],
+					GT97XX_PD_MODE_OFF);
+	if (ret < 0)
+		return ret;
+
+	/*
+	 * GT97xx requires waiting delay time of t_OPR
+	 * after PD reset takes place.
+	 */
+	usleep_range(GT97XX_T_OPR_US, GT97XX_T_OPR_US + 100);
+
+	/* Set GT97xx_RING_PD_CONTROL_REG to GT9768_AAC_MODE_EN(0x01) */
+	ret = i2c_smbus_write_byte_data(client,
+                	gt97xx->chip->regs[GT_RING_PD_CONTROL_REG],
+					GT97XX_AAC_MODE_EN);
+	if (ret < 0)
+		return ret;
+
+	/* Set AAC mode */
+	ret = gt97xx_mod_reg(gt97xx, gt97xx->chip->regs[GT_AAC_PRESC_REG],
+			     GT97XX_AAC_MODE_SEL_MASK,
+			     gt97xx->aac_mode << 5);
+	if (ret < 0)
+		return ret;
+
+	/* Set clock presc */
+	if (gt97xx->clock_presc != GT97XX_CLOCK_PRE_SCALE_DEFAULT) {
+		ret = gt97xx_mod_reg(gt97xx, gt97xx->chip->regs[GT_AAC_PRESC_REG],
+				     GT97XX_CLOCK_PRE_SCALE_SEL_MASK,
+				     gt97xx->clock_presc);
+		if (ret < 0)
+			return ret;
+	}
+
+	/* Set AAC Timing */
+	if (gt97xx->aac_timing != GT97XX_AAC_TIME_DEFAULT) {
+		ret = i2c_smbus_write_byte_data(client,
+                        gt97xx->chip->regs[GT_AAC_TIME_REG],
+						gt97xx->aac_timing);
+		if (ret < 0)
+			return ret;
+	}
+
+	for (val = gt97xx->focus->val % GT97XX_MOVE_STEPS;
+	     val <= gt97xx->focus->val;
+	     val += GT97XX_MOVE_STEPS) {
+		ret = gt97xx_set_dac(gt97xx, val);
+		if (ret) {
+			dev_err(&client->dev, "I2C failure: %d", ret);
+			return ret;
+		}
+		usleep_range(gt97xx->move_delay_us,
+			     gt97xx->move_delay_us + 1000);
+	}
+
+	return 0;
+}
+
+static int gt97xx_chip_regs_mapping(struct gt97xx *gt97xx)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&gt97xx->sd);
+	struct vcm_giantec_of_data *mod_chip_data;
+	int i = 0;
+
+//	dev_info(&client->dev, "--- gt97xx:chip_id=0x%x", gt97xx->chip->id);
+	mod_chip_data = kmemdup(gt97xx->chip, sizeof(gt97xx->chip), GFP_KERNEL);
+	if (!mod_chip_data) {
+		dev_err(&client->dev, "--- %s: kmemdup fail!", __func__);
+        return -1;
+	}
+
+	for (i = GT_IC_COM_REGS_START; i <= GT_IC_COM_REGS_END; i++) {
+		mod_chip_data->regs[i] = gt97xx_com_regs.regs[i];
+	}
+
+	gt97xx->chip = mod_chip_data;
+
+	return 0;
+}
+
+static int __maybe_unused gt97xx_release(struct gt97xx *gt97xx)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&gt97xx->sd);
+	int ret, val;
+
+	val = round_down(gt97xx->focus->val, GT97XX_MOVE_STEPS);
+	for ( ; val >= 0; val -= GT97XX_MOVE_STEPS) {
+		ret = gt97xx_set_dac(gt97xx, val);
+		if (ret) {
+			dev_err(&client->dev, "I2C write fail: %d", ret);
+			return ret;
+		}
+		usleep_range(gt97xx->move_delay_us,
+			     gt97xx->move_delay_us + 1000);
+	}
+
+	return 0;
+}
+
+static int gt97xx_power_on(struct device *dev)
+{
+	struct v4l2_subdev *sd = dev_get_drvdata(dev);
+	struct gt97xx *gt97xx = sd_to_gt97xx(sd);
+	int ret = 0;
+
+	dev_info(dev, "--- %s +", __func__);
+
+	ret = regulator_bulk_enable(ARRAY_SIZE(gt97xx_supply_names),
+				    gt97xx->supplies);
+	if (ret < 0) {
+		dev_err(dev, "failed to enable regulators\n");
+		return ret;
+	}
+
+	dev_info(dev, "--- %s -", __func__);
+	return ret;
+}
+
+static int gt97xx_power_off(struct device *dev)
+{
+	struct v4l2_subdev *sd = dev_get_drvdata(dev);
+	struct gt97xx *gt97xx = sd_to_gt97xx(sd);
+	int ret = 0;
+
+	dev_info(dev, "--- %s +", __func__);
+
+	regulator_bulk_disable(ARRAY_SIZE(gt97xx_supply_names),
+			       gt97xx->supplies);
+
+	dev_info(dev, "--- %s -", __func__);
+	return ret;
+}
+
+static int gt97xx_runtime_suspend(struct device *dev)
+{
+	struct v4l2_subdev *sd = dev_get_drvdata(dev);
+	struct gt97xx *gt97xx = sd_to_gt97xx(sd);
+
+	dev_info(dev, "--- %s +", __func__);
+
+	gt97xx_release(gt97xx);
+    gt97xx_power_off(dev);
+
+	dev_info(dev, "--- %s -", __func__);
+
+	return 0;
+}
+
+static int gt97xx_runtime_resume(struct device *dev)
+{
+	struct v4l2_subdev *sd = dev_get_drvdata(dev);
+	struct gt97xx *gt97xx = sd_to_gt97xx(sd);
+	int ret;
+
+	dev_info(dev, "--- %s +", __func__);
+
+    ret = gt97xx_power_on(dev);
+	if (ret < 0) {
+		dev_err(dev, "failed to power_on\n");
+		return ret;
+	}
+
+	/*
+	 * The datasheet refers to t_OPR that needs to be waited before sending
+	 * I2C commands after power-up.
+	 */
+	usleep_range(GT97XX_T_OPR_US, GT97XX_T_OPR_US + 100);
+
+	ret = gt97xx_init(gt97xx);
+	if (ret < 0)
+		goto disable_power;
+
+	dev_info(dev, "--- %s -", __func__);
+
+	return 0;
+
+disable_power:
+    gt97xx_power_off(dev);
+
+	return ret;
+}
+
+static int gt97xx_set_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct gt97xx *gt97xx = container_of(ctrl->handler,
+					     struct gt97xx, ctrls);
+//	struct i2c_client *client = v4l2_get_subdevdata(&gt97xx->sd);
+
+	if (ctrl->id == V4L2_CID_FOCUS_ABSOLUTE) {
+//		dev_info(&client->dev, "V4L2_CID_FOCUS_ABSOLUTE:%d\n", ctrl->val);
+		return gt97xx_set_dac(gt97xx, ctrl->val);
+	}
+	return 0;
+}
+
+static const struct v4l2_ctrl_ops gt97xx_ctrl_ops = {
+	.s_ctrl = gt97xx_set_ctrl,
+};
+
+static int gt97xx_open(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)
+{
+	return pm_runtime_resume_and_get(sd->dev);
+}
+
+static int gt97xx_close(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)
+{
+	pm_runtime_put(sd->dev);
+
+	return 0;
+}
+
+static const struct v4l2_subdev_internal_ops gt97xx_int_ops = {
+	.open = gt97xx_open,
+	.close = gt97xx_close,
+};
+
+static const struct v4l2_subdev_ops gt97xx_ops = { };
+
+static int gt97xx_init_controls(struct gt97xx *gt97xx)
+{
+	struct v4l2_ctrl_handler *hdl = &gt97xx->ctrls;
+	const struct v4l2_ctrl_ops *ops = &gt97xx_ctrl_ops;
+
+	v4l2_ctrl_handler_init(hdl, 1);
+
+	gt97xx->focus = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_FOCUS_ABSOLUTE, 0,
+					  GT97XX_MAX_FOCUS_POS,
+					  GT97XX_FOCUS_STEPS, 0);
+
+	if (hdl->error)
+		return hdl->error;
+
+	gt97xx->sd.ctrl_handler = hdl;
+
+	return 0;
+}
+
+static int gt97xx_probe(struct i2c_client *client)
+{
+	struct device *dev = &client->dev;
+	struct gt97xx *gt97xx;
+	unsigned int i;
+	int ret;
+
+	dev_info(dev, "--- %s +", __func__);
+
+	gt97xx = devm_kzalloc(dev, sizeof(*gt97xx), GFP_KERNEL);
+	if (!gt97xx)
+		return -ENOMEM;
+
+	/* Initialize subdev */
+	v4l2_i2c_subdev_init(&gt97xx->sd, client, &gt97xx_ops);
+
+    //=================================================
+    gt97xx->chip = of_device_get_match_data(dev);
+    ret = gt97xx_chip_regs_mapping(gt97xx);
+    if (ret < 0) {
+		dev_err(dev, "failed to map regs\n");
+		return ret;
+    }
+    //=================================================
+
+    //=================================================
+	gt97xx->aac_mode = GT97XX_AAC_MODE_DEFAULT;
+	gt97xx->aac_timing = GT97XX_AAC_TIME_DEFAULT;
+	gt97xx->clock_presc = GT97XX_CLOCK_PRE_SCALE_DEFAULT;
+
+	/* Optional indication of AAC mode select */
+	fwnode_property_read_u32(dev_fwnode(dev), "giantec,aac-mode",
+				 &gt97xx->aac_mode);
+
+	/* Optional indication of clock pre-scale select */
+	fwnode_property_read_u32(dev_fwnode(dev), "giantec,clock-presc",
+				 &gt97xx->clock_presc);
+
+	/* Optional indication of AAC Timing */
+	fwnode_property_read_u32(dev_fwnode(dev), "giantec,aac-timing",
+				 &gt97xx->aac_timing);
+
+	gt97xx->move_delay_us = gt97xx_cal_move_delay(gt97xx->aac_mode,
+						      gt97xx->clock_presc,
+						      gt97xx->aac_timing);
+
+    //=================================================
+	for (i = 0; i < ARRAY_SIZE(gt97xx_supply_names); i++)
+		gt97xx->supplies[i].supply = gt97xx_supply_names[i];
+
+	ret = devm_regulator_bulk_get(dev, ARRAY_SIZE(gt97xx_supply_names),
+				      gt97xx->supplies);
+	if (ret) {
+		dev_err(dev, "failed to get regulators\n");
+		return ret;
+	}
+    //=================================================
+
+	/* Initialize controls */
+	ret = gt97xx_init_controls(gt97xx);
+	if (ret)
+		goto err_free_handler;
+    //=================================================
+
+	/* Initialize subdev */
+	gt97xx->sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+	gt97xx->sd.internal_ops = &gt97xx_int_ops;
+	gt97xx->sd.entity.function = MEDIA_ENT_F_LENS;
+
+	dev_dbg(&client->dev, "gt97xx->sd.name: %s, dev->of_node->name: %s\n",
+	        gt97xx->sd.name, dev->of_node->name);
+	if (V4L2_SUBDEV_NAME_SIZE - strlen(gt97xx->sd.name) - 2
+	    < strlen(dev->of_node->name)) {
+		dev_err(&client->dev,
+		        "the string length of (sd.name + of_node->name) is too long.\n");
+		return -EINVAL;
+	}
+	strncat(gt97xx->sd.name, " ", 1);
+	strncat(gt97xx->sd.name, dev->of_node->name,
+	        V4L2_SUBDEV_NAME_SIZE - strlen(gt97xx->sd.name) - 2);
+	dev_dbg(&client->dev, "after: gt97xx->sd.name: %s\n", gt97xx->sd.name);
+
+	ret = media_entity_pads_init(&gt97xx->sd.entity, 0, NULL);
+	if (ret < 0)
+		goto err_free_handler;
+
+    //=================================================
+    /*power on and Initialize hw*/
+    ret = gt97xx_runtime_resume(dev);
+    if (ret < 0) {
+        dev_err(dev, "failed to power on: %d\n", ret);
+        goto err_clean_entity;
+    }
+    //=================================================
+
+    pm_runtime_enable(dev);
+
+	ret = v4l2_async_register_subdev(&gt97xx->sd);
+	if (ret < 0) {
+		dev_err(dev, "failed to register V4L2 subdev: %d", ret);
+		goto err_power_off;
+	}
+
+	dev_info(dev, "--- %s -", __func__);
+
+	return 0;
+
+err_power_off:
+	if (pm_runtime_enabled(dev))
+		pm_runtime_disable(dev);
+	else
+        gt97xx_power_off(dev);
+err_clean_entity:
+	media_entity_cleanup(&gt97xx->sd.entity);
+err_free_handler:
+	v4l2_ctrl_handler_free(&gt97xx->ctrls);
+
+	return ret;
+}
+
+static void gt97xx_remove(struct i2c_client *client)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct gt97xx *gt97xx = sd_to_gt97xx(sd);
+
+	v4l2_async_unregister_subdev(&gt97xx->sd);
+	v4l2_ctrl_handler_free(&gt97xx->ctrls);
+	media_entity_cleanup(&gt97xx->sd.entity);
+	pm_runtime_disable(&client->dev);
+	if (!pm_runtime_status_suspended(&client->dev))
+		gt97xx_runtime_suspend(&client->dev);
+	pm_runtime_set_suspended(&client->dev);
+
+	return;
+}
+
+static const struct dev_pm_ops gt97xx_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend,
+				pm_runtime_force_resume)
+	SET_RUNTIME_PM_OPS(gt97xx_runtime_suspend, gt97xx_runtime_resume, NULL)
+};
+
+
+//========================================================
+static const struct vcm_giantec_of_data gt9768_data = {
+	.id = GT9768_ID,
+};
+
+static const struct vcm_giantec_of_data gt9769_data = {
+	.id = GT9769_ID,
+};
+
+static const struct of_device_id gt97xx_of_table[] = {
+    { .compatible = "giantec,gt9768", .data = &gt9768_data},
+    { .compatible = "giantec,gt9769", .data = &gt9769_data},
+	{}
+};
+MODULE_DEVICE_TABLE(of, gt97xx_of_table);
+//========================================================
+
+static struct i2c_driver gt97xx_i2c_driver = {
+	.driver = {
+		.name = GT97XX_NAME,
+		.pm = &gt97xx_pm_ops,
+		.of_match_table = gt97xx_of_table,
+	},
+	.probe_new  = gt97xx_probe,
+	.remove = gt97xx_remove,
+};
+module_i2c_driver(gt97xx_i2c_driver);
+
+MODULE_AUTHOR("Zhi Mao <zhi.mao@mediatek.com>");
+MODULE_DESCRIPTION("GT97xx VCM driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/media/i2c/hi1339.c b/drivers/media/i2c/hi1339.c
new file mode 100755
index 0000000000000000000000000000000000000000..6b28006e19c70eb78f5f7e80898a4e3a8d8fcf10
--- /dev/null
+++ b/drivers/media/i2c/hi1339.c
@@ -0,0 +1,5696 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * hi1339.c - hi1339 sensor driver
+ *
+ * Copyright 2023 Mediatek
+ *
+ * Zhi Mao <zhi.mao@mediatek.com>
+ */
+
+#include <asm/unaligned.h>
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/gpio/consumer.h>
+#include <linux/i2c.h>
+#include <linux/module.h>
+#include <linux/pm_runtime.h>
+#include <linux/regmap.h>
+#include <linux/regulator/consumer.h>
+#include <media/media-entity.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-fwnode.h>
+#include <media/v4l2-subdev.h>
+
+
+
+//=========================================
+#define HI1339_REG_VALUE_08BIT		1
+#define HI1339_REG_VALUE_16BIT		2
+#define HI1339_REG_VALUE_24BIT		3
+
+#define HI1339_FPS					30
+#define HI1339_MBUS_CODE			MEDIA_BUS_FMT_SGBRG10_1X10
+#define HI1339_DATA_LANES			4
+
+#define HI1339_DEFAULT_CLK_FREQ		24000000
+#define HI1339_LINK_FREQ_1440MHZ	1440000000ULL
+#define HI1339_SCLK					72000000LL
+
+#define HI1339_LINK_FREQ_624MHZ 	624000000ULL
+
+#define HI1339_RGB_DEPTH			10
+
+#define HI1339_REG_CHIP_ID			0x0716 //0x20@7bit, 0x40@8bit
+#define HI1339_CHIP_ID				0x1339
+
+/* horizontal-timings from sensor */
+#define HI1339_REG_LLP				0x0206
+#define HI1339_HTS_30FPS			720
+#define HI1339_HTS_60FPS			720
+
+/* vertical-timings from sensor */
+#define HI1339_REG_FLL				0x020E
+#define HI1339_FLL_30FPS			3332
+#define HI1339_FLL_30FPS_MIN		3332
+#define HI1339_FLL_60FPS			1666
+#define HI1339_FLL_60FPS_MIN		1666
+#define HI1339_FLL_MAX				0x7fff
+
+/* streaming controls from sensor */
+#define HI1339_STRAEMING_REG		0x0B00 //[8] 1: streaming, 0:standby
+#define HI1339_MODE_STANDBY			0x0000
+#define HI1339_MODE_STREAMING		0x0100
+
+/* Exposure controls from sensor */
+#define HI1339_REG_EXPOSURE			0x020A
+#define HI1339_EXPOSURE_MIN			4
+#define HI1339_EXPOSURE_MAX_MARGIN	4
+#define HI1339_EXPOSURE_STEP		1
+
+/* Analog gain controls from sensor */
+#define HI1339_REG_ANALOG_GAIN		0x0212
+#define HI1339_AGAIN_MIN			0
+#define HI1339_AGAIN_MAX			240
+#define HI1339_AGAIN_STEP			1
+
+/* Digital gain controls from sensor */
+#define HI1339_REG_MWB_GR_GAIN		0x0214
+#define HI1339_REG_MWB_GB_GAIN		0x0216
+#define HI1339_REG_MWB_R_GAIN		0x0218
+#define HI1339_REG_MWB_B_GAIN		0x021A
+#define HI1339_DGAIN_MIN			1
+#define HI1339_DGAIN_MAX			8191
+#define HI1339_DGAIN_STEP			1
+#define HI1339_DGAIN_DEFAULT		512
+
+/* Test Pattern Control */
+#define HI1339_REG_ISP				0x0B04
+#define HI1339_REG_ISP_TPG_EN		0x0001
+#define HI1339_REG_TEST_PATTERN		0x0C0A
+
+/* Flip Mirror Controls from sensor */
+#define HI1339_REG_MIRROR_FLIP		0x0C34
+
+#define HI1339_REG_FORMAT_X			0x0F04
+#define HI1339_REG_FORMAT_Y			0x0F06
+//=========================================
+
+static const char *const hi1339_test_pattern_menu[] = {
+	"No Pattern",
+	"Solid Colour",
+	"100% Colour Bars",
+	"Fade To Grey Colour Bars",
+	"PN9",
+	"Horizontal Gradient Pattern",
+	"Vertical Gradient Pattern",
+	"Check Board",
+	"Slant Pattern",
+};
+
+static const s64 link_freq_menu_items[] = {
+	HI1339_LINK_FREQ_1440MHZ,
+	HI1339_LINK_FREQ_624MHZ,
+};
+
+static const char *const hi1339_supply_name[] = {
+	"avdd",
+	"dvdd",
+	"dovdd",
+};
+
+#define HI1339_NUM_SUPPLIES ARRAY_SIZE(hi1339_supply_name)
+
+struct hi1339 {
+	struct device *dev;
+	struct i2c_client *client;
+	struct v4l2_subdev sd;
+	struct media_pad pad;
+	struct v4l2_mbus_framefmt fmt;
+	struct v4l2_rect crop;
+
+	struct regulator_bulk_data	supplies[HI1339_NUM_SUPPLIES];
+	struct gpio_desc *enable_gpio;
+	struct clk *xclk;
+	struct regmap *regmap;
+
+	struct v4l2_ctrl_handler ctrl_handler;
+	struct v4l2_ctrl *pixel_rate;
+	struct v4l2_ctrl *link_freq;
+	struct v4l2_ctrl *exposure;
+	struct v4l2_ctrl *vflip;
+	struct v4l2_ctrl *hflip;
+	struct v4l2_ctrl *vblank;
+	struct v4l2_ctrl *hblank;
+
+
+	/*
+	 * Serialize control access, get/set format, get selection
+	 * and start streaming.
+	 */
+	struct mutex mutex;
+
+	bool streaming;
+
+	/* Current mode */
+	const struct hi1339_mode *cur_mode;
+};
+
+enum {
+	HI1339_LINK_FREQ_1440MBPS,
+	HI1339_LINK_FREQ_624MBPS,
+};
+
+struct hi1339_reg {
+	u16 address;
+	u16 val;
+};
+
+struct hi1339_reg_list {
+	u32 num_of_regs;
+	const struct hi1339_reg *regs;
+};
+
+struct hi1339_link_freq_config {
+	const struct hi1339_reg_list reg_list;
+};
+
+enum {
+	HI1339_TABLE_WAIT_MS = 0,
+	HI1339_TABLE_END,
+};
+
+/*From hi1339_mode_tbls.h*/
+static const struct hi1339_reg mode_4208x3120[] = {
+
+	{HI1339_STRAEMING_REG, 0x0000},
+	{0x2E38, 0x0040},
+	{0x2E3A, 0x003E},
+	{0x2E3C, 0x0042},
+	{0x2E3E, 0x0046},
+	{0x2E40, 0x0046},
+	{0x2E42, 0x004A},
+	{0x2E44, 0x0054},
+	{0x2E46, 0x0054},
+	{0x2E48, 0x005C},
+	{0x2E4A, 0x0064},
+	{0x2E4C, 0x0065},
+	{0x2E4E, 0x0070},
+	{0x2E50, 0x0079},
+	{0x2E52, 0x007B},
+	{0x2E54, 0x007F},
+	{0x2E56, 0x0085},
+	{0x2E58, 0x0086},
+	{0x2E5A, 0x0091},
+	{0x2E5C, 0x0096},
+	{0x2E5E, 0x0097},
+	{0x2E60, 0x00A4},
+	{0x2E62, 0x00AD},
+	{0x2E64, 0x00AF},
+	{0x2E66, 0x00C1},
+	{0x2E68, 0x00BD},
+	{0x2E6A, 0x00C0},
+	{0x2E6C, 0x00C5},
+	{0x2E6E, 0x00C6},
+	{0x2E70, 0x00BD},
+	{0x2E72, 0x00D1},
+	{0x2E74, 0x00D5},
+	{0x0204, 0x00C0},
+	{0x0206, 0x02D0},
+	{0x020A, 0x0D00},
+	{0x020E, 0x0D04},
+	{0x0224, 0x002E},
+	{0x022A, 0x0017},
+	{0x022C, 0x0E1F},
+	{0x022E, 0x0C61},
+	{0x0234, 0x1111},
+	{0x0236, 0x1111},
+	{0x0238, 0x1111},
+	{0x023A, 0x1111},
+	{0x0248, 0x0100},
+	{0x0250, 0x0000},
+	{0x0252, 0x0006},
+	{0x0254, 0x0000},
+	{0x0256, 0x0000},
+	{0x0258, 0x0000},
+	{0x025A, 0x0000},
+	{0x025C, 0x0000},
+	{0x025E, 0x0202},
+	{0x0380, 0x00D2},
+	{0x0662, 0x1010},
+	{0x0664, 0x0E0E},
+	{0x06BC, 0x85F0},
+	{0x06BE, 0x8600},
+	{0x06C0, 0x8380},
+	{0x06C2, 0x8380},
+	{0x0F00, 0x0000},
+	{0x0F04, 0x0008},
+	{0x0B02, 0x0100},
+	{0x0B04, 0x00DC},
+	{0x0B12, 0x1070},
+	{0x0B14, 0x0C30},
+	{0x0A10, 0x9C60},
+	{0x0C14, 0x0008},
+	{0x0C18, 0x1070},
+	{0x0C1A, 0x0C30},
+	{0x0730, 0x0101},
+	{0x0732, 0x0300},
+	{0x0734, 0x0300},
+	{0x0736, 0x0048},
+	{0x0738, 0x0002},
+	{0x073C, 0x0301},
+	{0x0740, 0x0100},
+	{0x0742, 0x0300},
+	{0x0744, 0x0300},
+	{0x0746, 0x00B4},
+	{0x0748, 0x0002},
+	{0x074A, 0x0700},
+	{0x074C, 0x8000},
+	{0x074E, 0x0000},
+	{0x0750, 0x0000},
+	{0x1200, 0xF9FD},
+	{0x1000, 0x0300},
+	{0x1002, 0xC311},
+	{0x1004, 0x2BAB},
+	{0x1010, 0x0400},
+	{0x1012, 0x0189},
+	{0x1014, 0x0056},
+	{0x1016, 0x0056},
+	{0x1018, 0x0080},
+	{0x101A, 0x0056},
+	{0x1020, 0xC10C},
+	{0x1022, 0x0B36},
+	{0x1024, 0x050D},
+	{0x1026, 0x1311},
+	{0x1028, 0x1B0E},
+	{0x102A, 0x140A},
+	{0x102C, 0x2100},
+	{0x1038, 0x1100},
+	{0x103E, 0x0001},
+	{0x1042, 0x0108},
+	{0x1044, 0x0100},
+	{0x1046, 0x0004},
+	{0x1048, 0x0100},
+	{0x1066, 0x0D7F},
+	{0x1600, 0xE000},
+	{0x1608, 0x0040},
+	{0x160A, 0x1000},
+	{0x160E, 0x0C00},
+	{0x1A00, 0x0140},
+
+	{HI1339_TABLE_END, 0x0000}
+};
+
+static const struct hi1339_reg mode_1920x1080[] = {
+	{HI1339_STRAEMING_REG, 0x0000},
+
+	{0x2E38, 0x0040},
+	{0x2E3A, 0x003E},
+	{0x2E3C, 0x0042},
+	{0x2E3E, 0x0046},
+	{0x2E40, 0x0046},
+	{0x2E42, 0x004A},
+	{0x2E44, 0x0054},
+	{0x2E46, 0x0054},
+	{0x2E48, 0x005C},
+	{0x2E4A, 0x0064},
+	{0x2E4C, 0x0065},
+	{0x2E4E, 0x0070},
+	{0x2E50, 0x0079},
+	{0x2E52, 0x007B},
+	{0x2E54, 0x007F},
+	{0x2E56, 0x0085},
+	{0x2E58, 0x0086},
+	{0x2E5A, 0x0091},
+	{0x2E5C, 0x0096},
+	{0x2E5E, 0x0097},
+	{0x2E60, 0x00A4},
+	{0x2E62, 0x00AD},
+	{0x2E64, 0x00AF},
+	{0x2E66, 0x00C1},
+	{0x2E68, 0x00BD},
+	{0x2E6A, 0x00C0},
+	{0x2E6C, 0x00C5},
+	{0x2E6E, 0x00C6},
+	{0x2E70, 0x00BD},
+	{0x2E72, 0x00D1},
+	{0x2E74, 0x00D5},
+	{0x0204, 0x00C0},
+	{0x0206, 0x02D0},
+	{0x020A, 0x067E},
+	{0x020E, 0x0682},
+	{0x0224, 0x020C},
+	{0x022A, 0x0017},
+	{0x022C, 0x0E2D},
+	{0x022E, 0x0A81},
+	{0x0234, 0x1111},
+	{0x0236, 0x3311},
+	{0x0238, 0x3311},
+	{0x023A, 0x1122},
+	{0x0248, 0x0100},
+	{0x0250, 0x0000},
+	{0x0252, 0x0006},
+	{0x0254, 0x0000},
+	{0x0256, 0x0000},
+	{0x0258, 0x0000},
+	{0x025A, 0x0000},
+	{0x025C, 0x0000},
+	{0x025E, 0x0202},
+	{0x0380, 0x00D2},
+	{0x0662, 0x1010},
+	{0x0664, 0x0E0E},
+	{0x06BC, 0x8180},
+	{0x06BE, 0x8800},
+	{0x06C0, 0x8600},
+	{0x06C2, 0x8600},
+	{0x0F00, 0x0400},
+	{0x0F04, 0x0060},
+	{0x0B02, 0x0100},
+	{0x0B04, 0x00FC},
+	{0x0B12, 0x0780},
+	{0x0B14, 0x0438},
+	{0x0A10, 0x9C60},
+	{0x0C14, 0x00C0},
+	{0x0C18, 0x0F00},
+	{0x0C1A, 0x0438},
+	{0x0730, 0x0101},
+	{0x0732, 0x0300},
+	{0x0734, 0x0300},
+	{0x0736, 0x0048},
+	{0x0738, 0x0002},
+	{0x073C, 0x0301},
+	{0x0740, 0x0100},
+	{0x0742, 0x0300},
+	{0x0744, 0x0300},
+	{0x0746, 0x009C},
+	{0x0748, 0x0002},
+	{0x074A, 0x0700},
+	{0x074C, 0x8100},
+	{0x074E, 0x0000},
+	{0x0750, 0x0000},
+	{0x1200, 0x79C5},
+	{0x1000, 0x0300},
+	{0x1002, 0xC311},
+	{0x1004, 0x2BB0},
+	{0x1010, 0x05AB},
+	{0x1012, 0x007F},
+	{0x1020, 0xC105},
+	{0x1022, 0x0517},
+	{0x1024, 0x0406},
+	{0x1026, 0x080A},
+	{0x1028, 0x1307},
+	{0x102A, 0x090A},
+	{0x102C, 0x0F00},
+	{0x103E, 0x0101},
+	{0x1066, 0x05C4},
+	{0x1600, 0x0400},
+	{0x1A00, 0x0240},
+	{0x1A02, 0x2244},
+	{0x1A04, 0x2204},
+
+	{HI1339_TABLE_END, 0x0000}
+};
+
+static const struct hi1339_reg mipi_data_rate_624mbps[] = {
+	{HI1339_STRAEMING_REG, 0x0000},
+	{0x0790, 0x0100},
+	{0x2000, 0x0000},
+	{0x2002, 0x0058},
+	{0x2006, 0x40B2},
+	{0x2008, 0xB074},
+	{0x200A, 0x84BC},
+	{0x200C, 0x40B2},
+	{0x200E, 0xB0AE},
+	{0x2010, 0x84BA},
+	{0x2012, 0x40B2},
+	{0x2014, 0xB0FE},
+	{0x2016, 0x84CA},
+	{0x2018, 0x40B2},
+	{0x201A, 0xB108},
+	{0x201C, 0x8476},
+	{0x201E, 0x40B2},
+	{0x2020, 0xB126},
+	{0x2022, 0x843A},
+	{0x2024, 0x40B2},
+	{0x2026, 0xB12C},
+	{0x2028, 0x8450},
+	{0x202A, 0x40B2},
+	{0x202C, 0xB166},
+	{0x202E, 0x848C},
+	{0x2030, 0x40B2},
+	{0x2032, 0xB1D6},
+	{0x2034, 0x8464},
+	{0x2036, 0x40B2},
+	{0x2038, 0xB1E0},
+	{0x203A, 0x847C},
+	{0x203C, 0x40B2},
+	{0x203E, 0xB37A},
+	{0x2040, 0x8490},
+	{0x2042, 0x40B2},
+	{0x2044, 0xB7E8},
+	{0x2046, 0x8488},
+	{0x2048, 0x40B2},
+	{0x204A, 0xB8B8},
+	{0x204C, 0x8478},
+	{0x204E, 0x40B2},
+	{0x2050, 0xB97E},
+	{0x2052, 0x8460},
+	{0x2054, 0x40B2},
+	{0x2056, 0xB9CA},
+	{0x2058, 0x8446},
+	{0x205A, 0x40B2},
+	{0x205C, 0xBA1E},
+	{0x205E, 0x8452},
+	{0x2060, 0x40B2},
+	{0x2062, 0xBA28},
+	{0x2064, 0x848A},
+	{0x2066, 0x40B2},
+	{0x2068, 0xBA56},
+	{0x206A, 0x8486},
+	{0x206C, 0x40B2},
+	{0x206E, 0xBB3A},
+	{0x2070, 0x8436},
+	{0x2072, 0x4130},
+	{0x2074, 0x120B},
+	{0x2076, 0x120A},
+	{0x2078, 0x1209},
+	{0x207A, 0x40B2},
+	{0x207C, 0x0700},
+	{0x207E, 0x8636},
+	{0x2080, 0x4309},
+	{0x2082, 0x403B},
+	{0x2084, 0x84C2},
+	{0x2086, 0x12AB},
+	{0x2088, 0x4F4A},
+	{0x208A, 0x12AB},
+	{0x208C, 0x4F4E},
+	{0x208E, 0x108E},
+	{0x2090, 0xDA0E},
+	{0x2092, 0x930E},
+	{0x2094, 0x2404},
+	{0x2096, 0x490F},
+	{0x2098, 0x5F0F},
+	{0x209A, 0x4E8F},
+	{0x209C, 0x0940},
+	{0x209E, 0x5319},
+	{0x20A0, 0x9039},
+	{0x20A2, 0x001C},
+	{0x20A4, 0x2BEE},
+	{0x20A6, 0x4139},
+	{0x20A8, 0x413A},
+	{0x20AA, 0x413B},
+	{0x20AC, 0x4130},
+	{0x20AE, 0x120B},
+	{0x20B0, 0x120A},
+	{0x20B2, 0x1209},
+	{0x20B4, 0xB3D2},
+	{0x20B6, 0x0363},
+	{0x20B8, 0x241E},
+	{0x20BA, 0x0905},
+	{0x20BC, 0x0851},
+	{0x20BE, 0x40B2},
+	{0x20C0, 0x0700},
+	{0x20C2, 0x8636},
+	{0x20C4, 0x4309},
+	{0x20C6, 0x490F},
+	{0x20C8, 0x5F0F},
+	{0x20CA, 0x4F1F},
+	{0x20CC, 0x0940},
+	{0x20CE, 0x4F0E},
+	{0x20D0, 0xF37E},
+	{0x20D2, 0xF03F},
+	{0x20D4, 0xFF00},
+	{0x20D6, 0x108F},
+	{0x20D8, 0x4F4A},
+	{0x20DA, 0x934A},
+	{0x20DC, 0x3402},
+	{0x20DE, 0x430E},
+	{0x20E0, 0x430A},
+	{0x20E2, 0x403B},
+	{0x20E4, 0x84C6},
+	{0x20E6, 0x4E4F},
+	{0x20E8, 0x12AB},
+	{0x20EA, 0x4A4F},
+	{0x20EC, 0x12AB},
+	{0x20EE, 0x5319},
+	{0x20F0, 0x9039},
+	{0x20F2, 0x001C},
+	{0x20F4, 0x2BE8},
+	{0x20F6, 0x4139},
+	{0x20F8, 0x413A},
+	{0x20FA, 0x413B},
+	{0x20FC, 0x4130},
+	{0x20FE, 0x12B0},
+	{0x2100, 0xB0AE},
+	{0x2102, 0x1292},
+	{0x2104, 0xD09A},
+	{0x2106, 0x4130},
+	{0x2108, 0x120B},
+	{0x210A, 0x421B},
+	{0x210C, 0x0384},
+	{0x210E, 0x1292},
+	{0x2110, 0xD046},
+	{0x2112, 0x8B82},
+	{0x2114, 0x7A04},
+	{0x2116, 0x8B82},
+	{0x2118, 0x7A06},
+	{0x211A, 0x8B82},
+	{0x211C, 0x7A08},
+	{0x211E, 0x8B82},
+	{0x2120, 0x7A0A},
+	{0x2122, 0x413B},
+	{0x2124, 0x4130},
+	{0x2126, 0x1292},
+	{0x2128, 0xD00A},
+	{0x212A, 0x4130},
+	{0x212C, 0x120B},
+	{0x212E, 0x120A},
+	{0x2130, 0x430A},
+	{0x2132, 0x403B},
+	{0x2134, 0x8230},
+	{0x2136, 0xB3D2},
+	{0x2138, 0x0267},
+	{0x213A, 0x2401},
+	{0x213C, 0x431A},
+	{0x213E, 0x1292},
+	{0x2140, 0xD020},
+	{0x2142, 0x931A},
+	{0x2144, 0x2403},
+	{0x2146, 0xB2F2},
+	{0x2148, 0x0381},
+	{0x214A, 0x240A},
+	{0x214C, 0x430F},
+	{0x214E, 0xE39B},
+	{0x2150, 0x0000},
+	{0x2152, 0x532B},
+	{0x2154, 0x531F},
+	{0x2156, 0x903F},
+	{0x2158, 0x0100},
+	{0x215A, 0x2BF9},
+	{0x215C, 0xC2F2},
+	{0x215E, 0x0381},
+	{0x2160, 0x413A},
+	{0x2162, 0x413B},
+	{0x2164, 0x4130},
+	{0x2166, 0x120B},
+	{0x2168, 0x120A},
+	{0x216A, 0x1209},
+	{0x216C, 0x403B},
+	{0x216E, 0x84D0},
+	{0x2170, 0x4219},
+	{0x2172, 0x0A00},
+	{0x2174, 0xB2F2},
+	{0x2176, 0x0361},
+	{0x2178, 0x241A},
+	{0x217A, 0x430A},
+	{0x217C, 0x4A0F},
+	{0x217E, 0x5F0F},
+	{0x2180, 0x4F1E},
+	{0x2182, 0x06BC},
+	{0x2184, 0x930E},
+	{0x2186, 0x3410},
+	{0x2188, 0xF03E},
+	{0x218A, 0x7FFF},
+	{0x218C, 0xE33E},
+	{0x218E, 0x531E},
+	{0x2190, 0x490F},
+	{0x2192, 0x1292},
+	{0x2194, 0x8480},
+	{0x2196, 0x4E8B},
+	{0x2198, 0x0004},
+	{0x219A, 0x4F8B},
+	{0x219C, 0x0006},
+	{0x219E, 0x523B},
+	{0x21A0, 0x531A},
+	{0x21A2, 0x922A},
+	{0x21A4, 0x2BEB},
+	{0x21A6, 0x3C13},
+	{0x21A8, 0xF03E},
+	{0x21AA, 0x7FFF},
+	{0x21AC, 0x3FF1},
+	{0x21AE, 0x438B},
+	{0x21B0, 0x0004},
+	{0x21B2, 0x438B},
+	{0x21B4, 0x0006},
+	{0x21B6, 0x438B},
+	{0x21B8, 0x000C},
+	{0x21BA, 0x438B},
+	{0x21BC, 0x000E},
+	{0x21BE, 0x438B},
+	{0x21C0, 0x0014},
+	{0x21C2, 0x438B},
+	{0x21C4, 0x0016},
+	{0x21C6, 0x438B},
+	{0x21C8, 0x001C},
+	{0x21CA, 0x438B},
+	{0x21CC, 0x001E},
+	{0x21CE, 0x4139},
+	{0x21D0, 0x413A},
+	{0x21D2, 0x413B},
+	{0x21D4, 0x4130},
+	{0x21D6, 0x1292},
+	{0x21D8, 0xD034},
+	{0x21DA, 0xD3D2},
+	{0x21DC, 0x7501},
+	{0x21DE, 0x4130},
+	{0x21E0, 0x120B},
+	{0x21E2, 0x120A},
+	{0x21E4, 0x1209},
+	{0x21E6, 0x1208},
+	{0x21E8, 0x1207},
+	{0x21EA, 0x1206},
+	{0x21EC, 0x8231},
+	{0x21EE, 0x93E2},
+	{0x21F0, 0x0241},
+	{0x21F2, 0x24B5},
+	{0x21F4, 0x4036},
+	{0x21F6, 0x0292},
+	{0x21F8, 0x462F},
+	{0x21FA, 0x4FC2},
+	{0x21FC, 0x0A01},
+	{0x21FE, 0xB2E2},
+	{0x2200, 0x0361},
+	{0x2202, 0x2405},
+	{0x2204, 0x462F},
+	{0x2206, 0x1292},
+	{0x2208, 0x8474},
+	{0x220A, 0x4F82},
+	{0x220C, 0x0A1C},
+	{0x220E, 0x4307},
+	{0x2210, 0x470F},
+	{0x2212, 0x5F0F},
+	{0x2214, 0x4F0E},
+	{0x2216, 0x510E},
+	{0x2218, 0x560F},
+	{0x221A, 0x4F9E},
+	{0x221C, 0x0002},
+	{0x221E, 0x0000},
+	{0x2220, 0x5317},
+	{0x2222, 0x9227},
+	{0x2224, 0x2BF5},
+	{0x2226, 0x93C2},
+	{0x2228, 0x0360},
+	{0x222A, 0x3430},
+	{0x222C, 0x4628},
+	{0x222E, 0xC312},
+	{0x2230, 0x1008},
+	{0x2232, 0x1108},
+	{0x2234, 0x1108},
+	{0x2236, 0x9038},
+	{0x2238, 0x0020},
+	{0x223A, 0x2802},
+	{0x223C, 0x4038},
+	{0x223E, 0x001F},
+	{0x2240, 0x4307},
+	{0x2242, 0x470E},
+	{0x2244, 0x5E0E},
+	{0x2246, 0x4E09},
+	{0x2248, 0x5609},
+	{0x224A, 0x491A},
+	{0x224C, 0x0002},
+	{0x224E, 0x430B},
+	{0x2250, 0x4E0F},
+	{0x2252, 0x5F0F},
+	{0x2254, 0x5F0F},
+	{0x2256, 0x5F0F},
+	{0x2258, 0x5F0F},
+	{0x225A, 0x580F},
+	{0x225C, 0x5F0F},
+	{0x225E, 0x4F1E},
+	{0x2260, 0xBE78},
+	{0x2262, 0x430F},
+	{0x2264, 0x4E0C},
+	{0x2266, 0x4F0D},
+	{0x2268, 0x1202},
+	{0x226A, 0xC232},
+	{0x226C, 0x12B0},
+	{0x226E, 0xFFC0},
+	{0x2270, 0x4132},
+	{0x2272, 0x108E},
+	{0x2274, 0x108F},
+	{0x2276, 0xEF4E},
+	{0x2278, 0xEF0E},
+	{0x227A, 0xF37F},
+	{0x227C, 0xC312},
+	{0x227E, 0x100F},
+	{0x2280, 0x100E},
+	{0x2282, 0x4E89},
+	{0x2284, 0x0002},
+	{0x2286, 0x5317},
+	{0x2288, 0x9227},
+	{0x228A, 0x2BDB},
+	{0x228C, 0x461A},
+	{0x228E, 0x0002},
+	{0x2290, 0x430B},
+	{0x2292, 0x403C},
+	{0x2294, 0x4029},
+	{0x2296, 0x430D},
+	{0x2298, 0x1202},
+	{0x229A, 0xC232},
+	{0x229C, 0x12B0},
+	{0x229E, 0xFFC0},
+	{0x22A0, 0x4132},
+	{0x22A2, 0x108E},
+	{0x22A4, 0x108F},
+	{0x22A6, 0xEF4E},
+	{0x22A8, 0xEF0E},
+	{0x22AA, 0xF37F},
+	{0x22AC, 0xC312},
+	{0x22AE, 0x100F},
+	{0x22B0, 0x100E},
+	{0x22B2, 0x110F},
+	{0x22B4, 0x100E},
+	{0x22B6, 0x110F},
+	{0x22B8, 0x100E},
+	{0x22BA, 0x110F},
+	{0x22BC, 0x100E},
+	{0x22BE, 0x110F},
+	{0x22C0, 0x100E},
+	{0x22C2, 0x110F},
+	{0x22C4, 0x100E},
+	{0x22C6, 0x4E86},
+	{0x22C8, 0x0002},
+	{0x22CA, 0x460F},
+	{0x22CC, 0x532F},
+	{0x22CE, 0x422D},
+	{0x22D0, 0x4F0E},
+	{0x22D2, 0x403F},
+	{0x22D4, 0x0E08},
+	{0x22D6, 0x1292},
+	{0x22D8, 0x843E},
+	{0x22DA, 0x93C2},
+	{0x22DC, 0x0360},
+	{0x22DE, 0x340B},
+	{0x22E0, 0x4307},
+	{0x22E2, 0x470F},
+	{0x22E4, 0x5F0F},
+	{0x22E6, 0x4F0E},
+	{0x22E8, 0x560E},
+	{0x22EA, 0x510F},
+	{0x22EC, 0x4FAE},
+	{0x22EE, 0x0002},
+	{0x22F0, 0x5317},
+	{0x22F2, 0x9227},
+	{0x22F4, 0x2BF6},
+	{0x22F6, 0x403D},
+	{0x22F8, 0x0005},
+	{0x22FA, 0x403E},
+	{0x22FC, 0x0292},
+	{0x22FE, 0x403F},
+	{0x2300, 0x8534},
+	{0x2302, 0x1292},
+	{0x2304, 0x843E},
+	{0x2306, 0x421F},
+	{0x2308, 0x060E},
+	{0x230A, 0x9F82},
+	{0x230C, 0x856E},
+	{0x230E, 0x2824},
+	{0x2310, 0x9382},
+	{0x2312, 0x060E},
+	{0x2314, 0x2421},
+	{0x2316, 0x90B6},
+	{0x2318, 0x0010},
+	{0x231A, 0x0000},
+	{0x231C, 0x2C0B},
+	{0x231E, 0x93C2},
+	{0x2320, 0x853E},
+	{0x2322, 0x2008},
+	{0x2324, 0x403F},
+	{0x2326, 0x0685},
+	{0x2328, 0xD0FF},
+	{0x232A, 0x0007},
+	{0x232C, 0x0000},
+	{0x232E, 0xF0FF},
+	{0x2330, 0xFFF8},
+	{0x2332, 0x0000},
+	{0x2334, 0x4392},
+	{0x2336, 0x856E},
+	{0x2338, 0x403F},
+	{0x233A, 0x0685},
+	{0x233C, 0xD2EF},
+	{0x233E, 0x0000},
+	{0x2340, 0xC2EF},
+	{0x2342, 0x0000},
+	{0x2344, 0xB0F2},
+	{0x2346, 0x0040},
+	{0x2348, 0x0B05},
+	{0x234A, 0x2403},
+	{0x234C, 0xD3D2},
+	{0x234E, 0x0420},
+	{0x2350, 0x3C0C},
+	{0x2352, 0xC3D2},
+	{0x2354, 0x0420},
+	{0x2356, 0x3C09},
+	{0x2358, 0x5392},
+	{0x235A, 0x856E},
+	{0x235C, 0x3FED},
+	{0x235E, 0x93C2},
+	{0x2360, 0x853E},
+	{0x2362, 0x2348},
+	{0x2364, 0x4036},
+	{0x2366, 0x8534},
+	{0x2368, 0x3F47},
+	{0x236A, 0x5231},
+	{0x236C, 0x4136},
+	{0x236E, 0x4137},
+	{0x2370, 0x4138},
+	{0x2372, 0x4139},
+	{0x2374, 0x413A},
+	{0x2376, 0x413B},
+	{0x2378, 0x4130},
+	{0x237A, 0x120B},
+	{0x237C, 0x120A},
+	{0x237E, 0x1209},
+	{0x2380, 0x1208},
+	{0x2382, 0x1207},
+	{0x2384, 0x1206},
+	{0x2386, 0x1205},
+	{0x2388, 0x1204},
+	{0x238A, 0x8031},
+	{0x238C, 0x0036},
+	{0x238E, 0x4381},
+	{0x2390, 0x002C},
+	{0x2392, 0x4381},
+	{0x2394, 0x002E},
+	{0x2396, 0x421F},
+	{0x2398, 0x0386},
+	{0x239A, 0xF03F},
+	{0x239C, 0x07FF},
+	{0x239E, 0x4F81},
+	{0x23A0, 0x0022},
+	{0x23A2, 0x4291},
+	{0x23A4, 0x0388},
+	{0x23A6, 0x0024},
+	{0x23A8, 0x421F},
+	{0x23AA, 0x038A},
+	{0x23AC, 0xF03F},
+	{0x23AE, 0x07FF},
+	{0x23B0, 0x4F81},
+	{0x23B2, 0x0026},
+	{0x23B4, 0x4291},
+	{0x23B6, 0x038C},
+	{0x23B8, 0x0028},
+	{0x23BA, 0x93E2},
+	{0x23BC, 0x0241},
+	{0x23BE, 0x2002},
+	{0x23C0, 0x4030},
+	{0x23C2, 0xB7BE},
+	{0x23C4, 0x40B1},
+	{0x23C6, 0x0292},
+	{0x23C8, 0x002A},
+	{0x23CA, 0x1292},
+	{0x23CC, 0xD060},
+	{0x23CE, 0x421E},
+	{0x23D0, 0x0698},
+	{0x23D2, 0x421F},
+	{0x23D4, 0x069A},
+	{0x23D6, 0x5E0E},
+	{0x23D8, 0x6F0F},
+	{0x23DA, 0x421A},
+	{0x23DC, 0x0694},
+	{0x23DE, 0x421B},
+	{0x23E0, 0x0696},
+	{0x23E2, 0x4E0C},
+	{0x23E4, 0x4F0D},
+	{0x23E6, 0x4A0E},
+	{0x23E8, 0x4B0F},
+	{0x23EA, 0x1292},
+	{0x23EC, 0x8458},
+	{0x23EE, 0x4C82},
+	{0x23F0, 0x8570},
+	{0x23F2, 0x430B},
+	{0x23F4, 0x421F},
+	{0x23F6, 0x038E},
+	{0x23F8, 0x9F0C},
+	{0x23FA, 0x2C01},
+	{0x23FC, 0x431B},
+	{0x23FE, 0x930B},
+	{0x2400, 0x25DB},
+	{0x2402, 0xD3E2},
+	{0x2404, 0x0380},
+	{0x2406, 0x93C2},
+	{0x2408, 0x853E},
+	{0x240A, 0x21E3},
+	{0x240C, 0xB0F2},
+	{0x240E, 0x0010},
+	{0x2410, 0x0381},
+	{0x2412, 0x25DF},
+	{0x2414, 0x4381},
+	{0x2416, 0x0020},
+	{0x2418, 0x4118},
+	{0x241A, 0x0020},
+	{0x241C, 0x5808},
+	{0x241E, 0x480B},
+	{0x2420, 0x510B},
+	{0x2422, 0x411F},
+	{0x2424, 0x002A},
+	{0x2426, 0x580F},
+	{0x2428, 0x4F9B},
+	{0x242A, 0x0002},
+	{0x242C, 0x0018},
+	{0x242E, 0x480A},
+	{0x2430, 0x5A0A},
+	{0x2432, 0x4A1E},
+	{0x2434, 0x0650},
+	{0x2436, 0x4A1F},
+	{0x2438, 0x0652},
+	{0x243A, 0x4E81},
+	{0x243C, 0x002E},
+	{0x243E, 0x4381},
+	{0x2440, 0x002C},
+	{0x2442, 0x4A1E},
+	{0x2444, 0x064E},
+	{0x2446, 0x4A1F},
+	{0x2448, 0x0650},
+	{0x244A, 0xD11E},
+	{0x244C, 0x002C},
+	{0x244E, 0xD11F},
+	{0x2450, 0x002E},
+	{0x2452, 0x4E0C},
+	{0x2454, 0x4F0D},
+	{0x2456, 0x108C},
+	{0x2458, 0x108D},
+	{0x245A, 0xED4C},
+	{0x245C, 0xED0C},
+	{0x245E, 0xF37D},
+	{0x2460, 0xC312},
+	{0x2462, 0x100D},
+	{0x2464, 0x100C},
+	{0x2466, 0x110D},
+	{0x2468, 0x100C},
+	{0x246A, 0x110D},
+	{0x246C, 0x100C},
+	{0x246E, 0x110D},
+	{0x2470, 0x100C},
+	{0x2472, 0x110D},
+	{0x2474, 0x100C},
+	{0x2476, 0x110D},
+	{0x2478, 0x100C},
+	{0x247A, 0x110D},
+	{0x247C, 0x100C},
+	{0x247E, 0x4C8B},
+	{0x2480, 0x0000},
+	{0x2482, 0x4A0B},
+	{0x2484, 0x510B},
+	{0x2486, 0xC312},
+	{0x2488, 0x100F},
+	{0x248A, 0x100E},
+	{0x248C, 0x110F},
+	{0x248E, 0x100E},
+	{0x2490, 0x110F},
+	{0x2492, 0x100E},
+	{0x2494, 0x110F},
+	{0x2496, 0x100E},
+	{0x2498, 0x530E},
+	{0x249A, 0x603F},
+	{0x249C, 0xFFFE},
+	{0x249E, 0x4E8B},
+	{0x24A0, 0x0008},
+	{0x24A2, 0x4F8B},
+	{0x24A4, 0x000A},
+	{0x24A6, 0x4A0E},
+	{0x24A8, 0x5E0E},
+	{0x24AA, 0x5A0E},
+	{0x24AC, 0x4E0F},
+	{0x24AE, 0x503F},
+	{0x24B0, 0xBF78},
+	{0x24B2, 0x9F1C},
+	{0x24B4, 0x000A},
+	{0x24B6, 0x2913},
+	{0x24B8, 0x4304},
+	{0x24BA, 0x4309},
+	{0x24BC, 0x4305},
+	{0x24BE, 0x4E1E},
+	{0x24C0, 0xBFDA},
+	{0x24C2, 0x903E},
+	{0x24C4, 0x8001},
+	{0x24C6, 0x2801},
+	{0x24C8, 0x4315},
+	{0x24CA, 0x4E06},
+	{0x24CC, 0xF036},
+	{0x24CE, 0x7FFF},
+	{0x24D0, 0x490C},
+	{0x24D2, 0x430D},
+	{0x24D4, 0x4807},
+	{0x24D6, 0x5707},
+	{0x24D8, 0x470F},
+	{0x24DA, 0x510F},
+	{0x24DC, 0x4F1E},
+	{0x24DE, 0x0008},
+	{0x24E0, 0x4F1F},
+	{0x24E2, 0x000A},
+	{0x24E4, 0xC312},
+	{0x24E6, 0x100F},
+	{0x24E8, 0x100E},
+	{0x24EA, 0x110F},
+	{0x24EC, 0x100E},
+	{0x24EE, 0x110F},
+	{0x24F0, 0x100E},
+	{0x24F2, 0x110F},
+	{0x24F4, 0x100E},
+	{0x24F6, 0x110F},
+	{0x24F8, 0x100E},
+	{0x24FA, 0x110F},
+	{0x24FC, 0x100E},
+	{0x24FE, 0x4C0A},
+	{0x2500, 0x4D0B},
+	{0x2502, 0x4E0C},
+	{0x2504, 0x4F0D},
+	{0x2506, 0x1202},
+	{0x2508, 0xC232},
+	{0x250A, 0x12B0},
+	{0x250C, 0xFFC0},
+	{0x250E, 0x4132},
+	{0x2510, 0x4E0C},
+	{0x2512, 0x4F0D},
+	{0x2514, 0x930D},
+	{0x2516, 0x38DF},
+	{0x2518, 0x4E0C},
+	{0x251A, 0x4F0D},
+	{0x251C, 0x110D},
+	{0x251E, 0x100C},
+	{0x2520, 0x110D},
+	{0x2522, 0x100C},
+	{0x2524, 0x110D},
+	{0x2526, 0x100C},
+	{0x2528, 0x110D},
+	{0x252A, 0x100C},
+	{0x252C, 0x110D},
+	{0x252E, 0x100C},
+	{0x2530, 0x9304},
+	{0x2532, 0x2404},
+	{0x2534, 0xE33C},
+	{0x2536, 0xE33D},
+	{0x2538, 0x531C},
+	{0x253A, 0x630D},
+	{0x253C, 0x9305},
+	{0x253E, 0x24C6},
+	{0x2540, 0x460E},
+	{0x2542, 0x430F},
+	{0x2544, 0x8E0C},
+	{0x2546, 0x7F0D},
+	{0x2548, 0x4C87},
+	{0x254A, 0x864C},
+	{0x254C, 0x4D87},
+	{0x254E, 0x864E},
+	{0x2550, 0x480F},
+	{0x2552, 0x510F},
+	{0x2554, 0x90BF},
+	{0x2556, 0x0201},
+	{0x2558, 0x0018},
+	{0x255A, 0x2806},
+	{0x255C, 0x480F},
+	{0x255E, 0x5F0F},
+	{0x2560, 0x438F},
+	{0x2562, 0x864C},
+	{0x2564, 0x438F},
+	{0x2566, 0x864E},
+	{0x2568, 0x5391},
+	{0x256A, 0x0020},
+	{0x256C, 0x92A1},
+	{0x256E, 0x0020},
+	{0x2570, 0x2B53},
+	{0x2572, 0x4381},
+	{0x2574, 0x0030},
+	{0x2576, 0x4381},
+	{0x2578, 0x0032},
+	{0x257A, 0x4381},
+	{0x257C, 0x0034},
+	{0x257E, 0x4118},
+	{0x2580, 0x0002},
+	{0x2582, 0x4309},
+	{0x2584, 0x411E},
+	{0x2586, 0x0004},
+	{0x2588, 0x430F},
+	{0x258A, 0x5E08},
+	{0x258C, 0x6F09},
+	{0x258E, 0xE849},
+	{0x2590, 0xE809},
+	{0x2592, 0x1089},
+	{0x2594, 0xF378},
+	{0x2596, 0x1088},
+	{0x2598, 0x5808},
+	{0x259A, 0x6909},
+	{0x259C, 0x4216},
+	{0x259E, 0x8570},
+	{0x25A0, 0x4307},
+	{0x25A2, 0xE647},
+	{0x25A4, 0xE607},
+	{0x25A6, 0x1087},
+	{0x25A8, 0xF376},
+	{0x25AA, 0x1086},
+	{0x25AC, 0x5606},
+	{0x25AE, 0x6707},
+	{0x25B0, 0x5606},
+	{0x25B2, 0x6707},
+	{0x25B4, 0x411E},
+	{0x25B6, 0x0022},
+	{0x25B8, 0x430F},
+	{0x25BA, 0x4E0A},
+	{0x25BC, 0x4F0B},
+	{0x25BE, 0x480C},
+	{0x25C0, 0x490D},
+	{0x25C2, 0x1202},
+	{0x25C4, 0xC232},
+	{0x25C6, 0x12B0},
+	{0x25C8, 0xFFC0},
+	{0x25CA, 0x4132},
+	{0x25CC, 0x4E04},
+	{0x25CE, 0x4F05},
+	{0x25D0, 0x1084},
+	{0x25D2, 0x1085},
+	{0x25D4, 0xE544},
+	{0x25D6, 0xE504},
+	{0x25D8, 0xF375},
+	{0x25DA, 0xC312},
+	{0x25DC, 0x1005},
+	{0x25DE, 0x1004},
+	{0x25E0, 0x1105},
+	{0x25E2, 0x1004},
+	{0x25E4, 0x411E},
+	{0x25E6, 0x0026},
+	{0x25E8, 0x430F},
+	{0x25EA, 0x4E0A},
+	{0x25EC, 0x4F0B},
+	{0x25EE, 0x1202},
+	{0x25F0, 0xC232},
+	{0x25F2, 0x12B0},
+	{0x25F4, 0xFFC0},
+	{0x25F6, 0x4132},
+	{0x25F8, 0x4E0A},
+	{0x25FA, 0x4F0B},
+	{0x25FC, 0x108A},
+	{0x25FE, 0x108B},
+	{0x2600, 0xEB4A},
+	{0x2602, 0xEB0A},
+	{0x2604, 0xF37B},
+	{0x2606, 0xC312},
+	{0x2608, 0x100B},
+	{0x260A, 0x100A},
+	{0x260C, 0x110B},
+	{0x260E, 0x100A},
+	{0x2610, 0x411E},
+	{0x2612, 0x0024},
+	{0x2614, 0x430F},
+	{0x2616, 0x5E04},
+	{0x2618, 0x6F05},
+	{0x261A, 0x411E},
+	{0x261C, 0x0028},
+	{0x261E, 0x430F},
+	{0x2620, 0x5E0A},
+	{0x2622, 0x6F0B},
+	{0x2624, 0x421E},
+	{0x2626, 0x0392},
+	{0x2628, 0x108C},
+	{0x262A, 0x108D},
+	{0x262C, 0xED4C},
+	{0x262E, 0xED0C},
+	{0x2630, 0xF37D},
+	{0x2632, 0xC312},
+	{0x2634, 0x100D},
+	{0x2636, 0x100C},
+	{0x2638, 0xC312},
+	{0x263A, 0x100D},
+	{0x263C, 0x100C},
+	{0x263E, 0x803C},
+	{0x2640, 0x0384},
+	{0x2642, 0x730D},
+	{0x2644, 0x281F},
+	{0x2646, 0x460C},
+	{0x2648, 0x470D},
+	{0x264A, 0x108C},
+	{0x264C, 0x108D},
+	{0x264E, 0xED4C},
+	{0x2650, 0xED0C},
+	{0x2652, 0xF37D},
+	{0x2654, 0xC312},
+	{0x2656, 0x100D},
+	{0x2658, 0x100C},
+	{0x265A, 0x430F},
+	{0x265C, 0xC312},
+	{0x265E, 0x100D},
+	{0x2660, 0x100C},
+	{0x2662, 0x8E0C},
+	{0x2664, 0x7F0D},
+	{0x2666, 0x280E},
+	{0x2668, 0x4391},
+	{0x266A, 0x0030},
+	{0x266C, 0x90B1},
+	{0x266E, 0x0190},
+	{0x2670, 0x0006},
+	{0x2672, 0x2802},
+	{0x2674, 0x4391},
+	{0x2676, 0x0032},
+	{0x2678, 0x90B1},
+	{0x267A, 0x0190},
+	{0x267C, 0x0000},
+	{0x267E, 0x2802},
+	{0x2680, 0x4391},
+	{0x2682, 0x0034},
+	{0x2684, 0x460E},
+	{0x2686, 0x470F},
+	{0x2688, 0x840E},
+	{0x268A, 0x750F},
+	{0x268C, 0x2805},
+	{0x268E, 0x4A0E},
+	{0x2690, 0x4B0F},
+	{0x2692, 0x860E},
+	{0x2694, 0x770F},
+	{0x2696, 0x2C9D},
+	{0x2698, 0x9381},
+	{0x269A, 0x0034},
+	{0x269C, 0x2004},
+	{0x269E, 0x4382},
+	{0x26A0, 0x864C},
+	{0x26A2, 0x4382},
+	{0x26A4, 0x864E},
+	{0x26A6, 0x9381},
+	{0x26A8, 0x0030},
+	{0x26AA, 0x2008},
+	{0x26AC, 0x4382},
+	{0x26AE, 0x8650},
+	{0x26B0, 0x4382},
+	{0x26B2, 0x8652},
+	{0x26B4, 0x4382},
+	{0x26B6, 0x8654},
+	{0x26B8, 0x4382},
+	{0x26BA, 0x8656},
+	{0x26BC, 0x9381},
+	{0x26BE, 0x0032},
+	{0x26C0, 0x2088},
+	{0x26C2, 0x4382},
+	{0x26C4, 0x8658},
+	{0x26C6, 0x4382},
+	{0x26C8, 0x865A},
+	{0x26CA, 0x3C83},
+	{0x26CC, 0x460E},
+	{0x26CE, 0x430F},
+	{0x26D0, 0x5E0C},
+	{0x26D2, 0x6F0D},
+	{0x26D4, 0x3F39},
+	{0x26D6, 0x503E},
+	{0x26D8, 0x001F},
+	{0x26DA, 0x630F},
+	{0x26DC, 0x3F1D},
+	{0x26DE, 0x9F1C},
+	{0x26E0, 0x0008},
+	{0x26E2, 0x2812},
+	{0x26E4, 0x4304},
+	{0x26E6, 0x4A0F},
+	{0x26E8, 0x580F},
+	{0x26EA, 0x580F},
+	{0x26EC, 0x580F},
+	{0x26EE, 0x4F1B},
+	{0x26F0, 0xBFB0},
+	{0x26F2, 0x903B},
+	{0x26F4, 0x1001},
+	{0x26F6, 0x2801},
+	{0x26F8, 0x4314},
+	{0x26FA, 0x4B09},
+	{0x26FC, 0xF039},
+	{0x26FE, 0x0FFF},
+	{0x2700, 0x4305},
+	{0x2702, 0x4E1E},
+	{0x2704, 0xBFD8},
+	{0x2706, 0x3EDD},
+	{0x2708, 0x9F1C},
+	{0x270A, 0x0006},
+	{0x270C, 0x2812},
+	{0x270E, 0x4304},
+	{0x2710, 0x4A0F},
+	{0x2712, 0x580F},
+	{0x2714, 0x580F},
+	{0x2716, 0x580F},
+	{0x2718, 0x4F1B},
+	{0x271A, 0xBFAE},
+	{0x271C, 0x903B},
+	{0x271E, 0x1001},
+	{0x2720, 0x2801},
+	{0x2722, 0x4314},
+	{0x2724, 0x4B09},
+	{0x2726, 0xF039},
+	{0x2728, 0x0FFF},
+	{0x272A, 0x4305},
+	{0x272C, 0x4E1E},
+	{0x272E, 0xBFD6},
+	{0x2730, 0x3EC8},
+	{0x2732, 0x9F1C},
+	{0x2734, 0x0004},
+	{0x2736, 0x2812},
+	{0x2738, 0x4304},
+	{0x273A, 0x4A0F},
+	{0x273C, 0x580F},
+	{0x273E, 0x580F},
+	{0x2740, 0x580F},
+	{0x2742, 0x4F1B},
+	{0x2744, 0xBFAC},
+	{0x2746, 0x903B},
+	{0x2748, 0x1001},
+	{0x274A, 0x2801},
+	{0x274C, 0x4314},
+	{0x274E, 0x4B09},
+	{0x2750, 0xF039},
+	{0x2752, 0x0FFF},
+	{0x2754, 0x4305},
+	{0x2756, 0x4E1E},
+	{0x2758, 0xBFD4},
+	{0x275A, 0x3EB3},
+	{0x275C, 0x9F1C},
+	{0x275E, 0x0002},
+	{0x2760, 0x2812},
+	{0x2762, 0x4304},
+	{0x2764, 0x4A0F},
+	{0x2766, 0x580F},
+	{0x2768, 0x580F},
+	{0x276A, 0x580F},
+	{0x276C, 0x4F1B},
+	{0x276E, 0xBFAA},
+	{0x2770, 0x903B},
+	{0x2772, 0x1001},
+	{0x2774, 0x2801},
+	{0x2776, 0x4314},
+	{0x2778, 0x4B09},
+	{0x277A, 0xF039},
+	{0x277C, 0x0FFF},
+	{0x277E, 0x4305},
+	{0x2780, 0x4E1E},
+	{0x2782, 0xBFD2},
+	{0x2784, 0x3E9E},
+	{0x2786, 0x9F2C},
+	{0x2788, 0x2812},
+	{0x278A, 0x4304},
+	{0x278C, 0x4A0F},
+	{0x278E, 0x580F},
+	{0x2790, 0x580F},
+	{0x2792, 0x580F},
+	{0x2794, 0x4F1B},
+	{0x2796, 0xBFA8},
+	{0x2798, 0x903B},
+	{0x279A, 0x1001},
+	{0x279C, 0x2801},
+	{0x279E, 0x4314},
+	{0x27A0, 0x4B09},
+	{0x27A2, 0xF039},
+	{0x27A4, 0x0FFF},
+	{0x27A6, 0x4305},
+	{0x27A8, 0x4E1E},
+	{0x27AA, 0xBFD0},
+	{0x27AC, 0x3E8A},
+	{0x27AE, 0x438A},
+	{0x27B0, 0x864C},
+	{0x27B2, 0x438A},
+	{0x27B4, 0x864E},
+	{0x27B6, 0x3E8C},
+	{0x27B8, 0xC3E2},
+	{0x27BA, 0x0380},
+	{0x27BC, 0x3E24},
+	{0x27BE, 0x93C2},
+	{0x27C0, 0x853E},
+	{0x27C2, 0x2402},
+	{0x27C4, 0x4030},
+	{0x27C6, 0xB3C4},
+	{0x27C8, 0x40B1},
+	{0x27CA, 0x8534},
+	{0x27CC, 0x002A},
+	{0x27CE, 0x4030},
+	{0x27D0, 0xB3CA},
+	{0x27D2, 0x5031},
+	{0x27D4, 0x0036},
+	{0x27D6, 0x4134},
+	{0x27D8, 0x4135},
+	{0x27DA, 0x4136},
+	{0x27DC, 0x4137},
+	{0x27DE, 0x4138},
+	{0x27E0, 0x4139},
+	{0x27E2, 0x413A},
+	{0x27E4, 0x413B},
+	{0x27E6, 0x4130},
+	{0x27E8, 0x120B},
+	{0x27EA, 0x120A},
+	{0x27EC, 0x1209},
+	{0x27EE, 0x1208},
+	{0x27F0, 0x1207},
+	{0x27F2, 0x1206},
+	{0x27F4, 0x1205},
+	{0x27F6, 0x8031},
+	{0x27F8, 0x0010},
+	{0x27FA, 0x4035},
+	{0x27FC, 0x84D0},
+	{0x27FE, 0x4036},
+	{0x2800, 0x84F0},
+	{0x2802, 0x4291},
+	{0x2804, 0x864C},
+	{0x2806, 0x0000},
+	{0x2808, 0x4291},
+	{0x280A, 0x864E},
+	{0x280C, 0x0002},
+	{0x280E, 0x4291},
+	{0x2810, 0x8650},
+	{0x2812, 0x0004},
+	{0x2814, 0x4291},
+	{0x2816, 0x8652},
+	{0x2818, 0x0006},
+	{0x281A, 0x4291},
+	{0x281C, 0x8654},
+	{0x281E, 0x0008},
+	{0x2820, 0x4291},
+	{0x2822, 0x8656},
+	{0x2824, 0x000A},
+	{0x2826, 0x4291},
+	{0x2828, 0x8658},
+	{0x282A, 0x000C},
+	{0x282C, 0x4291},
+	{0x282E, 0x865A},
+	{0x2830, 0x000E},
+	{0x2832, 0x4307},
+	{0x2834, 0x470B},
+	{0x2836, 0x5B0B},
+	{0x2838, 0x5B0B},
+	{0x283A, 0x4B1E},
+	{0x283C, 0x0650},
+	{0x283E, 0x4B1F},
+	{0x2840, 0x0652},
+	{0x2842, 0x4E09},
+	{0x2844, 0x4308},
+	{0x2846, 0x4B1E},
+	{0x2848, 0x064E},
+	{0x284A, 0x4B1F},
+	{0x284C, 0x0650},
+	{0x284E, 0xD80E},
+	{0x2850, 0xD90F},
+	{0x2852, 0x470A},
+	{0x2854, 0x5A0A},
+	{0x2856, 0x4A1D},
+	{0x2858, 0x0646},
+	{0x285A, 0x1206},
+	{0x285C, 0x450C},
+	{0x285E, 0x1292},
+	{0x2860, 0x8484},
+	{0x2862, 0x4E8B},
+	{0x2864, 0x061A},
+	{0x2866, 0x4F8B},
+	{0x2868, 0x061C},
+	{0x286A, 0x5321},
+	{0x286C, 0x93C2},
+	{0x286E, 0x853E},
+	{0x2870, 0x200B},
+	{0x2872, 0xB0F2},
+	{0x2874, 0x0010},
+	{0x2876, 0x0381},
+	{0x2878, 0x2407},
+	{0x287A, 0x4B0F},
+	{0x287C, 0x510F},
+	{0x287E, 0x5FAB},
+	{0x2880, 0x061A},
+	{0x2882, 0x6F9B},
+	{0x2884, 0x0002},
+	{0x2886, 0x061C},
+	{0x2888, 0xB0F2},
+	{0x288A, 0x0010},
+	{0x288C, 0x0603},
+	{0x288E, 0x2005},
+	{0x2890, 0x4A0D},
+	{0x2892, 0x5D0D},
+	{0x2894, 0xF0BD},
+	{0x2896, 0xF800},
+	{0x2898, 0x061A},
+	{0x289A, 0x5317},
+	{0x289C, 0x5235},
+	{0x289E, 0x5226},
+	{0x28A0, 0x9227},
+	{0x28A2, 0x2BC8},
+	{0x28A4, 0x5031},
+	{0x28A6, 0x0010},
+	{0x28A8, 0x4135},
+	{0x28AA, 0x4136},
+	{0x28AC, 0x4137},
+	{0x28AE, 0x4138},
+	{0x28B0, 0x4139},
+	{0x28B2, 0x413A},
+	{0x28B4, 0x413B},
+	{0x28B6, 0x4130},
+	{0x28B8, 0x120B},
+	{0x28BA, 0x430B},
+	{0x28BC, 0x425F},
+	{0x28BE, 0x0204},
+	{0x28C0, 0xF07F},
+	{0x28C2, 0x0003},
+	{0x28C4, 0x936F},
+	{0x28C6, 0x2801},
+	{0x28C8, 0x431B},
+	{0x28CA, 0x1292},
+	{0x28CC, 0xD048},
+	{0x28CE, 0xB0F2},
+	{0x28D0, 0x0040},
+	{0x28D2, 0x0381},
+	{0x28D4, 0x2450},
+	{0x28D6, 0x421E},
+	{0x28D8, 0x0206},
+	{0x28DA, 0xC312},
+	{0x28DC, 0x100E},
+	{0x28DE, 0x40F2},
+	{0x28E0, 0x0005},
+	{0x28E2, 0x0321},
+	{0x28E4, 0x43C2},
+	{0x28E6, 0x0320},
+	{0x28E8, 0x40F2},
+	{0x28EA, 0x0015},
+	{0x28EC, 0x0323},
+	{0x28EE, 0x40F2},
+	{0x28F0, 0x0016},
+	{0x28F2, 0x0325},
+	{0x28F4, 0x40B2},
+	{0x28F6, 0x0011},
+	{0x28F8, 0x0326},
+	{0x28FA, 0x4E0F},
+	{0x28FC, 0x503F},
+	{0x28FE, 0x0011},
+	{0x2900, 0x4F82},
+	{0x2902, 0x032A},
+	{0x2904, 0x40B2},
+	{0x2906, 0x0011},
+	{0x2908, 0x0346},
+	{0x290A, 0x4F82},
+	{0x290C, 0x034A},
+	{0x290E, 0x90B2},
+	{0x2910, 0x0018},
+	{0x2912, 0x0A00},
+	{0x2914, 0x2C1E},
+	{0x2916, 0x930B},
+	{0x2918, 0x240E},
+	{0x291A, 0x40B2},
+	{0x291C, 0x0019},
+	{0x291E, 0x0328},
+	{0x2920, 0x523F},
+	{0x2922, 0x4F82},
+	{0x2924, 0x032C},
+	{0x2926, 0x40B2},
+	{0x2928, 0x001A},
+	{0x292A, 0x0348},
+	{0x292C, 0x503E},
+	{0x292E, 0x001A},
+	{0x2930, 0x4E82},
+	{0x2932, 0x034C},
+	{0x2934, 0x3C22},
+	{0x2936, 0x40B2},
+	{0x2938, 0x0021},
+	{0x293A, 0x0328},
+	{0x293C, 0x4E0F},
+	{0x293E, 0x503F},
+	{0x2940, 0x0021},
+	{0x2942, 0x4F82},
+	{0x2944, 0x032C},
+	{0x2946, 0x40B2},
+	{0x2948, 0x0022},
+	{0x294A, 0x0348},
+	{0x294C, 0x503E},
+	{0x294E, 0x0022},
+	{0x2950, 0x3FEF},
+	{0x2952, 0x90B2},
+	{0x2954, 0x0030},
+	{0x2956, 0x0A00},
+	{0x2958, 0x2BEE},
+	{0x295A, 0x40B2},
+	{0x295C, 0x003F},
+	{0x295E, 0x0328},
+	{0x2960, 0x4E0F},
+	{0x2962, 0x503F},
+	{0x2964, 0x003F},
+	{0x2966, 0x4F82},
+	{0x2968, 0x032C},
+	{0x296A, 0x40B2},
+	{0x296C, 0x0040},
+	{0x296E, 0x0348},
+	{0x2970, 0x503E},
+	{0x2972, 0x0040},
+	{0x2974, 0x3FDD},
+	{0x2976, 0x43C2},
+	{0x2978, 0x0321},
+	{0x297A, 0x413B},
+	{0x297C, 0x4130},
+	{0x297E, 0x42D2},
+	{0x2980, 0x0B02},
+	{0x2982, 0x8664},
+	{0x2984, 0x403E},
+	{0x2986, 0x1200},
+	{0x2988, 0x4E6F},
+	{0x298A, 0xC312},
+	{0x298C, 0x104F},
+	{0x298E, 0x114F},
+	{0x2990, 0x4F0D},
+	{0x2992, 0xF31D},
+	{0x2994, 0x4D82},
+	{0x2996, 0x865C},
+	{0x2998, 0x4E6F},
+	{0x299A, 0xC312},
+	{0x299C, 0x104F},
+	{0x299E, 0x114F},
+	{0x29A0, 0x114F},
+	{0x29A2, 0x4F0D},
+	{0x29A4, 0xF31D},
+	{0x29A6, 0x4D82},
+	{0x29A8, 0x865E},
+	{0x29AA, 0x4E6F},
+	{0x29AC, 0xC312},
+	{0x29AE, 0x104F},
+	{0x29B0, 0x4F0D},
+	{0x29B2, 0xF31D},
+	{0x29B4, 0x4D82},
+	{0x29B6, 0x8660},
+	{0x29B8, 0x4E6F},
+	{0x29BA, 0xF35F},
+	{0x29BC, 0x4F0E},
+	{0x29BE, 0xF31E},
+	{0x29C0, 0x4E82},
+	{0x29C2, 0x8662},
+	{0x29C4, 0x1292},
+	{0x29C6, 0xD030},
+	{0x29C8, 0x4130},
+	{0x29CA, 0x93C2},
+	{0x29CC, 0x0263},
+	{0x29CE, 0x2403},
+	{0x29D0, 0x42D2},
+	{0x29D2, 0x8664},
+	{0x29D4, 0x0B02},
+	{0x29D6, 0x9392},
+	{0x29D8, 0x865C},
+	{0x29DA, 0x241B},
+	{0x29DC, 0xC2E2},
+	{0x29DE, 0x1200},
+	{0x29E0, 0x9392},
+	{0x29E2, 0x865E},
+	{0x29E4, 0x2413},
+	{0x29E6, 0xC2F2},
+	{0x29E8, 0x1200},
+	{0x29EA, 0x9392},
+	{0x29EC, 0x8660},
+	{0x29EE, 0x240B},
+	{0x29F0, 0xC3E2},
+	{0x29F2, 0x1200},
+	{0x29F4, 0x9392},
+	{0x29F6, 0x8662},
+	{0x29F8, 0x2403},
+	{0x29FA, 0xC3D2},
+	{0x29FC, 0x1200},
+	{0x29FE, 0x3C0C},
+	{0x2A00, 0xD3D2},
+	{0x2A02, 0x1200},
+	{0x2A04, 0x3C09},
+	{0x2A06, 0xD3E2},
+	{0x2A08, 0x1200},
+	{0x2A0A, 0x3FF4},
+	{0x2A0C, 0xD2F2},
+	{0x2A0E, 0x1200},
+	{0x2A10, 0x3FEC},
+	{0x2A12, 0xD2E2},
+	{0x2A14, 0x1200},
+	{0x2A16, 0x3FE4},
+	{0x2A18, 0x1292},
+	{0x2A1A, 0xD016},
+	{0x2A1C, 0x4130},
+	{0x2A1E, 0x1292},
+	{0x2A20, 0xD022},
+	{0x2A22, 0x43C2},
+	{0x2A24, 0x0B02},
+	{0x2A26, 0x4130},
+	{0x2A28, 0x430F},
+	{0x2A2A, 0xD3D2},
+	{0x2A2C, 0x7A12},
+	{0x2A2E, 0x0B00},
+	{0x2A30, 0x7304},
+	{0x2A32, 0x0000},
+	{0x2A34, 0x0800},
+	{0x2A36, 0x7A10},
+	{0x2A38, 0xD3D2},
+	{0x2A3A, 0x7B00},
+	{0x2A3C, 0x0800},
+	{0x2A3E, 0x7B00},
+	{0x2A40, 0x903F},
+	{0x2A42, 0x0005},
+	{0x2A44, 0x2003},
+	{0x2A46, 0x42D2},
+	{0x2A48, 0x8664},
+	{0x2A4A, 0x0B02},
+	{0x2A4C, 0x531F},
+	{0x2A4E, 0x9382},
+	{0x2A50, 0x7112},
+	{0x2A52, 0x27ED},
+	{0x2A54, 0x4130},
+	{0x2A56, 0x120B},
+	{0x2A58, 0x120A},
+	{0x2A5A, 0x1292},
+	{0x2A5C, 0xD056},
+	{0x2A5E, 0x421C},
+	{0x2A60, 0x865E},
+	{0x2A62, 0x4C0E},
+	{0x2A64, 0x5E0E},
+	{0x2A66, 0x5E0E},
+	{0x2A68, 0x5E0E},
+	{0x2A6A, 0x421D},
+	{0x2A6C, 0x865C},
+	{0x2A6E, 0x4D0F},
+	{0x2A70, 0x5F0F},
+	{0x2A72, 0x5F0F},
+	{0x2A74, 0xDF0E},
+	{0x2A76, 0x421B},
+	{0x2A78, 0x8660},
+	{0x2A7A, 0x4B0F},
+	{0x2A7C, 0x5F0F},
+	{0x2A7E, 0xDF0E},
+	{0x2A80, 0x421A},
+	{0x2A82, 0x8662},
+	{0x2A84, 0xDA0E},
+	{0x2A86, 0x93C2},
+	{0x2A88, 0x0381},
+	{0x2A8A, 0x3454},
+	{0x2A8C, 0xB3E2},
+	{0x2A8E, 0x0380},
+	{0x2A90, 0x240C},
+	{0x2A92, 0x903E},
+	{0x2A94, 0x0009},
+	{0x2A96, 0x2445},
+	{0x2A98, 0x903E},
+	{0x2A9A, 0x0005},
+	{0x2A9C, 0x2439},
+	{0x2A9E, 0x903E},
+	{0x2AA0, 0x000A},
+	{0x2AA2, 0x242B},
+	{0x2AA4, 0x903E},
+	{0x2AA6, 0x000B},
+	{0x2AA8, 0x241D},
+	{0x2AAA, 0x931D},
+	{0x2AAC, 0x2418},
+	{0x2AAE, 0xC2E2},
+	{0x2AB0, 0x1200},
+	{0x2AB2, 0x931C},
+	{0x2AB4, 0x2411},
+	{0x2AB6, 0xC2F2},
+	{0x2AB8, 0x1200},
+	{0x2ABA, 0x931B},
+	{0x2ABC, 0x240A},
+	{0x2ABE, 0xC3E2},
+	{0x2AC0, 0x1200},
+	{0x2AC2, 0x931A},
+	{0x2AC4, 0x2403},
+	{0x2AC6, 0xC3D2},
+	{0x2AC8, 0x1200},
+	{0x2ACA, 0x3C34},
+	{0x2ACC, 0xD3D2},
+	{0x2ACE, 0x1200},
+	{0x2AD0, 0x3C31},
+	{0x2AD2, 0xD3E2},
+	{0x2AD4, 0x1200},
+	{0x2AD6, 0x3FF5},
+	{0x2AD8, 0xD2F2},
+	{0x2ADA, 0x1200},
+	{0x2ADC, 0x3FEE},
+	{0x2ADE, 0xD2E2},
+	{0x2AE0, 0x1200},
+	{0x2AE2, 0x3FE7},
+	{0x2AE4, 0x403F},
+	{0x2AE6, 0x1200},
+	{0x2AE8, 0xC2FF},
+	{0x2AEA, 0x0000},
+	{0x2AEC, 0xC2EF},
+	{0x2AEE, 0x0000},
+	{0x2AF0, 0xD3EF},
+	{0x2AF2, 0x0000},
+	{0x2AF4, 0xD3DF},
+	{0x2AF6, 0x0000},
+	{0x2AF8, 0x3C1D},
+	{0x2AFA, 0x403F},
+	{0x2AFC, 0x1200},
+	{0x2AFE, 0xD2FF},
+	{0x2B00, 0x0000},
+	{0x2B02, 0xC2EF},
+	{0x2B04, 0x0000},
+	{0x2B06, 0xD3EF},
+	{0x2B08, 0x0000},
+	{0x2B0A, 0xC3DF},
+	{0x2B0C, 0x0000},
+	{0x2B0E, 0x3C12},
+	{0x2B10, 0x403F},
+	{0x2B12, 0x1200},
+	{0x2B14, 0xD2FF},
+	{0x2B16, 0x0000},
+	{0x2B18, 0xC2EF},
+	{0x2B1A, 0x0000},
+	{0x2B1C, 0xC3EF},
+	{0x2B1E, 0x0000},
+	{0x2B20, 0x3FF4},
+	{0x2B22, 0x403F},
+	{0x2B24, 0x1200},
+	{0x2B26, 0xC2FF},
+	{0x2B28, 0x0000},
+	{0x2B2A, 0xC2EF},
+	{0x2B2C, 0x0000},
+	{0x2B2E, 0xC3EF},
+	{0x2B30, 0x0000},
+	{0x2B32, 0x3FE0},
+	{0x2B34, 0x413A},
+	{0x2B36, 0x413B},
+	{0x2B38, 0x4130},
+	{0x2B3A, 0x4292},
+	{0x2B3C, 0x0C34},
+	{0x2B3E, 0x0202},
+	{0x2B40, 0x1292},
+	{0x2B42, 0xD006},
+	{0x2B44, 0x93C2},
+	{0x2B46, 0x861A},
+	{0x2B48, 0x2403},
+	{0x2B4A, 0x407F},
+	{0x2B4C, 0x0003},
+	{0x2B4E, 0x3C01},
+	{0x2B50, 0x434F},
+	{0x2B52, 0x4FC2},
+	{0x2B54, 0x023D},
+	{0x2B56, 0x425F},
+	{0x2B58, 0x861A},
+	{0x2B5A, 0x503F},
+	{0x2B5C, 0x0C7E},
+	{0x2B5E, 0x4F82},
+	{0x2B60, 0x752A},
+	{0x2B62, 0x4130},
+	{0x2B64, 0x7400},
+	{0x2B66, 0x8050},
+	{0x2B68, 0x30D8},
+	{0x2B6A, 0x0021},
+	{0x2B6C, 0x009D},
+	{0x2B6E, 0x005D},
+	{0x2B70, 0x21C3},
+	{0x2B72, 0x21C0},
+	{0x2B74, 0x0058},
+	{0x2B76, 0x0007},
+	{0x2B78, 0x5020},
+	{0x2B7A, 0x5040},
+	{0x2B7C, 0x5060},
+	{0x2B7E, 0x0098},
+	{0x2B80, 0x0057},
+	{0x2B82, 0x5083},
+	{0x2B84, 0x0912},
+	{0x2B86, 0x15D3},
+	{0x2B88, 0x0000},
+	{0x2B8A, 0x702C},
+	{0x2B8C, 0x16D5},
+	{0x2B8E, 0x20C3},
+	{0x2B90, 0x0058},
+	{0x2B92, 0x0001},
+	{0x2B94, 0x20A4},
+	{0x2B96, 0x700E},
+	{0x2B98, 0x2FA7},
+	{0x2B9A, 0x50A0},
+	{0x2B9C, 0x50C0},
+	{0x2B9E, 0x1805},
+	{0x2BA0, 0x0008},
+	{0x2BA2, 0x0020},
+	{0x2BA4, 0x0303},
+	{0x2BA6, 0x00C8},
+	{0x2BA8, 0x0045},
+	{0x2BAA, 0x0006},
+	{0x2BAC, 0x7002},
+	{0x2BAE, 0x0FDD},
+	{0x2BB0, 0x005D},
+	{0x2BB2, 0x21C3},
+	{0x2BB4, 0x21C0},
+	{0x2BB6, 0x21C3},
+	{0x2BB8, 0x0058},
+	{0x2BBA, 0x2014},
+	{0x2BBC, 0x20A4},
+	{0x2BBE, 0x704E},
+	{0x2BC0, 0x2FA7},
+	{0x2BC2, 0x50E0},
+	{0x2BC4, 0x5100},
+	{0x2BC6, 0x1345},
+	{0x2BC8, 0x0004},
+	{0x2BCA, 0x2132},
+	{0x2BCC, 0x7800},
+	{0x2BCE, 0x022E},
+	{0x2BD0, 0x0207},
+	{0x2BD2, 0x2E78},
+	{0x2BD4, 0x0002},
+	{0x2BD6, 0x7E38},
+	{0x2BD8, 0x0052},
+	{0x2BDA, 0x7E38},
+	{0x2BDC, 0x065E},
+	{0x2BDE, 0x5038},
+	{0x2BE0, 0x07DE},
+	{0x2BE2, 0x503A},
+	{0x2BE4, 0x0E72},
+	{0x2BE6, 0x507A},
+	{0x2BE8, 0x0F62},
+	{0x2BEA, 0x5030},
+	{0x2BEC, 0x0E62},
+	{0x2BEE, 0x0FF0},
+	{0x2BF0, 0x0702},
+	{0x2BF2, 0x7400},
+	{0x2BF4, 0x2002},
+	{0x2BF6, 0x7023},
+	{0x2BF8, 0x0FC1},
+	{0x2BFA, 0x705E},
+	{0x2BFC, 0x0FC0},
+	{0x2BFE, 0x7800},
+	{0x2C00, 0x0061},
+	{0x2C02, 0x7400},
+	{0x2C04, 0x2004},
+	{0x2C06, 0x7023},
+	{0x2C08, 0x0FC2},
+	{0x2C0A, 0x705E},
+	{0x2C0C, 0x0FC0},
+	{0x2C0E, 0x7800},
+	{0x2C10, 0x7400},
+	{0x2C12, 0x2008},
+	{0x2C14, 0x7023},
+	{0x2C16, 0x0FC3},
+	{0x2C18, 0x705E},
+	{0x2C1A, 0x0FC0},
+	{0x2C1C, 0x7800},
+	{0x2C1E, 0x7400},
+	{0x2C20, 0x0004},
+	{0x2C22, 0x70DF},
+	{0x2C24, 0x2F1F},
+	{0x2C26, 0x7002},
+	{0x2C28, 0x2F01},
+	{0x2C2A, 0x7800},
+	{0x2C2C, 0x7400},
+	{0x2C2E, 0x2010},
+	{0x2C30, 0x7023},
+	{0x2C32, 0x0FC4},
+	{0x2C34, 0x705E},
+	{0x2C36, 0x0FC0},
+	{0x2C38, 0x7800},
+	{0x2C3A, 0x7400},
+	{0x2C3C, 0x0003},
+	{0x2C3E, 0x70DF},
+	{0x2C40, 0x2F1F},
+	{0x2C42, 0x7002},
+	{0x2C44, 0x2F01},
+	{0x2C46, 0x7800},
+	{0x2C48, 0x7400},
+	{0x2C4A, 0x0002},
+	{0x2C4C, 0x70DF},
+	{0x2C4E, 0x2F1F},
+	{0x2C50, 0x7002},
+	{0x2C52, 0x2F01},
+	{0x2C54, 0x7800},
+	{0x2C56, 0x7400},
+	{0x2C58, 0x2008},
+	{0x2C5A, 0x7023},
+	{0x2C5C, 0x0FC3},
+	{0x2C5E, 0x705E},
+	{0x2C60, 0x0FC0},
+	{0x2C62, 0x7800},
+	{0x2C64, 0x0000},
+	{0x2C66, 0xBB64},
+	{0x2C68, 0x0000},
+	{0x2C6A, 0xBB64},
+	{0x2C6C, 0xBBCE},
+	{0x2C6E, 0x0002},
+	{0x2C70, 0x0063},
+	{0x2C72, 0xBBF2},
+	{0x2C74, 0x0063},
+	{0x2C76, 0xBC02},
+	{0x2C78, 0x0063},
+	{0x2C7A, 0xBC2C},
+	{0x2C7C, 0x0063},
+	{0x2C7E, 0xBC3A},
+	{0x2C80, 0xBC00},
+	{0x2C82, 0x0004},
+	{0x2C84, 0x0063},
+	{0x2C86, 0xBC2C},
+	{0x2C88, 0x0063},
+	{0x2C8A, 0xBC56},
+	{0x2C8C, 0x0063},
+	{0x2C8E, 0xBBF2},
+	{0x2C90, 0x0063},
+	{0x2C92, 0xBC48},
+	{0x2C94, 0xBC00},
+	{0x2C96, 0x0004},
+	{0x2C98, 0x0063},
+	{0x2C9A, 0xBBF2},
+	{0x2C9C, 0x0063},
+	{0x2C9E, 0xBC48},
+	{0x2CA0, 0x0063},
+	{0x2CA2, 0xBC2C},
+	{0x2CA4, 0x0063},
+	{0x2CA6, 0xBC3A},
+	{0x2CA8, 0xBC00},
+	{0x2CAA, 0x0004},
+	{0x2CAC, 0x0063},
+	{0x2CAE, 0xBC2C},
+	{0x2CB0, 0x0063},
+	{0x2CB2, 0xBC3A},
+	{0x2CB4, 0x0063},
+	{0x2CB6, 0xBBF2},
+	{0x2CB8, 0x0063},
+	{0x2CBA, 0xBC48},
+	{0x2CBC, 0xBC00},
+	{0x2CBE, 0x0004},
+	{0x2CC0, 0x0035},
+	{0x2CC2, 0x0037},
+	{0x2CC4, 0x003F},
+	{0x2CC6, 0x0157},
+	{0x2CC8, 0x0027},
+	{0x2CCA, 0x0023},
+	{0x2CCC, 0x004B},
+	{0x2CCE, 0x01C9},
+	{0x2CD0, 0x0091},
+	{0x2CD2, 0x0035},
+	{0x2CD4, 0x0034},
+	{0x2CD6, 0xFFFF},
+	{0x2CD8, 0x0028},
+	{0x2CDA, 0x0050},
+	{0x2CDC, 0x0000},
+	{0x2CDE, 0x0000},
+	{0x2CE0, 0xBCC0},
+	{0x2CE2, 0xBC64},
+	{0x2CE4, 0xBCD8},
+	{0x2CE6, 0xBC70},
+	{0x2CE8, 0xBC84},
+	{0x2CEA, 0xBC70},
+	{0x2CEC, 0xBC84},
+	{0x2CEE, 0x0000},
+	{0x2CF0, 0x0000},
+	{0x2CF2, 0x0000},
+	{0x2CF4, 0x0000},
+	{0x2CF6, 0x0000},
+	{0x2CF8, 0x0000},
+	{0x2CFA, 0x0000},
+	{0x2CFC, 0x0000},
+	{0x2CFE, 0x0000},
+	{0x2D00, 0x0000},
+	{0x2D02, 0x0000},
+	{0x2D04, 0x0000},
+	{0x2D06, 0xBC70},
+	{0x2D08, 0xBC84},
+	{0x2D0A, 0xBC98},
+	{0x2D0C, 0xBCAC},
+	{0x2D0E, 0x0000},
+	{0x2D10, 0x0000},
+	{0x2D12, 0x0000},
+	{0x2D14, 0x0000},
+	{0x2D16, 0x0000},
+	{0x2D18, 0x0000},
+	{0x2D1A, 0x0000},
+	{0x2D1C, 0x0000},
+	{0x2D1E, 0x0000},
+	{0x2D20, 0x0000},
+	{0x2D22, 0x0000},
+	{0x2D24, 0x0000},
+	{0x2E38, 0x0040},
+	{0x2E3A, 0x0042},
+	{0x2E3C, 0x0048},
+	{0x2E3E, 0x0050},
+	{0x2E40, 0x0055},
+	{0x2E42, 0x005D},
+	{0x2E44, 0x0065},
+	{0x2E46, 0x0067},
+	{0x2E48, 0x0068},
+	{0x2E4A, 0x006E},
+	{0x2E4C, 0x0075},
+	{0x2E4E, 0x007A},
+	{0x2E50, 0x0081},
+	{0x2E52, 0x0085},
+	{0x2E54, 0x0088},
+	{0x2E56, 0x0091},
+	{0x2E58, 0x0093},
+	{0x2E5A, 0x0098},
+	{0x2E5C, 0x009E},
+	{0x2E5E, 0x00A1},
+	{0x2E60, 0x00A8},
+	{0x2E62, 0x00AD},
+	{0x2E64, 0x00BB},
+	{0x2E66, 0x00C5},
+	{0x2E68, 0x00CC},
+	{0x2E6A, 0x00D1},
+	{0x2E6C, 0x00CF},
+	{0x2E6E, 0x00CD},
+	{0x2E70, 0x00DA},
+	{0x2E72, 0x00D8},
+	{0x2E74, 0x00E8},
+	{0x2E76, 0x00E8},
+	{0x2E78, 0x0200},
+	{0x2E7A, 0x0200},
+	{0x2E7C, 0x0200},
+	{0x2E7E, 0x0200},
+	{0x2E80, 0x0200},
+	{0x2E82, 0x0200},
+	{0x2E84, 0x0200},
+	{0x2E86, 0x0200},
+	{0x2E88, 0x0200},
+	{0x2E8A, 0x0200},
+	{0x2E8C, 0x0200},
+	{0x2E8E, 0x0200},
+	{0x2E90, 0x0200},
+	{0x2E92, 0x0200},
+	{0x2E94, 0x0200},
+	{0x2E96, 0x0200},
+	{0x2E98, 0x0200},
+	{0x2E9A, 0x0200},
+	{0x2E9C, 0x0200},
+	{0x2E9E, 0x0200},
+	{0x2EA0, 0x0200},
+	{0x2EA2, 0x0200},
+	{0x2EA4, 0x0200},
+	{0x2EA6, 0x0200},
+	{0x2EA8, 0x0200},
+	{0x2EAA, 0x0200},
+	{0x2EAC, 0x0200},
+	{0x2EAE, 0x0200},
+	{0x2EB0, 0x0200},
+	{0x2EB2, 0x0200},
+	{0x2EB4, 0x0200},
+	{0x2EB6, 0x0200},
+	{0x2EB8, 0x0200},
+	{0x2EBA, 0x0200},
+	{0x2EBC, 0x0200},
+	{0x2EBE, 0x0200},
+	{0x2EC0, 0x0200},
+	{0x2EC2, 0x0200},
+	{0x2EC4, 0x0200},
+	{0x2EC6, 0x0200},
+	{0x2EC8, 0x0200},
+	{0x2ECA, 0x0200},
+	{0x2ECC, 0x0200},
+	{0x2ECE, 0x0200},
+	{0x2ED0, 0x0200},
+	{0x2ED2, 0x0200},
+	{0x2ED4, 0x0200},
+	{0x2ED6, 0x0200},
+	{0x2ED8, 0x0200},
+	{0x2EDA, 0x0200},
+	{0x2EDC, 0x0200},
+	{0x2EDE, 0x0200},
+	{0x2EE0, 0x0200},
+	{0x2EE2, 0x0200},
+	{0x2EE4, 0x0200},
+	{0x2EE6, 0x0200},
+	{0x2EE8, 0x0200},
+	{0x2EEA, 0x0200},
+	{0x2EEC, 0x0200},
+	{0x2EEE, 0x0200},
+	{0x2EF0, 0x0200},
+	{0x2EF2, 0x0200},
+	{0x2EF4, 0x0200},
+	{0x2EF6, 0x0200},
+	{0x2EF8, 0x0200},
+	{0x2EFA, 0x0200},
+	{0x2EFC, 0x0200},
+	{0x2EFE, 0x0200},
+	{0x2F00, 0x0200},
+	{0x2F02, 0x0200},
+	{0x2F04, 0x0200},
+	{0x2F06, 0x0200},
+	{0x2F08, 0x0200},
+	{0x2F0A, 0x0200},
+	{0x2F0C, 0x0200},
+	{0x2F0E, 0x0200},
+	{0x2F10, 0x0200},
+	{0x2F12, 0x0200},
+	{0x2F14, 0x0200},
+	{0x2F16, 0x0200},
+	{0x2F18, 0x0200},
+	{0x2F1A, 0x0200},
+	{0x2F1C, 0x0200},
+	{0x2F1E, 0x0200},
+	{0x2F20, 0x0200},
+	{0x2F22, 0x0200},
+	{0x2F24, 0x0200},
+	{0x2F26, 0x0200},
+	{0x2F28, 0x0200},
+	{0x2F2A, 0x0200},
+	{0x2F2C, 0x0200},
+	{0x2F2E, 0x0200},
+	{0x2F30, 0x0200},
+	{0x2F32, 0x0200},
+	{0x2F34, 0x0200},
+	{0x2F36, 0x0200},
+	{0x2F38, 0x0200},
+	{0x2F3A, 0x0200},
+	{0x2F3C, 0x0200},
+	{0x2F3E, 0x0200},
+	{0x2F40, 0x0200},
+	{0x2F42, 0x0200},
+	{0x2F44, 0x0200},
+	{0x2F46, 0x0200},
+	{0x2F48, 0x0200},
+	{0x2F4A, 0x0200},
+	{0x2F4C, 0x0200},
+	{0x2F4E, 0x0200},
+	{0x2F50, 0x0200},
+	{0x2F52, 0x0200},
+	{0x2F54, 0x0200},
+	{0x2F56, 0x0200},
+	{0x2F58, 0x0200},
+	{0x2F5A, 0x0200},
+	{0x2F5C, 0x0200},
+	{0x2F5E, 0x0200},
+	{0x2F60, 0x0200},
+	{0x2F62, 0x0200},
+	{0x2F64, 0x0200},
+	{0x2F66, 0x0200},
+	{0x2F68, 0x0200},
+	{0x2F6A, 0x0200},
+	{0x2F6C, 0x0200},
+	{0x2F6E, 0x0200},
+	{0x2F70, 0x0200},
+	{0x2F72, 0x0200},
+	{0x2F74, 0x0200},
+	{0x2F76, 0x0200},
+	{0x363E, 0xBE38},
+	{0x3640, 0xBD06},
+	{0x3642, 0xBCE4},
+	{0x3644, 0xD13E},
+	{0x3646, 0xBCE6},
+	{0x3648, 0xBCE2},
+	{0x364A, 0x0000},
+	{0x364C, 0x0000},
+	{0x364E, 0x0000},
+	{0x3650, 0x0000},
+	{0x3652, 0x0000},
+	{0x3654, 0x0000},
+	{0x3656, 0x0000},
+	{0x3658, 0x0000},
+	{0x365A, 0x0000},
+	{0x365C, 0x0000},
+	{0x365E, 0x0000},
+	{0x3660, 0x0000},
+	{0x3662, 0x0000},
+
+	{0x2F78, 0x0042},
+	{0x2F7A, 0x004C},
+	{0x2F7C, 0x0078},
+	{0x2F7E, 0x00A1},
+	{0x2F80, 0x00A4},
+	{0x2F82, 0x07FF},
+	{0x2F84, 0x0042},
+	{0x2F86, 0x0048},
+	{0x2F88, 0x00A0},
+	{0x2F8A, 0x0106},
+	{0x2F8C, 0x01FD},
+	{0x2F8E, 0x07FF},
+	{0x2F90, 0x0042},
+	{0x2F92, 0x0048},
+	{0x2F94, 0x00A0},
+	{0x2F96, 0x0106},
+	{0x2F98, 0x01FD},
+	{0x2F9A, 0x07FF},
+	{0x2F9C, 0x0042},
+	{0x2F9E, 0x004C},
+	{0x2FA0, 0x005A},
+	{0x2FA2, 0x00A0},
+	{0x2FA4, 0x00A3},
+	{0x2FA6, 0x07FF},
+	{0x2FA8, 0x1014},
+	{0x2FAA, 0x0001},
+	{0x2FAC, 0x1007},
+	{0x2FAE, 0x0015},
+	{0x2FB0, 0x000A},
+	{0x2FB2, 0x1013},
+	{0x2FB4, 0x1002},
+	{0x2FB6, 0x0009},
+	{0x2FB8, 0x000E},
+	{0x2FBA, 0x0004},
+	{0x2FBC, 0x1013},
+	{0x2FBE, 0x1002},
+	{0x2FC0, 0x0009},
+	{0x2FC2, 0x000E},
+	{0x2FC4, 0x0004},
+	{0x2FC6, 0x1009},
+	{0x2FC8, 0x1009},
+	{0x2FCA, 0x1001},
+	{0x2FCC, 0x1027},
+	{0x2FCE, 0x000E},
+	{0x2FD0, 0x805A},
+	{0x2FD2, 0x8115},
+	{0x2FD4, 0x0025},
+	{0x2FD6, 0x8AA4},
+	{0x2FD8, 0x8637},
+	{0x2FDA, 0x0000},
+	{0x2FDC, 0x8035},
+	{0x2FDE, 0x8173},
+	{0x2FE0, 0x8535},
+	{0x2FE2, 0x8909},
+	{0x2FE4, 0x0816},
+	{0x2FE6, 0x0000},
+	{0x2FE8, 0x8035},
+	{0x2FEA, 0x8173},
+	{0x2FEC, 0x8535},
+	{0x2FEE, 0x8909},
+	{0x2FF0, 0x0816},
+	{0x2FF2, 0x0000},
+	{0x2FF4, 0x808F},
+	{0x2FF6, 0x803E},
+	{0x2FF8, 0x81F9},
+	{0x2FFA, 0x0C68},
+	{0x2FFC, 0x885A},
+	{0x2FFE, 0x0000},
+	{0x0266, 0x0001},
+	{0x0268, 0x00EB},
+	{0x026A, 0xFFFF},
+	{0x026C, 0x00FF},
+	{0x026E, 0x0000},
+	{0x0360, 0x9E8E},
+	{0x0384, 0x0004},
+	{0x0386, 0x0233},
+	{0x0388, 0x7133},
+	{0x038A, 0x02CD},
+	{0x038C, 0x4ECD},
+	{0x038E, 0x0041},
+	{0x0390, 0x0200},
+	{0x0392, 0x012C},
+	{0x0414, 0x0220},
+	{0x0450, 0x0032},
+	{0x0452, 0x0040},
+	{0x0600, 0x1130},
+	{0x0602, 0x3012},
+	{0x0604, 0x8048},
+	{0x060E, 0x0000},
+	{0x065E, 0x07FF},
+	{0x0660, 0x0002},
+	{0x0686, 0x0240},
+	{0x0688, 0x00CA},
+	{0x068A, 0x0041},
+	{0x06AA, 0x00FF},
+	{0x0F06, 0x0002},
+	{0x0A02, 0x0084},
+	{0x0A04, 0x0094},
+	{0x0A06, 0x8181},
+	{0x0A08, 0x888F},
+	{0x0A0A, 0xA664},
+	{0x0A0C, 0xF051},
+	{0x0A0E, 0xEC00},
+	{0x0A12, 0x0000},
+	{0x0A16, 0xCCCC},
+	{0x0A18, 0x0008},
+	{0x0A1A, 0x7E34},
+	{0x0A1E, 0x018F},
+	{0x0C00, 0x0021},
+	{0x0C16, 0x0002},
+	{0x0708, 0x6FC0},
+	{0x070C, 0x0000},
+	{0x0780, 0x010F},
+	{0x1218, 0x7026},
+	{0x1034, 0x0600},
+	{0x1036, 0x0208},
+	{0x105A, 0x0001},
+	{0x027E, 0x0100},
+
+	{HI1339_TABLE_END, 0x00}
+
+};
+
+static const struct hi1339_reg mipi_data_rate_1440mbps[] = {
+
+	{HI1339_STRAEMING_REG, 0x0000},
+	{0x0790, 0x0100},
+	{0x2000, 0x0000},
+	{0x2002, 0x0058},
+	{0x2006, 0x40B2},
+	{0x2008, 0xB074},
+	{0x200A, 0x84BC},
+	{0x200C, 0x40B2},
+	{0x200E, 0xB0AE},
+	{0x2010, 0x84BA},
+	{0x2012, 0x40B2},
+	{0x2014, 0xB0FE},
+	{0x2016, 0x84CA},
+	{0x2018, 0x40B2},
+	{0x201A, 0xB108},
+	{0x201C, 0x8476},
+	{0x201E, 0x40B2},
+	{0x2020, 0xB126},
+	{0x2022, 0x843A},
+	{0x2024, 0x40B2},
+	{0x2026, 0xB12C},
+	{0x2028, 0x8450},
+	{0x202A, 0x40B2},
+	{0x202C, 0xB166},
+	{0x202E, 0x848C},
+	{0x2030, 0x40B2},
+	{0x2032, 0xB1D6},
+	{0x2034, 0x8464},
+	{0x2036, 0x40B2},
+	{0x2038, 0xB1E0},
+	{0x203A, 0x847C},
+	{0x203C, 0x40B2},
+	{0x203E, 0xB37A},
+	{0x2040, 0x8490},
+	{0x2042, 0x40B2},
+	{0x2044, 0xB7E8},
+	{0x2046, 0x8488},
+	{0x2048, 0x40B2},
+	{0x204A, 0xB8B8},
+	{0x204C, 0x8478},
+	{0x204E, 0x40B2},
+	{0x2050, 0xB97E},
+	{0x2052, 0x8460},
+	{0x2054, 0x40B2},
+	{0x2056, 0xB9CA},
+	{0x2058, 0x8446},
+	{0x205A, 0x40B2},
+	{0x205C, 0xBA1E},
+	{0x205E, 0x8452},
+	{0x2060, 0x40B2},
+	{0x2062, 0xBA28},
+	{0x2064, 0x848A},
+	{0x2066, 0x40B2},
+	{0x2068, 0xBA56},
+	{0x206A, 0x8486},
+	{0x206C, 0x40B2},
+	{0x206E, 0xBB3A},
+	{0x2070, 0x8436},
+	{0x2072, 0x4130},
+	{0x2074, 0x120B},
+	{0x2076, 0x120A},
+	{0x2078, 0x1209},
+	{0x207A, 0x40B2},
+	{0x207C, 0x0700},
+	{0x207E, 0x8636},
+	{0x2080, 0x4309},
+	{0x2082, 0x403B},
+	{0x2084, 0x84C2},
+	{0x2086, 0x12AB},
+	{0x2088, 0x4F4A},
+	{0x208A, 0x12AB},
+	{0x208C, 0x4F4E},
+	{0x208E, 0x108E},
+	{0x2090, 0xDA0E},
+	{0x2092, 0x930E},
+	{0x2094, 0x2404},
+	{0x2096, 0x490F},
+	{0x2098, 0x5F0F},
+	{0x209A, 0x4E8F},
+	{0x209C, 0x0940},
+	{0x209E, 0x5319},
+	{0x20A0, 0x9039},
+	{0x20A2, 0x001C},
+	{0x20A4, 0x2BEE},
+	{0x20A6, 0x4139},
+	{0x20A8, 0x413A},
+	{0x20AA, 0x413B},
+	{0x20AC, 0x4130},
+	{0x20AE, 0x120B},
+	{0x20B0, 0x120A},
+	{0x20B2, 0x1209},
+	{0x20B4, 0xB3D2},
+	{0x20B6, 0x0363},
+	{0x20B8, 0x241E},
+	{0x20BA, 0x0905},
+	{0x20BC, 0x0851},
+	{0x20BE, 0x40B2},
+	{0x20C0, 0x0700},
+	{0x20C2, 0x8636},
+	{0x20C4, 0x4309},
+	{0x20C6, 0x490F},
+	{0x20C8, 0x5F0F},
+	{0x20CA, 0x4F1F},
+	{0x20CC, 0x0940},
+	{0x20CE, 0x4F0E},
+	{0x20D0, 0xF37E},
+	{0x20D2, 0xF03F},
+	{0x20D4, 0xFF00},
+	{0x20D6, 0x108F},
+	{0x20D8, 0x4F4A},
+	{0x20DA, 0x934A},
+	{0x20DC, 0x3402},
+	{0x20DE, 0x430E},
+	{0x20E0, 0x430A},
+	{0x20E2, 0x403B},
+	{0x20E4, 0x84C6},
+	{0x20E6, 0x4E4F},
+	{0x20E8, 0x12AB},
+	{0x20EA, 0x4A4F},
+	{0x20EC, 0x12AB},
+	{0x20EE, 0x5319},
+	{0x20F0, 0x9039},
+	{0x20F2, 0x001C},
+	{0x20F4, 0x2BE8},
+	{0x20F6, 0x4139},
+	{0x20F8, 0x413A},
+	{0x20FA, 0x413B},
+	{0x20FC, 0x4130},
+	{0x20FE, 0x12B0},
+	{0x2100, 0xB0AE},
+	{0x2102, 0x1292},
+	{0x2104, 0xD09A},
+	{0x2106, 0x4130},
+	{0x2108, 0x120B},
+	{0x210A, 0x421B},
+	{0x210C, 0x0384},
+	{0x210E, 0x1292},
+	{0x2110, 0xD046},
+	{0x2112, 0x8B82},
+	{0x2114, 0x7A04},
+	{0x2116, 0x8B82},
+	{0x2118, 0x7A06},
+	{0x211A, 0x8B82},
+	{0x211C, 0x7A08},
+	{0x211E, 0x8B82},
+	{0x2120, 0x7A0A},
+	{0x2122, 0x413B},
+	{0x2124, 0x4130},
+	{0x2126, 0x1292},
+	{0x2128, 0xD00A},
+	{0x212A, 0x4130},
+	{0x212C, 0x120B},
+	{0x212E, 0x120A},
+	{0x2130, 0x430A},
+	{0x2132, 0x403B},
+	{0x2134, 0x8230},
+	{0x2136, 0xB3D2},
+	{0x2138, 0x0267},
+	{0x213A, 0x2401},
+	{0x213C, 0x431A},
+	{0x213E, 0x1292},
+	{0x2140, 0xD020},
+	{0x2142, 0x931A},
+	{0x2144, 0x2403},
+	{0x2146, 0xB2F2},
+	{0x2148, 0x0381},
+	{0x214A, 0x240A},
+	{0x214C, 0x430F},
+	{0x214E, 0xE39B},
+	{0x2150, 0x0000},
+	{0x2152, 0x532B},
+	{0x2154, 0x531F},
+	{0x2156, 0x903F},
+	{0x2158, 0x0100},
+	{0x215A, 0x2BF9},
+	{0x215C, 0xC2F2},
+	{0x215E, 0x0381},
+	{0x2160, 0x413A},
+	{0x2162, 0x413B},
+	{0x2164, 0x4130},
+	{0x2166, 0x120B},
+	{0x2168, 0x120A},
+	{0x216A, 0x1209},
+	{0x216C, 0x403B},
+	{0x216E, 0x84D0},
+	{0x2170, 0x4219},
+	{0x2172, 0x0A00},
+	{0x2174, 0xB2F2},
+	{0x2176, 0x0361},
+	{0x2178, 0x241A},
+	{0x217A, 0x430A},
+	{0x217C, 0x4A0F},
+	{0x217E, 0x5F0F},
+	{0x2180, 0x4F1E},
+	{0x2182, 0x06BC},
+	{0x2184, 0x930E},
+	{0x2186, 0x3410},
+	{0x2188, 0xF03E},
+	{0x218A, 0x7FFF},
+	{0x218C, 0xE33E},
+	{0x218E, 0x531E},
+	{0x2190, 0x490F},
+	{0x2192, 0x1292},
+	{0x2194, 0x8480},
+	{0x2196, 0x4E8B},
+	{0x2198, 0x0004},
+	{0x219A, 0x4F8B},
+	{0x219C, 0x0006},
+	{0x219E, 0x523B},
+	{0x21A0, 0x531A},
+	{0x21A2, 0x922A},
+	{0x21A4, 0x2BEB},
+	{0x21A6, 0x3C13},
+	{0x21A8, 0xF03E},
+	{0x21AA, 0x7FFF},
+	{0x21AC, 0x3FF1},
+	{0x21AE, 0x438B},
+	{0x21B0, 0x0004},
+	{0x21B2, 0x438B},
+	{0x21B4, 0x0006},
+	{0x21B6, 0x438B},
+	{0x21B8, 0x000C},
+	{0x21BA, 0x438B},
+	{0x21BC, 0x000E},
+	{0x21BE, 0x438B},
+	{0x21C0, 0x0014},
+	{0x21C2, 0x438B},
+	{0x21C4, 0x0016},
+	{0x21C6, 0x438B},
+	{0x21C8, 0x001C},
+	{0x21CA, 0x438B},
+	{0x21CC, 0x001E},
+	{0x21CE, 0x4139},
+	{0x21D0, 0x413A},
+	{0x21D2, 0x413B},
+	{0x21D4, 0x4130},
+	{0x21D6, 0x1292},
+	{0x21D8, 0xD034},
+	{0x21DA, 0xD3D2},
+	{0x21DC, 0x7501},
+	{0x21DE, 0x4130},
+	{0x21E0, 0x120B},
+	{0x21E2, 0x120A},
+	{0x21E4, 0x1209},
+	{0x21E6, 0x1208},
+	{0x21E8, 0x1207},
+	{0x21EA, 0x1206},
+	{0x21EC, 0x8231},
+	{0x21EE, 0x93E2},
+	{0x21F0, 0x0241},
+	{0x21F2, 0x24B5},
+	{0x21F4, 0x4036},
+	{0x21F6, 0x0292},
+	{0x21F8, 0x462F},
+	{0x21FA, 0x4FC2},
+	{0x21FC, 0x0A01},
+	{0x21FE, 0xB2E2},
+	{0x2200, 0x0361},
+	{0x2202, 0x2405},
+	{0x2204, 0x462F},
+	{0x2206, 0x1292},
+	{0x2208, 0x8474},
+	{0x220A, 0x4F82},
+	{0x220C, 0x0A1C},
+	{0x220E, 0x4307},
+	{0x2210, 0x470F},
+	{0x2212, 0x5F0F},
+	{0x2214, 0x4F0E},
+	{0x2216, 0x510E},
+	{0x2218, 0x560F},
+	{0x221A, 0x4F9E},
+	{0x221C, 0x0002},
+	{0x221E, 0x0000},
+	{0x2220, 0x5317},
+	{0x2222, 0x9227},
+	{0x2224, 0x2BF5},
+	{0x2226, 0x93C2},
+	{0x2228, 0x0360},
+	{0x222A, 0x3430},
+	{0x222C, 0x4628},
+	{0x222E, 0xC312},
+	{0x2230, 0x1008},
+	{0x2232, 0x1108},
+	{0x2234, 0x1108},
+	{0x2236, 0x9038},
+	{0x2238, 0x0020},
+	{0x223A, 0x2802},
+	{0x223C, 0x4038},
+	{0x223E, 0x001F},
+	{0x2240, 0x4307},
+	{0x2242, 0x470E},
+	{0x2244, 0x5E0E},
+	{0x2246, 0x4E09},
+	{0x2248, 0x5609},
+	{0x224A, 0x491A},
+	{0x224C, 0x0002},
+	{0x224E, 0x430B},
+	{0x2250, 0x4E0F},
+	{0x2252, 0x5F0F},
+	{0x2254, 0x5F0F},
+	{0x2256, 0x5F0F},
+	{0x2258, 0x5F0F},
+	{0x225A, 0x580F},
+	{0x225C, 0x5F0F},
+	{0x225E, 0x4F1E},
+	{0x2260, 0xBE78},
+	{0x2262, 0x430F},
+	{0x2264, 0x4E0C},
+	{0x2266, 0x4F0D},
+	{0x2268, 0x1202},
+	{0x226A, 0xC232},
+	{0x226C, 0x12B0},
+	{0x226E, 0xFFC0},
+	{0x2270, 0x4132},
+	{0x2272, 0x108E},
+	{0x2274, 0x108F},
+	{0x2276, 0xEF4E},
+	{0x2278, 0xEF0E},
+	{0x227A, 0xF37F},
+	{0x227C, 0xC312},
+	{0x227E, 0x100F},
+	{0x2280, 0x100E},
+	{0x2282, 0x4E89},
+	{0x2284, 0x0002},
+	{0x2286, 0x5317},
+	{0x2288, 0x9227},
+	{0x228A, 0x2BDB},
+	{0x228C, 0x461A},
+	{0x228E, 0x0002},
+	{0x2290, 0x430B},
+	{0x2292, 0x403C},
+	{0x2294, 0x4029},
+	{0x2296, 0x430D},
+	{0x2298, 0x1202},
+	{0x229A, 0xC232},
+	{0x229C, 0x12B0},
+	{0x229E, 0xFFC0},
+	{0x22A0, 0x4132},
+	{0x22A2, 0x108E},
+	{0x22A4, 0x108F},
+	{0x22A6, 0xEF4E},
+	{0x22A8, 0xEF0E},
+	{0x22AA, 0xF37F},
+	{0x22AC, 0xC312},
+	{0x22AE, 0x100F},
+	{0x22B0, 0x100E},
+	{0x22B2, 0x110F},
+	{0x22B4, 0x100E},
+	{0x22B6, 0x110F},
+	{0x22B8, 0x100E},
+	{0x22BA, 0x110F},
+	{0x22BC, 0x100E},
+	{0x22BE, 0x110F},
+	{0x22C0, 0x100E},
+	{0x22C2, 0x110F},
+	{0x22C4, 0x100E},
+	{0x22C6, 0x4E86},
+	{0x22C8, 0x0002},
+	{0x22CA, 0x460F},
+	{0x22CC, 0x532F},
+	{0x22CE, 0x422D},
+	{0x22D0, 0x4F0E},
+	{0x22D2, 0x403F},
+	{0x22D4, 0x0E08},
+	{0x22D6, 0x1292},
+	{0x22D8, 0x843E},
+	{0x22DA, 0x93C2},
+	{0x22DC, 0x0360},
+	{0x22DE, 0x340B},
+	{0x22E0, 0x4307},
+	{0x22E2, 0x470F},
+	{0x22E4, 0x5F0F},
+	{0x22E6, 0x4F0E},
+	{0x22E8, 0x560E},
+	{0x22EA, 0x510F},
+	{0x22EC, 0x4FAE},
+	{0x22EE, 0x0002},
+	{0x22F0, 0x5317},
+	{0x22F2, 0x9227},
+	{0x22F4, 0x2BF6},
+	{0x22F6, 0x403D},
+	{0x22F8, 0x0005},
+	{0x22FA, 0x403E},
+	{0x22FC, 0x0292},
+	{0x22FE, 0x403F},
+	{0x2300, 0x8534},
+	{0x2302, 0x1292},
+	{0x2304, 0x843E},
+	{0x2306, 0x421F},
+	{0x2308, 0x060E},
+	{0x230A, 0x9F82},
+	{0x230C, 0x856E},
+	{0x230E, 0x2824},
+	{0x2310, 0x9382},
+	{0x2312, 0x060E},
+	{0x2314, 0x2421},
+	{0x2316, 0x90B6},
+	{0x2318, 0x0010},
+	{0x231A, 0x0000},
+	{0x231C, 0x2C0B},
+	{0x231E, 0x93C2},
+	{0x2320, 0x853E},
+	{0x2322, 0x2008},
+	{0x2324, 0x403F},
+	{0x2326, 0x0685},
+	{0x2328, 0xD0FF},
+	{0x232A, 0x0007},
+	{0x232C, 0x0000},
+	{0x232E, 0xF0FF},
+	{0x2330, 0xFFF8},
+	{0x2332, 0x0000},
+	{0x2334, 0x4392},
+	{0x2336, 0x856E},
+	{0x2338, 0x403F},
+	{0x233A, 0x0685},
+	{0x233C, 0xD2EF},
+	{0x233E, 0x0000},
+	{0x2340, 0xC2EF},
+	{0x2342, 0x0000},
+	{0x2344, 0xB0F2},
+	{0x2346, 0x0040},
+	{0x2348, 0x0B05},
+	{0x234A, 0x2403},
+	{0x234C, 0xD3D2},
+	{0x234E, 0x0420},
+	{0x2350, 0x3C0C},
+	{0x2352, 0xC3D2},
+	{0x2354, 0x0420},
+	{0x2356, 0x3C09},
+	{0x2358, 0x5392},
+	{0x235A, 0x856E},
+	{0x235C, 0x3FED},
+	{0x235E, 0x93C2},
+	{0x2360, 0x853E},
+	{0x2362, 0x2348},
+	{0x2364, 0x4036},
+	{0x2366, 0x8534},
+	{0x2368, 0x3F47},
+	{0x236A, 0x5231},
+	{0x236C, 0x4136},
+	{0x236E, 0x4137},
+	{0x2370, 0x4138},
+	{0x2372, 0x4139},
+	{0x2374, 0x413A},
+	{0x2376, 0x413B},
+	{0x2378, 0x4130},
+	{0x237A, 0x120B},
+	{0x237C, 0x120A},
+	{0x237E, 0x1209},
+	{0x2380, 0x1208},
+	{0x2382, 0x1207},
+	{0x2384, 0x1206},
+	{0x2386, 0x1205},
+	{0x2388, 0x1204},
+	{0x238A, 0x8031},
+	{0x238C, 0x0036},
+	{0x238E, 0x4381},
+	{0x2390, 0x002C},
+	{0x2392, 0x4381},
+	{0x2394, 0x002E},
+	{0x2396, 0x421F},
+	{0x2398, 0x0386},
+	{0x239A, 0xF03F},
+	{0x239C, 0x07FF},
+	{0x239E, 0x4F81},
+	{0x23A0, 0x0022},
+	{0x23A2, 0x4291},
+	{0x23A4, 0x0388},
+	{0x23A6, 0x0024},
+	{0x23A8, 0x421F},
+	{0x23AA, 0x038A},
+	{0x23AC, 0xF03F},
+	{0x23AE, 0x07FF},
+	{0x23B0, 0x4F81},
+	{0x23B2, 0x0026},
+	{0x23B4, 0x4291},
+	{0x23B6, 0x038C},
+	{0x23B8, 0x0028},
+	{0x23BA, 0x93E2},
+	{0x23BC, 0x0241},
+	{0x23BE, 0x2002},
+	{0x23C0, 0x4030},
+	{0x23C2, 0xB7BE},
+	{0x23C4, 0x40B1},
+	{0x23C6, 0x0292},
+	{0x23C8, 0x002A},
+	{0x23CA, 0x1292},
+	{0x23CC, 0xD060},
+	{0x23CE, 0x421E},
+	{0x23D0, 0x0698},
+	{0x23D2, 0x421F},
+	{0x23D4, 0x069A},
+	{0x23D6, 0x5E0E},
+	{0x23D8, 0x6F0F},
+	{0x23DA, 0x421A},
+	{0x23DC, 0x0694},
+	{0x23DE, 0x421B},
+	{0x23E0, 0x0696},
+	{0x23E2, 0x4E0C},
+	{0x23E4, 0x4F0D},
+	{0x23E6, 0x4A0E},
+	{0x23E8, 0x4B0F},
+	{0x23EA, 0x1292},
+	{0x23EC, 0x8458},
+	{0x23EE, 0x4C82},
+	{0x23F0, 0x8570},
+	{0x23F2, 0x430B},
+	{0x23F4, 0x421F},
+	{0x23F6, 0x038E},
+	{0x23F8, 0x9F0C},
+	{0x23FA, 0x2C01},
+	{0x23FC, 0x431B},
+	{0x23FE, 0x930B},
+	{0x2400, 0x25DB},
+	{0x2402, 0xD3E2},
+	{0x2404, 0x0380},
+	{0x2406, 0x93C2},
+	{0x2408, 0x853E},
+	{0x240A, 0x21E3},
+	{0x240C, 0xB0F2},
+	{0x240E, 0x0010},
+	{0x2410, 0x0381},
+	{0x2412, 0x25DF},
+	{0x2414, 0x4381},
+	{0x2416, 0x0020},
+	{0x2418, 0x4118},
+	{0x241A, 0x0020},
+	{0x241C, 0x5808},
+	{0x241E, 0x480B},
+	{0x2420, 0x510B},
+	{0x2422, 0x411F},
+	{0x2424, 0x002A},
+	{0x2426, 0x580F},
+	{0x2428, 0x4F9B},
+	{0x242A, 0x0002},
+	{0x242C, 0x0018},
+	{0x242E, 0x480A},
+	{0x2430, 0x5A0A},
+	{0x2432, 0x4A1E},
+	{0x2434, 0x0650},
+	{0x2436, 0x4A1F},
+	{0x2438, 0x0652},
+	{0x243A, 0x4E81},
+	{0x243C, 0x002E},
+	{0x243E, 0x4381},
+	{0x2440, 0x002C},
+	{0x2442, 0x4A1E},
+	{0x2444, 0x064E},
+	{0x2446, 0x4A1F},
+	{0x2448, 0x0650},
+	{0x244A, 0xD11E},
+	{0x244C, 0x002C},
+	{0x244E, 0xD11F},
+	{0x2450, 0x002E},
+	{0x2452, 0x4E0C},
+	{0x2454, 0x4F0D},
+	{0x2456, 0x108C},
+	{0x2458, 0x108D},
+	{0x245A, 0xED4C},
+	{0x245C, 0xED0C},
+	{0x245E, 0xF37D},
+	{0x2460, 0xC312},
+	{0x2462, 0x100D},
+	{0x2464, 0x100C},
+	{0x2466, 0x110D},
+	{0x2468, 0x100C},
+	{0x246A, 0x110D},
+	{0x246C, 0x100C},
+	{0x246E, 0x110D},
+	{0x2470, 0x100C},
+	{0x2472, 0x110D},
+	{0x2474, 0x100C},
+	{0x2476, 0x110D},
+	{0x2478, 0x100C},
+	{0x247A, 0x110D},
+	{0x247C, 0x100C},
+	{0x247E, 0x4C8B},
+	{0x2480, 0x0000},
+	{0x2482, 0x4A0B},
+	{0x2484, 0x510B},
+	{0x2486, 0xC312},
+	{0x2488, 0x100F},
+	{0x248A, 0x100E},
+	{0x248C, 0x110F},
+	{0x248E, 0x100E},
+	{0x2490, 0x110F},
+	{0x2492, 0x100E},
+	{0x2494, 0x110F},
+	{0x2496, 0x100E},
+	{0x2498, 0x530E},
+	{0x249A, 0x603F},
+	{0x249C, 0xFFFE},
+	{0x249E, 0x4E8B},
+	{0x24A0, 0x0008},
+	{0x24A2, 0x4F8B},
+	{0x24A4, 0x000A},
+	{0x24A6, 0x4A0E},
+	{0x24A8, 0x5E0E},
+	{0x24AA, 0x5A0E},
+	{0x24AC, 0x4E0F},
+	{0x24AE, 0x503F},
+	{0x24B0, 0xBF78},
+	{0x24B2, 0x9F1C},
+	{0x24B4, 0x000A},
+	{0x24B6, 0x2913},
+	{0x24B8, 0x4304},
+	{0x24BA, 0x4309},
+	{0x24BC, 0x4305},
+	{0x24BE, 0x4E1E},
+	{0x24C0, 0xBFDA},
+	{0x24C2, 0x903E},
+	{0x24C4, 0x8001},
+	{0x24C6, 0x2801},
+	{0x24C8, 0x4315},
+	{0x24CA, 0x4E06},
+	{0x24CC, 0xF036},
+	{0x24CE, 0x7FFF},
+	{0x24D0, 0x490C},
+	{0x24D2, 0x430D},
+	{0x24D4, 0x4807},
+	{0x24D6, 0x5707},
+	{0x24D8, 0x470F},
+	{0x24DA, 0x510F},
+	{0x24DC, 0x4F1E},
+	{0x24DE, 0x0008},
+	{0x24E0, 0x4F1F},
+	{0x24E2, 0x000A},
+	{0x24E4, 0xC312},
+	{0x24E6, 0x100F},
+	{0x24E8, 0x100E},
+	{0x24EA, 0x110F},
+	{0x24EC, 0x100E},
+	{0x24EE, 0x110F},
+	{0x24F0, 0x100E},
+	{0x24F2, 0x110F},
+	{0x24F4, 0x100E},
+	{0x24F6, 0x110F},
+	{0x24F8, 0x100E},
+	{0x24FA, 0x110F},
+	{0x24FC, 0x100E},
+	{0x24FE, 0x4C0A},
+	{0x2500, 0x4D0B},
+	{0x2502, 0x4E0C},
+	{0x2504, 0x4F0D},
+	{0x2506, 0x1202},
+	{0x2508, 0xC232},
+	{0x250A, 0x12B0},
+	{0x250C, 0xFFC0},
+	{0x250E, 0x4132},
+	{0x2510, 0x4E0C},
+	{0x2512, 0x4F0D},
+	{0x2514, 0x930D},
+	{0x2516, 0x38DF},
+	{0x2518, 0x4E0C},
+	{0x251A, 0x4F0D},
+	{0x251C, 0x110D},
+	{0x251E, 0x100C},
+	{0x2520, 0x110D},
+	{0x2522, 0x100C},
+	{0x2524, 0x110D},
+	{0x2526, 0x100C},
+	{0x2528, 0x110D},
+	{0x252A, 0x100C},
+	{0x252C, 0x110D},
+	{0x252E, 0x100C},
+	{0x2530, 0x9304},
+	{0x2532, 0x2404},
+	{0x2534, 0xE33C},
+	{0x2536, 0xE33D},
+	{0x2538, 0x531C},
+	{0x253A, 0x630D},
+	{0x253C, 0x9305},
+	{0x253E, 0x24C6},
+	{0x2540, 0x460E},
+	{0x2542, 0x430F},
+	{0x2544, 0x8E0C},
+	{0x2546, 0x7F0D},
+	{0x2548, 0x4C87},
+	{0x254A, 0x864C},
+	{0x254C, 0x4D87},
+	{0x254E, 0x864E},
+	{0x2550, 0x480F},
+	{0x2552, 0x510F},
+	{0x2554, 0x90BF},
+	{0x2556, 0x0201},
+	{0x2558, 0x0018},
+	{0x255A, 0x2806},
+	{0x255C, 0x480F},
+	{0x255E, 0x5F0F},
+	{0x2560, 0x438F},
+	{0x2562, 0x864C},
+	{0x2564, 0x438F},
+	{0x2566, 0x864E},
+	{0x2568, 0x5391},
+	{0x256A, 0x0020},
+	{0x256C, 0x92A1},
+	{0x256E, 0x0020},
+	{0x2570, 0x2B53},
+	{0x2572, 0x4381},
+	{0x2574, 0x0030},
+	{0x2576, 0x4381},
+	{0x2578, 0x0032},
+	{0x257A, 0x4381},
+	{0x257C, 0x0034},
+	{0x257E, 0x4118},
+	{0x2580, 0x0002},
+	{0x2582, 0x4309},
+	{0x2584, 0x411E},
+	{0x2586, 0x0004},
+	{0x2588, 0x430F},
+	{0x258A, 0x5E08},
+	{0x258C, 0x6F09},
+	{0x258E, 0xE849},
+	{0x2590, 0xE809},
+	{0x2592, 0x1089},
+	{0x2594, 0xF378},
+	{0x2596, 0x1088},
+	{0x2598, 0x5808},
+	{0x259A, 0x6909},
+	{0x259C, 0x4216},
+	{0x259E, 0x8570},
+	{0x25A0, 0x4307},
+	{0x25A2, 0xE647},
+	{0x25A4, 0xE607},
+	{0x25A6, 0x1087},
+	{0x25A8, 0xF376},
+	{0x25AA, 0x1086},
+	{0x25AC, 0x5606},
+	{0x25AE, 0x6707},
+	{0x25B0, 0x5606},
+	{0x25B2, 0x6707},
+	{0x25B4, 0x411E},
+	{0x25B6, 0x0022},
+	{0x25B8, 0x430F},
+	{0x25BA, 0x4E0A},
+	{0x25BC, 0x4F0B},
+	{0x25BE, 0x480C},
+	{0x25C0, 0x490D},
+	{0x25C2, 0x1202},
+	{0x25C4, 0xC232},
+	{0x25C6, 0x12B0},
+	{0x25C8, 0xFFC0},
+	{0x25CA, 0x4132},
+	{0x25CC, 0x4E04},
+	{0x25CE, 0x4F05},
+	{0x25D0, 0x1084},
+	{0x25D2, 0x1085},
+	{0x25D4, 0xE544},
+	{0x25D6, 0xE504},
+	{0x25D8, 0xF375},
+	{0x25DA, 0xC312},
+	{0x25DC, 0x1005},
+	{0x25DE, 0x1004},
+	{0x25E0, 0x1105},
+	{0x25E2, 0x1004},
+	{0x25E4, 0x411E},
+	{0x25E6, 0x0026},
+	{0x25E8, 0x430F},
+	{0x25EA, 0x4E0A},
+	{0x25EC, 0x4F0B},
+	{0x25EE, 0x1202},
+	{0x25F0, 0xC232},
+	{0x25F2, 0x12B0},
+	{0x25F4, 0xFFC0},
+	{0x25F6, 0x4132},
+	{0x25F8, 0x4E0A},
+	{0x25FA, 0x4F0B},
+	{0x25FC, 0x108A},
+	{0x25FE, 0x108B},
+	{0x2600, 0xEB4A},
+	{0x2602, 0xEB0A},
+	{0x2604, 0xF37B},
+	{0x2606, 0xC312},
+	{0x2608, 0x100B},
+	{0x260A, 0x100A},
+	{0x260C, 0x110B},
+	{0x260E, 0x100A},
+	{0x2610, 0x411E},
+	{0x2612, 0x0024},
+	{0x2614, 0x430F},
+	{0x2616, 0x5E04},
+	{0x2618, 0x6F05},
+	{0x261A, 0x411E},
+	{0x261C, 0x0028},
+	{0x261E, 0x430F},
+	{0x2620, 0x5E0A},
+	{0x2622, 0x6F0B},
+	{0x2624, 0x421E},
+	{0x2626, 0x0392},
+	{0x2628, 0x108C},
+	{0x262A, 0x108D},
+	{0x262C, 0xED4C},
+	{0x262E, 0xED0C},
+	{0x2630, 0xF37D},
+	{0x2632, 0xC312},
+	{0x2634, 0x100D},
+	{0x2636, 0x100C},
+	{0x2638, 0xC312},
+	{0x263A, 0x100D},
+	{0x263C, 0x100C},
+	{0x263E, 0x803C},
+	{0x2640, 0x0384},
+	{0x2642, 0x730D},
+	{0x2644, 0x281F},
+	{0x2646, 0x460C},
+	{0x2648, 0x470D},
+	{0x264A, 0x108C},
+	{0x264C, 0x108D},
+	{0x264E, 0xED4C},
+	{0x2650, 0xED0C},
+	{0x2652, 0xF37D},
+	{0x2654, 0xC312},
+	{0x2656, 0x100D},
+	{0x2658, 0x100C},
+	{0x265A, 0x430F},
+	{0x265C, 0xC312},
+	{0x265E, 0x100D},
+	{0x2660, 0x100C},
+	{0x2662, 0x8E0C},
+	{0x2664, 0x7F0D},
+	{0x2666, 0x280E},
+	{0x2668, 0x4391},
+	{0x266A, 0x0030},
+	{0x266C, 0x90B1},
+	{0x266E, 0x0190},
+	{0x2670, 0x0006},
+	{0x2672, 0x2802},
+	{0x2674, 0x4391},
+	{0x2676, 0x0032},
+	{0x2678, 0x90B1},
+	{0x267A, 0x0190},
+	{0x267C, 0x0000},
+	{0x267E, 0x2802},
+	{0x2680, 0x4391},
+	{0x2682, 0x0034},
+	{0x2684, 0x460E},
+	{0x2686, 0x470F},
+	{0x2688, 0x840E},
+	{0x268A, 0x750F},
+	{0x268C, 0x2805},
+	{0x268E, 0x4A0E},
+	{0x2690, 0x4B0F},
+	{0x2692, 0x860E},
+	{0x2694, 0x770F},
+	{0x2696, 0x2C9D},
+	{0x2698, 0x9381},
+	{0x269A, 0x0034},
+	{0x269C, 0x2004},
+	{0x269E, 0x4382},
+	{0x26A0, 0x864C},
+	{0x26A2, 0x4382},
+	{0x26A4, 0x864E},
+	{0x26A6, 0x9381},
+	{0x26A8, 0x0030},
+	{0x26AA, 0x2008},
+	{0x26AC, 0x4382},
+	{0x26AE, 0x8650},
+	{0x26B0, 0x4382},
+	{0x26B2, 0x8652},
+	{0x26B4, 0x4382},
+	{0x26B6, 0x8654},
+	{0x26B8, 0x4382},
+	{0x26BA, 0x8656},
+	{0x26BC, 0x9381},
+	{0x26BE, 0x0032},
+	{0x26C0, 0x2088},
+	{0x26C2, 0x4382},
+	{0x26C4, 0x8658},
+	{0x26C6, 0x4382},
+	{0x26C8, 0x865A},
+	{0x26CA, 0x3C83},
+	{0x26CC, 0x460E},
+	{0x26CE, 0x430F},
+	{0x26D0, 0x5E0C},
+	{0x26D2, 0x6F0D},
+	{0x26D4, 0x3F39},
+	{0x26D6, 0x503E},
+	{0x26D8, 0x001F},
+	{0x26DA, 0x630F},
+	{0x26DC, 0x3F1D},
+	{0x26DE, 0x9F1C},
+	{0x26E0, 0x0008},
+	{0x26E2, 0x2812},
+	{0x26E4, 0x4304},
+	{0x26E6, 0x4A0F},
+	{0x26E8, 0x580F},
+	{0x26EA, 0x580F},
+	{0x26EC, 0x580F},
+	{0x26EE, 0x4F1B},
+	{0x26F0, 0xBFB0},
+	{0x26F2, 0x903B},
+	{0x26F4, 0x1001},
+	{0x26F6, 0x2801},
+	{0x26F8, 0x4314},
+	{0x26FA, 0x4B09},
+	{0x26FC, 0xF039},
+	{0x26FE, 0x0FFF},
+	{0x2700, 0x4305},
+	{0x2702, 0x4E1E},
+	{0x2704, 0xBFD8},
+	{0x2706, 0x3EDD},
+	{0x2708, 0x9F1C},
+	{0x270A, 0x0006},
+	{0x270C, 0x2812},
+	{0x270E, 0x4304},
+	{0x2710, 0x4A0F},
+	{0x2712, 0x580F},
+	{0x2714, 0x580F},
+	{0x2716, 0x580F},
+	{0x2718, 0x4F1B},
+	{0x271A, 0xBFAE},
+	{0x271C, 0x903B},
+	{0x271E, 0x1001},
+	{0x2720, 0x2801},
+	{0x2722, 0x4314},
+	{0x2724, 0x4B09},
+	{0x2726, 0xF039},
+	{0x2728, 0x0FFF},
+	{0x272A, 0x4305},
+	{0x272C, 0x4E1E},
+	{0x272E, 0xBFD6},
+	{0x2730, 0x3EC8},
+	{0x2732, 0x9F1C},
+	{0x2734, 0x0004},
+	{0x2736, 0x2812},
+	{0x2738, 0x4304},
+	{0x273A, 0x4A0F},
+	{0x273C, 0x580F},
+	{0x273E, 0x580F},
+	{0x2740, 0x580F},
+	{0x2742, 0x4F1B},
+	{0x2744, 0xBFAC},
+	{0x2746, 0x903B},
+	{0x2748, 0x1001},
+	{0x274A, 0x2801},
+	{0x274C, 0x4314},
+	{0x274E, 0x4B09},
+	{0x2750, 0xF039},
+	{0x2752, 0x0FFF},
+	{0x2754, 0x4305},
+	{0x2756, 0x4E1E},
+	{0x2758, 0xBFD4},
+	{0x275A, 0x3EB3},
+	{0x275C, 0x9F1C},
+	{0x275E, 0x0002},
+	{0x2760, 0x2812},
+	{0x2762, 0x4304},
+	{0x2764, 0x4A0F},
+	{0x2766, 0x580F},
+	{0x2768, 0x580F},
+	{0x276A, 0x580F},
+	{0x276C, 0x4F1B},
+	{0x276E, 0xBFAA},
+	{0x2770, 0x903B},
+	{0x2772, 0x1001},
+	{0x2774, 0x2801},
+	{0x2776, 0x4314},
+	{0x2778, 0x4B09},
+	{0x277A, 0xF039},
+	{0x277C, 0x0FFF},
+	{0x277E, 0x4305},
+	{0x2780, 0x4E1E},
+	{0x2782, 0xBFD2},
+	{0x2784, 0x3E9E},
+	{0x2786, 0x9F2C},
+	{0x2788, 0x2812},
+	{0x278A, 0x4304},
+	{0x278C, 0x4A0F},
+	{0x278E, 0x580F},
+	{0x2790, 0x580F},
+	{0x2792, 0x580F},
+	{0x2794, 0x4F1B},
+	{0x2796, 0xBFA8},
+	{0x2798, 0x903B},
+	{0x279A, 0x1001},
+	{0x279C, 0x2801},
+	{0x279E, 0x4314},
+	{0x27A0, 0x4B09},
+	{0x27A2, 0xF039},
+	{0x27A4, 0x0FFF},
+	{0x27A6, 0x4305},
+	{0x27A8, 0x4E1E},
+	{0x27AA, 0xBFD0},
+	{0x27AC, 0x3E8A},
+	{0x27AE, 0x438A},
+	{0x27B0, 0x864C},
+	{0x27B2, 0x438A},
+	{0x27B4, 0x864E},
+	{0x27B6, 0x3E8C},
+	{0x27B8, 0xC3E2},
+	{0x27BA, 0x0380},
+	{0x27BC, 0x3E24},
+	{0x27BE, 0x93C2},
+	{0x27C0, 0x853E},
+	{0x27C2, 0x2402},
+	{0x27C4, 0x4030},
+	{0x27C6, 0xB3C4},
+	{0x27C8, 0x40B1},
+	{0x27CA, 0x8534},
+	{0x27CC, 0x002A},
+	{0x27CE, 0x4030},
+	{0x27D0, 0xB3CA},
+	{0x27D2, 0x5031},
+	{0x27D4, 0x0036},
+	{0x27D6, 0x4134},
+	{0x27D8, 0x4135},
+	{0x27DA, 0x4136},
+	{0x27DC, 0x4137},
+	{0x27DE, 0x4138},
+	{0x27E0, 0x4139},
+	{0x27E2, 0x413A},
+	{0x27E4, 0x413B},
+	{0x27E6, 0x4130},
+	{0x27E8, 0x120B},
+	{0x27EA, 0x120A},
+	{0x27EC, 0x1209},
+	{0x27EE, 0x1208},
+	{0x27F0, 0x1207},
+	{0x27F2, 0x1206},
+	{0x27F4, 0x1205},
+	{0x27F6, 0x8031},
+	{0x27F8, 0x0010},
+	{0x27FA, 0x4035},
+	{0x27FC, 0x84D0},
+	{0x27FE, 0x4036},
+	{0x2800, 0x84F0},
+	{0x2802, 0x4291},
+	{0x2804, 0x864C},
+	{0x2806, 0x0000},
+	{0x2808, 0x4291},
+	{0x280A, 0x864E},
+	{0x280C, 0x0002},
+	{0x280E, 0x4291},
+	{0x2810, 0x8650},
+	{0x2812, 0x0004},
+	{0x2814, 0x4291},
+	{0x2816, 0x8652},
+	{0x2818, 0x0006},
+	{0x281A, 0x4291},
+	{0x281C, 0x8654},
+	{0x281E, 0x0008},
+	{0x2820, 0x4291},
+	{0x2822, 0x8656},
+	{0x2824, 0x000A},
+	{0x2826, 0x4291},
+	{0x2828, 0x8658},
+	{0x282A, 0x000C},
+	{0x282C, 0x4291},
+	{0x282E, 0x865A},
+	{0x2830, 0x000E},
+	{0x2832, 0x4307},
+	{0x2834, 0x470B},
+	{0x2836, 0x5B0B},
+	{0x2838, 0x5B0B},
+	{0x283A, 0x4B1E},
+	{0x283C, 0x0650},
+	{0x283E, 0x4B1F},
+	{0x2840, 0x0652},
+	{0x2842, 0x4E09},
+	{0x2844, 0x4308},
+	{0x2846, 0x4B1E},
+	{0x2848, 0x064E},
+	{0x284A, 0x4B1F},
+	{0x284C, 0x0650},
+	{0x284E, 0xD80E},
+	{0x2850, 0xD90F},
+	{0x2852, 0x470A},
+	{0x2854, 0x5A0A},
+	{0x2856, 0x4A1D},
+	{0x2858, 0x0646},
+	{0x285A, 0x1206},
+	{0x285C, 0x450C},
+	{0x285E, 0x1292},
+	{0x2860, 0x8484},
+	{0x2862, 0x4E8B},
+	{0x2864, 0x061A},
+	{0x2866, 0x4F8B},
+	{0x2868, 0x061C},
+	{0x286A, 0x5321},
+	{0x286C, 0x93C2},
+	{0x286E, 0x853E},
+	{0x2870, 0x200B},
+	{0x2872, 0xB0F2},
+	{0x2874, 0x0010},
+	{0x2876, 0x0381},
+	{0x2878, 0x2407},
+	{0x287A, 0x4B0F},
+	{0x287C, 0x510F},
+	{0x287E, 0x5FAB},
+	{0x2880, 0x061A},
+	{0x2882, 0x6F9B},
+	{0x2884, 0x0002},
+	{0x2886, 0x061C},
+	{0x2888, 0xB0F2},
+	{0x288A, 0x0010},
+	{0x288C, 0x0603},
+	{0x288E, 0x2005},
+	{0x2890, 0x4A0D},
+	{0x2892, 0x5D0D},
+	{0x2894, 0xF0BD},
+	{0x2896, 0xF800},
+	{0x2898, 0x061A},
+	{0x289A, 0x5317},
+	{0x289C, 0x5235},
+	{0x289E, 0x5226},
+	{0x28A0, 0x9227},
+	{0x28A2, 0x2BC8},
+	{0x28A4, 0x5031},
+	{0x28A6, 0x0010},
+	{0x28A8, 0x4135},
+	{0x28AA, 0x4136},
+	{0x28AC, 0x4137},
+	{0x28AE, 0x4138},
+	{0x28B0, 0x4139},
+	{0x28B2, 0x413A},
+	{0x28B4, 0x413B},
+	{0x28B6, 0x4130},
+	{0x28B8, 0x120B},
+	{0x28BA, 0x430B},
+	{0x28BC, 0x425F},
+	{0x28BE, 0x0204},
+	{0x28C0, 0xF07F},
+	{0x28C2, 0x0003},
+	{0x28C4, 0x936F},
+	{0x28C6, 0x2801},
+	{0x28C8, 0x431B},
+	{0x28CA, 0x1292},
+	{0x28CC, 0xD048},
+	{0x28CE, 0xB0F2},
+	{0x28D0, 0x0040},
+	{0x28D2, 0x0381},
+	{0x28D4, 0x2450},
+	{0x28D6, 0x421E},
+	{0x28D8, 0x0206},
+	{0x28DA, 0xC312},
+	{0x28DC, 0x100E},
+	{0x28DE, 0x40F2},
+	{0x28E0, 0x0005},
+	{0x28E2, 0x0321},
+	{0x28E4, 0x43C2},
+	{0x28E6, 0x0320},
+	{0x28E8, 0x40F2},
+	{0x28EA, 0x0015},
+	{0x28EC, 0x0323},
+	{0x28EE, 0x40F2},
+	{0x28F0, 0x0016},
+	{0x28F2, 0x0325},
+	{0x28F4, 0x40B2},
+	{0x28F6, 0x0011},
+	{0x28F8, 0x0326},
+	{0x28FA, 0x4E0F},
+	{0x28FC, 0x503F},
+	{0x28FE, 0x0011},
+	{0x2900, 0x4F82},
+	{0x2902, 0x032A},
+	{0x2904, 0x40B2},
+	{0x2906, 0x0011},
+	{0x2908, 0x0346},
+	{0x290A, 0x4F82},
+	{0x290C, 0x034A},
+	{0x290E, 0x90B2},
+	{0x2910, 0x0018},
+	{0x2912, 0x0A00},
+	{0x2914, 0x2C1E},
+	{0x2916, 0x930B},
+	{0x2918, 0x240E},
+	{0x291A, 0x40B2},
+	{0x291C, 0x0019},
+	{0x291E, 0x0328},
+	{0x2920, 0x523F},
+	{0x2922, 0x4F82},
+	{0x2924, 0x032C},
+	{0x2926, 0x40B2},
+	{0x2928, 0x001A},
+	{0x292A, 0x0348},
+	{0x292C, 0x503E},
+	{0x292E, 0x001A},
+	{0x2930, 0x4E82},
+	{0x2932, 0x034C},
+	{0x2934, 0x3C22},
+	{0x2936, 0x40B2},
+	{0x2938, 0x0021},
+	{0x293A, 0x0328},
+	{0x293C, 0x4E0F},
+	{0x293E, 0x503F},
+	{0x2940, 0x0021},
+	{0x2942, 0x4F82},
+	{0x2944, 0x032C},
+	{0x2946, 0x40B2},
+	{0x2948, 0x0022},
+	{0x294A, 0x0348},
+	{0x294C, 0x503E},
+	{0x294E, 0x0022},
+	{0x2950, 0x3FEF},
+	{0x2952, 0x90B2},
+	{0x2954, 0x0030},
+	{0x2956, 0x0A00},
+	{0x2958, 0x2BEE},
+	{0x295A, 0x40B2},
+	{0x295C, 0x003F},
+	{0x295E, 0x0328},
+	{0x2960, 0x4E0F},
+	{0x2962, 0x503F},
+	{0x2964, 0x003F},
+	{0x2966, 0x4F82},
+	{0x2968, 0x032C},
+	{0x296A, 0x40B2},
+	{0x296C, 0x0040},
+	{0x296E, 0x0348},
+	{0x2970, 0x503E},
+	{0x2972, 0x0040},
+	{0x2974, 0x3FDD},
+	{0x2976, 0x43C2},
+	{0x2978, 0x0321},
+	{0x297A, 0x413B},
+	{0x297C, 0x4130},
+	{0x297E, 0x42D2},
+	{0x2980, 0x0B02},
+	{0x2982, 0x8664},
+	{0x2984, 0x403E},
+	{0x2986, 0x1200},
+	{0x2988, 0x4E6F},
+	{0x298A, 0xC312},
+	{0x298C, 0x104F},
+	{0x298E, 0x114F},
+	{0x2990, 0x4F0D},
+	{0x2992, 0xF31D},
+	{0x2994, 0x4D82},
+	{0x2996, 0x865C},
+	{0x2998, 0x4E6F},
+	{0x299A, 0xC312},
+	{0x299C, 0x104F},
+	{0x299E, 0x114F},
+	{0x29A0, 0x114F},
+	{0x29A2, 0x4F0D},
+	{0x29A4, 0xF31D},
+	{0x29A6, 0x4D82},
+	{0x29A8, 0x865E},
+	{0x29AA, 0x4E6F},
+	{0x29AC, 0xC312},
+	{0x29AE, 0x104F},
+	{0x29B0, 0x4F0D},
+	{0x29B2, 0xF31D},
+	{0x29B4, 0x4D82},
+	{0x29B6, 0x8660},
+	{0x29B8, 0x4E6F},
+	{0x29BA, 0xF35F},
+	{0x29BC, 0x4F0E},
+	{0x29BE, 0xF31E},
+	{0x29C0, 0x4E82},
+	{0x29C2, 0x8662},
+	{0x29C4, 0x1292},
+	{0x29C6, 0xD030},
+	{0x29C8, 0x4130},
+	{0x29CA, 0x93C2},
+	{0x29CC, 0x0263},
+	{0x29CE, 0x2403},
+	{0x29D0, 0x42D2},
+	{0x29D2, 0x8664},
+	{0x29D4, 0x0B02},
+	{0x29D6, 0x9392},
+	{0x29D8, 0x865C},
+	{0x29DA, 0x241B},
+	{0x29DC, 0xC2E2},
+	{0x29DE, 0x1200},
+	{0x29E0, 0x9392},
+	{0x29E2, 0x865E},
+	{0x29E4, 0x2413},
+	{0x29E6, 0xC2F2},
+	{0x29E8, 0x1200},
+	{0x29EA, 0x9392},
+	{0x29EC, 0x8660},
+	{0x29EE, 0x240B},
+	{0x29F0, 0xC3E2},
+	{0x29F2, 0x1200},
+	{0x29F4, 0x9392},
+	{0x29F6, 0x8662},
+	{0x29F8, 0x2403},
+	{0x29FA, 0xC3D2},
+	{0x29FC, 0x1200},
+	{0x29FE, 0x3C0C},
+	{0x2A00, 0xD3D2},
+	{0x2A02, 0x1200},
+	{0x2A04, 0x3C09},
+	{0x2A06, 0xD3E2},
+	{0x2A08, 0x1200},
+	{0x2A0A, 0x3FF4},
+	{0x2A0C, 0xD2F2},
+	{0x2A0E, 0x1200},
+	{0x2A10, 0x3FEC},
+	{0x2A12, 0xD2E2},
+	{0x2A14, 0x1200},
+	{0x2A16, 0x3FE4},
+	{0x2A18, 0x1292},
+	{0x2A1A, 0xD016},
+	{0x2A1C, 0x4130},
+	{0x2A1E, 0x1292},
+	{0x2A20, 0xD022},
+	{0x2A22, 0x43C2},
+	{0x2A24, 0x0B02},
+	{0x2A26, 0x4130},
+	{0x2A28, 0x430F},
+	{0x2A2A, 0xD3D2},
+	{0x2A2C, 0x7A12},
+	{0x2A2E, 0x0B00},
+	{0x2A30, 0x7304},
+	{0x2A32, 0x0000},
+	{0x2A34, 0x0800},
+	{0x2A36, 0x7A10},
+	{0x2A38, 0xD3D2},
+	{0x2A3A, 0x7B00},
+	{0x2A3C, 0x0800},
+	{0x2A3E, 0x7B00},
+	{0x2A40, 0x903F},
+	{0x2A42, 0x0005},
+	{0x2A44, 0x2003},
+	{0x2A46, 0x42D2},
+	{0x2A48, 0x8664},
+	{0x2A4A, 0x0B02},
+	{0x2A4C, 0x531F},
+	{0x2A4E, 0x9382},
+	{0x2A50, 0x7112},
+	{0x2A52, 0x27ED},
+	{0x2A54, 0x4130},
+	{0x2A56, 0x120B},
+	{0x2A58, 0x120A},
+	{0x2A5A, 0x1292},
+	{0x2A5C, 0xD056},
+	{0x2A5E, 0x421C},
+	{0x2A60, 0x865E},
+	{0x2A62, 0x4C0E},
+	{0x2A64, 0x5E0E},
+	{0x2A66, 0x5E0E},
+	{0x2A68, 0x5E0E},
+	{0x2A6A, 0x421D},
+	{0x2A6C, 0x865C},
+	{0x2A6E, 0x4D0F},
+	{0x2A70, 0x5F0F},
+	{0x2A72, 0x5F0F},
+	{0x2A74, 0xDF0E},
+	{0x2A76, 0x421B},
+	{0x2A78, 0x8660},
+	{0x2A7A, 0x4B0F},
+	{0x2A7C, 0x5F0F},
+	{0x2A7E, 0xDF0E},
+	{0x2A80, 0x421A},
+	{0x2A82, 0x8662},
+	{0x2A84, 0xDA0E},
+	{0x2A86, 0x93C2},
+	{0x2A88, 0x0381},
+	{0x2A8A, 0x3454},
+	{0x2A8C, 0xB3E2},
+	{0x2A8E, 0x0380},
+	{0x2A90, 0x240C},
+	{0x2A92, 0x903E},
+	{0x2A94, 0x0009},
+	{0x2A96, 0x2445},
+	{0x2A98, 0x903E},
+	{0x2A9A, 0x0005},
+	{0x2A9C, 0x2439},
+	{0x2A9E, 0x903E},
+	{0x2AA0, 0x000A},
+	{0x2AA2, 0x242B},
+	{0x2AA4, 0x903E},
+	{0x2AA6, 0x000B},
+	{0x2AA8, 0x241D},
+	{0x2AAA, 0x931D},
+	{0x2AAC, 0x2418},
+	{0x2AAE, 0xC2E2},
+	{0x2AB0, 0x1200},
+	{0x2AB2, 0x931C},
+	{0x2AB4, 0x2411},
+	{0x2AB6, 0xC2F2},
+	{0x2AB8, 0x1200},
+	{0x2ABA, 0x931B},
+	{0x2ABC, 0x240A},
+	{0x2ABE, 0xC3E2},
+	{0x2AC0, 0x1200},
+	{0x2AC2, 0x931A},
+	{0x2AC4, 0x2403},
+	{0x2AC6, 0xC3D2},
+	{0x2AC8, 0x1200},
+	{0x2ACA, 0x3C34},
+	{0x2ACC, 0xD3D2},
+	{0x2ACE, 0x1200},
+	{0x2AD0, 0x3C31},
+	{0x2AD2, 0xD3E2},
+	{0x2AD4, 0x1200},
+	{0x2AD6, 0x3FF5},
+	{0x2AD8, 0xD2F2},
+	{0x2ADA, 0x1200},
+	{0x2ADC, 0x3FEE},
+	{0x2ADE, 0xD2E2},
+	{0x2AE0, 0x1200},
+	{0x2AE2, 0x3FE7},
+	{0x2AE4, 0x403F},
+	{0x2AE6, 0x1200},
+	{0x2AE8, 0xC2FF},
+	{0x2AEA, 0x0000},
+	{0x2AEC, 0xC2EF},
+	{0x2AEE, 0x0000},
+	{0x2AF0, 0xD3EF},
+	{0x2AF2, 0x0000},
+	{0x2AF4, 0xD3DF},
+	{0x2AF6, 0x0000},
+	{0x2AF8, 0x3C1D},
+	{0x2AFA, 0x403F},
+	{0x2AFC, 0x1200},
+	{0x2AFE, 0xD2FF},
+	{0x2B00, 0x0000},
+	{0x2B02, 0xC2EF},
+	{0x2B04, 0x0000},
+	{0x2B06, 0xD3EF},
+	{0x2B08, 0x0000},
+	{0x2B0A, 0xC3DF},
+	{0x2B0C, 0x0000},
+	{0x2B0E, 0x3C12},
+	{0x2B10, 0x403F},
+	{0x2B12, 0x1200},
+	{0x2B14, 0xD2FF},
+	{0x2B16, 0x0000},
+	{0x2B18, 0xC2EF},
+	{0x2B1A, 0x0000},
+	{0x2B1C, 0xC3EF},
+	{0x2B1E, 0x0000},
+	{0x2B20, 0x3FF4},
+	{0x2B22, 0x403F},
+	{0x2B24, 0x1200},
+	{0x2B26, 0xC2FF},
+	{0x2B28, 0x0000},
+	{0x2B2A, 0xC2EF},
+	{0x2B2C, 0x0000},
+	{0x2B2E, 0xC3EF},
+	{0x2B30, 0x0000},
+	{0x2B32, 0x3FE0},
+	{0x2B34, 0x413A},
+	{0x2B36, 0x413B},
+	{0x2B38, 0x4130},
+	{0x2B3A, 0x4292},
+	{0x2B3C, 0x0C34},
+	{0x2B3E, 0x0202},
+	{0x2B40, 0x1292},
+	{0x2B42, 0xD006},
+	{0x2B44, 0x93C2},
+	{0x2B46, 0x861A},
+	{0x2B48, 0x2403},
+	{0x2B4A, 0x407F},
+	{0x2B4C, 0x0003},
+	{0x2B4E, 0x3C01},
+	{0x2B50, 0x434F},
+	{0x2B52, 0x4FC2},
+	{0x2B54, 0x023D},
+	{0x2B56, 0x425F},
+	{0x2B58, 0x861A},
+	{0x2B5A, 0x503F},
+	{0x2B5C, 0x0C7E},
+	{0x2B5E, 0x4F82},
+	{0x2B60, 0x752A},
+	{0x2B62, 0x4130},
+	{0x2B64, 0x7400},
+	{0x2B66, 0x8050},
+	{0x2B68, 0x30D8},
+	{0x2B6A, 0x0021},
+	{0x2B6C, 0x009D},
+	{0x2B6E, 0x005D},
+	{0x2B70, 0x21C3},
+	{0x2B72, 0x21C0},
+	{0x2B74, 0x0058},
+	{0x2B76, 0x0007},
+	{0x2B78, 0x5020},
+	{0x2B7A, 0x5040},
+	{0x2B7C, 0x5060},
+	{0x2B7E, 0x0098},
+	{0x2B80, 0x0057},
+	{0x2B82, 0x5083},
+	{0x2B84, 0x0912},
+	{0x2B86, 0x15D3},
+	{0x2B88, 0x0000},
+	{0x2B8A, 0x702C},
+	{0x2B8C, 0x16D5},
+	{0x2B8E, 0x20C3},
+	{0x2B90, 0x0058},
+	{0x2B92, 0x0001},
+	{0x2B94, 0x20A4},
+	{0x2B96, 0x700E},
+	{0x2B98, 0x2FA7},
+	{0x2B9A, 0x50A0},
+	{0x2B9C, 0x50C0},
+	{0x2B9E, 0x1805},
+	{0x2BA0, 0x0008},
+	{0x2BA2, 0x0020},
+	{0x2BA4, 0x0303},
+	{0x2BA6, 0x00C8},
+	{0x2BA8, 0x0045},
+	{0x2BAA, 0x0006},
+	{0x2BAC, 0x7002},
+	{0x2BAE, 0x0FDD},
+	{0x2BB0, 0x005D},
+	{0x2BB2, 0x21C3},
+	{0x2BB4, 0x21C0},
+	{0x2BB6, 0x21C3},
+	{0x2BB8, 0x0058},
+	{0x2BBA, 0x2014},
+	{0x2BBC, 0x20A4},
+	{0x2BBE, 0x704E},
+	{0x2BC0, 0x2FA7},
+	{0x2BC2, 0x50E0},
+	{0x2BC4, 0x5100},
+	{0x2BC6, 0x1345},
+	{0x2BC8, 0x0004},
+	{0x2BCA, 0x2132},
+	{0x2BCC, 0x7800},
+	{0x2BCE, 0x022E},
+	{0x2BD0, 0x0207},
+	{0x2BD2, 0x2E78},
+	{0x2BD4, 0x0002},
+	{0x2BD6, 0x7E38},
+	{0x2BD8, 0x0052},
+	{0x2BDA, 0x7E38},
+	{0x2BDC, 0x065E},
+	{0x2BDE, 0x5038},
+	{0x2BE0, 0x07DE},
+	{0x2BE2, 0x503A},
+	{0x2BE4, 0x0E72},
+	{0x2BE6, 0x507A},
+	{0x2BE8, 0x0F62},
+	{0x2BEA, 0x5030},
+	{0x2BEC, 0x0E62},
+	{0x2BEE, 0x0FF0},
+	{0x2BF0, 0x0702},
+	{0x2BF2, 0x7400},
+	{0x2BF4, 0x2002},
+	{0x2BF6, 0x7023},
+	{0x2BF8, 0x0FC1},
+	{0x2BFA, 0x705E},
+	{0x2BFC, 0x0FC0},
+	{0x2BFE, 0x7800},
+	{0x2C00, 0x0061},
+	{0x2C02, 0x7400},
+	{0x2C04, 0x2004},
+	{0x2C06, 0x7023},
+	{0x2C08, 0x0FC2},
+	{0x2C0A, 0x705E},
+	{0x2C0C, 0x0FC0},
+	{0x2C0E, 0x7800},
+	{0x2C10, 0x7400},
+	{0x2C12, 0x2008},
+	{0x2C14, 0x7023},
+	{0x2C16, 0x0FC3},
+	{0x2C18, 0x705E},
+	{0x2C1A, 0x0FC0},
+	{0x2C1C, 0x7800},
+	{0x2C1E, 0x7400},
+	{0x2C20, 0x0004},
+	{0x2C22, 0x70DF},
+	{0x2C24, 0x2F1F},
+	{0x2C26, 0x7002},
+	{0x2C28, 0x2F01},
+	{0x2C2A, 0x7800},
+	{0x2C2C, 0x7400},
+	{0x2C2E, 0x2010},
+	{0x2C30, 0x7023},
+	{0x2C32, 0x0FC4},
+	{0x2C34, 0x705E},
+	{0x2C36, 0x0FC0},
+	{0x2C38, 0x7800},
+	{0x2C3A, 0x7400},
+	{0x2C3C, 0x0003},
+	{0x2C3E, 0x70DF},
+	{0x2C40, 0x2F1F},
+	{0x2C42, 0x7002},
+	{0x2C44, 0x2F01},
+	{0x2C46, 0x7800},
+	{0x2C48, 0x7400},
+	{0x2C4A, 0x0002},
+	{0x2C4C, 0x70DF},
+	{0x2C4E, 0x2F1F},
+	{0x2C50, 0x7002},
+	{0x2C52, 0x2F01},
+	{0x2C54, 0x7800},
+	{0x2C56, 0x7400},
+	{0x2C58, 0x2008},
+	{0x2C5A, 0x7023},
+	{0x2C5C, 0x0FC3},
+	{0x2C5E, 0x705E},
+	{0x2C60, 0x0FC0},
+	{0x2C62, 0x7800},
+	{0x2C64, 0x0000},
+	{0x2C66, 0xBB64},
+	{0x2C68, 0x0000},
+	{0x2C6A, 0xBB64},
+	{0x2C6C, 0xBBCE},
+	{0x2C6E, 0x0002},
+	{0x2C70, 0x0063},
+	{0x2C72, 0xBBF2},
+	{0x2C74, 0x0063},
+	{0x2C76, 0xBC02},
+	{0x2C78, 0x0063},
+	{0x2C7A, 0xBC2C},
+	{0x2C7C, 0x0063},
+	{0x2C7E, 0xBC3A},
+	{0x2C80, 0xBC00},
+	{0x2C82, 0x0004},
+	{0x2C84, 0x0063},
+	{0x2C86, 0xBC2C},
+	{0x2C88, 0x0063},
+	{0x2C8A, 0xBC56},
+	{0x2C8C, 0x0063},
+	{0x2C8E, 0xBBF2},
+	{0x2C90, 0x0063},
+	{0x2C92, 0xBC48},
+	{0x2C94, 0xBC00},
+	{0x2C96, 0x0004},
+	{0x2C98, 0x0063},
+	{0x2C9A, 0xBBF2},
+	{0x2C9C, 0x0063},
+	{0x2C9E, 0xBC48},
+	{0x2CA0, 0x0063},
+	{0x2CA2, 0xBC2C},
+	{0x2CA4, 0x0063},
+	{0x2CA6, 0xBC3A},
+	{0x2CA8, 0xBC00},
+	{0x2CAA, 0x0004},
+	{0x2CAC, 0x0063},
+	{0x2CAE, 0xBC2C},
+	{0x2CB0, 0x0063},
+	{0x2CB2, 0xBC3A},
+	{0x2CB4, 0x0063},
+	{0x2CB6, 0xBBF2},
+	{0x2CB8, 0x0063},
+	{0x2CBA, 0xBC48},
+	{0x2CBC, 0xBC00},
+	{0x2CBE, 0x0004},
+	{0x2CC0, 0x0035},
+	{0x2CC2, 0x0037},
+	{0x2CC4, 0x003F},
+	{0x2CC6, 0x0157},
+	{0x2CC8, 0x0027},
+	{0x2CCA, 0x0023},
+	{0x2CCC, 0x004B},
+	{0x2CCE, 0x01C9},
+	{0x2CD0, 0x0091},
+	{0x2CD2, 0x0035},
+	{0x2CD4, 0x0034},
+	{0x2CD6, 0xFFFF},
+	{0x2CD8, 0x0028},
+	{0x2CDA, 0x0050},
+	{0x2CDC, 0x0000},
+	{0x2CDE, 0x0000},
+	{0x2CE0, 0xBCC0},
+	{0x2CE2, 0xBC64},
+	{0x2CE4, 0xBCD8},
+	{0x2CE6, 0xBC70},
+	{0x2CE8, 0xBC84},
+	{0x2CEA, 0xBC70},
+	{0x2CEC, 0xBC84},
+	{0x2CEE, 0x0000},
+	{0x2CF0, 0x0000},
+	{0x2CF2, 0x0000},
+	{0x2CF4, 0x0000},
+	{0x2CF6, 0x0000},
+	{0x2CF8, 0x0000},
+	{0x2CFA, 0x0000},
+	{0x2CFC, 0x0000},
+	{0x2CFE, 0x0000},
+	{0x2D00, 0x0000},
+	{0x2D02, 0x0000},
+	{0x2D04, 0x0000},
+	{0x2D06, 0xBC70},
+	{0x2D08, 0xBC84},
+	{0x2D0A, 0xBC98},
+	{0x2D0C, 0xBCAC},
+	{0x2D0E, 0x0000},
+	{0x2D10, 0x0000},
+	{0x2D12, 0x0000},
+	{0x2D14, 0x0000},
+	{0x2D16, 0x0000},
+	{0x2D18, 0x0000},
+	{0x2D1A, 0x0000},
+	{0x2D1C, 0x0000},
+	{0x2D1E, 0x0000},
+	{0x2D20, 0x0000},
+	{0x2D22, 0x0000},
+	{0x2D24, 0x0000},
+	{0x2E38, 0x0040},
+	{0x2E3A, 0x0042},
+	{0x2E3C, 0x0048},
+	{0x2E3E, 0x0050},
+	{0x2E40, 0x0055},
+	{0x2E42, 0x005D},
+	{0x2E44, 0x0065},
+	{0x2E46, 0x0067},
+	{0x2E48, 0x0068},
+	{0x2E4A, 0x006E},
+	{0x2E4C, 0x0075},
+	{0x2E4E, 0x007A},
+	{0x2E50, 0x0081},
+	{0x2E52, 0x0085},
+	{0x2E54, 0x0088},
+	{0x2E56, 0x0091},
+	{0x2E58, 0x0093},
+	{0x2E5A, 0x0098},
+	{0x2E5C, 0x009E},
+	{0x2E5E, 0x00A1},
+	{0x2E60, 0x00A8},
+	{0x2E62, 0x00AD},
+	{0x2E64, 0x00BB},
+	{0x2E66, 0x00C5},
+	{0x2E68, 0x00CC},
+	{0x2E6A, 0x00D1},
+	{0x2E6C, 0x00CF},
+	{0x2E6E, 0x00CD},
+	{0x2E70, 0x00DA},
+	{0x2E72, 0x00D8},
+	{0x2E74, 0x00E8},
+	{0x2E76, 0x00E8},
+	{0x2E78, 0x0200},
+	{0x2E7A, 0x0200},
+	{0x2E7C, 0x0200},
+	{0x2E7E, 0x0200},
+	{0x2E80, 0x0200},
+	{0x2E82, 0x0200},
+	{0x2E84, 0x0200},
+	{0x2E86, 0x0200},
+	{0x2E88, 0x0200},
+	{0x2E8A, 0x0200},
+	{0x2E8C, 0x0200},
+	{0x2E8E, 0x0200},
+	{0x2E90, 0x0200},
+	{0x2E92, 0x0200},
+	{0x2E94, 0x0200},
+	{0x2E96, 0x0200},
+	{0x2E98, 0x0200},
+	{0x2E9A, 0x0200},
+	{0x2E9C, 0x0200},
+	{0x2E9E, 0x0200},
+	{0x2EA0, 0x0200},
+	{0x2EA2, 0x0200},
+	{0x2EA4, 0x0200},
+	{0x2EA6, 0x0200},
+	{0x2EA8, 0x0200},
+	{0x2EAA, 0x0200},
+	{0x2EAC, 0x0200},
+	{0x2EAE, 0x0200},
+	{0x2EB0, 0x0200},
+	{0x2EB2, 0x0200},
+	{0x2EB4, 0x0200},
+	{0x2EB6, 0x0200},
+	{0x2EB8, 0x0200},
+	{0x2EBA, 0x0200},
+	{0x2EBC, 0x0200},
+	{0x2EBE, 0x0200},
+	{0x2EC0, 0x0200},
+	{0x2EC2, 0x0200},
+	{0x2EC4, 0x0200},
+	{0x2EC6, 0x0200},
+	{0x2EC8, 0x0200},
+	{0x2ECA, 0x0200},
+	{0x2ECC, 0x0200},
+	{0x2ECE, 0x0200},
+	{0x2ED0, 0x0200},
+	{0x2ED2, 0x0200},
+	{0x2ED4, 0x0200},
+	{0x2ED6, 0x0200},
+	{0x2ED8, 0x0200},
+	{0x2EDA, 0x0200},
+	{0x2EDC, 0x0200},
+	{0x2EDE, 0x0200},
+	{0x2EE0, 0x0200},
+	{0x2EE2, 0x0200},
+	{0x2EE4, 0x0200},
+	{0x2EE6, 0x0200},
+	{0x2EE8, 0x0200},
+	{0x2EEA, 0x0200},
+	{0x2EEC, 0x0200},
+	{0x2EEE, 0x0200},
+	{0x2EF0, 0x0200},
+	{0x2EF2, 0x0200},
+	{0x2EF4, 0x0200},
+	{0x2EF6, 0x0200},
+	{0x2EF8, 0x0200},
+	{0x2EFA, 0x0200},
+	{0x2EFC, 0x0200},
+	{0x2EFE, 0x0200},
+	{0x2F00, 0x0200},
+	{0x2F02, 0x0200},
+	{0x2F04, 0x0200},
+	{0x2F06, 0x0200},
+	{0x2F08, 0x0200},
+	{0x2F0A, 0x0200},
+	{0x2F0C, 0x0200},
+	{0x2F0E, 0x0200},
+	{0x2F10, 0x0200},
+	{0x2F12, 0x0200},
+	{0x2F14, 0x0200},
+	{0x2F16, 0x0200},
+	{0x2F18, 0x0200},
+	{0x2F1A, 0x0200},
+	{0x2F1C, 0x0200},
+	{0x2F1E, 0x0200},
+	{0x2F20, 0x0200},
+	{0x2F22, 0x0200},
+	{0x2F24, 0x0200},
+	{0x2F26, 0x0200},
+	{0x2F28, 0x0200},
+	{0x2F2A, 0x0200},
+	{0x2F2C, 0x0200},
+	{0x2F2E, 0x0200},
+	{0x2F30, 0x0200},
+	{0x2F32, 0x0200},
+	{0x2F34, 0x0200},
+	{0x2F36, 0x0200},
+	{0x2F38, 0x0200},
+	{0x2F3A, 0x0200},
+	{0x2F3C, 0x0200},
+	{0x2F3E, 0x0200},
+	{0x2F40, 0x0200},
+	{0x2F42, 0x0200},
+	{0x2F44, 0x0200},
+	{0x2F46, 0x0200},
+	{0x2F48, 0x0200},
+	{0x2F4A, 0x0200},
+	{0x2F4C, 0x0200},
+	{0x2F4E, 0x0200},
+	{0x2F50, 0x0200},
+	{0x2F52, 0x0200},
+	{0x2F54, 0x0200},
+	{0x2F56, 0x0200},
+	{0x2F58, 0x0200},
+	{0x2F5A, 0x0200},
+	{0x2F5C, 0x0200},
+	{0x2F5E, 0x0200},
+	{0x2F60, 0x0200},
+	{0x2F62, 0x0200},
+	{0x2F64, 0x0200},
+	{0x2F66, 0x0200},
+	{0x2F68, 0x0200},
+	{0x2F6A, 0x0200},
+	{0x2F6C, 0x0200},
+	{0x2F6E, 0x0200},
+	{0x2F70, 0x0200},
+	{0x2F72, 0x0200},
+	{0x2F74, 0x0200},
+	{0x2F76, 0x0200},
+	{0x363E, 0xBE38},
+	{0x3640, 0xBD06},
+	{0x3642, 0xBCE4},
+	{0x3644, 0xD13E},
+	{0x3646, 0xBCE6},
+	{0x3648, 0xBCE2},
+	{0x364A, 0x0000},
+	{0x364C, 0x0000},
+	{0x364E, 0x0000},
+	{0x3650, 0x0000},
+	{0x3652, 0x0000},
+	{0x3654, 0x0000},
+	{0x3656, 0x0000},
+	{0x3658, 0x0000},
+	{0x365A, 0x0000},
+	{0x365C, 0x0000},
+	{0x365E, 0x0000},
+	{0x3660, 0x0000},
+	{0x3662, 0x0000},
+
+	{0x2F78, 0x0042},
+	{0x2F7A, 0x004C},
+	{0x2F7C, 0x0078},
+	{0x2F7E, 0x00A1},
+	{0x2F80, 0x00A4},
+	{0x2F82, 0x07FF},
+	{0x2F84, 0x0042},
+	{0x2F86, 0x0048},
+	{0x2F88, 0x00A0},
+	{0x2F8A, 0x0106},
+	{0x2F8C, 0x01FD},
+	{0x2F8E, 0x07FF},
+	{0x2F90, 0x0042},
+	{0x2F92, 0x0048},
+	{0x2F94, 0x00A0},
+	{0x2F96, 0x0106},
+	{0x2F98, 0x01FD},
+	{0x2F9A, 0x07FF},
+	{0x2F9C, 0x0042},
+	{0x2F9E, 0x004C},
+	{0x2FA0, 0x005A},
+	{0x2FA2, 0x00A0},
+	{0x2FA4, 0x00A3},
+	{0x2FA6, 0x07FF},
+	{0x2FA8, 0x1014},
+	{0x2FAA, 0x0001},
+	{0x2FAC, 0x1007},
+	{0x2FAE, 0x0015},
+	{0x2FB0, 0x000A},
+	{0x2FB2, 0x1013},
+	{0x2FB4, 0x1002},
+	{0x2FB6, 0x0009},
+	{0x2FB8, 0x000E},
+	{0x2FBA, 0x0004},
+	{0x2FBC, 0x1013},
+	{0x2FBE, 0x1002},
+	{0x2FC0, 0x0009},
+	{0x2FC2, 0x000E},
+	{0x2FC4, 0x0004},
+	{0x2FC6, 0x1009},
+	{0x2FC8, 0x1009},
+	{0x2FCA, 0x1001},
+	{0x2FCC, 0x1027},
+	{0x2FCE, 0x000E},
+	{0x2FD0, 0x805A},
+	{0x2FD2, 0x8115},
+	{0x2FD4, 0x0025},
+	{0x2FD6, 0x8AA4},
+	{0x2FD8, 0x8637},
+	{0x2FDA, 0x0000},
+	{0x2FDC, 0x8035},
+	{0x2FDE, 0x8173},
+	{0x2FE0, 0x8535},
+	{0x2FE2, 0x8909},
+	{0x2FE4, 0x0816},
+	{0x2FE6, 0x0000},
+	{0x2FE8, 0x8035},
+	{0x2FEA, 0x8173},
+	{0x2FEC, 0x8535},
+	{0x2FEE, 0x8909},
+	{0x2FF0, 0x0816},
+	{0x2FF2, 0x0000},
+	{0x2FF4, 0x808F},
+	{0x2FF6, 0x803E},
+	{0x2FF8, 0x81F9},
+	{0x2FFA, 0x0C68},
+	{0x2FFC, 0x885A},
+	{0x2FFE, 0x0000},
+	{0x0266, 0x0001},
+	{0x0268, 0x00EB},
+	{0x026A, 0xFFFF},
+	{0x026C, 0x00FF},
+	{0x026E, 0x0000},
+	{0x0360, 0x9E8E},
+	{0x0384, 0x0004},
+	{0x0386, 0x0233},
+	{0x0388, 0x7133},
+	{0x038A, 0x02CD},
+	{0x038C, 0x4ECD},
+	{0x038E, 0x0041},
+	{0x0390, 0x0200},
+	{0x0392, 0x012C},
+	{0x0414, 0x0220},
+	{0x0450, 0x0032},
+	{0x0452, 0x0040},
+	{0x0600, 0x1130},
+	{0x0602, 0x3012},
+	{0x0604, 0x8048},
+	{0x060E, 0x0000},
+	{0x065E, 0x07FF},
+	{0x0660, 0x0002},
+	{0x0686, 0x0240},
+	{0x0688, 0x00CA},
+	{0x068A, 0x0041},
+	{0x06AA, 0x00FF},
+	{0x0F06, 0x0002},
+	{0x0A02, 0x0084},
+	{0x0A04, 0x0094},
+	{0x0A06, 0x8181},
+	{0x0A08, 0x888F},
+	{0x0A0A, 0xA664},
+	{0x0A0C, 0xF051},
+	{0x0A0E, 0xEC00},
+	{0x0A12, 0x0000},
+	{0x0A16, 0xCCCC},
+	{0x0A18, 0x0008},
+	{0x0A1A, 0x7E34},
+	{0x0A1E, 0x018F},
+	{0x0C00, 0x0021},
+	{0x0C16, 0x0002},
+	{0x0708, 0x6FC0},
+	{0x070C, 0x0000},
+	{0x0780, 0x010F},
+	{0x1218, 0x7026},
+	{0x1034, 0x0600},
+	{0x1036, 0x0208},
+	{0x105A, 0x0001},
+	{0x027E, 0x0100},
+
+	{HI1339_TABLE_END, 0x00}
+};
+
+static const struct hi1339_link_freq_config link_freq_configs[] = {
+	[HI1339_LINK_FREQ_1440MBPS] = {
+		.reg_list = {
+			.num_of_regs = ARRAY_SIZE(mipi_data_rate_1440mbps),
+			.regs = mipi_data_rate_1440mbps,
+		}
+	},
+	[HI1339_LINK_FREQ_624MBPS] = {
+		.reg_list = {
+			.num_of_regs = ARRAY_SIZE(mipi_data_rate_624mbps),
+			.regs = mipi_data_rate_624mbps,
+		}
+	},
+
+	// TODO:
+};
+
+
+enum {
+	HI1339_PREV,
+	HI1339_HS,
+};
+
+/*
+ * Declare modes in order, from biggest
+ * to smallest height.
+ */
+static const struct hi1339_mode {
+	u8	mode_id;
+	u32 width;
+	u32 height;
+	const struct hi1339_reg_list reg_list;
+
+	u32 hts; /* Horizontal timining size */
+	u32 vts_def; /* Default vertical timining size */
+	u32 vts_min; /* Min vertical timining size */
+	u32 link_freq_index; /* Link frequency needed for this resolution */
+	u32 max_framerate;
+} hi1339_modes[] = {
+	{
+		.mode_id = HI1339_PREV,
+		.width = 4208,
+		.height = 3120,
+		.reg_list = {
+			.num_of_regs = ARRAY_SIZE(mode_4208x3120),
+			.regs = mode_4208x3120,
+		},
+		.link_freq_index = HI1339_LINK_FREQ_1440MBPS,
+
+		.hts = HI1339_HTS_30FPS,
+		.vts_def = HI1339_FLL_30FPS,
+		.vts_min = HI1339_FLL_30FPS_MIN,
+		.max_framerate = 300,
+	},
+	{
+		.mode_id = HI1339_HS,
+		.width = 1920,
+		.height = 1080,
+		.reg_list = {
+			.num_of_regs = ARRAY_SIZE(mode_1920x1080),
+			.regs = mode_1920x1080,
+		},
+		.link_freq_index = HI1339_LINK_FREQ_624MBPS,
+
+		.hts = HI1339_HTS_60FPS,
+		.vts_def = HI1339_FLL_60FPS,
+		.vts_min = HI1339_FLL_60FPS_MIN,
+		.max_framerate = 600,
+	},
+};
+
+static u64 to_pixel_rate(u32 f_index)
+{
+	u64 pixel_rate = link_freq_menu_items[f_index] * 2 * HI1339_DATA_LANES;
+
+	do_div(pixel_rate, HI1339_RGB_DEPTH);
+
+	return pixel_rate;
+}
+
+static u64 __maybe_unused to_pixels_per_line(u32 hts, u32 f_index)
+{
+	u64 ppl = hts * to_pixel_rate(f_index);
+
+	do_div(ppl, HI1339_SCLK);
+
+	return ppl;
+}
+
+static int hi1339_read_reg(struct hi1339 *hi1339, u16 reg, u16 len, u32 *val)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&hi1339->sd);
+	struct i2c_msg msgs[2];
+	u8 addr_buf[2];
+	u8 data_buf[4] = {0};
+	int ret;
+
+	if (len > 4)
+		return -EINVAL;
+
+	put_unaligned_be16(reg, addr_buf);
+	msgs[0].addr = client->addr;
+	msgs[0].flags = 0;
+	msgs[0].len = sizeof(addr_buf);
+	msgs[0].buf = addr_buf;
+	msgs[1].addr = client->addr;
+	msgs[1].flags = I2C_M_RD;
+	msgs[1].len = len;
+	msgs[1].buf = &data_buf[4 - len];
+
+	ret = i2c_transfer(client->adapter, msgs, ARRAY_SIZE(msgs));
+	if (ret != ARRAY_SIZE(msgs))
+		return -EIO;
+
+	*val = get_unaligned_be32(data_buf);
+
+	return 0;
+}
+
+static int hi1339_write_reg(struct hi1339 *hi1339, u16 reg, u16 len, u32 val)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&hi1339->sd);
+	u8 buf[6];
+
+	if (len > 4)
+		return -EINVAL;
+
+	put_unaligned_be16(reg, buf);
+	put_unaligned_be32(val << 8 * (4 - len), buf + 2);
+	if (i2c_master_send(client, buf, len + 2) != len + 2)
+		return -EIO;
+
+	return 0;
+}
+
+static int hi1339_write_reg_list(struct hi1339 *hi1339,
+                                 const struct hi1339_reg_list *r_list)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&hi1339->sd);
+	unsigned int i;
+	int ret;
+
+	for (i = 0; i < r_list->num_of_regs; i++) {
+
+		if (r_list->regs[i].address == HI1339_TABLE_WAIT_MS) {
+			usleep_range(r_list->regs[i].val * 1000,
+			             r_list->regs[i].val * 1000 + 500);
+			continue;
+		}
+
+		if (r_list->regs[i].address == HI1339_TABLE_END) {
+			break;
+		}
+
+		ret = hi1339_write_reg(hi1339, r_list->regs[i].address,
+		                       HI1339_REG_VALUE_16BIT,
+		                       r_list->regs[i].val);
+		if (ret) {
+			dev_err_ratelimited(&client->dev,
+			                    "failed to write reg 0x%4.4x. error = %d",
+			                    r_list->regs[i].address, ret);
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
+static int hi1339_update_digital_gain(struct hi1339 *hi1339, u32 d_gain)
+{
+	int ret;
+
+	ret = hi1339_write_reg(hi1339, HI1339_REG_MWB_GR_GAIN,
+	                       HI1339_REG_VALUE_16BIT, d_gain);
+	if (ret)
+		return ret;
+
+	ret = hi1339_write_reg(hi1339, HI1339_REG_MWB_GB_GAIN,
+	                       HI1339_REG_VALUE_16BIT, d_gain);
+	if (ret)
+		return ret;
+
+	ret = hi1339_write_reg(hi1339, HI1339_REG_MWB_R_GAIN,
+	                       HI1339_REG_VALUE_16BIT, d_gain);
+	if (ret)
+		return ret;
+
+	return hi1339_write_reg(hi1339, HI1339_REG_MWB_B_GAIN,
+	                        HI1339_REG_VALUE_16BIT, d_gain);
+}
+
+static int hi1339_test_pattern(struct hi1339 *hi1339, u32 pattern)
+{
+	int ret;
+	u32 val;
+
+	if (pattern) {
+		ret = hi1339_read_reg(hi1339, HI1339_REG_ISP,
+		                      HI1339_REG_VALUE_16BIT, &val);
+		if (ret)
+			return ret;
+
+		ret = hi1339_write_reg(hi1339, HI1339_REG_ISP,
+		                       HI1339_REG_VALUE_16BIT,
+		                       val | HI1339_REG_ISP_TPG_EN);
+		if (ret)
+			return ret;
+	}
+
+	ret = hi1339_read_reg(hi1339, HI1339_REG_TEST_PATTERN,
+	                      HI1339_REG_VALUE_16BIT, &val);
+	if (ret)
+		return ret;
+
+	return hi1339_write_reg(hi1339, HI1339_REG_TEST_PATTERN,
+	                        HI1339_REG_VALUE_16BIT, val | pattern << 8);
+}
+
+static int hi1339_grbg_shift(struct hi1339 *hi1339)
+{
+	int ret;
+	int hflip, vflip;
+
+	/* regs shift for full size */
+	static const u32 FORMAT_X_SHIFT_1[2][2] = {
+		{ 0x0008, 0x0007, },
+		{ 0x0008, 0x0007, },
+	};
+
+	static const u32 FORMAT_Y_SHIFT_1[2][2] = {
+		{ 0x0002, 0x0002, },
+		{ 0x0001, 0x0001, },
+	};
+
+	/* regs shift for binning size */
+	static const u32 FORMAT_X_SHIFT_2[2][2] = {
+		{ 0x0004, 0x0003, },
+		{ 0x0004, 0x0003, },
+	};
+
+	static const u32 FORMAT_Y_SHIFT_2[2][2] = {
+		{ 0x0002, 0x0002, },
+		{ 0x0001, 0x0001, },
+	};
+
+	hflip = hi1339->hflip->val;
+	vflip = hi1339->vflip->val;
+
+	if (hi1339->cur_mode->width == 3264) {
+		ret = hi1339_write_reg(hi1339, HI1339_REG_FORMAT_X,
+		                       HI1339_REG_VALUE_16BIT,
+		                       FORMAT_X_SHIFT_1[vflip][hflip]);
+		if (ret)
+			return ret;
+
+		return hi1339_write_reg(hi1339, HI1339_REG_FORMAT_Y,
+		                        HI1339_REG_VALUE_16BIT,
+		                        FORMAT_Y_SHIFT_1[vflip][hflip]);
+	} else {
+		ret = hi1339_write_reg(hi1339, HI1339_REG_FORMAT_X,
+		                       HI1339_REG_VALUE_16BIT,
+		                       FORMAT_X_SHIFT_2[vflip][hflip]);
+		if (ret)
+			return ret;
+
+		return hi1339_write_reg(hi1339, HI1339_REG_FORMAT_Y,
+		                        HI1339_REG_VALUE_16BIT,
+		                        FORMAT_Y_SHIFT_2[vflip][hflip]);
+	}
+}
+
+static int hi1339_set_ctrl_hflip(struct hi1339 *hi1339, u32 ctrl_val)
+{
+	int ret;
+	u32 val;
+
+	ret = hi1339_read_reg(hi1339, HI1339_REG_MIRROR_FLIP,
+	                      HI1339_REG_VALUE_16BIT, &val);
+	if (ret)
+		return ret;
+
+	ret = hi1339_grbg_shift(hi1339);
+	if (ret)
+		return ret;
+
+	return hi1339_write_reg(hi1339, HI1339_REG_MIRROR_FLIP,
+	                        HI1339_REG_VALUE_16BIT,
+	                        ctrl_val ? val | BIT(8) : val & ~BIT(8));
+}
+
+static int hi1339_set_ctrl_vflip(struct hi1339 *hi1339, u8 ctrl_val)
+{
+	int ret;
+	u32 val;
+
+	ret = hi1339_read_reg(hi1339, HI1339_REG_MIRROR_FLIP,
+	                      HI1339_REG_VALUE_16BIT, &val);
+	if (ret)
+		return ret;
+
+	ret = hi1339_grbg_shift(hi1339);
+	if (ret)
+		return ret;
+
+	return hi1339_write_reg(hi1339, HI1339_REG_MIRROR_FLIP,
+	                        HI1339_REG_VALUE_16BIT,
+	                        ctrl_val ? val | BIT(9) : val & ~BIT(9));
+}
+
+static int hi1339_identify_module(struct hi1339 *hi1339)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&hi1339->sd);
+	int ret;
+	u32 val;
+
+	ret = hi1339_read_reg(hi1339, HI1339_REG_CHIP_ID,
+	                      HI1339_REG_VALUE_16BIT, &val);
+	if (ret)
+		return ret;
+
+	if (val != HI1339_CHIP_ID) {
+		dev_err(&client->dev, "chip id mismatch: 0x%x!=0x%x",
+		        HI1339_CHIP_ID, val);
+		return -ENXIO;
+	}
+
+	dev_info(&client->dev, "sensor_id: 0x%04x\n", val);
+	return 0;
+}
+
+static inline struct hi1339 *to_hi1339(struct v4l2_subdev *sd)
+{
+	return container_of(sd, struct hi1339, sd);
+}
+
+static int hi1339_power_on(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct hi1339 *hi1339 = to_hi1339(sd);
+	int ret;
+
+	dev_info(dev, "--- %s +", __func__);
+
+	gpiod_set_value_cansleep(hi1339->enable_gpio, 0);
+	usleep_range(2000, 3000);
+
+	ret = regulator_bulk_enable(HI1339_NUM_SUPPLIES, hi1339->supplies);
+	if (ret < 0) {
+		dev_err(hi1339->dev, "failed to enable regulators: %d\n", ret);
+		return ret;
+	}
+
+	//	usleep_range(2000, 3000);
+
+	ret = clk_prepare_enable(hi1339->xclk);
+	if (ret < 0) {
+		regulator_bulk_disable(HI1339_NUM_SUPPLIES, hi1339->supplies);
+		dev_err(hi1339->dev, "clk prepare enable failed\n");
+		return ret;
+	}
+
+	gpiod_set_value_cansleep(hi1339->enable_gpio, 1);
+	usleep_range(12000, 15000);
+
+	dev_info(dev, "--- %s -", __func__);
+
+	return 0;
+}
+
+static int hi1339_power_off(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct hi1339 *hi1339 = to_hi1339(sd);
+
+	dev_info(dev, "--- %s +", __func__);
+
+	gpiod_set_value_cansleep(hi1339->enable_gpio, 0);
+
+	clk_disable_unprepare(hi1339->xclk);
+
+	regulator_bulk_disable(HI1339_NUM_SUPPLIES, hi1339->supplies);
+	usleep_range(10, 20);
+
+	dev_info(dev, "--- %s -", __func__);
+
+	return 0;
+}
+
+static int hi1339_enum_mbus_code(struct v4l2_subdev *sd,
+                                 struct v4l2_subdev_state *sd_state,
+                                 struct v4l2_subdev_mbus_code_enum *code)
+{
+	if (code->index > 0)
+		return -EINVAL;
+
+	code->code = HI1339_MBUS_CODE;
+
+	return 0;
+}
+
+static int hi1339_enum_frame_size(struct v4l2_subdev *subdev,
+                                  struct v4l2_subdev_state *sd_state,
+                                  struct v4l2_subdev_frame_size_enum *fse)
+{
+	if (fse->code != HI1339_MBUS_CODE)
+		return -EINVAL;
+
+	if (fse->index >= ARRAY_SIZE(hi1339_modes))
+		return -EINVAL;
+
+	fse->min_width = fse->max_width = hi1339_modes[fse->index].width;
+	fse->min_height = fse->max_height = hi1339_modes[fse->index].height;
+
+	return 0;
+}
+
+#ifdef CONFIG_VIDEO_ADV_DEBUG
+static int hi1339_g_register(struct v4l2_subdev *subdev,
+                             struct v4l2_dbg_register *reg)
+{
+	struct hi1339 *hi1339 = container_of(subdev, struct hi1339, sd);
+	int ret;
+	u32 val;
+
+	ret = hi1339_read_reg(hi1339, reg->reg,
+	                      HI1339_REG_VALUE_08BIT, &val);
+	if (ret < 0)
+		return ret;
+
+	reg->val = val;
+	reg->size = 1;
+
+	return 0;
+}
+
+static int hi1339_s_register(struct v4l2_subdev *subdev,
+                             const struct v4l2_dbg_register *reg)
+{
+	struct hi1339 *hi1339 = container_of(subdev, struct hi1339, sd);
+
+	return hi1339_write_reg(hi1339, reg->reg,
+	                        HI1339_REG_VALUE_08BIT, reg->val & 0xff);
+}
+#endif
+
+static const struct v4l2_subdev_core_ops hi1339_core_ops = {
+#ifdef CONFIG_VIDEO_ADV_DEBUG
+	.g_register = hi1339_g_register,
+	.s_register = hi1339_s_register,
+#endif
+};
+
+static struct v4l2_mbus_framefmt *
+__hi1339_get_pad_format(struct hi1339 *hi1339,
+                        struct v4l2_subdev_state *sd_state,
+                        unsigned int pad,
+                        enum v4l2_subdev_format_whence which)
+{
+	switch (which) {
+	case V4L2_SUBDEV_FORMAT_TRY:
+		return v4l2_subdev_get_try_format(&hi1339->sd, sd_state, pad);
+	case V4L2_SUBDEV_FORMAT_ACTIVE:
+		return &hi1339->fmt;
+	default:
+		return NULL;
+	}
+}
+
+static int hi1339_get_format(struct v4l2_subdev *sd,
+                             struct v4l2_subdev_state *sd_state,
+                             struct v4l2_subdev_format *format)
+{
+	struct hi1339 *hi1339 = to_hi1339(sd);
+
+	mutex_lock(&hi1339->mutex);
+	format->format = *__hi1339_get_pad_format(hi1339, sd_state,
+	                 format->pad,
+	                 format->which);
+	mutex_unlock(&hi1339->mutex);
+
+	return 0;
+}
+
+static struct v4l2_rect *
+__hi1339_get_pad_crop(struct hi1339 *hi1339,
+                      struct v4l2_subdev_state *sd_state,
+                      unsigned int pad, enum v4l2_subdev_format_whence which)
+{
+	switch (which) {
+	case V4L2_SUBDEV_FORMAT_TRY:
+		return v4l2_subdev_get_try_crop(&hi1339->sd, sd_state, pad);
+	case V4L2_SUBDEV_FORMAT_ACTIVE:
+		return &hi1339->crop;
+	default:
+		return NULL;
+	}
+}
+
+static int hi1339_update_cur_mode_controls(struct hi1339 *hi1339)
+{
+	s64 exposure_max, h_blank;
+	int ret = 0;
+
+	ret = __v4l2_ctrl_modify_range(hi1339->vblank,
+						   hi1339->cur_mode->vts_min - hi1339->cur_mode->height,
+						   HI1339_FLL_MAX - hi1339->cur_mode->height,
+						   1,
+						   hi1339->cur_mode->vts_def - hi1339->cur_mode->height);
+	if (ret) {
+		dev_err(hi1339->dev, "VB ctrl range update failed\n");
+	}
+
+	h_blank = hi1339->cur_mode->hts - hi1339->cur_mode->width;
+	ret = __v4l2_ctrl_modify_range(hi1339->hblank,
+						   h_blank, h_blank, 1, h_blank);
+	if (ret) {
+		dev_err(hi1339->dev, "HB ctrl range update failed\n");
+	}
+
+	exposure_max = hi1339->cur_mode->vts_def - HI1339_EXPOSURE_MAX_MARGIN;
+	ret = __v4l2_ctrl_modify_range(hi1339->exposure,
+						 HI1339_EXPOSURE_MIN,
+						 exposure_max,
+						 HI1339_EXPOSURE_STEP,
+						 exposure_max);
+	if (ret) {
+		dev_err(hi1339->dev, "exposure ctrl range update failed\n");
+	}
+	return ret;
+}
+
+static int hi1339_set_format(struct v4l2_subdev *sd,
+                             struct v4l2_subdev_state *sd_state,
+                             struct v4l2_subdev_format *format)
+{
+	struct hi1339 *hi1339 = to_hi1339(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(&hi1339->sd);
+	struct device *dev = &client->dev;
+	struct v4l2_mbus_framefmt *__format;
+	struct v4l2_rect *__crop;
+	const struct hi1339_mode *mode;
+
+	mutex_lock(&hi1339->mutex);
+
+	dev_dbg(dev, "---- %s, format(W x H:%d x %d)  +",
+	         __func__, format->format.width, format->format.height);
+
+	__crop = __hi1339_get_pad_crop(hi1339, sd_state, format->pad,
+	                               format->which);
+
+	mode = v4l2_find_nearest_size(hi1339_modes,
+	                              ARRAY_SIZE(hi1339_modes), width, height,
+	                              format->format.width,
+	                              format->format.height);
+	dev_dbg(dev, "----func:%s, nearest mode(id:%d, WxH:%dx%d)",
+        __func__,
+        mode->mode_id,
+        mode->width, mode->height);
+
+	__crop->width = mode->width;
+	__crop->height = mode->height;
+
+	__format = __hi1339_get_pad_format(hi1339, sd_state, format->pad,
+	                                   format->which);
+	__format->width = __crop->width;
+	__format->height = __crop->height;
+	__format->code = HI1339_MBUS_CODE;
+	__format->field = V4L2_FIELD_NONE;
+	__format->colorspace = V4L2_COLORSPACE_SRGB;
+	__format->ycbcr_enc = V4L2_MAP_YCBCR_ENC_DEFAULT(__format->colorspace);
+	__format->quantization = V4L2_MAP_QUANTIZATION_DEFAULT(true,
+	                         __format->colorspace, __format->ycbcr_enc);
+	__format->xfer_func = V4L2_MAP_XFER_FUNC_DEFAULT(__format->colorspace);
+
+	format->format = *__format;
+
+	hi1339->cur_mode = mode;
+	dev_dbg(dev, "----func:%s, cur mode(id:%d, WxH:%dx%d)",
+        __func__,
+        hi1339->cur_mode->mode_id,
+        hi1339->cur_mode->width, hi1339->cur_mode->height);
+
+    hi1339_update_cur_mode_controls(hi1339);
+
+	mutex_unlock(&hi1339->mutex);
+
+	return 0;
+}
+
+static int hi1339_get_selection(struct v4l2_subdev *sd,
+                                struct v4l2_subdev_state *sd_state,
+                                struct v4l2_subdev_selection *sel)
+{
+	struct hi1339 *hi1339 = to_hi1339(sd);
+
+	if (sel->target != V4L2_SEL_TGT_CROP)
+		return -EINVAL;
+
+	mutex_lock(&hi1339->mutex);
+	sel->r = *__hi1339_get_pad_crop(hi1339, sd_state, sel->pad,
+	                                sel->which);
+	mutex_unlock(&hi1339->mutex);
+	return 0;
+}
+
+static int hi1339_entity_init_cfg(struct v4l2_subdev *subdev,
+                                  struct v4l2_subdev_state *sd_state)
+{
+	struct v4l2_subdev_format fmt = { };
+
+	fmt.which = sd_state ? V4L2_SUBDEV_FORMAT_TRY : V4L2_SUBDEV_FORMAT_ACTIVE;
+	fmt.format.width = hi1339_modes[0].width;
+	fmt.format.height = hi1339_modes[0].height;
+
+	hi1339_set_format(subdev, sd_state, &fmt);
+
+	return 0;
+}
+
+static int set_ext_ctrl(struct v4l2_ctrl *ctrl)
+{
+	int ret = 0;
+//	struct hi1339 *hi1339 = container_of(ctrl->handler, struct hi1339, ctrl_handler);
+//	struct i2c_client *client = v4l2_get_subdevdata(&hi1339->sd);
+
+	switch (ctrl->id) {
+	// TODO: add extension CMD
+
+	}
+
+	return ret;
+}
+
+
+static int hi1339_set_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct hi1339 *hi1339 = container_of(ctrl->handler,
+	                                     struct hi1339, ctrl_handler);
+	struct i2c_client *client = v4l2_get_subdevdata(&hi1339->sd);
+	s64 exposure_max;
+	int ret = 0;
+
+	/* Propagate change of current control to all related controls */
+	if (ctrl->id == V4L2_CID_VBLANK) {
+		/* Update max exposure while meeting expected vblanking */
+		exposure_max = hi1339->cur_mode->height + ctrl->val -
+		               HI1339_EXPOSURE_MAX_MARGIN;
+		__v4l2_ctrl_modify_range(hi1339->exposure,
+		                         hi1339->exposure->minimum,
+		                         exposure_max, hi1339->exposure->step,
+		                         exposure_max);
+	}
+
+	/* V4L2 controls values will be applied only when power is already up */
+	if (!pm_runtime_get_if_in_use(&client->dev))
+		return 0;
+
+	switch (ctrl->id) {
+	case V4L2_CID_ANALOGUE_GAIN:
+		//dev_info(hi1339->dev, "V4L2_CID_ANALOGUE_GAIN:0x%x\n", ctrl->val);
+		ret = hi1339_write_reg(hi1339, HI1339_REG_ANALOG_GAIN,
+		                       HI1339_REG_VALUE_16BIT, ctrl->val);
+		break;
+
+	case V4L2_CID_DIGITAL_GAIN:
+		ret = hi1339_update_digital_gain(hi1339, ctrl->val);
+		break;
+
+	case V4L2_CID_EXPOSURE:
+		//dev_info(hi1339->dev, "V4L2_CID_EXPOSURE:0x%x\n", ctrl->val);
+		ret = hi1339_write_reg(hi1339, HI1339_REG_EXPOSURE,
+		                       HI1339_REG_VALUE_16BIT, ctrl->val);
+		break;
+
+	case V4L2_CID_VBLANK:
+		/* Update FLL that meets expected vertical blanking */
+		dev_info(hi1339->dev, "V4L2_CID_VBLANK:height:%d, V_BLNK:%d\n",
+        		hi1339->cur_mode->height, ctrl->val);
+		ret = hi1339_write_reg(hi1339, HI1339_REG_FLL,
+		                       HI1339_REG_VALUE_16BIT,
+		                       hi1339->cur_mode->height + ctrl->val);
+		break;
+
+	case V4L2_CID_TEST_PATTERN:
+		ret = hi1339_test_pattern(hi1339, ctrl->val);
+		break;
+
+	case V4L2_CID_HFLIP:
+		hi1339_set_ctrl_hflip(hi1339, ctrl->val);
+		break;
+
+	case V4L2_CID_VFLIP:
+		hi1339_set_ctrl_vflip(hi1339, ctrl->val);
+		break;
+
+	default:
+		ret = set_ext_ctrl(ctrl);
+		break;
+	}
+
+	pm_runtime_put(&client->dev);
+
+	return ret;
+}
+
+
+static int get_volatile_ext_ctrl(struct v4l2_ctrl *ctrl)
+{
+	int ret = 0;
+	struct hi1339 *hi1339 = container_of(ctrl->handler, struct hi1339, ctrl_handler);
+	struct i2c_client *client = v4l2_get_subdevdata(&hi1339->sd);
+
+	dev_dbg(&client->dev, "---- %s, CMD:0x%x\n", __func__, ctrl->id);
+	switch (ctrl->id) {
+	default:
+		dev_dbg(&client->dev, "[hi1339] %s, un-support CMD: 0x%x\n", __func__, ctrl->id);
+		break;
+	}
+
+	return ret;
+}
+
+static int hi1339_g_volatile_ctrl(struct v4l2_ctrl *ctrl)
+{
+	int ret = 0;
+
+	switch (ctrl->id) {
+	default:
+		ret = get_volatile_ext_ctrl(ctrl);
+		break;
+	}
+
+	return ret;
+}
+
+static int try_ext_ctrl(struct v4l2_ctrl *ctrl)
+{
+	int ret = 0;
+	struct hi1339 *hi1339 = container_of(ctrl->handler, struct hi1339, ctrl_handler);
+	struct i2c_client *client = v4l2_get_subdevdata(&hi1339->sd);
+
+	switch (ctrl->id) {
+	default:
+		dev_dbg(&client->dev, "[hi1339] un-handle CMD: 0x%x (%s : %d)\n",
+		        ctrl->id, __func__, __LINE__);
+		break;
+	}
+
+	return ret;
+}
+
+static int hi1339_try_ctrl(struct v4l2_ctrl *ctrl)
+{
+	int ret = 0;
+
+	switch (ctrl->id) {
+	case V4L2_CID_EXPOSURE:
+	case V4L2_CID_ANALOGUE_GAIN:
+	case V4L2_CID_DIGITAL_GAIN:
+	case V4L2_CID_VBLANK:
+	case V4L2_CID_HFLIP:
+	case V4L2_CID_VFLIP:
+	case V4L2_CID_TEST_PATTERN:
+		return 0;
+	default:
+		ret = try_ext_ctrl(ctrl);
+		break;
+	}
+
+	return ret;
+}
+
+
+const struct v4l2_ctrl_ops hi1339_ctrl_ops = {
+	.g_volatile_ctrl = hi1339_g_volatile_ctrl,
+	.try_ctrl = hi1339_try_ctrl,
+	.s_ctrl = hi1339_set_ctrl,
+};
+
+static int hi1339_init_ext_controls(struct v4l2_ctrl_handler *ctrl_hdlr)
+{
+	return 0;
+}
+
+
+
+static int hi1339_start_streaming(struct hi1339 *hi1339)
+{
+	const struct hi1339_mode *mode;
+	const struct hi1339_reg_list *reg_list;
+	int link_freq_index;
+	int ret;
+
+	dev_info(hi1339->dev, "%s ++\n", __func__);
+
+	mutex_lock(&hi1339->mutex);
+
+	link_freq_index = hi1339->cur_mode->link_freq_index;
+	dev_info(hi1339->dev, "----link_freq_index = %d ",
+	         link_freq_index);
+
+	reg_list = &link_freq_configs[link_freq_index].reg_list;
+	ret = hi1339_write_reg_list(hi1339, reg_list);
+	if (ret) {
+		dev_err(hi1339->dev, "failed to set mode");
+		goto error;
+	}
+
+	mode = hi1339->cur_mode;
+	dev_info(hi1339->dev, "----write regtbl: mode(id:%d, WxH:%dx%d)",
+            mode->mode_id,
+            mode->width, mode->height);
+
+	reg_list = &mode->reg_list;
+	ret = hi1339_write_reg_list(hi1339, reg_list);
+	if (ret < 0) {
+		dev_err(hi1339->dev, "could not sent mode table %d\n", ret);
+		goto error;
+	}
+
+
+	ret = __v4l2_ctrl_handler_setup(hi1339->sd.ctrl_handler);
+	if (ret < 0) {
+		dev_err(hi1339->dev, "could not sync v4l2 controls\n");
+		goto error;
+	}
+
+	ret = hi1339_write_reg(hi1339, HI1339_STRAEMING_REG,
+	                       HI1339_REG_VALUE_16BIT, HI1339_MODE_STREAMING);
+
+	if (ret) {
+		dev_err(hi1339->dev, "failed to set stream on");
+		return ret;
+	}
+
+	mutex_unlock(&hi1339->mutex);
+
+	dev_info(hi1339->dev, "%s --\n", __func__);
+
+	return 0;
+
+error:
+	mutex_unlock(&hi1339->mutex);
+	return ret;
+}
+
+static int hi1339_stop_streaming(struct hi1339 *hi1339)
+{
+	int ret;
+
+	dev_info(hi1339->dev, "%s ++\n", __func__);
+
+	ret = hi1339_write_reg(hi1339, HI1339_STRAEMING_REG,
+	                       HI1339_REG_VALUE_16BIT, HI1339_MODE_STANDBY);
+	if (ret) {
+		dev_err(hi1339->dev, "failed to set stream off");
+		return ret;
+	}
+
+	dev_info(hi1339->dev, "%s --\n", __func__);
+
+	return ret;
+}
+
+static int hi1339_s_stream(struct v4l2_subdev *subdev, int enable)
+{
+	struct hi1339 *hi1339 = to_hi1339(subdev);
+	int ret;
+
+	if (hi1339->streaming == enable)
+		return 0;
+
+	if (enable) {
+		ret = pm_runtime_resume_and_get(hi1339->dev);
+		if (ret < 0)
+			return ret;
+
+		ret = hi1339_start_streaming(hi1339);
+		if (ret < 0)
+			goto err_rpm_put;
+	} else {
+		ret = hi1339_stop_streaming(hi1339);
+		if (ret < 0)
+			goto err_rpm_put;
+		pm_runtime_put(hi1339->dev);
+	}
+
+	hi1339->streaming = enable;
+	return 0;
+
+err_rpm_put:
+	pm_runtime_put(hi1339->dev);
+	return ret;
+}
+
+static int hi1339_g_mbus_config(struct v4l2_subdev *sd, unsigned int pad,
+                                struct v4l2_mbus_config *config)
+{
+	config->type = V4L2_MBUS_CSI2_DPHY;
+	config->bus.mipi_csi2.num_data_lanes = 4;
+	config->bus.mipi_csi2.flags = 0;
+	return 0;
+}
+
+static int hi1339_g_frame_interval(struct v4l2_subdev *subdev,
+                                   struct v4l2_subdev_frame_interval *fival)
+{
+	struct hi1339 *hi1339 = to_hi1339(subdev);
+
+	fival->interval.numerator = 1;
+	fival->interval.denominator = hi1339->cur_mode->max_framerate / 10;
+
+	return 0;
+}
+
+static int hi1339_enum_frame_interval(struct v4l2_subdev *subdev,
+                                      struct v4l2_subdev_state *sd_state,
+                                      struct v4l2_subdev_frame_interval_enum *fie)
+{
+	const struct hi1339_mode *mode;
+
+	if (fie->index != 0)
+		return -EINVAL;
+
+	mode = v4l2_find_nearest_size(hi1339_modes,
+	                              ARRAY_SIZE(hi1339_modes), width, height,
+	                              fie->width, fie->height);
+
+	fie->code = HI1339_MBUS_CODE;
+	fie->width = mode->width;
+	fie->height = mode->height;
+	fie->interval.numerator = 1;
+	fie->interval.denominator = mode->max_framerate / 10;
+
+	return 0;
+}
+
+static const struct v4l2_subdev_video_ops hi1339_video_ops = {
+	.s_stream = hi1339_s_stream,
+	.g_frame_interval = hi1339_g_frame_interval,
+	.s_frame_interval = hi1339_g_frame_interval,
+};
+
+static const struct v4l2_subdev_pad_ops hi1339_subdev_pad_ops = {
+	.enum_mbus_code = hi1339_enum_mbus_code,
+	.enum_frame_size = hi1339_enum_frame_size,
+	.enum_frame_interval = hi1339_enum_frame_interval,
+	.get_fmt = hi1339_get_format,
+	.set_fmt = hi1339_set_format,
+	.get_selection = hi1339_get_selection,
+	.init_cfg = hi1339_entity_init_cfg,
+	.get_mbus_config = hi1339_g_mbus_config,
+};
+
+static const struct v4l2_subdev_ops hi1339_subdev_ops = {
+	.core = &hi1339_core_ops,
+	.video = &hi1339_video_ops,
+	.pad = &hi1339_subdev_pad_ops,
+};
+
+static const struct regmap_config sensor_regmap_config = {
+	.reg_bits = 16,
+	.val_bits = 8,
+	.cache_type = REGCACHE_RBTREE,
+};
+
+static int hi1339_get_regulators(struct device *dev, struct hi1339 *hi1339)
+{
+	unsigned int i;
+
+	for (i = 0; i < HI1339_NUM_SUPPLIES; i++)
+		hi1339->supplies[i].supply = hi1339_supply_name[i];
+
+	return devm_regulator_bulk_get(dev, HI1339_NUM_SUPPLIES,
+	                               hi1339->supplies);
+}
+
+static int hi1339_parse_fwnode(struct device *dev)
+{
+	struct fwnode_handle *endpoint;
+	struct v4l2_fwnode_endpoint bus_cfg = {
+		.bus_type = V4L2_MBUS_CSI2_DPHY,
+	};
+	unsigned int i, j;
+	int ret;
+
+	endpoint = fwnode_graph_get_next_endpoint(dev_fwnode(dev), NULL);
+	if (!endpoint) {
+		dev_err(dev, "endpoint node not found\n");
+		return -EINVAL;
+	}
+
+	ret = v4l2_fwnode_endpoint_alloc_parse(endpoint, &bus_cfg);
+	if (ret) {
+		dev_err(dev, "parsing endpoint node failed\n");
+		goto done;
+	}
+
+	if (!bus_cfg.nr_of_link_frequencies) {
+		dev_err(dev, "no link frequencies defined");
+		ret = -EINVAL;
+		goto done;
+	}
+
+	for (i = 0; i < ARRAY_SIZE(link_freq_menu_items); i++) {
+		for (j = 0; j < bus_cfg.nr_of_link_frequencies; j++) {
+			if (link_freq_menu_items[i] == bus_cfg.link_frequencies[j])
+				break;
+		}
+
+		if (j == bus_cfg.nr_of_link_frequencies) {
+			dev_err(dev, "no link frequency %lld supported, please check DT",
+			        link_freq_menu_items[i]);
+			ret = -EINVAL;
+			goto done;
+		}
+	}
+
+done:
+	v4l2_fwnode_endpoint_free(&bus_cfg);
+	fwnode_handle_put(endpoint);
+	return ret;
+}
+
+static int __maybe_unused hi1339_suspend(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct hi1339 *hi1339 = to_hi1339(sd);
+
+	if (hi1339->streaming)
+		hi1339_stop_streaming(hi1339);
+
+	return 0;
+}
+
+static int __maybe_unused hi1339_resume(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct hi1339 *hi1339 = to_hi1339(sd);
+	int ret;
+
+	if (hi1339->streaming) {
+		ret = hi1339_start_streaming(hi1339);
+		if (ret)
+			goto error;
+	}
+
+	return 0;
+
+error:
+	hi1339_stop_streaming(hi1339);
+	hi1339->streaming = 0;
+	return ret;
+}
+
+
+static int hi1339_init_controls(struct hi1339 *hi1339)
+{
+	struct v4l2_ctrl_handler *ctrl_hdlr;
+	int ret;
+	s64 exposure_max, h_blank;
+
+	ctrl_hdlr = &hi1339->ctrl_handler;
+	ret = v4l2_ctrl_handler_init(ctrl_hdlr, 10);
+	if (ret)
+		return ret;
+
+	ctrl_hdlr->lock = &hi1339->mutex;
+	hi1339->link_freq = v4l2_ctrl_new_int_menu(ctrl_hdlr, &hi1339_ctrl_ops,
+	                    V4L2_CID_LINK_FREQ,
+	                    ARRAY_SIZE(link_freq_menu_items) - 1,
+	                    0, link_freq_menu_items);
+	if (hi1339->link_freq)
+		hi1339->link_freq->flags |= V4L2_CTRL_FLAG_READ_ONLY;
+
+	hi1339->pixel_rate = v4l2_ctrl_new_std(ctrl_hdlr, &hi1339_ctrl_ops,
+	                      V4L2_CID_PIXEL_RATE, 0,
+	                      to_pixel_rate(HI1339_LINK_FREQ_1440MBPS),
+	                      1,
+	                      to_pixel_rate(HI1339_LINK_FREQ_1440MBPS));
+
+	hi1339->vblank = v4l2_ctrl_new_std(ctrl_hdlr, &hi1339_ctrl_ops,
+	                                   V4L2_CID_VBLANK,
+	                                   hi1339->cur_mode->vts_min -
+	                                   hi1339->cur_mode->height,
+	                                   HI1339_FLL_MAX -
+	                                   hi1339->cur_mode->height, 1,
+	                                   hi1339->cur_mode->vts_def -
+	                                   hi1339->cur_mode->height);
+
+	h_blank = hi1339->cur_mode->hts - hi1339->cur_mode->width;
+	hi1339->hblank = v4l2_ctrl_new_std(ctrl_hdlr, &hi1339_ctrl_ops,
+	                                   V4L2_CID_HBLANK, h_blank, h_blank, 1,
+	                                   h_blank);
+	if (hi1339->hblank)
+		hi1339->hblank->flags |= V4L2_CTRL_FLAG_READ_ONLY;
+
+	v4l2_ctrl_new_std(ctrl_hdlr, &hi1339_ctrl_ops, V4L2_CID_ANALOGUE_GAIN,
+	                  HI1339_AGAIN_MIN, HI1339_AGAIN_MAX,
+	                  HI1339_AGAIN_STEP, HI1339_AGAIN_MIN);
+	v4l2_ctrl_new_std(ctrl_hdlr, &hi1339_ctrl_ops, V4L2_CID_DIGITAL_GAIN,
+	                  HI1339_DGAIN_MIN, HI1339_DGAIN_MAX,
+	                  HI1339_DGAIN_STEP, HI1339_DGAIN_DEFAULT);
+
+	exposure_max = hi1339->cur_mode->vts_def - HI1339_EXPOSURE_MAX_MARGIN;
+	hi1339->exposure = v4l2_ctrl_new_std(ctrl_hdlr, &hi1339_ctrl_ops,
+	                                     V4L2_CID_EXPOSURE,
+	                                     HI1339_EXPOSURE_MIN, exposure_max,
+	                                     HI1339_EXPOSURE_STEP,
+	                                     exposure_max);
+
+	v4l2_ctrl_new_std_menu_items(ctrl_hdlr, &hi1339_ctrl_ops,
+	                             V4L2_CID_TEST_PATTERN,
+	                             ARRAY_SIZE(hi1339_test_pattern_menu) - 1,
+	                             0, 0, hi1339_test_pattern_menu);
+	hi1339->hflip = v4l2_ctrl_new_std(ctrl_hdlr, &hi1339_ctrl_ops,
+	                                  V4L2_CID_HFLIP, 0, 1, 1, 0);
+	hi1339->vflip = v4l2_ctrl_new_std(ctrl_hdlr, &hi1339_ctrl_ops,
+	                                  V4L2_CID_VFLIP, 0, 1, 1, 0);
+
+
+	if (ctrl_hdlr->error)
+		return ctrl_hdlr->error;
+
+	hi1339->sd.ctrl_handler = ctrl_hdlr;
+
+	return 0;
+}
+
+
+
+static int hi1339_probe(struct i2c_client *client)
+{
+	struct device *dev = &client->dev;
+	struct hi1339 *hi1339;
+	int ret;
+
+	dev_info(dev, "--- %s +", __func__);
+
+	ret = hi1339_parse_fwnode(dev);
+	if (ret)
+		return ret;
+
+	hi1339 = devm_kzalloc(dev, sizeof(*hi1339), GFP_KERNEL);
+	if (!hi1339)
+		return -ENOMEM;
+
+	hi1339->dev = dev;
+
+	hi1339->xclk = devm_clk_get(dev, NULL);
+	if (IS_ERR(hi1339->xclk)) {
+		dev_err(dev, "could not get xclk\n");
+		return PTR_ERR(hi1339->xclk);
+	}
+
+	ret = clk_set_rate(hi1339->xclk, HI1339_DEFAULT_CLK_FREQ);
+	if (ret) {
+		dev_err(dev, "could not set xclk frequency\n");
+		return ret;
+	}
+
+	ret = hi1339_get_regulators(dev, hi1339);
+	if (ret < 0) {
+		dev_err(dev, "cannot get regulators\n");
+		return ret;
+	}
+
+	hi1339->enable_gpio = devm_gpiod_get(dev, "enable", GPIOD_OUT_LOW);
+	if (IS_ERR(hi1339->enable_gpio)) {
+		dev_err(dev, "cannot get enable gpio\n");
+		return PTR_ERR(hi1339->enable_gpio);
+	}
+
+	hi1339->regmap = devm_regmap_init_i2c(client, &sensor_regmap_config);
+	if (IS_ERR(hi1339->regmap)) {
+		dev_err(dev, "regmap init failed\n");
+		return PTR_ERR(hi1339->regmap);
+	}
+
+	v4l2_i2c_subdev_init(&hi1339->sd, client, &hi1339_subdev_ops);
+
+
+	/*
+	 * Enable power initially, to avoid warnings
+	 * from clk_disable on power_off
+	 */
+	hi1339_power_on(hi1339->dev);
+
+	ret = hi1339_identify_module(hi1339);
+	if (ret) {
+		dev_err(&client->dev, "failed to find sensor: %d\n", ret);
+		hi1339_power_off(hi1339->dev);
+		return ret;
+	}
+
+	mutex_init(&hi1339->mutex);
+	hi1339->cur_mode = &hi1339_modes[0];
+
+	ret = hi1339_init_controls(hi1339);
+	if (ret) {
+		dev_err(&client->dev, "failed to init controls: %d", ret);
+		goto free_ctrl;
+	}
+
+	hi1339->sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+	hi1339->pad.flags = MEDIA_PAD_FL_SOURCE;
+	hi1339->sd.dev = &client->dev;
+	hi1339->sd.entity.function = MEDIA_ENT_F_CAM_SENSOR;
+
+	// Init ExtCMD
+	ret = hi1339_init_ext_controls(hi1339->sd.ctrl_handler);
+	if (ret) {
+		dev_err(&client->dev, "failed to init controls: %d", ret);
+		goto free_ctrl;
+	}
+
+	dev_dbg(&client->dev, "hi1339->sd.name: %s, dev->of_node->name: %s\n",
+	        hi1339->sd.name, dev->of_node->name);
+	if (V4L2_SUBDEV_NAME_SIZE - strlen(hi1339->sd.name) - 2
+	    < strlen(dev->of_node->name)) {
+		dev_err(&client->dev,
+		        "the string length of (sd.name + of_node->name) is too long.\n");
+		return -EINVAL;
+	}
+	strncat(hi1339->sd.name, " ", 1);
+	strncat(hi1339->sd.name, dev->of_node->name,
+	        V4L2_SUBDEV_NAME_SIZE - strlen(hi1339->sd.name) - 2);
+	dev_dbg(&client->dev, "after: hi1339->sd.name: %s\n", hi1339->sd.name);
+
+
+	ret = media_entity_pads_init(&hi1339->sd.entity, 1, &hi1339->pad);
+	if (ret < 0) {
+		dev_err(dev, "could not register media entity\n");
+		goto free_ctrl;
+	}
+
+	ret = v4l2_async_register_subdev_sensor(&hi1339->sd);
+	if (ret < 0) {
+		dev_err(dev, "could not register v4l2 device\n");
+		goto free_entity;
+	}
+
+	pm_runtime_set_active(hi1339->dev);
+	pm_runtime_enable(hi1339->dev);
+	pm_runtime_idle(hi1339->dev);
+
+
+	dev_info(dev, "--- %s -", __func__);
+
+	return 0;
+
+free_entity:
+	media_entity_cleanup(&hi1339->sd.entity);
+free_ctrl:
+	mutex_destroy(&hi1339->mutex);
+	v4l2_ctrl_handler_free(hi1339->sd.ctrl_handler);
+	pm_runtime_disable(hi1339->dev);
+
+	return ret;
+}
+
+static void hi1339_remove(struct i2c_client *client)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct hi1339 *hi1339 = to_hi1339(sd);
+
+	v4l2_async_unregister_subdev(sd);
+	media_entity_cleanup(&sd->entity);
+	v4l2_ctrl_handler_free(sd->ctrl_handler);
+
+	pm_runtime_disable(&client->dev);
+	pm_runtime_set_suspended(&client->dev);
+
+	mutex_destroy(&hi1339->mutex);
+
+	return;
+}
+
+static const struct of_device_id hi1339_of_match[] = {
+	{ .compatible = "Hynix,hi1339" },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, hi1339_of_match);
+
+static const struct dev_pm_ops hi1339_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(hi1339_suspend, hi1339_resume)
+	SET_RUNTIME_PM_OPS(hi1339_power_off, hi1339_power_on, NULL)
+};
+
+static struct i2c_driver hi1339_i2c_driver = {
+	.driver = {
+		.of_match_table = hi1339_of_match,
+		.pm = &hi1339_pm_ops,
+		.name  = "hi1339",
+	},
+	.probe_new  = hi1339_probe,
+	.remove = hi1339_remove,
+};
+
+module_i2c_driver(hi1339_i2c_driver);
+
+MODULE_DESCRIPTION("Hynix hi1339 Camera driver");
+MODULE_AUTHOR("Zhi Mao <zhi.mao@mediatek.com>");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/media/mc/mc-device.c b/drivers/media/mc/mc-device.c
old mode 100644
new mode 100755
index 25020d58eb06e85bcd2bfe0afbea3665b3ee0de8..341af7df069f5349a1650c9dc53d7f9f2012f802
--- a/drivers/media/mc/mc-device.c
+++ b/drivers/media/mc/mc-device.c
@@ -225,6 +225,7 @@ static long media_device_setup_link(struct media_device *mdev, void *arg)
 
 	/* Setup the link on both entities. */
 	return __media_entity_setup_link(link, linkd->flags);
+
 }
 
 static long media_device_get_topology(struct media_device *mdev, void *arg)
diff --git a/drivers/media/platform/mediatek/Kconfig b/drivers/media/platform/mediatek/Kconfig
index 84104e2cd02447790ae5c29953a2e82ca4fdd0a7..05a3d77472bafef37240253a067e7448d6aac538 100644
--- a/drivers/media/platform/mediatek/Kconfig
+++ b/drivers/media/platform/mediatek/Kconfig
@@ -7,3 +7,5 @@ source "drivers/media/platform/mediatek/mdp/Kconfig"
 source "drivers/media/platform/mediatek/vcodec/Kconfig"
 source "drivers/media/platform/mediatek/vpu/Kconfig"
 source "drivers/media/platform/mediatek/mdp3/Kconfig"
+source "drivers/media/platform/mediatek/isp/Kconfig"
+source "drivers/media/platform/mediatek/aie/Kconfig"
diff --git a/drivers/media/platform/mediatek/Makefile b/drivers/media/platform/mediatek/Makefile
index 38e6ba917fe5cdd932aa6c88221c9a7aa5a7705a..12679ab6ad14197d554821d9df7d7eea3cff57af 100644
--- a/drivers/media/platform/mediatek/Makefile
+++ b/drivers/media/platform/mediatek/Makefile
@@ -4,3 +4,5 @@ obj-y += mdp/
 obj-y += vcodec/
 obj-y += vpu/
 obj-y += mdp3/
+obj-y += aie/
+obj-y += isp/isp_7x/
diff --git a/drivers/media/platform/mediatek/aie/Kconfig b/drivers/media/platform/mediatek/aie/Kconfig
new file mode 100644
index 0000000000000000000000000000000000000000..28828055b6f71601e04ca654c004ef8f83fbd2ff
--- /dev/null
+++ b/drivers/media/platform/mediatek/aie/Kconfig
@@ -0,0 +1,11 @@
+config VIDEO_MTK_AIE
+	tristate "Mediatek AI engine function"
+	select V4L2_MEM2MEM_DEV
+	select VIDEOBUF2_DMA_CONTIG
+	select MEDIA_CONTROLLER_REQUEST_API
+	help
+		Support the AI engine (AIE) feature
+
+		AIE driver is a V4L2 memory-to-memory device driver which
+		provides hardware accelerated face detection function,
+		it can detect different sizes of faces in a raw image.
diff --git a/drivers/media/platform/mediatek/aie/Makefile b/drivers/media/platform/mediatek/aie/Makefile
new file mode 100644
index 0000000000000000000000000000000000000000..2e119a24e298d3f2ab9d503b6317831053acfa75
--- /dev/null
+++ b/drivers/media/platform/mediatek/aie/Makefile
@@ -0,0 +1,22 @@
+# SPDX-License-Identifier: GPL-2.0
+
+ifneq ($(filter y m,$(CONFIG_INTERCONNECT_MTK_EXTENSION)),)
+ifeq ($(DEVICE_MODULES_PATH), )
+ccflags-$(CONFIG_VIDEO_MTK_AIE) += -I$(srctree)/drivers/misc/mediatek/mtk-interconnect/
+else
+ccflags-$(CONFIG_VIDEO_MTK_AIE) += -I$(DEVICE_MODULES_PATH)/drivers/misc/mediatek/mtk-interconnect/
+endif
+endif
+
+ifneq ($(filter y m,$(CONFIG_REGULATOR_MTK_VMM)),)
+ifeq ($(DEVICE_MODULES_PATH), )
+ccflags-$(CONFIG_VIDEO_MTK_AIE) += -I$(srctree)/drivers/media/platform/mtk-isp/mtk-vmm/
+else
+ccflags-$(CONFIG_VIDEO_MTK_AIE) += -I$(DEVICE_MODULES_PATH)/drivers/media/platform/mtk-isp/mtk-vmm/
+endif
+endif
+
+mtk_aie-$(CONFIG_VIDEO_MTK_AIE) += mtk_aie_53.o
+mtk_aie-$(CONFIG_VIDEO_MTK_AIE) += mtk_aie_drv.o
+
+obj-$(CONFIG_VIDEO_MTK_AIE) += mtk_aie.o
diff --git a/drivers/media/platform/mediatek/aie/mtk_aie.h b/drivers/media/platform/mediatek/aie/mtk_aie.h
new file mode 100644
index 0000000000000000000000000000000000000000..bf1600acb775045777be3f2d9f28fefbade2e240
--- /dev/null
+++ b/drivers/media/platform/mediatek/aie/mtk_aie.h
@@ -0,0 +1,1080 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+//
+// Copyright (c) 2018 MediaTek Inc.
+
+#ifndef __MTK_AIE_H__
+#define __MTK_AIE_H__
+
+#include <linux/completion.h>
+#include <linux/io.h>
+#include <linux/platform_device.h>
+#include <linux/pm_opp.h>
+#include <linux/regulator/consumer.h>
+#include <linux/types.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-device.h>
+#include <media/videobuf2-v4l2.h>
+
+// AIE 3.X
+
+#ifdef CONFIG_INTERCONNECT_MTK_EXTENSION
+#include "mtk-interconnect.h"
+#endif
+
+#define V4L2_META_FMT_MTFD_RESULT  v4l2_fourcc('M', 'T', 'f', 'd')
+
+// AIE 3.X
+#define MTK_AIE_OPP_SET			1
+#define MTK_AIE_CLK_LEVEL_CNT		4
+
+#define FD_VERSION 1946050
+#define ATTR_VERSION 1929401
+
+#define Y2R_SRC_DST_FORMAT 0
+#define Y2R_IN_W_H 1
+#define Y2R_OUT_W_H 2
+#define Y2R_RA0_RA1_EN 3
+#define Y2R_IN_X_Y_SIZE0 4
+#define Y2R_IN_STRIDE0_BUS_SIZE0 5
+#define Y2R_IN_X_Y_SIZE1 6
+#define Y2R_IN_STRIDE1_BUS_SIZE1 7
+#define Y2R_OUT_X_Y_SIZE0 8
+#define Y2R_OUT_STRIDE0_BUS_SIZE0 9
+#define Y2R_OUT_X_Y_SIZE1 10
+#define Y2R_OUT_STRIDE1_BUS_SIZE1 11
+#define Y2R_OUT_X_Y_SIZE2 12
+#define Y2R_OUT_STRIDE2_BUS_SIZE2 13
+#define Y2R_IN_0 14
+#define Y2R_IN_1 15
+#define Y2R_OUT_0 16
+#define Y2R_OUT_1 17
+#define Y2R_OUT_2 18
+#define Y2R_RS_SEL_SRZ_EN 19
+#define Y2R_X_Y_MAG 20
+#define Y2R_SRZ_HORI_STEP 22
+#define Y2R_SRZ_VERT_STEP 23
+#define Y2R_PADDING_EN_UP_DOWN 26
+#define Y2R_PADDING_RIGHT_LEFT 27
+#define Y2R_CO2_FMT_MODE_EN 28 /* AIE3.0 new */
+#define Y2R_CO2_CROP_X 29      /* AIE3.0 new */
+#define Y2R_CO2_CROP_Y 30      /* AIE3.0 new */
+#define Y2R_CON_IN_BA_MSB 31	/* MSB */
+#define Y2R_CON_OUT_BA_MSB 32	/* MSB */
+
+#define RS_IN_0 22
+#define RS_IN_1 23
+#define RS_IN_2 24
+#define RS_OUT_0 25
+#define RS_OUT_1 26
+#define RS_OUT_2 27
+#define RS_X_Y_MAG 1
+#define RS_SRZ_HORI_STEP 3
+#define RS_SRZ_VERT_STEP 4
+#define RS_INPUT_W_H 7
+#define RS_OUTPUT_W_H 8
+#define RS_IN_X_Y_SIZE0 10
+#define RS_IN_STRIDE0 11
+#define RS_IN_X_Y_SIZE1 12
+#define RS_IN_STRIDE1 13
+#define RS_IN_X_Y_SIZE2 14
+#define RS_IN_STRIDE2 15
+#define RS_OUT_X_Y_SIZE0 16
+#define RS_OUT_STRIDE0 17
+#define RS_OUT_X_Y_SIZE1 18
+#define RS_OUT_STRIDE1 19
+#define RS_OUT_X_Y_SIZE2 20
+#define RS_OUT_STRIDE2 21
+// AIE 3.X
+#define RS_CON_IN_BA_MSB 28	/* MSB */
+#define RS_CON_OUT_BA_MSB 29	/* MSB */
+
+#define FD_INPUT_ROTATE 1
+#define FD_CONV_WIDTH_MOD6 2
+#define FD_CONV_IMG_W_H 4
+
+#define FD_IN_IMG_W_H 5
+#define FD_OUT_IMG_W_H 6
+
+#define FD_IN_X_Y_SIZE0 9
+#define FD_IN_X_Y_SIZE1 11
+#define FD_IN_X_Y_SIZE2 13
+#define FD_IN_X_Y_SIZE3 15
+
+#define FD_IN_STRIDE0_BUS_SIZE0 10
+#define FD_IN_STRIDE1_BUS_SIZE1 12
+#define FD_IN_STRIDE2_BUS_SIZE2 14
+#define FD_IN_STRIDE3_BUS_SIZE3 16
+
+#define FD_OUT_X_Y_SIZE0 17
+#define FD_OUT_X_Y_SIZE1 19
+#define FD_OUT_X_Y_SIZE2 21
+#define FD_OUT_X_Y_SIZE3 23
+
+#define FD_OUT_STRIDE0_BUS_SIZE0 18
+#define FD_OUT_STRIDE1_BUS_SIZE1 20
+#define FD_OUT_STRIDE2_BUS_SIZE2 22
+#define FD_OUT_STRIDE3_BUS_SIZE3 24
+
+#define FD_IN_0 27
+#define FD_IN_1 28
+#define FD_IN_2 29
+#define FD_IN_3 30
+
+#define FD_OUT_0 31
+#define FD_OUT_1 32
+#define FD_OUT_2 33
+#define FD_OUT_3 34
+
+#define FD_KERNEL_0 35
+#define FD_KERNEL_1 36
+
+#define FD_RPN_SET 37
+#define FD_IMAGE_COORD 38
+#define FD_IMAGE_COORD_XY_OFST 39   /* AIE3.0 new */
+#define FD_BIAS_ACCU 47		    /* AIE3.0 new */
+#define FD_SRZ_FDRZ_RS 48	   /* AIE3.0 new */
+#define FD_SRZ_HORI_STEP 49	 /* AIE3.0 new */
+#define FD_SRZ_VERT_STEP 50	 /* AIE3.0 new */
+#define FD_SRZ_HORI_SUB_INT_OFST 51 /* AIE3.0 new */
+#define FD_SRZ_VERT_SUB_INT_OFST 52 /* AIE3.0 new */
+// AIE 3.X
+#define FD_CON_IN_BA_MSB 53		/* MSB */
+#define FD_CON_OUT_BA_MSB 54		/* MSB */
+#define FD_CON_KERNEL_BA_MSB 55		/* MSB */
+
+#define SRZ_BIT (BIT_MASK(16)|BIT_MASK(12)|BIT_MASK(8)|BIT_MASK(0))
+
+#define result_size 49152		/* 4*12*1024=49152 */
+
+#define fd_loop_num 87
+#define rpn0_loop_num 86
+#define rpn1_loop_num 57
+#define rpn2_loop_num 28
+
+#define pym0_start_loop 58
+#define pym1_start_loop 29
+#define pym2_start_loop 0
+
+#define attr_loop_num 26
+#define age_out_rgs 17
+#define gender_out_rgs 20
+#define indian_out_rgs 22
+#define race_out_rgs 25
+
+#define input_WDMA_WRA_num 4
+#define output_WDMA_WRA_num 4
+#define kernel_RDMA_RA_num 2
+
+#define MAX_ENQUE_FRAME_NUM 10
+#define PYM_NUM 3
+#define COLOR_NUM 3
+
+#define ATTR_MODE_PYRAMID_WIDTH 128
+#define ATTR_OUT_SIZE 32
+
+/* AIE 2.0 3.X register offset */
+#define AIE_START_REG 0x000
+#define AIE_ENABLE_REG 0x004
+#define AIE_LOOP_REG 0x008
+#define AIE_YUV2RGB_CON_BASE_ADR_REG 0x00c
+#define AIE_RS_CON_BASE_ADR_REG 0x010
+#define AIE_FD_CON_BASE_ADR_REG 0x014
+#define AIE_INT_EN_REG 0x018
+#define AIE_INT_REG 0x01c
+#define AIE_RESULT_0_REG 0x08c
+#define AIE_RESULT_1_REG 0x090
+#define AIE_DMA_CTL_REG 0x094
+/* AIE 3.0 register offset */
+
+#define AIE_YUV2RGB_CON_BASE_ADR_MSB    0x14C
+#define AIE_RS_CON_BASE_ADR_MSB         0x150
+#define AIE_FD_CON_BASE_ADR_MSB         0x154
+
+/* AIE 3.0 FLD register offset */
+#define FLD_EN                       0x400
+#define FLD_BASE_ADDR_FACE_0         0x404
+#define FLD_BASE_ADDR_FACE_1         0x408
+#define FLD_BASE_ADDR_FACE_2         0x40C
+#define FLD_BASE_ADDR_FACE_3         0x410
+#define FLD_BASE_ADDR_FACE_4         0x414
+#define FLD_BASE_ADDR_FACE_5         0x418
+#define FLD_BASE_ADDR_FACE_6         0x41C
+#define FLD_BASE_ADDR_FACE_7         0x420
+#define FLD_BASE_ADDR_FACE_8         0x424
+#define FLD_BASE_ADDR_FACE_9         0x428
+#define FLD_BASE_ADDR_FACE_10        0x42C
+#define FLD_BASE_ADDR_FACE_11        0x430
+#define FLD_BASE_ADDR_FACE_12        0x434
+#define FLD_BASE_ADDR_FACE_13        0x438
+#define FLD_BASE_ADDR_FACE_14        0x43C
+
+#define FLD_INFO_0_FACE_0            0x440
+#define FLD_INFO_1_FACE_0            0x444
+#define FLD_INFO_2_FACE_0            0x448
+#define FLD_INFO_0_FACE_1            0x44C
+#define FLD_INFO_1_FACE_1            0x450
+#define FLD_INFO_2_FACE_1            0x454
+#define FLD_INFO_0_FACE_2            0x458
+#define FLD_INFO_1_FACE_2            0x45C
+#define FLD_INFO_2_FACE_2            0x460
+#define FLD_INFO_0_FACE_3            0x464
+#define FLD_INFO_1_FACE_3            0x468
+#define FLD_INFO_2_FACE_3            0x46C
+#define FLD_INFO_0_FACE_4            0x470
+#define FLD_INFO_1_FACE_4            0x474
+#define FLD_INFO_2_FACE_4            0x478
+#define FLD_INFO_0_FACE_5            0x47C
+#define FLD_INFO_1_FACE_5            0x480
+#define FLD_INFO_2_FACE_5            0x484
+#define FLD_INFO_0_FACE_6            0x488
+#define FLD_INFO_1_FACE_6            0x48C
+#define FLD_INFO_2_FACE_6            0x490
+#define FLD_INFO_0_FACE_7            0x494
+#define FLD_INFO_1_FACE_7            0x498
+
+#define FLD_INFO_2_FACE_7            0x4A0
+#define FLD_INFO_0_FACE_8            0x4A4
+#define FLD_INFO_1_FACE_8            0x4A8
+#define FLD_INFO_2_FACE_8            0x4AC
+#define FLD_INFO_0_FACE_9            0x4B0
+#define FLD_INFO_1_FACE_9            0x4B4
+#define FLD_INFO_2_FACE_9            0x4B8
+#define FLD_INFO_0_FACE_10           0x4BC
+#define FLD_INFO_1_FACE_10           0x4C0
+#define FLD_INFO_2_FACE_10           0x4C4
+#define FLD_INFO_0_FACE_11           0x4C8
+#define FLD_INFO_1_FACE_11           0x4CC
+#define FLD_INFO_2_FACE_11           0x4D0
+#define FLD_INFO_0_FACE_12           0x4D4
+#define FLD_INFO_1_FACE_12           0x4D8
+#define FLD_INFO_2_FACE_12           0x4DC
+#define FLD_INFO_0_FACE_13           0x4E0
+#define FLD_INFO_1_FACE_13           0x4E4
+#define FLD_INFO_2_FACE_13           0x4E8
+#define FLD_INFO_0_FACE_14           0x4EC
+#define FLD_INFO_1_FACE_14           0x4F0
+#define FLD_INFO_2_FACE_14           0x4F4
+
+#define FLD_MODEL_PARA0              0x4F8
+#define FLD_MODEL_PARA1              0x4FC
+#define FLD_MODEL_PARA2              0x500
+#define FLD_MODEL_PARA3              0x504
+#define FLD_MODEL_PARA4              0x508
+#define FLD_MODEL_PARA5              0x50C
+#define FLD_MODEL_PARA6              0x510
+#define FLD_MODEL_PARA7              0x514
+#define FLD_MODEL_PARA8              0x518
+#define FLD_MODEL_PARA9              0x51C
+#define FLD_MODEL_PARA10             0x520
+#define FLD_MODEL_PARA11             0x524
+#define FLD_MODEL_PARA12             0x528
+#define FLD_MODEL_PARA13             0x52C
+#define FLD_MODEL_PARA14             0x530
+#define FLD_MODEL_PARA15             0x534
+#define FLD_MODEL_PARA16             0x538
+#define FLD_DEBUG_INFO0              0x53C
+#define FLD_DEBUG_INFO1              0x540
+
+#define FLD_BUSY                     0x544
+#define FLD_DONE                     0x548
+#define FLD_SRC_WD_HT                0x54C
+
+#define FLD_PL_IN_BASE_ADDR_0_0      0x550
+#define FLD_PL_IN_BASE_ADDR_0_1      0x554
+#define FLD_PL_IN_BASE_ADDR_0_2      0x558
+#define FLD_PL_IN_BASE_ADDR_0_3      0x55C
+#define FLD_PL_IN_BASE_ADDR_0_4      0x560
+#define FLD_PL_IN_BASE_ADDR_0_5      0x564
+#define FLD_PL_IN_BASE_ADDR_0_6      0x568
+#define FLD_PL_IN_BASE_ADDR_0_7      0x56C
+#define FLD_PL_IN_BASE_ADDR_0_8      0x570
+#define FLD_PL_IN_BASE_ADDR_0_9      0x574
+#define FLD_PL_IN_BASE_ADDR_0_10     0x578
+#define FLD_PL_IN_BASE_ADDR_0_11     0x57C
+#define FLD_PL_IN_BASE_ADDR_0_12     0x580
+#define FLD_PL_IN_BASE_ADDR_0_13     0x584
+#define FLD_PL_IN_BASE_ADDR_0_14     0x588
+#define FLD_PL_IN_BASE_ADDR_0_15     0x58C
+#define FLD_PL_IN_BASE_ADDR_0_16     0x590
+#define FLD_PL_IN_BASE_ADDR_0_17     0x594
+#define FLD_PL_IN_BASE_ADDR_0_18     0x598
+#define FLD_PL_IN_BASE_ADDR_0_19     0x59C
+#define FLD_PL_IN_BASE_ADDR_0_20     0x5A0
+#define FLD_PL_IN_BASE_ADDR_0_21     0x5A4
+#define FLD_PL_IN_BASE_ADDR_0_22     0x5A8
+#define FLD_PL_IN_BASE_ADDR_0_23     0x5AC
+#define FLD_PL_IN_BASE_ADDR_0_24     0x5B0
+#define FLD_PL_IN_BASE_ADDR_0_25     0x5B4
+#define FLD_PL_IN_BASE_ADDR_0_26     0x5B8
+#define FLD_PL_IN_BASE_ADDR_0_27     0x5BC
+#define FLD_PL_IN_BASE_ADDR_0_28     0x5C0
+#define FLD_PL_IN_BASE_ADDR_0_29     0x5C4
+
+#define FLD_PL_IN_BASE_ADDR_1_0      0x5C8
+#define FLD_PL_IN_BASE_ADDR_1_1      0x5CC
+#define FLD_PL_IN_BASE_ADDR_1_2      0x5D0
+#define FLD_PL_IN_BASE_ADDR_1_3      0x5D4
+#define FLD_PL_IN_BASE_ADDR_1_4      0x5D8
+#define FLD_PL_IN_BASE_ADDR_1_5      0x5DC
+#define FLD_PL_IN_BASE_ADDR_1_6      0x5E0
+#define FLD_PL_IN_BASE_ADDR_1_7      0x5E4
+#define FLD_PL_IN_BASE_ADDR_1_8      0x5E8
+#define FLD_PL_IN_BASE_ADDR_1_9      0x5EC
+#define FLD_PL_IN_BASE_ADDR_1_10     0x5F0
+#define FLD_PL_IN_BASE_ADDR_1_11     0x5F4
+#define FLD_PL_IN_BASE_ADDR_1_12     0x5F8
+#define FLD_PL_IN_BASE_ADDR_1_13     0x5FC
+#define FLD_PL_IN_BASE_ADDR_1_14     0x600
+#define FLD_PL_IN_BASE_ADDR_1_15     0x604
+#define FLD_PL_IN_BASE_ADDR_1_16     0x608
+#define FLD_PL_IN_BASE_ADDR_1_17     0x60C
+#define FLD_PL_IN_BASE_ADDR_1_18     0x610
+#define FLD_PL_IN_BASE_ADDR_1_19     0x614
+#define FLD_PL_IN_BASE_ADDR_1_20     0x618
+#define FLD_PL_IN_BASE_ADDR_1_21     0x61C
+#define FLD_PL_IN_BASE_ADDR_1_22     0x620
+#define FLD_PL_IN_BASE_ADDR_1_23     0x624
+#define FLD_PL_IN_BASE_ADDR_1_24     0x628
+#define FLD_PL_IN_BASE_ADDR_1_25     0x62C
+#define FLD_PL_IN_BASE_ADDR_1_26     0x630
+#define FLD_PL_IN_BASE_ADDR_1_27     0x634
+#define FLD_PL_IN_BASE_ADDR_1_28     0x638
+#define FLD_PL_IN_BASE_ADDR_1_29     0x63C
+
+#define FLD_PL_IN_BASE_ADDR_2_0      0x640
+#define FLD_PL_IN_BASE_ADDR_2_1      0x644
+#define FLD_PL_IN_BASE_ADDR_2_2      0x648
+#define FLD_PL_IN_BASE_ADDR_2_3      0x64C
+#define FLD_PL_IN_BASE_ADDR_2_4      0x650
+#define FLD_PL_IN_BASE_ADDR_2_5      0x654
+#define FLD_PL_IN_BASE_ADDR_2_6      0x658
+#define FLD_PL_IN_BASE_ADDR_2_7      0x65C
+#define FLD_PL_IN_BASE_ADDR_2_8      0x660
+#define FLD_PL_IN_BASE_ADDR_2_9      0x664
+#define FLD_PL_IN_BASE_ADDR_2_10     0x668
+#define FLD_PL_IN_BASE_ADDR_2_11     0x66C
+#define FLD_PL_IN_BASE_ADDR_2_12     0x670
+#define FLD_PL_IN_BASE_ADDR_2_13     0x674
+#define FLD_PL_IN_BASE_ADDR_2_14     0x678
+#define FLD_PL_IN_BASE_ADDR_2_15     0x67C
+#define FLD_PL_IN_BASE_ADDR_2_16     0x680
+#define FLD_PL_IN_BASE_ADDR_2_17     0x684
+#define FLD_PL_IN_BASE_ADDR_2_18     0x688
+#define FLD_PL_IN_BASE_ADDR_2_19     0x68C
+#define FLD_PL_IN_BASE_ADDR_2_20     0x690
+#define FLD_PL_IN_BASE_ADDR_2_21     0x694
+#define FLD_PL_IN_BASE_ADDR_2_22     0x698
+#define FLD_PL_IN_BASE_ADDR_2_23     0x69C
+#define FLD_PL_IN_BASE_ADDR_2_24     0x6A0
+#define FLD_PL_IN_BASE_ADDR_2_25     0x6A4
+#define FLD_PL_IN_BASE_ADDR_2_26     0x6A8
+#define FLD_PL_IN_BASE_ADDR_2_27     0x6AC
+#define FLD_PL_IN_BASE_ADDR_2_28     0x6B0
+#define FLD_PL_IN_BASE_ADDR_2_29     0x6B4
+
+#define FLD_PL_IN_BASE_ADDR_3_0      0x6B8
+#define FLD_PL_IN_BASE_ADDR_3_1      0x6BC
+#define FLD_PL_IN_BASE_ADDR_3_2      0x6C0
+#define FLD_PL_IN_BASE_ADDR_3_3      0x6C4
+#define FLD_PL_IN_BASE_ADDR_3_4      0x6C8
+#define FLD_PL_IN_BASE_ADDR_3_5      0x6CC
+#define FLD_PL_IN_BASE_ADDR_3_6      0x6D0
+#define FLD_PL_IN_BASE_ADDR_3_7      0x6D4
+#define FLD_PL_IN_BASE_ADDR_3_8      0x6D8
+#define FLD_PL_IN_BASE_ADDR_3_9      0x6DC
+#define FLD_PL_IN_BASE_ADDR_3_10     0x6E0
+#define FLD_PL_IN_BASE_ADDR_3_11     0x6E4
+#define FLD_PL_IN_BASE_ADDR_3_12     0x6E8
+#define FLD_PL_IN_BASE_ADDR_3_13     0x6EC
+#define FLD_PL_IN_BASE_ADDR_3_14     0x6F0
+#define FLD_PL_IN_BASE_ADDR_3_15     0x6F4
+#define FLD_PL_IN_BASE_ADDR_3_16     0x6F8
+#define FLD_PL_IN_BASE_ADDR_3_17     0x6FC
+#define FLD_PL_IN_BASE_ADDR_3_18     0x700
+#define FLD_PL_IN_BASE_ADDR_3_19     0x704
+#define FLD_PL_IN_BASE_ADDR_3_20     0x708
+#define FLD_PL_IN_BASE_ADDR_3_21     0x70C
+#define FLD_PL_IN_BASE_ADDR_3_22     0x710
+#define FLD_PL_IN_BASE_ADDR_3_23     0x714
+#define FLD_PL_IN_BASE_ADDR_3_24     0x718
+#define FLD_PL_IN_BASE_ADDR_3_25     0x71C
+#define FLD_PL_IN_BASE_ADDR_3_26     0x720
+#define FLD_PL_IN_BASE_ADDR_3_27     0x724
+#define FLD_PL_IN_BASE_ADDR_3_28     0x728
+#define FLD_PL_IN_BASE_ADDR_3_29     0x72C
+
+#define FLD_PL_IN_SIZE_0             0x730
+#define FLD_PL_IN_STRIDE_0           0x734
+#define FLD_PL_IN_SIZE_1             0x738
+#define FLD_PL_IN_STRIDE_1           0x73C
+#define FLD_PL_IN_SIZE_2_0           0x740
+#define FLD_PL_IN_STRIDE_2_0         0x744
+#define FLD_PL_IN_SIZE_2_1           0x748
+#define FLD_PL_IN_STRIDE_2_1         0x74C
+#define FLD_PL_IN_SIZE_2_2           0x750
+#define FLD_PL_IN_STRIDE_2_2         0x754
+#define FLD_PL_IN_SIZE_3             0x758
+#define FLD_PL_IN_STRIDE_3           0x75C
+
+#define FLD_SH_IN_BASE_ADDR_0        0x760
+#define FLD_SH_IN_BASE_ADDR_1        0x764
+#define FLD_SH_IN_BASE_ADDR_2        0x768
+#define FLD_SH_IN_BASE_ADDR_3        0x76C
+#define FLD_SH_IN_BASE_ADDR_4        0x770
+#define FLD_SH_IN_BASE_ADDR_5        0x774
+#define FLD_SH_IN_BASE_ADDR_6        0x778
+#define FLD_SH_IN_BASE_ADDR_7        0x77C
+#define FLD_SH_IN_BASE_ADDR_8        0x780
+#define FLD_SH_IN_BASE_ADDR_9        0x784
+#define FLD_SH_IN_BASE_ADDR_10       0x788
+#define FLD_SH_IN_BASE_ADDR_11       0x78C
+#define FLD_SH_IN_BASE_ADDR_12       0x790
+#define FLD_SH_IN_BASE_ADDR_13       0x794
+#define FLD_SH_IN_BASE_ADDR_14       0x798
+#define FLD_SH_IN_BASE_ADDR_15       0x79C
+#define FLD_SH_IN_BASE_ADDR_16       0x7A0
+#define FLD_SH_IN_BASE_ADDR_17       0x7A4
+#define FLD_SH_IN_BASE_ADDR_18       0x7A8
+#define FLD_SH_IN_BASE_ADDR_19       0x7AC
+#define FLD_SH_IN_BASE_ADDR_20       0x7B0
+#define FLD_SH_IN_BASE_ADDR_21       0x7B4
+#define FLD_SH_IN_BASE_ADDR_22       0x7B8
+#define FLD_SH_IN_BASE_ADDR_23       0x7BC
+#define FLD_SH_IN_BASE_ADDR_24       0x7C0
+#define FLD_SH_IN_BASE_ADDR_25       0x7C4
+#define FLD_SH_IN_BASE_ADDR_26       0x7C8
+#define FLD_SH_IN_BASE_ADDR_27       0x7CC
+#define FLD_SH_IN_BASE_ADDR_28       0x7D0
+#define FLD_SH_IN_BASE_ADDR_29       0x7D4
+
+#define FLD_SH_IN_SIZE_0             0x7D8
+#define FLD_SH_IN_STRIDE_0           0x7DC
+#define FLD_TR_OUT_BASE_ADDR_0       0x7E0
+#define FLD_TR_OUT_SIZE_0            0x7E4
+#define FLD_TR_OUT_STRIDE_0          0x7E8
+#define FLD_PP_OUT_BASE_ADDR_0       0x7EC
+#define FLD_PP_OUT_SIZE_0            0x7F0
+#define FLD_PP_OUT_STRIDE_0          0x7F4
+#define FLD_SPARE                    0x7F8
+
+#define FLD_BASE_ADDR_FACE_0_7_MSB 0x7FC
+#define FLD_BASE_ADDR_FACE_8_14_MSB 0x800
+
+#define FLD_PL_IN_BASE_ADDR_0_0_7_MSB 0x804
+#define FLD_PL_IN_BASE_ADDR_0_8_15_MSB 0x808
+#define FLD_PL_IN_BASE_ADDR_0_16_23_MSB 0x80C
+#define FLD_PL_IN_BASE_ADDR_0_24_29_MSB 0x810
+
+#define FLD_PL_IN_BASE_ADDR_1_0_7_MSB 0x814
+#define FLD_PL_IN_BASE_ADDR_1_8_15_MSB 0x818
+#define FLD_PL_IN_BASE_ADDR_1_16_23_MSB 0x81C
+#define FLD_PL_IN_BASE_ADDR_1_24_29_MSB 0x820
+
+#define FLD_PL_IN_BASE_ADDR_2_0_7_MSB 0x824
+#define FLD_PL_IN_BASE_ADDR_2_8_15_MSB 0x828
+#define FLD_PL_IN_BASE_ADDR_2_16_23_MSB 0x82C
+#define FLD_PL_IN_BASE_ADDR_2_24_29_MSB 0x830
+
+#define FLD_PL_IN_BASE_ADDR_3_0_7_MSB 0x834
+#define FLD_PL_IN_BASE_ADDR_3_8_15_MSB 0x838
+#define FLD_PL_IN_BASE_ADDR_3_16_23_MSB 0x83C
+#define FLD_PL_IN_BASE_ADDR_3_24_29_MSB 0x840
+
+#define FLD_SH_IN_BASE_ADDR_0_7_MSB 0x844
+#define FLD_SH_IN_BASE_ADDR_8_15_MSB 0x848
+#define FLD_SH_IN_BASE_ADDR_16_23_MSB 0x84C
+#define FLD_SH_IN_BASE_ADDR_24_29_MSB 0x850
+
+#define FLD_BS_IN_BASE_ADDR_0_7_MSB 0x8d4
+#define FLD_BS_IN_BASE_ADDR_8_15_MSB 0x8d8
+
+#define FLD_TR_OUT_BASE_ADDR_0_MSB 0x854
+#define FLD_PP_OUT_BASE_ADDR_0_MSB 0x858
+
+#define FLD_BS_IN_BASE_ADDR_00       0x85C
+#define FLD_BS_IN_BASE_ADDR_01       0x860
+#define FLD_BS_IN_BASE_ADDR_02       0x864
+#define FLD_BS_IN_BASE_ADDR_03       0x868
+#define FLD_BS_IN_BASE_ADDR_04       0x86C
+#define FLD_BS_IN_BASE_ADDR_05       0x870
+#define FLD_BS_IN_BASE_ADDR_06       0x874
+#define FLD_BS_IN_BASE_ADDR_07       0x878
+#define FLD_BS_IN_BASE_ADDR_08       0x87C
+#define FLD_BS_IN_BASE_ADDR_09       0x880
+#define FLD_BS_IN_BASE_ADDR_10       0x884
+#define FLD_BS_IN_BASE_ADDR_11       0x888
+#define FLD_BS_IN_BASE_ADDR_12       0x88C
+#define FLD_BS_IN_BASE_ADDR_13       0x890
+#define FLD_BS_IN_BASE_ADDR_14       0x894
+#define FLD_BS_BIAS                  0x8E4
+#define FLD_CV_FM_RANGE_0            0x8E8
+#define FLD_CV_FM_RANGE_1            0x8EC
+#define FLD_CV_PM_RANGE_0            0x8F0
+#define FLD_CV_PM_RANGE_1            0x8F4
+#define FLD_BS_RANGE_0               0x8F8
+#define FLD_BS_RANGE_1               0x8FC
+
+#define MTK_FD_OUTPUT_MIN_WIDTH 0U
+#define MTK_FD_OUTPUT_MIN_HEIGHT 0U
+#define MTK_FD_OUTPUT_MAX_WIDTH 4096U
+#define MTK_FD_OUTPUT_MAX_HEIGHT 4096U
+
+#define MTK_FD_HW_TIMEOUT 1000 /* 1000 msec */
+#define MAX_FACE_NUM 1024
+#define RLT_NUM 48
+#define GENDER_OUT 32
+
+#define RACE_RST_X_NUM 4
+#define RACE_RST_Y_NUM 64
+#define GENDER_RST_X_NUM 2
+#define GENDER_RST_Y_NUM 64
+#define MRACE_RST_NUM 4
+#define MGENDER_RST_NUM 2
+#define MAGE_RST_NUM 2
+#define MINDIAN_RST_NUM 2
+
+// AIE 3.X
+#define fld_forest 14
+#define fld_point 500
+
+#define fld_step_num 6
+#define fld_max_frame 15
+
+#define fld_step_blink 0
+#define fld_step_cv 1
+#define fld_step_fp 2
+#define fld_step_leaf 3
+#define fld_step_km02 4
+#define fld_step_km13 5
+
+#define fld_blink_weight_forest14_size 6416
+#define fld_cv_size 19392
+#define fld_fp_size 80160
+#define fld_leafnode_size 4608000
+#define fld_tree_km02_size 120000
+#define fld_tree_km13_size 120000
+#define fld_output_size 112
+
+#define POSE_LOOP_NUM 3
+
+#define KERNEL_SPACE_RLT 1
+#define FLD_CUR_LANDMARK 11
+
+/*
+ * The base for the mediatek FD driver controls.
+ * We reserve 16 controls for this driver.
+ */
+#ifdef V4L2_CID_USER_MTK_FD_BASE
+#undef V4L2_CID_USER_MTK_FD_BASE
+#endif
+#define V4L2_CID_USER_MTK_FD_BASE		(V4L2_CID_USER_BASE + 0x1fd0)
+
+struct aie_static_info_element {
+	unsigned int fd_wdma_size[output_WDMA_WRA_num];
+	unsigned int out_xsize_plus_1;
+	unsigned int out_height;
+	unsigned int out_ysize_plus_1_stride2;
+	unsigned int out_stride;
+	unsigned int out_stride_stride2;
+	unsigned int out_width;
+	unsigned int img_width;
+	unsigned int img_height;
+	unsigned int stride2_out_width;
+	unsigned int stride2_out_height;
+	unsigned int out_xsize_plus_1_stride2;
+	unsigned int input_xsize_plus_1;
+};
+struct aie_static_info {
+	struct aie_static_info_element info_element[fd_loop_num];
+};
+
+enum aie_state {
+	STATE_NA = 0,
+	STATE_INIT = 1
+};
+
+enum aie_mode { FDMODE = 0, ATTRIBUTEMODE = 1, POSEMODE = 2 };
+
+enum aie_format {
+	FMT_NA = 0,
+	FMT_YUV_2P = 1,
+	FMT_YVU_2P = 2,
+	FMT_YUYV = 3,
+	FMT_YVYU = 4,
+	FMT_UYVY = 5,
+	FMT_VYUY = 6,
+	FMT_MONO = 7,
+    // AIE 3.X
+	FMT_YUV420_2P = 8,
+	FMT_YUV420_1P = 9
+};
+
+enum aie_input_degree {
+	DEGREE_0 = 0,
+	DEGREE_90 = 1,
+	DEGREE_270 = 2,
+	DEGREE_180 = 3
+};
+
+
+/* align v4l2 user space interface */
+#if KERNEL_SPACE_RLT
+struct FDRESULT {
+  u16 anchor_x0[MAX_FACE_NUM];
+  u16 anchor_x1[MAX_FACE_NUM];
+  u16 anchor_y0[MAX_FACE_NUM];
+  u16 anchor_y1[MAX_FACE_NUM];
+  signed short rop_landmark_score0[MAX_FACE_NUM];
+  signed short rop_landmark_score1[MAX_FACE_NUM];
+  signed short rop_landmark_score2[MAX_FACE_NUM];
+  signed short anchor_score[MAX_FACE_NUM];
+  signed short rip_landmark_score0[MAX_FACE_NUM];
+  signed short rip_landmark_score1[MAX_FACE_NUM];
+  signed short rip_landmark_score2[MAX_FACE_NUM];
+  signed short rip_landmark_score3[MAX_FACE_NUM];
+  signed short rip_landmark_score4[MAX_FACE_NUM];
+  signed short rip_landmark_score5[MAX_FACE_NUM];
+  signed short rip_landmark_score6[MAX_FACE_NUM];
+  u16 face_result_index[MAX_FACE_NUM];
+  u16 anchor_index[MAX_FACE_NUM];
+  u32 fd_partial_result;
+};
+
+struct fd_result {
+	u16 fd_pyramid0_num;
+	u16 fd_pyramid1_num;
+	u16 fd_pyramid2_num;
+	u16 fd_total_num;
+    struct FDRESULT PYRAMID0_RESULT;
+    struct FDRESULT PYRAMID1_RESULT;
+    struct FDRESULT PYRAMID2_RESULT;
+};
+#else
+struct fd_result {
+	u16 fd_pyramid0_num;
+	u16 fd_pyramid1_num;
+	u16 fd_pyramid2_num;
+	u16 fd_total_num;
+	u8 rpn31_rlt[MAX_FACE_NUM][RLT_NUM];
+	u8 rpn63_rlt[MAX_FACE_NUM][RLT_NUM];
+	u8 rpn95_rlt[MAX_FACE_NUM][RLT_NUM];
+};
+#endif
+/* align v4l2 user space interface */
+#if KERNEL_SPACE_RLT
+struct RACERESULT {
+  signed short RESULT[4][64];  // RESULT[Channel][Feature]
+};
+
+struct GENDERRESULT {
+  signed short RESULT[2][64];  // RESULT[Channel][Feature]
+};
+
+struct MERGED_RACERESULT {
+  signed short RESULT[4];  // RESULT[Feature]
+};
+
+struct MERGED_GENDERRESULT {
+  signed short RESULT[2];  // RESULT[Feature]
+};
+
+struct MERGED_AGERESULT {
+  signed short RESULT[2];  // RESULT[Feature]
+};
+
+struct MERGED_IS_INDIANRESULT {
+  signed short RESULT[2];  // RESULT[Feature]
+};
+
+struct attr_result {
+  struct GENDERRESULT GENDER_RESULT;
+  struct RACERESULT RACE_RESULT;
+  struct MERGED_AGERESULT MERGED_AGE_RESULT;
+  struct MERGED_GENDERRESULT MERGED_GENDER_RESULT;
+  struct MERGED_IS_INDIANRESULT MERGED_IS_INDIAN_RESULT;
+  struct MERGED_RACERESULT MERGED_RACE_RESULT;
+};
+#else
+struct attr_result {
+	u8 rpn17_rlt[GENDER_OUT];
+	u8 rpn20_rlt[GENDER_OUT];
+	u8 rpn22_rlt[GENDER_OUT];
+	u8 rpn25_rlt[GENDER_OUT];
+};
+#endif
+struct aie_roi {
+	u32 x1;
+	u32 y1;
+	u32 x2;
+	u32 y2;
+};
+
+struct aie_padding {
+	u32 left;
+	u32 right;
+	u32 down;
+	u32 up;
+};
+
+// AIE 3.X
+#if KERNEL_SPACE_RLT
+struct FLD_LANDMARK{
+  u16 x;
+  u16 y;
+};
+struct fld_result {
+  struct FLD_LANDMARK fld_landmark[FLD_CUR_LANDMARK];
+  u16 fld_out_rip;
+  u16 fld_out_rop;
+  u16 confidence;
+  signed short blinkscore;
+};
+#else
+struct fld_result {
+	u8 fld_rlt[fld_max_frame][fld_output_size];
+};
+#endif
+
+// AIE 3.X
+struct fld_crop_rip_rop {
+       unsigned int fld_in_crop_x1;
+       unsigned int fld_in_crop_y1;
+       unsigned int fld_in_crop_x2;
+       unsigned int fld_in_crop_y2;
+       unsigned int fld_in_rip;
+       unsigned int fld_in_rop;
+} __packed;
+
+/* align v4l2 user space interface */
+struct aie_enq_info {
+	unsigned int sel_mode;
+	unsigned int src_img_fmt;
+	unsigned int src_img_width;
+	unsigned int src_img_height;
+	unsigned int src_img_stride;
+	unsigned int pyramid_base_width;
+	unsigned int pyramid_base_height;
+	unsigned int number_of_pyramid;
+	unsigned int rotate_degree;
+	int en_roi;
+	struct aie_roi src_roi;
+	int en_padding;
+	struct aie_padding src_padding;
+	unsigned int freq_level;
+	// AIE 3.X
+	unsigned int fld_face_num;
+	struct fld_crop_rip_rop fld_input[fld_max_frame];
+	u32 src_img_addr;
+	u32 src_img_addr_uv;
+	u32 fd_version;
+	u32 attr_version;
+	u32 pose_version;
+	struct fd_result fd_out;
+	struct attr_result attr_out;
+// AIE 3.X
+#if KERNEL_SPACE_RLT
+	struct fld_result fld_out[fld_max_frame];
+#else
+	struct fld_result fld_out;
+#endif
+	u32 irq_status;
+};
+
+struct aie_reg_cfg {
+	u32 rs_adr;
+	u32 yuv2rgb_adr;
+	u32 fd_adr;
+	u32 fd_pose_adr;
+	u32 fd_mode;
+	u32 hw_result;
+	u32 hw_result1;
+	u32 reserved;
+};
+
+struct aie_para {
+	void *fd_fd_cfg_va;
+	void *fd_rs_cfg_va;
+	void *fd_yuv2rgb_cfg_va;
+
+	void *attr_fd_cfg_va[MAX_ENQUE_FRAME_NUM];
+	void *attr_yuv2rgb_cfg_va[MAX_ENQUE_FRAME_NUM];
+
+	void *rs_pym_rst_va[PYM_NUM][COLOR_NUM];
+
+	dma_addr_t fd_fd_cfg_pa;
+	dma_addr_t fd_rs_cfg_pa;
+	dma_addr_t fd_yuv2rgb_cfg_pa;
+
+	dma_addr_t attr_fd_cfg_pa[MAX_ENQUE_FRAME_NUM];
+	dma_addr_t attr_yuv2rgb_cfg_pa[MAX_ENQUE_FRAME_NUM];
+
+	dma_addr_t rs_pym_rst_pa[PYM_NUM][COLOR_NUM];
+
+	u32 sel_mode;
+	u16 max_img_width;
+	u16 max_img_height;
+	u16 img_width;
+	u16 img_height;
+	u16 crop_width;
+	u16 crop_height;
+	u32 src_img_fmt;
+	u32 rotate_degree;
+	s16 rpn_anchor_thrd;
+	u16 pyramid_width;
+	u16 pyramid_height;
+	u16 max_pyramid_width;
+	u16 max_pyramid_height;
+	u16 number_of_pyramid;
+	u32 src_img_addr;
+	u32 src_img_addr_uv;
+};
+
+struct aie_attr_para {
+	u32 w_idx;
+	u32 r_idx;
+	u32 sel_mode[MAX_ENQUE_FRAME_NUM];
+	u16 img_width[MAX_ENQUE_FRAME_NUM];
+	u16 img_height[MAX_ENQUE_FRAME_NUM];
+	u16 crop_width[MAX_ENQUE_FRAME_NUM];
+	u16 crop_height[MAX_ENQUE_FRAME_NUM];
+	u32 src_img_fmt[MAX_ENQUE_FRAME_NUM];
+	u32 rotate_degree[MAX_ENQUE_FRAME_NUM];
+	u32 src_img_addr[MAX_ENQUE_FRAME_NUM];
+	u32 src_img_addr_uv[MAX_ENQUE_FRAME_NUM];
+};
+
+struct aie_fd_dma_para {
+	void *fd_out_hw_va[fd_loop_num][output_WDMA_WRA_num];
+	void *fd_kernel_va[fd_loop_num][kernel_RDMA_RA_num];
+	void *attr_out_hw_va[attr_loop_num][output_WDMA_WRA_num];
+	void *attr_kernel_va[attr_loop_num][kernel_RDMA_RA_num];
+
+	void *age_out_hw_va[MAX_ENQUE_FRAME_NUM];
+	void *gender_out_hw_va[MAX_ENQUE_FRAME_NUM];
+	void *isIndian_out_hw_va[MAX_ENQUE_FRAME_NUM];
+	void *race_out_hw_va[MAX_ENQUE_FRAME_NUM];
+
+	dma_addr_t fd_out_hw_pa[fd_loop_num][output_WDMA_WRA_num];
+	dma_addr_t fd_kernel_pa[fd_loop_num][kernel_RDMA_RA_num];
+	dma_addr_t attr_out_hw_pa[attr_loop_num][output_WDMA_WRA_num];
+	dma_addr_t attr_kernel_pa[attr_loop_num][kernel_RDMA_RA_num];
+
+	dma_addr_t age_out_hw_pa[MAX_ENQUE_FRAME_NUM];
+	dma_addr_t gender_out_hw_pa[MAX_ENQUE_FRAME_NUM];
+	dma_addr_t isIndian_out_hw_pa[MAX_ENQUE_FRAME_NUM];
+	dma_addr_t race_out_hw_pa[MAX_ENQUE_FRAME_NUM];
+};
+// AIE 3.X
+struct aie_fd_fld_para {
+	void *fld_step_va[fld_step_num][fld_max_frame];
+	void *fld_output_va[fld_max_frame];
+	dma_addr_t fld_step_pa[fld_step_num][fld_max_frame];
+	dma_addr_t fld_output_pa[fld_max_frame];
+};
+
+struct imem_buf_info {
+	void *va;
+	dma_addr_t pa;
+	unsigned int size;
+	unsigned int reserved;
+};
+
+struct fd_buffer {
+	__u32 dma_addr; /* used by DMA HW */
+} __packed;
+
+struct user_init {
+	unsigned int max_img_width;
+	unsigned int max_img_height;
+	unsigned int pyramid_width;
+	unsigned int pyramid_height;
+	signed int feature_threshold;
+} __packed;
+
+struct user_param {
+	unsigned int fd_mode;
+	unsigned int src_img_fmt;
+	unsigned int src_img_width;
+	unsigned int src_img_height;
+	unsigned int src_img_stride;
+	unsigned int pyramid_base_width;
+	unsigned int pyramid_base_height;
+	unsigned int number_of_pyramid;
+	unsigned int rotate_degree;
+	int en_roi;
+	struct aie_roi src_roi;	
+	int en_padding;
+    struct aie_padding src_padding;
+	unsigned int freq_level;
+// AIE 3.X
+	unsigned int fld_face_num;
+	struct fld_crop_rip_rop fld_input[fld_max_frame];
+} __packed;
+
+struct fd_enq_param {
+	struct fd_buffer src_img[2];
+	struct fd_buffer user_result;
+	struct user_param user_param;
+} __packed;
+
+// AIE 3.X
+#ifdef CONFIG_INTERCONNECT_MTK_EXTENSION
+struct mtk_aie_dvfs {
+	struct device *dev;
+	struct regulator *reg;
+	unsigned int clklv_num[MTK_AIE_OPP_SET];
+	unsigned int clklv[MTK_AIE_OPP_SET][MTK_AIE_CLK_LEVEL_CNT];
+	unsigned int voltlv[MTK_AIE_OPP_SET][MTK_AIE_CLK_LEVEL_CNT];
+	unsigned int clklv_idx[MTK_AIE_OPP_SET];
+	unsigned int clklv_target[MTK_AIE_OPP_SET];
+	unsigned int cur_volt;
+};
+
+struct mtk_aie_qos_path {
+	struct icc_path *path;	/* cmdq event enum value */
+	char dts_name[256];
+	unsigned long long bw;
+};
+
+struct mtk_aie_qos {
+	struct device *dev;
+	struct mtk_aie_qos_path *qos_path;
+};
+#endif
+
+struct aie_clocks {
+	struct clk_bulk_data *clks;
+	unsigned int clk_num;
+};
+
+struct mtk_aie_req_work {
+	struct work_struct work;
+	struct mtk_aie_dev *fd_dev;
+};
+#ifdef CONFIG_DEBUG_FS
+struct aie_trace_info {
+	char *dump_buffer;
+	unsigned int size_of_dump;
+	unsigned int offset_of_dump;
+	char trigger_dump[3];
+	char *ydata_buffer;
+	unsigned int size_of_ydata;
+	char *uvdata_buffer;
+	unsigned int size_of_uvdata;
+};
+#endif
+struct mtk_aie_variant {
+	unsigned int hw_version;
+	unsigned int fld_enable;
+	unsigned int y2r_cfg_size;
+	unsigned int rs_cfg_size;
+	unsigned int fd_cfg_size;
+};
+
+struct mtk_aie_dev {
+	struct device *dev;
+	struct mtk_aie_ctx *ctx;
+	struct v4l2_m2m_dev *m2m_dev;
+	struct device *larb;
+	struct aie_para *base_para;
+	struct aie_attr_para *attr_para;
+	struct aie_fd_dma_para *dma_para;
+
+	// AIE 3.X
+	struct aie_fd_fld_para *fld_para;
+#ifdef CONFIG_INTERCONNECT_MTK_EXTENSION
+	struct mtk_aie_dvfs *dvfs_info;
+	struct mtk_aie_qos *qos_info;
+#endif	
+
+	struct aie_enq_info *aie_cfg;
+	struct workqueue_struct *frame_done_wq;
+	void __iomem *fd_base;
+	struct mtk_aie_variant *variant;
+
+	/* Input Buffer Pointer */
+	struct imem_buf_info rs_cfg_data;
+	struct imem_buf_info fd_cfg_data;
+	struct imem_buf_info yuv2rgb_cfg_data;
+	/* HW Output Buffer Pointer */
+	struct imem_buf_info rs_output_hw;
+	struct imem_buf_info fd_dma_hw;
+	struct imem_buf_info fd_dma_result_hw;
+	struct imem_buf_info fd_kernel_hw;
+	struct imem_buf_info fd_attr_dma_hw;
+	struct aie_static_info st_info;
+
+	struct aie_reg_cfg reg_cfg;
+
+	// AIE 3.X
+	/* fld fw buffer */
+	struct media_device mdev;
+	struct video_device vfd;
+	struct aie_clocks aie_clk;
+	struct v4l2_device v4l2_dev;
+
+	/* Lock for V4L2 operations */
+	struct mutex vfd_lock;
+	struct mutex u_lock;
+	struct imem_buf_info fd_fld_step_data;
+	struct imem_buf_info fd_fld_out_hw;
+
+	int irq;
+	struct completion fd_job_finished;
+	struct delayed_work job_timeout_work;
+
+	/* DRAM Buffer Size */
+	unsigned int fd_rs_cfg_size;
+	unsigned int fd_fd_cfg_size;
+	unsigned int fd_yuv2rgb_cfg_size;
+	unsigned int attr_fd_cfg_size;
+	unsigned int attr_yuv2rgb_cfg_size;
+
+	/* HW Output Buffer Size */
+	unsigned int rs_pym_out_size[PYM_NUM];
+	unsigned int fd_dma_max_size;
+	unsigned int fd_dma_rst_max_size;
+	unsigned int fd_fd_kernel_size;
+	unsigned int fd_attr_kernel_size;
+	unsigned int fd_attr_dma_max_size;
+	unsigned int fd_attr_dma_rst_max_size;
+	// AIE 3.X
+	/* fld size */
+	unsigned int fld_step_size;
+	unsigned int fld_out_size;
+
+	wait_queue_head_t flushing_waitq;
+	atomic_t num_composing;
+	struct mtk_aie_req_work req_work;
+	unsigned int fd_state;
+	unsigned int fd_mem_size;
+
+#ifdef CONFIG_DEBUG_FS
+    struct aie_trace_info trace_info;
+#endif
+};
+
+struct mtk_aie_ctx {
+	struct mtk_aie_dev *fd_dev;
+	struct device *dev;
+	struct v4l2_fh fh;
+	struct v4l2_ctrl_handler hdl;
+	struct v4l2_pix_format_mplane src_fmt;
+	struct v4l2_meta_format dst_fmt;
+};
+
+/**************************************************************************/
+/*                   C L A S S    D E C L A R A T I O N                   */
+/**************************************************************************/
+
+void aie_reset(struct mtk_aie_dev *fd);
+int aie_init(struct mtk_aie_dev *fd, struct user_init *user_init);
+void aie_uninit(struct mtk_aie_dev *fd);
+int aie_prepare(struct mtk_aie_dev *fd, struct aie_enq_info *aie_cfg);
+void aie_execute(struct mtk_aie_dev *fd, struct aie_enq_info *aie_cfg);
+void aie_execute_pose(struct mtk_aie_dev *fd);
+void aie_irqhandle(struct mtk_aie_dev *fd);
+void aie_get_fd_result(struct mtk_aie_dev *fd, struct aie_enq_info *aie_cfg);
+void aie_get_attr_result(struct mtk_aie_dev *fd, struct aie_enq_info *aie_cfg);
+void aie_get_fld_result(struct mtk_aie_dev *fd, struct aie_enq_info *aie_cfg);
+#endif /*__MTK_AIE_H__*/
diff --git a/drivers/media/platform/mediatek/aie/mtk_aie_53.c b/drivers/media/platform/mediatek/aie/mtk_aie_53.c
new file mode 100644
index 0000000000000000000000000000000000000000..b4de413fc72f769c547aabee9cabad7a9134154a
--- /dev/null
+++ b/drivers/media/platform/mediatek/aie/mtk_aie_53.c
@@ -0,0 +1,1658 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2020 MediaTek Inc.
+ *
+ * Author: Fish Wu <fish.wu@mediatek.com>
+ *
+ */
+
+#include <linux/clk.h>
+#include <linux/dma-mapping.h>
+#include <linux/interrupt.h>
+#include <linux/iopoll.h>
+#include <linux/jiffies.h>
+#include <linux/module.h>
+#include <linux/of_address.h>
+#include <linux/of_irq.h>
+#include <linux/of_platform.h>
+#include <linux/platform_device.h>
+#include <linux/pm_runtime.h>
+#include <linux/remoteproc.h>
+#include <linux/version.h>
+#include <linux/types.h>
+#ifdef CONFIG_DEBUG_FS
+#include <linux/debugfs.h>
+#endif
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-event.h>
+#include <media/v4l2-ioctl.h>
+#include <media/v4l2-mem2mem.h>
+#include <media/videobuf2-core.h>
+#include <media/videobuf2-dma-contig.h>
+#include <media/videobuf2-v4l2.h>
+
+#include <soc/mediatek/smi.h>
+
+#include "mtk_aie.h"
+
+#ifdef CONFIG_DEBUG_FS
+#define AIE_DUMP_BUFFER_SIZE 4*1024*1024
+#define AIE_DEBUG_RAW_DATA_SIZE 2*640*480
+unsigned char rawdata[AIE_DEBUG_RAW_DATA_SIZE];
+struct debugfs_blob_wrapper ydata;
+#endif
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(5,7,0)
+#define VFL_TYPE_VIDEO VFL_TYPE_GRABBER
+#endif
+
+#ifdef CONFIG_INTERCONNECT_MTK_EXTENSION
+#define AIE_QOS_MAX 4
+#define AIE_QOS_RA_IDX 0
+#define AIE_QOS_RB_IDX 1
+#define AIE_QOS_WA_IDX 2
+#define AIE_QOS_WB_IDX 3
+#define AIE_READ_AVG_BW 213
+#define AIE_WRITE_AVG_BW 145
+#endif
+
+#define V4L2_CID_MTK_AIE_INIT (V4L2_CID_USER_MTK_FD_BASE + 1)
+#define V4L2_CID_MTK_AIE_PARAM (V4L2_CID_USER_MTK_FD_BASE + 2)
+#define V4L2_CID_MTK_AIE_FD_VER (V4L2_CID_USER_MTK_FD_BASE + 3)
+#define V4L2_CID_MTK_AIE_ATTR_VER (V4L2_CID_USER_MTK_FD_BASE + 4)
+
+#define V4L2_CID_MTK_AIE_MAX 4
+
+static const struct v4l2_pix_format_mplane mtk_aie_img_fmts[] = {
+	{
+		.pixelformat = V4L2_PIX_FMT_NV16M, .num_planes = 2,
+	},
+	{
+		.pixelformat = V4L2_PIX_FMT_NV61M, .num_planes = 2,
+	},
+	{
+		.pixelformat = V4L2_PIX_FMT_YUYV, .num_planes = 1,
+	},
+	{
+		.pixelformat = V4L2_PIX_FMT_YVYU, .num_planes = 1,
+	},
+	{
+		.pixelformat = V4L2_PIX_FMT_UYVY, .num_planes = 1,
+	},
+	{
+		.pixelformat = V4L2_PIX_FMT_VYUY, .num_planes = 1,
+	},
+	{
+		.pixelformat = V4L2_PIX_FMT_GREY, .num_planes = 1,
+	},
+	{
+		.pixelformat = V4L2_PIX_FMT_NV12M, .num_planes = 2,
+	},
+	{
+		.pixelformat = V4L2_PIX_FMT_NV12, .num_planes = 1,
+	},
+};
+
+#ifdef CONFIG_INTERCONNECT_MTK_EXTENSION
+static const struct mtk_aie_qos_path aie_qos_path[AIE_QOS_MAX] = {
+	{NULL, "l12_fdvt_rda", 0},
+	{NULL, "l12_fdvt_rdb", 0},
+	{NULL, "l12_fdvt_wra", 0},
+	{NULL, "l12_fdvt_wrb", 0}
+};
+#endif
+
+#define NUM_FORMATS ARRAY_SIZE(mtk_aie_img_fmts)
+
+struct clk_bulk_data aie_clks[] = {
+	{ .id = "IMG_IPE" },
+	{ .id = "IPE_FDVT" },
+	{ .id = "IPE_TOP" },
+	{ .id = "IPE_SMI_LARB12" },
+};
+
+static void *mtk_aie_get_drv_data(struct device *dev);
+
+static inline struct mtk_aie_ctx *fh_to_ctx(struct v4l2_fh *fh)
+{
+	return container_of(fh, struct mtk_aie_ctx, fh);
+}
+
+#ifdef CONFIG_INTERCONNECT_MTK_EXTENSION
+static int mtk_aie_mmdvfs_init(struct mtk_aie_dev *fd)
+{
+	u64 freq = 0;
+	int ret = -ENOMEM;
+	int opp_num = 0, opp_idx = 0, idx = 0, volt = 0;
+	struct device_node *np = NULL, *child_np = NULL;
+	struct of_phandle_iterator it;
+
+    fd->dvfs_info = kzalloc(sizeof(struct mtk_aie_dvfs),GFP_KERNEL);
+	if(!fd->dvfs_info)
+		return ret;
+
+	fd->dvfs_info->dev = fd->dev;
+	ret = dev_pm_opp_of_add_table(fd->dvfs_info->dev);
+	if (ret < 0) {
+		dev_info(fd->dvfs_info->dev, "fail to init opp table: %d\n", ret);
+		return ret;
+	}
+
+	fd->dvfs_info->reg = devm_regulator_get(fd->dvfs_info->dev, "dvfsrc-vcore");
+	if (IS_ERR(fd->dvfs_info->reg)) {
+		dev_info(fd->dvfs_info->dev, "can't get dvfsrc-vcore\n");
+		ret = PTR_ERR(fd->dvfs_info->reg);
+		fd->dvfs_info->reg = NULL;
+		return ret;
+	}
+
+	opp_num = regulator_count_voltages(fd->dvfs_info->reg);
+	of_for_each_phandle( &it, ret, fd->dvfs_info->dev->of_node, 
+		"operating-points-v2", NULL, 0) {
+		np = of_node_get(it.node);
+		if (!np) {
+			dev_info(fd->dvfs_info->dev, "of_node_get fail\n");
+			return ret;
+		}
+
+		do {
+			child_np = of_get_next_available_child(np, child_np);
+			if (child_np) {
+				of_property_read_u64(child_np, "opp-hz", &freq);
+				of_property_read_u32(child_np, "opp-microvolt", &volt);
+                if ((freq == 0) || (volt == 0)) {
+                    dev_info( fd->dvfs_info->dev,
+                        "%s: [ERROR] parsing zero freq/volt(%d/%d) at idx(%d)\n",
+                        __func__, freq, volt, idx);
+                    continue;
+                }
+				fd->dvfs_info->clklv[opp_idx][idx] = freq;
+				fd->dvfs_info->voltlv[opp_idx][idx] = volt;
+				dev_dbg(fd->dvfs_info->dev, "[%s] opp=%d, idx=%d, clk=%d volt=%d\n",
+					__func__, opp_idx, idx, fd->dvfs_info->clklv[opp_idx][idx],
+					fd->dvfs_info->voltlv[opp_idx][idx]);
+				idx++;
+			}
+		} while (child_np);
+		fd->dvfs_info->clklv_num[opp_idx] = idx;
+		fd->dvfs_info->clklv_target[opp_idx] = fd->dvfs_info->clklv[opp_idx][0];
+		fd->dvfs_info->clklv_idx[opp_idx] = 0;
+		idx = 0;
+		opp_idx++;
+		of_node_put(np);
+	}
+	fd->dvfs_info->cur_volt = 0;
+
+	return 0;
+}
+
+static void mtk_aie_mmdvfs_uninit(struct mtk_aie_dev *fd)
+{
+	int volt = 0;
+
+    if(fd->dvfs_info) {
+		dev_dbg(fd->dvfs_info->dev, "[%s]\n", __func__);
+
+		fd->dvfs_info->cur_volt = volt;
+
+		regulator_set_voltage(fd->dvfs_info->reg, volt, INT_MAX);
+
+		kfree(fd->dvfs_info);
+	}
+}
+
+static void mtk_aie_mmdvfs_set(struct mtk_aie_dev *fd,
+				bool isSet, unsigned int level)
+{
+	int volt = 0, idx = 0, opp_idx = 0;
+
+	if (isSet) {
+		if (level < fd->dvfs_info->clklv_num[opp_idx])
+			idx = level;
+	}
+	volt = fd->dvfs_info->voltlv[opp_idx][idx];
+
+	if (fd->dvfs_info->cur_volt != volt) {
+		dev_dbg(fd->dvfs_info->dev, "[%s] volt change opp=%d, idx=%d, clk=%d volt=%d\n",
+			__func__, opp_idx, idx, fd->dvfs_info->clklv[opp_idx][idx],
+			fd->dvfs_info->voltlv[opp_idx][idx]);
+		regulator_set_voltage(fd->dvfs_info->reg, volt, INT_MAX);
+		fd->dvfs_info->cur_volt = volt;
+	}
+}
+
+static int mtk_aie_mmqos_init(struct mtk_aie_dev *fd)
+{
+	int idx = 0;
+	int ret = -ENOMEM;
+
+    fd->qos_info = kzalloc(sizeof(struct mtk_aie_qos),GFP_KERNEL);
+	if(!fd->qos_info)
+		return ret;
+
+	fd->qos_info->dev = fd->dev;
+	fd->qos_info->qos_path = (struct mtk_aie_qos_path*)aie_qos_path;
+
+	for (idx = 0; idx < AIE_QOS_MAX; idx++) {
+		fd->qos_info->qos_path[idx].path =
+			of_mtk_icc_get(fd->qos_info->dev, fd->qos_info->qos_path[idx].dts_name);
+		fd->qos_info->qos_path[idx].bw = 0;
+		dev_dbg(fd->qos_info->dev, "[%s] idx=%d, path=%p, name=%s, bw=%llu\n",
+			__func__, idx,
+			fd->qos_info->qos_path[idx].path,
+			fd->qos_info->qos_path[idx].dts_name,
+			fd->qos_info->qos_path[idx].bw);
+	}
+	return 0;
+}
+
+static void mtk_aie_mmqos_uninit(struct mtk_aie_dev *fd)
+{
+	int idx = 0;
+
+	if(fd->qos_info) {
+		for (idx = 0; idx < AIE_QOS_MAX; idx++) {
+			if (fd->qos_info->qos_path[idx].path == NULL) {
+				dev_dbg(fd->qos_info->dev, "[%s] path of idx(%d) is NULL\n", __func__, idx);
+				continue;
+			}
+			dev_dbg(fd->qos_info->dev, "[%s] idx=%d, path=%p, bw=%llu\n",
+				__func__, idx,
+				fd->qos_info->qos_path[idx].path,
+				fd->qos_info->qos_path[idx].bw);
+			fd->qos_info->qos_path[idx].bw = 0;
+			mtk_icc_set_bw(fd->qos_info->qos_path[idx].path, 0, 0);
+		}
+		kfree(fd->qos_info);
+	}
+}
+
+static void mtk_aie_mmqos_set(struct mtk_aie_dev *fd,
+				bool isSet)
+{
+	int r_bw = 0;
+	int w_bw = 0;
+	int idx = 0;
+
+	if (isSet) {
+		r_bw = AIE_READ_AVG_BW;
+		w_bw = AIE_WRITE_AVG_BW;
+	}
+
+	for (idx = 0; idx < AIE_QOS_MAX; idx++) {
+		if (fd->qos_info->qos_path[idx].path == NULL) {
+			dev_dbg(fd->qos_info->dev, "[%s] path of idx(%d) is NULL\n",
+				 __func__, idx);
+			continue;
+		}
+
+		if (idx == AIE_QOS_RA_IDX &&
+		    fd->qos_info->qos_path[idx].bw != r_bw) {
+			dev_dbg(fd->qos_info->dev, "[%s] idx=%d, path=%p, bw=%llu/%d,\n",
+				__func__, idx,
+				fd->qos_info->qos_path[idx].path,
+				fd->qos_info->qos_path[idx].bw, r_bw);
+			fd->qos_info->qos_path[idx].bw = r_bw;
+			mtk_icc_set_bw(fd->qos_info->qos_path[idx].path,
+				       MBps_to_icc(fd->qos_info->qos_path[idx].bw), 0);
+		}
+
+		if (idx == AIE_QOS_WA_IDX &&
+		    fd->qos_info->qos_path[idx].bw != w_bw) {
+			dev_dbg(fd->qos_info->dev, "[%s] idx=%d, path=%p, bw=%llu/%d,\n",
+				__func__, idx,
+				fd->qos_info->qos_path[idx].path,
+				fd->qos_info->qos_path[idx].bw, w_bw);
+			fd->qos_info->qos_path[idx].bw = w_bw;
+			mtk_icc_set_bw(fd->qos_info->qos_path[idx].path,
+				       MBps_to_icc(fd->qos_info->qos_path[idx].bw), 0);
+		}
+	}
+}
+#endif
+
+static int mtk_aie_fill_init_param(struct mtk_aie_dev *fd,
+				    struct user_init *user_init,
+				    struct v4l2_ctrl_handler *hdl)
+{
+	struct v4l2_ctrl *ctrl = NULL;
+
+	ctrl = v4l2_ctrl_find(hdl, V4L2_CID_MTK_AIE_INIT);
+	if (ctrl) {
+		memcpy(user_init, ctrl->p_new.p_u32, sizeof(struct user_init));
+		dev_info(fd->dev, "init param : max w:%d, max h:%d",
+			user_init->max_img_width, user_init->max_img_height);
+		dev_info(fd->dev, "init param : p_w:%d, p_h:%d, f thread:%d",
+			user_init->pyramid_width, user_init->pyramid_height,
+			user_init->feature_threshold);
+	}
+	else {
+		dev_err(fd->dev, "NO V4L2_CID_MTK_AIE_INIT!\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int mtk_aie_hw_enable(struct mtk_aie_dev *fd)
+{
+	struct mtk_aie_ctx *ctx = fd->ctx;
+	struct user_init *user_init = NULL;
+	int ret = -EINVAL;
+
+	user_init = kzalloc(sizeof(struct user_init),GFP_KERNEL);
+	if(!user_init)
+		return -ENOMEM;
+
+	/* initial value */
+	ret = mtk_aie_fill_init_param(fd, user_init, &ctx->hdl);
+	if( ret != 0 )
+		goto init_fail;
+
+	ret = aie_init(fd, user_init);
+
+init_fail:
+	kfree(user_init);
+
+	return ret;
+}
+
+static void mtk_aie_hw_job_finish(struct mtk_aie_dev *fd,
+				  enum vb2_buffer_state vb_state)
+{
+	struct mtk_aie_ctx *ctx = NULL;
+	struct vb2_v4l2_buffer *src_vbuf = NULL, *dst_vbuf = NULL;
+	pm_runtime_put(fd->dev);
+	ctx = v4l2_m2m_get_curr_priv(fd->m2m_dev);
+	if(ctx == NULL) {
+		dev_err(fd->dev, "Failed to do v4l2_m2m_get_curr_priv!\n");
+	}
+	else {
+		src_vbuf = v4l2_m2m_src_buf_remove(ctx->fh.m2m_ctx);
+		dst_vbuf = v4l2_m2m_dst_buf_remove(ctx->fh.m2m_ctx);
+
+		v4l2_m2m_buf_copy_metadata(src_vbuf, dst_vbuf, true);
+		v4l2_m2m_buf_done(src_vbuf, vb_state);
+		v4l2_m2m_buf_done(dst_vbuf, vb_state);
+		v4l2_m2m_job_finish(fd->m2m_dev, ctx->fh.m2m_ctx);
+	}
+	complete_all(&fd->fd_job_finished);
+}
+
+static int mtk_aie_hw_connect(struct mtk_aie_dev *fd)
+{
+	pm_runtime_get_noresume(fd->dev);
+
+	if (mtk_aie_hw_enable(fd)) {
+		return -EINVAL;
+	}
+#ifdef CONFIG_INTERCONNECT_MTK_EXTENSION
+		mtk_aie_mmdvfs_set(fd, 1, 0);
+		mtk_aie_mmqos_set(fd, 1);
+#endif
+	return 0;
+}
+
+static void mtk_aie_hw_disconnect(struct mtk_aie_dev *fd)
+{
+	pm_runtime_put_noidle(fd->dev);
+#ifdef CONFIG_INTERCONNECT_MTK_EXTENSION
+		mtk_aie_mmqos_set(fd, 0);
+		mtk_aie_mmdvfs_set(fd, 0, 0);
+#endif
+	aie_uninit(fd);
+}
+
+static int mtk_aie_hw_job_exec(struct mtk_aie_dev *fd,
+                                struct fd_enq_param *fd_param)
+{
+	pm_runtime_get_sync((fd->dev));
+
+	reinit_completion(&fd->fd_job_finished);
+	schedule_delayed_work(&fd->job_timeout_work,
+			      msecs_to_jiffies(MTK_FD_HW_TIMEOUT));
+
+	return 0;
+}
+
+static int mtk_aie_vb2_buf_out_validate(struct vb2_buffer *vb)
+{
+	struct vb2_v4l2_buffer *v4l2_buf = to_vb2_v4l2_buffer(vb);
+
+	if (v4l2_buf->field == V4L2_FIELD_ANY)
+		v4l2_buf->field = V4L2_FIELD_NONE;
+	if (v4l2_buf->field != V4L2_FIELD_NONE)
+		return -EINVAL;
+
+	return 0;
+}
+
+static int mtk_aie_vb2_buf_prepare(struct vb2_buffer *vb)
+{
+	struct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);
+	struct vb2_queue *vq = vb->vb2_queue;
+	struct mtk_aie_ctx *ctx = vb2_get_drv_priv(vq);
+	struct device *dev = ctx->dev;
+	struct v4l2_pix_format_mplane *pixfmt = NULL;
+
+	switch (vq->type) {
+	case V4L2_BUF_TYPE_META_CAPTURE:
+		if (vb2_plane_size(vb, 0) < ctx->dst_fmt.buffersize) {
+			dev_info(dev, "meta size %lu is too small\n",
+				 vb2_plane_size(vb, 0));
+			return -EINVAL;
+		}
+		else {
+			vb2_set_plane_payload(vb, 0, ctx->dst_fmt.buffersize);
+		}
+		break;
+	case V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE:
+		pixfmt = &ctx->src_fmt;
+
+		if (vbuf->field == V4L2_FIELD_ANY)
+			vbuf->field = V4L2_FIELD_NONE;
+
+		if (vb->num_planes > 2 || vbuf->field != V4L2_FIELD_NONE) {
+			dev_info(dev, "plane %d or field %d not supported\n",
+				 vb->num_planes, vbuf->field);
+			return -EINVAL;
+		}
+
+		if (vb2_plane_size(vb, 0) < pixfmt->plane_fmt[0].sizeimage) {
+			dev_info(dev, "plane 0 %lu is too small than %x\n",
+				 vb2_plane_size(vb, 0),
+				 pixfmt->plane_fmt[0].sizeimage);
+			return -EINVAL;
+		}
+		else {
+			vb2_set_plane_payload(vb, 0, pixfmt->plane_fmt[0].sizeimage);
+		}
+
+		if (pixfmt->num_planes == 2 &&
+		    vb2_plane_size(vb, 1) < pixfmt->plane_fmt[1].sizeimage) {
+			dev_info(dev, "plane 1 %lu is too small than %x\n",
+				 vb2_plane_size(vb, 1),
+				 pixfmt->plane_fmt[1].sizeimage);
+			return -EINVAL;
+		}
+		else {
+			vb2_set_plane_payload(vb, 1, pixfmt->plane_fmt[1].sizeimage);
+		}
+		break;
+	}
+
+	return 0;
+}
+
+static void mtk_aie_vb2_buf_queue(struct vb2_buffer *vb)
+{
+	struct mtk_aie_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);
+	struct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);
+
+	v4l2_m2m_buf_queue(ctx->fh.m2m_ctx, vbuf);
+}
+
+static int mtk_aie_vb2_queue_setup(struct vb2_queue *vq,
+				   unsigned int *num_buffers,
+				   unsigned int *num_planes,
+				   unsigned int sizes[],
+				   struct device *alloc_devs[])
+{
+	struct mtk_aie_ctx *ctx = vb2_get_drv_priv(vq);
+	struct device *dev = ctx->dev;
+	unsigned int size[2] = {0,0};
+	unsigned int plane = 0;
+
+	switch (vq->type) {
+	case V4L2_BUF_TYPE_META_CAPTURE:
+		size[0] = ctx->dst_fmt.buffersize;
+		break;
+	case V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE:
+		size[0] = ctx->src_fmt.plane_fmt[0].sizeimage;
+		size[1] = ctx->src_fmt.plane_fmt[1].sizeimage;
+		break;
+	}
+
+	dev_info(dev, "vq type =%d, size[0]=%d, size[1]=%d\n", vq->type, size[0], size[1]);
+
+	if (*num_planes > 2)
+		return -EINVAL;
+
+	*num_buffers = clamp_val(*num_buffers, 1, VB2_MAX_FRAME);
+
+	if (*num_planes == 0) {
+		if (vq->type == V4L2_BUF_TYPE_META_CAPTURE) {
+			sizes[0] = ctx->dst_fmt.buffersize;
+			*num_planes = 1;
+			return 0;
+		}
+
+		*num_planes = ctx->src_fmt.num_planes;
+		if (*num_planes > 2)
+			return -EINVAL;
+		for (plane = 0; plane < *num_planes; plane++)
+			sizes[plane] = ctx->src_fmt.plane_fmt[plane].sizeimage;
+
+		return 0;
+	}
+
+	return 0;
+}
+
+static int mtk_aie_vb2_start_streaming(struct vb2_queue *vq, unsigned int count)
+{
+	struct mtk_aie_ctx *ctx = vb2_get_drv_priv(vq);
+
+	if (vq->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE)
+		return mtk_aie_hw_connect(ctx->fd_dev);
+
+	return 0;
+}
+
+static void aie_dumpinfo(struct mtk_aie_dev *fd)
+{
+	unsigned int i = 0;
+	u32 *cfg_value = NULL;
+
+	for (i = 0 ; i < 0x158; i = i + 4){
+		fd->trace_info.offset_of_dump += scnprintf(fd->trace_info.dump_buffer + fd->trace_info.offset_of_dump,
+		fd->trace_info.size_of_dump - fd->trace_info.offset_of_dump,
+		"Reg: %x, %x\n", i, readl(fd->fd_base + i));
+	}
+	for (i = 0x200 ; i < 0x3F8; i = i + 4){
+		fd->trace_info.offset_of_dump += scnprintf(fd->trace_info.dump_buffer + fd->trace_info.offset_of_dump,
+		fd->trace_info.size_of_dump - fd->trace_info.offset_of_dump,
+		"Dma Reg: %x, %x\n", i, readl(fd->fd_base + i));
+	}
+	if (fd->aie_cfg->sel_mode == 0) {
+		cfg_value = (u32 *)fd->base_para->fd_yuv2rgb_cfg_va;
+		for (i = 0; i < fd->fd_yuv2rgb_cfg_size / 4; i++){
+			fd->trace_info.offset_of_dump += scnprintf(fd->trace_info.dump_buffer + fd->trace_info.offset_of_dump,
+			fd->trace_info.size_of_dump - fd->trace_info.offset_of_dump,
+			"YUV config: %x, %x\n", i,cfg_value[i]);
+		}
+		cfg_value = (u32 *)fd->base_para->fd_rs_cfg_va;
+		for (i = 0; i < fd->fd_rs_cfg_size / 4; i++){
+			fd->trace_info.offset_of_dump += scnprintf(fd->trace_info.dump_buffer + fd->trace_info.offset_of_dump,
+			fd->trace_info.size_of_dump - fd->trace_info.offset_of_dump,
+			"RS config: %x, %x\n", i,cfg_value[i]);
+		}
+		cfg_value = (u32 *)fd->base_para->fd_fd_cfg_va;
+		for (i = 0; i < fd->fd_fd_cfg_size / 4; i++){
+			fd->trace_info.offset_of_dump += scnprintf(fd->trace_info.dump_buffer + fd->trace_info.offset_of_dump,
+			fd->trace_info.size_of_dump - fd->trace_info.offset_of_dump,
+			"FD config: %x, %x\n", i,cfg_value[i]);
+		}
+	}
+
+	if (fd->aie_cfg->sel_mode == 1) {
+		cfg_value = (u32 *)fd->base_para->attr_yuv2rgb_cfg_va;
+		for (i = 0; i < fd->fd_yuv2rgb_cfg_size / 4; i++){
+			fd->trace_info.offset_of_dump += scnprintf(fd->trace_info.dump_buffer + fd->trace_info.offset_of_dump,
+			fd->trace_info.size_of_dump - fd->trace_info.offset_of_dump,
+			"YUV config: %x, %x\n", i,cfg_value[i]);
+		}
+		cfg_value = (u32 *)fd->base_para->attr_fd_cfg_va;
+		for (i = 0; i < fd->fd_fd_cfg_size / 4; i++){
+			fd->trace_info.offset_of_dump += scnprintf(fd->trace_info.dump_buffer + fd->trace_info.offset_of_dump,
+			fd->trace_info.size_of_dump - fd->trace_info.offset_of_dump,
+			"FD config: %x, %x\n", i,cfg_value[i]);
+		}
+	}
+}
+
+static void mtk_aie_job_timeout_work(struct work_struct *work)
+{
+	struct mtk_aie_dev *fd =
+		container_of(work, struct mtk_aie_dev, job_timeout_work.work);
+
+	dev_err(fd->dev, "FD Job timeout!");
+
+
+	dev_info(fd->dev, "%s result result1: %x, %x, %x", __func__,
+		 readl(fd->fd_base + AIE_RESULT_0_REG),
+		 readl(fd->fd_base + AIE_RESULT_1_REG),
+		 readl(fd->fd_base + AIE_DMA_CTL_REG));
+
+	fd->aie_cfg->irq_status = readl(fd->fd_base + AIE_INT_EN_REG);
+
+	if (fd->aie_cfg->irq_status & 0x00010000 ||
+	    fd->aie_cfg->irq_status & 0x00100000 ||
+	    fd->aie_cfg->irq_status & 0x01000000)
+		aie_dumpinfo(fd);
+
+	if (fd->aie_cfg->sel_mode == 1)
+		dev_info(fd->dev, "[ATTRMODE] w_idx = %d, r_idx = %d\n",
+			 fd->attr_para->w_idx, fd->attr_para->r_idx);
+
+	aie_irqhandle(fd);
+	aie_reset(fd);
+	atomic_dec(&fd->num_composing);
+	mtk_aie_hw_job_finish(fd, VB2_BUF_STATE_ERROR);
+	wake_up(&fd->flushing_waitq);
+}
+
+static void mtk_aie_job_wait_finish(struct mtk_aie_dev *fd)
+{
+	wait_for_completion(&fd->fd_job_finished);
+}
+
+static void mtk_aie_vb2_stop_streaming(struct vb2_queue *vq)
+{
+	struct mtk_aie_ctx *ctx = vb2_get_drv_priv(vq);
+	struct mtk_aie_dev *fd = ctx->fd_dev;
+	struct vb2_v4l2_buffer *vb = NULL;
+	struct v4l2_m2m_ctx *m2m_ctx = ctx->fh.m2m_ctx;
+	struct v4l2_m2m_queue_ctx *queue_ctx;
+
+	mtk_aie_job_wait_finish(fd);
+	queue_ctx = V4L2_TYPE_IS_OUTPUT(vq->type) ? &m2m_ctx->out_q_ctx
+						  : &m2m_ctx->cap_q_ctx;
+	while ((vb = v4l2_m2m_buf_remove(queue_ctx)))
+		v4l2_m2m_buf_done(vb, VB2_BUF_STATE_ERROR);
+
+	if (vq->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE)
+		mtk_aie_hw_disconnect(fd);
+}
+
+static void mtk_aie_vb2_request_complete(struct vb2_buffer *vb)
+{
+	struct mtk_aie_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);
+
+	v4l2_ctrl_request_complete(vb->req_obj.req, &ctx->hdl);
+}
+
+static int mtk_aie_querycap(struct file *file, void *fh,
+			    struct v4l2_capability *cap)
+{
+	struct mtk_aie_dev *fd = video_drvdata(file);
+	struct device *dev = fd->dev;
+
+	strscpy(cap->driver, dev_driver_string(dev), sizeof(cap->driver));
+	strscpy(cap->card, dev_driver_string(dev), sizeof(cap->card));
+	snprintf(cap->bus_info, sizeof(cap->bus_info), "platform:%s",
+		 dev_name(fd->dev));
+
+	return 0;
+}
+
+static int mtk_aie_enum_fmt_out_mp(struct file *file, void *fh,
+				   struct v4l2_fmtdesc *f)
+{
+	if (f->index >= NUM_FORMATS)
+		return -EINVAL;
+
+	f->pixelformat = mtk_aie_img_fmts[f->index].pixelformat;
+	return 0;
+}
+
+static void mtk_aie_fill_pixfmt_mp(struct v4l2_pix_format_mplane *dfmt,
+				   const struct v4l2_pix_format_mplane *sfmt)
+{
+	dfmt->field = V4L2_FIELD_NONE;
+	dfmt->colorspace = V4L2_COLORSPACE_BT2020;
+	dfmt->num_planes = sfmt->num_planes;
+	dfmt->ycbcr_enc = V4L2_YCBCR_ENC_DEFAULT;
+	dfmt->quantization = V4L2_QUANTIZATION_DEFAULT;
+	dfmt->xfer_func = V4L2_MAP_XFER_FUNC_DEFAULT(dfmt->colorspace);
+
+	/* Keep user setting as possible */
+	dfmt->width = clamp(dfmt->width, MTK_FD_OUTPUT_MIN_WIDTH,
+			    MTK_FD_OUTPUT_MAX_WIDTH);
+	dfmt->height = clamp(dfmt->height, MTK_FD_OUTPUT_MIN_HEIGHT,
+			     MTK_FD_OUTPUT_MAX_HEIGHT);
+
+	if (sfmt->num_planes == 2) {
+		dfmt->plane_fmt[0].sizeimage =
+			dfmt->height * dfmt->plane_fmt[0].bytesperline;
+		if (sfmt->pixelformat == V4L2_PIX_FMT_NV12M)
+			dfmt->plane_fmt[1].sizeimage =
+				dfmt->height * dfmt->plane_fmt[1].bytesperline / 2;
+		else
+			dfmt->plane_fmt[1].sizeimage =
+				dfmt->height * dfmt->plane_fmt[1].bytesperline;
+	} else {
+		if (sfmt->pixelformat == V4L2_PIX_FMT_NV12)
+			dfmt->plane_fmt[0].sizeimage =
+				dfmt->height * dfmt->plane_fmt[0].bytesperline * 3 / 2;
+		else
+			dfmt->plane_fmt[0].sizeimage =
+				dfmt->height * dfmt->plane_fmt[0].bytesperline;
+	}
+}
+
+static const struct v4l2_pix_format_mplane *mtk_aie_find_fmt(u32 format)
+{
+	unsigned int i = 0;
+
+	for (i = 0; i < NUM_FORMATS; i++) {
+		if (mtk_aie_img_fmts[i].pixelformat == format)
+			return &mtk_aie_img_fmts[i];
+	}
+
+	return NULL;
+}
+
+static int mtk_aie_try_fmt_out_mp(struct file *file, void *fh,
+				  struct v4l2_format *f)
+{
+	struct v4l2_pix_format_mplane *pix_mp = &f->fmt.pix_mp;
+	const struct v4l2_pix_format_mplane *fmt;
+
+	fmt = mtk_aie_find_fmt(pix_mp->pixelformat);
+	if (!fmt)
+		fmt = &mtk_aie_img_fmts[0]; /* Get default img fmt */
+
+	mtk_aie_fill_pixfmt_mp(pix_mp, fmt);
+	return 0;
+}
+
+static int mtk_aie_g_fmt_out_mp(struct file *file, void *fh,
+				struct v4l2_format *f)
+{
+	struct mtk_aie_ctx *ctx = fh_to_ctx(fh);
+
+	f->fmt.pix_mp = ctx->src_fmt;
+
+	return 0;
+}
+
+static int mtk_aie_s_fmt_out_mp(struct file *file, void *fh,
+				struct v4l2_format *f)
+{
+	struct mtk_aie_ctx *ctx = fh_to_ctx(fh);
+	struct vb2_queue *vq = v4l2_m2m_get_vq(ctx->fh.m2m_ctx, f->type);
+
+	/* Change not allowed if queue is streaming. */
+	if (vb2_is_streaming(vq)) {
+		dev_info(ctx->dev, "Failed to set format, vb2 is busy\n");
+		return -EBUSY;
+	}
+
+	mtk_aie_try_fmt_out_mp(file, fh, f);
+	ctx->src_fmt = f->fmt.pix_mp;
+
+	return 0;
+}
+
+static int mtk_aie_enum_fmt_meta_cap(struct file *file, void *fh,
+				     struct v4l2_fmtdesc *f)
+{
+	if (f->index)
+		return -EINVAL;
+
+	strscpy(f->description, "Face detection result",
+		sizeof(f->description));
+
+	f->pixelformat = V4L2_META_FMT_MTFD_RESULT;
+	f->flags = 0;
+
+	return 0;
+}
+
+static int mtk_aie_g_fmt_meta_cap(struct file *file, void *fh,
+				  struct v4l2_format *f)
+{
+	f->fmt.meta.dataformat = V4L2_META_FMT_MTFD_RESULT;
+	f->fmt.meta.buffersize = sizeof(struct aie_enq_info);
+
+	return 0;
+}
+
+static const struct vb2_ops mtk_aie_vb2_ops = {
+	.queue_setup = mtk_aie_vb2_queue_setup,
+	.buf_out_validate = mtk_aie_vb2_buf_out_validate,
+	.buf_prepare = mtk_aie_vb2_buf_prepare,
+	.buf_queue = mtk_aie_vb2_buf_queue,
+	.start_streaming = mtk_aie_vb2_start_streaming,
+	.stop_streaming = mtk_aie_vb2_stop_streaming,
+	.wait_prepare = vb2_ops_wait_prepare,
+	.wait_finish = vb2_ops_wait_finish,
+	.buf_request_complete = mtk_aie_vb2_request_complete,
+};
+
+static const struct v4l2_ioctl_ops mtk_aie_v4l2_video_out_ioctl_ops = {
+	.vidioc_querycap = mtk_aie_querycap,
+	.vidioc_enum_fmt_vid_out = mtk_aie_enum_fmt_out_mp,
+	.vidioc_g_fmt_vid_out_mplane = mtk_aie_g_fmt_out_mp,
+	.vidioc_s_fmt_vid_out_mplane = mtk_aie_s_fmt_out_mp,
+	.vidioc_try_fmt_vid_out_mplane = mtk_aie_try_fmt_out_mp,
+	.vidioc_enum_fmt_meta_cap = mtk_aie_enum_fmt_meta_cap,
+	.vidioc_g_fmt_meta_cap = mtk_aie_g_fmt_meta_cap,
+	.vidioc_s_fmt_meta_cap = mtk_aie_g_fmt_meta_cap,
+	.vidioc_try_fmt_meta_cap = mtk_aie_g_fmt_meta_cap,
+	.vidioc_reqbufs = v4l2_m2m_ioctl_reqbufs,
+	.vidioc_create_bufs = v4l2_m2m_ioctl_create_bufs,
+	.vidioc_expbuf = v4l2_m2m_ioctl_expbuf,
+	.vidioc_prepare_buf = v4l2_m2m_ioctl_prepare_buf,
+	.vidioc_querybuf = v4l2_m2m_ioctl_querybuf,
+	.vidioc_qbuf = v4l2_m2m_ioctl_qbuf,
+	.vidioc_dqbuf = v4l2_m2m_ioctl_dqbuf,
+	.vidioc_streamon = v4l2_m2m_ioctl_streamon,
+	.vidioc_streamoff = v4l2_m2m_ioctl_streamoff,
+	.vidioc_subscribe_event = v4l2_ctrl_subscribe_event,
+	.vidioc_unsubscribe_event = v4l2_event_unsubscribe,
+};
+
+static int mtk_aie_queue_init(void *priv, struct vb2_queue *src_vq,
+			      struct vb2_queue *dst_vq)
+{
+	struct mtk_aie_ctx *ctx = priv;
+	int ret = -EINVAL;
+
+	src_vq->type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;
+	src_vq->io_modes = VB2_MMAP | VB2_DMABUF;
+	src_vq->supports_requests = true;
+	src_vq->drv_priv = ctx;
+	src_vq->ops = &mtk_aie_vb2_ops;
+	src_vq->mem_ops = &vb2_dma_contig_memops;
+	src_vq->buf_struct_size = sizeof(struct v4l2_m2m_buffer);
+	src_vq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;
+	src_vq->lock = &ctx->fd_dev->vfd_lock;
+	src_vq->dev = ctx->fd_dev->v4l2_dev.dev;
+
+	ret = vb2_queue_init(src_vq);
+	if (ret)
+		return ret;
+
+	dst_vq->type = V4L2_BUF_TYPE_META_CAPTURE;
+	dst_vq->io_modes = VB2_MMAP | VB2_DMABUF;
+	dst_vq->drv_priv = ctx;
+	dst_vq->ops = &mtk_aie_vb2_ops;
+	dst_vq->mem_ops = &vb2_dma_contig_memops;
+	dst_vq->buf_struct_size = sizeof(struct v4l2_m2m_buffer);
+	dst_vq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;
+	dst_vq->lock = &ctx->fd_dev->vfd_lock;
+	dst_vq->dev = ctx->fd_dev->v4l2_dev.dev;
+
+	return vb2_queue_init(dst_vq);
+}
+
+static struct v4l2_ctrl_config mtk_aie_controls[] = {
+	{
+		.id = V4L2_CID_MTK_AIE_INIT,
+		.name = "FD detection init",
+		.type = V4L2_CTRL_TYPE_U32,
+		.min = 0,
+		.max = 0xffffffff,
+		.step = 1,
+		.def = 0,
+		.dims = {sizeof(struct user_init) / 4},
+	},
+	{
+		.id = V4L2_CID_MTK_AIE_PARAM,
+		.name = "FD detection param",
+		.type = V4L2_CTRL_TYPE_U32,
+		.min = 0,
+		.max = 0xffffffff,
+		.step = 1,
+		.def = 0,
+		.dims = {sizeof(struct user_param) / 4},
+	},
+	{
+		.id = V4L2_CID_MTK_AIE_FD_VER,
+		.name = "FD detection fd ver",
+		.type = V4L2_CTRL_TYPE_U32,
+		.min = 0,
+		.max = 0xffffffff,
+		.step = 1,
+		.def = FD_VERSION,
+		.dims = {1},
+	},
+	{
+		.id = V4L2_CID_MTK_AIE_ATTR_VER,
+		.name = "FD detection attr ver",
+		.type = V4L2_CTRL_TYPE_U32,
+		.min = 0,
+		.max = 0xffffffff,
+		.step = 1,
+		.def = ATTR_VERSION,
+		.dims = {1},
+	},
+};
+
+static int mtk_aie_ctrls_setup(struct mtk_aie_ctx *ctx)
+{
+	struct v4l2_ctrl_handler *hdl = &ctx->hdl;
+	int i;
+
+	v4l2_ctrl_handler_init(hdl, V4L2_CID_MTK_AIE_MAX);
+	if (hdl->error)
+		return hdl->error;
+
+	mutex_init(&ctx->fd_dev->u_lock);
+	for (i = 0; i < ARRAY_SIZE(mtk_aie_controls); i++) {
+		v4l2_ctrl_new_custom(hdl, &mtk_aie_controls[i], ctx);
+		if (hdl->error) {
+			v4l2_ctrl_handler_free(hdl);
+			dev_info(ctx->dev, "Failed to register controls:%d", i);
+			return hdl->error;
+		}
+	}
+
+	ctx->fh.ctrl_handler = &ctx->hdl;
+	v4l2_ctrl_handler_setup(hdl);
+
+	return 0;
+}
+
+static void init_ctx_fmt(struct mtk_aie_ctx *ctx)
+{
+	struct v4l2_pix_format_mplane *src_fmt = &ctx->src_fmt;
+	struct v4l2_meta_format *dst_fmt = &ctx->dst_fmt;
+
+	/* Initialize M2M source fmt */
+	src_fmt->width = MTK_FD_OUTPUT_MAX_WIDTH;
+	src_fmt->height = MTK_FD_OUTPUT_MAX_HEIGHT;
+	mtk_aie_fill_pixfmt_mp(src_fmt, &mtk_aie_img_fmts[0]);
+
+	/* Initialize M2M destination fmt */
+	dst_fmt->buffersize = sizeof(struct aie_enq_info);
+	dst_fmt->dataformat = V4L2_META_FMT_MTFD_RESULT;
+}
+
+/*
+ * V4L2 file operations.
+ */
+static int mtk_vfd_open(struct file *filp)
+{
+	struct mtk_aie_dev *fd = video_drvdata(filp);
+	struct video_device *vdev = video_devdata(filp);
+	struct mtk_aie_ctx *ctx = NULL;
+	int ret = -EINVAL;
+
+	ctx = kzalloc(sizeof(struct mtk_aie_ctx), GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+
+	ctx->fd_dev = fd;
+	ctx->dev = fd->dev;
+	fd->ctx = ctx;
+
+	v4l2_fh_init(&ctx->fh, vdev);
+	filp->private_data = &ctx->fh;
+
+	init_ctx_fmt(ctx);
+
+	ret = mtk_aie_ctrls_setup(ctx);
+	if (ret) {
+		dev_info(ctx->dev, "Failed to set up controls:%d\n", ret);
+		goto err_fh_exit;
+	}
+	ctx->fh.m2m_ctx =
+		v4l2_m2m_ctx_init(fd->m2m_dev, ctx, &mtk_aie_queue_init);
+	if (IS_ERR(ctx->fh.m2m_ctx)) {
+		ret = PTR_ERR(ctx->fh.m2m_ctx);
+		goto err_free_ctrl_handler;
+	}
+	v4l2_fh_add(&ctx->fh);
+
+	return 0;
+err_free_ctrl_handler:
+	v4l2_ctrl_handler_free(&ctx->hdl);
+err_fh_exit:
+	v4l2_fh_exit(&ctx->fh);
+	kfree(ctx);
+
+	return ret;
+}
+
+static int mtk_vfd_release(struct file *filp)
+{
+	struct mtk_aie_ctx *ctx =
+		container_of(filp->private_data, struct mtk_aie_ctx, fh);
+
+	v4l2_m2m_ctx_release(ctx->fh.m2m_ctx);
+	v4l2_ctrl_handler_free(&ctx->hdl);
+	mutex_destroy(&ctx->fd_dev->u_lock);
+	v4l2_fh_del(&ctx->fh);
+	v4l2_fh_exit(&ctx->fh);
+
+	kfree(ctx);
+
+	return 0;
+}
+
+static const struct v4l2_file_operations fd_video_fops = {
+	.owner = THIS_MODULE,
+	.open = mtk_vfd_open,
+	.release = mtk_vfd_release,
+	.poll = v4l2_m2m_fop_poll,
+	.unlocked_ioctl = video_ioctl2,
+	.mmap = v4l2_m2m_fop_mmap,
+};
+
+static void mtk_aie_fill_user_param(struct mtk_aie_dev *fd,
+				    struct user_param *user_param,
+				    struct v4l2_ctrl_handler *hdl)
+{
+	struct v4l2_ctrl *ctrl;
+
+	ctrl = v4l2_ctrl_find(hdl, V4L2_CID_MTK_AIE_PARAM);
+	if (ctrl) {
+		memcpy(user_param, ctrl->p_new.p_u32, sizeof(struct user_param));
+	}
+	else {
+		dev_err(fd->dev, "NO V4L2_CID_MTK_AIE_PARAM!\n");
+	}
+}
+
+static void mtk_aie_device_run(void *priv)
+{
+	struct mtk_aie_ctx *ctx = priv;
+	struct mtk_aie_dev *fd = ctx->fd_dev;
+	struct vb2_v4l2_buffer *src_buf = NULL, *dst_buf = NULL;
+	struct fd_enq_param *fd_param = NULL;
+	void *plane_vaddr = NULL;
+	int ret = -EINVAL;
+
+	src_buf = v4l2_m2m_next_src_buf(ctx->fh.m2m_ctx);
+	dst_buf = v4l2_m2m_next_dst_buf(ctx->fh.m2m_ctx);
+
+	fd_param = kzalloc(sizeof(struct fd_enq_param),GFP_KERNEL);
+    if(!fd_param) {
+		dev_info(fd->dev, "NOMEM to allocate fd_param\n");
+		return;
+	}
+
+	fd_param->src_img[0].dma_addr =
+		vb2_dma_contig_plane_dma_addr(&src_buf->vb2_buf, 0);
+
+	if (ctx->src_fmt.num_planes == 2) {
+		fd_param->src_img[1].dma_addr =
+			vb2_dma_contig_plane_dma_addr(&src_buf->vb2_buf, 1);
+	}
+
+	mtk_aie_fill_user_param(fd, &fd_param->user_param, &ctx->hdl);
+
+	plane_vaddr = vb2_plane_vaddr(&dst_buf->vb2_buf, 0);
+	fd->aie_cfg = (struct aie_enq_info *)plane_vaddr;
+
+    memcpy(fd->aie_cfg, &fd_param->user_param, sizeof(struct user_param));
+
+	if (fd->variant->fld_enable) {
+		fd->aie_cfg->fld_face_num = fd_param->user_param.fld_face_num;
+		memcpy(fd->aie_cfg->fld_input, fd_param->user_param.fld_input,
+		       fld_max_frame * sizeof(struct fld_crop_rip_rop));
+	}
+
+	if (((fd->aie_cfg->sel_mode == 0) || (fd->aie_cfg->sel_mode == 1)) &&
+	    (fd->aie_cfg->src_img_fmt == FMT_YUV420_1P)) {
+		fd_param->src_img[1].dma_addr = fd_param->src_img[0].dma_addr +
+			fd_param->user_param.src_img_stride *
+			fd_param->user_param.src_img_height;
+	}
+
+	fd->aie_cfg->src_img_addr = fd_param->src_img[0].dma_addr;
+	fd->aie_cfg->src_img_addr_uv = fd_param->src_img[1].dma_addr;
+
+	ret = aie_prepare(fd, fd->aie_cfg);
+
+#ifdef CONFIG_INTERCONNECT_MTK_EXTENSION
+	mtk_aie_mmdvfs_set(fd, 1, fd->aie_cfg->freq_level);
+#endif
+
+	/* Complete request controls if any */
+	v4l2_ctrl_request_complete(src_buf->vb2_buf.req_obj.req, &ctx->hdl);
+
+	atomic_inc(&fd->num_composing);
+
+	mtk_aie_hw_job_exec(fd, fd_param);
+
+	kfree(fd_param);
+
+	if (ret) {
+		dev_info(fd->dev, "Failed to prepare aie setting\n");
+		return;
+	}
+
+	aie_execute(fd, fd->aie_cfg);
+}
+
+static struct v4l2_m2m_ops fd_m2m_ops = {
+	.device_run = mtk_aie_device_run,
+};
+
+static const struct media_device_ops fd_m2m_media_ops = {
+	.req_validate = vb2_request_validate,
+	.req_queue = v4l2_m2m_request_queue,
+};
+
+static int mtk_aie_video_device_register(struct mtk_aie_dev *fd)
+{
+	struct video_device *vfd = &fd->vfd;
+	struct v4l2_m2m_dev *m2m_dev = fd->m2m_dev;
+	struct device *dev = fd->dev;
+	int ret = -EINVAL;
+
+	vfd->fops = &fd_video_fops;
+	vfd->release = video_device_release_empty;
+	vfd->lock = &fd->vfd_lock;
+	vfd->v4l2_dev = &fd->v4l2_dev;
+	vfd->vfl_dir = VFL_DIR_M2M;
+	vfd->device_caps = V4L2_CAP_STREAMING | V4L2_CAP_VIDEO_OUTPUT_MPLANE |
+			   V4L2_CAP_META_CAPTURE;
+	vfd->ioctl_ops = &mtk_aie_v4l2_video_out_ioctl_ops;
+
+	strscpy(vfd->name, dev_driver_string(dev), sizeof(vfd->name));
+
+	video_set_drvdata(vfd, fd);
+
+	ret = video_register_device(vfd, VFL_TYPE_VIDEO, 0);
+	if (ret) {
+		dev_info(dev, "Failed to register video device\n");
+		goto err_free_dev;
+	}
+#ifdef CONFIG_MEDIA_CONTROLLER
+	ret = v4l2_m2m_register_media_controller(
+		m2m_dev, vfd, MEDIA_ENT_F_PROC_VIDEO_STATISTICS);
+	if (ret) {
+		dev_info(dev, "Failed to init mem2mem media controller\n");
+		goto err_unreg_video;
+	}
+#endif
+	return 0;
+#ifdef CONFIG_MEDIA_CONTROLLER
+err_unreg_video:
+	video_unregister_device(vfd);
+#endif
+err_free_dev:
+	return ret;
+}
+static int mtk_aie_dev_v4l2_init(struct mtk_aie_dev *fd)
+{
+#ifdef CONFIG_MEDIA_CONTROLLER
+	struct media_device *mdev = &fd->mdev;
+#endif
+	struct device *dev = fd->dev;
+	int ret = -EINVAL;
+
+	ret = v4l2_device_register(dev, &fd->v4l2_dev);
+	if (ret) {
+		dev_info(dev, "Failed to register v4l2 device\n");
+		return ret;
+	}
+
+	fd->m2m_dev = v4l2_m2m_init(&fd_m2m_ops);
+	if (IS_ERR(fd->m2m_dev)) {
+		dev_info(dev, "Failed to init mem2mem device\n");
+		ret = PTR_ERR(fd->m2m_dev);
+		goto err_unreg_v4l2_dev;
+	}
+#ifdef CONFIG_MEDIA_CONTROLLER
+	mdev->dev = dev;
+	strscpy(mdev->model, dev_driver_string(dev), sizeof(mdev->model));
+	snprintf(mdev->bus_info, sizeof(mdev->bus_info), "platform:%s",
+		 dev_name(dev));
+	media_device_init(mdev);
+	mdev->ops = &fd_m2m_media_ops;
+	fd->v4l2_dev.mdev = mdev;
+#endif
+
+	ret = mtk_aie_video_device_register(fd);
+	if (ret) {
+		dev_info(dev, "Failed to register video device\n");
+		goto err_cleanup_mdev;
+	}
+
+#ifdef CONFIG_MEDIA_CONTROLLER
+	ret = media_device_register(mdev);
+	if (ret) {
+		dev_info(dev, "Failed to register mem2mem media device\n");
+		goto err_unreg_vdev;
+	}
+#endif
+	return 0;
+
+#ifdef CONFIG_MEDIA_CONTROLLER
+err_unreg_vdev:
+	v4l2_m2m_unregister_media_controller(fd->m2m_dev);
+	video_unregister_device(&fd->vfd);
+#endif
+err_cleanup_mdev:
+#ifdef CONFIG_MEDIA_CONTROLLER
+	media_device_cleanup(mdev);
+#endif
+	v4l2_m2m_release(fd->m2m_dev);
+err_unreg_v4l2_dev:
+	v4l2_device_unregister(&fd->v4l2_dev);
+	return ret;
+}
+
+static void mtk_aie_video_device_unregister(struct mtk_aie_dev *fd)
+{
+#ifdef CONFIG_MEDIA_CONTROLLER
+	v4l2_m2m_unregister_media_controller(fd->m2m_dev);
+#endif
+	video_unregister_device(&fd->vfd);
+#ifdef CONFIG_MEDIA_CONTROLLER
+	media_device_cleanup(&fd->mdev);
+#endif
+	v4l2_m2m_release(fd->m2m_dev);
+	v4l2_device_unregister(&fd->v4l2_dev);
+}
+
+static irqreturn_t mtk_aie_irq(int irq, void *data)
+{
+	struct mtk_aie_dev *fd = (struct mtk_aie_dev *)data;
+
+	aie_irqhandle(fd);
+
+	queue_work(fd->frame_done_wq, &fd->req_work.work);
+
+	return IRQ_HANDLED;
+}
+
+static void mtk_aie_frame_done_worker(struct work_struct *work)
+{
+	struct mtk_aie_req_work *req_work = (struct mtk_aie_req_work *)work;
+	struct mtk_aie_dev *fd = (struct mtk_aie_dev *)req_work->fd_dev;
+
+	if (fd->reg_cfg.fd_mode == 0) {
+		fd->reg_cfg.hw_result = readl(fd->fd_base + AIE_RESULT_0_REG);
+		fd->reg_cfg.hw_result1 = readl(fd->fd_base + AIE_RESULT_1_REG);
+	}
+
+	switch (fd->aie_cfg->sel_mode) {
+	case 0:
+		aie_get_fd_result(fd, fd->aie_cfg);
+		break;
+	case 1:
+		aie_get_attr_result(fd, fd->aie_cfg);
+		break;
+	case 2:
+		if (fd->variant->fld_enable)
+			aie_get_fld_result(fd, fd->aie_cfg);
+		break;
+	default:
+		dev_info(fd->dev, "Wrong sel_mode\n");
+		break;
+	}
+
+#ifdef CONFIG_DEBUG_FS
+	if(fd->trace_info.trigger_dump[0] != '0')
+	{
+		cancel_delayed_work(&fd->job_timeout_work);
+		aie_irqhandle(fd);
+		aie_reset(fd);
+		atomic_dec(&fd->num_composing);
+		mtk_aie_hw_job_finish(fd, VB2_BUF_STATE_ERROR);
+		wake_up(&fd->flushing_waitq);
+		aie_dumpinfo(fd);
+		return;
+	}
+#endif
+	if (!cancel_delayed_work(&fd->job_timeout_work))
+		return;
+
+	atomic_dec(&fd->num_composing);
+	mtk_aie_hw_job_finish(fd, VB2_BUF_STATE_DONE);
+	wake_up(&fd->flushing_waitq);
+}
+#ifdef CONFIG_DEBUG_FS
+static int aie_dbg_dump_open(struct inode *inode, struct file *file)
+{
+    file->private_data = inode->i_private;
+	return 0;
+}
+
+static ssize_t aie_dbg_dump_read(struct file *file, char __user *buf,
+                              size_t len, loff_t *ppos)
+{
+	struct mtk_aie_dev *fd = file->private_data;
+
+	ssize_t ret_size = 0;
+	ret_size =	simple_read_from_buffer(buf, len, ppos,
+							   fd->trace_info.dump_buffer,
+							   fd->trace_info.offset_of_dump);
+
+	return ret_size;
+}
+
+static const struct file_operations aie_debug_dump_fops = {
+	.owner = THIS_MODULE,
+	.open = aie_dbg_dump_open,
+	.read = aie_dbg_dump_read,
+};
+
+static int aie_dbg_trigger_open(struct inode *inode, struct file *file)
+{
+    file->private_data = inode->i_private;
+	return 0;
+}
+
+static ssize_t aie_dbg_trigger_write(struct file *file, const char __user *buf,
+                              size_t len, loff_t *ppos)
+{
+	struct mtk_aie_dev *fd = file->private_data;
+	size_t ret = -EINVAL;
+
+	if (*ppos > sizeof(fd->trace_info.trigger_dump))
+		return -EINVAL;
+
+	ret = simple_write_to_buffer(fd->trace_info.trigger_dump, sizeof(fd->trace_info.trigger_dump), ppos, buf, len);
+
+	return ret;
+}
+
+static ssize_t aie_dbg_trigger_read(struct file *file, char __user *buf,
+                              size_t len, loff_t *ppos)
+{
+	struct mtk_aie_dev *fd = file->private_data;
+
+	return simple_read_from_buffer(buf, len, ppos,
+				fd->trace_info.trigger_dump,
+				sizeof(fd->trace_info.trigger_dump));
+}
+
+static const struct file_operations aie_debug_trigger_fops = {
+	.owner = THIS_MODULE,
+	.open = aie_dbg_trigger_open,
+	.write = aie_dbg_trigger_write,
+	.read = aie_dbg_trigger_read,
+};
+
+static struct dentry *aie_debugfs_dump,*aie_debugfs_trigger,*aie_debugfs_ydata,*aie_debugfs_root;
+#endif
+
+static int mtk_aie_probe(struct platform_device *pdev)
+{
+	struct mtk_aie_dev *fd = NULL;
+	struct device *dev = &pdev->dev;
+
+	int irq = -1;
+	int ret = -EINVAL;
+
+	fd = devm_kzalloc(&pdev->dev, sizeof(struct mtk_aie_dev), GFP_KERNEL);
+	if (!fd)
+		return -ENOMEM;
+
+	fd->variant = mtk_aie_get_drv_data(dev);
+
+	if (dma_set_mask_and_coherent(dev, DMA_BIT_MASK(34)))
+		dev_info(dev, "%s: No suitable DMA available\n", __func__);
+
+	dev_set_drvdata(dev, fd);
+	fd->dev = dev;
+
+	irq = platform_get_irq(pdev, 0);
+	if (irq < 0) {
+		dev_info(dev, "Failed to get irq by platform: %d\n", irq);
+		return irq;
+	}
+
+	ret = devm_request_irq(dev, irq, mtk_aie_irq, IRQF_SHARED,
+			       dev_driver_string(dev), fd);
+	if (ret) {
+		dev_err(dev, "Failed to request irq\n");
+		return ret;
+	}
+
+	disable_irq(irq);
+	fd->irq = irq;
+
+	fd->fd_base = devm_platform_ioremap_resource(pdev, 0);
+	if (IS_ERR(fd->fd_base)) {
+		dev_info(dev, "Failed to get fd reg base\n");
+		return PTR_ERR(fd->fd_base);
+	}
+
+	fd->aie_clk.clk_num = ARRAY_SIZE(aie_clks);
+	fd->aie_clk.clks = aie_clks;
+	ret = devm_clk_bulk_get(&pdev->dev, fd->aie_clk.clk_num, fd->aie_clk.clks);
+	if (ret) {
+		dev_info(dev,"failed to get raw clock:%d\n", ret);
+	}
+	mutex_init(&fd->vfd_lock);
+#ifdef CONFIG_DEBUG_FS
+	aie_debugfs_root = debugfs_create_dir("mtk_aie", NULL);
+	if (!aie_debugfs_root) {
+		return -ENOMEM;
+	}
+
+	aie_debugfs_dump = debugfs_create_file("dumpinfo", S_IRUGO, aie_debugfs_root, fd,
+					  &aie_debug_dump_fops);
+	if (!aie_debugfs_dump) {
+		return -ENOMEM;
+	}
+
+	aie_debugfs_trigger = debugfs_create_file("trigger_dump", S_IRUGO | S_IWUGO, aie_debugfs_root, fd,
+					  &aie_debug_trigger_fops);
+	if (!aie_debugfs_trigger) {
+		return -ENOMEM;
+	}
+
+	ydata.data = (void*)rawdata;
+	ydata.size = AIE_DEBUG_RAW_DATA_SIZE;
+
+	aie_debugfs_ydata = debugfs_create_blob("ydata.raw", S_IRUGO, aie_debugfs_root,
+						&ydata);
+	if (!aie_debugfs_ydata) {
+		return -ENOMEM;
+	}
+
+	fd->trace_info.size_of_dump = AIE_DUMP_BUFFER_SIZE;
+	fd->trace_info.dump_buffer = kmalloc(fd->trace_info.size_of_dump, GFP_KERNEL);
+	if (!fd->trace_info.dump_buffer)
+		return -ENOMEM;
+
+	fd->trace_info.trigger_dump[0] = '0';
+	fd->trace_info.trigger_dump[1] = '\n';
+	fd->trace_info.trigger_dump[2] = '\0';
+#endif
+
+	init_completion(&fd->fd_job_finished);
+	INIT_DELAYED_WORK(&fd->job_timeout_work, mtk_aie_job_timeout_work);
+	init_waitqueue_head(&fd->flushing_waitq);
+	atomic_set(&fd->num_composing, 0);
+
+	fd->frame_done_wq =
+			alloc_ordered_workqueue(dev_name(fd->dev),
+						WQ_HIGHPRI | WQ_FREEZABLE);
+	if (!fd->frame_done_wq) {
+		dev_info(fd->dev, "failed to alloc frame_done workqueue\n");
+		mutex_destroy(&fd->vfd_lock);
+		return -ENOMEM;
+	}
+
+	INIT_WORK(&fd->req_work.work, mtk_aie_frame_done_worker);
+	fd->req_work.fd_dev = fd;
+
+#ifdef CONFIG_INTERCONNECT_MTK_EXTENSION
+	ret = mtk_aie_mmdvfs_init(fd);
+	if (ret) {
+		dev_info(dev, "Failed to init mmdvfs: %d\n", ret);
+		goto err_destroy_mutex;
+	}
+	ret = mtk_aie_mmqos_init(fd);
+	if (ret) {
+		dev_info(dev, "Failed to init mmdvfs: %d\n", ret);
+		goto err_destroy_mutex;
+	}
+#endif
+	pm_runtime_enable(dev);
+	ret = mtk_aie_dev_v4l2_init(fd);
+	if (ret) {
+		dev_info(dev, "Failed to init v4l2 device: %d\n", ret);
+		goto err_disable_pm;
+	}
+	dev_info(dev, "AIE : Success to %s\n", __func__);
+
+	return 0;
+
+err_disable_pm:
+	pm_runtime_disable(fd->dev);
+#ifdef CONFIG_INTERCONNECT_MTK_EXTENSION
+err_destroy_mutex:
+	mtk_aie_mmdvfs_uninit(fd);
+	mtk_aie_mmqos_uninit(fd);
+#endif
+	destroy_workqueue(fd->frame_done_wq);
+	mutex_destroy(&fd->vfd_lock);
+
+	return ret;
+}
+
+static int mtk_aie_remove(struct platform_device *pdev)
+{
+	struct mtk_aie_dev *fd = dev_get_drvdata(&pdev->dev);
+
+	mtk_aie_video_device_unregister(fd);
+	pm_runtime_disable(&pdev->dev);
+#ifdef CONFIG_INTERCONNECT_MTK_EXTENSION
+	mtk_aie_mmdvfs_uninit(fd);
+	mtk_aie_mmqos_uninit(fd);
+#endif
+	destroy_workqueue(fd->frame_done_wq);
+	fd->frame_done_wq = NULL;
+	mutex_destroy(&fd->vfd_lock);
+#ifdef CONFIG_DEBUG_FS
+	if(fd->trace_info.dump_buffer){
+		kfree(fd->trace_info.dump_buffer);
+	}
+#endif
+	return 0;
+}
+
+static int mtk_aie_suspend(struct device *dev)
+{
+	struct mtk_aie_dev *fd = dev_get_drvdata(dev);
+	int ret = -EINVAL, num = 0;
+
+	if (pm_runtime_suspended(dev))
+		return 0;
+
+	num = atomic_read(&fd->num_composing);
+	dev_info(dev, "%s: suspend aie job start, num(%d)\n", __func__, num);
+
+	ret = wait_event_timeout
+		(fd->flushing_waitq,
+		 !(num = atomic_read(&fd->num_composing)),
+		 msecs_to_jiffies(MTK_FD_HW_TIMEOUT));
+	if (!ret && num) {
+		dev_info(dev, "%s: flushing aie job timeout, num(%d)\n",
+			__func__, num);
+
+		return -EBUSY;
+	}
+
+	dev_info(dev, "%s: suspend aie job end, num(%d)\n", __func__, num);
+
+	ret = pm_runtime_force_suspend(dev);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+static int mtk_aie_resume(struct device *dev)
+{
+	int ret = -EINVAL;
+
+	dev_info(dev, "%s: resume aie job start)\n", __func__);
+
+	if (pm_runtime_suspended(dev)) {
+		dev_info(dev, "%s: pm_runtime_suspended is true, no action\n",
+			__func__);
+		return 0;
+	}
+
+	ret = pm_runtime_force_resume(dev);
+	if (ret)
+		return ret;
+
+	dev_info(dev, "%s: resume aie job end)\n", __func__);
+	return 0;
+}
+
+static int mtk_aie_runtime_suspend(struct device *dev)
+{
+	struct mtk_aie_dev *fd = dev_get_drvdata(dev);
+
+	clk_bulk_disable_unprepare(fd->aie_clk.clk_num, fd->aie_clk.clks);
+
+	disable_irq(fd->irq);
+
+	return 0;
+}
+
+static int mtk_aie_runtime_resume(struct device *dev)
+{
+	struct mtk_aie_dev *fd = dev_get_drvdata(dev);
+	int ret = -EINVAL;
+
+
+	enable_irq(fd->irq);
+
+	ret = clk_bulk_prepare_enable(fd->aie_clk.clk_num, fd->aie_clk.clks);
+	if (ret) {
+		dev_info(dev,"failed to enable clock:%d\n", ret);
+    	return ret;
+	}
+
+	return 0;
+}
+
+static const struct dev_pm_ops mtk_aie_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(mtk_aie_suspend, mtk_aie_resume)
+	SET_RUNTIME_PM_OPS(mtk_aie_runtime_suspend, mtk_aie_runtime_resume, NULL)
+};
+
+static struct mtk_aie_variant aie_30_drvdata = {
+	.hw_version	= 30,
+	.fld_enable	= 0,
+	.y2r_cfg_size	= 32,
+	.rs_cfg_size	= 28,
+	.fd_cfg_size	= 54,
+};
+
+static struct mtk_aie_variant aie_31_drvdata = {
+	.hw_version	= 31,
+	.fld_enable	= 1,
+	.y2r_cfg_size	= 34,
+	.rs_cfg_size	= 30,
+	.fd_cfg_size	= 56,
+};
+
+static const struct of_device_id mtk_aie_of_ids[] = {
+	{
+		.compatible = "mediatek,aie-hw3.0",
+		.data = &aie_30_drvdata,
+	}, 
+	{
+		.compatible = "mediatek,aie-hw3.1",
+		.data = &aie_31_drvdata,
+	},
+	{ /* end of list */ },
+};
+MODULE_DEVICE_TABLE(of, mtk_aie_of_ids);
+
+static void *mtk_aie_get_drv_data(struct device *dev)
+{
+	struct mtk_aie_variant *driver_data = NULL;
+	const struct of_device_id *match = NULL;
+
+	if (!IS_ENABLED(CONFIG_OF) || !dev->of_node)
+		return &aie_30_drvdata;
+
+	match = of_match_node(mtk_aie_of_ids, dev->of_node);
+
+	if (match)
+		driver_data = (struct mtk_aie_variant *)match->data;
+
+	return driver_data;
+}
+
+static struct platform_driver mtk_aie_driver = {
+	.probe = mtk_aie_probe,
+	.remove = mtk_aie_remove,
+	.driver = {
+		.name = "mtk-aie-5.3",
+		.of_match_table = of_match_ptr(mtk_aie_of_ids),
+		.pm = &mtk_aie_pm_ops,
+	} };
+
+module_platform_driver(mtk_aie_driver);
+MODULE_AUTHOR("Fish Wu <fish.wu@mediatek.com>");
+MODULE_LICENSE("GPL v2");
+MODULE_DESCRIPTION("Mediatek AIE driver");
diff --git a/drivers/media/platform/mediatek/aie/mtk_aie_drv.c b/drivers/media/platform/mediatek/aie/mtk_aie_drv.c
new file mode 100644
index 0000000000000000000000000000000000000000..8628d6772a0401e3b93d2affa2514ff59f9871e8
--- /dev/null
+++ b/drivers/media/platform/mediatek/aie/mtk_aie_drv.c
@@ -0,0 +1,3367 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2020 MediaTek Inc.
+ *
+ * Author: Fish Wu <fish.wu@mediatek.com>
+ *
+ */
+
+#include <linux/delay.h>
+#include <linux/firmware.h>
+#include "mtk_aie.h"
+
+static const unsigned int fd_wdma_en[fd_loop_num][output_WDMA_WRA_num] = {
+	{1, 0, 0, 0}, {1, 0, 1, 0}, {1, 0, 1, 0}, {1, 0, 0, 0}, {1, 1, 1, 1},
+	{1, 1, 1, 1}, {1, 0, 0, 0}, {1, 0, 1, 0}, {1, 1, 0, 0}, {1, 0, 0, 0},
+	{1, 0, 1, 0}, {1, 1, 0, 0}, {1, 0, 0, 0}, {1, 0, 0, 0}, {1, 0, 0, 0},
+	{1, 0, 0, 0}, {1, 0, 0, 0}, {1, 0, 0, 0}, {1, 1, 0, 0}, {1, 1, 0, 0},
+	{1, 1, 0, 0}, {1, 0, 0, 0}, {1, 1, 1, 1}, {1, 1, 1, 1}, {1, 1, 0, 0},
+	{1, 1, 0, 0}, {1, 1, 0, 0}, {1, 0, 0, 0}, {1, 0, 0, 0}, {1, 0, 0, 0},
+	{1, 0, 1, 0}, {1, 0, 1, 0}, {1, 0, 0, 0}, {1, 1, 1, 1}, {1, 1, 1, 1},
+	{1, 0, 0, 0}, {1, 0, 1, 0}, {1, 1, 0, 0}, {1, 0, 0, 0}, {1, 0, 1, 0},
+	{1, 1, 0, 0}, {1, 0, 0, 0}, {1, 0, 0, 0}, {1, 0, 0, 0}, {1, 0, 0, 0},
+	{1, 0, 0, 0}, {1, 0, 0, 0}, {1, 1, 0, 0}, {1, 1, 0, 0}, {1, 1, 0, 0},
+	{1, 0, 0, 0}, {1, 1, 1, 1}, {1, 1, 1, 1}, {1, 1, 0, 0}, {1, 1, 0, 0},
+	{1, 1, 0, 0}, {1, 0, 0, 0}, {1, 0, 0, 0}, {1, 0, 0, 0}, {1, 0, 1, 0},
+	{1, 0, 1, 0}, {1, 0, 0, 0}, {1, 1, 1, 1}, {1, 1, 1, 1}, {1, 0, 0, 0},
+	{1, 0, 1, 0}, {1, 1, 0, 0}, {1, 0, 0, 0}, {1, 0, 1, 0}, {1, 1, 0, 0},
+	{1, 0, 0, 0}, {1, 0, 0, 0}, {1, 0, 0, 0}, {1, 0, 0, 0}, {1, 0, 0, 0},
+	{1, 0, 0, 0}, {1, 1, 0, 0}, {1, 1, 0, 0}, {1, 1, 0, 0}, {1, 0, 0, 0},
+	{1, 1, 1, 1}, {1, 1, 1, 1}, {1, 1, 0, 0}, {1, 1, 0, 0}, {1, 1, 0, 0},
+	{1, 0, 0, 0}, {1, 0, 0, 0} };
+
+static const unsigned int out_stride_size[fd_loop_num][output_WDMA_WRA_num] = {
+	{1, 0, 0, 0}, {1, 0, 2, 0}, {1, 0, 2, 0}, {1, 0, 0, 0}, {1, 1, 2, 2},
+	{1, 1, 2, 2}, {1, 0, 0, 0}, {1, 0, 2, 0}, {1, 1, 0, 0}, {1, 0, 0, 0},
+	{1, 0, 2, 0}, {1, 1, 0, 0}, {1, 0, 0, 0}, {1, 0, 0, 0}, {1, 0, 0, 0},
+	{1, 0, 0, 0}, {1, 0, 0, 0}, {1, 0, 0, 0}, {1, 1, 0, 0}, {1, 1, 0, 0},
+	{1, 1, 0, 0}, {1, 0, 0, 0}, {1, 1, 1, 1}, {1, 1, 1, 1}, {1, 1, 0, 0},
+	{1, 1, 0, 0}, {1, 1, 0, 0}, {1, 0, 0, 0}, {3, 0, 0, 0}, {1, 0, 0, 0},
+	{1, 0, 2, 0}, {1, 0, 2, 0}, {1, 0, 0, 0}, {1, 1, 2, 2}, {1, 1, 2, 2},
+	{1, 0, 0, 0}, {1, 0, 2, 0}, {1, 1, 0, 0}, {1, 0, 0, 0}, {1, 0, 2, 0},
+	{1, 1, 0, 0}, {1, 0, 0, 0}, {1, 0, 0, 0}, {1, 0, 0, 0}, {1, 0, 0, 0},
+	{1, 0, 0, 0}, {1, 0, 0, 0}, {1, 1, 0, 0}, {1, 1, 0, 0}, {1, 1, 0, 0},
+	{1, 0, 0, 0}, {1, 1, 1, 1}, {1, 1, 1, 1}, {1, 1, 0, 0}, {1, 1, 0, 0},
+	{1, 1, 0, 0}, {1, 0, 0, 0}, {3, 0, 0, 0}, {1, 0, 0, 0}, {1, 0, 2, 0},
+	{1, 0, 2, 0}, {1, 0, 0, 0}, {1, 1, 2, 2}, {1, 1, 2, 2}, {1, 0, 0, 0},
+	{1, 0, 2, 0}, {1, 1, 0, 0}, {1, 0, 0, 0}, {1, 0, 2, 0}, {1, 1, 0, 0},
+	{1, 0, 0, 0}, {1, 0, 0, 0}, {1, 0, 0, 0}, {1, 0, 0, 0}, {1, 0, 0, 0},
+	{1, 0, 0, 0}, {1, 1, 0, 0}, {1, 1, 0, 0}, {1, 1, 0, 0}, {1, 0, 0, 0},
+	{1, 1, 1, 1}, {1, 1, 1, 1}, {1, 1, 0, 0}, {1, 1, 0, 0}, {1, 1, 0, 0},
+	{1, 0, 0, 0}, {3, 0, 0, 0} };
+
+static const unsigned int fd_ker_rdma_size[fd_loop_num][kernel_RDMA_RA_num] = {
+	{240, 240},   {1168, 1168}, {1168, 1168}, {272, 272},   {2320, 2320},
+	{2080, 2080}, {1040, 1040}, {4624, 4624}, {3104, 3104}, {9232, 9232},
+	{4624, 4624}, {4128, 4128}, {1040, 1040}, {4624, 4624}, {4624, 4624},
+	{1552, 1552}, {4624, 4624}, {4624, 4624}, {4128, 4128}, {1040, 1040},
+	{1040, 1040}, {528, 528},   {4160, 4160}, {4160, 4160}, {2080, 2080},
+	{2080, 2080}, {2080, 2080}, {1040, 1040}, {0, 0},       {240, 240},
+	{1168, 1168}, {1168, 1168}, {272, 272},   {2320, 2320}, {2080, 2080},
+	{1040, 1040}, {4624, 4624}, {3104, 3104}, {9232, 9232}, {4624, 4624},
+	{4128, 4128}, {1040, 1040}, {4624, 4624}, {4624, 4624}, {1552, 1552},
+	{4624, 4624}, {4624, 4624}, {4128, 4128}, {1040, 1040}, {1040, 1040},
+	{528, 528},   {4160, 4160}, {4160, 4160}, {2080, 2080}, {2080, 2080},
+	{2080, 2080}, {1040, 1040}, {0, 0},       {240, 240},   {1168, 1168},
+	{1168, 1168}, {272, 272},   {2320, 2320}, {2080, 2080}, {1040, 1040},
+	{4624, 4624}, {3104, 3104}, {9232, 9232}, {4624, 4624}, {4128, 4128},
+	{1040, 1040}, {4624, 4624}, {4624, 4624}, {1552, 1552}, {4624, 4624},
+	{4624, 4624}, {4128, 4128}, {1040, 1040}, {1040, 1040}, {528, 528},
+	{4160, 4160}, {4160, 4160}, {2080, 2080}, {2080, 2080}, {2080, 2080},
+	{1040, 1040}, {0, 0} };
+
+static const unsigned int fd_out_stride2_in[fd_loop_num] = {
+	0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
+	0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
+
+static const unsigned int fd_stride[fd_loop_num] = {
+	2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+	1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1,
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1};
+
+static const unsigned int fd_maxpool[fd_loop_num] = {
+	0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
+
+static const unsigned int out_2size[fd_loop_num] = {
+	0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 1,
+	0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
+
+static const unsigned int in_ch_pack[fd_loop_num] = {
+	1, 16, 16, 16, 16, 16, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
+	32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 0,  1,  16, 16, 16, 16, 16, 32,
+	32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
+	32, 32, 32, 0,  1,  16, 16, 16, 16, 16, 32, 32, 32, 32, 32, 32, 32, 32,
+	32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 0};
+
+static const unsigned int outlayer[fd_loop_num] = {
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1,
+	1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0};
+static const unsigned int out_ch_pack[fd_loop_num] = {
+	16, 16, 16, 16, 16, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
+	32, 32, 32, 32, 16, 16, 16, 32, 32, 32, 32, 32, 32, 0,  16,
+	16, 16, 16, 16, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
+	32, 32, 32, 16, 16, 16, 32, 32, 32, 32, 32, 32, 0,  16, 16,
+	16, 16, 16, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
+	32, 32, 16, 16, 16, 32, 32, 32, 32, 32, 32, 0};
+
+static const unsigned int anchor_en_num[fd_loop_num] = {
+	5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
+	5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
+	5,  5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
+	5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5};
+
+/* [loop][ch][output_index] */
+static const signed int fd_rdma_en[fd_loop_num][input_WDMA_WRA_num][2] = {
+	{{99, 99}, {99, 99}, {99, 99}, {-1, -1} },
+	{{0, 0}, {-1, -1}, {-1, -1}, {-1, -1} },
+	{{1, 0}, {-1, -1}, {-1, -1}, {-1, -1} },
+	{{1, 0}, {2, 0}, {-1, -1}, {-1, -1} },
+	{{3, 0}, {-1, -1}, {-1, -1}, {-1, -1} },
+	{{1, 2}, {2, 2}, {4, 2}, {4, 3} },
+	{{5, 0}, {5, 1}, {-1, -1}, {-1, -1} },
+	{{6, 0}, {-1, -1}, {-1, -1}, {-1, -1} },
+	{{5, 0}, {5, 1}, {7, 0}, {-1, -1} },
+	{{8, 0}, {8, 1}, {-1, -1}, {-1, -1} },
+	{{9, 0}, {-1, -1}, {-1, -1}, {-1, -1} },
+	{{5, 2}, {5, 3}, {7, 2}, {10, 2} },
+	{{11, 0}, {11, 1}, {-1, -1}, {-1, -1} },
+	{{12, 0}, {-1, -1}, {-1, -1}, {-1, -1} },
+	{{13, 0}, {-1, -1}, {-1, -1}, {-1, -1} },
+	{{11, 0}, {11, 1}, {14, 0}, {-1, -1} },
+	{{15, 0}, {-1, -1}, {-1, -1}, {-1, -1} },
+	{{16, 0}, {-1, -1}, {-1, -1}, {-1, -1} },
+	{{11, 0}, {11, 1}, {14, 0}, {17, 0} },
+	{{18, 0}, {18, 1}, {-1, -1}, {-1, -1} },
+	{{18, 0}, {18, 1}, {-1, -1}, {-1, -1} },
+	{{18, 0}, {18, 1}, {-1, -1}, {-1, -1} },
+	{{18, 0}, {18, 1}, {-1, -1}, {-1, -1} },
+	{{18, 0}, {18, 1}, {-1, -1}, {-1, -1} },
+	{{18, 0}, {18, 1}, {-1, -1}, {-1, -1} },
+	{{18, 0}, {18, 1}, {-1, -1}, {-1, -1} },
+	{{18, 0}, {18, 1}, {-1, -1}, {-1, -1} },
+	{{18, 0}, {18, 1}, {-1, -1}, {-1, -1} },
+	{{19, 0}, {22, 0}, {22, 1}, {25, 0} },
+	{{99, 99}, {99, 99}, {99, 99}, {-1, -1} },
+	{{29, 0}, {-1, -1}, {-1, -1}, {-1, -1} },
+	{{30, 0}, {-1, -1}, {-1, -1}, {-1, -1} },
+	{{30, 0}, {31, 0}, {-1, -1}, {-1, -1} },
+	{{32, 0}, {-1, -1}, {-1, -1}, {-1, -1} },
+	{{30, 2}, {31, 2}, {33, 2}, {33, 3} },
+	{{34, 0}, {34, 1}, {-1, -1}, {-1, -1} },
+	{{35, 0}, {-1, -1}, {-1, -1}, {-1, -1} },
+	{{34, 0}, {34, 1}, {36, 0}, {-1, -1} },
+	{{37, 0}, {37, 1}, {-1, -1}, {-1, -1} },
+	{{38, 0}, {-1, -1}, {-1, -1}, {-1, -1} },
+	{{34, 2}, {34, 3}, {36, 2}, {39, 2} },
+	{{40, 0}, {40, 1}, {-1, -1}, {-1, -1} },
+	{{41, 0}, {-1, -1}, {-1, -1}, {-1, -1} },
+	{{42, 0}, {-1, -1}, {-1, -1}, {-1, -1} },
+	{{40, 0}, {40, 1}, {43, 0}, {-1, -1} },
+	{{44, 0}, {-1, -1}, {-1, -1}, {-1, -1} },
+	{{45, 0}, {-1, -1}, {-1, -1}, {-1, -1} },
+	{{40, 0}, {40, 1}, {43, 0}, {46, 0} },
+	{{47, 0}, {47, 1}, {-1, -1}, {-1, -1} },
+	{{47, 0}, {47, 1}, {-1, -1}, {-1, -1} },
+	{{47, 0}, {47, 1}, {-1, -1}, {-1, -1} },
+	{{47, 0}, {47, 1}, {-1, -1}, {-1, -1} },
+	{{47, 0}, {47, 1}, {-1, -1}, {-1, -1} },
+	{{47, 0}, {47, 1}, {-1, -1}, {-1, -1} },
+	{{47, 0}, {47, 1}, {-1, -1}, {-1, -1} },
+	{{47, 0}, {47, 1}, {-1, -1}, {-1, -1} },
+	{{47, 0}, {47, 1}, {-1, -1}, {-1, -1} },
+	{{48, 0}, {51, 0}, {51, 1}, {54, 0} },
+	{{99, 99}, {99, 99}, {99, 99}, {-1, -1} },
+	{{58, 0}, {-1, -1}, {-1, -1}, {-1, -1} },
+	{{59, 0}, {-1, -1}, {-1, -1}, {-1, -1} },
+	{{59, 0}, {60, 0}, {-1, -1}, {-1, -1} },
+	{{61, 0}, {-1, -1}, {-1, -1}, {-1, -1} },
+	{{59, 2}, {60, 2}, {62, 2}, {62, 3} },
+	{{63, 0}, {63, 1}, {-1, -1}, {-1, -1} },
+	{{64, 0}, {-1, -1}, {-1, -1}, {-1, -1} },
+	{{63, 0}, {63, 1}, {65, 0}, {-1, -1} },
+	{{66, 0}, {66, 1}, {-1, -1}, {-1, -1} },
+	{{67, 0}, {-1, -1}, {-1, -1}, {-1, -1} },
+	{{63, 2}, {63, 3}, {65, 2}, {68, 2} },
+	{{69, 0}, {69, 1}, {-1, -1}, {-1, -1} },
+	{{70, 0}, {-1, -1}, {-1, -1}, {-1, -1} },
+	{{71, 0}, {-1, -1}, {-1, -1}, {-1, -1} },
+	{{69, 0}, {69, 1}, {72, 0}, {-1, -1} },
+	{{73, 0}, {-1, -1}, {-1, -1}, {-1, -1} },
+	{{74, 0}, {-1, -1}, {-1, -1}, {-1, -1} },
+	{{69, 0}, {69, 1}, {72, 0}, {75, 0} },
+	{{76, 0}, {76, 1}, {-1, -1}, {-1, -1} },
+	{{76, 0}, {76, 1}, {-1, -1}, {-1, -1} },
+	{{76, 0}, {76, 1}, {-1, -1}, {-1, -1} },
+	{{76, 0}, {76, 1}, {-1, -1}, {-1, -1} },
+	{{76, 0}, {76, 1}, {-1, -1}, {-1, -1} },
+	{{76, 0}, {76, 1}, {-1, -1}, {-1, -1} },
+	{{76, 0}, {76, 1}, {-1, -1}, {-1, -1} },
+	{{76, 0}, {76, 1}, {-1, -1}, {-1, -1} },
+	{{76, 0}, {76, 1}, {-1, -1}, {-1, -1} },
+	{{77, 0}, {80, 0}, {80, 1}, {83, 0} } };
+
+static const unsigned int attr_wdma_en[attr_loop_num][output_WDMA_WRA_num] = {
+	{1, 0, 1, 0}, {1, 0, 1, 0}, {1, 0, 0, 0}, {1, 1, 1, 1}, {1, 1, 1, 1},
+	{1, 0, 1, 0}, {1, 1, 0, 0}, {1, 0, 1, 0}, {1, 1, 0, 0}, {1, 0, 0, 0},
+	{1, 0, 0, 0}, {1, 0, 0, 0}, {1, 0, 0, 0}, {1, 0, 0, 0}, {1, 0, 0, 0},
+	{1, 1, 0, 0}, {1, 0, 0, 0}, {1, 0, 0, 0}, {1, 0, 0, 0}, {1, 0, 0, 0},
+	{1, 0, 0, 0}, {1, 0, 0, 0}, {1, 0, 0, 0}, {1, 0, 0, 0}, {1, 0, 0, 0},
+	{1, 0, 0, 0} };
+static const unsigned int
+	attr_ker_rdma_size[attr_loop_num][kernel_RDMA_RA_num] = {
+		{240, 240},   {1168, 1168}, {272, 272},   {2320, 2320},
+		{2080, 2080}, {9232, 9232}, {3104, 3104}, {9232, 9232},
+		{4128, 4128}, {1040, 1040}, {4624, 4624}, {4624, 4624},
+		{1552, 1552}, {4624, 4624}, {4624, 4624}, {4128, 4128},
+		{9232, 9232}, {272, 272},   {9232, 9232}, {2320, 2320},
+		{144, 144},   {9232, 9232}, {272, 272},   {9232, 9232},
+		{2320, 2320}, {144, 144} };
+static const unsigned int attr_out_stride2_as_in[attr_loop_num] = {
+	0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
+static const unsigned int attr_fd_stride[attr_loop_num] = {/* H */
+							   2, 1, 1, 1, 1, 1, 1,
+							   1, 1, 1, 1, 1, 1, 1,
+							   1, 1, 1, 1, 1, 1, 1,
+							   1, 1, 1, 1, 1};
+static const unsigned int attr_fd_maxpool[attr_loop_num] = {/* L */
+							    1, 0, 0, 0, 0, 0, 0,
+							    0, 0, 0, 0, 0, 0, 0,
+							    0, 0, 0, 0, 0, 0, 0,
+							    0, 0, 0, 0, 0};
+static const unsigned int attr_out_2size[attr_loop_num] = {/* O */
+							   1, 1, 0, 1, 1, 1, 0,
+							   1, 0, 0, 0, 0, 0, 0,
+							   0, 0, 0, 0, 0, 0, 0,
+							   0, 0, 0, 0, 0};
+/* [loop][ch][output_index] */
+static const signed int attr_rdma_en[attr_loop_num][input_WDMA_WRA_num][2] = {
+	{{99, 99}, {99, 99}, {99, 99}, {-1, -1} },
+	{{0, 0}, {-1, -1}, {-1, -1}, {-1, -1} },
+	{{0, 0}, {1, 0}, {-1, -1}, {-1, -1} },
+	{{2, 0}, {-1, -1}, {-1, -1}, {-1, -1} },
+	{{0, 2}, {1, 2}, {3, 2}, {3, 3} },
+	{{4, 0}, {4, 1}, {-1, -1}, {-1, -1} },
+	{{4, 0}, {4, 1}, {5, 0}, {-1, -1} },
+	{{6, 0}, {6, 1}, {-1, -1}, {-1, -1} },
+	{{4, 2}, {4, 3}, {5, 2}, {7, 2} },
+	{{8, 0}, {8, 1}, {-1, -1}, {-1, -1} },
+	{{9, 0}, {-1, -1}, {-1, -1}, {-1, -1} },
+	{{10, 0}, {-1, -1}, {-1, -1}, {-1, -1} },
+	{{8, 0}, {8, 1}, {11, 0}, {-1, -1} },
+	{{12, 0}, {-1, -1}, {-1, -1}, {-1, -1} },
+	{{13, 0}, {-1, -1}, {-1, -1}, {-1, -1} },
+	{{8, 0}, {8, 1}, {11, 0}, {14, 0} },
+	{{15, 0}, {15, 1}, {-1, -1}, {-1, -1} },
+	{{16, 0}, {-1, -1}, {-1, -1}, {-1, -1} },
+	{{15, 0}, {15, 1}, {-1, -1}, {-1, -1} },
+	{{18, 0}, {-1, -1}, {-1, -1}, {-1, -1} },
+	{{19, 0}, {-1, -1}, {-1, -1}, {-1, -1} },
+	{{15, 0}, {15, 1}, {-1, -1}, {-1, -1} },
+	{{21, 0}, {-1, -1}, {-1, -1}, {-1, -1} },
+	{{15, 0}, {15, 1}, {-1, -1}, {-1, -1} },
+	{{23, 0}, {-1, -1}, {-1, -1}, {-1, -1} },
+	{{24, 0}, {-1, -1}, {-1, -1}, {-1, -1} } };
+
+static const unsigned int attr_wdma_size[attr_loop_num][output_WDMA_WRA_num] = {
+	{16384, 0, 4096, 0},
+	{16384, 0, 4096, 0},
+	{16384, 0, 0, 0},
+	{16384, 16384, 4096, 4096},
+	{8192, 8192, 2048, 2048},
+	{8192, 0, 2048, 0},
+	{8192, 8192, 0, 0},
+	{8192, 0, 2048, 0},
+	{2048, 2048, 0, 0},
+	{2048, 0, 0, 0},
+	{2048, 0, 0, 0},
+	{2048, 0, 0, 0},
+	{2048, 0, 0, 0},
+	{2048, 0, 0, 0},
+	{2048, 0, 0, 0},
+	{2048, 2048, 0, 0},
+	{2048, 0, 0, 0},
+	{0, 0, 0, 0},
+	{2048, 0, 0, 0},
+	{1024, 0, 0, 0},
+	{0, 0, 0, 0},
+	{2048, 0, 0, 0},
+	{0, 0, 0, 0},
+	{2048, 0, 0, 0},
+	{1024, 0, 0, 0},
+	{0, 0, 0, 0} };
+
+static const unsigned int fld_step_align_size[fld_step_num][fld_max_frame] = {
+	{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6528},
+	{1536, 1280, 1280, 1280, 1280, 1280, 1280, 1280,
+	 1280, 1280, 1280, 1280, 1280, 1280, 1280},
+	{5376, 5376, 5376, 5376, 5376, 5376, 5376, 5376,
+	 5376, 5376, 5376, 5376, 5376, 5376, 5376},
+	{307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200,
+	 307200, 307200, 307200, 307200, 307200, 307200, 307200},
+	{8064, 8064, 8064, 8064, 8064, 8064, 8064, 8064,
+	 8064, 8064, 8064, 8064, 8064, 8064, 8064},
+	{8064, 8064, 8064, 8064, 8064, 8064, 8064, 8064,
+	 8064, 8064, 8064, 8064, 8064, 8064, 8064}
+};
+
+static const unsigned int fld_face_info_0[fld_max_frame] = {
+	FLD_INFO_0_FACE_0, FLD_INFO_0_FACE_1, FLD_INFO_0_FACE_2,
+	FLD_INFO_0_FACE_3, FLD_INFO_0_FACE_4, FLD_INFO_0_FACE_5,
+	FLD_INFO_0_FACE_6, FLD_INFO_0_FACE_7, FLD_INFO_0_FACE_8,
+	FLD_INFO_0_FACE_9, FLD_INFO_0_FACE_10, FLD_INFO_0_FACE_11,
+	FLD_INFO_0_FACE_12, FLD_INFO_0_FACE_13, FLD_INFO_0_FACE_14
+};
+
+static const unsigned int fld_face_info_1[fld_max_frame] = {
+	FLD_INFO_1_FACE_0, FLD_INFO_1_FACE_1, FLD_INFO_1_FACE_2,
+	FLD_INFO_1_FACE_3, FLD_INFO_1_FACE_4, FLD_INFO_1_FACE_5,
+	FLD_INFO_1_FACE_6, FLD_INFO_1_FACE_7, FLD_INFO_1_FACE_8,
+	FLD_INFO_1_FACE_9, FLD_INFO_1_FACE_10, FLD_INFO_1_FACE_11,
+	FLD_INFO_1_FACE_12, FLD_INFO_1_FACE_13, FLD_INFO_1_FACE_14
+};
+
+static const unsigned int fld_face_info_2[fld_max_frame] = {
+	FLD_INFO_2_FACE_0, FLD_INFO_2_FACE_1, FLD_INFO_2_FACE_2,
+	FLD_INFO_2_FACE_3, FLD_INFO_2_FACE_4, FLD_INFO_2_FACE_5,
+	FLD_INFO_2_FACE_6, FLD_INFO_2_FACE_7, FLD_INFO_2_FACE_8,
+	FLD_INFO_2_FACE_9, FLD_INFO_2_FACE_10, FLD_INFO_2_FACE_11,
+	FLD_INFO_2_FACE_12, FLD_INFO_2_FACE_13, FLD_INFO_2_FACE_14
+};
+
+static int aie_imem_alloc(struct mtk_aie_dev *fd, u32 size,
+			  struct imem_buf_info *bufinfo)
+{
+	struct device *dev = fd->dev;
+	void *va = NULL;
+	dma_addr_t dma_handle = 0;
+
+	if (size == 0) {
+		dev_info(fd->dev, "%s: size(%d)\n", __func__, size);
+		return -EINVAL;
+	}
+
+	fd->fd_mem_size += size;
+
+	va = dma_alloc_coherent(dev, size, &dma_handle, GFP_KERNEL);
+	if (!va || dma_handle == 0)
+		return -ENOMEM;
+
+	bufinfo->va = va;
+	bufinfo->pa = dma_handle;
+	bufinfo->size = size;
+
+	fd->fd_mem_size += size;
+
+	dev_info(fd->dev, "%s: vAddr(0x%p), pAddr(0x%pad), size(%d)\n",
+		 __func__, va, &dma_handle, size);
+
+	return 0;
+}
+
+static void aie_imem_free(struct mtk_aie_dev *fd, struct imem_buf_info *bufinfo)
+{
+	dev_info(fd->dev, "%s: vAddr(0x%p), pAddr(0x%pad), size(%d)\n",
+		 __func__, bufinfo->va, &(bufinfo->pa),
+		 bufinfo->size);
+
+	if(bufinfo->va)
+		dma_free_coherent(fd->dev, bufinfo->size, bufinfo->va, bufinfo->pa);
+}
+
+static void aie_init_table(struct mtk_aie_dev *fd, u16 pym_width,
+			   u16 pym_height)
+{
+	int i = 0;
+	struct aie_static_info *pstv = NULL;
+
+	pstv = &fd->st_info;
+
+	pstv->info_element[pym2_start_loop].img_width = pym_width / 4;
+	pstv->info_element[pym2_start_loop].img_height = pym_height / 4;
+
+	pstv->info_element[pym1_start_loop].img_width = pym_width / 2;
+	pstv->info_element[pym1_start_loop].img_height = pym_height / 2;
+
+	pstv->info_element[pym0_start_loop].img_width = pym_width;
+	pstv->info_element[pym0_start_loop].img_height = pym_height;
+
+	for (i = 0; i < fd_loop_num; i++) {
+		if (i != pym2_start_loop &&
+		    i != pym1_start_loop &&
+		    i != pym0_start_loop) {
+			if (fd_out_stride2_in[i] == 1) {
+				pstv->info_element[i].img_width =
+					pstv->info_element[i - 1].stride2_out_width;
+				pstv->info_element[i].img_height =
+					pstv->info_element[i - 1].stride2_out_height;
+			} else {
+				pstv->info_element[i].img_width = pstv->info_element[i - 1].out_width;
+				pstv->info_element[i].img_height = pstv->info_element[i - 1].out_height;
+			}
+		}
+
+		if (fd_maxpool[i] == 1 && fd_stride[i] == 1) {
+			pstv->info_element[i].out_width =
+				(pstv->info_element[i].img_width - 1) /
+				(2 * fd_maxpool[i]) + 1;
+			pstv->info_element[i].out_height = (pstv->info_element[i].img_height - 1) /
+					      (2 * fd_maxpool[i]) + 1;
+		} else {
+			pstv->info_element[i].out_width =
+				(pstv->info_element[i].img_width - 1) /
+					(fd_stride[i] + 2 * fd_maxpool[i]) + 1;
+			pstv->info_element[i].out_height =
+				(pstv->info_element[i].img_height - 1) /
+					(fd_stride[i] + 2 * fd_maxpool[i]) + 1;
+		}
+
+		pstv->info_element[i].stride2_out_width =
+			((pstv->info_element[i].out_width - 1) / 2 + 1) * out_2size[i];
+		pstv->info_element[i].stride2_out_height =
+			((pstv->info_element[i].out_height - 1) / 2 + 1) * out_2size[i];
+
+		if (outlayer[i] == 1) {
+			pstv->info_element[i].out_xsize_plus_1 =
+				pstv->info_element[i].out_width * out_ch_pack[i] * 2;
+			pstv->info_element[i].out_stride = round_up(
+				pstv->info_element[i].out_xsize_plus_1 * anchor_en_num[i],
+				16);
+			pstv->info_element[i].out_xsize_plus_1_stride2 =
+				((pstv->info_element[i].out_width - 1) / 2 + 1) *
+				out_ch_pack[i] * 2 * out_2size[i];
+		} else {
+			pstv->info_element[i].out_xsize_plus_1 =
+				pstv->info_element[i].out_width * out_ch_pack[i];
+			pstv->info_element[i].out_stride =
+				round_up(pstv->info_element[i].out_xsize_plus_1, 16);
+			pstv->info_element[i].out_xsize_plus_1_stride2 =
+				((pstv->info_element[i].out_width - 1) / 2 + 1) *
+				out_ch_pack[i] * out_2size[i];
+		}
+
+		pstv->info_element[i].out_stride_stride2 =
+			round_up(pstv->info_element[i].out_xsize_plus_1_stride2, 16);
+
+		if (out_2size[i] == 1)
+			pstv->info_element[i].out_ysize_plus_1_stride2 =
+				(pstv->info_element[i].out_height - 1) / 2 + 1;
+		else
+			pstv->info_element[i].out_ysize_plus_1_stride2 = pstv->info_element[i].out_height;
+
+		if (fd_wdma_en[i][0]) {
+			if (i == rpn2_loop_num ||
+			    i == rpn1_loop_num ||
+			    i == rpn0_loop_num) {
+				pstv->info_element[i].fd_wdma_size[0] = result_size;
+			} else {
+				pstv->info_element[i].fd_wdma_size[0] = pstv->info_element[i].out_height *
+							   pstv->info_element[i].out_stride;
+			}
+		}
+
+		if (outlayer[i] == 1) {
+			if (fd_wdma_en[i][1])
+				pstv->info_element[i].fd_wdma_size[1] =
+					pstv->info_element[i].fd_wdma_size[0];
+			if (fd_wdma_en[i][2])
+				pstv->info_element[i].fd_wdma_size[2] =
+					pstv->info_element[i].fd_wdma_size[0];
+			if (fd_wdma_en[i][3])
+				pstv->info_element[i].fd_wdma_size[3] =
+					pstv->info_element[i].fd_wdma_size[0];
+		} else if (i == rpn2_loop_num || i == rpn1_loop_num ||
+			   i == rpn0_loop_num) {
+			pstv->info_element[i].fd_wdma_size[0] = result_size;
+		} else {
+			if (fd_wdma_en[i][1])
+				pstv->info_element[i].fd_wdma_size[1] = pstv->info_element[i].out_height *
+							   pstv->info_element[i].out_stride;
+			if (fd_wdma_en[i][2])
+				pstv->info_element[i].fd_wdma_size[2] =
+					pstv->info_element[i].out_ysize_plus_1_stride2 *
+					pstv->info_element[i].out_stride_stride2;
+			if (fd_wdma_en[i][3])
+				pstv->info_element[i].fd_wdma_size[3] =
+					pstv->info_element[i].out_ysize_plus_1_stride2 *
+					pstv->info_element[i].out_stride_stride2;
+		}
+
+		if (in_ch_pack[i] == 1)
+			pstv->info_element[i].input_xsize_plus_1 =
+				round_up(pstv->info_element[i].img_width, 8);
+		else
+			pstv->info_element[i].input_xsize_plus_1 =
+				pstv->info_element[i].img_width * in_ch_pack[i];
+	}
+}
+
+static void aie_update_table(struct mtk_aie_dev *fd, u16 pym_width,
+			   u16 pym_height)
+{
+	int i = 0;
+	struct aie_static_info *pstv = NULL;
+
+	pstv = &fd->st_info;
+
+	pstv->info_element[pym2_start_loop].img_width = pym_width / 4;
+	pstv->info_element[pym2_start_loop].img_height = pym_height / 4;
+
+	pstv->info_element[pym1_start_loop].img_width = pym_width / 2;
+	pstv->info_element[pym1_start_loop].img_height = pym_height / 2;
+
+	pstv->info_element[pym0_start_loop].img_width = pym_width;
+	pstv->info_element[pym0_start_loop].img_height = pym_height;
+
+	for (i = 0; i < fd_loop_num; i++) {
+		if (i != pym2_start_loop && i != pym1_start_loop &&
+		    i != pym0_start_loop) {
+			if (fd_out_stride2_in[i] == 1) {
+				pstv->info_element[i].img_width =
+					pstv->info_element[i - 1].stride2_out_width;
+				pstv->info_element[i].img_height =
+					pstv->info_element[i - 1].stride2_out_height;
+			} else {
+				pstv->info_element[i].img_width = pstv->info_element[i - 1].out_width;
+				pstv->info_element[i].img_height = pstv->info_element[i - 1].out_height;
+			}
+		}
+
+		if (fd_maxpool[i] == 1 && fd_stride[i] == 1) {
+			pstv->info_element[i].out_width =
+				(pstv->info_element[i].img_width - 1) /
+				(2 * fd_maxpool[i]) + 1;
+			pstv->info_element[i].out_height = (pstv->info_element[i].img_height - 1) /
+					      (2 * fd_maxpool[i]) + 1;
+		} else {
+			pstv->info_element[i].out_width =
+				(pstv->info_element[i].img_width - 1) /
+					(fd_stride[i] + 2 * fd_maxpool[i]) + 1;
+			pstv->info_element[i].out_height =
+				(pstv->info_element[i].img_height - 1) /
+					(fd_stride[i] + 2 * fd_maxpool[i]) + 1;
+		}
+
+		pstv->info_element[i].stride2_out_width =
+			((pstv->info_element[i].out_width - 1) / 2 + 1) * out_2size[i];
+		pstv->info_element[i].stride2_out_height =
+			((pstv->info_element[i].out_height - 1) / 2 + 1) * out_2size[i];
+
+		if (outlayer[i] == 1) {
+			pstv->info_element[i].out_xsize_plus_1 =
+				pstv->info_element[i].out_width * out_ch_pack[i] * 2;
+			pstv->info_element[i].out_stride = round_up(
+				pstv->info_element[i].out_xsize_plus_1 * anchor_en_num[i],
+				16);
+			pstv->info_element[i].out_xsize_plus_1_stride2 =
+				((pstv->info_element[i].out_width - 1) / 2 + 1) *
+				out_ch_pack[i] * 2 * out_2size[i];
+		} else {
+			pstv->info_element[i].out_xsize_plus_1 =
+				pstv->info_element[i].out_width * out_ch_pack[i];
+			pstv->info_element[i].out_stride =
+				round_up(pstv->info_element[i].out_xsize_plus_1, 16);
+			pstv->info_element[i].out_xsize_plus_1_stride2 =
+				((pstv->info_element[i].out_width - 1) / 2 + 1) *
+				out_ch_pack[i] * out_2size[i];
+		}
+
+		pstv->info_element[i].out_stride_stride2 =
+			round_up(pstv->info_element[i].out_xsize_plus_1_stride2, 16);
+
+		if (out_2size[i] == 1)
+			pstv->info_element[i].out_ysize_plus_1_stride2 =
+				(pstv->info_element[i].out_height - 1) / 2 + 1;
+		else
+			pstv->info_element[i].out_ysize_plus_1_stride2 = pstv->info_element[i].out_height;
+
+		if (in_ch_pack[i] == 1)
+			pstv->info_element[i].input_xsize_plus_1 =
+				round_up(pstv->info_element[i].img_width, 8);
+		else
+			pstv->info_element[i].input_xsize_plus_1 =
+				pstv->info_element[i].img_width * in_ch_pack[i];
+	}
+}
+
+static void aie_get_data_size(struct mtk_aie_dev *fd, u16 max_img_width,
+			      u16 max_img_height)
+{
+	u8 i = 0, j = 0;
+	struct aie_static_info *pstv = NULL;
+
+	pstv = &fd->st_info;
+
+	fd->base_para->max_img_width = max_img_width;
+	fd->base_para->max_img_height = max_img_height;
+	fd->fd_dma_max_size = 0;
+	fd->fd_dma_rst_max_size = 0;
+	fd->fd_fd_kernel_size = 0;
+	fd->fd_attr_kernel_size = 0;
+	fd->fd_attr_dma_max_size = 0;
+	fd->fd_attr_dma_rst_max_size = 0;
+
+	/* FDMODE Dram Buffer Size */
+	fd->fd_rs_cfg_size = 4 * fd->variant->rs_cfg_size * 2;
+	fd->fd_fd_cfg_size = 4 * fd->variant->fd_cfg_size * fd_loop_num;
+	fd->fd_yuv2rgb_cfg_size = 4 * fd->variant->y2r_cfg_size;
+
+	/* ATTRMODE Dram Buffer Size */
+	fd->attr_fd_cfg_size = 4 * fd->variant->fd_cfg_size * attr_loop_num;
+	fd->attr_yuv2rgb_cfg_size = 4 * fd->variant->y2r_cfg_size;
+
+	/* HW Output Buffer Size */
+	fd->rs_pym_out_size[0] = fd->base_para->max_pyramid_width *
+				 fd->base_para->max_pyramid_height;
+	fd->rs_pym_out_size[1] = fd->rs_pym_out_size[0] / 2;
+	fd->rs_pym_out_size[2] = fd->rs_pym_out_size[0] / 4;
+
+	/* FDMODE Dram Buffer Size */
+	for (i = 0; i < fd_loop_num; i++) {
+		for (j = 0; j < output_WDMA_WRA_num; j++) {
+			if (fd_wdma_en[i][j]) {
+				if ((i == rpn2_loop_num ||
+				     i == rpn1_loop_num ||
+				     i == rpn0_loop_num) && (j == 0)) {
+					fd->fd_dma_rst_max_size +=
+						pstv->info_element[i].fd_wdma_size[j];
+				} else {
+					fd->fd_dma_max_size +=
+						pstv->info_element[i].fd_wdma_size[j];
+				}
+			}
+		}
+	}
+
+	for (i = 0; i < fd_loop_num; i++) {
+		for (j = 0; j < kernel_RDMA_RA_num; j++) {
+			if (fd_ker_rdma_size[i][j])
+				fd->fd_fd_kernel_size += fd_ker_rdma_size[i][j];
+		}
+	}
+
+	/* ATTRMODE Dram Buffer Size */
+	for (i = 0; i < attr_loop_num; i++) {
+		for (j = 0; j < output_WDMA_WRA_num; j++) {
+			if (attr_wdma_en[i][j]) {
+				if ((i == age_out_rgs || i == gender_out_rgs ||
+				     i == indian_out_rgs || i == race_out_rgs) &&
+				    (j == 0)) {
+					fd->fd_attr_dma_rst_max_size +=
+						ATTR_OUT_SIZE * MAX_ENQUE_FRAME_NUM;
+				} else {
+					fd->fd_attr_dma_max_size += attr_wdma_size[i][j];
+				}
+			}
+		}
+	}
+
+	for (i = 0; i < attr_loop_num; i++) {
+		for (j = 0; j < kernel_RDMA_RA_num; j++)
+			fd->fd_attr_kernel_size += attr_ker_rdma_size[i][j];
+	}
+
+	/* FD Pose secure result output buffer: result size * 3 loops */
+	fd->fd_dma_rst_max_size += result_size * 3;
+
+	if (fd->variant->fld_enable) {
+		/* fld size */
+		fd->fld_step_size = 0;
+		for (i = 0; i < fld_step_num; i++)
+			for (j = 0; j < fld_max_frame; j++)
+				fd->fld_step_size += fld_step_align_size[i][j];
+
+		fd->fld_out_size = fld_output_size * fld_max_frame;
+	}
+}
+
+static int aie_alloc_dram_buf(struct mtk_aie_dev *fd)
+{
+	int ret = -EINVAL;
+	u8 i = 0;
+	u32 alloc_size = 0;
+
+	/* RS DRAM */
+	alloc_size = fd->fd_rs_cfg_size;
+	dev_info(fd->dev, "RS CFG:");
+	ret = aie_imem_alloc(fd, alloc_size, &fd->rs_cfg_data);
+	if (ret)
+		goto dma_alloc_fail;
+	/* FD MODE */
+	fd->base_para->fd_rs_cfg_pa = fd->rs_cfg_data.pa;
+	fd->base_para->fd_rs_cfg_va = fd->rs_cfg_data.va;
+
+	/* FD DRAM */
+	alloc_size =
+		fd->fd_fd_cfg_size + fd->attr_fd_cfg_size * MAX_ENQUE_FRAME_NUM;
+	dev_info(fd->dev, "FD CFG:");
+	ret = aie_imem_alloc(fd, alloc_size, &fd->fd_cfg_data);
+	if (ret)
+		goto dma_alloc_fail;
+	/* FD MODE */
+	fd->base_para->fd_fd_cfg_pa = fd->fd_cfg_data.pa;
+	fd->base_para->fd_fd_cfg_va = fd->fd_cfg_data.va;
+	/* ATTR MODE */
+	fd->base_para->attr_fd_cfg_pa[0] =
+		fd->base_para->fd_fd_cfg_pa + fd->fd_fd_cfg_size;
+	fd->base_para->attr_fd_cfg_va[0] =
+		fd->base_para->fd_fd_cfg_va + fd->fd_fd_cfg_size;
+
+	for (i = 1; i < MAX_ENQUE_FRAME_NUM; i++) {
+		fd->base_para->attr_fd_cfg_pa[i] =
+			fd->base_para->attr_fd_cfg_pa[i - 1] +
+			fd->attr_fd_cfg_size;
+		fd->base_para->attr_fd_cfg_va[i] =
+			fd->base_para->attr_fd_cfg_va[i - 1] +
+			fd->attr_fd_cfg_size;
+	}
+
+	/* YUV2RGB DRAM */
+	alloc_size = fd->fd_yuv2rgb_cfg_size +
+		     fd->attr_yuv2rgb_cfg_size * MAX_ENQUE_FRAME_NUM;
+	dev_info(fd->dev, "YUV2RGB CFG:");
+	ret = aie_imem_alloc(fd, alloc_size, &fd->yuv2rgb_cfg_data);
+	if (ret)
+		goto dma_alloc_fail;
+	/* FD MODE */
+	fd->base_para->fd_yuv2rgb_cfg_pa = fd->yuv2rgb_cfg_data.pa;
+	fd->base_para->fd_yuv2rgb_cfg_va = fd->yuv2rgb_cfg_data.va;
+
+	/* ATTR MODE */
+	fd->base_para->attr_yuv2rgb_cfg_pa[0] =
+		fd->base_para->fd_yuv2rgb_cfg_pa + fd->fd_yuv2rgb_cfg_size;
+	fd->base_para->attr_yuv2rgb_cfg_va[0] =
+		fd->base_para->fd_yuv2rgb_cfg_va + fd->fd_yuv2rgb_cfg_size;
+
+	for (i = 1; i < MAX_ENQUE_FRAME_NUM; i++) {
+		fd->base_para->attr_yuv2rgb_cfg_pa[i] =
+			fd->base_para->attr_yuv2rgb_cfg_pa[i - 1] +
+			fd->attr_yuv2rgb_cfg_size;
+		fd->base_para->attr_yuv2rgb_cfg_va[i] =
+			fd->base_para->attr_yuv2rgb_cfg_va[i - 1] +
+			fd->attr_yuv2rgb_cfg_size;
+	}
+
+	return ret;
+dma_alloc_fail:
+	aie_imem_free(fd, &fd->fd_cfg_data);
+	aie_imem_free(fd, &fd->rs_cfg_data);
+
+	return ret;
+}
+
+static int aie_alloc_output_buf(struct mtk_aie_dev *fd)
+{
+	int ret = -EINVAL;
+	u32 alloc_size = 0;
+	int i, j, pa_off = 0, va_off = 0;
+
+	for (i = 0; i < PYM_NUM; i++)
+		alloc_size += fd->rs_pym_out_size[i] * 3;
+	dev_info(fd->dev, "RS OUT:");
+	ret = aie_imem_alloc(fd, alloc_size, &fd->rs_output_hw);
+	if (ret)
+		return ret;
+
+	for (i = 0; i < PYM_NUM; i++) {
+		for (j = 0; j < COLOR_NUM; j++) {
+			fd->base_para->rs_pym_rst_pa[i][j] =
+				fd->rs_output_hw.pa + pa_off;
+			pa_off += fd->rs_pym_out_size[i];
+
+			fd->base_para->rs_pym_rst_va[i][j] =
+				fd->rs_output_hw.va + va_off;
+			va_off += fd->rs_pym_out_size[i];
+		}
+	}
+
+	return ret;
+}
+
+static void aie_alloc_normal(struct mtk_aie_dev *fd, int start, int end)
+{
+	int i = 0, j = 0;
+	int pi = 0, pj = 0;
+	struct aie_static_info *pstv = NULL;
+
+	pstv = &fd->st_info;
+	if (start <= 0 || end <= start) {
+		dev_info(fd->dev, "%s: start = %d, end = %d\n", __func__, start, end);
+		return;
+	}
+
+	pi = start - 1;
+	pj = 0;
+	for (i = start; i < end + 1; i++) {
+		for (j = 0; j < output_WDMA_WRA_num; j++) {
+			if (fd_wdma_en[i][j]) {
+				fd->dma_para->fd_out_hw_pa[i][j] =
+					fd->dma_para->fd_out_hw_pa[pi][pj] +
+					pstv->info_element[pi].fd_wdma_size[pj];
+				pi = i;
+				pj = j;
+			}
+		}
+	}
+}
+
+static int aie_alloc_fddma_buf(struct mtk_aie_dev *fd)
+{
+	int ret = -EINVAL;
+	u32 alloc_size = 0;
+
+	alloc_size = fd->fd_dma_max_size;
+	dev_info(fd->dev, "FD DMA:");
+	ret = aie_imem_alloc(fd, alloc_size, &fd->fd_dma_hw);
+	if (ret)
+		goto dma_alloc_fail;
+	alloc_size = fd->fd_fd_kernel_size + fd->fd_attr_kernel_size;
+	dev_info(fd->dev, "FD KERNEL:");
+	ret = aie_imem_alloc(fd, alloc_size, &fd->fd_kernel_hw);
+	if (ret)
+		goto dma_alloc_fail;
+
+	alloc_size = fd->fd_attr_dma_max_size;
+	dev_info(fd->dev, "ATTR DMA:");
+	ret = aie_imem_alloc(fd, alloc_size, &fd->fd_attr_dma_hw);
+	if (ret)
+		goto dma_alloc_fail;
+
+	alloc_size = fd->fd_dma_rst_max_size + fd->fd_attr_dma_rst_max_size;
+	dev_info(fd->dev, "RESULT DMA:");
+	ret = aie_imem_alloc(fd, alloc_size, &fd->fd_dma_result_hw);
+	if (ret)
+		goto dma_alloc_fail;
+
+	return 0;
+
+dma_alloc_fail:
+	aie_imem_free(fd, &fd->fd_attr_dma_hw);
+	aie_imem_free(fd, &fd->fd_kernel_hw);
+	aie_imem_free(fd, &fd->fd_dma_hw);
+
+	return ret;
+}
+
+static int aie_alloc_fld_buf(struct mtk_aie_dev *fd)
+{
+	int ret = -EINVAL;
+	u32 alloc_size = 0;
+
+	alloc_size = fd->fld_step_size;
+	dev_info(fd->dev, "FLD STEP:");
+	ret = aie_imem_alloc(fd, alloc_size, &fd->fd_fld_step_data);
+	if (ret)
+		return ret;
+
+	alloc_size = fd->fld_out_size;
+	dev_info(fd->dev, "FLD OUT:");
+	ret = aie_imem_alloc(fd, alloc_size, &fd->fd_fld_out_hw);
+	if (ret)
+		goto fld_step;
+
+	return 0;
+fld_step:
+	aie_imem_free(fd, &fd->fd_fld_step_data);
+
+	return ret;
+}
+
+static void aie_arrange_fddma_buf(struct mtk_aie_dev *fd)
+{
+	void *currentVA = NULL;
+	dma_addr_t currentPA = 0;
+	struct aie_static_info *pstv = NULL;
+	u8 i = 0, j = 0;
+
+	pstv = &fd->st_info;
+
+	/* 0~18 */
+	fd->dma_para->fd_out_hw_pa[0][0] = fd->fd_dma_hw.pa;
+	aie_alloc_normal(fd, 1, 18);
+
+	/* 19~27 */
+	fd->dma_para->fd_out_hw_pa[19][0] =
+		fd->dma_para->fd_out_hw_pa[18][1] + pstv->info_element[18].fd_wdma_size[1];
+	fd->dma_para->fd_out_hw_pa[19][1] =
+		fd->dma_para->fd_out_hw_pa[19][0] + pstv->info_element[19].out_xsize_plus_1;
+	fd->dma_para->fd_out_hw_pa[20][0] = fd->dma_para->fd_out_hw_pa[19][0] +
+					    2 * pstv->info_element[20].out_xsize_plus_1;
+	fd->dma_para->fd_out_hw_pa[20][1] = fd->dma_para->fd_out_hw_pa[19][0] +
+					    3 * pstv->info_element[20].out_xsize_plus_1;
+	fd->dma_para->fd_out_hw_pa[21][0] = fd->dma_para->fd_out_hw_pa[19][0] +
+					    4 * pstv->info_element[21].out_xsize_plus_1;
+	fd->dma_para->fd_out_hw_pa[22][0] =
+		fd->dma_para->fd_out_hw_pa[19][0] + pstv->info_element[19].fd_wdma_size[0] +
+		pstv->info_element[19].fd_wdma_size[1] + pstv->info_element[20].fd_wdma_size[0] +
+		pstv->info_element[20].fd_wdma_size[1] + pstv->info_element[21].fd_wdma_size[0];
+	fd->dma_para->fd_out_hw_pa[22][1] =
+		fd->dma_para->fd_out_hw_pa[22][0] + pstv->info_element[22].fd_wdma_size[0] +
+		pstv->info_element[22].fd_wdma_size[2] + pstv->info_element[23].fd_wdma_size[0];	
+	fd->dma_para->fd_out_hw_pa[22][2] =
+		fd->dma_para->fd_out_hw_pa[22][0] + pstv->info_element[22].out_xsize_plus_1;
+	fd->dma_para->fd_out_hw_pa[22][3] =
+		fd->dma_para->fd_out_hw_pa[22][1] + pstv->info_element[22].out_xsize_plus_1;
+	fd->dma_para->fd_out_hw_pa[23][0] = fd->dma_para->fd_out_hw_pa[22][0] +
+					    2 * pstv->info_element[23].out_xsize_plus_1;
+	fd->dma_para->fd_out_hw_pa[23][1] = fd->dma_para->fd_out_hw_pa[22][1] +
+					    2 * pstv->info_element[23].out_xsize_plus_1;
+	fd->dma_para->fd_out_hw_pa[23][2] = fd->dma_para->fd_out_hw_pa[22][0] +
+					    3 * pstv->info_element[23].out_xsize_plus_1;
+	fd->dma_para->fd_out_hw_pa[23][3] = fd->dma_para->fd_out_hw_pa[22][1] +
+					    3 * pstv->info_element[23].out_xsize_plus_1;
+	fd->dma_para->fd_out_hw_pa[24][0] = fd->dma_para->fd_out_hw_pa[22][0] +
+					    4 * pstv->info_element[24].out_xsize_plus_1;
+	fd->dma_para->fd_out_hw_pa[24][1] = fd->dma_para->fd_out_hw_pa[22][1] +
+					    4 * pstv->info_element[24].out_xsize_plus_1;
+	fd->dma_para->fd_out_hw_pa[25][0] =
+		fd->dma_para->fd_out_hw_pa[22][1] + pstv->info_element[22].fd_wdma_size[1] +
+		pstv->info_element[22].fd_wdma_size[3] + pstv->info_element[23].fd_wdma_size[1]+
+		pstv->info_element[23].fd_wdma_size[3] + pstv->info_element[24].fd_wdma_size[1];
+	fd->dma_para->fd_out_hw_pa[25][1] =
+		fd->dma_para->fd_out_hw_pa[25][0] + pstv->info_element[25].out_xsize_plus_1;
+	fd->dma_para->fd_out_hw_pa[26][0] = fd->dma_para->fd_out_hw_pa[25][0] +
+					    2 * pstv->info_element[26].out_xsize_plus_1;
+	fd->dma_para->fd_out_hw_pa[26][1] = fd->dma_para->fd_out_hw_pa[25][0] +
+					    3 * pstv->info_element[26].out_xsize_plus_1;
+	fd->dma_para->fd_out_hw_pa[27][0] = fd->dma_para->fd_out_hw_pa[25][0] +
+					    4 * pstv->info_element[27].out_xsize_plus_1;
+
+	/* 29~47 */
+	fd->dma_para->fd_out_hw_pa[29][0] =
+		fd->dma_para->fd_out_hw_pa[25][0] + pstv->info_element[25].fd_wdma_size[0] +
+		pstv->info_element[25].fd_wdma_size[1] + pstv->info_element[26].fd_wdma_size[0]+
+		pstv->info_element[26].fd_wdma_size[1] + pstv->info_element[27].fd_wdma_size[0];
+	aie_alloc_normal(fd, 30, 47);
+
+	/* 48~56 */
+	fd->dma_para->fd_out_hw_pa[48][0] =
+		fd->dma_para->fd_out_hw_pa[47][1] + pstv->info_element[47].fd_wdma_size[1];
+	fd->dma_para->fd_out_hw_pa[48][1] =
+		fd->dma_para->fd_out_hw_pa[48][0] + pstv->info_element[48].out_xsize_plus_1;
+	fd->dma_para->fd_out_hw_pa[49][0] = fd->dma_para->fd_out_hw_pa[48][0] +
+					    2 * pstv->info_element[49].out_xsize_plus_1;
+	fd->dma_para->fd_out_hw_pa[49][1] = fd->dma_para->fd_out_hw_pa[48][0] +
+					    3 * pstv->info_element[49].out_xsize_plus_1;
+	fd->dma_para->fd_out_hw_pa[50][0] = fd->dma_para->fd_out_hw_pa[48][0] +
+					    4 * pstv->info_element[50].out_xsize_plus_1;
+	fd->dma_para->fd_out_hw_pa[51][0] =
+		fd->dma_para->fd_out_hw_pa[48][0] + pstv->info_element[48].fd_wdma_size[0] +
+		pstv->info_element[48].fd_wdma_size[1] + pstv->info_element[49].fd_wdma_size[0]+
+		pstv->info_element[49].fd_wdma_size[1] + pstv->info_element[50].fd_wdma_size[0];
+	fd->dma_para->fd_out_hw_pa[51][1] =
+		fd->dma_para->fd_out_hw_pa[51][0] + pstv->info_element[51].fd_wdma_size[0] +
+		pstv->info_element[51].fd_wdma_size[2] + pstv->info_element[52].fd_wdma_size[0]+
+		pstv->info_element[52].fd_wdma_size[2] + pstv->info_element[53].fd_wdma_size[0];
+	fd->dma_para->fd_out_hw_pa[51][2] =
+		fd->dma_para->fd_out_hw_pa[51][0] + pstv->info_element[51].out_xsize_plus_1;
+	fd->dma_para->fd_out_hw_pa[51][3] =
+		fd->dma_para->fd_out_hw_pa[51][1] + pstv->info_element[51].out_xsize_plus_1;
+	fd->dma_para->fd_out_hw_pa[52][0] = fd->dma_para->fd_out_hw_pa[51][0] +
+					    2 * pstv->info_element[52].out_xsize_plus_1;
+	fd->dma_para->fd_out_hw_pa[52][1] = fd->dma_para->fd_out_hw_pa[51][1] +
+					    2 * pstv->info_element[52].out_xsize_plus_1;
+	fd->dma_para->fd_out_hw_pa[52][2] = fd->dma_para->fd_out_hw_pa[51][0] +
+					    3 * pstv->info_element[52].out_xsize_plus_1;
+	fd->dma_para->fd_out_hw_pa[52][3] = fd->dma_para->fd_out_hw_pa[51][1] +
+					    3 * pstv->info_element[52].out_xsize_plus_1;
+	fd->dma_para->fd_out_hw_pa[53][0] = fd->dma_para->fd_out_hw_pa[51][0] +
+					    4 * pstv->info_element[53].out_xsize_plus_1;
+	fd->dma_para->fd_out_hw_pa[53][1] = fd->dma_para->fd_out_hw_pa[51][1] +
+					    4 * pstv->info_element[53].out_xsize_plus_1;
+	fd->dma_para->fd_out_hw_pa[54][0] =
+		fd->dma_para->fd_out_hw_pa[51][1] + pstv->info_element[51].fd_wdma_size[1] +
+		pstv->info_element[51].fd_wdma_size[3] + pstv->info_element[52].fd_wdma_size[1]+
+		pstv->info_element[52].fd_wdma_size[3] + pstv->info_element[53].fd_wdma_size[1];
+	fd->dma_para->fd_out_hw_pa[54][1] =
+		fd->dma_para->fd_out_hw_pa[54][0] + pstv->info_element[54].out_xsize_plus_1;
+	fd->dma_para->fd_out_hw_pa[55][0] = fd->dma_para->fd_out_hw_pa[54][0] +
+					    2 * pstv->info_element[55].out_xsize_plus_1;
+	fd->dma_para->fd_out_hw_pa[55][1] = fd->dma_para->fd_out_hw_pa[54][0] +
+					    3 * pstv->info_element[55].out_xsize_plus_1;
+	fd->dma_para->fd_out_hw_pa[56][0] = fd->dma_para->fd_out_hw_pa[54][0] +
+					    4 * pstv->info_element[56].out_xsize_plus_1;
+
+	/* 58~76 */
+	fd->dma_para->fd_out_hw_pa[58][0] =
+		fd->dma_para->fd_out_hw_pa[54][0] + pstv->info_element[54].fd_wdma_size[0] +
+		pstv->info_element[54].fd_wdma_size[1] + pstv->info_element[55].fd_wdma_size[0]+
+		pstv->info_element[55].fd_wdma_size[1] + pstv->info_element[56].fd_wdma_size[0];
+	aie_alloc_normal(fd, 59, 76);
+
+	/* 77~85 */
+	fd->dma_para->fd_out_hw_pa[77][0] =
+		fd->dma_para->fd_out_hw_pa[76][1] + pstv->info_element[76].fd_wdma_size[1];
+	fd->dma_para->fd_out_hw_pa[77][1] =
+		fd->dma_para->fd_out_hw_pa[77][0] + pstv->info_element[77].out_xsize_plus_1;
+	fd->dma_para->fd_out_hw_pa[78][0] = fd->dma_para->fd_out_hw_pa[77][0] +
+					    2 * pstv->info_element[78].out_xsize_plus_1;
+	fd->dma_para->fd_out_hw_pa[78][1] = fd->dma_para->fd_out_hw_pa[77][0] +
+					    3 * pstv->info_element[78].out_xsize_plus_1;
+	fd->dma_para->fd_out_hw_pa[79][0] = fd->dma_para->fd_out_hw_pa[77][0] +
+					    4 * pstv->info_element[79].out_xsize_plus_1;
+	fd->dma_para->fd_out_hw_pa[80][0] =
+		fd->dma_para->fd_out_hw_pa[77][0] + pstv->info_element[77].fd_wdma_size[0] +
+		pstv->info_element[77].fd_wdma_size[1] + pstv->info_element[78].fd_wdma_size[0]+
+		pstv->info_element[78].fd_wdma_size[1] + pstv->info_element[79].fd_wdma_size[0];
+	fd->dma_para->fd_out_hw_pa[80][1] =
+		fd->dma_para->fd_out_hw_pa[80][0] + pstv->info_element[80].fd_wdma_size[0] +
+		pstv->info_element[80].fd_wdma_size[2] + pstv->info_element[81].fd_wdma_size[0]+
+		pstv->info_element[81].fd_wdma_size[2] + pstv->info_element[82].fd_wdma_size[0];
+	fd->dma_para->fd_out_hw_pa[80][2] =
+		fd->dma_para->fd_out_hw_pa[80][0] + pstv->info_element[80].out_xsize_plus_1;
+	fd->dma_para->fd_out_hw_pa[80][3] =
+		fd->dma_para->fd_out_hw_pa[80][1] + pstv->info_element[80].out_xsize_plus_1;
+	fd->dma_para->fd_out_hw_pa[81][0] = fd->dma_para->fd_out_hw_pa[80][0] +
+					    2 * pstv->info_element[81].out_xsize_plus_1;
+	fd->dma_para->fd_out_hw_pa[81][1] = fd->dma_para->fd_out_hw_pa[80][1] +
+					    2 * pstv->info_element[81].out_xsize_plus_1;
+	fd->dma_para->fd_out_hw_pa[81][2] = fd->dma_para->fd_out_hw_pa[80][0] +
+					    3 * pstv->info_element[81].out_xsize_plus_1;
+	fd->dma_para->fd_out_hw_pa[81][3] = fd->dma_para->fd_out_hw_pa[80][1] +
+					    3 * pstv->info_element[81].out_xsize_plus_1;
+	fd->dma_para->fd_out_hw_pa[82][0] = fd->dma_para->fd_out_hw_pa[80][0] +
+					    4 * pstv->info_element[82].out_xsize_plus_1;
+	fd->dma_para->fd_out_hw_pa[82][1] = fd->dma_para->fd_out_hw_pa[80][1] +
+					    4 * pstv->info_element[82].out_xsize_plus_1;
+	fd->dma_para->fd_out_hw_pa[83][0] =
+		fd->dma_para->fd_out_hw_pa[80][1] + pstv->info_element[80].fd_wdma_size[1] +
+		pstv->info_element[80].fd_wdma_size[3] + pstv->info_element[81].fd_wdma_size[1]+
+		pstv->info_element[81].fd_wdma_size[3] + pstv->info_element[82].fd_wdma_size[1];
+	fd->dma_para->fd_out_hw_pa[83][1] =
+		fd->dma_para->fd_out_hw_pa[83][0] + pstv->info_element[83].out_xsize_plus_1;
+	fd->dma_para->fd_out_hw_pa[84][0] = fd->dma_para->fd_out_hw_pa[83][0] +
+					    2 * pstv->info_element[84].out_xsize_plus_1;
+	fd->dma_para->fd_out_hw_pa[84][1] = fd->dma_para->fd_out_hw_pa[83][0] +
+					    3 * pstv->info_element[84].out_xsize_plus_1;
+	fd->dma_para->fd_out_hw_pa[85][0] = fd->dma_para->fd_out_hw_pa[83][0] +
+					    4 * pstv->info_element[85].out_xsize_plus_1;
+
+	/* VA : except 28, 57, 86 */
+	/* 0~86 */
+	fd->dma_para->fd_out_hw_va[0][0] = fd->fd_dma_hw.va;
+	for (i = 1; i < fd_loop_num; i++) {
+		if (i == rpn2_loop_num ||
+			i == rpn1_loop_num ||
+			i == rpn0_loop_num)
+			continue;
+		for (j = 0; j < 4; j++) {
+			if (fd_wdma_en[i][j]) {
+				fd->dma_para->fd_out_hw_va[i][j] =
+					fd->fd_dma_hw.va +
+					fd->dma_para->fd_out_hw_pa[i][j] -
+					fd->fd_dma_hw.pa;
+			}
+		}
+	}
+
+	currentPA = fd->dma_para->fd_out_hw_pa[83][0] +
+		    pstv->info_element[83].fd_wdma_size[0] + pstv->info_element[83].fd_wdma_size[1] +
+		    pstv->info_element[84].fd_wdma_size[0] + pstv->info_element[84].fd_wdma_size[1]+
+		    pstv->info_element[85].fd_wdma_size[0];
+	currentVA = fd->dma_para->fd_out_hw_va[83][0] +
+			pstv->info_element[83].fd_wdma_size[0] + pstv->info_element[83].fd_wdma_size[1] +
+			pstv->info_element[84].fd_wdma_size[0] + pstv->info_element[84].fd_wdma_size[1]+
+		    pstv->info_element[85].fd_wdma_size[0];
+
+	dev_info(fd->dev, "%s: current VA = %p, PA = 0x%016llx\n", __func__, currentVA, currentPA);
+}
+
+static void aie_arrange_kernel_buf(struct mtk_aie_dev *fd)
+{
+	void *currentVA = NULL;
+	dma_addr_t currentPA = 0;
+	u8 i = 0, j = 0;
+
+	currentPA = fd->fd_kernel_hw.pa;
+	currentVA = fd->fd_kernel_hw.va;
+
+	for (i = 0; i < fd_loop_num; i++) {
+		for (j = 0; j < kernel_RDMA_RA_num; j++) {
+			if (fd_ker_rdma_size[i][j]) {
+				fd->dma_para->fd_kernel_pa[i][j] = currentPA;
+				fd->dma_para->fd_kernel_va[i][j] = currentVA;
+				currentPA += fd_ker_rdma_size[i][j];
+				currentVA += fd_ker_rdma_size[i][j];
+			}
+		}
+	}
+
+	for (i = 0; i < attr_loop_num; i++) {
+		for (j = 0; j < kernel_RDMA_RA_num; j++) {
+			fd->dma_para->attr_kernel_pa[i][j] = currentPA;
+			fd->dma_para->attr_kernel_va[i][j] = currentVA;
+			currentPA += attr_ker_rdma_size[i][j];
+			currentVA += attr_ker_rdma_size[i][j];
+		}
+	}
+
+	dev_info(fd->dev, "%s: current VA = %p, PA = 0x%016llx\n", __func__, currentVA, currentPA);
+}
+
+static void aie_arrange_attrdma_buf(struct mtk_aie_dev *fd)
+{
+	void *currentVA = NULL;
+	dma_addr_t currentPA = 0;
+	u8 i = 0, j = 0;
+
+	currentPA = fd->fd_attr_dma_hw.pa;
+	currentVA = fd->fd_attr_dma_hw.va;
+
+	/* attribute mode */
+	for (i = 0; i < attr_loop_num; i++) {
+		for (j = 0; j < output_WDMA_WRA_num; j++) {
+			if (attr_wdma_en[i][j]) {
+				fd->dma_para->attr_out_hw_pa[i][j] = currentPA;
+				fd->dma_para->attr_out_hw_va[i][j] = currentVA;
+				currentPA += attr_wdma_size[i][j];
+				currentVA += attr_wdma_size[i][j];
+			}
+		}
+	}
+
+	dev_info(fd->dev, "%s: current VA = %p, PA = 0x%016llx\n", __func__, currentVA, currentPA);
+}
+
+static void aie_arrange_result_dma_buf(struct mtk_aie_dev *fd)
+{
+	void *currentResultVA = NULL;
+	dma_addr_t currentResultPA = 0;
+	u8 i = 0;
+	struct aie_static_info *pstv = NULL;
+
+	pstv = &fd->st_info;
+
+	currentResultPA = fd->fd_dma_result_hw.pa;
+	currentResultVA = fd->fd_dma_result_hw.va;
+
+	fd->dma_para->fd_out_hw_pa[rpn2_loop_num][0] = currentResultPA;
+	fd->dma_para->fd_out_hw_va[rpn2_loop_num][0] = currentResultVA;
+	currentResultPA += pstv->info_element[rpn2_loop_num].fd_wdma_size[0];
+	currentResultVA += pstv->info_element[rpn2_loop_num].fd_wdma_size[0];
+	fd->dma_para->fd_out_hw_pa[rpn1_loop_num][0] = currentResultPA;
+	fd->dma_para->fd_out_hw_va[rpn1_loop_num][0] = currentResultVA;
+	currentResultPA += pstv->info_element[rpn1_loop_num].fd_wdma_size[0];
+	currentResultVA += pstv->info_element[rpn1_loop_num].fd_wdma_size[0];
+	fd->dma_para->fd_out_hw_pa[rpn0_loop_num][0] = currentResultPA;
+	fd->dma_para->fd_out_hw_va[rpn0_loop_num][0] = currentResultVA;
+	currentResultPA += pstv->info_element[rpn0_loop_num].fd_wdma_size[0];
+	currentResultVA += pstv->info_element[rpn0_loop_num].fd_wdma_size[0];
+
+	fd->dma_para->attr_out_hw_pa[age_out_rgs][0] = currentResultPA;
+	fd->dma_para->attr_out_hw_va[age_out_rgs][0] = currentResultVA;
+	currentResultPA += ATTR_OUT_SIZE * MAX_ENQUE_FRAME_NUM;
+	currentResultVA += ATTR_OUT_SIZE * MAX_ENQUE_FRAME_NUM;
+	fd->dma_para->attr_out_hw_pa[gender_out_rgs][0] = currentResultPA;
+	fd->dma_para->attr_out_hw_va[gender_out_rgs][0] = currentResultVA;
+	currentResultPA += ATTR_OUT_SIZE * MAX_ENQUE_FRAME_NUM;
+	currentResultVA += ATTR_OUT_SIZE * MAX_ENQUE_FRAME_NUM;
+	fd->dma_para->attr_out_hw_pa[indian_out_rgs][0] = currentResultPA;
+	fd->dma_para->attr_out_hw_va[indian_out_rgs][0] = currentResultVA;
+	currentResultPA += ATTR_OUT_SIZE * MAX_ENQUE_FRAME_NUM;
+	currentResultVA += ATTR_OUT_SIZE * MAX_ENQUE_FRAME_NUM;
+	fd->dma_para->attr_out_hw_pa[race_out_rgs][0] = currentResultPA;
+	fd->dma_para->attr_out_hw_va[race_out_rgs][0] = currentResultVA;
+	currentResultPA += ATTR_OUT_SIZE * MAX_ENQUE_FRAME_NUM;
+	currentResultVA += ATTR_OUT_SIZE * MAX_ENQUE_FRAME_NUM;
+
+	/* need to prepare 10 buffers to store 10 times result */
+	fd->dma_para->age_out_hw_pa[0] =
+		fd->dma_para->attr_out_hw_pa[age_out_rgs][0];
+	fd->dma_para->age_out_hw_va[0] =
+		fd->dma_para->attr_out_hw_va[age_out_rgs][0];
+	fd->dma_para->gender_out_hw_pa[0] =
+		fd->dma_para->attr_out_hw_pa[gender_out_rgs][0];
+	fd->dma_para->gender_out_hw_va[0] =
+		fd->dma_para->attr_out_hw_va[gender_out_rgs][0];
+	fd->dma_para->isIndian_out_hw_pa[0] =
+		fd->dma_para->attr_out_hw_pa[indian_out_rgs][0];
+	fd->dma_para->isIndian_out_hw_va[0] =
+		fd->dma_para->attr_out_hw_va[indian_out_rgs][0];
+	fd->dma_para->race_out_hw_pa[0] =
+		fd->dma_para->attr_out_hw_pa[race_out_rgs][0];
+	fd->dma_para->race_out_hw_va[0] =
+		fd->dma_para->attr_out_hw_va[race_out_rgs][0];
+
+	for (i = 1; i < MAX_ENQUE_FRAME_NUM; i++) {
+		fd->dma_para->age_out_hw_pa[i] =
+			fd->dma_para->age_out_hw_pa[i - 1] + ATTR_OUT_SIZE;
+		fd->dma_para->age_out_hw_va[i] =
+			fd->dma_para->age_out_hw_va[i - 1] + ATTR_OUT_SIZE;
+		fd->dma_para->gender_out_hw_pa[i] =
+			fd->dma_para->gender_out_hw_pa[i - 1] + ATTR_OUT_SIZE;
+		fd->dma_para->gender_out_hw_va[i] =
+			fd->dma_para->gender_out_hw_va[i - 1] + ATTR_OUT_SIZE;
+		fd->dma_para->isIndian_out_hw_pa[i] =
+			fd->dma_para->isIndian_out_hw_pa[i - 1] + ATTR_OUT_SIZE;
+		fd->dma_para->isIndian_out_hw_va[i] =
+			fd->dma_para->isIndian_out_hw_va[i - 1] + ATTR_OUT_SIZE;
+		fd->dma_para->race_out_hw_pa[i] =
+			fd->dma_para->race_out_hw_pa[i - 1] + ATTR_OUT_SIZE;
+		fd->dma_para->race_out_hw_va[i] =
+			fd->dma_para->race_out_hw_va[i - 1] + ATTR_OUT_SIZE;
+	}
+
+	memset(fd->fd_dma_result_hw.va, 0, fd->fd_dma_result_hw.size);
+
+	dev_info(fd->dev, "%s: current VA = %p, PA = 0x%016llx\n", __func__, currentResultVA, currentResultPA);
+}
+
+static void aie_arrange_fld_buf(struct mtk_aie_dev *fd)
+{
+	u8 i = 0, j = 0;
+	unsigned int offset = 0;
+
+	for (i = 0; i < fld_step_num; i++) {
+		for (j = 0; j < fld_max_frame; j++) {
+			fd->fld_para->fld_step_va[i][j] = fd->fd_fld_step_data.va + offset;
+			fd->fld_para->fld_step_pa[i][j] = fd->fd_fld_step_data.pa + offset;
+			offset += fld_step_align_size[i][j];
+		}
+	}
+
+	for (i = 0, offset = 0; i < fld_max_frame; i++) {
+		fd->fld_para->fld_output_va[i] = fd->fd_fld_out_hw.va + offset;
+		fd->fld_para->fld_output_pa[i] = fd->fd_fld_out_hw.pa + offset;
+		offset += fld_output_size;
+	}
+}
+
+static void aie_update_fddma_buf(struct mtk_aie_dev *fd)
+{
+	struct aie_static_info *pstv = NULL;
+	u8 i = 0, j = 0;
+
+	pstv = &fd->st_info;
+
+	/* 19~27 */
+	fd->dma_para->fd_out_hw_pa[19][0] =
+		fd->dma_para->fd_out_hw_pa[18][1] + pstv->info_element[18].fd_wdma_size[1];
+	fd->dma_para->fd_out_hw_pa[19][1] =
+		fd->dma_para->fd_out_hw_pa[19][0] + pstv->info_element[19].out_xsize_plus_1;
+	fd->dma_para->fd_out_hw_pa[20][0] = fd->dma_para->fd_out_hw_pa[19][0] +
+					    2 * pstv->info_element[20].out_xsize_plus_1;
+	fd->dma_para->fd_out_hw_pa[20][1] = fd->dma_para->fd_out_hw_pa[19][0] +
+					    3 * pstv->info_element[20].out_xsize_plus_1;
+	fd->dma_para->fd_out_hw_pa[21][0] = fd->dma_para->fd_out_hw_pa[19][0] +
+					    4 * pstv->info_element[21].out_xsize_plus_1;
+	fd->dma_para->fd_out_hw_pa[22][0] =
+		fd->dma_para->fd_out_hw_pa[19][0] + pstv->info_element[19].fd_wdma_size[0] +
+		pstv->info_element[19].fd_wdma_size[1] + pstv->info_element[20].fd_wdma_size[0]+
+		pstv->info_element[20].fd_wdma_size[1] + pstv->info_element[21].fd_wdma_size[0];
+	fd->dma_para->fd_out_hw_pa[22][1] =
+		fd->dma_para->fd_out_hw_pa[22][0] + pstv->info_element[22].fd_wdma_size[0] +
+		pstv->info_element[22].fd_wdma_size[2] + pstv->info_element[23].fd_wdma_size[0]+
+		pstv->info_element[23].fd_wdma_size[2] + pstv->info_element[24].fd_wdma_size[0];
+	fd->dma_para->fd_out_hw_pa[22][2] =
+		fd->dma_para->fd_out_hw_pa[22][0] + pstv->info_element[22].out_xsize_plus_1;
+	fd->dma_para->fd_out_hw_pa[22][3] =
+		fd->dma_para->fd_out_hw_pa[22][1] + pstv->info_element[22].out_xsize_plus_1;
+	fd->dma_para->fd_out_hw_pa[23][0] = fd->dma_para->fd_out_hw_pa[22][0] +
+					    2 * pstv->info_element[23].out_xsize_plus_1;
+	fd->dma_para->fd_out_hw_pa[23][1] = fd->dma_para->fd_out_hw_pa[22][1] +
+					    2 * pstv->info_element[23].out_xsize_plus_1;
+	fd->dma_para->fd_out_hw_pa[23][2] = fd->dma_para->fd_out_hw_pa[22][0] +
+					    3 * pstv->info_element[23].out_xsize_plus_1;
+	fd->dma_para->fd_out_hw_pa[23][3] = fd->dma_para->fd_out_hw_pa[22][1] +
+					    3 * pstv->info_element[23].out_xsize_plus_1;
+	fd->dma_para->fd_out_hw_pa[24][0] = fd->dma_para->fd_out_hw_pa[22][0] +
+					    4 * pstv->info_element[24].out_xsize_plus_1;
+	fd->dma_para->fd_out_hw_pa[24][1] = fd->dma_para->fd_out_hw_pa[22][1] +
+					    4 * pstv->info_element[24].out_xsize_plus_1;
+	fd->dma_para->fd_out_hw_pa[25][0] =
+		fd->dma_para->fd_out_hw_pa[22][1] + pstv->info_element[22].fd_wdma_size[1] +
+		pstv->info_element[22].fd_wdma_size[3] + pstv->info_element[23].fd_wdma_size[1]+
+		pstv->info_element[23].fd_wdma_size[3] + pstv->info_element[24].fd_wdma_size[1];
+	fd->dma_para->fd_out_hw_pa[25][1] =
+		fd->dma_para->fd_out_hw_pa[25][0] + pstv->info_element[25].out_xsize_plus_1;
+	fd->dma_para->fd_out_hw_pa[26][0] = fd->dma_para->fd_out_hw_pa[25][0] +
+					    2 * pstv->info_element[26].out_xsize_plus_1;
+	fd->dma_para->fd_out_hw_pa[26][1] = fd->dma_para->fd_out_hw_pa[25][0] +
+					    3 * pstv->info_element[26].out_xsize_plus_1;
+	fd->dma_para->fd_out_hw_pa[27][0] = fd->dma_para->fd_out_hw_pa[25][0] +
+					    4 * pstv->info_element[27].out_xsize_plus_1;
+
+	/* 48~56 */
+	fd->dma_para->fd_out_hw_pa[48][0] =
+		fd->dma_para->fd_out_hw_pa[47][1] + pstv->info_element[47].fd_wdma_size[1];
+	fd->dma_para->fd_out_hw_pa[48][1] =
+		fd->dma_para->fd_out_hw_pa[48][0] + pstv->info_element[48].out_xsize_plus_1;
+	fd->dma_para->fd_out_hw_pa[49][0] = fd->dma_para->fd_out_hw_pa[48][0] +
+					    2 * pstv->info_element[49].out_xsize_plus_1;
+	fd->dma_para->fd_out_hw_pa[49][1] = fd->dma_para->fd_out_hw_pa[48][0] +
+					    3 * pstv->info_element[49].out_xsize_plus_1;
+	fd->dma_para->fd_out_hw_pa[50][0] = fd->dma_para->fd_out_hw_pa[48][0] +
+					    4 * pstv->info_element[50].out_xsize_plus_1;
+	fd->dma_para->fd_out_hw_pa[51][0] =
+		fd->dma_para->fd_out_hw_pa[48][0] + pstv->info_element[48].fd_wdma_size[0] +
+		pstv->info_element[48].fd_wdma_size[1] + pstv->info_element[49].fd_wdma_size[0]+
+		pstv->info_element[49].fd_wdma_size[1] + pstv->info_element[50].fd_wdma_size[0];
+	fd->dma_para->fd_out_hw_pa[51][1] =
+		fd->dma_para->fd_out_hw_pa[51][0] + pstv->info_element[51].fd_wdma_size[0] +
+		pstv->info_element[51].fd_wdma_size[2] + pstv->info_element[52].fd_wdma_size[0]+
+		pstv->info_element[52].fd_wdma_size[2] + pstv->info_element[53].fd_wdma_size[0];
+	fd->dma_para->fd_out_hw_pa[51][2] =
+		fd->dma_para->fd_out_hw_pa[51][0] + pstv->info_element[51].out_xsize_plus_1;
+	fd->dma_para->fd_out_hw_pa[51][3] =
+		fd->dma_para->fd_out_hw_pa[51][1] + pstv->info_element[51].out_xsize_plus_1;
+	fd->dma_para->fd_out_hw_pa[52][0] = fd->dma_para->fd_out_hw_pa[51][0] +
+					    2 * pstv->info_element[52].out_xsize_plus_1;
+	fd->dma_para->fd_out_hw_pa[52][1] = fd->dma_para->fd_out_hw_pa[51][1] +
+					    2 * pstv->info_element[52].out_xsize_plus_1;
+	fd->dma_para->fd_out_hw_pa[52][2] = fd->dma_para->fd_out_hw_pa[51][0] +
+					    3 * pstv->info_element[52].out_xsize_plus_1;
+	fd->dma_para->fd_out_hw_pa[52][3] = fd->dma_para->fd_out_hw_pa[51][1] +
+					    3 * pstv->info_element[52].out_xsize_plus_1;
+	fd->dma_para->fd_out_hw_pa[53][0] = fd->dma_para->fd_out_hw_pa[51][0] +
+					    4 * pstv->info_element[53].out_xsize_plus_1;
+	fd->dma_para->fd_out_hw_pa[53][1] = fd->dma_para->fd_out_hw_pa[51][1] +
+					    4 * pstv->info_element[53].out_xsize_plus_1;
+	fd->dma_para->fd_out_hw_pa[54][0] =
+		fd->dma_para->fd_out_hw_pa[51][1] + pstv->info_element[51].fd_wdma_size[1] +
+		pstv->info_element[51].fd_wdma_size[3] + pstv->info_element[52].fd_wdma_size[1]+
+		pstv->info_element[52].fd_wdma_size[3] + pstv->info_element[53].fd_wdma_size[1];
+	fd->dma_para->fd_out_hw_pa[54][1] =
+		fd->dma_para->fd_out_hw_pa[54][0] + pstv->info_element[54].out_xsize_plus_1;
+	fd->dma_para->fd_out_hw_pa[55][0] = fd->dma_para->fd_out_hw_pa[54][0] +
+					    2 * pstv->info_element[55].out_xsize_plus_1;
+	fd->dma_para->fd_out_hw_pa[55][1] = fd->dma_para->fd_out_hw_pa[54][0] +
+					    3 * pstv->info_element[55].out_xsize_plus_1;
+	fd->dma_para->fd_out_hw_pa[56][0] = fd->dma_para->fd_out_hw_pa[54][0] +
+					    4 * pstv->info_element[56].out_xsize_plus_1;
+	/* 77~85 */
+	fd->dma_para->fd_out_hw_pa[77][0] =
+		fd->dma_para->fd_out_hw_pa[76][1] + pstv->info_element[76].fd_wdma_size[1];
+	fd->dma_para->fd_out_hw_pa[77][1] =
+		fd->dma_para->fd_out_hw_pa[77][0] + pstv->info_element[77].out_xsize_plus_1;
+	fd->dma_para->fd_out_hw_pa[78][0] = fd->dma_para->fd_out_hw_pa[77][0] +
+					    2 * pstv->info_element[78].out_xsize_plus_1;
+	fd->dma_para->fd_out_hw_pa[78][1] = fd->dma_para->fd_out_hw_pa[77][0] +
+					    3 * pstv->info_element[78].out_xsize_plus_1;
+	fd->dma_para->fd_out_hw_pa[79][0] = fd->dma_para->fd_out_hw_pa[77][0] +
+					    4 * pstv->info_element[79].out_xsize_plus_1;
+	fd->dma_para->fd_out_hw_pa[80][0] =
+		fd->dma_para->fd_out_hw_pa[77][0] + pstv->info_element[77].fd_wdma_size[0] +
+		pstv->info_element[77].fd_wdma_size[1] + pstv->info_element[78].fd_wdma_size[0]+
+		pstv->info_element[78].fd_wdma_size[1] + pstv->info_element[79].fd_wdma_size[0];
+	fd->dma_para->fd_out_hw_pa[80][1] =
+		fd->dma_para->fd_out_hw_pa[80][0] + pstv->info_element[80].fd_wdma_size[0] +
+		pstv->info_element[80].fd_wdma_size[2] + pstv->info_element[81].fd_wdma_size[0]+
+		pstv->info_element[81].fd_wdma_size[2] + pstv->info_element[82].fd_wdma_size[0];
+	fd->dma_para->fd_out_hw_pa[80][2] =
+		fd->dma_para->fd_out_hw_pa[80][0] + pstv->info_element[80].out_xsize_plus_1;
+	fd->dma_para->fd_out_hw_pa[80][3] =
+		fd->dma_para->fd_out_hw_pa[80][1] + pstv->info_element[80].out_xsize_plus_1;
+	fd->dma_para->fd_out_hw_pa[81][0] = fd->dma_para->fd_out_hw_pa[80][0] +
+					    2 * pstv->info_element[81].out_xsize_plus_1;
+	fd->dma_para->fd_out_hw_pa[81][1] = fd->dma_para->fd_out_hw_pa[80][1] +
+					    2 * pstv->info_element[81].out_xsize_plus_1;
+	fd->dma_para->fd_out_hw_pa[81][2] = fd->dma_para->fd_out_hw_pa[80][0] +
+					    3 * pstv->info_element[81].out_xsize_plus_1;
+	fd->dma_para->fd_out_hw_pa[81][3] = fd->dma_para->fd_out_hw_pa[80][1] +
+					    3 * pstv->info_element[81].out_xsize_plus_1;
+	fd->dma_para->fd_out_hw_pa[82][0] = fd->dma_para->fd_out_hw_pa[80][0] +
+					    4 * pstv->info_element[82].out_xsize_plus_1;
+	fd->dma_para->fd_out_hw_pa[82][1] = fd->dma_para->fd_out_hw_pa[80][1] +
+					    4 * pstv->info_element[82].out_xsize_plus_1;
+	fd->dma_para->fd_out_hw_pa[83][0] =
+		fd->dma_para->fd_out_hw_pa[80][1] + pstv->info_element[80].fd_wdma_size[1] +
+		pstv->info_element[80].fd_wdma_size[3] + pstv->info_element[81].fd_wdma_size[1]+
+		pstv->info_element[81].fd_wdma_size[3] + pstv->info_element[82].fd_wdma_size[1];
+	fd->dma_para->fd_out_hw_pa[83][1] =
+		fd->dma_para->fd_out_hw_pa[83][0] + pstv->info_element[83].out_xsize_plus_1;
+	fd->dma_para->fd_out_hw_pa[84][0] = fd->dma_para->fd_out_hw_pa[83][0] +
+					    2 * pstv->info_element[84].out_xsize_plus_1;
+	fd->dma_para->fd_out_hw_pa[84][1] = fd->dma_para->fd_out_hw_pa[83][0] +
+					    3 * pstv->info_element[84].out_xsize_plus_1;
+	fd->dma_para->fd_out_hw_pa[85][0] = fd->dma_para->fd_out_hw_pa[83][0] +
+					    4 * pstv->info_element[85].out_xsize_plus_1;
+
+	/* VA : except 28, 57, 86 */
+	/* 0~86 */
+	fd->dma_para->fd_out_hw_va[0][0] = fd->fd_dma_hw.va;
+	for (i = 1; i < fd_loop_num; i++) {
+		if (i == rpn2_loop_num || i == rpn1_loop_num ||
+		    i == rpn0_loop_num)
+			continue;
+		for (j = 0; j < 4; j++) {
+			if (fd_wdma_en[i][j]) {
+				fd->dma_para->fd_out_hw_va[i][j] =
+					fd->fd_dma_hw.va +
+					fd->dma_para->fd_out_hw_pa[i][j] -
+					fd->fd_dma_hw.pa;
+			}
+		}
+	}
+}
+
+static void aie_free_dram_buf(struct mtk_aie_dev *fd)
+{
+	aie_imem_free(fd, &fd->rs_cfg_data);
+	aie_imem_free(fd, &fd->fd_cfg_data);
+	aie_imem_free(fd, &fd->yuv2rgb_cfg_data);
+}
+
+static void aie_free_output_buf(struct mtk_aie_dev *fd)
+{
+	aie_imem_free(fd, &fd->rs_output_hw);
+}
+
+static void aie_free_fddma_buf(struct mtk_aie_dev *fd)
+{
+	aie_imem_free(fd, &fd->fd_dma_hw);
+	aie_imem_free(fd, &fd->fd_kernel_hw);
+	aie_imem_free(fd, &fd->fd_attr_dma_hw);
+	aie_imem_free(fd, &fd->fd_dma_result_hw);
+}
+
+static void aie_free_fld_buf(struct mtk_aie_dev *fd)
+{
+	aie_imem_free(fd, &fd->fd_fld_step_data);
+	aie_imem_free(fd, &fd->fd_fld_out_hw);
+}
+
+static int aie_copy_fw(struct mtk_aie_dev *fd, const char *name, void *buf,
+		       unsigned int size)
+{
+	int ret = -EINVAL;
+	const struct firmware *fw = NULL;
+
+	ret = request_firmware(&fw, name, fd->dev);
+	if (ret) {
+		dev_info(fd->dev, "%s: fail to load firmware %s\n", __func__,
+			 name);
+		goto fw_error;
+	}
+
+	if (size < fw->size) {
+		ret = -EINVAL;
+		goto fw_error;
+	}
+
+	memcpy(buf, fw->data, fw->size);
+
+fw_error:
+	if (fw != NULL) {
+		release_firmware(fw);
+		fw = NULL;
+	}
+	return ret;
+}
+
+static int aie_load_fw(struct mtk_aie_dev *fd)
+{
+	u8 i = 0, j = 0;
+	int ret = -EINVAL;
+	char name[128] = {};
+	char *sel_folder = NULL;
+	char *mp_fw30_folder = "aie_mp_fw";
+	char *mp_fw31_folder = "aie_mp_fw31";
+
+	if (fd->variant->hw_version == 30)
+		sel_folder = mp_fw30_folder;
+	else if (fd->variant->hw_version == 31)
+		sel_folder = mp_fw31_folder;
+	else
+		return -EINVAL;
+
+	ret = sprintf(name, "%s/config/aie_fd_fd_config.bin", sel_folder);
+	if (ret < 0)
+		return ret;
+
+	ret = aie_copy_fw(fd, name, fd->base_para->fd_fd_cfg_va,
+			  fd->fd_fd_cfg_size);
+	if (ret)
+		return ret;
+
+	ret = sprintf(name, "%s/config/aie_fd_rs_config.bin", sel_folder);
+	if (ret < 0)
+		return ret;
+
+	ret = aie_copy_fw(fd, name, fd->base_para->fd_rs_cfg_va,
+			  fd->fd_rs_cfg_size);
+	if (ret)
+		return ret;
+
+	ret = sprintf(name, "%s/config/aie_fd_yuv2rgb_config.bin", sel_folder);
+	if (ret < 0)
+		return ret;
+
+	ret = aie_copy_fw(fd, name, fd->base_para->fd_yuv2rgb_cfg_va,
+			  fd->fd_yuv2rgb_cfg_size);
+	if (ret)
+		return ret;
+
+	ret = sprintf(name, "%s/config/aie_attr_fd_config.bin", sel_folder);
+	if (ret < 0)
+		return ret;
+
+	ret = aie_copy_fw(fd, name, fd->base_para->attr_fd_cfg_va[0],
+			  fd->attr_fd_cfg_size);
+	if (ret)
+		return ret;
+
+	ret = sprintf(name, "%s/config/aie_attr_yuv2rgb_config.bin", sel_folder);
+	if (ret < 0)
+		return ret;
+
+	ret = aie_copy_fw(fd, name, fd->base_para->attr_yuv2rgb_cfg_va[0],
+			  fd->attr_yuv2rgb_cfg_size);
+	if (ret)
+		return ret;
+
+	for (i = 1; i < MAX_ENQUE_FRAME_NUM; i++) {
+		memcpy(fd->base_para->attr_fd_cfg_va[i],
+		       fd->base_para->attr_fd_cfg_va[0], fd->attr_fd_cfg_size);
+		memcpy(fd->base_para->attr_yuv2rgb_cfg_va[i],
+		       fd->base_para->attr_yuv2rgb_cfg_va[0],
+		       fd->attr_yuv2rgb_cfg_size);
+	}
+
+	for (i = 0; i < fd_loop_num; i++) {
+		for (j = 0; j < kernel_RDMA_RA_num; j++) {
+			if (fd_ker_rdma_size[i][j]) {
+				ret = sprintf(name,
+					"%s/kernel/aie_fd_kernel_bias_loop%02d_%d.bin",
+					sel_folder, i, j);
+				if (ret < 0)
+					return ret;
+
+				ret = aie_copy_fw(
+					fd, name,
+					fd->dma_para->fd_kernel_va[i][j],
+					fd_ker_rdma_size[i][j]);
+				if (ret)
+					return ret;
+			}
+		}
+	}
+
+	for (i = 0; i < attr_loop_num; i++) {
+		for (j = 0; j < kernel_RDMA_RA_num; j++) {
+			ret = sprintf(name,
+				"%s/kernel/aie_attr_kernel_bias_loop%02d_%d.bin",
+				sel_folder, i, j);
+			if (ret < 0)
+				return ret;
+
+			ret = aie_copy_fw(fd, name,
+					  fd->dma_para->attr_kernel_va[i][j],
+					  attr_ker_rdma_size[i][j]);
+			if (ret)
+				return ret;
+		}
+	}
+
+	if (fd->variant->fld_enable) {
+		ret = sprintf(name, "%s/config/aie_fld_blink_weight_forest14.bin",
+			sel_folder);
+		if (ret < 0)
+			return ret;
+
+		ret = aie_copy_fw(fd, name,
+				  fd->fld_para->fld_step_va[fld_step_blink][14],
+				  fld_step_align_size[fld_step_blink][14]);
+		if (ret)
+			return ret;
+
+		for (j = 0; j < fld_max_frame; j++) {
+			ret = sprintf(name, "%s/config/aie_fld_cv_forest%02d_iom3.bin",
+				sel_folder, j);
+			if (ret < 0)
+				return ret;
+
+			ret = aie_copy_fw(fd, name,
+					  fd->fld_para->fld_step_va[fld_step_cv][j],
+					  fld_step_align_size[fld_step_cv][j]);
+			if (ret)
+				return ret;
+		}
+
+		for (j = 0; j < fld_max_frame; j++) {
+			ret = sprintf(name, "%s/config/aie_fld_fp_forest%02d_om45.bin",
+				sel_folder, j);
+			if (ret < 0)
+				return ret;
+
+			ret = aie_copy_fw(fd, name,
+					  fd->fld_para->fld_step_va[fld_step_fp][j],
+					  fld_step_align_size[fld_step_fp][j]);
+			if (ret)
+				return ret;
+		}
+
+		for (j = 0; j < fld_max_frame; j++) {
+			ret = sprintf(name, "%s/config/aie_fld_leafnode_forest%02d.bin",
+				sel_folder, j);
+			if (ret < 0)
+				return ret;
+
+			ret = aie_copy_fw(fd, name,
+					  fd->fld_para->fld_step_va[fld_step_leaf][j],
+					  fld_step_align_size[fld_step_leaf][j]);
+			if (ret)
+				return ret;
+		}
+
+		for (j = 0; j < fld_max_frame; j++) {
+			ret = sprintf(name, "%s/config/aie_fld_tree_forest%02d_km02.bin",
+				sel_folder, j);
+			if (ret < 0)
+				return ret;
+			ret = aie_copy_fw(fd, name,
+					  fd->fld_para->fld_step_va[fld_step_km02][j],
+					  fld_step_align_size[fld_step_km02][j]);
+			if (ret)
+				return ret;
+		}
+
+		for (j = 0; j < fld_max_frame; j++) {
+			ret = sprintf(name, "%s/config/aie_fld_tree_forest%02d_km13.bin",
+				sel_folder, j);
+			if (ret < 0)
+				return ret;
+			ret = aie_copy_fw(fd, name,
+					  fd->fld_para->fld_step_va[fld_step_km13][j],
+					  fld_step_align_size[fld_step_km13][j]);
+			if (ret)
+				return ret;
+		}
+	}
+
+	return ret;
+}
+
+static void aie_reset_output_buf(struct mtk_aie_dev *fd,
+				 struct aie_enq_info *aie_cfg)
+{
+	if (aie_cfg->sel_mode == 0) {
+		memset(fd->rs_output_hw.va, 0, fd->rs_output_hw.size);
+		memset(fd->dma_para->fd_out_hw_va[rpn0_loop_num][0], 0,
+		       result_size);
+		memset(fd->dma_para->fd_out_hw_va[rpn1_loop_num][0], 0,
+		       result_size);
+		memset(fd->dma_para->fd_out_hw_va[rpn2_loop_num][0], 0,
+		       result_size);
+	} else if (aie_cfg->sel_mode == 1) {
+		memset(fd->base_para->rs_pym_rst_va[0][0], 0,
+		       fd->rs_pym_out_size[0]);
+		memset(fd->base_para->rs_pym_rst_va[0][1], 0,
+		       fd->rs_pym_out_size[0]);
+		memset(fd->base_para->rs_pym_rst_va[0][2], 0,
+		       fd->rs_pym_out_size[0]);
+	} else if (aie_cfg->sel_mode == 2) {
+		if (fd->variant->fld_enable)
+			memset(fd->fld_para->fld_output_va[0], 0,
+			       fld_max_frame * fld_output_size);
+	}
+}
+
+static int aie_update_cfg(struct mtk_aie_dev *fd, struct aie_enq_info *aie_cfg)
+{
+	int crop_width = 0;
+	int crop_height = 0;
+
+	crop_width = aie_cfg->src_img_width;
+	crop_height = aie_cfg->src_img_height;
+
+	if (aie_cfg->en_roi) {
+		crop_width = aie_cfg->src_roi.x2 - aie_cfg->src_roi.x1 + 1;
+		crop_height = aie_cfg->src_roi.y2 - aie_cfg->src_roi.y1 + 1;
+	}
+
+	if (crop_width == 0 || crop_height == 0) {
+		dev_info(fd->dev, "AIE error:crop size is wrong");
+		return -EINVAL;
+	}
+
+	if (aie_cfg->en_padding) {
+		crop_width = crop_width + aie_cfg->src_padding.right +
+			     aie_cfg->src_padding.left;
+		crop_height = crop_height + aie_cfg->src_padding.up +
+			      aie_cfg->src_padding.down;
+	}
+
+	if (aie_cfg->sel_mode == 0) {
+		fd->base_para->sel_mode = aie_cfg->sel_mode;
+		fd->base_para->crop_width = crop_width;
+		fd->base_para->crop_height = crop_height;
+		fd->base_para->src_img_addr = aie_cfg->src_img_addr;
+		fd->base_para->src_img_addr_uv = aie_cfg->src_img_addr_uv;
+		fd->base_para->img_width = aie_cfg->src_img_width;
+		fd->base_para->img_height = aie_cfg->src_img_height;
+		fd->base_para->src_img_fmt = aie_cfg->src_img_fmt;
+		fd->base_para->rotate_degree = aie_cfg->rotate_degree;
+	} else if (aie_cfg->sel_mode == 1) {
+		fd->attr_para->sel_mode[fd->attr_para->w_idx] =
+			aie_cfg->sel_mode;
+		fd->attr_para->crop_width[fd->attr_para->w_idx] = crop_width;
+		fd->attr_para->crop_height[fd->attr_para->w_idx] = crop_height;
+		fd->attr_para->src_img_addr[fd->attr_para->w_idx] =
+			aie_cfg->src_img_addr;
+		fd->attr_para->src_img_addr_uv[fd->attr_para->w_idx] =
+			aie_cfg->src_img_addr_uv;
+		fd->attr_para->img_width[fd->attr_para->w_idx] =
+			aie_cfg->src_img_width;
+		fd->attr_para->img_height[fd->attr_para->w_idx] =
+			aie_cfg->src_img_height;
+		fd->attr_para->src_img_fmt[fd->attr_para->w_idx] =
+			aie_cfg->src_img_fmt;
+		fd->attr_para->rotate_degree[fd->attr_para->w_idx] =
+			aie_cfg->rotate_degree;
+	}
+
+	return 0;
+}
+
+static u32 aie_combine_u16(u16 low, u16 high)
+{
+	return ((u32)high << 16) | low;
+}
+
+static u32 aie_combine_stride(u16 low, u16 high)
+{
+	return ((u32)high << 16) | (low & 0x000F);
+}
+
+static int aie_config_y2r(struct mtk_aie_dev *fd, struct aie_enq_info *aie_cfg,
+			  int mode)
+{
+	u32 img_addr = 0;
+	u32 img_addr_UV = 0;
+	u32 img_off = 0;
+	u32 img_off_uv = 0;
+	u32 *yuv2rgb_cfg = NULL;
+	u32 srcbuf, srcbuf_UV = 0;
+	u16 xmag_0 = 0, ymag_0 = 0;
+	u16 pym0_out_w = 0;
+	u16 pym0_out_h = 0;
+	u16 stride_pym0_out_w = 0;
+	u16 src_crop_w = 0;
+	u16 src_crop_h = 0;
+
+	if (aie_cfg->en_roi == false) {
+		img_off = 0;
+		img_off_uv = 0;
+	} else {
+		if (aie_cfg->src_img_fmt == FMT_MONO ||
+		    aie_cfg->src_img_fmt == FMT_YUV_2P ||
+		    aie_cfg->src_img_fmt == FMT_YVU_2P) {
+			img_off =
+				aie_cfg->src_img_stride * aie_cfg->src_roi.y1 +
+				aie_cfg->src_roi.x1;
+			img_off_uv =
+				aie_cfg->src_img_stride * aie_cfg->src_roi.y1 +
+				aie_cfg->src_roi.x1;
+		} else if (aie_cfg->src_img_fmt == FMT_YUV420_2P ||
+			   aie_cfg->src_img_fmt == FMT_YUV420_1P) {
+			img_off =
+				aie_cfg->src_img_stride * aie_cfg->src_roi.y1 +
+				aie_cfg->src_roi.x1;
+			img_off_uv = aie_cfg->src_img_stride *
+				     aie_cfg->src_roi.y1 / 2 +
+				     aie_cfg->src_roi.x1;
+		} else if (aie_cfg->src_img_fmt == FMT_YUYV ||
+			   aie_cfg->src_img_fmt == FMT_YVYU ||
+			   aie_cfg->src_img_fmt == FMT_UYVY ||
+			   aie_cfg->src_img_fmt == FMT_VYUY) {
+			img_off =
+				aie_cfg->src_img_stride * aie_cfg->src_roi.y1 +
+				aie_cfg->src_roi.x1 * 2;
+			img_off_uv =
+				aie_cfg->src_img_stride * aie_cfg->src_roi.y1 +
+				aie_cfg->src_roi.x1 * 2;
+		} else {
+			dev_info(fd->dev,
+				 "AIE error: Unsupport input format %d",
+				 aie_cfg->src_img_fmt);
+			return -EINVAL;
+		}
+	}
+
+	img_addr = aie_cfg->src_img_addr + img_off;
+	img_addr_UV = aie_cfg->src_img_addr_uv + img_off_uv;
+
+	srcbuf = img_addr;
+	if (aie_cfg->src_img_fmt == FMT_YUV420_2P ||
+	    aie_cfg->src_img_fmt == FMT_YUV420_1P ||
+	    aie_cfg->src_img_fmt == FMT_YUV_2P ||
+	    aie_cfg->src_img_fmt == FMT_YVU_2P)
+		srcbuf_UV = img_addr_UV;
+	else
+		srcbuf_UV = 0;
+
+	if (mode == 0) {
+		src_crop_w = fd->base_para->crop_width;
+		src_crop_h = fd->base_para->crop_height;
+		yuv2rgb_cfg = (u32 *)fd->base_para->fd_yuv2rgb_cfg_va;
+		pym0_out_w = fd->base_para->pyramid_width;
+	} else {
+		src_crop_w = fd->attr_para->crop_width[fd->attr_para->w_idx];
+		src_crop_h = fd->attr_para->crop_height[fd->attr_para->w_idx];
+		yuv2rgb_cfg =
+			(u32 *)fd->base_para
+				->attr_yuv2rgb_cfg_va[fd->attr_para->w_idx];
+		pym0_out_w = ATTR_MODE_PYRAMID_WIDTH;
+	}
+
+	pym0_out_h = pym0_out_w * src_crop_h / src_crop_w;
+
+	if (pym0_out_w != 0) {
+		xmag_0 = 512 * src_crop_w / pym0_out_w;
+		ymag_0 = xmag_0;
+	} else {
+		xmag_0 = 0;
+		ymag_0 = 0;
+	}
+
+	yuv2rgb_cfg[Y2R_SRC_DST_FORMAT] =
+		(yuv2rgb_cfg[Y2R_SRC_DST_FORMAT] & 0xFFFFFFF8) |
+		((aie_cfg->src_img_fmt) & 0x7);
+	if (aie_cfg->src_img_fmt == FMT_YUV420_2P ||
+	    aie_cfg->src_img_fmt == FMT_YUV420_1P) { /* for match patten */
+		yuv2rgb_cfg[Y2R_SRC_DST_FORMAT] =
+			(yuv2rgb_cfg[Y2R_SRC_DST_FORMAT] & 0xFFFFFFF8) |
+			((0x3) & 0x7);
+	}
+	yuv2rgb_cfg[Y2R_IN_W_H] = (yuv2rgb_cfg[Y2R_IN_W_H] & 0xF800F800) |
+				  ((src_crop_w << 16) & 0x7FF0000) |
+				  (src_crop_h & 0x7FF);
+	yuv2rgb_cfg[Y2R_OUT_W_H] = (yuv2rgb_cfg[Y2R_OUT_W_H] & 0xF800F800) |
+				   ((pym0_out_w << 16) & 0x7FF0000) |
+				   (pym0_out_h & 0x7FF);
+
+	if (aie_cfg->src_img_fmt == FMT_YUV_2P ||
+	    aie_cfg->src_img_fmt == FMT_YVU_2P) { /* 2 plane */
+		yuv2rgb_cfg[Y2R_RA0_RA1_EN] =
+			(yuv2rgb_cfg[Y2R_RA0_RA1_EN] & 0xFFFFFFEE) | 0x11;
+		if (aie_cfg->en_roi) {
+			yuv2rgb_cfg[Y2R_IN_X_Y_SIZE0] = aie_combine_u16(
+				aie_cfg->src_roi.x2 - aie_cfg->src_roi.x1,
+				aie_cfg->src_roi.y2 - aie_cfg->src_roi.y1);
+			yuv2rgb_cfg[Y2R_IN_X_Y_SIZE1] = aie_combine_u16(
+				aie_cfg->src_roi.x2 - aie_cfg->src_roi.x1,
+				aie_cfg->src_roi.y2 - aie_cfg->src_roi.y1);
+		} else {
+			yuv2rgb_cfg[Y2R_IN_X_Y_SIZE0] =
+				aie_combine_u16(src_crop_w - 1, src_crop_h - 1);
+			yuv2rgb_cfg[Y2R_IN_X_Y_SIZE1] =
+				aie_combine_u16(src_crop_w - 1, src_crop_h - 1);
+		}
+		yuv2rgb_cfg[Y2R_IN_STRIDE0_BUS_SIZE0] =
+			(yuv2rgb_cfg[Y2R_IN_STRIDE0_BUS_SIZE0] & 0xFFF0) |
+			((aie_cfg->src_img_stride << 16) & 0xFFFF0000) | 0x1;
+		yuv2rgb_cfg[Y2R_IN_STRIDE1_BUS_SIZE1] =
+			(yuv2rgb_cfg[Y2R_IN_STRIDE1_BUS_SIZE1] & 0xFFF0) |
+			((aie_cfg->src_img_stride << 16) & 0xFFFF0000) | 0x1;
+	} else if (aie_cfg->src_img_fmt == FMT_MONO) {
+		yuv2rgb_cfg[Y2R_RA0_RA1_EN] =
+			(yuv2rgb_cfg[Y2R_RA0_RA1_EN] & 0xFFFFFFEE) | 0x01;
+		if (aie_cfg->en_roi) {
+			yuv2rgb_cfg[Y2R_IN_X_Y_SIZE0] = aie_combine_u16(
+				aie_cfg->src_roi.x2 - aie_cfg->src_roi.x1,
+				aie_cfg->src_roi.y2 - aie_cfg->src_roi.y1);
+			yuv2rgb_cfg[Y2R_IN_X_Y_SIZE1] = aie_combine_u16(
+				aie_cfg->src_roi.x2 - aie_cfg->src_roi.x1,
+				aie_cfg->src_roi.y2 - aie_cfg->src_roi.y1);
+		} else {
+			yuv2rgb_cfg[Y2R_IN_X_Y_SIZE0] =
+				aie_combine_u16(src_crop_w - 1, src_crop_h - 1);
+			yuv2rgb_cfg[Y2R_IN_X_Y_SIZE1] =
+				aie_combine_u16(src_crop_w - 1, src_crop_h - 1);
+		}
+		yuv2rgb_cfg[Y2R_IN_STRIDE0_BUS_SIZE0] =
+			(yuv2rgb_cfg[Y2R_IN_STRIDE0_BUS_SIZE0] & 0xFFF0) |
+			((aie_cfg->src_img_stride << 16) & 0xFFFF0000) | 0x0;
+		yuv2rgb_cfg[Y2R_IN_STRIDE1_BUS_SIZE1] =
+			(yuv2rgb_cfg[Y2R_IN_STRIDE1_BUS_SIZE1] & 0xFFF0) |
+			((aie_cfg->src_img_stride << 16) & 0xFFFF0000) | 0x0;
+	} else if (aie_cfg->src_img_fmt == FMT_YUYV ||
+		   aie_cfg->src_img_fmt == FMT_YVYU ||
+		   aie_cfg->src_img_fmt == FMT_UYVY ||
+		   aie_cfg->src_img_fmt == FMT_VYUY) { /* 1 plane */
+		yuv2rgb_cfg[Y2R_RA0_RA1_EN] =
+			(yuv2rgb_cfg[Y2R_RA0_RA1_EN] & 0xFFFFFFEE) | 0x1;
+		if (aie_cfg->en_roi) {
+			yuv2rgb_cfg[Y2R_IN_X_Y_SIZE0] =
+				aie_combine_u16(
+				2 * (aie_cfg->src_roi.x2 - aie_cfg->src_roi.x1 + 1) - 1,
+				aie_cfg->src_roi.y2 - aie_cfg->src_roi.y1);
+			yuv2rgb_cfg[Y2R_IN_X_Y_SIZE1] =
+				aie_combine_u16(
+				2 * (aie_cfg->src_roi.x2 - aie_cfg->src_roi.x1 + 1) - 1,
+				aie_cfg->src_roi.y2 - aie_cfg->src_roi.y1);
+		} else {
+			yuv2rgb_cfg[Y2R_IN_X_Y_SIZE0] = aie_combine_u16(
+				2 * src_crop_w - 1, src_crop_h - 1);
+			yuv2rgb_cfg[Y2R_IN_X_Y_SIZE1] = aie_combine_u16(
+				2 * src_crop_w - 1, src_crop_h - 1);
+		}
+		yuv2rgb_cfg[Y2R_IN_STRIDE0_BUS_SIZE0] =
+			(yuv2rgb_cfg[Y2R_IN_STRIDE0_BUS_SIZE0] & 0xFFF0) |
+			((aie_cfg->src_img_stride << 16) & 0xFFFF0000) | 0x3;
+		yuv2rgb_cfg[Y2R_IN_STRIDE1_BUS_SIZE1] =
+			(yuv2rgb_cfg[Y2R_IN_STRIDE1_BUS_SIZE1] & 0xFFF0) |
+			((aie_cfg->src_img_stride << 16) & 0xFFFF0000) | 0x3;
+	}
+
+	/* AIE3.0 */
+	if (aie_cfg->src_img_fmt == FMT_YUV420_2P ||
+	    aie_cfg->src_img_fmt == FMT_YUV420_1P) {
+		yuv2rgb_cfg[Y2R_RA0_RA1_EN] =
+			(yuv2rgb_cfg[Y2R_RA0_RA1_EN] & 0xFFFFFFEE) | 0x11;
+		if (aie_cfg->en_roi) {
+			yuv2rgb_cfg[Y2R_IN_X_Y_SIZE0] = aie_combine_u16(
+				aie_cfg->src_roi.x2 - aie_cfg->src_roi.x1,
+				aie_cfg->src_roi.y2 - aie_cfg->src_roi.y1);
+			yuv2rgb_cfg[Y2R_IN_X_Y_SIZE1] = aie_combine_u16(
+				aie_cfg->src_roi.x2 - aie_cfg->src_roi.x1,
+				(aie_cfg->src_roi.y2 - aie_cfg->src_roi.y1) /
+					2);
+		} else {
+			yuv2rgb_cfg[Y2R_IN_X_Y_SIZE0] =
+				aie_combine_u16(src_crop_w - 1, src_crop_h - 1);
+			yuv2rgb_cfg[Y2R_IN_X_Y_SIZE1] = aie_combine_u16(
+				src_crop_w - 1, src_crop_h / 2 - 1);
+		}
+		yuv2rgb_cfg[Y2R_IN_STRIDE0_BUS_SIZE0] =
+			(yuv2rgb_cfg[Y2R_IN_STRIDE0_BUS_SIZE0] & 0xFFF0) |
+			((aie_cfg->src_img_stride << 16) & 0xFFFF0000) | 0x0;
+		yuv2rgb_cfg[Y2R_IN_STRIDE1_BUS_SIZE1] =
+			(yuv2rgb_cfg[Y2R_IN_STRIDE1_BUS_SIZE1] & 0xFFF0) |
+			((aie_cfg->src_img_stride << 16) & 0xFFFF0000) | 0x0;
+
+		yuv2rgb_cfg[Y2R_CO2_FMT_MODE_EN] =
+			(yuv2rgb_cfg[Y2R_CO2_FMT_MODE_EN] & 0xFFFFFFFE) | 0x01;
+		if (aie_cfg->en_roi) {
+			yuv2rgb_cfg[Y2R_CO2_CROP_X] = aie_combine_u16(
+				0, aie_cfg->src_roi.x2 - aie_cfg->src_roi.x1);
+			yuv2rgb_cfg[Y2R_CO2_CROP_Y] = aie_combine_u16(
+				0, aie_cfg->src_roi.y2 - aie_cfg->src_roi.y1);
+		} else {
+			yuv2rgb_cfg[Y2R_CO2_CROP_X] =
+				aie_combine_u16(0, src_crop_w - 1);
+			yuv2rgb_cfg[Y2R_CO2_CROP_Y] =
+				aie_combine_u16(0, src_crop_h - 1);
+		}
+	} else {
+		yuv2rgb_cfg[Y2R_CO2_FMT_MODE_EN] =
+			(yuv2rgb_cfg[Y2R_CO2_FMT_MODE_EN] & 0xFFFFFFFE);
+
+		if (aie_cfg->en_roi) {
+			yuv2rgb_cfg[Y2R_CO2_CROP_X] = aie_combine_u16(
+				0, aie_cfg->src_roi.x2 - aie_cfg->src_roi.x1);
+			yuv2rgb_cfg[Y2R_CO2_CROP_Y] = aie_combine_u16(
+				0, aie_cfg->src_roi.y2 - aie_cfg->src_roi.y1);
+		} else {
+			yuv2rgb_cfg[Y2R_CO2_CROP_X] =
+				aie_combine_u16(0, src_crop_w - 1);
+			yuv2rgb_cfg[Y2R_CO2_CROP_Y] =
+				aie_combine_u16(0, src_crop_h - 1);
+		}
+	}
+
+	stride_pym0_out_w = round_up(pym0_out_w, 8);
+
+	yuv2rgb_cfg[Y2R_OUT_X_Y_SIZE0] =
+		aie_combine_u16(pym0_out_w - 1, pym0_out_h - 1);
+	yuv2rgb_cfg[Y2R_OUT_STRIDE0_BUS_SIZE0] = aie_combine_u16(
+		yuv2rgb_cfg[Y2R_OUT_STRIDE0_BUS_SIZE0], stride_pym0_out_w);
+	yuv2rgb_cfg[Y2R_OUT_X_Y_SIZE1] =
+		aie_combine_u16(pym0_out_w - 1, pym0_out_h - 1);
+	yuv2rgb_cfg[Y2R_OUT_STRIDE1_BUS_SIZE1] = aie_combine_u16(
+		yuv2rgb_cfg[Y2R_OUT_STRIDE1_BUS_SIZE1], stride_pym0_out_w);
+	yuv2rgb_cfg[Y2R_OUT_X_Y_SIZE2] =
+		aie_combine_u16(pym0_out_w - 1, pym0_out_h - 1);
+	yuv2rgb_cfg[Y2R_OUT_STRIDE2_BUS_SIZE2] = aie_combine_u16(
+		yuv2rgb_cfg[Y2R_OUT_STRIDE2_BUS_SIZE2], stride_pym0_out_w);
+
+	if (aie_cfg->en_padding) {
+		yuv2rgb_cfg[Y2R_PADDING_EN_UP_DOWN] =
+			1 | ((aie_cfg->src_padding.up << 4) & 0x1FF0) |
+			((aie_cfg->src_padding.down << 16) & 0x01FF0000);
+		yuv2rgb_cfg[Y2R_PADDING_RIGHT_LEFT] =
+			(aie_cfg->src_padding.right & 0x01FF) |
+			((aie_cfg->src_padding.left << 16) & 0x01FF0000);
+	} else {
+		yuv2rgb_cfg[Y2R_PADDING_EN_UP_DOWN] = 0;
+		yuv2rgb_cfg[Y2R_PADDING_RIGHT_LEFT] = 0;
+	}
+
+	yuv2rgb_cfg[Y2R_IN_0] = srcbuf;
+	yuv2rgb_cfg[Y2R_IN_1] = srcbuf_UV;
+
+	yuv2rgb_cfg[Y2R_OUT_0] = (u32)fd->base_para->rs_pym_rst_pa[0][0];
+	yuv2rgb_cfg[Y2R_OUT_1] = (u32)fd->base_para->rs_pym_rst_pa[0][1];
+	yuv2rgb_cfg[Y2R_OUT_2] = (u32)fd->base_para->rs_pym_rst_pa[0][2];
+
+	yuv2rgb_cfg[Y2R_X_Y_MAG] =
+		(xmag_0 & 0x3FFF) | ((ymag_0 << 16) & 0x3FFF0000);
+
+	if (src_crop_w >= pym0_out_w) { /* down scale AIE1.0 by FRZ */
+		yuv2rgb_cfg[Y2R_RS_SEL_SRZ_EN] =
+			(yuv2rgb_cfg[Y2R_RS_SEL_SRZ_EN] & 0x00100070);
+		yuv2rgb_cfg[Y2R_SRZ_HORI_STEP] = 0;
+		yuv2rgb_cfg[Y2R_SRZ_VERT_STEP] = 0;
+	} else { /* SRZ */
+		/* 0: FDRZ for down scaling */
+		/* 1: SRZ for up scaling */
+		yuv2rgb_cfg[Y2R_RS_SEL_SRZ_EN] =
+			(yuv2rgb_cfg[Y2R_RS_SEL_SRZ_EN] & 0x00100070) | SRZ_BIT;
+		yuv2rgb_cfg[Y2R_SRZ_HORI_STEP] =
+			((src_crop_w - 1) << 15) / (pym0_out_w - 1);
+		yuv2rgb_cfg[Y2R_SRZ_VERT_STEP] =
+			((src_crop_h - 1) << 15) / (pym0_out_h - 1);
+	}
+
+	if (fd->variant->hw_version == 31) {
+		yuv2rgb_cfg[Y2R_CON_IN_BA_MSB] = (u32)0x02020202;
+		yuv2rgb_cfg[Y2R_CON_OUT_BA_MSB] = (u32)0x02020202;
+	}
+
+	return 0;
+}
+
+static int aie_config_rs(struct mtk_aie_dev *fd, struct aie_enq_info *aie_cfg)
+{
+	u32 *rs_cfg = NULL;
+	u32 *rs_tbl[2] = {NULL,NULL};
+	u16 xmag_0 = 0, ymag_0 = 0;
+	u16 pym_out_w[3] = {0,0,0};
+	u16 pym_out_h[3] = {0,0,0};
+	u16 round_w = 0;
+	u16 src_crop_w = 0;
+	u16 src_crop_h = 0;
+	int i = 0;
+
+	if (aie_cfg->sel_mode == 0) {
+		src_crop_w = fd->base_para->crop_width;
+		src_crop_h = fd->base_para->crop_height;
+	} else {
+		src_crop_w = fd->attr_para->crop_width[fd->attr_para->w_idx];
+		src_crop_h = fd->attr_para->crop_height[fd->attr_para->w_idx];
+	}
+
+	rs_cfg = (u32 *)fd->base_para->fd_rs_cfg_va;
+
+	pym_out_w[0] = fd->base_para->pyramid_width;
+	pym_out_w[1] = pym_out_w[0] >> 1;
+	pym_out_w[2] = pym_out_w[1] >> 1;
+
+	pym_out_h[0] = pym_out_w[0] * src_crop_h / src_crop_w;
+	pym_out_h[1] = pym_out_h[0] >> 1;
+	pym_out_h[2] = pym_out_h[1] >> 1;
+
+	for (i = 0; i < 2; i++) {
+		rs_tbl[i] = rs_cfg + fd->variant->rs_cfg_size * i;
+
+		rs_tbl[i][RS_IN_0] = (u32)fd->base_para->rs_pym_rst_pa[i][0];
+		rs_tbl[i][RS_IN_1] = (u32)fd->base_para->rs_pym_rst_pa[i][1];
+		rs_tbl[i][RS_IN_2] = (u32)fd->base_para->rs_pym_rst_pa[i][2];
+
+		rs_tbl[i][RS_OUT_0] =
+			(u32)fd->base_para->rs_pym_rst_pa[i + 1][0];
+		rs_tbl[i][RS_OUT_1] =
+			(u32)fd->base_para->rs_pym_rst_pa[i + 1][1];
+		rs_tbl[i][RS_OUT_2] =
+			(u32)fd->base_para->rs_pym_rst_pa[i + 1][2];
+
+		rs_tbl[i][RS_INPUT_W_H] =
+			(rs_tbl[i][RS_INPUT_W_H] & 0xF800F800) |
+			(pym_out_h[i] & 0x7FF) |
+			((pym_out_w[i] << 16) & 0x7FF0000);
+		rs_tbl[i][RS_OUTPUT_W_H] =
+			(rs_tbl[i][RS_OUTPUT_W_H] & 0xF800F800) |
+			(pym_out_h[i + 1] & 0x7FF) |
+			((pym_out_w[i + 1] << 16) & 0x7FF0000);
+		rs_tbl[i][RS_IN_X_Y_SIZE0] =
+			aie_combine_u16(pym_out_w[i] - 1, pym_out_h[i] - 1);
+		rs_tbl[i][RS_IN_X_Y_SIZE1] =
+			aie_combine_u16(pym_out_w[i] - 1, pym_out_h[i] - 1);
+		rs_tbl[i][RS_IN_X_Y_SIZE2] =
+			aie_combine_u16(pym_out_w[i] - 1, pym_out_h[i] - 1);
+		rs_tbl[i][RS_IN_STRIDE0] =
+			aie_combine_u16(rs_tbl[i][RS_IN_STRIDE0], pym_out_w[i]);
+		rs_tbl[i][RS_IN_STRIDE1] =
+			aie_combine_u16(rs_tbl[i][RS_IN_STRIDE1], pym_out_w[i]);
+		rs_tbl[i][RS_IN_STRIDE2] =
+			aie_combine_u16(rs_tbl[i][RS_IN_STRIDE2], pym_out_w[i]);
+		rs_tbl[i][RS_OUT_X_Y_SIZE0] = aie_combine_u16(
+			pym_out_w[i + 1] - 1, pym_out_h[i + 1] - 1);
+		rs_tbl[i][RS_OUT_X_Y_SIZE1] = aie_combine_u16(
+			pym_out_w[i + 1] - 1, pym_out_h[i + 1] - 1);
+		rs_tbl[i][RS_OUT_X_Y_SIZE2] = aie_combine_u16(
+			pym_out_w[i + 1] - 1, pym_out_h[i + 1] - 1);
+
+		if (i == 0)
+			round_w = pym_out_w[i + 1];
+		else
+			round_w = round_up(pym_out_w[i + 1], 8);
+
+		rs_tbl[i][RS_OUT_STRIDE0] =
+			aie_combine_u16(rs_tbl[i][RS_OUT_STRIDE0], round_w);
+		rs_tbl[i][RS_OUT_STRIDE1] =
+			aie_combine_u16(rs_tbl[i][RS_OUT_STRIDE1], round_w);
+		rs_tbl[i][RS_OUT_STRIDE2] =
+			aie_combine_u16(rs_tbl[i][RS_OUT_STRIDE2], round_w);
+
+		xmag_0 = 512 * pym_out_w[i] / pym_out_w[i + 1];
+		ymag_0 = xmag_0;
+
+		rs_tbl[i][RS_X_Y_MAG] =
+			(xmag_0 & 0x3FFF) | ((ymag_0 << 16) & 0x3FFF0000);
+
+		if (fd->variant->hw_version == 31) {
+			rs_tbl[i][RS_CON_IN_BA_MSB] = (u32)0x02020202;
+			rs_tbl[i][RS_CON_OUT_BA_MSB] = (u32)0x02020202;
+		}
+	}
+
+	return 0;
+}
+
+static int aie_config_network(struct mtk_aie_dev *fd,
+			      struct aie_enq_info *aie_cfg)
+{
+	u16 conv_width = 0;
+	u16 conv_height = 0;
+	u8 i = 0;
+	u8 j = 0;
+	u8 uch = 0;
+	u8 uloop = 0;
+	u16 fd_xsize[4] = {0,0,0,0};
+	void *fd_cfg = NULL;
+	u32 *fd_cur_cfg = NULL;
+	u32 *fd_cur_set = NULL;
+	u16 pyramid0_out_w = 0;
+	u16 pyramid0_out_h = 0;
+	u16 pyramid1_out_h = 0;
+	u16 pyramid2_out_h = 0;
+	u16 input_height = 0;
+	u16 out_height = 0;
+	u16 out_ysize_plus_1 = 0;
+	u16 out_ysize_plus_1_stride2 = 0;
+	u32 src_crop_w = 0;
+	u32 src_crop_h = 0;
+	struct aie_static_info *pstv  = NULL;
+	u32 cal_x = 0;
+	u32 cal_y = 0;
+
+	pstv = &fd->st_info;
+
+	if (aie_cfg->sel_mode == 0) {
+		src_crop_w = fd->base_para->crop_width;
+		src_crop_h = fd->base_para->crop_height;
+	} else {
+		src_crop_w = fd->attr_para->crop_width[fd->attr_para->w_idx];
+		src_crop_h = fd->attr_para->crop_height[fd->attr_para->w_idx];
+	}
+
+	pyramid0_out_w = fd->base_para->pyramid_width;
+	pyramid0_out_h = pyramid0_out_w * src_crop_h / src_crop_w;
+
+	pyramid1_out_h = pyramid0_out_h / 2;
+	pyramid2_out_h = pyramid1_out_h / 2;
+
+	fd_cfg = fd->base_para->fd_fd_cfg_va;
+
+	for (i = 0; i < fd_loop_num; i++) {
+		fd_cur_cfg = (u32 *)fd_cfg + fd->variant->fd_cfg_size * i;
+		fd_cur_cfg[FD_INPUT_ROTATE] =
+			(fd_cur_cfg[FD_INPUT_ROTATE] & 0xFFFF0FFF) |
+			((aie_cfg->rotate_degree << 12) & 0x3000);
+
+		if (i == 0)
+			input_height = pyramid2_out_h;
+		else if (i == (rpn2_loop_num + 1))
+			input_height = pyramid1_out_h;
+		else if (i == (rpn1_loop_num + 1))
+			input_height = pyramid0_out_h;
+		else {
+			if (fd_out_stride2_in[i] == 0)
+				input_height = out_height;
+			else
+				input_height = (out_height + 1) / 2;
+		}
+
+		if (fd_maxpool[i] == 1 && fd_stride[i] == 1)
+			out_height =
+				DIV_ROUND_UP(input_height, 2 * fd_maxpool[i]);
+		else
+			out_height = 
+				DIV_ROUND_UP(input_height, fd_stride[i] + 2 * fd_maxpool[i]);
+
+		if (i == rpn0_loop_num ||
+			i == rpn1_loop_num ||
+			i == rpn2_loop_num) {
+			conv_width = fd->base_para->img_width;
+			conv_height = fd->base_para->img_height;
+			fd_xsize[0] =
+				pstv->info_element[i].img_width * 2 * 16 * anchor_en_num[i] - 1;
+			fd_xsize[1] = fd_xsize[2] = fd_xsize[3] =
+				pstv->info_element[i].img_width * 2 * 32 * anchor_en_num[i] - 1;
+		} else {
+			conv_width =
+				DIV_ROUND_UP(pstv->info_element[i].img_width, fd_stride[i]);
+			conv_height = 
+				DIV_ROUND_UP(input_height, fd_stride[i]);
+
+			fd_xsize[0] = fd_xsize[1] = fd_xsize[2] = fd_xsize[3] =
+				pstv->info_element[i].input_xsize_plus_1 - 1;
+		}
+
+		fd_cur_cfg[FD_CONV_WIDTH_MOD6] =
+			(fd_cur_cfg[FD_CONV_WIDTH_MOD6] & 0xFF8FFFFF) |
+			(((conv_width % 6) << 20) & 0x00700000);
+		fd_cur_cfg[FD_CONV_IMG_W_H] =
+			aie_combine_u16(conv_height, conv_width);
+
+		fd_cur_cfg[FD_IN_IMG_W_H] =
+			aie_combine_u16(input_height, pstv->info_element[i].img_width);
+		fd_cur_cfg[FD_OUT_IMG_W_H] =
+			aie_combine_u16(out_height, pstv->info_element[i].out_width);
+
+		if (fd_rdma_en[i][0][0] != -1) {
+			for (j = 0; j < 4; j++) {
+				fd_cur_cfg[FD_IN_X_Y_SIZE0 + 2 * j] =
+					aie_combine_u16(fd_xsize[j], input_height - 1);
+				fd_cur_cfg[FD_IN_STRIDE0_BUS_SIZE0 + 2 * j] =
+					aie_combine_stride(
+				fd_cur_cfg[FD_IN_STRIDE0_BUS_SIZE0 + 2 * j],
+						fd_xsize[j] + 1);
+			}
+		}
+
+		out_ysize_plus_1 = out_height - 1;
+		out_ysize_plus_1_stride2 = (out_height + 1) / 2 - 1;
+
+		for (j = 0; j < output_WDMA_WRA_num; j++) {
+			fd_cur_set = fd_cur_cfg + 2 * j;
+			if (!fd_wdma_en[i][j])
+				continue;
+
+			if (out_stride_size[i][j] == 1) {
+				fd_cur_set[FD_OUT_X_Y_SIZE0] = aie_combine_u16(
+					pstv->info_element[i].out_xsize_plus_1 - 1,
+					out_ysize_plus_1);
+				fd_cur_set[FD_OUT_STRIDE0_BUS_SIZE0] =
+					aie_combine_stride(
+						fd_cur_set[FD_OUT_STRIDE0_BUS_SIZE0],
+						pstv->info_element[i].out_stride);
+			} else if (out_stride_size[i][j] == 2) {
+				fd_cur_set[FD_OUT_X_Y_SIZE0] = aie_combine_u16(
+					pstv->info_element[i].out_xsize_plus_1_stride2 - 1,
+					out_ysize_plus_1_stride2);
+				fd_cur_set[FD_OUT_STRIDE0_BUS_SIZE0] =
+					aie_combine_stride(
+						fd_cur_set[FD_OUT_STRIDE0_BUS_SIZE0],
+						pstv->info_element[i].out_stride_stride2);
+			}
+		}
+
+		if (i == rpn0_loop_num || 
+			i == rpn1_loop_num ||
+		    i == rpn2_loop_num) {
+			fd_cur_cfg[FD_RPN_SET] =
+				aie_combine_u16(fd_cur_cfg[FD_RPN_SET],
+						fd->base_para->rpn_anchor_thrd);
+		}
+
+		if (i == rpn0_loop_num) {
+			cal_x = ((src_crop_w << 10) * 100 /
+				(int)fd->base_para->pyramid_width) >> 10;
+			cal_y = cal_x * 512 / 100;
+			fd_cur_cfg[FD_IMAGE_COORD] =
+				(fd_cur_cfg[FD_IMAGE_COORD] & 0xF) |
+				((cal_y << 4) & 0x7FFF0);
+			fd_cur_cfg[FD_IMAGE_COORD_XY_OFST] = 0;
+			if (aie_cfg->en_roi) {
+				fd_cur_cfg[FD_IMAGE_COORD_XY_OFST] =
+				(aie_cfg->src_roi.x1 - aie_cfg->src_padding.left) |
+				(aie_cfg->src_roi.y1 - aie_cfg->src_padding.up) << 16;
+			}
+		} else if (i == rpn1_loop_num) {
+			cal_x = ((src_crop_w << 10) * 100 /
+				(int)fd->base_para->pyramid_width) >> 10;
+			cal_y = cal_x * 2 * 512 / 100;
+			fd_cur_cfg[FD_IMAGE_COORD] =
+				(fd_cur_cfg[FD_IMAGE_COORD] & 0xF) |
+				((cal_y << 4) & 0x7FFF0);
+			fd_cur_cfg[FD_IMAGE_COORD_XY_OFST] = 0;
+			if (aie_cfg->en_roi) {
+				fd_cur_cfg[FD_IMAGE_COORD_XY_OFST] =
+				(aie_cfg->src_roi.x1 - aie_cfg->src_padding.left) |
+				(aie_cfg->src_roi.y1 - aie_cfg->src_padding.up) << 16;
+			}
+		} else if (i == rpn2_loop_num) {
+			cal_x = ((src_crop_w << 10) * 100 /
+				(int)fd->base_para->pyramid_width) >> 10;
+			cal_y = cal_x * 4 * 512 / 100;
+			fd_cur_cfg[FD_IMAGE_COORD] =
+				(fd_cur_cfg[FD_IMAGE_COORD] & 0xF) |
+				((cal_y << 4) & 0x7FFF0);
+			fd_cur_cfg[FD_IMAGE_COORD_XY_OFST] = 0;
+			if (aie_cfg->en_roi) {
+				fd_cur_cfg[FD_IMAGE_COORD_XY_OFST] =
+				(aie_cfg->src_roi.x1 - aie_cfg->src_padding.left) |
+				(aie_cfg->src_roi.y1 - aie_cfg->src_padding.up) << 16;
+			}
+		}
+
+		/* IN_FM_BASE_ADR */
+		if (i == 0) {
+			fd_cur_cfg[FD_IN_0] =
+				(u32)(fd->base_para->rs_pym_rst_pa[2][0]);
+			fd_cur_cfg[FD_IN_1] =
+				(u32)(fd->base_para->rs_pym_rst_pa[2][1]);
+			fd_cur_cfg[FD_IN_2] =
+				(u32)(fd->base_para->rs_pym_rst_pa[2][2]);
+		} else if (i == (rpn2_loop_num + 1)) {
+			fd_cur_cfg[FD_IN_0] =
+				(u32)(fd->base_para->rs_pym_rst_pa[1][0]);
+			fd_cur_cfg[FD_IN_1] =
+				(u32)(fd->base_para->rs_pym_rst_pa[1][1]);
+			fd_cur_cfg[FD_IN_2] =
+				(u32)(fd->base_para->rs_pym_rst_pa[1][2]);
+		} else if (i == (rpn1_loop_num + 1)) {
+			fd_cur_cfg[FD_IN_0] =
+				(u32)(fd->base_para->rs_pym_rst_pa[0][0]);
+			fd_cur_cfg[FD_IN_1] =
+				(u32)(fd->base_para->rs_pym_rst_pa[0][1]);
+			fd_cur_cfg[FD_IN_2] =
+				(u32)(fd->base_para->rs_pym_rst_pa[0][2]);
+		} else {
+			for (j = 0; j < input_WDMA_WRA_num; j++) {
+				if (fd_rdma_en[i][j][0] != -1) {
+					uloop = fd_rdma_en[i][j][0];
+					uch = fd_rdma_en[i][j][1];
+					fd_cur_cfg[FD_IN_0 + j] =
+						(u32)(fd->dma_para->fd_out_hw_pa[uloop][uch]);
+				}
+			}
+		}
+
+		/* OUT_FM_BASE_ADR */
+		for (j = 0; j < output_WDMA_WRA_num; j++) {
+			if (fd_wdma_en[i][j]) {
+				fd_cur_cfg[FD_OUT_0 + j] =
+					(u32)(fd->dma_para->fd_out_hw_pa[i][j]);
+			}
+		}
+
+		/* KERNEL_BASE_ADR */
+		for (j = 0; j < kernel_RDMA_RA_num; j++) {
+			if (fd_ker_rdma_size[i][j]) {
+				fd_cur_cfg[FD_KERNEL_0 + j] =
+					(u32)(fd->dma_para->fd_kernel_pa[i][j]);
+			}
+		}
+
+		if (fd->variant->hw_version == 31) {
+			fd_cur_cfg[FD_CON_IN_BA_MSB] = (u32)0x02020202;
+			fd_cur_cfg[FD_CON_OUT_BA_MSB] = (u32)0x02020202;
+			fd_cur_cfg[FD_CON_KERNEL_BA_MSB] = (u32)0x00000202;
+		}
+	}
+
+	return 0;
+}
+
+static int aie_config_attr_network(struct mtk_aie_dev *fd,
+				   struct aie_enq_info *aie_cfg)
+{
+	bool isRegressionLoop = false;
+	void *fd_cfg = NULL;
+	u32 *fd_cur_cfg = NULL;
+	u16 fd_input_ht = 0, fd_output_ht = 0;
+	u16 fd_out_y[4] = {0,0,0,0};
+	u8 i = 0, j = 0;
+	u8 uloop = 0, uch = 0, uidx = 0;
+	u16 pyramid0_out_w = 0, pyramid0_out_h = 0;
+	int fd_conv_ht = 0;
+	u16 src_crop_w = 0;
+	u16 src_crop_h = 0;
+
+	src_crop_w = fd->attr_para->crop_width[fd->attr_para->w_idx];
+	src_crop_h = fd->attr_para->crop_height[fd->attr_para->w_idx];
+
+	pyramid0_out_w = ATTR_MODE_PYRAMID_WIDTH;
+	pyramid0_out_h = pyramid0_out_w * src_crop_h / src_crop_w;
+
+	fd_cfg = fd->base_para->attr_fd_cfg_va[fd->attr_para->w_idx];
+
+	for (i = 0; i < attr_loop_num; i++) {
+		fd_cur_cfg = (u32 *)fd_cfg + fd->variant->fd_cfg_size * i;
+		fd_cur_cfg[FD_INPUT_ROTATE] =
+			(fd_cur_cfg[FD_INPUT_ROTATE] & 0xFFFF0FFF) |
+			((aie_cfg->rotate_degree << 12) & 0x3000);
+		if (i == 0)
+			fd_input_ht = pyramid0_out_h;
+		else {
+			if (attr_out_stride2_as_in[i] == 0)
+				fd_input_ht = fd_output_ht;
+			else if (attr_out_stride2_as_in[i] == 1)
+				fd_input_ht = (fd_output_ht + 1) / 2;
+		}
+		fd_output_ht = 
+			DIV_ROUND_UP(fd_input_ht, attr_fd_stride[i] + 2 * attr_fd_maxpool[i]);
+		fd_conv_ht = 
+			DIV_ROUND_UP(fd_input_ht, attr_fd_stride[i]);
+
+		fd_cur_cfg[FD_CONV_IMG_W_H] =
+			(fd_cur_cfg[FD_CONV_IMG_W_H] & 0xFFFF0000) |
+			(fd_conv_ht & 0xFFFF);
+		fd_cur_cfg[FD_IN_IMG_W_H] =
+			(fd_cur_cfg[FD_IN_IMG_W_H] & 0xFFFF0000) |
+			(fd_input_ht & 0xFFFF);
+		fd_cur_cfg[FD_OUT_IMG_W_H] =
+			(fd_cur_cfg[FD_OUT_IMG_W_H] & 0xFFFF0000) |
+			(fd_output_ht & 0xFFFF);
+		fd_cur_cfg[FD_IN_X_Y_SIZE0] = aie_combine_u16(
+			fd_cur_cfg[FD_IN_X_Y_SIZE0], fd_input_ht - 1);
+		fd_cur_cfg[FD_IN_X_Y_SIZE1] = aie_combine_u16(
+			fd_cur_cfg[FD_IN_X_Y_SIZE1], fd_input_ht - 1);
+		fd_cur_cfg[FD_IN_X_Y_SIZE2] = aie_combine_u16(
+			fd_cur_cfg[FD_IN_X_Y_SIZE2], fd_input_ht - 1);
+		fd_cur_cfg[FD_IN_X_Y_SIZE3] = aie_combine_u16(
+			fd_cur_cfg[FD_IN_X_Y_SIZE3], fd_input_ht - 1);
+
+		isRegressionLoop = (i == age_out_rgs || i == gender_out_rgs ||
+				    i == indian_out_rgs || i == race_out_rgs);
+
+		if (isRegressionLoop) {
+			fd_out_y[0] = 0;
+			fd_out_y[1] = 0;
+			fd_out_y[2] = 0;
+			fd_out_y[3] = 0;
+		} else {
+			fd_out_y[0] = fd_output_ht - 1;
+			fd_out_y[1] = fd_output_ht - 1;
+			if (attr_out_2size[i] == 0) {
+				fd_out_y[2] = fd_output_ht - 1;
+				fd_out_y[3] = fd_output_ht - 1;
+			} else {
+				fd_out_y[2] = (fd_output_ht + 1) / 2 - 1;
+				fd_out_y[3] = (fd_output_ht + 1) / 2 - 1;
+			}
+		}
+
+		for (j = 0; j < 4; j++)
+			fd_cur_cfg[FD_OUT_X_Y_SIZE0 + 2 * j] = aie_combine_u16(
+				fd_cur_cfg[FD_OUT_X_Y_SIZE0 + 2 * j],
+				fd_out_y[j]);
+
+		/* IN_FM_BASE_ADR */
+		if (i == 0) {
+			fd_cur_cfg[FD_IN_0] =
+				(u32)(fd->base_para->rs_pym_rst_pa[0][0]);
+			fd_cur_cfg[FD_IN_1] =
+				(u32)(fd->base_para->rs_pym_rst_pa[0][1]);
+			fd_cur_cfg[FD_IN_2] =
+				(u32)(fd->base_para->rs_pym_rst_pa[0][2]);
+		} else {
+			for (j = 0; j < input_WDMA_WRA_num; j++) {
+				if (attr_rdma_en[i][j][0] != -1) {
+					uloop = attr_rdma_en[i][j][0];
+					uch = attr_rdma_en[i][j][1];
+					fd_cur_cfg[FD_IN_0 + j] =
+						(u32)(fd->dma_para->attr_out_hw_pa[uloop][uch]);
+				}
+			}
+		}
+
+		/* OUT_FM_BASE_ADR */
+		for (j = 0; j < output_WDMA_WRA_num; j++) {
+			if (attr_wdma_en[i][j]) {
+				uidx = fd->attr_para->w_idx;
+				if (i == age_out_rgs && j == 0)
+					fd_cur_cfg[FD_OUT_0 + j] =
+						(u32)(fd->dma_para->age_out_hw_pa[uidx]);
+				else if (i == gender_out_rgs && j == 0)
+					fd_cur_cfg[FD_OUT_0 + j] =
+						(u32)(fd->dma_para->gender_out_hw_pa[uidx]);
+				else if (i == indian_out_rgs && j == 0)
+					fd_cur_cfg[FD_OUT_0 + j] =
+						(u32)(fd->dma_para->isIndian_out_hw_pa[uidx]);
+				else if (i == race_out_rgs && j == 0)
+					fd_cur_cfg[FD_OUT_0 + j] =
+						(u32)(fd->dma_para->race_out_hw_pa[uidx]);
+				else
+					fd_cur_cfg[FD_OUT_0 + j] =
+						(u32)(fd->dma_para->attr_out_hw_pa[i][j]);
+			}
+		}
+
+		/* KERNEL_BASE_ADR */
+		for (j = 0; j < kernel_RDMA_RA_num; j++) {
+			fd_cur_cfg[FD_KERNEL_0 + j] =
+				(u32)(fd->dma_para->attr_kernel_pa[i][j]);
+		}
+
+		if (fd->variant->hw_version == 31) {
+			fd_cur_cfg[FD_CON_IN_BA_MSB] = (u32)0x02020202;
+			fd_cur_cfg[FD_CON_OUT_BA_MSB] = (u32)0x02020202;
+			fd_cur_cfg[FD_CON_KERNEL_BA_MSB] = (u32)0x00000202;
+		}
+	}
+	return 0;
+}
+
+static int aie_config_dram(struct mtk_aie_dev *fd, struct aie_enq_info *aie_cfg)
+{
+	int ret = -EINVAL;
+
+	if (aie_cfg->sel_mode == 0) { /* FDMODE */
+		ret = aie_config_y2r(fd, aie_cfg, aie_cfg->sel_mode);
+		if (ret)
+			return ret;
+
+		ret = aie_config_rs(fd, aie_cfg);
+		if (ret)
+			return ret;
+
+		ret = aie_config_network(fd, aie_cfg);
+		if (ret)
+			return ret;
+
+	} else if (aie_cfg->sel_mode == 1) { /* ATTRIBUTEMODE */
+		ret = aie_config_y2r(fd, aie_cfg, aie_cfg->sel_mode);
+		if (ret)
+			return ret;
+
+		ret = aie_config_attr_network(fd, aie_cfg);
+		if (ret)
+			return ret;
+	}
+
+	return ret;
+}
+
+void aie_reset(struct mtk_aie_dev *fd)
+{
+	writel(0x30000, fd->fd_base + AIE_START_REG);
+	writel(0x0, fd->fd_base + AIE_START_REG);
+}
+
+int aie_init(struct mtk_aie_dev *fd, struct user_init *user_init)
+{
+	int ret = -ENOMEM;
+
+	fd->fd_state = STATE_NA;
+	fd->fd_mem_size = 0;
+
+	fd->base_para = kmalloc(sizeof(struct aie_para), GFP_KERNEL);
+	if (fd->base_para == NULL)
+		goto kmalloc_fail;
+
+	fd->attr_para = kmalloc(sizeof(struct aie_attr_para), GFP_KERNEL);
+	if (fd->attr_para == NULL)
+		goto kmalloc_fail;
+
+	fd->dma_para = kmalloc(sizeof(struct aie_fd_dma_para), GFP_KERNEL);
+	if (fd->dma_para == NULL)
+		goto kmalloc_fail;
+
+	if (fd->variant->fld_enable) {
+		fd->fld_para = kmalloc(sizeof(struct aie_fd_fld_para), GFP_KERNEL);
+		if (fd->fld_para == NULL)
+			goto kmalloc_fail;
+	}
+
+	fd->base_para->rpn_anchor_thrd = (signed short)(user_init->feature_threshold & 0x0000FFFF);
+	fd->base_para->pyramid_width = user_init->pyramid_width;
+	fd->base_para->pyramid_height = user_init->pyramid_height;
+	fd->base_para->max_pyramid_width =  user_init->pyramid_width;
+	fd->base_para->max_pyramid_height = user_init->pyramid_height;
+
+	memset(&fd->st_info, 0, sizeof(struct aie_static_info));
+	aie_init_table(fd, fd->base_para->max_pyramid_width,
+		       fd->base_para->max_pyramid_height);
+	aie_get_data_size(fd, user_init->max_img_width,
+			  user_init->max_img_height);
+	ret = aie_alloc_dram_buf(fd);
+	if (ret)
+		goto free_all;
+
+	ret = aie_alloc_output_buf(fd);
+	if (ret)
+		goto free_all;
+
+	ret = aie_alloc_fddma_buf(fd);
+	if (ret)
+		goto free_all;
+
+	if (fd->variant->fld_enable) {
+		ret = aie_alloc_fld_buf(fd);
+		if (ret)
+			goto free_all;
+	}
+
+	aie_arrange_fddma_buf(fd);
+	aie_arrange_kernel_buf(fd);
+	aie_arrange_attrdma_buf(fd);
+	aie_arrange_result_dma_buf(fd);
+
+	if (fd->variant->fld_enable)
+		aie_arrange_fld_buf(fd);
+
+	ret = aie_load_fw(fd);
+	if (ret) {
+		dev_err(fd->dev, "Failed to load aie fw\n");
+		goto free_all;
+	}
+
+	fd->attr_para->r_idx = 0;
+	fd->attr_para->w_idx = 0;
+
+	fd->fd_state = STATE_INIT;
+
+	dev_info(fd->dev, "%s: fd_mem_size(%d)\n", __func__, fd->fd_mem_size);
+
+	return ret;
+
+free_all:
+	aie_free_dram_buf(fd);
+	aie_free_output_buf(fd);
+	aie_free_fddma_buf(fd);
+	if (fd->variant->fld_enable) {
+		aie_free_fld_buf(fd);
+	}
+
+kmalloc_fail:
+    if(fd->base_para)
+		kfree(fd->base_para);
+	if(fd->attr_para)
+		kfree(fd->attr_para);
+	if(fd->dma_para)
+		kfree(fd->dma_para);
+	if(fd->fld_para)
+		kfree(fd->fld_para);
+
+	dev_info(fd->dev, "Failed to init aie\n");
+
+	return ret;
+}
+
+void aie_uninit(struct mtk_aie_dev *fd)
+{
+	fd->fd_state = STATE_NA;
+
+	aie_free_dram_buf(fd);
+	aie_free_output_buf(fd);
+	aie_free_fddma_buf(fd);
+
+	if (fd->variant->fld_enable)
+		aie_free_fld_buf(fd);
+
+    if(fd->base_para)
+		kfree(fd->base_para);
+    if(fd->attr_para)
+		kfree(fd->attr_para);
+    if(fd->dma_para)
+		kfree(fd->dma_para);
+    if(fd->fld_para)
+		kfree(fd->fld_para);
+}
+
+int aie_prepare(struct mtk_aie_dev *fd, struct aie_enq_info *aie_cfg)
+{
+	int ret = -EINVAL;
+
+	if (fd->fd_state != STATE_INIT) {
+		dev_info(fd->dev, "%s fd state fail: %d\n",
+			 __func__, fd->fd_state);
+		return ret;
+	}
+
+	if (fd->variant->fld_enable) {
+		if (aie_cfg->sel_mode == 2) { /* FLD don't need to prepare buf */
+			dev_info(fd->dev, "FLD, Mode: %d", aie_cfg->sel_mode);
+			return 0;
+		}
+	}
+
+	memset(&fd->reg_cfg, 0, sizeof(struct aie_reg_cfg));
+
+	if (aie_cfg->pyramid_base_width == 0) {
+		fd->base_para->pyramid_width =
+			fd->base_para->max_pyramid_width;
+		fd->base_para->pyramid_height =
+			fd->base_para->max_pyramid_height;
+		fd->base_para->number_of_pyramid = 3;
+	} else {
+		if (aie_cfg->pyramid_base_width >
+			fd->base_para->max_pyramid_width ||
+		    aie_cfg->pyramid_base_height >
+			fd->base_para->max_pyramid_height ||
+		    aie_cfg->number_of_pyramid > 3 ||
+		    aie_cfg->number_of_pyramid <= 0) {
+			dev_info(fd->dev, "err: base w: %d, h: %d, num: %d\n",
+			    aie_cfg->pyramid_base_width,
+			    aie_cfg->pyramid_base_height,
+			    aie_cfg->number_of_pyramid);
+			dev_info(fd->dev, "err: max w: %d, h: %d\n",
+			    fd->base_para->max_pyramid_width,
+			    fd->base_para->max_pyramid_height);
+
+			return ret;
+		}
+
+		fd->base_para->pyramid_height =
+			fd->base_para->max_pyramid_height;
+		fd->base_para->number_of_pyramid =
+			aie_cfg->number_of_pyramid;
+		if (aie_cfg->pyramid_base_width !=
+			fd->base_para->pyramid_width) {
+			dev_info(fd->dev, "pre: %d, cur: %d, num: %d\n",
+				fd->base_para->pyramid_width,
+				aie_cfg->pyramid_base_width,
+				fd->base_para->number_of_pyramid);
+			fd->base_para->pyramid_width =
+				aie_cfg->pyramid_base_width;
+			aie_update_table(
+				fd, fd->base_para->pyramid_width,
+				fd->base_para->pyramid_height);
+			aie_update_fddma_buf(fd);
+		}
+	}
+
+	if ((aie_cfg->src_img_width > fd->base_para->max_img_width) ||
+	    (aie_cfg->src_img_height > fd->base_para->max_img_height)) {
+		dev_info(
+			fd->dev,
+			"AIE error: Enque Size error, Src_WD: %d, Src_HT: %d\n",
+			aie_cfg->src_img_width, aie_cfg->src_img_height);
+
+		dev_info(fd->dev, "AIE error: MAX_Src_WD: %d, MAX_Src_HT: %d\n",
+			 fd->base_para->max_img_width,
+			 fd->base_para->max_img_height);
+		return ret;
+	}
+
+	aie_reset_output_buf(fd, aie_cfg);
+
+	fd->reg_cfg.fd_mode = aie_cfg->sel_mode;
+	if (aie_cfg->sel_mode == 0) { /* FDMODE */
+		fd->reg_cfg.rs_adr = (u32)fd->base_para->fd_rs_cfg_pa;
+		fd->reg_cfg.yuv2rgb_adr = (u32)fd->base_para->fd_yuv2rgb_cfg_pa;
+		fd->reg_cfg.fd_adr = (u32)fd->base_para->fd_fd_cfg_pa +
+			fd->variant->fd_cfg_size * 4 * fd_loop_num /
+			3 * (3 - aie_cfg->number_of_pyramid);
+
+	} else if (aie_cfg->sel_mode == 1) { /* ATTRMODE */
+		fd->reg_cfg.yuv2rgb_adr =
+			(u32)fd->base_para->attr_yuv2rgb_cfg_pa[fd->attr_para->w_idx];
+		fd->reg_cfg.fd_adr =
+			(u32)fd->base_para->attr_fd_cfg_pa[fd->attr_para->w_idx];
+	} else {
+		dev_info(fd->dev, "AIE error, Mode: %d", aie_cfg->sel_mode);
+		return ret;
+	}
+
+	ret = aie_update_cfg(fd, aie_cfg);
+	if (ret)
+		return ret;
+
+	ret = aie_config_dram(fd, aie_cfg);
+	if (ret)
+		return ret;
+
+	if (aie_cfg->sel_mode == 1) { /* ATTRMODE */
+		fd->attr_para->w_idx =
+			(fd->attr_para->w_idx + 1) % MAX_ENQUE_FRAME_NUM;
+	}
+
+	return ret;
+}
+
+void aie_execute(struct mtk_aie_dev *fd, struct aie_enq_info *aie_cfg)
+{
+	unsigned int loop_num = 0;
+	unsigned int loop_reg_val = 0;
+	unsigned int i = 0;
+
+	if (aie_cfg->sel_mode == 0) {
+		writel(0x0, fd->fd_base + AIE_START_REG);
+		writel(0x00000111, fd->fd_base + AIE_ENABLE_REG);
+		loop_num = fd_loop_num / 3 * (aie_cfg->number_of_pyramid);
+		loop_reg_val = (loop_num << 8) |
+			(aie_cfg->number_of_pyramid - 1);
+		writel(loop_reg_val, fd->fd_base + AIE_LOOP_REG);
+		writel(0x1, fd->fd_base + AIE_INT_EN_REG);
+		writel(fd->reg_cfg.rs_adr,
+		       fd->fd_base + AIE_RS_CON_BASE_ADR_REG);
+		writel(fd->reg_cfg.fd_adr,
+		       fd->fd_base + AIE_FD_CON_BASE_ADR_REG);
+		writel(fd->reg_cfg.yuv2rgb_adr,
+		       fd->fd_base + AIE_YUV2RGB_CON_BASE_ADR_REG);
+
+		if (fd->variant->hw_version == 31) {
+			writel(0x00000002,
+			       fd->fd_base + AIE_YUV2RGB_CON_BASE_ADR_MSB);
+			writel(0x00000002,
+			       fd->fd_base + AIE_RS_CON_BASE_ADR_MSB);
+			writel(0x00000002,
+			       fd->fd_base + AIE_FD_CON_BASE_ADR_MSB);
+		}
+
+		writel(0x1, fd->fd_base + AIE_START_REG);
+	} else if (aie_cfg->sel_mode == 1) {
+		writel(0x0, fd->fd_base + AIE_START_REG);
+		writel(0x00000101, fd->fd_base + AIE_ENABLE_REG);
+		writel(0x00001A00, fd->fd_base + AIE_LOOP_REG);
+		writel(0x1, fd->fd_base + AIE_INT_EN_REG);
+		writel(fd->reg_cfg.rs_adr,
+		       fd->fd_base + AIE_RS_CON_BASE_ADR_REG);
+		writel(fd->reg_cfg.fd_adr,
+		       fd->fd_base + AIE_FD_CON_BASE_ADR_REG);
+		writel(fd->reg_cfg.yuv2rgb_adr,
+		       fd->fd_base + AIE_YUV2RGB_CON_BASE_ADR_REG);
+
+		if (fd->variant->hw_version == 31) {
+			writel(0x00000002,
+			       fd->fd_base + AIE_YUV2RGB_CON_BASE_ADR_MSB);
+			writel(0x00000002,
+			       fd->fd_base + AIE_RS_CON_BASE_ADR_MSB);
+			writel(0x00000002,
+			       fd->fd_base + AIE_FD_CON_BASE_ADR_MSB);
+		}
+
+		writel(0x1, fd->fd_base + AIE_START_REG);
+	} else if (aie_cfg->sel_mode == 2) {
+		if (fd->variant->fld_enable) {
+			writel(0x10, fd->fd_base + AIE_START_REG);
+			writel(0x00011111, fd->fd_base + AIE_DMA_CTL_REG);
+			writel(0x01111111, fd->fd_base + FLD_EN);
+			writel(0x1, fd->fd_base + AIE_INT_EN_REG);
+			for (i = 0; i < aie_cfg->fld_face_num; i++) {
+				writel(aie_cfg->src_img_addr,
+				       fd->fd_base + FLD_BASE_ADDR_FACE_0 + i * 0x4);
+				writel(aie_cfg->fld_input[i].fld_in_crop_x1 << 16 |
+				       aie_cfg->fld_input[i].fld_in_crop_y1,
+				       fd->fd_base + fld_face_info_0[i]);
+				writel(aie_cfg->fld_input[i].fld_in_crop_x2 << 16 |
+				       aie_cfg->fld_input[i].fld_in_crop_y2,
+				       fd->fd_base + fld_face_info_1[i]);
+				writel(aie_cfg->fld_input[i].fld_in_rip << 4 |
+				       aie_cfg->fld_input[i].fld_in_rop,
+				       fd->fd_base + fld_face_info_2[i]);
+			}
+
+			writel(aie_cfg->fld_face_num << 28 | fld_forest << 16 | fld_point,
+			       fd->fd_base + FLD_MODEL_PARA1);
+			writel(13 << 16 | 0xfe9, fd->fd_base + FLD_MODEL_PARA14);
+
+			writel(aie_cfg->src_img_width << 16 | aie_cfg->src_img_height,
+			       fd->fd_base + FLD_SRC_WD_HT);
+
+			/*input settings*/
+			writel(0x007c003f, fd->fd_base + FLD_PL_IN_SIZE_0);
+			writel(0x0040000f, fd->fd_base + FLD_PL_IN_STRIDE_0);
+			writel(0x007c003f, fd->fd_base + FLD_PL_IN_SIZE_1);
+			writel(0x0040000f, fd->fd_base + FLD_PL_IN_STRIDE_1);
+			writel(0x0016003f, fd->fd_base + FLD_PL_IN_SIZE_2_0);
+			writel(0x0040000f, fd->fd_base + FLD_PL_IN_STRIDE_2_0);
+			writel(0x0013003f, fd->fd_base + FLD_PL_IN_SIZE_2_1);
+			writel(0x0040000f, fd->fd_base + FLD_PL_IN_STRIDE_2_1);
+			writel(0x0013003f, fd->fd_base + FLD_PL_IN_SIZE_2_2);
+			writel(0x0040000f, fd->fd_base + FLD_PL_IN_STRIDE_2_2);
+			writel(0x00a6001f, fd->fd_base + FLD_PL_IN_SIZE_3);
+			writel(0x0020000f, fd->fd_base + FLD_PL_IN_STRIDE_3);
+
+			/*output setting*/
+			writel((2400 * aie_cfg->fld_face_num - 1) << 16 | 127,
+			       fd->fd_base + FLD_SH_IN_SIZE_0);
+			writel(0x0010000f, fd->fd_base + FLD_SH_IN_STRIDE_0);
+			writel(fd->fld_para->fld_output_pa[0],
+			       fd->fd_base + FLD_TR_OUT_BASE_ADDR_0);
+			writel((aie_cfg->fld_face_num - 1) << 16 | 0x6f,
+			       fd->fd_base + FLD_TR_OUT_SIZE_0);
+			writel(0x0070000f, fd->fd_base + FLD_TR_OUT_STRIDE_0);
+			writel(fd->fld_para->fld_output_pa[0],
+			       fd->fd_base + FLD_PP_OUT_BASE_ADDR_0);
+			writel((aie_cfg->fld_face_num - 1) << 16 | 0x6f,
+			       fd->fd_base + FLD_PP_OUT_SIZE_0);
+			writel(0x0070000f, fd->fd_base + FLD_PP_OUT_STRIDE_0);
+
+			/*cv score*/
+			writel(0x00000001, fd->fd_base + FLD_BS_BIAS);
+			writel(0x0000b835, fd->fd_base + FLD_CV_FM_RANGE_0); //8E8
+			writel(0xffff5cba, fd->fd_base + FLD_CV_FM_RANGE_1); //8EC
+			writel(0x00005ed5, fd->fd_base + FLD_CV_PM_RANGE_0); //8F0
+			writel(0xffff910d, fd->fd_base + FLD_CV_PM_RANGE_1); //8F4
+			writel(0x0000031e, fd->fd_base + FLD_BS_RANGE_0); //8F8
+			writel(0xfffffcae, fd->fd_base + FLD_BS_RANGE_1); //8FC
+
+			/* 6 steps */
+			writel(fd->fld_para->fld_step_pa[fld_step_blink][14],
+			       fd->fd_base + FLD_BS_IN_BASE_ADDR_14);
+
+			writel(fd->fld_para->fld_step_pa[fld_step_cv][0],
+			       fd->fd_base + FLD_PL_IN_BASE_ADDR_2_0);
+			writel(fd->fld_para->fld_step_pa[fld_step_cv][1],
+			       fd->fd_base + FLD_PL_IN_BASE_ADDR_2_1);
+			writel(fd->fld_para->fld_step_pa[fld_step_cv][2],
+			       fd->fd_base + FLD_PL_IN_BASE_ADDR_2_2);
+			writel(fd->fld_para->fld_step_pa[fld_step_cv][3],
+			       fd->fd_base + FLD_PL_IN_BASE_ADDR_2_3);
+			writel(fd->fld_para->fld_step_pa[fld_step_cv][4],
+			       fd->fd_base + FLD_PL_IN_BASE_ADDR_2_4);
+			writel(fd->fld_para->fld_step_pa[fld_step_cv][5],
+			       fd->fd_base + FLD_PL_IN_BASE_ADDR_2_5);
+			writel(fd->fld_para->fld_step_pa[fld_step_cv][6],
+			       fd->fd_base + FLD_PL_IN_BASE_ADDR_2_6);
+			writel(fd->fld_para->fld_step_pa[fld_step_cv][7],
+			       fd->fd_base + FLD_PL_IN_BASE_ADDR_2_7);
+			writel(fd->fld_para->fld_step_pa[fld_step_cv][8],
+			       fd->fd_base + FLD_PL_IN_BASE_ADDR_2_8);
+			writel(fd->fld_para->fld_step_pa[fld_step_cv][9],
+			       fd->fd_base + FLD_PL_IN_BASE_ADDR_2_9);
+			writel(fd->fld_para->fld_step_pa[fld_step_cv][10],
+			       fd->fd_base + FLD_PL_IN_BASE_ADDR_2_10);
+			writel(fd->fld_para->fld_step_pa[fld_step_cv][11],
+			       fd->fd_base + FLD_PL_IN_BASE_ADDR_2_11);
+			writel(fd->fld_para->fld_step_pa[fld_step_cv][12],
+			       fd->fd_base + FLD_PL_IN_BASE_ADDR_2_12);
+			writel(fd->fld_para->fld_step_pa[fld_step_cv][13],
+			       fd->fd_base + FLD_PL_IN_BASE_ADDR_2_13);
+			writel(fd->fld_para->fld_step_pa[fld_step_cv][14],
+			       fd->fd_base + FLD_PL_IN_BASE_ADDR_2_14);
+
+			writel(fd->fld_para->fld_step_pa[fld_step_fp][0],
+			       fd->fd_base + FLD_PL_IN_BASE_ADDR_3_0);
+			writel(fd->fld_para->fld_step_pa[fld_step_fp][1],
+			       fd->fd_base + FLD_PL_IN_BASE_ADDR_3_1);
+			writel(fd->fld_para->fld_step_pa[fld_step_fp][2],
+			       fd->fd_base + FLD_PL_IN_BASE_ADDR_3_2);
+			writel(fd->fld_para->fld_step_pa[fld_step_fp][3],
+			       fd->fd_base + FLD_PL_IN_BASE_ADDR_3_3);
+			writel(fd->fld_para->fld_step_pa[fld_step_fp][4],
+			       fd->fd_base + FLD_PL_IN_BASE_ADDR_3_4);
+			writel(fd->fld_para->fld_step_pa[fld_step_fp][5],
+			       fd->fd_base + FLD_PL_IN_BASE_ADDR_3_5);
+			writel(fd->fld_para->fld_step_pa[fld_step_fp][6],
+			       fd->fd_base + FLD_PL_IN_BASE_ADDR_3_6);
+			writel(fd->fld_para->fld_step_pa[fld_step_fp][7],
+			       fd->fd_base + FLD_PL_IN_BASE_ADDR_3_7);
+			writel(fd->fld_para->fld_step_pa[fld_step_fp][8],
+			       fd->fd_base + FLD_PL_IN_BASE_ADDR_3_8);
+			writel(fd->fld_para->fld_step_pa[fld_step_fp][9],
+			       fd->fd_base + FLD_PL_IN_BASE_ADDR_3_9);
+			writel(fd->fld_para->fld_step_pa[fld_step_fp][10],
+			       fd->fd_base + FLD_PL_IN_BASE_ADDR_3_10);
+			writel(fd->fld_para->fld_step_pa[fld_step_fp][11],
+			       fd->fd_base + FLD_PL_IN_BASE_ADDR_3_11);
+			writel(fd->fld_para->fld_step_pa[fld_step_fp][12],
+			       fd->fd_base + FLD_PL_IN_BASE_ADDR_3_12);
+			writel(fd->fld_para->fld_step_pa[fld_step_fp][13],
+			       fd->fd_base + FLD_PL_IN_BASE_ADDR_3_13);
+			writel(fd->fld_para->fld_step_pa[fld_step_fp][14],
+			       fd->fd_base + FLD_PL_IN_BASE_ADDR_3_14);
+
+			writel(fd->fld_para->fld_step_pa[fld_step_leaf][0],
+			       fd->fd_base + FLD_SH_IN_BASE_ADDR_0);
+			writel(fd->fld_para->fld_step_pa[fld_step_leaf][1],
+			       fd->fd_base + FLD_SH_IN_BASE_ADDR_1);
+			writel(fd->fld_para->fld_step_pa[fld_step_leaf][2],
+			       fd->fd_base + FLD_SH_IN_BASE_ADDR_2);
+			writel(fd->fld_para->fld_step_pa[fld_step_leaf][3],
+			       fd->fd_base + FLD_SH_IN_BASE_ADDR_3);
+			writel(fd->fld_para->fld_step_pa[fld_step_leaf][4],
+			       fd->fd_base + FLD_SH_IN_BASE_ADDR_4);
+			writel(fd->fld_para->fld_step_pa[fld_step_leaf][5],
+			       fd->fd_base + FLD_SH_IN_BASE_ADDR_5);
+			writel(fd->fld_para->fld_step_pa[fld_step_leaf][6],
+			       fd->fd_base + FLD_SH_IN_BASE_ADDR_6);
+			writel(fd->fld_para->fld_step_pa[fld_step_leaf][7],
+			       fd->fd_base + FLD_SH_IN_BASE_ADDR_7);
+			writel(fd->fld_para->fld_step_pa[fld_step_leaf][8],
+			       fd->fd_base + FLD_SH_IN_BASE_ADDR_8);
+			writel(fd->fld_para->fld_step_pa[fld_step_leaf][9],
+			       fd->fd_base + FLD_SH_IN_BASE_ADDR_9);
+			writel(fd->fld_para->fld_step_pa[fld_step_leaf][10],
+			       fd->fd_base + FLD_SH_IN_BASE_ADDR_10);
+			writel(fd->fld_para->fld_step_pa[fld_step_leaf][11],
+			       fd->fd_base + FLD_SH_IN_BASE_ADDR_11);
+			writel(fd->fld_para->fld_step_pa[fld_step_leaf][12],
+			       fd->fd_base + FLD_SH_IN_BASE_ADDR_12);
+			writel(fd->fld_para->fld_step_pa[fld_step_leaf][13],
+			       fd->fd_base + FLD_SH_IN_BASE_ADDR_13);
+			writel(fd->fld_para->fld_step_pa[fld_step_leaf][14],
+			       fd->fd_base + FLD_SH_IN_BASE_ADDR_14);
+
+			writel(fd->fld_para->fld_step_pa[fld_step_km02][0],
+			       fd->fd_base + FLD_PL_IN_BASE_ADDR_0_0);
+			writel(fd->fld_para->fld_step_pa[fld_step_km02][1],
+			       fd->fd_base + FLD_PL_IN_BASE_ADDR_0_1);
+			writel(fd->fld_para->fld_step_pa[fld_step_km02][2],
+			       fd->fd_base + FLD_PL_IN_BASE_ADDR_0_2);
+			writel(fd->fld_para->fld_step_pa[fld_step_km02][3],
+			       fd->fd_base + FLD_PL_IN_BASE_ADDR_0_3);
+			writel(fd->fld_para->fld_step_pa[fld_step_km02][4],
+			       fd->fd_base + FLD_PL_IN_BASE_ADDR_0_4);
+			writel(fd->fld_para->fld_step_pa[fld_step_km02][5],
+			       fd->fd_base + FLD_PL_IN_BASE_ADDR_0_5);
+			writel(fd->fld_para->fld_step_pa[fld_step_km02][6],
+			       fd->fd_base + FLD_PL_IN_BASE_ADDR_0_6);
+			writel(fd->fld_para->fld_step_pa[fld_step_km02][7],
+			       fd->fd_base + FLD_PL_IN_BASE_ADDR_0_7);
+			writel(fd->fld_para->fld_step_pa[fld_step_km02][8],
+			       fd->fd_base + FLD_PL_IN_BASE_ADDR_0_8);
+			writel(fd->fld_para->fld_step_pa[fld_step_km02][9],
+			       fd->fd_base + FLD_PL_IN_BASE_ADDR_0_9);
+			writel(fd->fld_para->fld_step_pa[fld_step_km02][10],
+			       fd->fd_base + FLD_PL_IN_BASE_ADDR_0_10);
+			writel(fd->fld_para->fld_step_pa[fld_step_km02][11],
+			       fd->fd_base + FLD_PL_IN_BASE_ADDR_0_11);
+			writel(fd->fld_para->fld_step_pa[fld_step_km02][12],
+			       fd->fd_base + FLD_PL_IN_BASE_ADDR_0_12);
+			writel(fd->fld_para->fld_step_pa[fld_step_km02][13],
+			       fd->fd_base + FLD_PL_IN_BASE_ADDR_0_13);
+			writel(fd->fld_para->fld_step_pa[fld_step_km02][14],
+			       fd->fd_base + FLD_PL_IN_BASE_ADDR_0_14);
+
+			writel(fd->fld_para->fld_step_pa[fld_step_km13][0],
+			       fd->fd_base + FLD_PL_IN_BASE_ADDR_1_0);
+			writel(fd->fld_para->fld_step_pa[fld_step_km13][1],
+			       fd->fd_base + FLD_PL_IN_BASE_ADDR_1_1);
+			writel(fd->fld_para->fld_step_pa[fld_step_km13][2],
+			       fd->fd_base + FLD_PL_IN_BASE_ADDR_1_2);
+			writel(fd->fld_para->fld_step_pa[fld_step_km13][3],
+			       fd->fd_base + FLD_PL_IN_BASE_ADDR_1_3);
+			writel(fd->fld_para->fld_step_pa[fld_step_km13][4],
+			       fd->fd_base + FLD_PL_IN_BASE_ADDR_1_4);
+			writel(fd->fld_para->fld_step_pa[fld_step_km13][5],
+			       fd->fd_base + FLD_PL_IN_BASE_ADDR_1_5);
+			writel(fd->fld_para->fld_step_pa[fld_step_km13][6],
+			       fd->fd_base + FLD_PL_IN_BASE_ADDR_1_6);
+			writel(fd->fld_para->fld_step_pa[fld_step_km13][7],
+			       fd->fd_base + FLD_PL_IN_BASE_ADDR_1_7);
+			writel(fd->fld_para->fld_step_pa[fld_step_km13][8],
+			       fd->fd_base + FLD_PL_IN_BASE_ADDR_1_8);
+			writel(fd->fld_para->fld_step_pa[fld_step_km13][9],
+			       fd->fd_base + FLD_PL_IN_BASE_ADDR_1_9);
+			writel(fd->fld_para->fld_step_pa[fld_step_km13][10],
+			       fd->fd_base + FLD_PL_IN_BASE_ADDR_1_10);
+			writel(fd->fld_para->fld_step_pa[fld_step_km13][11],
+			       fd->fd_base + FLD_PL_IN_BASE_ADDR_1_11);
+			writel(fd->fld_para->fld_step_pa[fld_step_km13][12],
+			       fd->fd_base + FLD_PL_IN_BASE_ADDR_1_12);
+			writel(fd->fld_para->fld_step_pa[fld_step_km13][13],
+			       fd->fd_base + FLD_PL_IN_BASE_ADDR_1_13);
+			writel(fd->fld_para->fld_step_pa[fld_step_km13][14],
+			       fd->fd_base + FLD_PL_IN_BASE_ADDR_1_14);
+
+			/* */
+			writel(0x22222222, fd->fd_base + FLD_PL_IN_BASE_ADDR_0_0_7_MSB);
+			writel(0x02222222, fd->fd_base + FLD_PL_IN_BASE_ADDR_0_8_15_MSB);
+
+			writel(0x22222222, fd->fd_base + FLD_PL_IN_BASE_ADDR_1_0_7_MSB);
+			writel(0x02222222, fd->fd_base + FLD_PL_IN_BASE_ADDR_1_8_15_MSB);
+
+			writel(0x22222222, fd->fd_base + FLD_PL_IN_BASE_ADDR_2_0_7_MSB);
+			writel(0x02222222, fd->fd_base + FLD_PL_IN_BASE_ADDR_2_8_15_MSB);
+
+			writel(0x22222222, fd->fd_base + FLD_PL_IN_BASE_ADDR_3_0_7_MSB);
+			writel(0x02222222, fd->fd_base + FLD_PL_IN_BASE_ADDR_3_8_15_MSB);
+
+			writel(0x22222222, fd->fd_base + FLD_SH_IN_BASE_ADDR_0_7_MSB);
+			writel(0x02222222, fd->fd_base + FLD_SH_IN_BASE_ADDR_8_15_MSB);
+
+			writel(0x02000000, fd->fd_base + FLD_BS_IN_BASE_ADDR_8_15_MSB);
+
+			writel(0x22222222, fd->fd_base + FLD_BASE_ADDR_FACE_0_7_MSB);
+			writel(0x02222222, fd->fd_base + FLD_BASE_ADDR_FACE_8_14_MSB);
+			writel(0x00000002, fd->fd_base + FLD_TR_OUT_BASE_ADDR_0_MSB);
+			writel(0x00000002, fd->fd_base + FLD_PP_OUT_BASE_ADDR_0_MSB);
+
+			/*fld mode + trigger start*/
+			writel(0x11, fd->fd_base + AIE_START_REG);
+		}
+	}
+}
+
+void aie_execute_pose(struct mtk_aie_dev *fd)
+{
+	writel(0x00000100, fd->fd_base + AIE_ENABLE_REG);
+	writel(0x00000300, fd->fd_base + AIE_LOOP_REG);
+	writel(0x1, fd->fd_base + AIE_INT_EN_REG);
+	writel(fd->reg_cfg.fd_pose_adr, fd->fd_base + AIE_FD_CON_BASE_ADR_REG);
+	writel(0x1, fd->fd_base + AIE_START_REG);
+}
+
+void aie_irqhandle(struct mtk_aie_dev *fd)
+{
+	writel(0x0, fd->fd_base + AIE_START_REG);
+
+	/* interrupt read clear */
+	readl(fd->fd_base + AIE_INT_REG);
+}
+
+#if KERNEL_SPACE_RLT
+static u16 aie_get_hi16(unsigned int value) {
+	return (value & 0xFFFF0000) >> 16;
+}
+
+static u16 aie_get_lo16(unsigned int value) {
+	return value & 0xFFFF;
+}
+
+static signed short aie_refine_s16_value(signed short value) {
+  int16_t result = 0;
+
+  if ((value & 0x200) >> 9)
+    result = (value | 0xFE00);
+  else
+    result = value;
+
+  return result;
+}
+#endif
+
+/* return aie_cfg to user space */
+void aie_get_fd_result(struct mtk_aie_dev *fd, struct aie_enq_info *aie_cfg)
+{
+#if KERNEL_SPACE_RLT
+	void *fd_pym_result[PYM_NUM] = {NULL, NULL, NULL};
+	unsigned int* pto12 = NULL;
+	unsigned int i = 0, j = 0;
+    struct FDRESULT* prst = NULL;
+    signed short landmark = 0;
+#endif
+	u32 fd_result_hw = 0, fd_result_1_hw = 0;
+	u32 fd_total_num = 0;
+	u32 fd_pyramid_num[PYM_NUM] = {0,0,0};
+
+	aie_cfg->sel_mode = fd->base_para->sel_mode;
+	aie_cfg->rotate_degree = fd->base_para->rotate_degree;
+	aie_cfg->src_img_addr = fd->base_para->src_img_addr;
+	aie_cfg->src_img_addr_uv = fd->base_para->src_img_addr_uv;
+	aie_cfg->src_img_width = fd->base_para->img_width;
+	aie_cfg->src_img_height = fd->base_para->img_height;
+	aie_cfg->src_img_fmt = fd->base_para->src_img_fmt;
+	aie_cfg->fd_version = FD_VERSION;
+	aie_cfg->attr_version = ATTR_VERSION;
+
+	aie_cfg->irq_status = readl(fd->fd_base + AIE_INT_EN_REG);
+
+	fd_result_hw = fd->reg_cfg.hw_result;
+	fd_result_1_hw = fd->reg_cfg.hw_result1;
+	fd_total_num = fd_result_hw & 0xFFF;
+	fd_pyramid_num[0] = (fd_result_hw & 0xFFF0000) >> 16;
+	fd_pyramid_num[1] = fd_result_1_hw & 0xFFF;
+	fd_pyramid_num[2] = (fd_result_1_hw & 0xFFF0000) >> 16;
+
+	aie_cfg->fd_out.fd_total_num = fd_total_num;
+	aie_cfg->fd_out.fd_pyramid0_num = fd_pyramid_num[0];
+	aie_cfg->fd_out.fd_pyramid1_num = fd_pyramid_num[1];
+	aie_cfg->fd_out.fd_pyramid2_num = fd_pyramid_num[2];
+
+#if KERNEL_SPACE_RLT
+	switch (fd->aie_cfg->number_of_pyramid ) {
+	case 1:
+		fd_pym_result[2] = fd->dma_para->fd_out_hw_va[rpn0_loop_num][0];
+		break;
+	case 2:
+		fd_pym_result[1] = fd->dma_para->fd_out_hw_va[rpn0_loop_num][0];
+		fd_pym_result[2] = fd->dma_para->fd_out_hw_va[rpn1_loop_num][0];
+		break;
+	case 3:
+		fd_pym_result[0] = fd->dma_para->fd_out_hw_va[rpn0_loop_num][0];
+		fd_pym_result[1] = fd->dma_para->fd_out_hw_va[rpn1_loop_num][0];
+		fd_pym_result[2] = fd->dma_para->fd_out_hw_va[rpn2_loop_num][0];
+		break;
+	default:
+		dev_info(fd->dev, "Wrong number_of_pyramid\n");
+		break;
+	}
+
+	for (i = 0; i < 3; i++) {
+	  for (j = 0; j < fd_pyramid_num[i]; j++) {
+        if (i == 0)
+          prst = &aie_cfg->fd_out.PYRAMID0_RESULT;
+        else if (i == 1)
+          prst = &aie_cfg->fd_out.PYRAMID1_RESULT;
+        else if (i == 2)
+          prst = &aie_cfg->fd_out.PYRAMID2_RESULT;
+
+		pto12 = (unsigned int*)fd_pym_result[i] + 12 * j;
+
+        prst->anchor_x0[j] = aie_get_lo16(*(pto12 + 0));
+        prst->anchor_y0[j] = aie_get_hi16(*(pto12 + 0));
+        prst->anchor_x1[j] = aie_get_lo16(*(pto12 + 1));
+        prst->anchor_y1[j] = aie_get_hi16(*(pto12 + 1));
+
+		if(prst->anchor_x1[j] == 0 || prst->anchor_y1[j] == 0) {
+          dev_err(fd->dev,"wrong coordinate: i=%d j=%d M:%d %d %d %d\n",
+		  i,j,prst->anchor_x0[j],prst->anchor_x1[j],prst->anchor_y0[j],prst->anchor_y1[j]);
+          goto error_out;
+        }
+
+        /* ROP result at 1st run */
+        landmark = (*(pto12 + 2) & 0x3FF);
+        prst->rop_landmark_score0[j] = aie_refine_s16_value(landmark);
+        landmark = ((*(pto12 + 2) & 0xFFC00) >> 10);
+        prst->rop_landmark_score1[j] = aie_refine_s16_value(landmark);
+        landmark = ((*(pto12 + 2) & 0x3FF00000) >> 20);
+        prst->rop_landmark_score2[j] = aie_refine_s16_value(landmark);
+
+        prst->anchor_score[j] = aie_refine_s16_value(*(pto12 + 9) & 0x3FF);
+
+        /* RIP result at 1st run */
+        landmark = ((*(pto12 + 9) & 0xFFC00) >> 10);
+        prst->rip_landmark_score0[j] = aie_refine_s16_value(landmark);
+        landmark = ((*(pto12 + 9) & 0x3FF00000) >> 20);
+        prst->rip_landmark_score1[j] = aie_refine_s16_value(landmark);
+        landmark =
+            ((*(pto12 + 9) & 0xC0000000) >> 30) | ((*(pto12 + 10) & 0xFF) << 2);
+        prst->rip_landmark_score2[j] = aie_refine_s16_value(landmark);
+        landmark = ((*(pto12 + 10) & 0x3FF00) >> 8);
+        prst->rip_landmark_score3[j] = aie_refine_s16_value(landmark);
+        landmark = ((*(pto12 + 10) & 0xFFC0000) >> 18);
+        prst->rip_landmark_score4[j] = aie_refine_s16_value(landmark);
+        landmark = ((*(pto12 + 10) & 0xF0000000) >> 28) |
+                   ((*(pto12 + 11) & 0x3F) << 4);
+        prst->rip_landmark_score5[j] = aie_refine_s16_value(landmark);
+        landmark = ((*(pto12 + 11) & 0xFFC0) >> 6);
+        prst->rip_landmark_score6[j] = aie_refine_s16_value(landmark);
+        prst->face_result_index[j] = ((*(pto12 + 11) & 0xFFF0000) >> 16);
+        prst->anchor_index[j] = ((*(pto12 + 11) & 0x70000000) >> 28);
+
+        prst->fd_partial_result = fd_pyramid_num[i];
+	  }
+	}
+error_out:
+	return;
+#else
+	memcpy(aie_cfg->fd_out.rpn31_rlt,
+	       fd->dma_para->fd_out_hw_va[rpn2_loop_num][0],
+	       sizeof(aie_cfg->fd_out.rpn31_rlt));
+	memcpy(aie_cfg->fd_out.rpn63_rlt,
+	       fd->dma_para->fd_out_hw_va[rpn1_loop_num][0],
+	       sizeof(aie_cfg->fd_out.rpn63_rlt));
+	memcpy(aie_cfg->fd_out.rpn95_rlt,
+	       fd->dma_para->fd_out_hw_va[rpn0_loop_num][0],
+	       sizeof(aie_cfg->fd_out.rpn95_rlt));
+#endif
+
+}
+
+void aie_get_attr_result(struct mtk_aie_dev *fd, struct aie_enq_info *aie_cfg)
+{
+	u32 *attr_race_result = NULL, *attr_gender_result = NULL;
+	u32 *attr_age_result = NULL, *attr_isIndian_result = NULL;
+
+	aie_cfg->sel_mode = fd->attr_para->sel_mode[fd->attr_para->r_idx];
+	aie_cfg->rotate_degree =
+		fd->attr_para->rotate_degree[fd->attr_para->r_idx];
+	aie_cfg->src_img_addr =
+		fd->attr_para->src_img_addr[fd->attr_para->r_idx];
+	aie_cfg->src_img_addr_uv =
+		fd->attr_para->src_img_addr_uv[fd->attr_para->r_idx];
+	aie_cfg->src_img_width = fd->attr_para->img_width[fd->attr_para->r_idx];
+	aie_cfg->src_img_height =
+		fd->attr_para->img_height[fd->attr_para->r_idx];
+	aie_cfg->src_img_fmt = fd->attr_para->src_img_fmt[fd->attr_para->r_idx];
+	aie_cfg->fd_version = FD_VERSION;
+	aie_cfg->attr_version = ATTR_VERSION;
+
+	aie_cfg->irq_status = readl(fd->fd_base + AIE_INT_EN_REG);
+
+	/* 64 feature * 32 bytes */
+	attr_age_result =
+		(u32 *)fd->dma_para->age_out_hw_va[fd->attr_para->r_idx];
+	attr_gender_result =
+		(u32 *)fd->dma_para->gender_out_hw_va[fd->attr_para->r_idx];
+	attr_isIndian_result =
+		(u32 *)fd->dma_para->isIndian_out_hw_va[fd->attr_para->r_idx];
+	attr_race_result =
+		(u32 *)fd->dma_para->race_out_hw_va[fd->attr_para->r_idx];
+#if KERNEL_SPACE_RLT
+    aie_cfg->attr_out.MERGED_AGE_RESULT.RESULT[0] =
+        aie_get_lo16(*attr_age_result);
+    aie_cfg->attr_out.MERGED_AGE_RESULT.RESULT[1] =
+        aie_get_hi16(*attr_age_result);
+
+    aie_cfg->attr_out.MERGED_GENDER_RESULT.RESULT[0] =
+        aie_get_lo16(*attr_gender_result);
+    aie_cfg->attr_out.MERGED_GENDER_RESULT.RESULT[1] =
+        aie_get_hi16(*attr_gender_result);
+
+    aie_cfg->attr_out.MERGED_IS_INDIAN_RESULT.RESULT[0] =
+        aie_get_lo16(*attr_isIndian_result);
+    aie_cfg->attr_out.MERGED_IS_INDIAN_RESULT.RESULT[1] =
+        aie_get_hi16(*attr_isIndian_result);
+
+    aie_cfg->attr_out.MERGED_RACE_RESULT.RESULT[0] =
+        aie_get_lo16(*attr_race_result);
+    aie_cfg->attr_out.MERGED_RACE_RESULT.RESULT[1] =
+        aie_get_hi16(*attr_race_result);
+    aie_cfg->attr_out.MERGED_RACE_RESULT.RESULT[2] =
+        aie_get_lo16(*(attr_race_result + 1));
+#else
+	memcpy(aie_cfg->attr_out.rpn17_rlt, attr_age_result,
+	       sizeof(aie_cfg->attr_out.rpn17_rlt));
+	memcpy(aie_cfg->attr_out.rpn20_rlt, attr_gender_result,
+	       sizeof(aie_cfg->attr_out.rpn20_rlt));
+	memcpy(aie_cfg->attr_out.rpn22_rlt, attr_isIndian_result,
+	       sizeof(aie_cfg->attr_out.rpn22_rlt));
+	memcpy(aie_cfg->attr_out.rpn25_rlt, attr_race_result,
+	       sizeof(aie_cfg->attr_out.rpn25_rlt));
+#endif
+	fd->attr_para->r_idx = (fd->attr_para->r_idx + 1) % MAX_ENQUE_FRAME_NUM;
+}
+
+void aie_get_fld_result(struct mtk_aie_dev *fd, struct aie_enq_info *aie_cfg)
+{
+#if KERNEL_SPACE_RLT
+    int i = 0, j = 0;
+	u16 *out_parsing = NULL;
+    u8 fld_rlt[fld_max_frame][fld_output_size];
+#endif
+	aie_cfg->irq_status = readl(fd->fd_base + AIE_INT_EN_REG);
+#if KERNEL_SPACE_RLT
+	memcpy(fld_rlt,
+	       fd->fld_para->fld_output_va[0],
+	       sizeof(fld_rlt));
+
+    for (j = 0; j < aie_cfg->fld_face_num; j++) {
+
+	  out_parsing = (unsigned short *)&fld_rlt[j][0];
+      for (i = 0; i < FLD_CUR_LANDMARK; i++) {
+        aie_cfg->fld_out[j].fld_landmark[i].x = *out_parsing;
+        aie_cfg->fld_out[j].fld_landmark[i].y = *(out_parsing + 1);
+
+        if (i % 2)
+          out_parsing = out_parsing + 6;
+        else
+          out_parsing = out_parsing + 2;
+      }
+	  out_parsing = (unsigned short *)&fld_rlt[j][0];
+      if (FLD_CUR_LANDMARK % 2)
+        out_parsing = out_parsing + ((FLD_CUR_LANDMARK + 1) / 2) * 8;
+      else
+        out_parsing = out_parsing + (FLD_CUR_LANDMARK / 2) * 8;
+
+      aie_cfg->fld_out[j].fld_out_rop = *out_parsing;
+      aie_cfg->fld_out[j].fld_out_rip = *(out_parsing + 1);
+      aie_cfg->fld_out[j].confidence = *(out_parsing + 2);
+      aie_cfg->fld_out[j].blinkscore = *(out_parsing + 3);
+    }
+#else
+	memcpy(aie_cfg->fld_out.fld_rlt,
+	       fd->fld_para->fld_output_va[0],
+	       sizeof(aie_cfg->fld_out.fld_rlt));
+#endif
+}
+
diff --git a/drivers/media/platform/mediatek/isp/Kconfig b/drivers/media/platform/mediatek/isp/Kconfig
new file mode 100644
index 0000000000000000000000000000000000000000..42ba69521519c20abfbf3621404f781534afad90
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/Kconfig
@@ -0,0 +1,122 @@
+config VIDEO_MEDIATEK_ISP_PASS1
+	tristate "Mediatek ISP Pass 1 driver"
+	depends on VIDEO_V4L2
+	depends on ARCH_MEDIATEK
+	depends on REMOTEPROC
+	select V4L2_FWNODE
+	select VIDEO_V4L2_SUBDEV_API
+	select VIDEOBUF2_VMALLOC
+	select VIDEOBUF2_DMA_CONTIG
+	select MTK_SCP
+	default n
+	help
+		Pass 1 driver controls 3A (auto-focus, exposure,
+		and white balance) with tuning feature and outputs
+		the captured image buffers in Mediatek's camera system.
+
+		Choose y if you want to use Mediatek SoCs to create image
+		captured application such as video recording and still image
+		capturing.
+
+config VIDEO_MEDIATEK_ISP_DIP
+	tristate "Mediatek Digital Image Processing function"
+	select MTK_SCP
+	depends on VIDEO_MEDIATEK_MDP3
+	depends on REMOTEPROC
+	select VIDEO_V4L2_SUBDEV_API
+	select VIDEOBUF2_DMA_CONTIG
+	select VIDEOBUF2_CORE
+	select VIDEOBUF2_V4L2
+	select VIDEOBUF2_MEMOPS
+	select MEDIA_CONTROLLER
+
+	default n
+	help
+	    Support the basic Digital Image Processing (DIP) driver.
+
+	    DIP driver provides image format conversion, resizing,
+	    and rotation function through the low power hardware.
+	    DIP also supports multiple output feature. It can
+	    generate two or more output image with different effect
+	    based on a single input image at the same time.
+
+config MTK_SENINF
+	tristate "Mediatek mipi csi2 driver"
+	depends on VIDEO_V4L2 && VIDEO_V4L2_SUBDEV_API
+	depends on MEDIA_CAMERA_SUPPORT
+	select V4L2_FWNODE
+
+	default n
+	help
+	    This driver provides a mipi-csi2 host driver used as a
+	    interface to connect camera with Mediatek's
+	    MT8183 SOCs. It is able to handle multiple cameras
+	    at the same time.
+
+	    Choose y if you want to use Mediatek SoCs to create image
+	    capture application such as video recording and still image
+	    capture.
+
+config VIDEO_MTK_ISP_70_CAMSYS
+	tristate "Mediatek ISP 7.0 camsys driver"
+	depends on ARCH_MEDIATEK
+	select V4L2_FWNODE
+	select VIDEO_V4L2_SUBDEV_API
+	select VIDEOBUF2_VMALLOC
+	select VIDEOBUF2_DMA_CONTIG
+	select RPMSG_MTK_CCD
+	select MTKCCD_REMOTEPROC
+	select MTK_SCP
+
+	default n
+	help
+		Camsys driver controls 3A (auto-focus, exposure,
+		and white balance) with tuning feature and outputs
+		the captured image buffers in Mediatek's ISP7 system.
+
+		Choose y if you want to use Mediatek SoCs to create image
+		captured application such as video recording and still image
+		capturing.
+
+config VIDEO_MTK_ISP_71_CAMSYS
+	tristate "Mediatek ISP 7.1 camsys driver"
+	depends on ARCH_MEDIATEK
+	select V4L2_FWNODE
+	select VIDEO_V4L2_SUBDEV_API
+	select VIDEOBUF2_VMALLOC
+	select VIDEOBUF2_DMA_CONTIG
+	select RPMSG_MTK_CCD
+	select MTKCCD_REMOTEPROC
+	select MTK_SCP
+
+	default n
+	help
+		Camsys driver controls 3A (auto-focus, exposure,
+		and white balance) with tuning feature and outputs
+		the captured image buffers in Mediatek's ISP7 system.
+
+		Choose y if you want to use Mediatek SoCs to create image
+		captured application such as video recording and still image
+		capturing.
+
+config VIDEO_MTK_ISP_71_IMGSYS
+	tristate "Mediatek ISP70 image processing system function"
+	depends on MTK_CMDQ
+	depends on REMOTEPROC
+	select VIDEO_V4L2_SUBDEV_API
+	select VIDEOBUF2_DMA_CONTIG
+	select VIDEOBUF2_CORE
+	select VIDEOBUF2_V4L2
+	select VIDEOBUF2_MEMOPS
+	select MEDIA_CONTROLLER
+
+	default n
+	help
+	    Support the basic Image processing system driver.
+
+	    IMGSYS driver provides image format conversion, resizing,
+	    and rotation function through the low power hardware.
+	    IMGSYS also supports multiple output feature. It can
+	    generate two or more output image with different effect
+	    based on a single input image at the same time.
+
diff --git a/drivers/media/platform/mediatek/isp/common/mtk_cam-fmt.h b/drivers/media/platform/mediatek/isp/common/mtk_cam-fmt.h
new file mode 100644
index 0000000000000000000000000000000000000000..2eb54a2332ef3b8b13da1d2810e92a9549ea0b3c
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/common/mtk_cam-fmt.h
@@ -0,0 +1,87 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2022 MediaTek Inc.
+ */
+
+#ifndef __MTKCAM_FMT_H
+#define __MTKCAM_FMT_H
+
+/* camsys supported format */
+enum mtkcam_ipi_fmt {
+	MTKCAM_IPI_IMG_FMT_UNKNOWN		= -1,
+	MTKCAM_IPI_IMG_FMT_BAYER8		= 0,
+	MTKCAM_IPI_IMG_FMT_BAYER10		= 1,
+	MTKCAM_IPI_IMG_FMT_BAYER12		= 2,
+	MTKCAM_IPI_IMG_FMT_BAYER14		= 3,
+	MTKCAM_IPI_IMG_FMT_BAYER16		= 4,
+	MTKCAM_IPI_IMG_FMT_BAYER10_UNPACKED	= 5,
+	MTKCAM_IPI_IMG_FMT_BAYER12_UNPACKED	= 6,
+	MTKCAM_IPI_IMG_FMT_BAYER14_UNPACKED	= 7,
+	MTKCAM_IPI_IMG_FMT_RGB565		= 8,
+	MTKCAM_IPI_IMG_FMT_RGB888		= 9,
+	MTKCAM_IPI_IMG_FMT_JPEG			= 10,
+	MTKCAM_IPI_IMG_FMT_FG_BAYER8		= 11,
+	MTKCAM_IPI_IMG_FMT_FG_BAYER10		= 12,
+	MTKCAM_IPI_IMG_FMT_FG_BAYER12		= 13,
+	MTKCAM_IPI_IMG_FMT_FG_BAYER14		= 14,
+	MTKCAM_IPI_IMG_FMT_YUYV			= 15,
+	MTKCAM_IPI_IMG_FMT_YVYU			= 16,
+	MTKCAM_IPI_IMG_FMT_UYVY			= 17,
+	MTKCAM_IPI_IMG_FMT_VYUY			= 18,
+	MTKCAM_IPI_IMG_FMT_YUV_422_2P		= 19,
+	MTKCAM_IPI_IMG_FMT_YVU_422_2P		= 20,
+	MTKCAM_IPI_IMG_FMT_YUV_422_3P		= 21,
+	MTKCAM_IPI_IMG_FMT_YVU_422_3P		= 22,
+	MTKCAM_IPI_IMG_FMT_YUV_420_2P		= 23,
+	MTKCAM_IPI_IMG_FMT_YVU_420_2P		= 24,
+	MTKCAM_IPI_IMG_FMT_YUV_420_3P		= 25,
+	MTKCAM_IPI_IMG_FMT_YVU_420_3P		= 26,
+	MTKCAM_IPI_IMG_FMT_Y8			= 27,
+	MTKCAM_IPI_IMG_FMT_YUYV_Y210		= 28,
+	MTKCAM_IPI_IMG_FMT_YVYU_Y210		= 29,
+	MTKCAM_IPI_IMG_FMT_UYVY_Y210		= 30,
+	MTKCAM_IPI_IMG_FMT_VYUY_Y210		= 31,
+	MTKCAM_IPI_IMG_FMT_YUYV_Y210_PACKED	= 32,
+	MTKCAM_IPI_IMG_FMT_YVYU_Y210_PACKED	= 33,
+	MTKCAM_IPI_IMG_FMT_UYVY_Y210_PACKED	= 34,
+	MTKCAM_IPI_IMG_FMT_VYUY_Y210_PACKED	= 35,
+	MTKCAM_IPI_IMG_FMT_YUV_P210		= 36,
+	MTKCAM_IPI_IMG_FMT_YVU_P210		= 37,
+	MTKCAM_IPI_IMG_FMT_YUV_P010		= 38,
+	MTKCAM_IPI_IMG_FMT_YVU_P010		= 39,
+	MTKCAM_IPI_IMG_FMT_YUV_P210_PACKED	= 40,
+	MTKCAM_IPI_IMG_FMT_YVU_P210_PACKED	= 41,
+	MTKCAM_IPI_IMG_FMT_YUV_P010_PACKED	= 42,
+	MTKCAM_IPI_IMG_FMT_YVU_P010_PACKED	= 43,
+	MTKCAM_IPI_IMG_FMT_YUV_P212		= 44,
+	MTKCAM_IPI_IMG_FMT_YVU_P212		= 45,
+	MTKCAM_IPI_IMG_FMT_YUV_P012		= 46,
+	MTKCAM_IPI_IMG_FMT_YVU_P012		= 47,
+	MTKCAM_IPI_IMG_FMT_YUV_P212_PACKED	= 48,
+	MTKCAM_IPI_IMG_FMT_YVU_P212_PACKED	= 49,
+	MTKCAM_IPI_IMG_FMT_YUV_P012_PACKED	= 50,
+	MTKCAM_IPI_IMG_FMT_YVU_P012_PACKED	= 51,
+	MTKCAM_IPI_IMG_FMT_RGB_8B_3P		= 52,
+	MTKCAM_IPI_IMG_FMT_RGB_10B_3P		= 53,
+	MTKCAM_IPI_IMG_FMT_RGB_12B_3P		= 54,
+	MTKCAM_IPI_IMG_FMT_RGB_10B_3P_PACKED	= 55,
+	MTKCAM_IPI_IMG_FMT_RGB_12B_3P_PACKED	= 56,
+	MTKCAM_IPI_IMG_FMT_FG_BAYER8_3P		= 57,
+	MTKCAM_IPI_IMG_FMT_FG_BAYER10_3P	= 58,
+	MTKCAM_IPI_IMG_FMT_FG_BAYER12_3P	= 59,
+	MTKCAM_IPI_IMG_FMT_FG_BAYER10_3P_PACKED	= 60,
+	MTKCAM_IPI_IMG_FMT_FG_BAYER12_3P_PACKED	= 61,
+	MTKCAM_IPI_IMG_FMT_UFBC_NV12		= 62,
+	MTKCAM_IPI_IMG_FMT_UFBC_NV21		= 63,
+	MTKCAM_IPI_IMG_FMT_UFBC_YUV_P010	= 64,
+	MTKCAM_IPI_IMG_FMT_UFBC_YVU_P010	= 65,
+	MTKCAM_IPI_IMG_FMT_UFBC_YUV_P012	= 66,
+	MTKCAM_IPI_IMG_FMT_UFBC_YVU_P012	= 67,
+	MTKCAM_IPI_IMG_FMT_UFBC_BAYER8		= 68,
+	MTKCAM_IPI_IMG_FMT_UFBC_BAYER10		= 69,
+	MTKCAM_IPI_IMG_FMT_UFBC_BAYER12		= 70,
+	MTKCAM_IPI_IMG_FMT_UFBC_BAYER14		= 71,
+	MTKCAM_IPI_IMG_FMT_BAYER10_MIPI		= 72
+};
+
+#endif /* __MTKCAM_FMT_H */
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/Makefile b/drivers/media/platform/mediatek/isp/isp_7x/Makefile
new file mode 100644
index 0000000000000000000000000000000000000000..cde66df9948deba5c1d1bb39bb5ee7f14d06339e
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/Makefile
@@ -0,0 +1,19 @@
+# SPDX-License-Identifier: GPL-2.0
+
+subdir-ccflags-y += -Werror
+
+subdir-ccflags-$(CONFIG_VIDEO_MTK_ISP_70_CAMSYS) += -DISP7_0
+subdir-ccflags-$(CONFIG_VIDEO_MTK_ISP_71_CAMSYS) += -DISP7_1
+
+obj-$(CONFIG_VIDEO_MTK_ISP_70_CAMSYS) += camsys/
+obj-$(CONFIG_VIDEO_MTK_ISP_71_CAMSYS) += camsys/
+
+subdir-ccflags-$(CONFIG_VIDEO_MTK_ISP_71_IMGSYS) += -DIMGSYS_VER_ISP71
+subdir-ccflags-$(CONFIG_VIDEO_MTK_ISP_71_IMGSYS) += -DIMGSYS_WPE_NUM=2
+subdir-ccflags-$(CONFIG_VIDEO_MTK_ISP_71_IMGSYS) += -DIMGSYS_TRAW_NUM=2
+
+obj-$(CONFIG_VIDEO_MTK_ISP_71_IMGSYS) += imgsys/
+obj-$(CONFIG_VIDEO_MTK_ISP_71_IMGSYS) += mtk-hcp/
+obj-$(CONFIG_VIDEO_MTK_ISP_71_IMGSYS) += mtk-ipesys-me/
+
+
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/camsys/Makefile b/drivers/media/platform/mediatek/isp/isp_7x/camsys/Makefile
new file mode 100644
index 0000000000000000000000000000000000000000..fa49e4d90634c11a09ba021fc2ec6a8902a36d78
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/camsys/Makefile
@@ -0,0 +1,7 @@
+# SPDX-License-Identifier: GPL-2.0
+
+obj-y += src/
+
+# enable with unit_test
+#KBUILD_CFLAGS += -Wframe-larger-than=26384
+#obj-y += unit_test/
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/Makefile b/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/Makefile
new file mode 100644
index 0000000000000000000000000000000000000000..0d051fb121a8c52e78c101e9be203c5645d49db4
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/Makefile
@@ -0,0 +1,28 @@
+# SPDX-License-Identifier: GPL-2.0-only
+
+ccflags-y += -I$(srctree)/drivers/media/platform/mediatek/isp/isp_7x \
+	     -I$(srctree)/drivers/media/platform/mediatek/isp \
+	     -I$(srctree)/drivers/misc/mediatek/imgsensor/src-v4l2/frame-sync/ \
+	     -I$(srctree)/drivers/misc/mediatek/imgsensor/inc/
+
+mtk-cam-isp-objs := mtk_cam.o mtk_cam-raw.o mtk_cam-pool.o mtk_cam_pm.o \
+		    mtk_cam-video.o mtk_cam-ctrl.o \
+		    mtk_cam-seninf-route.o mtk_cam-seninf-drv.o \
+		    mtk_cam-debug.o \
+		    mtk_cam-sv.o \
+		    mtk_cam-raw_debug.o \
+		    mtk_cam-feature.o mtk_cam-timesync.o mtk_cam_vb2-dma-contig.o
+
+mtk-cam-plat-util-objs :=  mtk_cam-plat-util.o
+
+include $(src)/mtk_csi_phy_2_0/sub_drv.mk
+
+ifeq ($(CONFIG_VIDEO_MTK_ISP_71_CAMSYS),y)
+	mtk-cam-plat-impl-objs :=  mtk_cam-plat-mt8188.o
+else
+	mtk-cam-plat-impl-objs :=  mtk_cam-plat-mt8195.o
+endif
+
+obj-y += mtk-cam-plat-impl.o
+obj-y += mtk-cam-plat-util.o
+obj-y += mtk-cam-isp.o
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/imgsensor-user.h b/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/imgsensor-user.h
new file mode 100644
index 0000000000000000000000000000000000000000..5f06fdf10dd4b44da2cfe37d61127fb0b2decef3
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/imgsensor-user.h
@@ -0,0 +1,102 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright (c) 2020 MediaTek Inc. */
+
+#ifndef __IMGSENSOR_USER_H__
+#define __IMGSENSOR_USER_H__
+
+#include "kd_imgsensor_define_v4l2.h"
+
+enum {
+	PAD_SINK = 0,
+	PAD_SRC_RAW0,
+	PAD_SRC_RAW1,
+	PAD_SRC_RAW2,
+	PAD_SRC_RAW_W0,
+	PAD_SRC_RAW_EXT0,
+	PAD_SRC_PDAF0,
+	PAD_SRC_PDAF1,
+	PAD_SRC_PDAF2,
+	PAD_SRC_PDAF3,
+	PAD_SRC_PDAF4,
+	PAD_SRC_PDAF5,
+	PAD_SRC_PDAF6,
+	PAD_SRC_HDR0,
+	PAD_SRC_HDR1,
+	PAD_SRC_HDR2,
+	PAD_SRC_GENERAL0,
+	PAD_MAXCNT,
+	PAD_ERR = 0xffff,
+};
+
+struct mtk_hdr_exposure {
+	union {
+		struct {
+			__u32 le_exposure;
+			__u32 me_exposure;
+			__u32 se_exposure;
+			__u32 sse_exposure;
+			__u32 ssse_exposure;
+		};
+		__u32 arr[IMGSENSOR_STAGGER_EXPOSURE_CNT];
+	};
+};
+
+struct mtk_hdr_gain {
+	union {
+		struct {
+			__u32 le_gain;
+			__u32 me_gain;
+			__u32 se_gain;
+			__u32 sse_gain;
+			__u32 ssse_gain;
+		};
+		__u32 arr[IMGSENSOR_STAGGER_EXPOSURE_CNT];
+	};
+};
+
+struct mtk_hdr_ae {
+	struct mtk_hdr_exposure exposure;
+	struct mtk_hdr_gain gain;
+	__u32 actions;
+	__u32 subsample_tags;
+};
+
+struct mtk_mbus_frame_desc_entry_csi2 {
+	u8 channel;
+	u8 data_type;
+	u8 enable;
+	u16 hsize;
+	u16 vsize;
+	u16 user_data_desc;
+};
+
+struct mtk_mbus_frame_desc_entry {
+	//enum v4l2_mbus_frame_desc_flags flags;
+	//u32 pixelcode;
+	//u32 length;
+	union {
+		struct mtk_mbus_frame_desc_entry_csi2 csi2;
+	} bus;
+};
+#define MTK_FRAME_DESC_ENTRY_MAX 8
+
+enum mtk_mbus_frame_desc_type {
+	MTK_MBUS_FRAME_DESC_TYPE_PLATFORM,
+	MTK_MBUS_FRAME_DESC_TYPE_PARALLEL,
+	MTK_MBUS_FRAME_DESC_TYPE_CCP2,
+	MTK_MBUS_FRAME_DESC_TYPE_CSI2,
+};
+
+struct mtk_mbus_frame_desc {
+	enum mtk_mbus_frame_desc_type type;
+	struct mtk_mbus_frame_desc_entry entry[MTK_FRAME_DESC_ENTRY_MAX];
+	unsigned short num_entries;
+};
+
+struct mtk_csi_param {
+	__u8 dphy_trail;
+	__u8 dphy_data_settle;
+	__u8 dphy_clk_settle;
+	__u8 cphy_settle;
+};
+#endif
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/kd_imgsensor_define_v4l2.h b/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/kd_imgsensor_define_v4l2.h
new file mode 100644
index 0000000000000000000000000000000000000000..e205f2e69a94d4085f2da4ff58b3b2ad404f14c5
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/kd_imgsensor_define_v4l2.h
@@ -0,0 +1,75 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2019 MediaTek Inc.
+ */
+
+#ifndef _KD_IMGSENSOR_DATA_V4L2_H
+#define _KD_IMGSENSOR_DATA_V4L2_H
+
+enum VC_FEATURE {
+	VC_NONE = 0,
+	VC_MIN_NUM,
+	VC_RAW_DATA = VC_MIN_NUM,
+	VC_RAW_DATA_MAX,
+
+	VC_PDAF_MIN_NUM = VC_RAW_DATA_MAX,
+	VC_PDAF_STATS = VC_PDAF_MIN_NUM,
+	VC_PDAF_STATS_NE,
+	VC_PDAF_STATS_ME,
+	VC_PDAF_STATS_SE,
+	VC_PDAF_STATS_PIX_1,
+	VC_PDAF_STATS_PIX_2,
+	VC_PDAF_STATS_NE_PIX_1 = VC_PDAF_STATS_PIX_1,
+	VC_PDAF_STATS_NE_PIX_2 = VC_PDAF_STATS_PIX_2,
+	VC_PDAF_STATS_ME_PIX_1,
+	VC_PDAF_STATS_ME_PIX_2,
+	VC_PDAF_STATS_SE_PIX_1,
+	VC_PDAF_STATS_SE_PIX_2,
+	VC_PDAF_MAX_NUM,
+
+	VC_HDR_MIN_NUM = VC_PDAF_MAX_NUM,
+	VC_HDR_MVHDR = VC_HDR_MIN_NUM,
+	VC_HDR_MAX_NUM,
+
+	VC_3HDR_MIN_NUM = VC_HDR_MAX_NUM,
+	VC_3HDR_EMBEDDED = VC_3HDR_MIN_NUM,
+	VC_3HDR_FLICKER,
+	VC_3HDR_Y,
+	VC_3HDR_AE,
+	VC_3HDR_MAX_NUM,
+
+	VC_STAGGER_MIN_NUM = VC_3HDR_MAX_NUM,
+	VC_STAGGER_EMBEDDED = VC_STAGGER_MIN_NUM,
+	VC_STAGGER_NE,//9
+	VC_STAGGER_ME,//10
+	VC_STAGGER_SE,//11
+	VC_STAGGER_MAX_NUM,
+
+	VC_YUV_MIN_NUM = VC_STAGGER_MAX_NUM,
+	VC_YUV_Y = VC_YUV_MIN_NUM,
+	VC_YUV_UV,
+	VC_YUV_MAX_NUM,
+
+	VC_RAW_EXT_MIN_NUM = VC_YUV_MAX_NUM,
+	VC_RAW_W_DATA = VC_RAW_EXT_MIN_NUM,
+	VC_RAW_PROCESSED_DATA,
+	VC_RAW_EXT_MAX_NUM,
+
+	VC_GENERAL_DATA_MIN_NUM = VC_RAW_EXT_MAX_NUM,
+	VC_GENERAL_EMBEDDED = VC_GENERAL_DATA_MIN_NUM,
+	VC_GENERAL_DATA_MAX_NUM,
+
+	VC_MAX_NUM = VC_GENERAL_DATA_MAX_NUM,
+};
+
+// from longest for shortest exposure
+enum IMGSENSOR_STAGGER_EXPOSURE {
+	IMGSENSOR_STAGGER_EXPOSURE_LE,
+	IMGSENSOR_STAGGER_EXPOSURE_ME,
+	IMGSENSOR_STAGGER_EXPOSURE_SE,
+	IMGSENSOR_STAGGER_EXPOSURE_SSE,
+	IMGSENSOR_STAGGER_EXPOSURE_SSSE,
+	IMGSENSOR_STAGGER_EXPOSURE_CNT,
+};
+
+#endif              /* _KD_IMGSENSOR_DATA_H */
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam-ctrl.c b/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam-ctrl.c
new file mode 100755
index 0000000000000000000000000000000000000000..30eb17fdc112582d37284c51e6d7752ce38ed2f1
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam-ctrl.c
@@ -0,0 +1,4292 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2022 MediaTek Inc.
+ */
+
+#include <linux/list.h>
+#include <linux/of.h>
+#include <linux/videodev2.h>
+
+#include <media/v4l2-event.h>
+#include <media/v4l2-subdev.h>
+
+#include "mtk_cam.h"
+#include "mtk_cam-feature.h"
+#include "mtk_cam-ctrl.h"
+#include "mtk_cam-debug.h"
+#include "mtk_cam-pool.h"
+#include "mtk_cam-raw.h"
+#ifdef ISP7_1
+#include "mtk_cam-regs-mt8188.h"
+#include "mtk_cam-sv-regs-mt8188.h"
+#else
+#include "mtk_cam-regs-mt8195.h"
+#include "mtk_cam-sv-regs-mt8195.h"
+#endif
+#include "mtk_camera-v4l2-controls.h"
+
+#define SENSOR_SET_DEADLINE_MS  18
+#define SENSOR_SET_RESERVED_MS  7
+#define SENSOR_SET_DEADLINE_MS_60FPS  6
+#define SENSOR_SET_RESERVED_MS_60FPS  6
+#define SENSOR_SET_STAGGER_DEADLINE_MS  23
+#define SENSOR_SET_STAGGER_RESERVED_MS  6
+/*stagger sensor stability option for camsys*/
+#define STAGGER_CQ_LAST_SOF 1
+#define STAGGER_DYNAMIC_SWITCH 1
+#define STATE_NUM_AT_SOF 3
+#define INITIAL_DROP_FRAME_CNT 1
+
+enum MTK_CAMSYS_STATE_RESULT {
+	STATE_RESULT_TRIGGER_CQ = 0,
+	STATE_RESULT_PASS_CQ_INIT,
+	STATE_RESULT_PASS_CQ_SW_DELAY,
+	STATE_RESULT_PASS_CQ_SCQ_DELAY,
+	STATE_RESULT_PASS_CQ_HW_DELAY,
+};
+
+void state_transition(struct mtk_camsys_ctrl_state *state_entry,
+			     enum MTK_CAMSYS_STATE_IDX from,
+			     enum MTK_CAMSYS_STATE_IDX to)
+{
+	if (state_entry->estate == from)
+		state_entry->estate = to;
+}
+
+static void mtk_cam_event_eos(struct mtk_raw_pipeline *pipeline)
+{
+	struct v4l2_event event = {
+		.type = V4L2_EVENT_EOS,
+	};
+	v4l2_event_queue(pipeline->subdev.devnode, &event);
+}
+
+static void mtk_cam_event_frame_sync(struct mtk_raw_pipeline *pipeline,
+				     unsigned int frame_seq_no)
+{
+	struct v4l2_event event = {
+		.type = V4L2_EVENT_FRAME_SYNC,
+		.u.frame_sync.frame_sequence = frame_seq_no,
+	};
+	v4l2_event_queue(pipeline->subdev.devnode, &event);
+}
+
+static void mtk_cam_sv_event_frame_sync(struct mtk_camsv_device *camsv_dev,
+				unsigned int frame_seq_no)
+{
+	struct v4l2_event event = {
+		.type = V4L2_EVENT_FRAME_SYNC,
+		.u.frame_sync.frame_sequence = frame_seq_no,
+	};
+	v4l2_event_queue(camsv_dev->pipeline->subdev.devnode, &event);
+}
+
+static void mtk_cam_event_request_drained(struct mtk_raw_pipeline *pipeline)
+{
+	struct v4l2_event event = {
+		.type = V4L2_EVENT_REQUEST_DRAINED,
+	};
+	v4l2_event_queue(pipeline->subdev.devnode, &event);
+}
+
+static void mtk_cam_sv_event_request_drained(struct mtk_camsv_device *camsv_dev)
+{
+	struct v4l2_event event = {
+		.type = V4L2_EVENT_REQUEST_DRAINED,
+	};
+	v4l2_event_queue(camsv_dev->pipeline->subdev.devnode, &event);
+}
+
+static bool mtk_cam_request_drained(struct mtk_camsys_sensor_ctrl *sensor_ctrl)
+{
+	struct mtk_cam_ctx *ctx = sensor_ctrl->ctx;
+	int sensor_seq_no_next =
+		atomic_read(&sensor_ctrl->sensor_request_seq_no) + 1;
+	int res = 0;
+
+	if (mtk_cam_is_subsample(ctx))
+		sensor_seq_no_next =
+			atomic_read(&ctx->sensor_ctrl.isp_enq_seq_no) + 1;
+
+	if (sensor_seq_no_next <= atomic_read(&ctx->enqueued_frame_seq_no))
+		res = 1;
+	/* Send V4L2_EVENT_REQUEST_DRAINED event */
+	if (res == 0) {
+		mtk_cam_event_request_drained(ctx->pipe);
+		dev_dbg(ctx->cam->dev, "request_drained:(%d)\n",
+			sensor_seq_no_next);
+	}
+	return (res == 0);
+}
+
+static void mtk_cam_sv_request_drained(struct mtk_camsv_device *camsv_dev,
+		struct mtk_camsys_sensor_ctrl *sensor_ctrl)
+{
+	struct mtk_cam_ctx *ctx = sensor_ctrl->ctx;
+	int sensor_seq_no_next =
+		atomic_read(&sensor_ctrl->sensor_request_seq_no) + 1;
+	int res = 0;
+
+	if (mtk_cam_is_subsample(ctx))
+		sensor_seq_no_next =
+			atomic_read(&ctx->sensor_ctrl.isp_enq_seq_no) + 1;
+
+	if (sensor_seq_no_next <= atomic_read(&ctx->enqueued_frame_seq_no))
+		res = 1;
+	/* Send V4L2_EVENT_REQUEST_DRAINED event */
+	if (res == 0) {
+		mtk_cam_sv_event_request_drained(camsv_dev);
+		dev_dbg(camsv_dev->dev, "request_drained:(%d)\n",
+			sensor_seq_no_next);
+	}
+}
+
+static bool mtk_cam_req_frame_sync_set(struct mtk_cam_request *req,
+				       unsigned int pipe_id, int value)
+{
+	struct mtk_cam_device *cam =
+		container_of(req->req.mdev, struct mtk_cam_device, media_dev);
+	struct mtk_cam_request_stream_data *s_data;
+	struct v4l2_ctrl *ctrl;
+	struct v4l2_ctrl_handler *hdl;
+
+	s_data = mtk_cam_req_get_s_data(req, pipe_id, 0);
+	if (!s_data) {
+		dev_info(cam->dev,
+			 "%s:%s: get s_data(%d) failed\n",
+			 __func__, req->req.debug_str, pipe_id);
+		return false;
+	}
+
+	/* Use V4L2_CID_FRAME_SYNC to group sensors to be frame sync. */
+	if (!s_data->sensor_hdl_obj) {
+		dev_info(cam->dev,
+			 "%s:%s: pipe(%d): get sensor_hdl_obj failed\n",
+			 __func__, req->req.debug_str, pipe_id);
+		return false;
+	}
+	hdl = (struct v4l2_ctrl_handler *)s_data->sensor_hdl_obj->priv;
+
+	ctrl = v4l2_ctrl_find(hdl, V4L2_CID_FRAME_SYNC);
+	if (ctrl) {
+		v4l2_ctrl_s_ctrl(ctrl, value);
+		dev_info(cam->dev,
+			 "%s:%s: pipe(%d): apply V4L2_CID_FRAME_SYNC(%d)\n",
+			 __func__, req->req.debug_str, pipe_id, value);
+		return true;
+	}
+	dev_info(cam->dev,
+		 "%s:%s: pipe(%d): failed to find V4L2_CID_FRAME_SYNC\n",
+		 __func__, req->req.debug_str, pipe_id);
+
+	return false;
+}
+
+static bool mtk_cam_req_frame_sync_start(struct mtk_cam_request *req)
+{
+	/* All ctx with sensor is in ready state */
+	struct mtk_cam_device *cam =
+		container_of(req->req.mdev, struct mtk_cam_device, media_dev);
+	struct mtk_cam_ctx *ctx;
+	struct mtk_cam_ctx *sync_ctx[MTKCAM_SUBDEV_MAX];
+	unsigned int pipe_id;
+	int i, ctx_cnt = 0, synced_cnt = 0;
+	bool ret = false;
+
+	/* pick out the used ctxs */
+	for (i = 0; i < cam->max_stream_num; i++) {
+		if (!(1 << i & req->ctx_used))
+			continue;
+
+		sync_ctx[ctx_cnt] = &cam->ctxs[i];
+		ctx_cnt++;
+	}
+
+	mutex_lock(&req->fs.op_lock);
+	if (ctx_cnt > 1) {
+		/* multi sensor case */
+		req->fs.on_cnt++;
+		/* not first time */
+		if (req->fs.on_cnt != 1)
+			goto EXIT;
+
+		for (i = 0; i < ctx_cnt; i++) {
+			ctx = sync_ctx[i];
+			spin_lock(&ctx->streaming_lock);
+			if (!ctx->streaming) {
+				spin_unlock(&ctx->streaming_lock);
+				dev_info(cam->dev,
+					 "%s: ctx(%d): is streamed off\n",
+					 __func__, ctx->stream_id);
+				continue;
+			}
+			pipe_id = ctx->stream_id;
+			spin_unlock(&ctx->streaming_lock);
+
+			/* update sensor frame sync */
+			if (!ctx->synced) {
+				if (mtk_cam_req_frame_sync_set(req, pipe_id, 1))
+					ctx->synced = 1;
+			} else {
+				synced_cnt++;
+			}
+		}
+
+		/* the prepared sensor is no enough, skip */
+		/* frame sync set failed or stream off */
+		if (synced_cnt < 2) {
+			mtk_cam_fs_reset(&req->fs);
+			dev_info(cam->dev, "%s:%s: sensor is not ready\n",
+				 __func__, req->req.debug_str);
+			goto EXIT;
+		}
+
+		dev_dbg(cam->dev, "%s:%s:fs_sync_frame(1): ctxs: 0x%x\n",
+			__func__, req->req.debug_str, req->ctx_used);
+
+		ret = true;
+		goto EXIT;
+
+	} else if (ctx_cnt == 1) {
+		/* single sensor case */
+		ctx = sync_ctx[0];
+		spin_lock(&ctx->streaming_lock);
+		if (!ctx->streaming) {
+			spin_unlock(&ctx->streaming_lock);
+			dev_info(cam->dev,
+				 "%s: ctx(%d): is streamed off\n",
+				 __func__, ctx->stream_id);
+			goto EXIT;
+		}
+		pipe_id = ctx->stream_id;
+		spin_unlock(&ctx->streaming_lock);
+
+		if (ctx->synced)
+			if (mtk_cam_req_frame_sync_set(req, pipe_id, 0))
+				ctx->synced = 0;
+	}
+EXIT:
+	dev_dbg(cam->dev, "%s:%s:target/on/off(%d/%d/%d)\n", __func__,
+		req->req.debug_str, req->fs.target, req->fs.on_cnt,
+		req->fs.off_cnt);
+	mutex_unlock(&req->fs.op_lock);
+	return ret;
+}
+
+static bool mtk_cam_req_frame_sync_end(struct mtk_cam_request *req)
+{
+	/* All ctx with sensor is not in ready state */
+	struct mtk_cam_device *cam =
+		container_of(req->req.mdev, struct mtk_cam_device, media_dev);
+	bool ret = false;
+
+	mutex_lock(&req->fs.op_lock);
+	if (req->fs.target && req->fs.on_cnt) {
+		/* check fs on */
+		req->fs.off_cnt++;
+		if (req->fs.on_cnt != req->fs.target ||
+		    req->fs.off_cnt != req->fs.target) {
+			/* not the last */
+			goto EXIT;
+		}
+		dev_dbg(cam->dev,
+			"%s:%s:fs_sync_frame(0): ctxs: 0x%x\n",
+			__func__, req->req.debug_str, req->ctx_used);
+		ret = true;
+		goto EXIT;
+	}
+EXIT:
+	dev_dbg(cam->dev, "%s:%s:target/on/off(%d/%d/%d)\n", __func__,
+		req->req.debug_str, req->fs.target, req->fs.on_cnt,
+		req->fs.off_cnt);
+	mutex_unlock(&req->fs.op_lock);
+	return ret;
+}
+#ifdef ISP7_1
+static struct mtk_camsv_device *get_hdr_sv_dev(struct mtk_cam_ctx *ctx, int exp_order)
+{
+	struct mtk_camsv_device *camsv_dev;
+	struct device *dev_sv;
+	int i;
+
+	for (i = MTKCAM_SUBDEV_CAMSV_END - 1;
+	     i >= MTKCAM_SUBDEV_CAMSV_START; i--) {
+		if (ctx->pipe->enabled_raw & (1 << i)) {
+			int index = i - MTKCAM_SUBDEV_CAMSV_START;
+
+			dev_sv = ctx->cam->sv.devs[index];
+			if (dev_sv == NULL)
+				dev_info(ctx->cam->dev,
+					 "[%s] camsv device not found\n",
+					 __func__);
+			camsv_dev = dev_get_drvdata(dev_sv);
+			if (camsv_dev->pipeline->exp_order == exp_order)
+				return camsv_dev;
+		}
+	}
+	return NULL;
+}
+#endif
+static void mtk_cam_stream_on(struct mtk_raw_device *raw_dev,
+			      struct mtk_cam_ctx *ctx)
+{
+#ifdef ISP7_1
+	struct mtk_camsv_device *camsv_dev;
+	struct device *dev_sv;
+#endif
+	unsigned int hw_scen = 0;
+	int i;
+
+	if (mtk_cam_is_stagger(ctx))
+		hw_scen = mtk_raw_get_hdr_scen_id(ctx);
+	else if (mtk_cam_is_with_w_channel(ctx))
+		hw_scen = (1 << MTKCAM_SV_SPECIAL_SCENARIO_ADDITIONAL_RAW);
+
+	spin_lock(&ctx->streaming_lock);
+	if (ctx->streaming) {
+		for (i = 0; i < ctx->used_sv_num; i++)
+			mtk_cam_sv_dev_stream_on(ctx, i, 1, 1);
+		for (i = MTKCAM_SUBDEV_CAMSV_END - 1;
+		     i >= MTKCAM_SUBDEV_CAMSV_START; i--) {
+			if (hw_scen &&
+			    (ctx->pipe->enabled_raw & (1 << i)) &&
+			    (ctx->pipe->stagger_path == STAGGER_DCIF)) {
+#ifdef ISP7_1
+				int index = i - MTKCAM_SUBDEV_CAMSV_START;
+
+				dev_sv = ctx->cam->sv.devs[index];
+				if (dev_sv == NULL)
+					dev_info(ctx->cam->dev,
+						 "[%s] camsv device not found\n", __func__);
+				camsv_dev = dev_get_drvdata(dev_sv);
+				if (camsv_dev->pipeline->exp_order == 0)
+					mtk_cam_sv_dev_stream_on(ctx,
+						i - MTKCAM_SUBDEV_CAMSV_START,
+						1, hw_scen);
+#endif
+			} else if (hw_scen &&
+				   (ctx->pipe->enabled_raw & (1 << i)) &&
+				   (ctx->pipe->stagger_path != STAGGER_DCIF)) {
+				mtk_cam_sv_dev_stream_on(ctx,
+					i - MTKCAM_SUBDEV_CAMSV_START,
+					1, hw_scen);
+			}
+		}
+		stream_on(raw_dev, 1);
+	}
+	spin_unlock(&ctx->streaming_lock);
+}
+
+bool is_first_request_sync(struct mtk_cam_ctx *ctx)
+{
+	if (ctx->used_raw_num != 0) {
+		if (ctx->pipe->feature_active == 0 &&
+		    MTK_CAM_INITIAL_REQ_SYNC && ctx->sensor)
+			return true;
+	} else {
+		/* only for sv running case */
+		if (MTK_CAM_INITIAL_REQ_SYNC && ctx->sensor)
+			return true;
+	}
+	return false;
+}
+
+static int mtk_cam_sensor_switch_start_hw(struct mtk_cam_ctx *ctx,
+				   struct mtk_cam_request_stream_data *s_data)
+{
+	struct mtk_cam_device *cam = ctx->cam;
+	struct mtk_raw_device *raw_dev;
+	struct device *dev;
+	int i, j, ret, tgo_pxl_mode, feature_first_req, exp_no;
+
+	if (!ctx->used_raw_num)
+		goto set_pixelmode_tg;
+
+	tgo_pxl_mode = ctx->pipe->res_config.tgo_pxl_mode;
+	dev = mtk_cam_find_raw_dev(cam, ctx->used_raw_dev);
+	if (!dev) {
+		dev_info(cam->dev, "streamon raw device not found\n");
+		ret = -EINVAL;
+		goto fail_switch_stop;
+	}
+
+	mtk_camsys_ctrl_update(ctx);
+	raw_dev = dev_get_drvdata(dev);
+	atomic_set(&raw_dev->vf_en, 1);
+
+	if (mtk_cam_is_mstream(ctx)) {
+		struct mtk_cam_request *req = mtk_cam_s_data_get_req(s_data);
+		struct mtk_cam_request_stream_data *mstream_s_data;
+
+		mstream_s_data = mtk_cam_req_get_s_data(req, ctx->stream_id, 1);
+		state_transition(&mstream_s_data->state,
+				 E_STATE_SENINF, E_STATE_OUTER);
+	} else {
+		state_transition(&s_data->state, E_STATE_SENINF, E_STATE_OUTER);
+	}
+
+	feature_first_req = s_data->feature.raw_feature;
+	/* stagger mode - use sv to output data to DRAM - online mode */
+	if (mtk_cam_is_stagger(ctx)) {
+		int used_pipes, src_pad_idx;
+
+		used_pipes = ctx->pipe->enabled_raw;
+		for (i = MTKCAM_SUBDEV_CAMSV_START;
+		     i < MTKCAM_SUBDEV_CAMSV_END; i++) {
+			int index = i - MTKCAM_SUBDEV_CAMSV_START;
+
+			for (j = 0; j < MAX_STAGGER_EXP_AMOUNT; j++) {
+				if (cam->sv.pipelines[index].hw_cap &
+				    (1 << (j + CAMSV_EXP_ORDER_SHIFT))) {
+					src_pad_idx = PAD_SRC_RAW0 + j;
+					break;
+				}
+			}
+			if (used_pipes & (1 << i)) {
+				mtk_cam_call_seninf_set_pixelmode(ctx,
+								  s_data->seninf_new,
+								  src_pad_idx,
+								  tgo_pxl_mode);
+				mtk_cam_seninf_set_camtg(s_data->seninf_old,
+							 src_pad_idx,
+							 0xFF);
+				mtk_cam_seninf_set_camtg(s_data->seninf_new,
+							 src_pad_idx,
+							 cam->sv.pipelines[index].cammux_id);
+				dev_info(cam->dev,
+					 "seninf_set_camtg(src_pad:%d/i:%d/camtg:%d)",
+					 src_pad_idx, i,
+					 cam->sv.pipelines[index].cammux_id);
+			}
+		}
+	} else if (mtk_cam_is_time_shared(ctx)) {
+		int hw_scen = (1 << MTKCAM_IPI_HW_PATH_OFFLINE_M2M);
+		int src_pad_idx = PAD_SRC_RAW0;
+		int used_pipes = ctx->pipe->enabled_raw;
+
+		for (i = MTKCAM_SUBDEV_CAMSV_START;
+		     i < MTKCAM_SUBDEV_CAMSV_END; i++) {
+			int index = i - MTKCAM_SUBDEV_CAMSV_START;
+
+			if (used_pipes & (1 << i)) {
+				mtk_cam_call_seninf_set_pixelmode(ctx,
+								  s_data->seninf_new,
+								  src_pad_idx,
+								  tgo_pxl_mode);
+				mtk_cam_seninf_set_camtg(s_data->seninf_old,
+							 src_pad_idx, 0xFF);
+				mtk_cam_seninf_set_camtg(s_data->seninf_new,
+							 src_pad_idx,
+							 cam->sv.pipelines[index].cammux_id);
+				ret = mtk_cam_sv_dev_config(ctx, index,
+							    hw_scen, 0);
+				if (ret)
+					goto fail_switch_stop;
+
+				src_pad_idx++;
+				dev_info(cam->dev,
+					 "[TS] scen:0x%x/enabled_raw:0x%x/i(%d)",
+					 hw_scen, ctx->pipe->enabled_raw, i);
+			}
+		}
+	} else if (mtk_cam_is_with_w_channel(ctx)) {
+		for (i = MTKCAM_SUBDEV_CAMSV_START;
+		     i < MTKCAM_SUBDEV_CAMSV_END; i++) {
+			int index = i - MTKCAM_SUBDEV_CAMSV_START;
+
+			if (ctx->pipe->enabled_raw & 1 << i) {
+				int hw_scen =
+					(1 << MTKCAM_SV_SPECIAL_SCENARIO_ADDITIONAL_RAW);
+				mtk_cam_call_seninf_set_pixelmode(ctx,
+								  s_data->seninf_new,
+								  PAD_SRC_RAW_W0,
+								  tgo_pxl_mode);
+				mtk_cam_seninf_set_camtg(s_data->seninf_old,
+							 PAD_SRC_RAW_W0, 0xFF);
+				mtk_cam_seninf_set_camtg(s_data->seninf_new,
+							 PAD_SRC_RAW_W0,
+							 cam->sv.pipelines[index].cammux_id);
+				dev_info(cam->dev,
+					 "seninf_set_camtg(src_pad:%d/i:%d/camtg:%d)",
+					 PAD_SRC_RAW_W0, i,
+					 cam->sv.pipelines[index].cammux_id);
+				ret = mtk_cam_sv_dev_config(ctx, index,
+							    hw_scen, 0);
+				if (ret)
+					goto fail_switch_stop;
+				break;
+			}
+		}
+	}
+
+	/* set cam mux camtg and pixel mode */
+	if (mtk_cam_is_stagger(ctx)) {
+		if (ctx->pipe->stagger_path == STAGGER_ON_THE_FLY) {
+			int seninf_pad;
+
+			if (mtk_cam_feature_is_2_exposure(feature_first_req)) {
+				seninf_pad = PAD_SRC_RAW1;
+				exp_no = 2;
+			} else if (mtk_cam_feature_is_3_exposure(feature_first_req)) {
+				seninf_pad = PAD_SRC_RAW2;
+				exp_no = 3;
+			} else {
+				seninf_pad = PAD_SRC_RAW0;
+				exp_no = 1;
+			}
+
+			/* TODO: backend support one pixel mode only */
+			mtk_cam_call_seninf_set_pixelmode(ctx,
+							  s_data->seninf_new,
+							  seninf_pad,
+							  tgo_pxl_mode);
+			dev_info(cam->dev,
+				 "%s: change camtg(src_pad:%d/camtg:%d) for stagger, exp number:%d\n",
+				 __func__, seninf_pad,
+				 PipeIDtoTGIDX(raw_dev->id), exp_no);
+
+			mtk_cam_seninf_set_camtg(s_data->seninf_new, seninf_pad,
+						 PipeIDtoTGIDX(raw_dev->id));
+		}
+	} else if (!mtk_cam_is_m2m(ctx) &&
+		   !mtk_cam_is_time_shared(ctx)) {
+		mtk_cam_call_seninf_set_pixelmode(ctx, s_data->seninf_new,
+						  PAD_SRC_RAW0,
+						  tgo_pxl_mode);
+		mtk_cam_seninf_set_camtg(s_data->seninf_new, PAD_SRC_RAW0,
+					  PipeIDtoTGIDX(raw_dev->id));
+	}
+
+set_pixelmode_tg:
+	if (!mtk_cam_is_m2m(ctx)) {
+		for (i = 0 ; i < ctx->used_sv_num ; i++) {
+			/* use 8-pixel mode as default */
+			mtk_cam_call_seninf_set_pixelmode(ctx,
+							  s_data->seninf_new,
+							  ctx->sv_pipe[i]->seninf_padidx, 3);
+			mtk_cam_seninf_set_camtg(s_data->seninf_old,
+						 ctx->sv_pipe[i]->seninf_padidx,
+						 0xFF);
+			mtk_cam_seninf_set_camtg(s_data->seninf_new,
+						 ctx->sv_pipe[i]->seninf_padidx,
+						 ctx->sv_pipe[i]->cammux_id);
+		}
+	} else {
+		ctx->processing_buffer_list.cnt = 0;
+		ctx->composed_buffer_list.cnt = 0;
+		dev_dbg(cam->dev, "[M2M] reset processing_buffer_list.cnt & composed_buffer_list.cnt\n");
+	}
+
+	return 0;
+
+fail_switch_stop:
+	return ret;
+}
+
+void mtk_cam_req_seninf_change(struct mtk_cam_request *req)
+{
+	//struct media_pipeline *m_pipe;
+	struct mtk_cam_ctx *ctx;
+	struct mtk_cam_device *cam =
+		container_of(req->req.mdev, struct mtk_cam_device, media_dev);
+	struct mtk_cam_request_stream_data *req_stream_data;
+	struct mtk_raw_device *raw_dev;
+	int i, j, stream_id;
+	u32 val;
+
+	dev_info(cam->dev, "%s, req->ctx_used:0x%x, req->ctx_link_update:0x%x\n",
+		 __func__, req->ctx_used, req->ctx_link_update);
+
+	for (i = 0; i < cam->max_stream_num; i++) {
+		if (req->ctx_used & (1 << i) &&
+		    (req->ctx_link_update & (1 << i))) {
+			stream_id = i;
+			ctx = &cam->ctxs[stream_id];
+			raw_dev = get_main_raw_dev(ctx->cam, ctx->pipe);
+			req_stream_data =
+				mtk_cam_req_get_s_data(req, stream_id, 0);
+
+			dev_info(cam->dev, "%s: pipe(%d): switch seninf: %s--> %s\n",
+				 __func__, stream_id,
+				 req_stream_data->seninf_old->name,
+				 req_stream_data->seninf_new->name);
+
+			for (j = 0; j < ctx->used_sv_num; j++)
+				dev_info(cam->dev, "%s: pipe(%d): switch seninf: %s--> %s\n",
+					 __func__, ctx->sv_pipe[j]->id,
+					 req_stream_data->seninf_old->name,
+					 req_stream_data->seninf_new->name);
+
+			mtk_cam_apply_pending_dev_config(req_stream_data);
+			/*m_pipe = req_stream_data->seninf_new->entity.pipe;
+			req_stream_data->seninf_new->entity.pipe->streaming_count++;
+			req_stream_data->seninf_new->entity.pipe =
+				req_stream_data->seninf_old->entity.pipe;
+			req_stream_data->seninf_old->entity.pipe->streaming_count--;
+			req_stream_data->seninf_old->entity.pipe = m_pipe;*/
+
+			dev_info(cam->dev,
+				 "%s: pipe(%d):seninf(%s):seninf_set_camtg, pad(%d) camtg(%d)",
+				 __func__, stream_id,
+				 req_stream_data->seninf_old->name,
+				 PAD_SRC_RAW0, PipeIDtoTGIDX(raw_dev->id));
+			mtk_cam_sensor_switch_start_hw(ctx, req_stream_data);
+			dev_info(cam->dev, "%s: pipe(%d): update BW for %s\n",
+				 __func__, stream_id,
+				 req_stream_data->seninf_new->name);
+		}
+	}
+
+	for (i = 0; i < cam->max_stream_num; i++) {
+		if (req->ctx_used & (1 << i) &&
+			req->ctx_link_update & (1 << i)) {
+			stream_id = i;
+			ctx = &cam->ctxs[stream_id];
+			req_stream_data =
+				mtk_cam_req_get_s_data(req, stream_id, 0);
+			raw_dev = get_main_raw_dev(ctx->cam, ctx->pipe);
+
+			/* reset for mstream */
+			ctx->next_sof_mask_frame_seq_no = 0;
+
+			dev_info(cam->dev,
+				 "%s: pipe(%d): Enable VF of raw:%d\n",
+				 __func__, stream_id, raw_dev->id);
+
+			/* Enable CMOS */
+			dev_info(raw_dev->dev, "enable CMOS\n");
+			val = readl(raw_dev->base + REG_TG_SEN_MODE);
+			writel(val | TG_SEN_MODE_CMOS_EN,
+			       raw_dev->base + REG_TG_SEN_MODE);
+			mtk_cam_stream_on(raw_dev, ctx);
+
+			dev_info(raw_dev->dev, "%s: stream off seninf:%s\n",
+				__func__, req_stream_data->seninf_old->name);
+			v4l2_subdev_call(req_stream_data->seninf_old,
+					 video, s_stream, 0);
+
+			if (ctx->prev_sensor || ctx->prev_seninf) {
+				ctx->prev_sensor = NULL;
+				ctx->prev_seninf = NULL;
+			}
+		}
+	}
+	dev_dbg(cam->dev, "%s: cam mux switch done\n", __func__);
+}
+
+static void mtk_cam_m2m_sensor_skip(struct mtk_cam_request_stream_data *data)
+{
+	struct mtk_cam_request *req = mtk_cam_s_data_get_req(data);
+	struct mtk_cam_ctx *ctx = mtk_cam_s_data_get_ctx(data);
+
+	dev_dbg(ctx->cam->dev,
+		"%s:%s:ctx(%d):sensor ctrl skip frame_seq_no %d\n",
+		__func__, req->req.debug_str,
+		ctx->stream_id, data->frame_seq_no);
+	state_transition(&data->state, E_STATE_READY, E_STATE_SENSOR);
+	mtk_cam_complete_sensor_hdl(data);
+}
+
+static void mtk_cam_set_sensor_mstream_mode(struct mtk_cam_ctx *ctx, bool on)
+{
+	struct v4l2_ctrl *mstream_mode_ctrl;
+
+	mstream_mode_ctrl = v4l2_ctrl_find(ctx->sensor->ctrl_handler,
+					   V4L2_CID_MTK_MSTREAM_MODE);
+
+	if (!mstream_mode_ctrl) {
+		dev_info(ctx->cam->dev,
+			 "%s: ctx(%d): no sensor mstream mode control found\n",
+			 __func__, ctx->stream_id);
+		return;
+	}
+	v4l2_ctrl_s_ctrl(mstream_mode_ctrl, on);
+
+	dev_dbg(ctx->cam->dev,
+		"%s mstream mode:%d\n", __func__, on);
+}
+
+static int mtk_cam_set_sensor_mstream_exposure(struct mtk_cam_ctx *ctx,
+	struct mtk_cam_request_stream_data *req_stream_data)
+{
+	struct mtk_cam_device *cam = ctx->cam;
+	int is_mstream_last_exposure = 0;
+	struct mtk_cam_request *req = mtk_cam_s_data_get_req(req_stream_data);
+	struct mtk_cam_request_stream_data *last_req_stream_data;
+
+	last_req_stream_data = mtk_cam_req_get_s_data(req, ctx->stream_id, 0);
+	if (req_stream_data->frame_seq_no == last_req_stream_data->frame_seq_no)
+		is_mstream_last_exposure = 1;
+
+	if (!ctx->sensor) {
+		dev_info(cam->dev, "%s: ctx(%d): no sensor found\n",
+			 __func__, ctx->stream_id);
+	} else {
+		struct v4l2_ctrl *ae_shutter_ctrl;
+		struct v4l2_ctrl *ae_gain_ctrl;
+		int shutter, gain;
+
+		/* mstream mode on */
+		if (last_req_stream_data->frame_seq_no == 2 ||
+		    mtk_cam_feature_change_is_mstream(last_req_stream_data->feature.switch_feature_type))
+			mtk_cam_set_sensor_mstream_mode(ctx, 1);
+
+		ae_shutter_ctrl = v4l2_ctrl_find(ctx->sensor->ctrl_handler,
+					 V4L2_CID_EXPOSURE);
+		if (!ae_shutter_ctrl) {
+			dev_info(ctx->cam->dev,
+				"no stagger ae shutter ctrl id in %s\n",
+				ctx->sensor->name);
+			return is_mstream_last_exposure;
+		}
+
+		ae_gain_ctrl = v4l2_ctrl_find(ctx->sensor->ctrl_handler,
+					 V4L2_CID_ANALOGUE_GAIN);
+		if (!ae_gain_ctrl) {
+			dev_info(ctx->cam->dev,
+				"no stagger ae gain ctrl id in %s\n",
+				ctx->sensor->name);
+			return is_mstream_last_exposure;
+		}
+
+		shutter = req_stream_data->mtk_cam_exposure.shutter;
+		gain = req_stream_data->mtk_cam_exposure.gain;
+
+		dev_dbg(ctx->cam->dev,
+			"%s exposure:%d gain:%d\n", __func__, shutter, gain);
+
+		/* The gain value is computed through hal3A and transformed by halSensor. A gain value of 0 is expected. */
+		if (shutter > 0) {
+			v4l2_ctrl_s_ctrl_compound(ae_shutter_ctrl, V4L2_CTRL_TYPE_INTEGER,
+						&shutter);
+			v4l2_ctrl_s_ctrl_compound(ae_gain_ctrl, V4L2_CTRL_TYPE_INTEGER,
+						&gain);
+			dev_dbg(ctx->cam->dev, "mstream sensor ae ctrl done\n");
+		}
+	}
+
+	return is_mstream_last_exposure;
+}
+
+static bool mtk_cam_submit_kwork(struct kthread_worker *worker,
+				 struct mtk_cam_sensor_work *sensor_work,
+				 kthread_work_func_t func)
+{
+	if (!worker) {
+		pr_info("%s: not queue work since kthread_worker is null\n",
+			__func__);
+
+		return false;
+	}
+
+	if (atomic_read(&sensor_work->is_queued)) {
+		pr_info("%s: not queue work since sensor_work is already queued\n",
+			__func__);
+
+		return false;
+	}
+
+	/**
+	 * TODO: init the work function during request enqueue since
+	 * mtk_cam_submit_kwork() is called in interrupt context
+	 * now.
+	 */
+	kthread_init_work(&sensor_work->work, func);
+	atomic_set(&sensor_work->is_queued, 1);
+	return kthread_queue_work(worker, &sensor_work->work);
+}
+
+static void mtk_cam_exp_switch_sensor(
+	struct mtk_cam_request_stream_data *data)
+{
+	struct mtk_cam_request *req = mtk_cam_s_data_get_req(data);
+	struct mtk_cam_ctx *ctx = mtk_cam_s_data_get_ctx(data);
+	struct mtk_cam_device *cam = ctx->cam;
+	unsigned int time_after_sof = 0;
+
+	dev_dbg(cam->dev, "%s:%s:ctx(%d):sensor try set start\n",
+		__func__, req->req.debug_str, ctx->stream_id);
+
+	if (mtk_cam_req_frame_sync_start(req))
+		dev_dbg(cam->dev, "%s:%s:ctx(%d): sensor ctrl with frame sync - start\n",
+			__func__, req->req.debug_str, ctx->stream_id);
+	/* request setup*/
+	if (data->flags & MTK_CAM_REQ_S_DATA_FLAG_SENSOR_HDL_EN) {
+		v4l2_ctrl_request_setup(&req->req, data->sensor->ctrl_handler);
+		time_after_sof = ktime_get_boottime_ns() / 1000000 -
+					ctx->sensor_ctrl.sof_time;
+		dev_dbg(cam->dev, "[SOF+%dms] Sensor request:%d[ctx:%d] setup\n",
+			time_after_sof, data->frame_seq_no,
+			ctx->stream_id);
+	}
+
+	state_transition(&data->state,
+		E_STATE_READY, E_STATE_SENSOR);
+	if (mtk_cam_req_frame_sync_end(req))
+		dev_dbg(cam->dev, "%s:ctx(%d): sensor ctrl with frame sync - stop\n",
+			__func__, ctx->stream_id);
+
+	dev_info(cam->dev, "%s:%s:ctx(%d)req(%d):sensor done at SOF+%dms\n",
+		 __func__, req->req.debug_str, ctx->stream_id,
+		 data->frame_seq_no, time_after_sof);
+
+	mtk_cam_complete_sensor_hdl(data);
+}
+
+static void mtk_cam_exp_switch_sensor_worker(struct kthread_work *work)
+{
+	struct mtk_cam_request_stream_data *data
+		= mtk_cam_sensor_work_to_s_data(work);
+	struct mtk_cam_request *req = mtk_cam_s_data_get_req(data);
+	struct mtk_cam_ctx *ctx = mtk_cam_s_data_get_ctx(data);
+	struct mtk_cam_device *cam = ctx->cam;
+	unsigned int time_after_sof = 0;
+
+	req = mtk_cam_s_data_get_req(data);
+	dev_dbg(cam->dev, "%s:%s:ctx(%d):sensor try set start\n",
+		__func__, req->req.debug_str, ctx->stream_id);
+
+	if (mtk_cam_req_frame_sync_start(req))
+		dev_dbg(cam->dev,
+			"%s:%s:ctx(%d): sensor ctrl with frame sync - start\n",
+			__func__, req->req.debug_str, ctx->stream_id);
+	/* request setup*/
+	if (data->flags & MTK_CAM_REQ_S_DATA_FLAG_SENSOR_HDL_EN) {
+		v4l2_ctrl_request_setup(&req->req, data->sensor->ctrl_handler);
+		time_after_sof = ktime_get_boottime_ns() / 1000000 -
+			ctx->sensor_ctrl.sof_time;
+		dev_dbg(cam->dev, "[SOF+%dms] Sensor request:%d[ctx:%d] setup\n",
+			time_after_sof, data->frame_seq_no, ctx->stream_id);
+	}
+
+	state_transition(&data->state, E_STATE_READY, E_STATE_SENSOR);
+	if (mtk_cam_req_frame_sync_end(req))
+		dev_dbg(cam->dev,
+			"%s:ctx(%d): sensor ctrl with frame sync - stop\n",
+			__func__, ctx->stream_id);
+
+	dev_info(cam->dev, "%s:%s:ctx(%d)req(%d):sensor done at SOF+%dms\n",
+		 __func__, req->req.debug_str, ctx->stream_id,
+		 data->frame_seq_no, time_after_sof);
+	mtk_cam_complete_sensor_hdl(data);
+}
+
+static int mtk_camsys_exp_switch_cam_mux(struct mtk_raw_device *raw_dev,
+	struct mtk_cam_ctx *ctx, struct mtk_cam_request_stream_data *data)
+{
+	struct mtk_cam_seninf_mux_param param;
+	struct mtk_cam_seninf_mux_setting settings[3];
+	int type = data->feature.switch_feature_type;
+	int sv_main_id, sv_sub_id, sv_main_idx, sv_sub_idx;
+	int config_exposure_num = 3;
+	int feature_active;
+
+	/**
+	 * To identify the "max" exposure_num, we use
+	 * feature_active, not data->feature.raw_feature
+	 * since the latter one stores the exposure_num information,
+	 * not the max one.
+	 */
+	if (data->feature.switch_done == 1)
+		return 0;
+	feature_active = ctx->pipe->feature_active;
+	if (feature_active == STAGGER_2_EXPOSURE_LE_SE ||
+	    feature_active == STAGGER_2_EXPOSURE_SE_LE)
+		config_exposure_num = 2;
+
+	if (type != EXPOSURE_CHANGE_NONE && config_exposure_num == 3) {
+		sv_main_id = get_main_sv_pipe_id(ctx->cam, ctx->pipe->enabled_raw);
+		sv_sub_id = get_sub_sv_pipe_id(ctx->cam, ctx->pipe->enabled_raw);
+		sv_main_idx = sv_main_id - MTKCAM_SUBDEV_CAMSV_START;
+		sv_sub_idx = sv_sub_id - MTKCAM_SUBDEV_CAMSV_START;
+		switch (type) {
+		case EXPOSURE_CHANGE_3_to_2:
+		case EXPOSURE_CHANGE_1_to_2:
+			settings[0].seninf = ctx->seninf;
+			settings[0].source = PAD_SRC_RAW0;
+			settings[0].camtg =
+				ctx->cam->sv.pipelines[sv_main_idx].cammux_id;
+			settings[0].enable = 1;
+
+			settings[1].seninf = ctx->seninf;
+			settings[1].source = PAD_SRC_RAW1;
+			settings[1].camtg = PipeIDtoTGIDX(raw_dev->id);
+			settings[1].enable = 1;
+
+			settings[2].seninf = ctx->seninf;
+			settings[2].source = PAD_SRC_RAW2;
+			settings[2].camtg =
+				ctx->cam->sv.pipelines[sv_sub_idx].cammux_id;
+			settings[2].enable = 0;
+			break;
+		case EXPOSURE_CHANGE_3_to_1:
+		case EXPOSURE_CHANGE_2_to_1:
+			settings[0].seninf = ctx->seninf;
+			settings[0].source = PAD_SRC_RAW0;
+			settings[0].camtg = PipeIDtoTGIDX(raw_dev->id);
+			settings[0].enable = 1;
+
+			settings[1].seninf = ctx->seninf;
+			settings[1].source = PAD_SRC_RAW1;
+			settings[1].camtg =
+				ctx->cam->sv.pipelines[sv_sub_idx].cammux_id;
+			settings[1].enable = 0;
+
+			settings[2].seninf = ctx->seninf;
+			settings[2].source = PAD_SRC_RAW2;
+			settings[2].camtg  =
+				ctx->cam->sv.pipelines[sv_main_idx].cammux_id;
+			settings[2].enable = 0;
+			break;
+		case EXPOSURE_CHANGE_2_to_3:
+		case EXPOSURE_CHANGE_1_to_3:
+			settings[0].seninf = ctx->seninf;
+			settings[0].source = PAD_SRC_RAW0;
+			settings[0].camtg  =
+				ctx->cam->sv.pipelines[sv_main_idx].cammux_id;
+			settings[0].enable = 1;
+
+			settings[1].seninf = ctx->seninf;
+			settings[1].source = PAD_SRC_RAW1;
+			settings[1].camtg  =
+				ctx->cam->sv.pipelines[sv_sub_idx].cammux_id;
+			settings[1].enable = 1;
+
+			settings[2].seninf = ctx->seninf;
+			settings[2].source = PAD_SRC_RAW2;
+			settings[2].camtg  = PipeIDtoTGIDX(raw_dev->id);
+			settings[2].enable = 1;
+			break;
+		default:
+			break;
+		}
+		param.settings = &settings[0];
+		param.num = 3;
+		mtk_cam_seninf_streaming_mux_change(&param);
+		data->feature.switch_done = 1;
+		dev_info(ctx->cam->dev,
+			 "[%s] switch Req:%d, type:%d, cam_mux[0][1][2]:[%d/%d/%d][%d/%d/%d][%d/%d/%d]\n",
+			 __func__, data->frame_seq_no, type,
+			 settings[0].source, settings[0].camtg, settings[0].enable,
+			 settings[1].source, settings[1].camtg, settings[1].enable,
+			 settings[2].source, settings[2].camtg, settings[2].enable);
+	} else if (type != EXPOSURE_CHANGE_NONE && config_exposure_num == 2) {
+		sv_main_id = get_main_sv_pipe_id(ctx->cam, ctx->pipe->enabled_raw);
+		sv_main_idx = sv_main_id - MTKCAM_SUBDEV_CAMSV_START;
+		switch (type) {
+		case EXPOSURE_CHANGE_2_to_1:
+			settings[0].seninf = ctx->seninf;
+			settings[0].source = PAD_SRC_RAW0;
+			settings[0].camtg  = PipeIDtoTGIDX(raw_dev->id);
+			settings[0].enable = 1;
+			settings[1].seninf = ctx->seninf;
+			settings[1].source = PAD_SRC_RAW1;
+			settings[1].camtg  =
+				ctx->cam->sv.pipelines[sv_main_idx].cammux_id;
+			settings[1].enable = 0;
+			break;
+		case EXPOSURE_CHANGE_1_to_2:
+			settings[0].seninf = ctx->seninf;
+			settings[0].source = PAD_SRC_RAW0;
+			settings[0].camtg  =
+				ctx->cam->sv.pipelines[sv_main_idx].cammux_id;
+			settings[0].enable = 1;
+			settings[1].seninf = ctx->seninf;
+			settings[1].source = PAD_SRC_RAW1;
+			settings[1].camtg  = PipeIDtoTGIDX(raw_dev->id);
+			settings[1].enable = 1;
+			break;
+		default:
+			break;
+		}
+		param.settings = &settings[0];
+		param.num = 2;
+		mtk_cam_seninf_streaming_mux_change(&param);
+		data->feature.switch_done = 1;
+		dev_info(ctx->cam->dev,
+			 "[%s] switch Req:%d, type:%d, cam_mux[0][1]:[%d/%d/%d][%d/%d/%d] ts:%llu\n",
+			 __func__, data->frame_seq_no, type,
+			 settings[0].source, settings[0].camtg, settings[0].enable,
+			 settings[1].source, settings[1].camtg, settings[1].enable,
+			 ktime_get_boottime_ns() / 1000);
+	}
+	/* switch state */
+	if (type == EXPOSURE_CHANGE_3_to_1 ||
+		type == EXPOSURE_CHANGE_2_to_1) {
+		state_transition(&data->state,
+				 E_STATE_CQ, E_STATE_CAMMUX_OUTER);
+		state_transition(&data->state,
+				 E_STATE_OUTER, E_STATE_CAMMUX_OUTER);
+	}
+	return 0;
+}
+
+static int mtk_cam_exp_sensor_switch(struct mtk_cam_ctx *ctx,
+				     struct mtk_cam_request_stream_data *data)
+{
+	struct mtk_cam_device *cam = ctx->cam;
+	struct mtk_raw_device *raw_dev = get_main_raw_dev(ctx->cam, ctx->pipe);
+	int time_after_sof;
+	int type = data->feature.switch_feature_type;
+
+	if ((type == EXPOSURE_CHANGE_2_to_1 ||
+	     type == EXPOSURE_CHANGE_3_to_1) &&
+		(STAGGER_CQ_LAST_SOF == 0)) {
+		mtk_cam_submit_kwork(ctx->sensor_ctrl.sensorsetting_wq,
+				     &data->sensor_work,
+				     mtk_cam_exp_switch_sensor_worker);
+	} else if (type == EXPOSURE_CHANGE_1_to_2 ||
+		   type == EXPOSURE_CHANGE_1_to_3) {
+		mtk_cam_exp_switch_sensor(data);
+		mtk_camsys_exp_switch_cam_mux(raw_dev, ctx, data);
+	}
+	time_after_sof = ktime_get_boottime_ns() / 1000000 -
+		ctx->sensor_ctrl.sof_time;
+	dev_dbg(cam->dev,
+		"[%s] [SOF+%dms]] ctx:%d, req:%d\n",
+		__func__, time_after_sof, ctx->stream_id, data->frame_seq_no);
+
+	return 0;
+}
+
+static int mtk_cam_hdr_switch_toggle(struct mtk_cam_ctx *ctx, int raw_feature)
+{
+	struct mtk_raw_device *raw_dev;
+	struct mtk_camsv_device *camsv_dev;
+	struct device *dev_sv;
+	int sv_main_id, sv_sub_id;
+
+	raw_dev = get_main_raw_dev(ctx->cam, ctx->pipe);
+	sv_main_id = get_main_sv_pipe_id(ctx->cam, ctx->pipe->enabled_raw);
+	dev_sv = ctx->cam->sv.devs[sv_main_id - MTKCAM_PIPE_CAMSV_0];
+	camsv_dev = dev_get_drvdata(dev_sv);
+	enable_tg_db(raw_dev, 0);
+	mtk_cam_sv_toggle_tg_db(camsv_dev);
+	if (raw_feature == STAGGER_3_EXPOSURE_LE_NE_SE ||
+	    raw_feature == STAGGER_3_EXPOSURE_SE_NE_LE) {
+		sv_sub_id = get_sub_sv_pipe_id(ctx->cam, ctx->pipe->enabled_raw);
+		dev_sv = ctx->cam->sv.devs[sv_sub_id - MTKCAM_PIPE_CAMSV_0];
+		camsv_dev = dev_get_drvdata(dev_sv);
+		mtk_cam_sv_toggle_tg_db(camsv_dev);
+	}
+	enable_tg_db(raw_dev, 1);
+	toggle_db(raw_dev);
+
+	return 0;
+}
+
+static void mtk_cam_subspl_req_prepare(struct mtk_camsys_sensor_ctrl *sensor_ctrl)
+{
+	struct mtk_cam_ctx *ctx = sensor_ctrl->ctx;
+	struct mtk_cam_device *cam = ctx->cam;
+	struct mtk_cam_request_stream_data *data;
+	int sensor_seq_no_next =
+		atomic_read(&ctx->sensor_ctrl.isp_enq_seq_no) + 1;
+
+	data = mtk_cam_get_req_s_data(ctx, ctx->stream_id, sensor_seq_no_next);
+	if (data) {
+		if (data->state.estate == E_STATE_READY) {
+			dev_dbg(cam->dev, "[%s] sensor_no:%d stream_no:%d\n",
+				__func__, sensor_seq_no_next,
+				data->frame_seq_no);
+
+			/* EnQ this request's state element to state_list (STATE:READY) */
+			spin_lock(&sensor_ctrl->camsys_state_lock);
+			list_add_tail(&data->state.state_element,
+				      &sensor_ctrl->camsys_state_list);
+			state_transition(&data->state,
+					 E_STATE_READY, E_STATE_SUBSPL_READY);
+			spin_unlock(&sensor_ctrl->camsys_state_lock);
+		}
+	}
+}
+
+static inline bool is_sensor_switch(struct mtk_cam_request_stream_data *s_data)
+{
+	if (s_data->feature.switch_feature_type &&
+	    !mtk_cam_feature_change_is_mstream(s_data->feature.switch_feature_type))
+		return true;
+
+	if (s_data->flags & MTK_CAM_REQ_S_DATA_FLAG_SENSOR_MODE_UPDATE_T1) {
+		state_transition(&s_data->state, E_STATE_READY, E_STATE_SENSOR);
+		return true;
+	}
+
+	return false;
+}
+
+static void mtk_cam_set_sensor_subspl(struct mtk_cam_request_stream_data *data,
+				      struct mtk_camsys_sensor_ctrl *sensor_ctrl)
+{
+	struct mtk_cam_ctx *ctx = mtk_cam_s_data_get_ctx(data);
+	struct mtk_cam_device *cam = ctx->cam;
+	struct mtk_cam_request *req = mtk_cam_s_data_get_req(data);
+	struct mtk_raw_device *raw_dev = NULL;
+	unsigned int time_after_sof = 0;
+
+	dev_dbg(cam->dev, "%s:%s:ctx(%d) req(%d):sensor try set start\n",
+		__func__, req->req.debug_str,
+		ctx->stream_id, data->frame_seq_no);
+	atomic_set(&sensor_ctrl->sensor_request_seq_no,
+		   data->frame_seq_no);
+
+	/*
+	 * request setup
+	 * 1st frame sensor setting in mstream is treated like
+	 * normal frame and is set with other settings like max fps.
+	 * 2nd is special, only expsure is set.
+	 */
+	if (data->flags & MTK_CAM_REQ_S_DATA_FLAG_SENSOR_HDL_EN) {
+		v4l2_ctrl_request_setup(&req->req,
+					data->sensor->ctrl_handler);
+		time_after_sof = ktime_get_boottime_ns() / 1000000 -
+			ctx->sensor_ctrl.sof_time;
+		dev_dbg(cam->dev,
+			"[SOF+%dms] Sensor request:%d[ctx:%d] setup\n",
+			time_after_sof, data->frame_seq_no,
+			ctx->stream_id);
+	}
+	state_transition(&data->state, E_STATE_SUBSPL_OUTER,
+			 E_STATE_SUBSPL_SENSOR);
+
+	if (ctx->used_raw_num) {
+		raw_dev = get_main_raw_dev(ctx->cam, ctx->pipe);
+		if (atomic_read(&raw_dev->vf_en) == 0 &&
+		    ctx->sensor_ctrl.initial_cq_done == 1 &&
+		    data->frame_seq_no == 1)
+			mtk_cam_stream_on(raw_dev, ctx);
+	}
+
+	dev_dbg(cam->dev, "%s:%s:ctx(%d)req(%d):sensor done at SOF+%dms\n",
+		__func__, req->req.debug_str, ctx->stream_id,
+		data->frame_seq_no, time_after_sof);
+	mtk_cam_complete_sensor_hdl(data);
+}
+
+void mtk_cam_set_sensor_full(struct mtk_cam_request_stream_data *s_data,
+			     struct mtk_camsys_sensor_ctrl *sensor_ctrl)
+{
+	struct mtk_cam_device *cam;
+	struct mtk_cam_ctx *ctx;
+	struct mtk_cam_request *req;
+	struct mtk_raw_device *raw_dev = NULL;
+	unsigned int time_after_sof = 0;
+	int sv_i, is_mstream_last_exposure = 0;
+
+	/* EnQ this request's state element to state_list (STATE:READY) */
+	spin_lock(&sensor_ctrl->camsys_state_lock);
+	list_add_tail(&s_data->state.state_element,
+		      &sensor_ctrl->camsys_state_list);
+	atomic_set(&sensor_ctrl->sensor_request_seq_no, s_data->frame_seq_no);
+	spin_unlock(&sensor_ctrl->camsys_state_lock);
+
+	if (is_sensor_switch(s_data)) {
+		dev_info(sensor_ctrl->ctx->cam->dev,
+			 "[TimerIRQ] switch type:%d request:%d - pass sensor\n",
+			 s_data->feature.switch_feature_type,
+			 s_data->frame_seq_no);
+		return;
+	}
+
+	if (mtk_cam_is_m2m(sensor_ctrl->ctx)) {
+		mtk_cam_m2m_sensor_skip(s_data);
+		return;
+	}
+	/*sensor_worker task*/
+	ctx = mtk_cam_s_data_get_ctx(s_data);
+	cam = ctx->cam;
+	req = mtk_cam_s_data_get_req(s_data);
+
+	/* Update ctx->sensor for switch sensor cases */
+	if (s_data->seninf_new)
+		mtk_cam_update_sensor(ctx, s_data->sensor);
+
+	dev_dbg(cam->dev, "%s:%s:ctx(%d) req(%d):sensor try set start\n",
+		__func__, req->req.debug_str, ctx->stream_id, s_data->frame_seq_no);
+
+	if (ctx->used_raw_num && mtk_cam_req_frame_sync_start(req))
+		dev_dbg(cam->dev, "%s:%s:ctx(%d): sensor ctrl with frame sync - start\n",
+			__func__, req->req.debug_str, ctx->stream_id);
+
+	if (mtk_cam_is_mstream(ctx))
+		is_mstream_last_exposure =
+			mtk_cam_set_sensor_mstream_exposure(ctx, s_data);
+
+	/* request setup*/
+	/* 1st frame sensor setting in mstream is treated like normal frame and is set with
+	 * other settings like max fps.
+	 * 2nd is special, only expsure is set.
+	 */
+	if (!mtk_cam_is_m2m(ctx) && !is_mstream_last_exposure) {
+		if (s_data->flags & MTK_CAM_REQ_S_DATA_FLAG_SENSOR_HDL_EN) {
+			v4l2_ctrl_request_setup(&req->req,
+						s_data->sensor->ctrl_handler);
+			time_after_sof =
+				ktime_get_boottime_ns() / 1000000 - ctx->sensor_ctrl.sof_time;
+			dev_dbg(cam->dev,
+				"[SOF+%dms] Sensor request:%d[ctx:%d] setup\n",
+				time_after_sof, s_data->frame_seq_no,
+				ctx->stream_id);
+		}
+	}
+
+	if (mtk_cam_is_subsample(ctx))
+		state_transition(&s_data->state,
+		E_STATE_SUBSPL_OUTER, E_STATE_SUBSPL_SENSOR);
+	else if (mtk_cam_is_time_shared(ctx))
+		state_transition(&s_data->state,
+		E_STATE_TS_READY, E_STATE_TS_SENSOR);
+	else
+		state_transition(&s_data->state,
+		E_STATE_READY, E_STATE_SENSOR);
+
+	if (ctx->used_raw_num && mtk_cam_req_frame_sync_end(req))
+		dev_dbg(cam->dev, "%s:ctx(%d): sensor ctrl with frame sync - stop\n",
+			__func__, ctx->stream_id);
+
+	if (ctx->used_raw_num) {
+		raw_dev = get_main_raw_dev(ctx->cam, ctx->pipe);
+		if (atomic_read(&raw_dev->vf_en) == 0 &&
+			ctx->sensor_ctrl.initial_cq_done == 1 &&
+			s_data->frame_seq_no == 1)
+			mtk_cam_stream_on(raw_dev, ctx);
+	}
+
+	if (mtk_cam_feature_change_is_mstream(
+				s_data->feature.switch_feature_type)) {
+		/* mstream mode off */
+		if (s_data->feature.switch_feature_type ==
+				(EXPOSURE_CHANGE_2_to_1 | MSTREAM_EXPOSURE_CHANGE))
+			mtk_cam_set_sensor_mstream_mode(ctx, 0);
+	}
+
+	dev_dbg(cam->dev, "%s:%s:ctx(%d)req(%d):sensor done at SOF+%dms\n",
+		__func__, req->req.debug_str, ctx->stream_id,
+		s_data->frame_seq_no, time_after_sof);
+
+	mtk_cam_complete_sensor_hdl(s_data);
+
+	/* time sharing sv wdma flow - stream on at 1st request*/
+	if (mtk_cam_is_time_shared(ctx) &&
+		s_data->frame_seq_no == 1) {
+		unsigned int hw_scen =
+			(1 << MTKCAM_IPI_HW_PATH_OFFLINE_M2M);
+		for (sv_i = MTKCAM_SUBDEV_CAMSV_END - 1;
+			sv_i >= MTKCAM_SUBDEV_CAMSV_START; sv_i--)
+			if (ctx->pipe->enabled_raw & (1 << sv_i))
+				mtk_cam_sv_dev_stream_on(ctx, sv_i - MTKCAM_SUBDEV_CAMSV_START,
+							 1, hw_scen);
+	}
+}
+
+static void mtk_cam_try_set_sensor_subspl(struct mtk_cam_ctx *ctx)
+{
+	struct mtk_cam_request_stream_data *req_stream_data;
+	struct mtk_camsys_sensor_ctrl *sensor_ctrl = &ctx->sensor_ctrl;
+	int sensor_seq_no_next =
+		atomic_read(&sensor_ctrl->sensor_request_seq_no) + 1;
+
+	dev_dbg(ctx->cam->dev, "[%s:check] sensor_no:%d isp_no:%d\n", __func__,
+			sensor_seq_no_next, atomic_read(&sensor_ctrl->isp_request_seq_no));
+	req_stream_data = mtk_cam_get_req_s_data(ctx,
+			ctx->stream_id, sensor_seq_no_next);
+
+	if (req_stream_data && (sensor_seq_no_next > 1)) {
+		if (req_stream_data->state.estate == E_STATE_SUBSPL_OUTER) {
+			dev_dbg(ctx->cam->dev, "[%s:setup] sensor_no:%d stream_no:%d\n", __func__,
+				sensor_seq_no_next, req_stream_data->frame_seq_no);
+			mtk_cam_set_sensor_subspl(req_stream_data, &ctx->sensor_ctrl);
+		} else if (req_stream_data->state.estate == E_STATE_SUBSPL_SCQ) {
+			dev_dbg(ctx->cam->dev, "[%s:setup:SCQ] sensor_no:%d stream_no:%d\n",
+				__func__, sensor_seq_no_next, req_stream_data->frame_seq_no);
+		}
+	}
+}
+
+static void mtk_cam_try_set_sensor(struct mtk_cam_ctx *ctx)
+{
+	struct mtk_camsys_sensor_ctrl *sensor_ctrl = &ctx->sensor_ctrl;
+	struct mtk_cam_device *cam = ctx->cam;
+	struct mtk_cam_request_stream_data *req_stream_data;
+	struct mtk_camsys_ctrl_state *state_entry;
+	struct mtk_cam_request *req;
+	int sensor_seq_no_next =
+		atomic_read(&sensor_ctrl->sensor_request_seq_no) + 1;
+	int time_after_sof = ktime_get_boottime_ns() / 1000000 -
+			   ctx->sensor_ctrl.sof_time;
+	/*for 1st unsync, sensor setting will be set at enque thread*/
+	if (ctx->used_raw_num) {
+		if (MTK_CAM_INITIAL_REQ_SYNC == 0 &&
+				ctx->pipe->feature_active == 0 &&
+				sensor_seq_no_next <= 2) {
+			return;
+		}
+	} else {
+		if (MTK_CAM_INITIAL_REQ_SYNC == 0 &&
+				sensor_seq_no_next <= 2) {
+			return;
+		}
+	}
+	spin_lock(&sensor_ctrl->camsys_state_lock);
+	/* Check if previous state was without cq done */
+	list_for_each_entry(state_entry, &sensor_ctrl->camsys_state_list,
+			    state_element) {
+		req_stream_data = mtk_cam_ctrl_state_to_req_s_data(state_entry);
+		if (req_stream_data->frame_seq_no ==
+			atomic_read(&sensor_ctrl->sensor_request_seq_no)) {
+			if (state_entry->estate == E_STATE_CQ && USINGSCQ &&
+			    req_stream_data->frame_seq_no > INITIAL_DROP_FRAME_CNT &&
+			    !mtk_cam_is_stagger(ctx)) {
+				state_entry->estate = E_STATE_CQ_SCQ_DELAY;
+				spin_unlock(&sensor_ctrl->camsys_state_lock);
+				dev_dbg(ctx->cam->dev,
+					 "[%s] SCQ DELAY STATE at SOF+%dms\n", __func__,
+					 time_after_sof);
+				return;
+			} else if (state_entry->estate == E_STATE_CAMMUX_OUTER_CFG) {
+				state_entry->estate = E_STATE_CAMMUX_OUTER_CFG_DELAY;
+				dev_dbg(ctx->cam->dev,
+					"[%s] CAMMUX OUTTER CFG DELAY STATE\n", __func__);
+				spin_unlock(&sensor_ctrl->camsys_state_lock);
+				return;
+
+			} else if (state_entry->estate <= E_STATE_SENSOR) {
+				spin_unlock(&sensor_ctrl->camsys_state_lock);
+				dev_dbg(ctx->cam->dev,
+					 "[%s] wrong state:%d (sensor workqueue delay)\n",
+					 __func__, state_entry->estate);
+				return;
+			}
+		} else if (req_stream_data->frame_seq_no ==
+			atomic_read(&sensor_ctrl->sensor_request_seq_no) - 1) {
+			if (state_entry->estate < E_STATE_INNER) {
+				spin_unlock(&sensor_ctrl->camsys_state_lock);
+				dev_dbg(ctx->cam->dev,
+					 "[%s] req:%d isn't arrive inner at SOF+%dms\n",
+					 __func__, req_stream_data->frame_seq_no, time_after_sof);
+				return;
+			}
+		}
+	}
+	spin_unlock(&sensor_ctrl->camsys_state_lock);
+
+	/** Frame sync:
+	 * make sure the all ctxs of previous request are triggered
+	 */
+	req_stream_data = mtk_cam_get_req_s_data(ctx, ctx->stream_id,
+						 sensor_seq_no_next - 1);
+	if (req_stream_data) {
+		req = mtk_cam_s_data_get_req(req_stream_data);
+		/* fs complete: fs.target <= off and on == off */
+		if (!(req->fs.target <= req->fs.off_cnt &&
+		      req->fs.off_cnt == req->fs.on_cnt)) {
+			dev_info(ctx->cam->dev,
+				 "[TimerIRQ] ctx:%d the fs of req(%s/%d) is not completed, target/on/off(%d/%d/%d)\n",
+				 ctx->stream_id, req->req.debug_str,
+				 sensor_seq_no_next - 1, req->fs.target,
+				 req->fs.on_cnt, req->fs.off_cnt);
+			return;
+		}
+	}
+
+	req_stream_data =  mtk_cam_get_req_s_data(ctx, ctx->stream_id, sensor_seq_no_next);
+	if (req_stream_data) {
+		req = mtk_cam_s_data_get_req(req_stream_data);
+		if (req->ctx_used & (1 << req_stream_data->pipe_id) &&
+		    req->ctx_link_update & (1 << req_stream_data->pipe_id)) {
+			if (mtk_cam_is_mstream(ctx)) {
+				struct mtk_cam_request_stream_data *req_stream_data;
+
+				req_stream_data = mtk_cam_req_get_s_data(req, ctx->stream_id, 1);
+				if (sensor_seq_no_next == req_stream_data->frame_seq_no) {
+					dev_info(ctx->cam->dev,
+						"[TimerIRQ] state:%d, mstream sensor switch s_data(1st exp), mtk_cam_set_sensor_full is not triggered by timer\n",
+						state_entry->estate);
+					return;
+				}
+			} else {
+				dev_info(ctx->cam->dev,
+					"[TimerIRQ] state:%d, sensor switch s_data, mtk_cam_set_sensor_full is not triggered by timer\n",
+					state_entry->estate);
+				return;
+			}
+		}
+
+		mtk_cam_set_sensor_full(req_stream_data, &ctx->sensor_ctrl);
+		dev_dbg(cam->dev,
+			"%s:[TimerIRQ [SOF+%dms]:] ctx:%d, sensor_req_seq_no:%d\n",
+			__func__, time_after_sof, ctx->stream_id, sensor_seq_no_next);
+	} else {
+		dev_dbg(cam->dev,
+			"%s:[TimerIRQ [SOF+%dms]] ctx:%d, empty req_queue, sensor_req_seq_no:%d\n",
+			__func__, time_after_sof, ctx->stream_id,
+			atomic_read(&sensor_ctrl->sensor_request_seq_no));
+	}
+}
+
+static void mtk_cam_sensor_worker_in_sensorctrl(struct kthread_work *work)
+{
+	struct mtk_camsys_sensor_ctrl *sensor_ctrl =
+			container_of(work, struct mtk_camsys_sensor_ctrl, work);
+	struct mtk_cam_ctx *ctx;
+
+	ctx = sensor_ctrl->ctx;
+	if (mtk_cam_is_subsample(ctx))
+		mtk_cam_try_set_sensor_subspl(ctx);
+	else
+		mtk_cam_try_set_sensor(ctx);
+}
+
+bool mtk_cam_submit_kwork_in_sensorctrl(struct kthread_worker *worker,
+				 struct mtk_camsys_sensor_ctrl *sensor_ctrl)
+{
+	if (!worker) {
+		pr_info("%s: not queue work since kthread_worker is null\n",
+			__func__);
+
+		return false;
+	}
+
+	return kthread_queue_work(worker, &sensor_ctrl->work);
+}
+
+//TODO by wiki : a lot of change in this function
+static enum hrtimer_restart sensor_set_handler(struct hrtimer *t)
+{
+	struct mtk_camsys_sensor_ctrl *sensor_ctrl =
+		container_of(t, struct mtk_camsys_sensor_ctrl,
+			     sensor_deadline_timer);
+
+	mtk_cam_submit_kwork_in_sensorctrl(sensor_ctrl->sensorsetting_wq,
+				     sensor_ctrl);
+
+	return HRTIMER_NORESTART;
+}
+
+static enum hrtimer_restart sensor_deadline_timer_handler(struct hrtimer *t)
+{
+	unsigned int i;
+	unsigned int enq_no, sen_no;
+	struct mtk_camsys_sensor_ctrl *sensor_ctrl =
+		container_of(t, struct mtk_camsys_sensor_ctrl,
+			     sensor_deadline_timer);
+	struct mtk_cam_ctx *ctx = sensor_ctrl->ctx;
+	struct mtk_cam_device *cam = ctx->cam;
+	struct mtk_camsv_device *camsv_dev;
+	ktime_t m_kt;
+	int time_after_sof = ktime_get_boottime_ns() / 1000000 -
+			   sensor_ctrl->sof_time;
+	bool drained_res = false;
+
+	sensor_ctrl->sensor_deadline_timer.function = sensor_set_handler;
+
+	m_kt = ktime_set(0, sensor_ctrl->timer_req_sensor * 1000000);
+
+	if (ctx->used_raw_num) {
+		/* handle V4L2_EVENT_REQUEST_DRAINED event */
+		drained_res = mtk_cam_request_drained(sensor_ctrl);
+	}
+	for (i = 0; i < ctx->used_sv_num; i++) {
+		camsv_dev = dev_get_drvdata(cam->sv.devs[ctx->sv_pipe[i]->id -
+					    MTKCAM_SUBDEV_CAMSV_START]);
+		dev_dbg(camsv_dev->dev, "[SOF+%dms]\n", time_after_sof);
+		/* handle V4L2_EVENT_REQUEST_DRAINED event */
+		mtk_cam_sv_request_drained(camsv_dev, sensor_ctrl);
+	}
+	if (mtk_cam_is_subsample(ctx)) {
+		dev_dbg(cam->dev,
+			"[TimerIRQ [SOF+%dms]] ctx:%d, isp_enq_seq_no:%d\n",
+			time_after_sof, ctx->stream_id,
+			atomic_read(&sensor_ctrl->isp_enq_seq_no));
+		return HRTIMER_NORESTART;
+	}
+	dev_dbg(cam->dev,
+			"[TimerIRQ [SOF+%dms]] ctx:%d, sensor_req_seq_no:%d\n",
+			time_after_sof, ctx->stream_id,
+			atomic_read(&sensor_ctrl->sensor_request_seq_no));
+	if (drained_res == 0) {
+		sen_no = atomic_read(&sensor_ctrl->sensor_enq_seq_no);
+		enq_no = atomic_read(&ctx->enqueued_frame_seq_no);
+		if (enq_no == sen_no) {
+			mtk_cam_submit_kwork_in_sensorctrl(
+			sensor_ctrl->sensorsetting_wq, sensor_ctrl);
+			return HRTIMER_NORESTART;
+		}
+		dev_dbg(cam->dev,
+			"[TimerIRQ [SOF+%dms]] ctx:%d, enq:%d/sensor_enq:%d\n",
+			time_after_sof, ctx->stream_id, enq_no, sen_no);
+	}
+	/*using enque timing for sensor setting*/
+	if (ctx->used_raw_num) {
+		if (ctx->pipe->feature_active == 0) {
+			int drained_seq_no =
+				atomic_read(&sensor_ctrl->sensor_request_seq_no) + 1;
+			atomic_set(&sensor_ctrl->last_drained_seq_no, drained_seq_no);
+			return HRTIMER_NORESTART;
+		}
+	}
+	hrtimer_forward_now(&sensor_ctrl->sensor_deadline_timer, m_kt);
+
+	return HRTIMER_RESTART;
+}
+
+static void mtk_cam_sof_timer_setup(struct mtk_cam_ctx *ctx)
+{
+	struct mtk_camsys_sensor_ctrl *sensor_ctrl = &ctx->sensor_ctrl;
+	ktime_t m_kt;
+	int after_sof_ms = ktime_get_boottime_ns() / 1000000
+			- sensor_ctrl->sof_time;
+
+	//sensor_ctrl->sof_time = ktime_get_boottime_ns() / 1000000;
+	sensor_ctrl->sensor_deadline_timer.function =
+		sensor_deadline_timer_handler;
+	sensor_ctrl->ctx = ctx;
+	if (after_sof_ms < 0)
+		after_sof_ms = 0;
+	else if (after_sof_ms > sensor_ctrl->timer_req_event)
+		after_sof_ms = sensor_ctrl->timer_req_event - 1;
+	m_kt = ktime_set(0, sensor_ctrl->timer_req_event * 1000000
+			- after_sof_ms * 1000000);
+	hrtimer_start(&sensor_ctrl->sensor_deadline_timer, m_kt,
+		      HRTIMER_MODE_REL);
+}
+
+static void
+mtk_cam_set_timestamp(struct mtk_cam_request_stream_data *stream_data,
+		      u64 time_boot,
+		      u64 time_mono)
+{
+	stream_data->timestamp = time_boot;
+	stream_data->timestamp_mono = time_mono;
+}
+
+static int mtk_camsys_raw_subspl_state_handle(struct mtk_raw_device *raw_dev,
+				   struct mtk_camsys_sensor_ctrl *sensor_ctrl,
+		struct mtk_camsys_ctrl_state **current_state,
+		struct mtk_camsys_irq_info *irq_info)
+{
+	struct mtk_cam_ctx *ctx = sensor_ctrl->ctx;
+	struct mtk_camsys_ctrl_state *state_temp, *state_outer = NULL;
+	struct mtk_camsys_ctrl_state *state_ready = NULL;
+	struct mtk_camsys_ctrl_state *state_rec[STATE_NUM_AT_SOF];
+	struct mtk_cam_request *req;
+	struct mtk_cam_request_stream_data *req_stream_data;
+	int frame_idx_inner = irq_info->frame_idx_inner;
+	int stateidx;
+	int que_cnt = 0;
+	u64 time_boot = ktime_get_boottime_ns();
+	u64 time_mono = ktime_get_ns();
+	/* add apply sub sample state list*/
+	mtk_cam_subspl_req_prepare(sensor_ctrl);
+	/* List state-queue status*/
+	spin_lock(&sensor_ctrl->camsys_state_lock);
+	list_for_each_entry(state_temp, &sensor_ctrl->camsys_state_list,
+			    state_element) {
+		req = mtk_cam_ctrl_state_get_req(state_temp);
+		req_stream_data = mtk_cam_req_get_s_data(req, ctx->stream_id, 0);
+		stateidx = atomic_read(&sensor_ctrl->isp_enq_seq_no) + 1 -
+			   req_stream_data->frame_seq_no;
+		if (stateidx < STATE_NUM_AT_SOF && stateidx > -1) {
+			state_rec[stateidx] = state_temp;
+			/* Find outer state element */
+			if (state_temp->estate == E_STATE_SUBSPL_SENSOR ||
+				state_temp->estate == E_STATE_SUBSPL_OUTER) {
+				state_outer = state_temp;
+				mtk_cam_set_timestamp(req_stream_data,
+						      time_boot, time_mono);
+			}
+			if (state_temp->estate == E_STATE_SUBSPL_READY ||
+				state_temp->estate == E_STATE_SUBSPL_SCQ_DELAY) {
+				state_ready = state_temp;
+			}
+			dev_dbg(raw_dev->dev,
+			"[SOF-subsample] STATE_CHECK [N-%d] Req:%d / State:0x%x\n",
+			stateidx, req_stream_data->frame_seq_no,
+			state_rec[stateidx]->estate);
+		}
+		/* counter for state queue*/
+		que_cnt++;
+	}
+	spin_unlock(&sensor_ctrl->camsys_state_lock);
+	/* HW imcomplete case */
+	if (que_cnt >= STATE_NUM_AT_SOF)
+		dev_dbg(raw_dev->dev, "[SOF-subsample] HW_DELAY state\n");
+	/* Trigger high resolution timer to try sensor setting */
+	sensor_ctrl->sof_time = ktime_get_boottime_ns() / 1000000;
+	/*check if no dbload happended*/
+	if (state_ready && sensor_ctrl->sensorsetting_wq) {
+		req_stream_data = mtk_cam_ctrl_state_to_req_s_data(state_ready);
+		if (atomic_read(&sensor_ctrl->initial_drop_frame_cnt) == 0 &&
+			irq_info->frame_idx > frame_idx_inner) {
+			dev_info(raw_dev->dev,
+				"[SOF-noDBLOAD] HW delay outer_no:%d, inner_idx:%d <= processing_idx:%d,ts:%llu\n",
+				req_stream_data->frame_seq_no, frame_idx_inner,
+				atomic_read(&sensor_ctrl->isp_request_seq_no),
+				irq_info->ts_ns / 1000);
+			return STATE_RESULT_PASS_CQ_HW_DELAY;
+		}
+	}
+	mtk_cam_sof_timer_setup(ctx);
+	/* Transit outer state to inner state */
+	if (state_outer && sensor_ctrl->sensorsetting_wq) {
+		req = mtk_cam_ctrl_state_get_req(state_outer);
+		req_stream_data = mtk_cam_req_get_s_data(req, ctx->stream_id, 0);
+		if (req_stream_data->frame_seq_no == frame_idx_inner) {
+			if (frame_idx_inner > atomic_read(&sensor_ctrl->isp_request_seq_no)) {
+				if (state_outer->estate == E_STATE_SUBSPL_OUTER) {
+					mtk_cam_submit_kwork_in_sensorctrl(
+						sensor_ctrl->sensorsetting_wq, sensor_ctrl);
+					dev_dbg(raw_dev->dev, "sensor delay to SOF\n");
+				}
+				state_transition(state_outer, E_STATE_SUBSPL_SENSOR,
+						 E_STATE_SUBSPL_INNER);
+				atomic_set(&sensor_ctrl->isp_request_seq_no, frame_idx_inner);
+				dev_dbg(raw_dev->dev,
+					"[SOF-subsample] frame_seq_no:%d, SENSOR/OUTER->INNER state:0x%x\n",
+					req_stream_data->frame_seq_no, state_outer->estate);
+			}
+		}
+	}
+	/* Initial request case */
+	if (atomic_read(&sensor_ctrl->sensor_request_seq_no) <
+		INITIAL_DROP_FRAME_CNT) {
+		atomic_set(&sensor_ctrl->isp_request_seq_no, frame_idx_inner);
+		dev_dbg(raw_dev->dev, "[SOF-subsample] INIT STATE cnt:%d\n", que_cnt);
+		if (que_cnt > 0 && state_ready)
+			state_transition(state_ready, E_STATE_SUBSPL_READY,
+					 E_STATE_SUBSPL_SCQ);
+		return STATE_RESULT_PASS_CQ_INIT;
+	}
+	if (que_cnt > 0 && state_ready) {
+		/* CQ triggering judgment*/
+		if (state_ready->estate == E_STATE_SUBSPL_READY) {
+			*current_state = state_ready;
+			return STATE_RESULT_TRIGGER_CQ;
+		}
+		/* last SCQ triggering delay judgment*/
+		if (state_ready->estate == E_STATE_SUBSPL_SCQ_DELAY) {
+			dev_dbg(raw_dev->dev, "[SOF-subsample] SCQ_DELAY state:0x%x\n",
+				state_ready->estate);
+			return STATE_RESULT_PASS_CQ_SCQ_DELAY;
+		}
+	}
+
+	return STATE_RESULT_PASS_CQ_SW_DELAY;
+}
+
+static int mtk_camsys_raw_state_handle(struct mtk_raw_device *raw_dev,
+				   struct mtk_camsys_sensor_ctrl *sensor_ctrl,
+		struct mtk_camsys_ctrl_state **current_state,
+		struct mtk_camsys_irq_info *irq_info)
+{
+	struct mtk_cam_ctx *ctx = sensor_ctrl->ctx;
+	struct mtk_camsys_ctrl_state *state_temp, *state_outer = NULL;
+	struct mtk_camsys_ctrl_state *state_inner = NULL;
+	struct mtk_camsys_ctrl_state *state_rec[STATE_NUM_AT_SOF];
+	struct mtk_cam_request_stream_data *req_stream_data;
+	int frame_idx_inner = irq_info->frame_idx_inner;
+	int stateidx;
+	int que_cnt = 0;
+	int write_cnt;
+	u64 time_boot = ktime_get_boottime_ns();
+	u64 time_mono = ktime_get_ns();
+	int working_req_found = 0;
+	int switch_type;
+
+	/* List state-queue status*/
+	spin_lock(&sensor_ctrl->camsys_state_lock);
+	list_for_each_entry(state_temp, &sensor_ctrl->camsys_state_list,
+			    state_element) {
+		req_stream_data = mtk_cam_ctrl_state_to_req_s_data(state_temp);
+		stateidx = atomic_read(&sensor_ctrl->sensor_request_seq_no) -
+			   req_stream_data->frame_seq_no;
+		if (stateidx < STATE_NUM_AT_SOF && stateidx > -1) {
+			state_rec[stateidx] = state_temp;
+			if (stateidx == 0)
+				working_req_found = 1;
+			/* Find outer state element */
+			if (state_temp->estate == E_STATE_OUTER ||
+				state_temp->estate == E_STATE_CAMMUX_OUTER ||
+			    state_temp->estate == E_STATE_OUTER_HW_DELAY) {
+				state_outer = state_temp;
+				mtk_cam_set_timestamp(req_stream_data,
+						      time_boot, time_mono);
+			}
+			/* Find inner state element request*/
+			if (state_temp->estate == E_STATE_INNER ||
+			    state_temp->estate == E_STATE_INNER_HW_DELAY) {
+				state_inner = state_temp;
+			}
+			dev_dbg(raw_dev->dev,
+			"[SOF] STATE_CHECK [N-%d] Req:%d / State:%d\n",
+			stateidx, req_stream_data->frame_seq_no,
+			state_rec[stateidx]->estate);
+		}
+		/* counter for state queue*/
+		que_cnt++;
+	}
+	spin_unlock(&sensor_ctrl->camsys_state_lock);
+	/* HW imcomplete case */
+	if (state_inner) {
+		req_stream_data = mtk_cam_ctrl_state_to_req_s_data(state_inner);
+		write_cnt = (atomic_read(&sensor_ctrl->isp_request_seq_no) / 256)
+					* 256 + irq_info->write_cnt;
+		if (frame_idx_inner > atomic_read(&sensor_ctrl->isp_request_seq_no) ||
+			atomic_read(&req_stream_data->frame_done_work.is_queued) == 1) {
+			dev_dbg_ratelimited(raw_dev->dev, "[SOF] frame done work too late frames. req(%d),ts(%llu)\n",
+				req_stream_data->frame_seq_no, irq_info->ts_ns / 1000);
+		} else if (mtk_cam_is_stagger(ctx)) {
+			dev_dbg(raw_dev->dev, "[SOF:%d] HDR SWD over SOF case\n", frame_idx_inner);
+		} else if (write_cnt >= req_stream_data->frame_seq_no) {
+			dev_info_ratelimited(raw_dev->dev, "[SOF] frame done reading lost %d frames. req(%d),ts(%llu)\n",
+				write_cnt - req_stream_data->frame_seq_no + 1,
+				req_stream_data->frame_seq_no, irq_info->ts_ns / 1000);
+			mtk_cam_set_timestamp(req_stream_data,
+						      time_boot - 1000, time_mono - 1000);
+			mtk_camsys_frame_done(ctx, write_cnt, ctx->stream_id);
+		} else if ((write_cnt >= req_stream_data->frame_seq_no - 1)
+			&& irq_info->fbc_cnt == 0) {
+			dev_info_ratelimited(raw_dev->dev, "[SOF] frame done reading lost frames. req(%d),ts(%llu)\n",
+				req_stream_data->frame_seq_no, irq_info->ts_ns / 1000);
+			mtk_cam_set_timestamp(req_stream_data,
+						      time_boot - 1000, time_mono - 1000);
+			mtk_camsys_frame_done(ctx, write_cnt + 1, ctx->stream_id);
+		} else {
+			state_transition(state_inner, E_STATE_INNER,
+				 E_STATE_INNER_HW_DELAY);
+			if (state_outer) {
+				state_transition(state_outer, E_STATE_OUTER,
+				 E_STATE_OUTER_HW_DELAY);
+				state_transition(state_outer, E_STATE_CAMMUX_OUTER,
+				 E_STATE_OUTER_HW_DELAY);
+			}
+			dev_info_ratelimited(raw_dev->dev,
+				"[SOF] HW_IMCOMPLETE state cnt(%d,%d),req(%d),ts(%llu)\n",
+				write_cnt, irq_info->write_cnt, req_stream_data->frame_seq_no,
+				irq_info->ts_ns / 1000);
+			return STATE_RESULT_PASS_CQ_HW_DELAY;
+		}
+	}
+	/* Transit outer state to inner state */
+	if (state_outer && sensor_ctrl->sensorsetting_wq) {
+		req_stream_data = mtk_cam_ctrl_state_to_req_s_data(state_outer);
+		if (atomic_read(&sensor_ctrl->initial_drop_frame_cnt) == 0 &&
+			req_stream_data->frame_seq_no > frame_idx_inner) {
+			dev_info(raw_dev->dev,
+				"[SOF-noDBLOAD] HW delay outer_no:%d, inner_idx:%d <= processing_idx:%d,ts:%llu\n",
+				req_stream_data->frame_seq_no, frame_idx_inner,
+				atomic_read(&sensor_ctrl->isp_request_seq_no),
+				irq_info->ts_ns / 1000);
+			return STATE_RESULT_PASS_CQ_HW_DELAY;
+		}
+
+		if (atomic_read(&sensor_ctrl->initial_drop_frame_cnt) == 0 &&
+			req_stream_data->frame_seq_no == frame_idx_inner) {
+			if (frame_idx_inner > atomic_read(&sensor_ctrl->isp_request_seq_no)) {
+				state_transition(state_outer,
+						 E_STATE_OUTER_HW_DELAY,
+						 E_STATE_INNER_HW_DELAY);
+				state_transition(state_outer, E_STATE_OUTER,
+						 E_STATE_INNER);
+				state_transition(state_outer, E_STATE_CAMMUX_OUTER,
+						 E_STATE_INNER);
+				atomic_set(&sensor_ctrl->isp_request_seq_no, frame_idx_inner);
+				dev_dbg(raw_dev->dev,
+					"[SOF-DBLOAD] frame_seq_no:%d, OUTER->INNER state:%d,ts:%llu\n",
+					req_stream_data->frame_seq_no, state_outer->estate,
+					irq_info->ts_ns / 1000);
+			}
+		}
+	}
+	/* Trigger high resolution timer to try sensor setting */
+	sensor_ctrl->sof_time = irq_info->ts_ns / 1000000;
+	mtk_cam_sof_timer_setup(ctx);
+	/* Initial request case - 1st sensor wasn't set yet or initial drop wasn't finished*/
+	if (MTK_CAM_INITIAL_REQ_SYNC) {
+		if (atomic_read(&sensor_ctrl->sensor_request_seq_no)
+			<= INITIAL_DROP_FRAME_CNT ||
+			atomic_read(&sensor_ctrl->initial_drop_frame_cnt)) {
+			dev_dbg(raw_dev->dev, "[SOF] INIT STATE cnt:%d\n", que_cnt);
+			if (que_cnt > 0 && state_rec[0]) {
+				state_temp = state_rec[0];
+				req_stream_data = mtk_cam_ctrl_state_to_req_s_data(state_temp);
+				if (req_stream_data->frame_seq_no == 1)
+					state_transition(state_temp, E_STATE_SENSOR,
+						 E_STATE_OUTER);
+			}
+			return STATE_RESULT_PASS_CQ_INIT;
+		}
+	} else {
+		if (que_cnt > 1 && state_rec[1]) {
+			state_temp = state_rec[1];
+			req_stream_data = mtk_cam_ctrl_state_to_req_s_data(state_temp);
+			if (req_stream_data->frame_seq_no == 1)
+				state_transition(state_temp, E_STATE_SENSOR,
+					 E_STATE_INNER);
+		}
+	}
+	if (que_cnt > 0) {
+		/*handle exposure switch at frame start*/
+		if (working_req_found && state_rec[0]) {
+			req_stream_data = mtk_cam_ctrl_state_to_req_s_data(state_rec[0]);
+			switch_type = req_stream_data->feature.switch_feature_type;
+			if (switch_type &&
+				req_stream_data->feature.switch_done == 0 &&
+				!mtk_cam_feature_change_is_mstream(switch_type)) {
+				int res = 0;
+
+				if (STAGGER_DYNAMIC_SWITCH) {
+					mtk_cam_exp_sensor_switch(ctx, req_stream_data);
+					state_transition(state_rec[0], E_STATE_READY,
+							E_STATE_SENSOR);
+					*current_state = state_rec[0];
+					res = STATE_RESULT_TRIGGER_CQ;
+				} else {
+					/* trigger sensor switch and cam mux switch when*/
+					if (req_stream_data->feature.switch_prev_frame_done) {
+						mtk_cam_exp_sensor_switch(ctx, req_stream_data);
+						state_transition(state_rec[0], E_STATE_READY,
+							 E_STATE_SENSOR);
+						*current_state = state_rec[0];
+						res = STATE_RESULT_TRIGGER_CQ;
+					} else {
+						dev_info(raw_dev->dev, "[switch] prev not done :%llu\n",
+							irq_info->ts_ns / 1000);
+						res = STATE_RESULT_PASS_CQ_SW_DELAY;
+					}
+				}
+				return res;
+			}
+		}
+		if (working_req_found && state_rec[0]) {
+			if (state_rec[0]->estate == E_STATE_READY) {
+				dev_info(raw_dev->dev, "[SOF] sensor delay ts:%llu\n",
+					irq_info->ts_ns / 1000);
+				req_stream_data = mtk_cam_ctrl_state_to_req_s_data(state_rec[0]);
+				req_stream_data->flags |=
+					MTK_CAM_REQ_S_DATA_FLAG_SENSOR_HDL_DELAYED;
+			}
+
+			if (state_rec[0]->estate == E_STATE_SENINF)
+				dev_info(raw_dev->dev, "[SOF] sensor switch delay\n");
+
+			/* CQ triggering judgment*/
+			if (state_rec[0]->estate == E_STATE_SENSOR) {
+				*current_state = state_rec[0];
+				return STATE_RESULT_TRIGGER_CQ;
+			}
+			/* last SCQ triggering delay judgment*/
+			if (state_rec[0]->estate == E_STATE_CQ_SCQ_DELAY) {
+				state_transition(state_rec[0], E_STATE_CQ_SCQ_DELAY,
+						E_STATE_OUTER);
+				dev_info(raw_dev->dev, "[SOF] SCQ_DELAY state:%d ts:%llu\n",
+					state_rec[0]->estate, irq_info->ts_ns / 1000);
+				return STATE_RESULT_PASS_CQ_SCQ_DELAY;
+			}
+		} else {
+			dev_dbg(raw_dev->dev, "[SOF] working request not found\n");
+		}
+	}
+	return STATE_RESULT_PASS_CQ_SW_DELAY;
+}
+
+static void mtk_camsys_ts_sv_done(struct mtk_cam_ctx *ctx,
+				       unsigned int dequeued_frame_seq_no)
+{
+	struct mtk_cam_request *req = NULL;
+	struct mtk_cam_request_stream_data *req_stream_data;
+
+	/* Find request of this sv dequeued frame */
+	req = mtk_cam_get_req(ctx, dequeued_frame_seq_no);
+	if (req != NULL) {
+		req_stream_data = mtk_cam_req_get_s_data(req, ctx->stream_id, 0);
+		state_transition(&req_stream_data->state, E_STATE_TS_SV,
+					E_STATE_TS_MEM);
+		dev_info(ctx->cam->dev,
+		"TS-SVD[ctx:%d-#%d], SV done state:0x%x\n",
+		ctx->stream_id, dequeued_frame_seq_no, req_stream_data->state.estate);
+	}
+}
+
+static void mtk_camsys_ts_raw_try_set(struct mtk_raw_device *raw_dev,
+				       struct mtk_cam_ctx *ctx,
+				       unsigned int dequeued_frame_seq_no)
+{
+	struct mtk_cam_request *req = NULL;
+	struct mtk_cam_request_stream_data *req_stream_data;
+	struct mtk_cam_working_buf_entry *buf_entry;
+	dma_addr_t base_addr;
+
+	/* Find request of this dequeued frame */
+	req = mtk_cam_get_req(ctx, dequeued_frame_seq_no);
+	if (!req) {
+		dev_info(raw_dev->dev,
+			"TS-CQ[ctx:%d-#%d], request drained\n",
+			ctx->stream_id, dequeued_frame_seq_no);
+		return;
+	}
+	req_stream_data = mtk_cam_req_get_s_data(req, ctx->stream_id, 0);
+	if (raw_dev->time_shared_busy ||
+		req_stream_data->state.estate != E_STATE_TS_MEM) {
+		dev_info(raw_dev->dev,
+			"TS-CQ[ctx:%d-#%d], CQ isn't updated [busy:%d/state:0x%x]\n",
+			ctx->stream_id, dequeued_frame_seq_no,
+			raw_dev->time_shared_busy, req_stream_data->state.estate);
+		return;
+	}
+	raw_dev->time_shared_busy = true;
+	/* Update CQ base address if needed */
+	if (ctx->composed_frame_seq_no < dequeued_frame_seq_no) {
+		dev_info(raw_dev->dev,
+			"TS-CQ[ctx:%d-#%d], CQ isn't updated [composed_frame_deq (%d) ]\n",
+			ctx->stream_id, dequeued_frame_seq_no,
+			ctx->composed_frame_seq_no);
+		return;
+	}
+	/* apply next composed buffer */
+	spin_lock(&ctx->composed_buffer_list.lock);
+	if (list_empty(&ctx->composed_buffer_list.list)) {
+		dev_info(raw_dev->dev,
+			"TS-CQ, no buffer update, cq_num:%d, frame_seq:%d\n",
+			ctx->composed_frame_seq_no, dequeued_frame_seq_no);
+		spin_unlock(&ctx->composed_buffer_list.lock);
+	} else {
+		buf_entry = list_first_entry(&ctx->composed_buffer_list.list,
+					     struct mtk_cam_working_buf_entry,
+					     list_entry);
+		list_del(&buf_entry->list_entry);
+		ctx->composed_buffer_list.cnt--;
+		spin_unlock(&ctx->composed_buffer_list.lock);
+		spin_lock(&ctx->processing_buffer_list.lock);
+		list_add_tail(&buf_entry->list_entry,
+			      &ctx->processing_buffer_list.list);
+		ctx->processing_buffer_list.cnt++;
+		spin_unlock(&ctx->processing_buffer_list.lock);
+		base_addr = buf_entry->buffer.iova;
+		apply_cq(raw_dev, 0, base_addr,
+			buf_entry->cq_desc_size,
+			buf_entry->cq_desc_offset,
+			buf_entry->sub_cq_desc_size,
+			buf_entry->sub_cq_desc_offset);
+		state_transition(&req_stream_data->state, E_STATE_TS_MEM,
+						E_STATE_TS_CQ);
+		raw_dev->time_shared_busy_ctx_id = ctx->stream_id;
+		dev_info(raw_dev->dev,
+			"TS-CQ[ctx:%d-#%d], update CQ state:0x%x [composed_req(%d)]\n",
+			ctx->stream_id, dequeued_frame_seq_no, req_stream_data->state.estate,
+			ctx->composed_frame_seq_no);
+	}
+}
+
+static int mtk_camsys_ts_state_handle(
+		struct mtk_camsys_sensor_ctrl *sensor_ctrl,
+		struct mtk_camsys_ctrl_state **current_state,
+		int frame_idx_inner)
+{
+	struct mtk_cam_ctx *ctx = sensor_ctrl->ctx;
+	struct mtk_camsys_ctrl_state *state_temp = NULL;
+	struct mtk_camsys_ctrl_state *state_rec[STATE_NUM_AT_SOF];
+	struct mtk_cam_request *req;
+	struct mtk_cam_request_stream_data *req_stream_data;
+	int stateidx;
+	int que_cnt = 0;
+	u64 time_boot = ktime_get_boottime_ns();
+	u64 time_mono = ktime_get_ns();
+
+	/* List state-queue status*/
+	spin_lock(&sensor_ctrl->camsys_state_lock);
+	list_for_each_entry(state_temp, &sensor_ctrl->camsys_state_list,
+			    state_element) {
+		req = mtk_cam_ctrl_state_get_req(state_temp);
+		req_stream_data = mtk_cam_req_get_s_data(req, ctx->stream_id, 0);
+		stateidx = atomic_read(&sensor_ctrl->sensor_request_seq_no) -
+			   req_stream_data->frame_seq_no;
+		if (stateidx < STATE_NUM_AT_SOF && stateidx > -1) {
+			state_rec[stateidx] = state_temp;
+			if (state_temp->estate == E_STATE_TS_SV) {
+				req_stream_data->timestamp = time_boot;
+				req_stream_data->timestamp_mono = time_mono;
+			}
+			dev_dbg(ctx->cam->dev,
+			"[TS-SOF] ctx:%d STATE_CHECK [N-%d] Req:%d / State:0x%x\n",
+			ctx->stream_id, stateidx, req_stream_data->frame_seq_no,
+			state_rec[stateidx]->estate);
+		}
+		/* counter for state queue*/
+		que_cnt++;
+	}
+	spin_unlock(&sensor_ctrl->camsys_state_lock);
+	if (que_cnt > 0 && state_rec[0]) {
+		if (state_rec[0]->estate == E_STATE_TS_READY) {
+			dev_info(ctx->cam->dev, "[TS-SOF] sensor delay\n");
+			return STATE_RESULT_PASS_CQ_SW_DELAY;
+		}
+	}
+	/* Trigger high resolution timer to try sensor setting */
+	sensor_ctrl->sof_time = ktime_get_boottime_ns() / 1000000;
+	mtk_cam_sof_timer_setup(ctx);
+	if (que_cnt > 0 && state_rec[0]) {
+		/* camsv enque judgment*/
+		if (state_rec[0]->estate == E_STATE_TS_SENSOR) {
+			*current_state = state_rec[0];
+			return STATE_RESULT_TRIGGER_CQ;
+		}
+	}
+
+	return STATE_RESULT_PASS_CQ_SW_DELAY;
+}
+static void mtk_camsys_ts_frame_start(struct mtk_cam_ctx *ctx,
+				       unsigned int dequeued_frame_seq_no)
+{
+	struct mtk_cam_device *cam = ctx->cam;
+	struct mtk_cam_request *req_cq = NULL;
+	struct mtk_cam_request_stream_data *req_stream_data;
+	struct mtk_camsys_sensor_ctrl *sensor_ctrl = &ctx->sensor_ctrl;
+	struct mtk_camsys_ctrl_state *current_state;
+	enum MTK_CAMSYS_STATE_RESULT state_handle_ret;
+	struct mtk_camsv_device *camsv_dev;
+	struct device *dev_sv;
+	int sv_i;
+
+	/* Send V4L2_EVENT_FRAME_SYNC event */
+	mtk_cam_event_frame_sync(ctx->pipe, dequeued_frame_seq_no);
+
+	if (ctx->sensor) {
+		state_handle_ret =
+			mtk_camsys_ts_state_handle(sensor_ctrl,
+						&current_state,
+						dequeued_frame_seq_no);
+		if (state_handle_ret != STATE_RESULT_TRIGGER_CQ) {
+			dev_info(cam->dev, "[TS-SOF] SV-ENQUE drop s:%d deq:%d\n",
+				state_handle_ret, dequeued_frame_seq_no);
+			return;
+		}
+	}
+	/* Transit state from Sensor -> CQ */
+	if (ctx->sensor) {
+		state_transition(current_state,
+			E_STATE_TS_SENSOR, E_STATE_TS_SV);
+		req_cq = mtk_cam_ctrl_state_get_req(current_state);
+		req_stream_data = mtk_cam_req_get_s_data(req_cq, ctx->stream_id, 0);
+		/* time sharing sv wdma flow - stream on at 1st request*/
+		for (sv_i = MTKCAM_SUBDEV_CAMSV_END - 1;
+			sv_i >= MTKCAM_SUBDEV_CAMSV_START; sv_i--) {
+			if (ctx->pipe->enabled_raw & (1 << sv_i)) {
+				dev_sv = cam->sv.devs[sv_i - MTKCAM_SUBDEV_CAMSV_START];
+				camsv_dev = dev_get_drvdata(dev_sv);
+				mtk_cam_sv_enquehwbuf(camsv_dev,
+				req_stream_data->frame_params.img_ins[0].buf[0].iova,
+				req_stream_data->frame_seq_no);
+			}
+		}
+		req_stream_data->timestamp = ktime_get_boottime_ns();
+		dev_dbg(cam->dev,
+		"TS-SOF[ctx:%d-#%d], SV-ENQ req:%d is update, composed:%d, iova:0x%lx, time:%lld\n",
+		ctx->stream_id, dequeued_frame_seq_no, req_stream_data->frame_seq_no,
+		ctx->composed_frame_seq_no,
+		(unsigned long)req_stream_data->frame_params.img_ins[0].buf[0].iova,
+		req_stream_data->timestamp);
+	}
+}
+
+static bool
+mtk_cam_raw_prepare_mstream_frame_done(struct mtk_cam_ctx *ctx,
+				       struct mtk_cam_request_stream_data *req_stream_data)
+{
+	unsigned int frame_undone;
+	struct mtk_cam_device *cam;
+	struct mtk_cam_request_stream_data *s_data;
+	struct mtk_cam_request *state_req;
+	struct mtk_camsys_ctrl_state *state_entry;
+
+	cam = ctx->cam;
+	state_req = mtk_cam_s_data_get_req(req_stream_data);
+	state_entry = &req_stream_data->state;
+	s_data = mtk_cam_req_get_s_data(state_req, ctx->stream_id, 0);
+	if (mtk_cam_feature_is_mstream(s_data->feature.raw_feature) ||
+			mtk_cam_feature_is_mstream_m2m(s_data->feature.raw_feature)) {
+		if (req_stream_data->frame_seq_no == s_data->frame_seq_no)
+			frame_undone = 0;
+		else
+			frame_undone = 1;
+
+		dev_dbg(cam->dev,
+			"[mstream][SWD] req:%d/state:%d/time:%lld/sync_id:%lld/frame_undone:%d\n",
+			req_stream_data->frame_seq_no, state_entry->estate,
+			req_stream_data->timestamp, state_req->sync_id,
+			frame_undone);
+
+		if (frame_undone)
+			return false;
+	} else {
+		dev_dbg(cam->dev, "[mstream][SWD] req:%d/state:%d/time:%lld/sync_id:%lld\n",
+			req_stream_data->frame_seq_no, state_entry->estate,
+			req_stream_data->timestamp,
+			state_req->sync_id);
+	}
+
+	return true;
+}
+
+static void mtk_cam_mstream_frame_sync(struct mtk_raw_device *raw_dev,
+					struct mtk_cam_ctx *ctx,
+					unsigned int dequeued_frame_seq_no)
+{
+	struct mtk_cam_request *req;
+
+	req = mtk_cam_get_req(ctx, dequeued_frame_seq_no);
+	if (req) {
+		struct mtk_cam_request_stream_data *s_data =
+			mtk_cam_req_get_s_data(req, ctx->stream_id, 0);
+
+		if (mtk_cam_feature_is_mstream(s_data->feature.raw_feature) ||
+				mtk_cam_feature_is_mstream_m2m(s_data->feature.raw_feature)) {
+			/* report on first exp */
+			s_data = mtk_cam_req_get_s_data(req, ctx->stream_id, 1);
+			if (dequeued_frame_seq_no == s_data->frame_seq_no) {
+				dev_dbg(raw_dev->dev,
+					"%s mstream [SOF] with-req frame:%d sof:%d enque_req_cnt:%d\n",
+					__func__, dequeued_frame_seq_no,
+					req->p_data[ctx->stream_id].req_seq,
+					ctx->enqueued_request_cnt);
+				ctx->next_sof_mask_frame_seq_no =
+					dequeued_frame_seq_no + 1;
+				ctx->working_request_seq =
+					req->p_data[ctx->stream_id].req_seq;
+				mtk_cam_event_frame_sync(ctx->pipe,
+					req->p_data[ctx->stream_id].req_seq);
+			} else if (dequeued_frame_seq_no ==
+				ctx->next_sof_mask_frame_seq_no) {
+				dev_dbg(raw_dev->dev, "mstream [SOF-mask] with-req frame:%d working_seq:%d, sof_cnt:%lld\n",
+					dequeued_frame_seq_no, ctx->working_request_seq,
+					raw_dev->sof_count);
+				ctx->next_sof_mask_frame_seq_no = 1;
+			} else {
+				dev_dbg(raw_dev->dev, "mstream [SOF] with-req frame:%d\n",
+					ctx->working_request_seq);
+				mtk_cam_event_frame_sync(ctx->pipe,
+					ctx->working_request_seq);
+			}
+		} else {
+			/* mstream 1exp case */
+			dev_dbg(raw_dev->dev,
+					"%s mstream 1-exp [SOF] with-req frame:%d sof:%d enque_req_cnt:%d\n",
+					__func__, dequeued_frame_seq_no,
+					req->p_data[ctx->stream_id].req_seq,
+					ctx->enqueued_request_cnt);
+			ctx->working_request_seq =
+				req->p_data[ctx->stream_id].req_seq;
+			mtk_cam_event_frame_sync(ctx->pipe,
+				req->p_data[ctx->stream_id].req_seq);
+		}
+	} else if (dequeued_frame_seq_no ==
+			ctx->next_sof_mask_frame_seq_no) {
+		/* when frame request is already remove sof_done case */
+		dev_dbg(raw_dev->dev, "mstream [SOF-mask] req-gone frame:%d sof:%d sof_cnt:%lld\n",
+			ctx->next_sof_mask_frame_seq_no, ctx->working_request_seq,
+			raw_dev->sof_count);
+		ctx->next_sof_mask_frame_seq_no = 1;
+	} else {
+		/* except: keep report current working request sequence */
+		dev_dbg(raw_dev->dev, "mstream [SOF] req-gone frame:%d\n",
+			ctx->working_request_seq);
+		mtk_cam_event_frame_sync(ctx->pipe,
+				ctx->working_request_seq);
+	}
+}
+
+static void mtk_cam_handle_m2m_frame_done(struct mtk_cam_ctx *ctx,
+			      unsigned int dequeued_frame_seq_no,
+			      unsigned int pipe_id)
+{
+	struct mtk_raw_device *raw_dev = NULL;
+	struct mtk_camsys_ctrl_state *state_temp, *state_inner = NULL;
+	struct mtk_camsys_ctrl_state *state_sensor = NULL;
+	struct mtk_cam_request *req;
+	struct mtk_cam_request_stream_data *req_stream_data;
+	struct mtk_cam_working_buf_entry *buf_entry;
+	struct mtk_camsys_sensor_ctrl *sensor_ctrl = &ctx->sensor_ctrl;
+	dma_addr_t base_addr;
+	int que_cnt = 0;
+	u64 time_boot = ktime_get_boottime_ns();
+	u64 time_mono = ktime_get_ns();
+	int dequeue_cnt;
+
+	spin_lock(&ctx->streaming_lock);
+	if (!ctx->streaming) {
+		dev_dbg(ctx->cam->dev,
+			 "%s: skip frame done for stream off ctx:%d\n",
+			 __func__, ctx->stream_id);
+		spin_unlock(&ctx->streaming_lock);
+		return;
+	}
+	spin_unlock(&ctx->streaming_lock);
+
+	raw_dev = get_main_raw_dev(ctx->cam, ctx->pipe);
+
+	/* Send V4L2_EVENT_FRAME_SYNC event */
+	if (mtk_cam_is_mstream_m2m(ctx) || ctx->next_sof_mask_frame_seq_no != 0)
+		mtk_cam_mstream_frame_sync(raw_dev, ctx, dequeued_frame_seq_no);
+	else
+		mtk_cam_event_frame_sync(ctx->pipe, dequeued_frame_seq_no);
+
+	/* No SOF in M2M, so we update ctx's dequeued_frame_seq_no here */
+	ctx->dequeued_frame_seq_no = dequeued_frame_seq_no;
+
+	/* List state-queue status*/
+	spin_lock(&sensor_ctrl->camsys_state_lock);
+	list_for_each_entry(state_temp, &sensor_ctrl->camsys_state_list,
+			    state_element) {
+		req = mtk_cam_ctrl_state_get_req(state_temp);
+		req_stream_data = mtk_cam_req_get_s_data(req, ctx->stream_id, 0);
+
+		if (state_temp->estate == E_STATE_INNER && state_inner == NULL)
+			state_inner = state_temp;
+		else if (state_temp->estate == E_STATE_SENSOR && state_sensor == NULL)
+			state_sensor = state_temp;
+		/* counter for state queue*/
+		que_cnt++;
+	}
+	spin_unlock(&sensor_ctrl->camsys_state_lock);
+
+	/* Transit inner state to done state */
+	if (state_inner) {
+		req = mtk_cam_ctrl_state_get_req(state_inner);
+		req_stream_data = mtk_cam_req_get_s_data(req, ctx->stream_id, 0);
+
+		dev_dbg(raw_dev->dev,
+			"[M2M P1 Don] req_stream_data->frame_seq_no:%d dequeued_frame_seq_no:%d\n",
+			req_stream_data->frame_seq_no, dequeued_frame_seq_no);
+
+		if (req_stream_data->frame_seq_no == dequeued_frame_seq_no) {
+			state_transition(state_inner, E_STATE_INNER,
+			      E_STATE_DONE_NORMAL);
+			atomic_set(&sensor_ctrl->isp_request_seq_no, dequeued_frame_seq_no);
+			dev_dbg(raw_dev->dev,
+			      "[Frame done] frame_seq_no:%d, INNER->DONE_NORMAL state:%d\n",
+			      req_stream_data->frame_seq_no, state_inner->estate);
+		}
+	}
+
+	req_stream_data = mtk_cam_get_req_s_data(ctx, ctx->stream_id,
+						dequeued_frame_seq_no);
+	if (mtk_cam_is_mstream_m2m(ctx)) {
+		if (mtk_cam_raw_prepare_mstream_frame_done(ctx, req_stream_data)) {
+			dequeue_cnt = mtk_cam_dequeue_req_frame(ctx,
+					dequeued_frame_seq_no, ctx->stream_id);
+		}
+	} else {
+		dequeue_cnt = mtk_cam_dequeue_req_frame(ctx,
+				dequeued_frame_seq_no, ctx->stream_id);
+	}
+	complete(&ctx->m2m_complete);
+
+	/* apply next composed buffer */
+	spin_lock(&ctx->composed_buffer_list.lock);
+	dev_dbg(raw_dev->dev,
+		"[M2M check next action] que_cnt:%d composed_buffer_list.cnt:%d\n",
+		que_cnt, ctx->composed_buffer_list.cnt);
+
+	if (list_empty(&ctx->composed_buffer_list.list)) {
+		dev_info(raw_dev->dev,
+			"[M2M] no buffer, cq_num:%d, frame_seq:%d, composed_buffer_list.cnt :%d\n",
+			ctx->composed_frame_seq_no, dequeued_frame_seq_no,
+			ctx->composed_buffer_list.cnt);
+		spin_unlock(&ctx->composed_buffer_list.lock);
+	} else {
+		buf_entry = list_first_entry(&ctx->composed_buffer_list.list,
+					     struct mtk_cam_working_buf_entry,
+					     list_entry);
+		list_del(&buf_entry->list_entry);
+		ctx->composed_buffer_list.cnt--;
+		spin_unlock(&ctx->composed_buffer_list.lock);
+		spin_lock(&ctx->processing_buffer_list.lock);
+		list_add_tail(&buf_entry->list_entry,
+			      &ctx->processing_buffer_list.list);
+		ctx->processing_buffer_list.cnt++;
+
+		dev_dbg(raw_dev->dev,
+			"[M2M P1 Don] ctx->processing_buffer_list.cnt:%d\n",
+			ctx->processing_buffer_list.cnt);
+
+		spin_unlock(&ctx->processing_buffer_list.lock);
+
+		base_addr = buf_entry->buffer.iova;
+
+		if (state_sensor == NULL) {
+			dev_info(raw_dev->dev, "[M2M P1 Don] Invalid state_sensor\n");
+			return;
+		}
+
+		req = mtk_cam_ctrl_state_get_req(state_sensor);
+		req_stream_data = mtk_cam_req_get_s_data(req, ctx->stream_id, 0);
+		req_stream_data->timestamp = time_boot;
+		req_stream_data->timestamp_mono = time_mono;
+
+		apply_cq(raw_dev, 0, base_addr,
+			buf_entry->cq_desc_size,
+			buf_entry->cq_desc_offset,
+			buf_entry->sub_cq_desc_size,
+			buf_entry->sub_cq_desc_offset);
+		/* Transit state from Sensor -> CQ */
+		if (ctx->sensor) {
+			state_transition(state_sensor, E_STATE_SENSOR, E_STATE_CQ);
+
+			dev_dbg(raw_dev->dev,
+			"M2M apply_cq [ctx:%d-#%d], CQ-%d, composed:%d, cq_addr:0x%llx\n",
+			ctx->stream_id, dequeued_frame_seq_no, req_stream_data->frame_seq_no,
+			ctx->composed_frame_seq_no, base_addr);
+
+			dev_dbg(raw_dev->dev,
+			"M2M apply_cq: composed_buffer_list.cnt:%d time:%lld, monotime:%lld\n",
+			ctx->composed_buffer_list.cnt, req_stream_data->timestamp,
+			req_stream_data->timestamp_mono);
+		}
+	}
+
+	if (dequeue_cnt) {
+		mutex_lock(&ctx->cam->queue_lock);
+		mtk_cam_dev_req_try_queue(ctx->cam);
+		mutex_unlock(&ctx->cam->queue_lock);
+	}
+}
+static bool hdr_apply_cq_at_first_sof(struct mtk_raw_device *raw_dev,
+				       struct mtk_camsys_ctrl_state *cur_state,
+				       int state_ret)
+{
+	struct mtk_cam_request_stream_data *s_data;
+
+	/*hd last sof trigger setting enable*/
+	if (!cur_state)
+		return true;
+	s_data = mtk_cam_ctrl_state_to_req_s_data(cur_state);
+	if (!s_data)
+		return true;
+	if (raw_dev->stagger_en) {
+		atomic_set(&s_data->first_setting_check, 1);
+		if (STAGGER_CQ_LAST_SOF == 0)
+			return true;
+		else
+			return false;
+	}
+
+	return true;
+}
+
+static void mtk_camsys_raw_frame_start(struct mtk_raw_device *raw_dev,
+				       struct mtk_cam_ctx *ctx,
+				       struct mtk_camsys_irq_info *irq_info)
+{
+	unsigned int dequeued_frame_seq_no = irq_info->frame_idx_inner;
+	struct mtk_cam_request_stream_data *req_stream_data;
+	struct mtk_camsys_sensor_ctrl *sensor_ctrl = &ctx->sensor_ctrl;
+	struct mtk_cam_working_buf_entry *buf_entry;
+	struct mtk_camsys_ctrl_state *current_state;
+	dma_addr_t base_addr;
+	enum MTK_CAMSYS_STATE_RESULT state_handle_ret;
+	bool is_apply = false;
+
+	/*touch watchdog*/
+	if (watchdog_scenario(ctx))
+		mtk_ctx_watchdog_kick(ctx);
+	/* inner register dequeue number */
+	if (!mtk_cam_is_stagger(ctx))
+		ctx->dequeued_frame_seq_no = dequeued_frame_seq_no;
+	/* Send V4L2_EVENT_FRAME_SYNC event */
+	if (mtk_cam_is_mstream(ctx) || ctx->next_sof_mask_frame_seq_no != 0) {
+		mtk_cam_mstream_frame_sync(raw_dev, ctx, dequeued_frame_seq_no);
+	} else {
+		/* normal */
+		mtk_cam_event_frame_sync(ctx->pipe, dequeued_frame_seq_no);
+	}
+
+	/* Find request of this dequeued frame */
+	req_stream_data = mtk_cam_get_req_s_data(ctx, ctx->stream_id, dequeued_frame_seq_no);
+
+	/* Detect no frame done and trigger camsys dump for debugging */
+	mtk_cam_debug_detect_dequeue_failed(req_stream_data, 30, irq_info, raw_dev);
+	if (ctx->sensor) {
+		if (mtk_cam_is_subsample(ctx))
+			state_handle_ret =
+			mtk_camsys_raw_subspl_state_handle(raw_dev, sensor_ctrl,
+						&current_state, irq_info);
+		else
+			state_handle_ret =
+			mtk_camsys_raw_state_handle(raw_dev, sensor_ctrl,
+						&current_state, irq_info);
+		if (state_handle_ret != STATE_RESULT_TRIGGER_CQ) {
+			dev_dbg(raw_dev->dev, "[SOF] CQ drop s:%d deq:%d\n",
+				state_handle_ret, dequeued_frame_seq_no);
+#ifdef ISP7_1
+			if (ctx->pipe->stagger_path == STAGGER_DCIF) {
+				//mtk_camsys_hdr_dcif_enquesv();
+				struct mtk_cam_img_working_buf_entry *buf_entry;
+				struct mtk_camsv_device *camsv_dev;
+				struct device *dev_sv;
+				int sv_i;
+
+				for (sv_i = MTKCAM_SUBDEV_CAMSV_START;
+					sv_i < MTKCAM_SUBDEV_CAMSV_END ; sv_i++) {
+					if (ctx->pipe->enabled_raw & (1 << sv_i)) {
+						dev_sv = ctx->cam->sv.devs[sv_i
+							- MTKCAM_SUBDEV_CAMSV_START];
+						camsv_dev = dev_get_drvdata(dev_sv);
+						/* prepare working buffer */
+						buf_entry = mtk_cam_img_working_buf_get(ctx);
+						mtk_cam_sv_enquehwbuf(camsv_dev,
+							buf_entry->img_buffer.iova,
+							dequeued_frame_seq_no);
+						dev_info(camsv_dev->dev,
+						"[%s] dcif stagger workaround camsv id:%d/iova:0x%lx\n",
+						__func__, camsv_dev->id,
+						(unsigned long)buf_entry->img_buffer.iova);
+						mtk_cam_img_working_buf_put(buf_entry);
+					}
+				}
+			}
+#endif
+			return;
+		}
+		if (!hdr_apply_cq_at_first_sof(raw_dev, current_state, state_handle_ret))
+			return;
+	}
+	/* Update CQ base address if needed */
+	if (ctx->composed_frame_seq_no <= dequeued_frame_seq_no) {
+		dev_info_ratelimited(raw_dev->dev,
+			"SOF[ctx:%d-#%d], CQ isn't updated [composed_frame_deq (%d) ts:%llu]\n",
+			ctx->stream_id, dequeued_frame_seq_no,
+			ctx->composed_frame_seq_no, irq_info->ts_ns / 1000);
+		return;
+	}
+	/* apply next composed buffer */
+	spin_lock(&ctx->composed_buffer_list.lock);
+	if (list_empty(&ctx->composed_buffer_list.list)) {
+		dev_info_ratelimited(raw_dev->dev,
+			"SOF_INT_ST, no buffer update, cq_num:%d, frame_seq:%d, ts:%llu\n",
+			ctx->composed_frame_seq_no, dequeued_frame_seq_no,
+			irq_info->ts_ns / 1000);
+		spin_unlock(&ctx->composed_buffer_list.lock);
+	} else {
+		is_apply = true;
+		buf_entry = list_first_entry(&ctx->composed_buffer_list.list,
+					     struct mtk_cam_working_buf_entry,
+					     list_entry);
+		list_del(&buf_entry->list_entry);
+		ctx->composed_buffer_list.cnt--;
+		spin_unlock(&ctx->composed_buffer_list.lock);
+		spin_lock(&ctx->processing_buffer_list.lock);
+		list_add_tail(&buf_entry->list_entry,
+			      &ctx->processing_buffer_list.list);
+		ctx->processing_buffer_list.cnt++;
+		spin_unlock(&ctx->processing_buffer_list.lock);
+		base_addr = buf_entry->buffer.iova;
+		apply_cq(raw_dev, 0, base_addr,
+			buf_entry->cq_desc_size,
+			buf_entry->cq_desc_offset,
+			buf_entry->sub_cq_desc_size,
+			buf_entry->sub_cq_desc_offset);
+
+		/* req_stream_data of req_cq*/
+		req_stream_data = mtk_cam_ctrl_state_to_req_s_data(current_state);
+		/* Transit state from Sensor -> CQ */
+		if (ctx->sensor) {
+			if (mtk_cam_is_subsample(ctx))
+				state_transition(current_state,
+				E_STATE_SUBSPL_READY, E_STATE_SUBSPL_SCQ);
+			else
+				state_transition(current_state,
+				E_STATE_SENSOR, E_STATE_CQ);
+
+			dev_dbg(raw_dev->dev,
+			"SOF[ctx:%d-#%d], CQ-%d is update, composed:%d, cq_addr:0x%llx, time:%lld, monotime:%lld\n",
+			ctx->stream_id, dequeued_frame_seq_no, req_stream_data->frame_seq_no,
+			ctx->composed_frame_seq_no, base_addr, req_stream_data->timestamp,
+			req_stream_data->timestamp_mono);
+		}
+	}
+
+	if (mtk_cam_is_with_w_channel(ctx) && is_apply) {
+		if (mtk_cam_sv_rgbw_apply_next_buffer(buf_entry->s_data) == 0)
+			dev_info(raw_dev->dev, "rgbw: sv apply next buffer failed");
+	}
+	if (ctx->used_sv_num && is_apply) {
+		if (mtk_cam_sv_apply_all_buffers(ctx, irq_info->ts_ns) == 0)
+			dev_info(raw_dev->dev, "sv apply next buffer failed");
+	}
+}
+
+static int mtk_cam_hdr_last_frame_switch_check(
+		struct mtk_camsys_ctrl_state *state,
+		struct mtk_cam_request_stream_data *req_stream_data)
+{
+	int type = req_stream_data->feature.switch_feature_type;
+
+	if ((type == EXPOSURE_CHANGE_2_to_1 ||
+		type == EXPOSURE_CHANGE_3_to_1) &&
+			req_stream_data->feature.switch_done == 0) {
+		return 1;
+	} else if ((type == EXPOSURE_CHANGE_1_to_2 ||
+				type == EXPOSURE_CHANGE_1_to_3) &&
+				state->estate > E_STATE_SENSOR &&
+				state->estate < E_STATE_CAMMUX_OUTER) {
+		return 1;
+	}
+
+	return 0;
+}
+
+static int hdr_apply_cq_at_last_sof(struct mtk_raw_device *raw_dev,
+			struct mtk_cam_ctx *ctx,
+			struct mtk_camsys_ctrl_state *state_sensor,
+			struct mtk_camsys_irq_info *irq_info)
+{
+	struct mtk_cam_working_buf_entry *buf_entry;
+	struct mtk_cam_request_stream_data *s_data;
+	dma_addr_t base_addr;
+	bool is_apply = false;
+	unsigned int dequeued_frame_seq_no = irq_info->frame_idx_inner;
+
+	/*hd last sof trigger setting enable*/
+	if (STAGGER_CQ_LAST_SOF == 0)
+		return 0;
+	/*if db load judgment*/
+	if (ctx->sensor_ctrl.sensorsetting_wq) {
+		if (atomic_read(&ctx->sensor_ctrl.initial_drop_frame_cnt) == 0 &&
+			irq_info->frame_idx > dequeued_frame_seq_no) {
+			dev_info(raw_dev->dev,
+				"[SOF-noDBLOAD] HW delay outer_no:%d, inner_idx:%d <= processing_idx:%d\n",
+				irq_info->frame_idx, dequeued_frame_seq_no,
+				atomic_read(&ctx->sensor_ctrl.isp_request_seq_no));
+			return 0;
+		}
+	}
+	/* Update CQ base address if needed */
+	if (ctx->composed_frame_seq_no <= dequeued_frame_seq_no) {
+		dev_info_ratelimited(raw_dev->dev,
+			"SOF[ctx:%d-#%d], CQ isn't updated [composed_frame_deq (%d) ]\n",
+			ctx->stream_id, dequeued_frame_seq_no,
+			ctx->composed_frame_seq_no);
+		return 0;
+	}
+	if (!state_sensor)
+		return 0;
+	s_data = mtk_cam_ctrl_state_to_req_s_data(state_sensor);
+	/* apply next composed buffer */
+	spin_lock(&ctx->composed_buffer_list.lock);
+	if (list_empty(&ctx->composed_buffer_list.list)) {
+		dev_info(raw_dev->dev,
+			"SOF_INT_ST, no buffer update, cq_num:%d, frame_seq:%d\n",
+			ctx->composed_frame_seq_no, dequeued_frame_seq_no);
+		spin_unlock(&ctx->composed_buffer_list.lock);
+	} else if (!atomic_read(&s_data->first_setting_check) &&
+			s_data->feature.switch_feature_type == 0) {
+		dev_info(raw_dev->dev,
+			"SOF_INT_ST, 1st cq check failed, cq_num:%d, frame_seq:%d\n",
+			ctx->composed_frame_seq_no, dequeued_frame_seq_no);
+			spin_unlock(&ctx->composed_buffer_list.lock);
+	} else {
+		is_apply = true;
+		buf_entry = list_first_entry(&ctx->composed_buffer_list.list,
+					     struct mtk_cam_working_buf_entry,
+					     list_entry);
+		list_del(&buf_entry->list_entry);
+		ctx->composed_buffer_list.cnt--;
+		spin_unlock(&ctx->composed_buffer_list.lock);
+		spin_lock(&ctx->processing_buffer_list.lock);
+		list_add_tail(&buf_entry->list_entry,
+			      &ctx->processing_buffer_list.list);
+		ctx->processing_buffer_list.cnt++;
+		spin_unlock(&ctx->processing_buffer_list.lock);
+		base_addr = buf_entry->buffer.iova;
+		apply_cq(raw_dev, 0, base_addr,
+			buf_entry->cq_desc_size,
+			buf_entry->cq_desc_offset,
+			buf_entry->sub_cq_desc_size,
+			buf_entry->sub_cq_desc_offset);
+
+		/* req_stream_data of req_cq*/
+
+		/* Transit state from Sensor -> CQ */
+		if (ctx->sensor) {
+			state_transition(state_sensor,
+				E_STATE_SENSOR, E_STATE_CQ);
+		}
+	}
+
+	if (mtk_cam_is_with_w_channel(ctx) && is_apply) {
+		if (mtk_cam_sv_rgbw_apply_next_buffer(buf_entry->s_data) == 0)
+			dev_info(raw_dev->dev, "rgbw: sv apply next buffer failed");
+	}
+	if (ctx->used_sv_num && is_apply) {
+		if (mtk_cam_sv_apply_all_buffers(ctx, irq_info->ts_ns) == 0)
+			dev_info(raw_dev->dev, "sv apply next buffer failed");
+	}
+
+	return 0;
+}
+
+static int mtk_cam_hdr_last_frame_start(struct mtk_raw_device *raw_dev,
+			struct mtk_cam_ctx *ctx,
+			struct mtk_camsys_irq_info *irq_info)
+{
+	struct mtk_camsys_sensor_ctrl *sensor_ctrl = &ctx->sensor_ctrl;
+	struct mtk_camsys_ctrl_state *state_temp;
+	struct mtk_camsys_ctrl_state *state_switch = NULL;
+	struct mtk_camsys_ctrl_state *state_sensor = NULL;
+	struct mtk_cam_request *req;
+	struct mtk_cam_request_stream_data *req_stream_data;
+	int stateidx;
+	int que_cnt = 0;
+#ifdef ISP7_1
+	struct mtk_camsys_ctrl_state *state_cq = NULL;
+#endif
+
+	//TODO by wiki: no need to call mtk_camsys_raw_frame_start()??
+	sensor_ctrl->ctx->dequeued_frame_seq_no = irq_info->frame_idx_inner;
+
+	/* List state-queue status*/
+	spin_lock(&sensor_ctrl->camsys_state_lock);
+	list_for_each_entry(state_temp, &sensor_ctrl->camsys_state_list,
+			    state_element) {
+		req = mtk_cam_ctrl_state_get_req(state_temp);
+		req_stream_data = mtk_cam_req_get_s_data(req, ctx->stream_id, 0);
+
+		stateidx = atomic_read(&sensor_ctrl->sensor_request_seq_no) -
+			req_stream_data->frame_seq_no;
+
+		if (stateidx < STATE_NUM_AT_SOF && stateidx > -1) {
+			/* Find sensor element for last sof cq*/
+			if (state_temp->estate == E_STATE_SENSOR)
+				state_sensor = state_temp;
+			/*Find switch element*/
+			if (mtk_cam_hdr_last_frame_switch_check(state_temp,
+				req_stream_data)) {
+				state_switch = state_temp;
+				state_sensor = state_temp;
+			}
+#ifdef ISP7_1
+			/*Find CQ element for DCIF stagger*/
+			if (state_temp->estate == E_STATE_CQ)
+				state_cq = state_temp;
+#endif
+			dev_dbg(ctx->cam->dev,
+				"[%s] STATE_CHECK [N-%d] Req:%d / State:%d\n",
+				__func__, stateidx,
+				req_stream_data->frame_seq_no, state_temp->estate);
+		}
+		/* counter for state queue*/
+		que_cnt++;
+	}
+	spin_unlock(&sensor_ctrl->camsys_state_lock);
+	/*1-exp - as normal mode*/
+	if (!raw_dev->stagger_en && !state_switch) {
+		mtk_camsys_raw_frame_start(raw_dev, ctx, irq_info);
+		return 0;
+	}
+	/* trigger sensor switch and cam mux switch when*/
+	if (state_switch && STAGGER_DYNAMIC_SWITCH == 0) {
+		req = mtk_cam_ctrl_state_get_req(state_switch);
+		req_stream_data = mtk_cam_req_get_s_data(req, ctx->stream_id, 0);
+		if (req_stream_data->feature.switch_prev_frame_done == 0) {
+			dev_info(raw_dev->dev, "[%s] prev not done :%llu\n",
+			__func__, irq_info->ts_ns / 1000);
+			return 0;
+		}
+	}
+	/*HDR to Normal cam mux switch case timing will be at last sof*/
+	if (state_switch) {
+		req = mtk_cam_ctrl_state_get_req(state_switch);
+		req_stream_data = mtk_cam_req_get_s_data(req, ctx->stream_id, 0);
+#ifdef ISP7_1
+		if (STAGGER_CQ_LAST_SOF == 1 &&
+			(req_stream_data->feature.switch_feature_type == EXPOSURE_CHANGE_2_to_1 ||
+			req_stream_data->feature.switch_feature_type == EXPOSURE_CHANGE_3_to_1))
+			mtk_cam_exp_switch_sensor(req_stream_data);
+#endif
+		mtk_camsys_exp_switch_cam_mux(raw_dev, ctx, req_stream_data);
+		dev_info(ctx->cam->dev,
+			"[%s] switch Req:%d / State:%d\n",
+			__func__, req_stream_data->frame_seq_no, state_switch->estate);
+	}
+#ifdef ISP7_1
+	if (ctx->pipe->stagger_path == STAGGER_DCIF && state_cq) {
+		req_stream_data = mtk_cam_ctrl_state_to_req_s_data(state_cq);
+		if (req_stream_data->frame_seq_no == irq_info->frame_idx_inner) {
+			state_transition(state_cq, E_STATE_CQ, E_STATE_INNER);
+			dev_info(ctx->cam->dev,
+			"[%s] dcif stagger Req:%d / State:%d\n",
+			__func__, req_stream_data->frame_seq_no, state_cq->estate);
+		}
+	}
+#endif
+	/*if need apply cq at last sof*/
+	hdr_apply_cq_at_last_sof(raw_dev, ctx,
+		state_sensor, irq_info);
+
+	return 0;
+}
+
+static void mtk_cam_seamless_switch_work(struct work_struct *work)
+{
+	struct mtk_cam_req_work *req_work = (struct mtk_cam_req_work *)work;
+	struct mtk_cam_request *req;
+	struct mtk_cam_request_stream_data *s_data;
+	struct mtk_cam_ctx *ctx;
+	struct mtk_cam_device *cam;
+	char *debug_str;
+	struct v4l2_subdev_format fmt;
+	unsigned int time_after_sof = 0;
+
+	s_data = mtk_cam_req_work_get_s_data(req_work);
+	if (!s_data) {
+		pr_info("%s mtk_cam_req_work(%p), req_stream_data(%p), dropped\n",
+			__func__, req_work, s_data);
+		return;
+	}
+
+	req = mtk_cam_s_data_get_req(s_data);
+	if (!req) {
+		pr_info("%s s_data(%p), req(%p), dropped\n",
+			__func__, s_data, req);
+		return;
+	}
+	debug_str = req->req.debug_str;
+
+	ctx = mtk_cam_s_data_get_ctx(s_data);
+	if (!ctx) {
+		pr_info("%s s_data(%p), ctx(%p), dropped\n",
+			__func__, s_data, ctx);
+		return;
+	}
+	cam = ctx->cam;
+	fmt.which = V4L2_SUBDEV_FORMAT_ACTIVE;
+	fmt.pad = 0;
+	fmt.format = s_data->seninf_fmt.format;
+	v4l2_subdev_call(ctx->sensor, pad, set_fmt, NULL, &fmt);
+	dev_dbg(cam->dev,
+		"%s:ctx(%d):sd(%s):%s:seq(%d): apply sensor fmt, pad:%d set format w/h/code %d/%d/0x%x\n",
+		__func__, ctx->stream_id, ctx->sensor->name, debug_str, s_data->frame_seq_no,
+		fmt.pad, s_data->seninf_fmt.format.width,
+		s_data->seninf_fmt.format.height,
+		s_data->seninf_fmt.format.code);
+
+	if (mtk_cam_req_frame_sync_start(req))
+		dev_dbg(cam->dev, "%s:%s:ctx(%d): sensor ctrl with frame sync - start\n",
+			__func__, req->req.debug_str, ctx->stream_id);
+
+	if (s_data->flags & MTK_CAM_REQ_S_DATA_FLAG_SENSOR_HDL_EN) {
+		v4l2_ctrl_request_setup(&req->req, s_data->sensor->ctrl_handler);
+		time_after_sof =
+			ktime_get_boottime_ns() / 1000000 - ctx->sensor_ctrl.sof_time;
+		dev_dbg(cam->dev,
+			"%s:ctx(%d):sd(%s):%s:seq(%d):[SOF+%dms] Sensor request setup\n",
+			__func__, ctx->stream_id, ctx->sensor->name, debug_str,
+			s_data->frame_seq_no, time_after_sof);
+
+	}
+
+	if (mtk_cam_req_frame_sync_end(req))
+		dev_dbg(cam->dev, "%s:ctx(%d): sensor ctrl with frame sync - stop\n",
+			__func__, ctx->stream_id);
+
+	fmt.which = V4L2_SUBDEV_FORMAT_ACTIVE;
+	fmt.pad = PAD_SINK;
+	fmt.format = s_data->seninf_fmt.format;
+	v4l2_subdev_call(ctx->pipe->res_config.seninf,
+			       pad, set_fmt, NULL, &fmt);
+	dev_dbg(cam->dev,
+		"%s:ctx(%d):sd(%s):%s:seq(%d): apply seninf fmt, pad:%d set format w/h/code %d/%d/0x%x\n",
+		__func__, ctx->stream_id, ctx->pipe->res_config.seninf->name,
+		debug_str, s_data->frame_seq_no,
+		fmt.pad,
+		s_data->seninf_fmt.format.width,
+		s_data->seninf_fmt.format.height,
+		s_data->seninf_fmt.format.code);
+
+	fmt.which = V4L2_SUBDEV_FORMAT_ACTIVE;
+	fmt.pad = PAD_SRC_RAW0;
+	fmt.format = s_data->seninf_fmt.format;
+	v4l2_subdev_call(ctx->pipe->res_config.seninf,
+			       pad, set_fmt, NULL, &fmt);
+	dev_dbg(cam->dev,
+		"%s:ctx(%d):sd(%s):%s:seq(%d): apply seninf fmt, pad:%d set format w/h/code %d/%d/0x%x\n",
+		__func__, ctx->stream_id, ctx->pipe->res_config.seninf->name,
+		debug_str, s_data->frame_seq_no,
+		fmt.pad,
+		s_data->seninf_fmt.format.width,
+		s_data->seninf_fmt.format.height,
+		s_data->seninf_fmt.format.code);
+
+	dev_info(cam->dev,
+		 "%s:ctx(%d):sd(%s):%s:seq(%d): sensor done\n", __func__,
+		 ctx->stream_id, ctx->sensor->name, debug_str,
+		 s_data->frame_seq_no);
+
+	mtk_cam_complete_sensor_hdl(s_data);
+
+	state_transition(&s_data->state, E_STATE_CAMMUX_OUTER_CFG, E_STATE_CAMMUX_OUTER);
+	state_transition(&s_data->state, E_STATE_CAMMUX_OUTER_CFG_DELAY, E_STATE_INNER);
+}
+
+static void mtk_cam_handle_seamless_switch(struct mtk_cam_request_stream_data *s_data)
+{
+	struct mtk_cam_ctx *ctx = mtk_cam_s_data_get_ctx(s_data);
+	struct mtk_cam_device *cam = ctx->cam;
+
+	if (s_data->flags & MTK_CAM_REQ_S_DATA_FLAG_SENSOR_MODE_UPDATE_T1) {
+		state_transition(&s_data->state, E_STATE_OUTER, E_STATE_CAMMUX_OUTER_CFG);
+		INIT_WORK(&s_data->seninf_s_fmt_work.work, mtk_cam_seamless_switch_work);
+		queue_work(cam->link_change_wq, &s_data->seninf_s_fmt_work.work);
+	}
+}
+
+static void mtk_cam_link_change_worker(struct work_struct *work)
+{
+	struct mtk_cam_request *req =
+		container_of(work, struct mtk_cam_request, link_work);
+	mtk_cam_req_seninf_change(req);
+	req->flags |= MTK_CAM_REQ_FLAG_SENINF_CHANGED;
+}
+
+// TODO(mstream): check mux switch case
+static void mtk_cam_handle_mux_switch(struct mtk_raw_device *raw_src,
+				      struct mtk_cam_ctx *ctx,
+				      struct mtk_cam_request *req)
+{
+	struct mtk_cam_device *cam = ctx->cam;
+	struct mtk_raw_device *raw_dev;
+	struct mtk_camsv_device *sv_dev;
+	int i, j, stream_id;
+
+
+	if (!(req->ctx_used & cam->streaming_ctx & req->ctx_link_update))
+		return;
+
+	dev_info(cam->dev, "%s, req->ctx_used:0x%x, req->ctx_link_update:0x%x\n",
+		 __func__, req->ctx_used, req->ctx_link_update);
+
+	if (req->flags & MTK_CAM_REQ_FLAG_SENINF_IMMEDIATE_UPDATE) {
+		for (i = 0; i < cam->max_stream_num; i++) {
+			if ((req->ctx_used & 1 << i) && (req->ctx_link_update & 1 << i)) {
+				stream_id = i;
+				ctx = &cam->ctxs[stream_id];
+				raw_dev = get_main_raw_dev(ctx->cam, ctx->pipe);
+				dev_info(cam->dev, "%s: toggle for rawi\n", __func__);
+
+				enable_tg_db(raw_dev, 0);
+				enable_tg_db(raw_dev, 1);
+				toggle_db(raw_dev);
+
+				for (j = 0; j < ctx->used_sv_num; j++) {
+					sv_dev = get_camsv_dev(cam, ctx->sv_pipe[j]);
+					mtk_cam_sv_toggle_tg_db(sv_dev);
+					mtk_cam_sv_toggle_db(sv_dev);
+				}
+			}
+		}
+
+		INIT_WORK(&req->link_work, mtk_cam_link_change_worker);
+		queue_work(cam->link_change_wq, &req->link_work);
+	}
+}
+
+static void mtk_cam_handle_mstream_mux_switch(struct mtk_raw_device *raw_dev,
+				      struct mtk_cam_ctx *ctx,
+				      struct mtk_cam_request_stream_data *s_data)
+{
+	struct mtk_cam_request *req = mtk_cam_s_data_get_req(s_data);
+	struct mtk_cam_request_stream_data *mstream_s_data;
+	struct mtk_cam_device *cam = ctx->cam;
+
+	if (!(req->ctx_used & cam->streaming_ctx & req->ctx_link_update))
+		return;
+
+	mstream_s_data = mtk_cam_req_get_s_data(req, ctx->stream_id, 1);
+	if (s_data->frame_seq_no != mstream_s_data->frame_seq_no)
+		return;
+
+	mtk_cam_handle_mux_switch(raw_dev, ctx, req);
+}
+
+static void mtk_camsys_raw_m2m_cq_done(struct mtk_raw_device *raw_dev,
+				   struct mtk_cam_ctx *ctx,
+				   unsigned int frame_seq_no_outer)
+{
+	struct mtk_camsys_sensor_ctrl *sensor_ctrl = &ctx->sensor_ctrl;
+	struct mtk_camsys_ctrl_state *state_entry;
+	struct mtk_cam_request *req;
+	struct mtk_cam_request_stream_data *req_stream_data;
+
+	if (frame_seq_no_outer == 1)
+		stream_on(raw_dev, 1);
+
+	dev_dbg(raw_dev->dev,
+		"[M2M CQD] frame_seq_no_outer:%d composed_buffer_list.cnt:%d\n",
+		frame_seq_no_outer, ctx->composed_buffer_list.cnt);
+
+	spin_lock(&sensor_ctrl->camsys_state_lock);
+	list_for_each_entry(state_entry, &sensor_ctrl->camsys_state_list,
+			    state_element) {
+		req = mtk_cam_ctrl_state_get_req(state_entry);
+		req_stream_data = mtk_cam_req_get_s_data(req, ctx->stream_id, 0);
+
+		if (req_stream_data->frame_seq_no == frame_seq_no_outer) {
+			if (frame_seq_no_outer > atomic_read(&sensor_ctrl->isp_request_seq_no)) {
+				/**
+				 * outer number is 1 more from last SOF's
+				 * inner number
+				 */
+				state_transition(state_entry, E_STATE_CQ,
+						E_STATE_OUTER);
+
+				dev_dbg(raw_dev->dev,
+					"[M2M CQD] req:%d, CQ->OUTER state:%d\n",
+					req_stream_data->frame_seq_no, state_entry->estate);
+			}
+		}
+	}
+	spin_unlock(&sensor_ctrl->camsys_state_lock);
+}
+
+static void mtk_camsys_raw_cq_done(struct mtk_raw_device *raw_dev,
+				   struct mtk_cam_ctx *ctx,
+				   unsigned int frame_seq_no_outer)
+{
+	struct mtk_camsys_sensor_ctrl *sensor_ctrl = &ctx->sensor_ctrl;
+	struct mtk_camsys_ctrl_state *state_entry;
+	struct mtk_cam_request *req;
+	struct mtk_cam_request_stream_data *req_stream_data;
+	int feature;
+	int toggle_db_check = false;
+	int type;
+
+	/* initial CQ done */
+	if (raw_dev->sof_count == 0) {
+		sensor_ctrl->initial_cq_done = 1;
+		req_stream_data = mtk_cam_get_req_s_data(ctx, ctx->stream_id, 1);
+		if (req_stream_data->state.estate >= E_STATE_SENSOR ||
+			!ctx->sensor) {
+			mtk_cam_stream_on(raw_dev, ctx);
+		} else {
+			dev_dbg(raw_dev->dev,
+				"[CQD] 1st sensor not set yet, req:%d, state:%d\n",
+				req_stream_data->frame_seq_no, req_stream_data->state.estate);
+		}
+	}
+	/* Legacy CQ done will be always happened at frame done */
+	spin_lock(&sensor_ctrl->camsys_state_lock);
+	list_for_each_entry(state_entry, &sensor_ctrl->camsys_state_list,
+			    state_element) {
+		req_stream_data = mtk_cam_ctrl_state_to_req_s_data(state_entry);
+		req = req_stream_data->req;
+		if (mtk_cam_is_subsample(ctx)) {
+			if (raw_dev->sof_count == 0)
+				state_transition(state_entry, E_STATE_SUBSPL_READY,
+						 E_STATE_SUBSPL_OUTER);
+			if (state_entry->estate >= E_STATE_SUBSPL_SCQ &&
+				state_entry->estate < E_STATE_SUBSPL_INNER) {
+				state_transition(state_entry, E_STATE_SUBSPL_SCQ,
+						 E_STATE_SUBSPL_OUTER);
+				state_transition(state_entry, E_STATE_SUBSPL_SCQ_DELAY,
+						 E_STATE_SUBSPL_OUTER);
+				atomic_set(&sensor_ctrl->isp_enq_seq_no,
+							req_stream_data->frame_seq_no);
+				dev_dbg(raw_dev->dev,
+					"[CQD-subsample] req:%d, CQ->OUTER state:0x%x\n",
+					req_stream_data->frame_seq_no, state_entry->estate);
+			}
+		} else if (mtk_cam_is_time_shared(ctx)) {
+			if (req_stream_data->frame_seq_no == frame_seq_no_outer &&
+				frame_seq_no_outer >
+				atomic_read(&sensor_ctrl->isp_request_seq_no)) {
+				state_transition(state_entry, E_STATE_TS_CQ,
+						E_STATE_TS_INNER);
+				dev_dbg(raw_dev->dev, "[TS-SOF] ctx:%d sw trigger rawi_r2 req:%d->%d, state:0x%x\n",
+						ctx->stream_id, ctx->dequeued_frame_seq_no,
+						req_stream_data->frame_seq_no, state_entry->estate);
+				ctx->dequeued_frame_seq_no = frame_seq_no_outer;
+				writel_relaxed(RAWI_R2_TRIG, raw_dev->base + REG_CTL_RAWI_TRIG);
+				raw_dev->sof_count++;
+				wmb(); /* TBC */
+			}
+		} else if (req_stream_data->frame_seq_no == frame_seq_no_outer) {
+			if (frame_seq_no_outer > atomic_read(&sensor_ctrl->isp_request_seq_no)) {
+				/**
+				 * outer number is 1 more from last SOF's
+				 * inner number
+				 */
+				if (frame_seq_no_outer == 1)
+					state_entry->estate = E_STATE_OUTER;
+				state_transition(state_entry, E_STATE_CQ,
+						 E_STATE_OUTER);
+				state_transition(state_entry, E_STATE_CQ_SCQ_DELAY,
+						 E_STATE_OUTER);
+				state_transition(state_entry, E_STATE_SENINF,
+						 E_STATE_OUTER);
+
+				type = req_stream_data->feature.switch_feature_type;
+				if (type != 0 && (!mtk_cam_is_mstream(ctx) &&
+						!mtk_cam_feature_change_is_mstream(type))) {
+					// check if need to tg db
+					req_stream_data->feature.switch_curr_setting_done = 1;
+					if (!mtk_cam_get_req_s_data(ctx, ctx->stream_id,
+						req_stream_data->frame_seq_no - 1)) {
+						req_stream_data->feature.switch_prev_frame_done = 1;
+						dev_info(raw_dev->dev,
+						"[CQD-switch] req:%d, prev frame is done\n",
+						req_stream_data->frame_seq_no);
+					}
+					feature = req_stream_data->feature.raw_feature;
+					toggle_db_check =
+						req_stream_data->feature.switch_prev_frame_done &&
+						req_stream_data->feature.switch_curr_setting_done;
+				if (type == EXPOSURE_CHANGE_3_to_1 ||
+					type == EXPOSURE_CHANGE_2_to_1)
+					stagger_disable(raw_dev);
+				else if (type == EXPOSURE_CHANGE_1_to_2 ||
+					type == EXPOSURE_CHANGE_1_to_3)
+					stagger_enable(raw_dev);
+				if (toggle_db_check)
+					mtk_cam_hdr_switch_toggle(ctx, feature);
+				dev_dbg(raw_dev->dev,
+					"[CQD-switch] req:%d type:%d\n",
+					req_stream_data->frame_seq_no, type);
+			}
+				dev_dbg(raw_dev->dev,
+					"[CQD] req:%d, CQ->OUTER state:%d\n",
+					req_stream_data->frame_seq_no, state_entry->estate);
+				mtk_cam_handle_seamless_switch(req_stream_data);
+				feature = req_stream_data->feature.raw_feature;
+				if (mtk_cam_feature_is_mstream(feature)) {
+					mtk_cam_handle_mstream_mux_switch(raw_dev,
+									  ctx,
+									  req_stream_data);
+				} else {
+					mtk_cam_handle_mux_switch(raw_dev, ctx, req);
+				}
+			}
+		}
+	}
+	spin_unlock(&sensor_ctrl->camsys_state_lock);
+}
+
+static void mtk_camsys_raw_m2m_trigger(struct mtk_raw_device *raw_dev,
+				   struct mtk_cam_ctx *ctx,
+				   unsigned int frame_seq_no_outer)
+{
+
+	struct mtk_camsys_sensor_ctrl *sensor_ctrl = &ctx->sensor_ctrl;
+	struct mtk_camsys_ctrl_state *state_entry;
+	struct mtk_cam_request *req;
+	struct mtk_cam_request_stream_data *req_stream_data;
+	bool triggered;
+
+	if (!mtk_cam_feature_is_m2m(raw_dev->pipeline->feature_active))
+		return;
+
+	if (!mtk_cam_is_mstream_m2m(ctx))
+		trigger_rawi(raw_dev, ctx, -1);
+
+	spin_lock(&sensor_ctrl->camsys_state_lock);
+	triggered = false;
+
+	list_for_each_entry(state_entry, &sensor_ctrl->camsys_state_list,
+			    state_element) {
+		int s_data_idx, s_data_num;
+
+		req = mtk_cam_ctrl_state_get_req(state_entry);
+		s_data_num = req->p_data[ctx->stream_id].s_data_num;
+
+		for (s_data_idx = 0; s_data_idx < s_data_num; s_data_idx++) {
+			req_stream_data = mtk_cam_req_get_s_data(req,
+								ctx->stream_id,
+								s_data_idx);
+			dev_dbg(raw_dev->dev,
+				"s_data_idx/s_data_num:%d/%d, req_stream_data->frame_seq_no:%d",
+				s_data_idx, s_data_num,
+				req_stream_data->frame_seq_no);
+			if (req_stream_data->frame_seq_no == frame_seq_no_outer) {
+				if (mtk_cam_is_mstream_m2m(ctx)) {
+					if (s_data_idx == 0) {
+						toggle_db(raw_dev);
+						trigger_rawi(raw_dev, ctx,
+							MTKCAM_IPI_HW_PATH_OFFLINE_STAGGER);
+					} else if (s_data_idx == 1) {
+						toggle_db(raw_dev);
+						trigger_rawi(raw_dev, ctx,
+							MTKCAM_IPI_HW_PATH_OFFLINE_M2M);
+					}
+				}
+				/**
+				 * outer number is 1 more from last SOF's
+				 * inner number
+				 */
+				atomic_set(&sensor_ctrl->isp_request_seq_no, frame_seq_no_outer);
+				state_transition(state_entry, E_STATE_OUTER,
+					E_STATE_INNER);
+				dev_dbg(raw_dev->dev,
+					"[SW Trigger] req:%d, M2M CQ->INNER state:%d frame_seq_no:%d\n",
+					req_stream_data->frame_seq_no,
+					state_entry->estate,
+					frame_seq_no_outer);
+				triggered = true;
+				break;
+			}
+		}
+		if (triggered)
+			break;
+	}
+	spin_unlock(&sensor_ctrl->camsys_state_lock);
+}
+
+static bool
+mtk_camsys_raw_prepare_frame_done(struct mtk_raw_device *raw_dev,
+				  struct mtk_cam_ctx *ctx,
+				  unsigned int dequeued_frame_seq_no)
+{
+	struct mtk_cam_device *cam = ctx->cam;
+	struct mtk_camsys_sensor_ctrl *camsys_sensor_ctrl = &ctx->sensor_ctrl;
+	struct mtk_camsys_ctrl_state *state_entry;
+	struct mtk_cam_request *state_req;
+	struct mtk_cam_request_stream_data *s_data;
+
+	if (!ctx->sensor) {
+		dev_info(cam->dev, "%s: no sensor found in ctx:%d, req:%d",
+			__func__, ctx->stream_id, dequeued_frame_seq_no);
+
+		return true;
+	}
+
+	spin_lock(&camsys_sensor_ctrl->camsys_state_lock);
+	/**
+	 * Find inner register number's request and transit to
+	 * STATE_DONE_xxx
+	 */
+	list_for_each_entry(state_entry,
+			    &camsys_sensor_ctrl->camsys_state_list,
+			    state_element) {
+		state_req = mtk_cam_ctrl_state_get_req(state_entry);
+		s_data = mtk_cam_ctrl_state_to_req_s_data(state_entry);
+		if (s_data->frame_seq_no == dequeued_frame_seq_no) {
+			if (mtk_cam_is_subsample(ctx)) {
+				state_transition(state_entry,
+						 E_STATE_SUBSPL_INNER,
+						 E_STATE_SUBSPL_DONE_NORMAL);
+
+				dev_dbg(cam->dev, "[SWD-subspl] req:%d/state:0x%x/time:%lld\n",
+					s_data->frame_seq_no, state_entry->estate,
+					s_data->timestamp);
+			} else if (mtk_cam_is_time_shared(ctx)) {
+				state_transition(state_entry,
+						 E_STATE_TS_INNER,
+						 E_STATE_TS_DONE_NORMAL);
+
+				dev_dbg(cam->dev, "[TS-SWD] ctx:%d req:%d/state:0x%x/time:%lld\n",
+					ctx->stream_id, s_data->frame_seq_no,
+					state_entry->estate, s_data->timestamp);
+			} else {
+				state_transition(state_entry,
+						 E_STATE_INNER_HW_DELAY,
+						 E_STATE_DONE_MISMATCH);
+				state_transition(state_entry, E_STATE_INNER,
+						 E_STATE_DONE_NORMAL);
+
+				if (atomic_read(&camsys_sensor_ctrl->isp_request_seq_no) == 0)
+					state_transition(state_entry,
+					 E_STATE_CQ,
+					 E_STATE_OUTER);
+
+				/* mstream 2 and 1 exposure */
+				if ((mtk_cam_feature_is_mstream(
+					s_data->feature.raw_feature) ||
+					mtk_cam_feature_is_mstream_m2m(
+					s_data->feature.raw_feature)) ||
+				    ctx->next_sof_mask_frame_seq_no != 0) {
+					if (!mtk_cam_raw_prepare_mstream_frame_done
+						(ctx, s_data)) {
+						spin_unlock(&camsys_sensor_ctrl->camsys_state_lock);
+						return false;
+					}
+				} else {
+					dev_dbg(cam->dev,
+						"[SWD] req:%d/state:%d/time:%lld/sync_id:%lld\n",
+						s_data->frame_seq_no,
+						state_entry->estate,
+						s_data->timestamp,
+						state_req->sync_id);
+				}
+			}
+		}
+	}
+	spin_unlock(&camsys_sensor_ctrl->camsys_state_lock);
+
+	return true;
+}
+
+static void
+mtk_camsys_raw_change_pipeline(struct mtk_raw_device *raw_dev,
+			       struct mtk_cam_ctx *ctx,
+			       struct mtk_camsys_sensor_ctrl *sensor_ctrl,
+			       unsigned int dequeued_frame_seq_no)
+{
+	int i;
+	struct mtk_cam_device *cam = raw_dev->cam;
+	struct mtk_cam_request *req;
+	struct mtk_cam_request_stream_data *req_stream_data;
+	int frame_seq = dequeued_frame_seq_no + 1;
+
+	req = mtk_cam_get_req(ctx, frame_seq);
+	if (!req) {
+		dev_dbg(raw_dev->dev, "%s next req (%d) not queued\n", __func__, frame_seq);
+		return;
+	}
+	if (!req->ctx_link_update) {
+		dev_dbg(raw_dev->dev, "%s next req (%d) no link stup\n", __func__, frame_seq);
+		return;
+	}
+	dev_dbg(raw_dev->dev, "%s:req(%d) check: req->ctx_used:0x%x, req->ctx_link_update0x%x\n",
+		__func__, frame_seq, req->ctx_used, req->ctx_link_update);
+	/* Check if all ctx is ready to change link */
+	for (i = 0; i < cam->max_stream_num; i++) {
+		if ((req->ctx_used & 1 << i) && (req->ctx_link_update & (1 << i))) {
+			/**
+			 * Switch cammux double buffer write delay, we have to disable the
+			 * mux (mask the data and sof to raw) and than switch it.
+			 */
+			req_stream_data = mtk_cam_req_get_s_data(req, i, 0);
+			if (req_stream_data->state.estate == E_STATE_CAMMUX_OUTER_CFG_DELAY) {
+				/**
+				 * To be move to the start of frame done hanlding
+				 * INIT_WORK(&req->link_work, mtk_cam_link_change_worker);
+				 * queue_work(cam->link_change_wq, &req->link_work);
+				 */
+				dev_info(raw_dev->dev, "Exchange streams at req(%d), update link ctx (0x%x)\n",
+				frame_seq, req->ctx_link_update);
+				mtk_cam_req_seninf_change(req);
+				return;
+			}
+		}
+	}
+	dev_info(raw_dev->dev, "%s:req(%d) no link update data found!\n",
+		__func__, frame_seq);
+}
+
+static void mtk_cam_handle_frame_done(struct mtk_cam_ctx *ctx,
+				      unsigned int frame_seq_no,
+				      unsigned int pipe_id)
+{
+	struct mtk_raw_device *raw_dev = NULL;
+	bool need_dequeue;
+
+	/**
+	 * If ctx is already off, just return; mtk_cam_dev_req_cleanup()
+	 * triggered by mtk_cam_vb2_stop_streaming() puts the all media
+	 * requests back.
+	 */
+	spin_lock(&ctx->streaming_lock);
+	if (!ctx->streaming) {
+		dev_info(ctx->cam->dev,
+			 "%s: skip frame done for stream off ctx:%d\n",
+			 __func__, ctx->stream_id);
+		spin_unlock(&ctx->streaming_lock);
+		return;
+	}
+	spin_unlock(&ctx->streaming_lock);
+	if (is_camsv_subdev(pipe_id)) {
+		need_dequeue = true;
+	} else {
+		raw_dev = get_main_raw_dev(ctx->cam, ctx->pipe);
+		need_dequeue =
+			mtk_camsys_raw_prepare_frame_done(raw_dev, ctx,
+							  frame_seq_no);
+	}
+
+	if (!need_dequeue)
+		return;
+
+	dev_dbg(ctx->cam->dev, "[%s] job done ctx-%d:pipe-%d:req(%d)\n",
+			 __func__, ctx->stream_id, pipe_id, frame_seq_no);
+	if (mtk_cam_dequeue_req_frame(ctx, frame_seq_no, pipe_id)) {
+		mutex_lock(&ctx->cam->queue_lock);
+		mtk_cam_dev_req_try_queue(ctx->cam);
+		mutex_unlock(&ctx->cam->queue_lock);
+		if (is_raw_subdev(pipe_id))
+			mtk_camsys_raw_change_pipeline(raw_dev, ctx,
+						       &ctx->sensor_ctrl,
+						       frame_seq_no);
+	}
+}
+
+void mtk_cam_meta1_done_work(struct work_struct *work)
+{
+	struct mtk_cam_req_work *meta1_done_work = (struct mtk_cam_req_work *)work;
+	struct mtk_cam_request_stream_data *s_data, *s_data_ctx, *s_data_mstream;
+	struct mtk_cam_ctx *ctx;
+	struct mtk_cam_request *req;
+	struct mtk_cam_buffer *buf;
+	struct vb2_buffer *vb;
+	void *vaddr;
+	bool unreliable = false;
+
+	s_data = mtk_cam_req_work_get_s_data(meta1_done_work);
+	ctx = mtk_cam_s_data_get_ctx(s_data);
+	req = mtk_cam_s_data_get_req(s_data);
+	s_data_ctx = mtk_cam_req_get_s_data(req, ctx->stream_id, 0);
+
+	dev_dbg(ctx->cam->dev, "%s: ctx:%d\n", __func__, ctx->stream_id);
+
+	spin_lock(&ctx->streaming_lock);
+	if (!ctx->streaming) {
+		spin_unlock(&ctx->streaming_lock);
+		dev_info(ctx->cam->dev, "%s: skip for stream off ctx:%d\n",
+			 __func__, ctx->stream_id);
+		return;
+	}
+	spin_unlock(&ctx->streaming_lock);
+
+	if (!s_data) {
+		dev_info(ctx->cam->dev,
+			 "%s:ctx(%d): can't get s_data\n",
+			 __func__, ctx->stream_id);
+		return;
+	}
+
+	if (mtk_cam_is_mstream(ctx)) {
+		s_data_mstream = mtk_cam_req_get_s_data(req, ctx->stream_id, 1);
+
+		unreliable |= (s_data->flags &
+			MTK_CAM_REQ_S_DATA_FLAG_SENSOR_HDL_DELAYED);
+
+		if (s_data_mstream) {
+			unreliable |= (s_data_mstream->flags &
+				MTK_CAM_REQ_S_DATA_FLAG_SENSOR_HDL_DELAYED);
+		}
+	}
+
+	/* Copy the meta1 output content to user buffer */
+	buf = mtk_cam_s_data_get_vbuf(s_data, MTK_RAW_META_OUT_1);
+	if (!buf) {
+		dev_info(ctx->cam->dev,
+			"ctx(%d): can't get MTK_RAW_META_OUT_1 buf from req(%d)\n",
+			ctx->stream_id, s_data->frame_seq_no);
+		return;
+	}
+
+	vb = &buf->vbb.vb2_buf;
+	if (!vb) {
+		dev_info(ctx->cam->dev,
+			 "%s:ctx(%d): can't get vb2 buf\n",
+			 __func__, ctx->stream_id);
+		return;
+	}
+
+	vaddr = vb2_plane_vaddr(&buf->vbb.vb2_buf, 0);
+	if (!vaddr) {
+		dev_info(ctx->cam->dev,
+			 "%s:ctx(%d): can't get plane_vadd\n",
+			 __func__, ctx->stream_id);
+		return;
+	}
+
+	/* Update the timestamp for the buffer*/
+	mtk_cam_s_data_update_timestamp(buf, s_data_ctx);
+
+	/* clean the stream data for req reinit case */
+	mtk_cam_s_data_reset_vbuf(s_data, MTK_RAW_META_OUT_1);
+
+	/* Let user get the buffer */
+	if (unreliable)
+		vb2_buffer_done(&buf->vbb.vb2_buf, VB2_BUF_STATE_ERROR);
+	else
+		vb2_buffer_done(&buf->vbb.vb2_buf, VB2_BUF_STATE_DONE);
+
+	dev_dbg(ctx->cam->dev, "%s:%s: req(%d) done\n",
+		__func__, req->req.debug_str, s_data->frame_seq_no);
+}
+
+void mtk_cam_sv_work(struct work_struct *work)
+{
+	struct mtk_cam_req_work *sv_work = (struct mtk_cam_req_work *)work;
+	struct mtk_cam_request_stream_data *s_data;
+	struct mtk_cam_ctx *ctx;
+	struct device *dev_sv;
+	struct mtk_camsv_device *camsv_dev;
+	unsigned int seq_no;
+	dma_addr_t base_addr;
+
+	s_data = mtk_cam_req_work_get_s_data(sv_work);
+	ctx = mtk_cam_s_data_get_ctx(s_data);
+	dev_sv = ctx->cam->sv.devs[s_data->pipe_id - MTKCAM_SUBDEV_CAMSV_START];
+	camsv_dev = dev_get_drvdata(dev_sv);
+
+	if (s_data->req->pipe_used & (1 << s_data->pipe_id)) {
+		seq_no = s_data->frame_seq_no;
+		base_addr = s_data->sv_frame_params.img_out.buf[0][0].iova;
+		mtk_cam_sv_setup_cfg_info(camsv_dev, s_data);
+		mtk_cam_sv_enquehwbuf(camsv_dev, base_addr, seq_no);
+		mtk_cam_sv_vf_on(camsv_dev, 1);
+	} else {
+		mtk_cam_sv_vf_on(camsv_dev, 0);
+	}
+}
+
+static void mtk_cam_meta1_done(struct mtk_cam_ctx *ctx,
+	unsigned int frame_seq_no,
+	unsigned int pipe_id)
+{
+	struct mtk_cam_request *req;
+	struct mtk_cam_request_stream_data *req_stream_data;
+	struct mtk_cam_req_work *meta1_done_work;
+	struct mtk_camsys_sensor_ctrl *camsys_sensor_ctrl = &ctx->sensor_ctrl;
+
+	req = mtk_cam_get_req(ctx, frame_seq_no);
+	if (!req) {
+		dev_info(ctx->cam->dev, "%s:ctx-%d:pipe-%d:req(%d) not found!\n",
+			__func__, ctx->stream_id, pipe_id, frame_seq_no);
+		return;
+	}
+
+	req_stream_data = mtk_cam_req_get_s_data(req, pipe_id, 0);
+	if (!req_stream_data) {
+		dev_info(ctx->cam->dev, "%s:ctx-%d:pipe-%d:s_data not found!\n",
+			 __func__, ctx->stream_id, pipe_id);
+		return;
+	}
+
+	if (!(req_stream_data->flags & MTK_CAM_REQ_S_DATA_FLAG_META1_INDEPENDENT))
+		return;
+
+	/* Initial request readout will be delayed 1 frame*/
+	if (ctx->sensor) {
+		if (atomic_read(&camsys_sensor_ctrl->isp_request_seq_no) == 0 &&
+			is_first_request_sync(ctx)) {
+			dev_info(ctx->cam->dev,
+				"1st META1 done passed for initial request setting\n");
+			return;
+		}
+	}
+
+	meta1_done_work = &req_stream_data->meta1_done_work;
+	atomic_set(&meta1_done_work->is_queued, 1);
+	queue_work(ctx->frame_done_wq, &meta1_done_work->work);
+}
+
+static void mtk_camsys_m2m_frame_done(struct mtk_cam_ctx *ctx,
+							unsigned int frame_seq_no,
+							unsigned int pipe_id)
+{
+	struct mtk_cam_req_work *frame_done_work;
+	struct mtk_cam_request_stream_data *req_stream_data;
+
+	req_stream_data = mtk_cam_get_req_s_data(ctx, pipe_id, frame_seq_no);
+	if (atomic_read(&req_stream_data->frame_done_work.is_queued)) {
+		dev_info(ctx->cam->dev,
+			"already queue done work %d\n", req_stream_data->frame_seq_no);
+		return;
+	}
+
+	atomic_set(&req_stream_data->seninf_dump_state, MTK_CAM_REQ_DBGWORK_S_FINISHED);
+	atomic_set(&req_stream_data->frame_done_work.is_queued, 1);
+	frame_done_work = &req_stream_data->frame_done_work;
+	queue_work(ctx->frame_done_wq, &frame_done_work->work);
+}
+
+void mtk_cam_frame_done_work(struct work_struct *work)
+{
+	struct mtk_cam_req_work *frame_done_work = (struct mtk_cam_req_work *)work;
+	struct mtk_cam_request_stream_data *req_stream_data;
+	struct mtk_cam_ctx *ctx;
+
+	req_stream_data = mtk_cam_req_work_get_s_data(frame_done_work);
+	ctx = mtk_cam_s_data_get_ctx(req_stream_data);
+
+	if (mtk_cam_is_m2m(ctx))
+		mtk_cam_handle_m2m_frame_done(ctx,
+				  req_stream_data->frame_seq_no,
+				  req_stream_data->pipe_id);
+	else
+		mtk_cam_handle_frame_done(ctx,
+				  req_stream_data->frame_seq_no,
+				  req_stream_data->pipe_id);
+}
+
+void mtk_camsys_frame_done(struct mtk_cam_ctx *ctx,
+				  unsigned int frame_seq_no,
+				  unsigned int pipe_id)
+{
+	struct mtk_cam_request *req;
+	struct mtk_cam_req_work *frame_done_work;
+	struct mtk_camsys_sensor_ctrl *camsys_sensor_ctrl = &ctx->sensor_ctrl;
+	struct mtk_cam_request_stream_data *req_stream_data;
+	struct mtk_raw_device *raw_dev;
+	int i;
+	int switch_type;
+	int feature;
+
+	if (mtk_cam_is_stagger(ctx) && is_raw_subdev(pipe_id)) {
+		req = mtk_cam_get_req(ctx, frame_seq_no + 1);
+		if (req) {
+			req_stream_data = mtk_cam_req_get_s_data(req, pipe_id, 0);
+			switch_type = req_stream_data->feature.switch_feature_type;
+			feature = req_stream_data->feature.raw_feature;
+			if (switch_type &&
+				!mtk_cam_feature_change_is_mstream(switch_type)) {
+				req_stream_data->feature.switch_prev_frame_done = 1;
+				if (req_stream_data->feature.switch_prev_frame_done &&
+					req_stream_data->feature.switch_curr_setting_done)
+					mtk_cam_hdr_switch_toggle(ctx, feature);
+				dev_dbg(ctx->cam->dev,
+					"[SWD] switch req toggle check req:%d type:%d\n",
+					req_stream_data->frame_seq_no,
+					switch_type);
+			}
+		}
+	}
+
+	/* Initial request readout will be delayed 1 frame*/
+	if (ctx->sensor) {
+		if (atomic_read(&camsys_sensor_ctrl->isp_request_seq_no) == 0 &&
+			is_first_request_sync(ctx) &&
+			atomic_read(&camsys_sensor_ctrl->initial_drop_frame_cnt)) {
+			dev_info(ctx->cam->dev,
+					"1st SWD passed for initial request setting\n");
+				atomic_dec(&camsys_sensor_ctrl->initial_drop_frame_cnt);
+			return;
+		}
+	}
+
+	req_stream_data = mtk_cam_get_req_s_data(ctx, pipe_id, frame_seq_no);
+	if (req_stream_data) {
+		req = mtk_cam_s_data_get_req(req_stream_data);
+	} else {
+		dev_info(ctx->cam->dev, "%s:ctx-%d:pipe-%d:req(%d) not found!\n",
+			 __func__, ctx->stream_id, pipe_id, frame_seq_no);
+		return;
+	}
+
+	if (atomic_read(&req_stream_data->frame_done_work.is_queued)) {
+		dev_info(ctx->cam->dev,
+			"already queue done work req:%d seq:%d pipe_id:%d\n",
+			req_stream_data->frame_seq_no, frame_seq_no, pipe_id);
+		return;
+	}
+
+	atomic_set(&req_stream_data->seninf_dump_state, MTK_CAM_REQ_DBGWORK_S_FINISHED);
+	atomic_set(&req_stream_data->frame_done_work.is_queued, 1);
+	frame_done_work = &req_stream_data->frame_done_work;
+	queue_work(ctx->frame_done_wq, &frame_done_work->work);
+	if (mtk_cam_is_time_shared(ctx)) {
+		raw_dev = get_main_raw_dev(ctx->cam, ctx->pipe);
+		raw_dev->time_shared_busy = false;
+		/*try set other ctx in one request first*/
+		if (req->pipe_used != (1 << ctx->stream_id)) {
+			struct mtk_cam_ctx *ctx_2 = NULL;
+			int pipe_used_remain = req->pipe_used & (~(1 << ctx->stream_id));
+
+			for (i = 0;  i < ctx->cam->max_stream_num; i++)
+				if (pipe_used_remain == (1 << i)) {
+					ctx_2 = &ctx->cam->ctxs[i];
+					break;
+				}
+
+			if (!ctx_2) {
+				dev_dbg(raw_dev->dev, "%s: time sharing ctx-%d deq_no(%d)\n",
+				 __func__, ctx_2->stream_id, ctx_2->dequeued_frame_seq_no+1);
+				mtk_camsys_ts_raw_try_set(raw_dev, ctx_2,
+								ctx_2->dequeued_frame_seq_no + 1);
+			}
+		}
+		mtk_camsys_ts_raw_try_set(raw_dev, ctx, ctx->dequeued_frame_seq_no + 1);
+	}
+}
+
+
+void mtk_camsys_state_delete(struct mtk_cam_ctx *ctx,
+				struct mtk_camsys_sensor_ctrl *sensor_ctrl,
+				struct mtk_cam_request *req)
+{
+	struct mtk_camsys_ctrl_state *state_entry, *state_entry_prev;
+	struct mtk_cam_request_stream_data *s_data;
+	struct mtk_camsys_ctrl_state *req_state;
+	int state_found = 0;
+
+	if (ctx->sensor) {
+		spin_lock(&sensor_ctrl->camsys_state_lock);
+		list_for_each_entry_safe(state_entry, state_entry_prev,
+				&sensor_ctrl->camsys_state_list,
+				state_element) {
+			s_data = mtk_cam_req_get_s_data(req, ctx->stream_id, 0);
+			req_state = &s_data->state;
+
+			if (state_entry == req_state) {
+				list_del(&state_entry->state_element);
+				state_found = 1;
+			}
+
+			if (mtk_cam_feature_is_mstream(
+					s_data->feature.raw_feature) ||
+					mtk_cam_feature_is_mstream_m2m(
+					s_data->feature.raw_feature)) {
+				s_data = mtk_cam_req_get_s_data(req,
+								ctx->stream_id, 1);
+				req_state = &s_data->state;
+				if (state_entry == req_state) {
+					list_del(&state_entry->state_element);
+					state_found = 1;
+				}
+			}
+		}
+		spin_unlock(&sensor_ctrl->camsys_state_lock);
+		if (state_found == 0)
+			dev_dbg(ctx->cam->dev, "state not found\n");
+	}
+}
+
+static int mtk_camsys_camsv_state_handle(
+		struct mtk_camsv_device *camsv_dev,
+		struct mtk_camsys_sensor_ctrl *sensor_ctrl,
+		struct mtk_camsys_ctrl_state **current_state,
+		int frame_idx_inner)
+{
+	struct mtk_cam_ctx *ctx = sensor_ctrl->ctx;
+	struct mtk_camsys_ctrl_state *state_temp, *state_outer = NULL;
+	struct mtk_camsys_ctrl_state *state_rec[STATE_NUM_AT_SOF];
+	struct mtk_cam_request *req;
+	struct mtk_cam_request_stream_data *req_stream_data;
+	int stateidx;
+	int que_cnt = 0;
+
+	/* List state-queue status*/
+	spin_lock(&sensor_ctrl->camsys_state_lock);
+	list_for_each_entry(state_temp,
+	&sensor_ctrl->camsys_state_list, state_element) {
+		req = mtk_cam_ctrl_state_get_req(state_temp);
+		req_stream_data = mtk_cam_req_get_s_data(req, ctx->stream_id, 0);
+		stateidx = atomic_read(&sensor_ctrl->sensor_request_seq_no) -
+			   req_stream_data->frame_seq_no;
+
+		if (stateidx < STATE_NUM_AT_SOF && stateidx > -1) {
+			state_rec[stateidx] = state_temp;
+			/* Find outer state element */
+			if (state_temp->estate == E_STATE_OUTER ||
+				state_temp->estate == E_STATE_OUTER_HW_DELAY)
+				state_outer = state_temp;
+			dev_dbg(camsv_dev->dev,
+				"[SOF] STATE_CHECK [N-%d] Req:%d / State:%d\n",
+				stateidx, req_stream_data->frame_seq_no,
+				state_rec[stateidx]->estate);
+		}
+		/* counter for state queue*/
+		que_cnt++;
+	}
+	spin_unlock(&sensor_ctrl->camsys_state_lock);
+
+	/* HW imcomplete case */
+	if (que_cnt >= STATE_NUM_AT_SOF && state_rec[1] && state_rec[2]) {
+		state_transition(state_rec[2], E_STATE_INNER, E_STATE_INNER_HW_DELAY);
+		state_transition(state_rec[1], E_STATE_OUTER, E_STATE_OUTER_HW_DELAY);
+		dev_dbg(camsv_dev->dev, "[SOF] HW_DELAY state\n");
+		return STATE_RESULT_PASS_CQ_HW_DELAY;
+	}
+
+	/* Trigger high resolution timer to try sensor setting */
+	sensor_ctrl->sof_time = ktime_get_boottime_ns() / 1000000;
+	mtk_cam_sof_timer_setup(ctx);
+
+	/* Transit outer state to inner state */
+	if (state_outer != NULL) {
+		req = mtk_cam_ctrl_state_get_req(state_outer);
+		req_stream_data = mtk_cam_req_get_s_data(req, ctx->stream_id, 0);
+		if (req_stream_data->frame_seq_no == frame_idx_inner) {
+			if (frame_idx_inner ==
+				(atomic_read(&sensor_ctrl->isp_request_seq_no) + 1)) {
+				state_transition(state_outer,
+					E_STATE_OUTER_HW_DELAY, E_STATE_INNER_HW_DELAY);
+				state_transition(state_outer, E_STATE_OUTER, E_STATE_INNER);
+				atomic_set(&sensor_ctrl->isp_request_seq_no, frame_idx_inner);
+				dev_dbg(camsv_dev->dev, "[SOF-DBLOAD] req:%d, OUTER->INNER state:%d\n",
+						req_stream_data->frame_seq_no, state_outer->estate);
+			}
+		}
+	}
+
+	if (que_cnt > 0 && state_rec[0]) {
+		/* CQ triggering judgment*/
+		if (state_rec[0]->estate == E_STATE_SENSOR) {
+			*current_state = state_rec[0];
+			return STATE_RESULT_TRIGGER_CQ;
+		}
+	}
+
+	return STATE_RESULT_PASS_CQ_SW_DELAY;
+}
+
+static void mtk_camsys_camsv_check_frame_done(struct mtk_cam_ctx *ctx,
+	unsigned int dequeued_frame_seq_no, unsigned int pipe_id)
+{
+#define CHECK_STATE_DEPTH 3
+	struct mtk_camsys_sensor_ctrl *sensor_ctrl = &ctx->sensor_ctrl;
+	struct mtk_camsys_ctrl_state *state_temp;
+	struct mtk_cam_request_stream_data *req_stream_data;
+	unsigned long flags;
+	unsigned int seqList[CHECK_STATE_DEPTH];
+	unsigned int cnt = 0;
+	int i;
+
+	if (ctx->sensor) {
+		spin_lock_irqsave(&sensor_ctrl->camsys_state_lock, flags);
+		list_for_each_entry(state_temp, &sensor_ctrl->camsys_state_list,
+						state_element) {
+			req_stream_data = mtk_cam_ctrl_state_to_req_s_data(state_temp);
+			if (req_stream_data->frame_seq_no < dequeued_frame_seq_no) {
+				seqList[cnt++] = req_stream_data->frame_seq_no;
+				if (cnt == CHECK_STATE_DEPTH)
+					break;
+			}
+		}
+		spin_unlock_irqrestore(&sensor_ctrl->camsys_state_lock, flags);
+		for (i = 0; i < cnt; i++)
+			mtk_camsys_frame_done(ctx, seqList[i], pipe_id);
+	}
+}
+
+static void mtk_camsys_camsv_frame_start(struct mtk_camsv_device *camsv_dev,
+	struct mtk_cam_ctx *ctx, unsigned int dequeued_frame_seq_no, u64 ts_ns)
+{
+	struct mtk_cam_request *req;
+	struct mtk_cam_request_stream_data *req_stream_data;
+	struct mtk_camsys_sensor_ctrl *sensor_ctrl = &ctx->sensor_ctrl;
+	struct mtk_camsys_ctrl_state *current_state;
+	enum MTK_CAMSYS_STATE_RESULT state_handle_ret;
+	int sv_dev_index;
+
+	/* inner register dequeue number */
+	sv_dev_index = mtk_cam_find_sv_dev_index(ctx, camsv_dev->id);
+	if (sv_dev_index == -1) {
+		dev_dbg(camsv_dev->dev, "cannot find sv_dev_index(%d)", camsv_dev->id);
+		return;
+	}
+	ctx->sv_dequeued_frame_seq_no[sv_dev_index] = dequeued_frame_seq_no;
+	/* Send V4L2_EVENT_FRAME_SYNC event */
+	mtk_cam_sv_event_frame_sync(camsv_dev, dequeued_frame_seq_no);
+
+	if (ctx->sensor &&
+		(ctx->stream_id >= MTKCAM_SUBDEV_CAMSV_START &&
+		ctx->stream_id < MTKCAM_SUBDEV_CAMSV_END)) {
+		state_handle_ret = mtk_camsys_camsv_state_handle(camsv_dev, sensor_ctrl,
+				&current_state, dequeued_frame_seq_no);
+		if (state_handle_ret != STATE_RESULT_TRIGGER_CQ)
+			return;
+	}
+
+	/* Find request of this dequeued frame */
+	if (ctx->stream_id >= MTKCAM_SUBDEV_CAMSV_START &&
+		ctx->stream_id < MTKCAM_SUBDEV_CAMSV_END) {
+		req = mtk_cam_get_req(ctx, dequeued_frame_seq_no);
+		if (req) {
+			req_stream_data = mtk_cam_req_get_s_data(req, ctx->stream_id, 0);
+			req_stream_data->timestamp = ktime_get_boottime_ns();
+			req_stream_data->timestamp_mono = ktime_get_ns();
+		}
+		mtk_camsys_camsv_check_frame_done(ctx, dequeued_frame_seq_no,
+			ctx->stream_id + MTKCAM_SUBDEV_CAMSV_START);
+	}
+
+	/* apply next buffer */
+	if (ctx->stream_id >= MTKCAM_SUBDEV_CAMSV_START &&
+		ctx->stream_id < MTKCAM_SUBDEV_CAMSV_END) {
+		if (mtk_cam_sv_apply_next_buffer(ctx,
+			camsv_dev->id + MTKCAM_SUBDEV_CAMSV_START, ts_ns)) {
+			/* Transit state from Sensor -> Outer */
+			if (ctx->sensor)
+				state_transition(current_state, E_STATE_SENSOR, E_STATE_OUTER);
+		} else {
+			dev_info(camsv_dev->dev, "sv apply next buffer failed");
+		}
+	} else {
+		mtk_cam_sv_apply_next_buffer(ctx,
+			camsv_dev->id + MTKCAM_SUBDEV_CAMSV_START, ts_ns);
+	}
+}
+
+static bool mtk_camsys_is_all_cq_done(struct mtk_cam_ctx *ctx,
+	unsigned int pipe_id)
+{
+	unsigned int all_subdevs = 0;
+	bool ret = false;
+
+	spin_lock(&ctx->first_cq_lock);
+	if (ctx->is_first_cq_done) {
+		ret = true;
+		spin_unlock(&ctx->first_cq_lock);
+		goto EXIT;
+	}
+
+	// update cq done status
+	ctx->cq_done_status |= (1 << pipe_id);
+
+	// check cq done status
+	if (ctx->used_raw_num)
+		all_subdevs |= (1 << ctx->pipe->id);
+	if ((ctx->cq_done_status & all_subdevs) == all_subdevs) {
+		ctx->is_first_cq_done = 1;
+		ret = true;
+	}
+	spin_unlock(&ctx->first_cq_lock);
+	dev_info(ctx->cam->dev, "[1st-CQD] all done:%d, pipe_id:%d (using raw:%d)\n",
+		ctx->is_first_cq_done, pipe_id, ctx->used_raw_num);
+EXIT:
+	return ret;
+}
+
+static int mtk_camsys_event_handle_raw(struct mtk_cam_device *cam,
+				       unsigned int engine_id,
+				       struct mtk_camsys_irq_info *irq_info)
+{
+	struct mtk_raw_device *raw_dev;
+	struct mtk_cam_ctx *ctx;
+
+	raw_dev = dev_get_drvdata(cam->raw.devs[engine_id]);
+	if (mtk_cam_feature_is_time_shared(raw_dev->pipeline->feature_active))
+		ctx = &cam->ctxs[raw_dev->time_shared_busy_ctx_id];
+	else
+		ctx = mtk_cam_find_ctx(cam, &raw_dev->pipeline->subdev.entity);
+	if (!ctx) {
+		dev_dbg(raw_dev->dev, "cannot find ctx\n");
+		return -EINVAL;
+	}
+
+	/* raw's CQ done */
+	if (irq_info->irq_type & (1 << CAMSYS_IRQ_SETTING_DONE)) {
+
+		if (mtk_cam_is_m2m(ctx)) {
+			mtk_camsys_raw_m2m_cq_done(raw_dev, ctx, irq_info->frame_idx);
+			mtk_camsys_raw_m2m_trigger(raw_dev, ctx, irq_info->frame_idx);
+		} else {
+			if (mtk_camsys_is_all_cq_done(ctx, ctx->pipe->id))
+				mtk_camsys_raw_cq_done(raw_dev, ctx, irq_info->frame_idx);
+		}
+	}
+	/* raw's subsample sensor setting */
+	if (irq_info->irq_type & (1 << CAMSYS_IRQ_SUBSAMPLE_SENSOR_SET))
+		mtk_cam_submit_kwork_in_sensorctrl(ctx->sensor_ctrl.sensorsetting_wq,
+				     &ctx->sensor_ctrl);
+
+	/* raw's DMA done, we only allow AFO done here */
+	if (irq_info->irq_type & (1 << CAMSYS_IRQ_AFO_DONE))
+		mtk_cam_meta1_done(ctx, ctx->dequeued_frame_seq_no, ctx->stream_id);
+
+	/* raw's SW done */
+	if (irq_info->irq_type & (1 << CAMSYS_IRQ_FRAME_DONE)) {
+
+		if (mtk_cam_is_m2m(ctx)) {
+			mtk_camsys_m2m_frame_done(ctx, irq_info->frame_idx_inner,
+						  ctx->stream_id);
+		} else
+			mtk_camsys_frame_done(ctx, ctx->dequeued_frame_seq_no,
+					      ctx->stream_id);
+	}
+	/* raw's SOF */
+	if (irq_info->irq_type & (1 << CAMSYS_IRQ_FRAME_START)) {
+		if (atomic_read(&raw_dev->vf_en) == 0) {
+			dev_info(raw_dev->dev, "skip sof event when vf off\n");
+			return 0;
+		}
+
+		if (mtk_cam_is_stagger(ctx)) {
+			dev_dbg(raw_dev->dev, "[stagger] last frame_start\n");
+			mtk_cam_hdr_last_frame_start(raw_dev, ctx, irq_info);
+		} else {
+			mtk_camsys_raw_frame_start(raw_dev, ctx, irq_info);
+		}
+	}
+
+	return 0;
+}
+
+static int mtk_camsys_event_handle_camsv(struct mtk_cam_device *cam,
+					 unsigned int engine_id,
+					 struct mtk_camsys_irq_info *irq_info)
+{
+	struct mtk_camsv_device *camsv_dev;
+	struct mtk_cam_ctx *ctx;
+	int sv_dev_index;
+	unsigned int stream_id;
+	unsigned int seq;
+
+	camsv_dev = dev_get_drvdata(cam->sv.devs[engine_id]);
+	if (camsv_dev->pipeline->hw_scen &
+	    MTK_CAMSV_SUPPORTED_SPECIAL_HW_SCENARIO) {
+		struct mtk_raw_pipeline *pipeline = &cam->raw
+			.pipelines[camsv_dev->pipeline->main_pipe_id];
+		struct mtk_raw_device *raw_dev =
+			get_main_raw_dev(cam, pipeline);
+		struct mtk_cam_ctx *ctx =
+			mtk_cam_find_ctx(cam, &pipeline->subdev.entity);
+
+		dev_dbg(camsv_dev->dev, "sv special hw scenario: %d/%d/%d\n",
+			camsv_dev->pipeline->main_pipe_id,
+			raw_dev->id, ctx->stream_id);
+
+		// first exposure camsv's SOF
+		if (irq_info->irq_type & (1 << CAMSYS_IRQ_FRAME_START)) {
+			if (camsv_dev->pipeline->exp_order == 0) {
+#ifdef ISP7_1
+				if (ctx->pipe->stagger_path == STAGGER_DCIF) {
+					raw_dev->sof_count = irq_info->frame_idx_inner;
+					dev_dbg(camsv_dev->dev, "dcif/offline stagger raw sof:%ld\n",
+						(unsigned long)raw_dev->sof_count);
+					if (raw_dev->sof_count == 1) {
+						struct mtk_camsv_device *camsv_dev_s;
+						int hw_scen = mtk_raw_get_hdr_scen_id(ctx);
+
+						camsv_dev_s = get_hdr_sv_dev(ctx, 2);
+						mtk_cam_sv_dev_stream_on(ctx,
+							camsv_dev_s->id, 1, hw_scen);
+					}
+				}
+#endif
+				mtk_camsys_raw_frame_start(raw_dev, ctx, irq_info);
+			} else if (camsv_dev->pipeline->exp_order == 2) {
+				dev_dbg(camsv_dev->dev, "dcif/offline stagger raw last sof:%lld\n",
+						raw_dev->sof_count);
+				mtk_cam_hdr_last_frame_start(raw_dev, ctx, irq_info);
+			}
+		}
+		// time sharing - camsv write DRAM mode
+		if (camsv_dev->pipeline->hw_scen &
+		    (1 << MTKCAM_IPI_HW_PATH_OFFLINE_M2M)) {
+			if (irq_info->irq_type & (1<<CAMSYS_IRQ_FRAME_DONE)) {
+				mtk_camsys_ts_sv_done(ctx, irq_info->frame_idx_inner);
+				mtk_camsys_ts_raw_try_set(raw_dev, ctx,
+						ctx->dequeued_frame_seq_no + 1);
+			}
+			if (irq_info->irq_type & (1<<CAMSYS_IRQ_FRAME_START))
+				mtk_camsys_ts_frame_start(ctx, irq_info->frame_idx_inner);
+		}
+	} else {
+		ctx = mtk_cam_find_ctx(cam, &camsv_dev->pipeline->subdev.entity);
+		if (!ctx) {
+			dev_dbg(camsv_dev->dev, "cannot find ctx\n");
+			return -EINVAL;
+		}
+		stream_id = engine_id + MTKCAM_SUBDEV_CAMSV_START;
+		/* camsv's SW done */
+		if (irq_info->irq_type & (1<<CAMSYS_IRQ_FRAME_DONE)) {
+			sv_dev_index = mtk_cam_find_sv_dev_index(ctx, camsv_dev->id);
+			if (sv_dev_index == -1) {
+				dev_dbg(camsv_dev->dev,
+					"cannot find sv_dev_index(%d)", camsv_dev->id);
+				return -EINVAL;
+			}
+			seq = ctx->sv_dequeued_frame_seq_no[sv_dev_index];
+			mtk_camsys_frame_done(ctx, seq, stream_id);
+		}
+		/* camsv's SOF */
+		if (irq_info->irq_type & (1<<CAMSYS_IRQ_FRAME_START))
+			mtk_camsys_camsv_frame_start(camsv_dev, ctx,
+				irq_info->frame_idx_inner, irq_info->ts_ns);
+	}
+
+	return 0;
+}
+
+int mtk_camsys_isr_event(struct mtk_cam_device *cam,
+			 enum MTK_CAMSYS_ENGINE_TYPE engine_type,
+			 unsigned int engine_id,
+			 struct mtk_camsys_irq_info *irq_info)
+{
+	int ret = 0;
+
+	/**
+	 * Here it will be implemented dispatch rules for some scenarios
+	 * like twin/stagger/m-stream,
+	 * such cases that camsys will collect all coworked sub-engine's
+	 * signals and trigger some engine of them to do some job
+	 * individually.
+	 * twin - rawx2
+	 * stagger - rawx1, camsv x2
+	 * m-stream - rawx1 , camsv x2
+	 */
+	switch (engine_type) {
+	case CAMSYS_ENGINE_RAW:
+
+		ret = mtk_camsys_event_handle_raw(cam, engine_id, irq_info);
+
+		break;
+	case CAMSYS_ENGINE_CAMSV:
+
+		ret = mtk_camsys_event_handle_camsv(cam, engine_id, irq_info);
+
+		break;
+	case CAMSYS_ENGINE_SENINF:
+		/* ToDo - cam mux setting delay handling */
+		if (irq_info->irq_type & (1 << CAMSYS_IRQ_FRAME_DROP))
+			dev_info(cam->dev, "MTK_CAMSYS_ENGINE_SENINF_TAG engine:%d type:0x%x\n",
+				engine_id, irq_info->irq_type);
+		break;
+	default:
+		break;
+	}
+
+	return ret;
+}
+
+void mtk_cam_mstream_initial_sensor_setup(struct mtk_cam_request *initial_req,
+				  struct mtk_cam_ctx *ctx)
+{
+	struct mtk_camsys_sensor_ctrl *sensor_ctrl = &ctx->sensor_ctrl;
+	struct mtk_cam_request_stream_data *req_stream_data =
+		mtk_cam_req_get_s_data(initial_req, ctx->stream_id, 1);
+	sensor_ctrl->ctx = ctx;
+	req_stream_data->ctx = ctx;
+	mtk_cam_set_sensor_full(req_stream_data, &ctx->sensor_ctrl);
+	dev_info(ctx->cam->dev, "[mstream] Initial sensor timer setup, seq_no(%d)\n",
+				req_stream_data->frame_seq_no);
+	if (mtk_cam_is_mstream_m2m(ctx))
+		mtk_cam_initial_sensor_setup(initial_req, ctx);
+}
+
+void mtk_cam_initial_sensor_setup(struct mtk_cam_request *initial_req,
+				  struct mtk_cam_ctx *ctx)
+{
+	struct mtk_camsys_sensor_ctrl *sensor_ctrl = &ctx->sensor_ctrl;
+	struct mtk_cam_request_stream_data *req_stream_data;
+
+	sensor_ctrl->ctx = ctx;
+	req_stream_data = mtk_cam_req_get_s_data(initial_req, ctx->stream_id, 0);
+	req_stream_data->ctx = ctx;
+	mtk_cam_set_sensor_full(req_stream_data, &ctx->sensor_ctrl);
+	if (mtk_cam_is_subsample(ctx))
+		state_transition(&req_stream_data->state,
+			E_STATE_READY, E_STATE_SUBSPL_READY);
+	dev_info(ctx->cam->dev, "Directly setup sensor req:%d\n",
+		req_stream_data->frame_seq_no);
+}
+
+static void mtk_cam_complete_hdl(struct mtk_cam_request_stream_data *s_data,
+				 struct media_request_object *hdl_obj,
+				 char *name)
+{
+	char *debug_str;
+	u64 start, cost;
+
+	debug_str = mtk_cam_s_data_get_dbg_str(s_data);
+
+	start = ktime_get_boottime_ns();
+	if (hdl_obj->ops)
+		hdl_obj->ops->unbind(hdl_obj);	/* mutex used */
+	else
+		pr_info("%s:%s:pipe(%d):seq(%d): cannot unbind %s hd\n",
+			__func__, debug_str, s_data->pipe_id,
+			s_data->frame_seq_no, name);
+
+	cost = ktime_get_boottime_ns() - start;
+	if (cost > 1000000)
+		pr_info("%s:%s:pipe(%d):seq(%d): complete hdl:%s, cost:%llu ns\n",
+			__func__, debug_str, s_data->pipe_id,
+			s_data->frame_seq_no, name, cost);
+	else
+		pr_debug("%s:%s:pipe(%d):seq(%d): complete hdl:%s, cost:%llu ns\n",
+			 __func__, debug_str, s_data->pipe_id,
+			 s_data->frame_seq_no, name, cost);
+
+	media_request_object_complete(hdl_obj);
+}
+
+void mtk_cam_complete_sensor_hdl(struct mtk_cam_request_stream_data *s_data)
+{
+	if (s_data->flags & MTK_CAM_REQ_S_DATA_FLAG_SENSOR_HDL_EN &&
+	    !(s_data->flags & MTK_CAM_REQ_S_DATA_FLAG_SENSOR_HDL_COMPLETE) &&
+	    s_data->sensor_hdl_obj) {
+		mtk_cam_complete_hdl(s_data, s_data->sensor_hdl_obj, "sensor");
+		s_data->flags |= MTK_CAM_REQ_S_DATA_FLAG_SENSOR_HDL_COMPLETE;
+	}
+}
+
+void mtk_cam_complete_raw_hdl(struct mtk_cam_request_stream_data *s_data)
+{
+	if ((s_data->flags & MTK_CAM_REQ_S_DATA_FLAG_RAW_HDL_EN) &&
+	    !(s_data->flags & MTK_CAM_REQ_S_DATA_FLAG_RAW_HDL_COMPLETE) &&
+	    s_data->raw_hdl_obj) {
+		mtk_cam_complete_hdl(s_data, s_data->raw_hdl_obj, "raw");
+		s_data->flags |= MTK_CAM_REQ_S_DATA_FLAG_RAW_HDL_COMPLETE;
+	}
+}
+
+void mtk_cam_req_ctrl_setup(struct mtk_raw_pipeline *raw_pipe,
+					struct mtk_cam_request *req)
+{
+	struct mtk_cam_request_stream_data *req_stream_data;
+
+	req_stream_data = mtk_cam_req_get_s_data(req, raw_pipe->id, 0);
+
+	/* request setup*/
+	if (req_stream_data->flags & MTK_CAM_REQ_S_DATA_FLAG_RAW_HDL_EN &&
+	    !(req_stream_data->flags & MTK_CAM_REQ_S_DATA_FLAG_RAW_HDL_COMPLETE) &&
+	    req_stream_data->raw_hdl_obj) {
+		dev_dbg(raw_pipe->subdev.v4l2_dev->dev,
+			"%s:%s:%s:raw ctrl set start (seq:%d)\n",
+			__func__, raw_pipe->subdev.name, req->req.debug_str,
+			req_stream_data->frame_seq_no);
+		v4l2_ctrl_request_setup(&req->req, &raw_pipe->ctrl_handler);
+
+		mtk_cam_complete_raw_hdl(req_stream_data);
+	}
+}
+
+static int timer_reqdrained_chk(int fps_ratio, int sub_sample)
+{
+	int timer_ms = 0;
+
+	if (sub_sample > 0) {
+		if (fps_ratio > 1)
+			timer_ms = SENSOR_SET_DEADLINE_MS;
+		else
+			timer_ms = SENSOR_SET_DEADLINE_MS * fps_ratio;
+	} else {
+		if (fps_ratio > 1)
+			timer_ms = SENSOR_SET_DEADLINE_MS / fps_ratio;
+		else
+			timer_ms = SENSOR_SET_DEADLINE_MS;
+	}
+	/* earlier request drained event*/
+	if (sub_sample == 0 && fps_ratio > 1)
+		timer_ms = SENSOR_SET_DEADLINE_MS_60FPS;
+
+	return timer_ms;
+}
+static int timer_setsensor(int fps_ratio, int sub_sample)
+{
+	int timer_ms = 0;
+
+	if (sub_sample > 0) {
+		if (fps_ratio > 1)
+			timer_ms = SENSOR_SET_RESERVED_MS;
+		else
+			timer_ms = SENSOR_SET_RESERVED_MS * fps_ratio;
+	} else {
+		if (fps_ratio > 1)
+			timer_ms = SENSOR_SET_RESERVED_MS / fps_ratio;
+		else
+			timer_ms = SENSOR_SET_RESERVED_MS;
+	}
+	/* faster sensor setting*/
+	if (sub_sample == 0 && fps_ratio > 1)
+		timer_ms = SENSOR_SET_RESERVED_MS_60FPS;
+
+	return timer_ms;
+}
+
+int mtk_camsys_ctrl_start(struct mtk_cam_ctx *ctx)
+{
+	struct mtk_camsys_sensor_ctrl *camsys_sensor_ctrl = &ctx->sensor_ctrl;
+	struct v4l2_subdev_frame_interval fi;
+	int fps_factor = 1, sub_ratio = 0;
+
+	if (ctx->used_raw_num) {
+		fi.pad = 0;
+		v4l2_subdev_call(ctx->sensor, video, g_frame_interval, &fi);
+		fps_factor = (fi.interval.numerator > 0) ?
+				(fi.interval.denominator / fi.interval.numerator / 30) : 1;
+		sub_ratio =
+			mtk_cam_get_subsample_ratio(ctx->pipe->res_config.raw_feature);
+	}
+
+	camsys_sensor_ctrl->ctx = ctx;
+	atomic_set(&camsys_sensor_ctrl->sensor_enq_seq_no, 0);
+	atomic_set(&camsys_sensor_ctrl->sensor_request_seq_no, 0);
+	atomic_set(&camsys_sensor_ctrl->isp_request_seq_no, 0);
+	atomic_set(&camsys_sensor_ctrl->isp_enq_seq_no, 0);
+	atomic_set(&camsys_sensor_ctrl->last_drained_seq_no, 0);
+	camsys_sensor_ctrl->initial_cq_done = 0;
+	camsys_sensor_ctrl->sof_time = 0;
+	if (ctx->used_raw_num) {
+		if (is_first_request_sync(ctx))
+			atomic_set(&camsys_sensor_ctrl->initial_drop_frame_cnt,
+				INITIAL_DROP_FRAME_CNT);
+		else
+			atomic_set(&camsys_sensor_ctrl->initial_drop_frame_cnt, 0);
+	}
+
+	camsys_sensor_ctrl->timer_req_event =
+		timer_reqdrained_chk(fps_factor, sub_ratio);
+	camsys_sensor_ctrl->timer_req_sensor =
+		timer_setsensor(fps_factor, sub_ratio);
+	if (mtk_cam_is_stagger(ctx) &&
+		fps_factor == 1 && sub_ratio == 0) {
+		camsys_sensor_ctrl->timer_req_event =
+			SENSOR_SET_STAGGER_DEADLINE_MS;
+		camsys_sensor_ctrl->timer_req_sensor =
+			SENSOR_SET_STAGGER_RESERVED_MS;
+	}
+	INIT_LIST_HEAD(&camsys_sensor_ctrl->camsys_state_list);
+	spin_lock_init(&camsys_sensor_ctrl->camsys_state_lock);
+	if (ctx->sensor) {
+		hrtimer_init(&camsys_sensor_ctrl->sensor_deadline_timer,
+			     CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+		camsys_sensor_ctrl->sensor_deadline_timer.function =
+			sensor_deadline_timer_handler;
+		camsys_sensor_ctrl->sensorsetting_wq = &ctx->sensor_worker;
+	}
+	kthread_init_work(&camsys_sensor_ctrl->work, mtk_cam_sensor_worker_in_sensorctrl);
+
+	dev_info(ctx->cam->dev, "[%s] ctx:%d/raw_dev:0x%x drained/sensor (%d)%d/%d\n",
+		__func__, ctx->stream_id, ctx->used_raw_dev, fps_factor,
+		camsys_sensor_ctrl->timer_req_event, camsys_sensor_ctrl->timer_req_sensor);
+
+	return 0;
+}
+
+void mtk_camsys_ctrl_update(struct mtk_cam_ctx *ctx)
+{
+	struct mtk_camsys_sensor_ctrl *camsys_sensor_ctrl = &ctx->sensor_ctrl;
+	struct v4l2_subdev_frame_interval fi;
+	int fps_factor = 1, sub_ratio = 0;
+
+	if (ctx->used_raw_num) {
+		fi.pad = 0;
+		v4l2_subdev_call(ctx->sensor, video, g_frame_interval, &fi);
+		fps_factor = (fi.interval.numerator > 0) ?
+				(fi.interval.denominator / fi.interval.numerator / 30) : 1;
+		sub_ratio =
+			mtk_cam_get_subsample_ratio(ctx->pipe->res_config.raw_feature);
+	}
+
+	camsys_sensor_ctrl->timer_req_event =
+		timer_reqdrained_chk(fps_factor, sub_ratio);
+	camsys_sensor_ctrl->timer_req_sensor =
+		timer_setsensor(fps_factor, sub_ratio);
+
+	dev_info(ctx->cam->dev, "[%s] ctx:%d/raw_dev:0x%x drained/sensor (%d)%d/%d\n",
+		__func__, ctx->stream_id, ctx->used_raw_dev, fps_factor,
+		camsys_sensor_ctrl->timer_req_event, camsys_sensor_ctrl->timer_req_sensor);
+}
+
+void mtk_camsys_ctrl_stop(struct mtk_cam_ctx *ctx)
+{
+	struct mtk_camsys_sensor_ctrl *camsys_sensor_ctrl = &ctx->sensor_ctrl;
+	struct mtk_camsys_ctrl_state *state_entry, *state_entry_prev;
+
+	spin_lock(&camsys_sensor_ctrl->camsys_state_lock);
+	list_for_each_entry_safe(state_entry, state_entry_prev,
+				 &camsys_sensor_ctrl->camsys_state_list,
+				 state_element) {
+		list_del(&state_entry->state_element);
+	}
+	spin_unlock(&camsys_sensor_ctrl->camsys_state_lock);
+	if (ctx->sensor) {
+		hrtimer_cancel(&camsys_sensor_ctrl->sensor_deadline_timer);
+		camsys_sensor_ctrl->sensorsetting_wq = NULL;
+	}
+	kthread_flush_work(&camsys_sensor_ctrl->work);
+	if (ctx->used_raw_num)
+		mtk_cam_event_eos(ctx->pipe);
+	dev_info(ctx->cam->dev, "[%s] ctx:%d/raw_dev:0x%x\n",
+		__func__, ctx->stream_id, ctx->used_raw_dev);
+}
+
+void mtk_cam_m2m_enter_cq_state(struct mtk_camsys_ctrl_state *ctrl_state)
+{
+	state_transition(ctrl_state, E_STATE_SENSOR, E_STATE_CQ);
+}
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam-ctrl.h b/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam-ctrl.h
new file mode 100644
index 0000000000000000000000000000000000000000..8ead302c56b63afbc1ac0fdf4e1f7b61c2df19ae
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam-ctrl.h
@@ -0,0 +1,178 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2022 MediaTek Inc.
+ */
+
+#ifndef __MTK_CAM_CTRL_H
+#define __MTK_CAM_CTRL_H
+
+#include <linux/hrtimer.h>
+#include <linux/timer.h>
+
+#define MTK_CAM_INITIAL_REQ_SYNC 0
+
+struct mtk_cam_device;
+struct mtk_raw_device;
+
+enum MTK_CAMSYS_ENGINE_TYPE {
+	CAMSYS_ENGINE_RAW,
+	CAMSYS_ENGINE_MRAW,
+	CAMSYS_ENGINE_CAMSV,
+	CAMSYS_ENGINE_SENINF,
+};
+
+enum MTK_CAMSYS_IRQ_EVENT {
+	/* with normal_data */
+	CAMSYS_IRQ_SETTING_DONE = 0,
+	CAMSYS_IRQ_FRAME_START,
+	CAMSYS_IRQ_AFO_DONE,
+	CAMSYS_IRQ_FRAME_DONE,
+	CAMSYS_IRQ_SUBSAMPLE_SENSOR_SET,
+	CAMSYS_IRQ_FRAME_DROP,
+
+	/* with error_data */
+	CAMSYS_IRQ_ERROR,
+};
+
+struct mtk_camsys_irq_normal_data {
+};
+
+struct mtk_camsys_irq_error_data {
+	int err_status;
+};
+
+struct mtk_camsys_irq_info {
+	enum MTK_CAMSYS_IRQ_EVENT irq_type;
+	u64 ts_ns;
+	int frame_idx;
+	int frame_idx_inner;
+	bool sub_engine;
+	int write_cnt;
+	int fbc_cnt;
+	union {
+		struct mtk_camsys_irq_normal_data	n;
+		struct mtk_camsys_irq_error_data	e;
+	};
+};
+
+/*For state analysis and controlling for request*/
+enum MTK_CAMSYS_STATE_IDX {
+	E_STATE_READY = 0x0,
+	E_STATE_SENINF,
+	E_STATE_SENSOR,
+	E_STATE_CQ,
+	E_STATE_OUTER,
+	E_STATE_CAMMUX_OUTER_CFG,
+	E_STATE_CAMMUX_OUTER,
+	E_STATE_INNER,
+	E_STATE_DONE_NORMAL,
+	E_STATE_CQ_SCQ_DELAY,
+	E_STATE_CAMMUX_OUTER_CFG_DELAY,
+	E_STATE_OUTER_HW_DELAY,
+	E_STATE_INNER_HW_DELAY,
+	E_STATE_DONE_MISMATCH,
+	E_STATE_SUBSPL_READY = 0x10,
+	E_STATE_SUBSPL_SCQ,
+	E_STATE_SUBSPL_OUTER,
+	E_STATE_SUBSPL_SENSOR,
+	E_STATE_SUBSPL_INNER,
+	E_STATE_SUBSPL_DONE_NORMAL,
+	E_STATE_SUBSPL_SCQ_DELAY,
+	E_STATE_TS_READY = 0x20,
+	E_STATE_TS_SENSOR,
+	E_STATE_TS_SV,
+	E_STATE_TS_MEM,
+	E_STATE_TS_CQ,
+	E_STATE_TS_INNER,
+	E_STATE_TS_DONE_NORMAL,
+};
+
+struct mtk_camsys_ctrl_state {
+	enum MTK_CAMSYS_STATE_IDX estate;
+	struct list_head state_element;
+};
+
+struct mtk_camsys_link_ctrl {
+	struct mtk_raw_pipeline *pipe;
+	struct media_pad remote;
+	struct mtk_cam_ctx *swapping_ctx;
+	u8 active;
+	u8 wait_exchange;
+};
+
+/*per stream (sensor) */
+struct mtk_camsys_sensor_ctrl {
+	struct mtk_cam_ctx *ctx;
+	struct kthread_worker *sensorsetting_wq;
+	struct kthread_work work;
+	struct hrtimer sensor_deadline_timer;
+	u64 sof_time;
+	int timer_req_sensor;
+	int timer_req_event;
+	atomic_t sensor_enq_seq_no;
+	atomic_t sensor_request_seq_no;
+	atomic_t isp_request_seq_no;
+	atomic_t isp_enq_seq_no;
+	atomic_t last_drained_seq_no;
+	int initial_cq_done;
+	atomic_t initial_drop_frame_cnt;
+	struct list_head camsys_state_list;
+	spinlock_t camsys_state_lock;
+	/* link change ctrl */
+	struct mtk_camsys_link_ctrl link_ctrl;
+	struct mtk_cam_request *link_change_req;
+};
+
+enum {
+	EXPOSURE_CHANGE_NONE = 0,
+	EXPOSURE_CHANGE_3_to_2,
+	EXPOSURE_CHANGE_3_to_1,
+	EXPOSURE_CHANGE_2_to_3,
+	EXPOSURE_CHANGE_2_to_1,
+	EXPOSURE_CHANGE_1_to_3,
+	EXPOSURE_CHANGE_1_to_2,
+
+	MSTREAM_EXPOSURE_CHANGE = (1 << 4),
+};
+
+void mtk_camsys_state_delete(struct mtk_cam_ctx *ctx,
+				struct mtk_camsys_sensor_ctrl *sensor_ctrl,
+				struct mtk_cam_request *req);
+void mtk_camsys_frame_done(struct mtk_cam_ctx *ctx,
+				  unsigned int frame_seq_no,
+				  unsigned int pipe_id);
+
+int mtk_camsys_isr_event(struct mtk_cam_device *cam,
+			 enum MTK_CAMSYS_ENGINE_TYPE engine_type,
+			 unsigned int engine_id,
+			 struct mtk_camsys_irq_info *irq_info);
+bool mtk_cam_submit_kwork_in_sensorctrl(struct kthread_worker *worker,
+				 struct mtk_camsys_sensor_ctrl *sensor_ctrl);
+
+void mtk_cam_initial_sensor_setup(struct mtk_cam_request *req,
+			 struct mtk_cam_ctx *ctx);
+void mtk_cam_mstream_initial_sensor_setup(struct mtk_cam_request *req,
+			 struct mtk_cam_ctx *ctx);
+void mtk_cam_req_ctrl_setup(struct mtk_raw_pipeline *raw_pipe,
+			 struct mtk_cam_request *req);
+int mtk_camsys_ctrl_start(struct mtk_cam_ctx *ctx); /* ctx_stream_on */
+void mtk_camsys_ctrl_update(struct mtk_cam_ctx *ctx);
+void mtk_camsys_ctrl_stop(struct mtk_cam_ctx *ctx); /* ctx_stream_off */
+void mtk_cam_req_seninf_change(struct mtk_cam_request *req);
+void mtk_cam_frame_done_work(struct work_struct *work);
+void mtk_cam_meta1_done_work(struct work_struct *work);
+void mtk_cam_sv_work(struct work_struct *work);
+void mtk_cam_m2m_enter_cq_state(struct mtk_camsys_ctrl_state *ctrl_state);
+bool is_first_request_sync(struct mtk_cam_ctx *ctx);
+void
+mtk_cam_set_sensor_full(struct mtk_cam_request_stream_data *s_data,
+			struct mtk_camsys_sensor_ctrl *sensor_ctrl);
+
+void state_transition(struct mtk_camsys_ctrl_state *state_entry,
+		      enum MTK_CAMSYS_STATE_IDX from,
+		      enum MTK_CAMSYS_STATE_IDX to);
+void
+mtk_cam_set_sensor_switch(struct mtk_cam_request_stream_data *s_data,
+			  struct mtk_camsys_sensor_ctrl *sensor_ctrl);
+
+#endif
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam-debug.c b/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam-debug.c
new file mode 100644
index 0000000000000000000000000000000000000000..00e381312245fe650bc05bd041efa7e006a5aa0d
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam-debug.c
@@ -0,0 +1,1264 @@
+// SPDX-License-Identifier: GPL-2.0
+//
+// Copyright (c) 2022 MediaTek Inc.
+
+#ifdef CONFIG_DEBUG_FS
+
+#include <linux/freezer.h>
+#include <linux/videodev2.h>
+#include <media/v4l2-event.h>
+#include "mtk_cam.h"
+#include "mtk_cam-raw.h"
+#ifdef ISP7_1
+#include "mtk_cam-regs-mt8188.h"
+#else
+#include "mtk_cam-regs-mt8195.h"
+#endif
+#include "mtk_cam-debug.h"
+#include "mtk_camera-v4l2-controls.h"
+#include <soc/mediatek/smi.h>
+#define CAMSYS_DUMP_SATATE_INIT		0
+#define CAMSYS_DUMP_SATATE_READY	1
+
+#define CTRL_BLOCK_STATE_EMPTY		0
+#define CTRL_BLOCK_STATE_WRITE		1
+#define CTRL_BLOCK_STATE_READY		2
+#define CTRL_BLOCK_STATE_READ		3
+
+static int mtk_cam_debug_init_dump_param(struct mtk_cam_ctx *ctx,
+				   struct mtk_cam_dump_param *param,
+				   struct mtk_cam_request_stream_data *stream_data,
+				   char *desc)
+{
+	struct mtk_cam_device *cam = ctx->cam;
+	struct mtk_cam_buffer *buf;
+	struct mtk_cam_video_device *node;
+	int request_fd = -1;
+
+	memset(param, 0, sizeof(*param));
+	param->stream_id = ctx->stream_id;
+	param->sequence = stream_data->frame_seq_no;
+	param->timestamp = stream_data->timestamp;
+
+	if (stream_data->working_buf)
+		param->cq_cpu_addr = stream_data->working_buf->buffer.va;
+	else {
+		dev_info(cam->dev,
+			"%s:ctx(%d):req(%d):stream_data->working_buf is null\n",
+			__func__, ctx->stream_id, param->sequence);
+		return -EINVAL;
+	}
+
+	buf = mtk_cam_s_data_get_vbuf(stream_data, MTK_RAW_META_IN);
+	if (buf) {
+		request_fd = buf->vbb.request_fd;
+		node = mtk_cam_vbq_to_vdev(buf->vbb.vb2_buf.vb2_queue);
+		param->meta_in_cpu_addr = vb2_plane_vaddr(&buf->vbb.vb2_buf, 0);
+		param->meta_in_dump_buf_size =
+			node->active_fmt.fmt.meta.buffersize;
+		param->meta_in_iova = buf->daddr;
+		dev_dbg(cam->dev,
+			"%s:ctx(%d):req(%d):MTK_RAW_META_IN(%s) found: %d\n",
+			__func__, ctx->stream_id, param->sequence,
+			node->desc.name, param->meta_in_dump_buf_size);
+	}
+
+	param->cq_size = stream_data->working_buf->buffer.size;
+	param->cq_iova = stream_data->working_buf->buffer.iova;
+	param->cq_desc_offset = stream_data->working_buf->cq_desc_offset;
+	param->cq_desc_size = stream_data->working_buf->cq_desc_size;
+	param->sub_cq_desc_size = stream_data->working_buf->sub_cq_desc_size;
+	param->sub_cq_desc_offset = stream_data->working_buf->sub_cq_desc_offset;
+
+	param->request_fd = request_fd;
+	param->desc = desc;
+
+	/* add mtkcam_ipi_frame_param to dump */
+	param->frame_params = &stream_data->frame_params;
+	param->frame_param_size = sizeof(stream_data->frame_params);
+	dev_dbg(cam->dev, "%s:ctx(%d):req(%d), frame_param size(%d)\n",
+		__func__, ctx->stream_id, param->sequence,
+		param->frame_param_size);
+
+	/* add mtkcam_ipi_config_param to dump */
+	param->config_params = &ctx->config_params;
+	param->config_param_size = sizeof(ctx->config_params);
+	dev_dbg(cam->dev, "%s:ctx(%d):req(%d), cofig_param size(%d)\n",
+		__func__, ctx->stream_id, param->sequence,
+		param->config_param_size);
+
+	return 0;
+}
+
+/* Dump single region to the buffer */
+static void mtk_cam_dump_buf_content(struct device *dev, void *buf, void *src,
+				     int offset, int size, char *buf_name)
+{
+	void *dest;
+
+	if (!src || size <= 0)
+		return;
+
+	dest = buf + offset;
+	dev_dbg(dev, "%s: dump:%s(%p --> %p), offset(%d), size(%d)",
+		__func__, buf_name, src, dest, offset, size);
+	memcpy(dest, src, size);
+}
+
+static void
+mtk_cam_debug_dump_all_content(struct mtk_cam_debug_fs *debug_fs,
+			       void *dump_buf,
+			       struct mtk_cam_dump_param *param)
+{
+	struct mtk_cam_dump_header *header;
+	struct device *dev = debug_fs->cam->dev;
+
+	header = (struct mtk_cam_dump_header *)dump_buf;
+	strncpy(header->desc, param->desc, MTK_CAM_DEBUG_DUMP_DESC_SIZE - 1);
+	header->request_fd = param->request_fd;
+	header->stream_id = param->stream_id;
+	header->timestamp = param->timestamp;
+	header->sequence = param->sequence;
+	header->header_size = sizeof(*header);
+	header->payload_offset = header->header_size;
+	header->payload_size = debug_fs->buf_size -
+			       header->header_size;
+	dev_dbg(dev,
+		"%s:ctx(%d):req_fd(%d),ts(%llu),req(%d),header_sz(%d),payload_offset(%d),payload_sz(%d)",
+		__func__, header->stream_id, header->request_fd,
+		header->timestamp, header->sequence, header->header_size,
+		header->payload_offset, header->payload_size);
+
+	/* meta file information */
+	header->meta_version_major = mtk_cam_get_meta_version(true);
+	header->meta_version_minor = mtk_cam_get_meta_version(false);
+
+	/* CQ dump */
+	header->cq_dump_buf_offset = header->payload_offset;
+	header->cq_size = param->cq_size;
+	header->cq_iova = param->cq_iova;
+	header->cq_desc_offset = param->cq_desc_offset;
+	header->cq_desc_size = param->cq_desc_size;
+	header->sub_cq_desc_offset = param->sub_cq_desc_offset;
+	header->sub_cq_desc_size = param->sub_cq_desc_size;
+
+	/* meta in */
+	header->meta_in_dump_buf_offset = header->cq_dump_buf_offset +
+		header->cq_size;
+	header->meta_in_dump_buf_size = param->meta_in_dump_buf_size;
+	header->meta_in_iova = param->meta_in_iova;
+
+	/* meta out 0 */
+	header->meta_out_0_dump_buf_offset = header->meta_in_dump_buf_offset +
+		header->meta_in_dump_buf_size;
+	header->meta_out_0_dump_buf_size = param->meta_out_0_dump_buf_size;
+	header->meta_out_0_iova = param->meta_out_0_iova;
+
+	/* meta out 1 */
+	header->meta_out_1_dump_buf_offset =
+		header->meta_out_0_dump_buf_offset +
+		header->meta_out_0_dump_buf_size;
+	header->meta_out_1_dump_buf_size = param->meta_out_1_dump_buf_size;
+	header->meta_out_1_iova = param->meta_out_1_iova;
+
+	/* meta out 2 */
+	header->meta_out_2_dump_buf_offset =
+		header->meta_out_1_dump_buf_offset +
+		header->meta_out_1_dump_buf_size;
+	header->meta_out_2_dump_buf_size = param->meta_out_2_dump_buf_size;
+	header->meta_out_2_iova = param->meta_out_2_iova;
+
+	/* ipi frame param */
+	header->frame_dump_offset =
+		header->meta_out_2_dump_buf_offset +
+		header->meta_out_2_dump_buf_size;
+	header->frame_dump_size = param->frame_param_size;
+
+	/* ipi config param */
+	header->config_dump_offset =
+		header->frame_dump_offset +
+		header->frame_dump_size;
+	header->config_dump_size = param->config_param_size;
+	header->used_stream_num = 1;
+
+	mtk_cam_dump_buf_content(dev, dump_buf, param->cq_cpu_addr,
+				 header->cq_dump_buf_offset,
+				 header->cq_size, "CQ");
+
+	mtk_cam_dump_buf_content(dev, dump_buf, param->meta_in_cpu_addr,
+				 header->meta_in_dump_buf_offset,
+				 header->meta_in_dump_buf_size,
+				 "Meta-in");
+
+	mtk_cam_dump_buf_content(dev, dump_buf, param->meta_out_0_cpu_addr,
+				 header->meta_out_0_dump_buf_offset,
+				 header->meta_out_0_dump_buf_size,
+				 "Meta-out-0");
+
+	mtk_cam_dump_buf_content(dev, dump_buf, param->meta_out_1_cpu_addr,
+				 header->meta_out_1_dump_buf_offset,
+				 header->meta_out_1_dump_buf_size,
+				 "Meta-out-1");
+
+	mtk_cam_dump_buf_content(dev, dump_buf, param->meta_out_2_cpu_addr,
+				 header->meta_out_2_dump_buf_offset,
+				 header->meta_out_2_dump_buf_size,
+				 "Meta-out-2");
+
+	mtk_cam_dump_buf_content(dev, dump_buf, param->frame_params,
+				 header->frame_dump_offset,
+				 header->frame_dump_size,
+				 "Ipi-frame-params");
+
+	mtk_cam_dump_buf_content(dev, dump_buf, param->config_params,
+				 header->config_dump_offset,
+				 header->config_dump_size,
+				 "Ipi-config-params");
+}
+
+static struct mtk_cam_dump_ctrl_block*
+mtk_cam_dump_ctrl_block_next(struct mtk_cam_debug_fs *debug_fs,
+			     struct mtk_cam_dump_buf_ctrl *ctrl)
+{
+	struct device *dev = debug_fs->cam->dev;
+	struct mtk_cam_dump_ctrl_block *ctrl_block;
+	int head, tail;
+
+	head = ctrl->head;
+	tail = ctrl->tail;
+
+	if (ctrl->num <= 0) {
+		dev_info(dev, "%s:pipe(%d):no buffer allocated:%d\n", __func__,
+			 ctrl->pipe_id, ctrl->num);
+		return NULL;
+	}
+
+	if (ctrl->count) {
+		head++;
+		if (head == ctrl->num)
+			head = 0;
+		/* User is still reading the buffer*/
+		if (atomic_read(&ctrl->blocks[head].state) == CTRL_BLOCK_STATE_READ)
+			return NULL;
+		/* overwrite the last buffer */
+		if (head == tail)
+			tail++;
+		if (tail == ctrl->num)
+			tail = 0;
+	}
+
+	ctrl->tail = tail;
+	ctrl->head = head;
+	ctrl->count++;
+	if (ctrl->count > ctrl->num)
+		ctrl->count = ctrl->num;
+
+	ctrl_block = &ctrl->blocks[ctrl->head];
+	dev_dbg(dev,
+		"%s:pipe(%d):ctrl_block(%p),buf(%p),head(%d),tail(%d),cnt(%d),num(%d)\n",
+		__func__, ctrl->pipe_id, ctrl_block, ctrl_block->buf, ctrl->head,
+		ctrl->tail, ctrl->count, ctrl->num);
+
+	return ctrl_block;
+}
+
+static int mtk_cam_debug_dump(struct mtk_cam_debug_fs *debug_fs,
+			      struct mtk_cam_dump_param *param)
+{
+	struct device *dev = debug_fs->cam->dev;
+	struct mtk_cam_dump_buf_ctrl *ctrl = &debug_fs->ctrl[param->stream_id];
+	struct mtk_cam_dump_ctrl_block *ctrl_block;
+
+	mutex_lock(&ctrl->ctrl_lock);
+	ctrl_block = mtk_cam_dump_ctrl_block_next(debug_fs, ctrl);
+	if (!ctrl_block || !ctrl_block->buf) {
+		dev_info(dev, "%s:pipe(%d):req(%d):no free buffer, drop\n",
+			 __func__, param->stream_id, param->sequence);
+		mutex_unlock(&ctrl->ctrl_lock);
+
+		return -EINVAL;
+	}
+	mutex_unlock(&ctrl->ctrl_lock);
+
+	atomic_set(&ctrl_block->state, CTRL_BLOCK_STATE_WRITE);
+	mtk_cam_debug_dump_all_content(debug_fs, ctrl_block->buf, param);
+	atomic_set(&ctrl_block->state, CTRL_BLOCK_STATE_READY);
+
+	dev_dbg(dev, "%s:pipe(%d):req(%d):dump(%p) is ready to read, sz(%d)\n",
+		__func__, param->stream_id, param->sequence, ctrl_block->buf,
+		debug_fs->buf_size);
+
+	return 0;
+}
+
+static int mtk_cam_debug_exp_dump(struct mtk_cam_debug_fs *debug_fs,
+				  struct mtk_cam_dump_param *param)
+{
+	struct device *dev = debug_fs->cam->dev;
+	void *dump_buf = debug_fs->exp_dump_buf;
+
+	if (!dump_buf) {
+		dev_info(dev, "%s:pipe(%d):req(%d):no dump buffer. sz(%d)\n",
+			 __func__, param->stream_id, param->sequence,
+			 debug_fs->buf_size);
+		return -EINVAL;
+	}
+
+	mutex_lock(&debug_fs->exp_dump_buf_lock);
+	if (atomic_read(&debug_fs->exp_dump_state) != CAMSYS_DUMP_SATATE_INIT) {
+		dev_info(dev, "%s:pipe(%d):req(%d):dump can't be written, state(%d), buf(%p), sz(%d)\n",
+			 __func__, param->stream_id, param->sequence,
+			 atomic_read(&debug_fs->exp_dump_state), dump_buf,
+			 debug_fs->buf_size);
+		mutex_unlock(&debug_fs->exp_dump_buf_lock);
+
+		return -EINVAL;
+	}
+
+	memset(dump_buf, 0, debug_fs->buf_size);
+	mtk_cam_debug_dump_all_content(debug_fs, dump_buf, param);
+	atomic_set(&debug_fs->exp_dump_state, CAMSYS_DUMP_SATATE_READY);
+	mutex_unlock(&debug_fs->exp_dump_buf_lock);
+
+	dev_dbg(dev, "%s:pipe(%d):req(%d):dump is ready to read\n",
+		__func__, param->stream_id, param->sequence);
+
+	return 0;
+}
+
+static int mtk_cam_debug_find_dump_ctrl(struct mtk_cam_dump_buf_ctrl *ctrl,
+					unsigned long seq)
+{
+	int i = ctrl->head;
+	struct mtk_cam_dump_ctrl_block *ctrl_block;
+	struct mtk_cam_dump_header *header;
+
+	if (!ctrl->count)
+		return -EINVAL;
+
+	while (1) {
+		ctrl_block = &ctrl->blocks[i];
+		header = (struct mtk_cam_dump_header *)ctrl_block->buf;
+		if (header->sequence == seq)
+			return i;
+
+		if (i == ctrl->tail)
+			break;
+
+		if (--i < 0)
+			i = ctrl->num - 1;
+	}
+
+	return -EINVAL;
+}
+
+static int mtk_cam_debug_dump_ctrl_set(struct mtk_cam_dump_buf_ctrl *ctrl,
+				       unsigned long seq, bool start)
+{
+	struct mtk_cam_dump_ctrl_block *ctrl_block;
+	int ctrl_block_idx;
+
+	dev_info(ctrl->debug_fs->cam->dev,
+		 "%s:pipe_id(%d):to read req(%ld), start/end(%d)\n", __func__,
+		 ctrl->pipe_id, seq, start);
+	mutex_lock(&ctrl->ctrl_lock);
+	ctrl_block_idx = mtk_cam_debug_find_dump_ctrl(ctrl, seq);
+	if (ctrl_block_idx < 0) {
+		dev_info(ctrl->debug_fs->cam->dev,
+			 "%s:pipe_id(%d): to read req(%ld) dump, start/end(%d), not found\n",
+			 __func__, ctrl->pipe_id, seq, start);
+		goto FAIL_RELEASE_LOCK;
+	}
+	ctrl_block = &ctrl->blocks[ctrl_block_idx];
+	if (start) {
+		if (atomic_read(&ctrl_block->state) != CTRL_BLOCK_STATE_READY) {
+			dev_info(ctrl->debug_fs->cam->dev,
+				 "%s:pipe_id(%d):to get req(%ld) dump failed, state(%d)\n",
+				__func__, ctrl->pipe_id, seq,
+				atomic_read(&ctrl_block->state));
+			goto FAIL_RELEASE_LOCK;
+		}
+		atomic_set(&ctrl_block->state, CTRL_BLOCK_STATE_READ);
+		ctrl->cur_read = ctrl_block_idx;
+	} else {
+		if (atomic_read(&ctrl_block->state) != CTRL_BLOCK_STATE_READ) {
+			dev_info(ctrl->debug_fs->cam->dev,
+				 "%s:pipe_id(%d):to release req(%ld) dump failed, state(%d)\n",
+				 __func__, ctrl->pipe_id, seq,
+				 atomic_read(&ctrl_block->state));
+			goto FAIL_RELEASE_LOCK;
+		}
+		ctrl->cur_read = -1;
+		atomic_set(&ctrl_block->state, CTRL_BLOCK_STATE_READY);
+	}
+	mutex_unlock(&ctrl->ctrl_lock);
+	return 0;
+
+FAIL_RELEASE_LOCK:
+	ctrl->cur_read = -1;
+	mutex_unlock(&ctrl->ctrl_lock);
+	return -EINVAL;
+}
+
+static void mtk_cam_dump_ctrl_init(struct mtk_cam_debug_fs *debug_fs,
+				   struct mtk_cam_dump_buf_ctrl *ctrl, int num)
+{
+	ctrl->num = num;
+	ctrl->head = 0;
+	ctrl->tail = 0;
+	ctrl->count = 0;
+	ctrl->cur_read = -1;
+}
+
+static void mtk_cam_dump_ctrl_reinit(struct mtk_cam_dump_buf_ctrl *ctrl)
+{
+	int i;
+
+	mutex_lock(&ctrl->ctrl_lock);
+
+	ctrl->head = 0;
+	ctrl->tail = 0;
+	ctrl->count = 0;
+	ctrl->cur_read = -1;
+	for (i = 0; i < ctrl->num; i++)
+		atomic_set(&ctrl->blocks[i].state, CTRL_BLOCK_STATE_EMPTY);
+
+	mutex_unlock(&ctrl->ctrl_lock);
+}
+
+static int mtk_cam_dump_buf_realloc(struct mtk_cam_dump_buf_ctrl *ctrl,
+				    int num_of_bufs)
+{
+	int num_of_alloc = 0;
+	int i;
+	struct mtk_cam_dump_ctrl_block *ctrl_block;
+	struct mtk_cam_debug_fs *debug_fs = ctrl->debug_fs;
+	struct device *dev = debug_fs->cam->dev;
+	void *dump_buf;
+
+	mutex_lock(&ctrl->ctrl_lock);
+	/* Release the previous buffers */
+	for (i = 0; i < ctrl->num; i++) {
+		dev_dbg(dev, "%s:pipe(%d):free dump buf(%d):%p\n", __func__,
+			ctrl->pipe_id, i, ctrl->blocks[i].buf);
+		vfree(ctrl->blocks[i].buf);
+		ctrl->blocks[i].buf = NULL;
+	}
+
+	if (num_of_bufs > MTK_CAM_DEBUG_DUMP_MAX_BUF)
+		ctrl->num = MTK_CAM_DEBUG_DUMP_MAX_BUF;
+	else
+		ctrl->num = num_of_bufs;
+
+	for (i = 0; i < ctrl->num; i++) {
+		dump_buf = vzalloc(debug_fs->buf_size);
+		if (!dump_buf)
+			break;
+
+		ctrl_block = &ctrl->blocks[i];
+		atomic_set(&ctrl_block->state, CTRL_BLOCK_STATE_EMPTY);
+		ctrl_block->buf = dump_buf;
+		num_of_alloc++;
+		dev_dbg(dev, "%s:pipe(%d):alloc dump buf(%d):%p\n", __func__,
+			ctrl->pipe_id, i, ctrl->blocks[i].buf);
+	}
+
+	mtk_cam_dump_ctrl_init(debug_fs, ctrl, num_of_alloc);
+	dev_info(dev, "%s:pipe(%d):cnt(%d), head(%d), tail(%d), entry_sz(%d), entry_num(%d)\n",
+		 __func__, ctrl->pipe_id, ctrl->count, ctrl->head,
+		 ctrl->tail, debug_fs->buf_size, ctrl->num);
+	mutex_unlock(&ctrl->ctrl_lock);
+
+	return 0;
+}
+
+static int dbg_ctrl_open(struct inode *inode, struct file *file)
+{
+	struct mtk_cam_debug_fs *debug_fs;
+	struct mtk_cam_dump_buf_ctrl *ctrl;
+
+	if (inode->i_private)
+		file->private_data = inode->i_private;
+
+	ctrl = file->private_data;
+	debug_fs = ctrl->debug_fs;
+
+	dev_dbg(debug_fs->cam->dev,
+		"%s:pipe(%d):cnt(%d), head(%d), tail(%d), entry_sz(%d), entry_num(%d)\n",
+		__func__, ctrl->pipe_id, ctrl->count, ctrl->head, ctrl->tail,
+		debug_fs->buf_size, ctrl->num);
+
+	return 0;
+}
+
+static ssize_t dbg_ctrl_write(struct file *file, const char __user *data,
+			      size_t count, loff_t *ppos)
+{
+	struct mtk_cam_debug_fs *debug_fs;
+	struct mtk_cam_dump_buf_ctrl *ctrl;
+	char tmp[16];
+	char *parse_str = tmp;
+	char *cmd_str;
+	char *param_str_0;
+	char *param_str_1;
+	unsigned long seq = 0;
+	int ret = -EINVAL;
+
+	ctrl = file->private_data;
+	debug_fs = ctrl->debug_fs;
+	if (count >= 15) {
+		dev_info(ctrl->debug_fs->cam->dev,
+			 "%s:pipe(%d):Invalid cmd sz(%ld)\n", __func__,
+			 ctrl->pipe_id, count);
+		goto FAIL;
+	}
+
+	memset(tmp, 0, 16);
+	if (copy_from_user(tmp, data, count)) {
+		dev_info(ctrl->debug_fs->cam->dev,
+			 "%s:pipe(%d):copy_from_user failed, data(%p), sz(%ld)\n",
+			 __func__, ctrl->pipe_id, data, count);
+		ret = -EFAULT;
+		goto FAIL;
+	}
+	dev_dbg(ctrl->debug_fs->cam->dev, "%s:pipe(%d):received cmd(%s)\n",
+		__func__, ctrl->pipe_id, tmp);
+	cmd_str = strsep(&parse_str, ":");
+	param_str_0 = strsep(&parse_str, ":");
+
+	if (cmd_str[0] == 'r') {
+		param_str_1 = strsep(&parse_str, ":");
+		if (kstrtoul(param_str_1, 10, &seq)) {
+			ret = -EFAULT;
+			dev_dbg(ctrl->debug_fs->cam->dev, "kstrtoul failed:%s\n",
+				param_str_1);
+			goto FAIL;
+		}
+
+		if (param_str_0[0] == 's') {
+			ret = mtk_cam_debug_dump_ctrl_set(ctrl, seq, true);
+			if (ret < 0)
+				goto FAIL;
+		} else if (param_str_0[0] == 'e') {
+			ret = mtk_cam_debug_dump_ctrl_set(ctrl, seq, false);
+			if (ret < 0)
+				goto FAIL;
+		} else {
+			ret = -EFAULT;
+			goto FAIL;
+		}
+	} else if (cmd_str[0] == 'd') {
+		if (param_str_0[0] == 's') {
+			mtk_cam_dump_buf_realloc(ctrl, MTK_CAM_DEBUG_DUMP_MAX_BUF);
+			debug_fs->force_dump = MTK_CAM_REQ_DUMP_FORCE;
+		} else if (param_str_0[0] == 'r') {
+			mtk_cam_dump_ctrl_reinit(ctrl);
+			debug_fs->force_dump = MTK_CAM_REQ_DUMP_FORCE;
+		} else if (param_str_0[0] == 'e') {
+			debug_fs->force_dump = 0;
+			mtk_cam_dump_buf_realloc(ctrl, 0);
+		} else {
+			ret = -EFAULT;
+			goto FAIL;
+		}
+	}
+
+	return count;
+FAIL:
+	return ret;
+}
+
+static int dbg_data_open(struct inode *inode, struct file *file)
+{
+	struct mtk_cam_debug_fs *debug_fs;
+	struct mtk_cam_dump_buf_ctrl *ctrl;
+
+	if (inode->i_private)
+		file->private_data = inode->i_private;
+
+	ctrl = file->private_data;
+	debug_fs = ctrl->debug_fs;
+
+	dev_dbg(debug_fs->cam->dev,
+		"%s:pipe(%d):cnt(%d), head(%d), tail(%d), entry_sz(%d), entry_num(%d)\n",
+		__func__, ctrl->pipe_id, ctrl->count, ctrl->head, ctrl->tail,
+		debug_fs->buf_size, ctrl->num);
+
+	return 0;
+}
+
+static ssize_t dbg_data_read(struct file *file, char __user *user_buf,
+			     size_t count, loff_t *ppos)
+{
+	struct mtk_cam_dump_buf_ctrl *ctrl = file->private_data;
+	struct mtk_cam_debug_fs *debug_fs = ctrl->debug_fs;
+	struct mtk_cam_dump_ctrl_block *ctrl_block;
+
+	int cur_read = 0;
+	size_t read_count;
+
+	cur_read = ctrl->cur_read;
+	if (cur_read < 0) {
+		dev_dbg(debug_fs->cam->dev,
+			"%s:pipe(%d):user requested seq not found! cur_read(%d)\n",
+			__func__, ctrl->pipe_id, cur_read);
+		return 0;
+	}
+
+	ctrl_block = &ctrl->blocks[cur_read];
+	if (atomic_read(&ctrl_block->state) != CTRL_BLOCK_STATE_READ)
+		return 0;
+
+	dev_dbg(debug_fs->cam->dev,
+		"%s:pipe(%d):read buf request: %ld bytes\n", __func__,
+		ctrl->pipe_id, count);
+	read_count = simple_read_from_buffer(user_buf, count, ppos,
+					     ctrl_block->buf,
+					     debug_fs->buf_size);
+
+	return read_count;
+}
+
+static int mtk_cam_debug_has_exp_dump(struct mtk_cam_debug_fs *debug_fs)
+{
+	return (atomic_read(&debug_fs->exp_dump_state) == CAMSYS_DUMP_SATATE_READY);
+}
+
+static int exp_open(struct inode *inode, struct file *file)
+{
+	if (inode->i_private)
+		file->private_data = inode->i_private;
+
+	return 0;
+}
+
+static ssize_t exp_read(struct file *file, char __user *user_buf,
+			size_t count, loff_t *ppos)
+{
+	struct device *dev = file->private_data;
+	struct mtk_cam_device *cam;
+	struct mtk_cam_debug_fs *debug_fs;
+	size_t read_count;
+
+	if (!dev)
+		pr_debug("%s: dev can't be null\n", __func__);
+
+	cam = (struct mtk_cam_device *)dev_get_drvdata(dev);
+	if (!cam)
+		dev_dbg(dev, "%s: cam can't be null\n", __func__);
+
+	debug_fs = cam->debug_fs;
+	if (!debug_fs)
+		dev_dbg(dev, "%s: debug_fs can't be null\n", __func__);
+
+	if (!debug_fs->exp_dump_buf)
+		dev_dbg(dev, "%s: dump buf can't be null\n", __func__);
+
+	/* If no dump, return 0 byte read directly */
+	if (!mtk_cam_debug_has_exp_dump(debug_fs))
+		return 0;
+
+	dev_dbg(dev, "%s: read buf request: %ld bytes\n", __func__, count);
+	mutex_lock(&debug_fs->exp_dump_buf_lock);
+
+	read_count = simple_read_from_buffer(user_buf, count, ppos,
+					     debug_fs->exp_dump_buf,
+					     debug_fs->buf_size);
+
+	mutex_unlock(&debug_fs->exp_dump_buf_lock);
+
+	return read_count;
+}
+
+static int exp_release(struct inode *inode, struct file *file)
+{
+	struct device *dev;
+	struct mtk_cam_device *cam;
+	struct mtk_cam_debug_fs *debug_fs;
+
+	dev = file->private_data;
+	if (!dev) {
+		pr_debug("%s: dev is NULL", __func__);
+		return 0;
+	}
+
+	cam = (struct mtk_cam_device *)dev_get_drvdata(dev);
+	if (!cam) {
+		dev_dbg(dev, "%s: cam is NULL", __func__);
+		return 0;
+	}
+
+	debug_fs = cam->debug_fs;
+	dev_dbg(dev, "%s dump_state: %d\n", __func__,
+		atomic_read(&debug_fs->exp_dump_state));
+
+	return 0;
+}
+
+static const struct file_operations dbg_ctrl_fops = {
+	.open = dbg_ctrl_open,
+	.write = dbg_ctrl_write,
+};
+
+static const struct file_operations dbg_data_fops = {
+	.open = dbg_data_open,
+	.read = dbg_data_read,
+	.llseek = default_llseek,
+};
+
+static const struct file_operations exp_fops = {
+	.open = exp_open,
+	.read = exp_read,
+	.release = exp_release,
+};
+
+static int mtk_cam_exp_reinit(struct mtk_cam_debug_fs *debug_fs)
+{
+	/* Let the exception dump buffer can be written again */
+	mutex_lock(&debug_fs->exp_dump_buf_lock);
+	atomic_set(&debug_fs->exp_dump_state, CAMSYS_DUMP_SATATE_INIT);
+	mutex_unlock(&debug_fs->exp_dump_buf_lock);
+	return 0;
+}
+
+static int mtk_cam_debug_reinit(struct mtk_cam_debug_fs *debug_fs,
+				int streaming_id)
+{
+	struct mtk_cam_dump_buf_ctrl *ctrl;
+
+	if (!debug_fs->force_dump)
+		return 0;
+
+	ctrl = &debug_fs->ctrl[streaming_id];
+	mtk_cam_dump_ctrl_reinit(ctrl);
+
+	return 0;
+}
+
+static int mtk_cam_debug_init(struct mtk_cam_debug_fs *debug_fs,
+			      struct mtk_cam_device *cam, int content_size)
+{
+	struct mtk_cam_dump_buf_ctrl *ctrl;
+	void *exp_dump_buf;
+	int dump_mem_size, i;
+
+	dump_mem_size = content_size + sizeof(struct mtk_cam_dump_header);
+	debug_fs->cam = cam;
+	debug_fs->buf_size = dump_mem_size;
+
+	/* Exception dump initialization*/
+	exp_dump_buf = kzalloc(dump_mem_size, GFP_KERNEL);
+	if (!exp_dump_buf)
+		return -ENOMEM;
+
+	debug_fs->exp_dump_buf = exp_dump_buf;
+	atomic_set(&debug_fs->exp_dump_state, CAMSYS_DUMP_SATATE_INIT);
+	mutex_init(&debug_fs->exp_dump_buf_lock);
+
+	debug_fs->exp_dump_entry = debugfs_create_file("mtk_cam_exp_dump",
+						       0444, NULL, cam->dev,
+						       &exp_fops);
+	if (!debug_fs->exp_dump_entry) {
+		dev_info(cam->dev, "Can't create debug fs\n");
+		return -ENOMEM;
+	}
+
+	debug_fs->dbg_entry = debugfs_create_dir("mtk_cam_dbg", NULL);
+	for (i = 0; i < cam->max_stream_num; i++) {
+		char name[4];
+
+		ctrl = &debug_fs->ctrl[i];
+		ctrl->pipe_id = i;
+		ctrl->debug_fs = debug_fs;
+		atomic_set(&ctrl->dump_state, CAMSYS_DUMP_SATATE_INIT);
+		mutex_init(&ctrl->ctrl_lock);
+
+		snprintf(name, 4, "%d", i);
+		ctrl->dir_entry = debugfs_create_dir(name, debug_fs->dbg_entry);
+		if (!ctrl->dir_entry) {
+			dev_info(cam->dev,
+				 "Can't create dir for pipe:%d\n", i);
+			return -ENOMEM;
+		}
+
+		ctrl->ctrl_entry = debugfs_create_file("ctrl", 0664,
+						       ctrl->dir_entry, ctrl,
+						       &dbg_ctrl_fops);
+		if (!ctrl->ctrl_entry) {
+			dev_info(cam->dev,
+				 "Can't create ctrl file for pipe:%d\n", i);
+			return -ENOMEM;
+		}
+
+		ctrl->data_entry = debugfs_create_file("data", 0444,
+						       ctrl->dir_entry, ctrl,
+						       &dbg_data_fops);
+		if (!ctrl->data_entry) {
+			dev_info(cam->dev,
+				 "Can't create data file for pipe:%d\n", i);
+			return -ENOMEM;
+		}
+	}
+
+	return 0;
+}
+
+static void mtk_cam_debug_deinit(struct mtk_cam_debug_fs *debug_fs)
+{
+	struct mtk_cam_dump_buf_ctrl *ctrl;
+	int i;
+
+	if (!debug_fs)
+		return;
+
+	for (i = 0; i < debug_fs->cam->max_stream_num; i++) {
+		ctrl = &debug_fs->ctrl[i];
+		debugfs_remove(ctrl->ctrl_entry);
+		debugfs_remove(ctrl->data_entry);
+		debugfs_remove(ctrl->dir_entry);
+	}
+
+	debugfs_remove(debug_fs->dbg_entry);
+	kfree(debug_fs->exp_dump_buf);
+	dev_dbg(debug_fs->cam->dev, "Free exception dump buffer\n");
+	debugfs_remove(debug_fs->exp_dump_entry);
+}
+
+static void mtk_cam_debug_dump_work(struct work_struct *work)
+{
+	struct mtk_cam_req_dbg_work *dbg_work = to_mtk_cam_req_dbg_work(work);
+	struct mtk_cam_request_stream_data *s_data = dbg_work->s_data;
+	struct mtk_cam_ctx *ctx = mtk_cam_s_data_get_ctx(s_data);
+	struct mtk_cam_dump_param dump_param;
+	struct v4l2_event event = {
+		.type = V4L2_EVENT_REQUEST_DUMPED,
+	};
+	int ret = 0;
+
+	ret = mtk_cam_debug_init_dump_param(ctx, &dump_param, s_data,
+				      dbg_work->desc);
+	if (ret < 0) {
+		atomic_set(&dbg_work->state, MTK_CAM_REQ_DBGWORK_S_FINISHED);
+		return;
+	}
+
+	ctx->cam->debug_fs->ops->dump(ctx->cam->debug_fs, &dump_param);
+	atomic_set(&dbg_work->state, MTK_CAM_REQ_DBGWORK_S_FINISHED);
+
+	event.u.frame_sync.frame_sequence = dump_param.sequence;
+	v4l2_event_queue(ctx->pipe->subdev.devnode, &event);
+}
+
+static void mtk_cam_exception_work(struct work_struct *work)
+{
+	struct mtk_cam_req_dbg_work *dbg_work = to_mtk_cam_req_dbg_work(work);
+	struct mtk_cam_request_stream_data *s_data = dbg_work->s_data;
+	struct mtk_cam_request *req = mtk_cam_s_data_get_req(s_data);
+	struct mtk_cam_ctx *ctx = mtk_cam_s_data_get_ctx(s_data);
+	struct mtk_cam_dump_param dump_param;
+	char warn_desc[48];
+	char title_desc[48];
+	int ret = 0;
+
+	if (s_data == NULL)
+		return;
+
+	if (atomic_read(&s_data->dbg_exception_work.state) == MTK_CAM_REQ_DBGWORK_S_CANCEL) {
+		dev_info(ctx->cam->dev,
+			 "%s:ctx(%d):used_raw(0x%x):exception dump canceled\n",
+			 __func__, ctx->stream_id, ctx->used_raw_dev);
+		return;
+	}
+
+	ret = mtk_cam_debug_init_dump_param(ctx, &dump_param, s_data,
+				      dbg_work->desc);
+
+	if (ret < 0) {
+		atomic_set(&dbg_work->state, MTK_CAM_REQ_DBGWORK_S_FINISHED);
+		return;
+	}
+
+	ctx->cam->debug_fs->ops->exp_dump(ctx->cam->debug_fs, &dump_param);
+	snprintf(title_desc, 48, "Camsys:%s", dbg_work->desc);
+	snprintf(warn_desc, 48, "%s:ctx(%d):req(%d):%s",
+		 req->req.debug_str, ctx->stream_id, s_data->frame_seq_no,
+		 dbg_work->desc);
+	dev_info(ctx->cam->dev, "%s:camsys dump, %s\n",
+		 __func__, warn_desc);
+
+	WARN_ON(1);
+
+	atomic_set(&dbg_work->state, MTK_CAM_REQ_DBGWORK_S_FINISHED);
+}
+
+static bool
+mtk_cam_exceptoin_is_job_done(struct mtk_cam_request_stream_data *s_data,
+			      bool *streamoff)
+{
+	struct mtk_cam_ctx *ctx = mtk_cam_s_data_get_ctx(s_data);
+	int state;
+
+	spin_lock(&ctx->streaming_lock);
+	if (!ctx->streaming) {
+		spin_unlock(&ctx->streaming_lock);
+		*streamoff = true;
+		return true;
+	}
+	spin_unlock(&ctx->streaming_lock);
+
+	state = atomic_read(&s_data->dbg_exception_work.state);
+	if (state == MTK_CAM_REQ_DBGWORK_S_FINISHED ||
+	    state == MTK_CAM_REQ_DBGWORK_S_INIT ||
+	    state == MTK_CAM_REQ_DBGWORK_S_CANCEL) {
+		*streamoff = false;
+		return true;
+	}
+
+	return false;
+}
+
+static void mtk_cam_exceptoin_detect_work(struct work_struct *work)
+{
+	struct mtk_cam_req_dbg_work *dbg_work = to_mtk_cam_req_dbg_work(work);
+	struct mtk_cam_request_stream_data *s_data = dbg_work->s_data;
+	struct mtk_cam_request *req = mtk_cam_s_data_get_req(s_data);
+	struct mtk_cam_ctx *ctx = mtk_cam_s_data_get_ctx(s_data);
+	int ret;
+	bool streamoff;
+
+	ret = wait_event_freezable_timeout(ctx->cam->debug_exception_waitq,
+					   mtk_cam_exceptoin_is_job_done(s_data, &streamoff),
+					   msecs_to_jiffies(1000 / 30 * 8));
+	if (ret) {
+		if (!streamoff) {
+			dev_info(ctx->cam->dev,
+				"%s:ctx(%d):%s:req(%d):skip dump since job done\n",
+				__func__, ctx->stream_id, req->req.debug_str,
+				s_data->frame_seq_no);
+			atomic_set(&dbg_work->state, MTK_CAM_REQ_DBGWORK_S_FINISHED);
+		} else {
+			/**
+			 * Workaround for abnormal request release after
+			 * streaming off now, we can't touch the request
+			 * any more.
+			 */
+			dev_info(ctx->cam->dev,
+				 "%s: skip dump work for stream off ctx:%d\n",
+				 __func__, ctx->stream_id);
+		}
+		return;
+	}
+
+	if (atomic_read(&s_data->dbg_exception_work.state) == MTK_CAM_REQ_DBGWORK_S_CANCEL) {
+		dev_info(ctx->cam->dev,
+			 "%s:ctx(%d):used_raw(0x%x):exception dump canceled\n",
+			 __func__, ctx->stream_id, ctx->used_raw_dev);
+		return;
+	}
+
+	if (ctx->seninf) {
+		ret = mtk_cam_seninf_dump(ctx->seninf);
+		dev_info(ctx->cam->dev,
+			"%s:ctx(%d):used_raw(0x%x):mtk_cam_seninf_dump() ret=%d\n",
+			__func__, ctx->stream_id, ctx->used_raw_dev, ret);
+	} else {
+		dev_info(ctx->cam->dev, "%s: cannot find ctx->seninf\n",
+			 __func__);
+	}
+
+	mtk_cam_exception_work(work);
+}
+
+int mtk_cam_req_dump(struct mtk_cam_request_stream_data *s_data,
+		     unsigned int dump_flag, char *desc, bool smi_dump)
+{
+	struct mtk_cam_ctx *ctx = mtk_cam_s_data_get_ctx(s_data);
+	struct mtk_cam_req_dbg_work *dbg_work;
+	void (*work_func)(struct work_struct *work);
+	struct workqueue_struct *wq;
+
+	if (!ctx->cam->debug_fs)
+		return false;
+
+	switch (dump_flag) {
+	case MTK_CAM_REQ_DUMP_FORCE:
+		if (!ctx->cam->debug_fs->force_dump ||
+		    !ctx->cam->debug_fs->ctrl[ctx->stream_id].num)
+			return false;
+
+		dbg_work = &s_data->dbg_work;
+		work_func = mtk_cam_debug_dump_work;
+		wq = ctx->cam->debug_wq;
+		break;
+	case MTK_CAM_REQ_DUMP_DEQUEUE_FAILED:
+		dbg_work =  &s_data->dbg_exception_work;
+		work_func = mtk_cam_exception_work;
+		wq = ctx->cam->debug_exception_wq;
+		break;
+	case MTK_CAM_REQ_DUMP_CHK_DEQUEUE_FAILED:
+		dbg_work =  &s_data->dbg_exception_work;
+		work_func = mtk_cam_exceptoin_detect_work;
+		wq = ctx->cam->debug_exception_wq;
+		break;
+	default:
+		dev_dbg(ctx->cam->dev,
+			"%s:seq(%d) dump skipped, unknown dump type (%d)\n",
+			__func__, s_data->frame_seq_no,
+			dump_flag);
+		return false;
+	}
+
+	if (atomic_read(&dbg_work->state) != MTK_CAM_REQ_DBGWORK_S_INIT)
+		return false;
+
+	INIT_WORK(&dbg_work->work, work_func);
+	dbg_work->s_data = s_data;
+	dbg_work->dump_flags = dump_flag;
+	dbg_work->smi_dump = smi_dump;
+	atomic_set(&dbg_work->state, MTK_CAM_REQ_DBGWORK_S_PREPARED);
+	snprintf(dbg_work->desc, MTK_CAM_DEBUG_DUMP_DESC_SIZE - 1, desc);
+	if (!queue_work(wq, &dbg_work->work)) {
+		dev_dbg(ctx->cam->dev,
+			"%s: seq(%d) failed, debug work is already in queue\n",
+			__func__, s_data->frame_seq_no);
+		return false;
+	}
+
+	return true;
+}
+
+void
+mtk_cam_debug_detect_dequeue_failed(struct mtk_cam_request_stream_data *s_data,
+				    const unsigned int frame_no_update_limit,
+				    struct mtk_camsys_irq_info *irq_info,
+				    struct mtk_raw_device *raw_dev)
+{
+#define NO_P1_DONE_DEBUG_START 3
+
+	struct mtk_cam_ctx *ctx;
+	struct mtk_cam_request *req;
+
+	if (irq_info->fbc_cnt == 0)
+		return;
+	/**
+	 * If the requset is already dequeued (for example, the p1 done and sof
+	 * interrupt come almost together), skip the check.
+	 */
+	if (!s_data)
+		return;
+
+	ctx = mtk_cam_s_data_get_ctx(s_data);
+	req = mtk_cam_s_data_get_req(s_data);
+
+	if (ctx->composed_frame_seq_no < ctx->dequeued_frame_seq_no)
+		return;
+
+	if (s_data->state.estate == E_STATE_CQ ||
+	    s_data->state.estate == E_STATE_OUTER ||
+	    s_data->state.estate == E_STATE_INNER ||
+	    s_data->state.estate == E_STATE_OUTER_HW_DELAY ||
+	    s_data->state.estate == E_STATE_INNER_HW_DELAY) {
+		s_data->no_frame_done_cnt++;
+		if (s_data->no_frame_done_cnt > 1)
+			dev_info(ctx->cam->dev,
+			 "%s:SOF[ctx:%d-#%d] no p1 done for %d sofs, FBC_CNT %d dump req(%d) state(%d) ts(%llu)\n",
+			 req->req.debug_str, ctx->stream_id,
+			 ctx->dequeued_frame_seq_no,
+			 s_data->no_frame_done_cnt, irq_info->fbc_cnt,
+			 s_data->frame_seq_no, s_data->state.estate, irq_info->ts_ns / 1000);
+	}
+	if (s_data->no_frame_done_cnt >= NO_P1_DONE_DEBUG_START) {
+		dev_info(raw_dev->dev,
+			 "INT_EN %x\n",
+			 readl_relaxed(raw_dev->base + REG_CTL_RAW_INT_EN));
+
+		dev_info(raw_dev->dev,
+			 "REQ RAW/2/3 DMA/2:%08x/%08x/%08x/%08x/%08x\n",
+			 readl_relaxed(raw_dev->base + REG_CTL_RAW_MOD_REQ_STAT),
+			 readl_relaxed(raw_dev->base + REG_CTL_RAW_MOD2_REQ_STAT),
+			 readl_relaxed(raw_dev->base + REG_CTL_RAW_MOD3_REQ_STAT),
+			 readl_relaxed(raw_dev->base + REG_CTL_RAW_MOD5_REQ_STAT),
+			 readl_relaxed(raw_dev->base + REG_CTL_RAW_MOD6_REQ_STAT));
+		dev_info(raw_dev->dev,
+			 "RDY RAW/2/3 DMA/2:%08x/%08x/%08x/%08x/%08x\n",
+			 readl_relaxed(raw_dev->base + REG_CTL_RAW_MOD_RDY_STAT),
+			 readl_relaxed(raw_dev->base + REG_CTL_RAW_MOD2_RDY_STAT),
+			 readl_relaxed(raw_dev->base + REG_CTL_RAW_MOD3_RDY_STAT),
+			 readl_relaxed(raw_dev->base + REG_CTL_RAW_MOD5_RDY_STAT),
+			 readl_relaxed(raw_dev->base + REG_CTL_RAW_MOD6_RDY_STAT));
+		dev_info(raw_dev->dev,
+			 "REQ YUV/2/3/4 WDMA:%08x/%08x/%08x/%08x/%08x\n",
+			 readl_relaxed(raw_dev->yuv_base + REG_CTL_RAW_MOD_REQ_STAT),
+			 readl_relaxed(raw_dev->yuv_base + REG_CTL_RAW_MOD2_REQ_STAT),
+			 readl_relaxed(raw_dev->yuv_base + REG_CTL_RAW_MOD3_REQ_STAT),
+			 readl_relaxed(raw_dev->yuv_base + REG_CTL_RAW_MOD4_REQ_STAT),
+			 readl_relaxed(raw_dev->yuv_base + REG_CTL_RAW_MOD5_REQ_STAT));
+		dev_info(raw_dev->dev,
+			 "RDY YUV/2/3/4 WDMA:%08x/%08x/%08x/%08x/%08x\n",
+			 readl_relaxed(raw_dev->yuv_base + REG_CTL_RAW_MOD_RDY_STAT),
+			 readl_relaxed(raw_dev->yuv_base + REG_CTL_RAW_MOD2_RDY_STAT),
+			 readl_relaxed(raw_dev->yuv_base + REG_CTL_RAW_MOD3_RDY_STAT),
+			 readl_relaxed(raw_dev->yuv_base + REG_CTL_RAW_MOD4_RDY_STAT),
+			 readl_relaxed(raw_dev->yuv_base + REG_CTL_RAW_MOD5_RDY_STAT));
+	}
+
+	if (s_data->no_frame_done_cnt > frame_no_update_limit &&
+		s_data->dbg_work.dump_flags == 0) {
+		dev_info(ctx->cam->dev,
+			 "%s:SOF[ctx:%d-#%d] no p1 done for %d sofs, FBC_CNT %d dump req(%d) state(%d) ts(%llu)\n",
+			 req->req.debug_str, ctx->stream_id,
+			 ctx->dequeued_frame_seq_no,
+			 s_data->no_frame_done_cnt, irq_info->fbc_cnt,
+			 s_data->frame_seq_no,
+			 s_data->state.estate, irq_info->ts_ns / 1000);
+		mtk_cam_req_dump(s_data, MTK_CAM_REQ_DUMP_DEQUEUE_FAILED,
+				 "No P1 done", false);
+	} else if (s_data->no_frame_done_cnt > frame_no_update_limit &&
+		s_data->dbg_work.dump_flags != 0)
+		dev_info(ctx->cam->dev,
+			 "%s:SOF[ctx:%d-#%d] no p1 done for %d sofs, s_data->dbg_work.dump_flags(%d) state(%d) ts(%llu)\n",
+			 req->req.debug_str, ctx->stream_id,
+			 ctx->dequeued_frame_seq_no,
+			 s_data->no_frame_done_cnt, s_data->dbg_work.dump_flags,
+			 s_data->state.estate, irq_info->ts_ns / 1000);
+}
+
+void mtk_cam_debug_wakeup(struct wait_queue_head *wq_head)
+{
+	wake_up(wq_head);
+}
+
+static void mtk_cam_req_seninf_dump_work(struct work_struct *work)
+{
+	struct mtk_cam_seninf_dump_work *seninf_dump_work;
+	struct v4l2_subdev *seninf;
+
+	seninf_dump_work = to_mtk_cam_seninf_dump_work(work);
+	seninf = seninf_dump_work->seninf;
+	if (!seninf)
+		pr_info("%s: filaed, seninf can't be NULL\n", __func__);
+	else
+		mtk_cam_seninf_dump(seninf);
+
+	kfree(seninf_dump_work);
+}
+
+void
+mtk_cam_debug_seninf_dump(struct mtk_cam_request_stream_data *s_data)
+{
+	struct mtk_cam_ctx *ctx;
+	struct mtk_cam_seninf_dump_work *dump_work;
+	int err = 0;
+
+	ctx = mtk_cam_s_data_get_ctx(s_data);
+	if (!ctx) {
+		pr_info("%s: failed, ctx can't be NULL\n", __func__);
+		return;
+	}
+
+	spin_lock(&ctx->streaming_lock);
+	if (!ctx->streaming) {
+		dev_info(ctx->cam->dev,
+			 "%s:ctx(%d):s_data(%d) drop dump due to stream off\n",
+			 __func__, ctx->stream_id, s_data->frame_seq_no);
+		spin_unlock(&ctx->streaming_lock);
+		return;
+	}
+	spin_unlock(&ctx->streaming_lock);
+
+	if (atomic_read(&s_data->seninf_dump_state) != MTK_CAM_REQ_DBGWORK_S_INIT) {
+		dev_info(ctx->cam->dev,
+			 "%s:ctx(%d):s_data(%d) drop duplicated dump\n",
+			 __func__, ctx->stream_id, s_data->frame_seq_no);
+
+		return;
+	}
+
+	dump_work = kmalloc(sizeof(*dump_work), GFP_ATOMIC);
+	if (!dump_work)
+		err = -ENOMEM;
+
+	if (err)
+		dev_info(ctx->cam->dev, "failed to alloc dump_work\n");
+
+	dump_work->seninf = ctx->seninf;
+	INIT_WORK(&dump_work->work, mtk_cam_req_seninf_dump_work);
+	if (!queue_work(ctx->frame_done_wq, &dump_work->work))
+		dev_info(ctx->cam->dev,
+			 "%s:ctx(%d):s_data(%d) work was already on a queue\n",
+			 __func__, ctx->stream_id, s_data->frame_seq_no);
+	else
+		atomic_set(&s_data->seninf_dump_state, MTK_CAM_REQ_DBGWORK_S_FINISHED);
+
+}
+
+void mtk_cam_req_dump_work_init(struct mtk_cam_request_stream_data *s_data)
+{
+	atomic_set(&s_data->seninf_dump_state, MTK_CAM_REQ_DBGWORK_S_INIT);
+}
+
+void mtk_cam_req_dbg_works_clean(struct mtk_cam_request_stream_data *s_data)
+{
+	struct mtk_cam_ctx *ctx = mtk_cam_s_data_get_ctx(s_data);
+	char *dbg_str = mtk_cam_s_data_get_dbg_str(s_data);
+	int state;
+	u64 start, cost;
+
+	/* clean seninf dump work */
+	atomic_set(&s_data->seninf_dump_state, MTK_CAM_REQ_DBGWORK_S_FINISHED);
+
+	/* clean execption dump work */
+	state = atomic_read(&s_data->dbg_exception_work.state);
+	if (state != MTK_CAM_REQ_DBGWORK_S_INIT &&
+	    state != MTK_CAM_REQ_DBGWORK_S_FINISHED) {
+		atomic_set(&s_data->dbg_exception_work.state, MTK_CAM_REQ_DBGWORK_S_CANCEL);
+		mtk_cam_debug_wakeup(&ctx->cam->debug_exception_waitq);
+		start = ktime_get_boottime_ns();
+		cancel_work_sync(&s_data->dbg_exception_work.work);
+		cost = ktime_get_boottime_ns() - start;
+
+		dev_info(ctx->cam->dev,
+			 "%s:ctx(%d):%s:seq(%d): cancel dbg_exception_work(%d), wait: %llu ns\n",
+			 __func__, ctx->stream_id, dbg_str,
+			 s_data->frame_seq_no, state, cost);
+		atomic_set(&s_data->dbg_exception_work.state, MTK_CAM_REQ_DBGWORK_S_FINISHED);
+	} else {
+		mtk_cam_debug_wakeup(&ctx->cam->debug_exception_waitq);
+		atomic_set(&s_data->dbg_exception_work.state, MTK_CAM_REQ_DBGWORK_S_FINISHED);
+	}
+
+	/* clean debug dump work */
+	state = atomic_read(&s_data->dbg_work.state);
+	if (state != MTK_CAM_REQ_DBGWORK_S_INIT &&
+	    state != MTK_CAM_REQ_DBGWORK_S_FINISHED) {
+		start = ktime_get_boottime_ns();
+		cancel_work_sync(&s_data->dbg_work.work);
+		cost = ktime_get_boottime_ns() - start;
+		dev_info(ctx->cam->dev,
+			 "%s:ctx(%d):%s:seq(%d): cancel dbg_work(%d), wait: %llu ns\n",
+			  __func__, ctx->stream_id, dbg_str,
+			 s_data->frame_seq_no, state, cost);
+		atomic_set(&s_data->dbg_work.state, MTK_CAM_REQ_DBGWORK_S_FINISHED);
+	}
+
+}
+
+static struct mtk_cam_debug_ops debug_ops = {
+	.init = mtk_cam_debug_init,
+	.reinit = mtk_cam_debug_reinit,
+	.deinit = mtk_cam_debug_deinit,
+	.dump = mtk_cam_debug_dump,
+	.exp_reinit = mtk_cam_exp_reinit,
+	.exp_dump = mtk_cam_debug_exp_dump,
+};
+
+static struct mtk_cam_debug_fs debug_fs = {
+	.ops = &debug_ops,
+};
+
+struct mtk_cam_debug_fs *mtk_cam_get_debugfs(void)
+{
+	return &debug_fs;
+}
+
+#endif /* CONFIG_DEBUG_FS */
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam-debug.h b/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam-debug.h
new file mode 100644
index 0000000000000000000000000000000000000000..5d6405fbd75504d7c94f5b2b4a712684f0398bbe
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam-debug.h
@@ -0,0 +1,315 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2022 MediaTek Inc.
+ */
+
+#ifndef __MTK_CAM_DEBUG__
+#define __MTK_CAM_DEBUG__
+
+#include <linux/debugfs.h>
+struct mtk_cam_debug_fs;
+struct mtk_cam_device;
+struct mtk_cam_dump_param;
+struct mtk_raw_device;
+struct mtk_cam_request;
+struct mtk_cam_request_stream_data;
+struct mtk_cam_debug_fs;
+
+#define MTK_CAM_DEBUG_DUMP_MAX_BUF		(33 * 5)
+#define MTK_CAM_DEBUG_DUMP_DESC_SIZE		64
+#define MTK_CAM_DEBUG_DUMP_HEADER_MAX_SIZE	0x1000
+
+/* Force dump by user */
+#define MTK_CAM_REQ_DUMP_FORCE			BIT(0)
+/* Triggered when dequeue failed */
+#define MTK_CAM_REQ_DUMP_DEQUEUE_FAILED		BIT(1)
+/**
+ * Triggered when SOF may not come aganin. In this
+ * case, we will check if the request's state is
+ * still the same as the original one and start the
+ * dump if the state does not change.
+ */
+#define MTK_CAM_REQ_DUMP_CHK_DEQUEUE_FAILED	BIT(2)
+
+
+#define MTK_CAM_REQ_DBGWORK_S_INIT		0
+#define MTK_CAM_REQ_DBGWORK_S_PREPARED		1
+#define MTK_CAM_REQ_DBGWORK_S_FINISHED		2
+#define MTK_CAM_REQ_DBGWORK_S_CANCEL		3
+
+struct mtk_cam_dump_param {
+	/* Common Debug Information*/
+	char *desc;
+	__u32 request_fd;
+	__u32 stream_id;
+	__u64 timestamp;
+	__u32 sequence;
+
+	/* CQ dump */
+	void *cq_cpu_addr;
+	__u32 cq_size;
+#if defined ISP7_1
+	__u64	cq_iova;
+#elif defined ISP7_0
+	__u32	cq_iova;
+#endif
+	__u32 cq_desc_offset;
+	__u32 cq_desc_size;
+	__u32 sub_cq_desc_offset;
+	__u32 sub_cq_desc_size;
+
+	/* meta in */
+	void *meta_in_cpu_addr;
+	__u32 meta_in_dump_buf_size;
+#if defined ISP7_1
+	__u64	meta_in_iova;
+#elif defined ISP7_0
+	__u32	meta_in_iova;
+#endif
+	/* meta out 0 */
+	void *meta_out_0_cpu_addr;
+	__u32 meta_out_0_dump_buf_size;
+#if defined ISP7_1
+	__u64	meta_out_0_iova;
+#elif defined ISP7_0
+	__u32	meta_out_0_iova;
+#endif
+	/* meta out 1 */
+	void *meta_out_1_cpu_addr;
+	__u32 meta_out_1_dump_buf_size;
+#if defined ISP7_1
+	__u64	meta_out_1_iova;
+#elif defined ISP7_0
+	__u32	meta_out_1_iova;
+#endif
+	/* meta out 2 */
+	void *meta_out_2_cpu_addr;
+	__u32 meta_out_2_dump_buf_size;
+#if defined ISP7_1
+	__u64	meta_out_2_iova;
+#elif defined ISP7_0
+	__u32	meta_out_2_iova;
+#endif
+	/* ipi frame param */
+	struct mtkcam_ipi_frame_param *frame_params;
+	__u32 frame_param_size;
+
+	/* ipi config param */
+	struct mtkcam_ipi_config_param *config_params;
+	__u32 config_param_size;
+};
+
+struct mtk_cam_req_dump_work {
+	struct work_struct work;
+	atomic_t state;
+	unsigned int dump_flags;
+};
+
+struct mtk_cam_seninf_dump_work {
+	struct work_struct work;
+	struct v4l2_subdev *seninf;
+};
+
+struct mtk_cam_req_dbg_work {
+	struct work_struct work;
+	struct mtk_cam_request_stream_data *s_data;
+	atomic_t state;
+	unsigned int dump_flags;
+	int buffer_state;
+	char desc[MTK_CAM_DEBUG_DUMP_DESC_SIZE];
+	bool smi_dump;
+};
+
+struct mtk_cam_dump_header {
+	/* Common Debug Information*/
+	__u8	desc[MTK_CAM_DEBUG_DUMP_DESC_SIZE];
+	__u32	request_fd;
+	__u32   stream_id;
+	__u64	timestamp;
+	__u32	sequence;
+	__u32	header_size;
+	__u32	payload_offset;
+	__u32	payload_size;
+
+	/* meta file information */
+	__u32	meta_version_major;
+	__u32	meta_version_minor;
+
+	/* CQ dump */
+	__u32	cq_dump_buf_offset;
+	__u32	cq_size;
+#if defined ISP7_1
+	__u64	cq_iova;
+#elif defined ISP7_0
+	__u32	cq_iova;
+#endif
+	__u32	cq_desc_offset;
+	__u32	cq_desc_size;
+	__u32	sub_cq_desc_offset;
+	__u32	sub_cq_desc_size;
+
+	/* meta in */
+	__u32	meta_in_dump_buf_offset;
+	__u32	meta_in_dump_buf_size;
+#if defined ISP7_1
+	__u64	meta_in_iova;
+#elif defined ISP7_0
+	__u32	meta_in_iova;
+#endif
+
+	/* meta out 0 */
+	__u32	meta_out_0_dump_buf_offset;
+	__u32	meta_out_0_dump_buf_size;
+#if defined ISP7_1
+	__u64	meta_out_0_iova;
+#elif defined ISP7_0
+	__u32	meta_out_0_iova;
+#endif
+
+	/* meta out 1 */
+	__u32	meta_out_1_dump_buf_offset;
+	__u32	meta_out_1_dump_buf_size;
+#if defined ISP7_1
+	__u64	meta_out_1_iova;
+#elif defined ISP7_0
+	__u32	meta_out_1_iova;
+#endif
+
+	/* meta out 2 */
+	__u32	meta_out_2_dump_buf_offset;
+	__u32	meta_out_2_dump_buf_size;
+#if defined ISP7_1
+	__u64	meta_out_2_iova;
+#elif defined ISP7_0
+	__u32	meta_out_2_iova;
+#endif
+
+	/* status dump */
+	__u32	status_dump_offset;
+	__u32	status_dump_size;
+
+	/* ipi frame param */
+	__u32	frame_dump_offset;
+	__u32	frame_dump_size;
+
+	/* ipi config param */
+	__u32	config_dump_offset;
+	__u32	config_dump_size;
+	__u32	used_stream_num;
+};
+
+struct mtk_cam_dump_ctrl_block {
+	atomic_t state;
+	void *buf;
+};
+
+struct mtk_cam_dump_buf_ctrl {
+	int pipe_id;
+	struct mtk_cam_debug_fs *debug_fs;
+	struct mtk_cam_dump_ctrl_block blocks[MTK_CAM_DEBUG_DUMP_MAX_BUF];
+	struct dentry *dir_entry;
+	struct dentry *ctrl_entry;
+	struct dentry *data_entry;
+	struct mutex ctrl_lock;
+	int head;
+	int tail;
+	int num;
+	int count;
+	int cur_read;
+	atomic_t dump_state;
+	struct dentry *dump_entry;
+};
+
+struct mtk_cam_debug_ops {
+	int (*init)(struct mtk_cam_debug_fs *debug_fs,
+		    struct mtk_cam_device *cam, int content_size);
+	int (*dump)(struct mtk_cam_debug_fs *debug_fs,
+		    struct mtk_cam_dump_param *param);
+	int (*exp_dump)(struct mtk_cam_debug_fs *debug_fs,
+			struct mtk_cam_dump_param *param);
+	int (*exp_reinit)(struct mtk_cam_debug_fs *debug_fs);
+	int (*reinit)(struct mtk_cam_debug_fs *debug_fs,
+		      int stream_id);
+	void (*deinit)(struct mtk_cam_debug_fs *debug_fs);
+};
+
+struct mtk_cam_debug_fs {
+	struct mtk_cam_device *cam;
+	uint force_dump;
+	void *exp_dump_buf; /* kernel exception dump */
+	atomic_t exp_dump_state;
+	struct mutex exp_dump_buf_lock;
+	struct dentry *exp_dump_entry;
+	int buf_size;
+	struct dentry *dbg_entry;
+	struct mtk_cam_dump_buf_ctrl ctrl[MTKCAM_SUBDEV_MAX];
+	struct mtk_cam_debug_ops *ops;
+};
+
+#ifndef CONFIG_DEBUG_FS
+static inline struct mtk_cam_debug_fs *mtk_cam_get_debugfs(void)
+{
+	return NULL;
+}
+
+static inline int mtk_cam_req_dump(struct mtk_cam_request_stream_data *s_data,
+				   unsigned int dump_flag, char *desc, bool smi_dump)
+{
+	return 0;
+}
+
+static inline void
+mtk_cam_debug_detect_dequeue_failed(struct mtk_cam_request_stream_data *s_data,
+				    const unsigned int frame_no_update_limit,
+				    struct mtk_camsys_irq_info *irq_info,
+				    struct mtk_raw_device *raw_dev)
+{
+}
+
+static inline void mtk_cam_debug_wakeup(struct wait_queue_head *wq_head)
+{
+}
+
+static inline void
+mtk_cam_req_dump_work_init(struct mtk_cam_request_stream_data *s_data)
+{
+}
+
+static inline void
+mtk_cam_req_dbg_works_clean(struct mtk_cam_request_stream_data *s_data)
+{
+}
+
+static inline void
+mtk_cam_debug_seninf_dump(struct mtk_cam_request_stream_data *s_data)
+{
+}
+
+#else
+struct mtk_cam_debug_fs *mtk_cam_get_debugfs(void);
+
+int mtk_cam_req_dump(struct mtk_cam_request_stream_data *s_data,
+		     unsigned int dump_flag, char *desc, bool smi_dump);
+void
+mtk_cam_debug_detect_dequeue_failed(struct mtk_cam_request_stream_data *s_data,
+				    const unsigned int frame_no_update_limit,
+				    struct mtk_camsys_irq_info *irq_info,
+				    struct mtk_raw_device *raw_dev);
+void mtk_cam_debug_wakeup(struct wait_queue_head *wq_head);
+
+void mtk_cam_req_dump_work_init(struct mtk_cam_request_stream_data *s_data);
+
+void mtk_cam_req_dbg_works_clean(struct mtk_cam_request_stream_data *s_data);
+
+void
+mtk_cam_debug_seninf_dump(struct mtk_cam_request_stream_data *s_data);
+
+#endif /* CONFIG_DEBUG_FS */
+
+static inline struct mtk_cam_req_dbg_work *
+to_mtk_cam_req_dbg_work(struct work_struct *__work)
+{
+	return container_of(__work, struct mtk_cam_req_dbg_work, work);
+}
+
+#endif /* __MTK_CAM_DEBUG__ */
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam-defs.h b/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam-defs.h
new file mode 100644
index 0000000000000000000000000000000000000000..25dfd782566799ba4fe7526d6fd908b0832b17ed
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam-defs.h
@@ -0,0 +1,240 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2022 MediaTek Inc.
+ */
+
+#ifndef __MTKCAM_DEFS_H
+#define __MTKCAM_DEFS_H
+
+/**
+ *  This definition is for the following version:
+ *
+ *  MTK_CAM_IPI_VERSION_MAJOR: 0
+ *  MTK_CAM_IPI_VERSION_MINOR: 1
+ */
+
+#include <linux/types.h>
+#include <common/mtk_cam-fmt.h>
+
+/*
+ * Note:
+ *	Following definitions are used in IPI-messaging.
+ *	Values are used in software control flow only and cannot be applied to
+ *	hw registers directly.
+ */
+
+/* camsys hw pipelines */
+enum mtkcam_pipe_subdev {
+	MTKCAM_SUBDEV_RAW_START = 0,
+	MTKCAM_SUBDEV_RAW_0	= MTKCAM_SUBDEV_RAW_START,
+	MTKCAM_SUBDEV_RAW_1,
+	MTKCAM_SUBDEV_RAW_2,
+	MTKCAM_SUBDEV_RAW_END,
+	MTKCAM_SUBDEV_CAMSV_START = MTKCAM_SUBDEV_RAW_END,
+	MTKCAM_SUBDEV_CAMSV_0 = MTKCAM_SUBDEV_CAMSV_START,
+	MTKCAM_SUBDEV_CAMSV_1,
+	MTKCAM_SUBDEV_CAMSV_2,
+	MTKCAM_SUBDEV_CAMSV_3,
+	MTKCAM_SUBDEV_CAMSV_4,
+	MTKCAM_SUBDEV_CAMSV_5,
+#ifdef ISP7_1
+	MTKCAM_SUBDEV_CAMSV_6,
+	MTKCAM_SUBDEV_CAMSV_7,
+	MTKCAM_SUBDEV_CAMSV_8,
+	MTKCAM_SUBDEV_CAMSV_9,
+	MTKCAM_SUBDEV_CAMSV_10,
+	MTKCAM_SUBDEV_CAMSV_11,
+	MTKCAM_SUBDEV_CAMSV_12,
+	MTKCAM_SUBDEV_CAMSV_13,
+	MTKCAM_SUBDEV_CAMSV_14,
+	MTKCAM_SUBDEV_CAMSV_15,
+#endif
+	MTKCAM_SUBDEV_CAMSV_END,
+	MTKCAM_SUBDEV_MAX = MTKCAM_SUBDEV_CAMSV_END,
+};
+
+#define MTKCAM_MSTREAM_MAX 2
+#define MTKCAM_SUBDEV_RAW_MASK (1 << MTKCAM_SUBDEV_RAW_0| \
+				1 << MTKCAM_SUBDEV_RAW_1| \
+				1 << MTKCAM_SUBDEV_RAW_2)
+
+static inline int is_raw_subdev(unsigned char subdev_id)
+{
+	return (subdev_id == MTKCAM_SUBDEV_RAW_0 ||
+		subdev_id == MTKCAM_SUBDEV_RAW_1 ||
+		subdev_id == MTKCAM_SUBDEV_RAW_2);
+}
+
+static inline int is_camsv_subdev(unsigned char subdev_id)
+{
+	return (subdev_id >= MTKCAM_SUBDEV_CAMSV_START &&
+		subdev_id < MTKCAM_SUBDEV_CAMSV_END);
+}
+
+
+enum mtkcam_pipe_dev {
+	MTKCAM_PIPE_RAW_A	= 0,
+	MTKCAM_PIPE_RAW_B,
+	MTKCAM_PIPE_RAW_C,
+	MTKCAM_PIPE_CAMSV_0,
+	MTKCAM_PIPE_CAMSV_1,
+	MTKCAM_PIPE_CAMSV_2,
+	MTKCAM_PIPE_CAMSV_3,
+	MTKCAM_PIPE_CAMSV_4,
+	MTKCAM_PIPE_CAMSV_5,
+#ifdef ISP7_1
+	MTKCAM_PIPE_CAMSV_6,
+	MTKCAM_PIPE_CAMSV_7,
+	MTKCAM_PIPE_CAMSV_8,
+	MTKCAM_PIPE_CAMSV_9,
+	MTKCAM_PIPE_CAMSV_10,
+	MTKCAM_PIPE_CAMSV_11,
+	MTKCAM_PIPE_CAMSV_12,
+	MTKCAM_PIPE_CAMSV_13,
+	MTKCAM_PIPE_CAMSV_14,
+	MTKCAM_PIPE_CAMSV_15,
+#endif
+	MTKCAM_PIPE_MAX
+};
+
+enum mtkcam_ipi_raw_video_id {
+	MTKCAM_IPI_RAW_ID_UNKNOWN	= 0,
+	MTKCAM_IPI_RAW_RAWI_2,		/* RAWI_R2 */
+	MTKCAM_IPI_RAW_RAWI_3,		/* RAWI_R3 */
+	MTKCAM_IPI_RAW_RAWI_5,		/* RAWI_R5 */
+	MTKCAM_IPI_RAW_RAWI_6,		/* RAWI_R6 */
+	MTKCAM_IPI_RAW_IMGO,		/* IMGO_R1 */
+	MTKCAM_IPI_RAW_UFEO,		/* UFEO_R1 */
+	MTKCAM_IPI_RAW_RRZO,		/* RRZO_R1 */
+	MTKCAM_IPI_RAW_UFGO,		/* UFGO_R1 */
+	MTKCAM_IPI_RAW_YUVO_1,		/* YUVO_R1 */
+	MTKCAM_IPI_RAW_YUVO_2,		/* YUVO_R2 */
+	MTKCAM_IPI_RAW_YUVO_3,		/* YUVO_R3 */
+	MTKCAM_IPI_RAW_YUVO_4,		/* YUVO_R4 */
+	MTKCAM_IPI_RAW_YUVO_5,		/* YUVO_R5 */
+	MTKCAM_IPI_RAW_RZH1N2TO_2,	/* RZH1N2TO_R2 */
+	MTKCAM_IPI_RAW_DRZS4NO_1,	/* DRZS4NO_R1 */
+	MTKCAM_IPI_RAW_DRZS4NO_2,	/* DRZS4NO_R2 */
+	MTKCAM_IPI_RAW_DRZS4NO_3,	/* DRZS4NO_R3 */
+	MTKCAM_IPI_RAW_RZH1N2TO_3,	/* RZH1N2TO_R3 */
+	MTKCAM_IPI_RAW_RZH1N2TO_1,	/* RZH1N2TO_R1 */
+	MTKCAM_IPI_RAW_META_STATS_CFG,	/* All settings */
+	MTKCAM_IPI_RAW_META_STATS_0,	/* statistics */
+
+	/*
+	 * MTKCAM_IPI_RAW_META_STATS_1 is for AFO only, the buffer can be
+	 * dequeued once we got the  dma done.
+	 */
+	MTKCAM_IPI_RAW_META_STATS_1,
+
+	/* statistics may be pass to DIP */
+	MTKCAM_IPI_RAW_META_STATS_2,
+	MTKCAM_IPI_RAW_ID_MAX,
+};
+
+enum mtkcam_ipi_camsv_video_id {
+	MTKCAM_IPI_CAMSV_ID_UNKNOWN	= 0,
+	MTKCAM_IPI_CAMSV_MAIN_OUT = MTKCAM_IPI_RAW_ID_MAX,	/* imgo */
+
+	MTKCAM_IPI_CAMSV_ID_MAX,
+};
+
+/* Supported bayer pixel order: */
+enum mtkcam_ipi_bayer_pxl_id {
+	MTKCAM_IPI_BAYER_PXL_ID_B		= 0,
+	MTKCAM_IPI_BAYER_PXL_ID_GB		= 1,
+	MTKCAM_IPI_BAYER_PXL_ID_GR		= 2,
+	MTKCAM_IPI_BAYER_PXL_ID_R		= 3,
+	MTKCAM_IPI_BAYER_PXL_ID_UNKNOWN		= 4,
+};
+
+/* special input patterns */
+enum mtkcam_ipi_sensor_pattern {
+	MTKCAM_IPI_SENSOR_PATTERN_NORMAL		= 0,
+	MTKCAM_IPI_SENSOR_PATTERN_DUAL_PIX		= 1,
+	MTKCAM_IPI_SENSOR_PATTERN_QUADCODE		= 2, /* FIXME: ?? */
+	MTKCAM_IPI_SENSOR_PATTERN_4CELL			= 3,
+	MTKCAM_IPI_SENSOR_PATTERN_MONO			= 4,
+	MTKCAM_IPI_SENSOR_PATTERN_IVHDR			= 5,
+	MTKCAM_IPI_SENSOR_PATTERN_ZVHDR			= 6,
+	MTKCAM_IPI_SENSOR_PATTERN_4CELL_IVHDR		= 7,
+	MTKCAM_IPI_SENSOR_PATTERN_4CELL_ZVHDR		= 8,
+	MTKCAM_IPI_SENSOR_PATTERN_DUAL_PIX_IVHDR	= 9,
+	MTKCAM_IPI_SENSOR_PATTERN_DUAL_PIX_ZVHDR	= 10,
+	/* FIXME: can be ignored? */
+	MTKCAM_IPI_SENSOR_PATTERN_YUV			= 11,
+	 /* FIXME: what's 'normal' pd? */
+	MTKCAM_IPI_SENSOR_PATTERN_NORMAL_PD		= 12,
+};
+
+enum mtkcam_ipi_raw_path_control {
+	MTKCAM_IPI_IMGO_UNPROCESSED		= 0,
+	MTKCAM_IPI_IMGO_AFTER_BPC,
+	MTKCAM_IPI_IMGO_AFTER_FRZ,
+	MTKCAM_IPI_IMGO_AFTER_FUS,
+	MTKCAM_IPI_IMGO_AFTER_DGN,
+	MTKCAM_IPI_IMGO_AFTER_LSC,
+	MTKCAM_IPI_IMGO_AFTER_HLR,
+	MTKCAM_IPI_IMGO_AFTER_LTM,
+	MTKCAM_IPI_IMGO_FULLY_PROCESSED = MTKCAM_IPI_IMGO_AFTER_LTM,
+};
+
+/* For LBIT_MODE G2 */
+enum mtkcam_ipi_sw_feature_control {
+	MTKCAM_IPI_SW_FEATURE_NORMAL		= 0,
+	/* TG direct link */
+	MTKCAM_IPI_SW_FEATURE_VHDR_STAGGER	= 1,
+	/* Stagger: multi or single exposure */
+	MTKCAM_IPI_SW_FEATURE_VHDR_MSTREAM	= 2,
+	/* Mstream: multi or single exposure */
+};
+
+enum mtkcam_ipi_hw_path_control {
+	MTKCAM_IPI_HW_PATH_ON_THE_FLY			= 0,
+	/* TG direct link */
+	MTKCAM_IPI_HW_PATH_ON_THE_FLY_M2M		= 1,
+	/* On device tuning */
+	MTKCAM_IPI_HW_PATH_ON_THE_FLY_MSTREAM_SE_NE	= 2,
+	/* Mstream */
+	MTKCAM_IPI_HW_PATH_ON_THE_FLY_MSTREAM_NE_SE	= 3,
+	/* Mstream */
+	MTKCAM_IPI_HW_PATH_ON_THE_FLY_DCIF_STAGGER	= 4,
+	/* on the fly stagger */
+	MTKCAM_IPI_HW_PATH_OFFLINE_STAGGER		= 5,
+	/* offline stagger */
+	MTKCAM_IPI_HW_PATH_OFFLINE_SRT_DCIF_STAGGER	= 6,
+	/* sw real time direct couple */
+	MTKCAM_IPI_HW_PATH_OFFLINE_M2M			= 7,
+	/* SW trigger rawi */
+	MTKCAM_IPI_HW_PATH_ON_THE_FLY_RAWB		= 8,
+	/* TG direct link, for RAW_BC or single B */
+};
+
+enum mtkcam_ipi_meta_valid_num_control {
+	MTKCAM_IPI_FBCX_AAO = 0,
+	MTKCAM_IPI_FBCX_AAHO,
+	MTKCAM_IPI_FBCX_AFO,
+	MTKCAM_IPI_FBCX_TSFSO_1,
+	MTKCAM_IPI_FBCX_TSFSO_2,
+	MTKCAM_IPI_FBCX_LTMSO,
+	MTKCAM_IPI_FBCX_FLKO,
+	MTKCAM_IPI_FBCX_ACTSO,
+	MTKCAM_IPI_FBCX_PDO,
+	MTKCAM_IPI_FBCX_TNCSYO,
+	MTKCAM_IPI_FBCX_RZH1N2TO_R1,
+	MTKCAM_IPI_FBCX_RZH1N2TO_R2,
+	MTKCAM_IPI_FBCX_RZH1N2TO_R3,
+	MTKCAM_IPI_FBCX_LAST,
+};
+
+enum {
+	BIN_AUTO	= 0,
+	BIN_OFF		= BIN_AUTO,
+	BIN_ON		= (1 << 0),
+	CBN_2X2_ON	= (1 << 4),
+	CBN_3X3_ON	= (1 << 5),
+	CBN_4X4_ON	= (1 << 6),
+	QBND_ON		= (1 << 8)
+};
+
+#endif /* __MTKCAM_DEFS_H */
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam-dmadbg.h b/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam-dmadbg.h
new file mode 100644
index 0000000000000000000000000000000000000000..cd2f5334903875ac6b693d05522d3ee6bbec3d43
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam-dmadbg.h
@@ -0,0 +1,720 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2022 MediaTek Inc.
+ */
+
+#ifndef __MTK_CAM_RAW_DMADBG_H
+#define __MTK_CAM_RAW_DMADBG_H
+
+#include "mtk_cam-raw_debug.h"
+
+static __maybe_unused struct dma_debug_item dbg_RAWI_R2[] = {
+	{0x00000000, "rawi_r2 32(hex) 0000"},
+	{0x00000100, "rawi_r2 state_checksum"},
+	{0x00000200, "rawi_r2 line_pix_cnt_tmp"},
+	{0x00000300, "rawi_r2 line_pix_cnt"},
+	{0x00000500, "rawi_r2 smi_debug_data (case 0)"},
+	{0x00010600, "rawi_r2 aff(fifo)_debug_data (case 1)"},
+	{0x00030600, "rawi_r2 aff(fifo)_debug_data (case 3)"},
+	{0x01000040, "rawi_r2_smi_port / plane-0 / data-crc"},
+	{0x01000041, "rawi_r2_smi_port / plane-0 / addr-crc"},
+	{0x00000080, "rawi_r2_smi_port / smi_latency_mon output"},
+	{0x000000A0, "rawi_r2_smi_port / plane-0 / { len-cnt, dle-cnt }"},
+	{0x000000C0, "rawi_r2_smi_port / plane-0 / maddr_max record"},
+	{0x000000C1, "rawi_r2_smi_port / plane-0 / maddr_min record"},
+};
+
+static __maybe_unused struct dma_debug_item dbg_RAWI_R2_UFD[] = {
+	{0x00000001, "rawi_r2 ufd 32(hex) 0000"},
+	{0x00000101, "rawi_r2 ufd state_checksum"},
+	{0x00000201, "rawi_r2 ufd line_pix_cnt_tmp"},
+	{0x00000301, "rawi_r2 ufd line_pix_cnt"},
+};
+
+static __maybe_unused struct dma_debug_item dbg_RAWI_R3[] = {
+	{0x00000003, "rawi_r3 32(hex) 0000"},
+	{0x00000103, "rawi_r3 state_checksum"},
+	{0x00000203, "rawi_r3 line_pix_cnt_tmp"},
+	{0x00000303, "rawi_r3 line_pix_cnt"},
+	{0x00000503, "rawi_r3 smi_debug_data (case 0)"},
+	{0x00010603, "rawi_r3 aff(fifo)_debug_data (case 1)"},
+	{0x00030603, "rawi_r3 aff(fifo)_debug_data (case 3)"},
+	{0x01000043, "rawi_r3_smi_port / plane-0 / data-crc"},
+	{0x01000044, "rawi_r3_smi_port / plane-0 / addr-crc"},
+	{0x00000082, "rawi_r3_smi_port / smi_latency_mon output"},
+	{0x000000A2, "rawi_r3_smi_port / plane-0 / { len-cnt, dle-cnt }"},
+	{0x000002C0, "rawi_r3_smi_port / plane-0 / maddr_max record"},
+	{0x000002C1, "rawi_r3_smi_port / plane-0 / maddr_min record"},
+};
+
+static __maybe_unused struct dma_debug_item dbg_IMGO_R1[] = {
+	{0x00000019, "imgo_r1 32(hex) 0000"},
+	{0x00000119, "imgo_r1 state_checksum"},
+	{0x00000219, "imgo_r1 line_pix_cnt_tmp"},
+	{0x00000319, "imgo_r1 line_pix_cnt"},
+	{0x00000819, "imgo_r1 smi_debug_data (case 0)"},
+	{0x00010719, "imgo_r1 aff(fifo)_debug_data (case 1)"},
+	{0x00030719, "imgo_r1 aff(fifo)_debug_data (case 3)"},
+
+	{0x01000059, "imgo_r1_smi_port / plane-0 (i.e. imgo_r1) / data-crc"},
+
+	{0x0000008B, "imgo_r1_smi_port / smi_latency_mon output"},
+
+	{0x000000AB, "imgo_r1_smi_port / plane-0 / {len-cnt, dle-cnt}"},
+	{0x000000AC, "imgo_r1_smi_port / plane-0 / {load_com-cnt, bvalid-cnt}"},
+
+	{0x000013C0, "imgo_r1_smi_port / plane-0 / maddr_max record"},
+	{0x000013C1, "imgo_r1_smi_port / plane-0 / maddr_min record"},
+};
+
+static __maybe_unused struct dma_debug_item dbg_AAHO_R1[] = {
+	{0x0000001B, "32(hex) 0000"},
+	{0x0000011B, "state_checksum"},
+	{0x0000021B, "line_pix_cnt_tmp"},
+	{0x0000031B, "line_pix_cnt"},
+	{0x0000081B, "smi_debug_data (case 0)"},
+	{0x0001071B, "aff(fifo)_debug_data (case 1)"},
+	{0x0003071B, "aff(fifo)_debug_data (case 3)"},
+
+	{0x0100005B, "fho_r1_smi_port / plane-1 (i.e. aaho_r1) / data-crc"},
+
+	{0x000000AD, "fho_r1_smi_port / plane-0 (i.e. fho_r1) / len-cnt, dle-cnt"},
+	{0x000000AE, "fho_r1_smi_port / plane-0 (i.e. fho_r1) / load_com-cnt, bvalid-cnt"},
+	{0x000000AF, "fho_r1_smi_port / plane-1 (i.e. aaho_r1) / len-cnt, dle-cnt"},
+	{0x000000B0, "fho_r1_smi_port / plane-1 (i.e. aaho_r1) / load_com-cnt, bvalid-cnt"},
+	{0x000000B1, "fho_r1_smi_port / plane-2 (i.e. pdo_r1) / len-cnt, dle-cnt"},
+	{0x000000B2, "fho_r1_smi_port / plane-2 (i.e. pdo_r1) / load_com-cnt, bvalid-cnt"},
+};
+
+static __maybe_unused struct dma_debug_item dbg_PDO_R1[] = {
+	{0x0000001C, "32(hex) 0000"},
+	{0x0000011C, "state_checksum"},
+	{0x0000021C, "line_pix_cnt_tmp"},
+	{0x0000031C, "line_pix_cnt"},
+	{0x0000081C, "smi_debug_data (case 0)"},
+	{0x0001071C, "aff(fifo)_debug_data (case 1)"},
+	{0x0003071C, "aff(fifo)_debug_data (case 3)"},
+
+	{0x000000AD, "fho_r1_smi_port / plane-0 (i.e. fho_r1) / len-cnt, dle-cnt"},
+	{0x000000AE, "fho_r1_smi_port / plane-0 (i.e. fho_r1) / load_com-cnt, bvalid-cnt"},
+	{0x000000AF, "fho_r1_smi_port / plane-1 (i.e. aaho_r1) / len-cnt, dle-cnt"},
+	{0x000000B0, "fho_r1_smi_port / plane-1 (i.e. aaho_r1) / load_com-cnt, bvalid-cnt"},
+	{0x000000B1, "fho_r1_smi_port / plane-2 (i.e. pdo_r1) / len-cnt, dle-cnt"},
+	{0x000000B2, "fho_r1_smi_port / plane-2 (i.e. pdo_r1) / load_com-cnt, bvalid-cnt"},
+};
+
+static __maybe_unused struct dma_debug_item dbg_PDI_R1[] = {
+	{0x00000014, "pdi_r1 32(hex) 0000"},
+	{0x00000114, "pdi_r1 state_checksum"},
+	{0x00000214, "pdi_r1 line_pix_cnt_tmp"},
+	{0x00000314, "pdi_r1 line_pix_cnt"},
+	{0x00000414, "pdi_r1 important_status"},
+	{0x00000514, "pdi_r1 cmd_data_cnt"},
+	{0x00000614, "pdi_r1 tilex_byte_cnt"},
+	{0x00000714, "pdi_r1 tiley_cnt"},
+	{0x00000814, "pdi_r1 burst_line_cnt"},
+};
+
+// M4U_PORT CAM3_YUVO_R1 : yuvo_r1 + yuvbo_r1
+static __maybe_unused struct dma_debug_item dbg_YUVO_R1[] = {
+	{0x00000000, "yuvo_r1 32(hex) 0000"},
+	{0x00000100, "yuvo_r1 state_checksum"},
+	{0x00000200, "yuvo_r1 line_pix_cnt_tmp"},
+	{0x00000300, "yuvo_r1 line_pix_cnt"},
+	{0x00000800, "yuvo_r1 smi_debug_data (case 0)"},
+	{0x00010700, "yuvo_r1 aff(fifo)_debug_data (case 1)"},
+	{0x00030700, "yuvo_r1 aff(fifo)_debug_data (case 3)"},
+
+	{0x00000001, "yuvbo_r1 32(hex) 0000"},
+	{0x00000101, "yuvbo_r1 state_checksum"},
+	{0x00000201, "yuvbo_r1 line_pix_cnt_tmp"},
+	{0x00000301, "yuvbo_r1 line_pix_cnt"},
+	{0x00000801, "yuvbo_r1 smi_debug_data (case 0)"},
+	{0x00010701, "yuvbo_r1 aff(fifo)_debug_data (case 1)"},
+	{0x00030701, "yuvbo_r1 aff(fifo)_debug_data (case 3)"},
+
+	{0x01000040, "yuvo_r1_smi_port / plane-0 (i.e. yuvo_r1) / data-crc"},
+	{0x01000041, "yuvo_r1_smi_port / plane-1 (i.e. yuvbo_r1) / data-crc"},
+
+	{0x00000080, "yuvo_r1_smi_port / smi_latency_mon output"},
+
+	{0x000000AD, "yuvo_r1_smi_port / plane-0 (i.e. yuvo_r1) / { len-cnt, dle-cnt }"},
+	{0x000000AE, "yuvo_r1_smi_port / plane-0 (i.e. yuvo_r1) / { load_com-cnt, bvalid-cnt }"},
+	{0x000000AF, "yuvo_r1_smi_port / plane-1 (i.e. yuvbo_r1) / { len-cnt, dle-cnt }"},
+	{0x000000B0, "yuvo_r1_smi_port / plane-1 (i.e. yuvbo_r1) / { load_com-cnt, bvalid-cnt }"},
+
+	{0x000000C0,
+	 "yuvo_r1_smi_port / plane-0 - yuvo_r1_smi_port / plane-0 (i.e. yuvo_r1) / maddr_max record"},
+	{0x000000C1,
+	 "yuvo_r1_smi_port / plane-0 - yuvo_r1_smi_port / plane-0 (i.e. yuvo_r1) / maddr_min record"},
+	{0x000001C0,
+	 "yuvo_r1_smi_port / plane-1 - yuvo_r1_smi_port / plane-0 (i.e. yuvbo_r1) / maddr_max record"},
+	{0x000001C1,
+	 "yuvo_r1_smi_port / plane-1 - yuvo_r1_smi_port / plane-0 (i.e. yuvbo_r1) / maddr_min record"},
+};
+
+// M4U_PORT CAM3_YUVO_R3 : yuvo_r3 + yuvbo_r3
+static __maybe_unused struct dma_debug_item dbg_YUVO_R3[] = {
+	{0x00000004, "yuvo_r3 32(hex) 0000"},
+	{0x00000104, "yuvo_r3 state_checksum"},
+	{0x00000204, "yuvo_r3 line_pix_cnt_tmp"},
+	{0x00000304, "yuvo_r3 line_pix_cnt"},
+	{0x00000804, "smi_debug_data (case 0)"},
+	{0x00010704, "aff(fifo)_debug_data (case 1)"},
+	{0x00030704, "aff(fifo)_debug_data (case 3)"},
+
+	{0x00000005, "yuvbo_r3 32(hex) 0000"},
+	{0x00000105, "yuvbo_r3 state_checksum"},
+	{0x00000205, "yuvbo_r3 line_pix_cnt_tmp"},
+	{0x00000305, "yuvbo_r3 line_pix_cnt"},
+	{0x00000805, "yuvbo_r3 smi_debug_data (case 0)"},
+	{0x00010705, "yuvbo_r3 aff(fifo)_debug_data (case 1)"},
+	{0x00030705, "yuvbo_r3 aff(fifo)_debug_data (case 3)"},
+
+	{0x01000042, "yuvo_r3_smi_port / plane-0 (i.e. yuvo_r3) / data-crc"},
+	{0x01000043, "yuvo_r3_smi_port / plane-1 (i.e. yuvbo_r1) / data-crc"},
+
+	{0x00000081, "yuvo_r3_smi_port / smi_latency_mon output"},
+
+	{0x000000B1, "yuvo_r3_smi_port / plane-0 (i.e. yuvo_r3) / { len-cnt, dle-cnt }"},
+	{0x000000B2, "yuvo_r3_smi_port / plane-0 (i.e. yuvo_r3) / { load_com-cnt, bvalid-cnt }"},
+	{0x000000B3, "yuvo_r3_smi_port / plane-1 (i.e. yuvbo_r3) / { len-cnt, dle-cnt }"},
+	{0x000000B4, "yuvo_r3_smi_port / plane-1 (i.e. yuvbo_r3) / { load_com-cnt, bvalid-cnt }"},
+
+	{0x000002C0,
+	 "yuvo_r3_smi_port / plane-0 - yuvo_r3_smi_port / plane-0 (i.e. yuvo_r3) / maddr_max record"},
+	{0x000002C1,
+	 "yuvo_r3_smi_port / plane-0 - yuvo_r3_smi_port / plane-0 (i.e. yuvo_r3) / maddr_min record"},
+	{0x000003C0,
+	 "yuvo_r3_smi_port / plane-1 - yuvo_r3_smi_port / plane-0 (i.e. yuvbo_r3) / maddr_max record"},
+	{0x000003C1,
+	 "yuvo_r3_smi_port / plane-1 - yuvo_r3_smi_port / plane-0 (i.e. yuvbo_r3) / maddr_min record"},
+};
+
+// M4U_PORT CAM3_YUVCO_R1 : yuvco_r1 + yuvdo_r1 + yuvco_r3 + yuvdo_r3
+static __maybe_unused struct dma_debug_item dbg_YUVCO_R1[] = {
+	{0x00000002, "yuvco_r1 32(hex) 0000"},
+	{0x00000102, "yuvco_r1 state_checksum"},
+	{0x00000202, "yuvco_r1 line_pix_cnt_tmp"},
+	{0x00000302, "yuvco_r1 line_pix_cnt"},
+	{0x00000802, "yuvco_r1 smi_debug_data (case 0)"},
+	{0x00010702, "yuvco_r1 aff(fifo)_debug_data (case 1)"},
+	{0x00030702, "yuvco_r1 aff(fifo)_debug_data (case 3)"},
+
+	{0x00000003, "yuvdo_r1 32(hex) 0000"},
+	{0x00000103, "yuvdo_r1 state_checksum"},
+	{0x00000203, "yuvdo_r1 line_pix_cnt_tmp"},
+	{0x00000303, "yuvdo_r1 line_pix_cnt"},
+	{0x00000803, "yuvdo_r1 smi_debug_data (case 0)"},
+	{0x00010703, "yuvdo_r1 aff(fifo)_debug_data (case 1)"},
+	{0x00030703, "yuvdo_r1 aff(fifo)_debug_data (case 3)"},
+
+	{0x01000044, "yuvco_r1_smi_port / plane-0 (i.e. yuvco_r1) / data-crc"},
+	{0x01000045, "yuvco_r1_smi_port / plane-1 (i.e. yuvco_r1) / data-crc"},
+	{0x01000046, "yuvco_r1_smi_port / plane-2 (i.e. yuvco_r1) / data-crc"},
+	{0x01000047, "yuvco_r1_smi_port / plane-3 (i.e. yuvco_r1) / data-crc"},
+
+	{0x00000082, "yuvco_r1_smi_port / smi_latency_mon output"},
+
+	{0x000004C0,
+	 "yuvco_r1_smi_port / plane-0 - yuvco_r1_smi_port / plane-0 (i.e. yuvco_r1) / maddr_max record"},
+	{0x000004C1,
+	 "yuvco_r1_smi_port / plane-0 - yuvco_r1_smi_port / plane-0 (i.e. yuvco_r1) / maddr_min record"},
+	{0x000005C0,
+	 "yuvco_r1_smi_port / plane-1 - yuvco_r1_smi_port / plane-0 (i.e. yuvdo_r1) / maddr_max record"},
+	{0x000005C1,
+	 "yuvco_r1_smi_port / plane-1 - yuvco_r1_smi_port / plane-0 (i.e. yuvdo_r1) / maddr_min record"},
+};
+
+static __maybe_unused struct dma_debug_item dbg_YUVCO_R3[] = {
+	{0x00000006, "yuvco_r3 32(hex) 0000"},
+	{0x00000106, "yuvco_r3 state_checksum"},
+	{0x00000206, "yuvco_r3 line_pix_cnt_tmp"},
+	{0x00000306, "yuvco_r3 line_pix_cnt"},
+	{0x00000806, "yuvco_r3 smi_debug_data (case 0)"},
+	{0x00010706, "yuvco_r3 aff(fifo)_debug_data (case 1)"},
+	{0x00030706, "yuvco_r3 aff(fifo)_debug_data (case 3)"},
+
+	{0x00000007, "yuvdo_r3 32(hex) 0000"},
+	{0x00000107, "yuvdo_r3 state_checksum"},
+	{0x00000207, "yuvdo_r3 line_pix_cnt_tmp"},
+	{0x00000307, "yuvdo_r3 line_pix_cnt"},
+	{0x00000807, "yuvdo_r3 smi_debug_data (case 0)"},
+	{0x00010707, "yuvdo_r3 aff(fifo)_debug_data (case 1)"},
+	{0x00030707, "yuvdo_r3 aff(fifo)_debug_data (case 3)"},
+
+	{0x01000044, "yuvco_r1_smi_port / plane-0 (i.e. yuvco_r1) / data-crc"},
+	{0x01000045, "yuvco_r1_smi_port / plane-1 (i.e. yuvco_r1) / data-crc"},
+	{0x01000046, "yuvco_r1_smi_port / plane-2 (i.e. yuvco_r1) / data-crc"},
+	{0x01000047, "yuvco_r1_smi_port / plane-3 (i.e. yuvco_r1) / data-crc"},
+
+	{0x00000082, "yuvco_r1_smi_port / smi_latency_mon output"},
+
+	{0x000006C0,
+	 "yuvco_r1_smi_port / plane-2 - yuvco_r1_smi_port / plane-0 (i.e. yuvco_r3) / maddr_max record"},
+	{0x000006C1,
+	 "yuvco_r1_smi_port / plane-2 - yuvco_r1_smi_port / plane-0 (i.e. yuvco_r3) / maddr_max record"},
+	{0x000007C0,
+	 "yuvco_r1_smi_port / plane-3 - yuvco_r1_smi_port / plane-0 (i.e. yuvdo_r3) / maddr_max record"},
+	{0x000007C1,
+	 "yuvco_r1_smi_port / plane-3 - yuvco_r1_smi_port / plane-0 (i.e. yuvdo_r3) / maddr_min record"},
+};
+
+// M4U_PORT CAM3_YUVO_R2 : yuvo_r2 + yuvbo_r2 + yuvo_r4 + yuvbo_r4 + yuvo_r5 + yuvbo_r5
+static __maybe_unused struct dma_debug_item dbg_YUVO_R2[] = {
+	{0x00000008, "yuvo_r2 32(hex) 0000"},
+	{0x00000108, "yuvo_r2 state_checksum"},
+	{0x00000208, "yuvo_r2 line_pix_cnt_tmp"},
+	{0x00000308, "yuvo_r2 line_pix_cnt"},
+	{0x00000408, "yuvo_r2 important_status"},
+	{0x00000508, "yuvo_r2 cmd_data_cnt"},
+	{0x00000608, "yuvo_r2 cmd_cnt_for_bvalid_phase"},
+	{0x00000708, "yuvo_r2 input_h_cnt"},
+	{0x00000808, "yuvo_r2 input_v_cnt"},
+	{0x00000908, "yuvo_r2 xfer_y_cnt"},
+
+	{0x00000009, "yuvbo_r2 32(hex) 0000"},
+	{0x00000109, "yuvbo_r2 state_checksum"},
+	{0x00000209, "yuvbo_r2 line_pix_cnt_tmp"},
+	{0x00000309, "yuvbo_r2 line_pix_cnt"},
+	{0x00000409, "yuvbo_r2 important_status"},
+	{0x00000509, "yuvbo_r2 cmd_data_cnt"},
+	{0x00000609, "yuvbo_r2 cmd_cnt_for_bvalid_phase"},
+	{0x00000709, "yuvbo_r2 input_h_cnt"},
+	{0x00000809, "yuvbo_r2 input_v_cnt"},
+	{0x00000909, "yuvbo_r2 xfer_y_cnt"},
+
+	{0x01000048, "yuvo_r2_smi_port / plane-0 (i.e. yuvo_r2) / data-crc"},
+	{0x01000049, "yuvo_r2_smi_port / plane-1 (i.e. yuvbo_r2) / data-crc"},
+
+	{0x00000083, "yuvo_r2_smi_port / smi_latency_mon output"},
+
+	{0x000008C0,
+	 "yuvo_r2_smi_port / plane-0 - yuvo_r2_smi_port / plane-1 (i.e. cqi_r3) / maddr_max record"},
+	{0x000008C1,
+	 "yuvo_r2_smi_port / plane-0 - yuvo_r2_smi_port / plane-1 (i.e. cqi_r3) / maddr_min record"},
+	{0x000009C0,
+	 "yuvo_r2_smi_port / plane-1 - yuvo_r2_smi_port / plane-1 (i.e. cqi_r4) / maddr_max record"},
+	{0x000009C1,
+	 "yuvo_r2_smi_port / plane-1 - yuvo_r2_smi_port / plane-1 (i.e. cqi_r4) / maddr_min record"},
+};
+
+static __maybe_unused struct dma_debug_item dbg_YUVO_R4[] = {
+	{0x0000000A, "yuvo_r4 32(hex) 0000"},
+	{0x0000010A, "yuvo_r4 state_checksum"},
+	{0x0000020A, "yuvo_r4 line_pix_cnt_tmp"},
+	{0x0000030A, "yuvo_r4 line_pix_cnt"},
+	{0x0000040A, "yuvo_r4 important_status"},
+	{0x0000050A, "yuvo_r4 cmd_data_cnt"},
+	{0x0000060A, "yuvo_r4 cmd_cnt_for_bvalid_phase"},
+	{0x0000070A, "yuvo_r4 input_h_cnt"},
+	{0x0000080A, "yuvo_r4 input_v_cnt"},
+	{0x0000090A, "yuvo_r4 xfer_y_cnt"},
+
+	{0x0000000B, "yuvbo_r4 32(hex) 0000"},
+	{0x0000010B, "yuvbo_r4 state_checksum"},
+	{0x0000020B, "yuvbo_r4 line_pix_cnt_tmp"},
+	{0x0000030B, "yuvbo_r4 line_pix_cnt"},
+	{0x0000040B, "yuvbo_r4 important_status"},
+	{0x0000050B, "yuvbo_r4 cmd_data_cnt"},
+	{0x0000060B, "yuvbo_r4 cmd_cnt_for_bvalid_phase"},
+	{0x0000070B, "yuvbo_r4 input_h_cnt"},
+	{0x0000080B, "yuvbo_r4 input_v_cnt"},
+	{0x0000090B, "yuvbo_r4 xfer_y_cnt"},
+
+	{0x0100004A, "yuvo_r2_smi_port / plane-2 (i.e. yuvo_r4) / data-crc"},
+	{0x0100004B, "yuvo_r2_smi_port / plane-3 (i.e. yuvbo_r4) / data-crc"},
+
+	{0x00000083, "yuvo_r2_smi_port / smi_latency_mon output"},
+
+	{0x00000AC0,
+	 "yuvo_r2_smi_port / plane-2 - yuvo_r2_smi_port / plane-0 (i.e. lsci_r1) / maddr_max record"},
+	{0x00000AC1,
+	 "yuvo_r2_smi_port / plane-2 - yuvo_r2_smi_port / plane-0 (i.e. lsci_r1) / maddr_min record"},
+	{0x00000BC0,
+	 "yuvo_r2_smi_port / plane-3 - yuvo_r2_smi_port / plane-0 (i.e. bpci_r1) / maddr_max record"},
+	{0x00000BC1,
+	 "yuvo_r2_smi_port / plane-3 - yuvo_r2_smi_port / plane-0 (i.e. bpci_r1) / maddr_min record"},
+};
+
+static __maybe_unused struct dma_debug_item dbg_YUVO_R5[] = {
+	{0x0000000C, "yuvo_r5 32(hex) 0000"},
+	{0x0000010C, "yuvo_r5 state_checksum"},
+	{0x0000020C, "yuvo_r5 line_pix_cnt_tmp"},
+	{0x0000030C, "yuvo_r5 line_pix_cnt"},
+	{0x0000040C, "yuvo_r5 important_status"},
+	{0x0000050C, "yuvo_r5 cmd_data_cnt"},
+	{0x0000060C, "yuvo_r5 cmd_cnt_for_bvalid_phase"},
+	{0x0000070C, "yuvo_r5 input_h_cnt"},
+	{0x0000080C, "yuvo_r5 input_v_cnt"},
+	{0x0000090C, "yuvo_r5 xfer_y_cnt"},
+
+	{0x0000000D, "yuvbo_r5 32(hex) 0000"},
+	{0x0000010D, "yuvbo_r5 state_checksum"},
+	{0x0000020D, "yuvbo_r5 line_pix_cnt_tmp"},
+	{0x0000030D, "yuvbo_r5 line_pix_cnt"},
+	{0x0000040D, "yuvbo_r5 important_status"},
+	{0x0000050D, "yuvbo_r5 cmd_data_cnt"},
+	{0x0000060D, "yuvbo_r5 cmd_cnt_for_bvalid_phase"},
+	{0x0000070D, "yuvbo_r5 input_h_cnt"},
+	{0x0000080D, "yuvbo_r5 input_v_cnt"},
+	{0x0000090D, "yuvbo_r5 xfer_y_cnt"},
+
+	{0x0100004C, "yuvo_r2_smi_port / plane-4 (i.e. yuvo_r5) / data-crc"},
+	{0x0100004D, "yuvo_r2_smi_port / plane-5 (i.e. yuvbo_r5) / data-crc"},
+
+	{0x00000083, "yuvo_r2_smi_port / smi_latency_mon output"},
+
+	{0x00000CC0,
+	 "yuvo_r2_smi_port / plane-4 - yuvo_r2_smi_port / plane-1 (i.e. bpci_r2) / maddr_max record"},
+	{0x00000CC1,
+	 "yuvo_r2_smi_port / plane-4 - yuvo_r2_smi_port / plane-1 (i.e. bpci_r2) / maddr_min record"},
+	{0x00000DC0,
+	 "yuvo_r2_smi_port / plane-5 - yuvo_r2_smi_port / plane-2 (i.e. bpci_r3) / maddr_max record"},
+	{0x00000DC1,
+	 "yuvo_r2_smi_port / plane-5 - yuvo_r2_smi_port / plane-2 (i.e. bpci_r3) / maddr_min record"},
+};
+
+// M4U_PORT CAM3_RZH1N2TO_R1 : rzh1n2to_r1 + rzh1n2tbo_r1 + rzh1n2to_r2 + rzh1n2to_r3 + rzh1n2tbo_r3
+static __maybe_unused struct dma_debug_item dbg_RZH1N2TO_R1[] = {
+	{0x0000000E, "rzh1n2to_r1 32(hex) 0000"},
+	{0x0000010E, "rzh1n2to_r1 state_checksum"},
+	{0x0000020E, "rzh1n2to_r1 line_pix_cnt_tmp"},
+	{0x0000030E, "rzh1n2to_r1 line_pix_cnt"},
+	{0x0000040E, "rzh1n2to_r1 important_status"},
+	{0x0000050E, "rzh1n2to_r1 cmd_data_cnt"},
+	{0x0000060E, "rzh1n2to_r1 cmd_cnt_for_bvalid_phase"},
+	{0x0000070E, "rzh1n2to_r1 input_h_cnt"},
+	{0x0000080E, "rzh1n2to_r1 input_v_cnt"},
+	{0x0000090E, "rzh1n2to_r1 xfer_y_cnt"},
+
+	{0x0000000F, "rzh1n2tbo_r1 32(hex) 0000"},
+	{0x0000010F, "rzh1n2tbo_r1 state_checksum"},
+	{0x0000020F, "rzh1n2tbo_r1 line_pix_cnt_tmp"},
+	{0x0000030F, "rzh1n2tbo_r1 line_pix_cnt"},
+	{0x0000040F, "rzh1n2tbo_r1 important_status"},
+	{0x0000050F, "rzh1n2tbo_r1 cmd_data_cnt"},
+	{0x0000060F, "rzh1n2tbo_r1 cmd_cnt_for_bvalid_phase"},
+	{0x0000070F, "rzh1n2tbo_r1 input_h_cnt"},
+	{0x0000080F, "rzh1n2tbo_r1 input_v_cnt"},
+	{0x0000090F, "rzh1n2tbo_r1 xfer_y_cnt"},
+
+	{0x00000084, "rzh1n2to_r1_smi_port / smi_latency_mon output"},
+
+	{0x00000EC0,
+	 "rzh1n2to_r1_smi_port / plane-0 - rzh1n2to_r1_smi_port / plane-3 (i.e. rzh1n2to_r1) / maddr_max record"},
+	{0x00000EC1,
+	 "rzh1n2to_r1_smi_port / plane-0 - rzh1n2to_r1_smi_port / plane-3 (i.e. rzh1n2to_r1) / maddr_min record"},
+	{0x00000FC0,
+	 "rzh1n2to_r1_smi_port / plane-1 - rzh1n2to_r1_smi_port / plane-4 (i.e. rzh1n2tbo_r1) / maddr_max record"},
+	{0x00000FC1,
+	 "rzh1n2to_r1_smi_port / plane-1 - rzh1n2to_r1_smi_port / plane-4 (i.e. rzh1n2tbo_r1) / maddr_min record"},
+};
+
+static __maybe_unused struct dma_debug_item dbg_RZH1N2TO_R2[] = {
+	{0x00000010, "rzh1n2to_r2 32(hex) 0000"},
+	{0x00000110, "rzh1n2to_r2 state_checksum"},
+	{0x00000210, "rzh1n2to_r2 line_pix_cnt_tmp"},
+	{0x00000310, "rzh1n2to_r2 line_pix_cnt"},
+	{0x00000410, "rzh1n2to_r2 important_status"},
+	{0x00000510, "rzh1n2to_r2 cmd_data_cnt"},
+	{0x00000610, "rzh1n2to_r2 cmd_cnt_for_bvalid_phase"},
+	{0x00000710, "rzh1n2to_r2 input_h_cnt"},
+	{0x00000810, "rzh1n2to_r2 input_v_cnt"},
+	{0x00000910, "rzh1n2to_r2 xfer_y_cnt"},
+
+	{0x01000050, "rzh1n2to_r1_smi_port / plane-2 (i.e. rzh1n2to_r2) / data-crc"},
+
+	{0x00000084, "rzh1n2to_r1_smi_port / smi_latency_mon output"},
+
+	{0x000010C0,
+	 "rzh1n2to_r1_smi_port / plane-2 - rzh1n2to_r1_smi_port / plane-0 (i.e. rzh1n2to_r2) / maddr_max record"},
+	{0x000010C1,
+	 "rzh1n2to_r1_smi_port / plane-2 - rzh1n2to_r1_smi_port / plane-0 (i.e. rzh1n2to_r2) / maddr_min record"},
+};
+
+static __maybe_unused struct dma_debug_item dbg_RZH1N2TO_R3[] = {
+	{0x00000011, "rzh1n2to_r3 32(hex) 0000"},
+	{0x00000111, "rzh1n2to_r3 state_checksum"},
+	{0x00000211, "rzh1n2to_r3 line_pix_cnt_tmp"},
+	{0x00000311, "rzh1n2to_r3 line_pix_cnt"},
+	{0x00000411, "rzh1n2to_r3 important_status"},
+	{0x00000511, "rzh1n2to_r3 cmd_data_cnt"},
+	{0x00000611, "rzh1n2to_r3 cmd_cnt_for_bvalid_phase"},
+	{0x00000711, "rzh1n2to_r3 input_h_cnt"},
+	{0x00000811, "rzh1n2to_r3 input_v_cnt"},
+	{0x00000911, "rzh1n2to_r3 xfer_y_cnt"},
+
+	{0x00000012, "rzh1n2tbo_r3 32(hex) 0000"},
+	{0x00000112, "rzh1n2tbo_r3 state_checksum"},
+	{0x00000212, "rzh1n2tbo_r3 line_pix_cnt_tmp"},
+	{0x00000312, "rzh1n2tbo_r3 line_pix_cnt"},
+	{0x00000412, "rzh1n2tbo_r3 important_status"},
+	{0x00000512, "rzh1n2tbo_r3 cmd_data_cnt"},
+	{0x00000612, "rzh1n2tbo_r3 cmd_cnt_for_bvalid_phase"},
+	{0x00000712, "rzh1n2tbo_r3 input_h_cnt"},
+	{0x00000812, "rzh1n2tbo_r3 input_v_cnt"},
+	{0x00000912, "rzh1n2tbo_r3 xfer_y_cnt"},
+
+	{0x01000051, "rzh1n2to_r1_smi_port / plane-3 (i.e. rzh1n2to_r3) / data-crc"},
+	{0x01000052, "rzh1n2to_r1_smi_port / plane-4 (i.e. rzh1n2tbo_r3) / data-crc"},
+
+	{0x00000084, "rzh1n2to_r1_smi_port / smi_latency_mon output"},
+
+	{0x000011C0,
+	 "rzh1n2to_r1_smi_port / plane-3 - rzh1n2to_r1_smi_port / plane-1 (i.e. rzh1n2to_r3) / maddr_max record"},
+	{0x000011C1,
+	 "rzh1n2to_r1_smi_port / plane-3 - rzh1n2to_r1_smi_port / plane-1 (i.e. rzh1n2to_r3) / maddr_min record"},
+	{0x000012C0,
+	 "rzh1n2to_r1_smi_port / plane-4 - rzh1n2to_r1_smi_port / plane-2 (i.e. rzh1n2tbo_r3) / maddr_max record"},
+	{0x000012C1,
+	 "rzh1n2to_r1_smi_port / plane-4 - rzh1n2to_r1_smi_port / plane-2 (i.e. rzh1n2tbo_r3) / maddr_min record"},
+};
+
+// M4U_PORT CAM3_DRZS4NO_R1 : drzs4no_r1 + drzs4no_r2 + drzs4no_r3 + lmvo_r1 + actso_r1
+static __maybe_unused struct dma_debug_item dbg_DRZS4NO_R1[] = {
+	{0x00000013, "drzs4no_r1 32(hex) 0000"},
+	{0x00000113, "drzs4no_r1 state_checksum"},
+	{0x00000213, "drzs4no_r1 line_pix_cnt_tmp"},
+	{0x00000313, "drzs4no_r1 line_pix_cnt"},
+	{0x00000413, "drzs4no_r1 important_status"},
+	{0x00000513, "drzs4no_r1 cmd_data_cnt"},
+	{0x00000613, "drzs4no_r1 cmd_cnt_for_bvalid_phase"},
+	{0x00000713, "drzs4no_r1 input_h_cnt"},
+	{0x00000813, "drzs4no_r1 input_v_cnt"},
+	{0x00000913, "drzs4no_r1 xfer_y_cnt"},
+
+	{0x01000053, "drzs4no_r1_smi_port / plane-0 (i.e. drzs4no_r1) / data-crc"},
+
+	{0x00000085, "drzs4no_r1_smi_port / smi_latency_mon output"},
+
+	{0x000013C0,
+	 "drzs4no_r1_smi_port / plane-0 - drzs4no_r1_smi_port / plane-0 (i.e. drzs4no_r1) / maddr_max record"},
+	{0x000013C1,
+	 "drzs4no_r1_smi_port / plane-0 - drzs4no_r1_smi_port / plane-0 (i.e. drzs4no_r1) / maddr_min record"},
+};
+
+static __maybe_unused struct dma_debug_item dbg_DRZS4NO_R2[] = {
+	{0x00000014, "drzs4no_r2 32(hex) 0000"},
+	{0x00000114, "drzs4no_r2 state_checksum"},
+	{0x00000214, "drzs4no_r2 line_pix_cnt_tmp"},
+	{0x00000314, "drzs4no_r2 line_pix_cnt"},
+	{0x00000414, "drzs4no_r2 important_status"},
+	{0x00000514, "drzs4no_r2 cmd_data_cnt"},
+	{0x00000614, "drzs4no_r2 cmd_cnt_for_bvalid_phase"},
+	{0x00000714, "drzs4no_r2 input_h_cnt"},
+	{0x00000814, "drzs4no_r2 input_v_cnt"},
+	{0x00000914, "drzs4no_r2 xfer_y_cnt"},
+
+	{0x01000054, "drzs4no_r1_smi_port / plane-1 (i.e. drzs4no_r2) / data-crc"},
+
+	{0x00000085, "drzs4no_r1_smi_port / smi_latency_mon output"},
+
+	{0x000014C0,
+	 "drzs4no_r1_smi_port / plane-1 - drzs4no_r1_smi_port / plane-0 (i.e. drzs4no_r2) / maddr_max record"},
+	{0x000014C1,
+	 "drzs4no_r1_smi_port / plane-1 - drzs4no_r1_smi_port / plane-0 (i.e. drzs4no_r2) / maddr_min record"},
+};
+
+static __maybe_unused struct dma_debug_item dbg_DRZS4NO_R3[] = {
+	{0x00000015, "drzs4no_r3 32(hex) 0000"},
+	{0x00000115, "drzs4no_r3 state_checksum"},
+	{0x00000215, "drzs4no_r3 line_pix_cnt_tmp"},
+	{0x00000315, "drzs4no_r3 line_pix_cnt"},
+	{0x00000415, "drzs4no_r3 important_status"},
+	{0x00000515, "drzs4no_r3 cmd_data_cnt"},
+	{0x00000615, "drzs4no_r3 cmd_cnt_for_bvalid_phase"},
+	{0x00000715, "drzs4no_r3 input_h_cnt"},
+	{0x00000815, "drzs4no_r3 input_v_cnt"},
+	{0x00000915, "drzs4no_r3 xfer_y_cnt"},
+
+	{0x01000055, "drzs4no_r1_smi_port / plane-2 (i.e. drzs4no_r3) / data-crc"},
+
+	{0x00000085, "drzs4no_r1_smi_port / smi_latency_mon output"},
+
+	{0x000015C0,
+	 "drzs4no_r1_smi_port / plane-2 - drzs4no_r1_smi_port / plane-1 (i.e. drzs4no_r3) / maddr_max record"},
+	{0x000015C1,
+	 "drzs4no_r1_smi_port / plane-2 - drzs4no_r1_smi_port / plane-1 (i.e. drzs4no_r3) / maddr_min record"},
+};
+
+static __maybe_unused struct dma_debug_item dbg_LMVO_R1[] = {
+	{0x00000016, "lmvo_r1 32(hex) 0000"},
+	{0x00000116, "lmvo_r1 state_checksum"},
+	{0x00000216, "lmvo_r1 line_pix_cnt_tmp"},
+	{0x00000316, "lmvo_r1 line_pix_cnt"},
+	{0x00000416, "lmvo_r1 important_status"},
+	{0x00000516, "lmvo_r1 cmd_data_cnt"},
+	{0x00000616, "lmvo_r1 cmd_cnt_for_bvalid_phase"},
+	{0x00000716, "lmvo_r1 input_h_cnt"},
+	{0x00000816, "lmvo_r1 input_v_cnt"},
+	{0x00000916, "lmvo_r1 xfer_y_cnt"},
+
+	{0x01000056, "drzs4no_r1_smi_port / plane-3 (i.e. lmvo_r1) / data-crc"},
+
+	{0x00000085, "drzs4no_r1_smi_port / smi_latency_mon output"},
+
+	{0x000016C0,
+	 "drzs4no_r1_smi_port / plane-3 - drzs4no_r1_smi_port / plane-2 (i.e. lmvo_r1) / maddr_max record"},
+	{0x000016C1,
+	 "drzs4no_r1_smi_port / plane-3 - drzs4no_r1_smi_port / plane-2 (i.e. lmvo_r1) / maddr_min record"},
+};
+
+static __maybe_unused struct dma_debug_item dbg_ACTSO_R1[] = {
+	{0x00000017, "actso_r1 32(hex) 0000"},
+	{0x00000117, "actso_r1 state_checksum"},
+	{0x00000217, "actso_r1 line_pix_cnt_tmp"},
+	{0x00000317, "actso_r1 line_pix_cnt"},
+	{0x00000417, "actso_r1 important_status"},
+	{0x00000517, "actso_r1 cmd_data_cnt"},
+	{0x00000617, "actso_r1 cmd_cnt_for_bvalid_phase"},
+	{0x00000717, "actso_r1 input_h_cnt"},
+	{0x00000817, "actso_r1 input_v_cnt"},
+	{0x00000917, "actso_r1 xfer_y_cnt"},
+
+	{0x01000057, "drzs4no_r1_smi_port / plane-4 (i.e. actso_r1) / data-crc"},
+
+	{0x00000085, "drzs4no_r1_smi_port / smi_latency_mon output"},
+
+	{0x000017C0,
+	 "drzs4no_r1_smi_port / plane-4 - drzs4no_r1_smi_port / plane-0 (i.e. actsoo_r1) / maddr_max record"},
+	{0x000017C1,
+	 "drzs4no_r1_smi_port / plane-4 - drzs4no_r1_smi_port / plane-0 (i.e. actsoo_r1) / maddr_min record"},
+};
+
+// M4U_PORT CAM3_TNCSO_R1 : tncso_r1 + tncsbo_r1 + tncsho_r1 + tncsyo_r1
+static __maybe_unused struct dma_debug_item dbg_TNCSO_R1[] = {
+	{0x00000018, "tncso_r1 32(hex) 0000"},
+	{0x00000118, "tncso_r1 state_checksum"},
+	{0x00000218, "tncso_r1 line_pix_cnt_tmp"},
+	{0x00000318, "tncso_r1 line_pix_cnt"},
+	{0x00000418, "tncso_r1 important_status"},
+	{0x00000518, "tncso_r1 cmd_data_cnt"},
+	{0x00000618, "tncso_r1 cmd_cnt_for_bvalid_phase"},
+	{0x00000718, "tncso_r1 input_h_cnt"},
+	{0x00000818, "tncso_r1 input_v_cnt"},
+	{0x00000918, "tncso_r1 xfer_y_cnt"},
+
+	{0x01000058, "tncso_r1_smi_port / plane-0 (i.e. tncso_r1) / data-crc"},
+
+	{0x00000086, "tncso_r1_smi_port / smi_latency_mon output"},
+
+	{0x000018C0,
+	 "tncso_r1_smi_port / plane-0 - tncso_r1_smi_port / plane-1 (i.e. tncso_r1) / maddr_max record"},
+	{0x000018C1,
+	 "tncso_r1_smi_port / plane-0 - tncso_r1_smi_port / plane-1 (i.e. tncso_r1) / maddr_min record"},
+};
+
+static __maybe_unused struct dma_debug_item dbg_TNCSBO_R1[] = {
+	{0x00000019, "tncsbo_r1 32(hex) 0000"},
+	{0x00000119, "tncsbo_r1 state_checksum"},
+	{0x00000219, "tncsbo_r1 line_pix_cnt_tmp"},
+	{0x00000319, "tncsbo_r1 line_pix_cnt"},
+	{0x00000419, "tncsbo_r1 important_status"},
+	{0x00000519, "tncsbo_r1 cmd_data_cnt"},
+	{0x00000619, "tncsbo_r1 cmd_cnt_for_bvalid_phase"},
+	{0x00000719, "tncsbo_r1 input_h_cnt"},
+	{0x00000819, "tncsbo_r1 input_v_cnt"},
+	{0x00000919, "tncsbo_r1 xfer_y_cnt"},
+
+	{0x01000059, "tncso_r1_smi_port / plane-1 (i.e. tncsbo_r1) / data-crc"},
+
+	{0x00000086, "tncso_r1_smi_port / smi_latency_mon output"},
+
+	{0x000019C0,
+	 "tncso_r1_smi_port / plane-1 - tncso_r1_smi_port / plane-0 (i.e. tncsbo_r1) / maddr_max record"},
+	{0x000019C1,
+	 "tncso_r1_smi_port / plane-1 - tncso_r1_smi_port / plane-0 (i.e. tncsbo_r1) / maddr_min record"},
+};
+
+static __maybe_unused struct dma_debug_item dbg_TNCSHO_R1[] = {
+	{0x0000001A, "tncsho_r1 32(hex) 0000"},
+	{0x0000011A, "tncsho_r1 state_checksum"},
+	{0x0000021A, "tncsho_r1 line_pix_cnt_tmp"},
+	{0x0000031A, "tncsho_r1 line_pix_cnt"},
+	{0x0000041A, "tncsho_r1 important_status"},
+	{0x0000051A, "tncsho_r1 cmd_data_cnt"},
+	{0x0000061A, "tncsho_r1 cmd_cnt_for_bvalid_phase"},
+	{0x0000071A, "tncsho_r1 input_h_cnt"},
+	{0x0000081A, "tncsho_r1 input_v_cnt"},
+	{0x0000091A, "tncsho_r1 xfer_y_cnt"},
+
+	{0x0100005A, "tncso_r1_smi_port / plane-2 (i.e. tncsho_r1) / data-crc"},
+
+	{0x00000086, "tncso_r1_smi_port / smi_latency_mon output"},
+
+	{0x00001AC0,
+	 "tncso_r1_smi_port / plane-2 - tncso_r1_smi_port / plane-1 (i.e. tncsho_r1) / maddr_max record"},
+	{0x00001AC1,
+	 "tncso_r1_smi_port / plane-2 - tncso_r1_smi_port / plane-1 (i.e. tncsho_r1) / maddr_max record"},
+};
+
+static __maybe_unused struct dma_debug_item dbg_TNCSYO_R1[] = {
+	{0x0000001B, "tncsyo_r1 32(hex) 0000"},
+	{0x0000011B, "tncsyo_r1 state_checksum"},
+	{0x0000021B, "tncsyo_r1 line_pix_cnt_tmp"},
+	{0x0000031B, "tncsyo_r1 line_pix_cnt"},
+	{0x0000041B, "tncsyo_r1 important_status"},
+	{0x0000051B, "tncsyo_r1 cmd_data_cnt"},
+	{0x0000061B, "tncsyo_r1 cmd_cnt_for_bvalid_phase"},
+	{0x0000071B, "tncsyo_r1 input_h_cnt"},
+	{0x0000081B, "tncsyo_r1 input_v_cnt"},
+	{0x0000091B, "tncsyo_r1 xfer_y_cnt"},
+
+	{0x0100005B, "tncso_r1_smi_port / plane-3 (i.e. tncsyo_r1) / data-crc"},
+
+	{0x00000086, "tncso_r1_smi_port / smi_latency_mon output"},
+
+	{0x00001BC0,
+	 "tncso_r1_smi_port / plane-3 - tncso_r1_smi_port / plane-2 (i.e. tncsyo_r1) / maddr_max record"},
+	{0x00001BC0,
+	 "tncso_r1_smi_port / plane-3 - tncso_r1_smi_port / plane-2 (i.e. tncsyo_r1) / maddr_min record"},
+};
+
+static __maybe_unused struct dma_debug_item dbg_ulc_cmd_cnt[] = {
+	{0x00000511, "bpci_r1 cmd_data_cnt"},
+	{0x00000512, "bpci_r2 cmd_data_cnt"},
+	{0x00000513, "bpci_r3 cmd_data_cnt"},
+	{0x00000516, "aai_r1 cmd_data_cnt"},
+	{0x00000518, "rawi_r6 cmd_data_cnt"},
+	{0x0000051F, "tsfso_r1 cmd_data_cnt"},
+	{0x0000061F, "tsfso_r1 cmd_cnt_for_bvalid_phase"},
+	{0x00000520, "ltmso_r1 cmd_data_cnt"},
+	{0x00000620, "ltmso_r1 cmd_cnt_for_bvalid_phase"},
+	{0x00000521, "tsfso_r2 cmd_data_cnt"},
+	{0x00000621, "tsfso_r2 cmd_cnt_for_bvalid_phase"},
+	{0x00000522, "flko_r1 cmd_data_cnt"},
+	{0x00000622, "flko_r1 cmd_cnt_for_bvalid_phase"},
+	{0x00000523, "ufeo_r1 cmd_data_cnt"},
+	{0x00000623, "ufeo_r1 cmd_cnt_for_bvalid_phase"},
+	{0x00000528, "bino_r1 cmd_data_cnt"},
+	{0x00000628, "bino_r1 cmd_cnt_for_bvalid_phase"},
+};
+
+static __maybe_unused struct dma_debug_item dbg_ori_cmd_cnt[] = {
+	{0x000000A0, "rawi_r2_smi_port / plane-0 (i.e. rawi_r2) / { len-cnt, dle-cnt }"},
+	{0x000000A1, "ufdi_r2_smi_port / plane-0 (i.e. ufdi_r2) / { len-cnt, dle-cnt }"},
+	{0x000000A2, "rawi_r3_smi_port / plane-0 (i.e. rawi_r3) / { len-cnt, dle-cnt }"},
+	{0x000000A3, "ufdi_r3_smi_port / plane-0 (i.e. ufdi_r3) / { len-cnt, dle-cnt }"},
+	{0x000000A4, "rawi_r4_smi_port / plane-0 (i.e. rawi_r4) / { len-cnt, dle-cnt }"},
+	{0x000000A5, "rawi_r5_smi_port / plane-0 (i.e. rawi_r5) / { len-cnt, dle-cnt }"},
+	{0x000000A6, "cqi_r1_smi_port / plane-0 (i.e. cqi_r1) / { len-cnt, dle-cnt }"},
+	{0x000000A7, "cqi_r1_smi_port / plane-1 (i.e. cqi_r3) / { len-cnt, dle-cnt }"},
+	{0x000000A8, "cqi_r2_smi_port / plane-0 (i.e. cqi_r2) / { len-cnt, dle-cnt }"},
+	{0x000000A9, "cqi_r2_smi_port / plane-1 (i.e. cqi_r4) / { len-cnt, dle-cnt }"},
+	{0x000000AA, "lsci_r1_smi_port / plane-0 (i.e. lsci_r1) / { len-cnt, dle-cnt }"},
+	{0x000000AB, "imgo_r1_smi_port / plane-0 (i.e. imgo_r1) / { len-cnt, dle-cnt }"},
+	{0x000000AC, "imgo_r1_smi_port / plane-0 (i.e. imgo_r1) / { load_com-cnt, bvalid-cnt }"},
+	{0x000000AD, "fho_r1_smi_port / plane-0 (i.e. fho_r1) / { len-cnt, dle-cnt }"},
+	{0x000000AE, "fho_r1_smi_port / plane-0 (i.e. fho_r1) / { load_com-cnt, bvalid-cnt }"},
+	{0x000000AF, "fho_r1_smi_port / plane-1 (i.e. aaho_r1) / { len-cnt, dle-cnt }"},
+	{0x000000B0, "fho_r1_smi_port / plane-1 (i.e. aaho_r1) / { load_com-cnt, bvalid-cnt }"},
+	{0x000000B1, "fho_r1_smi_port / plane-2 (i.e. pdo_r1) / { len-cnt, dle-cnt }"},
+	{0x000000B2, "fho_r1_smi_port / plane-2 (i.e. pdo_r1) / { load_com-cnt, bvalid-cnt }"},
+	{0x000000B3, "aao_r1_smi_port / plane-0 (i.e. aao_r1) / { len-cnt, dle-cnt }"},
+	{0x000000B4, "aao_r1_smi_port / plane-0 (i.e. aao_r1) / { load_com-cnt, bvalid-cnt }"},
+	{0x000000B5, "aao_r1_smi_port / plane-1 (i.e. afo_r1) / { len-cnt, dle-cnt }"},
+	{0x000000B6, "aao_r1_smi_port / plane-1 (i.e. afo_r1) / { load_com-cnt, bvalid-cnt }"},
+	{0x000000B7, "ufdi_r5_smi_port / plane-0 (i.e. ufdi_r5) / { len-cnt, dle-cnt }"},
+};
+#endif /*__MTK_CAM_RAW_DMADBG_H*/
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam-feature.c b/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam-feature.c
new file mode 100644
index 0000000000000000000000000000000000000000..a2c0a696a38d0dc40cb5c94322d0911afec896d6
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam-feature.c
@@ -0,0 +1,178 @@
+// SPDX-License-Identifier: GPL-2.0
+//
+// Copyright (c) 2022 MediaTek Inc.
+
+#include "mtk_cam-feature.h"
+
+struct mtk_cam_ctx;
+
+/**
+ * TODO: phase out mtk_cam_is_[feature] since it can't be
+ * used when feature per-frame chages except mtk_cam_is_stagger(),
+ * which is using the raw_feature which is not changed
+ * during streaming.
+ */
+bool mtk_cam_is_time_shared(struct mtk_cam_ctx *ctx)
+{
+	if (!ctx->used_raw_num)
+		return false;
+
+	return mtk_cam_feature_is_time_shared(ctx->pipe->feature_pending);
+}
+
+bool mtk_cam_is_pure_m2m(struct mtk_cam_ctx *ctx)
+{
+	if (!ctx->used_raw_num)
+		return false;
+
+	if (ctx->pipe->feature_pending & MTK_CAM_FEATURE_PURE_OFFLINE_M2M_MASK)
+		return true;
+	else
+		return false;
+}
+
+bool mtk_cam_is_m2m(struct mtk_cam_ctx *ctx)
+{
+	if (!ctx->used_raw_num)
+		return false;
+
+	return mtk_cam_feature_is_m2m(ctx->pipe->feature_pending);
+}
+
+bool mtk_cam_is_stagger_m2m(struct mtk_cam_ctx *ctx)
+{
+	if (!ctx->used_raw_num)
+		return false;
+
+	return mtk_cam_feature_is_stagger_m2m(ctx->pipe->feature_pending);
+}
+
+bool mtk_cam_is_stagger(struct mtk_cam_ctx *ctx)
+{
+	if (!ctx->used_raw_num)
+		return false;
+
+	return mtk_cam_feature_is_stagger(ctx->pipe->feature_active);
+}
+
+bool mtk_cam_is_mstream_m2m(struct mtk_cam_ctx *ctx)
+{
+	if (!ctx->used_raw_num)
+		return false;
+
+	return mtk_cam_feature_is_mstream_m2m(ctx->pipe->feature_pending);
+}
+
+bool mtk_cam_is_mstream(struct mtk_cam_ctx *ctx)
+{
+	if (!ctx->used_raw_num) {
+		pr_debug("not mstream because of used_raw_num=0 !!!\n");
+		return false;
+	}
+
+	return mtk_cam_feature_is_mstream(ctx->pipe->feature_pending);
+}
+
+bool mtk_cam_is_subsample(struct mtk_cam_ctx *ctx)
+{
+	if (!ctx->used_raw_num)
+		return false;
+
+	return mtk_cam_feature_is_subsample(ctx->pipe->feature_pending);
+}
+
+bool mtk_cam_is_2_exposure(struct mtk_cam_ctx *ctx)
+{
+	if (!ctx->used_raw_num)
+		return false;
+
+	return mtk_cam_feature_is_2_exposure(ctx->pipe->feature_pending);
+}
+
+bool mtk_cam_is_3_exposure(struct mtk_cam_ctx *ctx)
+{
+	if (!ctx->used_raw_num)
+		return false;
+
+	return mtk_cam_feature_is_3_exposure(ctx->pipe->feature_pending);
+}
+
+bool mtk_cam_is_with_w_channel(struct mtk_cam_ctx *ctx)
+{
+	if (!ctx->used_raw_num)
+		return false;
+
+	return (ctx->pipe->feature_pending & WITH_W_CHANNEL) != 0;
+}
+
+int mtk_cam_get_sensor_exposure_num(u32 raw_feature)
+{
+	int result = 1;
+
+	raw_feature &= MTK_CAM_FEATURE_HDR_MASK;
+	switch (raw_feature) {
+	case STAGGER_3_EXPOSURE_LE_NE_SE:
+	case STAGGER_3_EXPOSURE_SE_NE_LE:
+		result = 3;
+		break;
+	case STAGGER_2_EXPOSURE_LE_SE:
+	case STAGGER_2_EXPOSURE_SE_LE:
+		result = 2;
+		break;
+	default:
+		result = 1;
+		break;
+	}
+	return result;
+}
+
+int mtk_cam_get_feature_switch(struct mtk_raw_pipeline *raw_pipe,
+			       int prev)
+{
+	int cur = raw_pipe->feature_pending;
+	int res = EXPOSURE_CHANGE_NONE;
+
+	if (cur == prev)
+		return EXPOSURE_CHANGE_NONE;
+	if (cur & MTK_CAM_FEATURE_HDR_MASK || prev & MTK_CAM_FEATURE_HDR_MASK) {
+		if (mtk_cam_feature_is_mstream(cur) || mtk_cam_feature_is_mstream(prev)) {
+			if (prev == 0 && mtk_cam_feature_is_mstream(cur))
+				res = EXPOSURE_CHANGE_1_to_2 |
+						MSTREAM_EXPOSURE_CHANGE;
+			else if (cur == 0 && mtk_cam_feature_is_mstream(prev))
+				res = EXPOSURE_CHANGE_2_to_1 |
+						MSTREAM_EXPOSURE_CHANGE;
+		} else {
+			cur &= MTK_CAM_FEATURE_HDR_MASK;
+			prev &= MTK_CAM_FEATURE_HDR_MASK;
+			if ((cur == STAGGER_2_EXPOSURE_LE_SE || cur == STAGGER_2_EXPOSURE_LE_SE) &&
+			    (prev == STAGGER_3_EXPOSURE_LE_NE_SE ||
+			     prev == STAGGER_3_EXPOSURE_SE_NE_LE))
+				res = EXPOSURE_CHANGE_3_to_2;
+			else if ((prev == STAGGER_2_EXPOSURE_LE_SE ||
+				  prev == STAGGER_2_EXPOSURE_SE_LE) &&
+				 (cur == STAGGER_3_EXPOSURE_LE_NE_SE ||
+				  cur == STAGGER_3_EXPOSURE_SE_NE_LE))
+				res = EXPOSURE_CHANGE_2_to_3;
+			else if (prev == 0 &&
+				 (cur == STAGGER_3_EXPOSURE_LE_NE_SE ||
+				  cur == STAGGER_3_EXPOSURE_SE_NE_LE))
+				res = EXPOSURE_CHANGE_1_to_3;
+			else if (cur == 0 &&
+				 (prev == STAGGER_3_EXPOSURE_LE_NE_SE ||
+				  prev == STAGGER_3_EXPOSURE_SE_NE_LE))
+				res = EXPOSURE_CHANGE_3_to_1;
+			else if (prev == 0 &&
+				 (cur == STAGGER_2_EXPOSURE_LE_SE ||
+				  cur == STAGGER_2_EXPOSURE_SE_LE))
+				res = EXPOSURE_CHANGE_1_to_2;
+			else if (cur == 0 &&
+				 (prev == STAGGER_2_EXPOSURE_LE_SE ||
+				  prev == STAGGER_2_EXPOSURE_SE_LE))
+				res = EXPOSURE_CHANGE_2_to_1;
+		}
+	}
+	dev_dbg(raw_pipe->subdev.dev, "[%s] res:%d\n", __func__, res);
+
+	return res;
+}
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam-feature.h b/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam-feature.h
new file mode 100644
index 0000000000000000000000000000000000000000..6b77b7f149ebdd180dc665e822aeb72438ce6bab
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam-feature.h
@@ -0,0 +1,114 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2022 MediaTek Inc.
+ */
+
+#ifndef __MTK_CAM_FEATURE_H
+#define __MTK_CAM_FEATURE_H
+
+#include "mtk_cam.h"
+#include "mtk_cam-raw.h"
+
+static inline bool mtk_cam_feature_is_mstream_m2m(int feature)
+{
+	if (!(feature & MTK_CAM_FEATURE_OFFLINE_M2M_MASK))
+		return false;
+
+	return !!((feature & MTK_CAM_FEATURE_HDR_MASK) == MSTREAM_NE_SE ||
+		  (feature & MTK_CAM_FEATURE_HDR_MASK) == MSTREAM_SE_NE);
+}
+
+static inline bool mtk_cam_feature_is_mstream(int feature)
+{
+	if (feature & MTK_CAM_FEATURE_OFFLINE_M2M_MASK)
+		return false;
+
+	return !!((feature & MTK_CAM_FEATURE_HDR_MASK) == MSTREAM_NE_SE ||
+		  (feature & MTK_CAM_FEATURE_HDR_MASK) == MSTREAM_SE_NE);
+}
+
+static inline bool mtk_cam_feature_is_time_shared(int feature)
+{
+	return !!(feature & MTK_CAM_FEATURE_TIMESHARE_MASK);
+}
+
+static inline bool mtk_cam_feature_is_stagger_m2m(int feature)
+{
+	int is_hdr = feature & MTK_CAM_FEATURE_HDR_MASK;
+
+	return !!((feature & MTK_CAM_FEATURE_OFFLINE_M2M_MASK) &&
+		(is_hdr >= STAGGER_2_EXPOSURE_LE_SE &&
+		is_hdr <= STAGGER_3_EXPOSURE_SE_NE_LE));
+}
+
+static inline bool mtk_cam_feature_is_m2m(int feature)
+{
+	return !!(feature & MTK_CAM_FEATURE_OFFLINE_M2M_MASK) ||
+			!!(feature & MTK_CAM_FEATURE_PURE_OFFLINE_M2M_MASK);
+}
+
+static inline bool mtk_cam_feature_is_pure_m2m(int feature)
+{
+	return !!(feature & MTK_CAM_FEATURE_PURE_OFFLINE_M2M_MASK);
+}
+
+static inline bool mtk_cam_feature_is_stagger(int feature)
+{
+	int is_hdr = feature & MTK_CAM_FEATURE_HDR_MASK;
+
+	if (feature & MTK_CAM_FEATURE_OFFLINE_M2M_MASK)
+		return false;
+
+	return !!(is_hdr && is_hdr >= STAGGER_2_EXPOSURE_LE_SE &&
+		is_hdr <= STAGGER_3_EXPOSURE_SE_NE_LE);
+}
+
+static inline bool mtk_cam_feature_is_subsample(int feature)
+{
+	return !!(feature & MTK_CAM_FEATURE_SUBSAMPLE_MASK);
+}
+
+static inline bool mtk_cam_feature_is_2_exposure(int feature)
+{
+	u32 raw_feature = feature & 0x0000000F;
+
+	return !!(raw_feature == STAGGER_2_EXPOSURE_LE_SE ||
+		raw_feature == STAGGER_2_EXPOSURE_SE_LE ||
+		mtk_cam_feature_is_mstream(feature));
+}
+
+static inline bool mtk_cam_feature_is_3_exposure(int feature)
+{
+	u32 raw_feature = feature & 0x0000000F;
+
+	return !!(raw_feature == STAGGER_3_EXPOSURE_LE_NE_SE ||
+		raw_feature == STAGGER_3_EXPOSURE_SE_NE_LE);
+}
+
+static inline bool mtk_cam_feature_change_is_mstream(int feature_change)
+{
+	return !!(feature_change & MSTREAM_EXPOSURE_CHANGE);
+}
+
+static inline bool mtk_cam_feature_is_switchable_hdr(int feature)
+{
+	return mtk_cam_feature_is_stagger(feature) || mtk_cam_feature_is_mstream(feature);
+}
+
+bool mtk_cam_is_time_shared(struct mtk_cam_ctx *ctx);
+bool mtk_cam_is_m2m(struct mtk_cam_ctx *ctx);
+bool mtk_cam_is_pure_m2m(struct mtk_cam_ctx *ctx);
+bool mtk_cam_is_stagger(struct mtk_cam_ctx *ctx);
+bool mtk_cam_is_stagger_m2m(struct mtk_cam_ctx *ctx);
+bool mtk_cam_is_mstream(struct mtk_cam_ctx *ctx);
+bool mtk_cam_is_mstream_m2m(struct mtk_cam_ctx *ctx);
+bool mtk_cam_feature_is_mstream(int feature);
+bool mtk_cam_feature_change_is_mstream(int feature_change);
+bool mtk_cam_is_subsample(struct mtk_cam_ctx *ctx);
+bool mtk_cam_is_2_exposure(struct mtk_cam_ctx *ctx);
+bool mtk_cam_is_3_exposure(struct mtk_cam_ctx *ctx);
+bool mtk_cam_is_with_w_channel(struct mtk_cam_ctx *ctx);
+int mtk_cam_get_sensor_exposure_num(u32 raw_feature);
+int mtk_cam_get_feature_switch(struct mtk_raw_pipeline *raw_pipe,
+			       int prev);
+#endif /*__MTK_CAM_FEATURE_H */
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam-ipi.h b/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam-ipi.h
new file mode 100644
index 0000000000000000000000000000000000000000..ee188088957e8c8f6a05c3d2acb98c525b7e4825
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam-ipi.h
@@ -0,0 +1,288 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2022 MediaTek Inc.
+ */
+
+#ifndef __MTK_CAM_IPI_H__
+#define __MTK_CAM_IPI_H__
+
+#define MTK_CAM_IPI_VERSION_MAJOR 0
+#define MTK_CAM_IPI_VERSION_MINOR 1
+
+#include <linux/types.h>
+#include "mtk_cam-defs.h"
+
+
+#define MTK_CAM_MAX_RUNNING_JOBS (3)
+#define CAM_MAX_PLANENUM (3)
+#define CAM_MAX_SUBSAMPLE (32)
+
+/*
+ * struct mtkcam_ipi_point - Point
+ *
+ * @x: x-coordinate of the point (zero-based).
+ * @y: y-coordinate of the point (zero-based).
+ */
+struct mtkcam_ipi_point {
+	__u16 x;
+	__u16 y;
+} __attribute__ ((__packed__));
+
+/*
+ * struct mtkcam_ipi_size - Size
+ *
+ * @w: width (in pixels).
+ * @h: height (in pixels).
+ */
+struct mtkcam_ipi_size {
+	__u16 w;
+	__u16 h;
+} __attribute__ ((__packed__));
+
+/*
+ * struct mtkcam_ipi_fract - fraction
+ *
+ * @numerator: denominator part of the fraction.
+ * @denominator: denominator part of the fraction.
+ */
+struct mtkcam_ipi_fract {
+	__u8 numerator;
+	__u8 denominator;
+};
+
+/*
+ * struct mtkcam_ipi_sw_buffer
+ *	- Shared buffer between cam-device and co-processor.
+ *
+ * @iova: DMA address for CAM DMA device.
+ * @ccd_fd: fd to ccd
+ * @scp_addr: SCP  address for external co-processor unit.
+ * @size: buffer size.
+ */
+struct mtkcam_ipi_sw_buffer {
+#ifdef ISP7_1
+	__u64 iova;
+#else
+	__u32 iova;
+#endif
+	__u32 fd;
+	__u32 scp_addr;
+	__u32 size;
+} __attribute__ ((__packed__));
+
+/*
+ * struct mtkcam_ipi_hw_buffer - DMA buffer for CAM DMA device.
+ *
+ * @iova: DMA address for CAM DMA device.
+ * @size: buffer size.
+ */
+struct mtkcam_ipi_hw_buffer {
+#ifdef ISP7_1
+	__u64 iova;
+#else
+	__u32 iova;
+#endif
+	__u32 size;
+} __attribute__ ((__packed__));
+
+struct mtkcam_ipi_pix_fmt {
+	__u32			format;
+	struct mtkcam_ipi_size	s;
+	__u16			stride[CAM_MAX_PLANENUM];
+} __attribute__ ((__packed__));
+
+struct mtkcam_ipi_crop {
+	struct mtkcam_ipi_point p;
+	struct mtkcam_ipi_size s;
+} __attribute__ ((__packed__));
+
+struct mtkcam_ipi_uid {
+	__u8 pipe_id;
+	__u8 id;
+} __attribute__ ((__packed__));
+
+#ifdef __KERNEL__
+
+static inline unsigned int mtkcam_raw_ids(void)
+{
+	return MTKCAM_IPI_RAW_ID_MAX - 1;
+}
+
+static inline unsigned int mtkcam_camsv_ids(void)
+{
+	return MTKCAM_IPI_CAMSV_ID_MAX - 1;
+}
+
+static inline unsigned int uid_nbits(void)
+{
+	return 3 * mtkcam_raw_ids()
+		+ 8 * mtkcam_camsv_ids();
+}
+
+static inline unsigned int uid_to_bit(struct mtkcam_ipi_uid uid)
+{
+	unsigned int lbit = 0;
+
+	lbit += (uid.pipe_id - MTKCAM_SUBDEV_RAW_0) * mtkcam_raw_ids();
+	if (uid.pipe_id > MTKCAM_SUBDEV_CAMSV_0)
+		lbit += (uid.pipe_id - MTKCAM_SUBDEV_CAMSV_0) *
+			mtkcam_camsv_ids();
+	return lbit + uid.id - 1; /* FIXME: 1 for temporay solution */
+}
+
+#endif
+
+struct mtkcam_ipi_img_input {
+	struct mtkcam_ipi_uid		uid;
+	struct mtkcam_ipi_pix_fmt	fmt;
+	struct mtkcam_ipi_sw_buffer	buf[CAM_MAX_PLANENUM];
+} __attribute__ ((__packed__));
+
+struct mtkcam_ipi_img_output {
+	struct mtkcam_ipi_uid		uid;
+	struct mtkcam_ipi_pix_fmt	fmt;
+	struct mtkcam_ipi_sw_buffer	buf[CAM_MAX_SUBSAMPLE][CAM_MAX_PLANENUM];
+	struct mtkcam_ipi_crop		crop;
+} __attribute__ ((__packed__));
+
+struct mtkcam_ipi_meta_input {
+	struct mtkcam_ipi_uid		uid;
+	struct mtkcam_ipi_sw_buffer	buf;
+} __attribute__ ((__packed__));
+
+struct mtkcam_ipi_meta_output {
+	struct mtkcam_ipi_uid		uid;
+	struct mtkcam_ipi_sw_buffer	buf;
+} __attribute__ ((__packed__));
+
+struct mtkcam_ipi_input_param {
+	__u32	fmt;
+	__u8	raw_pixel_id;
+	__u8	data_pattern;
+	__u8	pixel_mode;
+	__u8	subsample;
+	/* u8 continuous; */ /* always 1 */
+	/* u16 tg_fps; */ /* not used yet */
+	struct mtkcam_ipi_crop in_crop;
+} __attribute__ ((__packed__));
+
+struct mtkcam_ipi_raw_frame_param {
+	__u8	imgo_path_sel; /* mtkcam_ipi_raw_path_control */
+	__u8	hardware_scenario;
+	__u32	bin_flag;
+	__u8    exposure_num;
+	__u8    previous_exposure_num;
+	struct mtkcam_ipi_fract	frz_ratio;
+
+	/* blahblah */
+} __attribute__ ((__packed__));
+
+/* TODO: support CAMSV */
+struct cam_camsv_params {
+	/* sth here */
+} __attribute__ ((__packed__));
+
+struct mtkcam_ipi_session_cookie {
+	__u8 session_id;
+	__u32 frame_no;
+} __attribute__ ((__packed__));
+
+struct mtkcam_ipi_session_param {
+	struct mtkcam_ipi_sw_buffer workbuf;
+	struct mtkcam_ipi_sw_buffer msg_buf;
+	struct mtkcam_ipi_sw_buffer raw_workbuf;
+	struct mtkcam_ipi_sw_buffer priv_workbuf;
+	struct mtkcam_ipi_sw_buffer session_buf;
+} __attribute__ ((__packed__));
+
+struct mtkcam_ipi_hw_mapping {
+	__u8 pipe_id; /* ref. to mtkcam_pipe_subdev */
+	__u16 dev_mask; /* ref. to mtkcam_pipe_dev */
+	__u8 exp_order;
+} __attribute__ ((__packed__));
+
+/*  Control flags of CAM_CMD_CONFIG */
+#define MTK_CAM_IPI_CONFIG_TYPE_INIT			0x0001
+#define MTK_CAM_IPI_CONFIG_TYPE_INPUT_CHANGE		0x0002
+#define MTK_CAM_IPI_CONFIG_TYPE_EXEC_TWICE		0x0004
+#define MTK_CAM_IPI_CONFIG_TYPE_SMVR_PREVIEW		0x0008
+
+struct mtkcam_ipi_config_param {
+	__u8 flags;
+	struct mtkcam_ipi_input_param	input;
+	__u8 n_maps;
+	/* maximum # of pipes per stream */
+	struct mtkcam_ipi_hw_mapping maps[6];
+	/* sub_ratio:8, valid number: 8 */
+	__u16 valid_numbers[MTKCAM_IPI_FBCX_LAST];
+	__u8	sw_feature;
+} __attribute__ ((__packed__));
+
+#define CAM_MAX_IMAGE_INPUT	(5)
+#define CAM_MAX_IMAGE_OUTPUT	(15)
+#define CAM_MAX_META_OUTPUT	(4)
+#define CAM_MAX_PIPE_USED	(4)
+
+struct mtkcam_ipi_frame_param {
+	__u32 cur_workbuf_offset;
+	__u32 cur_workbuf_size;
+
+	struct mtkcam_ipi_raw_frame_param raw_param;
+	struct mtkcam_ipi_img_input img_ins[CAM_MAX_IMAGE_INPUT];
+	struct mtkcam_ipi_img_output img_outs[CAM_MAX_IMAGE_OUTPUT];
+	struct mtkcam_ipi_meta_output meta_outputs[CAM_MAX_META_OUTPUT];
+	struct mtkcam_ipi_meta_input meta_inputs[CAM_MAX_PIPE_USED];
+} __attribute__ ((__packed__));
+
+struct mtkcam_ipi_frame_info {
+	__u32	cur_msgbuf_offset;
+	__u32	cur_msgbuf_size;
+} __attribute__ ((__packed__));
+
+struct mtkcam_ipi_frame_ack_result {
+	__u32 cq_desc_offset;
+	__u32 sub_cq_desc_offset;
+	__u32 cq_desc_size;
+	__u32 sub_cq_desc_size;
+} __attribute__ ((__packed__));
+
+struct mtkcam_ipi_ack_info {
+	__u8 ack_cmd_id;
+	__s32 ret;
+	struct mtkcam_ipi_frame_ack_result frame_result;
+} __attribute__ ((__packed__));
+
+/*
+ * The IPI command enumeration.
+ */
+enum mtkcam_ipi_cmds {
+	/* request for a new streaming: mtkcam_ipi_session_param */
+	CAM_CMD_CREATE_SESSION,
+
+	/* config the stream: mtkcam_ipi_config_param */
+	CAM_CMD_CONFIG,
+
+	/* per-frame: mtkcam_ipi_frame_param */
+	CAM_CMD_FRAME,
+
+	/* release certain streaming: mtkcam_ipi_session_param */
+	CAM_CMD_DESTROY_SESSION,
+
+	/* ack: mtkcam_ipi_ack_info */
+	CAM_CMD_ACK,
+
+	CAM_CMD_RESERVED,
+};
+
+struct mtkcam_ipi_event  {
+	struct mtkcam_ipi_session_cookie cookie;
+	__u8 cmd_id;
+	union {
+		struct mtkcam_ipi_session_param	session_data;
+		struct mtkcam_ipi_config_param	config_data;
+		struct mtkcam_ipi_frame_info	frame_data;
+		struct mtkcam_ipi_ack_info	ack_data;
+	};
+} __attribute__ ((__packed__));
+
+#endif /* __MTK_CAM_IPI_H__ */
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam-meta-mt8188.h b/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam-meta-mt8188.h
new file mode 100644
index 0000000000000000000000000000000000000000..029609f0daab2bdb7db7971460590ca1ef88e7e1
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam-meta-mt8188.h
@@ -0,0 +1,827 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2022 MediaTek Inc.
+ */
+
+
+#ifndef __MTK_CAM_META_H__
+#define __MTK_CAM_META_H__
+
+
+/**
+ * struct mtk_cam_uapi_meta_rect - rect info
+ *
+ * @left: The X coordinate of the left side of the rectangle
+ * @top:  The Y coordinate of the left side of the rectangle
+ * @width:  The width of the rectangle
+ * @height: The height of the rectangle
+ *
+ * rect containing the width and height fields.
+ *
+ */
+struct mtk_cam_uapi_meta_rect {
+	__s32 left;
+	__s32 top;
+	__u32 width;
+	__u32 height;
+};
+
+/**
+ * struct mtk_cam_uapi_meta_size - size info
+ *
+ * @width:  The width of the size
+ * @height: The height of the size
+ *
+ * size containing the width and height fields.
+ *
+ */
+struct mtk_cam_uapi_meta_size {
+	__u32 width;
+	__u32 height;
+};
+
+/**
+ *  A U T O  E X P O S U R E
+ */
+
+/*
+ *  struct mtk_cam_uapi_ae_hist_cfg - histogram info for AE
+ *
+ *  @hist_en:    enable bit for current histogram, each histogram can
+ *      be 0/1 (disabled/enabled) separately
+ *  @hist_opt:   color mode config for current histogram (0/1/2/3/4:
+ *      R/G/B/RGB mix/Y)
+ *  @hist_bin:   bin mode config for current histogram (1/4: 256/1024 bin)
+ *  @hist_y_hi:  ROI Y range high bound for current histogram
+ *  @hist_y_low: ROI Y range low bound for current histogram
+ *  @hist_x_hi:  ROI X range high bound for current histogram
+ *  @hist_x_low: ROI X range low bound for current histogram
+ */
+struct mtk_cam_uapi_ae_hist_cfg {
+	__s32 hist_en;
+	__u8 hist_opt;
+	__u8 hist_bin;
+	__u16 hist_y_hi;
+	__u16 hist_y_low;
+	__u16 hist_x_hi;
+	__u16 hist_x_low;
+};
+
+#define MTK_CAM_UAPI_ROI_MAP_BLK_NUM (128*128)
+/*
+ *  struct mtk_cam_uapi_ae_param - parameters for AE configurtion
+ *
+ *  @pixel_hist_win_cfg_le: window config for le histogram 0~5
+ *           separately, uAEHistBin shold be the same
+ *           for these 6 histograms
+ *  @pixel_hist_win_cfg_se: window config for se histogram 0~5
+ *           separately, uAEHistBin shold be the same
+ *           for these 6 histograms
+ *  @roi_hist_cfg_le : config for roi le histogram 0~3
+ *           color mode/enable
+ *  @roi_hist_cfg_se : config for roi se histogram 0~3
+ *           color mode/enable
+ *  @hdr_ratio: in HDR scenario, AE calculated hdr ratio
+ *           (LE exp*iso/SE exp*iso*100) for current frame,
+ *           default non-HDR scenario ratio=1000
+ */
+struct mtk_cam_uapi_ae_param {
+	struct mtk_cam_uapi_ae_hist_cfg pixel_hist_win_cfg_le[6];
+	struct mtk_cam_uapi_ae_hist_cfg pixel_hist_win_cfg_se[6];
+	struct mtk_cam_uapi_ae_hist_cfg roi_hist_cfg_le[4];
+	struct mtk_cam_uapi_ae_hist_cfg roi_hist_cfg_se[4];
+	__u8  aai_r1_enable;
+	__u8  aai_roi_map[MTK_CAM_UAPI_ROI_MAP_BLK_NUM];
+	__u16 hdr_ratio; /* base 1 x= 1000 */
+	__u32 act_win_x_start;
+	__u32 act_win_x_end;
+	__u32 act_win_y_start;
+	__u32 act_win_y_end;
+};
+
+/**
+ *  A U T O  W H I T E  B A L A N C E
+ */
+
+/* Maximum blocks that Mediatek AWB supports */
+#define MTK_CAM_UAPI_AWB_MAX_LIGHT_AREA_NUM (10)
+
+/*
+ *  struct mtk_cam_uapi_awb_param - parameters for AWB configurtion
+ *
+ *  @stat_en:                  AWB stat enable
+ *  @windownum_x:              Number of horizontal AWB windows
+ *  @windownum_y:              Number of vertical AWB windows
+ *  @lowthreshold_r:           Low threshold of R
+ *  @lowthreshold_g:           Low threshold of G
+ *  @lowthreshold_b:           Low threshold of B
+ *  @highthreshold_r:          High threshold of R
+ *  @highthreshold_g:          High threshold of G
+ *  @highthreshold_b:          High threshold of B
+ *  @lightsrc_lowthreshold_r:  Low threshold of R for light source estimation
+ *  @lightsrc_lowthreshold_g:  Low threshold of G for light source estimation
+ *  @lightsrc_lowthreshold_b:  Low threshold of B for light source estimation
+ *  @lightsrc_highthreshold_r: High threshold of R for light source estimation
+ *  @lightsrc_highthreshold_g: High threshold of G for light source estimation
+ *  @lightsrc_highthreshold_b: High threshold of B for light source estimation
+ *  @pregainlimit_r:           Maximum limit clipping for R color
+ *  @pregainlimit_g:           Maximum limit clipping for G color
+ *  @pregainlimit_b:           Maximum limit clipping for B color
+ *  @pregain_r:                unit module compensation gain for R color
+ *  @pregain_g:                unit module compensation gain for G color
+ *  @pregain_b:                unit module compensation gain for B color
+ *  @valid_datawidth:          valid bits of statistic data
+ *  @hdr_support_en:           support HDR mode
+ *  @stat_mode:                Output format select <1>sum mode <0>average mode
+ *  @error_ratio:              Programmable error pixel count by AWB window size
+ *              (base : 256)
+ *  @awbxv_win_r:              light area of right bound, the size is defined in
+ *              MTK_CAM_UAPI_AWB_MAX_LIGHT_AREA_NUM
+ *  @awbxv_win_l:              light area of left bound the size is defined in
+ *              MTK_CAM_UAPI_AWB_MAX_LIGHT_AREA_NUM
+ *  @awbxv_win_d:              light area of lower bound the size is defined in
+ *              MTK_CAM_UAPI_AWB_MAX_LIGHT_AREA_NUM
+ *  @awbxv_win_u:              light area of upper bound the size is defined in
+ *              MTK_CAM_UAPI_AWB_MAX_LIGHT_AREA_NUM
+ *  @pregain2_r:               white balance gain of R color
+ *  @pregain2_g:               white balance gain of G color
+ *  @pregain2_b:               white balance gain of B color
+ */
+struct mtk_cam_uapi_awb_param {
+	__u32 stat_en;
+	__u32 windownum_x;
+	__u32 windownum_y;
+	__u32 lowthreshold_r;
+	__u32 lowthreshold_g;
+	__u32 lowthreshold_b;
+	__u32 highthreshold_r;
+	__u32 highthreshold_g;
+	__u32 highthreshold_b;
+	__u32 lightsrc_lowthreshold_r;
+	__u32 lightsrc_lowthreshold_g;
+	__u32 lightsrc_lowthreshold_b;
+	__u32 lightsrc_highthreshold_r;
+	__u32 lightsrc_highthreshold_g;
+	__u32 lightsrc_highthreshold_b;
+	__u32 pregainlimit_r;
+	__u32 pregainlimit_g;
+	__u32 pregainlimit_b;
+	__u32 pregain_r;
+	__u32 pregain_g;
+	__u32 pregain_b;
+	__u32 valid_datawidth;
+	__u32 hdr_support_en;
+	__u32 stat_mode;
+	__u32 format_shift;
+	__u32 error_ratio;
+	__u32 postgain_r;
+	__u32 postgain_g;
+	__u32 postgain_b;
+	__u32 postgain2_hi_r;
+	__u32 postgain2_hi_g;
+	__u32 postgain2_hi_b;
+	__u32 postgain2_med_r;
+	__u32 postgain2_med_g;
+	__u32 postgain2_med_b;
+	__u32 postgain2_low_r;
+	__u32 postgain2_low_g;
+	__u32 postgain2_low_b;
+	__s32 awbxv_win_r[MTK_CAM_UAPI_AWB_MAX_LIGHT_AREA_NUM];
+	__s32 awbxv_win_l[MTK_CAM_UAPI_AWB_MAX_LIGHT_AREA_NUM];
+	__s32 awbxv_win_d[MTK_CAM_UAPI_AWB_MAX_LIGHT_AREA_NUM];
+	__s32 awbxv_win_u[MTK_CAM_UAPI_AWB_MAX_LIGHT_AREA_NUM];
+	__u32 csc_ccm[9];
+	__u32 acc;
+	__u32 med_region[4];
+	__u32 low_region[4];
+	__u32 pregain2_r;
+	__u32 pregain2_g;
+	__u32 pregain2_b;
+};
+
+/*
+ * struct mtk_cam_uapi_dgn_param
+ *
+ *  @gain: digital gain to increase image brightness, 1 x= 1024
+ */
+struct mtk_cam_uapi_dgn_param {
+	__u32 gain;
+};
+
+/*
+ * struct mtk_cam_uapi_wb_param
+ *
+ *  @gain_r: white balance gain of R channel
+ *  @gain_g: white balance gain of G channel
+ *  @gain_b: white balance gain of B channel
+ */
+struct mtk_cam_uapi_wb_param {
+	__u32 gain_r;
+	__u32 gain_g;
+	__u32 gain_b;
+	__u32 clip;
+};
+
+/**
+ *  A U T O  F O C U S
+ */
+
+/**
+ * struct mtk_cam_uapi_af_param - af statistic parameters
+ *  @roi: AF roi rectangle (in pixel) for AF statistic covered, including
+ *    x, y, width, height
+ *  @th_sat_g:  green channel pixel value saturation threshold (0~255)
+ *  @th_h[3]: horizontal AF filters response threshold (0~50) for H0, H1,
+ *    and H2
+ *  @th_v:  vertical AF filter response threshold (0~50)
+ *  @blk_pixel_xnum: horizontal number of pixel per block
+ *  @blk_pixel_ynum: vertical number of pixel per block
+ *  @fir_type: to select FIR filter by AF target type (0,1,2,3)
+ *  @iir_type: to select IIR filter by AF target type (0,1,2,3)
+ *  @data_gain[7]: gamma curve gain for AF source data
+ */
+struct mtk_cam_uapi_af_param {
+	struct mtk_cam_uapi_meta_rect roi;
+	__u32 th_sat_g;
+	__u32 th_h[3];
+	__u32 th_v;
+	__u32 blk_pixel_xnum;
+	__u32 blk_pixel_ynum;
+	__u32 fir_type;
+	__u32 iir_type;
+	__u32 data_gain[7];
+};
+
+enum mtk_cam_uapi_flk_hdr_path_control {
+	MTKCAM_UAPI_FKLO_HDR_1ST_FRAME = 0,
+	MTKCAM_UAPI_FKLO_HDR_2ND_FRAME,
+	MTKCAM_UAPI_FKLO_HDR_3RD_FRAME,
+};
+
+/*
+ *  struct mtk_cam_uapi_flk_param
+ *
+ *  @input_bit_sel: maximum pixel value of flicker statistic input
+ *  @offset_y: initial position for flicker statistic calculation in y direction
+ *  @crop_y: number of rows which will be cropped from bottom
+ *  @sgg_val[8]: Simple Gain and Gamma for noise reduction, sgg_val[0] is
+ *               gain and sgg_val[1] - sgg_val[7] are gamma table
+ *  @noise_thr: the noise threshold of pixel value, pixel value lower than
+ *              this value is considered as noise
+ *  @saturate_thr: the saturation threshold of pixel value, pixel value
+ *                 higher than this value is considered as saturated
+ *  @hdr_flk_src: flk source tap point selection
+ */
+struct mtk_cam_uapi_flk_param {
+	__u32 input_bit_sel;
+	__u32 offset_y;
+	__u32 crop_y;
+	__u32 sgg_val[8];
+	__u32 noise_thr;
+	__u32 saturate_thr;
+	__u32 hdr_flk_src;
+};
+
+/*
+ * struct mtk_cam_uapi_tsf_param
+ *
+ *  @horizontal_num: block number of horizontal direction
+ *  @vertical_num:   block number of vertical direction
+ */
+struct mtk_cam_uapi_tsf_param {
+	__u32 horizontal_num;
+	__u32 vertical_num;
+};
+
+/*
+ * struct mtk_cam_uapi_pde_param
+ *
+ * @pdi_max_size: the max required memory size for pd table
+ * @pdo_max_size: the max required memory size for pd point output
+ * @pdo_x_size: the pd points out x size
+ * @pdo_y_size: the pd points out y size
+ * @pd_table_offset: the offset of pd table in the meta_cfg
+ */
+struct mtk_cam_uapi_pde_param {
+	__u32 pdi_max_size;
+	__u32 pdo_max_size;
+	__u32 pdo_x_size;
+	__u32 pdo_y_size;
+	__u32 pd_table_offset;
+};
+
+/**
+ * struct mtk_cam_uapi_meta_hw_buf - hardware buffer info
+ *
+ * @offset: offset from the start of the device memory associated to the
+ *    v4l2 meta buffer
+ * @size: size of the buffer
+ *
+ * Some part of the meta buffers are read or written by statistic related
+ * hardware DMAs. The hardware buffers may have different size among
+ * difference pipeline.
+ */
+struct mtk_cam_uapi_meta_hw_buf {
+	__u32 offset;
+	__u32 size;
+};
+
+/**
+ * struct mtk_cam_uapi_pdp_stats - statistics of pd
+ *
+ * @stats_src:     source width and heitgh of the statistics.
+ * @stride:     stride value used by
+ * @pdo_buf:     The buffer for PD statistic hardware output.
+ *
+ * This is the PD statistic returned to user.
+ */
+struct mtk_cam_uapi_pdp_stats {
+	struct  mtk_cam_uapi_meta_size stats_src;
+	__u32   stride;
+	struct  mtk_cam_uapi_meta_hw_buf pdo_buf;
+};
+
+/**
+ * struct mtk_cam_uapi_cpi_stats - statistics of pd
+ *
+ * @stats_src:     source width and heitgh of the statistics.
+ * @stride:     stride value used by
+ * @pdo_buf:     The buffer for PD statistic hardware output.
+ *
+ * This is the PD statistic returned to user.
+ */
+struct mtk_cam_uapi_cpi_stats {
+	struct  mtk_cam_uapi_meta_size stats_src;
+	__u32   stride;
+	struct  mtk_cam_uapi_meta_hw_buf cpio_buf;
+};
+
+/*
+ * struct mtk_cam_uapi_mqe_param
+ *
+ * @mqe_mode:
+ */
+struct mtk_cam_uapi_mqe_param {
+	__u32 mqe_mode;
+};
+
+/*
+ * struct mtk_cam_uapi_mobc_param
+ *
+ *
+ */
+struct mtk_cam_uapi_mobc_param {
+	__u32 mobc_offst0;
+	__u32 mobc_offst1;
+	__u32 mobc_offst2;
+	__u32 mobc_offst3;
+	__u32 mobc_gain0;
+	__u32 mobc_gain1;
+	__u32 mobc_gain2;
+	__u32 mobc_gain3;
+};
+
+/*
+ * struct mtk_cam_uapi_lsc_param
+ *
+ *
+ */
+struct mtk_cam_uapi_lsc_param {
+	__u32 lsc_ctl1;
+	__u32 lsc_ctl2;
+	__u32 lsc_ctl3;
+	__u32 lsc_lblock;
+	__u32 lsc_fblock;
+	__u32 lsc_ratio;
+	__u32 lsc_tpipe_ofst;
+	__u32 lsc_tpipe_size;
+};
+
+/*
+ * struct mtk_cam_uapi_sgg_param
+ *
+ *
+ */
+struct mtk_cam_uapi_sgg_param {
+	__u32 sgg_pgn;
+	__u32 sgg_gmrc_1;
+	__u32 sgg_gmrc_2;
+};
+
+/*
+ * struct mtk_cam_uapi_mbn_param
+ *
+ *
+ */
+struct mtk_cam_uapi_mbn_param {
+	__u32 mbn_pow;
+	__u32 mbn_dir;
+	__u32 mbn_spar_hei;
+	__u32 mbn_spar_pow;
+	__u32 mbn_spar_fac;
+	__u32 mbn_spar_con1;
+	__u32 mbn_spar_con0;
+};
+
+/*
+ * struct mtk_cam_uapi_cpi_param
+ *
+ *
+ */
+struct mtk_cam_uapi_cpi_param {
+	__u32 cpi_th;
+	__u32 cpi_pow;
+	__u32 cpi_dir;
+	__u32 cpi_spar_hei;
+	__u32 cpi_spar_pow;
+	__u32 cpi_spar_fac;
+	__u32 cpi_spar_con1;
+	__u32 cpi_spar_con0;
+};
+
+/*
+ * struct mtk_cam_uapi_lsci_param
+ *
+ *
+ */
+struct mtk_cam_uapi_lsci_param {
+	__u32 lsci_xsize;
+	__u32 lsci_ysize;
+};
+
+/**
+ * Common stuff for all statistics
+ */
+
+#define MTK_CAM_UAPI_MAX_CORE_NUM (2)
+
+/**
+ * struct mtk_cam_uapi_pipeline_config - pipeline configuration
+ *
+ * @num_of_core: The number of isp cores
+ */
+struct mtk_cam_uapi_pipeline_config {
+	__u32	num_of_core;
+	struct	mtk_cam_uapi_meta_size core_data_size;
+	__u32	core_pxl_mode_lg2;
+};
+
+/**
+ *  A U T O  E X P O S U R E
+ */
+
+/* TODO: Need to check the size of MTK_CAM_AE_HIST_MAX_BIN*/
+#define MTK_CAM_UAPI_AE_STATS_HIST_MAX_BIN (1024)
+
+/**
+ *  A E  A N D   A W B
+ */
+
+#define MTK_CAM_UAPI_AAO_BLK_SIZE (32)
+#define MTK_CAM_UAPI_AAO_MAX_BLK_X (128)
+#define MTK_CAM_UAPI_AAO_MAX_BLK_Y (128)
+#define MTK_CAM_UAPI_AAO_MAX_BUF_SIZE (MTK_CAM_UAPI_AAO_BLK_SIZE \
+					* MTK_CAM_UAPI_AAO_MAX_BLK_X \
+					* MTK_CAM_UAPI_AAO_MAX_BLK_Y)
+
+#define MTK_CAM_UAPI_AHO_BLK_SIZE (3)
+#define MTK_CAM_UAPI_AAHO_HIST_SIZE  (6 * 1024 * MTK_CAM_UAPI_AHO_BLK_SIZE \
+					+ 14 * 256 * MTK_CAM_UAPI_AHO_BLK_SIZE)
+#define MTK_CAM_UAPI_AAHO_MAX_BUF_SIZE  (MTK_CAM_UAPI_MAX_CORE_NUM * \
+					MTK_CAM_UAPI_AAHO_HIST_SIZE)
+
+/**
+ * struct mtk_cam_uapi_ae_awb_stats - statistics of ae and awb
+ *
+ * @aao_buf:       The buffer for AAHO statistic hardware output.
+ *        The maximum size of the buffer is defined with
+ *        MTK_CAM_UAPI_AAO_MAX_BUF_SIZE
+ * @aaho_buf:      The buffer for AAHO statistic hardware output.
+ *        The maximum size of the buffer is defined with
+ *        MTK_CAM_UAPI_AAHO_MAX_BUF_SIZE.
+ *
+ * This is the AE and AWB statistic returned to user. From  our hardware's
+ * point of view, we can't separate the AE and AWB output result, so I use
+ * a struct to retutn them.
+ */
+struct mtk_cam_uapi_ae_awb_stats {
+	__u32 awb_stat_en_status;
+	__u32 awb_qbn_acc;
+	__u32 ae_stat_en_status;
+	struct mtk_cam_uapi_meta_hw_buf aao_buf;
+	struct mtk_cam_uapi_meta_hw_buf aaho_buf;
+};
+
+/**
+ *  A U T O  F O C U S
+ */
+
+#define MTK_CAM_UAPI_AFO_BLK_SIZ    (32)
+#define MTK_CAM_UAPI_AFO_MAX_BLK_NUM (128 * 128)
+#define MTK_CAM_UAPI_AFO_MAX_BUF_SIZE   (MTK_CAM_UAPI_AFO_BLK_SIZ \
+						* MTK_CAM_UAPI_AFO_MAX_BLK_NUM)
+
+/**
+ * struct mtk_cam_uapi_af_stats - af statistics
+ *
+ * @blk_num_x: block number of horizontal direction
+ * @blk_num_y: block number of vertical direction
+ * @afo_buf:    the buffer for AAHO statistic hardware output. The maximum
+ *      size of the buffer is defined with
+ *      MTK_CAM_UAPI_AFO_MAX_BUF_SIZE.
+ */
+struct mtk_cam_uapi_af_stats {
+	__u32 blk_num_x;
+	__u32 blk_num_y;
+	struct mtk_cam_uapi_meta_hw_buf afo_buf;
+};
+
+/**
+ *  F L I C K E R
+ */
+
+/* FLK's hardware output block size: 64 bits */
+#define MTK_CAM_UAPI_FLK_BLK_SIZE (8)
+
+/* Maximum block size (each line) of Mediatek flicker statistic */
+#define MTK_CAM_UAPI_FLK_MAX_STAT_BLK_NUM (6)
+
+/* Maximum height (in pixel) that driver can support */
+#define MTK_CAM_UAPI_FLK_MAX_FRAME_HEIGHT (9000)
+#define MTK_CAM_UAPI_FLK_MAX_BUF_SIZE                              \
+	(MTK_CAM_UAPI_FLK_BLK_SIZE * MTK_CAM_UAPI_FLK_MAX_STAT_BLK_NUM * \
+	MTK_CAM_UAPI_FLK_MAX_FRAME_HEIGHT)
+
+/**
+ * struct mtk_cam_uapi_flk_stats
+ *
+ * @flko_buf: the buffer for FLKO statistic hardware output. The maximum
+ *         size of the buffer is defined with MTK_CAM_UAPI_FLK_MAX_BUF_SIZE.
+ */
+struct mtk_cam_uapi_flk_stats {
+	struct mtk_cam_uapi_meta_hw_buf flko_buf;
+};
+
+/**
+ *  T S F
+ */
+
+#define MTK_CAM_UAPI_TSFSO_SIZE (40 * 30 * 3 * 4)
+
+/**
+ * struct mtk_cam_uapi_tsf_stats - TSF statistic data
+ *
+ * @tsfo_buf: The buffer for tsf statistic hardware output. The buffer size
+ *        is defined in MTK_CAM_UAPI_TSFSO_SIZE.
+ *
+ * This output is for Mediatek proprietary algorithm
+ */
+struct mtk_cam_uapi_tsf_stats {
+	struct mtk_cam_uapi_meta_hw_buf tsfo_r1_buf;
+	struct mtk_cam_uapi_meta_hw_buf tsfo_r2_buf;
+};
+
+/**
+ * struct mtk_cam_uapi_pd_stats - statistics of pd
+ *
+ * @stats_src:     source width and heitgh of the statistics.
+ * @stride:	   stride value used by
+ * @pdo_buf:	   The buffer for PD statistic hardware output.
+ *
+ * This is the PD statistic returned to user.
+ */
+struct mtk_cam_uapi_pd_stats {
+	struct	mtk_cam_uapi_meta_size stats_src;
+	__u32	stride;
+	struct	mtk_cam_uapi_meta_hw_buf pdo_buf;
+};
+
+struct mtk_cam_uapi_timestamp {
+	__u64 timestamp_buf[128];
+};
+
+/**
+ *  T O N E
+ */
+#define MTK_CAM_UAPI_LTMSO_SIZE ((37*12*9 + 258) * 8)
+#define MTK_CAM_UAPI_TNCSO_SIZE (680*510*2)
+#define MTK_CAM_UAPI_TNCSHO_SIZE (1544)
+#define MTK_CAM_UAPI_TNCSBO_SIZE (3888)
+#define MTK_CAM_UAPI_TNCSYO_SIZE (68)
+
+/**
+ * struct mtk_cam_uapi_ltm_stats - Tone1 statistic data for
+ *            Mediatek proprietary algorithm
+ *
+ * @ltmso_buf:  The buffer for ltm statistic hardware output. The buffer size
+ *    is defined in MTK_CAM_UAPI_LTMSO_SIZE.
+ * @blk_num_x: block number of horizontal direction
+ * @blk_num_y:  block number of vertical direction
+ *
+ * For Mediatek proprietary algorithm
+ */
+struct mtk_cam_uapi_ltm_stats {
+	struct mtk_cam_uapi_meta_hw_buf ltmso_buf;
+	__u8  blk_num_x;
+	__u8  blk_num_y;
+};
+
+/**
+ * struct mtk_cam_uapi_tnc_stats - Tone2 statistic data for
+ *                 Mediatek proprietary algorithm
+ *
+ * @tncso_buf: The buffer for tnc statistic hardware output. The buffer size
+ *           is defined in MTK_CAM_UAPI_TNCSO_SIZE (680*510*2)
+ */
+struct mtk_cam_uapi_tnc_stats {
+	struct mtk_cam_uapi_meta_hw_buf tncso_buf;
+};
+
+/**
+ * struct mtk_cam_uapi_tnch_stats - Tone3 statistic data for Mediatek
+ *                                  proprietary algorithm
+ *
+ * @tncsho_buf: The buffer for tnch statistic hardware output. The buffer size
+ *           is defined in MTK_CAM_UAPI_TNCSHO_SIZE (1544)
+ */
+struct mtk_cam_uapi_tnch_stats {
+	struct mtk_cam_uapi_meta_hw_buf tncsho_buf;
+};
+
+/**
+ * struct mtk_cam_uapi_tncb_stats - Tone4 statistic data for Mediatek
+ *                                  proprietary algorithm
+ *
+ * @tncsbo_buf: The buffer for tncb statistic hardware output. The buffer size
+ *           is defined in MTK_CAM_UAPI_TNCSBO_SIZE (3888)
+ */
+struct mtk_cam_uapi_tncb_stats {
+	struct mtk_cam_uapi_meta_hw_buf tncsbo_buf;
+};
+
+/**
+ * struct mtk_cam_uapi_tncy_stats - Tone3 statistic data for Mediatek
+ *                                  proprietary algorithm
+ *
+ * @tncsyo_buf: The buffer for tncy statistic hardware output. The buffer size
+ *           is defined in MTK_CAM_UAPI_TNCSYO_SIZE (68)
+ */
+struct mtk_cam_uapi_tncy_stats {
+	struct mtk_cam_uapi_meta_hw_buf tncsyo_buf;
+};
+
+/**
+ * struct mtk_cam_uapi_act_stats - act statistic data for Mediatek
+ *                                  proprietary algorithm
+ *
+ * @actso_buf: The buffer for tncy statistic hardware output. The buffer size
+ *           is defined in MTK_CAM_UAPI_ACTSO_SIZE (768)
+ */
+#define MTK_CAM_UAPI_ACTSO_SIZE (768)
+struct mtk_cam_uapi_act_stats {
+	struct mtk_cam_uapi_meta_hw_buf actso_buf;
+};
+
+
+/**
+ *  V 4 L 2  M E T A  B U F F E R  L A Y O U T
+ */
+
+/*
+ *  struct mtk_cam_uapi_meta_raw_stats_cfg
+ *
+ *  @ae_awb_enable: To indicate if AE and AWB should be enblaed or not. If
+ *        it is 1, it means that we enable the following parts of
+ *        hardware:
+ *        (1) AE/AWB
+ *        (2) aao
+ *        (3) aaho
+ *  @af_enable:     To indicate if AF should be enabled or not. If it is 1,
+ *        it means that the AF and afo is enabled.
+ *  @dgn_enable:    To indicate if dgn module should be enabled or not.
+ *  @flk_enable:    If it is 1, it means flk and flko is enable. If ie is 0,
+ *        both flk and flko is disabled.
+ *  @tsf_enable:    If it is 1, it means tsfs and tsfso is enable. If ie is 0,
+ *        both tsfs and tsfso is disabled.
+ *  @wb_enable:     To indicate if wb module should be enabled or not.
+ *  @pde_enable:    To indicate if pde module should be enabled or not.
+ *  @ae_param:  AE Statistic window config
+ *  @awb_param: AWB statistic configuration control
+ *  @dgn_param: DGN settings
+ *  @flk_param: Flicker statistic configuration
+ *  @tsf_param: tsf statistic configuration
+ *  @wb_param:  WB settings
+ *  @pde_param: pde settings
+ */
+struct mtk_cam_uapi_meta_raw_stats_cfg {
+	__s8 ae_awb_enable;
+	__s8 af_enable;
+	__s8 dgn_enable;
+	__s8 flk_enable;
+	__s8 tsf_enable;
+	__s8 wb_enable;
+	__s8 pde_enable;
+
+	struct mtk_cam_uapi_ae_param ae_param;
+	struct mtk_cam_uapi_awb_param awb_param;
+	struct mtk_cam_uapi_af_param af_param;
+	struct mtk_cam_uapi_dgn_param dgn_param;
+	struct mtk_cam_uapi_flk_param flk_param;
+	struct mtk_cam_uapi_tsf_param tsf_param;
+	struct mtk_cam_uapi_wb_param wb_param;
+	struct mtk_cam_uapi_pde_param pde_param;
+
+	__u8 bytes[1024 * 94];
+};
+
+/**
+ * struct mtk_cam_uapi_meta_raw_stats_0 - capture buffer returns from camsys
+ *    after the frame is done. The buffer are not be pushed the other
+ *    driver such as dip.
+ *
+ * @ae_awb_stats_enabled: indicate that ae_awb_stats is ready or not in
+ *       this buffer
+ * @ltm_stats_enabled:    indicate that ltm_stats is ready or not in
+ *       this buffer
+ * @flk_stats_enabled:    indicate that flk_stats is ready or not in
+ *       this buffer
+ * @tsf_stats_enabled:    indicate that tsf_stats is ready or not in
+ *       this buffer
+ * @pde_stats_enabled:    indicate that pde_stats is ready or not in
+ *       this buffer
+ * @pipeline_config:      the pipeline configuration during processing
+ * @pde_stats: the pde module stats
+ */
+struct mtk_cam_uapi_meta_raw_stats_0 {
+	__u8 ae_awb_stats_enabled;
+	__u8 ltm_stats_enabled;
+	__u8 flk_stats_enabled;
+	__u8 tsf_stats_enabled;
+	__u8 tncy_stats_enabled;
+	__u8 pde_stats_enabled;
+
+	struct mtk_cam_uapi_pipeline_config pipeline_config;
+
+	struct mtk_cam_uapi_ae_awb_stats ae_awb_stats;
+	struct mtk_cam_uapi_ltm_stats ltm_stats;
+	struct mtk_cam_uapi_flk_stats flk_stats;
+	struct mtk_cam_uapi_tsf_stats tsf_stats;
+	struct mtk_cam_uapi_tncy_stats tncy_stats;
+	struct mtk_cam_uapi_pd_stats pde_stats;
+	struct mtk_cam_uapi_timestamp timestamp;
+};
+
+/**
+ * struct mtk_cam_uapi_meta_raw_stats_1 - statistics before frame done
+ *
+ * @af_stats_enabled: indicate that lce_stats is ready or not in this buffer
+ * @af_stats: AF statistics
+ *
+ * Any statistic output put in this structure should be careful.
+ * The meta buffer needs copying overhead to return the buffer before the
+ * all the ISP hardware's processing is finished.
+ */
+struct mtk_cam_uapi_meta_raw_stats_1 {
+	__u8 af_stats_enabled;
+	__u8 af_qbn_r6_enabled;
+	struct mtk_cam_uapi_af_stats af_stats;
+};
+
+/**
+ * struct mtk_cam_uapi_meta_raw_stats_2 - shared statistics buffer
+ *
+ * @act_stats_enabled:  indicate that act_stats is ready or not in this
+ * buffer
+ * @act_stats:  act statistics
+ *
+ * The statistic output in this structure may be pushed to the other
+ * driver such as dip.
+ *
+ */
+struct mtk_cam_uapi_meta_raw_stats_2 {
+	__u8 act_stats_enabled;
+
+	struct mtk_cam_uapi_act_stats act_stats;
+};
+
+/**
+ * struct mtk_cam_uapi_meta_camsv_stats_0 - capture buffer returns from
+ *	 camsys's camsv module after the frame is done. The buffer are
+ *	 not be pushed the other driver such as dip.
+ *
+ * @pd_stats_enabled:	 indicate that pd_stats is ready or not in
+ *			 this buffer
+ */
+struct mtk_cam_uapi_meta_camsv_stats_0 {
+	__u8   pd_stats_enabled;
+
+	struct mtk_cam_uapi_pd_stats pd_stats;
+};
+
+#define MTK_CAM_META_VERSION_MAJOR 2
+#define MTK_CAM_META_VERSION_MINOR 3
+#define MTK_CAM_META_PLATFORM_NAME "isp71"
+#define MTK_CAM_META_CHIP_NAME "mt8188"
+
+
+#endif /* __MTK_CAM_META_H__ */
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam-meta-mt8195.h b/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam-meta-mt8195.h
new file mode 100644
index 0000000000000000000000000000000000000000..1c8384b26b79656ce8897fdd81044207e5347a0d
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam-meta-mt8195.h
@@ -0,0 +1,702 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2022 MediaTek Inc.
+ */
+
+#ifndef __MTK_CAM_META_H__
+#define __MTK_CAM_META_H__
+
+/**
+ * struct mtk_cam_uapi_meta_rect - rect info
+ *
+ * @left: The X coordinate of the left side of the rectangle
+ * @top:  The Y coordinate of the left side of the rectangle
+ * @width:  The width of the rectangle
+ * @height: The height of the rectangle
+ *
+ * rect containing the width and height fields.
+ *
+ */
+struct mtk_cam_uapi_meta_rect {
+	__s32 left;
+	__s32 top;
+	__u32 width;
+	__u32 height;
+};
+
+/**
+ * struct mtk_cam_uapi_meta_size - size info
+ *
+ * @width:  The width of the size
+ * @height: The height of the size
+ *
+ * size containing the width and height fields.
+ *
+ */
+struct mtk_cam_uapi_meta_size {
+	__u32 width;
+	__u32 height;
+};
+
+/**
+ *  A U T O  E X P O S U R E
+ */
+
+/*
+ *  struct mtk_cam_uapi_ae_hist_cfg - histogram info for AE
+ *
+ *  @hist_en:    enable bit for current histogram, each histogram can
+ *      be 0/1 (disabled/enabled) separately
+ *  @hist_opt:   color mode config for current histogram (0/1/2/3/4:
+ *      R/G/B/RGB mix/Y)
+ *  @hist_bin:   bin mode config for current histogram (1/4: 256/1024 bin)
+ *  @hist_y_hi:  ROI Y range high bound for current histogram
+ *  @hist_y_low: ROI Y range low bound for current histogram
+ *  @hist_x_hi:  ROI X range high bound for current histogram
+ *  @hist_x_low: ROI X range low bound for current histogram
+ */
+struct mtk_cam_uapi_ae_hist_cfg {
+	__s32 hist_en;
+	__u8 hist_opt;
+	__u8 hist_bin;
+	__u16 hist_y_hi;
+	__u16 hist_y_low;
+	__u16 hist_x_hi;
+	__u16 hist_x_low;
+};
+
+#define MTK_CAM_UAPI_ROI_MAP_BLK_NUM (128*128)
+/*
+ *  struct mtk_cam_uapi_ae_param - parameters for AE configurtion
+ *
+ *  @pixel_hist_win_cfg_le: window config for le histogram 0~5
+ *           separately, uAEHistBin shold be the same
+ *           for these 6 histograms
+ *  @pixel_hist_win_cfg_se: window config for se histogram 0~5
+ *           separately, uAEHistBin shold be the same
+ *           for these 6 histograms
+ *  @roi_hist_cfg_le : config for roi le histogram 0~3
+ *           color mode/enable
+ *  @roi_hist_cfg_se : config for roi se histogram 0~3
+ *           color mode/enable
+ *  @hdr_ratio: in HDR scenario, AE calculated hdr ratio
+ *           (LE exp*iso/SE exp*iso*100) for current frame,
+ *           default non-HDR scenario ratio=1000
+ */
+struct mtk_cam_uapi_ae_param {
+	struct mtk_cam_uapi_ae_hist_cfg pixel_hist_win_cfg_le[6];
+	struct mtk_cam_uapi_ae_hist_cfg pixel_hist_win_cfg_se[6];
+	struct mtk_cam_uapi_ae_hist_cfg roi_hist_cfg_le[4];
+	struct mtk_cam_uapi_ae_hist_cfg roi_hist_cfg_se[4];
+	__u8  aai_r1_enable;
+	__u8  aai_roi_map[MTK_CAM_UAPI_ROI_MAP_BLK_NUM];
+	__u16 hdr_ratio; /* base 1 x= 1000 */
+	__u32 act_win_x_start;
+	__u32 act_win_x_end;
+	__u32 act_win_y_start;
+	__u32 act_win_y_end;
+};
+
+/**
+ *  A U T O  W H I T E  B A L A N C E
+ */
+
+/* Maximum blocks that Mediatek AWB supports */
+#define MTK_CAM_UAPI_AWB_MAX_LIGHT_AREA_NUM (10)
+
+/*
+ *  struct mtk_cam_uapi_awb_param - parameters for AWB configurtion
+ *
+ *  @stat_en:                  AWB stat enable
+ *  @windownum_x:              Number of horizontal AWB windows
+ *  @windownum_y:              Number of vertical AWB windows
+ *  @lowthreshold_r:           Low threshold of R
+ *  @lowthreshold_g:           Low threshold of G
+ *  @lowthreshold_b:           Low threshold of B
+ *  @highthreshold_r:          High threshold of R
+ *  @highthreshold_g:          High threshold of G
+ *  @highthreshold_b:          High threshold of B
+ *  @lightsrc_lowthreshold_r:  Low threshold of R for light source estimation
+ *  @lightsrc_lowthreshold_g:  Low threshold of G for light source estimation
+ *  @lightsrc_lowthreshold_b:  Low threshold of B for light source estimation
+ *  @lightsrc_highthreshold_r: High threshold of R for light source estimation
+ *  @lightsrc_highthreshold_g: High threshold of G for light source estimation
+ *  @lightsrc_highthreshold_b: High threshold of B for light source estimation
+ *  @pregainlimit_r:           Maximum limit clipping for R color
+ *  @pregainlimit_g:           Maximum limit clipping for G color
+ *  @pregainlimit_b:           Maximum limit clipping for B color
+ *  @pregain_r:                unit module compensation gain for R color
+ *  @pregain_g:                unit module compensation gain for G color
+ *  @pregain_b:                unit module compensation gain for B color
+ *  @valid_datawidth:          valid bits of statistic data
+ *  @hdr_support_en:           support HDR mode
+ *  @stat_mode:                Output format select <1>sum mode <0>average mode
+ *  @error_ratio:              Programmable error pixel count by AWB window size
+ *              (base : 256)
+ *  @awbxv_win_r:              light area of right bound, the size is defined in
+ *              MTK_CAM_UAPI_AWB_MAX_LIGHT_AREA_NUM
+ *  @awbxv_win_l:              light area of left bound the size is defined in
+ *              MTK_CAM_UAPI_AWB_MAX_LIGHT_AREA_NUM
+ *  @awbxv_win_d:              light area of lower bound the size is defined in
+ *              MTK_CAM_UAPI_AWB_MAX_LIGHT_AREA_NUM
+ *  @awbxv_win_u:              light area of upper bound the size is defined in
+ *              MTK_CAM_UAPI_AWB_MAX_LIGHT_AREA_NUM
+ *  @pregain2_r:               white balance gain of R color
+ *  @pregain2_g:               white balance gain of G color
+ *  @pregain2_b:               white balance gain of B color
+ */
+struct mtk_cam_uapi_awb_param {
+	__u32 stat_en;
+	__u32 windownum_x;
+	__u32 windownum_y;
+	__u32 lowthreshold_r;
+	__u32 lowthreshold_g;
+	__u32 lowthreshold_b;
+	__u32 highthreshold_r;
+	__u32 highthreshold_g;
+	__u32 highthreshold_b;
+	__u32 lightsrc_lowthreshold_r;
+	__u32 lightsrc_lowthreshold_g;
+	__u32 lightsrc_lowthreshold_b;
+	__u32 lightsrc_highthreshold_r;
+	__u32 lightsrc_highthreshold_g;
+	__u32 lightsrc_highthreshold_b;
+	__u32 pregainlimit_r;
+	__u32 pregainlimit_g;
+	__u32 pregainlimit_b;
+	__u32 pregain_r;
+	__u32 pregain_g;
+	__u32 pregain_b;
+	__u32 valid_datawidth;
+	__u32 hdr_support_en;
+	__u32 stat_mode;
+	__u32 format_shift;
+	__u32 error_ratio;
+	__u32 postgain_r;
+	__u32 postgain_g;
+	__u32 postgain_b;
+	__u32 postgain2_hi_r;
+	__u32 postgain2_hi_g;
+	__u32 postgain2_hi_b;
+	__u32 postgain2_med_r;
+	__u32 postgain2_med_g;
+	__u32 postgain2_med_b;
+	__u32 postgain2_low_r;
+	__u32 postgain2_low_g;
+	__u32 postgain2_low_b;
+	__s32 awbxv_win_r[MTK_CAM_UAPI_AWB_MAX_LIGHT_AREA_NUM];
+	__s32 awbxv_win_l[MTK_CAM_UAPI_AWB_MAX_LIGHT_AREA_NUM];
+	__s32 awbxv_win_d[MTK_CAM_UAPI_AWB_MAX_LIGHT_AREA_NUM];
+	__s32 awbxv_win_u[MTK_CAM_UAPI_AWB_MAX_LIGHT_AREA_NUM];
+	__u32 csc_ccm[9];
+	__u32 acc;
+	__u32 med_region[4];
+	__u32 low_region[4];
+	__u32 pregain2_r;
+	__u32 pregain2_g;
+	__u32 pregain2_b;
+};
+
+/*
+ * struct mtk_cam_uapi_dgn_param
+ *
+ *  @gain: digital gain to increase image brightness, 1 x= 1024
+ */
+struct mtk_cam_uapi_dgn_param {
+	__u32 gain;
+};
+
+/*
+ * struct mtk_cam_uapi_wb_param
+ *
+ *  @gain_r: white balance gain of R channel
+ *  @gain_g: white balance gain of G channel
+ *  @gain_b: white balance gain of B channel
+ */
+struct mtk_cam_uapi_wb_param {
+	__u32 gain_r;
+	__u32 gain_g;
+	__u32 gain_b;
+	__u32 clip;
+};
+
+/**
+ *  A U T O  F O C U S
+ */
+
+/**
+ * struct mtk_cam_uapi_af_param - af statistic parameters
+ *  @roi: AF roi rectangle (in pixel) for AF statistic covered, including
+ *    x, y, width, height
+ *  @th_sat_g:  green channel pixel value saturation threshold (0~255)
+ *  @th_h[3]: horizontal AF filters response threshold (0~50) for H0, H1,
+ *    and H2
+ *  @th_v:  vertical AF filter response threshold (0~50)
+ *  @blk_pixel_xnum: horizontal number of pixel per block
+ *  @blk_pixel_ynum: vertical number of pixel per block
+ *  @fir_type: to select FIR filter by AF target type (0,1,2,3)
+ *  @iir_type: to select IIR filter by AF target type (0,1,2,3)
+ *  @data_gain[7]: gamma curve gain for AF source data
+ */
+struct mtk_cam_uapi_af_param {
+	struct mtk_cam_uapi_meta_rect roi;
+	__u32 th_sat_g;
+	__u32 th_h[3];
+	__u32 th_v;
+	__u32 blk_pixel_xnum;
+	__u32 blk_pixel_ynum;
+	__u32 fir_type;
+	__u32 iir_type;
+	__u32 data_gain[7];
+};
+
+enum mtk_cam_uapi_flk_hdr_path_control {
+	MTKCAM_UAPI_FKLO_HDR_1ST_FRAME = 0,
+	MTKCAM_UAPI_FKLO_HDR_2ND_FRAME,
+	MTKCAM_UAPI_FKLO_HDR_3RD_FRAME,
+};
+
+/*
+ *  struct mtk_cam_uapi_flk_param
+ *
+ *  @input_bit_sel: maximum pixel value of flicker statistic input
+ *  @offset_y: initial position for flicker statistic calculation in y direction
+ *  @crop_y: number of rows which will be cropped from bottom
+ *  @sgg_val[8]: Simple Gain and Gamma for noise reduction, sgg_val[0] is
+ *               gain and sgg_val[1] - sgg_val[7] are gamma table
+ *  @noise_thr: the noise threshold of pixel value, pixel value lower than
+ *              this value is considered as noise
+ *  @saturate_thr: the saturation threshold of pixel value, pixel value
+ *                 higher than this value is considered as saturated
+ *  @hdr_flk_src: flk source tap point selection
+ */
+struct mtk_cam_uapi_flk_param {
+	__u32 input_bit_sel;
+	__u32 offset_y;
+	__u32 crop_y;
+	__u32 sgg_val[8];
+	__u32 noise_thr;
+	__u32 saturate_thr;
+	__u32 hdr_flk_src;
+};
+
+/*
+ * struct mtk_cam_uapi_tsf_param
+ *
+ *  @horizontal_num: block number of horizontal direction
+ *  @vertical_num:   block number of vertical direction
+ */
+struct mtk_cam_uapi_tsf_param {
+	__u32 horizontal_num;
+	__u32 vertical_num;
+};
+
+/*
+ * struct mtk_cam_uapi_pde_param
+ *
+ * @pdi_max_size: the max required memory size for pd table
+ * @pdo_max_size: the max required memory size for pd point output
+ * @pdo_x_size: the pd points out x size
+ * @pdo_y_size: the pd points out y size
+ * @pd_table_offset: the offset of pd table in the meta_cfg
+ */
+struct mtk_cam_uapi_pde_param {
+	__u32 pdi_max_size;
+	__u32 pdo_max_size;
+	__u32 pdo_x_size;
+	__u32 pdo_y_size;
+	__u32 pd_table_offset;
+};
+
+/**
+ * Common stuff for all statistics
+ */
+
+/**
+ * struct mtk_cam_uapi_meta_hw_buf - hardware buffer info
+ *
+ * @offset: offset from the start of the device memory associated to the
+ *    v4l2 meta buffer
+ * @size: size of the buffer
+ *
+ * Some part of the meta buffers are read or written by statistic related
+ * hardware DMAs. The hardware buffers may have different size among
+ * difference pipeline.
+ */
+struct mtk_cam_uapi_meta_hw_buf {
+	__u32 offset;
+	__u32 size;
+};
+
+#define MTK_CAM_UAPI_MAX_CORE_NUM (2)
+
+/**
+ * struct mtk_cam_uapi_pipeline_config - pipeline configuration
+ *
+ * @num_of_core: The number of isp cores
+ */
+struct mtk_cam_uapi_pipeline_config {
+	__u32	num_of_core;
+	struct	mtk_cam_uapi_meta_size core_data_size;
+	__u32	core_pxl_mode_lg2;
+};
+
+/**
+ *  A U T O  E X P O S U R E
+ */
+
+/* TODO: Need to check the size of MTK_CAM_AE_HIST_MAX_BIN*/
+#define MTK_CAM_UAPI_AE_STATS_HIST_MAX_BIN (1024)
+
+/**
+ *  A E  A N D   A W B
+ */
+
+#define MTK_CAM_UAPI_AAO_BLK_SIZE (32)
+#define MTK_CAM_UAPI_AAO_MAX_BLK_X (128)
+#define MTK_CAM_UAPI_AAO_MAX_BLK_Y (128)
+#define MTK_CAM_UAPI_AAO_MAX_BUF_SIZE (MTK_CAM_UAPI_AAO_BLK_SIZE \
+					* MTK_CAM_UAPI_AAO_MAX_BLK_X \
+					* MTK_CAM_UAPI_AAO_MAX_BLK_Y)
+
+#define MTK_CAM_UAPI_AHO_BLK_SIZE (3)
+#define MTK_CAM_UAPI_AAHO_HIST_SIZE  (6 * 1024 * MTK_CAM_UAPI_AHO_BLK_SIZE \
+					+ 14 * 256 * MTK_CAM_UAPI_AHO_BLK_SIZE)
+#define MTK_CAM_UAPI_AAHO_MAX_BUF_SIZE  (MTK_CAM_UAPI_MAX_CORE_NUM * \
+					MTK_CAM_UAPI_AAHO_HIST_SIZE)
+
+/**
+ * struct mtk_cam_uapi_ae_awb_stats - statistics of ae and awb
+ *
+ * @aao_buf:       The buffer for AAHO statistic hardware output.
+ *        The maximum size of the buffer is defined with
+ *        MTK_CAM_UAPI_AAO_MAX_BUF_SIZE
+ * @aaho_buf:      The buffer for AAHO statistic hardware output.
+ *        The maximum size of the buffer is defined with
+ *        MTK_CAM_UAPI_AAHO_MAX_BUF_SIZE.
+ *
+ * This is the AE and AWB statistic returned to user. From  our hardware's
+ * point of view, we can't separate the AE and AWB output result, so I use
+ * a struct to retutn them.
+ */
+struct mtk_cam_uapi_ae_awb_stats {
+	__u32 awb_stat_en_status;
+	__u32 awb_qbn_acc;
+	__u32 ae_stat_en_status;
+	struct mtk_cam_uapi_meta_hw_buf aao_buf;
+	struct mtk_cam_uapi_meta_hw_buf aaho_buf;
+};
+
+/**
+ *  A U T O  F O C U S
+ */
+
+#define MTK_CAM_UAPI_AFO_BLK_SIZ    (32)
+#define MTK_CAM_UAPI_AFO_MAX_BLK_NUM (128 * 128)
+#define MTK_CAM_UAPI_AFO_MAX_BUF_SIZE   (MTK_CAM_UAPI_AFO_BLK_SIZ \
+						* MTK_CAM_UAPI_AFO_MAX_BLK_NUM)
+
+/**
+ * struct mtk_cam_uapi_af_stats - af statistics
+ *
+ * @blk_num_x: block number of horizontal direction
+ * @blk_num_y: block number of vertical direction
+ * @afo_buf:    the buffer for AAHO statistic hardware output. The maximum
+ *      size of the buffer is defined with
+ *      MTK_CAM_UAPI_AFO_MAX_BUF_SIZE.
+ */
+struct mtk_cam_uapi_af_stats {
+	__u32 blk_num_x;
+	__u32 blk_num_y;
+	struct mtk_cam_uapi_meta_hw_buf afo_buf;
+};
+
+/**
+ *  F L I C K E R
+ */
+
+/* FLK's hardware output block size: 64 bits */
+#define MTK_CAM_UAPI_FLK_BLK_SIZE (8)
+
+/* Maximum block size (each line) of Mediatek flicker statistic */
+#define MTK_CAM_UAPI_FLK_MAX_STAT_BLK_NUM (6)
+
+/* Maximum height (in pixel) that driver can support */
+#define MTK_CAM_UAPI_FLK_MAX_FRAME_HEIGHT (6000)
+#define MTK_CAM_UAPI_FLK_MAX_BUF_SIZE                              \
+	(MTK_CAM_UAPI_FLK_BLK_SIZE * MTK_CAM_UAPI_FLK_MAX_STAT_BLK_NUM * \
+	MTK_CAM_UAPI_FLK_MAX_FRAME_HEIGHT)
+
+/**
+ * struct mtk_cam_uapi_flk_stats
+ *
+ * @flko_buf: the buffer for FLKO statistic hardware output. The maximum
+ *         size of the buffer is defined with MTK_CAM_UAPI_FLK_MAX_BUF_SIZE.
+ */
+struct mtk_cam_uapi_flk_stats {
+	struct mtk_cam_uapi_meta_hw_buf flko_buf;
+};
+
+/**
+ *  T S F
+ */
+
+#define MTK_CAM_UAPI_TSFSO_SIZE (40 * 30 * 3 * 4)
+
+/**
+ * struct mtk_cam_uapi_tsf_stats - TSF statistic data
+ *
+ * @tsfo_buf: The buffer for tsf statistic hardware output. The buffer size
+ *        is defined in MTK_CAM_UAPI_TSFSO_SIZE.
+ *
+ * This output is for Mediatek proprietary algorithm
+ */
+struct mtk_cam_uapi_tsf_stats {
+	struct mtk_cam_uapi_meta_hw_buf tsfo_r1_buf;
+	struct mtk_cam_uapi_meta_hw_buf tsfo_r2_buf;
+};
+
+/**
+ * struct mtk_cam_uapi_pd_stats - statistics of pd
+ *
+ * @stats_src:     source width and heitgh of the statistics.
+ * @stride:	   stride value used by
+ * @pdo_buf:	   The buffer for PD statistic hardware output.
+ *
+ * This is the PD statistic returned to user.
+ */
+struct mtk_cam_uapi_pd_stats {
+	struct	mtk_cam_uapi_meta_size stats_src;
+	__u32	stride;
+	struct	mtk_cam_uapi_meta_hw_buf pdo_buf;
+};
+
+struct mtk_cam_uapi_timestamp {
+	__u64 timestamp_buf[128];
+};
+
+/**
+ *  T O N E
+ */
+#define MTK_CAM_UAPI_LTMSO_SIZE ((70*12*9 + 514) * 4)
+#define MTK_CAM_UAPI_TNCSO_SIZE (680*510*2)
+#define MTK_CAM_UAPI_TNCSHO_SIZE (1544)
+#define MTK_CAM_UAPI_TNCSBO_SIZE (3888)
+#define MTK_CAM_UAPI_TNCSYO_SIZE (68)
+
+/**
+ * struct mtk_cam_uapi_ltm_stats - Tone1 statistic data for
+ *            Mediatek proprietary algorithm
+ *
+ * @ltmso_buf:  The buffer for ltm statistic hardware output. The buffer size
+ *    is defined in MTK_CAM_UAPI_LTMSO_SIZE.
+ * @blk_num_x: block number of horizontal direction
+ * @blk_num_y:  block number of vertical direction
+ *
+ * For Mediatek proprietary algorithm
+ */
+struct mtk_cam_uapi_ltm_stats {
+	struct mtk_cam_uapi_meta_hw_buf ltmso_buf;
+	__u8  blk_num_x;
+	__u8  blk_num_y;
+};
+
+/**
+ * struct mtk_cam_uapi_tnc_stats - Tone2 statistic data for
+ *                 Mediatek proprietary algorithm
+ *
+ * @tncso_buf: The buffer for tnc statistic hardware output. The buffer size
+ *           is defined in MTK_CAM_UAPI_TNCSO_SIZE (680*510*2)
+ */
+struct mtk_cam_uapi_tnc_stats {
+	struct mtk_cam_uapi_meta_hw_buf tncso_buf;
+};
+
+/**
+ * struct mtk_cam_uapi_tnch_stats - Tone3 statistic data for Mediatek
+ *                                  proprietary algorithm
+ *
+ * @tncsho_buf: The buffer for tnch statistic hardware output. The buffer size
+ *           is defined in MTK_CAM_UAPI_TNCSHO_SIZE (1544)
+ */
+struct mtk_cam_uapi_tnch_stats {
+	struct mtk_cam_uapi_meta_hw_buf tncsho_buf;
+};
+
+/**
+ * struct mtk_cam_uapi_tncb_stats - Tone4 statistic data for Mediatek
+ *                                  proprietary algorithm
+ *
+ * @tncsbo_buf: The buffer for tncb statistic hardware output. The buffer size
+ *           is defined in MTK_CAM_UAPI_TNCSBO_SIZE (3888)
+ */
+struct mtk_cam_uapi_tncb_stats {
+	struct mtk_cam_uapi_meta_hw_buf tncsbo_buf;
+};
+
+/**
+ * struct mtk_cam_uapi_tncy_stats - Tone3 statistic data for Mediatek
+ *                                  proprietary algorithm
+ *
+ * @tncsyo_buf: The buffer for tncy statistic hardware output. The buffer size
+ *           is defined in MTK_CAM_UAPI_TNCSYO_SIZE (68)
+ */
+struct mtk_cam_uapi_tncy_stats {
+	struct mtk_cam_uapi_meta_hw_buf tncsyo_buf;
+};
+
+/**
+ * struct mtk_cam_uapi_act_stats - act statistic data for Mediatek
+ *                                  proprietary algorithm
+ *
+ * @actso_buf: The buffer for tncy statistic hardware output. The buffer size
+ *           is defined in MTK_CAM_UAPI_ACTSO_SIZE (768)
+ */
+#define MTK_CAM_UAPI_ACTSO_SIZE (768)
+struct mtk_cam_uapi_act_stats {
+	struct mtk_cam_uapi_meta_hw_buf actso_buf;
+};
+
+
+/**
+ *  V 4 L 2  M E T A  B U F F E R  L A Y O U T
+ */
+
+/*
+ *  struct mtk_cam_uapi_meta_raw_stats_cfg
+ *
+ *  @ae_awb_enable: To indicate if AE and AWB should be enblaed or not. If
+ *        it is 1, it means that we enable the following parts of
+ *        hardware:
+ *        (1) AE/AWB
+ *        (2) aao
+ *        (3) aaho
+ *  @af_enable:     To indicate if AF should be enabled or not. If it is 1,
+ *        it means that the AF and afo is enabled.
+ *  @dgn_enable:    To indicate if dgn module should be enabled or not.
+ *  @flk_enable:    If it is 1, it means flk and flko is enable. If ie is 0,
+ *        both flk and flko is disabled.
+ *  @tsf_enable:    If it is 1, it means tsfs and tsfso is enable. If ie is 0,
+ *        both tsfs and tsfso is disabled.
+ *  @wb_enable:     To indicate if wb module should be enabled or not.
+ *  @pde_enable:    To indicate if pde module should be enabled or not.
+ *  @ae_param:  AE Statistic window config
+ *  @awb_param: AWB statistic configuration control
+ *  @dgn_param: DGN settings
+ *  @flk_param: Flicker statistic configuration
+ *  @tsf_param: tsf statistic configuration
+ *  @wb_param:  WB settings
+ *  @pde_param: pde settings
+ */
+struct mtk_cam_uapi_meta_raw_stats_cfg {
+	__s8 ae_awb_enable;
+	__s8 af_enable;
+	__s8 dgn_enable;
+	__s8 flk_enable;
+	__s8 tsf_enable;
+	__s8 wb_enable;
+	__s8 pde_enable;
+
+	struct mtk_cam_uapi_ae_param ae_param;
+	struct mtk_cam_uapi_awb_param awb_param;
+	struct mtk_cam_uapi_af_param af_param;
+	struct mtk_cam_uapi_dgn_param dgn_param;
+	struct mtk_cam_uapi_flk_param flk_param;
+	struct mtk_cam_uapi_tsf_param tsf_param;
+	struct mtk_cam_uapi_wb_param wb_param;
+	struct mtk_cam_uapi_pde_param pde_param;
+
+	__u8 bytes[1024 * 94];
+};
+
+/**
+ * struct mtk_cam_uapi_meta_raw_stats_0 - capture buffer returns from camsys
+ *    after the frame is done. The buffer are not be pushed the other
+ *    driver such as dip.
+ *
+ * @ae_awb_stats_enabled: indicate that ae_awb_stats is ready or not in
+ *       this buffer
+ * @ltm_stats_enabled:    indicate that ltm_stats is ready or not in
+ *       this buffer
+ * @flk_stats_enabled:    indicate that flk_stats is ready or not in
+ *       this buffer
+ * @tsf_stats_enabled:    indicate that tsf_stats is ready or not in
+ *       this buffer
+ * @pde_stats_enabled:    indicate that pde_stats is ready or not in
+ *       this buffer
+ * @pipeline_config:      the pipeline configuration during processing
+ * @pde_stats: the pde module stats
+ */
+struct mtk_cam_uapi_meta_raw_stats_0 {
+	__u8 ae_awb_stats_enabled;
+	__u8 ltm_stats_enabled;
+	__u8 flk_stats_enabled;
+	__u8 tsf_stats_enabled;
+	__u8 tncy_stats_enabled;
+	__u8 pde_stats_enabled;
+
+	struct mtk_cam_uapi_pipeline_config pipeline_config;
+
+	struct mtk_cam_uapi_ae_awb_stats ae_awb_stats;
+	struct mtk_cam_uapi_ltm_stats ltm_stats;
+	struct mtk_cam_uapi_flk_stats flk_stats;
+	struct mtk_cam_uapi_tsf_stats tsf_stats;
+	struct mtk_cam_uapi_tncy_stats tncy_stats;
+	struct mtk_cam_uapi_pd_stats pde_stats;
+	struct mtk_cam_uapi_timestamp timestamp;
+};
+
+/**
+ * struct mtk_cam_uapi_meta_raw_stats_1 - statistics before frame done
+ *
+ * @af_stats_enabled: indicate that lce_stats is ready or not in this buffer
+ * @af_stats: AF statistics
+ *
+ * Any statistic output put in this structure should be careful.
+ * The meta buffer needs copying overhead to return the buffer before the
+ * all the ISP hardware's processing is finished.
+ */
+struct mtk_cam_uapi_meta_raw_stats_1 {
+	__u8 af_stats_enabled;
+	__u8 af_qbn_r6_enabled;
+	struct mtk_cam_uapi_af_stats af_stats;
+};
+
+/**
+ * struct mtk_cam_uapi_meta_raw_stats_2 - shared statistics buffer
+ *
+ * @act_stats_enabled:  indicate that act_stats is ready or not in this
+ * buffer
+ * @act_stats:  act statistics
+ *
+ * The statistic output in this structure may be pushed to the other
+ * driver such as dip.
+ *
+ */
+struct mtk_cam_uapi_meta_raw_stats_2 {
+	__u8 act_stats_enabled;
+
+	struct mtk_cam_uapi_act_stats act_stats;
+};
+
+/**
+ * struct mtk_cam_uapi_meta_camsv_stats_0 - capture buffer returns from
+ *	 camsys's camsv module after the frame is done. The buffer are
+ *	 not be pushed the other driver such as dip.
+ *
+ * @pd_stats_enabled:	 indicate that pd_stats is ready or not in
+ *			 this buffer
+ */
+struct mtk_cam_uapi_meta_camsv_stats_0 {
+	__u8   pd_stats_enabled;
+
+	struct mtk_cam_uapi_pd_stats pd_stats;
+};
+
+#define MTK_CAM_META_VERSION_MAJOR 2
+#define MTK_CAM_META_VERSION_MINOR 16
+#define MTK_CAM_META_PLATFORM_NAME "isp70"
+#define MTK_CAM_META_CHIP_NAME "mt8195"
+
+
+#endif /* __MTK_CAM_META_H__ */
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam-plat-mt8188.c b/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam-plat-mt8188.c
new file mode 100644
index 0000000000000000000000000000000000000000..41b1424d9fc863bf69b8e62102dc95eb7da7efa7
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam-plat-mt8188.c
@@ -0,0 +1,221 @@
+// SPDX-License-Identifier: GPL-2.0
+//
+// Copyright (c) 2022 MediaTek Inc.
+
+#include <linux/module.h>
+#include <linux/init.h>
+
+#include "mtk_cam.h"
+#include "mtk_cam-raw.h"
+#include "mtk_cam-video.h"
+#include "mtk_cam-plat-util.h"
+#include "mtk_cam-meta-mt8188.h"
+
+#define RAW_STATS_CFG_SIZE \
+	ALIGN(sizeof(struct mtk_cam_uapi_meta_raw_stats_cfg), SZ_1K)
+
+/* meta out max size include 1k meta info and dma buffer size */
+#define RAW_STATS_0_SIZE \
+	ALIGN(ALIGN(sizeof(struct mtk_cam_uapi_meta_raw_stats_0), SZ_1K) + \
+	      MTK_CAM_UAPI_AAO_MAX_BUF_SIZE + MTK_CAM_UAPI_AAHO_MAX_BUF_SIZE + \
+	      MTK_CAM_UAPI_LTMSO_SIZE + \
+	      MTK_CAM_UAPI_FLK_MAX_BUF_SIZE + \
+	      MTK_CAM_UAPI_TSFSO_SIZE * 2 + /* r1 & r2 */ \
+	      MTK_CAM_UAPI_TNCSYO_SIZE \
+	      , (4 * SZ_1K))
+
+#define RAW_STATS_1_SIZE \
+	ALIGN(ALIGN(sizeof(struct mtk_cam_uapi_meta_raw_stats_1), SZ_1K) + \
+	      MTK_CAM_UAPI_AFO_MAX_BUF_SIZE, (4 * SZ_1K))
+
+#define RAW_STATS_2_SIZE \
+	ALIGN(ALIGN(sizeof(struct mtk_cam_uapi_meta_raw_stats_2), SZ_1K) + \
+	      MTK_CAM_UAPI_ACTSO_SIZE, (4 * SZ_1K))
+
+#define SV_STATS_0_SIZE \
+	sizeof(struct mtk_cam_uapi_meta_camsv_stats_0)
+
+/* FIXME for ISP6 meta format */
+static const struct mtk_cam_format_desc meta_fmts[] = {
+	{
+		.vfmt.fmt.meta = {
+			.dataformat = V4L2_META_FMT_MTISP_PARAMS,
+			.buffersize = RAW_STATS_CFG_SIZE,
+		},
+	},
+	{
+		.vfmt.fmt.meta = {
+			.dataformat = V4L2_META_FMT_MTISP_3A,
+			.buffersize = RAW_STATS_0_SIZE,
+		},
+	},
+	{
+		.vfmt.fmt.meta = {
+			.dataformat = V4L2_META_FMT_MTISP_AF,
+			.buffersize = RAW_STATS_1_SIZE,
+		},
+	},
+	{
+		.vfmt.fmt.meta = {
+			.dataformat = V4L2_META_FMT_MTISP_LCS,
+			.buffersize = RAW_STATS_2_SIZE,
+		},
+	},
+};
+
+static void set_payload(struct mtk_cam_uapi_meta_hw_buf *buf,
+			unsigned int size, unsigned long *offset)
+{
+	buf->offset = *offset;
+	buf->size = size;
+	*offset += size;
+}
+
+static uint64_t *camsys_get_timestamp_addr(void *vaddr)
+{
+	struct mtk_cam_uapi_meta_raw_stats_0 *stats0;
+
+	stats0 = (struct mtk_cam_uapi_meta_raw_stats_0 *)vaddr;
+	return (uint64_t *)(stats0->timestamp.timestamp_buf);
+}
+
+static void camsys_set_meta_stats_info(u32 dma_port, void *vaddr,
+				 struct mtk_raw_pde_config *pde_cfg)
+{
+	struct mtk_cam_uapi_meta_raw_stats_0 *stats0;
+	struct mtk_cam_uapi_meta_raw_stats_1 *stats1;
+	unsigned long offset;
+
+	switch (dma_port) {
+	case MTKCAM_IPI_RAW_META_STATS_0:
+		stats0 = (struct mtk_cam_uapi_meta_raw_stats_0 *)vaddr;
+		offset = sizeof(*stats0);
+		set_payload(&stats0->ae_awb_stats.aao_buf, MTK_CAM_UAPI_AAO_MAX_BUF_SIZE, &offset);
+		set_payload(&stats0->ae_awb_stats.aaho_buf,
+			MTK_CAM_UAPI_AAHO_MAX_BUF_SIZE, &offset);
+		set_payload(&stats0->ltm_stats.ltmso_buf, MTK_CAM_UAPI_LTMSO_SIZE, &offset);
+		set_payload(&stats0->flk_stats.flko_buf, MTK_CAM_UAPI_FLK_MAX_BUF_SIZE, &offset);
+		set_payload(&stats0->tsf_stats.tsfo_r1_buf, MTK_CAM_UAPI_TSFSO_SIZE, &offset);
+		set_payload(&stats0->tsf_stats.tsfo_r2_buf, MTK_CAM_UAPI_TSFSO_SIZE, &offset);
+		set_payload(&stats0->tncy_stats.tncsyo_buf, MTK_CAM_UAPI_TNCSYO_SIZE, &offset);
+		if (pde_cfg) {
+			if (pde_cfg->pde_info.pd_table_offset) {
+				set_payload(&stats0->pde_stats.pdo_buf,
+					    pde_cfg->pde_info.pdo_max_size,
+					    &offset);
+			}
+		}
+		break;
+	case MTKCAM_IPI_RAW_META_STATS_1:
+		stats1 = (struct mtk_cam_uapi_meta_raw_stats_1 *)vaddr;
+		offset = sizeof(*stats1);
+		set_payload(&stats1->af_stats.afo_buf, MTK_CAM_UAPI_AFO_MAX_BUF_SIZE, &offset);
+		break;
+	case MTKCAM_IPI_RAW_META_STATS_2:
+		//todo
+		pr_info("stats 2 not support");
+		break;
+	default:
+		pr_debug("%s: dma_port err\n", __func__);
+		break;
+	}
+}
+
+static void camsys_sv_set_meta_stats_info(
+	u32 dma_port, void *vaddr, unsigned int width,
+	unsigned int height, unsigned int stride)
+{
+	struct mtk_cam_uapi_meta_camsv_stats_0 *sv_stats0;
+	unsigned long offset;
+	unsigned int size;
+
+	switch (dma_port) {
+	case MTKCAM_IPI_CAMSV_MAIN_OUT:
+		size = stride * height;
+		sv_stats0 = (struct mtk_cam_uapi_meta_camsv_stats_0 *)vaddr;
+		offset = sizeof(*sv_stats0);
+		set_payload(&sv_stats0->pd_stats.pdo_buf, size, &offset);
+		sv_stats0->pd_stats_enabled = 1;
+		sv_stats0->pd_stats.stats_src.width = width;
+		sv_stats0->pd_stats.stats_src.height = height;
+		sv_stats0->pd_stats.stride = stride;
+		break;
+	default:
+		pr_debug("%s: dma_port err\n", __func__);
+		break;
+	}
+}
+
+static int camsys_get_meta_version(bool major)
+{
+	if (major)
+		return MTK_CAM_META_VERSION_MAJOR;
+	else
+		return MTK_CAM_META_VERSION_MINOR;
+}
+
+static int camsys_get_meta_size(u32 video_id)
+{
+	switch (video_id) {
+	case MTKCAM_IPI_RAW_META_STATS_CFG:
+		return RAW_STATS_CFG_SIZE;
+	case MTKCAM_IPI_RAW_META_STATS_0:
+		return RAW_STATS_0_SIZE;
+	case MTKCAM_IPI_RAW_META_STATS_1:
+		return RAW_STATS_1_SIZE;
+	case MTKCAM_IPI_RAW_META_STATS_2:
+		return RAW_STATS_2_SIZE;
+	case MTKCAM_IPI_CAMSV_MAIN_OUT:
+		return SV_STATS_0_SIZE;
+	default:
+		pr_debug("%s: no support stats(%d)\n", __func__, video_id);
+	}
+	return 0;
+}
+
+static const struct mtk_cam_format_desc *camsys_get_meta_fmts(void)
+{
+	return meta_fmts;
+}
+
+static int camsys_get_port_bw(
+	enum MMQOS_PORT port, unsigned long height, unsigned long fps)
+{
+	switch (port) {
+	case AAO:
+		return (MTK_CAM_UAPI_AAO_MAX_BUF_SIZE + MTK_CAM_UAPI_AFO_MAX_BUF_SIZE) * fps;
+	case AAHO:
+		return MTK_CAM_UAPI_AAHO_HIST_SIZE * fps;
+	case TSFSO:
+		return (MTK_CAM_UAPI_TSFSO_SIZE * 2 + MTK_CAM_UAPI_LTMSO_SIZE) * fps;
+	case FLKO:
+		return MTK_CAM_UAPI_FLK_BLK_SIZE * MTK_CAM_UAPI_FLK_MAX_STAT_BLK_NUM * height * fps;
+	default:
+		pr_debug("%s: no support port(%d)\n", __func__, port);
+	}
+
+	return 0;
+}
+
+static struct camsys_plat_fp plat_fp = {
+	.get_meta_version = camsys_get_meta_version,
+	.get_meta_size = camsys_get_meta_size,
+	.get_meta_fmts = camsys_get_meta_fmts,
+	.set_meta_stats_info = camsys_set_meta_stats_info,
+	.set_sv_meta_stats_info = camsys_sv_set_meta_stats_info,
+	.get_port_bw = camsys_get_port_bw,
+	.get_timestamp_addr = camsys_get_timestamp_addr,
+};
+
+static int __init plat_module_init(void)
+{
+	pr_info("plat init\n");
+
+	mtk_cam_set_plat_util(&plat_fp);
+
+	return 0;
+}
+
+module_init(plat_module_init);
+MODULE_DESCRIPTION("Mediatek Camsys plat driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam-plat-mt8195.c b/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam-plat-mt8195.c
new file mode 100644
index 0000000000000000000000000000000000000000..0ebfd16c0cd509468a8e63b1035825a1825705e8
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam-plat-mt8195.c
@@ -0,0 +1,222 @@
+// SPDX-License-Identifier: GPL-2.0
+//
+// Copyright (c) 2022 MediaTek Inc.
+
+#include <linux/module.h>
+#include <linux/init.h>
+
+#include "mtk_cam.h"
+#include "mtk_cam-raw.h"
+#include "mtk_cam-video.h"
+#include "mtk_cam-plat-util.h"
+#include "mtk_cam-meta-mt8195.h"
+
+#define RAW_STATS_CFG_SIZE \
+	ALIGN(sizeof(struct mtk_cam_uapi_meta_raw_stats_cfg), SZ_1K)
+
+/* meta out max size include 1k meta info and dma buffer size */
+#define RAW_STATS_0_SIZE \
+	ALIGN(ALIGN(sizeof(struct mtk_cam_uapi_meta_raw_stats_0), SZ_1K) + \
+	      MTK_CAM_UAPI_AAO_MAX_BUF_SIZE + MTK_CAM_UAPI_AAHO_MAX_BUF_SIZE + \
+	      MTK_CAM_UAPI_LTMSO_SIZE + \
+	      MTK_CAM_UAPI_FLK_MAX_BUF_SIZE + \
+	      MTK_CAM_UAPI_TSFSO_SIZE * 2 + /* r1 & r2 */ \
+	      MTK_CAM_UAPI_TNCSYO_SIZE \
+	      /* TODO: TNCSO TNCSBO TNCSHO SIZE */ \
+	      , (4 * SZ_1K))
+
+#define RAW_STATS_1_SIZE \
+	ALIGN(ALIGN(sizeof(struct mtk_cam_uapi_meta_raw_stats_1), SZ_1K) + \
+	      MTK_CAM_UAPI_AFO_MAX_BUF_SIZE, (4 * SZ_1K))
+
+#define RAW_STATS_2_SIZE \
+	ALIGN(ALIGN(sizeof(struct mtk_cam_uapi_meta_raw_stats_2), SZ_1K) + \
+	      MTK_CAM_UAPI_ACTSO_SIZE, (4 * SZ_1K))
+
+#define SV_STATS_0_SIZE \
+	sizeof(struct mtk_cam_uapi_meta_camsv_stats_0)
+
+static const struct mtk_cam_format_desc meta_fmts[] = { /* FIXME for ISP6 meta format */
+	{
+		.vfmt.fmt.meta = {
+			.dataformat = V4L2_META_FMT_MTISP_PARAMS,
+			.buffersize = RAW_STATS_CFG_SIZE,
+		},
+	},
+	{
+		.vfmt.fmt.meta = {
+			.dataformat = V4L2_META_FMT_MTISP_3A,
+			.buffersize = RAW_STATS_0_SIZE,
+		},
+	},
+	{
+		.vfmt.fmt.meta = {
+			.dataformat = V4L2_META_FMT_MTISP_AF,
+			.buffersize = RAW_STATS_1_SIZE,
+		},
+	},
+	{
+		.vfmt.fmt.meta = {
+			.dataformat = V4L2_META_FMT_MTISP_LCS,
+			.buffersize = RAW_STATS_2_SIZE,
+		},
+	},
+};
+
+
+static void set_payload(struct mtk_cam_uapi_meta_hw_buf *buf,
+			unsigned int size, unsigned long *offset)
+{
+	buf->offset = *offset;
+	buf->size = size;
+	*offset += size;
+}
+
+static uint64_t *camsys_get_timestamp_addr(void *vaddr)
+{
+	struct mtk_cam_uapi_meta_raw_stats_0 *stats0;
+
+	stats0 = (struct mtk_cam_uapi_meta_raw_stats_0 *)vaddr;
+	return (uint64_t *)(stats0->timestamp.timestamp_buf);
+}
+
+static void camsys_set_meta_stats_info(u32 dma_port, void *vaddr,
+				 struct mtk_raw_pde_config *pde_cfg)
+{
+	struct mtk_cam_uapi_meta_raw_stats_0 *stats0;
+	struct mtk_cam_uapi_meta_raw_stats_1 *stats1;
+	unsigned long offset;
+
+	switch (dma_port) {
+	case MTKCAM_IPI_RAW_META_STATS_0:
+		stats0 = (struct mtk_cam_uapi_meta_raw_stats_0 *)vaddr;
+		offset = sizeof(*stats0);
+		set_payload(&stats0->ae_awb_stats.aao_buf, MTK_CAM_UAPI_AAO_MAX_BUF_SIZE, &offset);
+		set_payload(&stats0->ae_awb_stats.aaho_buf,
+			MTK_CAM_UAPI_AAHO_MAX_BUF_SIZE, &offset);
+		set_payload(&stats0->ltm_stats.ltmso_buf, MTK_CAM_UAPI_LTMSO_SIZE, &offset);
+		set_payload(&stats0->flk_stats.flko_buf, MTK_CAM_UAPI_FLK_MAX_BUF_SIZE, &offset);
+		set_payload(&stats0->tsf_stats.tsfo_r1_buf, MTK_CAM_UAPI_TSFSO_SIZE, &offset);
+		set_payload(&stats0->tsf_stats.tsfo_r2_buf, MTK_CAM_UAPI_TSFSO_SIZE, &offset);
+		set_payload(&stats0->tncy_stats.tncsyo_buf, MTK_CAM_UAPI_TNCSYO_SIZE, &offset);
+		if (pde_cfg) {
+			if (pde_cfg->pde_info.pd_table_offset) {
+				set_payload(&stats0->pde_stats.pdo_buf,
+					    pde_cfg->pde_info.pdo_max_size,
+					    &offset);
+			}
+		}
+		break;
+	case MTKCAM_IPI_RAW_META_STATS_1:
+		stats1 = (struct mtk_cam_uapi_meta_raw_stats_1 *)vaddr;
+		offset = sizeof(*stats1);
+		set_payload(&stats1->af_stats.afo_buf, MTK_CAM_UAPI_AFO_MAX_BUF_SIZE, &offset);
+		break;
+	case MTKCAM_IPI_RAW_META_STATS_2:
+		//todo
+		pr_info("stats 2 not support");
+		break;
+	default:
+		pr_debug("%s: dma_port err\n", __func__);
+		break;
+	}
+}
+
+static void camsys_sv_set_meta_stats_info(
+	u32 dma_port, void *vaddr, unsigned int width,
+	unsigned int height, unsigned int stride)
+{
+	struct mtk_cam_uapi_meta_camsv_stats_0 *sv_stats0;
+	unsigned long offset;
+	unsigned int size;
+
+	switch (dma_port) {
+	case MTKCAM_IPI_CAMSV_MAIN_OUT:
+		size = stride * height;
+		sv_stats0 = (struct mtk_cam_uapi_meta_camsv_stats_0 *)vaddr;
+		offset = sizeof(*sv_stats0);
+		set_payload(&sv_stats0->pd_stats.pdo_buf, size, &offset);
+		sv_stats0->pd_stats_enabled = 1;
+		sv_stats0->pd_stats.stats_src.width = width;
+		sv_stats0->pd_stats.stats_src.height = height;
+		sv_stats0->pd_stats.stride = stride;
+		break;
+	default:
+		pr_debug("%s: dma_port err\n", __func__);
+		break;
+	}
+}
+
+static int camsys_get_meta_version(bool major)
+{
+	if (major)
+		return MTK_CAM_META_VERSION_MAJOR;
+	else
+		return MTK_CAM_META_VERSION_MINOR;
+}
+
+static int camsys_get_meta_size(u32 video_id)
+{
+	switch (video_id) {
+	case MTKCAM_IPI_RAW_META_STATS_CFG:
+		return RAW_STATS_CFG_SIZE;
+	case MTKCAM_IPI_RAW_META_STATS_0:
+		return RAW_STATS_0_SIZE;
+	case MTKCAM_IPI_RAW_META_STATS_1:
+		return RAW_STATS_1_SIZE;
+	case MTKCAM_IPI_RAW_META_STATS_2:
+		return RAW_STATS_2_SIZE;
+	case MTKCAM_IPI_CAMSV_MAIN_OUT:
+		return SV_STATS_0_SIZE;
+	default:
+		pr_debug("%s: no support stats(%d)\n", __func__, video_id);
+	}
+	return 0;
+}
+
+static const struct mtk_cam_format_desc *camsys_get_meta_fmts(void)
+{
+	return meta_fmts;
+}
+
+static int camsys_get_port_bw(
+	enum MMQOS_PORT port, unsigned long height, unsigned long fps)
+{
+	switch (port) {
+	case AAO:
+		return (MTK_CAM_UAPI_AAO_MAX_BUF_SIZE + MTK_CAM_UAPI_AFO_MAX_BUF_SIZE) * fps;
+	case AAHO:
+		return MTK_CAM_UAPI_AAHO_HIST_SIZE * fps;
+	case TSFSO:
+		return (MTK_CAM_UAPI_TSFSO_SIZE * 2 + MTK_CAM_UAPI_LTMSO_SIZE) * fps;
+	case FLKO:
+		return MTK_CAM_UAPI_FLK_BLK_SIZE * MTK_CAM_UAPI_FLK_MAX_STAT_BLK_NUM * height * fps;
+	default:
+		pr_debug("%s: no support port(%d)\n", __func__, port);
+	}
+
+	return 0;
+}
+
+static struct camsys_plat_fp plat_fp = {
+	.get_meta_version = camsys_get_meta_version,
+	.get_meta_size = camsys_get_meta_size,
+	.get_meta_fmts = camsys_get_meta_fmts,
+	.set_meta_stats_info = camsys_set_meta_stats_info,
+	.set_sv_meta_stats_info = camsys_sv_set_meta_stats_info,
+	.get_port_bw = camsys_get_port_bw,
+	.get_timestamp_addr = camsys_get_timestamp_addr,
+};
+
+static int __init plat_module_init(void)
+{
+	pr_info("plat init\n");
+
+	mtk_cam_set_plat_util(&plat_fp);
+
+	return 0;
+}
+
+module_init(plat_module_init);
+MODULE_DESCRIPTION("Mediatek Camsys plat driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam-plat-util.c b/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam-plat-util.c
new file mode 100644
index 0000000000000000000000000000000000000000..1428ae515f7adcc4c4e8ed317f8487d1224317c9
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam-plat-util.c
@@ -0,0 +1,96 @@
+// SPDX-License-Identifier: GPL-2.0
+//
+// Copyright (c) 2022 MediaTek Inc.
+
+#include <linux/module.h>
+#include <linux/init.h>
+
+#include "mtk_cam-raw.h"
+#include "mtk_cam-plat-util.h"
+
+struct camsys_plat_fp *plat_fp;
+
+void mtk_cam_set_plat_util(struct camsys_plat_fp *fp)
+{
+	if (!fp) {
+		pr_info("%s platform fp is NULL ", __func__);
+		return;
+	}
+	plat_fp = fp;
+}
+EXPORT_SYMBOL(mtk_cam_set_plat_util);
+
+int mtk_cam_get_meta_version(bool major)
+{
+	if (!plat_fp) {
+		pr_info("%s platform fp is NULL ", __func__);
+		return 0;
+	}
+	return plat_fp->get_meta_version(major);
+}
+EXPORT_SYMBOL(mtk_cam_get_meta_version);
+
+int mtk_cam_get_meta_size(u32 video_id)
+{
+	if (!plat_fp) {
+		pr_info("%s platform fp is NULL ", __func__);
+		return 0;
+	}
+	return plat_fp->get_meta_size(video_id);
+}
+EXPORT_SYMBOL(mtk_cam_get_meta_size);
+
+const struct mtk_cam_format_desc *mtk_cam_get_meta_fmts(void)
+{
+	if (!plat_fp) {
+		pr_info("%s platform fp is NULL ", __func__);
+		return 0;
+	}
+	return plat_fp->get_meta_fmts();
+}
+EXPORT_SYMBOL(mtk_cam_get_meta_fmts);
+
+void mtk_cam_set_meta_stats_info(u32 dma_port, void *vaddr,
+				 struct mtk_raw_pde_config *pde_cfg)
+{
+	if (!plat_fp) {
+		pr_info("%s platform fp is NULL ", __func__);
+		return;
+	}
+	plat_fp->set_meta_stats_info(dma_port, vaddr, pde_cfg);
+}
+EXPORT_SYMBOL(mtk_cam_set_meta_stats_info);
+
+void mtk_cam_set_sv_meta_stats_info(
+		u32 dma_port, void *vaddr,
+		unsigned int width, unsigned int height,
+		unsigned int stride)
+{
+	if (!plat_fp) {
+		pr_info("%s platform fp is NULL ", __func__);
+		return;
+	}
+	plat_fp->set_sv_meta_stats_info(
+		dma_port, vaddr, width, height, stride);
+}
+EXPORT_SYMBOL(mtk_cam_set_sv_meta_stats_info);
+
+uint64_t *mtk_cam_get_timestamp_addr(void *vaddr)
+{
+	if (!plat_fp) {
+		pr_info("%s platform fp is NULL ", __func__);
+		return 0;
+	}
+	return plat_fp->get_timestamp_addr(vaddr);
+}
+EXPORT_SYMBOL(mtk_cam_get_timestamp_addr);
+
+static int __init util_module_init(void)
+{
+	pr_info("platform util init\n");
+	return 0;
+}
+
+module_init(util_module_init);
+MODULE_DESCRIPTION("Mediatek Camsys plat util driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam-plat-util.h b/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam-plat-util.h
new file mode 100644
index 0000000000000000000000000000000000000000..da619e96bb380a5a5536f41af93eacacd3fec775
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam-plat-util.h
@@ -0,0 +1,58 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2022 MediaTek Inc.
+ */
+
+#ifndef __MTK_CAM_PLAT_UTIL_H
+#define __MTK_CAM_PLAT_UTIL_H
+
+enum MMQOS_PORT {
+	AAO = 0,
+	AAHO,
+	TSFSO,
+	FLKO,
+};
+
+typedef int (*plat_camsys_get_meta_version)(bool major);
+typedef int (*plat_camsys_get_meta_size)(u32 video_id);
+typedef const struct mtk_cam_format_desc* (*plat_camsys_get_meta_fmts)(void);
+typedef void (*plat_camsys_set_meta_stats_info)(u32 dma_port, void *vaddr,
+						struct mtk_raw_pde_config *pde_cfg);
+typedef void (*plat_camsys_sv_set_meta_stats_info)(u32 dma_port, void *vaddr,
+						   unsigned int width,
+						   unsigned int height,
+						   unsigned int stride);
+typedef int (*plat_camsys_get_port_bw)(enum MMQOS_PORT port,
+				       unsigned long height,
+				       unsigned long fps);
+
+typedef uint64_t* (*plat_camsys_get_timestamp_addr)(void *vaddr);
+
+struct camsys_plat_fp {
+	plat_camsys_get_meta_version get_meta_version;
+	plat_camsys_get_meta_size get_meta_size;
+	plat_camsys_get_meta_fmts get_meta_fmts;
+	plat_camsys_set_meta_stats_info set_meta_stats_info;
+	plat_camsys_sv_set_meta_stats_info set_sv_meta_stats_info;
+	plat_camsys_get_port_bw get_port_bw;
+	plat_camsys_get_timestamp_addr get_timestamp_addr;
+};
+
+void mtk_cam_set_plat_util(struct camsys_plat_fp *plat_fp);
+
+int mtk_cam_get_meta_version(bool major);
+
+int mtk_cam_get_meta_size(u32 video_id);
+
+const struct mtk_cam_format_desc *mtk_cam_get_meta_fmts(void);
+
+void mtk_cam_set_meta_stats_info(u32 dma_port, void *vaddr,
+				 struct mtk_raw_pde_config *pde_cfg);
+
+void mtk_cam_set_sv_meta_stats_info(u32 dma_port, void *vaddr,
+				    unsigned int width,
+				    unsigned int height,
+				    unsigned int stride);
+uint64_t *mtk_cam_get_timestamp_addr(void *vaddr);
+
+#endif /*__MTK_CAM_PLAT_UTIL_H*/
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam-pool.c b/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam-pool.c
new file mode 100644
index 0000000000000000000000000000000000000000..a42dfc21ef24798918aba4398d3d5f9e3b8d9c71
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam-pool.c
@@ -0,0 +1,453 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2018 MediaTek Inc.
+ *
+ * Author: Louis Kuo <louis.kuo@mediatek.com>
+ */
+
+#include <linux/device.h>
+//#include <linux/dma-iommu.h>
+#include <linux/dma-mapping.h>
+#include <linux/dma-buf.h>
+#include <linux/mm.h>
+#include <linux/remoteproc.h>
+#include <linux/spinlock.h>
+
+#include "mtk_cam.h"
+#include "mtk_cam-pool.h"
+
+int mtk_cam_working_buf_pool_init(struct mtk_cam_ctx *ctx, struct device *dev)
+{
+	int i, ret;
+	void *ptr;
+	dma_addr_t addr;
+	struct mtk_cam_device *cam = ctx->cam;
+	const int working_buf_size = round_up(CQ_BUF_SIZE, PAGE_SIZE);
+	const int msg_buf_size = round_up(IPI_FRAME_BUF_SIZE, PAGE_SIZE);
+
+	INIT_LIST_HEAD(&ctx->buf_pool.cam_freelist.list);
+	spin_lock_init(&ctx->buf_pool.cam_freelist.lock);
+	ctx->buf_pool.cam_freelist.cnt = 0;
+	ctx->buf_pool.working_buf_size = CAM_CQ_BUF_NUM * working_buf_size;
+	ctx->buf_pool.msg_buf_size = CAM_CQ_BUF_NUM * msg_buf_size;
+	ctx->buf_pool.raw_workbuf_size = round_up(SIZE_OF_RAW_WORKBUF, PAGE_SIZE);
+	ctx->buf_pool.priv_workbuf_size = round_up(SIZE_OF_RAW_PRIV, PAGE_SIZE);
+	ctx->buf_pool.session_buf_size = round_up(SIZE_OF_SESSION, PAGE_SIZE);
+
+	/* raw working buffer */
+	ptr = dma_alloc_coherent(cam->smem_dev, ctx->buf_pool.raw_workbuf_size,
+				 &addr, GFP_KERNEL);
+	if (!ptr)
+		return -ENOMEM;
+	ctx->buf_pool.raw_workbuf_scp_addr = addr;
+	ctx->buf_pool.raw_workbuf_va = ptr;
+	dev_dbg(dev, "[%s] raw working buf scp addr:%llx va:%pK size %d\n",
+		__func__,
+		ctx->buf_pool.raw_workbuf_scp_addr,
+		ctx->buf_pool.raw_workbuf_va,
+		ctx->buf_pool.raw_workbuf_size);
+
+	/* raw priv working buffer */
+	ptr = dma_alloc_coherent(cam->smem_dev, ctx->buf_pool.priv_workbuf_size,
+				 &addr, GFP_KERNEL);
+	if (!ptr)
+		return -ENOMEM;
+	ctx->buf_pool.priv_workbuf_scp_addr = addr;
+	ctx->buf_pool.priv_workbuf_va = ptr;
+	dev_dbg(dev, "[%s] raw pri working buf scp addr:%llx va:%pK size %d\n",
+		__func__,
+		ctx->buf_pool.priv_workbuf_scp_addr,
+		ctx->buf_pool.priv_workbuf_va,
+		ctx->buf_pool.priv_workbuf_size);
+
+	/* session buffer */
+	ptr = dma_alloc_coherent(cam->smem_dev, ctx->buf_pool.session_buf_size,
+				 &addr, GFP_KERNEL);
+	if (!ptr)
+		return -ENOMEM;
+	ctx->buf_pool.session_buf_scp_addr = addr;
+	ctx->buf_pool.session_buf_va = ptr;
+	dev_dbg(dev, "[%s] session buf scp addr:%llx va:%pK size %d\n",
+		__func__,
+		ctx->buf_pool.session_buf_scp_addr,
+		ctx->buf_pool.session_buf_va,
+		ctx->buf_pool.session_buf_size);
+
+	/* working buffer */
+	ptr = dma_alloc_coherent(cam->smem_dev, ctx->buf_pool.working_buf_size,
+				 &addr, GFP_KERNEL);
+	if (!ptr)
+		return -ENOMEM;
+	ctx->buf_pool.working_buf_scp_addr = addr;
+	ctx->buf_pool.working_buf_va = ptr;
+	addr = dma_map_resource(dev, addr, ctx->buf_pool.working_buf_size,
+				DMA_BIDIRECTIONAL, DMA_ATTR_SKIP_CPU_SYNC);
+	if (dma_mapping_error(dev, addr)) {
+		dev_err(dev, "failed to map scp iova\n");
+		ret = -ENOMEM;
+		goto fail_free_mem;
+	}
+	ctx->buf_pool.working_buf_iova = addr;
+	dev_dbg(dev, "[%s] CQ buf scp addr:%llx va:%pK iova:%llx size %d\n",
+		__func__,
+		ctx->buf_pool.working_buf_scp_addr,
+		ctx->buf_pool.working_buf_va,
+		ctx->buf_pool.working_buf_iova,
+		ctx->buf_pool.working_buf_size);
+
+	/* msg buffer */
+	ptr = dma_alloc_coherent(cam->smem_dev, ctx->buf_pool.msg_buf_size,
+				 &addr, GFP_KERNEL);
+	if (!ptr)
+		return -ENOMEM;
+	ctx->buf_pool.msg_buf_scp_addr = addr;
+	ctx->buf_pool.msg_buf_va = ptr;
+	dev_dbg(dev, "[%s] msg buf scp addr:%llx va:%pK size %d\n",
+		__func__, ctx->buf_pool.msg_buf_scp_addr,
+		ctx->buf_pool.msg_buf_va, ctx->buf_pool.msg_buf_size);
+
+	for (i = 0; i < CAM_CQ_BUF_NUM; i++) {
+		struct mtk_cam_working_buf_entry *buf = &ctx->buf_pool.working_buf[i];
+		int offset = i * working_buf_size;
+		int offset_msg = i * msg_buf_size;
+
+		buf->ctx = ctx;
+		buf->buffer.va = ctx->buf_pool.working_buf_va + offset;
+		buf->buffer.iova = ctx->buf_pool.working_buf_iova + offset;
+		buf->buffer.scp_addr = ctx->buf_pool.working_buf_scp_addr + offset;
+		buf->buffer.size = working_buf_size;
+		buf->msg_buffer.va = ctx->buf_pool.msg_buf_va + offset_msg;
+		buf->msg_buffer.scp_addr = ctx->buf_pool.msg_buf_scp_addr + offset_msg;
+		buf->msg_buffer.size = msg_buf_size;
+		buf->s_data = NULL;
+
+		list_add_tail(&buf->list_entry, &ctx->buf_pool.cam_freelist.list);
+		ctx->buf_pool.cam_freelist.cnt++;
+	}
+
+	dev_dbg(ctx->cam->dev,
+		"%s: ctx(%d): cq buffers init, freebuf cnt(%d)\n",
+		__func__, ctx->stream_id, ctx->buf_pool.cam_freelist.cnt);
+
+	return 0;
+fail_free_mem:
+	dma_free_coherent(cam->smem_dev, ctx->buf_pool.working_buf_size,
+			  ctx->buf_pool.working_buf_va,
+			  ctx->buf_pool.working_buf_scp_addr);
+	ctx->buf_pool.working_buf_scp_addr = 0;
+
+	return ret;
+}
+
+void mtk_cam_working_buf_pool_release(struct mtk_cam_ctx *ctx, struct device *dev)
+{
+	struct mtk_cam_device *cam = ctx->cam;
+
+	/* msg buffer */
+	dma_free_coherent(cam->smem_dev, ctx->buf_pool.msg_buf_size,
+			  ctx->buf_pool.msg_buf_va,
+			  ctx->buf_pool.msg_buf_scp_addr);
+	dev_dbg(dev,
+		"%s:ctx(%d):msg buffers release, va:%pK scp_addr %llx sz %d\n",
+		__func__, ctx->stream_id,
+		ctx->buf_pool.msg_buf_va,
+		ctx->buf_pool.msg_buf_scp_addr,
+		ctx->buf_pool.msg_buf_size);
+
+	/* working buffer */
+	dma_unmap_page_attrs(dev, ctx->buf_pool.working_buf_iova,
+			     ctx->buf_pool.working_buf_size,
+			     DMA_BIDIRECTIONAL,
+			     DMA_ATTR_SKIP_CPU_SYNC);
+	dma_free_coherent(cam->smem_dev, ctx->buf_pool.working_buf_size,
+			  ctx->buf_pool.working_buf_va,
+			  ctx->buf_pool.working_buf_scp_addr);
+	dev_dbg(dev,
+		"%s:ctx(%d):cq buffers release, iova %llx scp_addr %llx sz %d\n",
+		__func__, ctx->stream_id,
+		ctx->buf_pool.working_buf_iova,
+		ctx->buf_pool.working_buf_scp_addr,
+		ctx->buf_pool.working_buf_size);
+
+	/* session buffer */
+	dma_free_coherent(cam->smem_dev, ctx->buf_pool.session_buf_size,
+			  ctx->buf_pool.session_buf_va,
+			  ctx->buf_pool.session_buf_scp_addr);
+	dev_dbg(dev,
+		"%s:ctx(%d):session buffers release, scp_addr %llx sz %d\n",
+		__func__, ctx->stream_id,
+		ctx->buf_pool.session_buf_scp_addr,
+		ctx->buf_pool.session_buf_size);
+
+	/* raw priv working buffer */
+	dma_free_coherent(cam->smem_dev, ctx->buf_pool.priv_workbuf_size,
+			  ctx->buf_pool.priv_workbuf_va,
+			  ctx->buf_pool.priv_workbuf_scp_addr);
+	dev_dbg(dev,
+		"%s:ctx(%d):raw pri working buffers release, scp_addr %llx sz %d\n",
+		__func__, ctx->stream_id,
+		ctx->buf_pool.priv_workbuf_scp_addr,
+		ctx->buf_pool.priv_workbuf_size);
+
+	/* raw working buffer */
+	dma_free_coherent(cam->smem_dev, ctx->buf_pool.raw_workbuf_size,
+			  ctx->buf_pool.raw_workbuf_va,
+			  ctx->buf_pool.raw_workbuf_scp_addr);
+	dev_dbg(dev,
+		"%s:ctx(%d):raw working buffers release, scp_addr %llx sz %d\n",
+		__func__, ctx->stream_id,
+		ctx->buf_pool.raw_workbuf_scp_addr,
+		ctx->buf_pool.raw_workbuf_size);
+}
+
+void
+mtk_cam_working_buf_put(struct mtk_cam_working_buf_entry *buf_entry)
+{
+	struct mtk_cam_ctx *ctx = buf_entry->ctx;
+	int cnt;
+
+	spin_lock(&ctx->buf_pool.cam_freelist.lock);
+
+	list_add_tail(&buf_entry->list_entry,
+		      &ctx->buf_pool.cam_freelist.list);
+	cnt = ++ctx->buf_pool.cam_freelist.cnt;
+
+	spin_unlock(&ctx->buf_pool.cam_freelist.lock);
+
+	dev_dbg(ctx->cam->dev, "%s:ctx(%d):iova(%pad), free cnt(%d)\n",
+		__func__, ctx->stream_id, &buf_entry->buffer.iova, cnt);
+}
+
+struct mtk_cam_working_buf_entry*
+mtk_cam_working_buf_get(struct mtk_cam_ctx *ctx)
+{
+	struct mtk_cam_working_buf_entry *buf_entry;
+	int cnt;
+
+	/* get from free list */
+	spin_lock(&ctx->buf_pool.cam_freelist.lock);
+	if (list_empty(&ctx->buf_pool.cam_freelist.list)) {
+		spin_unlock(&ctx->buf_pool.cam_freelist.lock);
+
+		dev_info(ctx->cam->dev, "%s:ctx(%d):no free buf\n",
+			 __func__, ctx->stream_id);
+		return NULL;
+	}
+
+	buf_entry = list_first_entry(&ctx->buf_pool.cam_freelist.list,
+				     struct mtk_cam_working_buf_entry,
+				     list_entry);
+	list_del(&buf_entry->list_entry);
+	cnt = --ctx->buf_pool.cam_freelist.cnt;
+	buf_entry->ctx = ctx;
+
+	spin_unlock(&ctx->buf_pool.cam_freelist.lock);
+
+	dev_dbg(ctx->cam->dev, "%s:ctx(%d):iova(%pad), free cnt(%d)\n",
+		__func__, ctx->stream_id, &buf_entry->buffer.iova, cnt);
+
+	return buf_entry;
+}
+
+int mtk_cam_img_working_buf_pool_init(struct mtk_cam_ctx *ctx, int buf_num,
+				      struct device *dev)
+{
+	int i, ret, working_buf_size;
+	void *ptr;
+	dma_addr_t addr;
+	struct mtk_cam_device *cam = ctx->cam;
+	struct mtk_cam_video_device *vdev;
+
+	if (buf_num > CAM_IMG_BUF_NUM) {
+		dev_err(ctx->cam->dev,
+			"%s: ctx(%d): image buffers number too large(%d)\n",
+			__func__, ctx->stream_id, buf_num);
+		WARN_ON(1);
+		return 0;
+	}
+
+	vdev = &ctx->pipe->vdev_nodes[MTK_RAW_MAIN_STREAM_OUT - MTK_RAW_SINK_NUM];
+	working_buf_size = vdev->active_fmt.fmt.pix_mp.plane_fmt[0].sizeimage;
+	INIT_LIST_HEAD(&ctx->img_buf_pool.cam_freeimglist.list);
+	spin_lock_init(&ctx->img_buf_pool.cam_freeimglist.lock);
+	ctx->img_buf_pool.cam_freeimglist.cnt = 0;
+	ctx->img_buf_pool.working_img_buf_size = buf_num * working_buf_size;
+	ptr = dma_alloc_coherent(cam->smem_dev,
+				 ctx->img_buf_pool.working_img_buf_size,
+				 &addr, GFP_KERNEL);
+	if (!ptr)
+		return -ENOMEM;
+	ctx->img_buf_pool.working_img_buf_scp_addr = addr;
+	ctx->img_buf_pool.working_img_buf_va = ptr;
+	addr = dma_map_resource(dev, addr, ctx->img_buf_pool.working_img_buf_size,
+				DMA_BIDIRECTIONAL, DMA_ATTR_SKIP_CPU_SYNC);
+	if (dma_mapping_error(dev, addr)) {
+		dev_err(dev, "failed to map scp iova\n");
+		ret = -ENOMEM;
+		goto fail_free_mem;
+	}
+	ctx->img_buf_pool.working_img_buf_iova = addr;
+	dev_dbg(dev, "[%s] img working buf scp addr:%llx va:%pK iova: %llx size %d\n",
+		__func__,
+		ctx->img_buf_pool.working_img_buf_scp_addr,
+		ctx->img_buf_pool.working_img_buf_va,
+		ctx->img_buf_pool.working_img_buf_iova,
+		ctx->img_buf_pool.working_img_buf_size);
+
+	for (i = 0; i < buf_num; i++) {
+		struct mtk_cam_img_working_buf_entry *buf = &ctx->img_buf_pool.img_working_buf[i];
+		int offset = i * working_buf_size;
+
+		buf->ctx = ctx;
+		buf->img_buffer.va = ctx->img_buf_pool.working_img_buf_va + offset;
+		buf->img_buffer.scp_addr = ctx->img_buf_pool.working_img_buf_scp_addr + offset;
+		buf->img_buffer.iova = ctx->img_buf_pool.working_img_buf_iova + offset;
+		buf->img_buffer.size = working_buf_size;
+		list_add_tail(&buf->list_entry, &ctx->img_buf_pool.cam_freeimglist.list);
+		ctx->img_buf_pool.cam_freeimglist.cnt++;
+	}
+
+	dev_dbg(dev,
+		"%s: ctx(%d): image buffers init, freebuf cnt(%d)\n",
+		__func__, ctx->stream_id, ctx->img_buf_pool.cam_freeimglist.cnt);
+	return 0;
+
+fail_free_mem:
+	dma_free_coherent(cam->smem_dev, ctx->img_buf_pool.working_img_buf_size,
+			  ctx->img_buf_pool.working_img_buf_va,
+			  ctx->img_buf_pool.working_img_buf_scp_addr);
+	return ret;
+}
+
+void mtk_cam_img_working_buf_pool_release(struct mtk_cam_ctx *ctx,
+					  struct device *dev)
+{
+	struct mtk_cam_device *cam = ctx->cam;
+
+	dma_unmap_page_attrs(dev, ctx->img_buf_pool.working_img_buf_iova,
+			     ctx->img_buf_pool.working_img_buf_size,
+			     DMA_BIDIRECTIONAL,
+			     DMA_ATTR_SKIP_CPU_SYNC);
+	dma_free_coherent(cam->smem_dev, ctx->img_buf_pool.working_img_buf_size,
+			  ctx->img_buf_pool.working_img_buf_va,
+			  ctx->img_buf_pool.working_img_buf_scp_addr);
+	dev_dbg(dev,
+		"%s:ctx(%d):img working buf release, scp addr %llx va %pK iova %llx, sz %d\n",
+		__func__, ctx->stream_id,
+		ctx->img_buf_pool.working_img_buf_scp_addr,
+		ctx->img_buf_pool.working_img_buf_va,
+		ctx->img_buf_pool.working_img_buf_iova,
+		ctx->img_buf_pool.working_img_buf_size);
+}
+
+void mtk_cam_img_working_buf_put(struct mtk_cam_img_working_buf_entry *buf_entry)
+{
+	struct mtk_cam_ctx *ctx = buf_entry->ctx;
+	int cnt;
+
+	spin_lock(&ctx->img_buf_pool.cam_freeimglist.lock);
+
+	list_add_tail(&buf_entry->list_entry,
+		      &ctx->img_buf_pool.cam_freeimglist.list);
+	cnt = ++ctx->img_buf_pool.cam_freeimglist.cnt;
+
+	spin_unlock(&ctx->img_buf_pool.cam_freeimglist.lock);
+
+	dev_dbg(ctx->cam->dev, "%s:ctx(%d):iova(0x%llx), free cnt(%d)\n",
+		__func__, ctx->stream_id, buf_entry->img_buffer.iova, cnt);
+}
+
+struct mtk_cam_img_working_buf_entry*
+mtk_cam_img_working_buf_get(struct mtk_cam_ctx *ctx)
+{
+	struct mtk_cam_img_working_buf_entry *buf_entry;
+	int cnt;
+
+	/* get from free list */
+	spin_lock(&ctx->img_buf_pool.cam_freeimglist.lock);
+	if (list_empty(&ctx->img_buf_pool.cam_freeimglist.list)) {
+		spin_unlock(&ctx->img_buf_pool.cam_freeimglist.lock);
+
+		dev_info(ctx->cam->dev, "%s:ctx(%d):no free buf\n",
+			 __func__, ctx->stream_id);
+		return NULL;
+	}
+
+	buf_entry = list_first_entry(&ctx->img_buf_pool.cam_freeimglist.list,
+				     struct mtk_cam_img_working_buf_entry,
+				     list_entry);
+	list_del(&buf_entry->list_entry);
+	cnt = --ctx->img_buf_pool.cam_freeimglist.cnt;
+
+	spin_unlock(&ctx->img_buf_pool.cam_freeimglist.lock);
+
+	dev_dbg(ctx->cam->dev, "%s:ctx(%d):iova(0x%llx), free cnt(%d)\n",
+		__func__, ctx->stream_id, buf_entry->img_buffer.iova, cnt);
+
+	return buf_entry;
+}
+
+int mtk_cam_sv_working_buf_pool_init(struct mtk_cam_ctx *ctx)
+{
+	int i;
+
+	INIT_LIST_HEAD(&ctx->buf_pool.sv_freelist.list);
+	spin_lock_init(&ctx->buf_pool.sv_freelist.lock);
+	ctx->buf_pool.sv_freelist.cnt = 0;
+
+	for (i = 0; i < CAMSV_WORKING_BUF_NUM; i++) {
+		struct mtk_camsv_working_buf_entry *buf = &ctx->buf_pool.sv_working_buf[i];
+
+		buf->ctx = ctx;
+		list_add_tail(&buf->list_entry,
+			      &ctx->buf_pool.sv_freelist.list);
+		ctx->buf_pool.sv_freelist.cnt++;
+	}
+	dev_info(ctx->cam->dev, "%s:ctx(%d):freebuf cnt(%d)\n", __func__,
+		 ctx->stream_id, ctx->buf_pool.sv_freelist.cnt);
+
+	return 0;
+}
+
+void
+mtk_cam_sv_working_buf_put(struct mtk_camsv_working_buf_entry *buf_entry)
+{
+	struct mtk_cam_ctx *ctx = buf_entry->ctx;
+
+	dev_dbg(ctx->cam->dev, "%s:ctx(%d):s\n", __func__, ctx->stream_id);
+
+	if (!buf_entry)
+		return;
+
+	spin_lock(&ctx->buf_pool.sv_freelist.lock);
+	list_add_tail(&buf_entry->list_entry,
+		      &ctx->buf_pool.sv_freelist.list);
+	ctx->buf_pool.sv_freelist.cnt++;
+	spin_unlock(&ctx->buf_pool.sv_freelist.lock);
+
+	dev_dbg(ctx->cam->dev, "%s:ctx(%d):e\n", __func__, ctx->stream_id);
+}
+
+struct mtk_camsv_working_buf_entry*
+mtk_cam_sv_working_buf_get(struct mtk_cam_ctx *ctx)
+{
+	struct mtk_camsv_working_buf_entry *buf_entry;
+
+	dev_dbg(ctx->cam->dev, "%s:ctx(%d):s\n", __func__, ctx->stream_id);
+
+	spin_lock(&ctx->buf_pool.sv_freelist.lock);
+	if (list_empty(&ctx->buf_pool.sv_freelist.list)) {
+		spin_unlock(&ctx->buf_pool.sv_freelist.lock);
+		return NULL;
+	}
+
+	buf_entry = list_first_entry(&ctx->buf_pool.sv_freelist.list,
+				     struct mtk_camsv_working_buf_entry,
+				     list_entry);
+	list_del(&buf_entry->list_entry);
+	ctx->buf_pool.sv_freelist.cnt--;
+	spin_unlock(&ctx->buf_pool.sv_freelist.lock);
+
+	dev_dbg(ctx->cam->dev, "%s:ctx(%d):e\n", __func__, ctx->stream_id);
+	return buf_entry;
+}
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam-pool.h b/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam-pool.h
new file mode 100644
index 0000000000000000000000000000000000000000..da3b63f981da76e60840f8839581a6ec6c3f9392
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam-pool.h
@@ -0,0 +1,31 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2018 MediaTek Inc.
+ */
+
+#ifndef __MTK_CAM_POOL_H
+#define __MTK_CAM_POOL_H
+
+struct mtk_cam_ctx;
+
+int mtk_cam_working_buf_pool_init(struct mtk_cam_ctx *ctx, struct device *dev);
+void mtk_cam_working_buf_pool_release(struct mtk_cam_ctx *ctx, struct device *dev);
+void
+mtk_cam_working_buf_put(struct mtk_cam_working_buf_entry *buf_entry);
+struct mtk_cam_working_buf_entry*
+mtk_cam_working_buf_get(struct mtk_cam_ctx *ctx);
+
+int mtk_cam_img_working_buf_pool_init(struct mtk_cam_ctx *ctx, int buf_num, struct device *dev);
+void mtk_cam_img_working_buf_pool_release(struct mtk_cam_ctx *ctx, struct device *dev);
+void
+mtk_cam_img_working_buf_put(struct mtk_cam_img_working_buf_entry *buf_entry);
+struct mtk_cam_img_working_buf_entry*
+mtk_cam_img_working_buf_get(struct mtk_cam_ctx *ctx);
+
+int mtk_cam_sv_working_buf_pool_init(struct mtk_cam_ctx *ctx);
+void
+mtk_cam_sv_working_buf_put(struct mtk_camsv_working_buf_entry *buf_entry);
+struct mtk_camsv_working_buf_entry*
+mtk_cam_sv_working_buf_get(struct mtk_cam_ctx *ctx);
+
+#endif
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam-raw.c b/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam-raw.c
new file mode 100755
index 0000000000000000000000000000000000000000..6c09dd0f1c84eaccb7af687a6b23ea2bcea6e3b1
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam-raw.c
@@ -0,0 +1,6433 @@
+// SPDX-License-Identifier: GPL-2.0
+//
+// Copyright (c) 2022 MediaTek Inc.
+
+#include <linux/clk.h>
+#include <linux/component.h>
+#include <linux/interrupt.h>
+#include <linux/iopoll.h>
+#include <linux/module.h>
+#include <linux/of_platform.h>
+#include <linux/of.h>
+#include <linux/platform_device.h>
+#include <linux/pm_runtime.h>
+#include <linux/vmalloc.h>
+#include <linux/videodev2.h>
+#include <linux/suspend.h>
+#include <linux/rtc.h>
+
+#include <media/v4l2-device.h>
+#include <media/v4l2-event.h>
+#include <media/v4l2-ioctl.h>
+#include <media/v4l2-subdev.h>
+
+#include <soc/mediatek/smi.h>
+
+#include "mtk_cam.h"
+#include "mtk_cam-feature.h"
+#include "mtk_cam-raw.h"
+#ifdef ISP7_1
+#include "mtk_cam-regs-mt8188.h"
+#else
+#include "mtk_cam-regs-mt8195.h"
+#endif
+#include "mtk_cam-video.h"
+#include "mtk_cam-seninf-if.h"
+#include "mtk_camera-v4l2-controls.h"
+
+#include "mtk_cam-dmadbg.h"
+#include "mtk_cam-raw_debug.h"
+
+static unsigned int debug_raw;
+module_param(debug_raw, uint, 0644);
+MODULE_PARM_DESC(debug_raw, "activates debug info");
+
+static int debug_raw_num = -1;
+module_param(debug_raw_num, int, 0644);
+MODULE_PARM_DESC(debug_raw_num, "debug: num of used raw devices");
+
+static int debug_pixel_mode = -1;
+module_param(debug_pixel_mode, int, 0644);
+MODULE_PARM_DESC(debug_pixel_mode, "debug: pixel mode");
+
+static int debug_clk_idx = -1;
+module_param(debug_clk_idx, int, 0644);
+MODULE_PARM_DESC(debug_clk_idx, "debug: clk idx");
+
+static int debug_dump_fbc;
+module_param(debug_dump_fbc, int, 0644);
+MODULE_PARM_DESC(debug_dump_fbc, "debug: dump fbc");
+
+#define MTK_RAW_STOP_HW_TIMEOUT			(33)
+
+#define MTK_CAMSYS_RES_IDXMASK		0xF0
+#define MTK_CAMSYS_RES_BIN_TAG		0x10
+#define MTK_CAMSYS_RES_FRZ_TAG		0x20
+#define MTK_CAMSYS_RES_HWN_TAG		0x30
+#define MTK_CAMSYS_RES_CLK_TAG		0x40
+
+#define MTK_CAMSYS_RES_PLAN_NUM		10
+#define FRZ_PXLMODE_THRES		71
+#define MHz		1000000
+#ifdef ISP7_1
+#define TGO_MAX_PXLMODE				1
+#define MTK_CAMSYS_PROC_DEFAULT_PIXELMODE	1
+#else
+#define TGO_MAX_PXLMODE				8
+#define MTK_CAMSYS_PROC_DEFAULT_PIXELMODE	2
+#endif
+
+#define sizeof_u32(__struct__) ((sizeof(__struct__) + sizeof(u32) - 1)/ \
+				sizeof(u32))
+
+enum MTK_CAMSYS_RES_STEP {
+	E_RES_BASIC,
+	E_RES_BIN_S = MTK_CAMSYS_RES_BIN_TAG,
+	E_RES_BIN0 = E_RES_BIN_S,
+	E_RES_BIN1,
+	E_RES_BIN_E,
+	E_RES_FRZ_S = MTK_CAMSYS_RES_FRZ_TAG,
+	E_RES_FRZ0 = E_RES_FRZ_S,
+	E_RES_FRZ1,
+	E_RES_FRZ_E,
+	E_RES_HWN_S = MTK_CAMSYS_RES_HWN_TAG,
+	E_RES_HWN0 = E_RES_HWN_S,
+	E_RES_HWN1,
+	E_RES_HWN2,
+	E_RES_HWN_E,
+	E_RES_CLK_S = MTK_CAMSYS_RES_CLK_TAG,
+	E_RES_CLK0 = E_RES_CLK_S,
+	E_RES_CLK1,
+	E_RES_CLK2,
+	E_RES_CLK3,
+	E_RES_CLK_E,
+};
+
+enum MTK_CAMSYS_MAXLB_CHECK_RESULT {
+	LB_CHECK_OK = 0,
+	LB_CHECK_CBN,
+	LB_CHECK_QBN,
+	LB_CHECK_BIN,
+	LB_CHECK_FRZ,
+	LB_CHECK_TWIN,
+	LB_CHECK_RAW,
+};
+
+
+#define CAM_RAW_PROCESS_MAX_LINE_BUFFER		(6632)
+#define CAM_RAW_FRZ_MAX_LINE_BUFFER		(6632)
+#define CAM_RAW_BIN_MAX_LINE_BUFFER		(12000)
+#define CAM_RAW_QBND_MAX_LINE_BUFFER		(16000)
+#define CAM_RAW_CBN_MAX_LINE_BUFFER		(18472)
+#define CAM_TWIN_PROCESS_MAX_LINE_BUFFER	(12400)
+
+struct cam_resource_plan {
+	int cam_resource[MTK_CAMSYS_RES_STEP_NUM];
+};
+
+enum resource_strategy_id {
+	RESOURCE_STRATEGY_QPR = 0,
+	RESOURCE_STRATEGY_PQR,
+	RESOURCE_STRATEGY_RPQ,
+	RESOURCE_STRATEGY_QRP,
+	RESOURCE_STRATEGY_NUMBER
+};
+
+static const struct cam_resource_plan raw_resource_strategy_plan[] = {
+	[RESOURCE_STRATEGY_QPR] = {
+		.cam_resource = {
+			E_RES_BASIC, E_RES_HWN1, E_RES_CLK1, E_RES_CLK2,
+			E_RES_CLK3, E_RES_FRZ1, E_RES_BIN1, E_RES_HWN2} },
+	[RESOURCE_STRATEGY_PQR] = {
+		.cam_resource = {
+			E_RES_BASIC, E_RES_HWN1, E_RES_HWN2, E_RES_FRZ1,
+			E_RES_BIN1, E_RES_CLK1, E_RES_CLK2, E_RES_CLK3} },
+	[RESOURCE_STRATEGY_RPQ] = {
+		.cam_resource = {
+			E_RES_BASIC, E_RES_FRZ1, E_RES_BIN1, E_RES_CLK1,
+			E_RES_CLK2, E_RES_CLK3, E_RES_HWN1, E_RES_HWN2} },
+	[RESOURCE_STRATEGY_QRP] = {
+		.cam_resource = {
+			E_RES_BASIC, E_RES_CLK1, E_RES_CLK2, E_RES_CLK3,
+			E_RES_HWN1, E_RES_HWN2, E_RES_FRZ1, E_RES_BIN1} },
+};
+
+#ifdef ISP7_1
+/* stagger raw select and mode decision preference */
+#define STAGGER_MAX_STREAM_NUM 4
+
+struct cam_stagger_select {
+	int raw_select;
+	int mode_decision;
+};
+
+struct cam_stagger_order {
+	struct cam_stagger_select stagger_select[STAGGER_MAX_STREAM_NUM];
+};
+
+enum cam_stagger_stream_mode_plan {
+	STAGGER_STREAM_PLAN_OTF_ALL = 0,
+	STAGGER_STREAM_PLAN_OFF_ALL,
+	STAGGER_STREAM_PLAN_OTF_DCIF_OFF_2EXP,
+	STAGGER_STREAM_PLAN_OTF_DCIF_OFF_3EXP,
+	STAGGER_STREAM_PLAN_NUM_MAX
+};
+
+enum cam_stagger_raw_select {
+	RAW_SELECTION_A = 1 << MTKCAM_PIPE_RAW_A,
+	RAW_SELECTION_B = 1 << MTKCAM_PIPE_RAW_B,
+	RAW_SELECTION_C = 1 << MTKCAM_PIPE_RAW_C,
+	RAW_SELECTION_AB_AUTO =
+	(1 << MTKCAM_PIPE_RAW_A | 1 << MTKCAM_PIPE_RAW_B),
+	RAW_SELECTION_AUTO =
+	(1 << MTKCAM_PIPE_RAW_A | 1 << MTKCAM_PIPE_RAW_B | 1 << MTKCAM_PIPE_RAW_C),
+};
+
+static const struct cam_stagger_order stagger_mode_plan[] = {
+	[STAGGER_STREAM_PLAN_OTF_ALL] = {
+		.stagger_select = {
+			{.raw_select = RAW_SELECTION_AUTO, .mode_decision = STAGGER_ON_THE_FLY},
+			{.raw_select = RAW_SELECTION_AUTO, .mode_decision = STAGGER_ON_THE_FLY},
+			{.raw_select = RAW_SELECTION_AUTO, .mode_decision = STAGGER_ON_THE_FLY},
+			{.raw_select = RAW_SELECTION_AUTO, .mode_decision = STAGGER_ON_THE_FLY}
+			} },
+	[STAGGER_STREAM_PLAN_OFF_ALL] = {
+		.stagger_select = {
+			{.raw_select = RAW_SELECTION_C, .mode_decision = STAGGER_OFFLINE},
+			{.raw_select = RAW_SELECTION_C, .mode_decision = STAGGER_OFFLINE},
+			{.raw_select = RAW_SELECTION_C, .mode_decision = STAGGER_OFFLINE},
+			{.raw_select = RAW_SELECTION_C, .mode_decision = STAGGER_OFFLINE}
+			} },
+	[STAGGER_STREAM_PLAN_OTF_DCIF_OFF_2EXP] = {
+		.stagger_select = {
+			{.raw_select = RAW_SELECTION_AUTO, .mode_decision = STAGGER_ON_THE_FLY},
+			{.raw_select = RAW_SELECTION_AUTO, .mode_decision = STAGGER_DCIF},
+			{.raw_select = RAW_SELECTION_AUTO, .mode_decision = STAGGER_OFFLINE},
+			{.raw_select = RAW_SELECTION_AUTO, .mode_decision = STAGGER_OFFLINE}
+			} },
+	[STAGGER_STREAM_PLAN_OTF_DCIF_OFF_3EXP] = {
+		.stagger_select = {
+			{.raw_select = RAW_SELECTION_AB_AUTO, .mode_decision = STAGGER_ON_THE_FLY},
+			{.raw_select = RAW_SELECTION_C, .mode_decision = STAGGER_DCIF},
+			{.raw_select = RAW_SELECTION_AUTO, .mode_decision = STAGGER_OFFLINE},
+			{.raw_select = RAW_SELECTION_AUTO, .mode_decision = STAGGER_OFFLINE}
+			} },
+};
+#endif
+
+static const struct v4l2_mbus_framefmt mfmt_default = {
+	.code = MEDIA_BUS_FMT_SBGGR10_1X10,
+	.width = DEFAULT_WIDTH,
+	.height = DEFAULT_HEIGHT,
+	.field = V4L2_FIELD_NONE,
+	.colorspace = V4L2_COLORSPACE_SRGB,
+	.xfer_func = V4L2_XFER_FUNC_DEFAULT,
+	.ycbcr_enc = V4L2_YCBCR_ENC_DEFAULT,
+	.quantization = V4L2_QUANTIZATION_DEFAULT,
+};
+
+static bool mtk_raw_resource_calc(struct mtk_cam_device *cam,
+	struct mtk_cam_resource_config *res,
+	s64 pixel_rate, int res_plan,
+	int in_w, int in_h, int *out_w, int *out_h);
+
+static int mtk_raw_get_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct mtk_cam_resource *user_res;
+	struct mtk_raw_pipeline *pipeline;
+	struct device *dev;
+	int ret = 0;
+
+	pipeline = mtk_cam_ctrl_handler_to_raw_pipeline(ctrl->handler);
+	dev = pipeline->raw->devs[pipeline->id];
+
+	if (ctrl->id == V4L2_CID_MTK_CAM_RAW_RESOURCE_CALC) {
+		user_res = (struct mtk_cam_resource *)ctrl->p_new.p;
+		user_res->sensor_res = pipeline->user_res.sensor_res;
+		user_res->raw_res = pipeline->user_res.raw_res;
+		if (user_res->sink_fmt)
+			ret = mtk_cam_res_copy_fmt_to_user(pipeline,
+							user_res,
+							(struct v4l2_mbus_framefmt *)pipeline->user_res.sink_fmt);
+	} else if (ctrl->id == V4L2_CID_MTK_CAM_RAW_RESOURCE_UPDATE) {
+		ctrl->val = pipeline->sensor_mode_update;
+		dev_info(dev,
+			 "%s:pipe(%d): V4L2_CID_MTK_CAM_RAW_RESOURCE_UPDATE: %d\n",
+			 __func__, pipeline->id, pipeline->sensor_mode_update);
+	} else if (ctrl->id >= V4L2_CID_MTK_CAM_USED_ENGINE_TRY &&
+	    ctrl->id <= V4L2_CID_MTK_CAM_FRZ_TRY) {
+		/**
+		 * Read the determined resource for the "try" format
+		 * negotiation result
+		 */
+		mutex_lock(&pipeline->try_res_config.resource_lock);
+		switch (ctrl->id) {
+		case V4L2_CID_MTK_CAM_USED_ENGINE_TRY:
+			ctrl->val = pipeline->try_res_config.raw_num_used;
+			break;
+		case V4L2_CID_MTK_CAM_BIN_TRY:
+			ctrl->val = pipeline->try_res_config.bin_enable;
+			break;
+		case V4L2_CID_MTK_CAM_FRZ_TRY:
+			ctrl->val = pipeline->try_res_config.frz_enable ?
+				    pipeline->try_res_config.frz_ratio : 100;
+			break;
+		default:
+			dev_info(dev,
+				 "%s:pipe(%d): unknown resource CID: %d\n",
+				 __func__, pipeline->id, ctrl->id);
+			break;
+		}
+		mutex_unlock(&pipeline->try_res_config.resource_lock);
+	} else if (ctrl->id == V4L2_CID_MTK_CAM_SYNC_ID) {
+		mutex_lock(&pipeline->res_config.resource_lock);
+		*ctrl->p_new.p_s64 = pipeline->sync_id;
+		mutex_unlock(&pipeline->try_res_config.resource_lock);
+	} else {
+		/**
+		 * Read the determined resource for the "set" format
+		 * negotiations result
+		 */
+		mutex_lock(&pipeline->res_config.resource_lock);
+		switch (ctrl->id) {
+		case V4L2_CID_MTK_CAM_USED_ENGINE:
+			ctrl->val = pipeline->res_config.raw_num_used;
+			break;
+		case V4L2_CID_MTK_CAM_BIN_LIMIT:
+			ctrl->val = pipeline->res_config.bin_limit;
+			break;
+		case V4L2_CID_MTK_CAM_BIN:
+			ctrl->val = pipeline->res_config.bin_enable;
+			break;
+		case V4L2_CID_MTK_CAM_FRZ:
+			ctrl->val = pipeline->res_config.frz_enable ?
+				    pipeline->res_config.frz_ratio : 100;
+			break;
+		default:
+			dev_info(dev,
+				 "%s:pipe(%d): unknown try resource CID: %d\n",
+				 __func__, pipeline->id, ctrl->id);
+			break;
+		}
+		mutex_unlock(&pipeline->res_config.resource_lock);
+
+	}
+
+	dev_dbg(dev, "%s:pipe(%d):id(%s) val(%d)\n",
+		__func__, pipeline->id, ctrl->name, ctrl->val);
+	return ret;
+}
+
+#ifdef ISP7_1
+static s64 mtk_cam_get_stagger_path(s64 hw_mode)
+{
+	switch (hw_mode) {
+	case ON_THE_FLY:
+		return STAGGER_ON_THE_FLY;
+	case DCIF:
+		return STAGGER_DCIF;
+	default:
+		break;
+	}
+
+	return STAGGER_ON_THE_FLY;
+}
+#endif
+
+int
+mtk_cam_res_copy_fmt_from_user(struct mtk_raw_pipeline *pipeline,
+								struct mtk_cam_resource *res_user,
+								struct v4l2_mbus_framefmt *dest)
+{
+	long bytes;
+	struct device *dev = pipeline->raw->devs[pipeline->id];
+
+	if (!res_user->sink_fmt) {
+		dev_info(dev,
+			"%s:pipe(%d): sink_fmt can't be NULL for res ctrl\n",
+			__func__, pipeline->id);
+
+		return -EINVAL;
+	}
+
+	bytes = copy_from_user(dest, (void *)res_user->sink_fmt,
+			       sizeof(*dest));
+	if (bytes) {
+		dev_info(dev,
+			"%s:pipe(%d): copy_from_user on sink_fmt failed (%ld)\n",
+			__func__, pipeline->id, bytes);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+int
+mtk_cam_res_copy_fmt_to_user(struct mtk_raw_pipeline *pipeline,
+						struct mtk_cam_resource *res_user,
+						struct v4l2_mbus_framefmt *src)
+{
+	long bytes;
+	struct device *dev = pipeline->raw->devs[pipeline->id];
+
+	/* return the fmt to the users */
+	bytes = copy_to_user((void *)res_user->sink_fmt, src, sizeof(*src));
+	if (bytes) {
+		dev_info(dev,
+			"%s:pipe(%d): copy_to_user on sink_fmt failed (%ld)\n",
+			__func__, pipeline->id, bytes);
+
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int mtk_cam_raw_res_store(struct mtk_raw_pipeline *pipeline,
+			  struct mtk_cam_resource *res_user)
+{
+	struct device *dev = pipeline->raw->devs[pipeline->id];
+
+	dev_info(dev,
+		 "%s:pipe(%d): from user: sensor:%d/%d/%lld/%lld/%d/%d, raw:%lld/%d/%d/%d/%d/%d/%d/%d/%lld\n",
+		__func__, pipeline->id,
+		res_user->sensor_res.hblank, res_user->sensor_res.vblank,
+		res_user->sensor_res.pixel_rate,
+		 res_user->sensor_res.cust_pixel_rate,
+		 res_user->sensor_res.interval.denominator,
+		 res_user->sensor_res.interval.numerator,
+		 res_user->raw_res.feature, res_user->raw_res.bin,
+		 res_user->raw_res.path_sel, res_user->raw_res.raw_max,
+		 res_user->raw_res.raw_min, res_user->raw_res.raw_used,
+		 res_user->raw_res.strategy, res_user->raw_res.pixel_mode,
+		 res_user->raw_res.throughput);
+
+	/* check user value of sensor input parameters */
+	if (!mtk_cam_feature_is_pure_m2m(res_user->raw_res.feature) &&
+		 (!res_user->sensor_res.pixel_rate || !res_user->sensor_res.hblank ||
+		!res_user->sensor_res.vblank ||
+		!res_user->sensor_res.interval.denominator ||
+	    !res_user->sensor_res.interval.numerator)) {
+		dev_info(dev,
+			 "%s:pipe(%d): sensor info MUST be provided (TEST_PATTERN case)\n",
+			 __func__, pipeline->id);
+		/*test pattern case resource default copy*/
+		pipeline->res_config.raw_num_used = 1;
+		pipeline->res_config.bin_enable = 0;
+		pipeline->res_config.tgo_pxl_mode = 1;
+		pipeline->res_config.raw_path = 0;
+		pipeline->res_config.hwn_limit_min = 1;
+		pipeline->res_config.raw_feature = res_user->raw_res.feature;
+		pipeline->feature_pending = res_user->raw_res.feature;
+		pipeline->feature_active = res_user->raw_res.feature;
+		return 0;
+	}
+
+	/* check user value of raw input parameters */
+	if (res_user->raw_res.feature == 0xFFFFFFFF)
+		res_user->raw_res.feature = 0;
+
+	if (res_user->raw_res.bin == 0xFF)
+		res_user->raw_res.bin = 0;
+
+	if (res_user->raw_res.strategy == 0xFFFF)
+		res_user->raw_res.strategy = RESOURCE_STRATEGY_QRP;
+
+	if (res_user->raw_res.raw_max == 0xFF)
+		res_user->raw_res.raw_max = 2;
+
+	if (res_user->raw_res.raw_min == 0xFF)
+		res_user->raw_res.raw_min = 1;
+
+	if (res_user->raw_res.raw_min > 1)
+		res_user->raw_res.strategy = RESOURCE_STRATEGY_QPR;
+
+	if (res_user->raw_res.path_sel == 0xFF)
+		res_user->raw_res.path_sel = 0;
+
+	dev_info(dev,
+		"%s:pipe(%d): driver adjusted: raw:%lld/%d/%d/%d/%d/%d/%d/%d/%lld\n",
+		__func__, pipeline->id,
+		res_user->raw_res.feature, res_user->raw_res.bin,
+		res_user->raw_res.path_sel, res_user->raw_res.raw_max,
+		res_user->raw_res.raw_min, res_user->raw_res.raw_used,
+		res_user->raw_res.strategy, res_user->raw_res.pixel_mode,
+		res_user->raw_res.throughput);
+
+	return 0;
+}
+
+static s64 mtk_cam_calc_pure_m2m_pixelrate(s64 width, s64 height,
+					struct v4l2_fract *interval)
+{
+/* process + r/wdma margin = (1 + 5%) x (1 + 10%) */
+#define PURE_M2M_PROCESS_MARGIN_N 11550
+#define PURE_M2M_PROCESS_MARGIN_D 10000
+	s64 prate = 0;
+	int fps_n = interval->numerator;
+	int fps_d = interval->denominator;
+
+	prate = width * height * fps_d * PURE_M2M_PROCESS_MARGIN_N;
+	do_div(prate, fps_n * PURE_M2M_PROCESS_MARGIN_D);
+
+	pr_info("%s:width:%lld height:%lld interval:%d/%d prate:%lld\n",
+		__func__, width, height, fps_n, fps_d, prate);
+	return prate;
+}
+
+int
+mtk_cam_raw_try_res_ctrl(struct mtk_raw_pipeline *pipeline,
+			 struct mtk_cam_resource *res_user,
+			 struct mtk_cam_resource_config *res_cfg,
+			 struct v4l2_mbus_framefmt *sink_fmt)
+{
+	s64 prate = 0;
+	int width, height;
+	struct device *dev = pipeline->raw->devs[pipeline->id];
+
+	res_cfg->bin_limit = res_user->raw_res.bin; /* 1: force bin on */
+	res_cfg->frz_limit = 0;
+	res_cfg->hwn_limit_max = res_user->raw_res.raw_max;
+	res_cfg->hwn_limit_min = res_user->raw_res.raw_min;
+	res_cfg->hblank = res_user->sensor_res.hblank;
+	res_cfg->vblank = res_user->sensor_res.vblank;
+	res_cfg->sensor_pixel_rate = res_user->sensor_res.pixel_rate;
+	res_cfg->res_plan = res_user->raw_res.strategy;
+	res_cfg->raw_feature = res_user->raw_res.feature;
+	res_cfg->raw_path = res_user->raw_res.path_sel;
+
+	if (res_user->sensor_res.cust_pixel_rate)
+		prate = res_user->sensor_res.cust_pixel_rate;
+	else if (mtk_cam_feature_is_pure_m2m(res_cfg->raw_feature))
+		prate = mtk_cam_calc_pure_m2m_pixelrate(
+				sink_fmt->width, sink_fmt->height,
+				&res_cfg->interval);
+	else
+		prate = mtk_cam_seninf_calc_pixelrate(
+				pipeline->raw->cam_dev, sink_fmt->width,
+				sink_fmt->height,
+				res_user->sensor_res.hblank,
+				res_user->sensor_res.vblank,
+				res_user->sensor_res.interval.denominator,
+				res_user->sensor_res.interval.numerator,
+				res_user->sensor_res.pixel_rate);
+	/*worst case throughput prepare for stagger dynamic switch exposure num*/
+	if (mtk_cam_feature_is_stagger(res_cfg->raw_feature)) {
+		if (mtk_cam_feature_is_2_exposure(res_cfg->raw_feature)) {
+			dev_info(dev,
+			 "%s:pipe(%d): worst case stagger 2exp prate (0x%x):%lld->%lld\n",
+			 __func__, pipeline->id, res_cfg->raw_feature,
+			 prate, prate * 3);
+			prate = 2 * prate;
+		} else if (mtk_cam_feature_is_3_exposure(res_cfg->raw_feature)) {
+			dev_info(dev,
+			 "%s:pipe(%d): worst case stagger 3exp prate (0x%x):%lld->%lld\n",
+			 __func__, pipeline->id, res_cfg->raw_feature,
+			 prate, prate * 3);
+			prate = 3 * prate;
+		}
+	}
+	mtk_raw_resource_calc(dev_get_drvdata(pipeline->raw->cam_dev),
+		res_cfg, prate,
+		res_cfg->res_plan, sink_fmt->width,
+		sink_fmt->height, &width, &height);
+
+	if (res_user->raw_res.bin && !res_cfg->bin_enable) {
+		dev_info(dev,
+			"%s:pipe(%d): res calc failed on fource bin: user(%d)/bin_enable(%d)\n",
+			__func__, pipeline->id,	res_user->raw_res.bin,
+			res_cfg->bin_enable);
+		return -EINVAL;
+	}
+
+	if (res_cfg->raw_num_used > res_user->raw_res.raw_max ||
+		res_cfg->raw_num_used < res_user->raw_res.raw_min) {
+		dev_info(dev,
+			"%s:pipe(%d): res calc failed on raw used: user(%d/%d)/raw_num_used(%d)\n",
+			__func__, pipeline->id, res_user->raw_res.raw_max,
+			res_user->raw_res.raw_min, res_cfg->raw_num_used);
+	}
+
+	res_user->raw_res.pixel_mode = res_cfg->tgo_pxl_mode;
+	res_user->raw_res.raw_used = res_cfg->raw_num_used;
+	if (res_cfg->bin_limit == BIN_AUTO)
+		res_user->raw_res.bin = res_cfg->bin_enable;
+	else
+		res_user->raw_res.bin = res_cfg->bin_limit;
+
+	dev_info(dev,
+		 "%s:pipe(%d): res calc result: raw_used(%d)/bin(%d)/pixelmode(%d)/strategy(%d)\n",
+		 __func__, pipeline->id, res_user->raw_res.raw_used,
+		 res_user->raw_res.bin, res_user->raw_res.pixel_mode,
+		 res_user->raw_res.strategy);
+
+	/**
+	 * Other output not reveal to user now:
+	 * res_cfg->res_strategy[MTK_CAMSYS_RES_STEP_NUM];
+	 * res_cfg->clk_target;
+	 * res_cfg->frz_enable;
+	 * res_cfg->frz_ratio;
+	 * res_cfg->tgo_pxl_mode;
+	 */
+	if (width != sink_fmt->width || height != sink_fmt->height) {
+		dev_info(dev,
+			 "%s:pipe(%d): size adjust info: raw: sink(%d,%d) res:(%d,%d)\n",
+			__func__, pipeline->id, sink_fmt->width,
+			sink_fmt->height, width, height);
+	}
+
+	return 0;
+
+}
+
+static int mtk_cam_raw_set_res_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct mtk_raw_pipeline *pipeline;
+	struct mtk_cam_resource *res_user;
+	struct v4l2_mbus_framefmt sink_fmt;
+	struct device *dev;
+	int ret = 0;
+
+	pipeline = mtk_cam_ctrl_handler_to_raw_pipeline(ctrl->handler);
+	dev = pipeline->raw->devs[pipeline->id];
+	res_user = (struct mtk_cam_resource *)ctrl->p_new.p;
+
+	ret = mtk_cam_raw_res_store(pipeline, res_user);
+	pipeline->user_res = *res_user;
+	if (media_entity_is_streaming(&pipeline->subdev.entity)) {
+		/* If the pipeline is streaming, pending the change */
+		dev_dbg(dev, "%s:pipe(%d): pending res calc has not been supported except bin\n",
+			__func__, pipeline->id);
+		return ret;
+	}
+
+	dev_dbg(dev,
+		"%s:pipe(%d):streaming(%d), feature_pending(0x%llx), raw_res.feature(0x%llx), feature_active(0x%llx)\n",
+		__func__, pipeline->id, media_entity_is_streaming(&pipeline->subdev.entity),
+		pipeline->feature_pending, pipeline->user_res.raw_res.feature,
+		pipeline->feature_active);
+
+	ret = mtk_cam_res_copy_fmt_from_user(pipeline, res_user, &sink_fmt);
+	if (ret)
+		return ret;
+
+	pipeline->res_config.sink_fmt = sink_fmt;
+	ret = mtk_cam_raw_try_res_ctrl(pipeline, res_user,
+				       &pipeline->res_config, &sink_fmt);
+
+	if (ret)
+		return -EINVAL;
+
+	return ret;
+}
+
+static int mtk_raw_set_res_ctrl(struct device *dev, struct v4l2_ctrl *ctrl,
+				struct mtk_cam_resource_config *res_cfg,
+				int pipe_id)
+{
+	int ret = 0;
+	struct mtk_raw_pipeline *pipeline;
+
+	pipeline = mtk_cam_ctrl_handler_to_raw_pipeline(ctrl->handler);
+
+	if (ctrl->type == V4L2_CTRL_TYPE_INTEGER64)
+		dev_dbg(dev, "%s:pipe(%d):(name:%s, val:%lld)\n", __func__,
+			pipe_id, ctrl->name, *ctrl->p_new.p_s64);
+	else
+		dev_dbg(dev, "%s:pipe(%d):(name:%s, val:%d)\n", __func__,
+			pipe_id, ctrl->name, ctrl->val);
+
+	mutex_lock(&res_cfg->resource_lock);
+	switch (ctrl->id) {
+	case V4L2_CID_MTK_CAM_USED_ENGINE_LIMIT:
+		res_cfg->hwn_limit_max = ctrl->val;
+		break;
+	case V4L2_CID_MTK_CAM_BIN_LIMIT:
+		res_cfg->bin_limit = ctrl->val;
+		break;
+	case V4L2_CID_MTK_CAM_FRZ_LIMIT:
+		res_cfg->frz_limit = ctrl->val;
+		break;
+	case V4L2_CID_MTK_CAM_RESOURCE_PLAN_POLICY:
+		res_cfg->res_plan = ctrl->val;
+		break;
+	case V4L2_CID_MTK_CAM_RAW_PATH_SELECT:
+		res_cfg->raw_path = ctrl->val;
+		break;
+	case V4L2_CID_HBLANK:
+		res_cfg->hblank = ctrl->val;
+		break;
+	case V4L2_CID_VBLANK:
+		res_cfg->vblank = ctrl->val;
+		break;
+	case V4L2_CID_MTK_CAM_PIXEL_RATE:
+		res_cfg->sensor_pixel_rate = *ctrl->p_new.p_s64;
+		break;
+	case V4L2_CID_MTK_CAM_SYNC_ID:
+		pipeline->sync_id = *ctrl->p_new.p_s64;
+		break;
+	case V4L2_CID_MTK_CAM_MSTREAM_EXPOSURE:
+		pipeline->mstream_exposure = *(struct mtk_cam_mstream_exposure *)ctrl->p_new.p;
+		pipeline->mstream_exposure.valid = 1;
+		break;
+	default:
+		dev_info(dev,
+			 "%s:pipe(%d):ctrl(id:0x%x,val:%d) not handled\n",
+			 __func__, pipe_id, ctrl->id, ctrl->val);
+		ret = -EINVAL;
+		break;
+	}
+	mutex_unlock(&res_cfg->resource_lock);
+
+	return ret;
+}
+
+static int mtk_raw_try_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct device *dev;
+	struct mtk_raw_pipeline *pipeline;
+	struct mtk_cam_resource *res_user;
+	struct mtk_cam_resource_config res_cfg;
+	int ret = 0;
+
+	pipeline = mtk_cam_ctrl_handler_to_raw_pipeline(ctrl->handler);
+	dev = pipeline->raw->devs[pipeline->id];
+
+	switch (ctrl->id) {
+	case V4L2_CID_MTK_CAM_RAW_RESOURCE_CALC:
+		res_user = (struct mtk_cam_resource *)ctrl->p_new.p;
+		ret = mtk_cam_raw_res_store(pipeline, res_user);
+		if (ret)
+			break;
+
+		ret = mtk_cam_res_copy_fmt_from_user(pipeline, res_user,
+						     &res_cfg.sink_fmt);
+		if (ret) {
+			ret = 0;
+			/* only corret the user's input, it may be request-based try and set fmt */
+			dev_dbg(dev, "%s:pipe(%d): no sink_fmt from user, not calc res\n",
+				__func__, pipeline->id);
+			break;
+		}
+
+		dev_dbg(dev, "%s:pipe(%d): res ctrl start\n", __func__,
+			pipeline->id);
+			ret = mtk_cam_raw_try_res_ctrl(pipeline, res_user, &res_cfg,
+							   &res_cfg.sink_fmt);
+			if (ret)
+				break;
+
+		dev_dbg(dev,
+				"%s:pipe(%d):streaming(%d), feature_pending(0x%llx), feature_active(0x%llx)\n",
+				__func__, pipeline->id, media_entity_is_streaming(&pipeline->subdev.entity),
+				pipeline->feature_pending, pipeline->feature_active);
+
+		dev_dbg(dev, "%s:pipe(%d): res ctrl end\n", __func__,
+			pipeline->id);
+			break;
+	case V4L2_CID_MTK_CAM_RAW_RESOURCE_UPDATE:
+		dev_info(dev,
+				 "%s:pipe(%d): skip V4L2_CID_MTK_CAM_RAW_RESOURCE_UPDATE: %d\n",
+				 __func__, pipeline->id, ctrl->val);
+		ret = 0; /* no support */
+		break;
+	/* skip control value checks */
+	case V4L2_CID_MTK_CAM_MSTREAM_EXPOSURE:
+	case V4L2_CID_MTK_CAM_FEATURE:
+	case V4L2_CID_MTK_CAM_CAMSYS_HW_MODE:
+		ret = 0;
+		break;
+	default:
+		ret = mtk_raw_set_res_ctrl(pipeline->raw->devs[pipeline->id],
+				ctrl,
+				&pipeline->try_res_config,
+				pipeline->id);
+		break;
+	}
+
+	return ret;
+}
+
+static int mtk_raw_set_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct device *dev;
+	struct mtk_raw_pipeline *pipeline;
+	int ret = 0;
+
+	pipeline = mtk_cam_ctrl_handler_to_raw_pipeline(ctrl->handler);
+	dev = pipeline->raw->devs[pipeline->id];
+
+	switch (ctrl->id) {
+	case V4L2_CID_MTK_CAM_RAW_RESOURCE_CALC:
+		/**
+		 * It also updates V4L2_CID_MTK_CAM_FEATURE and
+		 * V4L2_CID_MTK_CAM_RAW_PATH_SELECT to device
+		 */
+		ret = mtk_cam_raw_set_res_ctrl(ctrl);
+		break;
+	case V4L2_CID_MTK_CAM_RAW_RESOURCE_UPDATE:
+		/**
+		 * sensor_mode_update should be reset by driver after the completion of
+		 * resource updating (seamless switch)
+		 */
+		pipeline->sensor_mode_update = ctrl->val;
+		dev_info(dev, "%s:pipe(%d):streaming(%d), sensor_mode_update(%d)\n",
+			 __func__, pipeline->id, media_entity_is_streaming(&pipeline->subdev.entity),
+			 pipeline->sensor_mode_update);
+		break;
+	case V4L2_CID_MTK_CAM_FEATURE:
+		pipeline->feature_pending = *ctrl->p_new.p_s64;
+
+		dev_dbg(dev,
+			"%s:pipe(%d):streaming(%d), feature_pending(0x%llx), feature_active(0x%llx)\n",
+			__func__, pipeline->id, media_entity_is_streaming(&pipeline->subdev.entity),
+			pipeline->feature_pending, pipeline->feature_active);
+		ret = 0;
+		break;
+	case V4L2_CID_MTK_CAM_CAMSYS_HW_MODE:
+		pipeline->hw_mode = *ctrl->p_new.p_s64;
+
+		dev_dbg(dev,
+			"%s:pipe(%d):streaming(%d), hw_mode(0x%llx)\n",
+			__func__, pipeline->id, media_entity_is_streaming(&pipeline->subdev.entity),
+			pipeline->hw_mode);
+
+		ret = 0;
+		break;
+	default:
+		ret = mtk_raw_set_res_ctrl(pipeline->raw->devs[pipeline->id],
+			ctrl, &pipeline->res_config,
+			pipeline->id);
+		break;
+	}
+
+	return ret;
+}
+
+static const struct v4l2_ctrl_ops cam_ctrl_ops = {
+	.g_volatile_ctrl = mtk_raw_get_ctrl,
+	.s_ctrl = mtk_raw_set_ctrl,
+	.try_ctrl = mtk_raw_try_ctrl,
+};
+
+static int mtk_raw_pde_get_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct mtk_raw_pipeline *pipeline;
+	struct mtk_raw_pde_config *pde_cfg;
+	struct mtk_cam_pde_info *pde_info_p;
+	struct device *dev;
+	int ret = 0;
+
+	pipeline = mtk_cam_ctrl_handler_to_raw_pipeline(ctrl->handler);
+	pde_cfg = &pipeline->pde_config;
+	pde_info_p = ctrl->p_new.p;
+	dev = pipeline->raw->devs[pipeline->id];
+
+	switch (ctrl->id) {
+	case V4L2_CID_MTK_CAM_PDE_INFO:
+		pde_info_p->pdo_max_size = pde_cfg->pde_info.pdo_max_size;
+		pde_info_p->pdi_max_size = pde_cfg->pde_info.pdi_max_size;
+		pde_info_p->pd_table_offset = pde_cfg->pde_info.pd_table_offset;
+		break;
+	default:
+		dev_info(dev, "%s(id:0x%x,val:%d) is not handled\n",
+			 __func__, ctrl->id, ctrl->val);
+		ret = -EINVAL;
+	}
+
+	return ret;
+}
+
+static int mtk_raw_pde_set_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct mtk_raw_pipeline *pipeline;
+	struct mtk_raw_pde_config *pde_cfg;
+	struct mtk_cam_pde_info *pde_info_p;
+	struct device *dev;
+	int ret = 0;
+	struct mtk_cam_video_device *node;
+	struct mtk_cam_dev_node_desc *desc;
+	const struct v4l2_format *default_fmt;
+
+	pipeline = mtk_cam_ctrl_handler_to_raw_pipeline(ctrl->handler);
+	pde_cfg = &pipeline->pde_config;
+	pde_info_p = ctrl->p_new.p;
+	dev = pipeline->raw->devs[pipeline->id];
+
+	node = &pipeline->vdev_nodes[MTK_RAW_META_IN - MTK_RAW_SINK_NUM];
+	desc = &node->desc;
+	default_fmt = &desc->fmts[desc->default_fmt_idx].vfmt;
+
+	switch (ctrl->id) {
+	case V4L2_CID_MTK_CAM_PDE_INFO:
+		if (!pde_info_p->pdo_max_size || !pde_info_p->pdi_max_size) {
+			dev_info(dev,
+				 "%s:pdo_max_sz(%d)/pdi_max_sz(%d) cannot be 0\n",
+				 __func__, pde_info_p->pdo_max_size,
+				 pde_info_p->pdi_max_size);
+			ret = -EINVAL;
+			break;
+		}
+
+		pde_cfg->pde_info.pdo_max_size = pde_info_p->pdo_max_size;
+		pde_cfg->pde_info.pdi_max_size = pde_info_p->pdi_max_size;
+		pde_cfg->pde_info.pd_table_offset =
+			default_fmt->fmt.meta.buffersize;
+		break;
+	default:
+		dev_info(dev, "%s(id:0x%x,val:%d) is not handled\n",
+			 __func__, ctrl->id, ctrl->val);
+		ret = -EINVAL;
+	}
+
+	return ret;
+}
+
+static const struct v4l2_ctrl_ops cam_pde_ctrl_ops = {
+	.g_volatile_ctrl = mtk_raw_pde_get_ctrl,
+	.s_ctrl = mtk_raw_pde_set_ctrl,
+	.try_ctrl = mtk_raw_pde_set_ctrl,
+};
+
+static const struct v4l2_ctrl_config hwn_limit = {
+	.ops = &cam_ctrl_ops,
+	.id = V4L2_CID_MTK_CAM_USED_ENGINE_LIMIT,
+	.name = "Engine resource limitation",
+	.type = V4L2_CTRL_TYPE_INTEGER,
+	.min = 1,
+	.max = 2,
+	.step = 1,
+	.def = 2,
+};
+
+static const struct v4l2_ctrl_config bin_limit = {
+	.ops = &cam_ctrl_ops,
+	.id = V4L2_CID_MTK_CAM_BIN_LIMIT,
+	.name = "Binning limitation",
+	.type = V4L2_CTRL_TYPE_INTEGER,
+	.min = 0,
+	.max = 0xfff,
+	.step = 1,
+	.def = 0,
+};
+
+static const struct v4l2_ctrl_config frz_limit = {
+	.ops = &cam_ctrl_ops,
+	.id = V4L2_CID_MTK_CAM_FRZ_LIMIT,
+	.name = "Resizer limitation",
+	.type = V4L2_CTRL_TYPE_INTEGER,
+	.min = 70,
+	.max = 100,
+	.step = 1,
+	.def = 100,
+};
+
+static const struct v4l2_ctrl_config hwn = {
+	.ops = &cam_ctrl_ops,
+	.id = V4L2_CID_MTK_CAM_USED_ENGINE,
+	.name = "Engine resource",
+	.type = V4L2_CTRL_TYPE_INTEGER,
+	.min = 1,
+	.max = 2,
+	.step = 1,
+	.def = 2,
+};
+
+static const struct v4l2_ctrl_config bin = {
+	.ops = &cam_ctrl_ops,
+	.id = V4L2_CID_MTK_CAM_BIN,
+	.name = "Binning",
+	.type = V4L2_CTRL_TYPE_BOOLEAN,
+	.min = 0,
+	.max = 1,
+	.step = 1,
+	.def = 1,
+};
+
+static const struct v4l2_ctrl_config frz = {
+	.ops = &cam_ctrl_ops,
+	.id = V4L2_CID_MTK_CAM_FRZ,
+	.name = "Resizer",
+	.type = V4L2_CTRL_TYPE_INTEGER,
+	.min = 70,
+	.max = 100,
+	.step = 1,
+	.def = 100,
+};
+
+static const struct v4l2_ctrl_config raw_path = {
+	.ops = &cam_ctrl_ops,
+	.id = V4L2_CID_MTK_CAM_RAW_PATH_SELECT,
+	.name = "Raw Path",
+	.type = V4L2_CTRL_TYPE_INTEGER,
+	.min = 0,
+	.max = 1,
+	.step = 1,
+	.def = 1,
+};
+
+static const struct v4l2_ctrl_config hwn_try = {
+	.ops = &cam_ctrl_ops,
+	.id = V4L2_CID_MTK_CAM_USED_ENGINE_TRY,
+	.name = "Engine resource",
+	.type = V4L2_CTRL_TYPE_INTEGER,
+	.min = 1,
+	.max = 2,
+	.step = 1,
+	.def = 2,
+};
+
+static const struct v4l2_ctrl_config bin_try = {
+	.ops = &cam_ctrl_ops,
+	.id = V4L2_CID_MTK_CAM_BIN_TRY,
+	.name = "Binning",
+	.type = V4L2_CTRL_TYPE_BOOLEAN,
+	.min = 0,
+	.max = 1,
+	.step = 1,
+	.def = 1,
+};
+
+static const struct v4l2_ctrl_config frz_try = {
+	.ops = &cam_ctrl_ops,
+	.id = V4L2_CID_MTK_CAM_FRZ_TRY,
+	.name = "Resizer",
+	.type = V4L2_CTRL_TYPE_INTEGER,
+	.min = 70,
+	.max = 100,
+	.step = 1,
+	.def = 100,
+};
+
+static const struct v4l2_ctrl_config res_plan_policy = {
+	.ops = &cam_ctrl_ops,
+	.id = V4L2_CID_MTK_CAM_RESOURCE_PLAN_POLICY,
+	.name = "Resource planning policy",
+	.type = V4L2_CTRL_TYPE_INTEGER,
+	.min = 0,
+	.max = 10,
+	.step = 1,
+	.def = 1,
+};
+
+static const struct v4l2_ctrl_config res_pixel_rate = {
+	.ops = &cam_ctrl_ops,
+	.id = V4L2_CID_MTK_CAM_PIXEL_RATE,
+	.name = "Resource pixel rate",
+	.type = V4L2_CTRL_TYPE_INTEGER64,
+	.min = 0,
+	.max = 0xFFFFFFFF,
+	.step = 1,
+	.def = 0,
+};
+
+static const struct v4l2_ctrl_config frame_sync_id = {
+	.ops = &cam_ctrl_ops,
+	.id = V4L2_CID_MTK_CAM_SYNC_ID,
+	.name = "Frame sync id",
+	.type = V4L2_CTRL_TYPE_INTEGER64,
+	.min = -1,
+	.max = 0x7FFFFFFF,
+	.step = 1,
+	.def = -1,
+};
+
+static const struct v4l2_ctrl_config mtk_feature = {
+	.ops = &cam_ctrl_ops,
+	.id = V4L2_CID_MTK_CAM_FEATURE,
+	.name = "Mediatek camsys feature",
+	.type = V4L2_CTRL_TYPE_INTEGER64,
+	.min = 0,
+	.max = RAW_FUNCTION_END,
+	.step = 1,
+	.def = 0,
+};
+
+static struct v4l2_ctrl_config cfg_res_ctrl = {
+	.ops = &cam_ctrl_ops,
+	.id = V4L2_CID_MTK_CAM_RAW_RESOURCE_CALC,
+	.name = "resource ctrl",
+	.type = V4L2_CTRL_COMPOUND_TYPES, /* V4L2_CTRL_TYPE_U32,*/
+	.flags = V4L2_CTRL_FLAG_EXECUTE_ON_WRITE,
+	.max = 0xffffffff,
+	.step = 1,
+	.dims = {sizeof(struct mtk_cam_resource)},
+};
+
+static struct v4l2_ctrl_config cfg_res_update = {
+	.ops = &cam_ctrl_ops,
+	.id = V4L2_CID_MTK_CAM_RAW_RESOURCE_UPDATE,
+	.name = "resource update",
+	.type = V4L2_CTRL_TYPE_INTEGER,
+	.min = 0,
+	.max = 0xf,
+	.step = 1,
+	.def = 0,
+};
+
+static const struct v4l2_ctrl_config mstream_exposure = {
+	.ops = &cam_ctrl_ops,
+	.id = V4L2_CID_MTK_CAM_MSTREAM_EXPOSURE,
+	.name = "mstream exposure",
+	.type = V4L2_CTRL_TYPE_U32,
+	.flags = V4L2_CTRL_FLAG_EXECUTE_ON_WRITE,
+	.max = 0xFFFFFFFF,
+	.step = 1,
+	.dims = {sizeof_u32(struct mtk_cam_mstream_exposure)},
+};
+
+static const struct v4l2_ctrl_config cfg_pde_info = {
+	.ops = &cam_pde_ctrl_ops,
+	.id = V4L2_CID_MTK_CAM_PDE_INFO,
+	.name = "pde information",
+	.type = V4L2_CTRL_TYPE_INTEGER,
+	.flags = V4L2_CTRL_FLAG_VOLATILE,
+	.min = 0,
+	.max = 0x1fffffff,
+	.step = 1,
+	.def = 0,
+	.dims = {sizeof_u32(struct mtk_cam_pde_info)},
+};
+
+static const struct v4l2_ctrl_config mtk_camsys_hw_mode = {
+	.ops = &cam_ctrl_ops,
+	.id = V4L2_CID_MTK_CAM_CAMSYS_HW_MODE,
+	.name = "Mediatek camsys hardware mode",
+	.type = V4L2_CTRL_TYPE_INTEGER64,
+	.min = 0,
+	.max = 0x7FFFFFFF,
+	.step = 1,
+	.def = DEFAULT,
+};
+
+void trigger_rawi(struct mtk_raw_device *dev, struct mtk_cam_ctx *ctx,
+		signed int hw_scene)
+{
+#define TRIGGER_RAWI_R6 0x10
+#define TRIGGER_RAWI_R2 0x01
+
+	u32 cmd = 0;
+
+	if (mtk_cam_is_stagger_m2m(ctx)) {
+		cmd = TRIGGER_RAWI_R6;
+	} else if (mtk_cam_is_mstream_m2m(ctx)) {
+		if (hw_scene == MTKCAM_IPI_HW_PATH_OFFLINE_M2M)
+			cmd = TRIGGER_RAWI_R2;
+		else if (hw_scene == MTKCAM_IPI_HW_PATH_OFFLINE_STAGGER)
+			cmd = TRIGGER_RAWI_R6;
+		pr_info("mstream %s, cmd:%d\n", __func__, cmd);
+	} else {
+		cmd = TRIGGER_RAWI_R2;
+	}
+
+	writel_relaxed(cmd, dev->base + REG_CTL_RAWI_TRIG);
+	wmb(); /* TBC */
+}
+
+void apply_cq(struct mtk_raw_device *dev,
+	      int initial, dma_addr_t cq_addr,
+	      unsigned int cq_size, unsigned int cq_offset,
+	      unsigned int sub_cq_size, unsigned int sub_cq_offset)
+{
+	/* note: legacy CQ just trigger 1st frame */
+	int trigger = USINGSCQ || initial;
+	dma_addr_t main, sub;
+
+#ifdef ISP7_1
+	dev_dbg(dev->dev,
+		"apply raw%d cq - addr:0x%llx ,size:%d/%d,offset:%d\n",
+		dev->id, cq_addr, cq_size, sub_cq_size, sub_cq_offset);
+#else
+	dev_dbg(dev->dev,
+		"apply raw%d cq - addr:0x%llx ,size:%d/%d,offset:%d, REG_CQ_THR0_CTL:0x%8x\n",
+		dev->id, cq_addr, cq_size, sub_cq_size, sub_cq_offset,
+		readl_relaxed(dev->base + REG_CQ_THR0_CTL));
+#endif
+
+	main = cq_addr + cq_offset;
+	sub = cq_addr + sub_cq_offset;
+
+	writel_relaxed(dmaaddr_lsb(main),
+		       dev->base + REG_CQ_THR0_BASEADDR);
+#ifdef ISP7_1
+	writel_relaxed(dmaaddr_msb(main),
+		       dev->base + REG_CQ_THR0_BASEADDR_MSB);
+#endif
+	writel_relaxed(cq_size,
+		       dev->base + REG_CQ_THR0_DESC_SIZE);
+	writel_relaxed(dmaaddr_lsb(sub),
+		       dev->base + REG_CQ_SUB_THR0_BASEADDR_2);
+#ifdef ISP7_1
+	writel_relaxed(dmaaddr_msb(sub),
+		       dev->base + REG_CQ_SUB_THR0_BASEADDR_MSB_2);
+#endif
+	writel_relaxed(sub_cq_size,
+		       dev->base + REG_CQ_SUB_THR0_DESC_SIZE_2);
+	if (trigger) {
+		writel_relaxed(CAMCTL_CQ_THR0_DONE_ST,
+		       dev->base + REG_CTL_RAW_INT6_EN);
+		writel_relaxed(BIT(10),
+		       dev->base + REG_CTL_RAW_INT7_EN);
+		writel(CTL_CQ_THR0_START, dev->base + REG_CTL_START);
+	}
+
+	wmb(); /* make sure committed */
+}
+
+#ifdef ISP7_1
+/* sw check again for rawi dcif case */
+bool is_dma_idle(struct mtk_raw_device *dev)
+{
+	bool ret = false;
+	int chasing_stat;
+	int raw_rst_stat = readl(dev->base + REG_DMA_SOFT_RST_STAT);
+	int raw_rst_stat2 = readl(dev->base + REG_DMA_SOFT_RST_STAT2);
+	int yuv_rst_stat = readl(dev->yuv_base + REG_DMA_SOFT_RST_STAT);
+
+	if (raw_rst_stat2 != 0x7 || yuv_rst_stat != 0xfffffff)
+		return false;
+
+	/* check beside rawi_r2/r3/r5*/
+	if (~raw_rst_stat & 0x7fffffda)
+		return false;
+
+	if (~raw_rst_stat & RST_STAT_RAWI_R2) { /* RAWI_R2 */
+		chasing_stat = readl(dev->base + REG_DMA_DBG_CHASING_STATUS);
+		ret = ((chasing_stat & RAWI_R2_SMI_REQ_ST) == 0 &&
+		 (readl(dev->base + REG_RAWI_R2_BASE + DMA_OFFSET_SPECIAL_DCIF)
+			& DC_CAMSV_STAGER_EN) &&
+		 (readl(dev->base + REG_CTL_MOD6_EN) & 0x1))
+			? true:false;
+		dev_info(dev->dev, "%s: chasing_stat: 0x%x ret=%d\n",
+				__func__, chasing_stat, ret);
+	}
+	if (~raw_rst_stat & RST_STAT_RAWI_R3) {
+		chasing_stat = readl(dev->base + REG_DMA_DBG_CHASING_STATUS);
+		ret = ((chasing_stat & RAWI_R3_SMI_REQ_ST) == 0 &&
+		 (readl(dev->base + REG_RAWI_R3_BASE + DMA_OFFSET_SPECIAL_DCIF)
+			& DC_CAMSV_STAGER_EN) &&
+		 (readl(dev->base + REG_CTL_MOD6_EN) & 0x80))
+			? true:false;
+		dev_info(dev->dev, "%s: chasing_stat: 0x%x, ret=%d\n",
+				__func__, chasing_stat, ret);
+	}
+	if (~raw_rst_stat & RST_STAT_RAWI_R5) {
+		chasing_stat = readl(dev->base + REG_DMA_DBG_CHASING_STATUS2);
+		ret = ((chasing_stat & RAWI_R5_SMI_REQ_ST) == 0 &&
+		 (readl(dev->base + REG_RAWI_R5_BASE + DMA_OFFSET_SPECIAL_DCIF)
+			& DC_CAMSV_STAGER_EN) &&
+		 (readl(dev->base + REG_CTL_MOD6_EN) & 0x1000))
+			? true:false;
+		dev_info(dev->dev, "%s: chasing_stat: 0x%x, ret=%d\n",
+				__func__, chasing_stat, ret);
+	}
+
+	return ret;
+}
+#endif
+
+void reset(struct mtk_raw_device *dev)
+{
+	int sw_ctl;
+	int ret;
+
+	dev_dbg(dev->dev, "%s\n", __func__);
+
+	/* Disable all DMA DCM before reset */
+	writel(0x00000fff, dev->base + REG_CTL_RAW_MOD5_DCM_DIS);
+	writel(0x0007ffff, dev->base + REG_CTL_RAW_MOD6_DCM_DIS);
+	writel(0xffffffff, dev->yuv_base + REG_CTL_RAW_MOD5_DCM_DIS);
+
+	/* enable CQI_R1 ~ R4 before reset and make sure loaded to inner */
+	writel(readl(dev->base + REG_CTL_MOD6_EN) | 0x78000,
+	       dev->base + REG_CTL_MOD6_EN);
+	toggle_db(dev);
+
+	writel(0, dev->base + REG_CTL_SW_CTL);
+	writel(1, dev->base + REG_CTL_SW_CTL);
+	wmb(); /* make sure committed */
+
+	ret = readx_poll_timeout(readl, dev->base + REG_CTL_SW_CTL, sw_ctl,
+				 sw_ctl & 0x2,
+				 1 /* delay, us */,
+				 5000 /* timeout, us */);
+#ifdef ISP7_1
+	if (ret < 0 && !is_dma_idle(dev)) {
+		dev_info(dev->dev,
+			 "%s: timeout: tg_sen_mode: 0x%x, ctl_en: 0x%x, mod6_en: 0x%x, ctl_sw_ctl:0x%x, frame_no:0x%x,rst_stat:0x%x,rst_stat2:0x%x,yuv_rst_stat:0x%x\n",
+			 __func__,
+			 readl(dev->base + REG_TG_SEN_MODE),
+			 readl(dev->base + REG_CTL_EN),
+			 readl(dev->base + REG_CTL_MOD6_EN),
+			 readl(dev->base + REG_CTL_SW_CTL),
+			 readl(dev->base + REG_FRAME_SEQ_NUM),
+			 readl(dev->base + REG_DMA_SOFT_RST_STAT),
+			 readl(dev->base + REG_DMA_SOFT_RST_STAT2),
+			 readl(dev->yuv_base + REG_DMA_SOFT_RST_STAT));
+#else
+	if (ret < 0) {
+		dev_info(dev->dev,
+			 "%s: timeout: tg_sen_mode: 0x%x, ctl_en: 0x%x, mod6_en: 0x%x, ctl_sw_ctl:0x%x, frame_no:0x%x,rst_stat:0x%x, yuv_rst_stat:0x%x\n",
+			 __func__,
+			 readl(dev->base + REG_TG_SEN_MODE),
+			 readl(dev->base + REG_CTL_EN),
+			 readl(dev->base + REG_CTL_MOD6_EN),
+			 readl(dev->base + REG_CTL_SW_CTL),
+			 readl(dev->base + REG_FRAME_SEQ_NUM),
+			 readl(dev->base + REG_DMA_SOFT_RST_STAT),
+			 readl(dev->yuv_base + REG_DMA_SOFT_RST_STAT));
+#endif
+
+		goto RESET_FAILURE;
+	}
+
+	/* do hw rst */
+	writel(4, dev->base + REG_CTL_SW_CTL);
+	writel(0, dev->base + REG_CTL_SW_CTL);
+
+RESET_FAILURE:
+	/* Enable all DMA DCM back */
+	writel(0x0, dev->base + REG_CTL_RAW_MOD5_DCM_DIS);
+	writel(0x0, dev->base + REG_CTL_RAW_MOD6_DCM_DIS);
+	writel(0x0, dev->yuv_base + REG_CTL_RAW_MOD5_DCM_DIS);
+
+	wmb(); /* make sure committed */
+}
+
+static void reset_reg(struct mtk_raw_device *dev)
+{
+	int cq_en, sw_done;
+
+	dev_dbg(dev->dev,
+			 "[%s++] CQ_EN/SW_SUB_CTL/SW_DONE [in] 0x%x/0x%x/0x%x [out] 0x%x/0x%x/0x%x\n",
+			 __func__,
+			 readl_relaxed(dev->base_inner + REG_CQ_EN),
+			 readl_relaxed(dev->base_inner + REG_CTL_SW_SUB_CTL),
+			 readl_relaxed(dev->base_inner + REG_CTL_SW_PASS1_DONE),
+			 readl_relaxed(dev->base + REG_CQ_EN),
+			 readl_relaxed(dev->base + REG_CTL_SW_SUB_CTL),
+			 readl_relaxed(dev->base + REG_CTL_SW_PASS1_DONE));
+
+	cq_en = readl_relaxed(dev->base_inner + REG_CQ_EN);
+	sw_done = readl_relaxed(dev->base_inner + REG_CTL_SW_PASS1_DONE);
+
+	cq_en = cq_en & (~SCQ_SUBSAMPLE_EN) & (~SCQ_STAGGER_MODE);
+	writel(cq_en, dev->base_inner + REG_CQ_EN);
+	writel(cq_en, dev->base + REG_CQ_EN);
+
+	dev_dbg(dev->dev, "[--] try to disable SCQ_STAGGER_MODE: CQ_EN(0x%x)\n",
+		cq_en);
+
+	writel(sw_done & (~SW_DONE_SAMPLE_EN), dev->base_inner + REG_CTL_SW_PASS1_DONE);
+	writel(sw_done & (~SW_DONE_SAMPLE_EN), dev->base + REG_CTL_SW_PASS1_DONE);
+
+	writel(0, dev->base_inner + REG_CTL_SW_SUB_CTL);
+	writel(0, dev->base + REG_CTL_SW_SUB_CTL);
+
+	wmb(); /* make sure committed */
+
+	dev_dbg(dev->dev,
+			 "[%s--] CQ_EN/SW_SUB_CTL/SW_DONE [in] 0x%x/0x%x/0x%x [out] 0x%x/0x%x/0x%x\n",
+			 __func__,
+			 readl_relaxed(dev->base_inner + REG_CQ_EN),
+			 readl_relaxed(dev->base_inner + REG_CTL_SW_SUB_CTL),
+			 readl_relaxed(dev->base_inner + REG_CTL_SW_PASS1_DONE),
+			 readl_relaxed(dev->base + REG_CQ_EN),
+			 readl_relaxed(dev->base + REG_CTL_SW_SUB_CTL),
+			 readl_relaxed(dev->base + REG_CTL_SW_PASS1_DONE));
+}
+
+void dump_aa_info(struct mtk_cam_ctx *ctx,
+					struct mtk_ae_debug_data *ae_info)
+{
+	struct mtk_raw_device *raw_dev = NULL;
+	struct mtk_raw_pipeline *pipe = ctx->pipe;
+	int i;
+
+	for (i = 0; i < ctx->cam->num_raw_devices; i++) {
+		if (pipe->enabled_raw & (1 << i)) {
+			struct device *dev = ctx->cam->raw.devs[i];
+
+			raw_dev = dev_get_drvdata(dev);
+			ae_info->OBC_R1_Sum[0] +=
+				((u64)readl(raw_dev->base + OFFSET_OBC_R1_R_SUM_H) << 32) |
+				readl(raw_dev->base + OFFSET_OBC_R1_R_SUM_L);
+			ae_info->OBC_R2_Sum[0] +=
+				((u64)readl(raw_dev->base + OFFSET_OBC_R2_R_SUM_H) << 32) |
+				readl(raw_dev->base + OFFSET_OBC_R2_R_SUM_L);
+			ae_info->OBC_R3_Sum[0] +=
+				((u64)readl(raw_dev->base + OFFSET_OBC_R3_R_SUM_H) << 32) |
+				readl(raw_dev->base + OFFSET_OBC_R3_R_SUM_L);
+			ae_info->LTM_Sum[0] +=
+				((u64)readl(raw_dev->base + REG_LTM_AE_DEBUG_R_MSB) << 32) |
+				readl(raw_dev->base + REG_LTM_AE_DEBUG_R_LSB);
+			ae_info->AA_Sum[0] +=
+				((u64)readl(raw_dev->base + REG_AA_R_SUM_H) << 32) |
+				readl(raw_dev->base + REG_AA_R_SUM_L);
+
+			ae_info->OBC_R1_Sum[1] +=
+				((u64)readl(raw_dev->base + OFFSET_OBC_R1_B_SUM_H) << 32) |
+				readl(raw_dev->base + OFFSET_OBC_R1_B_SUM_L);
+			ae_info->OBC_R2_Sum[1] +=
+				((u64)readl(raw_dev->base + OFFSET_OBC_R2_B_SUM_H) << 32) |
+				readl(raw_dev->base + OFFSET_OBC_R2_B_SUM_L);
+			ae_info->OBC_R3_Sum[1] +=
+				((u64)readl(raw_dev->base + OFFSET_OBC_R3_B_SUM_H) << 32) |
+				readl(raw_dev->base + OFFSET_OBC_R3_B_SUM_L);
+			ae_info->LTM_Sum[1] +=
+				((u64)readl(raw_dev->base + REG_LTM_AE_DEBUG_B_MSB) << 32) |
+				readl(raw_dev->base + REG_LTM_AE_DEBUG_B_LSB);
+			ae_info->AA_Sum[1] +=
+				((u64)readl(raw_dev->base + REG_AA_B_SUM_H) << 32) |
+				readl(raw_dev->base + REG_AA_B_SUM_L);
+
+			ae_info->OBC_R1_Sum[2] +=
+				((u64)readl(raw_dev->base + OFFSET_OBC_R1_GR_SUM_H) << 32) |
+				readl(raw_dev->base + OFFSET_OBC_R1_GR_SUM_L);
+			ae_info->OBC_R2_Sum[2] +=
+				((u64)readl(raw_dev->base + OFFSET_OBC_R2_GR_SUM_H) << 32) |
+				readl(raw_dev->base + OFFSET_OBC_R2_GR_SUM_L);
+			ae_info->OBC_R3_Sum[2] +=
+				((u64)readl(raw_dev->base + OFFSET_OBC_R3_GR_SUM_H) << 32) |
+				readl(raw_dev->base + OFFSET_OBC_R3_GR_SUM_L);
+			ae_info->LTM_Sum[2] +=
+				((u64)readl(raw_dev->base + REG_LTM_AE_DEBUG_GR_MSB) << 32) |
+				readl(raw_dev->base + REG_LTM_AE_DEBUG_GR_LSB);
+			ae_info->AA_Sum[2] +=
+				((u64)readl(raw_dev->base + REG_AA_GR_SUM_H) << 32) |
+				readl(raw_dev->base + REG_AA_GR_SUM_L);
+
+			ae_info->OBC_R1_Sum[3] +=
+				((u64)readl(raw_dev->base + OFFSET_OBC_R1_GB_SUM_H) << 32) |
+				readl(raw_dev->base + OFFSET_OBC_R1_GB_SUM_L);
+			ae_info->OBC_R2_Sum[3] +=
+				((u64)readl(raw_dev->base + OFFSET_OBC_R2_GB_SUM_H) << 32) |
+				readl(raw_dev->base + OFFSET_OBC_R2_GB_SUM_L);
+			ae_info->OBC_R3_Sum[3] +=
+				((u64)readl(raw_dev->base + OFFSET_OBC_R3_GB_SUM_H) << 32) |
+				readl(raw_dev->base + OFFSET_OBC_R3_GB_SUM_L);
+			ae_info->LTM_Sum[3] +=
+				((u64)readl(raw_dev->base + REG_LTM_AE_DEBUG_GB_MSB) << 32) |
+				readl(raw_dev->base + REG_LTM_AE_DEBUG_GB_LSB);
+			ae_info->AA_Sum[3] +=
+				((u64)readl(raw_dev->base + REG_AA_GB_SUM_H) << 32) |
+				readl(raw_dev->base + REG_AA_GB_SUM_L);
+		}
+	}
+}
+
+static int reset_msgfifo(struct mtk_raw_device *dev)
+{
+	atomic_set(&dev->is_fifo_overflow, 0);
+	return kfifo_init(&dev->msg_fifo, dev->msg_buffer, dev->fifo_size);
+}
+
+static int push_msgfifo(struct mtk_raw_device *dev,
+			struct mtk_camsys_irq_info *info)
+{
+	int len;
+
+	if (unlikely(kfifo_avail(&dev->msg_fifo) < sizeof(*info))) {
+		atomic_set(&dev->is_fifo_overflow, 1);
+		return -1;
+	}
+
+	len = kfifo_in(&dev->msg_fifo, info, sizeof(*info));
+	WARN_ON(len != sizeof(*info));
+
+	return 0;
+}
+
+#define FIFO_THRESHOLD(FIFO_SIZE, HEIGHT_RATIO, LOW_RATIO) \
+	(((FIFO_SIZE * HEIGHT_RATIO) & 0xFFF) << 16 | \
+	((FIFO_SIZE * LOW_RATIO) & 0xFFF))
+
+void set_fifo_size(void __iomem *dma_base, int fifo_size)
+{
+	writel_relaxed((0x1 << 28) | (fifo_size & 0xFFF),
+			dma_base + DMA_OFFSET_CON0);
+}
+
+static void set_fifo_threshold(void __iomem *dma_base)
+{
+	int fifo_size = 0;
+
+	fifo_size = readl_relaxed(dma_base + DMA_OFFSET_CON0) & 0xFFF;
+	writel_relaxed((0x1 << 28) | FIFO_THRESHOLD(fifo_size, 1/4, 1/8),
+			dma_base + DMA_OFFSET_CON1);
+	writel_relaxed((0x1 << 28) | FIFO_THRESHOLD(fifo_size, 1/2, 3/8),
+			dma_base + DMA_OFFSET_CON2);
+	writel_relaxed((0x1 << 31) | FIFO_THRESHOLD(fifo_size, 2/3, 13/24),
+			dma_base + DMA_OFFSET_CON3);
+	writel_relaxed((0x1 << 31) | FIFO_THRESHOLD(fifo_size, 3/8, 1/4),
+			dma_base + DMA_OFFSET_CON4);
+}
+
+void toggle_db(struct mtk_raw_device *dev)
+{
+	int value;
+	u32 val_cfg, val_dcif_ctl, val_sen;
+
+	value = readl_relaxed(dev->base + REG_CTL_MISC);
+	val_cfg = readl_relaxed(dev->base_inner + REG_TG_PATH_CFG);
+	val_dcif_ctl = readl_relaxed(dev->base_inner + REG_TG_DCIF_CTL);
+	val_sen = readl_relaxed(dev->base_inner + REG_TG_SEN_MODE);
+	writel_relaxed(value & ~CTL_DB_EN, dev->base + REG_CTL_MISC);
+	wmb(); /* TBC */
+	writel_relaxed(value | CTL_DB_EN, dev->base + REG_CTL_MISC);
+	wmb(); /* TBC */
+	dev_info(dev->dev, "%s,  read inner AsIs->ToBe TG_PATH_CFG:0x%x->0x%x, TG_DCIF:0x%x->0x%x, TG_SEN:0x%x->0x%x\n",
+		__func__,
+			val_cfg,
+			readl_relaxed(dev->base_inner + REG_TG_PATH_CFG),
+			val_dcif_ctl,
+			readl_relaxed(dev->base_inner + REG_TG_DCIF_CTL),
+			val_sen,
+			readl_relaxed(dev->base_inner + REG_TG_SEN_MODE));
+}
+
+void enable_tg_db(struct mtk_raw_device *dev, int en)
+{
+	int value;
+	u32 val_cfg, val_dcif_ctl, val_sen;
+
+	value = readl_relaxed(dev->base_inner + REG_TG_PATH_CFG);
+	if (en == 0) { /*disable tg db*/
+		val_cfg = readl_relaxed(dev->base_inner + REG_TG_PATH_CFG);
+		val_dcif_ctl = readl_relaxed(dev->base_inner + REG_TG_DCIF_CTL);
+		val_sen = readl_relaxed(dev->base_inner + REG_TG_SEN_MODE);
+		writel_relaxed(value | TG_DB_LOAD_DIS, dev->base + REG_TG_PATH_CFG);
+		wmb(); /* TBC */
+		dev_dbg(dev->dev, "%s disable,  TG_PATH_CFG:0x%x->0x%x, TG_DCIF:0x%x->0x%x, TG_SEN:0x%x->0x%x\n",
+		__func__,
+			val_cfg,
+			readl_relaxed(dev->base_inner + REG_TG_PATH_CFG),
+			val_dcif_ctl,
+			readl_relaxed(dev->base_inner + REG_TG_DCIF_CTL),
+			val_sen,
+			readl_relaxed(dev->base_inner + REG_TG_SEN_MODE));
+	} else { /*enable tg db*/
+		writel_relaxed(value & ~TG_DB_LOAD_DIS, dev->base + REG_TG_PATH_CFG);
+		wmb(); /* TBC */
+		dev_dbg(dev->dev, "%s enable, TG_PATH_CFG:0x%x\n", __func__, value);
+	}
+}
+
+static void init_dma_threshold(struct mtk_raw_device *dev)
+{
+	struct mtk_cam_device *cam_dev;
+
+	cam_dev = dev->cam;
+
+	/* work around mt8188 hw default fifo size value error */
+	set_fifo_size(dev->base + REG_IMGO_R1_BASE, 0x3C0);
+	set_fifo_size(dev->yuv_base + REG_YUVCO_R1_BASE, 0x200);
+	set_fifo_size(dev->yuv_base + REG_YUVDO_R1_BASE, 0x80);
+	set_fifo_size(dev->yuv_base + REG_YUVO_R3_BASE, 0xc0);
+	set_fifo_size(dev->yuv_base + REG_YUVBO_R3_BASE, 0x60);
+	set_fifo_size(dev->yuv_base + REG_YUVCO_R3_BASE, 0x40);
+	set_fifo_size(dev->yuv_base + REG_YUVO_R2_BASE, 0x80);
+	set_fifo_size(dev->yuv_base + REG_YUVBO_R2_BASE, 0x40);
+	set_fifo_size(dev->yuv_base + REG_YUVO_R4_BASE, 0x40);
+	set_fifo_size(dev->yuv_base + REG_YUVBO_R4_BASE, 0x40);
+	set_fifo_size(dev->yuv_base + REG_YUVO_R5_BASE, 0x40);
+	set_fifo_threshold(dev->base + REG_IMGO_R1_BASE);
+	set_fifo_threshold(dev->base + REG_FHO_R1_BASE);
+	set_fifo_threshold(dev->base + REG_AAHO_R1_BASE);
+	set_fifo_threshold(dev->base + REG_PDO_R1_BASE);
+	set_fifo_threshold(dev->base + REG_AAO_R1_BASE);
+	set_fifo_threshold(dev->base + REG_AFO_R1_BASE);
+	set_fifo_threshold(dev->base + REG_PDO_R1_BASE);
+
+	set_fifo_threshold(dev->yuv_base + REG_YUVO_R1_BASE);
+	set_fifo_threshold(dev->yuv_base + REG_YUVBO_R1_BASE);
+	set_fifo_threshold(dev->yuv_base + REG_YUVCO_R1_BASE);
+	set_fifo_threshold(dev->yuv_base + REG_YUVDO_R1_BASE);
+	set_fifo_threshold(dev->yuv_base + REG_YUVO_R3_BASE);
+	set_fifo_threshold(dev->yuv_base + REG_YUVBO_R3_BASE);
+	set_fifo_threshold(dev->yuv_base + REG_YUVCO_R3_BASE);
+	set_fifo_threshold(dev->yuv_base + REG_LTMSO_R1_BASE);
+	set_fifo_threshold(dev->yuv_base + REG_TSFSO_R1_BASE);
+	set_fifo_threshold(dev->yuv_base + REG_TSFSO_R2_BASE);
+	set_fifo_threshold(dev->yuv_base + REG_FLKO_R1_BASE);
+	set_fifo_threshold(dev->yuv_base + REG_UFEO_R1_BASE);
+	set_fifo_threshold(dev->yuv_base + REG_YUVO_R2_BASE);
+	set_fifo_threshold(dev->yuv_base + REG_YUVBO_R2_BASE);
+	set_fifo_threshold(dev->yuv_base + REG_YUVO_R4_BASE);
+	set_fifo_threshold(dev->yuv_base + REG_YUVBO_R4_BASE);
+	set_fifo_threshold(dev->yuv_base + REG_YUVO_R5_BASE);
+	set_fifo_threshold(dev->yuv_base + REG_YUVBO_R5_BASE);
+	set_fifo_threshold(dev->yuv_base + REG_RZH1N2TO_R1_BASE);
+	set_fifo_threshold(dev->yuv_base + REG_RZH1N2TBO_R1_BASE);
+	set_fifo_threshold(dev->yuv_base + REG_RZH1N2TO_R2_BASE);
+	set_fifo_threshold(dev->yuv_base + REG_RZH1N2TO_R3_BASE);
+	set_fifo_threshold(dev->yuv_base + REG_RZH1N2TBO_R3_BASE);
+	set_fifo_threshold(dev->yuv_base + REG_DRZS4NO_R1_BASE);
+	set_fifo_threshold(dev->yuv_base + REG_DRZS4NO_R2_BASE);
+	set_fifo_threshold(dev->yuv_base + REG_DRZS4NO_R3_BASE);
+	set_fifo_threshold(dev->yuv_base + REG_ACTSO_R1_BASE);
+	set_fifo_threshold(dev->yuv_base + REG_TNCSO_R1_BASE);
+	set_fifo_threshold(dev->yuv_base + REG_TNCSBO_R1_BASE);
+	set_fifo_threshold(dev->yuv_base + REG_TNCSHO_R1_BASE);
+	set_fifo_threshold(dev->yuv_base + REG_TNCSYO_R1_BASE);
+
+	set_fifo_threshold(dev->base + REG_RAWI_R2_BASE);
+	set_fifo_threshold(dev->base + REG_UFDI_R2_BASE);
+	set_fifo_threshold(dev->base + REG_RAWI_R3_BASE);
+	set_fifo_threshold(dev->base + REG_UFDI_R3_BASE);
+	set_fifo_threshold(dev->base + REG_CQI_R1_BASE);
+	set_fifo_threshold(dev->base + REG_CQI_R2_BASE);
+	set_fifo_threshold(dev->base + REG_CQI_R3_BASE);
+	set_fifo_threshold(dev->base + REG_CQI_R4_BASE);
+	set_fifo_threshold(dev->base + REG_LSCI_R1_BASE);
+	set_fifo_threshold(dev->base + REG_BPCI_R1_BASE);
+	set_fifo_threshold(dev->base + REG_BPCI_R2_BASE);
+	set_fifo_threshold(dev->base + REG_BPCI_R3_BASE);
+	set_fifo_threshold(dev->base + REG_PDI_R1_BASE);
+	set_fifo_threshold(dev->base + REG_AAI_R1_BASE);
+	set_fifo_threshold(dev->base + REG_CACI_R1_BASE);
+	set_fifo_threshold(dev->base + REG_RAWI_R6_BASE);
+
+	writel_relaxed(0x1, cam_dev->base + REG_HALT1_EN);
+	writel_relaxed(0x1, cam_dev->base + REG_HALT2_EN);
+	writel_relaxed(0x1, cam_dev->base + REG_HALT3_EN);
+	writel_relaxed(0x1, cam_dev->base + REG_HALT4_EN);
+	writel_relaxed(0x1, cam_dev->base + REG_HALT5_EN);
+	writel_relaxed(0x1, cam_dev->base + REG_HALT6_EN);
+	writel_relaxed(0x1, cam_dev->base + REG_ULTRA_HALT1_EN);
+	writel_relaxed(0x1, cam_dev->base + REG_ULTRA_HALT2_EN);
+	writel_relaxed(0x1, cam_dev->base + REG_ULTRA_HALT3_EN);
+	writel_relaxed(0x1, cam_dev->base + REG_ULTRA_HALT4_EN);
+	writel_relaxed(0x1, cam_dev->base + REG_ULTRA_HALT5_EN);
+	writel_relaxed(0x1, cam_dev->base + REG_ULTRA_HALT6_EN);
+	writel_relaxed(0x1, cam_dev->base + REG_PREULTRA_HALT1_EN);
+	writel_relaxed(0x1, cam_dev->base + REG_PREULTRA_HALT2_EN);
+	writel_relaxed(0x1, cam_dev->base + REG_PREULTRA_HALT3_EN);
+	writel_relaxed(0x1, cam_dev->base + REG_PREULTRA_HALT4_EN);
+	writel_relaxed(0x1, cam_dev->base + REG_PREULTRA_HALT5_EN);
+	writel_relaxed(0x1, cam_dev->base + REG_PREULTRA_HALT6_EN);
+
+}
+
+static int get_fps_ratio(struct mtk_raw_device *dev)
+{
+	int fps = (dev->pipeline->res_config.interval.numerator > 0) ?
+			(dev->pipeline->res_config.interval.denominator /
+			dev->pipeline->res_config.interval.numerator) : 0;
+
+	if (fps <= 30)
+		return 1;
+	else if (fps <= 60)
+		return 2;
+	else
+		return 1;
+}
+
+int mtk_cam_get_subsample_ratio(int raw_feature)
+{
+	switch (raw_feature & MTK_CAM_FEATURE_SUBSAMPLE_MASK) {
+	case HIGHFPS_2_SUBSAMPLE:
+		return 1;
+	case HIGHFPS_4_SUBSAMPLE:
+		return 3;
+	case HIGHFPS_8_SUBSAMPLE:
+		return 7;
+	case HIGHFPS_16_SUBSAMPLE:
+		return 15;
+	case HIGHFPS_32_SUBSAMPLE:
+		return 31;
+	default:
+		return 0;
+	}
+}
+
+void stagger_enable(struct mtk_raw_device *dev)
+{
+	u32 val;
+
+	val = readl_relaxed(dev->base + REG_CQ_EN);
+	writel_relaxed(val | SCQ_STAGGER_MODE, dev->base + REG_CQ_EN);
+	wmb(); /* TBC */
+	dev->stagger_en = 1;
+	dev_dbg(dev->dev, "%s - CQ_EN:0x%x->0x%x, TG_PATH_CFG:0x%x, TG_DCIF:0x%x, TG_SEN:0x%x\n",
+		__func__, val,
+		readl_relaxed(dev->base + REG_CQ_EN),
+		readl_relaxed(dev->base + REG_TG_PATH_CFG),
+		readl_relaxed(dev->base + REG_TG_DCIF_CTL),
+		readl_relaxed(dev->base + REG_TG_SEN_MODE));
+}
+
+void stagger_disable(struct mtk_raw_device *dev)
+{
+	u32 val = readl_relaxed(dev->base + REG_CQ_EN);
+
+	writel_relaxed(val & (~SCQ_STAGGER_MODE), dev->base + REG_CQ_EN);
+	wmb(); /* TBC */
+	dev->stagger_en = 0;
+	dev_dbg(dev->dev, "%s - CQ_EN:0x%x->0x%x, TG_PATH_CFG:0x%x, TG_DCIF:0x%x, TG_SEN:0x%x\n",
+		__func__,
+			val,
+		readl_relaxed(dev->base + REG_CQ_EN),
+		readl_relaxed(dev->base + REG_TG_PATH_CFG),
+		readl_relaxed(dev->base + REG_TG_DCIF_CTL),
+		readl_relaxed(dev->base + REG_TG_SEN_MODE));
+}
+
+static void subsample_set_sensor_time(struct mtk_raw_device *dev)
+{
+	dev->sub_sensor_ctrl_en = true;
+	dev->set_sensor_idx =
+		mtk_cam_get_subsample_ratio(dev->pipeline->feature_active) - 1;
+	dev->cur_vsync_idx = -1;
+}
+
+void subsample_enable(struct mtk_raw_device *dev)
+{
+	u32 val;
+	u32 sub_ratio = mtk_cam_get_subsample_ratio(
+			dev->pipeline->feature_active);
+
+	subsample_set_sensor_time(dev);
+
+	val = readl_relaxed(dev->base + REG_CQ_EN);
+	writel_relaxed(val | SCQ_SUBSAMPLE_EN, dev->base + REG_CQ_EN);
+	writel_relaxed(SW_DONE_SAMPLE_EN | sub_ratio,
+		dev->base + REG_CTL_SW_PASS1_DONE);
+	writel_relaxed(SW_DONE_SAMPLE_EN | sub_ratio,
+		dev->base_inner + REG_CTL_SW_PASS1_DONE);
+	wmb(); /* TBC */
+	dev_dbg(dev->dev, "%s - REG_CQ_EN:0x%x ,REG_CTL_SW_PASS1_DONE:0x%8x\n",
+			__func__,
+			readl_relaxed(dev->base + REG_CQ_EN),
+			readl_relaxed(dev->base + REG_CTL_SW_PASS1_DONE));
+}
+
+void initialize(struct mtk_raw_device *dev, int is_sub)
+{
+#if USINGSCQ
+	u32 val;
+
+	val = readl_relaxed(dev->base + REG_CQ_EN);
+	writel_relaxed(val | SCQ_EN, dev->base + REG_CQ_EN);
+
+	//writel_relaxed(0x100010, dev->base + REG_CQ_EN);
+	writel_relaxed(0xffffffff, dev->base + REG_SCQ_START_PERIOD);
+#endif
+
+	writel_relaxed(CQ_THR0_MODE_IMMEDIATE | CQ_THR0_EN,
+		       dev->base + REG_CQ_THR0_CTL);
+	writel_relaxed(CQ_THR0_MODE_IMMEDIATE | CQ_THR0_EN,
+		       dev->base + REG_CQ_SUB_THR0_CTL);
+	writel_relaxed(CAMCTL_CQ_THR0_DONE_ST, dev->base + REG_CTL_RAW_INT6_EN);
+#ifdef ISP7_1
+	writel_relaxed(BIT(10), dev->base + REG_CTL_RAW_INT7_EN);
+#endif
+
+	dev->is_sub = is_sub;
+	dev->sof_count = 0;
+	dev->vsync_count = 0;
+	dev->sub_sensor_ctrl_en = false;
+	dev->time_shared_busy = 0;
+	atomic_set(&dev->vf_en, 0);
+	dev->stagger_en = 0;
+	reset_msgfifo(dev);
+
+	init_dma_threshold(dev);
+
+	/* Workaround: disable FLKO error_sof: double sof error
+	 *   HW will send FLKO dma error when
+	 *      FLKO rcnt = 0 (not going to output this frame)
+	 *      However, HW_PASS1_DONE still comes as expected
+	 */
+	writel_relaxed(0xFFFE0000,
+		       dev->base + REG_FLKO_R1_BASE + DMA_OFFSET_ERR_STAT);
+
+	dev_dbg(dev->dev, "%s - REG_CQ_EN:0x%x ,REG_CQ_THR0_CTL:0x%8x\n",
+		__func__,
+			readl_relaxed(dev->base + REG_CQ_EN),
+			readl_relaxed(dev->base + REG_CQ_THR0_CTL));
+
+}
+
+static void immediate_stream_off_log(struct mtk_raw_device *dev, char *reg_name,
+				     void __iomem *base,
+				     void __iomem *base_inner,
+				     u32 offset, u32 cur_val, u32 cfg_val)
+{
+	u32 read_val, read_val_2;
+
+	read_val = readl_relaxed(base_inner + offset);
+	read_val_2 = readl_relaxed(base + offset);
+	dev_dbg(dev->dev,
+		"%s:%s: before: r(0x%x), w(0x%x), after:inner(0x%x),outer(0x%x)\n",
+		__func__, reg_name, cur_val, cfg_val,
+		read_val, read_val_2);
+}
+
+void immediate_stream_off(struct mtk_raw_device *dev)
+
+{
+	u32 chk_val, cur_val, cfg_val;
+	u32 offset;
+
+	atomic_set(&dev->vf_en, 0);
+
+
+	writel_relaxed((u32)~CQ_THR0_EN, dev->base + REG_CQ_THR0_CTL);
+	wmb(); /* make sure committed */
+
+	/* Disable Double Buffer */
+	offset = REG_TG_PATH_CFG;
+	cur_val = readl_relaxed(dev->base + offset);
+	cfg_val = cur_val | 0x100; /* clear TG_DB_LOAD_DIS */
+	writel(cfg_val, dev->base + offset); // has double buffer
+	wmb(); /* make sure committed */
+	immediate_stream_off_log(dev, "TG_PATH_CFG", dev->base, dev->base_inner,
+				 offset, cur_val, cfg_val);
+
+
+	/* Disable MISC CTRL */
+	offset = REG_CTL_MISC;
+	cur_val = readl_relaxed(dev->base + offset);
+	cfg_val = cur_val & ~CTL_DB_EN;
+	writel_relaxed(cfg_val, dev->base + offset);
+	wmb(); /* make sure committed */
+	immediate_stream_off_log(dev, "CTL_MISC", dev->base, dev->base_inner,
+				 offset, cur_val, cfg_val);
+
+	/* Disable VF */
+	offset = REG_TG_VF_CON;
+	cur_val = readl_relaxed(dev->base + offset);
+	cfg_val = cur_val & ~TG_VFDATA_EN;
+	writel(cfg_val, dev->base + offset);
+	wmb(); /* make sure committed */
+	if (readx_poll_timeout(readl, dev->base_inner + offset,
+			       chk_val, chk_val == cfg_val,
+			       1 /* sleep, us */,
+			       10000 /* timeout, us*/) < 0) {
+		dev_info(dev->dev, "%s: wait vf off timeout: TG_VF_CON 0x%x\n",
+			 __func__, chk_val);
+		immediate_stream_off_log(dev, "TG_VF_CON", dev->base,
+					 dev->base_inner, offset,
+					 cur_val, cfg_val);
+	} else {
+		dev_dbg(dev->dev, "%s: VF OFF success\n", __func__);
+	}
+
+	/* Disable CMOS */
+	offset = REG_TG_SEN_MODE;
+	cur_val = readl_relaxed(dev->base + offset);
+	cfg_val = cur_val & ~TG_SEN_MODE_CMOS_EN;
+	writel(cfg_val, dev->base + offset);
+	wmb(); /* make sure committed */
+	immediate_stream_off_log(dev, "TG_SEN_MODE", dev->base, dev->base_inner,
+				 offset, cur_val, cfg_val);
+
+	reset_reg(dev);
+	reset(dev);
+
+	wmb(); /* make sure committed */
+
+	/* Enable MISC CTRL */
+	offset = REG_CTL_MISC;
+	cur_val = readl_relaxed(dev->base + offset);
+	cfg_val = cur_val | CTL_DB_EN;
+	writel_relaxed(cfg_val, dev->base + offset);
+	wmb(); /* make sure committed */
+	immediate_stream_off_log(dev, "CTL_MISC", dev->base, dev->base_inner,
+				 offset, cur_val, cfg_val);
+
+	/* nable Double Buffer */
+	offset = REG_TG_PATH_CFG;
+	cur_val = readl_relaxed(dev->base + offset);
+	cfg_val = cur_val & ~0x100;
+	writel(cfg_val, dev->base + offset);
+	wmb(); /* make sure committed */
+	immediate_stream_off_log(dev, "TG_PATH_CFG", dev->base, dev->base_inner,
+				 offset, cur_val, cfg_val);
+}
+
+void stream_on(struct mtk_raw_device *dev, int on)
+{
+	u32 val;
+	u32 chk_val;
+	u32 cfg_val;
+	struct mtk_raw_pipeline *pipe;
+	u32 fps_ratio = 1;
+	int feature;
+
+	dev_info(dev->dev, "raw %d %s %d\n", dev->id, __func__, on);
+	pipe = dev->pipeline;
+	feature = pipe->feature_active;
+
+	if (on) {
+#if USINGSCQ
+		val = readl_relaxed(dev->base + REG_TG_TIME_STAMP_CNT);
+		val = (val == 0) ? 1 : val;
+		fps_ratio = get_fps_ratio(dev);
+		dev_info(dev->dev, "VF on - REG_TG_TIME_STAMP_CNT val:%d fps(30x):%d\n",
+			val, fps_ratio);
+		if (dev->stagger_en)
+			writel_relaxed(SCQ_DEADLINE_MS * 3 * 1000 * SCQ_DEFAULT_CLK_RATE /
+				(val * 2) / fps_ratio, dev->base + REG_SCQ_START_PERIOD);
+		else
+			writel_relaxed(SCQ_DEADLINE_MS * 1000 * SCQ_DEFAULT_CLK_RATE /
+				(val * 2) / fps_ratio, dev->base + REG_SCQ_START_PERIOD);
+#else
+		writel_relaxed(CQ_THR0_MODE_CONTINUOUS | CQ_THR0_EN,
+				dev->base + REG_CQ_THR0_CTL);
+		writel_relaxed(CQ_DB_EN | CQ_DB_LOAD_MODE,
+				dev->base + REG_CQ_EN);
+		wmb(); /* TBC */
+#endif
+
+		mtk_cam_set_topdebug_rdyreq(dev->dev, dev->base, dev->yuv_base,
+					     TG_OVERRUN);
+		dev->overrun_debug_dump_cnt = 0;
+		if (mtk_cam_feature_is_time_shared(feature) ||
+			mtk_cam_feature_is_m2m(feature)) {
+			dev_info(dev->dev, "[%s] M2M view finder disable\n", __func__);
+		} else {
+			val = readl_relaxed(dev->base + REG_TG_VF_CON);
+			val |= TG_VFDATA_EN;
+			writel_relaxed(val, dev->base + REG_TG_VF_CON);
+			wmb(); /* TBC */
+		}
+		atomic_set(&dev->vf_en, 1);
+		dev_info(dev->dev,
+			"%s - CQ_EN:0x%x, CQ_THR0_CTL:0x%8x, TG_VF_CON:0x%8x, SCQ_START_PERIOD:%d\n",
+			__func__,
+			readl_relaxed(dev->base + REG_CQ_EN),
+			readl_relaxed(dev->base + REG_CQ_THR0_CTL),
+			readl_relaxed(dev->base + REG_TG_VF_CON),
+			readl_relaxed(dev->base + REG_SCQ_START_PERIOD));
+	} else {
+		dev_info(dev->dev, "VF off\n");
+		atomic_set(&dev->vf_en, 0);
+
+		writel_relaxed((u32)~CQ_THR0_EN, dev->base + REG_CQ_THR0_CTL);
+		wmb(); /* TBC */
+
+		cfg_val = readl_relaxed(dev->base + REG_TG_PATH_CFG);
+		cfg_val |= 0x100;
+		writel(cfg_val, dev->base + REG_TG_PATH_CFG);
+
+		val = readl_relaxed(dev->base + REG_TG_VF_CON);
+		val &= ~TG_VFDATA_EN;
+		writel(val, dev->base + REG_TG_VF_CON);
+
+		cfg_val = readl_relaxed(dev->base + REG_TG_PATH_CFG);
+		cfg_val &= ~0x100;
+		writel(cfg_val, dev->base + REG_TG_PATH_CFG);
+
+		//writel_relaxed(val, dev->base_inner + REG_CTL_EN);
+		//writel_relaxed(val, dev->base_inner + REG_CTL_EN2);
+
+		wmb(); /* TBC */
+		/* reset hw after vf off */
+		if (readx_poll_timeout(readl, dev->base_inner + REG_TG_VF_CON,
+				       chk_val, chk_val == val,
+				       1 /* sleep, us */,
+				       33000 /* timeout, us*/) < 0) {
+
+			dev_info(dev->dev, "%s: wait vf off timeout: TG_VF_CON 0x%x\n",
+				 __func__, chk_val);
+		}
+
+		reset_reg(dev);
+	}
+}
+
+static int mtk_raw_linebuf_chk(bool b_twin, bool b_bin, bool b_frz, bool b_qbn,
+			       bool b_cbn, int tg_x, int *frz_ratio)
+{
+	int input_x = tg_x;
+	/* max line buffer check for frontal binning and resizer */
+	if (b_twin) {
+		if (input_x > CAM_TWIN_PROCESS_MAX_LINE_BUFFER)
+			return LB_CHECK_TWIN;
+		input_x = input_x >> 1;
+	}
+	if (b_cbn) {
+		if (input_x > CAM_RAW_CBN_MAX_LINE_BUFFER)
+			return LB_CHECK_CBN;
+		input_x = input_x >> 1;
+	}
+	if (b_qbn) {
+		if (input_x > CAM_RAW_QBND_MAX_LINE_BUFFER)
+			return LB_CHECK_QBN;
+		input_x = input_x >> 1;
+	}
+	if (b_bin) {
+		if (input_x > CAM_RAW_BIN_MAX_LINE_BUFFER)
+			return LB_CHECK_BIN;
+		input_x = input_x >> 1;
+	}
+	if (input_x <= CAM_RAW_PROCESS_MAX_LINE_BUFFER) {
+		return LB_CHECK_OK;
+	} else if (b_frz) {
+		if (input_x > CAM_RAW_FRZ_MAX_LINE_BUFFER)
+			return LB_CHECK_FRZ;
+
+		*frz_ratio = input_x * 100 /
+			CAM_RAW_PROCESS_MAX_LINE_BUFFER;
+		return LB_CHECK_OK;
+	} else {
+		return LB_CHECK_RAW;
+	}
+}
+
+static int mtk_raw_pixelmode_calc(int rawpxl, int b_twin, bool b_bin,
+				  bool b_frz, int min_ratio)
+{
+	int pixelmode = rawpxl;
+
+	pixelmode = (b_twin == 2) ? pixelmode << 2 : pixelmode;
+	pixelmode = (b_twin == 1) ? pixelmode << 1 : pixelmode;
+	pixelmode = b_bin ? pixelmode << 1 : pixelmode;
+	pixelmode = (b_frz && (min_ratio < FRZ_PXLMODE_THRES))
+			? pixelmode << 1 : pixelmode;
+	pixelmode = (pixelmode > TGO_MAX_PXLMODE) ?
+		TGO_MAX_PXLMODE : pixelmode;
+
+	return pixelmode;
+}
+
+static void mtk_raw_update_debug_param(struct mtk_cam_device *cam,
+				       struct mtk_cam_resource_config *res,
+				       int *clk_idx)
+{
+	/* skip if debug is not enabled */
+	if (!debug_raw)
+		return;
+
+	dev_dbg(cam->dev, "%s:before:BIN/FRZ/HWN/CLK/pxl=%d/%d(%d)/%d/%d/%d, clk:%d\n",
+		__func__, res->bin_enable, res->frz_enable, res->frz_ratio,
+		res->raw_num_used, *clk_idx, res->tgo_pxl_mode,
+		res->clk_target);
+
+	if (debug_raw_num > 0) {
+		dev_info(cam->dev, "DEBUG: force raw_num_used: %d\n",
+			 debug_raw_num);
+		res->raw_num_used = debug_raw_num;
+	}
+
+	if (debug_pixel_mode >= 0) {
+		dev_info(cam->dev, "DEBUG: force debug_pixel_mode (log2): %d\n",
+			 debug_pixel_mode);
+		res->tgo_pxl_mode = debug_pixel_mode;
+	}
+
+	if (debug_clk_idx >= 0) {
+		dev_info(cam->dev, "DEBUG: force debug_clk_idx: %d\n",
+			 debug_clk_idx);
+		*clk_idx = debug_clk_idx;
+	}
+
+	dev_dbg(cam->dev, "%s:after:BIN/FRZ/HWN/CLK/pxl=%d/%d(%d)/%d/%d/%d, clk:%d\n",
+		__func__, res->bin_enable, res->frz_enable, res->frz_ratio,
+		res->raw_num_used, *clk_idx, res->tgo_pxl_mode,
+		res->clk_target);
+
+}
+
+static bool is_cbn_en(int bin_flag)
+{
+	switch (bin_flag) {
+	case CBN_2X2_ON:
+	case CBN_3X3_ON:
+	case CBN_4X4_ON:
+		return true;
+	default:
+		return false;
+	}
+}
+
+static bool mtk_raw_resource_calc(struct mtk_cam_device *cam,
+				  struct mtk_cam_resource_config *res,
+				  s64 pixel_rate, int res_plan,
+				  int in_w, int in_h, int *out_w, int *out_h)
+{
+	int res_step_type = 0;
+	int tgo_pxl_mode = 1;
+	int pixel_mode[MTK_CAMSYS_RES_STEP_NUM] = {0};
+	int bin_temp = 0, frz_temp = 0, hwn_temp = 0;
+	int bin_en = 0, frz_en = 0, twin_en = 0, clk_cur = 0;
+	int idx = 0, clk_res = 0, idx_res = 0;
+	bool res_found = false;
+	int lb_chk_res = -1;
+	int frz_ratio = 100;
+	int p;
+
+	res->res_plan = res_plan;
+	res->pixel_rate = pixel_rate;
+	/* test pattern */
+	if (res->pixel_rate == 0)
+		res->pixel_rate = 450 * MHz;
+	if (mtk_cam_feature_is_time_shared(res->raw_feature))
+		res->hwn_limit_max = 1;
+	dev_dbg(cam->dev,
+		"[Res] PR = %lld, w/h=%d/%d HWN(%d)/BIN(%d)/FRZ(%d),Plan:%d\n",
+		res->pixel_rate, in_w, in_h,
+		res->hwn_limit_max, res->bin_limit, res->frz_limit, res->res_plan);
+	memcpy(res->res_strategy, raw_resource_strategy_plan + res->res_plan,
+	       MTK_CAMSYS_RES_STEP_NUM * sizeof(int));
+	res->bin_enable = 0;
+	res->raw_num_used = 1;
+	res->frz_enable = 0;
+	res->frz_ratio = frz_ratio;
+	for (idx = 0; idx < MTK_CAMSYS_RES_STEP_NUM ; idx++) {
+		res_step_type = res->res_strategy[idx] & MTK_CAMSYS_RES_IDXMASK;
+		switch (res_step_type) {
+		case MTK_CAMSYS_RES_BIN_TAG:
+			bin_temp = res->res_strategy[idx] - E_RES_BIN_S;
+			if (bin_temp <= res->bin_limit)
+				bin_en = bin_temp;
+			if (bin_en && frz_en)
+				frz_en = 0;
+			break;
+		case MTK_CAMSYS_RES_FRZ_TAG:
+			frz_temp = res->res_strategy[idx] - E_RES_FRZ_S;
+			if (res->frz_limit < 100)
+				frz_en = frz_temp;
+			break;
+		case MTK_CAMSYS_RES_HWN_TAG:
+			hwn_temp = res->res_strategy[idx] - E_RES_HWN_S;
+			if (hwn_temp + 1 <= res->hwn_limit_max)
+				twin_en = hwn_temp;
+			break;
+		case MTK_CAMSYS_RES_CLK_TAG:
+			clk_cur = res->res_strategy[idx] - E_RES_CLK_S;
+			break;
+		default:
+			break;
+		}
+
+		/* 1 for force bin on */
+		if (res->bin_limit >= 1)
+			bin_en = 1;
+
+		if (res->hwn_limit_min > 1)
+			twin_en = 1;
+
+		/* max line buffer check*/
+		lb_chk_res = mtk_raw_linebuf_chk(twin_en, res->bin_limit & BIN_ON,
+						 frz_en, res->bin_limit & QBND_ON,
+						 is_cbn_en(res->bin_limit),
+						 in_w, &frz_ratio);
+		/* frz ratio*/
+		if (res_step_type == MTK_CAMSYS_RES_FRZ_TAG) {
+			res->frz_ratio =
+				res->frz_limit < FRZ_PXLMODE_THRES
+				? res->frz_limit : FRZ_PXLMODE_THRES;
+		}
+		if (mtk_cam_feature_is_time_shared(res->raw_feature)) {
+			tgo_pxl_mode = mtk_raw_pixelmode_calc(MTK_CAMSYS_PROC_DEFAULT_PIXELMODE,
+					twin_en, bin_en, frz_en, res->frz_ratio);
+			pixel_mode[idx] = tgo_pxl_mode;
+			if (lb_chk_res == LB_CHECK_OK) {
+				res->bin_enable = bin_en;
+				res->frz_enable = frz_en;
+				res->raw_num_used = twin_en + 1;
+				clk_res = clk_cur;
+				idx_res = idx;
+				res_found = true;
+			}
+		} else {
+			/*try 1-pixel mode first*/
+			for (p = 1; p <= MTK_CAMSYS_PROC_DEFAULT_PIXELMODE; p++) {
+				tgo_pxl_mode = mtk_raw_pixelmode_calc(p, twin_en, bin_en, frz_en,
+									res->frz_ratio);
+				/**
+				 * isp throughput along resource strategy
+				 * (compared with pixel rate)
+				 */
+				pixel_mode[idx] = tgo_pxl_mode;
+
+#ifdef ISP7_1/* only support 1-pixel mode */
+				if (p == 1 &&
+					lb_chk_res == LB_CHECK_OK) {
+					if (!res_found) {
+						res->bin_enable = bin_en;
+						res->frz_enable = frz_en;
+						res->raw_num_used = twin_en + 1;
+						clk_res = clk_cur;
+						idx_res = idx;
+						res_found = true;
+						break;
+					}
+				}
+#endif
+			}
+		}
+		dev_dbg(cam->dev, "Res-%d B/F/H/C=%d/%d/%d/%d -> %d/%d/%d/%d (%d)(%d)\n",
+			idx, bin_temp, frz_temp, hwn_temp, clk_cur, bin_en,
+			frz_en, twin_en, clk_cur, lb_chk_res, pixel_mode[idx]);
+	}
+
+	tgo_pxl_mode = pixel_mode[idx_res];
+	switch (tgo_pxl_mode) {
+	case 1:
+		res->tgo_pxl_mode = 0;
+		break;
+	case 2:
+		res->tgo_pxl_mode = 1;
+		break;
+	case 4:
+		res->tgo_pxl_mode = 2;
+		break;
+	case 8:
+		res->tgo_pxl_mode = 3;
+		break;
+	default:
+		break;
+	}
+
+	mtk_raw_update_debug_param(cam, res, &clk_res);
+
+	if (res_found) {
+		dev_info(cam->dev, "Res-end:%d BIN/FRZ/HWN/CLK/pxl=%d/%d(%d)/%d/%d/%d, clk:%d\n",
+			idx_res, res->bin_enable, res->frz_enable, res->frz_ratio,
+			res->raw_num_used, clk_res, res->tgo_pxl_mode, res->clk_target);
+	} else {
+		dev_dbg(cam->dev, "[%s] Error resource result\n",
+			__func__);
+	}
+	if (res->bin_enable) {
+		*out_w = in_w >> 1;
+		*out_h = in_h >> 1;
+	} else if (res->frz_enable) {
+		*out_w = in_w * res->frz_ratio / 100;
+		*out_h = in_h * res->frz_ratio / 100;
+	} else {
+		*out_w = in_w;
+		*out_h = in_h;
+	}
+
+	return res_found;
+}
+
+static void raw_irq_handle_tg_grab_err(struct mtk_raw_device *raw_dev,
+					int dequeued_frame_seq_no);
+static void raw_irq_handle_dma_err(struct mtk_raw_device *raw_dev);
+static void raw_irq_handle_tg_overrun_err(struct mtk_raw_device *raw_dev,
+					  int dequeued_frame_seq_no);
+
+static void raw_handle_error(struct mtk_raw_device *raw_dev,
+			     struct mtk_camsys_irq_info *data)
+{
+	int err_status = data->e.err_status;
+	int frame_idx_inner = data->frame_idx_inner;
+
+	/* Show DMA errors in detail */
+	if (err_status & DMA_ERR_ST) {
+
+		/*
+		 * mtk_cam_dump_topdebug_rdyreq(dev,
+		 *                              raw_dev->base, raw_dev->yuv_base);
+		 */
+
+		raw_irq_handle_dma_err(raw_dev);
+
+		/*
+		 * mtk_cam_dump_req_rdy_status(raw_dev->dev, raw_dev->base,
+		 *		    raw_dev->yuv_base);
+		 */
+
+		/*
+		 * mtk_cam_dump_dma_debug(raw_dev->dev, raw_dev->base + CAMDMATOP_BASE,
+		 *                        "IMGO_R1",
+		 *                        dbg_IMGO_R1, ARRAY_SIZE(dbg_IMGO_R1));
+		 */
+	}
+	/* Show TG register for more error detail*/
+	if (err_status & TG_GBERR_ST)
+		raw_irq_handle_tg_grab_err(raw_dev, frame_idx_inner);
+
+	if (err_status & TG_OVRUN_ST) {
+		if (raw_dev->overrun_debug_dump_cnt < 4) {
+			mtk_cam_dump_topdebug_rdyreq(raw_dev->dev,
+				raw_dev->base, raw_dev->yuv_base);
+			raw_dev->overrun_debug_dump_cnt++;
+		} else {
+			dev_dbg(raw_dev->dev, "%s: TG_OVRUN_ST repeated skip dump raw_id:%d\n",
+				__func__, raw_dev->id);
+		}
+		raw_irq_handle_tg_overrun_err(raw_dev, frame_idx_inner);
+	}
+}
+
+static bool is_sub_sample_sensor_timing(struct mtk_raw_device *dev)
+{
+	return dev->cur_vsync_idx >= dev->set_sensor_idx;
+}
+
+static irqreturn_t mtk_irq_raw(int irq, void *data)
+{
+	struct mtk_raw_device *raw_dev = (struct mtk_raw_device *)data;
+	struct device *dev = raw_dev->dev;
+	struct mtk_camsys_irq_info irq_info;
+	unsigned int frame_idx, frame_idx_inner, fbc_fho_ctl2;
+	unsigned int irq_status, err_status, dmao_done_status, dmai_done_status;
+	unsigned int drop_status, dma_ofl_status, cq_done_status, cq2_done_status;
+	bool wake_thread = 0;
+
+	irq_status	= readl_relaxed(raw_dev->base + REG_CTL_RAW_INT_STAT);
+	dmao_done_status = readl_relaxed(raw_dev->base + REG_CTL_RAW_INT2_STAT);
+	dmai_done_status = readl_relaxed(raw_dev->base + REG_CTL_RAW_INT3_STAT);
+	drop_status	= readl_relaxed(raw_dev->base + REG_CTL_RAW_INT4_STAT);
+	dma_ofl_status  = readl_relaxed(raw_dev->base + REG_CTL_RAW_INT5_STAT);
+	cq_done_status  = readl_relaxed(raw_dev->base + REG_CTL_RAW_INT6_STAT);
+	cq2_done_status = readl_relaxed(raw_dev->base + REG_CTL_RAW_INT7_STAT);
+
+	frame_idx	= readl_relaxed(raw_dev->base + REG_FRAME_SEQ_NUM);
+	frame_idx_inner	= readl_relaxed(raw_dev->base_inner + REG_FRAME_SEQ_NUM);
+
+	fbc_fho_ctl2 =
+		readl_relaxed(REG_FBC_CTL2(raw_dev->base + FBC_R1A_BASE, 1));
+
+	err_status = irq_status & INT_ST_MASK_CAM_ERR;
+	if (unlikely(debug_raw))
+		dev_dbg(dev,
+			"INT:0x%x(err:0x%x) 2~7 0x%x/0x%x/0x%x/0x%x/0x%x/0x%x (in:%d)\n",
+			irq_status, err_status,
+			dmao_done_status, dmai_done_status, drop_status,
+			dma_ofl_status, cq_done_status, cq2_done_status,
+			frame_idx_inner);
+
+	if (unlikely(!raw_dev->pipeline || !raw_dev->pipeline->enabled_raw)) {
+		dev_dbg(dev, "%s: %i: raw pipeline is disabled\n",
+			__func__, raw_dev->id);
+		goto ctx_not_found;
+	}
+
+	irq_info.irq_type = 0;
+	irq_info.ts_ns = ktime_get_boottime_ns();
+	irq_info.frame_idx = frame_idx;
+	irq_info.frame_idx_inner = frame_idx_inner;
+
+	/* CQ done */
+	if (cq_done_status & CAMCTL_CQ_THR0_DONE_ST)
+		irq_info.irq_type |= 1 << CAMSYS_IRQ_SETTING_DONE;
+	/* DMAO done, only for AFO */
+	if (dmao_done_status & AFO_DONE_ST)
+		irq_info.irq_type |= 1 << CAMSYS_IRQ_AFO_DONE;
+		/* enable AFO_DONE_EN at backend manually */
+
+	/* Frame done */
+	if (irq_status & SW_PASS1_DON_ST) {
+		irq_info.irq_type |= 1 << CAMSYS_IRQ_FRAME_DONE;
+		raw_dev->overrun_debug_dump_cnt = 0;
+	}
+	/* Frame start */
+	if (irq_status & SOF_INT_ST) {
+		irq_info.irq_type |= 1 << CAMSYS_IRQ_FRAME_START;
+
+		raw_dev->cur_vsync_idx = 0;
+		raw_dev->sof_count++;
+		irq_info.write_cnt = ((fbc_fho_ctl2 & WCNT_BIT_MASK) >> 8) - 1;
+		irq_info.fbc_cnt = (fbc_fho_ctl2 & CNT_BIT_MASK) >> 16;
+	}
+	/* Vsync interrupt */
+	if (irq_status & VS_INT_ST)
+		raw_dev->vsync_count++;
+
+	if (raw_dev->sub_sensor_ctrl_en && irq_status & TG_VS_INT_ORG_ST
+	    && raw_dev->cur_vsync_idx >= 0) {
+		if (is_sub_sample_sensor_timing(raw_dev)) {
+			raw_dev->cur_vsync_idx = -1;
+			irq_info.irq_type |= 1 << CAMSYS_IRQ_SUBSAMPLE_SENSOR_SET;
+		}
+		++raw_dev->cur_vsync_idx;
+	}
+
+	if (irq_info.irq_type && !raw_dev->is_sub) {
+		if (push_msgfifo(raw_dev, &irq_info) == 0)
+			wake_thread = 1;
+	}
+
+	/* Check ISP error status */
+	if (unlikely(err_status)) {
+		struct mtk_camsys_irq_info err_info;
+
+		err_info.irq_type = 1 << CAMSYS_IRQ_ERROR;
+		err_info.ts_ns = irq_info.ts_ns;
+		err_info.frame_idx = irq_info.frame_idx;
+		err_info.frame_idx_inner = irq_info.frame_idx_inner;
+		err_info.e.err_status = err_status;
+
+		if (push_msgfifo(raw_dev, &err_info) == 0)
+			wake_thread = 1;
+	}
+
+	/* enable to debug fbc related */
+	if (debug_raw && debug_dump_fbc && (irq_status & SOF_INT_ST))
+		mtk_cam_raw_dump_fbc(raw_dev->dev, raw_dev->base, raw_dev->yuv_base);
+
+ctx_not_found:
+
+	return wake_thread ? IRQ_WAKE_THREAD : IRQ_HANDLED;
+}
+
+static irqreturn_t mtk_thread_irq_raw(int irq, void *data)
+{
+	struct mtk_raw_device *raw_dev = (struct mtk_raw_device *)data;
+	struct mtk_camsys_irq_info irq_info;
+
+	if (unlikely(atomic_cmpxchg(&raw_dev->is_fifo_overflow, 1, 0)))
+		dev_info(raw_dev->dev, "msg fifo overflow\n");
+
+	while (kfifo_len(&raw_dev->msg_fifo) >= sizeof(irq_info)) {
+		int len = kfifo_out(&raw_dev->msg_fifo, &irq_info, sizeof(irq_info));
+
+		WARN_ON(len != sizeof(irq_info));
+
+		dev_dbg(raw_dev->dev, "ts=%llu irq_type %d, req:%d/%d\n",
+			irq_info.ts_ns / 1000,
+			irq_info.irq_type,
+			irq_info.frame_idx_inner,
+			irq_info.frame_idx);
+
+		/* error case */
+		if (unlikely(irq_info.irq_type == (1 << CAMSYS_IRQ_ERROR))) {
+			raw_handle_error(raw_dev, &irq_info);
+			continue;
+		}
+
+		/* normal case */
+
+		/* inform interrupt information to camsys controller */
+		mtk_camsys_isr_event(raw_dev->cam,
+				     CAMSYS_ENGINE_RAW, raw_dev->id,
+				     &irq_info);
+	}
+
+	return IRQ_HANDLED;
+}
+
+void raw_irq_handle_tg_grab_err(struct mtk_raw_device *raw_dev,
+					int dequeued_frame_seq_no)
+{
+	struct mtk_cam_ctx *ctx;
+	struct mtk_cam_request_stream_data *s_data;
+	int val, val2;
+	unsigned int inner_val, tg_full_sel;
+
+	val = readl_relaxed(raw_dev->base + REG_TG_PATH_CFG);
+	inner_val = readl_relaxed(raw_dev->base_inner + REG_TG_PATH_CFG);
+	val = val | TG_TG_FULL_SEL;
+	writel_relaxed(val, raw_dev->base + REG_TG_PATH_CFG);
+	writel_relaxed(val, raw_dev->base_inner + REG_TG_PATH_CFG);
+	wmb(); /* TBC */
+	val2 = readl_relaxed(raw_dev->base + REG_TG_SEN_MODE);
+	val2 = val2 | TG_CMOS_RDY_SEL;
+	writel_relaxed(val2, raw_dev->base + REG_TG_SEN_MODE);
+	wmb(); /* TBC */
+
+	dev_info_ratelimited(raw_dev->dev,
+		"%d Grab_Err [Outter] TG PATHCFG/SENMODE FRMSIZE/R GRABPXL/LIN:%x/%x %x/%x %x/%x\n",
+		dequeued_frame_seq_no,
+		readl_relaxed(raw_dev->base + REG_TG_PATH_CFG),
+		readl_relaxed(raw_dev->base + REG_TG_SEN_MODE),
+		readl_relaxed(raw_dev->base + REG_TG_FRMSIZE_ST),
+		readl_relaxed(raw_dev->base + REG_TG_FRMSIZE_ST_R),
+		readl_relaxed(raw_dev->base + REG_TG_SEN_GRAB_PXL),
+		readl_relaxed(raw_dev->base + REG_TG_SEN_GRAB_LIN));
+	dev_info_ratelimited(raw_dev->dev,
+		"%d Grab_Err [Inner] TG PATHCFG/SENMODE FRMSIZE/R GRABPXL/LIN:%x/%x %x/%x %x/%x\n",
+		dequeued_frame_seq_no,
+		readl_relaxed(raw_dev->base_inner + REG_TG_PATH_CFG),
+		readl_relaxed(raw_dev->base_inner + REG_TG_SEN_MODE),
+		readl_relaxed(raw_dev->base_inner + REG_TG_FRMSIZE_ST),
+		readl_relaxed(raw_dev->base_inner + REG_TG_FRMSIZE_ST_R),
+		readl_relaxed(raw_dev->base_inner + REG_TG_SEN_GRAB_PXL),
+		readl_relaxed(raw_dev->base_inner + REG_TG_SEN_GRAB_LIN));
+
+	ctx = mtk_cam_find_ctx(raw_dev->cam, &raw_dev->pipeline->subdev.entity);
+	if (!ctx) {
+		dev_info(raw_dev->dev, "%s: cannot find ctx\n", __func__);
+		return;
+	}
+
+	s_data = mtk_cam_get_req_s_data(ctx, ctx->stream_id, dequeued_frame_seq_no);
+	if (s_data) {
+		mtk_cam_debug_seninf_dump(s_data);
+		tg_full_sel = ((inner_val & TG_FULLSEL_BIT_MASK) >> 15);
+
+		if (tg_full_sel == 1)
+			mtk_cam_req_dump(s_data, MTK_CAM_REQ_DUMP_CHK_DEQUEUE_FAILED,
+					"TG Grab Err", false);
+		else
+			dev_info(raw_dev->dev, "%s: tg_full_sel 0x%x\n", __func__, tg_full_sel);
+	} else {
+		dev_info(raw_dev->dev,
+			"%s: req(%d) can't be found for seninf dump\n",
+			__func__, dequeued_frame_seq_no);
+	}
+
+}
+
+void raw_irq_handle_dma_err(struct mtk_raw_device *raw_dev)
+{
+	mtk_cam_raw_dump_dma_err_st(raw_dev->dev, raw_dev->base);
+	mtk_cam_yuv_dump_dma_err_st(raw_dev->dev, raw_dev->yuv_base);
+
+	if (raw_dev->pipeline->feature_active)
+		mtk_cam_dump_dma_debug(raw_dev->dev,
+				       raw_dev->base + CAMDMATOP_BASE,
+				       "RAWI_R2",
+				       dbg_RAWI_R2, ARRAY_SIZE(dbg_RAWI_R2));
+
+	if (raw_dev->pipeline->pde_config.pde_info.pd_table_offset) {
+		dev_dbg_ratelimited(raw_dev->dev,
+				    "DMA_ERR:%x,PDI_R1:%x,PDO_R1:%x\n",
+			readl_relaxed(raw_dev->base + 0x4060),
+			readl_relaxed(raw_dev->base + REG_PDI_R1_BASE + DMA_OFFSET_ERR_STAT),
+			readl_relaxed(raw_dev->base + REG_PDO_R1_BASE + DMA_OFFSET_ERR_STAT)
+			);
+		dev_dbg_ratelimited(raw_dev->dev,
+				    "TG_FRMSIZE_ST:%x,TG_FRMSIZE_ST_R:%x\n",
+				readl_relaxed(raw_dev->base + 0x0738),
+				readl_relaxed(raw_dev->base + 0x076c)
+				);
+		mtk_cam_dump_dma_debug(raw_dev->dev, raw_dev->base + CAMDMATOP_BASE,
+				"PDO_R1", dbg_PDO_R1, ARRAY_SIZE(dbg_PDO_R1));
+		mtk_cam_dump_dma_debug(raw_dev->dev, raw_dev->base + CAMDMATOP_BASE,
+				"PDI_R1", dbg_PDI_R1, ARRAY_SIZE(dbg_PDI_R1));
+	}
+	/*
+	 * mtk_cam_dump_dma_debug(raw_dev->dev, raw_dev->base + CAMDMATOP_BASE,
+	 *                        "IMGO_R1", dbg_IMGO_R1, ARRAY_SIZE(dbg_IMGO_R1));
+	 */
+}
+
+static void raw_irq_handle_tg_overrun_err(struct mtk_raw_device *raw_dev,
+					  int dequeued_frame_seq_no)
+{
+	struct mtk_cam_ctx *ctx;
+	struct mtk_cam_request_stream_data *s_data;
+	int val, val2;
+	unsigned int inner_val, tg_full_sel;
+
+	val = readl_relaxed(raw_dev->base + REG_TG_PATH_CFG);
+	inner_val = readl_relaxed(raw_dev->base_inner + REG_TG_PATH_CFG);
+	val = val | TG_TG_FULL_SEL;
+	writel_relaxed(val, raw_dev->base + REG_TG_PATH_CFG);
+	writel_relaxed(val, raw_dev->base_inner + REG_TG_PATH_CFG);
+	wmb(); /* for dbg dump register */
+
+	val2 = readl_relaxed(raw_dev->base + REG_TG_SEN_MODE);
+	val2 = val2 | TG_CMOS_RDY_SEL;
+	writel_relaxed(val2, raw_dev->base + REG_TG_SEN_MODE);
+	wmb(); /* for dbg dump register */
+
+	dev_info(raw_dev->dev,
+		 "%d Overrun_Err [Outter] TG PATHCFG/SENMODE FRMSIZE/R GRABPXL/LIN:%x/%x %x/%x %x/%x\n",
+		 dequeued_frame_seq_no,
+			 readl_relaxed(raw_dev->base + REG_TG_PATH_CFG),
+			 readl_relaxed(raw_dev->base + REG_TG_SEN_MODE),
+			 readl_relaxed(raw_dev->base + REG_TG_FRMSIZE_ST),
+			 readl_relaxed(raw_dev->base + REG_TG_FRMSIZE_ST_R),
+			 readl_relaxed(raw_dev->base + REG_TG_SEN_GRAB_PXL),
+			 readl_relaxed(raw_dev->base + REG_TG_SEN_GRAB_LIN));
+	dev_info(raw_dev->dev,
+		 "%d Overrun_Err [Inner] TG PATHCFG/SENMODE FRMSIZE/R GRABPXL/LIN:%x/%x %x/%x %x/%x\n",
+		 dequeued_frame_seq_no,
+		 readl_relaxed(raw_dev->base_inner + REG_TG_PATH_CFG),
+		 readl_relaxed(raw_dev->base_inner + REG_TG_SEN_MODE),
+		 readl_relaxed(raw_dev->base_inner + REG_TG_FRMSIZE_ST),
+		 readl_relaxed(raw_dev->base_inner + REG_TG_FRMSIZE_ST_R),
+		 readl_relaxed(raw_dev->base_inner + REG_TG_SEN_GRAB_PXL),
+		 readl_relaxed(raw_dev->base_inner + REG_TG_SEN_GRAB_LIN));
+	dev_info(raw_dev->dev,
+			 "REQ RAW/2/3 DMA/2:%08x/%08x/%08x/%08x/%08x\n",
+			 readl_relaxed(raw_dev->base + REG_CTL_RAW_MOD_REQ_STAT),
+			 readl_relaxed(raw_dev->base + REG_CTL_RAW_MOD2_REQ_STAT),
+			 readl_relaxed(raw_dev->base + REG_CTL_RAW_MOD3_REQ_STAT),
+			 readl_relaxed(raw_dev->base + REG_CTL_RAW_MOD5_REQ_STAT),
+			 readl_relaxed(raw_dev->base + REG_CTL_RAW_MOD6_REQ_STAT));
+	dev_info(raw_dev->dev,
+			 "RDY RAW/2/3 DMA/2:%08x/%08x/%08x/%08x/%08x\n",
+			 readl_relaxed(raw_dev->base + REG_CTL_RAW_MOD_RDY_STAT),
+			 readl_relaxed(raw_dev->base + REG_CTL_RAW_MOD2_RDY_STAT),
+			 readl_relaxed(raw_dev->base + REG_CTL_RAW_MOD3_RDY_STAT),
+			 readl_relaxed(raw_dev->base + REG_CTL_RAW_MOD5_RDY_STAT),
+			 readl_relaxed(raw_dev->base + REG_CTL_RAW_MOD6_RDY_STAT));
+	dev_info(raw_dev->dev,
+			 "REQ YUV/2/3/4 WDMA:%08x/%08x/%08x/%08x/%08x\n",
+			 readl_relaxed(raw_dev->yuv_base + REG_CTL_RAW_MOD_REQ_STAT),
+			 readl_relaxed(raw_dev->yuv_base + REG_CTL_RAW_MOD2_REQ_STAT),
+			 readl_relaxed(raw_dev->yuv_base + REG_CTL_RAW_MOD3_REQ_STAT),
+			 readl_relaxed(raw_dev->yuv_base + REG_CTL_RAW_MOD4_REQ_STAT),
+			 readl_relaxed(raw_dev->yuv_base + REG_CTL_RAW_MOD5_REQ_STAT));
+	dev_info(raw_dev->dev,
+			 "RDY YUV/2/3/4 WDMA:%08x/%08x/%08x/%08x/%08x\n",
+			 readl_relaxed(raw_dev->yuv_base + REG_CTL_RAW_MOD_RDY_STAT),
+			 readl_relaxed(raw_dev->yuv_base + REG_CTL_RAW_MOD2_RDY_STAT),
+			 readl_relaxed(raw_dev->yuv_base + REG_CTL_RAW_MOD3_RDY_STAT),
+			 readl_relaxed(raw_dev->yuv_base + REG_CTL_RAW_MOD4_RDY_STAT),
+			 readl_relaxed(raw_dev->yuv_base + REG_CTL_RAW_MOD5_RDY_STAT));
+
+	ctx = mtk_cam_find_ctx(raw_dev->cam, &raw_dev->pipeline->subdev.entity);
+	if (!ctx) {
+		dev_info(raw_dev->dev, "%s: cannot find ctx\n", __func__);
+		return;
+	}
+
+	/* TODO: check if we tried recover the error before we dump */
+
+	s_data = mtk_cam_get_req_s_data(ctx, ctx->stream_id, dequeued_frame_seq_no);
+	if (s_data) {
+		/**
+		 * Enable the dump manually if needed.
+		 * mtk_cam_req_dump() already call mtk_cam_seninf_dump()
+		 * in a delayed work if no P1 done comes.
+		 */
+		if (0 && raw_dev->sof_count > 3)
+			mtk_cam_debug_seninf_dump(s_data);
+
+		tg_full_sel = ((inner_val & TG_FULLSEL_BIT_MASK) >> 15);
+		if (tg_full_sel == 1)
+			mtk_cam_req_dump(s_data, MTK_CAM_REQ_DUMP_CHK_DEQUEUE_FAILED,
+					"TG Overrun Err", true);
+		else
+			dev_info(raw_dev->dev, "%s: tg_full_sel 0x%x:\n", __func__, tg_full_sel);
+	} else {
+		dev_info(raw_dev->dev, "%s: req(%d) can't be found for dump\n",
+			__func__, dequeued_frame_seq_no);
+		if (0 && raw_dev->sof_count > 3 && ctx->seninf)
+			mtk_cam_seninf_dump(ctx->seninf);
+	}
+}
+
+static int mtk_raw_pm_suspend_prepare(struct mtk_raw_device *dev)
+{
+	u32 val;
+	int ret;
+
+	dev_dbg(dev->dev, "- %s\n", __func__);
+
+	if (pm_runtime_suspended(dev->dev))
+		return 0;
+
+	/* Disable ISP's view finder and wait for TG idle */
+	dev_dbg(dev->dev, "cam suspend, disable VF\n");
+	val = readl(dev->base + REG_TG_VF_CON);
+	writel(val & (~TG_VFDATA_EN), dev->base + REG_TG_VF_CON);
+	ret = readl_poll_timeout_atomic(dev->base + REG_TG_INTER_ST, val,
+					(val & TG_CAM_CS_MASK) == TG_IDLE_ST,
+					USEC_PER_MSEC, MTK_RAW_STOP_HW_TIMEOUT);
+	if (ret)
+		dev_dbg(dev->dev, "can't stop HW:%d:0x%x\n", ret, val);
+
+	/* Disable CMOS */
+	val = readl(dev->base + REG_TG_SEN_MODE);
+	writel(val & (~TG_SEN_MODE_CMOS_EN), dev->base + REG_TG_SEN_MODE);
+
+	/* Force ISP HW to idle */
+	ret = pm_runtime_force_suspend(dev->dev);
+	return ret;
+}
+
+static int mtk_raw_pm_post_suspend(struct mtk_raw_device *dev)
+{
+	u32 val;
+	int ret;
+
+	dev_dbg(dev->dev, "- %s\n", __func__);
+
+	if (pm_runtime_suspended(dev->dev))
+		return 0;
+
+	/* Force ISP HW to resume */
+	ret = pm_runtime_force_resume(dev->dev);
+	if (ret)
+		return ret;
+
+	/* Enable CMOS */
+	dev_dbg(dev->dev, "cam resume, enable CMOS/VF\n");
+	val = readl(dev->base + REG_TG_SEN_MODE);
+	writel(val | TG_SEN_MODE_CMOS_EN, dev->base + REG_TG_SEN_MODE);
+
+	/* Enable VF */
+	val = readl(dev->base + REG_TG_VF_CON);
+	writel(val | TG_VFDATA_EN, dev->base + REG_TG_VF_CON);
+
+	return 0;
+}
+
+static int raw_pm_notifier(struct notifier_block *nb,
+							unsigned long action, void *data)
+{
+	struct mtk_raw_device *raw_dev =
+			container_of(nb, struct mtk_raw_device, pm_notifier);
+
+	switch (action) {
+	case PM_SUSPEND_PREPARE:
+		mtk_raw_pm_suspend_prepare(raw_dev);
+		break;
+	case PM_POST_SUSPEND:
+		mtk_raw_pm_post_suspend(raw_dev);
+		break;
+	default:
+		break;
+	}
+
+	return NOTIFY_OK;
+}
+
+static int mtk_raw_of_probe(struct platform_device *pdev,
+			    struct mtk_raw_device *raw)
+{
+	struct device *dev = &pdev->dev;
+	struct resource *res;
+	unsigned int i;
+	int clks, ret;
+
+	ret = of_property_read_u32(dev->of_node, "mediatek,cam-id",
+				   &raw->id);
+	if (ret) {
+		dev_dbg(dev, "missing camid property\n");
+		return ret;
+	}
+
+	if (dma_set_mask_and_coherent(dev, DMA_BIT_MASK(34)))
+		dev_info(dev, "%s: No suitable DMA available\n", __func__);
+
+	if (!dev->dma_parms) {
+		dev->dma_parms =
+			devm_kzalloc(dev, sizeof(*dev->dma_parms), GFP_KERNEL);
+		if (!dev->dma_parms)
+			return -ENOMEM;
+	}
+
+	if (dev->dma_parms) {
+		ret = dma_set_max_seg_size(dev, UINT_MAX);
+		if (ret)
+			dev_info(dev, "Failed to set DMA segment size\n");
+	}
+
+	/* base outer register */
+	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "base");
+	if (!res) {
+		dev_info(dev, "failed to get mem\n");
+		return -ENODEV;
+	}
+
+	raw->base = devm_ioremap_resource(dev, res);
+	if (IS_ERR(raw->base)) {
+		dev_dbg(dev, "failed to map register base\n");
+		return PTR_ERR(raw->base);
+	}
+
+	/* base inner register */
+	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "inner_base");
+	if (!res) {
+		dev_dbg(dev, "failed to get mem\n");
+		return -ENODEV;
+	}
+
+	raw->base_inner = devm_ioremap_resource(dev, res);
+	if (IS_ERR(raw->base_inner)) {
+		dev_dbg(dev, "failed to map register inner base\n");
+		return PTR_ERR(raw->base_inner);
+	}
+
+	/* will be assigned later */
+	raw->yuv_base = NULL;
+
+	raw->irq = platform_get_irq(pdev, 0);
+	if (raw->irq < 0) {
+		dev_dbg(dev, "failed to get irq\n");
+		return -ENODEV;
+	}
+
+	ret = devm_request_threaded_irq(dev, raw->irq,
+					mtk_irq_raw,
+					mtk_thread_irq_raw,
+					0, dev_name(dev), raw);
+	if (ret) {
+		dev_dbg(dev, "failed to request irq=%d\n", raw->irq);
+		return ret;
+	}
+	dev_dbg(dev, "registered irq=%d\n", raw->irq);
+
+	disable_irq(raw->irq);
+
+	clks = of_count_phandle_with_args(pdev->dev.of_node, "clocks",
+			"#clock-cells");
+
+	raw->num_clks = (clks == -ENOENT) ? 0:clks;
+	dev_info(dev, "clk_num:%d\n", raw->num_clks);
+
+	if (raw->num_clks) {
+		raw->clks = devm_kcalloc(dev, raw->num_clks, sizeof(*raw->clks),
+					GFP_KERNEL);
+		if (!raw->clks)
+			return -ENOMEM;
+	}
+
+	for (i = 0; i < raw->num_clks; i++) {
+		raw->clks[i] = of_clk_get(pdev->dev.of_node, i);
+		if (IS_ERR(raw->clks[i])) {
+			dev_info(dev, "failed to get clk %d\n", i);
+			return -ENODEV;
+		}
+	}
+
+#ifdef CONFIG_PM_SLEEP
+	raw->pm_notifier.notifier_call = raw_pm_notifier;
+	ret = register_pm_notifier(&raw->pm_notifier);
+	if (ret) {
+		dev_info(dev, "failed to register notifier block.\n");
+		return ret;
+	}
+#endif
+	return 0;
+}
+
+static int mtk_raw_sd_subscribe_event(struct v4l2_subdev *subdev,
+				      struct v4l2_fh *fh,
+				      struct v4l2_event_subscription *sub)
+{
+	switch (sub->type) {
+	case V4L2_EVENT_FRAME_SYNC:
+		return v4l2_event_subscribe(fh, sub, 0, NULL);
+	case V4L2_EVENT_REQUEST_DRAINED:
+		return v4l2_event_subscribe(fh, sub, 0, NULL);
+	case V4L2_EVENT_EOS:
+		return v4l2_event_subscribe(fh, sub, 0, NULL);
+	case V4L2_EVENT_REQUEST_DUMPED:
+		return v4l2_event_subscribe(fh, sub, 0, NULL);
+
+	default:
+		return -EINVAL;
+	}
+}
+
+static int mtk_raw_available_resource(struct mtk_raw *raw)
+{
+	struct device *dev = raw->cam_dev;
+	struct mtk_cam_device *cam_dev = dev_get_drvdata(dev);
+	int res_status = 0;
+	int i, j;
+
+	for (i = 0; i < cam_dev->num_raw_devices; i++) {
+		struct mtk_raw_pipeline *pipe = raw->pipelines + i;
+
+		for (j = 0; j < ARRAY_SIZE(raw->devs); j++) {
+			if (pipe->enabled_raw & 1 << j)
+				res_status |= 1 << j;
+		}
+	}
+	dev_dbg(raw->cam_dev, "%s raw_status:0x%x Available Engine:A/B/C:%d/%d/%d\n",
+		 __func__, res_status,
+			!(res_status & (1 << MTKCAM_SUBDEV_RAW_0)),
+			!(res_status & (1 << MTKCAM_SUBDEV_RAW_1)),
+			!(res_status & (1 << MTKCAM_SUBDEV_RAW_2)));
+
+	return res_status;
+}
+
+#ifdef ISP7_1
+static int raw_stagger_select(struct mtk_cam_ctx *ctx,
+			int raw_status,
+			int pipe_hw_mode,
+			struct mtk_raw_stagger_select *result)
+{
+	struct mtk_cam_device *cam = ctx->cam;
+	struct cam_stagger_order stagger_order;
+	struct cam_stagger_select stagger_select;
+	struct mtk_cam_ctx *ctx_chk;
+	int i, m;
+	int stagger_ctx_num = 0, mode = 0;
+	int stagger_plan = STAGGER_STREAM_PLAN_OTF_ALL;
+	int stagger_order_mask[STAGGER_MAX_STREAM_NUM] = {0};
+	int mask = 0x0;
+	bool selected = false;
+
+	stagger_order = stagger_mode_plan[stagger_plan];
+	/* check how many stagger sensors are running, */
+	/* this will affect the decision of which mode */
+	/* to run for following stagger sensor         */
+	for (i = 0;  i < cam->max_stream_num; i++) {
+		ctx_chk = &cam->ctxs[i];
+		if (ctx_chk != ctx && ctx_chk->streaming && mtk_cam_is_stagger(ctx_chk)) {
+			for (m = 0; m < STAGGER_MAX_STREAM_NUM; m++) {
+				mode = (pipe_hw_mode) ?
+					mtk_cam_get_stagger_path(pipe_hw_mode) :
+					stagger_order.stagger_select[m].mode_decision;
+				dev_info(cam->dev, "[%s:stagger check] i:%d/m:%d; mode:%d\n",
+				__func__, i, m, mode);
+				if (mode == ctx_chk->pipe->stagger_path) {
+					stagger_order_mask[m] = 1;
+					break;
+				}
+			}
+			stagger_ctx_num++;
+		}
+	}
+	dev_info(cam->dev, "[%s:counter] num:%d; this ctx order is :%d (%d/%d/%d/%d)\n",
+		__func__, stagger_ctx_num, stagger_ctx_num + 1,
+		stagger_order_mask[0], stagger_order_mask[1],
+		stagger_order_mask[2], stagger_order_mask[3]);
+
+	/* check this ctx should use which raw_select_mask and mode */
+	for (i = 0; i < stagger_ctx_num + 1; i++) {
+		if (stagger_order_mask[i] == 0) {
+			stagger_select = stagger_order.stagger_select[i];
+			result->stagger_path = (pipe_hw_mode) ?
+				mtk_cam_get_stagger_path(pipe_hw_mode) :
+				stagger_select.mode_decision;
+			dev_info(cam->dev, "[%s:plan:%d] raw_status 0x%x, stagger_select_raw_mask:0x%x mode:0x%x\n",
+				__func__, i, raw_status, stagger_select.raw_select,
+				result->stagger_path);
+		}
+	}
+
+	result->enabled_raw = 0;
+	for (m = MTKCAM_SUBDEV_RAW_0; m < RAW_PIPELINE_NUM; m++) {
+		mask = 1 << m;
+		if (stagger_select.raw_select & mask) { /*check stagger raw select mask*/
+			if (!(raw_status & mask)) { /*check available raw select mask*/
+				result->enabled_raw |= mask;
+				selected = true;
+				break;
+			}
+		} else {
+			dev_info(cam->dev, "[%s:select] traversed current raw %d/0x%x, stagger_select_raw_mask:0x%x\n",
+				__func__, m, mask, stagger_select.raw_select);
+		}
+	}
+
+	return selected;
+}
+
+int mtk_cam_raw_stagger_select(struct mtk_cam_ctx *ctx,
+				      struct mtk_raw_pipeline *pipe,
+				      int raw_status)
+{
+	bool selected;
+	struct mtk_raw_stagger_select result;
+
+	selected = raw_stagger_select(ctx, raw_status,
+				      pipe->hw_mode, &result);
+
+	ctx->pipe->stagger_path_pending = result.stagger_path;
+	ctx->pipe->stagger_path = ctx->pipe->stagger_path_pending;
+	pipe->enabled_raw |= result.enabled_raw;
+
+	return selected;
+}
+
+int mtk_cam_s_data_raw_stagger_select(struct mtk_cam_request_stream_data *s_data,
+			    int raw_status)
+{
+	struct mtk_cam_ctx *ctx;
+	struct mtk_raw_pipeline *pipe;
+	bool selected;
+	struct mtk_raw_stagger_select *result;
+	struct mtk_cam_req_raw_pipe_data *s_raw_pipe_data;
+
+
+	s_raw_pipe_data = mtk_cam_s_data_get_raw_pipe_data(s_data);
+	result = &s_raw_pipe_data->stagger_select;
+	ctx = mtk_cam_s_data_get_ctx(s_data);
+	pipe = ctx->pipe;
+
+	selected = raw_stagger_select(ctx,
+				raw_status,
+				pipe->hw_mode,
+				result);
+
+	ctx->pipe->stagger_path_pending = result->stagger_path;
+	s_raw_pipe_data->enabled_raw |= result->enabled_raw;
+
+	return selected;
+
+}
+#endif
+
+int mtk_cam_s_data_raw_select(struct mtk_cam_request_stream_data *s_data,
+			    struct mtkcam_ipi_input_param *cfg_in_param)
+{
+	struct mtk_cam_ctx *ctx;
+	struct mtk_raw_pipeline *pipe;
+	int raw_status = 0;
+#ifdef ISP7_1
+	struct mtk_cam_req_raw_pipe_data *s_raw_pipe_data;
+	bool selected = false;
+
+	s_raw_pipe_data = mtk_cam_s_data_get_raw_pipe_data(s_data);
+#endif
+
+	ctx = mtk_cam_s_data_get_ctx(s_data);
+	pipe = ctx->pipe;
+	raw_status = mtk_raw_available_resource(pipe->raw);
+	raw_status &= ~pipe->enabled_raw;
+
+#ifdef ISP7_1
+	if (mtk_cam_feature_is_stagger(s_raw_pipe_data->res.raw_res.feature))
+		selected = mtk_cam_s_data_raw_stagger_select(s_data, raw_status);
+#endif
+
+	mtk_raw_available_resource(pipe->raw);
+
+#ifdef ISP7_1
+
+	if (!selected)
+		return -EINVAL;
+#endif
+
+	return 0;
+}
+
+
+int mtk_cam_raw_select(struct mtk_cam_ctx *ctx,
+		       struct mtkcam_ipi_input_param *cfg_in_param)
+{
+	struct mtk_cam_device *cam = ctx->cam;
+	struct mtk_raw_pipeline *pipe = ctx->pipe;
+	struct mtk_raw_pipeline *pipe_chk;
+	int raw_status = 0;
+	int mask = 0x0;
+	bool selected = false;
+	int m;
+
+	pipe->enabled_raw = 0;
+	raw_status = mtk_raw_available_resource(pipe->raw);
+#ifdef ISP7_1
+	if (mtk_cam_is_stagger(ctx)) {
+		selected = mtk_cam_raw_stagger_select(ctx, pipe, raw_status);
+	} else if (mtk_cam_feature_is_time_shared(pipe->feature_pending)) {
+#else
+	if (mtk_cam_feature_is_time_shared(pipe->feature_pending)) {
+#endif
+		int ts_id, ts_id_chk;
+		/*First, check if group ID used in every pipeline*/
+		/*if yes , use same engine*/
+		for (m = MTKCAM_SUBDEV_RAW_0; m < ARRAY_SIZE(pipe->raw->devs); m++) {
+			pipe_chk = pipe->raw->pipelines + m;
+			dev_info(cam->dev, "[%s] checking idx:%d pipe_id:%d pipe_chk_id:%d\n",
+				__func__, m, pipe->id, pipe_chk->id);
+			if (pipe->id != pipe_chk->id) {
+				ts_id = pipe->feature_active &
+						MTK_CAM_FEATURE_TIMESHARE_MASK;
+				ts_id_chk = pipe_chk->feature_active &
+							MTK_CAM_FEATURE_TIMESHARE_MASK;
+				if (ts_id == ts_id_chk &&
+					pipe_chk->enabled_raw != 0) {
+					mask = pipe_chk->enabled_raw & MTKCAM_SUBDEV_RAW_MASK;
+					pipe->enabled_raw |= mask;
+					selected = true;
+					break;
+				}
+			}
+		}
+		if (selected) {
+			dev_info(cam->dev, "[%s] Timeshared (%d)- enabled_raw:0x%x as pipe:%d enabled_raw:0x%x\n",
+				__func__, ts_id >> 8, pipe->enabled_raw,
+				pipe_chk->id, pipe_chk->enabled_raw);
+		} else {
+			/*if no , use new engine from a->b->c*/
+			for (m = MTKCAM_SUBDEV_RAW_0; m < ARRAY_SIZE(pipe->raw->devs); m++) {
+				pipe_chk = pipe->raw->pipelines + m;
+				mask = 1 << m;
+				if (!(raw_status & mask)) {
+					pipe->enabled_raw |= mask;
+					selected = true;
+					break;
+				}
+			}
+		}
+	} else if (pipe->res_config.raw_num_used == 3) {
+		mask = 1 << MTKCAM_SUBDEV_RAW_0
+			| 1 << MTKCAM_SUBDEV_RAW_1 | 1 << MTKCAM_SUBDEV_RAW_2;
+		if (!(raw_status & mask)) {
+			pipe->enabled_raw |= mask;
+			selected = true;
+		}
+	} else if (pipe->res_config.raw_num_used == 2) {
+		for (m = MTKCAM_SUBDEV_RAW_0; m >= MTKCAM_SUBDEV_RAW_0; m--) {
+			mask = (1 << m) | (1 << (m + 1));
+			if (!(raw_status & mask)) {
+				pipe->enabled_raw |= mask;
+				selected = true;
+				break;
+			}
+		}
+	} else {
+		for (m = MTKCAM_SUBDEV_RAW_0; m < ARRAY_SIZE(pipe->raw->devs); m++) {
+			mask = 1 << m;
+			if (!(raw_status & mask)) {
+				pipe->enabled_raw |= mask;
+				selected = true;
+				break;
+			}
+		}
+	}
+	mtk_raw_available_resource(pipe->raw);
+	if (!selected)
+		return -EINVAL;
+	/**
+	 * TODO: duplicated using raw case will implement in time sharing isp case
+	 */
+
+	return 0;
+}
+
+static int mtk_raw_sd_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	struct mtk_raw_pipeline *pipe;
+	struct mtk_raw *raw;
+	struct mtk_cam_device *cam;
+	struct mtk_cam_ctx *ctx;
+	unsigned int i;
+
+	pipe = container_of(sd, struct mtk_raw_pipeline, subdev);
+	if (!pipe)
+		return -1;
+	raw = pipe->raw;
+	if (!raw)
+		return -1;
+	cam = dev_get_drvdata(raw->cam_dev);
+	ctx = mtk_cam_find_ctx(cam, &sd->entity);
+
+	if (WARN_ON(!ctx))
+		return -EINVAL;
+
+	if (enable) {
+		pipe->feature_active = pipe->user_res.raw_res.feature;
+		pipe->enabled_dmas = 0;
+		ctx->pipe = pipe;
+		ctx->used_raw_num++;
+		pipe->feature_active = pipe->user_res.raw_res.feature;
+		for (i = 0; i < ARRAY_SIZE(pipe->vdev_nodes); i++) {
+			if (!pipe->vdev_nodes[i].enabled)
+				continue;
+			pipe->enabled_dmas |=
+				(1ULL << pipe->vdev_nodes[i].desc.dma_port);
+		}
+	} else {
+		for (i = 0; i < ARRAY_SIZE(raw->devs); i++) {
+			if (pipe->enabled_raw & 1 << i) {
+				dev_info(raw->cam_dev, "%s: power off raw (%d)\n", __func__, i);
+				pm_runtime_put_sync(raw->devs[i]);
+			}
+		}
+	}
+
+	dev_info(raw->cam_dev, "%s:raw-%d: en %d, dev 0x%x dmas 0x%lx\n",
+		 __func__, pipe->id, enable, pipe->enabled_raw,
+		 pipe->enabled_dmas);
+
+	return 0;
+}
+
+static int mtk_raw_init_cfg(struct v4l2_subdev *sd,
+			    struct v4l2_subdev_state *sd_state)
+{
+	struct v4l2_mbus_framefmt *mf;
+	unsigned int i;
+	struct mtk_raw_pipeline *pipe =
+		container_of(sd, struct mtk_raw_pipeline, subdev);
+	struct mtk_raw *raw = pipe->raw;
+
+	for (i = 0; i < sd->entity.num_pads; i++) {
+		mf = v4l2_subdev_get_try_format(sd, sd_state, i);
+		*mf = mfmt_default;
+		pipe->cfg[i].mbus_fmt = mfmt_default;
+
+		dev_dbg(raw->cam_dev, "%s init pad:%d format:0x%x\n",
+			sd->name, i, mf->code);
+	}
+
+	return 0;
+}
+
+static bool mtk_raw_try_fmt(struct v4l2_subdev *sd,
+			   struct v4l2_subdev_format *fmt)
+{
+	struct mtk_raw_pipeline *pipe =
+		container_of(sd, struct mtk_raw_pipeline, subdev);
+	struct mtk_raw *raw = pipe->raw;
+	unsigned int user_fmt = mtk_cam_get_sensor_fmt(fmt->format.code);
+
+	dev_dbg(raw->cam_dev, "%s:s_fmt: check format 0x%x, w:%d, h:%d field:%d\n",
+		sd->name, fmt->format.code, fmt->format.width,
+		fmt->format.height, fmt->format.field);
+
+	/* check sensor format */
+	if (fmt->pad == MTK_RAW_SINK) {
+		user_fmt = mtk_cam_get_sensor_fmt(fmt->format.code);
+		if (user_fmt == MTKCAM_IPI_IMG_FMT_UNKNOWN)
+			return false;
+	}
+
+	return true;
+}
+
+struct v4l2_mbus_framefmt*
+mtk_raw_pipeline_get_fmt(struct mtk_raw_pipeline *pipe,
+					struct v4l2_subdev_state *sd_state,
+					int padid, int which)
+{
+	/* format invalid and return default format */
+	if (which == V4L2_SUBDEV_FORMAT_TRY)
+		return v4l2_subdev_get_try_format(&pipe->subdev, sd_state, padid);
+
+	if (WARN_ON(padid >= pipe->subdev.entity.num_pads))
+		return &pipe->cfg[0].mbus_fmt;
+
+	return &pipe->cfg[padid].mbus_fmt;
+}
+
+struct v4l2_rect*
+mtk_raw_pipeline_get_selection(struct mtk_raw_pipeline *pipe,
+					struct v4l2_subdev_state *sd_state,
+					int pad, int which)
+{
+	/* format invalid and return default format */
+	if (which == V4L2_SUBDEV_FORMAT_TRY)
+		return v4l2_subdev_get_try_crop(&pipe->subdev, sd_state, pad);
+
+	if (WARN_ON(pad >= pipe->subdev.entity.num_pads))
+		return &pipe->cfg[0].crop;
+
+	return &pipe->cfg[pad].crop;
+}
+
+static void propagate_fmt(struct v4l2_mbus_framefmt *sink_mf,
+			  struct v4l2_mbus_framefmt *source_mf, int w, int h)
+{
+	source_mf->code = sink_mf->code;
+	source_mf->colorspace = sink_mf->colorspace;
+	source_mf->field = sink_mf->field;
+	source_mf->width = w;
+	source_mf->height = h;
+}
+
+bool mtk_raw_fmt_get_res(struct v4l2_subdev *sd,
+				struct v4l2_subdev_format *fmt,
+				struct mtk_cam_resource *res)
+{
+	void *user_ptr;
+	u64 addr;
+
+	addr = ((u64)fmt->reserved[1] << 32) | fmt->reserved[2];
+	user_ptr = (void *)addr;
+	if (!user_ptr) {
+		dev_info(sd->v4l2_dev->dev, "%s: mtk_cam_resource is null\n",
+			__func__);
+		return false;
+	}
+
+	if (copy_from_user(res, user_ptr, sizeof(*res))) {
+		dev_info(sd->v4l2_dev->dev, "%s: copy_from_user failedm user_ptr:%p\n",
+			__func__, user_ptr);
+		return false;
+	}
+
+	dev_dbg(sd->v4l2_dev->dev, "%s:sensor:%d/%d/%lld/%d/%d, raw:%lld/%d/%d/%d/%d/%d/%d/%d/%lld\n",
+		__func__,
+		res->sensor_res.hblank, res->sensor_res.vblank,
+		res->sensor_res.pixel_rate,	res->sensor_res.interval.denominator,
+		res->sensor_res.interval.numerator,
+		res->raw_res.feature, res->raw_res.bin, res->raw_res.path_sel,
+		res->raw_res.raw_max, res->raw_res.raw_min, res->raw_res.raw_used,
+		res->raw_res.strategy, res->raw_res.pixel_mode,
+		res->raw_res.throughput);
+
+	return res;
+}
+
+static int mtk_raw_set_src_pad_selection_default(struct v4l2_subdev *sd,
+				struct v4l2_subdev_state *sd_state,
+				struct v4l2_mbus_framefmt *sink_fmt,
+				struct mtk_cam_resource *res,
+				int pad, int which)
+{
+	struct v4l2_rect *source_sel;
+	struct mtk_raw_pipeline *pipe;
+
+	pipe = container_of(sd, struct mtk_raw_pipeline, subdev);
+	source_sel = mtk_raw_pipeline_get_selection(pipe, sd_state, pad, which);
+	if (source_sel->width > sink_fmt->width) {
+		source_sel->width = sink_fmt->width;
+		/* may need some log */
+	}
+
+	if (source_sel->height > sink_fmt->height) {
+		source_sel->height = sink_fmt->height;
+		/* may need some log */
+	}
+
+	return 0;
+}
+
+static int mtk_raw_set_src_pad_selection_yuv(struct v4l2_subdev *sd,
+				struct v4l2_subdev_state *sd_state,
+				struct v4l2_mbus_framefmt *sink_fmt,
+				struct mtk_cam_resource *res,
+				int pad, int which)
+{
+	int i;
+	struct v4l2_rect *prev_yuv = NULL, *source_sel, *tmp_sel;
+	struct v4l2_mbus_framefmt *framefmt;
+	struct mtk_raw_pipeline *pipe;
+
+	pipe = container_of(sd, struct mtk_raw_pipeline, subdev);
+	mtk_raw_set_src_pad_selection_default(sd, sd_state, sink_fmt, res, pad, which);
+	source_sel = mtk_raw_pipeline_get_selection(pipe, sd_state, pad, which);
+
+	for (i = MTK_RAW_YUVO_1_OUT; i < pad; i++) {
+		framefmt = mtk_raw_pipeline_get_fmt(pipe, sd_state, pad, which);
+		tmp_sel = mtk_raw_pipeline_get_selection(pipe, sd_state, pad, which);
+
+		/* Skip disabled YUV pad */
+		if (!mtk_cam_is_pad_fmt_enable(framefmt))
+			continue;
+
+		prev_yuv = tmp_sel;
+	}
+
+	if (prev_yuv) {
+		if (source_sel->width != prev_yuv->width) {
+			source_sel->width = prev_yuv->width;
+			/* may need some log */
+		}
+
+		if (source_sel->height != prev_yuv->height) {
+			source_sel->height = prev_yuv->height;
+			/* may need some log */
+		}
+	}
+
+	return 0;
+}
+
+static struct v4l2_mbus_framefmt*
+mtk_raw_get_sink_pad_framefmt(struct v4l2_subdev *sd,
+				struct v4l2_subdev_state *sd_state, int which)
+{
+	struct v4l2_mbus_framefmt *sink_fmt = NULL, *tmp_fmt;
+	struct mtk_raw_pipeline *pipe;
+	int i;
+
+	pipe = container_of(sd, struct mtk_raw_pipeline, subdev);
+	for (i = MTK_RAW_SINK; i < MTK_RAW_SOURCE_BEGIN; i++) {
+		tmp_fmt = mtk_raw_pipeline_get_fmt(pipe, sd_state, i, which);
+		if (i != MTK_RAW_META_IN &&
+			mtk_cam_is_pad_fmt_enable(tmp_fmt)) {
+			sink_fmt = tmp_fmt;
+			break;
+		}
+	}
+
+	return sink_fmt;
+}
+
+int mtk_cam_collect_psel(struct mtk_raw_pipeline *pipe,
+			 struct v4l2_subdev_selection *sel)
+{
+	pipe->req_psel_update |= 1 << sel->pad;
+	pipe->req_psel[sel->pad] = *sel;
+
+	dev_info(pipe->subdev.v4l2_dev->dev,
+		 "%s:%s:pad(%d), pending s_selection, l/t/w/h=(%d,%d,%d,%d)\n",
+		 __func__, pipe->subdev.name, sel->pad,
+		 sel->r.left, sel->r.top,
+		 sel->r.width, sel->r.height);
+
+	return 0;
+}
+
+static int mtk_raw_set_pad_selection(struct v4l2_subdev *sd,
+				struct v4l2_subdev_state *sd_state,
+				struct v4l2_subdev_selection *sel)
+{
+	struct v4l2_mbus_framefmt *sink_fmt = NULL;
+	struct mtk_raw_pipeline *pipe;
+	struct mtk_cam_video_device *node;
+	struct mtk_cam_resource *res = NULL;
+	struct v4l2_rect *crop;
+	int ret;
+
+	if (sel->pad < MTK_RAW_MAIN_STREAM_OUT || sel->pad >= MTK_RAW_META_OUT_BEGIN)
+		return -EINVAL;
+
+	pipe = container_of(sd, struct mtk_raw_pipeline, subdev);
+
+	/* if the pipeline is streaming, pending the change */
+	if (sel->which == V4L2_SUBDEV_FORMAT_ACTIVE &&
+	    !media_entity_is_streaming(&sd->entity)) {
+		mtk_cam_collect_psel(pipe, sel);
+		return 0;
+	}
+
+	/*
+	 * Find the sink pad fmt, there must be one eanbled sink pad at least
+	 */
+	sink_fmt = mtk_raw_get_sink_pad_framefmt(sd, sd_state, sel->which);
+	if (!sink_fmt)
+		return -EINVAL;
+
+	node = &pipe->vdev_nodes[sel->pad - MTK_RAW_SINK_NUM];
+	crop = mtk_raw_pipeline_get_selection(pipe, sd_state, sel->pad, sel->which);
+	*crop = sel->r;
+	ret = node->desc.pad_ops->set_pad_selection(sd, sd_state, sink_fmt, res, sel->pad, sel->which);
+	if (ret)
+		return -EINVAL;
+
+	sel->r = *crop;
+
+	return 0;
+}
+
+static int mtk_raw_get_pad_selection(struct v4l2_subdev *sd,
+				struct v4l2_subdev_state *sd_state,
+				struct v4l2_subdev_selection *sel)
+{
+	return 0;
+}
+
+static int mtk_raw_set_sink_pad_fmt(struct v4l2_subdev *sd,
+				struct v4l2_subdev_state *sd_state,
+				struct v4l2_subdev_format *fmt)
+{
+	struct device *dev;
+	struct mtk_cam_video_device *node;
+	const char *node_str;
+	const struct mtk_cam_format_desc *fmt_desc;
+	struct mtk_raw_pipeline *pipe;
+	int i;
+	int ipi_fmt;
+	struct v4l2_mbus_framefmt *framefmt, *source_fmt = NULL, *tmp_fmt;
+
+	/* Do nothing for pad to meta video device */
+	if (fmt->pad == MTK_RAW_META_IN)
+		return 0;
+
+	dev = sd->v4l2_dev->dev;
+	pipe = container_of(sd, struct mtk_raw_pipeline, subdev);
+	framefmt = mtk_raw_pipeline_get_fmt(pipe, sd_state, fmt->pad, fmt->which);
+
+	/* If data from sensor, we check the size with max imgo size*/
+	if (fmt->pad < MTK_RAW_SINK_NUM) {
+		/* from sensor */
+		node = &pipe->vdev_nodes[MTK_RAW_MAIN_STREAM_OUT - MTK_RAW_SINK_NUM];
+		node_str = "sink";
+	} else {
+		/* from memory */
+		node = &pipe->vdev_nodes[fmt->pad - MTK_RAW_SINK_NUM];
+		node_str = node->desc.name;
+	}
+
+	ipi_fmt = mtk_cam_get_sensor_fmt(framefmt->code);
+	if (ipi_fmt == MTKCAM_IPI_IMG_FMT_UNKNOWN) {
+		/**
+		 * Set imgo's default fmt, the user must check
+		 * if the pad sink format is the same as the
+		 * source format of the link before stream on.
+		 */
+		fmt_desc = &node->desc.fmts[node->desc.default_fmt_idx];
+		framefmt->code = fmt_desc->pfmt.code;
+		dev_info(dev,
+			"%s(%d): Adjust unaccept fmt code on sink pad:%d, 0x%x->0x%x\n",
+			__func__, fmt->which, fmt->pad, fmt->format.code, framefmt->code);
+	}
+
+	/* Reset pads' enable state*/
+	for (i = MTK_RAW_SINK; i < MTK_RAW_META_OUT_BEGIN; i++) {
+		if (i == MTK_RAW_META_IN)
+			continue;
+		tmp_fmt = mtk_raw_pipeline_get_fmt(pipe, sd_state, i, fmt->which);
+		mtk_cam_pad_fmt_enable(tmp_fmt, false);
+	}
+
+	/* TODO: copy the filed we are used only*/
+	*framefmt = fmt->format;
+	if (framefmt->width > node->desc.frmsizes->stepwise.max_width)
+		framefmt->width = node->desc.frmsizes->stepwise.max_width;
+
+	if (framefmt->height > node->desc.frmsizes->stepwise.max_height)
+		framefmt->height = node->desc.frmsizes->stepwise.max_height;
+
+	mtk_cam_pad_fmt_enable(framefmt, true);
+
+	dev_info(dev,
+		"%s(%d): Set fmt pad:%d(%s), code/w/h = 0x%x/%d/%d\n",
+		__func__, fmt->which, fmt->pad, node_str,
+		framefmt->code, framefmt->width, framefmt->height);
+
+	/* Propagation inside subdev */
+	for (i = MTK_RAW_SOURCE_BEGIN; i < MTK_RAW_META_OUT_BEGIN; i++) {
+		source_fmt = mtk_raw_pipeline_get_fmt(pipe, sd_state, i, fmt->which);
+
+		/* Get default format's desc for the pad */
+		node = &pipe->vdev_nodes[i - MTK_RAW_SINK_NUM];
+
+		/**
+		 * Propagate the size from sink pad to source pades, adjusted
+		 * based on each pad's default format.
+		 */
+		if (source_fmt->width > node->desc.frmsizes->stepwise.max_width)
+			source_fmt->width = node->desc.frmsizes->stepwise.max_width;
+		else
+			source_fmt->width = framefmt->width;
+
+		if (source_fmt->height > node->desc.frmsizes->stepwise.max_height)
+			source_fmt->height = node->desc.frmsizes->stepwise.max_height;
+		else
+			source_fmt->height = framefmt->height;
+
+		dev_dbg(dev,
+			"%s(%d): Propagate to pad:%d(%s), (0x%x/%d/%d)\n",
+			__func__, fmt->which, fmt->pad, node->desc.name,
+			source_fmt->code, source_fmt->width, source_fmt->height);
+
+	}
+
+	return 0;
+}
+
+static int mtk_raw_set_src_pad_fmt_default(struct v4l2_subdev *sd,
+				struct v4l2_subdev_state *sd_state,
+				struct v4l2_mbus_framefmt *sink_fmt,
+				struct mtk_cam_resource *res,
+				int pad, int which)
+{
+	struct device *dev;
+	struct v4l2_mbus_framefmt *source_fmt;
+	struct mtk_raw_pipeline *pipe =
+		container_of(sd, struct mtk_raw_pipeline, subdev);
+	struct mtk_cam_video_device *node;
+
+	dev = sd->v4l2_dev->dev;
+	node = &pipe->vdev_nodes[pad - MTK_RAW_SINK_NUM];
+	source_fmt = mtk_raw_pipeline_get_fmt(pipe, sd_state, pad, which);
+	if (source_fmt->width > sink_fmt->width) {
+		dev_info(dev,
+			"%s(%d): adjusted: width(%d) over sink (%d)\n",
+			__func__, which, source_fmt->width, sink_fmt->width);
+		source_fmt->width = sink_fmt->width;
+	}
+
+	if (source_fmt->height > sink_fmt->height) {
+		dev_info(dev,
+			"%s(%d): adjusted: width(%d) over sink (%d)\n",
+			__func__, which, source_fmt->height, sink_fmt->height);
+		source_fmt->height = sink_fmt->height;
+	}
+
+	if (source_fmt->width > node->desc.frmsizes->stepwise.max_width) {
+		dev_info(dev,
+			"%s(%d): adjusted: width(%d) over max (%d)\n",
+			__func__, which, source_fmt->width, node->desc.frmsizes->stepwise.max_width);
+		source_fmt->width = node->desc.frmsizes->stepwise.max_width;
+	}
+
+	if (source_fmt->height > node->desc.frmsizes->stepwise.max_height) {
+		dev_info(dev,
+			"%s(%d): adjusted: height(%d) over max (%d)\n",
+			__func__, which, source_fmt->height, node->desc.frmsizes->stepwise.max_height);
+	}
+
+	return 0;
+}
+
+static int mtk_raw_set_src_pad_fmt_rzh1n2(struct v4l2_subdev *sd,
+				struct v4l2_subdev_state *sd_state,
+				struct v4l2_mbus_framefmt *sink_fmt,
+				struct mtk_cam_resource *res,
+				int pad, int which)
+{
+	struct device *dev;
+	struct v4l2_mbus_framefmt *source_fmt;
+	struct v4l2_mbus_framefmt *tmp_fmt;
+	struct mtk_raw_pipeline *pipe =
+		container_of(sd, struct mtk_raw_pipeline, subdev);
+
+	dev = sd->v4l2_dev->dev;
+	mtk_raw_set_src_pad_fmt_default(sd, sd_state, sink_fmt, res, pad, which);
+	source_fmt = mtk_raw_pipeline_get_fmt(pipe, sd_state, pad, which);
+
+	/* rzh1n2to_r1 and rzh1n2to_r3 size must be the same */
+	if (pad == MTK_RAW_RZH1N2TO_3_OUT) {
+		tmp_fmt = mtk_raw_pipeline_get_fmt(pipe, sd_state, MTK_RAW_RZH1N2TO_1_OUT, which);
+		if (mtk_cam_is_pad_fmt_enable(tmp_fmt) &&
+			source_fmt->height != tmp_fmt->height &&
+			source_fmt->width != tmp_fmt->width) {
+			dev_info(dev,
+				"%s(%d): adjusted: rzh1n2to_r3(%d,%d) and rzh1n2to_r1(%d,%d) must have the same sz\n",
+				__func__, which, source_fmt->width,
+				source_fmt->height, tmp_fmt->width, tmp_fmt->height);
+			source_fmt->width = tmp_fmt->width;
+			source_fmt->height = tmp_fmt->height;
+		}
+	}
+
+	return 0;
+}
+
+static int mtk_raw_set_src_pad_fmt(struct v4l2_subdev *sd,
+	struct v4l2_subdev_state *sd_state,
+	struct v4l2_subdev_format *fmt)
+{
+	struct device *dev;
+	struct mtk_cam_resource res;
+	struct mtk_cam_video_device *node;
+	struct mtk_raw_pipeline *pipe;
+	int ret = 0;
+	struct v4l2_mbus_framefmt *source_fmt, *sink_fmt = NULL;
+
+	/* Do nothing for pad to meta video device */
+	if (fmt->pad >= MTK_RAW_META_OUT_BEGIN)
+		return 0;
+
+	pipe = container_of(sd, struct mtk_raw_pipeline, subdev);
+	dev = sd->v4l2_dev->dev;
+	node = &pipe->vdev_nodes[fmt->pad - MTK_RAW_SINK_NUM];
+
+	/*
+	 * Find the sink pad fmt, there must be one eanbled sink pad at least
+	 */
+	sink_fmt = mtk_raw_get_sink_pad_framefmt(sd, sd_state, fmt->which);
+	if (!sink_fmt) {
+		dev_info(dev,
+			"%s(%d): Set fmt pad:%d(%s), no s_fmt on sink pad\n",
+			__func__, fmt->which, fmt->pad, node->desc.name);
+		return -EINVAL;
+	}
+
+	if (!mtk_raw_fmt_get_res(sd, fmt, &res)) {
+		dev_info(dev,
+			"%s(%d): Set fmt pad:%d(%s), no mtk_cam_resource found\n",
+			__func__, fmt->which, fmt->pad, node->desc.name);
+		return -EINVAL;
+	}
+
+	if (node->desc.pad_ops->set_pad_fmt) {
+		/* call source pad's set_pad_fmt op to adjust fmt by pad */
+		source_fmt = mtk_raw_pipeline_get_fmt(pipe, sd_state, fmt->pad, fmt->which);
+		/* TODO: copy the fileds we are used only*/
+		*source_fmt = fmt->format;
+		ret = node->desc.pad_ops->set_pad_fmt(sd, sd_state, sink_fmt, &res, fmt->pad,
+			fmt->which);
+	}
+
+	if (ret)
+		return ret;
+
+	dev_dbg(dev,
+		"%s(%d): s_fmt to pad:%d(%s), user(0x%x/%d/%d) driver(0x%x/%d/%d)\n",
+		__func__, fmt->which, fmt->pad, node->desc.name,
+		fmt->format.code, fmt->format.width, fmt->format.height,
+		source_fmt->code, source_fmt->width, source_fmt->height);
+	mtk_cam_pad_fmt_enable(source_fmt, false);
+	fmt->format = *source_fmt;
+
+	return 0;
+}
+
+static int mtk_raw_try_pad_fmt(struct v4l2_subdev *sd,
+				struct v4l2_subdev_state *sd_state,
+				struct v4l2_subdev_format *fmt)
+{
+
+	if (fmt->pad >= MTK_RAW_SINK && fmt->pad < MTK_RAW_SOURCE_BEGIN)
+		mtk_raw_set_sink_pad_fmt(sd, sd_state, fmt);
+	else if (fmt->pad < MTK_RAW_PIPELINE_PADS_NUM)
+		mtk_raw_set_src_pad_fmt(sd, sd_state, fmt);
+	else
+		return -EINVAL;
+
+	return 0;
+}
+
+/* To be deplicated */
+static int mtk_raw_call_set_fmt(struct v4l2_subdev *sd,
+				struct v4l2_subdev_state *sd_state,
+				struct v4l2_subdev_format *fmt,
+				bool streaming)
+{
+	struct mtk_raw_pipeline *pipe =
+		container_of(sd, struct mtk_raw_pipeline, subdev);
+	struct mtk_raw *raw = pipe->raw;
+	struct v4l2_mbus_framefmt *mf;
+
+	if (!sd || !fmt) {
+		dev_dbg(raw->cam_dev, "%s: Required sd(%p), fmt(%p)\n",
+			__func__, sd, fmt);
+		return -EINVAL;
+	}
+
+	if (fmt->which == V4L2_SUBDEV_FORMAT_TRY && !sd_state) {
+		dev_dbg(raw->cam_dev, "%s: Required sd(%p), cfg(%p) for FORMAT_TRY\n",
+			__func__, sd, sd_state);
+		return -EINVAL;
+	}
+
+	if (!mtk_raw_try_fmt(sd, fmt) &&
+			!mtk_cam_feature_is_pure_m2m(
+			pipe->feature_pending)) {
+		mf = mtk_raw_pipeline_get_fmt(pipe, sd_state, fmt->pad, fmt->which);
+		fmt->format = *mf;
+		dev_info(raw->cam_dev,
+			"sd:%s pad:%d didn't apply and keep format w/h/code %d/%d/0x%x\n",
+			sd->name, fmt->pad, mf->width, mf->height, mf->code);
+	} else {
+		mf = mtk_raw_pipeline_get_fmt(pipe, sd_state, fmt->pad, fmt->which);
+		*mf = fmt->format;
+		dev_dbg(raw->cam_dev,
+			"sd:%s pad:%d set format w/h/code %d/%d/0x%x\n",
+			sd->name, fmt->pad, mf->width, mf->height, mf->code);
+	}
+
+	/*sink pad format propagate to source pad*/
+	if (fmt->pad == MTK_RAW_SINK) {
+		struct v4l2_mbus_framefmt *source_mf;
+		struct v4l2_format *img_fmt;
+
+		if (fmt->which == V4L2_SUBDEV_FORMAT_ACTIVE) {
+			img_fmt = &pipe->vdev_nodes[MTK_RAW_SINK].pending_fmt;
+			img_fmt->fmt.pix_mp.width = mf->width;
+			img_fmt->fmt.pix_mp.height = mf->height;
+		}
+		source_mf = mtk_raw_pipeline_get_fmt(pipe, sd_state,
+								MTK_RAW_MAIN_STREAM_OUT,
+								fmt->which);
+
+		if (streaming) {
+			propagate_fmt(mf, source_mf, mf->width, mf->height);
+
+			return 0;
+		}
+
+		/**
+		 * User will trigger resource calc with V4L2_CID_MTK_CAM_RAW_RESOURCE_CALC
+		 * so we don't need to trigger it here anymore.
+		 */
+		propagate_fmt(mf, source_mf, mf->width, mf->height);
+	}
+
+	return 0;
+}
+
+int mtk_raw_call_pending_set_fmt(struct v4l2_subdev *sd,
+				struct v4l2_subdev_format *fmt)
+{
+	struct mtk_raw_pipeline *pipe =
+		container_of(sd, struct mtk_raw_pipeline, subdev);
+	struct mtk_cam_device *cam = dev_get_drvdata(pipe->raw->cam_dev);
+
+	/* We only allow V4L2_SUBDEV_FORMAT_ACTIVE for pending set fmt */
+	if (fmt->which != V4L2_SUBDEV_FORMAT_ACTIVE) {
+		dev_info(cam->dev,
+			"%s:pipe(%d):pad(%d): only allow V4L2_SUBDEV_FORMAT_ACTIVE\n",
+				__func__, pipe->id, fmt->pad);
+		return -EINVAL;
+	}
+
+	return mtk_raw_call_set_fmt(sd, NULL, fmt, true);
+}
+
+static int mtk_cam_collect_pfmt(struct mtk_raw_pipeline *pipe,
+				struct v4l2_subdev_format *fmt)
+{
+	int pad = fmt->pad;
+
+	if (pad < 0) {
+		dev_dbg(pipe->subdev.v4l2_dev->dev,
+			"error: %s: invalid parameter(pad)\n",
+			__func__);
+		return -EINVAL;
+	}
+	pipe->req_pfmt_update |= 1 << pad;
+	pipe->req_pad_fmt[pad] = *fmt;
+
+	dev_dbg(pipe->subdev.v4l2_dev->dev,
+		"%s:%s:pad(%d), pending s_fmt, w/h/code=%d/%d/0x%x\n",
+		__func__, pipe->subdev.name,
+		pad, fmt->format.width, fmt->format.height,
+		fmt->format.code);
+
+	return 0;
+}
+
+static int mtk_raw_set_fmt(struct v4l2_subdev *sd,
+				struct v4l2_subdev_state *sd_state,
+				struct v4l2_subdev_format *fmt)
+{
+	struct mtk_raw_pipeline *pipe =
+		container_of(sd, struct mtk_raw_pipeline, subdev);
+
+	if (fmt->which == V4L2_SUBDEV_FORMAT_TRY)
+		return mtk_raw_try_pad_fmt(sd, sd_state, fmt);
+
+	/* if the pipeline is streaming, pending the change */
+	if (!media_entity_is_streaming(&sd->entity))
+		return mtk_raw_call_set_fmt(sd, sd_state, fmt, false);
+
+	mtk_cam_collect_pfmt(pipe, fmt);
+
+	return 0;
+}
+
+static int mtk_raw_get_fmt(struct v4l2_subdev *sd,
+			   struct v4l2_subdev_state *sd_state,
+			  struct v4l2_subdev_format *fmt)
+{
+	struct mtk_raw_pipeline *pipe =
+		container_of(sd, struct mtk_raw_pipeline, subdev);
+	struct mtk_raw *raw = pipe->raw;
+	struct v4l2_mbus_framefmt *mf;
+
+	mf = mtk_raw_pipeline_get_fmt(pipe, sd_state, fmt->pad, fmt->which);
+	fmt->format = *mf;
+	dev_dbg(raw->cam_dev, "sd:%s pad:%d get format w/h/code %d/%d/0x%x\n",
+		sd->name, fmt->pad, fmt->format.width, fmt->format.height,
+		fmt->format.code);
+
+	return 0;
+}
+
+void mtk_cam_update_sensor(struct mtk_cam_ctx *ctx, struct v4l2_subdev *sensor)
+{
+	ctx->prev_sensor = ctx->sensor;
+	ctx->sensor = sensor;
+}
+
+struct v4l2_subdev *mtk_cam_find_sensor(struct mtk_cam_ctx *ctx,
+					struct media_entity *entity)
+{
+	struct v4l2_subdev *sensor = NULL;
+	struct media_pipeline_pad *ppad;
+
+	list_for_each_entry(ppad, &ctx->pipeline.pads, list) {
+		entity = ppad->pad->entity;
+		dev_dbg(ctx->cam->dev, "linked entity: %s\n", entity->name);
+
+		sensor = NULL;
+
+		switch (entity->function) {
+		case MEDIA_ENT_F_CAM_SENSOR:
+			sensor = media_entity_to_v4l2_subdev(entity);
+			break;
+		default:
+			break;
+		}
+
+		if (sensor)
+			break;
+	}
+
+	return sensor;
+}
+
+unsigned int mtk_raw_get_hdr_scen_id(
+	struct mtk_cam_ctx *ctx)
+{
+	unsigned int hw_scen =
+		(1 << MTKCAM_IPI_HW_PATH_ON_THE_FLY_DCIF_STAGGER);
+
+	if (ctx->pipe->stagger_path == STAGGER_ON_THE_FLY)
+		hw_scen = (1 << MTKCAM_IPI_HW_PATH_ON_THE_FLY_DCIF_STAGGER);
+#ifdef ISP7_1
+	else if (ctx->pipe->stagger_path == STAGGER_DCIF)
+		hw_scen = (1 << MTKCAM_IPI_HW_PATH_OFFLINE_SRT_DCIF_STAGGER);
+#endif
+	else if (ctx->pipe->stagger_path == STAGGER_OFFLINE)
+		hw_scen = (1 << MTKCAM_IPI_HW_PATH_OFFLINE_STAGGER);
+
+	return hw_scen;
+}
+
+static int mtk_cam_media_link_setup(struct media_entity *entity,
+				    const struct media_pad *local,
+				    const struct media_pad *remote, u32 flags)
+{
+	struct mtk_raw_pipeline *pipe =
+		container_of(entity, struct mtk_raw_pipeline, subdev.entity);
+	struct mtk_raw *raw = pipe->raw;
+	u32 pad = local->index;
+
+	dev_dbg(raw->cam_dev, "%s: raw %d: remote:%s:%d->local:%s:%d flags:0x%x\n",
+		__func__, pipe->id, remote->entity->name, remote->index,
+		local->entity->name, local->index, flags);
+
+	if (pad < MTK_RAW_PIPELINE_PADS_NUM && pad != MTK_RAW_SINK)
+		pipe->vdev_nodes[pad - MTK_RAW_SINK_NUM].enabled =
+			!!(flags & MEDIA_LNK_FL_ENABLED);
+
+	if (!media_entity_is_streaming(entity) && !(flags & MEDIA_LNK_FL_ENABLED))
+		memset(pipe->cfg, 0, sizeof(pipe->cfg));
+
+	if (pad == MTK_RAW_SINK && flags & MEDIA_LNK_FL_ENABLED)
+		pipe->res_config.seninf =
+			media_entity_to_v4l2_subdev(remote->entity);
+
+	return 0;
+}
+
+struct mtk_raw_pipeline*
+mtk_cam_get_link_enabled_raw(struct v4l2_subdev *seninf)
+{
+	struct mtk_cam_device *cam;
+	int i;
+
+	cam = container_of(seninf->v4l2_dev->mdev, struct mtk_cam_device, media_dev);
+
+	for (i = MTKCAM_SUBDEV_RAW_0; i <= MTKCAM_SUBDEV_RAW_END; i++) {
+		if (cam->raw.pipelines[i].res_config.seninf == seninf)
+			return &cam->raw.pipelines[i];
+	}
+
+	return NULL;
+}
+
+static int
+mtk_raw_s_frame_interval(struct v4l2_subdev *sd,
+			 struct v4l2_subdev_frame_interval *interval)
+{
+	struct mtk_raw_pipeline *pipe =
+		container_of(sd, struct mtk_raw_pipeline, subdev);
+	struct mtk_raw *raw = pipe->raw;
+
+	dev_dbg(raw->cam_dev, "%s:pipe(%d):current res: fps = %d/%d",
+		__func__, pipe->id,
+		interval->interval.numerator,
+		interval->interval.denominator);
+	pipe->res_config.interval = interval->interval;
+
+	return 0;
+}
+
+static const struct v4l2_subdev_core_ops mtk_raw_subdev_core_ops = {
+	.subscribe_event = mtk_raw_sd_subscribe_event,
+	.unsubscribe_event = v4l2_event_subdev_unsubscribe,
+};
+
+static const struct v4l2_subdev_video_ops mtk_raw_subdev_video_ops = {
+	.s_stream =  mtk_raw_sd_s_stream,
+	.s_frame_interval = mtk_raw_s_frame_interval,
+};
+
+static const struct v4l2_subdev_pad_ops mtk_raw_subdev_pad_ops = {
+	.link_validate = mtk_cam_link_validate,
+	.init_cfg = mtk_raw_init_cfg,
+	.set_fmt = mtk_raw_set_fmt,
+	.get_fmt = mtk_raw_get_fmt,
+	.set_selection = mtk_raw_set_pad_selection,
+	.get_selection = mtk_raw_get_pad_selection,
+};
+
+static const struct v4l2_subdev_ops mtk_raw_subdev_ops = {
+	.core = &mtk_raw_subdev_core_ops,
+	.video = &mtk_raw_subdev_video_ops,
+	.pad = &mtk_raw_subdev_pad_ops,
+};
+
+static const struct media_entity_operations mtk_cam_media_entity_ops = {
+	.link_setup = mtk_cam_media_link_setup,
+	.link_validate = v4l2_subdev_link_validate,
+};
+
+static const struct v4l2_ioctl_ops mtk_cam_v4l2_vout_ioctl_ops = {
+	.vidioc_querycap = mtk_cam_vidioc_querycap,
+	.vidioc_enum_framesizes = mtk_cam_vidioc_enum_framesizes,
+	.vidioc_enum_fmt_vid_cap = mtk_cam_vidioc_enum_fmt,
+	.vidioc_g_fmt_vid_out_mplane = mtk_cam_vidioc_g_fmt,
+	.vidioc_s_fmt_vid_out_mplane = mtk_cam_vidioc_s_fmt,
+	.vidioc_try_fmt_vid_out_mplane = mtk_cam_vidioc_try_fmt,
+	.vidioc_reqbufs = vb2_ioctl_reqbufs,
+	.vidioc_create_bufs = vb2_ioctl_create_bufs,
+	.vidioc_prepare_buf = vb2_ioctl_prepare_buf,
+	.vidioc_querybuf = vb2_ioctl_querybuf,
+	.vidioc_qbuf = vb2_ioctl_qbuf,
+	.vidioc_dqbuf = vb2_ioctl_dqbuf,
+	.vidioc_streamon = vb2_ioctl_streamon,
+	.vidioc_streamoff = vb2_ioctl_streamoff,
+	.vidioc_expbuf = vb2_ioctl_expbuf,
+	.vidioc_subscribe_event = v4l2_ctrl_subscribe_event,
+	.vidioc_unsubscribe_event = v4l2_event_unsubscribe,
+};
+
+static const struct v4l2_ioctl_ops mtk_cam_v4l2_vcap_ioctl_ops = {
+	.vidioc_querycap = mtk_cam_vidioc_querycap,
+	.vidioc_enum_framesizes = mtk_cam_vidioc_enum_framesizes,
+	.vidioc_enum_fmt_vid_cap = mtk_cam_vidioc_enum_fmt,
+	.vidioc_g_fmt_vid_cap_mplane = mtk_cam_vidioc_g_fmt,
+	.vidioc_s_fmt_vid_cap_mplane = mtk_cam_vidioc_s_fmt,
+	.vidioc_try_fmt_vid_cap_mplane = mtk_cam_vidioc_try_fmt,
+	.vidioc_s_selection = mtk_cam_vidioc_s_selection,
+	.vidioc_reqbufs = vb2_ioctl_reqbufs,
+	.vidioc_create_bufs = vb2_ioctl_create_bufs,
+	.vidioc_prepare_buf = vb2_ioctl_prepare_buf,
+	.vidioc_querybuf = vb2_ioctl_querybuf,
+	.vidioc_qbuf = vb2_ioctl_qbuf,
+	.vidioc_dqbuf = vb2_ioctl_dqbuf,
+	.vidioc_streamon = vb2_ioctl_streamon,
+	.vidioc_streamoff = vb2_ioctl_streamoff,
+	.vidioc_expbuf = vb2_ioctl_expbuf,
+	.vidioc_subscribe_event = v4l2_ctrl_subscribe_event,
+	.vidioc_unsubscribe_event = v4l2_event_unsubscribe,
+};
+
+static const struct v4l2_ioctl_ops mtk_cam_v4l2_meta_cap_ioctl_ops = {
+	.vidioc_querycap = mtk_cam_vidioc_querycap,
+	.vidioc_enum_fmt_meta_cap = mtk_cam_vidioc_meta_enum_fmt,
+	.vidioc_g_fmt_meta_cap = mtk_cam_vidioc_g_meta_fmt,
+	.vidioc_s_fmt_meta_cap = mtk_cam_vidioc_g_meta_fmt,
+	.vidioc_try_fmt_meta_cap = mtk_cam_vidioc_g_meta_fmt,
+	.vidioc_reqbufs = vb2_ioctl_reqbufs,
+	.vidioc_create_bufs = vb2_ioctl_create_bufs,
+	.vidioc_prepare_buf = vb2_ioctl_prepare_buf,
+	.vidioc_querybuf = vb2_ioctl_querybuf,
+	.vidioc_qbuf = vb2_ioctl_qbuf,
+	.vidioc_dqbuf = vb2_ioctl_dqbuf,
+	.vidioc_streamon = vb2_ioctl_streamon,
+	.vidioc_streamoff = vb2_ioctl_streamoff,
+	.vidioc_expbuf = vb2_ioctl_expbuf,
+};
+
+static const struct v4l2_ioctl_ops mtk_cam_v4l2_meta_out_ioctl_ops = {
+	.vidioc_querycap = mtk_cam_vidioc_querycap,
+	.vidioc_enum_fmt_meta_out = mtk_cam_vidioc_meta_enum_fmt,
+	.vidioc_g_fmt_meta_out = mtk_cam_vidioc_g_meta_fmt,
+	.vidioc_s_fmt_meta_out = mtk_cam_vidioc_g_meta_fmt,
+	.vidioc_try_fmt_meta_out = mtk_cam_vidioc_g_meta_fmt,
+	.vidioc_reqbufs = vb2_ioctl_reqbufs,
+	.vidioc_create_bufs = vb2_ioctl_create_bufs,
+	.vidioc_prepare_buf = vb2_ioctl_prepare_buf,
+	.vidioc_querybuf = vb2_ioctl_querybuf,
+	.vidioc_qbuf = vb2_ioctl_qbuf,
+	.vidioc_dqbuf = vb2_ioctl_dqbuf,
+	.vidioc_streamon = vb2_ioctl_streamon,
+	.vidioc_streamoff = vb2_ioctl_streamoff,
+	.vidioc_expbuf = vb2_ioctl_expbuf,
+};
+
+static const struct mtk_cam_format_desc  stream_out_fmts[] = {
+	/* This is a default image format */
+	{
+		.vfmt.fmt.pix_mp = {
+			.width = IMG_MAX_WIDTH,
+			.height = IMG_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_SBGGR8,
+			.num_planes = 1,
+		},
+		.pfmt = {
+			.code = MEDIA_BUS_FMT_SBGGR8_1X8,
+		}
+	},
+	{
+		.vfmt.fmt.pix_mp = {
+			.width = IMG_MAX_WIDTH,
+			.height = IMG_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_SBGGR10,
+			.num_planes = 1,
+		},
+		.pfmt = {
+			.code = MEDIA_BUS_FMT_SBGGR10_1X10,
+		}
+	},
+	{
+		.vfmt.fmt.pix_mp = {
+			.width = IMG_MAX_WIDTH,
+			.height = IMG_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_MTISP_SBGGR10,
+			.num_planes = 1,
+		},
+		.pfmt = {
+			.code = MEDIA_BUS_FMT_MTISP_SBGGR10_1X10,
+		}
+	},
+	{
+		.vfmt.fmt.pix_mp = {
+			.width = IMG_MAX_WIDTH,
+			.height = IMG_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_SBGGR10P,
+		},
+	},
+	{
+		.vfmt.fmt.pix_mp = {
+			.width = IMG_MAX_WIDTH,
+			.height = IMG_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_SBGGR12,
+			.num_planes = 1,
+		},
+		.pfmt = {
+			.code = MEDIA_BUS_FMT_SBGGR12_1X12,
+		}
+	},
+	{
+		.vfmt.fmt.pix_mp = {
+			.width = IMG_MAX_WIDTH,
+			.height = IMG_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_MTISP_SBGGR12,
+			.num_planes = 1,
+		},
+		.pfmt = {
+			.code = MEDIA_BUS_FMT_MTISP_SBGGR12_1X12,
+		}
+	},
+	{
+		.vfmt.fmt.pix_mp = {
+			.width = IMG_MAX_WIDTH,
+			.height = IMG_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_SBGGR14,
+			.num_planes = 1,
+		},
+		.pfmt = {
+			.code = MEDIA_BUS_FMT_SBGGR14_1X14,
+		}
+	},
+	{
+		.vfmt.fmt.pix_mp = {
+			.width = IMG_MAX_WIDTH,
+			.height = IMG_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_MTISP_SBGGR14,
+			.num_planes = 1,
+		},
+		.pfmt = {
+			.code = MEDIA_BUS_FMT_MTISP_SBGGR14_1X14,
+		}
+	},
+	{
+		.vfmt.fmt.pix_mp = {
+			.width = IMG_MAX_WIDTH,
+			.height = IMG_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_SGBRG8,
+			.num_planes = 1,
+		},
+		.pfmt = {
+			.code = MEDIA_BUS_FMT_SGBRG8_1X8,
+		}
+	},
+	{
+		.vfmt.fmt.pix_mp = {
+			.width = IMG_MAX_WIDTH,
+			.height = IMG_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_SGBRG10,
+			.num_planes = 1,
+		},
+		.pfmt = {
+			.code = MEDIA_BUS_FMT_SGBRG10_1X10,
+		}
+	},
+	{
+		.vfmt.fmt.pix_mp = {
+			.width = IMG_MAX_WIDTH,
+			.height = IMG_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_MTISP_SGBRG10,
+			.num_planes = 1,
+		},
+		.pfmt = {
+			.code = MEDIA_BUS_FMT_MTISP_SGBRG10_1X10,
+		}
+	},
+	{
+		.vfmt.fmt.pix_mp = {
+			.width = IMG_MAX_WIDTH,
+			.height = IMG_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_SGBRG10P,
+		},
+	},
+	{
+		.vfmt.fmt.pix_mp = {
+			.width = IMG_MAX_WIDTH,
+			.height = IMG_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_SGBRG12,
+			.num_planes = 1,
+		},
+		.pfmt = {
+			.code = MEDIA_BUS_FMT_SGBRG12_1X12,
+		}
+	},
+	{
+		.vfmt.fmt.pix_mp = {
+			.width = IMG_MAX_WIDTH,
+			.height = IMG_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_MTISP_SGBRG12,
+			.num_planes = 1,
+		},
+		.pfmt = {
+			.code = MEDIA_BUS_FMT_MTISP_SGBRG12_1X12,
+		}
+	},
+	{
+		.vfmt.fmt.pix_mp = {
+			.width = IMG_MAX_WIDTH,
+			.height = IMG_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_SGBRG14,
+			.num_planes = 1,
+		},
+		.pfmt = {
+			.code = MEDIA_BUS_FMT_SGBRG14_1X14,
+		}
+	},
+	{
+		.vfmt.fmt.pix_mp = {
+			.width = IMG_MAX_WIDTH,
+			.height = IMG_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_MTISP_SGBRG14,
+			.num_planes = 1,
+		},
+		.pfmt = {
+			.code = MEDIA_BUS_FMT_MTISP_SGBRG14_1X14,
+		}
+	},
+	{
+		.vfmt.fmt.pix_mp = {
+			.width = IMG_MAX_WIDTH,
+			.height = IMG_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_SGRBG8,
+			.num_planes = 1,
+		},
+		.pfmt = {
+			.code = MEDIA_BUS_FMT_SGRBG8_1X8,
+		}
+	},
+	{
+		.vfmt.fmt.pix_mp = {
+			.width = IMG_MAX_WIDTH,
+			.height = IMG_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_SGRBG10,
+			.num_planes = 1,
+		},
+		.pfmt = {
+			.code = MEDIA_BUS_FMT_SGRBG10_1X10,
+		}
+	},
+	{
+		.vfmt.fmt.pix_mp = {
+			.width = IMG_MAX_WIDTH,
+			.height = IMG_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_MTISP_SGRBG10,
+			.num_planes = 1,
+		},
+		.pfmt = {
+			.code = MEDIA_BUS_FMT_MTISP_SGRBG10_1X10,
+		}
+	},
+	{
+		.vfmt.fmt.pix_mp = {
+			.width = IMG_MAX_WIDTH,
+			.height = IMG_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_SGRBG10P,
+		},
+	},
+	{
+		.vfmt.fmt.pix_mp = {
+			.width = IMG_MAX_WIDTH,
+			.height = IMG_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_SGRBG12,
+			.num_planes = 1,
+		},
+		.pfmt = {
+			.code = MEDIA_BUS_FMT_SGRBG12_1X12,
+		}
+	},
+	{
+		.vfmt.fmt.pix_mp = {
+			.width = IMG_MAX_WIDTH,
+			.height = IMG_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_MTISP_SGRBG12,
+			.num_planes = 1,
+		},
+		.pfmt = {
+			.code = MEDIA_BUS_FMT_MTISP_SGRBG12_1X12,
+		}
+	},
+	{
+		.vfmt.fmt.pix_mp = {
+			.width = IMG_MAX_WIDTH,
+			.height = IMG_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_SGRBG14,
+			.num_planes = 1,
+		},
+		.pfmt = {
+			.code = MEDIA_BUS_FMT_SGRBG14_1X14,
+		}
+	},
+	{
+		.vfmt.fmt.pix_mp = {
+			.width = IMG_MAX_WIDTH,
+			.height = IMG_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_MTISP_SGRBG14,
+			.num_planes = 1,
+		},
+		.pfmt = {
+			.code = MEDIA_BUS_FMT_MTISP_SGRBG14_1X14,
+		}
+	},
+	{
+		.vfmt.fmt.pix_mp = {
+			.width = IMG_MAX_WIDTH,
+			.height = IMG_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_SRGGB8,
+			.num_planes = 1,
+		},
+		.pfmt = {
+			.code = MEDIA_BUS_FMT_SRGGB8_1X8,
+		}
+	},
+	{
+		.vfmt.fmt.pix_mp = {
+			.width = IMG_MAX_WIDTH,
+			.height = IMG_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_SRGGB10,
+			.num_planes = 1,
+		},
+		.pfmt = {
+			.code = MEDIA_BUS_FMT_SRGGB10_1X10,
+		}
+	},
+	{
+		.vfmt.fmt.pix_mp = {
+			.width = IMG_MAX_WIDTH,
+			.height = IMG_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_MTISP_SRGGB10,
+			.num_planes = 1,
+		},
+		.pfmt = {
+			.code = MEDIA_BUS_FMT_MTISP_SRGGB10_1X10,
+		}
+	},
+	{
+		.vfmt.fmt.pix_mp = {
+			.width = IMG_MAX_WIDTH,
+			.height = IMG_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_SRGGB10P,
+		},
+	},
+
+	{
+		.vfmt.fmt.pix_mp = {
+			.width = IMG_MAX_WIDTH,
+			.height = IMG_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_SRGGB12,
+			.num_planes = 1,
+		},
+		.pfmt = {
+			.code = MEDIA_BUS_FMT_SRGGB12_1X12,
+		}
+	},
+	{
+		.vfmt.fmt.pix_mp = {
+			.width = IMG_MAX_WIDTH,
+			.height = IMG_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_MTISP_SRGGB12,
+			.num_planes = 1,
+		},
+		.pfmt = {
+			.code = MEDIA_BUS_FMT_MTISP_SRGGB12_1X12,
+		}
+	},
+	{
+		.vfmt.fmt.pix_mp = {
+			.width = IMG_MAX_WIDTH,
+			.height = IMG_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_SRGGB14,
+			.num_planes = 1,
+		},
+		.pfmt = {
+			.code = MEDIA_BUS_FMT_SRGGB14_1X14,
+		}
+	},
+	{
+		.vfmt.fmt.pix_mp = {
+			.width = IMG_MAX_WIDTH,
+			.height = IMG_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_MTISP_SRGGB14,
+			.num_planes = 1,
+		},
+		.pfmt = {
+			.code = MEDIA_BUS_FMT_MTISP_SRGGB14_1X14,
+		}
+	},
+	{
+		.vfmt.fmt.pix_mp = {
+			.width = IMG_MAX_WIDTH,
+			.height = IMG_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_SBGGR16,
+			.num_planes = 1,
+		},
+		.pfmt = {
+			.code = MEDIA_BUS_FMT_SBGGR16_1X16,
+		}
+	},
+	{
+		.vfmt.fmt.pix_mp = {
+			.width = IMG_MAX_WIDTH,
+			.height = IMG_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_SGBRG16,
+			.num_planes = 1,
+		},
+		.pfmt = {
+			.code = MEDIA_BUS_FMT_SGBRG16_1X16,
+		}
+	},
+	{
+		.vfmt.fmt.pix_mp = {
+			.width = IMG_MAX_WIDTH,
+			.height = IMG_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_SGRBG16,
+			.num_planes = 1,
+		},
+		.pfmt = {
+			.code = MEDIA_BUS_FMT_SGRBG16_1X16,
+		}
+	},
+	{
+		.vfmt.fmt.pix_mp = {
+			.width = IMG_MAX_WIDTH,
+			.height = IMG_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_SRGGB16,
+			.num_planes = 1,
+		},
+		.pfmt = {
+			.code = MEDIA_BUS_FMT_SRGGB16_1X16,
+		}
+	},
+	{
+		.vfmt.fmt.pix_mp = {
+			.width = IMG_MAX_WIDTH,
+			.height = IMG_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_MTISP_BAYER8_UFBC,
+		},
+	},
+	{
+		.vfmt.fmt.pix_mp = {
+			.width = IMG_MAX_WIDTH,
+			.height = IMG_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_MTISP_BAYER10_UFBC,
+		},
+	},
+	{
+		.vfmt.fmt.pix_mp = {
+			.width = IMG_MAX_WIDTH,
+			.height = IMG_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_MTISP_BAYER12_UFBC,
+		},
+	},
+	{
+		.vfmt.fmt.pix_mp = {
+			.width = IMG_MAX_WIDTH,
+			.height = IMG_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_MTISP_BAYER14_UFBC,
+		},
+	},
+};
+
+static const struct mtk_cam_format_desc yuv_out_group1_fmts[] = {
+	{
+		.vfmt.fmt.pix_mp = {
+			.width = YUV_GROUP1_MAX_WIDTH,
+			.height = YUV_GROUP1_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_NV12,
+		},
+	},
+	{
+		.vfmt.fmt.pix_mp = {
+			.width = YUV_GROUP1_MAX_WIDTH,
+			.height = YUV_GROUP1_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_NV21,
+		},
+	},
+	{
+		.vfmt.fmt.pix_mp = {
+			.width = YUV_GROUP1_MAX_WIDTH,
+			.height = YUV_GROUP1_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_NV12_10,
+		},
+	},
+	{
+		.vfmt.fmt.pix_mp = {
+			.width = YUV_GROUP1_MAX_WIDTH,
+			.height = YUV_GROUP1_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_NV21_10,
+		},
+	},
+	{
+		.vfmt.fmt.pix_mp = {
+			.width = YUV_GROUP1_MAX_WIDTH,
+			.height = YUV_GROUP1_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_MTISP_NV12_10P,
+		},
+	},
+	{
+		.vfmt.fmt.pix_mp = {
+			.width = YUV_GROUP1_MAX_WIDTH,
+			.height = YUV_GROUP1_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_MTISP_NV21_10P,
+		},
+	},
+	{
+		.vfmt.fmt.pix_mp = {
+			.width = YUV_GROUP1_MAX_WIDTH,
+			.height = YUV_GROUP1_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_NV12_12,
+		},
+	},
+	{
+		.vfmt.fmt.pix_mp = {
+			.width = YUV_GROUP1_MAX_WIDTH,
+			.height = YUV_GROUP1_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_NV21_12,
+		},
+	},
+	{
+		.vfmt.fmt.pix_mp = {
+			.width = YUV_GROUP1_MAX_WIDTH,
+			.height = YUV_GROUP1_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_MTISP_NV12_12P,
+		},
+	},
+	{
+		.vfmt.fmt.pix_mp = {
+			.width = YUV_GROUP1_MAX_WIDTH,
+			.height = YUV_GROUP1_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_MTISP_NV21_12P,
+		},
+	},
+	{
+		.vfmt.fmt.pix_mp = {
+			.width = YUV_GROUP1_MAX_WIDTH,
+			.height = YUV_GROUP1_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_YUV420,
+		},
+	},
+	{
+		.vfmt.fmt.pix_mp = {
+			.width = YUV_GROUP1_MAX_WIDTH,
+			.height = YUV_GROUP1_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_MTISP_NV12_UFBC,
+		},
+	},
+	{
+		.vfmt.fmt.pix_mp = {
+			.width = YUV_GROUP1_MAX_WIDTH,
+			.height = YUV_GROUP1_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_MTISP_NV21_UFBC,
+		},
+	},
+	{
+		.vfmt.fmt.pix_mp = {
+			.width = YUV_GROUP1_MAX_WIDTH,
+			.height = YUV_GROUP1_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_MTISP_NV12_10_UFBC,
+		},
+	},
+	{
+		.vfmt.fmt.pix_mp = {
+			.width = YUV_GROUP1_MAX_WIDTH,
+			.height = YUV_GROUP1_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_MTISP_NV21_10_UFBC,
+		},
+	},
+	{
+		.vfmt.fmt.pix_mp = {
+			.width = YUV_GROUP1_MAX_WIDTH,
+			.height = YUV_GROUP1_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_MTISP_NV12_12_UFBC,
+		},
+	},
+	{
+		.vfmt.fmt.pix_mp = {
+			.width = YUV_GROUP1_MAX_WIDTH,
+			.height = YUV_GROUP1_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_MTISP_NV21_12_UFBC,
+		},
+	},
+	{
+		.vfmt.fmt.pix_mp = {
+			.width = YUV_GROUP1_MAX_WIDTH,
+			.height = YUV_GROUP1_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_MTISP_SGRB8F,
+		},
+	},
+	{
+		.vfmt.fmt.pix_mp = {
+			.width = YUV_GROUP1_MAX_WIDTH,
+			.height = YUV_GROUP1_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_MTISP_SGRB10F,
+		},
+	},
+	{
+		.vfmt.fmt.pix_mp = {
+			.width = YUV_GROUP1_MAX_WIDTH,
+			.height = YUV_GROUP1_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_MTISP_SGRB12F,
+		},
+	}
+};
+
+static const struct mtk_cam_format_desc yuv_out_group2_fmts[] = {
+	{
+		.vfmt.fmt.pix_mp = {
+			.width = YUV_GROUP2_MAX_WIDTH,
+			.height = YUV_GROUP2_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_NV12,
+		},
+	},
+	{
+		.vfmt.fmt.pix_mp = {
+			.width = YUV_GROUP2_MAX_WIDTH,
+			.height = YUV_GROUP2_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_NV21,
+		},
+	},
+	{
+		.vfmt.fmt.pix_mp = {
+			.width = YUV_GROUP2_MAX_WIDTH,
+			.height = YUV_GROUP2_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_NV12_10,
+		},
+	},
+	{
+		.vfmt.fmt.pix_mp = {
+			.width = YUV_GROUP2_MAX_WIDTH,
+			.height = YUV_GROUP2_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_NV21_10,
+		},
+	},
+	{
+		.vfmt.fmt.pix_mp = {
+			.width = YUV_GROUP2_MAX_WIDTH,
+			.height = YUV_GROUP2_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_MTISP_NV12_10P,
+		},
+	},
+	{
+		.vfmt.fmt.pix_mp = {
+			.width = YUV_GROUP2_MAX_WIDTH,
+			.height = YUV_GROUP2_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_MTISP_NV21_10P,
+		},
+	},
+	{
+		.vfmt.fmt.pix_mp = {
+			.width = YUV_GROUP2_MAX_WIDTH,
+			.height = YUV_GROUP2_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_NV12_12,
+		},
+	},
+	{
+		.vfmt.fmt.pix_mp = {
+			.width = YUV_GROUP2_MAX_WIDTH,
+			.height = YUV_GROUP2_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_NV21_12,
+		},
+	},
+	{
+		.vfmt.fmt.pix_mp = {
+			.width = YUV_GROUP2_MAX_WIDTH,
+			.height = YUV_GROUP2_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_MTISP_NV12_12P,
+		},
+	},
+	{
+		.vfmt.fmt.pix_mp = {
+			.width = YUV_GROUP2_MAX_WIDTH,
+			.height = YUV_GROUP2_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_MTISP_NV21_12P,
+		},
+	}
+};
+
+static const struct mtk_cam_format_desc rzh1n2to1_out_fmts[] = {
+	{
+		.vfmt.fmt.pix_mp = {
+			.width = RZH1N2TO1_MAX_WIDTH,
+			.height = RZH1N2TO1_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_NV12,
+		},
+	},
+	{
+		.vfmt.fmt.pix_mp = {
+			.width = RZH1N2TO1_MAX_WIDTH,
+			.height = RZH1N2TO1_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_NV21,
+		},
+	},
+	{
+		.vfmt.fmt.pix_mp = {
+			.width = RZH1N2TO1_MAX_WIDTH,
+			.height = RZH1N2TO1_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_NV16,
+		},
+	},
+	{
+		.vfmt.fmt.pix_mp = {
+			.width = RZH1N2TO1_MAX_WIDTH,
+			.height = RZH1N2TO1_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_NV61,
+		},
+	}
+};
+
+static const struct mtk_cam_format_desc rzh1n2to2_out_fmts[] = {
+	{
+		.vfmt.fmt.pix_mp = {
+			.width = RZH1N2TO2_MAX_WIDTH,
+			.height = RZH1N2TO2_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_YUYV,
+		},
+	},
+	{
+		.vfmt.fmt.pix_mp = {
+			.width = RZH1N2TO2_MAX_WIDTH,
+			.height = RZH1N2TO2_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_YVYU,
+		},
+	}
+};
+
+static const struct mtk_cam_format_desc rzh1n2to3_out_fmts[] = {
+	{
+		.vfmt.fmt.pix_mp = {
+			.width = RZH1N2TO3_MAX_WIDTH,
+			.height = RZH1N2TO3_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_NV12,
+		},
+	},
+	{
+		.vfmt.fmt.pix_mp = {
+			.width = RZH1N2TO3_MAX_WIDTH,
+			.height = RZH1N2TO3_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_NV21,
+		},
+	},
+	{
+		.vfmt.fmt.pix_mp = {
+			.width = RZH1N2TO3_MAX_WIDTH,
+			.height = RZH1N2TO3_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_NV16,
+		},
+	},
+	{
+		.vfmt.fmt.pix_mp = {
+			.width = RZH1N2TO3_MAX_WIDTH,
+			.height = RZH1N2TO3_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_NV61,
+		},
+	}
+};
+
+static const struct mtk_cam_format_desc drzs4no1_out_fmts[] = {
+	{
+		.vfmt.fmt.pix_mp = {
+			.width = DRZS4NO1_MAX_WIDTH,
+			.height = DRZS4NO1_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_GREY,
+		},
+	},
+	{
+		.vfmt.fmt.pix_mp = {
+			.width = DRZS4NO1_MAX_WIDTH,
+			.height = DRZS4NO1_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_NV16,
+		},
+	},
+	{
+		.vfmt.fmt.pix_mp = {
+			.width = DRZS4NO1_MAX_WIDTH,
+			.height = DRZS4NO1_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_NV61,
+		},
+	},
+	{
+		.vfmt.fmt.pix_mp = {
+			.width = DRZS4NO1_MAX_WIDTH,
+			.height = DRZS4NO1_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_NV16_10,
+		},
+	},
+	{
+		.vfmt.fmt.pix_mp = {
+			.width = DRZS4NO1_MAX_WIDTH,
+			.height = DRZS4NO1_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_NV61_10,
+		},
+	},
+	{
+		.vfmt.fmt.pix_mp = {
+			.width = DRZS4NO1_MAX_WIDTH,
+			.height = DRZS4NO1_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_MTISP_NV16_10P,
+		},
+	},
+	{
+		.vfmt.fmt.pix_mp = {
+			.width = DRZS4NO1_MAX_WIDTH,
+			.height = DRZS4NO1_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_MTISP_NV61_10P,
+		},
+	},
+	{
+		.vfmt.fmt.pix_mp = {
+			.width = DRZS4NO1_MAX_WIDTH,
+			.height = DRZS4NO1_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_NV12,
+		},
+	},
+	{
+		.vfmt.fmt.pix_mp = {
+			.width = DRZS4NO1_MAX_WIDTH,
+			.height = DRZS4NO1_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_NV21,
+		},
+	},
+	{
+		.vfmt.fmt.pix_mp = {
+			.width = DRZS4NO1_MAX_WIDTH,
+			.height = DRZS4NO1_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_NV12_10,
+		},
+	},
+	{
+		.vfmt.fmt.pix_mp = {
+			.width = DRZS4NO1_MAX_WIDTH,
+			.height = DRZS4NO1_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_NV21_10,
+		},
+	},
+	{
+		.vfmt.fmt.pix_mp = {
+			.width = DRZS4NO1_MAX_WIDTH,
+			.height = DRZS4NO1_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_MTISP_NV12_10P,
+		},
+	},
+	{
+		.vfmt.fmt.pix_mp = {
+			.width = DRZS4NO1_MAX_WIDTH,
+			.height = DRZS4NO1_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_MTISP_NV21_10P,
+		},
+	},
+};
+
+static const struct mtk_cam_format_desc drzs4no2_out_fmts[] = {
+	{
+		.vfmt.fmt.pix_mp = {
+			.width = DRZS4NO2_MAX_WIDTH,
+			.height = DRZS4NO2_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_GREY,
+		},
+	}
+};
+
+static const struct mtk_cam_format_desc drzs4no3_out_fmts[] = {
+	{
+		.vfmt.fmt.pix_mp = {
+			.width = DRZS4NO3_MAX_WIDTH,
+			.height = DRZS4NO3_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_GREY,
+		},
+	}
+};
+
+#define MTK_RAW_TOTAL_OUTPUT_QUEUES 4
+
+static const struct
+mtk_cam_dev_node_desc output_queues[] = {
+	{
+		.id = MTK_RAW_META_IN,
+		.name = "meta input",
+		.cap = V4L2_CAP_META_OUTPUT,
+		.buf_type = V4L2_BUF_TYPE_META_OUTPUT,
+		.link_flags = MEDIA_LNK_FL_ENABLED |  MEDIA_LNK_FL_IMMUTABLE,
+		.image = false,
+		.smem_alloc = true,
+		.need_cache_sync_on_prepare = true,
+		.dma_port = MTKCAM_IPI_RAW_META_STATS_CFG,
+		.default_fmt_idx = 0,
+		.max_buf_count = 16,
+		.ioctl_ops = &mtk_cam_v4l2_meta_out_ioctl_ops,
+	},
+	{
+		.id = MTK_RAW_RAWI_2_IN,
+		.name = "rawi 2",
+		.cap = V4L2_CAP_VIDEO_OUTPUT_MPLANE,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,
+		.link_flags = MEDIA_LNK_FL_ENABLED |  MEDIA_LNK_FL_IMMUTABLE,
+		.image = true,
+		.smem_alloc = false,
+		.dma_port = MTKCAM_IPI_RAW_RAWI_2,
+		.fmts = stream_out_fmts,
+		.num_fmts = ARRAY_SIZE(stream_out_fmts),
+		.default_fmt_idx = 0,
+		.ioctl_ops = &mtk_cam_v4l2_vout_ioctl_ops,
+		.frmsizes = &(struct v4l2_frmsizeenum) {
+			.index = 0,
+			.type = V4L2_FRMSIZE_TYPE_CONTINUOUS,
+			.stepwise = {
+				.max_width = IMG_MAX_WIDTH,
+				.min_width = IMG_MIN_WIDTH,
+				.max_height = IMG_MAX_HEIGHT,
+				.min_height = IMG_MIN_HEIGHT,
+				.step_height = 1,
+				.step_width = 1,
+			},
+		},
+	},
+	{
+		.id = MTK_RAW_RAWI_3_IN,
+		.name = "rawi 3",
+		.cap = V4L2_CAP_VIDEO_OUTPUT_MPLANE,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,
+		.link_flags = 0,
+		.image = true,
+		.smem_alloc = false,
+		.dma_port = MTKCAM_IPI_RAW_RAWI_3,
+		.fmts = stream_out_fmts,
+		.num_fmts = ARRAY_SIZE(stream_out_fmts),
+		.default_fmt_idx = 0,
+		.ioctl_ops = &mtk_cam_v4l2_vout_ioctl_ops,
+		.frmsizes = &(struct v4l2_frmsizeenum) {
+			.index = 0,
+			.type = V4L2_FRMSIZE_TYPE_CONTINUOUS,
+			.stepwise = {
+				.max_width = IMG_MAX_WIDTH,
+				.min_width = IMG_MIN_WIDTH,
+				.max_height = IMG_MAX_HEIGHT,
+				.min_height = IMG_MIN_HEIGHT,
+				.step_height = 1,
+				.step_width = 1,
+			},
+		},
+	},
+	{
+		.id = MTK_RAW_RAWI_4_IN,
+		.name = "rawi 4",
+		.cap = V4L2_CAP_VIDEO_OUTPUT_MPLANE,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,
+		.link_flags = 0,
+		.image = true,
+		.smem_alloc = false,
+		.dma_port = MTKCAM_IPI_RAW_RAWI_3, //todo: wait backend add MTKCAM_IPI_RAW_RAWI_4
+		.fmts = stream_out_fmts,
+		.num_fmts = ARRAY_SIZE(stream_out_fmts),
+		.default_fmt_idx = 0,
+		.ioctl_ops = &mtk_cam_v4l2_vout_ioctl_ops,
+		.frmsizes = &(struct v4l2_frmsizeenum) {
+			.index = 0,
+			.type = V4L2_FRMSIZE_TYPE_CONTINUOUS,
+			.stepwise = {
+				.max_width = IMG_MAX_WIDTH,
+				.min_width = IMG_MIN_WIDTH,
+				.max_height = IMG_MAX_HEIGHT,
+				.min_height = IMG_MIN_HEIGHT,
+				.step_height = 1,
+				.step_width = 1,
+			},
+		},
+	}
+};
+
+static const char *output_queue_names[RAW_PIPELINE_NUM][MTK_RAW_TOTAL_OUTPUT_QUEUES] = {
+	{"mtk-cam raw-0 meta-input", "mtk-cam raw-0 rawi-2",
+	 "mtk-cam raw-0 rawi-3", "mtk-cam raw-0 rawi-4"},
+	{"mtk-cam raw-1 meta-input", "mtk-cam raw-1 rawi-2",
+	 "mtk-cam raw-1 rawi-3", "mtk-cam raw-1 rawi-4"},
+#ifdef ISP7_1
+	{"mtk-cam raw-2 meta-input", "mtk-cam raw-2 rawi-2",
+	 "mtk-cam raw-2 rawi-3", "mtk-cam raw-2 rawi-4"},
+#endif
+};
+
+struct mtk_cam_pad_ops source_pad_ops_default = {
+	.set_pad_fmt = mtk_raw_set_src_pad_fmt_default,
+	.set_pad_selection = mtk_raw_set_src_pad_selection_default,
+};
+
+struct mtk_cam_pad_ops source_pad_ops_yuv = {
+	.set_pad_fmt = mtk_raw_set_src_pad_fmt_default,
+	.set_pad_selection = mtk_raw_set_src_pad_selection_yuv,
+};
+
+struct mtk_cam_pad_ops source_pad_ops_drzs4no = {
+	.set_pad_fmt = mtk_raw_set_src_pad_fmt_default,
+	.set_pad_selection = mtk_raw_set_src_pad_selection_default,
+};
+
+struct mtk_cam_pad_ops source_pad_ops_rzh1n2 = {
+	.set_pad_fmt = mtk_raw_set_src_pad_fmt_rzh1n2,
+	.set_pad_selection = mtk_raw_set_src_pad_selection_default,
+};
+
+#define MTK_RAW_TOTAL_CAPTURE_QUEUES 20
+static const struct
+mtk_cam_dev_node_desc capture_queues[] = {
+	{
+		.id = MTK_RAW_MAIN_STREAM_OUT,
+		.name = "imgo",
+		.cap = V4L2_CAP_VIDEO_CAPTURE_MPLANE,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE,
+		.link_flags = MEDIA_LNK_FL_ENABLED |  MEDIA_LNK_FL_IMMUTABLE,
+		.image = true,
+		.smem_alloc = false,
+		.dma_port = MTKCAM_IPI_RAW_IMGO,
+		.fmts = stream_out_fmts,
+		.num_fmts = ARRAY_SIZE(stream_out_fmts),
+		.default_fmt_idx = 0,
+		.pad_ops = &source_pad_ops_default,
+		.ioctl_ops = &mtk_cam_v4l2_vcap_ioctl_ops,
+		.frmsizes = &(struct v4l2_frmsizeenum) {
+			.index = 0,
+			.type = V4L2_FRMSIZE_TYPE_CONTINUOUS,
+			.stepwise = {
+				.max_width = IMG_MAX_WIDTH,
+				.min_width = IMG_MIN_WIDTH,
+				.max_height = IMG_MAX_HEIGHT,
+				.min_height = IMG_MIN_HEIGHT,
+				.step_height = 1,
+				.step_width = 1,
+			},
+		},
+	},
+	{
+		.id = MTK_RAW_YUVO_1_OUT,
+		.name = "yuvo 1",
+		.cap = V4L2_CAP_VIDEO_CAPTURE_MPLANE,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE,
+		.link_flags = MEDIA_LNK_FL_ENABLED |  MEDIA_LNK_FL_IMMUTABLE,
+		.image = true,
+		.smem_alloc = false,
+		.dma_port = MTKCAM_IPI_RAW_YUVO_1,
+		.fmts = yuv_out_group1_fmts,
+		.num_fmts = ARRAY_SIZE(yuv_out_group1_fmts),
+		.default_fmt_idx = 0,
+		.pad_ops = &source_pad_ops_yuv,
+		.ioctl_ops = &mtk_cam_v4l2_vcap_ioctl_ops,
+		.frmsizes = &(struct v4l2_frmsizeenum) {
+			.index = 0,
+			.type = V4L2_FRMSIZE_TYPE_CONTINUOUS,
+			.stepwise = {
+				.max_width = YUV_GROUP1_MAX_WIDTH,
+				.min_width = IMG_MIN_WIDTH,
+				.max_height = YUV_GROUP1_MAX_HEIGHT,
+				.min_height = IMG_MIN_HEIGHT,
+				.step_height = 1,
+				.step_width = 1,
+			},
+		},
+	},
+	{
+		.id = MTK_RAW_YUVO_2_OUT,
+		.name = "yuvo 2",
+		.cap = V4L2_CAP_VIDEO_CAPTURE_MPLANE,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE,
+		.link_flags = MEDIA_LNK_FL_ENABLED |  MEDIA_LNK_FL_IMMUTABLE,
+		.image = true,
+		.smem_alloc = false,
+		.dma_port = MTKCAM_IPI_RAW_YUVO_2,
+		.fmts = yuv_out_group2_fmts,
+		.num_fmts = ARRAY_SIZE(yuv_out_group2_fmts),
+		.default_fmt_idx = 0,
+		.pad_ops = &source_pad_ops_yuv,
+		.ioctl_ops = &mtk_cam_v4l2_vcap_ioctl_ops,
+		.frmsizes = &(struct v4l2_frmsizeenum) {
+			.index = 0,
+			.type = V4L2_FRMSIZE_TYPE_CONTINUOUS,
+			.stepwise = {
+				.max_width = YUV_GROUP2_MAX_WIDTH,
+				.min_width = IMG_MIN_WIDTH,
+				.max_height = YUV_GROUP2_MAX_HEIGHT,
+				.min_height = IMG_MIN_HEIGHT,
+				.step_height = 1,
+				.step_width = 1,
+			},
+		},
+	},
+	{
+		.id = MTK_RAW_YUVO_3_OUT,
+		.name = "yuvo 3",
+		.cap = V4L2_CAP_VIDEO_CAPTURE_MPLANE,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE,
+		.link_flags = MEDIA_LNK_FL_ENABLED |  MEDIA_LNK_FL_IMMUTABLE,
+		.image = true,
+		.smem_alloc = false,
+		.dma_port = MTKCAM_IPI_RAW_YUVO_3,
+		.fmts = yuv_out_group1_fmts,
+		.num_fmts = ARRAY_SIZE(yuv_out_group1_fmts),
+		.default_fmt_idx = 0,
+		.pad_ops = &source_pad_ops_yuv,
+		.ioctl_ops = &mtk_cam_v4l2_vcap_ioctl_ops,
+		.frmsizes = &(struct v4l2_frmsizeenum) {
+			.index = 0,
+			.type = V4L2_FRMSIZE_TYPE_CONTINUOUS,
+			.stepwise = {
+				.max_width = YUV_GROUP1_MAX_WIDTH,
+				.min_width = IMG_MIN_WIDTH,
+				.max_height = YUV_GROUP1_MAX_HEIGHT,
+				.min_height = IMG_MIN_HEIGHT,
+				.step_height = 1,
+				.step_width = 1,
+			},
+		},
+	},
+	{
+		.id = MTK_RAW_YUVO_4_OUT,
+		.name = "yuvo 4",
+		.cap = V4L2_CAP_VIDEO_CAPTURE_MPLANE,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE,
+		.link_flags = MEDIA_LNK_FL_ENABLED |  MEDIA_LNK_FL_IMMUTABLE,
+		.image = true,
+		.smem_alloc = false,
+		.dma_port = MTKCAM_IPI_RAW_YUVO_4,
+		.fmts = yuv_out_group2_fmts,
+		.num_fmts = ARRAY_SIZE(yuv_out_group2_fmts),
+		.default_fmt_idx = 0,
+		.pad_ops = &source_pad_ops_yuv,
+		.ioctl_ops = &mtk_cam_v4l2_vcap_ioctl_ops,
+		.frmsizes = &(struct v4l2_frmsizeenum) {
+			.index = 0,
+			.type = V4L2_FRMSIZE_TYPE_CONTINUOUS,
+			.stepwise = {
+				.max_width = YUV_GROUP2_MAX_WIDTH,
+				.min_width = IMG_MIN_WIDTH,
+				.max_height = YUV_GROUP2_MAX_HEIGHT,
+				.min_height = IMG_MIN_HEIGHT,
+				.step_height = 1,
+				.step_width = 1,
+			},
+		},
+	},
+	{
+		.id = MTK_RAW_YUVO_5_OUT,
+		.name = "yuvo 5",
+		.cap = V4L2_CAP_VIDEO_CAPTURE_MPLANE,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE,
+		.link_flags = MEDIA_LNK_FL_ENABLED |  MEDIA_LNK_FL_IMMUTABLE,
+		.image = true,
+		.smem_alloc = false,
+		.dma_port = MTKCAM_IPI_RAW_YUVO_5,
+		.fmts = yuv_out_group2_fmts,
+		.num_fmts = ARRAY_SIZE(yuv_out_group2_fmts),
+		.default_fmt_idx = 0,
+		.pad_ops = &source_pad_ops_yuv,
+		.ioctl_ops = &mtk_cam_v4l2_vcap_ioctl_ops,
+		.frmsizes = &(struct v4l2_frmsizeenum) {
+			.index = 0,
+			.type = V4L2_FRMSIZE_TYPE_CONTINUOUS,
+			.stepwise = {
+				.max_width = YUV_GROUP2_MAX_WIDTH,
+				.min_width = IMG_MIN_WIDTH,
+				.max_height = YUV_GROUP2_MAX_HEIGHT,
+				.min_height = IMG_MIN_HEIGHT,
+				.step_height = 1,
+				.step_width = 1,
+			},
+		},
+	},
+	{
+		.id = MTK_RAW_DRZS4NO_1_OUT,
+		.name = "drzs4no 1",
+		.cap = V4L2_CAP_VIDEO_CAPTURE_MPLANE,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE,
+		.link_flags = MEDIA_LNK_FL_ENABLED |  MEDIA_LNK_FL_IMMUTABLE,
+		.image = true,
+		.smem_alloc = false,
+		.dma_port = MTKCAM_IPI_RAW_DRZS4NO_1,
+		.fmts = drzs4no1_out_fmts,
+		.num_fmts = ARRAY_SIZE(drzs4no1_out_fmts),
+		.default_fmt_idx = 0,
+		.pad_ops = &source_pad_ops_drzs4no,
+		.ioctl_ops = &mtk_cam_v4l2_vcap_ioctl_ops,
+		.frmsizes = &(struct v4l2_frmsizeenum) {
+			.index = 0,
+			.type = V4L2_FRMSIZE_TYPE_CONTINUOUS,
+			.stepwise = {
+				.max_width = DRZS4NO1_MAX_WIDTH,
+				.min_width = IMG_MIN_WIDTH,
+				.max_height = DRZS4NO1_MAX_HEIGHT,
+				.min_height = IMG_MIN_HEIGHT,
+				.step_height = 1,
+				.step_width = 1,
+			},
+		},
+	},
+	{
+		.id = MTK_RAW_DRZS4NO_2_OUT,
+		.name = "drzs4no 2",
+		.cap = V4L2_CAP_VIDEO_CAPTURE_MPLANE,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE,
+		.link_flags = MEDIA_LNK_FL_ENABLED |  MEDIA_LNK_FL_IMMUTABLE,
+		.image = true,
+		.smem_alloc = false,
+		.dma_port = MTKCAM_IPI_RAW_DRZS4NO_2,
+		.fmts = drzs4no2_out_fmts,
+		.num_fmts = ARRAY_SIZE(drzs4no2_out_fmts),
+		.default_fmt_idx = 0,
+		.pad_ops = &source_pad_ops_drzs4no,
+		.ioctl_ops = &mtk_cam_v4l2_vcap_ioctl_ops,
+		.frmsizes = &(struct v4l2_frmsizeenum) {
+			.index = 0,
+			.type = V4L2_FRMSIZE_TYPE_CONTINUOUS,
+			.stepwise = {
+				.max_width = DRZS4NO2_MAX_WIDTH,
+				.min_width = IMG_MIN_WIDTH,
+				.max_height = DRZS4NO2_MAX_HEIGHT,
+				.min_height = IMG_MIN_HEIGHT,
+				.step_height = 1,
+				.step_width = 1,
+			},
+		},
+	},
+	{
+		.id = MTK_RAW_DRZS4NO_3_OUT,
+		.name = "drzs4no 3",
+		.cap = V4L2_CAP_VIDEO_CAPTURE_MPLANE,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE,
+		.link_flags = MEDIA_LNK_FL_ENABLED |  MEDIA_LNK_FL_IMMUTABLE,
+		.image = true,
+		.smem_alloc = false,
+		.dma_port = MTKCAM_IPI_RAW_DRZS4NO_3,
+		.fmts = drzs4no3_out_fmts,
+		.num_fmts = ARRAY_SIZE(drzs4no3_out_fmts),
+		.default_fmt_idx = 0,
+		.pad_ops = &source_pad_ops_drzs4no,
+		.ioctl_ops = &mtk_cam_v4l2_vcap_ioctl_ops,
+		.frmsizes = &(struct v4l2_frmsizeenum) {
+			.index = 0,
+			.type = V4L2_FRMSIZE_TYPE_CONTINUOUS,
+			.stepwise = {
+				.max_width = DRZS4NO3_MAX_WIDTH,
+				.min_width = IMG_MIN_WIDTH,
+				.max_height = DRZS4NO3_MAX_HEIGHT,
+				.min_height = IMG_MIN_HEIGHT,
+				.step_height = 1,
+				.step_width = 1,
+			},
+		},
+	},
+	{
+		.id = MTK_RAW_RZH1N2TO_1_OUT,
+		.name = "rzh1n2to 1",
+		.cap = V4L2_CAP_VIDEO_CAPTURE_MPLANE,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE,
+		.link_flags = MEDIA_LNK_FL_ENABLED |  MEDIA_LNK_FL_IMMUTABLE,
+		.image = true,
+		.smem_alloc = false,
+		.dma_port = MTKCAM_IPI_RAW_RZH1N2TO_1,
+		.fmts = rzh1n2to1_out_fmts,
+		.num_fmts = ARRAY_SIZE(rzh1n2to1_out_fmts),
+		.default_fmt_idx = 0,
+		.pad_ops = &source_pad_ops_rzh1n2,
+		.ioctl_ops = &mtk_cam_v4l2_vcap_ioctl_ops,
+		.frmsizes = &(struct v4l2_frmsizeenum) {
+			.index = 0,
+			.type = V4L2_FRMSIZE_TYPE_CONTINUOUS,
+			.stepwise = {
+				.max_width = RZH1N2TO1_MAX_WIDTH,
+				.min_width = IMG_MIN_WIDTH,
+				.max_height = RZH1N2TO1_MAX_HEIGHT,
+				.min_height = IMG_MIN_HEIGHT,
+				.step_height = 1,
+				.step_width = 1,
+			},
+		},
+	},
+	{
+		.id = MTK_RAW_RZH1N2TO_2_OUT,
+		.name = "rzh1n2to 2",
+		.cap = V4L2_CAP_VIDEO_CAPTURE_MPLANE,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE,
+		.link_flags = MEDIA_LNK_FL_ENABLED |  MEDIA_LNK_FL_IMMUTABLE,
+		.image = true,
+		.smem_alloc = false,
+		.dma_port = MTKCAM_IPI_RAW_RZH1N2TO_2,
+		.fmts = rzh1n2to2_out_fmts,
+		.num_fmts = ARRAY_SIZE(rzh1n2to2_out_fmts),
+		.default_fmt_idx = 0,
+		.pad_ops = &source_pad_ops_rzh1n2,
+		.ioctl_ops = &mtk_cam_v4l2_vcap_ioctl_ops,
+		.frmsizes = &(struct v4l2_frmsizeenum) {
+			.index = 0,
+			.type = V4L2_FRMSIZE_TYPE_CONTINUOUS,
+			.stepwise = {
+				.max_width = RZH1N2TO2_MAX_WIDTH,
+				.min_width = IMG_MIN_WIDTH,
+				.max_height = RZH1N2TO2_MAX_HEIGHT,
+				.min_height = IMG_MIN_HEIGHT,
+				.step_height = 1,
+				.step_width = 1,
+			},
+		},
+	},
+	{
+		.id = MTK_RAW_RZH1N2TO_3_OUT,
+		.name = "rzh1n2to 3",
+		.cap = V4L2_CAP_VIDEO_CAPTURE_MPLANE,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE,
+		.link_flags = MEDIA_LNK_FL_ENABLED |  MEDIA_LNK_FL_IMMUTABLE,
+		.image = true,
+		.smem_alloc = false,
+		.dma_port = MTKCAM_IPI_RAW_RZH1N2TO_3,
+		.fmts = rzh1n2to3_out_fmts,
+		.num_fmts = ARRAY_SIZE(rzh1n2to3_out_fmts),
+		.default_fmt_idx = 0,
+		.pad_ops = &source_pad_ops_rzh1n2,
+		.ioctl_ops = &mtk_cam_v4l2_vcap_ioctl_ops,
+		.frmsizes = &(struct v4l2_frmsizeenum) {
+			.index = 0,
+			.type = V4L2_FRMSIZE_TYPE_CONTINUOUS,
+			.stepwise = {
+				.max_width = RZH1N2TO3_MAX_WIDTH,
+				.min_width = IMG_MIN_WIDTH,
+				.max_height = RZH1N2TO3_MAX_HEIGHT,
+				.min_height = IMG_MIN_HEIGHT,
+				.step_height = 1,
+				.step_width = 1,
+			},
+		},
+	},
+	{
+		.id = MTK_RAW_MAIN_STREAM_SV_1_OUT,
+		.name = "sv imgo 1",
+		.cap = V4L2_CAP_VIDEO_CAPTURE_MPLANE,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE,
+		.link_flags = MEDIA_LNK_FL_ENABLED |  MEDIA_LNK_FL_IMMUTABLE,
+		.image = true,
+		.smem_alloc = false,
+		.dma_port = MTKCAM_IPI_CAMSV_MAIN_OUT,
+		.fmts = stream_out_fmts,
+		.num_fmts = ARRAY_SIZE(stream_out_fmts),
+		.default_fmt_idx = 0,
+		.pad_ops = &source_pad_ops_default,
+		.ioctl_ops = &mtk_cam_v4l2_vcap_ioctl_ops,
+		.frmsizes = &(struct v4l2_frmsizeenum) {
+			.index = 0,
+			.type = V4L2_FRMSIZE_TYPE_CONTINUOUS,
+			.stepwise = {
+				.max_width = IMG_MAX_WIDTH,
+				.min_width = IMG_MIN_WIDTH,
+				.max_height = IMG_MAX_HEIGHT,
+				.min_height = IMG_MIN_HEIGHT,
+				.step_height = 1,
+				.step_width = 1,
+			},
+		},
+	},
+	{
+		.id = MTK_RAW_MAIN_STREAM_SV_2_OUT,
+		.name = "sv imgo 2",
+		.cap = V4L2_CAP_VIDEO_CAPTURE_MPLANE,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE,
+		.link_flags = MEDIA_LNK_FL_ENABLED |  MEDIA_LNK_FL_IMMUTABLE,
+		.image = true,
+		.smem_alloc = false,
+		.dma_port = MTKCAM_IPI_CAMSV_MAIN_OUT,
+		.fmts = stream_out_fmts,
+		.num_fmts = ARRAY_SIZE(stream_out_fmts),
+		.default_fmt_idx = 0,
+		.pad_ops = &source_pad_ops_default,
+		.ioctl_ops = &mtk_cam_v4l2_vcap_ioctl_ops,
+		.frmsizes = &(struct v4l2_frmsizeenum) {
+			.index = 0,
+			.type = V4L2_FRMSIZE_TYPE_CONTINUOUS,
+			.stepwise = {
+				.max_width = IMG_MAX_WIDTH,
+				.min_width = IMG_MIN_WIDTH,
+				.max_height = IMG_MAX_HEIGHT,
+				.min_height = IMG_MIN_HEIGHT,
+				.step_height = 1,
+				.step_width = 1,
+			},
+		},
+	},
+	{
+		.id = MTK_RAW_META_OUT_0,
+		.name = "partial meta 0",
+		.cap = V4L2_CAP_META_CAPTURE,
+		.buf_type = V4L2_BUF_TYPE_META_CAPTURE,
+		.link_flags = MEDIA_LNK_FL_ENABLED |  MEDIA_LNK_FL_IMMUTABLE,
+		.image = false,
+		.smem_alloc = true,
+		.dma_port = MTKCAM_IPI_RAW_META_STATS_0,
+		.default_fmt_idx = 1,
+		.max_buf_count = 16,
+		.ioctl_ops = &mtk_cam_v4l2_meta_cap_ioctl_ops,
+	},
+	{
+		.id = MTK_RAW_META_OUT_1,
+		.name = "partial meta 1",
+		.cap = V4L2_CAP_META_CAPTURE,
+		.buf_type = V4L2_BUF_TYPE_META_CAPTURE,
+		.link_flags = MEDIA_LNK_FL_ENABLED |  MEDIA_LNK_FL_IMMUTABLE,
+		.image = false,
+		.smem_alloc = true,
+		.need_cache_sync_on_finish = true,
+		.dma_port = MTKCAM_IPI_RAW_META_STATS_1,
+		.default_fmt_idx = 2,
+		.max_buf_count = 16,
+		.ioctl_ops = &mtk_cam_v4l2_meta_cap_ioctl_ops,
+	},
+	{
+		.id = MTK_RAW_META_OUT_2,
+		.name = "partial meta 2",
+		.cap = V4L2_CAP_META_CAPTURE,
+		.buf_type = V4L2_BUF_TYPE_META_CAPTURE,
+		.link_flags = MEDIA_LNK_FL_ENABLED |  MEDIA_LNK_FL_IMMUTABLE,
+		.image = false,
+		.smem_alloc = false,
+		.need_cache_sync_on_finish = true,
+		.dma_port = MTKCAM_IPI_RAW_META_STATS_2,
+		.default_fmt_idx = 3,
+		.max_buf_count = 16,
+		.ioctl_ops = &mtk_cam_v4l2_meta_cap_ioctl_ops,
+	},
+	{
+		.id = MTK_RAW_META_SV_OUT_0,
+		.name = "external meta 0",
+		.cap = V4L2_CAP_META_CAPTURE,
+		.buf_type = V4L2_BUF_TYPE_META_CAPTURE,
+		.link_flags = MEDIA_LNK_FL_ENABLED |  MEDIA_LNK_FL_IMMUTABLE,
+		.image = false,
+		.smem_alloc = false,
+		.dma_port = MTKCAM_IPI_CAMSV_MAIN_OUT,
+		.fmts = stream_out_fmts,
+		.default_fmt_idx = 0,
+		.max_buf_count = 16,
+		.ioctl_ops = &mtk_cam_v4l2_meta_cap_ioctl_ops,
+	},
+	{
+		.id = MTK_RAW_META_SV_OUT_1,
+		.name = "external meta 1",
+		.cap = V4L2_CAP_META_CAPTURE,
+		.buf_type = V4L2_BUF_TYPE_META_CAPTURE,
+		.link_flags = MEDIA_LNK_FL_ENABLED |  MEDIA_LNK_FL_IMMUTABLE,
+		.image = false,
+		.smem_alloc = false,
+		.dma_port = MTKCAM_IPI_CAMSV_MAIN_OUT,
+		.fmts = stream_out_fmts,
+		.default_fmt_idx = 0,
+		.max_buf_count = 16,
+		.ioctl_ops = &mtk_cam_v4l2_meta_cap_ioctl_ops,
+	},
+	{
+		.id = MTK_RAW_META_SV_OUT_2,
+		.name = "external meta 2",
+		.cap = V4L2_CAP_META_CAPTURE,
+		.buf_type = V4L2_BUF_TYPE_META_CAPTURE,
+		.link_flags = MEDIA_LNK_FL_ENABLED |  MEDIA_LNK_FL_IMMUTABLE,
+		.image = false,
+		.smem_alloc = false,
+		.dma_port = MTKCAM_IPI_CAMSV_MAIN_OUT,
+		.fmts = stream_out_fmts,
+		.default_fmt_idx = 0,
+		.max_buf_count = 16,
+		.ioctl_ops = &mtk_cam_v4l2_meta_cap_ioctl_ops,
+	},
+};
+
+static const char *capture_queue_names[RAW_PIPELINE_NUM][MTK_RAW_TOTAL_CAPTURE_QUEUES] = {
+	{"mtk-cam raw-0 main-stream",
+	 "mtk-cam raw-0 yuvo-1", "mtk-cam raw-0 yuvo-2",
+	 "mtk-cam raw-0 yuvo-3", "mtk-cam raw-0 yuvo-4",
+	 "mtk-cam raw-0 yuvo-5",
+	 "mtk-cam raw-0 drzs4no-1", "mtk-cam raw-0 drzs4no-2", "mtk-cam raw-0 drzs4no-3",
+	 "mtk-cam raw-0 rzh1n2to-1", "mtk-cam raw-0 rzh1n2to-2", "mtk-cam raw-0 rzh1n2to-3",
+	 "mtk-cam raw-0 sv-imgo-1", "mtk-cam raw-0 sv-imgo-2",
+	 "mtk-cam raw-0 partial-meta-0", "mtk-cam raw-0 partial-meta-1",
+	 "mtk-cam raw-0 partial-meta-2",
+	 "mtk-cam raw-0 ext-meta-0", "mtk-cam raw-0 ext-meta-1",
+	 "mtk-cam raw-0 ext-meta-2"},
+
+	{"mtk-cam raw-1 main-stream",
+	 "mtk-cam raw-1 yuvo-1", "mtk-cam raw-1 yuvo-2",
+	 "mtk-cam raw-1 yuvo-3", "mtk-cam raw-1 yuvo-4",
+	 "mtk-cam raw-1 yuvo-5",
+	 "mtk-cam raw-1 drzs4no-1", "mtk-cam raw-1 drzs4no-2", "mtk-cam raw-1 drzs4no-3",
+	 "mtk-cam raw-1 rzh1n2to-1", "mtk-cam raw-1 rzh1n2to-2", "mtk-cam raw-1 rzh1n2to-3",
+	 "mtk-cam raw-1 sv-imgo-1", "mtk-cam raw-1 sv-imgo-2",
+	 "mtk-cam raw-1 partial-meta-0", "mtk-cam raw-1 partial-meta-1",
+	 "mtk-cam raw-1 partial-meta-2",
+	 "mtk-cam raw-1 ext-meta-0", "mtk-cam raw-1 ext-meta-1",
+	 "mtk-cam raw-1 ext-meta-2"},
+
+#ifdef ISP7_1
+	{"mtk-cam raw-2 main-stream",
+	 "mtk-cam raw-2 yuvo-1", "mtk-cam raw-2 yuvo-2",
+	 "mtk-cam raw-2 yuvo-3", "mtk-cam raw-2 yuvo-4",
+	 "mtk-cam raw-2 yuvo-5",
+	 "mtk-cam raw-2 drzs4no-1", "mtk-cam raw-2 drzs4no-2", "mtk-cam raw-2 drzs4no-3",
+	 "mtk-cam raw-2 rzh1n2to-1", "mtk-cam raw-2 rzh1n2to-2", "mtk-cam raw-2 rzh1n2to-3",
+	 "mtk-cam raw-2 sv-imgo-1", "mtk-cam raw-2 sv-imgo-2",
+	 "mtk-cam raw-2 partial-meta-0", "mtk-cam raw-2 partial-meta-1",
+	 "mtk-cam raw-2 partial-meta-2",
+	 "mtk-cam raw-2 ext-meta-0", "mtk-cam raw-2 ext-meta-1",
+	 "mtk-cam raw-2 ext-meta-2"},
+#endif
+};
+
+/* The helper to configure the device context */
+static void mtk_raw_pipeline_queue_setup(struct mtk_raw_pipeline *pipe)
+{
+	unsigned int node_idx, i;
+
+	if (WARN_ON(MTK_RAW_TOTAL_OUTPUT_QUEUES + MTK_RAW_TOTAL_CAPTURE_QUEUES
+	    != MTK_RAW_TOTAL_NODES))
+		return;
+
+	node_idx = 0;
+	/* Setup the output queue */
+	for (i = 0; i < MTK_RAW_TOTAL_OUTPUT_QUEUES; i++) {
+		pipe->vdev_nodes[node_idx].desc = output_queues[i];
+		if (pipe->vdev_nodes[node_idx].desc.id == MTK_RAW_META_IN)
+			pipe->vdev_nodes[node_idx].desc.fmts = mtk_cam_get_meta_fmts();
+		pipe->vdev_nodes[node_idx++].desc.name =
+			output_queue_names[pipe->id][i];
+	}
+
+	/* Setup the capture queue */
+	for (i = 0; i < MTK_RAW_TOTAL_CAPTURE_QUEUES; i++) {
+		pipe->vdev_nodes[node_idx].desc = capture_queues[i];
+		if (pipe->vdev_nodes[node_idx].desc.id >= MTK_RAW_META_OUT_BEGIN &&
+			pipe->vdev_nodes[node_idx].desc.id <= MTK_RAW_META_OUT_2)
+			pipe->vdev_nodes[node_idx].desc.fmts = mtk_cam_get_meta_fmts();
+		pipe->vdev_nodes[node_idx++].desc.name =
+			capture_queue_names[pipe->id][i];
+	}
+}
+
+static void mtk_raw_pipeline_ctrl_setup(struct mtk_raw_pipeline *pipe)
+{
+	struct v4l2_ctrl_handler *ctrl_hdlr;
+	struct v4l2_ctrl *ctrl;
+	struct device *dev = pipe->raw->devs[pipe->id];
+	int ret = 0;
+
+	ctrl_hdlr = &pipe->ctrl_handler;
+	ret = v4l2_ctrl_handler_init(ctrl_hdlr, 5);
+	if (ret) {
+		dev_info(dev, "v4l2_ctrl_handler init failed\n");
+		return;
+	}
+	mutex_init(&pipe->res_config.resource_lock);
+	mutex_init(&pipe->try_res_config.resource_lock);
+	ctrl = v4l2_ctrl_new_custom(ctrl_hdlr, &hwn_limit, NULL);
+	if (ctrl)
+		ctrl->flags |= V4L2_CTRL_FLAG_VOLATILE |
+			       V4L2_CTRL_FLAG_EXECUTE_ON_WRITE;
+	ctrl = v4l2_ctrl_new_custom(ctrl_hdlr, &frz_limit, NULL);
+	if (ctrl)
+		ctrl->flags |= V4L2_CTRL_FLAG_VOLATILE |
+			       V4L2_CTRL_FLAG_EXECUTE_ON_WRITE;
+	ctrl = v4l2_ctrl_new_custom(ctrl_hdlr, &bin_limit, NULL);
+	if (ctrl)
+		ctrl->flags |= V4L2_CTRL_FLAG_VOLATILE |
+			       V4L2_CTRL_FLAG_EXECUTE_ON_WRITE;
+	ctrl = v4l2_ctrl_new_custom(ctrl_hdlr, &hwn, NULL);
+	if (ctrl)
+		ctrl->flags |= V4L2_CTRL_FLAG_VOLATILE;
+	ctrl = v4l2_ctrl_new_custom(ctrl_hdlr, &frz, NULL);
+	if (ctrl)
+		ctrl->flags |= V4L2_CTRL_FLAG_VOLATILE;
+	ctrl = v4l2_ctrl_new_custom(ctrl_hdlr, &bin, NULL);
+	if (ctrl)
+		ctrl->flags |= V4L2_CTRL_FLAG_VOLATILE;
+	ctrl = v4l2_ctrl_new_custom(ctrl_hdlr, &hwn_try, NULL);
+	if (ctrl)
+		ctrl->flags |= V4L2_CTRL_FLAG_VOLATILE;
+	ctrl = v4l2_ctrl_new_custom(ctrl_hdlr, &frz_try, NULL);
+	if (ctrl)
+		ctrl->flags |= V4L2_CTRL_FLAG_VOLATILE;
+	ctrl = v4l2_ctrl_new_custom(ctrl_hdlr, &bin_try, NULL);
+	if (ctrl)
+		ctrl->flags |= V4L2_CTRL_FLAG_VOLATILE;
+	v4l2_ctrl_new_custom(ctrl_hdlr, &res_plan_policy, NULL);
+	ctrl = v4l2_ctrl_new_custom(ctrl_hdlr, &res_pixel_rate, NULL);
+	if (ctrl)
+		ctrl->flags |= V4L2_CTRL_FLAG_VOLATILE;
+	ctrl = v4l2_ctrl_new_custom(ctrl_hdlr, &frame_sync_id, NULL);
+	if (ctrl)
+		ctrl->flags |= V4L2_CTRL_FLAG_VOLATILE |
+			       V4L2_CTRL_FLAG_EXECUTE_ON_WRITE;
+	ctrl = v4l2_ctrl_new_custom(ctrl_hdlr, &raw_path, NULL);
+	if (ctrl)
+		ctrl->flags |= V4L2_CTRL_FLAG_VOLATILE |
+			       V4L2_CTRL_FLAG_EXECUTE_ON_WRITE;
+
+	v4l2_ctrl_new_std(ctrl_hdlr, &cam_ctrl_ops,
+				    V4L2_CID_HBLANK, 0, 65535, 1, 0);
+	v4l2_ctrl_new_std(ctrl_hdlr, &cam_ctrl_ops,
+				    V4L2_CID_VBLANK, 0, 65535, 1, 0);
+
+	// PDE
+	ctrl = v4l2_ctrl_new_custom(ctrl_hdlr, &cfg_pde_info, NULL);
+
+	ctrl = v4l2_ctrl_new_custom(ctrl_hdlr, &mtk_feature, NULL);
+	if (ctrl)
+		ctrl->flags |= V4L2_CTRL_FLAG_VOLATILE |
+			V4L2_CTRL_FLAG_EXECUTE_ON_WRITE;
+
+	ctrl = v4l2_ctrl_new_custom(ctrl_hdlr, &cfg_res_update, NULL);
+	if (ctrl)
+		ctrl->flags |= V4L2_CTRL_FLAG_VOLATILE |
+			V4L2_CTRL_FLAG_EXECUTE_ON_WRITE;
+
+	ctrl = v4l2_ctrl_new_custom(ctrl_hdlr, &cfg_res_ctrl, NULL);
+	if (ctrl)
+		ctrl->flags |= V4L2_CTRL_FLAG_VOLATILE |
+			V4L2_CTRL_FLAG_EXECUTE_ON_WRITE;
+
+	ctrl = v4l2_ctrl_new_custom(ctrl_hdlr,
+		&mtk_camsys_hw_mode, NULL);
+	if (ctrl)
+		ctrl->flags |= V4L2_CTRL_FLAG_EXECUTE_ON_WRITE;
+
+	v4l2_ctrl_new_custom(ctrl_hdlr, &mstream_exposure, NULL);
+	pipe->res_config.hwn_limit_max = hwn_limit.def;
+	pipe->res_config.frz_limit = frz_limit.def;
+	pipe->res_config.bin_limit = bin_limit.def;
+	pipe->res_config.res_plan = res_plan_policy.def;
+	pipe->feature_pending = mtk_feature.def;
+	pipe->sync_id = frame_sync_id.def;
+	pipe->sensor_mode_update = cfg_res_update.def;
+	pipe->pde_config.pde_info.pdo_max_size = cfg_pde_info.def;
+	pipe->pde_config.pde_info.pdi_max_size = cfg_pde_info.def;
+	pipe->pde_config.pde_info.pd_table_offset = cfg_pde_info.def;
+	pipe->subdev.ctrl_handler = ctrl_hdlr;
+	pipe->hw_mode = mtk_camsys_hw_mode.def;
+}
+
+static int mtk_raw_pipeline_register(unsigned int id, struct device *dev,
+				     struct mtk_raw_pipeline *pipe,
+			       struct v4l2_device *v4l2_dev)
+{
+	struct mtk_cam_device *cam = dev_get_drvdata(pipe->raw->cam_dev);
+	struct v4l2_subdev *sd = &pipe->subdev;
+	struct mtk_cam_video_device *video;
+	unsigned int i;
+	int ret;
+
+	pipe->id = id;
+	pipe->dynamic_exposure_num_max = 3;
+
+	/* Initialize subdev */
+	v4l2_subdev_init(sd, &mtk_raw_subdev_ops);
+	sd->entity.function = MEDIA_ENT_F_PROC_VIDEO_PIXEL_FORMATTER;
+	sd->entity.ops = &mtk_cam_media_entity_ops;
+	sd->flags = V4L2_SUBDEV_FL_HAS_DEVNODE | V4L2_SUBDEV_FL_HAS_EVENTS;
+	snprintf(sd->name, sizeof(sd->name),
+		 "%s-%d", dev_driver_string(dev), pipe->id);
+	v4l2_set_subdevdata(sd, pipe);
+	mtk_raw_pipeline_ctrl_setup(pipe);
+	dev_info(dev, "%s: %s\n", __func__, sd->name);
+
+	ret = v4l2_device_register_subdev(v4l2_dev, sd);
+	if (ret < 0) {
+		dev_info(dev, "Failed to register subdev: %d\n", ret);
+		return ret;
+	}
+
+	mtk_raw_pipeline_queue_setup(pipe);
+	/* setup pads of raw pipeline */
+	for (i = 0; i < ARRAY_SIZE(pipe->pads); i++) {
+		pipe->pads[i].flags = i < MTK_RAW_SOURCE_BEGIN ?
+			MEDIA_PAD_FL_SINK : MEDIA_PAD_FL_SOURCE;
+	}
+
+	media_entity_pads_init(&sd->entity, ARRAY_SIZE(pipe->pads), pipe->pads);
+
+	/* setup video node */
+	for (i = 0; i < ARRAY_SIZE(pipe->vdev_nodes); i++) {
+		video = pipe->vdev_nodes + i;
+
+		switch (pipe->id) {
+		case MTKCAM_SUBDEV_RAW_0:
+		case MTKCAM_SUBDEV_RAW_1:
+		case MTKCAM_SUBDEV_RAW_2:
+			video->uid.pipe_id = pipe->id;
+			break;
+		default:
+			dev_dbg(dev, "invalid pipe id\n");
+			return -EINVAL;
+		}
+
+		video->uid.id = video->desc.dma_port;
+		video->ctx = &cam->ctxs[id];
+		ret = mtk_cam_video_register(video, v4l2_dev);
+		if (ret)
+			goto fail_unregister_video;
+
+		if (V4L2_TYPE_IS_OUTPUT(video->desc.buf_type))
+			ret = media_create_pad_link(&video->vdev.entity, 0,
+						    &sd->entity,
+						    video->desc.id,
+						    video->desc.link_flags);
+		else
+			ret = media_create_pad_link(&sd->entity,
+						    video->desc.id,
+						    &video->vdev.entity, 0,
+						    video->desc.link_flags);
+
+		if (ret)
+			goto fail_unregister_video;
+	}
+
+	return 0;
+
+fail_unregister_video:
+	for (i = i - 1; i >= 0; i--)
+		mtk_cam_video_unregister(pipe->vdev_nodes + i);
+
+	return ret;
+}
+
+static void mtk_raw_pipeline_unregister(struct mtk_raw_pipeline *pipe)
+{
+	unsigned int i;
+
+	for (i = 0; i < ARRAY_SIZE(pipe->vdev_nodes); i++)
+		mtk_cam_video_unregister(pipe->vdev_nodes + i);
+	v4l2_ctrl_handler_free(&pipe->ctrl_handler);
+	mutex_destroy(&pipe->res_config.resource_lock);
+	v4l2_device_unregister_subdev(&pipe->subdev);
+	media_entity_cleanup(&pipe->subdev.entity);
+}
+
+int mtk_raw_setup_dependencies(struct mtk_raw *raw)
+{
+	struct device *dev = raw->cam_dev;
+	struct mtk_cam_device *cam_dev = dev_get_drvdata(dev);
+	struct device *consumer, *supplier;
+	struct device_link *link;
+	struct mtk_raw_device *raw_dev;
+	struct mtk_yuv_device *yuv_dev;
+	int i;
+
+	for (i = 0; i < cam_dev->num_raw_devices; i++) {
+		consumer = raw->devs[i];
+		supplier = raw->yuvs[i];
+		if (!consumer || !supplier) {
+			dev_info(dev, "failed to get raw/yuv dev for id %d\n", i);
+			continue;
+		}
+
+		raw_dev = dev_get_drvdata(consumer);
+		yuv_dev = dev_get_drvdata(supplier);
+		raw_dev->yuv_base = yuv_dev->base;
+
+		link = device_link_add(consumer, supplier,
+				       DL_FLAG_AUTOREMOVE_CONSUMER |
+				       DL_FLAG_PM_RUNTIME);
+		if (!link) {
+			dev_info(dev, "Unable to create link between %s and %s\n",
+				 dev_name(consumer), dev_name(supplier));
+			return -ENODEV;
+		}
+	}
+
+	return 0;
+}
+
+int mtk_raw_register_entities(struct mtk_raw *raw, struct v4l2_device *v4l2_dev)
+{
+	struct device *dev = raw->cam_dev;
+	struct mtk_cam_device *cam_dev = dev_get_drvdata(dev);
+	unsigned int i;
+	int ret;
+
+	for (i = 0; i < cam_dev->num_raw_devices; i++) {
+		struct mtk_raw_pipeline *pipe = raw->pipelines + i;
+
+		pipe->raw = raw;
+		memset(pipe->cfg, 0, sizeof(*pipe->cfg));
+		ret = mtk_raw_pipeline_register(MTKCAM_SUBDEV_RAW_0 + i,
+						raw->devs[i],
+						raw->pipelines + i, v4l2_dev);
+		if (ret)
+			return ret;
+	}
+	return 0;
+}
+
+void mtk_raw_unregister_entities(struct mtk_raw *raw)
+{
+	struct device *dev = raw->cam_dev;
+	struct mtk_cam_device *cam_dev = dev_get_drvdata(dev);
+	unsigned int i;
+
+	for (i = 0; i < cam_dev->num_raw_devices; i++)
+		mtk_raw_pipeline_unregister(raw->pipelines + i);
+}
+
+static int mtk_raw_component_bind(struct device *dev, struct device *master,
+				  void *data)
+{
+	struct mtk_raw_device *raw_dev = dev_get_drvdata(dev);
+	struct mtk_cam_device *cam_dev = data;
+	struct mtk_raw *raw = &cam_dev->raw;
+
+	dev_info(dev, "%s: id=%d\n", __func__, raw_dev->id);
+
+	raw_dev->cam = cam_dev;
+	raw->devs[raw_dev->id] = dev;
+	raw->cam_dev = cam_dev->dev;
+
+	return 0;
+}
+
+static void mtk_raw_component_unbind(struct device *dev, struct device *master,
+				     void *data)
+{
+	struct mtk_raw_device *raw_dev = dev_get_drvdata(dev);
+	struct mtk_cam_device *cam_dev = data;
+	struct mtk_raw *raw = &cam_dev->raw;
+
+	dev_info(dev, "%s\n", __func__);
+
+	raw_dev->cam = NULL;
+	raw_dev->pipeline = NULL;
+	raw->devs[raw_dev->id] = NULL;
+}
+
+static const struct component_ops mtk_raw_component_ops = {
+	.bind = mtk_raw_component_bind,
+	.unbind = mtk_raw_component_unbind,
+};
+
+static int mtk_raw_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct mtk_raw_device *raw_dev;
+	int ret;
+
+	dev_info(dev, "%s\n", __func__);
+
+	raw_dev = devm_kzalloc(dev, sizeof(*raw_dev), GFP_KERNEL);
+	if (!raw_dev)
+		return -ENOMEM;
+
+	raw_dev->dev = dev;
+	dev_set_drvdata(dev, raw_dev);
+
+	ret = mtk_raw_of_probe(pdev, raw_dev);
+	if (ret)
+		return ret;
+
+	raw_dev->fifo_size =
+		roundup_pow_of_two(8 * sizeof(struct mtk_camsys_irq_info));
+	raw_dev->msg_buffer = devm_kzalloc(dev, raw_dev->fifo_size, GFP_KERNEL);
+	if (!raw_dev->msg_buffer)
+		return -ENOMEM;
+
+	pm_runtime_enable(dev);
+
+	return component_add(dev, &mtk_raw_component_ops);
+}
+
+static int mtk_raw_remove(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct mtk_raw_device *raw_dev = dev_get_drvdata(dev);
+	int i;
+
+	dev_info(dev, "%s\n", __func__);
+
+	unregister_pm_notifier(&raw_dev->pm_notifier);
+
+	pm_runtime_disable(dev);
+	component_del(dev, &mtk_raw_component_ops);
+
+	for (i = 0; i < raw_dev->num_clks; i++)
+		clk_put(raw_dev->clks[i]);
+
+	return 0;
+}
+
+static int mtk_raw_runtime_suspend(struct device *dev)
+{
+	struct mtk_raw_device *drvdata = dev_get_drvdata(dev);
+	int i;
+
+	dev_dbg(dev, "%s:disable clock\n", __func__);
+
+	disable_irq(drvdata->irq);
+
+	reset(drvdata);
+
+	for (i = 0; i < drvdata->num_clks; i++)
+		clk_disable_unprepare(drvdata->clks[i]);
+
+	return 0;
+}
+
+static int mtk_raw_runtime_resume(struct device *dev)
+{
+	struct mtk_raw_device *drvdata = dev_get_drvdata(dev);
+	int i, ret;
+
+	/* reset_msgfifo before enable_irq */
+	ret = reset_msgfifo(drvdata);
+	if (ret)
+		return ret;
+
+	enable_irq(drvdata->irq);
+
+	dev_dbg(dev, "%s:enable clock\n", __func__);
+
+	for (i = 0; i < drvdata->num_clks; i++) {
+		ret = clk_prepare_enable(drvdata->clks[i]);
+		if (ret) {
+			dev_info(dev, "enable failed at clk #%d, ret = %d\n",
+				 i, ret);
+			i--;
+			while (i >= 0)
+				clk_disable_unprepare(drvdata->clks[i--]);
+
+			return ret;
+		}
+	}
+
+	reset(drvdata);
+
+	return 0;
+}
+
+static const struct dev_pm_ops mtk_raw_pm_ops = {
+	SET_RUNTIME_PM_OPS(mtk_raw_runtime_suspend, mtk_raw_runtime_resume,
+			   NULL)
+};
+
+static const struct of_device_id mtk_raw_of_ids[] = {
+	{.compatible = "mediatek,cam-raw",},
+	{}
+};
+MODULE_DEVICE_TABLE(of, mtk_raw_of_ids);
+
+struct platform_driver mtk_cam_raw_driver = {
+	.probe   = mtk_raw_probe,
+	.remove  = mtk_raw_remove,
+	.driver  = {
+		.name  = "mtk-cam raw",
+		.of_match_table = of_match_ptr(mtk_raw_of_ids),
+		.pm     = &mtk_raw_pm_ops,
+	}
+};
+
+static int mtk_yuv_component_bind(struct device *dev, struct device *master,
+				  void *data)
+{
+	struct mtk_yuv_device *drvdata = dev_get_drvdata(dev);
+	struct mtk_cam_device *cam_dev = data;
+	struct mtk_raw *raw = &cam_dev->raw;
+
+	dev_info(dev, "%s: id=%d\n", __func__, drvdata->id);
+	raw->yuvs[drvdata->id] = dev;
+
+	return 0;
+}
+
+static void mtk_yuv_component_unbind(struct device *dev, struct device *master,
+				     void *data)
+{
+	struct mtk_yuv_device *drvdata = dev_get_drvdata(dev);
+	struct mtk_cam_device *cam_dev = data;
+	struct mtk_raw *raw = &cam_dev->raw;
+
+	dev_info(dev, "%s\n", __func__);
+	raw->yuvs[drvdata->id] = NULL;
+}
+
+static const struct component_ops mtk_yuv_component_ops = {
+	.bind = mtk_yuv_component_bind,
+	.unbind = mtk_yuv_component_unbind,
+};
+
+static irqreturn_t mtk_irq_yuv(int irq, void *data)
+{
+	struct mtk_yuv_device *drvdata = (struct mtk_yuv_device *)data;
+	struct device *dev = drvdata->dev;
+
+	unsigned int irq_status, err_status, dma_done_status;
+	unsigned int drop_status, dma_ofl_status;
+
+	irq_status =
+		readl_relaxed(drvdata->base + REG_CTL_RAW_INT_STAT);
+	dma_done_status =
+		readl_relaxed(drvdata->base + REG_CTL_RAW_INT2_STAT);
+	drop_status =
+		readl_relaxed(drvdata->base + REG_CTL_RAW_INT4_STAT);
+	dma_ofl_status =
+		readl_relaxed(drvdata->base + REG_CTL_RAW_INT5_STAT);
+
+	err_status = irq_status & 0x4; // bit2: DMA_ERR
+
+	if (unlikely(debug_raw))
+		dev_dbg(dev, "YUV-INT:0x%x(err:0x%x) INT2/4/5 0x%x/0x%x/0x%x\n",
+			irq_status, err_status,
+			dma_done_status, drop_status, dma_ofl_status);
+
+	return IRQ_HANDLED;
+}
+
+static int mtk_yuv_pm_suspend_prepare(struct mtk_yuv_device *dev)
+{
+	int ret;
+
+	dev_dbg(dev->dev, "- %s\n", __func__);
+
+	if (pm_runtime_suspended(dev->dev))
+		return 0;
+
+	/* Force ISP HW to idle */
+	ret = pm_runtime_force_suspend(dev->dev);
+	return ret;
+}
+
+static int mtk_yuv_pm_post_suspend(struct mtk_yuv_device *dev)
+{
+	int ret;
+
+	dev_dbg(dev->dev, "- %s\n", __func__);
+
+	if (pm_runtime_suspended(dev->dev))
+		return 0;
+
+	/* Force ISP HW to resume */
+	ret = pm_runtime_force_resume(dev->dev);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+static int yuv_pm_notifier(struct notifier_block *nb,
+							unsigned long action, void *data)
+{
+	struct mtk_yuv_device *yuv_dev =
+			container_of(nb, struct mtk_yuv_device, pm_notifier);
+
+	switch (action) {
+	case PM_SUSPEND_PREPARE:
+		mtk_yuv_pm_suspend_prepare(yuv_dev);
+		break;
+	case PM_POST_SUSPEND:
+		mtk_yuv_pm_post_suspend(yuv_dev);
+		break;
+	default:
+		break;
+	}
+
+	return NOTIFY_OK;
+}
+
+static int mtk_yuv_of_probe(struct platform_device *pdev,
+			    struct mtk_yuv_device *drvdata)
+{
+	struct device *dev = &pdev->dev;
+	struct resource *res;
+	unsigned int i;
+	int irq, clks, ret;
+
+	ret = of_property_read_u32(dev->of_node, "mediatek,cam-id",
+				   &drvdata->id);
+	if (ret) {
+		dev_dbg(dev, "missing camid property\n");
+		return ret;
+	}
+
+	if (dma_set_mask_and_coherent(dev, DMA_BIT_MASK(34)))
+		dev_info(dev, "%s: No suitable DMA available\n", __func__);
+
+	if (!dev->dma_parms) {
+		dev->dma_parms =
+			devm_kzalloc(dev, sizeof(*dev->dma_parms), GFP_KERNEL);
+		if (!dev->dma_parms)
+			return -ENOMEM;
+	}
+
+	if (dev->dma_parms) {
+		ret = dma_set_max_seg_size(dev, UINT_MAX);
+		if (ret)
+			dev_info(dev, "Failed to set DMA segment size\n");
+	}
+
+	/* base outer register */
+	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "base");
+	if (!res) {
+		dev_info(dev, "failed to get mem\n");
+		return -ENODEV;
+	}
+
+	drvdata->base = devm_ioremap_resource(dev, res);
+	if (IS_ERR(drvdata->base)) {
+		dev_dbg(dev, "failed to map register base\n");
+		return PTR_ERR(drvdata->base);
+	}
+
+	irq = platform_get_irq(pdev, 0);
+	if (irq < 0) {
+		dev_dbg(dev, "failed to get irq\n");
+		return -ENODEV;
+	}
+
+	ret = devm_request_irq(dev, irq, mtk_irq_yuv, 0,
+			       dev_name(dev), drvdata);
+	if (ret) {
+		dev_dbg(dev, "failed to request irq=%d\n", irq);
+		return ret;
+	}
+	dev_dbg(dev, "registered irq=%d\n", irq);
+
+	clks = of_count_phandle_with_args(pdev->dev.of_node, "clocks",
+			"#clock-cells");
+
+	drvdata->num_clks  = (clks == -ENOENT) ? 0:clks;
+	dev_info(dev, "clk_num:%d\n", drvdata->num_clks);
+
+	if (drvdata->num_clks) {
+		drvdata->clks = devm_kcalloc(dev, drvdata->num_clks,
+					     sizeof(*drvdata->clks),
+					     GFP_KERNEL);
+		if (!drvdata->clks)
+			return -ENOMEM;
+	}
+
+	for (i = 0; i < drvdata->num_clks; i++) {
+		drvdata->clks[i] = of_clk_get(pdev->dev.of_node, i);
+		if (IS_ERR(drvdata->clks[i])) {
+			dev_info(dev, "failed to get clk %d\n", i);
+			return -ENODEV;
+		}
+	}
+
+#ifdef CONFIG_PM_SLEEP
+	drvdata->pm_notifier.notifier_call = yuv_pm_notifier;
+	ret = register_pm_notifier(&drvdata->pm_notifier);
+	if (ret) {
+		dev_info(dev, "failed to register notifier block.\n");
+		return ret;
+	}
+#endif
+
+	return 0;
+}
+
+static int mtk_yuv_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct mtk_yuv_device *drvdata;
+	int ret;
+
+	dev_info(dev, "%s\n", __func__);
+
+	drvdata = devm_kzalloc(dev, sizeof(*drvdata), GFP_KERNEL);
+	if (!drvdata)
+		return -ENOMEM;
+
+	drvdata->dev = dev;
+	dev_set_drvdata(dev, drvdata);
+
+	ret = mtk_yuv_of_probe(pdev, drvdata);
+	if (ret) {
+		dev_info(dev, "mtk_yuv_of_probe failed\n");
+		return ret;
+	}
+
+	pm_runtime_enable(dev);
+
+	return component_add(dev, &mtk_yuv_component_ops);
+}
+
+static int mtk_yuv_remove(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct mtk_yuv_device *drvdata = dev_get_drvdata(dev);
+	int i;
+
+	dev_info(dev, "%s\n", __func__);
+
+	unregister_pm_notifier(&drvdata->pm_notifier);
+
+	pm_runtime_disable(dev);
+	component_del(dev, &mtk_yuv_component_ops);
+
+	for (i = 0; i < drvdata->num_clks; i++)
+		clk_put(drvdata->clks[i]);
+
+	return 0;
+}
+
+/* driver for yuv part */
+static int mtk_yuv_runtime_suspend(struct device *dev)
+{
+	struct mtk_yuv_device *drvdata = dev_get_drvdata(dev);
+	int i;
+
+	dev_info(dev, "%s:disable clock\n", __func__);
+
+	for (i = 0; i < drvdata->num_clks; i++)
+		clk_disable_unprepare(drvdata->clks[i]);
+
+	return 0;
+}
+
+static int mtk_yuv_runtime_resume(struct device *dev)
+{
+	struct mtk_yuv_device *drvdata = dev_get_drvdata(dev);
+	int i, ret;
+
+	dev_info(dev, "%s:enable clock\n", __func__);
+
+	for (i = 0; i < drvdata->num_clks; i++) {
+		ret = clk_prepare_enable(drvdata->clks[i]);
+		if (ret) {
+			dev_info(dev, "enable failed at clk #%d, ret = %d\n",
+				 i, ret);
+			i--;
+			while (i >= 0)
+				clk_disable_unprepare(drvdata->clks[i--]);
+
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
+#ifdef CAMSYS_TF_DUMP_71_1
+int mtk_cam_translation_fault_callback(int port, dma_addr_t mva, void *data)
+{
+	struct mtk_raw_device *raw_dev = (struct mtk_raw_device *)data;
+	struct device *dev = raw_dev->dev;
+	struct mtk_cam_ctx *ctx;
+	struct mtk_cam_request_stream_data *s_data;
+
+	unsigned int dequeued_frame_seq_no_inner;
+	unsigned int rawi_inner_addr, rawi_inner_addr_msb;
+	unsigned int inner_addr, inner_addr_msb, size;
+
+	dequeued_frame_seq_no_inner =
+		readl_relaxed(raw_dev->base_inner + REG_FRAME_SEQ_NUM);
+
+	if (atomic_read(&raw_dev->vf_en) == 0)
+		dequeued_frame_seq_no_inner = 1;
+
+	ctx = mtk_cam_find_ctx(raw_dev->cam, &raw_dev->pipeline->subdev.entity);
+	s_data = mtk_cam_get_req_s_data(ctx, ctx->stream_id, dequeued_frame_seq_no_inner);
+
+	dev_info(dev, "=================== [CAMSYS M4U] Dump Begin ==================\n");
+
+	dev_info(dev, "M4U TF port %d iova %pad frame_seq_no %d raw id %d vf %d\n",
+		port, &mva, dequeued_frame_seq_no_inner, raw_dev->id, atomic_read(&raw_dev->vf_en));
+
+	mtk_cam_raw_dump_fbc(raw_dev->dev, raw_dev->base, raw_dev->yuv_base);
+
+	dev_info(raw_dev->dev,
+		 "[Outter] TG PATHCFG/SENMODE FRMSIZE/R GRABPXL/LIN:%x/%x %x/%x %x/%x\n",
+		 readl_relaxed(raw_dev->base + REG_TG_PATH_CFG),
+		 readl_relaxed(raw_dev->base + REG_TG_SEN_MODE),
+		 readl_relaxed(raw_dev->base + REG_TG_FRMSIZE_ST),
+		 readl_relaxed(raw_dev->base + REG_TG_FRMSIZE_ST_R),
+		 readl_relaxed(raw_dev->base + REG_TG_SEN_GRAB_PXL),
+		 readl_relaxed(raw_dev->base + REG_TG_SEN_GRAB_LIN));
+	dev_info(raw_dev->dev,
+		 "[Inner] TG PATHCFG/SENMODE FRMSIZE/R GRABPXL/LIN:%x/%x %x/%x %x/%x\n",
+		 readl_relaxed(raw_dev->base_inner + REG_TG_PATH_CFG),
+		 readl_relaxed(raw_dev->base_inner + REG_TG_SEN_MODE),
+		 readl_relaxed(raw_dev->base_inner + REG_TG_FRMSIZE_ST),
+		 readl_relaxed(raw_dev->base_inner + REG_TG_FRMSIZE_ST_R),
+		 readl_relaxed(raw_dev->base_inner + REG_TG_SEN_GRAB_PXL),
+		 readl_relaxed(raw_dev->base_inner + REG_TG_SEN_GRAB_LIN));
+	dev_info(raw_dev->dev,
+		 "REQ RAW/2/3 DMA/2:%08x/%08x/%08x/%08x/%08x\n",
+		 readl_relaxed(raw_dev->base + REG_CTL_RAW_MOD_REQ_STAT),
+		 readl_relaxed(raw_dev->base + REG_CTL_RAW_MOD2_REQ_STAT),
+		 readl_relaxed(raw_dev->base + REG_CTL_RAW_MOD3_REQ_STAT),
+		 readl_relaxed(raw_dev->base + REG_CTL_RAW_MOD5_REQ_STAT),
+		 readl_relaxed(raw_dev->base + REG_CTL_RAW_MOD6_REQ_STAT));
+	dev_info(raw_dev->dev,
+		 "RDY RAW/2/3 DMA/2:%08x/%08x/%08x/%08x/%08x\n",
+		 readl_relaxed(raw_dev->base + REG_CTL_RAW_MOD_RDY_STAT),
+		 readl_relaxed(raw_dev->base + REG_CTL_RAW_MOD2_RDY_STAT),
+		 readl_relaxed(raw_dev->base + REG_CTL_RAW_MOD3_RDY_STAT),
+		 readl_relaxed(raw_dev->base + REG_CTL_RAW_MOD5_RDY_STAT),
+		 readl_relaxed(raw_dev->base + REG_CTL_RAW_MOD6_RDY_STAT));
+	dev_info(raw_dev->dev,
+		 "REQ YUV/2/3/4 WDMA:%08x/%08x/%08x/%08x/%08x\n",
+		 readl_relaxed(raw_dev->yuv_base + REG_CTL_RAW_MOD_REQ_STAT),
+		 readl_relaxed(raw_dev->yuv_base + REG_CTL_RAW_MOD2_REQ_STAT),
+		 readl_relaxed(raw_dev->yuv_base + REG_CTL_RAW_MOD3_REQ_STAT),
+		 readl_relaxed(raw_dev->yuv_base + REG_CTL_RAW_MOD4_REQ_STAT),
+		 readl_relaxed(raw_dev->yuv_base + REG_CTL_RAW_MOD5_REQ_STAT));
+	dev_info(raw_dev->dev,
+		 "RDY YUV/2/3/4 WDMA:%08x/%08x/%08x/%08x/%08x\n",
+		 readl_relaxed(raw_dev->yuv_base + REG_CTL_RAW_MOD_RDY_STAT),
+		 readl_relaxed(raw_dev->yuv_base + REG_CTL_RAW_MOD2_RDY_STAT),
+		 readl_relaxed(raw_dev->yuv_base + REG_CTL_RAW_MOD3_RDY_STAT),
+		 readl_relaxed(raw_dev->yuv_base + REG_CTL_RAW_MOD4_RDY_STAT),
+		 readl_relaxed(raw_dev->yuv_base + REG_CTL_RAW_MOD5_RDY_STAT));
+
+	switch (port) {
+	case M4U_PORT_L16_CAM2_CQI_R1:
+	case M4U_PORT_L27_CAM2_CQI_R1:
+	case M4U_PORT_L28_CAM2_CQI_R1:
+	case M4U_PORT_L16_CAM2_CQI_R2:
+	case M4U_PORT_L27_CAM2_CQI_R2:
+	case M4U_PORT_L28_CAM2_CQI_R2:
+		// M4U_PORT CAM2_CQI_R1 + CAM2_CQI_R2
+		inner_addr =
+				readl_relaxed(raw_dev->base_inner + REG_CQ_THR0_BASEADDR);
+		inner_addr_msb =
+				readl_relaxed(raw_dev->base_inner + REG_CQ_THR0_BASEADDR_MSB);
+		size = readl_relaxed(raw_dev->base_inner + REG_CQ_THR0_DESC_SIZE);
+		dev_info(raw_dev->dev,
+			 "CQ_THR0_inner_addr_msb:%d, CQ_THR0_inner_addr:%08x, size:0x%x\n",
+			inner_addr_msb, inner_addr, size);
+
+		inner_addr =
+				readl_relaxed(raw_dev->base_inner + REG_CQ_SUB_THR0_BASEADDR_2);
+		inner_addr_msb =
+				readl_relaxed(raw_dev->base_inner + REG_CQ_SUB_THR0_BASEADDR_MSB_2);
+		size = readl_relaxed(raw_dev->base_inner + REG_CQ_SUB_THR0_DESC_SIZE_2);
+		dev_info(raw_dev->dev,
+			 "CQ_SUB_THR0_2_inner_addr_msb:%d, CQ_SUB_THR0_2_inner_addr:%08x, size:0x%x\n",
+			inner_addr_msb, inner_addr, size);
+		break;
+	case M4U_PORT_L16_CAM2_RAWI_R2:
+	case M4U_PORT_L27_CAM2_RAWI_R2:
+	case M4U_PORT_L28_CAM2_RAWI_R2:
+		// M4U_PORT CAM2_RAWI_R2
+		rawi_inner_addr =
+				readl_relaxed(raw_dev->base_inner + REG_RAWI_R2_BASE);
+		rawi_inner_addr_msb =
+				readl_relaxed(raw_dev->base_inner + REG_RAWI_R2_BASE_MSB);
+		dev_info(raw_dev->dev,
+			 "rawi_r2_inner_addr_msb:%d, rawi_r2_inner_addr:%08x\n",
+			rawi_inner_addr_msb, rawi_inner_addr);
+
+		mtk_cam_dump_dma_debug(raw_dev->dev, raw_dev->base + CAMDMATOP_BASE,
+				"RAWI_R2", dbg_RAWI_R2, ARRAY_SIZE(dbg_RAWI_R2));
+		break;
+	case M4U_PORT_L16_CAM2_RAWI_R3:
+	case M4U_PORT_L27_CAM2_RAWI_R3:
+	case M4U_PORT_L28_CAM2_RAWI_R3:
+		// M4U_PORT CAM2_RAWI_R2
+		rawi_inner_addr =
+				readl_relaxed(raw_dev->base_inner + REG_RAWI_R3_BASE);
+		rawi_inner_addr_msb =
+				readl_relaxed(raw_dev->base_inner + REG_RAWI_R3_BASE_MSB);
+		dev_info(raw_dev->dev,
+			 "rawi_r3_inner_addr_msb:%d, rawi_r3_inner_addr:%08x\n",
+			 rawi_inner_addr_msb, rawi_inner_addr);
+
+		mtk_cam_dump_dma_debug(raw_dev->dev, raw_dev->base + CAMDMATOP_BASE,
+				"RAWI_R3", dbg_RAWI_R3, ARRAY_SIZE(dbg_RAWI_R3));
+		break;
+	case M4U_PORT_L17_CAM3_YUVO_R1:
+	case M4U_PORT_L29_CAM3_YUVO_R1:
+	case M4U_PORT_L30_CAM3_YUVO_R1:
+		// M4U_PORT CAM3_YUVO_R1 : yuvo_r1 + yuvbo_r1
+		mtk_cam_dump_dma_debug(raw_dev->dev, raw_dev->yuv_base + CAMDMATOP_BASE,
+				"YUVO_R1", dbg_YUVO_R1, ARRAY_SIZE(dbg_YUVO_R1));
+		break;
+	case M4U_PORT_L17_CAM3_YUVO_R3:
+	case M4U_PORT_L29_CAM3_YUVO_R3:
+	case M4U_PORT_L30_CAM3_YUVO_R3:
+		// M4U_PORT CAM3_YUVO_R3 : yuvo_r3 + yuvbo_r3
+		mtk_cam_dump_dma_debug(raw_dev->dev, raw_dev->yuv_base + CAMDMATOP_BASE,
+				"YUVO_R3", dbg_YUVO_R3, ARRAY_SIZE(dbg_YUVO_R3));
+		break;
+	case M4U_PORT_L17_CAM3_YUVCO_R1:
+	case M4U_PORT_L29_CAM3_YUVCO_R1:
+	case M4U_PORT_L30_CAM3_YUVCO_R1:
+		// M4U_PORT CAM3_YUVCO_R1 : yuvco_r1 + yuvdo_r1 + yuvco_r3 + yuvdo_r3
+		mtk_cam_dump_dma_debug(raw_dev->dev, raw_dev->yuv_base + CAMDMATOP_BASE,
+				"YUVCO_R1", dbg_YUVCO_R1, ARRAY_SIZE(dbg_YUVCO_R1));
+		mtk_cam_dump_dma_debug(raw_dev->dev, raw_dev->yuv_base + CAMDMATOP_BASE,
+				"YUVCO_R3", dbg_YUVCO_R3, ARRAY_SIZE(dbg_YUVCO_R3));
+		break;
+	case M4U_PORT_L17_CAM3_YUVO_R2:
+	case M4U_PORT_L29_CAM3_YUVO_R2:
+	case M4U_PORT_L30_CAM3_YUVO_R2:
+		// M4U_PORT CAM3_YUVO_R2 : yuvo_r2 + yuvbo_r2 + yuvo_r4 + yuvbo_r4
+		//                           + yuvo_r5 + yuvbo_r5
+		mtk_cam_dump_dma_debug(raw_dev->dev, raw_dev->yuv_base + CAMDMATOP_BASE,
+				"YUVO_R2", dbg_YUVO_R2, ARRAY_SIZE(dbg_YUVO_R2));
+		mtk_cam_dump_dma_debug(raw_dev->dev, raw_dev->yuv_base + CAMDMATOP_BASE,
+				"YUVO_R4", dbg_YUVO_R4, ARRAY_SIZE(dbg_YUVO_R4));
+		mtk_cam_dump_dma_debug(raw_dev->dev, raw_dev->yuv_base + CAMDMATOP_BASE,
+				"YUVO_R5", dbg_YUVO_R5, ARRAY_SIZE(dbg_YUVO_R5));
+		break;
+	case M4U_PORT_L17_CAM3_RZH1N2TO_R1:
+	case M4U_PORT_L29_CAM3_RZH1N2TO_R1:
+	case M4U_PORT_L30_CAM3_RZH1N2TO_R1:
+		// M4U_PORT CAM3_RZH1N2TO_R1 : rzh1n2to_r1 + rzh1n2tbo_r1 + rzh1n2to_r2
+		//                               + rzh1n2to_r3 + rzh1n2tbo_r3
+		mtk_cam_dump_dma_debug(raw_dev->dev, raw_dev->yuv_base + CAMDMATOP_BASE,
+				"RZH1N2TO_R1", dbg_RZH1N2TO_R1, ARRAY_SIZE(dbg_RZH1N2TO_R1));
+		mtk_cam_dump_dma_debug(raw_dev->dev, raw_dev->yuv_base + CAMDMATOP_BASE,
+				"RZH1N2TO_R2", dbg_RZH1N2TO_R2, ARRAY_SIZE(dbg_RZH1N2TO_R2));
+		mtk_cam_dump_dma_debug(raw_dev->dev, raw_dev->yuv_base + CAMDMATOP_BASE,
+				"RZH1N2TO_R3", dbg_RZH1N2TO_R3, ARRAY_SIZE(dbg_RZH1N2TO_R3));
+		break;
+	case M4U_PORT_L17_CAM3_DRZS4NO_R1:
+	case M4U_PORT_L29_CAM3_DRZS4NO_R1:
+	case M4U_PORT_L30_CAM3_DRZS4NO_R1:
+		// M4U_PORT CAM3_DRZS4NO_R1 : drzs4no_r1 + drzs4no_r2 + drzs4no_r3
+		//                               + lmvo_r1 + actso_r1
+		mtk_cam_dump_dma_debug(raw_dev->dev, raw_dev->yuv_base + CAMDMATOP_BASE,
+				"DRZS4NO_R1", dbg_DRZS4NO_R1, ARRAY_SIZE(dbg_DRZS4NO_R1));
+		mtk_cam_dump_dma_debug(raw_dev->dev, raw_dev->yuv_base + CAMDMATOP_BASE,
+				"DRZS4NO_R2", dbg_DRZS4NO_R2, ARRAY_SIZE(dbg_DRZS4NO_R2));
+		mtk_cam_dump_dma_debug(raw_dev->dev, raw_dev->yuv_base + CAMDMATOP_BASE,
+				"DRZS4NO_R3", dbg_DRZS4NO_R3, ARRAY_SIZE(dbg_DRZS4NO_R3));
+		mtk_cam_dump_dma_debug(raw_dev->dev, raw_dev->yuv_base + CAMDMATOP_BASE,
+				"LMVO_R1", dbg_LMVO_R1, ARRAY_SIZE(dbg_LMVO_R1));
+		mtk_cam_dump_dma_debug(raw_dev->dev, raw_dev->yuv_base + CAMDMATOP_BASE,
+				"ACTSO_R1", dbg_ACTSO_R1, ARRAY_SIZE(dbg_ACTSO_R1));
+		break;
+	case M4U_PORT_L17_CAM3_TNCSO_R1:
+	case M4U_PORT_L29_CAM3_TNCSO_R1:
+	case M4U_PORT_L30_CAM3_TNCSO_R1:
+		// M4U_PORT CAM3_TNCSO_R1 : tncso_r1 + tncsbo_r1 + tncsho_r1 + tncsyo_r1
+		mtk_cam_dump_dma_debug(raw_dev->dev, raw_dev->yuv_base + CAMDMATOP_BASE,
+				"TNCSO_R1", dbg_TNCSO_R1, ARRAY_SIZE(dbg_TNCSO_R1));
+		mtk_cam_dump_dma_debug(raw_dev->dev, raw_dev->yuv_base + CAMDMATOP_BASE,
+				"TNCSBO_R1", dbg_TNCSBO_R1, ARRAY_SIZE(dbg_TNCSBO_R1));
+		mtk_cam_dump_dma_debug(raw_dev->dev, raw_dev->yuv_base + CAMDMATOP_BASE,
+				"TNCSHO_R1", dbg_TNCSHO_R1, ARRAY_SIZE(dbg_TNCSHO_R1));
+		mtk_cam_dump_dma_debug(raw_dev->dev, raw_dev->yuv_base + CAMDMATOP_BASE,
+				"TNCSYO_R1", dbg_TNCSYO_R1, ARRAY_SIZE(dbg_TNCSYO_R1));
+		break;
+	default:
+		break;
+	}
+	dev_info(dev, "=================== [CAMSYS M4U] Dump End ====================\n");
+	if (s_data)
+		mtk_cam_req_dump(s_data, MTK_CAM_REQ_DUMP_DEQUEUE_FAILED, "M4U TF", false);
+	else
+		dev_info(raw_dev->dev, "s_data is null\n");
+
+	return 0;
+}
+#endif
+
+static const struct dev_pm_ops mtk_yuv_pm_ops = {
+	SET_RUNTIME_PM_OPS(mtk_yuv_runtime_suspend, mtk_yuv_runtime_resume,
+			   NULL)
+};
+
+static const struct of_device_id mtk_yuv_of_ids[] = {
+	{.compatible = "mediatek,cam-yuv",},
+	{}
+};
+MODULE_DEVICE_TABLE(of, mtk_yuv_of_ids);
+
+struct platform_driver mtk_cam_yuv_driver = {
+	.probe   = mtk_yuv_probe,
+	.remove  = mtk_yuv_remove,
+	.driver  = {
+		.name  = "mtk-cam yuv",
+		.of_match_table = of_match_ptr(mtk_yuv_of_ids),
+		.pm     = &mtk_yuv_pm_ops,
+	}
+};
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam-raw.h b/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam-raw.h
new file mode 100755
index 0000000000000000000000000000000000000000..bae0bdf3ee6fd96ea46fd4d056cb6cf5dfde6ee3
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam-raw.h
@@ -0,0 +1,458 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2022 MediaTek Inc.
+ */
+
+#ifndef __MTK_CAM_RAW_H
+#define __MTK_CAM_RAW_H
+
+#include <linux/kfifo.h>
+#include <media/v4l2-subdev.h>
+#include "mtk_cam-video.h"
+#include "mtk_camera-v4l2-controls.h"
+
+struct mtk_cam_request_stream_data;
+
+#ifdef ISP7_1
+#define RAW_PIPELINE_NUM 3
+#else
+#define RAW_PIPELINE_NUM 2
+#endif
+#define SCQ_DEADLINE_MS  15 // ~1/2 frame length
+#define SCQ_DEFAULT_CLK_RATE 208 // default 208MHz
+#define USINGSCQ 1
+#define MTK_CAMSYS_RES_STEP_NUM	8
+
+/* FIXME: dynamic config image max/min w/h */
+#ifdef ISP7_1
+#define IMG_MAX_WIDTH		12000
+#define IMG_MAX_HEIGHT		9000
+#else
+#define IMG_MAX_WIDTH		8192
+#define IMG_MAX_HEIGHT		6144
+#endif
+#define IMG_MIN_WIDTH		80
+#define IMG_MIN_HEIGHT		60
+#define YUV_GROUP1_MAX_WIDTH	8160
+#define YUV_GROUP1_MAX_HEIGHT	3896
+#define YUV_GROUP2_MAX_WIDTH	3060
+#define YUV_GROUP2_MAX_HEIGHT	1145
+#define YUV1_MAX_WIDTH		8160
+#define YUV1_MAX_HEIGHT		2290
+#define YUV2_MAX_WIDTH		3060
+#define YUV2_MAX_HEIGHT		1145
+#define YUV3_MAX_WIDTH		7794
+#define YUV3_MAX_HEIGHT		3896
+#define YUV4_MAX_WIDTH		1530
+#define YUV4_MAX_HEIGHT		572
+#define YUV5_MAX_WIDTH		1530
+#define YUV5_MAX_HEIGHT		572
+#define DRZS4NO1_MAX_WIDTH	2400
+#define DRZS4NO1_MAX_HEIGHT	1080
+#define DRZS4NO2_MAX_WIDTH	2400
+#define DRZS4NO2_MAX_HEIGHT	1080
+#define DRZS4NO3_MAX_WIDTH	576
+#define DRZS4NO3_MAX_HEIGHT	432
+#define RZH1N2TO1_MAX_WIDTH	1280
+#define RZH1N2TO1_MAX_HEIGHT	600
+#define RZH1N2TO2_MAX_WIDTH	512
+#define RZH1N2TO2_MAX_HEIGHT	512
+#define RZH1N2TO3_MAX_WIDTH	1280
+#define RZH1N2TO3_MAX_HEIGHT	600
+
+#define IMG_PIX_ALIGN		2
+
+enum raw_module_id {
+	RAW_A = 0,
+	RAW_B = 1,
+#ifdef ISP7_1
+	RAW_C = 2,
+#endif
+	RAW_NUM,
+};
+/* feature mask to categorize all raw functions */
+#define MTK_CAM_FEATURE_HDR_MASK		0x0000000F
+#define MTK_CAM_FEATURE_SUBSAMPLE_MASK		0x000000F0
+#define MTK_CAM_FEATURE_OFFLINE_M2M_MASK	0x00000100
+#define MTK_CAM_FEATURE_PURE_OFFLINE_M2M_MASK	0x00000200
+#define MTK_CAM_FEATURE_TIMESHARE_MASK		0x00001000
+#define MTK_CAM_FEATURE_HDR_MEMORY_SAVING_MASK	0x00002000
+
+enum raw_function_id {
+	/* hdr */
+	STAGGER_2_EXPOSURE_LE_SE	= (1 << 0),
+	STAGGER_2_EXPOSURE_SE_LE	= (2 << 0),
+	STAGGER_3_EXPOSURE_LE_NE_SE	= (3 << 0),
+	STAGGER_3_EXPOSURE_SE_NE_LE	= (4 << 0),
+	MSTREAM_NE_SE			= (5 << 0),
+	MSTREAM_SE_NE			= (6 << 0),
+	/* high fps (subsample) */
+	HIGHFPS_2_SUBSAMPLE		= (1 << 4),
+	HIGHFPS_4_SUBSAMPLE		= (2 << 4),
+	HIGHFPS_8_SUBSAMPLE		= (3 << 4),
+	HIGHFPS_16_SUBSAMPLE		= (4 << 4),
+	HIGHFPS_32_SUBSAMPLE		= (5 << 4),
+	OFFLINE_M2M			= (1 << 8),
+	PURE_OFFLINE_M2M		= (1 << 9),
+	TIMESHARE_1_GROUP		= (1 << 12),
+	HDR_MEMORY_SAVING		= (1 << 13),
+	WITH_W_CHANNEL			= (1 << 16),
+	RAW_FUNCTION_END		= 0xF0000000,
+};
+
+enum hdr_scenario_id {
+	STAGGER_ON_THE_FLY	= (1 << 0),
+	STAGGER_OFFLINE		= (1 << 1),
+	STAGGER_DCIF		= (1 << 2),
+	STAGGER_M2M		= (1 << 3),
+	MSTREAM			= (1 << 4),
+	MSTREAM_M2M		= (1 << 5),
+};
+
+enum hardware_mode_id {
+	DEFAULT			= 0,
+	ON_THE_FLY		= 1,
+	DCIF			= 2,
+};
+
+/* enum for pads of raw pipeline */
+enum {
+	MTK_RAW_SINK_BEGIN = 0,
+	MTK_RAW_SINK = MTK_RAW_SINK_BEGIN,
+	MTK_RAW_SINK_NUM,
+	MTK_RAW_META_IN = MTK_RAW_SINK_NUM,
+	MTK_RAW_RAWI_2_IN,
+	MTK_RAW_RAWI_3_IN,
+	MTK_RAW_RAWI_4_IN,
+	MTK_RAW_SOURCE_BEGIN,
+	MTK_RAW_MAIN_STREAM_OUT = MTK_RAW_SOURCE_BEGIN,
+	MTK_RAW_YUVO_1_OUT,
+	MTK_RAW_YUVO_2_OUT,
+	MTK_RAW_YUVO_3_OUT,
+	MTK_RAW_YUVO_4_OUT,
+	MTK_RAW_YUVO_5_OUT,
+	MTK_RAW_DRZS4NO_1_OUT,
+	MTK_RAW_DRZS4NO_2_OUT,
+	MTK_RAW_DRZS4NO_3_OUT,
+	MTK_RAW_RZH1N2TO_1_OUT,
+	MTK_RAW_RZH1N2TO_2_OUT,
+	MTK_RAW_RZH1N2TO_3_OUT,
+	MTK_RAW_MAIN_STREAM_SV_1_OUT,
+	MTK_RAW_MAIN_STREAM_SV_2_OUT,
+	MTK_RAW_META_OUT_BEGIN,
+	MTK_RAW_META_OUT_0 = MTK_RAW_META_OUT_BEGIN,
+	MTK_RAW_META_OUT_1,
+	MTK_RAW_META_OUT_2,
+	MTK_RAW_META_SV_OUT_0,
+	MTK_RAW_META_SV_OUT_1,
+	MTK_RAW_META_SV_OUT_2,
+	MTK_RAW_PIPELINE_PADS_NUM,
+};
+
+/* max(pdi_table1, pdi_table2, ...)*/
+#define RAW_STATS_CFG_VARIOUS_SIZE ALIGN(0x7500, SZ_1K)
+
+#define MTK_RAW_TOTAL_NODES (MTK_RAW_PIPELINE_PADS_NUM - MTK_RAW_SINK_NUM)
+
+struct mtk_cam_dev;
+struct mtk_cam_ctx;
+
+/**
+ * TODO raw_hw_ops
+ * struct raw_device;
+ * struct raw_hw_ops {
+ *	TODO: may add arguments to select raw
+ *	int (*get)(struct raw_device *raw, struct mtk_cam_ctx *ctx);
+ *	void (*put)(struct raw_device *raw, struct mtk_cam_ctx *ctx);
+ *
+ *	int (*enable_clk)(struct raw_device *raw, struct mtk_cam_ctx *ctx,
+ *			  raw_resource res);
+ *	int (*disable_clk)(struct raw_device *raw, struct mtk_cam_ctx *ctx,
+ *			   raw_resource res);
+ *
+ *	void (*reset)(struct raw_device *raw, u8 flag);
+ *	irqreturn_t (*isr)(int irq, void *rawdev);
+ * };
+ */
+
+/**
+ * TODO: raw_isr_ops
+ * struct raw_isr_ops {
+ *	void (*apply)(struct raw_device *raw, enum raw_module_id module_id);
+ *	void (*sof)(struct raw_device *raw, enum raw_module_id module_id);
+ *	void (*frame_done)(struct raw_device *raw);
+ * };
+ */
+
+struct mtk_raw_pde_config {
+	struct mtk_cam_pde_info pde_info;
+};
+
+struct mtk_cam_resource_config {
+	struct v4l2_subdev *seninf;
+	struct mutex resource_lock;
+	struct v4l2_fract interval;
+	s64 pixel_rate;
+	u32 bin_limit;
+	u32 frz_limit;
+	u32 hwn_limit_max;
+	u32 hwn_limit_min;
+	s64 hblank;
+	s64 vblank;
+	s64 sensor_pixel_rate;
+	u32 res_plan;
+	u32 raw_feature;
+	u32 res_strategy[MTK_CAMSYS_RES_STEP_NUM];
+	u32 clk_target;
+	u32 raw_num_used;
+	u32 bin_enable;
+	u32 frz_enable;
+	u32 frz_ratio;
+	u32 tgo_pxl_mode;
+	u32 raw_path;
+	/* sink fmt adjusted according resource used*/
+	struct v4l2_mbus_framefmt sink_fmt;
+};
+
+struct mtk_raw_pad_config {
+	struct v4l2_mbus_framefmt mbus_fmt;
+	struct v4l2_rect crop;
+};
+
+/*
+ * struct mtk_raw_pipeline - sub dev to use raws.
+ *
+ * @feature_pending: keep the user value of S_CTRL V4L2_CID_MTK_CAM_FEATURE.
+ *		     It it safe save to be used in mtk_cam_vidioc_s_fmt,
+ *		     mtk_cam_vb2_queue_setup and mtk_cam_vb2_buf_queue
+ *		     But considering that we can't when the user calls S_CTRL,
+ *		     please use mtk_cam_request_stream_data's
+ *		     feature.raw_feature field
+ *		     to avoid the CTRL value change tming issue.
+ * @feature_active: The active feature during streaming. It can't be changed
+ *		    during streaming and can only be used after streaming on.
+ * @req_seninf_old: It is used to keep the request-based link setup parameters.
+ *		    The req_seninf_old stores the original seninf in mtk_cam_link_notify()
+ *		    and it should be clean (set to NULL) after mtk_cam_req_queue()
+ *		    is called.
+ * @req_seninf_new: It is used to keep the request-based link setup parameters.
+ *		    The req_seninf_new stores the original seninf in mtk_cam_link_notify()
+ *		    and it should be clean (set to NULL) after mtk_cam_req_queue()
+ *		    is called.
+ *
+ */
+struct mtk_raw_pipeline {
+	unsigned int id;
+	struct v4l2_subdev subdev;
+	struct media_pad pads[MTK_RAW_PIPELINE_PADS_NUM];
+	struct mtk_cam_video_device vdev_nodes[MTK_RAW_TOTAL_NODES];
+	struct mtk_raw *raw;
+	struct mtk_raw_pad_config cfg[MTK_RAW_PIPELINE_PADS_NUM];
+	/* cached settings */
+	unsigned int enabled_raw;
+	unsigned long enabled_dmas;
+	/* resource controls */
+	struct v4l2_ctrl_handler ctrl_handler;
+	s64 feature_pending;
+	s64 feature_active;
+	int dynamic_exposure_num_max;
+	/* TODO: merge or integrate with mtk_cam_resource_config */
+	struct mtk_cam_resource user_res;
+	struct mtk_cam_resource_config res_config;
+	struct mtk_cam_resource_config try_res_config;
+	int sensor_mode_update;
+	s64 sync_id;
+	/* mstream */
+	struct mtk_cam_mstream_exposure mstream_exposure;
+	/* stagger */
+	enum hdr_scenario_id stagger_path;
+	enum hdr_scenario_id stagger_path_pending;
+	/* pde module */
+	struct mtk_raw_pde_config pde_config;
+	s64 hw_mode;
+	struct v4l2_subdev *req_sensor_new;
+	struct v4l2_subdev *req_seninf_old;
+	struct v4l2_subdev *req_seninf_new;
+	unsigned int req_vfmt_update;
+	unsigned int req_pfmt_update;
+	unsigned int req_vsel_update;
+	unsigned int req_psel_update;
+	struct v4l2_subdev_format req_pad_fmt[MTK_RAW_PIPELINE_PADS_NUM];
+	struct v4l2_subdev_selection req_psel[MTK_RAW_PIPELINE_PADS_NUM];
+
+};
+
+struct mtk_raw_device {
+	struct device *dev;
+	struct mtk_cam_device *cam;
+	unsigned int id;
+	int irq;
+	void __iomem *base;
+	void __iomem *base_inner;
+	void __iomem *yuv_base;
+	unsigned int num_clks;
+	struct clk **clks;
+#ifdef CONFIG_PM_SLEEP
+	struct notifier_block pm_notifier;
+#endif
+
+	int		fifo_size;
+	void		*msg_buffer;
+	struct kfifo	msg_fifo;
+	atomic_t	is_fifo_overflow;
+
+	struct mtk_raw_pipeline *pipeline;
+	bool is_sub;
+
+	u64 sof_count;
+	u64 vsync_count;
+
+	/* for subsample, sensor-control */
+	bool sub_sensor_ctrl_en;
+	int set_sensor_idx;
+	int cur_vsync_idx;
+
+	u8 time_shared_busy;
+	u8 time_shared_busy_ctx_id;
+	atomic_t vf_en;
+	u32 stagger_en;
+	int overrun_debug_dump_cnt;
+};
+
+struct mtk_yuv_device {
+	struct device *dev;
+	unsigned int id;
+	void __iomem *base;
+	unsigned int num_clks;
+	struct clk **clks;
+#ifdef CONFIG_PM_SLEEP
+	struct notifier_block pm_notifier;
+#endif
+};
+
+/* AE information */
+struct mtk_ae_debug_data {
+	u64 OBC_R1_Sum[4];
+	u64 OBC_R2_Sum[4];
+	u64 OBC_R3_Sum[4];
+	u64 AA_Sum[4];
+	u64 LTM_Sum[4];
+};
+
+/*
+ * struct mtk_raw - the raw information
+ *
+ * //FIXME for raw info comments
+ *
+ */
+struct mtk_raw {
+	struct device *cam_dev;
+	struct device *devs[RAW_PIPELINE_NUM];
+	struct device *yuvs[RAW_PIPELINE_NUM];
+	struct mtk_raw_pipeline pipelines[RAW_PIPELINE_NUM];
+};
+
+struct mtk_raw_stagger_select {
+	int stagger_path;
+	int enabled_raw;
+};
+
+static inline struct mtk_raw_pipeline*
+mtk_cam_ctrl_handler_to_raw_pipeline(struct v4l2_ctrl_handler *handler)
+{
+	return container_of(handler, struct mtk_raw_pipeline, ctrl_handler);
+};
+
+int mtk_raw_setup_dependencies(struct mtk_raw *raw);
+
+int mtk_raw_register_entities(struct mtk_raw *raw,
+			      struct v4l2_device *v4l2_dev);
+void mtk_raw_unregister_entities(struct mtk_raw *raw);
+
+int mtk_cam_raw_select(struct mtk_cam_ctx *ctx,
+		       struct mtkcam_ipi_input_param *cfg_in_param);
+
+int mtk_cam_get_subsample_ratio(int raw_feature);
+
+void subsample_enable(struct mtk_raw_device *dev);
+
+void stagger_enable(struct mtk_raw_device *dev);
+
+void stagger_disable(struct mtk_raw_device *dev);
+
+void toggle_db(struct mtk_raw_device *dev);
+
+void enable_tg_db(struct mtk_raw_device *dev, int en);
+
+void initialize(struct mtk_raw_device *dev, int is_sub);
+
+void stream_on(struct mtk_raw_device *dev, int on);
+
+void immediate_stream_off(struct mtk_raw_device *dev);
+
+void apply_cq(struct mtk_raw_device *dev,
+	      int initial, dma_addr_t cq_addr,
+	      unsigned int cq_size, unsigned int cq_offset,
+	      unsigned int sub_cq_size, unsigned int sub_cq_offset);
+
+void trigger_rawi(struct mtk_raw_device *dev, struct mtk_cam_ctx *ctx,
+		signed int hw_scene);
+
+void reset(struct mtk_raw_device *dev);
+
+void dump_aa_info(struct mtk_cam_ctx *ctx,
+				 struct mtk_ae_debug_data *ae_info);
+
+int mtk_raw_call_pending_set_fmt(struct v4l2_subdev *sd,
+				 struct v4l2_subdev_format *fmt);
+
+struct v4l2_subdev *mtk_cam_find_sensor(struct mtk_cam_ctx *ctx,
+					struct media_entity *entity);
+
+void mtk_cam_update_sensor(struct mtk_cam_ctx *ctx,
+			   struct v4l2_subdev *sensor);
+
+struct mtk_raw_pipeline*
+	mtk_cam_get_link_enabled_raw(struct v4l2_subdev *seninf);
+
+bool
+mtk_raw_fmt_get_res(struct v4l2_subdev *sd, struct v4l2_subdev_format *fmt,
+		    struct mtk_cam_resource *res);
+
+unsigned int mtk_raw_get_hdr_scen_id(struct mtk_cam_ctx *ctx);
+
+struct v4l2_mbus_framefmt*
+mtk_raw_pipeline_get_fmt(struct mtk_raw_pipeline *pipe,
+			struct v4l2_subdev_state *sd_state,
+			int padid, int which);
+struct v4l2_rect*
+mtk_raw_pipeline_get_selection(struct mtk_raw_pipeline *pipe,
+			struct v4l2_subdev_state *sd_state,
+			int pad, int which);
+int
+mtk_cam_raw_try_res_ctrl(struct mtk_raw_pipeline *pipeline,
+			struct mtk_cam_resource *res_user,
+			struct mtk_cam_resource_config *res_cfg,
+			struct v4l2_mbus_framefmt *sink_fmt);
+int
+mtk_cam_res_copy_fmt_from_user(struct mtk_raw_pipeline *pipeline,
+			struct mtk_cam_resource *res_user,
+			struct v4l2_mbus_framefmt *dest);
+int
+mtk_cam_res_copy_fmt_to_user(struct mtk_raw_pipeline *pipeline,
+			struct mtk_cam_resource *res_user,
+			struct v4l2_mbus_framefmt *src);
+extern struct platform_driver mtk_cam_raw_driver;
+extern struct platform_driver mtk_cam_yuv_driver;
+
+static inline u32 dmaaddr_lsb(dma_addr_t addr)
+{
+	return addr & (BIT_MASK(32) - 1UL);
+}
+
+static inline u32 dmaaddr_msb(dma_addr_t addr)
+{
+	return addr >> 32;
+}
+
+#endif /*__MTK_CAM_RAW_H*/
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam-raw_debug.c b/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam-raw_debug.c
new file mode 100644
index 0000000000000000000000000000000000000000..2359c28c9eccd4b905feb0125d2f6d0c585bc505
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam-raw_debug.c
@@ -0,0 +1,418 @@
+// SPDX-License-Identifier: GPL-2.0
+//
+// Copyright (c) 2022 MediaTek Inc.
+
+#include <linux/device.h>
+#include <linux/io.h>
+
+#ifdef ISP7_1
+#include "mtk_cam-regs-mt8188.h"
+#else
+#include "mtk_cam-regs-mt8195.h"
+#endif
+
+#include "mtk_cam-raw_debug.h"
+
+#define ADD_FBC_DMA(name)	 #name
+static const char * const fbc_r1_list[] = {
+	ADD_FBC_DMA(IMGO_R1),
+	ADD_FBC_DMA(FHO_R1),
+	ADD_FBC_DMA(AAHO_R1),
+	ADD_FBC_DMA(PDO_R1),
+	ADD_FBC_DMA(AAO_R1),
+	ADD_FBC_DMA(TSFSO_R1),
+	ADD_FBC_DMA(LTMSO_R1),
+	ADD_FBC_DMA(AFO_R1),
+	ADD_FBC_DMA(FLKO_R1),
+	ADD_FBC_DMA(UFEO_R1),
+	ADD_FBC_DMA(TSFSO_R2),
+};
+
+static const char * const fbc_r2_list[] = {
+	ADD_FBC_DMA(YUVO_R1),
+	ADD_FBC_DMA(YUVBO_R1),
+	ADD_FBC_DMA(YUVCO_R1),
+	ADD_FBC_DMA(YUVDO_R1),
+	ADD_FBC_DMA(YUVO_R3),
+	ADD_FBC_DMA(YUVBO_R3),
+	ADD_FBC_DMA(YUVCO_R3),
+	ADD_FBC_DMA(YUVDO_R3),
+	ADD_FBC_DMA(YUVO_R2),
+	ADD_FBC_DMA(YUVBO_R2),
+	ADD_FBC_DMA(YUVO_R4),
+	ADD_FBC_DMA(YUVBO_R4),
+	ADD_FBC_DMA(RZH1N2TO_R1),
+	ADD_FBC_DMA(RZH1N2TBO_R1),
+	ADD_FBC_DMA(RZH1N2TO_R2),
+	ADD_FBC_DMA(RZH1N2TO_R3),
+	ADD_FBC_DMA(RZH1N2TBO_R3),
+	ADD_FBC_DMA(DRZS4NO_R1),
+	ADD_FBC_DMA(DRZS4NO_R2),
+	ADD_FBC_DMA(DRZS4NO_R3),
+	ADD_FBC_DMA(TNCSO_R1),
+	ADD_FBC_DMA(TNCSYO_R1),
+	ADD_FBC_DMA(TNCSBO_R1),
+	ADD_FBC_DMA(TNCSHO_R1),
+	ADD_FBC_DMA(ACTSO_R1),
+	ADD_FBC_DMA(YUVO_R5),
+	ADD_FBC_DMA(YUVBO_R5),
+};
+
+#define LOGGER_PREFIX_SIZE 16
+#define LOGGER_BUFSIZE 128
+struct buffered_logger {
+	struct device *dev;
+	void (*log_handler)(struct buffered_logger *log);
+
+	char prefix[LOGGER_PREFIX_SIZE];
+	char buf[LOGGER_BUFSIZE + 1];
+	int size;
+};
+
+#define _INIT_LOGGER(logger, _dev, _hdl)	\
+({						\
+	(logger)->dev = _dev;			\
+	(logger)->log_handler = _hdl;		\
+	(logger)->prefix[0] = '\0';		\
+	(logger)->buf[LOGGER_BUFSIZE] = '\0';	\
+	(logger)->size = 0;			\
+})
+
+#define INIT_LOGGER_ALWAYS(logger, dev)		\
+	_INIT_LOGGER(logger, dev, mtk_cam_log_handle_info)
+#define INIT_LOGGER_LIMITED(logger, dev)	\
+	_INIT_LOGGER(logger, dev, mtk_cam_log_handle_limited)
+
+static __printf(2, 3)
+void mtk_cam_log_set_prefix(struct buffered_logger *log, const char *fmt, ...)
+{
+	va_list args;
+
+	va_start(args, fmt);
+	vscnprintf(log->prefix, LOGGER_PREFIX_SIZE, fmt, args);
+	va_end(args);
+}
+
+static void mtk_cam_log_handle_limited(struct buffered_logger *log)
+{
+	dev_info_ratelimited(log->dev, "%s: %.*s\n",
+			     log->prefix, log->size, log->buf);
+	log->size = 0;
+}
+
+static void mtk_cam_log_handle_info(struct buffered_logger *log)
+{
+	dev_info(log->dev, "%s: %.*s\n",
+		 log->prefix, log->size, log->buf);
+	log->size = 0;
+}
+
+static void mtk_cam_log_flush(struct buffered_logger *log)
+{
+	log->log_handler(log);
+}
+
+static __printf(2, 3)
+void mtk_cam_log_push(struct buffered_logger *log, const char *fmt, ...)
+{
+	va_list args;
+	int len;
+
+	va_start(args, fmt);
+	len = vscnprintf(log->buf + log->size, LOGGER_BUFSIZE - log->size + 1,
+			 fmt, args);
+	va_end(args);
+
+	if (len + log->size < LOGGER_BUFSIZE) {
+		log->size += len;
+		return;
+	}
+
+	mtk_cam_log_flush(log);
+
+	va_start(args, fmt);
+	len = vscnprintf(log->buf + log->size, LOGGER_BUFSIZE - log->size + 1,
+			 fmt, args);
+	va_end(args);
+
+	log->size += len;
+
+	if (len == LOGGER_BUFSIZE)
+		dev_info(log->dev, "log buffer size not enough: %d\n",
+			 LOGGER_BUFSIZE);
+}
+
+void mtk_cam_raw_dump_fbc(struct device *dev,
+			  void __iomem *base, void __iomem *yuvbase)
+{
+	struct buffered_logger log;
+	int fbc_r1_ctl2[ARRAY_SIZE(fbc_r1_list)];
+	int fbc_r2_ctl2[ARRAY_SIZE(fbc_r2_list)];
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(fbc_r1_list); i++)
+		fbc_r1_ctl2[i] = readl(base + REG_FBC_CTL2(FBC_R1A_BASE, i));
+
+	for (i = 0; i < ARRAY_SIZE(fbc_r2_list); i++)
+		fbc_r2_ctl2[i] = readl(yuvbase + REG_FBC_CTL2(FBC_R2A_BASE, i));
+
+	INIT_LOGGER_ALWAYS(&log, dev);
+
+	mtk_cam_log_set_prefix(&log, "%s", "RAW FBC");
+	for (i = 0; i < ARRAY_SIZE(fbc_r1_list); i++)
+		if (fbc_r1_ctl2[i] & 0xffffff) /* if has been used */
+			mtk_cam_log_push(&log, " %s: 0x%08x",
+					 fbc_r1_list[i], fbc_r1_ctl2[i]);
+	mtk_cam_log_flush(&log);
+
+	mtk_cam_log_set_prefix(&log, "%s", "YUV FBC");
+	for (i = 0; i < ARRAY_SIZE(fbc_r2_list); i++)
+		if (fbc_r2_ctl2[i] & 0xffffff) /* if has been used */
+			mtk_cam_log_push(&log, " %s: 0x%08x",
+					 fbc_r2_list[i], fbc_r2_ctl2[i]);
+	mtk_cam_log_flush(&log);
+}
+
+struct reg_to_dump {
+	const char *name;
+	unsigned int reg;
+};
+
+#define ADD_DMA(name)	{ #name, REG_ ## name ## _BASE + DMA_OFFSET_ERR_STAT }
+static const struct reg_to_dump raw_dma_list[] = {
+	ADD_DMA(IMGO_R1),
+	ADD_DMA(IMGO_R1),
+	ADD_DMA(UFEO_R1),
+	ADD_DMA(PDO_R1),
+	ADD_DMA(FLKO_R1),
+	ADD_DMA(TSFSO_R1),
+	ADD_DMA(TSFSO_R2),
+	ADD_DMA(AAO_R1),
+	ADD_DMA(AAHO_R1),
+	ADD_DMA(AFO_R1),
+	ADD_DMA(LTMSO_R1),
+	ADD_DMA(FHO_R1),
+	/* ADD_DMA(BPCO_R1), */
+
+	ADD_DMA(RAWI_R2),
+	ADD_DMA(UFDI_R2),
+	ADD_DMA(BPCI_R1),
+	ADD_DMA(LSCI_R1),
+	ADD_DMA(AAI_R1),
+	ADD_DMA(PDI_R1),
+	ADD_DMA(BPCI_R2),
+	ADD_DMA(RAWI_R3),
+	ADD_DMA(UFDI_R3),
+	ADD_DMA(BPCI_R3),
+	/* ADD_DMA(RAWI_R4), */
+	/* ADD_DMA(BPCI_R4), */
+	/* ADD_DMA(RAWI_R5), */
+	ADD_DMA(RAWI_R6),
+	ADD_DMA(CACI_R1),
+};
+
+static const struct reg_to_dump yuv_dma_list[] = {
+	ADD_DMA(ACTSO_R1),
+	ADD_DMA(TNCSO_R1),
+	ADD_DMA(TNCSBO_R1),
+	ADD_DMA(TNCSHO_R1),
+	ADD_DMA(TNCSYO_R1),
+	ADD_DMA(DRZS4NO_R1),
+	ADD_DMA(DRZS4NO_R2),
+	ADD_DMA(DRZS4NO_R3),
+	ADD_DMA(RZH1N2TO_R1),
+	ADD_DMA(RZH1N2TBO_R1),
+	ADD_DMA(RZH1N2TO_R2),
+	ADD_DMA(RZH1N2TO_R3),
+	ADD_DMA(RZH1N2TBO_R3),
+	ADD_DMA(YUVO_R1),
+	ADD_DMA(YUVBO_R1),
+	ADD_DMA(YUVCO_R1),
+	ADD_DMA(YUVDO_R1),
+	ADD_DMA(YUVO_R2),
+	ADD_DMA(YUVBO_R2),
+	ADD_DMA(YUVO_R3),
+	ADD_DMA(YUVBO_R3),
+	ADD_DMA(YUVCO_R3),
+	ADD_DMA(YUVDO_R3),
+	ADD_DMA(YUVO_R4),
+	ADD_DMA(YUVBO_R4),
+	ADD_DMA(YUVO_R5),
+	ADD_DMA(YUVBO_R5),
+};
+
+static void mtk_cam_dump_dma_err_st(struct device *dev, void __iomem *base,
+				    const char *prefix,
+				    const struct reg_to_dump *from,
+				    const struct reg_to_dump *to)
+{
+	struct buffered_logger log;
+	int err_found = 0;
+	int err_st;
+
+	INIT_LOGGER_LIMITED(&log, dev);
+	mtk_cam_log_set_prefix(&log, "%s", prefix);
+
+	while (from < to) {
+		err_st = readl_relaxed(base + from->reg);
+
+		/* [15:0] ERR_STAT */
+		if (err_st & 0xffff) {
+			mtk_cam_log_push(&log, " %s: 0x%08x",
+					 from->name, err_st);
+			err_found = 1;
+		}
+		from++;
+	}
+
+	if (err_found)
+		mtk_cam_log_flush(&log);
+}
+
+void mtk_cam_raw_dump_dma_err_st(struct device *dev, void __iomem *base)
+{
+	mtk_cam_dump_dma_err_st(dev, base, "RAW DMA_ERR",
+				raw_dma_list,
+				raw_dma_list + ARRAY_SIZE(raw_dma_list));
+}
+
+void mtk_cam_yuv_dump_dma_err_st(struct device *dev, void __iomem *base)
+{
+	mtk_cam_dump_dma_err_st(dev, base, "YUV DMA_ERR",
+				yuv_dma_list,
+				yuv_dma_list + ARRAY_SIZE(yuv_dma_list));
+}
+
+void mtk_cam_dump_req_rdy_status(struct device *dev,
+				 void __iomem *base, void __iomem *yuvbase)
+{
+	dev_dbg_ratelimited(dev,
+			    "REQ RAW/2/3 DMA/2:%08x/%08x/%08x/%08x/%08x\n",
+			    readl_relaxed(base + REG_CTL_RAW_MOD_REQ_STAT),
+			    readl_relaxed(base + REG_CTL_RAW_MOD2_REQ_STAT),
+			    readl_relaxed(base + REG_CTL_RAW_MOD3_REQ_STAT),
+			    readl_relaxed(base + REG_CTL_RAW_MOD5_REQ_STAT),
+			    readl_relaxed(base + REG_CTL_RAW_MOD6_REQ_STAT));
+	dev_dbg_ratelimited(dev,
+			    "RDY RAW/2/3 DMA/2:%08x/%08x/%08x/%08x/%08x\n",
+			    readl_relaxed(base + REG_CTL_RAW_MOD_RDY_STAT),
+			    readl_relaxed(base + REG_CTL_RAW_MOD2_RDY_STAT),
+			    readl_relaxed(base + REG_CTL_RAW_MOD3_RDY_STAT),
+			    readl_relaxed(base + REG_CTL_RAW_MOD5_RDY_STAT),
+			    readl_relaxed(base + REG_CTL_RAW_MOD6_RDY_STAT));
+	dev_dbg_ratelimited(dev,
+			    "REQ YUV/2/3/4 WDMA:%08x/%08x/%08x/%08x/%08x\n",
+			    readl_relaxed(yuvbase + REG_CTL_RAW_MOD_REQ_STAT),
+			    readl_relaxed(yuvbase + REG_CTL_RAW_MOD2_REQ_STAT),
+			    readl_relaxed(yuvbase + REG_CTL_RAW_MOD3_REQ_STAT),
+			    readl_relaxed(yuvbase + REG_CTL_RAW_MOD4_REQ_STAT),
+			    readl_relaxed(yuvbase + REG_CTL_RAW_MOD5_REQ_STAT));
+	dev_dbg_ratelimited(dev,
+			    "RDY YUV/2/3/4 WDMA:%08x/%08x/%08x/%08x/%08x\n",
+			    readl_relaxed(yuvbase + REG_CTL_RAW_MOD_RDY_STAT),
+			    readl_relaxed(yuvbase + REG_CTL_RAW_MOD2_RDY_STAT),
+			    readl_relaxed(yuvbase + REG_CTL_RAW_MOD3_RDY_STAT),
+			    readl_relaxed(yuvbase + REG_CTL_RAW_MOD4_RDY_STAT),
+			    readl_relaxed(yuvbase + REG_CTL_RAW_MOD5_RDY_STAT));
+}
+
+void mtk_cam_dump_dma_debug(struct device *dev,
+			    void __iomem *dmatop_base,
+			    const char *dma_name,
+			    struct dma_debug_item *items, int n)
+{
+	void __iomem *dbg_sel = dmatop_base + 0x70;
+	void __iomem *dbg_port = dmatop_base + 0x74;
+	int i = 0;
+	unsigned int vals[16];
+
+	if (n >= 16) {
+		dev_dbg(dev, "%s: should enlarge array size for n(%d)\n",
+			__func__, n);
+		return;
+	}
+
+	for (i = 0; i < n; i++) {
+		writel(items[i].debug_sel, dbg_sel);
+		if (readl(dbg_sel) != items[i].debug_sel)
+			dev_dbg(dev, "failed to write dbg_sel %08x\n",
+				items[i].debug_sel);
+
+		vals[i] = readl(dbg_port);
+	};
+
+	dev_dbg(dev, "%s: %s, n = %d", __func__, dma_name, n);
+	for (i = 0; i < n; i++)
+		dev_dbg(dev, "%08x: %08x [%s]\n",
+			items[i].debug_sel, vals[i], items[i].msg);
+}
+
+void mtk_cam_set_topdebug_rdyreq(struct device *dev,
+				 void __iomem *base, void __iomem *yuvbase,
+				 u32 event)
+{
+	u32 val = event << 16 | 0xa << 12;
+
+#ifdef ISP7_1
+	writel(val, base + REG_CTL_DBG_SET);
+	writel(event, base + REG_CTL_DBG_SET2);
+	writel(val, yuvbase + REG_CTL_DBG_SET);
+	dev_info(dev,
+		 "set CAMCTL_DBG_SET2/CAMCTL_DBG_SET (RAW/YUV) 0x%08x/0x%08x\n",
+		 event, val);
+#else
+	writel(val, base + REG_CTL_DBG_SET);
+	writel(val, yuvbase + REG_CTL_DBG_SET);
+	dev_info(dev, "set CAMCTL_DBG_SET (RAW) 0x%08x\n", val);
+#endif
+}
+
+void mtk_cam_dump_topdebug_rdyreq(struct device *dev,
+				  void __iomem *base, void __iomem *yuvbase)
+{
+	static const u32 debug_sel[] = {
+		/* req group 1~7 */
+		0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6,
+		/* rdy group 1~7 */
+		0x8, 0x9, 0xA, 0xB, 0xC, 0xD, 0xE,
+		/* latched_events */
+		0xF,
+	};
+	void __iomem *dbg_set;
+	void __iomem *dbg_port;
+	u32 set;
+	int i;
+
+	/* CAMCTL_DBG_SET
+	 *   CAMCTL_SNAPSHOT_SEL  [23:16]
+	 *   CAMCTL_DEBUG_TOP_SEL [15:12]
+	 *   CAMCTL_DEBUG_SEL     [11: 8]
+	 *   CAMCTL_DEBUG_MOD_SEL [ 7: 0]
+	 */
+
+	/* CAMCTL_DEBUG_MOD_SEL
+	 *   0: tg_scq_cnt_sub_pass1_done
+	 *   1: rdyreq_dbg_data
+	 */
+
+	dbg_set = base + REG_CTL_DBG_SET;
+	dbg_port = base + REG_CTL_DBG_PORT;
+
+	set = (readl(dbg_set) & 0xfff000) | 0x1;
+	for (i = 0; i < ARRAY_SIZE(debug_sel); i++) {
+		writel(set | debug_sel[i] << 8, dbg_set);
+		dev_info(dev, "RAW debug_set 0x%08x port 0x%08x\n",
+			 readl(dbg_set), readl(dbg_port));
+	}
+
+	dbg_set = yuvbase + REG_CTL_DBG_SET;
+	dbg_port = yuvbase + REG_CTL_DBG_PORT;
+
+	set = (readl(dbg_set) & 0xfff000) | 0x1;
+	for (i = 0; i < ARRAY_SIZE(debug_sel); i++) {
+		writel(set | debug_sel[i] << 8, dbg_set);
+		dev_info(dev, "YUV debug_set 0x%08x port 0x%08x\n",
+			 readl(dbg_set), readl(dbg_port));
+	}
+}
+
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam-raw_debug.h b/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam-raw_debug.h
new file mode 100644
index 0000000000000000000000000000000000000000..8d457403a5b03d9e87a1e442e415fa33ce28f988
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam-raw_debug.h
@@ -0,0 +1,39 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2022 MediaTek Inc.
+ */
+
+#ifndef _MTK_CAM_RAW_DEBUG_H
+#define _MTK_CAM_RAW_DEBUG_H
+
+enum topdebug_event {
+	ALL_THE_TIME	= BIT(0),
+	TG_OVERRUN	= BIT(1),
+	CQ_MAIN_VS_ERR	= BIT(2),
+	CQ_SUB_VS_ERR	= BIT(3),
+	RAW_DMA_ERR	= BIT(4),
+	YUV_DMA_ERR	= BIT(5),
+};
+
+struct dma_debug_item {
+	unsigned int	debug_sel;
+	const char	*msg;
+};
+
+void mtk_cam_raw_dump_fbc(struct device *dev,
+			  void __iomem *base, void __iomem *yuvbase);
+void mtk_cam_raw_dump_dma_err_st(struct device *dev, void __iomem *base);
+void mtk_cam_yuv_dump_dma_err_st(struct device *dev, void __iomem *yuvbase);
+void mtk_cam_dump_req_rdy_status(struct device *dev,
+				 void __iomem *base, void __iomem *yuvbase);
+void mtk_cam_dump_dma_debug(struct device *dev,
+			    void __iomem *dmatop_base,
+			    const char *dma_name,
+			    struct dma_debug_item *items, int n);
+void mtk_cam_set_topdebug_rdyreq(struct device *dev,
+				 void __iomem *base, void __iomem *yuvbase,
+				 u32 event);
+void mtk_cam_dump_topdebug_rdyreq(struct device *dev,
+				  void __iomem *base, void __iomem *yuvbase);
+
+#endif	/* _MTK_CAM_RAW_DEBUG_H */
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam-regs-mt8188.h b/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam-regs-mt8188.h
new file mode 100644
index 0000000000000000000000000000000000000000..517a7aa4e8c474ab144d2613b72a2ae070c6788e
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam-regs-mt8188.h
@@ -0,0 +1,390 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2022 MediaTek Inc.
+ */
+
+#ifndef _CAM_REGS_H
+#define _CAM_REGS_H
+
+/* Raw Part */
+
+/* normal siganl */
+#define VS_INT_ST							(1L << 0)
+#define TG_INT1_ST							(1L << 1)
+#define TG_INT2_ST							(1L << 2)
+#define EXPDON_ST							(1L << 5)
+#define SOF_INT_ST							(1L << 8)
+#define HW_PASS1_DON_ST						(1L << 20)
+#define SW_PASS1_DON_ST						(1L << 22)
+#define TG_VS_INT_ORG_ST					(1L << 11)
+
+/* YUV siganl */
+#define YUV_SW_PASS1_DON_ST					(1L << 0)
+#define YUV_PASS1_DON_ST					(1L << 1)
+#define YUV_DMA_ERR_ST						(1L << 2)
+
+/* err status */
+#define TG_OVRUN_ST							(1L << 6)
+#define TG_GBERR_ST							(1L << 7)
+#define CQ_DB_LOAD_ERR_ST					(1L << 12)
+#define CQ_MAIN_CODE_ERR_ST					(1L << 14)
+#define CQ_MAIN_VS_ERR_ST					(1L << 15)
+#define CQ_MAIN_TRIG_DLY_ST					(1L << 16)
+#define LSCI_ERR_ST							(1L << 24)
+#define DMA_ERR_ST							(1L << 26)
+
+/* CAM DMA done status */
+#define IMGO_DONE_ST						(1L << 0)
+#define AFO_DONE_ST							(1L << 8)
+#define CQI_R1_DONE_ST						(1L << 15)
+
+/* RAW input trigger ctrl*/
+#define RAWI_R2_TRIG						(1L << 0)
+#define RAWI_R3_TRIG						(1L << 1)
+#define RAWI_R4_TRIG						(1L << 2)
+#define RAWI_R5_TRIG						(1L << 3)
+#define RAWI_R6_TRIG						(1L << 4)
+
+
+/* IRQ signal mask */
+#define INT_ST_MASK_CAM (VS_INT_ST	 |\
+						TG_INT1_ST	 |\
+						TG_INT2_ST	 |\
+						EXPDON_ST       |\
+						HW_PASS1_DON_ST |\
+						SOF_INT_ST      |\
+						SW_PASS1_DON_ST)
+
+/* IRQ Error Mask */
+#define INT_ST_MASK_CAM_ERR (TG_OVRUN_ST	 |\
+							TG_GBERR_ST	 |\
+							CQ_DB_LOAD_ERR_ST	 |\
+							CQ_MAIN_CODE_ERR_ST |\
+							CQ_MAIN_VS_ERR_ST	 |\
+							DMA_ERR_ST)
+
+/* camsys */
+#define REG_CAMSYS_CG_SET					0x0004
+#define REG_CAMSYS_CG_CLR					0x0008
+
+#define REG_HALT1_EN						0x0350
+#define REG_HALT2_EN						0x0354
+#define REG_HALT3_EN						0x0358
+#define REG_HALT4_EN						0x035c
+#define REG_HALT5_EN						0x0360
+#define REG_HALT6_EN						0x0364
+#define REG_FLASH							0x03A0
+#define REG_ULTRA_HALT1_EN					0x03c0
+#define REG_ULTRA_HALT2_EN					0x03c4
+#define REG_ULTRA_HALT3_EN					0x03c8
+#define REG_ULTRA_HALT4_EN					0x03cc
+#define REG_ULTRA_HALT5_EN					0x03d0
+#define REG_ULTRA_HALT6_EN					0x03d4
+#define REG_PREULTRA_HALT1_EN				0x03f0
+#define REG_PREULTRA_HALT2_EN				0x03f4
+#define REG_PREULTRA_HALT3_EN				0x03f8
+#define REG_PREULTRA_HALT4_EN				0x03fc
+#define REG_PREULTRA_HALT5_EN				0x0400
+#define REG_PREULTRA_HALT6_EN				0x0404
+
+/* Status check */
+#define REG_CTL_EN							0x0000
+#define REG_CTL_EN2							0x0004
+
+
+/* DMA Enable Register, DMA_EN */
+#define REG_CTL_MOD5_EN						0x0010
+#define REG_CTL_MOD6_EN						0x0014
+/* RAW input trigger*/
+#define REG_CTL_RAWI_TRIG					0x00C0
+
+#define REG_CTL_MISC						0x0060
+#define CTL_DB_EN							BIT(4)
+
+
+#define REG_CTL_SW_CTL						0x00C4
+#define REG_CTL_START						0x00B0
+
+#define REG_CTL_RAW_INT_EN					0x0100
+#define REG_CTL_RAW_INT_STAT				0x0104
+#define REG_CTL_RAW_INT2_EN					0x0110
+#define REG_CTL_RAW_INT2_STAT				0x0114
+#define REG_CTL_RAW_INT3_STAT				0x0124
+#define REG_CTL_RAW_INT4_STAT				0x0134
+#define REG_CTL_RAW_INT5_STAT				0x0144
+#define REG_CTL_RAW_INT6_EN					0x0150
+#define REG_CTL_RAW_INT6_STAT				0x0154
+#define REG_CTL_RAW_INT7_EN					0x0160
+#define REG_CTL_RAW_INT7_STAT				0x0164
+
+#define REG_CTL_RAW_MOD_DCM_DIS				0x0300
+#define REG_CTL_RAW_MOD2_DCM_DIS			0x0304
+#define REG_CTL_RAW_MOD3_DCM_DIS			0x0308
+#define REG_CTL_RAW_MOD5_DCM_DIS			0x0310
+#define REG_CTL_RAW_MOD6_DCM_DIS			0x0314
+
+#define REG_CTL_DBG_SET						0x00F0
+#define REG_CTL_DBG_PORT					0x00F4
+#define REG_DMA_DBG_SEL						0x4070
+#define REG_DMA_DBG_PORT					0x4074
+#ifdef ISP7_1
+#define REG_CTL_DBG_SET2					0x00F8
+#endif
+
+#define REG_CTL_RAW_MOD_REQ_STAT			0x0340
+#define REG_CTL_RAW_MOD2_REQ_STAT			0x0344
+#define REG_CTL_RAW_MOD3_REQ_STAT			0x0348
+#define REG_CTL_RAW_MOD4_REQ_STAT			0x034c /* CAMCTL2 */
+#define REG_CTL_RAW_MOD5_REQ_STAT			0x0350
+#define REG_CTL_RAW_MOD6_REQ_STAT			0x0354
+
+#define REG_CTL_RAW_MOD_RDY_STAT			0x0360
+#define REG_CTL_RAW_MOD2_RDY_STAT			0x0364
+#define REG_CTL_RAW_MOD3_RDY_STAT			0x0368
+#define REG_CTL_RAW_MOD4_RDY_STAT			0x036c /* CAMCTL2 */
+#define REG_CTL_RAW_MOD5_RDY_STAT			0x0370
+#define REG_CTL_RAW_MOD6_RDY_STAT			0x0374
+
+#define REG_CQ_EN							0x0400
+#define REG_SCQ_START_PERIOD				0x0408
+#define REG_CQ_THR0_CTL						0x0410
+#define REG_CQ_SUB_CQ_EN					0x06B0
+#define REG_CQ_SUB_THR0_CTL					0x06C0
+
+#define REG_CTL_SW_PASS1_DONE				0x00c8
+#define SW_DONE_SAMPLE_EN					BIT(8)
+#define REG_CTL_SW_SUB_CTL					0x00cc
+
+#define REG_CQ_THR0_BASEADDR				0x0414
+#define REG_CQ_THR0_BASEADDR_MSB			0x0418
+#define REG_CQ_THR0_DESC_SIZE				0x041C
+#define REG_SCQ_CQ_TRIG_TIME				0x0410
+#define REG_CQ_SUB_THR0_BASEADDR_2			0x06CC
+#define REG_CQ_SUB_THR0_BASEADDR_MSB_2		0x06D0
+#define REG_CQ_SUB_THR0_DESC_SIZE_2			0x06D8
+#define REG_CQ_SUB_THR0_BASEADDR_1			0x06C4
+#define REG_CQ_SUB_THR0_BASEADDR_MSB_1		0x06C8
+#define REG_CQ_SUB_THR0_DESC_SIZE_1			0x06D4
+#define SCQ_EN								BIT(20)
+#define SCQ_STAGGER_MODE					BIT(12)
+#define SCQ_SUBSAMPLE_EN					BIT(21)
+#define CQ_DB_EN							BIT(4)
+#define CQ_THR0_MODE_IMMEDIATE				BIT(4)
+#define CQ_THR0_MODE_CONTINUOUS				BIT(5)
+#define CQ_THR0_EN							BIT(0)
+#define SCQ_SUB_RESET						BIT(16)
+
+#define REG_TG_SEN_MODE						0x0700
+#define TG_CMOS_RDY_SEL						BIT(14)
+#define TG_SEN_MODE_CMOS_EN					BIT(0)
+#define TG_VFDATA_EN						BIT(0)
+#define TG_TG_FULL_SEL						BIT(15)
+#define TG_STAGGER_EN						BIT(22)
+
+#define REG_TG_VF_CON						0x0704
+#define REG_TG_SEN_GRAB_PXL					0x0708
+#define REG_TG_SEN_GRAB_LIN					0x070C
+#define REG_TG_PATH_CFG						0x0710
+#define TG_DB_LOAD_DIS						BIT(8)
+#define TG_SUB_SOF_SRC_SEL_0				BIT(20)
+#define TG_SUB_SOF_SRC_SEL_1				BIT(21)
+
+#define REG_TG_INTER_ST						0x073C
+/* use this MASK to extract TG_CAM_CS from TG_INTER_ST */
+#define TG_CAM_CS_MASK						0x3f00
+#define TG_IDLE_ST							BIT(8)
+
+
+#define REG_TG_FRMSIZE_ST					0x0738
+#define REG_TG_DCIF_CTL						0x075C
+#define TG_DCIF_EN							BIT(16)
+
+#define REG_TG_FRMSIZE_ST_R					0x076C
+#define REG_TG_TIME_STAMP					0x0778
+#define REG_TG_TIME_STAMP_CNT				0x077C
+
+/* tg flash */
+#define	REG_TG_XENON_FLASH_CTL				0x0780
+#define REG_TG_XENON_FLASH_OFFSET			0x0784
+#define REG_TG_XENON_FLASH_HIGH_WIDTH		0x0788
+#define REG_TG_XENON_FLASH_LOW_WIDTH		0x078C
+#define	REG_TG_IR_FLASH_CTL					0x0798
+#define REG_TG_IR_FLASH_OFFSET				0x079C
+#define REG_TG_IR_FLASH_HIGH_WIDTH			0x07A0
+#define REG_TG_IR_FLASH_LOW_WIDTH			0x07A4
+
+/* for raw & yuv's dma top base */
+#define CAMDMATOP_BASE						0x4000
+
+#define REG_DMA_SOFT_RST_STAT               0x4068
+#ifdef ISP7_1
+#define REG_DMA_SOFT_RST_STAT2              0x406C
+#define REG_DMA_DBG_CHASING_STATUS          0x4098
+#define REG_DMA_DBG_CHASING_STATUS2         0x409c
+#endif
+
+#define RAWI_R2_SMI_REQ_ST					BIT(0)
+#define RAWI_R3_SMI_REQ_ST					BIT(16)
+#define RAWI_R5_SMI_REQ_ST					BIT(16)
+
+#define RST_STAT_RAWI_R2					BIT(0)
+#define RST_STAT_RAWI_R3					BIT(2)
+#define RST_STAT_RAWI_R5					BIT(5)
+/* use spare register FH_SPARE_5 */
+#define REG_FRAME_SEQ_NUM					0x4994
+
+#define REG_CAMCTL_FBC_SEL					0x00A0
+#define REG_CAMCTL_FBC_RCNT_INC				0x00A4
+
+#define CAMCTL_IMGO_R1_RCNT_INC				BIT(0)
+#define CAMCTL_CQ_THR0_DONE_ST				BIT(0)
+#define CTL_CQ_THR0_START					BIT(0)
+
+/* AE debug info */
+/* CAMSYS_RAW 0x1a03 */
+#define OFFSET_OBC_R1_R_SUM_L				0x1178
+#define OFFSET_OBC_R1_R_SUM_H				0x117c
+#define OFFSET_OBC_R1_B_SUM_L				0x1180
+#define OFFSET_OBC_R1_B_SUM_H				0x1184
+#define OFFSET_OBC_R1_GR_SUM_L				0x1188
+#define OFFSET_OBC_R1_GR_SUM_H				0x118c
+#define OFFSET_OBC_R1_GB_SUM_L				0x1190
+#define OFFSET_OBC_R1_GB_SUM_H				0x1194
+#define OFFSET_OBC_R1_ACT_WIN_X				0x1198
+#define OFFSET_OBC_R1_ACT_WIN_Y				0x119c
+
+#define OFFSET_OBC_R2_R_SUM_L				0x1438
+#define OFFSET_OBC_R2_R_SUM_H				0x143c
+#define OFFSET_OBC_R2_B_SUM_L				0x1440
+#define OFFSET_OBC_R2_B_SUM_H				0x1444
+#define OFFSET_OBC_R2_GR_SUM_L				0x1448
+#define OFFSET_OBC_R2_GR_SUM_H				0x144c
+#define OFFSET_OBC_R2_GB_SUM_L				0x1450
+#define OFFSET_OBC_R2_GB_SUM_H				0x1454
+#define OFFSET_OBC_R2_ACT_WIN_X				0x1458
+#define OFFSET_OBC_R2_ACT_WIN_Y				0x145c
+
+#define OFFSET_OBC_R3_R_SUM_L				0x16f8
+#define OFFSET_OBC_R3_R_SUM_H				0x16fc
+#define OFFSET_OBC_R3_B_SUM_L				0x1700
+#define OFFSET_OBC_R3_B_SUM_H				0x1704
+#define OFFSET_OBC_R3_GR_SUM_L				0x1708
+#define OFFSET_OBC_R3_GR_SUM_H				0x170c
+#define OFFSET_OBC_R3_GB_SUM_L				0x1710
+#define OFFSET_OBC_R3_GB_SUM_H				0x1714
+#define OFFSET_OBC_R3_ACT_WIN_X				0x1718
+#define OFFSET_OBC_R3_ACT_WIN_Y				0x171c
+
+#define REG_LTM_AE_DEBUG_B_MSB				0x23f0
+#define REG_LTM_AE_DEBUG_B_LSB				0x23f4
+#define REG_LTM_AE_DEBUG_GB_MSB				0x23f8
+#define REG_LTM_AE_DEBUG_GB_LSB				0x23fc
+#define REG_LTM_AE_DEBUG_GR_MSB				0x2400
+#define REG_LTM_AE_DEBUG_GR_LSB				0x2404
+#define REG_LTM_AE_DEBUG_R_MSB				0x2408
+#define REG_LTM_AE_DEBUG_R_LSB				0x240c
+#define REG_LTMS_ACT_WIN_X					0x2578
+#define REG_LTMS_ACT_WIN_Y					0x257c
+
+#define REG_AA_R_SUM_L						0x2a1c
+#define REG_AA_R_SUM_H						0x2a20
+#define REG_AA_B_SUM_L						0x2a24
+#define REG_AA_B_SUM_H						0x2a28
+#define REG_AA_GR_SUM_L						0x2a2c
+#define REG_AA_GR_SUM_H						0x2a30
+#define REG_AA_GB_SUM_L						0x2a34
+#define REG_AA_GB_SUM_H						0x2a30
+#define REG_AA_ACT_WIN_X					0x2a3c
+#define REG_AA_ACT_WIN_Y					0x2a40
+
+#define DMA_OFFSET_CON0						0x020
+#define DMA_OFFSET_CON1						0x024
+#define DMA_OFFSET_CON2						0x028
+#define DMA_OFFSET_CON3						0x02c
+#define DMA_OFFSET_CON4						0x030
+#define DMA_OFFSET_ERR_STAT					0x034
+
+#define DMA_OFFSET_SPECIAL_DCIF				0x03c
+#define DC_CAMSV_STAGER_EN					BIT(16)
+
+#define FBC_R1A_BASE						0x2c00
+#define FBC_R2A_BASE						0x3780
+#define REG_FBC_CTL1(base, idx)				(base + idx * 8)
+#define REG_FBC_CTL2(base, idx)				(base + idx * 8 + 4)
+#define WCNT_BIT_MASK						0xFF00
+#define CNT_BIT_MASK						0xFF0000
+#define TG_FULLSEL_BIT_MASK					0x8000
+/* ORIDMA */
+/* CAMSYS_RAW 0x1a03 */
+#define REG_IMGO_R1_BASE					0x4880
+#define REG_FHO_R1_BASE						0x4930
+#define REG_AAHO_R1_BASE					0x49e0
+#define REG_PDO_R1_BASE						0x4a90
+#define REG_AAO_R1_BASE						0x4a40
+#define REG_AFO_R1_BASE						0x4bf0
+
+/* CAMSYS_YUV 0x1a05 */
+#define REG_YUVO_R1_BASE					0x4200
+#define REG_YUVBO_R1_BASE					0x42b0
+#define REG_YUVCO_R1_BASE					0x4360
+#define REG_YUVDO_R1_BASE					0x4410
+#define REG_YUVO_R3_BASE					0x44c0
+#define REG_YUVBO_R3_BASE					0x4570
+#define REG_YUVCO_R3_BASE					0x4620
+#define REG_YUVDO_R3_BASE					0x46D0
+
+/* ULCDMA */
+/* CAMSYS_RAW 0x1603 */
+#define REG_LTMSO_R1_BASE					0x4ce0
+#define REG_TSFSO_R1_BASE					0x4ca0
+#define REG_TSFSO_R2_BASE					0x4de0
+#define REG_FLKO_R1_BASE					0x4d20
+#define REG_UFEO_R1_BASE					0x4d60
+
+/* CAMSYS_YUV 0x1605 */
+#define REG_YUVO_R2_BASE					0x4780
+#define REG_YUVBO_R2_BASE					0x47c0
+#define REG_YUVO_R4_BASE					0x4800
+#define REG_YUVBO_R4_BASE					0x4840
+#define REG_YUVO_R5_BASE					0x4c00
+#define REG_YUVBO_R5_BASE					0x4c40
+#define REG_RZH1N2TO_R1_BASE				0x4880
+#define REG_RZH1N2TBO_R1_BASE				0x48c0
+#define REG_RZH1N2TO_R2_BASE				0x4900
+#define REG_RZH1N2TO_R3_BASE				0x4940
+#define REG_RZH1N2TBO_R3_BASE				0x4980
+#define REG_DRZS4NO_R1_BASE					0x49c0
+#define REG_DRZS4NO_R2_BASE					0x4a00
+#define REG_DRZS4NO_R3_BASE					0x4a40
+#define REG_ACTSO_R1_BASE					0x4ac0
+#define REG_TNCSO_R1_BASE					0x4b00
+#define REG_TNCSBO_R1_BASE					0x4b40
+#define REG_TNCSHO_R1_BASE					0x4b80
+#define REG_TNCSYO_R1_BASE					0x4bc0
+
+/* CAMSYS_RAW 0x1a03 */
+#define REG_RAWI_R2_BASE					0x4100
+#define REG_RAWI_R2_BASE_MSB				0x4104
+#define REG_UFDI_R2_BASE					0x4170
+#define REG_RAWI_R3_BASE					0x41e0
+#define REG_RAWI_R3_BASE_MSB				0x41e4
+#define REG_UFDI_R3_BASE					0x4250
+#define REG_CQI_R1_BASE						0x4410
+#define REG_CQI_R1_BASE_MSB					0x4414
+#define REG_CQI_R2_BASE						0x4480
+#define REG_CQI_R2_BASE_MSB					0x4484
+#define REG_CQI_R3_BASE						0x44f0
+#define REG_CQI_R3_BASE_MSB					0x44f4
+#define REG_CQI_R4_BASE						0x4560
+#define REG_CQI_R4_BASE_MSB					0x4564
+#define REG_LSCI_R1_BASE					0x45d0
+#define REG_BPCI_R1_BASE					0x4640
+#define REG_BPCI_R2_BASE					0x4680
+#define REG_BPCI_R3_BASE					0x46c0
+#define REG_PDI_R1_BASE						0x4700
+#define REG_AAI_R1_BASE						0x4780
+#define REG_CACI_R1_BASE					0x47c0
+#define REG_RAWI_R5_BASE					0x4330
+#define REG_RAWI_R6_BASE					0x4800
+
+#endif	/* _CAM_REGS_H */
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam-regs-mt8195.h b/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam-regs-mt8195.h
new file mode 100644
index 0000000000000000000000000000000000000000..cce6f983a12e6f19e1f63e87c14f970c41fec696
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam-regs-mt8195.h
@@ -0,0 +1,369 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2022 MediaTek Inc.
+ */
+
+#ifndef _CAM_REGS_H
+#define _CAM_REGS_H
+
+/* Raw Part */
+
+/* normal siganl */
+#define VS_INT_ST							(1L << 0)
+#define TG_INT1_ST							(1L << 1)
+#define TG_INT2_ST							(1L << 2)
+#define EXPDON_ST							(1L << 5)
+#define SOF_INT_ST							(1L << 8)
+#define HW_PASS1_DON_ST						(1L << 20)
+#define SW_PASS1_DON_ST						(1L << 22)
+#define TG_VS_INT_ORG_ST					(1L << 11)
+
+/* YUV siganl */
+#define YUV_SW_PASS1_DON_ST					(1L << 0)
+#define YUV_PASS1_DON_ST					(1L << 1)
+#define YUV_DMA_ERR_ST						(1L << 2)
+
+/* err status */
+#define TG_OVRUN_ST							(1L << 6)
+#define TG_GBERR_ST							(1L << 7)
+#define CQ_DB_LOAD_ERR_ST					(1L << 12)
+#define CQ_MAIN_CODE_ERR_ST					(1L << 14)
+#define CQ_MAIN_VS_ERR_ST					(1L << 15)
+#define CQ_MAIN_TRIG_DLY_ST					(1L << 16)
+#define LSCI_ERR_ST							(1L << 24)
+#define DMA_ERR_ST							(1L << 26)
+
+/* CAM DMA done status */
+#define IMGO_DONE_ST						(1L << 0)
+#define AFO_DONE_ST							(1L << 8)
+#define CQI_R1_DONE_ST						(1L << 15)
+
+/* RAW input trigger ctrl*/
+#define RAWI_R2_TRIG						(1L << 0)
+#define RAWI_R3_TRIG						(1L << 1)
+#define RAWI_R4_TRIG						(1L << 2)
+#define RAWI_R5_TRIG						(1L << 3)
+#define RAWI_R6_TRIG						(1L << 4)
+
+
+/* IRQ signal mask */
+#define INT_ST_MASK_CAM (VS_INT_ST	 |\
+						TG_INT1_ST	 |\
+						TG_INT2_ST	 |\
+						EXPDON_ST       |\
+						HW_PASS1_DON_ST |\
+						SOF_INT_ST      |\
+						SW_PASS1_DON_ST)
+
+/* IRQ Error Mask */
+#define INT_ST_MASK_CAM_ERR (TG_OVRUN_ST	 |\
+							TG_GBERR_ST	 |\
+							CQ_DB_LOAD_ERR_ST	 |\
+							CQ_MAIN_CODE_ERR_ST |\
+							CQ_MAIN_VS_ERR_ST	 |\
+							DMA_ERR_ST)
+
+/* camsys */
+#define REG_CAMSYS_CG_SET					0x0004
+#define REG_CAMSYS_CG_CLR					0x0008
+
+#define REG_HALT1_EN						0x0350
+#define REG_HALT2_EN						0x0354
+#define REG_HALT3_EN						0x0358
+#define REG_HALT4_EN						0x035c
+#define REG_HALT5_EN						0x0360
+#define REG_HALT6_EN						0x0364
+#define REG_FLASH							0x03A0
+#define REG_ULTRA_HALT1_EN					0x0368
+#define REG_ULTRA_HALT2_EN					0x036c
+#define REG_ULTRA_HALT3_EN					0x03b0
+#define REG_ULTRA_HALT4_EN					0x03b4
+#define REG_ULTRA_HALT5_EN					0x03b8
+#define REG_ULTRA_HALT6_EN					0x03bc
+#define REG_PREULTRA_HALT1_EN				0x03c4
+#define REG_PREULTRA_HALT2_EN				0x03c8
+#define REG_PREULTRA_HALT3_EN				0x03cc
+#define REG_PREULTRA_HALT4_EN				0x03d0
+#define REG_PREULTRA_HALT5_EN				0x03d4
+#define REG_PREULTRA_HALT6_EN				0x03d8
+
+/* Status check */
+#define REG_CTL_EN							0x0000
+#define REG_CTL_EN2							0x0004
+
+
+/* DMA Enable Register, DMA_EN */
+#define REG_CTL_MOD5_EN						0x0010
+#define REG_CTL_MOD6_EN						0x0014
+/* RAW input trigger*/
+#define REG_CTL_RAWI_TRIG					0x00C0
+
+#define REG_CTL_MISC						0x0060
+#define CTL_DB_EN							BIT(4)
+
+
+#define REG_CTL_SW_CTL						0x00C4
+#define REG_CTL_START						0x00B0
+
+#define REG_CTL_RAW_INT_EN					0x0100
+#define REG_CTL_RAW_INT_STAT				0x0104
+#define REG_CTL_RAW_INT2_EN					0x0110
+#define REG_CTL_RAW_INT2_STAT				0x0114
+#define REG_CTL_RAW_INT3_STAT				0x0124
+#define REG_CTL_RAW_INT4_STAT				0x0134
+#define REG_CTL_RAW_INT5_STAT				0x0144
+#define REG_CTL_RAW_INT6_EN					0x0150
+#define REG_CTL_RAW_INT6_STAT				0x0154
+#define REG_CTL_RAW_INT7_EN					0x0160
+#define REG_CTL_RAW_INT7_STAT				0x0164
+
+#define REG_CTL_RAW_MOD_DCM_DIS				0x0300
+#define REG_CTL_RAW_MOD2_DCM_DIS			0x0304
+#define REG_CTL_RAW_MOD3_DCM_DIS			0x0308
+#define REG_CTL_RAW_MOD5_DCM_DIS			0x0310
+#define REG_CTL_RAW_MOD6_DCM_DIS			0x0314
+
+#define REG_CTL_DBG_SET						0x00F0
+#define REG_CTL_DBG_PORT					0x00F4
+#define REG_DMA_DBG_SEL						0x4070
+#define REG_DMA_DBG_PORT					0x4074
+#ifdef ISP7_1
+#define REG_CTL_DBG_SET2					0x00F8
+#endif
+
+#define REG_CTL_RAW_MOD_REQ_STAT			0x0340
+#define REG_CTL_RAW_MOD2_REQ_STAT			0x0344
+#define REG_CTL_RAW_MOD3_REQ_STAT			0x0348
+#define REG_CTL_RAW_MOD4_REQ_STAT			0x034c /* CAMCTL2 */
+#define REG_CTL_RAW_MOD5_REQ_STAT			0x0350
+#define REG_CTL_RAW_MOD6_REQ_STAT			0x0354
+
+#define REG_CTL_RAW_MOD_RDY_STAT			0x0360
+#define REG_CTL_RAW_MOD2_RDY_STAT			0x0364
+#define REG_CTL_RAW_MOD3_RDY_STAT			0x0368
+#define REG_CTL_RAW_MOD4_RDY_STAT			0x036c /* CAMCTL2 */
+#define REG_CTL_RAW_MOD5_RDY_STAT			0x0370
+#define REG_CTL_RAW_MOD6_RDY_STAT			0x0374
+
+#define REG_CQ_EN							0x0400
+#define REG_SCQ_START_PERIOD				0x0408
+#define REG_CQ_THR0_CTL						0x0414
+#define REG_CQ_SUB_CQ_EN					0x060C
+#define REG_CQ_SUB_THR0_CTL					0x061C
+
+#define REG_CTL_SW_PASS1_DONE				0x00c8
+#define SW_DONE_SAMPLE_EN					BIT(8)
+#define REG_CTL_SW_SUB_CTL					0x00cc
+
+#define REG_CQ_THR0_BASEADDR				0x0418
+#define REG_CQ_THR0_DESC_SIZE				0x041C
+#define REG_SCQ_CQ_TRIG_TIME				0x0410
+#define REG_CQ_SUB_THR0_BASEADDR_2			0x0624
+#define REG_CQ_SUB_THR0_DESC_SIZE_2			0x062C
+#define REG_CQ_SUB_THR0_BASEADDR_1			0x0620
+#define REG_CQ_SUB_THR0_DESC_SIZE_1			0x0628
+#define SCQ_EN								BIT(20)
+#define SCQ_STAGGER_MODE					BIT(12)
+#define SCQ_SUBSAMPLE_EN					BIT(21)
+#define CQ_DB_EN							BIT(4)
+#define CQ_THR0_MODE_IMMEDIATE				BIT(4)
+#define CQ_THR0_MODE_CONTINUOUS				BIT(5)
+#define CQ_THR0_EN							BIT(0)
+#define SCQ_SUB_RESET						BIT(16)
+
+#define REG_TG_SEN_MODE						0x0700
+#define TG_CMOS_RDY_SEL						BIT(14)
+#define TG_SEN_MODE_CMOS_EN					BIT(0)
+#define TG_VFDATA_EN						BIT(0)
+#define TG_TG_FULL_SEL						BIT(15)
+#define TG_STAGGER_EN						BIT(22)
+
+#define REG_TG_VF_CON						0x0704
+#define REG_TG_SEN_GRAB_PXL					0x0708
+#define REG_TG_SEN_GRAB_LIN					0x070C
+#define REG_TG_PATH_CFG						0x0710
+#define TG_DB_LOAD_DIS						BIT(8)
+#define TG_SUB_SOF_SRC_SEL_0				BIT(20)
+#define TG_SUB_SOF_SRC_SEL_1				BIT(21)
+
+#define REG_TG_INTER_ST						0x073C
+/* use this MASK to extract TG_CAM_CS from TG_INTER_ST */
+#define TG_CAM_CS_MASK						0x3f00
+#define TG_IDLE_ST							BIT(8)
+
+
+#define REG_TG_FRMSIZE_ST					0x0738
+#define REG_TG_DCIF_CTL						0x075C
+#define TG_DCIF_EN							BIT(16)
+
+#define REG_TG_FRMSIZE_ST_R					0x076C
+#define REG_TG_TIME_STAMP					0x0778
+#define REG_TG_TIME_STAMP_CNT				0x077C
+
+/* tg flash */
+#define	REG_TG_XENON_FLASH_CTL				0x0780
+#define REG_TG_XENON_FLASH_OFFSET			0x0784
+#define REG_TG_XENON_FLASH_HIGH_WIDTH		0x0788
+#define REG_TG_XENON_FLASH_LOW_WIDTH		0x078C
+#define	REG_TG_IR_FLASH_CTL					0x0798
+#define REG_TG_IR_FLASH_OFFSET				0x079C
+#define REG_TG_IR_FLASH_HIGH_WIDTH			0x07A0
+#define REG_TG_IR_FLASH_LOW_WIDTH			0x07A4
+
+/* for raw & yuv's dma top base */
+#define CAMDMATOP_BASE						0x4000
+
+#define REG_DMA_SOFT_RST_STAT               0x4068
+#ifdef ISP7_1
+#define REG_DMA_SOFT_RST_STAT2              0x406C
+#define REG_DMA_DBG_CHASING_STATUS          0x4098
+#define REG_DMA_DBG_CHASING_STATUS2         0x409c
+#endif
+
+/* use spare register FH_SPARE_5 */
+#define REG_FRAME_SEQ_NUM					0x4930
+
+#define REG_CAMCTL_FBC_RCNT_INC				0x00A4
+
+#define CAMCTL_IMGO_R1_RCNT_INC				BIT(0)
+#define CAMCTL_CQ_THR0_DONE_ST				BIT(0)
+#define CTL_CQ_THR0_START					BIT(0)
+
+/* AE debug info */
+/* CAMSYS_RAW 0x1a03 */
+#define OFFSET_OBC_R1_R_SUM_L				0x1178
+#define OFFSET_OBC_R1_R_SUM_H				0x117c
+#define OFFSET_OBC_R1_B_SUM_L				0x1180
+#define OFFSET_OBC_R1_B_SUM_H				0x1184
+#define OFFSET_OBC_R1_GR_SUM_L				0x1188
+#define OFFSET_OBC_R1_GR_SUM_H				0x118c
+#define OFFSET_OBC_R1_GB_SUM_L				0x1190
+#define OFFSET_OBC_R1_GB_SUM_H				0x1194
+#define OFFSET_OBC_R1_ACT_WIN_X				0x1198
+#define OFFSET_OBC_R1_ACT_WIN_Y				0x119c
+
+#define OFFSET_OBC_R2_R_SUM_L				0x1438
+#define OFFSET_OBC_R2_R_SUM_H				0x143c
+#define OFFSET_OBC_R2_B_SUM_L				0x1440
+#define OFFSET_OBC_R2_B_SUM_H				0x1444
+#define OFFSET_OBC_R2_GR_SUM_L				0x1448
+#define OFFSET_OBC_R2_GR_SUM_H				0x144c
+#define OFFSET_OBC_R2_GB_SUM_L				0x1450
+#define OFFSET_OBC_R2_GB_SUM_H				0x1454
+#define OFFSET_OBC_R2_ACT_WIN_X				0x1458
+#define OFFSET_OBC_R2_ACT_WIN_Y				0x145c
+
+#define OFFSET_OBC_R3_R_SUM_L				0x16f8
+#define OFFSET_OBC_R3_R_SUM_H				0x16fc
+#define OFFSET_OBC_R3_B_SUM_L				0x1700
+#define OFFSET_OBC_R3_B_SUM_H				0x1704
+#define OFFSET_OBC_R3_GR_SUM_L				0x1708
+#define OFFSET_OBC_R3_GR_SUM_H				0x170c
+#define OFFSET_OBC_R3_GB_SUM_L				0x1710
+#define OFFSET_OBC_R3_GB_SUM_H				0x1714
+#define OFFSET_OBC_R3_ACT_WIN_X				0x1718
+#define OFFSET_OBC_R3_ACT_WIN_Y				0x171c
+
+#define REG_LTM_AE_DEBUG_B_MSB				0x23f0
+#define REG_LTM_AE_DEBUG_B_LSB				0x23f4
+#define REG_LTM_AE_DEBUG_GB_MSB				0x23f8
+#define REG_LTM_AE_DEBUG_GB_LSB				0x23fc
+#define REG_LTM_AE_DEBUG_GR_MSB				0x2400
+#define REG_LTM_AE_DEBUG_GR_LSB				0x2404
+#define REG_LTM_AE_DEBUG_R_MSB				0x2408
+#define REG_LTM_AE_DEBUG_R_LSB				0x240c
+#define REG_LTMS_ACT_WIN_X					0x2578
+#define REG_LTMS_ACT_WIN_Y					0x257c
+
+#define REG_AA_R_SUM_L						0x2a1c
+#define REG_AA_R_SUM_H						0x2a20
+#define REG_AA_B_SUM_L						0x2a24
+#define REG_AA_B_SUM_H						0x2a28
+#define REG_AA_GR_SUM_L						0x2a2c
+#define REG_AA_GR_SUM_H						0x2a30
+#define REG_AA_GB_SUM_L						0x2a34
+#define REG_AA_GB_SUM_H						0x2a30
+#define REG_AA_ACT_WIN_X					0x2a3c
+#define REG_AA_ACT_WIN_Y					0x2a40
+
+#define DMA_OFFSET_CON0						0x01c
+#define DMA_OFFSET_CON1						0x020
+#define DMA_OFFSET_CON2						0x024
+#define DMA_OFFSET_CON3						0x028
+#define DMA_OFFSET_CON4						0x02c
+#define DMA_OFFSET_ERR_STAT					0x030
+
+#define FBC_R1A_BASE						0x2c00
+#define FBC_R2A_BASE						0x3780
+#define REG_FBC_CTL1(base, idx)				(base + idx * 8)
+#define REG_FBC_CTL2(base, idx)				(base + idx * 8 + 4)
+#define WCNT_BIT_MASK						0xFF00
+#define CNT_BIT_MASK						0xFF0000
+#define TG_FULLSEL_BIT_MASK					0x8000
+/* ORIDMA */
+/* CAMSYS_RAW 0x1603 */
+#define REG_IMGO_R1_BASE					0x4820
+#define REG_FHO_R1_BASE						0x48d0
+#define REG_AAHO_R1_BASE					0x4980
+#define REG_PDO_R1_BASE						0x4a30
+#define REG_AAO_R1_BASE						0x4ae0
+#define REG_AFO_R1_BASE						0x4b90
+
+/* CAMSYS_YUV 0x1605 */
+#define REG_YUVO_R1_BASE					0x4200
+#define REG_YUVBO_R1_BASE					0x42b0
+#define REG_YUVCO_R1_BASE					0x4360
+#define REG_YUVDO_R1_BASE					0x4410
+#define REG_YUVO_R3_BASE					0x44c0
+#define REG_YUVBO_R3_BASE					0x4570
+#define REG_YUVCO_R3_BASE					0x4620
+#define REG_YUVDO_R3_BASE					0x46D0
+
+/* ULCDMA */
+/* CAMSYS_RAW 0x1603 */
+#define REG_LTMSO_R1_BASE					0x4c80
+#define REG_TSFSO_R1_BASE					0x4c40
+#define REG_TSFSO_R2_BASE					0x4d80
+#define REG_FLKO_R1_BASE					0x4cc0
+#define REG_UFEO_R1_BASE					0x4d00
+
+/* CAMSYS_YUV 0x1605 */
+#define REG_YUVO_R2_BASE					0x4780
+#define REG_YUVBO_R2_BASE					0x47c0
+#define REG_YUVO_R4_BASE					0x4800
+#define REG_YUVBO_R4_BASE					0x4840
+#define REG_YUVO_R5_BASE					0x4c00
+#define REG_YUVBO_R5_BASE					0x4c40
+#define REG_RZH1N2TO_R1_BASE				0x4880
+#define REG_RZH1N2TBO_R1_BASE				0x48c0
+#define REG_RZH1N2TO_R2_BASE				0x4900
+#define REG_RZH1N2TO_R3_BASE				0x4940
+#define REG_RZH1N2TBO_R3_BASE				0x4980
+#define REG_DRZS4NO_R1_BASE					0x49c0
+#define REG_DRZS4NO_R2_BASE					0x4a00
+#define REG_DRZS4NO_R3_BASE					0x4a40
+#define REG_ACTSO_R1_BASE					0x4ac0
+#define REG_TNCSO_R1_BASE					0x4b00
+#define REG_TNCSBO_R1_BASE					0x4b40
+#define REG_TNCSHO_R1_BASE					0x4b80
+#define REG_TNCSYO_R1_BASE					0x4bc0
+
+/* CAMSYS_RAW 0x1603 */
+#define REG_RAWI_R2_BASE					0x4200
+#define REG_UFDI_R2_BASE					0x4260
+#define REG_RAWI_R3_BASE					0x42c0
+#define REG_UFDI_R3_BASE					0x4320
+#define REG_CQI_R1_BASE						0x4440
+#define REG_CQI_R2_BASE						0x44a0
+#define REG_CQI_R3_BASE						0x4500
+#define REG_CQI_R4_BASE						0x4560
+#define REG_LSCI_R1_BASE					0x45c0
+#define REG_BPCI_R1_BASE					0x4620
+#define REG_BPCI_R2_BASE					0x4660
+#define REG_BPCI_R3_BASE					0x46a0
+#define REG_PDI_R1_BASE						0x46e0
+#define REG_AAI_R1_BASE						0x4760
+#define REG_CACI_R1_BASE					0x47a0
+#define REG_RAWI_R6_BASE					0x47e0
+
+#endif	/* _CAM_REGS_H */
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam-seninf-ca.c b/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam-seninf-ca.c
new file mode 100644
index 0000000000000000000000000000000000000000..1ad680c8033c96094e6db807aaf50b8a1d06da2f
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam-seninf-ca.c
@@ -0,0 +1,122 @@
+// SPDX-License-Identifier: GPL-2.0
+//
+// Copyright (c) 2022 MediaTek Inc.
+
+#include<linux/slab.h>
+
+#include "mtk_cam-seninf-ca.h"
+
+#define PFX "mtk_cam-seninf-ca"
+#define LOG_INF(format, args...) pr_info(PFX "[%s] " format, __func__, ##args)
+#define PARAM_SIZE 4
+
+
+#define SRV_NAME(name)   "com.mediatek.geniezone." name
+
+static struct SENINF_CA *pca;
+
+static const char imgsensor_srv_name[] =  SRV_NAME("srv.imgsensor");
+#define IMGSENSOR_UUID { 0x7b665120, 0x2121, 0x4487, \
+	{ 0xba, 0x71, 0x0a, 0x51, 0xd7, 0xea, 0x78, 0xfe } }
+
+int seninf_ca_open_session(void)
+{
+	int ret = SENINF_CA_RETURN_SUCCESS;
+	TZ_RESULT ret_tz = TZ_RESULT_SUCCESS;
+
+	LOG_INF("[%s] +", __func__);
+
+	pca = kmalloc(sizeof(struct SENINF_CA), GFP_KERNEL);
+
+	memset(pca, 0, sizeof(struct SENINF_CA));
+	ret_tz = KREE_CreateSession(imgsensor_srv_name, &pca->session);
+	if (ret_tz != TZ_RESULT_SUCCESS) {
+		LOG_INF("[%s] CreateSession fail. ret: %d. ", __func__, ret_tz);
+		ret = SENINF_CA_RETURN_ERROR;
+	}
+
+	LOG_INF("[%s]-", __func__);
+	return ret;
+}
+
+int seninf_ca_close_session(void)
+{
+	int ret = SENINF_CA_RETURN_SUCCESS;
+	TZ_RESULT ret_tz = TZ_RESULT_SUCCESS;
+
+	if (pca == NULL)
+		return ret;
+
+	ret_tz = KREE_CloseSession(pca->session);
+	memset(&pca->session, 0, sizeof(KREE_SESSION_HANDLE));
+
+	if (ret_tz != TZ_RESULT_SUCCESS) {
+		LOG_INF("[%s] CloseSession fail. ret: %d. ", __func__, ret_tz);
+		ret = SENINF_CA_RETURN_ERROR;
+	}
+
+	LOG_INF("[%s] -", __func__);
+	return ret;
+}
+
+
+
+int seninf_ca_checkpipe(unsigned int SecInfo_addr)
+{
+
+	int types = 0;
+	int ret = SENINF_CA_RETURN_SUCCESS;
+	TZ_RESULT ret_tz = TZ_RESULT_SUCCESS;
+	union MTEEC_PARAM param[PARAM_SIZE];
+
+	LOG_INF("[%s] +", __func__);
+
+	param[0].value.a = ret;
+	param[0].value.b = SecInfo_addr;
+	types = TZ_ParamTypes4(TZPT_VALUE_OUTPUT, TZPT_NONE, TZPT_NONE, TZPT_NONE);
+	ret_tz = KREE_TeeServiceCall(pca->session, SENINF_TEE_CMD_CHECKPIPE, types, param);
+
+	if (ret_tz != TZ_RESULT_SUCCESS && param[0].value.a) {
+		LOG_INF("[%s]checkpipe failed.", __func__);
+		ret = SENINF_CA_RETURN_ERROR;
+	}
+
+	LOG_INF("[%s] -", __func__);
+	return ret;
+}
+
+
+
+
+
+int seninf_ca_free(void)
+{
+	int types = 0;
+	int ret = SENINF_CA_RETURN_SUCCESS;
+	TZ_RESULT ret_tz = TZ_RESULT_SUCCESS;
+	union MTEEC_PARAM param[PARAM_SIZE];
+
+	LOG_INF("[%s] +", __func__);
+
+	if (pca == NULL) {
+		LOG_INF("[%s]pca is null", __func__);
+		return ret;
+	}
+
+	param[0].value.a = ret;
+	types = TZ_ParamTypes4(TZPT_VALUE_OUTPUT, TZPT_NONE, TZPT_NONE, TZPT_NONE);
+	ret_tz = KREE_TeeServiceCall(pca->session, SENINF_TEE_CMD_FREE, types, param);
+
+	if (ret_tz != TZ_RESULT_SUCCESS && param[0].value.a) {
+		LOG_INF("[%s]free failed.", __func__);
+		ret = SENINF_CA_RETURN_ERROR;
+	}
+
+	LOG_INF("[%s] -", __func__);
+	return ret;
+}
+
+
+
+
+
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam-seninf-ca.h b/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam-seninf-ca.h
new file mode 100644
index 0000000000000000000000000000000000000000..6aab61bc468191c8295f74c3f213e42e51421e27
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam-seninf-ca.h
@@ -0,0 +1,49 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2022 MediaTek Inc.
+ */
+
+
+
+#ifndef __IMGSENSOR_CA_H__
+#define __IMGSENSOR_CA_H__
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <linux/types.h>
+#include <linux/delay.h>
+#include <linux/limits.h>
+#include <kree/system.h>
+#include <kree/mem.h>
+
+enum SENINF_TEE_CMD {
+
+	SENINF_TEE_CMD_SYNC_TO_PA = 0x10,
+	SENINF_TEE_CMD_SYNC_TO_VA,
+	SENINF_TEE_CMD_CHECKPIPE,
+	SENINF_TEE_CMD_FREE,
+
+};
+
+enum SENINF_CA_RETURN {
+
+	SENINF_CA_RETURN_ERROR,
+	SENINF_CA_RETURN_SUCCESS
+
+};
+
+struct SENINF_CA {
+
+	KREE_SESSION_HANDLE session;
+
+};
+
+int seninf_ca_open_session(void);
+int seninf_ca_close_session(void);
+int seninf_ca_checkpipe(unsigned int SecInfo_addr);
+int seninf_ca_free(void);
+
+#endif
+
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam-seninf-def.h b/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam-seninf-def.h
new file mode 100644
index 0000000000000000000000000000000000000000..2bca48fb1a7a27de17bc1f3068c23dbc1eac754a
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam-seninf-def.h
@@ -0,0 +1,281 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+// Copyright (c) 2022 MediaTek Inc.
+
+#ifndef __MTK_CAM_SENINF_DEF_H__
+#define __MTK_CAM_SENINF_DEF_H__
+
+#define SENINF_VC_MAXCNT 8
+#define SENINF_DEF_PIXEL_MODE 2
+
+#ifdef ISP7_1
+
+#define SENINF_CLK_MARGIN_IN_PERCENT 0
+#define HW_BUF_EFFECT 10
+#define CSI_CLK_273MHZ
+
+/* under 14.5 Gbps, trail should be enable */
+#define SENINF_HS_TRAIL_EN_CONDITION 1450000000
+
+#else //MT8195
+
+#define SENINF_CLK_MARGIN_IN_PERCENT 5
+#define HW_BUF_EFFECT 80
+#define CSI_CLK_356MHZ
+
+/* under 800Mbps, trail should be enable */
+#define SENINF_HS_TRAIL_EN_CONDITION 800000000
+
+#endif //#ifdef ISP7_1
+
+#define SENINF_TIMESTAMP_CLK 1000
+#define ISP_CLK_LOW 273000000
+
+/* data lane hs settle, base on 208 MHz csi ck */
+#ifdef CSI_CLK_208MHZ
+#define SENINF_CPHY_SETTLE_DELAY_DT 0x15
+#define SENINF_DPHY_SETTLE_DELAY_DT 0x15
+#define SENINF_SETTLE_DELAY_CK 0x9
+#define SENINF_HS_TRAIL_PARAMETER 0x8
+#endif
+/* data lane hs settle, base on 208 MHz csi ck */
+#ifdef CSI_CLK_273MHZ
+#define SENINF_CPHY_SETTLE_DELAY_DT 0x10
+#define SENINF_DPHY_SETTLE_DELAY_DT 0x10
+#define SENINF_SETTLE_DELAY_CK 0x11
+#define SENINF_HS_TRAIL_PARAMETER 0x34
+#endif
+
+#ifdef CSI_CLK_499MHZ
+#define SENINF_CPHY_SETTLE_DELAY_DT 0x20
+#define SENINF_DPHY_SETTLE_DELAY_DT 0x2f
+#define SENINF_SETTLE_DELAY_CK 0x2f
+#define SENINF_HS_TRAIL_PARAMETER 0x34
+#endif
+
+/* data lane hs settle, base on 312 MHz csi ck */
+#ifdef CSI_CLK_312MHZ
+#define SENINF_CPHY_SETTLE_DELAY_DT 0x20
+#define SENINF_DPHY_SETTLE_DELAY_DT 0x20
+#define SENINF_SETTLE_DELAY_CK 0xD
+#define SENINF_HS_TRAIL_PARAMETER 0xa
+#endif
+
+/* data lane hs settle, base on 356 MHz csi ck */
+#ifdef CSI_CLK_356MHZ
+#define SENINF_CPHY_SETTLE_DELAY_DT 0x1c
+#define SENINF_DPHY_SETTLE_DELAY_DT 0x27
+#define SENINF_SETTLE_DELAY_CK 0x13
+#define SENINF_HS_TRAIL_PARAMETER 0x25
+#endif
+
+/* clock lane hs settle, base on 393 MHz csi ck */
+#ifdef CSI_CLK_393MHZ
+#define SENINF_CPHY_SETTLE_DELAY_DT 0x28
+#define SENINF_DPHY_SETTLE_DELAY_DT 0x28
+#define SENINF_SETTLE_DELAY_CK 0x10
+#define SENINF_HS_TRAIL_PARAMETER 0x30
+#endif
+
+/* clock lane hs settle, base on 416 MHz csi ck */
+#ifdef CSI_CLK_416MHZ
+#define SENINF_CPHY_SETTLE_DELAY_DT 0x27
+#define SENINF_DPHY_SETTLE_DELAY_DT 0x27
+#define SENINF_SETTLE_DELAY_CK 0x13
+#define SENINF_HS_TRAIL_PARAMETER 0x30
+#endif
+
+#define SENSOR_CLOCK_POLARITY_HIGH	0
+#define SENSOR_CLOCK_POLARITY_LOW	1
+#define NUM_PORTS			2
+#define DEFAULT_WIDTH			1600
+#define DEFAULT_HEIGHT			1200
+
+#define SENINF_DEBUG
+
+#ifdef SENINF_DEBUG
+#define SENINF_DEBUG_FL_IGNORE_CAM_LINK 1
+#define SENINF_DEBUG_FL_ALLOC_CAM_MUX 2
+#endif
+
+enum CSI_PORT {
+	CSI_PORT_0 = 0,
+	CSI_PORT_1,
+	CSI_PORT_2,
+	CSI_PORT_3,
+	CSI_PORT_4,
+	CSI_PORT_5,
+	CSI_PORT_0A,
+	CSI_PORT_0B,
+	CSI_PORT_1A,
+	CSI_PORT_1B,
+	CSI_PORT_2A,
+	CSI_PORT_2B,
+	CSI_PORT_3A,
+	CSI_PORT_3B,
+	CSI_PORT_4A,
+	CSI_PORT_4B,
+	CSI_PORT_5A,
+	CSI_PORT_5B,
+	CSI_PORT_MAX_NUM,
+};
+
+#define SENINF_CSI_PORT_NAMES \
+	"0", \
+	"1", \
+	"2", \
+	"3", \
+	"4", \
+	"5", \
+	"0A", \
+	"0B", \
+	"1A", \
+	"1B", \
+	"2A", \
+	"2B", \
+	"3A", \
+	"3B", \
+	"4A", \
+	"4B", \
+	"5A", \
+	"5B", \
+
+enum SENINF_PHY_VER_ENUM {
+	SENINF_PHY_2_0,
+	SENINF_PHY_VER_NUM,
+};
+
+#define MTK_CSI_PHY_VERSIONS \
+"mtk_csi_phy_2_0", \
+
+enum SENINF_ENUM {
+	SENINF_1,
+	SENINF_2,
+	SENINF_3,
+	SENINF_4,
+	SENINF_5,
+	SENINF_6,
+	SENINF_7,
+	SENINF_8,
+	SENINF_9,
+	SENINF_10,
+	SENINF_11,
+	SENINF_12,
+	SENINF_NUM,
+};
+
+enum SENINF_MUX_ENUM {
+	SENINF_MUX1,
+	SENINF_MUX2,
+	SENINF_MUX3,
+	SENINF_MUX4,
+	SENINF_MUX5,
+	SENINF_MUX6,
+	SENINF_MUX7,
+	SENINF_MUX8,
+	SENINF_MUX9,
+	SENINF_MUX10,
+	SENINF_MUX11,
+	SENINF_MUX12,
+	SENINF_MUX13,
+	SENINF_MUX14,
+	SENINF_MUX15,
+	SENINF_MUX16,
+	SENINF_MUX17,
+	SENINF_MUX18,
+	SENINF_MUX19,
+	SENINF_MUX20,
+	SENINF_MUX21,
+	SENINF_MUX22,
+	SENINF_MUX_NUM,
+
+	SENINF_MUX_ERROR = -1,
+};
+
+enum SENINF_CAM_MUX_ENUM {
+	SENINF_CAM_MUX0,
+	SENINF_CAM_MUX1,
+	SENINF_CAM_MUX2,
+	SENINF_CAM_MUX3,
+	SENINF_CAM_MUX4,
+	SENINF_CAM_MUX5,
+	SENINF_CAM_MUX6,
+	SENINF_CAM_MUX7,
+	SENINF_CAM_MUX8,
+	SENINF_CAM_MUX9,
+	SENINF_CAM_MUX10,
+	SENINF_CAM_MUX11,
+	SENINF_CAM_MUX12,
+	SENINF_CAM_MUX13,
+	SENINF_CAM_MUX14,
+	SENINF_CAM_MUX15,
+	SENINF_CAM_MUX16,
+	SENINF_CAM_MUX17,
+	SENINF_CAM_MUX18,
+	SENINF_CAM_MUX19,
+	SENINF_CAM_MUX20,
+	SENINF_CAM_MUX21,
+	SENINF_CAM_MUX22,
+	SENINF_CAM_MUX_NUM,
+
+	SENINF_CAM_MUX_ERR = 0xff
+};
+
+enum SENINF_SOURCE_ENUM { //0:CSI2(2.5G), 3: parallel, 8:NCSI2(1.5G)
+	CSI2 = 0x0, /* 2.5G support */
+	TEST_MODEL = 0x1,
+	CCIR656	= 0x2,
+	PARALLEL_SENSOR = 0x3,
+	SERIAL_SENSOR = 0x4,
+	HD_TV = 0x5,
+	EXT_CSI2_OUT1 = 0x6,
+	EXT_CSI2_OUT2 = 0x7,
+	MIPI_SENSOR = 0x8,/* 1.5G support */
+	VIRTUAL_CHANNEL_1 = 0x9,
+	VIRTUAL_CHANNEL_2 = 0xA,
+	VIRTUAL_CHANNEL_3 = 0xB,
+	VIRTUAL_CHANNEL_4 = 0xC,
+	VIRTUAL_CHANNEL_5 = 0xD,
+	VIRTUAL_CHANNEL_6 = 0xE,
+};
+
+enum SENINF_CSI2_ENUM {
+	CSI2_1_5G = 0x0, /* 1.5G support */
+	CSI2_2_5G = 0x1, /* 2.5G support */
+	CSI2_2_5G_CPHY = 0x2, /* 2.5G support */
+};
+
+enum TG_FORMAT_ENUM {
+	RAW_8BIT_FMT = 0x0,
+	RAW_10BIT_FMT = 0x1,
+	RAW_12BIT_FMT = 0x2,
+	YUV422_FMT = 0x3,
+	RAW_14BIT_FMT = 0x4,
+	RGB565_MIPI_FMT	= 0x5,
+	RGB888_MIPI_FMT	= 0x6,
+	JPEG_FMT = 0x7
+};
+
+enum {
+	CLK_CAM_SENINF = 0,
+	CLK_TOP_SENINF,
+	CLK_TOP_SENINF1,
+	CLK_TOP_SENINF2,
+	CLK_TOP_SENINF3,
+	CLK_TOP_SENINF4,
+	CLK_TOP_SENINF5,
+	CLK_TOP_SENINF_END,
+	CLK_TOP_CAMTM = CLK_TOP_SENINF_END,
+	CLK_MAXCNT,
+};
+
+#define SENINF_CLK_NAMES \
+	"clk_cam_seninf", \
+	"clk_top_seninf", \
+	"clk_top_seninf1", \
+	"clk_top_seninf2", \
+	"clk_top_seninf3", \
+	"clk_top_seninf4", \
+	"clk_top_seninf5", \
+	"clk_top_camtm", \
+
+#endif
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam-seninf-drv.c b/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam-seninf-drv.c
new file mode 100644
index 0000000000000000000000000000000000000000..5a9cc18487da8744b6927643180ae70143cbae54
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam-seninf-drv.c
@@ -0,0 +1,2002 @@
+// SPDX-License-Identifier: GPL-2.0
+// Copyright (c) 2022 MediaTek Inc.
+
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/pm_domain.h>
+#include <linux/pm_runtime.h>
+#include <linux/clk.h>
+#include <linux/of_graph.h>
+#include <linux/of_irq.h>
+#include <linux/of_device.h>
+#include <linux/component.h>
+#include <linux/pm_opp.h>
+#include <linux/regulator/consumer.h>
+
+#ifdef CONFIG_COMPAT
+#include <linux/compat.h>
+#endif
+#include <linux/videodev2.h>
+#include <media/v4l2-subdev.h>
+#include <media/v4l2-fwnode.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-event.h>
+#include <media/v4l2-async.h>
+#include <media/v4l2-device.h>
+
+#include "mtk_cam.h"
+#include "mtk_cam-seninf-def.h"
+#include "mtk_cam-seninf.h"
+#include "mtk_cam-seninf-hw.h"
+#include "mtk_cam-seninf-route.h"
+#include "imgsensor-user.h"
+#ifdef SENSOR_SECURE_MTEE_SUPPORT
+#include "mtk_cam-seninf-ca.h"
+#endif
+
+#define ESD_RESET_SUPPORT 1
+#define V4L2_CID_MTK_SENINF_BASE	(V4L2_CID_USER_BASE | 0xf000)
+#define V4L2_CID_MTK_TEST_STREAMON	(V4L2_CID_MTK_SENINF_BASE + 1)
+
+#define sd_to_ctx(__sd) container_of(__sd, struct seninf_ctx, subdev)
+#define notifier_to_ctx(__n) container_of(__n, struct seninf_ctx, notifier)
+#define ctrl_hdl_to_ctx(__h) container_of(__h, struct seninf_ctx, ctrl_handler)
+#define sizeof_u32(__struct_name__) (sizeof(__struct_name__) / sizeof(u32))
+#define sizeof_u16(__struct_name__) (sizeof(__struct_name__) / sizeof(u16))
+
+struct mtk_cam_seninf_ops *g_seninf_ops;
+
+#ifdef CSI_EFUSE_SET
+#include <linux/nvmem-consumer.h>
+#endif
+static const char * const csi_phy_versions[] = {
+	MTK_CSI_PHY_VERSIONS
+};
+
+
+static const char * const csi_port_names[] = {
+	SENINF_CSI_PORT_NAMES
+};
+
+static const char * const clk_names[] = {
+	SENINF_CLK_NAMES
+};
+
+static const char * const set_reg_names[] = {
+	SET_REG_KEYS_NAMES
+};
+
+static ssize_t status_show(struct device *dev,
+			   struct device_attribute *attr, char *buf)
+{
+	return g_seninf_ops->_show_status(dev, attr, buf);
+}
+
+static DEVICE_ATTR_RO(status);
+
+static ssize_t err_status_show(struct device *dev,
+			   struct device_attribute *attr, char *buf)
+{
+	return g_seninf_ops->_show_err_status(dev, attr, buf);
+}
+
+static DEVICE_ATTR_RO(err_status);
+
+static ssize_t debug_ops_show(struct device *dev,
+			   struct device_attribute *attr, char *buf)
+{
+	int len = 0;
+
+	len += snprintf(buf + len, PAGE_SIZE - len, "This is debug ops message\n");
+
+	return len;
+}
+
+enum REG_OPS_CMD {
+	REG_OPS_CMD_ID,
+	REG_OPS_CMD_CSI,
+	REG_OPS_CMD_RG,
+	REG_OPS_CMD_VAL,
+	REG_OPS_CMD_MAX_NUM,
+};
+
+static ssize_t debug_ops_store(struct device *dev,
+			   struct device_attribute *attr,
+			   const char *buf, size_t count)
+{
+	char delim[] = " ";
+	char csi_names[20];
+	char *token = NULL;
+	char *sbuf = kzalloc(sizeof(char) * (count + 1), GFP_KERNEL);
+	char *s = sbuf;
+	int ret, i, num_para = 0;
+	char *arg[REG_OPS_CMD_MAX_NUM];
+	struct seninf_core *core = dev_get_drvdata(dev);
+	struct seninf_ctx *ctx;
+	int csi_port = -1;
+	int rg_idx = -1;
+	u32 val;
+
+	if (!sbuf)
+		goto ERR_DEBUG_OPS_STORE;
+
+	memcpy(sbuf, buf, count);
+
+	token = strsep(&s, delim);
+	while (token != NULL && num_para < REG_OPS_CMD_MAX_NUM) {
+		if (strlen(token)) {
+			arg[num_para] = token;
+			num_para++;
+		}
+
+		token = strsep(&s, delim);
+	}
+
+	if (num_para != REG_OPS_CMD_MAX_NUM) {
+		dev_info(dev, "Wrong command parameter number\n");
+		goto ERR_DEBUG_OPS_STORE;
+	}
+
+	if (strncmp("SET_REG", arg[REG_OPS_CMD_ID], sizeof("SET_REG")) == 0) {
+		for (i = 0; i < REG_KEY_MAX_NUM; i++) {
+			if (!strcasecmp(arg[REG_OPS_CMD_RG], set_reg_names[i]))
+				rg_idx = i;
+		}
+		if (rg_idx < 0)
+			goto ERR_DEBUG_OPS_STORE;
+
+		ret = kstrtouint(arg[REG_OPS_CMD_VAL], 0, &val);
+		if (ret)
+			goto ERR_DEBUG_OPS_STORE;
+
+		for (i = 0; i < CSI_PORT_MAX_NUM; i++) {
+			memset(csi_names, 0, ARRAY_SIZE(csi_names));
+			snprintf(csi_names, 10, "csi-%s", csi_port_names[i]);
+			if (!strcasecmp(arg[REG_OPS_CMD_CSI], csi_names))
+				csi_port = i;
+		}
+
+		if (csi_port < 0)
+			goto ERR_DEBUG_OPS_STORE;
+
+		// reg call
+		mutex_lock(&core->mutex);
+
+		list_for_each_entry(ctx, &core->list, list) {
+			if (csi_port == ctx->port)
+				g_seninf_ops->_set_reg(ctx, rg_idx, val);
+		}
+
+		mutex_unlock(&core->mutex);
+	}
+
+ERR_DEBUG_OPS_STORE:
+
+	kfree(sbuf);
+
+	return count;
+}
+
+static DEVICE_ATTR_RW(debug_ops);
+
+#define SENINF_DVFS_READY
+#ifdef SENINF_DVFS_READY
+static int seninf_dfs_init(struct seninf_dfs *dfs, struct device *dev)
+{
+	int ret, i;
+	struct dev_pm_opp *opp;
+	unsigned long freq;
+
+	dfs->dev = dev;
+
+	ret = dev_pm_opp_of_add_table(dev);
+	if (ret < 0) {
+		dev_info(dev, "fail to init opp table: %d\n", ret);
+		return ret;
+	}
+
+#ifdef ISP7_1
+	dfs->reg = devm_regulator_get_optional(dev, "dvfsrc-vmm");
+	if (IS_ERR(dfs->reg)) {
+		dev_info(dev, "can't get dvfsrc-vmm\n");
+		return PTR_ERR(dfs->reg);
+	}
+#else //MT8195
+	dfs->reg = devm_regulator_get_optional(dev, "dvfsrc-vcore");
+	if (IS_ERR(dfs->reg)) {
+		dev_info(dev, "can't get dvfsrc-vcore\n");
+		return PTR_ERR(dfs->reg);
+	}
+#endif //ISP7_1
+
+	dfs->cnt = dev_pm_opp_get_opp_count(dev);
+
+	dfs->freqs = devm_kzalloc(dev,
+				  sizeof(unsigned long) * dfs->cnt, GFP_KERNEL);
+	dfs->volts = devm_kzalloc(dev,
+				  sizeof(unsigned long) * dfs->cnt, GFP_KERNEL);
+	if (!dfs->freqs || !dfs->volts)
+		return -ENOMEM;
+
+	i = 0;
+	freq = 0;
+	while (!IS_ERR(opp = dev_pm_opp_find_freq_ceil(dev, &freq))) {
+		dfs->freqs[i] = freq;
+		dfs->volts[i] = dev_pm_opp_get_voltage(opp);
+		freq++;
+		i++;
+		dev_pm_opp_put(opp);
+	}
+
+	for (i = 0; i < dfs->cnt; i++) {
+		dev_info(dev, "dfs[%d] freq %ld volt %ld\n",
+			 i, dfs->freqs[i], dfs->volts[i]);
+	}
+
+	return 0;
+}
+#endif
+
+static int seninf_dfs_exit(struct seninf_dfs *dfs)
+{
+	if (!dfs->cnt)
+		return 0;
+
+	dev_pm_opp_of_remove_table(dfs->dev);
+
+	return 0;
+}
+
+static int __seninf_dfs_set(struct seninf_ctx *ctx, unsigned long freq)
+{
+	int i;
+	struct seninf_ctx *tmp;
+	struct seninf_core *core = ctx->core;
+	struct seninf_dfs *dfs = &core->dfs;
+	unsigned long require = 0, old;
+
+	if (!dfs->cnt)
+		return 0;
+
+	old = ctx->isp_freq;
+	ctx->isp_freq = freq;
+
+	list_for_each_entry(tmp, &core->list, list) {
+		if (tmp->isp_freq > require)
+			require = tmp->isp_freq;
+	}
+
+	for (i = 0; i < dfs->cnt; i++) {
+		if (dfs->freqs[i] >= require)
+			break;
+	}
+
+	if (i == dfs->cnt) {
+		ctx->isp_freq = old;
+		return -EINVAL;
+	}
+
+	regulator_set_voltage(dfs->reg, dfs->volts[i],
+			      dfs->volts[dfs->cnt - 1]);
+
+	dev_info(ctx->dev, "freq %ld require %ld selected %ld\n",
+		 freq, require, dfs->freqs[i]);
+
+	return 0;
+}
+
+static int seninf_dfs_set(struct seninf_ctx *ctx, unsigned long freq)
+{
+	int ret;
+	struct seninf_core *core = ctx->core;
+
+	mutex_lock(&core->mutex);
+	ret = __seninf_dfs_set(ctx, freq);
+	mutex_unlock(&core->mutex);
+
+	return ret;
+}
+
+static int seninf_core_pm_runtime_enable(struct seninf_core *core)
+{
+	int i;
+
+	core->pm_domain_cnt = of_count_phandle_with_args(core->dev->of_node,
+					"power-domains",
+					"#power-domain-cells");
+	if (core->pm_domain_cnt == 1)
+		pm_runtime_enable(core->dev);
+	else {
+		core->pm_domain_devs = devm_kcalloc(core->dev, core->pm_domain_cnt,
+					sizeof(*core->pm_domain_devs), GFP_KERNEL);
+		if (!core->pm_domain_devs)
+			return -ENOMEM;
+
+		for (i = 0; i < core->pm_domain_cnt; i++) {
+			core->pm_domain_devs[i] =
+				dev_pm_domain_attach_by_id(core->dev, i);
+
+			if (IS_ERR_OR_NULL(core->pm_domain_devs[i])) {
+				dev_info(core->dev, "%s: fail to probe pm id %d\n",
+					__func__, i);
+				core->pm_domain_devs[i] = NULL;
+			}
+		}
+	}
+
+	return 0;
+}
+
+static int seninf_core_pm_runtime_disable(struct seninf_core *core)
+{
+	int i;
+
+	if (core->pm_domain_cnt == 1)
+		pm_runtime_disable(core->dev);
+	else {
+		if (!core->pm_domain_devs)
+			return -EINVAL;
+
+		for (i = 0; i < core->pm_domain_cnt; i++) {
+			if (core->pm_domain_devs[i])
+				dev_pm_domain_detach(core->pm_domain_devs[i], 1);
+		}
+	}
+
+	return 0;
+}
+
+static int seninf_core_pm_runtime_get_sync(struct seninf_core *core)
+{
+	int i;
+
+	if (core->pm_domain_cnt == 1)
+		pm_runtime_get_sync(core->dev);
+	else {
+		if (!core->pm_domain_devs)
+			return -EINVAL;
+
+		for (i = 0; i < core->pm_domain_cnt; i++) {
+			if (core->pm_domain_devs[i])
+				pm_runtime_get_sync(core->pm_domain_devs[i]);
+		}
+	}
+
+	return 0;
+}
+
+static int seninf_core_pm_runtime_put(struct seninf_core *core)
+{
+	int i;
+
+	if (core->pm_domain_cnt == 1)
+		pm_runtime_put_sync(core->dev);
+	else {
+		if (!core->pm_domain_devs && core->pm_domain_cnt < 1)
+			return -EINVAL;
+
+		for (i = core->pm_domain_cnt - 1; i >= 0; i--) {
+			if (core->pm_domain_devs[i])
+				pm_runtime_put_sync(core->pm_domain_devs[i]);
+		}
+	}
+
+	return 0;
+}
+
+static irqreturn_t mtk_irq_seninf(int irq, void *data)
+{
+	g_seninf_ops->_irq_handler(irq, data);
+	return IRQ_HANDLED;
+}
+
+static int get_seninf_ops(struct device *dev, struct seninf_core *core)
+{
+	int i, ret;
+	const char *ver;
+
+	ret = of_property_read_string(dev->of_node, "mtk_csi_phy_ver", &ver);
+	if (ret) {
+		dev_err(dev,
+			"Fail to get mtk_csi_phy_ver property (err = %d)\n",
+			ret);
+		return ret;
+	}
+	for (i = 0; i < SENINF_PHY_VER_NUM; i++) {
+		if (!strcasecmp(ver, csi_phy_versions[i])) {
+			if (i == SENINF_PHY_2_0)
+				g_seninf_ops = &mtk_csi_phy_2_0;
+
+			dev_info(dev, "%s: mtk_csi_phy_ver = %s i = %d ret = %d\n",
+				 __func__,
+				 csi_phy_versions[i], i, ret);
+
+			of_property_read_u32(dev->of_node, "seninf_num",
+					     &g_seninf_ops->seninf_num);
+			of_property_read_u32(dev->of_node, "mux_num",
+					     &g_seninf_ops->mux_num);
+			of_property_read_u32(dev->of_node, "cam_mux_num",
+					     &g_seninf_ops->cam_mux_num);
+			of_property_read_u32(dev->of_node, "pref_mux_num",
+					     &g_seninf_ops->pref_mux_num);
+
+			dev_info(dev, "%s: seninf_num = %d, mux_num = %d, cam_mux_num = %d, pref_mux_num =%d\n",
+				 __func__,
+				 g_seninf_ops->seninf_num,
+				 g_seninf_ops->mux_num,
+				 g_seninf_ops->cam_mux_num,
+				 g_seninf_ops->pref_mux_num);
+			return 0;
+		}
+	}
+
+	return -1;
+}
+
+static int seninf_core_probe(struct platform_device *pdev)
+{
+	int i, ret, irq;
+	struct resource *res;
+	struct seninf_core *core;
+	struct device *dev = &pdev->dev;
+
+	core = devm_kzalloc(&pdev->dev, sizeof(*core), GFP_KERNEL);
+	if (!core)
+		return -ENOMEM;
+
+	dev_set_drvdata(dev, core);
+	core->dev = dev;
+	mutex_init(&core->mutex);
+	INIT_LIST_HEAD(&core->list);
+
+	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "base");
+	core->reg_if = devm_ioremap_resource(dev, res);
+	if (IS_ERR(core->reg_if))
+		return PTR_ERR(core->reg_if);
+
+	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "ana-rx");
+	core->reg_ana = devm_ioremap_resource(dev, res);
+	if (IS_ERR(core->reg_ana))
+		return PTR_ERR(core->reg_ana);
+
+	ret = get_seninf_ops(dev, core);
+	if (ret) {
+		dev_dbg(dev, "failed to get seninf ops\n");
+		return ret;
+	}
+	mtk_cam_seninf_init_res(core);
+
+	spin_lock_init(&core->spinlock_irq);
+	irq = platform_get_irq(pdev, 0);
+	if (!irq) {
+		dev_dbg(dev, "failed to get irq\n");
+		return -ENODEV;
+	}
+
+	ret = devm_request_irq(dev, irq, mtk_irq_seninf, 0,
+				dev_name(dev), core);
+	if (ret) {
+		dev_dbg(dev, "failed to request irq=%d\n", irq);
+		return ret;
+	}
+	dev_dbg(dev, "registered irq=%d\n", irq);
+
+	/* default platform properties */
+	core->cphy_settle_delay_dt = SENINF_CPHY_SETTLE_DELAY_DT;
+	core->dphy_settle_delay_dt = SENINF_DPHY_SETTLE_DELAY_DT;
+	core->settle_delay_ck = SENINF_SETTLE_DELAY_CK;
+	core->hs_trail_parameter = SENINF_HS_TRAIL_PARAMETER;
+
+	/* read platform properties from device tree */
+	of_property_read_u32(dev->of_node, "cphy_settle_delay_dt",
+			     &core->cphy_settle_delay_dt);
+	of_property_read_u32(dev->of_node, "dphy_settle_delay_dt",
+			     &core->dphy_settle_delay_dt);
+	of_property_read_u32(dev->of_node, "settle_delay_ck",
+			     &core->settle_delay_ck);
+	of_property_read_u32(dev->of_node, "hs_trail_parameter",
+			     &core->hs_trail_parameter);
+
+	for (i = 0; i < CLK_MAXCNT; i++) {
+		core->clk[i] = devm_clk_get(dev, clk_names[i]);
+		if (IS_ERR(core->clk[i])) {
+			dev_info(dev, "failed to get %s\n", clk_names[i]);
+			core->clk[i] = NULL;
+			//return -EINVAL;
+		}
+	}
+
+	ret = of_platform_populate(dev->of_node, NULL, NULL, dev);
+	if (ret) {
+		dev_info(dev, "%s: failed to create sub devices\n", __func__);
+		return ret;
+	}
+
+#ifdef SENINF_DVFS_READY
+	ret = seninf_dfs_init(&core->dfs, dev);
+	if (ret) {
+		dev_info(dev, "%s: failed to init dfs\n", __func__);
+		//return ret;
+	}
+#endif
+
+	ret = device_create_file(dev, &dev_attr_status);
+	if (ret)
+		dev_info(dev, "failed to create sysfs status\n");
+
+	ret = device_create_file(dev, &dev_attr_debug_ops);
+	if (ret)
+		dev_info(dev, "failed to create sysfs debug ops\n");
+
+	ret = device_create_file(dev, &dev_attr_err_status);
+	if (ret)
+		dev_info(dev, "failed to create sysfs status\n");
+
+	seninf_core_pm_runtime_enable(core);
+
+	kthread_init_worker(&core->seninf_worker);
+	core->seninf_kworker_task = kthread_run(kthread_worker_fn,
+				&core->seninf_worker, "seninf_worker");
+	if (IS_ERR(core->seninf_kworker_task)) {
+		dev_info(dev, "%s: failed to start seninf kthread worker\n",
+			__func__);
+		core->seninf_kworker_task = NULL;
+	}
+
+	dev_info(dev, "%s\n", __func__);
+
+	return 0;
+}
+
+static int seninf_core_remove(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct seninf_core *core = dev_get_drvdata(dev);
+
+	seninf_dfs_exit(&core->dfs);
+	of_platform_depopulate(dev);
+	seninf_core_pm_runtime_disable(core);
+	device_remove_file(dev, &dev_attr_status);
+	device_remove_file(dev, &dev_attr_debug_ops);
+	device_remove_file(dev, &dev_attr_err_status);
+
+	if (core->seninf_kworker_task)
+		kthread_stop(core->seninf_kworker_task);
+
+	dev_info(dev, "%s\n", __func__);
+
+	return 0;
+}
+
+static const struct of_device_id seninf_core_of_match[] = {
+	{.compatible = "mediatek,seninf-core"},
+	{},
+};
+MODULE_DEVICE_TABLE(of, seninf_core_of_match);
+
+struct platform_driver seninf_core_pdrv = {
+	.probe	= seninf_core_probe,
+	.remove	= seninf_core_remove,
+	.driver	= {
+		.name = "seninf-core",
+		.of_match_table = seninf_core_of_match,
+	},
+};
+
+static int get_csi_port(struct device *dev, int *port)
+{
+	int i, ret;
+	const char *name;
+
+	ret = of_property_read_string(dev->of_node, "csi-port", &name);
+	if (ret)
+		return ret;
+
+	for (i = 0; i < CSI_PORT_MAX_NUM; i++) {
+		if (!strcasecmp(name, csi_port_names[i])) {
+			*port = i;
+			return 0;
+		}
+	}
+
+	return -1;
+}
+
+static int seninf_subscribe_event(struct v4l2_subdev *sd,
+				  struct v4l2_fh *fh,
+				  struct v4l2_event_subscription *sub)
+{
+	switch (sub->type) {
+	case V4L2_EVENT_CTRL:
+		return v4l2_ctrl_subdev_subscribe_event(sd, fh, sub);
+	default:
+		return -EINVAL;
+	}
+}
+
+static void init_fmt(struct seninf_ctx *ctx)
+{
+	int i;
+
+	for (i = 0 ; i < ARRAY_SIZE(ctx->fmt); i++) {
+		ctx->fmt[i].format.code = MEDIA_BUS_FMT_SBGGR10_1X10;
+		ctx->fmt[i].format.width = DEFAULT_WIDTH;
+		ctx->fmt[i].format.height = DEFAULT_HEIGHT;
+		ctx->fmt[i].format.field = V4L2_FIELD_NONE;
+		ctx->fmt[i].format.colorspace = V4L2_COLORSPACE_SRGB;
+		ctx->fmt[i].format.xfer_func = V4L2_XFER_FUNC_DEFAULT;
+		ctx->fmt[i].format.ycbcr_enc = V4L2_YCBCR_ENC_DEFAULT;
+		ctx->fmt[i].format.quantization = V4L2_QUANTIZATION_DEFAULT;
+	}
+
+	for (i = 0; i < ARRAY_SIZE(ctx->vcinfo.vc); i++)
+		ctx->vcinfo.vc[i].pixel_mode = SENINF_DEF_PIXEL_MODE;
+}
+#ifdef CSI_EFUSE_SET
+static int dev_read_csi_efuse(struct seninf_ctx *ctx)
+{
+	struct nvmem_cell *cell;
+	size_t len = 0;
+	u32 *buf;
+
+	ctx->m_csi_efuse = 0x00000000;
+
+	cell = nvmem_cell_get(ctx->dev, "rg_csi");
+	dev_info(ctx->dev, "ctx->port = %d\n", ctx->port);
+	if (IS_ERR(cell)) {
+		if (PTR_ERR(cell) == -EPROBE_DEFER) {
+			dev_info(ctx->dev, "read csi efuse returned with error cell %d\n",
+				-EPROBE_DEFER-EPROBE_DEFER);
+			return PTR_ERR(cell);
+		}
+		dev_info(ctx->dev, "read csi efuse returned with error cell %d\n", -1);
+		return -1;
+	}
+	buf = (u32 *)nvmem_cell_read(cell, &len);
+	nvmem_cell_put(cell);
+	if (IS_ERR(buf)) {
+		dev_info(ctx->dev, "read csi efuse returned with error buf\n");
+		return PTR_ERR(buf);
+	}
+	ctx->m_csi_efuse = *buf;
+	kfree(buf);
+	dev_info(ctx->dev, "Efuse Data: 0x%08x\n", ctx->m_csi_efuse);
+
+	return 0;
+}
+#endif
+static const struct v4l2_mbus_framefmt fmt_default = {
+	.code = MEDIA_BUS_FMT_SBGGR10_1X10,
+	.width = DEFAULT_WIDTH,
+	.height = DEFAULT_HEIGHT,
+	.field = V4L2_FIELD_NONE,
+	.colorspace = V4L2_COLORSPACE_SRGB,
+	.xfer_func = V4L2_XFER_FUNC_DEFAULT,
+	.ycbcr_enc = V4L2_YCBCR_ENC_DEFAULT,
+	.quantization = V4L2_QUANTIZATION_DEFAULT,
+};
+
+static int mtk_cam_seninf_init_cfg(struct v4l2_subdev *sd,
+				   struct v4l2_subdev_state *sd_state)
+{
+	struct v4l2_mbus_framefmt *mf;
+	unsigned int i;
+
+	for (i = 0; i < sd->entity.num_pads; i++) {
+		mf = v4l2_subdev_get_try_format(sd, sd_state, i);
+		*mf = fmt_default;
+	}
+
+	return 0;
+}
+
+static int mtk_cam_seninf_set_fmt(struct v4l2_subdev *sd,
+				  struct v4l2_subdev_state *sd_state,
+				  struct v4l2_subdev_format *fmt)
+{
+	struct seninf_ctx *ctx = sd_to_ctx(sd);
+	struct v4l2_mbus_framefmt *format;
+	char bSinkFormatChanged = 0;
+
+	if (fmt->pad < PAD_SINK || fmt->pad >= PAD_MAXCNT)
+		return -EINVAL;
+
+	format = &ctx->fmt[fmt->pad].format;
+
+	if (fmt->which == V4L2_SUBDEV_FORMAT_TRY) {
+		*v4l2_subdev_get_try_format(sd, sd_state, fmt->pad) = fmt->format;
+		dev_dbg(ctx->dev, "s_fmt pad %d code/res 0x%x/%dx%d which %d=> 0x%x/%dx%d\n",
+			fmt->pad,
+			fmt->format.code,
+			fmt->format.width,
+			fmt->format.height,
+			fmt->which,
+			format->code,
+			format->width,
+			format->height);
+	} else {
+		/* NOTE: update vcinfo once the SINK format changed */
+		if (fmt->pad == PAD_SINK)
+			bSinkFormatChanged = 1;
+
+		format->code = fmt->format.code;
+		format->width = fmt->format.width;
+		format->height = fmt->format.height;
+
+		if (bSinkFormatChanged && !ctx->is_test_model)
+			mtk_cam_seninf_get_vcinfo(ctx);
+
+		dev_info(ctx->dev, "s_fmt pad %d code/res 0x%x/%dx%d which %d=> 0x%x/%dx%d\n",
+			fmt->pad,
+			fmt->format.code,
+			fmt->format.width,
+			fmt->format.height,
+			fmt->which,
+			format->code,
+			format->width,
+			format->height);
+	}
+
+	return 0;
+}
+
+static int mtk_cam_seninf_get_fmt(struct v4l2_subdev *sd,
+				  struct v4l2_subdev_state *sd_state,
+				  struct v4l2_subdev_format *fmt)
+{
+	struct seninf_ctx *ctx = sd_to_ctx(sd);
+	struct v4l2_mbus_framefmt *format;
+
+	if (fmt->pad < PAD_SINK || fmt->pad >= PAD_MAXCNT)
+		return -EINVAL;
+
+	format = &ctx->fmt[fmt->pad].format;
+
+	if (fmt->which == V4L2_SUBDEV_FORMAT_TRY) {
+		fmt->format = *v4l2_subdev_get_try_format(sd, sd_state, fmt->pad);
+	} else {
+		fmt->format.code = format->code;
+		fmt->format.width = format->width;
+		fmt->format.height = format->height;
+		fmt->format.field = format->field;
+		fmt->format.colorspace = format->colorspace;
+		fmt->format.xfer_func = format->xfer_func;
+		fmt->format.ycbcr_enc = format->ycbcr_enc;
+		fmt->format.quantization = format->quantization;
+	}
+
+	return 0;
+}
+
+static int set_test_model(struct seninf_ctx *ctx, char enable)
+{
+	struct seninf_vc *vc[] = {NULL, NULL, NULL, NULL, NULL};
+	int i = 0, vc_used = 0;
+	struct seninf_mux *mux;
+	struct seninf_dfs *dfs = &ctx->core->dfs;
+	int pref_idx[] = {0, 1, 2, 3, 4}; //FIXME
+
+	if (ctx->is_test_model == 1) {
+		vc[vc_used++] = mtk_cam_seninf_get_vc_by_pad(ctx, PAD_SRC_RAW0);
+	} else if (ctx->is_test_model == 2) {
+		vc[vc_used++] = mtk_cam_seninf_get_vc_by_pad(ctx, PAD_SRC_RAW0);
+		vc[vc_used++] = mtk_cam_seninf_get_vc_by_pad(ctx, PAD_SRC_RAW1);
+		vc[vc_used++] = mtk_cam_seninf_get_vc_by_pad(ctx, PAD_SRC_RAW2);
+	} else if (ctx->is_test_model == 3) {
+		vc[vc_used++] = mtk_cam_seninf_get_vc_by_pad(ctx, PAD_SRC_RAW0);
+		vc[vc_used++] = mtk_cam_seninf_get_vc_by_pad(ctx, PAD_SRC_PDAF0);
+#ifdef ISP7_1
+	} else if (ctx->is_test_model == 4) {
+		vc[vc_used++] = mtk_cam_seninf_get_vc_by_pad(ctx, PAD_SRC_RAW0);
+		vc[vc_used++] = mtk_cam_seninf_get_vc_by_pad(ctx, PAD_SRC_RAW1);
+		vc[vc_used++] = mtk_cam_seninf_get_vc_by_pad(ctx, PAD_SRC_RAW2);
+		vc[vc_used++] = mtk_cam_seninf_get_vc_by_pad(ctx, PAD_SRC_PDAF0);
+		vc[vc_used++] = mtk_cam_seninf_get_vc_by_pad(ctx, PAD_SRC_PDAF1);
+	} else if (ctx->is_test_model == 5) {
+		vc[vc_used++] = mtk_cam_seninf_get_vc_by_pad(ctx, PAD_SRC_RAW0);
+		vc[vc_used++] = mtk_cam_seninf_get_vc_by_pad(ctx, PAD_SRC_RAW_W0);
+#endif
+	} else {
+		dev_info(ctx->dev, "testmodel %d invalid\n", ctx->is_test_model);
+		return -1;
+	}
+
+	for (; i < vc_used; ++i) {
+		if (!vc[i]) {
+			dev_info(ctx->dev, "vc not found\n");
+			return -1;
+		}
+	}
+
+	if (enable) {
+		pm_runtime_get_sync(ctx->dev);
+		if (ctx->core->clk[CLK_TOP_CAMTM])
+			clk_prepare_enable(ctx->core->clk[CLK_TOP_CAMTM]);
+
+		if (dfs->cnt)
+			seninf_dfs_set(ctx, dfs->freqs[dfs->cnt - 1]);
+
+		for (i = 0; i < vc_used; ++i) {
+			mux = mtk_cam_seninf_mux_get_pref(ctx,
+							  pref_idx,
+							  ARRAY_SIZE(pref_idx));
+			if (!mux)
+				return -EBUSY;
+			vc[i]->mux = mux->idx;
+			vc[i]->cam = ctx->pad2cam[vc[i]->out_pad];
+			vc[i]->enable = 1;
+
+			dev_info(ctx->dev, "test mode mux %d, cam %d, pixel mode %d\n",
+					vc[i]->mux, vc[i]->cam, vc[i]->pixel_mode);
+
+			g_seninf_ops->_set_test_model(ctx,
+					vc[i]->mux, vc[i]->cam, vc[i]->pixel_mode);
+
+			if (vc[i]->out_pad == PAD_SRC_PDAF0)
+				mdelay(40);
+			else
+				udelay(40);
+		}
+	} else {
+		g_seninf_ops->_set_idle(ctx);
+		mtk_cam_seninf_release_mux(ctx);
+		if (dfs->cnt)
+			seninf_dfs_set(ctx, 0);
+
+		if (ctx->core->clk[CLK_TOP_CAMTM])
+			clk_disable_unprepare(ctx->core->clk[CLK_TOP_CAMTM]);
+		pm_runtime_put_sync(ctx->dev);
+	}
+
+	ctx->streaming = enable;
+
+	return 0;
+}
+
+static int config_hw(struct seninf_ctx *ctx)
+{
+	int i, intf, skip_mux_ctrl;
+	int hsPol, vsPol, vc_sel, dt_sel, dt_en;
+	struct seninf_vcinfo *vcinfo;
+	struct seninf_vc *vc;
+	struct seninf_mux *mux, *mux_by_grp[SENINF_VC_MAXCNT] = {0};
+
+	intf = ctx->seninfIdx;
+	vcinfo = &ctx->vcinfo;
+
+	g_seninf_ops->_reset(ctx, intf);
+
+	g_seninf_ops->_set_vc(ctx, intf, vcinfo);
+
+	g_seninf_ops->_set_csi_mipi(ctx);
+
+	// TODO
+	hsPol = 0;
+	vsPol = 0;
+
+	for (i = 0; i < vcinfo->cnt; i++) {
+		vc = &vcinfo->vc[i];
+
+		vc->enable = mtk_cam_seninf_is_vc_enabled(ctx, vc);
+		if (!vc->enable) {
+			dev_info(ctx->dev, "vc[%d] feature %d, pad %d. skip\n",
+				 i, vc->feature, vc->out_pad);
+			continue;
+		}
+
+		/* alloc mux by group */
+		if (mux_by_grp[vc->group]) {
+			mux = mux_by_grp[vc->group];
+			skip_mux_ctrl = 1;
+		} else {
+			int pref_idx[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
+					10, 11, 12, 13, 14, 15,	16, 17, 18, 19, 20, 21 };
+			mux = mux_by_grp[vc->group] =
+				//mtk_cam_seninf_mux_get(ctx);
+				mtk_cam_seninf_mux_get_pref(ctx,
+						pref_idx,
+						g_seninf_ops->pref_mux_num);
+			skip_mux_ctrl = 0;
+		}
+
+		if (!mux) {
+			mtk_cam_seninf_release_mux(ctx);
+			return -EBUSY;
+		}
+
+		vc->mux = mux->idx;
+		vc->cam = ctx->pad2cam[vc->out_pad];
+
+		if (!skip_mux_ctrl) {
+			g_seninf_ops->_mux(ctx, vc->mux);
+			g_seninf_ops->_set_mux_ctrl(ctx, vc->mux,
+						    hsPol, vsPol,
+				MIPI_SENSOR + vc->group,
+				vc->pixel_mode);
+
+			g_seninf_ops->_set_top_mux_ctrl(ctx, vc->mux, intf);
+
+			//TODO
+			//mtk_cam_seninf_set_mux_crop(ctx, vc->mux, 0, 2327, 0);
+		}
+		dev_info(ctx->dev, "ctx->pad2cam[%d] %d vc->out_pad %d vc->cam %d, i %d",
+			vc->out_pad, ctx->pad2cam[vc->out_pad], vc->out_pad, vc->cam, i);
+
+		if (vc->cam != 0xff) {
+			vc_sel = vc->vc;
+			dt_sel = vc->dt;
+			dt_en = !!dt_sel;
+
+			/* CMD_SENINF_FINALIZE_CAM_MUX */
+			g_seninf_ops->_set_cammux_vc(ctx, vc->cam,
+						     vc_sel, dt_sel, dt_en, dt_en);
+			g_seninf_ops->_set_cammux_src(ctx, vc->mux, vc->cam,
+						      vc->exp_hsize, vc->exp_vsize);
+			g_seninf_ops->_set_cammux_chk_pixel_mode(ctx,
+								 vc->cam,
+								 vc->pixel_mode);
+			g_seninf_ops->_cammux(ctx, vc->cam);
+
+			dev_info(ctx->dev, "vc[%d] pad %d intf %d mux %d cam %d\n",
+				 i, vc->out_pad, intf, vc->mux, vc->cam);
+
+#ifdef SENSOR_SECURE_MTEE_SUPPORT
+			if (ctx->is_secure == 1) {
+				dev_info(ctx->dev, "Sensor kernel init seninf_ca");
+				if (!seninf_ca_open_session())
+					dev_info(ctx->dev, "seninf_ca_open_session fail");
+
+				dev_info(ctx->dev, "Sensor kernel ca_checkpipe");
+				seninf_ca_checkpipe(ctx->SecInfo_addr);
+			}
+#endif
+
+		} else
+			dev_info(ctx->dev, "not set camtg yet, vc[%d] pad %d intf %d mux %d cam %d\n",
+					 i, vc->out_pad, intf, vc->mux, vc->cam);
+	}
+	return 0;
+}
+
+//TODO by wiki, pclk NOT use
+static int calc_buffered_pixel_rate(struct device *dev,
+				    s64 width, s64 height,
+				    s64 hblank, s64 vblank,
+				    int fps_n, int fps_d, s64 *result)
+{
+	s64 buffered_pixel_rate;
+	s64 orig_pixel_rate = *result;
+	s64 pclk;
+	s64 k;
+
+	/* calculate pclk */
+	pclk = (width + hblank) * (height + vblank) * fps_n;
+	do_div(pclk, fps_d);
+
+	/* calculate buffered pixel_rate */
+	buffered_pixel_rate = orig_pixel_rate * width;
+	k = HW_BUF_EFFECT * orig_pixel_rate;
+	do_div(k, ISP_CLK_LOW);
+	do_div(buffered_pixel_rate, (width + hblank - k));
+	*result = buffered_pixel_rate;
+
+	dev_info(
+		dev,
+		"%s: w %lld h %lld hb %lld vb %lld fps %d/%d pclk %lld->%lld orig %lld k %lld hbe %d\n",
+		__func__, width, height, hblank, vblank,
+		fps_n, fps_d, pclk, buffered_pixel_rate, orig_pixel_rate, k, HW_BUF_EFFECT);
+
+	return 0;
+}
+
+static int get_buffered_pixel_rate(struct seninf_ctx *ctx,
+				   struct v4l2_subdev *sd, int sd_pad_idx,
+				   s64 *result)
+{
+	int ret;
+	struct v4l2_ctrl *ctrl;
+	struct v4l2_subdev_format fmt;
+	struct v4l2_subdev_frame_interval fi;
+	s64 width, height, hblank, vblank;
+
+	fmt.pad = sd_pad_idx;
+	fmt.which = V4L2_SUBDEV_FORMAT_ACTIVE;
+	ret = v4l2_subdev_call(sd, pad, get_fmt, NULL, &fmt);
+	if (ret) {
+		dev_info(ctx->dev, "no get_fmt in %s\n", sd->name);
+		return ret;
+	}
+
+	width = fmt.format.width;
+	height = fmt.format.height;
+
+	memset(&fi, 0, sizeof(fi));
+	fi.pad = sd_pad_idx;
+	ret = v4l2_subdev_call(sd, video, g_frame_interval, &fi);
+	if (ret) {
+		dev_info(ctx->dev, "no g_frame_interval in %s\n", sd->name);
+		return ret;
+	}
+
+	ctrl = v4l2_ctrl_find(sd->ctrl_handler, V4L2_CID_HBLANK);
+	if (!ctrl) {
+		dev_info(ctx->dev, "no hblank in %s\n", sd->name);
+		return -EINVAL;
+	}
+
+	hblank = v4l2_ctrl_g_ctrl(ctrl);
+
+	ctrl = v4l2_ctrl_find(sd->ctrl_handler, V4L2_CID_VBLANK);
+	if (!ctrl) {
+		dev_info(ctx->dev, "no vblank in %s\n", sd->name);
+		return -EINVAL;
+	}
+
+	vblank = v4l2_ctrl_g_ctrl(ctrl);
+
+	/* update fps */
+	ctx->fps_n = fi.interval.denominator;
+	ctx->fps_d = fi.interval.numerator;
+
+	return calc_buffered_pixel_rate(ctx->dev, width, height, hblank, vblank,
+					ctx->fps_n, ctx->fps_d, result);
+}
+
+static int get_pixel_rate(struct seninf_ctx *ctx, struct v4l2_subdev *sd,
+			  s64 *result)
+{
+	struct v4l2_ctrl *ctrl;
+
+	ctrl = v4l2_ctrl_find(sd->ctrl_handler, V4L2_CID_PIXEL_RATE);
+	if (!ctrl) {
+		dev_info(ctx->dev, "no pixel rate in subdev %s\n", sd->name);
+		return -EINVAL;
+	}
+
+	*result = v4l2_ctrl_g_ctrl_int64(ctrl);
+
+	return 0;
+}
+
+static int get_mbus_config(struct seninf_ctx *ctx, struct v4l2_subdev *sd)
+{
+	struct v4l2_mbus_config cfg;
+	int ret;
+
+	ret = v4l2_subdev_call(sd, pad, get_mbus_config, ctx->sensor_pad_idx, &cfg);
+	if (ret) {
+		dev_info(ctx->dev, "no g_mbus_config in %s\n",
+			 sd->entity.name);
+		return -1;
+	}
+
+	ctx->is_cphy = cfg.type == V4L2_MBUS_CSI2_CPHY;
+	ctx->num_data_lanes = cfg.bus.mipi_csi2.num_data_lanes;
+
+	return 0;
+}
+
+//static int update_isp_clk(struct seninf_ctx *ctx)
+int update_isp_clk(struct seninf_ctx *ctx)
+{
+	int i, ret, pixelmode;
+	struct seninf_dfs *dfs = &ctx->core->dfs;
+	s64 pixel_rate = -1, dfs_freq;
+	struct seninf_vc *vc;
+
+
+	if (!dfs->cnt)
+		return 0;
+
+	vc = mtk_cam_seninf_get_vc_by_pad(ctx, PAD_SRC_RAW0);
+	if (!vc) {
+		dev_info(ctx->dev, "failed to get vc\n");
+		return -1;
+	}
+	dev_info(ctx->dev,
+		"%s dfs->cnt %d pixel mode %d customized_pixel_rate %lld, buffered_pixel_rate %lld mipi_pixel_rate %lld\n",
+		__func__,
+		dfs->cnt,
+		vc->pixel_mode,
+		ctx->customized_pixel_rate,
+		ctx->buffered_pixel_rate,
+		ctx->mipi_pixel_rate);
+	//Use SensorPixelrate
+	if (ctx->customized_pixel_rate)
+		pixel_rate = ctx->customized_pixel_rate;
+	else if (ctx->buffered_pixel_rate)
+		pixel_rate = ctx->buffered_pixel_rate;
+	else if (ctx->mipi_pixel_rate)
+		pixel_rate = ctx->mipi_pixel_rate;
+	else {
+		dev_info(ctx->dev, "failed to get pixel_rate\n");
+		return -EINVAL;
+	}
+
+	pixelmode = vc->pixel_mode;
+	for (i = 0; i < dfs->cnt; i++) {
+		dfs_freq = dfs->freqs[i];
+		dfs_freq = dfs_freq * (100 - SENINF_CLK_MARGIN_IN_PERCENT);
+		do_div(dfs_freq, 100);
+		if ((dfs_freq << pixelmode) >= pixel_rate)
+			break;
+	}
+
+	if (i == dfs->cnt) {
+		dev_info(ctx->dev, "mux is overrun. please adjust pixelmode\n");
+		return -EINVAL;
+	}
+
+	ret = seninf_dfs_set(ctx, dfs->freqs[i]);
+	if (ret) {
+		dev_info(ctx->dev, "failed to set freq\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+static int debug_err_detect_initialize(struct seninf_ctx *ctx)
+{
+	struct seninf_core *core;
+	struct seninf_ctx *ctx_;
+
+	core = dev_get_drvdata(ctx->dev->parent);
+
+	core->csi_irq_en_flag = 0;
+	core->vsync_irq_en_flag = 0;
+
+	list_for_each_entry(ctx_, &core->list, list) {
+		ctx_->data_not_enough_flag = 0;
+		ctx_->err_lane_resync_flag = 0;
+		ctx_->crc_err_flag = 0;
+		ctx_->ecc_err_double_flag = 0;
+		ctx_->ecc_err_corrected_flag = 0;
+		ctx_->fifo_overrun_flag = 0;
+		ctx_->size_err_flag = 0;
+		ctx_->data_not_enough_cnt = 0;
+		ctx_->err_lane_resync_cnt = 0;
+		ctx_->crc_err_cnt = 0;
+		ctx_->ecc_err_double_cnt = 0;
+		ctx_->ecc_err_corrected_cnt = 0;
+		ctx_->fifo_overrun_cnt = 0;
+		ctx_->size_err_cnt = 0;
+	}
+
+	return 0;
+}
+
+static int seninf_s_stream(struct v4l2_subdev *sd, int enable)
+{
+#ifdef SENSOR_SECURE_MTEE_SUPPORT
+	u32 ret_gz;
+#endif
+	int ret;
+	struct seninf_ctx *ctx = sd_to_ctx(sd);
+
+	if (ctx->streaming == enable)
+		return 0;
+
+	if (ctx->is_test_model)
+		return set_test_model(ctx, enable);
+
+	if (!ctx->sensor_sd) {
+		dev_info(ctx->dev, "no sensor\n");
+		return -EFAULT;
+	}
+
+	if (enable) {
+		debug_err_detect_initialize(ctx);
+		get_mbus_config(ctx, ctx->sensor_sd);
+
+		get_pixel_rate(ctx, ctx->sensor_sd, &ctx->mipi_pixel_rate);
+
+		ctx->buffered_pixel_rate = ctx->mipi_pixel_rate;
+		get_buffered_pixel_rate(ctx, ctx->sensor_sd,
+					ctx->sensor_pad_idx, &ctx->buffered_pixel_rate);
+
+		ret = pm_runtime_get_sync(ctx->dev);
+		if (ret < 0) {
+			dev_info(ctx->dev, "%s pm_runtime_get_sync ret %d\n", __func__, ret);
+			pm_runtime_put_noidle(ctx->dev);
+			return ret;
+		}
+
+		update_isp_clk(ctx);
+		ret = config_hw(ctx);
+		if (ret) {
+			dev_info(ctx->dev, "config_seninf_hw ret %d\n", ret);
+			return ret;
+		}
+
+		notify_fsync_cammux_usage(ctx);
+
+#ifdef SENINF_VC_ROUTING
+		//update_sensor_frame_desc(ctx);
+#endif
+
+		ret = v4l2_subdev_call(ctx->sensor_sd, video, s_stream, 1);
+		if (ret) {
+			dev_info(ctx->dev, "sensor stream-on ret %d\n", ret);
+			return  ret;
+		}
+#ifdef SENINF_UT_DUMP
+		g_seninf_ops->_debug(ctx);
+#endif
+
+	} else {
+		ret = v4l2_subdev_call(ctx->sensor_sd, video, s_stream, 0);
+		if (ret) {
+			dev_info(ctx->dev, "sensor stream-off ret %d\n", ret);
+			return ret;
+		}
+#ifdef SENSOR_SECURE_MTEE_SUPPORT
+		if (ctx->is_secure == 1) {
+			dev_info(ctx->dev, "sensor kernel ca_free");
+			seninf_ca_free();
+
+			dev_info(ctx->dev, "close seninf_ca");
+			ret_gz = seninf_ca_close_session();
+			ctx->is_secure = 0;
+		}
+#endif
+		g_seninf_ops->_set_idle(ctx);
+		mtk_cam_seninf_release_mux(ctx);
+		seninf_dfs_set(ctx, 0);
+		g_seninf_ops->_poweroff(ctx);
+		pm_runtime_put_sync(ctx->dev);
+	}
+
+	ctx->streaming = enable;
+	return 0;
+}
+
+static const struct v4l2_subdev_pad_ops seninf_subdev_pad_ops = {
+#ifdef ISP7_1
+	.link_validate = mtk_cam_link_validate,
+#else
+	.link_validate = v4l2_subdev_link_validate_default,
+#endif
+	.init_cfg = mtk_cam_seninf_init_cfg,
+	.set_fmt = mtk_cam_seninf_set_fmt,
+	.get_fmt = mtk_cam_seninf_get_fmt,
+};
+
+static const struct v4l2_subdev_video_ops seninf_subdev_video_ops = {
+	.s_stream = seninf_s_stream,
+};
+
+static struct v4l2_subdev_core_ops seninf_subdev_core_ops = {
+	.subscribe_event	= seninf_subscribe_event,
+	.unsubscribe_event	= v4l2_event_subdev_unsubscribe,
+};
+
+static struct v4l2_subdev_ops seninf_subdev_ops = {
+	.core	= &seninf_subdev_core_ops,
+	.video	= &seninf_subdev_video_ops,
+	.pad	= &seninf_subdev_pad_ops,
+};
+
+static int seninf_link_setup(struct media_entity *entity,
+			     const struct media_pad *local,
+				 const struct media_pad *remote, u32 flags)
+{
+	struct v4l2_subdev *sd;
+	struct seninf_ctx *ctx;
+
+	sd = media_entity_to_v4l2_subdev(entity);
+	ctx = v4l2_get_subdevdata(sd);
+
+	if (local->flags & MEDIA_PAD_FL_SOURCE) {
+		if (flags & MEDIA_LNK_FL_ENABLED) {
+			if (!mtk_cam_seninf_get_vc_by_pad(ctx, local->index)) {
+				dev_info(ctx->dev,
+					 "%s enable link w/o vc_info pad idex %d\n",
+					 __func__, local->index);
+			}
+		}
+	} else {
+		/* NOTE: update vcinfo once the link becomes enabled */
+		if (flags & MEDIA_LNK_FL_ENABLED) {
+			ctx->sensor_sd =
+				media_entity_to_v4l2_subdev(remote->entity);
+			ctx->sensor_pad_idx = remote->index;
+			mtk_cam_seninf_get_vcinfo(ctx);
+		}
+	}
+
+	return 0;
+}
+
+static const struct media_entity_operations seninf_media_ops = {
+	.link_setup = seninf_link_setup,
+	.link_validate = v4l2_subdev_link_validate,
+};
+
+static int seninf_notifier_bound(struct v4l2_async_notifier *notifier,
+				 struct v4l2_subdev *sd,
+					 struct v4l2_async_subdev *asd)
+{
+	struct seninf_ctx *ctx = notifier_to_ctx(notifier);
+	int ret;
+
+	dev_info(ctx->dev, "%s bounded\n", sd->entity.name);
+
+	ret = media_create_pad_link(&sd->entity, 0,
+				    &ctx->subdev.entity, 0, 0);
+	if (ret) {
+		dev_info(ctx->dev,
+			"failed to create link for %s\n",
+			sd->entity.name);
+		return ret;
+	}
+
+	ret = v4l2_device_register_subdev_nodes(ctx->subdev.v4l2_dev);
+	if (ret) {
+		dev_info(ctx->dev, "failed to create subdev nodes\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+static void seninf_notifier_unbind(struct v4l2_async_notifier *notifier,
+				   struct v4l2_subdev *sd,
+					   struct v4l2_async_subdev *asd)
+{
+	struct seninf_ctx *ctx = notifier_to_ctx(notifier);
+
+	dev_info(ctx->dev, "%s is unbounded\n", sd->entity.name);
+}
+
+static const struct v4l2_async_notifier_operations seninf_async_ops = {
+	.bound = seninf_notifier_bound,
+	.unbind = seninf_notifier_unbind,
+};
+
+/* NOTE: update vcinfo once test_model switches */
+static int seninf_test_pattern(struct seninf_ctx *ctx, u32 pattern)
+{
+	switch (pattern) {
+	case 0:
+		if (ctx->streaming)
+			return -EBUSY;
+		ctx->is_test_model = 0;
+		mtk_cam_seninf_get_vcinfo(ctx);
+		dev_info(ctx->dev, "test pattern off\n");
+		break;
+	case 1:// RAW only
+	case 2:// Stagger: 3 expo
+	case 3:// 1 RAW + 1 PD
+#ifdef ISP7_1
+	case 4:// 3 RAW + 2 PD
+	case 5:// 1 RAW + 1 W channel
+#endif
+		if (ctx->streaming)
+			return -EBUSY;
+		ctx->is_test_model = pattern;
+		mtk_cam_seninf_get_vcinfo_test(ctx);
+		dev_info(ctx->dev, "test pattern on\n");
+		break;
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+#ifdef SENINF_DEBUG
+static int seninf_test_streamon(struct seninf_ctx *ctx, u32 en)
+{
+#ifdef SECURE_UT
+	ctx->is_secure = 1;
+	ctx->SecInfo_addr = 0x53;
+#endif
+	if (en) {
+		ctx->is_test_streamon = 1;
+		mtk_cam_seninf_alloc_cam_mux(ctx);
+		seninf_s_stream(&ctx->subdev, 1);
+	} else {
+		seninf_s_stream(&ctx->subdev, 0);
+		mtk_cam_seninf_release_cam_mux(ctx);
+		ctx->is_test_streamon = 0;
+	}
+
+	return 0;
+}
+#endif
+
+static int mtk_cam_seninf_set_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct seninf_ctx *ctx = ctrl_hdl_to_ctx(ctrl->handler);
+	int ret;
+	//struct seninf_vc *vc = NULL;
+
+	switch (ctrl->id) {
+	case V4L2_CID_TEST_PATTERN:
+		ret = seninf_test_pattern(ctx, ctrl->val);
+		break;
+	case V4L2_CID_MTK_SENINF_S_STREAM:
+		{
+			ret = seninf_s_stream(&ctx->subdev, ctrl->val);
+		}
+		break;
+	case V4L2_CID_MTK_SENINF_S_FRAME_DESC:
+		{
+			struct mtk_mbus_frame_desc *fdesc =
+				(struct mtk_mbus_frame_desc *)ctrl->p_new.p;
+
+			if (fdesc->num_entries > MTK_FRAME_DESC_ENTRY_MAX) {
+				dev_info(ctx->dev, "Invalid frame desc entry.\n");
+				return -EINVAL;
+			}
+
+			/* save description for route select */
+			memcpy(&ctx->fdesc, fdesc, sizeof(struct mtk_mbus_frame_desc));
+			ret = 0;
+		}
+		break;
+#ifdef SENINF_DEBUG
+	case V4L2_CID_MTK_TEST_STREAMON:
+		ret = seninf_test_streamon(ctx, ctrl->val);
+		break;
+#endif
+	default:
+		ret = 0;
+		dev_info(ctx->dev, "%s Unhandled id:0x%x, val:0x%x\n",
+			 __func__, ctrl->id, ctrl->val);
+		break;
+	}
+
+	return ret;
+}
+
+static const struct v4l2_ctrl_ops seninf_ctrl_ops = {
+	.s_ctrl = mtk_cam_seninf_set_ctrl,
+};
+
+static int seninf_open(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)
+{
+	struct seninf_ctx *ctx = sd_to_ctx(sd);
+	struct seninf_core *core;
+
+	core = dev_get_drvdata(ctx->dev->parent);
+
+	mutex_lock(&ctx->mutex);
+	ctx->open_refcnt++;
+	core->pid = find_get_pid(current->pid);
+
+	if (ctx->open_refcnt == 1)
+		dev_info(ctx->dev, "%s open_refcnt %d\n", __func__, ctx->open_refcnt);
+
+	mutex_unlock(&ctx->mutex);
+
+	return 0;
+}
+
+static int seninf_close(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)
+{
+	struct seninf_ctx *ctx = sd_to_ctx(sd);
+
+	mutex_lock(&ctx->mutex);
+	ctx->open_refcnt--;
+
+
+	if (!ctx->open_refcnt) {
+		dev_info(ctx->dev, "%s open_refcnt %d\n", __func__, ctx->open_refcnt);
+#ifdef SENINF_DEBUG
+		if (ctx->is_test_streamon)
+			seninf_test_streamon(ctx, 0);
+		else if (ctx->streaming)
+#else
+		if (ctx->streaming)
+#endif
+			seninf_s_stream(&ctx->subdev, 0);
+	}
+
+	mutex_unlock(&ctx->mutex);
+
+	return 0;
+}
+
+static const struct v4l2_subdev_internal_ops seninf_internal_ops = {
+	.open = seninf_open,
+	.close = seninf_close,
+};
+
+static const char * const seninf_test_pattern_menu[] = {
+	"Disabled",
+	"generate_test_pattern",
+	"generate_test_pattern_stagger",
+	"generate_test_pattern_pd",
+#ifdef ISP7_1
+	"generate_test_pattern_5_src_pad",
+	"generate_test_pattern_raw_and_w",
+#endif
+};
+
+#ifdef SENINF_DEBUG
+static const struct v4l2_ctrl_config cfg_test_streamon = {
+	.ops = &seninf_ctrl_ops,
+	.id = V4L2_CID_MTK_TEST_STREAMON,
+	.name = "test_streamon",
+	.type = V4L2_CTRL_TYPE_BOOLEAN,
+	.flags = V4L2_CTRL_FLAG_EXECUTE_ON_WRITE,
+	.max = 1,
+	.step = 1,
+};
+#endif
+
+static const struct v4l2_ctrl_config cfg_s_stream = {
+	.ops = &seninf_ctrl_ops,
+	.id = V4L2_CID_MTK_SENINF_S_STREAM,
+	.name = "set_stream",
+	.type = V4L2_CTRL_TYPE_BOOLEAN,
+	.flags = V4L2_CTRL_FLAG_EXECUTE_ON_WRITE,
+	.max = 1,
+	.step = 1,
+};
+
+static const struct v4l2_ctrl_config cfg_s_frame_desc = {
+	.ops = &seninf_ctrl_ops,
+	.id = V4L2_CID_MTK_SENINF_S_FRAME_DESC,
+	.name = "set_frame_desc",
+	.type = V4L2_CTRL_TYPE_U32,
+	.flags = V4L2_CTRL_FLAG_EXECUTE_ON_WRITE,
+	.min = 0x0,
+	.max = 0xFFFFFFFF,
+	.step = 1,
+	.def = 0x0,
+	.dims = {sizeof_u32(struct mtk_mbus_frame_desc)},
+};
+
+static int seninf_initialize_controls(struct seninf_ctx *ctx)
+{
+	struct v4l2_ctrl_handler *handler;
+	int ret;
+
+	handler = &ctx->ctrl_handler;
+	ret = v4l2_ctrl_handler_init(handler, 2);
+	if (ret)
+		return ret;
+	v4l2_ctrl_new_std_menu_items(handler, &seninf_ctrl_ops,
+				     V4L2_CID_TEST_PATTERN,
+		ARRAY_SIZE(seninf_test_pattern_menu) - 1,
+		0, 0, seninf_test_pattern_menu);
+
+#ifdef SENINF_DEBUG
+	v4l2_ctrl_new_custom(handler, &cfg_test_streamon, NULL);
+#endif
+	v4l2_ctrl_new_custom(handler, &cfg_s_stream, NULL);
+
+	v4l2_ctrl_new_custom(handler, &cfg_s_frame_desc, NULL);
+
+	if (handler->error) {
+		ret = handler->error;
+		dev_info(ctx->dev,
+			"Failed to init controls(%d)\n", ret);
+		goto err_free_handler;
+	}
+
+	ctx->subdev.ctrl_handler = handler;
+	return 0;
+
+err_free_handler:
+	v4l2_ctrl_handler_free(handler);
+
+	return ret;
+}
+
+static int register_subdev(struct seninf_ctx *ctx, struct v4l2_device *v4l2_dev)
+{
+	int i, ret;
+	struct v4l2_subdev *sd = &ctx->subdev;
+	struct device *dev = ctx->dev;
+	struct media_pad *pads = ctx->pads;
+	struct v4l2_async_notifier *notifier = &ctx->notifier;
+
+	v4l2_subdev_init(sd, &seninf_subdev_ops);
+
+	sd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+	sd->flags |= V4L2_SUBDEV_FL_HAS_EVENTS;
+	sd->dev = dev;
+
+	if (strlen(dev->of_node->name) > 16)
+		snprintf(sd->name, sizeof(sd->name), "%s-%s",
+			 dev_driver_string(dev), &dev->of_node->name[16]);
+	else
+		snprintf(sd->name, sizeof(sd->name), "%s-%s",
+			 dev_driver_string(dev), csi_port_names[ctx->port]);
+
+	v4l2_set_subdevdata(sd, ctx);
+
+	sd->entity.function = MEDIA_ENT_F_VID_IF_BRIDGE;
+	sd->entity.ops = &seninf_media_ops;
+	sd->internal_ops = &seninf_internal_ops;
+
+	pads[PAD_SINK].flags = MEDIA_PAD_FL_SINK;
+	for (i = PAD_SRC_RAW0; i < PAD_MAXCNT; i++)
+		pads[i].flags = MEDIA_PAD_FL_SOURCE;
+
+	for (i = 0; i < PAD_MAXCNT; i++)
+		ctx->pad2cam[i] = 0xff;
+
+	ret = media_entity_pads_init(&sd->entity, PAD_MAXCNT, pads);
+	if (ret < 0) {
+		dev_info(dev, "failed to init pads\n");
+		return ret;
+	}
+
+	ret = v4l2_device_register_subdev(v4l2_dev, sd);
+	if (ret < 0) {
+		dev_info(dev, "failed to register subdev\n");
+		return ret;
+	}
+
+	v4l2_async_nf_init(notifier);
+	ret = v4l2_async_nf_parse_fwnode_endpoints
+		(dev, notifier, sizeof(struct v4l2_async_subdev), NULL);
+	if (ret < 0)
+		dev_info(dev, "no endpoint\n");
+
+	notifier->ops = &seninf_async_ops;
+	ret = v4l2_async_nf_register(v4l2_dev, notifier);
+	if (ret < 0) {
+		dev_info(dev, "failed to register notifier\n");
+		goto err_unregister_subdev;
+	}
+
+	return 0;
+
+err_unregister_subdev:
+	v4l2_device_unregister_subdev(sd);
+	v4l2_async_nf_cleanup(notifier);
+
+	return ret;
+}
+
+static void unregister_subdev(struct seninf_ctx *ctx)
+{
+	struct v4l2_subdev *sd = &ctx->subdev;
+
+	v4l2_async_nf_unregister(&ctx->notifier);
+	v4l2_async_nf_cleanup(&ctx->notifier);
+	v4l2_device_unregister_subdev(sd);
+	media_entity_cleanup(&sd->entity);
+}
+
+static int seninf_comp_bind(struct device *dev, struct device *master,
+			    void *data)
+{
+	struct mtk_cam_device *cam_dev = data;
+	struct v4l2_device *v4l2_dev = &cam_dev->v4l2_dev;
+	struct seninf_ctx *ctx = dev_get_drvdata(dev);
+
+	return register_subdev(ctx, v4l2_dev);
+}
+
+static void seninf_comp_unbind(struct device *dev, struct device *master,
+			       void *data)
+{
+	struct seninf_ctx *ctx = dev_get_drvdata(dev);
+
+	unregister_subdev(ctx);
+}
+
+static const struct component_ops seninf_comp_ops = {
+	.bind = seninf_comp_bind,
+	.unbind = seninf_comp_unbind,
+};
+
+static int seninf_probe(struct platform_device *pdev)
+{
+	int ret, port;
+	struct seninf_ctx *ctx;
+	struct device *dev = &pdev->dev;
+	struct seninf_core *core;
+
+	if (!dev->parent)
+		return -EPROBE_DEFER;
+
+	core = dev_get_drvdata(dev->parent);
+	if (!core)
+		return -EPROBE_DEFER;
+
+	ctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+
+	dev_set_drvdata(dev, ctx);
+	ctx->dev = dev;
+	ctx->core = core;
+	list_add(&ctx->list, &core->list);
+	INIT_LIST_HEAD(&ctx->list_mux);
+	INIT_LIST_HEAD(&ctx->list_cam_mux);
+
+	ctx->open_refcnt = 0;
+	mutex_init(&ctx->mutex);
+
+	ret = get_csi_port(dev, &port);
+	if (ret) {
+		dev_info(dev, "get_csi_port ret %d\n", ret);
+		return ret;
+	}
+
+	g_seninf_ops->_init_iomem(ctx, core->reg_if, core->reg_ana);
+	g_seninf_ops->_init_port(ctx, port);
+	init_fmt(ctx);
+
+	/* default platform properties */
+	//ctx->seninf_dphy_settle_delay_dt = 0;
+
+	/* read platform properties from device tree */
+	//of_property_read_u32(dev->of_node, "seninf_dphy_settle_delay_dt",
+	//	&ctx->seninf_dphy_settle_delay_dt);
+	//dev_info(dev, "seninf dphy settle delay dt = %u\n",
+	//	 ctx->seninf_dphy_settle_delay_dt);
+
+	ctx->cphy_settle_delay_dt = ctx->core->cphy_settle_delay_dt;
+	ctx->dphy_settle_delay_dt = ctx->core->dphy_settle_delay_dt;
+	ctx->settle_delay_ck = ctx->core->settle_delay_ck;
+	ctx->hs_trail_parameter = ctx->core->hs_trail_parameter;
+
+	of_property_read_u32(dev->of_node, "cphy_settle_delay_dt",
+		&ctx->cphy_settle_delay_dt);
+	of_property_read_u32(dev->of_node, "dphy_settle_delay_dt",
+		&ctx->dphy_settle_delay_dt);
+	of_property_read_u32(dev->of_node, "settle_delay_ck",
+		&ctx->settle_delay_ck);
+	of_property_read_u32(dev->of_node, "hs_trail_parameter",
+		&ctx->hs_trail_parameter);
+
+	dev_info(dev,
+		"seninf d_settlte/d_settle_ck/d_trail/c_settle= 0x%x/0x%x/0x%x/0x%x\n",
+		ctx->dphy_settle_delay_dt,
+		ctx->settle_delay_ck,
+		ctx->hs_trail_parameter,
+		ctx->cphy_settle_delay_dt);
+
+#ifdef CSI_EFUSE_SET
+	ret = dev_read_csi_efuse(ctx);
+	if (ret < 0)
+		dev_info(dev, "Failed to read efuse data\n");
+#endif
+
+	ret = seninf_initialize_controls(ctx);
+	if (ret) {
+		dev_info(dev, "Failed to initialize controls\n");
+		return ret;
+	}
+
+	ret = component_add(dev, &seninf_comp_ops);
+	if (ret < 0) {
+		dev_info(dev, "component_add failed\n");
+		goto err_free_handler;
+	}
+
+
+	pm_runtime_enable(dev);
+
+	dev_info(dev, "%s: port=%d\n", __func__, ctx->port);
+
+	return 0;
+
+err_free_handler:
+	v4l2_ctrl_handler_free(&ctx->ctrl_handler);
+
+	return ret;
+}
+
+static int runtime_suspend(struct device *dev)
+{
+	int i;
+	struct seninf_ctx *ctx = dev_get_drvdata(dev);
+	struct seninf_core *core = ctx->core;
+
+	mutex_lock(&core->mutex);
+
+	core->refcnt--;
+	if (core->refcnt == 0) {
+		i = CLK_TOP_SENINF_END;
+		do {
+			i--;
+			if (ctx->core->clk[i])
+				clk_disable_unprepare(ctx->core->clk[i]);
+		} while (i);
+		seninf_core_pm_runtime_put(core);
+		if (ctx->core->dfs.reg && regulator_is_enabled(ctx->core->dfs.reg))
+			regulator_disable(ctx->core->dfs.reg);
+
+	}
+
+	mutex_unlock(&core->mutex);
+
+	return 0;
+}
+
+static int runtime_resume(struct device *dev)
+{
+	int i;
+#ifdef ISP7_1
+	int ret;
+#endif
+	struct seninf_ctx *ctx = dev_get_drvdata(dev);
+	struct seninf_core *core = ctx->core;
+
+	mutex_lock(&core->mutex);
+
+	core->refcnt++;
+
+	if (core->refcnt == 1) {
+#ifdef ISP7_1
+		if (ctx->core->dfs.reg) {
+			ret = regulator_enable(ctx->core->dfs.reg);
+			if (ret < 0) {
+				dev_err(dev, "set voltage failed\n");
+				mutex_unlock(&core->mutex);
+				return ret;
+			}
+		}
+#endif
+		seninf_core_pm_runtime_get_sync(core);
+		for (i = 0; i < CLK_TOP_SENINF_END; i++) {
+			if (core->clk[i])
+				clk_prepare_enable(core->clk[i]);
+		}
+		g_seninf_ops->_disable_all_mux(ctx);
+		g_seninf_ops->_disable_all_cammux(ctx);
+	}
+
+	mutex_unlock(&core->mutex);
+
+	return 0;
+}
+
+static const struct dev_pm_ops pm_ops = {
+	SET_RUNTIME_PM_OPS(runtime_suspend, runtime_resume, NULL)
+};
+
+static int seninf_remove(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct seninf_ctx *ctx = dev_get_drvdata(dev);
+
+	if (ctx->streaming) {
+		g_seninf_ops->_set_idle(ctx);
+		mtk_cam_seninf_release_mux(ctx);
+	}
+
+	pm_runtime_disable(ctx->dev);
+
+	component_del(dev, &seninf_comp_ops);
+
+	v4l2_ctrl_handler_free(&ctx->ctrl_handler);
+
+	mutex_destroy(&ctx->mutex);
+
+	dev_info(dev, "%s\n", __func__);
+
+	return 0;
+}
+
+static const struct of_device_id seninf_of_match[] = {
+	{.compatible = "mediatek,seninf"},
+	{},
+};
+MODULE_DEVICE_TABLE(of, seninf_of_match);
+
+static int seninf_suspend(struct platform_device *pdev, pm_message_t mesg)
+{
+	return 0;
+}
+
+static int seninf_resume(struct platform_device *pdev)
+{
+	return 0;
+}
+
+struct platform_driver seninf_pdrv = {
+	.probe	= seninf_probe,
+	.remove	= seninf_remove,
+	.suspend = seninf_suspend,
+	.resume = seninf_resume,
+	.driver	= {
+		.name = "seninf",
+		.of_match_table = seninf_of_match,
+		.pm  = &pm_ops,
+	},
+};
+
+int mtk_cam_seninf_calc_pixelrate(struct device *dev, s64 width, s64 height,
+				  s64 hblank, s64 vblank,
+				  int fps_n, int fps_d,
+				  s64 sensor_pixel_rate)
+{
+	int ret;
+	s64 p_pixel_rate = sensor_pixel_rate;
+
+	ret = calc_buffered_pixel_rate(dev, width, height, hblank, vblank,
+				       fps_n, fps_d, &p_pixel_rate);
+	if (ret)
+		return sensor_pixel_rate;
+
+	return p_pixel_rate;
+}
+
+/* to be replaced by mtk_cam_seninf_calc_pixelrate() */
+int mtk_cam_seninf_get_pixelrate(struct v4l2_subdev *sd, s64 *p_pixel_rate)
+{
+	int ret;
+	s64 pixel_rate = -1;
+	struct seninf_ctx *ctx = sd_to_ctx(sd);
+
+	if (!ctx->sensor_sd) {
+		dev_info(ctx->dev, "no sensor\n");
+		return -EFAULT;
+	}
+
+	ret = get_buffered_pixel_rate(ctx,
+				      ctx->sensor_sd, ctx->sensor_pad_idx,
+				      &pixel_rate);
+	if (ret)
+		get_pixel_rate(ctx, ctx->sensor_sd, &pixel_rate);
+
+	if (pixel_rate <= 0) {
+		dev_info(ctx->dev, "failed to get pixel_rate\n");
+		return -EINVAL;
+	}
+
+	*p_pixel_rate = pixel_rate;
+
+	return 0;
+}
+
+#define SOF_TIMEOUT_RATIO 110
+int mtk_cam_seninf_check_timeout(struct v4l2_subdev *sd, u64 time_after_sof)
+{
+	struct seninf_ctx *ctx = sd_to_ctx(sd);
+	int ret =  -EINVAL;
+
+	dev_info(ctx->dev, "no timeout recheck for subdev %s\n", sd->name);
+	return ret;
+}
+
+
+int mtk_cam_seninf_dump(struct v4l2_subdev *sd)
+{
+	int ret = 0;
+	struct seninf_ctx *ctx = sd_to_ctx(sd);
+
+	ret = pm_runtime_get_sync(ctx->dev);
+	if (ret < 0) {
+		dev_info(ctx->dev, "%s pm_runtime_get_sync ret %d\n", __func__, ret);
+		pm_runtime_put_noidle(ctx->dev);
+		return ret;
+	}
+
+	if (ctx->streaming) {
+		ret = g_seninf_ops->_debug(sd_to_ctx(sd));
+#if ESD_RESET_SUPPORT
+		if (ret != 0)
+#else
+		if (0)
+#endif
+			reset_sensor(sd_to_ctx(sd));
+	} else
+		dev_info(ctx->dev, "%s should not dump during stream off\n", __func__);
+
+	pm_runtime_put_sync(ctx->dev);
+	return ret;
+}
+
+void mtk_cam_seninf_set_secure(struct v4l2_subdev *sd, int enable, unsigned int SecInfo_addr)
+{
+	struct seninf_ctx *ctx = sd_to_ctx(sd);
+
+	ctx->SecInfo_addr = SecInfo_addr;
+	dev_info(ctx->dev, "[%s]: %x, enable: %d\n", __func__, SecInfo_addr, enable);
+	ctx->is_secure = enable ? 1 : 0;
+}
+
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam-seninf-drv.h b/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam-seninf-drv.h
new file mode 100644
index 0000000000000000000000000000000000000000..c4a4d9b20e9d5ca39c6dc7265bb25b6af966f3cf
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam-seninf-drv.h
@@ -0,0 +1,13 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2022 MediaTek Inc.
+ */
+
+#ifndef __MTK_CAM_SENINF_DRV_H
+#define __MTK_CAM_SENINF_DRV_H
+
+extern struct platform_driver seninf_core_pdrv;
+extern struct platform_driver seninf_pdrv;
+
+#endif /*__MTK_CAM_SENINF_DRV_H*/
+
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam-seninf-hw.h b/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam-seninf-hw.h
new file mode 100644
index 0000000000000000000000000000000000000000..b7a5ede316fa0b6c8c08864dad314cef11dc7df8
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam-seninf-hw.h
@@ -0,0 +1,118 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+// Copyright (c) 2022 MediaTek Inc.
+
+#ifndef __MTK_CAM_SENINF_HW_H__
+#define __MTK_CAM_SENINF_HW_H__
+
+//#include <linux/irqreturn.h>
+#include <linux/interrupt.h>
+#include <linux/sched/signal.h>
+#include <linux/sched.h>
+#define seninf_aee_print(string, args...) \
+	pr_info("[SENINF] error:"string, ##args)
+
+enum SET_REG_KEYS {
+	REG_KEY_MIN = 0,
+	REG_KEY_SETTLE_CK = REG_KEY_MIN,
+	REG_KEY_SETTLE_DT,
+	REG_KEY_HS_TRAIL_EN,
+	REG_KEY_HS_TRAIL_PARAM,
+	REG_KEY_CSI_IRQ_STAT,
+	REG_KEY_CSI_RESYNC_CYCLE,
+	REG_KEY_MUX_IRQ_STAT,
+	REG_KEY_CAMMUX_IRQ_STAT,
+	REG_KEY_CAMMUX_VSYNC_IRQ_EN,
+	REG_KEY_CSI_IRQ_EN,
+	REG_KEY_MAX_NUM
+};
+
+#define SET_REG_KEYS_NAMES \
+	"RG_SETTLE_CK", \
+	"RG_SETTLE_DT", \
+	"RG_HS_TRAIL_EN", \
+	"RG_HS_TRAIL_PARAM", \
+	"RG_CSI_IRQ_STAT", \
+	"RG_CSI_RESYNC_CYCLE", \
+	"RG_MUX_IRQ_STAT", \
+	"RG_CAMMUX_IRQ_STAT", \
+	"REG_VSYNC_IRQ_EN", \
+	"RG_CSI_IRQ_EN", \
+
+struct mtk_cam_seninf_mux_meter {
+	u32 width;
+	u32 height;
+	u32 h_valid;
+	u32 h_blank;
+	u32 v_valid;
+	u32 v_blank;
+	s64 mipi_pixel_rate;
+	s64 vb_in_us;
+	s64 hb_in_us;
+	s64 line_time_in_us;
+};
+
+extern int update_isp_clk(struct seninf_ctx *ctx);
+
+struct mtk_cam_seninf_ops {
+	int (*_init_iomem)(struct seninf_ctx *ctx,
+			      void __iomem *if_base, void __iomem *ana_base);
+	int (*_init_port)(struct seninf_ctx *ctx, int port);
+	int (*_is_cammux_used)(struct seninf_ctx *ctx, int cam_mux);
+	int (*_cammux)(struct seninf_ctx *ctx, int cam_mux);
+	int (*_disable_cammux)(struct seninf_ctx *ctx, int cam_mux);
+	int (*_disable_all_cammux)(struct seninf_ctx *ctx);
+	int (*_set_top_mux_ctrl)(struct seninf_ctx *ctx,
+						int mux_idx, int seninf_src);
+	int (*_get_top_mux_ctrl)(struct seninf_ctx *ctx, int mux_idx);
+	int (*_get_cammux_ctrl)(struct seninf_ctx *ctx, int cam_mux);
+	u32 (*_get_cammux_res)(struct seninf_ctx *ctx, int cam_mux);
+	int (*_set_cammux_vc)(struct seninf_ctx *ctx, int cam_mux,
+					 int vc_sel, int dt_sel, int vc_en, int dt_en);
+	int (*_set_cammux_src)(struct seninf_ctx *ctx, int src,
+					  int target, int exp_hsize, int exp_vsize);
+	int (*_set_vc)(struct seninf_ctx *ctx, int seninfIdx,
+				  struct seninf_vcinfo *vcinfo);
+	int (*_set_mux_ctrl)(struct seninf_ctx *ctx, int mux,
+					int hsPol, int vsPol, int src_sel,
+					int pixel_mode);
+	int (*_set_mux_crop)(struct seninf_ctx *ctx, int mux,
+					int start_x, int end_x, int enable);
+	int (*_is_mux_used)(struct seninf_ctx *ctx, int mux);
+	int (*_mux)(struct seninf_ctx *ctx, int mux);
+	int (*_disable_mux)(struct seninf_ctx *ctx, int mux);
+	int (*_disable_all_mux)(struct seninf_ctx *ctx);
+	int (*_set_cammux_chk_pixel_mode)(struct seninf_ctx *ctx,
+							 int cam_mux, int pixelMode);
+	int (*_set_test_model)(struct seninf_ctx *ctx,
+					  int mux, int cam_mux, int pixelMode);
+	int (*_set_csi_mipi)(struct seninf_ctx *ctx);
+	int (*_poweroff)(struct seninf_ctx *ctx);
+	int (*_reset)(struct seninf_ctx *ctx, int seninfIdx);
+	int (*_set_idle)(struct seninf_ctx *ctx);
+	int (*_get_mux_meter)(struct seninf_ctx *ctx, int mux,
+					 struct mtk_cam_seninf_mux_meter *meter);
+	ssize_t (*_show_status)(struct device *dev, struct device_attribute *attr, char *buf);
+	int (*_switch_to_cammux_inner_page)(struct seninf_ctx *ctx, bool inner);
+	int (*_set_cammux_next_ctrl)(struct seninf_ctx *ctx, int src, int target);
+	int (*_update_mux_pixel_mode)(struct seninf_ctx *ctx, int mux, int pixel_mode);
+	int (*_irq_handler)(int irq, void *data);
+	int (*_set_sw_cfg_busy)(struct seninf_ctx *ctx, bool enable, int index);
+	int (*_set_cam_mux_dyn_en)(struct seninf_ctx *ctx, bool enable, int cam_mux, int index);
+	int (*_reset_cam_mux_dyn_en)(struct seninf_ctx *ctx, int index);
+	int (*_enable_global_drop_irq)(struct seninf_ctx *ctx, bool enable, int index);
+	int (*_enable_cam_mux_vsync_irq)(struct seninf_ctx *ctx, bool enable, int cam_mux);
+	int (*_disable_all_cam_mux_vsync_irq)(struct seninf_ctx *ctx);
+	int (*_debug)(struct seninf_ctx *ctx);
+	int (*_set_reg)(struct seninf_ctx *ctx, u32 key, u32 val);
+	ssize_t (*_show_err_status)(struct device *dev, struct device_attribute *attr, char *buf);
+	unsigned int seninf_num;
+	unsigned int mux_num;
+	unsigned int cam_mux_num;
+	unsigned int pref_mux_num;
+
+};
+
+extern struct mtk_cam_seninf_ops mtk_csi_phy_2_0;
+extern struct mtk_cam_seninf_ops *g_seninf_ops;
+
+#endif
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam-seninf-if.h b/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam-seninf-if.h
new file mode 100644
index 0000000000000000000000000000000000000000..c061418285cf4bc41828c05aec8845648d7fc103
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam-seninf-if.h
@@ -0,0 +1,88 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+// Copyright (c) 2022 MediaTek Inc.
+
+#ifndef __MTK_CAM_SENINF_IF_H__
+#define __MTK_CAM_SENINF_IF_H__
+
+int mtk_cam_seninf_get_pixelmode(struct v4l2_subdev *sd, int pad_id,
+				 int *pixelmode);
+
+int mtk_cam_seninf_set_pixelmode(struct v4l2_subdev *sd, int pad_id,
+				 int pixelmode);
+
+int mtk_cam_seninf_set_camtg(struct v4l2_subdev *sd, int pad_id, int camtg);
+
+int mtk_cam_seninf_get_pixelrate(struct v4l2_subdev *sd, s64 *pixelrate);
+
+int mtk_cam_seninf_calc_pixelrate(struct device *dev, s64 width, s64 height, s64 hblank,
+				  s64 vblank, int fps_n, int fps_d, s64 sensor_pixel_rate);
+
+int mtk_cam_seninf_dump(struct v4l2_subdev *sd);
+
+int mtk_cam_seninf_check_timeout(struct v4l2_subdev *sd, u64 time_waited);
+
+
+/**
+ * struct mtk_cam_seninf_mux_setting - mux setting change setting
+ * @seninf: sensor interface's V4L2 subdev
+ * @source: source pad id of the seninf subdev, to indicate the image
+ *          processing engine to be conncted
+ * @camtg: physical image processing engine's id (e.g. raw's device id)
+ */
+struct mtk_cam_seninf_mux_setting {
+	struct v4l2_subdev *seninf;
+	int source;
+	int camtg;
+	int enable;
+};
+
+/**
+ * typedef mtk_cam_seninf_mux_change_done_fnc - mux change fininshed callback
+ *
+ * @private: Private data passed from mtk_cam_seninf_streaming_mux_change.
+ *           In general, it is the request object indicate the mux changes.
+ *
+ * Returns true if the mux changes are all applied.
+ */
+typedef bool (*mtk_cam_seninf_mux_change_done_fn)(void *private);
+
+/**
+ * struct mtk_cam_seninf_mux_param - mux setting change parameters
+ * @settings: per mux settings
+ * @num: number of params
+ * @fnc: callback function when seninf driver finihsed all the mux changes.
+ * @private: Private data of the caller. The private data will be return from
+ *           seninf driver through mtk_cam_seninf_mux_change_done_fnc callback.
+ */
+struct mtk_cam_seninf_mux_param {
+	struct mtk_cam_seninf_mux_setting *settings;
+	int num;
+	mtk_cam_seninf_mux_change_done_fn func;
+	void *private;
+};
+
+/**
+ * struct mtk_cam_seninf_streaming_mux_change - change connection during streaming
+ * @param: a new connection from sensor interface to image processing engine
+ *
+ * To be called when camsys driver need to change the connection from sensor
+ * interface to image processing engine during streaming. It is a asynchronized
+ * call, the sensor interface driver will call back func to notify the caller.
+ *
+ * Returns true if the mux changes will be applied.
+ */
+bool
+mtk_cam_seninf_streaming_mux_change(struct mtk_cam_seninf_mux_param *param);
+
+
+struct mtk_seninf_sof_notify_param {
+	struct v4l2_subdev *sd;
+	unsigned int sof_cnt;
+};
+
+unsigned int
+mtk_cam_seninf_get_vc_feature(struct v4l2_subdev *sd, unsigned int pad);
+
+void
+mtk_cam_seninf_set_secure(struct v4l2_subdev *sd, int enable, unsigned int SecInfo_addr);
+#endif
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam-seninf-regs.h b/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam-seninf-regs.h
new file mode 100644
index 0000000000000000000000000000000000000000..5e01e2e86e3a8f27907f9f5a2021b997c576ccbd
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam-seninf-regs.h
@@ -0,0 +1,37 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+// Copyright (c) 2022 MediaTek Inc.
+
+#ifndef __MTK_CAM_SENINF_REGS_H__
+#define __MTK_CAM_SENINF_REGS_H__
+
+
+
+#define SENINF_BITS(base, reg, field, val) do { \
+	u32 __iomem *__p = base + reg; \
+	u32 __v = readl(__p); \
+	__v &= ~field##_MASK; \
+	__v |= (((val) << field##_SHIFT) & field##_MASK); \
+	writel(__v, __p); \
+} while (0)
+
+#define SENINF_READ_BITS(base, reg, field) \
+({ \
+	u32 __iomem *__p = base + reg; \
+	u32 __v = readl(__p); \
+	__v &= field##_MASK; \
+	__v >>= field##_SHIFT; \
+	__v; \
+})
+
+#define SENINF_READ_REG(base, reg) \
+({ \
+	u32 __iomem *__p = base + reg; \
+	u32 __v = readl(__p); \
+	__v; \
+})
+
+#define SENINF_WRITE_REG(base, reg, val) { \
+	u32 __iomem *__p = base + reg; \
+	writel(val, __p); \
+}
+#endif
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam-seninf-route.c b/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam-seninf-route.c
new file mode 100644
index 0000000000000000000000000000000000000000..325469738933cadaabc6e9eb1b2c86c738dd6df4
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam-seninf-route.c
@@ -0,0 +1,901 @@
+// SPDX-License-Identifier: GPL-2.0
+// Copyright (c) 2022 MediaTek Inc.
+
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/of_graph.h>
+#include <linux/of_device.h>
+
+#include <linux/videodev2.h>
+#include <media/v4l2-subdev.h>
+#include <media/v4l2-fwnode.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-event.h>
+#include <media/v4l2-async.h>
+#include <media/v4l2-device.h>
+
+#include "mtk_cam-seninf.h"
+#include "mtk_cam-seninf-route.h"
+#include "mtk_cam-seninf-if.h"
+#include "mtk_cam-seninf-hw.h"
+#include "imgsensor-user.h"
+#ifdef SENSOR_SECURE_MTEE_SUPPORT
+#include "mtk_cam-seninf-ca.h"
+#endif
+#define to_std_fmt_code(code) \
+	((code) & 0xFFFF)
+
+void mtk_cam_seninf_init_res(struct seninf_core *core)
+{
+	int i;
+
+	INIT_LIST_HEAD(&core->list_mux);
+	for (i = 0; i < g_seninf_ops->mux_num; i++) {
+		core->mux[i].idx = i;
+		list_add_tail(&core->mux[i].list, &core->list_mux);
+	}
+
+#ifdef SENINF_DEBUG
+	INIT_LIST_HEAD(&core->list_cam_mux);
+	for (i = 0; i < g_seninf_ops->cam_mux_num; i++) {
+		core->cam_mux[i].idx = i;
+		list_add_tail(&core->cam_mux[i].list, &core->list_cam_mux);
+	}
+#endif
+}
+
+struct seninf_mux *mtk_cam_seninf_mux_get(struct seninf_ctx *ctx)
+{
+	struct seninf_core *core = ctx->core;
+	struct seninf_mux *ent = NULL;
+
+	mutex_lock(&core->mutex);
+
+	if (!list_empty(&core->list_mux)) {
+		ent = list_first_entry(&core->list_mux,
+				       struct seninf_mux, list);
+		list_move_tail(&ent->list, &ctx->list_mux);
+	}
+
+	mutex_unlock(&core->mutex);
+
+	return ent;
+}
+
+struct seninf_mux *mtk_cam_seninf_mux_get_pref(struct seninf_ctx *ctx,
+					       int *pref_idx, int pref_cnt)
+{
+	int i;
+	struct seninf_core *core = ctx->core;
+	struct seninf_mux *ent = NULL;
+
+	mutex_lock(&core->mutex);
+
+	list_for_each_entry(ent, &core->list_mux, list) {
+		for (i = 0; i < pref_cnt; i++) {
+			if (ent->idx == pref_idx[i]) {
+				list_move_tail(&ent->list,
+					       &ctx->list_mux);
+				mutex_unlock(&core->mutex);
+				return ent;
+			}
+		}
+	}
+
+	mutex_unlock(&core->mutex);
+
+	return mtk_cam_seninf_mux_get(ctx);
+}
+
+void mtk_cam_seninf_mux_put(struct seninf_ctx *ctx, struct seninf_mux *mux)
+{
+	struct seninf_core *core = ctx->core;
+
+	mutex_lock(&core->mutex);
+	list_move_tail(&mux->list, &core->list_mux);
+	mutex_unlock(&core->mutex);
+}
+
+void mtk_cam_seninf_get_vcinfo_test(struct seninf_ctx *ctx)
+{
+	struct seninf_vcinfo *vcinfo = &ctx->vcinfo;
+	struct seninf_vc *vc;
+
+	vcinfo->cnt = 0;
+
+	if (ctx->is_test_model == 1) {
+		vc = &vcinfo->vc[vcinfo->cnt++];
+		vc->vc = 0;
+		vc->dt = 0x2b;
+		vc->feature = VC_RAW_DATA;
+		vc->out_pad = PAD_SRC_RAW0;
+		vc->group = 0;
+	} else if (ctx->is_test_model == 2) {
+		vc = &vcinfo->vc[vcinfo->cnt++];
+		vc->vc = 0;
+		vc->dt = 0x2b;
+		vc->feature = VC_STAGGER_NE;
+		vc->out_pad = PAD_SRC_RAW0;
+		vc->group = 0;
+
+		vc = &vcinfo->vc[vcinfo->cnt++];
+		vc->vc = 0;
+		vc->dt = 0x2b;
+		vc->feature = VC_STAGGER_ME;
+		vc->out_pad = PAD_SRC_RAW1;
+		vc->group = 0;
+
+		vc = &vcinfo->vc[vcinfo->cnt++];
+		vc->vc = 0;
+		vc->dt = 0x2b;
+		vc->feature = VC_STAGGER_SE;
+		vc->out_pad = PAD_SRC_RAW2;
+		vc->group = 0;
+	} else if (ctx->is_test_model == 3) {
+		vc = &vcinfo->vc[vcinfo->cnt++];
+		vc->vc = 0;
+		vc->dt = 0x2b;
+		vc->feature = VC_RAW_DATA;
+		vc->out_pad = PAD_SRC_RAW0;
+		vc->group = 0;
+
+		vc = &vcinfo->vc[vcinfo->cnt++];
+		vc->vc = 0;
+		vc->dt = 0x30;
+		vc->feature = VC_PDAF_STATS;
+		vc->out_pad = PAD_SRC_PDAF0;
+		vc->group = 0;
+	} else if (ctx->is_test_model == 4) {
+#ifdef ISP7_1
+		vc = &vcinfo->vc[vcinfo->cnt++];
+		vc->vc = 0;
+		vc->dt = 0x2b;
+		vc->feature = VC_RAW_DATA;
+		vc->out_pad = PAD_SRC_RAW0;
+		vc->group = 0;
+
+		vc = &vcinfo->vc[vcinfo->cnt++];
+		vc->vc = 0;
+		vc->dt = 0x2b;
+		vc->feature = VC_RAW_DATA;
+		vc->out_pad = PAD_SRC_RAW1;
+		vc->group = 0;
+
+		vc = &vcinfo->vc[vcinfo->cnt++];
+		vc->vc = 0;
+		vc->dt = 0x2b;
+		vc->feature = VC_RAW_DATA;
+		vc->out_pad = PAD_SRC_RAW2;
+		vc->group = 0;
+
+		vc = &vcinfo->vc[vcinfo->cnt++];
+		vc->vc = 0;
+		vc->dt = 0x2b;
+		vc->feature = VC_RAW_DATA;
+		vc->out_pad = PAD_SRC_PDAF0;
+		vc->group = 0;
+
+		vc = &vcinfo->vc[vcinfo->cnt++];
+		vc->vc = 0;
+		vc->dt = 0x2b;
+		vc->feature = VC_RAW_DATA;
+		vc->out_pad = PAD_SRC_PDAF1;
+		vc->group = 0;
+#endif
+	} else if (ctx->is_test_model == 5) {
+#ifdef ISP7_1
+		vc = &vcinfo->vc[vcinfo->cnt++];
+		vc->vc = 0;
+		vc->dt = 0x2b;
+		vc->feature = VC_RAW_DATA;
+		vc->out_pad = PAD_SRC_RAW0;
+		vc->group = 0;
+
+		vc = &vcinfo->vc[vcinfo->cnt++];
+		vc->vc = 0;
+		vc->dt = 0x2b;
+		vc->feature = VC_RAW_W_DATA;
+		vc->out_pad = PAD_SRC_RAW_W0;
+		vc->group = 0;
+#endif
+	}
+}
+
+struct seninf_vc *mtk_cam_seninf_get_vc_by_pad(struct seninf_ctx *ctx, int idx)
+{
+	int i;
+	struct seninf_vcinfo *vcinfo = &ctx->vcinfo;
+
+	for (i = 0; i < vcinfo->cnt; i++) {
+		if (vcinfo->vc[i].out_pad == idx)
+			return &vcinfo->vc[i];
+	}
+
+	return NULL;
+}
+
+unsigned int mtk_cam_seninf_get_vc_feature(struct v4l2_subdev *sd, unsigned int pad)
+{
+	struct seninf_vc *pvc = NULL;
+	struct seninf_ctx *ctx = container_of(sd, struct seninf_ctx, subdev);
+
+	pvc = mtk_cam_seninf_get_vc_by_pad(ctx, pad);
+	if (pvc)
+		return pvc->feature;
+
+	return VC_NONE;
+}
+
+static int get_mbus_format_by_dt(int dt)
+{
+	switch (dt) {
+	case 0x2a:
+		return MEDIA_BUS_FMT_SBGGR8_1X8;
+	case 0x2b:
+		return MEDIA_BUS_FMT_SBGGR10_1X10;
+	case 0x2c:
+		return MEDIA_BUS_FMT_SBGGR12_1X12;
+	default:
+		/* default raw8 for other data types */
+		return MEDIA_BUS_FMT_SBGGR8_1X8;
+	}
+}
+
+static int get_vcinfo_by_pad_fmt(struct seninf_ctx *ctx)
+{
+	struct seninf_vcinfo *vcinfo = &ctx->vcinfo;
+	struct seninf_vc *vc;
+
+	vcinfo->cnt = 0;
+
+	switch (to_std_fmt_code(ctx->fmt[PAD_SINK].format.code)) {
+	case MEDIA_BUS_FMT_SBGGR10_1X10:
+	case MEDIA_BUS_FMT_SGBRG10_1X10:
+	case MEDIA_BUS_FMT_SGRBG10_1X10:
+	case MEDIA_BUS_FMT_SRGGB10_1X10:
+		vc = &vcinfo->vc[vcinfo->cnt++];
+		vc->vc = 0;
+		vc->dt = 0x2b;
+		vc->feature = VC_RAW_DATA;
+		vc->out_pad = PAD_SRC_RAW0;
+		vc->group = 0;
+		break;
+	case MEDIA_BUS_FMT_SBGGR12_1X12:
+	case MEDIA_BUS_FMT_SGBRG12_1X12:
+	case MEDIA_BUS_FMT_SGRBG12_1X12:
+	case MEDIA_BUS_FMT_SRGGB12_1X12:
+		vc = &vcinfo->vc[vcinfo->cnt++];
+		vc->vc = 0;
+		vc->dt = 0x2c;
+		vc->feature = VC_RAW_DATA;
+		vc->out_pad = PAD_SRC_RAW0;
+		vc->group = 0;
+		break;
+	default:
+		return -1;
+	}
+
+	return 0;
+}
+
+#ifdef SENINF_VC_ROUTING
+
+int mtk_cam_seninf_get_vcinfo(struct seninf_ctx *ctx)
+{
+	int ret = 0;
+	int i, grp, grp_metadata, raw_cnt;
+	struct mtk_mbus_frame_desc fd;
+	struct seninf_vcinfo *vcinfo = &ctx->vcinfo;
+	struct seninf_vc *vc;
+	int desc;
+	struct v4l2_subdev_format raw_fmt;
+
+	if (!ctx->sensor_sd)
+		return -EINVAL;
+
+	/* load description from user config */
+	memcpy(&fd, &ctx->fdesc, sizeof(struct mtk_mbus_frame_desc));
+	dev_dbg(ctx->dev, "ctx->fdesc.num_entries(%d)\n", fd.num_entries);
+
+	if (ret || fd.type != MTK_MBUS_FRAME_DESC_TYPE_CSI2 || !fd.num_entries) {
+		dev_info(ctx->dev, "%s get_ctrl ret:%d num_entries:%d type:%d\n", __func__,
+			ret, fd.num_entries, fd.type);
+		return get_vcinfo_by_pad_fmt(ctx);
+	}
+
+	vcinfo->cnt = 0;
+	grp = 0;
+	raw_cnt = 0;
+	grp_metadata = -1;
+
+	for (i = 0; i < fd.num_entries; i++) {
+		vc = &vcinfo->vc[vcinfo->cnt];
+		vc->vc = fd.entry[i].bus.csi2.channel;
+		vc->dt = fd.entry[i].bus.csi2.data_type;
+		desc = fd.entry[i].bus.csi2.user_data_desc;
+
+		switch (desc) {
+		case VC_3HDR_Y:
+			vc->feature = VC_3HDR_Y;
+			vc->out_pad = PAD_SRC_HDR0;
+			break;
+		case VC_3HDR_AE:
+			vc->feature = VC_3HDR_AE;
+			vc->out_pad = PAD_SRC_HDR1;
+			break;
+		case VC_3HDR_FLICKER:
+			vc->feature = VC_3HDR_FLICKER;
+			vc->out_pad = PAD_SRC_HDR2;
+			break;
+		case VC_PDAF_STATS:
+			vc->feature = VC_PDAF_STATS;
+			vc->out_pad = PAD_SRC_PDAF0;
+			break;
+		case VC_PDAF_STATS_PIX_1:
+			vc->feature = VC_PDAF_STATS_PIX_1;
+			vc->out_pad = PAD_SRC_PDAF1;
+			break;
+		case VC_PDAF_STATS_PIX_2:
+			vc->feature = VC_PDAF_STATS_PIX_2;
+			vc->out_pad = PAD_SRC_PDAF2;
+			break;
+		case VC_PDAF_STATS_ME_PIX_1:
+			vc->feature = VC_PDAF_STATS_ME_PIX_1;
+			vc->out_pad = PAD_SRC_PDAF3;
+			break;
+		case VC_PDAF_STATS_ME_PIX_2:
+			vc->feature = VC_PDAF_STATS_ME_PIX_2;
+			vc->out_pad = PAD_SRC_PDAF4;
+			break;
+		case VC_PDAF_STATS_SE_PIX_1:
+			vc->feature = VC_PDAF_STATS_SE_PIX_1;
+			vc->out_pad = PAD_SRC_PDAF5;
+			break;
+		case VC_PDAF_STATS_SE_PIX_2:
+			vc->feature = VC_PDAF_STATS_SE_PIX_2;
+			vc->out_pad = PAD_SRC_PDAF6;
+			break;
+		case VC_YUV_Y:
+			vc->feature = VC_RAW_DATA;
+			vc->out_pad = PAD_SRC_RAW0;
+			break;
+		case VC_YUV_UV:
+			vc->feature = VC_RAW_DATA;
+			vc->out_pad = PAD_SRC_RAW1;
+			break;
+		case VC_GENERAL_EMBEDDED:
+			vc->feature = VC_GENERAL_EMBEDDED;
+			vc->out_pad = PAD_SRC_GENERAL0;
+			break;
+		default:
+			if (vc->dt == 0x2a || vc->dt == 0x2b ||
+			    vc->dt == 0x2c) {
+				if (raw_cnt >= 3) {
+					dev_info(ctx->dev,
+						"too much raw data\n");
+					continue;
+				}
+
+				switch (desc) {
+				case VC_STAGGER_NE:
+					vc->out_pad = PAD_SRC_RAW0;
+					break;
+				case VC_STAGGER_ME:
+					vc->out_pad = PAD_SRC_RAW1;
+					break;
+				case VC_STAGGER_SE:
+					vc->out_pad = PAD_SRC_RAW2;
+					break;
+				case VC_RAW_W_DATA:
+					vc->out_pad = PAD_SRC_RAW_W0;
+					break;
+				case VC_RAW_PROCESSED_DATA:
+					vc->out_pad = PAD_SRC_RAW_EXT0;
+					break;
+				default:
+					vc->out_pad = PAD_SRC_RAW0 + raw_cnt;
+					break;
+				}
+				++raw_cnt;
+				vc->feature = VC_RAW_DATA;
+				vc->group = grp++;
+			} else {
+				dev_info(ctx->dev, "unknown desc %d, dt 0x%x\n",
+					desc, vc->dt);
+				continue;
+			}
+			break;
+		}
+
+		if (vc->feature != VC_RAW_DATA) {
+			switch (vc->feature) {
+			case VC_PDAF_STATS_PIX_1:
+			case VC_PDAF_STATS_PIX_2:
+			case VC_PDAF_STATS_ME_PIX_1:
+			case VC_PDAF_STATS_ME_PIX_2:
+			case VC_PDAF_STATS_SE_PIX_1:
+			case VC_PDAF_STATS_SE_PIX_2:
+				vc->group = grp++;
+				break;
+			default:
+				if (grp_metadata < 0)
+					grp_metadata = grp++;
+				vc->group = grp_metadata;
+				break;
+			}
+		}
+
+		vc->exp_hsize = fd.entry[i].bus.csi2.hsize;
+		vc->exp_vsize = fd.entry[i].bus.csi2.vsize;
+
+		/* update pad fotmat */
+		if (vc->exp_hsize && vc->exp_vsize) {
+			ctx->fmt[vc->out_pad].format.width = vc->exp_hsize;
+			ctx->fmt[vc->out_pad].format.height = vc->exp_vsize;
+		}
+
+		if (vc->feature == VC_RAW_DATA) {
+			raw_fmt.pad = ctx->sensor_pad_idx;
+			raw_fmt.which = V4L2_SUBDEV_FORMAT_ACTIVE;
+			ret = v4l2_subdev_call(ctx->sensor_sd, pad, get_fmt,
+					       NULL, &raw_fmt);
+			if (ret) {
+				dev_info(ctx->dev, "no get_fmt in %s\n",
+					ctx->sensor_sd->name);
+				ctx->fmt[vc->out_pad].format.code =
+					get_mbus_format_by_dt(vc->dt);
+			} else {
+				ctx->fmt[vc->out_pad].format.code =
+					to_std_fmt_code(raw_fmt.format.code);
+			}
+		} else {
+			ctx->fmt[vc->out_pad].format.code =
+				get_mbus_format_by_dt(vc->dt);
+		}
+
+		dev_info(ctx->dev, "%s vc[%d] vc 0x%x dt 0x%x pad %d exp %dx%d grp 0x%x code 0x%x\n",
+			__func__,
+			vcinfo->cnt, vc->vc, vc->dt, vc->out_pad,
+			vc->exp_hsize, vc->exp_vsize, vc->group,
+			ctx->fmt[vc->out_pad].format.code);
+		vcinfo->cnt++;
+	}
+
+	return 0;
+}
+#endif
+
+#ifndef SENINF_VC_ROUTING
+int mtk_cam_seninf_get_vcinfo(struct seninf_ctx *ctx)
+{
+	return get_vcinfo_by_pad_fmt(ctx);
+}
+#endif
+
+void mtk_cam_seninf_release_mux(struct seninf_ctx *ctx)
+{
+	struct seninf_mux *ent, *tmp;
+
+	list_for_each_entry_safe(ent, tmp, &ctx->list_mux, list) {
+		mtk_cam_seninf_mux_put(ctx, ent);
+	}
+}
+
+int mtk_cam_seninf_is_vc_enabled(struct seninf_ctx *ctx, struct seninf_vc *vc)
+{
+#ifdef SENINF_VC_ROUTING
+	return 1;
+#else
+	int i;
+	struct seninf_vcinfo *vcinfo = &ctx->vcinfo;
+
+#ifdef SENINF_DEBUG
+	if (ctx->is_test_streamon)
+		return 1;
+#endif
+
+	if (vc->out_pad != PAD_SRC_RAW0 &&
+		vc->out_pad != PAD_SRC_RAW1 &&
+		vc->out_pad != PAD_SRC_RAW2) {
+		if (media_entity_remote_pad(&ctx->pads[vc->out_pad]))
+			return 1;
+		else
+			return 0;
+	}
+
+	for (i = 0; i < vcinfo->cnt; i++) {
+		u8 out_pad = vcinfo->vc[i].out_pad;
+
+		if ((out_pad == PAD_SRC_RAW0 ||
+			 out_pad == PAD_SRC_RAW1 ||
+			 out_pad == PAD_SRC_RAW2) &&
+			media_entity_remote_pad(&ctx->pads[out_pad]))
+			return 1;
+	}
+
+	return 0;
+
+#endif
+}
+
+int mtk_cam_seninf_is_di_enabled(struct seninf_ctx *ctx, u8 ch, u8 dt)
+{
+	int i;
+	struct seninf_vc *vc;
+
+	for (i = 0; i < ctx->vcinfo.cnt; i++) {
+		vc = &ctx->vcinfo.vc[i];
+		if (vc->vc == ch && vc->dt == dt) {
+#ifdef SENINF_DEBUG
+			if (ctx->is_test_streamon)
+				return 1;
+#endif
+			if (media_pad_remote_pad_first(&ctx->pads[vc->out_pad]))
+				return 1;
+			return 0;
+		}
+	}
+
+	return 0;
+}
+
+/* Debug Only */
+#ifdef SENINF_DEBUG
+void mtk_cam_seninf_release_cam_mux(struct seninf_ctx *ctx)
+{
+	struct seninf_core *core = ctx->core;
+	struct seninf_cam_mux *ent, *tmp;
+
+	mutex_lock(&core->mutex);
+
+	/* release all cam muxs */
+	list_for_each_entry_safe(ent, tmp, &ctx->list_cam_mux, list) {
+		list_move_tail(&ent->list, &core->list_cam_mux);
+	}
+
+	mutex_unlock(&core->mutex);
+}
+
+void mtk_cam_seninf_alloc_cam_mux(struct seninf_ctx *ctx)
+{
+	int i;
+	struct seninf_core *core = ctx->core;
+	struct seninf_vcinfo *vcinfo = &ctx->vcinfo;
+	struct seninf_vc *vc;
+	struct seninf_cam_mux *ent;
+
+	mutex_lock(&core->mutex);
+
+	/* allocate all cam muxs */
+	for (i = 0; i < vcinfo->cnt; i++) {
+		vc = &vcinfo->vc[i];
+		ent = list_first_entry_or_null(&core->list_cam_mux,
+					       struct seninf_cam_mux, list);
+		if (ent) {
+			list_move_tail(&ent->list, &ctx->list_cam_mux);
+			ctx->pad2cam[vc->out_pad] = ent->idx;
+			dev_info(ctx->dev, "pad%d -> cam%d\n",
+				 vc->out_pad, ent->idx);
+		}
+	}
+
+	mutex_unlock(&core->mutex);
+}
+#endif
+
+int mtk_cam_seninf_get_pixelmode(struct v4l2_subdev *sd,
+				 int pad_id, int *pixelMode)
+{
+	struct seninf_ctx *ctx = container_of(sd, struct seninf_ctx, subdev);
+	struct seninf_vc *vc;
+
+	vc = mtk_cam_seninf_get_vc_by_pad(ctx, pad_id);
+	if (!vc) {
+		pr_info("%s: invalid pad=%d\n", __func__, pad_id);
+		return -1;
+	}
+
+	*pixelMode = vc->pixel_mode;
+
+	return 0;
+}
+
+int mtk_cam_seninf_set_pixelmode(struct v4l2_subdev *sd,
+				 int pad_id, int pixelMode)
+{
+	struct seninf_ctx *ctx = container_of(sd, struct seninf_ctx, subdev);
+	struct seninf_vc *vc;
+
+	vc = mtk_cam_seninf_get_vc_by_pad(ctx, pad_id);
+	if (!vc) {
+		pr_info("%s: invalid pad=%d\n", __func__, pad_id);
+		return -1;
+	}
+
+	vc->pixel_mode = pixelMode;
+	if (ctx->streaming) {
+		update_isp_clk(ctx);
+		g_seninf_ops->_update_mux_pixel_mode(ctx, vc->mux, pixelMode);
+	}
+	// if streaming, update ispclk and update pixle mode seninf mux and reset
+
+	return 0;
+}
+
+static int _mtk_cam_seninf_set_camtg(struct v4l2_subdev *sd, int pad_id, int camtg, bool disable_last)
+{
+	int vc_en, old_camtg;
+	struct seninf_ctx *ctx = container_of(sd, struct seninf_ctx, subdev);
+	struct seninf_vc *vc;
+
+	if (pad_id < PAD_SRC_RAW0 || pad_id >= PAD_MAXCNT)
+		return -EINVAL;
+
+	vc = mtk_cam_seninf_get_vc_by_pad(ctx, pad_id);
+	if (!vc)
+		return -EINVAL;
+
+	ctx->pad2cam[pad_id] = camtg;
+
+	vc_en = mtk_cam_seninf_is_vc_enabled(ctx, vc);
+
+	/* change cam-mux while streaming */
+	if (ctx->streaming && vc_en && vc->cam != camtg) {
+#ifdef SENSOR_SECURE_MTEE_SUPPORT
+		if (ctx->is_secure == 1) {
+			vc->cam = camtg;
+
+			dev_info(ctx->dev, "Sensor Secure CA");
+			g_seninf_ops->_set_cammux_vc(ctx, vc->cam,
+								vc->vc, vc->dt,
+								!!vc->dt, !!vc->dt);
+			g_seninf_ops->_set_cammux_src(ctx, vc->mux, vc->cam,
+								vc->exp_hsize,
+								vc->exp_vsize);
+			g_seninf_ops->_set_cammux_chk_pixel_mode(ctx,
+								vc->cam,
+								vc->pixel_mode);
+			g_seninf_ops->_cammux(ctx, vc->cam);
+			if (pad_id == PAD_SRC_RAW0) {
+				// notify vc->cam
+				notify_fsync_cammux_usage_with_kthread(ctx);
+			}
+
+			if (!seninf_ca_open_session())
+				dev_info(ctx->dev, "seninf_ca_open_session fail");
+
+			dev_info(ctx->dev, "Sensor kernel ca_checkpipe");
+			seninf_ca_checkpipe(ctx->SecInfo_addr);
+		} else {
+#endif
+			if (camtg == 0xff) {
+				old_camtg = vc->cam;
+				vc->cam = 0xff;
+				g_seninf_ops->_switch_to_cammux_inner_page(ctx, true);
+				g_seninf_ops->_set_cammux_next_ctrl(ctx, 0x1f, old_camtg);
+				g_seninf_ops->_disable_cammux(ctx, old_camtg);
+			} else {
+				/* disable old */
+				old_camtg = vc->cam;
+				/* enable new */
+				vc->cam = camtg;
+				g_seninf_ops->_switch_to_cammux_inner_page(ctx, true);
+				g_seninf_ops->_set_cammux_next_ctrl(ctx, 0x1f, vc->cam);
+
+				g_seninf_ops->_switch_to_cammux_inner_page(ctx, false);
+
+				g_seninf_ops->_set_cammux_vc(ctx, vc->cam,
+									vc->vc, vc->dt,
+									!!vc->dt, !!vc->dt);
+				g_seninf_ops->_set_cammux_src(ctx, vc->mux, vc->cam,
+									vc->exp_hsize,
+									vc->exp_vsize);
+				g_seninf_ops->_set_cammux_chk_pixel_mode(ctx,
+									vc->cam,
+									vc->pixel_mode);
+				if (old_camtg != 0xff && disable_last) {
+					//disable old in next sof
+					g_seninf_ops->_disable_cammux(ctx, old_camtg);
+				}
+				g_seninf_ops->_cammux(ctx, vc->cam); //enable in next sof
+				g_seninf_ops->_switch_to_cammux_inner_page(ctx, true);
+				g_seninf_ops->_set_cammux_next_ctrl(ctx, vc->mux, vc->cam);
+				if (old_camtg != 0xff && disable_last)
+					g_seninf_ops->_set_cammux_next_ctrl(ctx,
+									vc->mux, old_camtg);
+
+				if (pad_id == PAD_SRC_RAW0) {
+					// notify vc->cam
+					notify_fsync_cammux_usage_with_kthread(ctx);
+				}
+			}
+			dev_info(ctx->dev, "%s: pad %d mux %d cam %d -> %d\n",
+				 __func__, vc->out_pad, vc->mux, old_camtg, vc->cam);
+
+#ifdef SENSOR_SECURE_MTEE_SUPPORT
+		}
+#endif
+	} else {
+		dev_info(ctx->dev, "%s: pad_id %d, camtg %d, ctx->streaming %d, vc_en %d, vc->cam %d\n",
+			 __func__, pad_id, camtg, ctx->streaming, vc_en, vc->cam);
+	}
+
+	return 0;
+}
+
+
+int mtk_cam_seninf_set_camtg(struct v4l2_subdev *sd, int pad_id, int camtg)
+{
+	return _mtk_cam_seninf_set_camtg(sd, pad_id, camtg, true);
+}
+
+static int mtk_cam_seninf_get_raw_cam_info(struct seninf_ctx *ctx)
+{
+	struct seninf_vcinfo *vcinfo = &ctx->vcinfo;
+	struct seninf_vc *vc;
+	int i;
+
+	for (i = 0; i < vcinfo->cnt; i++) {
+		vc = &vcinfo->vc[i];
+		if (vc->out_pad == PAD_SRC_RAW0) /* first raw */
+			return vc->cam;
+	}
+
+	dev_info(ctx->dev, "%s: no raw data in vc channel\n", __func__);
+	return -1;
+}
+
+bool
+mtk_cam_seninf_streaming_mux_change(struct mtk_cam_seninf_mux_param *param)
+{
+	struct v4l2_subdev *sd = NULL;
+	int pad_id = -1;
+	int camtg = -1;
+	struct seninf_ctx *ctx;
+	int index = 0;
+
+	if (param != NULL && param->num == 1) {
+		sd = param->settings[0].seninf;
+		pad_id = param->settings[0].source;
+		camtg = param->settings[0].camtg;
+
+		_mtk_cam_seninf_set_camtg(sd, pad_id, camtg, true);
+
+	} else if (param != NULL && param->num > 1) {
+		sd = param->settings[0].seninf;
+		pad_id = param->settings[0].source;
+		camtg = param->settings[0].camtg;
+
+		ctx = container_of(sd, struct seninf_ctx, subdev);
+
+		//mtk_cam_seninf_enable_global_drop_irq(ctx, true, 0);
+		g_seninf_ops->_reset_cam_mux_dyn_en(ctx, index);
+		//k_cam_seninf_set_sw_cfg_busy(ctx, true, index);
+
+		_mtk_cam_seninf_set_camtg(sd, pad_id, camtg, false);
+		//g_seninf_ops->_enable_cam_mux_vsync_irq(ctx, true, camtg);
+		//k_cam_seninf_set_cam_mux_dyn_en(ctx, true, camtg, index);
+
+
+
+		sd = param->settings[1].seninf;
+		pad_id = param->settings[1].source;
+		camtg = param->settings[1].camtg;
+		_mtk_cam_seninf_set_camtg(sd, pad_id, camtg, false);
+		//g_seninf_ops->_enable_cam_mux_vsync_irq(ctx, true, camtg);
+		//mtk_cam_seninf_set_cam_mux_dyn_en(ctx, true, camtg, index);
+
+
+
+		if (param->num > 2) {
+			sd = param->settings[2].seninf;
+			pad_id = param->settings[2].source;
+			camtg = param->settings[2].camtg;
+
+			_mtk_cam_seninf_set_camtg(sd, pad_id, camtg, false);
+
+			//g_seninf_ops->_enable_cam_mux_vsync_irq(ctx, true, camtg);
+			//k_cam_seninf_set_cam_mux_dyn_en(ctx, true, camtg, index);
+
+			dev_info(ctx->dev,
+				"%s: param->num %d, pad_id[0] %d, ctx->camtg[0] %d, pad_id[1] %d, ctx->camtg[1] %d pad_id[2] %d, ctx->camtg[2] %d %llu|%llu\n",
+				__func__, param->num,
+				param->settings[0].source, param->settings[0].camtg,
+				param->settings[1].source, param->settings[1].camtg,
+				param->settings[2].source, param->settings[2].camtg,
+				ktime_get_boottime_ns(),
+				ktime_get_ns());
+		} else
+			dev_info(ctx->dev,
+				"%s: param->num %d, pad_id[0] %d, ctx->camtg[0] %d, pad_id[1] %d, ctx->camtg[1] %d %llu|%llu\n",
+				__func__, param->num, pad_id, camtg,
+				param->settings[1].source, param->settings[1].camtg,
+				ktime_get_boottime_ns(),
+				ktime_get_ns());
+
+		//mtk_cam_seninf_set_sw_cfg_busy(ctx, false, index);
+		//mtk_cam_seninf_enable_global_drop_irq(ctx, false, 0);
+		//g_seninf_ops->_disable_all_cam_mux_vsync_irq(ctx);
+
+	}
+	return true;
+}
+
+int reset_sensor(struct seninf_ctx *ctx)
+{
+	struct v4l2_subdev *sensor_sd = ctx->sensor_sd;
+	struct v4l2_ctrl *ctrl;
+
+	ctrl = v4l2_ctrl_find(sensor_sd->ctrl_handler,
+			V4L2_CID_MTK_SENSOR_RESET);
+	if (!ctrl) {
+		dev_info(ctx->dev, "V4L2_CID_MTK_SENSOR_RESET %s\n",
+			sensor_sd->name);
+		return -EINVAL;
+	}
+
+	v4l2_ctrl_s_ctrl(ctrl, 1);
+
+	return 0;
+}
+
+
+int notify_fsync_cammux_usage(struct seninf_ctx *ctx)
+{
+	int cam_idx = mtk_cam_seninf_get_raw_cam_info(ctx);
+	struct v4l2_subdev *sensor_sd = ctx->sensor_sd;
+	struct v4l2_ctrl *ctrl;
+
+	if (cam_idx < 0)
+		return -EINVAL;
+
+	ctrl = v4l2_ctrl_find(sensor_sd->ctrl_handler,
+			V4L2_CID_FSYNC_MAP_ID);
+	if (!ctrl) {
+		dev_info(ctx->dev, "no fsync map id in %s\n",
+			sensor_sd->name);
+		return -EINVAL;
+	}
+
+	dev_info(ctx->dev, "raw cammux usage = %d\n", cam_idx);
+
+	v4l2_ctrl_s_ctrl(ctrl, cam_idx);
+
+	return 0;
+}
+
+static void mtk_notify_cammux_usage_fn(struct kthread_work *work)
+{
+	struct mtk_seninf_work *seninf_work = NULL;
+	struct seninf_ctx *ctx = NULL;
+
+	seninf_work = container_of(work, struct mtk_seninf_work, work);
+
+	if (seninf_work) {
+		ctx = seninf_work->ctx;
+		if (ctx)
+			notify_fsync_cammux_usage(ctx);
+
+		kfree(seninf_work);
+	}
+}
+
+void notify_fsync_cammux_usage_with_kthread(struct seninf_ctx *ctx)
+{
+	struct mtk_seninf_work *seninf_work = NULL;
+
+	if (ctx->streaming) {
+		seninf_work = kmalloc(sizeof(struct mtk_seninf_work),
+					GFP_ATOMIC);
+		if (seninf_work) {
+			kthread_init_work(&seninf_work->work,
+					mtk_notify_cammux_usage_fn);
+			seninf_work->ctx = ctx;
+			kthread_queue_work(&ctx->core->seninf_worker,
+					&seninf_work->work);
+		}
+	}
+}
+
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam-seninf-route.h b/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam-seninf-route.h
new file mode 100644
index 0000000000000000000000000000000000000000..09d1a958a872a0ea525b933c4f96ed3a19c07baf
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam-seninf-route.h
@@ -0,0 +1,37 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright (c) 2022 MediaTek Inc. */
+
+#ifndef __MTK_CAM_SENINF_ROUTE_H__
+#define __MTK_CAM_SENINF_ROUTE_H__
+
+void mtk_cam_seninf_init_res(struct seninf_core *core);
+
+struct seninf_mux *mtk_cam_seninf_mux_get(struct seninf_ctx *ctx);
+struct seninf_mux *mtk_cam_seninf_mux_get_pref(struct seninf_ctx *ctx,
+					       int *pref_idx, int pref_cnt);
+void mtk_cam_seninf_mux_put(struct seninf_ctx *ctx, struct seninf_mux *mux);
+void mtk_cam_seninf_release_mux(struct seninf_ctx *ctx);
+
+void mtk_cam_seninf_get_vcinfo_test(struct seninf_ctx *ctx);
+
+struct seninf_vc *mtk_cam_seninf_get_vc_by_pad(struct seninf_ctx *ctx, int idx);
+
+int mtk_cam_seninf_get_vcinfo(struct seninf_ctx *ctx);
+
+int mtk_cam_seninf_is_vc_enabled(struct seninf_ctx *ctx,
+				 struct seninf_vc *vc);
+
+int mtk_cam_seninf_is_di_enabled(struct seninf_ctx *ctx, u8 ch, u8 dt);
+
+int notify_fsync_cammux_usage(struct seninf_ctx *ctx);
+void notify_fsync_cammux_usage_with_kthread(struct seninf_ctx *ctx);
+
+int reset_sensor(struct seninf_ctx *ctx);
+
+
+#ifdef SENINF_DEBUG
+void mtk_cam_seninf_alloc_cam_mux(struct seninf_ctx *ctx);
+void mtk_cam_seninf_release_cam_mux(struct seninf_ctx *ctx);
+#endif
+
+#endif
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam-seninf.h b/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam-seninf.h
new file mode 100644
index 0000000000000000000000000000000000000000..30853fe2d49e7a3ddafc1314dee1b10dd0675b53
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam-seninf.h
@@ -0,0 +1,205 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright (c) 2022 MediaTek Inc. */
+
+#ifndef __MTK_CAM_SENINF_H__
+#define __MTK_CAM_SENINF_H__
+
+#include <linux/kthread.h>
+#include <media/v4l2-subdev.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-fwnode.h>
+
+#include "mtk_cam-seninf-def.h"
+#include "imgsensor-user.h"
+#include "mtk_cam-seninf-regs.h"
+
+/* def V4L2_MBUS_CSI2_IS_USER_DEFINED_DATA */
+#define SENINF_VC_ROUTING
+
+#define CSI_EFUSE_SET
+//#define SENINF_UT_DUMP
+
+struct seninf_ctx;
+
+struct seninf_mux {
+	struct list_head list;
+	int idx;
+};
+
+struct seninf_cam_mux {
+	struct list_head list;
+	int idx;
+};
+
+struct seninf_vc {
+	u8 vc;
+	u8 dt;
+	u8 feature;
+	u8 out_pad;
+	u8 pixel_mode;
+	u8 group;
+	u8 mux; // allocated per group
+	u8 cam; // assigned by cam driver
+	u8 enable;
+	u16 exp_hsize;
+	u16 exp_vsize;
+};
+
+struct seninf_vcinfo {
+	struct seninf_vc vc[SENINF_VC_MAXCNT];
+	int cnt;
+};
+
+struct seninf_dfs {
+	struct device *dev;
+	struct regulator *reg;
+	unsigned long *freqs;
+	unsigned long *volts;
+	int cnt;
+};
+
+struct mtk_seninf_work {
+	struct kthread_work work;
+	struct seninf_ctx *ctx;
+	union work_data_t {
+		unsigned int sof;
+		void *data_ptr;
+	} data;
+};
+
+struct seninf_core {
+	struct device *dev;
+	int pm_domain_cnt;
+	struct device **pm_domain_devs;
+	struct clk *clk[CLK_MAXCNT];
+	struct seninf_dfs dfs;
+	struct list_head list;
+	struct list_head list_mux;
+	struct seninf_mux mux[SENINF_MUX_NUM];
+#ifdef SENINF_DEBUG
+	struct list_head list_cam_mux;
+	struct seninf_cam_mux cam_mux[SENINF_CAM_MUX_NUM];
+#endif
+	struct mutex mutex;
+	void __iomem *reg_if;
+	void __iomem *reg_ana;
+	int refcnt;
+
+	/* platform properties */
+	int cphy_settle_delay_dt;
+	int dphy_settle_delay_dt;
+	int settle_delay_ck;
+	int hs_trail_parameter;
+
+	spinlock_t spinlock_irq;
+
+	struct kthread_worker seninf_worker;
+	struct task_struct *seninf_kworker_task;
+
+	/* record pid */
+	struct pid *pid;
+	/* mipi error detection count */
+	unsigned int detection_cnt;
+	/* enable csi irq flag */
+	unsigned int csi_irq_en_flag;
+	/* enable vsync irq flag */
+	unsigned int vsync_irq_en_flag;
+};
+
+struct seninf_ctx {
+	struct v4l2_subdev subdev;
+	struct v4l2_async_notifier notifier;
+	struct device *dev;
+	struct v4l2_ctrl_handler ctrl_handler;
+	struct media_pad pads[PAD_MAXCNT];
+	struct v4l2_subdev_format fmt[PAD_MAXCNT];
+	struct seninf_core *core;
+	struct list_head list;
+
+	int port;
+	int portNum;
+	int portA;
+	int portB;
+	int num_data_lanes;
+	s64 mipi_pixel_rate;
+	s64 buffered_pixel_rate;
+	s64 customized_pixel_rate;
+
+	unsigned int is_4d1c:1;
+	unsigned int is_cphy:1;
+	unsigned int is_test_model:4;
+#ifdef SENINF_DEBUG
+	unsigned int is_test_streamon:1;
+#endif
+#ifdef CSI_EFUSE_SET
+	unsigned int m_csi_efuse;
+#endif
+	unsigned int is_secure:1;
+	unsigned int SecInfo_addr;
+	int seninfIdx;
+	int pad2cam[PAD_MAXCNT];
+
+	/* remote sensor */
+	struct v4l2_subdev *sensor_sd;
+	int sensor_pad_idx;
+
+	/* provided by sensor */
+	struct seninf_vcinfo vcinfo;
+	struct mtk_mbus_frame_desc fdesc;
+	int fps_n;
+	int fps_d;
+
+	/* dfs */
+	int isp_freq;
+
+	void __iomem *reg_ana_csi_rx[CSI_PORT_MAX_NUM];
+	void __iomem *reg_ana_dphy_top[CSI_PORT_MAX_NUM];
+	void __iomem *reg_ana_cphy_top[CSI_PORT_MAX_NUM];
+	void __iomem *reg_if_top;
+	void __iomem *reg_if_ctrl[SENINF_NUM];
+	void __iomem *reg_if_cam_mux;
+	void __iomem *reg_if_cam_mux_gcsr;
+	void __iomem *reg_if_cam_mux_pcsr[SENINF_CAM_MUX_NUM];
+	void __iomem *reg_if_tg[SENINF_NUM];
+	void __iomem *reg_if_csi2[SENINF_NUM];
+	void __iomem *reg_if_mux[SENINF_MUX_NUM];
+
+	/* resources */
+	struct list_head list_mux;
+	struct list_head list_cam_mux;
+
+	/* flags */
+	unsigned int streaming:1;
+
+	int seninf_dphy_settle_delay_dt;
+	int cphy_settle_delay_dt;
+	int dphy_settle_delay_dt;
+	int settle_delay_ck;
+	int hs_trail_parameter;
+	/*sensor mode customized csi params*/
+	struct mtk_csi_param csi_param;
+
+	int open_refcnt;
+	struct mutex mutex;
+
+	/* csi irq */
+	unsigned int data_not_enough_cnt;
+	unsigned int err_lane_resync_cnt;
+	unsigned int crc_err_cnt;
+	unsigned int ecc_err_double_cnt;
+	unsigned int ecc_err_corrected_cnt;
+	/* seninf_mux fifo overrun irq */
+	unsigned int fifo_overrun_cnt;
+	/* cam_mux h/v size irq */
+	unsigned int size_err_cnt;
+	/* error flag */
+	unsigned int data_not_enough_flag;
+	unsigned int err_lane_resync_flag;
+	unsigned int crc_err_flag;
+	unsigned int ecc_err_double_flag;
+	unsigned int ecc_err_corrected_flag;
+	unsigned int fifo_overrun_flag;
+	unsigned int size_err_flag;
+};
+
+#endif
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam-sv-regs-mt8188.h b/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam-sv-regs-mt8188.h
new file mode 100644
index 0000000000000000000000000000000000000000..8c6c29012fd63604e96f5fdc1fe57ec3409be441
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam-sv-regs-mt8188.h
@@ -0,0 +1,612 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2022 MediaTek Inc.
+ */
+
+#ifndef _CAMSV_REGS_H
+#define _CAMSV_REGS_H
+
+/*  */
+#define REG_CAMSV_TOP_FBC_CNT_SET				0x0014
+
+union CAMSV_TOP_FBC_CNT_SET {
+	struct {
+		unsigned int  RCNT_INC1					:	1;
+		unsigned int  RCNT_INC2					:	1;
+		unsigned int  rsv_2						:	30;
+	} Bits;
+	unsigned int Raw;
+};
+/* Module EN */
+#define REG_CAMSV_MODULE_EN						0x0040
+union CAMSV_MODULE_EN {
+	struct {
+		unsigned int  TG_EN						:	1;
+		unsigned int  rsv_1						:	1;
+		unsigned int  PAK_EN					:	1;
+		unsigned int  PAK_SEL					:	1;
+		unsigned int  IMGO_EN					:	1;
+		unsigned int  rsv_5						:	1;
+		unsigned int  UFE_EN					:	1;
+		unsigned int  QBN_EN					:	1;
+		unsigned int  rsv_8						:	8;
+		unsigned int  DOWN_SAMPLE_PERIOD		:	8;
+		unsigned int  DOWN_SAMPLE_EN			:	1;
+		unsigned int  DB_LOAD_HOLD				:	1;
+		unsigned int  DB_LOAD_FORCE				:	1;
+		unsigned int  rsv_27					:	1;
+		unsigned int  DB_LOAD_SRC				:	2;
+		unsigned int  DB_EN						:	1;
+		unsigned int  DB_LOCK					:	1;
+	} Bits;
+	unsigned int Raw;
+};
+
+
+/* FMT SEL */
+#define REG_CAMSV_FMT_SEL						0x0044
+union CAMSV_FMT_SEL {
+	struct {
+		unsigned int  TG1_FMT					:	3;
+		unsigned int  rsv_3						:	2;
+		unsigned int  TG1_SW					:	2;
+		unsigned int  rsv_7						:	1;
+		unsigned int  LP_MODE					:	1;
+		unsigned int  HLR_MODE					:	1;
+		unsigned int  rsv_10					:	22;
+	} Bits;
+	unsigned int Raw;
+};
+
+/* INT EN */
+#define REG_CAMSV_INT_EN						0x0048
+union CAMSV_INT_EN {
+	struct {
+		unsigned int  VS_INT_EN					:	1;
+		unsigned int  TG_INT1_EN				:	1;
+		unsigned int  TG_INT2_EN				:	1;
+		unsigned int  EXPDON1_INT_EN			:	1;
+		unsigned int  TG_ERR_INT_EN				:	1;
+		unsigned int  TG_GBERR_INT_EN			:	1;
+		unsigned int  TG_SOF_INT_EN				:	1;
+		unsigned int  TG_SOF_WAIT_INT_EN		:	1;
+		unsigned int  TG_SOF_DROP_INT_EN		:	1;
+		unsigned int  VS_INT_ORG_EN				:	1;
+		unsigned int  DB_LOAD_ERR_EN			:	1;
+		unsigned int  PASS1_DON_INT_EN			:	1;
+		unsigned int  SW_PASS1_DON_INT_EN		:	1;
+		unsigned int  SUB_PASS1_DON_INT_EN		:	1;
+		unsigned int  rsv_14					:	1;
+		unsigned int  UFEO_OVERR_INT_EN			:	1;
+		unsigned int  DMA_ERR_INT_EN			:	1;
+		unsigned int  IMGO_OVERR_INT_EN			:	1;
+		unsigned int  UFEO_DROP_INT_EN			:	1;
+		unsigned int  IMGO_DROP_INT_EN			:	1;
+		unsigned int  IMGO_DONE_INT_EN			:	1;
+		unsigned int  UFEO_DONE_INT_EN			:	1;
+		unsigned int  TG_INT3_EN				:	1;
+		unsigned int  TG_INT4_EN				:	1;
+		unsigned int  SW_ENQUE_ERR_EN			:	1;
+		unsigned int  rsv_25					:	6;
+		unsigned int  INT_WCLR_EN				:	1;
+	} Bits;
+	unsigned int Raw;
+};
+
+
+/* INT Status */
+#define REG_CAMSV_INT_STATUS					0x004C
+#define CAMSV_INT_VS_ST							BIT(0)
+#define CAMSV_INT_TG_ST1						BIT(1)
+#define CAMSV_INT_TG_ST2						BIT(2)
+#define CAMSV_INT_EXPDON1_ST					BIT(3)
+#define CAMSV_INT_TG_ERR_ST						BIT(4)
+#define CAMSV_INT_TG_GBERR_ST					BIT(5)
+#define CAMSV_INT_TG_SOF_INT_ST					BIT(6)
+#define CAMSV_INT_DB_LOAD_ERR_ST				BIT(10)
+#define CAMSV_INT_PASS1_DON_ST					BIT(11)
+#define CAMSV_INT_SW_PASS1_DON_ST				BIT(12)
+#define CAMSV_INT_SUB_PASS1_DON_ST				BIT(13)
+#define CAMSV_INT_UFEO_OVERR_ST					BIT(15)
+#define CAMSV_INT_DMA_ERR_ST					BIT(16)
+#define CAMSV_INT_IMGO_OVERR_ST					BIT(17)
+#define CAMSV_INT_UFEO_DROP_ST					BIT(18)
+#define CAMSV_INT_IMGO_DROP_ST					BIT(19)
+#define CAMSV_INT_IMGO_DONE_ST					BIT(20)
+#define CAMSV_INT_UFEO_DONE_ST					BIT(21)
+#define CAMSV_INT_TG_ST3						BIT(22)
+#define CAMSV_INT_TG_ST4						BIT(23)
+#define CAMSV_INT_SW_ENQUE_ERR					BIT(24)
+union CAMSV_INT_STATUS {
+	struct {
+		unsigned int  VS_ST						:	1;
+		unsigned int  TG_ST1					:	1;
+		unsigned int  TG_ST2					:	1;
+		unsigned int  EXPDON1_ST				:	1;
+		unsigned int  SV_TG_ERR_ST				:	1;
+		unsigned int  SV_TG_GBERR_ST			:	1;
+		unsigned int  TG_SOF_INT_ST				:	1;
+		unsigned int  TG_SOF_WAIT_ST			:	1;
+		unsigned int  TG_SOF_DROP_ST			:	1;
+		unsigned int  VS_ORG_ST					:	1;
+		unsigned int  DB_LOAD_ERR_ST			:	1;
+		unsigned int  PASS1_DON_ST				:	1;
+		unsigned int  SV_SW_PASS1_DON_ST		:	1;
+		unsigned int  SUB_PASS1_DON_ST			:	1;
+		unsigned int  rsv_14					:	1;
+		unsigned int  SV_UFEO_OVERR_ST			:	1;
+		unsigned int  SV_DMA_ERR_ST				:	1;
+		unsigned int  SV_IMGO_OVERR_ST			:	1;
+		unsigned int  SV_UFEO_DROP_ST			:	1;
+		unsigned int  SV_IMGO_DROP_ST			:	1;
+		unsigned int  SV_IMGO_DONE_ST			:	1;
+		unsigned int  SV_UFEO_DONE_ST			:	1;
+		unsigned int  TG_ST3					:	1;
+		unsigned int  TG_ST4					:	1;
+		unsigned int  SW_ENQUE_ERR				:	1;
+		unsigned int  rsv_20					:	7;
+	} Bits;
+	unsigned int Raw;
+};
+
+/* SW CTL */
+#define REG_CAMSV_SW_CTL						0x0050
+
+/* IMGO FBC */
+#define REG_CAMSV_IMGO_FBC						0x005C
+union CAMSV_IMGO_FBC {
+	struct {
+		unsigned int  rsv_0						:	1;
+		unsigned int  rsv_1						:	1;
+		unsigned int  rsv_2						:	1;
+		unsigned int  rsv_3						:	1;
+		unsigned int  IMGO_FIFO_FULL_EN			:	1;
+		unsigned int  UFEO_FIFO_FULL_EN			:	1;
+		unsigned int  IMGO_FBC_FIFO_FULL_SEL	:	1;
+		unsigned int  UFEO_FBC_FIFO_FULL_SEL	:	1;
+		unsigned int  rsv_8						:	24;
+	} Bits;
+	unsigned int Raw;
+};
+
+/* CLK EN */
+#define REG_CAMSV_CLK_EN						0x0060
+union CAMSV_CLK_EN {
+	struct {
+		unsigned int  TG_DP_CK_EN				:	1;
+		unsigned int  QBN_DP_CK_EN				:	1;
+		unsigned int  PAK_DP_CK_EN				:	1;
+		unsigned int  rsv_3						:	1;
+		unsigned int  UFEO_DP_CK_EN				:	1;
+		unsigned int  rsv_5						:	10;
+		unsigned int  IMGO_DP_CK_EN				:	1;
+		unsigned int  rsv_16					:	16;
+	} Bits;
+	unsigned int Raw;
+};
+
+/* DCIF Set */
+#define REG_CAMSV_DCIF_SET						0x0074
+union CAMSV_DCIF_SET {
+	struct {
+		unsigned int  rsv_0						:	6;
+		unsigned int  POSTPONE_PASS1_DONE		:	1;
+		unsigned int  MASK_DB_LOAD				:	1;
+		unsigned int  ENABLE_OUTPUT_CQ_START_SIGNAL	:	1;
+		unsigned int  ENABLE_REFERENCE_COUPLE_CAMSV_PASS1_ENABLE	:	1;
+		unsigned int  SEL_THE_SOF_SIGNAL_FROM	:	2;
+		unsigned int  rsv_12					:	3;
+		unsigned int  FOR_DCIF_SUBSAMPLE_EN		:	1;
+		unsigned int  FOR_DCIF_SUBSAMPLE_NUMBER	:	8;
+		unsigned int  FOR_DCIF_CQ_START_TIMING	:	8;
+	} Bits;
+	unsigned int Raw;
+};
+
+/* SUB CTRL */
+#define REG_CAMSV_SUB_CTRL						0x0078
+union CAMSV_SUB_CTRL {
+	struct {
+		unsigned int  CENTRAL_SUB_EN			:	1;
+		unsigned int  rsv_1						:	31;
+	} Bits;
+	unsigned int Raw;
+};
+
+/* PAK */
+#define REG_CAMSV_PAK							0x007C
+union CAMSV_PAK {
+	struct {
+		unsigned int  PAK_MODE					:	8;
+		unsigned int  PAK_DBL_MODE				:	2;
+		unsigned int  rsv_10					:	22;
+	} Bits;
+	unsigned int Raw;
+};
+
+/* QBIN */
+#define REG_CAMSV_QBN_SET						0x009C
+union CAMSV_CAMSV_QBN_SET {
+	struct {
+		unsigned int  CSR_QBN_CAM_PIX_BUS		:	2;
+		unsigned int  rsv_1						:	30;
+	} Bits;
+	unsigned int Raw;
+};
+
+/* TG SEN Mode */
+#define REG_CAMSV_TG_SEN_MODE					0x0100
+#define CAMSV_TG_SEN_MODE_CMOS_EN				BIT(0)
+#define CAMSV_TG_SEN_MODE_CMOS_RDY_SEL			BIT(14)
+
+union CAMSV_TG_SEN_MODE {
+	struct {
+		unsigned int  CMOS_EN					:	1;
+		unsigned int  rsv_1						:	1;
+		unsigned int  SOT_MODE					:	1;
+		unsigned int  SOT_CLR_MODE				:	1;
+		unsigned int  DBL_DATA_BUS				:	2;
+		unsigned int  rsv_6						:	2;
+		unsigned int  SOF_SRC					:	2;
+		unsigned int  EOF_SRC					:	2;
+		unsigned int  PXL_CNT_RST_SRC			:	1;
+		unsigned int  rsv_13					:	1;
+		unsigned int  CMOS_RDY_SEL				:	1;
+		unsigned int  FIFO_FULL_CTL_EN			:	1;
+		unsigned int  TIME_STP_EN				:	1;
+		unsigned int  VS_SUB_EN					:	1;
+		unsigned int  SOF_SUB_EN				:	1;
+		unsigned int  VSYNC_INT_POL				:	1;
+		unsigned int  EOF_ALS_RDY_EN			:	1;
+		unsigned int  rsv_21					:	1;
+		unsigned int  STAGGER_EN				:	1;
+		unsigned int  HDR_EN					:	1;
+		unsigned int  HDR_SEL					:	1;
+		unsigned int  SOT_DLY_EN				:	1;
+		unsigned int  VS_IGNORE_STALL_EN		:	1;
+		unsigned int  LINE_OK_CHECK				:	1;
+		unsigned int  SOF_SUB_CNT_EXCEPTION_DIS :	1;
+		unsigned int  rsv_29					:	3;
+	} Bits;
+	unsigned int Raw;
+};
+
+
+/* TG VF CON */
+#define REG_CAMSV_TG_VF_CON						0x0104
+#define CAMSV_TG_VF_CON_VFDATA_EN				BIT(0)
+union CAMSV_TG_VF_CON {
+	struct {
+		unsigned int  VFDATA_EN					:	1;
+		unsigned int  SINGLE_MODE				:	1;
+		unsigned int  rsv_2						:	2;
+		unsigned int  FR_CON					:	3;
+		unsigned int  rsv_7						:	1;
+		unsigned int  SP_DELAY					:	3;
+		unsigned int  rsv_11					:	1;
+		unsigned int  SPDELAY_MODE				:	1;
+		unsigned int  VFDATA_EN_MUX_0_SEL		:	1;
+		unsigned int  VFDATA_EN_MUX_1_SEL		:	1;
+		unsigned int  rsv_15					:	17;
+	} Bits;
+	unsigned int Raw;
+};
+
+/* TG GRAB PXL */
+#define REG_CAMSV_TG_SEN_GRAB_PXL				0x0108
+
+/* TG_GRAB LIN */
+#define REG_CAMSV_TG_SEN_GRAB_LIN				0x010C
+
+/* TG Path CFG */
+#define REG_CAMSV_TG_PATH_CFG					0x0110
+
+#define CAMSV_TG_PATH_TG_FULL_SEL				BIT(15)
+union CAMSV_TG_PATH_CFG {
+	struct {
+		unsigned int  SEN_IN_LSB				:	3;
+		unsigned int  rsv_3						:	1;
+		unsigned int  JPGINF_EN					:	1;
+		unsigned int  MEMIN_EN					:	1;
+		unsigned int  rsv_6						:	1;
+		unsigned int  JPG_LINEND_EN				:	1;
+		unsigned int  DB_LOAD_DIS				:	1;
+		unsigned int  DB_LOAD_SRC				:	1;
+		unsigned int  DB_LOAD_VSPOL				:	1;
+		unsigned int  DB_LOAD_HOLD				:	1;
+		unsigned int  YUV_U2S_DIS				:	1;
+		unsigned int  YUV_BIN_EN				:	1;
+		unsigned int  TG_ERR_SEL				:	1;
+		unsigned int  TG_FULL_SEL				:	1;
+		unsigned int  TG_FULL_SEL2				:	1;
+		unsigned int  FLUSH_DISABLE				:	1;
+		unsigned int  INT_BANK_DISABLE			:	1;
+		unsigned int  EXP_ESC					:	1;
+		unsigned int  SUB_SOF_SRC_SEL			:	2;
+		unsigned int  rsv_22					:	10;
+	} Bits;
+	unsigned int Raw;
+};
+
+/* TG FRMSIZE ST */
+#define REG_CAMSV_TG_FRMSIZE_ST					0x0138
+
+/* TG INTER ST */
+#define REG_CAMSV_TG_INTER_ST					0x013C
+#define CAMSV_TG_CS_MASK						0x3F00
+#define CAMSV_TG_IDLE_ST						BIT(8)
+union CAMSV_TG_INTER_ST {
+	struct {
+		unsigned int  SYN_VF_DATA_EN			:	1;
+		unsigned int  OUT_RDY					:	1;
+		unsigned int  OUT_REQ					:	1;
+		unsigned int  rsv_3						:	5;
+		unsigned int  TG_CAM_CS					:	6;
+		unsigned int  rsv_14					:	2;
+		unsigned int  CAM_FRM_CNT				:	8;
+		unsigned int  CAM_TOTAL_FRM				:	8;
+	} Bits;
+	unsigned int Raw;
+};
+
+//TG_DCIF_CTL?
+
+/* TG SUB PERIOD */
+#define REG_CAMSV_TG_SUB_PERIOD					0x0164
+union CAMSV_TG_SUB_PERIOD {
+	struct {
+		unsigned int  VS_PERIOD					:	8;
+		unsigned int  SOF_PERIOD				:	8;
+		unsigned int  rsv_16					:	16;
+	} Bits;
+	unsigned int Raw;
+};
+
+/* TG FRMSIZE ST R */
+#define REG_CAMSV_TG_FRMSIZE_ST_R				0x016C
+
+/* TG TIME STAMP */
+#define REG_CAMSV_TG_TIME_STAMP					0x0178
+
+/* PAK CON */
+#define REG_CAMSV_PAK_CON						0x01C0
+union CAMSV_PAK_CON {
+	struct {
+		unsigned int  PAK_SWAP_ODR				:	2;
+		unsigned int  rsv_2						:	2;
+		unsigned int  PAK_UV_SIGN				:	1;
+		unsigned int  rsv_5						:	11;
+		unsigned int  PAK_IN_BIT				:	5;
+		unsigned int  rsv_21					:	11;
+	} Bits;
+	unsigned int Raw;
+};
+
+/* FBC IMGO CTL1 */
+#define REG_CAMSV_FBC_IMGO_CTL1					0x0240
+union CAMSV_FBC_IMGO_CTL1 {
+	struct {
+		unsigned int  rsv_0						:	8;
+		unsigned int  FBC_RESET					:	1;
+		unsigned int  FBC_DB_EN					:	1;
+		unsigned int  rsv_10					:	1;
+		unsigned int  rsv_11					:	1;
+		unsigned int  LOCK_EN					:	1;
+		unsigned int  DROP_TIMING				:	1;
+		unsigned int  FBC_SUB_EN				:	1;
+		unsigned int  FBC_EN					:	1;
+		unsigned int  VALID_NUM					:	8;
+		unsigned int  SUB_RATIO					:	8;
+	} Bits;
+	unsigned int Raw;
+};
+
+/* FBC IMGO CTL2 */
+#define REG_CAMSV_FBC_IMGO_CTL2					0x0244
+
+/* QBIN */
+#define REG_CAMSV_QBN							0x0400
+union CAMSV_QBN_CTL {
+	struct {
+		unsigned int  CAMSVQBN_ACC				:	2;
+		unsigned int  rsv_2						:	2;
+		unsigned int  CAMSVQBN_ACC_MODE			:	2;
+		unsigned int  rsv_6						:	26;
+	} Bits;
+	unsigned int Raw;
+};
+
+/* Special FUN EN */
+#define REG_CAMSV_SPECIAL_FUN_EN				0x0600
+union CAMSV_SPECIAL_FUN_EN {
+	struct {
+		unsigned int  rsv_0						:	20;
+		unsigned int  CONTINUOUS_COM_CON		:	2;
+		unsigned int  rsv_22					:	1;
+		unsigned int  CONTINUOUS_COM_EN			:	1;
+		unsigned int  LPDVT_EN					:	1;
+		unsigned int  GCLAST_EN					:	1;
+		unsigned int  DCM_MODE					:	1;
+		unsigned int  rsv_27					:	5;
+	} Bits;
+	unsigned int Raw;
+};
+
+/* DMA DEBUG SEL */
+#define REG_CAMSV_DMATOP_DMA_DEBUG_SEL			0x0670
+
+/* DMA DEBUG PORT */
+#define REG_CAMSV_DMATOP_DMA_DEBUG_PORT			0x0674
+
+/* IMGO BASE ADDR */
+#define REG_CAMSV_IMGO_BASE_ADDR				0x0700
+
+/* IMGO BASE ADDR MSB */
+#define REG_CAMSV_IMGO_BASE_ADDR_MSB			0x0704
+
+/* IMGO OFST ADDR */
+#define REG_CAMSV_IMGO_OFST_ADDR				0x0708
+
+/* IMGO OFST ADDR */
+#define REG_CAMSV_IMGO_OFST_ADDR_MSB			0x070C
+
+/* IMGO XSIZE */
+#define REG_CAMSV_IMGO_XSIZE					0x0710
+union CAMSV_IMGO_XSIZE {
+	struct {
+		unsigned int  XSIZE						:	16;
+		unsigned int  rsv_16					:	16;
+	} Bits;
+	unsigned int Raw;
+};
+
+/* IMGO YSIZE */
+#define REG_CAMSV_IMGO_YSIZE					0x0714
+union CAMSV_IMGO_YSIZE {
+	struct {
+		unsigned int  YSIZE						:	16;
+		unsigned int  rsv_16					:	16;
+	} Bits;
+	unsigned int Raw;
+};
+
+/* IMGO STRIDE */
+#define REG_CAMSV_IMGO_STRIDE					0x0718
+union CAMSV_IMGO_STRIDE {
+	struct {
+		unsigned int  STRIDE					:	16;
+		unsigned int  rsv_16					:	16;
+	} Bits;
+	unsigned int Raw;
+};
+
+#define REG_CAMSV_IMGO_BASIC					0x071C
+union CAMSV_IMGO_BASIC {
+	struct {
+		unsigned int  BUS_SIZE					:	4;
+		unsigned int  rsv_4						:	4;
+		unsigned int  FORMAT					:	6;
+		unsigned int  rsv_14					:	9;
+		unsigned int  EVEN_ODD_EN				:	1;
+		unsigned int  rsv_24					:	4;
+		unsigned int  BUS_SIZE_EN				:	1;
+		unsigned int  FORMAT_EN					:	1;
+		unsigned int  rsv_30					:	1;
+		unsigned int  EVEN_ODD_EN_EN			:	1;
+	} Bits;
+	unsigned int Raw;
+};
+
+/* IMGO CON0 */
+#define REG_CAMSV_IMGO_CON0						0x0720
+union CAMSV_IMGO_CON0 {
+	struct {
+		unsigned int  FIFO_SIZE					:	12;
+		unsigned int  rsv_12					:	12;
+		unsigned int  MAX_BURST_LEN				:	8;
+	} Bits;
+	unsigned int Raw;
+};
+
+/* IMGO CON1 */
+#define REG_CAMSV_IMGO_CON1						0x0724
+union CAMSV_IMGO_CON1 {
+	struct {
+		unsigned int  FIFO_PRE_PRI_THRL			:	12;
+		unsigned int  rsv_12					:	4;
+		unsigned int  FIFO_PRE_PRI_THRH			:	12;
+		unsigned int  LAST_PRE_ULTRA_EN			:	1;
+		unsigned int  rsv_29					:	3;
+	} Bits;
+	unsigned int Raw;
+};
+
+/* IMGO CON2 */
+#define REG_CAMSV_IMGO_CON2						0x0728
+union CAMSV_IMGO_CON2 {
+	struct {
+		unsigned int  FIFO_PRI_THRL				:	12;
+		unsigned int  rsv_12					:	4;
+		unsigned int  FIFO_PRI_THRH				:	12;
+		unsigned int  LAST_ULTRA_EN				:	1;
+		unsigned int  rsv_29					:	3;
+	} Bits;
+	unsigned int Raw;
+};
+
+/* IMGO CON3 */
+#define REG_CAMSV_IMGO_CON3						0x072C
+union CAMSV_IMGO_CON3 {
+	struct {
+		unsigned int  FIFO_URGENT_THRL			:	12;
+		unsigned int  rsv_12					:	4;
+		unsigned int  FIFO_URGENT_THRH			:	12;
+		unsigned int  rsv_28					:	3;
+		unsigned int  FIFO_URGENT_EN			:	1;
+	} Bits;
+	unsigned int Raw;
+};
+
+/* IMGO CON4 */
+#define REG_CAMSV_IMGO_CON4						0x0730
+union CAMSV_IMGO_CON4 {
+	struct {
+		unsigned int  FIFO_DVFS_THRL			:	12;
+		unsigned int  rsv_12					:	4;
+		unsigned int  FIFO_DVFS_THRH			:	12;
+		unsigned int  rsv_28					:	3;
+		unsigned int  FIFO_DVFS_EN				:	1;
+	} Bits;
+	unsigned int Raw;
+};
+
+/* IMGO ERR STAT */
+#define REG_CAMSV_IMGO_ERR_STAT					0x0734
+
+/* DMA SPECIAL EN */
+#define REG_CAMSV_DMA_SPECIAL_EN				0x0738
+union CAMSV_DMA_SPECIAL_EN {
+	struct {
+		unsigned int  UFO_EN					:	1;
+		unsigned int  rsv_1						:	2;
+		unsigned int  UFO_XSIZE_QUEUE_FULL		:	1;
+		unsigned int  FH_EN						:	1;
+		unsigned int  rsv_5						:	2;
+		unsigned int  N_UFE_XSIZE_QUEUE_FULL	:	1; //error flag
+		unsigned int  IPU_RING_EN				:	1;
+		unsigned int  RING_EN					:	1;
+		unsigned int  rsv_10					:	2;
+		unsigned int  BW_SELF_TEST_EN			:	1;
+		unsigned int  V_FLIP_EN					:	1;
+		unsigned int  V_FLIP_X2_EN				:	1;
+		unsigned int  rsv_15					:	17;
+	} Bits;
+	unsigned int Raw;
+};
+
+/* IMGO CROP */
+#define REG_CAMSV_IMGO_CROP						0x074C
+union CAMSV_IMGO_CROP {
+	struct {
+		unsigned int  XOFFSET					:	16;
+		unsigned int  YOFFSET					:	16;
+	} Bits;
+	unsigned int Raw;
+};
+
+/* IMGO FH SPARE 3 */
+#define REG_CAMSV_FRAME_SEQ_NO					0x075C
+
+/* IRQ Error Mask */
+#define INT_ST_MASK_CAMSV_ERR (\
+					CAMSV_INT_TG_ERR_ST |\
+					CAMSV_INT_TG_GBERR_ST |\
+					CAMSV_INT_DB_LOAD_ERR_ST |\
+					CAMSV_INT_DMA_ERR_ST |\
+					CAMSV_INT_IMGO_OVERR_ST)
+
+/* Dma Error Mask */
+#define DMA_ST_MASK_CAMSV_ERR (\
+					CAMSV_INT_DMA_ERR_ST)
+
+#endif	/* _CAMSV_REGS_H */
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam-sv-regs-mt8195.h b/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam-sv-regs-mt8195.h
new file mode 100644
index 0000000000000000000000000000000000000000..bad153978d0be22a819409cd320f5e456ea5273b
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam-sv-regs-mt8195.h
@@ -0,0 +1,564 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2022 MediaTek Inc.
+ */
+
+#ifndef _CAMSV_REGS_H
+#define _CAMSV_REGS_H
+
+/*  */
+#define REG_CAMSV_TOP_FBC_CNT_SET				0x0014
+union CAMSV_TOP_FBC_CNT_SET {
+	struct {
+		unsigned int  RCNT_INC1					:	1;
+		unsigned int  RCNT_INC2					:	1;
+		unsigned int  RCNT_INC3					:	1;
+		unsigned int  RCNT_INC4					:	1;
+		unsigned int  rsv_4						:	28;
+	} Bits;
+	unsigned int Raw;
+};
+
+/* Module EN */
+#define REG_CAMSV_MODULE_EN						0x0040
+union CAMSV_MODULE_EN {
+	struct {
+		unsigned int  TG_EN						:	1;
+		unsigned int  rsv_1						:	1;
+		unsigned int  PAK_EN					:	1;
+		unsigned int  PAK_SEL					:	1;
+		unsigned int  IMGO_EN					:	1;
+		unsigned int  rsv_5						:	1;
+		unsigned int  UFE_EN					:	1;
+		unsigned int  rsv_7						:	9;
+		unsigned int  DOWN_SAMPLE_PERIOD		:	8;
+		unsigned int  DOWN_SAMPLE_EN			:	1;
+		unsigned int  rsv_25					:	3;
+		unsigned int  DB_LOAD_SRC				:	2;
+		unsigned int  DB_EN						:	1;
+		unsigned int  DB_LOCK					:	1;
+	} Bits;
+	unsigned int Raw;
+};
+
+/* FMT SEL */
+#define REG_CAMSV_FMT_SEL						0x0044
+union CAMSV_FMT_SEL {
+	struct {
+		unsigned int  TG1_FMT					:	3;
+		unsigned int  rsv_3						:	2;
+		unsigned int  TG1_SW					:	2;
+		unsigned int  rsv_7						:	1;
+		unsigned int  LP_MODE					:	1;
+		unsigned int  HLR_MODE					:	1;
+		unsigned int  rsv_10					:	22;
+	} Bits;
+	unsigned int Raw;
+};
+
+/* INT EN */
+#define REG_CAMSV_INT_EN						0x0048
+union CAMSV_INT_EN {
+	struct {
+		unsigned int  VS_INT_EN					:	1;
+		unsigned int  TG_INT1_EN				:	1;
+		unsigned int  TG_INT2_EN				:	1;
+		unsigned int  EXPDON1_INT_EN			:	1;
+		unsigned int  TG_ERR_INT_EN				:	1;
+		unsigned int  TG_GBERR_INT_EN			:	1;
+		unsigned int  TG_SOF_INT_EN				:	1;
+		unsigned int  TG_SOF_WAIT_INT_EN		:	1;
+		unsigned int  TG_SOF_DROP_INT_EN		:	1;
+		unsigned int  VS_INT_ORG_EN				:	1;
+		unsigned int  DB_LOAD_ERR_EN			:	1;
+		unsigned int  PASS1_DON_INT_EN			:	1;
+		unsigned int  SW_PASS1_DON_INT_EN		:	1;
+		unsigned int  SUB_PASS1_DON_INT_EN		:	1;
+		unsigned int  rsv_14					:	1;
+		unsigned int  UFEO_OVERR_INT_EN			:	1;
+		unsigned int  DMA_ERR_INT_EN			:	1;
+		unsigned int  IMGO_OVERR_INT_EN			:	1;
+		unsigned int  UFEO_DROP_INT_EN			:	1;
+		unsigned int  IMGO_DROP_INT_EN			:	1;
+		unsigned int  IMGO_DONE_INT_EN			:	1;
+		unsigned int  UFEO_DONE_INT_EN			:	1;
+		unsigned int  TG_INT3_EN				:	1;
+		unsigned int  TG_INT4_EN				:	1;
+		unsigned int  rsv_24					:	7;
+		unsigned int  INT_WCLR_EN				:	1;
+	} Bits;
+	unsigned int Raw;
+};
+
+
+/* INT Status */
+#define REG_CAMSV_INT_STATUS					0x004C
+#define CAMSV_INT_VS_ST							BIT(0)
+#define CAMSV_INT_TG_ST1						BIT(1)
+#define CAMSV_INT_TG_ST2						BIT(2)
+#define CAMSV_INT_EXPDON1_ST					BIT(3)
+#define CAMSV_INT_TG_ERR_ST						BIT(4)
+#define CAMSV_INT_TG_GBERR_ST					BIT(5)
+#define CAMSV_INT_TG_SOF_INT_ST					BIT(6)
+#define CAMSV_INT_DB_LOAD_ERR_ST				BIT(10)
+#define CAMSV_INT_PASS1_DON_ST					BIT(11)
+#define CAMSV_INT_SW_PASS1_DON_ST				BIT(12)
+#define CAMSV_INT_SUB_PASS1_DON_ST				BIT(13)
+#define CAMSV_INT_UFEO_OVERR_ST					BIT(15)
+#define CAMSV_INT_DMA_ERR_ST					BIT(16)
+#define CAMSV_INT_IMGO_OVERR_ST					BIT(17)
+#define CAMSV_INT_UFEO_DROP_ST					BIT(18)
+#define CAMSV_INT_IMGO_DROP_ST					BIT(19)
+#define CAMSV_INT_IMGO_DONE_ST					BIT(20)
+#define CAMSV_INT_UFEO_DONE_ST					BIT(21)
+#define CAMSV_INT_TG_ST3						BIT(22)
+#define CAMSV_INT_TG_ST4						BIT(23)
+union CAMSV_INT_STATUS {
+	struct {
+		unsigned int  VS_ST						:	1;
+		unsigned int  TG_ST1					:	1;
+		unsigned int  TG_ST2					:	1;
+		unsigned int  EXPDON1_ST				:	1;
+		unsigned int  SV_TG_ERR_ST				:	1;
+		unsigned int  SV_TG_GBERR_ST			:	1;
+		unsigned int  TG_SOF_INT_ST				:	1;
+		unsigned int  TG_SOF_WAIT_ST			:	1;
+		unsigned int  TG_SOF_DROP_ST			:	1;
+		unsigned int  VS_ORG_ST					:	1;
+		unsigned int  DB_LOAD_ERR_ST			:	1;
+		unsigned int  PASS1_DON_ST				:	1;
+		unsigned int  SV_SW_PASS1_DON_ST		:	1;
+		unsigned int  SUB_PASS1_DON_ST			:	1;
+		unsigned int  rsv_14					:	1;
+		unsigned int  SV_UFEO_OVERR_ST			:	1;
+		unsigned int  SV_DMA_ERR_ST				:	1;
+		unsigned int  SV_IMGO_OVERR_ST			:	1;
+		unsigned int  SV_UFEO_DROP_ST			:	1;
+		unsigned int  SV_IMGO_DROP_ST			:	1;
+		unsigned int  SV_IMGO_DONE_ST			:	1;
+		unsigned int  SV_UFEO_DONE_ST			:	1;
+		unsigned int  TG_ST3					:	1;
+		unsigned int  TG_ST4					:	1;
+		unsigned int  rsv_20					:	8;
+	} Bits;
+	unsigned int Raw;
+};
+
+/* SW CTL */
+#define REG_CAMSV_SW_CTL						0x0050
+
+/* IMGO FBC */
+#define REG_CAMSV_IMGO_FBC						0x005C
+union CAMSV_IMGO_FBC {
+	struct {
+		unsigned int  rsv_0						:	1;
+		unsigned int  rsv_1						:	1;
+		unsigned int  rsv_2						:	1;
+		unsigned int  rsv_3						:	1;
+		unsigned int  IMGO_FIFO_FULL_EN			:	1;
+		unsigned int  UFEO_FIFO_FULL_EN			:	1;
+		unsigned int  IMGO_FBC_FIFO_FULL_SEL	:	1;
+		unsigned int  UFEO_FBC_FIFO_FULL_SEL	:	1;
+		unsigned int  rsv_8						:	24;
+	} Bits;
+	unsigned int Raw;
+};
+
+/* CLK EN */
+#define REG_CAMSV_CLK_EN						0x0060
+union CAMSV_CLK_EN {
+	struct {
+		unsigned int  TG_DP_CK_EN				:	1;
+		unsigned int  rsv_1						:	1;
+		unsigned int  PAK_DP_CK_EN				:	1;
+		unsigned int  rsv_3						:	1;
+		unsigned int  UFEO_DP_CK_EN				:	1;
+		unsigned int  rsv_5						:	10;
+		unsigned int  IMGO_DP_CK_EN				:	1;
+		unsigned int  rsv_16					:	16;
+	} Bits;
+	unsigned int Raw;
+};
+
+/* DCIF Set */
+#define REG_CAMSV_DCIF_SET						0x0074
+union CAMSV_DCIF_SET {
+	struct {
+		unsigned int  rsv_0						:	6;
+		unsigned int  POSTPONE_PASS1_DONE		:	1;
+		unsigned int  MASK_DB_LOAD				:	1;
+		unsigned int  ENABLE_OUTPUT_CQ_START_SIGNAL	:	1;
+		unsigned int  ENABLE_REFERENCE_COUPLE_CAMSV_PASS1_ENABLE	:	1;
+		unsigned int  SEL_THE_SOF_SIGNAL_FROM	:	2;
+		unsigned int  rsv_12					:	3;
+		unsigned int  FOR_DCIF_SUBSAMPLE_EN		:	1;
+		unsigned int  FOR_DCIF_SUBSAMPLE_NUMBER	:	8;
+		unsigned int  FOR_DCIF_CQ_START_TIMING	:	8;
+	} Bits;
+	unsigned int Raw;
+};
+
+/* SUB CTRL */
+#define REG_CAMSV_SUB_CTRL						0x0078
+union CAMSV_SUB_CTRL {
+	struct {
+		unsigned int  CENTRAL_SUB_EN			:	1;
+		unsigned int  rsv_1						:	31;
+	} Bits;
+	unsigned int Raw;
+};
+
+/* PAK */
+#define REG_CAMSV_PAK							0x007C
+union CAMSV_PAK {
+	struct {
+		unsigned int  PAK_MODE					:	8;
+		unsigned int  PAK_DBL_MODE				:	2;
+		unsigned int  rsv_10					:	22;
+	} Bits;
+	unsigned int Raw;
+};
+
+/* TG SEN Mode */
+#define REG_CAMSV_TG_SEN_MODE					0x0100
+#define CAMSV_TG_SEN_MODE_CMOS_EN				BIT(0)
+#define CAMSV_TG_SEN_MODE_CMOS_RDY_SEL			BIT(14)
+union CAMSV_TG_SEN_MODE {
+	struct {
+		unsigned int  CMOS_EN					:	1;
+		unsigned int  rsv_1						:	1;
+		unsigned int  SOT_MODE					:	1;
+		unsigned int  SOT_CLR_MODE				:	1;
+		unsigned int  DBL_DATA_BUS				:	2;
+		unsigned int  rsv_6						:	2;
+		unsigned int  SOF_SRC					:	2;
+		unsigned int  EOF_SRC					:	2;
+		unsigned int  PXL_CNT_RST_SRC			:	1;
+		unsigned int  rsv_13					:	1;
+		unsigned int  CMOS_RDY_SEL				:	1;
+		unsigned int  FIFO_FULL_CTL_EN			:	1;
+		unsigned int  TIME_STP_EN				:	1;
+		unsigned int  VS_SUB_EN					:	1;
+		unsigned int  SOF_SUB_EN				:	1;
+		unsigned int  VSYNC_INT_POL				:	1;
+		unsigned int  EOF_ALS_RDY_EN			:	1;
+		unsigned int  rsv_21					:	1;
+		unsigned int  STAGGER_EN				:	1;
+		unsigned int  HDR_EN					:	1;
+		unsigned int  HDR_SEL					:	1;
+		unsigned int  SOT_DLY_EN				:	1;
+		unsigned int  VS_IGNORE_STALL_EN		:	1;
+		unsigned int  LINE_OK_CHECK				:	1;
+		unsigned int  rsv_28					:	4;
+	} Bits;
+	unsigned int Raw;
+};
+
+/* TG VF CON */
+#define REG_CAMSV_TG_VF_CON						0x0104
+#define CAMSV_TG_VF_CON_VFDATA_EN				BIT(0)
+union CAMSV_TG_VF_CON {
+	struct {
+		unsigned int  VFDATA_EN					:	1;
+		unsigned int  SINGLE_MODE				:	1;
+		unsigned int  rsv_2						:	2;
+		unsigned int  FR_CON					:	3;
+		unsigned int  rsv_7						:	1;
+		unsigned int  SP_DELAY					:	3;
+		unsigned int  rsv_11					:	1;
+		unsigned int  SPDELAY_MODE				:	1;
+		unsigned int  VFDATA_EN_MUX_0_SEL		:	1;
+		unsigned int  VFDATA_EN_MUX_1_SEL		:	1;
+		unsigned int  rsv_15					:	17;
+	} Bits;
+	unsigned int Raw;
+};
+
+/* TG GRAB PXL */
+#define REG_CAMSV_TG_SEN_GRAB_PXL				0x0108
+
+/* TG_GRAB LIN */
+#define REG_CAMSV_TG_SEN_GRAB_LIN				0x010C
+
+/* TG Path CFG */
+#define REG_CAMSV_TG_PATH_CFG					0x0110
+
+#define CAMSV_TG_PATH_TG_FULL_SEL				BIT(15)
+union CAMSV_TG_PATH_CFG {
+	struct {
+		unsigned int  SEN_IN_LSB				:	3;
+		unsigned int  rsv_3						:	1;
+		unsigned int  JPGINF_EN					:	1;
+		unsigned int  MEMIN_EN					:	1;
+		unsigned int  rsv_6						:	1;
+		unsigned int  JPG_LINEND_EN				:	1;
+		unsigned int  DB_LOAD_DIS				:	1;
+		unsigned int  DB_LOAD_SRC				:	1;
+		unsigned int  DB_LOAD_VSPOL				:	1;
+		unsigned int  rsv_11					:	1;
+		unsigned int  YUV_U2S_DIS				:	1;
+		unsigned int  YUV_BIN_EN				:	1;
+		unsigned int  TG_ERR_SEL				:	1;
+		unsigned int  TG_FULL_SEL				:	1;
+		unsigned int  TG_FULL_SEL2				:	1;
+		unsigned int  FLUSH_DISABLE				:	1;
+		unsigned int  INT_BANK_DISABLE			:	1;
+		unsigned int  EXP_ESC					:	1;
+		unsigned int  SUB_SOF_SRC_SEL			:	2;
+		unsigned int  rsv_22					:	10;
+	} Bits;
+	unsigned int Raw;
+};
+
+/* TG FRMSIZE ST */
+#define REG_CAMSV_TG_FRMSIZE_ST					0x0138
+
+/* TG INTER ST */
+#define REG_CAMSV_TG_INTER_ST					0x013C
+#define CAMSV_TG_CS_MASK						0x3F00
+#define CAMSV_TG_IDLE_ST						BIT(8)
+union CAMSV_TG_INTER_ST {
+	struct {
+		unsigned int  SYN_VF_DATA_EN			:	1;
+		unsigned int  OUT_RDY					:	1;
+		unsigned int  OUT_REQ					:	1;
+		unsigned int  rsv_3						:	5;
+		unsigned int  TG_CAM_CS					:	6;
+		unsigned int  rsv_14					:	2;
+		unsigned int  CAM_FRM_CNT				:	8;
+		unsigned int  CAM_TOTAL_FRM				:	8;
+	} Bits;
+	unsigned int Raw;
+};
+
+/* TG SUB PERIOD */
+#define REG_CAMSV_TG_SUB_PERIOD					0x0164
+union CAMSV_TG_SUB_PERIOD {
+	struct {
+		unsigned int  VS_PERIOD					:	8;
+		unsigned int  SOF_PERIOD				:	8;
+		unsigned int  rsv_16					:	16;
+	} Bits;
+	unsigned int Raw;
+};
+
+/* TG FRMSIZE ST R */
+#define REG_CAMSV_TG_FRMSIZE_ST_R				0x016C
+
+/* TG TIME STAMP */
+#define REG_CAMSV_TG_TIME_STAMP					0x0178
+
+/* PAK CON */
+#define REG_CAMSV_PAK_CON						0x01C0
+union CAMSV_PAK_CON {
+	struct {
+		unsigned int  PAK_SWAP_ODR				:	2;
+		unsigned int  rsv_2						:	2;
+		unsigned int  PAK_UV_SIGN				:	1;
+		unsigned int  rsv_5						:	11;
+		unsigned int  PAK_IN_BIT				:	5;
+		unsigned int  rsv_21					:	11;
+	} Bits;
+	unsigned int Raw;
+};
+
+/* FBC IMGO CTL1 */
+#define REG_CAMSV_FBC_IMGO_CTL1					0x0240
+union CAMSV_FBC_IMGO_CTL1 {
+	struct {
+		unsigned int  rsv_0						:	8;
+		unsigned int  FBC_RESET					:	1;
+		unsigned int  FBC_DB_EN					:	1;
+		unsigned int  rsv_10					:	1;
+		unsigned int  rsv_11					:	1;
+		unsigned int  LOCK_EN					:	1;
+		unsigned int  DROP_TIMING				:	1;
+		unsigned int  FBC_SUB_EN				:	1;
+		unsigned int  FBC_EN					:	1;
+		unsigned int  VALID_NUM					:	8;
+		unsigned int  SUB_RATIO					:	8;
+	} Bits;
+	unsigned int Raw;
+};
+
+/* FBC IMGO CTL1 */
+#define REG_CAMSV_FBC_IMGO_CTL2					0x0244
+
+/* Special FUN EN */
+#define REG_CAMSV_SPECIAL_FUN_EN				0x0600
+union CAMSV_SPECIAL_FUN_EN {
+	struct {
+		unsigned int  rsv_0						:	20;
+		unsigned int  CONTINUOUS_COM_CON		:	2;
+		unsigned int  rsv_22					:	1;
+		unsigned int  CONTINUOUS_COM_EN			:	1;
+		unsigned int  LPDVT_EN					:	1;
+		unsigned int  GCLAST_EN					:	1;
+		unsigned int  DCM_MODE					:	1;
+		unsigned int  rsv_27					:	5;
+	} Bits;
+	unsigned int Raw;
+};
+
+/* DMA DEBUG SEL */
+#define REG_CAMSV_DMATOP_DMA_DEBUG_SEL                  0x0670
+
+/* DMA DEBUG PORT */
+#define REG_CAMSV_DMATOP_DMA_DEBUG_PORT                 0x0674
+
+/* IMGO BASE ADDR */
+#define REG_CAMSV_IMGO_BASE_ADDR				0x0700
+
+/* IMGO BASE ADDR MSB */
+#define REG_CAMSV_IMGO_BASE_ADDR_MSB			0x0704
+
+/* IMGO OFST ADDR */
+#define REG_CAMSV_IMGO_OFST_ADDR				0x0708
+
+/* IMGO OFST ADDR */
+#define REG_CAMSV_IMGO_OFST_ADDR_MSB			0x070C
+
+/* IMGO XSIZE */
+#define REG_CAMSV_IMGO_XSIZE					0x0710
+union CAMSV_IMGO_XSIZE {
+	struct {
+		unsigned int  XSIZE						:	16;
+		unsigned int  rsv_16					:	16;
+	} Bits;
+	unsigned int Raw;
+};
+
+/* IMGO YSIZE */
+#define REG_CAMSV_IMGO_YSIZE					0x0714
+union CAMSV_IMGO_YSIZE {
+	struct {
+		unsigned int  YSIZE						:	16;
+		unsigned int  rsv_16					:	16;
+	} Bits;
+	unsigned int Raw;
+};
+
+/* IMGO STRIDE */
+#define REG_CAMSV_IMGO_STRIDE					0x0718
+union CAMSV_IMGO_STRIDE {
+	struct {
+		unsigned int  STRIDE					:	16;
+		unsigned int  BUS_SIZE					:	4;
+		unsigned int  FORMAT					:	6;
+		unsigned int  FORMAT_EN					:	1;
+		unsigned int  BUS_SIZE_EN				:	1;
+		unsigned int  rsv_28					:	4;
+	} Bits;
+	unsigned int Raw;
+};
+
+/* IMGO CON0 */
+#define REG_CAMSV_IMGO_CON0						0x071C
+union CAMSV_IMGO_CON0 {
+	struct {
+		unsigned int  FIFO_SIZE					:	12;
+		unsigned int  rsv_12					:	16;
+		unsigned int  MAX_BURST_LEN				:	4;
+	} Bits;
+	unsigned int Raw;
+};
+
+/* IMGO CON1 */
+#define REG_CAMSV_IMGO_CON1						0x0720
+union CAMSV_IMGO_CON1 {
+	struct {
+		unsigned int  FIFO_PRE_PRI_THRL			:	12;
+		unsigned int  rsv_12					:	4;
+		unsigned int  FIFO_PRE_PRI_THRH			:	12;
+		unsigned int  LAST_PRE_ULTRA_EN			:	1;
+		unsigned int  rsv_29					:	3;
+	} Bits;
+	unsigned int Raw;
+};
+
+/* IMGO CON2 */
+#define REG_CAMSV_IMGO_CON2						0x0724
+union CAMSV_IMGO_CON2 {
+	struct {
+		unsigned int  FIFO_PRI_THRL				:	12;
+		unsigned int  rsv_12					:	4;
+		unsigned int  FIFO_PRI_THRH				:	12;
+		unsigned int  LAST_ULTRA_EN				:	1;
+		unsigned int  rsv_29					:	3;
+	} Bits;
+	unsigned int Raw;
+};
+
+/* IMGO CON3 */
+#define REG_CAMSV_IMGO_CON3						0x0728
+union CAMSV_IMGO_CON3 {
+	struct {
+		unsigned int  FIFO_URGENT_THRL			:	12;
+		unsigned int  rsv_12					:	4;
+		unsigned int  FIFO_URGENT_THRH			:	12;
+		unsigned int  rsv_28					:	3;
+		unsigned int  FIFO_URGENT_EN			:	1;
+	} Bits;
+	unsigned int Raw;
+};
+
+/* IMGO CON4 */
+#define REG_CAMSV_IMGO_CON4						0x072C
+union CAMSV_IMGO_CON4 {
+	struct {
+		unsigned int  FIFO_DVFS_THRL			:	12;
+		unsigned int  rsv_12					:	4;
+		unsigned int  FIFO_DVFS_THRH			:	12;
+		unsigned int  rsv_28					:	3;
+		unsigned int  FIFO_DVFS_EN				:	1;
+	} Bits;
+	unsigned int Raw;
+};
+
+/* IMGO ERR STAT */
+#define REG_CAMSV_IMGO_ERR_STAT					0x0730
+
+/* DMA SPECIAL EN */
+#define REG_CAMSV_DMA_SPECIAL_EN				0x0734
+union CAMSV_DMA_SPECIAL_EN {
+	struct {
+		unsigned int  UFO_EN					:	1;
+		unsigned int  rsv_1						:	2;
+		unsigned int  UFO_XSIZE_QUEUE_FULL		:	1;
+		unsigned int  FH_EN						:	1;
+		unsigned int  rsv_5						:	3;
+		unsigned int  IPU_RING_EN				:	1;
+		unsigned int  RING_EN					:	1;
+		unsigned int  rsv_10					:	2;
+		unsigned int  BW_SELF_TEST_EN			:	1;
+		unsigned int  V_FLIP_EN					:	1;
+		unsigned int  V_FLIP_X2_EN				:	1;
+		unsigned int  rsv_15					:	17;
+	} Bits;
+	unsigned int Raw;
+};
+
+/* IMGO CROP */
+#define REG_CAMSV_IMGO_CROP						0x0748
+union CAMSV_IMGO_CROP {
+	struct {
+		unsigned int  XOFFSET					:	16;
+		unsigned int  YOFFSET					:	16;
+	} Bits;
+	unsigned int Raw;
+};
+
+/* IMGO FH SPARE 3 */
+#define REG_CAMSV_FRAME_SEQ_NO					0x0758
+
+/* IRQ Error Mask */
+#define INT_ST_MASK_CAMSV_ERR (\
+					CAMSV_INT_TG_ERR_ST |\
+					CAMSV_INT_TG_GBERR_ST |\
+					CAMSV_INT_DB_LOAD_ERR_ST)
+
+/* Dma Error Mask */
+#define DMA_ST_MASK_CAMSV_ERR (\
+					CAMSV_INT_DMA_ERR_ST)
+
+#endif	/* _CAMSV_REGS_H */
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam-sv.c b/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam-sv.c
new file mode 100755
index 0000000000000000000000000000000000000000..42692ce2bc0d7fbe7b90e367ffa1d7f487fa96e4
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam-sv.c
@@ -0,0 +1,2992 @@
+// SPDX-License-Identifier: GPL-2.0
+//
+// Copyright (c) 2022 MediaTek Inc.
+
+#include <linux/clk.h>
+#include <linux/component.h>
+#include <linux/interrupt.h>
+#include <linux/iopoll.h>
+#include <linux/module.h>
+#include <linux/of_platform.h>
+#include <linux/of.h>
+#include <linux/platform_device.h>
+#include <linux/pm_runtime.h>
+#include <linux/vmalloc.h>
+#include <linux/videodev2.h>
+#include <linux/jiffies.h>
+
+#include <media/v4l2-device.h>
+#include <media/v4l2-event.h>
+#include <media/v4l2-ioctl.h>
+#include <media/v4l2-subdev.h>
+
+#include <soc/mediatek/smi.h>
+
+#include "mtk_cam.h"
+#include "mtk_cam-feature.h"
+#include "mtk_cam_pm.h"
+#include "mtk_cam-pool.h"
+
+#ifdef ISP7_1
+#include "mtk_cam-sv-regs-mt8188.h"
+#else //MT8195
+#include "mtk_cam-sv-regs-mt8195.h"
+#endif
+
+#include "mtk_cam-sv.h"
+#include "mtk_camera-v4l2-controls.h"
+
+#ifdef CONFIG_MTK_SMI_EXT
+#include "smi_public.h"
+#endif
+
+#ifdef CONFIG_MTK_IOMMU_V2
+#include "mtk_iommu_ext.h"
+#include "mach/pseudo_m4u.h"
+#endif
+
+#ifdef CAMSYS_TF_DUMP_71_1
+#include <dt-bindings/memory/mt6983-larb-port.h>
+#include "iommu_debug.h"
+#endif
+
+#define MTK_CAMSV_STOP_HW_TIMEOUT			(33 * USEC_PER_MSEC)
+
+static const struct of_device_id mtk_camsv_of_ids[] = {
+	{.compatible = "mediatek,camsv",},
+	{}
+};
+MODULE_DEVICE_TABLE(of, mtk_camsv_of_ids);
+
+static void mtk_camsv_register_iommu_tf_callback(struct mtk_camsv_device *sv)
+{
+#ifdef CAMSYS_TF_DUMP_71_1
+	dev_dbg(sv->dev, "%s : sv->id:%d\n", __func__, sv->id);
+
+	switch (sv->id) {
+	case CAMSV_0:
+		mtk_iommu_register_fault_callback(M4U_PORT_L13_CAM1_GCAMSV_A_IMGO_1,
+			mtk_camsv_translation_fault_callback, (void *)sv, false);
+		break;
+	case CAMSV_1:
+		mtk_iommu_register_fault_callback(M4U_PORT_L13_CAM1_GCAMSV_A_IMGO_2,
+			mtk_camsv_translation_fault_callback, (void *)sv, false);
+		break;
+	case CAMSV_2:
+		mtk_iommu_register_fault_callback(M4U_PORT_L14_CAM1_GCAMSV_B_IMGO_1,
+			mtk_camsv_translation_fault_callback, (void *)sv, false);
+		break;
+	case CAMSV_3:
+		mtk_iommu_register_fault_callback(M4U_PORT_L14_CAM1_GCAMSV_B_IMGO_2,
+			mtk_camsv_translation_fault_callback, (void *)sv, false);
+		break;
+	case CAMSV_4:
+		mtk_iommu_register_fault_callback(M4U_PORT_L13_CAM1_GCAMSV_C_IMGO_1,
+			mtk_camsv_translation_fault_callback, (void *)sv, false);
+		break;
+	case CAMSV_5:
+		mtk_iommu_register_fault_callback(M4U_PORT_L13_CAM1_GCAMSV_C_IMGO_2,
+			mtk_camsv_translation_fault_callback, (void *)sv, false);
+		break;
+	case CAMSV_6:
+		mtk_iommu_register_fault_callback(M4U_PORT_L14_CAM1_GCAMSV_D_IMGO_1,
+			mtk_camsv_translation_fault_callback, (void *)sv, false);
+		break;
+	case CAMSV_7:
+		mtk_iommu_register_fault_callback(M4U_PORT_L14_CAM1_GCAMSV_D_IMGO_2,
+			mtk_camsv_translation_fault_callback, (void *)sv, false);
+		break;
+	case CAMSV_8:
+		mtk_iommu_register_fault_callback(M4U_PORT_L13_CAM1_GCAMSV_E_IMGO_1,
+			mtk_camsv_translation_fault_callback, (void *)sv, false);
+		break;
+	case CAMSV_9:
+		mtk_iommu_register_fault_callback(M4U_PORT_L13_CAM1_GCAMSV_E_IMGO_2,
+			mtk_camsv_translation_fault_callback, (void *)sv, false);
+		break;
+	case CAMSV_10:
+		mtk_iommu_register_fault_callback(M4U_PORT_L14_CAM1_GCAMSV_F_IMGO_1,
+			mtk_camsv_translation_fault_callback, (void *)sv, false);
+		break;
+	case CAMSV_11:
+		mtk_iommu_register_fault_callback(M4U_PORT_L14_CAM1_GCAMSV_F_IMGO_2,
+			mtk_camsv_translation_fault_callback, (void *)sv, false);
+		break;
+	case CAMSV_12:
+		mtk_iommu_register_fault_callback(M4U_PORT_L13_CAM1_GCAMSV_G_IMGO_1,
+			mtk_camsv_translation_fault_callback, (void *)sv, false);
+		break;
+	case CAMSV_13:
+		mtk_iommu_register_fault_callback(M4U_PORT_L13_CAM1_GCAMSV_G_IMGO_2,
+			mtk_camsv_translation_fault_callback, (void *)sv, false);
+		break;
+	case CAMSV_14:
+		mtk_iommu_register_fault_callback(M4U_PORT_L14_CAM1_GCAMSV_H_IMGO_1,
+			mtk_camsv_translation_fault_callback, (void *)sv, false);
+		break;
+	case CAMSV_15:
+		mtk_iommu_register_fault_callback(M4U_PORT_L14_CAM1_GCAMSV_H_IMGO_2,
+			mtk_camsv_translation_fault_callback, (void *)sv, false);
+		break;
+	}
+#endif
+};
+
+#ifdef CAMSYS_TF_DUMP_71_1
+int mtk_camsv_translation_fault_callback(int port, dma_addr_t mva, void *data)
+{
+	struct mtk_camsv_device *sv_dev = (struct mtk_camsv_device *)data;
+
+	dev_info(sv_dev->dev, "mod_en:0x%x fmt_sel:0x%x imgo_fbc_ctrl1:0x%x imgo_fbc_ctrl2:0x%x",
+		readl_relaxed(sv_dev->base_inner + REG_CAMSV_MODULE_EN),
+		readl_relaxed(sv_dev->base_inner + REG_CAMSV_FMT_SEL),
+		readl_relaxed(sv_dev->base_inner + REG_CAMSV_FBC_IMGO_CTL1),
+		readl_relaxed(sv_dev->base_inner + REG_CAMSV_FBC_IMGO_CTL2));
+
+	dev_info(sv_dev->dev, "tg_sen_mode:0x%x tg_vf_con:0x%x tg_path_cfg:0x%x tg_grab_pxl:0x%x tg_grab_lin:0x%x",
+		readl_relaxed(sv_dev->base_inner + REG_CAMSV_TG_SEN_MODE),
+		readl_relaxed(sv_dev->base_inner + REG_CAMSV_TG_VF_CON),
+		readl_relaxed(sv_dev->base_inner + REG_CAMSV_TG_PATH_CFG),
+		readl_relaxed(sv_dev->base_inner + REG_CAMSV_TG_SEN_GRAB_PXL),
+		readl_relaxed(sv_dev->base_inner + REG_CAMSV_TG_SEN_GRAB_LIN));
+
+	dev_info(sv_dev->dev, "imgo_xsize:0x%x imgo_ysize:0x%x imgo_stride:0x%x imgo_addr:0x%x_%x imgo_ofst_addr:0x%x_%x",
+		readl_relaxed(sv_dev->base_inner + REG_CAMSV_IMGO_XSIZE),
+		readl_relaxed(sv_dev->base_inner + REG_CAMSV_IMGO_YSIZE),
+		readl_relaxed(sv_dev->base_inner + REG_CAMSV_IMGO_STRIDE),
+		readl_relaxed(sv_dev->base_inner + REG_CAMSV_IMGO_BASE_ADDR_MSB),
+		readl_relaxed(sv_dev->base_inner + REG_CAMSV_IMGO_BASE_ADDR),
+		readl_relaxed(sv_dev->base_inner + REG_CAMSV_IMGO_OFST_ADDR_MSB),
+		readl_relaxed(sv_dev->base_inner + REG_CAMSV_IMGO_OFST_ADDR));
+
+	return 0;
+}
+#endif
+
+static const struct v4l2_mbus_framefmt sv_mfmt_default = {
+	.code = MEDIA_BUS_FMT_SBGGR10_1X10,
+	.width = DEFAULT_WIDTH,
+	.height = DEFAULT_HEIGHT,
+	.field = V4L2_FIELD_NONE,
+	.colorspace = V4L2_COLORSPACE_SRGB,
+	.xfer_func = V4L2_XFER_FUNC_DEFAULT,
+	.ycbcr_enc = V4L2_YCBCR_ENC_DEFAULT,
+	.quantization = V4L2_QUANTIZATION_DEFAULT,
+};
+
+static int mtk_camsv_sd_subscribe_event(struct v4l2_subdev *subdev,
+				      struct v4l2_fh *fh,
+				      struct v4l2_event_subscription *sub)
+{
+	switch (sub->type) {
+	case V4L2_EVENT_FRAME_SYNC:
+		return v4l2_event_subscribe(fh, sub, 0, NULL);
+	case V4L2_EVENT_REQUEST_DRAINED:
+		return v4l2_event_subscribe(fh, sub, 0, NULL);
+	case V4L2_EVENT_EOS:
+		return v4l2_event_subscribe(fh, sub, 0, NULL);
+	default:
+		return -EINVAL;
+	}
+}
+
+int mtk_cam_sv_select(struct mtk_camsv_pipeline *pipe,
+			struct mtkcam_ipi_input_param *cfg_in_param)
+{
+	pipe->enabled_sv = 1 << (pipe->id - MTKCAM_SUBDEV_CAMSV_START);
+
+	return 0;
+}
+
+static int mtk_camsv_sd_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	struct mtk_camsv_pipeline *pipe =
+		container_of(sd, struct mtk_camsv_pipeline, subdev);
+	struct mtk_camsv *sv = pipe->sv;
+	struct mtk_cam_device *cam = dev_get_drvdata(sv->cam_dev);
+	struct mtk_cam_ctx *ctx = mtk_cam_find_ctx(cam, &sd->entity);
+	unsigned int i;
+
+	if (WARN_ON(!ctx))
+		return -EINVAL;
+
+	if (enable) {
+		pipe->enabled_dmas = 0;
+		if (ctx->used_sv_num < MAX_SV_PIPES_PER_STREAM)
+			ctx->sv_pipe[ctx->used_sv_num++] = pipe;
+		else
+			dev_dbg(sv->cam_dev, "un-expected used sv number:%d\n", ctx->used_sv_num);
+
+		for (i = 0; i < ARRAY_SIZE(pipe->vdev_nodes); i++) {
+			if (!pipe->vdev_nodes[i].enabled)
+				continue;
+			pipe->enabled_dmas |= pipe->vdev_nodes[i].desc.dma_port;
+		}
+	} else {
+		pipe->enabled_sv = 0;
+		pipe->enabled_dmas = 0;
+	}
+
+	dev_info(sv->cam_dev, "%s:camsv-%d: en %d, dev 0x%x dmas 0x%x\n",
+		 __func__, pipe->id-MTKCAM_SUBDEV_CAMSV_START, enable, pipe->enabled_sv,
+		 pipe->enabled_dmas);
+
+	return 0;
+}
+
+static int mtk_camsv_init_cfg(struct v4l2_subdev *sd,
+		struct v4l2_subdev_state *sd_state)
+{
+	struct v4l2_mbus_framefmt *mf;
+	unsigned int i;
+	struct mtk_camsv_pipeline *pipe =
+		container_of(sd, struct mtk_camsv_pipeline, subdev);
+	struct mtk_camsv *sv = pipe->sv;
+
+	for (i = 0; i < sd->entity.num_pads; i++) {
+		mf = v4l2_subdev_get_try_format(sd, sd_state, i);
+		*mf = sv_mfmt_default;
+		pipe->cfg[i].mbus_fmt = sv_mfmt_default;
+
+		dev_dbg(sv->cam_dev, "%s init pad:%d format:0x%x\n",
+			sd->name, i, mf->code);
+	}
+
+	return 0;
+}
+
+static int mtk_camsv_try_fmt(struct v4l2_subdev *sd,
+			  struct v4l2_subdev_format *fmt)
+{
+	struct mtk_camsv_pipeline *pipe =
+		container_of(sd, struct mtk_camsv_pipeline, subdev);
+	struct mtk_camsv *sv = pipe->sv;
+	unsigned int sensor_fmt = mtk_cam_get_sensor_fmt(fmt->format.code);
+
+	dev_dbg(sv->cam_dev, "%s try format 0x%x, w:%d, h:%d field:%d\n",
+		sd->name, fmt->format.code, fmt->format.width,
+		fmt->format.height, fmt->format.field);
+
+	/* check sensor format */
+	if (!sensor_fmt || fmt->pad == MTK_CAMSV_SINK)
+		return sensor_fmt;
+	else if (fmt->pad < MTK_CAMSV_PIPELINE_PADS_NUM) {
+		/* check vdev node format */
+		unsigned int img_fmt, i;
+		struct mtk_cam_video_device *node =
+			&pipe->vdev_nodes[fmt->pad - MTK_CAMSV_SINK_NUM];
+
+		dev_dbg(sv->cam_dev, "node:%s num_fmts:%d",
+				node->desc.name, node->desc.num_fmts);
+		for (i = 0; i < node->desc.num_fmts; i++) {
+			img_fmt = mtk_cam_get_img_fmt(
+				node->desc.fmts[i].vfmt.fmt.pix_mp.pixelformat);
+			dev_dbg(sv->cam_dev,
+				"try format sensor_fmt 0x%x img_fmt 0x%x",
+				sensor_fmt, img_fmt);
+			if (sensor_fmt == img_fmt)
+				return img_fmt;
+		}
+	}
+
+	return MTKCAM_IPI_IMG_FMT_UNKNOWN;
+}
+
+static struct v4l2_mbus_framefmt *get_sv_fmt(struct mtk_camsv_pipeline *pipe,
+					  struct v4l2_subdev_state *sd_state,
+					  unsigned int padid, int which)
+{
+	/* format invalid and return default format */
+	if (which == V4L2_SUBDEV_FORMAT_TRY)
+		return v4l2_subdev_get_try_format(&pipe->subdev, sd_state, padid);
+
+	if (WARN_ON(padid >= pipe->subdev.entity.num_pads))
+		return &pipe->cfg[0].mbus_fmt;
+
+	return &pipe->cfg[padid].mbus_fmt;
+}
+
+static int mtk_camsv_call_set_fmt(struct v4l2_subdev *sd,
+			  struct v4l2_subdev_state *sd_state,
+			  struct v4l2_subdev_format *fmt)
+{
+	struct mtk_camsv_pipeline *pipe =
+		container_of(sd, struct mtk_camsv_pipeline, subdev);
+	struct mtk_camsv *sv = pipe->sv;
+	struct v4l2_mbus_framefmt *mf;
+
+	if (!sd || !fmt) {
+		dev_dbg(sv->cam_dev, "%s: Required sd(%p), fmt(%p)\n",
+			__func__, sd, fmt);
+		return -EINVAL;
+	}
+
+	if (fmt->which == V4L2_SUBDEV_FORMAT_TRY && !sd_state) {
+		dev_dbg(sv->cam_dev, "%s: Required sd(%p), cfg(%p) for FORMAT_TRY\n",
+					__func__, sd, sd_state);
+		return -EINVAL;
+	}
+
+	if (!mtk_camsv_try_fmt(sd, fmt)) {
+		mf = get_sv_fmt(pipe, sd_state, fmt->pad, fmt->which);
+		fmt->format = *mf;
+	} else {
+		mf = get_sv_fmt(pipe, sd_state, fmt->pad, fmt->which);
+		*mf = fmt->format;
+		dev_dbg(sv->cam_dev,
+			"sd:%s pad:%d set format w/h/code %d/%d/0x%x\n",
+			sd->name, fmt->pad, mf->width, mf->height, mf->code);
+	}
+
+	return 0;
+}
+
+int mtk_camsv_call_pending_set_fmt(struct v4l2_subdev *sd,
+				 struct v4l2_subdev_format *fmt)
+{
+	struct mtk_camsv_pipeline *pipe =
+		container_of(sd, struct mtk_camsv_pipeline, subdev);
+	struct mtk_cam_device *cam = dev_get_drvdata(pipe->sv->cam_dev);
+
+	/* We only allow V4L2_SUBDEV_FORMAT_ACTIVE for pending set fmt */
+	if (fmt->which != V4L2_SUBDEV_FORMAT_ACTIVE) {
+		dev_info(cam->dev,
+			"%s:pipe(%d):pad(%d): only allow V4L2_SUBDEV_FORMAT_ACTIVE\n",
+			__func__, pipe->id, fmt->pad);
+		return -EINVAL;
+	}
+
+	return mtk_camsv_call_set_fmt(sd, NULL, fmt);
+}
+
+static int mtk_camsv_set_fmt(struct v4l2_subdev *sd,
+			  struct v4l2_subdev_state *sd_state,
+			  struct v4l2_subdev_format *fmt)
+{
+	struct media_request *req;
+	struct mtk_cam_request *cam_req;
+	struct mtk_cam_request_stream_data *stream_data;
+	int request_fd;
+
+	struct mtk_camsv_pipeline *pipe =
+		container_of(sd, struct mtk_camsv_pipeline, subdev);
+	struct mtk_cam_device *cam = dev_get_drvdata(pipe->sv->cam_dev);
+
+	if (fmt->which == V4L2_SUBDEV_FORMAT_TRY)
+		return mtk_camsv_call_set_fmt(sd, sd_state, fmt);
+
+	/* if the pipeline is streaming, pending the change */
+	if (!media_entity_is_streaming(&sd->entity))
+		return mtk_camsv_call_set_fmt(sd, sd_state, fmt);
+
+	request_fd = v4l2_subdev_format_request_fd(fmt);
+	if (request_fd <= 0)
+		return -EINVAL;
+
+	req = media_request_get_by_fd(&cam->media_dev, request_fd);
+	if (req) {
+		cam_req = to_mtk_cam_req(req);
+		dev_info(cam->dev, "sd:%s pad:%d pending success, req fd(%d)\n",
+			sd->name, fmt->pad, request_fd);
+	} else {
+		dev_info(cam->dev, "sd:%s pad:%d pending failed, req fd(%d) invalid\n",
+			sd->name, fmt->pad, request_fd);
+		return -EINVAL;
+	}
+
+	stream_data = mtk_cam_req_get_s_data_no_chk(cam_req, pipe->id, 0);
+	stream_data->pad_fmt_update |= (1 << fmt->pad);
+	stream_data->pad_fmt[fmt->pad] = *fmt;
+
+	media_request_put(req);
+
+	return 0;
+}
+
+static int mtk_camsv_get_fmt(struct v4l2_subdev *sd,
+			  struct v4l2_subdev_state *sd_state,
+			  struct v4l2_subdev_format *fmt)
+{
+	struct mtk_camsv_pipeline *pipe =
+		container_of(sd, struct mtk_camsv_pipeline, subdev);
+	struct mtk_camsv *sv = pipe->sv;
+	struct v4l2_mbus_framefmt *mf;
+
+	if (fmt->which == V4L2_SUBDEV_FORMAT_TRY)
+		mf = v4l2_subdev_get_try_format(sd, sd_state, fmt->pad);
+	else {
+		if (WARN_ON(fmt->pad >= sd->entity.num_pads))
+			mf = &pipe->cfg[0].mbus_fmt;
+		else
+			mf = &pipe->cfg[fmt->pad].mbus_fmt;
+	}
+
+	fmt->format = *mf;
+	dev_dbg(sv->cam_dev, "sd:%s pad:%d get format 0x%x\n",
+		sd->name, fmt->pad, fmt->format.code);
+
+	return 0;
+}
+
+static int mtk_camsv_media_link_setup(struct media_entity *entity,
+				    const struct media_pad *local,
+				    const struct media_pad *remote, u32 flags)
+{
+	struct mtk_camsv_pipeline *pipe =
+		container_of(entity, struct mtk_camsv_pipeline, subdev.entity);
+	struct mtk_camsv *sv = pipe->sv;
+	u32 pad = local->index;
+
+	dev_info(sv->cam_dev, "%s: camsv %d: %d->%d flags:0x%x\n",
+		__func__, pipe->id, remote->index, local->index, flags);
+
+	if (pad == MTK_CAMSV_SINK)
+		pipe->seninf_padidx = remote->index;
+
+	if (pad < MTK_CAMSV_PIPELINE_PADS_NUM && pad != MTK_CAMSV_SINK)
+		pipe->vdev_nodes[pad-MTK_CAMSV_SINK_NUM].enabled =
+			!!(flags & MEDIA_LNK_FL_ENABLED);
+
+	if (!(flags & MEDIA_LNK_FL_ENABLED))
+		memset(pipe->cfg, 0, sizeof(pipe->cfg));
+
+	return 0;
+}
+
+static const struct v4l2_subdev_core_ops mtk_camsv_subdev_core_ops = {
+	.subscribe_event = mtk_camsv_sd_subscribe_event,
+	.unsubscribe_event = v4l2_event_subdev_unsubscribe,
+};
+
+static const struct v4l2_subdev_video_ops mtk_camsv_subdev_video_ops = {
+	.s_stream =  mtk_camsv_sd_s_stream,
+};
+
+static const struct v4l2_subdev_pad_ops mtk_camsv_subdev_pad_ops = {
+#ifdef ISP7_1
+	.link_validate = mtk_cam_link_validate,
+#else
+	.link_validate = v4l2_subdev_link_validate_default,
+#endif
+	.init_cfg = mtk_camsv_init_cfg,
+	.set_fmt = mtk_camsv_set_fmt,
+	.get_fmt = mtk_camsv_get_fmt,
+};
+
+static const struct v4l2_subdev_ops mtk_camsv_subdev_ops = {
+	.core = &mtk_camsv_subdev_core_ops,
+	.video = &mtk_camsv_subdev_video_ops,
+	.pad = &mtk_camsv_subdev_pad_ops,
+};
+
+static const struct media_entity_operations mtk_camsv_media_entity_ops = {
+	.link_setup = mtk_camsv_media_link_setup,
+	.link_validate = v4l2_subdev_link_validate,
+};
+
+static const struct v4l2_ioctl_ops mtk_camsv_v4l2_vcap_ioctl_ops = {
+	.vidioc_querycap = mtk_cam_vidioc_querycap,
+	.vidioc_enum_framesizes = mtk_cam_vidioc_enum_framesizes,
+	.vidioc_enum_fmt_vid_cap = mtk_cam_vidioc_enum_fmt,
+	.vidioc_g_fmt_vid_cap_mplane = mtk_cam_vidioc_g_fmt,
+	.vidioc_s_fmt_vid_cap_mplane = mtk_cam_vidioc_s_fmt,
+	.vidioc_try_fmt_vid_cap_mplane = mtk_cam_vidioc_try_fmt,
+	.vidioc_reqbufs = vb2_ioctl_reqbufs,
+	.vidioc_create_bufs = vb2_ioctl_create_bufs,
+	.vidioc_prepare_buf = vb2_ioctl_prepare_buf,
+	.vidioc_querybuf = vb2_ioctl_querybuf,
+	.vidioc_qbuf = vb2_ioctl_qbuf,
+	.vidioc_dqbuf = vb2_ioctl_dqbuf,
+	.vidioc_streamon = vb2_ioctl_streamon,
+	.vidioc_streamoff = vb2_ioctl_streamoff,
+	.vidioc_expbuf = vb2_ioctl_expbuf,
+	.vidioc_subscribe_event = v4l2_ctrl_subscribe_event,
+	.vidioc_unsubscribe_event = v4l2_event_unsubscribe,
+};
+
+static const struct mtk_cam_format_desc sv_stream_out_fmts[] = {
+	/* This is a default image format */
+	{
+		.vfmt.fmt.pix_mp = {
+			.width = SV_IMG_MAX_WIDTH,
+			.height = SV_IMG_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_MTISP_SBGGR10,
+		},
+	},
+	{
+		.vfmt.fmt.pix_mp = {
+			.width = SV_IMG_MAX_WIDTH,
+			.height = SV_IMG_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_SBGGR8,
+		},
+	},
+	{
+		.vfmt.fmt.pix_mp = {
+			.width = SV_IMG_MAX_WIDTH,
+			.height = SV_IMG_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_MTISP_SBGGR12,
+		},
+	},
+	{
+		.vfmt.fmt.pix_mp = {
+			.width = SV_IMG_MAX_WIDTH,
+			.height = SV_IMG_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_MTISP_SBGGR14,
+		},
+	},
+	{
+		.vfmt.fmt.pix_mp = {
+			.width = SV_IMG_MAX_WIDTH,
+			.height = SV_IMG_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_SGBRG8,
+		},
+	},
+	{
+		.vfmt.fmt.pix_mp = {
+			.width = SV_IMG_MAX_WIDTH,
+			.height = SV_IMG_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_MTISP_SGBRG10,
+		},
+	},
+	{
+		.vfmt.fmt.pix_mp = {
+			.width = SV_IMG_MAX_WIDTH,
+			.height = SV_IMG_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_MTISP_SGBRG12,
+		},
+	},
+	{
+		.vfmt.fmt.pix_mp = {
+			.width = SV_IMG_MAX_WIDTH,
+			.height = SV_IMG_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_MTISP_SGBRG14,
+		},
+	},
+	{
+		.vfmt.fmt.pix_mp = {
+			.width = SV_IMG_MAX_WIDTH,
+			.height = SV_IMG_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_SGRBG8,
+		},
+	},
+	{
+		.vfmt.fmt.pix_mp = {
+			.width = SV_IMG_MAX_WIDTH,
+			.height = SV_IMG_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_MTISP_SGRBG10,
+		},
+	},
+	{
+		.vfmt.fmt.pix_mp = {
+			.width = SV_IMG_MAX_WIDTH,
+			.height = SV_IMG_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_MTISP_SGRBG12,
+		},
+	},
+	{
+		.vfmt.fmt.pix_mp = {
+			.width = SV_IMG_MAX_WIDTH,
+			.height = SV_IMG_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_MTISP_SGRBG14,
+		},
+	},
+	{
+		.vfmt.fmt.pix_mp = {
+			.width = SV_IMG_MAX_WIDTH,
+			.height = SV_IMG_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_SRGGB8,
+		},
+	},
+	{
+		.vfmt.fmt.pix_mp = {
+			.width = SV_IMG_MAX_WIDTH,
+			.height = SV_IMG_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_MTISP_SRGGB10,
+		},
+	},
+	{
+		.vfmt.fmt.pix_mp = {
+			.width = SV_IMG_MAX_WIDTH,
+			.height = SV_IMG_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_MTISP_SRGGB12,
+		},
+	},
+	{
+		.vfmt.fmt.pix_mp = {
+			.width = SV_IMG_MAX_WIDTH,
+			.height = SV_IMG_MAX_HEIGHT,
+			.pixelformat = V4L2_PIX_FMT_MTISP_SRGGB14,
+		},
+	},
+};
+
+#define MTK_CAMSV_TOTAL_CAPTURE_QUEUES 1
+
+static const struct
+mtk_cam_dev_node_desc sv_capture_queues[] = {
+	{
+		.id = MTK_CAMSV_MAIN_STREAM_OUT,
+		.name = "main stream",
+		.cap = V4L2_CAP_VIDEO_CAPTURE_MPLANE,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE,
+		.link_flags = MEDIA_LNK_FL_ENABLED |  MEDIA_LNK_FL_IMMUTABLE,
+		.image = true,
+		.smem_alloc = false,
+		.dma_port = MTKCAM_IPI_CAMSV_MAIN_OUT,
+		.fmts = sv_stream_out_fmts,
+		.num_fmts = ARRAY_SIZE(sv_stream_out_fmts),
+		.default_fmt_idx = 0,
+		.ioctl_ops = &mtk_camsv_v4l2_vcap_ioctl_ops,
+		.frmsizes = &(struct v4l2_frmsizeenum) {
+			.index = 0,
+			.type = V4L2_FRMSIZE_TYPE_CONTINUOUS,
+			.stepwise = {
+				.max_width = SV_IMG_MAX_WIDTH,
+				.min_width = SV_IMG_MIN_WIDTH,
+				.max_height = SV_IMG_MAX_HEIGHT,
+				.min_height = SV_IMG_MIN_HEIGHT,
+				.step_height = 1,
+				.step_width = 1,
+			},
+		},
+	},
+};
+
+static const char *sv_capture_queue_names[CAMSV_PIPELINE_NUM][MTK_CAMSV_TOTAL_CAPTURE_QUEUES] = {
+	{"mtk-cam camsv-0 main-stream"},
+	{"mtk-cam camsv-1 main-stream"},
+	{"mtk-cam camsv-2 main-stream"},
+	{"mtk-cam camsv-3 main-stream"},
+	{"mtk-cam camsv-4 main-stream"},
+	{"mtk-cam camsv-5 main-stream"},
+#ifdef ISP7_1
+	{"mtk-cam camsv-6 main-stream"},
+	{"mtk-cam camsv-7 main-stream"},
+#endif
+};
+
+static int reset_msgfifo(struct mtk_camsv_device *dev)
+{
+	atomic_set(&dev->is_fifo_overflow, 0);
+	return kfifo_init(&dev->msg_fifo, dev->msg_buffer, dev->fifo_size);
+}
+
+static int push_msgfifo(struct mtk_camsv_device *dev,
+			struct mtk_camsys_irq_info *info)
+{
+	int len;
+
+	if (unlikely(kfifo_avail(&dev->msg_fifo) < sizeof(*info))) {
+		atomic_set(&dev->is_fifo_overflow, 1);
+		return -1;
+	}
+
+	len = kfifo_in(&dev->msg_fifo, info, sizeof(*info));
+	WARN_ON(len != sizeof(*info));
+
+	return 0;
+}
+
+void sv_reset(struct mtk_camsv_device *dev)
+{
+#ifdef ISP7_1
+	int sw_ctl;
+	int ret;
+
+	dev_dbg(dev->dev, "%s camsv_id:%d\n", __func__, dev->id);
+
+	writel(0, dev->base + REG_CAMSV_SW_CTL);
+	writel(1, dev->base + REG_CAMSV_SW_CTL);
+	wmb(); /* make sure committed */
+
+	ret = readx_poll_timeout(readl, dev->base + REG_CAMSV_SW_CTL, sw_ctl,
+				 sw_ctl & 0x2,
+				 1 /* delay, us */,
+				 100000 /* timeout, us */);
+	if (ret < 0) {
+		dev_info(dev->dev, "%s: timeout\n", __func__);
+
+		dev_info(dev->dev,
+			 "tg_sen_mode: 0x%x, ctl_en: 0x%x, ctl_sw_ctl:0x%x, frame_no:0x%x\n",
+			 readl(dev->base + REG_CAMSV_TG_SEN_MODE),
+			 readl(dev->base + REG_CAMSV_MODULE_EN),
+			 readl(dev->base + REG_CAMSV_SW_CTL),
+			 readl(dev->base + REG_CAMSV_FRAME_SEQ_NO)
+			);
+
+		//mtk_smi_dbg_hang_detect("camsys-camsv");
+
+		goto RESET_FAILURE;
+	}
+
+	/* hw issue: second channel dma's ck/rst not refer to its own status */
+	/* for above reason, merely do fbc reset rather than do hw reset */
+	/* writel(4, dev->base + REG_CAMSV_SW_CTL); */
+	writel(0x100, dev->base + REG_CAMSV_FBC_IMGO_CTL1);
+
+	writel(0, dev->base + REG_CAMSV_SW_CTL);
+	wmb(); /* make sure committed */
+
+RESET_FAILURE:
+	return;
+#else //mt8195
+	unsigned long end = jiffies + msecs_to_jiffies(100);
+
+	dev_dbg(dev->dev, "%s\n", __func__);
+
+	writel_relaxed(0, dev->base + REG_CAMSV_SW_CTL);
+	writel_relaxed(1, dev->base + REG_CAMSV_SW_CTL);
+	wmb(); /* TBC */
+
+
+	while (time_before(jiffies, end)) {
+		if (readl(dev->base + REG_CAMSV_SW_CTL) & 0x2) {
+			// do hw rst
+			writel_relaxed(4, dev->base + REG_CAMSV_SW_CTL);
+			writel_relaxed(0, dev->base + REG_CAMSV_SW_CTL);
+			wmb(); /* TBC */
+			return;
+		}
+
+		dev_info(dev->dev,
+			"tg_sen_mode: 0x%x, ctl_en: 0x%x, ctl_sw_ctl:0x%x, frame_no:0x%x\n",
+			readl(dev->base + REG_CAMSV_TG_SEN_MODE),
+			readl(dev->base + REG_CAMSV_MODULE_EN),
+			readl(dev->base + REG_CAMSV_SW_CTL),
+			readl(dev->base + REG_CAMSV_FRAME_SEQ_NO)
+			);
+		usleep_range(10, 20);
+	}
+
+	dev_dbg(dev->dev, "reset hw timeout\n");
+#endif //#ifdef ISP7_1
+}
+
+int mtk_cam_sv_pipeline_config(
+	struct mtk_cam_ctx *ctx, unsigned int idx,
+	struct mtkcam_ipi_input_param *cfg_in_param)
+{
+	struct mtk_camsv_pipeline *sv_pipe = ctx->sv_pipe[idx];
+	struct mtk_camsv *sv = sv_pipe->sv;
+	unsigned int i;
+	int ret;
+
+	/* reset pm_runtime during streaming dynamic change */
+	if (ctx->streaming) {
+		for (i = 0; i < ARRAY_SIZE(sv->devs); i++)
+			if (sv_pipe->enabled_sv & 1<<i)
+				pm_runtime_put_sync(sv->devs[i]);
+	}
+
+	ret = mtk_cam_sv_select(sv_pipe, cfg_in_param);
+	if (ret) {
+		dev_dbg(sv->cam_dev, "failed select camsv: %d\n",
+			ctx->stream_id);
+		return ret;
+	}
+
+	for (i = 0; i < ARRAY_SIZE(sv->devs); i++)
+		if (sv_pipe->enabled_sv & 1<<i)
+			pm_runtime_get_sync(sv->devs[i]);
+
+	if (ret < 0) {
+		dev_dbg(sv->cam_dev,
+			"failed at pm_runtime_get_sync: %s\n",
+			dev_driver_string(sv->devs[i]));
+		for (i = i-1; i >= 0; i--)
+			if (sv_pipe->enabled_sv & 1<<i)
+				pm_runtime_put_sync(sv->devs[i]);
+		return ret;
+	}
+
+	ctx->used_sv_dev[idx] = sv_pipe->enabled_sv;
+	dev_info(sv->cam_dev, "ctx_id %d used_sv_dev %d pipe_id %d\n",
+		ctx->stream_id, ctx->used_sv_dev[idx], sv_pipe->id);
+	return 0;
+}
+
+
+struct device *mtk_cam_find_sv_dev(struct mtk_cam_device *cam, unsigned int sv_mask)
+{
+	unsigned int i;
+
+	for (i = 0; i < cam->num_camsv_devices; i++) {
+		if (sv_mask & (1 << i))
+			return cam->sv.devs[i];
+	}
+
+	return NULL;
+}
+
+unsigned int mtk_cam_sv_format_sel(unsigned int pixel_fmt)
+{
+	union CAMSV_FMT_SEL fmt;
+
+	fmt.Raw = 0;
+	fmt.Bits.TG1_SW = TG_SW_UYVY;
+
+	switch (pixel_fmt) {
+	case V4L2_PIX_FMT_SBGGR8:
+	case V4L2_PIX_FMT_SGBRG8:
+	case V4L2_PIX_FMT_SGRBG8:
+	case V4L2_PIX_FMT_SRGGB8:
+		fmt.Bits.TG1_FMT = SV_TG_FMT_RAW8;
+		break;
+	case V4L2_PIX_FMT_MTISP_SBGGR10:
+	case V4L2_PIX_FMT_MTISP_SGBRG10:
+	case V4L2_PIX_FMT_MTISP_SGRBG10:
+	case V4L2_PIX_FMT_MTISP_SRGGB10:
+		fmt.Bits.TG1_FMT = SV_TG_FMT_RAW10;
+		break;
+	case V4L2_PIX_FMT_MTISP_SBGGR12:
+	case V4L2_PIX_FMT_MTISP_SGBRG12:
+	case V4L2_PIX_FMT_MTISP_SGRBG12:
+	case V4L2_PIX_FMT_MTISP_SRGGB12:
+		fmt.Bits.TG1_FMT = SV_TG_FMT_RAW12;
+		break;
+	case V4L2_PIX_FMT_MTISP_SBGGR14:
+	case V4L2_PIX_FMT_MTISP_SGBRG14:
+	case V4L2_PIX_FMT_MTISP_SGRBG14:
+	case V4L2_PIX_FMT_MTISP_SRGGB14:
+		fmt.Bits.TG1_FMT = SV_TG_FMT_RAW14;
+		break;
+	default:
+		break;
+	}
+
+	return fmt.Raw;
+}
+
+unsigned int mtk_cam_sv_pak_sel(unsigned int tg_fmt,
+	unsigned int pixel_mode)
+{
+	union CAMSV_PAK pak;
+
+	pak.Raw = 0;
+
+	switch (tg_fmt) {
+	case SV_TG_FMT_RAW8:
+		pak.Bits.PAK_MODE = 128;
+		break;
+	case SV_TG_FMT_RAW10:
+		pak.Bits.PAK_MODE = 129;
+		break;
+	case SV_TG_FMT_RAW12:
+		pak.Bits.PAK_MODE = 130;
+		break;
+	default:
+		break;
+	}
+
+	pak.Bits.PAK_DBL_MODE = pixel_mode;
+
+	return pak.Raw;
+}
+
+unsigned int mtk_cam_sv_xsize_cal(struct mtkcam_ipi_input_param *cfg_in_param)
+{
+
+	union CAMSV_FMT_SEL fmt;
+	unsigned int size;
+	unsigned int divisor;
+
+	fmt.Raw = cfg_in_param->fmt;
+
+	switch (fmt.Bits.TG1_FMT) {
+	case SV_TG_FMT_RAW8:
+		size = cfg_in_param->in_crop.s.w;
+		break;
+	case SV_TG_FMT_RAW10:
+		size = (cfg_in_param->in_crop.s.w * 10) / 8;
+		break;
+	case SV_TG_FMT_RAW12:
+		size = (cfg_in_param->in_crop.s.w * 12) / 8;
+		break;
+	case SV_TG_FMT_RAW14:
+		size = (cfg_in_param->in_crop.s.w * 14) / 8;
+		break;
+	default:
+		return 0;
+	}
+
+	switch (cfg_in_param->pixel_mode) {
+	case 0:
+		divisor = 0x1;
+		break;
+	case 1:
+		divisor = 0x3;
+		break;
+	case 2:
+		divisor = 0x7;
+		break;
+	case 3:
+		divisor = 0xF;
+		break;
+	default:
+		return 0;
+	}
+	size = ((size + divisor) & ~divisor);
+	return size;
+}
+
+int mtk_cam_sv_tg_config(struct mtk_camsv_device *dev, struct mtkcam_ipi_input_param *cfg_in_param)
+{
+	int ret = 0;
+	unsigned int pxl, lin;
+
+	CAMSV_WRITE_BITS(dev->base + REG_CAMSV_TG_SEN_MODE, CAMSV_TG_SEN_MODE, CMOS_EN, 0);
+
+	/* subsample */
+	if (cfg_in_param->subsample > 0) {
+		CAMSV_WRITE_BITS(dev->base + REG_CAMSV_TG_SEN_MODE,
+			CAMSV_TG_SEN_MODE, SOF_SUB_EN, 1);
+		CAMSV_WRITE_BITS(dev->base + REG_CAMSV_TG_SEN_MODE,
+			CAMSV_TG_SEN_MODE, VS_SUB_EN, 1);
+		CAMSV_WRITE_BITS(dev->base + REG_CAMSV_TG_SUB_PERIOD,
+			CAMSV_TG_SUB_PERIOD, VS_PERIOD, cfg_in_param->subsample);
+		CAMSV_WRITE_BITS(dev->base + REG_CAMSV_TG_SUB_PERIOD,
+			CAMSV_TG_SUB_PERIOD, SOF_PERIOD, cfg_in_param->subsample);
+	} else {
+		CAMSV_WRITE_BITS(dev->base + REG_CAMSV_TG_SEN_MODE,
+			CAMSV_TG_SEN_MODE, SOF_SUB_EN, 0);
+		CAMSV_WRITE_BITS(dev->base + REG_CAMSV_TG_SEN_MODE,
+			CAMSV_TG_SEN_MODE, VS_SUB_EN, 0);
+		CAMSV_WRITE_BITS(dev->base + REG_CAMSV_TG_SUB_PERIOD,
+			CAMSV_TG_SUB_PERIOD, VS_PERIOD, cfg_in_param->subsample);
+		CAMSV_WRITE_BITS(dev->base + REG_CAMSV_TG_SUB_PERIOD,
+			CAMSV_TG_SUB_PERIOD, SOF_PERIOD, cfg_in_param->subsample);
+	}
+
+	if (dev->pipeline->hw_scen &
+		MTK_CAMSV_SUPPORTED_STAGGER_SCENARIO) {
+	#ifdef ISP7_1
+		if (dev->pipeline->exp_order == 0) {
+	#else //MT8195
+		if (dev->id == 0) {
+	#endif
+			CAMSV_WRITE_BITS(dev->base + REG_CAMSV_TG_SEN_MODE,
+				CAMSV_TG_SEN_MODE, STAGGER_EN, 0);
+			CAMSV_WRITE_BITS(dev->base + REG_CAMSV_TG_PATH_CFG,
+				CAMSV_TG_PATH_CFG, SUB_SOF_SRC_SEL, 0);
+	#ifdef ISP7_1
+		} else {
+	#else //MT8195
+		} else if (dev->id == 1) {
+	#endif
+			CAMSV_WRITE_BITS(dev->base + REG_CAMSV_TG_SEN_MODE,
+				CAMSV_TG_SEN_MODE, STAGGER_EN, 1);
+			CAMSV_WRITE_BITS(dev->base + REG_CAMSV_TG_PATH_CFG,
+				CAMSV_TG_PATH_CFG, SUB_SOF_SRC_SEL, 0);
+		}
+	} else {
+		CAMSV_WRITE_BITS(dev->base + REG_CAMSV_TG_SEN_MODE,
+				CAMSV_TG_SEN_MODE, STAGGER_EN, 0);
+		CAMSV_WRITE_BITS(dev->base + REG_CAMSV_TG_PATH_CFG,
+				CAMSV_TG_PATH_CFG, SUB_SOF_SRC_SEL, 0);
+	}
+
+	/* timestamp */
+	CAMSV_WRITE_BITS(dev->base + REG_CAMSV_TG_SEN_MODE,
+		CAMSV_TG_SEN_MODE, TIME_STP_EN, 1);
+
+	/* trig mode */
+	CAMSV_WRITE_BITS(dev->base + REG_CAMSV_TG_VF_CON,
+		CAMSV_TG_VF_CON, SINGLE_MODE, 0);
+
+	/* pixel mode */
+	switch (cfg_in_param->pixel_mode) {
+	case 0:
+		CAMSV_WRITE_BITS(dev->base + REG_CAMSV_TG_SEN_MODE,
+			CAMSV_TG_SEN_MODE, DBL_DATA_BUS, 0);
+		break;
+	case 1:
+		CAMSV_WRITE_BITS(dev->base + REG_CAMSV_TG_SEN_MODE,
+			CAMSV_TG_SEN_MODE, DBL_DATA_BUS, 1);
+		break;
+	case 2:
+		CAMSV_WRITE_BITS(dev->base + REG_CAMSV_TG_SEN_MODE,
+			CAMSV_TG_SEN_MODE, DBL_DATA_BUS, 2);
+		break;
+	case 3:
+		CAMSV_WRITE_BITS(dev->base + REG_CAMSV_TG_SEN_MODE,
+			CAMSV_TG_SEN_MODE, DBL_DATA_BUS, 3);
+		break;
+	default:
+		dev_dbg(dev->dev, "unknown pixel mode(%d)", cfg_in_param->pixel_mode);
+		ret = -1;
+		goto EXIT;
+	}
+
+	/* grab size */
+	pxl = ((cfg_in_param->in_crop.s.w+cfg_in_param->in_crop.p.x)<<16)|
+			cfg_in_param->in_crop.p.x;
+	lin = ((cfg_in_param->in_crop.s.h+cfg_in_param->in_crop.p.y)<<16)|
+			cfg_in_param->in_crop.p.y;
+	CAMSV_WRITE_REG(dev->base + REG_CAMSV_TG_SEN_GRAB_PXL, pxl);
+	CAMSV_WRITE_REG(dev->base + REG_CAMSV_TG_SEN_GRAB_LIN, lin);
+
+	dev_info(dev->dev, "pixel mode:%d\n", cfg_in_param->pixel_mode);
+	dev_info(dev->dev, "sub-sample:%d\n", cfg_in_param->subsample);
+	dev_info(dev->dev, "fmt:%d\n", cfg_in_param->fmt);
+	dev_info(dev->dev, "crop_x:%d\n", cfg_in_param->in_crop.p.x);
+	dev_info(dev->dev, "crop_y:%d\n", cfg_in_param->in_crop.p.y);
+	dev_info(dev->dev, "crop_w:%d\n", cfg_in_param->in_crop.s.w);
+	dev_info(dev->dev, "crop_h:%d\n", cfg_in_param->in_crop.s.h);
+
+EXIT:
+	return ret;
+}
+
+int mtk_cam_sv_top_config(
+	struct mtk_camsv_device *dev,
+	struct mtkcam_ipi_input_param *cfg_in_param)
+{
+#ifdef ISP7_1
+	unsigned int int_en = (SV_INT_EN_TG_ERR_INT_EN |
+							SV_INT_EN_TG_GBERR_INT_EN |
+							SV_INT_EN_TG_SOF_INT_EN |
+							SV_INT_EN_SW_PASS1_DON_INT_EN |
+							SV_INT_EN_DMA_ERR_INT_EN);
+	union CAMSV_PAK pak;
+#else //MT8195
+	unsigned int int_en = (SV_INT_EN_VS1_INT_EN |
+							SV_INT_EN_TG_ERR_INT_EN |
+							SV_INT_EN_TG_GBERR_INT_EN |
+							SV_INT_EN_TG_SOF_INT_EN |
+							SV_INT_EN_PASS1_DON_INT_EN |
+							SV_INT_EN_SW_PASS1_DON_INT_EN |
+							SV_INT_EN_DMA_ERR_INT_EN |
+							SV_INT_EN_IMGO_OVERR_INT_EN);
+#endif
+	union CAMSV_FMT_SEL fmt;
+	int ret = 0;
+
+	/* reset */
+	sv_reset(dev);
+
+	/* fun en */
+	CAMSV_WRITE_BITS(dev->base + REG_CAMSV_MODULE_EN,
+		CAMSV_MODULE_EN, TG_EN, 1);
+	CAMSV_WRITE_BITS(dev->base + REG_CAMSV_MODULE_EN,
+		CAMSV_MODULE_EN, DB_EN, 0);
+#ifdef ISP7_1
+	CAMSV_WRITE_BITS(dev->base + REG_CAMSV_MODULE_EN,
+		CAMSV_MODULE_EN, DB_LOAD_SRC, SV_DB_SRC_SUB_SOF);
+#else //MT8195
+	CAMSV_WRITE_BITS(dev->base + REG_CAMSV_MODULE_EN,
+		CAMSV_MODULE_EN, DB_LOAD_SRC, SV_DB_SRC_SOF);
+	if ((dev->pipeline->hw_scen &
+		(1 << MTKCAM_IPI_HW_PATH_ON_THE_FLY_DCIF_STAGGER)) ||
+		(dev->pipeline->hw_scen &
+		(1 << MTKCAM_IPI_HW_PATH_OFFLINE_SRT_DCIF_STAGGER))) {
+		CAMSV_WRITE_BITS(dev->base + REG_CAMSV_MODULE_EN,
+			CAMSV_MODULE_EN, DB_LOAD_SRC, SV_DB_SRC_SUB_SOF);
+	} else {
+		CAMSV_WRITE_BITS(dev->base + REG_CAMSV_MODULE_EN,
+			CAMSV_MODULE_EN, DB_LOAD_SRC, SV_DB_SRC_SUB_SOF);
+	}
+#endif
+
+	/* central sub en */
+	if (cfg_in_param->subsample > 0)
+		CAMSV_WRITE_BITS(dev->base + REG_CAMSV_SUB_CTRL,
+			CAMSV_SUB_CTRL, CENTRAL_SUB_EN, 1);
+	else
+		CAMSV_WRITE_BITS(dev->base + REG_CAMSV_SUB_CTRL,
+			CAMSV_SUB_CTRL, CENTRAL_SUB_EN, 0);
+
+	/* disable db load mask for non-dcif case */
+	CAMSV_WRITE_BITS(dev->base + REG_CAMSV_DCIF_SET,
+		CAMSV_DCIF_SET, MASK_DB_LOAD, 0);
+
+	if ((dev->pipeline->hw_scen &
+		(1 << MTKCAM_IPI_HW_PATH_ON_THE_FLY_DCIF_STAGGER)) ||
+		(dev->pipeline->hw_scen &
+		(1 << MTKCAM_IPI_HW_PATH_OFFLINE_SRT_DCIF_STAGGER))) {
+		CAMSV_WRITE_BITS(dev->base + REG_CAMSV_DCIF_SET,
+			CAMSV_DCIF_SET, FOR_DCIF_SUBSAMPLE_EN, 1);
+		CAMSV_WRITE_BITS(dev->base + REG_CAMSV_DCIF_SET,
+			CAMSV_DCIF_SET, ENABLE_OUTPUT_CQ_START_SIGNAL, 1);
+	} else {
+		CAMSV_WRITE_BITS(dev->base + REG_CAMSV_DCIF_SET,
+			CAMSV_DCIF_SET, FOR_DCIF_SUBSAMPLE_EN, 0);
+		CAMSV_WRITE_BITS(dev->base + REG_CAMSV_DCIF_SET,
+			CAMSV_DCIF_SET, ENABLE_OUTPUT_CQ_START_SIGNAL, 0);
+	}
+
+	/* fmt sel */
+	CAMSV_WRITE_REG(dev->base + REG_CAMSV_FMT_SEL, cfg_in_param->fmt);
+
+	/* int en */
+	CAMSV_WRITE_REG(dev->base + REG_CAMSV_INT_EN, int_en);
+
+	/* sub p1 done */
+	if (cfg_in_param->subsample > 0) {
+		CAMSV_WRITE_BITS(dev->base + REG_CAMSV_MODULE_EN,
+			CAMSV_MODULE_EN, DOWN_SAMPLE_EN, 1);
+		CAMSV_WRITE_BITS(dev->base + REG_CAMSV_MODULE_EN,
+			CAMSV_MODULE_EN, DOWN_SAMPLE_PERIOD, cfg_in_param->subsample);
+	} else {
+		CAMSV_WRITE_BITS(dev->base + REG_CAMSV_MODULE_EN,
+			CAMSV_MODULE_EN, DOWN_SAMPLE_EN, 0);
+		CAMSV_WRITE_BITS(dev->base + REG_CAMSV_MODULE_EN,
+			CAMSV_MODULE_EN, DOWN_SAMPLE_PERIOD, cfg_in_param->subsample);
+	}
+
+	/* pak */
+	fmt.Raw = cfg_in_param->fmt;
+
+#ifdef ISP7_1
+	pak.Raw = mtk_cam_sv_pak_sel(fmt.Bits.TG1_FMT, cfg_in_param->pixel_mode);
+	CAMSV_WRITE_BITS(dev->base + REG_CAMSV_MODULE_EN,
+		CAMSV_MODULE_EN, PAK_EN, 1);
+	CAMSV_WRITE_BITS(dev->base + REG_CAMSV_MODULE_EN,
+		CAMSV_MODULE_EN, PAK_SEL, 0);
+	CAMSV_WRITE_BITS(dev->base + REG_CAMSV_PAK_CON,
+		CAMSV_PAK_CON, PAK_IN_BIT, 14);
+	CAMSV_WRITE_REG(dev->base + REG_CAMSV_PAK, pak.Raw);
+#else //MT8195
+	switch (fmt.Bits.TG1_FMT) {
+	case SV_TG_FMT_RAW8:
+		CAMSV_WRITE_BITS(dev->base + REG_CAMSV_MODULE_EN,
+			CAMSV_MODULE_EN, PAK_EN, 1);
+		CAMSV_WRITE_BITS(dev->base + REG_CAMSV_MODULE_EN,
+			CAMSV_MODULE_EN, PAK_SEL, 0);
+		CAMSV_WRITE_BITS(dev->base + REG_CAMSV_PAK,
+			CAMSV_PAK, PAK_MODE, 128);
+		CAMSV_WRITE_BITS(dev->base + REG_CAMSV_PAK_CON,
+			CAMSV_PAK_CON, PAK_IN_BIT, 14);
+		break;
+	case SV_TG_FMT_RAW10:
+		CAMSV_WRITE_BITS(dev->base + REG_CAMSV_MODULE_EN,
+			CAMSV_MODULE_EN, PAK_EN, 1);
+		CAMSV_WRITE_BITS(dev->base + REG_CAMSV_MODULE_EN,
+			CAMSV_MODULE_EN, PAK_SEL, 0);
+		CAMSV_WRITE_BITS(dev->base + REG_CAMSV_PAK,
+			CAMSV_PAK, PAK_MODE, 129);
+		CAMSV_WRITE_BITS(dev->base + REG_CAMSV_PAK_CON,
+			CAMSV_PAK_CON, PAK_IN_BIT, 14);
+		break;
+	case SV_TG_FMT_RAW12:
+		CAMSV_WRITE_BITS(dev->base + REG_CAMSV_MODULE_EN,
+			CAMSV_MODULE_EN, PAK_EN, 1);
+		CAMSV_WRITE_BITS(dev->base + REG_CAMSV_MODULE_EN,
+			CAMSV_MODULE_EN, PAK_SEL, 0);
+		CAMSV_WRITE_BITS(dev->base + REG_CAMSV_PAK,
+			CAMSV_PAK, PAK_MODE, 130);
+		CAMSV_WRITE_BITS(dev->base + REG_CAMSV_PAK_CON,
+			CAMSV_PAK_CON, PAK_IN_BIT, 14);
+		break;
+	default:
+		dev_dbg(dev->dev, "unknown tg format(%d)", fmt.Bits.TG1_FMT);
+		ret = -1;
+		goto EXIT;
+	}
+#endif //#ifdef ISP7_1
+
+	/* ufe disable */
+	CAMSV_WRITE_BITS(dev->base + REG_CAMSV_MODULE_EN,
+		CAMSV_MODULE_EN, UFE_EN, 0);
+
+#ifndef ISP7_1 //MT8195
+	/* pixel mode */
+	switch (cfg_in_param->pixel_mode) {
+	case 0:
+		CAMSV_WRITE_BITS(dev->base + REG_CAMSV_PAK,
+			CAMSV_PAK, PAK_DBL_MODE, 0);
+		break;
+	case 1:
+		CAMSV_WRITE_BITS(dev->base + REG_CAMSV_PAK,
+			CAMSV_PAK, PAK_DBL_MODE, 1);
+		break;
+	case 2:
+		CAMSV_WRITE_BITS(dev->base + REG_CAMSV_PAK,
+			CAMSV_PAK, PAK_DBL_MODE, 2);
+		break;
+	case 3:
+		CAMSV_WRITE_BITS(dev->base + REG_CAMSV_PAK,
+			CAMSV_PAK, PAK_DBL_MODE, 3);
+		break;
+	default:
+		dev_dbg(dev->dev, "unknown pixel mode(%d)", cfg_in_param->pixel_mode);
+		ret = -1;
+		goto EXIT;
+	}
+#endif //#ifdef ISP7_1
+
+	/* dma performance */
+	CAMSV_WRITE_REG(dev->base + REG_CAMSV_SPECIAL_FUN_EN, 0x4000000);
+
+#ifndef ISP7_1
+EXIT:
+#endif
+	return ret;
+}
+
+int mtk_cam_sv_dmao_config(
+	struct mtk_camsv_device *top_dev,
+	struct mtk_camsv_device *sub_dev,
+	struct mtkcam_ipi_input_param *cfg_in_param,
+	int hw_scen,
+	int raw_imgo_stride)
+{
+	int ret = 0;
+#ifdef ISP7_1
+	union CAMSV_FMT_SEL fmt;
+#else //MT8195
+	unsigned int stride;
+#endif
+
+	/* imgo dma setting */
+	CAMSV_WRITE_REG(sub_dev->base + REG_CAMSV_IMGO_XSIZE,
+		mtk_cam_sv_xsize_cal(cfg_in_param) - 1);
+	CAMSV_WRITE_REG(sub_dev->base + REG_CAMSV_IMGO_YSIZE,
+		cfg_in_param->in_crop.s.h - 1);
+	CAMSV_WRITE_REG(sub_dev->base + REG_CAMSV_IMGO_STRIDE,
+		mtk_cam_sv_xsize_cal(cfg_in_param));
+
+#ifdef ISP7_1
+	/* check raw's imgo stride */
+	if (hw_scen & MTK_CAMSV_SUPPORTED_SPECIAL_HW_SCENARIO) {
+		if (raw_imgo_stride > mtk_cam_sv_xsize_cal(cfg_in_param)) {
+			dev_info(sub_dev->dev, "Special feature:0x%x, raw/sv stride = %d(THIS)/%d\n",
+				hw_scen, raw_imgo_stride, mtk_cam_sv_xsize_cal(cfg_in_param));
+			CAMSV_WRITE_REG(sub_dev->base + REG_CAMSV_IMGO_STRIDE,
+				raw_imgo_stride);
+		}
+	}
+#endif
+
+	dev_info(sub_dev->dev, "xsize:%d ysize:%d stride:%d\n",
+		CAMSV_READ_REG(sub_dev->base + REG_CAMSV_IMGO_XSIZE),
+		CAMSV_READ_REG(sub_dev->base + REG_CAMSV_IMGO_YSIZE),
+		CAMSV_READ_REG(sub_dev->base + REG_CAMSV_IMGO_STRIDE));
+	/* imgo crop */
+	CAMSV_WRITE_REG(sub_dev->base + REG_CAMSV_IMGO_CROP, 0);
+
+#ifdef ISP7_1
+	/* imgo stride */
+	fmt.Raw = cfg_in_param->fmt;
+	dev_info(sub_dev->dev, "fmt.Raw: 0x%x, pixel_mode: %d\n", fmt.Raw, cfg_in_param->pixel_mode);
+	if (fmt.Bits.TG1_FMT == SV_TG_FMT_YUV422) {
+		switch (cfg_in_param->pixel_mode) {
+		case PXL_MOD_1:
+			CAMSV_WRITE_BITS(sub_dev->base + REG_CAMSV_IMGO_BASIC,
+			CAMSV_IMGO_BASIC, BUS_SIZE_EN, 1);
+			CAMSV_WRITE_BITS(sub_dev->base + REG_CAMSV_IMGO_BASIC,
+			CAMSV_IMGO_BASIC, BUS_SIZE, 1);
+			break;
+		case PXL_MOD_2:
+			CAMSV_WRITE_BITS(sub_dev->base + REG_CAMSV_IMGO_BASIC,
+			CAMSV_IMGO_BASIC, BUS_SIZE_EN, 1);
+			CAMSV_WRITE_BITS(sub_dev->base + REG_CAMSV_IMGO_BASIC,
+			CAMSV_IMGO_BASIC, BUS_SIZE, 1);
+			break;
+		case PXL_MOD_4:
+			CAMSV_WRITE_BITS(sub_dev->base + REG_CAMSV_IMGO_BASIC,
+			CAMSV_IMGO_BASIC, BUS_SIZE_EN, 1);
+			CAMSV_WRITE_BITS(sub_dev->base + REG_CAMSV_IMGO_BASIC,
+			CAMSV_IMGO_BASIC, BUS_SIZE, 7);
+			break;
+		default:
+			dev_dbg(sub_dev->dev, "unknown pixel mode(%d)", cfg_in_param->pixel_mode);
+			ret = -1;
+			return ret;
+		}
+	}
+
+	/* imgo con */
+	if (sub_dev->id >= 0 && sub_dev->id < 10) {
+		CAMSV_WRITE_REG(sub_dev->base + REG_CAMSV_IMGO_CON0, 0x10000300);
+		CAMSV_WRITE_REG(sub_dev->base + REG_CAMSV_IMGO_CON1, 0x00C00060);
+		CAMSV_WRITE_REG(sub_dev->base + REG_CAMSV_IMGO_CON2, 0x01800120);
+		CAMSV_WRITE_REG(sub_dev->base + REG_CAMSV_IMGO_CON3, 0x020001A0);
+		CAMSV_WRITE_REG(sub_dev->base + REG_CAMSV_IMGO_CON4, 0x012000C0);
+	} else {
+		CAMSV_WRITE_REG(sub_dev->base + REG_CAMSV_IMGO_CON0, 0x10000080);
+		CAMSV_WRITE_REG(sub_dev->base + REG_CAMSV_IMGO_CON1, 0x00200010);
+		CAMSV_WRITE_REG(sub_dev->base + REG_CAMSV_IMGO_CON2, 0x00400030);
+		CAMSV_WRITE_REG(sub_dev->base + REG_CAMSV_IMGO_CON3, 0x00550045);
+		CAMSV_WRITE_REG(sub_dev->base + REG_CAMSV_IMGO_CON4, 0x00300020);
+	}
+
+#else //MT8195
+	/* imgo stride */
+	stride = CAMSV_READ_REG(sub_dev->base + REG_CAMSV_IMGO_STRIDE);
+	switch (cfg_in_param->pixel_mode) {
+	case 0:
+		stride = stride | (1<<27) | (1<<16);
+		CAMSV_WRITE_REG(sub_dev->base + REG_CAMSV_IMGO_STRIDE, stride);
+		break;
+	case 1:
+		stride = stride | (1<<27) | (3<<16);
+		CAMSV_WRITE_REG(sub_dev->base + REG_CAMSV_IMGO_STRIDE, stride);
+		break;
+	case 2:
+		stride = stride | (1<<27) | (7<<16);
+		CAMSV_WRITE_REG(sub_dev->base + REG_CAMSV_IMGO_STRIDE, stride);
+		break;
+	case 3:
+		stride = stride | (1<<27) | (15<<16);
+		CAMSV_WRITE_REG(sub_dev->base + REG_CAMSV_IMGO_STRIDE, stride);
+		break;
+	default:
+		dev_dbg(sub_dev->dev, "unknown pixel mode(%d)", cfg_in_param->pixel_mode);
+		ret = -1;
+		goto EXIT;
+	}
+
+	/* imgo con */
+	switch (top_dev->id) {
+	case 0:
+	case 1:
+	case 2:
+	case 3:
+		CAMSV_WRITE_REG(top_dev->base + REG_CAMSV_IMGO_CON0, 0x80000300);
+		CAMSV_WRITE_REG(top_dev->base + REG_CAMSV_IMGO_CON1, 0x00C00060);
+		CAMSV_WRITE_REG(top_dev->base + REG_CAMSV_IMGO_CON2, 0x01800120);
+		CAMSV_WRITE_REG(top_dev->base + REG_CAMSV_IMGO_CON3, 0x020001A0);
+		CAMSV_WRITE_REG(top_dev->base + REG_CAMSV_IMGO_CON4, 0x012000C0);
+		break;
+	default:
+		CAMSV_WRITE_REG(top_dev->base + REG_CAMSV_IMGO_CON0, 0x80000100);
+		CAMSV_WRITE_REG(top_dev->base + REG_CAMSV_IMGO_CON1, 0x00400020);
+		CAMSV_WRITE_REG(top_dev->base + REG_CAMSV_IMGO_CON2, 0x00800060);
+		CAMSV_WRITE_REG(top_dev->base + REG_CAMSV_IMGO_CON3, 0x00AA0082);
+		CAMSV_WRITE_REG(top_dev->base + REG_CAMSV_IMGO_CON4, 0x00600040);
+		break;
+	}
+	switch (sub_dev->id) {
+	case 0:
+	case 1:
+	case 2:
+	case 3:
+		CAMSV_WRITE_REG(sub_dev->base + REG_CAMSV_IMGO_CON0, 0x80000300);
+		CAMSV_WRITE_REG(sub_dev->base + REG_CAMSV_IMGO_CON1, 0x00C00060);
+		CAMSV_WRITE_REG(sub_dev->base + REG_CAMSV_IMGO_CON2, 0x01800120);
+		CAMSV_WRITE_REG(sub_dev->base + REG_CAMSV_IMGO_CON3, 0x020001A0);
+		CAMSV_WRITE_REG(sub_dev->base + REG_CAMSV_IMGO_CON4, 0x012000C0);
+		break;
+	default:
+		CAMSV_WRITE_REG(sub_dev->base + REG_CAMSV_IMGO_CON0, 0x80000100);
+		CAMSV_WRITE_REG(sub_dev->base + REG_CAMSV_IMGO_CON1, 0x00400020);
+		CAMSV_WRITE_REG(sub_dev->base + REG_CAMSV_IMGO_CON2, 0x00800060);
+		CAMSV_WRITE_REG(sub_dev->base + REG_CAMSV_IMGO_CON3, 0x00AA0082);
+		CAMSV_WRITE_REG(sub_dev->base + REG_CAMSV_IMGO_CON4, 0x00600040);
+		break;
+	}
+EXIT:
+#endif //#ifdef ISP7_1
+
+	return ret;
+}
+
+int mtk_cam_sv_fbc_config(
+	struct mtk_camsv_device *dev,
+	struct mtkcam_ipi_input_param *cfg_in_param)
+{
+	int ret = 0;
+
+	CAMSV_WRITE_REG(dev->base + REG_CAMSV_FBC_IMGO_CTL1, 0);
+
+	return ret;
+}
+
+int mtk_cam_sv_tg_enable(
+	struct mtk_camsv_device *dev,
+	struct mtkcam_ipi_input_param *cfg_in_param)
+{
+	int ret = 0;
+
+	CAMSV_WRITE_BITS(dev->base + REG_CAMSV_TG_SEN_MODE,
+		CAMSV_TG_SEN_MODE, CMOS_EN, 1);
+
+	return ret;
+}
+
+int mtk_cam_sv_toggle_tg_db(struct mtk_camsv_device *dev)
+{
+	int val, val2;
+
+	val = CAMSV_READ_REG(dev->base_inner + REG_CAMSV_TG_PATH_CFG);
+	CAMSV_WRITE_BITS(dev->base + REG_CAMSV_TG_PATH_CFG,
+		CAMSV_TG_PATH_CFG, DB_LOAD_DIS, 1);
+
+	CAMSV_WRITE_BITS(dev->base + REG_CAMSV_TG_PATH_CFG,
+		CAMSV_TG_PATH_CFG, DB_LOAD_DIS, 0);
+	val2 = CAMSV_READ_REG(dev->base_inner + REG_CAMSV_TG_PATH_CFG);
+	dev_info(dev->dev, "%s 0x%x->0x%x\n", __func__, val, val2);
+
+	return 0;
+}
+
+int mtk_cam_sv_toggle_db(struct mtk_camsv_device *dev)
+{
+	int val, val2;
+
+	val = CAMSV_READ_REG(dev->base_inner + REG_CAMSV_MODULE_EN);
+	CAMSV_WRITE_BITS(dev->base + REG_CAMSV_MODULE_EN,
+		CAMSV_MODULE_EN, DB_EN, 0);
+
+	CAMSV_WRITE_BITS(dev->base + REG_CAMSV_MODULE_EN,
+		CAMSV_MODULE_EN, DB_EN, 1);
+	val2 = CAMSV_READ_REG(dev->base_inner + REG_CAMSV_MODULE_EN);
+	dev_info(dev->dev, "%s 0x%x->0x%x\n", __func__, val, val2);
+
+	return 0;
+}
+
+int mtk_cam_sv_top_enable(struct mtk_camsv_device *dev)
+{
+	int ret = 0;
+
+	CAMSV_WRITE_BITS(dev->base + REG_CAMSV_CLK_EN,
+		CAMSV_CLK_EN, TG_DP_CK_EN, 1);
+#ifdef ISP7_1
+	CAMSV_WRITE_BITS(dev->base + REG_CAMSV_CLK_EN,
+		CAMSV_CLK_EN, QBN_DP_CK_EN, 1);
+#endif
+	CAMSV_WRITE_BITS(dev->base + REG_CAMSV_CLK_EN,
+		CAMSV_CLK_EN, PAK_DP_CK_EN, 1);
+	CAMSV_WRITE_BITS(dev->base + REG_CAMSV_CLK_EN,
+		CAMSV_CLK_EN, IMGO_DP_CK_EN, 1);
+
+#ifdef ISP7_1
+	mtk_cam_sv_toggle_db(dev);
+	mtk_cam_sv_toggle_tg_db(dev);
+#else //MT8195
+	CAMSV_WRITE_BITS(dev->base + REG_CAMSV_MODULE_EN,
+		CAMSV_MODULE_EN, DB_EN, 0);
+	CAMSV_WRITE_BITS(dev->base + REG_CAMSV_MODULE_EN,
+		CAMSV_MODULE_EN, DB_EN, 1);
+#endif
+
+	dev_info(dev->dev, "%s FBC_IMGO_CTRL1/2:0x%x/0x%x\n",
+		__func__,
+		CAMSV_READ_REG(dev->base + REG_CAMSV_FBC_IMGO_CTL1),
+		CAMSV_READ_REG(dev->base + REG_CAMSV_FBC_IMGO_CTL2));
+
+	if (CAMSV_READ_BITS(dev->base + REG_CAMSV_TG_SEN_MODE,
+		CAMSV_TG_SEN_MODE, CMOS_EN) && dev->is_enqueued) {
+		CAMSV_WRITE_BITS(dev->base + REG_CAMSV_TG_VF_CON,
+			CAMSV_TG_VF_CON, VFDATA_EN, 1);
+	}
+
+	return ret;
+}
+
+int mtk_cam_sv_dmao_enable(
+	struct mtk_camsv_device *dev,
+	struct mtkcam_ipi_input_param *cfg_in_param)
+{
+	int ret = 0;
+
+	CAMSV_WRITE_BITS(dev->base + REG_CAMSV_MODULE_EN,
+		CAMSV_MODULE_EN, IMGO_EN, 1);
+
+	return ret;
+}
+
+int mtk_cam_sv_fbc_enable(
+	struct mtk_camsv_device *dev,
+	struct mtkcam_ipi_input_param *cfg_in_param)
+{
+	int ret = 0;
+
+	if (CAMSV_READ_BITS(dev->base + REG_CAMSV_TG_VF_CON,
+			CAMSV_TG_VF_CON, VFDATA_EN) == 1) {
+		ret = -1;
+		dev_dbg(dev->dev, "cannot enable fbc when streaming");
+		goto EXIT;
+	}
+	CAMSV_WRITE_BITS(dev->base + REG_CAMSV_FBC_IMGO_CTL1,
+		CAMSV_FBC_IMGO_CTL1, SUB_RATIO, cfg_in_param->subsample);
+	CAMSV_WRITE_BITS(dev->base + REG_CAMSV_FBC_IMGO_CTL1,
+		CAMSV_FBC_IMGO_CTL1, FBC_EN, 1);
+	CAMSV_WRITE_BITS(dev->base + REG_CAMSV_FBC_IMGO_CTL1,
+		CAMSV_FBC_IMGO_CTL1, FBC_DB_EN, 0);
+
+EXIT:
+	return ret;
+}
+
+int mtk_cam_sv_tg_disable(struct mtk_camsv_device *dev)
+{
+	int ret = 0;
+
+	CAMSV_WRITE_BITS(dev->base + REG_CAMSV_TG_SEN_MODE,
+		CAMSV_TG_SEN_MODE, CMOS_EN, 0);
+
+	return ret;
+}
+
+int mtk_cam_sv_top_disable(struct mtk_camsv_device *dev)
+{
+	int ret = 0;
+
+	if (CAMSV_READ_BITS(dev->base + REG_CAMSV_TG_VF_CON,
+			CAMSV_TG_VF_CON, VFDATA_EN)) {
+		CAMSV_WRITE_BITS(dev->base + REG_CAMSV_TG_VF_CON,
+			CAMSV_TG_VF_CON, VFDATA_EN, 0);
+#ifdef ISP7_1
+		mtk_cam_sv_toggle_tg_db(dev);
+#endif
+		sv_reset(dev);
+	}
+	CAMSV_WRITE_BITS(dev->base + REG_CAMSV_MODULE_EN,
+		CAMSV_MODULE_EN, DB_EN, 0);
+	CAMSV_WRITE_REG(dev->base + REG_CAMSV_MODULE_EN, 0);
+	CAMSV_WRITE_REG(dev->base + REG_CAMSV_FMT_SEL, 0);
+	CAMSV_WRITE_REG(dev->base + REG_CAMSV_INT_EN, 0);
+	CAMSV_WRITE_REG(dev->base + REG_CAMSV_FBC_IMGO_CTL1, 0);
+	CAMSV_WRITE_BITS(dev->base + REG_CAMSV_MODULE_EN,
+		CAMSV_MODULE_EN, DB_EN, 1);
+
+	CAMSV_WRITE_BITS(dev->base + REG_CAMSV_CLK_EN,
+		CAMSV_CLK_EN, TG_DP_CK_EN, 0);
+	CAMSV_WRITE_BITS(dev->base + REG_CAMSV_CLK_EN,
+		CAMSV_CLK_EN, PAK_DP_CK_EN, 0);
+	CAMSV_WRITE_BITS(dev->base + REG_CAMSV_CLK_EN,
+		CAMSV_CLK_EN, IMGO_DP_CK_EN, 0);
+
+	return ret;
+}
+
+int mtk_cam_sv_dmao_disable(struct mtk_camsv_device *dev)
+{
+	int ret = 0;
+
+	CAMSV_WRITE_BITS(dev->base + REG_CAMSV_MODULE_EN,
+		CAMSV_MODULE_EN, IMGO_EN, 0);
+
+	return ret;
+}
+
+int mtk_cam_sv_fbc_disable(struct mtk_camsv_device *dev)
+{
+	int ret = 0;
+
+	CAMSV_WRITE_REG(dev->base + REG_CAMSV_FBC_IMGO_CTL1, 0);
+
+	return ret;
+}
+
+int mtk_cam_sv_vf_on(struct mtk_camsv_device *dev, unsigned int is_on)
+{
+	int ret = 0;
+
+	if (is_on) {
+		if (CAMSV_READ_BITS(dev->base + REG_CAMSV_TG_VF_CON,
+			CAMSV_TG_VF_CON, VFDATA_EN) == 0) {
+			CAMSV_WRITE_BITS(dev->base + REG_CAMSV_TG_VF_CON,
+				CAMSV_TG_VF_CON, VFDATA_EN, 1);
+		}
+	} else {
+		if (CAMSV_READ_BITS(dev->base + REG_CAMSV_TG_VF_CON,
+			CAMSV_TG_VF_CON, VFDATA_EN) == 1) {
+			CAMSV_WRITE_BITS(dev->base + REG_CAMSV_TG_VF_CON,
+				CAMSV_TG_VF_CON, VFDATA_EN, 0);
+		}
+	}
+
+	return ret;
+}
+
+int mtk_cam_sv_is_vf_on(struct mtk_camsv_device *dev)
+{
+	if (CAMSV_READ_BITS(dev->base + REG_CAMSV_TG_VF_CON,
+			CAMSV_TG_VF_CON, VFDATA_EN) == 1)
+		return 1;
+	else
+		return 0;
+}
+
+int mtk_cam_sv_enquehwbuf(
+	struct mtk_camsv_device *dev,
+	dma_addr_t ba,
+	unsigned int seq_no)
+{
+	int ret = 0;
+	union CAMSV_TOP_FBC_CNT_SET reg;
+
+#ifdef ISP7_1
+#else
+	struct mtk_camsv_device *top_dev = dev_get_drvdata(dev->cam->sv.devs[dev->id / 2 * 2]);
+#endif
+
+	reg.Raw = 0;
+
+#ifdef ISP7_1
+	CAMSV_WRITE_REG(dev->base + REG_CAMSV_FRAME_SEQ_NO, seq_no);
+	CAMSV_WRITE_REG(dev->base + REG_CAMSV_IMGO_BASE_ADDR, ba & 0xFFFFFFFF);
+	CAMSV_WRITE_REG(dev->base + REG_CAMSV_IMGO_BASE_ADDR_MSB, (ba >> 32) & 0xF);
+	reg.Bits.RCNT_INC1 = 1;
+	CAMSV_WRITE_REG(dev->base + REG_CAMSV_TOP_FBC_CNT_SET, reg.Raw);
+#else
+	CAMSV_WRITE_REG(dev->base + REG_CAMSV_FRAME_SEQ_NO, seq_no);
+	CAMSV_WRITE_REG(dev->base + REG_CAMSV_IMGO_BASE_ADDR, ba);
+	if (dev->id % 2)
+		reg.Bits.RCNT_INC3 = 1;
+	else
+		reg.Bits.RCNT_INC1 = 1;
+	CAMSV_WRITE_REG(top_dev->base + REG_CAMSV_TOP_FBC_CNT_SET, reg.Raw);
+#endif
+	return ret;
+}
+
+int mtk_cam_sv_write_rcnt(struct mtk_cam_ctx *ctx, unsigned int pipe_id)
+{
+	int ret = 0;
+	union CAMSV_TOP_FBC_CNT_SET reg;
+	struct device *dev_sv;
+	struct mtk_camsv_device *camsv_dev;
+
+	dev_sv = ctx->cam->sv.devs[pipe_id - MTKCAM_SUBDEV_CAMSV_START];
+	camsv_dev = dev_get_drvdata(dev_sv);
+
+	reg.Raw = 0;
+	reg.Bits.RCNT_INC1 = 1;
+	CAMSV_WRITE_REG(camsv_dev->base + REG_CAMSV_TOP_FBC_CNT_SET, reg.Raw);
+
+	return ret;
+}
+
+int mtk_cam_sv_cal_cfg_info(struct mtk_cam_ctx *ctx,
+	const struct v4l2_format *img_fmt,
+	struct mtk_camsv_frame_params *params)
+{
+	int ret = 0;
+	union CAMSV_FMT_SEL fmt;
+	struct mtkcam_ipi_input_param cfg_in_param;
+	unsigned int pxl, lin;
+
+	fmt.Raw = mtk_cam_sv_format_sel(img_fmt->fmt.pix_mp.pixelformat);
+
+	cfg_in_param.fmt = fmt.Raw;
+	cfg_in_param.in_crop.p.x = 0;
+	cfg_in_param.in_crop.p.y = 0;
+	cfg_in_param.in_crop.s.w = ALIGN(img_fmt->fmt.pix_mp.width, 4);
+	cfg_in_param.in_crop.s.h = ALIGN(img_fmt->fmt.pix_mp.height, 4);
+	cfg_in_param.pixel_mode = 3;
+
+	pxl = ((cfg_in_param.in_crop.s.w + cfg_in_param.in_crop.p.x) << 16) |
+			cfg_in_param.in_crop.p.x;
+	lin = ((cfg_in_param.in_crop.s.h + cfg_in_param.in_crop.p.y) << 16) |
+			cfg_in_param.in_crop.p.y;
+
+	params->is_reconfig = 1;
+	params->cfg_info.grab_pxl = pxl;
+	params->cfg_info.grab_lin = lin;
+	params->cfg_info.fmt_sel = fmt.Raw;
+	params->cfg_info.pak =
+		mtk_cam_sv_pak_sel(fmt.Bits.TG1_FMT, cfg_in_param.pixel_mode);
+	params->cfg_info.imgo_xsize =
+		mtk_cam_sv_xsize_cal(&cfg_in_param) - 1;
+	params->cfg_info.imgo_ysize = cfg_in_param.in_crop.s.h - 1;
+	params->cfg_info.imgo_stride =
+		mtk_cam_sv_xsize_cal(&cfg_in_param);
+
+	dev_info(ctx->cam->dev, "%s pxl(0x%x)lin(0x%x)fmtsel(0x%x)pak(0x%x)xsize(0x%x)ysize(0x%x)stride(0x%x)",
+		__func__, params->cfg_info.grab_pxl, params->cfg_info.grab_lin,
+		params->cfg_info.fmt_sel, params->cfg_info.pak,
+		params->cfg_info.imgo_xsize, params->cfg_info.imgo_ysize,
+		params->cfg_info.imgo_stride);
+
+	return ret;
+}
+
+int mtk_cam_sv_setup_cfg_info(struct mtk_camsv_device *dev,
+	struct mtk_cam_request_stream_data *s_data)
+{
+	int ret = 0;
+#ifdef ISP7_1
+	if (s_data->sv_frame_params.is_reconfig) {
+		dev_dbg(dev->dev, "%s +", __func__);
+		CAMSV_WRITE_BITS(dev->base + REG_CAMSV_TG_PATH_CFG,
+			CAMSV_TG_PATH_CFG, DB_LOAD_HOLD, 1);
+		CAMSV_WRITE_REG(dev->base + REG_CAMSV_TG_SEN_GRAB_PXL,
+			s_data->sv_frame_params.cfg_info.grab_pxl);
+		CAMSV_WRITE_REG(dev->base + REG_CAMSV_TG_SEN_GRAB_LIN,
+			s_data->sv_frame_params.cfg_info.grab_lin);
+		CAMSV_WRITE_REG(dev->base + REG_CAMSV_FMT_SEL,
+			s_data->sv_frame_params.cfg_info.fmt_sel);
+		CAMSV_WRITE_REG(dev->base + REG_CAMSV_PAK,
+			s_data->sv_frame_params.cfg_info.pak);
+		CAMSV_WRITE_REG(dev->base + REG_CAMSV_IMGO_XSIZE,
+			s_data->sv_frame_params.cfg_info.imgo_xsize);
+		CAMSV_WRITE_REG(dev->base + REG_CAMSV_IMGO_YSIZE,
+			s_data->sv_frame_params.cfg_info.imgo_ysize);
+		CAMSV_WRITE_REG(dev->base + REG_CAMSV_IMGO_STRIDE,
+			s_data->sv_frame_params.cfg_info.imgo_stride);
+		CAMSV_WRITE_BITS(dev->base + REG_CAMSV_TG_PATH_CFG,
+			CAMSV_TG_PATH_CFG, DB_LOAD_HOLD, 0);
+		dev_dbg(dev->dev, "%s -", __func__);
+	}
+#endif
+
+	return ret;
+}
+
+int mtk_cam_find_sv_dev_index(
+	struct mtk_cam_ctx *ctx,
+	unsigned int idx)
+{
+	int i;
+
+	for (i = 0 ; i < MAX_SV_PIPES_PER_STREAM ; i++) {
+		if (ctx->used_sv_dev[i] == (1 << idx))
+			return i;
+	}
+
+	return -1;
+}
+
+int mtk_cam_sv_apply_all_buffers(struct mtk_cam_ctx *ctx, u64 ts_ns)
+{
+	unsigned int seq_no;
+	dma_addr_t base_addr;
+	struct mtk_camsv_working_buf_entry *buf_entry, *buf_entry_prev;
+	struct mtk_camsv_device *camsv_dev;
+	int i;
+
+	for (i = 0; i < ctx->used_sv_num; i++) {
+		camsv_dev = get_camsv_dev(ctx->cam, ctx->sv_pipe[i]);
+
+		spin_lock(&ctx->sv_using_buffer_list[i].lock);
+		if (list_empty(&ctx->sv_using_buffer_list[i].list)) {
+			spin_unlock(&ctx->sv_using_buffer_list[i].lock);
+			return 0;
+		}
+		list_for_each_entry_safe(buf_entry, buf_entry_prev,
+			&ctx->sv_using_buffer_list[i].list, list_entry) {
+			if (buf_entry->ts_raw == 0) {
+				buf_entry->ts_raw = ts_ns;
+				break;
+			}
+		}
+		buf_entry = list_first_entry(&ctx->sv_using_buffer_list[i].list,
+				struct mtk_camsv_working_buf_entry, list_entry);
+		if (mtk_cam_sv_is_vf_on(camsv_dev) &&
+			(ctx->used_raw_num != 0)) {
+			if ((buf_entry->ts_sv == 0) ||
+				((buf_entry->ts_sv < buf_entry->ts_raw) &&
+				((buf_entry->ts_raw - buf_entry->ts_sv) > 10000000))) {
+				dev_dbg(ctx->cam->dev, "%s pipe_id:%d ts_raw:%lld ts_sv:%lld",
+					__func__, ctx->sv_pipe[i]->id,
+					buf_entry->ts_raw, buf_entry->ts_sv);
+				spin_unlock(&ctx->sv_using_buffer_list[i].lock);
+				continue;
+			}
+		}
+		list_del(&buf_entry->list_entry);
+		ctx->sv_using_buffer_list[i].cnt--;
+		spin_unlock(&ctx->sv_using_buffer_list[i].lock);
+		spin_lock(&ctx->sv_processing_buffer_list[i].lock);
+		list_add_tail(&buf_entry->list_entry,
+				&ctx->sv_processing_buffer_list[i].list);
+		ctx->sv_processing_buffer_list[i].cnt++;
+		spin_unlock(&ctx->sv_processing_buffer_list[i].lock);
+
+		if (buf_entry->s_data->req->pipe_used & (1 << ctx->sv_pipe[i]->id)) {
+			if (buf_entry->s_data->frame_seq_no == 1) {
+				seq_no = buf_entry->s_data->frame_seq_no;
+				base_addr =
+					buf_entry->s_data->sv_frame_params.img_out.buf[0][0].iova;
+				camsv_dev->is_enqueued = 1;
+				mtk_cam_sv_enquehwbuf(camsv_dev, base_addr, seq_no);
+				/* initial request readout will be delayed 1 frame */
+				if (ctx->used_raw_num && !mtk_cam_is_subsample(ctx) &&
+					!mtk_cam_is_stagger(ctx) && !mtk_cam_is_stagger_m2m(ctx) &&
+					!mtk_cam_is_time_shared(ctx) && !mtk_cam_is_mstream(ctx))
+					mtk_cam_sv_write_rcnt(ctx, ctx->sv_pipe[i]->id);
+			} else {
+				if (ctx->sv_wq)
+					queue_work(ctx->sv_wq, &buf_entry->s_data->sv_work.work);
+			}
+		} else {
+			/* under seamless/sat case, to turn off vf */
+			if (ctx->sv_wq)
+				queue_work(ctx->sv_wq, &buf_entry->s_data->sv_work.work);
+		}
+	}
+
+	return 1;
+}
+
+int mtk_cam_sv_apply_next_buffer(struct mtk_cam_ctx *ctx,
+	unsigned int pipe_id, u64 ts_ns)
+{
+	unsigned int seq_no;
+	dma_addr_t base_addr;
+	struct mtk_camsv_working_buf_entry *buf_entry;
+	struct mtk_camsv_device *camsv_dev;
+	struct mtk_cam_request_stream_data *s_data;
+	int i;
+
+	for (i = 0; i < ctx->used_sv_num; i++) {
+		if (ctx->sv_pipe[i]->id == pipe_id) {
+			camsv_dev = get_camsv_dev(ctx->cam, ctx->sv_pipe[i]);
+
+			spin_lock(&ctx->sv_using_buffer_list[i].lock);
+			if (list_empty(&ctx->sv_using_buffer_list[i].list)) {
+				spin_unlock(&ctx->sv_using_buffer_list[i].lock);
+				return 0;
+			}
+			buf_entry = list_first_entry(&ctx->sv_using_buffer_list[i].list,
+					struct mtk_camsv_working_buf_entry, list_entry);
+			buf_entry->ts_sv = ts_ns;
+			if (((buf_entry->ts_raw == 0) && (ctx->used_raw_num != 0)) ||
+				((buf_entry->ts_sv < buf_entry->ts_raw) &&
+				((buf_entry->ts_raw - buf_entry->ts_sv) > 10000000))) {
+				dev_dbg(ctx->cam->dev, "%s pipe_id:%d ts_raw:%lld ts_sv:%lld",
+					__func__, ctx->sv_pipe[i]->id,
+					buf_entry->ts_raw, buf_entry->ts_sv);
+				spin_unlock(&ctx->sv_using_buffer_list[i].lock);
+				return 1;
+			}
+			list_del(&buf_entry->list_entry);
+			ctx->sv_using_buffer_list[i].cnt--;
+			spin_unlock(&ctx->sv_using_buffer_list[i].lock);
+			spin_lock(&ctx->sv_processing_buffer_list[i].lock);
+			list_add_tail(&buf_entry->list_entry,
+					&ctx->sv_processing_buffer_list[i].list);
+			ctx->sv_processing_buffer_list[i].cnt++;
+			spin_unlock(&ctx->sv_processing_buffer_list[i].lock);
+
+			if (buf_entry->s_data->req->pipe_used & (1 << ctx->sv_pipe[i]->id)) {
+				if (buf_entry->s_data->frame_seq_no == 1) {
+					s_data = buf_entry->s_data;
+					seq_no = s_data->frame_seq_no;
+					base_addr =
+						s_data->sv_frame_params.img_out.buf[0][0].iova;
+					camsv_dev->is_enqueued = 1;
+					mtk_cam_sv_enquehwbuf(camsv_dev, base_addr, seq_no);
+					/* initial request readout will be delayed 1 frame */
+					if (ctx->used_raw_num && !mtk_cam_is_subsample(ctx) &&
+						!mtk_cam_is_stagger(ctx) &&
+						!mtk_cam_is_stagger_m2m(ctx) &&
+						!mtk_cam_is_time_shared(ctx) &&
+						!mtk_cam_is_mstream(ctx))
+						mtk_cam_sv_write_rcnt(ctx, ctx->sv_pipe[i]->id);
+				} else {
+					if (ctx->sv_wq)
+						queue_work(ctx->sv_wq,
+							&buf_entry->s_data->sv_work.work);
+				}
+			} else {
+				/* under seamless/sat case, to turn off vf */
+				if (ctx->sv_wq)
+					queue_work(ctx->sv_wq, &buf_entry->s_data->sv_work.work);
+			}
+			break;
+		}
+	}
+
+	return 1;
+}
+
+int mtk_cam_sv_rgbw_apply_next_buffer(
+	struct mtk_cam_request_stream_data *s_data)
+{
+	struct mtk_cam_ctx *ctx = s_data->ctx;
+	struct mtk_camsv_device *camsv_dev;
+	dma_addr_t base_addr;
+	unsigned int seq_no;
+	int i, ret = 0;
+
+	for (i = MTKCAM_SUBDEV_CAMSV_START; i < MTKCAM_SUBDEV_CAMSV_END; i++) {
+		if (ctx->pipe->enabled_raw & (1 << i)) {
+			camsv_dev = get_camsv_dev(
+				ctx->cam, &ctx->cam->sv.pipelines[i - MTKCAM_SUBDEV_CAMSV_START]);
+			base_addr = s_data->sv_frame_params.img_out.buf[0][0].iova;
+			seq_no = s_data->frame_seq_no;
+			mtk_cam_sv_enquehwbuf(camsv_dev, base_addr, seq_no);
+			ret = 1;
+		}
+	}
+
+	return ret;
+}
+
+int mtk_cam_sv_apply_switch_buffers(struct mtk_cam_ctx *ctx)
+{
+	unsigned int seq_no;
+	dma_addr_t base_addr;
+	struct mtk_camsv_working_buf_entry *buf_entry;
+	struct mtk_camsv_device *camsv_dev;
+	int i;
+
+	for (i = 0; i < ctx->used_sv_num; i++) {
+		camsv_dev = get_camsv_dev(ctx->cam, ctx->sv_pipe[i]);
+
+		spin_lock(&ctx->sv_using_buffer_list[i].lock);
+		if (list_empty(&ctx->sv_using_buffer_list[i].list)) {
+			spin_unlock(&ctx->sv_using_buffer_list[i].lock);
+			return 0;
+		}
+		buf_entry = list_first_entry(&ctx->sv_using_buffer_list[i].list,
+				struct mtk_camsv_working_buf_entry, list_entry);
+		list_del(&buf_entry->list_entry);
+		ctx->sv_using_buffer_list[i].cnt--;
+		spin_unlock(&ctx->sv_using_buffer_list[i].lock);
+		spin_lock(&ctx->sv_processing_buffer_list[i].lock);
+		list_add_tail(&buf_entry->list_entry,
+				&ctx->sv_processing_buffer_list[i].list);
+		ctx->sv_processing_buffer_list[i].cnt++;
+		spin_unlock(&ctx->sv_processing_buffer_list[i].lock);
+
+		if (buf_entry->s_data->req->pipe_used & (1 << ctx->sv_pipe[i]->id)) {
+			seq_no = buf_entry->s_data->frame_seq_no;
+			base_addr =
+				buf_entry->s_data->sv_frame_params.img_out.buf[0][0].iova;
+			camsv_dev->is_enqueued = 1;
+			mtk_cam_sv_enquehwbuf(camsv_dev, base_addr, seq_no);
+		}
+	}
+
+	return 1;
+}
+
+int mtk_cam_sv_dev_config(
+	struct mtk_cam_ctx *ctx,
+	unsigned int idx,
+	unsigned int hw_scen,
+	unsigned int exp_order)
+{
+	struct mtk_cam_device *cam = ctx->cam;
+	struct device *dev = cam->dev;
+	struct mtkcam_ipi_input_param cfg_in_param;
+	struct v4l2_mbus_framefmt *mf;
+	struct device *dev_sv;
+	struct mtk_camsv_device *camsv_dev;
+	struct mtk_camsv_device *camsv_top_dev;
+	struct v4l2_format *img_fmt;
+	unsigned int i;
+	int ret, pad_idx, pixel_mode = 0;
+
+	if (hw_scen & MTK_CAMSV_SUPPORTED_SPECIAL_HW_SCENARIO) {
+		if (hw_scen & (1 << MTKCAM_SV_SPECIAL_SCENARIO_ADDITIONAL_RAW)) {
+			img_fmt = &ctx->pipe->vdev_nodes[
+				MTK_RAW_MAIN_STREAM_SV_1_OUT - MTK_RAW_SINK_NUM].active_fmt;
+			pad_idx = PAD_SRC_RAW_W0;
+			mf = &ctx->pipe->cfg[MTK_RAW_SINK].mbus_fmt;
+		} else {
+			img_fmt = &ctx->pipe->vdev_nodes[MTK_RAW_MAIN_STREAM_OUT - MTK_RAW_SINK_NUM]
+				.active_fmt;
+			pad_idx = PAD_SRC_RAW0;
+			mf = &ctx->pipe->cfg[MTK_RAW_SINK].mbus_fmt;
+		}
+	} else {
+		img_fmt = &ctx->sv_pipe[idx]
+			->vdev_nodes[MTK_CAMSV_MAIN_STREAM_OUT-MTK_CAMSV_SINK_NUM].active_fmt;
+		pad_idx = ctx->sv_pipe[idx]->seninf_padidx;
+		mf = &ctx->sv_pipe[idx]->cfg[MTK_CAMSV_SINK].mbus_fmt;
+	}
+
+	/* Update cfg_in_param */
+	mtk_cam_seninf_get_pixelmode(ctx->seninf, pad_idx, &pixel_mode);
+	cfg_in_param.pixel_mode = pixel_mode;
+	cfg_in_param.data_pattern = 0x0;
+	cfg_in_param.in_crop.p.x = 0;
+	cfg_in_param.in_crop.p.y = 0;
+#ifdef ISP7_1 //TODO: why?
+	cfg_in_param.in_crop.s.w =
+		(mtk_camsv_is_yuv_format(img_fmt->fmt.pix_mp.pixelformat)) ?
+		ALIGN(img_fmt->fmt.pix_mp.width, 4) * 2 :
+		ALIGN(img_fmt->fmt.pix_mp.width, 4);
+	cfg_in_param.in_crop.s.h = img_fmt->fmt.pix_mp.height;
+#else
+	cfg_in_param.in_crop.s.w = ALIGN(img_fmt->fmt.pix_mp.width, 4);
+	cfg_in_param.in_crop.s.h = ALIGN(img_fmt->fmt.pix_mp.height, 4);
+#endif //#ifdef ISP7_1
+	dev_info(dev, "sink pad code:0x%x raw's imgo stride:%d\n", mf->code,
+		img_fmt->fmt.pix_mp.plane_fmt[0].bytesperline);
+	cfg_in_param.raw_pixel_id = mtk_cam_get_sensor_pixel_id(mf->code);
+	cfg_in_param.subsample = 0;
+	cfg_in_param.fmt = mtk_cam_sv_format_sel(img_fmt->fmt.pix_mp.pixelformat);
+
+	if (cfg_in_param.in_crop.s.w % (1 << pixel_mode))
+		dev_info(dev, "crop width(%d) is not the multiple of pixel mode(%d)\n",
+			cfg_in_param.in_crop.s.w, pixel_mode);
+
+	if (hw_scen & MTK_CAMSV_SUPPORTED_SPECIAL_HW_SCENARIO) {
+		pm_runtime_get_sync(cam->sv.devs[idx]);
+	} else {
+		ret = mtk_cam_sv_pipeline_config(ctx, idx, &cfg_in_param);
+		if (ret)
+			return ret;
+	}
+
+	if (hw_scen & MTK_CAMSV_SUPPORTED_SPECIAL_HW_SCENARIO) {
+		dev_sv = cam->sv.devs[idx];
+		if (dev_sv == NULL) {
+			dev_dbg(dev, "config camsv device not found\n");
+			return -EINVAL;
+		}
+		camsv_dev = dev_get_drvdata(dev_sv);
+		camsv_dev->pipeline = &cam->sv.pipelines[idx];
+		camsv_dev->pipeline->hw_scen = hw_scen;
+		camsv_dev->pipeline->main_pipe_id = ctx->pipe->id;
+		camsv_dev->pipeline->exp_order = exp_order;
+		camsv_top_dev = dev_get_drvdata(cam->sv.devs[camsv_dev->id / 2 * 2]);
+	} else {
+		dev_sv = mtk_cam_find_sv_dev(cam, ctx->used_sv_dev[idx]);
+		if (dev_sv == NULL) {
+			dev_dbg(dev, "config camsv device not found\n");
+			return -EINVAL;
+		}
+		camsv_dev = dev_get_drvdata(dev_sv);
+		for (i = 0; i < CAMSV_PIPELINE_NUM; i++)
+			if (cam->sv.pipelines[i].enabled_sv & 1<<camsv_dev->id) {
+				camsv_dev->pipeline = &cam->sv.pipelines[i];
+				break;
+			}
+		camsv_dev->pipeline->hw_scen = hw_scen;
+		camsv_dev->pipeline->main_pipe_id = 0;
+		camsv_dev->pipeline->exp_order = 0;
+		camsv_top_dev = dev_get_drvdata(cam->sv.devs[camsv_dev->id / 2 * 2]);
+	}
+
+	/* reset enqueued status */
+	camsv_dev->is_enqueued = 0;
+	reset_msgfifo(camsv_dev);
+
+	mtk_cam_sv_tg_config(camsv_dev, &cfg_in_param);
+	mtk_cam_sv_top_config(camsv_dev, &cfg_in_param);
+	mtk_cam_sv_dmao_config(camsv_top_dev, camsv_dev, &cfg_in_param,
+					hw_scen, img_fmt->fmt.pix_mp.plane_fmt[0].bytesperline);
+	mtk_cam_sv_fbc_config(camsv_dev, &cfg_in_param);
+	mtk_cam_sv_tg_enable(camsv_dev, &cfg_in_param);
+	mtk_cam_sv_dmao_enable(camsv_dev, &cfg_in_param);
+	mtk_cam_sv_fbc_enable(camsv_dev, &cfg_in_param);
+
+	mtk_camsv_register_iommu_tf_callback(camsv_dev);
+
+	dev_info(dev, "camsv %d %s done\n", camsv_dev->id, __func__);
+
+	return 0;
+}
+
+int mtk_cam_sv_dev_stream_on(
+	struct mtk_cam_ctx *ctx,
+	unsigned int idx,
+	unsigned int streaming,
+	unsigned int hw_scen)
+{
+	struct mtk_cam_device *cam = ctx->cam;
+	struct device *dev = cam->dev;
+	struct device *dev_sv;
+	struct mtk_camsv_device *camsv_dev;
+	unsigned int i;
+	int ret = 0;
+
+	if (hw_scen & MTK_CAMSV_SUPPORTED_SPECIAL_HW_SCENARIO) {
+		dev_sv = cam->sv.devs[idx];
+		if (dev_sv == NULL) {
+			dev_dbg(dev, "stream on camsv device not found\n");
+			return -EINVAL;
+		}
+		camsv_dev = dev_get_drvdata(dev_sv);
+		camsv_dev->is_enqueued = 1;
+	} else {
+		dev_sv = mtk_cam_find_sv_dev(cam, ctx->used_sv_dev[idx]);
+		if (dev_sv == NULL) {
+			dev_dbg(dev, "stream on camsv device not found\n");
+			return -EINVAL;
+		}
+		camsv_dev = dev_get_drvdata(dev_sv);
+		for (i = 0; i < CAMSV_PIPELINE_NUM; i++)
+			if (cam->sv.pipelines[i].enabled_sv & 1<<camsv_dev->id) {
+				camsv_dev->pipeline = &cam->sv.pipelines[i];
+				break;
+			}
+	}
+
+	if (streaming)
+		ret = mtk_cam_sv_top_enable(camsv_dev);
+	else {
+		/* reset enqueued status */
+		camsv_dev->is_enqueued = 0;
+
+		ret = mtk_cam_sv_top_disable(camsv_dev) ||
+			mtk_cam_sv_fbc_disable(camsv_dev) ||
+			mtk_cam_sv_dmao_disable(camsv_dev) ||
+			mtk_cam_sv_tg_disable(camsv_dev);
+		pm_runtime_put_sync(camsv_dev->dev);
+	}
+
+	dev_info(dev, "camsv %d %s en(%d)\n", camsv_dev->id, __func__, streaming);
+
+	return ret;
+}
+
+static void mtk_camsv_pipeline_queue_setup(
+	struct mtk_camsv_pipeline *pipe)
+{
+	unsigned int node_idx, i;
+
+	node_idx = 0;
+	/* Setup the capture queue */
+	for (i = 0; i < MTK_CAMSV_TOTAL_CAPTURE_QUEUES; i++) {
+		pipe->vdev_nodes[node_idx].desc = sv_capture_queues[i];
+		pipe->vdev_nodes[node_idx++].desc.name =
+			sv_capture_queue_names[pipe->id-MTKCAM_SUBDEV_CAMSV_START][i];
+	}
+}
+
+static int mtk_camsv_pipeline_register(
+	unsigned int id, struct device *dev,
+	struct mtk_camsv_pipeline *pipe,
+	struct v4l2_device *v4l2_dev)
+{
+	struct mtk_cam_device *cam = dev_get_drvdata(pipe->sv->cam_dev);
+	struct mtk_camsv_device *camsv_dev = dev_get_drvdata(dev);
+	struct v4l2_subdev *sd = &pipe->subdev;
+	struct mtk_cam_video_device *video;
+	unsigned int i;
+	int ret;
+
+	pipe->id = id;
+	pipe->hw_cap = camsv_dev->hw_cap;
+	pipe->cammux_id = camsv_dev->cammux_id;
+
+	/* Initialize subdev */
+	v4l2_subdev_init(sd, &mtk_camsv_subdev_ops);
+	sd->entity.function = MEDIA_ENT_F_PROC_VIDEO_PIXEL_FORMATTER;
+	sd->entity.ops = &mtk_camsv_media_entity_ops;
+	sd->flags = V4L2_SUBDEV_FL_HAS_DEVNODE | V4L2_SUBDEV_FL_HAS_EVENTS;
+	ret = snprintf(sd->name, sizeof(sd->name),
+		 "%s-%d", dev_driver_string(dev), (pipe->id-MTKCAM_SUBDEV_CAMSV_START));
+	if (ret < 0) {
+		dev_info(dev, "Failed to compose device name: %d\n", ret);
+		return ret;
+	}
+	v4l2_set_subdevdata(sd, pipe);
+
+	dev_info(dev, "%s: %s\n", __func__, sd->name);
+
+	ret = v4l2_device_register_subdev(v4l2_dev, sd);
+	if (ret < 0) {
+		dev_info(dev, "Failed to register subdev: %d\n", ret);
+		return ret;
+	}
+
+	mtk_camsv_pipeline_queue_setup(pipe);
+
+	//setup pads of camsv pipeline
+	for (i = 0; i < ARRAY_SIZE(pipe->pads); i++) {
+		pipe->pads[i].flags = i < MTK_CAMSV_SOURCE_BEGIN ?
+			MEDIA_PAD_FL_SINK : MEDIA_PAD_FL_SOURCE;
+	}
+
+	media_entity_pads_init(&sd->entity, ARRAY_SIZE(pipe->pads), pipe->pads);
+
+	/* setup video node */
+	for (i = 0; i < ARRAY_SIZE(pipe->vdev_nodes); i++) {
+		video = pipe->vdev_nodes + i;
+
+		if (pipe->id >= MTKCAM_SUBDEV_CAMSV_START &&
+			pipe->id < MTKCAM_SUBDEV_CAMSV_END)
+			video->uid.pipe_id = pipe->id;
+		else {
+			dev_info(dev, "invalid pipe id\n");
+			return -EINVAL;
+		}
+
+		video->uid.id = video->desc.dma_port;
+		video->ctx = &cam->ctxs[id];
+		ret = mtk_cam_video_register(video, v4l2_dev);
+		if (ret)
+			goto fail_unregister_video;
+
+		if (V4L2_TYPE_IS_OUTPUT(video->desc.buf_type))
+			ret = media_create_pad_link(&video->vdev.entity, 0,
+						    &sd->entity,
+						    video->desc.id,
+						    video->desc.link_flags);
+		else
+			ret = media_create_pad_link(&sd->entity,
+						    video->desc.id,
+						    &video->vdev.entity, 0,
+						    video->desc.link_flags);
+
+		if (ret)
+			goto fail_unregister_video;
+	}
+
+	return 0;
+
+fail_unregister_video:
+	for (i = i-1; i >= 0; i--)
+		mtk_cam_video_unregister(pipe->vdev_nodes + i);
+
+	return ret;
+}
+
+static void mtk_camsv_pipeline_unregister(
+	struct mtk_camsv_pipeline *pipe)
+{
+	unsigned int i;
+
+	for (i = 0; i < ARRAY_SIZE(pipe->vdev_nodes); i++)
+		mtk_cam_video_unregister(pipe->vdev_nodes + i);
+
+	v4l2_device_unregister_subdev(&pipe->subdev);
+	media_entity_cleanup(&pipe->subdev.entity);
+}
+
+int mtk_camsv_setup_dependencies(struct mtk_camsv *sv, struct mtk_larb *larb)
+{
+	struct device *dev = sv->cam_dev;
+	struct device *consumer, *supplier;
+	struct device_link *link;
+	int i;
+
+	for (i = 0; i < CAMSV_PIPELINE_NUM; i++) {
+		consumer = sv->devs[i];
+		if (!consumer) {
+			dev_info(dev, "failed to get dev for id %d\n", i);
+			continue;
+		}
+
+		switch (i) {
+#ifdef ISP7_1
+		case 0:
+		case 1:
+		case 4:
+		case 5:
+		case 8:
+		case 9:
+		case 12:
+		case 13:
+#else //MT8195
+		case 3: /* special case: 13 + 14 */
+			supplier = find_larb(larb, 14);
+			link = device_link_add(consumer, supplier,
+					       DL_FLAG_AUTOREMOVE_CONSUMER |
+					       DL_FLAG_PM_RUNTIME);
+			if (!link) {
+				dev_info(dev, "Unable to create link between %s and %s\n",
+					dev_name(consumer), dev_name(supplier));
+				return -ENODEV;
+			}
+			break;
+		case 0:
+		case 2:
+		case 4:
+#endif
+			supplier = find_larb(larb, 13);
+			break;
+		default:
+			supplier = find_larb(larb, 14);
+			break;
+		}
+
+		if (!supplier) {
+			dev_info(dev, "failed to get supplier for id %d\n", i);
+			return -ENODEV;
+		}
+
+		link = device_link_add(consumer, supplier,
+				       DL_FLAG_AUTOREMOVE_CONSUMER |
+				       DL_FLAG_PM_RUNTIME);
+		if (!link) {
+			dev_info(dev, "Unable to create link between %s and %s\n",
+				dev_name(consumer), dev_name(supplier));
+			return -ENODEV;
+		}
+	}
+
+	return 0;
+}
+
+int mtk_camsv_register_entities(
+	struct mtk_camsv *sv,
+	struct v4l2_device *v4l2_dev)
+{
+	unsigned int i;
+	int ret;
+
+	for (i = 0; i < CAMSV_PIPELINE_NUM; i++) {
+		struct mtk_camsv_pipeline *pipe = sv->pipelines + i;
+
+		pipe->sv = sv;
+		memset(pipe->cfg, 0, sizeof(*pipe->cfg));
+		ret = mtk_camsv_pipeline_register(MTKCAM_SUBDEV_CAMSV_START + i,
+						sv->devs[i],
+						sv->pipelines + i, v4l2_dev);
+		if (ret)
+			return ret;
+	}
+	return 0;
+}
+
+void mtk_camsv_unregister_entities(struct mtk_camsv *sv)
+{
+	unsigned int i;
+
+	for (i = 0; i < CAMSV_PIPELINE_NUM; i++)
+		mtk_camsv_pipeline_unregister(sv->pipelines + i);
+}
+
+static void camsv_dump_dma_debug_data(struct mtk_camsv_device *camsv_dev)
+{
+
+	u32 checksum, line_pix_cnt, line_pix_cnt_temp, smi_debug_data;
+	u32 fifo_debug_data_1, fifo_debug_data_3, smi_crc, smi_latency;
+	u32 smi_len_dle_cnt, smi_com_bvalid_cnt;
+
+	writel_relaxed(0x00000100, camsv_dev->base + REG_CAMSV_DMATOP_DMA_DEBUG_SEL);
+	checksum = readl_relaxed(camsv_dev->base + REG_CAMSV_DMATOP_DMA_DEBUG_PORT);
+	writel_relaxed(0x00000200, camsv_dev->base + REG_CAMSV_DMATOP_DMA_DEBUG_SEL);
+	line_pix_cnt = readl_relaxed(camsv_dev->base + REG_CAMSV_DMATOP_DMA_DEBUG_PORT);
+	writel_relaxed(0x00000300, camsv_dev->base + REG_CAMSV_DMATOP_DMA_DEBUG_SEL);
+	line_pix_cnt_temp = readl_relaxed(camsv_dev->base + REG_CAMSV_DMATOP_DMA_DEBUG_PORT);
+	writel_relaxed(0x00000800, camsv_dev->base + REG_CAMSV_DMATOP_DMA_DEBUG_SEL);
+	smi_debug_data = readl_relaxed(camsv_dev->base + REG_CAMSV_DMATOP_DMA_DEBUG_PORT);
+	writel_relaxed(0x00010700, camsv_dev->base + REG_CAMSV_DMATOP_DMA_DEBUG_SEL);
+	fifo_debug_data_1 = readl_relaxed(camsv_dev->base + REG_CAMSV_DMATOP_DMA_DEBUG_PORT);
+	writel_relaxed(0x00030700, camsv_dev->base + REG_CAMSV_DMATOP_DMA_DEBUG_SEL);
+	fifo_debug_data_3 = readl_relaxed(camsv_dev->base + REG_CAMSV_DMATOP_DMA_DEBUG_PORT);
+	writel_relaxed(0x01000040, camsv_dev->base + REG_CAMSV_DMATOP_DMA_DEBUG_SEL);
+	smi_crc = readl_relaxed(camsv_dev->base + REG_CAMSV_DMATOP_DMA_DEBUG_PORT);
+	writel_relaxed(0x00000080, camsv_dev->base + REG_CAMSV_DMATOP_DMA_DEBUG_SEL);
+	smi_latency = readl_relaxed(camsv_dev->base + REG_CAMSV_DMATOP_DMA_DEBUG_PORT);
+	writel_relaxed(0x000000A0, camsv_dev->base + REG_CAMSV_DMATOP_DMA_DEBUG_SEL);
+	smi_len_dle_cnt = readl_relaxed(camsv_dev->base + REG_CAMSV_DMATOP_DMA_DEBUG_PORT);
+	writel_relaxed(0x000000A1, camsv_dev->base + REG_CAMSV_DMATOP_DMA_DEBUG_SEL);
+	smi_com_bvalid_cnt = readl_relaxed(camsv_dev->base + REG_CAMSV_DMATOP_DMA_DEBUG_PORT);
+
+	dev_info_ratelimited(camsv_dev->dev,
+		"dma_top_debug:0x%x_0x%x_0x%x_0x%x_0x%x_0x%x_0x%x_0x%x_0x%x_0x%x\n",
+		checksum, line_pix_cnt, line_pix_cnt_temp, smi_debug_data,
+		fifo_debug_data_1, fifo_debug_data_3, smi_crc, smi_latency,
+		smi_len_dle_cnt, smi_com_bvalid_cnt);
+}
+
+static void camsv_irq_handle_err(
+	struct mtk_camsv_device *camsv_dev,
+	unsigned int dequeued_frame_seq_no)
+{
+	int val, val2;
+	struct mtk_cam_request_stream_data *s_data;
+	struct mtk_cam_device *cam = camsv_dev->cam;
+	struct mtk_cam_ctx *ctx;
+	struct mtk_raw_pipeline *raw_pipe;
+	unsigned int stream_id;
+
+	val = readl_relaxed(camsv_dev->base + REG_CAMSV_TG_PATH_CFG);
+	val = val | CAMSV_TG_PATH_TG_FULL_SEL;
+	writel_relaxed(val, camsv_dev->base + REG_CAMSV_TG_PATH_CFG);
+	wmb(); /* TBC */
+	val2 = readl_relaxed(camsv_dev->base + REG_CAMSV_TG_SEN_MODE);
+	val2 = val2 | CAMSV_TG_SEN_MODE_CMOS_RDY_SEL;
+	writel_relaxed(val2, camsv_dev->base + REG_CAMSV_TG_SEN_MODE);
+	wmb(); /* TBC */
+	dev_info_ratelimited(camsv_dev->dev,
+		"TG PATHCFG/SENMODE/FRMSIZE/RGRABPXL/LIN:%x/%x/%x/%x/%x/%x\n",
+		readl_relaxed(camsv_dev->base + REG_CAMSV_TG_PATH_CFG),
+		readl_relaxed(camsv_dev->base + REG_CAMSV_TG_SEN_MODE),
+		readl_relaxed(camsv_dev->base + REG_CAMSV_TG_FRMSIZE_ST),
+		readl_relaxed(camsv_dev->base + REG_CAMSV_TG_FRMSIZE_ST_R),
+		readl_relaxed(camsv_dev->base + REG_CAMSV_TG_SEN_GRAB_PXL),
+		readl_relaxed(camsv_dev->base + REG_CAMSV_TG_SEN_GRAB_LIN));
+	dev_info_ratelimited(camsv_dev->dev,
+		"IMGO:0x%x\n",
+		readl_relaxed(camsv_dev->base + REG_CAMSV_IMGO_ERR_STAT));
+
+	if (camsv_dev->pipeline->hw_scen &
+		MTK_CAMSV_SUPPORTED_SPECIAL_HW_SCENARIO) {
+		raw_pipe = &cam->raw
+			.pipelines[camsv_dev->pipeline->main_pipe_id];
+		ctx = mtk_cam_find_ctx(cam, &raw_pipe->subdev.entity);
+		if (!ctx) {
+			dev_info(camsv_dev->dev, "%s: cannot find ctx\n", __func__);
+			return;
+		}
+		stream_id = camsv_dev->pipeline->main_pipe_id;
+	} else {
+		ctx = mtk_cam_find_ctx(camsv_dev->cam,
+			&camsv_dev->pipeline->subdev.entity);
+		if (!ctx) {
+			dev_info(camsv_dev->dev, "%s: cannot find ctx\n", __func__);
+			return;
+		}
+		stream_id = camsv_dev->id + MTKCAM_SUBDEV_CAMSV_START;
+	}
+
+	s_data = mtk_cam_get_req_s_data(ctx, stream_id, dequeued_frame_seq_no);
+	if (s_data) {
+		//mtk_cam_debug_seninf_dump(s_data); //TODO: wait for define
+	} else {
+		dev_info(camsv_dev->dev,
+			 "%s: req(%d) can't be found for seninf dump\n",
+			 __func__, dequeued_frame_seq_no);
+	}
+}
+
+static void camsv_handle_err(
+	struct mtk_camsv_device *camsv_dev,
+	struct mtk_camsys_irq_info *data)
+{
+	int err_status = data->e.err_status;
+	int frame_idx_inner = data->frame_idx_inner;
+
+	dev_info_ratelimited(camsv_dev->dev, "error status:0x%x", err_status);
+
+	/* show more error detail */
+	camsv_irq_handle_err(camsv_dev, frame_idx_inner);
+
+	/* dump dma debug data */
+	camsv_dump_dma_debug_data(camsv_dev);
+}
+
+static irqreturn_t mtk_irq_camsv(int irq, void *data)
+{
+	struct mtk_camsv_device *camsv_dev = (struct mtk_camsv_device *)data;
+	struct device *dev = camsv_dev->dev;
+	struct mtk_camsys_irq_info irq_info;
+	unsigned int dequeued_imgo_seq_no, dequeued_imgo_seq_no_inner;
+	unsigned int irq_status, err_status;
+	unsigned int drop_status, imgo_err_status, imgo_overr_status;
+	unsigned int fbc_imgo_status, imgo_addr;
+	bool wake_thread = 0;
+#ifdef ISP7_1
+	unsigned int imgo_addr_msb;
+	unsigned int tg_sen_mode, dcif_set, tg_vf_con, tg_path_cfg;
+#endif
+
+	irq_status	= readl_relaxed(camsv_dev->base + REG_CAMSV_INT_STATUS);
+	dequeued_imgo_seq_no =
+		readl_relaxed(camsv_dev->base + REG_CAMSV_FRAME_SEQ_NO);
+	dequeued_imgo_seq_no_inner =
+		readl_relaxed(camsv_dev->base_inner + REG_CAMSV_FRAME_SEQ_NO);
+	fbc_imgo_status =
+		readl_relaxed(camsv_dev->base + REG_CAMSV_FBC_IMGO_CTL2);
+	imgo_addr =
+		readl_relaxed(camsv_dev->base + REG_CAMSV_IMGO_BASE_ADDR);
+#ifdef ISP7_1
+	imgo_addr_msb =
+		readl_relaxed(camsv_dev->base + REG_CAMSV_IMGO_BASE_ADDR_MSB);
+	tg_sen_mode =
+		readl_relaxed(camsv_dev->base_inner + REG_CAMSV_TG_SEN_MODE);
+	dcif_set =
+		readl_relaxed(camsv_dev->base_inner + REG_CAMSV_DCIF_SET);
+	tg_vf_con =
+		readl_relaxed(camsv_dev->base_inner + REG_CAMSV_TG_VF_CON);
+	tg_path_cfg =
+		readl_relaxed(camsv_dev->base_inner + REG_CAMSV_TG_PATH_CFG);
+#endif
+
+	err_status = irq_status & INT_ST_MASK_CAMSV_ERR;
+	imgo_err_status = irq_status & CAMSV_INT_DMA_ERR_ST;
+	imgo_overr_status = irq_status & CAMSV_INT_IMGO_OVERR_ST;
+	drop_status = irq_status & CAMSV_INT_IMGO_DROP_ST;
+
+	dev_info(dev,
+		"%i status:0x%x(err:0x%x) drop:0x%x imgo_dma_err:0x%x_%x fbc:0x%x (imgo:0x%x) ",
+		camsv_dev->id,
+		irq_status, err_status,
+		drop_status, imgo_err_status, imgo_overr_status,
+		fbc_imgo_status, imgo_addr);
+
+#ifdef ISP7_1
+	dev_info(dev,
+		"imgo_msb:0x%x, in:%d tg_sen/dcif_set/tg_vf/tg_path:0x%x_%x_%x_%x\n",
+		imgo_addr_msb, dequeued_imgo_seq_no_inner,
+		tg_sen_mode, dcif_set, tg_vf_con, tg_path_cfg);
+#endif
+	/*
+	 * In normal case, the next SOF ISR should come after HW PASS1 DONE ISR.
+	 * If these two ISRs come together, print warning msg to hint.
+	 */
+	irq_info.ts_ns = ktime_get_boottime_ns();
+	irq_info.frame_idx = dequeued_imgo_seq_no;
+	irq_info.frame_idx_inner = dequeued_imgo_seq_no_inner;
+	irq_info.irq_type = 0;
+	irq_info.sub_engine = 0;
+	if ((irq_status & CAMSV_INT_TG_SOF_INT_ST) &&
+		(irq_status & CAMSV_INT_PASS1_DON_ST))
+		dev_dbg(dev, "sof_done block cnt:%d\n", camsv_dev->sof_count);
+	/* Frame done */
+	if (irq_status & CAMSV_INT_SW_PASS1_DON_ST)
+		irq_info.irq_type |= (1 << CAMSYS_IRQ_FRAME_DONE);
+	/* Frame start */
+	if (irq_status & CAMSV_INT_TG_SOF_INT_ST) {
+		irq_info.irq_type |= (1 << CAMSYS_IRQ_FRAME_START);
+		camsv_dev->sof_count++;
+	}
+
+	if (irq_info.irq_type && push_msgfifo(camsv_dev, &irq_info) == 0)
+		wake_thread = 1;
+
+	/* Check ISP error status */
+	if (err_status) {
+		struct mtk_camsys_irq_info err_info;
+
+		err_info.irq_type = CAMSYS_IRQ_ERROR;
+		err_info.ts_ns = irq_info.ts_ns;
+		err_info.frame_idx = irq_info.frame_idx;
+		err_info.frame_idx_inner = irq_info.frame_idx_inner;
+		err_info.e.err_status = err_status;
+
+		if (push_msgfifo(camsv_dev, &err_info) == 0)
+			wake_thread = 1;
+	}
+
+	return wake_thread ? IRQ_WAKE_THREAD : IRQ_HANDLED;
+}
+
+static irqreturn_t mtk_thread_irq_camsv(int irq, void *data)
+{
+	struct mtk_camsv_device *camsv_dev = (struct mtk_camsv_device *)data;
+	struct mtk_camsys_irq_info irq_info;
+
+	if (unlikely(atomic_cmpxchg(&camsv_dev->is_fifo_overflow, 1, 0)))
+		dev_info(camsv_dev->dev, "msg fifo overflow\n");
+
+	while (kfifo_len(&camsv_dev->msg_fifo) >= sizeof(irq_info)) {
+		int len = kfifo_out(&camsv_dev->msg_fifo, &irq_info, sizeof(irq_info));
+
+		WARN_ON(len != sizeof(irq_info));
+
+		/* error case */
+		if (unlikely(irq_info.irq_type == CAMSYS_IRQ_ERROR)) {
+			camsv_handle_err(camsv_dev, &irq_info);
+			continue;
+		}
+
+		/* normal case */
+
+		/* inform interrupt information to camsys controller */
+		mtk_camsys_isr_event(camsv_dev->cam,
+				     CAMSYS_ENGINE_CAMSV, camsv_dev->id,
+				     &irq_info);
+	}
+
+	return IRQ_HANDLED;
+}
+
+bool
+mtk_cam_sv_finish_buf(struct mtk_cam_request_stream_data *req_stream_data)
+{
+	bool result = false;
+	struct mtk_camsv_working_buf_entry *sv_buf_entry, *sv_buf_entry_prev;
+	struct mtk_cam_ctx *ctx = req_stream_data->ctx;
+	int i;
+
+	if (!ctx->used_sv_num)
+		return false;
+
+	for (i = 0; i < ctx->used_sv_num; i++) {
+		spin_lock(&ctx->sv_processing_buffer_list[i].lock);
+		list_for_each_entry_safe(sv_buf_entry, sv_buf_entry_prev,
+					 &ctx->sv_processing_buffer_list[i].list,
+					 list_entry) {
+			if (sv_buf_entry->s_data->frame_seq_no ==
+				req_stream_data->frame_seq_no) {
+				list_del(&sv_buf_entry->list_entry);
+				mtk_cam_sv_wbuf_set_s_data(sv_buf_entry, NULL);
+				mtk_cam_sv_working_buf_put(sv_buf_entry);
+				ctx->sv_processing_buffer_list[i].cnt--;
+				result = true;
+				break;
+			}
+		}
+		spin_unlock(&ctx->sv_processing_buffer_list[i].lock);
+	}
+
+	return result;
+}
+static int mtk_camsv_pm_suspend(struct device *dev)
+{
+	struct mtk_camsv_device *camsv_dev = dev_get_drvdata(dev);
+	u32 val;
+	int ret;
+
+	dev_dbg(dev, "- %s\n", __func__);
+
+	if (pm_runtime_suspended(dev))
+		return 0;
+
+	/* Disable ISP's view finder and wait for TG idle */
+	dev_dbg(dev, "camsv suspend, disable VF\n");
+	val = readl(camsv_dev->base + REG_CAMSV_TG_VF_CON);
+	writel(val & (~CAMSV_TG_VF_CON_VFDATA_EN),
+		camsv_dev->base + REG_CAMSV_TG_VF_CON);
+	ret = readl_poll_timeout_atomic(
+					camsv_dev->base + REG_CAMSV_TG_INTER_ST, val,
+					(val & CAMSV_TG_CS_MASK) == CAMSV_TG_IDLE_ST,
+					USEC_PER_MSEC, MTK_CAMSV_STOP_HW_TIMEOUT);
+	if (ret)
+		dev_dbg(dev, "can't stop HW:%d:0x%x\n", ret, val);
+
+	/* Disable CMOS */
+	val = readl(camsv_dev->base + REG_CAMSV_TG_SEN_MODE);
+	writel(val & (~CAMSV_TG_SEN_MODE_CMOS_EN),
+		camsv_dev->base + REG_CAMSV_TG_SEN_MODE);
+
+	/* Force ISP HW to idle */
+	ret = pm_runtime_put_sync(dev);
+	return ret;
+}
+
+static int mtk_camsv_pm_resume(struct device *dev)
+{
+	struct mtk_camsv_device *camsv_dev = dev_get_drvdata(dev);
+	u32 val;
+	int ret;
+
+	dev_dbg(dev, "- %s\n", __func__);
+
+	if (pm_runtime_suspended(dev))
+		return 0;
+
+	/* Force ISP HW to resume */
+	ret = pm_runtime_get_sync(dev);
+	if (ret)
+		return ret;
+
+	/* Enable CMOS */
+	dev_dbg(dev, "camsv resume, enable CMOS/VF\n");
+	val = readl(camsv_dev->base + REG_CAMSV_TG_SEN_MODE);
+	writel(val | CAMSV_TG_SEN_MODE_CMOS_EN,
+		camsv_dev->base + REG_CAMSV_TG_SEN_MODE);
+
+	/* Enable VF */
+	val = readl(camsv_dev->base + REG_CAMSV_TG_VF_CON);
+	writel(val | CAMSV_TG_VF_CON_VFDATA_EN,
+		camsv_dev->base + REG_CAMSV_TG_VF_CON);
+
+	return 0;
+}
+
+static int mtk_camsv_suspend_pm_event(struct notifier_block *notifier,
+			unsigned long pm_event, void *unused)
+{
+	struct mtk_camsv_device *camsv_dev =
+		container_of(notifier, struct mtk_camsv_device, notifier_blk);
+	struct device *dev = camsv_dev->dev;
+
+	switch (pm_event) {
+	case PM_HIBERNATION_PREPARE:
+		return NOTIFY_DONE;
+	case PM_RESTORE_PREPARE:
+		return NOTIFY_DONE;
+	case PM_POST_HIBERNATION:
+		return NOTIFY_DONE;
+	case PM_SUSPEND_PREPARE: /* before enter suspend */
+		mtk_camsv_pm_suspend(dev);
+		return NOTIFY_DONE;
+	case PM_POST_SUSPEND: /* after resume */
+		mtk_camsv_pm_resume(dev);
+		return NOTIFY_DONE;
+	}
+	return NOTIFY_OK;
+}
+
+static int mtk_camsv_of_probe(struct platform_device *pdev,
+			    struct mtk_camsv_device *sv)
+{
+	struct device *dev = &pdev->dev;
+	struct resource *res;
+	unsigned int i;
+	int clks, ret;
+
+	ret = of_property_read_u32(dev->of_node, "mediatek,camsv-id",
+						       &sv->id);
+	if (ret) {
+		dev_dbg(dev, "missing camid property\n");
+		return ret;
+	}
+
+	ret = of_property_read_u32(dev->of_node, "mediatek,camsv-hwcap",
+						       &sv->hw_cap);
+	sv->hw_cap |= (1 << MTKCAM_SV_SPECIAL_SCENARIO_ADDITIONAL_RAW);
+	if (ret) {
+		dev_dbg(dev, "missing hardware capability property\n");
+		return ret;
+	}
+
+	ret = of_property_read_u32(dev->of_node, "mediatek,cammux-id",
+						       &sv->cammux_id);
+	if (ret) {
+		dev_dbg(dev, "missing cammux id property\n");
+		return ret;
+	}
+
+	/* base outer register */
+	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "base");
+	if (!res) {
+		dev_info(dev, "failed to get mem\n");
+		return -ENODEV;
+	}
+
+	sv->base = devm_ioremap_resource(dev, res);
+	if (IS_ERR(sv->base)) {
+		dev_dbg(dev, "failed to map register base\n");
+		return PTR_ERR(sv->base);
+	}
+	dev_dbg(dev, "camsv, map_addr=0x%pK\n", sv->base);
+
+	/* base inner register */
+	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "inner_base");
+	if (!res) {
+		dev_dbg(dev, "failed to get mem\n");
+		return -ENODEV;
+	}
+
+	sv->base_inner = devm_ioremap_resource(dev, res);
+	if (IS_ERR(sv->base_inner)) {
+		dev_dbg(dev, "failed to map register inner base\n");
+		return PTR_ERR(sv->base_inner);
+	}
+	dev_dbg(dev, "camsv, map_addr(inner)=0x%pK\n", sv->base_inner);
+
+	sv->irq = platform_get_irq(pdev, 0);
+	if (!sv->irq) {
+		dev_dbg(dev, "failed to get irq\n");
+		return -ENODEV;
+	}
+
+	ret = devm_request_threaded_irq(dev, sv->irq,
+					mtk_irq_camsv,
+					mtk_thread_irq_camsv,
+					0, dev_name(dev), sv);
+	if (ret) {
+		dev_dbg(dev, "failed to request irq=%d\n", sv->irq);
+		return ret;
+	}
+	dev_dbg(dev, "registered irq=%d\n", sv->irq);
+
+	disable_irq(sv->irq);
+
+	clks  = of_count_phandle_with_args(pdev->dev.of_node, "clocks",
+			"#clock-cells");
+
+	sv->num_clks = (clks == -ENOENT) ? 0:clks;
+	dev_info(dev, "clk_num:%d\n", sv->num_clks);
+
+	if (sv->num_clks) {
+		sv->clks = devm_kcalloc(dev, sv->num_clks, sizeof(*sv->clks),
+					 GFP_KERNEL);
+		if (!sv->clks)
+			return -ENOMEM;
+	}
+
+	for (i = 0; i < sv->num_clks; i++) {
+		sv->clks[i] = of_clk_get(pdev->dev.of_node, i);
+		if (IS_ERR(sv->clks[i])) {
+			dev_info(dev, "failed to get clk %d\n", i);
+			return -ENODEV;
+		}
+	}
+
+	sv->notifier_blk.notifier_call = mtk_camsv_suspend_pm_event;
+	sv->notifier_blk.priority = 0;
+	ret = register_pm_notifier(&sv->notifier_blk);
+	if (ret) {
+		dev_info(dev, "Failed to register PM notifier");
+		return -ENODEV;
+	}
+
+	return 0;
+}
+
+static int mtk_camsv_component_bind(
+	struct device *dev,
+	struct device *master,
+	void *data)
+{
+	struct mtk_camsv_device *camsv_dev = dev_get_drvdata(dev);
+	struct mtk_cam_device *cam_dev = data;
+	struct mtk_camsv *sv = &cam_dev->sv;
+
+	dev_info(dev, "%s: id=%d\n", __func__, camsv_dev->id);
+
+	camsv_dev->cam = cam_dev;
+	sv->devs[camsv_dev->id] = dev;
+	sv->cam_dev = cam_dev->dev;
+
+	return 0;
+}
+
+static void mtk_camsv_component_unbind(
+	struct device *dev,
+	struct device *master,
+	void *data)
+{
+	struct mtk_camsv_device *camsv_dev = dev_get_drvdata(dev);
+	struct mtk_cam_device *cam_dev = data;
+	struct mtk_camsv *sv = &cam_dev->sv;
+
+	dev_info(dev, "%s\n", __func__);
+
+	camsv_dev->cam = NULL;
+	camsv_dev->pipeline = NULL;
+	sv->devs[camsv_dev->id] = NULL;
+}
+
+
+static const struct component_ops mtk_camsv_component_ops = {
+	.bind = mtk_camsv_component_bind,
+	.unbind = mtk_camsv_component_unbind,
+};
+
+#ifdef CONFIG_MTK_IOMMU_V2
+static inline int m4u_control_camsv_iommu_port(void)
+{
+	struct M4U_PORT_STRUCT sPort;
+	int use_m4u = 1;
+	int ret = 0;
+	int i = 0;
+
+	for (i = 0; i < LARB13_PORT_SIZE; i++) {
+		sPort.ePortID = M4U_PORT_L13_CAM_MRAWI_MDP + i;
+		sPort.Virtuality = use_m4u;
+		sPort.Security = 0;
+		sPort.domain = 2;
+		sPort.Distance = 1;
+		sPort.Direction = 0;
+		ret = m4u_config_port(&sPort);
+		if (ret) {
+			pr_debug("config M4U Port %s to %s FAIL(ret=%d)\n",
+				iommu_get_port_name(
+					M4U_PORT_L13_CAM_MRAWI_MDP + i),
+				use_m4u ? "virtual" : "physical", ret);
+			ret = -1;
+		}
+	}
+
+	for (i = 0; i < LARB14_PORT_SIZE; i++) {
+		sPort.ePortID = M4U_PORT_L14_CAM_MRAWI_DISP + i;
+		sPort.Virtuality = use_m4u;
+		sPort.Security = 0;
+		sPort.domain = 2;
+		sPort.Distance = 1;
+		sPort.Direction = 0;
+		ret = m4u_config_port(&sPort);
+		if (ret) {
+			pr_debug("config M4U Port %s to %s FAIL(ret=%d)\n",
+				iommu_get_port_name(
+					M4U_PORT_L14_CAM_MRAWI_DISP + i),
+				use_m4u ? "virtual" : "physical", ret);
+			ret = -1;
+		}
+	}
+
+	return ret;
+}
+#endif
+
+static int mtk_camsv_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct mtk_camsv_device *camsv_dev;
+	int ret;
+
+	dev_info(dev, "%s\n", __func__);
+
+	camsv_dev = devm_kzalloc(dev, sizeof(*camsv_dev), GFP_KERNEL);
+	if (!camsv_dev)
+		return -ENOMEM;
+
+	camsv_dev->dev = dev;
+	dev_set_drvdata(dev, camsv_dev);
+
+	ret = mtk_camsv_of_probe(pdev, camsv_dev);
+	if (ret)
+		return ret;
+
+#ifdef ISP7_1
+#else //MT8195
+	pm_runtime_set_autosuspend_delay(dev, 2 * MTK_CAMSV_STOP_HW_TIMEOUT);
+	pm_runtime_use_autosuspend(dev);
+#endif
+
+	camsv_dev->fifo_size =
+		roundup_pow_of_two(8 * sizeof(struct mtk_camsys_irq_info));
+	camsv_dev->msg_buffer = devm_kzalloc(dev, camsv_dev->fifo_size,
+					     GFP_KERNEL);
+	if (!camsv_dev->msg_buffer)
+		return -ENOMEM;
+
+	pm_runtime_enable(dev);
+
+	return component_add(dev, &mtk_camsv_component_ops);
+}
+
+static int mtk_camsv_remove(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+
+	dev_info(dev, "%s\n", __func__);
+
+	pm_runtime_disable(dev);
+
+	component_del(dev, &mtk_camsv_component_ops);
+	return 0;
+}
+
+static int mtk_camsv_runtime_suspend(struct device *dev)
+{
+	struct mtk_camsv_device *camsv_dev = dev_get_drvdata(dev);
+	int i;
+
+	dev_dbg(dev, "%s:disable clock\n", __func__);
+
+	for (i = 0; i < camsv_dev->num_clks; i++)
+		clk_disable_unprepare(camsv_dev->clks[i]);
+
+	disable_irq(camsv_dev->irq);
+
+	return 0;
+}
+
+static int mtk_camsv_runtime_resume(struct device *dev)
+{
+	struct mtk_camsv_device *camsv_dev = dev_get_drvdata(dev);
+	int i, ret;
+
+	/* reset_msgfifo before enable_irq */
+	ret = reset_msgfifo(camsv_dev);
+	if (ret)
+		return ret;
+
+	enable_irq(camsv_dev->irq);
+
+	dev_dbg(dev, "%s:enable clock\n", __func__);
+
+	for (i = 0; i < camsv_dev->num_clks; i++) {
+		ret = clk_prepare_enable(camsv_dev->clks[i]);
+		if (ret) {
+			dev_info(dev, "enable failed at clk #%d, ret = %d\n",
+				 i, ret);
+			i--;
+			while (i >= 0)
+				clk_disable_unprepare(camsv_dev->clks[i--]);
+
+			return ret;
+		}
+	}
+	sv_reset(camsv_dev);
+
+	return 0;
+}
+
+static const struct dev_pm_ops mtk_camsv_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(mtk_camsv_pm_suspend, mtk_camsv_pm_resume)
+	SET_RUNTIME_PM_OPS(mtk_camsv_runtime_suspend, mtk_camsv_runtime_resume,
+			   NULL)
+};
+
+struct platform_driver mtk_cam_sv_driver = {
+	.probe   = mtk_camsv_probe,
+	.remove  = mtk_camsv_remove,
+	.driver  = {
+		.name  = "mtk-cam camsv",
+		.of_match_table = of_match_ptr(mtk_camsv_of_ids),
+		.pm     = &mtk_camsv_pm_ops,
+	}
+};
+
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam-sv.h b/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam-sv.h
new file mode 100644
index 0000000000000000000000000000000000000000..4943395d8e4515e2b0dbf4d671bae74159c45ef3
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam-sv.h
@@ -0,0 +1,343 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2022 MediaTek Inc.
+ */
+
+#ifndef __MTK_CAM_SV_H
+#define __MTK_CAM_SV_H
+
+#include <linux/kfifo.h>
+#include <linux/suspend.h>
+
+#include "mtk_cam-video.h"
+
+#ifdef ISP7_1
+#define CAMSV_PIPELINE_NUM 8
+#else //mt8195
+#define CAMSV_PIPELINE_NUM 6
+#endif
+
+#define SV_IMG_MAX_WIDTH		8192
+#define SV_IMG_MAX_HEIGHT		6144
+#define SV_IMG_MIN_WIDTH		0
+#define SV_IMG_MIN_HEIGHT		0
+
+/* camsv hardware capability definition: */
+/* [15:0]: hardware scenario             */
+/* [19:16]: group number                 */
+/* [23:20]: exposure order               */
+#define CAMSV_GROUP_SHIFT 16
+#define CAMSV_EXP_ORDER_SHIFT 20
+#define CAMSV_GROUP_AMOUNT 4
+
+enum mtkcam_sv_hw_path_control {
+	MTKCAM_SV_SPECIAL_SCENARIO_ADDITIONAL_RAW = MTKCAM_IPI_HW_PATH_OFFLINE_M2M + 2,
+};
+
+#define MTK_CAMSV_SUPPORTED_SPECIAL_HW_SCENARIO	(\
+			(1 << MTKCAM_SV_SPECIAL_SCENARIO_ADDITIONAL_RAW) |\
+			(1 << MTKCAM_IPI_HW_PATH_ON_THE_FLY_DCIF_STAGGER) |\
+			(1 << MTKCAM_IPI_HW_PATH_OFFLINE_SRT_DCIF_STAGGER) |\
+			(1 << MTKCAM_IPI_HW_PATH_OFFLINE_STAGGER) |\
+			(1 << MTKCAM_IPI_HW_PATH_OFFLINE_M2M))
+#define MTK_CAMSV_SUPPORTED_STAGGER_SCENARIO	(\
+			(1 << MTKCAM_IPI_HW_PATH_ON_THE_FLY_DCIF_STAGGER) |\
+			(1 << MTKCAM_IPI_HW_PATH_OFFLINE_SRT_DCIF_STAGGER) |\
+			(1 << MTKCAM_IPI_HW_PATH_OFFLINE_STAGGER))
+
+#define CAMSV_WRITE_BITS(RegAddr, RegName, FieldName, FieldValue) do {\
+	union RegName reg;\
+	\
+	reg.Raw = readl_relaxed(RegAddr);\
+	reg.Bits.FieldName = FieldValue;\
+	writel_relaxed(reg.Raw, RegAddr);\
+} while (0)
+
+#define CAMSV_WRITE_REG(RegAddr, RegValue) ({\
+	writel_relaxed(RegValue, RegAddr);\
+})
+
+#define CAMSV_READ_BITS(RegAddr, RegName, FieldName) ({\
+	union RegName reg;\
+	\
+	reg.Raw = readl_relaxed(RegAddr);\
+	reg.Bits.FieldName;\
+})
+
+#define CAMSV_READ_REG(RegAddr) ({\
+	unsigned int var;\
+	\
+	var = readl_relaxed(RegAddr);\
+	var;\
+})
+
+#define CAMSV_MAX_PIPE_USED 4
+
+struct mtk_cam_ctx;
+struct mtk_cam_request;
+struct mtk_cam_request_stream_data;
+
+enum camsv_module_id {
+	CAMSV_START = 0,
+	CAMSV_0 = CAMSV_START,
+	CAMSV_1 = 1,
+	CAMSV_2 = 2,
+	CAMSV_3 = 3,
+	CAMSV_4 = 4,
+	CAMSV_5 = 5,
+#ifdef ISP7_1
+	CAMSV_6 = 6,
+	CAMSV_7 = 7,
+#ifdef FULL_CAM_SUBDEV
+	CAMSV_8 = 8,
+	CAMSV_9 = 9,
+	CAMSV_10 = 10,
+	CAMSV_11 = 11,
+	CAMSV_12 = 12,
+	CAMSV_13 = 13,
+	CAMSV_14 = 14,
+	CAMSV_15 = 15,
+#endif //FULL_CAM_SUBDEV
+#endif //ISP7_1
+	CAMSV_END
+};
+
+enum camsv_db_load_src {
+	SV_DB_SRC_SUB_P1_DONE = 0,
+	SV_DB_SRC_SOF         = 1,
+	SV_DB_SRC_SUB_SOF     = 2,
+};
+
+enum camsv_int_en {
+	SV_INT_EN_VS1_INT_EN               = (1L<<0),
+	SV_INT_EN_TG_INT1_EN               = (1L<<1),
+	SV_INT_EN_TG_INT2_EN               = (1L<<2),
+	SV_INT_EN_EXPDON1_INT_EN           = (1L<<3),
+	SV_INT_EN_TG_ERR_INT_EN            = (1L<<4),
+	SV_INT_EN_TG_GBERR_INT_EN          = (1L<<5),
+	SV_INT_EN_TG_SOF_INT_EN            = (1L<<6),
+	SV_INT_EN_TG_WAIT_INT_EN           = (1L<<7),
+	SV_INT_EN_TG_DROP_INT_EN           = (1L<<8),
+	SV_INT_EN_VS_INT_ORG_EN            = (1L<<9),
+	SV_INT_EN_DB_LOAD_ERR_EN           = (1L<<10),
+	SV_INT_EN_PASS1_DON_INT_EN         = (1L<<11),
+	SV_INT_EN_SW_PASS1_DON_INT_EN      = (1L<<12),
+	SV_INT_EN_SUB_PASS1_DON_INT_EN     = (1L<<13),
+	SV_INT_EN_UFEO_OVERR_INT_EN        = (1L<<15),
+	SV_INT_EN_DMA_ERR_INT_EN           = (1L<<16),
+	SV_INT_EN_IMGO_OVERR_INT_EN        = (1L<<17),
+	SV_INT_EN_UFEO_DROP_INT_EN         = (1L<<18),
+	SV_INT_EN_IMGO_DROP_INT_EN         = (1L<<19),
+	SV_INT_EN_IMGO_DONE_INT_EN         = (1L<<20),
+	SV_INT_EN_UFEO_DONE_INT_EN         = (1L<<21),
+	SV_INT_EN_TG_INT3_EN               = (1L<<22),
+	SV_INT_EN_TG_INT4_EN               = (1L<<23),
+	SV_INT_EN_INT_WCLR_EN              = (1L<<31),
+};
+
+enum camsv_tg_fmt {
+	SV_TG_FMT_RAW8      = 0,
+	SV_TG_FMT_RAW10     = 1,
+	SV_TG_FMT_RAW12     = 2,
+	SV_TG_FMT_YUV422    = 3,
+	SV_TG_FMT_RAW14     = 4,
+	SV_TG_FMT_RSV1      = 5,
+	SV_TG_FMT_RSV2      = 6,
+	SV_TG_FMT_JPG       = 7,
+};
+
+enum camsv_tg_swap {
+	TG_SW_UYVY = 0,
+	TG_SW_YUYV = 1,
+	TG_SW_VYUY = 2,
+	TG_SW_YVYU = 3,
+};
+
+/* enum for pads of camsv pipeline */
+enum {
+	MTK_CAMSV_SINK_BEGIN = 0,
+	MTK_CAMSV_SINK = MTK_CAMSV_SINK_BEGIN,
+	MTK_CAMSV_SINK_NUM,
+
+	MTK_CAMSV_SOURCE_BEGIN = MTK_CAMSV_SINK_NUM,
+	MTK_CAMSV_MAIN_STREAM_OUT = MTK_CAMSV_SOURCE_BEGIN,
+	MTK_CAMSV_PIPELINE_PADS_NUM,
+};
+
+#define MTK_CAMSV_TOTAL_NODES (MTK_CAMSV_PIPELINE_PADS_NUM - MTK_CAMSV_SINK_NUM)
+
+struct mtk_camsv_pad_config {
+	struct v4l2_mbus_framefmt mbus_fmt;
+};
+
+struct mtk_camsv_pipeline {
+	unsigned int id;
+	struct v4l2_subdev subdev;
+	struct media_pad pads[MTK_CAMSV_PIPELINE_PADS_NUM];
+	struct mtk_cam_video_device vdev_nodes[MTK_CAMSV_TOTAL_NODES];
+	struct mtk_camsv *sv;
+	struct mtk_camsv_pad_config cfg[MTK_CAMSV_PIPELINE_PADS_NUM];
+
+	/* cached settings */
+	unsigned int enabled_sv;
+	unsigned int enabled_dmas;
+
+	/* seninf pad index */
+	u32 seninf_padidx;
+
+	/* special hardware scenario */
+	unsigned int hw_cap;
+	unsigned int cammux_id;
+	unsigned int hw_scen;
+	unsigned int main_pipe_id;
+	unsigned int exp_order;
+	unsigned int is_occupied;
+};
+
+struct mtk_camsv_device {
+	struct device *dev;
+	struct mtk_cam_device *cam;
+	unsigned int id;
+	int irq;
+	void __iomem *base;
+	void __iomem *base_inner;
+	unsigned int num_clks;
+	struct clk **clks;
+	struct mtk_camsv_pipeline *pipeline;
+	unsigned int hw_cap;
+	unsigned int cammux_id;
+
+	int fifo_size;
+	void *msg_buffer;
+	struct kfifo msg_fifo;
+	atomic_t is_fifo_overflow;
+
+	unsigned int sof_count;
+	unsigned int frame_wait_to_process;
+	struct notifier_block notifier_blk;
+	unsigned int is_enqueued;
+};
+
+struct mtk_camsv {
+	struct device *cam_dev;
+	struct device *devs[CAMSV_PIPELINE_NUM];
+	struct mtk_camsv_pipeline pipelines[CAMSV_PIPELINE_NUM];
+};
+
+struct mtk_camsv_reconfig_info {
+	u32 grab_pxl;
+	u32 grab_lin;
+	u32 fmt_sel;
+	u32 pak;
+	u32 imgo_xsize;
+	u32 imgo_ysize;
+	u32 imgo_stride;
+};
+
+struct mtk_camsv_frame_params {
+	u8 is_reconfig;
+	struct mtk_camsv_reconfig_info cfg_info;
+	struct mtkcam_ipi_img_output img_out;
+};
+
+static inline bool mtk_camsv_is_sv_pipe(int pipe_id)
+{
+	return (pipe_id >= MTKCAM_SUBDEV_CAMSV_START) &&
+		(pipe_id < MTKCAM_SUBDEV_CAMSV_END);
+}
+
+static inline bool mtk_camsv_is_yuv_format(unsigned int fmt)
+{
+	bool ret = false;
+
+	switch (fmt) {
+	case V4L2_PIX_FMT_YUYV:
+	case V4L2_PIX_FMT_YVYU:
+	case V4L2_PIX_FMT_UYVY:
+	case V4L2_PIX_FMT_VYUY:
+		ret = true;
+		break;
+	default:
+		ret = false;
+		break;
+	}
+
+	return ret;
+}
+
+struct mtk_larb;
+int mtk_camsv_setup_dependencies(struct mtk_camsv *sv, struct mtk_larb *larb);
+int mtk_camsv_register_entities(
+	struct mtk_camsv *sv, struct v4l2_device *v4l2_dev);
+void mtk_camsv_unregister_entities(struct mtk_camsv *sv);
+int mtk_camsv_call_pending_set_fmt(struct v4l2_subdev *sd,
+				 struct v4l2_subdev_format *fmt);
+int mtk_cam_sv_select(
+	struct mtk_camsv_pipeline *pipe,
+	struct mtkcam_ipi_input_param *cfg_in_param);
+void sv_reset(struct mtk_camsv_device *dev);
+int mtk_cam_sv_pipeline_config(
+	struct mtk_cam_ctx *ctx, unsigned int idx,
+	struct mtkcam_ipi_input_param *cfg_in_param);
+struct device *mtk_cam_find_sv_dev(
+	struct mtk_cam_device *cam, unsigned int sv_mask);
+int mtk_cam_sv_dev_config(
+	struct mtk_cam_ctx *ctx, unsigned int idx, unsigned int hw_scen,
+	unsigned int exp_order);
+int mtk_cam_sv_dev_stream_on(
+	struct mtk_cam_ctx *ctx, unsigned int idx,
+	unsigned int streaming, unsigned int hw_scen);
+unsigned int mtk_cam_sv_format_sel(unsigned int pixel_fmt);
+unsigned int mtk_cam_sv_pak_sel(unsigned int tg_fmt,
+	unsigned int pixel_mode);
+unsigned int mtk_cam_sv_xsize_cal(
+	struct mtkcam_ipi_input_param *cfg_in_param);
+int mtk_cam_sv_tg_config(
+	struct mtk_camsv_device *dev, struct mtkcam_ipi_input_param *cfg_in_param);
+int mtk_cam_sv_top_config(
+	struct mtk_camsv_device *dev, struct mtkcam_ipi_input_param *cfg_in_param);
+int mtk_cam_sv_dmao_config(
+	struct mtk_camsv_device *top_dev, struct mtk_camsv_device *sub_dev,
+	struct mtkcam_ipi_input_param *cfg_in_param,
+	int hw_scen, int raw_imgo_stride);
+int mtk_cam_sv_fbc_config(
+	struct mtk_camsv_device *dev, struct mtkcam_ipi_input_param *cfg_in_param);
+
+int mtk_cam_sv_tg_enable(
+	struct mtk_camsv_device *dev, struct mtkcam_ipi_input_param *cfg_in_param);
+int mtk_cam_sv_toggle_tg_db(struct mtk_camsv_device *dev);
+int mtk_cam_sv_toggle_db(struct mtk_camsv_device *dev);
+int mtk_cam_sv_top_enable(struct mtk_camsv_device *dev);
+int mtk_cam_sv_dmao_enable(
+	struct mtk_camsv_device *dev, struct mtkcam_ipi_input_param *cfg_in_param);
+int mtk_cam_sv_fbc_enable(
+	struct mtk_camsv_device *dev, struct mtkcam_ipi_input_param *cfg_in_param);
+
+int mtk_cam_sv_tg_disable(struct mtk_camsv_device *dev);
+int mtk_cam_sv_top_disable(struct mtk_camsv_device *dev);
+int mtk_cam_sv_dmao_disable(struct mtk_camsv_device *dev);
+int mtk_cam_sv_fbc_disable(struct mtk_camsv_device *dev);
+int mtk_cam_sv_vf_on(struct mtk_camsv_device *dev, unsigned int is_on);
+int mtk_cam_sv_is_vf_on(struct mtk_camsv_device *dev);
+int mtk_cam_sv_enquehwbuf(struct mtk_camsv_device *dev, dma_addr_t ba,
+	unsigned int seq_no);
+bool mtk_cam_sv_finish_buf(struct mtk_cam_request_stream_data *s_data);
+int mtk_cam_find_sv_dev_index(struct mtk_cam_ctx *ctx, unsigned int idx);
+int mtk_cam_sv_apply_all_buffers(struct mtk_cam_ctx *ctx, u64 ts_ns);
+int mtk_cam_sv_apply_next_buffer(struct mtk_cam_ctx *ctx,
+	unsigned int pipe_id, u64 ts_ns);
+int mtk_cam_sv_rgbw_apply_next_buffer(
+	struct mtk_cam_request_stream_data *s_data);
+int mtk_cam_sv_apply_switch_buffers(struct mtk_cam_ctx *ctx);
+int mtk_cam_sv_write_rcnt(struct mtk_cam_ctx *ctx, unsigned int pipe_id);
+int mtk_cam_sv_cal_cfg_info(struct mtk_cam_ctx *ctx,
+	const struct v4l2_format *img_fmt, struct mtk_camsv_frame_params *params);
+int mtk_cam_sv_setup_cfg_info(struct mtk_camsv_device *dev,
+	struct mtk_cam_request_stream_data *s_data);
+#ifdef CAMSYS_TF_DUMP_71_1
+int mtk_camsv_translation_fault_callback(int port, dma_addr_t mva, void *data);
+#endif
+
+extern struct platform_driver mtk_cam_sv_driver;
+
+#endif
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam-timesync.c b/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam-timesync.c
new file mode 100644
index 0000000000000000000000000000000000000000..8565de96759f4d74c620aa19d58deed0d0e7b822
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam-timesync.c
@@ -0,0 +1,146 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2017 MediaTek Inc.
+ */
+
+#include <linux/module.h>
+#include <asm/arch_timer.h>
+#include <linux/init.h>
+#include <linux/timer.h>
+#include <linux/workqueue.h>
+#include <linux/spinlock.h>
+#include <linux/math64.h>
+
+#include "mtk_cam-timesync.h"
+
+#define FILTER_DATAPOINTS	16
+#define FILTER_FREQ		10000000ULL /* 10 ms */
+
+struct moving_average {
+	uint64_t last_time;
+	int64_t input[FILTER_DATAPOINTS];
+	int64_t output;
+	uint8_t cnt;
+	uint8_t tail;
+};
+
+static struct moving_average moving_average_algo_mono;
+static struct moving_average moving_average_algo_boot;
+static DEFINE_SPINLOCK(moving_average_lock);
+
+/* arch counter is 13M, mult is 161319385, shift is 21 */
+static uint64_t arch_counter_to_ns(uint64_t cyc)
+{
+	u64 num, max = ULLONG_MAX;
+	u32 mult = 161319385;
+	u32 shift = 21;
+	s64 nsec = 0;
+
+	do_div(max, mult);
+	if (cyc > max) {
+		num = div64_u64(cyc, max);
+		nsec = (((u64) max * mult) >> shift) * num;
+		cyc -= num * max;
+	}
+	nsec += ((u64) cyc * mult) >> shift;
+	return nsec;
+}
+
+static void moving_average_filter(struct moving_average *filter,
+	uint64_t base_time, uint64_t archcounter_time)
+{
+	int i = 0;
+	int64_t avg = 0;
+	int64_t ret_avg = 0;
+
+	if (base_time < filter->last_time + FILTER_FREQ)
+		return;
+
+	filter->last_time = base_time;
+
+	filter->input[filter->tail++] = base_time - archcounter_time;
+	filter->tail &= (FILTER_DATAPOINTS - 1);
+	if (filter->cnt < FILTER_DATAPOINTS)
+		filter->cnt++;
+
+	for (i = 1, avg = 0; i < filter->cnt; i++)
+		avg += (filter->input[i] - filter->input[0]);
+	ret_avg = div_s64(avg, filter->cnt) + filter->input[0];
+	WRITE_ONCE(filter->output, ret_avg);
+}
+
+static uint64_t get_filter_output(struct moving_average *filter)
+{
+	return READ_ONCE(filter->output);
+}
+
+static void filter_algo_init(struct moving_average *filter)
+{
+	spin_lock(&moving_average_lock);
+	memset(filter, 0, sizeof(*filter));
+	spin_unlock(&moving_average_lock);
+}
+
+void mtk_cam_timesync_init(uint8_t status)
+{
+	if (status) {
+		filter_algo_init(&moving_average_algo_mono);
+		filter_algo_init(&moving_average_algo_boot);
+	}
+}
+
+u64 mtk_cam_get_time(u64 cyc)
+{
+	return arch_counter_to_ns(cyc);
+}
+
+uint64_t mtk_cam_timesync_to_monotonic(uint64_t hwclock)
+{
+	unsigned long flags = 0;
+	uint64_t base_time = 0;
+	uint64_t archcounter_time = 0;
+	uint64_t reslut_time = 0;
+
+	spin_lock(&moving_average_lock);
+
+	local_irq_save(flags);
+	base_time = ktime_to_ns(ktime_get());
+	archcounter_time =
+		arch_counter_to_ns(__arch_counter_get_cntvct_stable());
+	local_irq_restore(flags);
+
+	moving_average_filter(&moving_average_algo_mono,
+		base_time, archcounter_time);
+
+	reslut_time = arch_counter_to_ns(hwclock) +
+		get_filter_output(&moving_average_algo_mono);
+
+	spin_unlock(&moving_average_lock);
+	return reslut_time;
+}
+
+uint64_t mtk_cam_timesync_to_boot(uint64_t hwclock)
+{
+	unsigned long flags = 0;
+	uint64_t base_time = 0;
+	uint64_t archcounter_time = 0;
+	uint64_t reslut_time = 0;
+
+	spin_lock(&moving_average_lock);
+
+	local_irq_save(flags);
+	base_time = ktime_get_boottime_ns();
+	archcounter_time =
+		arch_counter_to_ns(__arch_counter_get_cntvct_stable());
+	local_irq_restore(flags);
+
+	moving_average_filter(&moving_average_algo_boot,
+		base_time, archcounter_time);
+
+	reslut_time = arch_counter_to_ns(hwclock) +
+		get_filter_output(&moving_average_algo_boot);
+
+	spin_unlock(&moving_average_lock);
+	return reslut_time;
+}
+
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam-timesync.h b/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam-timesync.h
new file mode 100644
index 0000000000000000000000000000000000000000..10d781d3c0f8682b9f4a4f5a5984847e8567da03
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam-timesync.h
@@ -0,0 +1,14 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2017 MediaTek Inc.
+ */
+
+#ifndef __ARCHCOUNTER_TIMESYNC__
+#define __ARCHCOUNTER_TIMESYNC__
+
+void mtk_cam_timesync_init(uint8_t status);
+uint64_t mtk_cam_timesync_to_monotonic(uint64_t hwclock);
+uint64_t mtk_cam_timesync_to_boot(uint64_t hwclock);
+u64 mtk_cam_get_time(u64 cyc);
+
+#endif
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam-ufbc-def.h b/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam-ufbc-def.h
new file mode 100644
index 0000000000000000000000000000000000000000..8294012dd55581d905336130ed1439a83f631f7d
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam-ufbc-def.h
@@ -0,0 +1,170 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2022 MediaTek Inc.
+ * Author: Hung-Wen Hsieh <hung-wen.hsieh@mediatek.com>
+ */
+
+#ifndef __UFBC_DEF_H__
+#define __UFBC_DEF_H__
+
+
+/**
+ * Describe Mediatek UFBC (Universal Frame Buffer Compression) buffer header.
+ * Mediatek UFBC supports 1 plane Bayer and 2 planes Y/UV image formats.
+ * Caller must follow the formulation to calculate the bit stream buffer size
+ * and length table buffer size.
+ *
+ * Header Size
+ *
+ * Fixed size of 4096 bytes. Reserved bytes will be used by Mediatek
+ * ISP driver. Caller SHOULD NOT edit it.
+ *
+ * Bit Stream Size
+ *
+ *  @code
+ *    // for each plane
+ *    size = ((width + 63) / 64) * 64;      // width must be aligned to 64 pixel
+ *    size = (size * bitsPerPixel + 7) / 8; // convert to bytes
+ *    size = size * height;
+ *  @endcode
+ *
+ * Table Size
+ *
+ *  @code
+ *    // for each plane
+ *    size = (width + 63) / 64;
+ *    size = size * height;
+ *  @endcode
+ *
+ * And the memory layout should be followed as
+ *
+ *  @code
+ *           Bayer                  YUV2P
+ *    +------------------+  +------------------+
+ *    |      Header      |  |      Header      |
+ *    +------------------+  +------------------+
+ *    |                  |  |     Y Plane      |
+ *    | Bayer Bit Stream |  |    Bit Stream    |
+ *    |                  |  |                  |
+ *    +------------------+  +------------------+
+ *    |   Length Table   |  |     UV Plane     |
+ *    +------------------+  |    Bit Stream    |
+ *                          |                  |
+ *                          +------------------+
+ *                          |     Y Plane      |
+ *                          |   Length Table   |
+ *                          +------------------+
+ *                          |     UV Plane     |
+ *                          |   Length Table   |
+ *                          +------------------+
+ *  @endcode
+ *
+ *  @note Caller has responsibility to fill all the fields according the
+ *        real buffer layout.
+ */
+
+struct UfbcBufHeader {
+	/** Describe image resolution, unit in pixel. */
+	uint32_t width;
+
+	/** Describe image resolution, unit in pixel. */
+	uint32_t height;
+
+	/** Describe UFBC data plane count, UFBC supports maximum 2 planes. */
+	uint32_t planeCount;
+
+	/** Describe the original image data bits per pixel of the given plane. */
+	uint32_t bitsPerPixel[3];
+
+	/**
+	 * Describe the offset of the given plane bit stream data in bytes,
+	 * including header size.
+	 */
+	uint32_t bitStreamOffset[3];
+
+	/** Describe the bit stream data size in bytes of the given plane. */
+	uint32_t bitStreamSize[3];
+
+	/** Describe the encoded data size in bytes of the given plane. */
+	uint32_t bitStreamDataSize[3];
+
+	/**
+	 * Describe the offset of length table of the given plane, including
+	 * header size.
+	 */
+	uint32_t tableOffset[3];
+
+	/** Describe the length table size of the given plane */
+	uint32_t tableSize[3];
+
+	/** Describe the total buffer size, including buffer header. */
+	uint32_t bufferSize;
+};
+
+
+struct UfbcBufferHeader {
+	union {
+		struct UfbcBufHeader header;
+		uint8_t reserved[4096];
+	};
+};
+
+struct IMG_META_INFO {
+	unsigned int Version;
+	unsigned int HeaderSize;
+	unsigned int BitStreamOffset[8];
+	unsigned int LengthTableOffset[8];
+};
+
+/******************************************************************************
+ * @UFBC format meta info
+ *
+ ******************************************************************************/
+struct UFD_META_INFO {
+	unsigned int bUF;
+	unsigned int UFD_BITSTREAM_OFST_ADDR[4];
+	unsigned int UFD_BS_AU_START[4];
+	unsigned int UFD_AU2_SIZE[4];
+	unsigned int UFD_BOND_MODE;
+};
+
+struct UFD_HW_META_INFO {
+	unsigned int Buf[32];
+};
+
+union UFDStruct {
+	struct UFD_META_INFO UFD;
+	struct UFD_HW_META_INFO HWUFD;
+};
+
+struct UFO_META_INFO {
+	struct UfbcBufHeader ImgInfo;
+	unsigned int AUWriteBySW;
+	union UFDStruct UFD;
+};
+
+
+struct YUFD_META_INFO {
+	unsigned int bYUF;
+	unsigned int YUFD_BITSTREAM_OFST_ADDR[4];
+	unsigned int YUFD_BS_AU_START[4];
+	unsigned int YUFD_AU2_SIZE[4];
+	unsigned int YUFD_BOND_MODE;
+};
+
+struct YUFD_HW_META_INFO {
+	unsigned int Buf[32];
+};
+
+union YUFDStruct {
+	struct YUFD_META_INFO YUFD;
+	struct YUFD_HW_META_INFO HWYUFD;
+};
+
+struct YUFO_META_INFO {
+	struct UfbcBufHeader ImgInfo;
+	unsigned int AUWriteBySW;
+	union YUFDStruct YUFD;
+};
+
+#endif // __UFBC_DEF_H__
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam-video.c b/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam-video.c
new file mode 100755
index 0000000000000000000000000000000000000000..33d1d9b173ad13c11b47707645f755b7da476b62
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam-video.c
@@ -0,0 +1,1767 @@
+// SPDX-License-Identifier: GPL-2.0
+//
+// Copyright (c) 2022 MediaTek Inc.
+
+#include <media/v4l2-device.h>
+#include <media/v4l2-ioctl.h>
+#include <media/videobuf2-dma-contig.h>
+#include <linux/videodev2.h>
+#include <linux/iommu.h>
+
+#include "mtk_cam.h"
+#include "mtk_cam-feature.h"
+#include "mtk_cam-video.h"
+#include "mtk_camera-v4l2-controls.h"
+#include "mtk_cam-ufbc-def.h"
+
+#include "mtk_cam_vb2-dma-contig.h"
+/*
+ * Note
+ *	differt dma(fmt) would have different bus_size
+ *	align xsize(bytes per line) with [bus_size * pixel_mode]
+ */
+static inline
+int mtk_cam_is_fullg(unsigned int ipi_fmt)
+{
+	return (ipi_fmt == MTKCAM_IPI_IMG_FMT_FG_BAYER8)
+		|| (ipi_fmt == MTKCAM_IPI_IMG_FMT_FG_BAYER10)
+		|| (ipi_fmt == MTKCAM_IPI_IMG_FMT_FG_BAYER12);
+}
+
+static inline
+int mtk_cam_dma_bus_size(int bpp, int pixel_mode_shift, int is_fg)
+{
+	unsigned int bus_size = ALIGN(bpp, 16) << pixel_mode_shift;
+
+	if (is_fg)
+		bus_size <<= 1;
+	return bus_size / 8; /* in bytes */
+}
+
+static inline
+int mtk_cam_yuv_dma_bus_size(int bpp, int pixel_mode_shift)
+{
+	unsigned int bus_size = ALIGN(bpp, 32);
+
+	return bus_size / 8; /* in bytes */
+}
+
+static inline
+int mtk_cam_dmao_xsize(int w, unsigned int ipi_fmt, int pixel_mode_shift)
+{
+	const int is_fg		= mtk_cam_is_fullg(ipi_fmt);
+	const int bpp		= mtk_cam_get_pixel_bits(ipi_fmt);
+	const int bytes		= is_fg ?
+		DIV_ROUND_UP(w * bpp * 3 / 2, 8) : DIV_ROUND_UP(w * bpp, 8);
+	const int bus_size	= mtk_cam_dma_bus_size(bpp, pixel_mode_shift, is_fg);
+
+	return ALIGN(bytes, bus_size);
+}
+
+static int mtk_cam_vb2_queue_setup(struct vb2_queue *vq,
+				   unsigned int *num_buffers,
+				   unsigned int *num_planes,
+				   unsigned int sizes[],
+				   struct device *alloc_devs[])
+{
+	struct mtk_cam_device *cam = vb2_get_drv_priv(vq);
+	struct mtk_cam_video_device *node = mtk_cam_vbq_to_vdev(vq);
+	struct mtk_raw_pipeline *raw_pipeline;
+	unsigned int max_buffer_count = node->desc.max_buf_count;
+	const struct v4l2_format *fmt = &node->active_fmt;
+	unsigned int size;
+	int i;
+	int min_buf_sz;
+
+	min_buf_sz = ALIGN(IMG_MIN_WIDTH, IMG_PIX_ALIGN) * IMG_MIN_HEIGHT;
+
+	/* Check the limitation of buffer size */
+	if (max_buffer_count)
+		*num_buffers = clamp_val(*num_buffers, 1, max_buffer_count);
+
+	if (node->desc.smem_alloc)
+		vq->dma_attrs |= DMA_ATTR_NO_KERNEL_MAPPING;
+
+	if (vq->type == V4L2_BUF_TYPE_META_OUTPUT ||
+	    vq->type == V4L2_BUF_TYPE_META_CAPTURE)
+		size = fmt->fmt.meta.buffersize;
+	else
+		size = min_buf_sz;
+
+	/* Add for q.create_bufs with fmt.g_sizeimage(p) / 2 test */
+	if (*num_planes) {
+		if (sizes[0] < size || *num_planes != 1)
+			return -EINVAL;
+	} else {
+		/* TBC: subsampling configuration */
+		if (is_raw_subdev(node->uid.pipe_id)) {
+			raw_pipeline = mtk_cam_dev_get_raw_pipeline(cam, node->uid.pipe_id);
+			if (raw_pipeline && node->desc.id == MTK_RAW_MAIN_STREAM_OUT) {
+				if (raw_pipeline->dynamic_exposure_num_max >
+				    fmt->fmt.pix_mp.num_planes) {
+					*num_planes = raw_pipeline->dynamic_exposure_num_max;
+					for (i = 0; i < *num_planes; i++)
+						sizes[i] = size;
+				} else if (raw_pipeline && raw_pipeline->user_res.raw_res.feature &&
+					fmt->fmt.pix_mp.num_planes > 1) {
+					*num_planes = fmt->fmt.pix_mp.num_planes;
+
+					for (i = 0; i < *num_planes; i++)
+						sizes[i] = size;
+				} else {
+					*num_planes = 1;
+					sizes[0] = size;
+				}
+			} else if (raw_pipeline && raw_pipeline->user_res.raw_res.feature
+				&& fmt->fmt.pix_mp.num_planes > 1) {
+				*num_planes = fmt->fmt.pix_mp.num_planes;
+				for (i = 0; i < *num_planes; i++)
+					sizes[i] = size;
+			} else {
+				*num_planes = 1;
+				sizes[0] = size;
+			}
+		} else if (is_camsv_subdev(node->uid.pipe_id)) {
+			*num_planes = 1;
+			sizes[0] = size;
+		} else {
+			*num_planes = 1;
+			sizes[0] = size;
+		}
+	}
+
+	return 0;
+}
+
+static int mtk_cam_vb2_buf_init(struct vb2_buffer *vb)
+{
+	struct mtk_cam_video_device *node = mtk_cam_vbq_to_vdev(vb->vb2_queue);
+	struct device *dev = vb->vb2_queue->dev;
+	struct mtk_cam_buffer *buf;
+	struct iommu_domain *domain;
+
+	buf = mtk_cam_vb2_buf_to_dev_buf(vb);
+	buf->daddr = vb2_dma_contig_plane_dma_addr(vb, 0);
+	buf->scp_addr = 0;
+
+	/* SCP address is only valid for meta input buffer */
+	if (!node->desc.smem_alloc)
+		return 0;
+
+	domain = iommu_get_domain_for_dev(dev);
+	buf->scp_addr = iommu_iova_to_phys(domain, buf->daddr);
+
+	return 0;
+}
+
+static int mtk_cam_vb2_buf_prepare(struct vb2_buffer *vb)
+{
+	struct mtk_cam_video_device *node = mtk_cam_vbq_to_vdev(vb->vb2_queue);
+	struct vb2_v4l2_buffer *v4l2_buf = to_vb2_v4l2_buffer(vb);
+	const struct v4l2_format *fmt = &node->active_fmt;
+	unsigned int size;
+	unsigned int plane;
+
+	if (node->desc.need_cache_sync_on_prepare) {
+		dev_dbg(vb->vb2_queue->dev, "%s: %s\n",
+			__func__, node->desc.name);
+		for (plane = 0; plane < vb->num_planes; ++plane)
+			mtk_cam_vb2_sync_for_device(vb->planes[plane].mem_priv);
+	}
+
+	if (vb->vb2_queue->type == V4L2_BUF_TYPE_META_OUTPUT ||
+	    vb->vb2_queue->type == V4L2_BUF_TYPE_META_CAPTURE)
+		size = fmt->fmt.meta.buffersize;
+	else
+		size = fmt->fmt.pix_mp.plane_fmt[0].sizeimage;
+
+	if (vb2_plane_size(vb, 0) < size) {
+		dev_info(vb->vb2_queue->dev, "plane size is too small:%lu<%u\n",
+			vb2_plane_size(vb, 0), size);
+		/* return -EINVAL; */
+	}
+
+	if (V4L2_TYPE_IS_OUTPUT(vb->vb2_queue->type)) {
+		if ((vb2_get_plane_payload(vb, 0) != size) && (vb->vb2_queue->streaming)) {
+			dev_dbg(vb->vb2_queue->dev, "plane payload is mismatch:%lu:%u\n",
+				vb2_get_plane_payload(vb, 0), size);
+			/* todo: user must set correct byteused */
+			/* return -EINVAL;*/
+		}
+		return 0;
+	}
+
+	v4l2_buf->field = V4L2_FIELD_NONE;
+	vb2_set_plane_payload(vb, 0, size);
+
+	return 0;
+}
+
+static void mtk_cam_vb2_buf_finish(struct vb2_buffer *vb)
+{
+	struct mtk_cam_video_device *node = mtk_cam_vbq_to_vdev(vb->vb2_queue);
+	unsigned int plane;
+
+	if (node->desc.need_cache_sync_on_finish) {
+		dev_dbg(vb->vb2_queue->dev, "%s: %s\n",
+			__func__, node->desc.name);
+		for (plane = 0; plane < vb->num_planes; ++plane)
+			mtk_cam_vb2_sync_for_cpu(vb->planes[plane].mem_priv);
+	}
+}
+
+static int mtk_cam_vb2_start_streaming(struct vb2_queue *vq,
+				       unsigned int count)
+{
+	struct mtk_cam_device *cam = vb2_get_drv_priv(vq);
+	struct mtk_cam_video_device *node = mtk_cam_vbq_to_vdev(vq);
+	struct media_entity *entity = &node->vdev.entity;
+	struct mtk_cam_ctx *ctx = NULL;
+	struct device *dev = cam->dev;
+	int ret;
+
+	/* check entity is linked */
+	if (!node->enabled) {
+		dev_info(cam->dev,
+			"%s: stream on failed, node is not enabled\n",
+			node->desc.name);
+		ret = -ENOLINK;
+		goto fail_return_buffer;
+	}
+
+	if (!media_entity_is_streaming(entity)) {
+		ctx = mtk_cam_start_ctx(cam, node);
+		if (!ctx) {
+			ret = -ENOLINK;
+			goto fail_return_buffer;
+		}
+	} else {
+		ctx = mtk_cam_find_ctx(cam, entity);
+		if (WARN_ON(!ctx)) {
+			ret = -ENOLINK;
+			goto fail_return_buffer;
+		}
+	}
+
+	cam->streaming_pipe |= (1 << node->uid.pipe_id);
+	ctx->streaming_pipe |= (1 << node->uid.pipe_id);
+	ctx->streaming_node_cnt++;
+
+	if (ctx->streaming_node_cnt == 1)
+		if (is_raw_subdev(node->uid.pipe_id)) {
+			if (!isp_composer_create_session(ctx)) {
+				ctx->session_created = 1;
+			} else {
+				complete(&ctx->session_complete);
+				ret = -EBUSY;
+				goto fail_stop_ctx;
+			}
+		}
+
+	dev_dbg(dev, "%s:%s:ctx(%d): node:%d count info:%d\n", __func__,
+		node->desc.name, ctx->stream_id, node->desc.id, ctx->streaming_node_cnt);
+
+	if (ctx->streaming_node_cnt < ctx->enabled_node_cnt)
+		return 0;
+
+	/* all enabled nodes are streaming, enable all subdevs */
+	ret = mtk_cam_ctx_stream_on(ctx, node);
+	if (ret)
+		goto fail_destroy_session;
+
+	return 0;
+
+fail_destroy_session:
+	if (ctx->session_created)
+		isp_composer_destroy_session(ctx);
+fail_stop_ctx:
+	ctx->streaming_node_cnt--;
+	ctx->streaming_pipe &= ~(1 << node->uid.pipe_id);
+	cam->streaming_pipe &= ~(1 << node->uid.pipe_id);
+	mtk_cam_dev_req_cleanup(ctx, node->uid.pipe_id, VB2_BUF_STATE_QUEUED);
+	mtk_cam_stop_ctx(ctx, node);
+fail_return_buffer:
+	/* relese bufs by request */
+	return ret;
+}
+
+static void mtk_cam_vb2_stop_streaming(struct vb2_queue *vq)
+{
+	struct mtk_cam_device *cam = vb2_get_drv_priv(vq);
+	struct mtk_cam_video_device *node = mtk_cam_vbq_to_vdev(vq);
+	struct device *dev = cam->dev;
+	struct mtk_cam_ctx *ctx;
+
+	ctx = mtk_cam_find_ctx(cam, &node->vdev.entity);
+	if (WARN_ON(!ctx)) {
+		/* the ctx is stop, media_pipeline_stop is called */
+		mtk_cam_dev_req_clean_pending(cam, node->uid.pipe_id,
+					      VB2_BUF_STATE_ERROR);
+		return;
+	}
+
+	dev_dbg(dev, "%s:%s:ctx(%d): node:%d count info:%d\n", __func__,
+		node->desc.name, ctx->stream_id, node->desc.id, ctx->streaming_node_cnt);
+
+	if (ctx->streaming_node_cnt == ctx->enabled_node_cnt)
+		mtk_cam_ctx_stream_off(ctx, node);
+
+	if (cam->streaming_pipe & (1 << node->uid.pipe_id)) {
+		/* NOTE: take multi-pipelines case into consideration     */
+		/* Moreover, must clean bit mask before req cleanup       */
+		/* Otherwise, would cause req not removed in pending list */
+		cam->streaming_pipe &= ~(1 << node->uid.pipe_id);
+		mtk_cam_dev_req_cleanup(ctx, node->uid.pipe_id, VB2_BUF_STATE_ERROR);
+	}
+
+	/* all bufs of node should be return by per requests */
+
+	/* NOTE: take multi-pipelines case into consideration */
+	cam->streaming_pipe &= ~(1 << node->uid.pipe_id);
+	ctx->streaming_node_cnt--;
+	if (ctx->streaming_node_cnt)
+		return;
+
+	mtk_cam_stop_ctx(ctx, node);
+}
+
+int is_mtk_format(u32 pixelformat)
+{
+	switch (pixelformat) {
+	case V4L2_PIX_FMT_YUYV10:
+	case V4L2_PIX_FMT_YVYU10:
+	case V4L2_PIX_FMT_UYVY10:
+	case V4L2_PIX_FMT_VYUY10:
+	case V4L2_PIX_FMT_YUYV12:
+	case V4L2_PIX_FMT_YVYU12:
+	case V4L2_PIX_FMT_UYVY12:
+	case V4L2_PIX_FMT_VYUY12:
+	case V4L2_PIX_FMT_MTISP_YUYV10P:
+	case V4L2_PIX_FMT_MTISP_YVYU10P:
+	case V4L2_PIX_FMT_MTISP_UYVY10P:
+	case V4L2_PIX_FMT_MTISP_VYUY10P:
+	case V4L2_PIX_FMT_MTISP_YUYV12P:
+	case V4L2_PIX_FMT_MTISP_YVYU12P:
+	case V4L2_PIX_FMT_MTISP_UYVY12P:
+	case V4L2_PIX_FMT_MTISP_VYUY12P:
+	case V4L2_PIX_FMT_NV12_10:
+	case V4L2_PIX_FMT_NV21_10:
+	case V4L2_PIX_FMT_NV16_10:
+	case V4L2_PIX_FMT_NV61_10:
+	case V4L2_PIX_FMT_NV12_12:
+	case V4L2_PIX_FMT_NV21_12:
+	case V4L2_PIX_FMT_NV16_12:
+	case V4L2_PIX_FMT_NV61_12:
+	case V4L2_PIX_FMT_MTISP_NV12_10P:
+	case V4L2_PIX_FMT_MTISP_NV21_10P:
+	case V4L2_PIX_FMT_MTISP_NV16_10P:
+	case V4L2_PIX_FMT_MTISP_NV61_10P:
+	case V4L2_PIX_FMT_MTISP_NV12_12P:
+	case V4L2_PIX_FMT_MTISP_NV21_12P:
+	case V4L2_PIX_FMT_MTISP_NV16_12P:
+	case V4L2_PIX_FMT_MTISP_NV61_12P:
+	case V4L2_PIX_FMT_MTISP_NV12_UFBC:
+	case V4L2_PIX_FMT_MTISP_NV21_UFBC:
+	case V4L2_PIX_FMT_MTISP_NV12_10_UFBC:
+	case V4L2_PIX_FMT_MTISP_NV21_10_UFBC:
+	case V4L2_PIX_FMT_MTISP_NV12_12_UFBC:
+	case V4L2_PIX_FMT_MTISP_NV21_12_UFBC:
+	case V4L2_PIX_FMT_MTISP_BAYER8_UFBC:
+	case V4L2_PIX_FMT_MTISP_BAYER10_UFBC:
+	case V4L2_PIX_FMT_MTISP_BAYER12_UFBC:
+	case V4L2_PIX_FMT_MTISP_BAYER14_UFBC:
+		return 1;
+	default:
+		return 0;
+	}
+}
+
+int is_yuv_ufo(u32 pixelformat)
+{
+	switch (pixelformat) {
+	case V4L2_PIX_FMT_MTISP_NV12_UFBC:
+	case V4L2_PIX_FMT_MTISP_NV21_UFBC:
+	case V4L2_PIX_FMT_MTISP_NV12_10_UFBC:
+	case V4L2_PIX_FMT_MTISP_NV21_10_UFBC:
+	case V4L2_PIX_FMT_MTISP_NV12_12_UFBC:
+	case V4L2_PIX_FMT_MTISP_NV21_12_UFBC:
+		return 1;
+	default:
+		return 0;
+	}
+}
+
+int is_raw_ufo(u32 pixelformat)
+{
+	switch (pixelformat) {
+	case V4L2_PIX_FMT_MTISP_BAYER8_UFBC:
+	case V4L2_PIX_FMT_MTISP_BAYER10_UFBC:
+	case V4L2_PIX_FMT_MTISP_BAYER12_UFBC:
+	case V4L2_PIX_FMT_MTISP_BAYER14_UFBC:
+		return 1;
+	default:
+		return 0;
+	}
+}
+
+int is_fullg_rb(u32 pixelformat)
+{
+	switch (pixelformat) {
+	case V4L2_PIX_FMT_MTISP_SGRB8F:
+	case V4L2_PIX_FMT_MTISP_SGRB10F:
+	case V4L2_PIX_FMT_MTISP_SGRB12F:
+		return 1;
+	default:
+		return 0;
+	}
+}
+
+const struct mtk_format_info *mtk_format_info(u32 format)
+{
+	static const struct mtk_format_info formats[] = {
+		/* YUV planar formats */
+		{ .format = V4L2_PIX_FMT_NV12_10,  .mem_planes = 1, .comp_planes = 2,
+			.bpp = { 1, 2, 0, 0 }, .hdiv = 2, .vdiv = 2,
+			.bit_r_num = 2, .bit_r_den = 1 },
+		{ .format = V4L2_PIX_FMT_NV21_10,  .mem_planes = 1, .comp_planes = 2,
+			.bpp = { 1, 2, 0, 0 }, .hdiv = 2, .vdiv = 2,
+			.bit_r_num = 2, .bit_r_den = 1 },
+		{ .format = V4L2_PIX_FMT_NV16_10,  .mem_planes = 1, .comp_planes = 2,
+			.bpp = { 1, 2, 0, 0 }, .hdiv = 2, .vdiv = 1,
+			.bit_r_num = 2, .bit_r_den = 1 },
+		{ .format = V4L2_PIX_FMT_NV61_10,  .mem_planes = 1, .comp_planes = 2,
+			.bpp = { 1, 2, 0, 0 }, .hdiv = 2, .vdiv = 1,
+			.bit_r_num = 2, .bit_r_den = 1 },
+		{ .format = V4L2_PIX_FMT_YUYV10,	  .mem_planes = 1, .comp_planes = 1,
+			.bpp = { 2, 0, 0, 0 }, .hdiv = 2, .vdiv = 1,
+			.bit_r_num = 2, .bit_r_den = 1 },
+		{ .format = V4L2_PIX_FMT_YVYU10,	  .mem_planes = 1, .comp_planes = 1,
+			.bpp = { 2, 0, 0, 0 }, .hdiv = 2, .vdiv = 1,
+			.bit_r_num = 2, .bit_r_den = 1 },
+		{ .format = V4L2_PIX_FMT_UYVY10,	  .mem_planes = 1, .comp_planes = 1,
+			.bpp = { 2, 0, 0, 0 }, .hdiv = 2, .vdiv = 1,
+			.bit_r_num = 2, .bit_r_den = 1 },
+		{ .format = V4L2_PIX_FMT_VYUY10,	  .mem_planes = 1, .comp_planes = 1,
+			.bpp = { 2, 0, 0, 0 }, .hdiv = 2, .vdiv = 1,
+			.bit_r_num = 2, .bit_r_den = 1 },
+		{ .format = V4L2_PIX_FMT_NV12_12,  .mem_planes = 1, .comp_planes = 2,
+			.bpp = { 1, 2, 0, 0 }, .hdiv = 2, .vdiv = 2,
+			.bit_r_num = 2, .bit_r_den = 1 },
+		{ .format = V4L2_PIX_FMT_NV21_12,  .mem_planes = 1, .comp_planes = 2,
+			.bpp = { 1, 2, 0, 0 }, .hdiv = 2, .vdiv = 2,
+			.bit_r_num = 2, .bit_r_den = 1 },
+		{ .format = V4L2_PIX_FMT_NV16_12,  .mem_planes = 1, .comp_planes = 2,
+			.bpp = { 1, 2, 0, 0 }, .hdiv = 2, .vdiv = 1,
+			.bit_r_num = 2, .bit_r_den = 1 },
+		{ .format = V4L2_PIX_FMT_NV61_12,  .mem_planes = 1, .comp_planes = 2,
+			.bpp = { 1, 2, 0, 0 }, .hdiv = 2, .vdiv = 1,
+			.bit_r_num = 2, .bit_r_den = 1 },
+		{ .format = V4L2_PIX_FMT_YUYV12,	  .mem_planes = 1, .comp_planes = 1,
+			.bpp = { 2, 0, 0, 0 }, .hdiv = 2, .vdiv = 1,
+			.bit_r_num = 2, .bit_r_den = 1 },
+		{ .format = V4L2_PIX_FMT_YVYU12,	  .mem_planes = 1, .comp_planes = 1,
+			.bpp = { 2, 0, 0, 0 }, .hdiv = 2, .vdiv = 1,
+			.bit_r_num = 2, .bit_r_den = 1 },
+		{ .format = V4L2_PIX_FMT_UYVY12,	  .mem_planes = 1, .comp_planes = 1,
+			.bpp = { 2, 0, 0, 0 }, .hdiv = 2, .vdiv = 1,
+			.bit_r_num = 2, .bit_r_den = 1 },
+		{ .format = V4L2_PIX_FMT_VYUY12,	  .mem_planes = 1, .comp_planes = 1,
+			.bpp = { 2, 0, 0, 0 }, .hdiv = 2, .vdiv = 1,
+			.bit_r_num = 2, .bit_r_den = 1 },
+		/* YUV packed formats */
+		{ .format = V4L2_PIX_FMT_MTISP_YUYV10P,	  .mem_planes = 1, .comp_planes = 1,
+			.bpp = { 2, 0, 0, 0 }, .hdiv = 2, .vdiv = 1,
+			.bit_r_num = 5, .bit_r_den = 4 },
+		{ .format = V4L2_PIX_FMT_MTISP_YVYU10P,	  .mem_planes = 1, .comp_planes = 1,
+			.bpp = { 2, 0, 0, 0 }, .hdiv = 2, .vdiv = 1,
+			.bit_r_num = 5, .bit_r_den = 4 },
+		{ .format = V4L2_PIX_FMT_MTISP_UYVY10P,	  .mem_planes = 1, .comp_planes = 1,
+			.bpp = { 2, 0, 0, 0 }, .hdiv = 2, .vdiv = 1,
+			.bit_r_num = 5, .bit_r_den = 4 },
+		{ .format = V4L2_PIX_FMT_MTISP_VYUY10P,	  .mem_planes = 1, .comp_planes = 1,
+			.bpp = { 2, 0, 0, 0 }, .hdiv = 2, .vdiv = 1,
+			.bit_r_num = 5, .bit_r_den = 4 },
+		{ .format = V4L2_PIX_FMT_MTISP_NV12_10P, .mem_planes = 1, .comp_planes = 2,
+			.bpp = { 1, 2, 0, 0 }, .hdiv = 2, .vdiv = 2,
+			.bit_r_num = 5, .bit_r_den = 4 },
+		{ .format = V4L2_PIX_FMT_MTISP_NV21_10P, .mem_planes = 1, .comp_planes = 2,
+			.bpp = { 1, 2, 0, 0 }, .hdiv = 2, .vdiv = 2,
+			.bit_r_num = 5, .bit_r_den = 4 },
+		{ .format = V4L2_PIX_FMT_MTISP_NV16_10P, .mem_planes = 1, .comp_planes = 2,
+			.bpp = { 1, 2, 0, 0 }, .hdiv = 2, .vdiv = 1,
+			.bit_r_num = 5, .bit_r_den = 4 },
+		{ .format = V4L2_PIX_FMT_MTISP_NV61_10P, .mem_planes = 1, .comp_planes = 2,
+			.bpp = { 1, 2, 0, 0 }, .hdiv = 2, .vdiv = 1,
+			.bit_r_num = 5, .bit_r_den = 4 },
+		{ .format = V4L2_PIX_FMT_MTISP_YUYV12P,	  .mem_planes = 1, .comp_planes = 1,
+			.bpp = { 2, 0, 0, 0 }, .hdiv = 2, .vdiv = 1,
+			.bit_r_num = 3, .bit_r_den = 2 },
+		{ .format = V4L2_PIX_FMT_MTISP_YVYU12P,	  .mem_planes = 1, .comp_planes = 1,
+			.bpp = { 2, 0, 0, 0 }, .hdiv = 2, .vdiv = 1,
+			.bit_r_num = 3, .bit_r_den = 2 },
+		{ .format = V4L2_PIX_FMT_MTISP_UYVY12P,	  .mem_planes = 1, .comp_planes = 1,
+			.bpp = { 2, 0, 0, 0 }, .hdiv = 2, .vdiv = 1,
+			.bit_r_num = 3, .bit_r_den = 2 },
+		{ .format = V4L2_PIX_FMT_MTISP_VYUY12P,	  .mem_planes = 1, .comp_planes = 1,
+			.bpp = { 2, 0, 0, 0 }, .hdiv = 2, .vdiv = 1,
+			.bit_r_num = 3, .bit_r_den = 2 },
+		{ .format = V4L2_PIX_FMT_MTISP_NV12_12P, .mem_planes = 1, .comp_planes = 2,
+			.bpp = { 1, 2, 0, 0 }, .hdiv = 2, .vdiv = 2,
+			.bit_r_num = 3, .bit_r_den = 2 },
+		{ .format = V4L2_PIX_FMT_MTISP_NV21_12P, .mem_planes = 1, .comp_planes = 2,
+			.bpp = { 1, 2, 0, 0 }, .hdiv = 2, .vdiv = 2,
+			.bit_r_num = 3, .bit_r_den = 2 },
+		{ .format = V4L2_PIX_FMT_MTISP_NV16_12P, .mem_planes = 1, .comp_planes = 2,
+			.bpp = { 1, 2, 0, 0 }, .hdiv = 2, .vdiv = 1,
+			.bit_r_num = 3, .bit_r_den = 2 },
+		{ .format = V4L2_PIX_FMT_MTISP_NV61_12P, .mem_planes = 1, .comp_planes = 2,
+			.bpp = { 1, 2, 0, 0 }, .hdiv = 2, .vdiv = 1,
+			.bit_r_num = 3, .bit_r_den = 2 },
+		/* YUV UFBC formats */
+		{ .format = V4L2_PIX_FMT_MTISP_NV12_UFBC, .mem_planes = 1, .comp_planes = 2,
+			.bpp = { 1, 2, 0, 0 }, .hdiv = 2, .vdiv = 2,
+			.bit_r_num = 2, .bit_r_den = 1 },
+		{ .format = V4L2_PIX_FMT_MTISP_NV21_UFBC, .mem_planes = 1, .comp_planes = 2,
+			.bpp = { 1, 2, 0, 0 }, .hdiv = 2, .vdiv = 2,
+			.bit_r_num = 2, .bit_r_den = 1 },
+		{ .format = V4L2_PIX_FMT_MTISP_NV12_10_UFBC, .mem_planes = 1, .comp_planes = 2,
+			.bpp = { 1, 2, 0, 0 }, .hdiv = 2, .vdiv = 2,
+			.bit_r_num = 5, .bit_r_den = 4 },
+		{ .format = V4L2_PIX_FMT_MTISP_NV21_10_UFBC, .mem_planes = 1, .comp_planes = 2,
+			.bpp = { 1, 2, 0, 0 }, .hdiv = 2, .vdiv = 2,
+			.bit_r_num = 5, .bit_r_den = 4 },
+		{ .format = V4L2_PIX_FMT_MTISP_NV12_12_UFBC, .mem_planes = 1, .comp_planes = 2,
+			.bpp = { 1, 2, 0, 0 }, .hdiv = 2, .vdiv = 2,
+			.bit_r_num = 3, .bit_r_den = 2 },
+		{ .format = V4L2_PIX_FMT_MTISP_NV21_12_UFBC, .mem_planes = 1, .comp_planes = 2,
+			.bpp = { 1, 2, 0, 0 }, .hdiv = 2, .vdiv = 2,
+			.bit_r_num = 3, .bit_r_den = 2 },
+		{ .format = V4L2_PIX_FMT_MTISP_BAYER8_UFBC, .mem_planes = 1, .comp_planes = 1,
+			.bpp = { 1, 0, 0, 0 }, .hdiv = 1, .vdiv = 1,
+			.bit_r_num = 1, .bit_r_den = 1 },
+		{ .format = V4L2_PIX_FMT_MTISP_BAYER10_UFBC, .mem_planes = 1, .comp_planes = 1,
+			.bpp = { 1, 0, 0, 0 }, .hdiv = 1, .vdiv = 1,
+			.bit_r_num = 5, .bit_r_den = 4 },
+		{ .format = V4L2_PIX_FMT_MTISP_BAYER12_UFBC, .mem_planes = 1, .comp_planes = 1,
+			.bpp = { 1, 0, 0, 0 }, .hdiv = 1, .vdiv = 1,
+			.bit_r_num = 3, .bit_r_den = 2 },
+		{ .format = V4L2_PIX_FMT_MTISP_BAYER14_UFBC, .mem_planes = 1, .comp_planes = 1,
+			.bpp = { 1, 0, 0, 0 }, .hdiv = 1, .vdiv = 1,
+			.bit_r_num = 7, .bit_r_den = 4 },
+
+	};
+	unsigned int i;
+
+	for (i = 0; i < ARRAY_SIZE(formats); ++i)
+		if (formats[i].format == format)
+			return &formats[i];
+	return NULL;
+}
+
+static void mtk_cam_vb2_buf_queue(struct vb2_buffer *vb)
+{
+	struct mtk_cam_device *cam = vb2_get_drv_priv(vb->vb2_queue);
+	unsigned int pipe_id;
+	struct mtk_cam_buffer *buf = mtk_cam_vb2_buf_to_dev_buf(vb);
+	struct mtk_cam_request *req = to_mtk_cam_req(vb->request);
+	struct mtk_cam_request_stream_data *req_stream_data;
+	struct mtk_cam_video_device *node = mtk_cam_vbq_to_vdev(vb->vb2_queue);
+	struct mtk_raw_pde_config *pde_cfg;
+	struct device *dev = cam->dev;
+	unsigned int desc_id;
+	unsigned int dma_port = node->desc.dma_port;
+	unsigned int width, height, stride;
+	void *vaddr;
+	struct mtkcam_ipi_frame_param *frame_param;
+	struct mtkcam_ipi_meta_input *meta_in;
+	struct mtkcam_ipi_meta_output *meta_out;
+	struct mtk_camsv_frame_params *sv_frame_params;
+
+	dma_port = node->desc.dma_port;
+	pipe_id = node->uid.pipe_id;
+	req_stream_data = mtk_cam_req_get_s_data(req, pipe_id, 0);
+	frame_param = &req_stream_data->frame_params;
+	sv_frame_params = &req_stream_data->sv_frame_params;
+	mtk_cam_s_data_set_vbuf(req_stream_data, buf, node->desc.id);
+
+	/* update buffer internal address */
+	switch (dma_port) {
+	case MTKCAM_IPI_RAW_META_STATS_CFG:
+		desc_id = node->desc.id-MTK_RAW_SINK_NUM;
+		meta_in = &frame_param->meta_inputs[desc_id];
+		meta_in->buf.fd = vb->planes[0].m.fd;
+		/* vb->planes[0].bytesused; todo: vb2_q byteused is zero before stream on */
+		meta_in->buf.size = node->active_fmt.fmt.meta.buffersize;
+		meta_in->buf.iova = buf->daddr;
+		meta_in->buf.scp_addr = buf->scp_addr;
+		meta_in->uid.id = dma_port;
+		vaddr = vb2_plane_vaddr(vb, 0);
+		break;
+	case MTKCAM_IPI_RAW_META_STATS_0:
+	case MTKCAM_IPI_RAW_META_STATS_1:
+	case MTKCAM_IPI_RAW_META_STATS_2:
+		pde_cfg = &cam->raw.pipelines[node->uid.pipe_id].pde_config;
+		desc_id = node->desc.id-MTK_RAW_META_OUT_BEGIN;
+		meta_out = &frame_param->meta_outputs[desc_id];
+		meta_out->buf.fd = vb->planes[0].m.fd;
+		meta_out->buf.size = node->active_fmt.fmt.meta.buffersize;
+		meta_out->buf.iova = buf->daddr;
+		meta_out->buf.scp_addr = buf->scp_addr;
+		meta_out->uid.id = dma_port;
+		vaddr = vb2_plane_vaddr(vb, 0);
+		mtk_cam_set_meta_stats_info(dma_port, vaddr, pde_cfg);
+		break;
+	case MTKCAM_IPI_CAMSV_MAIN_OUT:
+		if (node->desc.id == MTK_RAW_MAIN_STREAM_SV_1_OUT) {
+			sv_frame_params->img_out.buf[0][0].iova = buf->daddr;
+		} else {
+			sv_frame_params->img_out.buf[0][0].iova = buf->daddr +
+				mtk_cam_get_meta_size(dma_port);
+			width = node->active_fmt.fmt.pix_mp.width;
+			height = node->active_fmt.fmt.pix_mp.height;
+			stride = node->active_fmt.fmt.pix_mp.plane_fmt[0].bytesperline;
+			vaddr = vb2_plane_vaddr(vb, 0);
+			mtk_cam_set_sv_meta_stats_info(node->desc.dma_port,
+						       vaddr, width,
+						       height, stride);
+		}
+		break;
+	default:
+		dev_dbg(dev, "%s:pipe(%d):buffer with invalid port(%d)\n",
+			__func__, pipe_id, dma_port);
+		break;
+	}
+
+}
+
+static void mtk_cam_vb2_request_complete(struct vb2_buffer *vb)
+{
+	struct mtk_cam_device *cam = vb2_get_drv_priv(vb->vb2_queue);
+
+	dev_dbg(vb->vb2_queue->dev, "%s\n", __func__);
+
+	v4l2_ctrl_request_complete(vb->req_obj.req,
+				   cam->v4l2_dev.ctrl_handler);
+}
+
+static int mtk_cam_vb2_buf_out_validate(struct vb2_buffer *vb)
+{
+	struct vb2_v4l2_buffer *v4l2_buf = to_vb2_v4l2_buffer(vb);
+
+	if (vb->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) {
+		if (v4l2_buf->field == V4L2_FIELD_ANY)
+			v4l2_buf->field = V4L2_FIELD_NONE;
+
+		if (v4l2_buf->field != V4L2_FIELD_NONE)
+			return -EINVAL;
+	}
+	return 0;
+}
+
+static const struct vb2_ops mtk_cam_vb2_ops = {
+	.queue_setup = mtk_cam_vb2_queue_setup,
+
+	.wait_prepare = vb2_ops_wait_prepare,
+	.wait_finish = vb2_ops_wait_finish,
+
+	.buf_out_validate = mtk_cam_vb2_buf_out_validate,
+	.buf_init = mtk_cam_vb2_buf_init,
+	.buf_prepare = mtk_cam_vb2_buf_prepare,
+	.buf_finish = mtk_cam_vb2_buf_finish,
+
+	.start_streaming = mtk_cam_vb2_start_streaming,
+	.stop_streaming = mtk_cam_vb2_stop_streaming,
+
+	.buf_queue = mtk_cam_vb2_buf_queue,
+	.buf_request_complete = mtk_cam_vb2_request_complete,
+};
+
+static const struct v4l2_file_operations mtk_cam_v4l2_fops = {
+	.unlocked_ioctl = video_ioctl2,
+	.open = v4l2_fh_open,
+	.release = vb2_fop_release,
+	.poll = vb2_fop_poll,
+	.mmap = vb2_fop_mmap,
+#ifdef CONFIG_COMPAT
+	.compat_ioctl32 = v4l2_compat_ioctl32,
+#endif
+};
+
+unsigned int mtk_cam_get_sensor_pixel_id(unsigned int fmt)
+{
+	switch (fmt & SENSOR_FMT_MASK) {
+	case MEDIA_BUS_FMT_SBGGR8_1X8:
+	case MEDIA_BUS_FMT_SBGGR10_1X10:
+	case MEDIA_BUS_FMT_SBGGR12_1X12:
+	case MEDIA_BUS_FMT_SBGGR14_1X14:
+		return MTKCAM_IPI_BAYER_PXL_ID_B;
+	case MEDIA_BUS_FMT_SGBRG8_1X8:
+	case MEDIA_BUS_FMT_SGBRG10_1X10:
+	case MEDIA_BUS_FMT_SGBRG12_1X12:
+	case MEDIA_BUS_FMT_SGBRG14_1X14:
+		return MTKCAM_IPI_BAYER_PXL_ID_GB;
+	case MEDIA_BUS_FMT_SGRBG8_1X8:
+	case MEDIA_BUS_FMT_SGRBG10_1X10:
+	case MEDIA_BUS_FMT_SGRBG12_1X12:
+	case MEDIA_BUS_FMT_SGRBG14_1X14:
+		return MTKCAM_IPI_BAYER_PXL_ID_GR;
+	case MEDIA_BUS_FMT_SRGGB8_1X8:
+	case MEDIA_BUS_FMT_SRGGB10_1X10:
+	case MEDIA_BUS_FMT_SRGGB12_1X12:
+	case MEDIA_BUS_FMT_SRGGB14_1X14:
+		return MTKCAM_IPI_BAYER_PXL_ID_R;
+	default:
+		return MTKCAM_IPI_BAYER_PXL_ID_UNKNOWN;
+	}
+}
+
+unsigned int mtk_cam_get_sensor_fmt(unsigned int fmt)
+{
+	switch (fmt & SENSOR_FMT_MASK) {
+	case MEDIA_BUS_FMT_SBGGR8_1X8:
+	case MEDIA_BUS_FMT_SGBRG8_1X8:
+	case MEDIA_BUS_FMT_SGRBG8_1X8:
+	case MEDIA_BUS_FMT_SRGGB8_1X8:
+		return MTKCAM_IPI_IMG_FMT_BAYER8;
+	case MEDIA_BUS_FMT_SBGGR10_1X10:
+	case MEDIA_BUS_FMT_SGBRG10_1X10:
+	case MEDIA_BUS_FMT_SGRBG10_1X10:
+	case MEDIA_BUS_FMT_SRGGB10_1X10:
+		return MTKCAM_IPI_IMG_FMT_BAYER10;
+	case MEDIA_BUS_FMT_SBGGR12_1X12:
+	case MEDIA_BUS_FMT_SGBRG12_1X12:
+	case MEDIA_BUS_FMT_SGRBG12_1X12:
+	case MEDIA_BUS_FMT_SRGGB12_1X12:
+		return MTKCAM_IPI_IMG_FMT_BAYER12;
+	case MEDIA_BUS_FMT_SBGGR14_1X14:
+	case MEDIA_BUS_FMT_SGBRG14_1X14:
+	case MEDIA_BUS_FMT_SGRBG14_1X14:
+	case MEDIA_BUS_FMT_SRGGB14_1X14:
+		return MTKCAM_IPI_IMG_FMT_BAYER14;
+	default:
+		return MTKCAM_IPI_IMG_FMT_UNKNOWN;
+	}
+}
+
+unsigned int mtk_cam_get_pixel_bits(unsigned int ipi_fmt)
+{
+	switch (ipi_fmt) {
+	case MTKCAM_IPI_IMG_FMT_BAYER8:
+	case MTKCAM_IPI_IMG_FMT_FG_BAYER8:
+		return 8;
+	case MTKCAM_IPI_IMG_FMT_BAYER10:
+	case MTKCAM_IPI_IMG_FMT_FG_BAYER10:
+	case MTKCAM_IPI_IMG_FMT_BAYER10_MIPI:
+		return 10;
+	case MTKCAM_IPI_IMG_FMT_BAYER12:
+	case MTKCAM_IPI_IMG_FMT_FG_BAYER12:
+		return 12;
+	case MTKCAM_IPI_IMG_FMT_BAYER14:
+	case MTKCAM_IPI_IMG_FMT_UFBC_BAYER14:
+		return 14;
+	case MTKCAM_IPI_IMG_FMT_BAYER10_UNPACKED:
+	case MTKCAM_IPI_IMG_FMT_BAYER12_UNPACKED:
+	case MTKCAM_IPI_IMG_FMT_BAYER14_UNPACKED:
+	case MTKCAM_IPI_IMG_FMT_BAYER16:
+	case MTKCAM_IPI_IMG_FMT_YUYV:
+	case MTKCAM_IPI_IMG_FMT_YVYU:
+	case MTKCAM_IPI_IMG_FMT_UYVY:
+	case MTKCAM_IPI_IMG_FMT_VYUY:
+		return 16;
+	case MTKCAM_IPI_IMG_FMT_Y8:
+	case MTKCAM_IPI_IMG_FMT_YUV_422_2P:
+	case MTKCAM_IPI_IMG_FMT_YVU_422_2P:
+	case MTKCAM_IPI_IMG_FMT_YUV_422_3P:
+	case MTKCAM_IPI_IMG_FMT_YVU_422_3P:
+	case MTKCAM_IPI_IMG_FMT_YUV_420_2P:
+	case MTKCAM_IPI_IMG_FMT_YVU_420_2P:
+	case MTKCAM_IPI_IMG_FMT_YUV_420_3P:
+	case MTKCAM_IPI_IMG_FMT_YVU_420_3P:
+		return 8;
+	case MTKCAM_IPI_IMG_FMT_YUYV_Y210:
+	case MTKCAM_IPI_IMG_FMT_YVYU_Y210:
+	case MTKCAM_IPI_IMG_FMT_UYVY_Y210:
+	case MTKCAM_IPI_IMG_FMT_VYUY_Y210:
+		return 32;
+	case MTKCAM_IPI_IMG_FMT_YUV_P210:
+	case MTKCAM_IPI_IMG_FMT_YVU_P210:
+	case MTKCAM_IPI_IMG_FMT_YUV_P010:
+	case MTKCAM_IPI_IMG_FMT_YVU_P010:
+	case MTKCAM_IPI_IMG_FMT_YUV_P212:
+	case MTKCAM_IPI_IMG_FMT_YVU_P212:
+	case MTKCAM_IPI_IMG_FMT_YUV_P012:
+	case MTKCAM_IPI_IMG_FMT_YVU_P012:
+		return 16;
+	case MTKCAM_IPI_IMG_FMT_YUYV_Y210_PACKED:
+	case MTKCAM_IPI_IMG_FMT_YVYU_Y210_PACKED:
+	case MTKCAM_IPI_IMG_FMT_UYVY_Y210_PACKED:
+	case MTKCAM_IPI_IMG_FMT_VYUY_Y210_PACKED:
+		return 20;
+	case MTKCAM_IPI_IMG_FMT_YUV_P210_PACKED:
+	case MTKCAM_IPI_IMG_FMT_YVU_P210_PACKED:
+	case MTKCAM_IPI_IMG_FMT_YUV_P010_PACKED:
+	case MTKCAM_IPI_IMG_FMT_YVU_P010_PACKED:
+		return 10;
+	case MTKCAM_IPI_IMG_FMT_YUV_P212_PACKED:
+	case MTKCAM_IPI_IMG_FMT_YVU_P212_PACKED:
+	case MTKCAM_IPI_IMG_FMT_YUV_P012_PACKED:
+	case MTKCAM_IPI_IMG_FMT_YVU_P012_PACKED:
+		return 12;
+	case MTKCAM_IPI_IMG_FMT_RGB_8B_3P:
+	case MTKCAM_IPI_IMG_FMT_FG_BAYER8_3P:
+	case MTKCAM_IPI_IMG_FMT_UFBC_NV12:
+	case MTKCAM_IPI_IMG_FMT_UFBC_NV21:
+	case MTKCAM_IPI_IMG_FMT_UFBC_BAYER8:
+		return 8;
+	case MTKCAM_IPI_IMG_FMT_RGB_10B_3P_PACKED:
+	case MTKCAM_IPI_IMG_FMT_FG_BAYER10_3P_PACKED:
+	case MTKCAM_IPI_IMG_FMT_UFBC_YUV_P010:
+	case MTKCAM_IPI_IMG_FMT_UFBC_YVU_P010:
+	case MTKCAM_IPI_IMG_FMT_UFBC_BAYER10:
+		return 10;
+	case MTKCAM_IPI_IMG_FMT_RGB_12B_3P_PACKED:
+	case MTKCAM_IPI_IMG_FMT_FG_BAYER12_3P_PACKED:
+	case MTKCAM_IPI_IMG_FMT_UFBC_YUV_P012:
+	case MTKCAM_IPI_IMG_FMT_UFBC_YVU_P012:
+	case MTKCAM_IPI_IMG_FMT_UFBC_BAYER12:
+		return 12;
+	case MTKCAM_IPI_IMG_FMT_RGB_10B_3P:
+	case MTKCAM_IPI_IMG_FMT_FG_BAYER10_3P:
+	case MTKCAM_IPI_IMG_FMT_RGB_12B_3P:
+	case MTKCAM_IPI_IMG_FMT_FG_BAYER12_3P:
+		return 16;
+
+	default:
+		break;
+	}
+	pr_debug("not supported ipi-fmt 0x%08x", ipi_fmt);
+
+	return -1;
+}
+
+unsigned int mtk_cam_get_img_fmt(unsigned int fourcc)
+{
+	switch (fourcc) {
+	case V4L2_PIX_FMT_GREY:
+		return MTKCAM_IPI_IMG_FMT_Y8;
+	case V4L2_PIX_FMT_YUYV:
+		return MTKCAM_IPI_IMG_FMT_YUYV;
+	case V4L2_PIX_FMT_YVYU:
+		return MTKCAM_IPI_IMG_FMT_YVYU;
+	case V4L2_PIX_FMT_NV16:
+		return MTKCAM_IPI_IMG_FMT_YUV_422_2P;
+	case V4L2_PIX_FMT_NV61:
+		return MTKCAM_IPI_IMG_FMT_YVU_422_2P;
+	case V4L2_PIX_FMT_NV12:
+		return MTKCAM_IPI_IMG_FMT_YUV_420_2P;
+	case V4L2_PIX_FMT_NV21:
+		return MTKCAM_IPI_IMG_FMT_YVU_420_2P;
+	case V4L2_PIX_FMT_YUV422P:
+		return MTKCAM_IPI_IMG_FMT_YUV_422_3P;
+	case V4L2_PIX_FMT_YUV420:
+		return MTKCAM_IPI_IMG_FMT_YUV_420_3P;
+	case V4L2_PIX_FMT_YVU420:
+		return MTKCAM_IPI_IMG_FMT_YVU_420_3P;
+	case V4L2_PIX_FMT_NV12_10:
+		return MTKCAM_IPI_IMG_FMT_YUV_P010;
+	case V4L2_PIX_FMT_NV21_10:
+		return MTKCAM_IPI_IMG_FMT_YVU_P010;
+	case V4L2_PIX_FMT_NV16_10:
+		return MTKCAM_IPI_IMG_FMT_YUV_P210;
+	case V4L2_PIX_FMT_NV61_10:
+		return MTKCAM_IPI_IMG_FMT_YVU_P210;
+	case V4L2_PIX_FMT_MTISP_NV12_10P:
+		return MTKCAM_IPI_IMG_FMT_YUV_P010_PACKED;
+	case V4L2_PIX_FMT_MTISP_NV21_10P:
+		return MTKCAM_IPI_IMG_FMT_YVU_P010_PACKED;
+	case V4L2_PIX_FMT_MTISP_NV16_10P:
+		return MTKCAM_IPI_IMG_FMT_YUV_P210_PACKED;
+	case V4L2_PIX_FMT_MTISP_NV61_10P:
+		return MTKCAM_IPI_IMG_FMT_YVU_P210_PACKED;
+	case V4L2_PIX_FMT_YUYV10:
+		return MTKCAM_IPI_IMG_FMT_YUYV_Y210;
+	case V4L2_PIX_FMT_YVYU10:
+		return MTKCAM_IPI_IMG_FMT_YVYU_Y210;
+	case V4L2_PIX_FMT_UYVY10:
+		return MTKCAM_IPI_IMG_FMT_UYVY_Y210;
+	case V4L2_PIX_FMT_VYUY10:
+		return MTKCAM_IPI_IMG_FMT_VYUY_Y210;
+	case V4L2_PIX_FMT_MTISP_YUYV10P:
+		return MTKCAM_IPI_IMG_FMT_YUYV_Y210_PACKED;
+	case V4L2_PIX_FMT_MTISP_YVYU10P:
+		return MTKCAM_IPI_IMG_FMT_YVYU_Y210_PACKED;
+	case V4L2_PIX_FMT_MTISP_UYVY10P:
+		return MTKCAM_IPI_IMG_FMT_UYVY_Y210_PACKED;
+	case V4L2_PIX_FMT_MTISP_VYUY10P:
+		return MTKCAM_IPI_IMG_FMT_VYUY_Y210_PACKED;
+	case V4L2_PIX_FMT_NV12_12:
+		return MTKCAM_IPI_IMG_FMT_YUV_P012;
+	case V4L2_PIX_FMT_NV21_12:
+		return MTKCAM_IPI_IMG_FMT_YVU_P012;
+	case V4L2_PIX_FMT_NV16_12:
+		return MTKCAM_IPI_IMG_FMT_YUV_P212;
+	case V4L2_PIX_FMT_NV61_12:
+		return MTKCAM_IPI_IMG_FMT_YVU_P212;
+	case V4L2_PIX_FMT_MTISP_NV12_12P:
+		return MTKCAM_IPI_IMG_FMT_YUV_P012_PACKED;
+	case V4L2_PIX_FMT_MTISP_NV21_12P:
+		return MTKCAM_IPI_IMG_FMT_YVU_P012_PACKED;
+	case V4L2_PIX_FMT_MTISP_NV16_12P:
+		return MTKCAM_IPI_IMG_FMT_YUV_P212_PACKED;
+	case V4L2_PIX_FMT_MTISP_NV61_12P:
+		return MTKCAM_IPI_IMG_FMT_YVU_P212_PACKED;
+	case V4L2_PIX_FMT_SBGGR8:
+	case V4L2_PIX_FMT_SGBRG8:
+	case V4L2_PIX_FMT_SGRBG8:
+	case V4L2_PIX_FMT_SRGGB8:
+		return MTKCAM_IPI_IMG_FMT_BAYER8;
+	case V4L2_PIX_FMT_MTISP_SBGGR8F:
+	case V4L2_PIX_FMT_MTISP_SGBRG8F:
+	case V4L2_PIX_FMT_MTISP_SGRBG8F:
+	case V4L2_PIX_FMT_MTISP_SRGGB8F:
+		return MTKCAM_IPI_IMG_FMT_FG_BAYER8;
+	case V4L2_PIX_FMT_SBGGR10:
+	case V4L2_PIX_FMT_SGBRG10:
+	case V4L2_PIX_FMT_SGRBG10:
+	case V4L2_PIX_FMT_SRGGB10:
+		return MTKCAM_IPI_IMG_FMT_BAYER10_UNPACKED;
+	case V4L2_PIX_FMT_SBGGR10P:
+	case V4L2_PIX_FMT_SGBRG10P:
+	case V4L2_PIX_FMT_SGRBG10P:
+	case V4L2_PIX_FMT_SRGGB10P:
+		return MTKCAM_IPI_IMG_FMT_BAYER10_MIPI;
+	case V4L2_PIX_FMT_MTISP_SBGGR10:
+	case V4L2_PIX_FMT_MTISP_SGBRG10:
+	case V4L2_PIX_FMT_MTISP_SGRBG10:
+	case V4L2_PIX_FMT_MTISP_SRGGB10:
+		return MTKCAM_IPI_IMG_FMT_BAYER10;
+	case V4L2_PIX_FMT_MTISP_SBGGR10F:
+	case V4L2_PIX_FMT_MTISP_SGBRG10F:
+	case V4L2_PIX_FMT_MTISP_SGRBG10F:
+	case V4L2_PIX_FMT_MTISP_SRGGB10F:
+		return MTKCAM_IPI_IMG_FMT_FG_BAYER10;
+	case V4L2_PIX_FMT_SBGGR12:
+	case V4L2_PIX_FMT_SGBRG12:
+	case V4L2_PIX_FMT_SGRBG12:
+	case V4L2_PIX_FMT_SRGGB12:
+		return MTKCAM_IPI_IMG_FMT_BAYER12_UNPACKED;
+	case V4L2_PIX_FMT_MTISP_SBGGR12:
+	case V4L2_PIX_FMT_MTISP_SGBRG12:
+	case V4L2_PIX_FMT_MTISP_SGRBG12:
+	case V4L2_PIX_FMT_MTISP_SRGGB12:
+		return MTKCAM_IPI_IMG_FMT_BAYER12;
+	case V4L2_PIX_FMT_MTISP_SBGGR12F:
+	case V4L2_PIX_FMT_MTISP_SGBRG12F:
+	case V4L2_PIX_FMT_MTISP_SGRBG12F:
+	case V4L2_PIX_FMT_MTISP_SRGGB12F:
+		return MTKCAM_IPI_IMG_FMT_FG_BAYER12;
+	case V4L2_PIX_FMT_SBGGR14:
+	case V4L2_PIX_FMT_SGBRG14:
+	case V4L2_PIX_FMT_SGRBG14:
+	case V4L2_PIX_FMT_SRGGB14:
+		return MTKCAM_IPI_IMG_FMT_BAYER14_UNPACKED;
+	case V4L2_PIX_FMT_MTISP_SBGGR14:
+	case V4L2_PIX_FMT_MTISP_SGBRG14:
+	case V4L2_PIX_FMT_MTISP_SGRBG14:
+	case V4L2_PIX_FMT_MTISP_SRGGB14:
+		return MTKCAM_IPI_IMG_FMT_BAYER14;
+	case V4L2_PIX_FMT_MTISP_SBGGR14F:
+	case V4L2_PIX_FMT_MTISP_SGBRG14F:
+	case V4L2_PIX_FMT_MTISP_SGRBG14F:
+	case V4L2_PIX_FMT_MTISP_SRGGB14F:
+		return MTKCAM_IPI_IMG_FMT_FG_BAYER14;
+	case V4L2_PIX_FMT_SBGGR16:
+	case V4L2_PIX_FMT_SGBRG16:
+	case V4L2_PIX_FMT_SGRBG16:
+	case V4L2_PIX_FMT_SRGGB16:
+		return MTKCAM_IPI_IMG_FMT_BAYER16;
+	case V4L2_PIX_FMT_MTISP_NV12_UFBC:
+		return MTKCAM_IPI_IMG_FMT_UFBC_NV12;
+	case V4L2_PIX_FMT_MTISP_NV21_UFBC:
+		return MTKCAM_IPI_IMG_FMT_UFBC_NV21;
+	case V4L2_PIX_FMT_MTISP_NV12_10_UFBC:
+		return MTKCAM_IPI_IMG_FMT_UFBC_YUV_P010;
+	case V4L2_PIX_FMT_MTISP_NV21_10_UFBC:
+		return MTKCAM_IPI_IMG_FMT_UFBC_YVU_P010;
+	case V4L2_PIX_FMT_MTISP_NV12_12_UFBC:
+		return MTKCAM_IPI_IMG_FMT_UFBC_YUV_P012;
+	case V4L2_PIX_FMT_MTISP_NV21_12_UFBC:
+		return MTKCAM_IPI_IMG_FMT_UFBC_YVU_P012;
+	case V4L2_PIX_FMT_MTISP_BAYER8_UFBC:
+		return MTKCAM_IPI_IMG_FMT_UFBC_BAYER8;
+	case V4L2_PIX_FMT_MTISP_BAYER10_UFBC:
+		return MTKCAM_IPI_IMG_FMT_UFBC_BAYER10;
+	case V4L2_PIX_FMT_MTISP_BAYER12_UFBC:
+		return MTKCAM_IPI_IMG_FMT_UFBC_BAYER12;
+	case V4L2_PIX_FMT_MTISP_BAYER14_UFBC:
+		return MTKCAM_IPI_IMG_FMT_UFBC_BAYER14;
+	case V4L2_PIX_FMT_MTISP_SGRB8F:
+		return MTKCAM_IPI_IMG_FMT_FG_BAYER8_3P;
+	case V4L2_PIX_FMT_MTISP_SGRB10F:
+		return MTKCAM_IPI_IMG_FMT_FG_BAYER10_3P_PACKED;
+	case V4L2_PIX_FMT_MTISP_SGRB12F:
+		return MTKCAM_IPI_IMG_FMT_FG_BAYER12_3P_PACKED;
+	default:
+		return MTKCAM_IPI_IMG_FMT_UNKNOWN;
+	}
+}
+
+static int mtk_cam_fill_pixfmt_mp(struct v4l2_pix_format_mplane *pixfmt,
+			u32 pixelformat, u32 width, u32 height)
+{
+	struct v4l2_plane_pix_format *plane;
+	unsigned int ipi_fmt = mtk_cam_get_img_fmt(pixelformat);
+	u8 pixel_bits = mtk_cam_get_pixel_bits(ipi_fmt);
+	u32 stride;
+	u32 aligned_width;
+	u8 pixel_mode_shift = 0; /* todo: should set by resMgr */
+	u8 bus_size;
+	u8 i;
+
+	pixfmt->width = width;
+	pixfmt->height = height;
+	pixfmt->pixelformat = pixelformat;
+	plane = &pixfmt->plane_fmt[0];
+	bus_size = mtk_cam_yuv_dma_bus_size(pixel_bits, pixel_mode_shift);
+	plane->sizeimage = 0;
+
+	if (is_mtk_format(pixelformat)) {
+		const struct mtk_format_info *info;
+
+		info = mtk_format_info(pixelformat);
+		pixfmt->num_planes = info->mem_planes;
+
+		if (!info)
+			return -EINVAL;
+
+		if (info->mem_planes == 1) {
+			if (is_yuv_ufo(pixelformat)) {
+				/* UFO format width should align 64 pixel */
+				aligned_width = ALIGN(width, 64);
+				stride = aligned_width * info->bit_r_num / info->bit_r_den;
+
+				if (stride > plane->bytesperline)
+					plane->bytesperline = stride;
+				plane->sizeimage = stride * height;
+				plane->sizeimage += stride * height / 2;
+				plane->sizeimage += ALIGN((aligned_width / 64), 8) * height;
+				plane->sizeimage += ALIGN((aligned_width / 64), 8) * height / 2;
+				plane->sizeimage += sizeof(struct UfbcBufferHeader);
+			} else if (is_raw_ufo(pixelformat)) {
+				/* UFO format width should align 64 pixel */
+				aligned_width = ALIGN(width, 64);
+				stride = aligned_width * info->bit_r_num / info->bit_r_den;
+
+				if (stride > plane->bytesperline)
+					plane->bytesperline = stride;
+				plane->sizeimage = stride * height;
+				plane->sizeimage += ALIGN((aligned_width / 64), 8) * height;
+				plane->sizeimage += sizeof(struct UfbcBufferHeader);
+			} else {
+				/* width should be bus_size align */
+				aligned_width = ALIGN(DIV_ROUND_UP(width
+					* info->bit_r_num, info->bit_r_den), bus_size);
+				stride = aligned_width * info->bpp[0];
+
+				if (stride > plane->bytesperline)
+					plane->bytesperline = stride;
+
+				for (i = 0; i < info->comp_planes; i++) {
+					unsigned int hdiv = (i == 0) ? 1 : info->hdiv;
+					unsigned int vdiv = (i == 0) ? 1 : info->vdiv;
+
+					if ((plane->bytesperline > stride) && is_fullg_rb(pixelformat)) {
+						plane->sizeimage +=
+							DIV_ROUND_UP(plane->bytesperline, hdiv)
+							* DIV_ROUND_UP(height, vdiv);
+					} else if ((plane->bytesperline > stride) && !is_fullg_rb(pixelformat)) {
+						plane->sizeimage += plane->bytesperline
+							* DIV_ROUND_UP(height, vdiv);
+					} else {
+						plane->sizeimage += info->bpp[i]
+							* DIV_ROUND_UP(aligned_width, hdiv)
+							* DIV_ROUND_UP(height, vdiv);
+					}
+				}
+			}
+			pr_debug("%s stride %d sizeimage %d\n", __func__,
+				plane->bytesperline, plane->sizeimage);
+		} else {
+			pr_debug("do not support non contiguous mplane\n");
+		}
+	} else {
+		const struct v4l2_format_info *info;
+
+		pr_debug("pixelformat:0x%x sizeimage:%d\n", pixelformat, plane->sizeimage);
+		info = v4l2_format_info(pixelformat);
+		pixfmt->num_planes = info->mem_planes;
+
+		if (!info)
+			return -EINVAL;
+
+		if (info->mem_planes == 1) {
+
+			aligned_width = ALIGN(width, bus_size);
+			stride = aligned_width * info->bpp[0];
+			if (stride > plane->bytesperline)
+				plane->bytesperline = stride;
+
+			for (i = 0; i < info->comp_planes; i++) {
+				unsigned int hdiv = (i == 0) ? 1 : info->hdiv;
+				unsigned int vdiv = (i == 0) ? 1 : info->vdiv;
+
+				plane->sizeimage += info->bpp[i]
+					* DIV_ROUND_UP(aligned_width, hdiv)
+					* DIV_ROUND_UP(height, vdiv);
+			}
+			pr_debug("%s stride %d sizeimage %d\n", __func__,
+				plane->bytesperline, plane->sizeimage);
+		} else {
+			pr_debug("do not support non contiguous mplane\n");
+		}
+	}
+
+	return 0;
+}
+
+static void cal_image_pix_mp(unsigned int node_id,
+			     struct v4l2_pix_format_mplane *mp,
+			     unsigned int pixel_mode)
+{
+	unsigned int ipi_fmt = mtk_cam_get_img_fmt(mp->pixelformat);
+	unsigned int width = mp->width;
+	unsigned int height = mp->height;
+	unsigned int stride, i;
+
+	pr_debug("fmt:0x%x ipi_fmt:%d\n", mp->pixelformat, ipi_fmt);
+	switch (ipi_fmt) {
+	case MTKCAM_IPI_IMG_FMT_BAYER8:
+	case MTKCAM_IPI_IMG_FMT_BAYER10:
+	case MTKCAM_IPI_IMG_FMT_BAYER12:
+	case MTKCAM_IPI_IMG_FMT_BAYER14:
+	case MTKCAM_IPI_IMG_FMT_BAYER16:
+	case MTKCAM_IPI_IMG_FMT_BAYER10_MIPI:
+	case MTKCAM_IPI_IMG_FMT_BAYER10_UNPACKED:
+	case MTKCAM_IPI_IMG_FMT_BAYER12_UNPACKED:
+	case MTKCAM_IPI_IMG_FMT_BAYER14_UNPACKED:
+	case MTKCAM_IPI_IMG_FMT_FG_BAYER8:
+	case MTKCAM_IPI_IMG_FMT_FG_BAYER10:
+	case MTKCAM_IPI_IMG_FMT_FG_BAYER12:
+	case MTKCAM_IPI_IMG_FMT_FG_BAYER14:
+		stride = mtk_cam_dmao_xsize(width, ipi_fmt, pixel_mode);
+		for (i = 0; i < mp->num_planes; i++) {
+			if (stride > mp->plane_fmt[i].bytesperline)
+				mp->plane_fmt[i].bytesperline = stride;
+			mp->plane_fmt[i].sizeimage = mp->plane_fmt[i].bytesperline * height;
+		}
+	break;
+	case MTKCAM_IPI_IMG_FMT_YUYV:
+	case MTKCAM_IPI_IMG_FMT_YVYU:
+	case MTKCAM_IPI_IMG_FMT_UYVY:
+	case MTKCAM_IPI_IMG_FMT_VYUY:
+	case MTKCAM_IPI_IMG_FMT_YUV_422_2P:
+	case MTKCAM_IPI_IMG_FMT_YVU_422_2P:
+	case MTKCAM_IPI_IMG_FMT_YUV_422_3P:
+	case MTKCAM_IPI_IMG_FMT_YVU_422_3P:
+	case MTKCAM_IPI_IMG_FMT_YUV_420_2P:
+	case MTKCAM_IPI_IMG_FMT_YVU_420_2P:
+	case MTKCAM_IPI_IMG_FMT_YUV_420_3P:
+	case MTKCAM_IPI_IMG_FMT_YVU_420_3P:
+	case MTKCAM_IPI_IMG_FMT_Y8:
+	case MTKCAM_IPI_IMG_FMT_YUYV_Y210:
+	case MTKCAM_IPI_IMG_FMT_YVYU_Y210:
+	case MTKCAM_IPI_IMG_FMT_UYVY_Y210:
+	case MTKCAM_IPI_IMG_FMT_VYUY_Y210:
+	case MTKCAM_IPI_IMG_FMT_YUYV_Y210_PACKED:
+	case MTKCAM_IPI_IMG_FMT_YVYU_Y210_PACKED:
+	case MTKCAM_IPI_IMG_FMT_UYVY_Y210_PACKED:
+	case MTKCAM_IPI_IMG_FMT_VYUY_Y210_PACKED:
+	case MTKCAM_IPI_IMG_FMT_YUV_P210:
+	case MTKCAM_IPI_IMG_FMT_YVU_P210:
+	case MTKCAM_IPI_IMG_FMT_YUV_P010:
+	case MTKCAM_IPI_IMG_FMT_YVU_P010:
+	case MTKCAM_IPI_IMG_FMT_YUV_P210_PACKED:
+	case MTKCAM_IPI_IMG_FMT_YVU_P210_PACKED:
+	case MTKCAM_IPI_IMG_FMT_YUV_P010_PACKED:
+	case MTKCAM_IPI_IMG_FMT_YVU_P010_PACKED:
+	case MTKCAM_IPI_IMG_FMT_YUV_P212:
+	case MTKCAM_IPI_IMG_FMT_YVU_P212:
+	case MTKCAM_IPI_IMG_FMT_YUV_P012:
+	case MTKCAM_IPI_IMG_FMT_YVU_P012:
+	case MTKCAM_IPI_IMG_FMT_YUV_P212_PACKED:
+	case MTKCAM_IPI_IMG_FMT_YVU_P212_PACKED:
+	case MTKCAM_IPI_IMG_FMT_YUV_P012_PACKED:
+	case MTKCAM_IPI_IMG_FMT_YVU_P012_PACKED:
+	case MTKCAM_IPI_IMG_FMT_UFBC_NV12:
+	case MTKCAM_IPI_IMG_FMT_UFBC_NV21:
+	case MTKCAM_IPI_IMG_FMT_UFBC_YUV_P010:
+	case MTKCAM_IPI_IMG_FMT_UFBC_YVU_P010:
+	case MTKCAM_IPI_IMG_FMT_UFBC_YUV_P012:
+	case MTKCAM_IPI_IMG_FMT_UFBC_YVU_P012:
+	case MTKCAM_IPI_IMG_FMT_UFBC_BAYER8:
+	case MTKCAM_IPI_IMG_FMT_UFBC_BAYER10:
+	case MTKCAM_IPI_IMG_FMT_UFBC_BAYER12:
+	case MTKCAM_IPI_IMG_FMT_UFBC_BAYER14:
+	case MTKCAM_IPI_IMG_FMT_FG_BAYER8_3P:
+	case MTKCAM_IPI_IMG_FMT_FG_BAYER10_3P_PACKED:
+	case MTKCAM_IPI_IMG_FMT_FG_BAYER12_3P_PACKED:
+		mtk_cam_fill_pixfmt_mp(mp, mp->pixelformat, width, height);
+	break;
+	default:
+		break;
+	}
+}
+
+static int mtk_video_init_format(struct mtk_cam_video_device *video)
+{
+	struct mtk_cam_dev_node_desc *desc = &video->desc;
+	struct v4l2_format *active = &video->active_fmt;
+	const struct v4l2_format *default_fmt =
+		&desc->fmts[desc->default_fmt_idx].vfmt;
+
+	active->type = desc->buf_type;
+
+	if (!desc->image) {
+		active->fmt.meta.dataformat = default_fmt->fmt.meta.dataformat;
+		active->fmt.meta.buffersize = default_fmt->fmt.meta.buffersize;
+		return 0;
+	}
+
+	active->fmt.pix_mp.pixelformat = default_fmt->fmt.pix_mp.pixelformat;
+	active->fmt.pix_mp.width = default_fmt->fmt.pix_mp.width;
+	active->fmt.pix_mp.height = default_fmt->fmt.pix_mp.height;
+	active->fmt.pix_mp.num_planes = default_fmt->fmt.pix_mp.num_planes;
+
+	cal_image_pix_mp(desc->id, &active->fmt.pix_mp, 0);
+
+	/**
+	 * TODO: to support multi-plane: for example, yuv or do it as
+	 * following?
+	 */
+	active->fmt.pix_mp.num_planes = 1;
+	active->fmt.pix_mp.colorspace = V4L2_COLORSPACE_SRGB;
+	active->fmt.pix_mp.field = V4L2_FIELD_NONE;
+	active->fmt.pix_mp.ycbcr_enc = V4L2_YCBCR_ENC_DEFAULT;
+	active->fmt.pix_mp.quantization = V4L2_QUANTIZATION_DEFAULT;
+	active->fmt.pix_mp.xfer_func = V4L2_XFER_FUNC_SRGB;
+
+	return 0;
+}
+
+int mtk_cam_video_register(struct mtk_cam_video_device *video,
+			   struct v4l2_device *v4l2_dev)
+{
+	struct mtk_cam_device *cam =
+		container_of(v4l2_dev, struct mtk_cam_device, v4l2_dev);
+	struct media_pad *pad = &video->pad;
+	struct video_device *vdev = &video->vdev;
+	struct vb2_queue *q = &video->vb2_q;
+	unsigned int output = V4L2_TYPE_IS_OUTPUT(video->desc.buf_type);
+	int ret;
+
+	if (video->desc.link_flags & MEDIA_LNK_FL_ENABLED)
+		video->enabled = true;
+	else
+		video->enabled = false;
+
+	mutex_init(&video->q_lock);
+
+	/* initialize vb2_queue */
+	q->type = video->desc.buf_type;
+	q->io_modes = VB2_MMAP | VB2_DMABUF;
+
+	if (q->type == V4L2_BUF_TYPE_META_OUTPUT)
+		q->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;
+	else
+		/**
+		 *  Actually we want to configure it as boot time but
+		 *  there is no such option now. We will upstream
+		 *  a new flag such as V4L2_BUF_FLAG_TIMESTAMP_BOOT
+		 *  and use that in the future.
+		 */
+		q->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_BOOT;
+
+	if (video->desc.smem_alloc)
+		q->bidirectional = 1;
+
+	if (video->uid.pipe_id >= MTKCAM_SUBDEV_CAMSV_START &&
+		video->uid.pipe_id < MTKCAM_SUBDEV_CAMSV_END) {
+		switch (video->uid.pipe_id) {
+		case MTKCAM_SUBDEV_CAMSV_0:
+		case MTKCAM_SUBDEV_CAMSV_1:
+		case MTKCAM_SUBDEV_CAMSV_4:
+#ifdef ISP7_1
+		case MTKCAM_SUBDEV_CAMSV_5:
+#ifdef FULL_CAM_SUBDEV
+		case MTKCAM_SUBDEV_CAMSV_8:
+		case MTKCAM_SUBDEV_CAMSV_9:
+		case MTKCAM_SUBDEV_CAMSV_12:
+		case MTKCAM_SUBDEV_CAMSV_13:
+#endif
+#endif
+			q->dev = find_larb(&cam->larb, 13);
+			break;
+		default:
+			q->dev = find_larb(&cam->larb, 14);
+			break;
+		}
+	} else {
+		switch (video->desc.id) {
+		case MTK_RAW_YUVO_1_OUT:
+		case MTK_RAW_YUVO_2_OUT:
+		case MTK_RAW_YUVO_3_OUT:
+		case MTK_RAW_YUVO_4_OUT:
+		case MTK_RAW_YUVO_5_OUT:
+		case MTK_RAW_DRZS4NO_1_OUT:
+		case MTK_RAW_DRZS4NO_2_OUT:
+		case MTK_RAW_DRZS4NO_3_OUT:
+		case MTK_RAW_RZH1N2TO_1_OUT:
+		case MTK_RAW_RZH1N2TO_2_OUT:
+		case MTK_RAW_RZH1N2TO_3_OUT:
+			/* should have a better implementation here */
+			q->dev = cam->raw.yuvs[0];
+			break;
+		default:
+			q->dev = cam->raw.devs[0];
+			break;
+		}
+	}
+
+	q->supports_requests = true;
+	q->lock = &video->q_lock;
+	q->ops = &mtk_cam_vb2_ops;
+	q->mem_ops = &vb2_dma_contig_memops;
+	q->drv_priv = cam;
+	q->buf_struct_size = sizeof(struct mtk_cam_buffer);
+
+	if (output)
+		q->timestamp_flags |= V4L2_BUF_FLAG_TSTAMP_SRC_EOF;
+	else
+		q->timestamp_flags |= V4L2_BUF_FLAG_TSTAMP_SRC_SOE;
+
+	/* No minimum buffers limitation */
+	q->min_buffers_needed = 0;
+
+	ret = vb2_queue_init(q);
+	if (ret < 0) {
+		dev_info(v4l2_dev->dev, "Failed to init vb2 queue: %d\n", ret);
+		goto error_vb2_init;
+	}
+
+	pad->flags = output ? MEDIA_PAD_FL_SOURCE : MEDIA_PAD_FL_SINK;
+	ret = media_entity_pads_init(&vdev->entity, 1, pad);
+	if (ret < 0) {
+		dev_info(v4l2_dev->dev, "Failed to init video entity: %d\n",
+			ret);
+		goto error_media_init;
+	}
+
+	ret = mtk_video_init_format(video);
+	if (ret < 0) {
+		dev_info(v4l2_dev->dev, "Failed to init format: %d\n", ret);
+		goto error_video_register;
+	}
+
+	vdev->entity.function = MEDIA_ENT_F_IO_V4L;
+	vdev->entity.ops = NULL;
+	vdev->fops = &mtk_cam_v4l2_fops;
+	vdev->device_caps = video->desc.cap | V4L2_CAP_STREAMING;
+	vdev->v4l2_dev = v4l2_dev;
+
+	vdev->vfl_dir = output ? VFL_DIR_TX : VFL_DIR_RX;
+	vdev->queue = &video->vb2_q;
+	vdev->ioctl_ops = video->desc.ioctl_ops;
+	vdev->release = video_device_release_empty;
+	/* TODO: share q_lock or use another lock? */
+	vdev->lock = &video->q_lock;
+	strlcpy(vdev->name, video->desc.name, sizeof(vdev->name));
+
+	ret = video_register_device(vdev, VFL_TYPE_VIDEO, -1);
+	if (ret < 0) {
+		dev_info(v4l2_dev->dev, "Failed to register video device: %d\n",
+			ret);
+		goto error_video_register;
+	}
+	video_set_drvdata(vdev, cam);
+
+	dev_dbg(v4l2_dev->dev, "registered vdev:%d:%s\n",
+		video->desc.id, vdev->name);
+
+	return 0;
+
+error_video_register:
+	media_entity_cleanup(&vdev->entity);
+error_media_init:
+	vb2_queue_release(&video->vb2_q);
+error_vb2_init:
+	mutex_destroy(&video->q_lock);
+
+	return ret;
+}
+
+void mtk_cam_video_unregister(struct mtk_cam_video_device *video)
+{
+	video_unregister_device(&video->vdev);
+	vb2_queue_release(&video->vb2_q);
+	media_entity_cleanup(&video->vdev.entity);
+	mutex_destroy(&video->q_lock);
+}
+
+const struct v4l2_format *
+mtk_cam_dev_find_fmt(struct mtk_cam_dev_node_desc *desc, u32 format)
+{
+	unsigned int i;
+	const struct v4l2_format *fmt;
+
+	for (i = 0; i < desc->num_fmts; i++) {
+		fmt = &desc->fmts[i].vfmt;
+		if (fmt->fmt.pix_mp.pixelformat == format)
+			return fmt;
+	}
+
+	return NULL;
+}
+
+int mtk_cam_vidioc_querycap(struct file *file, void *fh,
+			    struct v4l2_capability *cap)
+{
+	struct mtk_cam_device *cam = video_drvdata(file);
+
+	strscpy(cap->driver, dev_driver_string(cam->dev), sizeof(cap->driver));
+	strscpy(cap->card, dev_driver_string(cam->dev), sizeof(cap->card));
+	snprintf(cap->bus_info, sizeof(cap->bus_info), "platform:%s",
+		 dev_name(cam->dev));
+
+	return 0;
+}
+
+int mtk_cam_vidioc_enum_framesizes(struct file *filp, void *priv,
+				   struct v4l2_frmsizeenum *sizes)
+{
+	struct mtk_cam_video_device *node = file_to_mtk_cam_node(filp);
+	const struct v4l2_format *dev_fmt;
+
+	dev_fmt = mtk_cam_dev_find_fmt(&node->desc, sizes->pixel_format);
+	if (!dev_fmt || sizes->index)
+		return -EINVAL;
+
+	sizes->type = node->desc.frmsizes->type;
+	memcpy(&sizes->stepwise, &node->desc.frmsizes->stepwise,
+	       sizeof(sizes->stepwise));
+	return 0;
+}
+
+int mtk_cam_vidioc_enum_fmt(struct file *file, void *fh,
+			    struct v4l2_fmtdesc *f)
+{
+	struct mtk_cam_video_device *node = file_to_mtk_cam_node(file);
+
+	if (f->index >= node->desc.num_fmts)
+		return -EINVAL;
+
+	/* f->description is filled in v4l_fill_fmtdesc function */
+	f->pixelformat = node->desc.fmts[f->index].vfmt.fmt.pix_mp.pixelformat;
+	f->flags = 0;
+	return 0;
+}
+
+int mtk_cam_vidioc_g_fmt(struct file *file, void *fh,
+			 struct v4l2_format *f)
+{
+	struct mtk_cam_video_device *node = file_to_mtk_cam_node(file);
+
+	f->fmt = node->active_fmt.fmt;
+
+	return 0;
+}
+
+int mtk_cam_collect_vfmt(struct mtk_raw_pipeline *pipe,
+	struct mtk_cam_video_device *node,
+	struct v4l2_format *f)
+{
+	pipe->req_vfmt_update |= (1 << node->desc.id);
+	node->pending_fmt = *f;
+
+	return 0;
+}
+
+int mtk_cam_vidioc_s_fmt(struct file *file, void *fh,
+			 struct v4l2_format *f)
+{
+	struct mtk_cam_device *cam = video_drvdata(file);
+	struct mtk_cam_video_device *node = file_to_mtk_cam_node(file);
+	struct mtk_raw_pipeline *raw_pipeline;
+	int raw_feature = 0;
+
+	raw_pipeline = mtk_cam_dev_get_raw_pipeline(cam, node->uid.pipe_id);
+
+	if (!vb2_is_busy(node->vdev.queue)) {
+		/* Get the valid format */
+		if (raw_pipeline)
+			raw_feature = raw_pipeline->user_res.raw_res.feature;
+
+		mtk_cam_video_set_fmt(node, f, raw_feature);
+
+		/* Configure to video device */
+		node->active_fmt = *f;
+		return 0;
+	}
+
+	if (raw_pipeline)
+		mtk_cam_collect_vfmt(raw_pipeline, node, f);
+	dev_dbg(cam->dev,
+		"%s:pipe(%d):%s:pending s_fmt: pixelfmt(0x%x), w(%d), h(%d)\n",
+		__func__, node->uid.pipe_id, node->desc.name,
+		f->fmt.pix_mp.pixelformat,  f->fmt.pix_mp.width, f->fmt.pix_mp.height);
+
+	return 0;
+}
+
+int mtk_cam_video_set_fmt(struct mtk_cam_video_device *node, struct v4l2_format *f, int raw_feature)
+{
+	struct mtk_cam_device *cam = video_get_drvdata(&node->vdev);
+	const struct v4l2_format *dev_fmt;
+	struct v4l2_format try_fmt;
+	s32 i;
+	u32 bytesperline, sizeimage;
+	u32 is_hdr = 0, is_hdr_m2m = 0;
+
+	dev_dbg(cam->dev,
+			"%s:pipe(%d):%s:feature(0x%x)\n",
+			__func__, node->uid.pipe_id, node->desc.name, raw_feature);
+
+	memset(&try_fmt, 0, sizeof(try_fmt));
+	try_fmt.type = f->type;
+
+	/* Validate pixelformat */
+	dev_fmt = mtk_cam_dev_find_fmt(&node->desc, f->fmt.pix_mp.pixelformat);
+	if (!dev_fmt) {
+		dev_dbg(cam->dev, "unknown fmt:%d\n",
+			f->fmt.pix_mp.pixelformat);
+		dev_fmt = &node->desc.fmts[node->desc.default_fmt_idx].vfmt;
+	}
+	try_fmt.fmt.pix_mp.pixelformat = dev_fmt->fmt.pix_mp.pixelformat;
+
+	/* Validate image width & height range */
+	try_fmt.fmt.pix_mp.width = clamp_val(f->fmt.pix_mp.width,
+					     IMG_MIN_WIDTH, IMG_MAX_WIDTH);
+	try_fmt.fmt.pix_mp.height = clamp_val(f->fmt.pix_mp.height,
+					      IMG_MIN_HEIGHT, IMG_MAX_HEIGHT);
+	/* 4 bytes alignment for width */
+	/* Todo: width and stride should align bus_size */
+	try_fmt.fmt.pix_mp.width = ALIGN(try_fmt.fmt.pix_mp.width, IMG_PIX_ALIGN);
+	try_fmt.fmt.pix_mp.num_planes = 1;
+
+	if (raw_feature & MTK_CAM_FEATURE_HDR_MASK) {
+		if (raw_feature & MTK_CAM_FEATURE_OFFLINE_M2M_MASK)
+			is_hdr_m2m = 1;
+		else
+			is_hdr = 1;
+	}
+
+	/* support 1/2/3 plane */
+	/* Note: vhdr m2m main stream is implicitly multiple plane */
+	/* but not nego through try format */
+	if ((node->desc.id == MTK_RAW_MAIN_STREAM_OUT && is_hdr) ||
+		(node->desc.id == MTK_RAW_RAWI_2_IN && is_hdr_m2m)) {
+
+		switch (raw_feature & MTK_CAM_FEATURE_HDR_MASK) {
+		case STAGGER_2_EXPOSURE_LE_SE:
+		case STAGGER_2_EXPOSURE_SE_LE:
+		case MSTREAM_NE_SE:
+		case MSTREAM_SE_NE:
+			try_fmt.fmt.pix_mp.num_planes = 2;
+			break;
+		case STAGGER_3_EXPOSURE_LE_NE_SE:
+		case STAGGER_3_EXPOSURE_SE_NE_LE:
+			try_fmt.fmt.pix_mp.num_planes = 3;
+			break;
+		default:
+			try_fmt.fmt.pix_mp.num_planes = 1;
+		}
+	}
+
+	for (i = 0 ; i < try_fmt.fmt.pix_mp.num_planes ; i++)
+		try_fmt.fmt.pix_mp.plane_fmt[i].bytesperline =
+				f->fmt.pix_mp.plane_fmt[i].bytesperline;
+
+	/* bytesperline & sizeimage calculation */
+	if (node->desc.dma_port == MTKCAM_IPI_CAMSV_MAIN_OUT)
+		cal_image_pix_mp(node->desc.id, &try_fmt.fmt.pix_mp, 3);
+	else
+		cal_image_pix_mp(node->desc.id, &try_fmt.fmt.pix_mp, 0);
+
+	/* subsample */
+	if (node->desc.id >= MTK_RAW_MAIN_STREAM_OUT &&
+		node->desc.id < MTK_RAW_RZH1N2TO_1_OUT &&
+		(mtk_cam_feature_is_subsample(raw_feature))) {
+		switch (raw_feature) {
+		case HIGHFPS_2_SUBSAMPLE:
+			try_fmt.fmt.pix_mp.num_planes = 2;
+			break;
+		case HIGHFPS_4_SUBSAMPLE:
+			try_fmt.fmt.pix_mp.num_planes = 4;
+			break;
+		case HIGHFPS_8_SUBSAMPLE:
+			try_fmt.fmt.pix_mp.num_planes = 8;
+			break;
+		case HIGHFPS_16_SUBSAMPLE:
+			try_fmt.fmt.pix_mp.num_planes =
+				MAX_SUBSAMPLE_PLANE_NUM;
+			break;
+		default:
+			try_fmt.fmt.pix_mp.num_planes = 1;
+		}
+		bytesperline = try_fmt.fmt.pix_mp.plane_fmt[0].bytesperline;
+		sizeimage = try_fmt.fmt.pix_mp.plane_fmt[0].sizeimage;
+		for (i = 0 ; i < try_fmt.fmt.pix_mp.num_planes ; i++) {
+			try_fmt.fmt.pix_mp.plane_fmt[i].bytesperline =
+				bytesperline;
+			try_fmt.fmt.pix_mp.plane_fmt[i].sizeimage =
+				sizeimage;
+		}
+		dev_info(cam->dev, "%s id:%d raw_feature:0x%x stride:%d size:%d\n",
+			__func__, node->desc.id, raw_feature,
+			bytesperline, sizeimage);
+	}
+	/* add header size for vc channel */
+	if (node->desc.dma_port == MTKCAM_IPI_CAMSV_MAIN_OUT &&
+		node->desc.id == MTK_CAMSV_MAIN_STREAM_OUT)
+		try_fmt.fmt.pix_mp.plane_fmt[0].sizeimage +=
+		mtk_cam_get_meta_size(MTKCAM_IPI_CAMSV_MAIN_OUT);
+	/* Constant format fields */
+	try_fmt.fmt.pix_mp.colorspace = V4L2_COLORSPACE_SRGB;
+	try_fmt.fmt.pix_mp.field = V4L2_FIELD_NONE;
+	try_fmt.fmt.pix_mp.ycbcr_enc = V4L2_YCBCR_ENC_DEFAULT;
+	try_fmt.fmt.pix_mp.quantization = V4L2_QUANTIZATION_DEFAULT;
+	try_fmt.fmt.pix_mp.xfer_func = V4L2_XFER_FUNC_SRGB;
+
+	*f = try_fmt;
+
+	return 0;
+}
+
+int mtk_cam_vidioc_try_fmt(struct file *file, void *fh,
+			   struct v4l2_format *f)
+{
+	struct mtk_cam_video_device *node = file_to_mtk_cam_node(file);
+	int raw_feature = 0;
+
+	if (is_raw_subdev(node->uid.pipe_id))
+		raw_feature = mtk_cam_fmt_get_raw_feature(&f->fmt.pix_mp);
+
+	mtk_cam_video_set_fmt(node, f, raw_feature);
+
+	return 0;
+}
+
+int mtk_cam_vidioc_meta_enum_fmt(struct file *file, void *fh,
+				 struct v4l2_fmtdesc *f)
+{
+	struct mtk_cam_video_device *node = file_to_mtk_cam_node(file);
+
+	if (f->index)
+		return -EINVAL;
+
+	/* f->description is filled in v4l_fill_fmtdesc function */
+	f->pixelformat = node->active_fmt.fmt.meta.dataformat;
+	f->flags = 0;
+
+	return 0;
+}
+
+int mtk_cam_vidioc_g_meta_fmt(struct file *file, void *fh,
+			      struct v4l2_format *f)
+{
+	struct mtk_cam_device *cam = video_drvdata(file);
+	struct mtk_cam_video_device *node = file_to_mtk_cam_node(file);
+	struct mtk_cam_dev_node_desc *desc = &node->desc;
+	const struct v4l2_format *default_fmt =
+		&desc->fmts[desc->default_fmt_idx].vfmt;
+	struct mtk_raw_pde_config *pde_cfg;
+	struct mtk_cam_pde_info *pde_info;
+
+	if (node->desc.dma_port == MTKCAM_IPI_RAW_META_STATS_CFG) {
+		pde_cfg = &cam->raw.pipelines[node->uid.pipe_id].pde_config;
+		pde_info = &pde_cfg->pde_info;
+		if (pde_info->pd_table_offset) {
+			node->active_fmt.fmt.meta.buffersize =
+				default_fmt->fmt.meta.buffersize
+				+ pde_info->pdi_max_size;
+			dev_dbg(cam->dev, "PDE: node(%d), enlarge meta size(%d)",
+				node->desc.dma_port,
+				node->active_fmt.fmt.meta.buffersize);
+		}
+	}
+	if (node->desc.dma_port == MTKCAM_IPI_RAW_META_STATS_0) {
+		pde_cfg = &cam->raw.pipelines[node->uid.pipe_id].pde_config;
+		pde_info = &pde_cfg->pde_info;
+		if (pde_info->pd_table_offset) {
+			node->active_fmt.fmt.meta.buffersize =
+				default_fmt->fmt.meta.buffersize
+				+ pde_info->pdo_max_size;
+			dev_dbg(cam->dev, "PDE: node(%d), enlarge meta size(%d)",
+				node->desc.dma_port,
+				node->active_fmt.fmt.meta.buffersize);
+		}
+	}
+	f->fmt.meta.dataformat = node->active_fmt.fmt.meta.dataformat;
+	f->fmt.meta.buffersize = node->active_fmt.fmt.meta.buffersize;
+
+	return 0;
+}
+
+int mtk_cam_collect_vsel(struct mtk_raw_pipeline *pipe,
+			 struct mtk_cam_video_device *node,
+				struct v4l2_selection *s)
+{
+	pipe->req_vsel_update |= (1 << node->desc.id); /* debug only*/
+	node->pending_crop = *s;
+
+	dev_dbg(pipe->subdev.v4l2_dev->dev,
+		"%s:%s:%s:pending vidioc_s_selection (%d,%d,%d,%d)\n",
+		__func__, pipe->subdev.name, node->desc.name,
+		s->r.left, s->r.top, s->r.width, s->r.height);
+
+			return 0;
+}
+
+int mtk_cam_vidioc_s_selection(struct file *file, void *fh,
+				struct v4l2_selection *s)
+{
+	struct mtk_cam_device *cam = video_drvdata(file);
+	struct mtk_cam_video_device *node = file_to_mtk_cam_node(file);
+	struct mtk_raw_pipeline *raw_pipeline;
+
+	raw_pipeline = mtk_cam_dev_get_raw_pipeline(cam, node->uid.pipe_id);
+	if (raw_pipeline)
+		mtk_cam_collect_vsel(raw_pipeline, node, s);
+
+	return 0;
+}
+
+void mtk_cam_fmt_set_raw_feature(struct v4l2_pix_format_mplane *fmt_mp, int raw_feature)
+{
+	u8 *reserved = fmt_mp->reserved;
+
+	fmt_mp->flags = raw_feature & 0x000000FF;
+	reserved[4] = (raw_feature & 0x0000FF00) >> 8;
+	reserved[5] = (raw_feature & 0x00FF0000) >> 16;
+	reserved[6] = (raw_feature & 0xFF000000) >> 24;
+}
+
+int mtk_cam_fmt_get_raw_feature(struct v4l2_pix_format_mplane *fmt_mp)
+{
+	int raw_feature = fmt_mp->flags;
+
+	/**
+	 * Current 8 bits flag is not enough so we also use the reserved[4-6] to
+	 * save the feature flags.
+	 */
+	raw_feature |= ((unsigned int)fmt_mp->reserved[4]) << 8 & 0x0000FF00;
+	raw_feature |= ((unsigned int)fmt_mp->reserved[5]) << 16 & 0x00FF0000;
+	raw_feature |= ((unsigned int)fmt_mp->reserved[6]) << 24 & 0xFF000000;
+
+	return raw_feature;
+}
+
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam-video.h b/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam-video.h
new file mode 100755
index 0000000000000000000000000000000000000000..a92df48cd25fd1095921e209918f457593f4074f
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam-video.h
@@ -0,0 +1,227 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2022 MediaTek Inc.
+ */
+
+#ifndef __MTK_CAM_VIDEO_H
+#define __MTK_CAM_VIDEO_H
+
+#include <linux/types.h>
+#include <linux/videodev2.h>
+#include <media/media-entity.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-dev.h>
+#include <media/videobuf2-core.h>
+#include <media/videobuf2-v4l2.h>
+
+#include "mtk_cam-ipi.h"
+
+#define MAX_PLANE_NUM 3
+#define MAX_SUBSAMPLE_PLANE_NUM 8
+
+struct mtk_cam_device;
+struct mtk_cam_resource;
+struct mtk_raw_pde_config;
+
+typedef int (*set_pad_fmt_func_t)(struct v4l2_subdev *sd,
+			struct v4l2_subdev_state *sd_state,
+			struct v4l2_mbus_framefmt *sink_fmt,
+			struct mtk_cam_resource *res,
+			int pad, int which);
+
+typedef int (*set_pad_selection_func_t)(struct v4l2_subdev *sd,
+			struct v4l2_subdev_state *sd_state,
+			struct v4l2_mbus_framefmt *sink_fmt,
+			struct mtk_cam_resource *res,
+			int pad, int which);
+
+/*
+ * struct mtk_cam_buffer - MTK camera device buffer.
+ *
+ * @vb: Embedded struct vb2_v4l2_buffer.
+ * @queue: List entry of the object
+ * @daddr: The DMA address of this buffer.
+ * @scp_addr: The SCP address of this buffer which
+ *            is only supported for meta input node.
+ *
+ */
+struct mtk_cam_buffer {
+	struct vb2_v4l2_buffer vbb;
+	struct list_head list;
+	struct list_head stream_data_list;
+
+	dma_addr_t daddr;
+	dma_addr_t scp_addr;
+};
+
+struct mtk_cam_format_desc {
+	struct v4l2_format vfmt;
+	struct v4l2_mbus_framefmt pfmt;
+};
+
+struct mtk_cam_pad_ops {
+	set_pad_fmt_func_t set_pad_fmt;
+	set_pad_selection_func_t set_pad_selection;
+};
+
+/*
+ * struct mtk_cam_dev_node_desc - MTK camera device node descriptor
+ *
+ * @id: id of the node
+ * @name: name of the node
+ * @cap: supported V4L2 capabilities
+ * @buf_type: supported V4L2 buffer type
+ * @dma_port: the dma ports associated to the node
+ * @link_flags: default media link flags
+ * @smem_alloc: using the smem_dev as alloc device or not
+ * @need_cache_sync_on_prepare: do cache sync at buf_prepare
+ * @need_cache_sync_on_finish: do cache sync at buf_finish
+ * @image: true for image node, false for meta node
+ * @num_fmts: the number of supported node formats
+ * @default_fmt_idx: default format of this node
+ * @max_buf_count: maximum VB2 buffer count
+ * @ioctl_ops:  mapped to v4l2_ioctl_ops
+ * @fmts: supported format
+ * @frmsizes: supported V4L2 frame size number
+ *
+ */
+struct mtk_cam_dev_node_desc {
+	u8 id;
+	const char *name;
+	u32 cap;
+	u32 buf_type;
+	u32 dma_port;
+	u32 link_flags;
+	u8 smem_alloc:1;
+	u8 need_cache_sync_on_prepare:1;
+	u8 need_cache_sync_on_finish:1;
+	u8 image:1;
+	u8 num_fmts;
+	u8 default_fmt_idx;
+	u8 max_buf_count;
+	const struct v4l2_ioctl_ops *ioctl_ops;
+	const struct mtk_cam_format_desc *fmts;
+	const struct v4l2_frmsizeenum *frmsizes;
+	struct mtk_cam_pad_ops *pad_ops;
+};
+
+/*
+ * struct mtk_cam_video_device - Mediatek video device structure.
+ *
+ * FIXME
+ *
+ */
+struct mtk_cam_video_device {
+	struct mtkcam_ipi_uid uid;
+	struct mtk_cam_dev_node_desc desc;
+	unsigned int enabled;
+
+	struct vb2_queue vb2_q;
+	struct video_device vdev;
+	struct media_pad pad;
+	struct v4l2_format active_fmt;
+	/* use first 4 elements of reserved field of v4l2_pix_format_mplane as request fd */
+	struct v4l2_format pending_fmt;
+	/* use first elements of reserved field of v4l2_selection as request fd*/
+	struct v4l2_selection pending_crop;
+	/* Serializes vb2 queue and video device operations */
+	struct mutex q_lock;
+	int streaming_id;
+
+	/* cached ctx info */
+	struct mtk_cam_ctx *ctx;
+};
+
+struct mtk_format_info {
+	u32 format;
+	u8 mem_planes;
+	u8 comp_planes;
+	u8 bpp[4];
+	u8 hdiv;
+	u8 vdiv;
+	/* numerator of bit ratio */
+	u8 bit_r_num;
+	/* denominator of bit ratio */
+	u8 bit_r_den;
+};
+
+int mtk_cam_fmt_get_raw_feature(struct v4l2_pix_format_mplane *fmt_mp);
+void mtk_cam_fmt_set_raw_feature(struct v4l2_pix_format_mplane *fmt_mp, int raw_feature);
+int mtk_cam_video_register(struct mtk_cam_video_device *video,
+			   struct v4l2_device *v4l2_dev);
+void mtk_cam_video_unregister(struct mtk_cam_video_device *video);
+
+static inline struct mtk_cam_video_device *
+file_to_mtk_cam_node(struct file *__file)
+{
+	return container_of(video_devdata(__file),
+		struct mtk_cam_video_device, vdev);
+}
+
+static inline struct mtk_cam_buffer *
+mtk_cam_vb2_buf_to_dev_buf(struct vb2_buffer *__vb)
+{
+	return container_of(__vb, struct mtk_cam_buffer, vbb.vb2_buf);
+}
+
+static inline struct mtk_cam_video_device *
+mtk_cam_vbq_to_vdev(struct vb2_queue *__vq)
+{
+	return container_of(__vq, struct mtk_cam_video_device, vb2_q);
+}
+
+const struct v4l2_format *
+mtk_cam_dev_find_fmt(struct mtk_cam_dev_node_desc *desc, u32 format);
+
+int mtk_cam_vidioc_querycap(struct file *file, void *fh,
+			    struct v4l2_capability *cap);
+
+int mtk_cam_vidioc_enum_framesizes(struct file *filp, void *priv,
+				   struct v4l2_frmsizeenum *sizes);
+
+int mtk_cam_vidioc_enum_fmt(struct file *file, void *fh,
+			    struct v4l2_fmtdesc *f);
+
+int mtk_cam_vidioc_g_fmt(struct file *file, void *fh,
+			 struct v4l2_format *f);
+
+int mtk_cam_vidioc_s_fmt(struct file *file, void *fh,
+			 struct v4l2_format *f);
+
+int mtk_cam_vidioc_try_fmt(struct file *file, void *fh,
+			   struct v4l2_format *f);
+
+int mtk_cam_vidioc_meta_enum_fmt(struct file *file, void *fh,
+				 struct v4l2_fmtdesc *f);
+
+int mtk_cam_vidioc_s_selection(struct file *file, void *fh,
+				struct v4l2_selection *s);
+
+int mtk_cam_vidioc_g_meta_fmt(struct file *file, void *fh,
+			      struct v4l2_format *f);
+
+/* Utility functions to convert format enum */
+unsigned int mtk_cam_get_sensor_pixel_id(unsigned int fmt);
+
+unsigned int mtk_cam_get_sensor_fmt(unsigned int fmt);
+
+unsigned int mtk_cam_get_pixel_bits(unsigned int pix_fmt);
+
+unsigned int mtk_cam_get_img_fmt(unsigned int fourcc);
+
+void mtk_cam_set_meta_stats_info(u32 dma_port, void *vaddr,
+				 struct mtk_raw_pde_config *pde_cfg);
+
+int mtk_cam_video_set_fmt(struct mtk_cam_video_device *node, struct v4l2_format *f, int feature);
+
+int is_mtk_format(u32 pixelformat);
+
+int is_yuv_ufo(u32 pixelformat);
+
+int is_raw_ufo(u32 pixelformat);
+
+int is_fullg_rb(u32 pixelformat);
+
+const struct mtk_format_info *mtk_format_info(u32 format);
+
+#endif /*__MTK_CAM_VIDEO_H*/
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam.c b/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam.c
new file mode 100755
index 0000000000000000000000000000000000000000..2f29506c0641e4fc6866f0b519104b1d47d5ad4e
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam.c
@@ -0,0 +1,7196 @@
+// SPDX-License-Identifier: GPL-2.0
+//
+// Copyright (c) 2022 MediaTek Inc.
+
+#include <linux/component.h>
+#include <linux/iopoll.h>
+#include <linux/module.h>
+#include <linux/of_platform.h>
+#include <linux/platform_device.h>
+
+#include <linux/pm_runtime.h>
+#include <linux/remoteproc.h>
+#include <linux/remoteproc/mtk_scp.h>
+
+#include <linux/types.h>
+#include <linux/videodev2.h>
+#include <media/videobuf2-v4l2.h>
+#include <media/v4l2-fwnode.h>
+#include <media/v4l2-mc.h>
+#include <media/v4l2-subdev.h>
+
+#include "mtk_cam.h"
+#include "mtk_cam-ctrl.h"
+#include "mtk_cam-feature.h"
+#include "mtk_cam_pm.h"
+#include "mtk_cam-pool.h"
+#ifdef ISP7_1
+#include "mtk_cam-regs-mt8188.h"
+#else
+#include "mtk_cam-regs-mt8195.h"
+#endif
+#include "mtk_camera-v4l2-controls.h"
+#include "mtk_cam-ufbc-def.h"
+#include "mtk_cam-timesync.h"
+
+#ifdef CONFIG_VIDEO_MTK_ISP_CAMSYS_DUBUG
+static unsigned int debug_ae = 1;
+#else
+static unsigned int debug_ae;
+#endif
+module_param(debug_ae, uint, 0644);
+MODULE_PARM_DESC(debug_ae, "activates debug ae info");
+
+/* FIXME for CIO pad id */
+#define MTK_CAM_CIO_PAD_SRC		PAD_SRC_RAW0
+#define MTK_CAM_CIO_PAD_SINK		MTK_RAW_SINK
+#define MTK_CAM_IPI_SEND_TIMEOUT                1000
+/* Zero out the end of the struct pointed to by p.  Everything after, but
+ * not including, the specified field is cleared.
+ */
+#define CLEAR_AFTER_FIELD(p, field) \
+	memset((u8 *)(p) + offsetof(typeof(*(p)), field) + sizeof((p)->field), \
+	0, sizeof(*(p)) - offsetof(typeof(*(p)), field) -sizeof((p)->field))
+
+static const struct of_device_id mtk_cam_of_ids[] = {
+	{.compatible = "mediatek,camisp",},
+	{}
+};
+
+MODULE_DEVICE_TABLE(of, mtk_cam_of_ids);
+
+static void mtk_cam_register_iommu_tf_callback(struct mtk_raw_device *raw)
+{
+#ifdef CAMSYS_TF_DUMP_71_1
+	dev_dbg(raw->dev, "%s : raw->id:%d\n", __func__, raw->id);
+
+	if (raw->id == RAW_A) {
+		mtk_iommu_register_fault_callback(M4U_PORT_L16_CAM2_IMGP_R1,
+			mtk_cam_translation_fault_callback, (void *)raw, false);
+
+		mtk_iommu_register_fault_callback(M4U_PORT_L16_CAM2_CQI_R1,
+			mtk_cam_translation_fault_callback, (void *)raw, false);
+
+		mtk_iommu_register_fault_callback(M4U_PORT_L16_CAM2_CQI_R2,
+			mtk_cam_translation_fault_callback, (void *)raw, false);
+
+		mtk_iommu_register_fault_callback(M4U_PORT_L16_CAM2_FHO_R1,
+			mtk_cam_translation_fault_callback, (void *)raw, false);
+
+		mtk_iommu_register_fault_callback(M4U_PORT_L16_CAM2_AAO_R1,
+			mtk_cam_translation_fault_callback, (void *)raw, false);
+
+		mtk_iommu_register_fault_callback(M4U_PORT_L16_CAM2_TSFSO_R1,
+			mtk_cam_translation_fault_callback, (void *)raw, false);
+
+		mtk_iommu_register_fault_callback(M4U_PORT_L16_CAM2_FLKO_R1,
+			mtk_cam_translation_fault_callback, (void *)raw, false);
+
+		mtk_iommu_register_fault_callback(M4U_PORT_L16_CAM2_RAWI_R2,
+			mtk_cam_translation_fault_callback, (void *)raw, false);
+
+		mtk_iommu_register_fault_callback(M4U_PORT_L16_CAM2_RAWI_R3,
+			mtk_cam_translation_fault_callback, (void *)raw, false);
+
+		mtk_iommu_register_fault_callback(M4U_PORT_L17_CAM3_YUVO_R1,
+			mtk_cam_translation_fault_callback, (void *)raw, false);
+
+		mtk_iommu_register_fault_callback(M4U_PORT_L17_CAM3_YUVO_R3,
+			mtk_cam_translation_fault_callback, (void *)raw, false);
+
+		mtk_iommu_register_fault_callback(M4U_PORT_L17_CAM3_YUVCO_R1,
+			mtk_cam_translation_fault_callback, (void *)raw, false);
+
+		mtk_iommu_register_fault_callback(M4U_PORT_L17_CAM3_YUVO_R2,
+			mtk_cam_translation_fault_callback, (void *)raw, false);
+
+		mtk_iommu_register_fault_callback(M4U_PORT_L17_CAM3_RZH1N2TO_R1,
+			mtk_cam_translation_fault_callback, (void *)raw, false);
+
+		mtk_iommu_register_fault_callback(M4U_PORT_L17_CAM3_DRZS4NO_R1,
+			mtk_cam_translation_fault_callback, (void *)raw, false);
+
+		mtk_iommu_register_fault_callback(M4U_PORT_L17_CAM3_TNCSO_R1,
+			mtk_cam_translation_fault_callback, (void *)raw, false);
+	} else if (raw->id == RAW_B) {
+		mtk_iommu_register_fault_callback(M4U_PORT_L27_CAM2_IMGP_R1,
+			mtk_cam_translation_fault_callback, (void *)raw, false);
+
+		mtk_iommu_register_fault_callback(M4U_PORT_L27_CAM2_CQI_R1,
+			mtk_cam_translation_fault_callback, (void *)raw, false);
+
+		mtk_iommu_register_fault_callback(M4U_PORT_L27_CAM2_CQI_R2,
+			mtk_cam_translation_fault_callback, (void *)raw, false);
+
+		mtk_iommu_register_fault_callback(M4U_PORT_L27_CAM2_FHO_R1,
+			mtk_cam_translation_fault_callback, (void *)raw, false);
+
+		mtk_iommu_register_fault_callback(M4U_PORT_L27_CAM2_AAO_R1,
+			mtk_cam_translation_fault_callback, (void *)raw, false);
+
+		mtk_iommu_register_fault_callback(M4U_PORT_L27_CAM2_TSFSO_R1,
+			mtk_cam_translation_fault_callback, (void *)raw, false);
+
+		mtk_iommu_register_fault_callback(M4U_PORT_L27_CAM2_FLKO_R1,
+			mtk_cam_translation_fault_callback, (void *)raw, false);
+
+		mtk_iommu_register_fault_callback(M4U_PORT_L27_CAM2_RAWI_R2,
+			mtk_cam_translation_fault_callback, (void *)raw, false);
+
+		mtk_iommu_register_fault_callback(M4U_PORT_L27_CAM2_RAWI_R3,
+			mtk_cam_translation_fault_callback, (void *)raw, false);
+
+		mtk_iommu_register_fault_callback(M4U_PORT_L29_CAM3_YUVO_R1,
+			mtk_cam_translation_fault_callback, (void *)raw, false);
+
+		mtk_iommu_register_fault_callback(M4U_PORT_L29_CAM3_YUVO_R3,
+			mtk_cam_translation_fault_callback, (void *)raw, false);
+
+		mtk_iommu_register_fault_callback(M4U_PORT_L29_CAM3_YUVCO_R1,
+			mtk_cam_translation_fault_callback, (void *)raw, false);
+
+		mtk_iommu_register_fault_callback(M4U_PORT_L29_CAM3_YUVO_R2,
+			mtk_cam_translation_fault_callback, (void *)raw, false);
+
+		mtk_iommu_register_fault_callback(M4U_PORT_L29_CAM3_RZH1N2TO_R1,
+			mtk_cam_translation_fault_callback, (void *)raw, false);
+
+		mtk_iommu_register_fault_callback(M4U_PORT_L29_CAM3_DRZS4NO_R1,
+			mtk_cam_translation_fault_callback, (void *)raw, false);
+
+		mtk_iommu_register_fault_callback(M4U_PORT_L29_CAM3_TNCSO_R1,
+			mtk_cam_translation_fault_callback, (void *)raw, false);
+	} else if (raw->id == RAW_C) {
+		mtk_iommu_register_fault_callback(M4U_PORT_L28_CAM2_IMGP_R1,
+			mtk_cam_translation_fault_callback, (void *)raw, false);
+
+		mtk_iommu_register_fault_callback(M4U_PORT_L28_CAM2_CQI_R1,
+			mtk_cam_translation_fault_callback, (void *)raw, false);
+
+		mtk_iommu_register_fault_callback(M4U_PORT_L28_CAM2_CQI_R2,
+			mtk_cam_translation_fault_callback, (void *)raw, false);
+
+		mtk_iommu_register_fault_callback(M4U_PORT_L28_CAM2_FHO_R1,
+			mtk_cam_translation_fault_callback, (void *)raw, false);
+
+		mtk_iommu_register_fault_callback(M4U_PORT_L28_CAM2_AAO_R1,
+			mtk_cam_translation_fault_callback, (void *)raw, false);
+
+		mtk_iommu_register_fault_callback(M4U_PORT_L28_CAM2_TSFSO_R1,
+			mtk_cam_translation_fault_callback, (void *)raw, false);
+
+		mtk_iommu_register_fault_callback(M4U_PORT_L28_CAM2_FLKO_R1,
+			mtk_cam_translation_fault_callback, (void *)raw, false);
+
+		mtk_iommu_register_fault_callback(M4U_PORT_L28_CAM2_RAWI_R2,
+			mtk_cam_translation_fault_callback, (void *)raw, false);
+
+		mtk_iommu_register_fault_callback(M4U_PORT_L28_CAM2_RAWI_R3,
+			mtk_cam_translation_fault_callback, (void *)raw, false);
+
+		mtk_iommu_register_fault_callback(M4U_PORT_L30_CAM3_YUVO_R1,
+			mtk_cam_translation_fault_callback, (void *)raw, false);
+
+		mtk_iommu_register_fault_callback(M4U_PORT_L30_CAM3_YUVO_R3,
+			mtk_cam_translation_fault_callback, (void *)raw, false);
+
+		mtk_iommu_register_fault_callback(M4U_PORT_L30_CAM3_YUVCO_R1,
+			mtk_cam_translation_fault_callback, (void *)raw, false);
+
+		mtk_iommu_register_fault_callback(M4U_PORT_L30_CAM3_YUVO_R2,
+			mtk_cam_translation_fault_callback, (void *)raw, false);
+
+		mtk_iommu_register_fault_callback(M4U_PORT_L30_CAM3_RZH1N2TO_R1,
+			mtk_cam_translation_fault_callback, (void *)raw, false);
+
+		mtk_iommu_register_fault_callback(M4U_PORT_L30_CAM3_DRZS4NO_R1,
+			mtk_cam_translation_fault_callback, (void *)raw, false);
+
+		mtk_iommu_register_fault_callback(M4U_PORT_L30_CAM3_TNCSO_R1,
+			mtk_cam_translation_fault_callback, (void *)raw, false);
+	}
+#endif
+}
+
+/**
+ * All member of mtk_cam_request which may be used after
+ * media_request_ioctl_reinit and before next media_request_ioctl_queue
+ * must be clean here.
+ */
+static void mtk_cam_req_clean(struct mtk_cam_request *req)
+{
+	req->ctx_link_update = 0;
+}
+
+/**
+ * All member of mtk_cam_request_stream_data which may be used
+ * after media_request_ioctl_reinit and before the next
+ * media_request_ioctl_queue must be clean here. For
+ * example, the pending set fmt, set selection, and sensor
+ * switch extension of camsys driver.
+ */
+static void
+mtk_cam_req_s_data_clean(struct mtk_cam_request_stream_data *s_data)
+{
+	s_data->seninf_old = NULL;
+	s_data->seninf_new = NULL;
+	s_data->sensor = NULL;
+	s_data->pad_fmt_update = 0;
+	s_data->vdev_fmt_update = 0;
+	s_data->vdev_selection_update = 0;
+	s_data->flags = 0;
+}
+
+static void
+mtk_cam_req_pipe_s_data_clean(struct mtk_cam_request *req, int pipe_id,
+			      int index)
+{
+	struct mtk_cam_request_stream_data *req_stream_data;
+
+	req_stream_data = mtk_cam_req_get_s_data(req, pipe_id, index);
+	if (req_stream_data) {
+		mtk_cam_req_s_data_clean(req_stream_data);
+		/**
+		 * Notice that the we clean req_stream_data->bufs here so
+		 * we should not use it after this function called on it.
+		 * mtk_cam_vb2_return_all_buffers() uses another list
+		 * of mtk_cam_video_device to keep the vb2 buffers to be clean.
+		 */
+		 memset(req_stream_data->bufs, 0, sizeof(req_stream_data->bufs));
+	}
+}
+
+void mtk_cam_s_data_update_timestamp(struct mtk_cam_buffer *buf,
+				     struct mtk_cam_request_stream_data *s_data)
+{
+	struct mtk_cam_ctx *ctx;
+	struct vb2_buffer *vb;
+	struct mtk_cam_video_device *node;
+
+	ctx = mtk_cam_s_data_get_ctx(s_data);
+	if (!ctx) {
+		pr_info("%s: get ctx from s_data failed", __func__);
+		return;
+	}
+
+	vb = &buf->vbb.vb2_buf;
+	node = mtk_cam_vbq_to_vdev(vb->vb2_queue);
+
+	buf->vbb.sequence = s_data->frame_seq_no;
+	if (vb->vb2_queue->timestamp_flags & V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC)
+		vb->timestamp = s_data->timestamp_mono;
+	else
+		vb->timestamp = s_data->timestamp;
+
+	/*check buffer's timestamp*/
+	if (node->desc.dma_port == MTKCAM_IPI_RAW_META_STATS_CFG)
+		dev_dbg(ctx->cam->dev,
+			"%s:%s:vb sequence:%d, queue type:%d, timestamp_flags:0x%x, timestamp:%lld\n",
+			__func__, node->desc.name, buf->vbb.sequence,
+			vb->vb2_queue->type, vb->vb2_queue->timestamp_flags,
+			vb->timestamp);
+}
+
+static void mtk_cam_req_return_pipe_buffers(struct mtk_cam_request *req,
+					int pipe_id, int index)
+{
+	struct mtk_cam_device *cam =
+		container_of(req->req.mdev, struct mtk_cam_device, media_dev);
+	struct mtk_cam_request_stream_data *s_data_pipe;
+	struct mtk_cam_buffer *buf_ret[MTK_RAW_TOTAL_NODES];
+	struct mtk_cam_buffer *buf;
+	struct mtk_cam_video_device *node;
+	struct vb2_buffer *vb;
+	int i, buf_state, buf_start, buf_end, buf_ret_cnt;
+
+	s_data_pipe = mtk_cam_req_get_s_data(req, pipe_id, index);
+	if (!s_data_pipe) {
+		pr_info("%s: get s_data pipe failed", __func__);
+		return;
+	}
+
+	if (is_raw_subdev(pipe_id)) {
+		buf_start = MTK_RAW_SINK_NUM;
+		buf_end = MTK_RAW_PIPELINE_PADS_NUM;
+	}
+
+	if (is_camsv_subdev(pipe_id)) {
+		buf_start = MTK_CAMSV_SINK_BEGIN;
+		buf_end = MTK_CAMSV_PIPELINE_PADS_NUM;
+	}
+
+	buf_ret_cnt = 0;
+	for (i = buf_start; i < buf_end; i++) {
+		/* make sure do not touch req/s_data after vb2_buffe_done */
+		buf = mtk_cam_s_data_get_vbuf(s_data_pipe, i);
+		if (!buf)
+			continue;
+		buf_ret[buf_ret_cnt++] = buf;
+		/* clean the stream data for req reinit case */
+		mtk_cam_s_data_reset_vbuf(s_data_pipe, i);
+	}
+
+	/* clean the req_stream_data being used right after request reinit */
+	mtk_cam_req_pipe_s_data_clean(req, pipe_id, index);
+
+	buf_state = atomic_read(&s_data_pipe->buf_state);
+	if (buf_state == -1)
+		buf_state = VB2_BUF_STATE_ERROR;
+
+	dev_dbg(cam->dev,
+		"%s:%s: pipe_id(%d) buf_state(%d) buf_ret_cnt(%d)\n", __func__,
+		req->req.debug_str, pipe_id, buf_state, buf_ret_cnt);
+
+	for (i = 0; i < buf_ret_cnt; i++) {
+		buf = buf_ret[i];
+		vb = &buf->vbb.vb2_buf;
+		node = mtk_cam_vbq_to_vdev(vb->vb2_queue);
+		if (node->uid.pipe_id != pipe_id) {
+			dev_info(cam->dev,
+				"%s:%s:node(%s): invalid pipe id (%d), should be (%d)\n",
+				__func__, req->req.debug_str,
+				node->desc.name, node->uid.pipe_id, pipe_id);
+			continue;
+		}
+
+		// TODO(mstream): fill timestamp
+		if (atomic_read(&req->state) > MTK_CAM_REQ_STATE_PENDING)
+			mtk_cam_s_data_update_timestamp(buf, s_data_pipe);
+
+		vb2_buffer_done(&buf->vbb.vb2_buf, buf_state);
+	}
+}
+
+struct mtk_cam_request_stream_data*
+mtk_cam_get_req_s_data(struct mtk_cam_ctx *ctx, unsigned int pipe_id,
+			unsigned int frame_seq_no)
+
+{
+	struct mtk_cam_device *cam = ctx->cam;
+	struct mtk_cam_request *req, *req_prev;
+	struct mtk_cam_request_stream_data *req_stream_data;
+	int i;
+
+	spin_lock(&cam->running_job_lock);
+	list_for_each_entry_safe(req, req_prev, &cam->running_job_list, list) {
+		if (req->pipe_used & (1 << pipe_id)) {
+			for (i = 0; i < req->p_data[pipe_id].s_data_num; i++) {
+				req_stream_data = &req->p_data[pipe_id].s_data[i];
+				if (req_stream_data->frame_seq_no == frame_seq_no) {
+					spin_unlock(&cam->running_job_lock);
+					return req_stream_data;
+				}
+			}
+		}
+	}
+	spin_unlock(&cam->running_job_lock);
+
+	return NULL;
+}
+
+void mtk_cam_req_update_seq(struct mtk_cam_ctx *ctx, struct mtk_cam_request *req,
+					int seq)
+{
+	req->p_data[ctx->stream_id].req_seq = seq;
+}
+
+struct mtk_cam_request *mtk_cam_get_req(struct mtk_cam_ctx *ctx,
+					unsigned int frame_seq_no)
+{
+	struct mtk_cam_request_stream_data *req_stream_data;
+
+	req_stream_data = mtk_cam_get_req_s_data(ctx, ctx->stream_id, frame_seq_no);
+	if (!req_stream_data)
+		return NULL;
+
+	return req_stream_data->req;
+}
+
+bool watchdog_scenario(struct mtk_cam_ctx *ctx)
+{
+	if (ctx->sensor && !mtk_cam_is_m2m(ctx) && ctx->used_raw_num)
+		return true;
+	else
+		return false;
+}
+
+static bool finish_cq_buf(struct mtk_cam_request_stream_data *req_stream_data)
+{
+	bool result = false;
+	struct mtk_cam_ctx *ctx = req_stream_data->ctx;
+	struct mtk_cam_working_buf_entry *cq_buf_entry;
+
+	if (!ctx->used_raw_num)
+		return false;
+
+	spin_lock(&ctx->processing_buffer_list.lock);
+
+	cq_buf_entry = req_stream_data->working_buf;
+	/* Check if the cq buffer is already finished */
+	if (!cq_buf_entry || !cq_buf_entry->s_data) {
+		dev_info(ctx->cam->dev,
+			 "%s:%s:ctx(%d):req(%d):working_buf is already release\n", __func__,
+			req_stream_data->req->req.debug_str, ctx->stream_id,
+			req_stream_data->frame_seq_no);
+		spin_unlock(&ctx->processing_buffer_list.lock);
+		return false;
+	}
+
+	list_del(&cq_buf_entry->list_entry);
+	mtk_cam_s_data_reset_wbuf(req_stream_data);
+	ctx->processing_buffer_list.cnt--;
+	spin_unlock(&ctx->processing_buffer_list.lock);
+
+	mtk_cam_working_buf_put(cq_buf_entry);
+	result = true;
+
+	dev_dbg(ctx->cam->dev, "put cq buf:%pad, %s\n",
+			&cq_buf_entry->buffer.iova,
+			req_stream_data->req->req.debug_str);
+
+	return result;
+}
+
+static bool finish_img_buf(struct mtk_cam_request_stream_data *req_stream_data)
+{
+	bool result = false;
+	struct mtk_cam_ctx *ctx = req_stream_data->ctx;
+	struct mtk_cam_img_working_buf_entry *buf_entry, *buf_entry_prev;
+
+	if (!ctx->used_raw_num)
+		return false;
+
+	spin_lock(&ctx->processing_img_buffer_list.lock);
+	if (ctx->processing_img_buffer_list.cnt == 0) {
+		spin_unlock(&ctx->processing_img_buffer_list.lock);
+		return false;
+	}
+
+	list_for_each_entry_safe(buf_entry, buf_entry_prev,
+				 &ctx->processing_img_buffer_list.list,
+				 list_entry) {
+		if (buf_entry->s_data == req_stream_data) {
+			list_del(&buf_entry->list_entry);
+			mtk_cam_img_wbuf_set_s_data(buf_entry, NULL);
+			mtk_cam_img_working_buf_put(buf_entry);
+			ctx->processing_img_buffer_list.cnt--;
+			result = true;
+			dev_dbg(ctx->cam->dev, "[%s] iova:0x%llx\n",
+				__func__, buf_entry->img_buffer.iova);
+		}
+	}
+	spin_unlock(&ctx->processing_img_buffer_list.lock);
+
+	return result;
+}
+
+static void update_hw_mapping(struct mtk_cam_ctx *ctx,
+	struct mtkcam_ipi_config_param *config_param, int feature, int stagger_path,
+	int enabled_raw)
+{
+	int i, exp_no;
+	bool bDcif;
+
+	// raw
+	config_param->maps[0].pipe_id = ctx->pipe->id;
+	config_param->maps[0].dev_mask = MTKCAM_SUBDEV_RAW_MASK & ctx->used_raw_dev;
+	config_param->n_maps = 1;
+
+	if (mtk_cam_feature_is_stagger(feature)) {
+		/* check exposure number */
+		if (mtk_cam_feature_is_2_exposure(feature))
+			exp_no = 2;
+		else if (mtk_cam_feature_is_3_exposure(feature))
+			exp_no = 3;
+		else
+			exp_no = 1;
+
+		/* check stagger mode */
+		bDcif = (stagger_path == STAGGER_DCIF) ? true : false;
+
+		/* update hw maaping */
+		for (i = MTKCAM_SUBDEV_CAMSV_START; i < MTKCAM_SUBDEV_CAMSV_END; i++) {
+			if (enabled_raw & (1 << i)) {
+				if (config_param->n_maps < ARRAY_SIZE(config_param->maps)) {
+					config_param->maps[config_param->n_maps].pipe_id = i;
+					config_param->maps[config_param->n_maps].dev_mask =
+						(1 << i);
+					if (ctx->cam->sv.pipelines[i -
+						MTKCAM_SUBDEV_CAMSV_START].hw_cap &
+						(1 << CAMSV_EXP_ORDER_SHIFT))
+						config_param->maps[
+						config_param->n_maps].exp_order =
+							(bDcif && (exp_no == 1)) ? 2 : 0;
+					else if (ctx->cam->sv.pipelines[i -
+						MTKCAM_SUBDEV_CAMSV_START].hw_cap &
+						(1 << (CAMSV_EXP_ORDER_SHIFT + 1)))
+						config_param->maps[
+						config_param->n_maps].exp_order =
+							(bDcif && (exp_no == 2)) ? 2 : 1;
+					else
+						config_param->maps[
+						config_param->n_maps].exp_order = 2;
+					dev_info(ctx->cam->dev, "hw mapping pipe_id:%d exp_order:%d",
+						i,
+						config_param->maps[config_param->n_maps].exp_order);
+					config_param->n_maps++;
+				} else
+					dev_info(ctx->cam->dev, "hw mapping is over size(enable_raw:%d)",
+								ctx->pipe->enabled_raw);
+			}
+		}
+	}
+}
+
+static void mtk_cam_del_req_from_running(struct mtk_cam_ctx *ctx,
+					 struct mtk_cam_request *req, int pipe_id)
+{
+	struct mtk_cam_request_stream_data *s_data;
+
+	s_data = mtk_cam_req_get_s_data(req, ctx->stream_id, 0);
+	dev_dbg(ctx->cam->dev,
+		"%s: %s: removed, req:%d, ctx:(%d/0x%x/0x%x), pipe:(%d/0x%x/0x%x) done_status:0x%x)\n",
+		__func__, req->req.debug_str, s_data->frame_seq_no,
+		ctx->stream_id, req->ctx_used, ctx->cam->streaming_ctx,
+		pipe_id, req->pipe_used, ctx->cam->streaming_pipe,
+		req->done_status);
+
+	atomic_set(&req->state, MTK_CAM_REQ_STATE_COMPLETE);
+	spin_lock(&ctx->cam->running_job_lock);
+	list_del(&req->list);
+	ctx->cam->running_job_count--;
+	spin_unlock(&ctx->cam->running_job_lock);
+}
+
+static void mtk_cam_req_works_clean(struct mtk_cam_request_stream_data *s_data)
+{
+	struct mtk_cam_ctx *ctx = mtk_cam_s_data_get_ctx(s_data);
+	char *dbg_str = mtk_cam_s_data_get_dbg_str(s_data);
+
+	/* flush the sensor work */
+	if (atomic_read(&s_data->sensor_work.is_queued)) {
+		kthread_flush_work(&s_data->sensor_work.work);
+		dev_dbg(ctx->cam->dev,
+				"%s:ctx(%d):%s:seq(%d): flushed sensor_work\n",
+				__func__, ctx->stream_id, dbg_str, s_data->frame_seq_no);
+	}
+}
+
+static void mtk_cam_get_timestamp(struct mtk_cam_ctx *ctx,
+		struct mtk_cam_request_stream_data *s_data)
+{
+	struct mtk_cam_buffer *buf;
+	struct vb2_buffer *vb;
+	void *vaddr;
+	int subsample = 0;
+	uint64_t *pTimestamp;
+	u32 *fho_va;
+	int i;
+
+	if (ctx->used_raw_num != 0)
+		subsample =
+			mtk_cam_get_subsample_ratio(ctx->pipe->res_config.raw_feature);
+
+	buf = mtk_cam_s_data_get_vbuf(s_data, MTK_RAW_META_OUT_0);
+	if (!buf) {
+		dev_info(ctx->cam->dev,
+			 "ctx(%d): can't get MTK_RAW_META_OUT_0 buf from req(%d)\n",
+			 ctx->stream_id, s_data->frame_seq_no);
+		return;
+	}
+
+	vb = &buf->vbb.vb2_buf;
+	if (!vb) {
+		dev_info(ctx->cam->dev,
+			 "%s:ctx(%d): can't get vb2 buf\n",
+			 __func__, ctx->stream_id);
+		return;
+	}
+
+	vaddr = vb2_plane_vaddr(&buf->vbb.vb2_buf, 0);
+	if (!vaddr) {
+		dev_info(ctx->cam->dev,
+			 "%s:ctx(%d): can't get plane_vadd\n",
+			 __func__, ctx->stream_id);
+		return;
+	}
+
+	if ((s_data->working_buf->buffer.va == (void *)NULL) ||
+		s_data->working_buf->buffer.size == 0) {
+		dev_info(ctx->cam->dev,
+			 "%s:ctx(%d): can't get working_buf\n",
+			 __func__, ctx->stream_id);
+		return;
+	}
+
+	fho_va = (u32 *)(s_data->working_buf->buffer.va +
+		s_data->working_buf->buffer.size - 64 * (subsample + 1));
+
+	pTimestamp = mtk_cam_get_timestamp_addr(vaddr);
+	for (i = 0; i < (subsample + 1); i++) {
+		/* timstamp_LSB + timestamp_MSB << 32 */
+		*(pTimestamp + i*2) = mtk_cam_timesync_to_monotonic
+		((u64) (*(fho_va + i*16)) + ((u64)(*(fho_va + i*16 + 1)) << 32))
+		/1000;
+		*(pTimestamp + i*2 + 1) = mtk_cam_timesync_to_boot
+		((u64) (*(fho_va + i*16)) + ((u64)(*(fho_va + i*16 + 1)) << 32))
+		/1000;
+		dev_dbg(ctx->cam->dev,
+			"timestamp TS:momo %lld us boot %lld us, LSB:%d MSB:%d\n",
+			*(pTimestamp + i*2), *(pTimestamp + i*2 + 1),
+			*(fho_va + i*16), *(fho_va + i*16 + 1));
+	}
+}
+
+int mtk_cam_dequeue_req_frame(struct mtk_cam_ctx *ctx,
+			       unsigned int dequeued_frame_seq_no,
+			       int pipe_id)
+{
+	struct mtk_cam_request *req, *req_prev;
+	struct mtk_cam_request_stream_data *s_data, *s_data_pipe, *s_data_mstream;
+	struct mtk_cam_request_stream_data *deq_s_data[18];
+	struct mtk_raw_pipeline *pipe = ctx->pipe;
+	/* consider running_job_list depth and mstream(2 s_data): 3*3*2 */
+	struct mtk_camsys_sensor_ctrl *sensor_ctrl = &ctx->sensor_ctrl;
+	int feature, buf_state;
+	int dequeue_cnt, s_data_cnt, handled_cnt;
+	bool del_job, del_req;
+	bool unreliable = false;
+	struct mtk_ae_debug_data ae_data;
+
+	dequeue_cnt = 0;
+	s_data_cnt = 0;
+	spin_lock(&ctx->cam->running_job_lock);
+	list_for_each_entry_safe(req, req_prev, &ctx->cam->running_job_list, list) {
+		if (!(req->pipe_used & (1 << pipe_id)))
+			continue;
+
+		s_data = mtk_cam_req_get_s_data(req, ctx->stream_id, 0);
+		if (!s_data) {
+			dev_info(ctx->cam->dev,
+				"frame_seq:%d[ctx=%d,pipe=%d], de-queue request not found\n",
+				dequeued_frame_seq_no, ctx->stream_id, pipe_id);
+			continue;
+		}
+
+		if (s_data->frame_seq_no > dequeued_frame_seq_no)
+			goto STOP_SCAN;
+
+		deq_s_data[s_data_cnt++] = s_data;
+		if (s_data_cnt >= 18) {
+			dev_info(ctx->cam->dev,
+				 "%s:%s:ctx(%d):pipe(%d):seq(%d/%d) dequeue s_data over local buffer cnt(%d)\n",
+				 __func__, req->req.debug_str, ctx->stream_id, pipe_id,
+				 s_data->frame_seq_no, dequeued_frame_seq_no,
+				 s_data_cnt);
+			goto STOP_SCAN;
+		}
+	}
+
+STOP_SCAN:
+	spin_unlock(&ctx->cam->running_job_lock);
+
+	for (handled_cnt = 0; handled_cnt < s_data_cnt; handled_cnt++) {
+		s_data = deq_s_data[handled_cnt];
+		del_req = false;
+		del_job = false;
+		feature = s_data->feature.raw_feature;
+		req = mtk_cam_s_data_get_req(s_data);
+		if (!req) {
+			dev_info(ctx->cam->dev,
+				"%s:ctx(%d):pipe(%d):seq(%d) req not found\n",
+				__func__, ctx->stream_id, pipe_id,
+				s_data->frame_seq_no);
+			continue;
+		}
+
+		spin_lock(&req->done_status_lock);
+
+		if (req->done_status & 1 << pipe_id) {
+			/* already handled by another job done work */
+			spin_unlock(&req->done_status_lock);
+			continue;
+		}
+
+		/* Check whether all pipelines of single ctx are done */
+		req->done_status |= 1 << pipe_id;
+		if ((req->done_status & ctx->streaming_pipe) ==
+		    (req->pipe_used & ctx->streaming_pipe))
+			del_job = true;
+
+
+		if ((req->done_status & ctx->cam->streaming_pipe) ==
+		    (req->pipe_used & ctx->cam->streaming_pipe)) {
+			if (MTK_CAM_REQ_STATE_RUNNING ==
+			    atomic_cmpxchg(&req->state,
+					   MTK_CAM_REQ_STATE_RUNNING,
+					   MTK_CAM_REQ_STATE_DELETING))
+				del_req = true;
+		}
+
+		if (is_raw_subdev(pipe_id) && debug_ae) {
+			dump_aa_info(ctx, &ae_data);
+			dev_dbg(ctx->cam->dev,
+				"%s:%s:ctx(%d):pipe(%d):de-queue seq(%d):handle seq(%d),done(0x%x),pipes(req:0x%x,ctx:0x%x,all:0x%x),del_job(%d),del_req(%d),metaout,size(%d,%d),AA(0x%llx,0x%llx,0x%llx,0x%llx)(0x%llx,0x%llx,0x%llx,0x%llx)(0x%llx,0x%llx,0x%llx,0x%llx)(0x%llx,0x%llx,0x%llx,0x%llx)(0x%llx,0x%llx,0x%llx,0x%llx)\n",
+				__func__, req->req.debug_str, ctx->stream_id, pipe_id,
+				dequeued_frame_seq_no, s_data->frame_seq_no, req->done_status,
+				req->pipe_used, ctx->streaming_pipe, ctx->cam->streaming_pipe,
+				del_job, del_req,
+				pipe->res_config.sink_fmt.width, pipe->res_config.sink_fmt.height,
+				ae_data.OBC_R1_Sum[0], ae_data.OBC_R1_Sum[1],
+				ae_data.OBC_R1_Sum[2], ae_data.OBC_R1_Sum[3],
+				ae_data.OBC_R2_Sum[0], ae_data.OBC_R2_Sum[1],
+				ae_data.OBC_R2_Sum[2], ae_data.OBC_R2_Sum[3],
+				ae_data.OBC_R3_Sum[0], ae_data.OBC_R3_Sum[1],
+				ae_data.OBC_R3_Sum[2], ae_data.OBC_R3_Sum[3],
+				ae_data.AA_Sum[0], ae_data.AA_Sum[1],
+				ae_data.AA_Sum[2], ae_data.AA_Sum[3],
+				ae_data.LTM_Sum[0], ae_data.LTM_Sum[1],
+				ae_data.LTM_Sum[2], ae_data.LTM_Sum[3]);
+		} else
+			dev_dbg(ctx->cam->dev,
+				"%s:%s:ctx(%d):pipe(%d):de-queue seq(%d):handle seq(%d),done(0x%x),pipes(req:0x%x,ctx:0x%x,all:0x%x),del_job(%d),del_req(%d)\n",
+			__func__, req->req.debug_str, ctx->stream_id, pipe_id,
+			dequeued_frame_seq_no, s_data->frame_seq_no, req->done_status,
+			req->pipe_used, ctx->streaming_pipe, ctx->cam->streaming_pipe,
+				del_job, del_req);
+
+		spin_unlock(&req->done_status_lock);
+
+		if (mtk_cam_feature_is_mstream(feature) || mtk_cam_feature_is_mstream_m2m(feature))
+			s_data_mstream = mtk_cam_req_get_s_data(req, ctx->stream_id, 1);
+		else
+			s_data_mstream = NULL;
+
+		if (is_raw_subdev(pipe_id)) {
+			mtk_cam_get_timestamp(ctx, s_data);
+			mtk_cam_req_dbg_works_clean(s_data);
+			mtk_cam_req_works_clean(s_data);
+
+			if (s_data_mstream) {
+				mtk_cam_req_dbg_works_clean(s_data_mstream);
+				mtk_cam_req_works_clean(s_data_mstream);
+			}
+		}
+
+		if (del_job) {
+			atomic_dec(&ctx->running_s_data_cnt);
+			mtk_camsys_state_delete(ctx, sensor_ctrl, req);
+
+			/* release internal buffers */
+			mtk_cam_sv_finish_buf(s_data);
+			finish_cq_buf(s_data);
+
+			if (mtk_cam_is_time_shared(ctx))
+				finish_img_buf(s_data);
+
+			if (s_data_mstream) {
+				finish_cq_buf(s_data_mstream);
+				mtk_cam_sv_finish_buf(s_data_mstream);
+			}
+		}
+
+		if (del_req) {
+			mtk_cam_del_req_from_running(ctx, req, pipe_id);
+			dequeue_cnt++;
+		}
+
+		if (mtk_cam_feature_is_mstream(feature)) {
+			unreliable |= (s_data->flags &
+						   MTK_CAM_REQ_S_DATA_FLAG_SENSOR_HDL_DELAYED);
+
+			if (s_data_mstream) {
+				unreliable |= (s_data_mstream->flags &
+					MTK_CAM_REQ_S_DATA_FLAG_SENSOR_HDL_DELAYED);
+			}
+		}
+
+		/* release vb2 buffers of the pipe */
+		s_data_pipe = mtk_cam_req_get_s_data(req, pipe_id, 0);
+		if (!s_data_pipe) {
+			dev_info(ctx->cam->dev,
+				"%s:%s:ctx(%d):pipe(%d):seq(%d) s_data_pipe not found\n",
+				__func__, req->req.debug_str, ctx->stream_id, pipe_id,
+				s_data->frame_seq_no);
+			continue;
+		}
+
+		if (s_data->frame_seq_no < dequeued_frame_seq_no) {
+			buf_state = VB2_BUF_STATE_ERROR;
+			dev_dbg(ctx->cam->dev,
+				"%s:%s:pipe(%d) seq:%d, time:%lld drop, ctx:%d\n",
+				__func__, req->req.debug_str, pipe_id,
+				s_data->frame_seq_no, s_data->timestamp,
+				ctx->stream_id);
+		} else if (s_data->state.estate == E_STATE_DONE_MISMATCH) {
+			buf_state = VB2_BUF_STATE_ERROR;
+			dev_dbg(ctx->cam->dev,
+				"%s:%s:pipe(%d) seq:%d, state done mismatch",
+				__func__, req->req.debug_str, pipe_id,
+				s_data->frame_seq_no);
+		} else if (unreliable) {
+			buf_state = VB2_BUF_STATE_ERROR;
+			dev_dbg(ctx->cam->dev,
+				"%s:%s:pipe(%d) seq:%d, done (unreliable)",
+				__func__, req->req.debug_str, pipe_id,
+				s_data->frame_seq_no);
+		} else {
+			buf_state = VB2_BUF_STATE_DONE;
+			dev_dbg(ctx->cam->dev,
+				"%s:%s:pipe(%d) seq:%d, done success",
+				__func__, req->req.debug_str, pipe_id,
+				s_data->frame_seq_no);
+		}
+
+		if (mtk_cam_s_data_set_buf_state(s_data_pipe, buf_state)) {
+			/* handle vb2_buffer_done */
+			if (mtk_cam_req_put(req, pipe_id))
+				dev_dbg(ctx->cam->dev,
+					"%s:%s:pipe(%d) return request",
+					__func__, req->req.debug_str, pipe_id);
+		}
+	}
+
+	return dequeue_cnt;
+}
+
+void mtk_cam_dev_req_clean_pending(struct mtk_cam_device *cam, int pipe_id,
+				   int buf_state)
+{
+	struct mtk_cam_request *req, *req_prev;
+	struct mtk_cam_request_stream_data *s_data_pipe;
+	struct list_head *pending = &cam->pending_job_list;
+	struct list_head req_clean_list;
+
+	/* Consider pipe bufs and pipe_used only */
+
+	INIT_LIST_HEAD(&req_clean_list);
+
+	spin_lock(&cam->pending_job_lock);
+	list_for_each_entry_safe(req, req_prev, pending, list) {
+		/* update pipe_used */
+		req->pipe_used &= ~(1 << pipe_id);
+		list_add_tail(&req->cleanup_list, &req_clean_list);
+		if (!(req->pipe_used & cam->streaming_pipe)) {
+			/* the last pipe */
+			list_del(&req->list);
+			dev_info(cam->dev,
+				 "%s:%s:pipe(%d) remove req from pending list\n",
+				 __func__, req->req.debug_str, pipe_id);
+		}
+	}
+	spin_unlock(&cam->pending_job_lock);
+
+	list_for_each_entry_safe(req, req_prev, &req_clean_list, cleanup_list) {
+		list_del(&req->cleanup_list);
+		s_data_pipe = mtk_cam_req_get_s_data(req, pipe_id, 0);
+		if (!s_data_pipe) {
+			dev_dbg(cam->dev,
+				"%s:%s:pipe_used(0x%x):pipe(%d) s_data_pipe not found\n",
+				__func__, req->req.debug_str, req->pipe_used,
+				pipe_id);
+			continue;
+		}
+		if (mtk_cam_s_data_set_buf_state(s_data_pipe, buf_state)) {
+			/* handle vb2_buffer_done */
+			if (mtk_cam_req_put(req, pipe_id))
+				dev_dbg(cam->dev,
+					"%s:%s:pipe_used(0x%x):pipe(%d) return request",
+					__func__, req->req.debug_str,
+					req->pipe_used, pipe_id);
+			/* DO NOT touch req after here */
+		}
+	}
+}
+
+void mtk_cam_dev_req_cleanup(struct mtk_cam_ctx *ctx, int pipe_id, int buf_state)
+{
+	struct mtk_cam_device *cam = ctx->cam;
+	struct mtk_cam_request *req, *req_prev;
+	struct mtk_cam_request_stream_data *s_data, *s_data_pipe;
+	struct mtk_cam_request_stream_data *clean_s_data[18];
+	/* consider running_job_list depth and mstream(2 s_data): 3*3*2 */
+	struct list_head *running = &cam->running_job_list;
+	unsigned int other_pipes, done_status;
+	int i, num_s_data, s_data_cnt, handled_cnt;
+	bool need_clean_req;
+
+	mtk_cam_dev_req_clean_pending(cam, pipe_id, buf_state);
+
+	s_data_cnt = 0;
+	spin_lock(&cam->running_job_lock);
+	list_for_each_entry_safe(req, req_prev, running, list) {
+		/* only handle requests belong to current ctx */
+		if (!(req->pipe_used & ctx->streaming_pipe))
+			continue;
+
+		num_s_data = mtk_cam_req_get_num_s_data(req, pipe_id);
+		/* reverse the order for release req with s_data_0 */
+		for (i = num_s_data - 1; i >= 0; i--) {
+			s_data = mtk_cam_req_get_s_data(req, pipe_id, i);
+			if (s_data) {
+				clean_s_data[s_data_cnt++] = s_data;
+				if (s_data_cnt >= 18) {
+					dev_info(cam->dev,
+						 "%s: over local buffer cnt(%d)\n",
+						 __func__,  s_data_cnt);
+					goto STOP_SCAN;
+				}
+			} else {
+				dev_info(cam->dev,
+					 "%s:%s:pipe(%d): get s_data failed\n",
+					 __func__, req->req.debug_str, pipe_id);
+			}
+		}
+	}
+STOP_SCAN:
+	spin_unlock(&cam->running_job_lock);
+
+	for (handled_cnt = 0; handled_cnt < s_data_cnt; handled_cnt++) {
+		s_data = clean_s_data[handled_cnt];
+		req = mtk_cam_s_data_get_req(s_data);
+		if (!req) {
+			pr_info("ERR can't be recovered: invalid req found in s_data_clean_list\n");
+			continue;
+		}
+
+		if (ctx->used_raw_num != 0) {
+			if (s_data->index > 0)
+				dev_info(cam->dev,
+					"%s:%s:pipe(%d):seq(%d): clean s_data_%d, raw_feature(%lld)\n",
+					__func__, req->req.debug_str, pipe_id,
+					s_data->frame_seq_no, s_data->index,
+					ctx->pipe->feature_pending);
+			else
+				dev_dbg(cam->dev,
+					"%s:%s:pipe(%d):seq(%d): clean s_data_%d, raw_feature(%lld)\n",
+					__func__, req->req.debug_str, pipe_id,
+					s_data->frame_seq_no, s_data->index,
+					ctx->pipe->feature_pending);
+		}
+
+		/* Cancel s_data's works before we clean up the data */
+		if (atomic_read(&s_data->sensor_work.is_queued)) {
+			kthread_cancel_work_sync(&s_data->sensor_work.work);
+			dev_info(cam->dev,
+				 "%s:%s:pipe(%d):seq(%d): cancel sensor_work\n",
+				 __func__, req->req.debug_str, pipe_id,
+				 s_data->frame_seq_no);
+		}
+		atomic_set(&s_data->sensor_work.is_queued, 1);
+
+		if (atomic_read(&s_data->meta1_done_work.is_queued)) {
+			cancel_work_sync(&s_data->meta1_done_work.work);
+			dev_info(cam->dev,
+				 "%s:%s:pipe(%d):seq(%d): cancel AFO done_work\n",
+				 __func__, req->req.debug_str, pipe_id,
+				 s_data->frame_seq_no);
+		}
+		atomic_set(&s_data->meta1_done_work.is_queued, 1);
+
+		if (atomic_read(&s_data->frame_done_work.is_queued)) {
+			cancel_work_sync(&s_data->frame_done_work.work);
+			dev_info(cam->dev,
+				 "%s:%s:pipe(%d):seq(%d): cancel frame_done_work\n",
+				 __func__, req->req.debug_str, pipe_id,
+				 s_data->frame_seq_no);
+		}
+		atomic_set(&s_data->frame_done_work.is_queued, 1);
+
+		if (atomic_read(&s_data->dbg_exception_work.state) ==
+			MTK_CAM_REQ_DBGWORK_S_PREPARED) {
+			atomic_set(&s_data->dbg_exception_work.state, MTK_CAM_REQ_DBGWORK_S_CANCEL);
+			mtk_cam_debug_wakeup(&ctx->cam->debug_exception_waitq);
+			cancel_work_sync(&s_data->dbg_exception_work.work);
+			dev_info(cam->dev,
+				 "%s:%s:pipe(%d):seq(%d): cancel dbg_exception_work\n",
+				 __func__, req->req.debug_str, pipe_id,
+				 s_data->frame_seq_no);
+		}
+		atomic_set(&s_data->dbg_exception_work.state, MTK_CAM_REQ_DBGWORK_S_FINISHED);
+
+		if (atomic_read(&s_data->dbg_work.state) ==
+			MTK_CAM_REQ_DBGWORK_S_PREPARED) {
+			cancel_work_sync(&s_data->dbg_work.work);
+			dev_info(cam->dev,
+				 "%s:%s:pipe(%d):seq(%d): cancel dbg_work\n",
+				 __func__, req->req.debug_str, pipe_id,
+				 s_data->frame_seq_no);
+		}
+		atomic_set(&s_data->dbg_work.state, MTK_CAM_REQ_DBGWORK_S_FINISHED);
+
+		spin_lock(&req->done_status_lock);
+		dev_dbg(cam->dev,
+			"%s:%s:pipe(%d):seq(%d):req staus before clean:done(0x%x),pipe_used(0x%x)\n",
+			__func__, req->req.debug_str, pipe_id,
+			s_data->frame_seq_no, req->done_status, req->pipe_used);
+
+		need_clean_req = false;
+		if (atomic_read(&req->state) == MTK_CAM_REQ_STATE_RUNNING) {
+			/* mark request status to done for release */
+			req->done_status |= req->pipe_used & (1 << pipe_id);
+			if (req->done_status == req->pipe_used &&
+			    MTK_CAM_REQ_STATE_RUNNING ==
+			    atomic_cmpxchg(&req->state,
+					   MTK_CAM_REQ_STATE_RUNNING,
+					   MTK_CAM_REQ_STATE_DELETING))
+				need_clean_req = true;
+		}
+
+		/* if being the last one, check other pipes in the ctx */
+		other_pipes = 0;
+		done_status = req->done_status;
+		if (need_clean_req)
+			other_pipes = ctx->streaming_pipe & ~(1 << pipe_id);
+		spin_unlock(&req->done_status_lock);
+
+		/**
+		 * Before remove the request, flush other pipe's done work
+		 * in the same ctx to make sure mtk_cam_dev_job_done finished
+		 */
+		if (other_pipes) {
+			for (i = 0; i < MTKCAM_SUBDEV_MAX; i++) {
+				if (!(1 << i & other_pipes & done_status))
+					continue;
+
+				s_data_pipe = mtk_cam_req_get_s_data(req, i, 0);
+				if (!s_data_pipe)
+					continue;
+
+				/**
+				 * if done_status is marked, it means the work
+				 * is running or complete
+				 */
+				if (flush_work(&s_data->frame_done_work.work))
+					dev_info(cam->dev,
+						 "%s:%s:pipe(%d):seq(%d): flush pipe(%d) frame_done_work\n",
+						 __func__, req->req.debug_str,
+						 pipe_id, s_data_pipe->frame_seq_no,
+						 i);
+			}
+		}
+
+		mtk_cam_complete_sensor_hdl(s_data);
+		mtk_cam_complete_raw_hdl(s_data);
+		/*
+		 * reset fs state, if one sensor off and another one alive,
+		 * Let the req be the single sensor case.
+		 */
+		mutex_lock(&req->fs.op_lock);
+		mtk_cam_fs_reset(&req->fs);
+		mutex_unlock(&req->fs.op_lock);
+		if (need_clean_req) {
+			dev_info(cam->dev,
+				 "%s:%s:pipe(%d):seq(%d): remove req from running list\n",
+				 __func__, req->req.debug_str, pipe_id,
+				 s_data->frame_seq_no);
+			atomic_set(&req->state, MTK_CAM_REQ_STATE_CLEANUP);
+			spin_lock(&cam->running_job_lock);
+			list_del(&req->list);
+			cam->running_job_count--;
+			spin_unlock(&cam->running_job_lock);
+		} else {
+			dev_info(cam->dev,
+				 "%s:%s:pipe(%d):seq(%d): skip remove req from running list\n",
+				 __func__, req->req.debug_str, pipe_id,
+				 s_data->frame_seq_no);
+		}
+
+		if (mtk_cam_s_data_set_buf_state(s_data, buf_state)) {
+			if (s_data->index > 0) {
+				mtk_cam_req_return_pipe_buffers(req, pipe_id,
+								s_data->index);
+			} else {
+				/* handle vb2_buffer_done */
+				if (mtk_cam_req_put(req, pipe_id))
+					dev_dbg(cam->dev,
+						"%s:%s:pipe(%d) return request",
+						__func__, req->req.debug_str,
+						pipe_id);
+			}
+		}
+	}
+
+	/* all bufs in this node should be returned by req */
+
+	dev_dbg(cam->dev,
+		"%s: cleanup all stream off req, streaming ctx:0x%x, streaming pipe:0x%x)\n",
+		__func__, cam->streaming_ctx, cam->streaming_pipe);
+}
+
+void mtk_cam_req_get(struct mtk_cam_request *req, int pipe_id)
+{
+	atomic_inc(&req->ref_cnt);
+}
+
+bool mtk_cam_req_put(struct mtk_cam_request *req, int pipe_id)
+{
+	bool ret = false;
+
+	if (!atomic_dec_return(&req->ref_cnt)) {
+		mtk_cam_req_clean(req);
+		ret = true;
+	}
+
+	/* release the pipe buf with s_data_pipe buf state */
+	mtk_cam_req_return_pipe_buffers(req, pipe_id, 0);
+
+	return ret;
+}
+
+static void config_img_in_fmt_mstream(struct mtk_cam_device *cam,
+				struct mtk_cam_request_stream_data *req_stream_data,
+				struct mtk_cam_video_device *node,
+				const struct v4l2_format *cfg_fmt,
+				int feature)
+{
+	struct mtkcam_ipi_img_input *in_fmt;
+	int input_node;
+	struct mtk_cam_ctx *ctx = req_stream_data->ctx;
+
+	if (node->desc.dma_port != MTKCAM_IPI_RAW_IMGO &&
+			node->desc.dma_port != MTKCAM_IPI_RAW_RAWI_2)
+		return;
+
+	if (mtk_cam_feature_is_m2m(feature)) {
+		int exp;
+		struct mtk_cam_request *req = req_stream_data->req;
+
+		for (exp = 1; exp <= 3; exp++) {
+			if (exp == 1) {
+				req_stream_data =
+					mtk_cam_req_get_s_data(req,
+					ctx->stream_id, 1);
+				input_node = MTKCAM_IPI_RAW_RAWI_2;
+			} else {
+				req_stream_data =
+					mtk_cam_req_get_s_data(req,
+					ctx->stream_id, 0);
+				if (exp == 2)
+					input_node = MTKCAM_IPI_RAW_RAWI_2;
+				else
+					input_node = MTKCAM_IPI_RAW_RAWI_6;
+			}
+			in_fmt = &req_stream_data->frame_params.img_ins[input_node -
+				MTKCAM_IPI_RAW_RAWI_2];
+			in_fmt->uid.id = input_node;
+			in_fmt->uid.pipe_id = node->uid.pipe_id;
+			in_fmt->fmt.format =
+				mtk_cam_get_img_fmt(cfg_fmt->fmt.pix_mp.pixelformat);
+			in_fmt->fmt.s.w = cfg_fmt->fmt.pix_mp.width;
+			in_fmt->fmt.s.h = cfg_fmt->fmt.pix_mp.height;
+			in_fmt->fmt.stride[0] =
+				cfg_fmt->fmt.pix_mp.plane_fmt[0].bytesperline;
+			dev_dbg(cam->dev,
+				"[m-stream] ctx: %d dma_port:%d size=%dx%d, stride:%d, fmt:0x%x (0x%lx/0x%lx)\n",
+				ctx->stream_id, input_node, in_fmt->fmt.s.w,
+				in_fmt->fmt.s.h, in_fmt->fmt.stride[0],
+				in_fmt->fmt.format, (unsigned long)in_fmt->buf[0].iova,
+				(unsigned long)req_stream_data->frame_params.img_outs[0].buf[0][0].iova);
+		}
+	} else {
+		input_node = MTKCAM_IPI_RAW_RAWI_2;
+		in_fmt = &req_stream_data->frame_params.img_ins[input_node -
+			MTKCAM_IPI_RAW_RAWI_2];
+		in_fmt->uid.id = input_node;
+		in_fmt->uid.pipe_id = node->uid.pipe_id;
+		in_fmt->fmt.format =
+			mtk_cam_get_img_fmt(cfg_fmt->fmt.pix_mp.pixelformat);
+		in_fmt->fmt.s.w = cfg_fmt->fmt.pix_mp.width;
+		in_fmt->fmt.s.h = cfg_fmt->fmt.pix_mp.height;
+		in_fmt->fmt.stride[0] =
+			cfg_fmt->fmt.pix_mp.plane_fmt[0].bytesperline;
+		dev_dbg(cam->dev,
+			"[m-stream] ctx: %d dma_port:%d size=%dx%d, stride:%d, fmt:0x%x (0x%lx/0x%lx)\n",
+			ctx->stream_id, input_node, in_fmt->fmt.s.w,
+			in_fmt->fmt.s.h, in_fmt->fmt.stride[0],
+			in_fmt->fmt.format, (unsigned long)in_fmt->buf[0].iova,
+			(unsigned long)req_stream_data->frame_params.img_outs[0].buf[0][0].iova);
+	}
+
+}
+
+static void config_img_in_fmt_stagger(struct mtk_cam_device *cam,
+				struct mtk_cam_request_stream_data *req,
+				struct mtk_cam_video_device *node,
+				const struct v4l2_format *cfg_fmt,
+				enum hdr_scenario_id scenario,
+				int feature)
+{
+	struct mtkcam_ipi_img_input *in_fmt;
+	int input_node;
+	int rawi_port_num = 0;
+	int rawi_idx = 0;
+	const int *ptr_rawi = NULL;
+	static const int stagger_onthefly_2exp_rawi[1] = {
+					MTKCAM_IPI_RAW_RAWI_2};
+	static const int stagger_onthefly_3exp_rawi[2] = {
+					MTKCAM_IPI_RAW_RAWI_2, MTKCAM_IPI_RAW_RAWI_3};
+#ifdef ISP7_1
+	static const int stagger_dcif_1exp_rawi[1] = {
+					MTKCAM_IPI_RAW_RAWI_5};
+	static const int stagger_dcif_2exp_rawi[2] = {
+					MTKCAM_IPI_RAW_RAWI_2, MTKCAM_IPI_RAW_RAWI_5};
+	static const int stagger_dcif_3exp_rawi[3] = {
+					MTKCAM_IPI_RAW_RAWI_2, MTKCAM_IPI_RAW_RAWI_3,
+					MTKCAM_IPI_RAW_RAWI_5};
+#endif
+	static const int stagger_m2m_2exp_rawi[2] =	{
+					MTKCAM_IPI_RAW_RAWI_2, MTKCAM_IPI_RAW_RAWI_6};
+	static const int stagger_m2m_3exp_rawi[3] = {
+					MTKCAM_IPI_RAW_RAWI_2, MTKCAM_IPI_RAW_RAWI_3,
+					MTKCAM_IPI_RAW_RAWI_6};
+
+	if (node->desc.dma_port != MTKCAM_IPI_RAW_IMGO &&
+		node->desc.dma_port != MTKCAM_IPI_RAW_RAWI_2)
+		return;
+
+	if (scenario == STAGGER_ON_THE_FLY) {
+		if (mtk_cam_feature_is_2_exposure(feature)) {
+			rawi_port_num = 1;
+			ptr_rawi = stagger_onthefly_2exp_rawi;
+		} else if (mtk_cam_feature_is_3_exposure(feature)) {
+			rawi_port_num = 2;
+			ptr_rawi = stagger_onthefly_3exp_rawi;
+		}
+#ifdef ISP7_1
+	} else if (scenario == STAGGER_DCIF) {
+		if (mtk_cam_feature_is_2_exposure(feature)) {
+			rawi_port_num = 2;
+			ptr_rawi = stagger_dcif_2exp_rawi;
+		} else if (mtk_cam_feature_is_3_exposure(feature)) {
+			rawi_port_num = 3;
+			ptr_rawi = stagger_dcif_3exp_rawi;
+		} else {
+			rawi_port_num = 1;
+			ptr_rawi = stagger_dcif_1exp_rawi;
+		}
+#endif
+	} else {
+		if (mtk_cam_feature_is_2_exposure(feature)) {
+			rawi_port_num = 2;
+			ptr_rawi = stagger_m2m_2exp_rawi;
+		} else if (mtk_cam_feature_is_3_exposure(feature)) {
+			rawi_port_num = 3;
+			ptr_rawi = stagger_m2m_3exp_rawi;
+		}
+	}
+
+	if (ptr_rawi == NULL)
+		return;
+
+	for (rawi_idx = 0; rawi_idx < rawi_port_num; rawi_idx++) {
+		input_node = ptr_rawi[rawi_idx];
+		in_fmt = &req->frame_params.img_ins[input_node - MTKCAM_IPI_RAW_RAWI_2];
+		in_fmt->uid.id = input_node;
+		in_fmt->uid.pipe_id = node->uid.pipe_id;
+		in_fmt->fmt.format = mtk_cam_get_img_fmt(cfg_fmt->fmt.pix_mp.pixelformat);
+		in_fmt->fmt.s.w = cfg_fmt->fmt.pix_mp.width;
+		in_fmt->fmt.s.h = cfg_fmt->fmt.pix_mp.height;
+		in_fmt->fmt.stride[0] = cfg_fmt->fmt.pix_mp.plane_fmt[0].bytesperline;
+
+		dev_dbg(cam->dev,
+		"[stagger-%d] ctx: %d dma_port:%d size=%dx%d, stride:%d, fmt:0x%x (iova:0x%lx)\n",
+		rawi_idx, req->ctx->stream_id, input_node, in_fmt->fmt.s.w,
+		in_fmt->fmt.s.h, in_fmt->fmt.stride[0], in_fmt->fmt.format,
+		(unsigned long)in_fmt->buf[0].iova);
+	}
+}
+
+static void
+config_img_in_fmt_time_shared(struct mtk_cam_device *cam,
+			      struct mtk_cam_request_stream_data *req,
+			      struct mtk_cam_video_device *node,
+			      const struct v4l2_format *cfg_fmt)
+{
+	struct mtkcam_ipi_img_input *in_fmt;
+	struct mtk_cam_img_working_buf_entry *buf_entry;
+	struct mtk_cam_ctx *ctx = req->ctx;
+	int input_node;
+
+	if (node->desc.dma_port != MTKCAM_IPI_RAW_IMGO)
+		return;
+
+	input_node = MTKCAM_IPI_RAW_RAWI_2;
+	in_fmt = &req->frame_params.img_ins[input_node - MTKCAM_IPI_RAW_RAWI_2];
+	node = &ctx->pipe->vdev_nodes[MTK_RAW_MAIN_STREAM_OUT - MTK_RAW_SINK_NUM];
+	in_fmt->uid.id = input_node;
+	in_fmt->uid.pipe_id = node->uid.pipe_id;
+	in_fmt->fmt.format = mtk_cam_get_img_fmt(cfg_fmt->fmt.pix_mp.pixelformat);
+	in_fmt->fmt.s.w = cfg_fmt->fmt.pix_mp.width;
+	in_fmt->fmt.s.h = cfg_fmt->fmt.pix_mp.height;
+	in_fmt->fmt.stride[0] = cfg_fmt->fmt.pix_mp.plane_fmt[0].bytesperline;
+	/* prepare working buffer */
+	buf_entry = mtk_cam_img_working_buf_get(ctx);
+	if (!buf_entry) {
+		dev_info(cam->dev, "%s: No img buf availablle: req:%d\n",
+		__func__, req->frame_seq_no);
+		WARN_ON(1);
+		return;
+	}
+
+	mtk_cam_img_wbuf_set_s_data(buf_entry, req);
+	/* put to processing list */
+	spin_lock(&ctx->processing_img_buffer_list.lock);
+	list_add_tail(&buf_entry->list_entry, &ctx->processing_img_buffer_list.list);
+	ctx->processing_img_buffer_list.cnt++;
+	spin_unlock(&ctx->processing_img_buffer_list.lock);
+	in_fmt->buf[0].iova = buf_entry->img_buffer.iova;
+	in_fmt->buf[0].size = cfg_fmt->fmt.pix_mp.plane_fmt[0].sizeimage;
+	dev_info(cam->dev,
+	"[%s:%d] ctx:%d dma_port:%d size=%dx%d %d, stride:%d, fmt:0x%x (iova:0x%lx)\n",
+	__func__, req->frame_seq_no, ctx->stream_id, input_node, in_fmt->fmt.s.w,
+	in_fmt->fmt.s.h, in_fmt->buf[0].size, in_fmt->fmt.stride[0],
+	in_fmt->fmt.format, (unsigned long)in_fmt->buf[0].iova);
+
+}
+
+static void check_buffer_mem_saving(
+		struct mtk_cam_request_stream_data *req,
+		struct mtkcam_ipi_img_input *in_fmt,
+		int rawi_port_num)
+{
+	if (req->feature.raw_feature & HDR_MEMORY_SAVING) {
+		if (rawi_port_num == 2) {
+			/*raw's imgo using buf from user*/
+			req->frame_params.img_outs[0].buf[0][0].iova =
+			req->frame_params.img_ins[0].buf[0].iova;
+			/*sv's imgo using img pool buf*/
+			in_fmt->buf[0].iova = 0x0;
+		} else if (rawi_port_num == 1) {
+			/*raw's imgo using buf from user*/
+			req->frame_params.img_outs[0].buf[0][0].iova =
+			req->frame_params.img_ins[0].buf[0].iova;
+			/*sv's imgo using img pool buf*/
+			in_fmt->buf[0].iova = 0x0;
+		}
+		dev_dbg(req->ctx->cam->dev, "%s: req:%d, rawi_num:%d\n",
+			__func__, req->frame_seq_no, rawi_port_num);
+	}
+}
+
+static void check_stagger_buffer(struct mtk_cam_device *cam,
+				 struct mtk_cam_ctx *ctx,
+				 struct mtk_cam_request *cam_req)
+{
+	struct mtkcam_ipi_img_input *in_fmt;
+	struct mtk_cam_img_working_buf_entry *buf_entry;
+	struct mtk_cam_video_device *node;
+	struct mtk_cam_request_stream_data *s_data;
+	const struct v4l2_format *cfg_fmt;
+	int input_node, rawi_port_num = 0, rawi_idx = 0;
+	const int *ptr_rawi = NULL;
+	int feature;
+
+	static const int stagger_onthefly_2exp_rawi[1] = {
+					MTKCAM_IPI_RAW_RAWI_2};
+	static const int stagger_onthefly_3exp_rawi[2] = {
+					MTKCAM_IPI_RAW_RAWI_2, MTKCAM_IPI_RAW_RAWI_3};
+#ifdef ISP7_1
+	static const int stagger_dcif_1exp_rawi[1] = {
+					MTKCAM_IPI_RAW_RAWI_5};
+	static const int stagger_dcif_2exp_rawi[2] = {
+					MTKCAM_IPI_RAW_RAWI_2, MTKCAM_IPI_RAW_RAWI_5};
+	static const int stagger_dcif_3exp_rawi[3] = {
+					MTKCAM_IPI_RAW_RAWI_2, MTKCAM_IPI_RAW_RAWI_3,
+					MTKCAM_IPI_RAW_RAWI_5};
+#endif
+	/* check the raw pipe only */
+	s_data = mtk_cam_req_get_s_data(cam_req, ctx->stream_id, 0);
+	feature = s_data->feature.raw_feature;
+	if (ctx->pipe->stagger_path_pending == STAGGER_ON_THE_FLY) {
+		s_data->frame_params.raw_param.hardware_scenario =
+			MTKCAM_IPI_HW_PATH_ON_THE_FLY_DCIF_STAGGER;
+		if (mtk_cam_feature_is_2_exposure(feature)) {
+			s_data->frame_params.raw_param.exposure_num = 2;
+			rawi_port_num = 1;
+			ptr_rawi = stagger_onthefly_2exp_rawi;
+		} else if (mtk_cam_feature_is_3_exposure(feature)) {
+			s_data->frame_params.raw_param.exposure_num = 3;
+			rawi_port_num = 2;
+			ptr_rawi = stagger_onthefly_3exp_rawi;
+		} else {
+			s_data->frame_params.raw_param.hardware_scenario =
+					MTKCAM_IPI_HW_PATH_ON_THE_FLY;
+			s_data->frame_params.raw_param.exposure_num = 1;
+			rawi_port_num = 0;
+			ptr_rawi = NULL;
+		}
+	}
+#ifdef ISP7_1
+	else if (ctx->pipe->stagger_path_pending == STAGGER_DCIF) {
+		s_data->frame_params.raw_param.hardware_scenario =
+			MTKCAM_IPI_HW_PATH_OFFLINE_SRT_DCIF_STAGGER;
+		if (mtk_cam_feature_is_2_exposure(feature)) {
+			s_data->frame_params.raw_param.exposure_num = 2;
+			rawi_port_num = 2;
+			ptr_rawi = stagger_dcif_2exp_rawi;
+		} else if (mtk_cam_feature_is_3_exposure(feature)) {
+			s_data->frame_params.raw_param.exposure_num = 3;
+			rawi_port_num = 3;
+			ptr_rawi = stagger_dcif_3exp_rawi;
+		} else {
+			s_data->frame_params.raw_param.exposure_num = 1;
+			rawi_port_num = 1;
+			ptr_rawi = stagger_dcif_1exp_rawi;
+		}
+	}
+#endif
+	for (rawi_idx = 0; rawi_idx < rawi_port_num; rawi_idx++) {
+		input_node = ptr_rawi[rawi_idx];
+		in_fmt = &s_data->frame_params.img_ins[
+					input_node - MTKCAM_IPI_RAW_RAWI_2];
+		check_buffer_mem_saving(s_data, in_fmt, rawi_port_num);
+		if (in_fmt->buf[0].iova == 0x0) {
+			node = &ctx->pipe->vdev_nodes[
+				MTK_RAW_MAIN_STREAM_OUT - MTK_RAW_SINK_NUM];
+
+			cfg_fmt = mtk_cam_s_data_get_vfmt(s_data, node->desc.id);
+
+			/* workaround for raw switch */
+			if (!cfg_fmt->fmt.pix_mp.pixelformat)
+				cfg_fmt = &node->active_fmt;
+
+			in_fmt->uid.id = input_node;
+			in_fmt->uid.pipe_id = node->uid.pipe_id;
+			in_fmt->fmt.format = mtk_cam_get_img_fmt(
+					cfg_fmt->fmt.pix_mp.pixelformat);
+			in_fmt->fmt.s.w = cfg_fmt->fmt.pix_mp.width;
+			in_fmt->fmt.s.h = cfg_fmt->fmt.pix_mp.height;
+			in_fmt->fmt.stride[0] =
+				cfg_fmt->fmt.pix_mp.plane_fmt[0].bytesperline;
+			/* prepare working buffer */
+			buf_entry = mtk_cam_img_working_buf_get(ctx);
+			if (!buf_entry) {
+				dev_info(cam->dev,
+					 "%s: No img buf availablle: req:%d\n",
+					 __func__, s_data->frame_seq_no);
+				WARN_ON(1);
+				return;
+			}
+			mtk_cam_img_wbuf_set_s_data(buf_entry, s_data);
+			/* put to processing list */
+			spin_lock(&ctx->processing_img_buffer_list.lock);
+			list_add_tail(&buf_entry->list_entry,
+				      &ctx->processing_img_buffer_list.list);
+			ctx->processing_img_buffer_list.cnt++;
+			spin_unlock(&ctx->processing_img_buffer_list.lock);
+			in_fmt->buf[0].iova = buf_entry->img_buffer.iova;
+			finish_img_buf(s_data);
+		}
+		dev_dbg(cam->dev,
+			"[%s:%d] ctx:%d dma_port:%d size=%dx%d, stride:%d, fmt:0x%x (in/out:0x%lx/0x%lx)\n",
+			__func__, s_data->frame_seq_no, ctx->stream_id,
+			input_node, in_fmt->fmt.s.w, in_fmt->fmt.s.h,
+			in_fmt->fmt.stride[0], in_fmt->fmt.format,
+			(unsigned long)in_fmt->buf[0].iova,
+			(unsigned long)s_data->frame_params.img_outs[0].buf[0][0].iova);
+	}
+
+	switch (s_data->feature.switch_feature_type) {
+	case EXPOSURE_CHANGE_NONE:
+		s_data->frame_params.raw_param.previous_exposure_num =
+				s_data->frame_params.raw_param.exposure_num;
+		break;
+	case EXPOSURE_CHANGE_3_to_2:
+	case EXPOSURE_CHANGE_3_to_1:
+		s_data->frame_params.raw_param.previous_exposure_num = 3;
+		break;
+	case EXPOSURE_CHANGE_2_to_3:
+	case EXPOSURE_CHANGE_2_to_1:
+		s_data->frame_params.raw_param.previous_exposure_num = 2;
+		break;
+	case EXPOSURE_CHANGE_1_to_3:
+	case EXPOSURE_CHANGE_1_to_2:
+		s_data->frame_params.raw_param.previous_exposure_num = 1;
+		break;
+	default:
+		s_data->frame_params.raw_param.previous_exposure_num =
+				s_data->frame_params.raw_param.exposure_num;
+	}
+}
+
+static void check_timeshared_buffer(struct mtk_cam_device *cam,
+				    struct mtk_cam_ctx *ctx,
+				    struct mtk_cam_request *cam_req)
+{
+	struct mtkcam_ipi_img_input *in_fmt;
+	struct mtk_cam_img_working_buf_entry *buf_entry;
+	struct mtk_cam_video_device *node;
+	struct mtk_cam_request_stream_data *req;
+	const struct v4l2_format *cfg_fmt;
+	int input_node;
+
+	/* check raw pipe only */
+	input_node = MTKCAM_IPI_RAW_RAWI_2;
+	req = mtk_cam_req_get_s_data(cam_req, ctx->stream_id, 0);
+	in_fmt = &req->frame_params.img_ins[input_node - MTKCAM_IPI_RAW_RAWI_2];
+
+	if (in_fmt->buf[0].iova == 0x0) {
+		node = &ctx->pipe->vdev_nodes[
+			MTK_RAW_MAIN_STREAM_OUT - MTK_RAW_SINK_NUM];
+
+		cfg_fmt = mtk_cam_s_data_get_vfmt(req, node->desc.id);
+		/* workaround for raw switch */
+		if (!cfg_fmt->fmt.pix_mp.pixelformat)
+			cfg_fmt = &node->active_fmt;
+
+		in_fmt->uid.id = input_node;
+		in_fmt->uid.pipe_id = node->uid.pipe_id;
+		in_fmt->fmt.format =
+			mtk_cam_get_img_fmt(cfg_fmt->fmt.pix_mp.pixelformat);
+		in_fmt->fmt.s.w = cfg_fmt->fmt.pix_mp.width;
+		in_fmt->fmt.s.h = cfg_fmt->fmt.pix_mp.height;
+		in_fmt->fmt.stride[0] =
+			cfg_fmt->fmt.pix_mp.plane_fmt[0].bytesperline;
+		/* prepare working buffer */
+		buf_entry = mtk_cam_img_working_buf_get(ctx);
+		if (!buf_entry) {
+			dev_info(cam->dev, "%s: No img buf availablle: req:%d\n",
+				 __func__, req->frame_seq_no);
+			WARN_ON(1);
+			return;
+		}
+		mtk_cam_img_wbuf_set_s_data(buf_entry, req);
+		/* put to processing list */
+		spin_lock(&ctx->processing_img_buffer_list.lock);
+		list_add_tail(&buf_entry->list_entry,
+			      &ctx->processing_img_buffer_list.list);
+		ctx->processing_img_buffer_list.cnt++;
+		spin_unlock(&ctx->processing_img_buffer_list.lock);
+		in_fmt->buf[0].iova = buf_entry->img_buffer.iova;
+	}
+	dev_dbg(cam->dev,
+		"[%s:%d] ctx:%d dma_port:%d size=%dx%d, stride:%d, fmt:0x%x (iova:0x%lx)\n",
+		__func__, req->frame_seq_no, ctx->stream_id, input_node,
+		in_fmt->fmt.s.w, in_fmt->fmt.s.h, in_fmt->fmt.stride[0],
+		in_fmt->fmt.format, (unsigned long)in_fmt->buf[0].iova);
+}
+
+/* FIXME: should move following to raw's implementation. */
+static int config_img_in_fmt(struct mtk_cam_device *cam,
+			  struct mtk_cam_video_device *node,
+			  const struct v4l2_format *cfg_fmt,
+			  struct mtkcam_ipi_img_input *in_fmt)
+{
+	/* Check output & input image size dimension */
+	if (node->desc.dma_port != MTKCAM_IPI_RAW_RAWI_2) {
+		dev_info(cam->dev,
+			 "pipe(%d):dam_port(%d) only support MTKCAM_IPI_RAW_RAWI_2 now\n",
+			 node->uid.pipe_id, node->desc.dma_port);
+		return -EINVAL;
+	}
+
+	in_fmt->fmt.format =
+		mtk_cam_get_img_fmt(cfg_fmt->fmt.pix_mp.pixelformat);
+	if (in_fmt->fmt.format == MTKCAM_IPI_IMG_FMT_UNKNOWN) {
+		dev_info(cam->dev, "pipe: %d, node:%d unknown pixel fmt:%d\n",
+			node->uid.pipe_id, node->desc.dma_port,
+			cfg_fmt->fmt.pix_mp.pixelformat);
+		return -EINVAL;
+	}
+
+	in_fmt->fmt.s.w = cfg_fmt->fmt.pix_mp.width;
+	in_fmt->fmt.s.h = cfg_fmt->fmt.pix_mp.height;
+	in_fmt->fmt.stride[0] = cfg_fmt->fmt.pix_mp.plane_fmt[0].bytesperline;
+
+	dev_dbg(cam->dev,
+		"pipe: %d dma_port:%d size=%0dx%0d, stride:%d\n",
+		node->uid.pipe_id, node->desc.dma_port, in_fmt->fmt.s.w,
+		in_fmt->fmt.s.h, in_fmt->fmt.stride[0]);
+
+	return 0;
+}
+
+/* FIXME: should move following to raw's implementation. */
+static int config_img_fmt(struct mtk_cam_device *cam,
+			  struct mtk_cam_video_device *node,
+			  const struct v4l2_format *cfg_fmt,
+			  struct mtkcam_ipi_img_output *out_fmt, int sd_width,
+			  int sd_height)
+{
+	/* Check output & input image size dimension */
+	if (node->desc.dma_port == MTKCAM_IPI_RAW_IMGO &&
+	    (cfg_fmt->fmt.pix_mp.width > sd_width ||
+			cfg_fmt->fmt.pix_mp.height > sd_height)) {
+		dev_dbg(cam->dev, "pipe: %d cfg(%d,%d) size is larger than sensor(%d,%d)\n",
+			node->uid.pipe_id, cfg_fmt->fmt.pix_mp.width, cfg_fmt->fmt.pix_mp.height,
+			sd_width, sd_height);
+		return -EINVAL;
+	}
+
+	out_fmt->fmt.format =
+		mtk_cam_get_img_fmt(cfg_fmt->fmt.pix_mp.pixelformat);
+	if (out_fmt->fmt.format == MTKCAM_IPI_IMG_FMT_UNKNOWN) {
+		dev_dbg(cam->dev, "pipe: %d, node:%d unknown pixel fmt:%d\n",
+			node->uid.pipe_id, node->desc.dma_port,
+			cfg_fmt->fmt.pix_mp.pixelformat);
+		return -EINVAL;
+	}
+	out_fmt->fmt.s.w = cfg_fmt->fmt.pix_mp.width;
+	out_fmt->fmt.s.h = cfg_fmt->fmt.pix_mp.height;
+
+	/* TODO: support multi-plane stride */
+	out_fmt->fmt.stride[0] = cfg_fmt->fmt.pix_mp.plane_fmt[0].bytesperline;
+
+	if (out_fmt->crop.p.x == 0 && out_fmt->crop.s.w == 0) {
+		out_fmt->crop.p.x = 0;
+		out_fmt->crop.p.y = 0;
+		out_fmt->crop.s.w = sd_width;
+		out_fmt->crop.s.h = sd_height;
+	}
+
+	dev_dbg(cam->dev,
+		"pipe: %d dma_port:%d size=%0dx%0d, stride:%d, crop=%0dx%0d\n",
+		node->uid.pipe_id, node->desc.dma_port, out_fmt->fmt.s.w,
+		out_fmt->fmt.s.h, out_fmt->fmt.stride[0], out_fmt->crop.s.w,
+		out_fmt->crop.s.h);
+
+	return 0;
+}
+
+static int config_img_fmt_mstream(struct mtk_cam_ctx *ctx,
+				struct mtk_cam_request *req,
+				const struct v4l2_format *cfg_fmt,
+				struct mtk_cam_video_device *node,
+				int sd_width, int sd_height,
+				int feature)
+{
+	struct mtk_cam_device *cam = ctx->cam;
+	struct mtk_cam_request_stream_data *req_stream_data;
+	struct mtk_cam_request_stream_data *mstream_req_stream_data;
+	struct mtkcam_ipi_img_output *mstream_first_out_fmt;
+	int ret;
+
+	mstream_req_stream_data =
+		mtk_cam_req_get_s_data(req, ctx->stream_id, 1);
+	mstream_req_stream_data->ctx = ctx;
+	mstream_first_out_fmt = &mstream_req_stream_data->frame_params
+		.img_outs[node->desc.id - MTK_RAW_SOURCE_BEGIN];
+	mstream_first_out_fmt->uid.pipe_id = node->uid.pipe_id;
+	mstream_first_out_fmt->uid.id =  node->desc.dma_port;
+	ret = config_img_fmt(cam, node, cfg_fmt,
+			     mstream_first_out_fmt, sd_width, sd_height);
+	if (ret)
+		return ret;
+
+	req_stream_data = mtk_cam_req_get_s_data(req, ctx->stream_id, 0);
+	config_img_in_fmt_mstream(cam, req_stream_data, node, cfg_fmt, feature);
+
+	return ret;
+}
+
+static void check_mstream_buffer(struct mtk_cam_device *cam,
+				struct mtk_cam_ctx *ctx,
+				struct mtk_cam_request *req)
+{
+	struct mtk_cam_request_stream_data *req_stream_data;
+	struct mtkcam_ipi_frame_param *frame_param;
+	struct mtk_cam_request_stream_data *req_stream_data_mstream;
+	struct mtkcam_ipi_frame_param *mstream_frame_param;
+	struct mtkcam_ipi_img_input *in_fmt;
+	struct mtk_raw_pipeline *pipe = ctx->pipe;
+	struct mtk_cam_video_device *vdev;
+	unsigned int desc_id;
+	unsigned int pipe_id;
+	int in_node;
+	int is_m2m = 0;
+	int feature;
+
+	desc_id = MTKCAM_IPI_RAW_IMGO - MTK_RAW_RAWI_2_IN;
+	in_node = MTKCAM_IPI_RAW_RAWI_2;
+	pipe_id = ctx->stream_id;
+
+	req_stream_data = mtk_cam_req_get_s_data(req, pipe_id, 0);
+	frame_param = &req_stream_data->frame_params;
+	in_fmt = &frame_param->img_ins[in_node - MTKCAM_IPI_RAW_RAWI_2];
+
+	/* support stt-only case in which no imgo is involved */
+	if (in_fmt->buf[0].iova == 0x0) {
+		struct mtk_cam_img_working_buf_entry *buf_entry;
+		const struct v4l2_format *cfg_fmt;
+		struct mtkcam_ipi_img_output *out_fmt;
+
+		feature = req_stream_data->feature.raw_feature &
+				MTK_CAM_FEATURE_HDR_MASK;
+		is_m2m = mtk_cam_feature_is_mstream_m2m(
+				req_stream_data->feature.raw_feature);
+
+		/* prepare working buffer */
+		buf_entry = mtk_cam_img_working_buf_get(ctx);
+		if (!buf_entry) {
+			dev_info(cam->dev, "%s: No img buf availablle: req:%d\n",
+			__func__, req_stream_data->frame_seq_no);
+			WARN_ON(1);
+			return;
+		}
+
+		/* config format */
+		vdev = &pipe->vdev_nodes[MTK_RAW_MAIN_STREAM_OUT - MTK_RAW_SINK_NUM];
+		cfg_fmt = mtk_cam_s_data_get_vfmt(req_stream_data, MTK_RAW_MAIN_STREAM_OUT);
+		/* workaround for raw switch */
+		if (!cfg_fmt->fmt.pix_mp.pixelformat)
+			cfg_fmt = &vdev->active_fmt;
+		config_img_fmt_mstream(ctx, req, cfg_fmt, vdev,
+				       cfg_fmt->fmt.pix_mp.width,
+				       cfg_fmt->fmt.pix_mp.height, feature);
+
+		/* fill mstream frame param data */
+		req_stream_data_mstream = mtk_cam_req_get_s_data(req, pipe_id, 1);
+		mstream_frame_param = &req_stream_data_mstream->frame_params;
+
+		mstream_frame_param->raw_param.exposure_num = 1;
+		frame_param->raw_param.exposure_num = 2;
+
+		out_fmt = &mstream_frame_param->img_outs[desc_id];
+		out_fmt->buf[0][0].iova = buf_entry->img_buffer.iova;
+		in_fmt->buf[0].iova = out_fmt->buf[0][0].iova;
+		out_fmt->buf[0][0].size =
+			vdev->active_fmt.fmt.pix_mp.plane_fmt[0].sizeimage;
+		in_fmt->buf[0].size = out_fmt->buf[0][0].size;
+
+		/* reuse padding img working buffer to reduce memory use */
+		mtk_cam_img_working_buf_put(buf_entry);
+
+		if (feature == MSTREAM_NE_SE) {
+			frame_param->raw_param.hardware_scenario =
+				is_m2m ? MTKCAM_IPI_HW_PATH_OFFLINE_STAGGER :
+			MTKCAM_IPI_HW_PATH_ON_THE_FLY_MSTREAM_NE_SE;
+
+			dev_dbg(cam->dev,
+				"%s: mstream (m2m %d) ne_se ne imgo:0x%lx se rawi:0x%lx\n",
+				__func__, is_m2m, (unsigned long)out_fmt->buf[0][0].iova,
+				(unsigned long)in_fmt->buf[0].iova);
+		} else {
+			frame_param->raw_param.hardware_scenario =
+				is_m2m ? MTKCAM_IPI_HW_PATH_OFFLINE_STAGGER :
+			MTKCAM_IPI_HW_PATH_ON_THE_FLY_MSTREAM_SE_NE;
+
+			dev_dbg(cam->dev,
+				"%s: mstream (m2m %d) se_ne se imgo:0x%lx ne rawi:0x%lx\n",
+				__func__, is_m2m, (unsigned long)out_fmt->buf[0][0].iova,
+				(unsigned long)in_fmt->buf[0].iova);
+		}
+	}
+}
+
+static void mtk_cam_req_set_vfmt(struct mtk_cam_device *cam,
+				 struct mtk_raw_pipeline *raw_pipeline,
+				 struct mtk_cam_request_stream_data *s_data)
+{
+	struct mtk_cam_video_device *node;
+	struct mtk_cam_request *req;
+	struct v4l2_format *f;
+	struct v4l2_selection *s;
+	int i;
+
+	req = mtk_cam_s_data_get_req(s_data);
+
+	/* force update format to every video device before re-streamon */
+	for (i = MTK_RAW_SINK_NUM + 1; i < MTK_RAW_META_OUT_BEGIN; i++) {
+		node = &raw_pipeline->vdev_nodes[i - MTK_RAW_SINK_NUM];
+		f = mtk_cam_s_data_get_vfmt(s_data, node->desc.id);
+		if (!f) {
+			dev_info(cam->dev,
+				 "%s:%s:pipe(%d):%s: can't find the vfmt field to save\n",
+				 __func__, req->req.debug_str,
+				 node->uid.pipe_id, node->desc.name);
+			} else {
+				if (s_data->vdev_fmt_update &
+				    (1 << node->desc.id)) {
+					mtk_cam_video_set_fmt(node, f,
+							      s_data->feature.raw_feature);
+					node->active_fmt = *f;
+					dev_dbg(cam->dev,
+						"%s:%s:pipe(%d):%s:apply pending v4l2 fmt: pixelfmt(0x%x), w(%d), h(%d)\n",
+						__func__, req->req.debug_str,
+						node->uid.pipe_id, node->desc.name,
+						f->fmt.pix_mp.pixelformat,
+						f->fmt.pix_mp.width,
+						f->fmt.pix_mp.height);
+
+				} else {
+					*f = node->active_fmt;
+					dev_dbg(cam->dev,
+						"%s:%s:pipe(%d):%s:save v4l2 fmt: pixelfmt(0x%x), w(%d), h(%d)\n",
+						__func__, req->req.debug_str,
+						node->uid.pipe_id, node->desc.name,
+						f->fmt.pix_mp.pixelformat,
+						f->fmt.pix_mp.width,
+						f->fmt.pix_mp.height);
+				}
+			}
+
+			s = mtk_cam_s_data_get_vsel(s_data, node->desc.id);
+			if (!s) {
+				dev_info(cam->dev,
+					 "%s:%s:pipe(%d):%s: can't find the vsel field to save\n",
+					 __func__, req->req.debug_str,
+					 node->uid.pipe_id,
+					 node->desc.name);
+			} else {
+				if (s_data->vdev_selection_update &
+				    (1 << node->desc.id)) {
+					node->pending_crop = *s;
+					dev_dbg(cam->dev,
+						"%s:%s:pipe(%d):%s: apply pending vidioc_s_selection (%d,%d,%d,%d)\n",
+						__func__, req->req.debug_str,
+						node->uid.pipe_id, node->desc.name,
+						node->pending_crop.r.left,
+						node->pending_crop.r.top,
+						node->pending_crop.r.width,
+						node->pending_crop.r.height);
+				} else {
+					*s = node->pending_crop;
+			}
+		}
+	}
+}
+
+static int mtk_cam_req_set_fmt(struct mtk_cam_device *cam,
+							   struct mtk_cam_request *req)
+{
+	int pipe_id;
+	int pad;
+	struct mtk_cam_request_stream_data *stream_data;
+	struct v4l2_subdev *sd;
+	struct mtk_raw_pipeline *raw_pipeline;
+	int w, h;
+
+	dev_dbg(cam->dev, "%s:%s\n", __func__, req->req.debug_str);
+	for (pipe_id = 0; pipe_id < cam->max_stream_num; pipe_id++) {
+		if (req->pipe_used & (1 << pipe_id)) {
+			if (is_raw_subdev(pipe_id)) {
+				stream_data = mtk_cam_req_get_s_data(req, pipe_id, 0);
+				raw_pipeline = &cam->raw.pipelines[pipe_id];
+				mtk_cam_req_set_vfmt(cam, raw_pipeline,
+							stream_data);
+				sd = &raw_pipeline->subdev;
+				pad = MTK_RAW_SINK;
+
+				if (stream_data->pad_fmt_update & 1 << MTK_RAW_SINK) {
+					/* update stream_data flag */
+					w = raw_pipeline->cfg[MTK_RAW_SINK].mbus_fmt.width;
+					h = raw_pipeline->cfg[MTK_RAW_SINK].mbus_fmt.height;
+					if (w != stream_data->pad_fmt[pad].format.width ||
+						h != stream_data->pad_fmt[pad].format.height) {
+						dev_info(cam->dev,
+							"%s:%s:pipe(%d):seq(%d):sink fmt change: (%d, %d) --> (%d, %d)\n",
+							__func__, req->req.debug_str, pipe_id,
+							stream_data->frame_seq_no,
+							w, h,
+							stream_data->pad_fmt[pad].format.width,
+							stream_data->pad_fmt[pad].format.height);
+						stream_data->flags |=
+							MTK_CAM_REQ_S_DATA_FLAG_SINK_FMT_UPDATE;
+					}
+					if (stream_data->flags &
+						MTK_CAM_REQ_S_DATA_FLAG_SENSOR_MODE_UPDATE_T1) {
+						stream_data->seninf_fmt.format =
+							stream_data->pad_fmt[pad].format;
+						dev_info(cam->dev,
+							"%s:%s:pipe(%d):seq(%d):pending sensor/seninf fmt change: (%d, %d, 0x%x)\n",
+							__func__, req->req.debug_str, pipe_id,
+							stream_data->frame_seq_no,
+							stream_data->seninf_fmt.format.width,
+							stream_data->seninf_fmt.format.height,
+							stream_data->seninf_fmt.format.code);
+					}
+				}
+				/* Set MEDIA_PAD_FL_SINK pad's fmt */
+				for (pad = MTK_RAW_SINK_BEGIN;
+					pad < MTK_RAW_SOURCE_BEGIN; pad++) {
+					if (stream_data->pad_fmt_update & 1 << pad) {
+						mtk_raw_call_pending_set_fmt(sd,
+							&stream_data->pad_fmt[pad]);
+					} else {
+						stream_data->pad_fmt[pad].format =
+							raw_pipeline->cfg[pad].mbus_fmt;
+					}
+				}
+				/* Set MEDIA_PAD_FL_SOURCE pad's fmt */
+				for (pad = MTK_RAW_SOURCE_BEGIN;
+					 pad < MTK_RAW_PIPELINE_PADS_NUM; pad++) {
+					if (stream_data->pad_fmt_update & 1 << pad) {
+						mtk_raw_call_pending_set_fmt(sd,
+							 &stream_data->pad_fmt[pad]);
+					} else {
+						stream_data->pad_fmt[pad].format =
+							raw_pipeline->cfg[pad].mbus_fmt;
+					}
+				}
+			} else if (is_camsv_subdev(pipe_id)) {
+				stream_data = mtk_cam_req_get_s_data(req, pipe_id, 0);
+				sd = &cam->sv.pipelines[pipe_id - MTKCAM_SUBDEV_CAMSV_START].subdev;
+				for (pad = MTK_CAMSV_SOURCE_BEGIN;
+					 pad < MTK_CAMSV_PIPELINE_PADS_NUM; pad++)
+					if (stream_data->pad_fmt_update & (1 << pad))
+						mtk_camsv_call_pending_set_fmt(sd,
+							 &stream_data->pad_fmt[pad]);
+			}
+		}
+	}
+	return 0;
+}
+
+static int mtk_cam_req_update_ctrl(struct mtk_raw_pipeline *raw_pipe,
+	struct mtk_cam_request_stream_data *s_data)
+{
+	s64 raw_fut_pre;
+	char *debug_str = mtk_cam_s_data_get_dbg_str(s_data);
+	struct mtk_cam_request *req;
+	struct mtk_cam_req_raw_pipe_data *raw_pipe_data;
+
+	raw_pipe_data = mtk_cam_s_data_get_raw_pipe_data(s_data);
+	req = mtk_cam_s_data_get_req(s_data);
+
+	/* clear seamless switch mode */
+	raw_pipe->sensor_mode_update = 0;
+	raw_fut_pre = raw_pipe->feature_pending;
+	mtk_cam_req_ctrl_setup(raw_pipe, req);
+
+	/* use raw_res.feature as raw_fut_pre (feature setup before re-streamon)*/
+	if (req->ctx_link_update & (1 << raw_pipe->id)) {
+		raw_fut_pre = raw_pipe->feature_pending;
+		dev_info(raw_pipe->subdev.v4l2_dev->dev,
+			"%s:%s:%s:linkupdate: raw_feature(0x%0llx), prev_feature(0x%0llx), res feature(0x%0llx)\n",
+			__func__, raw_pipe->subdev.name, debug_str,
+			raw_pipe->feature_pending,
+			raw_fut_pre,
+			raw_pipe->user_res.raw_res.feature);
+	}
+
+		s_data->feature.switch_feature_type =
+			mtk_cam_get_feature_switch(raw_pipe, raw_fut_pre);
+	s_data->feature.raw_feature = raw_pipe->feature_pending;
+	s_data->feature.prev_feature = raw_fut_pre;
+	atomic_set(&s_data->first_setting_check, 0);
+	if (s_data->feature.switch_feature_type) {
+		s_data->feature.switch_prev_frame_done = 0;
+		s_data->feature.switch_curr_setting_done = 0;
+		s_data->feature.switch_done = 0;
+	}
+
+	dev_dbg(raw_pipe->subdev.v4l2_dev->dev,
+		"%s:%s:%s:raw_feature(0x%0x), prev_feature(0x%0x), switch_feature_type(0x%0x), sensor_mode_update(0x%0x)\n",
+		__func__, raw_pipe->subdev.name, debug_str,
+		s_data->feature.raw_feature,
+		s_data->feature.prev_feature,
+		s_data->feature.switch_feature_type,
+		raw_pipe->sensor_mode_update);
+
+	if (raw_pipe->sensor_mode_update)
+		s_data->flags |= MTK_CAM_REQ_S_DATA_FLAG_SENSOR_MODE_UPDATE_T1;
+
+	raw_pipe_data->res = raw_pipe->user_res;
+
+	return 0;
+}
+
+static void mtk_cam_update_s_data_exp(struct mtk_cam_ctx *ctx,
+					struct mtk_cam_request *req,
+					int raw_feature,
+					struct mtk_cam_mstream_exposure *exp)
+{
+	struct mtk_cam_request_stream_data *req_stream_data_1st =
+		mtk_cam_req_get_s_data(req, ctx->stream_id, 1);
+	struct mtk_cam_request_stream_data *req_stream_data_2nd =
+		mtk_cam_req_get_s_data(req, ctx->stream_id, 0);
+
+	if (!exp->valid)
+		return;
+
+	if (raw_feature == MSTREAM_NE_SE) {
+		req_stream_data_1st->mtk_cam_exposure = exp->exposure[0];
+		req_stream_data_2nd->mtk_cam_exposure = exp->exposure[1];
+	} else {
+		req_stream_data_2nd->mtk_cam_exposure = exp->exposure[0];
+		req_stream_data_1st->mtk_cam_exposure = exp->exposure[1];
+	}
+
+	exp->valid = 0;
+
+	dev_dbg(ctx->cam->dev,
+		"update mstream(%d) exposure 1st:%d 2nd:%d gain 1st:%d 2nd:%d\n",
+		raw_feature,
+		req_stream_data_1st->mtk_cam_exposure.shutter,
+		req_stream_data_2nd->mtk_cam_exposure.shutter,
+		req_stream_data_1st->mtk_cam_exposure.gain,
+		req_stream_data_2nd->mtk_cam_exposure.gain);
+}
+
+static int mtk_cam_fill_img_buf(struct mtkcam_ipi_img_output *img_out,
+						const struct v4l2_format *f, dma_addr_t daddr)
+{
+	u32 pixelformat = f->fmt.pix_mp.pixelformat;
+	u32 width = f->fmt.pix_mp.width;
+	u32 height = f->fmt.pix_mp.height;
+	const struct v4l2_plane_pix_format *plane = &f->fmt.pix_mp.plane_fmt[0];
+	u32 stride = plane->bytesperline;
+	u32 aligned_width;
+	unsigned int addr_offset = 0;
+	int i;
+	(void) width;
+
+	if (is_mtk_format(pixelformat)) {
+		const struct mtk_format_info *info;
+
+		info = mtk_format_info(pixelformat);
+		if (!info)
+			return -EINVAL;
+
+		aligned_width = stride / info->bpp[0];
+		if (info->mem_planes == 1) {
+			if (is_yuv_ufo(pixelformat)) {
+				aligned_width = ALIGN(width, 64);
+				img_out->buf[0][0].iova = daddr;
+				img_out->fmt.stride[0] = aligned_width * info->bit_r_num
+							 / info->bit_r_den;
+				img_out->buf[0][0].size = img_out->fmt.stride[0] * height;
+				img_out->buf[0][0].size += img_out->fmt.stride[0] * height / 2;
+				img_out->buf[0][0].size += ALIGN((aligned_width / 64), 8) * height;
+				img_out->buf[0][0].size += ALIGN((aligned_width / 64), 8) * height
+							   / 2;
+				img_out->buf[0][0].size += sizeof(struct UfbcBufferHeader);
+
+				pr_debug("plane:%d stride:%d plane_size:%d addr:0x%lx\n",
+					0, img_out->fmt.stride[0], img_out->buf[0][0].size,
+					(unsigned long)img_out->buf[0][0].iova);
+			} else if (is_raw_ufo(pixelformat)) {
+				aligned_width = ALIGN(width, 64);
+				img_out->buf[0][0].iova = daddr;
+				img_out->fmt.stride[0] = aligned_width * info->bit_r_num /
+							 info->bit_r_den;
+				img_out->buf[0][0].size = img_out->fmt.stride[0] * height;
+				img_out->buf[0][0].size += ALIGN((aligned_width / 64), 8) * height;
+				img_out->buf[0][0].size += sizeof(struct UfbcBufferHeader);
+
+				pr_debug("plane:%d stride:%d plane_size:%d addr:0x%lx\n",
+					0, img_out->fmt.stride[0], img_out->buf[0][0].size,
+					(unsigned long)img_out->buf[0][0].iova);
+			} else {
+				for (i = 0; i < info->comp_planes; i++) {
+					unsigned int hdiv = (i == 0) ? 1 : info->hdiv;
+					unsigned int vdiv = (i == 0) ? 1 : info->vdiv;
+
+					img_out->buf[0][i].iova = daddr + addr_offset;
+					img_out->fmt.stride[i] = info->bpp[i] *
+						DIV_ROUND_UP(aligned_width, hdiv);
+					img_out->buf[0][i].size = img_out->fmt.stride[i]
+						* DIV_ROUND_UP(height, vdiv);
+					addr_offset += img_out->buf[0][i].size;
+					pr_debug("plane:%d stride:%d plane_size:%d addr:0x%lx\n",
+						i, img_out->fmt.stride[i], img_out->buf[0][i].size,
+						(unsigned long)img_out->buf[0][i].iova);
+				}
+			}
+		} else {
+			pr_debug("do not support non contiguous mplane\n");
+		}
+	} else {
+		const struct v4l2_format_info *info;
+
+		info = v4l2_format_info(pixelformat);
+		if (!info)
+			return -EINVAL;
+
+		aligned_width = stride / info->bpp[0];
+		if (info->mem_planes == 1) {
+			for (i = 0; i < info->comp_planes; i++) {
+				unsigned int hdiv = (i == 0) ? 1 : info->hdiv;
+				unsigned int vdiv = (i == 0) ? 1 : info->vdiv;
+
+				img_out->buf[0][i].iova = daddr + addr_offset;
+				img_out->fmt.stride[i] = info->bpp[i] *
+					DIV_ROUND_UP(aligned_width, hdiv);
+				img_out->buf[0][i].size = img_out->fmt.stride[i]
+					* DIV_ROUND_UP(height, vdiv);
+				addr_offset += img_out->buf[0][i].size;
+				pr_debug("stride:%d plane_size:%d addr:0x%lx\n",
+					img_out->fmt.stride[i], img_out->buf[0][i].size,
+					(unsigned long)img_out->buf[0][i].iova);
+			}
+		} else {
+			pr_debug("do not support non contiguous mplane\n");
+		}
+	}
+
+	return 0;
+}
+
+static void mtk_cam_mstream_buf_update(struct mtk_cam_request *req,
+				unsigned int pipe_id, int feature,
+				unsigned int desc_id,
+				int buf_plane_idx,
+				struct vb2_buffer *vb,
+				const struct v4l2_format *f)
+{
+	struct mtk_cam_request_stream_data *req_stream_data =
+		mtk_cam_req_get_s_data(req, pipe_id, 0);
+	struct mtkcam_ipi_frame_param *frame_param =
+		&req_stream_data->frame_params;
+	struct mtk_cam_request_stream_data *req_stream_data_mstream =
+		mtk_cam_req_get_s_data(req, pipe_id, 1);
+	struct mtkcam_ipi_frame_param *mstream_frame_param =
+		&req_stream_data_mstream->frame_params;
+	int i = buf_plane_idx;
+	struct mtk_cam_buffer *buf = mtk_cam_vb2_buf_to_dev_buf(vb);
+	struct mtk_cam_video_device *node = mtk_cam_vbq_to_vdev(vb->vb2_queue);
+
+	if (i >= 2) {
+		pr_debug("mstream buffer plane over 2\n");
+		return;
+	}
+
+	mstream_frame_param->raw_param.exposure_num = 1;
+	frame_param->raw_param.exposure_num = 2;
+
+	if (mtk_cam_feature_is_mstream_m2m(feature)) {
+		/**
+		 * MSTREAM_SE_NE M2M orientation
+		 * First exposure:
+		 * Input = SE(RAWI2 node buffer through RAWI2),
+		 * Output = SE(IMGO node buffer)
+		 * hw_scenario -> MTKCAM_IPI_HW_PATH_OFFLINE_M2M
+		 *
+		 * Second exposure:
+		 * Intput = NE(RAWI2 buffer through RAWI6) + SE(IMGO buffer through RAWI2),
+		 * Output = NE(IMGO node buffer)
+		 * hw_scenario -> MTKCAM_IPI_HW_PATH_OFFLINE_STAGGER
+		 */
+
+		mstream_frame_param->raw_param.hardware_scenario =
+			MTKCAM_IPI_HW_PATH_OFFLINE_M2M;
+		frame_param->raw_param.hardware_scenario =
+			MTKCAM_IPI_HW_PATH_OFFLINE_STAGGER;
+
+		if ((feature & MSTREAM_NE_SE) == MSTREAM_NE_SE) {
+			if (i == 0) {
+				if (node->desc.id == MTK_RAW_MAIN_STREAM_OUT) {
+					int in_node;
+					unsigned int desc_id =
+						node->desc.id - MTK_RAW_SOURCE_BEGIN;
+
+					// 3. 1st exp NE output
+					mstream_frame_param->img_outs[desc_id].buf[0][0].iova =
+						buf->daddr;
+					mstream_frame_param->img_outs[desc_id].buf[0][0].size =
+						f->fmt.pix_mp.plane_fmt[0].sizeimage;
+
+					// SE output
+					frame_param->img_outs[desc_id].buf[0][0].iova =
+						buf->daddr + f->fmt.pix_mp.plane_fmt[0].sizeimage;
+					frame_param->img_outs[desc_id].buf[0][0].size =
+						f->fmt.pix_mp.plane_fmt[0].sizeimage;
+
+					pr_debug("mstream ne_se m2m ne imgo:0x%lx size:%d se imgo:0x%lx size:%d\n",
+					(unsigned long)mstream_frame_param->img_outs[desc_id].buf[0][0].iova,
+					mstream_frame_param->img_outs[desc_id].buf[0][0].size,
+					(unsigned long)frame_param->img_outs[desc_id].buf[0][0].iova,
+					frame_param->img_outs[desc_id].buf[0][0].size);
+
+					/**
+					 * 4. 2nd exp SE Intput =
+					 * SE(RAWI2 buffer through RAWI6)(step2) +
+					 * NE(IMGO buffer through RAWI2)
+					 */
+					in_node = MTKCAM_IPI_RAW_RAWI_2;
+
+					frame_param->img_ins[in_node -
+						MTKCAM_IPI_RAW_RAWI_2].buf[0].iova = buf->daddr;
+					frame_param->img_ins[in_node -
+						MTKCAM_IPI_RAW_RAWI_2].buf[0].size =
+						f->fmt.pix_mp.plane_fmt[i].sizeimage;
+
+					pr_debug("mstream ne_se m2m se rawi2:0x%lx size:%d\n",
+						(unsigned long)frame_param->img_ins[in_node -
+						MTKCAM_IPI_RAW_RAWI_2].
+						buf[0].iova, frame_param->img_ins[in_node -
+						MTKCAM_IPI_RAW_RAWI_2].
+						buf[0].size);
+				} else if (node->desc.id == MTK_RAW_RAWI_2_IN) {
+					// 1. 1st exp NE input
+					int in_node = MTKCAM_IPI_RAW_RAWI_2;
+
+					mstream_frame_param->img_ins[in_node -
+						MTKCAM_IPI_RAW_RAWI_2].buf[0].iova = buf->daddr;
+					mstream_frame_param->img_ins[in_node -
+						MTKCAM_IPI_RAW_RAWI_2].buf[0].size =
+						f->fmt.pix_mp.plane_fmt[0].sizeimage;
+
+					pr_debug("mstream ne_se m2m ne rawi2:0x%lx size:%d\n",
+						(unsigned long)mstream_frame_param->img_ins[
+						in_node -
+						MTKCAM_IPI_RAW_RAWI_2].buf[0].iova,
+						mstream_frame_param->img_ins[in_node -
+						MTKCAM_IPI_RAW_RAWI_2].buf[0].size);
+				}
+			} else if (i == 1) {
+				if (node->desc.id == MTK_RAW_MAIN_STREAM_OUT) {
+					/* main stream numplane is 1, not entering here */
+				} else if (node->desc.id == MTK_RAW_RAWI_2_IN) {
+					// 2. SE input
+					int in_node = MTKCAM_IPI_RAW_RAWI_6;
+
+					frame_param->img_ins[in_node -
+						MTKCAM_IPI_RAW_RAWI_2].buf[0].iova = buf->daddr +
+						f->fmt.pix_mp.plane_fmt[i].sizeimage;
+					frame_param->img_ins[in_node -
+						MTKCAM_IPI_RAW_RAWI_2].buf[0].size =
+						f->fmt.pix_mp.plane_fmt[i].sizeimage;
+
+					pr_debug("mstream ne_se m2m se rawi6:0x%lx size:%d\n",
+						(unsigned long)frame_param->img_ins[in_node -
+						MTKCAM_IPI_RAW_RAWI_2].
+						buf[0].iova, frame_param->img_ins[in_node -
+						MTKCAM_IPI_RAW_RAWI_2].buf[0].size);
+				}
+			}
+		} else { // MSTREAM_SE_NE
+			if (i == 0) {
+				if (node->desc.id == MTK_RAW_MAIN_STREAM_OUT) {
+					int in_node;
+					unsigned int desc_id =
+						node->desc.id - MTK_RAW_SOURCE_BEGIN;
+
+
+					// 3. 1st exp SE output
+					// as normal 1 exposure flow
+					mstream_frame_param->img_outs[desc_id].buf[0][0].iova =
+						buf->daddr + f->fmt.pix_mp.plane_fmt[i].sizeimage;
+					mstream_frame_param->img_outs[desc_id].buf[0][0].size =
+						f->fmt.pix_mp.plane_fmt[i].sizeimage;
+
+					// 2nd exp NE output
+					frame_param->img_outs[desc_id].buf[0][0].iova = buf->daddr;
+					frame_param->img_outs[desc_id].buf[0][0].size =
+						f->fmt.pix_mp.plane_fmt[i].sizeimage;
+
+					pr_debug("mstream se_ne m2m se imgo:0x%lx size:%d ne imgo:0x%lx size:%d\n",
+					(unsigned long)mstream_frame_param->img_outs[desc_id].buf[0][0].iova,
+					mstream_frame_param->img_outs[desc_id].buf[0][0].size,
+					(unsigned long)frame_param->img_outs[desc_id].buf[0][0].iova,
+					frame_param->img_outs[desc_id].buf[0][0].size);
+
+					/**
+					 * 4. 2nd exp NE Intput =
+					 * NE(RAWI2 buffer through RAWI6)(step2) +
+					 * SE(IMGO buffer through RAWI2)
+					 */
+					in_node = MTKCAM_IPI_RAW_RAWI_2;
+					frame_param->img_ins[in_node -
+						MTKCAM_IPI_RAW_RAWI_2].buf[0].iova =
+						buf->daddr + f->fmt.pix_mp.plane_fmt[i].sizeimage;
+					frame_param->img_ins[in_node -
+						MTKCAM_IPI_RAW_RAWI_2].buf[0].size =
+						f->fmt.pix_mp.plane_fmt[i].sizeimage;
+
+					pr_debug("mstream se_ne m2m ne rawi2:0x%lx size:%d\n",
+						(unsigned long)frame_param->img_ins[in_node -
+						MTKCAM_IPI_RAW_RAWI_2].buf[0].iova,
+						frame_param->img_ins[in_node -
+						MTKCAM_IPI_RAW_RAWI_2].buf[0].size);
+				} else if (node->desc.id == MTK_RAW_RAWI_2_IN) {
+					// 1. 1st exp SE input
+					int in_node = MTKCAM_IPI_RAW_RAWI_2;
+
+					mstream_frame_param->img_ins[in_node -
+						MTKCAM_IPI_RAW_RAWI_2].buf[0].iova =
+						buf->daddr + f->fmt.pix_mp.plane_fmt[i].sizeimage;
+					mstream_frame_param->img_ins[in_node -
+						MTKCAM_IPI_RAW_RAWI_2].buf[0].size =
+						f->fmt.pix_mp.plane_fmt[i].sizeimage;
+
+					pr_debug("mstream se_ne m2m se rawi2:0x%lx size:%d\n",
+						(unsigned long)mstream_frame_param->img_ins[
+						in_node - MTKCAM_IPI_RAW_RAWI_2].buf[0].iova,
+						mstream_frame_param->img_ins[in_node -
+						MTKCAM_IPI_RAW_RAWI_2].buf[0].size);
+				}
+			} else if (i == 1) {
+				if (node->desc.id == MTK_RAW_MAIN_STREAM_OUT) {
+					/* main stream numplane is 1, not entering here */
+				} else if (node->desc.id == MTK_RAW_RAWI_2_IN) {
+					// 2. 2nd exp NE input
+					int in_node = MTKCAM_IPI_RAW_RAWI_6;
+
+					frame_param->img_ins[in_node -
+						MTKCAM_IPI_RAW_RAWI_2].buf[0].iova = buf->daddr;
+					frame_param->img_ins[in_node -
+						MTKCAM_IPI_RAW_RAWI_2].buf[0].size =
+						f->fmt.pix_mp.plane_fmt[i].sizeimage;
+
+					pr_debug("mstream se_ne m2m ne rawi6:0x%lx size:%d\n",
+						(unsigned long)frame_param->img_ins[in_node -
+						MTKCAM_IPI_RAW_RAWI_2].buf[0].iova,
+						frame_param->img_ins[in_node -
+						MTKCAM_IPI_RAW_RAWI_2].buf[0].size);
+				}
+			}
+		}
+	} else {
+		if ((feature & MSTREAM_NE_SE) == MSTREAM_NE_SE)
+			frame_param->raw_param.hardware_scenario =
+			MTKCAM_IPI_HW_PATH_ON_THE_FLY_MSTREAM_NE_SE;
+		else
+			frame_param->raw_param.hardware_scenario =
+			MTKCAM_IPI_HW_PATH_ON_THE_FLY_MSTREAM_SE_NE;
+
+		// imgo mstream buffer layout is fixed plane[0]=NE, plane[1]=SE
+		if ((feature & MSTREAM_NE_SE) == MSTREAM_NE_SE) {
+			if (i == 0) { // normal output NE(plane[0]) first
+				// as normal 1 exposure flow
+				mstream_frame_param->img_outs[desc_id].buf[0][0].iova =
+					buf->daddr;
+				mstream_frame_param->img_outs[desc_id].buf[0][0].size =
+					f->fmt.pix_mp.plane_fmt[i].sizeimage;
+
+				pr_debug("mstream ne_se ne imgo:0x%lx size:%d\n",
+				(unsigned long)mstream_frame_param->img_outs[desc_id].buf[0][0].iova,
+				mstream_frame_param->img_outs[desc_id].buf[0][0].size);
+			} else if (i == 1) { // then SE
+				// in = NE output
+				int in_node = MTKCAM_IPI_RAW_RAWI_2;
+
+				frame_param->img_ins[in_node - MTKCAM_IPI_RAW_RAWI_2].buf[0]
+				.iova = mstream_frame_param->img_outs[desc_id].buf[0][0]
+				.iova;
+				frame_param->img_ins[in_node - MTKCAM_IPI_RAW_RAWI_2].buf[0]
+				.size = f->fmt.pix_mp.plane_fmt[0].sizeimage;
+				// out = SE output
+				frame_param->img_outs[desc_id].buf[0][0].iova =
+					buf->daddr + f->fmt.pix_mp.plane_fmt[i].sizeimage;
+				frame_param->img_outs[desc_id].buf[0][0].size =
+					f->fmt.pix_mp.plane_fmt[i].sizeimage;
+				pr_debug("mstream ne_se se rawi:0x%lx size:%d, imgo:0x%lx size:%d\n",
+					(unsigned long)frame_param->img_ins[in_node -
+					MTKCAM_IPI_RAW_RAWI_2].buf[0].iova,
+					frame_param->img_ins[in_node -
+					MTKCAM_IPI_RAW_RAWI_2].buf[0].size,
+					(unsigned long)frame_param->img_outs[desc_id].buf[0][0].iova,
+					frame_param->img_outs[desc_id].buf[0][0].size);
+			}
+		} else {
+			if (i == 0) { // normal output SE(plane[1]) first
+				mstream_frame_param->img_outs[desc_id].buf[0][0].iova =
+					buf->daddr + f->fmt.pix_mp.plane_fmt[i].sizeimage;
+				mstream_frame_param->img_outs[desc_id].buf[0][0].size =
+					f->fmt.pix_mp.plane_fmt[i].sizeimage;
+				pr_debug("mstream se_ne se imgo:0x%lx size:%d\n",
+				(unsigned long)mstream_frame_param->img_outs[desc_id].buf[0][0].iova,
+				mstream_frame_param->img_outs[desc_id].buf[0][0].size);
+			} else if (i == 1) { // then NE
+				// in = SE output
+				int in_node = MTKCAM_IPI_RAW_RAWI_2;
+
+				frame_param->img_ins[in_node - MTKCAM_IPI_RAW_RAWI_2].buf[0]
+				.iova = mstream_frame_param->img_outs[desc_id].buf[0][0]
+				.iova;
+				frame_param->img_ins[in_node - MTKCAM_IPI_RAW_RAWI_2].buf[0]
+					.size = f->fmt.pix_mp.plane_fmt[i].sizeimage;
+				// out = NE out
+				frame_param->img_outs[desc_id].buf[0][0].iova =
+					buf->daddr;
+				frame_param->img_outs[desc_id].buf[0][0].size =
+					f->fmt.pix_mp.plane_fmt[i].sizeimage;
+				pr_debug("mstream se_ne ne rawi:0x%lx size:%d, imgo:0x%lx size:%d\n",
+					(unsigned long)frame_param->img_ins[in_node -
+					MTKCAM_IPI_RAW_RAWI_2].buf[0].iova,
+					frame_param->img_ins[in_node -
+					MTKCAM_IPI_RAW_RAWI_2].buf[0].size,
+					(unsigned long)frame_param->img_outs[desc_id].buf[0][0].iova,
+					frame_param->img_outs[desc_id].buf[0][0].size);
+			}
+		}
+	}
+}
+
+static int mtk_cam_hdr_buf_update(struct vb2_buffer *vb,
+		enum hdr_scenario_id scenario,
+			   struct mtk_cam_request *req,
+			   unsigned int pipe_id,
+			   int feature, const struct v4l2_format *f)
+
+{
+	struct mtk_cam_buffer *buf = mtk_cam_vb2_buf_to_dev_buf(vb);
+	struct mtk_cam_video_device *node = mtk_cam_vbq_to_vdev(vb->vb2_queue);
+	unsigned int desc_id;
+	int i;
+	struct mtk_cam_request_stream_data *req_stream_data =
+		mtk_cam_req_get_s_data(req, pipe_id, 0);
+	struct mtkcam_ipi_frame_param *frame_param =
+		&req_stream_data->frame_params;
+
+	if (scenario != STAGGER_M2M)
+		desc_id = node->desc.id - MTK_RAW_SOURCE_BEGIN;
+	else
+		desc_id = node->desc.id - MTK_RAW_RAWI_2_IN;
+
+	for (i = 0 ; i < vb->num_planes; i++) {
+		vb->planes[i].data_offset =
+			i * f->fmt.pix_mp.plane_fmt[i].sizeimage;
+		if (mtk_cam_feature_is_mstream(feature) ||
+				mtk_cam_feature_is_mstream_m2m(feature)) {
+			mtk_cam_mstream_buf_update(req, pipe_id, feature,
+						desc_id, i, vb, f);
+		} else if (mtk_cam_get_sensor_exposure_num(feature) == 3) {
+			if (i == 0) { /* camsv1*/
+				int in_node = MTKCAM_IPI_RAW_RAWI_2;
+
+				frame_param->img_ins[in_node - MTKCAM_IPI_RAW_RAWI_2].buf[0]
+				.iova = buf->daddr + vb->planes[i].data_offset;
+				frame_param->img_ins[in_node - MTKCAM_IPI_RAW_RAWI_2].buf[0]
+					.size = f->fmt.pix_mp.plane_fmt[i].sizeimage;
+			} else if (i == 1) { /*camsv2*/
+				int in_node = MTKCAM_IPI_RAW_RAWI_3;
+
+				frame_param->img_ins[in_node - MTKCAM_IPI_RAW_RAWI_2].buf[0]
+				.iova = buf->daddr + vb->planes[i].data_offset;
+				frame_param->img_ins[in_node - MTKCAM_IPI_RAW_RAWI_2].buf[0]
+					.size = f->fmt.pix_mp.plane_fmt[i].sizeimage;
+			} else if (i == 2) { /*raw*/
+				if (scenario == STAGGER_M2M) {
+					int in_node = MTKCAM_IPI_RAW_RAWI_6;
+
+					frame_param->img_ins[in_node - MTKCAM_IPI_RAW_RAWI_2].buf[0]
+						.iova = buf->daddr + vb->planes[i].data_offset;
+					frame_param->img_ins[in_node - MTKCAM_IPI_RAW_RAWI_2].buf[0]
+						.size = f->fmt.pix_mp.plane_fmt[i].sizeimage;
+				} else {
+					frame_param->img_outs[desc_id].buf[0][0].iova =
+						buf->daddr + vb->planes[i].data_offset;
+				}
+			}
+		} else if (mtk_cam_get_sensor_exposure_num(feature) == 2) {
+			if (i == 0) { /* camsv1*/
+				int in_node = MTKCAM_IPI_RAW_RAWI_2;
+
+				frame_param->img_ins[in_node - MTKCAM_IPI_RAW_RAWI_2].buf[0]
+				.iova = buf->daddr + vb->planes[i].data_offset;
+				frame_param->img_ins[in_node - MTKCAM_IPI_RAW_RAWI_2].buf[0]
+					.size = f->fmt.pix_mp.plane_fmt[i].sizeimage;
+			} else if (i == 1) { /*raw*/
+				if (scenario == STAGGER_M2M) {
+					int in_node = MTKCAM_IPI_RAW_RAWI_6;
+
+					frame_param->img_ins[in_node - MTKCAM_IPI_RAW_RAWI_2].buf[0]
+						.iova = buf->daddr + vb->planes[i].data_offset;
+					frame_param->img_ins[in_node - MTKCAM_IPI_RAW_RAWI_2].buf[0]
+						.size = f->fmt.pix_mp.plane_fmt[i].sizeimage;
+				} else {
+					frame_param->img_outs[desc_id].buf[0][0].iova =
+						buf->daddr + vb->planes[i].data_offset;
+				}
+			}
+		}
+	}
+
+	return 0;
+}
+
+/* Update raw_param.imgo_path_sel */
+static void mtk_cam_config_raw_path(struct mtk_cam_request_stream_data *s_data,
+				   struct mtk_cam_buffer *buf)
+{
+	struct mtk_cam_ctx *ctx;
+	struct mtk_cam_device *cam;
+	struct mtk_cam_video_device *node;
+	struct mtk_raw_pipeline *raw_pipline;
+	struct mtkcam_ipi_frame_param *frame_param;
+
+	ctx = mtk_cam_s_data_get_ctx(s_data);
+	cam = ctx->cam;
+	frame_param = &s_data->frame_params;
+	node = mtk_cam_vbq_to_vdev(buf->vbb.vb2_buf.vb2_queue);
+	raw_pipline = mtk_cam_dev_get_raw_pipeline(cam, node->uid.pipe_id);
+
+	if (raw_pipline->res_config.raw_path == V4L2_MTK_CAM_RAW_PATH_SELECT_BPC)
+		frame_param->raw_param.imgo_path_sel = MTKCAM_IPI_IMGO_AFTER_BPC;
+	else if (raw_pipline->res_config.raw_path == V4L2_MTK_CAM_RAW_PATH_SELECT_FUS)
+		frame_param->raw_param.imgo_path_sel = MTKCAM_IPI_IMGO_AFTER_FUS;
+	else if (raw_pipline->res_config.raw_path == V4L2_MTK_CAM_RAW_PATH_SELECT_DGN)
+		frame_param->raw_param.imgo_path_sel = MTKCAM_IPI_IMGO_AFTER_DGN;
+	else if (raw_pipline->res_config.raw_path == V4L2_MTK_CAM_RAW_PATH_SELECT_LSC)
+		frame_param->raw_param.imgo_path_sel = MTKCAM_IPI_IMGO_AFTER_LSC;
+	else if (raw_pipline->res_config.raw_path == V4L2_MTK_CAM_RAW_PATH_SELECT_LTM)
+		frame_param->raw_param.imgo_path_sel = MTKCAM_IPI_IMGO_AFTER_LTM;
+	else
+		/* un-processed raw frame */
+		frame_param->raw_param.imgo_path_sel = MTKCAM_IPI_IMGO_UNPROCESSED;
+
+	dev_dbg(cam->dev, "%s: node:%d fd:%d idx:%d raw_path(%d) ipi imgo_path_sel(%d))\n",
+		__func__, node->desc.id, buf->vbb.request_fd, buf->vbb.vb2_buf.index,
+		raw_pipline->res_config.raw_path, frame_param->raw_param.imgo_path_sel);
+}
+
+/*
+ * Update:
+ * 1. imgo's buffer information (address and size)
+ * 2. rawi's buffer information (address and size) if it is stagger or mstream case
+ * 3. camsv's buffer information (address and size) if it is stagger
+ */
+static int mtk_cam_config_raw_img_out_imgo(struct mtk_cam_request_stream_data *s_data,
+				      struct mtk_cam_buffer *buf)
+{
+	enum hdr_scenario_id scenario;
+	struct mtk_cam_ctx *ctx;
+	struct mtk_cam_device *cam;
+	struct mtk_cam_request *req;
+	struct mtk_cam_video_device *node;
+	struct mtkcam_ipi_frame_param *frame_param;
+	struct mtkcam_ipi_img_output *img_out;
+	struct vb2_buffer *vb;
+	const struct v4l2_format *cfg_fmt;
+	int i;
+	int feature, hdr_feature;
+	unsigned int pixelformat;
+
+	ctx = mtk_cam_s_data_get_ctx(s_data);
+	cam = ctx->cam;
+	feature = s_data->feature.raw_feature;
+	req = mtk_cam_s_data_get_req(s_data);
+	frame_param = &s_data->frame_params;
+	vb = &buf->vbb.vb2_buf;
+	node = mtk_cam_vbq_to_vdev(buf->vbb.vb2_buf.vb2_queue);
+
+	/* TODO: support sub-sampling multi-plane buffer */
+	img_out = &frame_param->img_outs[node->desc.id - MTK_RAW_SOURCE_BEGIN];
+	cfg_fmt = mtk_cam_s_data_get_vfmt(s_data, node->desc.id);
+	if (!cfg_fmt) {
+		dev_info(cam->dev,
+			 "%s:%s:pipe(%d):%s: can't find the vfmt field to save\n",
+			 __func__, req->req.debug_str, node->uid.pipe_id, node->desc.name);
+		return -EINVAL;
+	}
+	pixelformat = cfg_fmt->fmt.pix_mp.pixelformat;
+	img_out->buf[0][0].iova = buf->daddr;
+	img_out->buf[0][0].fd = vb->planes[0].m.fd;
+	if (is_raw_ufo(pixelformat))
+		mtk_cam_fill_img_buf(img_out, cfg_fmt, buf->daddr);
+
+	if ((feature & MTK_CAM_FEATURE_HDR_MASK) &&
+		!(feature & MTK_CAM_FEATURE_OFFLINE_M2M_MASK)) {
+		hdr_feature = feature & MTK_CAM_FEATURE_HDR_MASK;
+		if (hdr_feature == MSTREAM_NE_SE ||
+		    hdr_feature == MSTREAM_SE_NE)
+			scenario = MSTREAM;
+		else
+			scenario = STAGGER_ON_THE_FLY;
+		mtk_cam_hdr_buf_update(vb, scenario, req, node->uid.pipe_id,
+				       feature, cfg_fmt);
+	} else if (mtk_cam_feature_is_mstream_m2m(feature)) {
+		mtk_cam_hdr_buf_update(vb, MSTREAM_M2M, req,
+				       node->uid.pipe_id,
+				       feature, cfg_fmt);
+	}
+
+	if (mtk_cam_feature_is_subsample(feature)) {
+		for (i = 0 ; i < vb->num_planes; i++) {
+			vb->planes[i].data_offset =
+				i * cfg_fmt->fmt.pix_mp.plane_fmt[i].sizeimage;
+			img_out->buf[i][0].iova =
+				buf->daddr + vb->planes[i].data_offset;
+		}
+		/* FOR 16 subsample ratios - FIXME */
+		if (feature == HIGHFPS_16_SUBSAMPLE)
+			for (i = MAX_SUBSAMPLE_PLANE_NUM; i < 16; i++)
+				img_out->buf[i][0].iova =
+				buf->daddr + i * cfg_fmt->fmt.pix_mp.plane_fmt[0].sizeimage;
+		/* FOR 32 subsample ratios - FIXME */
+		if (feature == HIGHFPS_32_SUBSAMPLE)
+			for (i = MAX_SUBSAMPLE_PLANE_NUM; i < 32; i++)
+				img_out->buf[i][0].iova =
+				buf->daddr + i * cfg_fmt->fmt.pix_mp.plane_fmt[0].sizeimage;
+	}
+
+	return 0;
+}
+
+/* Update dmo's buffer information except imgo (address and size) */
+static int mtk_cam_config_raw_img_out(struct mtk_cam_request_stream_data *s_data,
+				     struct mtk_cam_buffer *buf)
+{
+	struct mtk_cam_ctx *ctx;
+	struct mtk_cam_device *cam;
+	struct mtk_cam_request *req;
+	struct mtk_cam_video_device *node;
+	struct mtkcam_ipi_frame_param *frame_param;
+	struct mtkcam_ipi_img_output *img_out;
+	struct vb2_buffer *vb;
+	const struct v4l2_format *cfg_fmt;
+
+	int i, p;
+	int feature;
+	int comp_planes, plane;
+	unsigned int offset;
+
+	ctx = mtk_cam_s_data_get_ctx(s_data);
+	cam = ctx->cam;
+	feature = s_data->feature.raw_feature;
+	req = mtk_cam_s_data_get_req(s_data);
+	frame_param = &s_data->frame_params;
+	vb = &buf->vbb.vb2_buf;
+	node = mtk_cam_vbq_to_vdev(buf->vbb.vb2_buf.vb2_queue);
+
+	/* TODO: support sub-sampling multi-plane buffer */
+	img_out = &frame_param->img_outs[node->desc.id - MTK_RAW_SOURCE_BEGIN];
+	cfg_fmt = mtk_cam_s_data_get_vfmt(s_data, node->desc.id);
+	if (!cfg_fmt) {
+		dev_info(cam->dev,
+			 "%s:%s:pipe(%d):%s: can't find the vfmt field to save\n",
+			 __func__, req->req.debug_str, node->uid.pipe_id, node->desc.name);
+		return -EINVAL;
+	}
+
+	img_out->buf[0][0].fd = vb->planes[0].m.fd;
+	mtk_cam_fill_img_buf(img_out, cfg_fmt, buf->daddr);
+	if (mtk_cam_feature_is_subsample(feature)) {
+		comp_planes = 1;
+		if (is_mtk_format(cfg_fmt->fmt.pix_mp.pixelformat)) {
+			const struct mtk_format_info *mtk_info =
+				mtk_format_info(cfg_fmt->fmt.pix_mp.pixelformat);
+			comp_planes = mtk_info->comp_planes;
+		} else {
+			const struct v4l2_format_info *v4l2_info =
+				v4l2_format_info(cfg_fmt->fmt.pix_mp.pixelformat);
+			comp_planes = v4l2_info->comp_planes;
+		}
+
+		for (i = 1 ; i < vb->num_planes; i++) {
+			offset = i * cfg_fmt->fmt.pix_mp.plane_fmt[i].sizeimage;
+			vb->planes[i].data_offset = offset;
+
+			img_out->buf[i][0].iova = buf->daddr + offset;
+			img_out->buf[i][0].size = img_out->buf[0][0].size;
+			for (plane = 1 ; plane < comp_planes; plane++) {
+				img_out->buf[i][plane].iova =
+					img_out->buf[i][plane-1].iova +
+					img_out->buf[i][plane-1].size;
+				img_out->buf[i][plane].size =
+					img_out->buf[0][plane].size;
+			}
+		}
+
+		/* FOR 16 subsample ratios - FIXME */
+		if (feature == HIGHFPS_16_SUBSAMPLE) {
+			for (i = MAX_SUBSAMPLE_PLANE_NUM; i < 16; i++) {
+				offset = i * cfg_fmt->fmt.pix_mp.plane_fmt[0].sizeimage;
+				img_out->buf[i][0].iova = buf->daddr + offset;
+				img_out->buf[i][0].size = img_out->buf[0][0].size;
+
+				for (p = 1 ; p < comp_planes; p++) {
+					img_out->buf[i][p].iova =
+						img_out->buf[i][p-1].iova +
+						img_out->buf[i][p-1].size;
+					img_out->buf[i][p].size =
+						img_out->buf[0][p].size;
+				}
+			}
+		}
+
+		/* FOR 32 subsample ratios - FIXME */
+		if (feature == HIGHFPS_32_SUBSAMPLE) {
+			for (i = MAX_SUBSAMPLE_PLANE_NUM; i < 32; i++) {
+				offset = i * cfg_fmt->fmt.pix_mp.plane_fmt[0].sizeimage;
+				img_out->buf[i][0].iova = buf->daddr + offset;
+				img_out->buf[i][0].size = img_out->buf[0][0].size;
+				for (p = 1 ; p < comp_planes; p++) {
+					img_out->buf[i][p].iova =
+						img_out->buf[i][p-1].iova +
+						img_out->buf[i][p-1].size;
+					img_out->buf[i][p].size =
+						img_out->buf[0][p].size;
+				}
+			}
+		}
+
+	}
+
+	return 0;
+}
+
+static int
+mtk_cam_config_raw_img_fmt(struct mtk_cam_request_stream_data *s_data,
+			      struct mtk_cam_buffer *buf)
+{
+	struct mtk_cam_ctx *ctx;
+	struct mtk_cam_device *cam;
+	struct mtk_cam_request *req;
+	struct mtk_cam_video_device *node;
+	struct mtkcam_ipi_frame_param *frame_param;
+	struct mtkcam_ipi_img_output *img_out;
+	int feature;
+	struct v4l2_mbus_framefmt *pfmt;
+	int sd_width, sd_height, ret;
+	const struct v4l2_format *cfg_fmt;
+	struct v4l2_selection *cfg_selection;
+
+	ctx = mtk_cam_s_data_get_ctx(s_data);
+	cam = ctx->cam;
+	feature = s_data->feature.raw_feature;
+	req = mtk_cam_s_data_get_req(s_data);
+	frame_param = &s_data->frame_params;
+	node = mtk_cam_vbq_to_vdev(buf->vbb.vb2_buf.vb2_queue);
+
+	/* TODO: support sub-sampling multi-plane buffer */
+	img_out = &frame_param->img_outs[node->desc.id - MTK_RAW_SOURCE_BEGIN];
+	cfg_fmt = mtk_cam_s_data_get_vfmt(s_data, node->desc.id);
+	if (!cfg_fmt) {
+		dev_info(cam->dev,
+			 "%s:%s:pipe(%d):%s: can't find the vfmt field to save\n",
+			 __func__, req->req.debug_str, node->uid.pipe_id, node->desc.name);
+		return -EINVAL;
+	}
+
+	cfg_selection = mtk_cam_s_data_get_vsel(s_data, node->desc.id);
+
+	pfmt = mtk_cam_s_data_get_pfmt(s_data, MTK_RAW_SINK);
+	sd_width = pfmt->width;
+	sd_height = pfmt->height;
+
+	img_out->uid.pipe_id = node->uid.pipe_id;
+	img_out->uid.id =  node->desc.dma_port;
+
+	img_out->crop.p.x = cfg_selection->r.left;
+	img_out->crop.p.y = cfg_selection->r.top;
+	img_out->crop.s.w = cfg_selection->r.width;
+	img_out->crop.s.h = cfg_selection->r.height;
+
+	ret = config_img_fmt(cam, node, cfg_fmt, img_out, sd_width, sd_height);
+	if (ret)
+		return ret;
+
+	if (mtk_cam_feature_is_stagger(feature))
+		config_img_in_fmt_stagger(cam, s_data, node,
+					  cfg_fmt, ctx->pipe->stagger_path, feature);
+
+	if (mtk_cam_feature_is_time_shared(feature))
+		config_img_in_fmt_time_shared(cam, s_data, node, cfg_fmt);
+
+	if ((mtk_cam_feature_is_mstream(feature) || mtk_cam_feature_is_mstream_m2m(feature))
+	    && node->desc.dma_port == MTKCAM_IPI_RAW_IMGO) {
+		ret = config_img_fmt_mstream(ctx, req,
+					     cfg_fmt, node,
+					     sd_width, sd_height, feature);
+		if (ret)
+			return ret;
+	}
+	return 0;
+}
+
+static int
+mtk_cam_config_raw_img_in_rawi2(struct mtk_cam_request_stream_data *s_data,
+			  struct mtk_cam_buffer *buf)
+{
+	struct mtk_cam_ctx *ctx;
+	struct mtk_cam_device *cam;
+	struct mtk_cam_request *req;
+	struct mtk_cam_video_device *node;
+	struct mtkcam_ipi_frame_param *frame_param;
+	struct mtkcam_ipi_img_input *in_fmt;
+	struct vb2_buffer *vb;
+	const struct v4l2_format *cfg_fmt;
+	int feature;
+	int ret;
+
+	ctx = mtk_cam_s_data_get_ctx(s_data);
+	cam = ctx->cam;
+	feature = s_data->feature.raw_feature;
+	req = mtk_cam_s_data_get_req(s_data);
+	frame_param = &s_data->frame_params;
+	vb = &buf->vbb.vb2_buf;
+	node = mtk_cam_vbq_to_vdev(buf->vbb.vb2_buf.vb2_queue);
+	in_fmt = &frame_param->img_ins[node->desc.id - MTK_RAW_RAWI_2_IN];
+
+	cfg_fmt = mtk_cam_s_data_get_vfmt(s_data, node->desc.id);
+	if (!cfg_fmt) {
+		dev_info(cam->dev,
+			 "%s:%s:pipe(%d):%s: can't find the vfmt field to save\n",
+			 __func__, req->req.debug_str, node->uid.pipe_id, node->desc.name);
+		return -EINVAL;
+	}
+
+	if (feature & MTK_CAM_FEATURE_OFFLINE_M2M_MASK &&
+		feature & MTK_CAM_FEATURE_HDR_MASK) {
+		if (mtk_cam_feature_is_stagger_m2m(feature)) {
+			mtk_cam_hdr_buf_update(vb, STAGGER_M2M,
+						req, node->uid.pipe_id, feature, cfg_fmt);
+			frame_param->raw_param.hardware_scenario =
+				MTKCAM_IPI_HW_PATH_OFFLINE_STAGGER;
+			frame_param->raw_param.exposure_num =
+				mtk_cam_get_sensor_exposure_num(feature);
+		} else if (mtk_cam_feature_is_mstream_m2m(feature)) {
+			mtk_cam_hdr_buf_update(vb, MSTREAM_M2M,
+					       req, node->uid.pipe_id,
+					       feature, cfg_fmt);
+		}
+	} else {
+		in_fmt->buf[0].iova = buf->daddr;
+		frame_param->raw_param.hardware_scenario =
+			MTKCAM_IPI_HW_PATH_OFFLINE_M2M;
+	}
+
+	in_fmt->uid.pipe_id = node->uid.pipe_id;
+	in_fmt->uid.id = node->desc.dma_port;
+	ret = config_img_in_fmt(cam, node, cfg_fmt, in_fmt);
+	if (ret)
+		return ret;
+
+	if (mtk_cam_feature_is_stagger_m2m(feature))
+		config_img_in_fmt_stagger(cam, s_data, node, cfg_fmt, STAGGER_M2M, feature);
+
+	if (mtk_cam_feature_is_mstream_m2m(feature))
+		config_img_in_fmt_mstream(cam, s_data, node, cfg_fmt, feature);
+
+	return 0;
+}
+
+static int
+mtk_cam_camsv_update_fparam(struct mtk_cam_request_stream_data *s_data,
+			      struct mtk_cam_buffer *buf)
+{
+	struct mtk_cam_video_device *node;
+	struct mtk_cam_ctx *ctx;
+	const struct v4l2_format *cfg_fmt;
+
+	ctx = mtk_cam_s_data_get_ctx(s_data);
+	node = mtk_cam_vbq_to_vdev(buf->vbb.vb2_buf.vb2_queue);
+	cfg_fmt = mtk_cam_s_data_get_vfmt(s_data, node->desc.id);
+	if (s_data->vdev_fmt_update && cfg_fmt) {
+		mtk_cam_sv_cal_cfg_info(
+			ctx, cfg_fmt, &s_data->sv_frame_params);
+	}
+
+	return 0;
+}
+
+static int mtk_cam_req_update(struct mtk_cam_device *cam,
+			      struct mtk_cam_request *req)
+{
+	struct media_request_object *obj, *obj_prev;
+	struct vb2_buffer *vb;
+	struct mtk_cam_buffer *buf;
+	struct mtk_cam_video_device *node;
+	struct mtk_cam_ctx *ctx;
+	struct mtk_cam_request_stream_data *req_stream_data, *req_stream_data_mstream;
+	int i, ctx_cnt;
+	int raw_feature;
+	int res_feature;
+	int ret;
+
+	dev_dbg(cam->dev, "update request:%s\n", req->req.debug_str);
+
+	mtk_cam_req_set_fmt(cam, req);
+
+	list_for_each_entry_safe(obj, obj_prev, &req->req.objects, list) {
+		if (!vb2_request_object_is_buffer(obj))
+			continue;
+		vb = container_of(obj, struct vb2_buffer, req_obj);
+		buf = mtk_cam_vb2_buf_to_dev_buf(vb);
+		node = mtk_cam_vbq_to_vdev(vb->vb2_queue);
+
+		ctx = mtk_cam_find_ctx(cam, &node->vdev.entity);
+		req->ctx_used |= 1 << ctx->stream_id;
+
+		req_stream_data = mtk_cam_req_get_s_data(req, node->uid.pipe_id, 0);
+		req_stream_data->ctx = ctx;
+		req_stream_data->no_frame_done_cnt = 0;
+		atomic_set(&req_stream_data->sensor_work.is_queued, 0);
+		atomic_set(&req_stream_data->dbg_work.state, MTK_CAM_REQ_DBGWORK_S_INIT);
+		req_stream_data->dbg_work.dump_flags = 0;
+		atomic_set(&req_stream_data->dbg_exception_work.state, MTK_CAM_REQ_DBGWORK_S_INIT);
+		req_stream_data->dbg_exception_work.dump_flags = 0;
+		atomic_set(&req_stream_data->frame_done_work.is_queued, 0);
+		req->sync_id = (ctx->used_raw_num) ? ctx->pipe->sync_id : 0;
+
+		raw_feature = req_stream_data->feature.raw_feature;
+		if (mtk_cam_feature_is_mstream(raw_feature))
+			mtk_cam_update_s_data_exp(ctx, req, raw_feature,
+						  &ctx->pipe->mstream_exposure);
+
+		if (mtk_cam_feature_is_mstream(raw_feature) ||
+		    mtk_cam_feature_is_mstream_m2m(raw_feature)) {
+			req_stream_data_mstream = mtk_cam_req_get_s_data(req, node->uid.pipe_id, 1);
+			req_stream_data_mstream->ctx = ctx;
+		}
+
+		/* TODO: AFO independent supports TWIN */
+		if (ctx->used_raw_num && ctx->pipe->res_config.raw_num_used == 1)
+			req_stream_data->flags |= MTK_CAM_REQ_S_DATA_FLAG_META1_INDEPENDENT;
+
+		if (req_stream_data->seninf_new)
+			ctx->seninf = req_stream_data->seninf_new;
+
+		/* update buffer format */
+		switch (node->desc.dma_port) {
+		case MTKCAM_IPI_RAW_RAWI_2:
+			ret = mtk_cam_config_raw_img_in_rawi2(req_stream_data, buf);
+			if (ret)
+				return ret;
+			break;
+		case MTKCAM_IPI_RAW_IMGO:
+			mtk_cam_config_raw_path(req_stream_data, buf);
+			ret = mtk_cam_config_raw_img_out_imgo(req_stream_data, buf);
+			if (ret)
+				return ret;
+
+			ret = mtk_cam_config_raw_img_fmt(req_stream_data, buf);
+			if (ret)
+				return ret;
+			break;
+		case MTKCAM_IPI_RAW_YUVO_1:
+		case MTKCAM_IPI_RAW_YUVO_2:
+		case MTKCAM_IPI_RAW_YUVO_3:
+		case MTKCAM_IPI_RAW_YUVO_4:
+		case MTKCAM_IPI_RAW_YUVO_5:
+		case MTKCAM_IPI_RAW_RZH1N2TO_1:
+		case MTKCAM_IPI_RAW_RZH1N2TO_2:
+		case MTKCAM_IPI_RAW_RZH1N2TO_3:
+		case MTKCAM_IPI_RAW_DRZS4NO_1:
+		case MTKCAM_IPI_RAW_DRZS4NO_2:
+		case MTKCAM_IPI_RAW_DRZS4NO_3:
+			ret = mtk_cam_config_raw_img_out(req_stream_data, buf);
+			if (ret)
+				return ret;
+
+			ret = mtk_cam_config_raw_img_fmt(req_stream_data, buf);
+				if (ret)
+					return ret;
+			break;
+
+		case MTKCAM_IPI_CAMSV_MAIN_OUT:
+			mtk_cam_camsv_update_fparam(req_stream_data, buf);
+			break;
+		case MTKCAM_IPI_RAW_META_STATS_CFG:
+		case MTKCAM_IPI_RAW_META_STATS_0:
+		case MTKCAM_IPI_RAW_META_STATS_1:
+		case MTKCAM_IPI_RAW_META_STATS_2:
+			break;
+		default:
+			/* Do nothing for the ports not related to crop settings */
+			break;
+		}
+	}
+
+	/* frame sync */
+	/* prepare img working buf */
+	ctx_cnt = 0;
+	for (i = 0; i < cam->max_stream_num; i++) {
+		if (!(1 << i & req->ctx_used))
+			continue;
+
+		/* TODO: user fs */
+		ctx_cnt++;
+
+		ctx = &cam->ctxs[i];
+		req_stream_data = mtk_cam_req_get_s_data(req, ctx->stream_id, 0);
+		if (!req_stream_data)
+			continue;
+		res_feature = mtk_cam_s_data_get_res_feature(req_stream_data);
+		if (mtk_cam_feature_is_time_shared(res_feature))
+			check_timeshared_buffer(cam, ctx, req);
+
+		if (mtk_cam_feature_is_mstream(req_stream_data->feature.raw_feature) ||
+		    mtk_cam_feature_is_mstream_m2m(req_stream_data->feature.raw_feature))
+			check_mstream_buffer(cam, ctx, req);
+	}
+	req->fs.target = ctx_cnt > 1 ? ctx_cnt : 0;
+
+	return 0;
+}
+
+/* Check all pipeline involved in the request are streamed on */
+static int mtk_cam_dev_req_is_stream_on(struct mtk_cam_device *cam,
+					struct mtk_cam_request *req)
+{
+	dev_dbg(cam->dev,
+		"%s: pipe_used(0x%x), streaming_pipe(0x%x), req(%s)\n",
+		__func__, req->pipe_used, cam->streaming_pipe,
+		req->req.debug_str);
+	return (req->pipe_used & cam->streaming_pipe) == req->pipe_used;
+}
+
+static void mtk_cam_req_work_init(struct mtk_cam_req_work *work,
+	struct mtk_cam_request_stream_data *s_data)
+{
+	work->s_data = s_data;
+}
+
+static void fill_mstream_s_data(struct mtk_cam_ctx *ctx,
+				struct mtk_cam_request *req)
+{
+	struct mtk_cam_req_work *frame_work, *frame_done_work;
+	struct mtk_cam_request_stream_data *req_stream_data;
+	struct mtk_cam_request_stream_data *req_stream_data_mstream;
+	struct mtk_cam_request_stream_data *pipe_stream_data;
+	unsigned int j;
+
+	req_stream_data = mtk_cam_req_get_s_data(req, ctx->stream_id, 0);
+	req_stream_data_mstream =
+		mtk_cam_req_get_s_data(req, ctx->stream_id, 1);
+
+	req_stream_data_mstream->frame_seq_no = req_stream_data->frame_seq_no;
+	req_stream_data->frame_seq_no =
+		req_stream_data_mstream->frame_seq_no + 1;
+
+	req_stream_data_mstream->feature.raw_feature =
+		req_stream_data->feature.raw_feature;
+
+	req_stream_data_mstream->sensor = req_stream_data->sensor;
+	req_stream_data_mstream->raw_hdl_obj = req_stream_data->raw_hdl_obj;
+	req_stream_data_mstream->sensor_hdl_obj = req_stream_data->sensor_hdl_obj;
+	req_stream_data_mstream->flags |= req_stream_data->flags &
+					  MTK_CAM_REQ_S_DATA_FLAG_SENSOR_HDL_EN;
+	req_stream_data_mstream->flags |= req_stream_data->flags &
+					  MTK_CAM_REQ_S_DATA_FLAG_RAW_HDL_EN;
+
+	atomic_set(&ctx->enqueued_frame_seq_no, req_stream_data->frame_seq_no);
+
+	/* sensor switch update s_data state */
+	if (req->ctx_link_update & (1 << ctx->stream_id)) {
+		req_stream_data->state.estate = E_STATE_READY;
+		req_stream_data_mstream->state.estate = E_STATE_SENINF;
+	}
+
+	pr_debug("%s: frame_seq:%d, frame_mstream_seq:%d\n",
+		__func__, req_stream_data->frame_seq_no,
+		req_stream_data_mstream->frame_seq_no);
+
+	req_stream_data_mstream->ctx = ctx;
+	req_stream_data_mstream->no_frame_done_cnt = 0;
+	atomic_set(&req_stream_data_mstream->sensor_work.is_queued, 0);
+	atomic_set(&req_stream_data_mstream->dbg_work.state,
+			MTK_CAM_REQ_DBGWORK_S_INIT);
+	req_stream_data_mstream->dbg_work.dump_flags = 0;
+	atomic_set(&req_stream_data_mstream->dbg_exception_work.state,
+			MTK_CAM_REQ_DBGWORK_S_INIT);
+	req_stream_data_mstream->dbg_exception_work.dump_flags = 0;
+	atomic_set(&req_stream_data_mstream->frame_done_work.is_queued, 0);
+
+	frame_work = &req_stream_data_mstream->frame_work;
+	mtk_cam_req_work_init(frame_work, req_stream_data_mstream);
+
+
+	for (j = MTKCAM_SUBDEV_RAW_START ; j < MTKCAM_SUBDEV_RAW_END ; j++) {
+		if (1 << j & ctx->streaming_pipe) {
+			pipe_stream_data = mtk_cam_req_get_s_data(req, j, 1);
+			frame_done_work = &pipe_stream_data->frame_done_work;
+			mtk_cam_req_work_init(frame_done_work, pipe_stream_data);
+			INIT_WORK(&frame_done_work->work, mtk_cam_frame_done_work);
+		}
+	}
+}
+
+static void fill_sv_mstream_s_data(struct mtk_cam_device *cam,
+				struct mtk_cam_request *req, unsigned int pipe_id)
+{
+	struct mtk_cam_req_work *frame_done_work, *sv_work;
+	struct mtk_cam_request_stream_data *req_stream_data;
+	struct mtk_cam_request_stream_data *req_stream_data_mstream;
+
+	req_stream_data = mtk_cam_req_get_s_data(req, pipe_id, 0);
+	req_stream_data_mstream =
+		mtk_cam_req_get_s_data(req, pipe_id, 1);
+
+	/* sequence number */
+	req_stream_data_mstream->frame_seq_no = req_stream_data->frame_seq_no;
+	req_stream_data->frame_seq_no =
+		req_stream_data_mstream->frame_seq_no + 1;
+	atomic_set(&cam->ctxs[pipe_id].enqueued_frame_seq_no, req_stream_data->frame_seq_no);
+
+	/* frame done work */
+	atomic_set(&req_stream_data_mstream->frame_done_work.is_queued, 0);
+	frame_done_work = &req_stream_data_mstream->frame_done_work;
+	mtk_cam_req_work_init(frame_done_work, req_stream_data_mstream);
+	INIT_WORK(&frame_done_work->work, mtk_cam_frame_done_work);
+
+	/* sv work */
+	sv_work = &req_stream_data_mstream->sv_work;
+	mtk_cam_req_work_init(sv_work, req_stream_data_mstream);
+	INIT_WORK(&sv_work->work, mtk_cam_sv_work);
+
+	/* sv parameters */
+	req_stream_data_mstream->sv_frame_params = req_stream_data->sv_frame_params;
+
+	dev_dbg(cam->dev, "%s: pipe_id:%d, frame_seq:%d frame_mstream_seq:%d\n",
+		__func__, pipe_id, req_stream_data->frame_seq_no,
+		req_stream_data_mstream->frame_seq_no);
+}
+
+static void
+immediate_link_update_chk(struct mtk_cam_ctx *ctx, int pipe_id,
+					int running_s_data_num,
+					struct mtk_cam_request_stream_data *s_data)
+{
+	struct mtk_cam_request *req = mtk_cam_s_data_get_req(s_data);
+
+	if (req->ctx_link_update && (!s_data->seninf_new || !s_data->seninf_old)) {
+		dev_info(ctx->cam->dev,
+			"%s:req(%s):pipe(%d):seq(%d):ctx_link_update(0x%x):seninf_old(%p),seninf_new(%p) can't be null\n",
+			__func__, req->req.debug_str, pipe_id,
+			s_data->frame_seq_no, req->ctx_link_update,
+			s_data->seninf_old, s_data->seninf_new);
+		req->ctx_link_update = 0;
+	}
+
+	/**
+	 * If there is only one running job and it is the
+	 * switching request, trigger the seninf change
+	 * before set sensor.
+	 */
+	if (req->ctx_link_update & (1 << pipe_id)) {
+		if (running_s_data_num == 1) {
+			dev_info(ctx->cam->dev,
+				"%s:req(%s):pipe(%d):link change before enqueue: seq(%d), running_s_data_num(%d)\n",
+				__func__, req->req.debug_str, pipe_id,
+				s_data->frame_seq_no, running_s_data_num);
+			s_data->state.estate = E_STATE_SENINF;
+			req->flags |= MTK_CAM_REQ_FLAG_SENINF_IMMEDIATE_UPDATE;
+		} else {
+			dev_info(ctx->cam->dev,
+				"%s:req(%s):pipe(%d):link change after last p1 done: seq(%d), running_s_data_num(%d)\n",
+				__func__, req->req.debug_str, pipe_id,
+				s_data->frame_seq_no, running_s_data_num);
+		}
+	}
+}
+
+static void mtk_cam_req_s_data_init(struct mtk_cam_request *req,
+				    int pipe_id,
+				    int s_data_index)
+{
+	struct mtk_cam_request_stream_data *req_stream_data;
+
+	req_stream_data = &req->p_data[pipe_id].s_data[s_data_index];
+	req_stream_data->req = req;
+	req_stream_data->pipe_id = pipe_id;
+	req_stream_data->state.estate = E_STATE_READY;
+	req_stream_data->index = s_data_index;
+	atomic_set(&req_stream_data->buf_state, -1);
+
+	/**
+	 * req_stream_data->flags is cleaned by
+	 * mtk_cam_req_s_data_clean () at previous job done
+	 * and may by updated by qbuf before request enqueue
+	 * so we don't reset it here.
+	 */
+	mtk_cam_req_work_init(&req_stream_data->seninf_s_fmt_work,
+			req_stream_data);
+		mtk_cam_req_work_init(&req_stream_data->frame_work,
+			req_stream_data);
+		mtk_cam_req_work_init(&req_stream_data->frame_done_work,
+			req_stream_data);
+		mtk_cam_req_work_init(&req_stream_data->meta1_done_work,
+			req_stream_data);
+	mtk_cam_req_work_init(&req_stream_data->sv_work,
+				  req_stream_data);
+		/**
+		 * clean the param structs since we support req reinit.
+		 * the mtk_cam_request may not be "zero" when it is
+		 * enqueued.
+		 */
+	memset(&req_stream_data->frame_params, 0,
+	       sizeof(req_stream_data->frame_params));
+	memset(&req_stream_data->sv_frame_params, 0,
+	       sizeof(req_stream_data->sv_frame_params));
+	memset(&req_stream_data->mtk_cam_exposure, 0,
+	       sizeof(req_stream_data->mtk_cam_exposure));
+
+	/* generally is single exposure */
+	req_stream_data->frame_params.raw_param.exposure_num = 1;
+
+}
+
+void mtk_cam_dev_req_try_queue(struct mtk_cam_device *cam)
+{
+	struct mtk_cam_ctx *ctx, *stream_ctx;
+	struct mtk_cam_request *req, *req_prev;
+	struct mtk_cam_request_stream_data *s_data;
+	int i, s_data_flags;
+	int feature_change, previous_feature;
+	int enqueue_req_cnt, job_count, s_data_cnt;
+	struct list_head equeue_list;
+	struct v4l2_ctrl_handler *hdl;
+	struct media_request_object *sensor_hdl_obj, *raw_hdl_obj, *obj;
+	unsigned long flags;
+
+	if (!cam->streaming_ctx) {
+		dev_info(cam->dev, "streams are off\n");
+		return;
+	}
+
+	INIT_LIST_HEAD(&equeue_list);
+
+	spin_lock(&cam->running_job_lock);
+	job_count = cam->running_job_count;
+	spin_unlock(&cam->running_job_lock);
+
+	/* Pick up requests which are runnable */
+	enqueue_req_cnt = 0;
+	spin_lock(&cam->pending_job_lock);
+	list_for_each_entry_safe(req, req_prev, &cam->pending_job_list, list) {
+		if (likely(mtk_cam_dev_req_is_stream_on(cam, req))) {
+			if (job_count + enqueue_req_cnt >=
+			    RAW_PIPELINE_NUM * MTK_CAM_MAX_RUNNING_JOBS) {
+				dev_dbg(cam->dev, "jobs are full, job cnt(%d)\n",
+					 job_count);
+				break;
+			}
+			dev_dbg(cam->dev, "%s job cnt(%d), allow req_enqueue(%s)\n",
+				__func__, job_count + enqueue_req_cnt, req->req.debug_str);
+
+			enqueue_req_cnt++;
+			list_del(&req->list);
+			list_add_tail(&req->list, &equeue_list);
+		}
+	}
+	spin_unlock(&cam->pending_job_lock);
+
+	if (!enqueue_req_cnt)
+		return;
+
+	list_for_each_entry_safe(req, req_prev, &equeue_list, list) {
+		for (i = 0; i < cam->max_stream_num; i++) {
+			if (!(req->pipe_used & 1 << i))
+				continue;
+
+			/* Initialize ctx related s_data fields */
+			ctx = &cam->ctxs[i];
+			sensor_hdl_obj = NULL;
+			raw_hdl_obj = NULL;
+			s_data_flags = 0;
+
+			/* Update frame_seq_no */
+			s_data = mtk_cam_req_get_s_data(req, i, 0);
+			s_data->frame_seq_no = atomic_inc_return(&ctx->enqueued_frame_seq_no);
+			mtk_cam_req_update_seq(ctx, req,
+					       ++(ctx->enqueued_request_cnt));
+			if (is_camsv_subdev(i)) {
+				stream_ctx = mtk_cam_find_ctx(cam,
+					&cam->sv.pipelines[i -
+					MTKCAM_SUBDEV_CAMSV_START].subdev.entity);
+			}
+			if (is_raw_subdev(i) && ctx->sensor) {
+				previous_feature = ctx->pipe->feature_pending;
+
+				s_data_cnt =
+					atomic_inc_return(&ctx->running_s_data_cnt);
+
+				immediate_link_update_chk(ctx, i, s_data_cnt,
+							  s_data);
+
+				if (!(req->ctx_link_update & (1 << i)))
+					s_data->sensor = ctx->sensor;
+
+				spin_lock_irqsave(&req->req.lock, flags);
+				list_for_each_entry(obj, &req->req.objects, list) {
+					if (vb2_request_object_is_buffer(obj))
+						continue;
+
+					hdl = (struct v4l2_ctrl_handler *)obj->priv;
+					if (hdl == &ctx->pipe->ctrl_handler)
+						raw_hdl_obj = obj;
+					else if (hdl == ctx->sensor->ctrl_handler)
+						sensor_hdl_obj = obj;
+				}
+				spin_unlock_irqrestore(&req->req.lock, flags);
+
+				if (raw_hdl_obj) {
+					s_data->flags |= MTK_CAM_REQ_S_DATA_FLAG_RAW_HDL_EN;
+					s_data->raw_hdl_obj = raw_hdl_obj;
+					dev_dbg(cam->dev,
+						"%s:%s:ctx(%d): find pipe hdl\n",
+						__func__, req->req.debug_str, i);
+				}
+
+				/* Apply raw subdev's ctrl */
+				mtk_cam_req_update_ctrl(ctx->pipe, s_data);
+				feature_change = s_data->feature.switch_feature_type;
+
+				if (s_data->sensor && s_data->sensor->ctrl_handler &&
+				    sensor_hdl_obj) {
+					s_data->sensor_hdl_obj = sensor_hdl_obj;
+					dev_dbg(cam->dev,
+						"%s:%s:ctx(%d): find sensor(%s) hdl\n",
+						__func__, req->req.debug_str, i,
+						s_data->sensor->name);
+					s_data->flags |=
+						MTK_CAM_REQ_S_DATA_FLAG_SENSOR_HDL_EN;
+				}
+
+				s_data_flags = s_data->flags;
+
+				/* mstream: re-init the s_data */
+				if (mtk_cam_feature_change_is_mstream(feature_change) ||
+						(req->ctx_link_update & (1 << ctx->pipe->id)))
+					mstream_seamless_buf_update(ctx, req, i,
+								    previous_feature);
+
+				/* reload s_data */
+				s_data->flags = s_data_flags;
+				s_data->raw_hdl_obj = raw_hdl_obj;
+				s_data->sensor_hdl_obj = sensor_hdl_obj;
+
+				/* copy s_data content */
+				if (mtk_cam_is_mstream(ctx) || mtk_cam_is_mstream_m2m(ctx))
+					fill_mstream_s_data(ctx, req);
+				else if (req->p_data[i].s_data_num == 2)
+					dev_info(cam->dev,
+						 "%s:req(%s): undefined s_data_1, raw_feature(%lld)\n",
+						 __func__, req->req.debug_str,
+						 ctx->pipe->feature_pending);
+			} else if (is_camsv_subdev(i) && stream_ctx &&
+				i == stream_ctx->stream_id) {
+				if (!(req->ctx_link_update & (1 << i)))
+					s_data->sensor = stream_ctx->sensor;
+
+				spin_lock_irqsave(&req->req.lock, flags);
+				list_for_each_entry(obj, &req->req.objects, list) {
+					if (vb2_request_object_is_buffer(obj))
+						continue;
+					hdl = (struct v4l2_ctrl_handler *)obj->priv;
+					if (stream_ctx->sensor && hdl ==
+						stream_ctx->sensor->ctrl_handler)
+						sensor_hdl_obj = obj;
+				}
+				spin_unlock_irqrestore(&req->req.lock, flags);
+
+				if (s_data->sensor && s_data->sensor->ctrl_handler &&
+					sensor_hdl_obj) {
+					s_data->sensor_hdl_obj = sensor_hdl_obj;
+					dev_dbg(cam->dev,
+						"%s:%s:ctx(%d): find sensor(%s) hdl\n",
+						__func__, req->req.debug_str, i,
+						s_data->sensor->name);
+					s_data->flags |=
+						MTK_CAM_REQ_S_DATA_FLAG_SENSOR_HDL_EN;
+				}
+			} else if (is_camsv_subdev(i) && stream_ctx &&
+				i != stream_ctx->stream_id) {
+				/* copy s_data content for mstream case */
+				if (mtk_cam_is_mstream(stream_ctx)) {
+					req->p_data[i].s_data_num = 2;
+					mtk_cam_req_s_data_init(req, i, 1);
+					fill_sv_mstream_s_data(cam, req, i);
+				}
+			} else if (is_raw_subdev(i) && !ctx->sensor) {
+				/* pure m2m raw ctrl handle */
+				s_data_cnt =
+					atomic_inc_return(&ctx->running_s_data_cnt);
+
+				spin_lock_irqsave(&req->req.lock, flags);
+				list_for_each_entry(obj, &req->req.objects, list) {
+					if (vb2_request_object_is_buffer(obj))
+						continue;
+
+					hdl = (struct v4l2_ctrl_handler *)obj->priv;
+					if (hdl == &ctx->pipe->ctrl_handler)
+						raw_hdl_obj = obj;
+				}
+				spin_unlock_irqrestore(&req->req.lock, flags);
+
+				if (raw_hdl_obj) {
+					s_data->flags |= MTK_CAM_REQ_S_DATA_FLAG_RAW_HDL_EN;
+					s_data->raw_hdl_obj = raw_hdl_obj;
+					dev_dbg(cam->dev,
+						"%s:%s:ctx(%d): find pipe hdl\n",
+						__func__, req->req.debug_str, i);
+				}
+
+				/* Apply raw subdev's ctrl */
+				mtk_cam_req_update_ctrl(ctx->pipe, s_data);
+			}
+		}
+
+		if (mtk_cam_req_update(cam, req)) {
+			dev_info(cam->dev,
+				 "%s:req(%s): invalid req settings which can't be recovered\n",
+				 __func__, req->req.debug_str);
+			WARN_ON(1);
+			return;
+		}
+
+		atomic_set(&req->state, MTK_CAM_REQ_STATE_RUNNING);
+		spin_lock(&cam->running_job_lock);
+		cam->running_job_count++;
+		list_del(&req->list);
+		list_add_tail(&req->list, &cam->running_job_list);
+		spin_unlock(&cam->running_job_lock);
+		mtk_cam_dev_req_enqueue(cam, req);
+	}
+}
+
+static struct media_request *mtk_cam_req_alloc(struct media_device *mdev)
+{
+	struct mtk_cam_request *cam_req;
+
+	cam_req = vzalloc(sizeof(*cam_req));
+	spin_lock_init(&cam_req->done_status_lock);
+	mutex_init(&cam_req->fs.op_lock);
+
+	return &cam_req->req;
+}
+
+static void mtk_cam_req_free(struct media_request *req)
+{
+	struct mtk_cam_request *cam_req = to_mtk_cam_req(req);
+
+	vfree(cam_req);
+}
+
+static int mtk_cam_req_chk_job_list(struct mtk_cam_device *cam,
+				    struct mtk_cam_request *new_req,
+				    struct list_head *job_list,
+				    char *job_list_name)
+{
+	if (!job_list || !job_list->prev || !job_list->prev->next ||
+	    !new_req) {
+		dev_dbg(cam->dev,
+			"%s:%s: job_list, job_list->prev, job_list->prev->next, new_req can't be NULL\n",
+			__func__, job_list_name);
+		return -EINVAL;
+	}
+
+	if (job_list->prev->next != job_list) {
+		dev_dbg(cam->dev, "%s broken: job_list->prev->next(%p), job_list(%p), req(%s)\n",
+			job_list_name, job_list->prev->next, job_list,
+			new_req->req.debug_str);
+		return -EINVAL;
+	}
+
+	if (&new_req->list == job_list->prev || &new_req->list == job_list) {
+		dev_dbg(cam->dev, "%s job double add: req(%s)\n",
+			job_list_name, new_req->req.debug_str);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+/* only init extend s_data and update s_data_num */
+static void mtk_cam_req_p_data_extend_init(struct mtk_cam_request *req,
+				    int pipe_id,
+				    int s_data_num)
+{
+	int i;
+
+	req->p_data[pipe_id].s_data_num = s_data_num;
+	for (i = 1; i < s_data_num; i++)
+		mtk_cam_req_s_data_init(req, pipe_id, i);
+}
+
+static void mtk_cam_req_p_data_init(struct mtk_cam_request *req,
+				    int pipe_id,
+				    int s_data_num)
+{
+	int i = 0;
+
+	req->p_data[pipe_id].s_data_num = s_data_num;
+	for (i = 0; i < s_data_num; i++)
+		mtk_cam_req_s_data_init(req, pipe_id, i);
+}
+
+static inline void mtk_cam_req_cnt_init(struct mtk_cam_request *req)
+{
+	atomic_set(&req->ref_cnt, 0);
+}
+
+static unsigned int mtk_cam_req_get_pipe_used(struct media_request *req)
+{
+	/**
+	 * V4L2 framework doesn't trigger q->ops->buf_queue(q, buf) when it is
+	 * stream off. We have to check the used context through the request directly
+	 * before streaming on.
+	 */
+	struct media_request_object *obj;
+	unsigned int pipe_used = 0;
+	struct mtk_cam_request *cam_req = to_mtk_cam_req(req);
+	unsigned int i, feature;
+	struct mtk_cam_device *cam =
+		container_of(req->mdev, struct mtk_cam_device, media_dev);
+	struct mtk_raw_pipeline *raw_pipeline;
+
+	list_for_each_entry(obj, &req->objects, list) {
+		struct vb2_buffer *vb;
+		struct mtk_cam_video_device *node;
+
+		if (!vb2_request_object_is_buffer(obj))
+			continue;
+		vb = container_of(obj, struct vb2_buffer, req_obj);
+		node = mtk_cam_vbq_to_vdev(vb->vb2_queue);
+		pipe_used |= 1 << node->uid.pipe_id;
+	}
+
+	mtk_cam_req_cnt_init(cam_req);
+
+	/* Initialize per pipe's stream data (without ctx)*/
+	for (i = 0; i < cam->max_stream_num; i++) {
+		if (pipe_used & (1 << i)) {
+			/* reset feature for each pipe */
+			feature = 0;
+			/**
+			 * By default, the s_data_num is 1;
+			 * for some special feature like mstream, it is 2.
+			 */
+			if (is_raw_subdev(i)) {
+				raw_pipeline = &cam->raw.pipelines[i - MTKCAM_SUBDEV_RAW_0];
+				feature = raw_pipeline->feature_pending;
+			}
+			if (mtk_cam_feature_is_mstream(feature) ||
+					mtk_cam_feature_is_mstream_m2m(feature))
+				mtk_cam_req_p_data_init(cam_req, i, 2);
+			else
+				mtk_cam_req_p_data_init(cam_req, i, 1);
+
+			mtk_cam_req_get(cam_req, i); /* pipe id */
+		}
+	}
+
+	return pipe_used;
+}
+
+static void mtk_cam_req_queue(struct media_request *req)
+{
+	struct mtk_cam_request *cam_req = to_mtk_cam_req(req);
+	struct mtk_cam_device *cam =
+		container_of(req->mdev, struct mtk_cam_device, media_dev);
+
+	/* reset done status */
+	cam_req->done_status = 0;
+	cam_req->pipe_used = mtk_cam_req_get_pipe_used(req);
+	cam_req->flags = 0;
+	cam_req->ctx_used = 0; /* will update after stream on */
+	mtk_cam_fs_reset(&cam_req->fs);
+
+	/* update frame_params's dma_bufs in mtk_cam_vb2_buf_queue */
+	vb2_request_queue(req);
+
+	/* add to pending job list */
+	spin_lock(&cam->pending_job_lock);
+	if (mtk_cam_req_chk_job_list(cam, cam_req,
+				     &cam->pending_job_list,
+				     "pending_job_list")) {
+		spin_unlock(&cam->pending_job_lock);
+		return;
+	}
+
+	/**
+	 * Add req's ref cnt since it is used by pending_job_list and running
+	 * pending_job_list.
+	 */
+	atomic_set(&cam_req->state, MTK_CAM_REQ_STATE_PENDING);
+	list_add_tail(&cam_req->list, &cam->pending_job_list);
+	spin_unlock(&cam->pending_job_lock);
+	mutex_lock(&cam->queue_lock);
+	mtk_cam_dev_req_try_queue(cam);
+	mutex_unlock(&cam->queue_lock);
+}
+
+/* to save the link change information in request */
+static int mtk_cam_collect_link_change(struct mtk_raw_pipeline *pipe,
+				       struct v4l2_subdev *req_sensor_new,
+				       struct v4l2_subdev *req_seninf_old,
+				       struct v4l2_subdev *req_seninf_new)
+{
+	char warn_desc[48];
+
+	int ret = snprintf(warn_desc, 48, "prev:%s: sensor_new(%p)/seninf_old(%p)/seninf_new(%p)",
+		 pipe->subdev.name, pipe->req_sensor_new,
+		 pipe->req_seninf_old, pipe->req_seninf_new);
+	if (ret < 0 || (unsigned int) ret >= sizeof(warn_desc)) {
+		dev_info(pipe->subdev.v4l2_dev->dev,
+			 "error: %s: failed to write warn_desc\n",
+			 __func__);
+		return -EINVAL;
+	}
+
+	if (!pipe->req_sensor_new || !pipe->req_seninf_old || !pipe->req_seninf_new) {
+		dev_info(pipe->subdev.v4l2_dev->dev,
+			 "%s:%s:the prev link change has not been queued. %s\n",
+			 __func__, pipe->subdev.name, warn_desc);
+#if IS_ENABLED(CONFIG_MTK_AEE_FEATURE)
+		aee_kernel_warning_api(__FILE__, __LINE__, DB_OPT_DEFAULT,
+				       "the prev link change has not been queued",
+				       warn_desc);
+#else
+		WARN_ON(1);
+#endif
+		return -EINVAL;
+	}
+
+	pipe->req_sensor_new = req_sensor_new;
+	pipe->req_seninf_old = req_seninf_old;
+	pipe->req_seninf_new = req_seninf_new;
+
+	return 0;
+}
+
+int mtk_cam_req_save_link_change(struct mtk_raw_pipeline *pipe,
+				 struct mtk_cam_request *cam_req,
+				 struct mtk_cam_request_stream_data *s_data)
+{
+	char warn_desc[48];
+
+	if (pipe->req_sensor_new || pipe->req_seninf_old || pipe->req_seninf_new) {
+		if (pipe->req_sensor_new && pipe->req_seninf_old && pipe->req_seninf_new) {
+			s_data->seninf_old = pipe->req_seninf_old;
+			s_data->seninf_new = pipe->req_seninf_new;
+			s_data->sensor = pipe->req_sensor_new;
+			cam_req->ctx_link_update |= 1 << pipe->id;
+			dev_info(pipe->subdev.v4l2_dev->dev,
+				 "%s:%s:%s: queued link setup: senor_n:%s,seninf_n:%s), seninf_o:%s\n",
+				 __func__, pipe->subdev.name, cam_req->req.debug_str,
+				 s_data->sensor->name, s_data->seninf_old->name,
+				 s_data->seninf_new->name);
+			/* clear the setting after it is alrady saved in request */
+			pipe->req_sensor_new = NULL;
+			pipe->req_seninf_old = NULL;
+			pipe->req_seninf_new = NULL;
+		} else {
+			int ret = snprintf(warn_desc, 48,
+				 "%s:%s:param's can't be null:sensor_n(%p)/seninf_o(%p)/seninf_n(%p)",
+				 pipe->subdev.name, cam_req->req.debug_str,
+				 pipe->req_sensor_new, pipe->req_seninf_old,
+				 pipe->req_seninf_new);
+			if (ret < 0 || (unsigned int) ret >= sizeof(warn_desc)) {
+				dev_info(pipe->subdev.v4l2_dev->dev,
+					"error: %s: failed to write warn_desc\n",
+					__func__);
+				return -EINVAL;
+			}
+			dev_info(pipe->subdev.v4l2_dev->dev,
+				 "%s:%s\n", __func__, warn_desc);
+#if IS_ENABLED(CONFIG_MTK_AEE_FEATURE)
+			aee_kernel_warning_api(__FILE__, __LINE__, DB_OPT_DEFAULT,
+					       "invalid link setup param",
+					       warn_desc);
+#else
+			WARN_ON(1);
+#endif
+			return -EINVAL;
+		}
+	}
+	/* not link setup need to be handled*/
+	return 0;
+}
+
+static int mtk_cam_link_notify(struct media_link *link, u32 flags,
+							unsigned int notification)
+{
+	struct media_entity *source = link->source->entity;
+	struct media_entity *sink = link->sink->entity;
+	struct v4l2_subdev *subdev;
+	struct mtk_cam_ctx *ctx;
+	struct mtk_cam_device *cam;
+	struct mtk_raw_pipeline *pipe;
+	struct v4l2_subdev *req_sensor_new, *req_seninf_old, *req_seninf_new;
+
+	if (source->function != MEDIA_ENT_F_VID_IF_BRIDGE ||
+		notification != MEDIA_DEV_NOTIFY_POST_LINK_CH)
+		return v4l2_pipeline_link_notify(link, flags, notification);
+
+	subdev = media_entity_to_v4l2_subdev(sink);
+	cam = container_of(subdev->v4l2_dev->mdev, struct mtk_cam_device, media_dev);
+	ctx = mtk_cam_find_ctx(cam, sink);
+
+	if (!ctx || !ctx->streaming || !(flags & MEDIA_LNK_FL_ENABLED))
+		return v4l2_pipeline_link_notify(link, flags, notification);
+
+	pipe = container_of(subdev, struct mtk_raw_pipeline, subdev);
+	req_seninf_old = ctx->seninf;
+	req_seninf_new = media_entity_to_v4l2_subdev(source);
+	req_sensor_new = mtk_cam_find_sensor(ctx, &req_seninf_new->entity);
+	mtk_cam_collect_link_change(pipe, req_sensor_new, req_seninf_old, req_seninf_new);
+
+	dev_dbg(cam->dev, "link_change ctx:%d, old seninf:%s, new seninf:%s\n",
+		ctx->stream_id, req_seninf_old->name,	req_seninf_new->name);
+
+	return v4l2_pipeline_link_notify(link, flags, notification);
+}
+
+static const struct media_device_ops mtk_cam_dev_ops = {
+	.link_notify = mtk_cam_link_notify,
+	.req_alloc = mtk_cam_req_alloc,
+	.req_free = mtk_cam_req_free,
+	.req_validate = vb2_request_validate,
+	.req_queue = mtk_cam_req_queue,
+};
+
+static int mtk_cam_of_rproc(struct mtk_cam_device *cam,
+			    struct platform_device *pdev)
+{
+	struct device *dev = cam->dev;
+
+	cam->scp = scp_get(pdev);
+	if (!cam->scp) {
+		dev_err(dev, "failed to get scp device\n");
+		return -ENODEV;
+	}
+
+	cam->rproc_handle = scp_get_rproc(cam->scp);
+	dev_dbg(dev, "camsys rproc_phandle: 0x%pK\n", cam->rproc_handle);
+	cam->smem_dev = scp_get_device(cam->scp);
+
+	return 0;
+}
+
+static int get_available_sv_pipes(struct mtk_cam_device *cam,
+							int hw_scen, int req_amount, int master,
+							int is_trial)
+{
+	unsigned int i, j, k, group, exp_order;
+	unsigned int idle_pipes = 0, match_cnt = 0;
+
+	if (hw_scen == (1 << MTKCAM_IPI_HW_PATH_ON_THE_FLY_DCIF_STAGGER) ||
+		hw_scen == (1 << MTKCAM_IPI_HW_PATH_OFFLINE_SRT_DCIF_STAGGER)) {
+		for (i = 0; i < req_amount; i++) {
+			group = master << CAMSV_GROUP_SHIFT;
+			exp_order = 1 << (i + CAMSV_EXP_ORDER_SHIFT);
+			for (j = 0; j < cam->num_camsv_devices; j++) {
+				if ((cam->sv.pipelines[j].is_occupied == 0) &&
+					(cam->sv.pipelines[j].hw_cap & hw_scen) &&
+					(cam->sv.pipelines[j].hw_cap & group) &&
+					(cam->sv.pipelines[j].hw_cap & exp_order)) {
+					match_cnt++;
+					idle_pipes |= (1 << cam->sv.pipelines[j].id);
+					break;
+				}
+			}
+			if (j == cam->num_camsv_devices) {
+				idle_pipes = 0;
+				match_cnt = 0;
+				goto EXIT;
+			}
+		}
+	} else if (hw_scen == (1 << MTKCAM_IPI_HW_PATH_OFFLINE_STAGGER)) {
+		for (i = 0; i < CAMSV_GROUP_AMOUNT; i++) {
+			for (j = 0; j < req_amount; j++) {
+				group = 1 << (i + CAMSV_GROUP_SHIFT);
+				exp_order = 1 << (j + CAMSV_EXP_ORDER_SHIFT);
+				for (k = 0; k < cam->num_camsv_devices; k++) {
+					if ((cam->sv.pipelines[k].is_occupied == 0) &&
+						(cam->sv.pipelines[k].hw_cap & hw_scen) &&
+						(cam->sv.pipelines[k].hw_cap & group) &&
+						(cam->sv.pipelines[k].hw_cap & exp_order)) {
+						match_cnt++;
+						idle_pipes |= (1 << cam->sv.pipelines[k].id);
+						break;
+					}
+				}
+				if (k == cam->num_camsv_devices) {
+					idle_pipes = 0;
+					match_cnt = 0;
+					goto EXIT;
+				}
+			}
+			if (match_cnt == req_amount)
+				break;
+		}
+	} else {
+		for (i = 0; i < cam->num_camsv_devices; i++) {
+			if ((cam->sv.pipelines[i].is_occupied == 0) &&
+				(cam->sv.pipelines[i].hw_cap & hw_scen)) {
+				match_cnt++;
+				idle_pipes |= (1 << cam->sv.pipelines[i].id);
+			}
+			if (match_cnt == req_amount)
+				break;
+		}
+		if (match_cnt < req_amount) {
+			idle_pipes = 0;
+			match_cnt = 0;
+			goto EXIT;
+		}
+	}
+
+	if (is_trial == 0) {
+		for (i = 0; i < cam->num_camsv_devices; i++) {
+			if (idle_pipes & (1 << cam->sv.pipelines[i].id))
+				cam->sv.pipelines[i].is_occupied = 1;
+		}
+	}
+
+EXIT:
+	return idle_pipes;
+}
+
+void mstream_seamless_buf_update(struct mtk_cam_ctx *ctx,
+				struct mtk_cam_request *req, int pipe_id,
+				int previous_feature)
+{
+	struct mtk_cam_request_stream_data *req_stream_data =
+		mtk_cam_req_get_s_data_no_chk(req, pipe_id, 0);
+	struct mtkcam_ipi_frame_param *frame_param =
+		&req_stream_data->frame_params;
+	struct mtk_cam_request_stream_data *req_stream_data_mstream =
+		mtk_cam_req_get_s_data_no_chk(req, pipe_id, 1);
+	struct mtkcam_ipi_frame_param *mstream_frame_param =
+		&req_stream_data_mstream->frame_params;
+	int in_node = MTKCAM_IPI_RAW_RAWI_2;
+	int desc_id = MTK_RAW_MAIN_STREAM_OUT - MTK_RAW_SOURCE_BEGIN;
+	int current_feature = ctx->pipe->feature_pending;
+	struct mtk_cam_video_device *vdev;
+	int main_stream_size;
+	__u64 iova;
+	__u32 fd;
+	__u8 imgo_path_sel;
+
+	vdev = &ctx->pipe->vdev_nodes[MTK_RAW_MAIN_STREAM_OUT - MTK_RAW_SINK_NUM];
+	main_stream_size = vdev->active_fmt.fmt.pix_mp.plane_fmt[1].sizeimage;
+
+	pr_info("%s cur_feature(%d) prev_feature(%d) main_stream_size(%d)",
+		__func__, current_feature, previous_feature, main_stream_size);
+
+		/* backup first because main stream buffer is already assigned */
+	iova = frame_param->img_outs[desc_id].buf[0][0].iova;
+	fd = frame_param->img_outs[desc_id].buf[0][0].fd;
+	imgo_path_sel = frame_param->raw_param.imgo_path_sel;
+
+	if (mtk_cam_feature_is_mstream(current_feature)) {
+		/* for 1->2, 2->2 */
+		/* init stream data for mstream */
+		mtk_cam_req_p_data_extend_init(req, pipe_id, 2);
+	} else {
+		/* for 2->1 */
+		/* init stream data for normal exp */
+		mtk_cam_req_p_data_extend_init(req, pipe_id, 1);
+	}
+
+		/* recover main stream buffer */
+		frame_param->img_outs[desc_id].buf[0][0].iova = iova;
+	frame_param->img_outs[desc_id].buf[0][0].size = main_stream_size;
+		frame_param->img_outs[desc_id].buf[0][0].fd = fd;
+		frame_param->raw_param.imgo_path_sel = imgo_path_sel;
+
+	if (current_feature == MSTREAM_NE_SE) {
+		mstream_frame_param->raw_param.exposure_num = 1;
+		frame_param->raw_param.exposure_num = 2;
+		frame_param->raw_param.hardware_scenario =
+		MTKCAM_IPI_HW_PATH_ON_THE_FLY_MSTREAM_NE_SE;
+	} else if (current_feature == MSTREAM_SE_NE) {
+		mstream_frame_param->raw_param.exposure_num = 1;
+		frame_param->raw_param.exposure_num = 2;
+		frame_param->raw_param.hardware_scenario =
+		MTKCAM_IPI_HW_PATH_ON_THE_FLY_MSTREAM_SE_NE;
+	} else {
+		// normal single exposure
+		mstream_frame_param->raw_param.exposure_num = 0;
+		frame_param->raw_param.exposure_num = 1;
+		frame_param->raw_param.hardware_scenario =
+		MTKCAM_IPI_HW_PATH_ON_THE_FLY;
+	}
+
+	// imgo mstream buffer layout is fixed plane[0]=NE, plane[1]=SE
+	if (current_feature == MSTREAM_NE_SE) {
+		// Normal single exposure seamless to NE_SE
+		// NE as normal 1 exposure flow, get iova from frame_param
+		mstream_frame_param->img_outs[desc_id].buf[0][0].iova =
+				frame_param->img_outs[desc_id].buf[0][0].iova;
+		pr_debug("%s mstream ne_se ne imgo:0x%lx\n",
+			__func__,
+			(unsigned long)mstream_frame_param->img_outs[desc_id].buf[0][0].iova);
+
+		// SE, in = NE output
+		frame_param->img_ins[in_node - MTKCAM_IPI_RAW_RAWI_2].buf[0]
+			.iova = mstream_frame_param->img_outs[desc_id].buf[0][0].iova;
+		frame_param->img_ins[in_node - MTKCAM_IPI_RAW_RAWI_2].buf[0]
+			.size = main_stream_size;
+		// out = SE output
+		frame_param->img_outs[desc_id].buf[0][0].iova +=
+			main_stream_size;
+		frame_param->img_outs[desc_id].buf[0][0].size =
+			main_stream_size;
+		pr_debug("%s mstream ne_se se rawi:0x%lx imgo:0x%lx size:%d\n",
+			__func__,
+			(unsigned long)frame_param->img_ins[in_node - MTKCAM_IPI_RAW_RAWI_2].buf[0].iova,
+			(unsigned long)frame_param->img_outs[desc_id].buf[0][0].iova,
+			frame_param->img_outs[desc_id].buf[0][0].size);
+	} else if (current_feature == MSTREAM_SE_NE) {
+		// Normal single exposure seamless to NE_SE
+		// SE as normal output SE(plane[1]) first
+		mstream_frame_param->img_outs[desc_id].buf[0][0].iova =
+			frame_param->img_outs[desc_id].buf[0][0].iova +
+			main_stream_size;
+		mstream_frame_param->img_outs[desc_id].buf[0][0].size =
+			main_stream_size;
+		pr_debug("%s mstream se_ne se imgo:0x%lx size:%d\n",
+			__func__,
+			(unsigned long)mstream_frame_param->img_outs[desc_id].buf[0][0].iova,
+			mstream_frame_param->img_outs[desc_id].buf[0][0].size);
+
+		// NE,  in = SE output
+		frame_param->img_ins[in_node - MTKCAM_IPI_RAW_RAWI_2].buf[0]
+			.iova = mstream_frame_param->img_outs[desc_id].buf[0][0].iova;
+		frame_param->img_ins[in_node - MTKCAM_IPI_RAW_RAWI_2].buf[0]
+			.size = main_stream_size;
+		// out = NE out, already configured in normal single exposure
+
+		pr_debug("%s mstream se_ne ne rawi:0x%lx imgo:0x%lx size:%d\n",
+			__func__,
+			(unsigned long)frame_param->img_ins[in_node - MTKCAM_IPI_RAW_RAWI_2].buf[0].iova,
+			(unsigned long)frame_param->img_outs[desc_id].buf[0][0].iova,
+			frame_param->img_outs[desc_id].buf[0][0].size);
+	} else {
+		// M-Stream seamless to normal single exposure
+		// clear mstream mstream_frame_param
+		mstream_frame_param->img_outs[desc_id].buf[0][0].iova = 0;
+
+		// reset frame_param to normal single exposure
+		// if previous is NE_SE, recover imgo
+		if (previous_feature == MSTREAM_NE_SE) {
+			// get NE from rawi
+			frame_param->img_outs[desc_id].buf[0][0].iova =
+			frame_param->img_ins[in_node - MTKCAM_IPI_RAW_RAWI_2].buf[0]
+			.iova;
+		}
+
+		// if previous is SE_NE, imgo iova is already correct
+
+		// clear rawi2
+		frame_param->img_ins[in_node - MTKCAM_IPI_RAW_RAWI_2].buf[0]
+			.iova = 0;
+		frame_param->img_ins[in_node - MTKCAM_IPI_RAW_RAWI_2].buf[0]
+			.size = 0;
+
+		pr_debug("%s normal imgo:0x%lx\n", __func__,
+			(unsigned long)frame_param->img_outs[desc_id].buf[0][0].iova);
+	}
+}
+
+int get_main_sv_pipe_id(struct mtk_cam_device *cam,
+							int used_dev_mask)
+{
+	unsigned int i;
+
+	for (i = MTKCAM_SUBDEV_CAMSV_START; i < MTKCAM_SUBDEV_CAMSV_END; i++) {
+		if (used_dev_mask & (1 << i))
+			if (cam->sv.pipelines[i - MTKCAM_SUBDEV_CAMSV_START].exp_order == 0)
+				return i;
+	}
+	return -1;
+}
+
+int get_sub_sv_pipe_id(struct mtk_cam_device *cam,
+							int used_dev_mask)
+{
+	unsigned int i;
+
+	for (i = MTKCAM_SUBDEV_CAMSV_START; i < MTKCAM_SUBDEV_CAMSV_END; i++) {
+		if (used_dev_mask & (1 << i))
+			if (cam->sv.pipelines[i - MTKCAM_SUBDEV_CAMSV_START].exp_order == 1)
+				return i;
+	}
+	return -1;
+}
+
+int get_last_sv_pipe_id(struct mtk_cam_device *cam,
+							int used_dev_mask)
+{
+	unsigned int i;
+
+	for (i = MTKCAM_SUBDEV_CAMSV_START; i < MTKCAM_SUBDEV_CAMSV_END; i++) {
+		if (used_dev_mask & (1 << i))
+			if (cam->sv.pipelines[i - MTKCAM_SUBDEV_CAMSV_START].exp_order == 2)
+				return i;
+	}
+	return -1;
+}
+
+struct mtk_raw_device *get_main_raw_dev(struct mtk_cam_device *cam,
+					  struct mtk_raw_pipeline *pipe)
+{
+	struct device *dev_main;
+	unsigned int i;
+
+	for (i = 0; i < cam->num_raw_devices; i++) {
+		if (pipe->enabled_raw & (1 << i)) {
+			dev_main = cam->raw.devs[i];
+			break;
+		}
+	}
+
+	return dev_get_drvdata(dev_main);
+}
+
+struct mtk_raw_device *get_sub_raw_dev(struct mtk_cam_device *cam,
+					 struct mtk_raw_pipeline *pipe)
+{
+	struct device *dev_sub;
+	unsigned int i;
+
+	for (i = 0; i < cam->num_raw_devices - 1; i++) {
+		if (pipe->enabled_raw & (1 << i)) {
+			dev_sub = cam->raw.devs[i + 1];
+			break;
+		}
+	}
+
+	return dev_get_drvdata(dev_sub);
+}
+
+struct mtk_raw_device *get_sub2_raw_dev(struct mtk_cam_device *cam,
+					  struct mtk_raw_pipeline *pipe)
+{
+	struct device *dev_sub;
+	unsigned int i;
+
+	for (i = 0; i < cam->num_raw_devices; i++) {
+		if (pipe->enabled_raw & (1 << i)) {
+			dev_sub = cam->raw.devs[i + 2];
+			break;
+		}
+	}
+
+	return dev_get_drvdata(dev_sub);
+}
+
+struct mtk_camsv_device *get_camsv_dev(struct mtk_cam_device *cam,
+					  struct mtk_camsv_pipeline *pipe)
+{
+	struct device *dev;
+
+	dev = cam->sv.devs[pipe->id - MTKCAM_SUBDEV_CAMSV_START];
+
+	return dev_get_drvdata(dev);
+}
+
+static void isp_composer_uninit(struct mtk_cam_device *cam)
+{
+	scp_ipi_unregister(cam->scp, SCP_IPI_ISP_CMD);
+	scp_ipi_unregister(cam->scp, SCP_IPI_ISP_FRAME);
+}
+
+static int isp_composer_handle_ack(struct mtk_cam_device *cam,
+				   struct mtkcam_ipi_event *ipi_msg)
+{
+	struct device *dev = cam->dev;
+	struct mtk_cam_ctx *ctx;
+	struct mtk_cam_working_buf_entry *buf_entry;
+	struct mtk_cam_request_stream_data *s_data;
+	struct mtk_cam_request *req;
+	bool is_m2m_apply_cq = false;
+	bool is_mux_change_with_apply_cq = false;
+	struct mtk_raw_device *raw_dev;
+
+	ctx = &cam->ctxs[ipi_msg->cookie.session_id];
+
+	if (mtk_cam_is_m2m(ctx)) {
+		if (ipi_msg->cookie.frame_no > 1) {
+			dev_dbg(dev, "[M2M] wait_for_completion +\n");
+			wait_for_completion(&ctx->m2m_complete);
+			dev_dbg(dev, "[M2M] wait_for_completion -\n");
+		}
+	}
+
+	spin_lock(&ctx->using_buffer_list.lock);
+
+	ctx->composed_frame_seq_no = ipi_msg->cookie.frame_no;
+	if (mtk_cam_is_mstream(ctx)) {
+		dev_dbg(dev, "[mstream] ctx:%d ack frame_num:%d\n",
+			ctx->stream_id, ctx->composed_frame_seq_no);
+	} else {
+		dev_dbg(dev, "ctx:%d ack frame_num:%d\n",
+			ctx->stream_id, ctx->composed_frame_seq_no);
+	}
+
+	/* get from using list */
+	if (list_empty(&ctx->using_buffer_list.list)) {
+		spin_unlock(&ctx->using_buffer_list.lock);
+		return -EINVAL;
+	}
+	/* assign raw using buf */
+	buf_entry = list_first_entry(&ctx->using_buffer_list.list,
+				     struct mtk_cam_working_buf_entry,
+				     list_entry);
+	list_del(&buf_entry->list_entry);
+	ctx->using_buffer_list.cnt--;
+
+	s_data = mtk_cam_wbuf_get_s_data(buf_entry);
+	if (!s_data) {
+		dev_dbg(dev, "ctx:%d no req for ack frame_num:%d\n",
+			ctx->stream_id, ctx->composed_frame_seq_no);
+		spin_unlock(&ctx->using_buffer_list.lock);
+		return -EINVAL;
+	}
+
+	req = mtk_cam_s_data_get_req(s_data);
+	if (req->flags & MTK_CAM_REQ_FLAG_SENINF_IMMEDIATE_UPDATE &&
+			(req->ctx_link_update & (1 << s_data->pipe_id))) {
+		if (mtk_cam_is_mstream(ctx)) {
+			struct mtk_cam_request_stream_data *mstream_1st_data;
+
+			mstream_1st_data =  mtk_cam_req_get_s_data(req, ctx->stream_id, 1);
+			if (ipi_msg->cookie.frame_no == mstream_1st_data->frame_seq_no) {
+				is_mux_change_with_apply_cq = true;
+				ctx->is_first_cq_done = 0;
+			}
+		} else {
+			is_mux_change_with_apply_cq = true;
+		}
+	}
+
+	buf_entry->cq_desc_offset =
+		ipi_msg->ack_data.frame_result.cq_desc_offset;
+	buf_entry->cq_desc_size =
+		ipi_msg->ack_data.frame_result.cq_desc_size;
+	buf_entry->sub_cq_desc_offset =
+		ipi_msg->ack_data.frame_result.sub_cq_desc_offset;
+	buf_entry->sub_cq_desc_size =
+		ipi_msg->ack_data.frame_result.sub_cq_desc_size;
+
+	/* Do nothing if the user doesn't enable force dump */
+	if (mtk_cam_feature_is_mstream(s_data->feature.raw_feature) ||
+			mtk_cam_feature_is_mstream_m2m(s_data->feature.raw_feature)) {
+		struct mtk_cam_request_stream_data *mstream_s_data;
+
+		mstream_s_data = mtk_cam_req_get_s_data(
+							s_data->req, ctx->stream_id, 0);
+		if (s_data->frame_seq_no ==
+		    mstream_s_data->frame_seq_no) {
+			mtk_cam_req_dump(s_data,
+					 MTK_CAM_REQ_DUMP_FORCE,
+					 "Camsys Force Dump", false);
+		}
+	} else {
+		mtk_cam_req_dump(s_data,
+				 MTK_CAM_REQ_DUMP_FORCE,
+				 "Camsys Force Dump", false);
+	}
+
+	if (ipi_msg->ack_data.ret) {
+		mtk_cam_req_dump(s_data,
+			MTK_CAM_REQ_DUMP_DEQUEUE_FAILED,
+			"Camsys compose error", false);
+	}
+	if (mtk_cam_is_m2m(ctx)) {
+		spin_lock(&ctx->composed_buffer_list.lock);
+		dev_dbg(dev, "%s ctx->composed_buffer_list.cnt %d\n", __func__,
+			ctx->composed_buffer_list.cnt);
+
+		if (ctx->composed_buffer_list.cnt == 0)
+			is_m2m_apply_cq = true;
+
+		spin_unlock(&ctx->composed_buffer_list.lock);
+
+		spin_lock(&ctx->processing_buffer_list.lock);
+		dev_dbg(dev, "%s ctx->processing_buffer_list.cnt %d\n", __func__,
+			ctx->processing_buffer_list.cnt);
+		spin_unlock(&ctx->processing_buffer_list.lock);
+	}
+
+	if ((ctx->composed_frame_seq_no == 1 && !mtk_cam_is_time_shared(ctx)) ||
+	    is_m2m_apply_cq || is_mux_change_with_apply_cq) {
+		struct device *dev;
+		/* apply raw CQ */
+		spin_lock(&ctx->processing_buffer_list.lock);
+		list_add_tail(&buf_entry->list_entry,
+			      &ctx->processing_buffer_list.list);
+		ctx->processing_buffer_list.cnt++;
+		spin_unlock(&ctx->processing_buffer_list.lock);
+		spin_unlock(&ctx->using_buffer_list.lock);
+
+		dev = mtk_cam_find_raw_dev(cam, ctx->pipe->enabled_raw);
+		if (!dev) {
+			dev_dbg(dev, "frm#1 raw device not found\n");
+			return -EINVAL;
+		}
+
+		raw_dev = dev_get_drvdata(dev);
+
+		if (mtk_cam_is_m2m(ctx)) {
+			dev_dbg(dev, "%s M2M apply_cq, composed_buffer_list.cnt %d frame_seq_no %d\n",
+				__func__, ctx->composed_buffer_list.cnt,
+				s_data->frame_seq_no);
+			mtk_cam_m2m_enter_cq_state(&s_data->state);
+		}
+
+		apply_cq(raw_dev, 1, buf_entry->buffer.iova,
+			 buf_entry->cq_desc_size,
+			 buf_entry->cq_desc_offset,
+			 buf_entry->sub_cq_desc_size,
+			 buf_entry->sub_cq_desc_offset);
+
+		if (mtk_cam_is_with_w_channel(ctx)) {
+			if (mtk_cam_sv_rgbw_apply_next_buffer(buf_entry->s_data) == 0)
+				dev_info(raw_dev->dev, "rgbw: sv apply next buffer failed");
+		}
+
+		if (is_mux_change_with_apply_cq)
+			mtk_cam_sv_apply_switch_buffers(ctx);
+		s_data->timestamp = ktime_get_boottime_ns();
+		s_data->timestamp_mono = ktime_get_ns();
+
+		return 0;
+	}
+
+	spin_lock(&ctx->composed_buffer_list.lock);
+	list_add_tail(&buf_entry->list_entry,
+		      &ctx->composed_buffer_list.list);
+	ctx->composed_buffer_list.cnt++;
+	if (mtk_cam_is_m2m(ctx)) {
+		dev_dbg(dev, "%s M2M composed_buffer_list.cnt %d\n",
+			__func__, ctx->composed_buffer_list.cnt);
+	}
+	spin_unlock(&ctx->composed_buffer_list.lock);
+	spin_unlock(&ctx->using_buffer_list.lock);
+
+	return 0;
+}
+
+static void isp_composer_handler(void *data, unsigned int len, void *priv)
+{
+	struct mtk_cam_device *cam = (struct mtk_cam_device *)priv;
+	struct device *dev = cam->dev;
+	struct mtkcam_ipi_event *ipi_msg;
+	struct mtk_cam_ctx *ctx;
+
+	ipi_msg = (struct mtkcam_ipi_event *)data;
+
+	if (len < offsetofend(struct mtkcam_ipi_event, ack_data)) {
+		dev_dbg(dev, "wrong IPI len:%d\n", len);
+		return;
+	}
+
+	if (ipi_msg->cmd_id != CAM_CMD_ACK ||
+	    (ipi_msg->ack_data.ack_cmd_id != CAM_CMD_FRAME &&
+	     ipi_msg->ack_data.ack_cmd_id != CAM_CMD_DESTROY_SESSION))
+		return;
+
+	if (ipi_msg->ack_data.ack_cmd_id == CAM_CMD_FRAME) {
+		isp_composer_handle_ack(cam, ipi_msg);
+		return;
+
+	} else if (ipi_msg->ack_data.ack_cmd_id == CAM_CMD_DESTROY_SESSION) {
+		ctx = &cam->ctxs[ipi_msg->cookie.session_id];
+		complete(&ctx->session_complete);
+		dev_info(dev, "%s:ctx(%d): session destroyed",
+			 __func__, ctx->stream_id);
+	}
+}
+
+static void isp_tx_frame_worker(struct work_struct *work)
+{
+	struct mtk_cam_req_work *req_work = (struct mtk_cam_req_work *)work;
+	struct mtkcam_ipi_event event;
+	struct mtkcam_ipi_session_cookie *session = &event.cookie;
+	struct mtkcam_ipi_frame_info *frame_info = &event.frame_data;
+	struct mtkcam_ipi_frame_param *frame_data, *frame_param;
+	struct mtk_cam_request *req;
+	struct mtk_cam_request_stream_data *req_stream_data;
+	struct mtk_cam_ctx *ctx;
+	struct mtk_cam_device *cam;
+	struct mtk_cam_working_buf_entry *buf_entry;
+	struct mtk_cam_buffer *meta1_buf;
+	struct mtk_cam_resource *res_user;
+	struct mtk_cam_req_raw_pipe_data *s_raw_pipe_data;
+	int i;
+
+	req_stream_data = mtk_cam_req_work_get_s_data(req_work);
+	if (!req_stream_data) {
+		pr_info("%s mtk_cam_req_work(%p), req_stream_data(%p), dropped\n",
+			__func__, req_work, req_stream_data);
+		return;
+	}
+	req = mtk_cam_s_data_get_req(req_stream_data);
+	if (!req) {
+		pr_info("%s req_stream_data(%p), req(%p), dropped\n",
+			__func__, req_stream_data, req);
+		return;
+	}
+	ctx = mtk_cam_s_data_get_ctx(req_stream_data);
+	if (!ctx) {
+		pr_info("%s req_stream_data(%p), ctx(%p), dropped\n",
+			__func__, req_stream_data, ctx);
+		return;
+	}
+
+	cam = ctx->cam;
+	if (ctx->used_raw_num == 0) {
+		dev_dbg(cam->dev, "raw is un-used, skip frame work");
+		return;
+	}
+
+	/* check if the ctx is streaming */
+	spin_lock(&ctx->streaming_lock);
+	if (!ctx->streaming) {
+		dev_info(cam->dev,
+			 "%s: skip frame work, for stream off ctx:%d, req:%d\n",
+			 __func__, ctx->stream_id, req_stream_data->frame_seq_no);
+		spin_unlock(&ctx->streaming_lock);
+		return;
+	}
+	spin_unlock(&ctx->streaming_lock);
+
+	s_raw_pipe_data = mtk_cam_s_data_get_raw_pipe_data(req_stream_data);
+
+	/* Send CAM_CMD_CONFIG if the sink pad fmt is changed */
+	if (req->ctx_link_update & 1 << ctx->stream_id ||
+	    req_stream_data->flags & MTK_CAM_REQ_S_DATA_FLAG_SINK_FMT_UPDATE)
+		mtk_cam_s_data_dev_config(req_stream_data, true, true);
+
+	if (req->ctx_link_update & 1 << ctx->stream_id)
+		mtk_cam_s_data_sv_dev_config(req_stream_data);
+
+	/* handle stagger 1,2,3 exposure */
+	if (s_raw_pipe_data == NULL) {
+		dev_info(cam->dev, "error: %s: s_raw_pipe_data = NULL\n", __func__);
+		return;
+	}
+	if (mtk_cam_feature_is_stagger(s_raw_pipe_data->res.raw_res.feature))
+		check_stagger_buffer(cam, ctx, req);
+
+	memset(&event, 0, sizeof(event));
+	event.cmd_id = CAM_CMD_FRAME;
+	session->session_id = ctx->stream_id;
+	/* prepare working buffer */
+	buf_entry = mtk_cam_working_buf_get(ctx);
+	if (!buf_entry) {
+		dev_info(cam->dev, "%s: No CQ buf availablle: req:%d(%s)\n",
+			 __func__, req_stream_data->frame_seq_no,
+			 req->req.debug_str);
+		WARN_ON(1);
+		return;
+	}
+	mtk_cam_s_data_set_wbuf(req_stream_data, buf_entry);
+	/* put to using list */
+	spin_lock(&ctx->using_buffer_list.lock);
+	list_add_tail(&buf_entry->list_entry, &ctx->using_buffer_list.list);
+	ctx->using_buffer_list.cnt++;
+	spin_unlock(&ctx->using_buffer_list.lock);
+
+	/* Prepare MTKCAM_IPI_RAW_META_STATS_1 params */
+	meta1_buf = mtk_cam_s_data_get_vbuf(req_stream_data, MTK_RAW_META_OUT_1);
+
+	/* Prepare rp message */
+	frame_info->cur_msgbuf_offset =
+		buf_entry->msg_buffer.va -
+		cam->ctxs[session->session_id].buf_pool.msg_buf_va;
+	frame_info->cur_msgbuf_size = buf_entry->msg_buffer.size;
+	frame_data = (struct mtkcam_ipi_frame_param *)buf_entry->msg_buffer.va;
+	session->frame_no = req_stream_data->frame_seq_no;
+
+	if (mtk_cam_feature_is_stagger(s_raw_pipe_data->res.raw_res.feature) ||
+		mtk_cam_feature_is_mstream(s_raw_pipe_data->res.raw_res.feature) ||
+		mtk_cam_feature_is_mstream_m2m(s_raw_pipe_data->res.raw_res.feature))
+		dev_dbg(cam->dev, "[%s:vhdr-req:%d] ctx:%d type:%d (ipi)hwscene:%d/expN:%d/prev_expN:%d\n",
+			__func__, req_stream_data->frame_seq_no, ctx->stream_id,
+			req_stream_data->feature.switch_feature_type,
+			req_stream_data->frame_params.raw_param.hardware_scenario,
+			req_stream_data->frame_params.raw_param.exposure_num,
+			req_stream_data->frame_params.raw_param.previous_exposure_num);
+
+	if (!(mtk_cam_is_mstream(ctx) &&
+		req_stream_data->frame_params.raw_param.exposure_num == 1)) {
+		frame_param = &req_stream_data->frame_params;
+		for (i = 0; i < CAM_MAX_IMAGE_INPUT; i++) {
+			if (frame_param->img_ins[i].buf[0].iova != 0 &&
+				frame_param->img_ins[i].uid.id != 0)
+				req_stream_data->raw_dmas |=
+					(1ULL << frame_param->img_ins[i].uid.id);
+		}
+		for (i = 0; i < CAM_MAX_IMAGE_OUTPUT; i++) {
+			if (frame_param->img_outs[i].buf[0][0].iova != 0 &&
+				frame_param->img_outs[i].uid.id != 0)
+				req_stream_data->raw_dmas |=
+					(1ULL << frame_param->img_outs[i].uid.id);
+		}
+		for (i = 0; i < CAM_MAX_META_OUTPUT; i++) {
+			if (frame_param->meta_outputs[i].buf.iova != 0 &&
+				frame_param->meta_outputs[i].uid.id != 0)
+				req_stream_data->raw_dmas |=
+					(1ULL << frame_param->meta_outputs[i].uid.id);
+		}
+		for (i = 0; i < CAM_MAX_PIPE_USED; i++) {
+			if (frame_param->meta_inputs[i].buf.iova != 0 &&
+				frame_param->meta_outputs[i].uid.id != 0)
+				req_stream_data->raw_dmas |=
+					(1ULL << frame_param->meta_inputs[i].uid.id);
+		}
+	}
+
+	memcpy(frame_data, &req_stream_data->frame_params,
+	       sizeof(req_stream_data->frame_params));
+	frame_data->cur_workbuf_offset =
+		buf_entry->buffer.iova -
+		cam->ctxs[session->session_id].buf_pool.working_buf_iova;
+	frame_data->cur_workbuf_size = buf_entry->buffer.size;
+
+	res_user = mtk_cam_s_data_get_res(req_stream_data);
+	if (res_user && res_user->raw_res.bin) {
+		frame_data->raw_param.bin_flag = res_user->raw_res.bin;
+	} else {
+		if (ctx->pipe->res_config.bin_limit == BIN_AUTO)
+			frame_data->raw_param.bin_flag = ctx->pipe->res_config.bin_enable;
+		else
+			frame_data->raw_param.bin_flag = ctx->pipe->res_config.bin_limit;
+	}
+
+	scp_ipi_send(cam->scp, SCP_IPI_ISP_FRAME, &event,
+		     sizeof(event), MTK_CAM_IPI_SEND_TIMEOUT);
+	dev_dbg(cam->dev,
+		 "%s: IPI send id: %d, ctx:%d, seq:%d, bin:(0x%x)\n",
+		 req->req.debug_str, event.cmd_id, session->session_id,
+		 req_stream_data->frame_seq_no,
+		 frame_data->raw_param.bin_flag);
+}
+
+static bool mtk_cam_sv_req_enqueue(struct mtk_cam_ctx *ctx,
+	struct mtk_cam_request *req, unsigned int idx)
+{
+	unsigned int i, pipe_id;
+	struct mtk_cam_request_stream_data *ctx_stream_data;
+	struct mtk_cam_request_stream_data *pipe_stream_data;
+	struct mtk_camsv_working_buf_entry *buf_entry;
+	bool ret = true;
+
+	if (ctx->used_sv_num == 0)
+		return ret;
+
+	ctx_stream_data = mtk_cam_req_get_s_data(req, ctx->stream_id, idx);
+	for (i = 0 ; i < ctx->used_sv_num ; i++) {
+		pipe_id = ctx->sv_pipe[i]->id;
+		buf_entry = mtk_cam_sv_working_buf_get(ctx);
+		req->p_data[pipe_id].s_data_num = req->p_data[ctx->stream_id].s_data_num;
+		pipe_stream_data = mtk_cam_req_get_s_data(req, pipe_id, idx);
+		/* align master pipe's sequence number */
+		pipe_stream_data->frame_seq_no = ctx_stream_data->frame_seq_no;
+		pipe_stream_data->req = ctx_stream_data->req;
+		pipe_stream_data->pipe_id = ctx->sv_pipe[i]->id;
+		pipe_stream_data->ctx = ctx;
+		buf_entry->ts_raw = 0;
+		buf_entry->ts_sv = 0;
+		mtk_cam_req_dump_work_init(pipe_stream_data);
+		mtk_cam_req_work_init(&pipe_stream_data->sv_work, pipe_stream_data);
+		INIT_WORK(&pipe_stream_data->sv_work.work, mtk_cam_sv_work);
+		mtk_cam_sv_wbuf_set_s_data(buf_entry, pipe_stream_data);
+		spin_lock(&ctx->sv_using_buffer_list[i].lock);
+		list_add_tail(&buf_entry->list_entry,
+				&ctx->sv_using_buffer_list[i].list);
+		ctx->sv_using_buffer_list[i].cnt++;
+		spin_unlock(&ctx->sv_using_buffer_list[i].lock);
+	}
+	if (ctx_stream_data->frame_seq_no == 1) {
+		mtk_cam_sv_apply_all_buffers(ctx, ktime_get_boottime_ns());
+		if (ctx->stream_id >= MTKCAM_SUBDEV_CAMSV_START &&
+			ctx->stream_id < MTKCAM_SUBDEV_CAMSV_END) {
+			if (ctx_stream_data->state.estate == E_STATE_READY ||
+				ctx_stream_data->state.estate == E_STATE_SENSOR) {
+				ctx_stream_data->state.estate = E_STATE_OUTER;
+			}
+		}
+	}
+
+	return ret;
+}
+
+static void mtk_cam_sensor_switch_stop_reinit_hw(struct mtk_cam_ctx *ctx,
+					  struct mtk_cam_request_stream_data *s_data,
+					  int stream_id)
+{
+	struct mtk_cam_device *cam = ctx->cam;
+	struct mtk_cam_request *req;
+	struct mtk_cam_req_raw_pipe_data *s_raw_pipe_data;
+	struct mtk_raw_device *raw_dev;
+	struct mtk_camsv_device *sv_dev;
+	int i;
+	int sof_count;
+	int feature, feature_first_req;
+
+	req = mtk_cam_s_data_get_req(s_data);
+	s_raw_pipe_data = mtk_cam_s_data_get_raw_pipe_data(s_data);
+	feature = s_raw_pipe_data->res.raw_res.feature;
+	feature_first_req = s_data->feature.raw_feature;
+
+	dev_info(ctx->cam->dev,
+		 "%s:%s:pipe(%d): switch op seq(%d), flags(0x%x), ctx_link_update(0x%x), stream_id(%d), feature(0x%x)\n",
+		 __func__, req->req.debug_str, s_data->pipe_id, s_data->frame_seq_no,
+		 req->flags, req->ctx_link_update, stream_id,
+		 feature);
+
+	/* stop the raw */
+	if (ctx->used_raw_num) {
+		raw_dev = get_main_raw_dev(ctx->cam, ctx->pipe);
+		if (mtk_cam_is_time_shared(ctx)) {
+			unsigned int hw_scen =
+				(1 << MTKCAM_IPI_HW_PATH_OFFLINE_M2M);
+			for (i = MTKCAM_SUBDEV_CAMSV_START ; i < MTKCAM_SUBDEV_CAMSV_END ; i++) {
+				if (ctx->pipe->enabled_raw & (1 << i)) {
+					mtk_cam_sv_dev_stream_on
+						(ctx, i - MTKCAM_SUBDEV_CAMSV_START, 0, hw_scen);
+					cam->sv.pipelines[
+						i - MTKCAM_SUBDEV_CAMSV_START].is_occupied = 0;
+					ctx->pipe->enabled_raw &= ~(1 << i);
+				}
+			}
+		} else {
+			if (mtk_cam_is_mstream(ctx)) {
+				struct mtk_cam_request_stream_data *mstream_2nd_data;
+
+				mstream_2nd_data = mtk_cam_req_get_s_data(req, stream_id, 0);
+				if (mstream_2nd_data->seninf_new) {
+					s_data->sensor = mstream_2nd_data->sensor;
+					s_data->seninf_new = mstream_2nd_data->seninf_new;
+					s_data->seninf_old = mstream_2nd_data->seninf_old;
+				}
+			}
+			// stream_on(raw_dev, 0);
+			dev_info(ctx->cam->dev, "%s: Disable cammux: %s\n", __func__,
+				 s_data->seninf_old->name);
+			mtk_cam_seninf_set_camtg(s_data->seninf_old, PAD_SRC_RAW0, 0xFF);
+			mtk_cam_seninf_set_camtg(s_data->seninf_old, PAD_SRC_RAW1, 0xFF);
+			mtk_cam_seninf_set_camtg(s_data->seninf_old, PAD_SRC_RAW2, 0xFF);
+			immediate_stream_off(raw_dev);
+		}
+		/* Twin */
+		if (ctx->pipe->res_config.raw_num_used != 1) {
+			struct mtk_raw_device *raw_dev_sub =
+						get_sub_raw_dev(cam, ctx->pipe);
+			stream_on(raw_dev_sub, 0);
+			if (ctx->pipe->res_config.raw_num_used == 3) {
+				struct mtk_raw_device *raw_dev_sub2 =
+					get_sub2_raw_dev(cam, ctx->pipe);
+				stream_on(raw_dev_sub2, 0);
+			}
+		}
+	}
+
+	/* stop the camsv for special scenario */
+	if (mtk_cam_is_stagger(ctx)) {
+		unsigned int hw_scen = mtk_raw_get_hdr_scen_id(ctx);
+
+		for (i = MTKCAM_SUBDEV_CAMSV_START; i < MTKCAM_SUBDEV_CAMSV_END; i++) {
+			if (ctx->pipe->enabled_raw & (1 << i)) {
+				mtk_cam_sv_dev_stream_on
+					(ctx, i - MTKCAM_SUBDEV_CAMSV_START, 0, hw_scen);
+				cam->sv.pipelines[i - MTKCAM_SUBDEV_CAMSV_START].is_occupied = 0;
+				ctx->pipe->enabled_raw &= ~(1 << i);
+			}
+		}
+	} else if (mtk_cam_is_with_w_channel(ctx)) {
+		unsigned int hw_scen = (1 << MTKCAM_SV_SPECIAL_SCENARIO_ADDITIONAL_RAW);
+
+		for (i = MTKCAM_SUBDEV_CAMSV_START; i < MTKCAM_SUBDEV_CAMSV_END; i++) {
+			if (ctx->pipe->enabled_raw & (1 << i)) {
+				mtk_cam_sv_dev_stream_on
+					(ctx, i - MTKCAM_SUBDEV_CAMSV_START, 0, hw_scen);
+				cam->sv.pipelines[i - MTKCAM_SUBDEV_CAMSV_START].is_occupied = 0;
+				ctx->pipe->enabled_raw &= ~(1 << i);
+			}
+		}
+	}
+
+	/* stop the camsv */
+	for (i = 0 ; i < ctx->used_sv_num ; i++) {
+		sv_dev = get_camsv_dev(cam, ctx->sv_pipe[i]);
+		mtk_cam_sv_vf_on(sv_dev, 0);
+		sv_dev->is_enqueued = 0;
+	}
+
+	/* apply sensor setting if needed */
+	if ((s_data->frame_seq_no == 1) &&
+	    (s_data->flags & MTK_CAM_REQ_S_DATA_FLAG_SENSOR_HDL_EN) &&
+	    !(s_data->flags & MTK_CAM_REQ_S_DATA_FLAG_SENSOR_HDL_COMPLETE))
+		mtk_cam_set_sensor_full(s_data, &ctx->sensor_ctrl);
+
+	/* keep the sof_count to restore it after reinit */
+	sof_count = raw_dev->sof_count;
+
+	/* reinitialized the settings */
+	if (ctx->used_raw_num) {
+		initialize(raw_dev, 0);
+		raw_dev->sof_count = sof_count;
+		/* Stagger */
+		if (mtk_cam_feature_is_stagger(feature)) {
+			if (mtk_cam_feature_is_stagger(feature_first_req))
+				stagger_enable(raw_dev);
+			else
+				stagger_disable(raw_dev);
+		}
+		/* Sub sample */
+		if (mtk_cam_feature_is_subsample(feature))
+			subsample_enable(raw_dev);
+		/* Twin */
+		if (ctx->pipe->res_config.raw_num_used != 1) {
+			struct mtk_raw_device *raw_dev_sub =
+			get_sub_raw_dev(cam, ctx->pipe);
+			initialize(raw_dev_sub, 1);
+			if (ctx->pipe->res_config.raw_num_used == 3) {
+				struct mtk_raw_device *raw_dev_sub2 =
+					get_sub2_raw_dev(cam, ctx->pipe);
+				initialize(raw_dev_sub2, 1);
+			}
+		}
+	}
+}
+
+static void handle_immediate_switch(struct mtk_cam_ctx *ctx,
+			     struct mtk_cam_request_stream_data *s_data,
+			     int stream_id)
+{
+	struct mtk_cam_request *req;
+
+	req = mtk_cam_s_data_get_req(s_data);
+
+	if (!is_raw_subdev(stream_id)) {
+		dev_info(ctx->cam->dev,
+			 "%s:%s:pipe(%d): switch op seq(%d), flags(0x%x), ctx_link_update(0x%x), stream_id(%d)\n",
+			 __func__, req->req.debug_str, s_data->pipe_id, s_data->frame_seq_no,
+			 req->flags, req->ctx_link_update, stream_id);
+		return;
+	}
+
+	if ((req->flags & MTK_CAM_REQ_FLAG_SENINF_IMMEDIATE_UPDATE) &&
+	    (req->ctx_link_update & (1 << stream_id)))
+		mtk_cam_sensor_switch_stop_reinit_hw(ctx, s_data, stream_id);
+}
+
+void mtk_cam_dev_req_enqueue(struct mtk_cam_device *cam,
+			     struct mtk_cam_request *req)
+{
+	unsigned int i, j;
+
+	for (i = 0; i < cam->max_stream_num; i++) {
+		if (req->pipe_used & (1 << i))  {
+			unsigned int stream_id = i;
+			struct mtk_cam_req_work *frame_work, *done_work;
+			struct mtk_cam_request_stream_data *req_stream_data;
+			struct mtk_cam_request_stream_data *pipe_stream_data;
+			struct mtk_cam_ctx *ctx = &cam->ctxs[stream_id];
+			struct mtk_camsys_sensor_ctrl *sensor_ctrl = &ctx->sensor_ctrl;
+			unsigned int drained_seq_no = 0;
+			unsigned int initial_frame = 0;
+
+			/**
+			 * For sub dev shares ctx's cases, e.g.
+			 * PDAF's topoloy, camsv is the part of raw pipeline's
+			 * ctx and we need to skip the camsv sub dev's ctx (which
+			 * is not streaming here).
+			 */
+			if (!ctx->streaming)
+				continue;
+			atomic_set(&ctx->sensor_ctrl.sensor_enq_seq_no,
+				atomic_read(&ctx->enqueued_frame_seq_no));
+			/*sensor setting after request drained check*/
+			if (ctx->used_raw_num) {
+				if (ctx->pipe->feature_active == 0 &&
+				    ctx->dequeued_frame_seq_no > 3) {
+					drained_seq_no =
+						atomic_read(&sensor_ctrl->last_drained_seq_no);
+					if (atomic_read(&sensor_ctrl->sensor_enq_seq_no) ==
+						drained_seq_no)
+						mtk_cam_submit_kwork_in_sensorctrl(
+							sensor_ctrl->sensorsetting_wq,
+							sensor_ctrl);
+				}
+			}
+			req_stream_data = mtk_cam_req_get_s_data(req, stream_id, 0);
+
+			if (req_stream_data->frame_seq_no == 1 ||
+			    ((mtk_cam_is_mstream(ctx) || mtk_cam_is_mstream_m2m(ctx)) &&
+			    (req_stream_data->frame_seq_no == 2)) ||
+			    (req->ctx_link_update & (1 << stream_id)))
+				initial_frame = 1;
+			frame_work = &req_stream_data->frame_work;
+			mtk_cam_req_work_init(frame_work, req_stream_data);
+
+			for (j = 0 ; j < MTKCAM_SUBDEV_MAX ; j++) {
+				if ((1 << j & ctx->streaming_pipe) && (1 << j & req->pipe_used)) {
+					pipe_stream_data = mtk_cam_req_get_s_data(req, j, 0);
+					done_work = &pipe_stream_data->frame_done_work;
+					INIT_WORK(&done_work->work, mtk_cam_frame_done_work);
+
+					done_work = &pipe_stream_data->meta1_done_work;
+					atomic_set(&done_work->is_queued, 0);
+					INIT_WORK(&done_work->work, mtk_cam_meta1_done_work);
+				}
+			}
+
+			if (mtk_cam_is_time_shared(ctx)) {
+				req_stream_data->frame_params.raw_param.hardware_scenario =
+						MTKCAM_IPI_HW_PATH_OFFLINE_M2M;
+				req_stream_data->frame_params.raw_param.exposure_num = 1;
+				req_stream_data->state.estate = E_STATE_TS_READY;
+			}
+
+			if (ctx->sensor && (initial_frame ||
+					mtk_cam_is_m2m(ctx))) {
+				if (mtk_cam_is_mstream(ctx) || mtk_cam_is_mstream_m2m(ctx))
+					mtk_cam_mstream_initial_sensor_setup(req, ctx);
+				else
+					mtk_cam_initial_sensor_setup(req, ctx);
+			}
+			if (ctx->used_raw_num != 0) {
+				if (ctx->sensor && MTK_CAM_INITIAL_REQ_SYNC == 0 &&
+					(ctx->pipe->feature_active == 0 ||
+					req_stream_data->frame_params.raw_param.hardware_scenario
+					== MTKCAM_IPI_HW_PATH_OFFLINE_SRT_DCIF_STAGGER) &&
+					req_stream_data->frame_seq_no == 2) {
+					mtk_cam_initial_sensor_setup(req, ctx);
+				}
+			} else { // for single sv pipe stream
+				if (ctx->sensor && MTK_CAM_INITIAL_REQ_SYNC == 0 &&
+					req_stream_data->frame_seq_no == 2) {
+					mtk_cam_initial_sensor_setup(req, ctx);
+				}
+			}
+
+			if (mtk_cam_is_mstream(ctx)) {
+				if (req->ctx_link_update & (1 << stream_id)) {
+					struct mtk_cam_request_stream_data *s_data;
+
+					s_data = mtk_cam_req_get_s_data(req, stream_id, 1);
+					ctx->sensor_ctrl.ctx = ctx;
+					s_data->ctx = ctx;
+					handle_immediate_switch(ctx, s_data, i);
+				}
+			} else {
+				handle_immediate_switch(ctx, req_stream_data, i);
+			}
+
+			/* Prepare CQ compose work */
+			if (mtk_cam_is_mstream(ctx) || mtk_cam_is_mstream_m2m(ctx)) {
+				int frame_cnt;
+
+				for (frame_cnt = 1; frame_cnt <= MTKCAM_MSTREAM_MAX;
+						frame_cnt++) {
+					if (frame_cnt == 1) { // first exposure
+						dev_dbg(cam->dev, "%s: mstream 1st exp frame\n",
+							__func__);
+						req_stream_data =
+							mtk_cam_req_get_s_data(req,
+							stream_id, 1);
+						mtk_cam_sv_req_enqueue(ctx, req, 1);
+					} else { // second exposure
+						dev_dbg(cam->dev, "%s: mstream 2nd exp frame\n",
+							__func__);
+						req_stream_data =
+							mtk_cam_req_get_s_data(req,
+							stream_id, 0);
+						mtk_cam_sv_req_enqueue(ctx, req, 0);
+					}
+					frame_work = &req_stream_data->frame_work;
+					mtk_cam_req_dump_work_init(req_stream_data);
+					INIT_WORK(&frame_work->work,
+						isp_tx_frame_worker);
+					queue_work(ctx->composer_wq,
+						&frame_work->work);
+				}
+			} else {
+				mtk_cam_sv_req_enqueue(ctx, req, 0);
+				mtk_cam_req_dump_work_init(req_stream_data);
+				INIT_WORK(&frame_work->work, isp_tx_frame_worker);
+				queue_work(ctx->composer_wq, &frame_work->work);
+			}
+
+			dev_dbg(cam->dev, "%s:ctx:%d:req:%d(%s) enqueue ctx_used:0x%x,streaming_ctx:0x%x,job cnt:%d, running(%d)\n",
+				__func__, stream_id, req_stream_data->frame_seq_no,
+				req->req.debug_str, req->ctx_used, cam->streaming_ctx,
+				cam->running_job_count, atomic_read(&ctx->running_s_data_cnt));
+		}
+	}
+}
+
+int isp_composer_create_session(struct mtk_cam_ctx *ctx)
+{
+	struct mtk_cam_device *cam = ctx->cam;
+	struct mtkcam_ipi_event event;
+	struct mtkcam_ipi_session_cookie *session = &event.cookie;
+	struct mtkcam_ipi_session_param	*session_data = &event.session_data;
+
+	memset(&event, 0, sizeof(event));
+	event.cmd_id = CAM_CMD_CREATE_SESSION;
+	session->session_id = ctx->stream_id;
+	session_data->workbuf.iova = ctx->buf_pool.working_buf_iova;
+	session_data->workbuf.scp_addr = ctx->buf_pool.working_buf_scp_addr;
+	session_data->workbuf.size = ctx->buf_pool.working_buf_size;
+	session_data->msg_buf.scp_addr = ctx->buf_pool.msg_buf_scp_addr;
+	session_data->msg_buf.size = ctx->buf_pool.msg_buf_size;
+	session_data->raw_workbuf.scp_addr = ctx->buf_pool.raw_workbuf_scp_addr;
+	session_data->raw_workbuf.size = ctx->buf_pool.raw_workbuf_size;
+	session_data->priv_workbuf.scp_addr = ctx->buf_pool.priv_workbuf_scp_addr;
+	session_data->priv_workbuf.size = ctx->buf_pool.priv_workbuf_size;
+	session_data->session_buf.scp_addr = ctx->buf_pool.session_buf_scp_addr;
+	session_data->session_buf.size = ctx->buf_pool.session_buf_size;
+
+	scp_ipi_send(cam->scp, SCP_IPI_ISP_CMD, &event,
+		     sizeof(event), MTK_CAM_IPI_SEND_TIMEOUT);
+	dev_dbg(cam->dev,
+		"%s: IPI send id: %d, cq_buf(scp addr:%x,sz:%d, msg_buf(scp addr:%x,sz%d)\n",
+		__func__, event.cmd_id, session_data->workbuf.scp_addr,
+		session_data->workbuf.size, session_data->msg_buf.scp_addr,
+		session_data->msg_buf.size);
+	return 0;
+}
+
+void isp_composer_destroy_session(struct mtk_cam_ctx *ctx)
+{
+	struct mtk_cam_device *cam = ctx->cam;
+	struct mtkcam_ipi_event event;
+	struct mtkcam_ipi_session_cookie *session = &event.cookie;
+
+	memset(&event, 0, sizeof(event));
+	event.cmd_id = CAM_CMD_DESTROY_SESSION;
+	session->session_id = ctx->stream_id;
+	scp_ipi_send(cam->scp, SCP_IPI_ISP_CMD, &event,
+		     sizeof(event), MTK_CAM_IPI_SEND_TIMEOUT);
+	dev_info(cam->dev, "IPI send id: %d\n", event.cmd_id);
+}
+
+static void
+isp_composer_hw_config(struct mtk_cam_device *cam,
+		       struct mtk_cam_ctx *ctx,
+		       struct mtkcam_ipi_config_param *config_param)
+{
+	struct mtkcam_ipi_event event;
+	struct mtkcam_ipi_session_cookie *session = &event.cookie;
+	struct mtkcam_ipi_config_param *config = &event.config_data;
+
+	memset(&event, 0, sizeof(event));
+	event.cmd_id = CAM_CMD_CONFIG;
+	session->session_id = ctx->stream_id;
+	memcpy(config, config_param, sizeof(*config_param));
+	dev_dbg(cam->dev, "%s sw_feature:%d\n", __func__, config->sw_feature);
+	scp_ipi_send(cam->scp, SCP_IPI_ISP_CMD, &event,
+		     sizeof(event), MTK_CAM_IPI_SEND_TIMEOUT);
+	dev_dbg(cam->dev, "IPI send id: %d\n", event.cmd_id);
+
+	/* For debug dump file */
+	memcpy(&ctx->config_params, config_param, sizeof(*config_param));
+	dev_dbg(cam->dev, "%s:ctx(%d): save config_param to ctx, sz:%ld\n",
+		__func__, ctx->stream_id, sizeof(*config_param));
+}
+
+struct mtk_raw_pipeline*
+mtk_cam_dev_get_raw_pipeline(struct mtk_cam_device *cam,
+			     unsigned int pipe_id)
+{
+	if (pipe_id < MTKCAM_SUBDEV_RAW_START || pipe_id >= MTKCAM_SUBDEV_RAW_END)
+		return NULL;
+	else
+		return &cam->raw.pipelines[pipe_id - MTKCAM_SUBDEV_RAW_0];
+}
+
+static int
+mtk_cam_raw_pipeline_config(struct mtk_cam_ctx *ctx,
+			    struct mtkcam_ipi_input_param *cfg_in_param)
+{
+	struct mtk_raw_pipeline *pipe = ctx->pipe;
+	struct mtk_raw *raw = pipe->raw;
+	unsigned int i;
+	int ret;
+
+	/* reset pm_runtime during streaming dynamic change */
+	if (ctx->streaming) {
+		for (i = 0; i < ARRAY_SIZE(raw->devs); i++) {
+			if (pipe->enabled_raw & 1 << i) {
+				dev_info(raw->cam_dev, "%s: power off raw (%d) for reset\n",
+						 __func__, i);
+				pm_runtime_put_sync(raw->devs[i]);
+			}
+		}
+	}
+
+	ret = mtk_cam_raw_select(ctx, cfg_in_param);
+	if (ret) {
+		dev_info(raw->cam_dev, "failed select raw: %d\n",
+			ctx->stream_id);
+		return ret;
+	}
+
+	for (i = 0; i < ARRAY_SIZE(raw->devs); i++) {
+		if (pipe->enabled_raw & 1 << i) {
+			dev_info(raw->cam_dev, "%s: power on raw (%d)\n", __func__, i);
+			pm_runtime_get_sync(raw->devs[i]);
+		}
+	}
+
+	if (ret < 0) {
+		dev_info(raw->cam_dev,
+			"failed at pm_runtime_get_sync: %s\n",
+			dev_driver_string(raw->devs[i]));
+		for (i = i - 1; i >= 0; i--)
+			if (pipe->enabled_raw & 1 << i) {
+				dev_info(raw->cam_dev, "%s: power off raw (%d)\n",
+						 __func__, i);
+				pm_runtime_put_sync(raw->devs[i]);
+			}
+		return ret;
+	}
+	ctx->used_raw_dev = pipe->enabled_raw;
+	dev_info(raw->cam_dev, "ctx_id %d used_raw_dev 0x%x pipe_id %d\n",
+		ctx->stream_id, ctx->used_raw_dev, pipe->id);
+	return 0;
+}
+
+static int
+mtk_cam_s_data_raw_pipeline_config(struct mtk_cam_request_stream_data *s_data,
+			    struct mtkcam_ipi_input_param *cfg_in_param)
+{
+	struct mtk_cam_ctx *ctx;
+	struct mtk_raw_pipeline *pipe;
+	struct mtk_cam_req_raw_pipe_data *s_raw_pipe_data;
+	struct mtk_raw *raw;
+	int ret;
+
+	ctx = mtk_cam_s_data_get_ctx(s_data);
+	s_raw_pipe_data = mtk_cam_s_data_get_raw_pipe_data(s_data);
+	pipe = ctx->pipe;
+	raw = pipe->raw;
+
+	ret = mtk_cam_s_data_raw_select(s_data, cfg_in_param);
+	if (ret) {
+		dev_dbg(raw->cam_dev, "failed select raw: %d\n",
+			ctx->stream_id);
+		return ret;
+	}
+
+	s_raw_pipe_data->enabled_raw |= s_raw_pipe_data->stagger_select.enabled_raw;
+	dev_info(raw->cam_dev, "ctx_id %d used_raw_dev 0x%x pipe_id %d\n",
+		ctx->stream_id, s_raw_pipe_data->enabled_raw, pipe->id);
+
+	return 0;
+}
+
+void mtk_cam_apply_pending_dev_config(struct mtk_cam_request_stream_data *s_data)
+{
+	struct mtk_cam_req_raw_pipe_data *s_raw_pipe_data;
+	struct mtk_cam_ctx *ctx;
+	char *debug_str = mtk_cam_s_data_get_dbg_str(s_data);
+
+	s_raw_pipe_data = mtk_cam_s_data_get_raw_pipe_data(s_data);
+
+	ctx = mtk_cam_s_data_get_ctx(s_data);
+	ctx->pipe->feature_active = ctx->pipe->user_res.raw_res.feature;
+	ctx->pipe->stagger_path = s_raw_pipe_data->stagger_select.stagger_path;
+	ctx->pipe->enabled_raw = s_raw_pipe_data->enabled_raw;
+	ctx->used_raw_dev = s_raw_pipe_data->enabled_raw;
+
+	dev_info(ctx->cam->dev,
+		"%s:%s:pipe(%d):seq(%d):feature_active(0x%llx), ctx->pipe->user_res.raw_res.feature(%lld), stagger_path(0x%x), enabled_raw(0x%x)\n",
+		__func__, debug_str, ctx->stream_id, s_data->frame_seq_no,
+		ctx->pipe->feature_active,
+		ctx->pipe->user_res.raw_res.feature,
+		ctx->pipe->stagger_path, ctx->pipe->enabled_raw);
+}
+
+int mtk_cam_s_data_dev_config(struct mtk_cam_request_stream_data *s_data,
+	bool streaming, bool config_pipe)
+{
+	struct mtk_cam_req_raw_pipe_data *s_raw_pipe_data;
+	struct mtk_cam_ctx *ctx;
+	struct mtk_cam_device *cam;
+	struct device *dev;
+	struct mtkcam_ipi_config_param config_param;
+	struct mtkcam_ipi_input_param *cfg_in_param;
+	struct mtk_raw_pipeline *pipe;
+	struct mtk_raw *raw;
+	struct v4l2_mbus_framefmt *mf;
+	struct device *dev_raw;
+	struct mtk_raw_device *raw_dev;
+	struct v4l2_format *img_fmt;
+	unsigned int i;
+	int ret;
+	u32 mf_code;
+	int feature;
+
+	ctx = mtk_cam_s_data_get_ctx(s_data);
+	cam = ctx->cam;
+	dev = cam->dev;
+	pipe = ctx->pipe;
+	raw = pipe->raw;
+	mf = &pipe->cfg[MTK_RAW_SINK].mbus_fmt;
+	s_raw_pipe_data = mtk_cam_s_data_get_raw_pipe_data(s_data);
+	feature = s_raw_pipe_data->res.raw_res.feature;
+
+	memset(&config_param, 0, sizeof(config_param));
+
+	/* Update cfg_in_param */
+	cfg_in_param = &config_param.input;
+	cfg_in_param->pixel_mode = ctx->pipe->res_config.tgo_pxl_mode;
+	cfg_in_param->subsample = mtk_cam_get_subsample_ratio(
+					ctx->pipe->feature_active);
+	/* TODO: data pattern from meta buffer per frame setting */
+	cfg_in_param->data_pattern = MTKCAM_IPI_SENSOR_PATTERN_NORMAL;
+	img_fmt = &pipe->vdev_nodes[MTK_RAW_SINK].pending_fmt;
+	cfg_in_param->in_crop.s.w = img_fmt->fmt.pix_mp.width;
+	cfg_in_param->in_crop.s.h = img_fmt->fmt.pix_mp.height;
+	dev_dbg(dev, "sink pad code:0x%x, tg size:%d %d\n", mf->code,
+		cfg_in_param->in_crop.s.w, cfg_in_param->in_crop.s.h);
+
+	mf_code = mf->code & 0xffff; /* todo: sensor mode issue, need patch */
+	cfg_in_param->raw_pixel_id = mtk_cam_get_sensor_pixel_id(mf_code);
+	cfg_in_param->fmt = mtk_cam_get_sensor_fmt(mf_code);
+	if (cfg_in_param->fmt == MTKCAM_IPI_IMG_FMT_UNKNOWN ||
+	    cfg_in_param->raw_pixel_id == MTKCAM_IPI_BAYER_PXL_ID_UNKNOWN) {
+		dev_dbg(dev, "unknown sd code:%d\n", mf_code);
+		return -EINVAL;
+	}
+
+	s_raw_pipe_data->enabled_raw = ctx->pipe->enabled_raw & MTKCAM_SUBDEV_RAW_MASK;
+	if (config_pipe && mtk_cam_feature_is_stagger(feature)) {
+		ret = mtk_cam_s_data_raw_pipeline_config(s_data, cfg_in_param);
+		if (ret)
+			return ret;
+	}
+
+	config_param.flags = MTK_CAM_IPI_CONFIG_TYPE_INPUT_CHANGE;
+
+	dev_dbg(dev, "%s: config_param flag:0x%x enabled_raw:0x%x\n", __func__,
+			config_param.flags, s_raw_pipe_data->enabled_raw);
+
+	if (config_pipe && mtk_cam_feature_is_stagger(feature)) {
+		int main = (1 << MTKCAM_SUBDEV_RAW_0);
+		int hw_scen, req_amount, idle_pipes;
+
+		for (i = MTKCAM_SUBDEV_RAW_START; i < MTKCAM_SUBDEV_RAW_END; i++) {
+			if (s_raw_pipe_data->enabled_raw & (1 << i)) {
+				main = (1 << i);
+				break;
+			}
+		}
+		if (s_raw_pipe_data->stagger_select.stagger_path == STAGGER_ON_THE_FLY) {
+			hw_scen = (1 << MTKCAM_IPI_HW_PATH_ON_THE_FLY_DCIF_STAGGER);
+			req_amount = (mtk_cam_feature_is_3_exposure(feature)) ? 2 : 1;
+		} else if (s_raw_pipe_data->stagger_select.stagger_path == STAGGER_DCIF) {
+			hw_scen = (1 << MTKCAM_IPI_HW_PATH_OFFLINE_SRT_DCIF_STAGGER);
+			req_amount = (mtk_cam_feature_is_3_exposure(feature)) ? 3 : 2;
+		} else if (s_raw_pipe_data->stagger_select.stagger_path == STAGGER_OFFLINE) {
+			hw_scen = (1 << MTKCAM_IPI_HW_PATH_OFFLINE_STAGGER);
+			req_amount = (mtk_cam_feature_is_3_exposure(feature)) ? 3 : 2;
+		} else {
+			hw_scen = (1 << MTKCAM_IPI_HW_PATH_ON_THE_FLY_DCIF_STAGGER);
+			req_amount = (mtk_cam_feature_is_3_exposure(feature)) ? 2 : 1;
+		}
+		idle_pipes = get_available_sv_pipes(cam, hw_scen, req_amount, main, 0);
+		/* cached used sv pipes */
+		s_raw_pipe_data->enabled_raw |= idle_pipes;
+		ctx->pipe->enabled_raw |= idle_pipes;
+		if (idle_pipes == 0) {
+			dev_info(cam->dev, "no available sv pipes(scen:%d/req_amount:%d)",
+				hw_scen, req_amount);
+			return -EINVAL;
+		}
+	}
+
+	update_hw_mapping(ctx, &config_param, feature,
+		s_raw_pipe_data->stagger_select.stagger_path,
+		s_raw_pipe_data->enabled_raw);
+
+	if (mtk_cam_feature_is_mstream(feature) || mtk_cam_feature_is_mstream_m2m(feature)) {
+		config_param.sw_feature = MTKCAM_IPI_SW_FEATURE_VHDR_MSTREAM;
+		dev_dbg(dev, "%s sw_feature:%d", __func__, config_param.sw_feature);
+	} else {
+		config_param.sw_feature = (mtk_cam_feature_is_stagger(feature) == 1 ||
+			mtk_cam_feature_is_stagger_m2m(feature) == 1) ?
+			MTKCAM_IPI_SW_FEATURE_VHDR_STAGGER : MTKCAM_IPI_SW_FEATURE_NORMAL;
+	}
+
+	dev_raw = mtk_cam_find_raw_dev(cam, s_raw_pipe_data->enabled_raw);
+	if (!dev_raw) {
+		dev_dbg(dev, "config raw device not found\n");
+		return -EINVAL;
+	}
+
+	raw_dev = dev_get_drvdata(dev_raw);
+	for (i = 0; i < RAW_PIPELINE_NUM; i++)
+		if (raw->pipelines[i].enabled_raw & 1 << raw_dev->id) {
+			raw_dev->pipeline = &raw->pipelines[i];
+			/* TWIN case */
+			if (raw->pipelines[i].res_config.raw_num_used != 1) {
+				struct mtk_raw_device *raw_dev_sub =
+						get_sub_raw_dev(cam, ctx->pipe);
+				raw_dev_sub->pipeline = &raw->pipelines[i];
+				dev_dbg(dev, "twin main/sub raw_id:%d/%d\n",
+					raw_dev->id, raw_dev_sub->id);
+				if (raw->pipelines[i].res_config.raw_num_used == 3) {
+					struct mtk_raw_device *raw_dev_sub2 =
+						get_sub2_raw_dev(cam, ctx->pipe);
+					raw_dev_sub2->pipeline = &raw->pipelines[i];
+					dev_dbg(dev, "triplet m/s/s2 raw_id:%d/%d/%d\n",
+						raw_dev->id, raw_dev_sub->id, raw_dev_sub2->id);
+				}
+			}
+			break;
+		}
+
+	isp_composer_hw_config(cam, ctx, &config_param);
+	dev_dbg(dev, "raw %d %s done\n", raw_dev->id, __func__);
+
+	return 0;
+}
+
+int mtk_cam_s_data_sv_dev_config(struct mtk_cam_request_stream_data *s_data)
+{
+	struct mtk_cam_req_raw_pipe_data *s_raw_pipe_data;
+	struct mtk_cam_ctx *ctx;
+	struct mtk_cam_device *cam;
+	int i, j, ret = 0, used_pipes, src_pad_idx, exp_no, feature;
+	unsigned int hw_scen;
+	bool bDcif;
+
+	ctx = mtk_cam_s_data_get_ctx(s_data);
+	cam = ctx->cam;
+	s_raw_pipe_data = mtk_cam_s_data_get_raw_pipe_data(s_data);
+	feature = s_raw_pipe_data->res.raw_res.feature;
+
+	/* check exposure number */
+	if (mtk_cam_feature_is_2_exposure(feature))
+		exp_no = 2;
+	else if (mtk_cam_feature_is_3_exposure(feature))
+		exp_no = 3;
+	else
+		exp_no = 1;
+
+	/* check hardware scenario */
+	if (s_raw_pipe_data->stagger_select.stagger_path == STAGGER_ON_THE_FLY) {
+		hw_scen = (1 << MTKCAM_IPI_HW_PATH_ON_THE_FLY_DCIF_STAGGER);
+		bDcif = false;
+	} else if (s_raw_pipe_data->stagger_select.stagger_path == STAGGER_DCIF) {
+		hw_scen = (1 << MTKCAM_IPI_HW_PATH_OFFLINE_SRT_DCIF_STAGGER);
+		bDcif = true;
+	} else if (s_raw_pipe_data->stagger_select.stagger_path == STAGGER_OFFLINE) {
+		hw_scen = (1 << MTKCAM_IPI_HW_PATH_OFFLINE_STAGGER);
+		bDcif = false;
+	} else {
+		hw_scen = (1 << MTKCAM_IPI_HW_PATH_ON_THE_FLY_DCIF_STAGGER);
+		bDcif = false;
+	}
+
+	used_pipes = s_raw_pipe_data->enabled_raw;
+	for (i = MTKCAM_SUBDEV_CAMSV_START; i < MTKCAM_SUBDEV_CAMSV_END; i++) {
+		for (j = 0; j < MAX_STAGGER_EXP_AMOUNT; j++) {
+			if (cam->sv.pipelines[i -
+				MTKCAM_SUBDEV_CAMSV_START].hw_cap &
+				(1 << (j + CAMSV_EXP_ORDER_SHIFT))) {
+				src_pad_idx = PAD_SRC_RAW0 + j;
+				break;
+			}
+		}
+		if (used_pipes & (1 << i)) {
+			ret = mtk_cam_sv_dev_config
+				(ctx, i - MTKCAM_SUBDEV_CAMSV_START, hw_scen,
+				 (bDcif && (src_pad_idx == exp_no)) ?
+				 2 : src_pad_idx - PAD_SRC_RAW0);
+			if (ret) {
+				dev_info(cam->dev, "%s failed(pipe:%d)", __func__, i);
+				return ret;
+			}
+		}
+	}
+
+	return ret;
+}
+
+/* FIXME: modified from v5: should move to raw */
+int mtk_cam_dev_config(struct mtk_cam_ctx *ctx, bool streaming, bool config_pipe)
+{
+	struct mtk_cam_device *cam = ctx->cam;
+	struct device *dev = cam->dev;
+	struct mtkcam_ipi_config_param config_param;
+	struct mtkcam_ipi_input_param *cfg_in_param;
+	struct mtk_raw_pipeline *pipe = ctx->pipe;
+	struct mtk_raw *raw = pipe->raw;
+	struct v4l2_mbus_framefmt *mf = &pipe->cfg[MTK_RAW_SINK].mbus_fmt;
+	struct device *dev_raw;
+	struct mtk_raw_device *raw_dev;
+	struct v4l2_format *img_fmt;
+	unsigned int i;
+	int ret;
+	u32 mf_code;
+	int feature_active; /* Used to know max exposure num */
+
+	feature_active = ctx->pipe->feature_active;
+	/**
+	 * If you wan't to get the first req's raw_feature (not the max exp. num),
+	 * you can use read ctx->pipe->feature_pending here.
+	 */
+
+	memset(&config_param, 0, sizeof(config_param));
+
+	/* Update cfg_in_param */
+	cfg_in_param = &config_param.input;
+	cfg_in_param->pixel_mode = ctx->pipe->res_config.tgo_pxl_mode;
+	cfg_in_param->subsample = mtk_cam_get_subsample_ratio(
+					ctx->pipe->feature_active);
+	/* TODO: data pattern from meta buffer per frame setting */
+	cfg_in_param->data_pattern = MTKCAM_IPI_SENSOR_PATTERN_NORMAL;
+	img_fmt = &pipe->vdev_nodes[MTK_RAW_SINK].pending_fmt;
+	cfg_in_param->in_crop.s.w = img_fmt->fmt.pix_mp.width;
+	cfg_in_param->in_crop.s.h = img_fmt->fmt.pix_mp.height;
+
+	if (mtk_cam_is_pure_m2m(ctx)) {
+		mf = &pipe->cfg[MTK_RAW_RAWI_2_IN].mbus_fmt;
+		dev_dbg(dev, "[pure m2m] rawi2 pad code:0x%x, sink tg size:%d %d\n",
+			mf->code, cfg_in_param->in_crop.s.w, cfg_in_param->in_crop.s.h);
+	} else {
+		dev_dbg(dev, "sink pad code:0x%x, tg size:%d %d\n", mf->code,
+			cfg_in_param->in_crop.s.w, cfg_in_param->in_crop.s.h);
+	}
+
+	mf_code = mf->code & 0xffff; /* todo: sensor mode issue, need patch */
+	cfg_in_param->raw_pixel_id = mtk_cam_get_sensor_pixel_id(mf_code);
+	cfg_in_param->fmt = mtk_cam_get_sensor_fmt(mf_code);
+	if (cfg_in_param->fmt == MTKCAM_IPI_IMG_FMT_UNKNOWN ||
+	    cfg_in_param->raw_pixel_id == MTKCAM_IPI_BAYER_PXL_ID_UNKNOWN) {
+		dev_info(dev, "unknown sd code:%d\n", mf_code);
+		return -EINVAL;
+	}
+
+	if (config_pipe) {
+		config_param.flags = MTK_CAM_IPI_CONFIG_TYPE_INIT;
+		ret = mtk_cam_raw_pipeline_config(ctx, cfg_in_param);
+		if (ret)
+			return ret;
+	} else {
+		/* Change the input size information only */
+		config_param.flags = MTK_CAM_IPI_CONFIG_TYPE_INPUT_CHANGE;
+	}
+
+	if (config_pipe && is_first_request_sync(ctx))
+		config_param.flags |= MTK_CAM_IPI_CONFIG_TYPE_EXEC_TWICE;
+
+	dev_dbg(dev, "%s: config_param flag:0x%x enabled_raw:0x%x\n", __func__,
+			config_param.flags, ctx->pipe->enabled_raw);
+
+	if (config_pipe && mtk_cam_feature_is_stagger(feature_active)) {
+		int main = (1 << MTKCAM_SUBDEV_RAW_0);
+		int hw_scen, req_amount, idle_pipes;
+
+		for (i = MTKCAM_SUBDEV_RAW_START; i < MTKCAM_SUBDEV_RAW_END; i++) {
+			if (ctx->pipe->enabled_raw & (1 << i)) {
+				main = (1 << i);
+				break;
+			}
+		}
+		if (ctx->pipe->stagger_path == STAGGER_ON_THE_FLY) {
+			hw_scen = (1 << MTKCAM_IPI_HW_PATH_ON_THE_FLY_DCIF_STAGGER);
+			req_amount = (mtk_cam_feature_is_3_exposure(feature_active)) ? 2 : 1;
+		} else if (ctx->pipe->stagger_path == STAGGER_DCIF) {
+			hw_scen = (1 << MTKCAM_IPI_HW_PATH_OFFLINE_SRT_DCIF_STAGGER);
+			req_amount = (mtk_cam_feature_is_3_exposure(feature_active)) ? 3 : 2;
+		} else if (ctx->pipe->stagger_path == STAGGER_OFFLINE) {
+			hw_scen = (1 << MTKCAM_IPI_HW_PATH_OFFLINE_STAGGER);
+			req_amount = (mtk_cam_feature_is_3_exposure(feature_active)) ? 3 : 2;
+		} else {
+			hw_scen = (1 << MTKCAM_IPI_HW_PATH_ON_THE_FLY_DCIF_STAGGER);
+			req_amount = (mtk_cam_feature_is_3_exposure(feature_active)) ? 2 : 1;
+		}
+		idle_pipes = get_available_sv_pipes(cam, hw_scen, req_amount, main, 0);
+		/* cached used sv pipes */
+		ctx->pipe->enabled_raw |= idle_pipes;
+		if (idle_pipes == 0) {
+			dev_info(cam->dev, "no available sv pipes(scen:%d/req_amount:%d)",
+				hw_scen, req_amount);
+			return -EINVAL;
+		}
+	} else if (config_pipe && mtk_cam_is_time_shared(ctx)) {
+		int main = (1 << MTKCAM_SUBDEV_RAW_0);
+		int hw_scen, req_amount, idle_pipes;
+
+		for (i = MTKCAM_SUBDEV_RAW_START; i < MTKCAM_SUBDEV_RAW_END; i++) {
+			if (ctx->pipe->enabled_raw & (1 << i)) {
+				main = (1 << i);
+				break;
+			}
+		}
+		hw_scen = (1 << MTKCAM_IPI_HW_PATH_OFFLINE_M2M);
+		req_amount = 1;
+		idle_pipes = get_available_sv_pipes(cam, hw_scen, req_amount, main, 0);
+		/* cached used sv pipes */
+		ctx->pipe->enabled_raw |= idle_pipes;
+		if (idle_pipes == 0) {
+			dev_info(cam->dev, "no available sv pipes(scen:%d/req_amount:%d)",
+				hw_scen, req_amount);
+			return -EINVAL;
+		}
+	} else if (mtk_cam_is_with_w_channel(ctx)) {
+		int main, hw_scen, req_amount, idle_pipes;
+
+		main = (ctx->pipe->enabled_raw & (1 << MTKCAM_SUBDEV_RAW_0)) ?
+			(1 << MTKCAM_SUBDEV_RAW_0) : (1 << MTKCAM_SUBDEV_RAW_1);
+		hw_scen = (1 << MTKCAM_SV_SPECIAL_SCENARIO_ADDITIONAL_RAW);
+		req_amount = 1;
+
+		idle_pipes = get_available_sv_pipes(cam, hw_scen, req_amount, main, 0);
+		/* cached used sv pipes */
+		ctx->pipe->enabled_raw |= idle_pipes;
+		if (idle_pipes == 0) {
+			dev_info(cam->dev, "no available sv pipes(scen:%d/req_amount:%d)",
+				hw_scen, req_amount);
+			return -EINVAL;
+		}
+	}
+
+
+	update_hw_mapping(ctx, &config_param, feature_active, ctx->pipe->stagger_path,
+			  ctx->pipe->enabled_raw);
+	if (mtk_cam_feature_is_mstream(feature_active) ||
+	    mtk_cam_feature_is_mstream_m2m(feature_active)) {
+		config_param.sw_feature = MTKCAM_IPI_SW_FEATURE_VHDR_MSTREAM;
+		dev_dbg(dev, "%s sw_feature:%d", __func__, config_param.sw_feature);
+	} else {
+		config_param.sw_feature = (mtk_cam_feature_is_stagger(feature_active) == 1 ||
+			mtk_cam_feature_is_stagger_m2m(feature_active) == 1) ?
+			MTKCAM_IPI_SW_FEATURE_VHDR_STAGGER : MTKCAM_IPI_SW_FEATURE_NORMAL;
+	}
+
+	dev_raw = mtk_cam_find_raw_dev(cam, ctx->used_raw_dev);
+	if (!dev_raw) {
+		dev_info(dev, "config raw device not found\n");
+		return -EINVAL;
+	}
+	raw_dev = dev_get_drvdata(dev_raw);
+	for (i = 0; i < RAW_PIPELINE_NUM; i++)
+		if (raw->pipelines[i].enabled_raw & 1 << raw_dev->id) {
+			raw_dev->pipeline = &raw->pipelines[i];
+			/* TWIN case */
+			if (raw->pipelines[i].res_config.raw_num_used != 1) {
+				struct mtk_raw_device *raw_dev_sub =
+						get_sub_raw_dev(cam, ctx->pipe);
+				raw_dev_sub->pipeline = &raw->pipelines[i];
+				dev_dbg(dev, "twin main/sub raw_id:%d/%d\n",
+					raw_dev->id, raw_dev_sub->id);
+				if (raw->pipelines[i].res_config.raw_num_used == 3) {
+					struct mtk_raw_device *raw_dev_sub2 =
+						get_sub2_raw_dev(cam, ctx->pipe);
+					raw_dev_sub2->pipeline = &raw->pipelines[i];
+					dev_dbg(dev, "triplet m/s/s2 raw_id:%d/%d/%d\n",
+						raw_dev->id, raw_dev_sub->id, raw_dev_sub2->id);
+				}
+			}
+			break;
+		}
+
+	if (!streaming)
+		reset(raw_dev);
+	isp_composer_hw_config(cam, ctx, &config_param);
+	dev_dbg(dev, "raw %d %s done\n", raw_dev->id, __func__);
+
+	return 0;
+}
+
+static int isp_composer_init(struct mtk_cam_device *cam)
+{
+	struct device *dev = cam->dev;
+	int ret;
+
+	ret = rproc_boot(cam->rproc_handle);
+	if (ret) {
+		dev_err(dev, "failed to rproc_boot\n");
+		return ret;
+	}
+
+	ret = scp_ipi_register(cam->scp, SCP_IPI_ISP_CMD,
+			       isp_composer_handler, cam);
+	if (ret) {
+		dev_err(dev, "failed to register IPI cmd\n");
+		return ret;
+	}
+
+	ret = scp_ipi_register(cam->scp, SCP_IPI_ISP_FRAME,
+			       isp_composer_handler, cam);
+	if (ret) {
+		dev_err(dev, "failed to register IPI frame\n");
+		goto unreg_ipi_cmd;
+	}
+
+	return 0;
+
+unreg_ipi_cmd:
+	scp_ipi_unregister(cam->scp, SCP_IPI_ISP_CMD);
+
+	return ret;
+}
+
+static int mtk_cam_runtime_suspend(struct device *dev)
+{
+	dev_dbg(dev, "- %s\n", __func__);
+	return 0;
+}
+
+static int mtk_cam_runtime_resume(struct device *dev)
+{
+	dev_dbg(dev, "- %s\n", __func__);
+	return 0;
+}
+
+struct mtk_cam_ctx *mtk_cam_find_ctx(struct mtk_cam_device *cam,
+				     struct media_entity *entity)
+{
+	unsigned int i;
+
+	for (i = 0;  i < cam->max_stream_num; i++) {
+		if (media_entity_pipeline(entity) == &cam->ctxs[i].pipeline)
+			return &cam->ctxs[i];
+	}
+
+	return NULL;
+}
+
+struct mtk_cam_ctx *mtk_cam_start_ctx(struct mtk_cam_device *cam,
+				      struct mtk_cam_video_device *node)
+{
+	struct mtk_cam_ctx *ctx = node->ctx;
+	struct device *dev;
+	struct v4l2_subdev **target_sd;
+	int ret, i, is_first_ctx;
+	struct media_entity *entity = &node->vdev.entity;
+	struct media_pipeline_pad *ppad;
+
+	dev_info(cam->dev, "%s:ctx(%d): triggered by %s\n",
+		 __func__, ctx->stream_id, entity->name);
+
+	atomic_set(&ctx->enqueued_frame_seq_no, 0);
+	ctx->composed_frame_seq_no = 0;
+	ctx->dequeued_frame_seq_no = 0;
+	for (i = 0; i < MAX_SV_PIPES_PER_STREAM; i++)
+		ctx->sv_dequeued_frame_seq_no[i] = 0;
+	ctx->enqueued_request_cnt = 0;
+	ctx->next_sof_mask_frame_seq_no = 0;
+	ctx->working_request_seq = 0;
+	atomic_set(&ctx->running_s_data_cnt, 0);
+	init_completion(&ctx->session_complete);
+	init_completion(&ctx->m2m_complete);
+
+	is_first_ctx = !cam->composer_cnt;
+	if (is_first_ctx) {
+		cam->running_job_count = 0;
+		dev_info(cam->dev, "%s: power on camsys\n", __func__);
+		pm_runtime_get_sync(cam->dev);
+		ret = isp_composer_init(cam);
+		if (ret)
+			goto fail_shutdown;
+		/* To catch camsys exception and trigger dump */
+		if (cam->debug_fs)
+			cam->debug_fs->ops->exp_reinit(cam->debug_fs);
+	}
+	cam->composer_cnt++;
+	if (node->uid.pipe_id >= MTKCAM_SUBDEV_CAMSV_START &&
+		node->uid.pipe_id < MTKCAM_SUBDEV_CAMSV_END) {
+		switch (node->uid.pipe_id) {
+		case MTKCAM_SUBDEV_CAMSV_0:
+		case MTKCAM_SUBDEV_CAMSV_1:
+		case MTKCAM_SUBDEV_CAMSV_4:
+#ifdef ISP7_1
+		case MTKCAM_SUBDEV_CAMSV_5:
+#endif
+			dev = find_larb(&cam->larb, 13);
+			break;
+		default:
+			dev = find_larb(&cam->larb, 14);
+			break;
+		}
+	} else {
+		switch (node->desc.id) {
+		case MTK_RAW_YUVO_1_OUT:
+		case MTK_RAW_YUVO_2_OUT:
+		case MTK_RAW_YUVO_3_OUT:
+		case MTK_RAW_YUVO_4_OUT:
+		case MTK_RAW_YUVO_5_OUT:
+		case MTK_RAW_DRZS4NO_1_OUT:
+		case MTK_RAW_DRZS4NO_2_OUT:
+		case MTK_RAW_DRZS4NO_3_OUT:
+		case MTK_RAW_RZH1N2TO_1_OUT:
+		case MTK_RAW_RZH1N2TO_2_OUT:
+		case MTK_RAW_RZH1N2TO_3_OUT:
+			/* should have a better implementation here */
+			dev = cam->raw.yuvs[0];
+			break;
+		default:
+			dev = cam->raw.devs[0];
+			break;
+		}
+	}
+	ret = mtk_cam_working_buf_pool_init(ctx, dev);
+	if (ret) {
+		dev_info(cam->dev, "failed to reserve DMA memory:%d\n", ret);
+		goto fail_uninit_composer;
+	}
+
+	kthread_init_worker(&ctx->sensor_worker);
+	ctx->sensor_worker_task = kthread_run(kthread_worker_fn,
+					      &ctx->sensor_worker,
+					      "sensor_worker-%d",
+					      ctx->stream_id);
+	if (IS_ERR(ctx->sensor_worker_task)) {
+		dev_info(cam->dev, "%s:ctx(%d): could not create sensor_worker_task\n",
+			 __func__, ctx->stream_id);
+		goto fail_release_buffer_pool;
+	}
+
+	sched_set_fifo(ctx->sensor_worker_task);
+
+	ctx->composer_wq =
+			alloc_ordered_workqueue(dev_name(cam->dev),
+						WQ_HIGHPRI | WQ_FREEZABLE);
+	if (!ctx->composer_wq) {
+		dev_info(cam->dev, "failed to alloc composer workqueue\n");
+		goto fail_uninit_sensor_worker_task;
+	}
+
+	ctx->frame_done_wq =
+			alloc_ordered_workqueue(dev_name(cam->dev),
+						WQ_HIGHPRI | WQ_FREEZABLE);
+	if (!ctx->frame_done_wq) {
+		dev_info(cam->dev, "failed to alloc frame_done workqueue\n");
+		goto fail_uninit_composer_wq;
+	}
+
+	ctx->sv_wq =
+			alloc_ordered_workqueue(dev_name(cam->dev),
+						WQ_HIGHPRI | WQ_FREEZABLE);
+	if (!ctx->sv_wq) {
+		dev_info(cam->dev, "failed to alloc sv workqueue\n");
+		goto fail_uninit_frame_done_wq;
+	}
+
+	mtk_cam_sv_working_buf_pool_init(ctx);
+	ret = media_pipeline_start(&entity->pads[0], &ctx->pipeline);
+	if (ret) {
+		dev_info(cam->dev,
+			 "%s:pipe(%d):failed in media_pipeline_start:%d\n",
+			 __func__, node->uid.pipe_id, ret);
+		goto fail_uninit_sv_wq;
+	}
+
+	/* traverse to update used subdevs & number of nodes */
+	i = 0;
+	list_for_each_entry(ppad, &ctx->pipeline.pads, list) {
+		entity = ppad->pad->entity;
+		dev_dbg(cam->dev, "linked entity %s\n", entity->name);
+
+		target_sd = NULL;
+
+		switch (entity->function) {
+		case MEDIA_ENT_F_IO_V4L:
+			ctx->enabled_node_cnt++;
+			break;
+		case MEDIA_ENT_F_PROC_VIDEO_PIXEL_FORMATTER: /* pipeline */
+			if (i >= MAX_PIPES_PER_STREAM)
+				continue;
+				//goto fail_stop_pipeline;
+
+			target_sd = ctx->pipe_subdevs + i;
+			i++;
+			break;
+		case MEDIA_ENT_F_VID_IF_BRIDGE: /* seninf */
+			target_sd = &ctx->seninf;
+			if (*target_sd)
+				continue;
+
+			break;
+		case MEDIA_ENT_F_CAM_SENSOR:
+			target_sd = &ctx->sensor;
+			break;
+		default:
+			break;
+		}
+
+		if (!target_sd)
+			continue;
+
+		if (*target_sd) {
+			dev_info(cam->dev, "duplicated subdevs!!!\n");
+			goto fail_stop_pipeline;
+		}
+
+		if (is_media_entity_v4l2_subdev(entity))
+			*target_sd = media_entity_to_v4l2_subdev(entity);
+	}
+
+	return ctx;
+
+fail_stop_pipeline:
+	media_pipeline_stop(&entity->pads[0]);
+fail_uninit_sv_wq:
+	destroy_workqueue(ctx->sv_wq);
+fail_uninit_frame_done_wq:
+	destroy_workqueue(ctx->frame_done_wq);
+fail_uninit_composer_wq:
+	destroy_workqueue(ctx->composer_wq);
+fail_uninit_sensor_worker_task:
+	kthread_stop(ctx->sensor_worker_task);
+	ctx->sensor_worker_task = NULL;
+fail_release_buffer_pool:
+	mtk_cam_working_buf_pool_release(ctx, dev);
+fail_uninit_composer:
+	isp_composer_uninit(cam);
+	cam->composer_cnt--;
+fail_shutdown:
+	if (is_first_ctx) {
+		pm_runtime_mark_last_busy(cam->dev);
+		pm_runtime_put_sync_autosuspend(cam->dev);
+		rproc_shutdown(cam->rproc_handle);
+	}
+	return NULL;
+}
+
+void mtk_cam_stop_ctx(struct mtk_cam_ctx *ctx, struct mtk_cam_video_device *node)
+{
+	struct mtk_cam_device *cam = ctx->cam;
+	struct media_entity *entity = &node->vdev.entity;
+	struct device *dev;
+	unsigned int i, j;
+
+	if (node->uid.pipe_id >= MTKCAM_SUBDEV_CAMSV_START &&
+		node->uid.pipe_id < MTKCAM_SUBDEV_CAMSV_END) {
+		switch (node->uid.pipe_id) {
+		case MTKCAM_SUBDEV_CAMSV_0:
+		case MTKCAM_SUBDEV_CAMSV_1:
+		case MTKCAM_SUBDEV_CAMSV_4:
+#ifdef ISP7_1
+		case MTKCAM_SUBDEV_CAMSV_5:
+#endif
+			dev = find_larb(&cam->larb, 13);
+			break;
+		default:
+			dev = find_larb(&cam->larb, 14);
+			break;
+		}
+	} else {
+		switch (node->desc.id) {
+		case MTK_RAW_YUVO_1_OUT:
+		case MTK_RAW_YUVO_2_OUT:
+		case MTK_RAW_YUVO_3_OUT:
+		case MTK_RAW_YUVO_4_OUT:
+		case MTK_RAW_YUVO_5_OUT:
+		case MTK_RAW_DRZS4NO_1_OUT:
+		case MTK_RAW_DRZS4NO_2_OUT:
+		case MTK_RAW_DRZS4NO_3_OUT:
+		case MTK_RAW_RZH1N2TO_1_OUT:
+		case MTK_RAW_RZH1N2TO_2_OUT:
+		case MTK_RAW_RZH1N2TO_3_OUT:
+			/* should have a better implementation here */
+			dev = cam->raw.yuvs[0];
+			break;
+		default:
+			dev = cam->raw.devs[0];
+			break;
+		}
+	}
+
+	dev_info(cam->dev, "%s:ctx(%d): triggered by %s\n",
+		 __func__, ctx->stream_id, entity->name);
+
+	media_pipeline_stop(&entity->pads[0]);
+	if (ctx->session_created) {
+		dev_dbg(cam->dev,
+			"%s:ctx(%d): session_created, wait for composer session destroy\n",
+			__func__, ctx->stream_id);
+		if (wait_for_completion_timeout(
+			&ctx->session_complete, msecs_to_jiffies(300)) == 0)
+			dev_info(cam->dev, "%s:ctx(%d): complete timeout\n",
+			__func__, ctx->stream_id);
+	}
+
+	/* For M2M feature, signal all waiters */
+	if (mtk_cam_is_m2m(ctx))
+		complete_all(&ctx->m2m_complete);
+
+	if (!cam->streaming_ctx) {
+		struct v4l2_subdev *sd;
+		v4l2_device_for_each_subdev(sd, &cam->v4l2_dev) {
+			if (sd->entity.function == MEDIA_ENT_F_VID_IF_BRIDGE) {
+				int ret;
+				ret = v4l2_subdev_call(sd, video, s_stream, 0);
+				if (ret)
+					dev_err(cam->dev,
+						"failed to streamoff %s:%d\n",
+						sd->name, ret);
+
+				/*if(!sd->entity.pipe) {
+					dev_err(cam->dev, "%s() entity.pipe is empty for vid IF bridge\n", __func__);
+				}
+				else {
+					sd->entity.pipe->streaming_count = 0;
+					sd->entity.pipe = NULL;
+				}*/
+			} else if (sd->entity.function ==
+						MEDIA_ENT_F_CAM_SENSOR) {
+				/*if(!sd->entity.pipe) {
+					dev_err(cam->dev, "%s() entity.pipe is empty for sensor\n", __func__);
+				}
+				else {
+					sd->entity.pipe->streaming_count = 0;
+					sd->entity.pipe = NULL;
+				}*/
+			}
+		}
+	}
+
+	drain_workqueue(ctx->composer_wq);
+	destroy_workqueue(ctx->composer_wq);
+	ctx->composer_wq = NULL;
+	drain_workqueue(ctx->frame_done_wq);
+	destroy_workqueue(ctx->frame_done_wq);
+	ctx->frame_done_wq = NULL;
+	drain_workqueue(ctx->sv_wq);
+	destroy_workqueue(ctx->sv_wq);
+	ctx->sv_wq = NULL;
+	kthread_flush_worker(&ctx->sensor_worker);
+	kthread_stop(ctx->sensor_worker_task);
+	ctx->sensor_worker_task = NULL;
+
+	for (i = 0 ; i < ctx->used_sv_num ; i++) {
+		for (j = 0 ; j < cam->max_stream_num ; j++) {
+			if (ctx->sv_pipe[i]->id == cam->ctxs[j].stream_id) {
+				atomic_set(&cam->ctxs[j].enqueued_frame_seq_no, 0);
+				break;
+			}
+		}
+	}
+	ctx->session_created = 0;
+	ctx->enabled_node_cnt = 0;
+	ctx->streaming_node_cnt = 0;
+	ctx->streaming_pipe = 0;
+	ctx->sensor = NULL;
+	ctx->prev_sensor = NULL;
+	ctx->seninf = NULL;
+	ctx->prev_seninf = NULL;
+	atomic_set(&ctx->enqueued_frame_seq_no, 0);
+	ctx->enqueued_request_cnt = 0;
+	ctx->next_sof_mask_frame_seq_no = 0;
+	ctx->working_request_seq = 0;
+	ctx->composed_frame_seq_no = 0;
+	ctx->is_first_cq_done = 0;
+	ctx->cq_done_status = 0;
+	ctx->used_raw_num = 0;
+	ctx->used_sv_num = 0;
+
+	INIT_LIST_HEAD(&ctx->using_buffer_list.list);
+	INIT_LIST_HEAD(&ctx->composed_buffer_list.list);
+	INIT_LIST_HEAD(&ctx->processing_buffer_list.list);
+
+	//INIT_LIST_HEAD(&ctx->sv_using_buffer_list.list);
+	//INIT_LIST_HEAD(&ctx->sv_processing_buffer_list.list);
+
+	for (i = 0; i < MAX_SV_PIPES_PER_STREAM; i++) {
+		INIT_LIST_HEAD(&ctx->sv_using_buffer_list[i].list);
+		INIT_LIST_HEAD(&ctx->sv_processing_buffer_list[i].list);
+	}
+	INIT_LIST_HEAD(&ctx->processing_img_buffer_list.list);
+	for (i = 0; i < MAX_PIPES_PER_STREAM; i++)
+		ctx->pipe_subdevs[i] = NULL;
+
+	for (i = 0; i < MAX_SV_PIPES_PER_STREAM; i++) {
+		ctx->sv_pipe[i] = NULL;
+		ctx->used_sv_dev[i] = 0;
+	}
+	isp_composer_uninit(cam);
+		cam->composer_cnt--;
+
+	dev_info(cam->dev, "%s: ctx-%d:  composer_cnt:%d\n",
+		__func__, ctx->stream_id, cam->composer_cnt);
+
+	mtk_cam_working_buf_pool_release(ctx, dev);
+
+	if (ctx->cam->rproc_handle && !ctx->cam->composer_cnt) {
+		dev_info(cam->dev, "%s power off camsys\n", __func__);
+		pm_runtime_mark_last_busy(cam->dev);
+		pm_runtime_put_sync_autosuspend(cam->dev);
+		rproc_shutdown(cam->rproc_handle);
+	}
+}
+
+int PipeIDtoTGIDX(int pipe_id)
+{
+	/* camsv's cammux id is defined in its own dts */
+
+	switch (pipe_id) {
+	case MTKCAM_SUBDEV_RAW_0:
+					return 0;
+	case MTKCAM_SUBDEV_RAW_1:
+					return 1;
+	case MTKCAM_SUBDEV_RAW_2:
+					return 2;
+	default:
+			break;
+	}
+	return -1;
+}
+
+int mtk_cam_call_seninf_set_pixelmode(struct mtk_cam_ctx *ctx,
+				      struct v4l2_subdev *sd,
+				      int pad_id, int pixel_mode)
+{
+	int ret;
+
+	ret = mtk_cam_seninf_set_pixelmode(sd, pad_id, pixel_mode);
+	dev_dbg(ctx->cam->dev,
+		"%s:ctx(%d): seninf(%s): pad(%d), pixel_mode(%d)\n, ret(%d)",
+		__func__, ctx->stream_id, sd->name, pad_id, pixel_mode,
+		ret);
+
+	return ret;
+}
+
+int mtk_cam_ctx_stream_on(struct mtk_cam_ctx *ctx, struct mtk_cam_video_device *node)
+{
+	struct mtk_cam_device *cam = ctx->cam;
+	struct device *dev, *mem_dev;
+	struct mtk_raw_device *raw_dev;
+	struct mtk_camsv_device *camsv_dev;
+	int i, j, ret;
+	int tgo_pxl_mode;
+	bool need_dump_mem = false;
+	int feature_active = 0;	/* Used to know max exposure num */
+	int feature_first_req = 0;	/* Used to know first frame's exposure num */
+
+	dev_info(cam->dev, "ctx %d stream on, streaming_pipe:0x%x\n",
+		 ctx->stream_id, ctx->streaming_pipe);
+
+	if (ctx->streaming) {
+		dev_info(cam->dev, "ctx-%d is already streaming on\n", ctx->stream_id);
+		return 0;
+	}
+
+	for (i = 0; i < MAX_PIPES_PER_STREAM && ctx->pipe_subdevs[i]; i++) {
+		ret = v4l2_subdev_call(ctx->pipe_subdevs[i], video,
+				       s_stream, 1);
+		if (ret) {
+			dev_info(cam->dev, "failed to stream on %s: %d\n",
+				ctx->pipe_subdevs[i]->name, ret);
+			goto fail_pipe_off;
+		}
+	}
+
+	if (ctx->pipe) {
+		feature_active = ctx->pipe->feature_active;
+		feature_first_req = ctx->pipe->feature_pending;
+	}
+	if (ctx->used_raw_num) {
+		tgo_pxl_mode = ctx->pipe->res_config.tgo_pxl_mode;
+		if (node->uid.pipe_id >= MTKCAM_SUBDEV_CAMSV_START &&
+			node->uid.pipe_id < MTKCAM_SUBDEV_CAMSV_END) {
+			switch (node->uid.pipe_id) {
+			case MTKCAM_SUBDEV_CAMSV_0:
+			case MTKCAM_SUBDEV_CAMSV_1:
+			case MTKCAM_SUBDEV_CAMSV_4:
+#ifdef ISP7_1
+			case MTKCAM_SUBDEV_CAMSV_5:
+#ifdef FULL_CAM_SUBDEV
+			case MTKCAM_SUBDEV_CAMSV_8:
+			case MTKCAM_SUBDEV_CAMSV_9:
+			case MTKCAM_SUBDEV_CAMSV_12:
+			case MTKCAM_SUBDEV_CAMSV_13:
+#endif
+#endif
+				mem_dev = find_larb(&cam->larb, 13);
+				break;
+			default:
+				mem_dev = find_larb(&cam->larb, 14);
+				break;
+			}
+		} else {
+			switch (node->desc.id) {
+			case MTK_RAW_YUVO_1_OUT:
+			case MTK_RAW_YUVO_2_OUT:
+			case MTK_RAW_YUVO_3_OUT:
+			case MTK_RAW_YUVO_4_OUT:
+			case MTK_RAW_YUVO_5_OUT:
+			case MTK_RAW_DRZS4NO_1_OUT:
+			case MTK_RAW_DRZS4NO_2_OUT:
+			case MTK_RAW_DRZS4NO_3_OUT:
+			case MTK_RAW_RZH1N2TO_1_OUT:
+			case MTK_RAW_RZH1N2TO_2_OUT:
+			case MTK_RAW_RZH1N2TO_3_OUT:
+				/* should have a better implementation here */
+				mem_dev = cam->raw.yuvs[0];
+				break;
+			default:
+				mem_dev = cam->raw.devs[0];
+				break;
+			}
+		}
+
+		if (ctx->pipe->dynamic_exposure_num_max > 1 ||
+		    mtk_cam_feature_is_switchable_hdr(feature_active))
+			ret = mtk_cam_img_working_buf_pool_init(ctx,
+				2 + mtk_cam_feature_is_3_exposure(feature_active),
+				mem_dev);
+		if (mtk_cam_feature_is_time_shared(feature_active))
+			ret = mtk_cam_img_working_buf_pool_init(ctx, CAM_IMG_BUF_NUM,
+								mem_dev);
+		if (ret) {
+			dev_info(dev, "failed to reserve DMA memory:%d\n", ret);
+			goto fail_img_buf_release;
+		}
+
+		ret = mtk_cam_dev_config(ctx, false, true);
+		if (ret)
+			goto fail_img_buf_release;
+		dev = mtk_cam_find_raw_dev(cam, ctx->used_raw_dev);
+		if (!dev) {
+			dev_info(cam->dev, "streamon raw device not found\n");
+			goto fail_img_buf_release;
+		}
+		raw_dev = dev_get_drvdata(dev);
+
+
+		/* stagger mode - use sv to output data to DRAM - online mode */
+		if (mtk_cam_feature_is_stagger(feature_active)) {
+			int used_pipes, src_pad_idx, exp_no;
+			unsigned int hw_scen = mtk_raw_get_hdr_scen_id(ctx);
+			bool bDcif;
+
+			/* check exposure number */
+			if (mtk_cam_feature_is_2_exposure(feature_active))
+				exp_no = 2;
+			else if (mtk_cam_feature_is_3_exposure(feature_active))
+				exp_no = 3;
+			else
+				exp_no = 1;
+
+			/* check stagger mode */
+#ifdef ISP7_1
+			bDcif = (ctx->pipe->stagger_path == STAGGER_DCIF) ? true : false;
+#else
+			bDcif = false;
+#endif
+
+			used_pipes = ctx->pipe->enabled_raw;
+			for (i = MTKCAM_SUBDEV_CAMSV_START ; i < MTKCAM_SUBDEV_CAMSV_END ; i++) {
+				for (j = 0; j < MAX_STAGGER_EXP_AMOUNT; j++) {
+					if (cam->sv.pipelines[i -
+						MTKCAM_SUBDEV_CAMSV_START].hw_cap &
+						(1 << (j + CAMSV_EXP_ORDER_SHIFT))) {
+						src_pad_idx = PAD_SRC_RAW0 + j;
+						break;
+					}
+				}
+				if (used_pipes & (1 << i)) {
+					mtk_cam_call_seninf_set_pixelmode(ctx, ctx->seninf,
+									  src_pad_idx,
+									  tgo_pxl_mode);
+					mtk_cam_seninf_set_camtg(ctx->seninf, src_pad_idx,
+						cam->sv.pipelines[
+							i - MTKCAM_SUBDEV_CAMSV_START].cammux_id);
+					dev_info(cam->dev, "seninf_set_camtg(src_pad:%d/i:%d/camtg:%d)",
+						src_pad_idx, i,
+						cam->sv.pipelines[
+							i - MTKCAM_SUBDEV_CAMSV_START].cammux_id);
+					ret = mtk_cam_sv_dev_config(
+						ctx, i - MTKCAM_SUBDEV_CAMSV_START, hw_scen,
+						(bDcif && (src_pad_idx == exp_no)) ?
+						2 : src_pad_idx - PAD_SRC_RAW0);
+					if (ret)
+						goto fail_img_buf_release;
+				}
+			}
+		} else if (mtk_cam_feature_is_time_shared(feature_active)) {
+			int used_pipes, src_pad_idx, hw_scen;
+
+			hw_scen = (1 << MTKCAM_IPI_HW_PATH_OFFLINE_M2M);
+			src_pad_idx = PAD_SRC_RAW0;
+			used_pipes = ctx->pipe->enabled_raw;
+			for (i = MTKCAM_SUBDEV_CAMSV_START ; i < MTKCAM_SUBDEV_CAMSV_END ; i++) {
+				if (used_pipes & (1 << i)) {
+					mtk_cam_call_seninf_set_pixelmode(ctx,
+									  ctx->seninf,
+									  src_pad_idx,
+									  tgo_pxl_mode);
+					mtk_cam_seninf_set_camtg(ctx->seninf, src_pad_idx,
+						cam->sv.pipelines[
+							i - MTKCAM_SUBDEV_CAMSV_START].cammux_id);
+					ret = mtk_cam_sv_dev_config(
+						ctx, i - MTKCAM_SUBDEV_CAMSV_START, hw_scen,
+						0);
+					if (ret)
+						goto fail_img_buf_release;
+					src_pad_idx++;
+					dev_info(cam->dev, "[TS] scen:0x%x/enabled_raw:0x%x/i(%d)",
+					hw_scen, ctx->pipe->enabled_raw, i);
+				}
+			}
+		} else if (mtk_cam_is_with_w_channel(ctx)) {
+			for (i = MTKCAM_SUBDEV_CAMSV_START ; i < MTKCAM_SUBDEV_CAMSV_END ; i++) {
+				if (ctx->pipe->enabled_raw & 1 << i) {
+					int hw_scen =
+						(1 << MTKCAM_SV_SPECIAL_SCENARIO_ADDITIONAL_RAW);
+
+					mtk_cam_call_seninf_set_pixelmode(ctx, ctx->seninf,
+						PAD_SRC_RAW_W0, tgo_pxl_mode);
+					mtk_cam_seninf_set_camtg(ctx->seninf, PAD_SRC_RAW_W0,
+						cam->sv.pipelines[
+							i - MTKCAM_SUBDEV_CAMSV_START].cammux_id);
+					dev_info(cam->dev,
+						"seninf_set_camtg(src_pad:%d/i:%d/camtg:%d)",
+						PAD_SRC_RAW_W0, i,
+						cam->sv.pipelines[
+							i - MTKCAM_SUBDEV_CAMSV_START].cammux_id);
+					ret = mtk_cam_sv_dev_config(ctx,
+							i - MTKCAM_SUBDEV_CAMSV_START,
+							hw_scen, 0);
+					if (ret)
+						goto fail_img_buf_release;
+					break;
+				}
+			}
+		}
+
+		/*set cam mux camtg and pixel mode*/
+		if (mtk_cam_feature_is_stagger(feature_active)) {
+			if (ctx->pipe->stagger_path == STAGGER_ON_THE_FLY) {
+				int seninf_pad;
+
+				if (mtk_cam_feature_is_2_exposure(feature_first_req))
+					seninf_pad = PAD_SRC_RAW1;
+				else if (mtk_cam_feature_is_3_exposure(feature_first_req))
+					seninf_pad = PAD_SRC_RAW2;
+				else
+					seninf_pad = PAD_SRC_RAW0;
+
+				/* todo: backend support one pixel mode only */
+				mtk_cam_call_seninf_set_pixelmode(ctx,
+								  ctx->seninf,
+								  seninf_pad,
+								  tgo_pxl_mode);
+				mtk_cam_seninf_set_camtg(ctx->seninf, seninf_pad,
+							PipeIDtoTGIDX(raw_dev->id));
+			}
+		} else if (!mtk_cam_feature_is_m2m(feature_active) &&
+					!mtk_cam_feature_is_time_shared(feature_active)) {
+			mtk_cam_call_seninf_set_pixelmode(ctx, ctx->seninf,
+							  PAD_SRC_RAW0,
+							  tgo_pxl_mode);
+			mtk_cam_seninf_set_camtg(ctx->seninf, PAD_SRC_RAW0,
+						 PipeIDtoTGIDX(raw_dev->id));
+		}
+	}
+
+	if (!mtk_cam_feature_is_m2m(feature_active)) {
+		for (i = 0 ; i < ctx->used_sv_num ; i++) {
+			/* use 8-pixel mode as default */
+			mtk_cam_call_seninf_set_pixelmode(ctx,
+							  ctx->seninf,
+							  ctx->sv_pipe[i]->seninf_padidx, 3);
+			mtk_cam_seninf_set_camtg(ctx->seninf,
+						 ctx->sv_pipe[i]->seninf_padidx,
+						 ctx->sv_pipe[i]->cammux_id);
+			ret = mtk_cam_sv_dev_config(ctx, i, 1, 0);
+			if (ret)
+				goto fail_img_buf_release;
+		}
+
+		ret = v4l2_subdev_call(ctx->seninf, video, s_stream, 1);
+		if (ret) {
+			dev_info(cam->dev, "failed to stream on seninf %s:%d\n",
+				 ctx->seninf->name, ret);
+			goto fail_img_buf_release;
+		}
+	} else {
+		ctx->processing_buffer_list.cnt = 0;
+		ctx->composed_buffer_list.cnt = 0;
+		dev_dbg(cam->dev, "[M2M] reset processing_buffer_list.cnt & composed_buffer_list.cnt\n");
+	}
+	if (ctx->used_raw_num) {
+		initialize(raw_dev, 0);
+		/* Stagger */
+		if (mtk_cam_feature_is_stagger(feature_first_req))
+			stagger_enable(raw_dev);
+		/* Sub sample */
+		if (mtk_cam_feature_is_subsample(feature_active))
+			subsample_enable(raw_dev);
+		/* Twin */
+		if (ctx->pipe->res_config.raw_num_used != 1) {
+			struct mtk_raw_device *raw_dev_sub =
+			get_sub_raw_dev(cam, ctx->pipe);
+			initialize(raw_dev_sub, 1);
+			if (ctx->pipe->res_config.raw_num_used == 3) {
+				struct mtk_raw_device *raw_dev_sub2 =
+					get_sub2_raw_dev(cam, ctx->pipe);
+				initialize(raw_dev_sub2, 1);
+			}
+		}
+	}
+	/* TODO */
+	spin_lock(&ctx->streaming_lock);
+	if (!cam->streaming_ctx && cam->debug_fs)
+		need_dump_mem = true;
+	else
+		dev_dbg(cam->dev,
+			"No need to alloc mem for ctx: streaming_ctx(0x%x), debug_fs(%p)\n",
+			cam->streaming_ctx, cam->debug_fs);
+	ctx->streaming = true;
+	cam->streaming_ctx |= 1 << ctx->stream_id;
+
+	spin_unlock(&ctx->streaming_lock);
+	if (need_dump_mem)
+		cam->debug_fs->ops->reinit(cam->debug_fs, ctx->stream_id);
+	ret = mtk_camsys_ctrl_start(ctx);
+	if (ret)
+		goto fail_streaming_off;
+
+	mutex_lock(&cam->queue_lock);
+	mtk_cam_dev_req_try_queue(cam);  /* request moved into working list */
+	mutex_unlock(&cam->queue_lock);
+	/* raw off, no cq done, so sv on after enque */
+	if (ctx->used_raw_num == 0) {
+		for (i = 0 ; i < ctx->used_sv_num ; i++) {
+			camsv_dev = get_camsv_dev(cam, ctx->sv_pipe[i]);
+			camsv_dev->is_enqueued = 1;
+			ret = mtk_cam_sv_dev_stream_on(ctx, i, 1, 1);
+			if (ret)
+				goto fail_sv_stream_off;
+		}
+	}
+
+	if (watchdog_scenario(ctx))
+		mtk_ctx_watchdog_start(ctx, 4);
+
+	dev_dbg(cam->dev, "streamed on camsys ctx:%d\n", ctx->stream_id);
+
+	if (raw_dev)
+		mtk_cam_register_iommu_tf_callback(raw_dev);
+
+	return 0;
+
+fail_sv_stream_off:
+	if (ctx->used_raw_num == 0) {
+		for (i = 0 ; i < ctx->used_sv_num ; i++) {
+			camsv_dev = get_camsv_dev(cam, ctx->sv_pipe[i]);
+			camsv_dev->is_enqueued = 0;
+			ret = mtk_cam_sv_dev_stream_on(ctx, i, 0, 1);
+			if (ret)
+				dev_info(cam->dev,
+					 "%s:failed to stream off camsv(%d)\n",
+					 __func__, i);
+		}
+	}
+	mtk_camsys_ctrl_stop(ctx);
+fail_streaming_off:
+	spin_lock(&ctx->streaming_lock);
+	ctx->streaming = false;
+	cam->streaming_ctx &= ~(1 << ctx->stream_id);
+	spin_unlock(&ctx->streaming_lock);
+	if (!mtk_cam_is_m2m(ctx))
+		v4l2_subdev_call(ctx->seninf, video, s_stream, 0);
+fail_img_buf_release:
+	if (ctx->img_buf_pool.working_img_buf_size > 0)
+		mtk_cam_img_working_buf_pool_release(ctx, mem_dev);
+fail_pipe_off:
+	for (i = 0; i < MAX_PIPES_PER_STREAM && ctx->pipe_subdevs[i]; i++)
+		v4l2_subdev_call(ctx->pipe_subdevs[i], video, s_stream, 0);
+
+	return ret;
+}
+
+static int mtk_cam_ts_are_all_ctx_off(struct mtk_cam_device *cam,
+			struct mtk_cam_ctx *ctx)
+{
+	struct mtk_raw_pipeline *pipe_chk, *pipe;
+	struct mtk_cam_ctx *ctx_chk;
+	int i;
+	int ts_id, ts_id_chk;
+	int ret = true;
+
+	for (i = 0;  i < cam->max_stream_num; i++) {
+		ctx_chk = cam->ctxs + i;
+		if (ctx_chk == ctx)
+			continue;
+		if (ctx_chk->pipe) {
+			pipe = ctx->pipe;
+			ts_id = pipe->feature_active &
+					MTK_CAM_FEATURE_TIMESHARE_MASK;
+			pipe_chk = ctx_chk->pipe;
+			ts_id_chk = pipe_chk->feature_active &
+					MTK_CAM_FEATURE_TIMESHARE_MASK;
+			dev_info(cam->dev, "[%s] i:%d pipe/ts:%d/0x%x chk_pipe/ts:%d/0x%x\n",
+				__func__, i, pipe->id, ts_id, pipe_chk->id, ts_id_chk);
+			if (ts_id == ts_id_chk) {
+				if (ctx_chk->streaming)
+					ret = false;
+			}
+		}
+	}
+
+	return ret;
+}
+
+int mtk_cam_ctx_stream_off(struct mtk_cam_ctx *ctx, struct mtk_cam_video_device *node)
+{
+	struct mtk_cam_device *cam = ctx->cam;
+	struct device *dev;
+	struct mtk_raw_device *raw_dev;
+	unsigned int i, enabled_sv = 0;
+	int ret;
+	int feature = 0;
+
+	if (!ctx->streaming) {
+		dev_info(cam->dev, "ctx-%d is already streaming off\n",
+			ctx->stream_id);
+		return 0;
+	}
+
+	if (ctx->pipe)
+		feature = ctx->pipe->feature_active;
+
+	if (watchdog_scenario(ctx))
+		mtk_ctx_watchdog_stop(ctx);
+
+	dev_info(cam->dev, "%s: ctx-%d:  composer_cnt:%d, streaming_pipe:0x%x\n",
+		__func__, ctx->stream_id, cam->composer_cnt, ctx->streaming_pipe);
+
+	spin_lock(&ctx->streaming_lock);
+	ctx->streaming = false;
+	cam->streaming_ctx &= ~(1 << ctx->stream_id);
+	spin_unlock(&ctx->streaming_lock);
+
+	if (ctx->synced) {
+		/* after streaming being off, no one can do V4L2_CID_FRAME_SYNC */
+		struct v4l2_ctrl *ctrl;
+
+		ctrl = v4l2_ctrl_find(ctx->sensor->ctrl_handler,
+				      V4L2_CID_FRAME_SYNC);
+		if (ctrl) {
+			v4l2_ctrl_s_ctrl(ctrl, 0);
+			dev_info(cam->dev,
+				 "%s: ctx(%d): apply V4L2_CID_FRAME_SYNC(0)\n",
+				 __func__, ctx->stream_id);
+		} else {
+			dev_info(cam->dev,
+				 "%s: ctx(%d): failed to find V4L2_CID_FRAME_SYNC\n",
+				 __func__, ctx->stream_id);
+		}
+		ctx->synced = 0;
+	}
+
+	if (!mtk_cam_feature_is_m2m(feature)) {
+		ret = v4l2_subdev_call(ctx->seninf, video, s_stream, 0);
+		if (ret) {
+			dev_info(cam->dev, "failed to stream off %s:%d\n",
+				 ctx->seninf->name, ret);
+			return -EPERM;
+		}
+	}
+
+	if (ctx->used_raw_num) {
+		dev = mtk_cam_find_raw_dev(cam, ctx->used_raw_dev);
+		if (!dev) {
+			dev_info(cam->dev, "streamoff raw device not found\n");
+			goto fail_stream_off;
+		}
+		raw_dev = dev_get_drvdata(dev);
+		if (mtk_cam_feature_is_time_shared(feature)) {
+			unsigned int hw_scen =
+				(1 << MTKCAM_IPI_HW_PATH_OFFLINE_M2M);
+			for (i = MTKCAM_SUBDEV_CAMSV_START ; i < MTKCAM_SUBDEV_CAMSV_END ; i++) {
+				if (ctx->pipe->enabled_raw & (1 << i)) {
+					mtk_cam_sv_dev_stream_on(
+						ctx, i - MTKCAM_SUBDEV_CAMSV_START, 0, hw_scen);
+					cam->sv.pipelines[
+						i - MTKCAM_SUBDEV_CAMSV_START].is_occupied = 0;
+					ctx->pipe->enabled_raw &= ~(1 << i);
+					enabled_sv |= (1 << i);
+				}
+			}
+			if (mtk_cam_ts_are_all_ctx_off(cam, ctx))
+				stream_on(raw_dev, 0);
+		} else {
+			stream_on(raw_dev, 0);
+		}
+		/* Twin */
+		if (ctx->pipe->res_config.raw_num_used != 1) {
+			struct mtk_raw_device *raw_dev_sub =
+						get_sub_raw_dev(cam, ctx->pipe);
+			stream_on(raw_dev_sub, 0);
+			if (ctx->pipe->res_config.raw_num_used == 3) {
+				struct mtk_raw_device *raw_dev_sub2 =
+					get_sub2_raw_dev(cam, ctx->pipe);
+				stream_on(raw_dev_sub2, 0);
+			}
+		}
+	}
+	for (i = 0 ; i < ctx->used_sv_num ; i++) {
+		ret = mtk_cam_sv_dev_stream_on(ctx, i, 0, 1);
+		if (ret)
+			return ret;
+	}
+	if (mtk_cam_feature_is_stagger(feature)) {
+		unsigned int hw_scen = mtk_raw_get_hdr_scen_id(ctx);
+
+		for (i = MTKCAM_SUBDEV_CAMSV_START; i < MTKCAM_SUBDEV_CAMSV_END; i++) {
+			if (ctx->pipe->enabled_raw & (1 << i)) {
+				mtk_cam_sv_dev_stream_on(
+					ctx, i - MTKCAM_SUBDEV_CAMSV_START, 0, hw_scen);
+				cam->sv.pipelines[i - MTKCAM_SUBDEV_CAMSV_START].is_occupied = 0;
+				ctx->pipe->enabled_raw &= ~(1 << i);
+				enabled_sv |= (1 << i);
+			}
+		}
+	} else if (mtk_cam_is_with_w_channel(ctx)) {
+		unsigned int hw_scen = (1 << MTKCAM_SV_SPECIAL_SCENARIO_ADDITIONAL_RAW);
+
+		for (i = MTKCAM_SUBDEV_CAMSV_START ; i < MTKCAM_SUBDEV_CAMSV_END ; i++) {
+			if (ctx->pipe->enabled_raw & (1 << i)) {
+				mtk_cam_sv_dev_stream_on(
+					ctx, i - MTKCAM_SUBDEV_CAMSV_START, 0, hw_scen);
+				cam->sv.pipelines[i - MTKCAM_SUBDEV_CAMSV_START].is_occupied = 0;
+				ctx->pipe->enabled_raw &= ~(1 << i);
+				enabled_sv |= (1 << i);
+			}
+		}
+	}
+	for (i = 0; i < MAX_PIPES_PER_STREAM && ctx->pipe_subdevs[i]; i++) {
+		ret = v4l2_subdev_call(ctx->pipe_subdevs[i], video,
+				       s_stream, 0);
+		if (ret) {
+			dev_info(cam->dev, "failed to stream off %s: %d\n",
+				ctx->pipe_subdevs[i]->name, ret);
+			return -EPERM;
+		}
+	}
+
+	if (ctx->img_buf_pool.working_img_buf_size > 0) {
+		if (node->uid.pipe_id >= MTKCAM_SUBDEV_CAMSV_START &&
+			node->uid.pipe_id < MTKCAM_SUBDEV_CAMSV_END) {
+			switch (node->uid.pipe_id) {
+			case MTKCAM_SUBDEV_CAMSV_0:
+			case MTKCAM_SUBDEV_CAMSV_1:
+			case MTKCAM_SUBDEV_CAMSV_4:
+#ifdef ISP7_1
+			case MTKCAM_SUBDEV_CAMSV_5:
+#endif
+				dev = find_larb(&cam->larb, 13);
+				break;
+			default:
+				dev = find_larb(&cam->larb, 14);
+				break;
+			}
+		} else {
+			switch (node->desc.id) {
+			case MTK_RAW_YUVO_1_OUT:
+			case MTK_RAW_YUVO_2_OUT:
+			case MTK_RAW_YUVO_3_OUT:
+			case MTK_RAW_YUVO_4_OUT:
+			case MTK_RAW_YUVO_5_OUT:
+			case MTK_RAW_DRZS4NO_1_OUT:
+			case MTK_RAW_DRZS4NO_2_OUT:
+			case MTK_RAW_DRZS4NO_3_OUT:
+			case MTK_RAW_RZH1N2TO_1_OUT:
+			case MTK_RAW_RZH1N2TO_2_OUT:
+			case MTK_RAW_RZH1N2TO_3_OUT:
+				/* should have a better implementation here */
+				dev = cam->raw.yuvs[0];
+				break;
+			default:
+				dev = cam->raw.devs[0];
+				break;
+			}
+		}
+		mtk_cam_img_working_buf_pool_release(ctx, dev);
+	}
+
+	mtk_camsys_ctrl_stop(ctx);
+
+fail_stream_off:
+	if (ctx->used_raw_num)
+		isp_composer_destroy_session(ctx);
+
+	dev_dbg(cam->dev, "streamed off camsys ctx:%d\n", ctx->stream_id);
+
+	return 0;
+}
+
+static int config_bridge_pad_links(struct mtk_cam_device *cam,
+				   struct v4l2_subdev *seninf)
+{
+	struct media_entity *pipe_entity;
+	unsigned int i, j;
+	int ret;
+
+	for (i = 0; i < cam->max_stream_num; i++) {
+		if (i >= MTKCAM_SUBDEV_RAW_START &&
+			i < (MTKCAM_SUBDEV_RAW_START + cam->num_raw_devices)) {
+			pipe_entity = &cam->raw.pipelines[i].subdev.entity;
+
+			dev_info(cam->dev, "create pad link %s %s\n",
+				seninf->entity.name, pipe_entity->name);
+
+			ret = media_create_pad_link(&seninf->entity,
+					MTK_CAM_CIO_PAD_SRC,
+					pipe_entity,
+					MTK_CAM_CIO_PAD_SINK,
+					MEDIA_LNK_FL_DYNAMIC);
+
+			if (ret) {
+				dev_dbg(cam->dev,
+					"failed to create pad link %s %s err:%d\n",
+					seninf->entity.name, pipe_entity->name,
+					ret);
+				return ret;
+			}
+		} else if (i >= MTKCAM_SUBDEV_CAMSV_START && i < MTKCAM_SUBDEV_CAMSV_END) {
+			pipe_entity = &cam->sv.pipelines[i-MTKCAM_SUBDEV_CAMSV_START].subdev.entity;
+
+			dev_info(cam->dev, "create pad link %s %s\n",
+				seninf->entity.name, pipe_entity->name);
+
+			ret = media_create_pad_link(&seninf->entity,
+					PAD_SRC_RAW0,
+					pipe_entity,
+					MTK_CAMSV_SINK,
+					MEDIA_LNK_FL_DYNAMIC);
+
+			if (ret) {
+				dev_dbg(cam->dev,
+					"failed to create pad link %s %s err:%d\n",
+					seninf->entity.name, pipe_entity->name,
+					ret);
+				return ret;
+			}
+
+			for (j = PAD_SRC_PDAF0; j <= PAD_SRC_PDAF5; j++) {
+				ret = media_create_pad_link(&seninf->entity, j,
+							pipe_entity,
+							MTK_CAMSV_SINK,
+							MEDIA_LNK_FL_DYNAMIC);
+
+				if (ret) {
+					dev_dbg(cam->dev,
+						"failed to create pad link %s %s err:%d\n",
+						seninf->entity.name, pipe_entity->name,
+						ret);
+					return ret;
+				}
+			}
+		}
+	}
+
+	return 0;
+}
+
+static int mtk_cam_create_links(struct mtk_cam_device *cam)
+{
+	struct v4l2_subdev *sd;
+	unsigned int i;
+	int ret;
+
+	i = 0;
+	v4l2_device_for_each_subdev(sd, &cam->v4l2_dev) {
+		if (i < cam->num_seninf_devices &&
+		    sd->entity.function == MEDIA_ENT_F_VID_IF_BRIDGE) {
+			ret = config_bridge_pad_links(cam, sd);
+			i++;
+		}
+	}
+
+	return ret;
+}
+
+static int mtk_cam_master_bind(struct device *dev)
+{
+	struct mtk_cam_device *cam_dev = dev_get_drvdata(dev);
+	struct media_device *media_dev = &cam_dev->media_dev;
+	int ret;
+
+	dev_info(dev, "%s\n", __func__);
+
+	media_dev->dev = cam_dev->dev;
+	strscpy(media_dev->model, dev_driver_string(dev),
+		sizeof(media_dev->model));
+	snprintf(media_dev->bus_info, sizeof(media_dev->bus_info),
+		 "platform:%s", dev_name(dev));
+	media_dev->hw_revision = 0;
+	media_dev->ops = &mtk_cam_dev_ops;
+	media_device_init(media_dev);
+
+	cam_dev->v4l2_dev.mdev = media_dev;
+	ret = v4l2_device_register(cam_dev->dev, &cam_dev->v4l2_dev);
+	if (ret) {
+		dev_dbg(dev, "Failed to register V4L2 device: %d\n", ret);
+		goto fail_media_device_cleanup;
+	}
+
+	ret = media_device_register(media_dev);
+	if (ret) {
+		dev_dbg(dev, "Failed to register media device: %d\n",
+			ret);
+		goto fail_v4l2_device_unreg;
+	}
+
+	ret = component_bind_all(dev, cam_dev);
+	if (ret) {
+		dev_dbg(dev, "Failed to bind all component: %d\n", ret);
+		goto fail_media_device_unreg;
+	}
+
+	ret = mtk_raw_setup_dependencies(&cam_dev->raw);
+	if (ret) {
+		dev_dbg(dev, "Failed to mtk_raw_setup_dependencies: %d\n", ret);
+		goto fail_unbind_all;
+	}
+
+	ret = mtk_camsv_setup_dependencies(&cam_dev->sv, &cam_dev->larb);
+	if (ret) {
+		dev_dbg(dev, "Failed to mtk_camsv_setup_dependencies: %d\n", ret);
+		goto fail_remove_dependencies;
+	}
+	ret = mtk_raw_register_entities(&cam_dev->raw, &cam_dev->v4l2_dev);
+	if (ret) {
+		dev_dbg(dev, "Failed to init raw subdevs: %d\n", ret);
+		goto fail_remove_dependencies;
+	}
+
+	ret = mtk_camsv_register_entities(&cam_dev->sv, &cam_dev->v4l2_dev);
+	if (ret) {
+		dev_dbg(dev, "Failed to init camsv subdevs: %d\n", ret);
+		goto fail_unreg_raw_entities;
+	}
+	mtk_cam_create_links(cam_dev);
+	/* Expose all subdev's nodes */
+	ret = v4l2_device_register_subdev_nodes(&cam_dev->v4l2_dev);
+	if (ret) {
+		dev_dbg(dev, "Failed to register subdev nodes\n");
+		goto fail_unreg_camsv_entities;
+	}
+
+	dev_info(dev, "%s success\n", __func__);
+	return 0;
+
+fail_unreg_camsv_entities:
+	mtk_camsv_unregister_entities(&cam_dev->sv);
+
+fail_unreg_raw_entities:
+	mtk_raw_unregister_entities(&cam_dev->raw);
+
+fail_remove_dependencies:
+	/* nothing to do for now */
+
+fail_unbind_all:
+	component_unbind_all(dev, cam_dev);
+
+fail_media_device_unreg:
+	media_device_unregister(&cam_dev->media_dev);
+
+fail_v4l2_device_unreg:
+	v4l2_device_unregister(&cam_dev->v4l2_dev);
+
+fail_media_device_cleanup:
+	media_device_cleanup(&cam_dev->media_dev);
+
+	return ret;
+}
+
+static void mtk_cam_master_unbind(struct device *dev)
+{
+	struct mtk_cam_device *cam_dev = dev_get_drvdata(dev);
+
+	dev_info(dev, "%s\n", __func__);
+
+	mtk_raw_unregister_entities(&cam_dev->raw);
+	mtk_camsv_unregister_entities(&cam_dev->sv);
+	component_unbind_all(dev, cam_dev);
+
+	media_device_unregister(&cam_dev->media_dev);
+	v4l2_device_unregister(&cam_dev->v4l2_dev);
+	media_device_cleanup(&cam_dev->media_dev);
+}
+
+static int compare_dev(struct device *dev, void *data)
+{
+	return dev == (struct device *)data;
+}
+
+static void mtk_cam_match_remove(struct device *dev)
+{
+	(void) dev;
+}
+
+static int add_match_by_driver(struct device *dev,
+			       struct component_match **match,
+			       struct platform_driver *drv)
+{
+	struct device *p = NULL, *d;
+	int num = 0;
+
+	do {
+		d = platform_find_device_by_driver(p, &drv->driver);
+		put_device(p);
+		p = d;
+		if (!d)
+			break;
+
+		component_match_add(dev, match, compare_dev, d);
+		num++;
+	} while (true);
+
+	return num;
+}
+
+static struct component_match *mtk_cam_match_add(struct device *dev)
+{
+	struct mtk_cam_device *cam_dev = dev_get_drvdata(dev);
+	struct component_match *match = NULL;
+	int yuv_num;
+
+	cam_dev->num_raw_devices =
+		add_match_by_driver(dev, &match, &mtk_cam_raw_driver);
+
+	yuv_num = add_match_by_driver(dev, &match, &mtk_cam_yuv_driver);
+
+	cam_dev->num_larb_devices =
+		add_match_by_driver(dev, &match, &mtk_cam_larb_driver);
+
+	cam_dev->num_camsv_devices =
+		add_match_by_driver(dev, &match, &mtk_cam_sv_driver);
+
+	cam_dev->num_seninf_devices =
+		add_match_by_driver(dev, &match, &seninf_pdrv);
+
+	if (IS_ERR(match))
+		mtk_cam_match_remove(dev);
+
+	dev_info(dev, "#: raw %d, yuv %d, larb %d, sv %d, seninf %d\n",
+		 cam_dev->num_raw_devices, yuv_num,
+		 cam_dev->num_larb_devices,
+		 cam_dev->num_camsv_devices,
+		 cam_dev->num_seninf_devices);
+
+	return match ? match : ERR_PTR(-ENODEV);
+}
+
+static const struct component_master_ops mtk_cam_master_ops = {
+	.bind = mtk_cam_master_bind,
+	.unbind = mtk_cam_master_unbind,
+};
+
+static void mtk_cam_ctx_watchdog_worker(struct work_struct *work)
+{
+	struct mtk_cam_ctx *ctx;
+	struct v4l2_subdev *seninf;
+	struct mtk_raw_device *raw;
+	u64 watchdog_cnt;
+	int timeout;
+	static u64 last_vsync_count;
+	bool is_abnormal_vsync = false;
+
+	ctx = container_of(work, struct mtk_cam_ctx, watchdog_work);
+	seninf = ctx->seninf;
+	if (!seninf) {
+		dev_info(ctx->cam->dev,
+			 "%s:ctx(%d):stop watchdog task for no seninf\n",
+			 __func__, ctx->stream_id);
+		return;
+	}
+	raw = get_main_raw_dev(ctx->cam, ctx->pipe);
+	watchdog_cnt = atomic_read(&ctx->watchdog_cnt);
+	timeout = mtk_cam_seninf_check_timeout(seninf,
+		watchdog_cnt * MTK_CAM_CTX_WATCHDOG_INTERVAL * 1000000);
+	if (last_vsync_count == raw->vsync_count)
+		is_abnormal_vsync = true;
+	last_vsync_count = raw->vsync_count;
+	/**
+	 * Current we just call seninf dump, but it is better to check
+	 * and restart the stream in the future.
+	 */
+	if (atomic_read(&ctx->watchdog_dumped)) {
+		dev_info(ctx->cam->dev,
+			 "%s:ctx(%d):skip redundant seninf dump for no sof\n",
+			 __func__, ctx->stream_id);
+	} else {
+		if (timeout) {
+			dev_info(ctx->cam->dev, "%s:ctx(%d): timeout, VF(%d) vsync count(%lld) sof count(%lld) start dump (%lldx100ms)\n",
+				__func__, ctx->stream_id, atomic_read(&raw->vf_en),
+				raw->vsync_count, raw->sof_count, watchdog_cnt);
+			if (is_abnormal_vsync)
+				dev_info(ctx->cam->dev, "%s:abnormal vsync\n", __func__);
+			atomic_set(&ctx->watchdog_dumped, 1); // fixme
+			atomic_set(&ctx->watchdog_cnt, 0);
+			mtk_cam_seninf_dump(seninf);
+			atomic_set(&ctx->watchdog_cnt, 0);
+			atomic_inc(&ctx->watchdog_dump_cnt);
+			atomic_set(&ctx->watchdog_dumped, 0);
+		} else {
+			dev_info(ctx->cam->dev, "%s:ctx(%d): not timeout, for long exp (%lldx100ms)\n",
+				__func__, ctx->stream_id, watchdog_cnt);
+		}
+	}
+}
+
+static void mtk_ctx_watchdog(struct timer_list *t)
+{
+	struct mtk_cam_ctx *ctx = from_timer(ctx, t, watchdog_timer);
+	struct mtk_raw_device *raw;
+	int watchdog_cnt;
+	int watchdog_dump_cnt;
+
+	if (!ctx->streaming)
+		return;
+
+	raw = get_main_raw_dev(ctx->cam, ctx->pipe);
+	if (!raw) {
+		dev_info(ctx->cam->dev,
+			 "%s:ctx(%d):stop watchdog task for no raw ctx\n",
+			 __func__, ctx->stream_id);
+		return;
+	}
+
+	watchdog_cnt = atomic_inc_return(&ctx->watchdog_cnt);
+	watchdog_dump_cnt = atomic_read(&ctx->watchdog_dump_cnt);
+
+	if (atomic_read(&ctx->watchdog_dumped)) {
+		dev_dbg(ctx->cam->dev,
+			 "%s:ctx(%d):skip watchdog worker (worker is ongoing)\n",
+			 __func__, ctx->stream_id);
+	} else if (watchdog_cnt >= atomic_read(&ctx->watchdog_timeout_cnt)) {
+		/**
+		 * No raw's sof interrupts were generated by hw for the
+		 * Nth time of running the watchdog timer.
+		 */
+		if (watchdog_dump_cnt < 4) {
+			dev_info_ratelimited(ctx->cam->dev, "%s:ctx(%d): timeout! VF(%d) vsync count(%lld) sof count(%lld) watcgdog_cnt(%d)(+%dms)\n",
+				__func__, ctx->stream_id, atomic_read(&raw->vf_en),
+				raw->vsync_count, raw->sof_count, watchdog_cnt,
+				watchdog_cnt * MTK_CAM_CTX_WATCHDOG_INTERVAL);
+
+			schedule_work(&ctx->watchdog_work);
+		} else {
+			dev_info_ratelimited(ctx->cam->dev, "%s:ctx(%d): dump > 3! watchdog_dump_cnt(%d)(+%dms)\n",
+				__func__, ctx->stream_id, watchdog_dump_cnt,
+				watchdog_cnt * MTK_CAM_CTX_WATCHDOG_INTERVAL);
+		}
+	}
+
+	ctx->watchdog_timer.expires = jiffies +
+				msecs_to_jiffies(MTK_CAM_CTX_WATCHDOG_INTERVAL);
+	dev_dbg(ctx->cam->dev, "%s:check ctx(%d): dog_cnt(%d), dog_time:%dms\n",
+				__func__, ctx->stream_id, watchdog_cnt,
+				watchdog_cnt * MTK_CAM_CTX_WATCHDOG_INTERVAL);
+	add_timer(&ctx->watchdog_timer);
+}
+
+void mtk_ctx_watchdog_kick(struct mtk_cam_ctx *ctx)
+{
+	dev_dbg(ctx->cam->dev, "%s:ctx(%d): watchdog_cnt(%d)\n",
+		__func__, ctx->stream_id, atomic_read(&ctx->watchdog_cnt));
+	atomic_set(&ctx->watchdog_cnt, 0);
+	atomic_set(&ctx->watchdog_dump_cnt, 0);
+}
+
+static void mtk_ctx_watchdog_init(struct mtk_cam_ctx *ctx)
+{
+	INIT_WORK(&ctx->watchdog_work, mtk_cam_ctx_watchdog_worker);
+	timer_setup(&ctx->watchdog_timer, mtk_ctx_watchdog, 0);
+}
+
+void mtk_ctx_watchdog_start(struct mtk_cam_ctx *ctx, int timeout_cnt)
+{
+	dev_info(ctx->cam->dev, "%s:ctx(%d):start the watchdog, timeout setting(%d)\n",
+		__func__, ctx->stream_id, MTK_CAM_CTX_WATCHDOG_INTERVAL * timeout_cnt);
+
+	atomic_set(&ctx->watchdog_timeout_cnt, timeout_cnt);
+	atomic_set(&ctx->watchdog_cnt, 0);
+	atomic_set(&ctx->watchdog_dumped, 0);
+	atomic_set(&ctx->watchdog_dump_cnt, 0);
+	ctx->watchdog_timer.expires = jiffies +
+				msecs_to_jiffies(MTK_CAM_CTX_WATCHDOG_INTERVAL);
+	add_timer(&ctx->watchdog_timer);
+}
+
+void mtk_ctx_watchdog_stop(struct mtk_cam_ctx *ctx)
+{
+	dev_info(ctx->cam->dev, "%s:ctx(%d):stop the watchdog\n",
+		__func__, ctx->stream_id);
+	del_timer_sync(&ctx->watchdog_timer);
+}
+
+static void mtk_cam_ctx_init(struct mtk_cam_ctx *ctx,
+			     struct mtk_cam_device *cam,
+			     unsigned int stream_id)
+{
+	unsigned int i;
+
+	ctx->cam = cam;
+	ctx->stream_id = stream_id;
+	ctx->sensor = NULL;
+	ctx->prev_sensor = NULL;
+	ctx->prev_seninf = NULL;
+
+	ctx->streaming_pipe = 0;
+	ctx->streaming_node_cnt = 0;
+
+	ctx->used_raw_num = 0;
+	ctx->used_raw_dev = 0;
+	ctx->processing_buffer_list.cnt = 0;
+	ctx->composed_buffer_list.cnt = 0;
+	ctx->is_first_cq_done = 0;
+	ctx->cq_done_status = 0;
+	ctx->session_created = 0;
+
+	ctx->used_sv_num = 0;
+	for (i = 0 ; i < MAX_SV_PIPES_PER_STREAM ; i++) {
+		ctx->sv_pipe[i] = NULL;
+		ctx->used_sv_dev[i] = 0;
+		ctx->sv_dequeued_frame_seq_no[i] = 0;
+		ctx->sv_using_buffer_list[i].cnt = 0;
+		ctx->sv_processing_buffer_list[i].cnt = 0;
+	}
+	INIT_LIST_HEAD(&ctx->using_buffer_list.list);
+	INIT_LIST_HEAD(&ctx->composed_buffer_list.list);
+	INIT_LIST_HEAD(&ctx->processing_buffer_list.list);
+	for (i = 0; i < MAX_SV_PIPES_PER_STREAM; i++) {
+		INIT_LIST_HEAD(&ctx->sv_using_buffer_list[i].list);
+		INIT_LIST_HEAD(&ctx->sv_processing_buffer_list[i].list);
+	}
+	INIT_LIST_HEAD(&ctx->processing_img_buffer_list.list);
+	spin_lock_init(&ctx->using_buffer_list.lock);
+	spin_lock_init(&ctx->composed_buffer_list.lock);
+	spin_lock_init(&ctx->processing_buffer_list.lock);
+	for (i = 0; i < MAX_SV_PIPES_PER_STREAM; i++) {
+		spin_lock_init(&ctx->sv_using_buffer_list[i].lock);
+		spin_lock_init(&ctx->sv_processing_buffer_list[i].lock);
+	}
+	spin_lock_init(&ctx->streaming_lock);
+	spin_lock_init(&ctx->first_cq_lock);
+	spin_lock_init(&ctx->processing_img_buffer_list.lock);
+
+	mtk_ctx_watchdog_init(ctx);
+}
+
+static int mtk_cam_v4l2_subdev_link_validate(struct v4l2_subdev *sd,
+				      struct media_link *link,
+				      struct v4l2_subdev_format *source_fmt,
+				      struct v4l2_subdev_format *sink_fmt)
+{
+	bool pass = true;
+
+	/* The width, height and code must match. */
+	if (source_fmt->format.width != sink_fmt->format.width) {
+		dev_dbg(sd->entity.graph_obj.mdev->dev,
+			"%s: width does not match (source %u, sink %u)\n",
+			__func__,
+			source_fmt->format.width, sink_fmt->format.width);
+		pass = false;
+	}
+
+	if (source_fmt->format.height != sink_fmt->format.height) {
+		dev_dbg(sd->entity.graph_obj.mdev->dev,
+			"%s: height does not match (source %u, sink %u)\n",
+			__func__,
+			source_fmt->format.height, sink_fmt->format.height);
+		pass = false;
+	}
+
+	if (source_fmt->format.code != sink_fmt->format.code) {
+		dev_info(sd->entity.graph_obj.mdev->dev,
+			"%s: warn: media bus code does not match (source 0x%8.8x, sink 0x%8.8x)\n",
+			__func__,
+			source_fmt->format.code, sink_fmt->format.code);
+		pass = false;
+	}
+
+	if (pass)
+		return 0;
+
+	dev_dbg(sd->entity.graph_obj.mdev->dev,
+		"%s: link was \"%s\":%u -> \"%s\":%u\n", __func__,
+		link->source->entity->name, link->source->index,
+		link->sink->entity->name, link->sink->index);
+
+	return -EPIPE;
+}
+
+int mtk_cam_link_validate(struct v4l2_subdev *sd,
+			  struct media_link *link,
+			  struct v4l2_subdev_format *source_fmt,
+			  struct v4l2_subdev_format *sink_fmt)
+{
+	struct device *dev;
+	int ret = 0;
+
+	dev = sd->v4l2_dev->dev;
+
+	ret = mtk_cam_v4l2_subdev_link_validate(sd, link, source_fmt, sink_fmt);
+	if (ret)
+		dev_info(dev, "%s: link validate failed pad/code/w/h: SRC(%d/0x%x/%d/%d), SINK(%d:0x%x/%d/%d)\n",
+			 sd->name, source_fmt->pad, source_fmt->format.code,
+			 source_fmt->format.width, source_fmt->format.height,
+			 sink_fmt->pad, sink_fmt->format.code,
+			 sink_fmt->format.width, sink_fmt->format.height);
+
+	return ret;
+}
+
+static int mtk_cam_debug_fs_init(struct mtk_cam_device *cam)
+{
+	/**
+	 * The dump buffer size depdends on the meta buffer size
+	 * which is variable among devices using different type of sensors
+	 * , e.g. PD's statistic buffers.
+	 */
+	int dump_mem_size = MTK_CAM_DEBUG_DUMP_HEADER_MAX_SIZE +
+			    CQ_BUF_SIZE +
+			    mtk_cam_get_meta_size(MTKCAM_IPI_RAW_META_STATS_CFG) +
+			    RAW_STATS_CFG_VARIOUS_SIZE +
+			    sizeof(struct mtkcam_ipi_frame_param) +
+			    sizeof(struct mtkcam_ipi_config_param) *
+			    RAW_PIPELINE_NUM;
+
+	cam->debug_fs = mtk_cam_get_debugfs();
+	if (!cam->debug_fs)
+		return 0;
+
+	cam->debug_fs->ops->init(cam->debug_fs, cam, dump_mem_size);
+	cam->debug_wq = alloc_ordered_workqueue(dev_name(cam->dev),
+						__WQ_LEGACY | WQ_MEM_RECLAIM |
+						WQ_FREEZABLE);
+	cam->debug_exception_wq = alloc_ordered_workqueue(dev_name(cam->dev),
+						__WQ_LEGACY | WQ_MEM_RECLAIM |
+						WQ_FREEZABLE);
+	init_waitqueue_head(&cam->debug_exception_waitq);
+
+	if (!cam->debug_wq || !cam->debug_exception_wq)
+		return -EINVAL;
+
+	return 0;
+}
+
+static void mtk_cam_debug_fs_deinit(struct mtk_cam_device *cam)
+{
+
+	drain_workqueue(cam->debug_wq);
+	destroy_workqueue(cam->debug_wq);
+	drain_workqueue(cam->debug_exception_wq);
+	destroy_workqueue(cam->debug_exception_wq);
+
+	if (cam->debug_fs)
+		cam->debug_fs->ops->deinit(cam->debug_fs);
+}
+
+static int register_sub_drivers(struct device *dev)
+{
+	struct component_match *match = NULL;
+	int ret;
+
+	ret = platform_driver_register(&mtk_cam_larb_driver);
+	if (ret) {
+		dev_info(dev, "%s mtk_cam_larb_driver fail\n", __func__);
+		goto REGISTER_LARB_FAIL;
+	}
+
+	ret = platform_driver_register(&seninf_pdrv);
+	if (ret) {
+		dev_info(dev, "%s seninf_pdrv fail\n", __func__);
+		goto REGISTER_SENINF_FAIL;
+	}
+
+	ret = platform_driver_register(&seninf_core_pdrv);
+	if (ret) {
+		dev_info(dev, "%s seninf_core_pdrv fail\n", __func__);
+		goto REGISTER_SENINF_CORE_FAIL;
+	}
+
+	ret = platform_driver_register(&mtk_cam_sv_driver);
+	if (ret) {
+		dev_info(dev, "%s mtk_cam_sv_driver fail\n", __func__);
+		goto REGISTER_CAMSV_FAIL;
+	}
+	ret = platform_driver_register(&mtk_cam_raw_driver);
+	if (ret) {
+		dev_info(dev, "%s mtk_cam_raw_driver fail\n", __func__);
+		goto REGISTER_RAW_FAIL;
+	}
+
+	ret = platform_driver_register(&mtk_cam_yuv_driver);
+	if (ret) {
+		dev_info(dev, "%s mtk_cam_raw_driver fail\n", __func__);
+		goto REGISTER_YUV_FAIL;
+	}
+
+	match = mtk_cam_match_add(dev);
+	if (IS_ERR(match)) {
+		ret = PTR_ERR(match);
+		goto ADD_MATCH_FAIL;
+	}
+
+	ret = component_master_add_with_match(dev, &mtk_cam_master_ops, match);
+	if (ret < 0)
+		goto MASTER_ADD_MATCH_FAIL;
+
+	return 0;
+
+MASTER_ADD_MATCH_FAIL:
+	mtk_cam_match_remove(dev);
+
+ADD_MATCH_FAIL:
+	platform_driver_unregister(&mtk_cam_yuv_driver);
+
+REGISTER_YUV_FAIL:
+	platform_driver_unregister(&mtk_cam_raw_driver);
+
+REGISTER_RAW_FAIL:
+	platform_driver_unregister(&mtk_cam_sv_driver);
+
+REGISTER_CAMSV_FAIL:
+	platform_driver_unregister(&seninf_core_pdrv);
+
+REGISTER_SENINF_CORE_FAIL:
+	platform_driver_unregister(&seninf_pdrv);
+
+REGISTER_SENINF_FAIL:
+	platform_driver_unregister(&mtk_cam_larb_driver);
+
+REGISTER_LARB_FAIL:
+	return ret;
+}
+
+static int mtk_cam_probe(struct platform_device *pdev)
+{
+	struct mtk_cam_device *cam_dev;
+	struct device *dev = &pdev->dev;
+	struct resource *res;
+	int ret;
+	unsigned int i;
+
+	dev_info(dev, "%s\n", __func__);
+
+	/* initialize structure */
+	cam_dev = devm_kzalloc(dev, sizeof(*cam_dev), GFP_KERNEL);
+	if (!cam_dev)
+		return -ENOMEM;
+	if (dma_set_mask_and_coherent(dev, DMA_BIT_MASK(34)))
+		dev_info(dev, "%s: No suitable DMA available\n", __func__);
+
+	if (!dev->dma_parms) {
+		dev->dma_parms =
+			devm_kzalloc(dev, sizeof(*dev->dma_parms), GFP_KERNEL);
+		if (!dev->dma_parms)
+			return -ENOMEM;
+	}
+
+	if (dev->dma_parms) {
+		ret = dma_set_max_seg_size(dev, UINT_MAX);
+		if (ret)
+			dev_info(dev, "Failed to set DMA segment size\n");
+	}
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		dev_info(dev, "failed to get mem\n");
+		return -ENODEV;
+	}
+
+	cam_dev->base = devm_ioremap_resource(dev, res);
+	if (IS_ERR(cam_dev->base)) {
+		dev_dbg(dev, "failed to map register base\n");
+		return PTR_ERR(cam_dev->base);
+	}
+
+	cam_dev->dev = dev;
+	dev_set_drvdata(dev, cam_dev);
+
+	cam_dev->composer_cnt = 0;
+	cam_dev->num_seninf_devices = 0;
+
+	/* FIXME: decide max raw stream num by seninf num */
+	cam_dev->max_stream_num = MTKCAM_SUBDEV_MAX;
+	cam_dev->ctxs = devm_kcalloc(dev, cam_dev->max_stream_num,
+				     sizeof(*cam_dev->ctxs), GFP_KERNEL);
+	if (!cam_dev->ctxs)
+		return -ENOMEM;
+
+	cam_dev->streaming_ctx = 0;
+	for (i = 0; i < cam_dev->max_stream_num; i++)
+		mtk_cam_ctx_init(cam_dev->ctxs + i, cam_dev, i);
+
+	cam_dev->running_job_count = 0;
+	spin_lock_init(&cam_dev->pending_job_lock);
+	spin_lock_init(&cam_dev->running_job_lock);
+	INIT_LIST_HEAD(&cam_dev->pending_job_list);
+	INIT_LIST_HEAD(&cam_dev->running_job_list);
+
+	mutex_init(&cam_dev->queue_lock);
+
+	pm_runtime_enable(dev);
+
+	ret = mtk_cam_of_rproc(cam_dev, pdev);
+	if (ret)
+		goto fail_destroy_mutex;
+
+	ret = register_sub_drivers(dev);
+	if (ret) {
+		dev_info(dev, "fail to register_sub_drivers\n");
+		goto fail_destroy_mutex;
+	}
+
+
+	cam_dev->link_change_wq =
+		alloc_ordered_workqueue(dev_name(cam_dev->dev),
+								WQ_HIGHPRI | WQ_FREEZABLE);
+	if (!cam_dev->link_change_wq) {
+		dev_dbg(cam_dev->dev, "failed to alloc link_change_wq\n");
+		goto fail_match_remove;
+	}
+
+	ret = mtk_cam_debug_fs_init(cam_dev);
+	if (ret < 0)
+		goto fail_uninit_link_change_wq;
+
+	return 0;
+
+fail_uninit_link_change_wq:
+	destroy_workqueue(cam_dev->link_change_wq);
+
+fail_match_remove:
+	mtk_cam_match_remove(dev);
+
+fail_destroy_mutex:
+	mutex_destroy(&cam_dev->queue_lock);
+
+	return ret;
+}
+
+static int mtk_cam_remove(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct mtk_cam_device *cam_dev = dev_get_drvdata(dev);
+
+	pm_runtime_disable(dev);
+
+	component_master_del(dev, &mtk_cam_master_ops);
+	mtk_cam_match_remove(dev);
+
+	mutex_destroy(&cam_dev->queue_lock);
+		mtk_cam_debug_fs_deinit(cam_dev);
+
+	destroy_workqueue(cam_dev->link_change_wq);
+	platform_driver_unregister(&mtk_cam_sv_driver);
+	platform_driver_unregister(&mtk_cam_raw_driver);
+	platform_driver_unregister(&mtk_cam_larb_driver);
+	platform_driver_unregister(&seninf_core_pdrv);
+	platform_driver_unregister(&seninf_pdrv);
+
+	return 0;
+}
+
+static const struct dev_pm_ops mtk_cam_pm_ops = {
+	SET_RUNTIME_PM_OPS(mtk_cam_runtime_suspend, mtk_cam_runtime_resume,
+			   NULL)
+};
+
+static struct platform_driver mtk_cam_driver = {
+	.probe   = mtk_cam_probe,
+	.remove  = mtk_cam_remove,
+	.driver  = {
+		.name  = "mtk-cam",
+		.of_match_table = of_match_ptr(mtk_cam_of_ids),
+		.pm     = &mtk_cam_pm_ops,
+	}
+};
+
+static int __init mtk_cam_init(void)
+{
+	return platform_driver_register(&mtk_cam_driver);
+}
+
+static void __exit mtk_cam_exit(void)
+{
+	platform_driver_unregister(&mtk_cam_driver);
+}
+
+module_init(mtk_cam_init);
+module_exit(mtk_cam_exit);
+
+MODULE_DESCRIPTION("Camera ISP driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam.h b/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam.h
new file mode 100755
index 0000000000000000000000000000000000000000..f817ec9c2736fd23f7e49b18b367a85d65f5f9f8
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam.h
@@ -0,0 +1,845 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2022 MediaTek Inc.
+ */
+
+#ifndef __MTK_CAM_H
+#define __MTK_CAM_H
+
+#include <linux/list.h>
+#include <linux/of.h>
+#include <linux/rpmsg.h>
+#include <media/media-device.h>
+#include <media/media-request.h>
+#include <media/v4l2-async.h>
+#include <media/v4l2-device.h>
+
+#include "mtk_cam-raw.h"
+#include "mtk_cam-sv.h"
+#include "mtk_cam_pm.h"
+#include "mtk_cam-ipi.h"
+#include "imgsensor-user.h"
+#include "mtk_cam-seninf-def.h"
+#include "mtk_cam-seninf-drv.h"
+#include "mtk_cam-seninf-if.h"
+#include "mtk_cam-ctrl.h"
+#include "mtk_cam-debug.h"
+#include "mtk_cam-plat-util.h"
+
+#define MTK_CAM_REQ_MAX_S_DATA	2
+/* for SCP internal working buffers, need to align it with SCP */
+#define SIZE_OF_RAW_PRIV		20788
+#define SIZE_OF_RAW_WORKBUF		18600
+#define SIZE_OF_SESSION			22596
+/* for cq working buffers */
+#ifdef ISP7_1
+#define CQ_BUF_SIZE	0x8000
+#else
+#define CQ_BUF_SIZE	0x10000
+#endif
+#define CAM_CQ_BUF_NUM 16
+#define CAMSV_WORKING_BUF_NUM 64
+#define IPI_FRAME_BUF_SIZE ALIGN(sizeof(struct mtkcam_ipi_frame_param), SZ_1K)
+/* for time-sharing camsv working buffer, (1inner+2backendprogramming+3backup)*/
+#define CAM_IMG_BUF_NUM (6)
+#define MAX_STAGGER_EXP_AMOUNT 3
+#define MAX_PIPES_PER_STREAM 5
+#define MAX_SV_PIPES_PER_STREAM (MAX_PIPES_PER_STREAM-1)
+#define MTK_CAM_CTX_WATCHDOG_INTERVAL	100
+
+struct platform_device;
+struct mtk_rpmsg_device;
+struct mtk_cam_debug_fs;
+struct mtk_cam_request;
+struct mtk_raw_pipeline;
+
+#define SENSOR_FMT_MASK			0xFFFF
+/* flags of mtk_cam_request_stream_data */
+/* flags of mtk_cam_request */
+#define MTK_CAM_REQ_FLAG_SENINF_CHANGED			BIT(0)
+
+#define MTK_CAM_REQ_FLAG_SENINF_IMMEDIATE_UPDATE	BIT(1)
+
+/* flags of mtk_cam_request_stream_data */
+#define MTK_CAM_REQ_S_DATA_FLAG_TG_FLASH		BIT(0)
+
+#define MTK_CAM_REQ_S_DATA_FLAG_META1_INDEPENDENT	BIT(1)
+
+#define MTK_CAM_REQ_S_DATA_FLAG_SINK_FMT_UPDATE		BIT(2)
+
+/* Apply sensor mode and the timing is 1 vsync before */
+#define MTK_CAM_REQ_S_DATA_FLAG_SENSOR_MODE_UPDATE_T1	BIT(3)
+
+#define MTK_CAM_REQ_S_DATA_FLAG_SENSOR_HDL_EN		BIT(4)
+
+#define MTK_CAM_REQ_S_DATA_FLAG_RAW_HDL_EN		BIT(5)
+
+#define MTK_CAM_REQ_S_DATA_FLAG_SENSOR_HDL_COMPLETE	BIT(6)
+
+#define MTK_CAM_REQ_S_DATA_FLAG_RAW_HDL_COMPLETE	BIT(7)
+
+#define MTK_CAM_REQ_S_DATA_FLAG_SENSOR_HDL_DELAYED	BIT(8)
+
+#define v4l2_subdev_format_request_fd(x) x->reserved[0]
+struct mtk_cam_working_buf {
+	void *va;
+	dma_addr_t iova;
+	dma_addr_t scp_addr;
+	int size;
+};
+
+struct mtk_cam_msg_buf {
+	void *va;
+	dma_addr_t scp_addr;
+	int size;
+};
+
+struct mtk_cam_dmao_buf {
+	void *va;
+	dma_addr_t iova;
+	dma_addr_t scp_addr;
+	int size;
+	int fd;
+};
+
+/* TODO: remove this entry wrapper */
+struct mtk_cam_working_buf_entry {
+	struct mtk_cam_ctx *ctx;
+	struct mtk_cam_request_stream_data *s_data;
+	struct mtk_cam_working_buf buffer;
+	struct mtk_cam_dmao_buf meta_buffer;
+	struct mtk_cam_msg_buf msg_buffer;
+	struct list_head list_entry;
+	int cq_desc_offset;
+	int cq_desc_size;
+	int sub_cq_desc_offset;
+	int sub_cq_desc_size;
+};
+
+struct mtk_cam_img_working_buf_entry {
+	struct mtk_cam_ctx *ctx;
+	struct mtk_cam_request_stream_data *s_data;
+	struct mtk_cam_working_buf img_buffer;
+	struct list_head list_entry;
+};
+
+struct mtk_cam_working_buf_list {
+	struct list_head list;
+	u32 cnt;
+	spinlock_t lock; /* protect the list and cnt */
+};
+
+struct mtk_camsv_working_buf_entry {
+	struct mtk_cam_ctx *ctx;
+	struct mtk_cam_request_stream_data *s_data;
+	struct list_head list_entry;
+	u64 ts_raw;
+	u64 ts_sv;
+};
+
+struct mtk_camsv_working_buf_list {
+	struct list_head list;
+	u32 cnt;
+	spinlock_t lock; /* protect the list and cnt */
+};
+
+struct mtk_cam_req_work {
+	struct work_struct work;
+	struct mtk_cam_request_stream_data *s_data;
+	struct list_head list;
+	atomic_t is_queued;
+};
+
+static inline struct mtk_cam_request_stream_data*
+mtk_cam_req_work_get_s_data(struct mtk_cam_req_work *work)
+{
+	return work->s_data;
+}
+
+struct mtk_cam_req_feature {
+	int raw_feature;
+	int prev_feature;
+	int switch_feature_type;
+	bool switch_prev_frame_done;
+	bool switch_curr_setting_done;
+	bool switch_done;
+};
+
+struct mtk_cam_sensor_work {
+	struct kthread_work work;
+	atomic_t is_queued;
+};
+
+/*
+ * struct mtk_cam_request_stream_data - per stream members of a request
+ *
+ * @pad_fmt: pad format configurtion for sensor switch.
+ * @frame_params: The frame info. & address info. of enabled DMA nodes.
+ * @frame_work: work queue entry for frame transmission to SCP.
+ * @working_buf: command queue buffer associated to this request
+ * @mtk_cam_exposure: exposure value of sensor of mstream
+ * @deque_list_node: the entry node of s_data for deque
+ * @cleanup_list_node: the entry node of s_data for cleanup
+ *
+ */
+struct mtk_cam_request_stream_data {
+	int index;
+	struct mtk_cam_request *req;
+	struct mtk_cam_ctx *ctx;
+	int pipe_id;
+	unsigned int frame_seq_no;
+	unsigned int flags;
+	unsigned long raw_dmas;
+	u64 timestamp;
+	u64 timestamp_mono;
+	atomic_t buf_state; /* default: -1 */
+	struct mtk_cam_buffer *bufs[MTK_RAW_TOTAL_NODES];
+	struct v4l2_subdev *sensor;
+	struct v4l2_subdev *seninf_old;
+	struct v4l2_subdev *seninf_new;
+	struct media_request_object *sensor_hdl_obj;  /* for complete only */
+	struct media_request_object *raw_hdl_obj;  /* for complete only */
+	u32 pad_fmt_update;
+	u32 vdev_fmt_update;
+	u32 vdev_selection_update;
+	u32 pad_selection_update;
+	struct v4l2_subdev_format seninf_fmt;
+	struct v4l2_subdev_format pad_fmt[MTK_RAW_PIPELINE_PADS_NUM];
+	struct v4l2_rect pad_selection[MTK_RAW_PIPELINE_PADS_NUM];
+	struct v4l2_format vdev_fmt[MTK_RAW_TOTAL_NODES];
+	struct v4l2_selection vdev_selection[MTK_RAW_TOTAL_NODES];
+	struct mtkcam_ipi_frame_param frame_params;
+	struct mtk_camsv_frame_params sv_frame_params;
+	struct mtk_cam_sensor_work sensor_work;
+	struct mtk_cam_req_work seninf_s_fmt_work;
+	struct mtk_cam_req_work frame_work;
+	struct mtk_cam_req_work meta1_done_work;
+	struct mtk_cam_req_work frame_done_work;
+	struct mtk_cam_req_work sv_work;
+	struct mtk_camsys_ctrl_state state;
+	struct mtk_cam_working_buf_entry *working_buf;
+	unsigned int no_frame_done_cnt;
+	atomic_t seninf_dump_state;
+	struct mtk_cam_req_feature feature;
+	struct mtk_cam_shutter_gain mtk_cam_exposure;
+	struct mtk_cam_req_dbg_work dbg_work;
+	struct mtk_cam_req_dbg_work dbg_exception_work;
+	struct list_head deque_list_node;
+	struct list_head cleanup_list_node;
+	atomic_t first_setting_check;
+};
+
+struct mtk_cam_req_pipe {
+	int s_data_num;
+	int req_seq;
+	struct mtk_cam_request_stream_data s_data[MTK_CAM_REQ_MAX_S_DATA];
+};
+
+enum mtk_cam_request_state {
+	MTK_CAM_REQ_STATE_PENDING,
+	MTK_CAM_REQ_STATE_RUNNING,
+	MTK_CAM_REQ_STATE_DELETING,
+	MTK_CAM_REQ_STATE_COMPLETE,
+	MTK_CAM_REQ_STATE_CLEANUP,
+	NR_OF_MTK_CAM_REQ_STATE,
+};
+
+enum mtk_cam_pixel_mode {
+	PXL_MOD_1 = 0,
+	PXL_MOD_2,
+	PXL_MOD_4,
+	PXL_MOD_8,
+};
+
+/**
+ * mtk_cam_frame_sync: the frame sync state of one request
+ *
+ * @target: the num of ctx(sensor) which should be synced
+ * @on_cnt: the count of frame sync on called by ctx
+ * @off_cnt: the count of frame sync off called by ctx
+ * @op_lock: protect frame sync state variables
+ */
+struct mtk_cam_frame_sync {
+	unsigned int target;
+	unsigned int on_cnt;
+	unsigned int off_cnt;
+	struct mutex op_lock;
+};
+
+struct mtk_cam_req_raw_pipe_data {
+	struct mtk_cam_resource res;
+	struct mtk_raw_stagger_select stagger_select;
+	int enabled_raw;
+};
+
+/*
+ * struct mtk_cam_request - MTK camera request.
+ *
+ * @req: Embedded struct media request.
+ * @ctx_used: conctext used in this request
+ * @ctx_link_update: contexts have update link
+ * @pipe_used: pipe used in this request. Two or more pipes may share
+ * the same context.
+ * @frame_params: The frame info. & address info. of enabled DMA nodes.
+ * @frame_work: work queue entry for frame transmission to SCP.
+ * @list: List entry of the object for @struct mtk_cam_device:
+ *        pending_job_list or running_job_list.
+ * @mtk_cam_request_stream_data: stream context related to the request
+ * @fs: the frame sync state
+ */
+struct mtk_cam_request {
+	struct media_request req;
+	unsigned int pipe_used;
+	unsigned int ctx_used;
+	unsigned int ctx_link_update;
+	unsigned int flags;
+	unsigned int done_status;
+	spinlock_t done_status_lock;
+	atomic_t state;
+	struct mtk_cam_frame_sync fs;
+	struct list_head list;
+	struct list_head cleanup_list;
+	struct work_struct link_work;
+	struct mtk_cam_req_pipe p_data[MTKCAM_SUBDEV_MAX];
+	struct mtk_cam_req_raw_pipe_data raw_pipe_data[MTKCAM_SUBDEV_RAW_END -
+						       MTKCAM_SUBDEV_RAW_START];
+	s64 sync_id;
+	atomic_t ref_cnt;
+};
+
+struct mtk_cam_working_buf_pool {
+	struct mtk_cam_ctx *ctx;
+
+	struct dma_buf *working_buf_dmabuf;
+
+	void *working_buf_va;
+	dma_addr_t working_buf_iova;
+	dma_addr_t working_buf_scp_addr;
+	int working_buf_size;
+
+	void *msg_buf_va;
+	dma_addr_t msg_buf_scp_addr;
+	int msg_buf_size;
+
+	void *raw_workbuf_va;
+	dma_addr_t raw_workbuf_scp_addr;
+	int raw_workbuf_size;
+	void *priv_workbuf_va;
+	dma_addr_t priv_workbuf_scp_addr;
+	int priv_workbuf_size;
+	void *session_buf_va;
+	dma_addr_t session_buf_scp_addr;
+	int session_buf_size;
+
+	struct mtk_cam_working_buf_entry working_buf[CAM_CQ_BUF_NUM];
+	struct mtk_cam_working_buf_list cam_freelist;
+
+	struct mtk_camsv_working_buf_entry sv_working_buf[CAMSV_WORKING_BUF_NUM];
+	struct mtk_camsv_working_buf_list sv_freelist;
+};
+
+struct mtk_cam_img_working_buf_pool {
+	struct mtk_cam_ctx *ctx;
+	struct dma_buf *working_img_buf_dmabuf;
+	void *working_img_buf_va;
+	dma_addr_t working_img_buf_iova;
+	dma_addr_t working_img_buf_scp_addr;
+	int working_img_buf_size;
+	struct mtk_cam_img_working_buf_entry img_working_buf[CAM_IMG_BUF_NUM];
+	struct mtk_cam_working_buf_list cam_freeimglist;
+};
+
+struct mtk_cam_device;
+
+struct mtk_cam_ctx {
+	struct mtk_cam_device *cam;
+	unsigned int stream_id;
+	unsigned int streaming;
+	unsigned int synced;
+	struct media_pipeline pipeline;
+	struct mtk_raw_pipeline *pipe;
+	struct mtk_camsv_pipeline *sv_pipe[MAX_SV_PIPES_PER_STREAM];
+	unsigned int enabled_node_cnt;
+	unsigned int streaming_pipe;
+	unsigned int streaming_node_cnt;
+	unsigned int is_first_cq_done;
+	unsigned int cq_done_status;
+	atomic_t running_s_data_cnt;
+	struct v4l2_subdev *sensor;
+	struct v4l2_subdev *prev_sensor;
+	struct v4l2_subdev *seninf;
+	struct v4l2_subdev *prev_seninf;
+	struct v4l2_subdev *pipe_subdevs[MAX_PIPES_PER_STREAM];
+	struct mtk_camsys_sensor_ctrl sensor_ctrl;
+
+	unsigned int used_raw_num;
+	unsigned int used_raw_dev;
+
+	unsigned int used_sv_num;
+	unsigned int used_sv_dev[MAX_SV_PIPES_PER_STREAM];
+	struct task_struct *sensor_worker_task;
+	struct kthread_worker sensor_worker;
+	struct workqueue_struct *composer_wq;
+	struct workqueue_struct *frame_done_wq;
+	struct workqueue_struct *sv_wq;
+
+	struct completion session_complete;
+	struct completion m2m_complete;
+	int session_created;
+
+	struct rpmsg_channel_info rpmsg_channel;
+	struct mtk_rpmsg_device *rpmsg_dev;
+
+	//  TODO: how to support multi-stream with frame-sync?
+	struct mtk_cam_working_buf_pool buf_pool;
+	struct mtk_cam_working_buf_list using_buffer_list;
+	struct mtk_cam_working_buf_list composed_buffer_list;
+	struct mtk_cam_working_buf_list processing_buffer_list;
+
+	struct mtk_camsv_working_buf_list sv_using_buffer_list[MAX_SV_PIPES_PER_STREAM];
+	struct mtk_camsv_working_buf_list sv_processing_buffer_list[MAX_SV_PIPES_PER_STREAM];
+
+	/* sensor image buffer pool handling from kernel */
+	struct mtk_cam_img_working_buf_pool img_buf_pool;
+	struct mtk_cam_working_buf_list processing_img_buffer_list;
+
+	atomic_t enqueued_frame_seq_no;
+	unsigned int composed_frame_seq_no;
+	unsigned int dequeued_frame_seq_no;
+
+	/* mstream */
+	unsigned int enqueued_request_cnt;
+	unsigned int next_sof_mask_frame_seq_no;
+	unsigned int working_request_seq;
+
+	unsigned int sv_dequeued_frame_seq_no[MAX_SV_PIPES_PER_STREAM];
+	spinlock_t streaming_lock;
+	spinlock_t first_cq_lock;
+
+	atomic_t watchdog_timeout_cnt;
+	atomic_t watchdog_cnt;
+	atomic_t watchdog_dumped;
+	atomic_t watchdog_dump_cnt;
+	struct timer_list watchdog_timer;
+	struct work_struct watchdog_work;
+
+	/* To support debug dump */
+	struct mtkcam_ipi_config_param config_params;
+
+};
+
+struct mtk_cam_device {
+	struct device *dev;
+
+	struct v4l2_device v4l2_dev;
+	struct v4l2_async_notifier notifier;
+	struct media_device media_dev;
+	void __iomem *base;
+
+	struct mtk_scp *scp;
+	struct device *smem_dev;
+	phandle rproc_phandle;
+	struct rproc *rproc_handle;
+
+	struct workqueue_struct *link_change_wq;
+	unsigned int composer_cnt;
+
+	unsigned int num_seninf_devices;
+	unsigned int num_raw_devices;
+	unsigned int num_larb_devices;
+	unsigned int num_camsv_devices;
+
+	struct mtk_raw raw;
+	struct mtk_larb larb;
+	struct mtk_camsv sv;
+
+	struct mutex queue_lock;
+
+	unsigned int max_stream_num;
+	unsigned int streaming_ctx;
+	unsigned int streaming_pipe;
+	struct mtk_cam_ctx *ctxs;
+
+	/* request related */
+	struct list_head pending_job_list;
+	spinlock_t pending_job_lock;
+	struct list_head running_job_list;
+	unsigned int running_job_count;
+	spinlock_t running_job_lock;
+
+	struct mtk_cam_debug_fs *debug_fs;
+	struct workqueue_struct *debug_wq;
+	struct workqueue_struct *debug_exception_wq;
+	wait_queue_head_t debug_exception_waitq;
+};
+
+static inline struct mtk_cam_request_stream_data*
+mtk_cam_ctrl_state_to_req_s_data(struct mtk_camsys_ctrl_state *state)
+{
+	return container_of(state, struct mtk_cam_request_stream_data, state);
+}
+
+static inline struct mtk_cam_request*
+mtk_cam_ctrl_state_get_req(struct mtk_camsys_ctrl_state *state)
+{
+	struct mtk_cam_request_stream_data *request_stream_data;
+
+	request_stream_data = mtk_cam_ctrl_state_to_req_s_data(state);
+	return request_stream_data->req;
+}
+
+static inline int
+mtk_cam_req_get_num_s_data(struct mtk_cam_request *req, int pipe_id)
+{
+	if (pipe_id < 0 || pipe_id > MTKCAM_SUBDEV_MAX)
+		return 0;
+
+	return req->p_data[pipe_id].s_data_num;
+}
+
+/**
+ * Be used operation between request reinit and enqueue.
+ * For example, request-based set fmt and selection.
+ */
+static inline struct mtk_cam_request_stream_data*
+mtk_cam_req_get_s_data_no_chk(struct mtk_cam_request *req, int pipe_id, int idx)
+{
+	return &req->p_data[pipe_id].s_data[idx];
+}
+
+static inline struct mtk_cam_request_stream_data*
+mtk_cam_req_get_s_data(struct mtk_cam_request *req, int pipe_id, int idx)
+{
+	if (!req || pipe_id < 0 || pipe_id > MTKCAM_SUBDEV_MAX)
+		return NULL;
+
+	if (idx < 0 || idx >= req->p_data[pipe_id].s_data_num)
+		return NULL;
+
+	return mtk_cam_req_get_s_data_no_chk(req, pipe_id, idx);
+}
+
+static inline struct mtk_cam_request_stream_data*
+mtk_cam_wbuf_get_s_data(struct mtk_cam_working_buf_entry *buf_entry)
+{
+	return buf_entry->s_data;
+}
+
+static inline void
+mtk_cam_img_wbuf_set_s_data(struct mtk_cam_img_working_buf_entry *buf_entry,
+	struct mtk_cam_request_stream_data *s_data)
+{
+	buf_entry->s_data = s_data;
+}
+
+static inline void
+mtk_cam_sv_wbuf_set_s_data(struct mtk_camsv_working_buf_entry *buf_entry,
+	struct mtk_cam_request_stream_data *s_data)
+{
+	buf_entry->s_data = s_data;
+}
+
+	static inline struct mtk_cam_ctx*
+mtk_cam_s_data_get_ctx(struct mtk_cam_request_stream_data *s_data)
+{
+	if (s_data == NULL)
+		return NULL;
+
+	return s_data->ctx;
+}
+
+static inline char*
+mtk_cam_s_data_get_dbg_str(struct mtk_cam_request_stream_data *s_data)
+{
+	return s_data->req->req.debug_str;
+}
+
+static inline struct mtk_cam_request*
+mtk_cam_s_data_get_req(struct mtk_cam_request_stream_data *s_data)
+{
+	if (s_data == NULL)
+		return NULL;
+
+	return s_data->req;
+}
+
+static inline struct mtk_cam_req_raw_pipe_data*
+mtk_cam_s_data_get_raw_pipe_data(struct mtk_cam_request_stream_data *s_data)
+{
+	if (!is_raw_subdev(s_data->pipe_id))
+		return NULL;
+
+	return &s_data->req->raw_pipe_data[s_data->pipe_id];
+}
+
+static inline struct mtk_cam_resource*
+mtk_cam_s_data_get_res(struct mtk_cam_request_stream_data *s_data)
+{
+	if (s_data == NULL)
+		return NULL;
+
+	if (!is_raw_subdev(s_data->pipe_id))
+		return NULL;
+
+	return &s_data->req->raw_pipe_data[s_data->pipe_id].res;
+}
+
+static inline int
+mtk_cam_s_data_get_res_feature(struct mtk_cam_request_stream_data *s_data)
+{
+	return (s_data == NULL || !is_raw_subdev(s_data->pipe_id)) ?
+		0 : s_data->req->raw_pipe_data[s_data->pipe_id].res.raw_res.feature;
+}
+
+static inline int
+mtk_cam_s_data_get_vbuf_idx(struct mtk_cam_request_stream_data *s_data, int node_id)
+{
+	if (s_data->pipe_id >= MTKCAM_SUBDEV_RAW_START &&
+		s_data->pipe_id < MTKCAM_SUBDEV_RAW_END)
+		return node_id - MTK_RAW_SINK_NUM;
+
+	if (s_data->pipe_id >= MTKCAM_SUBDEV_CAMSV_START &&
+		s_data->pipe_id < MTKCAM_SUBDEV_CAMSV_END)
+		return  node_id - MTK_CAMSV_SINK_NUM;
+	return -1;
+}
+
+static inline void
+mtk_cam_s_data_set_vbuf(struct mtk_cam_request_stream_data *s_data,
+						struct mtk_cam_buffer *buf,
+						int node_id)
+{
+	int idx = mtk_cam_s_data_get_vbuf_idx(s_data, node_id);
+
+	if (idx >= 0)
+		s_data->bufs[idx] = buf;
+}
+
+static inline struct mtk_cam_buffer*
+mtk_cam_s_data_get_vbuf(struct mtk_cam_request_stream_data *s_data, int node_id)
+{
+	int idx = mtk_cam_s_data_get_vbuf_idx(s_data, node_id);
+
+	if (idx >= 0)
+		return s_data->bufs[idx];
+	return NULL;
+}
+
+static inline struct v4l2_format*
+mtk_cam_s_data_get_vfmt(struct mtk_cam_request_stream_data *s_data, int node_id)
+{
+	int idx = mtk_cam_s_data_get_vbuf_idx(s_data, node_id);
+
+	if (idx >= 0)
+		return &s_data->vdev_fmt[idx];
+
+	return NULL;
+}
+
+static inline struct v4l2_mbus_framefmt*
+mtk_cam_s_data_get_pfmt(struct mtk_cam_request_stream_data *s_data, int pad)
+{
+	if (pad >= 0)
+		return &s_data->pad_fmt[pad].format;
+
+	return NULL;
+}
+
+
+static inline struct v4l2_selection*
+mtk_cam_s_data_get_vsel(struct mtk_cam_request_stream_data *s_data, int node_id)
+{
+	int idx = mtk_cam_s_data_get_vbuf_idx(s_data, node_id);
+
+	if (idx >= 0)
+		return &s_data->vdev_selection[idx];
+
+	return NULL;
+}
+
+static inline void
+mtk_cam_s_data_reset_vbuf(struct mtk_cam_request_stream_data *s_data, int node_id)
+{
+	int idx = mtk_cam_s_data_get_vbuf_idx(s_data, node_id);
+
+	if (idx >= 0)
+		s_data->bufs[idx] = NULL;
+}
+
+static inline void
+mtk_cam_s_data_set_wbuf(struct mtk_cam_request_stream_data *s_data,
+	struct mtk_cam_working_buf_entry *buf_entry)
+{
+	buf_entry->s_data = s_data;
+	s_data->working_buf = buf_entry;
+}
+
+static inline void
+mtk_cam_s_data_reset_wbuf(struct mtk_cam_request_stream_data *s_data)
+{
+	if (!s_data->working_buf)
+		return;
+
+	s_data->working_buf->s_data = NULL;
+	s_data->working_buf = NULL;
+}
+
+static inline bool
+mtk_cam_s_data_set_buf_state(struct mtk_cam_request_stream_data *s_data,
+			     enum vb2_buffer_state state)
+{
+	if (!s_data)
+		return false;
+
+	if (-1 == atomic_cmpxchg(&s_data->buf_state, -1, state))
+		return true;
+
+	return false;
+}
+
+int mtk_cam_s_data_raw_select(struct mtk_cam_request_stream_data *s_data,
+			      struct mtkcam_ipi_input_param *cfg_in_param);
+
+static inline struct mtk_cam_request_stream_data*
+mtk_cam_sensor_work_to_s_data(struct kthread_work *work)
+{
+	return container_of(work, struct mtk_cam_request_stream_data,
+			    sensor_work.work);
+}
+
+static inline struct mtk_cam_seninf_dump_work*
+to_mtk_cam_seninf_dump_work(struct work_struct *work)
+{
+	return container_of(work, struct mtk_cam_seninf_dump_work, work);
+}
+
+static inline struct mtk_cam_request *
+to_mtk_cam_req(struct media_request *__req)
+{
+	return container_of(__req, struct mtk_cam_request, req);
+}
+
+static inline void
+mtk_cam_pad_fmt_enable(struct v4l2_mbus_framefmt *framefmt,
+					bool enable)
+{
+	if (enable)
+		framefmt->flags |= V4L2_MBUS_FRAMEFMT_PAD_ENABLE;
+	else
+		framefmt->flags &= ~V4L2_MBUS_FRAMEFMT_PAD_ENABLE;
+}
+
+static inline bool
+mtk_cam_is_pad_fmt_enable(struct v4l2_mbus_framefmt *framefmt)
+{
+	return framefmt->flags & V4L2_MBUS_FRAMEFMT_PAD_ENABLE;
+}
+
+static inline void mtk_cam_fs_reset(struct mtk_cam_frame_sync *fs)
+{
+	fs->target = 0;
+	fs->on_cnt = 0;
+	fs->off_cnt = 0;
+}
+
+static inline struct device *mtk_cam_find_raw_dev(struct mtk_cam_device *cam,
+						  unsigned int raw_mask)
+{
+	unsigned int i;
+
+	for (i = 0; i < cam->num_raw_devices; i++)
+		if (raw_mask & (1 << i))
+			return cam->raw.devs[i];
+
+	return NULL;
+}
+
+struct mtk_cam_ctx *mtk_cam_start_ctx(struct mtk_cam_device *cam,
+				      struct mtk_cam_video_device *node);
+struct mtk_cam_ctx *mtk_cam_find_ctx(struct mtk_cam_device *cam,
+				     struct media_entity *entity);
+void mtk_cam_stop_ctx(struct mtk_cam_ctx *ctx, struct mtk_cam_video_device *node);
+void mtk_cam_complete_raw_hdl(struct mtk_cam_request_stream_data *s_data);
+void mtk_cam_complete_sensor_hdl(struct mtk_cam_request_stream_data *s_data);
+int mtk_cam_ctx_stream_on(struct mtk_cam_ctx *ctx, struct mtk_cam_video_device *node);
+int mtk_cam_ctx_stream_off(struct mtk_cam_ctx *ctx, struct mtk_cam_video_device *node);
+bool watchdog_scenario(struct mtk_cam_ctx *ctx);
+void mtk_ctx_watchdog_kick(struct mtk_cam_ctx *ctx);
+void mtk_ctx_watchdog_start(struct mtk_cam_ctx *ctx, int timeout_cnt);
+void mtk_ctx_watchdog_stop(struct mtk_cam_ctx *ctx);
+
+int mtk_cam_call_seninf_set_pixelmode(struct mtk_cam_ctx *ctx,
+				      struct v4l2_subdev *sd,
+				      int pad_id, int pixel_mode);
+void mtk_cam_dev_req_enqueue(struct mtk_cam_device *cam,
+			     struct mtk_cam_request *req);
+void mtk_cam_dev_req_cleanup(struct mtk_cam_ctx *ctx, int pipe_id, int buf_state);
+void mtk_cam_dev_req_clean_pending(struct mtk_cam_device *cam, int pipe_id,
+				   int buf_state);
+
+void mtk_cam_req_get(struct mtk_cam_request *req, int pipe_id);
+bool mtk_cam_req_put(struct mtk_cam_request *req, int pipe_id);
+
+void mtk_cam_dev_req_try_queue(struct mtk_cam_device *cam);
+
+void mtk_cam_s_data_update_timestamp(struct mtk_cam_buffer *buf,
+				     struct mtk_cam_request_stream_data *s_data);
+
+int mtk_cam_dequeue_req_frame(struct mtk_cam_ctx *ctx,
+			       unsigned int dequeued_frame_seq_no,
+			       int pipe_id);
+
+void mtk_cam_dev_job_done(struct mtk_cam_ctx *ctx,
+			  struct mtk_cam_request *req,
+			  int pipe_id,
+			  enum vb2_buffer_state state);
+
+int mtk_cam_dev_config(struct mtk_cam_ctx *ctx, bool streaming, bool config_pipe);
+void mtk_cam_apply_pending_dev_config(struct mtk_cam_request_stream_data *s_data);
+int mtk_cam_s_data_dev_config(struct mtk_cam_request_stream_data *s_data,
+	bool streaming, bool config_pipe);
+int mtk_cam_s_data_sv_dev_config(struct mtk_cam_request_stream_data *s_data);
+
+int mtk_cam_link_validate(struct v4l2_subdev *sd,
+			  struct media_link *link,
+			  struct v4l2_subdev_format *source_fmt,
+			  struct v4l2_subdev_format *sink_fmt);
+int mtk_cam_req_save_link_change(struct mtk_raw_pipeline *pipe,
+				 struct mtk_cam_request *cam_req,
+				 struct mtk_cam_request_stream_data *s_data);
+int mtk_cam_req_save_raw_vfmts(struct mtk_raw_pipeline *pipe,
+			       struct mtk_cam_request *cam_req,
+			       struct mtk_cam_request_stream_data *s_data);
+int mtk_cam_req_save_raw_vsels(struct mtk_raw_pipeline *pipe,
+			       struct mtk_cam_request *cam_req,
+			       struct mtk_cam_request_stream_data *s_data);
+
+struct mtk_cam_request *mtk_cam_get_req(struct mtk_cam_ctx *ctx,
+					unsigned int frame_seq_no);
+void mtk_cam_req_update_seq(struct mtk_cam_ctx *ctx, struct mtk_cam_request *req,
+					int seq);
+struct mtk_cam_request_stream_data*
+mtk_cam_get_req_s_data(struct mtk_cam_ctx *ctx,
+		       unsigned int pipe_id, unsigned int frame_seq_no);
+struct mtk_raw_pipeline *mtk_cam_dev_get_raw_pipeline(struct mtk_cam_device *cam,
+						      unsigned int id);
+int get_main_sv_pipe_id(struct mtk_cam_device *cam, int used_dev_mask);
+int get_sub_sv_pipe_id(struct mtk_cam_device *cam, int used_dev_mask);
+int get_last_sv_pipe_id(struct mtk_cam_device *cam, int used_dev_mask);
+
+struct mtk_raw_device *get_main_raw_dev(struct mtk_cam_device *cam,
+					  struct mtk_raw_pipeline *pipe);
+struct mtk_raw_device *get_sub_raw_dev(struct mtk_cam_device *cam,
+					 struct mtk_raw_pipeline *pipe);
+struct mtk_raw_device *get_sub2_raw_dev(struct mtk_cam_device *cam,
+					  struct mtk_raw_pipeline *pipe);
+struct mtk_camsv_device *get_camsv_dev(struct mtk_cam_device *cam,
+					struct mtk_camsv_pipeline *pipe);
+int isp_composer_create_session(struct mtk_cam_ctx *ctx);
+void isp_composer_destroy_session(struct mtk_cam_ctx *ctx);
+int PipeIDtoTGIDX(int pipe_id);
+void mstream_seamless_buf_update(struct mtk_cam_ctx *ctx,
+				struct mtk_cam_request *req, int pipe_id,
+				int previous_feature);
+
+#endif /*__MTK_CAM_H*/
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam_pm.c b/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam_pm.c
new file mode 100644
index 0000000000000000000000000000000000000000..e3efb477a572412c319f62045a60b13a43c5d8cc
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam_pm.c
@@ -0,0 +1,167 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2016 MediaTek Inc.
+ * Author: Tiffany Lin <tiffany.lin@mediatek.com>
+ *
+ */
+
+#include <linux/of_address.h>
+#include <linux/of_platform.h>
+#include <linux/pm_runtime.h>
+#include <soc/mediatek/smi.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/of_device.h>
+#include <linux/of.h>
+#include <linux/component.h>
+#include "mtk_cam.h"
+
+#include "mtk_cam_pm.h"
+
+#define LARB_ID_13  13
+#define LARB_ID_14  14
+#ifdef ISP7_1
+#define LARB_ID_25  25
+#define LARB_ID_26  26
+#endif
+
+struct mtk_cam_larb_device {
+	unsigned int	larb_id;
+	struct device	*dev;
+	struct mtk_cam_device *cam;
+};
+
+static int mtk_cam_pm_component_bind(struct device *dev, struct device *master,
+				  void *data)
+{
+	struct mtk_cam_larb_device *larb_dev = dev_get_drvdata(dev);
+	struct mtk_cam_device *cam_dev = data;
+	struct mtk_larb *larb = &cam_dev->larb;
+
+	dev_info(dev, "%s: id=%d\n", __func__, larb_dev->larb_id);
+
+	larb_dev->cam = cam_dev;
+	switch (larb_dev->larb_id) {
+	case LARB_ID_13:
+		larb->devs[CAMSYS_LARB_13] = dev;
+		break;
+	case LARB_ID_14:
+		larb->devs[CAMSYS_LARB_14] = dev;
+		break;
+#ifdef ISP7_1
+	case LARB_ID_25:
+		larb->devs[CAMSYS_LARB_25] = dev;
+		break;
+	case LARB_ID_26:
+		larb->devs[CAMSYS_LARB_26] = dev;
+		break;
+#endif
+	}
+
+	larb->cam_dev = cam_dev->dev;
+	return 0;
+}
+
+static void mtk_cam_pm_component_unbind(struct device *dev, struct device *master,
+				     void *data)
+{
+	struct mtk_cam_larb_device *larb_dev = dev_get_drvdata(dev);
+	struct mtk_cam_device *cam_dev = data;
+	struct mtk_larb *larb = &cam_dev->larb;
+
+	dev_info(dev, "%s id=%d\n", __func__, larb_dev->larb_id);
+
+	//larb_dev->cam = NULL;
+	switch (larb_dev->larb_id) {
+	case LARB_ID_13:
+		larb->devs[CAMSYS_LARB_13] = NULL;
+		break;
+	case LARB_ID_14:
+		larb->devs[CAMSYS_LARB_14] = NULL;
+		break;
+#ifdef ISP7_1
+	case LARB_ID_25:
+		larb->devs[CAMSYS_LARB_25] = NULL;
+		break;
+	case LARB_ID_26:
+		larb->devs[CAMSYS_LARB_26] = NULL;
+		break;
+#endif
+	}
+}
+
+static const struct component_ops mtk_cam_pm_component_ops = {
+	.bind = mtk_cam_pm_component_bind,
+	.unbind = mtk_cam_pm_component_unbind,
+};
+
+static int mtk_cam_larb_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct mtk_cam_larb_device   *larb_dev;
+	int ret;
+
+	dev_info(dev, "%s\n", __func__);
+	larb_dev = devm_kzalloc(dev, sizeof(*dev), GFP_KERNEL);
+	if (!larb_dev)
+		return -ENOMEM;
+	if (dma_set_mask_and_coherent(dev, DMA_BIT_MASK(34)))
+		dev_info(dev, "%s: No suitable DMA available\n", __func__);
+
+	if (!dev->dma_parms) {
+		dev->dma_parms =
+			devm_kzalloc(dev, sizeof(*dev->dma_parms), GFP_KERNEL);
+		if (!dev->dma_parms)
+			return -ENOMEM;
+	}
+
+	if (dev->dma_parms) {
+		ret = dma_set_max_seg_size(dev, UINT_MAX);
+		if (ret)
+			dev_info(dev, "Failed to set DMA segment size\n");
+	}
+
+	ret = of_property_read_u32(dev->of_node, "mediatek,larb-id",
+				   &larb_dev->larb_id);
+	if (ret != 0)
+		return ret;
+
+	larb_dev->dev = dev;
+	dev_set_drvdata(dev, larb_dev);
+
+	pm_runtime_enable(dev);
+
+	return component_add(dev, &mtk_cam_pm_component_ops);
+}
+
+static int mtk_cam_larb_remove(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+
+	pm_runtime_disable(dev);
+
+	component_del(dev, &mtk_cam_pm_component_ops);
+	return 0;
+}
+
+static const struct of_device_id mtk_cam_larb_match[] = {
+
+	{.compatible = "mediatek,camisp-larb",},
+	{},
+};
+
+//MODULE_DEVICE_TABLE(of, mtk_cam_larb_match);
+
+struct platform_driver mtk_cam_larb_driver = {
+	.probe  = mtk_cam_larb_probe,
+	.remove = mtk_cam_larb_remove,
+	.driver = {
+		.name   = "mtk-cam-larb",
+		.of_match_table = of_match_ptr(mtk_cam_larb_match),
+	},
+};
+//module_platform_driver(mtk_cam_larb_driver);
+
+//MODULE_LICENSE("GPL v2");
+//MODULE_DESCRIPTION("Mediatek video camera isp larb driver");
+
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam_pm.h b/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam_pm.h
new file mode 100644
index 0000000000000000000000000000000000000000..08f53d4b3cbd6cb06e02693275a9dccfae7dcf2f
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam_pm.h
@@ -0,0 +1,46 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2016 MediaTek Inc.
+ * Author: Tiffany Lin <tiffany.lin@mediatek.com>
+ *
+ */
+
+#ifndef _MTK_CAM_PM_H_
+#define _MTK_CAM_PM_H_
+
+enum CAMSYS_LARB_IDX {
+	CAMSYS_LARB_13 = 0,
+	CAMSYS_LARB_14,
+#ifdef ISP7_1
+	CAMSYS_LARB_25,
+	CAMSYS_LARB_26,
+#endif
+	CAMSYS_LARB_NUM
+};
+
+struct mtk_larb {
+	struct device *cam_dev;
+	struct device *devs[CAMSYS_LARB_NUM];
+};
+
+extern struct platform_driver mtk_cam_larb_driver;
+
+static inline struct device *find_larb(struct mtk_larb *larb, int larb_id)
+{
+	switch (larb_id) {
+	case 13:
+		return larb->devs[CAMSYS_LARB_13];
+	case 14:
+		return larb->devs[CAMSYS_LARB_14];
+#ifdef ISP7_1
+	case 25:
+		return larb->devs[CAMSYS_LARB_25];
+	case 26:
+		return larb->devs[CAMSYS_LARB_26];
+#endif
+	}
+
+	return NULL;
+}
+
+#endif /* _MTK_CAM_PM_H_ */
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam_vb2-dma-contig.c b/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam_vb2-dma-contig.c
new file mode 100644
index 0000000000000000000000000000000000000000..628468a9155bdf75e6cd00c929ab9f7c1f6ab688
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam_vb2-dma-contig.c
@@ -0,0 +1,271 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2022 MediaTek Inc.
+ */
+
+#include <linux/dma-buf.h>
+#include <linux/module.h>
+#include <linux/refcount.h>
+#include <linux/scatterlist.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/dma-mapping.h>
+
+#include <media/videobuf2-v4l2.h>
+#include <media/videobuf2-memops.h>
+
+#include "mtk_cam_vb2-dma-contig.h"
+
+struct mtk_cam_vb2_buf {
+	struct device			*dev;
+	void				*vaddr;
+	unsigned long			size;
+	void				*cookie;
+	dma_addr_t			dma_addr;
+	unsigned long			attrs;
+	enum dma_data_direction		dma_dir;
+	struct sg_table			*dma_sgt;
+	struct frame_vector		*vec;
+
+	/* MMAP related */
+	struct vb2_vmarea_handler	handler;
+	refcount_t			refcount;
+	struct sg_table			*sgt_base;
+
+	/* DMABUF related */
+	struct dma_buf_attachment	*db_attach;
+	struct iosys_map map;
+};
+
+/*********************************************/
+/*        scatterlist table functions        */
+/*********************************************/
+
+static unsigned long mtk_cam_vb2_get_contiguous_size(struct sg_table *sgt)
+{
+	struct scatterlist *s;
+	dma_addr_t expected = sg_dma_address(sgt->sgl);
+	unsigned int i;
+	unsigned long size = 0;
+
+	for_each_sgtable_dma_sg(sgt, s, i) {
+		if (sg_dma_address(s) != expected)
+			break;
+		expected += sg_dma_len(s);
+		size += sg_dma_len(s);
+	}
+	return size;
+}
+
+/*********************************************/
+/*         callbacks for all buffers         */
+/*********************************************/
+
+static void *mtk_cam_vb2_cookie(struct vb2_buffer *vb, void *buf_priv)
+{
+	struct mtk_cam_vb2_buf *buf = buf_priv;
+
+	return &buf->dma_addr;
+}
+
+static void *mtk_cam_vb2_vaddr(struct vb2_buffer *vb, void *buf_priv)
+{
+	struct mtk_cam_vb2_buf *buf = buf_priv;
+
+	if (!buf->vaddr && buf->db_attach)
+		dma_buf_vmap(buf->db_attach->dmabuf, &buf->map);
+
+	buf->vaddr = buf->map.vaddr;
+
+	return buf->vaddr;
+}
+
+static unsigned int mtk_cam_vb2_num_users(void *buf_priv)
+{
+	struct mtk_cam_vb2_buf *buf = buf_priv;
+
+	return refcount_read(&buf->refcount);
+}
+
+static void mtk_cam_vb2_prepare(void *buf_priv)
+{
+	struct mtk_cam_vb2_buf *buf = buf_priv;
+	struct sg_table *sgt = buf->dma_sgt;
+
+	if (!sgt)
+		return;
+
+	dma_sync_sgtable_for_device(buf->dev, sgt, buf->dma_dir);
+}
+
+static void mtk_cam_vb2_finish(void *buf_priv)
+{
+	struct mtk_cam_vb2_buf *buf = buf_priv;
+	struct sg_table *sgt = buf->dma_sgt;
+
+	if (!sgt)
+		return;
+
+	dma_sync_sgtable_for_cpu(buf->dev, sgt, buf->dma_dir);
+}
+
+/*********************************************/
+/*       callbacks for DMABUF buffers        */
+/*********************************************/
+
+static int mtk_cam_vb2_map_dmabuf(void *mem_priv)
+{
+	struct mtk_cam_vb2_buf *buf = mem_priv;
+	struct sg_table *sgt;
+	unsigned long contig_size;
+
+	if (WARN_ON(!buf->db_attach)) {
+		pr_info("trying to pin a non attached buffer\n");
+		return -EINVAL;
+	}
+
+	if (WARN_ON(buf->dma_sgt)) {
+		pr_info("dmabuf buffer is already pinned\n");
+		return 0;
+	}
+
+	/* get the associated scatterlist for this buffer */
+	sgt = dma_buf_map_attachment(buf->db_attach, buf->dma_dir);
+	if (IS_ERR(sgt)) {
+		pr_info("Error getting dmabuf scatterlist\n");
+		return -EINVAL;
+	}
+
+	/* checking if dmabuf is big enough to store contiguous chunk */
+	contig_size = mtk_cam_vb2_get_contiguous_size(sgt);
+	if (contig_size < buf->size) {
+		pr_info("contiguous chunk is too small %lu/%lu\n",
+		       contig_size, buf->size);
+		dma_buf_unmap_attachment(buf->db_attach, sgt, buf->dma_dir);
+		return -EFAULT;
+	}
+
+	buf->dma_addr = sg_dma_address(sgt->sgl);
+	buf->dma_sgt = sgt;
+	buf->vaddr = NULL;
+
+	return 0;
+}
+
+static void mtk_cam_vb2_unmap_dmabuf(void *mem_priv)
+{
+	struct mtk_cam_vb2_buf *buf = mem_priv;
+	struct sg_table *sgt = buf->dma_sgt;
+
+	if (WARN_ON(!buf->db_attach)) {
+		pr_info("trying to unpin a not attached buffer\n");
+		return;
+	}
+
+	if (WARN_ON(!sgt)) {
+		pr_info("dmabuf buffer is already unpinned\n");
+		return;
+	}
+
+	if (buf->vaddr) {
+		dma_buf_vunmap(buf->db_attach->dmabuf, &buf->map);
+		buf->vaddr = NULL;
+	}
+	dma_buf_unmap_attachment(buf->db_attach, sgt, buf->dma_dir);
+
+	buf->dma_addr = 0;
+	buf->dma_sgt = NULL;
+}
+
+static void mtk_cam_vb2_detach_dmabuf(void *mem_priv)
+{
+	struct mtk_cam_vb2_buf *buf = mem_priv;
+
+	/* if vb2 works correctly you should never detach mapped buffer */
+	if (WARN_ON(buf->dma_addr))
+		mtk_cam_vb2_unmap_dmabuf(buf);
+
+	/* detach this attachment */
+	dma_buf_detach(buf->db_attach->dmabuf, buf->db_attach);
+	kfree(buf);
+}
+
+static void *mtk_cam_vb2_attach_dmabuf(struct vb2_buffer *vb,
+				       struct device *dev, struct dma_buf *dbuf,
+				       unsigned long size)
+{
+	struct mtk_cam_vb2_buf *buf;
+	struct dma_buf_attachment *dba;
+
+	if (dbuf->size < size)
+		return ERR_PTR(-EFAULT);
+
+	if (WARN_ON(!dev))
+		return ERR_PTR(-EINVAL);
+
+	buf = kzalloc(sizeof(*buf), GFP_KERNEL);
+	if (!buf)
+		return ERR_PTR(-ENOMEM);
+
+	buf->dev = dev;
+	/* create attachment for the dmabuf with the user device */
+	dba = dma_buf_attach(dbuf, buf->dev);
+	if (IS_ERR(dba)) {
+		pr_info("failed to attach dmabuf\n");
+		kfree(buf);
+		return dba;
+	}
+
+	buf->size = size;
+	buf->db_attach = dba;
+
+	return buf;
+}
+
+/*********************************************/
+/*       DMA CONTIG exported functions       */
+/*********************************************/
+
+const struct vb2_mem_ops mtk_cam_dma_contig_memops = {
+	/* .alloc = */
+	/* .put = */
+	/* .get_dmabuf = */
+	.cookie		= mtk_cam_vb2_cookie,
+	.vaddr		= mtk_cam_vb2_vaddr,
+	/* .mmap = */
+	/* .get_userptr = */
+	/* .put_userptr	= */
+	.prepare	= mtk_cam_vb2_prepare,
+	.finish		= mtk_cam_vb2_finish,
+	.map_dmabuf	= mtk_cam_vb2_map_dmabuf,
+	.unmap_dmabuf	= mtk_cam_vb2_unmap_dmabuf,
+	.attach_dmabuf	= mtk_cam_vb2_attach_dmabuf,
+	.detach_dmabuf	= mtk_cam_vb2_detach_dmabuf,
+	.num_users	= mtk_cam_vb2_num_users,
+};
+EXPORT_SYMBOL_GPL(mtk_cam_dma_contig_memops);
+
+void mtk_cam_vb2_sync_for_device(void *buf_priv)
+{
+	struct mtk_cam_vb2_buf *buf = buf_priv;
+	struct sg_table *sgt = buf->dma_sgt;
+
+	if (!sgt)
+		return;
+
+	dma_sync_sgtable_for_device(buf->dev, sgt, buf->dma_dir);
+}
+
+void mtk_cam_vb2_sync_for_cpu(void *buf_priv)
+{
+	struct mtk_cam_vb2_buf *buf = buf_priv;
+	struct sg_table *sgt = buf->dma_sgt;
+
+	if (!sgt)
+		return;
+
+	dma_sync_sgtable_for_cpu(buf->dev, sgt, buf->dma_dir);
+}
+
+MODULE_DESCRIPTION("DMA-contig memory handling routines for mtk-cam videobuf2");
+MODULE_LICENSE("GPL");
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam_vb2-dma-contig.h b/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam_vb2-dma-contig.h
new file mode 100644
index 0000000000000000000000000000000000000000..0098973964d2fd664426bb8ad45a4ea08e9492ba
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_cam_vb2-dma-contig.h
@@ -0,0 +1,16 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2022 MediaTek Inc.
+ */
+
+#ifndef __MTK_CAM_VB2_DMA_CONTIG_H
+#define __MTK_CAM_VB2_DMA_CONTIG_H
+
+#include <linux/dma-buf.h>
+
+extern const struct vb2_mem_ops mtk_cam_dma_contig_memops;
+
+void mtk_cam_vb2_sync_for_device(void *buf_priv);
+void mtk_cam_vb2_sync_for_cpu(void *buf_priv);
+
+#endif /*__MTK_CAM_VB2_DMA_CONTIG_H*/
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_csi_phy_2_0/mtk_cam-seninf-cammux.h b/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_csi_phy_2_0/mtk_cam-seninf-cammux.h
new file mode 100644
index 0000000000000000000000000000000000000000..34b770c7decfb4fe962a748f19c26a2bddc0586b
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_csi_phy_2_0/mtk_cam-seninf-cammux.h
@@ -0,0 +1,923 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2022 MediaTek Inc.
+ */
+
+#ifndef __SENINF_CAM_MUX_H__
+#define __SENINF_CAM_MUX_H__
+
+#define SENINF_CAM_MUX_CTRL_0 0x0000
+#define RG_SENINF_CAM_MUX0_SRC_SEL_SHIFT 0
+#define RG_SENINF_CAM_MUX0_SRC_SEL_MASK (0xf << 0)
+#define RG_SENINF_CAM_MUX1_SRC_SEL_SHIFT 8
+#define RG_SENINF_CAM_MUX1_SRC_SEL_MASK (0xf << 8)
+#define RG_SENINF_CAM_MUX2_SRC_SEL_SHIFT 16
+#define RG_SENINF_CAM_MUX2_SRC_SEL_MASK (0xf << 16)
+#define RG_SENINF_CAM_MUX3_SRC_SEL_SHIFT 24
+#define RG_SENINF_CAM_MUX3_SRC_SEL_MASK (0xf << 24)
+
+#define SENINF_CAM_MUX_CTRL_1 0x0004
+#define RG_SENINF_CAM_MUX4_SRC_SEL_SHIFT 0
+#define RG_SENINF_CAM_MUX4_SRC_SEL_MASK (0xf << 0)
+#define RG_SENINF_CAM_MUX5_SRC_SEL_SHIFT 8
+#define RG_SENINF_CAM_MUX5_SRC_SEL_MASK (0xf << 8)
+#define RG_SENINF_CAM_MUX6_SRC_SEL_SHIFT 16
+#define RG_SENINF_CAM_MUX6_SRC_SEL_MASK (0xf << 16)
+#define RG_SENINF_CAM_MUX7_SRC_SEL_SHIFT 24
+#define RG_SENINF_CAM_MUX7_SRC_SEL_MASK (0xf << 24)
+
+#define SENINF_CAM_MUX_CTRL_2 0x0008
+#define RG_SENINF_CAM_MUX8_SRC_SEL_SHIFT 0
+#define RG_SENINF_CAM_MUX8_SRC_SEL_MASK (0xf << 0)
+#define RG_SENINF_CAM_MUX9_SRC_SEL_SHIFT 8
+#define RG_SENINF_CAM_MUX9_SRC_SEL_MASK (0xf << 8)
+#define RG_SENINF_CAM_MUX10_SRC_SEL_SHIFT 16
+#define RG_SENINF_CAM_MUX10_SRC_SEL_MASK (0xf << 16)
+#define RG_SENINF_CAM_MUX11_SRC_SEL_SHIFT 24
+#define RG_SENINF_CAM_MUX11_SRC_SEL_MASK (0xf << 24)
+
+#define SENINF_CAM_MUX_CTRL_3 0x000c
+#define RG_SENINF_CAM_MUX12_SRC_SEL_SHIFT 0
+#define RG_SENINF_CAM_MUX12_SRC_SEL_MASK (0xf << 0)
+#define RG_SENINF_CAM_MUX13_SRC_SEL_SHIFT 8
+#define RG_SENINF_CAM_MUX13_SRC_SEL_MASK (0xf << 8)
+#define RG_SENINF_CAM_MUX14_SRC_SEL_SHIFT 16
+#define RG_SENINF_CAM_MUX14_SRC_SEL_MASK (0xf << 16)
+#define RG_SENINF_CAM_MUX15_SRC_SEL_SHIFT 24
+#define RG_SENINF_CAM_MUX15_SRC_SEL_MASK (0xf << 24)
+
+#define SENINF_CAM_MUX_EN 0x0010
+#define SENINF_CAM_MUX0_EN_SHIFT 0
+#define SENINF_CAM_MUX0_EN_MASK (0x1 << 0)
+#define SENINF_CAM_MUX1_EN_SHIFT 1
+#define SENINF_CAM_MUX1_EN_MASK (0x1 << 1)
+#define SENINF_CAM_MUX2_EN_SHIFT 2
+#define SENINF_CAM_MUX2_EN_MASK (0x1 << 2)
+#define SENINF_CAM_MUX3_EN_SHIFT 3
+#define SENINF_CAM_MUX3_EN_MASK (0x1 << 3)
+#define SENINF_CAM_MUX4_EN_SHIFT 4
+#define SENINF_CAM_MUX4_EN_MASK (0x1 << 4)
+#define SENINF_CAM_MUX5_EN_SHIFT 5
+#define SENINF_CAM_MUX5_EN_MASK (0x1 << 5)
+#define SENINF_CAM_MUX6_EN_SHIFT 6
+#define SENINF_CAM_MUX6_EN_MASK (0x1 << 6)
+#define SENINF_CAM_MUX7_EN_SHIFT 7
+#define SENINF_CAM_MUX7_EN_MASK (0x1 << 7)
+#define SENINF_CAM_MUX8_EN_SHIFT 8
+#define SENINF_CAM_MUX8_EN_MASK (0x1 << 8)
+#define SENINF_CAM_MUX9_EN_SHIFT 9
+#define SENINF_CAM_MUX9_EN_MASK (0x1 << 9)
+#define SENINF_CAM_MUX10_EN_SHIFT 10
+#define SENINF_CAM_MUX10_EN_MASK (0x1 << 10)
+#define SENINF_CAM_MUX11_EN_SHIFT 11
+#define SENINF_CAM_MUX11_EN_MASK (0x1 << 11)
+#define SENINF_CAM_MUX12_EN_SHIFT 12
+#define SENINF_CAM_MUX12_EN_MASK (0x1 << 12)
+#define SENINF_CAM_MUX13_EN_SHIFT 13
+#define SENINF_CAM_MUX13_EN_MASK (0x1 << 13)
+#define SENINF_CAM_MUX14_EN_SHIFT 14
+#define SENINF_CAM_MUX14_EN_MASK (0x1 << 14)
+#define SENINF_CAM_MUX15_EN_SHIFT 15
+#define SENINF_CAM_MUX15_EN_MASK (0x1 << 15)
+
+#define SENINF_CAM_MUX_CHK_EN 0x0018
+#define SENINF_CAM_MUX0_CHK_EN_SHIFT 0
+#define SENINF_CAM_MUX0_CHK_EN_MASK (0x1 << 0)
+#define SENINF_CAM_MUX1_CHK_EN_SHIFT 1
+#define SENINF_CAM_MUX1_CHK_EN_MASK (0x1 << 1)
+#define SENINF_CAM_MUX2_CHK_EN_SHIFT 2
+#define SENINF_CAM_MUX2_CHK_EN_MASK (0x1 << 2)
+#define SENINF_CAM_MUX3_CHK_EN_SHIFT 3
+#define SENINF_CAM_MUX3_CHK_EN_MASK (0x1 << 3)
+#define SENINF_CAM_MUX4_CHK_EN_SHIFT 4
+#define SENINF_CAM_MUX4_CHK_EN_MASK (0x1 << 4)
+#define SENINF_CAM_MUX5_CHK_EN_SHIFT 5
+#define SENINF_CAM_MUX5_CHK_EN_MASK (0x1 << 5)
+#define SENINF_CAM_MUX6_CHK_EN_SHIFT 6
+#define SENINF_CAM_MUX6_CHK_EN_MASK (0x1 << 6)
+#define SENINF_CAM_MUX7_CHK_EN_SHIFT 7
+#define SENINF_CAM_MUX7_CHK_EN_MASK (0x1 << 7)
+#define SENINF_CAM_MUX8_CHK_EN_SHIFT 8
+#define SENINF_CAM_MUX8_CHK_EN_MASK (0x1 << 8)
+#define SENINF_CAM_MUX9_CHK_EN_SHIFT 9
+#define SENINF_CAM_MUX9_CHK_EN_MASK (0x1 << 9)
+#define SENINF_CAM_MUX10_CHK_EN_SHIFT 10
+#define SENINF_CAM_MUX10_CHK_EN_MASK (0x1 << 10)
+#define SENINF_CAM_MUX11_CHK_EN_SHIFT 11
+#define SENINF_CAM_MUX11_CHK_EN_MASK (0x1 << 11)
+#define SENINF_CAM_MUX12_CHK_EN_SHIFT 12
+#define SENINF_CAM_MUX12_CHK_EN_MASK (0x1 << 12)
+#define SENINF_CAM_MUX13_CHK_EN_SHIFT 13
+#define SENINF_CAM_MUX13_CHK_EN_MASK (0x1 << 13)
+#define SENINF_CAM_MUX14_CHK_EN_SHIFT 14
+#define SENINF_CAM_MUX14_CHK_EN_MASK (0x1 << 14)
+#define SENINF_CAM_MUX15_CHK_EN_SHIFT 15
+#define SENINF_CAM_MUX15_CHK_EN_MASK (0x1 << 15)
+
+#define SENINF_CAM_MUX0_OPT 0x0020
+#define RG_SENINF_CAM_MUX0_VC_EN_SHIFT 0
+#define RG_SENINF_CAM_MUX0_VC_EN_MASK (0x1 << 0)
+#define RG_SENINF_CAM_MUX0_DT_EN_SHIFT 1
+#define RG_SENINF_CAM_MUX0_DT_EN_MASK (0x1 << 1)
+#define RG_SENINF_CAM_MUX0_VC_SEL_SHIFT 8
+#define RG_SENINF_CAM_MUX0_VC_SEL_MASK (0x1f << 8)
+#define RG_SENINF_CAM_MUX0_DT_SEL_SHIFT 16
+#define RG_SENINF_CAM_MUX0_DT_SEL_MASK (0x3f << 16)
+#define RG_SENINF_CAM_MUX0_VSYNC_BYPASS_SHIFT 24
+#define RG_SENINF_CAM_MUX0_VSYNC_BYPASS_MASK (0x1 << 24)
+
+#define SENINF_CAM_MUX1_OPT 0x0024
+#define RG_SENINF_CAM_MUX1_VC_EN_SHIFT 0
+#define RG_SENINF_CAM_MUX1_VC_EN_MASK (0x1 << 0)
+#define RG_SENINF_CAM_MUX1_DT_EN_SHIFT 1
+#define RG_SENINF_CAM_MUX1_DT_EN_MASK (0x1 << 1)
+#define RG_SENINF_CAM_MUX1_VC_SEL_SHIFT 8
+#define RG_SENINF_CAM_MUX1_VC_SEL_MASK (0x1f << 8)
+#define RG_SENINF_CAM_MUX1_DT_SEL_SHIFT 16
+#define RG_SENINF_CAM_MUX1_DT_SEL_MASK (0x3f << 16)
+#define RG_SENINF_CAM_MUX1_VSYNC_BYPASS_SHIFT 24
+#define RG_SENINF_CAM_MUX1_VSYNC_BYPASS_MASK (0x1 << 24)
+
+#define SENINF_CAM_MUX2_OPT 0x0028
+#define RG_SENINF_CAM_MUX2_VC_EN_SHIFT 0
+#define RG_SENINF_CAM_MUX2_VC_EN_MASK (0x1 << 0)
+#define RG_SENINF_CAM_MUX2_DT_EN_SHIFT 1
+#define RG_SENINF_CAM_MUX2_DT_EN_MASK (0x1 << 1)
+#define RG_SENINF_CAM_MUX2_VC_SEL_SHIFT 8
+#define RG_SENINF_CAM_MUX2_VC_SEL_MASK (0x1f << 8)
+#define RG_SENINF_CAM_MUX2_DT_SEL_SHIFT 16
+#define RG_SENINF_CAM_MUX2_DT_SEL_MASK (0x3f << 16)
+#define RG_SENINF_CAM_MUX2_VSYNC_BYPASS_SHIFT 24
+#define RG_SENINF_CAM_MUX2_VSYNC_BYPASS_MASK (0x1 << 24)
+
+#define SENINF_CAM_MUX3_OPT 0x002c
+#define RG_SENINF_CAM_MUX3_VC_EN_SHIFT 0
+#define RG_SENINF_CAM_MUX3_VC_EN_MASK (0x1 << 0)
+#define RG_SENINF_CAM_MUX3_DT_EN_SHIFT 1
+#define RG_SENINF_CAM_MUX3_DT_EN_MASK (0x1 << 1)
+#define RG_SENINF_CAM_MUX3_VC_SEL_SHIFT 8
+#define RG_SENINF_CAM_MUX3_VC_SEL_MASK (0x1f << 8)
+#define RG_SENINF_CAM_MUX3_DT_SEL_SHIFT 16
+#define RG_SENINF_CAM_MUX3_DT_SEL_MASK (0x3f << 16)
+#define RG_SENINF_CAM_MUX3_VSYNC_BYPASS_SHIFT 24
+#define RG_SENINF_CAM_MUX3_VSYNC_BYPASS_MASK (0x1 << 24)
+
+#define SENINF_CAM_MUX4_OPT 0x0030
+#define RG_SENINF_CAM_MUX4_VC_EN_SHIFT 0
+#define RG_SENINF_CAM_MUX4_VC_EN_MASK (0x1 << 0)
+#define RG_SENINF_CAM_MUX4_DT_EN_SHIFT 1
+#define RG_SENINF_CAM_MUX4_DT_EN_MASK (0x1 << 1)
+#define RG_SENINF_CAM_MUX4_VC_SEL_SHIFT 8
+#define RG_SENINF_CAM_MUX4_VC_SEL_MASK (0x1f << 8)
+#define RG_SENINF_CAM_MUX4_DT_SEL_SHIFT 16
+#define RG_SENINF_CAM_MUX4_DT_SEL_MASK (0x3f << 16)
+#define RG_SENINF_CAM_MUX4_VSYNC_BYPASS_SHIFT 24
+#define RG_SENINF_CAM_MUX4_VSYNC_BYPASS_MASK (0x1 << 24)
+
+#define SENINF_CAM_MUX5_OPT 0x0034
+#define RG_SENINF_CAM_MUX5_VC_EN_SHIFT 0
+#define RG_SENINF_CAM_MUX5_VC_EN_MASK (0x1 << 0)
+#define RG_SENINF_CAM_MUX5_DT_EN_SHIFT 1
+#define RG_SENINF_CAM_MUX5_DT_EN_MASK (0x1 << 1)
+#define RG_SENINF_CAM_MUX5_VC_SEL_SHIFT 8
+#define RG_SENINF_CAM_MUX5_VC_SEL_MASK (0x1f << 8)
+#define RG_SENINF_CAM_MUX5_DT_SEL_SHIFT 16
+#define RG_SENINF_CAM_MUX5_DT_SEL_MASK (0x3f << 16)
+#define RG_SENINF_CAM_MUX5_VSYNC_BYPASS_SHIFT 24
+#define RG_SENINF_CAM_MUX5_VSYNC_BYPASS_MASK (0x1 << 24)
+
+#define SENINF_CAM_MUX6_OPT 0x0038
+#define RG_SENINF_CAM_MUX6_VC_EN_SHIFT 0
+#define RG_SENINF_CAM_MUX6_VC_EN_MASK (0x1 << 0)
+#define RG_SENINF_CAM_MUX6_DT_EN_SHIFT 1
+#define RG_SENINF_CAM_MUX6_DT_EN_MASK (0x1 << 1)
+#define RG_SENINF_CAM_MUX6_VC_SEL_SHIFT 8
+#define RG_SENINF_CAM_MUX6_VC_SEL_MASK (0x1f << 8)
+#define RG_SENINF_CAM_MUX6_DT_SEL_SHIFT 16
+#define RG_SENINF_CAM_MUX6_DT_SEL_MASK (0x3f << 16)
+#define RG_SENINF_CAM_MUX6_VSYNC_BYPASS_SHIFT 24
+#define RG_SENINF_CAM_MUX6_VSYNC_BYPASS_MASK (0x1 << 24)
+
+#define SENINF_CAM_MUX7_OPT 0x003c
+#define RG_SENINF_CAM_MUX7_VC_EN_SHIFT 0
+#define RG_SENINF_CAM_MUX7_VC_EN_MASK (0x1 << 0)
+#define RG_SENINF_CAM_MUX7_DT_EN_SHIFT 1
+#define RG_SENINF_CAM_MUX7_DT_EN_MASK (0x1 << 1)
+#define RG_SENINF_CAM_MUX7_VC_SEL_SHIFT 8
+#define RG_SENINF_CAM_MUX7_VC_SEL_MASK (0x1f << 8)
+#define RG_SENINF_CAM_MUX7_DT_SEL_SHIFT 16
+#define RG_SENINF_CAM_MUX7_DT_SEL_MASK (0x3f << 16)
+#define RG_SENINF_CAM_MUX7_VSYNC_BYPASS_SHIFT 24
+#define RG_SENINF_CAM_MUX7_VSYNC_BYPASS_MASK (0x1 << 24)
+
+#define SENINF_CAM_MUX8_OPT 0x0040
+#define RG_SENINF_CAM_MUX8_VC_EN_SHIFT 0
+#define RG_SENINF_CAM_MUX8_VC_EN_MASK (0x1 << 0)
+#define RG_SENINF_CAM_MUX8_DT_EN_SHIFT 1
+#define RG_SENINF_CAM_MUX8_DT_EN_MASK (0x1 << 1)
+#define RG_SENINF_CAM_MUX8_VC_SEL_SHIFT 8
+#define RG_SENINF_CAM_MUX8_VC_SEL_MASK (0x1f << 8)
+#define RG_SENINF_CAM_MUX8_DT_SEL_SHIFT 16
+#define RG_SENINF_CAM_MUX8_DT_SEL_MASK (0x3f << 16)
+#define RG_SENINF_CAM_MUX8_VSYNC_BYPASS_SHIFT 24
+#define RG_SENINF_CAM_MUX8_VSYNC_BYPASS_MASK (0x1 << 24)
+
+#define SENINF_CAM_MUX9_OPT 0x0044
+#define RG_SENINF_CAM_MUX9_VC_EN_SHIFT 0
+#define RG_SENINF_CAM_MUX9_VC_EN_MASK (0x1 << 0)
+#define RG_SENINF_CAM_MUX9_DT_EN_SHIFT 1
+#define RG_SENINF_CAM_MUX9_DT_EN_MASK (0x1 << 1)
+#define RG_SENINF_CAM_MUX9_VC_SEL_SHIFT 8
+#define RG_SENINF_CAM_MUX9_VC_SEL_MASK (0x1f << 8)
+#define RG_SENINF_CAM_MUX9_DT_SEL_SHIFT 16
+#define RG_SENINF_CAM_MUX9_DT_SEL_MASK (0x3f << 16)
+#define RG_SENINF_CAM_MUX9_VSYNC_BYPASS_SHIFT 24
+#define RG_SENINF_CAM_MUX9_VSYNC_BYPASS_MASK (0x1 << 24)
+
+#define SENINF_CAM_MUX10_OPT 0x0048
+#define RG_SENINF_CAM_MUX10_VC_EN_SHIFT 0
+#define RG_SENINF_CAM_MUX10_VC_EN_MASK (0x1 << 0)
+#define RG_SENINF_CAM_MUX10_DT_EN_SHIFT 1
+#define RG_SENINF_CAM_MUX10_DT_EN_MASK (0x1 << 1)
+#define RG_SENINF_CAM_MUX10_VC_SEL_SHIFT 8
+#define RG_SENINF_CAM_MUX10_VC_SEL_MASK (0x1f << 8)
+#define RG_SENINF_CAM_MUX10_DT_SEL_SHIFT 16
+#define RG_SENINF_CAM_MUX10_DT_SEL_MASK (0x3f << 16)
+#define RG_SENINF_CAM_MUX10_VSYNC_BYPASS_SHIFT 24
+#define RG_SENINF_CAM_MUX10_VSYNC_BYPASS_MASK (0x1 << 24)
+
+#define SENINF_CAM_MUX11_OPT 0x004c
+#define RG_SENINF_CAM_MUX11_VC_EN_SHIFT 0
+#define RG_SENINF_CAM_MUX11_VC_EN_MASK (0x1 << 0)
+#define RG_SENINF_CAM_MUX11_DT_EN_SHIFT 1
+#define RG_SENINF_CAM_MUX11_DT_EN_MASK (0x1 << 1)
+#define RG_SENINF_CAM_MUX11_VC_SEL_SHIFT 8
+#define RG_SENINF_CAM_MUX11_VC_SEL_MASK (0x1f << 8)
+#define RG_SENINF_CAM_MUX11_DT_SEL_SHIFT 16
+#define RG_SENINF_CAM_MUX11_DT_SEL_MASK (0x3f << 16)
+#define RG_SENINF_CAM_MUX11_VSYNC_BYPASS_SHIFT 24
+#define RG_SENINF_CAM_MUX11_VSYNC_BYPASS_MASK (0x1 << 24)
+
+#define SENINF_CAM_MUX12_OPT 0x0050
+#define RG_SENINF_CAM_MUX12_VC_EN_SHIFT 0
+#define RG_SENINF_CAM_MUX12_VC_EN_MASK (0x1 << 0)
+#define RG_SENINF_CAM_MUX12_DT_EN_SHIFT 1
+#define RG_SENINF_CAM_MUX12_DT_EN_MASK (0x1 << 1)
+#define RG_SENINF_CAM_MUX12_VC_SEL_SHIFT 8
+#define RG_SENINF_CAM_MUX12_VC_SEL_MASK (0x1f << 8)
+#define RG_SENINF_CAM_MUX12_DT_SEL_SHIFT 16
+#define RG_SENINF_CAM_MUX12_DT_SEL_MASK (0x3f << 16)
+#define RG_SENINF_CAM_MUX12_VSYNC_BYPASS_SHIFT 24
+#define RG_SENINF_CAM_MUX12_VSYNC_BYPASS_MASK (0x1 << 24)
+
+#define SENINF_CAM_MUX13_OPT 0x0054
+#define RG_SENINF_CAM_MUX13_VC_EN_SHIFT 0
+#define RG_SENINF_CAM_MUX13_VC_EN_MASK (0x1 << 0)
+#define RG_SENINF_CAM_MUX13_DT_EN_SHIFT 1
+#define RG_SENINF_CAM_MUX13_DT_EN_MASK (0x1 << 1)
+#define RG_SENINF_CAM_MUX13_VC_SEL_SHIFT 8
+#define RG_SENINF_CAM_MUX13_VC_SEL_MASK (0x1f << 8)
+#define RG_SENINF_CAM_MUX13_DT_SEL_SHIFT 16
+#define RG_SENINF_CAM_MUX13_DT_SEL_MASK (0x3f << 16)
+#define RG_SENINF_CAM_MUX13_VSYNC_BYPASS_SHIFT 24
+#define RG_SENINF_CAM_MUX13_VSYNC_BYPASS_MASK (0x1 << 24)
+
+#define SENINF_CAM_MUX14_OPT 0x0058
+#define RG_SENINF_CAM_MUX14_VC_EN_SHIFT 0
+#define RG_SENINF_CAM_MUX14_VC_EN_MASK (0x1 << 0)
+#define RG_SENINF_CAM_MUX14_DT_EN_SHIFT 1
+#define RG_SENINF_CAM_MUX14_DT_EN_MASK (0x1 << 1)
+#define RG_SENINF_CAM_MUX14_VC_SEL_SHIFT 8
+#define RG_SENINF_CAM_MUX14_VC_SEL_MASK (0x1f << 8)
+#define RG_SENINF_CAM_MUX14_DT_SEL_SHIFT 16
+#define RG_SENINF_CAM_MUX14_DT_SEL_MASK (0x3f << 16)
+#define RG_SENINF_CAM_MUX14_VSYNC_BYPASS_SHIFT 24
+#define RG_SENINF_CAM_MUX14_VSYNC_BYPASS_MASK (0x1 << 24)
+
+#define SENINF_CAM_MUX15_OPT 0x005c
+#define RG_SENINF_CAM_MUX15_VC_EN_SHIFT 0
+#define RG_SENINF_CAM_MUX15_VC_EN_MASK (0x1 << 0)
+#define RG_SENINF_CAM_MUX15_DT_EN_SHIFT 1
+#define RG_SENINF_CAM_MUX15_DT_EN_MASK (0x1 << 1)
+#define RG_SENINF_CAM_MUX15_VC_SEL_SHIFT 8
+#define RG_SENINF_CAM_MUX15_VC_SEL_MASK (0x1f << 8)
+#define RG_SENINF_CAM_MUX15_DT_SEL_SHIFT 16
+#define RG_SENINF_CAM_MUX15_DT_SEL_MASK (0x3f << 16)
+#define RG_SENINF_CAM_MUX15_VSYNC_BYPASS_SHIFT 24
+#define RG_SENINF_CAM_MUX15_VSYNC_BYPASS_MASK (0x1 << 24)
+
+#define SENINF_CAM_MUX_CTRL 0x0080
+#define SENINF_CAM_MUX_SW_RST_SHIFT 0
+#define SENINF_CAM_MUX_SW_RST_MASK (0x1 << 0)
+#define SENINF_CAM_MUX_IRQ_SW_RST_SHIFT 1
+#define SENINF_CAM_MUX_IRQ_SW_RST_MASK (0x1 << 1)
+#define RG_SENINF_CAM_MUX_SLICE_FULL_OPT_SHIFT 7
+#define RG_SENINF_CAM_MUX_SLICE_FULL_OPT_MASK (0x1 << 7)
+#define RG_SENINF_CAM_MUX_IRQ_CLR_MODE_SHIFT 8
+#define RG_SENINF_CAM_MUX_IRQ_CLR_MODE_MASK (0x1 << 8)
+#define RG_SENINF_CAM_MUX_IRQ_VERIF_EN_SHIFT 9
+#define RG_SENINF_CAM_MUX_IRQ_VERIF_EN_MASK (0x1 << 9)
+
+#define SENINF_CAM_MUX_DYN_CTRL 0x0088
+#define RG_SENINF_CAM_MUX_DYN_SWITCH_BSY0_SHIFT 0
+#define RG_SENINF_CAM_MUX_DYN_SWITCH_BSY0_MASK (0x1 << 0)
+#define RG_SENINF_CAM_MUX_DYN_SWITCH_BSY1_SHIFT 4
+#define RG_SENINF_CAM_MUX_DYN_SWITCH_BSY1_MASK (0x1 << 4)
+#define CAM_MUX_DYN_PAGE_SEL_SHIFT 28
+#define CAM_MUX_DYN_PAGE_SEL_MASK (0x1 << 28)
+
+#define SENINF_CAM_MUX_DYN_EN 0x008c
+#define RG_SENINF_CAM_MUX_DYN_SWITCH_EN0_SHIFT 0
+#define RG_SENINF_CAM_MUX_DYN_SWITCH_EN0_MASK (0xffff << 0)
+#define RG_SENINF_CAM_MUX_DYN_SWITCH_EN1_SHIFT 16
+#define RG_SENINF_CAM_MUX_DYN_SWITCH_EN1_MASK (0xffff << 16)
+
+#define SENINF_CAM_MUX_NEXT_CTRL_0 0x0090
+#define CAM_MUX0_NEXT_SRC_SEL_SHIFT 0
+#define CAM_MUX0_NEXT_SRC_SEL_MASK (0xf << 0)
+#define CAM_MUX1_NEXT_SRC_SEL_SHIFT 8
+#define CAM_MUX1_NEXT_SRC_SEL_MASK (0xf << 8)
+#define CAM_MUX2_NEXT_SRC_SEL_SHIFT 16
+#define CAM_MUX2_NEXT_SRC_SEL_MASK (0xf << 16)
+#define CAM_MUX3_NEXT_SRC_SEL_SHIFT 24
+#define CAM_MUX3_NEXT_SRC_SEL_MASK (0xf << 24)
+
+#define SENINF_CAM_MUX_NEXT_CTRL_1 0x0094
+#define CAM_MUX4_NEXT_SRC_SEL_SHIFT 0
+#define CAM_MUX4_NEXT_SRC_SEL_MASK (0xf << 0)
+#define CAM_MUX5_NEXT_SRC_SEL_SHIFT 8
+#define CAM_MUX5_NEXT_SRC_SEL_MASK (0xf << 8)
+#define CAM_MUX6_NEXT_SRC_SEL_SHIFT 16
+#define CAM_MUX6_NEXT_SRC_SEL_MASK (0xf << 16)
+#define CAM_MUX7_NEXT_SRC_SEL_SHIFT 24
+#define CAM_MUX7_NEXT_SRC_SEL_MASK (0xf << 24)
+
+#define SENINF_CAM_MUX_NEXT_CTRL_2 0x0098
+#define CAM_MUX8_NEXT_SRC_SEL_SHIFT 0
+#define CAM_MUX8_NEXT_SRC_SEL_MASK (0xf << 0)
+#define CAM_MUX9_NEXT_SRC_SEL_SHIFT 8
+#define CAM_MUX9_NEXT_SRC_SEL_MASK (0xf << 8)
+#define CAM_MUX10_NEXT_SRC_SEL_SHIFT 16
+#define CAM_MUX10_NEXT_SRC_SEL_MASK (0xf << 16)
+#define CAM_MUX11_NEXT_SRC_SEL_SHIFT 24
+#define CAM_MUX11_NEXT_SRC_SEL_MASK (0xf << 24)
+
+#define SENINF_CAM_MUX_NEXT_CTRL_3 0x009c
+#define CAM_MUX12_NEXT_SRC_SEL_SHIFT 0
+#define CAM_MUX12_NEXT_SRC_SEL_MASK (0xf << 0)
+#define CAM_MUX13_NEXT_SRC_SEL_SHIFT 8
+#define CAM_MUX13_NEXT_SRC_SEL_MASK (0xf << 8)
+#define CAM_MUX14_NEXT_SRC_SEL_SHIFT 16
+#define CAM_MUX14_NEXT_SRC_SEL_MASK (0xf << 16)
+#define CAM_MUX15_NEXT_SRC_SEL_SHIFT 24
+#define CAM_MUX15_NEXT_SRC_SEL_MASK (0xf << 24)
+
+#define SENINF_CAM_MUX_IRQ_EN 0x00a0
+#define RG_SENINF_CAM_MUX0_HSIZE_ERR_IRQ_EN_SHIFT 0
+#define RG_SENINF_CAM_MUX0_HSIZE_ERR_IRQ_EN_MASK (0x1 << 0)
+#define RG_SENINF_CAM_MUX0_VSIZE_ERR_IRQ_EN_SHIFT 1
+#define RG_SENINF_CAM_MUX0_VSIZE_ERR_IRQ_EN_MASK (0x1 << 1)
+#define RG_SENINF_CAM_MUX1_HSIZE_ERR_IRQ_EN_SHIFT 2
+#define RG_SENINF_CAM_MUX1_HSIZE_ERR_IRQ_EN_MASK (0x1 << 2)
+#define RG_SENINF_CAM_MUX1_VSIZE_ERR_IRQ_EN_SHIFT 3
+#define RG_SENINF_CAM_MUX1_VSIZE_ERR_IRQ_EN_MASK (0x1 << 3)
+#define RG_SENINF_CAM_MUX2_HSIZE_ERR_IRQ_EN_SHIFT 4
+#define RG_SENINF_CAM_MUX2_HSIZE_ERR_IRQ_EN_MASK (0x1 << 4)
+#define RG_SENINF_CAM_MUX2_VSIZE_ERR_IRQ_EN_SHIFT 5
+#define RG_SENINF_CAM_MUX2_VSIZE_ERR_IRQ_EN_MASK (0x1 << 5)
+#define RG_SENINF_CAM_MUX3_HSIZE_ERR_IRQ_EN_SHIFT 6
+#define RG_SENINF_CAM_MUX3_HSIZE_ERR_IRQ_EN_MASK (0x1 << 6)
+#define RG_SENINF_CAM_MUX3_VSIZE_ERR_IRQ_EN_SHIFT 7
+#define RG_SENINF_CAM_MUX3_VSIZE_ERR_IRQ_EN_MASK (0x1 << 7)
+#define RG_SENINF_CAM_MUX4_HSIZE_ERR_IRQ_EN_SHIFT 8
+#define RG_SENINF_CAM_MUX4_HSIZE_ERR_IRQ_EN_MASK (0x1 << 8)
+#define RG_SENINF_CAM_MUX4_VSIZE_ERR_IRQ_EN_SHIFT 9
+#define RG_SENINF_CAM_MUX4_VSIZE_ERR_IRQ_EN_MASK (0x1 << 9)
+#define RG_SENINF_CAM_MUX5_HSIZE_ERR_IRQ_EN_SHIFT 10
+#define RG_SENINF_CAM_MUX5_HSIZE_ERR_IRQ_EN_MASK (0x1 << 10)
+#define RG_SENINF_CAM_MUX5_VSIZE_ERR_IRQ_EN_SHIFT 11
+#define RG_SENINF_CAM_MUX5_VSIZE_ERR_IRQ_EN_MASK (0x1 << 11)
+#define RG_SENINF_CAM_MUX6_HSIZE_ERR_IRQ_EN_SHIFT 12
+#define RG_SENINF_CAM_MUX6_HSIZE_ERR_IRQ_EN_MASK (0x1 << 12)
+#define RG_SENINF_CAM_MUX6_VSIZE_ERR_IRQ_EN_SHIFT 13
+#define RG_SENINF_CAM_MUX6_VSIZE_ERR_IRQ_EN_MASK (0x1 << 13)
+#define RG_SENINF_CAM_MUX7_HSIZE_ERR_IRQ_EN_SHIFT 14
+#define RG_SENINF_CAM_MUX7_HSIZE_ERR_IRQ_EN_MASK (0x1 << 14)
+#define RG_SENINF_CAM_MUX7_VSIZE_ERR_IRQ_EN_SHIFT 15
+#define RG_SENINF_CAM_MUX7_VSIZE_ERR_IRQ_EN_MASK (0x1 << 15)
+#define RG_SENINF_CAM_MUX8_HSIZE_ERR_IRQ_EN_SHIFT 16
+#define RG_SENINF_CAM_MUX8_HSIZE_ERR_IRQ_EN_MASK (0x1 << 16)
+#define RG_SENINF_CAM_MUX8_VSIZE_ERR_IRQ_EN_SHIFT 17
+#define RG_SENINF_CAM_MUX8_VSIZE_ERR_IRQ_EN_MASK (0x1 << 17)
+#define RG_SENINF_CAM_MUX9_HSIZE_ERR_IRQ_EN_SHIFT 18
+#define RG_SENINF_CAM_MUX9_HSIZE_ERR_IRQ_EN_MASK (0x1 << 18)
+#define RG_SENINF_CAM_MUX9_VSIZE_ERR_IRQ_EN_SHIFT 19
+#define RG_SENINF_CAM_MUX9_VSIZE_ERR_IRQ_EN_MASK (0x1 << 19)
+#define RG_SENINF_CAM_MUX10_HSIZE_ERR_IRQ_EN_SHIFT 20
+#define RG_SENINF_CAM_MUX10_HSIZE_ERR_IRQ_EN_MASK (0x1 << 20)
+#define RG_SENINF_CAM_MUX10_VSIZE_ERR_IRQ_EN_SHIFT 21
+#define RG_SENINF_CAM_MUX10_VSIZE_ERR_IRQ_EN_MASK (0x1 << 21)
+#define RG_SENINF_CAM_MUX11_HSIZE_ERR_IRQ_EN_SHIFT 22
+#define RG_SENINF_CAM_MUX11_HSIZE_ERR_IRQ_EN_MASK (0x1 << 22)
+#define RG_SENINF_CAM_MUX11_VSIZE_ERR_IRQ_EN_SHIFT 23
+#define RG_SENINF_CAM_MUX11_VSIZE_ERR_IRQ_EN_MASK (0x1 << 23)
+#define RG_SENINF_CAM_MUX12_HSIZE_ERR_IRQ_EN_SHIFT 24
+#define RG_SENINF_CAM_MUX12_HSIZE_ERR_IRQ_EN_MASK (0x1 << 24)
+#define RG_SENINF_CAM_MUX12_VSIZE_ERR_IRQ_EN_SHIFT 25
+#define RG_SENINF_CAM_MUX12_VSIZE_ERR_IRQ_EN_MASK (0x1 << 25)
+#define RG_SENINF_CAM_MUX13_HSIZE_ERR_IRQ_EN_SHIFT 26
+#define RG_SENINF_CAM_MUX13_HSIZE_ERR_IRQ_EN_MASK (0x1 << 26)
+#define RG_SENINF_CAM_MUX13_VSIZE_ERR_IRQ_EN_SHIFT 27
+#define RG_SENINF_CAM_MUX13_VSIZE_ERR_IRQ_EN_MASK (0x1 << 27)
+#define RG_SENINF_CAM_MUX14_HSIZE_ERR_IRQ_EN_SHIFT 28
+#define RG_SENINF_CAM_MUX14_HSIZE_ERR_IRQ_EN_MASK (0x1 << 28)
+#define RG_SENINF_CAM_MUX14_VSIZE_ERR_IRQ_EN_SHIFT 29
+#define RG_SENINF_CAM_MUX14_VSIZE_ERR_IRQ_EN_MASK (0x1 << 29)
+#define RG_SENINF_CAM_MUX15_HSIZE_ERR_IRQ_EN_SHIFT 30
+#define RG_SENINF_CAM_MUX15_HSIZE_ERR_IRQ_EN_MASK (0x1 << 30)
+#define RG_SENINF_CAM_MUX15_VSIZE_ERR_IRQ_EN_SHIFT 31
+#define RG_SENINF_CAM_MUX15_VSIZE_ERR_IRQ_EN_MASK (0x1 << 31)
+
+#define SENINF_CAM_MUX_IRQ_STATUS 0x00a8
+#define RO_SENINF_CAM_MUX0_HSIZE_ERR_IRQ_SHIFT 0
+#define RO_SENINF_CAM_MUX0_HSIZE_ERR_IRQ_MASK (0x1 << 0)
+#define RO_SENINF_CAM_MUX0_VSIZE_ERR_IRQ_SHIFT 1
+#define RO_SENINF_CAM_MUX0_VSIZE_ERR_IRQ_MASK (0x1 << 1)
+#define RO_SENINF_CAM_MUX1_HSIZE_ERR_IRQ_SHIFT 2
+#define RO_SENINF_CAM_MUX1_HSIZE_ERR_IRQ_MASK (0x1 << 2)
+#define RO_SENINF_CAM_MUX1_VSIZE_ERR_IRQ_SHIFT 3
+#define RO_SENINF_CAM_MUX1_VSIZE_ERR_IRQ_MASK (0x1 << 3)
+#define RO_SENINF_CAM_MUX2_HSIZE_ERR_IRQ_SHIFT 4
+#define RO_SENINF_CAM_MUX2_HSIZE_ERR_IRQ_MASK (0x1 << 4)
+#define RO_SENINF_CAM_MUX2_VSIZE_ERR_IRQ_SHIFT 5
+#define RO_SENINF_CAM_MUX2_VSIZE_ERR_IRQ_MASK (0x1 << 5)
+#define RO_SENINF_CAM_MUX3_HSIZE_ERR_IRQ_SHIFT 6
+#define RO_SENINF_CAM_MUX3_HSIZE_ERR_IRQ_MASK (0x1 << 6)
+#define RO_SENINF_CAM_MUX3_VSIZE_ERR_IRQ_SHIFT 7
+#define RO_SENINF_CAM_MUX3_VSIZE_ERR_IRQ_MASK (0x1 << 7)
+#define RO_SENINF_CAM_MUX4_HSIZE_ERR_IRQ_SHIFT 8
+#define RO_SENINF_CAM_MUX4_HSIZE_ERR_IRQ_MASK (0x1 << 8)
+#define RO_SENINF_CAM_MUX4_VSIZE_ERR_IRQ_SHIFT 9
+#define RO_SENINF_CAM_MUX4_VSIZE_ERR_IRQ_MASK (0x1 << 9)
+#define RO_SENINF_CAM_MUX5_HSIZE_ERR_IRQ_SHIFT 10
+#define RO_SENINF_CAM_MUX5_HSIZE_ERR_IRQ_MASK (0x1 << 10)
+#define RO_SENINF_CAM_MUX5_VSIZE_ERR_IRQ_SHIFT 11
+#define RO_SENINF_CAM_MUX5_VSIZE_ERR_IRQ_MASK (0x1 << 11)
+#define RO_SENINF_CAM_MUX6_HSIZE_ERR_IRQ_SHIFT 12
+#define RO_SENINF_CAM_MUX6_HSIZE_ERR_IRQ_MASK (0x1 << 12)
+#define RO_SENINF_CAM_MUX6_VSIZE_ERR_IRQ_SHIFT 13
+#define RO_SENINF_CAM_MUX6_VSIZE_ERR_IRQ_MASK (0x1 << 13)
+#define RO_SENINF_CAM_MUX7_HSIZE_ERR_IRQ_SHIFT 14
+#define RO_SENINF_CAM_MUX7_HSIZE_ERR_IRQ_MASK (0x1 << 14)
+#define RO_SENINF_CAM_MUX7_VSIZE_ERR_IRQ_SHIFT 15
+#define RO_SENINF_CAM_MUX7_VSIZE_ERR_IRQ_MASK (0x1 << 15)
+#define RO_SENINF_CAM_MUX8_HSIZE_ERR_IRQ_SHIFT 16
+#define RO_SENINF_CAM_MUX8_HSIZE_ERR_IRQ_MASK (0x1 << 16)
+#define RO_SENINF_CAM_MUX8_VSIZE_ERR_IRQ_SHIFT 17
+#define RO_SENINF_CAM_MUX8_VSIZE_ERR_IRQ_MASK (0x1 << 17)
+#define RO_SENINF_CAM_MUX9_HSIZE_ERR_IRQ_SHIFT 18
+#define RO_SENINF_CAM_MUX9_HSIZE_ERR_IRQ_MASK (0x1 << 18)
+#define RO_SENINF_CAM_MUX9_VSIZE_ERR_IRQ_SHIFT 19
+#define RO_SENINF_CAM_MUX9_VSIZE_ERR_IRQ_MASK (0x1 << 19)
+#define RO_SENINF_CAM_MUX10_HSIZE_ERR_IRQ_SHIFT 20
+#define RO_SENINF_CAM_MUX10_HSIZE_ERR_IRQ_MASK (0x1 << 20)
+#define RO_SENINF_CAM_MUX10_VSIZE_ERR_IRQ_SHIFT 21
+#define RO_SENINF_CAM_MUX10_VSIZE_ERR_IRQ_MASK (0x1 << 21)
+#define RO_SENINF_CAM_MUX11_HSIZE_ERR_IRQ_SHIFT 22
+#define RO_SENINF_CAM_MUX11_HSIZE_ERR_IRQ_MASK (0x1 << 22)
+#define RO_SENINF_CAM_MUX11_VSIZE_ERR_IRQ_SHIFT 23
+#define RO_SENINF_CAM_MUX11_VSIZE_ERR_IRQ_MASK (0x1 << 23)
+#define RO_SENINF_CAM_MUX12_HSIZE_ERR_IRQ_SHIFT 24
+#define RO_SENINF_CAM_MUX12_HSIZE_ERR_IRQ_MASK (0x1 << 24)
+#define RO_SENINF_CAM_MUX12_VSIZE_ERR_IRQ_SHIFT 25
+#define RO_SENINF_CAM_MUX12_VSIZE_ERR_IRQ_MASK (0x1 << 25)
+#define RO_SENINF_CAM_MUX13_HSIZE_ERR_IRQ_SHIFT 26
+#define RO_SENINF_CAM_MUX13_HSIZE_ERR_IRQ_MASK (0x1 << 26)
+#define RO_SENINF_CAM_MUX13_VSIZE_ERR_IRQ_SHIFT 27
+#define RO_SENINF_CAM_MUX13_VSIZE_ERR_IRQ_MASK (0x1 << 27)
+#define RO_SENINF_CAM_MUX14_HSIZE_ERR_IRQ_SHIFT 28
+#define RO_SENINF_CAM_MUX14_HSIZE_ERR_IRQ_MASK (0x1 << 28)
+#define RO_SENINF_CAM_MUX14_VSIZE_ERR_IRQ_SHIFT 29
+#define RO_SENINF_CAM_MUX14_VSIZE_ERR_IRQ_MASK (0x1 << 29)
+#define RO_SENINF_CAM_MUX15_HSIZE_ERR_IRQ_SHIFT 30
+#define RO_SENINF_CAM_MUX15_HSIZE_ERR_IRQ_MASK (0x1 << 30)
+#define RO_SENINF_CAM_MUX15_VSIZE_ERR_IRQ_SHIFT 31
+#define RO_SENINF_CAM_MUX15_VSIZE_ERR_IRQ_MASK (0x1 << 31)
+
+#define SENINF_CAM_MUX_IRQ_TRIG 0x00ac
+#define RG_SENINF_CAM_MUX_IRQ_TRIG_SHIFT 0
+#define RG_SENINF_CAM_MUX_IRQ_TRIG_MASK (0xffffffff << 0)
+
+#define SENINF_CAM_MUX_VSYNC_IRQ_EN 0x00b0
+#define RG_SENINF_CAM_MUX_VSYNC_IRQ_EN_SHIFT 0
+#define RG_SENINF_CAM_MUX_VSYNC_IRQ_EN_MASK (0xffff << 0)
+#define RG_SENINF_CAM_MUX_VSYNC_ALL_IRQ_EN_SHIFT 24
+#define RG_SENINF_CAM_MUX_VSYNC_ALL_IRQ_EN_MASK (0x3 << 24)
+#define RG_SENINF_CAM_MUX_VSYNC_ALL_NONE_IRQ_EN_SHIFT 28
+#define RG_SENINF_CAM_MUX_VSYNC_ALL_NONE_IRQ_EN_MASK (0x3 << 28)
+
+#define SENINF_CAM_MUX_VSYNC_IRQ_STS 0x00b4
+#define RO_SENINF_CAM_MUX_VSYNC_IRQ_SHIFT 0
+#define RO_SENINF_CAM_MUX_VSYNC_IRQ_MASK (0xffff << 0)
+#define RO_SENINF_CAM_MUX_VSYNC_ALL_IRQ_SHIFT 24
+#define RO_SENINF_CAM_MUX_VSYNC_ALL_IRQ_MASK (0x3 << 24)
+#define RG_SENINF_CAM_MUX_VSYNC_ALL_NONE_IRQ_SHIFT 28
+#define RG_SENINF_CAM_MUX_VSYNC_ALL_NONE_IRQ_MASK (0x3 << 28)
+
+#define SENINF_CAM_MUX_VSYNC_IRQ_TRIG 0x00bc
+#define RG_SENINF_CAM_MUX_VSYNC_IRQ_TRIG_SHIFT 0
+#define RG_SENINF_CAM_MUX_VSYNC_IRQ_TRIG_MASK (0xffffffff << 0)
+
+#define SENINF_CAM_MUX_DBG_CTRL 0x00c0
+#define RG_SENINF_CAM_MUX_DBG_EN_SHIFT 0
+#define RG_SENINF_CAM_MUX_DBG_EN_MASK (0x1 << 0)
+#define RG_SENINF_CAM_MUX_DBG_SEL_SHIFT 8
+#define RG_SENINF_CAM_MUX_DBG_SEL_MASK (0xff << 8)
+
+#define SENINF_CAM_MUX_DBG_OUT 0x00c4
+#define RO_SENINF_CAM_MUX_DBG_OUT_SHIFT 0
+#define RO_SENINF_CAM_MUX_DBG_OUT_MASK (0xffffffff << 0)
+
+#define SENINF_CAM_MUX_VSYNC_T0_WINDOW_L 0x00d0
+#define RG_SENINF_CAM_MUX_VSYNC_TIMER0_WINDOW_L_SHIFT 0
+#define RG_SENINF_CAM_MUX_VSYNC_TIMER0_WINDOW_L_MASK (0xffffffff << 0)
+
+#define SENINF_CAM_MUX_VSYNC_T1_WINDOW_L 0x00d8
+#define RG_SENINF_CAM_MUX_VSYNC_TIMER1_WINDOW_L_SHIFT 0
+#define RG_SENINF_CAM_MUX_VSYNC_TIMER1_WINDOW_L_MASK (0xffffffff << 0)
+
+#define SENINF_CAM_MUX_SAT_IRQ_EN 0x00e0
+#define RG_SENINF_CAM_MUX_SKIP_NEXT_FRAME_EN_RISE0_IRQ_EN_SHIFT 0
+#define RG_SENINF_CAM_MUX_SKIP_NEXT_FRAME_EN_RISE0_IRQ_EN_MASK (0x1 << 0)
+#define RG_SENINF_CAM_MUX_SKIP_NEXT_FRAME_EN_RISE1_IRQ_EN_SHIFT 1
+#define RG_SENINF_CAM_MUX_SKIP_NEXT_FRAME_EN_RISE1_IRQ_EN_MASK (0x1 << 1)
+
+#define SENINF_CAM_MUX_SAT_IRQ_STATUS 0x00e8
+#define RO_SENINF_CAM_MUX_SKIP_NEXT_FRAME_EN_RISE0_IRQ_SHIFT 0
+#define RO_SENINF_CAM_MUX_SKIP_NEXT_FRAME_EN_RISE0_IRQ_MASK (0x1 << 0)
+#define RO_SENINF_CAM_MUX_SKIP_NEXT_FRAME_EN_RISE1_IRQ_SHIFT 1
+#define RO_SENINF_CAM_MUX_SKIP_NEXT_FRAME_EN_RISE1_IRQ_MASK (0x1 << 1)
+
+#define SENINF_CAM_MUX_SAT_IRQ_TRIG 0x00ec
+#define RG_SENINF_CAM_MUX_SKIP_NEXT_FRAME_EN_RISE_IRQ_TRIG_SHIFT 0
+#define RG_SENINF_CAM_MUX_SKIP_NEXT_FRAME_EN_RISE_IRQ_TRIG_MASK (0xffffffff << 0)
+
+#define SENINF_CAM_SPARE 0x00f8
+#define RG_SENINF_TOP_SPARE_0_SHIFT 0
+#define RG_SENINF_TOP_SPARE_0_MASK (0xff << 0)
+#define RG_SENINF_TOP_SPARE_1_SHIFT 16
+#define RG_SENINF_TOP_SPARE_1_MASK (0xff << 16)
+
+#define SENINF_CAM_MUX0_CHK_CTL_0 0x0100
+#define RG_SENINF_CAM_MUX0_PIX_MODE_SEL_SHIFT 0
+#define RG_SENINF_CAM_MUX0_PIX_MODE_SEL_MASK (0x3 << 0)
+
+#define SENINF_CAM_MUX0_CHK_CTL_1 0x0104
+#define RG_SENINF_CAM_MUX0_EXP_HSIZE_SHIFT 0
+#define RG_SENINF_CAM_MUX0_EXP_HSIZE_MASK (0xffff << 0)
+#define RG_SENINF_CAM_MUX0_EXP_VSIZE_SHIFT 16
+#define RG_SENINF_CAM_MUX0_EXP_VSIZE_MASK (0xffff << 16)
+
+#define SENINF_CAM_MUX0_CHK_RES 0x0108
+#define RO_SENINF_CAM_MUX0_RCV_HSIZE_SHIFT 0
+#define RO_SENINF_CAM_MUX0_RCV_HSIZE_MASK (0xffff << 0)
+#define RO_SENINF_CAM_MUX0_RCV_VSIZE_SHIFT 16
+#define RO_SENINF_CAM_MUX0_RCV_VSIZE_MASK (0xffff << 16)
+
+#define SENINF_CAM_MUX0_CHK_ERR_RES 0x010c
+#define RO_SENINF_CAM_MUX0_RCV_ERR_HSIZE_SHIFT 0
+#define RO_SENINF_CAM_MUX0_RCV_ERR_HSIZE_MASK (0xffff << 0)
+#define RO_SENINF_CAM_MUX0_RCV_ERR_VSIZE_SHIFT 16
+#define RO_SENINF_CAM_MUX0_RCV_ERR_VSIZE_MASK (0xffff << 16)
+
+#define SENINF_CAM_MUX1_CHK_CTL_0 0x0110
+#define RG_SENINF_CAM_MUX1_PIX_MODE_SEL_SHIFT 0
+#define RG_SENINF_CAM_MUX1_PIX_MODE_SEL_MASK (0x3 << 0)
+
+#define SENINF_CAM_MUX1_CHK_CTL_1 0x0114
+#define RG_SENINF_CAM_MUX1_EXP_HSIZE_SHIFT 0
+#define RG_SENINF_CAM_MUX1_EXP_HSIZE_MASK (0xffff << 0)
+#define RG_SENINF_CAM_MUX1_EXP_VSIZE_SHIFT 16
+#define RG_SENINF_CAM_MUX1_EXP_VSIZE_MASK (0xffff << 16)
+
+#define SENINF_CAM_MUX1_CHK_RES 0x0118
+#define RO_SENINF_CAM_MUX1_RCV_HSIZE_SHIFT 0
+#define RO_SENINF_CAM_MUX1_RCV_HSIZE_MASK (0xffff << 0)
+#define RO_SENINF_CAM_MUX1_RCV_VSIZE_SHIFT 16
+#define RO_SENINF_CAM_MUX1_RCV_VSIZE_MASK (0xffff << 16)
+
+#define SENINF_CAM_MUX1_CHK_ERR_RES 0x011c
+#define RO_SENINF_CAM_MUX1_RCV_ERR_HSIZE_SHIFT 0
+#define RO_SENINF_CAM_MUX1_RCV_ERR_HSIZE_MASK (0xffff << 0)
+#define RO_SENINF_CAM_MUX1_RCV_ERR_VSIZE_SHIFT 16
+#define RO_SENINF_CAM_MUX1_RCV_ERR_VSIZE_MASK (0xffff << 16)
+
+#define SENINF_CAM_MUX2_CHK_CTL_0 0x0120
+#define RG_SENINF_CAM_MUX2_PIX_MODE_SEL_SHIFT 0
+#define RG_SENINF_CAM_MUX2_PIX_MODE_SEL_MASK (0x3 << 0)
+
+#define SENINF_CAM_MUX2_CHK_CTL_1 0x0124
+#define RG_SENINF_CAM_MUX2_EXP_HSIZE_SHIFT 0
+#define RG_SENINF_CAM_MUX2_EXP_HSIZE_MASK (0xffff << 0)
+#define RG_SENINF_CAM_MUX2_EXP_VSIZE_SHIFT 16
+#define RG_SENINF_CAM_MUX2_EXP_VSIZE_MASK (0xffff << 16)
+
+#define SENINF_CAM_MUX2_CHK_RES 0x0128
+#define RO_SENINF_CAM_MUX2_RCV_HSIZE_SHIFT 0
+#define RO_SENINF_CAM_MUX2_RCV_HSIZE_MASK (0xffff << 0)
+#define RO_SENINF_CAM_MUX2_RCV_VSIZE_SHIFT 16
+#define RO_SENINF_CAM_MUX2_RCV_VSIZE_MASK (0xffff << 16)
+
+#define SENINF_CAM_MUX2_CHK_ERR_RES 0x012c
+#define RO_SENINF_CAM_MUX2_RCV_ERR_HSIZE_SHIFT 0
+#define RO_SENINF_CAM_MUX2_RCV_ERR_HSIZE_MASK (0xffff << 0)
+#define RO_SENINF_CAM_MUX2_RCV_ERR_VSIZE_SHIFT 16
+#define RO_SENINF_CAM_MUX2_RCV_ERR_VSIZE_MASK (0xffff << 16)
+
+#define SENINF_CAM_MUX3_CHK_CTL_0 0x0130
+#define RG_SENINF_CAM_MUX3_PIX_MODE_SEL_SHIFT 0
+#define RG_SENINF_CAM_MUX3_PIX_MODE_SEL_MASK (0x3 << 0)
+
+#define SENINF_CAM_MUX3_CHK_CTL_1 0x0134
+#define RG_SENINF_CAM_MUX3_EXP_HSIZE_SHIFT 0
+#define RG_SENINF_CAM_MUX3_EXP_HSIZE_MASK (0xffff << 0)
+#define RG_SENINF_CAM_MUX3_EXP_VSIZE_SHIFT 16
+#define RG_SENINF_CAM_MUX3_EXP_VSIZE_MASK (0xffff << 16)
+
+#define SENINF_CAM_MUX3_CHK_RES 0x0138
+#define RO_SENINF_CAM_MUX3_RCV_HSIZE_SHIFT 0
+#define RO_SENINF_CAM_MUX3_RCV_HSIZE_MASK (0xffff << 0)
+#define RO_SENINF_CAM_MUX3_RCV_VSIZE_SHIFT 16
+#define RO_SENINF_CAM_MUX3_RCV_VSIZE_MASK (0xffff << 16)
+
+#define SENINF_CAM_MUX3_CHK_ERR_RES 0x013c
+#define RO_SENINF_CAM_MUX3_RCV_ERR_HSIZE_SHIFT 0
+#define RO_SENINF_CAM_MUX3_RCV_ERR_HSIZE_MASK (0xffff << 0)
+#define RO_SENINF_CAM_MUX3_RCV_ERR_VSIZE_SHIFT 16
+#define RO_SENINF_CAM_MUX3_RCV_ERR_VSIZE_MASK (0xffff << 16)
+
+#define SENINF_CAM_MUX4_CHK_CTL_0 0x0140
+#define RG_SENINF_CAM_MUX4_PIX_MODE_SEL_SHIFT 0
+#define RG_SENINF_CAM_MUX4_PIX_MODE_SEL_MASK (0x3 << 0)
+
+#define SENINF_CAM_MUX4_CHK_CTL_1 0x0144
+#define RG_SENINF_CAM_MUX4_EXP_HSIZE_SHIFT 0
+#define RG_SENINF_CAM_MUX4_EXP_HSIZE_MASK (0xffff << 0)
+#define RG_SENINF_CAM_MUX4_EXP_VSIZE_SHIFT 16
+#define RG_SENINF_CAM_MUX4_EXP_VSIZE_MASK (0xffff << 16)
+
+#define SENINF_CAM_MUX4_CHK_RES 0x0148
+#define RO_SENINF_CAM_MUX4_RCV_HSIZE_SHIFT 0
+#define RO_SENINF_CAM_MUX4_RCV_HSIZE_MASK (0xffff << 0)
+#define RO_SENINF_CAM_MUX4_RCV_VSIZE_SHIFT 16
+#define RO_SENINF_CAM_MUX4_RCV_VSIZE_MASK (0xffff << 16)
+
+#define SENINF_CAM_MUX4_CHK_ERR_RES 0x014c
+#define RO_SENINF_CAM_MUX4_RCV_ERR_HSIZE_SHIFT 0
+#define RO_SENINF_CAM_MUX4_RCV_ERR_HSIZE_MASK (0xffff << 0)
+#define RO_SENINF_CAM_MUX4_RCV_ERR_VSIZE_SHIFT 16
+#define RO_SENINF_CAM_MUX4_RCV_ERR_VSIZE_MASK (0xffff << 16)
+
+#define SENINF_CAM_MUX5_CHK_CTL_0 0x0150
+#define RG_SENINF_CAM_MUX5_PIX_MODE_SEL_SHIFT 0
+#define RG_SENINF_CAM_MUX5_PIX_MODE_SEL_MASK (0x3 << 0)
+
+#define SENINF_CAM_MUX5_CHK_CTL_1 0x0154
+#define RG_SENINF_CAM_MUX5_EXP_HSIZE_SHIFT 0
+#define RG_SENINF_CAM_MUX5_EXP_HSIZE_MASK (0xffff << 0)
+#define RG_SENINF_CAM_MUX5_EXP_VSIZE_SHIFT 16
+#define RG_SENINF_CAM_MUX5_EXP_VSIZE_MASK (0xffff << 16)
+
+#define SENINF_CAM_MUX5_CHK_RES 0x0158
+#define RO_SENINF_CAM_MUX5_RCV_HSIZE_SHIFT 0
+#define RO_SENINF_CAM_MUX5_RCV_HSIZE_MASK (0xffff << 0)
+#define RO_SENINF_CAM_MUX5_RCV_VSIZE_SHIFT 16
+#define RO_SENINF_CAM_MUX5_RCV_VSIZE_MASK (0xffff << 16)
+
+#define SENINF_CAM_MUX5_CHK_ERR_RES 0x015c
+#define RO_SENINF_CAM_MUX5_RCV_ERR_HSIZE_SHIFT 0
+#define RO_SENINF_CAM_MUX5_RCV_ERR_HSIZE_MASK (0xffff << 0)
+#define RO_SENINF_CAM_MUX5_RCV_ERR_VSIZE_SHIFT 16
+#define RO_SENINF_CAM_MUX5_RCV_ERR_VSIZE_MASK (0xffff << 16)
+
+#define SENINF_CAM_MUX6_CHK_CTL_0 0x0160
+#define RG_SENINF_CAM_MUX6_PIX_MODE_SEL_SHIFT 0
+#define RG_SENINF_CAM_MUX6_PIX_MODE_SEL_MASK (0x3 << 0)
+
+#define SENINF_CAM_MUX6_CHK_CTL_1 0x0164
+#define RG_SENINF_CAM_MUX6_EXP_HSIZE_SHIFT 0
+#define RG_SENINF_CAM_MUX6_EXP_HSIZE_MASK (0xffff << 0)
+#define RG_SENINF_CAM_MUX6_EXP_VSIZE_SHIFT 16
+#define RG_SENINF_CAM_MUX6_EXP_VSIZE_MASK (0xffff << 16)
+
+#define SENINF_CAM_MUX6_CHK_RES 0x0168
+#define RO_SENINF_CAM_MUX6_RCV_HSIZE_SHIFT 0
+#define RO_SENINF_CAM_MUX6_RCV_HSIZE_MASK (0xffff << 0)
+#define RO_SENINF_CAM_MUX6_RCV_VSIZE_SHIFT 16
+#define RO_SENINF_CAM_MUX6_RCV_VSIZE_MASK (0xffff << 16)
+
+#define SENINF_CAM_MUX6_CHK_ERR_RES 0x016c
+#define RO_SENINF_CAM_MUX6_RCV_ERR_HSIZE_SHIFT 0
+#define RO_SENINF_CAM_MUX6_RCV_ERR_HSIZE_MASK (0xffff << 0)
+#define RO_SENINF_CAM_MUX6_RCV_ERR_VSIZE_SHIFT 16
+#define RO_SENINF_CAM_MUX6_RCV_ERR_VSIZE_MASK (0xffff << 16)
+
+#define SENINF_CAM_MUX7_CHK_CTL_0 0x0170
+#define RG_SENINF_CAM_MUX7_PIX_MODE_SEL_SHIFT 0
+#define RG_SENINF_CAM_MUX7_PIX_MODE_SEL_MASK (0x3 << 0)
+
+#define SENINF_CAM_MUX7_CHK_CTL_1 0x0174
+#define RG_SENINF_CAM_MUX7_EXP_HSIZE_SHIFT 0
+#define RG_SENINF_CAM_MUX7_EXP_HSIZE_MASK (0xffff << 0)
+#define RG_SENINF_CAM_MUX7_EXP_VSIZE_SHIFT 16
+#define RG_SENINF_CAM_MUX7_EXP_VSIZE_MASK (0xffff << 16)
+
+#define SENINF_CAM_MUX7_CHK_RES 0x0178
+#define RO_SENINF_CAM_MUX7_RCV_HSIZE_SHIFT 0
+#define RO_SENINF_CAM_MUX7_RCV_HSIZE_MASK (0xffff << 0)
+#define RO_SENINF_CAM_MUX7_RCV_VSIZE_SHIFT 16
+#define RO_SENINF_CAM_MUX7_RCV_VSIZE_MASK (0xffff << 16)
+
+#define SENINF_CAM_MUX7_CHK_ERR_RES 0x017c
+#define RO_SENINF_CAM_MUX7_RCV_ERR_HSIZE_SHIFT 0
+#define RO_SENINF_CAM_MUX7_RCV_ERR_HSIZE_MASK (0xffff << 0)
+#define RO_SENINF_CAM_MUX7_RCV_ERR_VSIZE_SHIFT 16
+#define RO_SENINF_CAM_MUX7_RCV_ERR_VSIZE_MASK (0xffff << 16)
+
+#define SENINF_CAM_MUX8_CHK_CTL_0 0x0180
+#define RG_SENINF_CAM_MUX8_PIX_MODE_SEL_SHIFT 0
+#define RG_SENINF_CAM_MUX8_PIX_MODE_SEL_MASK (0x3 << 0)
+
+#define SENINF_CAM_MUX8_CHK_CTL_1 0x0184
+#define RG_SENINF_CAM_MUX8_EXP_HSIZE_SHIFT 0
+#define RG_SENINF_CAM_MUX8_EXP_HSIZE_MASK (0xffff << 0)
+#define RG_SENINF_CAM_MUX8_EXP_VSIZE_SHIFT 16
+#define RG_SENINF_CAM_MUX8_EXP_VSIZE_MASK (0xffff << 16)
+
+#define SENINF_CAM_MUX8_CHK_RES 0x0188
+#define RO_SENINF_CAM_MUX8_RCV_HSIZE_SHIFT 0
+#define RO_SENINF_CAM_MUX8_RCV_HSIZE_MASK (0xffff << 0)
+#define RO_SENINF_CAM_MUX8_RCV_VSIZE_SHIFT 16
+#define RO_SENINF_CAM_MUX8_RCV_VSIZE_MASK (0xffff << 16)
+
+#define SENINF_CAM_MUX8_CHK_ERR_RES 0x018c
+#define RO_SENINF_CAM_MUX8_RCV_ERR_HSIZE_SHIFT 0
+#define RO_SENINF_CAM_MUX8_RCV_ERR_HSIZE_MASK (0xffff << 0)
+#define RO_SENINF_CAM_MUX8_RCV_ERR_VSIZE_SHIFT 16
+#define RO_SENINF_CAM_MUX8_RCV_ERR_VSIZE_MASK (0xffff << 16)
+
+#define SENINF_CAM_MUX9_CHK_CTL_0 0x0190
+#define RG_SENINF_CAM_MUX9_PIX_MODE_SEL_SHIFT 0
+#define RG_SENINF_CAM_MUX9_PIX_MODE_SEL_MASK (0x3 << 0)
+
+#define SENINF_CAM_MUX9_CHK_CTL_1 0x0194
+#define RG_SENINF_CAM_MUX9_EXP_HSIZE_SHIFT 0
+#define RG_SENINF_CAM_MUX9_EXP_HSIZE_MASK (0xffff << 0)
+#define RG_SENINF_CAM_MUX9_EXP_VSIZE_SHIFT 16
+#define RG_SENINF_CAM_MUX9_EXP_VSIZE_MASK (0xffff << 16)
+
+#define SENINF_CAM_MUX9_CHK_RES 0x0198
+#define RO_SENINF_CAM_MUX9_RCV_HSIZE_SHIFT 0
+#define RO_SENINF_CAM_MUX9_RCV_HSIZE_MASK (0xffff << 0)
+#define RO_SENINF_CAM_MUX9_RCV_VSIZE_SHIFT 16
+#define RO_SENINF_CAM_MUX9_RCV_VSIZE_MASK (0xffff << 16)
+
+#define SENINF_CAM_MUX9_CHK_ERR_RES 0x019c
+#define RO_SENINF_CAM_MUX9_RCV_ERR_HSIZE_SHIFT 0
+#define RO_SENINF_CAM_MUX9_RCV_ERR_HSIZE_MASK (0xffff << 0)
+#define RO_SENINF_CAM_MUX9_RCV_ERR_VSIZE_SHIFT 16
+#define RO_SENINF_CAM_MUX9_RCV_ERR_VSIZE_MASK (0xffff << 16)
+
+#define SENINF_CAM_MUX10_CHK_CTL_0 0x01a0
+#define RG_SENINF_CAM_MUX10_PIX_MODE_SEL_SHIFT 0
+#define RG_SENINF_CAM_MUX10_PIX_MODE_SEL_MASK (0x3 << 0)
+
+#define SENINF_CAM_MUX10_CHK_CTL_1 0x01a4
+#define RG_SENINF_CAM_MUX10_EXP_HSIZE_SHIFT 0
+#define RG_SENINF_CAM_MUX10_EXP_HSIZE_MASK (0xffff << 0)
+#define RG_SENINF_CAM_MUX10_EXP_VSIZE_SHIFT 16
+#define RG_SENINF_CAM_MUX10_EXP_VSIZE_MASK (0xffff << 16)
+
+#define SENINF_CAM_MUX10_CHK_RES 0x01a8
+#define RO_SENINF_CAM_MUX10_RCV_HSIZE_SHIFT 0
+#define RO_SENINF_CAM_MUX10_RCV_HSIZE_MASK (0xffff << 0)
+#define RO_SENINF_CAM_MUX10_RCV_VSIZE_SHIFT 16
+#define RO_SENINF_CAM_MUX10_RCV_VSIZE_MASK (0xffff << 16)
+
+#define SENINF_CAM_MUX10_CHK_ERR_RES 0x01ac
+#define RO_SENINF_CAM_MUX10_RCV_ERR_HSIZE_SHIFT 0
+#define RO_SENINF_CAM_MUX10_RCV_ERR_HSIZE_MASK (0xffff << 0)
+#define RO_SENINF_CAM_MUX10_RCV_ERR_VSIZE_SHIFT 16
+#define RO_SENINF_CAM_MUX10_RCV_ERR_VSIZE_MASK (0xffff << 16)
+
+#define SENINF_CAM_MUX11_CHK_CTL_0 0x01b0
+#define RG_SENINF_CAM_MUX11_PIX_MODE_SEL_SHIFT 0
+#define RG_SENINF_CAM_MUX11_PIX_MODE_SEL_MASK (0x3 << 0)
+
+#define SENINF_CAM_MUX11_CHK_CTL_1 0x01b4
+#define RG_SENINF_CAM_MUX11_EXP_HSIZE_SHIFT 0
+#define RG_SENINF_CAM_MUX11_EXP_HSIZE_MASK (0xffff << 0)
+#define RG_SENINF_CAM_MUX11_EXP_VSIZE_SHIFT 16
+#define RG_SENINF_CAM_MUX11_EXP_VSIZE_MASK (0xffff << 16)
+
+#define SENINF_CAM_MUX11_CHK_RES 0x01b8
+#define RO_SENINF_CAM_MUX11_RCV_HSIZE_SHIFT 0
+#define RO_SENINF_CAM_MUX11_RCV_HSIZE_MASK (0xffff << 0)
+#define RO_SENINF_CAM_MUX11_RCV_VSIZE_SHIFT 16
+#define RO_SENINF_CAM_MUX11_RCV_VSIZE_MASK (0xffff << 16)
+
+#define SENINF_CAM_MUX11_CHK_ERR_RES 0x01bc
+#define RO_SENINF_CAM_MUX11_RCV_ERR_HSIZE_SHIFT 0
+#define RO_SENINF_CAM_MUX11_RCV_ERR_HSIZE_MASK (0xffff << 0)
+#define RO_SENINF_CAM_MUX11_RCV_ERR_VSIZE_SHIFT 16
+#define RO_SENINF_CAM_MUX11_RCV_ERR_VSIZE_MASK (0xffff << 16)
+
+#define SENINF_CAM_MUX12_CHK_CTL_0 0x01c0
+#define RG_SENINF_CAM_MUX12_PIX_MODE_SEL_SHIFT 0
+#define RG_SENINF_CAM_MUX12_PIX_MODE_SEL_MASK (0x3 << 0)
+
+#define SENINF_CAM_MUX12_CHK_CTL_1 0x01c4
+#define RG_SENINF_CAM_MUX12_EXP_HSIZE_SHIFT 0
+#define RG_SENINF_CAM_MUX12_EXP_HSIZE_MASK (0xffff << 0)
+#define RG_SENINF_CAM_MUX12_EXP_VSIZE_SHIFT 16
+#define RG_SENINF_CAM_MUX12_EXP_VSIZE_MASK (0xffff << 16)
+
+#define SENINF_CAM_MUX12_CHK_RES 0x01c8
+#define RO_SENINF_CAM_MUX12_RCV_HSIZE_SHIFT 0
+#define RO_SENINF_CAM_MUX12_RCV_HSIZE_MASK (0xffff << 0)
+#define RO_SENINF_CAM_MUX12_RCV_VSIZE_SHIFT 16
+#define RO_SENINF_CAM_MUX12_RCV_VSIZE_MASK (0xffff << 16)
+
+#define SENINF_CAM_MUX12_CHK_ERR_RES 0x01cc
+#define RO_SENINF_CAM_MUX12_RCV_ERR_HSIZE_SHIFT 0
+#define RO_SENINF_CAM_MUX12_RCV_ERR_HSIZE_MASK (0xffff << 0)
+#define RO_SENINF_CAM_MUX12_RCV_ERR_VSIZE_SHIFT 16
+#define RO_SENINF_CAM_MUX12_RCV_ERR_VSIZE_MASK (0xffff << 16)
+
+#define SENINF_CAM_MUX13_CHK_CTL_0 0x01d0
+#define RG_SENINF_CAM_MUX13_PIX_MODE_SEL_SHIFT 0
+#define RG_SENINF_CAM_MUX13_PIX_MODE_SEL_MASK (0x3 << 0)
+
+#define SENINF_CAM_MUX13_CHK_CTL_1 0x01d4
+#define RG_SENINF_CAM_MUX13_EXP_HSIZE_SHIFT 0
+#define RG_SENINF_CAM_MUX13_EXP_HSIZE_MASK (0xffff << 0)
+#define RG_SENINF_CAM_MUX13_EXP_VSIZE_SHIFT 16
+#define RG_SENINF_CAM_MUX13_EXP_VSIZE_MASK (0xffff << 16)
+
+#define SENINF_CAM_MUX13_CHK_RES 0x01d8
+#define RO_SENINF_CAM_MUX13_RCV_HSIZE_SHIFT 0
+#define RO_SENINF_CAM_MUX13_RCV_HSIZE_MASK (0xffff << 0)
+#define RO_SENINF_CAM_MUX13_RCV_VSIZE_SHIFT 16
+#define RO_SENINF_CAM_MUX13_RCV_VSIZE_MASK (0xffff << 16)
+
+#define SENINF_CAM_MUX13_CHK_ERR_RES 0x01dc
+#define RO_SENINF_CAM_MUX13_RCV_ERR_HSIZE_SHIFT 0
+#define RO_SENINF_CAM_MUX13_RCV_ERR_HSIZE_MASK (0xffff << 0)
+#define RO_SENINF_CAM_MUX13_RCV_ERR_VSIZE_SHIFT 16
+#define RO_SENINF_CAM_MUX13_RCV_ERR_VSIZE_MASK (0xffff << 16)
+
+#define SENINF_CAM_MUX14_CHK_CTL_0 0x01e0
+#define RG_SENINF_CAM_MUX14_PIX_MODE_SEL_SHIFT 0
+#define RG_SENINF_CAM_MUX14_PIX_MODE_SEL_MASK (0x3 << 0)
+
+#define SENINF_CAM_MUX14_CHK_CTL_1 0x01e4
+#define RG_SENINF_CAM_MUX14_EXP_HSIZE_SHIFT 0
+#define RG_SENINF_CAM_MUX14_EXP_HSIZE_MASK (0xffff << 0)
+#define RG_SENINF_CAM_MUX14_EXP_VSIZE_SHIFT 16
+#define RG_SENINF_CAM_MUX14_EXP_VSIZE_MASK (0xffff << 16)
+
+#define SENINF_CAM_MUX14_CHK_RES 0x01e8
+#define RO_SENINF_CAM_MUX14_RCV_HSIZE_SHIFT 0
+#define RO_SENINF_CAM_MUX14_RCV_HSIZE_MASK (0xffff << 0)
+#define RO_SENINF_CAM_MUX14_RCV_VSIZE_SHIFT 16
+#define RO_SENINF_CAM_MUX14_RCV_VSIZE_MASK (0xffff << 16)
+
+#define SENINF_CAM_MUX14_CHK_ERR_RES 0x01ec
+#define RO_SENINF_CAM_MUX14_RCV_ERR_HSIZE_SHIFT 0
+#define RO_SENINF_CAM_MUX14_RCV_ERR_HSIZE_MASK (0xffff << 0)
+#define RO_SENINF_CAM_MUX14_RCV_ERR_VSIZE_SHIFT 16
+#define RO_SENINF_CAM_MUX14_RCV_ERR_VSIZE_MASK (0xffff << 16)
+
+#define SENINF_CAM_MUX15_CHK_CTL_0 0x01f0
+#define RG_SENINF_CAM_MUX15_PIX_MODE_SEL_SHIFT 0
+#define RG_SENINF_CAM_MUX15_PIX_MODE_SEL_MASK (0x3 << 0)
+
+#define SENINF_CAM_MUX15_CHK_CTL_1 0x01f4
+#define RG_SENINF_CAM_MUX15_EXP_HSIZE_SHIFT 0
+#define RG_SENINF_CAM_MUX15_EXP_HSIZE_MASK (0xffff << 0)
+#define RG_SENINF_CAM_MUX15_EXP_VSIZE_SHIFT 16
+#define RG_SENINF_CAM_MUX15_EXP_VSIZE_MASK (0xffff << 16)
+
+#define SENINF_CAM_MUX15_CHK_RES 0x01f8
+#define RO_SENINF_CAM_MUX15_RCV_HSIZE_SHIFT 0
+#define RO_SENINF_CAM_MUX15_RCV_HSIZE_MASK (0xffff << 0)
+#define RO_SENINF_CAM_MUX15_RCV_VSIZE_SHIFT 16
+#define RO_SENINF_CAM_MUX15_RCV_VSIZE_MASK (0xffff << 16)
+
+#define SENINF_CAM_MUX15_CHK_ERR_RES 0x01fc
+#define RO_SENINF_CAM_MUX15_RCV_ERR_HSIZE_SHIFT 0
+#define RO_SENINF_CAM_MUX15_RCV_ERR_HSIZE_MASK (0xffff << 0)
+#define RO_SENINF_CAM_MUX15_RCV_ERR_VSIZE_SHIFT 16
+#define RO_SENINF_CAM_MUX15_RCV_ERR_VSIZE_MASK (0xffff << 16)
+
+#endif
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_csi_phy_2_0/mtk_cam-seninf-csi0-cphy.h b/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_csi_phy_2_0/mtk_cam-seninf-csi0-cphy.h
new file mode 100644
index 0000000000000000000000000000000000000000..1bc3de55e0e62597f51876d216148f37b0867199
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_csi_phy_2_0/mtk_cam-seninf-csi0-cphy.h
@@ -0,0 +1,614 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2022 MediaTek Inc.
+ */
+
+#ifndef __CSI0_CPHY_TOP_H__
+#define __CSI0_CPHY_TOP_H__
+
+#define CPHY_RX_CTRL 0x0000
+#define CPHY_RX_TR0_LPRX_EN_SHIFT 0
+#define CPHY_RX_TR0_LPRX_EN_MASK (0x1 << 0)
+#define CPHY_RX_TR1_LPRX_EN_SHIFT 1
+#define CPHY_RX_TR1_LPRX_EN_MASK (0x1 << 1)
+#define CPHY_RX_TR2_LPRX_EN_SHIFT 2
+#define CPHY_RX_TR2_LPRX_EN_MASK (0x1 << 2)
+#define CPHY_RX_TR3_LPRX_EN_SHIFT 3
+#define CPHY_RX_TR3_LPRX_EN_MASK (0x1 << 3)
+#define CPHY_RX_TR0_HSRX_EN_SHIFT 4
+#define CPHY_RX_TR0_HSRX_EN_MASK (0x1 << 4)
+#define CPHY_RX_TR1_HSRX_EN_SHIFT 5
+#define CPHY_RX_TR1_HSRX_EN_MASK (0x1 << 5)
+#define CPHY_RX_TR2_HSRX_EN_SHIFT 6
+#define CPHY_RX_TR2_HSRX_EN_MASK (0x1 << 6)
+#define CPHY_RX_TR3_HSRX_EN_SHIFT 7
+#define CPHY_RX_TR3_HSRX_EN_MASK (0x1 << 7)
+#define CPHY_RX_TR0_BIST_EN_SHIFT 16
+#define CPHY_RX_TR0_BIST_EN_MASK (0x1 << 16)
+#define CPHY_RX_TR1_BIST_EN_SHIFT 17
+#define CPHY_RX_TR1_BIST_EN_MASK (0x1 << 17)
+#define CPHY_RX_TR2_BIST_EN_SHIFT 18
+#define CPHY_RX_TR2_BIST_EN_MASK (0x1 << 18)
+#define CPHY_RX_TR3_BIST_EN_SHIFT 19
+#define CPHY_RX_TR3_BIST_EN_MASK (0x1 << 19)
+
+#define CPHY_RX_OPT 0x0008
+#define RG_CPHY_RX_PRBS_GEN_DATA_DELAY_EN_SHIFT 0
+#define RG_CPHY_RX_PRBS_GEN_DATA_DELAY_EN_MASK (0x1 << 0)
+#define RG_CPHY_RX_LP_MODE_SHIFT 1
+#define RG_CPHY_RX_LP_MODE_MASK (0x1 << 1)
+#define RG_CPHY_RX_SYNC_DETECT_OPT_SHIFT 4
+#define RG_CPHY_RX_SYNC_DETECT_OPT_MASK (0x7 << 4)
+#define RG_CPHY_RX_TR0_INIT_WIRE_STATE_SHIFT 16
+#define RG_CPHY_RX_TR0_INIT_WIRE_STATE_MASK (0x7 << 16)
+#define RG_CPHY_RX_TR1_INIT_WIRE_STATE_SHIFT 20
+#define RG_CPHY_RX_TR1_INIT_WIRE_STATE_MASK (0x7 << 20)
+#define RG_CPHY_RX_TR2_INIT_WIRE_STATE_SHIFT 24
+#define RG_CPHY_RX_TR2_INIT_WIRE_STATE_MASK (0x7 << 24)
+#define RG_CPHY_RX_TR3_INIT_WIRE_STATE_SHIFT 28
+#define RG_CPHY_RX_TR3_INIT_WIRE_STATE_MASK (0x7 << 28)
+
+#define CPHY_RX_DETECT_CTRL_SYNC 0x0010
+#define RG_CPHY_RX_DETECT_7S_DIS_SYNC_SHIFT 0
+#define RG_CPHY_RX_DETECT_7S_DIS_SYNC_MASK (0x1 << 0)
+#define RG_CPHY_RX_DETECT_7S_MASK_SYNC_SHIFT 1
+#define RG_CPHY_RX_DETECT_7S_MASK_SYNC_MASK (0x7f << 1)
+#define RG_CPHY_RX_DETECT_7S_WORD_SYNC_SHIFT 8
+#define RG_CPHY_RX_DETECT_7S_WORD_SYNC_MASK (0x1fffff << 8)
+
+#define CPHY_RX_DETECT_CTRL_ESCAPE 0x0014
+#define RG_CPHY_RX_DETECT_7S_DIS_ESCAPE_SHIFT 0
+#define RG_CPHY_RX_DETECT_7S_DIS_ESCAPE_MASK (0x1 << 0)
+#define RG_CPHY_RX_DETECT_7S_MASK_ESCAPE_SHIFT 1
+#define RG_CPHY_RX_DETECT_7S_MASK_ESCAPE_MASK (0x7f << 1)
+#define RG_CPHY_RX_DETECT_7S_WORD_ESCAPE_SHIFT 8
+#define RG_CPHY_RX_DETECT_7S_WORD_ESCAPE_MASK (0x1fffff << 8)
+
+#define CPHY_RX_DETECT_CTRL_POST 0x0018
+#define RG_CPHY_RX_DETECT_7S_DIS_POST_SHIFT 0
+#define RG_CPHY_RX_DETECT_7S_DIS_POST_MASK (0x1 << 0)
+#define RG_CPHY_RX_DATA_VALID_POST_EN_SHIFT 4
+#define RG_CPHY_RX_DATA_VALID_POST_EN_MASK (0x1 << 4)
+#define RG_CPHY_RX_DETECT_7S_WORD_POST_SHIFT 8
+#define RG_CPHY_RX_DETECT_7S_WORD_POST_MASK (0x1fffff << 8)
+
+#define CPHY_RX_TRIO0_DEBUG_0 0x0020
+#define RO_CPHY_RX_TR0_SYMBOL_STREAM_0_SHIFT 0
+#define RO_CPHY_RX_TR0_SYMBOL_STREAM_0_MASK (0xffffffff << 0)
+
+#define CPHY_RX_TRIO0_DEBUG_1 0x0024
+#define RO_CPHY_RX_TR0_SYMBOL_STREAM_1_SHIFT 0
+#define RO_CPHY_RX_TR0_SYMBOL_STREAM_1_MASK (0x3ff << 0)
+#define RO_CPHY_RX_TR0_SYMBOL_STRAM_VALID_SHIFT 12
+#define RO_CPHY_RX_TR0_SYMBOL_STRAM_VALID_MASK (0x1 << 12)
+#define RO_CPHY_RX_TR0_DETECT_SYNC_SHIFT 16
+#define RO_CPHY_RX_TR0_DETECT_SYNC_MASK (0x1 << 16)
+#define RO_CPHY_RX_TR0_DETECT_ESCAPE_SHIFT 17
+#define RO_CPHY_RX_TR0_DETECT_ESCAPE_MASK (0x1 << 17)
+#define RO_CPHY_RX_TR0_DETECT_POST_SHIFT 18
+#define RO_CPHY_RX_TR0_DETECT_POST_MASK (0x1 << 18)
+#define RO_CPHY_RX_TR0_POSITION_SYNC_SHIFT 24
+#define RO_CPHY_RX_TR0_POSITION_SYNC_MASK (0xf << 24)
+#define RO_CPHY_RX_TR0_POSITION_ESCAPE_SHIFT 28
+#define RO_CPHY_RX_TR0_POSITION_ESCAPE_MASK (0xf << 28)
+
+#define CPHY_RX_TRIO1_DEBUG_0 0x0030
+#define RO_CPHY_RX_TR1_SYMBOL_STREAM_0_SHIFT 0
+#define RO_CPHY_RX_TR1_SYMBOL_STREAM_0_MASK (0xffffffff << 0)
+
+#define CPHY_RX_TRIO1_DEBUG_1 0x0034
+#define RO_CPHY_RX_TR1_SYMBOL_STREAM_1_SHIFT 0
+#define RO_CPHY_RX_TR1_SYMBOL_STREAM_1_MASK (0x3ff << 0)
+#define RO_CPHY_RX_TR1_SYMBOL_STRAM_VALID_SHIFT 12
+#define RO_CPHY_RX_TR1_SYMBOL_STRAM_VALID_MASK (0x1 << 12)
+#define RO_CPHY_RX_TR1_DETECT_SYNC_SHIFT 16
+#define RO_CPHY_RX_TR1_DETECT_SYNC_MASK (0x1 << 16)
+#define RO_CPHY_RX_TR1_DETECT_ESCAPE_SHIFT 17
+#define RO_CPHY_RX_TR1_DETECT_ESCAPE_MASK (0x1 << 17)
+#define RO_CPHY_RX_TR1_DETECT_POST_SHIFT 18
+#define RO_CPHY_RX_TR1_DETECT_POST_MASK (0x1 << 18)
+#define RO_CPHY_RX_TR1_POSITION_SYNC_SHIFT 24
+#define RO_CPHY_RX_TR1_POSITION_SYNC_MASK (0xf << 24)
+#define RO_CPHY_RX_TR1_POSITION_ESCAPE_SHIFT 28
+#define RO_CPHY_RX_TR1_POSITION_ESCAPE_MASK (0xf << 28)
+
+#define CPHY_RX_TRIO2_DEBUG_0 0x0040
+#define RO_CPHY_RX_TR2_SYMBOL_STREAM_0_SHIFT 0
+#define RO_CPHY_RX_TR2_SYMBOL_STREAM_0_MASK (0xffffffff << 0)
+
+#define CPHY_RX_TRIO2_DEBUG_1 0x0044
+#define RO_CPHY_RX_TR2_SYMBOL_STREAM_1_SHIFT 0
+#define RO_CPHY_RX_TR2_SYMBOL_STREAM_1_MASK (0x3ff << 0)
+#define RO_CPHY_RX_TR2_SYMBOL_STRAM_VALID_SHIFT 12
+#define RO_CPHY_RX_TR2_SYMBOL_STRAM_VALID_MASK (0x1 << 12)
+#define RO_CPHY_RX_TR2_DETECT_SYNC_SHIFT 16
+#define RO_CPHY_RX_TR2_DETECT_SYNC_MASK (0x1 << 16)
+#define RO_CPHY_RX_TR2_DETECT_ESCAPE_SHIFT 17
+#define RO_CPHY_RX_TR2_DETECT_ESCAPE_MASK (0x1 << 17)
+#define RO_CPHY_RX_TR2_DETECT_POST_SHIFT 18
+#define RO_CPHY_RX_TR2_DETECT_POST_MASK (0x1 << 18)
+#define RO_CPHY_RX_TR2_POSITION_SYNC_SHIFT 24
+#define RO_CPHY_RX_TR2_POSITION_SYNC_MASK (0xf << 24)
+#define RO_CPHY_RX_TR2_POSITION_ESCAPE_SHIFT 28
+#define RO_CPHY_RX_TR2_POSITION_ESCAPE_MASK (0xf << 28)
+
+#define CPHY_RX_TRIO3_DEBUG_0 0x0050
+#define RO_CPHY_RX_TR3_SYMBOL_STREAM_0_SHIFT 0
+#define RO_CPHY_RX_TR3_SYMBOL_STREAM_0_MASK (0xffffffff << 0)
+
+#define CPHY_RX_TRIO3_DEBUG_1 0x0054
+#define RO_CPHY_RX_TR3_SYMBOL_STREAM_1_SHIFT 0
+#define RO_CPHY_RX_TR3_SYMBOL_STREAM_1_MASK (0x3ff << 0)
+#define RO_CPHY_RX_TR3_SYMBOL_STRAM_VALID_SHIFT 12
+#define RO_CPHY_RX_TR3_SYMBOL_STRAM_VALID_MASK (0x1 << 12)
+#define RO_CPHY_RX_TR3_DETECT_SYNC_SHIFT 16
+#define RO_CPHY_RX_TR3_DETECT_SYNC_MASK (0x1 << 16)
+#define RO_CPHY_RX_TR3_DETECT_ESCAPE_SHIFT 17
+#define RO_CPHY_RX_TR3_DETECT_ESCAPE_MASK (0x1 << 17)
+#define RO_CPHY_RX_TR3_DETECT_POST_SHIFT 18
+#define RO_CPHY_RX_TR3_DETECT_POST_MASK (0x1 << 18)
+#define RO_CPHY_RX_TR3_POSITION_SYNC_SHIFT 24
+#define RO_CPHY_RX_TR3_POSITION_SYNC_MASK (0xf << 24)
+#define RO_CPHY_RX_TR3_POSITION_ESCAPE_SHIFT 28
+#define RO_CPHY_RX_TR3_POSITION_ESCAPE_MASK (0xf << 28)
+
+#define CPHY_RX_BIST_TRIO0_PROGSEQ_0 0x0060
+#define RG_CPHY_RX_TR0_BIST_PROGSEQ_S0_SHIFT 0
+#define RG_CPHY_RX_TR0_BIST_PROGSEQ_S0_MASK (0x7 << 0)
+#define RG_CPHY_RX_TR0_BIST_PROGSEQ_S1_SHIFT 4
+#define RG_CPHY_RX_TR0_BIST_PROGSEQ_S1_MASK (0x7 << 4)
+#define RG_CPHY_RX_TR0_BIST_PROGSEQ_S2_SHIFT 8
+#define RG_CPHY_RX_TR0_BIST_PROGSEQ_S2_MASK (0x7 << 8)
+#define RG_CPHY_RX_TR0_BIST_PROGSEQ_S3_SHIFT 12
+#define RG_CPHY_RX_TR0_BIST_PROGSEQ_S3_MASK (0x7 << 12)
+#define RG_CPHY_RX_TR0_BIST_PROGSEQ_S4_SHIFT 16
+#define RG_CPHY_RX_TR0_BIST_PROGSEQ_S4_MASK (0x7 << 16)
+#define RG_CPHY_RX_TR0_BIST_PROGSEQ_S5_SHIFT 20
+#define RG_CPHY_RX_TR0_BIST_PROGSEQ_S5_MASK (0x7 << 20)
+#define RG_CPHY_RX_TR0_BIST_PROGSEQ_S6_SHIFT 24
+#define RG_CPHY_RX_TR0_BIST_PROGSEQ_S6_MASK (0x7 << 24)
+#define RG_CPHY_RX_TR0_BIST_PROGSEQ_S7_SHIFT 28
+#define RG_CPHY_RX_TR0_BIST_PROGSEQ_S7_MASK (0x7 << 28)
+
+#define CPHY_RX_BIST_TRIO0_PROGSEQ_1 0x0064
+#define RG_CPHY_RX_TR0_BIST_PROGSEQ_S8_SHIFT 0
+#define RG_CPHY_RX_TR0_BIST_PROGSEQ_S8_MASK (0x7 << 0)
+#define RG_CPHY_RX_TR0_BIST_PROGSEQ_S9_SHIFT 4
+#define RG_CPHY_RX_TR0_BIST_PROGSEQ_S9_MASK (0x7 << 4)
+#define RG_CPHY_RX_TR0_BIST_PROGSEQ_S10_SHIFT 8
+#define RG_CPHY_RX_TR0_BIST_PROGSEQ_S10_MASK (0x7 << 8)
+#define RG_CPHY_RX_TR0_BIST_PROGSEQ_S11_SHIFT 12
+#define RG_CPHY_RX_TR0_BIST_PROGSEQ_S11_MASK (0x7 << 12)
+#define RG_CPHY_RX_TR0_BIST_PROGSEQ_S12_SHIFT 16
+#define RG_CPHY_RX_TR0_BIST_PROGSEQ_S12_MASK (0x7 << 16)
+#define RG_CPHY_RX_TR0_BIST_PROGSEQ_S13_SHIFT 20
+#define RG_CPHY_RX_TR0_BIST_PROGSEQ_S13_MASK (0x7 << 20)
+
+#define CPHY_RX_BIST_TRIO1_PROGSEQ_0 0x0068
+#define RG_CPHY_RX_TR1_BIST_PROGSEQ_S0_SHIFT 0
+#define RG_CPHY_RX_TR1_BIST_PROGSEQ_S0_MASK (0x7 << 0)
+#define RG_CPHY_RX_TR1_BIST_PROGSEQ_S1_SHIFT 4
+#define RG_CPHY_RX_TR1_BIST_PROGSEQ_S1_MASK (0x7 << 4)
+#define RG_CPHY_RX_TR1_BIST_PROGSEQ_S2_SHIFT 8
+#define RG_CPHY_RX_TR1_BIST_PROGSEQ_S2_MASK (0x7 << 8)
+#define RG_CPHY_RX_TR1_BIST_PROGSEQ_S3_SHIFT 12
+#define RG_CPHY_RX_TR1_BIST_PROGSEQ_S3_MASK (0x7 << 12)
+#define RG_CPHY_RX_TR1_BIST_PROGSEQ_S4_SHIFT 16
+#define RG_CPHY_RX_TR1_BIST_PROGSEQ_S4_MASK (0x7 << 16)
+#define RG_CPHY_RX_TR1_BIST_PROGSEQ_S5_SHIFT 20
+#define RG_CPHY_RX_TR1_BIST_PROGSEQ_S5_MASK (0x7 << 20)
+#define RG_CPHY_RX_TR1_BIST_PROGSEQ_S6_SHIFT 24
+#define RG_CPHY_RX_TR1_BIST_PROGSEQ_S6_MASK (0x7 << 24)
+#define RG_CPHY_RX_TR1_BIST_PROGSEQ_S7_SHIFT 28
+#define RG_CPHY_RX_TR1_BIST_PROGSEQ_S7_MASK (0x7 << 28)
+
+#define CPHY_RX_BIST_TRIO1_PROGSEQ_1 0x006c
+#define RG_CPHY_RX_TR1_BIST_PROGSEQ_S8_SHIFT 0
+#define RG_CPHY_RX_TR1_BIST_PROGSEQ_S8_MASK (0x7 << 0)
+#define RG_CPHY_RX_TR1_BIST_PROGSEQ_S9_SHIFT 4
+#define RG_CPHY_RX_TR1_BIST_PROGSEQ_S9_MASK (0x7 << 4)
+#define RG_CPHY_RX_TR1_BIST_PROGSEQ_S10_SHIFT 8
+#define RG_CPHY_RX_TR1_BIST_PROGSEQ_S10_MASK (0x7 << 8)
+#define RG_CPHY_RX_TR1_BIST_PROGSEQ_S11_SHIFT 12
+#define RG_CPHY_RX_TR1_BIST_PROGSEQ_S11_MASK (0x7 << 12)
+#define RG_CPHY_RX_TR1_BIST_PROGSEQ_S12_SHIFT 16
+#define RG_CPHY_RX_TR1_BIST_PROGSEQ_S12_MASK (0x7 << 16)
+#define RG_CPHY_RX_TR1_BIST_PROGSEQ_S13_SHIFT 20
+#define RG_CPHY_RX_TR1_BIST_PROGSEQ_S13_MASK (0x7 << 20)
+
+#define CPHY_RX_BIST_TRIO2_PROGSEQ_0 0x0070
+#define RG_CPHY_RX_TR2_BIST_PROGSEQ_S0_SHIFT 0
+#define RG_CPHY_RX_TR2_BIST_PROGSEQ_S0_MASK (0x7 << 0)
+#define RG_CPHY_RX_TR2_BIST_PROGSEQ_S1_SHIFT 4
+#define RG_CPHY_RX_TR2_BIST_PROGSEQ_S1_MASK (0x7 << 4)
+#define RG_CPHY_RX_TR2_BIST_PROGSEQ_S2_SHIFT 8
+#define RG_CPHY_RX_TR2_BIST_PROGSEQ_S2_MASK (0x7 << 8)
+#define RG_CPHY_RX_TR2_BIST_PROGSEQ_S3_SHIFT 12
+#define RG_CPHY_RX_TR2_BIST_PROGSEQ_S3_MASK (0x7 << 12)
+#define RG_CPHY_RX_TR2_BIST_PROGSEQ_S4_SHIFT 16
+#define RG_CPHY_RX_TR2_BIST_PROGSEQ_S4_MASK (0x7 << 16)
+#define RG_CPHY_RX_TR2_BIST_PROGSEQ_S5_SHIFT 20
+#define RG_CPHY_RX_TR2_BIST_PROGSEQ_S5_MASK (0x7 << 20)
+#define RG_CPHY_RX_TR2_BIST_PROGSEQ_S6_SHIFT 24
+#define RG_CPHY_RX_TR2_BIST_PROGSEQ_S6_MASK (0x7 << 24)
+#define RG_CPHY_RX_TR2_BIST_PROGSEQ_S7_SHIFT 28
+#define RG_CPHY_RX_TR2_BIST_PROGSEQ_S7_MASK (0x7 << 28)
+
+#define CPHY_RX_BIST_TRIO2_PROGSEQ_1 0x0074
+#define RG_CPHY_RX_TR2_BIST_PROGSEQ_S8_SHIFT 0
+#define RG_CPHY_RX_TR2_BIST_PROGSEQ_S8_MASK (0x7 << 0)
+#define RG_CPHY_RX_TR2_BIST_PROGSEQ_S9_SHIFT 4
+#define RG_CPHY_RX_TR2_BIST_PROGSEQ_S9_MASK (0x7 << 4)
+#define RG_CPHY_RX_TR2_BIST_PROGSEQ_S10_SHIFT 8
+#define RG_CPHY_RX_TR2_BIST_PROGSEQ_S10_MASK (0x7 << 8)
+#define RG_CPHY_RX_TR2_BIST_PROGSEQ_S11_SHIFT 12
+#define RG_CPHY_RX_TR2_BIST_PROGSEQ_S11_MASK (0x7 << 12)
+#define RG_CPHY_RX_TR2_BIST_PROGSEQ_S12_SHIFT 16
+#define RG_CPHY_RX_TR2_BIST_PROGSEQ_S12_MASK (0x7 << 16)
+#define RG_CPHY_RX_TR2_BIST_PROGSEQ_S13_SHIFT 20
+#define RG_CPHY_RX_TR2_BIST_PROGSEQ_S13_MASK (0x7 << 20)
+
+#define CPHY_RX_BIST_TRIO3_PROGSEQ_0 0x0078
+#define RG_CPHY_RX_TR3_BIST_PROGSEQ_S0_SHIFT 0
+#define RG_CPHY_RX_TR3_BIST_PROGSEQ_S0_MASK (0x7 << 0)
+#define RG_CPHY_RX_TR3_BIST_PROGSEQ_S1_SHIFT 4
+#define RG_CPHY_RX_TR3_BIST_PROGSEQ_S1_MASK (0x7 << 4)
+#define RG_CPHY_RX_TR3_BIST_PROGSEQ_S2_SHIFT 8
+#define RG_CPHY_RX_TR3_BIST_PROGSEQ_S2_MASK (0x7 << 8)
+#define RG_CPHY_RX_TR3_BIST_PROGSEQ_S3_SHIFT 12
+#define RG_CPHY_RX_TR3_BIST_PROGSEQ_S3_MASK (0x7 << 12)
+#define RG_CPHY_RX_TR3_BIST_PROGSEQ_S4_SHIFT 16
+#define RG_CPHY_RX_TR3_BIST_PROGSEQ_S4_MASK (0x7 << 16)
+#define RG_CPHY_RX_TR3_BIST_PROGSEQ_S5_SHIFT 20
+#define RG_CPHY_RX_TR3_BIST_PROGSEQ_S5_MASK (0x7 << 20)
+#define RG_CPHY_RX_TR3_BIST_PROGSEQ_S6_SHIFT 24
+#define RG_CPHY_RX_TR3_BIST_PROGSEQ_S6_MASK (0x7 << 24)
+#define RG_CPHY_RX_TR3_BIST_PROGSEQ_S7_SHIFT 28
+#define RG_CPHY_RX_TR3_BIST_PROGSEQ_S7_MASK (0x7 << 28)
+
+#define CPHY_RX_BIST_TRIO3_PROGSEQ_1 0x007c
+#define RG_CPHY_RX_TR3_BIST_PROGSEQ_S8_SHIFT 0
+#define RG_CPHY_RX_TR3_BIST_PROGSEQ_S8_MASK (0x7 << 0)
+#define RG_CPHY_RX_TR3_BIST_PROGSEQ_S9_SHIFT 4
+#define RG_CPHY_RX_TR3_BIST_PROGSEQ_S9_MASK (0x7 << 4)
+#define RG_CPHY_RX_TR3_BIST_PROGSEQ_S10_SHIFT 8
+#define RG_CPHY_RX_TR3_BIST_PROGSEQ_S10_MASK (0x7 << 8)
+#define RG_CPHY_RX_TR3_BIST_PROGSEQ_S11_SHIFT 12
+#define RG_CPHY_RX_TR3_BIST_PROGSEQ_S11_MASK (0x7 << 12)
+#define RG_CPHY_RX_TR3_BIST_PROGSEQ_S12_SHIFT 16
+#define RG_CPHY_RX_TR3_BIST_PROGSEQ_S12_MASK (0x7 << 16)
+#define RG_CPHY_RX_TR3_BIST_PROGSEQ_S13_SHIFT 20
+#define RG_CPHY_RX_TR3_BIST_PROGSEQ_S13_MASK (0x7 << 20)
+
+#define CPHY_RX_BIST_TRIO0_CTRL 0x0080
+#define RG_CPHY_RX_TR0_PRBS_SEED_0_SHIFT 0
+#define RG_CPHY_RX_TR0_PRBS_SEED_0_MASK (0xff << 0)
+#define RG_CPHY_RX_TR0_PRBS_SEED_1_SHIFT 8
+#define RG_CPHY_RX_TR0_PRBS_SEED_1_MASK (0xff << 8)
+#define RG_CPHY_RX_TR0_PRBS_SEED_2_SHIFT 16
+#define RG_CPHY_RX_TR0_PRBS_SEED_2_MASK (0x3 << 16)
+#define RG_CPHY_RX_TR0_BIST_COMP_MODE_SHIFT 20
+#define RG_CPHY_RX_TR0_BIST_COMP_MODE_MASK (0x1 << 20)
+#define RG_CPHY_RX_TR0_FIX_POINT_RST_MODE_SHIFT 21
+#define RG_CPHY_RX_TR0_FIX_POINT_RST_MODE_MASK (0x1 << 21)
+#define CPHY_RX_TR0_FIX_POINT_RST_SHIFT 22
+#define CPHY_RX_TR0_FIX_POINT_RST_MASK (0x1 << 22)
+#define RG_CPHY_RX_TR0_PRBS_PAT_SEL_SHIFT 24
+#define RG_CPHY_RX_TR0_PRBS_PAT_SEL_MASK (0x7 << 24)
+
+#define CPHY_RX_BIST_TRIO1_CTRL 0x0084
+#define RG_CPHY_RX_TR1_PRBS_SEED_0_SHIFT 0
+#define RG_CPHY_RX_TR1_PRBS_SEED_0_MASK (0xff << 0)
+#define RG_CPHY_RX_TR1_PRBS_SEED_1_SHIFT 8
+#define RG_CPHY_RX_TR1_PRBS_SEED_1_MASK (0xff << 8)
+#define RG_CPHY_RX_TR1_PRBS_SEED_2_SHIFT 16
+#define RG_CPHY_RX_TR1_PRBS_SEED_2_MASK (0x3 << 16)
+#define RG_CPHY_RX_TR1_BIST_COMP_MODE_SHIFT 20
+#define RG_CPHY_RX_TR1_BIST_COMP_MODE_MASK (0x1 << 20)
+#define RG_CPHY_RX_TR1_FIX_POINT_RST_MODE_SHIFT 21
+#define RG_CPHY_RX_TR1_FIX_POINT_RST_MODE_MASK (0x1 << 21)
+#define CPHY_RX_TR1_FIX_POINT_RST_SHIFT 22
+#define CPHY_RX_TR1_FIX_POINT_RST_MASK (0x1 << 22)
+#define RG_CPHY_RX_TR1_PRBS_PAT_SEL_SHIFT 24
+#define RG_CPHY_RX_TR1_PRBS_PAT_SEL_MASK (0x7 << 24)
+
+#define CPHY_RX_BIST_TRIO2_CTRL 0x0088
+#define RG_CPHY_RX_TR2_PRBS_SEED_0_SHIFT 0
+#define RG_CPHY_RX_TR2_PRBS_SEED_0_MASK (0xff << 0)
+#define RG_CPHY_RX_TR2_PRBS_SEED_1_SHIFT 8
+#define RG_CPHY_RX_TR2_PRBS_SEED_1_MASK (0xff << 8)
+#define RG_CPHY_RX_TR2_PRBS_SEED_2_SHIFT 16
+#define RG_CPHY_RX_TR2_PRBS_SEED_2_MASK (0x3 << 16)
+#define RG_CPHY_RX_TR2_BIST_COMP_MODE_SHIFT 20
+#define RG_CPHY_RX_TR2_BIST_COMP_MODE_MASK (0x1 << 20)
+#define RG_CPHY_RX_TR2_FIX_POINT_RST_MODE_SHIFT 21
+#define RG_CPHY_RX_TR2_FIX_POINT_RST_MODE_MASK (0x1 << 21)
+#define CPHY_RX_TR2_FIX_POINT_RST_SHIFT 22
+#define CPHY_RX_TR2_FIX_POINT_RST_MASK (0x1 << 22)
+#define RG_CPHY_RX_TR2_PRBS_PAT_SEL_SHIFT 24
+#define RG_CPHY_RX_TR2_PRBS_PAT_SEL_MASK (0x7 << 24)
+
+#define CPHY_RX_BIST_TRIO3_CTRL 0x008c
+#define RG_CPHY_RX_TR3_PRBS_SEED_0_SHIFT 0
+#define RG_CPHY_RX_TR3_PRBS_SEED_0_MASK (0xff << 0)
+#define RG_CPHY_RX_TR3_PRBS_SEED_1_SHIFT 8
+#define RG_CPHY_RX_TR3_PRBS_SEED_1_MASK (0xff << 8)
+#define RG_CPHY_RX_TR3_PRBS_SEED_2_SHIFT 16
+#define RG_CPHY_RX_TR3_PRBS_SEED_2_MASK (0x3 << 16)
+#define RG_CPHY_RX_TR3_BIST_COMP_MODE_SHIFT 20
+#define RG_CPHY_RX_TR3_BIST_COMP_MODE_MASK (0x1 << 20)
+#define RG_CPHY_RX_TR3_FIX_POINT_RST_MODE_SHIFT 21
+#define RG_CPHY_RX_TR3_FIX_POINT_RST_MODE_MASK (0x1 << 21)
+#define CPHY_RX_TR3_FIX_POINT_RST_SHIFT 22
+#define CPHY_RX_TR3_FIX_POINT_RST_MASK (0x1 << 22)
+#define RG_CPHY_RX_TR3_PRBS_PAT_SEL_SHIFT 24
+#define RG_CPHY_RX_TR3_PRBS_PAT_SEL_MASK (0x7 << 24)
+
+#define CPHY_RX_BIST_DBG_STATUS 0x0090
+#define RO_CPHY_RX_TR0_BIST_LP_HS_LP_DONE_SHIFT 0
+#define RO_CPHY_RX_TR0_BIST_LP_HS_LP_DONE_MASK (0x1 << 0)
+#define RO_CPHY_RX_TR1_BIST_LP_HS_LP_DONE_SHIFT 1
+#define RO_CPHY_RX_TR1_BIST_LP_HS_LP_DONE_MASK (0x1 << 1)
+#define RO_CPHY_RX_TR2_BIST_LP_HS_LP_DONE_SHIFT 2
+#define RO_CPHY_RX_TR2_BIST_LP_HS_LP_DONE_MASK (0x1 << 2)
+#define RO_CPHY_RX_TR3_BIST_LP_HS_LP_DONE_SHIFT 3
+#define RO_CPHY_RX_TR3_BIST_LP_HS_LP_DONE_MASK (0x1 << 3)
+
+#define CPHY_RX_BIST_TRIO0_STATUS_0 0x00a0
+#define RO_CPHY_RX_TR0_BIST_WORD_CNT_0_SHIFT 0
+#define RO_CPHY_RX_TR0_BIST_WORD_CNT_0_MASK (0xffffffff << 0)
+
+#define CPHY_RX_BIST_TRIO0_STATUS_1 0x00a4
+#define RO_CPHY_RX_TR0_BIST_WORD_CNT_1_SHIFT 0
+#define RO_CPHY_RX_TR0_BIST_WORD_CNT_1_MASK (0xffff << 0)
+#define RO_CPHY_RX_TR0_BIST_ERR_CNT_SHIFT 16
+#define RO_CPHY_RX_TR0_BIST_ERR_CNT_MASK (0xff << 16)
+#define RO_CPHY_RX_TR0_BIST_WORD_CNT_OVERFLOW_SHIFT 24
+#define RO_CPHY_RX_TR0_BIST_WORD_CNT_OVERFLOW_MASK (0x1 << 24)
+
+#define CPHY_RX_BIST_TRIO0_STATUS_2 0x00a8
+#define RO_CPHY_RX_TR0_BIST_ERR_RECORD_0_SHIFT 0
+#define RO_CPHY_RX_TR0_BIST_ERR_RECORD_0_MASK (0xffffffff << 0)
+
+#define CPHY_RX_BIST_TRIO0_STATUS_3 0x00ac
+#define RO_CPHY_RX_TR0_BIST_ERR_RECORD_1_SHIFT 0
+#define RO_CPHY_RX_TR0_BIST_ERR_RECORD_1_MASK (0xffff << 0)
+
+#define CPHY_RX_BIST_TRIO1_STATUS_0 0x00b0
+#define RO_CPHY_RX_TR1_BIST_WORD_CNT_0_SHIFT 0
+#define RO_CPHY_RX_TR1_BIST_WORD_CNT_0_MASK (0xffffffff << 0)
+
+#define CPHY_RX_BIST_TRIO1_STATUS_1 0x00b4
+#define RO_CPHY_RX_TR1_BIST_WORD_CNT_1_SHIFT 0
+#define RO_CPHY_RX_TR1_BIST_WORD_CNT_1_MASK (0xffff << 0)
+#define RO_CPHY_RX_TR1_BIST_ERR_CNT_SHIFT 16
+#define RO_CPHY_RX_TR1_BIST_ERR_CNT_MASK (0xff << 16)
+#define RO_CPHY_RX_TR1_BIST_WORD_CNT_OVERFLOW_SHIFT 24
+#define RO_CPHY_RX_TR1_BIST_WORD_CNT_OVERFLOW_MASK (0x1 << 24)
+
+#define CPHY_RX_BIST_TRIO1_STATUS_2 0x00b8
+#define RO_CPHY_RX_TR1_BIST_ERR_RECORD_0_SHIFT 0
+#define RO_CPHY_RX_TR1_BIST_ERR_RECORD_0_MASK (0xffffffff << 0)
+
+#define CPHY_RX_BIST_TRIO1_STATUS_3 0x00bc
+#define RO_CPHY_RX_TR1_BIST_ERR_RECORD_1_SHIFT 0
+#define RO_CPHY_RX_TR1_BIST_ERR_RECORD_1_MASK (0xffff << 0)
+
+#define CPHY_RX_BIST_TRIO2_STATUS_0 0x00c0
+#define RO_CPHY_RX_TR2_BIST_WORD_CNT_0_SHIFT 0
+#define RO_CPHY_RX_TR2_BIST_WORD_CNT_0_MASK (0xffffffff << 0)
+
+#define CPHY_RX_BIST_TRIO2_STATUS_1 0x00c4
+#define RO_CPHY_RX_TR2_BIST_WORD_CNT_1_SHIFT 0
+#define RO_CPHY_RX_TR2_BIST_WORD_CNT_1_MASK (0xffff << 0)
+#define RO_CPHY_RX_TR2_BIST_ERR_CNT_SHIFT 16
+#define RO_CPHY_RX_TR2_BIST_ERR_CNT_MASK (0xff << 16)
+#define RO_CPHY_RX_TR2_BIST_WORD_CNT_OVERFLOW_SHIFT 24
+#define RO_CPHY_RX_TR2_BIST_WORD_CNT_OVERFLOW_MASK (0x1 << 24)
+
+#define CPHY_RX_BIST_TRIO2_STATUS_2 0x00c8
+#define RO_CPHY_RX_TR2_BIST_ERR_RECORD_0_SHIFT 0
+#define RO_CPHY_RX_TR2_BIST_ERR_RECORD_0_MASK (0xffffffff << 0)
+
+#define CPHY_RX_BIST_TRIO2_STATUS_3 0x00cc
+#define RO_CPHY_RX_TR2_BIST_ERR_RECORD_1_SHIFT 0
+#define RO_CPHY_RX_TR2_BIST_ERR_RECORD_1_MASK (0xffff << 0)
+
+#define CPHY_RX_BIST_TRIO3_STATUS_0 0x00d0
+#define RO_CPHY_RX_TR3_BIST_WORD_CNT_0_SHIFT 0
+#define RO_CPHY_RX_TR3_BIST_WORD_CNT_0_MASK (0xffffffff << 0)
+
+#define CPHY_RX_BIST_TRIO3_STATUS_1 0x00d4
+#define RO_CPHY_RX_TR3_BIST_WORD_CNT_1_SHIFT 0
+#define RO_CPHY_RX_TR3_BIST_WORD_CNT_1_MASK (0xffff << 0)
+#define RO_CPHY_RX_TR3_BIST_ERR_CNT_SHIFT 16
+#define RO_CPHY_RX_TR3_BIST_ERR_CNT_MASK (0xff << 16)
+#define RO_CPHY_RX_TR3_BIST_WORD_CNT_OVERFLOW_SHIFT 24
+#define RO_CPHY_RX_TR3_BIST_WORD_CNT_OVERFLOW_MASK (0x1 << 24)
+
+#define CPHY_RX_BIST_TRIO3_STATUS_2 0x00d8
+#define RO_CPHY_RX_TR3_BIST_ERR_RECORD_0_SHIFT 0
+#define RO_CPHY_RX_TR3_BIST_ERR_RECORD_0_MASK (0xffffffff << 0)
+
+#define CPHY_RX_BIST_TRIO3_STATUS_3 0x00dc
+#define RO_CPHY_RX_TR3_BIST_ERR_RECORD_1_SHIFT 0
+#define RO_CPHY_RX_TR3_BIST_ERR_RECORD_1_MASK (0xffff << 0)
+
+#define CPHY_RX_LOOPBACK_OPT 0x00e0
+#define CPHY_RX_LB_TRIGGER_SYNC_INIT_SHIFT 0
+#define CPHY_RX_LB_TRIGGER_SYNC_INIT_MASK (0x1 << 0)
+#define CPHY_RX_LB_RELEASE_SYNC_INIT_SHIFT 1
+#define CPHY_RX_LB_RELEASE_SYNC_INIT_MASK (0x1 << 1)
+#define RG_PHYD2MAC_CPHY_GEN_EN_SHIFT 8
+#define RG_PHYD2MAC_CPHY_GEN_EN_MASK (0x1 << 8)
+#define RG_PHYD2MAC_CPHY_GEN_MODE_SHIFT 9
+#define RG_PHYD2MAC_CPHY_GEN_MODE_MASK (0x1 << 9)
+#define RG_PHYD2MAC_CPHY_GEN_SEL_SHIFT 10
+#define RG_PHYD2MAC_CPHY_GEN_SEL_MASK (0x1 << 10)
+
+#define CPHY_RX_FSM_STATUS 0x00e4
+#define RO_CPHY_RX_TR0_FSM_SHIFT 0
+#ifdef ISP7_1
+#define RO_CPHY_RX_TR0_FSM_MASK (0xff << 0)
+#define RO_CPHY_RX_TR1_FSM_MASK (0xff << 8)
+#define RO_CPHY_RX_TR2_FSM_MASK (0xff << 16)
+#define RO_CPHY_RX_TR3_FSM_MASK (0xff << 24)
+#else
+#define RO_CPHY_RX_TR0_FSM_MASK (0x7f << 0)
+#define RO_CPHY_RX_TR1_FSM_MASK (0x7f << 8)
+#define RO_CPHY_RX_TR2_FSM_MASK (0x7f << 16)
+#define RO_CPHY_RX_TR3_FSM_MASK (0x7f << 24)
+#endif
+#define RO_CPHY_RX_TR1_FSM_SHIFT 8
+
+#define RO_CPHY_RX_TR2_FSM_SHIFT 16
+
+#define RO_CPHY_RX_TR3_FSM_SHIFT 24
+
+
+#define CPHY_RX_IRQ_EN 0x00f0
+#define RG_CPHY_RX_TR0_ERR_SOT_SYNC_HS_IRQ_EN_SHIFT 0
+#define RG_CPHY_RX_TR0_ERR_SOT_SYNC_HS_IRQ_EN_MASK (0x1 << 0)
+#define RG_CPHY_RX_TR1_ERR_SOT_SYNC_HS_IRQ_EN_SHIFT 1
+#define RG_CPHY_RX_TR1_ERR_SOT_SYNC_HS_IRQ_EN_MASK (0x1 << 1)
+#define RG_CPHY_RX_TR2_ERR_SOT_SYNC_HS_IRQ_EN_SHIFT 2
+#define RG_CPHY_RX_TR2_ERR_SOT_SYNC_HS_IRQ_EN_MASK (0x1 << 2)
+#define RG_CPHY_RX_TR3_ERR_SOT_SYNC_HS_IRQ_EN_SHIFT 3
+#define RG_CPHY_RX_TR3_ERR_SOT_SYNC_HS_IRQ_EN_MASK (0x1 << 3)
+#define RG_CPHY_RX_TR0_DETECT_ESCAPE_PULSE_IRQ_EN_SHIFT 4
+#define RG_CPHY_RX_TR0_DETECT_ESCAPE_PULSE_IRQ_EN_MASK (0x1 << 4)
+#define RG_CPHY_RX_TR1_DETECT_ESCAPE_PULSE_IRQ_EN_SHIFT 5
+#define RG_CPHY_RX_TR1_DETECT_ESCAPE_PULSE_IRQ_EN_MASK (0x1 << 5)
+#define RG_CPHY_RX_TR2_DETECT_ESCAPE_PULSE_IRQ_EN_SHIFT 6
+#define RG_CPHY_RX_TR2_DETECT_ESCAPE_PULSE_IRQ_EN_MASK (0x1 << 6)
+#define RG_CPHY_RX_TR3_DETECT_ESCAPE_PULSE_IRQ_EN_SHIFT 7
+#define RG_CPHY_RX_TR3_DETECT_ESCAPE_PULSE_IRQ_EN_MASK (0x1 << 7)
+#define RG_CPHY_RX_IRQ_W1C_EN_SHIFT 31
+#define RG_CPHY_RX_IRQ_W1C_EN_MASK (0x1 << 31)
+
+#define CPHY_RX_IRQ_STATUS 0x00f4
+#define CPHY_RX_TR0_ERR_SOT_SYNC_HS_IRQ_SHIFT 0
+#define CPHY_RX_TR0_ERR_SOT_SYNC_HS_IRQ_MASK (0x1 << 0)
+#define CPHY_RX_TR1_ERR_SOT_SYNC_HS_IRQ_SHIFT 1
+#define CPHY_RX_TR1_ERR_SOT_SYNC_HS_IRQ_MASK (0x1 << 1)
+#define CPHY_RX_TR2_ERR_SOT_SYNC_HS_IRQ_SHIFT 2
+#define CPHY_RX_TR2_ERR_SOT_SYNC_HS_IRQ_MASK (0x1 << 2)
+#define CPHY_RX_TR3_ERR_SOT_SYNC_HS_IRQ_SHIFT 3
+#define CPHY_RX_TR3_ERR_SOT_SYNC_HS_IRQ_MASK (0x1 << 3)
+#define CPHY_RX_TR0_DETECT_ESCAPE_PULSE_IRQ_SHIFT 4
+#define CPHY_RX_TR0_DETECT_ESCAPE_PULSE_IRQ_MASK (0x1 << 4)
+#define CPHY_RX_TR1_DETECT_ESCAPE_PULSE_IRQ_SHIFT 5
+#define CPHY_RX_TR1_DETECT_ESCAPE_PULSE_IRQ_MASK (0x1 << 5)
+#define CPHY_RX_TR2_DETECT_ESCAPE_PULSE_IRQ_SHIFT 6
+#define CPHY_RX_TR2_DETECT_ESCAPE_PULSE_IRQ_MASK (0x1 << 6)
+#define CPHY_RX_TR3_DETECT_ESCAPE_PULSE_IRQ_SHIFT 7
+#define CPHY_RX_TR3_DETECT_ESCAPE_PULSE_IRQ_MASK (0x1 << 7)
+
+#define CPHY_RX_STATE_CHK_EN 0x0100
+#define CPHY_RX_STATE_CHK_EN_TRIO0_SHIFT 0
+#define CPHY_RX_STATE_CHK_EN_TRIO0_MASK (0x1 << 0)
+#define CPHY_RX_STATE_CHK_EN_TRIO1_SHIFT 1
+#define CPHY_RX_STATE_CHK_EN_TRIO1_MASK (0x1 << 1)
+#define CPHY_RX_STATE_CHK_EN_TRIO2_SHIFT 2
+#define CPHY_RX_STATE_CHK_EN_TRIO2_MASK (0x1 << 2)
+#define CPHY_RX_STATE_CHK_EN_TRIO3_SHIFT 3
+#define CPHY_RX_STATE_CHK_EN_TRIO3_MASK (0x1 << 3)
+#define RG_ALPOUT_MASK_SHIFT 16
+#define RG_ALPOUT_MASK_MASK (0xff << 16)
+#define RG_ALP_POST_DET_MASK_SHIFT 24
+#define RG_ALP_POST_DET_MASK_MASK (0xff << 24)
+
+#define CPHY_RX_STATE_CHK_TIMER 0x0104
+#define RG_CPHY_RX_STATE_CHK_RX_TIMER_CNT_SHIFT 0
+#define RG_CPHY_RX_STATE_CHK_RX_TIMER_CNT_MASK (0xffffffff << 0)
+
+#define CPHY_RX_STATE_CHK_STATUS_TRIO0 0x0110
+#define RO_CPHY_RX_STATE_CHK_ERR_TRIO0_SHIFT 0
+#define RO_CPHY_RX_STATE_CHK_ERR_TRIO0_MASK (0x1 << 0)
+#define RO_CPHY_RX_STATE_CHK_ERR_CNT_TRIO0_SHIFT 4
+#define RO_CPHY_RX_STATE_CHK_ERR_CNT_TRIO0_MASK (0x7 << 4)
+#define CPHY_RX_STATE_CHK_FAIL_SEQ0_TRIO0_SHIFT 16
+#define CPHY_RX_STATE_CHK_FAIL_SEQ0_TRIO0_MASK (0xf << 16)
+#define CPHY_RX_STATE_CHK_FAIL_SEQ1_TRIO0_SHIFT 20
+#define CPHY_RX_STATE_CHK_FAIL_SEQ1_TRIO0_MASK (0xf << 20)
+#define CPHY_RX_STATE_CHK_FAIL_SEQ2_TRIO0_SHIFT 24
+#define CPHY_RX_STATE_CHK_FAIL_SEQ2_TRIO0_MASK (0xf << 24)
+#define CPHY_RX_STATE_CHK_FAIL_SEQ3_TRIO0_SHIFT 28
+#define CPHY_RX_STATE_CHK_FAIL_SEQ3_TRIO0_MASK (0xf << 28)
+
+#define CPHY_RX_STATE_CHK_STATUS_TRIO1 0x0114
+#define RO_CPHY_RX_STATE_CHK_ERR_TRIO1_SHIFT 0
+#define RO_CPHY_RX_STATE_CHK_ERR_TRIO1_MASK (0x1 << 0)
+#define RO_CPHY_RX_STATE_CHK_ERR_CNT_TRIO1_SHIFT 4
+#define RO_CPHY_RX_STATE_CHK_ERR_CNT_TRIO1_MASK (0x7 << 4)
+#define CPHY_RX_STATE_CHK_FAIL_SEQ0_TRIO1_SHIFT 16
+#define CPHY_RX_STATE_CHK_FAIL_SEQ0_TRIO1_MASK (0xf << 16)
+#define CPHY_RX_STATE_CHK_FAIL_SEQ1_TRIO1_SHIFT 20
+#define CPHY_RX_STATE_CHK_FAIL_SEQ1_TRIO1_MASK (0xf << 20)
+#define CPHY_RX_STATE_CHK_FAIL_SEQ2_TRIO1_SHIFT 24
+#define CPHY_RX_STATE_CHK_FAIL_SEQ2_TRIO1_MASK (0xf << 24)
+#define CPHY_RX_STATE_CHK_FAIL_SEQ3_TRIO1_SHIFT 28
+#define CPHY_RX_STATE_CHK_FAIL_SEQ3_TRIO1_MASK (0xf << 28)
+
+#define CPHY_RX_STATE_CHK_STATUS_TRIO2 0x0118
+#define RO_CPHY_RX_STATE_CHK_ERR_TRIO2_SHIFT 0
+#define RO_CPHY_RX_STATE_CHK_ERR_TRIO2_MASK (0x1 << 0)
+#define RO_CPHY_RX_STATE_CHK_ERR_CNT_TRIO2_SHIFT 4
+#define RO_CPHY_RX_STATE_CHK_ERR_CNT_TRIO2_MASK (0x7 << 4)
+#define CPHY_RX_STATE_CHK_FAIL_SEQ0_TRIO2_SHIFT 16
+#define CPHY_RX_STATE_CHK_FAIL_SEQ0_TRIO2_MASK (0xf << 16)
+#define CPHY_RX_STATE_CHK_FAIL_SEQ1_TRIO2_SHIFT 20
+#define CPHY_RX_STATE_CHK_FAIL_SEQ1_TRIO2_MASK (0xf << 20)
+#define CPHY_RX_STATE_CHK_FAIL_SEQ2_TRIO2_SHIFT 24
+#define CPHY_RX_STATE_CHK_FAIL_SEQ2_TRIO2_MASK (0xf << 24)
+#define CPHY_RX_STATE_CHK_FAIL_SEQ3_TRIO2_SHIFT 28
+#define CPHY_RX_STATE_CHK_FAIL_SEQ3_TRIO2_MASK (0xf << 28)
+
+#define CPHY_RX_STATE_CHK_STATUS_TRIO3 0x011c
+#define RO_CPHY_RX_STATE_CHK_ERR_TRIO3_SHIFT 0
+#define RO_CPHY_RX_STATE_CHK_ERR_TRIO3_MASK (0x1 << 0)
+#define RO_CPHY_RX_STATE_CHK_ERR_CNT_TRIO3_SHIFT 4
+#define RO_CPHY_RX_STATE_CHK_ERR_CNT_TRIO3_MASK (0x7 << 4)
+#define CPHY_RX_STATE_CHK_FAIL_SEQ0_TRIO3_SHIFT 16
+#define CPHY_RX_STATE_CHK_FAIL_SEQ0_TRIO3_MASK (0xf << 16)
+#define CPHY_RX_STATE_CHK_FAIL_SEQ1_TRIO3_SHIFT 20
+#define CPHY_RX_STATE_CHK_FAIL_SEQ1_TRIO3_MASK (0xf << 20)
+#define CPHY_RX_STATE_CHK_FAIL_SEQ2_TRIO3_SHIFT 24
+#define CPHY_RX_STATE_CHK_FAIL_SEQ2_TRIO3_MASK (0xf << 24)
+#define CPHY_RX_STATE_CHK_FAIL_SEQ3_TRIO3_SHIFT 28
+#define CPHY_RX_STATE_CHK_FAIL_SEQ3_TRIO3_MASK (0xf << 28)
+
+#define CPHY_RX_CAL_ALP_CTRL 0x0130
+#define RG_CPHY_CAL_EN_SHIFT 0
+#define RG_CPHY_CAL_EN_MASK (0x1 << 0)
+#define RG_CPHY_ALP_EN_SHIFT 1
+#define RG_CPHY_ALP_EN_MASK (0x1 << 1)
+#define RG_PREAMBLE_DET_SEL_SHIFT 2
+#define RG_PREAMBLE_DET_SEL_MASK (0x1 << 2)
+#define RG_ALP_POS_DET_SEL_SHIFT 4
+#define RG_ALP_POS_DET_SEL_MASK (0x1 << 4)
+#define RG_ALP_STOP_DET_EN_SHIFT 5
+#define RG_ALP_STOP_DET_EN_MASK (0x1 << 5)
+#ifdef ISP7_1
+#define RG_ALPOUT_MASK_ALP_SHIFT 6
+#define RG_ALPOUT_MASK_ALP_MASK (0x1 << 6)
+#else
+#define RG_ALP_POS_DET_MASK_SHIFT 6
+#define RG_ALP_POS_DET_MASK_MASK (0x3 << 6)
+#endif
+#define RG_ALPRX_EN_SEL_SHIFT 7
+#define RG_ALPRX_EN_SEL_MASK (0x1 << 7)
+#define RG_CPHY_SELCAL_PARAMETER_SHIFT 8
+#define RG_CPHY_SELCAL_PARAMETER_MASK (0xff << 8)
+#define RG_CPHY_ALP_SETTLE_PARAMETER_SHIFT 16
+#define RG_CPHY_ALP_SETTLE_PARAMETER_MASK (0xff << 16)
+#define RG_TR_PREAMBLE_DET_CNT_SHIFT 24
+#define RG_TR_PREAMBLE_DET_CNT_MASK (0xff << 24)
+
+#define CPHY_RX_INIT 0x0134
+#define RG_CSI2_TINIT_CNT_SHIFT 0
+#define RG_CSI2_TINIT_CNT_MASK (0xfffff << 0)
+#define RG_CSI2_TINIT_CNT_EN_SHIFT 31
+#define RG_CSI2_TINIT_CNT_EN_MASK (0x1 << 31)
+
+#endif
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_csi_phy_2_0/mtk_cam-seninf-csi0-dphy.h b/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_csi_phy_2_0/mtk_cam-seninf-csi0-dphy.h
new file mode 100644
index 0000000000000000000000000000000000000000..3a6b88f8e98de625e36a5ce42adb410f035bea23
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_csi_phy_2_0/mtk_cam-seninf-csi0-dphy.h
@@ -0,0 +1,848 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2022 MediaTek Inc.
+ */
+
+#ifndef __CSI0_DPHY_TOP_H__
+#define __CSI0_DPHY_TOP_H__
+
+#define DPHY_RX_LANE_EN 0x0000
+#define DPHY_RX_LC0_EN_SHIFT 0
+#define DPHY_RX_LC0_EN_MASK (0x1 << 0)
+#define DPHY_RX_LC1_EN_SHIFT 1
+#define DPHY_RX_LC1_EN_MASK (0x1 << 1)
+#define DPHY_RX_LD0_EN_SHIFT 8
+#define DPHY_RX_LD0_EN_MASK (0x1 << 8)
+#define DPHY_RX_LD1_EN_SHIFT 9
+#define DPHY_RX_LD1_EN_MASK (0x1 << 9)
+#define DPHY_RX_LD2_EN_SHIFT 10
+#define DPHY_RX_LD2_EN_MASK (0x1 << 10)
+#define DPHY_RX_LD3_EN_SHIFT 11
+#define DPHY_RX_LD3_EN_MASK (0x1 << 11)
+#define DPHY_RX_SW_RST_SHIFT 31
+#define DPHY_RX_SW_RST_MASK (0x1 << 31)
+
+#define DPHY_RX_LANE_SELECT 0x0004
+#define RG_DPHY_RX_LC0_SEL_SHIFT 0
+#define RG_DPHY_RX_LC0_SEL_MASK (0x7 << 0)
+#define RG_DPHY_RX_LC1_SEL_SHIFT 4
+#define RG_DPHY_RX_LC1_SEL_MASK (0x7 << 4)
+#define RG_DPHY_RX_LD0_SEL_SHIFT 8
+#define RG_DPHY_RX_LD0_SEL_MASK (0x7 << 8)
+#define RG_DPHY_RX_LD1_SEL_SHIFT 12
+#define RG_DPHY_RX_LD1_SEL_MASK (0x7 << 12)
+#define RG_DPHY_RX_LD2_SEL_SHIFT 16
+#define RG_DPHY_RX_LD2_SEL_MASK (0x7 << 16)
+#define RG_DPHY_RX_LD3_SEL_SHIFT 20
+#define RG_DPHY_RX_LD3_SEL_MASK (0x7 << 20)
+#define DPHY_RX_CK_DATA_MUX_EN_SHIFT 31
+#define DPHY_RX_CK_DATA_MUX_EN_MASK (0x1 << 31)
+
+#define DPHY_RX_HS_RX_EN_SW 0x0008
+#define RG_DPHY_RX_LC0_HSRX_EN_SW_SHIFT 0
+#define RG_DPHY_RX_LC0_HSRX_EN_SW_MASK (0x1 << 0)
+#define RG_DPHY_RX_LC1_HSRX_EN_SW_SHIFT 1
+#define RG_DPHY_RX_LC1_HSRX_EN_SW_MASK (0x1 << 1)
+#define RG_CDPHY_RX_LD0_TRIO0_HSRX_EN_SW_SHIFT 8
+#define RG_CDPHY_RX_LD0_TRIO0_HSRX_EN_SW_MASK (0x1 << 8)
+#define RG_CDPHY_RX_LD1_TRIO1_HSRX_EN_SW_SHIFT 9
+#define RG_CDPHY_RX_LD1_TRIO1_HSRX_EN_SW_MASK (0x1 << 9)
+#define RG_CDPHY_RX_LD2_TRIO2_HSRX_EN_SW_SHIFT 10
+#define RG_CDPHY_RX_LD2_TRIO2_HSRX_EN_SW_MASK (0x1 << 10)
+#define RG_CDPHY_RX_LD2_TRIO3_HSRX_EN_SW_SHIFT 11
+#define RG_CDPHY_RX_LD2_TRIO3_HSRX_EN_SW_MASK (0x1 << 11)
+
+#define DPHY_RX_CLOCK_LANE0_HS_PARAMETER 0x0010
+#define RG_DPHY_RX_LC0_HS_PREPARE_PARAMETER_SHIFT 0
+#define RG_DPHY_RX_LC0_HS_PREPARE_PARAMETER_MASK (0xff << 0)
+#define RG_DPHY_RX_LC0_HS_SETTLE_PARAMETER_SHIFT 16
+#define RG_DPHY_RX_LC0_HS_SETTLE_PARAMETER_MASK (0xff << 16)
+#define RG_DPHY_RX_LC0_HS_PREPARE_EN_SHIFT 28
+#define RG_DPHY_RX_LC0_HS_PREPARE_EN_MASK (0x1 << 28)
+#define RG_DPHY_RX_LC0_HS_OPTION_SHIFT 30
+#define RG_DPHY_RX_LC0_HS_OPTION_MASK (0x1 << 30)
+
+#define DPHY_RX_CLOCK_LANE1_HS_PARAMETER 0x0014
+#define RG_DPHY_RX_LC1_HS_PREPARE_PARAMETER_SHIFT 0
+#define RG_DPHY_RX_LC1_HS_PREPARE_PARAMETER_MASK (0xff << 0)
+#define RG_DPHY_RX_LC1_HS_SETTLE_PARAMETER_SHIFT 16
+#define RG_DPHY_RX_LC1_HS_SETTLE_PARAMETER_MASK (0xff << 16)
+#define RG_DPHY_RX_LC1_HS_PREPARE_EN_SHIFT 28
+#define RG_DPHY_RX_LC1_HS_PREPARE_EN_MASK (0x1 << 28)
+#define RG_DPHY_RX_LC1_HS_OPTION_SHIFT 30
+#define RG_DPHY_RX_LC1_HS_OPTION_MASK (0x1 << 30)
+
+#define DPHY_RX_DATA_LANE0_HS_PARAMETER 0x0020
+#define RG_CDPHY_RX_LD0_TRIO0_HS_PREPARE_PARAMETER_SHIFT 0
+#define RG_CDPHY_RX_LD0_TRIO0_HS_PREPARE_PARAMETER_MASK (0xff << 0)
+#define RG_DPHY_RX_LD0_HS_TRAIL_PARAMETER_SHIFT 8
+#define RG_DPHY_RX_LD0_HS_TRAIL_PARAMETER_MASK (0xff << 8)
+#define RG_CDPHY_RX_LD0_TRIO0_HS_SETTLE_PARAMETER_SHIFT 16
+#define RG_CDPHY_RX_LD0_TRIO0_HS_SETTLE_PARAMETER_MASK (0xff << 16)
+#define RG_CDPHY_RX_LD0_TRIO0_HS_PREPARE_EN_SHIFT 28
+#define RG_CDPHY_RX_LD0_TRIO0_HS_PREPARE_EN_MASK (0x1 << 28)
+#define RG_DPHY_RX_LD0_HS_TRAIL_EN_SHIFT 29
+#define RG_DPHY_RX_LD0_HS_TRAIL_EN_MASK (0x1 << 29)
+
+#define DPHY_RX_DATA_LANE1_HS_PARAMETER 0x0024
+#define RG_CDPHY_RX_LD1_TRIO1_HS_PREPARE_PARAMETER_SHIFT 0
+#define RG_CDPHY_RX_LD1_TRIO1_HS_PREPARE_PARAMETER_MASK (0xff << 0)
+#define RG_DPHY_RX_LD1_HS_TRAIL_PARAMETER_SHIFT 8
+#define RG_DPHY_RX_LD1_HS_TRAIL_PARAMETER_MASK (0xff << 8)
+#define RG_CDPHY_RX_LD1_TRIO1_HS_SETTLE_PARAMETER_SHIFT 16
+#define RG_CDPHY_RX_LD1_TRIO1_HS_SETTLE_PARAMETER_MASK (0xff << 16)
+#define RG_CDPHY_RX_LD1_TRIO1_HS_PREPARE_EN_SHIFT 28
+#define RG_CDPHY_RX_LD1_TRIO1_HS_PREPARE_EN_MASK (0x1 << 28)
+#define RG_DPHY_RX_LD1_HS_TRAIL_EN_SHIFT 29
+#define RG_DPHY_RX_LD1_HS_TRAIL_EN_MASK (0x1 << 29)
+
+#define DPHY_RX_DATA_LANE2_HS_PARAMETER 0x0028
+#define RG_CDPHY_RX_LD2_TRIO2_HS_PREPARE_PARAMETER_SHIFT 0
+#define RG_CDPHY_RX_LD2_TRIO2_HS_PREPARE_PARAMETER_MASK (0xff << 0)
+#define RG_DPHY_RX_LD2_HS_TRAIL_PARAMETER_SHIFT 8
+#define RG_DPHY_RX_LD2_HS_TRAIL_PARAMETER_MASK (0xff << 8)
+#define RG_CDPHY_RX_LD2_TRIO2_HS_SETTLE_PARAMETER_SHIFT 16
+#define RG_CDPHY_RX_LD2_TRIO2_HS_SETTLE_PARAMETER_MASK (0xff << 16)
+#define RG_CDPHY_RX_LD2_TRIO2_HS_PREPARE_EN_SHIFT 28
+#define RG_CDPHY_RX_LD2_TRIO2_HS_PREPARE_EN_MASK (0x1 << 28)
+#define RG_DPHY_RX_LD2_HS_TRAIL_EN_SHIFT 29
+#define RG_DPHY_RX_LD2_HS_TRAIL_EN_MASK (0x1 << 29)
+
+#define DPHY_RX_DATA_LANE3_HS_PARAMETER 0x002c
+#define RG_CDPHY_RX_LD3_TRIO3_HS_PREPARE_PARAMETER_SHIFT 0
+#define RG_CDPHY_RX_LD3_TRIO3_HS_PREPARE_PARAMETER_MASK (0xff << 0)
+#define RG_DPHY_RX_LD3_HS_TRAIL_PARAMETER_SHIFT 8
+#define RG_DPHY_RX_LD3_HS_TRAIL_PARAMETER_MASK (0xff << 8)
+#define RG_CDPHY_RX_LD3_TRIO3_HS_SETTLE_PARAMETER_SHIFT 16
+#define RG_CDPHY_RX_LD3_TRIO3_HS_SETTLE_PARAMETER_MASK (0xff << 16)
+#define RG_CDPHY_RX_LD3_TRIO3_HS_PREPARE_EN_SHIFT 28
+#define RG_CDPHY_RX_LD3_TRIO3_HS_PREPARE_EN_MASK (0x1 << 28)
+#define RG_DPHY_RX_LD3_HS_TRAIL_EN_SHIFT 29
+#define RG_DPHY_RX_LD3_HS_TRAIL_EN_MASK (0x1 << 29)
+
+#define DPHY_RX_CLOCK_LANE_FSM 0x0030
+#define RO_DPHY_RX_CL0_FSM_SHIFT 0
+#define RO_DPHY_RX_CL0_FSM_MASK (0x3f << 0)
+#define RO_DPHY_RX_CL1_FSM_SHIFT 8
+#define RO_DPHY_RX_CL1_FSM_MASK (0x3f << 8)
+
+#define DPHY_RX_DATA_LANE_FSM 0x0034
+#ifdef ISP7_1
+#define RO_DPHY_RX_DL0_FSM_MASK (0xff << 0)
+#define RO_DPHY_RX_DL1_FSM_MASK (0xff << 8)
+#define RO_DPHY_RX_DL2_FSM_MASK (0xff << 16)
+#define RO_DPHY_RX_DL3_FSM_MASK (0xff << 24)
+#else
+#define RO_DPHY_RX_DL0_FSM_MASK (0x3f << 0)
+#define RO_DPHY_RX_DL1_FSM_MASK (0x3f << 8)
+#define RO_DPHY_RX_DL2_FSM_MASK (0x3f << 16)
+#define RO_DPHY_RX_DL3_FSM_MASK (0x3f << 24)
+#endif
+#define RO_DPHY_RX_DL0_FSM_SHIFT 0
+#define RO_DPHY_RX_DL1_FSM_SHIFT 8
+#define RO_DPHY_RX_DL2_FSM_SHIFT 16
+#define RO_DPHY_RX_DL3_FSM_SHIFT 24
+
+#define DPHY_RX_DATA_LANE_SYNC_DETECT_NORMAL 0x0040
+#define RG_DPHY_RX_LD_SYNC_SEQ_PAT_NORM_SHIFT 0
+#define RG_DPHY_RX_LD_SYNC_SEQ_PAT_NORM_MASK (0xffff << 0)
+#define RG_DPHY_RX_LD_SYNC_SEQ_MASK_NORM_SHIFT 16
+#define RG_DPHY_RX_LD_SYNC_SEQ_MASK_NORM_MASK (0xffff << 16)
+
+#define DPHY_RX_DATA_LANE_SYNC_DETECT_DESKEW 0x0044
+#define RG_DPHY_RX_LD_SYNC_SEQ_PAT_DESKEW_SHIFT 0
+#define RG_DPHY_RX_LD_SYNC_SEQ_PAT_DESKEW_MASK (0xffff << 0)
+#define RG_DPHY_RX_LD_SYNC_SEQ_MASK_DESKEW_SHIFT 16
+#define RG_DPHY_RX_LD_SYNC_SEQ_MASK_DESKEW_MASK (0xffff << 16)
+
+#define DPHY_RX_DATA_LANE_SYNC_DETECT_ALTCAL 0x0048
+#define RG_DPHY_RX_LD_SYNC_SEQ_PAT_ALT_CAL_SHIFT 0
+#define RG_DPHY_RX_LD_SYNC_SEQ_PAT_ALT_CAL_MASK (0xffff << 0)
+#define RG_DPHY_RX_LD_SYNC_SEQ_MASK_ALT_CAL_SHIFT 16
+#define RG_DPHY_RX_LD_SYNC_SEQ_MASK_ALT_CAL_MASK (0xffff << 16)
+
+#define DPHY_RX_DATA_LANE_SYNC_DETECT_PRESEQ 0x004c
+#define RG_DPHY_RX_LD_SYNC_SEQ_PAT_PRE_SEQ_SHIFT 0
+#define RG_DPHY_RX_LD_SYNC_SEQ_PAT_PRE_SEQ_MASK (0xffff << 0)
+#define RG_DPHY_RX_LD_SYNC_SEQ_MASK_PRE_SEQ_SHIFT 16
+#define RG_DPHY_RX_LD_SYNC_SEQ_MASK_PRE_SEQ_MASK (0xffff << 16)
+
+#define DPHY_RX_DESKEW_CTRL 0x0050
+#define RG_DPHY_RX_DESKEW_INITIAL_SETUP_SHIFT 0
+#define RG_DPHY_RX_DESKEW_INITIAL_SETUP_MASK (0xf << 0)
+#define RG_DPHY_RX_DESKEW_OFFSET_SHIFT 4
+#define RG_DPHY_RX_DESKEW_OFFSET_MASK (0xf << 4)
+#define RG_DPHY_RX_DESKEW_EN_SHIFT 8
+#define RG_DPHY_RX_DESKEW_EN_MASK (0x1 << 8)
+#define RG_DPHY_RX_DESKEW_CODE_UNIT_SEL_SHIFT 9
+#define RG_DPHY_RX_DESKEW_CODE_UNIT_SEL_MASK (0x1 << 9)
+#define RG_DPHY_RX_DESKEW_HW_DELAY_APPLY_OPT_SHIFT 10
+#define RG_DPHY_RX_DESKEW_HW_DELAY_APPLY_OPT_MASK (0x1 << 10)
+#define RG_DPHY_RX_DESKEW_ACC_MODE_SHIFT 12
+#define RG_DPHY_RX_DESKEW_ACC_MODE_MASK (0xf << 12)
+#define RG_DPHY_RX_DESKEW_APPLY_MODE_SHIFT 16
+#define RG_DPHY_RX_DESKEW_APPLY_MODE_MASK (0xf << 16)
+#define RG_DPHY_RX_DESKEW_LENGTH_SHIFT 24
+#define RG_DPHY_RX_DESKEW_LENGTH_MASK (0x3f << 24)
+#define DPHY_RX_DESKEW_SW_RST_SHIFT 31
+#define DPHY_RX_DESKEW_SW_RST_MASK (0x1 << 31)
+
+#define DPHY_RX_DESKEW_TIMING_CTRL 0x0054
+#define RG_DPHY_RX_DESKEW_SETUP_CNT_SHIFT 0
+#define RG_DPHY_RX_DESKEW_SETUP_CNT_MASK (0xf << 0)
+#define RG_DPHY_RX_DESKEW_HOLD_CNT_SHIFT 8
+#define RG_DPHY_RX_DESKEW_HOLD_CNT_MASK (0xf << 8)
+#define RG_DPHY_RX_DESKEW_DETECT_CNT_SHIFT 16
+#define RG_DPHY_RX_DESKEW_DETECT_CNT_MASK (0x7f << 16)
+#define RG_DPHY_RX_DESKEW_CMPLENGTH_SHIFT 24
+#define RG_DPHY_RX_DESKEW_CMPLENGTH_MASK (0xf << 24)
+
+#define DPHY_RX_DESKEW_LANE_SWAP 0x0058
+#define RG_DPHY_RX_DESKEW_LANE0_SWAP_SHIFT 0
+#define RG_DPHY_RX_DESKEW_LANE0_SWAP_MASK (0x3 << 0)
+#define RG_DPHY_RX_DESKEW_LANE1_SWAP_SHIFT 2
+#define RG_DPHY_RX_DESKEW_LANE1_SWAP_MASK (0x3 << 2)
+#define RG_DPHY_RX_DESKEW_LANE2_SWAP_SHIFT 4
+#define RG_DPHY_RX_DESKEW_LANE2_SWAP_MASK (0x3 << 4)
+#define RG_DPHY_RX_DESKEW_LANE3_SWAP_SHIFT 6
+#define RG_DPHY_RX_DESKEW_LANE3_SWAP_MASK (0x3 << 6)
+#define RG_MIN_CODE_SHIFT 24
+#define RG_MIN_CODE_MASK (0x7 << 24)
+#define RG_MIN_CODE_EN_SHIFT 28
+#define RG_MIN_CODE_EN_MASK (0x1 << 28)
+#define RG_DBG_CLR_SHIFT 29
+#define RG_DBG_CLR_MASK (0x1 << 29)
+#define RG_APPLY_ONLY_1ST_PAT_SHIFT 30
+#define RG_APPLY_ONLY_1ST_PAT_MASK (0x1 << 30)
+#define RG_DBGST_OPT_SHIFT 31
+#define RG_DBGST_OPT_MASK (0x1 << 31)
+
+#define DPHY_RX_DESKEW_LANE0_CTRL 0x0060
+#define DPHY_RX_DESKEW_L0_DELAY_EN_SHIFT 0
+#define DPHY_RX_DESKEW_L0_DELAY_EN_MASK (0x1 << 0)
+#define RG_DPHY_RX_DESKEW_L0_DELAY_APPLY_SHIFT 1
+#define RG_DPHY_RX_DESKEW_L0_DELAY_APPLY_MASK (0x1 << 1)
+#define RG_DPHY_RX_DESKEW_L0_DELAY_CODE_SHIFT 8
+#define RG_DPHY_RX_DESKEW_L0_DELAY_CODE_MASK (0x3f << 8)
+#define RG_DPHY_RX_DESKEW_L0_PERIODIC_SHIFT 16
+#define RG_DPHY_RX_DESKEW_L0_PERIODIC_MASK (0x1 << 16)
+#define RG_PERIODIC_DESKEW_1DIR_ONLY_SHIFT 17
+#define RG_PERIODIC_DESKEW_1DIR_ONLY_MASK (0x1 << 17)
+#define RG_DPHY_RX_DESKEW_L0_PERIODIC_DELAY_CODE_CNT_SHIFT 20
+#define RG_DPHY_RX_DESKEW_L0_PERIODIC_DELAY_CODE_CNT_MASK (0xf << 20)
+
+#define DPHY_RX_DESKEW_LANE1_CTRL 0x0064
+#define DPHY_RX_DESKEW_L1_DELAY_EN_SHIFT 0
+#define DPHY_RX_DESKEW_L1_DELAY_EN_MASK (0x1 << 0)
+#define RG_DPHY_RX_DESKEW_L1_DELAY_APPLY_SHIFT 1
+#define RG_DPHY_RX_DESKEW_L1_DELAY_APPLY_MASK (0x1 << 1)
+#define RG_DPHY_RX_DESKEW_L1_DELAY_CODE_SHIFT 8
+#define RG_DPHY_RX_DESKEW_L1_DELAY_CODE_MASK (0x3f << 8)
+#define RG_DPHY_RX_DESKEW_L1_PERIODIC_SHIFT 16
+#define RG_DPHY_RX_DESKEW_L1_PERIODIC_MASK (0x1 << 16)
+#define RG_DPHY_RX_DESKEW_L1_PERIODIC_DELAY_CODE_CNT_SHIFT 20
+#define RG_DPHY_RX_DESKEW_L1_PERIODIC_DELAY_CODE_CNT_MASK (0xf << 20)
+
+#define DPHY_RX_DESKEW_LANE2_CTRL 0x0068
+#define DPHY_RX_DESKEW_L2_DELAY_EN_SHIFT 0
+#define DPHY_RX_DESKEW_L2_DELAY_EN_MASK (0x1 << 0)
+#define RG_DPHY_RX_DESKEW_L2_DELAY_APPLY_SHIFT 1
+#define RG_DPHY_RX_DESKEW_L2_DELAY_APPLY_MASK (0x1 << 1)
+#define RG_DPHY_RX_DESKEW_L2_DELAY_CODE_SHIFT 8
+#define RG_DPHY_RX_DESKEW_L2_DELAY_CODE_MASK (0x3f << 8)
+#define RG_DPHY_RX_DESKEW_L2_PERIODIC_SHIFT 16
+#define RG_DPHY_RX_DESKEW_L2_PERIODIC_MASK (0x1 << 16)
+#define RG_DPHY_RX_DESKEW_L2_PERIODIC_DELAY_CODE_CNT_SHIFT 20
+#define RG_DPHY_RX_DESKEW_L2_PERIODIC_DELAY_CODE_CNT_MASK (0xf << 20)
+
+#define DPHY_RX_DESKEW_LANE3_CTRL 0x006c
+#define DPHY_RX_DESKEW_L3_DELAY_EN_SHIFT 0
+#define DPHY_RX_DESKEW_L3_DELAY_EN_MASK (0x1 << 0)
+#define RG_DPHY_RX_DESKEW_L3_DELAY_APPLY_SHIFT 1
+#define RG_DPHY_RX_DESKEW_L3_DELAY_APPLY_MASK (0x1 << 1)
+#define RG_DPHY_RX_DESKEW_L3_DELAY_CODE_SHIFT 8
+#define RG_DPHY_RX_DESKEW_L3_DELAY_CODE_MASK (0x3f << 8)
+#define RG_DPHY_RX_DESKEW_L3_PERIODIC_SHIFT 16
+#define RG_DPHY_RX_DESKEW_L3_PERIODIC_MASK (0x1 << 16)
+#define RG_DPHY_RX_DESKEW_L3_PERIODIC_DELAY_CODE_CNT_SHIFT 20
+#define RG_DPHY_RX_DESKEW_L3_PERIODIC_DELAY_CODE_CNT_MASK (0xf << 20)
+
+#define DPHY_RX_DESKEW_LANE0_DA_READ 0x0070
+#define RO_DA_DPHY_L0_DELAY_EN_SHIFT 0
+#define RO_DA_DPHY_L0_DELAY_EN_MASK (0x1 << 0)
+#define RO_DA_DPHY_L0_DELAY_APPLY_SHIFT 1
+#define RO_DA_DPHY_L0_DELAY_APPLY_MASK (0x1 << 1)
+#define RO_DA_DPHY_L0_DELAY_CODE_SHIFT 8
+#define RO_DA_DPHY_L0_DELAY_CODE_MASK (0x7f << 8)
+
+#define DPHY_RX_DESKEW_LANE1_DA_READ 0x0074
+#define RO_DA_DPHY_L1_DELAY_EN_SHIFT 0
+#define RO_DA_DPHY_L1_DELAY_EN_MASK (0x1 << 0)
+#define RO_DA_DPHY_L1_DELAY_APPLY_SHIFT 1
+#define RO_DA_DPHY_L1_DELAY_APPLY_MASK (0x1 << 1)
+#define RO_DA_DPHY_L0_DELAY_CODE_SHIFT 8
+#define RO_DA_DPHY_L0_DELAY_CODE_MASK (0x7f << 8)
+
+#define DPHY_RX_DESKEW_LANE2_DA_READ 0x0078
+#define RO_DA_DPHY_L2_DELAY_EN_SHIFT 0
+#define RO_DA_DPHY_L2_DELAY_EN_MASK (0x1 << 0)
+#define RO_DA_DPHY_L2_DELAY_APPLY_SHIFT 1
+#define RO_DA_DPHY_L2_DELAY_APPLY_MASK (0x1 << 1)
+#define RO_DA_DPHY_L0_DELAY_CODE_SHIFT 8
+#define RO_DA_DPHY_L0_DELAY_CODE_MASK (0x7f << 8)
+
+#define DPHY_RX_DESKEW_LANE3_DA_READ 0x007c
+#define RO_DA_DPHY_L3_DELAY_EN_SHIFT 0
+#define RO_DA_DPHY_L3_DELAY_EN_MASK (0x1 << 0)
+#define RO_DA_DPHY_L3_DELAY_APPLY_SHIFT 1
+#define RO_DA_DPHY_L3_DELAY_APPLY_MASK (0x1 << 1)
+#define RO_DA_DPHY_L0_DELAY_CODE_SHIFT 8
+#define RO_DA_DPHY_L0_DELAY_CODE_MASK (0x7f << 8)
+
+#define DPHY_RX_DESKEW_IRQ_EN 0x0080
+#define RG_DPHY_RX_DESKEW_IRQ_EN_SHIFT 0
+#define RG_DPHY_RX_DESKEW_IRQ_EN_MASK (0xffff << 0)
+#define RG_DPHY_RX_DESKEW_IRQ_W1C_EN_SHIFT 31
+#define RG_DPHY_RX_DESKEW_IRQ_W1C_EN_MASK (0x1 << 31)
+
+#define DPHY_RX_DESKEW_IRQ_STATUS 0x0084
+#define RO_DPHY_RX_DESKEW_IRQ_STATUS_SHIFT 0
+#define RO_DPHY_RX_DESKEW_IRQ_STATUS_MASK (0xffff << 0)
+
+#define DPHY_RX_IRQ_EN 0x0088
+#define RG_DPHY_RX_ERR_SOT_SYNC_HS_L0_IRQ_EN_SHIFT 0
+#define RG_DPHY_RX_ERR_SOT_SYNC_HS_L0_IRQ_EN_MASK (0x1 << 0)
+#define RG_DPHY_RX_ERR_SOT_SYNC_HS_L1_IRQ_EN_SHIFT 1
+#define RG_DPHY_RX_ERR_SOT_SYNC_HS_L1_IRQ_EN_MASK (0x1 << 1)
+#define RG_DPHY_RX_ERR_SOT_SYNC_HS_L2_IRQ_EN_SHIFT 2
+#define RG_DPHY_RX_ERR_SOT_SYNC_HS_L2_IRQ_EN_MASK (0x1 << 2)
+#define RG_DPHY_RX_ERR_SOT_SYNC_HS_L3_IRQ_EN_SHIFT 3
+#define RG_DPHY_RX_ERR_SOT_SYNC_HS_L3_IRQ_EN_MASK (0x1 << 3)
+#define RG_DPHY_RX_IRQ_W1C_EN_SHIFT 31
+#define RG_DPHY_RX_IRQ_W1C_EN_MASK (0x1 << 31)
+
+#define DPHY_RX_IRQ_STATUS 0x008c
+#define DPHY_RX_ERR_SOT_SYNC_HS_L0_IRQ_SHIFT 0
+#define DPHY_RX_ERR_SOT_SYNC_HS_L0_IRQ_MASK (0x1 << 0)
+#define DPHY_RX_ERR_SOT_SYNC_HS_L1_IRQ_SHIFT 1
+#define DPHY_RX_ERR_SOT_SYNC_HS_L1_IRQ_MASK (0x1 << 1)
+#define DPHY_RX_ERR_SOT_SYNC_HS_L2_IRQ_SHIFT 2
+#define DPHY_RX_ERR_SOT_SYNC_HS_L2_IRQ_MASK (0x1 << 2)
+#define DPHY_RX_ERR_SOT_SYNC_HS_L3_IRQ_SHIFT 3
+#define DPHY_RX_ERR_SOT_SYNC_HS_L3_IRQ_MASK (0x1 << 3)
+
+#define DPHY_RX_STATUS_0 0x00a0
+#define RO_DPHY_RX_LD0_SYNC_SEQ_POS_NORM_SHIFT 0
+#define RO_DPHY_RX_LD0_SYNC_SEQ_POS_NORM_MASK (0xf << 0)
+#define RO_DPHY_RX_LD1_SYNC_SEQ_POS_NORM_SHIFT 4
+#define RO_DPHY_RX_LD1_SYNC_SEQ_POS_NORM_MASK (0xf << 4)
+#define RO_DPHY_RX_LD2_SYNC_SEQ_POS_NORM_SHIFT 8
+#define RO_DPHY_RX_LD2_SYNC_SEQ_POS_NORM_MASK (0xf << 8)
+#define RO_DPHY_RX_LD3_SYNC_SEQ_POS_NORM_SHIFT 12
+#define RO_DPHY_RX_LD3_SYNC_SEQ_POS_NORM_MASK (0xf << 12)
+#define RO_DPHY_RX_LD0_SYNC_SEQ_POS_DESKEW_SHIFT 16
+#define RO_DPHY_RX_LD0_SYNC_SEQ_POS_DESKEW_MASK (0xf << 16)
+#define RO_DPHY_RX_LD1_SYNC_SEQ_POS_DESKEW_SHIFT 20
+#define RO_DPHY_RX_LD1_SYNC_SEQ_POS_DESKEW_MASK (0xf << 20)
+#define RO_DPHY_RX_LD2_SYNC_SEQ_POS_DESKEW_SHIFT 24
+#define RO_DPHY_RX_LD2_SYNC_SEQ_POS_DESKEW_MASK (0xf << 24)
+#define RO_DPHY_RX_LD3_SYNC_SEQ_POS_DESKEW_SHIFT 28
+#define RO_DPHY_RX_LD3_SYNC_SEQ_POS_DESKEW_MASK (0xf << 28)
+
+#define DPHY_RX_DESKEW_DBG_MUX 0x00e0
+#define RG_DPHY_RX_DESKEW_DBG_MUX_SHIFT 0
+#define RG_DPHY_RX_DESKEW_DBG_MUX_MASK (0xff << 0)
+
+#define DPHY_RX_DESKEW_OUT 0x00e4
+#define RG_DPHY_RX_DESKEW_DBG_OUT_SHIFT 0
+#ifdef ISP7_1
+#define RG_DPHY_RX_DESKEW_DBG_OUT_MASK (0xffffffff << 0)
+#else
+#define RG_DPHY_RX_DESKEW_DBG_OUT_MASK (0xff << 0)
+#endif
+#define DPHY_RX_SPARE0 0x00f0
+#define RG_DPHY_RX_SPARE0_SHIFT 0
+#define RG_DPHY_RX_SPARE0_MASK (0x3f << 0)
+#define RG_POST_CNT_SHIFT 6
+#define RG_POST_CNT_MASK (0x3f << 6)
+#define RG_DPHY_RX_SPARE0_2_SHIFT 12
+#define RG_DPHY_RX_SPARE0_2_MASK (0xfffff << 12)
+
+#define DPHY_RX_SPARE1 0x00f4
+#define RG_DPHY_RX_SPARE1_SHIFT 0
+#define RG_DPHY_RX_SPARE1_MASK (0xffffffff << 0)
+
+#define DPHY_RX_BIST_ENABLE 0x0100
+#define DPHY_RX_BIST_EN_LANE0_SHIFT 0
+#define DPHY_RX_BIST_EN_LANE0_MASK (0x1 << 0)
+#define DPHY_RX_BIST_EN_LANE1_SHIFT 1
+#define DPHY_RX_BIST_EN_LANE1_MASK (0x1 << 1)
+#define DPHY_RX_BIST_EN_LANE2_SHIFT 2
+#define DPHY_RX_BIST_EN_LANE2_MASK (0x1 << 2)
+#define DPHY_RX_BIST_EN_LANE3_SHIFT 3
+#define DPHY_RX_BIST_EN_LANE3_MASK (0x1 << 3)
+#define RG_PHY2MAC_CDPHY_GEN_EN_SHIFT 8
+#define RG_PHY2MAC_CDPHY_GEN_EN_MASK (0x1 << 8)
+#define RG_PHY2MAC_CDPHY_GEN_MODE_SHIFT 9
+#define RG_PHY2MAC_CDPHY_GEN_MODE_MASK (0x1 << 9)
+#define RG_PHY2MAC_CDPHY_GEN_SEL_SHIFT 10
+#define RG_PHY2MAC_CDPHY_GEN_SEL_MASK (0x1 << 10)
+
+#define DPHY_RX_BIST_STATUS 0x0104
+#define RO_DPHY_RX_BIST_OK_LANE0_SHIFT 0
+#define RO_DPHY_RX_BIST_OK_LANE0_MASK (0x1 << 0)
+#define RO_DPHY_RX_BIST_OK_LANE1_SHIFT 1
+#define RO_DPHY_RX_BIST_OK_LANE1_MASK (0x1 << 1)
+#define RO_DPHY_RX_BIST_OK_LANE2_SHIFT 2
+#define RO_DPHY_RX_BIST_OK_LANE2_MASK (0x1 << 2)
+#define RO_DPHY_RX_BIST_OK_LANE3_SHIFT 3
+#define RO_DPHY_RX_BIST_OK_LANE3_MASK (0x1 << 3)
+#define RO_DPHY_RX_BIST_HS_MODE_OK_LANE0_SHIFT 8
+#define RO_DPHY_RX_BIST_HS_MODE_OK_LANE0_MASK (0x1 << 8)
+#define RO_DPHY_RX_BIST_HS_MODE_OK_LANE1_SHIFT 9
+#define RO_DPHY_RX_BIST_HS_MODE_OK_LANE1_MASK (0x1 << 9)
+#define RO_DPHY_RX_BIST_HS_MODE_OK_LANE2_SHIFT 10
+#define RO_DPHY_RX_BIST_HS_MODE_OK_LANE2_MASK (0x1 << 10)
+#define RO_DPHY_RX_BIST_HS_MODE_OK_LANE3_SHIFT 11
+#define RO_DPHY_RX_BIST_HS_MODE_OK_LANE3_MASK (0x1 << 11)
+#define RO_DPHY_RX_BIST_LP_MODE_OK_LANE0_SHIFT 16
+#define RO_DPHY_RX_BIST_LP_MODE_OK_LANE0_MASK (0x1 << 16)
+#define RO_DPHY_RX_BIST_LP_MODE_OK_LANE1_SHIFT 17
+#define RO_DPHY_RX_BIST_LP_MODE_OK_LANE1_MASK (0x1 << 17)
+#define RO_DPHY_RX_BIST_LP_MODE_OK_LANE2_SHIFT 18
+#define RO_DPHY_RX_BIST_LP_MODE_OK_LANE2_MASK (0x1 << 18)
+#define RO_DPHY_RX_BIST_LP_MODE_OK_LANE3_SHIFT 19
+#define RO_DPHY_RX_BIST_LP_MODE_OK_LANE3_MASK (0x1 << 19)
+
+#define DPHY_RX_BIST_CONFIG_0_LANE0 0x0110
+#define RG_DPHY_RX_BIST_MODE_LANE0_SHIFT 0
+#define RG_DPHY_RX_BIST_MODE_LANE0_MASK (0x3 << 0)
+#define RG_DPHY_RX_BIST_HS_FIX_PAT_LANE0_SHIFT 4
+#define RG_DPHY_RX_BIST_HS_FIX_PAT_LANE0_MASK (0x1 << 4)
+#define RG_DPHY_RX_BIST_HS_SYNC_DET_UNBLOCK_LANE0_SHIFT 5
+#define RG_DPHY_RX_BIST_HS_SYNC_DET_UNBLOCK_LANE0_MASK (0x1 << 5)
+#define RG_DPHY_RX_BIST_HS_RAN_PAT_MASK_N_LANE0_SHIFT 8
+#define RG_DPHY_RX_BIST_HS_RAN_PAT_MASK_N_LANE0_MASK (0xff << 8)
+#define RG_DPHY_RX_BIST_HS_LENGTH_LANE0_SHIFT 16
+#define RG_DPHY_RX_BIST_HS_LENGTH_LANE0_MASK (0x7fff << 16)
+
+#define DPHY_RX_BIST_CONFIG_1_LANE0 0x0114
+#define RG_DPHY_RX_BIST_LP_MODE_SEQ0_LANE0_SHIFT 0
+#define RG_DPHY_RX_BIST_LP_MODE_SEQ0_LANE0_MASK (0x3 << 0)
+#define RG_DPHY_RX_BIST_LP_MODE_SEQ1_LANE0_SHIFT 2
+#define RG_DPHY_RX_BIST_LP_MODE_SEQ1_LANE0_MASK (0x3 << 2)
+#define RG_DPHY_RX_BIST_LP_MODE_SEQ2_LANE0_SHIFT 4
+#define RG_DPHY_RX_BIST_LP_MODE_SEQ2_LANE0_MASK (0x3 << 4)
+#define RG_DPHY_RX_BIST_LP_MODE_SEQ3_LANE0_SHIFT 6
+#define RG_DPHY_RX_BIST_LP_MODE_SEQ3_LANE0_MASK (0x3 << 6)
+#define RG_DPHY_RX_BIST_LP_MODE_SEQ4_LANE0_SHIFT 8
+#define RG_DPHY_RX_BIST_LP_MODE_SEQ4_LANE0_MASK (0x3 << 8)
+#define RG_DPHY_RX_BIST_LP_MODE_LENGTH_LANE0_SHIFT 16
+#define RG_DPHY_RX_BIST_LP_MODE_LENGTH_LANE0_MASK (0x7 << 16)
+
+#define DPHY_RX_BIST_STATUS_LANE0 0x0118
+#define RO_DPHY_RX_BIST_START_LANE0_SHIFT 0
+#define RO_DPHY_RX_BIST_START_LANE0_MASK (0x1 << 0)
+#define RO_DPHY_RX_BIST_HS_OK_LANE0_SHIFT 1
+#define RO_DPHY_RX_BIST_HS_OK_LANE0_MASK (0x1 << 1)
+#define RO_DPHY_RX_BIST_DATA_OK_LANE0_SHIFT 2
+#define RO_DPHY_RX_BIST_DATA_OK_LANE0_MASK (0x1 << 2)
+#define RO_DPHY_RX_BIST_FSM_OK_LANE0_SHIFT 3
+#define RO_DPHY_RX_BIST_FSM_OK_LANE0_MASK (0x1 << 3)
+#define RO_DPHY_RX_BIST_LP_FAIL_SEQ_NUMBER_LANE0_SHIFT 8
+#define RO_DPHY_RX_BIST_LP_FAIL_SEQ_NUMBER_LANE0_MASK (0x7 << 8)
+#define RO_DPHY_RX_BIST_LP_FAIL_SEQ_LANE0_SHIFT 12
+#define RO_DPHY_RX_BIST_LP_FAIL_SEQ_LANE0_MASK (0x3 << 12)
+
+#define DPHY_RX_BIST_CONFIG_0_LANE1 0x0120
+#define RG_DPHY_RX_BIST_MODE_LANE1_SHIFT 0
+#define RG_DPHY_RX_BIST_MODE_LANE1_MASK (0x3 << 0)
+#define RG_DPHY_RX_BIST_HS_FIX_PAT_LANE1_SHIFT 4
+#define RG_DPHY_RX_BIST_HS_FIX_PAT_LANE1_MASK (0x1 << 4)
+#define RG_DPHY_RX_BIST_HS_SYNC_DET_UNBLOCK_LANE1_SHIFT 5
+#define RG_DPHY_RX_BIST_HS_SYNC_DET_UNBLOCK_LANE1_MASK (0x1 << 5)
+#define RG_DPHY_RX_BIST_HS_RAN_PAT_MASK_N_LANE1_SHIFT 8
+#define RG_DPHY_RX_BIST_HS_RAN_PAT_MASK_N_LANE1_MASK (0xff << 8)
+#define RG_DPHY_RX_BIST_HS_LENGTH_LANE1_SHIFT 16
+#define RG_DPHY_RX_BIST_HS_LENGTH_LANE1_MASK (0x7fff << 16)
+
+#define DPHY_RX_BIST_CONFIG_1_LANE1 0x0124
+#define RG_DPHY_RX_BIST_LP_MODE_SEQ0_LANE1_SHIFT 0
+#define RG_DPHY_RX_BIST_LP_MODE_SEQ0_LANE1_MASK (0x3 << 0)
+#define RG_DPHY_RX_BIST_LP_MODE_SEQ1_LANE1_SHIFT 2
+#define RG_DPHY_RX_BIST_LP_MODE_SEQ1_LANE1_MASK (0x3 << 2)
+#define RG_DPHY_RX_BIST_LP_MODE_SEQ2_LANE1_SHIFT 4
+#define RG_DPHY_RX_BIST_LP_MODE_SEQ2_LANE1_MASK (0x3 << 4)
+#define RG_DPHY_RX_BIST_LP_MODE_SEQ3_LANE1_SHIFT 6
+#define RG_DPHY_RX_BIST_LP_MODE_SEQ3_LANE1_MASK (0x3 << 6)
+#define RG_DPHY_RX_BIST_LP_MODE_SEQ4_LANE1_SHIFT 8
+#define RG_DPHY_RX_BIST_LP_MODE_SEQ4_LANE1_MASK (0x3 << 8)
+#define RG_DPHY_RX_BIST_LP_MODE_LENGTH_LANE1_SHIFT 16
+#define RG_DPHY_RX_BIST_LP_MODE_LENGTH_LANE1_MASK (0x7 << 16)
+
+#define DPHY_RX_BIST_STATUS_LANE1 0x0128
+#define RO_DPHY_RX_BIST_START_LANE1_SHIFT 0
+#define RO_DPHY_RX_BIST_START_LANE1_MASK (0x1 << 0)
+#define RO_DPHY_RX_BIST_HS_OK_LANE1_SHIFT 1
+#define RO_DPHY_RX_BIST_HS_OK_LANE1_MASK (0x1 << 1)
+#define RO_DPHY_RX_BIST_DATA_OK_LANE1_SHIFT 2
+#define RO_DPHY_RX_BIST_DATA_OK_LANE1_MASK (0x1 << 2)
+#define RO_DPHY_RX_BIST_FSM_OK_LANE1_SHIFT 3
+#define RO_DPHY_RX_BIST_FSM_OK_LANE1_MASK (0x1 << 3)
+#define RO_DPHY_RX_BIST_LP_FAIL_SEQ_NUMBER_LANE1_SHIFT 8
+#define RO_DPHY_RX_BIST_LP_FAIL_SEQ_NUMBER_LANE1_MASK (0x7 << 8)
+#define RO_DPHY_RX_BIST_LP_FAIL_SEQ_LANE1_SHIFT 12
+#define RO_DPHY_RX_BIST_LP_FAIL_SEQ_LANE1_MASK (0x3 << 12)
+
+#define DPHY_RX_BIST_CONFIG_0_LANE2 0x0130
+#define RG_DPHY_RX_BIST_MODE_LANE2_SHIFT 0
+#define RG_DPHY_RX_BIST_MODE_LANE2_MASK (0x3 << 0)
+#define RG_DPHY_RX_BIST_HS_FIX_PAT_LANE2_SHIFT 4
+#define RG_DPHY_RX_BIST_HS_FIX_PAT_LANE2_MASK (0x1 << 4)
+#define RG_DPHY_RX_BIST_HS_SYNC_DET_UNBLOCK_LANE2_SHIFT 5
+#define RG_DPHY_RX_BIST_HS_SYNC_DET_UNBLOCK_LANE2_MASK (0x1 << 5)
+#define RG_DPHY_RX_BIST_HS_RAN_PAT_MASK_N_LANE2_SHIFT 8
+#define RG_DPHY_RX_BIST_HS_RAN_PAT_MASK_N_LANE2_MASK (0xff << 8)
+#define RG_DPHY_RX_BIST_HS_LENGTH_LANE2_SHIFT 16
+#define RG_DPHY_RX_BIST_HS_LENGTH_LANE2_MASK (0x7fff << 16)
+
+#define DPHY_RX_BIST_CONFIG_1_LANE2 0x0134
+#define RG_DPHY_RX_BIST_LP_MODE_SEQ0_LANE2_SHIFT 0
+#define RG_DPHY_RX_BIST_LP_MODE_SEQ0_LANE2_MASK (0x3 << 0)
+#define RG_DPHY_RX_BIST_LP_MODE_SEQ1_LANE2_SHIFT 2
+#define RG_DPHY_RX_BIST_LP_MODE_SEQ1_LANE2_MASK (0x3 << 2)
+#define RG_DPHY_RX_BIST_LP_MODE_SEQ2_LANE2_SHIFT 4
+#define RG_DPHY_RX_BIST_LP_MODE_SEQ2_LANE2_MASK (0x3 << 4)
+#define RG_DPHY_RX_BIST_LP_MODE_SEQ3_LANE2_SHIFT 6
+#define RG_DPHY_RX_BIST_LP_MODE_SEQ3_LANE2_MASK (0x3 << 6)
+#define RG_DPHY_RX_BIST_LP_MODE_SEQ4_LANE2_SHIFT 8
+#define RG_DPHY_RX_BIST_LP_MODE_SEQ4_LANE2_MASK (0x3 << 8)
+#define RG_DPHY_RX_BIST_LP_MODE_LENGTH_LANE2_SHIFT 16
+#define RG_DPHY_RX_BIST_LP_MODE_LENGTH_LANE2_MASK (0x7 << 16)
+
+#define DPHY_RX_BIST_STATUS_LANE2 0x0138
+#define RO_DPHY_RX_BIST_START_LANE2_SHIFT 0
+#define RO_DPHY_RX_BIST_START_LANE2_MASK (0x1 << 0)
+#define RO_DPHY_RX_BIST_HS_OK_LANE2_SHIFT 1
+#define RO_DPHY_RX_BIST_HS_OK_LANE2_MASK (0x1 << 1)
+#define RO_DPHY_RX_BIST_DATA_OK_LANE2_SHIFT 2
+#define RO_DPHY_RX_BIST_DATA_OK_LANE2_MASK (0x1 << 2)
+#define RO_DPHY_RX_BIST_FSM_OK_LANE2_SHIFT 3
+#define RO_DPHY_RX_BIST_FSM_OK_LANE2_MASK (0x1 << 3)
+#define RO_DPHY_RX_BIST_LP_FAIL_SEQ_NUMBER_LANE2_SHIFT 8
+#define RO_DPHY_RX_BIST_LP_FAIL_SEQ_NUMBER_LANE2_MASK (0x7 << 8)
+#define RO_DPHY_RX_BIST_LP_FAIL_SEQ_LANE2_SHIFT 12
+#define RO_DPHY_RX_BIST_LP_FAIL_SEQ_LANE2_MASK (0x3 << 12)
+
+#define DPHY_RX_BIST_CONFIG_0_LANE3 0x0140
+#define RG_DPHY_RX_BIST_MODE_LANE3_SHIFT 0
+#define RG_DPHY_RX_BIST_MODE_LANE3_MASK (0x3 << 0)
+#define RG_DPHY_RX_BIST_HS_FIX_PAT_LANE3_SHIFT 4
+#define RG_DPHY_RX_BIST_HS_FIX_PAT_LANE3_MASK (0x1 << 4)
+#define RG_DPHY_RX_BIST_HS_SYNC_DET_UNBLOCK_LANE3_SHIFT 5
+#define RG_DPHY_RX_BIST_HS_SYNC_DET_UNBLOCK_LANE3_MASK (0x1 << 5)
+#define RG_DPHY_RX_BIST_HS_RAN_PAT_MASK_N_LANE3_SHIFT 8
+#define RG_DPHY_RX_BIST_HS_RAN_PAT_MASK_N_LANE3_MASK (0xff << 8)
+#define RG_DPHY_RX_BIST_HS_LENGTH_LANE3_SHIFT 16
+#define RG_DPHY_RX_BIST_HS_LENGTH_LANE3_MASK (0x7fff << 16)
+
+#define DPHY_RX_BIST_CONFIG_1_LANE3 0x0144
+#define RG_DPHY_RX_BIST_LP_MODE_SEQ0_LANE3_SHIFT 0
+#define RG_DPHY_RX_BIST_LP_MODE_SEQ0_LANE3_MASK (0x3 << 0)
+#define RG_DPHY_RX_BIST_LP_MODE_SEQ1_LANE3_SHIFT 2
+#define RG_DPHY_RX_BIST_LP_MODE_SEQ1_LANE3_MASK (0x3 << 2)
+#define RG_DPHY_RX_BIST_LP_MODE_SEQ2_LANE3_SHIFT 4
+#define RG_DPHY_RX_BIST_LP_MODE_SEQ2_LANE3_MASK (0x3 << 4)
+#define RG_DPHY_RX_BIST_LP_MODE_SEQ3_LANE3_SHIFT 6
+#define RG_DPHY_RX_BIST_LP_MODE_SEQ3_LANE3_MASK (0x3 << 6)
+#define RG_DPHY_RX_BIST_LP_MODE_SEQ4_LANE3_SHIFT 8
+#define RG_DPHY_RX_BIST_LP_MODE_SEQ4_LANE3_MASK (0x3 << 8)
+#define RG_DPHY_RX_BIST_LP_MODE_LENGTH_LANE3_SHIFT 16
+#define RG_DPHY_RX_BIST_LP_MODE_LENGTH_LANE3_MASK (0x7 << 16)
+
+#define DPHY_RX_BIST_STATUS_LANE3 0x0148
+#define RO_DPHY_RX_BIST_START_LANE3_SHIFT 0
+#define RO_DPHY_RX_BIST_START_LANE3_MASK (0x1 << 0)
+#define RO_DPHY_RX_BIST_HS_OK_LANE3_SHIFT 1
+#define RO_DPHY_RX_BIST_HS_OK_LANE3_MASK (0x1 << 1)
+#define RO_DPHY_RX_BIST_DATA_OK_LANE3_SHIFT 2
+#define RO_DPHY_RX_BIST_DATA_OK_LANE3_MASK (0x1 << 2)
+#define RO_DPHY_RX_BIST_FSM_OK_LANE3_SHIFT 3
+#define RO_DPHY_RX_BIST_FSM_OK_LANE3_MASK (0x1 << 3)
+#define RO_DPHY_RX_BIST_LP_FAIL_SEQ_NUMBER_LANE3_SHIFT 8
+#define RO_DPHY_RX_BIST_LP_FAIL_SEQ_NUMBER_LANE3_MASK (0x7 << 8)
+#define RO_DPHY_RX_BIST_LP_FAIL_SEQ_LANE3_SHIFT 12
+#define RO_DPHY_RX_BIST_LP_FAIL_SEQ_LANE3_MASK (0x3 << 12)
+
+#define DPHY_RX_BIST_STATUS_WORD_CNT_LANE0 0x0150
+#define RO_DPHY_RX_BIST_WORD_CNT_LANE0_SHIFT 0
+#define RO_DPHY_RX_BIST_WORD_CNT_LANE0_MASK (0xffffffff << 0)
+
+#define DPHY_RX_BIST_STATUS_WORD_ERR_CNT_LANE0 0x0154
+#define RO_DPHY_RX_BIST_WORD_ERR_CNT_LANE0_SHIFT 0
+#define RO_DPHY_RX_BIST_WORD_ERR_CNT_LANE0_MASK (0xffff << 0)
+
+#define DPHY_RX_BIST_STATUS_WORD_CNT_LANE1 0x0158
+#define RO_DPHY_RX_BIST_WORD_CNT_LANE1_SHIFT 0
+#define RO_DPHY_RX_BIST_WORD_CNT_LANE1_MASK (0xffffffff << 0)
+
+#define DPHY_RX_BIST_STATUS_WORD_ERR_CNT_LANE1 0x015c
+#define RO_DPHY_RX_BIST_WORD_ERR_CNT_LANE1_SHIFT 0
+#define RO_DPHY_RX_BIST_WORD_ERR_CNT_LANE1_MASK (0xffff << 0)
+
+#define DPHY_RX_BIST_STATUS_WORD_CNT_LANE2 0x0160
+#define RO_DPHY_RX_BIST_WORD_CNT_LANE2_SHIFT 0
+#define RO_DPHY_RX_BIST_WORD_CNT_LANE2_MASK (0xffffffff << 0)
+
+#define DPHY_RX_BIST_STATUS_WORD_ERR_CNT_LANE2 0x0164
+#define RO_DPHY_RX_BIST_WORD_ERR_CNT_LANE2_SHIFT 0
+#define RO_DPHY_RX_BIST_WORD_ERR_CNT_LANE2_MASK (0xffff << 0)
+
+#define DPHY_RX_BIST_STATUS_WORD_CNT_LANE3 0x0168
+#define RO_DPHY_RX_BIST_WORD_CNT_LANE3_SHIFT 0
+#define RO_DPHY_RX_BIST_WORD_CNT_LANE3_MASK (0xffffffff << 0)
+
+#define DPHY_RX_BIST_STATUS_WORD_ERR_CNT_LANE3 0x016c
+#define RO_DPHY_RX_BIST_WORD_ERR_CNT_LANE3_SHIFT 0
+#define RO_DPHY_RX_BIST_WORD_ERR_CNT_LANE3_MASK (0xffff << 0)
+
+#define DPHY_DPHYV21_CTRL 0x0180
+#define RG_DPHY_CAL_EN_SHIFT 0
+#define RG_DPHY_CAL_EN_MASK (0x1 << 0)
+#define RG_DPHY_PREAMBLE_EN_SHIFT 1
+#define RG_DPHY_PREAMBLE_EN_MASK (0x1 << 1)
+#define RG_HSIDLE_EN_SHIFT 2
+#define RG_HSIDLE_EN_MASK (0x1 << 2)
+
+#define DPHY_PRBS_SEED 0x0184
+#define CSR_RLRN_PRBS_SEED_SHIFT 0
+#define CSR_RLRN_PRBS_SEED_MASK (0x3ffff << 0)
+
+#define DPHY_HS_IDLE_CNT 0x0188
+#define RG_CK_DET_BYTE_CK_DIV_SHIFT 0
+#define RG_CK_DET_BYTE_CK_DIV_MASK (0xff << 0)
+#define RG_CK_DET_CK_CNT_SHIFT 8
+#define RG_CK_DET_CK_CNT_MASK (0xff << 8)
+#define RG_HSRC_EN_MASK_CNT_SHIFT 16
+#define RG_HSRC_EN_MASK_CNT_MASK (0x3f << 16)
+#define RG_DIV_CK_DET_SEL_SHIFT 24
+#define RG_DIV_CK_DET_SEL_MASK (0x1 << 24)
+
+#define DPHY_DFT_CLR 0x018c
+#define RG_DPHY_LP00_2_SYNC_CODE_CLR_SHIFT 0
+#define RG_DPHY_LP00_2_SYNC_CODE_CLR_MASK (0x1 << 0)
+#define RG_DPHY_ERROR_CMP_CLR_LANE0_SHIFT 1
+#define RG_DPHY_ERROR_CMP_CLR_LANE0_MASK (0x1 << 1)
+#define RG_DPHY_ERROR_CMP_CLR_LANE1_SHIFT 2
+#define RG_DPHY_ERROR_CMP_CLR_LANE1_MASK (0x1 << 2)
+#define RG_DPHY_ERROR_CMP_CLR_LANE2_SHIFT 3
+#define RG_DPHY_ERROR_CMP_CLR_LANE2_MASK (0x1 << 3)
+#define RG_DPHY_ERROR_CMP_CLR_LANE3_SHIFT 4
+#define RG_DPHY_ERROR_CMP_CLR_LANE3_MASK (0x1 << 4)
+
+#define DPHY_ALT_CAL_CTRL_LANE0 0x0190
+#define RG_ALT_CAL_MODE_LANE0_SHIFT 0
+#define RG_ALT_CAL_MODE_LANE0_MASK (0x1f << 0)
+
+#define DPHY_ALT_CAL_WORD_CNT0_LANE0 0x0194
+#define RG_ALT_CAL_WORD_CNT0_LANE0_SHIFT 0
+#define RG_ALT_CAL_WORD_CNT0_LANE0_MASK (0xffff << 0)
+#define DPHY_ALT_CAL_WORD_CNT0_LANE0_RO_ALT_CAL_ERR_CNT_LANE0_SHIFT 16
+#define DPHY_ALT_CAL_WORD_CNT0_LANE0_RO_ALT_CAL_ERR_CNT_LANE0_MASK (0xffff << 16)
+
+#define DPHY_ALT_CAL_WORD_CNT1_LANE0 0x0198
+#define RG_ALT_CAL_WORD_CNT1_LANE0_SHIFT 0
+#define RG_ALT_CAL_WORD_CNT1_LANE0_MASK (0xffffffff << 0)
+
+#define DPHY_ALT_CAL_ERR_CNT_LANE0 0x019c
+#define RO_ALT_CAL_ERR_CNT1_LANE0_SHIFT 0
+#define RO_ALT_CAL_ERR_CNT1_LANE0_MASK (0xffffffff << 0)
+#define DPHY_ALT_CAL_ERR_CNT_LANE0_RO_ALT_CAL_ERR_CNT_LANE0_SHIFT 0
+#define DPHY_ALT_CAL_ERR_CNT_LANE0_RO_ALT_CAL_ERR_CNT_LANE0_MASK (0xffffffff << 0)
+
+#define DPHY_ALT_CAL_CTRL_LANE1 0x01a0
+#define RG_ALT_CAL_MODE_LANE1_SHIFT 0
+#define RG_ALT_CAL_MODE_LANE1_MASK (0x1f << 0)
+
+#define DPHY_ALT_CAL_WORD_CNT0_LANE1 0x01a4
+#define RG_ALT_CAL_WORD_CNT0_LANE1_SHIFT 0
+#define RG_ALT_CAL_WORD_CNT0_LANE1_MASK (0xffff << 0)
+#define DPHY_ALT_CAL_WORD_CNT0_LANE1_RO_ALT_CAL_ERR_CNT_LANE1_SHIFT 16
+#define DPHY_ALT_CAL_WORD_CNT0_LANE1_RO_ALT_CAL_ERR_CNT_LANE1_MASK (0xffff << 16)
+
+#define DPHY_ALT_CAL_WORD_CNT1_LANE1 0x01a8
+#define RG_ALT_CAL_WORD_CNT1_LANE1_SHIFT 0
+#define RG_ALT_CAL_WORD_CNT1_LANE1_MASK (0xffffffff << 0)
+
+#define DPHY_ALT_CAL_ERR_CNT_LANE1 0x01ac
+#define DPHY_ALT_CAL_ERR_CNT_LANE1_RO_ALT_CAL_ERR_CNT_LANE1_SHIFT 0
+#define DPHY_ALT_CAL_ERR_CNT_LANE1_RO_ALT_CAL_ERR_CNT_LANE1_MASK (0xffffffff << 0)
+
+#define DPHY_ALT_CAL_CTRL_LANE2 0x01b0
+#define RG_ALT_CAL_MODE_LANE2_SHIFT 0
+#define RG_ALT_CAL_MODE_LANE2_MASK (0x1f << 0)
+
+#define DPHY_ALT_CAL_WORD_CNT0_LANE2 0x01b4
+#define RG_ALT_CAL_WORD_CNT0_LANE2_SHIFT 0
+#define RG_ALT_CAL_WORD_CNT0_LANE2_MASK (0xffff << 0)
+#define DPHY_ALT_CAL_WORD_CNT0_LANE2_RO_ALT_CAL_ERR_CNT_LANE2_SHIFT 16
+#define DPHY_ALT_CAL_WORD_CNT0_LANE2_RO_ALT_CAL_ERR_CNT_LANE2_MASK (0xffff << 16)
+
+#define DPHY_ALT_CAL_WORD_CNT1_LANE2 0x01b8
+#define RG_ALT_CAL_WORD_CNT1_LANE2_SHIFT 0
+#define RG_ALT_CAL_WORD_CNT1_LANE2_MASK (0xffffffff << 0)
+
+#define DPHY_ALT_CAL_ERR_CNT_LANE2 0x01bc
+#define DPHY_ALT_CAL_ERR_CNT_LANE2_RO_ALT_CAL_ERR_CNT_LANE2_SHIFT 0
+#define DPHY_ALT_CAL_ERR_CNT_LANE2_RO_ALT_CAL_ERR_CNT_LANE2_MASK (0xffffffff << 0)
+
+#define DPHY_ALT_CAL_CTRL_LANE3 0x01c0
+#define RG_ALT_CAL_MODE_LANE3_SHIFT 0
+#define RG_ALT_CAL_MODE_LANE3_MASK (0x1f << 0)
+
+#define DPHY_ALT_CAL_WORD_CNT0_LANE3 0x01c4
+#define RG_ALT_CAL_WORD_CNT0_LANE3_SHIFT 0
+#define RG_ALT_CAL_WORD_CNT0_LANE3_MASK (0xffff << 0)
+#define DPHY_ALT_CAL_WORD_CNT0_LANE3_RO_ALT_CAL_ERR_CNT_LANE3_SHIFT 16
+#define DPHY_ALT_CAL_WORD_CNT0_LANE3_RO_ALT_CAL_ERR_CNT_LANE3_MASK (0xffff << 16)
+
+#define DPHY_ALT_CAL_WORD_CNT1_LANE3 0x01c8
+#define RG_ALT_CAL_WORD_CNT1_LANE3_SHIFT 0
+#define RG_ALT_CAL_WORD_CNT1_LANE3_MASK (0xffffffff << 0)
+
+#define DPHY_ALT_CAL_ERR_CNT_LANE3 0x01cc
+#define DPHY_ALT_CAL_ERR_CNT_LANE3_RO_ALT_CAL_ERR_CNT_LANE3_SHIFT 0
+#define DPHY_ALT_CAL_ERR_CNT_LANE3_RO_ALT_CAL_ERR_CNT_LANE3_MASK (0xffffffff << 0)
+
+#define DPHY_ALT_CAL_BURST_CNT_LANE0 0x01d0
+#define RG_DPHY_PRBS_BURST_CNT_LANE0_SHIFT 0
+#define RG_DPHY_PRBS_BURST_CNT_LANE0_MASK (0xffffffff << 0)
+
+#define DPHY_ALT_CAL_BURST_ERRCNT_LANE0 0x01d4
+#define RO_DPHY_PRBS_BURST_ERR_CNT_LANE0_SHIFT 0
+#define RO_DPHY_PRBS_BURST_ERR_CNT_LANE0_MASK (0xffffffff << 0)
+
+#define DPHY_ALT_CAL_BURST_CNT_LANE1 0x01d8
+#define RG_DPHY_PRBS_BURST_CNT_LANE1_SHIFT 0
+#define RG_DPHY_PRBS_BURST_CNT_LANE1_MASK (0xffffffff << 0)
+
+#define DPHY_ALT_CAL_BURST_ERRCNT_LANE1 0x01dc
+#define RO_DPHY_PRBS_BURST_ERR_CNT_LANE1_SHIFT 0
+#define RO_DPHY_PRBS_BURST_ERR_CNT_LANE1_MASK (0xffffffff << 0)
+
+#define DPHY_ALT_CAL_BURST_CNT_LANE2 0x01e0
+#define RG_DPHY_PRBS_BURST_CNT_LANE2_SHIFT 0
+#define RG_DPHY_PRBS_BURST_CNT_LANE2_MASK (0xffffffff << 0)
+
+#define DPHY_ALT_CAL_BURST_ERRCNT_LANE2 0x01e4
+#define RO_DPHY_PRBS_BURST_ERR_CNT_LANE2_SHIFT 0
+#define RO_DPHY_PRBS_BURST_ERR_CNT_LANE2_MASK (0xffffffff << 0)
+
+#define DPHY_ALT_CAL_BURST_CNT_LANE3 0x01e8
+#define RG_DPHY_PRBS_BURST_CNT_LANE3_SHIFT 0
+#define RG_DPHY_PRBS_BURST_CNT_LANE3_MASK (0xffffffff << 0)
+
+#define DPHY_ALT_CAL_BURST_ERRCNT_LANE3 0x01ec
+#define RO_DPHY_PRBS_BURST_ERR_CNT_LANE3_SHIFT 0
+#define RO_DPHY_PRBS_BURST_ERR_CNT_LANE3_MASK (0xffffffff << 0)
+
+#define DPHY_ALT_CAL_PKT_CNT0 0x01f0
+#define RG_ALT_CAL_PKT_CNT0_SHIFT 0
+#define RG_ALT_CAL_PKT_CNT0_MASK (0xffffffff << 0)
+
+#define DPHY_ALT_CAL_PKT_CNT1 0x01f4
+#define RG_ALT_CAL_PKT_CNT1_SHIFT 0
+#define RG_ALT_CAL_PKT_CNT1_MASK (0xffff << 0)
+#ifdef ISP7_1
+#define DPHY_RX_STATE_CHK_EN 0x0260
+#else
+#define DPHY_RX_STATE_CHK_EN 0x0200
+#endif
+#define DPHY_RX_STATE_CHK_EN_LANE0_SHIFT 0
+#define DPHY_RX_STATE_CHK_EN_LANE0_MASK (0x1 << 0)
+#define DPHY_RX_STATE_CHK_EN_LANE1_SHIFT 1
+#define DPHY_RX_STATE_CHK_EN_LANE1_MASK (0x1 << 1)
+#define DPHY_RX_STATE_CHK_EN_LANE2_SHIFT 2
+#define DPHY_RX_STATE_CHK_EN_LANE2_MASK (0x1 << 2)
+#define DPHY_RX_STATE_CHK_EN_LANE3_SHIFT 3
+#define DPHY_RX_STATE_CHK_EN_LANE3_MASK (0x1 << 3)
+
+#define DPHY_RX_STATE_CHK_TIMER 0x0264
+#define RG_DPHY_RX_STATE_CHK_RX_TIMER_CNT_SHIFT 0
+#define RG_DPHY_RX_STATE_CHK_RX_TIMER_CNT_MASK (0xffffffff << 0)
+
+#define DPHY_RX_STATE_CHK_STATUS_LANE0 0x0270
+#define RO_DPHY_RX_STATE_CHK_ERR_LANE0_SHIFT 0
+#define RO_DPHY_RX_STATE_CHK_ERR_LANE0_MASK (0x1 << 0)
+#define RO_DPHY_RX_STATE_CHK_ERR_CNT_LANE0_SHIFT 4
+#define RO_DPHY_RX_STATE_CHK_ERR_CNT_LANE0_MASK (0x7 << 4)
+#define DPHY_RX_STATE_CHK_FAIL_SEQ0_LANE0_SHIFT 16
+#define DPHY_RX_STATE_CHK_FAIL_SEQ0_LANE0_MASK (0x7 << 16)
+#define DPHY_RX_STATE_CHK_FAIL_SEQ1_LANE0_SHIFT 20
+#define DPHY_RX_STATE_CHK_FAIL_SEQ1_LANE0_MASK (0x7 << 20)
+#define DPHY_RX_STATE_CHK_FAIL_SEQ2_LANE0_SHIFT 24
+#define DPHY_RX_STATE_CHK_FAIL_SEQ2_LANE0_MASK (0x7 << 24)
+#define DPHY_RX_STATE_CHK_FAIL_SEQ3_LANE0_SHIFT 28
+#define DPHY_RX_STATE_CHK_FAIL_SEQ3_LANE0_MASK (0x7 << 28)
+
+#define DPHY_RX_STATE_CHK_STATUS_LANE1 0x0274
+#define RO_DPHY_RX_STATE_CHK_ERR_LANE1_SHIFT 0
+#define RO_DPHY_RX_STATE_CHK_ERR_LANE1_MASK (0x1 << 0)
+#define RO_DPHY_RX_STATE_CHK_ERR_CNT_LANE1_SHIFT 4
+#define RO_DPHY_RX_STATE_CHK_ERR_CNT_LANE1_MASK (0x7 << 4)
+#define DPHY_RX_STATE_CHK_FAIL_SEQ0_LANE1_SHIFT 16
+#define DPHY_RX_STATE_CHK_FAIL_SEQ0_LANE1_MASK (0x7 << 16)
+#define DPHY_RX_STATE_CHK_FAIL_SEQ1_LANE1_SHIFT 20
+#define DPHY_RX_STATE_CHK_FAIL_SEQ1_LANE1_MASK (0x7 << 20)
+#define DPHY_RX_STATE_CHK_FAIL_SEQ2_LANE1_SHIFT 24
+#define DPHY_RX_STATE_CHK_FAIL_SEQ2_LANE1_MASK (0x7 << 24)
+#define DPHY_RX_STATE_CHK_FAIL_SEQ3_LANE1_SHIFT 28
+#define DPHY_RX_STATE_CHK_FAIL_SEQ3_LANE1_MASK (0x7 << 28)
+
+#define DPHY_RX_STATE_CHK_STATUS_LANE2 0x0278
+#define RO_DPHY_RX_STATE_CHK_ERR_LANE2_SHIFT 0
+#define RO_DPHY_RX_STATE_CHK_ERR_LANE2_MASK (0x1 << 0)
+#define RO_DPHY_RX_STATE_CHK_ERR_CNT_LANE2_SHIFT 4
+#define RO_DPHY_RX_STATE_CHK_ERR_CNT_LANE2_MASK (0x7 << 4)
+#define DPHY_RX_STATE_CHK_FAIL_SEQ0_LANE2_SHIFT 16
+#define DPHY_RX_STATE_CHK_FAIL_SEQ0_LANE2_MASK (0x7 << 16)
+#define DPHY_RX_STATE_CHK_FAIL_SEQ1_LANE2_SHIFT 20
+#define DPHY_RX_STATE_CHK_FAIL_SEQ1_LANE2_MASK (0x7 << 20)
+#define DPHY_RX_STATE_CHK_FAIL_SEQ2_LANE2_SHIFT 24
+#define DPHY_RX_STATE_CHK_FAIL_SEQ2_LANE2_MASK (0x7 << 24)
+#define DPHY_RX_STATE_CHK_FAIL_SEQ3_LANE2_SHIFT 28
+#define DPHY_RX_STATE_CHK_FAIL_SEQ3_LANE2_MASK (0x7 << 28)
+
+#define DPHY_RX_STATE_CHK_STATUS_LANE3 0x027c
+#define RO_DPHY_RX_STATE_CHK_ERR_LANE3_SHIFT 0
+#define RO_DPHY_RX_STATE_CHK_ERR_LANE3_MASK (0x1 << 0)
+#define RO_DPHY_RX_STATE_CHK_ERR_CNT_LANE3_SHIFT 4
+#define RO_DPHY_RX_STATE_CHK_ERR_CNT_LANE3_MASK (0x7 << 4)
+#define DPHY_RX_STATE_CHK_FAIL_SEQ0_LANE3_SHIFT 16
+#define DPHY_RX_STATE_CHK_FAIL_SEQ0_LANE3_MASK (0x7 << 16)
+#define DPHY_RX_STATE_CHK_FAIL_SEQ1_LANE3_SHIFT 20
+#define DPHY_RX_STATE_CHK_FAIL_SEQ1_LANE3_MASK (0x7 << 20)
+#define DPHY_RX_STATE_CHK_FAIL_SEQ2_LANE3_SHIFT 24
+#define DPHY_RX_STATE_CHK_FAIL_SEQ2_LANE3_MASK (0x7 << 24)
+#define DPHY_RX_STATE_CHK_FAIL_SEQ3_LANE3_SHIFT 28
+#define DPHY_RX_STATE_CHK_FAIL_SEQ3_LANE3_MASK (0x7 << 28)
+
+#define CDPHY_DEBUG_PORT_SELECT 0x0280
+#define RG_CSI_CDPHY_DBG_PORT_SEL_SHIFT 0
+#define RG_CSI_CDPHY_DBG_PORT_SEL_MASK (0xffffffff << 0)
+
+#define CDPHY_DEBUG_MODE_SELECT 0x0284
+#define RG_CSI_CDPHY_DBG_MOD_SEL_SHIFT 0
+#define RG_CSI_CDPHY_DBG_MOD_SEL_MASK (0xffff << 0)
+
+#define CDPHY_DEBUG_OUT_READ 0x0288
+#define RO_CSI_CDPHY_DBG_OUT_READ_SHIFT 0
+#define RO_CSI_CDPHY_DBG_OUT_READ_MASK (0xffffffff << 0)
+
+#define DPHY_RX_INIT 0x028c
+#define RG_CSI2_TINIT_CNT_SHIFT 0
+#define RG_CSI2_TINIT_CNT_MASK (0xfffff << 0)
+#define RG_CSI2_TINIT_CNT_EN_SHIFT 31
+#define RG_CSI2_TINIT_CNT_EN_MASK (0x1 << 31)
+
+#endif
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_csi_phy_2_0/mtk_cam-seninf-hw_phy_2_0.c b/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_csi_phy_2_0/mtk_cam-seninf-hw_phy_2_0.c
new file mode 100644
index 0000000000000000000000000000000000000000..0e0364b2a9bb60183a7625b2a542dbe75cee13eb
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_csi_phy_2_0/mtk_cam-seninf-hw_phy_2_0.c
@@ -0,0 +1,3106 @@
+// SPDX-License-Identifier: GPL-2.0
+// Copyright (c) 2022 MediaTek Inc.
+
+#include <linux/module.h>
+#include <linux/delay.h>
+
+#include "../mtk_cam-seninf.h"
+#include "../mtk_cam-seninf-hw.h"
+#include "../mtk_cam-seninf-regs.h"
+#include "mtk_cam-seninf-top-ctrl.h"
+#include "mtk_cam-seninf-seninf1-mux.h"
+#include "mtk_cam-seninf-seninf1.h"
+#include "mtk_cam-seninf-seninf1-csi2.h"
+#include "mtk_cam-seninf-tg1.h"
+#include "mtk_cam-seninf-cammux.h"
+#include "mtk_cam-seninf-mipi-rx-ana-cdphy-csi0a.h"
+#include "mtk_cam-seninf-csi0-cphy.h"
+#include "mtk_cam-seninf-csi0-dphy.h"
+#include "imgsensor-user.h"
+
+#define DEBUG_CAM_MUX_SWITCH 0
+#define LOG_MORE 0
+
+static struct mtk_cam_seninf_ops *_seninf_ops = &mtk_csi_phy_2_0;
+
+
+#define SET_DI_CTRL(ptr, s, vc) do { \
+	SENINF_BITS(ptr, SENINF_CSI2_S##s##_DI_CTRL, \
+			RG_CSI2_S##s##_DT_SEL, vc->dt); \
+	SENINF_BITS(ptr, SENINF_CSI2_S##s##_DI_CTRL, \
+			RG_CSI2_S##s##_VC_SEL, vc->vc); \
+	SENINF_BITS(ptr, SENINF_CSI2_S##s##_DI_CTRL, \
+			RG_CSI2_S##s##_DT_INTERLEAVE_MODE, 1); \
+	SENINF_BITS(ptr, SENINF_CSI2_S##s##_DI_CTRL, \
+			RG_CSI2_S##s##_VC_INTERLEAVE_EN, 1); \
+} while (0)
+
+#define SET_CH_CTRL(ptr, ch, s) \
+	SENINF_BITS(ptr, SENINF_CSI2_CH##ch##_CTRL, \
+		RG_CSI2_CH##ch##_S##s##_GRP_EN, 1)
+
+#define SET_DI_CH_CTRL(ptr, s, vc) do { \
+	SET_DI_CTRL(ptr, s, vc); \
+	if (vc->group == 0) \
+		SET_CH_CTRL(ptr, 0, s); \
+	else if (vc->group == 1) \
+		SET_CH_CTRL(ptr, 1, s); \
+	else if (vc->group == 2) \
+		SET_CH_CTRL(ptr, 2, s); \
+	else if (vc->group == 3) \
+		SET_CH_CTRL(ptr, 3, s); \
+} while (0)
+
+#define SHOW(buf, len, fmt, ...) { \
+	len += snprintf(buf + len, PAGE_SIZE - len, fmt, ##__VA_ARGS__); \
+}
+
+static int mtk_cam_seninf_init_iomem(struct seninf_ctx *ctx,
+			      void __iomem *if_base, void __iomem *ana_base)
+{
+	int i;
+
+	ctx->reg_ana_csi_rx[CSI_PORT_0] =
+	ctx->reg_ana_csi_rx[CSI_PORT_0A] = ana_base + 0;
+	ctx->reg_ana_csi_rx[CSI_PORT_0B] = ana_base + 0x1000;
+
+	ctx->reg_ana_csi_rx[CSI_PORT_1] =
+	ctx->reg_ana_csi_rx[CSI_PORT_1A] = ana_base + 0x4000;
+	ctx->reg_ana_csi_rx[CSI_PORT_1B] = ana_base + 0x5000;
+
+	ctx->reg_ana_csi_rx[CSI_PORT_2] =
+	ctx->reg_ana_csi_rx[CSI_PORT_2A] = ana_base + 0x8000;
+	ctx->reg_ana_csi_rx[CSI_PORT_2B] = ana_base + 0x9000;
+
+	ctx->reg_ana_csi_rx[CSI_PORT_3] =
+	ctx->reg_ana_csi_rx[CSI_PORT_3A] = ana_base + 0xc000;
+	ctx->reg_ana_csi_rx[CSI_PORT_3B] = ana_base + 0xd000;
+
+	ctx->reg_ana_dphy_top[CSI_PORT_0A] =
+	ctx->reg_ana_dphy_top[CSI_PORT_0B] =
+	ctx->reg_ana_dphy_top[CSI_PORT_0] = ana_base + 0x2000;
+
+	ctx->reg_ana_dphy_top[CSI_PORT_1A] =
+	ctx->reg_ana_dphy_top[CSI_PORT_1B] =
+	ctx->reg_ana_dphy_top[CSI_PORT_1] = ana_base + 0x6000;
+
+	ctx->reg_ana_dphy_top[CSI_PORT_2A] =
+	ctx->reg_ana_dphy_top[CSI_PORT_2B] =
+	ctx->reg_ana_dphy_top[CSI_PORT_2] = ana_base + 0xa000;
+
+	ctx->reg_ana_dphy_top[CSI_PORT_3A] =
+	ctx->reg_ana_dphy_top[CSI_PORT_3B] =
+	ctx->reg_ana_dphy_top[CSI_PORT_3] = ana_base + 0xe000;
+
+	ctx->reg_ana_cphy_top[CSI_PORT_0A] =
+	ctx->reg_ana_cphy_top[CSI_PORT_0B] =
+	ctx->reg_ana_cphy_top[CSI_PORT_0] = ana_base + 0x3000;
+
+	ctx->reg_ana_cphy_top[CSI_PORT_1A] =
+	ctx->reg_ana_cphy_top[CSI_PORT_1B] =
+	ctx->reg_ana_cphy_top[CSI_PORT_1] = ana_base + 0x7000;
+
+	ctx->reg_ana_cphy_top[CSI_PORT_2A] =
+	ctx->reg_ana_cphy_top[CSI_PORT_2B] =
+	ctx->reg_ana_cphy_top[CSI_PORT_2] = ana_base + 0xb000;
+
+	ctx->reg_ana_cphy_top[CSI_PORT_3A] =
+	ctx->reg_ana_cphy_top[CSI_PORT_3B] =
+	ctx->reg_ana_cphy_top[CSI_PORT_3] = ana_base + 0xf000;
+
+	ctx->reg_if_top = if_base;
+
+	for (i = SENINF_1; i < _seninf_ops->seninf_num; i++) {
+		ctx->reg_if_ctrl[i] = if_base + 0x0200 + (0x1000 * i);
+		ctx->reg_if_tg[i] = if_base + 0x0F00 + (0x1000 * i);
+		ctx->reg_if_csi2[i] = if_base + 0x0a00 + (0x1000 * i);
+	}
+
+	for (i = SENINF_MUX1; i < _seninf_ops->mux_num; i++)
+		ctx->reg_if_mux[i] = if_base + 0x0d00 + (0x1000 * i);
+
+	ctx->reg_if_cam_mux = if_base + 0x0400;
+
+	return 0;
+}
+
+static int mtk_cam_seninf_init_port(struct seninf_ctx *ctx, int port)
+{
+	int portNum;
+
+	if (port >= CSI_PORT_0A)
+		portNum = (port - CSI_PORT_0) >> 1;
+	else
+		portNum = port;
+
+	ctx->port = port;
+	ctx->portNum = portNum;
+	ctx->portA = CSI_PORT_0A + (portNum << 1);
+	ctx->portB = ctx->portA + 1;
+	ctx->is_4d1c = (port == portNum);
+
+	switch (port) {
+	case CSI_PORT_0:
+		ctx->seninfIdx = SENINF_1;
+		break;
+	case CSI_PORT_0A:
+		ctx->seninfIdx = SENINF_1;
+		break;
+	case CSI_PORT_0B:
+		ctx->seninfIdx = SENINF_2;
+		break;
+	case CSI_PORT_1:
+		ctx->seninfIdx = SENINF_3;
+		break;
+	case CSI_PORT_1A:
+		ctx->seninfIdx = SENINF_3;
+		break;
+	case CSI_PORT_1B:
+		ctx->seninfIdx = SENINF_4;
+		break;
+	case CSI_PORT_2:
+		ctx->seninfIdx = SENINF_5;
+		break;
+	case CSI_PORT_2A:
+		ctx->seninfIdx = SENINF_5;
+		break;
+	case CSI_PORT_2B:
+		ctx->seninfIdx = SENINF_6;
+		break;
+	case CSI_PORT_3:
+		ctx->seninfIdx = SENINF_7;
+		break;
+	case CSI_PORT_3A:
+		ctx->seninfIdx = SENINF_7;
+		break;
+	case CSI_PORT_3B:
+		ctx->seninfIdx = SENINF_8;
+		break;
+	default:
+		dev_dbg(ctx->dev, "invalid port %d\n", port);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int mtk_cam_seninf_is_cammux_used(struct seninf_ctx *ctx, int cam_mux)
+{
+	void *pSeninf_cam_mux = ctx->reg_if_cam_mux;
+	unsigned int temp = SENINF_READ_REG(pSeninf_cam_mux,
+			SENINF_CAM_MUX_EN);
+
+	if (cam_mux >= _seninf_ops->cam_mux_num) {
+		dev_dbg(ctx->dev, "%s err cam_mux %d >= SENINF_CAM_MUX_NUM %d\n",
+			__func__,
+			cam_mux,
+			_seninf_ops->cam_mux_num);
+		return 0;
+	}
+
+	return !!(temp & (1 << cam_mux));
+}
+
+static int mtk_cam_seninf_cammux(struct seninf_ctx *ctx, int cam_mux)
+{
+	void *pSeninf_cam_mux = ctx->reg_if_cam_mux;
+	u32 temp;
+
+	if (cam_mux >= _seninf_ops->cam_mux_num) {
+		dev_dbg(ctx->dev, "%s err cam_mux %d >= SENINF_CAM_MUX_NUM %d\n",
+			__func__,
+			cam_mux,
+			_seninf_ops->cam_mux_num);
+		return 0;
+	}
+
+	temp = SENINF_READ_REG(pSeninf_cam_mux, SENINF_CAM_MUX_EN);
+	SENINF_WRITE_REG(pSeninf_cam_mux, SENINF_CAM_MUX_EN, temp |
+			 (1 << cam_mux));
+
+	SENINF_WRITE_REG(pSeninf_cam_mux, SENINF_CAM_MUX_IRQ_STATUS,
+			 3 << (cam_mux * 2));//clr irq
+
+	dev_dbg(ctx->dev, "cam_mux %d EN 0x%x IRQ_EN 0x%x IRQ_STATUS 0x%x\n",
+		 cam_mux,
+		SENINF_READ_REG(pSeninf_cam_mux, SENINF_CAM_MUX_EN),
+		SENINF_READ_REG(pSeninf_cam_mux, SENINF_CAM_MUX_IRQ_EN),
+		SENINF_READ_REG(pSeninf_cam_mux, SENINF_CAM_MUX_IRQ_STATUS));
+
+	return 0;
+}
+
+static int mtk_cam_seninf_disable_cammux(struct seninf_ctx *ctx, int cam_mux)
+{
+	void *base = ctx->reg_if_cam_mux;
+	u32 temp;
+
+	if (cam_mux >= _seninf_ops->cam_mux_num) {
+		dev_dbg(ctx->dev, "%s err cam_mux %d >= SENINF_CAM_MUX_NUM %d\n",
+			__func__,
+			cam_mux,
+			_seninf_ops->cam_mux_num);
+		return 0;
+	}
+
+	temp = SENINF_READ_REG(base, SENINF_CAM_MUX_EN);
+
+	if ((1 << cam_mux) & temp) {
+		SENINF_WRITE_REG(base, SENINF_CAM_MUX_EN,
+			temp & (~(1 << cam_mux)));
+		dev_dbg(ctx->dev, "cammux %d EN %x IRQ_EN %x IRQ_STATUS %x",
+			 cam_mux,
+			SENINF_READ_REG(base, SENINF_CAM_MUX_EN),
+			SENINF_READ_REG(base, SENINF_CAM_MUX_IRQ_EN),
+			SENINF_READ_REG(base, SENINF_CAM_MUX_IRQ_STATUS));
+	}
+
+	return 0;
+}
+
+static int mtk_cam_seninf_disable_all_cammux(struct seninf_ctx *ctx)
+{
+	void *pSeninf_cam_mux = ctx->reg_if_cam_mux;
+
+	SENINF_WRITE_REG(pSeninf_cam_mux, SENINF_CAM_MUX_EN, 0);
+	dev_dbg(ctx->dev, "%s all cam_mux EN 0x%x\n",
+		__func__,
+		SENINF_READ_REG(pSeninf_cam_mux, SENINF_CAM_MUX_EN));
+
+	return 0;
+}
+
+static int mtk_cam_seninf_set_top_mux_ctrl(struct seninf_ctx *ctx,
+				    int mux_idx, int seninf_src)
+{
+	void *pSeninf = ctx->reg_if_top;
+
+	switch (mux_idx) {
+	case SENINF_MUX1:
+		SENINF_BITS(pSeninf, SENINF_TOP_MUX_CTRL_0,
+			    RG_SENINF_MUX1_SRC_SEL, seninf_src);
+		break;
+	case SENINF_MUX2:
+		SENINF_BITS(pSeninf, SENINF_TOP_MUX_CTRL_0,
+			    RG_SENINF_MUX2_SRC_SEL, seninf_src);
+		break;
+	case SENINF_MUX3:
+		SENINF_BITS(pSeninf, SENINF_TOP_MUX_CTRL_0,
+			    RG_SENINF_MUX3_SRC_SEL, seninf_src);
+		break;
+	case SENINF_MUX4:
+		SENINF_BITS(pSeninf, SENINF_TOP_MUX_CTRL_0,
+			    RG_SENINF_MUX4_SRC_SEL, seninf_src);
+		break;
+	case SENINF_MUX5:
+		SENINF_BITS(pSeninf, SENINF_TOP_MUX_CTRL_1,
+			    RG_SENINF_MUX5_SRC_SEL, seninf_src);
+		break;
+	case SENINF_MUX6:
+		SENINF_BITS(pSeninf, SENINF_TOP_MUX_CTRL_1,
+			    RG_SENINF_MUX6_SRC_SEL, seninf_src);
+		break;
+	case SENINF_MUX7:
+		SENINF_BITS(pSeninf, SENINF_TOP_MUX_CTRL_1,
+			    RG_SENINF_MUX7_SRC_SEL, seninf_src);
+		break;
+	case SENINF_MUX8:
+		SENINF_BITS(pSeninf, SENINF_TOP_MUX_CTRL_1,
+			    RG_SENINF_MUX8_SRC_SEL, seninf_src);
+		break;
+#ifdef ISP7_1
+	case SENINF_MUX9:
+		SENINF_BITS(pSeninf, SENINF_TOP_MUX_CTRL_2,
+			    RG_SENINF_MUX9_SRC_SEL, seninf_src);
+		break;
+	case SENINF_MUX10:
+		SENINF_BITS(pSeninf, SENINF_TOP_MUX_CTRL_2,
+			    RG_SENINF_MUX10_SRC_SEL, seninf_src);
+		break;
+	case SENINF_MUX11:
+		SENINF_BITS(pSeninf, SENINF_TOP_MUX_CTRL_2,
+			    RG_SENINF_MUX11_SRC_SEL, seninf_src);
+		break;
+	case SENINF_MUX12:
+		SENINF_BITS(pSeninf, SENINF_TOP_MUX_CTRL_2,
+			    RG_SENINF_MUX12_SRC_SEL, seninf_src);
+		break;
+	case SENINF_MUX13:
+		SENINF_BITS(pSeninf, SENINF_TOP_MUX_CTRL_3,
+				RG_SENINF_MUX13_SRC_SEL, seninf_src);
+		break;
+#endif
+	default:
+		dev_dbg(ctx->dev, "invalid mux_idx %d\n", mux_idx);
+		return -EINVAL;
+	}
+#if LOG_MORE
+#ifdef ISP7_1
+	dev_dbg(ctx->dev,
+		 "TOP_MUX_CTRL_0(0x%lx) TOP_MUX_CTRL_1(0x%lx) TOP_MUX_CTRL_2(0x%lx) TOP_MUX_CTRL_3(0x%x)\n",
+		 SENINF_READ_REG(pSeninf, SENINF_TOP_MUX_CTRL_0),
+		 SENINF_READ_REG(pSeninf, SENINF_TOP_MUX_CTRL_1),
+		 SENINF_READ_REG(pSeninf, SENINF_TOP_MUX_CTRL_2),
+		 SENINF_READ_REG(pSeninf, SENINF_TOP_MUX_CTRL_3));
+#else
+	dev_dbg(ctx->dev, "TOP_MUX_CTRL_0(0x%lx) TOP_MUX_CTRL_1(0x%lx)\n",
+		 SENINF_READ_REG(pSeninf, SENINF_TOP_MUX_CTRL_0),
+		 SENINF_READ_REG(pSeninf, SENINF_TOP_MUX_CTRL_1));
+#endif
+#endif
+	return 0;
+}
+
+static int mtk_cam_seninf_get_top_mux_ctrl(struct seninf_ctx *ctx, int mux_idx)
+{
+	void *pSeninf = ctx->reg_if_top;
+	unsigned int seninf_src = 0;
+
+
+	switch (mux_idx) {
+	case SENINF_MUX1:
+		seninf_src = SENINF_READ_BITS(pSeninf, SENINF_TOP_MUX_CTRL_0,
+				RG_SENINF_MUX1_SRC_SEL);
+		break;
+	case SENINF_MUX2:
+		seninf_src = SENINF_READ_BITS(pSeninf, SENINF_TOP_MUX_CTRL_0,
+				RG_SENINF_MUX2_SRC_SEL);
+		break;
+	case SENINF_MUX3:
+		seninf_src = SENINF_READ_BITS(pSeninf, SENINF_TOP_MUX_CTRL_0,
+			RG_SENINF_MUX3_SRC_SEL);
+			break;
+	case SENINF_MUX4:
+		seninf_src = SENINF_READ_BITS(pSeninf, SENINF_TOP_MUX_CTRL_0,
+			RG_SENINF_MUX4_SRC_SEL);
+		break;
+	case SENINF_MUX5:
+		seninf_src = SENINF_READ_BITS(pSeninf, SENINF_TOP_MUX_CTRL_1,
+			RG_SENINF_MUX5_SRC_SEL);
+		break;
+	case SENINF_MUX6:
+		seninf_src = SENINF_READ_BITS(pSeninf, SENINF_TOP_MUX_CTRL_1,
+			RG_SENINF_MUX6_SRC_SEL);
+		break;
+	case SENINF_MUX7:
+		seninf_src = SENINF_READ_BITS(pSeninf, SENINF_TOP_MUX_CTRL_1,
+			RG_SENINF_MUX7_SRC_SEL);
+		break;
+	case SENINF_MUX8:
+		seninf_src = SENINF_READ_BITS(pSeninf, SENINF_TOP_MUX_CTRL_1,
+			RG_SENINF_MUX8_SRC_SEL);
+		break;
+#ifdef ISP7_1
+	case SENINF_MUX9:
+		seninf_src = SENINF_READ_BITS(pSeninf, SENINF_TOP_MUX_CTRL_2,
+			RG_SENINF_MUX9_SRC_SEL);
+		break;
+	case SENINF_MUX10:
+		seninf_src = SENINF_READ_BITS(pSeninf, SENINF_TOP_MUX_CTRL_2,
+			RG_SENINF_MUX10_SRC_SEL);
+		break;
+	case SENINF_MUX11:
+		seninf_src = SENINF_READ_BITS(pSeninf, SENINF_TOP_MUX_CTRL_2,
+			RG_SENINF_MUX11_SRC_SEL);
+		break;
+	case SENINF_MUX12:
+		seninf_src = SENINF_READ_BITS(pSeninf, SENINF_TOP_MUX_CTRL_2,
+			RG_SENINF_MUX12_SRC_SEL);
+		break;
+	case SENINF_MUX13:
+		seninf_src = SENINF_READ_BITS(pSeninf, SENINF_TOP_MUX_CTRL_3,
+			RG_SENINF_MUX13_SRC_SEL);
+		break;
+#endif
+	default:
+		dev_dbg(ctx->dev, "invalid mux_idx %d", mux_idx);
+		return -EINVAL;
+	}
+
+	return seninf_src;
+}
+
+static int mtk_cam_seninf_get_cammux_ctrl(struct seninf_ctx *ctx, int cam_mux)
+{
+	void *pSeninf_cam_mux = ctx->reg_if_cam_mux;
+	unsigned int seninfMuxSrc = 0;
+
+	if (cam_mux >= _seninf_ops->cam_mux_num) {
+		dev_dbg(ctx->dev, "%s err cam_mux %d >= SENINF_CAM_MUX_NUM %d\n",
+			__func__,
+			cam_mux,
+			_seninf_ops->cam_mux_num);
+		return 0;
+	}
+
+	switch (cam_mux) {
+	case SENINF_CAM_MUX0:
+		seninfMuxSrc = SENINF_READ_BITS(pSeninf_cam_mux,
+			SENINF_CAM_MUX_CTRL_0, RG_SENINF_CAM_MUX0_SRC_SEL);
+		break;
+	case SENINF_CAM_MUX1:
+		seninfMuxSrc = SENINF_READ_BITS(pSeninf_cam_mux,
+			SENINF_CAM_MUX_CTRL_0, RG_SENINF_CAM_MUX1_SRC_SEL);
+		break;
+	case SENINF_CAM_MUX2:
+		seninfMuxSrc = SENINF_READ_BITS(pSeninf_cam_mux,
+			SENINF_CAM_MUX_CTRL_0, RG_SENINF_CAM_MUX2_SRC_SEL);
+		break;
+	case SENINF_CAM_MUX3:
+		seninfMuxSrc = SENINF_READ_BITS(pSeninf_cam_mux,
+			SENINF_CAM_MUX_CTRL_0, RG_SENINF_CAM_MUX3_SRC_SEL);
+		break;
+	case SENINF_CAM_MUX4:
+		seninfMuxSrc = SENINF_READ_BITS(pSeninf_cam_mux,
+			SENINF_CAM_MUX_CTRL_1, RG_SENINF_CAM_MUX4_SRC_SEL);
+		break;
+	case SENINF_CAM_MUX5:
+		seninfMuxSrc = SENINF_READ_BITS(pSeninf_cam_mux,
+			SENINF_CAM_MUX_CTRL_1, RG_SENINF_CAM_MUX5_SRC_SEL);
+		break;
+	case SENINF_CAM_MUX6:
+		seninfMuxSrc = SENINF_READ_BITS(pSeninf_cam_mux,
+			SENINF_CAM_MUX_CTRL_1, RG_SENINF_CAM_MUX6_SRC_SEL);
+		break;
+	case SENINF_CAM_MUX7:
+		seninfMuxSrc = SENINF_READ_BITS(pSeninf_cam_mux,
+			SENINF_CAM_MUX_CTRL_1, RG_SENINF_CAM_MUX7_SRC_SEL);
+		break;
+	case SENINF_CAM_MUX8:
+		seninfMuxSrc = SENINF_READ_BITS(pSeninf_cam_mux,
+			SENINF_CAM_MUX_CTRL_2, RG_SENINF_CAM_MUX8_SRC_SEL);
+		break;
+	case SENINF_CAM_MUX9:
+		seninfMuxSrc = SENINF_READ_BITS(pSeninf_cam_mux,
+			SENINF_CAM_MUX_CTRL_2, RG_SENINF_CAM_MUX9_SRC_SEL);
+		break;
+	case SENINF_CAM_MUX10:
+		seninfMuxSrc = SENINF_READ_BITS(pSeninf_cam_mux,
+			SENINF_CAM_MUX_CTRL_2, RG_SENINF_CAM_MUX10_SRC_SEL);
+		break;
+	case SENINF_CAM_MUX11:
+		seninfMuxSrc = SENINF_READ_BITS(pSeninf_cam_mux,
+			SENINF_CAM_MUX_CTRL_2, RG_SENINF_CAM_MUX11_SRC_SEL);
+		break;
+	case SENINF_CAM_MUX12:
+		seninfMuxSrc = SENINF_READ_BITS(pSeninf_cam_mux,
+			SENINF_CAM_MUX_CTRL_3, RG_SENINF_CAM_MUX12_SRC_SEL);
+		break;
+#ifdef ISP7_1
+	case SENINF_CAM_MUX13:
+		seninfMuxSrc = SENINF_READ_BITS(pSeninf_cam_mux,
+			SENINF_CAM_MUX_CTRL_3, RG_SENINF_CAM_MUX13_SRC_SEL);
+		break;
+	case SENINF_CAM_MUX14:
+		seninfMuxSrc = SENINF_READ_BITS(pSeninf_cam_mux,
+			SENINF_CAM_MUX_CTRL_3, RG_SENINF_CAM_MUX14_SRC_SEL);
+		break;
+	case SENINF_CAM_MUX15:
+		seninfMuxSrc = SENINF_READ_BITS(pSeninf_cam_mux,
+			SENINF_CAM_MUX_CTRL_3, RG_SENINF_CAM_MUX15_SRC_SEL);
+		break;
+#endif
+	default:
+		dev_dbg(ctx->dev, "invalid cam_mux %d", cam_mux);
+		return -EINVAL;
+	}
+
+	return seninfMuxSrc;
+}
+
+static u32 mtk_cam_seninf_get_cammux_res(struct seninf_ctx *ctx, int cam_mux)
+{
+	if (cam_mux >= _seninf_ops->cam_mux_num) {
+		dev_dbg(ctx->dev, "%s err cam_mux %d >= SENINF_CAM_MUX_NUM %d\n",
+			__func__,
+			cam_mux,
+			_seninf_ops->cam_mux_num);
+		return 0;
+	}
+
+	return SENINF_READ_REG(ctx->reg_if_cam_mux,
+			SENINF_CAM_MUX0_CHK_RES + (0x10 * cam_mux));
+}
+
+static u32 mtk_cam_seninf_get_cammux_exp(struct seninf_ctx *ctx, int cam_mux)
+{
+	if (cam_mux >= _seninf_ops->cam_mux_num) {
+		dev_dbg(ctx->dev, "%s err cam_mux %d >= SENINF_CAM_MUX_NUM %d\n",
+			__func__,
+			cam_mux,
+			_seninf_ops->cam_mux_num);
+		return 0;
+	}
+
+	return SENINF_READ_REG(ctx->reg_if_cam_mux,
+			SENINF_CAM_MUX0_CHK_CTL_1 + (0x10 * cam_mux));
+}
+
+static int mtk_cam_seninf_set_cammux_vc(struct seninf_ctx *ctx, int cam_mux,
+				 int vc_sel, int dt_sel, int vc_en, int dt_en)
+{
+	void *mpSeninfCamMuxVCAddr = ctx->reg_if_cam_mux + (4 * cam_mux);
+
+	if (cam_mux >= _seninf_ops->cam_mux_num) {
+		dev_dbg(ctx->dev, "%s err cam_mux %d >= SENINF_CAM_MUX_NUM %d\n",
+			__func__,
+			cam_mux,
+			_seninf_ops->cam_mux_num);
+		return 0;
+	}
+
+#if	DEBUG_CAM_MUX_SWITCH
+	dev_dbg(ctx->dev, "cam_mux %d vc 0x%x dt 0x%x, vc_en %d dt_en %d\n",
+		 cam_mux, vc_sel, dt_sel, vc_en, dt_en);
+#endif
+	SENINF_BITS(mpSeninfCamMuxVCAddr, SENINF_CAM_MUX0_OPT,
+		    RG_SENINF_CAM_MUX0_VC_SEL, vc_sel);
+	SENINF_BITS(mpSeninfCamMuxVCAddr, SENINF_CAM_MUX0_OPT,
+		    RG_SENINF_CAM_MUX0_DT_SEL, dt_sel);
+	SENINF_BITS(mpSeninfCamMuxVCAddr, SENINF_CAM_MUX0_OPT,
+		    RG_SENINF_CAM_MUX0_VC_EN, vc_en);
+	SENINF_BITS(mpSeninfCamMuxVCAddr, SENINF_CAM_MUX0_OPT,
+		    RG_SENINF_CAM_MUX0_DT_EN, dt_en);
+
+	return 0;
+}
+static int mtk_cam_seninf_switch_to_cammux_inner_page(struct seninf_ctx *ctx, bool inner)
+{
+	void *mpSeninfCamMuxAddr = ctx->reg_if_cam_mux;
+
+#if	DEBUG_CAM_MUX_SWITCH
+	dev_dbg(ctx->dev, "%s inner %d\n", __func__, inner);
+#endif
+	SENINF_BITS(mpSeninfCamMuxAddr,
+		SENINF_CAM_MUX_DYN_CTRL, CAM_MUX_DYN_PAGE_SEL, inner ? 0 : 1);
+	return 0;
+}
+
+static int mtk_cam_seninf_set_cammux_next_ctrl(struct seninf_ctx *ctx, int src, int target)
+{
+	void *mpSeninfCamMux_base = ctx->reg_if_cam_mux;
+
+	if (target >= _seninf_ops->cam_mux_num) {
+		dev_dbg(ctx->dev, "%s err cam_mux %d >= SENINF_CAM_MUX_NUM %d\n",
+			__func__,
+			target,
+			_seninf_ops->cam_mux_num);
+		return 0;
+	}
+
+#if	DEBUG_CAM_MUX_SWITCH
+	dev_dbg(ctx->dev, "cam_mux %d src %d\n", target, src);
+#endif
+	switch (target) {
+	case SENINF_CAM_MUX0:
+		SENINF_BITS(mpSeninfCamMux_base, SENINF_CAM_MUX_NEXT_CTRL_0,
+			    CAM_MUX0_NEXT_SRC_SEL, src);
+		break;
+	case SENINF_CAM_MUX1:
+		SENINF_BITS(mpSeninfCamMux_base, SENINF_CAM_MUX_NEXT_CTRL_0,
+			    CAM_MUX1_NEXT_SRC_SEL, src);
+		break;
+	case SENINF_CAM_MUX2:
+		SENINF_BITS(mpSeninfCamMux_base, SENINF_CAM_MUX_NEXT_CTRL_0,
+			    CAM_MUX2_NEXT_SRC_SEL, src);
+		break;
+	case SENINF_CAM_MUX3:
+		SENINF_BITS(mpSeninfCamMux_base, SENINF_CAM_MUX_NEXT_CTRL_0,
+			    CAM_MUX3_NEXT_SRC_SEL, src);
+		break;
+	case SENINF_CAM_MUX4:
+		SENINF_BITS(mpSeninfCamMux_base, SENINF_CAM_MUX_NEXT_CTRL_1,
+			    CAM_MUX4_NEXT_SRC_SEL, src);
+
+		break;
+	case SENINF_CAM_MUX5:
+		SENINF_BITS(mpSeninfCamMux_base, SENINF_CAM_MUX_NEXT_CTRL_1,
+			    CAM_MUX5_NEXT_SRC_SEL, src);
+
+		break;
+	case SENINF_CAM_MUX6:
+		SENINF_BITS(mpSeninfCamMux_base, SENINF_CAM_MUX_NEXT_CTRL_1,
+			    CAM_MUX6_NEXT_SRC_SEL, src);
+
+		break;
+	case SENINF_CAM_MUX7:
+		SENINF_BITS(mpSeninfCamMux_base, SENINF_CAM_MUX_NEXT_CTRL_1,
+			    CAM_MUX7_NEXT_SRC_SEL, src);
+
+		break;
+	case SENINF_CAM_MUX8:
+		SENINF_BITS(mpSeninfCamMux_base, SENINF_CAM_MUX_NEXT_CTRL_2,
+			    CAM_MUX8_NEXT_SRC_SEL, src);
+
+		break;
+	case SENINF_CAM_MUX9:
+		SENINF_BITS(mpSeninfCamMux_base, SENINF_CAM_MUX_NEXT_CTRL_2,
+			    CAM_MUX9_NEXT_SRC_SEL, src);
+
+		break;
+	case SENINF_CAM_MUX10:
+		SENINF_BITS(mpSeninfCamMux_base, SENINF_CAM_MUX_NEXT_CTRL_2,
+			    CAM_MUX10_NEXT_SRC_SEL, src);
+
+		break;
+	case SENINF_CAM_MUX11:
+		SENINF_BITS(mpSeninfCamMux_base, SENINF_CAM_MUX_NEXT_CTRL_2,
+			    CAM_MUX11_NEXT_SRC_SEL, src);
+
+		break;
+	case SENINF_CAM_MUX12:
+		SENINF_BITS(mpSeninfCamMux_base, SENINF_CAM_MUX_NEXT_CTRL_3,
+			    CAM_MUX12_NEXT_SRC_SEL, src);
+
+		break;
+#ifdef ISP7_1
+	case SENINF_CAM_MUX13:
+		SENINF_BITS(mpSeninfCamMux_base, SENINF_CAM_MUX_NEXT_CTRL_3,
+				CAM_MUX13_NEXT_SRC_SEL, src);
+
+	break;
+	case SENINF_CAM_MUX14:
+		SENINF_BITS(mpSeninfCamMux_base, SENINF_CAM_MUX_NEXT_CTRL_3,
+			    CAM_MUX14_NEXT_SRC_SEL, src);
+
+	break;
+	case SENINF_CAM_MUX15:
+		SENINF_BITS(mpSeninfCamMux_base, SENINF_CAM_MUX_NEXT_CTRL_3,
+				CAM_MUX15_NEXT_SRC_SEL, src);
+
+	break;
+#endif
+	default:
+		dev_dbg(ctx->dev, "invalid src %d target %d", src, target);
+		return -EINVAL;
+	}
+
+return 0;
+}
+
+
+static int mtk_cam_seninf_set_cammux_src(struct seninf_ctx *ctx, int src, int target,
+				  int exp_hsize, int exp_vsize)
+{
+	void *mpSeninfCamMux_base = ctx->reg_if_cam_mux;
+
+	if (target >= _seninf_ops->cam_mux_num) {
+		dev_dbg(ctx->dev, "%s err cam_mux %d >= SENINF_CAM_MUX_NUM %d\n",
+			__func__,
+			target,
+			_seninf_ops->cam_mux_num);
+		return 0;
+	}
+
+#if	DEBUG_CAM_MUX_SWITCH
+	dev_dbg(ctx->dev, "%s cam_mux %d src %d exp_hsize %d, exp_hsize %d\n",
+		__func__, target, src, exp_hsize, exp_vsize);
+#endif
+	switch (target) {
+	case SENINF_CAM_MUX0:
+		SENINF_BITS(mpSeninfCamMux_base, SENINF_CAM_MUX_CTRL_0,
+			    RG_SENINF_CAM_MUX0_SRC_SEL, src);
+		SENINF_BITS(mpSeninfCamMux_base, SENINF_CAM_MUX0_CHK_CTL_1,
+			    RG_SENINF_CAM_MUX0_EXP_HSIZE, exp_hsize);
+		SENINF_BITS(mpSeninfCamMux_base, SENINF_CAM_MUX0_CHK_CTL_1,
+			    RG_SENINF_CAM_MUX0_EXP_VSIZE, exp_vsize);
+		break;
+	case SENINF_CAM_MUX1:
+		SENINF_BITS(mpSeninfCamMux_base, SENINF_CAM_MUX_CTRL_0,
+			    RG_SENINF_CAM_MUX1_SRC_SEL, src);
+		SENINF_BITS(mpSeninfCamMux_base, SENINF_CAM_MUX1_CHK_CTL_1,
+			    RG_SENINF_CAM_MUX1_EXP_HSIZE, exp_hsize);
+		SENINF_BITS(mpSeninfCamMux_base, SENINF_CAM_MUX1_CHK_CTL_1,
+			    RG_SENINF_CAM_MUX1_EXP_VSIZE, exp_vsize);
+		break;
+	case SENINF_CAM_MUX2:
+		SENINF_BITS(mpSeninfCamMux_base, SENINF_CAM_MUX_CTRL_0,
+			    RG_SENINF_CAM_MUX2_SRC_SEL, src);
+		SENINF_BITS(mpSeninfCamMux_base, SENINF_CAM_MUX2_CHK_CTL_1,
+			    RG_SENINF_CAM_MUX2_EXP_HSIZE, exp_hsize);
+		SENINF_BITS(mpSeninfCamMux_base, SENINF_CAM_MUX2_CHK_CTL_1,
+			    RG_SENINF_CAM_MUX2_EXP_VSIZE, exp_vsize);
+		break;
+	case SENINF_CAM_MUX3:
+		SENINF_BITS(mpSeninfCamMux_base, SENINF_CAM_MUX_CTRL_0,
+			    RG_SENINF_CAM_MUX3_SRC_SEL, src);
+		SENINF_BITS(mpSeninfCamMux_base, SENINF_CAM_MUX3_CHK_CTL_1,
+			    RG_SENINF_CAM_MUX3_EXP_HSIZE, exp_hsize);
+		SENINF_BITS(mpSeninfCamMux_base, SENINF_CAM_MUX3_CHK_CTL_1,
+			    RG_SENINF_CAM_MUX3_EXP_VSIZE, exp_vsize);
+		break;
+	case SENINF_CAM_MUX4:
+		SENINF_BITS(mpSeninfCamMux_base, SENINF_CAM_MUX_CTRL_1,
+			    RG_SENINF_CAM_MUX4_SRC_SEL, src);
+		SENINF_BITS(mpSeninfCamMux_base, SENINF_CAM_MUX4_CHK_CTL_1,
+			    RG_SENINF_CAM_MUX4_EXP_HSIZE, exp_hsize);
+		SENINF_BITS(mpSeninfCamMux_base, SENINF_CAM_MUX4_CHK_CTL_1,
+			    RG_SENINF_CAM_MUX4_EXP_VSIZE, exp_vsize);
+		break;
+	case SENINF_CAM_MUX5:
+		SENINF_BITS(mpSeninfCamMux_base, SENINF_CAM_MUX_CTRL_1,
+			    RG_SENINF_CAM_MUX5_SRC_SEL, src);
+		SENINF_BITS(mpSeninfCamMux_base, SENINF_CAM_MUX5_CHK_CTL_1,
+			    RG_SENINF_CAM_MUX5_EXP_HSIZE, exp_hsize);
+		SENINF_BITS(mpSeninfCamMux_base, SENINF_CAM_MUX5_CHK_CTL_1,
+			    RG_SENINF_CAM_MUX5_EXP_VSIZE, exp_vsize);
+		break;
+	case SENINF_CAM_MUX6:
+		SENINF_BITS(mpSeninfCamMux_base, SENINF_CAM_MUX_CTRL_1,
+			    RG_SENINF_CAM_MUX6_SRC_SEL, src);
+		SENINF_BITS(mpSeninfCamMux_base, SENINF_CAM_MUX6_CHK_CTL_1,
+			    RG_SENINF_CAM_MUX6_EXP_HSIZE, exp_hsize);
+		SENINF_BITS(mpSeninfCamMux_base, SENINF_CAM_MUX6_CHK_CTL_1,
+			    RG_SENINF_CAM_MUX6_EXP_VSIZE, exp_vsize);
+		break;
+	case SENINF_CAM_MUX7:
+		SENINF_BITS(mpSeninfCamMux_base, SENINF_CAM_MUX_CTRL_1,
+			    RG_SENINF_CAM_MUX7_SRC_SEL, src);
+		SENINF_BITS(mpSeninfCamMux_base, SENINF_CAM_MUX7_CHK_CTL_1,
+			    RG_SENINF_CAM_MUX7_EXP_HSIZE, exp_hsize);
+		SENINF_BITS(mpSeninfCamMux_base, SENINF_CAM_MUX7_CHK_CTL_1,
+			    RG_SENINF_CAM_MUX7_EXP_VSIZE, exp_vsize);
+		break;
+	case SENINF_CAM_MUX8:
+		SENINF_BITS(mpSeninfCamMux_base, SENINF_CAM_MUX_CTRL_2,
+			    RG_SENINF_CAM_MUX8_SRC_SEL, src);
+		SENINF_BITS(mpSeninfCamMux_base, SENINF_CAM_MUX8_CHK_CTL_1,
+			    RG_SENINF_CAM_MUX8_EXP_HSIZE, exp_hsize);
+		SENINF_BITS(mpSeninfCamMux_base, SENINF_CAM_MUX8_CHK_CTL_1,
+			    RG_SENINF_CAM_MUX8_EXP_VSIZE, exp_vsize);
+		break;
+	case SENINF_CAM_MUX9:
+		SENINF_BITS(mpSeninfCamMux_base, SENINF_CAM_MUX_CTRL_2,
+			    RG_SENINF_CAM_MUX9_SRC_SEL, src);
+		SENINF_BITS(mpSeninfCamMux_base, SENINF_CAM_MUX9_CHK_CTL_1,
+			    RG_SENINF_CAM_MUX9_EXP_HSIZE, exp_hsize);
+		SENINF_BITS(mpSeninfCamMux_base, SENINF_CAM_MUX9_CHK_CTL_1,
+			    RG_SENINF_CAM_MUX9_EXP_VSIZE, exp_vsize);
+		break;
+	case SENINF_CAM_MUX10:
+		SENINF_BITS(mpSeninfCamMux_base, SENINF_CAM_MUX_CTRL_2,
+			    RG_SENINF_CAM_MUX10_SRC_SEL, src);
+		SENINF_BITS(mpSeninfCamMux_base, SENINF_CAM_MUX10_CHK_CTL_1,
+			    RG_SENINF_CAM_MUX10_EXP_HSIZE, exp_hsize);
+		SENINF_BITS(mpSeninfCamMux_base, SENINF_CAM_MUX10_CHK_CTL_1,
+			    RG_SENINF_CAM_MUX10_EXP_VSIZE, exp_vsize);
+		break;
+	case SENINF_CAM_MUX11:
+		SENINF_BITS(mpSeninfCamMux_base, SENINF_CAM_MUX_CTRL_2,
+			    RG_SENINF_CAM_MUX11_SRC_SEL, src);
+		SENINF_BITS(mpSeninfCamMux_base, SENINF_CAM_MUX11_CHK_CTL_1,
+			    RG_SENINF_CAM_MUX11_EXP_HSIZE, exp_hsize);
+		SENINF_BITS(mpSeninfCamMux_base, SENINF_CAM_MUX11_CHK_CTL_1,
+			    RG_SENINF_CAM_MUX11_EXP_VSIZE, exp_vsize);
+		break;
+	case SENINF_CAM_MUX12:
+		SENINF_BITS(mpSeninfCamMux_base, SENINF_CAM_MUX_CTRL_3,
+			    RG_SENINF_CAM_MUX12_SRC_SEL, src);
+		SENINF_BITS(mpSeninfCamMux_base, SENINF_CAM_MUX12_CHK_CTL_1,
+			    RG_SENINF_CAM_MUX12_EXP_HSIZE, exp_hsize);
+		SENINF_BITS(mpSeninfCamMux_base, SENINF_CAM_MUX12_CHK_CTL_1,
+			    RG_SENINF_CAM_MUX12_EXP_VSIZE, exp_vsize);
+		break;
+#ifdef ISP7_1
+	case SENINF_CAM_MUX13:
+		SENINF_BITS(mpSeninfCamMux_base, SENINF_CAM_MUX_CTRL_3,
+				RG_SENINF_CAM_MUX13_SRC_SEL, src);
+		SENINF_BITS(mpSeninfCamMux_base, SENINF_CAM_MUX13_CHK_CTL_1,
+				RG_SENINF_CAM_MUX13_EXP_HSIZE, exp_hsize);
+		SENINF_BITS(mpSeninfCamMux_base, SENINF_CAM_MUX13_CHK_CTL_1,
+				RG_SENINF_CAM_MUX13_EXP_VSIZE, exp_vsize);
+		break;
+	case SENINF_CAM_MUX14:
+		SENINF_BITS(mpSeninfCamMux_base, SENINF_CAM_MUX_CTRL_3,
+			    RG_SENINF_CAM_MUX14_SRC_SEL, src);
+		SENINF_BITS(mpSeninfCamMux_base, SENINF_CAM_MUX14_CHK_CTL_1,
+			    RG_SENINF_CAM_MUX14_EXP_HSIZE, exp_hsize);
+		SENINF_BITS(mpSeninfCamMux_base, SENINF_CAM_MUX14_CHK_CTL_1,
+			    RG_SENINF_CAM_MUX14_EXP_VSIZE, exp_vsize);
+		break;
+	case SENINF_CAM_MUX15:
+		SENINF_BITS(mpSeninfCamMux_base, SENINF_CAM_MUX_CTRL_3,
+			    RG_SENINF_CAM_MUX15_SRC_SEL, src);
+		SENINF_BITS(mpSeninfCamMux_base, SENINF_CAM_MUX15_CHK_CTL_1,
+			    RG_SENINF_CAM_MUX15_EXP_HSIZE, exp_hsize);
+		SENINF_BITS(mpSeninfCamMux_base, SENINF_CAM_MUX15_CHK_CTL_1,
+			    RG_SENINF_CAM_MUX15_EXP_VSIZE, exp_vsize);
+		break;
+#endif
+	default:
+		dev_dbg(ctx->dev, "invalid src %d target %d", src, target);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int mtk_cam_seninf_set_vc(struct seninf_ctx *ctx, int intf,
+			  struct seninf_vcinfo *vcinfo)
+{
+	void *pSeninf_csi2 = ctx->reg_if_csi2[intf];
+	int i;
+	struct seninf_vc *vc;
+
+	if (!vcinfo || !vcinfo->cnt)
+		return 0;
+
+	SENINF_WRITE_REG(pSeninf_csi2, SENINF_CSI2_S0_DI_CTRL, 0);
+	SENINF_WRITE_REG(pSeninf_csi2, SENINF_CSI2_S1_DI_CTRL, 0);
+	SENINF_WRITE_REG(pSeninf_csi2, SENINF_CSI2_S2_DI_CTRL, 0);
+	SENINF_WRITE_REG(pSeninf_csi2, SENINF_CSI2_S3_DI_CTRL, 0);
+	SENINF_WRITE_REG(pSeninf_csi2, SENINF_CSI2_S4_DI_CTRL, 0);
+	SENINF_WRITE_REG(pSeninf_csi2, SENINF_CSI2_S5_DI_CTRL, 0);
+	SENINF_WRITE_REG(pSeninf_csi2, SENINF_CSI2_S6_DI_CTRL, 0);
+	SENINF_WRITE_REG(pSeninf_csi2, SENINF_CSI2_S7_DI_CTRL, 0);
+
+	SENINF_WRITE_REG(pSeninf_csi2, SENINF_CSI2_CH0_CTRL, 0);
+	SENINF_WRITE_REG(pSeninf_csi2, SENINF_CSI2_CH1_CTRL, 0);
+	SENINF_WRITE_REG(pSeninf_csi2, SENINF_CSI2_CH2_CTRL, 0);
+	SENINF_WRITE_REG(pSeninf_csi2, SENINF_CSI2_CH3_CTRL, 0);
+
+	for (i = 0; i < vcinfo->cnt; i++) {
+		vc = &vcinfo->vc[i];
+
+		/* General Long Packet Data Types: 0x10-0x17 */
+		if (vc->dt >= 0x10 && vc->dt <= 0x17) {
+			SENINF_BITS(pSeninf_csi2, SENINF_CSI2_OPT,
+				    RG_CSI2_GENERIC_LONG_PACKET_EN, 1);
+		}
+
+		switch (i) {
+		case 0:
+			SET_DI_CH_CTRL(pSeninf_csi2, 0, vc);
+			break;
+		case 1:
+			SET_DI_CH_CTRL(pSeninf_csi2, 1, vc);
+			break;
+		case 2:
+			SET_DI_CH_CTRL(pSeninf_csi2, 2, vc);
+			break;
+		case 3:
+			SET_DI_CH_CTRL(pSeninf_csi2, 3, vc);
+			break;
+		case 4:
+			SET_DI_CH_CTRL(pSeninf_csi2, 4, vc);
+			break;
+		case 5:
+			SET_DI_CH_CTRL(pSeninf_csi2, 5, vc);
+			break;
+		case 6:
+			SET_DI_CH_CTRL(pSeninf_csi2, 6, vc);
+			break;
+		case 7:
+			SET_DI_CH_CTRL(pSeninf_csi2, 7, vc);
+			break;
+		}
+	}
+
+	dev_dbg(ctx->dev, "DI_CTRL 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\n",
+		 SENINF_READ_REG(pSeninf_csi2, SENINF_CSI2_S0_DI_CTRL),
+		SENINF_READ_REG(pSeninf_csi2, SENINF_CSI2_S1_DI_CTRL),
+		SENINF_READ_REG(pSeninf_csi2, SENINF_CSI2_S2_DI_CTRL),
+		SENINF_READ_REG(pSeninf_csi2, SENINF_CSI2_S3_DI_CTRL),
+		SENINF_READ_REG(pSeninf_csi2, SENINF_CSI2_S4_DI_CTRL),
+		SENINF_READ_REG(pSeninf_csi2, SENINF_CSI2_S5_DI_CTRL),
+		SENINF_READ_REG(pSeninf_csi2, SENINF_CSI2_S6_DI_CTRL),
+		SENINF_READ_REG(pSeninf_csi2, SENINF_CSI2_S7_DI_CTRL));
+
+	dev_dbg(ctx->dev, "CH_CTRL 0x%x 0x%x 0x%x 0x%x\n",
+		 SENINF_READ_REG(pSeninf_csi2, SENINF_CSI2_CH0_CTRL),
+		SENINF_READ_REG(pSeninf_csi2, SENINF_CSI2_CH1_CTRL),
+		SENINF_READ_REG(pSeninf_csi2, SENINF_CSI2_CH2_CTRL),
+		SENINF_READ_REG(pSeninf_csi2, SENINF_CSI2_CH3_CTRL));
+
+	return 0;
+}
+
+static int mtk_cam_seninf_set_mux_ctrl(struct seninf_ctx *ctx, int mux,
+				int hsPol, int vsPol, int src_sel,
+				int pixel_mode)
+{
+	unsigned int temp = 0;
+	void *pSeninf_mux;
+
+	pSeninf_mux = ctx->reg_if_mux[mux];
+
+	//1A00 4D04[3:0] select source group
+	SENINF_BITS(pSeninf_mux, SENINF_MUX_CTRL_1,
+		    RG_SENINF_MUX_SRC_SEL,
+			src_sel);
+
+	SENINF_BITS(pSeninf_mux, SENINF_MUX_CTRL_1,
+		    RG_SENINF_MUX_PIX_MODE_SEL,
+			pixel_mode);
+
+//	set_camux_checker_pixel_mode(0, pixel_mode);
+
+	SENINF_BITS(pSeninf_mux, SENINF_MUX_OPT,
+		    RG_SENINF_MUX_HSYNC_POL, hsPol);
+	SENINF_BITS(pSeninf_mux, SENINF_MUX_OPT,
+		    RG_SENINF_MUX_VSYNC_POL, vsPol);
+
+	temp = SENINF_READ_REG(pSeninf_mux, SENINF_MUX_CTRL_0);
+	SENINF_WRITE_REG(pSeninf_mux, SENINF_MUX_CTRL_0, temp | 0x6);//reset
+	SENINF_WRITE_REG(pSeninf_mux, SENINF_MUX_CTRL_0, temp & 0xFFFFFFF9);
+#if LOG_MORE
+	dev_dbg(ctx->dev, "SENINF_MUX_CTRL_1(0x%x), SENINF_MUX_OPT(0x%x)",
+		 SENINF_READ_REG(pSeninf_mux, SENINF_MUX_CTRL_1),
+		SENINF_READ_REG(pSeninf_mux, SENINF_MUX_OPT));
+#endif
+	return 0;
+}
+
+static int mtk_cam_seninf_update_mux_pixel_mode(struct seninf_ctx *ctx, int mux,
+				int pixel_mode)
+{
+	unsigned int temp = 0;
+	void *pSeninf_mux;
+
+	pSeninf_mux = ctx->reg_if_mux[mux];
+
+
+	SENINF_BITS(pSeninf_mux, SENINF_MUX_CTRL_1,
+		    RG_SENINF_MUX_PIX_MODE_SEL,
+			pixel_mode);
+
+	temp = SENINF_READ_REG(pSeninf_mux, SENINF_MUX_CTRL_0);
+	SENINF_WRITE_REG(pSeninf_mux, SENINF_MUX_CTRL_0, temp | 0x6);//reset
+	SENINF_WRITE_REG(pSeninf_mux, SENINF_MUX_CTRL_0, temp & 0xFFFFFFF9);
+
+	dev_dbg(ctx->dev, "%s mux %d SENINF_MUX_CTRL_1(0x%x), SENINF_MUX_OPT(0x%x)",
+		__func__,
+		mux,
+		SENINF_READ_REG(pSeninf_mux, SENINF_MUX_CTRL_1),
+		SENINF_READ_REG(pSeninf_mux, SENINF_MUX_OPT));
+
+	return 0;
+}
+
+
+static int mtk_cam_seninf_set_mux_crop(struct seninf_ctx *ctx, int mux,
+				int start_x, int end_x, int enable)
+{
+	void *pSeninf_mux = ctx->reg_if_mux[mux];
+
+	SENINF_BITS(pSeninf_mux, SENINF_MUX_CROP_PIX_CTRL,
+		    RG_SENINF_MUX_CROP_START_8PIX_CNT, start_x / 8);
+	SENINF_BITS(pSeninf_mux, SENINF_MUX_CROP_PIX_CTRL,
+		    RG_SENINF_MUX_CROP_END_8PIX_CNT,
+		start_x / 8 + (end_x - start_x + 1) / 8 - 1 + (((end_x -
+		start_x + 1) % 8) > 0 ? 1 : 0));
+	SENINF_BITS(pSeninf_mux, SENINF_MUX_CTRL_1,
+		    RG_SENINF_MUX_CROP_EN, enable);
+
+	dev_dbg(ctx->dev, "MUX_CROP_PIX_CTRL 0x%x MUX_CTRL_1 0x%x\n",
+		 SENINF_READ_REG(pSeninf_mux, SENINF_MUX_CROP_PIX_CTRL),
+		SENINF_READ_REG(pSeninf_mux, SENINF_MUX_CTRL_1));
+
+	dev_dbg(ctx->dev, "mux %d, start %d, end %d, enable %d\n",
+		 mux, start_x, end_x, enable);
+
+	return 0;
+}
+
+static int mtk_cam_seninf_is_mux_used(struct seninf_ctx *ctx, int mux)
+{
+	void *pSeninf_mux = ctx->reg_if_mux[mux];
+
+	return SENINF_READ_BITS(pSeninf_mux, SENINF_MUX_CTRL_0, SENINF_MUX_EN);
+}
+
+static int mtk_cam_seninf_mux(struct seninf_ctx *ctx, int mux)
+{
+	void *pSeninf_mux = ctx->reg_if_mux[mux];
+
+	SENINF_BITS(pSeninf_mux, SENINF_MUX_CTRL_0, SENINF_MUX_EN, 1);
+	return 0;
+}
+
+static int mtk_cam_seninf_disable_mux(struct seninf_ctx *ctx, int mux)
+{
+	int i;
+	void *pSeninf_mux = ctx->reg_if_mux[mux];
+
+	SENINF_BITS(pSeninf_mux, SENINF_MUX_CTRL_0, SENINF_MUX_EN, 0);
+
+	//also disable CAM_MUX with input from mux
+	for (i = SENINF_CAM_MUX0; i < _seninf_ops->cam_mux_num; i++) {
+		if (mux == mtk_cam_seninf_get_cammux_ctrl(ctx, i))
+			mtk_cam_seninf_disable_cammux(ctx, i);
+	}
+
+	return 0;
+}
+
+static int mtk_cam_seninf_disable_all_mux(struct seninf_ctx *ctx)
+{
+	int i;
+	void *pSeninf_mux;
+
+	for (i = 0; i < _seninf_ops->mux_num; i++) {
+		pSeninf_mux = ctx->reg_if_mux[i];
+		SENINF_BITS(pSeninf_mux, SENINF_MUX_CTRL_0, SENINF_MUX_EN, 0);
+	}
+
+	return 0;
+}
+
+static int mtk_cam_seninf_set_cammux_chk_pixel_mode(struct seninf_ctx *ctx,
+					     int cam_mux, int pixel_mode)
+{
+	void *mpSeninfCamMux_base = ctx->reg_if_cam_mux;
+
+	if (cam_mux >= _seninf_ops->cam_mux_num) {
+		dev_dbg(ctx->dev, "%s err cam_mux %d >= SENINF_CAM_MUX_NUM %d\n",
+			__func__,
+			cam_mux,
+			_seninf_ops->cam_mux_num);
+		return 0;
+	}
+
+#if	DEBUG_CAM_MUX_SWITCH
+	dev_dbg(ctx->dev, "%s cam_mux %d chk pixel_mode %d\n",
+		__func__, cam_mux, pixel_mode);
+#endif
+	switch (cam_mux) {
+	case SENINF_CAM_MUX0:
+		SENINF_BITS(mpSeninfCamMux_base,
+			    SENINF_CAM_MUX0_CHK_CTL_0,
+			RG_SENINF_CAM_MUX0_PIX_MODE_SEL, pixel_mode);
+		break;
+	case SENINF_CAM_MUX1:
+		SENINF_BITS(mpSeninfCamMux_base,
+			    SENINF_CAM_MUX1_CHK_CTL_0,
+			RG_SENINF_CAM_MUX1_PIX_MODE_SEL, pixel_mode);
+		break;
+	case SENINF_CAM_MUX2:
+		SENINF_BITS(mpSeninfCamMux_base,
+			    SENINF_CAM_MUX2_CHK_CTL_0,
+			RG_SENINF_CAM_MUX2_PIX_MODE_SEL, pixel_mode);
+		break;
+	case SENINF_CAM_MUX3:
+		SENINF_BITS(mpSeninfCamMux_base,
+			    SENINF_CAM_MUX3_CHK_CTL_0,
+			RG_SENINF_CAM_MUX3_PIX_MODE_SEL, pixel_mode);
+		break;
+	case SENINF_CAM_MUX4:
+		SENINF_BITS(mpSeninfCamMux_base,
+			    SENINF_CAM_MUX4_CHK_CTL_0,
+			RG_SENINF_CAM_MUX4_PIX_MODE_SEL, pixel_mode);
+		break;
+	case SENINF_CAM_MUX5:
+		SENINF_BITS(mpSeninfCamMux_base,
+			    SENINF_CAM_MUX5_CHK_CTL_0,
+			RG_SENINF_CAM_MUX5_PIX_MODE_SEL, pixel_mode);
+		break;
+	case SENINF_CAM_MUX6:
+		SENINF_BITS(mpSeninfCamMux_base,
+			    SENINF_CAM_MUX6_CHK_CTL_0,
+			RG_SENINF_CAM_MUX6_PIX_MODE_SEL, pixel_mode);
+		break;
+	case SENINF_CAM_MUX7:
+		SENINF_BITS(mpSeninfCamMux_base,
+			    SENINF_CAM_MUX7_CHK_CTL_0,
+			RG_SENINF_CAM_MUX7_PIX_MODE_SEL, pixel_mode);
+		break;
+	case SENINF_CAM_MUX8:
+		SENINF_BITS(mpSeninfCamMux_base,
+			    SENINF_CAM_MUX8_CHK_CTL_0,
+			RG_SENINF_CAM_MUX8_PIX_MODE_SEL, pixel_mode);
+		break;
+	case SENINF_CAM_MUX9:
+		SENINF_BITS(mpSeninfCamMux_base,
+			    SENINF_CAM_MUX9_CHK_CTL_0,
+			RG_SENINF_CAM_MUX9_PIX_MODE_SEL, pixel_mode);
+		break;
+	case SENINF_CAM_MUX10:
+		SENINF_BITS(mpSeninfCamMux_base,
+			    SENINF_CAM_MUX10_CHK_CTL_0,
+			RG_SENINF_CAM_MUX10_PIX_MODE_SEL, pixel_mode);
+		break;
+	case SENINF_CAM_MUX11:
+		SENINF_BITS(mpSeninfCamMux_base,
+			    SENINF_CAM_MUX11_CHK_CTL_0,
+			RG_SENINF_CAM_MUX11_PIX_MODE_SEL, pixel_mode);
+		break;
+	case SENINF_CAM_MUX12:
+		SENINF_BITS(mpSeninfCamMux_base,
+			    SENINF_CAM_MUX12_CHK_CTL_0,
+			RG_SENINF_CAM_MUX12_PIX_MODE_SEL, pixel_mode);
+		break;
+#ifdef ISP7_1
+	case SENINF_CAM_MUX13:
+		SENINF_BITS(mpSeninfCamMux_base,
+				SENINF_CAM_MUX13_CHK_CTL_0,
+			RG_SENINF_CAM_MUX13_PIX_MODE_SEL, pixel_mode);
+		break;
+	case SENINF_CAM_MUX14:
+		SENINF_BITS(mpSeninfCamMux_base,
+				SENINF_CAM_MUX14_CHK_CTL_0,
+			RG_SENINF_CAM_MUX14_PIX_MODE_SEL, pixel_mode);
+		break;
+	case SENINF_CAM_MUX15:
+		SENINF_BITS(mpSeninfCamMux_base,
+				SENINF_CAM_MUX15_CHK_CTL_0,
+			RG_SENINF_CAM_MUX15_PIX_MODE_SEL, pixel_mode);
+		break;
+#endif
+	default:
+		dev_dbg(ctx->dev, "invalid cam_mux %d pixel_mode %d\n",
+			cam_mux, pixel_mode);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int mtk_cam_seninf_set_test_model(struct seninf_ctx *ctx,
+				  int mux, int cam_mux, int pixel_mode)
+{
+	int intf;
+	void *pSeninf;
+	void *pSeninf_tg;
+
+	intf = mux % 5; /* XXX: only a subset of seninf has a testmdl, by platform */
+
+	pSeninf = ctx->reg_if_ctrl[intf];
+	pSeninf_tg = ctx->reg_if_tg[intf];
+
+	_seninf_ops->_reset(ctx, intf);
+	mtk_cam_seninf_mux(ctx, mux);
+	mtk_cam_seninf_set_mux_ctrl(ctx, mux,
+				    0, 0, TEST_MODEL, pixel_mode);
+	mtk_cam_seninf_set_top_mux_ctrl(ctx, mux, intf);
+
+	mtk_cam_seninf_set_cammux_vc(ctx, cam_mux, 0, 0, 0, 0);
+	mtk_cam_seninf_set_cammux_src(ctx, mux, cam_mux, 0, 0);
+	mtk_cam_seninf_set_cammux_chk_pixel_mode(ctx, cam_mux, pixel_mode);
+	mtk_cam_seninf_cammux(ctx, cam_mux);
+
+	SENINF_BITS(pSeninf, SENINF_TESTMDL_CTRL, RG_SENINF_TESTMDL_EN, 1);
+	SENINF_BITS(pSeninf, SENINF_CTRL, SENINF_EN, 1);
+
+	SENINF_BITS(pSeninf_tg, TM_SIZE, TM_LINE, 4224);
+	SENINF_BITS(pSeninf_tg, TM_SIZE, TM_PXL, 5632);
+	SENINF_BITS(pSeninf_tg, TM_CLK, TM_CLK_CNT, 7);
+
+	SENINF_BITS(pSeninf_tg, TM_DUM, TM_VSYNC, 100);
+	SENINF_BITS(pSeninf_tg, TM_DUM, TM_DUMMYPXL, 100);
+
+	SENINF_BITS(pSeninf_tg, TM_CTL, TM_PAT, 0xC);
+	SENINF_BITS(pSeninf_tg, TM_CTL, TM_EN, 1);
+
+	return 0;
+}
+
+static int csirx_phyA_power_on(struct seninf_ctx *ctx, int portIdx, int en)
+{
+	void *base = ctx->reg_ana_csi_rx[portIdx];
+
+	SENINF_BITS(base, CDPHY_RX_ANA_8, RG_CSI0_L0_T0AB_EQ_OS_CAL_EN, 0);
+	SENINF_BITS(base, CDPHY_RX_ANA_8, RG_CSI0_L1_T1AB_EQ_OS_CAL_EN, 0);
+	SENINF_BITS(base, CDPHY_RX_ANA_8, RG_CSI0_L2_T1BC_EQ_OS_CAL_EN, 0);
+	SENINF_BITS(base, CDPHY_RX_ANA_8, RG_CSI0_XX_T0BC_EQ_OS_CAL_EN, 0);
+	SENINF_BITS(base, CDPHY_RX_ANA_8, RG_CSI0_XX_T0CA_EQ_OS_CAL_EN, 0);
+	SENINF_BITS(base, CDPHY_RX_ANA_8, RG_CSI0_XX_T1CA_EQ_OS_CAL_EN, 0);
+	SENINF_BITS(base, CDPHY_RX_ANA_0, RG_CSI0_BG_LPF_EN, 0);
+	SENINF_BITS(base, CDPHY_RX_ANA_0, RG_CSI0_BG_CORE_EN, 0);
+	udelay(200);
+
+	if (en) {
+		SENINF_BITS(base, CDPHY_RX_ANA_0,
+			    RG_CSI0_BG_CORE_EN, 1);
+		udelay(30);
+		SENINF_BITS(base, CDPHY_RX_ANA_0,
+			    RG_CSI0_BG_LPF_EN, 1);
+		udelay(1);
+		SENINF_BITS(base, CDPHY_RX_ANA_8,
+			    RG_CSI0_L0_T0AB_EQ_OS_CAL_EN, 1);
+		SENINF_BITS(base, CDPHY_RX_ANA_8,
+			    RG_CSI0_L1_T1AB_EQ_OS_CAL_EN, 1);
+		SENINF_BITS(base, CDPHY_RX_ANA_8,
+			    RG_CSI0_L2_T1BC_EQ_OS_CAL_EN, 1);
+		SENINF_BITS(base, CDPHY_RX_ANA_8,
+			    RG_CSI0_XX_T0BC_EQ_OS_CAL_EN, 1);
+		SENINF_BITS(base, CDPHY_RX_ANA_8,
+			    RG_CSI0_XX_T0CA_EQ_OS_CAL_EN, 1);
+		SENINF_BITS(base, CDPHY_RX_ANA_8,
+			    RG_CSI0_XX_T1CA_EQ_OS_CAL_EN, 1);
+		udelay(1);
+#if LOG_MORE
+		dev_dbg(ctx->dev, "portIdx %d en %d CDPHY_RX_ANA_0 0x%x ANA_8 0x%x\n",
+			portIdx, en,
+			SENINF_READ_REG(base, CDPHY_RX_ANA_0),
+			SENINF_READ_REG(base, CDPHY_RX_ANA_8));
+#endif
+	}
+
+	return 0;
+}
+#ifdef CSI_EFUSE_SET
+static int apply_efuse_data(struct seninf_ctx *ctx)
+{
+	int ret = 0;
+	int port;
+	void *base;
+	unsigned int m_csi_efuse = ctx->m_csi_efuse;
+
+	if (m_csi_efuse == 0) {
+#if LOG_MORE
+		dev_dbg(ctx->dev, "No efuse data. Returned.\n");
+#endif
+		return -1;
+	}
+
+	port = ctx->port;
+	base = ctx->reg_ana_csi_rx[port];
+#ifdef ISP7_1
+	SENINF_BITS(base, CDPHY_RX_ANA_2,
+		RG_CSI0_L0P_T0A_HSRT_CODE, (m_csi_efuse>>27) & 0x1f);
+	SENINF_BITS(base, CDPHY_RX_ANA_2,
+		RG_CSI0_L0N_T0B_HSRT_CODE, (m_csi_efuse>>27) & 0x1f);
+	SENINF_BITS(base, CDPHY_RX_ANA_3,
+		RG_CSI0_L1P_T0C_HSRT_CODE, (m_csi_efuse>>22) & 0x1f);
+	SENINF_BITS(base, CDPHY_RX_ANA_3,
+		RG_CSI0_L1N_T1A_HSRT_CODE, (m_csi_efuse>>22) & 0x1f);
+	SENINF_BITS(base, CDPHY_RX_ANA_4,
+		RG_CSI0_L2P_T1B_HSRT_CODE, (m_csi_efuse>>17) & 0x1f);
+	SENINF_BITS(base, CDPHY_RX_ANA_4,
+		RG_CSI0_L2N_T1C_HSRT_CODE, (m_csi_efuse>>17) & 0x1f);
+#else
+	SENINF_BITS(base, CDPHY_RX_ANA_2,
+		RG_CSI0_L0P_T0A_HSRT_CODE, (m_csi_efuse>>0) & 0x1f);
+	SENINF_BITS(base, CDPHY_RX_ANA_2,
+		RG_CSI0_L0N_T0B_HSRT_CODE, (m_csi_efuse>>0) & 0x1f);
+	SENINF_BITS(base, CDPHY_RX_ANA_3,
+		RG_CSI0_L1P_T0C_HSRT_CODE, (m_csi_efuse>>5) & 0x1f);
+	SENINF_BITS(base, CDPHY_RX_ANA_3,
+		RG_CSI0_L1N_T1A_HSRT_CODE, (m_csi_efuse>>5) & 0x1f);
+	SENINF_BITS(base, CDPHY_RX_ANA_4,
+		RG_CSI0_L2P_T1B_HSRT_CODE, (m_csi_efuse>>10) & 0x1f);
+	SENINF_BITS(base, CDPHY_RX_ANA_4,
+		RG_CSI0_L2N_T1C_HSRT_CODE, (m_csi_efuse>>10) & 0x1f);
+#endif
+	dev_dbg(ctx->dev,
+		"CSI%dA CDPHY_RX_ANA_2(0x%x) CDPHY_RX_ANA_3(0x%x) CDPHY_RX_ANA_4(0x%x)",
+		ctx->port,
+		SENINF_READ_REG(base, CDPHY_RX_ANA_2),
+		SENINF_READ_REG(base, CDPHY_RX_ANA_3),
+		SENINF_READ_REG(base, CDPHY_RX_ANA_4));
+
+	if (ctx->is_4d1c == 0)
+		return ret;
+
+	port = ctx->portB;
+	base = ctx->reg_ana_csi_rx[port];
+#ifdef ISP7_1
+	SENINF_BITS(base, CDPHY_RX_ANA_2,
+		RG_CSI0_L0P_T0A_HSRT_CODE, (m_csi_efuse>>12) & 0x1f);
+	SENINF_BITS(base, CDPHY_RX_ANA_2,
+		RG_CSI0_L0N_T0B_HSRT_CODE, (m_csi_efuse>>12) & 0x1f);
+	SENINF_BITS(base, CDPHY_RX_ANA_3,
+		RG_CSI0_L1P_T0C_HSRT_CODE, (m_csi_efuse>>7) & 0x1f);
+	SENINF_BITS(base, CDPHY_RX_ANA_3,
+		RG_CSI0_L1N_T1A_HSRT_CODE, (m_csi_efuse>>7) & 0x1f);
+	if (port < CSI_PORT_2A) {
+		SENINF_BITS(base, CDPHY_RX_ANA_4,
+			RG_CSI0_L2P_T1B_HSRT_CODE, (m_csi_efuse>>2) & 0x1f);
+		SENINF_BITS(base, CDPHY_RX_ANA_4,
+			RG_CSI0_L2N_T1C_HSRT_CODE, (m_csi_efuse>>2) & 0x1f);
+		dev_dbg(ctx->dev,
+			"CSI%dB CDPHY_RX_ANA_2(0x%x) CDPHY_RX_ANA_3(0x%x) CDPHY_RX_ANA_4(0x%x)",
+			ctx->port,
+			SENINF_READ_REG(base, CDPHY_RX_ANA_2),
+			SENINF_READ_REG(base, CDPHY_RX_ANA_3),
+			SENINF_READ_REG(base, CDPHY_RX_ANA_4));
+	} else
+		dev_dbg(ctx->dev,
+			"CSI%dB CDPHY_RX_ANA_2(0x%x) CDPHY_RX_ANA_3(0x%x)",
+			ctx->port,
+			SENINF_READ_REG(base, CDPHY_RX_ANA_2),
+			SENINF_READ_REG(base, CDPHY_RX_ANA_3));
+#else
+	SENINF_BITS(base, CDPHY_RX_ANA_2,
+		RG_CSI0_L0P_T0A_HSRT_CODE, (m_csi_efuse>>15) & 0x1f);
+	SENINF_BITS(base, CDPHY_RX_ANA_2,
+		RG_CSI0_L0N_T0B_HSRT_CODE, (m_csi_efuse>>15) & 0x1f);
+	SENINF_BITS(base, CDPHY_RX_ANA_3,
+		RG_CSI0_L1P_T0C_HSRT_CODE, (m_csi_efuse>>20) & 0x1f);
+	SENINF_BITS(base, CDPHY_RX_ANA_3,
+		RG_CSI0_L1N_T1A_HSRT_CODE, (m_csi_efuse>>20) & 0x1f);
+	SENINF_BITS(base, CDPHY_RX_ANA_4,
+		RG_CSI0_L2P_T1B_HSRT_CODE, (m_csi_efuse>>25) & 0x1f);
+	SENINF_BITS(base, CDPHY_RX_ANA_4,
+		RG_CSI0_L2N_T1C_HSRT_CODE, (m_csi_efuse>>25) & 0x1f);
+	dev_dbg(ctx->dev,
+		"CSI%dB CDPHY_RX_ANA_2(0x%x) CDPHY_RX_ANA_3(0x%x) CDPHY_RX_ANA_4(0x%x)", ctx->port,
+		SENINF_READ_REG(base, CDPHY_RX_ANA_2),
+		SENINF_READ_REG(base, CDPHY_RX_ANA_3),
+		SENINF_READ_REG(base, CDPHY_RX_ANA_4));
+#endif
+	return ret;
+}
+#endif
+static int csirx_phyA_init(struct seninf_ctx *ctx)
+{
+	int i, port;
+	void *base;
+
+	port = ctx->port;
+	for (i = 0; i <= ctx->is_4d1c; i++) {
+		port = i ? ctx->portB : ctx->port;
+		base = ctx->reg_ana_csi_rx[port];
+		SENINF_BITS(base, CDPHY_RX_ANA_1,
+			    RG_CSI0_BG_LPRX_VTL_SEL, 0x4);
+		SENINF_BITS(base, CDPHY_RX_ANA_1,
+			    RG_CSI0_BG_LPRX_VTH_SEL, 0x4);
+		SENINF_BITS(base, CDPHY_RX_ANA_2,
+			    RG_CSI0_BG_ALP_RX_VTL_SEL, 0x4);
+		SENINF_BITS(base, CDPHY_RX_ANA_2,
+			    RG_CSI0_BG_ALP_RX_VTH_SEL, 0x4);
+		SENINF_BITS(base, CDPHY_RX_ANA_1,
+			    RG_CSI0_BG_VREF_SEL, 0x8);
+		SENINF_BITS(base, CDPHY_RX_ANA_1,
+			    RG_CSI0_CDPHY_EQ_DES_VREF_SEL, 0x2);
+		SENINF_BITS(base, CDPHY_RX_ANA_5,
+			    RG_CSI0_CDPHY_EQ_BW, 0x3);
+		SENINF_BITS(base, CDPHY_RX_ANA_5,
+			    RG_CSI0_CDPHY_EQ_IS, 0x1);
+		SENINF_BITS(base, CDPHY_RX_ANA_5,
+			    RG_CSI0_CDPHY_EQ_LATCH_EN, 0x1);
+		SENINF_BITS(base, CDPHY_RX_ANA_5,
+			    RG_CSI0_CDPHY_EQ_DG0_EN, 0x1);
+		SENINF_BITS(base, CDPHY_RX_ANA_5,
+			    RG_CSI0_CDPHY_EQ_DG1_EN, 0x1);
+		SENINF_BITS(base, CDPHY_RX_ANA_5,
+			    RG_CSI0_CDPHY_EQ_SR0, 0x0);
+		SENINF_BITS(base, CDPHY_RX_ANA_5,
+			    RG_CSI0_CDPHY_EQ_SR1, 0x0);
+		SENINF_BITS(base, CDPHY_RX_ANA_9,
+			    RG_CSI0_RESERVE, 0x3003);
+		SENINF_BITS(base, CDPHY_RX_ANA_SETTING_0,
+			    CSR_CSI_RST_MODE, 0x2);
+
+		//r50 termination
+		SENINF_BITS(base, CDPHY_RX_ANA_2,
+			    RG_CSI0_L0P_T0A_HSRT_CODE, 0x10);
+		SENINF_BITS(base, CDPHY_RX_ANA_2,
+			    RG_CSI0_L0N_T0B_HSRT_CODE, 0x10);
+		SENINF_BITS(base, CDPHY_RX_ANA_3,
+			    RG_CSI0_L1P_T0C_HSRT_CODE, 0x10);
+		SENINF_BITS(base, CDPHY_RX_ANA_3,
+			    RG_CSI0_L1N_T1A_HSRT_CODE, 0x10);
+		SENINF_BITS(base, CDPHY_RX_ANA_4,
+			    RG_CSI0_L2P_T1B_HSRT_CODE, 0x10);
+		SENINF_BITS(base, CDPHY_RX_ANA_4,
+			    RG_CSI0_L2N_T1C_HSRT_CODE, 0x10);
+		SENINF_BITS(base, CDPHY_RX_ANA_0,
+			    RG_CSI0_CPHY_T0_CDR_FIRST_EDGE_EN, 0x0);
+		SENINF_BITS(base, CDPHY_RX_ANA_0,
+			    RG_CSI0_CPHY_T1_CDR_FIRST_EDGE_EN, 0x0);
+		SENINF_BITS(base, CDPHY_RX_ANA_2,
+			    RG_CSI0_CPHY_T0_CDR_SELF_CAL_EN, 0x0);
+		SENINF_BITS(base, CDPHY_RX_ANA_2,
+			    RG_CSI0_CPHY_T1_CDR_SELF_CAL_EN, 0x0);
+
+		SENINF_BITS(base, CDPHY_RX_ANA_6,
+			    RG_CSI0_CPHY_T0_CDR_CK_DELAY, 0x0);
+		SENINF_BITS(base, CDPHY_RX_ANA_7,
+			    RG_CSI0_CPHY_T1_CDR_CK_DELAY, 0x0);
+		SENINF_BITS(base, CDPHY_RX_ANA_6,
+			    RG_CSI0_CPHY_T0_CDR_AB_WIDTH, 0x9);
+		SENINF_BITS(base, CDPHY_RX_ANA_6,
+			    RG_CSI0_CPHY_T0_CDR_BC_WIDTH, 0x9);
+		SENINF_BITS(base, CDPHY_RX_ANA_6,
+			    RG_CSI0_CPHY_T0_CDR_CA_WIDTH, 0x9);
+		SENINF_BITS(base, CDPHY_RX_ANA_7,
+			    RG_CSI0_CPHY_T1_CDR_AB_WIDTH, 0x9);
+		SENINF_BITS(base, CDPHY_RX_ANA_7,
+			    RG_CSI0_CPHY_T1_CDR_BC_WIDTH, 0x9);
+		SENINF_BITS(base, CDPHY_RX_ANA_7,
+			    RG_CSI0_CPHY_T1_CDR_CA_WIDTH, 0x9);
+
+		dev_dbg(ctx->dev, "port:%d CDPHY_RX_ANA_0(0x%x)\n",
+			 port, SENINF_READ_REG(base, CDPHY_RX_ANA_0));
+	}
+
+#ifdef CSI_EFUSE_SET
+	apply_efuse_data(ctx);
+#endif
+
+	return 0;
+}
+
+static int csirx_dphy_init(struct seninf_ctx *ctx)
+{
+	void *base = ctx->reg_ana_dphy_top[ctx->port];
+	int settle_delay_dt, settle_delay_ck, hs_trail, hs_trail_en;
+	int bit_per_pixel;
+	u64 data_rate;
+
+	settle_delay_dt = ctx->is_cphy ? ctx->core->cphy_settle_delay_dt :
+		ctx->core->dphy_settle_delay_dt;
+
+	SENINF_BITS(base, DPHY_RX_DATA_LANE0_HS_PARAMETER,
+		    RG_CDPHY_RX_LD0_TRIO0_HS_SETTLE_PARAMETER,
+		    settle_delay_dt);
+	SENINF_BITS(base, DPHY_RX_DATA_LANE1_HS_PARAMETER,
+		    RG_CDPHY_RX_LD1_TRIO1_HS_SETTLE_PARAMETER,
+		    settle_delay_dt);
+	SENINF_BITS(base, DPHY_RX_DATA_LANE2_HS_PARAMETER,
+		    RG_CDPHY_RX_LD2_TRIO2_HS_SETTLE_PARAMETER,
+		    settle_delay_dt);
+	SENINF_BITS(base, DPHY_RX_DATA_LANE3_HS_PARAMETER,
+		    RG_CDPHY_RX_LD3_TRIO3_HS_SETTLE_PARAMETER,
+		    settle_delay_dt);
+
+	settle_delay_ck = ctx->core->settle_delay_ck;
+
+	SENINF_BITS(base, DPHY_RX_CLOCK_LANE0_HS_PARAMETER,
+		    RG_DPHY_RX_LC0_HS_SETTLE_PARAMETER,
+		    settle_delay_ck);
+	SENINF_BITS(base, DPHY_RX_CLOCK_LANE1_HS_PARAMETER,
+		    RG_DPHY_RX_LC1_HS_SETTLE_PARAMETER,
+		    settle_delay_ck);
+
+	/*Settle delay by lane*/
+	SENINF_BITS(base, DPHY_RX_DATA_LANE0_HS_PARAMETER,
+		    RG_CDPHY_RX_LD0_TRIO0_HS_PREPARE_PARAMETER, 2);
+	SENINF_BITS(base, DPHY_RX_DATA_LANE1_HS_PARAMETER,
+		    RG_CDPHY_RX_LD1_TRIO1_HS_PREPARE_PARAMETER, 2);
+	SENINF_BITS(base, DPHY_RX_DATA_LANE2_HS_PARAMETER,
+		    RG_CDPHY_RX_LD2_TRIO2_HS_PREPARE_PARAMETER, 2);
+	SENINF_BITS(base, DPHY_RX_DATA_LANE3_HS_PARAMETER,
+		    RG_CDPHY_RX_LD3_TRIO3_HS_PREPARE_PARAMETER, 2);
+
+	hs_trail = ctx->hs_trail_parameter;
+
+	SENINF_BITS(base, DPHY_RX_DATA_LANE0_HS_PARAMETER,
+		    RG_DPHY_RX_LD0_HS_TRAIL_PARAMETER, hs_trail);
+	SENINF_BITS(base, DPHY_RX_DATA_LANE1_HS_PARAMETER,
+		    RG_DPHY_RX_LD1_HS_TRAIL_PARAMETER, hs_trail);
+	SENINF_BITS(base, DPHY_RX_DATA_LANE2_HS_PARAMETER,
+		    RG_DPHY_RX_LD2_HS_TRAIL_PARAMETER, hs_trail);
+	SENINF_BITS(base, DPHY_RX_DATA_LANE3_HS_PARAMETER,
+		    RG_DPHY_RX_LD3_HS_TRAIL_PARAMETER, hs_trail);
+
+	if (!ctx->is_cphy) {
+		/* TODO */
+		bit_per_pixel = 10;
+		if (ctx->customized_pixel_rate != 0) {
+		    data_rate = ctx->customized_pixel_rate * bit_per_pixel;
+		} else {
+			data_rate = ctx->mipi_pixel_rate * bit_per_pixel;
+		}
+		do_div(data_rate, ctx->num_data_lanes);
+		hs_trail_en = data_rate < 1400000000;
+		SENINF_BITS(base, DPHY_RX_DATA_LANE0_HS_PARAMETER,
+			    RG_DPHY_RX_LD0_HS_TRAIL_EN, hs_trail_en);
+		SENINF_BITS(base, DPHY_RX_DATA_LANE1_HS_PARAMETER,
+			    RG_DPHY_RX_LD1_HS_TRAIL_EN, hs_trail_en);
+		SENINF_BITS(base, DPHY_RX_DATA_LANE2_HS_PARAMETER,
+			    RG_DPHY_RX_LD2_HS_TRAIL_EN, hs_trail_en);
+		SENINF_BITS(base, DPHY_RX_DATA_LANE3_HS_PARAMETER,
+			    RG_DPHY_RX_LD3_HS_TRAIL_EN, hs_trail_en);
+	}
+
+	return 0;
+}
+
+static int csirx_cphy_init(struct seninf_ctx *ctx)
+{
+	void *base = ctx->reg_ana_cphy_top[ctx->port];
+
+	SENINF_BITS(base, CPHY_RX_DETECT_CTRL_POST,
+		    RG_CPHY_RX_DATA_VALID_POST_EN, 1);
+
+	return 0;
+}
+
+static int csirx_phy_init(struct seninf_ctx *ctx)
+{
+	/* phyA init */
+	csirx_phyA_init(ctx);
+
+	/* phyD init */
+	csirx_dphy_init(ctx);
+	csirx_cphy_init(ctx);
+
+	return 0;
+}
+
+static int csirx_seninf_csi2_setting(struct seninf_ctx *ctx)
+{
+	void *pSeninf_csi2 = ctx->reg_if_csi2[ctx->seninfIdx];
+	int csi_en;
+
+	SENINF_BITS(pSeninf_csi2, SENINF_CSI2_DBG_CTRL,
+		    RG_CSI2_DBG_PACKET_CNT_EN, 1);
+
+	// lane/trio count
+	SENINF_BITS(pSeninf_csi2, SENINF_CSI2_RESYNC_MERGE_CTRL,
+		    RG_CSI2_RESYNC_CYCLE_CNT_OPT, 1);
+
+	csi_en = (1 << ctx->num_data_lanes) - 1;
+
+	if (!ctx->is_cphy) { //Dphy
+		SENINF_BITS(pSeninf_csi2, SENINF_CSI2_OPT,
+			    RG_CSI2_CPHY_SEL, 0);
+		SENINF_WRITE_REG(pSeninf_csi2, SENINF_CSI2_EN, csi_en);
+		SENINF_BITS(pSeninf_csi2, SENINF_CSI2_HDR_MODE_0,
+			    RG_CSI2_HEADER_MODE, 0);
+		SENINF_BITS(pSeninf_csi2, SENINF_CSI2_HDR_MODE_0,
+			    RG_CSI2_HEADER_LEN, 0);
+	} else { //Cphy
+		u8 map_hdr_len[] = {0, 1, 2, 4, 5};
+
+		SENINF_WRITE_REG(pSeninf_csi2, SENINF_CSI2_EN, csi_en);
+		SENINF_BITS(pSeninf_csi2, SENINF_CSI2_OPT,
+			    RG_CSI2_CPHY_SEL, 1);
+		SENINF_BITS(pSeninf_csi2, SENINF_CSI2_HDR_MODE_0,
+			    RG_CSI2_HEADER_MODE, 2); //cphy
+		SENINF_BITS(pSeninf_csi2, SENINF_CSI2_HDR_MODE_0,
+			    RG_CSI2_HEADER_LEN,
+			    map_hdr_len[ctx->num_data_lanes]);
+	}
+
+	return 0;
+}
+
+static int csirx_seninf_setting(struct seninf_ctx *ctx)
+{
+	void *pSeninf = ctx->reg_if_ctrl[ctx->seninfIdx];
+
+	// enable/disable seninf csi2
+	SENINF_BITS(pSeninf, SENINF_CSI2_CTRL, RG_SENINF_CSI2_EN, 1);
+
+	// enable/disable seninf, enable after csi2, testmdl is done.
+	SENINF_BITS(pSeninf, SENINF_CTRL, SENINF_EN, 1);
+
+	return 0;
+}
+
+static int csirx_seninf_top_setting(struct seninf_ctx *ctx)
+{
+	void *pSeninf_top = ctx->reg_if_top;
+
+	switch (ctx->port) {
+	case CSI_PORT_0:
+		SENINF_BITS(pSeninf_top, SENINF_TOP_PHY_CTRL_CSI0,
+			    RG_PHY_SENINF_MUX0_CPHY_MODE, 0); //4T
+		break;
+	case CSI_PORT_0A:
+	case CSI_PORT_0B:
+		SENINF_BITS(pSeninf_top, SENINF_TOP_PHY_CTRL_CSI0,
+			    RG_PHY_SENINF_MUX0_CPHY_MODE, 2); //2T+2T
+		break;
+	case CSI_PORT_1:
+		SENINF_BITS(pSeninf_top, SENINF_TOP_PHY_CTRL_CSI1,
+			    RG_PHY_SENINF_MUX1_CPHY_MODE, 0); //4T
+		break;
+	case CSI_PORT_1A:
+	case CSI_PORT_1B:
+		SENINF_BITS(pSeninf_top, SENINF_TOP_PHY_CTRL_CSI1,
+			    RG_PHY_SENINF_MUX1_CPHY_MODE, 2); //2T+2T
+		break;
+	case CSI_PORT_2:
+		SENINF_BITS(pSeninf_top, SENINF_TOP_PHY_CTRL_CSI2,
+			    RG_PHY_SENINF_MUX2_CPHY_MODE, 0); //4T
+		break;
+	case CSI_PORT_2A:
+	case CSI_PORT_2B:
+		SENINF_BITS(pSeninf_top, SENINF_TOP_PHY_CTRL_CSI2,
+			    RG_PHY_SENINF_MUX2_CPHY_MODE, 2); //2T+2T
+		break;
+	case CSI_PORT_3:
+		SENINF_BITS(pSeninf_top, SENINF_TOP_PHY_CTRL_CSI3,
+			    RG_PHY_SENINF_MUX3_CPHY_MODE, 0); //4T
+		break;
+	case CSI_PORT_3A:
+	case CSI_PORT_3B:
+		SENINF_BITS(pSeninf_top, SENINF_TOP_PHY_CTRL_CSI3,
+			    RG_PHY_SENINF_MUX3_CPHY_MODE, 2); //2T+2T
+		break;
+	default:
+		break;
+	}
+
+	// port operation mode
+	switch (ctx->port) {
+	case CSI_PORT_0:
+	case CSI_PORT_0A:
+	case CSI_PORT_0B:
+		if (!ctx->is_cphy) { //Dphy
+			SENINF_BITS(pSeninf_top, SENINF_TOP_PHY_CTRL_CSI0,
+				    PHY_SENINF_MUX0_CPHY_EN, 0);
+			SENINF_BITS(pSeninf_top, SENINF_TOP_PHY_CTRL_CSI0,
+				    PHY_SENINF_MUX0_DPHY_EN, 1);
+		} else {
+			SENINF_BITS(pSeninf_top, SENINF_TOP_PHY_CTRL_CSI0,
+				    PHY_SENINF_MUX0_DPHY_EN, 0);
+			SENINF_BITS(pSeninf_top, SENINF_TOP_PHY_CTRL_CSI0,
+				    PHY_SENINF_MUX0_CPHY_EN, 1);
+		}
+		break;
+	case CSI_PORT_1:
+	case CSI_PORT_1A:
+	case CSI_PORT_1B:
+		if (!ctx->is_cphy) { //Dphy
+			SENINF_BITS(pSeninf_top, SENINF_TOP_PHY_CTRL_CSI1,
+				    PHY_SENINF_MUX1_CPHY_EN, 0);
+			SENINF_BITS(pSeninf_top, SENINF_TOP_PHY_CTRL_CSI1,
+				    PHY_SENINF_MUX1_DPHY_EN, 1);
+		} else {
+			SENINF_BITS(pSeninf_top, SENINF_TOP_PHY_CTRL_CSI1,
+				    PHY_SENINF_MUX1_DPHY_EN, 0);
+			SENINF_BITS(pSeninf_top, SENINF_TOP_PHY_CTRL_CSI1,
+				    PHY_SENINF_MUX1_CPHY_EN, 1);
+		}
+		break;
+	case CSI_PORT_2:
+	case CSI_PORT_2A:
+	case CSI_PORT_2B:
+		if (!ctx->is_cphy) { //Dphy
+			SENINF_BITS(pSeninf_top, SENINF_TOP_PHY_CTRL_CSI2,
+				    PHY_SENINF_MUX2_CPHY_EN, 0);
+			SENINF_BITS(pSeninf_top, SENINF_TOP_PHY_CTRL_CSI2,
+				    PHY_SENINF_MUX2_DPHY_EN, 1);
+		} else {
+			SENINF_BITS(pSeninf_top, SENINF_TOP_PHY_CTRL_CSI2,
+				    PHY_SENINF_MUX2_DPHY_EN, 0);
+			SENINF_BITS(pSeninf_top, SENINF_TOP_PHY_CTRL_CSI2,
+				    PHY_SENINF_MUX2_CPHY_EN, 1);
+		}
+		break;
+	case CSI_PORT_3:
+	case CSI_PORT_3A:
+	case CSI_PORT_3B:
+		if (!ctx->is_cphy) { //Dphy
+			SENINF_BITS(pSeninf_top, SENINF_TOP_PHY_CTRL_CSI3,
+				    PHY_SENINF_MUX3_CPHY_EN, 0);
+			SENINF_BITS(pSeninf_top, SENINF_TOP_PHY_CTRL_CSI3,
+				    PHY_SENINF_MUX3_DPHY_EN, 1);
+		} else {
+			SENINF_BITS(pSeninf_top, SENINF_TOP_PHY_CTRL_CSI3,
+				    PHY_SENINF_MUX3_DPHY_EN, 0);
+			SENINF_BITS(pSeninf_top, SENINF_TOP_PHY_CTRL_CSI3,
+				    PHY_SENINF_MUX3_CPHY_EN, 1);
+		}
+		break;
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+static int csirx_phyA_setting(struct seninf_ctx *ctx)
+{
+	void *base, *baseA, *baseB;
+
+	base = ctx->reg_ana_csi_rx[ctx->port];
+	baseA = ctx->reg_ana_csi_rx[ctx->portA];
+	baseB = ctx->reg_ana_csi_rx[ctx->portB];
+
+	if (!ctx->is_cphy) { //Dphy
+		if (ctx->is_4d1c) {
+			SENINF_BITS(baseA, CDPHY_RX_ANA_0,
+				    RG_CSI0_CPHY_EN, 0);
+			SENINF_BITS(baseB, CDPHY_RX_ANA_0,
+				    RG_CSI0_CPHY_EN, 0);
+			// clear clk sel first
+			SENINF_BITS(baseA, CDPHY_RX_ANA_0,
+				    RG_CSI0_DPHY_L0_CKMODE_EN, 0);
+			SENINF_BITS(baseA, CDPHY_RX_ANA_0,
+				    RG_CSI0_DPHY_L1_CKMODE_EN, 0);
+			SENINF_BITS(baseA, CDPHY_RX_ANA_0,
+				    RG_CSI0_DPHY_L2_CKMODE_EN, 0);
+			SENINF_BITS(baseB, CDPHY_RX_ANA_0,
+				    RG_CSI0_DPHY_L0_CKMODE_EN, 0);
+			SENINF_BITS(baseB, CDPHY_RX_ANA_0,
+				    RG_CSI0_DPHY_L1_CKMODE_EN, 0);
+			SENINF_BITS(baseB, CDPHY_RX_ANA_0,
+				    RG_CSI0_DPHY_L2_CKMODE_EN, 0);
+
+			SENINF_BITS(baseA, CDPHY_RX_ANA_0,
+				    RG_CSI0_DPHY_L0_CKSEL, 1);
+			SENINF_BITS(baseA, CDPHY_RX_ANA_0,
+				    RG_CSI0_DPHY_L1_CKSEL, 1);
+			SENINF_BITS(baseA, CDPHY_RX_ANA_0,
+				    RG_CSI0_DPHY_L2_CKSEL, 1);
+			SENINF_BITS(baseB, CDPHY_RX_ANA_0,
+				    RG_CSI0_DPHY_L0_CKSEL, 1);
+			SENINF_BITS(baseB, CDPHY_RX_ANA_0,
+				    RG_CSI0_DPHY_L1_CKSEL, 1);
+			SENINF_BITS(baseB, CDPHY_RX_ANA_0,
+				    RG_CSI0_DPHY_L2_CKSEL, 1);
+
+			SENINF_BITS(baseA, CDPHY_RX_ANA_0,
+				    RG_CSI0_DPHY_L0_CKMODE_EN, 0);
+			SENINF_BITS(baseA, CDPHY_RX_ANA_0,
+				    RG_CSI0_DPHY_L1_CKMODE_EN, 0);
+			SENINF_BITS(baseA, CDPHY_RX_ANA_0,
+				    RG_CSI0_DPHY_L2_CKMODE_EN, 1);
+			SENINF_BITS(baseB, CDPHY_RX_ANA_0,
+				    RG_CSI0_DPHY_L0_CKMODE_EN, 0);
+			SENINF_BITS(baseB, CDPHY_RX_ANA_0,
+				    RG_CSI0_DPHY_L1_CKMODE_EN, 0);
+			SENINF_BITS(baseB, CDPHY_RX_ANA_0,
+				    RG_CSI0_DPHY_L2_CKMODE_EN, 0);
+
+			SENINF_BITS(baseA, CDPHY_RX_ANA_5,
+				    RG_CSI0_CDPHY_EQ_BW, 0x3);
+			SENINF_BITS(baseA, CDPHY_RX_ANA_5,
+				    RG_CSI0_CDPHY_EQ_IS, 0x1);
+			SENINF_BITS(baseA, CDPHY_RX_ANA_5,
+				    RG_CSI0_CDPHY_EQ_LATCH_EN, 0x1);
+			SENINF_BITS(baseA, CDPHY_RX_ANA_5,
+				    RG_CSI0_CDPHY_EQ_DG0_EN, 0x1);
+			SENINF_BITS(baseA, CDPHY_RX_ANA_5,
+				    RG_CSI0_CDPHY_EQ_DG1_EN, 0x1);
+			SENINF_BITS(baseA, CDPHY_RX_ANA_5,
+				    RG_CSI0_CDPHY_EQ_SR0, 0x1);
+			SENINF_BITS(baseA, CDPHY_RX_ANA_5,
+				    RG_CSI0_CDPHY_EQ_SR1, 0x0);
+
+			SENINF_BITS(baseB, CDPHY_RX_ANA_5,
+				    RG_CSI0_CDPHY_EQ_BW, 0x3);
+			SENINF_BITS(baseB, CDPHY_RX_ANA_5,
+				    RG_CSI0_CDPHY_EQ_IS, 0x1);
+			SENINF_BITS(baseB, CDPHY_RX_ANA_5,
+				    RG_CSI0_CDPHY_EQ_LATCH_EN, 0x1);
+			SENINF_BITS(baseB, CDPHY_RX_ANA_5,
+				    RG_CSI0_CDPHY_EQ_DG0_EN, 0x1);
+			SENINF_BITS(baseB, CDPHY_RX_ANA_5,
+				    RG_CSI0_CDPHY_EQ_DG1_EN, 0x1);
+			SENINF_BITS(baseB, CDPHY_RX_ANA_5,
+				    RG_CSI0_CDPHY_EQ_SR0, 0x1);
+			SENINF_BITS(baseB, CDPHY_RX_ANA_5,
+				    RG_CSI0_CDPHY_EQ_SR1, 0x0);
+		} else {
+			SENINF_BITS(base, CDPHY_RX_ANA_0,
+				    RG_CSI0_CPHY_EN, 0);
+			// clear clk sel first
+			SENINF_BITS(base, CDPHY_RX_ANA_0,
+				    RG_CSI0_DPHY_L0_CKMODE_EN, 0);
+			SENINF_BITS(base, CDPHY_RX_ANA_0,
+				    RG_CSI0_DPHY_L1_CKMODE_EN, 0);
+			SENINF_BITS(base, CDPHY_RX_ANA_0,
+				    RG_CSI0_DPHY_L2_CKMODE_EN, 0);
+
+			SENINF_BITS(base, CDPHY_RX_ANA_0,
+				    RG_CSI0_DPHY_L0_CKSEL, 0);
+			SENINF_BITS(base, CDPHY_RX_ANA_0,
+				    RG_CSI0_DPHY_L1_CKSEL, 0);
+			SENINF_BITS(base, CDPHY_RX_ANA_0,
+				    RG_CSI0_DPHY_L2_CKSEL, 0);
+
+			SENINF_BITS(base, CDPHY_RX_ANA_0,
+				    RG_CSI0_DPHY_L0_CKMODE_EN, 0);
+			SENINF_BITS(base, CDPHY_RX_ANA_0,
+				    RG_CSI0_DPHY_L1_CKMODE_EN, 1);
+			SENINF_BITS(base, CDPHY_RX_ANA_0,
+				    RG_CSI0_DPHY_L2_CKMODE_EN, 0);
+
+			SENINF_BITS(base, CDPHY_RX_ANA_5,
+				    RG_CSI0_CDPHY_EQ_BW, 0x3);
+			SENINF_BITS(base, CDPHY_RX_ANA_5,
+				    RG_CSI0_CDPHY_EQ_IS, 0x1);
+			SENINF_BITS(base, CDPHY_RX_ANA_5,
+				    RG_CSI0_CDPHY_EQ_LATCH_EN, 0x1);
+			SENINF_BITS(base, CDPHY_RX_ANA_5,
+				    RG_CSI0_CDPHY_EQ_DG0_EN, 0x1);
+			SENINF_BITS(base, CDPHY_RX_ANA_5,
+				    RG_CSI0_CDPHY_EQ_DG1_EN, 0x1);
+			SENINF_BITS(base, CDPHY_RX_ANA_5,
+				    RG_CSI0_CDPHY_EQ_SR0, 0x1);
+			SENINF_BITS(base, CDPHY_RX_ANA_5,
+				    RG_CSI0_CDPHY_EQ_SR1, 0x0);
+		}
+	} else { //Cphy
+		if (ctx->is_4d1c) {
+			SENINF_BITS(baseA, CDPHY_RX_ANA_0,
+				    RG_CSI0_CPHY_EN, 1);
+			SENINF_BITS(baseB, CDPHY_RX_ANA_0,
+				    RG_CSI0_CPHY_EN, 1);
+
+			SENINF_BITS(baseA, CDPHY_RX_ANA_5,
+				    RG_CSI0_CDPHY_EQ_BW, 0x3);
+			SENINF_BITS(baseA, CDPHY_RX_ANA_5,
+				    RG_CSI0_CDPHY_EQ_IS, 0x1);
+			SENINF_BITS(baseA, CDPHY_RX_ANA_5,
+				    RG_CSI0_CDPHY_EQ_LATCH_EN, 0x1);
+			SENINF_BITS(baseA, CDPHY_RX_ANA_5,
+				    RG_CSI0_CDPHY_EQ_DG0_EN, 0x1);
+			SENINF_BITS(baseA, CDPHY_RX_ANA_5,
+				    RG_CSI0_CDPHY_EQ_DG1_EN, 0x0);
+			SENINF_BITS(baseA, CDPHY_RX_ANA_5,
+				    RG_CSI0_CDPHY_EQ_SR0, 0x3);
+			SENINF_BITS(baseA, CDPHY_RX_ANA_5,
+				    RG_CSI0_CDPHY_EQ_SR1, 0x0);
+
+			SENINF_BITS(baseA, CDPHY_RX_ANA_5,
+				    RG_CSI0_CDPHY_EQ_BW, 0x3);
+			SENINF_BITS(baseA, CDPHY_RX_ANA_5,
+				    RG_CSI0_CDPHY_EQ_IS, 0x1);
+			SENINF_BITS(baseA, CDPHY_RX_ANA_5,
+				    RG_CSI0_CDPHY_EQ_LATCH_EN, 0x1);
+			SENINF_BITS(baseA, CDPHY_RX_ANA_5,
+				    RG_CSI0_CDPHY_EQ_DG0_EN, 0x1);
+			SENINF_BITS(baseA, CDPHY_RX_ANA_5,
+				    RG_CSI0_CDPHY_EQ_DG1_EN, 0x0);
+			SENINF_BITS(baseA, CDPHY_RX_ANA_5,
+				    RG_CSI0_CDPHY_EQ_SR0, 0x3);
+			SENINF_BITS(baseA, CDPHY_RX_ANA_5,
+				    RG_CSI0_CDPHY_EQ_SR1, 0x0);
+		} else {
+			SENINF_BITS(base, CDPHY_RX_ANA_0,
+				    RG_CSI0_CPHY_EN, 1);
+			SENINF_BITS(base, CDPHY_RX_ANA_5,
+				    RG_CSI0_CDPHY_EQ_BW, 0x3);
+			SENINF_BITS(base, CDPHY_RX_ANA_5,
+				    RG_CSI0_CDPHY_EQ_IS, 0x1);
+			SENINF_BITS(base, CDPHY_RX_ANA_5,
+				    RG_CSI0_CDPHY_EQ_LATCH_EN, 0x1);
+			SENINF_BITS(base, CDPHY_RX_ANA_5,
+				    RG_CSI0_CDPHY_EQ_DG0_EN, 0x1);
+			SENINF_BITS(base, CDPHY_RX_ANA_5,
+				    RG_CSI0_CDPHY_EQ_DG1_EN, 0x0);
+			SENINF_BITS(base, CDPHY_RX_ANA_5,
+				    RG_CSI0_CDPHY_EQ_SR0, 0x3);
+			SENINF_BITS(base, CDPHY_RX_ANA_5,
+				    RG_CSI0_CDPHY_EQ_SR1, 0x0);
+		}
+	}
+
+	/* phyA power on */
+
+	if (ctx->is_4d1c) {
+		csirx_phyA_power_on(ctx, ctx->portA, 1);
+		csirx_phyA_power_on(ctx, ctx->portB, 1);
+	} else {
+		csirx_phyA_power_on(ctx, ctx->port, 1);
+	}
+
+	return 0;
+}
+
+static int csirx_dphy_setting(struct seninf_ctx *ctx)
+{
+	void *base = ctx->reg_ana_dphy_top[ctx->port];
+
+	if (ctx->is_4d1c) {
+		SENINF_BITS(base, DPHY_RX_LANE_SELECT, RG_DPHY_RX_LD3_SEL, 4);
+		SENINF_BITS(base, DPHY_RX_LANE_SELECT, RG_DPHY_RX_LD2_SEL, 0);
+		SENINF_BITS(base, DPHY_RX_LANE_SELECT, RG_DPHY_RX_LD1_SEL, 3);
+		SENINF_BITS(base, DPHY_RX_LANE_SELECT, RG_DPHY_RX_LD0_SEL, 1);
+		SENINF_BITS(base, DPHY_RX_LANE_SELECT, RG_DPHY_RX_LC0_SEL, 2);
+
+		SENINF_BITS(base, DPHY_RX_LANE_EN, DPHY_RX_LD0_EN, 1);
+		SENINF_BITS(base, DPHY_RX_LANE_EN, DPHY_RX_LD1_EN, 1);
+		SENINF_BITS(base, DPHY_RX_LANE_EN, DPHY_RX_LD2_EN, 1);
+		SENINF_BITS(base, DPHY_RX_LANE_EN, DPHY_RX_LD3_EN, 1);
+		SENINF_BITS(base, DPHY_RX_LANE_EN, DPHY_RX_LC0_EN, 1);
+		SENINF_BITS(base, DPHY_RX_LANE_EN, DPHY_RX_LC1_EN, 0);
+	} else {
+		SENINF_BITS(base, DPHY_RX_LANE_SELECT, RG_DPHY_RX_LD3_SEL, 5);
+		SENINF_BITS(base, DPHY_RX_LANE_SELECT, RG_DPHY_RX_LD2_SEL, 3);
+		SENINF_BITS(base, DPHY_RX_LANE_SELECT, RG_DPHY_RX_LD1_SEL, 2);
+		SENINF_BITS(base, DPHY_RX_LANE_SELECT, RG_DPHY_RX_LD0_SEL, 0);
+		SENINF_BITS(base, DPHY_RX_LANE_SELECT, RG_DPHY_RX_LC1_SEL, 4);
+		SENINF_BITS(base, DPHY_RX_LANE_SELECT, RG_DPHY_RX_LC0_SEL, 1);
+
+		SENINF_BITS(base, DPHY_RX_LANE_EN, DPHY_RX_LD0_EN, 1);
+		SENINF_BITS(base, DPHY_RX_LANE_EN, DPHY_RX_LD1_EN, 1);
+		SENINF_BITS(base, DPHY_RX_LANE_EN, DPHY_RX_LD2_EN, 1);
+		SENINF_BITS(base, DPHY_RX_LANE_EN, DPHY_RX_LD3_EN, 1);
+		SENINF_BITS(base, DPHY_RX_LANE_EN, DPHY_RX_LC0_EN, 1);
+		SENINF_BITS(base, DPHY_RX_LANE_EN, DPHY_RX_LC1_EN, 1);
+	}
+
+	SENINF_BITS(base, DPHY_RX_LANE_SELECT, DPHY_RX_CK_DATA_MUX_EN, 1);
+
+	return 0;
+}
+
+static int csirx_cphy_setting(struct seninf_ctx *ctx)
+{
+	void *base = ctx->reg_ana_cphy_top[ctx->port];
+
+	switch (ctx->port) {
+	case CSI_PORT_0:
+	case CSI_PORT_1:
+	case CSI_PORT_2:
+	case CSI_PORT_3:
+	case CSI_PORT_0A:
+	case CSI_PORT_1A:
+	case CSI_PORT_2A:
+	case CSI_PORT_3A:
+		if (ctx->num_data_lanes == 3) {
+			SENINF_BITS(base, CPHY_RX_CTRL, CPHY_RX_TR0_LPRX_EN, 1);
+			SENINF_BITS(base, CPHY_RX_CTRL, CPHY_RX_TR1_LPRX_EN, 1);
+			SENINF_BITS(base, CPHY_RX_CTRL, CPHY_RX_TR2_LPRX_EN, 1);
+			SENINF_BITS(base, CPHY_RX_CTRL, CPHY_RX_TR3_LPRX_EN, 0);
+		} else if (ctx->num_data_lanes == 2) {
+			SENINF_BITS(base, CPHY_RX_CTRL, CPHY_RX_TR0_LPRX_EN, 1);
+			SENINF_BITS(base, CPHY_RX_CTRL, CPHY_RX_TR1_LPRX_EN, 1);
+		} else {
+			SENINF_BITS(base, CPHY_RX_CTRL, CPHY_RX_TR0_LPRX_EN, 1);
+		}
+		break;
+	case CSI_PORT_0B:
+	case CSI_PORT_1B:
+	case CSI_PORT_2B:
+	case CSI_PORT_3B:
+		if (ctx->num_data_lanes == 2) {
+			SENINF_BITS(base, CPHY_RX_CTRL, CPHY_RX_TR2_LPRX_EN, 1);
+			SENINF_BITS(base, CPHY_RX_CTRL, CPHY_RX_TR3_LPRX_EN, 1);
+		} else
+			SENINF_BITS(base, CPHY_RX_CTRL, CPHY_RX_TR2_LPRX_EN, 1);
+		break;
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+static int csirx_phy_setting(struct seninf_ctx *ctx)
+{
+	/* phyA */
+	csirx_phyA_setting(ctx);
+
+	if (!ctx->is_cphy)
+		csirx_dphy_setting(ctx);
+	else
+		csirx_cphy_setting(ctx);
+
+	return 0;
+}
+
+static int mtk_cam_seninf_set_csi_mipi(struct seninf_ctx *ctx)
+{
+	csirx_phy_init(ctx);
+
+	/* seninf csi2 */
+	csirx_seninf_csi2_setting(ctx);
+
+	/* seninf */
+	csirx_seninf_setting(ctx);
+
+	/* seninf top */
+	csirx_seninf_top_setting(ctx);
+
+	/* phy */
+	csirx_phy_setting(ctx);
+
+	return 0;
+}
+
+static int mtk_cam_seninf_poweroff(struct seninf_ctx *ctx)
+{
+	void *pSeninf_csi2;
+
+	pSeninf_csi2 = ctx->reg_if_csi2[ctx->seninfIdx];
+
+	SENINF_WRITE_REG(pSeninf_csi2, SENINF_CSI2_EN, 0x0);
+
+	if (ctx->is_4d1c) {
+		csirx_phyA_power_on(ctx, ctx->portA, 0);
+		csirx_phyA_power_on(ctx, ctx->portB, 0);
+	} else {
+		csirx_phyA_power_on(ctx, ctx->port, 0);
+	}
+
+	return 0;
+}
+
+static int mtk_cam_seninf_reset(struct seninf_ctx *ctx, int seninfIdx)
+{
+	int i;
+	void *pSeninf_mux;
+	void *pSeninf = ctx->reg_if_ctrl[seninfIdx];
+
+	SENINF_BITS(pSeninf, SENINF_CSI2_CTRL, SENINF_CSI2_SW_RST, 1);
+	udelay(1);
+	SENINF_BITS(pSeninf, SENINF_CSI2_CTRL, SENINF_CSI2_SW_RST, 0);
+
+	dev_dbg(ctx->dev, "reset seninf %d\n", seninfIdx);
+
+	for (i = SENINF_MUX1; i < _seninf_ops->mux_num; i++)
+		if (mtk_cam_seninf_get_top_mux_ctrl(ctx, i) == seninfIdx &&
+		    mtk_cam_seninf_is_mux_used(ctx, i)) {
+			pSeninf_mux = ctx->reg_if_mux[i];
+			SENINF_BITS(pSeninf_mux, SENINF_MUX_CTRL_0,
+				    SENINF_MUX_SW_RST, 1);
+			udelay(1);
+			SENINF_BITS(pSeninf_mux, SENINF_MUX_CTRL_0,
+				    SENINF_MUX_SW_RST, 0);
+			dev_dbg(ctx->dev, "reset mux %d\n", i);
+		}
+
+	return 0;
+}
+
+static int mtk_cam_seninf_set_idle(struct seninf_ctx *ctx)
+{
+	int i;
+	struct seninf_vcinfo *vcinfo = &ctx->vcinfo;
+	struct seninf_vc *vc;
+
+	for (i = 0; i < vcinfo->cnt; i++) {
+		vc = &vcinfo->vc[i];
+		if (vc->enable) {
+			mtk_cam_seninf_disable_mux(ctx, vc->mux);
+			mtk_cam_seninf_disable_cammux(ctx, vc->cam);
+			ctx->pad2cam[vc->out_pad] = 0xff;
+		}
+	}
+
+	return 0;
+}
+
+static int mtk_cam_seninf_get_mux_meter(struct seninf_ctx *ctx, int mux,
+				 struct mtk_cam_seninf_mux_meter *meter)
+{
+	void *pSeninf_mux;
+	s64 hv, hb, vv, vb, w, h, mipi_pixel_rate;
+	s64 vb_in_us, hb_in_us, line_time_in_us;
+	u32 res;
+
+	pSeninf_mux = ctx->reg_if_mux[mux];
+
+	SENINF_BITS(pSeninf_mux, SENINF_MUX_FRAME_SIZE_MON_CTRL,
+		    RG_SENINF_MUX_FRAME_SIZE_MON_EN, 1);
+
+	hv = SENINF_READ_REG(pSeninf_mux,
+			     SENINF_MUX_FRAME_SIZE_MON_H_VALID);
+	hb = SENINF_READ_REG(pSeninf_mux,
+			     SENINF_MUX_FRAME_SIZE_MON_H_BLANK);
+	vv = SENINF_READ_REG(pSeninf_mux,
+			     SENINF_MUX_FRAME_SIZE_MON_V_VALID);
+	vb = SENINF_READ_REG(pSeninf_mux,
+			     SENINF_MUX_FRAME_SIZE_MON_V_BLANK);
+	res = SENINF_READ_REG(pSeninf_mux,
+			      SENINF_MUX_SIZE);
+
+	w = res & 0xffff;
+	h = res >> 16;
+
+	if (ctx->fps_n && ctx->fps_d) {
+		mipi_pixel_rate = w * ctx->fps_n * (vv + vb);
+		do_div(mipi_pixel_rate, ctx->fps_d);
+		do_div(mipi_pixel_rate, hv);
+
+		vb_in_us = vb * ctx->fps_d * 1000000;
+		do_div(vb_in_us, vv + vb);
+		do_div(vb_in_us, ctx->fps_n);
+
+		hb_in_us = hb * ctx->fps_d * 1000000;
+		do_div(hb_in_us, vv + vb);
+		do_div(hb_in_us, ctx->fps_n);
+
+		line_time_in_us = (hv + hb) * ctx->fps_d * 1000000;
+		do_div(line_time_in_us, vv + vb);
+		do_div(line_time_in_us, ctx->fps_n);
+	} else {
+		mipi_pixel_rate = -1;
+		vb_in_us = -1;
+		hb_in_us = -1;
+		line_time_in_us = -1;
+	}
+
+	meter->width = w;
+	meter->height = h;
+
+	meter->h_valid = hv;
+	meter->h_blank = hb;
+	meter->v_valid = vv;
+	meter->v_blank = vb;
+
+	meter->mipi_pixel_rate = mipi_pixel_rate;
+	meter->vb_in_us = vb_in_us;
+	meter->hb_in_us = hb_in_us;
+	meter->line_time_in_us = line_time_in_us;
+
+	return 0;
+}
+
+static ssize_t mtk_cam_seninf_show_status(struct device *dev,
+				   struct device_attribute *attr,
+		char *buf)
+{
+	int i, len;
+	struct seninf_core *core;
+	struct seninf_ctx *ctx;
+	struct seninf_vc *vc;
+	struct media_link *link;
+	struct media_pad *pad;
+	struct mtk_cam_seninf_mux_meter meter;
+	void *csi2, *pmux;
+#ifdef ISP7_1
+	void *rx, *pcammux;
+#endif
+	core = dev_get_drvdata(dev);
+	len = 0;
+
+	mutex_lock(&core->mutex);
+
+	list_for_each_entry(ctx, &core->list, list) {
+		SHOW(buf, len,
+		     "\n[%s] port %d intf %d test %d cphy %d lanes %d\n",
+			ctx->subdev.name,
+			ctx->port,
+			ctx->seninfIdx,
+			ctx->is_test_model,
+			ctx->is_cphy,
+			ctx->num_data_lanes);
+
+		pad = &ctx->pads[PAD_SINK];
+		list_for_each_entry(link, &pad->entity->links, list) {
+			if (link->sink == pad) {
+				SHOW(buf, len, "source %s flags 0x%lx\n",
+				     link->source->entity->name,
+					link->flags);
+			}
+		}
+
+		if (!ctx->streaming)
+			continue;
+
+		csi2 = ctx->reg_if_csi2[ctx->seninfIdx];
+#ifdef ISP7_1
+		rx = ctx->reg_ana_dphy_top[ctx->port];
+#endif
+		SHOW(buf, len, "csi2 irq_stat 0x%08x\n",
+		     SENINF_READ_REG(csi2, SENINF_CSI2_IRQ_STATUS));
+		SHOW(buf, len, "csi2 line_frame_num 0x%08x\n",
+		     SENINF_READ_REG(csi2, SENINF_CSI2_LINE_FRAME_NUM));
+		SHOW(buf, len, "csi2 packet_status 0x%08x\n",
+		     SENINF_READ_REG(csi2, SENINF_CSI2_PACKET_STATUS));
+		SHOW(buf, len, "csi2 packet_cnt_status 0x%08x\n",
+		     SENINF_READ_REG(csi2, SENINF_CSI2_PACKET_CNT_STATUS));
+#ifdef ISP7_1
+		SHOW(buf, len, "rx-ana settle ck 0x%02x dt 0x%02x\n",
+		     SENINF_READ_BITS(rx, DPHY_RX_CLOCK_LANE0_HS_PARAMETER,
+				      RG_DPHY_RX_LC0_HS_SETTLE_PARAMETER),
+		     SENINF_READ_BITS(rx, DPHY_RX_DATA_LANE0_HS_PARAMETER,
+				      RG_CDPHY_RX_LD0_TRIO0_HS_SETTLE_PARAMETER));
+		SHOW(buf, len, "rx-ana trail en %u param 0x%02x\n",
+		     SENINF_READ_BITS(rx, DPHY_RX_DATA_LANE0_HS_PARAMETER,
+				      RG_DPHY_RX_LD0_HS_TRAIL_EN),
+		     SENINF_READ_BITS(rx, DPHY_RX_DATA_LANE0_HS_PARAMETER,
+				      RG_DPHY_RX_LD0_HS_TRAIL_PARAMETER));
+
+		SHOW(buf, len, "data_not_enough_cnt : <%d>",
+			ctx->data_not_enough_cnt);
+		SHOW(buf, len, "err_lane_resync_cnt : <%d>",
+			ctx->err_lane_resync_cnt);
+		SHOW(buf, len, "crc_err_cnt : <%d>",
+			ctx->crc_err_flag);
+		SHOW(buf, len, "ecc_err_double_cnt : <%d>",
+			ctx->ecc_err_double_cnt);
+		SHOW(buf, len, "ecc_err_corrected_cnt : <%d>\n",
+			ctx->ecc_err_corrected_cnt);
+#endif
+		for (i = 0; i < ctx->vcinfo.cnt; i++) {
+			vc = &ctx->vcinfo.vc[i];
+			pmux = ctx->reg_if_mux[vc->mux];
+#ifdef ISP7_1
+			pcammux = ctx->reg_if_cam_mux;
+#endif
+			SHOW(buf, len,
+			     "[%d] vc 0x%x dt 0x%x mux %d cam %d\n",
+				i, vc->vc, vc->dt, vc->mux, vc->cam);
+			SHOW(buf, len,
+			     "\tmux[%d] en %d src %d irq_stat 0x%x\n",
+				vc->mux,
+				mtk_cam_seninf_is_mux_used(ctx, vc->mux),
+				mtk_cam_seninf_get_top_mux_ctrl(ctx, vc->mux),
+				SENINF_READ_REG(pmux, SENINF_MUX_IRQ_STATUS));
+#ifdef ISP7_1
+			SHOW(buf, len, "\t\tfifo_overrun_cnt : <%d>\n",
+				ctx->fifo_overrun_cnt);
+			SHOW(buf, len,
+			     "\tcam[%d] en %d src %d exp 0x%x res 0x%x irq_stat 0x%x\n",
+				vc->cam,
+				mtk_cam_seninf_is_cammux_used(ctx, vc->cam),
+				mtk_cam_seninf_get_cammux_ctrl(ctx, vc->cam),
+				mtk_cam_seninf_get_cammux_exp(ctx, vc->cam),
+				mtk_cam_seninf_get_cammux_res(ctx, vc->cam),
+				SENINF_READ_REG(pcammux, SENINF_CAM_MUX_IRQ_STATUS));
+			SHOW(buf, len, "\t\tsize_err_cnt : <%d>\n",
+				ctx->size_err_cnt);
+#else
+			SHOW(buf, len,
+			     "\tcam[%d] en %d src %d exp 0x%x res 0x%x\n",
+				vc->cam,
+				mtk_cam_seninf_is_cammux_used(ctx, vc->cam),
+				mtk_cam_seninf_get_cammux_ctrl(ctx, vc->cam),
+				mtk_cam_seninf_get_cammux_exp(ctx, vc->cam),
+				mtk_cam_seninf_get_cammux_res(ctx, vc->cam));
+#endif
+			if (vc->feature == VC_RAW_DATA ||
+				vc->feature == VC_STAGGER_NE ||
+				vc->feature == VC_STAGGER_ME ||
+				vc->feature == VC_STAGGER_SE) {
+				mtk_cam_seninf_get_mux_meter(ctx,
+							     vc->mux, &meter);
+				SHOW(buf, len, "\t--- mux meter ---\n");
+				SHOW(buf, len, "\twidth %d height %d\n",
+				     meter.width, meter.height);
+				SHOW(buf, len, "\th_valid %d, h_blank %d\n",
+				     meter.h_valid, meter.h_blank);
+				SHOW(buf, len, "\tv_valid %d, v_blank %d\n",
+				     meter.v_valid, meter.v_blank);
+				SHOW(buf, len, "\tmipi_pixel_rate %lld\n",
+				     meter.mipi_pixel_rate);
+				SHOW(buf, len, "\tv_blank %lld us\n",
+				     meter.vb_in_us);
+				SHOW(buf, len, "\th_blank %lld us\n",
+				     meter.hb_in_us);
+				SHOW(buf, len, "\tline_time %lld us\n",
+				     meter.line_time_in_us);
+			}
+		}
+	}
+
+	mutex_unlock(&core->mutex);
+
+	return len;
+}
+
+#define SENINF_DRV_DEBUG_MAX_DELAY 400
+
+#define CLEAR_MATCHED_CAM_MUX_IRQ(_cam_mux, used_cammux, enabled) do { \
+	if ((used_cammux == _cam_mux) && (enabled & (1<<_cam_mux))) { \
+		dev_dbg(ctx->dev, \
+			"before clear cam mux%u recSize = 0x%x, irq = 0x%x", \
+			_cam_mux, \
+			SENINF_READ_REG(ctx->reg_if_cam_mux, \
+					SENINF_CAM_MUX##_cam_mux##_CHK_RES), \
+			SENINF_READ_REG(ctx->reg_if_cam_mux, \
+					SENINF_CAM_MUX_IRQ_STATUS)); \
+		SENINF_WRITE_REG(ctx->reg_if_cam_mux, \
+				 SENINF_CAM_MUX_IRQ_STATUS, \
+				 3 << (SENINF_CAM_MUX##_cam_mux * 2)); \
+	} \
+} while (0)
+
+#define CHECK_MATCHED_CAM_MUX(_cam_mux, used_cammux, enabled, irq_status) do { \
+	if ((used_cammux == _cam_mux) && (enabled & (1<<_cam_mux))) { \
+		int recSize = SENINF_READ_REG(ctx->reg_if_cam_mux, \
+					SENINF_CAM_MUX##_cam_mux##_CHK_RES); \
+		int expSize = SENINF_READ_REG(ctx->reg_if_cam_mux, \
+					SENINF_CAM_MUX##_cam_mux##_CHK_CTL_1); \
+		if (recSize != expSize) { \
+			dev_dbg(ctx->dev, \
+				"cam mux%u size mismatch!, recSize = 0x%x, expSize = 0x%x", \
+				_cam_mux, recSize, expSize); \
+			ret = -3; \
+		} \
+		if ((irq_status & \
+		     (3 << (SENINF_CAM_MUX##_cam_mux * 2))) != 0) { \
+			dev_dbg(ctx->dev, \
+				"cam mux%u size mismatch!, irq = 0x%x", \
+				_cam_mux, irq_status); \
+			ret = -3; \
+		} \
+	} \
+} while (0)
+
+static int mtk_cam_seninf_debug(struct seninf_ctx *ctx)
+{
+	void *base_ana, *base_cphy, *base_dphy, *base_csi, *base_mux;
+	unsigned int temp = 0;
+	int pkg_cnt_changed = 0;
+	unsigned int mipi_packet_cnt = 0;
+	unsigned int tmp_mipi_packet_cnt = 0;
+	unsigned long total_delay = 0;
+	int irq_status = 0;
+	int enabled = 0;
+	int ret = 0;
+	int j;
+	unsigned long debug_ft = 33;//FIXME
+	unsigned long debug_vb = 1;//FIXME
+
+	for (j = CSI_PORT_0A; j < CSI_PORT_3A; j++) {
+		base_ana = ctx->reg_ana_csi_rx[j];
+		dev_dbg(ctx->dev,
+			"MipiRx_ANA%d: CDPHY_RX_ANA_0(0x%x) ANA_2(0x%x) ANA_4(0x%x) ANA_5(0x%x) ANA_8(0x%x)\n",
+			j - 3,
+			SENINF_READ_REG(base_ana, CDPHY_RX_ANA_0),
+			SENINF_READ_REG(base_ana, CDPHY_RX_ANA_2),
+			SENINF_READ_REG(base_ana, CDPHY_RX_ANA_4),
+			SENINF_READ_REG(base_ana, CDPHY_RX_ANA_5),
+			SENINF_READ_REG(base_ana, CDPHY_RX_ANA_8));
+		dev_dbg(ctx->dev,
+			"MipiRx_ANA%d: CDPHY_RX_ANA_AD_0(0x%x) AD_HS_0(0x%x) AD_HS_1(0x%x)\n",
+			j - 3,
+			SENINF_READ_REG(base_ana, CDPHY_RX_ANA_AD_0),
+			SENINF_READ_REG(base_ana, CDPHY_RX_ANA_AD_HS_0),
+			SENINF_READ_REG(base_ana, CDPHY_RX_ANA_AD_HS_1));
+	}
+
+	for (j = CSI_PORT_0; j < CSI_PORT_3; j++) {
+		base_cphy = ctx->reg_ana_cphy_top[j];
+		base_dphy = ctx->reg_ana_dphy_top[j];
+
+		dev_dbg(ctx->dev,
+			"Csi%d_Dphy_Top: LANE_EN(0x%x) LANE_SELECT(0x%x) DATA_LANE0_HS(0x%x) DATA_LANE1_HS(0x%x) DATA_LANE2_HS(0x%x) DATA_LANE3_HS(0x%x)\n",
+			j,
+			SENINF_READ_REG(base_dphy, DPHY_RX_LANE_EN),
+			SENINF_READ_REG(base_dphy, DPHY_RX_LANE_SELECT),
+			SENINF_READ_REG(base_dphy,
+					DPHY_RX_DATA_LANE0_HS_PARAMETER),
+			SENINF_READ_REG(base_dphy,
+					DPHY_RX_DATA_LANE1_HS_PARAMETER),
+			SENINF_READ_REG(base_dphy,
+					DPHY_RX_DATA_LANE2_HS_PARAMETER),
+			SENINF_READ_REG(base_dphy,
+					DPHY_RX_DATA_LANE3_HS_PARAMETER));
+
+		dev_dbg(ctx->dev,
+			"Csi%d_Cphy_Top: CPHY_RX_CTRL(0x%x) CPHY_RX_DETECT_CTRL_POST(0x%x)\n",
+			j,
+			SENINF_READ_REG(base_cphy, CPHY_RX_CTRL),
+			SENINF_READ_REG(base_cphy, CPHY_RX_DETECT_CTRL_POST));
+	}
+
+	dev_dbg(ctx->dev,
+		"SENINF_TOP_MUX_CTRL_0(0x%x) SENINF_TOP_MUX_CTRL_1(0x%x)\n",
+		SENINF_READ_REG(ctx->reg_if_top, SENINF_TOP_MUX_CTRL_0),
+		SENINF_READ_REG(ctx->reg_if_top, SENINF_TOP_MUX_CTRL_1));
+
+	dev_dbg(ctx->dev,
+		"SENINF_CAM_MUX_CTRL_0(0x%x) SENINF_CAM_MUX_CTRL_1(0x%x) SENINF_CAM_MUX_CTRL_2(0x%x)\n",
+		SENINF_READ_REG(ctx->reg_if_cam_mux, SENINF_CAM_MUX_CTRL_0),
+		SENINF_READ_REG(ctx->reg_if_cam_mux, SENINF_CAM_MUX_CTRL_1),
+		SENINF_READ_REG(ctx->reg_if_cam_mux, SENINF_CAM_MUX_CTRL_2));
+
+	enabled = SENINF_READ_REG(ctx->reg_if_cam_mux, SENINF_CAM_MUX_EN);
+	/* clear cam mux irq */
+	for (j = 0; j < ctx->vcinfo.cnt; j++) {
+		if (ctx->vcinfo.vc[j].enable) {
+			CLEAR_MATCHED_CAM_MUX_IRQ(0, ctx->vcinfo.vc[j].cam,
+						  enabled);
+			CLEAR_MATCHED_CAM_MUX_IRQ(1, ctx->vcinfo.vc[j].cam,
+						  enabled);
+			CLEAR_MATCHED_CAM_MUX_IRQ(2, ctx->vcinfo.vc[j].cam,
+						  enabled);
+			CLEAR_MATCHED_CAM_MUX_IRQ(3, ctx->vcinfo.vc[j].cam,
+						  enabled);
+			CLEAR_MATCHED_CAM_MUX_IRQ(4, ctx->vcinfo.vc[j].cam,
+						  enabled);
+			CLEAR_MATCHED_CAM_MUX_IRQ(5, ctx->vcinfo.vc[j].cam,
+						  enabled);
+			CLEAR_MATCHED_CAM_MUX_IRQ(6, ctx->vcinfo.vc[j].cam,
+						  enabled);
+			CLEAR_MATCHED_CAM_MUX_IRQ(7, ctx->vcinfo.vc[j].cam,
+						  enabled);
+			CLEAR_MATCHED_CAM_MUX_IRQ(8, ctx->vcinfo.vc[j].cam,
+						  enabled);
+			CLEAR_MATCHED_CAM_MUX_IRQ(9, ctx->vcinfo.vc[j].cam,
+						  enabled);
+			CLEAR_MATCHED_CAM_MUX_IRQ(10, ctx->vcinfo.vc[j].cam,
+						  enabled);
+			CLEAR_MATCHED_CAM_MUX_IRQ(11, ctx->vcinfo.vc[j].cam,
+						  enabled);
+			CLEAR_MATCHED_CAM_MUX_IRQ(12, ctx->vcinfo.vc[j].cam,
+						  enabled);
+		}
+	}
+
+	/* Seninf_csi status IRQ */
+	for (j = SENINF_1; j < _seninf_ops->seninf_num; j++) {
+		base_csi = ctx->reg_if_csi2[j];
+		temp = SENINF_READ_REG(base_csi, SENINF_CSI2_IRQ_STATUS);
+		if (temp & ~(0x324)) {
+			SENINF_WRITE_REG(base_csi, SENINF_CSI2_IRQ_STATUS,
+					 0xffffffff);
+		}
+		dev_dbg(ctx->dev,
+			"SENINF%d_CSI2_EN(0x%x) SENINF_CSI2_OPT(0x%x) SENINF_CSI2_IRQ_STATUS(0x%x)\n",
+			j,
+			SENINF_READ_REG(base_csi, SENINF_CSI2_EN),
+			SENINF_READ_REG(base_csi, SENINF_CSI2_OPT),
+			temp);
+	}
+
+	/* Seninf_csi packet count */
+	pkg_cnt_changed = 0;
+	base_csi = ctx->reg_if_csi2[(uint32_t)ctx->seninfIdx];
+	if (SENINF_READ_REG(base_csi, SENINF_CSI2_EN) & 0x1) {
+		SENINF_BITS(base_csi, SENINF_CSI2_DBG_CTRL,
+			    RG_CSI2_DBG_PACKET_CNT_EN, 1);
+		mipi_packet_cnt = SENINF_READ_REG(base_csi,
+					SENINF_CSI2_PACKET_CNT_STATUS);
+		dev_dbg(ctx->dev,
+			"total_delay %ld SENINF%d_PkCnt(0x%x)\n",
+			total_delay, ctx->seninfIdx, mipi_packet_cnt);
+
+		while (total_delay <= debug_ft) {
+			tmp_mipi_packet_cnt = mipi_packet_cnt & 0xFFFF;
+			mdelay(debug_vb);
+			total_delay += debug_vb;
+			mipi_packet_cnt = SENINF_READ_REG(base_csi,
+						SENINF_CSI2_PACKET_CNT_STATUS);
+			dev_dbg(ctx->dev,
+				"total_delay %ld SENINF%d_PkCnt(0x%x)\n",
+				total_delay, ctx->seninfIdx, mipi_packet_cnt);
+			if (tmp_mipi_packet_cnt != (mipi_packet_cnt & 0xFFFF)) {
+				pkg_cnt_changed = 1;
+				break;
+			}
+		}
+	}
+	if (!pkg_cnt_changed)
+		ret = -1;
+
+	/* Check csi status again */
+	if (debug_ft > total_delay) {
+		mdelay(debug_ft - total_delay);
+		total_delay = debug_ft;
+	}
+	temp = SENINF_READ_REG(base_csi, SENINF_CSI2_IRQ_STATUS);
+	dev_dbg(ctx->dev,
+		"SENINF%d_CSI2_IRQ_STATUS(0x%x)\n", ctx->seninfIdx, temp);
+	if (total_delay < SENINF_DRV_DEBUG_MAX_DELAY) {
+		if (total_delay + debug_ft < SENINF_DRV_DEBUG_MAX_DELAY)
+			mdelay(debug_ft);
+		else
+			mdelay(SENINF_DRV_DEBUG_MAX_DELAY - total_delay);
+	}
+	temp = SENINF_READ_REG(base_csi, SENINF_CSI2_IRQ_STATUS);
+	dev_dbg(ctx->dev,
+		"SENINF%d_CSI2_IRQ_STATUS(0x%x)\n", ctx->seninfIdx, temp);
+	if ((temp & 0xD0) != 0)
+		ret = -2; //multi lanes sync error, crc error, ecc error
+
+	/* SENINF_MUX */
+	for (j = SENINF_MUX1; j < _seninf_ops->mux_num; j++) {
+		base_mux = ctx->reg_if_mux[j];
+		dev_dbg(ctx->dev,
+			"SENINF%d_MUX_CTRL0(0x%x) SENINF%d_MUX_CTRL1(0x%x) SENINF_MUX_IRQ_STATUS(0x%x) SENINF%d_MUX_SIZE(0x%x) SENINF_MUX_ERR_SIZE(0x%x) SENINF_MUX_EXP_SIZE(0x%x)\n",
+			j,
+			SENINF_READ_REG(base_mux, SENINF_MUX_CTRL_0),
+			j,
+			SENINF_READ_REG(base_mux, SENINF_MUX_CTRL_1),
+			SENINF_READ_REG(base_mux, SENINF_MUX_IRQ_STATUS),
+			j,
+			SENINF_READ_REG(base_mux, SENINF_MUX_SIZE),
+			SENINF_READ_REG(base_mux, SENINF_MUX_ERR_SIZE),
+			SENINF_READ_REG(base_mux, SENINF_MUX_IMG_SIZE));
+
+		if (SENINF_READ_REG(base_mux, SENINF_MUX_IRQ_STATUS) & 0x1) {
+			SENINF_WRITE_REG(base_mux, SENINF_MUX_IRQ_STATUS,
+					 0xffffffff);
+			mdelay(debug_ft);
+			dev_dbg(ctx->dev,
+				"after reset overrun, SENINF_MUX_IRQ_STATUS(0x%x) SENINF%d_MUX_SIZE(0x%x)\n",
+				SENINF_READ_REG(base_mux,
+						SENINF_MUX_IRQ_STATUS),
+				j,
+				SENINF_READ_REG(base_mux, SENINF_MUX_SIZE));
+		}
+	}
+
+	irq_status = SENINF_READ_REG(ctx->reg_if_cam_mux,
+				     SENINF_CAM_MUX_IRQ_STATUS);
+
+	dev_dbg(ctx->dev,
+		"SENINF_CAM_MUX_EN 0x%x SENINF_CAM_MUX_IRQ_EN 0x%x SENINF_CAM_MUX_IRQ_STATUS 0x%x",
+		enabled,
+		SENINF_READ_REG(ctx->reg_if_cam_mux, SENINF_CAM_MUX_IRQ_EN),
+		irq_status);
+
+	/* check SENINF_CAM_MUX size */
+	for (j = 0; j < ctx->vcinfo.cnt; j++) {
+		if (ctx->vcinfo.vc[j].enable) {
+			CHECK_MATCHED_CAM_MUX(0, ctx->vcinfo.vc[j].cam,
+					      enabled, irq_status);
+			CHECK_MATCHED_CAM_MUX(1, ctx->vcinfo.vc[j].cam,
+					      enabled, irq_status);
+			CHECK_MATCHED_CAM_MUX(2, ctx->vcinfo.vc[j].cam,
+					      enabled, irq_status);
+			CHECK_MATCHED_CAM_MUX(3, ctx->vcinfo.vc[j].cam,
+					      enabled, irq_status);
+			CHECK_MATCHED_CAM_MUX(4, ctx->vcinfo.vc[j].cam,
+					      enabled, irq_status);
+			CHECK_MATCHED_CAM_MUX(5, ctx->vcinfo.vc[j].cam,
+					      enabled, irq_status);
+			CHECK_MATCHED_CAM_MUX(6, ctx->vcinfo.vc[j].cam,
+					      enabled, irq_status);
+			CHECK_MATCHED_CAM_MUX(7, ctx->vcinfo.vc[j].cam,
+					      enabled, irq_status);
+			CHECK_MATCHED_CAM_MUX(8, ctx->vcinfo.vc[j].cam,
+					      enabled, irq_status);
+			CHECK_MATCHED_CAM_MUX(9, ctx->vcinfo.vc[j].cam,
+					      enabled, irq_status);
+			CHECK_MATCHED_CAM_MUX(10, ctx->vcinfo.vc[j].cam,
+					      enabled, irq_status);
+			CHECK_MATCHED_CAM_MUX(11, ctx->vcinfo.vc[j].cam,
+					      enabled, irq_status);
+			CHECK_MATCHED_CAM_MUX(12, ctx->vcinfo.vc[j].cam,
+					      enabled, irq_status);
+		}
+	}
+
+	dev_dbg(ctx->dev,
+		"SENINF_CAM_MUX size: MUX0(0x%x) MUX1(0x%x) MUX2(0x%x) MUX3(0x%x) MUX4(0x%x) MUX5(0x%x)\n",
+		SENINF_READ_REG(ctx->reg_if_cam_mux, SENINF_CAM_MUX0_CHK_RES),
+		SENINF_READ_REG(ctx->reg_if_cam_mux, SENINF_CAM_MUX1_CHK_RES),
+		SENINF_READ_REG(ctx->reg_if_cam_mux, SENINF_CAM_MUX2_CHK_RES),
+		SENINF_READ_REG(ctx->reg_if_cam_mux, SENINF_CAM_MUX3_CHK_RES),
+		SENINF_READ_REG(ctx->reg_if_cam_mux, SENINF_CAM_MUX4_CHK_RES),
+		SENINF_READ_REG(ctx->reg_if_cam_mux, SENINF_CAM_MUX5_CHK_RES));
+	dev_dbg(ctx->dev,
+		"SENINF_CAM_MUX size: MUX6(0x%x) MUX7(0x%x) MUX8(0x%x) MUX9(0x%x) MUX10(0x%x) MUX1(0x%x) MUX12(0x%x)\n",
+		SENINF_READ_REG(ctx->reg_if_cam_mux, SENINF_CAM_MUX6_CHK_RES),
+		SENINF_READ_REG(ctx->reg_if_cam_mux, SENINF_CAM_MUX7_CHK_RES),
+		SENINF_READ_REG(ctx->reg_if_cam_mux, SENINF_CAM_MUX8_CHK_RES),
+		SENINF_READ_REG(ctx->reg_if_cam_mux, SENINF_CAM_MUX9_CHK_RES),
+		SENINF_READ_REG(ctx->reg_if_cam_mux, SENINF_CAM_MUX10_CHK_RES),
+		SENINF_READ_REG(ctx->reg_if_cam_mux, SENINF_CAM_MUX11_CHK_RES),
+		SENINF_READ_REG(ctx->reg_if_cam_mux, SENINF_CAM_MUX12_CHK_RES));
+	dev_dbg(ctx->dev,
+		"SENINF_CAM_MUX err size: MUX0(0x%x) MUX1(0x%x) MUX2(0x%x) MUX3(0x%x) MUX4(0x%x) MUX5(0x%x)\n",
+		SENINF_READ_REG(ctx->reg_if_cam_mux,
+				SENINF_CAM_MUX0_CHK_ERR_RES),
+		SENINF_READ_REG(ctx->reg_if_cam_mux,
+				SENINF_CAM_MUX1_CHK_ERR_RES),
+		SENINF_READ_REG(ctx->reg_if_cam_mux,
+				SENINF_CAM_MUX2_CHK_ERR_RES),
+		SENINF_READ_REG(ctx->reg_if_cam_mux,
+				SENINF_CAM_MUX3_CHK_ERR_RES),
+		SENINF_READ_REG(ctx->reg_if_cam_mux,
+				SENINF_CAM_MUX4_CHK_ERR_RES),
+		SENINF_READ_REG(ctx->reg_if_cam_mux,
+				SENINF_CAM_MUX5_CHK_ERR_RES));
+	dev_dbg(ctx->dev,
+		"SENINF_CAM_MUX err size: MUX6(0x%x) MUX7(0x%x) MUX8(0x%x) MUX9(0x%x) MUX10(0x%x) MUX11(0x%x) MUX12(0x%x)\n",
+		SENINF_READ_REG(ctx->reg_if_cam_mux,
+				SENINF_CAM_MUX6_CHK_ERR_RES),
+		SENINF_READ_REG(ctx->reg_if_cam_mux,
+				SENINF_CAM_MUX7_CHK_ERR_RES),
+		SENINF_READ_REG(ctx->reg_if_cam_mux,
+				SENINF_CAM_MUX8_CHK_ERR_RES),
+		SENINF_READ_REG(ctx->reg_if_cam_mux,
+				SENINF_CAM_MUX9_CHK_ERR_RES),
+		SENINF_READ_REG(ctx->reg_if_cam_mux,
+				SENINF_CAM_MUX10_CHK_ERR_RES),
+		SENINF_READ_REG(ctx->reg_if_cam_mux,
+				SENINF_CAM_MUX11_CHK_ERR_RES),
+		SENINF_READ_REG(ctx->reg_if_cam_mux,
+				SENINF_CAM_MUX12_CHK_ERR_RES));
+
+	//check VC/DT split
+	dev_dbg(ctx->dev,
+		"VC/DT split:SENINF_CAM_MUX0_OPT(0x%x) MUX1(0x%x) MUX2(0x%x) MUX3(0x%x) MUX4(0x%x) MUX5(0x%x)\n",
+		SENINF_READ_REG(ctx->reg_if_cam_mux, SENINF_CAM_MUX0_OPT),
+		SENINF_READ_REG(ctx->reg_if_cam_mux, SENINF_CAM_MUX1_OPT),
+		SENINF_READ_REG(ctx->reg_if_cam_mux, SENINF_CAM_MUX2_OPT),
+		SENINF_READ_REG(ctx->reg_if_cam_mux, SENINF_CAM_MUX3_OPT),
+		SENINF_READ_REG(ctx->reg_if_cam_mux, SENINF_CAM_MUX4_OPT),
+		SENINF_READ_REG(ctx->reg_if_cam_mux, SENINF_CAM_MUX5_OPT));
+	dev_dbg(ctx->dev,
+		"VC/DT split:SENINF_CAM_MUX6_OPT(0x%x) MUX7(0x%x) MUX8(0x%x) MUX9(0x%x) MUX10(0x%x) MUX11(0x%x) MUX12(0x%x)\n",
+		SENINF_READ_REG(ctx->reg_if_cam_mux, SENINF_CAM_MUX6_OPT),
+		SENINF_READ_REG(ctx->reg_if_cam_mux, SENINF_CAM_MUX7_OPT),
+		SENINF_READ_REG(ctx->reg_if_cam_mux, SENINF_CAM_MUX8_OPT),
+		SENINF_READ_REG(ctx->reg_if_cam_mux, SENINF_CAM_MUX9_OPT),
+		SENINF_READ_REG(ctx->reg_if_cam_mux, SENINF_CAM_MUX10_OPT),
+		SENINF_READ_REG(ctx->reg_if_cam_mux, SENINF_CAM_MUX11_OPT),
+		SENINF_READ_REG(ctx->reg_if_cam_mux, SENINF_CAM_MUX12_OPT));
+
+	dev_dbg(ctx->dev, "ret = %d", ret);
+
+	return ret;
+}
+/*
+ *static int mtk_cam_seninf_vsync_irq_handler(unsigned int vsync_irq_status, void *data)
+ *{
+ *	int i = 0;
+ *	struct seninf_core *core = (struct seninf_core *)data;
+ *
+ *	for (i = SENINF_CAM_MUX0; i < _seninf_ops->cam_mux_num; i++) {
+ *		if (vsync_irq_status & (1 << SENINF_CAM_MUX0)) {
+ *			dev_dbg(core->dev, "%s vsync for SENINF_CAM_MUX%d\n",
+ *				__func__, i);
+ *		}
+ *	}
+ *	return 0;
+ *}
+ */
+
+static ssize_t mtk_cam_seninf_show_err_status(struct device *dev,
+				   struct device_attribute *attr,
+		char *buf)
+{
+	int i, len;
+	struct seninf_core *core;
+	struct seninf_ctx *ctx;
+	struct seninf_vc *vc;
+
+	core = dev_get_drvdata(dev);
+	len = 0;
+
+	mutex_lock(&core->mutex);
+
+	list_for_each_entry(ctx, &core->list, list) {
+		SHOW(buf, len,
+		     "\n[%s] port %d intf %d test %d cphy %d lanes %d\n",
+			ctx->subdev.name,
+			ctx->port,
+			ctx->seninfIdx,
+			ctx->is_test_model,
+			ctx->is_cphy,
+			ctx->num_data_lanes);
+
+		SHOW(buf, len, "---flag = errs exceed theshhold ? 1 : 0---\n");
+		SHOW(buf, len, "\tdata_not_enough error flag : <%d>",
+			ctx->data_not_enough_flag);
+		SHOW(buf, len, "\terr_lane_resync error flag : <%d>",
+			ctx->err_lane_resync_flag);
+		SHOW(buf, len, "\tcrc_err error flag : <%d>",
+			ctx->crc_err_flag);
+		SHOW(buf, len, "\tecc_err_double error flag : <%d>",
+			ctx->ecc_err_double_flag);
+		SHOW(buf, len, "\tecc_err_corrected error flag : <%d>\n",
+			ctx->ecc_err_corrected_flag);
+
+		for (i = 0; i < ctx->vcinfo.cnt; i++) {
+			vc = &ctx->vcinfo.vc[i];
+			SHOW(buf, len,
+			     "[%d] vc 0x%x dt 0x%x mux %d cam %d\n",
+				i, vc->vc, vc->dt, vc->mux, vc->cam);
+			SHOW(buf, len, "\tfifo_overrun error flag : <%d>",
+				ctx->fifo_overrun_flag);
+			SHOW(buf, len, "\tsize_err error flag : <%d>\n",
+				ctx->size_err_flag);
+		}
+	}
+
+	mutex_unlock(&core->mutex);
+
+	return len;
+}
+
+static int mtk_cam_seninf_irq_handler(int irq, void *data)
+{
+/*
+ *	unsigned long flags = 0;
+ *	unsigned int vsync_irq_status;
+ *	unsigned int global_drop_status;
+ *	struct seninf_core *core = (struct seninf_core *)data;
+ *	void *cam_mux_base = core->reg_if + 0x400;
+ *
+ *	spin_lock_irqsave(&core->spinlock_irq, flags);
+ *	vsync_irq_status = SENINF_READ_REG(cam_mux_base, SENINF_CAM_MUX_VSYNC_IRQ_STS);
+ *	SENINF_WRITE_REG(cam_mux_base, SENINF_CAM_MUX_VSYNC_IRQ_STS, vsync_irq_status);
+ *
+ *	global_drop_status = SENINF_READ_REG(cam_mux_base, SENINF_CAM_MUX_IRQ_STATUS);
+ *	spin_unlock_irqrestore(&core->spinlock_irq, flags);
+ *
+ *	dev_dbg(core->dev,
+ *		"%s SENINF_CAM_MUX_VSYNC_IRQ_STS 0x%x , SENINF_CAM_MUX_IRQ_STATUS 0x%x\n",
+ *		__func__, vsync_irq_status, global_drop_status);
+ *	mtk_cam_seninf_vsync_irq_handler(vsync_irq_status, data);
+ */
+	struct seninf_core *core = (struct seninf_core *)data;
+	unsigned long flags;
+	/* for mipi err detection */
+	struct seninf_ctx *ctx;
+	struct seninf_vc *vc;
+	void *csi2, *pmux, *pSeninf_cam_mux;
+	int i;
+	unsigned int csiIrq_tmp;
+	unsigned int muxIrq_tmp;
+	unsigned int camIrq_exp_tmp;
+	unsigned int camIrq_res_tmp;
+	/* for err detection aee log snprintf */
+	char seninf_name[256];
+	int cnt1, cnt2, cnt3, cnt4, cnt5, cnt6, cnt7;
+	int cnt_tmp = 0;
+
+	spin_lock_irqsave(&core->spinlock_irq, flags);
+
+	/* debug for set_reg case: REG_KEY_CSI_IRQ_EN */
+	if (core->csi_irq_en_flag) {
+		list_for_each_entry(ctx, &core->list, list) {
+			csi2 = ctx->reg_if_csi2[ctx->seninfIdx];
+			csiIrq_tmp =
+				SENINF_READ_REG(csi2, SENINF_CSI2_IRQ_STATUS);
+
+			if (csiIrq_tmp) {
+				SENINF_WRITE_REG(
+					csi2,
+					SENINF_CSI2_IRQ_STATUS,
+					0xFFFFFFFF);
+			}
+
+			if (csiIrq_tmp & (0x1 << 3))
+				ctx->ecc_err_corrected_cnt++;
+			if (csiIrq_tmp & (0x1 << 4))
+				ctx->ecc_err_double_cnt++;
+			if (csiIrq_tmp & (0x1 << 6))
+				ctx->crc_err_cnt++;
+			if (csiIrq_tmp & (0x1 << 13))
+				ctx->err_lane_resync_cnt++;
+			if (csiIrq_tmp & (0x1 << 29))
+				ctx->data_not_enough_cnt++;
+
+			for (i = 0; i < ctx->vcinfo.cnt; i++) {
+				vc = &ctx->vcinfo.vc[i];
+				pmux = ctx->reg_if_mux[vc->mux];
+				pSeninf_cam_mux = ctx->reg_if_cam_mux;
+				muxIrq_tmp = SENINF_READ_REG(
+						pmux,
+						SENINF_MUX_IRQ_STATUS);
+				camIrq_exp_tmp =
+					SENINF_READ_REG(
+						pSeninf_cam_mux,
+						SENINF_CAM_MUX0_CHK_CTL_1 + (0x10 * (vc->cam)));
+				camIrq_res_tmp =
+					SENINF_READ_REG(
+						pSeninf_cam_mux,
+						SENINF_CAM_MUX0_CHK_RES + (0x10 * (vc->cam)));
+
+				if (muxIrq_tmp)
+					SENINF_WRITE_REG(
+						pmux,
+						SENINF_MUX_IRQ_STATUS,
+						0xFFFFFFFF);
+
+				if (camIrq_res_tmp != camIrq_exp_tmp)
+					SENINF_WRITE_REG(
+						pSeninf_cam_mux,
+						SENINF_CAM_MUX0_CHK_RES + (0x10 * (vc->cam)),
+						0xFFFFFFFF);
+
+				if (muxIrq_tmp & (0x1 << 0))
+					ctx->fifo_overrun_cnt++;
+				if (camIrq_res_tmp != camIrq_exp_tmp)
+					ctx->size_err_cnt++;
+			}
+
+			if ((ctx->data_not_enough_cnt) >= (core->detection_cnt) ||
+			    (ctx->err_lane_resync_cnt) >= (core->detection_cnt) ||
+			    (ctx->crc_err_cnt) >= (core->detection_cnt) ||
+			    (ctx->ecc_err_double_cnt) >= (core->detection_cnt) ||
+			    (ctx->ecc_err_corrected_cnt) >= (core->detection_cnt) ||
+			    (ctx->fifo_overrun_cnt) >= (core->detection_cnt) ||
+			    (ctx->size_err_cnt) >= (core->detection_cnt)) {
+				SENINF_WRITE_REG(csi2, SENINF_CSI2_IRQ_EN, 0x80000000);
+
+				if ((ctx->data_not_enough_cnt) >= (core->detection_cnt))
+					ctx->data_not_enough_flag = 1;
+				if ((ctx->err_lane_resync_cnt) >= (core->detection_cnt))
+					ctx->err_lane_resync_flag = 1;
+				if ((ctx->crc_err_cnt) >= (core->detection_cnt))
+					ctx->crc_err_flag = 1;
+				if ((ctx->ecc_err_double_cnt) >= (core->detection_cnt))
+					ctx->ecc_err_double_flag = 1;
+				if ((ctx->ecc_err_corrected_cnt) >= (core->detection_cnt))
+					ctx->ecc_err_corrected_flag = 1;
+				if ((ctx->fifo_overrun_cnt) >= (core->detection_cnt))
+					ctx->fifo_overrun_flag = 1;
+				if ((ctx->size_err_cnt) >= (core->detection_cnt))
+					ctx->size_err_flag = 1;
+
+				cnt1 = snprintf(seninf_name, 256, "%s", __func__);
+				cnt_tmp += cnt1;
+				cnt2 = snprintf(seninf_name+cnt_tmp, 256-cnt_tmp,
+					"   data_not_enough_count: %d",
+					ctx->data_not_enough_cnt);
+				cnt_tmp += cnt2;
+				cnt3 = snprintf(seninf_name+cnt_tmp, 256-cnt_tmp,
+					"   err_lane_resync_count: %d",
+					ctx->err_lane_resync_cnt);
+				cnt_tmp += cnt3;
+				cnt4 = snprintf(seninf_name+cnt_tmp, 256-cnt_tmp,
+					"   crc_err_count: %d",
+					ctx->crc_err_cnt);
+				cnt_tmp += cnt4;
+				cnt5 = snprintf(seninf_name+cnt_tmp, 256-cnt_tmp,
+					"   ecc_err_double_count: %d",
+					ctx->ecc_err_double_cnt);
+				cnt_tmp += cnt5;
+				cnt6 = snprintf(seninf_name+cnt_tmp, 256-cnt_tmp,
+					"   ecc_err_corrected_count: %d",
+					ctx->ecc_err_corrected_cnt);
+				cnt_tmp += cnt6;
+				cnt7 = snprintf(seninf_name+cnt_tmp, 256-cnt_tmp,
+					"   fifo_overrun_count: %d",
+					ctx->fifo_overrun_cnt);
+				cnt_tmp += cnt7;
+				snprintf(seninf_name+cnt_tmp, 256-cnt_tmp,
+					"   size_err_count: %d",
+					ctx->size_err_cnt);
+				seninf_aee_print("[AEE] %s", seninf_name);
+
+				// kill_pid(core->pid, SIGKILL, 1);
+			}
+		}
+	}
+
+	spin_unlock_irqrestore(&core->spinlock_irq, flags);
+
+	return 0;
+}
+
+static int mtk_cam_seninf_set_sw_cfg_busy(struct seninf_ctx *ctx, bool enable, int index)
+{
+	void *pSeninf_cam_mux = ctx->reg_if_cam_mux;
+
+	if (index == 0)
+		SENINF_BITS(pSeninf_cam_mux,
+			SENINF_CAM_MUX_DYN_CTRL, RG_SENINF_CAM_MUX_DYN_SWITCH_BSY0, enable);
+	else
+		SENINF_BITS(pSeninf_cam_mux,
+			SENINF_CAM_MUX_DYN_CTRL, RG_SENINF_CAM_MUX_DYN_SWITCH_BSY1, enable);
+	return 0;
+}
+
+static int mtk_cam_seninf_set_cam_mux_dyn_en(
+	struct seninf_ctx *ctx, bool enable, int cam_mux, int index)
+{
+	void *pSeninf_cam_mux = ctx->reg_if_cam_mux;
+	int tmp = 0;
+
+	if (index == 0) {
+		tmp = SENINF_READ_BITS(pSeninf_cam_mux,
+			SENINF_CAM_MUX_DYN_EN, RG_SENINF_CAM_MUX_DYN_SWITCH_EN0);
+		if (enable)
+			tmp = tmp | (1 << cam_mux);
+		else
+			tmp = tmp & ~(1 << cam_mux);
+		SENINF_BITS(pSeninf_cam_mux,
+			SENINF_CAM_MUX_DYN_EN, RG_SENINF_CAM_MUX_DYN_SWITCH_EN0, tmp);
+	} else {
+		tmp = SENINF_READ_BITS(pSeninf_cam_mux,
+			SENINF_CAM_MUX_DYN_EN, RG_SENINF_CAM_MUX_DYN_SWITCH_EN1);
+		if (enable)
+			tmp = tmp | (1 << cam_mux);
+		else
+			tmp = tmp & ~(1 << cam_mux);
+		SENINF_BITS(pSeninf_cam_mux,
+			SENINF_CAM_MUX_DYN_EN, RG_SENINF_CAM_MUX_DYN_SWITCH_EN1, tmp);
+	}
+	return 0;
+
+}
+
+static int mtk_cam_seninf_reset_cam_mux_dyn_en(struct seninf_ctx *ctx, int index)
+{
+	void *pSeninf_cam_mux = ctx->reg_if_cam_mux;
+
+	if (index == 0)
+		SENINF_BITS(pSeninf_cam_mux,
+			SENINF_CAM_MUX_DYN_EN, RG_SENINF_CAM_MUX_DYN_SWITCH_EN0, 0);
+	else
+		SENINF_BITS(pSeninf_cam_mux,
+			SENINF_CAM_MUX_DYN_EN, RG_SENINF_CAM_MUX_DYN_SWITCH_EN1, 0);
+	return 0;
+}
+
+
+static int mtk_cam_seninf_enable_global_drop_irq(struct seninf_ctx *ctx, bool enable, int index)
+{
+	void *pSeninf_cam_mux = ctx->reg_if_cam_mux;
+
+	if (index == 0)
+		SENINF_BITS(pSeninf_cam_mux,
+			SENINF_CAM_MUX_IRQ_EN, RG_SENINF_CAM_MUX15_HSIZE_ERR_IRQ_EN, enable);
+	else
+		SENINF_BITS(pSeninf_cam_mux,
+			SENINF_CAM_MUX_IRQ_EN, RG_SENINF_CAM_MUX15_VSIZE_ERR_IRQ_EN, enable);
+	return 0;
+
+}
+
+static int mtk_cam_seninf_enable_cam_mux_vsync_irq(struct seninf_ctx *ctx, bool enable, int cam_mux)
+{
+	void *pSeninf_cam_mux = ctx->reg_if_cam_mux;
+	int tmp = 0;
+
+	tmp = SENINF_READ_BITS(pSeninf_cam_mux,
+			SENINF_CAM_MUX_VSYNC_IRQ_EN, RG_SENINF_CAM_MUX_VSYNC_IRQ_EN);
+	if (enable)
+		tmp |= (enable << cam_mux);
+	else
+		tmp &= ~(enable << cam_mux);
+	SENINF_BITS(pSeninf_cam_mux,
+			SENINF_CAM_MUX_VSYNC_IRQ_EN, RG_SENINF_CAM_MUX_VSYNC_IRQ_EN, tmp);
+	return 0;
+}
+
+
+static int mtk_cam_seninf_disable_all_cam_mux_vsync_irq(struct seninf_ctx *ctx)
+{
+	void *pSeninf_cam_mux = ctx->reg_if_cam_mux;
+
+	SENINF_BITS(pSeninf_cam_mux,
+		SENINF_CAM_MUX_VSYNC_IRQ_EN, RG_SENINF_CAM_MUX_VSYNC_IRQ_EN, 0);
+	return 0;
+
+}
+
+static int mtk_cam_seninf_set_reg(struct seninf_ctx *ctx, u32 key, u32 val)
+{
+	int i;
+	void *base = ctx->reg_ana_dphy_top[ctx->port];
+	void *csi2 = ctx->reg_if_csi2[ctx->seninfIdx];
+	void *pmux, *pcammux;
+	struct seninf_vc *vc;
+	struct seninf_core *core;
+	struct seninf_ctx *ctx_;
+	void *csi2_;
+
+	core = dev_get_drvdata(ctx->dev->parent);
+
+	if (!ctx->streaming)
+		return 0;
+
+	dev_dbg(ctx->dev, "%s key = 0x%x, val = 0x%x\n",
+		 __func__, key, val);
+
+	switch (key) {
+	case REG_KEY_SETTLE_CK:
+		SENINF_BITS(base, DPHY_RX_CLOCK_LANE0_HS_PARAMETER,
+			    RG_DPHY_RX_LC0_HS_SETTLE_PARAMETER,
+			    val);
+		SENINF_BITS(base, DPHY_RX_CLOCK_LANE1_HS_PARAMETER,
+			    RG_DPHY_RX_LC1_HS_SETTLE_PARAMETER,
+			    val);
+		break;
+	case REG_KEY_SETTLE_DT:
+		SENINF_BITS(base, DPHY_RX_DATA_LANE0_HS_PARAMETER,
+			    RG_CDPHY_RX_LD0_TRIO0_HS_SETTLE_PARAMETER,
+			    val);
+		SENINF_BITS(base, DPHY_RX_DATA_LANE1_HS_PARAMETER,
+			    RG_CDPHY_RX_LD1_TRIO1_HS_SETTLE_PARAMETER,
+			    val);
+		SENINF_BITS(base, DPHY_RX_DATA_LANE2_HS_PARAMETER,
+			    RG_CDPHY_RX_LD2_TRIO2_HS_SETTLE_PARAMETER,
+			    val);
+		SENINF_BITS(base, DPHY_RX_DATA_LANE3_HS_PARAMETER,
+			    RG_CDPHY_RX_LD3_TRIO3_HS_SETTLE_PARAMETER,
+			    val);
+		break;
+	case REG_KEY_HS_TRAIL_EN:
+		SENINF_BITS(base, DPHY_RX_DATA_LANE0_HS_PARAMETER,
+			    RG_DPHY_RX_LD0_HS_TRAIL_EN, val);
+		SENINF_BITS(base, DPHY_RX_DATA_LANE1_HS_PARAMETER,
+			    RG_DPHY_RX_LD1_HS_TRAIL_EN, val);
+		SENINF_BITS(base, DPHY_RX_DATA_LANE2_HS_PARAMETER,
+			    RG_DPHY_RX_LD2_HS_TRAIL_EN, val);
+		SENINF_BITS(base, DPHY_RX_DATA_LANE3_HS_PARAMETER,
+			    RG_DPHY_RX_LD3_HS_TRAIL_EN, val);
+		break;
+	case REG_KEY_HS_TRAIL_PARAM:
+		SENINF_BITS(base, DPHY_RX_DATA_LANE0_HS_PARAMETER,
+			    RG_DPHY_RX_LD0_HS_TRAIL_PARAMETER, val);
+		SENINF_BITS(base, DPHY_RX_DATA_LANE1_HS_PARAMETER,
+			    RG_DPHY_RX_LD1_HS_TRAIL_PARAMETER, val);
+		SENINF_BITS(base, DPHY_RX_DATA_LANE2_HS_PARAMETER,
+			    RG_DPHY_RX_LD2_HS_TRAIL_PARAMETER, val);
+		SENINF_BITS(base, DPHY_RX_DATA_LANE3_HS_PARAMETER,
+			    RG_DPHY_RX_LD3_HS_TRAIL_PARAMETER, val);
+		break;
+	case REG_KEY_CSI_IRQ_STAT:
+		SENINF_WRITE_REG(csi2, SENINF_CSI2_IRQ_STATUS,
+				 val & 0xFFFFFFFF);
+		break;
+	case REG_KEY_MUX_IRQ_STAT:
+		for (i = 0; i < ctx->vcinfo.cnt; i++) {
+			vc = &ctx->vcinfo.vc[i];
+			pmux = ctx->reg_if_mux[vc->mux];
+			SENINF_WRITE_REG(pmux, SENINF_MUX_IRQ_STATUS,
+					val & 0xFFFFFFFF);
+		}
+		break;
+	case REG_KEY_CAMMUX_IRQ_STAT:
+		for (i = 0; i < ctx->vcinfo.cnt; i++) {
+			vc = &ctx->vcinfo.vc[i];
+			pcammux = ctx->reg_if_cam_mux;
+			SENINF_WRITE_REG(pcammux,
+					SENINF_CAM_MUX_IRQ_STATUS,
+					val & 0xFFFFFFFF);
+		}
+		break;
+	case REG_KEY_CSI_IRQ_EN:
+		{
+			if (val < 0)
+				return 0;
+			if (!val)
+				core->detection_cnt = 50;
+
+			core->csi_irq_en_flag = 1;
+			core->detection_cnt = val;
+			list_for_each_entry(ctx_, &core->list, list) {
+				csi2_ = ctx_->reg_if_csi2[ctx_->seninfIdx];
+				SENINF_WRITE_REG(csi2_, SENINF_CSI2_IRQ_EN,
+						0xA0002058);
+			}
+		}
+		break;
+	}
+
+	return 0;
+}
+
+struct mtk_cam_seninf_ops mtk_csi_phy_2_0 = {
+	._init_iomem = mtk_cam_seninf_init_iomem,
+	._init_port = mtk_cam_seninf_init_port,
+	._is_cammux_used = mtk_cam_seninf_is_cammux_used,
+	._cammux = mtk_cam_seninf_cammux,
+	._disable_cammux = mtk_cam_seninf_disable_cammux,
+	._disable_all_cammux = mtk_cam_seninf_disable_all_cammux,
+	._set_top_mux_ctrl = mtk_cam_seninf_set_top_mux_ctrl,
+	._get_top_mux_ctrl = mtk_cam_seninf_get_top_mux_ctrl,
+	._get_cammux_ctrl = mtk_cam_seninf_get_cammux_ctrl,
+	._get_cammux_res = mtk_cam_seninf_get_cammux_res,
+	._set_cammux_vc = mtk_cam_seninf_set_cammux_vc,
+	._set_cammux_src = mtk_cam_seninf_set_cammux_src,
+	._set_vc = mtk_cam_seninf_set_vc,
+	._set_mux_ctrl = mtk_cam_seninf_set_mux_ctrl,
+	._set_mux_crop = mtk_cam_seninf_set_mux_crop,
+	._is_mux_used = mtk_cam_seninf_is_mux_used,
+	._mux = mtk_cam_seninf_mux,
+	._disable_mux = mtk_cam_seninf_disable_mux,
+	._disable_all_mux = mtk_cam_seninf_disable_all_mux,
+	._set_cammux_chk_pixel_mode = mtk_cam_seninf_set_cammux_chk_pixel_mode,
+	._set_test_model = mtk_cam_seninf_set_test_model,
+	._set_csi_mipi = mtk_cam_seninf_set_csi_mipi,
+	._poweroff = mtk_cam_seninf_poweroff,
+	._reset = mtk_cam_seninf_reset,
+	._set_idle = mtk_cam_seninf_set_idle,
+	._get_mux_meter = mtk_cam_seninf_get_mux_meter,
+	._show_status = mtk_cam_seninf_show_status,
+	._switch_to_cammux_inner_page = mtk_cam_seninf_switch_to_cammux_inner_page,
+	._set_cammux_next_ctrl = mtk_cam_seninf_set_cammux_next_ctrl,
+	._update_mux_pixel_mode = mtk_cam_seninf_update_mux_pixel_mode,
+	._irq_handler = mtk_cam_seninf_irq_handler,
+	._set_sw_cfg_busy = mtk_cam_seninf_set_sw_cfg_busy,
+	._set_cam_mux_dyn_en = mtk_cam_seninf_set_cam_mux_dyn_en,
+	._reset_cam_mux_dyn_en = mtk_cam_seninf_reset_cam_mux_dyn_en,
+	._enable_global_drop_irq = mtk_cam_seninf_enable_global_drop_irq,
+	._enable_cam_mux_vsync_irq = mtk_cam_seninf_enable_cam_mux_vsync_irq,
+	._disable_all_cam_mux_vsync_irq = mtk_cam_seninf_disable_all_cam_mux_vsync_irq,
+	._debug = mtk_cam_seninf_debug,
+	._set_reg = mtk_cam_seninf_set_reg,
+	.mux_num = 8,
+#ifdef ISP7_1
+	.seninf_num = 4,
+	.cam_mux_num = 11,
+	.pref_mux_num = 11,
+#else
+	.seninf_num = 6,
+	.cam_mux_num = 13,
+	.pref_mux_num = 8,
+#endif
+	._show_err_status = mtk_cam_seninf_show_err_status,
+};
+
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_csi_phy_2_0/mtk_cam-seninf-mipi-rx-ana-cdphy-csi0a.h b/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_csi_phy_2_0/mtk_cam-seninf-mipi-rx-ana-cdphy-csi0a.h
new file mode 100644
index 0000000000000000000000000000000000000000..f0d77d2b390101ed89ccb3f8f498a812926a78fa
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_csi_phy_2_0/mtk_cam-seninf-mipi-rx-ana-cdphy-csi0a.h
@@ -0,0 +1,561 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2022 MediaTek Inc.
+ */
+
+#ifndef __MIPI_RX_ANA_CDPHY_CSI0A_H__
+#define __MIPI_RX_ANA_CDPHY_CSI0A_H__
+
+#define CDPHY_RX_ANA_0 0x0000
+#define RG_CSI0_BG_CORE_EN_SHIFT 0
+#define RG_CSI0_BG_CORE_EN_MASK (0x1 << 0)
+#define RG_CSI0_BG_LPF_EN_SHIFT 1
+#define RG_CSI0_BG_LPF_EN_MASK (0x1 << 1)
+#define RG_CSI0_EQ_PROTECT_EN_SHIFT 4
+#define RG_CSI0_EQ_PROTECT_EN_MASK (0x1 << 4)
+#define RG_CSI0_BYTE_CK_RSTB_SEL_SHIFT 5
+#define RG_CSI0_BYTE_CK_RSTB_SEL_MASK (0x1 << 5)
+#define RG_CSI0_DPHY_L0_CKSEL_SHIFT 8
+#define RG_CSI0_DPHY_L0_CKSEL_MASK (0x1 << 8)
+#define RG_CSI0_DPHY_L1_CKSEL_SHIFT 9
+#define RG_CSI0_DPHY_L1_CKSEL_MASK (0x1 << 9)
+#define RG_CSI0_DPHY_L2_CKSEL_SHIFT 10
+#define RG_CSI0_DPHY_L2_CKSEL_MASK (0x1 << 10)
+#define RG_CSI0_DPHY_L0_CKMODE_EN_SHIFT 12
+#define RG_CSI0_DPHY_L0_CKMODE_EN_MASK (0x1 << 12)
+#define RG_CSI0_DPHY_L1_CKMODE_EN_SHIFT 13
+#define RG_CSI0_DPHY_L1_CKMODE_EN_MASK (0x1 << 13)
+#define RG_CSI0_DPHY_L2_CKMODE_EN_SHIFT 14
+#define RG_CSI0_DPHY_L2_CKMODE_EN_MASK (0x1 << 14)
+#define RG_CSI0_CDPHY_L0_T0_BYTECK_INVERT_SHIFT 16
+#define RG_CSI0_CDPHY_L0_T0_BYTECK_INVERT_MASK (0x1 << 16)
+#define RG_CSI0_DPHY_L1_BYTECK_INVERT_SHIFT 17
+#define RG_CSI0_DPHY_L1_BYTECK_INVERT_MASK (0x1 << 17)
+#define RG_CSI0_CDPHY_L2_T1_BYTECK_INVERT_SHIFT 18
+#define RG_CSI0_CDPHY_L2_T1_BYTECK_INVERT_MASK (0x1 << 18)
+#define RG_CSI0_CPHY_EN_SHIFT 20
+#define RG_CSI0_CPHY_EN_MASK (0x1 << 20)
+#define RG_CSI0_CPHY_T0_CDR_FIRST_EDGE_EN_SHIFT 21
+#define RG_CSI0_CPHY_T0_CDR_FIRST_EDGE_EN_MASK (0x1 << 21)
+#define RG_CSI0_CPHY_T1_CDR_FIRST_EDGE_EN_SHIFT 22
+#define RG_CSI0_CPHY_T1_CDR_FIRST_EDGE_EN_MASK (0x1 << 22)
+#define RG_CSI0_CDPHY_L0_T0_FORCE_INIT_SHIFT 24
+#define RG_CSI0_CDPHY_L0_T0_FORCE_INIT_MASK (0x1 << 24)
+#define RG_CSI0_DPHY_L1_FORCE_INIT_SHIFT 25
+#define RG_CSI0_DPHY_L1_FORCE_INIT_MASK (0x1 << 25)
+#define RG_CSI0_CDPHY_L2_T1_FORCE_INIT_SHIFT 26
+#define RG_CSI0_CDPHY_L2_T1_FORCE_INIT_MASK (0x1 << 26)
+#define RG_CSI0_CDPHY_L0_T0_SYNC_INIT_CTRL_SHIFT 28
+#define RG_CSI0_CDPHY_L0_T0_SYNC_INIT_CTRL_MASK (0x1 << 28)
+#define RG_CSI0_DPHY_L1_SYNC_INIT_CTRL_SHIFT 29
+#define RG_CSI0_DPHY_L1_SYNC_INIT_CTRL_MASK (0x1 << 29)
+#define RG_CSI0_CDPHY_L2_T1_SYNC_INIT_CTRL_SHIFT 30
+#define RG_CSI0_CDPHY_L2_T1_SYNC_INIT_CTRL_MASK (0x1 << 30)
+#define RG_CSI0_FORCE_HSRT_EN_SHIFT 31
+#define RG_CSI0_FORCE_HSRT_EN_MASK (0x1 << 31)
+
+#define CDPHY_RX_ANA_1 0x0004
+#define RG_CSI0_BG_LPRX_VTL_SEL_SHIFT 0
+#define RG_CSI0_BG_LPRX_VTL_SEL_MASK (0x7 << 0)
+#define RG_CSI0_BG_LPRX_VTH_SEL_SHIFT 4
+#define RG_CSI0_BG_LPRX_VTH_SEL_MASK (0x7 << 4)
+#define RG_CSI0_BG_VREF_SEL_SHIFT 8
+#define RG_CSI0_BG_VREF_SEL_MASK (0xf << 8)
+#define RG_CSI0_CDPHY_DELAYCAL_CK_SEL_SHIFT 12
+#define RG_CSI0_CDPHY_DELAYCAL_CK_SEL_MASK (0x7 << 12)
+#define RG_CSI0_CDPHY_EQ_DES_VREF_SEL_SHIFT 16
+#define RG_CSI0_CDPHY_EQ_DES_VREF_SEL_MASK (0x7 << 16)
+#define RG_CSI0_CDPHY_DELAY_VREF_SEL_SHIFT 20
+#define RG_CSI0_CDPHY_DELAY_VREF_SEL_MASK (0x7 << 20)
+#define RG_CSI0_DPHY_L0_DELAYCAL_EN_SHIFT 24
+#define RG_CSI0_DPHY_L0_DELAYCAL_EN_MASK (0x1 << 24)
+#define RG_CSI0_DPHY_L1_DELAYCAL_EN_SHIFT 25
+#define RG_CSI0_DPHY_L1_DELAYCAL_EN_MASK (0x1 << 25)
+#define RG_CSI0_DPHY_L2_DELAYCAL_EN_SHIFT 26
+#define RG_CSI0_DPHY_L2_DELAYCAL_EN_MASK (0x1 << 26)
+#define RG_CSI0_DPHY_L0_DELAYCAL_RSTB_SHIFT 28
+#define RG_CSI0_DPHY_L0_DELAYCAL_RSTB_MASK (0x1 << 28)
+#define RG_CSI0_DPHY_L1_DELAYCAL_RSTB_SHIFT 29
+#define RG_CSI0_DPHY_L1_DELAYCAL_RSTB_MASK (0x1 << 29)
+#define RG_CSI0_DPHY_L2_DELAYCAL_RSTB_SHIFT 30
+#define RG_CSI0_DPHY_L2_DELAYCAL_RSTB_MASK (0x1 << 30)
+
+#define CDPHY_RX_ANA_2 0x0008
+#define RG_CSI0_L0P_T0A_HSRT_CODE_SHIFT 0
+#define RG_CSI0_L0P_T0A_HSRT_CODE_MASK (0x1f << 0)
+#define RG_CSI0_L0N_T0B_HSRT_CODE_SHIFT 8
+#define RG_CSI0_L0N_T0B_HSRT_CODE_MASK (0x1f << 8)
+#define RG_CSI0_CPHY_T0_CDR_SELF_CAL_EN_SHIFT 16
+#define RG_CSI0_CPHY_T0_CDR_SELF_CAL_EN_MASK (0x1 << 16)
+#define RG_CSI0_CPHY_T1_CDR_SELF_CAL_EN_SHIFT 17
+#define RG_CSI0_CPHY_T1_CDR_SELF_CAL_EN_MASK (0x1 << 17)
+#define RG_CSI0_BG_ALP_RX_VTH_SEL_SHIFT 24
+#define RG_CSI0_BG_ALP_RX_VTH_SEL_MASK (0x7 << 24)
+#define RG_CSI0_BG_ALP_RX_VTL_SEL_SHIFT 28
+#define RG_CSI0_BG_ALP_RX_VTL_SEL_MASK (0x7 << 28)
+
+#define CDPHY_RX_ANA_3 0x000c
+#define RG_CSI0_L1P_T0C_HSRT_CODE_SHIFT 0
+#define RG_CSI0_L1P_T0C_HSRT_CODE_MASK (0x1f << 0)
+#define RG_CSI0_L1N_T1A_HSRT_CODE_SHIFT 8
+#define RG_CSI0_L1N_T1A_HSRT_CODE_MASK (0x1f << 8)
+#define RG_CSI0_OS_CAL_CNT_SEL_SHIFT 16
+#define RG_CSI0_OS_CAL_CNT_SEL_MASK (0x3 << 16)
+#define RG_CSI0_EQ_DES_VREF_SEL_SHIFT 20
+#define RG_CSI0_EQ_DES_VREF_SEL_MASK (0x3f << 20)
+
+#define CDPHY_RX_ANA_4 0x0010
+#define RG_CSI0_L2P_T1B_HSRT_CODE_SHIFT 0
+#define RG_CSI0_L2P_T1B_HSRT_CODE_MASK (0x1f << 0)
+#define RG_CSI0_L2N_T1C_HSRT_CODE_SHIFT 8
+#define RG_CSI0_L2N_T1C_HSRT_CODE_MASK (0x1f << 8)
+
+#define CDPHY_RX_ANA_5 0x0014
+#define RG_CSI0_CDPHY_EQ_BW_SHIFT 0
+#define RG_CSI0_CDPHY_EQ_BW_MASK (0x3 << 0)
+#define RG_CSI0_CDPHY_EQ_IS_SHIFT 2
+#define RG_CSI0_CDPHY_EQ_IS_MASK (0x3 << 2)
+#define RG_CSI0_CDPHY_EQ_DG0_EN_SHIFT 4
+#define RG_CSI0_CDPHY_EQ_DG0_EN_MASK (0x1 << 4)
+#define RG_CSI0_CDPHY_EQ_DG1_EN_SHIFT 5
+#define RG_CSI0_CDPHY_EQ_DG1_EN_MASK (0x1 << 5)
+#define RG_CSI0_CDPHY_EQ_LATCH_EN_SHIFT 6
+#define RG_CSI0_CDPHY_EQ_LATCH_EN_MASK (0x1 << 6)
+#define RG_CSI0_CDPHY_EQ_SR0_SHIFT 8
+#define RG_CSI0_CDPHY_EQ_SR0_MASK (0xf << 8)
+#define RG_CSI0_CDPHY_EQ_SR1_SHIFT 12
+#define RG_CSI0_CDPHY_EQ_SR1_MASK (0xf << 12)
+#define RG_CSI0_L0_T0AB_EQ_MON_EN_SHIFT 16
+#define RG_CSI0_L0_T0AB_EQ_MON_EN_MASK (0x1 << 16)
+#define RG_CSI0_L1_T1AB_EQ_MON_EN_SHIFT 17
+#define RG_CSI0_L1_T1AB_EQ_MON_EN_MASK (0x1 << 17)
+#define RG_CSI0_L2_T1BC_EQ_MON_EN_SHIFT 18
+#define RG_CSI0_L2_T1BC_EQ_MON_EN_MASK (0x1 << 18)
+#define RG_CSI0_XX_T0BC_EQ_MON_EN_SHIFT 24
+#define RG_CSI0_XX_T0BC_EQ_MON_EN_MASK (0x1 << 24)
+#define RG_CSI0_XX_T0CA_EQ_MON_EN_SHIFT 25
+#define RG_CSI0_XX_T0CA_EQ_MON_EN_MASK (0x1 << 25)
+#define RG_CSI0_XX_T1CA_EQ_MON_EN_SHIFT 26
+#define RG_CSI0_XX_T1CA_EQ_MON_EN_MASK (0x1 << 26)
+
+#define CDPHY_RX_ANA_6 0x0018
+#define RG_CSI0_CPHY_T0_CDR_AB_WIDTH_SHIFT 0
+#define RG_CSI0_CPHY_T0_CDR_AB_WIDTH_MASK (0x3f << 0)
+#define RG_CSI0_CPHY_T0_CDR_BC_WIDTH_SHIFT 8
+#define RG_CSI0_CPHY_T0_CDR_BC_WIDTH_MASK (0x3f << 8)
+#define RG_CSI0_CPHY_T0_CDR_CA_WIDTH_SHIFT 16
+#define RG_CSI0_CPHY_T0_CDR_CA_WIDTH_MASK (0x3f << 16)
+#define RG_CSI0_CPHY_T0_CDR_CK_DELAY_SHIFT 24
+#define RG_CSI0_CPHY_T0_CDR_CK_DELAY_MASK (0x3f << 24)
+
+#define CDPHY_RX_ANA_7 0x001c
+#define RG_CSI0_CPHY_T1_CDR_AB_WIDTH_SHIFT 0
+#define RG_CSI0_CPHY_T1_CDR_AB_WIDTH_MASK (0x3f << 0)
+#define RG_CSI0_CPHY_T1_CDR_BC_WIDTH_SHIFT 8
+#define RG_CSI0_CPHY_T1_CDR_BC_WIDTH_MASK (0x3f << 8)
+#define RG_CSI0_CPHY_T1_CDR_CA_WIDTH_SHIFT 16
+#define RG_CSI0_CPHY_T1_CDR_CA_WIDTH_MASK (0x3f << 16)
+#define RG_CSI0_CPHY_T1_CDR_CK_DELAY_SHIFT 24
+#define RG_CSI0_CPHY_T1_CDR_CK_DELAY_MASK (0x3f << 24)
+
+#define CDPHY_RX_ANA_8 0x0020
+#define RGS_CSI0_CDPHY_L0_T0AB_OS_CAL_CPLT_SHIFT 0
+#define RGS_CSI0_CDPHY_L0_T0AB_OS_CAL_CPLT_MASK (0x1 << 0)
+#define RGS_CSI0_CDPHY_L1_T1AB_OS_CAL_CPLT_SHIFT 1
+#define RGS_CSI0_CDPHY_L1_T1AB_OS_CAL_CPLT_MASK (0x1 << 1)
+#define RGS_CSI0_CDPHY_L2_T1BC_OS_CAL_CPLT_SHIFT 2
+#define RGS_CSI0_CDPHY_L2_T1BC_OS_CAL_CPLT_MASK (0x1 << 2)
+#define RGS_CSI0_CPHY_T0BC_OS_CAL_CPLT_SHIFT 3
+#define RGS_CSI0_CPHY_T0BC_OS_CAL_CPLT_MASK (0x1 << 3)
+#define RGS_CSI0_CPHY_T0CA_OS_CAL_CPLT_SHIFT 4
+#define RGS_CSI0_CPHY_T0CA_OS_CAL_CPLT_MASK (0x1 << 4)
+#define RGS_CSI0_CPHY_T1CA_OS_CAL_CPLT_SHIFT 5
+#define RGS_CSI0_CPHY_T1CA_OS_CAL_CPLT_MASK (0x1 << 5)
+#define RGS_CSI0_OS_CAL_CODE_SHIFT 8
+#define RGS_CSI0_OS_CAL_CODE_MASK (0xff << 8)
+#define RG_CSI0_L0_T0AB_EQ_OS_CAL_EN_SHIFT 16
+#define RG_CSI0_L0_T0AB_EQ_OS_CAL_EN_MASK (0x1 << 16)
+#define RG_CSI0_L1_T1AB_EQ_OS_CAL_EN_SHIFT 17
+#define RG_CSI0_L1_T1AB_EQ_OS_CAL_EN_MASK (0x1 << 17)
+#define RG_CSI0_L2_T1BC_EQ_OS_CAL_EN_SHIFT 18
+#define RG_CSI0_L2_T1BC_EQ_OS_CAL_EN_MASK (0x1 << 18)
+#define RG_CSI0_XX_T0BC_EQ_OS_CAL_EN_SHIFT 19
+#define RG_CSI0_XX_T0BC_EQ_OS_CAL_EN_MASK (0x1 << 19)
+#define RG_CSI0_XX_T0CA_EQ_OS_CAL_EN_SHIFT 20
+#define RG_CSI0_XX_T0CA_EQ_OS_CAL_EN_MASK (0x1 << 20)
+#define RG_CSI0_XX_T1CA_EQ_OS_CAL_EN_SHIFT 21
+#define RG_CSI0_XX_T1CA_EQ_OS_CAL_EN_MASK (0x1 << 21)
+#define RG_CSI0_OS_CAL_SEL_SHIFT 24
+#define RG_CSI0_OS_CAL_SEL_MASK (0x7 << 24)
+#define RG_CSI0_OS_CAL_DIV_SHIFT 28
+#define RG_CSI0_OS_CAL_DIV_MASK (0x7 << 28)
+
+#define CDPHY_RX_ANA_9 0x0024
+#define RGS_CSI0_CPHY_T0_DLL_CODE_SHIFT 0
+#define RGS_CSI0_CPHY_T0_DLL_CODE_MASK (0xf << 0)
+#define RGS_CSI0_CPHY_T0_MASK_CAL_CPLT_SHIFT 4
+#define RGS_CSI0_CPHY_T0_MASK_CAL_CPLT_MASK (0x1 << 4)
+#define RGS_CSI0_CPHY_T0_MASK_CAL_OF_SHIFT 5
+#define RGS_CSI0_CPHY_T0_MASK_CAL_OF_MASK (0x1 << 5)
+#define RGS_CSI0_CPHY_T1_DLL_CODE_SHIFT 8
+#define RGS_CSI0_CPHY_T1_DLL_CODE_MASK (0xf << 8)
+#define RGS_CSI0_CPHY_T1_MASK_CAL_CPLT_SHIFT 12
+#define RGS_CSI0_CPHY_T1_MASK_CAL_CPLT_MASK (0x1 << 12)
+#define RGS_CSI0_CPHY_T1_MASK_CAL_OF_SHIFT 13
+#define RGS_CSI0_CPHY_T1_MASK_CAL_OF_MASK (0x1 << 13)
+#define RG_CSI0_RESERVE_SHIFT 16
+#define RG_CSI0_RESERVE_MASK (0xffff << 16)
+
+#define CDPHY_RX_ANA_FORCE_MODE_0 0x0040
+#define RG_SW_FORCE_VAL_DA_CSI0_CDPHY_L0P_T0A_LPRX_EN_SHIFT 0
+#define RG_SW_FORCE_VAL_DA_CSI0_CDPHY_L0P_T0A_LPRX_EN_MASK (0x1 << 0)
+#define RG_SW_FORCE_VAL_DA_CSI0_CDPHY_L0N_T0B_LPRX_EN_SHIFT 1
+#define RG_SW_FORCE_VAL_DA_CSI0_CDPHY_L0N_T0B_LPRX_EN_MASK (0x1 << 1)
+#define RG_SW_FORCE_VAL_DA_CSI0_CDPHY_L1P_T0C_LPRX_EN_SHIFT 4
+#define RG_SW_FORCE_VAL_DA_CSI0_CDPHY_L1P_T0C_LPRX_EN_MASK (0x1 << 4)
+#define RG_SW_FORCE_VAL_DA_CSI0_CDPHY_L1N_T1A_LPRX_EN_SHIFT 5
+#define RG_SW_FORCE_VAL_DA_CSI0_CDPHY_L1N_T1A_LPRX_EN_MASK (0x1 << 5)
+#define RG_SW_FORCE_VAL_DA_CSI0_CDPHY_L2P_T1B_LPRX_EN_SHIFT 8
+#define RG_SW_FORCE_VAL_DA_CSI0_CDPHY_L2P_T1B_LPRX_EN_MASK (0x1 << 8)
+#define RG_SW_FORCE_VAL_DA_CSI0_CDPHY_L2N_T1C_LPRX_EN_SHIFT 9
+#define RG_SW_FORCE_VAL_DA_CSI0_CDPHY_L2N_T1C_LPRX_EN_MASK (0x1 << 9)
+#define RO_DA_CSI0_CDPHY_L0P_T0A_LPRX_EN_SHIFT 16
+#define RO_DA_CSI0_CDPHY_L0P_T0A_LPRX_EN_MASK (0x1 << 16)
+#define RO_DA_CSI0_CDPHY_L0N_T0B_LPRX_EN_SHIFT 17
+#define RO_DA_CSI0_CDPHY_L0N_T0B_LPRX_EN_MASK (0x1 << 17)
+#define RO_DA_CSI0_CDPHY_L1P_T0C_LPRX_EN_SHIFT 20
+#define RO_DA_CSI0_CDPHY_L1P_T0C_LPRX_EN_MASK (0x1 << 20)
+#define RO_DA_CSI0_CDPHY_L1N_T1A_LPRX_EN_SHIFT 21
+#define RO_DA_CSI0_CDPHY_L1N_T1A_LPRX_EN_MASK (0x1 << 21)
+#define RO_DA_CSI0_CDPHY_L2P_T1B_LPRX_EN_SHIFT 24
+#define RO_DA_CSI0_CDPHY_L2P_T1B_LPRX_EN_MASK (0x1 << 24)
+#define RO_DA_CSI0_CDPHY_L2N_T1C_LPRX_EN_SHIFT 25
+#define RO_DA_CSI0_CDPHY_L2N_T1C_LPRX_EN_MASK (0x1 << 25)
+
+#define CDPHY_RX_ANA_FORCE_MODE_EN_0 0x0044
+#define RG_SW_FORCE_EN_DA_CSI0_CDPHY_L0P_T0A_LPRX_EN_SHIFT 0
+#define RG_SW_FORCE_EN_DA_CSI0_CDPHY_L0P_T0A_LPRX_EN_MASK (0x1 << 0)
+#define RG_SW_FORCE_EN_DA_CSI0_CDPHY_L0N_T0B_LPRX_EN_SHIFT 1
+#define RG_SW_FORCE_EN_DA_CSI0_CDPHY_L0N_T0B_LPRX_EN_MASK (0x1 << 1)
+#define RG_SW_FORCE_EN_DA_CSI0_CDPHY_L1P_T0C_LPRX_EN_SHIFT 4
+#define RG_SW_FORCE_EN_DA_CSI0_CDPHY_L1P_T0C_LPRX_EN_MASK (0x1 << 4)
+#define RG_SW_FORCE_EN_DA_CSI0_CDPHY_L1N_T1A_LPRX_EN_SHIFT 5
+#define RG_SW_FORCE_EN_DA_CSI0_CDPHY_L1N_T1A_LPRX_EN_MASK (0x1 << 5)
+#define RG_SW_FORCE_EN_DA_CSI0_CDPHY_L2P_T1B_LPRX_EN_SHIFT 8
+#define RG_SW_FORCE_EN_DA_CSI0_CDPHY_L2P_T1B_LPRX_EN_MASK (0x1 << 8)
+#define RG_SW_FORCE_EN_DA_CSI0_CDPHY_L2N_T1C_LPRX_EN_SHIFT 9
+#define RG_SW_FORCE_EN_DA_CSI0_CDPHY_L2N_T1C_LPRX_EN_MASK (0x1 << 9)
+
+#define CDPHY_RX_ANA_AD_0 0x0048
+#define RO_AD_CSI0_CDPHY_L0P_T0A_LPRX_OUT_SHIFT 0
+#define RO_AD_CSI0_CDPHY_L0P_T0A_LPRX_OUT_MASK (0x1 << 0)
+#define RO_AD_CSI0_CDPHY_L0N_T0B_LPRX_OUT_SHIFT 1
+#define RO_AD_CSI0_CDPHY_L0N_T0B_LPRX_OUT_MASK (0x1 << 1)
+#define RO_AD_CSI0_CDPHY_L1P_T0C_LPRX_OUT_SHIFT 4
+#define RO_AD_CSI0_CDPHY_L1P_T0C_LPRX_OUT_MASK (0x1 << 4)
+#define RO_AD_CSI0_CDPHY_L1N_T1A_LPRX_OUT_SHIFT 5
+#define RO_AD_CSI0_CDPHY_L1N_T1A_LPRX_OUT_MASK (0x1 << 5)
+#define RO_AD_CSI0_CDPHY_L2P_T1B_LPRX_OUT_SHIFT 8
+#define RO_AD_CSI0_CDPHY_L2P_T1B_LPRX_OUT_MASK (0x1 << 8)
+#define RO_AD_CSI0_CDPHY_L2N_T1C_LPRX_OUT_SHIFT 9
+#define RO_AD_CSI0_CDPHY_L2N_T1C_LPRX_OUT_MASK (0x1 << 9)
+
+#define CDPHY_RX_ANA_FORCE_MODE_1 0x0050
+#define RG_SW_FORCE_VAL_DA_CSI0_DPHY_L0_ALPRX_EN_SHIFT 0
+#define RG_SW_FORCE_VAL_DA_CSI0_DPHY_L0_ALPRX_EN_MASK (0x1 << 0)
+#define RG_SW_FORCE_VAL_DA_CSI0_DPHY_L1_ALPRX_EN_SHIFT 4
+#define RG_SW_FORCE_VAL_DA_CSI0_DPHY_L1_ALPRX_EN_MASK (0x1 << 4)
+#define RG_SW_FORCE_VAL_DA_CSI0_DPHY_L2_ALPRX_EN_SHIFT 8
+#define RG_SW_FORCE_VAL_DA_CSI0_DPHY_L2_ALPRX_EN_MASK (0x1 << 8)
+#define RO_DA_CSI0_DPHY_L0_ALPRX_EN_SHIFT 16
+#define RO_DA_CSI0_DPHY_L0_ALPRX_EN_MASK (0x1 << 16)
+#define RO_DA_CSI0_DPHY_L1_ALPRX_EN_SHIFT 20
+#define RO_DA_CSI0_DPHY_L1_ALPRX_EN_MASK (0x1 << 20)
+#define RO_DA_CSI0_DPHY_L2_ALPRX_EN_SHIFT 24
+#define RO_DA_CSI0_DPHY_L2_ALPRX_EN_MASK (0x1 << 24)
+
+#define CDPHY_RX_ANA_FORCE_MODE_EN_1 0x0054
+#define RG_SW_FORCE_EN_DA_CSI0_DPHY_L0_ALPRX_EN_SHIFT 0
+#define RG_SW_FORCE_EN_DA_CSI0_DPHY_L0_ALPRX_EN_MASK (0x1 << 0)
+#define RG_SW_FORCE_EN_DA_CSI0_DPHY_L1_ALPRX_EN_SHIFT 4
+#define RG_SW_FORCE_EN_DA_CSI0_DPHY_L1_ALPRX_EN_MASK (0x1 << 4)
+#define RG_SW_FORCE_EN_DA_CSI0_DPHY_L2_ALPRX_EN_SHIFT 8
+#define RG_SW_FORCE_EN_DA_CSI0_DPHY_L2_ALPRX_EN_MASK (0x1 << 8)
+
+#define CDPHY_RX_ANA_AD_1 0x0058
+#define RO_AD_CSI0_DPHY_L0_ALPRX_OUT_SHIFT 0
+#define RO_AD_CSI0_DPHY_L0_ALPRX_OUT_MASK (0x1 << 0)
+#define RO_AD_CSI0_DPHY_L1_ALPRX_OUT_SHIFT 4
+#define RO_AD_CSI0_DPHY_L1_ALPRX_OUT_MASK (0x1 << 4)
+#define RO_AD_CSI0_DPHY_L2_ALPRX_OUT_SHIFT 8
+#define RO_AD_CSI0_DPHY_L2_ALPRX_OUT_MASK (0x1 << 8)
+
+#define CDPHY_RX_ANA_FORCE_MODE_2 0x0060
+#define RG_SW_FORCE_VAL_DA_CSI0_CDPHY_L0P_T0A_HSRT_EN_SHIFT 0
+#define RG_SW_FORCE_VAL_DA_CSI0_CDPHY_L0P_T0A_HSRT_EN_MASK (0x1 << 0)
+#define RG_SW_FORCE_VAL_DA_CSI0_CDPHY_L0N_T0B_HSRT_EN_SHIFT 1
+#define RG_SW_FORCE_VAL_DA_CSI0_CDPHY_L0N_T0B_HSRT_EN_MASK (0x1 << 1)
+#define RG_SW_FORCE_VAL_DA_CSI0_CDPHY_L1P_T0C_HSRT_EN_SHIFT 4
+#define RG_SW_FORCE_VAL_DA_CSI0_CDPHY_L1P_T0C_HSRT_EN_MASK (0x1 << 4)
+#define RG_SW_FORCE_VAL_DA_CSI0_CDPHY_L1N_T1A_HSRT_EN_SHIFT 5
+#define RG_SW_FORCE_VAL_DA_CSI0_CDPHY_L1N_T1A_HSRT_EN_MASK (0x1 << 5)
+#define RG_SW_FORCE_VAL_DA_CSI0_CDPHY_L2P_T1B_HSRT_EN_SHIFT 8
+#define RG_SW_FORCE_VAL_DA_CSI0_CDPHY_L2P_T1B_HSRT_EN_MASK (0x1 << 8)
+#define RG_SW_FORCE_VAL_DA_CSI0_CDPHY_L2N_T1C_HSRT_EN_SHIFT 9
+#define RG_SW_FORCE_VAL_DA_CSI0_CDPHY_L2N_T1C_HSRT_EN_MASK (0x1 << 9)
+#define RO_DA_CSI0_CDPHY_L0P_T0A_HSRT_EN_SHIFT 16
+#define RO_DA_CSI0_CDPHY_L0P_T0A_HSRT_EN_MASK (0x1 << 16)
+#define RO_DA_CSI0_CDPHY_L0N_T0B_HSRT_EN_SHIFT 17
+#define RO_DA_CSI0_CDPHY_L0N_T0B_HSRT_EN_MASK (0x1 << 17)
+#define RO_DA_CSI0_CDPHY_L1P_T0C_HSRT_EN_SHIFT 20
+#define RO_DA_CSI0_CDPHY_L1P_T0C_HSRT_EN_MASK (0x1 << 20)
+#define RO_DA_CSI0_CDPHY_L1N_T1A_HSRT_EN_SHIFT 21
+#define RO_DA_CSI0_CDPHY_L1N_T1A_HSRT_EN_MASK (0x1 << 21)
+#define RO_DA_CSI0_CDPHY_L2P_T1B_HSRT_EN_SHIFT 24
+#define RO_DA_CSI0_CDPHY_L2P_T1B_HSRT_EN_MASK (0x1 << 24)
+#define RO_DA_CSI0_CDPHY_L2N_T1C_HSRT_EN_SHIFT 25
+#define RO_DA_CSI0_CDPHY_L2N_T1C_HSRT_EN_MASK (0x1 << 25)
+
+#define CDPHY_RX_ANA_FORCE_MODE_EN_2 0x0064
+#define RG_SW_FORCE_EN_DA_CSI0_CDPHY_L0P_T0A_HSRT_EN_SHIFT 0
+#define RG_SW_FORCE_EN_DA_CSI0_CDPHY_L0P_T0A_HSRT_EN_MASK (0x1 << 0)
+#define RG_SW_FORCE_EN_DA_CSI0_CDPHY_L0N_T0B_HSRT_EN_SHIFT 1
+#define RG_SW_FORCE_EN_DA_CSI0_CDPHY_L0N_T0B_HSRT_EN_MASK (0x1 << 1)
+#define RG_SW_FORCE_EN_DA_CSI0_CDPHY_L1P_T0C_HSRT_EN_SHIFT 4
+#define RG_SW_FORCE_EN_DA_CSI0_CDPHY_L1P_T0C_HSRT_EN_MASK (0x1 << 4)
+#define RG_SW_FORCE_EN_DA_CSI0_CDPHY_L1N_T1A_HSRT_EN_SHIFT 5
+#define RG_SW_FORCE_EN_DA_CSI0_CDPHY_L1N_T1A_HSRT_EN_MASK (0x1 << 5)
+#define RG_SW_FORCE_EN_DA_CSI0_CDPHY_L2P_T1B_HSRT_EN_SHIFT 8
+#define RG_SW_FORCE_EN_DA_CSI0_CDPHY_L2P_T1B_HSRT_EN_MASK (0x1 << 8)
+#define RG_SW_FORCE_EN_DA_CSI0_CDPHY_L2N_T1C_HSRT_EN_SHIFT 9
+#define RG_SW_FORCE_EN_DA_CSI0_CDPHY_L2N_T1C_HSRT_EN_MASK (0x1 << 9)
+
+#define CDPHY_RX_ANA_FORCE_MODE_3 0x0070
+#define RG_SW_FORCE_VAL_DA_CSI0_CDPHY_L0_T0AB_EQ_EN_SHIFT 0
+#define RG_SW_FORCE_VAL_DA_CSI0_CDPHY_L0_T0AB_EQ_EN_MASK (0x1 << 0)
+#define RG_SW_FORCE_VAL_DA_CSI0_CPHY_T0CA_EQ_EN_SHIFT 1
+#define RG_SW_FORCE_VAL_DA_CSI0_CPHY_T0CA_EQ_EN_MASK (0x1 << 1)
+#define RG_SW_FORCE_VAL_DA_CSI0_CPHY_T0BC_EQ_EN_SHIFT 4
+#define RG_SW_FORCE_VAL_DA_CSI0_CPHY_T0BC_EQ_EN_MASK (0x1 << 4)
+#define RG_SW_FORCE_VAL_DA_CSI0_CDPHY_L1_T1AB_EQ_EN_SHIFT 5
+#define RG_SW_FORCE_VAL_DA_CSI0_CDPHY_L1_T1AB_EQ_EN_MASK (0x1 << 5)
+#define RG_SW_FORCE_VAL_DA_CSI0_CPHY_T1CA_EQ_EN_SHIFT 8
+#define RG_SW_FORCE_VAL_DA_CSI0_CPHY_T1CA_EQ_EN_MASK (0x1 << 8)
+#define RG_SW_FORCE_VAL_DA_CSI0_CDPHY_L2_T1BC_EQ_EN_SHIFT 9
+#define RG_SW_FORCE_VAL_DA_CSI0_CDPHY_L2_T1BC_EQ_EN_MASK (0x1 << 9)
+#define RO_DA_CSI0_CDPHY_L0_T0AB_EQ_EN_SHIFT 16
+#define RO_DA_CSI0_CDPHY_L0_T0AB_EQ_EN_MASK (0x1 << 16)
+#define RO_DA_CSI0_CPHY_T0CA_EQ_EN_SHIFT 17
+#define RO_DA_CSI0_CPHY_T0CA_EQ_EN_MASK (0x1 << 17)
+#define RO_DA_CSI0_CPHY_T0BC_EQ_EN_SHIFT 20
+#define RO_DA_CSI0_CPHY_T0BC_EQ_EN_MASK (0x1 << 20)
+#define RO_DA_CSI0_CDPHY_L1_T1AB_EQ_EN_SHIFT 21
+#define RO_DA_CSI0_CDPHY_L1_T1AB_EQ_EN_MASK (0x1 << 21)
+#define RO_DA_CSI0_CPHY_T1CA_EQ_EN_SHIFT 24
+#define RO_DA_CSI0_CPHY_T1CA_EQ_EN_MASK (0x1 << 24)
+#define RO_DA_CSI0_CDPHY_L2_T1BC_EQ_EN_SHIFT 25
+#define RO_DA_CSI0_CDPHY_L2_T1BC_EQ_EN_MASK (0x1 << 25)
+
+#define CDPHY_RX_ANA_FORCE_MODE_EN_3 0x0074
+#define RG_SW_FORCE_EN_DA_CSI0_CDPHY_L0_T0AB_EQ_EN_SHIFT 0
+#define RG_SW_FORCE_EN_DA_CSI0_CDPHY_L0_T0AB_EQ_EN_MASK (0x1 << 0)
+#define RG_SW_FORCE_EN_DA_CSI0_CPHY_T0CA_EQ_EN_SHIFT 1
+#define RG_SW_FORCE_EN_DA_CSI0_CPHY_T0CA_EQ_EN_MASK (0x1 << 1)
+#define RG_SW_FORCE_EN_DA_CSI0_CPHY_T0BC_EQ_EN_SHIFT 4
+#define RG_SW_FORCE_EN_DA_CSI0_CPHY_T0BC_EQ_EN_MASK (0x1 << 4)
+#define RG_SW_FORCE_EN_DA_CSI0_CDPHY_L1_T1AB_EQ_EN_SHIFT 5
+#define RG_SW_FORCE_EN_DA_CSI0_CDPHY_L1_T1AB_EQ_EN_MASK (0x1 << 5)
+#define RG_SW_FORCE_EN_DA_CSI0_CPHY_T1CA_EQ_EN_SHIFT 8
+#define RG_SW_FORCE_EN_DA_CSI0_CPHY_T1CA_EQ_EN_MASK (0x1 << 8)
+#define RG_SW_FORCE_EN_DA_CSI0_CDPHY_L2_T1BC_EQ_EN_SHIFT 9
+#define RG_SW_FORCE_EN_DA_CSI0_CDPHY_L2_T1BC_EQ_EN_MASK (0x1 << 9)
+
+#define CDPHY_RX_ANA_FORCE_MODE_4 0x0080
+#define RG_SW_FORCE_VAL_DA_CSI0_DPHY_L0_SAMP_EN_SHIFT 0
+#define RG_SW_FORCE_VAL_DA_CSI0_DPHY_L0_SAMP_EN_MASK (0x1 << 0)
+#define RG_SW_FORCE_VAL_DA_CSI0_CPHY_T0_CDR_EN_SHIFT 1
+#define RG_SW_FORCE_VAL_DA_CSI0_CPHY_T0_CDR_EN_MASK (0x1 << 1)
+#define RG_SW_FORCE_VAL_DA_CSI0_DPHY_L1_SAMP_EN_SHIFT 4
+#define RG_SW_FORCE_VAL_DA_CSI0_DPHY_L1_SAMP_EN_MASK (0x1 << 4)
+#define RG_SW_FORCE_VAL_DA_CSI0_CPHY_T1_CDR_EN_SHIFT 5
+#define RG_SW_FORCE_VAL_DA_CSI0_CPHY_T1_CDR_EN_MASK (0x1 << 5)
+#define RG_SW_FORCE_VAL_DA_CSI0_DPHY_L2_SAMP_EN_SHIFT 8
+#define RG_SW_FORCE_VAL_DA_CSI0_DPHY_L2_SAMP_EN_MASK (0x1 << 8)
+#define RO_DA_CSI0_DPHY_L0_SAMP_EN_SHIFT 16
+#define RO_DA_CSI0_DPHY_L0_SAMP_EN_MASK (0x1 << 16)
+#define RO_DA_CSI0_CPHY_T0_CDR_EN_SHIFT 17
+#define RO_DA_CSI0_CPHY_T0_CDR_EN_MASK (0x1 << 17)
+#define RO_DA_CSI0_DPHY_L1_SAMP_EN_SHIFT 20
+#define RO_DA_CSI0_DPHY_L1_SAMP_EN_MASK (0x1 << 20)
+#define RO_DA_CSI0_CPHY_T1_CDR_EN_SHIFT 21
+#define RO_DA_CSI0_CPHY_T1_CDR_EN_MASK (0x1 << 21)
+#define RO_DA_CSI0_DPHY_L2_SAMP_EN_SHIFT 24
+#define RO_DA_CSI0_DPHY_L2_SAMP_EN_MASK (0x1 << 24)
+
+#define CDPHY_RX_ANA_FORCE_MODE_EN_4 0x0084
+#define RG_SW_FORCE_EN_DA_CSI0_DPHY_L0_SAMP_EN_SHIFT 0
+#define RG_SW_FORCE_EN_DA_CSI0_DPHY_L0_SAMP_EN_MASK (0x1 << 0)
+#define RG_SW_FORCE_EN_DA_CSI0_CPHY_T0_CDR_EN_SHIFT 1
+#define RG_SW_FORCE_EN_DA_CSI0_CPHY_T0_CDR_EN_MASK (0x1 << 1)
+#define RG_SW_FORCE_EN_DA_CSI0_DPHY_L1_SAMP_EN_SHIFT 4
+#define RG_SW_FORCE_EN_DA_CSI0_DPHY_L1_SAMP_EN_MASK (0x1 << 4)
+#define RG_SW_FORCE_EN_DA_CSI0_CPHY_T1_CDR_EN_SHIFT 5
+#define RG_SW_FORCE_EN_DA_CSI0_CPHY_T1_CDR_EN_MASK (0x1 << 5)
+#define RG_SW_FORCE_EN_DA_CSI0_DPHY_L2_SAMP_EN_SHIFT 8
+#define RG_SW_FORCE_EN_DA_CSI0_DPHY_L2_SAMP_EN_MASK (0x1 << 8)
+
+#define CDPHY_RX_ANA_FORCE_MODE_5 0x0090
+#define RG_SW_FORCE_VAL_DA_CSI0_CDPHY_L0_T0_DES_EN_SHIFT 0
+#define RG_SW_FORCE_VAL_DA_CSI0_CDPHY_L0_T0_DES_EN_MASK (0x1 << 0)
+#define RG_SW_FORCE_VAL_DA_CSI0_DPHY_L1_DES_EN_SHIFT 1
+#define RG_SW_FORCE_VAL_DA_CSI0_DPHY_L1_DES_EN_MASK (0x1 << 1)
+#define RG_SW_FORCE_VAL_DA_CSI0_CDPHY_L2_T1_DES_EN_SHIFT 2
+#define RG_SW_FORCE_VAL_DA_CSI0_CDPHY_L2_T1_DES_EN_MASK (0x1 << 2)
+#define RG_SW_FORCE_VAL_DA_CSI0_CDPHY_L0_T0_DES_SYNC_INIT_SHIFT 8
+#define RG_SW_FORCE_VAL_DA_CSI0_CDPHY_L0_T0_DES_SYNC_INIT_MASK (0x1 << 8)
+#define RG_SW_FORCE_VAL_DA_CSI0_DPHY_L1_DES_SYNC_INIT_SHIFT 9
+#define RG_SW_FORCE_VAL_DA_CSI0_DPHY_L1_DES_SYNC_INIT_MASK (0x1 << 9)
+#define RG_SW_FORCE_VAL_DA_CSI0_CDPHY_L2_T1_DES_SYNC_INIT_SHIFT 10
+#define RG_SW_FORCE_VAL_DA_CSI0_CDPHY_L2_T1_DES_SYNC_INIT_MASK (0x1 << 10)
+#define RO_DA_CSI0_CDPHY_L0_T0_DES_EN_SHIFT 16
+#define RO_DA_CSI0_CDPHY_L0_T0_DES_EN_MASK (0x1 << 16)
+#define RO_DA_CSI0_DPHY_L1_DES_EN_SHIFT 17
+#define RO_DA_CSI0_DPHY_L1_DES_EN_MASK (0x1 << 17)
+#define RO_DA_CSI0_CDPHY_L2_T1_DES_EN_SHIFT 18
+#define RO_DA_CSI0_CDPHY_L2_T1_DES_EN_MASK (0x1 << 18)
+#define RO_DA_CSI0_CDPHY_L0_T0_DES_SYNC_INIT_SHIFT 24
+#define RO_DA_CSI0_CDPHY_L0_T0_DES_SYNC_INIT_MASK (0x1 << 24)
+#define RO_DA_CSI0_DPHY_L1_DES_SYNC_INIT_SHIFT 25
+#define RO_DA_CSI0_DPHY_L1_DES_SYNC_INIT_MASK (0x1 << 25)
+#define RO_DA_CSI0_CDPHY_L2_T1_DES_SYNC_INIT_SHIFT 26
+#define RO_DA_CSI0_CDPHY_L2_T1_DES_SYNC_INIT_MASK (0x1 << 26)
+
+#define CDPHY_RX_ANA_FORCE_MODE_EN_5 0x0094
+#define RG_SW_FORCE_EN_DA_CSI0_CDPHY_L0_T0_DES_EN_SHIFT 0
+#define RG_SW_FORCE_EN_DA_CSI0_CDPHY_L0_T0_DES_EN_MASK (0x1 << 0)
+#define RG_SW_FORCE_EN_DA_CSI0_DPHY_L1_DES_EN_SHIFT 1
+#define RG_SW_FORCE_EN_DA_CSI0_DPHY_L1_DES_EN_MASK (0x1 << 1)
+#define RG_SW_FORCE_EN_DA_CSI0_CDPHY_L2_T1_DES_EN_SHIFT 2
+#define RG_SW_FORCE_EN_DA_CSI0_CDPHY_L2_T1_DES_EN_MASK (0x1 << 2)
+#define RG_SW_FORCE_EN_DA_CSI0_CDPHY_L0_T0_DES_SYNC_INIT_SHIFT 8
+#define RG_SW_FORCE_EN_DA_CSI0_CDPHY_L0_T0_DES_SYNC_INIT_MASK (0x1 << 8)
+#define RG_SW_FORCE_EN_DA_CSI0_DPHY_L1_DES_SYNC_INIT_SHIFT 9
+#define RG_SW_FORCE_EN_DA_CSI0_DPHY_L1_DES_SYNC_INIT_MASK (0x1 << 9)
+#define RG_SW_FORCE_EN_DA_CSI0_CDPHY_L2_T1_DES_SYNC_INIT_SHIFT 10
+#define RG_SW_FORCE_EN_DA_CSI0_CDPHY_L2_T1_DES_SYNC_INIT_MASK (0x1 << 10)
+
+#define CDPHY_RX_ANA_AD_HS_0 0x00a0
+#define RO_AD_CSI0_CPHY_T0CA_SHIFT 0
+#define RO_AD_CSI0_CPHY_T0CA_MASK (0xff << 0)
+#define RO_AD_CSI0_CPHY_T0BC_SHIFT 8
+#define RO_AD_CSI0_CPHY_T0BC_MASK (0xff << 8)
+#define RO_AD_CSI0_CDPHY_L0_T0AB_SHIFT 16
+#define RO_AD_CSI0_CDPHY_L0_T0AB_MASK (0xff << 16)
+
+#define CDPHY_RX_ANA_AD_HS_1 0x00a4
+#define RO_AD_CSI0_DPHY_L1_SHIFT 16
+#define RO_AD_CSI0_DPHY_L1_MASK (0xff << 16)
+
+#define CDPHY_RX_ANA_AD_HS_2 0x00a8
+#define RO_AD_CSI0_CPHY_T1CA_SHIFT 8
+#define RO_AD_CSI0_CPHY_T1CA_MASK (0xff << 8)
+#define RO_AD_CSI0_CDPHY_L2_T1BC_SHIFT 16
+#define RO_AD_CSI0_CDPHY_L2_T1BC_MASK (0xff << 16)
+#define RO_AD_CSI0_CPHY_T1AB_SHIFT 24
+#define RO_AD_CSI0_CPHY_T1AB_MASK (0xff << 24)
+
+#define CDPHY_RX_ANA_FORCE_MODE_6 0x00b0
+#define RG_SW_FORCE_VAL_DA_CSI0_DPHY_L0_DELAY_CODE_SHIFT 0
+#define RG_SW_FORCE_VAL_DA_CSI0_DPHY_L0_DELAY_CODE_MASK (0x7f << 0)
+#define RG_SW_FORCE_VAL_DA_CSI0_DPHY_L0_DELAY_EN_SHIFT 8
+#define RG_SW_FORCE_VAL_DA_CSI0_DPHY_L0_DELAY_EN_MASK (0x1 << 8)
+#define RG_SW_FORCE_VAL_DA_CSI0_DPHY_L0_DELAY_APPLY_SHIFT 9
+#define RG_SW_FORCE_VAL_DA_CSI0_DPHY_L0_DELAY_APPLY_MASK (0x1 << 9)
+#define RO_DA_CSI0_DPHY_L0_DELAY_CODE_SHIFT 16
+#define RO_DA_CSI0_DPHY_L0_DELAY_CODE_MASK (0x7f << 16)
+#define RO_DA_CSI0_DPHY_L0_DELAY_EN_SHIFT 24
+#define RO_DA_CSI0_DPHY_L0_DELAY_EN_MASK (0x1 << 24)
+#define RO_DA_CSI0_DPHY_L0_DELAY_APPLY_SHIFT 25
+#define RO_DA_CSI0_DPHY_L0_DELAY_APPLY_MASK (0x1 << 25)
+
+#define CDPHY_RX_ANA_FORCE_MODE_EN_6 0x00b4
+#define RG_SW_FORCE_EN_DA_CSI0_DPHY_L0_DELAY_CODE_SHIFT 0
+#define RG_SW_FORCE_EN_DA_CSI0_DPHY_L0_DELAY_CODE_MASK (0x1 << 0)
+#define RG_SW_FORCE_EN_DA_CSI0_DPHY_L0_DELAY_EN_SHIFT 8
+#define RG_SW_FORCE_EN_DA_CSI0_DPHY_L0_DELAY_EN_MASK (0x1 << 8)
+#define RG_SW_FORCE_EN_DA_CSI0_DPHY_L0_DELAY_APPLY_SHIFT 9
+#define RG_SW_FORCE_EN_DA_CSI0_DPHY_L0_DELAY_APPLY_MASK (0x1 << 9)
+
+#define CDPHY_RX_ANA_FORCE_MODE_7 0x00c0
+#define RG_SW_FORCE_VAL_DA_CSI0_DPHY_L1_DELAY_CODE_SHIFT 0
+#define RG_SW_FORCE_VAL_DA_CSI0_DPHY_L1_DELAY_CODE_MASK (0x7f << 0)
+#define RG_SW_FORCE_VAL_DA_CSI0_DPHY_L1_DELAY_EN_SHIFT 8
+#define RG_SW_FORCE_VAL_DA_CSI0_DPHY_L1_DELAY_EN_MASK (0x1 << 8)
+#define RG_SW_FORCE_VAL_DA_CSI0_DPHY_L1_DELAY_APPLY_SHIFT 9
+#define RG_SW_FORCE_VAL_DA_CSI0_DPHY_L1_DELAY_APPLY_MASK (0x1 << 9)
+#define RO_DA_CSI0_DPHY_L1_DELAY_CODE_SHIFT 16
+#define RO_DA_CSI0_DPHY_L1_DELAY_CODE_MASK (0x7f << 16)
+#define RO_DA_CSI0_DPHY_L1_DELAY_EN_SHIFT 24
+#define RO_DA_CSI0_DPHY_L1_DELAY_EN_MASK (0x1 << 24)
+#define RO_DA_CSI0_DPHY_L1_DELAY_APPLY_SHIFT 25
+#define RO_DA_CSI0_DPHY_L1_DELAY_APPLY_MASK (0x1 << 25)
+
+#define CDPHY_RX_ANA_FORCE_MODE_EN_7 0x00c4
+#define RG_SW_FORCE_EN_DA_CSI0_DPHY_L1_DELAY_CODE_SHIFT 0
+#define RG_SW_FORCE_EN_DA_CSI0_DPHY_L1_DELAY_CODE_MASK (0x1 << 0)
+#define RG_SW_FORCE_EN_DA_CSI0_DPHY_L1_DELAY_EN_SHIFT 8
+#define RG_SW_FORCE_EN_DA_CSI0_DPHY_L1_DELAY_EN_MASK (0x1 << 8)
+#define RG_SW_FORCE_EN_DA_CSI0_DPHY_L1_DELAY_APPLY_SHIFT 9
+#define RG_SW_FORCE_EN_DA_CSI0_DPHY_L1_DELAY_APPLY_MASK (0x1 << 9)
+
+#define CDPHY_RX_ANA_FORCE_MODE_8 0x00d0
+#define RG_SW_FORCE_VAL_DA_CSI0_DPHY_L2_DELAY_CODE_SHIFT 0
+#define RG_SW_FORCE_VAL_DA_CSI0_DPHY_L2_DELAY_CODE_MASK (0x7f << 0)
+#define RG_SW_FORCE_VAL_DA_CSI0_DPHY_L2_DELAY_EN_SHIFT 8
+#define RG_SW_FORCE_VAL_DA_CSI0_DPHY_L2_DELAY_EN_MASK (0x1 << 8)
+#define RG_SW_FORCE_VAL_DA_CSI0_DPHY_L2_DELAY_APPLY_SHIFT 9
+#define RG_SW_FORCE_VAL_DA_CSI0_DPHY_L2_DELAY_APPLY_MASK (0x1 << 9)
+#define RO_DA_CSI0_DPHY_L2_DELAY_CODE_SHIFT 16
+#define RO_DA_CSI0_DPHY_L2_DELAY_CODE_MASK (0x7f << 16)
+#define RO_DA_CSI0_DPHY_L2_DELAY_EN_SHIFT 24
+#define RO_DA_CSI0_DPHY_L2_DELAY_EN_MASK (0x1 << 24)
+#define RO_DA_CSI0_DPHY_L2_DELAY_APPLY_SHIFT 25
+#define RO_DA_CSI0_DPHY_L2_DELAY_APPLY_MASK (0x1 << 25)
+
+#define CDPHY_RX_ANA_FORCE_MODE_EN_8 0x00d4
+#define RG_SW_FORCE_EN_DA_CSI0_DPHY_L2_DELAY_CODE_SHIFT 0
+#define RG_SW_FORCE_EN_DA_CSI0_DPHY_L2_DELAY_CODE_MASK (0x1 << 0)
+#define RG_SW_FORCE_EN_DA_CSI0_DPHY_L2_DELAY_EN_SHIFT 8
+#define RG_SW_FORCE_EN_DA_CSI0_DPHY_L2_DELAY_EN_MASK (0x1 << 8)
+#define RG_SW_FORCE_EN_DA_CSI0_DPHY_L2_DELAY_APPLY_SHIFT 9
+#define RG_SW_FORCE_EN_DA_CSI0_DPHY_L2_DELAY_APPLY_MASK (0x1 << 9)
+
+#define CDPHY_RX_ANA_SETTING_0 0x00f0
+#define CSR_CSI_CLK_MON_SHIFT 0
+#define CSR_CSI_CLK_MON_MASK (0x1 << 0)
+#define CSR_CSI_CLK_EN_SHIFT 1
+#define CSR_CSI_CLK_EN_MASK (0x1 << 1)
+#define CSR_ASYNC_FIFO_GATING_SEL_SHIFT 4
+#define CSR_ASYNC_FIFO_GATING_SEL_MASK (0xf << 4)
+#define CSR_CSI_MON_MUX_SHIFT 8
+#define CSR_CSI_MON_MUX_MASK (0xff << 8)
+#define CSR_CSI_RST_MODE_SHIFT 16
+#define CSR_CSI_RST_MODE_MASK (0x3 << 16)
+#define CSR_SW_RST_SHIFT 24
+#define CSR_SW_RST_MASK (0xf << 24)
+
+#define CDPHY_RX_ANA_SETTING_1 0x00f4
+#define RG_CSI0_CDPHY_FMCK_SEL_SHIFT 0
+#define RG_CSI0_CDPHY_FMCK_SEL_MASK (0x3 << 0)
+#define RG_CSI0_ASYNC_OPTION_SHIFT 4
+#define RG_CSI0_ASYNC_OPTION_MASK (0xf << 4)
+#define RG_CAL_METHOD_3S_SHIFT 8
+#define RG_CAL_METHOD_3S_MASK (0x1 << 8)
+#define RG_CSI0_CDPHY_SPARE_REG_SHIFT 16
+#define RG_CSI0_CDPHY_SPARE_REG_MASK (0xffff << 16)
+
+#define CDPHY_RX_ANA_DBG_OUT 0x00f8
+#define CSI_DEBUG_OUT_SHIFT 0
+#define CSI_DEBUG_OUT_MASK (0xffffffff << 0)
+
+#endif
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_csi_phy_2_0/mtk_cam-seninf-seninf1-csi2.h b/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_csi_phy_2_0/mtk_cam-seninf-seninf1-csi2.h
new file mode 100644
index 0000000000000000000000000000000000000000..b0e9a78f777ecc2b6429dc6d3aa7a5271cee83c3
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_csi_phy_2_0/mtk_cam-seninf-seninf1-csi2.h
@@ -0,0 +1,853 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2022 MediaTek Inc.
+ */
+
+#ifndef __SENINF1_CSI2_H__
+#define __SENINF1_CSI2_H__
+
+#define SENINF_CSI2_EN 0x0000
+#define CSI2_LANE0_EN_SHIFT 0
+#define CSI2_LANE0_EN_MASK (0x1 << 0)
+#define CSI2_LANE1_EN_SHIFT 1
+#define CSI2_LANE1_EN_MASK (0x1 << 1)
+#define CSI2_LANE2_EN_SHIFT 2
+#define CSI2_LANE2_EN_MASK (0x1 << 2)
+#define CSI2_LANE3_EN_SHIFT 3
+#define CSI2_LANE3_EN_MASK (0x1 << 3)
+
+#define SENINF_CSI2_OPT 0x0004
+#define RG_CSI2_CPHY_SEL_SHIFT 0
+#define RG_CSI2_CPHY_SEL_MASK (0x1 << 0)
+#define RG_CSI2_ECC_EN_SHIFT 1
+#define RG_CSI2_ECC_EN_MASK (0x1 << 1)
+#define RG_CSI2_B2P_EN_SHIFT 2
+#define RG_CSI2_B2P_EN_MASK (0x1 << 2)
+#define RG_CSI2_GENERIC_LONG_PACKET_EN_SHIFT 3
+#define RG_CSI2_GENERIC_LONG_PACKET_EN_MASK (0x1 << 3)
+#define RG_CSI2_IMG_PACKET_EN_SHIFT 4
+#define RG_CSI2_IMG_PACKET_EN_MASK (0x1 << 4)
+#define RG_CSI2_SPEC_V2P0_SEL_SHIFT 5
+#define RG_CSI2_SPEC_V2P0_SEL_MASK (0x1 << 5)
+#define RG_CSI2_DESCRAMBLE_EN_SHIFT 6
+#define RG_CSI2_DESCRAMBLE_EN_MASK (0x1 << 6)
+#define RG_CSI2_VS_OUTPUT_MODE_SHIFT 8
+#define RG_CSI2_VS_OUTPUT_MODE_MASK (0x1 << 8)
+#define RG_CSI2_VS_OUTPUT_LEN_SEL_SHIFT 9
+#define RG_CSI2_VS_OUTPUT_LEN_SEL_MASK (0x1 << 9)
+#define RG_CSI2_HSYNC_POL_SHIFT 12
+#define RG_CSI2_HSYNC_POL_MASK (0x1 << 12)
+#define RG_CSI2_VSYNC_POL_SHIFT 13
+#define RG_CSI2_VSYNC_POL_MASK (0x1 << 13)
+#define RG_CSI2_FIFO_PUSH_EN_SHIFT 16
+#define RG_CSI2_FIFO_PUSH_EN_MASK (0x3f << 16)
+
+#define SENINF_CSI2_HDR_MODE_0 0x0008
+#define RG_CSI2_HEADER_MODE_SHIFT 0
+#define RG_CSI2_HEADER_MODE_MASK (0xff << 0)
+#define RG_CSI2_HEADER_LEN_SHIFT 8
+#define RG_CSI2_HEADER_LEN_MASK (0x7 << 8)
+
+#define SENINF_CSI2_HDR_MODE_1 0x000c
+#define RG_CSI2_CPHY_HEADER_DI_POS_SHIFT 0
+#define RG_CSI2_CPHY_HEADER_DI_POS_MASK (0xff << 0)
+#define RG_CSI2_CPHY_HEADER_WC_POS_SHIFT 8
+#define RG_CSI2_CPHY_HEADER_WC_POS_MASK (0xff << 8)
+#define RG_CSI2_CPHY_HEADER_VCX_POS_SHIFT 16
+#define RG_CSI2_CPHY_HEADER_VCX_POS_MASK (0xff << 16)
+
+#define SENINF_CSI2_RESYNC_MERGE_CTRL 0x0010
+#define RG_CSI2_RESYNC_CYCLE_CNT_SHIFT 0
+#define RG_CSI2_RESYNC_CYCLE_CNT_MASK (0x1f << 0)
+#define RG_CSI2_RESYNC_CYCLE_CNT_OPT_SHIFT 8
+#define RG_CSI2_RESYNC_CYCLE_CNT_OPT_MASK (0x1 << 8)
+#define RG_CSI2_RESYNC_DATAOUT_OPT_SHIFT 9
+#define RG_CSI2_RESYNC_DATAOUT_OPT_MASK (0x1 << 9)
+#define RG_CSI2_RESYNC_BYPASS_SHIFT 10
+#define RG_CSI2_RESYNC_BYPASS_MASK (0x1 << 10)
+
+#define SENINF_CSI2_DPCM_CTRL 0x0018
+#define RG_CSI2_DPCM_MODE_SHIFT 0
+#define RG_CSI2_DPCM_MODE_MASK (0xf << 0)
+#define RG_CSI2_DT_30_DPCM_EN_SHIFT 8
+#define RG_CSI2_DT_30_DPCM_EN_MASK (0x1 << 8)
+#define RG_CSI2_DT_31_DPCM_EN_SHIFT 9
+#define RG_CSI2_DT_31_DPCM_EN_MASK (0x1 << 9)
+#define RG_CSI2_DT_32_DPCM_EN_SHIFT 10
+#define RG_CSI2_DT_32_DPCM_EN_MASK (0x1 << 10)
+#define RG_CSI2_DT_33_DPCM_EN_SHIFT 11
+#define RG_CSI2_DT_33_DPCM_EN_MASK (0x1 << 11)
+#define RG_CSI2_DT_34_DPCM_EN_SHIFT 12
+#define RG_CSI2_DT_34_DPCM_EN_MASK (0x1 << 12)
+#define RG_CSI2_DT_35_DPCM_EN_SHIFT 13
+#define RG_CSI2_DT_35_DPCM_EN_MASK (0x1 << 13)
+#define RG_CSI2_DT_36_DPCM_EN_SHIFT 14
+#define RG_CSI2_DT_36_DPCM_EN_MASK (0x1 << 14)
+#define RG_CSI2_DT_37_DPCM_EN_SHIFT 15
+#define RG_CSI2_DT_37_DPCM_EN_MASK (0x1 << 15)
+#define RG_CSI2_DT_2A_DPCM_EN_SHIFT 16
+#define RG_CSI2_DT_2A_DPCM_EN_MASK (0x1 << 16)
+
+#define SENINF_CSI2_S0_DI_CTRL 0x0020
+#define RG_CSI2_S0_VC_INTERLEAVE_EN_SHIFT 0
+#define RG_CSI2_S0_VC_INTERLEAVE_EN_MASK (0x1 << 0)
+#define RG_CSI2_S0_DT_INTERLEAVE_MODE_SHIFT 4
+#define RG_CSI2_S0_DT_INTERLEAVE_MODE_MASK (0x3 << 4)
+#define RG_CSI2_S0_VC_SEL_SHIFT 8
+#define RG_CSI2_S0_VC_SEL_MASK (0x1f << 8)
+#define RG_CSI2_S0_DT_SEL_SHIFT 16
+#define RG_CSI2_S0_DT_SEL_MASK (0x3f << 16)
+
+#define SENINF_CSI2_S1_DI_CTRL 0x0024
+#define RG_CSI2_S1_VC_INTERLEAVE_EN_SHIFT 0
+#define RG_CSI2_S1_VC_INTERLEAVE_EN_MASK (0x1 << 0)
+#define RG_CSI2_S1_DT_INTERLEAVE_MODE_SHIFT 4
+#define RG_CSI2_S1_DT_INTERLEAVE_MODE_MASK (0x3 << 4)
+#define RG_CSI2_S1_VC_SEL_SHIFT 8
+#define RG_CSI2_S1_VC_SEL_MASK (0x1f << 8)
+#define RG_CSI2_S1_DT_SEL_SHIFT 16
+#define RG_CSI2_S1_DT_SEL_MASK (0x3f << 16)
+
+#define SENINF_CSI2_S2_DI_CTRL 0x0028
+#define RG_CSI2_S2_VC_INTERLEAVE_EN_SHIFT 0
+#define RG_CSI2_S2_VC_INTERLEAVE_EN_MASK (0x1 << 0)
+#define RG_CSI2_S2_DT_INTERLEAVE_MODE_SHIFT 4
+#define RG_CSI2_S2_DT_INTERLEAVE_MODE_MASK (0x3 << 4)
+#define RG_CSI2_S2_VC_SEL_SHIFT 8
+#define RG_CSI2_S2_VC_SEL_MASK (0x1f << 8)
+#define RG_CSI2_S2_DT_SEL_SHIFT 16
+#define RG_CSI2_S2_DT_SEL_MASK (0x3f << 16)
+
+#define SENINF_CSI2_S3_DI_CTRL 0x002c
+#define RG_CSI2_S3_VC_INTERLEAVE_EN_SHIFT 0
+#define RG_CSI2_S3_VC_INTERLEAVE_EN_MASK (0x1 << 0)
+#define RG_CSI2_S3_DT_INTERLEAVE_MODE_SHIFT 4
+#define RG_CSI2_S3_DT_INTERLEAVE_MODE_MASK (0x3 << 4)
+#define RG_CSI2_S3_VC_SEL_SHIFT 8
+#define RG_CSI2_S3_VC_SEL_MASK (0x1f << 8)
+#define RG_CSI2_S3_DT_SEL_SHIFT 16
+#define RG_CSI2_S3_DT_SEL_MASK (0x3f << 16)
+
+#define SENINF_CSI2_S4_DI_CTRL 0x0030
+#define RG_CSI2_S4_VC_INTERLEAVE_EN_SHIFT 0
+#define RG_CSI2_S4_VC_INTERLEAVE_EN_MASK (0x1 << 0)
+#define RG_CSI2_S4_DT_INTERLEAVE_MODE_SHIFT 4
+#define RG_CSI2_S4_DT_INTERLEAVE_MODE_MASK (0x3 << 4)
+#define RG_CSI2_S4_VC_SEL_SHIFT 8
+#define RG_CSI2_S4_VC_SEL_MASK (0x1f << 8)
+#define RG_CSI2_S4_DT_SEL_SHIFT 16
+#define RG_CSI2_S4_DT_SEL_MASK (0x3f << 16)
+
+#define SENINF_CSI2_S5_DI_CTRL 0x0034
+#define RG_CSI2_S5_VC_INTERLEAVE_EN_SHIFT 0
+#define RG_CSI2_S5_VC_INTERLEAVE_EN_MASK (0x1 << 0)
+#define RG_CSI2_S5_DT_INTERLEAVE_MODE_SHIFT 4
+#define RG_CSI2_S5_DT_INTERLEAVE_MODE_MASK (0x3 << 4)
+#define RG_CSI2_S5_VC_SEL_SHIFT 8
+#define RG_CSI2_S5_VC_SEL_MASK (0x1f << 8)
+#define RG_CSI2_S5_DT_SEL_SHIFT 16
+#define RG_CSI2_S5_DT_SEL_MASK (0x3f << 16)
+
+#define SENINF_CSI2_S6_DI_CTRL 0x0038
+#define RG_CSI2_S6_VC_INTERLEAVE_EN_SHIFT 0
+#define RG_CSI2_S6_VC_INTERLEAVE_EN_MASK (0x1 << 0)
+#define RG_CSI2_S6_DT_INTERLEAVE_MODE_SHIFT 4
+#define RG_CSI2_S6_DT_INTERLEAVE_MODE_MASK (0x3 << 4)
+#define RG_CSI2_S6_VC_SEL_SHIFT 8
+#define RG_CSI2_S6_VC_SEL_MASK (0x1f << 8)
+#define RG_CSI2_S6_DT_SEL_SHIFT 16
+#define RG_CSI2_S6_DT_SEL_MASK (0x3f << 16)
+
+#define SENINF_CSI2_S7_DI_CTRL 0x003c
+#define RG_CSI2_S7_VC_INTERLEAVE_EN_SHIFT 0
+#define RG_CSI2_S7_VC_INTERLEAVE_EN_MASK (0x1 << 0)
+#define RG_CSI2_S7_DT_INTERLEAVE_MODE_SHIFT 4
+#define RG_CSI2_S7_DT_INTERLEAVE_MODE_MASK (0x3 << 4)
+#define RG_CSI2_S7_VC_SEL_SHIFT 8
+#define RG_CSI2_S7_VC_SEL_MASK (0x1f << 8)
+#define RG_CSI2_S7_DT_SEL_SHIFT 16
+#define RG_CSI2_S7_DT_SEL_MASK (0x3f << 16)
+
+#define SENINF_CSI2_CH0_CTRL 0x0060
+#define RG_CSI2_CH0_GRP_MODE_SHIFT 0
+#define RG_CSI2_CH0_GRP_MODE_MASK (0x1 << 0)
+#define RG_CSI2_CH0_VSYNC_BYPASS_SHIFT 1
+#define RG_CSI2_CH0_VSYNC_BYPASS_MASK (0x1 << 1)
+#define RG_CSI2_CH0_S0_GRP_EN_SHIFT 8
+#define RG_CSI2_CH0_S0_GRP_EN_MASK (0x1 << 8)
+#define RG_CSI2_CH0_S1_GRP_EN_SHIFT 9
+#define RG_CSI2_CH0_S1_GRP_EN_MASK (0x1 << 9)
+#define RG_CSI2_CH0_S2_GRP_EN_SHIFT 10
+#define RG_CSI2_CH0_S2_GRP_EN_MASK (0x1 << 10)
+#define RG_CSI2_CH0_S3_GRP_EN_SHIFT 11
+#define RG_CSI2_CH0_S3_GRP_EN_MASK (0x1 << 11)
+#define RG_CSI2_CH0_S4_GRP_EN_SHIFT 12
+#define RG_CSI2_CH0_S4_GRP_EN_MASK (0x1 << 12)
+#define RG_CSI2_CH0_S5_GRP_EN_SHIFT 13
+#define RG_CSI2_CH0_S5_GRP_EN_MASK (0x1 << 13)
+#define RG_CSI2_CH0_S6_GRP_EN_SHIFT 14
+#define RG_CSI2_CH0_S6_GRP_EN_MASK (0x1 << 14)
+#define RG_CSI2_CH0_S7_GRP_EN_SHIFT 15
+#define RG_CSI2_CH0_S7_GRP_EN_MASK (0x1 << 15)
+
+#define SENINF_CSI2_CH1_CTRL 0x0064
+#define RG_CSI2_CH1_GRP_MODE_SHIFT 0
+#define RG_CSI2_CH1_GRP_MODE_MASK (0x1 << 0)
+#define RG_CSI2_CH1_VSYNC_BYPASS_SHIFT 1
+#define RG_CSI2_CH1_VSYNC_BYPASS_MASK (0x1 << 1)
+#define RG_CSI2_CH1_S0_GRP_EN_SHIFT 8
+#define RG_CSI2_CH1_S0_GRP_EN_MASK (0x1 << 8)
+#define RG_CSI2_CH1_S1_GRP_EN_SHIFT 9
+#define RG_CSI2_CH1_S1_GRP_EN_MASK (0x1 << 9)
+#define RG_CSI2_CH1_S2_GRP_EN_SHIFT 10
+#define RG_CSI2_CH1_S2_GRP_EN_MASK (0x1 << 10)
+#define RG_CSI2_CH1_S3_GRP_EN_SHIFT 11
+#define RG_CSI2_CH1_S3_GRP_EN_MASK (0x1 << 11)
+#define RG_CSI2_CH1_S4_GRP_EN_SHIFT 12
+#define RG_CSI2_CH1_S4_GRP_EN_MASK (0x1 << 12)
+#define RG_CSI2_CH1_S5_GRP_EN_SHIFT 13
+#define RG_CSI2_CH1_S5_GRP_EN_MASK (0x1 << 13)
+#define RG_CSI2_CH1_S6_GRP_EN_SHIFT 14
+#define RG_CSI2_CH1_S6_GRP_EN_MASK (0x1 << 14)
+#define RG_CSI2_CH1_S7_GRP_EN_SHIFT 15
+#define RG_CSI2_CH1_S7_GRP_EN_MASK (0x1 << 15)
+
+#define SENINF_CSI2_CH2_CTRL 0x0068
+#define RG_CSI2_CH2_GRP_MODE_SHIFT 0
+#define RG_CSI2_CH2_GRP_MODE_MASK (0x1 << 0)
+#define RG_CSI2_CH2_VSYNC_BYPASS_SHIFT 1
+#define RG_CSI2_CH2_VSYNC_BYPASS_MASK (0x1 << 1)
+#define RG_CSI2_CH2_S0_GRP_EN_SHIFT 8
+#define RG_CSI2_CH2_S0_GRP_EN_MASK (0x1 << 8)
+#define RG_CSI2_CH2_S1_GRP_EN_SHIFT 9
+#define RG_CSI2_CH2_S1_GRP_EN_MASK (0x1 << 9)
+#define RG_CSI2_CH2_S2_GRP_EN_SHIFT 10
+#define RG_CSI2_CH2_S2_GRP_EN_MASK (0x1 << 10)
+#define RG_CSI2_CH2_S3_GRP_EN_SHIFT 11
+#define RG_CSI2_CH2_S3_GRP_EN_MASK (0x1 << 11)
+#define RG_CSI2_CH2_S4_GRP_EN_SHIFT 12
+#define RG_CSI2_CH2_S4_GRP_EN_MASK (0x1 << 12)
+#define RG_CSI2_CH2_S5_GRP_EN_SHIFT 13
+#define RG_CSI2_CH2_S5_GRP_EN_MASK (0x1 << 13)
+#define RG_CSI2_CH2_S6_GRP_EN_SHIFT 14
+#define RG_CSI2_CH2_S6_GRP_EN_MASK (0x1 << 14)
+#define RG_CSI2_CH2_S7_GRP_EN_SHIFT 15
+#define RG_CSI2_CH2_S7_GRP_EN_MASK (0x1 << 15)
+
+#define SENINF_CSI2_CH3_CTRL 0x006c
+#define RG_CSI2_CH3_GRP_MODE_SHIFT 0
+#define RG_CSI2_CH3_GRP_MODE_MASK (0x1 << 0)
+#define RG_CSI2_CH3_VSYNC_BYPASS_SHIFT 1
+#define RG_CSI2_CH3_VSYNC_BYPASS_MASK (0x1 << 1)
+#define RG_CSI2_CH3_S0_GRP_EN_SHIFT 8
+#define RG_CSI2_CH3_S0_GRP_EN_MASK (0x1 << 8)
+#define RG_CSI2_CH3_S1_GRP_EN_SHIFT 9
+#define RG_CSI2_CH3_S1_GRP_EN_MASK (0x1 << 9)
+#define RG_CSI2_CH3_S2_GRP_EN_SHIFT 10
+#define RG_CSI2_CH3_S2_GRP_EN_MASK (0x1 << 10)
+#define RG_CSI2_CH3_S3_GRP_EN_SHIFT 11
+#define RG_CSI2_CH3_S3_GRP_EN_MASK (0x1 << 11)
+#define RG_CSI2_CH3_S4_GRP_EN_SHIFT 12
+#define RG_CSI2_CH3_S4_GRP_EN_MASK (0x1 << 12)
+#define RG_CSI2_CH3_S5_GRP_EN_SHIFT 13
+#define RG_CSI2_CH3_S5_GRP_EN_MASK (0x1 << 13)
+#define RG_CSI2_CH3_S6_GRP_EN_SHIFT 14
+#define RG_CSI2_CH3_S6_GRP_EN_MASK (0x1 << 14)
+#define RG_CSI2_CH3_S7_GRP_EN_SHIFT 15
+#define RG_CSI2_CH3_S7_GRP_EN_MASK (0x1 << 15)
+
+#define SENINF_CSI2_L0_DESCRAMBLE_SEED_0 0x0080
+#define RG_CSI2_L0_DESCRAMBLE_TYPE0_SEED_SHIFT 0
+#define RG_CSI2_L0_DESCRAMBLE_TYPE0_SEED_MASK (0xffff << 0)
+#define RG_CSI2_L0_DESCRAMBLE_TYPE1_SEED_SHIFT 16
+#define RG_CSI2_L0_DESCRAMBLE_TYPE1_SEED_MASK (0xffff << 16)
+
+#define SENINF_CSI2_L0_DESCRAMBLE_SEED_1 0x0084
+#define RG_CSI2_L0_DESCRAMBLE_TYPE2_SEED_SHIFT 0
+#define RG_CSI2_L0_DESCRAMBLE_TYPE2_SEED_MASK (0xffff << 0)
+#define RG_CSI2_L0_DESCRAMBLE_TYPE3_SEED_SHIFT 16
+#define RG_CSI2_L0_DESCRAMBLE_TYPE3_SEED_MASK (0xffff << 16)
+
+#define SENINF_CSI2_L1_DESCRAMBLE_SEED_0 0x0090
+#define RG_CSI2_L1_DESCRAMBLE_TYPE0_SEED_SHIFT 0
+#define RG_CSI2_L1_DESCRAMBLE_TYPE0_SEED_MASK (0xffff << 0)
+#define RG_CSI2_L1_DESCRAMBLE_TYPE1_SEED_SHIFT 16
+#define RG_CSI2_L1_DESCRAMBLE_TYPE1_SEED_MASK (0xffff << 16)
+
+#define SENINF_CSI2_L1_DESCRAMBLE_SEED_1 0x0094
+#define RG_CSI2_L1_DESCRAMBLE_TYPE2_SEED_SHIFT 0
+#define RG_CSI2_L1_DESCRAMBLE_TYPE2_SEED_MASK (0xffff << 0)
+#define RG_CSI2_L1_DESCRAMBLE_TYPE3_SEED_SHIFT 16
+#define RG_CSI2_L1_DESCRAMBLE_TYPE3_SEED_MASK (0xffff << 16)
+
+#define SENINF_CSI2_L2_DESCRAMBLE_SEED_0 0x00a0
+#define RG_CSI2_L2_DESCRAMBLE_TYPE0_SEED_SHIFT 0
+#define RG_CSI2_L2_DESCRAMBLE_TYPE0_SEED_MASK (0xffff << 0)
+#define RG_CSI2_L2_DESCRAMBLE_TYPE1_SEED_SHIFT 16
+#define RG_CSI2_L2_DESCRAMBLE_TYPE1_SEED_MASK (0xffff << 16)
+
+#define SENINF_CSI2_L2_DESCRAMBLE_SEED_1 0x00a4
+#define RG_CSI2_L2_DESCRAMBLE_TYPE2_SEED_SHIFT 0
+#define RG_CSI2_L2_DESCRAMBLE_TYPE2_SEED_MASK (0xffff << 0)
+#define RG_CSI2_L2_DESCRAMBLE_TYPE3_SEED_SHIFT 16
+#define RG_CSI2_L2_DESCRAMBLE_TYPE3_SEED_MASK (0xffff << 16)
+
+#define SENINF_CSI2_L3_DESCRAMBLE_SEED_0 0x00b0
+#define RG_CSI2_L3_DESCRAMBLE_TYPE0_SEED_SHIFT 0
+#define RG_CSI2_L3_DESCRAMBLE_TYPE0_SEED_MASK (0xffff << 0)
+#define RG_CSI2_L3_DESCRAMBLE_TYPE1_SEED_SHIFT 16
+#define RG_CSI2_L3_DESCRAMBLE_TYPE1_SEED_MASK (0xffff << 16)
+
+#define SENINF_CSI2_L3_DESCRAMBLE_SEED_1 0x00b4
+#define RG_CSI2_L3_DESCRAMBLE_TYPE2_SEED_SHIFT 0
+#define RG_CSI2_L3_DESCRAMBLE_TYPE2_SEED_MASK (0xffff << 0)
+#define RG_CSI2_L3_DESCRAMBLE_TYPE3_SEED_SHIFT 16
+#define RG_CSI2_L3_DESCRAMBLE_TYPE3_SEED_MASK (0xffff << 16)
+
+#define SENINF_CSI2_IRQ_EN 0x00c0
+#define RG_CSI2_ERR_FRAME_SYNC_IRQ_EN_SHIFT 0
+#define RG_CSI2_ERR_FRAME_SYNC_IRQ_EN_MASK (0x1 << 0)
+#define RG_CSI2_ERR_ID_IRQ_EN_SHIFT 1
+#define RG_CSI2_ERR_ID_IRQ_EN_MASK (0x1 << 1)
+#define RG_CSI2_ECC_ERR_UNDETECTED_IRQ_EN_SHIFT 2
+#define RG_CSI2_ECC_ERR_UNDETECTED_IRQ_EN_MASK (0x1 << 2)
+#define RG_CSI2_ECC_ERR_CORRECTED_IRQ_EN_SHIFT 3
+#define RG_CSI2_ECC_ERR_CORRECTED_IRQ_EN_MASK (0x1 << 3)
+#define RG_CSI2_ECC_ERR_DOUBLE_IRQ_EN_SHIFT 4
+#define RG_CSI2_ECC_ERR_DOUBLE_IRQ_EN_MASK (0x1 << 4)
+#define RG_CSI2_CRC_CORRECT_IRQ_EN_SHIFT 5
+#define RG_CSI2_CRC_CORRECT_IRQ_EN_MASK (0x1 << 5)
+#define RG_CSI2_CRC_ERR_IRQ_EN_SHIFT 6
+#define RG_CSI2_CRC_ERR_IRQ_EN_MASK (0x1 << 6)
+#define RG_CSI2_ERR_MULTI_LANE_SYNC_IRQ_EN_SHIFT 7
+#define RG_CSI2_ERR_MULTI_LANE_SYNC_IRQ_EN_MASK (0x1 << 7)
+#define RG_CSI2_FS_RECEIVE_IRQ_EN_SHIFT 8
+#define RG_CSI2_FS_RECEIVE_IRQ_EN_MASK (0x1 << 8)
+#define RG_CSI2_FE_RECEIVE_IRQ_EN_SHIFT 9
+#define RG_CSI2_FE_RECEIVE_IRQ_EN_MASK (0x1 << 9)
+#define RG_CSI2_LS_RECEIVE_IRQ_EN_SHIFT 10
+#define RG_CSI2_LS_RECEIVE_IRQ_EN_MASK (0x1 << 10)
+#define RG_CSI2_LE_RECEIVE_IRQ_EN_SHIFT 11
+#define RG_CSI2_LE_RECEIVE_IRQ_EN_MASK (0x1 << 11)
+#define RG_CSI2_GS_RECEIVE_IRQ_EN_SHIFT 12
+#define RG_CSI2_GS_RECEIVE_IRQ_EN_MASK (0x1 << 12)
+#define RG_CSI2_ERR_LANE_RESYNC_IRQ_EN_SHIFT 13
+#define RG_CSI2_ERR_LANE_RESYNC_IRQ_EN_MASK (0x1 << 13)
+#define RG_CSI2_LANE_MERGE_FIFO_AF_IRQ_EN_SHIFT 14
+#define RG_CSI2_LANE_MERGE_FIFO_AF_IRQ_EN_MASK (0x1 << 14)
+#define RG_CSI2_ERR_FRAME_SYNC_S0_IRQ_EN_SHIFT 16
+#define RG_CSI2_ERR_FRAME_SYNC_S0_IRQ_EN_MASK (0x1 << 16)
+#define RG_CSI2_ERR_FRAME_SYNC_S1_IRQ_EN_SHIFT 17
+#define RG_CSI2_ERR_FRAME_SYNC_S1_IRQ_EN_MASK (0x1 << 17)
+#define RG_CSI2_ERR_FRAME_SYNC_S2_IRQ_EN_SHIFT 18
+#define RG_CSI2_ERR_FRAME_SYNC_S2_IRQ_EN_MASK (0x1 << 18)
+#define RG_CSI2_ERR_FRAME_SYNC_S3_IRQ_EN_SHIFT 19
+#define RG_CSI2_ERR_FRAME_SYNC_S3_IRQ_EN_MASK (0x1 << 19)
+#define RG_CSI2_ERR_FRAME_SYNC_S4_IRQ_EN_SHIFT 20
+#define RG_CSI2_ERR_FRAME_SYNC_S4_IRQ_EN_MASK (0x1 << 20)
+#define RG_CSI2_ERR_FRAME_SYNC_S5_IRQ_EN_SHIFT 21
+#define RG_CSI2_ERR_FRAME_SYNC_S5_IRQ_EN_MASK (0x1 << 21)
+#define RG_CSI2_ERR_FRAME_SYNC_S6_IRQ_EN_SHIFT 22
+#define RG_CSI2_ERR_FRAME_SYNC_S6_IRQ_EN_MASK (0x1 << 22)
+#define RG_CSI2_ERR_FRAME_SYNC_S7_IRQ_EN_SHIFT 23
+#define RG_CSI2_ERR_FRAME_SYNC_S7_IRQ_EN_MASK (0x1 << 23)
+#define RG_CSI2_RESYNC_FIFO_OVERFLOW_L0_IRQ_EN_SHIFT 24
+#define RG_CSI2_RESYNC_FIFO_OVERFLOW_L0_IRQ_EN_MASK (0x1 << 24)
+#define RG_CSI2_RESYNC_FIFO_OVERFLOW_L1_IRQ_EN_SHIFT 25
+#define RG_CSI2_RESYNC_FIFO_OVERFLOW_L1_IRQ_EN_MASK (0x1 << 25)
+#define RG_CSI2_RESYNC_FIFO_OVERFLOW_L2_IRQ_EN_SHIFT 26
+#define RG_CSI2_RESYNC_FIFO_OVERFLOW_L2_IRQ_EN_MASK (0x1 << 26)
+#define RG_CSI2_RESYNC_FIFO_OVERFLOW_L3_IRQ_EN_SHIFT 27
+#define RG_CSI2_RESYNC_FIFO_OVERFLOW_L3_IRQ_EN_MASK (0x1 << 27)
+#define RG_CSI2_ASYNC_FIFO_OVERRUN_IRQ_EN_SHIFT 28
+#define RG_CSI2_ASYNC_FIFO_OVERRUN_IRQ_EN_MASK (0x1 << 28)
+#define RG_CSI2_RECEIVE_DATA_NOT_ENOUGH_IRQ_EN_SHIFT 29
+#define RG_CSI2_RECEIVE_DATA_NOT_ENOUGH_IRQ_EN_MASK (0x1 << 29)
+#define RG_CSI2_IRQ_CLR_MODE_SHIFT 31
+#define RG_CSI2_IRQ_CLR_MODE_MASK (0x1 << 31)
+
+#define SENINF_CSI2_IRQ_STATUS 0x00c8
+#define RO_CSI2_ERR_FRAME_SYNC_IRQ_SHIFT 0
+#define RO_CSI2_ERR_FRAME_SYNC_IRQ_MASK (0x1 << 0)
+#define RO_CSI2_ERR_ID_IRQ_SHIFT 1
+#define RO_CSI2_ERR_ID_IRQ_MASK (0x1 << 1)
+#define RO_CSI2_ECC_ERR_UNDETECTED_IRQ_SHIFT 2
+#define RO_CSI2_ECC_ERR_UNDETECTED_IRQ_MASK (0x1 << 2)
+#define RO_CSI2_ECC_ERR_CORRECTED_IRQ_SHIFT 3
+#define RO_CSI2_ECC_ERR_CORRECTED_IRQ_MASK (0x1 << 3)
+#define RO_CSI2_ECC_ERR_DOUBLE_IRQ_SHIFT 4
+#define RO_CSI2_ECC_ERR_DOUBLE_IRQ_MASK (0x1 << 4)
+#define RO_CSI2_CRC_CORRECT_IRQ_SHIFT 5
+#define RO_CSI2_CRC_CORRECT_IRQ_MASK (0x1 << 5)
+#define RO_CSI2_CRC_ERR_IRQ_SHIFT 6
+#define RO_CSI2_CRC_ERR_IRQ_MASK (0x1 << 6)
+#define RO_CSI2_ERR_MULTI_LANE_SYNC_IRQ_SHIFT 7
+#define RO_CSI2_ERR_MULTI_LANE_SYNC_IRQ_MASK (0x1 << 7)
+#define RO_CSI2_FS_RECEIVE_IRQ_SHIFT 8
+#define RO_CSI2_FS_RECEIVE_IRQ_MASK (0x1 << 8)
+#define RO_CSI2_FE_RECEIVE_IRQ_SHIFT 9
+#define RO_CSI2_FE_RECEIVE_IRQ_MASK (0x1 << 9)
+#define RO_CSI2_LS_RECEIVE_IRQ_SHIFT 10
+#define RO_CSI2_LS_RECEIVE_IRQ_MASK (0x1 << 10)
+#define RO_CSI2_LE_RECEIVE_IRQ_SHIFT 11
+#define RO_CSI2_LE_RECEIVE_IRQ_MASK (0x1 << 11)
+#define RO_CSI2_GS_RECEIVE_IRQ_SHIFT 12
+#define RO_CSI2_GS_RECEIVE_IRQ_MASK (0x1 << 12)
+#define RO_CSI2_ERR_LANE_RESYNC_IRQ_SHIFT 13
+#define RO_CSI2_ERR_LANE_RESYNC_IRQ_MASK (0x1 << 13)
+#define RO_CSI2_LANE_MERGE_FIFO_AF_IRQ_SHIFT 14
+#define RO_CSI2_LANE_MERGE_FIFO_AF_IRQ_MASK (0x1 << 14)
+#define RO_CSI2_ERR_FRAME_SYNC_S0_IRQ_SHIFT 16
+#define RO_CSI2_ERR_FRAME_SYNC_S0_IRQ_MASK (0x1 << 16)
+#define RO_CSI2_ERR_FRAME_SYNC_S1_IRQ_SHIFT 17
+#define RO_CSI2_ERR_FRAME_SYNC_S1_IRQ_MASK (0x1 << 17)
+#define RO_CSI2_ERR_FRAME_SYNC_S2_IRQ_SHIFT 18
+#define RO_CSI2_ERR_FRAME_SYNC_S2_IRQ_MASK (0x1 << 18)
+#define RO_CSI2_ERR_FRAME_SYNC_S3_IRQ_SHIFT 19
+#define RO_CSI2_ERR_FRAME_SYNC_S3_IRQ_MASK (0x1 << 19)
+#define RO_CSI2_ERR_FRAME_SYNC_S4_IRQ_SHIFT 20
+#define RO_CSI2_ERR_FRAME_SYNC_S4_IRQ_MASK (0x1 << 20)
+#define RO_CSI2_ERR_FRAME_SYNC_S5_IRQ_SHIFT 21
+#define RO_CSI2_ERR_FRAME_SYNC_S5_IRQ_MASK (0x1 << 21)
+#define RO_CSI2_ERR_FRAME_SYNC_S6_IRQ_SHIFT 22
+#define RO_CSI2_ERR_FRAME_SYNC_S6_IRQ_MASK (0x1 << 22)
+#define RO_CSI2_ERR_FRAME_SYNC_S7_IRQ_SHIFT 23
+#define RO_CSI2_ERR_FRAME_SYNC_S7_IRQ_MASK (0x1 << 23)
+#define RO_CSI2_RESYNC_FIFO_OVERFLOW_L0_IRQ_SHIFT 24
+#define RO_CSI2_RESYNC_FIFO_OVERFLOW_L0_IRQ_MASK (0x1 << 24)
+#define RO_CSI2_RESYNC_FIFO_OVERFLOW_L1_IRQ_SHIFT 25
+#define RO_CSI2_RESYNC_FIFO_OVERFLOW_L1_IRQ_MASK (0x1 << 25)
+#define RO_CSI2_RESYNC_FIFO_OVERFLOW_L2_IRQ_SHIFT 26
+#define RO_CSI2_RESYNC_FIFO_OVERFLOW_L2_IRQ_MASK (0x1 << 26)
+#define RO_CSI2_RESYNC_FIFO_OVERFLOW_L3_IRQ_SHIFT 27
+#define RO_CSI2_RESYNC_FIFO_OVERFLOW_L3_IRQ_MASK (0x1 << 27)
+#define RO_CSI2_ASYNC_FIFO_OVERRUN_IRQ_SHIFT 28
+#define RO_CSI2_ASYNC_FIFO_OVERRUN_IRQ_MASK (0x1 << 28)
+#define RO_CSI2_RECEIVE_DATA_NOT_ENOUGH_IRQ_SHIFT 29
+#define RO_CSI2_RECEIVE_DATA_NOT_ENOUGH_IRQ_MASK (0x1 << 29)
+
+#define SENINF_CSI2_IRQ_TRIG 0x00cc
+#define RG_CSI2_IRQ_TRIG_SHIFT 0
+#define RG_CSI2_IRQ_TRIG_MASK (0x1fffffff << 0)
+#define RG_CSI2_IRQ_VERIF_EN_SHIFT 31
+#define RG_CSI2_IRQ_VERIF_EN_MASK (0x1 << 31)
+
+#define SENINF_CSI2_LINE_FRAME_NUM 0x00d0
+#define RO_CSI2_LINE_NUM_SHIFT 0
+#define RO_CSI2_LINE_NUM_MASK (0xffff << 0)
+#define RO_CSI2_FRAME_NUM_SHIFT 16
+#define RO_CSI2_FRAME_NUM_MASK (0xffff << 16)
+
+#define SENINF_CSI2_PACKET_STATUS 0x00d4
+#define RO_CSI2_PACKET_DT_SHIFT 0
+#define RO_CSI2_PACKET_DT_MASK (0x3f << 0)
+#define RO_CSI2_PACKET_VC_SHIFT 8
+#define RO_CSI2_PACKET_VC_MASK (0x1f << 8)
+#define RO_CSI2_PACKET_WC_SHIFT 16
+#define RO_CSI2_PACKET_WC_MASK (0xffff << 16)
+
+#define SENINF_CSI2_GEN_SHORT_PACKET_STATUS 0x00d8
+#define RO_CSI2_GENERIC_SHORT_PACKET_DT_SHIFT 0
+#define RO_CSI2_GENERIC_SHORT_PACKET_DT_MASK (0x3f << 0)
+#define RO_CSI2_GENERIC_SHORT_PACKET_WC_SHIFT 16
+#define RO_CSI2_GENERIC_SHORT_PACKET_WC_MASK (0xffff << 16)
+
+#define SENINF_CSI2_PACKET_CNT_STATUS 0x00dc
+#define RO_CSI2_PACKET_CNT_SHIFT 0
+#define RO_CSI2_PACKET_CNT_MASK (0xffff << 0)
+#define RO_CSI2_PACKET_CNT_BUF_SHIFT 16
+#define RO_CSI2_PACKET_CNT_BUF_MASK (0xffff << 16)
+
+#define SENINF_CSI2_DBG_CTRL 0x00e0
+#define RG_CSI2_DBG_SEL_SHIFT 0
+#define RG_CSI2_DBG_SEL_MASK (0xff << 0)
+#define RG_CSI2_DBG_EN_SHIFT 16
+#define RG_CSI2_DBG_EN_MASK (0x1 << 16)
+#define RG_CSI2_DBG_PACKET_CNT_EN_SHIFT 17
+#define RG_CSI2_DBG_PACKET_CNT_EN_MASK (0x1 << 17)
+
+#define SENINF_CSI2_DBG_OUT 0x00f4
+#define RO_CSI2_DBG_OUT_SHIFT 0
+#define RO_CSI2_DBG_OUT_MASK (0xffffffff << 0)
+
+#define SENINF_CSI2_SPARE 0x00f8
+#define RG_CSI2_SPARE_0_SHIFT 0
+#define RG_CSI2_SPARE_0_MASK (0xff << 0)
+#define RG_CSI2_SPARE_1_SHIFT 16
+#define RG_CSI2_SPARE_1_MASK (0xff << 16)
+
+#define SENINF_CSI2_SOFEOF_PARAMETER 0x00fc
+#define RG_CSI2_SOF_PULSE_WIDTH_SHIFT 0
+#define RG_CSI2_SOF_PULSE_WIDTH_MASK (0xffff << 0)
+#define RG_CSI2_EOF_PULSE_WIDTH_SHIFT 16
+#define RG_CSI2_EOF_PULSE_WIDTH_MASK (0xffff << 16)
+
+#define SENINF_CSI2_R24USERDEF_DT 0x0100
+#define RG_CSI2_RAW24LIKE_USERDEF_DT_SHIFT 0
+#define RG_CSI2_RAW24LIKE_USERDEF_DT_MASK (0x3f << 0)
+#define RG_CSI2_USERDEF_DT_EN_SHIFT 8
+#define RG_CSI2_USERDEF_DT_EN_MASK (0x1 << 8)
+#define RG_ADAS_CTRL_WORD_EN_SHIFT 16
+#define RG_ADAS_CTRL_WORD_EN_MASK (0x1 << 16)
+#define RG_USER_DEF_38_2_3F_EN_SHIFT 17
+#define RG_USER_DEF_38_2_3F_EN_MASK (0x1 << 17)
+
+#define SENINF_CSI2_DT0 0x0104
+#define RG_CSI2_RAW10_DT_SHIFT 0
+#define RG_CSI2_RAW10_DT_MASK (0x3f << 0)
+#define RG_CSI2_RAW12_DT_SHIFT 8
+#define RG_CSI2_RAW12_DT_MASK (0x3f << 8)
+#define RG_CSI2_RAW14_DT_SHIFT 16
+#define RG_CSI2_RAW14_DT_MASK (0x3f << 16)
+#define RG_CSI2_RAW16_DT_SHIFT 24
+#define RG_CSI2_RAW16_DT_MASK (0x3f << 24)
+
+#define SENINF_CSI2_DT1 0x0108
+#define RG_CSI2_RAW20_DT_SHIFT 0
+#define RG_CSI2_RAW20_DT_MASK (0x3f << 0)
+#define RG_CSI2_YUV420_10_SHIFT 8
+#define RG_CSI2_YUV420_10_MASK (0x3f << 8)
+#define RG_CSI2_YUV420CSPS_10_SHIFT 16
+#define RG_CSI2_YUV420CSPS_10_MASK (0x3f << 16)
+#define RG_CSI2_YUV422_10_SHIFT 24
+#define RG_CSI2_YUV422_10_MASK (0x3f << 24)
+
+#define SENINF_CSI2_DT2 0x010c
+#define RG_CSI2_RGB565_DT_SHIFT 0
+#define RG_CSI2_RGB565_DT_MASK (0x3f << 0)
+#define RG_CSI2_RGB888_DT_SHIFT 8
+#define RG_CSI2_RGB888_DT_MASK (0x3f << 8)
+#define RG_FORCE_LONG_PKT_SHIFT 16
+#define RG_FORCE_LONG_PKT_MASK (0x1 << 16)
+#define RG_FORCE_RAW8_PKT_SHIFT 17
+#define RG_FORCE_RAW8_PKT_MASK (0x1 << 17)
+
+#define SENINF_CSI2_FORCEDT0 0x0110
+#define RG_FORCE_DT0_SHIFT 0
+#define RG_FORCE_DT0_MASK (0x3f << 0)
+#define RG_FORCE_DT0_SEL_SHIFT 8
+#define RG_FORCE_DT0_SEL_MASK (0x7 << 8)
+#define RG_FORCE_DT0_EN_SHIFT 12
+#define RG_FORCE_DT0_EN_MASK (0x1 << 12)
+#define RG_FORCE_DT1_SHIFT 16
+#define RG_FORCE_DT1_MASK (0x3f << 16)
+#define RG_FORCE_DT1_SEL_SHIFT 24
+#define RG_FORCE_DT1_SEL_MASK (0x7 << 24)
+#define RG_FORCE_DT1_EN_SHIFT 28
+#define RG_FORCE_DT1_EN_MASK (0x1 << 28)
+
+#define SENINF_CSI2_FORCEDT1 0x0114
+#define RG_FORCE_DT2_SHIFT 0
+#define RG_FORCE_DT2_MASK (0x3f << 0)
+#define RG_FORCE_DT2_SEL_SHIFT 8
+#define RG_FORCE_DT2_SEL_MASK (0x7 << 8)
+#define RG_FORCE_DT2_EN_SHIFT 12
+#define RG_FORCE_DT2_EN_MASK (0x1 << 12)
+#define RG_FORCE_DT3_SHIFT 16
+#define RG_FORCE_DT3_MASK (0x3f << 16)
+#define RG_FORCE_DT3_SEL_SHIFT 24
+#define RG_FORCE_DT3_SEL_MASK (0x7 << 24)
+#define RG_FORCE_DT3_EN_SHIFT 28
+#define RG_FORCE_DT3_EN_MASK (0x1 << 28)
+
+#define SENINF_CSI2_FORCEDT2 0x0118
+#define RG_SEQ_DT0_SHIFT 0
+#define RG_SEQ_DT0_MASK (0x3f << 0)
+#define RG_SEQ10_DT_EN_SHIFT 7
+#define RG_SEQ10_DT_EN_MASK (0x1 << 7)
+#define RG_SEQ_DT1_SHIFT 8
+#define RG_SEQ_DT1_MASK (0x3f << 8)
+#define RG_SEQ12_DT_EN_SHIFT 15
+#define RG_SEQ12_DT_EN_MASK (0x1 << 15)
+#define RG_SEQ_DT2_SHIFT 16
+#define RG_SEQ_DT2_MASK (0x3f << 16)
+#define RG_SEQ14_DT_EN_SHIFT 23
+#define RG_SEQ14_DT_EN_MASK (0x1 << 23)
+#define RG_SEQ_DT3_SHIFT 24
+#define RG_SEQ_DT3_MASK (0x3f << 24)
+#define RG_SEQ_DT_38_TO_3F_EN_SHIFT 30
+#define RG_SEQ_DT_38_TO_3F_EN_MASK (0x1 << 30)
+#define RG_SEQ_DT_30_TO_37_EN_SHIFT 31
+#define RG_SEQ_DT_30_TO_37_EN_MASK (0x1 << 31)
+
+#define SENINF_CSI2_DTCTRL_WORD00 0x0120
+#define RG_CSI2_DTCTRL_WORD00_SHIFT 0
+#define RG_CSI2_DTCTRL_WORD00_MASK (0xffffffff << 0)
+
+#define SENINF_CSI2_DTCTRL_WORD01 0x0124
+#define RG_CSI2_DTCTRL_WORD01_SHIFT 0
+#define RG_CSI2_DTCTRL_WORD01_MASK (0xffffffff << 0)
+
+#define SENINF_CSI2_DTCTRL_WORD02 0x0128
+#define RG_CSI2_DTCTRL_WORD02_SHIFT 0
+#define RG_CSI2_DTCTRL_WORD02_MASK (0xffffffff << 0)
+
+#define SENINF_CSI2_DTCTRL_WORDDT0 0x012c
+#define RG_CSI2_DTCTRL_WORDDT0_SHIFT 0
+#define RG_CSI2_DTCTRL_WORDDT0_MASK (0x3f << 0)
+
+#define SENINF_CSI2_DTCTRL_WORD10 0x0130
+#define RG_CSI2_DTCTRL_WORD10_SHIFT 0
+#define RG_CSI2_DTCTRL_WORD10_MASK (0xffffffff << 0)
+
+#define SENINF_CSI2_DTCTRL_WORD11 0x0134
+#define RG_CSI2_DTCTRL_WORD11_SHIFT 0
+#define RG_CSI2_DTCTRL_WORD11_MASK (0xffffffff << 0)
+
+#define SENINF_CSI2_DTCTRL_WORD12 0x0138
+#define RG_CSI2_DTCTRL_WORD12_SHIFT 0
+#define RG_CSI2_DTCTRL_WORD12_MASK (0xffffffff << 0)
+
+#define SENINF_CSI2_DTCTRL_WORDDT1 0x013c
+#define RG_CSI2_DTCTRL_WORDDT1_SHIFT 0
+#define RG_CSI2_DTCTRL_WORDDT1_MASK (0x3f << 0)
+
+#define SENINF_CSI2_DTCTRL_WORD20 0x0140
+#define RG_CSI2_DTCTRL_WORD20_SHIFT 0
+#define RG_CSI2_DTCTRL_WORD20_MASK (0xffffffff << 0)
+
+#define SENINF_CSI2_DTCTRL_WORD21 0x0144
+#define RG_CSI2_DTCTRL_WORD21_SHIFT 0
+#define RG_CSI2_DTCTRL_WORD21_MASK (0xffffffff << 0)
+
+#define SENINF_CSI2_DTCTRL_WORD22 0x0148
+#define RG_CSI2_DTCTRL_WORD22_SHIFT 0
+#define RG_CSI2_DTCTRL_WORD22_MASK (0xffffffff << 0)
+
+#define SENINF_CSI2_DTCTRL_WORDDT2 0x014c
+#define RG_CSI2_DTCTRL_WORDDT2_SHIFT 0
+#define RG_CSI2_DTCTRL_WORDDT2_MASK (0x3f << 0)
+
+#define SENINF_CSI2_DTCTRL_WORD30 0x0150
+#define RG_CSI2_DTCTRL_WORD30_SHIFT 0
+#define RG_CSI2_DTCTRL_WORD30_MASK (0xffffffff << 0)
+
+#define SENINF_CSI2_DTCTRL_WORD31 0x0154
+#define RG_CSI2_DTCTRL_WORD31_SHIFT 0
+#define RG_CSI2_DTCTRL_WORD31_MASK (0xffffffff << 0)
+
+#define SENINF_CSI2_DTCTRL_WORD32 0x0158
+#define RG_CSI2_DTCTRL_WORD32_SHIFT 0
+#define RG_CSI2_DTCTRL_WORD32_MASK (0xffffffff << 0)
+
+#define SENINF_CSI2_DTCTRL_WORDDT3 0x015c
+#define RG_CSI2_DTCTRL_WORDDT3_SHIFT 0
+#define RG_CSI2_DTCTRL_WORDDT3_MASK (0x3f << 0)
+
+#define SENINF_CSI2_DTCTRL_WORD40 0x0160
+#define RG_CSI2_DTCTRL_WORD40_SHIFT 0
+#define RG_CSI2_DTCTRL_WORD40_MASK (0xffffffff << 0)
+
+#define SENINF_CSI2_DTCTRL_WORD41 0x0164
+#define RG_CSI2_DTCTRL_WORD41_SHIFT 0
+#define RG_CSI2_DTCTRL_WORD41_MASK (0xffffffff << 0)
+
+#define SENINF_CSI2_DTCTRL_WORD42 0x0168
+#define RG_CSI2_DTCTRL_WORD42_SHIFT 0
+#define RG_CSI2_DTCTRL_WORD42_MASK (0xffffffff << 0)
+
+#define SENINF_CSI2_DTCTRL_WORDDT4 0x016c
+#define RG_CSI2_DTCTRL_WORDDT4_SHIFT 0
+#define RG_CSI2_DTCTRL_WORDDT4_MASK (0x3f << 0)
+
+#define SENINF_CSI2_DTCTRL_WORD50 0x0170
+#define RG_CSI2_DTCTRL_WORD50_SHIFT 0
+#define RG_CSI2_DTCTRL_WORD50_MASK (0xffffffff << 0)
+
+#define SENINF_CSI2_DTCTRL_WORD51 0x0174
+#define RG_CSI2_DTCTRL_WORD51_SHIFT 0
+#define RG_CSI2_DTCTRL_WORD51_MASK (0xffffffff << 0)
+
+#define SENINF_CSI2_DTCTRL_WORD52 0x0178
+#define RG_CSI2_DTCTRL_WORD52_SHIFT 0
+#define RG_CSI2_DTCTRL_WORD52_MASK (0xffffffff << 0)
+
+#define SENINF_CSI2_DTCTRL_WORDDT5 0x017c
+#define RG_CSI2_DTCTRL_WORDDT5_SHIFT 0
+#define RG_CSI2_DTCTRL_WORDDT5_MASK (0x3f << 0)
+
+#define SENINF_CSI2_DTCTRL_WORD60 0x0180
+#define RG_CSI2_DTCTRL_WORD60_SHIFT 0
+#define RG_CSI2_DTCTRL_WORD60_MASK (0xffffffff << 0)
+
+#define SENINF_CSI2_DTCTRL_WORD61 0x0184
+#define RG_CSI2_DTCTRL_WORD61_SHIFT 0
+#define RG_CSI2_DTCTRL_WORD61_MASK (0xffffffff << 0)
+
+#define SENINF_CSI2_DTCTRL_WORD62 0x0188
+#define RG_CSI2_DTCTRL_WORD62_SHIFT 0
+#define RG_CSI2_DTCTRL_WORD62_MASK (0xffffffff << 0)
+
+#define SENINF_CSI2_DTCTRL_WORDDT6 0x018c
+#define RG_CSI2_DTCTRL_WORDDT6_SHIFT 0
+#define RG_CSI2_DTCTRL_WORDDT6_MASK (0x3f << 0)
+
+#define SENINF_CSI2_DTCTRL_WORD70 0x0190
+#define RG_CSI2_DTCTRL_WORD70_SHIFT 0
+#define RG_CSI2_DTCTRL_WORD70_MASK (0xffffffff << 0)
+
+#define SENINF_CSI2_DTCTRL_WORD71 0x0194
+#define RG_CSI2_DTCTRL_WORD71_SHIFT 0
+#define RG_CSI2_DTCTRL_WORD71_MASK (0xffffffff << 0)
+
+#define SENINF_CSI2_DTCTRL_WORD72 0x0198
+#define RG_CSI2_DTCTRL_WORD72_SHIFT 0
+#define RG_CSI2_DTCTRL_WORD72_MASK (0xffffffff << 0)
+
+#define SENINF_CSI2_DTCTRL_WORDDT7 0x019c
+#define RG_CSI2_DTCTRL_WORDDT7_SHIFT 0
+#define RG_CSI2_DTCTRL_WORDDT7_MASK (0x3f << 0)
+
+#define SENINF_CSI2_DTCTRL_WORD_MASK0 0x01a0
+#define RG_CSI2_DTCTRL_WORD_MASK0_SHIFT 0
+#define RG_CSI2_DTCTRL_WORD_MASK0_MASK (0xffffffff << 0)
+
+#define SENINF_CSI2_DTCTRL_WORD_MASK1 0x01a4
+#define RG_CSI2_DTCTRL_WORD_MASK1_SHIFT 0
+#define RG_CSI2_DTCTRL_WORD_MASK1_MASK (0xffffffff << 0)
+
+#define SENINF_CSI2_DTCTRL_WORD_MASK2 0x01a8
+#define RG_CSI2_DTCTRL_WORD_MASK2_SHIFT 0
+#define RG_CSI2_DTCTRL_WORD_MASK2_MASK (0xffffffff << 0)
+
+#define SENINF_CSI2_VCCTRL_WORD00 0x0220
+#define RG_CSI2_VCCTRL_WORD00_SHIFT 0
+#define RG_CSI2_VCCTRL_WORD00_MASK (0xffffffff << 0)
+
+#define SENINF_CSI2_VCCTRL_WORD01 0x0224
+#define RG_CSI2_VCCTRL_WORD01_SHIFT 0
+#define RG_CSI2_VCCTRL_WORD01_MASK (0xffffffff << 0)
+
+#define SENINF_CSI2_VCCTRL_WORD02 0x0228
+#define RG_CSI2_VCCTRL_WORD02_SHIFT 0
+#define RG_CSI2_VCCTRL_WORD02_MASK (0xffffffff << 0)
+
+#define SENINF_CSI2_VCCTRL_WORDDT0 0x022c
+#define RG_CSI2_VCCTRL_WORDVC0_SHIFT 0
+#define RG_CSI2_VCCTRL_WORDVC0_MASK (0x1f << 0)
+
+#define SENINF_CSI2_VCCTRL_WORD10 0x0230
+#define RG_CSI2_VCCTRL_WORD10_SHIFT 0
+#define RG_CSI2_VCCTRL_WORD10_MASK (0xffffffff << 0)
+
+#define SENINF_CSI2_VCCTRL_WORD11 0x0234
+#define RG_CSI2_VCCTRL_WORD11_SHIFT 0
+#define RG_CSI2_VCCTRL_WORD11_MASK (0xffffffff << 0)
+
+#define SENINF_CSI2_VCCTRL_WORD12 0x0238
+#define RG_CSI2_VCCTRL_WORD12_SHIFT 0
+#define RG_CSI2_VCCTRL_WORD12_MASK (0xffffffff << 0)
+
+#define SENINF_CSI2_VCCTRL_WORDDT1 0x023c
+#define RG_CSI2_VCCTRL_WORDVC1_SHIFT 0
+#define RG_CSI2_VCCTRL_WORDVC1_MASK (0x1f << 0)
+
+#define SENINF_CSI2_VCCTRL_WORD20 0x0240
+#define RG_CSI2_VCCTRL_WORD20_SHIFT 0
+#define RG_CSI2_VCCTRL_WORD20_MASK (0xffffffff << 0)
+
+#define SENINF_CSI2_VCCTRL_WORD21 0x0244
+#define RG_CSI2_VCCTRL_WORD21_SHIFT 0
+#define RG_CSI2_VCCTRL_WORD21_MASK (0xffffffff << 0)
+
+#define SENINF_CSI2_VCCTRL_WORD22 0x0248
+#define RG_CSI2_VCCTRL_WORD22_SHIFT 0
+#define RG_CSI2_VCCTRL_WORD22_MASK (0xffffffff << 0)
+
+#define SENINF_CSI2_VCCTRL_WORDDT2 0x024c
+#define RG_CSI2_VCCTRL_WORDVC2_SHIFT 0
+#define RG_CSI2_VCCTRL_WORDVC2_MASK (0x1f << 0)
+
+#define SENINF_CSI2_VCCTRL_WORD30 0x0250
+#define RG_CSI2_VCCTRL_WORD30_SHIFT 0
+#define RG_CSI2_VCCTRL_WORD30_MASK (0xffffffff << 0)
+
+#define SENINF_CSI2_VCCTRL_WORD31 0x0254
+#define RG_CSI2_VCCTRL_WORD31_SHIFT 0
+#define RG_CSI2_VCCTRL_WORD31_MASK (0xffffffff << 0)
+
+#define SENINF_CSI2_VCCTRL_WORD32 0x0258
+#define RG_CSI2_VCCTRL_WORD32_SHIFT 0
+#define RG_CSI2_VCCTRL_WORD32_MASK (0xffffffff << 0)
+
+#define SENINF_CSI2_VCCTRL_WORDDT3 0x025c
+#define RG_CSI2_VCCTRL_WORDVC3_SHIFT 0
+#define RG_CSI2_VCCTRL_WORDVC3_MASK (0x1f << 0)
+
+#define SENINF_CSI2_VCCTRL_WORD40 0x0260
+#define RG_CSI2_VCCTRL_WORD40_SHIFT 0
+#define RG_CSI2_VCCTRL_WORD40_MASK (0xffffffff << 0)
+
+#define SENINF_CSI2_VCCTRL_WORD41 0x0264
+#define RG_CSI2_VCCTRL_WORD41_SHIFT 0
+#define RG_CSI2_VCCTRL_WORD41_MASK (0xffffffff << 0)
+
+#define SENINF_CSI2_VCCTRL_WORD42 0x0268
+#define RG_CSI2_VCCTRL_WORD42_SHIFT 0
+#define RG_CSI2_VCCTRL_WORD42_MASK (0xffffffff << 0)
+
+#define SENINF_CSI2_VCCTRL_WORDDT4 0x026c
+#define RG_CSI2_VCCTRL_WORDVC4_SHIFT 0
+#define RG_CSI2_VCCTRL_WORDVC4_MASK (0x1f << 0)
+
+#define SENINF_CSI2_VCCTRL_WORD50 0x0270
+#define RG_CSI2_VCCTRL_WORD50_SHIFT 0
+#define RG_CSI2_VCCTRL_WORD50_MASK (0xffffffff << 0)
+
+#define SENINF_CSI2_VCCTRL_WORD51 0x0274
+#define RG_CSI2_VCCTRL_WORD51_SHIFT 0
+#define RG_CSI2_VCCTRL_WORD51_MASK (0xffffffff << 0)
+
+#define SENINF_CSI2_VCCTRL_WORD52 0x0278
+#define RG_CSI2_VCCTRL_WORD52_SHIFT 0
+#define RG_CSI2_VCCTRL_WORD52_MASK (0xffffffff << 0)
+
+#define SENINF_CSI2_VCCTRL_WORDDT5 0x027c
+#define RG_CSI2_VCCTRL_WORDVC5_SHIFT 0
+#define RG_CSI2_VCCTRL_WORDVC5_MASK (0x1f << 0)
+
+#define SENINF_CSI2_VCCTRL_WORD60 0x0280
+#define RG_CSI2_VCCTRL_WORD60_SHIFT 0
+#define RG_CSI2_VCCTRL_WORD60_MASK (0xffffffff << 0)
+
+#define SENINF_CSI2_VCCTRL_WORD61 0x0284
+#define RG_CSI2_VCCTRL_WORD61_SHIFT 0
+#define RG_CSI2_VCCTRL_WORD61_MASK (0xffffffff << 0)
+
+#define SENINF_CSI2_VCCTRL_WORD62 0x0288
+#define RG_CSI2_VCCTRL_WORD62_SHIFT 0
+#define RG_CSI2_VCCTRL_WORD62_MASK (0xffffffff << 0)
+
+#define SENINF_CSI2_VCCTRL_WORDDT6 0x028c
+#define RG_CSI2_VCCTRL_WORDVC6_SHIFT 0
+#define RG_CSI2_VCCTRL_WORDVC6_MASK (0x1f << 0)
+
+#define SENINF_CSI2_VCCTRL_WORD70 0x0290
+#define RG_CSI2_VCCTRL_WORD70_SHIFT 0
+#define RG_CSI2_VCCTRL_WORD70_MASK (0xffffffff << 0)
+
+#define SENINF_CSI2_VCCTRL_WORD71 0x0294
+#define RG_CSI2_VCCTRL_WORD71_SHIFT 0
+#define RG_CSI2_VCCTRL_WORD71_MASK (0xffffffff << 0)
+
+#define SENINF_CSI2_VCCTRL_WORD72 0x0298
+#define RG_CSI2_VCCTRL_WORD72_SHIFT 0
+#define RG_CSI2_VCCTRL_WORD72_MASK (0xffffffff << 0)
+
+#define SENINF_CSI2_VCCTRL_WORDDT7 0x029c
+#define RG_CSI2_VCCTRL_WORDVC7_SHIFT 0
+#define RG_CSI2_VCCTRL_WORDVC7_MASK (0x1f << 0)
+
+#define SENINF_CSI2_VCCTRL_WORD_MASK0 0x02a0
+#define RG_CSI2_VCCTRL_WORD_MASK0_SHIFT 0
+#define RG_CSI2_VCCTRL_WORD_MASK0_MASK (0xffffffff << 0)
+
+#define SENINF_CSI2_VCCTRL_WORD_MASK1 0x02a4
+#define RG_CSI2_VCCTRL_WORD_MASK1_SHIFT 0
+#define RG_CSI2_VCCTRL_WORD_MASK1_MASK (0xffffffff << 0)
+
+#define SENINF_CSI2_VCCTRL_WORD_MASK2 0x02a8
+#define RG_CSI2_VCCTRL_WORD_MASK2_SHIFT 0
+#define RG_CSI2_VCCTRL_WORD_MASK2_MASK (0xffffffff << 0)
+
+#endif
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_csi_phy_2_0/mtk_cam-seninf-seninf1-mux.h b/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_csi_phy_2_0/mtk_cam-seninf-seninf1-mux.h
new file mode 100644
index 0000000000000000000000000000000000000000..e3b5f03fc6aedb477a0ec86d3527189d4e706558
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_csi_phy_2_0/mtk_cam-seninf-seninf1-mux.h
@@ -0,0 +1,153 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2022 MediaTek Inc.
+ */
+
+#ifndef __SENINF1_MUX_H__
+#define __SENINF1_MUX_H__
+
+#define SENINF_MUX_CTRL_0 0x0000
+#define SENINF_MUX_EN_SHIFT 0
+#define SENINF_MUX_EN_MASK (0x1 << 0)
+#define SENINF_MUX_IRQ_SW_RST_SHIFT 1
+#define SENINF_MUX_IRQ_SW_RST_MASK (0x1 << 1)
+#define SENINF_MUX_SW_RST_SHIFT 2
+#define SENINF_MUX_SW_RST_MASK (0x1 << 2)
+
+#define SENINF_MUX_CTRL_1 0x0004
+#define RG_SENINF_MUX_SRC_SEL_SHIFT 0
+#define RG_SENINF_MUX_SRC_SEL_MASK (0xf << 0)
+#define RG_SENINF_MUX_PIX_MODE_SEL_SHIFT 8
+#define RG_SENINF_MUX_PIX_MODE_SEL_MASK (0x3 << 8)
+#define RG_SENINF_MUX_FIFO_PUSH_EN_SHIFT 16
+#define RG_SENINF_MUX_FIFO_PUSH_EN_MASK (0x3f << 16)
+#define RG_SENINF_MUX_RDY_FORCE_MODE_EN_SHIFT 24
+#define RG_SENINF_MUX_RDY_FORCE_MODE_EN_MASK (0x1 << 24)
+#define RG_SENINF_MUX_RDY_FORCE_MODE_VAL_SHIFT 25
+#define RG_SENINF_MUX_RDY_FORCE_MODE_VAL_MASK (0x1 << 25)
+#define RG_SENINF_MUX_CROP_EN_SHIFT 28
+#define RG_SENINF_MUX_CROP_EN_MASK (0x1 << 28)
+
+#define SENINF_MUX_OPT 0x0008
+#define RG_SENINF_MUX_CNT_INIT_OPT_SHIFT 0
+#define RG_SENINF_MUX_CNT_INIT_OPT_MASK (0x3 << 0)
+#define RG_SENINF_MUX_FIFO_FULL_OUTPUT_OPT_SHIFT 8
+#define RG_SENINF_MUX_FIFO_FULL_OUTPUT_OPT_MASK (0x3 << 8)
+#define RG_SENINF_MUX_FIFO_FULL_WR_MODE_SHIFT 10
+#define RG_SENINF_MUX_FIFO_FULL_WR_MODE_MASK (0x3 << 10)
+#define RG_SENINF_MUX_FIFO_OVERRUN_RST_EN_SHIFT 12
+#define RG_SENINF_MUX_FIFO_OVERRUN_RST_EN_MASK (0x1 << 12)
+#define RG_SENINF_MUX_HSYNC_POL_SHIFT 16
+#define RG_SENINF_MUX_HSYNC_POL_MASK (0x1 << 16)
+#define RG_SENINF_MUX_VSYNC_POL_SHIFT 17
+#define RG_SENINF_MUX_VSYNC_POL_MASK (0x1 << 17)
+
+#define SENINF_MUX_IRQ_EN 0x0010
+#define RG_SENINF_MUX_FIFO_OVERRUN_IRQ_EN_SHIFT 0
+#define RG_SENINF_MUX_FIFO_OVERRUN_IRQ_EN_MASK (0x1 << 0)
+#define RG_SENINF_MUX_FSM_ERR_IRQ_EN_SHIFT 1
+#define RG_SENINF_MUX_FSM_ERR_IRQ_EN_MASK (0x1 << 1)
+#define RG_SENINF_MUX_HSIZE_ERR_IRQ_EN_SHIFT 2
+#define RG_SENINF_MUX_HSIZE_ERR_IRQ_EN_MASK (0x1 << 2)
+#define RG_SENINF_MUX_VSIZE_ERR_IRQ_EN_SHIFT 3
+#define RG_SENINF_MUX_VSIZE_ERR_IRQ_EN_MASK (0x1 << 3)
+#define RG_SENINF_MUX_IRQ_CLR_MODE_SHIFT 31
+#define RG_SENINF_MUX_IRQ_CLR_MODE_MASK (0x1 << 31)
+
+#define SENINF_MUX_IRQ_STATUS 0x0018
+#define RO_SENINF_MUX_FIFO_OVERRUN_IRQ_SHIFT 0
+#define RO_SENINF_MUX_FIFO_OVERRUN_IRQ_MASK (0x1 << 0)
+#define RO_SENINF_MUX_FSM_ERR_IRQ_SHIFT 1
+#define RO_SENINF_MUX_FSM_ERR_IRQ_MASK (0x1 << 1)
+#define RO_SENINF_MUX_HSIZE_ERR_IRQ_SHIFT 2
+#define RO_SENINF_MUX_HSIZE_ERR_IRQ_MASK (0x1 << 2)
+#define RO_SENINF_MUX_VSIZE_ERR_IRQ_SHIFT 3
+#define RO_SENINF_MUX_VSIZE_ERR_IRQ_MASK (0x1 << 3)
+
+#define SENINF_MUX_IRQ_TRIG 0x001c
+#define RG_SENINF_MUX_IRQ_TRIG_SHIFT 0
+#define RG_SENINF_MUX_IRQ_TRIG_MASK (0xf << 0)
+#define RG_SENINF_MUX_IRQ_VERIF_EN_SHIFT 31
+#define RG_SENINF_MUX_IRQ_VERIF_EN_MASK (0x1 << 31)
+
+#define SENINF_MUX_IMG_SIZE 0x0020
+#define RG_SENINF_MUX_EXPECT_HSIZE_SHIFT 0
+#define RG_SENINF_MUX_EXPECT_HSIZE_MASK (0xffff << 0)
+#define RG_SENINF_MUX_EXPECT_VSIZE_SHIFT 16
+#define RG_SENINF_MUX_EXPECT_VSIZE_MASK (0xffff << 16)
+
+#define SENINF_MUX_CROP_PIX_CTRL 0x0028
+#define RG_SENINF_MUX_CROP_START_8PIX_CNT_SHIFT 0
+#define RG_SENINF_MUX_CROP_START_8PIX_CNT_MASK (0xfff << 0)
+#define RG_SENINF_MUX_CROP_END_8PIX_CNT_SHIFT 16
+#define RG_SENINF_MUX_CROP_END_8PIX_CNT_MASK (0xfff << 16)
+
+#define SENINF_MUX_SIZE 0x0030
+#define RO_SENINF_MUX_RCV_HSIZE_SHIFT 0
+#define RO_SENINF_MUX_RCV_HSIZE_MASK (0xffff << 0)
+#define RO_SENINF_MUX_RCV_VSIZE_SHIFT 16
+#define RO_SENINF_MUX_RCV_VSIZE_MASK (0xffff << 16)
+
+#define SENINF_MUX_ERR_SIZE 0x0034
+#define RO_SENINF_MUX_RCV_ERR_HSIZE_SHIFT 0
+#define RO_SENINF_MUX_RCV_ERR_HSIZE_MASK (0xffff << 0)
+#define RO_SENINF_MUX_RCV_ERR_VSIZE_SHIFT 16
+#define RO_SENINF_MUX_RCV_ERR_VSIZE_MASK (0xffff << 16)
+
+#define SENINF_MUX_FIFO_STATUS 0x0040
+#define RO_SENINF_MUX_FIFO_WA_SHIFT 0
+#define RO_SENINF_MUX_FIFO_WA_MASK (0x1ff << 0)
+#define RO_SENINF_MUX_FIFO_WCS_SHIFT 12
+#define RO_SENINF_MUX_FIFO_WCS_MASK (0x1 << 12)
+#define RO_SENINF_MUX_FIFO_RA_SHIFT 16
+#define RO_SENINF_MUX_FIFO_RA_MASK (0x1ff << 16)
+#define RO_SENINF_MUX_FIFO_RCS_SHIFT 28
+#define RO_SENINF_MUX_FIFO_RCS_MASK (0x1 << 28)
+
+#define SENINF_MUX_DBG_CTRL 0x0080
+#define RG_SENINF_MUX_DBG_EN_SHIFT 0
+#define RG_SENINF_MUX_DBG_EN_MASK (0x1 << 0)
+#define RG_SENINF_MUX_DBG_SEL_SHIFT 8
+#define RG_SENINF_MUX_DBG_SEL_MASK (0xff << 8)
+
+#define SENINF_MUX_DBG_OUT 0x0088
+#define RO_SENINF_MUX_DBG_OUT_SHIFT 0
+#define RO_SENINF_MUX_DBG_OUT_MASK (0xffffffff << 0)
+
+#define SENINF_MUX_CAM_MON 0x00a0
+#define RO_SENINF_MUX_CAM_MON_0_SHIFT 0
+#define RO_SENINF_MUX_CAM_MON_0_MASK (0xffff << 0)
+#define RO_SENINF_MUX_CAM_MON_1_SHIFT 16
+#define RO_SENINF_MUX_CAM_MON_1_MASK (0xffff << 16)
+
+#define SENINF_MUX_PIX_CNT 0x00a4
+#define RO_SENINF_MUX_PIX_CNT_SHIFT 0
+#define RO_SENINF_MUX_PIX_CNT_MASK (0xffffffff << 0)
+
+#define SENINF_MUX_FRAME_SIZE_MON_CTRL 0x00a8
+#define RG_SENINF_MUX_FRAME_SIZE_MON_EN_SHIFT 0
+#define RG_SENINF_MUX_FRAME_SIZE_MON_EN_MASK (0x1 << 0)
+
+#define SENINF_MUX_FRAME_SIZE_MON_H_VALID 0x00b0
+#define RO_SENINF_MUX_FRAME_H_VALID_SHIFT 0
+#define RO_SENINF_MUX_FRAME_H_VALID_MASK (0xffffffff << 0)
+
+#define SENINF_MUX_FRAME_SIZE_MON_H_BLANK 0x00b4
+#define RO_SENINF_MUX_FRAME_H_BLANK_SHIFT 0
+#define RO_SENINF_MUX_FRAME_H_BLANK_MASK (0xffffffff << 0)
+
+#define SENINF_MUX_FRAME_SIZE_MON_V_VALID 0x00b8
+#define RO_SENINF_MUX_FRAME_V_VALID_SHIFT 0
+#define RO_SENINF_MUX_FRAME_V_VALID_MASK (0xffffffff << 0)
+
+#define SENINF_MUX_FRAME_SIZE_MON_V_BLANK 0x00bc
+#define RO_SENINF_MUX_FRAME_V_BLANK_SHIFT 0
+#define RO_SENINF_MUX_FRAME_V_BLANK_MASK (0xffffffff << 0)
+
+#define SENINF_MUX_SPARE 0x00f0
+#define RG_SENINF_MUX_SPARE_0_SHIFT 0
+#define RG_SENINF_MUX_SPARE_0_MASK (0xff << 0)
+#define RG_SENINF_MUX_SPARE_1_SHIFT 16
+#define RG_SENINF_MUX_SPARE_1_MASK (0xff << 16)
+
+#endif
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_csi_phy_2_0/mtk_cam-seninf-seninf1.h b/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_csi_phy_2_0/mtk_cam-seninf-seninf1.h
new file mode 100644
index 0000000000000000000000000000000000000000..5dd1b35086362a31bd3af3dea3cf14e92ed8fd28
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_csi_phy_2_0/mtk_cam-seninf-seninf1.h
@@ -0,0 +1,53 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2022 MediaTek Inc.
+ */
+
+#ifndef __SENINF1_H__
+#define __SENINF1_H__
+
+#define SENINF_CTRL 0x0000
+#define SENINF_EN_SHIFT 0
+#define SENINF_EN_MASK (0x1 << 0)
+
+#define SENINF_DBG 0x0004
+#define RG_SENINF_DBG_SEL_SHIFT 0
+#define RG_SENINF_DBG_SEL_MASK (0xf << 0)
+
+#define SENINF_CSI2_CTRL 0x0010
+#define RG_SENINF_CSI2_EN_SHIFT 0
+#define RG_SENINF_CSI2_EN_MASK (0x1 << 0)
+#define SENINF_CSI2_SW_RST_SHIFT 4
+#define SENINF_CSI2_SW_RST_MASK (0x1 << 4)
+
+#define SENINF_TESTMDL_CTRL 0x0020
+#define RG_SENINF_TESTMDL_EN_SHIFT 0
+#define RG_SENINF_TESTMDL_EN_MASK (0x1 << 0)
+#define SENINF_TESTMDL_SW_RST_SHIFT 4
+#define SENINF_TESTMDL_SW_RST_MASK (0x1 << 4)
+
+#define SENINF_TG_CTRL 0x0030
+#define SENINF_TG_SW_RST_SHIFT 4
+#define SENINF_TG_SW_RST_MASK (0x1 << 4)
+
+#define SENINF_SCAM_CTRL 0x0040
+#define RG_SENINF_SCAM_EN_SHIFT 0
+#define RG_SENINF_SCAM_EN_MASK (0x1 << 0)
+#define SENINF_SCAM_SW_RST_SHIFT 4
+#define SENINF_SCAM_SW_RST_MASK (0x1 << 4)
+
+#define SENINF_PCAM_CTRL 0x0050
+#define RG_SENINF_PCAM_DATA_SEL_SHIFT 0
+#define RG_SENINF_PCAM_DATA_SEL_MASK (0x7 << 0)
+
+#define SENINF_CCIR_CTRL 0x0060
+#define SENINF_CCIR_SW_RST_SHIFT 4
+#define SENINF_CCIR_SW_RST_MASK (0x1 << 4)
+
+#define SENINF_SPARE 0x00f8
+#define RG_SENINF_SPARE_0_SHIFT 0
+#define RG_SENINF_SPARE_0_MASK (0xff << 0)
+#define RG_SENINF_SPARE_1_SHIFT 16
+#define RG_SENINF_SPARE_1_MASK (0xff << 16)
+
+#endif
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_csi_phy_2_0/mtk_cam-seninf-tg1.h b/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_csi_phy_2_0/mtk_cam-seninf-tg1.h
new file mode 100644
index 0000000000000000000000000000000000000000..fa91df8829435493241feaf6bf5e791504546c22
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_csi_phy_2_0/mtk_cam-seninf-tg1.h
@@ -0,0 +1,89 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2022 MediaTek Inc.
+ */
+
+#ifndef __SENINF_TG1_H__
+#define __SENINF_TG1_H__
+
+#define TM_CTL 0x0008
+#define TM_EN_SHIFT 0
+#define TM_EN_MASK (0x1 << 0)
+#define TM_RST_SHIFT 1
+#define TM_RST_MASK (0x1 << 1)
+#define TM_FMT_SHIFT 2
+#define TM_FMT_MASK (0x1 << 2)
+#define TM_BIN_IMG_SWITCH_EN_SHIFT 3
+#define TM_BIN_IMG_SWITCH_EN_MASK (0x1 << 3)
+#define TM_PAT_SHIFT 4
+#define TM_PAT_MASK (0x1f << 4)
+
+#define TM_SIZE 0x000c
+#define TM_PXL_SHIFT 0
+#define TM_PXL_MASK (0xffff << 0)
+#define TM_LINE_SHIFT 16
+#define TM_LINE_MASK (0xffff << 16)
+
+#define TM_CLK 0x0010
+#define TM_CLK_CNT_SHIFT 0
+#define TM_CLK_CNT_MASK (0xff << 0)
+#define TM_CLRBAR_OFT_SHIFT 8
+#define TM_CLRBAR_OFT_MASK (0x1fff << 8)
+#define TM_CLRBAR_IDX_SHIFT 28
+#define TM_CLRBAR_IDX_MASK (0x7 << 28)
+
+#define TM_DUM 0x0018
+#define TM_DUMMYPXL_SHIFT 0
+#define TM_DUMMYPXL_MASK (0xffff << 0)
+#define TM_VSYNC_SHIFT 16
+#define TM_VSYNC_MASK (0xffff << 16)
+
+#define TM_RAND_SEED 0x001c
+#define TM_SEED_SHIFT 0
+#define TM_SEED_MASK (0xffffffff << 0)
+
+#define TM_RAND_CTL 0x0020
+#define TM_DIFF_FRM_SHIFT 0
+#define TM_DIFF_FRM_MASK (0x1 << 0)
+
+#define TM_STAGGER_CTL 0x0024
+#define STAGGER_MODE_EN_SHIFT 0
+#define STAGGER_MODE_EN_MASK (0x1 << 0)
+#define EXP_NUM_SHIFT 4
+#define EXP_NUM_MASK (0x7 << 4)
+#define EXP_ONE_VSYNC_SHIFT 8
+#define EXP_ONE_VSYNC_MASK (0x1 << 8)
+
+#define TM_STAGGER_CON0 0x0028
+#define TM_EXP_DT0_SHIFT 0
+#define TM_EXP_DT0_MASK (0x3f << 0)
+#define TM_EXP_VSYNC_VC0_SHIFT 8
+#define TM_EXP_VSYNC_VC0_MASK (0x1f << 8)
+#define TM_EXP_HSYNC_VC0_SHIFT 16
+#define TM_EXP_HSYNC_VC0_MASK (0x1f << 16)
+
+#define TM_STAGGER_CON1 0x002c
+#define TM_EXP_DT1_SHIFT 0
+#define TM_EXP_DT1_MASK (0x3f << 0)
+#define TM_EXP_VSYNC_VC1_SHIFT 8
+#define TM_EXP_VSYNC_VC1_MASK (0x1f << 8)
+#define TM_EXP_HSYNC_VC1_SHIFT 16
+#define TM_EXP_HSYNC_VC1_MASK (0x1f << 16)
+
+#define TM_STAGGER_CON2 0x0030
+#define TM_EXP_DT2_SHIFT 0
+#define TM_EXP_DT2_MASK (0x3f << 0)
+#define TM_EXP_VSYNC_VC2_SHIFT 8
+#define TM_EXP_VSYNC_VC2_MASK (0x1f << 8)
+#define TM_EXP_HSYNC_VC2_SHIFT 16
+#define TM_EXP_HSYNC_VC2_MASK (0x1f << 16)
+
+#define TM_STAGGER_CON3 0x0034
+#define TM_EXP_DT3_SHIFT 0
+#define TM_EXP_DT3_MASK (0x3f << 0)
+#define TM_EXP_VSYNC_VC3_SHIFT 8
+#define TM_EXP_VSYNC_VC3_MASK (0x1f << 8)
+#define TM_EXP_HSYNC_VC3_SHIFT 16
+#define TM_EXP_HSYNC_VC3_MASK (0x1f << 16)
+
+#endif
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_csi_phy_2_0/mtk_cam-seninf-top-ctrl.h b/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_csi_phy_2_0/mtk_cam-seninf-top-ctrl.h
new file mode 100644
index 0000000000000000000000000000000000000000..4484072046164a6c1bb1f85511aedd6974063280
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_csi_phy_2_0/mtk_cam-seninf-top-ctrl.h
@@ -0,0 +1,399 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2022 MediaTek Inc.
+ */
+
+#ifndef __SENINF_TOP_H__
+#define __SENINF_TOP_H__
+
+#define SENINF_TOP_CTRL 0x0000
+#define SENINF_TOP_SW_RST_SHIFT 0
+#define SENINF_TOP_SW_RST_MASK (0x1 << 0)
+#define SENINF_TOP_N3D_SW_RST_SHIFT 4
+#define SENINF_TOP_N3D_SW_RST_MASK (0x1 << 4)
+#define RG_SENINF1_PCAM_PCLK_SEL_SHIFT 8
+#define RG_SENINF1_PCAM_PCLK_SEL_MASK (0x1 << 8)
+#define RG_SENINF2_PCAM_PCLK_SEL_SHIFT 9
+#define RG_SENINF2_PCAM_PCLK_SEL_MASK (0x1 << 9)
+#define RG_SENINF1_PCAM_PCLK_EN_SHIFT 12
+#define RG_SENINF1_PCAM_PCLK_EN_MASK (0x1 << 12)
+#define RG_SENINF2_PCAM_PCLK_EN_SHIFT 13
+#define RG_SENINF2_PCAM_PCLK_EN_MASK (0x1 << 13)
+#define RG_SLICE_FIFO_FULL_OPT_SHIFT 16
+#define RG_SLICE_FIFO_FULL_OPT_MASK (0x1 << 16)
+
+#define SENINF_TOP_DBG_CTRL 0x0008
+#define RG_SENINF_TOP_DBG_SEL_SHIFT 0
+#define RG_SENINF_TOP_DBG_SEL_MASK (0x1f << 0)
+#define RG_SENINF_TOP_DBG_BYTE0_SEL_SHIFT 16
+#define RG_SENINF_TOP_DBG_BYTE0_SEL_MASK (0x3 << 16)
+#define RG_SENINF_TOP_DBG_BYTE1_SEL_SHIFT 20
+#define RG_SENINF_TOP_DBG_BYTE1_SEL_MASK (0x3 << 20)
+#define RG_SENINF_TOP_DBG_BYTE2_SEL_SHIFT 24
+#define RG_SENINF_TOP_DBG_BYTE2_SEL_MASK (0x3 << 24)
+#define RG_SENINF_TOP_DBG_BYTE3_SEL_SHIFT 28
+#define RG_SENINF_TOP_DBG_BYTE3_SEL_MASK (0x3 << 28)
+
+#define SENINF_TOP_MUX_CTRL_0 0x0010
+#define RG_SENINF_MUX1_SRC_SEL_SHIFT 0
+#define RG_SENINF_MUX1_SRC_SEL_MASK (0xf << 0)
+#define RG_SENINF_MUX2_SRC_SEL_SHIFT 8
+#define RG_SENINF_MUX2_SRC_SEL_MASK (0xf << 8)
+#define RG_SENINF_MUX3_SRC_SEL_SHIFT 16
+#define RG_SENINF_MUX3_SRC_SEL_MASK (0xf << 16)
+#define RG_SENINF_MUX4_SRC_SEL_SHIFT 24
+#define RG_SENINF_MUX4_SRC_SEL_MASK (0xf << 24)
+
+#define SENINF_TOP_MUX_CTRL_1 0x0014
+#define RG_SENINF_MUX5_SRC_SEL_SHIFT 0
+#define RG_SENINF_MUX5_SRC_SEL_MASK (0xf << 0)
+#define RG_SENINF_MUX6_SRC_SEL_SHIFT 8
+#define RG_SENINF_MUX6_SRC_SEL_MASK (0xf << 8)
+#define RG_SENINF_MUX7_SRC_SEL_SHIFT 16
+#define RG_SENINF_MUX7_SRC_SEL_MASK (0xf << 16)
+#define RG_SENINF_MUX8_SRC_SEL_SHIFT 24
+#define RG_SENINF_MUX8_SRC_SEL_MASK (0xf << 24)
+
+#define SENINF_TOP_MUX_CTRL_2 0x0018
+#define RG_SENINF_MUX9_SRC_SEL_SHIFT 0
+#define RG_SENINF_MUX9_SRC_SEL_MASK (0xf << 0)
+#define RG_SENINF_MUX10_SRC_SEL_SHIFT 8
+#define RG_SENINF_MUX10_SRC_SEL_MASK (0xf << 8)
+#define RG_SENINF_MUX11_SRC_SEL_SHIFT 16
+#define RG_SENINF_MUX11_SRC_SEL_MASK (0xf << 16)
+#define RG_SENINF_MUX12_SRC_SEL_SHIFT 24
+#define RG_SENINF_MUX12_SRC_SEL_MASK (0xf << 24)
+
+#define SENINF_TOP_MUX_CTRL_3 0x001c
+#define RG_SENINF_MUX13_SRC_SEL_SHIFT 0
+#define RG_SENINF_MUX13_SRC_SEL_MASK (0xf << 0)
+
+#define SENINF_TOP_PHY_CTRL_CSI0 0x0060
+#define PHY_SENINF_MUX0_DPHY_EN_SHIFT 0
+#define PHY_SENINF_MUX0_DPHY_EN_MASK (0x1 << 0)
+#define PHY_SENINF_MUX0_CPHY_EN_SHIFT 1
+#define PHY_SENINF_MUX0_CPHY_EN_MASK (0x1 << 1)
+#define RG_PHY_SENINF_MUX0_CPHY_MODE_SHIFT 8
+#define RG_PHY_SENINF_MUX0_CPHY_MODE_MASK (0x3 << 8)
+
+#define SENINF_TOP_PHY_CTRL_CSI1 0x0064
+#define PHY_SENINF_MUX1_DPHY_EN_SHIFT 0
+#define PHY_SENINF_MUX1_DPHY_EN_MASK (0x1 << 0)
+#define PHY_SENINF_MUX1_CPHY_EN_SHIFT 1
+#define PHY_SENINF_MUX1_CPHY_EN_MASK (0x1 << 1)
+#define RG_PHY_SENINF_MUX1_CPHY_MODE_SHIFT 8
+#define RG_PHY_SENINF_MUX1_CPHY_MODE_MASK (0x3 << 8)
+
+#define SENINF_TOP_PHY_CTRL_CSI2 0x0068
+#define PHY_SENINF_MUX2_DPHY_EN_SHIFT 0
+#define PHY_SENINF_MUX2_DPHY_EN_MASK (0x1 << 0)
+#define PHY_SENINF_MUX2_CPHY_EN_SHIFT 1
+#define PHY_SENINF_MUX2_CPHY_EN_MASK (0x1 << 1)
+#define RG_PHY_SENINF_MUX2_CPHY_MODE_SHIFT 8
+#define RG_PHY_SENINF_MUX2_CPHY_MODE_MASK (0x3 << 8)
+
+#define SENINF_TOP_PHY_CTRL_CSI3 0x006c
+#define PHY_SENINF_MUX3_DPHY_EN_SHIFT 0
+#define PHY_SENINF_MUX3_DPHY_EN_MASK (0x1 << 0)
+#define PHY_SENINF_MUX3_CPHY_EN_SHIFT 1
+#define PHY_SENINF_MUX3_CPHY_EN_MASK (0x1 << 1)
+#define RG_PHY_SENINF_MUX3_CPHY_MODE_SHIFT 8
+#define RG_PHY_SENINF_MUX3_CPHY_MODE_MASK (0x3 << 8)
+
+#define SENINF_TOP_PHY_CTRL_CSI4 0x0070
+#define PHY_SENINF_MUX4_DPHY_EN_SHIFT 0
+#define PHY_SENINF_MUX4_DPHY_EN_MASK (0x1 << 0)
+#define PHY_SENINF_MUX4_CPHY_EN_SHIFT 1
+#define PHY_SENINF_MUX4_CPHY_EN_MASK (0x1 << 1)
+#define RG_PHY_SENINF_MUX4_CPHY_MODE_SHIFT 8
+#define RG_PHY_SENINF_MUX4_CPHY_MODE_MASK (0x3 << 8)
+
+#define SENINF_TOP_N3D_A_CTRL 0x0080
+#define RG_N3D_SENINF1_VSYNC_SRC_SEL_A_SHIFT 0
+#define RG_N3D_SENINF1_VSYNC_SRC_SEL_A_MASK (0xf << 0)
+#define RG_N3D_SENINF2_VSYNC_SRC_SEL_A_SHIFT 8
+#define RG_N3D_SENINF2_VSYNC_SRC_SEL_A_MASK (0xf << 8)
+
+#define SENINF_TOP_N3D_B_CTRL 0x0084
+#define RG_N3D_SENINF1_VSYNC_SRC_SEL_B_SHIFT 0
+#define RG_N3D_SENINF1_VSYNC_SRC_SEL_B_MASK (0xf << 0)
+#define RG_N3D_SENINF2_VSYNC_SRC_SEL_B_SHIFT 8
+#define RG_N3D_SENINF2_VSYNC_SRC_SEL_B_MASK (0xf << 8)
+
+#define SENINF_TOP_PHY_CHK_EN 0x00a0
+#define PHY_SENINF_MUX0_PHYD2MAC_DPHY_CHK_EN_SHIFT 0
+#define PHY_SENINF_MUX0_PHYD2MAC_DPHY_CHK_EN_MASK (0x1 << 0)
+#define PHY_SENINF_MUX1_PHYD2MAC_DPHY_CHK_EN_SHIFT 1
+#define PHY_SENINF_MUX1_PHYD2MAC_DPHY_CHK_EN_MASK (0x1 << 1)
+#define PHY_SENINF_MUX2_PHYD2MAC_DPHY_CHK_EN_SHIFT 2
+#define PHY_SENINF_MUX2_PHYD2MAC_DPHY_CHK_EN_MASK (0x1 << 2)
+#define PHY_SENINF_MUX3_PHYD2MAC_DPHY_CHK_EN_SHIFT 3
+#define PHY_SENINF_MUX3_PHYD2MAC_DPHY_CHK_EN_MASK (0x1 << 3)
+#define PHY_SENINF_MUX4_PHYD2MAC_DPHY_CHK_EN_SHIFT 4
+#define PHY_SENINF_MUX4_PHYD2MAC_DPHY_CHK_EN_MASK (0x1 << 4)
+#define PHY_SENINF_MUX0_PHYD2MAC_CPHY_CHK_EN_SHIFT 8
+#define PHY_SENINF_MUX0_PHYD2MAC_CPHY_CHK_EN_MASK (0x1 << 8)
+#define PHY_SENINF_MUX1_PHYD2MAC_CPHY_CHK_EN_SHIFT 9
+#define PHY_SENINF_MUX1_PHYD2MAC_CPHY_CHK_EN_MASK (0x1 << 9)
+#define PHY_SENINF_MUX2_PHYD2MAC_CPHY_CHK_EN_SHIFT 10
+#define PHY_SENINF_MUX2_PHYD2MAC_CPHY_CHK_EN_MASK (0x1 << 10)
+#define PHY_SENINF_MUX3_PHYD2MAC_CPHY_CHK_EN_SHIFT 11
+#define PHY_SENINF_MUX3_PHYD2MAC_CPHY_CHK_EN_MASK (0x1 << 11)
+#define PHY_SENINF_MUX4_PHYD2MAC_CPHY_CHK_EN_SHIFT 12
+#define PHY_SENINF_MUX4_PHYD2MAC_CPHY_CHK_EN_MASK (0x1 << 12)
+
+#define SENINF_TOP_PHY_CHK_MODE 0x00a4
+#define RG_PHY_SENINF_MUX0_PHYD2MAC_DPHY_CHK_MODE_SHIFT 0
+#define RG_PHY_SENINF_MUX0_PHYD2MAC_DPHY_CHK_MODE_MASK (0x1 << 0)
+#define RG_PHY_SENINF_MUX1_PHYD2MAC_DPHY_CHK_MODE_SHIFT 1
+#define RG_PHY_SENINF_MUX1_PHYD2MAC_DPHY_CHK_MODE_MASK (0x1 << 1)
+#define RG_PHY_SENINF_MUX2_PHYD2MAC_DPHY_CHK_MODE_SHIFT 2
+#define RG_PHY_SENINF_MUX2_PHYD2MAC_DPHY_CHK_MODE_MASK (0x1 << 2)
+#define RG_PHY_SENINF_MUX3_PHYD2MAC_DPHY_CHK_MODE_SHIFT 3
+#define RG_PHY_SENINF_MUX3_PHYD2MAC_DPHY_CHK_MODE_MASK (0x1 << 3)
+#define RG_PHY_SENINF_MUX4_PHYD2MAC_DPHY_CHK_MODE_SHIFT 4
+#define RG_PHY_SENINF_MUX4_PHYD2MAC_DPHY_CHK_MODE_MASK (0x1 << 4)
+#define RG_PHY_SENINF_MUX0_PHYD2MAC_CPHY_CHK_MODE_SHIFT 8
+#define RG_PHY_SENINF_MUX0_PHYD2MAC_CPHY_CHK_MODE_MASK (0x1 << 8)
+#define RG_PHY_SENINF_MUX1_PHYD2MAC_CPHY_CHK_MODE_SHIFT 9
+#define RG_PHY_SENINF_MUX1_PHYD2MAC_CPHY_CHK_MODE_MASK (0x1 << 9)
+#define RG_PHY_SENINF_MUX2_PHYD2MAC_CPHY_CHK_MODE_SHIFT 10
+#define RG_PHY_SENINF_MUX2_PHYD2MAC_CPHY_CHK_MODE_MASK (0x1 << 10)
+#define RG_PHY_SENINF_MUX3_PHYD2MAC_CPHY_CHK_MODE_SHIFT 11
+#define RG_PHY_SENINF_MUX3_PHYD2MAC_CPHY_CHK_MODE_MASK (0x1 << 11)
+#define RG_PHY_SENINF_MUX4_PHYD2MAC_CPHY_CHK_MODE_SHIFT 12
+#define RG_PHY_SENINF_MUX4_PHYD2MAC_CPHY_CHK_MODE_MASK (0x1 << 12)
+
+#define SENINF_TOP_PHY0_CHK_RES 0x00b0
+#define RO_PHY_SENINF_MUX0_PHYD2MAC_DPHY_L0_CHK_DONE_SHIFT 0
+#define RO_PHY_SENINF_MUX0_PHYD2MAC_DPHY_L0_CHK_DONE_MASK (0x1 << 0)
+#define RO_PHY_SENINF_MUX0_PHYD2MAC_DPHY_L1_CHK_DONE_SHIFT 1
+#define RO_PHY_SENINF_MUX0_PHYD2MAC_DPHY_L1_CHK_DONE_MASK (0x1 << 1)
+#define RO_PHY_SENINF_MUX0_PHYD2MAC_DPHY_L2_CHK_DONE_SHIFT 2
+#define RO_PHY_SENINF_MUX0_PHYD2MAC_DPHY_L2_CHK_DONE_MASK (0x1 << 2)
+#define RO_PHY_SENINF_MUX0_PHYD2MAC_DPHY_L3_CHK_DONE_SHIFT 3
+#define RO_PHY_SENINF_MUX0_PHYD2MAC_DPHY_L3_CHK_DONE_MASK (0x1 << 3)
+#define RO_PHY_SENINF_MUX0_PHYD2MAC_DPHY_L0_CHK_FAIL_SHIFT 8
+#define RO_PHY_SENINF_MUX0_PHYD2MAC_DPHY_L0_CHK_FAIL_MASK (0x1 << 8)
+#define RO_PHY_SENINF_MUX0_PHYD2MAC_DPHY_L1_CHK_FAIL_SHIFT 9
+#define RO_PHY_SENINF_MUX0_PHYD2MAC_DPHY_L1_CHK_FAIL_MASK (0x1 << 9)
+#define RO_PHY_SENINF_MUX0_PHYD2MAC_DPHY_L2_CHK_FAIL_SHIFT 10
+#define RO_PHY_SENINF_MUX0_PHYD2MAC_DPHY_L2_CHK_FAIL_MASK (0x1 << 10)
+#define RO_PHY_SENINF_MUX0_PHYD2MAC_DPHY_L3_CHK_FAIL_SHIFT 11
+#define RO_PHY_SENINF_MUX0_PHYD2MAC_DPHY_L3_CHK_FAIL_MASK (0x1 << 11)
+#define RO_PHY_SENINF_MUX0_PHYD2MAC_CPHY_T0_CHK_DONE_SHIFT 16
+#define RO_PHY_SENINF_MUX0_PHYD2MAC_CPHY_T0_CHK_DONE_MASK (0x1 << 16)
+#define RO_PHY_SENINF_MUX0_PHYD2MAC_CPHY_T1_CHK_DONE_SHIFT 17
+#define RO_PHY_SENINF_MUX0_PHYD2MAC_CPHY_T1_CHK_DONE_MASK (0x1 << 17)
+#define RO_PHY_SENINF_MUX0_PHYD2MAC_CPHY_T2_CHK_DONE_SHIFT 18
+#define RO_PHY_SENINF_MUX0_PHYD2MAC_CPHY_T2_CHK_DONE_MASK (0x1 << 18)
+#define RO_PHY_SENINF_MUX0_PHYD2MAC_CPHY_T3_CHK_DONE_SHIFT 19
+#define RO_PHY_SENINF_MUX0_PHYD2MAC_CPHY_T3_CHK_DONE_MASK (0x1 << 19)
+#define RO_PHY_SENINF_MUX0_PHYD2MAC_CPHY_T0_CHK_FAIL_SHIFT 24
+#define RO_PHY_SENINF_MUX0_PHYD2MAC_CPHY_T0_CHK_FAIL_MASK (0x1 << 24)
+#define RO_PHY_SENINF_MUX0_PHYD2MAC_CPHY_T1_CHK_FAIL_SHIFT 25
+#define RO_PHY_SENINF_MUX0_PHYD2MAC_CPHY_T1_CHK_FAIL_MASK (0x1 << 25)
+#define RO_PHY_SENINF_MUX0_PHYD2MAC_CPHY_T2_CHK_FAIL_SHIFT 26
+#define RO_PHY_SENINF_MUX0_PHYD2MAC_CPHY_T2_CHK_FAIL_MASK (0x1 << 26)
+#define RO_PHY_SENINF_MUX0_PHYD2MAC_CPHY_T3_CHK_FAIL_SHIFT 27
+#define RO_PHY_SENINF_MUX0_PHYD2MAC_CPHY_T3_CHK_FAIL_MASK (0x1 << 27)
+
+#define SENINF_TOP_PHY1_CHK_RES 0x00b4
+#define RO_PHY_SENINF_MUX1_PHYD2MAC_DPHY_L0_CHK_DONE_SHIFT 0
+#define RO_PHY_SENINF_MUX1_PHYD2MAC_DPHY_L0_CHK_DONE_MASK (0x1 << 0)
+#define RO_PHY_SENINF_MUX1_PHYD2MAC_DPHY_L1_CHK_DONE_SHIFT 1
+#define RO_PHY_SENINF_MUX1_PHYD2MAC_DPHY_L1_CHK_DONE_MASK (0x1 << 1)
+#define RO_PHY_SENINF_MUX1_PHYD2MAC_DPHY_L2_CHK_DONE_SHIFT 2
+#define RO_PHY_SENINF_MUX1_PHYD2MAC_DPHY_L2_CHK_DONE_MASK (0x1 << 2)
+#define RO_PHY_SENINF_MUX1_PHYD2MAC_DPHY_L3_CHK_DONE_SHIFT 3
+#define RO_PHY_SENINF_MUX1_PHYD2MAC_DPHY_L3_CHK_DONE_MASK (0x1 << 3)
+#define RO_PHY_SENINF_MUX1_PHYD2MAC_DPHY_L0_CHK_FAIL_SHIFT 8
+#define RO_PHY_SENINF_MUX1_PHYD2MAC_DPHY_L0_CHK_FAIL_MASK (0x1 << 8)
+#define RO_PHY_SENINF_MUX1_PHYD2MAC_DPHY_L1_CHK_FAIL_SHIFT 9
+#define RO_PHY_SENINF_MUX1_PHYD2MAC_DPHY_L1_CHK_FAIL_MASK (0x1 << 9)
+#define RO_PHY_SENINF_MUX1_PHYD2MAC_DPHY_L2_CHK_FAIL_SHIFT 10
+#define RO_PHY_SENINF_MUX1_PHYD2MAC_DPHY_L2_CHK_FAIL_MASK (0x1 << 10)
+#define RO_PHY_SENINF_MUX1_PHYD2MAC_DPHY_L3_CHK_FAIL_SHIFT 11
+#define RO_PHY_SENINF_MUX1_PHYD2MAC_DPHY_L3_CHK_FAIL_MASK (0x1 << 11)
+#define RO_PHY_SENINF_MUX1_PHYD2MAC_CPHY_T0_CHK_DONE_SHIFT 16
+#define RO_PHY_SENINF_MUX1_PHYD2MAC_CPHY_T0_CHK_DONE_MASK (0x1 << 16)
+#define RO_PHY_SENINF_MUX1_PHYD2MAC_CPHY_T1_CHK_DONE_SHIFT 17
+#define RO_PHY_SENINF_MUX1_PHYD2MAC_CPHY_T1_CHK_DONE_MASK (0x1 << 17)
+#define RO_PHY_SENINF_MUX1_PHYD2MAC_CPHY_T2_CHK_DONE_SHIFT 18
+#define RO_PHY_SENINF_MUX1_PHYD2MAC_CPHY_T2_CHK_DONE_MASK (0x1 << 18)
+#define RO_PHY_SENINF_MUX1_PHYD2MAC_CPHY_T3_CHK_DONE_SHIFT 19
+#define RO_PHY_SENINF_MUX1_PHYD2MAC_CPHY_T3_CHK_DONE_MASK (0x1 << 19)
+#define RO_PHY_SENINF_MUX1_PHYD2MAC_CPHY_T0_CHK_FAIL_SHIFT 24
+#define RO_PHY_SENINF_MUX1_PHYD2MAC_CPHY_T0_CHK_FAIL_MASK (0x1 << 24)
+#define RO_PHY_SENINF_MUX1_PHYD2MAC_CPHY_T1_CHK_FAIL_SHIFT 25
+#define RO_PHY_SENINF_MUX1_PHYD2MAC_CPHY_T1_CHK_FAIL_MASK (0x1 << 25)
+#define RO_PHY_SENINF_MUX1_PHYD2MAC_CPHY_T2_CHK_FAIL_SHIFT 26
+#define RO_PHY_SENINF_MUX1_PHYD2MAC_CPHY_T2_CHK_FAIL_MASK (0x1 << 26)
+#define RO_PHY_SENINF_MUX1_PHYD2MAC_CPHY_T3_CHK_FAIL_SHIFT 27
+#define RO_PHY_SENINF_MUX1_PHYD2MAC_CPHY_T3_CHK_FAIL_MASK (0x1 << 27)
+
+#define SENINF_TOP_PHY2_CHK_RES 0x00b8
+#define RO_PHY_SENINF_MUX2_PHYD2MAC_DPHY_L0_CHK_DONE_SHIFT 0
+#define RO_PHY_SENINF_MUX2_PHYD2MAC_DPHY_L0_CHK_DONE_MASK (0x1 << 0)
+#define RO_PHY_SENINF_MUX2_PHYD2MAC_DPHY_L1_CHK_DONE_SHIFT 1
+#define RO_PHY_SENINF_MUX2_PHYD2MAC_DPHY_L1_CHK_DONE_MASK (0x1 << 1)
+#define RO_PHY_SENINF_MUX2_PHYD2MAC_DPHY_L2_CHK_DONE_SHIFT 2
+#define RO_PHY_SENINF_MUX2_PHYD2MAC_DPHY_L2_CHK_DONE_MASK (0x1 << 2)
+#define RO_PHY_SENINF_MUX2_PHYD2MAC_DPHY_L3_CHK_DONE_SHIFT 3
+#define RO_PHY_SENINF_MUX2_PHYD2MAC_DPHY_L3_CHK_DONE_MASK (0x1 << 3)
+#define RO_PHY_SENINF_MUX2_PHYD2MAC_DPHY_L0_CHK_FAIL_SHIFT 8
+#define RO_PHY_SENINF_MUX2_PHYD2MAC_DPHY_L0_CHK_FAIL_MASK (0x1 << 8)
+#define RO_PHY_SENINF_MUX2_PHYD2MAC_DPHY_L1_CHK_FAIL_SHIFT 9
+#define RO_PHY_SENINF_MUX2_PHYD2MAC_DPHY_L1_CHK_FAIL_MASK (0x1 << 9)
+#define RO_PHY_SENINF_MUX2_PHYD2MAC_DPHY_L2_CHK_FAIL_SHIFT 10
+#define RO_PHY_SENINF_MUX2_PHYD2MAC_DPHY_L2_CHK_FAIL_MASK (0x1 << 10)
+#define RO_PHY_SENINF_MUX2_PHYD2MAC_DPHY_L3_CHK_FAIL_SHIFT 11
+#define RO_PHY_SENINF_MUX2_PHYD2MAC_DPHY_L3_CHK_FAIL_MASK (0x1 << 11)
+#define RO_PHY_SENINF_MUX2_PHYD2MAC_CPHY_T0_CHK_DONE_SHIFT 16
+#define RO_PHY_SENINF_MUX2_PHYD2MAC_CPHY_T0_CHK_DONE_MASK (0x1 << 16)
+#define RO_PHY_SENINF_MUX2_PHYD2MAC_CPHY_T1_CHK_DONE_SHIFT 17
+#define RO_PHY_SENINF_MUX2_PHYD2MAC_CPHY_T1_CHK_DONE_MASK (0x1 << 17)
+#define RO_PHY_SENINF_MUX2_PHYD2MAC_CPHY_T2_CHK_DONE_SHIFT 18
+#define RO_PHY_SENINF_MUX2_PHYD2MAC_CPHY_T2_CHK_DONE_MASK (0x1 << 18)
+#define RO_PHY_SENINF_MUX2_PHYD2MAC_CPHY_T3_CHK_DONE_SHIFT 19
+#define RO_PHY_SENINF_MUX2_PHYD2MAC_CPHY_T3_CHK_DONE_MASK (0x1 << 19)
+#define RO_PHY_SENINF_MUX2_PHYD2MAC_CPHY_T0_CHK_FAIL_SHIFT 24
+#define RO_PHY_SENINF_MUX2_PHYD2MAC_CPHY_T0_CHK_FAIL_MASK (0x1 << 24)
+#define RO_PHY_SENINF_MUX2_PHYD2MAC_CPHY_T1_CHK_FAIL_SHIFT 25
+#define RO_PHY_SENINF_MUX2_PHYD2MAC_CPHY_T1_CHK_FAIL_MASK (0x1 << 25)
+#define RO_PHY_SENINF_MUX2_PHYD2MAC_CPHY_T2_CHK_FAIL_SHIFT 26
+#define RO_PHY_SENINF_MUX2_PHYD2MAC_CPHY_T2_CHK_FAIL_MASK (0x1 << 26)
+#define RO_PHY_SENINF_MUX2_PHYD2MAC_CPHY_T3_CHK_FAIL_SHIFT 27
+#define RO_PHY_SENINF_MUX2_PHYD2MAC_CPHY_T3_CHK_FAIL_MASK (0x1 << 27)
+
+#define SENINF_TOP_PHY3_CHK_RES 0x00bc
+#define RO_PHY_SENINF_MUX3_PHYD2MAC_DPHY_L0_CHK_DONE_SHIFT 0
+#define RO_PHY_SENINF_MUX3_PHYD2MAC_DPHY_L0_CHK_DONE_MASK (0x1 << 0)
+#define RO_PHY_SENINF_MUX3_PHYD2MAC_DPHY_L1_CHK_DONE_SHIFT 1
+#define RO_PHY_SENINF_MUX3_PHYD2MAC_DPHY_L1_CHK_DONE_MASK (0x1 << 1)
+#define RO_PHY_SENINF_MUX3_PHYD2MAC_DPHY_L2_CHK_DONE_SHIFT 2
+#define RO_PHY_SENINF_MUX3_PHYD2MAC_DPHY_L2_CHK_DONE_MASK (0x1 << 2)
+#define RO_PHY_SENINF_MUX3_PHYD2MAC_DPHY_L3_CHK_DONE_SHIFT 3
+#define RO_PHY_SENINF_MUX3_PHYD2MAC_DPHY_L3_CHK_DONE_MASK (0x1 << 3)
+#define RO_PHY_SENINF_MUX3_PHYD2MAC_DPHY_L0_CHK_FAIL_SHIFT 8
+#define RO_PHY_SENINF_MUX3_PHYD2MAC_DPHY_L0_CHK_FAIL_MASK (0x1 << 8)
+#define RO_PHY_SENINF_MUX3_PHYD2MAC_DPHY_L1_CHK_FAIL_SHIFT 9
+#define RO_PHY_SENINF_MUX3_PHYD2MAC_DPHY_L1_CHK_FAIL_MASK (0x1 << 9)
+#define RO_PHY_SENINF_MUX3_PHYD2MAC_DPHY_L2_CHK_FAIL_SHIFT 10
+#define RO_PHY_SENINF_MUX3_PHYD2MAC_DPHY_L2_CHK_FAIL_MASK (0x1 << 10)
+#define RO_PHY_SENINF_MUX3_PHYD2MAC_DPHY_L3_CHK_FAIL_SHIFT 11
+#define RO_PHY_SENINF_MUX3_PHYD2MAC_DPHY_L3_CHK_FAIL_MASK (0x1 << 11)
+#define RO_PHY_SENINF_MUX3_PHYD2MAC_CPHY_T0_CHK_DONE_SHIFT 16
+#define RO_PHY_SENINF_MUX3_PHYD2MAC_CPHY_T0_CHK_DONE_MASK (0x1 << 16)
+#define RO_PHY_SENINF_MUX3_PHYD2MAC_CPHY_T1_CHK_DONE_SHIFT 17
+#define RO_PHY_SENINF_MUX3_PHYD2MAC_CPHY_T1_CHK_DONE_MASK (0x1 << 17)
+#define RO_PHY_SENINF_MUX3_PHYD2MAC_CPHY_T2_CHK_DONE_SHIFT 18
+#define RO_PHY_SENINF_MUX3_PHYD2MAC_CPHY_T2_CHK_DONE_MASK (0x1 << 18)
+#define RO_PHY_SENINF_MUX3_PHYD2MAC_CPHY_T3_CHK_DONE_SHIFT 19
+#define RO_PHY_SENINF_MUX3_PHYD2MAC_CPHY_T3_CHK_DONE_MASK (0x1 << 19)
+#define RO_PHY_SENINF_MUX3_PHYD2MAC_CPHY_T0_CHK_FAIL_SHIFT 24
+#define RO_PHY_SENINF_MUX3_PHYD2MAC_CPHY_T0_CHK_FAIL_MASK (0x1 << 24)
+#define RO_PHY_SENINF_MUX3_PHYD2MAC_CPHY_T1_CHK_FAIL_SHIFT 25
+#define RO_PHY_SENINF_MUX3_PHYD2MAC_CPHY_T1_CHK_FAIL_MASK (0x1 << 25)
+#define RO_PHY_SENINF_MUX3_PHYD2MAC_CPHY_T2_CHK_FAIL_SHIFT 26
+#define RO_PHY_SENINF_MUX3_PHYD2MAC_CPHY_T2_CHK_FAIL_MASK (0x1 << 26)
+#define RO_PHY_SENINF_MUX3_PHYD2MAC_CPHY_T3_CHK_FAIL_SHIFT 27
+#define RO_PHY_SENINF_MUX3_PHYD2MAC_CPHY_T3_CHK_FAIL_MASK (0x1 << 27)
+
+#define SENINF_TOP_PHY4_CHK_RES 0x00c0
+#define RO_PHY_SENINF_MUX4_PHYD2MAC_DPHY_L0_CHK_DONE_SHIFT 0
+#define RO_PHY_SENINF_MUX4_PHYD2MAC_DPHY_L0_CHK_DONE_MASK (0x1 << 0)
+#define RO_PHY_SENINF_MUX4_PHYD2MAC_DPHY_L1_CHK_DONE_SHIFT 1
+#define RO_PHY_SENINF_MUX4_PHYD2MAC_DPHY_L1_CHK_DONE_MASK (0x1 << 1)
+#define RO_PHY_SENINF_MUX4_PHYD2MAC_DPHY_L2_CHK_DONE_SHIFT 2
+#define RO_PHY_SENINF_MUX4_PHYD2MAC_DPHY_L2_CHK_DONE_MASK (0x1 << 2)
+#define RO_PHY_SENINF_MUX4_PHYD2MAC_DPHY_L3_CHK_DONE_SHIFT 3
+#define RO_PHY_SENINF_MUX4_PHYD2MAC_DPHY_L3_CHK_DONE_MASK (0x1 << 3)
+#define RO_PHY_SENINF_MUX4_PHYD2MAC_DPHY_L0_CHK_FAIL_SHIFT 8
+#define RO_PHY_SENINF_MUX4_PHYD2MAC_DPHY_L0_CHK_FAIL_MASK (0x1 << 8)
+#define RO_PHY_SENINF_MUX4_PHYD2MAC_DPHY_L1_CHK_FAIL_SHIFT 9
+#define RO_PHY_SENINF_MUX4_PHYD2MAC_DPHY_L1_CHK_FAIL_MASK (0x1 << 9)
+#define RO_PHY_SENINF_MUX4_PHYD2MAC_DPHY_L2_CHK_FAIL_SHIFT 10
+#define RO_PHY_SENINF_MUX4_PHYD2MAC_DPHY_L2_CHK_FAIL_MASK (0x1 << 10)
+#define RO_PHY_SENINF_MUX4_PHYD2MAC_DPHY_L3_CHK_FAIL_SHIFT 11
+#define RO_PHY_SENINF_MUX4_PHYD2MAC_DPHY_L3_CHK_FAIL_MASK (0x1 << 11)
+#define RO_PHY_SENINF_MUX4_PHYD2MAC_CPHY_T0_CHK_DONE_SHIFT 16
+#define RO_PHY_SENINF_MUX4_PHYD2MAC_CPHY_T0_CHK_DONE_MASK (0x1 << 16)
+#define RO_PHY_SENINF_MUX4_PHYD2MAC_CPHY_T1_CHK_DONE_SHIFT 17
+#define RO_PHY_SENINF_MUX4_PHYD2MAC_CPHY_T1_CHK_DONE_MASK (0x1 << 17)
+#define RO_PHY_SENINF_MUX4_PHYD2MAC_CPHY_T2_CHK_DONE_SHIFT 18
+#define RO_PHY_SENINF_MUX4_PHYD2MAC_CPHY_T2_CHK_DONE_MASK (0x1 << 18)
+#define RO_PHY_SENINF_MUX4_PHYD2MAC_CPHY_T3_CHK_DONE_SHIFT 19
+#define RO_PHY_SENINF_MUX4_PHYD2MAC_CPHY_T3_CHK_DONE_MASK (0x1 << 19)
+#define RO_PHY_SENINF_MUX4_PHYD2MAC_CPHY_T0_CHK_FAIL_SHIFT 24
+#define RO_PHY_SENINF_MUX4_PHYD2MAC_CPHY_T0_CHK_FAIL_MASK (0x1 << 24)
+#define RO_PHY_SENINF_MUX4_PHYD2MAC_CPHY_T1_CHK_FAIL_SHIFT 25
+#define RO_PHY_SENINF_MUX4_PHYD2MAC_CPHY_T1_CHK_FAIL_MASK (0x1 << 25)
+#define RO_PHY_SENINF_MUX4_PHYD2MAC_CPHY_T2_CHK_FAIL_SHIFT 26
+#define RO_PHY_SENINF_MUX4_PHYD2MAC_CPHY_T2_CHK_FAIL_MASK (0x1 << 26)
+#define RO_PHY_SENINF_MUX4_PHYD2MAC_CPHY_T3_CHK_FAIL_SHIFT 27
+#define RO_PHY_SENINF_MUX4_PHYD2MAC_CPHY_T3_CHK_FAIL_MASK (0x1 << 27)
+
+#define SENINF_TOP_PHY_SENINF_MUX0_DBG_CTRL 0x00d0
+#define RG_PHY_SENINF_MUX0_DBG_EN_SHIFT 0
+#define RG_PHY_SENINF_MUX0_DBG_EN_MASK (0x1 << 0)
+#define RG_PHY_SENINF_MUX0_DBG_SEL_SHIFT 8
+#define RG_PHY_SENINF_MUX0_DBG_SEL_MASK (0x1f << 8)
+
+#define SENINF_TOP_PHY_SENINF_MUX0_DBG_OUT 0x00d4
+#define RO_PHY_SENINF_MUX0_DBG_OUT_SHIFT 0
+#define RO_PHY_SENINF_MUX0_DBG_OUT_MASK (0xffffffff << 0)
+
+#define SENINF_TOP_PHY_SENINF_MUX1_DBG_CTRL 0x00d8
+#define RG_PHY_SENINF_MUX1_DBG_EN_SHIFT 0
+#define RG_PHY_SENINF_MUX1_DBG_EN_MASK (0x1 << 0)
+#define RG_PHY_SENINF_MUX1_DBG_SEL_SHIFT 8
+#define RG_PHY_SENINF_MUX1_DBG_SEL_MASK (0x1f << 8)
+
+#define SENINF_TOP_PHY_SENINF_MUX1_DBG_OUT 0x00dc
+#define RO_PHY_SENINF_MUX2_DBG_OUT_SHIFT 0
+#define RO_PHY_SENINF_MUX2_DBG_OUT_MASK (0xffffffff << 0)
+
+#define SENINF_TOP_PHY_SENINF_MUX2_DBG_CTRL 0x00e0
+#define RG_PHY_SENINF_MUX2_DBG_EN_SHIFT 0
+#define RG_PHY_SENINF_MUX2_DBG_EN_MASK (0x1 << 0)
+#define RG_PHY_SENINF_MUX2_DBG_SEL_SHIFT 8
+#define RG_PHY_SENINF_MUX2_DBG_SEL_MASK (0x1f << 8)
+
+#define SENINF_TOP_PHY_SENINF_MUX2_DBG_OUT 0x00e4
+#define RO_PHY_SENINF_MUX2_DBG_OUT_SHIFT 0
+#define RO_PHY_SENINF_MUX2_DBG_OUT_MASK (0xffffffff << 0)
+
+#define SENINF_TOP_PHY_SENINF_MUX3_DBG_CTRL 0x00e8
+#define RG_PHY_SENINF_MUX3_DBG_EN_SHIFT 0
+#define RG_PHY_SENINF_MUX3_DBG_EN_MASK (0x1 << 0)
+#define RG_PHY_SENINF_MUX3_DBG_SEL_SHIFT 8
+#define RG_PHY_SENINF_MUX3_DBG_SEL_MASK (0x1f << 8)
+
+#define SENINF_TOP_PHY_SENINF_MUX3_DBG_OUT 0x00ec
+#define RO_PHY_SENINF_MUX3_DBG_OUT_SHIFT 0
+#define RO_PHY_SENINF_MUX3_DBG_OUT_MASK (0xffffffff << 0)
+
+#define SENINF_TOP_PHY_SENINF_MUX4_DBG_CTRL 0x00f0
+#define RG_PHY_SENINF_MUX4_DBG_EN_SHIFT 0
+#define RG_PHY_SENINF_MUX4_DBG_EN_MASK (0x1 << 0)
+#define RG_PHY_SENINF_MUX4_DBG_SEL_SHIFT 8
+#define RG_PHY_SENINF_MUX4_DBG_SEL_MASK (0x1f << 8)
+
+#define SENINF_TOP_PHY_SENINF_MUX4_DBG_OUT 0x00f4
+#define RO_PHY_SENINF_MUX4_DBG_OUT_SHIFT 0
+#define RO_PHY_SENINF_MUX4_DBG_OUT_MASK (0xffffffff << 0)
+
+#define SENINF_TOP_SPARE 0x00f8
+#define RG_SENINF_TOP_SPARE_0_SHIFT 0
+#define RG_SENINF_TOP_SPARE_0_MASK (0xff << 0)
+#define RG_SENINF_TOP_SPARE_1_SHIFT 16
+#define RG_SENINF_TOP_SPARE_1_MASK (0xff << 16)
+
+#define SENINF_TOP_FIFO_THRESH 0x00fc
+#define RG_FIFO_ALMOST_FULL_THRESHOLD_SHIFT 0
+#define RG_FIFO_ALMOST_FULL_THRESHOLD_MASK (0xffff << 0)
+#define RG_FIFO_ALMOST_FULL_PULSE_WIDTH_SHIFT 16
+#define RG_FIFO_ALMOST_FULL_PULSE_WIDTH_MASK (0xffff << 16)
+
+#endif
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_csi_phy_2_0/sub_drv.mk b/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_csi_phy_2_0/sub_drv.mk
new file mode 100644
index 0000000000000000000000000000000000000000..300f1bfa2adc0e2e8701160e831b215dcd5f0c70
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/camsys/src/mtk_csi_phy_2_0/sub_drv.mk
@@ -0,0 +1,6 @@
+# SPDX-License-Identifier: GPL-2.0
+# Copyright (C) 2022 MediaTek Inc.
+
+mtk-cam-isp-objs += \
+	mtk_csi_phy_2_0/mtk_cam-seninf-hw_phy_2_0.o
+
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/camsys/unit_test/Makefile b/drivers/media/platform/mediatek/isp/isp_7x/camsys/unit_test/Makefile
new file mode 100644
index 0000000000000000000000000000000000000000..cdac08f71c8db628685e150d13553c67f3508bd8
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/camsys/unit_test/Makefile
@@ -0,0 +1,10 @@
+
+ccflags-y += -I$(srctree)/drivers/media/platform/mediatek/isp \
+	     -I$(srctree)/drivers/media/platform/mediatek/isp/isp_7x/camsys/
+
+cam-ut-objs := mtk_cam_ut-cam.o \
+	       mtk_cam_ut-seninf.o \
+	       mtk_cam_ut.o \
+	       mtk_cam_ut-camsv.o
+
+obj-y += cam-ut.o
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/camsys/unit_test/mtk_cam_regs_mt8188.h b/drivers/media/platform/mediatek/isp/isp_7x/camsys/unit_test/mtk_cam_regs_mt8188.h
new file mode 100644
index 0000000000000000000000000000000000000000..649db2a6557cee6f661707d463e6869fe6787fc2
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/camsys/unit_test/mtk_cam_regs_mt8188.h
@@ -0,0 +1,244 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2020 MediaTek Inc.
+ * Author: Bibby Hsieh <bibby.hsieh@mediatek.com>
+ */
+
+/* normal siganl */
+#define VS_INT_ST								(1L << 0)
+#define TG_INT1_ST								(1L << 1)
+#define TG_INT2_ST								(1L << 2)
+#define EXPDON_ST								(1L << 5)
+#define SOF_INT_ST								(1L << 8)
+#define HW_PASS1_DON_ST							(1L << 20)
+#define SW_PASS1_DON_ST							(1L << 22)
+/* YUV siganl */
+#define YUV_SW_PASS1_DON_ST						(1L << 0)
+#define YUV_PASS1_DON_ST						(1L << 1)
+#define YUV_DMA_ERR_ST							(1L << 2)
+/* err status */
+#define TG_OVRUN_ST								(1L << 6)
+#define TG_GBERR_ST								(1L << 7)
+#define CQ_DB_LOAD_ERR_ST						(1L << 12)
+#define CQ_MAIN_CODE_ERR_ST						(1L << 14)
+#define CQ_MAIN_VS_ERR_ST						(1L << 15)
+#define CQ_MAIN_TRIG_DLY_ST						(1L << 16)
+#define LSCI_ERR_ST								(1L << 24)
+#define DMA_ERR_ST								(1L << 26)
+/* CAM DMA done status */
+#define IMGO_DONE_ST							(1L << 0)
+#define CQI_R1_DONE_ST							(1L << 8)
+/* IRQ signal mask */
+#define INT_ST_MASK_CAM (VS_INT_ST	 |\
+			 TG_INT1_ST	 |\
+			 TG_INT2_ST	 |\
+			 EXPDON_ST       |\
+			 HW_PASS1_DON_ST |\
+			 SOF_INT_ST      |\
+			 SW_PASS1_DON_ST)
+/* IRQ Error Mask */
+#define INT_ST_MASK_CAM_ERR (TG_OVRUN_ST	 |\
+			     TG_GBERR_ST	 |\
+			     CQ_DB_LOAD_ERR_ST	 |\
+			     CQ_MAIN_CODE_ERR_ST |\
+			     CQ_MAIN_VS_ERR_ST	 |\
+			     DMA_ERR_ST)
+#define ISP_SENINF_CTRL(regs)					(regs + 0x0200)
+#define ISP_SENINF_TSETMDL_CTRL(regs)			(regs + 0x0220)
+#define ISP_SENINF_MUX_CTRL_0(regs)				(regs + 0x0D00)
+#define ISP_SENINF_MUX_CTRL_1(regs)				(regs + 0x0D04)
+#define ISP_SENINF_TM_CTL(regs)					(regs + 0x0F08)
+#define ISP_SENINF_TM_SIZE(regs)				(regs + 0x0F0C)
+#define ISP_SENINF_TM_CLK(regs)					(regs + 0x0F10)
+#define ISP_SENINF_TM_DUM(regs)					(regs + 0x0F18)
+#define ISP_SENINF_CAM_MUX_PCSR_0(regs)			(regs + 0x0400)
+#define CAMSYS_MAIN_REG_HALT1_EN(regs)			(regs + 0x0350)
+#define CAMSYS_MAIN_REG_HALT2_EN(regs)			(regs + 0x0354)
+#define CAMSYS_MAIN_REG_HALT3_EN(regs)			(regs + 0x0358)
+#define CAMSYS_MAIN_REG_HALT4_EN(regs)			(regs + 0x035C)
+#define CAMSYS_MAIN_REG_HALT5_EN(regs)			(regs + 0x0360)
+#define CAMSYS_MAIN_REG_HALT6_EN(regs)			(regs + 0x0364)
+#define CAM_REG_CTL_RAW_INT_STATUS(regs)		(regs + 0x0104)
+#define CAM_REG_CTL_RAW_INT2_STATUS(regs)		(regs + 0x0114)
+#define CAM_REG_CTL_RAW_INT3_STATUS(regs)		(regs + 0x0124)
+#define CAM_REG_CTL_RAW_INT4_STATUS(regs)		(regs + 0x0134)
+#define CAM_REG_CTL_RAW_INT5_STATUS(regs)		(regs + 0x0144)
+#define CAM_REG_CTL_RAW_INT6_EN					0x0150
+#define CAM_REG_CTL_RAW_INT6_STATUS(regs)		(regs + 0x0154)
+#define CAM_REG_CTL_RAW_INT7_EN					0x0160
+#define CAM_REG_CTL_RAW_INT7_STATUS(regs)		(regs + 0x0164)
+#define CAM_REG_CTL_RAW_INT_STATUSX(regs)		(regs + 0x0108)
+#define CAM_REG_CTL_RAW_INT2_STATUSX(regs)		(regs + 0x0118)
+#define CAM_REG_CTL_RAW_INT3_STATUSX(regs)		(regs + 0x0128)
+#define CAM_REG_CTL_RAW_INT4_STATUSX(regs)		(regs + 0x0138)
+#define CAM_REG_CTL_RAW_INT5_STATUSX(regs)		(regs + 0x0148)
+#define CAM_REG_CTL_RAW_INT6_STATUSX(regs)		(regs + 0x0158)
+#define CTL_CQ_THR0_DONE_ST						BIT(0)
+#define CAM_REG_CTL_RAW_INT7_STATUSX(regs)		(regs + 0x0168)
+#define CTL_CQ_THRSUB_DONE_ST					BIT(10)
+#define CAM_REG_CTL2_RAW_INT_STATUS(regs)		(regs + 0x0104)
+#define CAM_REG_CTL2_RAW_INT2_STATUS(regs)		(regs + 0x0114)
+#define CAM_REG_CTL2_RAW_INT4_STATUS(regs)		(regs + 0x0134)
+#define CAM_REG_CTL2_RAW_INT5_STATUS(regs)		(regs + 0x0144)
+#define CAM_REG_CTL2_RAW_INT_STATUSX(regs)		(regs + 0x0108)
+#define CAM_REG_CTL2_RAW_INT2_STATUSX(regs)		(regs + 0x0118)
+#define CAM_REG_CTL2_RAW_INT4_STATUSX(regs)		(regs + 0x0138)
+#define CAM_REG_CTL2_RAW_INT5_STATUSX(regs)		(regs + 0x0148)
+#define CAM_REG_CTL_RAW_MOD5_DCM_DIS			0x0310
+#define CAM_REG_CTL_RAW_MOD6_DCM_DIS			0x0314
+#define CAM_REG_CQ_THR0_CTL(regs)				(regs + 0x0410)
+#define CAM_REG_CQ_THR0_BASEADDR(regs)			(regs + 0x0414)
+#define CAM_REG_CQ_THR0_DESC_SIZE(regs)			(regs + 0x041C)
+#define CAM_REG_TG_SEN_MODE(regs)				(regs + 0x0700)
+#define TG_CMOS_RDY_SEL							BIT(14)
+#define CAM_REG_TG_SEN_GRAB_PXL(regs)			(regs + 0x0708)
+#define CAM_REG_TG_SEN_GRAB_LIN(regs)			(regs + 0x070C)
+#define CAM_REG_TG_PATH_CFG(regs)				(regs + 0x0710)
+#define TG_TG_FULL_SEL							BIT(15)
+#define CAM_REG_TG_FRMSIZE_ST(regs)				(regs + 0x0738)
+#define CAM_REG_TG_FRMSIZE_ST_R(regs)			(regs + 0x076C)
+#define CAM_REG_CQI_R1A_CON0(regs)				(regs + 0x4430)
+#define CAM_REG_CQI_R1A_CON1(regs)				(regs + 0x4434)
+#define CAM_REG_CQI_R1A_CON2(regs)				(regs + 0x4438)
+#define CAM_REG_CQI_R1A_CON3(regs)				(regs + 0x443C)
+#define CAM_REG_CQI_R1A_CON4(regs)				(regs + 0x4440)
+#define CAM_REG_CQI_R2A_CON0(regs)				(regs + 0x44A0)
+#define CAM_REG_CQI_R2A_CON1(regs)				(regs + 0x44A4)
+#define CAM_REG_CQI_R2A_CON2(regs)				(regs + 0x44A8)
+#define CAM_REG_CQI_R2A_CON3(regs)				(regs + 0x44AC)
+#define CAM_REG_CQI_R2A_CON4(regs)				(regs + 0x44B0)
+#define CAM_REG_CQI_R3A_CON0(regs)				(regs + 0x4510)
+#define CAM_REG_CQI_R3A_CON1(regs)				(regs + 0x4514)
+#define CAM_REG_CQI_R3A_CON2(regs)				(regs + 0x4518)
+#define CAM_REG_CQI_R3A_CON3(regs)				(regs + 0x451C)
+#define CAM_REG_CQI_R3A_CON4(regs)				(regs + 0x4520)
+#define CAM_REG_CQI_R4A_CON0(regs)				(regs + 0x4580)
+#define CAM_REG_CQI_R4A_CON1(regs)				(regs + 0x4584)
+#define CAM_REG_CQI_R4A_CON2(regs)				(regs + 0x4588)
+#define CAM_REG_CQI_R4A_CON3(regs)				(regs + 0x458C)
+#define CAM_REG_CQI_R4A_CON4(regs)				(regs + 0x4590)
+#define CAM_REG_IMGO_CON0(regs)					(regs + 0x48a0)
+#define CAM_REG_IMGO_CON1(regs)					(regs + 0x48a4)
+#define CAM_REG_IMGO_CON2(regs)					(regs + 0x48a8)
+#define CAM_REG_IMGO_CON3(regs)					(regs + 0x48ac)
+#define CAM_REG_IMGO_CON4(regs)					(regs + 0x4900)
+/* error status */
+#define REG_RAWI_R2_ERR_STAT					0x4134
+#define REG_UFDI_R2_ERR_STAT					0x41A4
+#define REG_RAWI_R3_ERR_STAT					0x4214
+#define REG_UFDI_R3_ERR_STAT					0x4284
+#define REG_CQI_R1_ERR_STAT						0x4444
+#define REG_CQI_R2_ERR_STAT						0x44B4
+#define REG_CQI_R3_ERR_STAT						0x4524
+#define REG_CQI_R4_ERR_STAT						0x4594
+#define REG_LSCI_R1_ERR_STAT					0x4604
+#define REG_BPCI_R1_ERR_STAT					0x4674
+#define REG_BPCI_R2_ERR_STAT					0x46B4
+#define REG_BPCI_R3_ERR_STAT					0x46F4
+#define REG_PDI_R1_ERR_STAT						0x4734
+#define REG_AAI_R1_ERR_STAT						0x47B4
+#define REG_CACI_R1_ERR_STAT					0x47F4
+#define REG_RAWI2_R6_ERR_STAT					0x4834
+#define REG_IMGO_R1_ERR_STAT					0x48B4
+#define REG_FHO_R1_ERR_STAT						0x4964
+#define REG_AAHO_R1_ERR_STAT					0x4A14
+#define REG_PDO_R1_ERR_STAT						0x4AC4
+#define REG_AAO_R1_ERR_STAT						0x4B74
+#define REG_AFO_R1_ERR_STAT						0x4C24
+#define REG_TSFSO_R1_ERR_STAT					0x4CD4
+#define REG_LTMSO_R1_ERR_STAT					0x4D14
+#define REG_FLKO_R1_ERR_STAT					0x4D54
+#define REG_UFEO_R1_ERR_STAT					0x4D94
+#define REG_TSFSO_R2_ERR_STAT					0x4E14
+/* error status, yuv base */
+#define REG_YUVO_R1_ERR_STAT					0x4234
+#define REG_YUVBO_R1_ERR_STAT					0x42E4
+#define REG_YUVCO_R1_ERR_STAT					0x4394
+#define REG_YUVDO_R1_ERR_STAT					0x4444
+#define REG_YUVO_R3_ERR_STAT					0x44F4
+#define REG_YUVBO_R3_ERR_STAT					0x45A4
+#define REG_YUVCO_R3_ERR_STAT					0x4654
+#define REG_YUVDO_R3_ERR_STAT					0x4704
+#define REG_YUVO_R2_ERR_STAT					0x47B4
+#define REG_YUVBO_R2_ERR_STAT					0x47F4
+#define REG_YUVO_R4_ERR_STAT					0x4834
+#define REG_YUVBO_R4_ERR_STAT					0x4874
+#define REG_RZH1N2TO_R1_ERR_STAT				0x48B4
+#define REG_RZH1N2TBO_R1_ERR_STAT				0x48F4
+#define REG_RZH1N2TO_R2_ERR_STAT				0x4934
+#define REG_RZH1N2TO_R3_ERR_STAT				0x4974
+#define REG_RZH1N2TBO_R3_ERR_STAT				0x49B4
+#define REG_DRZS4NO_R1_ERR_STAT					0x49F4
+#define REG_DRZS4NO_R2_ERR_STAT					0x4A34
+#define REG_DRZS4NO_R3_ERR_STAT					0x4A74
+#define REG_ACTSO_R1_ERR_STAT					0x4AF4
+#define REG_TNCSYO_R1_ERR_STAT					0x4BF4
+#define REG_YUVO_R5_ERR_STAT					0x4C34
+#define REG_YUVBO_R5_ERR_STAT					0x4C74
+/* CQ related */
+#define REG_CQ_EN								0x0400
+#define REG_SCQ_START_PERIOD					0x0408
+#define REG_CQ_THR0_CTL							0x0410
+#define REG_CQ_THR0_BASEADDR					0x0414
+#define REG_CQ_THR0_BASEADDR_MSB				0x0418
+#define REG_CQ_THR0_DESC_SIZE					0x041C
+#define REG_CQ_SUB_CQ_EN						0x06B0
+#define REG_CQ_SUB_THR0_CTL						0x06C0
+#define REG_CQ_SUB_THR0_BASEADDR_2				0x06CC
+#define REG_CQ_SUB_THR0_BASEADDR_MSB_2			0x06D0
+#define REG_CQ_SUB_THR0_DESC_SIZE_2				0x06D8
+#define REG_CQ_SUB_THR0_BASEADDR_1				0x06C4
+#define REG_CQ_SUB_THR0_BASEADDR_MSB_1			0x06C8
+#define REG_CQ_SUB_THR0_DESC_SIZE_1				0x06D4
+#define CQ_DB_EN								BIT(4)
+#define CQ_DB_LOAD_MODE							BIT(8)
+#define CQ_RESET								BIT(16)
+#define CTL_CQ_THR0_START						BIT(0)
+#define CQ_THR0_MODE_IMMEDIATE					BIT(4)
+#define CQ_THR0_MODE_CONTINUOUS					BIT(5)
+#define CQ_THR0_DONE_SEL						BIT(8)
+#define SCQ_EN									BIT(20)
+#define SCQ_SUBSAMPLE_EN                    	BIT(21)
+#define SCQ_SUB_RESET							BIT(16)
+#define CQ_THR0_EN								BIT(0)
+#define CQ_CQI_R1_EN							BIT(15)
+#define CQ_CQI_R2_EN							BIT(16)
+#define CAMCQ_SCQ_EN							BIT(20)
+#define PASS1_DONE_SEL							BIT(31)
+/* camsys */
+#define REG_CAMSYS_CG_SET						0x0004
+#define REG_CAMSYS_CG_CLR						0x0008
+#define REG_CTL_START							0x00B0
+/* camctl */
+#define REG_CTL_RAWI_TRIG						0x00C0
+#define REG_CTL_SW_CTL							0x00C4
+#define REG_CTL_SW_PASS1_DONE					0x00C8
+#define REG_CTL_SW_SUB_CTL						0x00CC
+/* TG */
+#define REG_TG_SEN_MODE							0x0700
+#define TG_SEN_MODE_CMOS_EN						BIT(0)
+#define REG_TG_VF_CON							0x0704
+#define TG_VFDATA_EN							BIT(0)
+#define REG_TG_INTER_ST							0x073C
+#define TG_CAM_CS_MASK							0x3f00
+#define TG_IDLE_ST								BIT(8)
+/* DBG */
+#define CAM_REG_CQ_SUB_THR0_BASEADDR_1(regs)	(regs + 0x0620)
+#define CAM_REG_CQ_SUB_THR0_BASEADDR_2(regs)	(regs + 0x0624)
+#define CAM_REG_SUB_THR0_DESC_SIZE_1(regs)		(regs + 0x0628)
+#define CAM_REG_SUB_THR0_DESC_SIZE_2(regs)		(regs + 0x062C)
+#define CAM_REG_IMGO_ORIWDMA_BASE_ADDR(regs)	(regs + 0x4820)
+#define CAM_REG_AAO_ORIWDMA_BASE_ADDR(regs)		(regs + 0x4AE0)
+#define CAM_REG_YUVO_R1_ORIWDMA_BASE_ADDR(regs)	(regs + 0x4200)
+#define CAM_REG_YUVO_R3_ORIWDMA_BASE_ADDR(regs)	(regs + 0x44C0)
+#define CAM_REG_FBC_IMGO_R1_CTL2(regs)			(regs + 0x2C04)
+#define CAM_REG_FBC_YUVO_R1_CTL2(regs)			(regs + 0x3784)
+#define CAM_REG_FBC_YUVO_R3_CTL2(regs)			(regs + 0x37A4)
+#define CAM_REG_CQ_EN(regs)						(regs + 0x0400)
+#define CAM_REG_SUB_CQ_EN(regs)					(regs + 0x060C)
+#define CAM_REG_SW_PASS1_DONE(regs)				(regs + 0x00C8)
+#define CAM_REG_SW_SUB_CTL(regs)				(regs + 0x00CC)
+#define CAM_REG_FBC_AAO_R1_CTL1(regs)			(regs + 0x2C20)
+#define CAM_REG_FBC_AAHO_R1_CTL1(regs)			(regs + 0x2C10)
+#define CAM_REG_FBC_AAO_R1_CTL2(regs)			(regs + 0x2C24)
+#define CAM_REG_FBC_AAHO_R1_CTL2(regs)			(regs + 0x2C14)
\ No newline at end of file
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/camsys/unit_test/mtk_cam_regs_mt8195.h b/drivers/media/platform/mediatek/isp/isp_7x/camsys/unit_test/mtk_cam_regs_mt8195.h
new file mode 100644
index 0000000000000000000000000000000000000000..7229cc42d6056653faadb39a8933cd9becaad269
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/camsys/unit_test/mtk_cam_regs_mt8195.h
@@ -0,0 +1,280 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2021 MediaTek Inc.
+ * Author: Bibby Hsieh <bibby.hsieh@mediatek.com>
+ */
+
+/* normal siganl */
+#define VS_INT_ST								(1L << 0)
+#define TG_INT1_ST								(1L << 1)
+#define TG_INT2_ST								(1L << 2)
+#define EXPDON_ST								(1L << 5)
+#define SOF_INT_ST								(1L << 8)
+#define HW_PASS1_DON_ST							(1L << 20)
+#define SW_PASS1_DON_ST							(1L << 22)
+
+/* YUV siganl */
+#define YUV_SW_PASS1_DON_ST						(1L << 0)
+#define YUV_PASS1_DON_ST						(1L << 1)
+#define YUV_DMA_ERR_ST							(1L << 2)
+
+/* err status */
+#define TG_OVRUN_ST								(1L << 6)
+#define TG_GBERR_ST								(1L << 7)
+#define CQ_DB_LOAD_ERR_ST						(1L << 12)
+#define CQ_MAIN_CODE_ERR_ST						(1L << 14)
+#define CQ_MAIN_VS_ERR_ST						(1L << 15)
+#define CQ_MAIN_TRIG_DLY_ST						(1L << 16)
+#define LSCI_ERR_ST								(1L << 24)
+#define DMA_ERR_ST								(1L << 26)
+
+/* CAM DMA done status */
+#define IMGO_DONE_ST							(1L << 0)
+#define CQI_R1_DONE_ST							(1L << 8)
+
+/* IRQ signal mask */
+#define INT_ST_MASK_CAM (VS_INT_ST	 |\
+			 TG_INT1_ST	 |\
+			 TG_INT2_ST	 |\
+			 EXPDON_ST       |\
+			 HW_PASS1_DON_ST |\
+			 SOF_INT_ST      |\
+			 SW_PASS1_DON_ST)
+
+/* IRQ Error Mask */
+#define INT_ST_MASK_CAM_ERR (TG_OVRUN_ST	 |\
+			     TG_GBERR_ST	 |\
+			     CQ_DB_LOAD_ERR_ST	 |\
+			     CQ_MAIN_CODE_ERR_ST |\
+			     CQ_MAIN_VS_ERR_ST	 |\
+			     DMA_ERR_ST)
+
+#define ISP_SENINF_CTRL(regs)					(regs + 0x0200)
+#define ISP_SENINF_TSETMDL_CTRL(regs)			(regs + 0x0220)
+#define ISP_SENINF_MUX_CTRL_0(regs)				(regs + 0x0D00)
+#define ISP_SENINF_MUX_CTRL_1(regs)				(regs + 0x0D04)
+
+#define ISP_SENINF_TM_CTL(regs)					(regs + 0x0608)
+#define ISP_SENINF_TM_SIZE(regs)				(regs + 0x060C)
+#define ISP_SENINF_TM_CLK(regs)					(regs + 0x0610)
+#define ISP_SENINF_TM_DUM(regs)					(regs + 0x0618)
+
+#define ISP_SENINF_CAM_MUX_PCSR_0(regs)			(regs + 0x0400)
+
+#define CAMSYS_MAIN_REG_HALT1_EN(regs)			(regs + 0x0350)
+#define CAMSYS_MAIN_REG_HALT2_EN(regs)			(regs + 0x0354)
+#define CAMSYS_MAIN_REG_HALT3_EN(regs)			(regs + 0x0358)
+#define CAMSYS_MAIN_REG_HALT4_EN(regs)			(regs + 0x035C)
+#define CAMSYS_MAIN_REG_HALT5_EN(regs)			(regs + 0x0360)
+#define CAMSYS_MAIN_REG_HALT6_EN(regs)			(regs + 0x0364)
+
+#define CAM_REG_CTL_RAW_INT_STATUS(regs)		(regs + 0x0104)
+#define CAM_REG_CTL_RAW_INT2_STATUS(regs)		(regs + 0x0114)
+#define CAM_REG_CTL_RAW_INT3_STATUS(regs)		(regs + 0x0124)
+#define CAM_REG_CTL_RAW_INT4_STATUS(regs)		(regs + 0x0134)
+#define CAM_REG_CTL_RAW_INT5_STATUS(regs)		(regs + 0x0144)
+#define CAM_REG_CTL_RAW_INT6_EN					0x0150
+#define CAM_REG_CTL_RAW_INT6_STATUS(regs)		(regs + 0x0154)
+#define CAM_REG_CTL_RAW_INT7_EN					0x0160
+#define CAM_REG_CTL_RAW_INT7_STATUS(regs)		(regs + 0x0164)
+
+#define CAM_REG_CTL_RAW_INT_STATUSX(regs)		(regs + 0x0108)
+#define CAM_REG_CTL_RAW_INT2_STATUSX(regs)		(regs + 0x0118)
+#define CAM_REG_CTL_RAW_INT3_STATUSX(regs)		(regs + 0x0128)
+#define CAM_REG_CTL_RAW_INT4_STATUSX(regs)		(regs + 0x0138)
+#define CAM_REG_CTL_RAW_INT5_STATUSX(regs)		(regs + 0x0148)
+#define CAM_REG_CTL_RAW_INT6_STATUSX(regs)		(regs + 0x0158)
+#define CTL_CQ_THR0_DONE_ST						BIT(0)
+#define CAM_REG_CTL_RAW_INT7_STATUSX(regs)		(regs + 0x0168)
+#define CTL_CQ_THRSUB_DONE_ST					BIT(10)
+
+
+#define CAM_REG_CTL2_RAW_INT_STATUS(regs)		(regs + 0x0104)
+#define CAM_REG_CTL2_RAW_INT2_STATUS(regs)		(regs + 0x0114)
+#define CAM_REG_CTL2_RAW_INT4_STATUS(regs)		(regs + 0x0134)
+#define CAM_REG_CTL2_RAW_INT5_STATUS(regs)		(regs + 0x0144)
+
+#define CAM_REG_CTL2_RAW_INT_STATUSX(regs)		(regs + 0x0108)
+#define CAM_REG_CTL2_RAW_INT2_STATUSX(regs)		(regs + 0x0118)
+#define CAM_REG_CTL2_RAW_INT4_STATUSX(regs)		(regs + 0x0138)
+#define CAM_REG_CTL2_RAW_INT5_STATUSX(regs)		(regs + 0x0148)
+
+#define CAM_REG_CTL_RAW_MOD5_DCM_DIS			0x0310
+#define CAM_REG_CTL_RAW_MOD6_DCM_DIS			0x0314
+
+#define CAM_REG_CQ_THR0_CTL(regs)				(regs + 0x0414)
+#define CAM_REG_CQ_THR0_BASEADDR(regs)			(regs + 0x0418)
+#define CAM_REG_CQ_THR0_DESC_SIZE(regs)			(regs + 0x041C)
+
+#define CAM_REG_TG_SEN_MODE(regs)				(regs + 0x0700)
+#define TG_CMOS_RDY_SEL							BIT(14)
+#define CAM_REG_TG_SEN_GRAB_PXL(regs)			(regs + 0x0708)
+#define CAM_REG_TG_SEN_GRAB_LIN(regs)			(regs + 0x070C)
+#define CAM_REG_TG_PATH_CFG(regs)				(regs + 0x0710)
+#define TG_TG_FULL_SEL							BIT(15)
+#define CAM_REG_TG_FRMSIZE_ST(regs)				(regs + 0x0738)
+#define CAM_REG_TG_FRMSIZE_ST_R(regs)			(regs + 0x076C)
+
+#define CAM_REG_CQI_R1A_CON0(regs)				(regs + 0x445C)
+#define CAM_REG_CQI_R1A_CON1(regs)				(regs + 0x4460)
+#define CAM_REG_CQI_R1A_CON2(regs)				(regs + 0x4464)
+#define CAM_REG_CQI_R1A_CON3(regs)				(regs + 0x4468)
+#define CAM_REG_CQI_R1A_CON4(regs)				(regs + 0x446C)
+
+#define CAM_REG_CQI_R2A_CON0(regs)				(regs + 0x44BC)
+#define CAM_REG_CQI_R2A_CON1(regs)				(regs + 0x44C0)
+#define CAM_REG_CQI_R2A_CON2(regs)				(regs + 0x44C4)
+#define CAM_REG_CQI_R2A_CON3(regs)				(regs + 0x44C8)
+#define CAM_REG_CQI_R2A_CON4(regs)				(regs + 0x44CC)
+
+#define CAM_REG_CQI_R3A_CON0(regs)				(regs + 0x44BC)
+#define CAM_REG_CQI_R3A_CON1(regs)				(regs + 0x44C0)
+#define CAM_REG_CQI_R3A_CON2(regs)				(regs + 0x44C4)
+#define CAM_REG_CQI_R3A_CON3(regs)				(regs + 0x44C8)
+#define CAM_REG_CQI_R3A_CON4(regs)				(regs + 0x44CC)
+
+#define CAM_REG_CQI_R4A_CON0(regs)				(regs + 0x44BC)
+#define CAM_REG_CQI_R4A_CON1(regs)				(regs + 0x44C0)
+#define CAM_REG_CQI_R4A_CON2(regs)				(regs + 0x44C4)
+#define CAM_REG_CQI_R4A_CON3(regs)				(regs + 0x44C8)
+#define CAM_REG_CQI_R4A_CON4(regs)				(regs + 0x44CC)
+
+#define CAM_REG_IMGO_CON0(regs)					(regs + 0x483C)
+#define CAM_REG_IMGO_CON1(regs)					(regs + 0x4840)
+#define CAM_REG_IMGO_CON2(regs)					(regs + 0x4844)
+#define CAM_REG_IMGO_CON3(regs)					(regs + 0x4848)
+#define CAM_REG_IMGO_CON4(regs)					(regs + 0x484C)
+
+/* error status */
+#define REG_RAWI_R2_ERR_STAT					0x4230
+#define REG_UFDI_R2_ERR_STAT					0x4290
+#define REG_RAWI_R3_ERR_STAT					0x42F0
+#define REG_UFDI_R3_ERR_STAT					0x4350
+#define REG_RAWI_R6_ERR_STAT					0x4810
+#define REG_CQI_R1_ERR_STAT						0x4470
+#define REG_CQI_R2_ERR_STAT						0x44D0
+#define REG_CQI_R3_ERR_STAT						0x4530
+#define REG_CQI_R4_ERR_STAT						0x4590
+#define REG_LSCI_R1_ERR_STAT					0x45F0
+#define REG_BPCI_R1_ERR_STAT					0x4650
+#define REG_BPCI_R2_ERR_STAT					0x4690
+#define REG_BPCI_R3_ERR_STAT					0x46D0
+#define REG_PDI_R1_ERR_STAT						0x4710
+#define REG_AAI_R1_ERR_STAT						0x4790
+#define REG_CACI_R1_ERR_STAT					0x47D0
+#define REG_RAWI2_R6_ERR_STAT					0x4810
+#define REG_IMGO_R1_ERR_STAT					0x4850
+#define REG_FHO_R1_ERR_STAT						0x4900
+#define REG_AAHO_R1_ERR_STAT					0x49B0
+#define REG_PDO_R1_ERR_STAT						0x4A60
+#define REG_AAO_R1_ERR_STAT						0x4B10
+#define REG_AFO_R1_ERR_STAT						0x4BC0
+#define REG_TSFSO_R1_ERR_STAT					0x4C70
+#define REG_LTMSO_R1_ERR_STAT					0x4CB0
+#define REG_FLKO_R1_ERR_STAT					0x4CF0
+#define REG_UFEO_R1_ERR_STAT					0x4D30
+#define REG_TSFSO_R2_ERR_STAT					0x4DB0
+/* error status, yuv base */
+#define REG_YUVO_R1_ERR_STAT					0x4230
+#define REG_YUVBO_R1_ERR_STAT					0x42E0
+#define REG_YUVCO_R1_ERR_STAT					0x4390
+#define REG_YUVDO_R1_ERR_STAT					0x4440
+#define REG_YUVO_R3_ERR_STAT					0x44F0
+#define REG_YUVBO_R3_ERR_STAT					0x45A0
+#define REG_YUVCO_R3_ERR_STAT					0x4650
+#define REG_YUVDO_R3_ERR_STAT					0x4700
+#define REG_YUVO_R2_ERR_STAT					0x47B0
+#define REG_YUVBO_R2_ERR_STAT					0x47F0
+#define REG_YUVO_R4_ERR_STAT					0x4830
+#define REG_YUVBO_R4_ERR_STAT					0x4870
+#define REG_RZH1N2TO_R1_ERR_STAT				0x48B0
+#define REG_RZH1N2TBO_R1_ERR_STAT				0x48F0
+#define REG_RZH1N2TO_R2_ERR_STAT				0x4930
+#define REG_RZH1N2TO_R3_ERR_STAT				0x4970
+#define REG_RZH1N2TBO_R3_ERR_STAT				0x49B0
+#define REG_DRZS4NO_R1_ERR_STAT					0x49F0
+#define REG_DRZS4NO_R2_ERR_STAT					0x4A30
+#define REG_DRZS4NO_R3_ERR_STAT					0x4A70
+#define REG_ACTSO_R1_ERR_STAT					0x4AF0
+#define REG_TNCSO_R1_ERR_STAT					0x4B30
+#define REG_TNCSBO_R1_ERR_STAT					0x4B70
+#define REG_TNCSHO_R1_ERR_STAT					0x4BB0
+#define REG_TNCSYO_R1_ERR_STAT					0x4BF0
+#define REG_YUVO_R5_ERR_STAT					0x4C30
+#define REG_YUVBO_R5_ERR_STAT					0x4C70
+
+/* CQ related */
+#define REG_CQ_EN								0x0400
+#define REG_SCQ_START_PERIOD					0x0408
+#define REG_CQ_THR0_CTL							0x0414
+#define REG_CQ_THR0_BASEADDR					0x0418
+#define REG_CQ_THR0_DESC_SIZE					0x041C
+#define REG_CQ_SUB_CQ_EN						0x060C
+#define REG_CQ_SUB_THR0_CTL						0x061C
+#define REG_CQ_SUB_THR0_BASEADDR_2				0x0624
+#define REG_CQ_SUB_THR0_DESC_SIZE_2				0x062C
+#define REG_CQ_SUB_THR0_BASEADDR_1				0x0620
+#define REG_CQ_SUB_THR0_DESC_SIZE_1				0x0628
+
+#define CQ_DB_EN								BIT(4)
+#define CQ_DB_LOAD_MODE							BIT(8)
+#define CQ_RESET								BIT(16)
+#define CTL_CQ_THR0_START						BIT(0)
+#define CQ_THR0_MODE_IMMEDIATE					BIT(4)
+#define CQ_THR0_MODE_CONTINUOUS					BIT(5)
+#define CQ_THR0_DONE_SEL						BIT(8)
+#define SCQ_EN									BIT(20)
+#define SCQ_SUBSAMPLE_EN						BIT(21)
+#define SCQ_SUB_RESET							BIT(16)
+
+#define CQ_THR0_EN								BIT(0)
+#define CQ_CQI_R1_EN							BIT(8)
+#define CQ_CQI_R2_EN							BIT(9)
+#define CAMCQ_SCQ_EN							BIT(20)
+#define PASS1_DONE_SEL							BIT(31)
+
+/* camsys */
+#define REG_CAMSYS_CG_SET						0x0004
+#define REG_CAMSYS_CG_CLR						0x0008
+#define REG_CTL_START							0x00B0
+
+/* camctl */
+#define REG_CTL_RAWI_TRIG						0x00C0
+#define REG_CTL_SW_CTL							0x00C4
+#define REG_CTL_SW_PASS1_DONE					0x00C8
+#define REG_CTL_SW_SUB_CTL						0x00CC
+
+/* TG */
+#define REG_TG_SEN_MODE							0x0700
+#define TG_SEN_MODE_CMOS_EN						BIT(0)
+
+#define REG_TG_VF_CON							0x0704
+#define TG_VFDATA_EN							BIT(0)
+#define REG_TG_INTER_ST							0x073C
+#define TG_CAM_CS_MASK							0x3f00
+#define TG_IDLE_ST								BIT(8)
+
+/* DBG */
+#define CAM_REG_CQ_SUB_THR0_BASEADDR_1(regs)	(regs + 0x0620)
+#define CAM_REG_CQ_SUB_THR0_BASEADDR_2(regs)	(regs + 0x0624)
+#define CAM_REG_SUB_THR0_DESC_SIZE_1(regs)		(regs + 0x0628)
+#define CAM_REG_SUB_THR0_DESC_SIZE_2(regs)		(regs + 0x062C)
+#define CAM_REG_IMGO_ORIWDMA_BASE_ADDR(regs)	(regs + 0x4820)
+#define CAM_REG_AAO_ORIWDMA_BASE_ADDR(regs)		(regs + 0x4AE0)
+#define CAM_REG_YUVO_R1_ORIWDMA_BASE_ADDR(regs)	(regs + 0x4200)
+#define CAM_REG_YUVO_R3_ORIWDMA_BASE_ADDR(regs)	(regs + 0x44C0)
+
+#define CAM_REG_FBC_IMGO_R1_CTL2(regs)			(regs + 0x2C04)
+#define CAM_REG_FBC_YUVO_R1_CTL2(regs)			(regs + 0x3784)
+#define CAM_REG_FBC_YUVO_R3_CTL2(regs)			(regs + 0x37A4)
+
+#define CAM_REG_CQ_EN(regs)						(regs + 0x0400)
+#define CAM_REG_SUB_CQ_EN(regs)					(regs + 0x060C)
+
+#define CAM_REG_SW_PASS1_DONE(regs)				(regs + 0x00C8)
+#define CAM_REG_SW_SUB_CTL(regs)				(regs + 0x00CC)
+
+#define CAM_REG_FBC_AAO_R1_CTL1(regs)			(regs + 0x2C20)
+#define CAM_REG_FBC_AAHO_R1_CTL1(regs)			(regs + 0x2C10)
+#define CAM_REG_FBC_AAO_R1_CTL2(regs)			(regs + 0x2C24)
+#define CAM_REG_FBC_AAHO_R1_CTL2(regs)			(regs + 0x2C14)
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/camsys/unit_test/mtk_cam_ut-cam.c b/drivers/media/platform/mediatek/isp/isp_7x/camsys/unit_test/mtk_cam_ut-cam.c
new file mode 100644
index 0000000000000000000000000000000000000000..784460367dd055638dd77cff7bb359205fff0685
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/camsys/unit_test/mtk_cam_ut-cam.c
@@ -0,0 +1,1133 @@
+// SPDX-License-Identifier: GPL-2.0
+//
+// Copyright (c) 2021 MediaTek Inc.
+
+#include <linux/clk.h>
+#include <linux/component.h>
+#include <linux/dma-mapping.h>
+#include <linux/interrupt.h>
+#include <linux/iopoll.h>
+#include <linux/module.h>
+#include <linux/of_platform.h>
+#include <linux/of.h>
+#include <linux/platform_device.h>
+#include <linux/pm_runtime.h>
+
+#include "mtk_cam_ut.h"
+#include "mtk_cam_ut-engines.h"
+#ifdef ISP7_1
+#include "mtk_cam_regs_mt8188.h"
+#else
+#include "mtk_cam_regs_mt8195.h"
+#endif
+
+static int ut_raw_reset(struct device *dev)
+{
+	struct mtk_ut_raw_device *raw = dev_get_drvdata(dev);
+	void __iomem *base = raw->base;
+	void __iomem *yuv_base = raw->yuv_base;
+	u32 ctl;
+
+	writel(0x00000fff, base + CAM_REG_CTL_RAW_MOD5_DCM_DIS);
+	writel(0x0007ffff, base + CAM_REG_CTL_RAW_MOD6_DCM_DIS);
+	writel(0xffffffff, yuv_base + CAM_REG_CTL_RAW_MOD5_DCM_DIS);
+
+	/* Disable all DMA DCM before reset */
+	wmb(); /* TBC */
+	writel(1, base + REG_CTL_SW_CTL);
+
+	if (!readl_poll_timeout_atomic(base + REG_CTL_SW_CTL, ctl,
+				       ctl & 0x2, 1, 1000)) {
+		writel(4, base + REG_CTL_SW_CTL);
+		writel(0, base + REG_CTL_SW_CTL);
+		dev_info(dev, "reset success\n");
+	} else {
+		dev_info(dev, "Reset hw timeout: SW_CTL 0x%x\n",
+			 readl_relaxed(base + REG_CTL_SW_CTL));
+	}
+
+	writel(0x0, base + CAM_REG_CTL_RAW_MOD5_DCM_DIS);
+	writel(0x0, base + CAM_REG_CTL_RAW_MOD6_DCM_DIS);
+	writel(0x0, yuv_base + CAM_REG_CTL_RAW_MOD5_DCM_DIS);
+
+	writel_relaxed(0x0, base + REG_CTL_SW_PASS1_DONE);
+	writel_relaxed(0x0, raw->base_inner + REG_CTL_SW_PASS1_DONE);
+
+	/* make sure reset take effect */
+	wmb();
+
+	return -1;
+}
+
+static void set_steamon_handle(struct device *dev, int type);
+
+static int ut_raw_initialize(struct device *dev, void *ext_params)
+{
+	struct mtk_ut_raw_device *raw = dev_get_drvdata(dev);
+	struct mtk_ut_raw_initial_params *p = ext_params;
+	void __iomem *base = raw->base;
+	u32 val;
+
+	if (!p)
+		return -1;
+
+	/* initialize for CQ */
+	if (p->subsample) {
+		val = readl_relaxed(base + REG_CQ_EN);
+		writel_relaxed(val | SCQ_EN | SCQ_SUBSAMPLE_EN, base + REG_CQ_EN);
+
+		writel_relaxed(0x100 | p->subsample, base + REG_CTL_SW_PASS1_DONE);
+		writel_relaxed(0x100 | p->subsample, raw->base_inner + REG_CTL_SW_PASS1_DONE);
+	} else {
+		val = readl_relaxed(base + REG_CQ_EN);
+		writel_relaxed(val | SCQ_EN, base + REG_CQ_EN);
+	}
+
+	writel_relaxed(CQ_THR0_MODE_IMMEDIATE | CQ_THR0_EN,
+		       base + REG_CQ_THR0_CTL);
+	writel_relaxed(CQ_THR0_MODE_IMMEDIATE | CQ_THR0_EN,
+		       base + REG_CQ_SUB_THR0_CTL);
+
+	writel_relaxed(0xffffffff, base + REG_SCQ_START_PERIOD);
+	writel_relaxed(0xffffffff, raw->base_inner + REG_SCQ_START_PERIOD);
+
+	/* make sure all the CQ setting take effect */
+	wmb();
+
+	set_steamon_handle(dev, p->streamon_type);
+
+	raw->is_subsample = p->subsample;
+	raw->hardware_scenario = p->hardware_scenario;
+	raw->is_initial_cq = 1;
+	raw->cq_done_mask = 0;
+
+	return 0;
+}
+
+static int ut_raw_s_stream(struct device *dev, int on)
+{
+	struct mtk_ut_raw_device *raw = dev_get_drvdata(dev);
+	void __iomem *base = raw->base;
+	u32 val;
+
+	dev_info(dev, "%s: %s\n", __func__, on ? "on" : "off");
+
+	val = readl_relaxed(base + REG_TG_VF_CON);
+	if (on)
+		val |= TG_VFDATA_EN;
+	else
+		val &= ~TG_VFDATA_EN;
+
+	writel_relaxed(val, base + REG_TG_VF_CON);
+
+	/* make sure VF enable setting take effect */
+	wmb();
+
+	return 0;
+}
+
+static int ut_raw_trigger_rawi_r2(struct device *dev, int on)
+{
+	struct mtk_ut_raw_device *raw = dev_get_drvdata(dev);
+	void __iomem *base = raw->base;
+
+	if (on)
+		writel(0x1, base + REG_CTL_RAWI_TRIG);
+
+	dev_info(raw->dev, "%s: on %d\n", __func__, on);
+	return 0;
+}
+
+static int ut_raw_trigger_rawi_r6(struct device *dev, int on)
+{
+	struct mtk_ut_raw_device *raw = dev_get_drvdata(dev);
+	void __iomem *base = raw->base;
+
+	dev_info(dev, "[%s] ut_raw_trigger_rawi\n", __func__);
+
+	writel_relaxed(0x10, base + REG_CTL_RAWI_TRIG);
+	wmb(); /* TBC */
+
+	return 0;
+}
+#ifdef ISP7_1
+static int ut_raw_trigger_rawi_r5(struct device *dev, int on)
+{
+	struct mtk_ut_raw_device *raw = dev_get_drvdata(dev);
+	void __iomem *base = raw->base;
+
+	dev_info(dev, "[%s] ut_raw_trigger_rawi\n", __func__);
+
+	writel_relaxed(0x8, base + REG_CTL_RAWI_TRIG);
+	wmb(); /* TBC */
+
+	return 0;
+}
+#endif
+static void set_steamon_handle(struct device *dev, int type)
+{
+	struct mtk_ut_raw_device *raw = dev_get_drvdata(dev);
+
+	dev_info(raw->dev, "streamon type %d\n", type);
+
+	if (type == STREAM_FROM_TG)
+		raw->ops.s_stream = ut_raw_s_stream;
+	else if (type == STREAM_FROM_RAWI_R2)
+		raw->ops.s_stream = ut_raw_trigger_rawi_r2;
+	else if (type == STREAM_FROM_RAWI_R6)
+		raw->ops.s_stream = ut_raw_trigger_rawi_r6;
+#ifdef ISP7_1
+	else if (type == STREAM_FROM_RAWI_R5)
+		raw->ops.s_stream = ut_raw_trigger_rawi_r5;
+#endif
+	else
+		dev_info(raw->dev, "type %d not supported yet\n", type);
+}
+
+static int ut_raw_apply_cq(struct device *dev,
+			    dma_addr_t cq_addr, unsigned int cq_size, unsigned int cq_offset,
+			    unsigned int sub_cq_size, unsigned int sub_cq_offset)
+{
+	struct mtk_ut_raw_device *raw = dev_get_drvdata(dev);
+	void __iomem *base = raw->base;
+
+	dev_info(dev, "[%s] cq baseaddr = 0x%x, cq size = 0x%x, cq offset = 0x%x, sub_cq size = 0x%x, sub_cq_offset = 0x%x\n",
+		__func__, cq_addr, cq_size, cq_offset, sub_cq_size, sub_cq_offset);
+		writel_relaxed(cq_addr + cq_offset, base + REG_CQ_THR0_BASEADDR);
+		writel_relaxed(cq_size, base + REG_CQ_THR0_DESC_SIZE);
+
+	writel_relaxed(cq_addr + sub_cq_offset,
+		base + REG_CQ_SUB_THR0_BASEADDR_2);
+	writel_relaxed(sub_cq_size,
+		base + REG_CQ_SUB_THR0_DESC_SIZE_2);
+
+	writel(CTL_CQ_THR0_START, base + REG_CTL_START);
+
+	/* make sure reset take effect */
+	wmb();
+
+	return 0;
+}
+
+static void ut_raw_set_ops(struct device *dev)
+{
+	struct mtk_ut_raw_device *raw = dev_get_drvdata(dev);
+
+	raw->ops.reset = ut_raw_reset;
+	raw->ops.s_stream = ut_raw_s_stream;
+	raw->ops.apply_cq = ut_raw_apply_cq;
+	raw->ops.initialize = ut_raw_initialize;
+}
+
+static int mtk_ut_raw_component_bind(struct device *dev,
+				     struct device *master, void *data)
+{
+	struct mtk_ut_raw_device *raw = dev_get_drvdata(dev);
+	struct mtk_cam_ut *ut = data;
+	struct ut_event evt;
+
+	dev_info(dev, "%s\n", __func__);
+
+	if (!data) {
+		dev_info(dev, "no master data\n");
+		return -1;
+	}
+
+	if (!ut->raw) {
+		dev_info(dev, "no raw arr, num of raw %d\n", ut->num_raw);
+		return -1;
+	}
+	ut->raw[raw->id] = dev;
+
+	evt.mask = EVENT_SOF | EVENT_CQ_DONE | EVENT_SW_P1_DONE | EVENT_CQ_MAIN_TRIG_DLY;
+	add_listener(&raw->event_src, &ut->listener, evt);
+
+	return 0;
+}
+
+static void mtk_ut_raw_component_unbind(struct device *dev,
+					struct device *master, void *data)
+{
+	struct mtk_ut_raw_device *raw = dev_get_drvdata(dev);
+	struct mtk_cam_ut *ut = data;
+
+	dev_dbg(dev, "%s\n", __func__);
+	ut->raw[raw->id] = NULL;
+	remove_listener(&raw->event_src, &ut->listener);
+}
+
+static const struct component_ops mtk_ut_raw_component_ops = {
+	.bind = mtk_ut_raw_component_bind,
+	.unbind = mtk_ut_raw_component_unbind,
+};
+
+static void raw_handle_tg_grab_err(struct mtk_ut_raw_device *raw)
+{
+	void __iomem *base = raw->base;
+	int val;
+
+	val = readl_relaxed(CAM_REG_TG_PATH_CFG(base));
+	val = val | TG_TG_FULL_SEL;
+	writel_relaxed(val, CAM_REG_TG_PATH_CFG(base));
+	/* make sure all the TG setting take effect */
+	wmb();
+	val = readl_relaxed(CAM_REG_TG_SEN_MODE(base));
+	val = val | TG_CMOS_RDY_SEL;
+	writel_relaxed(val, CAM_REG_TG_SEN_MODE(base));
+	/* make sure all the TG setting take effect */
+	wmb();
+	dev_dbg(raw->dev,
+		"TG_PATH_CFG:0x%x, TG_SEN_MODE:0x%x TG_FRMSIZE_ST:0x%8x, TG_FRMSIZE_ST_R:0x%8x TG_SEN_GRAB_PXL:0x%8x, TG_SEN_GRAB_LIN:0x%8x\n",
+		readl_relaxed(CAM_REG_TG_PATH_CFG(base)),
+		readl_relaxed(CAM_REG_TG_SEN_MODE(base)),
+		readl_relaxed(CAM_REG_TG_FRMSIZE_ST(base)),
+		readl_relaxed(CAM_REG_TG_FRMSIZE_ST_R(base)),
+		readl_relaxed(CAM_REG_TG_SEN_GRAB_PXL(base)),
+		readl_relaxed(CAM_REG_TG_SEN_GRAB_LIN(base)));
+}
+
+static void raw_handle_dma_err(struct mtk_ut_raw_device *raw)
+{
+	void __iomem *base = raw->base;
+	void __iomem *yuv_base = raw->yuv_base;
+
+	dev_info_ratelimited(raw->dev,
+			    "IMGO:%x,YUVO_R1/R2/R3/R4/R5:%x/%x/%x/%x/%x\n",
+			    readl_relaxed(base + REG_IMGO_R1_ERR_STAT),
+			    readl_relaxed(yuv_base + REG_YUVO_R1_ERR_STAT),
+			    readl_relaxed(yuv_base + REG_YUVO_R2_ERR_STAT),
+			    readl_relaxed(yuv_base + REG_YUVO_R3_ERR_STAT),
+			    readl_relaxed(yuv_base + REG_YUVO_R4_ERR_STAT),
+			    readl_relaxed(yuv_base + REG_YUVO_R5_ERR_STAT)
+			   );
+
+	dev_info_ratelimited(raw->dev,
+			    "RZH1N2TO_R1/R2/R3:%x/%x/%x,DRZS4NO_R1/R2/R3:%x/%x/%x\n",
+			    readl_relaxed(yuv_base + REG_RZH1N2TO_R1_ERR_STAT),
+			    readl_relaxed(yuv_base + REG_RZH1N2TO_R2_ERR_STAT),
+			    readl_relaxed(yuv_base + REG_RZH1N2TO_R3_ERR_STAT),
+			    readl_relaxed(yuv_base + REG_DRZS4NO_R1_ERR_STAT),
+			    readl_relaxed(yuv_base + REG_DRZS4NO_R2_ERR_STAT),
+			    readl_relaxed(yuv_base + REG_DRZS4NO_R3_ERR_STAT)
+			   );
+
+	dev_info_ratelimited(raw->dev,
+			    "AAO/AAHO/LTMSO/FLKO/AFO:%x/%x/%x/%x/%x,TSFSO_R1/R2:%x/%x\n",
+			    readl_relaxed(base + REG_AAO_R1_ERR_STAT),
+			    readl_relaxed(base + REG_AAHO_R1_ERR_STAT),
+			    readl_relaxed(base + REG_LTMSO_R1_ERR_STAT),
+			    readl_relaxed(base + REG_FLKO_R1_ERR_STAT),
+			    readl_relaxed(base + REG_AFO_R1_ERR_STAT),
+			    readl_relaxed(base + REG_TSFSO_R1_ERR_STAT),
+			    readl_relaxed(base + REG_TSFSO_R2_ERR_STAT)
+			   );
+
+	dev_info_ratelimited(raw->dev,
+			    "RAWI_R2/R3:%x/%x,LSCI:%x,BPCI_R1/R2/R3:%x/%x/%x\n",
+			    readl_relaxed(base + REG_RAWI_R2_ERR_STAT),
+			    readl_relaxed(base + REG_RAWI_R3_ERR_STAT),
+			    readl_relaxed(base + REG_LSCI_R1_ERR_STAT),
+			    readl_relaxed(base + REG_BPCI_R1_ERR_STAT),
+			    readl_relaxed(base + REG_BPCI_R2_ERR_STAT),
+			    readl_relaxed(base + REG_BPCI_R3_ERR_STAT)
+			   );
+}
+
+static void raw_check_error_status(struct mtk_ut_raw_device *raw,
+				   struct ut_raw_status *st)
+{
+	u32 err_status;
+
+	err_status = st->irq & INT_ST_MASK_CAM_ERR;
+	if (!err_status)
+		return;
+	dev_info(raw->dev, "int_err:0x%x 0x%x\n", st->irq, err_status);
+
+	if (err_status & DMA_ERR_ST)
+		raw_handle_dma_err(raw);
+	/* Show TG register for more error detail*/
+	if (err_status & TG_GBERR_ST)
+		raw_handle_tg_grab_err(raw);
+}
+
+static irqreturn_t mtk_ut_raw_irq(int irq, void *data)
+{
+#define RAW_DEBUG 0
+	struct mtk_ut_raw_device *raw = data;
+	void __iomem *base = raw->base;
+	struct ut_raw_status status;
+	struct ut_raw_statusx statusx;
+	struct ut_event event;
+#if RAW_DEBUG
+	void __iomem *base_inner = raw->base_inner;
+	struct ut_raw_debug_csr dbg_csr;
+#endif
+	/* raw */
+	status.irq = readl_relaxed(CAM_REG_CTL_RAW_INT_STATUS(base));
+	status.wdma = readl_relaxed(CAM_REG_CTL_RAW_INT2_STATUS(base));
+	status.rdma = readl_relaxed(CAM_REG_CTL_RAW_INT3_STATUS(base));
+	status.drop = readl_relaxed(CAM_REG_CTL_RAW_INT4_STATUS(base));
+	status.ofl = readl_relaxed(CAM_REG_CTL_RAW_INT5_STATUS(base));
+	status.cq_done = readl_relaxed(CAM_REG_CTL_RAW_INT6_STATUS(base));
+	status.cq_done2 = readl_relaxed(CAM_REG_CTL_RAW_INT7_STATUS(base));
+
+	event.mask = 0;
+
+	if (status.irq & SOF_INT_ST)
+		event.mask |= EVENT_SOF;
+
+	if (status.irq & SW_PASS1_DON_ST) {
+		event.mask |= EVENT_SW_P1_DONE;
+
+		/* raw */
+		statusx.irq = readl_relaxed(CAM_REG_CTL_RAW_INT_STATUSX(base));
+		statusx.wdma = readl_relaxed(CAM_REG_CTL_RAW_INT2_STATUSX(base));
+		statusx.rdma = readl_relaxed(CAM_REG_CTL_RAW_INT3_STATUSX(base));
+		statusx.drop = readl_relaxed(CAM_REG_CTL_RAW_INT4_STATUSX(base));
+		statusx.ofl = readl_relaxed(CAM_REG_CTL_RAW_INT5_STATUSX(base));
+		statusx.cq_done = readl_relaxed(CAM_REG_CTL_RAW_INT6_STATUSX(base));
+		statusx.cq_done2 = readl_relaxed(CAM_REG_CTL_RAW_INT7_STATUSX(base));
+
+		dev_info(raw->dev,
+			 "STATUSX INT1-7 0x%x/0x%x/0x%x/0x%x/0x%x/0x%x/0x%x\n",
+			 statusx.irq, statusx.wdma, statusx.rdma, statusx.drop,
+			 statusx.ofl, statusx.cq_done, statusx.cq_done2);
+	}
+
+	if (status.cq_done & CTL_CQ_THR0_DONE_ST)
+		raw->cq_done_mask |= 0x1;
+
+	if (status.cq_done2 & CTL_CQ_THRSUB_DONE_ST)
+		raw->cq_done_mask |= 0x2;
+
+	if (raw->is_subsample && !raw->is_initial_cq &&
+	    (raw->cq_done_mask & 0x1)) {
+		raw->cq_done_mask = 0;
+		event.mask |= EVENT_CQ_DONE;
+	} else if (raw->cq_done_mask == 0x3) {
+		raw->is_initial_cq = 0;
+		raw->cq_done_mask = 0;
+		event.mask |= EVENT_CQ_DONE;
+	}
+
+	if (status.irq & CQ_MAIN_TRIG_DLY_ST)
+		event.mask |= EVENT_CQ_MAIN_TRIG_DLY;
+
+	if (event.mask && raw->id == 0) {
+		dev_dbg(raw->dev, "send event 0x%x\n", event.mask);
+		send_event(&raw->event_src, event);
+	}
+
+		/* debug */
+#if RAW_DEBUG
+	dbg_csr.cq_sub1_addr =
+		readl_relaxed(CAM_REG_CQ_SUB_THR0_BASEADDR_1(base));
+	dbg_csr.cq_sub2_addr =
+		readl_relaxed(CAM_REG_CQ_SUB_THR0_BASEADDR_2(base));
+	dbg_csr.cq_sub1_szie =
+		readl_relaxed(CAM_REG_SUB_THR0_DESC_SIZE_1(base));
+	dbg_csr.cq_sub2_szie =
+		readl_relaxed(CAM_REG_SUB_THR0_DESC_SIZE_2(base));
+
+	dbg_csr.imgo_addr =
+		readl_relaxed(CAM_REG_IMGO_ORIWDMA_BASE_ADDR(base));
+	dbg_csr.fbc_imgo_ctl2 =
+		readl_relaxed(CAM_REG_FBC_IMGO_R1_CTL2(base));
+
+	dbg_csr.cq_en =
+		readl_relaxed(CAM_REG_CQ_EN(base));
+	dbg_csr.sub_cq_en =
+		readl_relaxed(CAM_REG_SUB_CQ_EN(base));
+
+	dbg_csr.sw_pass1_done =
+		readl_relaxed(CAM_REG_SW_PASS1_DONE(base));
+	dbg_csr.sw_sub_ctl =
+		readl_relaxed(CAM_REG_SW_SUB_CTL(base));
+
+	dbg_csr.aao_addr =
+		readl_relaxed(CAM_REG_AAO_ORIWDMA_BASE_ADDR(base));
+	dbg_csr.fbc_aao_ctl2 =
+		readl_relaxed(CAM_REG_FBC_AAO_R1_CTL2(base));
+	dbg_csr.fbc_aaho_ctl2 =
+		readl_relaxed(CAM_REG_FBC_AAHO_R1_CTL2(base));
+#endif
+#if RAW_DEBUG
+	dev_info(raw->dev,
+		"INT1-7 0x%x/0x%x/0x%x/0x%x/0x%x/0x%x/0x%x\n",
+		status.irq, status.wdma, status.rdma, status.drop,
+		status.ofl, status.cq_done, status.cq_done2);
+
+	dev_info(raw->dev,
+		"cq_sub1_addr=0x%x, cq_sub2_addr=0x%x, cq_sub1_szie:0x%x, cq_sub2_szie=0x%x\n",
+		dbg_csr.cq_sub1_addr, dbg_csr.cq_sub2_addr,
+		dbg_csr.cq_sub1_szie, dbg_csr.cq_sub2_szie);
+
+	dev_info(raw->dev,
+		"imgo_addr=0x%x fbc_imgo_ctl2=0x%x cq 0x%x sub_cq 0x%x sw_pass1_done 0x%x sw_sub_ctl 0x%x, aao_addr=0x%x ctl2 0x%x, 0x%x\n",
+		dbg_csr.imgo_addr, dbg_csr.fbc_imgo_ctl2, dbg_csr.cq_en, dbg_csr.sub_cq_en,
+		dbg_csr.sw_pass1_done, dbg_csr.sw_sub_ctl, dbg_csr.aao_addr, dbg_csr.fbc_aao_ctl2,
+		dbg_csr.fbc_aaho_ctl2);
+
+	dbg_csr.sw_pass1_done =
+		readl_relaxed(CAM_REG_SW_PASS1_DONE(base_inner));
+	dbg_csr.sw_sub_ctl =
+		readl_relaxed(CAM_REG_SW_SUB_CTL(base_inner));
+
+	dev_info(raw->dev,
+		"inner sw_pass1_done 0x%x sw_sub_ctl 0x%x\n",
+		dbg_csr.sw_pass1_done, dbg_csr.sw_sub_ctl);
+#endif
+
+	raw_check_error_status(raw, &status);
+	dev_info(raw->dev, "INT1-7 0x%x/0x%x/0x%x/0x%x/0x%x/0x%x/0x%x",
+		 status.irq, status.wdma, status.rdma, status.drop,
+		 status.ofl, status.cq_done, status.cq_done2);
+
+	return IRQ_HANDLED;
+}
+
+static int mtk_ut_raw_of_probe(struct platform_device *pdev,
+			    struct mtk_ut_raw_device *raw)
+{
+	struct device *dev = &pdev->dev;
+	struct resource *res;
+	int irq, ret;
+	int i;
+
+	ret = of_property_read_u32(dev->of_node, "mediatek,cam-id",
+				   &raw->id);
+	dev_info(dev, "id = %d\n", raw->id);
+	if (ret) {
+		dev_info(dev, "missing camid property\n");
+		return ret;
+	}
+
+	/* base outer register */
+	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "base");
+	if (!res) {
+		dev_info(dev, "failed to get mem\n");
+		return -ENODEV;
+	}
+
+	raw->base = devm_ioremap_resource(dev, res);
+	if (IS_ERR(raw->base)) {
+		dev_info(dev, "failed to map register base\n");
+		return PTR_ERR(raw->base);
+	}
+	dev_dbg(dev, "raw, map_addr=0x%pK\n", raw->base);
+	/* base inner register */
+	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "inner_base");
+	if (!res) {
+		dev_info(dev, "failed to get mem\n");
+		return -ENODEV;
+	}
+
+	raw->base_inner = devm_ioremap_resource(dev, res);
+	if (IS_ERR(raw->base_inner)) {
+		dev_info(dev, "failed to map register inner base\n");
+		return PTR_ERR(raw->base_inner);
+	}
+
+	/* will be assigned later */
+	raw->yuv_base = NULL;
+
+	irq = platform_get_irq(pdev, 0);
+	if (irq < 0) {
+		dev_info(dev, "failed to get irq\n");
+		return -ENODEV;
+	}
+
+	ret = devm_request_irq(dev, irq, mtk_ut_raw_irq, 0,
+			       dev_name(dev), raw);
+	if (ret) {
+		dev_info(dev, "failed to request irq=%d\n", irq);
+		return ret;
+	}
+	dev_dbg(dev, "registered irq=%d\n", irq);
+
+	raw->num_clks = of_count_phandle_with_args(pdev->dev.of_node, "clocks",
+			"#clock-cells");
+	dev_info(dev, "clk_num:%d\n", raw->num_clks);
+
+	if (raw->num_clks) {
+		raw->clks = devm_kcalloc(dev, raw->num_clks, sizeof(*raw->clks),
+					 GFP_KERNEL);
+		if (!raw->clks)
+			return -ENOMEM;
+	}
+
+	for (i = 0; i < raw->num_clks; i++) {
+		raw->clks[i] = of_clk_get(pdev->dev.of_node, i);
+		if (IS_ERR(raw->clks[i])) {
+			dev_info(dev, "failed to get clk %d\n", i);
+			return -ENODEV;
+		}
+	}
+
+	return 0;
+}
+
+static int mtk_ut_raw_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct mtk_ut_raw_device *drvdata;
+	int ret;
+
+	dev_info(dev, "%s\n", __func__);
+
+	drvdata = devm_kzalloc(dev, sizeof(*drvdata), GFP_KERNEL);
+	if (!drvdata)
+		return -ENOMEM;
+
+	drvdata->dev = dev;
+	dev_set_drvdata(dev, drvdata);
+
+	ret = mtk_ut_raw_of_probe(pdev, drvdata);
+	if (ret)
+		return ret;
+
+	init_event_source(&drvdata->event_src);
+	ut_raw_set_ops(dev);
+
+	pm_runtime_enable(dev);
+
+	ret = component_add(dev, &mtk_ut_raw_component_ops);
+	if (ret)
+		return ret;
+
+	dev_info(dev, "%s: success\n", __func__);
+	return 0;
+}
+
+static int mtk_ut_raw_remove(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct mtk_ut_raw_device *drvdata = dev_get_drvdata(dev);
+	int i;
+
+	dev_info(dev, "%s\n", __func__);
+
+	pm_runtime_disable(dev);
+	component_del(dev, &mtk_ut_raw_component_ops);
+
+	for (i = 0; i < drvdata->num_clks; i++)
+		clk_put(drvdata->clks[i]);
+
+	return 0;
+}
+
+static int mtk_ut_raw_pm_suspend(struct device *dev)
+{
+	struct mtk_ut_raw_device *raw = dev_get_drvdata(dev);
+	u32 val;
+	int ret;
+
+	dev_dbg(dev, "- %s\n", __func__);
+
+	if (pm_runtime_suspended(dev))
+		return 0;
+
+	/* Disable ISP's view finder and wait for TG idle */
+	dev_dbg(dev, "cam suspend, disable VF\n");
+	val = readl(raw->base + REG_TG_VF_CON);
+	writel(val & (~TG_VFDATA_EN), raw->base + REG_TG_VF_CON);
+	ret = readl_poll_timeout_atomic(raw->base + REG_TG_INTER_ST, val,
+					(val & TG_CAM_CS_MASK) == TG_IDLE_ST,
+					USEC_PER_MSEC, 33);
+	if (ret)
+		dev_dbg(dev, "can't stop HW:%d:0x%x\n", ret, val);
+
+	/* Disable CMOS */
+	val = readl(raw->base + REG_TG_SEN_MODE);
+	writel(val & (~TG_SEN_MODE_CMOS_EN), raw->base + REG_TG_SEN_MODE);
+
+	/* Force ISP HW to idle */
+	ret = pm_runtime_force_suspend(dev);
+	return ret;
+}
+
+static int mtk_ut_raw_pm_resume(struct device *dev)
+{
+	struct mtk_ut_raw_device *raw = dev_get_drvdata(dev);
+	u32 val;
+	int ret;
+
+	dev_dbg(dev, "- %s\n", __func__);
+
+	if (pm_runtime_suspended(dev))
+		return 0;
+
+	/* Force ISP HW to resume */
+	ret = pm_runtime_force_resume(dev);
+	if (ret)
+		return ret;
+
+	/* Enable CMOS */
+	dev_dbg(dev, "cam resume, enable CMOS/VF\n");
+	val = readl(raw->base + REG_TG_SEN_MODE);
+	writel(val | TG_SEN_MODE_CMOS_EN, raw->base + REG_TG_SEN_MODE);
+
+	/* Enable VF */
+	val = readl(raw->base + REG_TG_VF_CON);
+	writel(val | TG_VFDATA_EN, raw->base + REG_TG_VF_CON);
+
+	return 0;
+}
+
+static int mtk_ut_raw_runtime_suspend(struct device *dev)
+{
+	struct mtk_ut_raw_device *raw = dev_get_drvdata(dev);
+	int i;
+
+	ut_raw_reset(dev);
+
+	for (i = 0; i < raw->num_clks; i++)
+		clk_disable_unprepare(raw->clks[i]);
+
+	return 0;
+}
+
+static int mtk_ut_raw_runtime_resume(struct device *dev)
+{
+	struct mtk_ut_raw_device *raw = dev_get_drvdata(dev);
+	int i, ret;
+
+	for (i = 0; i < raw->num_clks; i++) {
+		ret = clk_prepare_enable(raw->clks[i]);
+		if (ret) {
+			dev_info(dev, "enable failed at clk #%d, ret = %d\n",
+				 i, ret);
+			i--;
+			while (i >= 0)
+				clk_disable_unprepare(raw->clks[i--]);
+
+			return ret;
+		}
+	}
+
+	ut_raw_reset(dev);
+	return 0;
+}
+
+static const struct dev_pm_ops mtk_ut_raw_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(mtk_ut_raw_pm_suspend, mtk_ut_raw_pm_resume)
+	SET_RUNTIME_PM_OPS(mtk_ut_raw_runtime_suspend, mtk_ut_raw_runtime_resume,
+			   NULL)
+};
+
+static const struct of_device_id mtk_ut_raw_of_ids[] = {
+	{.compatible = "mediatek,cam-raw",},
+	{}
+};
+MODULE_DEVICE_TABLE(of, mtk_ut_raw_of_ids);
+
+struct platform_driver mtk_ut_raw_driver = {
+	.probe   = mtk_ut_raw_probe,
+	.remove  = mtk_ut_raw_remove,
+	.driver  = {
+		.name  = "mtk-cam ut-raw",
+		.of_match_table = of_match_ptr(mtk_ut_raw_of_ids),
+		.pm     = &mtk_ut_raw_pm_ops,
+	}
+};
+
+/* YUV part driver */
+static void ut_yuv_set_ops(struct device *dev)
+{
+	struct mtk_ut_yuv_device *drvdata = dev_get_drvdata(dev);
+
+	drvdata->ops.reset = NULL;
+	drvdata->ops.s_stream = NULL;
+	drvdata->ops.apply_cq = NULL;
+	drvdata->ops.initialize = NULL;
+}
+
+static int mtk_ut_yuv_component_bind(struct device *dev,
+				     struct device *master, void *data)
+{
+	struct mtk_ut_yuv_device *drvdata = dev_get_drvdata(dev);
+	struct mtk_cam_ut *ut = data;
+
+	dev_info(dev, "%s\n", __func__);
+
+	if (!data) {
+		dev_info(dev, "no master data\n");
+		return -1;
+	}
+
+	if (!ut->yuv) {
+		dev_info(dev, "no yuv arr, num of yuv %d\n", ut->num_yuv);
+		return -1;
+	}
+	ut->yuv[drvdata->id] = dev;
+
+	return 0;
+}
+
+static void mtk_ut_yuv_component_unbind(struct device *dev,
+					struct device *master, void *data)
+{
+	struct mtk_ut_yuv_device *drvdata = dev_get_drvdata(dev);
+	struct mtk_cam_ut *ut = data;
+
+	dev_dbg(dev, "%s\n", __func__);
+	ut->yuv[drvdata->id] = NULL;
+}
+
+static const struct component_ops mtk_ut_yuv_component_ops = {
+	.bind = mtk_ut_yuv_component_bind,
+	.unbind = mtk_ut_yuv_component_unbind,
+};
+
+static void yuv_handle_dma_err(struct mtk_ut_yuv_device *raw)
+{
+	//void __iomem *base = raw->base;
+	void __iomem *yuv_base = raw->base;
+
+	dev_info_ratelimited(raw->dev,
+			    "YUVO_R1/R2/R3/R4/R5:%x/%x/%x/%x/%x\n",
+			    readl_relaxed(yuv_base + REG_YUVO_R1_ERR_STAT),
+			    readl_relaxed(yuv_base + REG_YUVO_R2_ERR_STAT),
+			    readl_relaxed(yuv_base + REG_YUVO_R3_ERR_STAT),
+			    readl_relaxed(yuv_base + REG_YUVO_R4_ERR_STAT),
+			    readl_relaxed(yuv_base + REG_YUVO_R5_ERR_STAT)
+			   );
+
+	dev_info_ratelimited(raw->dev,
+			    "RZH1N2TO_R1/R2/R3:%x/%x/%x,DRZS4NO_R1/R2/R3:%x/%x/%x\n",
+			    readl_relaxed(yuv_base + REG_RZH1N2TO_R1_ERR_STAT),
+			    readl_relaxed(yuv_base + REG_RZH1N2TO_R2_ERR_STAT),
+			    readl_relaxed(yuv_base + REG_RZH1N2TO_R3_ERR_STAT),
+			    readl_relaxed(yuv_base + REG_DRZS4NO_R1_ERR_STAT),
+			    readl_relaxed(yuv_base + REG_DRZS4NO_R2_ERR_STAT),
+			    readl_relaxed(yuv_base + REG_DRZS4NO_R3_ERR_STAT)
+			   );
+}
+
+static irqreturn_t mtk_ut_yuv_irq(int irq, void *data)
+{
+	struct mtk_ut_yuv_device *drvdata = data;
+	void __iomem *base = drvdata->base;
+	struct ut_yuv_status status;
+
+	/* yuv */
+	status.irq = readl_relaxed(CAM_REG_CTL2_RAW_INT_STATUS(base));
+	status.wdma = readl_relaxed(CAM_REG_CTL2_RAW_INT2_STATUS(base));
+	status.drop = readl_relaxed(CAM_REG_CTL2_RAW_INT4_STATUS(base));
+	status.ofl = readl_relaxed(CAM_REG_CTL2_RAW_INT5_STATUS(base));
+
+	if (status.irq & 0x04)
+		yuv_handle_dma_err(data);
+
+	if (status.irq & (YUV_PASS1_DON_ST|YUV_SW_PASS1_DON_ST|YUV_DMA_ERR_ST)) {
+		struct ut_yuv_statusx statusx;
+
+		statusx.irq = readl_relaxed(CAM_REG_CTL2_RAW_INT_STATUSX(base));
+		statusx.wdma = readl_relaxed(CAM_REG_CTL2_RAW_INT2_STATUSX(base));
+		statusx.drop = readl_relaxed(CAM_REG_CTL2_RAW_INT4_STATUSX(base));
+		statusx.ofl = readl_relaxed(CAM_REG_CTL2_RAW_INT5_STATUSX(base));
+
+		dev_info(drvdata->dev, "STATUSX INT-DONE 1245 0x%x/0x%x/0x%x/0x%x\n",
+			 statusx.irq, statusx.wdma, statusx.drop, statusx.ofl);
+	}
+
+	dev_info(drvdata->dev, "INT 1245 0x%x/0x%x/0x%x/0x%x\n",
+		 status.irq, status.wdma, status.drop, status.ofl);
+
+	return IRQ_HANDLED;
+}
+
+static int mtk_ut_yuv_of_probe(struct platform_device *pdev,
+			    struct mtk_ut_yuv_device *drvdata)
+{
+	struct device *dev = &pdev->dev;
+	struct resource *res;
+	int irq, ret;
+	int i;
+
+	ret = of_property_read_u32(dev->of_node, "mediatek,cam-id",
+				   &drvdata->id);
+	dev_info(dev, "id = %d\n", drvdata->id);
+	if (ret) {
+		dev_info(dev, "missing camid property\n");
+		return ret;
+	}
+
+	/* base outer register */
+	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "base");
+	if (!res) {
+		dev_info(dev, "failed to get mem\n");
+		return -ENODEV;
+	}
+
+	drvdata->base = devm_ioremap_resource(dev, res);
+	if (IS_ERR(drvdata->base)) {
+		dev_info(dev, "failed to map register base\n");
+		return PTR_ERR(drvdata->base);
+	}
+
+	irq = platform_get_irq(pdev, 0);
+	if (irq < 0) {
+		dev_info(dev, "failed to get irq\n");
+		return -ENODEV;
+	}
+
+	ret = devm_request_irq(dev, irq, mtk_ut_yuv_irq, 0,
+			       dev_name(dev), drvdata);
+	if (ret) {
+		dev_info(dev, "failed to request irq=%d\n", irq);
+		return ret;
+	}
+	dev_dbg(dev, "registered irq=%d\n", irq);
+
+	drvdata->num_clks = of_count_phandle_with_args(pdev->dev.of_node,
+						       "clocks",
+						       "#clock-cells");
+	dev_info(dev, "clk_num:%d\n", drvdata->num_clks);
+
+	if (drvdata->num_clks) {
+		drvdata->clks = devm_kcalloc(dev, drvdata->num_clks,
+					     sizeof(*drvdata->clks),
+					     GFP_KERNEL);
+		if (!drvdata->clks)
+			return -ENODEV;
+	}
+
+	for (i = 0; i < drvdata->num_clks; i++) {
+		drvdata->clks[i] = of_clk_get(pdev->dev.of_node, i);
+		if (IS_ERR(drvdata->clks[i])) {
+			dev_info(dev, "failed to get clk %d\n", i);
+			return -ENODEV;
+		}
+	}
+
+	return 0;
+}
+
+
+static int mtk_ut_yuv_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct mtk_ut_yuv_device *drvdata;
+	int ret;
+
+	dev_info(dev, "%s\n", __func__);
+
+	drvdata = devm_kzalloc(dev, sizeof(*drvdata), GFP_KERNEL);
+	if (!drvdata)
+		return -ENOMEM;
+
+	drvdata->dev = dev;
+	dev_set_drvdata(dev, drvdata);
+
+	ret = mtk_ut_yuv_of_probe(pdev, drvdata);
+	if (ret)
+		return ret;
+
+	ut_yuv_set_ops(dev);
+
+	pm_runtime_enable(dev);
+
+	ret = component_add(dev, &mtk_ut_yuv_component_ops);
+	if (ret)
+		return ret;
+
+	dev_info(dev, "%s: success\n", __func__);
+	return 0;
+}
+
+static int mtk_ut_yuv_remove(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct mtk_ut_raw_device *drvdata = dev_get_drvdata(dev);
+	int i;
+
+	dev_info(dev, "%s\n", __func__);
+
+	pm_runtime_disable(dev);
+	component_del(dev, &mtk_ut_yuv_component_ops);
+
+	for (i = 0; i < drvdata->num_clks; i++)
+		clk_put(drvdata->clks[i]);
+
+	return 0;
+}
+
+
+static int mtk_ut_yuv_pm_suspend(struct device *dev)
+{
+	int ret;
+
+	dev_dbg(dev, "- %s\n", __func__);
+
+	if (pm_runtime_suspended(dev))
+		return 0;
+
+	ret = pm_runtime_force_suspend(dev);
+
+	return ret;
+}
+
+static int mtk_ut_yuv_pm_resume(struct device *dev)
+{
+	int ret;
+
+	dev_dbg(dev, "- %s\n", __func__);
+
+	if (pm_runtime_suspended(dev))
+		return 0;
+
+	/* Force ISP HW to resume */
+	ret = pm_runtime_force_resume(dev);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+static int mtk_ut_yuv_runtime_suspend(struct device *dev)
+{
+	struct mtk_ut_yuv_device *raw = dev_get_drvdata(dev);
+	int i;
+
+	for (i = 0; i < raw->num_clks; i++)
+		clk_disable_unprepare(raw->clks[i]);
+	return 0;
+}
+
+static int mtk_ut_yuv_runtime_resume(struct device *dev)
+{
+	struct mtk_ut_yuv_device *raw = dev_get_drvdata(dev);
+	int i, ret;
+
+	for (i = 0; i < raw->num_clks; i++) {
+		ret = clk_prepare_enable(raw->clks[i]);
+		if (ret) {
+			dev_info(dev, "enable failed at clk #%d, ret = %d\n",
+				 i, ret);
+			i--;
+			while (i >= 0)
+				clk_disable_unprepare(raw->clks[i--]);
+
+			return ret;
+		}
+	}
+	return 0;
+}
+
+
+static const struct dev_pm_ops mtk_ut_yuv_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(mtk_ut_yuv_pm_suspend, mtk_ut_yuv_pm_resume)
+	SET_RUNTIME_PM_OPS(mtk_ut_yuv_runtime_suspend, mtk_ut_yuv_runtime_resume,
+			   NULL)
+};
+
+static const struct of_device_id mtk_ut_yuv_of_ids[] = {
+	{.compatible = "mediatek,cam-yuv",},
+	{}
+};
+MODULE_DEVICE_TABLE(of, mtk_ut_yuv_of_ids);
+
+struct platform_driver mtk_ut_yuv_driver = {
+	.probe   = mtk_ut_yuv_probe,
+	.remove  = mtk_ut_yuv_remove,
+	.driver  = {
+		.name  = "mtk-cam ut-yuv",
+		.of_match_table = of_match_ptr(mtk_ut_yuv_of_ids),
+		.pm     = &mtk_ut_yuv_pm_ops,
+	}
+};
+
+#if WITH_LARB_DRIVER
+static int mtk_ut_larb_component_bind(struct device *dev,
+				      struct device *master,
+				      void *data)
+{
+	struct device_link *link;
+
+	dev_dbg(dev, "%s\n", __func__);
+
+	link = device_link_add(master, dev, DL_FLAG_AUTOREMOVE_CONSUMER |
+			       DL_FLAG_PM_RUNTIME);
+	if (!link) {
+		dev_info(dev, "Unable to create link between %s and %s\n",
+			 dev_name(master), dev_name(dev));
+		return -ENODEV;
+	}
+	return 0;
+}
+
+static void mtk_ut_larb_component_unbind(struct device *dev,
+					 struct device *master,
+					 void *data)
+{
+	dev_dbg(dev, "%s\n", __func__);
+}
+
+static const struct component_ops mtk_ut_larb_component_ops = {
+	.bind = mtk_ut_larb_component_bind,
+	.unbind = mtk_ut_larb_component_unbind,
+};
+
+static int mtk_ut_larb_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	int ret;
+
+	dev_info(dev, "%s\n", __func__);
+
+#ifdef CONFIG_MTK_IOMMU_PGTABLE_EXT
+#if (CONFIG_MTK_IOMMU_PGTABLE_EXT > 32)
+	if (dma_set_mask_and_coherent(dev, DMA_BIT_MASK(34)))
+		dev_dbg(dev, "%s: No suitable DMA available\n", __func__);
+#endif
+#endif
+
+	if (!dev->dma_parms) {
+		dev->dma_parms =
+			devm_kzalloc(dev, sizeof(*dev->dma_parms), GFP_KERNEL);
+		if (!dev->dma_parms)
+			return -ENOMEM;
+	}
+
+	if (dev->dma_parms) {
+		ret = dma_set_max_seg_size(dev, UINT_MAX);
+		if (ret)
+			dev_info(dev, "Failed to set DMA segment size\n");
+	}
+
+	pm_runtime_enable(dev);
+	pm_runtime_get_sync(dev);
+
+	ret = component_add(dev, &mtk_ut_larb_component_ops);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+static int mtk_ut_larb_remove(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+
+	dev_info(dev, "%s disable larb\n", __func__);
+	pm_runtime_put(dev);
+	pm_runtime_disable(dev);
+	return 0;
+}
+
+static const struct of_device_id mtk_ut_larb_of_ids[] = {
+	{.compatible = "mediatek,camisp-larb",},
+	{}
+};
+MODULE_DEVICE_TABLE(of, mtk_ut_larb_of_ids);
+
+struct platform_driver mtk_ut_larb_driver = {
+	.probe   = mtk_ut_larb_probe,
+	.remove  = mtk_ut_larb_remove,
+	.driver  = {
+		.name  = "mtk-cam larb-ut",
+		.of_match_table = of_match_ptr(mtk_ut_larb_of_ids),
+	}
+};
+#endif
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/camsys/unit_test/mtk_cam_ut-camsv.c b/drivers/media/platform/mediatek/isp/isp_7x/camsys/unit_test/mtk_cam_ut-camsv.c
new file mode 100644
index 0000000000000000000000000000000000000000..58f14ba6e3e2addc5cb197f9bbbdf93f061d0417
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/camsys/unit_test/mtk_cam_ut-camsv.c
@@ -0,0 +1,994 @@
+// SPDX-License-Identifier: GPL-2.0
+//
+// Copyright (c) 2021 MediaTek Inc.
+
+#include <linux/clk.h>
+#include <linux/component.h>
+#include <linux/dma-mapping.h>
+#include <linux/interrupt.h>
+#include <linux/iopoll.h>
+#include <linux/module.h>
+#include <linux/of_platform.h>
+#include <linux/of.h>
+#include <linux/platform_device.h>
+#include <linux/pm_runtime.h>
+
+#include "mtk_cam_ut.h"
+#include "mtk_cam_ut-engines.h"
+#ifdef ISP7_1
+#include "../src/mtk_cam-sv-regs-mt8188.h"
+#else
+#include "../src/mtk_cam-sv-regs-mt8195.h"
+#endif
+
+#define CAMSV_WRITE_BITS(RegAddr, RegName, FieldName, FieldValue) do {\
+	union RegName reg;\
+	\
+	reg.Raw = readl_relaxed(RegAddr);\
+	reg.Bits.FieldName = FieldValue;\
+	writel_relaxed(reg.Raw, RegAddr);\
+} while (0)
+
+#define CAMSV_WRITE_REG(RegAddr, RegValue) ({\
+	writel_relaxed(RegValue, RegAddr);\
+})
+
+#define CAMSV_READ_BITS(RegAddr, RegName, FieldName) ({\
+	union RegName reg;\
+	\
+	reg.Raw = readl_relaxed(RegAddr);\
+	reg.Bits.FieldName;\
+})
+
+#define CAMSV_READ_REG(RegAddr) ({\
+	unsigned int var;\
+	\
+	var = readl_relaxed(RegAddr);\
+	var;\
+})
+
+enum camsv_db_load_src {
+	SV_DB_SRC_SUB_P1_DONE = 0,
+	SV_DB_SRC_SOF         = 1,
+	SV_DB_SRC_SUB_SOF     = 2,
+};
+
+enum camsv_int_en {
+	SV_INT_EN_VS1_INT_EN               = (1L<<0),
+	SV_INT_EN_TG_INT1_EN               = (1L<<1),
+	SV_INT_EN_TG_INT2_EN               = (1L<<2),
+	SV_INT_EN_EXPDON1_INT_EN           = (1L<<3),
+	SV_INT_EN_TG_ERR_INT_EN            = (1L<<4),
+	SV_INT_EN_TG_GBERR_INT_EN          = (1L<<5),
+	SV_INT_EN_TG_SOF_INT_EN            = (1L<<6),
+	SV_INT_EN_TG_WAIT_INT_EN           = (1L<<7),
+	SV_INT_EN_TG_DROP_INT_EN           = (1L<<8),
+	SV_INT_EN_VS_INT_ORG_EN            = (1L<<9),
+	SV_INT_EN_DB_LOAD_ERR_EN           = (1L<<10),
+	SV_INT_EN_PASS1_DON_INT_EN         = (1L<<11),
+	SV_INT_EN_SW_PASS1_DON_INT_EN      = (1L<<12),
+	SV_INT_EN_SUB_PASS1_DON_INT_EN     = (1L<<13),
+	SV_INT_EN_UFEO_OVERR_INT_EN        = (1L<<15),
+	SV_INT_EN_DMA_ERR_INT_EN           = (1L<<16),
+	SV_INT_EN_IMGO_OVERR_INT_EN        = (1L<<17),
+	SV_INT_EN_UFEO_DROP_INT_EN         = (1L<<18),
+	SV_INT_EN_IMGO_DROP_INT_EN         = (1L<<19),
+	SV_INT_EN_IMGO_DONE_INT_EN         = (1L<<20),
+	SV_INT_EN_UFEO_DONE_INT_EN         = (1L<<21),
+	SV_INT_EN_TG_INT3_EN               = (1L<<22),
+	SV_INT_EN_TG_INT4_EN               = (1L<<23),
+	SV_INT_EN_INT_WCLR_EN              = (1L<<31),
+};
+
+enum camsv_tg_fmt {
+	SV_TG_FMT_RAW8      = 0,
+	SV_TG_FMT_RAW10     = 1,
+	SV_TG_FMT_RAW12     = 2,
+	SV_TG_FMT_YUV422    = 3,
+	SV_TG_FMT_RAW14     = 4,
+	SV_TG_FMT_RSV1      = 5,
+	SV_TG_FMT_RSV2      = 6,
+	SV_TG_FMT_JPG       = 7,
+};
+
+enum camsv_tg_swap {
+	TG_SW_UYVY = 0,
+	TG_SW_YUYV = 1,
+	TG_SW_VYUY = 2,
+	TG_SW_YVYU = 3,
+};
+
+unsigned int ut_mtk_cam_sv_xsize_cal(
+	struct mtkcam_ipi_input_param *cfg_in_param)
+{
+
+	union CAMSV_FMT_SEL fmt;
+	unsigned int size;
+	unsigned int divisor;
+
+	fmt.Raw = cfg_in_param->fmt;
+
+	switch (fmt.Bits.TG1_FMT) {
+	case SV_TG_FMT_RAW8:
+		size = cfg_in_param->in_crop.s.w;
+		break;
+	case SV_TG_FMT_RAW10:
+		size = (cfg_in_param->in_crop.s.w * 10) / 8;
+		break;
+	case SV_TG_FMT_RAW12:
+		size = (cfg_in_param->in_crop.s.w * 12) / 8;
+		break;
+	case SV_TG_FMT_RAW14:
+		size = (cfg_in_param->in_crop.s.w * 14) / 8;
+		break;
+	default:
+		return 0;
+	}
+
+	switch (cfg_in_param->pixel_mode) {
+	case 0:
+		divisor = 0x1;
+		break;
+	case 1:
+		divisor = 0x3;
+		break;
+	case 2:
+		divisor = 0x7;
+		break;
+	case 3:
+		divisor = 0xF;
+		break;
+	default:
+		return 0;
+	}
+	size = ((size + divisor) & ~divisor);
+	return size;
+}
+
+void ut_sv_reset(struct device *dev)
+{
+	unsigned long end = jiffies + msecs_to_jiffies(100);
+	struct mtk_ut_camsv_device *sv_dev = dev_get_drvdata(dev);
+
+	dev_dbg(dev, "%s\n", __func__);
+
+	writel_relaxed(0, sv_dev->base + REG_CAMSV_SW_CTL);
+	writel_relaxed(1, sv_dev->base + REG_CAMSV_SW_CTL);
+	wmb(); /* TBC */
+
+	while (time_before(jiffies, end)) {
+		if (readl(sv_dev->base + REG_CAMSV_SW_CTL) & 0x2) {
+			// do hw rst
+			writel_relaxed(4, sv_dev->base + REG_CAMSV_SW_CTL);
+			writel_relaxed(0, sv_dev->base + REG_CAMSV_SW_CTL);
+			wmb(); /* TBC */
+			return;
+		}
+
+		dev_info(dev,
+			"tg_sen_mode: 0x%x, ctl_en: 0x%x, ctl_sw_ctl:0x%x, frame_no:0x%x\n",
+			readl(sv_dev->base + REG_CAMSV_TG_SEN_MODE),
+			readl(sv_dev->base + REG_CAMSV_MODULE_EN),
+			readl(sv_dev->base + REG_CAMSV_SW_CTL),
+			readl(sv_dev->base + REG_CAMSV_FRAME_SEQ_NO)
+			);
+		usleep_range(10, 20);
+	}
+
+	dev_dbg(dev, "reset hw timeout\n");
+}
+
+int ut_mtk_cam_sv_convert_fmt(unsigned int ipi_fmt)
+{
+	union CAMSV_FMT_SEL fmt;
+
+	fmt.Raw = 0;
+	fmt.Bits.TG1_SW = TG_SW_UYVY;
+
+	switch (ipi_fmt) {
+	case MTKCAM_IPI_IMG_FMT_BAYER8:
+		fmt.Bits.TG1_FMT = SV_TG_FMT_RAW8;
+		break;
+	case MTKCAM_IPI_IMG_FMT_BAYER10:
+		fmt.Bits.TG1_FMT = SV_TG_FMT_RAW10;
+		break;
+	case MTKCAM_IPI_IMG_FMT_BAYER12:
+		fmt.Bits.TG1_FMT = SV_TG_FMT_RAW12;
+		break;
+	case MTKCAM_IPI_IMG_FMT_BAYER14:
+		fmt.Bits.TG1_FMT = SV_TG_FMT_RAW14;
+		break;
+	default:
+		break;
+	}
+
+	return fmt.Raw;
+}
+
+int ut_mtk_cam_sv_tg_config(
+	struct device *dev, struct mtkcam_ipi_input_param *cfg_in_param)
+{
+	int ret = 0;
+	unsigned int pxl, lin;
+	struct mtk_ut_camsv_device *sv_dev = dev_get_drvdata(dev);
+
+	CAMSV_WRITE_BITS(sv_dev->base + REG_CAMSV_TG_SEN_MODE,
+		CAMSV_TG_SEN_MODE, CMOS_EN, 0);
+
+	/* subsample */
+	if (cfg_in_param->subsample > 0) {
+		CAMSV_WRITE_BITS(sv_dev->base + REG_CAMSV_TG_SEN_MODE,
+			CAMSV_TG_SEN_MODE, SOF_SUB_EN, 1);
+		CAMSV_WRITE_BITS(sv_dev->base + REG_CAMSV_TG_SEN_MODE,
+			CAMSV_TG_SEN_MODE, VS_SUB_EN, 1);
+		CAMSV_WRITE_BITS(sv_dev->base + REG_CAMSV_TG_SUB_PERIOD,
+			CAMSV_TG_SUB_PERIOD, VS_PERIOD,
+			cfg_in_param->subsample);
+		CAMSV_WRITE_BITS(sv_dev->base + REG_CAMSV_TG_SUB_PERIOD,
+			CAMSV_TG_SUB_PERIOD, SOF_PERIOD,
+			cfg_in_param->subsample);
+	} else {
+		CAMSV_WRITE_BITS(sv_dev->base + REG_CAMSV_TG_SEN_MODE,
+			CAMSV_TG_SEN_MODE, SOF_SUB_EN, 0);
+		CAMSV_WRITE_BITS(sv_dev->base + REG_CAMSV_TG_SEN_MODE,
+			CAMSV_TG_SEN_MODE, VS_SUB_EN, 0);
+		CAMSV_WRITE_BITS(sv_dev->base + REG_CAMSV_TG_SUB_PERIOD,
+			CAMSV_TG_SUB_PERIOD, VS_PERIOD,
+			cfg_in_param->subsample);
+		CAMSV_WRITE_BITS(sv_dev->base + REG_CAMSV_TG_SUB_PERIOD,
+			CAMSV_TG_SUB_PERIOD, SOF_PERIOD,
+			cfg_in_param->subsample);
+	}
+
+	if (sv_dev->id == 0) {
+		CAMSV_WRITE_BITS(sv_dev->base + REG_CAMSV_TG_SEN_MODE,
+			CAMSV_TG_SEN_MODE, STAGGER_EN, 0);
+		CAMSV_WRITE_BITS(sv_dev->base + REG_CAMSV_TG_PATH_CFG,
+			CAMSV_TG_PATH_CFG, SUB_SOF_SRC_SEL, 0);
+	} else if (sv_dev->id == 1) {
+		CAMSV_WRITE_BITS(sv_dev->base + REG_CAMSV_TG_SEN_MODE,
+			CAMSV_TG_SEN_MODE, STAGGER_EN, 1);
+		CAMSV_WRITE_BITS(sv_dev->base + REG_CAMSV_TG_PATH_CFG,
+			CAMSV_TG_PATH_CFG, SUB_SOF_SRC_SEL, 0);
+	}
+
+	/* timestamp */
+	CAMSV_WRITE_BITS(sv_dev->base + REG_CAMSV_TG_SEN_MODE,
+		CAMSV_TG_SEN_MODE, TIME_STP_EN, 1);
+
+	/* trig mode */
+	CAMSV_WRITE_BITS(sv_dev->base + REG_CAMSV_TG_VF_CON,
+		CAMSV_TG_VF_CON, SINGLE_MODE, 0);
+
+	/* pixel mode */
+	switch (cfg_in_param->pixel_mode) {
+	case 0:
+		CAMSV_WRITE_BITS(sv_dev->base + REG_CAMSV_TG_SEN_MODE,
+			CAMSV_TG_SEN_MODE, DBL_DATA_BUS, 0);
+		break;
+	case 1:
+		CAMSV_WRITE_BITS(sv_dev->base + REG_CAMSV_TG_SEN_MODE,
+			CAMSV_TG_SEN_MODE, DBL_DATA_BUS, 1);
+		break;
+	case 2:
+		CAMSV_WRITE_BITS(sv_dev->base + REG_CAMSV_TG_SEN_MODE,
+			CAMSV_TG_SEN_MODE, DBL_DATA_BUS, 2);
+		break;
+	case 3:
+		CAMSV_WRITE_BITS(sv_dev->base + REG_CAMSV_TG_SEN_MODE,
+			CAMSV_TG_SEN_MODE, DBL_DATA_BUS, 3);
+		break;
+	default:
+		dev_dbg(dev, "unknown pixel mode(%d)",
+			cfg_in_param->pixel_mode);
+		ret = -1;
+		goto EXIT;
+	}
+
+	/* grab size */
+	pxl = ((cfg_in_param->in_crop.s.w+cfg_in_param->in_crop.p.x)<<16)|
+			cfg_in_param->in_crop.p.x;
+	lin = ((cfg_in_param->in_crop.s.h+cfg_in_param->in_crop.p.y)<<16)|
+			cfg_in_param->in_crop.p.y;
+	CAMSV_WRITE_REG(sv_dev->base + REG_CAMSV_TG_SEN_GRAB_PXL, pxl);
+	CAMSV_WRITE_REG(sv_dev->base + REG_CAMSV_TG_SEN_GRAB_LIN, lin);
+
+	dev_info(dev, "pixel mode:%d\n", cfg_in_param->pixel_mode);
+	dev_info(dev, "sub-sample:%d\n", cfg_in_param->subsample);
+	dev_info(dev, "fmt:%d\n", cfg_in_param->fmt);
+	dev_info(dev, "crop_x:%d\n", cfg_in_param->in_crop.p.x);
+	dev_info(dev, "crop_y:%d\n", cfg_in_param->in_crop.p.y);
+	dev_info(dev, "crop_w:%d\n", cfg_in_param->in_crop.s.w);
+	dev_info(dev, "crop_h:%d\n", cfg_in_param->in_crop.s.h);
+
+EXIT:
+	return ret;
+}
+
+int ut_mtk_cam_sv_top_config(
+	struct device *dev,
+	struct mtkcam_ipi_input_param *cfg_in_param)
+{
+	unsigned int int_en =
+		(SV_INT_EN_VS1_INT_EN |
+		SV_INT_EN_TG_ERR_INT_EN |
+		SV_INT_EN_TG_GBERR_INT_EN |
+		SV_INT_EN_TG_SOF_INT_EN |
+		SV_INT_EN_PASS1_DON_INT_EN |
+		SV_INT_EN_SW_PASS1_DON_INT_EN |
+		SV_INT_EN_DMA_ERR_INT_EN |
+		SV_INT_EN_IMGO_OVERR_INT_EN);
+	union CAMSV_FMT_SEL fmt;
+	int ret = 0;
+	struct mtk_ut_camsv_device *sv_dev = dev_get_drvdata(dev);
+
+	/* reset */
+	ut_sv_reset(dev);
+
+	/* fun en */
+	CAMSV_WRITE_BITS(sv_dev->base + REG_CAMSV_MODULE_EN,
+		CAMSV_MODULE_EN, TG_EN, 1);
+	CAMSV_WRITE_BITS(sv_dev->base + REG_CAMSV_MODULE_EN,
+		CAMSV_MODULE_EN, DB_EN, 0);
+	CAMSV_WRITE_BITS(sv_dev->base + REG_CAMSV_MODULE_EN,
+		CAMSV_MODULE_EN, DB_LOAD_SRC, SV_DB_SRC_SUB_SOF);
+
+	/* central sub en */
+	if (cfg_in_param->subsample > 0)
+		CAMSV_WRITE_BITS(sv_dev->base + REG_CAMSV_SUB_CTRL,
+			CAMSV_SUB_CTRL, CENTRAL_SUB_EN, 1);
+	else
+		CAMSV_WRITE_BITS(sv_dev->base + REG_CAMSV_SUB_CTRL,
+			CAMSV_SUB_CTRL, CENTRAL_SUB_EN, 0);
+
+	/* disable db load mask for non-dcif case */
+	CAMSV_WRITE_BITS(sv_dev->base + REG_CAMSV_DCIF_SET,
+		CAMSV_DCIF_SET, MASK_DB_LOAD, 0);
+
+	CAMSV_WRITE_BITS(sv_dev->base + REG_CAMSV_DCIF_SET,
+		CAMSV_DCIF_SET, FOR_DCIF_SUBSAMPLE_EN, 1);
+	CAMSV_WRITE_BITS(sv_dev->base + REG_CAMSV_DCIF_SET,
+		CAMSV_DCIF_SET, ENABLE_OUTPUT_CQ_START_SIGNAL, 1);
+
+	/* fmt sel */
+	fmt.Raw = ut_mtk_cam_sv_convert_fmt(cfg_in_param->fmt);
+	CAMSV_WRITE_REG(sv_dev->base + REG_CAMSV_FMT_SEL, fmt.Raw);
+
+	/* int en */
+	CAMSV_WRITE_REG(sv_dev->base + REG_CAMSV_INT_EN, int_en);
+
+	/* sub p1 done */
+	if (cfg_in_param->subsample > 0) {
+		CAMSV_WRITE_BITS(sv_dev->base + REG_CAMSV_MODULE_EN,
+			CAMSV_MODULE_EN, DOWN_SAMPLE_EN, 1);
+		CAMSV_WRITE_BITS(sv_dev->base + REG_CAMSV_MODULE_EN,
+			CAMSV_MODULE_EN, DOWN_SAMPLE_PERIOD,
+			cfg_in_param->subsample);
+	} else {
+		CAMSV_WRITE_BITS(sv_dev->base + REG_CAMSV_MODULE_EN,
+			CAMSV_MODULE_EN, DOWN_SAMPLE_EN, 0);
+		CAMSV_WRITE_BITS(sv_dev->base + REG_CAMSV_MODULE_EN,
+			CAMSV_MODULE_EN, DOWN_SAMPLE_PERIOD,
+			cfg_in_param->subsample);
+	}
+
+	switch (fmt.Bits.TG1_FMT) {
+	case SV_TG_FMT_RAW8:
+		CAMSV_WRITE_BITS(sv_dev->base + REG_CAMSV_MODULE_EN,
+			CAMSV_MODULE_EN, PAK_EN, 1);
+		CAMSV_WRITE_BITS(sv_dev->base + REG_CAMSV_MODULE_EN,
+			CAMSV_MODULE_EN, PAK_SEL, 0);
+		CAMSV_WRITE_BITS(sv_dev->base + REG_CAMSV_PAK,
+			CAMSV_PAK, PAK_MODE, 128);
+		CAMSV_WRITE_BITS(sv_dev->base + REG_CAMSV_PAK_CON,
+			CAMSV_PAK_CON, PAK_IN_BIT, 14);
+		break;
+	case SV_TG_FMT_RAW10:
+		CAMSV_WRITE_BITS(sv_dev->base + REG_CAMSV_MODULE_EN,
+			CAMSV_MODULE_EN, PAK_EN, 1);
+		CAMSV_WRITE_BITS(sv_dev->base + REG_CAMSV_MODULE_EN,
+			CAMSV_MODULE_EN, PAK_SEL, 0);
+		CAMSV_WRITE_BITS(sv_dev->base + REG_CAMSV_PAK,
+			CAMSV_PAK, PAK_MODE, 129);
+		CAMSV_WRITE_BITS(sv_dev->base + REG_CAMSV_PAK_CON,
+			CAMSV_PAK_CON, PAK_IN_BIT, 14);
+		break;
+	case SV_TG_FMT_RAW12:
+		CAMSV_WRITE_BITS(sv_dev->base + REG_CAMSV_MODULE_EN,
+			CAMSV_MODULE_EN, PAK_EN, 1);
+		CAMSV_WRITE_BITS(sv_dev->base + REG_CAMSV_MODULE_EN,
+			CAMSV_MODULE_EN, PAK_SEL, 0);
+		CAMSV_WRITE_BITS(sv_dev->base + REG_CAMSV_PAK,
+			CAMSV_PAK, PAK_MODE, 130);
+		CAMSV_WRITE_BITS(sv_dev->base + REG_CAMSV_PAK_CON,
+			CAMSV_PAK_CON, PAK_IN_BIT, 14);
+		break;
+	default:
+		dev_dbg(dev, "unknown tg format(%d)", fmt.Bits.TG1_FMT);
+		ret = -1;
+		goto EXIT;
+	}
+
+	/* ufe disable */
+	CAMSV_WRITE_BITS(sv_dev->base + REG_CAMSV_MODULE_EN,
+		CAMSV_MODULE_EN, UFE_EN, 0);
+
+	/* pixel mode */
+	switch (cfg_in_param->pixel_mode) {
+	case 0:
+		CAMSV_WRITE_BITS(sv_dev->base + REG_CAMSV_PAK,
+			CAMSV_PAK, PAK_DBL_MODE, 0);
+		break;
+	case 1:
+		CAMSV_WRITE_BITS(sv_dev->base + REG_CAMSV_PAK,
+			CAMSV_PAK, PAK_DBL_MODE, 1);
+		break;
+	case 2:
+		CAMSV_WRITE_BITS(sv_dev->base + REG_CAMSV_PAK,
+			CAMSV_PAK, PAK_DBL_MODE, 2);
+		break;
+	case 3:
+		CAMSV_WRITE_BITS(sv_dev->base + REG_CAMSV_PAK,
+			CAMSV_PAK, PAK_DBL_MODE, 3);
+		break;
+	default:
+		dev_dbg(dev, "unknown pixel mode(%d)",
+			cfg_in_param->pixel_mode);
+		ret = -1;
+		goto EXIT;
+	}
+
+	/* dma performance */
+	CAMSV_WRITE_REG(sv_dev->base + REG_CAMSV_SPECIAL_FUN_EN, 0x4000000);
+
+EXIT:
+	return ret;
+}
+
+int ut_mtk_cam_sv_dmao_config(
+	struct device *dev,
+	struct mtkcam_ipi_input_param *cfg_in_param)
+{
+	int ret = 0;
+	unsigned int stride;
+	struct mtk_ut_camsv_device *sv_dev = dev_get_drvdata(dev);
+
+	/* imgo dma setting */
+	CAMSV_WRITE_REG(sv_dev->base + REG_CAMSV_IMGO_XSIZE,
+		ut_mtk_cam_sv_xsize_cal(cfg_in_param) - 1);
+	CAMSV_WRITE_REG(sv_dev->base + REG_CAMSV_IMGO_YSIZE,
+		cfg_in_param->in_crop.s.h - 1);
+	CAMSV_WRITE_REG(sv_dev->base + REG_CAMSV_IMGO_STRIDE,
+		ut_mtk_cam_sv_xsize_cal(cfg_in_param));
+
+	dev_info(dev, "xsize:%d\n",
+		CAMSV_READ_REG(sv_dev->base + REG_CAMSV_IMGO_XSIZE));
+	dev_info(dev, "ysize:%d\n",
+		CAMSV_READ_REG(sv_dev->base + REG_CAMSV_IMGO_YSIZE));
+	dev_info(dev, "stride:%d\n",
+		CAMSV_READ_REG(sv_dev->base + REG_CAMSV_IMGO_STRIDE));
+
+	/* imgo crop */
+	CAMSV_WRITE_REG(sv_dev->base + REG_CAMSV_IMGO_CROP, 0);
+
+	/* imgo stride */
+	stride = CAMSV_READ_REG(sv_dev->base + REG_CAMSV_IMGO_STRIDE);
+	switch (cfg_in_param->pixel_mode) {
+	case 0:
+		stride = stride | (1<<27) | (1<<16);
+		CAMSV_WRITE_REG(sv_dev->base + REG_CAMSV_IMGO_STRIDE, stride);
+		break;
+	case 1:
+		stride = stride | (1<<27) | (3<<16);
+		CAMSV_WRITE_REG(sv_dev->base + REG_CAMSV_IMGO_STRIDE, stride);
+		break;
+	case 2:
+		stride = stride | (1<<27) | (7<<16);
+		CAMSV_WRITE_REG(sv_dev->base + REG_CAMSV_IMGO_STRIDE, stride);
+		break;
+	case 3:
+		stride = stride | (1<<27) | (15<<16);
+		CAMSV_WRITE_REG(sv_dev->base + REG_CAMSV_IMGO_STRIDE, stride);
+		break;
+	default:
+		dev_dbg(dev, "unknown pixel mode(%d)",
+			cfg_in_param->pixel_mode);
+		ret = -1;
+		goto EXIT;
+	}
+
+	/* imgo con */
+	if (sv_dev->id >= 0 && sv_dev->id < 10) {
+		CAMSV_WRITE_REG(sv_dev->base + REG_CAMSV_IMGO_CON0, 0x80000300);
+		CAMSV_WRITE_REG(sv_dev->base + REG_CAMSV_IMGO_CON1, 0x00C00060);
+		CAMSV_WRITE_REG(sv_dev->base + REG_CAMSV_IMGO_CON2, 0x01800120);
+		CAMSV_WRITE_REG(sv_dev->base + REG_CAMSV_IMGO_CON3, 0x020001A0);
+		CAMSV_WRITE_REG(sv_dev->base + REG_CAMSV_IMGO_CON4, 0x012000C0);
+	} else {
+		CAMSV_WRITE_REG(sv_dev->base + REG_CAMSV_IMGO_CON0, 0x80000100);
+		CAMSV_WRITE_REG(sv_dev->base + REG_CAMSV_IMGO_CON1, 0x00400020);
+		CAMSV_WRITE_REG(sv_dev->base + REG_CAMSV_IMGO_CON2, 0x00800060);
+		CAMSV_WRITE_REG(sv_dev->base + REG_CAMSV_IMGO_CON3, 0x00AA0082);
+		CAMSV_WRITE_REG(sv_dev->base + REG_CAMSV_IMGO_CON4, 0x00600040);
+	}
+
+EXIT:
+	return ret;
+}
+
+int ut_mtk_cam_sv_fbc_config(
+	struct device *dev,
+	struct mtkcam_ipi_input_param *cfg_in_param)
+{
+	int ret = 0;
+	struct mtk_ut_camsv_device *sv_dev = dev_get_drvdata(dev);
+
+	CAMSV_WRITE_REG(sv_dev->base + REG_CAMSV_FBC_IMGO_CTL1, 0);
+
+	return ret;
+}
+
+int ut_mtk_cam_sv_tg_enable(
+	struct device *dev,
+	struct mtkcam_ipi_input_param *cfg_in_param)
+{
+	int ret = 0;
+	struct mtk_ut_camsv_device *sv_dev = dev_get_drvdata(dev);
+
+	CAMSV_WRITE_BITS(sv_dev->base + REG_CAMSV_TG_SEN_MODE,
+		CAMSV_TG_SEN_MODE, CMOS_EN, 1);
+
+	return ret;
+}
+
+int ut_mtk_cam_sv_top_enable(struct device *dev)
+{
+	int ret = 0;
+	struct mtk_ut_camsv_device *sv_dev = dev_get_drvdata(dev);
+
+	if (CAMSV_READ_BITS(sv_dev->base + REG_CAMSV_TG_SEN_MODE,
+		CAMSV_TG_SEN_MODE, CMOS_EN)) {
+		CAMSV_WRITE_BITS(sv_dev->base + REG_CAMSV_TG_VF_CON,
+			CAMSV_TG_VF_CON, VFDATA_EN, 1);
+		CAMSV_WRITE_BITS(sv_dev->base + REG_CAMSV_TG_PATH_CFG,
+			CAMSV_TG_PATH_CFG, DB_LOAD_DIS, 0);
+	}
+
+	return ret;
+}
+
+int ut_mtk_cam_sv_dmao_enable(
+	struct device *dev,
+	struct mtkcam_ipi_input_param *cfg_in_param)
+{
+	int ret = 0;
+	struct mtk_ut_camsv_device *sv_dev = dev_get_drvdata(dev);
+
+	CAMSV_WRITE_BITS(sv_dev->base + REG_CAMSV_MODULE_EN,
+		CAMSV_MODULE_EN, IMGO_EN, 1);
+
+	return ret;
+}
+
+int ut_mtk_cam_sv_fbc_enable(
+	struct device *dev,
+	struct mtkcam_ipi_input_param *cfg_in_param)
+{
+	int ret = 0;
+	struct mtk_ut_camsv_device *sv_dev = dev_get_drvdata(dev);
+
+	if (CAMSV_READ_BITS(sv_dev->base + REG_CAMSV_TG_VF_CON,
+			CAMSV_TG_VF_CON, VFDATA_EN) == 1) {
+		ret = -1;
+		dev_dbg(dev, "cannot enable fbc when streaming");
+		goto EXIT;
+	}
+	CAMSV_WRITE_BITS(sv_dev->base + REG_CAMSV_FBC_IMGO_CTL1,
+		CAMSV_FBC_IMGO_CTL1, SUB_RATIO, cfg_in_param->subsample);
+	CAMSV_WRITE_BITS(sv_dev->base + REG_CAMSV_FBC_IMGO_CTL1,
+		CAMSV_FBC_IMGO_CTL1, FBC_EN, 1);
+	CAMSV_WRITE_BITS(sv_dev->base + REG_CAMSV_FBC_IMGO_CTL1,
+		CAMSV_FBC_IMGO_CTL1, FBC_DB_EN, 0);
+
+EXIT:
+	return ret;
+}
+
+int ut_mtk_cam_sv_tg_disable(
+	struct device *dev)
+{
+	int ret = 0;
+	struct mtk_ut_camsv_device *sv_dev = dev_get_drvdata(dev);
+
+	CAMSV_WRITE_BITS(sv_dev->base + REG_CAMSV_TG_SEN_MODE,
+		CAMSV_TG_SEN_MODE, CMOS_EN, 0);
+
+	return ret;
+}
+
+int ut_mtk_cam_sv_top_disable(struct device *dev)
+{
+	int ret = 0;
+	struct mtk_ut_camsv_device *sv_dev = dev_get_drvdata(dev);
+
+	if (CAMSV_READ_BITS(sv_dev->base + REG_CAMSV_TG_VF_CON,
+			CAMSV_TG_VF_CON, VFDATA_EN)) {
+		CAMSV_WRITE_BITS(sv_dev->base + REG_CAMSV_TG_VF_CON,
+			CAMSV_TG_VF_CON, VFDATA_EN, 0);
+		ut_sv_reset(dev);
+	}
+	CAMSV_WRITE_BITS(sv_dev->base + REG_CAMSV_MODULE_EN,
+		CAMSV_MODULE_EN, DB_EN, 0);
+	CAMSV_WRITE_REG(sv_dev->base + REG_CAMSV_MODULE_EN, 0);
+	CAMSV_WRITE_REG(sv_dev->base + REG_CAMSV_FMT_SEL, 0);
+	CAMSV_WRITE_REG(sv_dev->base + REG_CAMSV_INT_EN, 0);
+	CAMSV_WRITE_REG(sv_dev->base + REG_CAMSV_FBC_IMGO_CTL1, 0);
+	CAMSV_WRITE_BITS(sv_dev->base + REG_CAMSV_MODULE_EN,
+		CAMSV_MODULE_EN, DB_EN, 1);
+
+	CAMSV_WRITE_BITS(sv_dev->base + REG_CAMSV_CLK_EN,
+		CAMSV_CLK_EN, TG_DP_CK_EN, 0);
+	CAMSV_WRITE_BITS(sv_dev->base + REG_CAMSV_CLK_EN,
+		CAMSV_CLK_EN, PAK_DP_CK_EN, 0);
+	CAMSV_WRITE_BITS(sv_dev->base + REG_CAMSV_CLK_EN,
+		CAMSV_CLK_EN, IMGO_DP_CK_EN, 0);
+
+	return ret;
+}
+
+int ut_mtk_cam_sv_dmao_disable(
+	struct device *dev)
+{
+	int ret = 0;
+	struct mtk_ut_camsv_device *sv_dev = dev_get_drvdata(dev);
+
+	CAMSV_WRITE_BITS(sv_dev->base + REG_CAMSV_MODULE_EN,
+		CAMSV_MODULE_EN, IMGO_EN, 0);
+
+	return ret;
+}
+
+int ut_mtk_cam_sv_fbc_disable(
+	struct device *dev)
+{
+	int ret = 0;
+	struct mtk_ut_camsv_device *sv_dev = dev_get_drvdata(dev);
+
+	CAMSV_WRITE_REG(sv_dev->base + REG_CAMSV_FBC_IMGO_CTL1, 0);
+
+	return ret;
+}
+
+int ut_mtk_cam_sv_toggle_db(
+	struct device *dev)
+{
+	int ret = 0;
+	struct mtk_ut_camsv_device *sv_dev = dev_get_drvdata(dev);
+
+	CAMSV_WRITE_BITS(sv_dev->base + REG_CAMSV_CLK_EN,
+		CAMSV_CLK_EN, TG_DP_CK_EN, 1);
+	CAMSV_WRITE_BITS(sv_dev->base + REG_CAMSV_CLK_EN,
+		CAMSV_CLK_EN, PAK_DP_CK_EN, 1);
+	CAMSV_WRITE_BITS(sv_dev->base + REG_CAMSV_CLK_EN,
+		CAMSV_CLK_EN, IMGO_DP_CK_EN, 1);
+
+	CAMSV_WRITE_BITS(sv_dev->base + REG_CAMSV_MODULE_EN,
+		CAMSV_MODULE_EN, DB_EN, 0);
+	CAMSV_WRITE_BITS(sv_dev->base + REG_CAMSV_MODULE_EN,
+		CAMSV_MODULE_EN, DB_EN, 1);
+
+	return ret;
+}
+
+static int ut_camsv_initialize(struct device *dev, void *ext_params)
+{
+	return 0;
+}
+
+static int ut_camsv_reset(struct device *dev)
+{
+	ut_sv_reset(dev);
+	return 0;
+}
+
+static int ut_camsv_s_stream(struct device *dev, int on)
+{
+	int ret = 0;
+
+	dev_info(dev, "%s: %s\n", __func__, on ? "on" : "off");
+
+	if (on)
+		ret = ut_mtk_cam_sv_top_enable(dev);
+	else {
+		ret = ut_mtk_cam_sv_top_disable(dev) ||
+			ut_mtk_cam_sv_fbc_disable(dev) ||
+			ut_mtk_cam_sv_dmao_disable(dev) ||
+			ut_mtk_cam_sv_tg_disable(dev);
+	}
+
+	return ret;
+}
+
+static int ut_camsv_dev_config(struct device *dev,
+	struct mtkcam_ipi_input_param *cfg_in_param)
+{
+	int ret = 0;
+
+	ret = ut_mtk_cam_sv_tg_config(dev, cfg_in_param) ||
+		ut_mtk_cam_sv_top_config(dev, cfg_in_param) ||
+		ut_mtk_cam_sv_dmao_config(dev, cfg_in_param) ||
+		ut_mtk_cam_sv_fbc_config(dev, cfg_in_param) ||
+		ut_mtk_cam_sv_tg_enable(dev, cfg_in_param) ||
+		ut_mtk_cam_sv_dmao_enable(dev, cfg_in_param) ||
+		ut_mtk_cam_sv_fbc_enable(dev, cfg_in_param) ||
+		ut_mtk_cam_sv_toggle_db(dev);
+
+	return ret;
+}
+
+static void ut_camsv_set_ops(struct device *dev)
+{
+	struct mtk_ut_camsv_device *sv_dev = dev_get_drvdata(dev);
+
+	sv_dev->ops.initialize = ut_camsv_initialize;
+	sv_dev->ops.reset = ut_camsv_reset;
+	sv_dev->ops.s_stream = ut_camsv_s_stream;
+	sv_dev->ops.dev_config = ut_camsv_dev_config;
+}
+
+static int mtk_ut_camsv_component_bind(struct device *dev,
+				     struct device *master, void *data)
+{
+	struct mtk_ut_camsv_device *sv_dev = dev_get_drvdata(dev);
+	struct mtk_cam_ut *ut = data;
+	struct ut_event evt;
+
+	dev_info(dev, "%s\n", __func__);
+
+	if (!data) {
+		dev_info(dev, "no master data\n");
+		return -1;
+	}
+
+	if (!ut->camsv) {
+		dev_info(dev, "no camsv arr, num of camsv %d\n", ut->num_camsv);
+		return -1;
+	}
+	ut->camsv[sv_dev->id] = dev;
+
+	evt.mask = EVENT_SV_SOF;
+	add_listener(&sv_dev->event_src, &ut->listener, evt);
+
+	return 0;
+}
+
+static void mtk_ut_camsv_component_unbind(struct device *dev,
+					struct device *master, void *data)
+{
+	struct mtk_ut_camsv_device *sv_dev = dev_get_drvdata(dev);
+	struct mtk_cam_ut *ut = data;
+
+	dev_dbg(dev, "%s\n", __func__);
+	ut->camsv[sv_dev->id] = NULL;
+	remove_listener(&sv_dev->event_src, &ut->listener);
+}
+
+static const struct component_ops mtk_ut_camsv_component_ops = {
+	.bind = mtk_ut_camsv_component_bind,
+	.unbind = mtk_ut_camsv_component_unbind,
+};
+
+static irqreturn_t mtk_ut_camsv_irq(int irq, void *data)
+{
+	struct mtk_ut_camsv_device *camsv = data;
+	struct ut_event event;
+	unsigned int irq_status, fbc_imgo_ctl2;
+
+	irq_status = readl_relaxed(camsv->base + REG_CAMSV_INT_STATUS);
+	fbc_imgo_ctl2 = readl_relaxed(camsv->base + REG_CAMSV_FBC_IMGO_CTL2);
+
+	event.mask = 0;
+
+	if (irq_status & CAMSV_INT_TG_SOF_INT_ST)
+		event.mask |= EVENT_SV_SOF;
+
+	if (event.mask && camsv->id == 0) {
+		dev_dbg(camsv->dev, "send event 0x%x\n", event.mask);
+		send_event(&camsv->event_src, event);
+	}
+
+	dev_info(camsv->dev, "irq_status:0x%x/fbc_imgo_ctl2:0x%x",
+		irq_status, fbc_imgo_ctl2);
+
+	return IRQ_HANDLED;
+}
+
+static int mtk_ut_camsv_of_probe(struct platform_device *pdev,
+			    struct mtk_ut_camsv_device *camsv)
+{
+	struct device *dev = &pdev->dev;
+	struct resource *res;
+	int irq, ret;
+	int i;
+
+	ret = of_property_read_u32(dev->of_node, "mediatek,camsv-id",
+				   &camsv->id);
+	dev_info(dev, "id = %d\n", camsv->id);
+	if (ret) {
+		dev_info(dev, "missing camsvid property\n");
+		return ret;
+	}
+
+	/* base outer register */
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		dev_info(dev, "failed to get mem\n");
+		return -ENODEV;
+	}
+
+	camsv->base = devm_ioremap_resource(dev, res);
+	if (IS_ERR(camsv->base)) {
+		dev_info(dev, "failed to map register base\n");
+		return PTR_ERR(camsv->base);
+	}
+	dev_dbg(dev, "camsv, map_addr=0x%pK\n", camsv->base);
+
+	/* base inner register */
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 1);
+	if (!res) {
+		dev_info(dev, "failed to get mem\n");
+		return -ENODEV;
+	}
+
+	camsv->base_inner = devm_ioremap_resource(dev, res);
+	if (IS_ERR(camsv->base_inner)) {
+		dev_info(dev, "failed to map register inner base\n");
+		return PTR_ERR(camsv->base_inner);
+	}
+
+	irq = platform_get_irq(pdev, 0);
+	if (irq < 0) {
+		dev_info(dev, "failed to get irq\n");
+		return -ENODEV;
+	}
+
+	ret = devm_request_irq(dev, irq, mtk_ut_camsv_irq, 0,
+			       dev_name(dev), camsv);
+	if (ret) {
+		dev_info(dev, "failed to request irq=%d\n", irq);
+		return ret;
+	}
+	dev_dbg(dev, "registered irq=%d\n", irq);
+
+	camsv->num_clks = of_count_phandle_with_args(
+		pdev->dev.of_node, "clocks", "#clock-cells");
+	dev_info(dev, "clk_num:%d\n", camsv->num_clks);
+
+	if (camsv->num_clks) {
+		camsv->clks = devm_kcalloc(dev, camsv->num_clks,
+						sizeof(*camsv->clks), GFP_KERNEL);
+		if (!camsv->clks)
+			return -ENOMEM;
+	}
+
+	for (i = 0; i < camsv->num_clks; i++) {
+		camsv->clks[i] = of_clk_get(pdev->dev.of_node, i);
+		if (IS_ERR(camsv->clks[i])) {
+			dev_info(dev, "failed to get clk %d\n", i);
+			return -ENODEV;
+		}
+	}
+
+	return 0;
+}
+
+static int mtk_ut_camsv_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct mtk_ut_camsv_device *camsv;
+	int ret;
+
+	dev_info(dev, "%s\n", __func__);
+
+	camsv = devm_kzalloc(dev, sizeof(*camsv), GFP_KERNEL);
+	if (!camsv)
+		return -ENOMEM;
+
+	camsv->dev = dev;
+	dev_set_drvdata(dev, camsv);
+
+	ret = mtk_ut_camsv_of_probe(pdev, camsv);
+	if (ret)
+		return ret;
+
+	init_event_source(&camsv->event_src);
+	ut_camsv_set_ops(dev);
+
+	pm_runtime_enable(dev);
+
+	ret = component_add(dev, &mtk_ut_camsv_component_ops);
+	if (ret)
+		return ret;
+
+	dev_info(dev, "%s: success\n", __func__);
+	return 0;
+}
+
+static int mtk_ut_camsv_remove(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct mtk_ut_camsv_device *camsv = dev_get_drvdata(dev);
+	int i;
+
+	dev_info(dev, "%s\n", __func__);
+
+	for (i = 0; i < camsv->num_clks; i++) {
+		if (camsv->clks[i])
+			clk_put(camsv->clks[i]);
+	}
+
+	pm_runtime_disable(dev);
+
+	component_del(dev, &mtk_ut_camsv_component_ops);
+	return 0;
+}
+
+static int mtk_ut_camsv_pm_suspend(struct device *dev)
+{
+	dev_dbg(dev, "- %s\n", __func__);
+	return 0;
+}
+
+static int mtk_ut_camsv_pm_resume(struct device *dev)
+{
+	dev_dbg(dev, "- %s\n", __func__);
+	return 0;
+}
+
+static int mtk_ut_camsv_runtime_suspend(struct device *dev)
+{
+	struct mtk_ut_camsv_device *camsv = dev_get_drvdata(dev);
+	int i;
+
+	for (i = 0; i < camsv->num_clks; i++)
+		clk_disable_unprepare(camsv->clks[i]);
+
+	return 0;
+}
+
+static int mtk_ut_camsv_runtime_resume(struct device *dev)
+{
+	struct mtk_ut_camsv_device *camsv = dev_get_drvdata(dev);
+	int i;
+
+	for (i = 0; i < camsv->num_clks; i++)
+		clk_prepare_enable(camsv->clks[i]);
+
+	return 0;
+}
+
+static const struct dev_pm_ops mtk_ut_camsv_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(mtk_ut_camsv_pm_suspend,
+							mtk_ut_camsv_pm_resume)
+	SET_RUNTIME_PM_OPS(mtk_ut_camsv_runtime_suspend,
+						mtk_ut_camsv_runtime_resume,
+						NULL)
+};
+
+static const struct of_device_id mtk_ut_camsv_of_ids[] = {
+	{.compatible = "mediatek,camsv",},
+	{}
+};
+
+MODULE_DEVICE_TABLE(of, mtk_ut_camsv_of_ids);
+
+struct platform_driver mtk_ut_camsv_driver = {
+	.probe   = mtk_ut_camsv_probe,
+	.remove  = mtk_ut_camsv_remove,
+	.driver  = {
+		.name  = "mtk-cam camsv-ut",
+		.of_match_table = of_match_ptr(mtk_ut_camsv_of_ids),
+		.pm     = &mtk_ut_camsv_pm_ops,
+	}
+};
+
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/camsys/unit_test/mtk_cam_ut-engines.h b/drivers/media/platform/mediatek/isp/isp_7x/camsys/unit_test/mtk_cam_ut-engines.h
new file mode 100644
index 0000000000000000000000000000000000000000..c7fd9812207012026a36113d27198f1827767cb1
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/camsys/unit_test/mtk_cam_ut-engines.h
@@ -0,0 +1,207 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2021 MediaTek Inc.
+ */
+
+#ifndef __MTK_CAM_UT_ENGINES_H
+#define __MTK_CAM_UT_ENGINES_H
+
+#include "mtk_cam_ut-event.h"
+
+struct engine_ops {
+	/* test mdl, optional */
+	int (*set_size)(struct device *dev,
+			int width, int height,
+			int pixmode_lg2,
+			int pattern,
+			int seninf_idx,
+			int tg_idx);
+
+	int (*initialize)(struct device *dev, void *ext_params);
+	int (*reset)(struct device *dev);
+	int (*s_stream)(struct device *dev, int on);
+	int (*apply_cq)(struct device *dev,
+		dma_addr_t cq_addr, unsigned int cq_size, unsigned int cq_offset,
+		unsigned int sub_cq_size,
+		unsigned int sub_cq_offset);
+	int (*dev_config)(struct device *dev,
+		struct mtkcam_ipi_input_param *cfg_in_param);
+};
+
+#define CALL_ENGINE_OPS(dev, ops, ...) \
+	((dev && dev->ops) ? dev.ops(dev, ##__VA_ARGS__) : -EINVAL)
+
+struct ut_raw_status {
+	/* raw INT1~7 */
+	u32 irq;
+	u32 wdma;
+	u32 rdma;
+	u32 drop;
+	u32 ofl;
+	u32 cq_done;
+	u32 cq_done2;
+
+};
+
+struct ut_raw_statusx {
+	/* raw INT1~7 */
+	u32 irq;
+	u32 wdma;
+	u32 rdma;
+	u32 drop;
+	u32 ofl;
+	u32 cq_done;
+	u32 cq_done2;
+
+};
+
+struct ut_raw_debug_csr {
+	/* CQ INT1~7 */
+	u32 cq_sub1_addr;
+	u32 cq_sub2_addr;
+	u32 cq_sub1_szie;
+	u32 cq_sub2_szie;
+
+	/* DMAO */
+	u32 imgo_addr;
+	u32 aao_addr;
+
+    /* FBC */
+	u32 fbc_imgo_ctl2;
+	u32 fbc_aao_ctl2;
+	u32 fbc_aaho_ctl2;
+
+	/* CQ */
+	u32 cq_en;
+	u32 sub_cq_en;
+
+	/* CTL */
+	u32 sw_pass1_done;
+	u32 sw_sub_ctl;
+
+};
+
+enum RAW_STREAMON_TYPE {
+	STREAM_FROM_TG,
+	STREAM_FROM_RAWI_R2,
+	STREAM_FROM_RAWI_R5,
+	STREAM_FROM_RAWI_R6,
+};
+
+struct mtk_ut_raw_initial_params {
+	int subsample;
+	int streamon_type;
+	int hardware_scenario;
+};
+
+struct mtk_ut_raw_device {
+	struct device *dev;
+	unsigned int id;
+	void __iomem *base;
+	void __iomem *base_inner;
+	void __iomem *yuv_base;
+	unsigned int num_clks;
+	struct clk **clks;
+
+	struct ut_event_source event_src;
+	struct engine_ops ops;
+
+	int is_subsample;
+	int is_initial_cq;
+	int cq_done_mask; /* [0]: main, [1]: sub */
+	int hardware_scenario;
+
+};
+
+#define CALL_RAW_OPS(dev, op, ...) \
+{\
+	struct mtk_ut_raw_device *drvdata = dev_get_drvdata(dev);\
+	((dev && drvdata->ops.op) ? drvdata->ops.op(dev, ##__VA_ARGS__) : \
+	 -EINVAL);\
+}
+
+struct ut_yuv_status {
+	/* yuv INT 1/2/4/5 */
+	u32 irq;
+	u32 wdma;
+	u32 drop;
+	u32 ofl;
+};
+
+struct ut_yuv_statusx {
+	/* yuv INT 1/2/4/5 */
+	u32 irq;
+	u32 wdma;
+	u32 drop;
+	u32 ofl;
+};
+
+struct ut_yuv_debug_csr {
+	/* DMAO */
+	u32 yuvo_r1_addr;
+	u32 yuvo_r3_addr;
+
+    /* FBC */
+	u32 fbc_yuvo_r1ctl2;
+	u32 fbc_yuvo_r3ctl2;
+};
+
+struct mtk_ut_yuv_device {
+	struct device *dev;
+	unsigned int id;
+	void __iomem *base;
+	unsigned int num_clks;
+	struct clk **clks;
+
+	struct engine_ops ops;
+};
+
+#define CALL_YUV_OPS(dev, op, ...) \
+{\
+	struct mtk_ut_yuv_device *drvdata = dev_get_drvdata(dev);\
+	((dev && drvdata->ops.op) ? drvdata->ops.op(dev, ##__VA_ARGS__) : \
+	 -EINVAL);\
+}
+
+struct mtk_ut_camsv_device {
+	struct device *dev;
+	unsigned int id;
+	void __iomem *base;
+	void __iomem *base_inner;
+	unsigned int num_clks;
+	struct clk **clks;
+
+	struct ut_event_source event_src;
+	struct engine_ops ops;
+};
+
+#define CALL_CAMSV_OPS(dev, op, ...) \
+{\
+	struct mtk_ut_camsv_device *camsv = dev_get_drvdata(dev);\
+	((dev && camsv->ops.op) ? camsv->ops.op(dev, ##__VA_ARGS__) : -EINVAL);\
+}
+
+struct mtk_ut_seninf_device {
+	struct device *dev;
+	void __iomem *base;
+
+	unsigned int num_clks;
+	struct clk **clks;
+
+	struct engine_ops ops;
+};
+
+#define CALL_SENINF_OPS(dev, op, ...) \
+{\
+	struct mtk_ut_seninf_device *seninf = dev_get_drvdata(dev);\
+	((dev && seninf->ops.op) ? seninf->ops.op(dev, ##__VA_ARGS__) : -EINVAL);\
+}
+
+extern struct platform_driver mtk_ut_raw_driver;
+extern struct platform_driver mtk_ut_yuv_driver;
+extern struct platform_driver mtk_ut_camsv_driver;
+extern struct platform_driver mtk_ut_seninf_driver;
+#define WITH_LARB_DRIVER 1
+extern struct platform_driver mtk_ut_larb_driver;
+
+#endif /* __MTK_CAM_UT_ENGINES_H */
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/camsys/unit_test/mtk_cam_ut-event.h b/drivers/media/platform/mediatek/isp/isp_7x/camsys/unit_test/mtk_cam_ut-event.h
new file mode 100644
index 0000000000000000000000000000000000000000..1a1dfb87cba3cf2f5d8185d9a9fba718e423b3f3
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/camsys/unit_test/mtk_cam_ut-event.h
@@ -0,0 +1,102 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2021 MediaTek Inc.
+ */
+
+#ifndef __MTK_CAM_UT_EVENT_H
+#define __MTK_CAM_UT_EVENT_H
+
+#include <linux/list.h>
+#include <linux/slab.h>
+
+struct ut_event {
+	int	mask;
+};
+
+struct ut_event_source;
+struct ut_event_listener {
+	void (*on_notify)(struct ut_event_listener *listener,
+			  struct ut_event_source *src,
+			  struct ut_event event);
+};
+
+struct ut_event_linstener_entry {
+	struct ut_event_listener *listener;
+	struct ut_event	filter;
+	struct list_head list;
+};
+
+struct ut_event_source {
+	struct list_head listeners;
+};
+
+static inline void init_event_source(struct ut_event_source *src)
+{
+	WARN_ON(!src);
+
+	INIT_LIST_HEAD(&src->listeners);
+};
+
+static inline void add_listener(struct ut_event_source *src,
+				struct ut_event_listener *listener,
+				struct ut_event event)
+{
+	struct ut_event_linstener_entry *entry;
+
+	WARN_ON(!src || !listener);
+
+	entry = kzalloc(sizeof(*entry), GFP_KERNEL);
+	WARN_ON(!entry);
+
+	entry->listener = listener;
+	entry->filter = event;
+
+	list_add_tail(&entry->list, &src->listeners);
+}
+
+static inline void remove_listener(struct ut_event_source *src,
+				   struct ut_event_listener *listener)
+{
+	struct ut_event_linstener_entry *entry;
+
+	WARN_ON(!src || !listener);
+
+	list_for_each_entry(entry, &src->listeners, list) {
+		if (entry->listener == listener) {
+			list_del(&entry->list);
+			kfree(entry);
+			break;
+		}
+	}
+}
+
+static inline void send_event(struct ut_event_source *src,
+			      struct ut_event event)
+{
+	struct ut_event_linstener_entry *entry;
+	struct ut_event masked_event;
+
+	WARN_ON(!src);
+
+	list_for_each_entry(entry, &src->listeners, list) {
+
+		WARN_ON(!entry->listener);
+		masked_event.mask = entry->filter.mask & event.mask;
+
+		//pr_info("entry with mask 0x%x, f_notify %x\n",
+		//	entry->filter.mask, entry->on_notify);
+		if (masked_event.mask && entry->listener->on_notify)
+			entry->listener->on_notify(entry->listener, src,
+						   masked_event);
+	}
+}
+
+/* events */
+
+#define EVENT_SOF		BIT(0)
+#define EVENT_CQ_DONE		BIT(1)
+#define EVENT_SW_P1_DONE	BIT(2)
+#define EVENT_CQ_MAIN_TRIG_DLY	BIT(3)
+#define EVENT_SV_SOF		BIT(4)
+
+#endif /* __MTK_CAM_UT_EVENT_H */
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/camsys/unit_test/mtk_cam_ut-seninf.c b/drivers/media/platform/mediatek/isp/isp_7x/camsys/unit_test/mtk_cam_ut-seninf.c
new file mode 100644
index 0000000000000000000000000000000000000000..5ae6b683edbf96e2523e1002228872f820e340fb
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/camsys/unit_test/mtk_cam_ut-seninf.c
@@ -0,0 +1,288 @@
+// SPDX-License-Identifier: GPL-2.0
+//
+// Copyright (c) 2021 MediaTek Inc.
+
+#include <linux/clk.h>
+#include <linux/component.h>
+#include <linux/dma-mapping.h>
+#include <linux/interrupt.h>
+#include <linux/iopoll.h>
+#include <linux/module.h>
+#include <linux/of_platform.h>
+#include <linux/of.h>
+#include <linux/platform_device.h>
+#include <linux/pm_runtime.h>
+
+#include "mtk_cam_ut.h"
+#include "mtk_cam_ut-engines.h"
+#ifdef ISP7_1
+#include "mtk_cam_regs_mt8188.h"
+#else
+#include "mtk_cam_regs_mt8195.h"
+#endif
+
+static unsigned int testmdl_hblank = 0x80;
+module_param(testmdl_hblank, int, 0644);
+MODULE_PARM_DESC(testmdl_hblank, "h-blanking for testmdl");
+
+/* seninf */
+static int get_test_hmargin(int w, int h, int clk_cnt, int clk_mhz, int fps)
+{
+	int target_h = clk_mhz * (1000000/fps) / w * max(8/(clk_cnt+1), 1);
+
+	return max(target_h - h, 0x80);
+}
+
+static int ut_seninf_set_testmdl(struct device *dev,
+				 int width, int height,
+				 int pixmode_lg2,
+				 int pattern,
+				 int seninf_idx,
+				 int tg_idx)
+{
+	struct mtk_ut_seninf_device *seninf = dev_get_drvdata(dev);
+	void __iomem *base = seninf->base + seninf_idx * SENINF_OFFSET;
+	const u16 dummy_pxl = 0x80, h_margin = 0x80;
+	const u8 clk_div_cnt = (8 >> pixmode_lg2) - 1;
+	const u16 dum_vsync = get_test_hmargin(width + dummy_pxl,
+					      height + h_margin,
+					      clk_div_cnt, 416, 30);
+	unsigned int cam_mux_ctrl;
+	void __iomem *cam_mux_ctrl_addr;
+
+	dev_info(dev, "%s width %d x height %d dum_vsync %d pixmode_lg2 %d clk_div_cnt %d\n",
+		 __func__, width, height, dum_vsync,
+		 pixmode_lg2, clk_div_cnt);
+	dev_info(dev, "%s seninf_idx %d tg_idx %d\n", __func__, seninf_idx, tg_idx);
+
+	/* test mdl */
+	writel_relaxed((height + h_margin) << 16 | width,
+		       ISP_SENINF_TM_SIZE(base));
+	writel_relaxed(clk_div_cnt, ISP_SENINF_TM_CLK(base));
+	writel_relaxed(dum_vsync << 16 | dummy_pxl, ISP_SENINF_TM_DUM(base));
+	writel_relaxed(pattern << 4 | 0x1, ISP_SENINF_TM_CTL(base));
+	writel_relaxed(0x1f << 16 | pixmode_lg2 << 8 | 0x1,
+		       ISP_SENINF_MUX_CTRL_1(base));
+	writel_relaxed(0x1, ISP_SENINF_MUX_CTRL_0(base));
+	writel_relaxed(0x1, ISP_SENINF_TSETMDL_CTRL(base));
+	writel_relaxed(0x1, ISP_SENINF_CTRL(base));
+
+	/* cam mux ctrl */
+	cam_mux_ctrl_addr = ISP_SENINF_CAM_MUX_PCSR_0(seninf->base) + tg_idx * 0x4;
+	cam_mux_ctrl = readl_relaxed(cam_mux_ctrl_addr);
+	cam_mux_ctrl &= ~(0xFF << ((tg_idx % 4) * 8));
+	cam_mux_ctrl |= seninf_idx << ((tg_idx % 4) * 8);
+	writel_relaxed(cam_mux_ctrl, cam_mux_ctrl_addr);
+	/* make sure all the seninf setting take effect */
+	wmb();
+
+	return 0;
+}
+
+static int ut_seninf_reset(struct device *dev)
+{
+	struct mtk_ut_seninf_device *seninf = dev_get_drvdata(dev);
+	void __iomem *cam_mux_ctrl_addr;
+	int i;
+	unsigned int cam_mux_ctrl;
+
+	dev_info(dev, "%s\n", __func__);
+
+	for (i = 0; i < camsys_tg_max; i++) {
+		cam_mux_ctrl_addr = ISP_SENINF_CAM_MUX_PCSR_0(seninf->base) + i * 0x4;
+		cam_mux_ctrl = readl_relaxed(cam_mux_ctrl_addr);
+		cam_mux_ctrl &= 0xFFFF7F7F;
+		writel_relaxed(cam_mux_ctrl, cam_mux_ctrl_addr);
+	}
+	/* make sure all the seninf setting take effect */
+	wmb();
+
+	return 0;
+}
+
+static void ut_seninf_set_ops(struct device *dev)
+{
+	struct mtk_ut_seninf_device *seninf = dev_get_drvdata(dev);
+
+	seninf->ops.set_size = ut_seninf_set_testmdl;
+	seninf->ops.reset = ut_seninf_reset;
+}
+
+static int mtk_ut_seninf_component_bind(struct device *dev,
+					struct device *master,
+					void *data)
+{
+	struct mtk_cam_ut *ut = data;
+
+	dev_dbg(dev, "%s\n", __func__);
+	ut->seninf = dev;
+
+	return 0;
+}
+
+static void mtk_ut_seninf_component_unbind(struct device *dev,
+					   struct device *master,
+					   void *data)
+{
+	struct mtk_cam_ut *ut = data;
+
+	dev_dbg(dev, "%s\n", __func__);
+	ut->seninf = NULL;
+}
+
+static const struct component_ops mtk_ut_seninf_component_ops = {
+	.bind = mtk_ut_seninf_component_bind,
+	.unbind = mtk_ut_seninf_component_unbind,
+};
+
+static int mtk_ut_seninf_of_probe(struct platform_device *pdev,
+			    struct mtk_ut_seninf_device *seninf)
+{
+	struct device *dev = &pdev->dev;
+	struct resource *res;
+	int i, clks;
+
+	/* base register */
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		dev_info(dev, "failed to get mem\n");
+		return -ENODEV;
+	}
+
+	seninf->base = devm_ioremap_resource(dev, res);
+	if (IS_ERR(seninf->base)) {
+		dev_info(dev, "failed to map register base\n");
+		return PTR_ERR(seninf->base);
+	}
+	dev_dbg(dev, "seninf, map_addr=0x%pK\n", seninf->base);
+
+	clks = of_count_phandle_with_args(pdev->dev.of_node,
+				"clocks", "#clock-cells");
+
+	seninf->num_clks = (clks == -ENOENT) ? 0:clks;
+	dev_info(dev, "clk_num:%d\n", seninf->num_clks);
+
+	if (seninf->num_clks) {
+		seninf->clks = devm_kcalloc(dev, seninf->num_clks,
+					    sizeof(*seninf->clks), GFP_KERNEL);
+		if (!seninf->clks)
+			return -ENODEV;
+	}
+
+	for (i = 0; i < seninf->num_clks; i++) {
+		seninf->clks[i] = of_clk_get(pdev->dev.of_node, i);
+		if (IS_ERR(seninf->clks[i])) {
+			dev_info(dev, "failed to get clk %d\n", i);
+			return -ENODEV;
+		}
+	}
+
+	return 0;
+}
+
+static int mtk_ut_seninf_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct mtk_ut_seninf_device *seninf;
+	int ret;
+
+	dev_info(dev, "%s\n", __func__);
+
+	seninf = devm_kzalloc(dev, sizeof(*seninf), GFP_KERNEL);
+	if (!seninf)
+		return -ENOMEM;
+
+	seninf->dev = dev;
+	dev_set_drvdata(dev, seninf);
+
+	ret = mtk_ut_seninf_of_probe(pdev, seninf);
+	if (ret)
+		return ret;
+
+	ut_seninf_set_ops(dev);
+
+	pm_runtime_enable(dev);
+
+	ret = component_add(dev, &mtk_ut_seninf_component_ops);
+	if (ret)
+		return ret;
+
+	dev_info(dev, "%s: success\n", __func__);
+	return 0;
+}
+
+static int mtk_ut_seninf_remove(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct mtk_ut_seninf_device *seninf = dev_get_drvdata(dev);
+	int i;
+
+	dev_info(dev, "%s\n", __func__);
+
+	for (i = 0; i < seninf->num_clks; i++) {
+		if (seninf->clks[i])
+			clk_put(seninf->clks[i]);
+	}
+
+	pm_runtime_disable(dev);
+
+	component_del(dev, &mtk_ut_seninf_component_ops);
+	return 0;
+}
+
+static int mtk_ut_seninf_pm_suspend(struct device *dev)
+{
+	dev_dbg(dev, "- %s\n", __func__);
+	return 0;
+}
+
+static int mtk_ut_seninf_pm_resume(struct device *dev)
+{
+	dev_dbg(dev, "- %s\n", __func__);
+	return 0;
+}
+
+static int mtk_ut_seninf_runtime_suspend(struct device *dev)
+{
+	struct mtk_ut_seninf_device *seninf = dev_get_drvdata(dev);
+	int i;
+
+	for (i = 0; i < seninf->num_clks; i++)
+		clk_disable_unprepare(seninf->clks[i]);
+
+	return 0;
+}
+
+static int mtk_ut_seninf_runtime_resume(struct device *dev)
+{
+	struct mtk_ut_seninf_device *seninf = dev_get_drvdata(dev);
+	int i;
+
+	for (i = 0; i < seninf->num_clks; i++)
+		clk_prepare_enable(seninf->clks[i]);
+
+	return 0;
+}
+
+static const struct dev_pm_ops mtk_ut_seninf_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(mtk_ut_seninf_pm_suspend, mtk_ut_seninf_pm_resume)
+	SET_RUNTIME_PM_OPS(mtk_ut_seninf_runtime_suspend, mtk_ut_seninf_runtime_resume,
+			   NULL)
+};
+
+static const struct of_device_id mtk_ut_seninf_of_ids[] = {
+	{.compatible = "mediatek,seninf-core",},
+	{}
+};
+MODULE_DEVICE_TABLE(of, mtk_ut_seninf_of_ids);
+
+struct platform_driver mtk_ut_seninf_driver = {
+	.probe   = mtk_ut_seninf_probe,
+	.remove  = mtk_ut_seninf_remove,
+	.driver  = {
+		.name  = "mtk-cam seninf-ut",
+		.of_match_table = of_match_ptr(mtk_ut_seninf_of_ids),
+		.pm     = &mtk_ut_seninf_pm_ops,
+	}
+};
+
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/camsys/unit_test/mtk_cam_ut.c b/drivers/media/platform/mediatek/isp/isp_7x/camsys/unit_test/mtk_cam_ut.c
new file mode 100644
index 0000000000000000000000000000000000000000..2c0239e0d7eab1d667153e717e32c7062e49bca5
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/camsys/unit_test/mtk_cam_ut.c
@@ -0,0 +1,1353 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2021 MediaTek Inc.
+ * Author: Bibby Hsieh <bibby.hsieh@mediatek.com>
+ */
+
+#include <linux/cdev.h>
+#include <linux/clk.h>
+#include <linux/compat.h>
+#include <linux/component.h>
+#include <linux/dma-buf.h>
+#include <linux/fs.h>
+#include <linux/ioport.h>
+#include <linux/interrupt.h>
+#include <linux/iopoll.h>
+#include <linux/irqreturn.h>
+#include <linux/kernel.h>
+//#include <linux/mtk_ccd_controls.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_irq.h>
+#include <linux/of_address.h>
+#include <linux/of_platform.h>
+//#include <linux/platform_data/mtk_ccd.h>
+#include <linux/platform_device.h>
+#include <linux/pm_domain.h>
+#include <linux/pm_runtime.h>
+#include <linux/remoteproc.h>
+//#include <linux/rpmsg/mtk_ccd_rpmsg.h>
+#include <linux/slab.h>
+#include <linux/uaccess.h>
+
+#include "mtk_cam_ut.h"
+#include "mtk_isp_ut_ioctl.h"
+#include "mtk_cam_ut-engines.h"
+
+#define CAM_DEV_NAME "mtk_cam_ut"
+
+static int debug_testmdl_pixmode = -1;
+module_param(debug_testmdl_pixmode, int, 0644);
+MODULE_PARM_DESC(debug_testmdl_pixmode, "fixed pixel mode for testmdl");
+
+static int apply_next_req(struct mtk_cam_ut *ut)
+{
+	struct mtk_cam_ut_buf_entry *buf_entry;
+	unsigned long flags;
+
+	spin_lock_irqsave(&ut->enque_list.lock, flags);
+	if (list_empty(&ut->enque_list.list)) {
+		dev_info(ut->dev, "no req to apply\n");
+		spin_unlock_irqrestore(&ut->enque_list.lock, flags);
+		return 0;
+	}
+
+	buf_entry = list_first_entry(&ut->enque_list.list,
+				     struct mtk_cam_ut_buf_entry, list_entry);
+	if (buf_entry->cq_buf.size == 0) {
+		dev_dbg(ut->dev, "Composer handler is not finished yet\n");
+		spin_unlock_irqrestore(&ut->enque_list.lock, flags);
+		return 0;
+	}
+
+	if (!ut->with_testmdl) {
+		spin_lock_irqsave(&ut->spinlock_irq, flags);
+		if (!ut->m2m_available) {
+			dev_info(ut->dev, "%s: m2m not avialable\n");
+			spin_unlock_irqrestore(&ut->spinlock_irq, flags);
+			return 0;
+		}
+
+		ut->m2m_available = 0;
+		spin_unlock_irqrestore(&ut->spinlock_irq, flags);
+	}
+
+	list_del(&buf_entry->list_entry);
+	ut->enque_list.cnt--;
+	spin_unlock_irqrestore(&ut->enque_list.lock, flags);
+
+	if (ut->hardware_scenario == MTKCAM_IPI_HW_PATH_ON_THE_FLY_RAWB) {
+		CALL_RAW_OPS(ut->raw[1], apply_cq,
+			     buf_entry->cq_buf.iova,
+			     buf_entry->cq_buf.size,
+			     buf_entry->cq_offset,
+			     buf_entry->sub_cq_size,
+			     buf_entry->sub_cq_offset);
+	} else {
+		CALL_RAW_OPS(ut->raw[0], apply_cq,
+			     buf_entry->cq_buf.iova,
+			     buf_entry->cq_buf.size,
+			     buf_entry->cq_offset,
+			     buf_entry->sub_cq_size,
+			     buf_entry->sub_cq_offset);
+	}
+
+	spin_lock_irqsave(&ut->processing_list.lock, flags);
+	list_add_tail(&buf_entry->list_entry, &ut->processing_list.list);
+	ut->processing_list.cnt++;
+	spin_unlock_irqrestore(&ut->processing_list.lock, flags);
+
+	return 0;
+}
+
+static int handle_req_done(struct mtk_cam_ut *ut)
+{
+	struct mtk_cam_ut_buf_entry *buf_entry;
+
+	spin_lock(&ut->processing_list.lock);
+	if (list_empty(&ut->processing_list.list)) {
+		dev_info(ut->dev, "Duplicate SW P1 DONE, should not happen\n");
+		spin_unlock(&ut->processing_list.lock);
+		return 0;
+	}
+
+	buf_entry = list_first_entry(&ut->processing_list.list,
+				     struct mtk_cam_ut_buf_entry, list_entry);
+	list_del(&buf_entry->list_entry);
+	ut->processing_list.cnt--;
+	spin_unlock(&ut->processing_list.lock);
+
+	spin_lock(&ut->deque_list.lock);
+	list_add_tail(&buf_entry->list_entry, &ut->deque_list.list);
+	ut->deque_list.cnt++;
+	spin_unlock(&ut->deque_list.lock);
+
+	wake_up(&ut->done_wq);
+	return 0;
+}
+
+static int handle_req_done_m2m(struct mtk_cam_ut *ut)
+{
+	unsigned long flags;
+
+	handle_req_done(ut);
+
+	spin_lock_irqsave(&ut->spinlock_irq, flags);
+	ut->m2m_available = 1;
+	spin_unlock_irqrestore(&ut->spinlock_irq, flags);
+
+	apply_next_req(ut);
+	return 0;
+}
+
+static int on_ipi_composed(struct mtk_cam_ut *ut)
+{
+	return  0;
+}
+
+static int apply_req_on_composed_once(struct mtk_cam_ut *ut)
+{
+	struct mtk_ut_raw_initial_params raw_params;
+
+	raw_params.subsample = ut->subsample;
+	raw_params.streamon_type = STREAM_FROM_TG;
+	raw_params.hardware_scenario = ut->hardware_scenario;
+
+	CALL_RAW_OPS(ut->raw[0], initialize, &raw_params);
+	CALL_RAW_OPS(ut->raw[1], initialize, &raw_params);
+	CALL_RAW_OPS(ut->raw[2], initialize, &raw_params);
+
+	ut->hdl.on_ipi_composed = on_ipi_composed;
+	return apply_next_req(ut);
+}
+
+static int apply_req_on_composed_m2m_once(struct mtk_cam_ut *ut)
+{
+	struct mtk_ut_raw_initial_params raw_params;
+
+	raw_params.subsample = ut->subsample;
+	raw_params.streamon_type = STREAM_FROM_TG;
+
+	if (!ut->with_testmdl) {
+		if (ut->hardware_scenario == MTKCAM_IPI_HW_PATH_OFFLINE_STAGGER) {
+			if (ut->main_rawi == MTKCAM_IPI_RAW_RAWI_6)
+				raw_params.streamon_type = STREAM_FROM_RAWI_R6;
+			else if (ut->main_rawi == MTKCAM_IPI_RAW_RAWI_5)
+				raw_params.streamon_type = STREAM_FROM_RAWI_R5;
+			else {
+				dev_info(ut->dev, "can't find correct main rawi\n");
+				return 0;
+			}
+		} else
+			raw_params.streamon_type = STREAM_FROM_RAWI_R2;
+	}
+
+	dev_info(ut->dev,
+				 "streamon_type %d\n", raw_params.streamon_type);
+
+	CALL_RAW_OPS(ut->raw[0], initialize, &raw_params);
+	CALL_RAW_OPS(ut->raw[1], initialize, &raw_params);
+	CALL_RAW_OPS(ut->raw[2], initialize, &raw_params);
+
+	ut->hdl.on_ipi_composed = apply_next_req;
+	return apply_next_req(ut);
+}
+
+static int streamon_on_cqdone_once(struct mtk_cam_ut *ut)
+{
+	int i;
+
+	if (ut->hardware_scenario == MTKCAM_IPI_HW_PATH_ON_THE_FLY_RAWB)
+		CALL_RAW_OPS(ut->raw[1], s_stream, 1)
+	else if (ut->hardware_scenario != MTKCAM_IPI_HW_PATH_OFFLINE_SRT_DCIF_STAGGER)
+		CALL_RAW_OPS(ut->raw[0], s_stream, 1)
+
+	for (i = ut->is_dcif_camsv - 1; i >= 0; i--)
+		CALL_CAMSV_OPS(ut->camsv[i], s_stream, 1);
+
+	ut->hdl.on_isr_cq_done = NULL;
+	return 0;
+}
+
+static int trigger_rawi(struct mtk_cam_ut *ut)
+{
+	CALL_RAW_OPS(ut->raw[0], s_stream, 1);
+	return 0;
+}
+
+static void setup_hanlder(struct mtk_cam_ut *ut)
+{
+	memset(&ut->hdl, 0, sizeof(struct mtk_cam_ut_event_handler));
+
+	dev_info(ut->dev,
+				 "ut->with_testmdl %d\n", ut->with_testmdl);
+
+	if (ut->with_testmdl) {
+		if (!ut->is_dcif_camsv) {
+			ut->hdl.on_ipi_composed = apply_req_on_composed_once;
+			ut->hdl.on_isr_sof = apply_next_req;
+			ut->hdl.on_isr_sv_sof = NULL;
+			ut->hdl.on_isr_cq_done = streamon_on_cqdone_once;
+			ut->hdl.on_isr_frame_done = handle_req_done;
+		} else {
+			ut->hdl.on_ipi_composed = apply_req_on_composed_once;
+			ut->hdl.on_isr_sof = NULL;
+			ut->hdl.on_isr_sv_sof = apply_next_req;
+			ut->hdl.on_isr_cq_done = streamon_on_cqdone_once;
+			ut->hdl.on_isr_frame_done = handle_req_done;
+		}
+	} else {
+		if (!ut->is_dcif_camsv) {
+			ut->hdl.on_ipi_composed = apply_req_on_composed_m2m_once;
+			ut->hdl.on_isr_sof = NULL;
+			ut->hdl.on_isr_sv_sof = NULL;
+			ut->hdl.on_isr_cq_done = trigger_rawi;
+			ut->hdl.on_isr_frame_done = handle_req_done_m2m;
+		} else {
+			dev_info(ut->dev,
+				 "dcif without testmdl: not supported yet\n");
+		}
+	}
+}
+
+static int cam_of_rproc(struct mtk_cam_ut *ut)
+{
+	struct device *dev = ut->dev;
+	int ret;
+
+	ret = of_property_read_u32(dev->of_node, "mediatek,ccd",
+				   &ut->rproc_phandle);
+	if (ret) {
+		dev_info(dev, "fail to get rproc_phandle:%d\n", ret);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int cam_composer_handler(struct rpmsg_device *rpdev, void *data,
+				int len, void *priv, u32 src)
+{
+	struct mtk_cam_ut *ut = (struct mtk_cam_ut *)priv;
+	struct device *dev = ut->dev;
+	struct mtkcam_ipi_event *ipi_msg;
+	struct mtk_cam_ut_buf_entry *buf_entry;
+	unsigned long flags;
+
+	ipi_msg = (struct mtkcam_ipi_event *)data;
+	if (!ipi_msg)
+		return -EINVAL;
+
+	if (len < offsetofend(struct mtkcam_ipi_event, ack_data)) {
+		dev_dbg(dev, "wrong IPI len:%d\n", len);
+		return -EINVAL;
+	}
+
+	if (ipi_msg->cmd_id != CAM_CMD_ACK ||
+		(ipi_msg->ack_data.ack_cmd_id != CAM_CMD_FRAME &&
+		ipi_msg->ack_data.ack_cmd_id != CAM_CMD_DESTROY_SESSION))
+		return -EINVAL;
+
+	if (ipi_msg->ack_data.ack_cmd_id == CAM_CMD_FRAME) {
+		dev_dbg(dev, "%s, ack_cmd_id = CAM_CMD_FRAME\n", __func__);
+
+		spin_lock_irqsave(&ut->enque_list.lock, flags);
+		buf_entry = list_first_entry(&ut->enque_list.list,
+				struct mtk_cam_ut_buf_entry, list_entry);
+		buf_entry->cq_buf.size =
+			ipi_msg->ack_data.frame_result.cq_desc_size;
+		buf_entry->cq_offset =
+			ipi_msg->ack_data.frame_result.cq_desc_offset;
+		buf_entry->sub_cq_size =
+			ipi_msg->ack_data.frame_result.sub_cq_desc_size;
+		buf_entry->sub_cq_offset =
+			ipi_msg->ack_data.frame_result.sub_cq_desc_offset;
+		spin_unlock_irqrestore(&ut->enque_list.lock, flags);
+
+		if (ut->hdl.on_ipi_composed)
+			ut->hdl.on_ipi_composed(ut);
+	}
+
+	return 0;
+}
+
+static int cam_composer_init(struct mtk_cam_ut *ut)
+{
+	struct device *dev = ut->dev;
+	struct mtk_ccd *ccd;
+	struct rproc_subdev *rpmsg_subdev;
+	struct rpmsg_channel_info *msg = &ut->rpmsg_channel;
+	int ret;
+
+	ut->rproc_handle = rproc_get_by_phandle(ut->rproc_phandle);
+	if (!ut->rproc_handle) {
+		dev_dbg(dev, "fail to get rproc_handle\n");
+		return -EINVAL;
+	}
+
+	ret = rproc_boot(ut->rproc_handle);
+	if (ret) {
+		dev_dbg(dev, "failed to rproc_boot:%d\n", ret);
+		goto fail_rproc_put;
+	}
+
+	ccd = (struct mtk_ccd *)ut->rproc_handle->priv;
+	rpmsg_subdev = ccd->rpmsg_subdev;
+	snprintf(msg->name, RPMSG_NAME_SIZE, "mtk-isp-unit-test\0\n");
+	msg->src = CCD_IPI_ISP_MAIN;
+	ut->rpmsg_dev = mtk_create_client_msgdevice(rpmsg_subdev, msg);
+	if (!ut->rpmsg_dev) {
+		ret = -EINVAL;
+		goto fail_shutdown;
+	}
+	ut->rpmsg_dev->rpdev.ept = rpmsg_create_ept(&ut->rpmsg_dev->rpdev,
+						    cam_composer_handler,
+						    ut, *msg);
+	if (IS_ERR(ut->rpmsg_dev->rpdev.ept)) {
+		ret = -EINVAL;
+		goto fail_shutdown;
+	}
+
+	return ret;
+fail_shutdown:
+	rproc_shutdown(ut->rproc_handle);
+fail_rproc_put:
+	rproc_put(ut->rproc_handle);
+	ut->rproc_handle = NULL;
+	return ret;
+}
+
+static void cam_composer_uninit(struct mtk_cam_ut *ut)
+{
+	struct mtk_ccd *ccd = ut->rproc_handle->priv;
+
+	mtk_destroy_client_msgdevice(ccd->rpmsg_subdev, &ut->rpmsg_channel);
+	ut->rpmsg_dev = NULL;
+	rproc_shutdown(ut->rproc_handle);
+	rproc_put(ut->rproc_handle);
+	ut->rproc_handle = NULL;
+}
+
+static void ut_event_on_notify(struct ut_event_listener *listener,
+			       struct ut_event_source *src,
+			       struct ut_event event)
+{
+	struct mtk_cam_ut *ut = container_of(listener, struct mtk_cam_ut, listener);
+	int mask = event.mask;
+
+	dev_dbg(ut->dev, "%s: event 0x%x\n", __func__, mask);
+
+	if ((mask & EVENT_SOF) && ut->hdl.on_isr_sof)
+		ut->hdl.on_isr_sof(ut);
+
+	if ((mask & EVENT_SV_SOF) && ut->hdl.on_isr_sv_sof)
+		ut->hdl.on_isr_sv_sof(ut);
+
+	if ((mask & EVENT_CQ_DONE) && ut->hdl.on_isr_cq_done)
+		ut->hdl.on_isr_cq_done(ut);
+
+	if ((mask & EVENT_SW_P1_DONE) && ut->hdl.on_isr_frame_done)
+		ut->hdl.on_isr_frame_done(ut);
+}
+
+static int dequeue_buffer(struct mtk_cam_ut *ut, unsigned int timeout_ms)
+{
+	struct mtk_cam_ut_buf_entry *buf_entry;
+	long timeout_jiff, ret;
+	unsigned long flags;
+
+	timeout_jiff = msecs_to_jiffies(timeout_ms);
+	ret = wait_event_interruptible_timeout(ut->done_wq,
+					       !list_empty(&ut->deque_list.list),
+					       timeout_jiff);
+	if (!ret) {
+		dev_info(ut->dev, "deque time=%ums out\n",
+			 timeout_ms);
+		return -1;
+	} else if (-ERESTARTSYS == ret) {
+		dev_info(ut->dev, "deque interrupted by signal\n");
+		return -1;
+	}
+
+	dev_info(ut->dev, "deque success, time left %ums\n",
+		 jiffies_to_msecs(ret));
+
+	spin_lock_irqsave(&ut->deque_list.lock, flags);
+	buf_entry = list_first_entry(&ut->deque_list.list,
+				     struct mtk_cam_ut_buf_entry,
+				     list_entry);
+	list_del(&buf_entry->list_entry);
+	ut->deque_list.cnt--;
+	spin_unlock_irqrestore(&ut->deque_list.lock, flags);
+	kfree(buf_entry);
+
+	return 0;
+}
+
+static long cam_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+	struct mtk_cam_ut *ut = filp->private_data;
+	struct device *dev = ut->dev;
+
+	switch (cmd) {
+	case ISP_UT_IOCTL_SET_TESTMDL: {
+		struct cam_ioctl_set_testmdl testmdl;
+		int pixel_mode;
+
+		ut->is_dcif_camsv = 0;
+		ut->with_testmdl = 0;
+
+		if (copy_from_user(&testmdl, (void *)arg,
+				   sizeof(struct cam_ioctl_set_testmdl)) != 0) {
+			dev_dbg(dev, "Fail to get testmdl parameter\n");
+			return -EFAULT;
+		}
+
+		pixel_mode = testmdl.pixmode_lg2;
+		if (debug_testmdl_pixmode >= 0) {
+			dev_info(dev, "DEBUG: set testmdl pixel mode (log2) %d\n",
+				debug_testmdl_pixmode);
+			pixel_mode = debug_testmdl_pixmode;
+		}
+
+		// update hardware scenario
+		ut->hardware_scenario = testmdl.hwScenario;
+
+		dev_info(dev, "testmdl.mode=%d testmdl.hwScenario=%d\n",
+			testmdl.mode, testmdl.hwScenario);
+		if (testmdl.mode == (u8)-1)
+			dev_info(dev, "without testmdl\n");
+		else {
+			ut->with_testmdl = 1;
+			// reset cam mux
+			CALL_SENINF_OPS(ut->seninf, reset);
+		}
+
+		if (testmdl.hwScenario == MTKCAM_IPI_HW_PATH_ON_THE_FLY_DCIF_STAGGER) {
+			if (testmdl.mode == stagger_3exp) {
+				ut->is_dcif_camsv = 2;
+				CALL_SENINF_OPS(ut->seninf, set_size,
+					   testmdl.width, testmdl.height,
+					   pixel_mode, testmdl.pattern,
+					   seninf_0, camsv_tg_0);
+				mdelay(1);
+				CALL_SENINF_OPS(ut->seninf, set_size,
+					   testmdl.width, testmdl.height,
+					   pixel_mode, testmdl.pattern,
+					   seninf_1, camsv_tg_1);
+				mdelay(1);
+				CALL_SENINF_OPS(ut->seninf, set_size,
+					   testmdl.width, testmdl.height,
+					   pixel_mode, testmdl.pattern,
+					   seninf_2, raw_tg_0);
+			} else if (testmdl.mode == stagger_2exp) {
+				ut->is_dcif_camsv = 1;
+				CALL_SENINF_OPS(ut->seninf, set_size,
+					   testmdl.width, testmdl.height,
+					   pixel_mode, testmdl.pattern,
+					   seninf_0, camsv_tg_0);
+				mdelay(1);
+				CALL_SENINF_OPS(ut->seninf, set_size,
+					   testmdl.width, testmdl.height,
+					   pixel_mode, testmdl.pattern,
+					   seninf_1, raw_tg_0);
+			}
+		} else if (testmdl.hwScenario == MTKCAM_IPI_HW_PATH_OFFLINE_SRT_DCIF_STAGGER) {
+			// temporarily support camsv_a1 + camsv_a2 + raw_a case
+			if (testmdl.mode == stagger_2exp) {
+				ut->is_dcif_camsv = 2;
+				CALL_SENINF_OPS(ut->seninf, set_size,
+					   testmdl.width, testmdl.height,
+					   pixel_mode, testmdl.pattern,
+					   seninf_0, camsv_tg_0);
+				mdelay(1);
+				CALL_SENINF_OPS(ut->seninf, set_size,
+					   testmdl.width, testmdl.height,
+					   pixel_mode, testmdl.pattern,
+					   seninf_1, camsv_tg_1);
+			} else if (testmdl.mode == normal) {
+				ut->is_dcif_camsv = 1;
+				CALL_SENINF_OPS(ut->seninf, set_size,
+					   testmdl.width, testmdl.height,
+					   pixel_mode, testmdl.pattern,
+					   seninf_0, camsv_tg_0);
+			}
+		} else if (testmdl.hwScenario == MTKCAM_IPI_HW_PATH_ON_THE_FLY_RAWB) {
+			if (ut->with_testmdl == 1) {
+				CALL_SENINF_OPS(ut->seninf, set_size,
+					   testmdl.width, testmdl.height,
+					   pixel_mode, testmdl.pattern,
+					   seninf_0, raw_tg_1);
+			}
+		} else {
+			if (ut->with_testmdl == 1) {
+				CALL_SENINF_OPS(ut->seninf, set_size,
+					   testmdl.width, testmdl.height,
+					   pixel_mode, testmdl.pattern,
+					   seninf_0, raw_tg_0);
+			}
+		}
+
+		return 0;
+	}
+	case ISP_UT_IOCTL_DEQUE: {
+		unsigned int timeout_ms;
+
+		if (copy_from_user(&timeout_ms, (void *)arg,
+				   sizeof(unsigned int)) != 0) {
+			dev_dbg(dev, "Fail to get deque info\n");
+			return -EFAULT;
+		}
+
+		dev_info(dev, "dequeue_buffer, timeout=%ums\n", timeout_ms);
+		if (dequeue_buffer(ut, timeout_ms)) {
+			dev_info(dev, "dequeue_buffer failed\n");
+			return -ENODATA;
+		}
+
+		return 0;
+	}
+	case ISP_UT_IOCTL_CREATE_SESSION: {
+		struct cam_ioctl_create_session session;
+		struct mtkcam_ipi_event event;
+		struct mem_obj smem;
+		struct mem_obj smem_ipi;
+		void *mem_priv;
+		void *mem_ipi_priv;
+		struct mtk_ccd *ccd;
+		int dmabuf_ipi_fd;
+		struct mtkcam_ipi_sw_buffer *cqbuf;
+		struct mtkcam_ipi_sw_buffer *msgbuf;
+
+		if (copy_from_user(&session, (void *)arg,
+				   sizeof(session)) != 0) {
+			dev_dbg(dev, "[CREATE_SESSION] Fail to get session\n");
+			return -EFAULT;
+		}
+
+		ccd = (struct mtk_ccd *)ut->rproc_handle->priv;
+		event.cmd_id = CAM_CMD_CREATE_SESSION;
+		event.cookie = session.cookie;
+		ut->mem->size = round_up(session.cq_buffer_size, PAGE_SIZE);
+		smem.len = ut->mem->size;
+		mem_priv = mtk_ccd_get_buffer(ccd, &smem);
+		ut->mem->fd = mtk_ccd_get_buffer_fd(ccd, mem_priv);
+		ut->mem->iova = smem.iova;
+		ut->mem->va = smem.va;
+
+		cqbuf = &event.session_data.workbuf;
+		cqbuf->size = session.cq_buffer_size;
+		cqbuf->ccd_fd = ut->mem->fd;
+		cqbuf->iova = ut->mem->iova;
+
+		/* config ipi msg */
+		ut->msg_mem->size = round_up(IPI_FRAME_BUF_TOTAL_SIZE,
+					 PAGE_SIZE);
+		smem_ipi.len = ut->msg_mem->size;
+		mem_ipi_priv = mtk_ccd_get_buffer(ccd, &smem_ipi);
+		ut->msg_mem->fd = dmabuf_ipi_fd =
+			mtk_ccd_get_buffer_fd(ccd, mem_ipi_priv);
+		ut->msg_mem->iova = smem_ipi.iova;
+		ut->msg_mem->va = smem_ipi.va;
+
+		msgbuf = &event.session_data.msg_buf;
+		msgbuf->size = IPI_FRAME_BUF_TOTAL_SIZE;
+		msgbuf->ccd_fd = dmabuf_ipi_fd;
+		msgbuf->iova = ut->msg_mem->iova;
+		dev_info(dev, "[CREATE_SESSION] ut->msg_mem->va 0x%x size %d\n",
+				ut->msg_mem->va, msgbuf->size);
+		/* ipi msg end */
+
+		ut->enque_list.cnt = 0;
+		ut->deque_list.cnt = 0;
+		ut->processing_list.cnt = 0;
+		INIT_LIST_HEAD(&ut->enque_list.list);
+		INIT_LIST_HEAD(&ut->deque_list.list);
+		INIT_LIST_HEAD(&ut->processing_list.list);
+		rpmsg_send(ut->rpmsg_dev->rpdev.ept, &event, sizeof(event));
+		ut->m2m_available = 1;
+
+		return 0;
+	}
+	case ISP_UT_IOCTL_DESTROY_SESSION: {
+		struct mtkcam_ipi_session_cookie cookie;
+		struct mtkcam_ipi_event event;
+		struct mtk_ccd *ccd = (struct mtk_ccd *)ut->rproc_handle->priv;
+		struct mem_obj smem;
+		int fd, i;
+
+		if (copy_from_user(&cookie, (void *)arg,
+				   sizeof(cookie)) != 0) {
+			dev_dbg(dev, "[DESTROY_SESSION] Fail to get cookie\n");
+			return -EFAULT;
+		}
+
+		event.cmd_id = CAM_CMD_DESTROY_SESSION;
+		event.cookie = cookie;
+
+		if (ut->with_testmdl) {
+			for (i = 0; i < ut->is_dcif_camsv; i++)
+				CALL_CAMSV_OPS(ut->camsv[i], s_stream, 0);
+
+			if (ut->hardware_scenario != MTKCAM_IPI_HW_PATH_OFFLINE_SRT_DCIF_STAGGER) {
+				CALL_RAW_OPS(ut->raw[0], s_stream, 0);
+				/* stream off rawb for bc case(or any case)
+				 * w/o send hardware_scenario
+				 */
+				CALL_RAW_OPS(ut->raw[1], s_stream, 0);
+			}
+		}
+
+		smem.va = ut->mem->va;
+		smem.iova = ut->mem->iova;
+		smem.len = ut->mem->size;
+		fd = ut->mem->fd;
+		mtk_ccd_put_buffer_fd(ccd, &smem, fd);
+		mtk_ccd_put_buffer(ccd, &smem);
+
+		dev_dbg(dev,
+				"%s:msg buffers release, mem(%p), sz(%d)\n",
+				__func__, smem.va, smem.len);
+
+		smem.va = ut->msg_mem->va;
+		smem.iova = 0;
+		smem.len = ut->msg_mem->size;
+		fd = ut->msg_mem->fd;
+		mtk_ccd_put_buffer_fd(ccd, &smem, fd);
+		mtk_ccd_put_buffer(ccd, &smem);
+		dev_dbg(dev,
+				"%s:ipi msg buffers release, mem(%p), sz(%d)\n",
+				__func__, smem.va, smem.len);
+
+		rpmsg_send(ut->rpmsg_dev->rpdev.ept, &event, sizeof(event));
+
+		return 0;
+	}
+	case ISP_UT_IOCTL_ENQUE: {
+		static struct cam_ioctl_enque enque; /* large struct */
+		struct mtkcam_ipi_event event;
+		struct mtk_cam_ut_buf_entry *buf_entry;
+		unsigned long flags;
+		struct mtkcam_ipi_frame_info *frame_info = &event.frame_data;
+		struct mtkcam_ipi_frame_param *frame_data;
+		int i = 0;
+
+		struct cam_ioctl_enque *pEnque;
+
+		if (copy_from_user(&pEnque, (void *)arg, sizeof(pEnque)) != 0) {
+			dev_dbg(dev, "[ENQUE] Fail to get enque\n");
+			return -EFAULT;
+		}
+
+		if (copy_from_user(&enque, (void *)pEnque, sizeof(enque)) != 0) {
+			dev_dbg(dev, "[ENQUE] Fail to get enque\n");
+			return -EFAULT;
+		}
+
+		buf_entry = kzalloc(sizeof(*buf_entry), GFP_KERNEL);
+		event.cmd_id = CAM_CMD_FRAME;
+		event.cookie = enque.cookie;
+		ut->hardware_scenario = enque.frame_param.raw_param.hardware_scenario;
+
+		spin_lock_irqsave(&ut->enque_list.lock, flags);
+		list_add_tail(&buf_entry->list_entry, &ut->enque_list.list);
+		ut->enque_list.cnt++;
+
+		if (ut->hardware_scenario == MTKCAM_IPI_HW_PATH_OFFLINE_STAGGER) {
+			for (i = 0 ; i < CAM_MAX_IMAGE_INPUT; i++) {
+				if (enque.frame_param.img_ins[i].uid.id == MTKCAM_IPI_RAW_RAWI_6) {
+					ut->main_rawi = MTKCAM_IPI_RAW_RAWI_6;
+					break;
+				}
+
+				if (enque.frame_param.img_ins[i].uid.id == MTKCAM_IPI_RAW_RAWI_5) {
+					ut->main_rawi = MTKCAM_IPI_RAW_RAWI_5;
+					break;
+				}
+			}
+		}
+		/* ipi msg */
+		dev_info(dev, "[ENQUE] msg_mem->va 0x%x size %d cur_msgbuf_offset 0x%x cur_workbuf_offset 0x%x frame_no %d\n",
+				ut->msg_mem->va, ut->msg_mem->size,
+				frame_info->cur_msgbuf_offset,
+				enque.frame_param.cur_workbuf_offset,
+				event.cookie.frame_no);
+
+		/* Prepare rp message */
+		BUILD_BUG_ON(sizeof(struct mtkcam_ipi_frame_param) > IPI_FRAME_BUF_SIZE);
+		frame_info->cur_msgbuf_offset =
+				(event.cookie.frame_no % IPI_FRAME_BUF_NUM) * IPI_FRAME_BUF_SIZE;
+		frame_info->cur_msgbuf_size = IPI_FRAME_BUF_SIZE;
+		buf_entry->msg_buffer.va = ut->msg_mem->va +
+				frame_info->cur_msgbuf_offset;
+		frame_data = (struct mtkcam_ipi_frame_param *)buf_entry->msg_buffer.va;
+
+
+		memcpy(frame_data, &enque.frame_param,
+				sizeof(enque.frame_param));
+		/* ipi msg end */
+
+		buf_entry->frame_seq_no = ut->enque_list.cnt;
+		buf_entry->cq_buf.iova = ut->mem->iova +
+			enque.frame_param.cur_workbuf_offset;
+		buf_entry->cq_buf.size = buf_entry->sub_cq_size = 0;
+
+		spin_unlock_irqrestore(&ut->enque_list.lock, flags);
+		rpmsg_send(ut->rpmsg_dev->rpdev.ept, &event, sizeof(event));
+
+		return 0;
+	}
+	case ISP_UT_IOCTL_CONFIG: {
+		struct cam_ioctl_config config;
+		struct mtkcam_ipi_event event;
+		struct mtkcam_ipi_config_param *pParam;
+		int i;
+
+		if (copy_from_user(&config, (void *)arg,
+				   sizeof(config)) != 0) {
+			dev_dbg(dev, "[CONFIG] Fail to get config\n");
+			return -EFAULT;
+		}
+		dev_info(dev, "ut->is_dcif_camsv=%d\n", ut->is_dcif_camsv);
+		if (ut->hardware_scenario == MTKCAM_IPI_HW_PATH_ON_THE_FLY_DCIF_STAGGER) {
+			pParam = &config.config_param;
+			for (i = 0; i < ut->is_dcif_camsv; i++)
+				CALL_CAMSV_OPS(ut->camsv[i], dev_config, &pParam->input);
+		} else if (ut->hardware_scenario == MTKCAM_IPI_HW_PATH_OFFLINE_SRT_DCIF_STAGGER) {
+			pParam = &config.config_param;
+			for (i = 0; i < ut->is_dcif_camsv; i++)
+				CALL_CAMSV_OPS(ut->camsv[i], dev_config, &pParam->input);
+
+		}
+
+		config.config_param.flags = MTK_CAM_IPI_CONFIG_TYPE_INIT;
+					/* |MTK_CAM_IPI_CONFIG_TYPE_SMVR_PREVIEW */
+
+		ut->subsample = config.config_param.input.subsample;
+
+		event.cmd_id = CAM_CMD_CONFIG;
+		event.cookie = config.cookie;
+		event.config_data = config.config_param;
+		rpmsg_send(ut->rpmsg_dev->rpdev.ept, &event, sizeof(event));
+
+		setup_hanlder(ut);
+
+		return 0;
+	}
+	case ISP_UT_IOCTL_ALLOC_DMABUF: {
+		struct cam_ioctl_dmabuf_param workbuf;
+		struct mem_obj smem;
+		void *mem_priv;
+		struct mtk_ccd *ccd;
+
+		if (copy_from_user(&workbuf, (void *)arg,
+				   sizeof(workbuf)) != 0) {
+			dev_dbg(dev, "[ALLOC_DMABUF] Fail to get sw buffer\n");
+			return -EFAULT;
+		}
+
+		ccd = (struct mtk_ccd *)ut->rproc_handle->priv;
+		workbuf.size = round_up(workbuf.size, PAGE_SIZE);
+		smem.len = workbuf.size;
+		mem_priv = mtk_ccd_get_buffer(ccd, &smem);
+		workbuf.ccd_fd = mtk_ccd_get_buffer_fd(ccd, mem_priv);
+		workbuf.iova = smem.iova;
+		workbuf.kva = (uint64_t)smem.va;
+
+		if (copy_to_user((void *)arg, &workbuf,
+				 sizeof(workbuf)) != 0) {
+			dev_dbg(dev, "[ALLOC_DMABUF] Fail to put sw buffer\n");
+			return -EFAULT;
+		}
+
+		dev_dbg(dev, "[ALLOC_DMABUF] ccd_fd=%d, kva=0x%llx, iova=0x%llx, size=%d\n",
+			workbuf.ccd_fd, workbuf.kva, workbuf.iova, workbuf.size);
+		return 0;
+	}
+	case ISP_UT_IOCTL_FREE_DMABUF: {
+		struct cam_ioctl_dmabuf_param workbuf;
+		struct mtk_ccd *ccd = (struct mtk_ccd *)ut->rproc_handle->priv;
+		struct mem_obj smem;
+		int fd;
+
+		if (copy_from_user(&workbuf, (void *)arg,
+			sizeof(workbuf)) != 0) {
+			dev_dbg(dev, "[FREE_DMABUF] Fail to get sw buffer\n");
+			return -EFAULT;
+		}
+
+		dev_dbg(dev, "[FREE_DMABUF] kva=0x%llx, iova=0x%llx, size=%d, ccd_fd=%d\n",
+			workbuf.kva, workbuf.iova, workbuf.size, workbuf.ccd_fd);
+
+		smem.va = (void *)workbuf.kva;
+		smem.iova = workbuf.iova;
+		smem.len = workbuf.size;
+		fd = workbuf.ccd_fd;
+		mtk_ccd_put_buffer_fd(ccd, &smem, fd);
+		mtk_ccd_put_buffer(ccd, &smem);
+
+		dev_dbg(dev,
+			"%s:sw buffers release, mem(%p), sz(%d)\n",
+			__func__, smem.iova, smem.len);
+
+		return 0;
+	}
+	default:
+		dev_info(dev, "DO NOT support this ioctl (%d)\n", cmd);
+		return -ENOIOCTLCMD;
+	}
+}
+
+static int cam_open(struct inode *inode, struct file *filp)
+{
+	struct mtk_cam_ut *ut =	container_of(inode->i_cdev,
+					     struct mtk_cam_ut, cdev);
+	int i;
+
+	dev_info(ut->dev, "%s\n", __func__);
+	get_device(ut->dev);
+
+	pm_runtime_get_sync(ut->dev);
+
+	for (i = 0; i < ut->num_raw; i++) {
+		pr_info("get_sync raw %d\n", i);
+		pm_runtime_get_sync(ut->raw[i]);
+	}
+
+	for (i = 0; i < ut->num_camsv; i++) {
+		pr_info("get_sync camsv %d\n", i);
+		pm_runtime_get_sync(ut->camsv[i]);
+	}
+
+	/* Note: seninf's dts have no power-domains now, so do it after raw's */
+	pm_runtime_get_sync(ut->seninf);
+
+	filp->private_data = ut;
+
+	cam_composer_init(ut);
+
+	return 0;
+}
+
+static int cam_release(struct inode *inode, struct file *filp)
+{
+	struct mtk_cam_ut *ut = filp->private_data;
+	int i;
+
+	dev_info(ut->dev, "%s\n", __func__);
+
+	cam_composer_uninit(ut);
+
+	pm_runtime_put(ut->seninf);
+
+	for (i = 0; i < ut->num_camsv; i++)
+		pm_runtime_put(ut->camsv[i]);
+
+	for (i = 0; i < ut->num_raw; i++)
+		pm_runtime_put(ut->raw[i]);
+
+	pm_runtime_put(ut->dev);
+	put_device(ut->dev);
+
+	return 0;
+}
+
+static const struct file_operations cam_file_oper = {
+	.owner = THIS_MODULE,
+	.open = cam_open,
+	.release = cam_release,
+	.unlocked_ioctl = cam_ioctl,
+#ifdef CONFIG_COMPAT
+	.compat_ioctl   = compat_ptr_ioctl,
+#endif
+};
+
+static inline void cam_unreg_char_dev(struct mtk_cam_ut *ut)
+{
+	device_destroy(ut->class, ut->devno);
+	class_destroy(ut->class);
+	cdev_del(&ut->cdev);
+	unregister_chrdev_region(ut->devno, 1);
+}
+
+static inline int cam_reg_char_dev(struct mtk_cam_ut *ut)
+{
+	struct device *dev;
+	int ret;
+
+	ret = alloc_chrdev_region(&ut->devno, 0, 1, CAM_DEV_NAME);
+	if (ret < 0) {
+		dev_dbg(ut->dev, "Fail to alloc chrdev region, %d\n", ret);
+		return ret;
+	}
+
+	cdev_init(&ut->cdev, &cam_file_oper);
+	//ut->cdev.owner = THIS_MODULE;
+	ret = cdev_add(&ut->cdev, ut->devno, 1);
+	if (ret < 0) {
+		dev_dbg(ut->dev, "Attach file operation failed, %d\n", ret);
+		goto EXIT;
+	}
+
+	ut->class = class_create(THIS_MODULE, CAM_DEV_NAME);
+	if (IS_ERR(ut->class)) {
+		ret = PTR_ERR(ut->class);
+		dev_dbg(ut->dev, "Fail to create class, %d\n", ret);
+		goto CLASS_CREATE_FAIL;
+	}
+
+	dev = device_create(ut->class, ut->dev, ut->devno, NULL, CAM_DEV_NAME);
+	if (IS_ERR(dev)) {
+		ret = PTR_ERR(dev);
+		dev_dbg(ut->dev, "Fail to create /dev/%s, %d\n",
+			CAM_DEV_NAME, ret);
+		goto DEV_CREATE_FAIL;
+	}
+	return ret;
+
+DEV_CREATE_FAIL:
+	class_destroy(ut->class);
+CLASS_CREATE_FAIL:
+	cdev_del(&ut->cdev);
+EXIT:
+	cam_unreg_char_dev(ut);
+	return ret;
+}
+
+static int compare_dev(struct device *dev, void *data)
+{
+	return dev == (struct device *)data;
+}
+
+static void mtk_cam_match_remove(struct device *dev)
+{
+	(void) dev;
+}
+
+static int add_match_by_driver(struct device *dev,
+			       struct component_match **match,
+			       struct platform_driver *drv)
+{
+	struct device *p = NULL, *d;
+	int num = 0;
+
+	do {
+		d = platform_find_device_by_driver(p, &drv->driver);
+		put_device(p);
+		p = d;
+		if (!d)
+			break;
+
+		component_match_add(dev, match, compare_dev, d);
+		num++;
+	} while (true);
+
+	return num;
+}
+
+static struct component_match *mtk_cam_match_add(struct device *dev)
+{
+	struct mtk_cam_ut *ut = dev_get_drvdata(dev);
+	struct component_match *match = NULL;
+	int seninf_num;
+
+	seninf_num = add_match_by_driver(dev, &match, &mtk_ut_seninf_driver);
+	dev_info(dev, "# of seninf_num: %d\n", seninf_num);
+
+	ut->num_raw = add_match_by_driver(dev, &match, &mtk_ut_raw_driver);
+	dev_info(dev, "# of raw: %d\n", ut->num_raw);
+
+	ut->num_yuv = add_match_by_driver(dev, &match, &mtk_ut_yuv_driver);
+	dev_info(dev, "# of yuv: %d\n", ut->num_yuv);
+
+	ut->num_camsv = add_match_by_driver(dev, &match, &mtk_ut_camsv_driver);
+	dev_info(dev, "# of camsv: %d\n", ut->num_camsv);
+
+	if (IS_ERR(match))
+		mtk_cam_match_remove(dev);
+
+	return match ? match : ERR_PTR(-ENODEV);
+}
+
+static int bind_cam_sub_pipes(struct mtk_cam_ut *ut)
+{
+	struct device *consumer, *supplier;
+	struct device_link *link;
+	struct mtk_ut_raw_device *raw;
+	struct mtk_ut_yuv_device *yuv;
+	int i;
+
+	dev_info(ut->dev, "%s\n", __func__);
+
+	for (i = 0; i < ut->num_raw; i++) {
+		consumer = ut->raw[i];
+		supplier = ut->yuv[i];
+		if (!consumer || !supplier) {
+			dev_info(ut->dev,
+				 "failed to get raw/yuv dev for id %d\n", i);
+			continue;
+		}
+
+		raw = dev_get_drvdata(consumer);
+		yuv = dev_get_drvdata(supplier);
+
+		raw->yuv_base = yuv->base;
+
+		link = device_link_add(consumer, supplier,
+				       DL_FLAG_AUTOREMOVE_CONSUMER |
+				       DL_FLAG_PM_RUNTIME);
+		if (!link) {
+			dev_info(ut->dev,
+				 "Unable to create link between %s and %s\n",
+				 dev_name(consumer), dev_name(supplier));
+			return -ENODEV;
+		}
+	}
+	return 0;
+}
+
+static int mtk_cam_ut_master_bind(struct device *dev)
+{
+	struct mtk_cam_ut *ut = dev_get_drvdata(dev);
+	int ret;
+
+	dev_info(dev, "%s\n", __func__);
+
+	if (ut->num_raw) {
+		ut->raw = devm_kcalloc(dev, ut->num_raw, sizeof(*ut->raw),
+				       GFP_KERNEL);
+		if (!ut->raw)
+			return -ENOMEM;
+	}
+
+	if (ut->num_yuv) {
+		ut->yuv = devm_kcalloc(dev, ut->num_yuv, sizeof(*ut->yuv),
+				       GFP_KERNEL);
+		if (!ut->yuv)
+			return -ENOMEM;
+	}
+
+	if (ut->num_raw != ut->num_yuv) {
+		dev_info(dev, "wrong num: raw %d, yuv %d\n",
+			 ut->num_raw, ut->num_yuv);
+		return -ENODEV;
+	}
+
+	if (ut->num_camsv) {
+		ut->camsv = devm_kcalloc(dev, ut->num_camsv, sizeof(*ut->camsv),
+				       GFP_KERNEL);
+		if (!ut->camsv)
+			return -ENOMEM;
+	}
+
+#if WITH_LARB_DRIVER
+	if (ut->num_larb) {
+		ut->larb = devm_kcalloc(dev, ut->num_larb, sizeof(*ut->larb),
+					GFP_KERNEL);
+		if (!ut->larb)
+			return -ENOMEM;
+	}
+#endif
+
+	dev_info(dev, "component_bind_all with data = 0x%llx\n", dev_get_drvdata(dev));
+	ret = component_bind_all(dev, dev_get_drvdata(dev));
+	if (ret) {
+		dev_info(dev, "Failed to bind all component: %d\n", ret);
+		return ret;
+	}
+
+	ret = bind_cam_sub_pipes(ut);
+	if (ret) {
+		dev_info(dev, "Failed to update_yuv_base: %d\n", ret);
+		return ret;
+	}
+
+	dev_info(dev, "%s success\n", __func__);
+	return 0;
+}
+
+static void mtk_cam_ut_master_unbind(struct device *dev)
+{
+	struct mtk_cam_ut *ut = dev_get_drvdata(dev);
+
+	dev_info(dev, "%s\n", __func__);
+	component_unbind_all(dev, ut);
+}
+
+static const struct component_master_ops mtk_cam_master_ops = {
+	.bind = mtk_cam_ut_master_bind,
+	.unbind = mtk_cam_ut_master_unbind,
+};
+
+static int register_sub_drivers(struct device *dev)
+{
+	struct component_match *match = NULL;
+	int ret;
+
+#if WITH_LARB_DRIVER
+	ret = platform_driver_register(&mtk_ut_larb_driver);
+	if (ret) {
+		dev_info(dev, "%s register larb driver fail\n", __func__);
+		goto REGISTER_LARB_FAIL;
+	}
+#endif
+
+	ret = platform_driver_register(&mtk_ut_raw_driver);
+	if (ret) {
+		dev_info(dev, "%s register raw driver fail\n", __func__);
+		goto REGISTER_RAW_FAIL;
+	}
+
+	ret = platform_driver_register(&mtk_ut_yuv_driver);
+	if (ret) {
+		dev_info(dev, "%s register yuv driver fail\n", __func__);
+		goto REGISTER_YUV_FAIL;
+	}
+
+	ret = platform_driver_register(&mtk_ut_camsv_driver);
+	if (ret) {
+		dev_info(dev, "%s register camsv driver fail\n", __func__);
+		goto REGISTER_CAMSV_FAIL;
+	}
+
+	ret = platform_driver_register(&mtk_ut_seninf_driver);
+	if (ret) {
+		dev_info(dev, "%s register seninf driver fail\n", __func__);
+		goto REGISTER_SENINF_FAIL;
+	}
+
+	match = mtk_cam_match_add(dev);
+	if (IS_ERR(match)) {
+		dev_info(dev, "%s mtk_cam_match_add failed\n", __func__);
+		ret = PTR_ERR(match);
+		goto ADD_MATCH_FAIL;
+	}
+
+	ret = component_master_add_with_match(dev, &mtk_cam_master_ops, match);
+	if (ret < 0)
+		goto MASTER_ADD_MATCH_FAIL;
+
+	return 0;
+
+MASTER_ADD_MATCH_FAIL:
+	mtk_cam_match_remove(dev);
+
+ADD_MATCH_FAIL:
+	platform_driver_unregister(&mtk_ut_seninf_driver);
+
+REGISTER_SENINF_FAIL:
+	platform_driver_unregister(&mtk_ut_camsv_driver);
+
+REGISTER_CAMSV_FAIL:
+	platform_driver_unregister(&mtk_ut_yuv_driver);
+
+REGISTER_YUV_FAIL:
+	platform_driver_unregister(&mtk_ut_raw_driver);
+
+REGISTER_RAW_FAIL:
+#if WITH_LARB_DRIVER
+	platform_driver_unregister(&mtk_ut_larb_driver);
+
+REGISTER_LARB_FAIL:
+#endif
+	return ret;
+}
+
+static int mtk_cam_ut_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct mtk_cam_ut *ut;
+	int ret;
+
+	ut = devm_kzalloc(dev, sizeof(*ut), GFP_KERNEL);
+	if (!ut)
+		return -ENOMEM;
+	ut->dev = dev;
+	platform_set_drvdata(pdev, ut);
+
+#ifdef CONFIG_MTK_IOMMU_PGTABLE_EXT
+#if (CONFIG_MTK_IOMMU_PGTABLE_EXT > 32)
+	if (dma_set_mask_and_coherent(dev, DMA_BIT_MASK(34)))
+		dev_info(dev, "%s: No suitable DMA available\n", __func__);
+#endif
+#endif
+
+	if (!dev->dma_parms) {
+		dev->dma_parms =
+			devm_kzalloc(dev, sizeof(*dev->dma_parms), GFP_KERNEL);
+		if (!dev->dma_parms)
+			return -ENOMEM;
+	}
+
+	if (dev->dma_parms) {
+		ret = dma_set_max_seg_size(dev, UINT_MAX);
+		if (ret)
+			dev_info(dev, "Failed to set DMA segment size\n");
+	}
+
+
+	ret = cam_of_rproc(ut);
+	if (ret)
+		return ret;
+
+	ret = cam_reg_char_dev(ut);
+	if (ret) {
+		dev_info(dev, "fail to register char dev\n");
+		return ret;
+	}
+
+	ut->mem = devm_kzalloc(dev, sizeof(*ut->mem), GFP_KERNEL);
+	ut->msg_mem = devm_kzalloc(dev, sizeof(*ut->msg_mem), GFP_KERNEL);
+	spin_lock_init(&ut->spinlock_irq);
+	spin_lock_init(&ut->enque_list.lock);
+	spin_lock_init(&ut->deque_list.lock);
+	spin_lock_init(&ut->processing_list.lock);
+	init_waitqueue_head(&ut->done_wq);
+
+	ut->listener.on_notify = ut_event_on_notify;
+
+	ret = register_sub_drivers(dev);
+	if (ret) {
+		dev_info(dev, "fail to register_sub_drivers\n");
+		return ret;
+	}
+
+	pm_runtime_enable(dev);
+
+	dev_info(dev, "%s: success\n", __func__);
+	return 0;
+}
+
+static int mtk_cam_ut_remove(struct platform_device *pdev)
+{
+	struct mtk_cam_ut *ut =
+		(struct mtk_cam_ut *)platform_get_drvdata(pdev);
+
+	pm_runtime_disable(ut->dev);
+
+	cam_unreg_char_dev(ut);
+
+	return 0;
+}
+
+static int mtk_cam_ut_pm_suspend(struct device *dev)
+{
+	int ret;
+
+	dev_dbg(dev, "- %s\n", __func__);
+
+	if (pm_runtime_suspended(dev))
+		return 0;
+
+	ret = pm_runtime_force_suspend(dev);
+	if (ret)
+		dev_dbg(dev, "failed to force suspend:%d\n", ret);
+
+	return ret;
+}
+
+static int mtk_cam_ut_pm_resume(struct device *dev)
+{
+	int ret;
+
+	dev_dbg(dev, "- %s\n", __func__);
+
+	if (pm_runtime_suspended(dev))
+		return 0;
+
+	ret = pm_runtime_force_resume(dev);
+	return ret;
+}
+
+static int mtk_cam_ut_runtime_suspend(struct device *dev)
+{
+	dev_dbg(dev, "- %s\n", __func__);
+	return 0;
+}
+
+static int mtk_cam_ut_runtime_resume(struct device *dev)
+{
+	dev_dbg(dev, "- %s\n", __func__);
+	return 0;
+}
+
+static const struct dev_pm_ops mtk_cam_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(mtk_cam_ut_pm_suspend, mtk_cam_ut_pm_resume)
+	SET_RUNTIME_PM_OPS(mtk_cam_ut_runtime_suspend,
+			   mtk_cam_ut_runtime_resume,
+			   NULL)
+};
+
+static const struct of_device_id cam_ut_driver_dt_match[] = {
+	{ .compatible = "mediatek,camisp", },
+	{}
+};
+MODULE_DEVICE_TABLE(of, cam_ut_driver_dt_match);
+
+static struct platform_driver mtk_cam_ut_driver = {
+	.probe		= mtk_cam_ut_probe,
+	.remove		= mtk_cam_ut_remove,
+	.driver		= {
+		.name	= "mtk-cam ut",
+		.of_match_table = of_match_ptr(cam_ut_driver_dt_match),
+	}
+};
+
+static int __init mtk_cam_ut_init(void)
+{
+	int ret;
+
+	ret = platform_driver_register(&mtk_cam_ut_driver);
+	return ret;
+}
+
+static void __exit mtk_cam_ut_exit(void)
+{
+	platform_driver_unregister(&mtk_cam_ut_driver);
+}
+
+module_init(mtk_cam_ut_init);
+module_exit(mtk_cam_ut_exit);
+
+MODULE_DESCRIPTION("Mediatek ISP unit test driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/camsys/unit_test/mtk_cam_ut.h b/drivers/media/platform/mediatek/isp/isp_7x/camsys/unit_test/mtk_cam_ut.h
new file mode 100644
index 0000000000000000000000000000000000000000..f322e0410376f890169ed4d0172064b196eedc46
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/camsys/unit_test/mtk_cam_ut.h
@@ -0,0 +1,157 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2021 MediaTek Inc.
+ */
+
+#ifndef __MTK_CAM_UT_H
+#define __MTK_CAM_UT_H
+
+#include <linux/cdev.h>
+#include <linux/rpmsg.h>
+#include <linux/wait.h>
+
+#include <src/mtk_cam-ipi.h>
+#include "mtk_cam_ut-event.h"
+#define IPI_FRAME_BUF_SIZE		0x8000
+#define IPI_FRAME_BUF_NUM		3
+#define IPI_FRAME_BUF_TOTAL_SIZE	(IPI_FRAME_BUF_SIZE * IPI_FRAME_BUF_NUM)
+
+#define CAM_MAX_DMA (CAM_MAX_IMAGE_OUTPUT * CAM_MAX_PLANENUM \
+			+ CAM_MAX_META_OUTPUT + CAM_MAX_PIPE_USED)
+
+#define SENINF_OFFSET 0x1000
+
+enum seninf_enum {
+	seninf_0 = 0,
+	seninf_1,
+	seninf_2,
+	seninf_3,
+	seninf_4,
+	seninf_5
+};
+
+enum tg_enum {
+	raw_tg_0 = 0,
+	raw_tg_1,
+	raw_tg_2,
+	camsv_tg_0 = 3,
+	camsv_tg_1,
+	camsv_tg_2,
+	camsv_tg_3,
+	camsv_tg_4,
+	camsv_tg_5,
+#ifdef ISP7_1
+	camsv_tg_6,
+	camsv_tg_7,
+	camsv_tg_8,
+	camsv_tg_9,
+	camsv_tg_10,
+	camsv_tg_11,
+	camsv_tg_12 = 19,
+	camsv_tg_13,
+	camsv_tg_14,
+	camsv_tg_15,
+#endif
+	camsys_tg_max
+};
+
+// align TestMdlMode in testPlan.h
+enum testmdl_enum {
+	disable = -1,
+	normal = 0,
+	stagger_1exp = 1U << 1,
+	stagger_2exp = 1U << 2,
+	stagger_3exp = 1U << 3,
+};
+
+struct mtk_cam_ut_mem_obj {
+	int fd;
+	dma_addr_t iova;
+	uint32_t size;
+	void *va;
+
+	struct dma_buf_attachment *attach;
+	struct sg_table *sgt;
+	struct dma_buf *dma_buf;
+};
+
+struct mtk_cam_msg_buf {
+	void *va;
+	int size;
+};
+
+struct mtk_cam_ut_buf_entry {
+	unsigned int frame_seq_no;
+	struct mtk_cam_ut_mem_obj cq_buf;
+	struct mtk_cam_ut_mem_obj dma_buf[CAM_MAX_DMA];
+	struct mtk_cam_msg_buf msg_buffer;
+	struct list_head list_entry;
+	unsigned int  cq_offset;
+	unsigned int  sub_cq_size;
+	unsigned int  sub_cq_offset;
+};
+
+struct mtk_cam_ut_buf_list {
+	struct list_head list;
+	u32 cnt;
+	spinlock_t lock;
+};
+
+struct mtk_cam_ut;
+struct mtk_cam_ut_event_handler {
+	int (*on_ipi_composed)(struct mtk_cam_ut *ut);
+
+	int (*on_isr_sof)(struct mtk_cam_ut *ut);
+	int (*on_isr_sv_sof)(struct mtk_cam_ut *ut);
+	int (*on_isr_cq_done)(struct mtk_cam_ut *ut);
+	int (*on_isr_frame_done)(struct mtk_cam_ut *ut);
+};
+
+struct mtk_cam_ut {
+	struct device *dev;
+
+	dev_t devno;
+	struct cdev cdev;
+	struct class *class;
+
+	int num_raw;
+	int num_yuv;
+	int num_larb;
+	int num_camsv;
+
+	struct device *seninf;
+	struct device **raw;
+	struct device **yuv;
+	struct device **larb;
+	struct device **camsv;
+
+	struct mtk_cam_ut_mem_obj *mem;
+	struct mtk_cam_ut_mem_obj *msg_mem;
+	void __iomem *base;
+
+	phandle rproc_phandle;
+	struct rproc *rproc_handle;
+	struct rpmsg_channel_info rpmsg_channel;
+	struct mtk_rpmsg_device *rpmsg_dev;
+
+	struct mtk_cam_ut_buf_list enque_list;
+	struct mtk_cam_ut_buf_list processing_list;
+	struct mtk_cam_ut_buf_list deque_list;
+	wait_queue_head_t done_wq;
+
+	struct ut_event_listener listener;
+
+	/* config related */
+	int with_testmdl;
+	int is_dcif_camsv;
+	int subsample;
+	int hardware_scenario;
+	int main_rawi;
+
+	struct mtk_cam_ut_event_handler hdl;
+
+	spinlock_t spinlock_irq;
+	int m2m_available;
+};
+
+#endif /* __MTK_CAM_UT_H */
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/camsys/unit_test/mtk_isp_ut_ioctl.h b/drivers/media/platform/mediatek/isp/isp_7x/camsys/unit_test/mtk_isp_ut_ioctl.h
new file mode 100644
index 0000000000000000000000000000000000000000..bef4d7a09b4e8544d6a105455f790708777a858c
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/camsys/unit_test/mtk_isp_ut_ioctl.h
@@ -0,0 +1,73 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2021 MediaTek Inc.
+ * Author: Bibby Hsieh <bibby.hsieh@mediatek.com>
+ */
+
+#ifndef __MTK_ISP_UT_IOCTL_H__
+#define __MTK_ISP_UT_IOCTL_H__
+
+#include <linux/types.h>
+
+#define ISP_UT_IOCTL_TYPE 'K'
+
+struct cam_ioctl_set_testmdl {
+	__u16 width;
+	__u16 height;
+	__u8 pattern;
+	__u8 pixmode_lg2;
+	__u8 mode;
+	__u8 hwScenario;
+};
+
+#define ISP_UT_IOCTL_SET_TESTMDL \
+	_IOW(ISP_UT_IOCTL_TYPE, 0, struct cam_ioctl_set_testmdl)
+
+struct cam_ioctl_create_session {
+	struct mtkcam_ipi_session_cookie cookie;
+	uint32_t cq_buffer_size;
+};
+
+#define ISP_UT_IOCTL_CREATE_SESSION \
+	_IOW(ISP_UT_IOCTL_TYPE, 1, struct cam_ioctl_create_session)
+
+#define ISP_UT_IOCTL_DESTROY_SESSION \
+	_IOW(ISP_UT_IOCTL_TYPE, 2, struct mtkcam_ipi_session_cookie)
+
+struct cam_ioctl_config {
+	struct mtkcam_ipi_session_cookie cookie;
+	struct mtkcam_ipi_config_param config_param;
+};
+
+#define ISP_UT_IOCTL_CONFIG \
+	_IOW(ISP_UT_IOCTL_TYPE, 3, struct cam_ioctl_config)
+
+struct cam_ioctl_enque {
+	struct mtkcam_ipi_session_cookie cookie;
+	struct mtkcam_ipi_frame_param frame_param;
+
+	uint32_t img_output_fd[CAM_MAX_IMAGE_OUTPUT * CAM_MAX_PLANENUM];
+	uint32_t meta_output_fd[CAM_MAX_META_OUTPUT];
+	uint32_t meta_input_fd[CAM_MAX_PIPE_USED];
+};
+
+#define ISP_UT_IOCTL_ENQUE \
+	_IO(ISP_UT_IOCTL_TYPE, 4)
+
+#define ISP_UT_IOCTL_DEQUE \
+	_IOW(ISP_UT_IOCTL_TYPE, 5, unsigned int)
+
+struct cam_ioctl_dmabuf_param {
+	uint32_t size;
+	uint32_t ccd_fd;
+	uint64_t iova;
+	uint64_t kva;
+};
+
+#define ISP_UT_IOCTL_ALLOC_DMABUF \
+	_IOW(ISP_UT_IOCTL_TYPE, 6, struct cam_ioctl_dmabuf_param)
+
+#define ISP_UT_IOCTL_FREE_DMABUF \
+	_IOW(ISP_UT_IOCTL_TYPE, 7, struct cam_ioctl_dmabuf_param)
+
+#endif
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/imgsys/Makefile b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/Makefile
new file mode 100644
index 0000000000000000000000000000000000000000..455129de193872ec4ef980a7c99e55a09cc5321a
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/Makefile
@@ -0,0 +1,30 @@
+# SPDX-License-Identifier: GPL-2.0
+#
+
+ccflags-y += -I$(srctree)/drivers/media/platform/mediatek/isp/isp_7x/mtk-hcp
+ccflags-y += -I$(srctree)/include/linux/mailbox/
+ccflags-y += -I$(srctree)/drivers/media/platform/mediatek/isp/isp_7x/imgsys/
+ccflags-y += -I$(srctree)/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/
+ccflags-y += -I$(srctree)/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_71
+ccflags-y += -I$(srctree)/drivers/media/platform/mediatek/isp/isp_7x/mtk-ipesys-me/
+ccflags-y += -I$(srctree)/drivers/iommu
+subdir-ccflags-y += -DIMGSYS_VER_ISP71
+mtk_imgsys_util-objs := \
+mtk_imgsys-dev.o \
+mtk_imgsys-sys.o \
+mtk_imgsys-v4l2.o \
+mtk_imgsys-cmdq.o \
+mtk_imgsys-worker.o \
+mtk_imgsys-of.o \
+mtk_imgsys-trace.o
+
+mtk_imgsys_hw_isp-objs := \
+platforms/isp_71/mtk_imgsys-debug.o \
+platforms/isp_71/modules/mtk_imgsys-dip.o \
+platforms/isp_71/modules/mtk_imgsys-traw.o \
+platforms/isp_71/modules/mtk_imgsys-pqdip.o \
+platforms/isp_71/modules/mtk_imgsys-wpe.o \
+platforms/isp_71/modules/mtk_imgsys-adl.o
+
+obj-y += mtk_imgsys_util.o
+obj-y += mtk_imgsys_hw_isp.o
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/imgsys/mtk-img-ipi.h b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/mtk-img-ipi.h
new file mode 100644
index 0000000000000000000000000000000000000000..14255210e75a3f8c3fd0a7997e9cb758df77aadb
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/mtk-img-ipi.h
@@ -0,0 +1,644 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2021 MediaTek Inc.
+ */
+
+#ifndef __MTK_IMG_IPI_H__
+#define __MTK_IMG_IPI_H__
+
+#include <linux/types.h>
+#include <linux/time.h>
+#include <mtk_header_desc.h>
+
+#ifndef __KERNEL__
+#define BIT(nr)	(1UL << (nr))
+typedef u_int8_t u8;
+typedef int8_t s8;
+typedef u_int16_t u16;
+typedef int16_t s16;
+typedef u_int32_t u32;
+typedef int32_t s32;
+typedef u_int64_t u64;
+typedef int64_t s64;
+#endif
+
+/* updated in W1948.1 */
+#define HEADER_VER 19481
+
+/* ISP-MDP generic input information */
+#define MTK_V4L2_BATCH_MODE_SUPPORT	1
+#define MTK_V4L2_SKIP_TILE_SUPPORT	0
+#define MTK_V4L2_CTRL_META_SUPPORT	1
+
+/* TODO */
+#define IMG_MAX_HW_INPUTS	3
+
+#define IMG_MAX_HW_OUTPUTS	4
+
+#if defined(IMGSYS_VER_ISP71)
+#define IMG_MAX_HW_DMAS		72
+#define IMG_MODULE_SET 5
+#elif defined(IMGSYS_VER_ISP70)
+#define IMG_MAX_HW_DMAS		67
+#define IMG_MODULE_SET 4
+#endif
+
+#define IMG_MAX_PLANES		3
+
+#define IMG_IPI_INIT    1
+#define IMG_IPI_DEINIT  2
+#define IMG_IPI_FRAME   3
+#define IMG_IPI_DEBUG   4
+
+struct module_init_info {
+	uint64_t	c_wbuf;
+	uint64_t	c_wbuf_dma;
+	uint32_t	c_wbuf_sz;
+	uint32_t	c_wbuf_fd;
+	uint64_t	t_wbuf;
+	uint64_t	t_wbuf_dma;
+	uint32_t	t_wbuf_sz;
+	uint32_t	t_wbuf_fd;
+} __attribute__ ((__packed__));
+
+struct img_init_info {
+	uint32_t	header_version;
+	uint32_t	isp_version;
+	uint32_t	dip_save_file;
+	uint32_t	param_pack_size;
+	uint32_t	dip_param_size;
+	uint32_t	frameparam_size;
+	uint32_t	reg_phys_addr;
+	uint32_t	reg_range;
+	uint64_t	hw_buf_fd;
+	uint64_t	hw_buf;
+	uint32_t	hw_buf_size;
+	uint32_t	reg_table_size;
+	uint32_t	sub_frm_size;
+	uint32_t	cq_size;
+	uint64_t	drv_data;
+	/*new add, need refine*/
+	struct module_init_info module_info[IMG_MODULE_SET];
+	uint32_t    g_wbuf_fd;
+	uint64_t	g_wbuf;
+	uint32_t	g_wbuf_sz;
+	uint32_t	sec_tag;
+	uint16_t	full_wd;
+	uint16_t	full_ht;
+	uint32_t	smvr_mode;
+} __attribute__ ((__packed__));
+
+struct img_swfrm_info {
+	uint32_t hw_comb;
+	int sw_ridx;
+	uint8_t is_time_shared;
+	uint8_t is_secFrm;
+	uint8_t is_earlycb;
+	uint8_t is_lastingroup;
+	uint64_t sw_goft;
+	uint64_t sw_bwoft;
+	int subfrm_idx;
+	void *g_swbuf;
+	void *bw_swbuf;
+	uint64_t pixel_bw;
+} __attribute__ ((__packed__));
+
+struct img_addr {
+	u64	va;	/* Used by Linux OS access */
+	u32	pa;	/* Used by CM4 access */
+	u32	iova;	/* Used by IOMMU HW access */
+	u32	offset; /* Used by User Daemon access */
+#ifdef MTK_V4L2_BATCH_MODE_SUPPORT
+	// Batch mode {
+	int	fd;
+	// } Batch mode
+#endif
+} __attribute__ ((__packed__));
+
+struct tuning_addr {
+	u64	va;	/* Used by Linux OS access */
+	u64	present;
+	u32	pa;	/* Used by CM4 access */
+	u32	iova;	/* Used by IOMMU HW access */
+} __attribute__ ((__packed__));
+
+
+struct img_sw_addr {
+	u64	va;	/* Used by APMCU access */
+	u32	pa;	/* Used by CM4 access */
+	u32	offset; /* Used by User Daemon access */
+#ifdef MTK_V4L2_BATCH_MODE_SUPPORT
+	// Batch mode {
+	u32	fd; /* Used by User Daemon access */
+	// } Batch mode
+#endif
+} __attribute__ ((__packed__));
+
+struct img_plane_format {
+	u32	size;
+	u16	stride;
+} __attribute__ ((__packed__));
+
+struct img_pix_format {
+	u16		width;
+	u16		height;
+	u32		colorformat;	/* enum mdp_color */
+	u16		ycbcr_prof;	/* enum mdp_ycbcr_profile */
+	struct img_plane_format	plane_fmt[IMG_MAX_PLANES];
+} __attribute__ ((__packed__));
+
+struct img_image_buffer {
+	struct img_pix_format	format;
+	u32		iova[IMG_MAX_PLANES];
+	/* enum mdp_buffer_usage, FD or advanced ISP usages */
+	u32		usage;
+	s32		fd[IMG_MAX_PLANES];
+} __attribute__ ((__packed__));
+
+struct img_rect {
+	int16_t		left;
+	int16_t		top;
+	uint16_t	width;
+	uint16_t	height;
+} __attribute__ ((__packed__));
+
+#define IMG_SUBPIXEL_SHIFT	20
+
+struct img_crop {
+	s16		left;
+	s16		top;
+	u16	width;
+	u16	height;
+	u32	left_subpix;
+	u32	top_subpix;
+	u32	width_subpix;
+	u32	height_subpix;
+} __attribute__ ((__packed__));
+
+#define IMG_CTRL_FLAG_HFLIP	BIT(0)
+#define IMG_CTRL_FLAG_DITHER	BIT(1)
+#define IMG_CTRL_FLAG_SHARPNESS	BIT(4)
+#define IMG_CTRL_FLAG_HDR	BIT(5)
+#define IMG_CTRL_FLAG_DRE	BIT(6)
+
+struct img_input {
+	struct img_image_buffer	buffer;
+	u16		flags;	/* HDR, DRE, dither */
+} __attribute__ ((__packed__));
+
+struct img_output {
+	struct img_image_buffer	buffer;
+	struct img_crop		crop;
+	struct img_rect		compose;
+	s16			rotation;
+	u16		flags;	/* H-flip, sharpness, dither */
+	u8		type; /* MCRP-D1, MCRP-D2 */
+} __attribute__ ((__packed__));
+
+// Batch Mode {
+#if (MTK_V4L2_BATCH_MODE_SUPPORT == 1 || MTK_V4L2_CTRL_META_SUPPORT == 1)
+#define MAX_SRZ_CONFIGS  5
+#define MAX_EXTRA_PARAMS  5
+
+enum dip_srz_module {
+	DIP_SRZ_NONE  = 0x0000,
+	DIP_SRZ1      = 0x0001,
+	DIP_SRZ2      = 0x0002,
+	DIP_SRZ3      = 0x0004,
+	DIP_SRZ4      = 0x0008,
+	DIP_SRZ5      = 0x0010,
+};
+
+struct srz_config {
+	enum dip_srz_module srz_module_id;
+	uint32_t in_w;
+	uint32_t in_h;
+	uint32_t out_w;
+	uint32_t out_h;
+	uint32_t crop_x;
+	uint32_t crop_y;
+	uint32_t crop_floatX; /* x float precise - 32 bit */
+	uint32_t crop_floatY; /* y float precise - 32 bit */
+	unsigned long crop_w;
+	unsigned long crop_h;
+} __attribute__ ((__packed__));
+
+/* need to refine it for better memory usage.
+ * See FEInfo(48B), FMInfo(32B), CrspInfo(24B), MFBConfig(...)
+ */
+#define EXTRA_PARAM_SIZE (64)
+struct extra_param {
+	uint32_t cmd_idx;
+	uint8_t module_struct[EXTRA_PARAM_SIZE];
+} __attribute__ ((__packed__));
+
+struct dip_param {
+	uint32_t frame_no;
+	uint32_t request_no;
+	uint32_t unique_key;
+	/*struct timeval expected_end_time;*/
+	int32_t user_enum;
+
+	uint8_t num_srz_cfg;
+	struct srz_config srz_cfg[MAX_SRZ_CONFIGS];
+
+	uint8_t num_extra_param;
+	struct extra_param extra_param[MAX_EXTRA_PARAMS];
+	// V3 batch mode added {
+	uint64_t next_frame;
+	// } V3 batch mode added
+#if MTK_V4L2_SKIP_TILE_SUPPORT
+	u32 frameflag;
+#endif
+#if MTK_V4L2_CTRL_META_SUPPORT == 1
+	u8 StreamTag;
+#endif
+
+} __attribute__ ((__packed__));
+#endif
+// } Batch Mode
+
+struct dip_config_data {
+	struct img_addr ref;
+	struct img_addr alloc_buf;
+	struct img_addr output;
+};
+#define SHARED_BUFFER
+#ifdef SHARED_BUFFER
+#define TIME_MAX (192)
+struct img_ipi_frameparam {
+	u8		dmas_enable[IMG_MAX_HW_DMAS][TIME_MAX];
+	struct header_desc	dmas[IMG_MAX_HW_DMAS];
+	struct header_desc	tuning_meta;
+	struct header_desc	ctrl_meta;
+};
+#else
+struct img_ipi_frameparam {
+	u32		index;
+	u32		frame_no;
+	u64		timestamp;
+	u8		type;	/* enum mdp_stream_type */
+	u8		state;
+	u8		num_inputs;
+	u8		num_outputs;
+	u64		drv_data;
+	struct img_input	inputs[IMG_MAX_HW_INPUTS];
+	struct img_output	outputs[IMG_MAX_HW_OUTPUTS];
+	struct tuning_addr	tuning_data;
+
+	struct header_desc	dmas[IMG_MAX_HW_DMAS];
+	struct header_desc	tuning_meta;
+	struct header_desc	ctrl_meta;
+
+#if MTK_V4L2_SKIP_TILE_SUPPORT == 0
+	struct img_addr		subfrm_data;
+#else
+	struct dip_config_data	subfrm_data;
+#endif
+	struct img_sw_addr	config_data;
+	struct img_sw_addr	self_data;
+#if (MTK_V4L2_BATCH_MODE_SUPPORT == 1 || MTK_V4L2_CTL_META_SUPPORT == 1)
+	struct dip_param dip_param;
+#endif
+#ifdef MTK_V4L2_BATCH_MODE_SUPPORT
+	/* pointer to arrays of img_ipi_frameparam and dip_param. */
+	uint64_t framepack_buf_va;
+#endif
+
+} __attribute__ ((__packed__));
+#endif
+struct img_sw_buffer {
+	u64	handle;		/* Used by APMCU access */
+	u32	scp_addr;	/* Used by CM4 access */
+	u32	fd;		/* Used by User Daemon access */
+	u32	offset;		/* Used by User Daemon access */
+} __attribute__ ((__packed__));
+
+struct img_ipi_param {
+	u8	usage;
+	u8	smvr_mode;
+	struct img_sw_buffer frm_param;
+#ifdef MTK_V4L2_BATCH_MODE_SUPPORT
+	// V3 batch mode added {
+	u8	is_batch_mode;
+	u8	num_frames;
+	u64	req_addr_va;
+	u64	frm_param_offset;
+	// } V3 batch mode added
+#endif
+} __attribute__ ((__packed__));
+
+#ifdef __KERNEL__
+struct img_frameparam {
+	struct list_head	list_entry;
+	struct img_ipi_frameparam frameparam;
+};
+#endif
+
+/* ISP-MDP generic output information */
+
+struct img_comp_frame {
+	u32	output_disable:1;
+	u32	bypass:1;
+	u16	in_width;
+	u16	in_height;
+	u16	out_width;
+	u16	out_height;
+	struct img_crop	crop;
+	u16	in_total_width;
+	u16	out_total_width;
+} __attribute__ ((__packed__));
+
+struct img_region {
+	s16	left;
+	s16	right;
+	s16	top;
+	s16	bottom;
+} __attribute__ ((__packed__));
+
+struct img_offset {
+	s16		left;
+	s16		top;
+	u32	left_subpix;
+	u32	top_subpix;
+} __attribute__ ((__packed__));
+
+struct img_comp_subfrm {
+	u32		tile_disable:1;
+	struct img_region	in;
+	struct img_region	out;
+	struct img_offset	luma;
+	struct img_offset	chroma;
+	s16			out_vertical;	/* Output vertical index */
+	s16			out_horizontal;	/* Output horizontal index */
+} __attribute__ ((__packed__));
+
+#define IMG_MAX_SUBFRAMES	14
+
+struct mdp_rdma_subfrm {
+	u32	offset[IMG_MAX_PLANES];
+	u32	offset_0_p;
+	u32	src;
+	u32	clip;
+	u32	clip_ofst;
+} __attribute__ ((__packed__));
+
+struct mdp_rdma_data {
+	u32		src_ctrl;
+	u32		cmpr_ctrl;
+	u32		control;
+	u32		iova[IMG_MAX_PLANES];
+	u32		iova_end[IMG_MAX_PLANES];
+	u32		mf_bkgd;
+	u32		mf_bkgd_in_pxl;
+	u32		sf_bkgd;
+	u32		ufo_dec_y;
+	u32		ufo_dec_c;
+	u32		transform;
+	struct mdp_rdma_subfrm	subfrms[IMG_MAX_SUBFRAMES];
+} __attribute__ ((__packed__));
+
+struct mdp_rsz_subfrm {
+	u32	control2;
+	u32	src;
+	u32	clip;
+} __attribute__ ((__packed__));
+
+struct mdp_rsz_data {
+	u32		coeff_step_x;
+	u32		coeff_step_y;
+	u32		control1;
+	u32		control2;
+	struct mdp_rsz_subfrm	subfrms[IMG_MAX_SUBFRAMES];
+} __attribute__ ((__packed__));
+
+struct mdp_wrot_subfrm {
+	u32	offset[IMG_MAX_PLANES];
+	u32	src;
+	u32	clip;
+	u32	clip_ofst;
+	u32	main_buf;
+} __attribute__ ((__packed__));
+
+struct mdp_wrot_data {
+	u32		iova[IMG_MAX_PLANES];
+	u32		control;
+	u32		scan_10bit;
+	u32		pending_zero;
+	u32		stride[IMG_MAX_PLANES];
+	u32		mat_ctrl;
+	u32		fifo_test;
+	u32		filter;
+	struct mdp_wrot_subfrm	subfrms[IMG_MAX_SUBFRAMES];
+} __attribute__ ((__packed__));
+
+struct mdp_wdma_subfrm {
+	u32	offset[IMG_MAX_PLANES];
+	u32	src;
+	u32	clip;
+	u32	clip_ofst;
+} __attribute__ ((__packed__));
+
+struct mdp_wdma_data {
+	u32		wdma_cfg;
+	u32		iova[IMG_MAX_PLANES];
+	u32		w_in_byte;
+	u32		uv_stride;
+	struct mdp_wdma_subfrm	subfrms[IMG_MAX_SUBFRAMES];
+} __attribute__ ((__packed__));
+
+struct mdp_hdr_subfrm {
+	uint32_t	hist_left;
+} __attribute__ ((__packed__));
+
+struct mdp_hdr_data {
+	uint32_t		rounding;
+	struct mdp_hdr_subfrm	subfrms[IMG_MAX_SUBFRAMES];
+} __attribute__ ((__packed__));
+
+#define MAX_READ_REG_NUM 4
+
+
+struct dip_data {
+	/* subset of ISP_DRIVER_CONFIG_STRUCT */
+	// TODO: DIP settings for GCE cmd
+	unsigned int cq_basePA;
+	//E_ISP_DIP_CQ p2Cq;
+	unsigned long DesCqPa;
+	unsigned long DesCqVa; // for debugging
+	unsigned int *pIspVirRegAddr_pa;
+	unsigned int *pIspVirRegAddr_va;
+	unsigned long tpipeTablePa;
+	unsigned int *tpipeTableVa;
+	unsigned int RingBufIdx;
+	unsigned int burstCqIdx;
+	unsigned int dupCqIdx;
+	unsigned int cqIdx;                     //! index of pass2 cmdQ
+	unsigned int frameflag;
+	unsigned long smx1iPa;
+	unsigned long smx2iPa;
+	unsigned long smx3iPa;
+	unsigned long smx4iPa;
+	//ISP2MDP_STRUCT isp2mdpcfg;
+	char *m_pMetLogBuf;
+	unsigned int m_MetLogBufSize;
+	unsigned int debugRegDump; // dump isp reg from GCE
+	//total width of in-dma for frame mode only
+	unsigned int framemode_total_in_w;
+	//total width od out-dma for frame mode only
+	unsigned int framemode_total_out_w;
+	unsigned int framemode_h;        //height for frame mode only
+	unsigned int total_data_size;     // add for bandwidth
+	unsigned int dmgi_data_size;
+	unsigned int depi_data_size;
+	unsigned int lcei_data_size;
+	unsigned int timgo_data_size;
+	unsigned int regCount;
+	unsigned int ReadAddrList[MAX_READ_REG_NUM];
+	unsigned long imgi_base_addr;
+	unsigned long tpipeTablePa_wpe;
+	unsigned int *tpipeTableVa_wpe;
+	unsigned long tpipeTablePa_mfb;
+	unsigned int *tpipeTableVa_mfb;
+	unsigned int *dl_tpipeTableVa_wpe;
+	unsigned int dupCqIdx_wpe;
+	unsigned int regCount_wpe;
+	unsigned int ReadAddrList_wpe[MAX_READ_REG_NUM];
+	unsigned int *wpecommand;
+	unsigned int *mfbcommand;
+	// DIP settings for GCE cmd
+	unsigned long cqSecHdl;
+	unsigned long cqSecSize;
+	unsigned long DesCqOft;
+	unsigned long DesCqSize;
+	unsigned long VirtRegPa;
+	unsigned long VirtRegVa;
+	unsigned long VirtRegOft;
+	unsigned long tpipeTableSecHdl;
+	unsigned long tpipeTableSecSize;
+	unsigned long tpipeTableOft;
+	unsigned long smxSecHdl;
+	unsigned long smxSecSize;
+	unsigned long smx1iOft;
+	unsigned long smx2iOft;
+	unsigned long smx3iOft;
+	unsigned long smx4iOft;
+	unsigned long dip_ctl_yuv_en;
+	unsigned long dip_ctl_yuv2_en;
+	unsigned long dip_ctl_rgb_en;
+	unsigned long dip_ctl_rgb2_en;
+	unsigned long dip_ctl_dma_en;
+	unsigned long dip_ctl_dma2_en;
+	unsigned long dip_ctl_fmt_sel;
+	unsigned long dip_ctl_fmt2_sel;
+	unsigned long dip_ctl_mux_sel;
+	unsigned long dip_ctl_mux2_sel;
+	unsigned long dip_ctl_misc_sel;
+	unsigned long dip_img2o_base_addr;
+	unsigned long dip_img2bo_base_addr;
+	unsigned long dip_img3o_base_addr;
+	unsigned long dip_img3bo_base_addr;
+	unsigned long dip_img3co_base_addr;
+	unsigned long dip_feo_base_addr;
+	unsigned long dip_dceso_base_addr;
+	unsigned long dip_timgo_base_addr;
+	unsigned long dip_imgi_base_addr;
+	unsigned long dip_imgbi_base_addr;
+	unsigned long dip_imgci_base_addr;
+	unsigned long dip_vipi_base_addr;
+	unsigned long dip_vip2i_base_addr;
+	unsigned long dip_vip3i_base_addr;
+	unsigned long dip_dmgi_base_addr;
+	unsigned long dip_depi_base_addr;
+	unsigned long dip_lcei_base_addr;
+	unsigned long dip_ufdi_base_addr;
+	unsigned long dip_imgbi_base_vaddr;
+	unsigned long dip_imgci_base_vaddr;
+	unsigned long dip_dmgi_base_vaddr;
+	unsigned long dip_depi_base_vaddr;
+	unsigned long dip_lcei_base_vaddr;
+	unsigned int dip_img2o_size[3];
+	unsigned int dip_img3o_size[3];
+	unsigned int dip_feo_size[3];
+	unsigned int dip_dceso_size[3];
+	unsigned int dip_timgo_size[3];
+	unsigned int dip_imgi_size[3];
+	unsigned int dip_imgbi_size[3];
+	unsigned int dip_imgci_size[3];
+	unsigned int dip_vipi_size[3];
+	unsigned int dip_dmgi_size[3];
+	unsigned int dip_depi_size[3];
+	unsigned int dip_lcei_size[3];
+	unsigned int dip_ufdi_size[3];
+	unsigned int dip_secure_tag;
+	unsigned int dip_img2o_secure_tag;
+	unsigned int dip_img2bo_secure_tag;
+	unsigned int dip_img3o_secure_tag;
+	unsigned int dip_img3bo_secure_tag;
+	unsigned int dip_img3co_secure_tag;
+	unsigned int dip_feo_secure_tag;
+	unsigned int dip_dceso_secure_tag;
+	unsigned int dip_timgo_secure_tag;
+	unsigned int dip_imgi_secure_tag;
+	unsigned int dip_imgbi_secure_tag;
+	unsigned int dip_imgci_secure_tag;
+	unsigned int dip_vipi_secure_tag;
+	unsigned int dip_vip2i_secure_tag;
+	unsigned int dip_vip3i_secure_tag;
+	unsigned int dip_dmgi_secure_tag;
+	unsigned int dip_depi_secure_tag;
+	unsigned int dip_lcei_secure_tag;
+	unsigned int dip_ufdi_secure_tag;
+} __attribute__ ((__packed__));
+
+struct isp_data {
+	u64	dl_flags;	/* 1 << (enum mdp_comp_type) */
+	u32	smxi_iova[4];
+	u32	cq_idx;
+	u32	cq_iova;
+	u32	tpipe_iova[IMG_MAX_SUBFRAMES];
+	u32	mfb_iova[IMG_MAX_SUBFRAMES];
+	struct dip_data	dip_data;	// TODO: declared in a platform header
+} __attribute__ ((__packed__));
+
+struct img_compparam {
+	u16		type;	/* enum mdp_comp_type */
+	u16		id;	/* enum mdp_comp_id */
+	u32		input;
+	u32		outputs[IMG_MAX_HW_OUTPUTS];
+	u32		num_outputs;
+	struct img_comp_frame	frame;
+	struct img_comp_subfrm	subfrms[IMG_MAX_SUBFRAMES];
+	u32		num_subfrms;
+	union {
+		struct mdp_rdma_data	rdma;
+		struct mdp_rsz_data	rsz;
+		struct mdp_wrot_data	wrot;
+		struct mdp_wdma_data	wdma;
+		struct mdp_hdr_data	hdr;
+		struct isp_data		isp;
+		/* struct wpe_data	wpe; */
+	};
+} __attribute__ ((__packed__));
+
+#define IMG_MAX_COMPONENTS	20
+
+struct img_mux {
+	u32	reg;
+	u32	value;
+};
+
+struct img_mmsys_ctrl {
+	struct img_mux	sets[IMG_MAX_COMPONENTS * 2];
+	u32	num_sets;
+};
+
+struct img_config {
+	struct img_compparam	components[IMG_MAX_COMPONENTS];
+	u32		num_components;
+	struct img_mmsys_ctrl	ctrls[IMG_MAX_SUBFRAMES];
+	u32		num_subfrms;
+} __attribute__ ((__packed__));
+
+#endif  /* __MTK_IMG_IPI_H__ */
+
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/imgsys/mtk_header_desc.h b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/mtk_header_desc.h
new file mode 100644
index 0000000000000000000000000000000000000000..092d32084bfc0977f9e6cd8067fa7ee951b9f56a
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/mtk_header_desc.h
@@ -0,0 +1,453 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2021 MediaTek Inc.
+ *
+ */
+
+#ifndef _HEADER_DESC_
+#define _HEADER_DESC_
+
+/* TBD */
+#include <linux/videodev2.h>
+/**/
+
+enum imgsysrotation {
+	imgsysrotation_0      = 0, //
+	imgsysrotation_90,         //90 CW
+	imgsysrotation_180,
+	imgsysrotation_270
+};
+
+enum imgsysflip {
+	imgsysflip_off     = 0, //
+	imgsysflip_on      = 1, //
+};
+
+enum img_resize_ratio {
+	img_resize_anyratio,
+	img_resize_down4,
+	img_resize_down2,
+	img_resize_down42,
+	img_resiz_max
+};
+#define COMPACT_USE
+struct v4l2_ext_plane {
+#ifndef COMPACT_USE
+	__u32			bytesused;
+	__u32			length;
+#endif
+	union {
+#ifndef COMPACT_USE
+		__u32		mem_offset;
+		__u64		userptr;
+#endif
+		struct {
+			__s32		fd;
+			__u32		offset;
+		} dma_buf;
+	} m;
+#ifndef COMPACT_USE
+	__u32			data_offset;
+	__u32			reserved[11];
+#else
+	__u64			reserved[2];
+#endif
+};
+#define IMGBUF_MAX_PLANES (3)
+struct v4l2_ext_buffer {
+#ifndef COMPACT_USE
+	__u32			index;
+	__u32			type;
+	__u32			flags;
+	__u32			field;
+	__u64			timestamp;
+	__u32			sequence;
+	__u32			memory;
+#endif
+	struct v4l2_ext_plane	planes[IMGBUF_MAX_PLANES];
+	__u32			num_planes;
+#ifndef COMPACT_USE
+	__u32			reserved[11];
+#else
+	__u64			reserved[2];
+#endif
+};
+
+struct mtk_imgsys_crop {
+	struct v4l2_rect	c;
+	struct v4l2_fract	left_subpix;
+	struct v4l2_fract	top_subpix;
+	struct v4l2_fract	width_subpix;
+	struct v4l2_fract	height_subpix;
+};
+
+struct plane_pix_format {
+	__u32		sizeimage;
+	__u32		bytesperline;
+} __packed;
+
+
+struct pix_format_mplane {
+	__u32				width;
+	__u32				height;
+	__u32				pixelformat;
+	struct plane_pix_format	plane_fmt[IMGBUF_MAX_PLANES];
+} __packed;
+
+
+struct buf_format {
+	union {
+		struct pix_format_mplane	pix_mp;  /* V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE */
+	} fmt;
+};
+
+struct buf_info {
+	struct v4l2_ext_buffer buf;
+	struct buf_format fmt;
+	struct mtk_imgsys_crop crop;
+	/* struct v4l2_rect compose; */
+	__u32 rotation;
+	__u32 hflip;
+	__u32 vflip;
+	__u8  resizeratio;
+	__u32  secu;
+};
+
+#define FRAME_BUF_MAX (1)
+struct frameparams {
+	struct buf_info bufs[FRAME_BUF_MAX];
+};
+
+#define SCALE_MAX (1)
+#define TIME_MAX (192)
+
+struct header_desc {
+	__u32 fparams_tnum;
+	struct frameparams fparams[TIME_MAX][SCALE_MAX];
+};
+
+#define TMAX (16)
+struct header_desc_norm {
+	__u32 fparams_tnum;
+	struct frameparams fparams[TMAX][SCALE_MAX];
+};
+
+#define IMG_MAX_HW_INPUTS	3
+
+#define IMG_MAX_HW_OUTPUTS	4
+/* TODO */
+#if defined(IMGSYS_VER_ISP71)
+#define IMG_MAX_HW_DMAS     72
+#elif defined(IMGSYS_VER_ISP70)
+#define IMG_MAX_HW_DMAS     67
+#endif
+struct singlenode_desc {
+	__u8 dmas_enable[IMG_MAX_HW_DMAS][TIME_MAX];
+	struct header_desc	dmas[IMG_MAX_HW_DMAS];
+	struct header_desc	tuning_meta;
+	struct header_desc	ctrl_meta;
+};
+
+struct singlenode_desc_norm {
+	__u8 dmas_enable[IMG_MAX_HW_DMAS][TMAX];
+	struct header_desc_norm	dmas[IMG_MAX_HW_DMAS];
+	struct header_desc_norm	tuning_meta;
+	struct header_desc_norm	ctrl_meta;
+};
+
+#define V4L2_META_FMT_MTISP_DESC   v4l2_fourcc('M', 'T', 'f', 'd')
+	/* ISP description fmt*/
+#define V4L2_META_FMT_MTISP_SD   v4l2_fourcc('M', 'T', 'f', 's')
+	/* ISP singledevice fmt*/
+#define V4L2_META_FMT_MTISP_DESC_NORM   v4l2_fourcc('M', 'T', 'f', 'r')
+	/* ISP SMVR DESC fmt*/
+#define V4L2_META_FMT_MTISP_SDNORM   v4l2_fourcc('M', 'T', 's', 'r')
+	/* ISP SMVR SD fmt*/
+#define V4L2_PIX_FMT_WARP2P      v4l2_fourcc('M', 'W', '2', 'P')
+	/* Mediatek warp map 32-bit, 2 plane */
+#define V4L2_PIX_FMT_YUV422      v4l2_fourcc('Y', 'U', '1', '6')
+	/* YUV-8bit packed 4:2:2 3plane */
+#define V4L2_PIX_FMT_YUYV_Y210P    v4l2_fourcc('Y', 'U', '1', 'A')
+	/* YUV-10bit packed 4:2:2 1plane, YUYV  */
+#define V4L2_PIX_FMT_YVYU_Y210P    v4l2_fourcc('Y', 'V', '1', 'A')
+	/* YUV-10bit packed 4:2:2 1plane, YVYU  */
+#define V4L2_PIX_FMT_UYVY_Y210P    v4l2_fourcc('U', 'Y', '1', 'A')
+	/* YUV-10bit packed 4:2:2 1plane, UYVY  */
+#define V4L2_PIX_FMT_VYUY_Y210P    v4l2_fourcc('V', 'Y', '1', 'A')
+	/* YUV-10bit packed 4:2:2 1plane, VYUY  */
+#define V4L2_PIX_FMT_YUV_2P210P    v4l2_fourcc('U', '2', '2', 'A')
+	/* YUV-10bit packed 4:2:2 2plane, (Y)(UV)  */
+#define V4L2_PIX_FMT_YVU_2P210P    v4l2_fourcc('V', '2', '2', 'A')
+	/* YUV-10bit packed 4:2:2 2plane, (Y)(VU)  */
+#define V4L2_PIX_FMT_YUV_3P210P    v4l2_fourcc('Y', '2', '3', 'A')
+	/* YUV-10bit packed 4:2:2 3plane */
+#define V4L2_PIX_FMT_YUV_2P010P    v4l2_fourcc('U', '0', '2', 'A')
+	/* YUV-10bit packed 4:2:0 2plane, (Y)(UV)  */
+#define V4L2_PIX_FMT_YVU_2P010P    v4l2_fourcc('V', '0', '2', 'A')
+	/* YUV-10bit packed 4:2:0 2plane, (Y)(VU)  */
+#define V4L2_PIX_FMT_YUV_3P010P    v4l2_fourcc('Y', '0', '3', 'A')
+	/* YUV-10bit packed 4:2:0 3plane */
+#define V4L2_PIX_FMT_YUYV_Y210    v4l2_fourcc('Y', 'U', '1', 'a')
+	/* YUV-10bit unpacked 4:2:2 1plane, YUYV  */
+#define V4L2_PIX_FMT_YVYU_Y210    v4l2_fourcc('Y', 'V', '1', 'a')
+	/* YUV-10bit unpacked 4:2:2 1plane, YVYU  */
+#define V4L2_PIX_FMT_UYVY_Y210    v4l2_fourcc('U', 'Y', '1', 'a')
+	/* YUV-10bit unpacked 4:2:2 1plane, UYVY  */
+#define V4L2_PIX_FMT_VYUY_Y210    v4l2_fourcc('V', 'Y', '1', 'a')
+	/* YUV-10bit unpacked 4:2:2 1plane, VYUY  */
+#define V4L2_PIX_FMT_YUV_2P210    v4l2_fourcc('U', '2', '2', 'a')
+	/* YUV-10bit unpacked 4:2:2 2plane, (Y)(UV)  */
+#define V4L2_PIX_FMT_YVU_2P210    v4l2_fourcc('V', '2', '2', 'a')
+	/* YUV-10bit unpacked 4:2:2 2plane, (Y)(VU)  */
+#define V4L2_PIX_FMT_YUV_3P210    v4l2_fourcc('Y', '2', '3', 'a')
+	/* YUV-10bit unpacked 4:2:2 3plane */
+#define V4L2_PIX_FMT_YUV_2P010    v4l2_fourcc('U', '0', '2', 'a')
+	/* YUV-10bit unpacked 4:2:0 2plane, (Y)(UV)  */
+#define V4L2_PIX_FMT_YVU_2P010    v4l2_fourcc('V', '0', '2', 'a')
+	/* YUV-10bit unpacked 4:2:0 2plane, (Y)(VU)  */
+#define V4L2_PIX_FMT_YUV_3P010    v4l2_fourcc('Y', '0', '3', 'a')
+	/* YUV-10bit unpacked 4:2:0 3plane */
+#define V4L2_PIX_FMT_YUV_2P012P    v4l2_fourcc('U', '0', '2', 'C')
+	/* YUV-12bit packed 4:2:0 2plane, (Y)(UV)  */
+#define V4L2_PIX_FMT_YVU_2P012P    v4l2_fourcc('V', '0', '2', 'C')
+	/* YUV-12bit packed 4:2:0 2plane, (Y)(VU)  */
+#define V4L2_PIX_FMT_YUV_2P012    v4l2_fourcc('U', '0', '2', 'c')
+	/* YUV-12bit unpacked 4:2:0 2plane, (Y)(UV)  */
+#define V4L2_PIX_FMT_YVU_2P012    v4l2_fourcc('V', '0', '2', 'c')
+	/* YUV-12bit unpacked 4:2:0 2plane, (Y)(VU)  */
+#define V4L2_PIX_FMT_MTISP_RGB3PP8  v4l2_fourcc('M', 'r', '3', '8')
+	/* RGB-8bit-3P-Packed, (R)(G)(B) */
+#define V4L2_PIX_FMT_MTISP_RGB3PP10 v4l2_fourcc('M', 'r', '3', 'a')
+	/* RGB-10bit-3P-Packed, (R)(G)(B) */
+#define V4L2_PIX_FMT_MTISP_RGB3PP12 v4l2_fourcc('M', 'r', '3', 'c')
+	/* RGB-12bit-3P-Packed, (R)(G)(B) */
+#define V4L2_PIX_FMT_MTISP_RGB3PU8 v4l2_fourcc('M', 'R', '3', '8')
+	/* RGB-8bit-3P-Unpacked, (R)(G)(B) */
+#define V4L2_PIX_FMT_MTISP_RGB3PU10 v4l2_fourcc('M', 'R', '3', 'A')
+	/* RGB-10bit-3P-Unpacked, (R)(G)(B) */
+#define V4L2_PIX_FMT_MTISP_RGB3PU12 v4l2_fourcc('M', 'R', '3', 'C')
+	/* RGB-12bit-3P-Unpacked, (R)(G)(B) */
+#define V4L2_PIX_FMT_MTISP_FGRBP8 v4l2_fourcc('M', 'F', 'g', '8')
+	/* FG-8bit-2P-Packed */
+#define V4L2_PIX_FMT_MTISP_FGRBP10 v4l2_fourcc('M', 'F', 'g', 'a')
+	/* FG-10bit-2P-Packed */
+#define V4L2_PIX_FMT_MTISP_FGRBP12 v4l2_fourcc('M', 'F', 'g', 'c')
+	/* FG-12bit-2P-Packed */
+#define V4L2_PIX_FMT_MTISP_FGRBU8 v4l2_fourcc('M', 'F', 'G', '8')
+	/* FG-8bit-2P-Unpacked */
+#define V4L2_PIX_FMT_MTISP_FGRBU10 v4l2_fourcc('M', 'F', 'G', 'A')
+      /* FG-10bit-2P-Unpacked */
+#define V4L2_PIX_FMT_MTISP_FGRBU12 v4l2_fourcc('M', 'F', 'G', 'C')
+	/* FG-12bit-2P-Unpacked */
+#define V4L2_PIX_FMT_MTISP_FGRB3P8 v4l2_fourcc('M', 'f', '3', '8')
+	/* FG-8bit-3P-Packed */
+#define V4L2_PIX_FMT_MTISP_FGRB3P10 v4l2_fourcc('M', 'f', '3', 'a')
+	/* FG-10bit-3P-Packed */
+#define V4L2_PIX_FMT_MTISP_FGRB3P12 v4l2_fourcc('M', 'f', '3', 'c')
+	/* FG-12bit-3P-Packed */
+#define V4L2_PIX_FMT_MTISP_FGRB3U8 v4l2_fourcc('M', 'F', '3', '8')
+	/* FG-8bit-3P-Unpacked */
+#define V4L2_PIX_FMT_MTISP_FGRB3U10 v4l2_fourcc('M', 'F', '3', 'A')
+	/* FG-10bit-3P-Unpacked */
+#define V4L2_PIX_FMT_MTISP_FGRB3U12 v4l2_fourcc('M', 'F', '3', 'C')
+	/* FG-12bit-3P-Unpacked */
+#define V4L2_PIX_FMT_MTISP_RGB48 v4l2_fourcc('M', 'R', '1', '6')
+	/* RGB-48bit */
+#define V4L2_PIX_FMT_MTISP_Y32   v4l2_fourcc('M', 'T', '3', '2')
+	/* Y-32bit */
+#define V4L2_PIX_FMT_MTISP_Y16   v4l2_fourcc('M', 'T', '1', '6')
+	/* Y-16bit */
+#define V4L2_PIX_FMT_MTISP_Y8   v4l2_fourcc('M', 'T', '0', '8')
+	/* Y-8bit */
+#define V4L2_PIX_FMT_MTISP_SBGGRU10  v4l2_fourcc('M', 'b', 'B', 'A')
+	/* Bayer-10bit-Unpacked, (B)(G)(G)(R) */
+#define V4L2_PIX_FMT_MTISP_SGBRGU10  v4l2_fourcc('M', 'b', 'G', 'A')
+	/* Bayer-10bit-Unpacked, (G)(B)(R)(G) */
+#define V4L2_PIX_FMT_MTISP_SGRBGU10  v4l2_fourcc('M', 'b', 'g', 'A')
+	/* Bayer-10bit-Unpacked, (G)(R)(B)(G) */
+#define V4L2_PIX_FMT_MTISP_SRGGBU10  v4l2_fourcc('M', 'b', 'R', 'A')
+	/* Bayer-10bit-Unpacked, (R)(G)(G)(B) */
+#define V4L2_PIX_FMT_MTISP_SBGGRU12  v4l2_fourcc('M', 'b', 'B', 'C')
+	/* Bayer-12bit-Unpacked, (B)(G)(G)(R) */
+#define V4L2_PIX_FMT_MTISP_SGBRGU12  v4l2_fourcc('M', 'b', 'G', 'C')
+	/* Bayer-12bit-Unpacked, (G)(B)(R)(G) */
+#define V4L2_PIX_FMT_MTISP_SGRBGU12  v4l2_fourcc('M', 'b', 'g', 'C')
+	/* Bayer-12bit-Unpacked, (G)(R)(B)(G) */
+#define V4L2_PIX_FMT_MTISP_SRGGBU12  v4l2_fourcc('M', 'b', 'R', 'C')
+	/* Bayer-12bit-Unpacked, (R)(G)(G)(B) */
+
+/* Vendor specific - Mediatek ISP bayer formats: from videodev2.h */
+#define V4L2_PIX_FMT_MTISP_SBGGR10  v4l2_fourcc('M', 'B', 'B', 'A')
+/*  Packed 10-bit  */
+#define V4L2_PIX_FMT_MTISP_SGBRG10  v4l2_fourcc('M', 'B', 'G', 'A')
+/*  Packed 10-bit  */
+#define V4L2_PIX_FMT_MTISP_SGRBG10  v4l2_fourcc('M', 'B', 'g', 'A')
+/*  Packed 10-bit  */
+#define V4L2_PIX_FMT_MTISP_SRGGB10  v4l2_fourcc('M', 'B', 'R', 'A')
+/*  Packed 10-bit  */
+#define V4L2_PIX_FMT_MTISP_SBGGR12  v4l2_fourcc('M', 'B', 'B', 'C')
+/*  Packed 12-bit  */
+#define V4L2_PIX_FMT_MTISP_SGBRG12  v4l2_fourcc('M', 'B', 'G', 'C')
+/*  Packed 12-bit  */
+#define V4L2_PIX_FMT_MTISP_SGRBG12  v4l2_fourcc('M', 'B', 'g', 'C')
+/*  Packed 12-bit  */
+#define V4L2_PIX_FMT_MTISP_SRGGB12  v4l2_fourcc('M', 'B', 'R', 'C')
+/*  Packed 12-bit  */
+#define V4L2_PIX_FMT_MTISP_SBGGR14  v4l2_fourcc('M', 'B', 'B', 'E')
+/*  Packed 14-bit  */
+#define V4L2_PIX_FMT_MTISP_SGBRG14  v4l2_fourcc('M', 'B', 'G', 'E')
+/*  Packed 14-bit  */
+#define V4L2_PIX_FMT_MTISP_SGRBG14  v4l2_fourcc('M', 'B', 'g', 'E')
+/*  Packed 14-bit  */
+#define V4L2_PIX_FMT_MTISP_SRGGB14  v4l2_fourcc('M', 'B', 'R', 'E')
+/*  Packed 14-bit  */
+#define V4L2_PIX_FMT_MTISP_SBGGR8F   v4l2_fourcc('M', 'F', 'B', '8')
+/*  Full-G  8-bit  */
+#define V4L2_PIX_FMT_MTISP_SGBRG8F   v4l2_fourcc('M', 'F', 'G', '8')
+/*  Full-G  8-bit  */
+#define V4L2_PIX_FMT_MTISP_SGRBG8F   v4l2_fourcc('M', 'F', 'g', '8')
+/*  Full-G  8-bit  */
+#define V4L2_PIX_FMT_MTISP_SRGGB8F   v4l2_fourcc('M', 'F', 'R', '8')
+/*  Full-G  8-bit  */
+#define V4L2_PIX_FMT_MTISP_SBGGR10F  v4l2_fourcc('M', 'F', 'B', 'A')
+/*  Full-G 10-bit  */
+#define V4L2_PIX_FMT_MTISP_SGBRG10F  v4l2_fourcc('M', 'F', 'G', 'A')
+/*  Full-G 10-bit  */
+#define V4L2_PIX_FMT_MTISP_SGRBG10F  v4l2_fourcc('M', 'F', 'g', 'A')
+/*  Full-G 10-bit  */
+#define V4L2_PIX_FMT_MTISP_SRGGB10F  v4l2_fourcc('M', 'F', 'R', 'A')
+/*  Full-G 10-bit  */
+#define V4L2_PIX_FMT_MTISP_SBGGR12F  v4l2_fourcc('M', 'F', 'B', 'C')
+/*  Full-G 12-bit  */
+#define V4L2_PIX_FMT_MTISP_SGBRG12F  v4l2_fourcc('M', 'F', 'G', 'C')
+/*  Full-G 12-bit  */
+#define V4L2_PIX_FMT_MTISP_SGRBG12F  v4l2_fourcc('M', 'F', 'g', 'C')
+/*  Full-G 12-bit  */
+#define V4L2_PIX_FMT_MTISP_SRGGB12F  v4l2_fourcc('M', 'F', 'R', 'C')
+/*  Full-G 12-bit  */
+#define V4L2_PIX_FMT_MTISP_SBGGR14F  v4l2_fourcc('M', 'F', 'B', 'E')
+/*  Full-G 14-bit  */
+#define V4L2_PIX_FMT_MTISP_SGBRG14F  v4l2_fourcc('M', 'F', 'G', 'E')
+/*  Full-G 14-bit  */
+#define V4L2_PIX_FMT_MTISP_SGRBG14F  v4l2_fourcc('M', 'F', 'g', 'E')
+/*  Full-G 14-bit  */
+#define V4L2_PIX_FMT_MTISP_SRGGB14F  v4l2_fourcc('M', 'F', 'R', 'E')
+/*  Full-G 14-bit  */
+/* Vendor specific - Mediatek Luminance+Chrominance formats */
+#define V4L2_PIX_FMT_MTISP_YUYV10P v4l2_fourcc('Y', 'U', 'A', 'P')
+/* 16  YUV 4:2:2 10-bit packed */
+#define V4L2_PIX_FMT_MTISP_YVYU10P v4l2_fourcc('Y', 'V', 'A', 'P')
+/* 16  YUV 4:2:2 10-bit packed */
+#define V4L2_PIX_FMT_MTISP_UYVY10P v4l2_fourcc('U', 'Y', 'A', 'P')
+/* 16  YUV 4:2:2 10-bit packed */
+#define V4L2_PIX_FMT_MTISP_VYUY10P v4l2_fourcc('V', 'Y', 'A', 'P')
+/* 16  YUV 4:2:2 10-bit packed */
+#define V4L2_PIX_FMT_MTISP_NV12_10P v4l2_fourcc('1', '2', 'A', 'P')
+/* 12  Y/CbCr 4:2:0 10 bits packed */
+#define V4L2_PIX_FMT_MTISP_NV21_10P v4l2_fourcc('2', '1', 'A', 'P')
+/* 12  Y/CrCb 4:2:0 10 bits packed */
+#define V4L2_PIX_FMT_MTISP_NV16_10P v4l2_fourcc('1', '6', 'A', 'P')
+/* 16  Y/CbCr 4:2:2 10 bits packed */
+#define V4L2_PIX_FMT_MTISP_NV61_10P v4l2_fourcc('6', '1', 'A', 'P')
+/* 16  Y/CrCb 4:2:2 10 bits packed */
+#define V4L2_PIX_FMT_MTISP_SBGGRU14  v4l2_fourcc('M', 'b', 'B', 'E')
+	/* Bayer-14bit-Unpacked, (B)(G)(G)(R) */
+#define V4L2_PIX_FMT_MTISP_SGBRGU14  v4l2_fourcc('M', 'b', 'G', 'E')
+	/* Bayer-14bit-Unpacked, (G)(B)(R)(G) */
+#define V4L2_PIX_FMT_MTISP_SGRBGU14  v4l2_fourcc('M', 'b', 'g', 'E')
+	/* Bayer-14bit-Unpacked, (G)(R)(B)(G) */
+#define V4L2_PIX_FMT_MTISP_SRGGBU14  v4l2_fourcc('M', 'b', 'R', 'E')
+	/* Bayer-14bit-Unpacked, (R)(G)(G)(B) */
+#define V4L2_PIX_FMT_MTISP_SBGGRU15  v4l2_fourcc('M', 'b', 'B', 'F')
+	/* Bayer-15bit-Unpacked, (B)(G)(G)(R) */
+#define V4L2_PIX_FMT_MTISP_SGBRGU15  v4l2_fourcc('M', 'b', 'G', 'F')
+	/* Bayer-15bit-Unpacked, (G)(B)(R)(G) */
+#define V4L2_PIX_FMT_MTISP_SGRBGU15  v4l2_fourcc('M', 'b', 'g', 'F')
+	/* Bayer-15bit-Unpacked, (G)(R)(B)(G) */
+#define V4L2_PIX_FMT_MTISP_SRGGBU15  v4l2_fourcc('M', 'b', 'R', 'F')
+	/* Bayer-15bit-Unpacked, (R)(G)(G)(B) */
+#define V4L2_PIX_FMT_MTISP_SBGGR16  v4l2_fourcc('M', 'B', 'B', 'G')
+	/* Bayer-16bit-Packed, (B)(G)(G)(R) */
+#define V4L2_PIX_FMT_MTISP_SGBRG16  v4l2_fourcc('M', 'B', 'G', 'G')
+	/* Bayer-16bit-Packed, (G)(B)(R)(G) */
+#define V4L2_PIX_FMT_MTISP_SGRBG16  v4l2_fourcc('M', 'B', 'g', 'G')
+	/* Bayer-16bit-Packed, (G)(R)(B)(G) */
+#define V4L2_PIX_FMT_MTISP_SRGGB16  v4l2_fourcc('M', 'B', 'R', 'G')
+	/* Bayer-16bit-Packed, (R)(G)(G)(B) */
+#define V4L2_PIX_FMT_MTISP_SBGGR22  v4l2_fourcc('M', 'B', 'B', 'M')
+	/* Bayer-22bit-Packed, (B)(G)(G)(R) */
+#define V4L2_PIX_FMT_MTISP_SGBRG22  v4l2_fourcc('M', 'B', 'G', 'M')
+	/* Bayer-22bit-Packed, (G)(B)(R)(G) */
+#define V4L2_PIX_FMT_MTISP_SGRBG22  v4l2_fourcc('M', 'B', 'g', 'M')
+	/* Bayer-22bit-Packed, (G)(R)(B)(G) */
+#define V4L2_PIX_FMT_MTISP_SRGGB22  v4l2_fourcc('M', 'B', 'R', 'M')
+	/* Bayer-22bit-Packed, (R)(G)(G)(B) */
+#define V4L2_PIX_FMT_UFBC_NV12    v4l2_fourcc('U', 'F', '2', '8')
+	/* YUV-8bit UFBC packed 4:2:0 2plane, (Y)(UV)  */
+#define V4L2_PIX_FMT_UFBC_NV21    v4l2_fourcc('V', 'F', '2', '8')
+	/* YUV-8bit UFBC packed 4:2:0 2plane, (Y)(VU)  */
+#define V4L2_PIX_FMT_UFBC_YUV_2P010P    v4l2_fourcc('U', 'F', '2', 'A')
+	/* YUV-10bit UFBC packed 4:2:0 2plane, (Y)(UV)  */
+#define V4L2_PIX_FMT_UFBC_YVU_2P010P    v4l2_fourcc('V', 'F', '2', 'A')
+	/* YUV-10bit UFBC packed 4:2:0 2plane, (Y)(VU)  */
+#define V4L2_PIX_FMT_UFBC_YUV_2P012P    v4l2_fourcc('U', 'F', '2', 'C')
+	/* YUV-12bit UFBC packed 4:2:0 2plane, (Y)(UV)  */
+#define V4L2_PIX_FMT_UFBC_YVU_2P012P    v4l2_fourcc('V', 'F', '2', 'C')
+	/* YUV-12bit UFBC packed 4:2:0 2plane, (Y)(VU)  */
+#define V4L2_PIX_FMT_MTISP_UFBC_SBGGR8 v4l2_fourcc('U', 'B', 'B', '8')
+	/* UFBC Bayer format, 8 bits, 1 plane, may be (BGGR) */
+#define V4L2_PIX_FMT_MTISP_UFBC_SGBRG8 v4l2_fourcc('U', 'B', 'G', '8')
+	/* UFBC Bayer format, 8 bits, 1 plane, may be (GBRG) */
+#define V4L2_PIX_FMT_MTISP_UFBC_SGRBG8 v4l2_fourcc('U', 'B', 'g', '8')
+	/* UFBC Bayer format, 8 bits, 1 plane, may be (GRBG) */
+#define V4L2_PIX_FMT_MTISP_UFBC_SRGGB8 v4l2_fourcc('U', 'B', 'R', '8')
+	/* UFBC Bayer format, 8 bits, 1 plane, may be (RGGB) */
+#define V4L2_PIX_FMT_MTISP_UFBC_SBGGR10 v4l2_fourcc('U', 'B', 'B', 'A')
+	/* UFBC Bayer format, 10 bits, 1 plane, may be (BGGR) */
+#define V4L2_PIX_FMT_MTISP_UFBC_SGBRG10 v4l2_fourcc('U', 'B', 'G', 'A')
+	/* UFBC Bayer format, 10 bits, 1 plane, may be (GBRG) */
+#define V4L2_PIX_FMT_MTISP_UFBC_SGRBG10 v4l2_fourcc('U', 'B', 'g', 'A')
+	/* UFBC Bayer format, 10 bits, 1 plane, may be (GRBG) */
+#define V4L2_PIX_FMT_MTISP_UFBC_SRGGB10 v4l2_fourcc('U', 'B', 'R', 'A')
+	/* UFBC Bayer format, 10 bits, 1 plane, may be (RGGB) */
+#define V4L2_PIX_FMT_MTISP_UFBC_SBGGR12 v4l2_fourcc('U', 'B', 'B', 'C')
+	/* UFBC Bayer format, 12 bits, 1 plane, may be (BGGR) */
+#define V4L2_PIX_FMT_MTISP_UFBC_SGBRG12 v4l2_fourcc('U', 'B', 'G', 'C')
+	/* UFBC Bayer format, 12 bits, 1 plane, may be (GBRG) */
+#define V4L2_PIX_FMT_MTISP_UFBC_SGRBG12 v4l2_fourcc('U', 'B', 'g', 'C')
+	/* UFBC Bayer format, 12 bits, 1 plane, may be (GRBG) */
+#define V4L2_PIX_FMT_MTISP_UFBC_SRGGB12 v4l2_fourcc('U', 'B', 'R', 'C')
+	/* UFBC Bayer format, 12 bits, 1 plane, may be (RGGB) */
+#define V4L2_PIX_FMT_MTISP_UFBC_SBGGR14 v4l2_fourcc('U', 'B', 'B', 'E')
+	/* UFBC Bayer format, 14 bits, 1 plane, may be (BGGR) */
+#define V4L2_PIX_FMT_MTISP_UFBC_SGBRG14 v4l2_fourcc('U', 'B', 'G', 'E')
+	/* UFBC Bayer format, 14 bits, 1 plane, may be (GBRG) */
+#define V4L2_PIX_FMT_MTISP_UFBC_SGRBG14 v4l2_fourcc('U', 'B', 'g', 'E')
+	/* UFBC Bayer format, 14 bits, 1 plane, may be (GRBG) */
+#define V4L2_PIX_FMT_MTISP_UFBC_SRGGB14 v4l2_fourcc('U', 'B', 'R', 'E')
+	/* UFBC Bayer format, 14 bits, 1 plane, may be (RGGB) */
+#define V4L2_PIX_FMT_AFBC_RGBA32 v4l2_fourcc('A', 'F', 'R', '8')
+	/* RGB-8bit AFBC packed, (R)(G)(B)(A) */
+#define V4L2_PIX_FMT_AFBC_BGRA32 v4l2_fourcc('A', 'F', 'B', '8')
+	/* RGB-8bit AFBC packed, (B)(G)(R)(A) */
+#define V4L2_PIX_FMT_AFBC_NV12 v4l2_fourcc('A', 'F', 'U', '8')
+	/* YUV-8bit AFBC packed 4:2:0 2plane, (Y)(UV) */
+#define V4L2_PIX_FMT_AFBC_NV21 v4l2_fourcc('A', 'F', 'V', '8')
+	/* YUV-8bit AFBC packed 4:2:0 2plane, (Y)(VU) */
+#define V4L2_PIX_FMT_AFBC_YUV_2P010P v4l2_fourcc('A', 'F', 'U', 'A')
+	/* YUV-10bit AFBC packed 4:2:0 2plane, (Y)(UV) */
+#define V4L2_PIX_FMT_AFBC_YVU_2P010P v4l2_fourcc('A', 'F', 'V', 'A')
+	/* YUV-10bit AFBC packed 4:2:0 2plane, (Y)(VU) */
+#define V4L2_PIX_FMT_MTISP_SBGGRM10 v4l2_fourcc('M', 'M', 'B', 'A')
+	/* MIPI-10bit-Packed, (B)(G)(G)(R) */
+#define V4L2_PIX_FMT_MTISP_SGBRGM10 v4l2_fourcc('M', 'M', 'G', 'A')
+	/* MIPI-10bit-Packed, (G)(B)(R)(G) */
+#define V4L2_PIX_FMT_MTISP_SGRBGM10 v4l2_fourcc('M', 'M', 'g', 'A')
+	/* MIPI-10bit-Packed, (G)(R)(B)(G) */
+#define V4L2_PIX_FMT_MTISP_SRGGBM10 v4l2_fourcc('M', 'M', 'R', 'A')
+	/* MIPI-10bit-Packed, (R)(G)(G)(B) */
+
+/* Vendor specific - Mediatek ISP parameters for firmware */
+#define V4L2_META_FMT_MTISP_PARAMS v4l2_fourcc('M', 'T', 'f', 'p')
+
+#endif
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/imgsys/mtk_imgsys-cmdq-ext.h b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/mtk_imgsys-cmdq-ext.h
new file mode 100644
index 0000000000000000000000000000000000000000..a297d7c188ecc4267f390d5610bbb543eba81c92
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/mtk_imgsys-cmdq-ext.h
@@ -0,0 +1,10 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2021 MediaTek Inc.
+ *
+ * Author: Daniel Huang <daniel.huang@mediatek.com>
+ *
+ */
+
+void imgsys_cmdq_setevent(u64 u_id);
+
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/imgsys/mtk_imgsys-cmdq.c b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/mtk_imgsys-cmdq.c
new file mode 100755
index 0000000000000000000000000000000000000000..78fdb70b07cf9ed57bdcc720b63a0dde8a167df1
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/mtk_imgsys-cmdq.c
@@ -0,0 +1,2069 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2018 MediaTek Inc.
+ *
+ * Author: Daniel Huang <daniel.huang@mediatek.com>
+ *
+ */
+#include <linux/dma-mapping.h>
+#include <linux/mailbox_controller.h>
+#include <linux/platform_device.h>
+#include <linux/soc/mediatek/mtk-cmdq.h>
+#include <linux/pm_opp.h>
+#include <linux/pm_runtime.h>
+#include <linux/regulator/consumer.h>
+#include "mtk_imgsys-engine.h"
+#include "mtk_imgsys-cmdq.h"
+#include "mtk_imgsys-cmdq-ext.h"
+#include "mtk_imgsys-cmdq-plat.h"
+#include "mtk_imgsys-trace.h"
+//#include "mtk-interconnect.h"
+#if IMGSYS_SECURE_ENABLE
+#include "cmdq-sec.h"
+#include "cmdq-sec-iwc-common.h"
+#endif
+
+
+
+#define WPE_BWLOG_HW_COMB (IMGSYS_ENG_WPE_TNR | IMGSYS_ENG_DIP)
+#define WPE_BWLOG_HW_COMB_ninA (IMGSYS_ENG_WPE_EIS | IMGSYS_ENG_PQDIP_A)
+#define WPE_BWLOG_HW_COMB_ninB (IMGSYS_ENG_WPE_EIS | IMGSYS_ENG_PQDIP_B)
+
+int imgsys_cmdq_ts_en;
+module_param(imgsys_cmdq_ts_en, int, 0644);
+
+int imgsys_wpe_bwlog_en;
+module_param(imgsys_wpe_bwlog_en, int, 0644);
+
+int imgsys_cmdq_ts_dbg_en;
+module_param(imgsys_cmdq_ts_dbg_en, int, 0644);
+
+int imgsys_dvfs_dbg_en;
+module_param(imgsys_dvfs_dbg_en, int, 0644);
+
+int imgsys_qos_update_freq;
+module_param(imgsys_qos_update_freq, int, 0644);
+
+int imgsys_qos_blank_int;
+module_param(imgsys_qos_blank_int, int, 0644);
+
+int imgsys_qos_factor;
+module_param(imgsys_qos_factor, int, 0644);
+
+struct workqueue_struct *imgsys_cmdq_wq;
+static u32 is_stream_off;
+#if IMGSYS_SECURE_ENABLE
+static u32 is_sec_task_create;
+#endif
+static struct imgsys_event_history event_hist[IMGSYS_CMDQ_SYNC_POOL_NUM];
+static void imgsys_cmdq_task_cb(struct mbox_client *cl, void *mssg);
+
+
+// cmdq_pkt_destroy
+void imgsys_destroy_pkt(struct cmdq_pkt *pkt)
+{
+	struct cmdq_client *client = (struct cmdq_client *)pkt->cl;
+
+	dma_unmap_single(client->chan->mbox->dev, pkt->pa_base, pkt->buf_size,
+			 DMA_TO_DEVICE);
+	kfree(pkt->va_base);
+}
+
+//cmdq_pkt_create
+static int imgsys_create_pkt(struct cmdq_pkt *pkt, struct cmdq_client *client, u32 size)
+{
+	struct device *dev;
+	dma_addr_t dma_addr;
+
+	pkt->va_base = kzalloc(size, GFP_KERNEL);
+
+	if (!pkt->va_base) {
+		return ERR_PTR(-ENOMEM);
+	}
+
+	pkt->buf_size = size;
+	pkt->cl = (void *)client;
+
+	if ((pkt->cl) == NULL) {
+		return ERR_PTR(-EINVAL);
+	}
+
+	if ((client->chan) == NULL) {
+		return ERR_PTR(-EINVAL);
+	}
+
+	if ((client->chan->mbox) == NULL) {
+		return ERR_PTR(-EINVAL);
+	}
+
+	dev = client->chan->mbox->dev;
+	dma_addr = dma_map_single(dev, pkt->va_base, pkt->buf_size,
+				  DMA_TO_DEVICE);
+
+	if (dma_mapping_error(dev, dma_addr)) {
+		dev_err(dev, "dma map failed, size=%u\n", (u32)(u64)size);
+		kfree(pkt->va_base);
+		return ERR_PTR(-ENOMEM);
+	}
+
+	pkt->pa_base = dma_addr;
+
+	return 0;
+}
+
+void imgsys_cmdq_init(struct mtk_imgsys_dev *imgsys_dev, const int nr_imgsys_dev)
+{
+	struct device *dev = imgsys_dev->dev;
+	u32 idx = 0;
+
+	pr_info("%s: +, dev(%p), num(%d)\n", __func__, dev, nr_imgsys_dev);
+
+	/* Only first user has to do init work queue */
+	if (nr_imgsys_dev == 1) {
+		imgsys_cmdq_wq = alloc_ordered_workqueue("%s",
+				__WQ_LEGACY | WQ_MEM_RECLAIM |
+				WQ_FREEZABLE,
+				"imgsys_cmdq_cb_wq");
+		if (!imgsys_cmdq_wq)
+			pr_info("%s: Create workquque IMGSYS-CMDQ fail!\n",
+								__func__);
+	}
+
+	switch (nr_imgsys_dev) {
+	case 1: /* DIP */
+		/* request thread by index (in dts) 0 */
+		for (idx = 0; idx < IMGSYS_ENG_MAX; idx++) {
+			imgsys_clt[idx] = kzalloc(sizeof(*imgsys_clt[idx]), GFP_KERNEL);
+			if (!imgsys_clt[idx])
+				pr_info("%s: kzalloc fail(%d, %p)\n", __func__, idx, imgsys_clt[idx]);
+			imgsys_clt[idx]->client.dev = dev;
+			imgsys_clt[idx]->client.tx_block = false;
+			imgsys_clt[idx]->client.knows_txdone = true;
+			imgsys_clt[idx]->client.rx_callback = imgsys_cmdq_task_cb;
+			imgsys_clt[idx]->chan =
+			mbox_request_channel(&imgsys_clt[idx]->client,
+					     idx);
+			pr_info("%s: mbox_request_channel(%d, %p)\n", __func__, idx, imgsys_clt[idx]);
+
+		}
+
+
+		#if IMGSYS_SECURE_ENABLE
+		/* request for imgsys secure gce thread */
+		for (idx = IMGSYS_ENG_MAX; idx < (IMGSYS_ENG_MAX + IMGSYS_SEC_THD); idx++) {
+			imgsys_sec_clt[idx-IMGSYS_ENG_MAX] = cmdq_mbox_create(dev, idx);
+			pr_info(
+				"%s: cmdq_mbox_create sec_thd(%d, 0x%x)\n",
+				__func__, idx, imgsys_sec_clt[idx-IMGSYS_ENG_MAX]);
+		}
+		#endif
+		/* parse hardware event */
+		for (idx = 0; idx < IMGSYS_CMDQ_EVENT_MAX; idx++) {
+			of_property_read_u16(dev->of_node,
+				imgsys_event[idx].dts_name,
+				&imgsys_event[idx].event);
+			pr_info("%s: event idx %d is (%s, %d)\n", __func__,
+				idx, imgsys_event[idx].dts_name,
+				imgsys_event[idx].event);
+		}
+		break;
+	default:
+		break;
+	}
+
+	mutex_init(&imgsys_dev->dvfs_qos_lock);
+	mutex_init(&imgsys_dev->power_ctrl_lock);
+
+}
+
+void imgsys_cmdq_release(struct mtk_imgsys_dev *imgsys_dev)
+{
+	u32 idx = 0;
+	pr_info("%s: +\n", __func__);
+
+	/* Destroy cmdq client */
+	for (idx = 0; idx < IMGSYS_ENG_MAX; idx++) {
+		cmdq_mbox_destroy(imgsys_clt[idx]);
+		imgsys_clt[idx] = NULL;
+	}
+	#if IMGSYS_SECURE_ENABLE
+	for (idx = 0; idx < IMGSYS_SEC_THD; idx++) {
+		cmdq_mbox_destroy(imgsys_sec_clt[idx]);
+		imgsys_sec_clt[idx] = NULL;
+	}
+	#endif
+
+	/* Release work_quque */
+	flush_workqueue(imgsys_cmdq_wq);
+	destroy_workqueue(imgsys_cmdq_wq);
+	imgsys_cmdq_wq = NULL;
+	mutex_destroy(&imgsys_dev->dvfs_qos_lock);
+	mutex_destroy(&imgsys_dev->power_ctrl_lock);
+}
+
+void imgsys_cmdq_streamon(struct mtk_imgsys_dev *imgsys_dev)
+{
+#if CMDQ_EXT
+	u32 idx = 0;
+#endif
+
+	dev_info(imgsys_dev->dev, "%s: cmdq stream on (%d)\n", __func__, is_stream_off);
+	is_stream_off = 0;
+#if CMDQ_EXT
+	cmdq_mbox_enable(imgsys_clt[0]->chan);
+	for (idx = IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_START;
+		idx <= IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_END; idx++)
+		cmdq_clear_event(imgsys_clt[0]->chan, imgsys_event[idx].event);
+#endif
+
+	memset((void *)event_hist, 0x0,
+		sizeof(struct imgsys_event_history)*IMGSYS_CMDQ_SYNC_POOL_NUM);
+#if DVFS_QOS_READY
+	mtk_imgsys_mmqos_reset(imgsys_dev);
+#endif
+}
+
+void imgsys_cmdq_streamoff(struct mtk_imgsys_dev *imgsys_dev)
+{
+	u32 idx = 0;
+
+	dev_info(imgsys_dev->dev,
+		"%s: cmdq stream off (%d) idx(%d)\n", __func__, is_stream_off, idx);
+	is_stream_off = 1;
+
+	#if CMDQ_STOP_FUNC
+	for (idx = 0; idx < IMGSYS_ENG_MAX; idx++) {
+		cmdq_mbox_stop(imgsys_clt[idx]);
+		dev_dbg(imgsys_dev->dev,
+			"%s: calling cmdq_mbox_stop(%d, 0x%x)\n",
+			__func__, idx, imgsys_clt[idx]);
+	}
+	#endif
+	#if IMGSYS_SECURE_ENABLE
+	if (is_sec_task_create) {
+		cmdq_sec_mbox_stop(imgsys_sec_clt[0]);
+		/* cmdq_pkt_destroy(pkt_sec); */
+		/* pkt_sec = NULL; */
+		is_sec_task_create = 0;
+	}
+	#endif
+
+#if CMDQ_EXT
+	cmdq_mbox_disable(imgsys_clt[0]->chan);
+#endif
+
+	#if DVFS_QOS_READY
+	mtk_imgsys_mmqos_reset(imgsys_dev);
+	#endif
+}
+
+void imgsys_cmdq_cmd_dump(struct swfrm_info_t *frm_info, u32 frm_idx)
+{
+	struct GCERecoder *cmd_buf = NULL;
+	struct Command *cmd = NULL;
+	u32 cmd_num = 0;
+	u32 cmd_idx = 0;
+	u32 cmd_ofst = 0;
+
+	cmd_buf = (struct GCERecoder *)frm_info->user_info[frm_idx].g_swbuf;
+	cmd_num = cmd_buf->curr_length / sizeof(struct Command);
+	cmd_ofst = sizeof(struct GCERecoder);
+
+	pr_info(
+	"%s: +, req fd/no(%d/%d) frame no(%d) frm(%d/%d), cmd_oft(0x%x/0x%x), cmd_len(%d), num(%d), sz_per_cmd(%ld), frm_blk(%d), hw_comb(0x%x)\n",
+		__func__, frm_info->request_fd, frm_info->request_no, frm_info->frame_no,
+		frm_idx, frm_info->total_frmnum, cmd_buf->cmd_offset, cmd_ofst,
+		cmd_buf->curr_length, cmd_num, sizeof(struct Command), cmd_buf->frame_block,
+		frm_info->user_info[frm_idx].hw_comb);
+
+	if (cmd_ofst != cmd_buf->cmd_offset) {
+		pr_info("%s: [ERROR]cmd offset is not match (0x%x/0x%x)!\n",
+			__func__, cmd_buf->cmd_offset, cmd_ofst);
+		return;
+	}
+
+	cmd = (struct Command *)((unsigned long)(frm_info->user_info[frm_idx].g_swbuf) +
+		(unsigned long)(cmd_buf->cmd_offset));
+
+	for (cmd_idx = 0; cmd_idx < cmd_num; cmd_idx++) {
+		switch (cmd[cmd_idx].opcode) {
+		case IMGSYS_CMD_READ:
+			pr_info(
+			"%s: READ with source(0x%08llx) target(0x%08llx) mask(0x%08x)\n", __func__,
+				cmd[cmd_idx].u.source, cmd[cmd_idx].u.target, cmd[cmd_idx].u.mask);
+			break;
+		case IMGSYS_CMD_WRITE:
+			pr_debug(
+			"%s: WRITE with addr(0x%08llx) value(0x%08x) mask(0x%08x)\n", __func__,
+				cmd[cmd_idx].u.address, cmd[cmd_idx].u.value, cmd[cmd_idx].u.mask);
+			break;
+		case IMGSYS_CMD_POLL:
+			pr_info(
+			"%s: POLL with addr(0x%08llx) value(0x%08x) mask(0x%08x)\n", __func__,
+				cmd[cmd_idx].u.address, cmd[cmd_idx].u.value, cmd[cmd_idx].u.mask);
+			break;
+		case IMGSYS_CMD_WAIT:
+			pr_info(
+			"%s: WAIT event(%d/%d) action(%d)\n", __func__,
+				cmd[cmd_idx].u.event, imgsys_event[cmd[cmd_idx].u.event].event,
+				cmd[cmd_idx].u.action);
+			break;
+		case IMGSYS_CMD_UPDATE:
+			pr_info(
+			"%s: UPDATE event(%d/%d) action(%d)\n", __func__,
+				cmd[cmd_idx].u.event, imgsys_event[cmd[cmd_idx].u.event].event,
+				cmd[cmd_idx].u.action);
+			break;
+		case IMGSYS_CMD_ACQUIRE:
+			pr_info(
+			"%s: ACQUIRE event(%d/%d) action(%d)\n", __func__,
+				cmd[cmd_idx].u.event, imgsys_event[cmd[cmd_idx].u.event].event,
+				cmd[cmd_idx].u.action);
+			break;
+		case IMGSYS_CMD_TIME:
+			pr_info("%s: Get cmdq TIME stamp\n", __func__);
+		break;
+		case IMGSYS_CMD_STOP:
+			pr_info("%s: End Of Cmd!\n", __func__);
+			break;
+		default:
+			pr_info("%s: [ERROR]Not Support Cmd(%d)!\n", __func__, cmd[cmd_idx].opcode);
+			break;
+		}
+	}
+}
+
+static void imgsys_cmdq_cb_work(struct work_struct *work)
+{
+	struct mtk_imgsys_cb_param *cb_param = NULL;
+	struct mtk_imgsys_dev *imgsys_dev = NULL;
+	u32 hw_comb = 0;
+	u32 cb_frm_cnt = 0;
+	u64 tsDvfsQosStart = 0, tsDvfsQosEnd = 0;
+	int req_fd = 0, req_no = 0, frm_no = 0;
+	bool isLastTaskInReq = 0;
+	u32 tsSwEvent = 0, tsHwEvent = 0, tsHw = 0, tsTaskPending = 0;
+	char *wpestr = NULL;
+	u32 wpebw_en = imgsys_wpe_bwlog_enable();
+#ifdef CMDQ_EXT_TS
+	u32 tsHwStr = 0, tsHwEnd = 0;
+	char logBuf_temp[MTK_IMGSYS_LOG_LENGTH];
+	u32 real_frm_idx = 0;
+	u32 idx = 0;
+#endif
+
+	pr_debug("%s: +\n", __func__);
+
+	cb_param = container_of(work, struct mtk_imgsys_cb_param, cmdq_cb_work);
+	cb_param->cmdqTs.tsCmdqCbWorkStart = ktime_get_boottime_ns()/1000;
+	imgsys_dev = cb_param->imgsys_dev;
+
+	dev_dbg(imgsys_dev->dev,
+		"%s: cb(%p) gid(%d) in block(%d/%d) for frm(%d/%d) lst(%d/%d/%d) task(%d/%d/%d) ofst(%lx/%lx/%lx/%lx/%lx)\n",
+		__func__, cb_param, cb_param->group_id,
+		cb_param->blk_idx,  cb_param->blk_num,
+		cb_param->frm_idx, cb_param->frm_num,
+		cb_param->isBlkLast, cb_param->isFrmLast, cb_param->isTaskLast,
+		cb_param->task_id, cb_param->task_num, cb_param->task_cnt,
+		cb_param->pkt_ofst[0], cb_param->pkt_ofst[1], cb_param->pkt_ofst[2],
+		cb_param->pkt_ofst[3], cb_param->pkt_ofst[4]);
+
+	#if DVFS_QOS_READY
+	mtk_imgsys_power_ctrl(imgsys_dev, false);
+	#endif
+
+#ifdef CMDQ_EXT_TS
+
+	if (imgsys_cmdq_ts_enable()) {
+		for (idx = 0; idx < cb_param->task_cnt; idx++) {
+			/* Calculating task timestamp */
+			tsSwEvent = cb_param->taskTs.dma_va[cb_param->taskTs.ofst+4*idx+1]
+					- cb_param->taskTs.dma_va[cb_param->taskTs.ofst+4*idx+0];
+			tsHwEvent = cb_param->taskTs.dma_va[cb_param->taskTs.ofst+4*idx+2]
+					- cb_param->taskTs.dma_va[cb_param->taskTs.ofst+4*idx+1];
+			tsHwStr = cb_param->taskTs.dma_va[cb_param->taskTs.ofst+4*idx+2];
+			tsHwEnd = cb_param->taskTs.dma_va[cb_param->taskTs.ofst+4*idx+3];
+			tsHw = cb_param->taskTs.dma_va[cb_param->taskTs.ofst+4*idx+3]
+				- cb_param->taskTs.dma_va[cb_param->taskTs.ofst+4*idx+2];
+			tsTaskPending =
+			cb_param->taskTs.dma_va[cb_param->taskTs.ofst+cb_param->taskTs.num-1]
+			- cb_param->taskTs.dma_va[cb_param->taskTs.ofst+4*idx+0];
+			CMDQ_TICK_TO_US(tsSwEvent);
+			CMDQ_TICK_TO_US(tsHwEvent);
+			CMDQ_TICK_TO_US(tsHw);
+			CMDQ_TICK_TO_US(tsHwStr);
+			CMDQ_TICK_TO_US(tsHwEnd);
+			CMDQ_TICK_TO_US(tsTaskPending);
+			tsTaskPending =
+				(cb_param->cmdqTs.tsCmdqCbStart-cb_param->cmdqTs.tsFlushStart)
+				- tsTaskPending;
+			dev_dbg(imgsys_dev->dev,
+			"%s: TSus cb(%p) err(%d) frm(%d/%d/%d) hw_comb(0x%x) ts_num(%d) sw_event(%d) hw_event(%d) hw_real(%d) (%d/%d/%d/%d)\n",
+				__func__, cb_param, cb_param->err, cb_param->frm_idx,
+				cb_param->frm_num, cb_frm_cnt, hw_comb,
+				cb_param->taskTs.num, tsSwEvent, tsHwEvent, tsHw,
+				cb_param->taskTs.dma_va[cb_param->taskTs.ofst+4*idx+0],
+				cb_param->taskTs.dma_va[cb_param->taskTs.ofst+4*idx+1],
+				cb_param->taskTs.dma_va[cb_param->taskTs.ofst+4*idx+2],
+				cb_param->taskTs.dma_va[cb_param->taskTs.ofst+4*idx+3]
+			);
+			if (imgsys_cmdq_ts_dbg_enable()) {
+				real_frm_idx = cb_param->frm_idx - (cb_param->task_cnt - 1) + idx;
+				hw_comb = cb_param->frm_info->user_info[real_frm_idx].hw_comb;
+				memset((char *)logBuf_temp, 0x0, MTK_IMGSYS_LOG_LENGTH);
+				logBuf_temp[strlen(logBuf_temp)] = '\0';
+				snprintf(logBuf_temp, MTK_IMGSYS_LOG_LENGTH,
+					"/[%d/%d/%d/%d]hw_comb(0x%x)ts(%d-%d-%d-%d)hw(%d-%d)",
+					real_frm_idx, cb_param->frm_num,
+					cb_param->blk_idx, cb_param->blk_num,
+					hw_comb, tsTaskPending, tsSwEvent, tsHwEvent,
+					tsHw, tsHwStr, tsHwEnd);
+				strncat(cb_param->frm_info->hw_ts_log, logBuf_temp,
+						strlen(logBuf_temp));
+			}
+		}
+	}
+#endif
+
+	if (cb_param->err != 0)
+		pr_info(
+			"%s: [ERROR] cb(%p) error(%d) gid(%d) for frm(%d/%d) blk(%d/%d) lst(%d/%d) earlycb(%d) task(%d/%d/%d) ofst(%lx/%lx/%lx/%lx/%lx)",
+			__func__, cb_param, cb_param->err, cb_param->group_id,
+			cb_param->frm_idx, cb_param->frm_num,
+			cb_param->blk_idx, cb_param->blk_num,
+			cb_param->isBlkLast, cb_param->isFrmLast,
+			cb_param->is_earlycb,
+			cb_param->task_id, cb_param->task_num, cb_param->task_cnt,
+			cb_param->pkt_ofst[0], cb_param->pkt_ofst[1], cb_param->pkt_ofst[2],
+			cb_param->pkt_ofst[3], cb_param->pkt_ofst[4]);
+	if (is_stream_off == 1)
+		pr_info("%s: [ERROR] cb(%p) pipe already streamoff(%d)!\n",
+			__func__, cb_param, is_stream_off);
+
+	dev_dbg(imgsys_dev->dev,
+		"%s: req fd/no(%d/%d) frame no(%d) cb(%p)frm_info(%p) isBlkLast(%d) isFrmLast(%d) isECB(%d) isGPLast(%d) isGPECB(%d) for frm(%d/%d)\n",
+		__func__, cb_param->frm_info->request_fd,
+		cb_param->frm_info->request_no, cb_param->frm_info->frame_no,
+		cb_param, cb_param->frm_info, cb_param->isBlkLast,
+		cb_param->isFrmLast, cb_param->is_earlycb,
+		cb_param->frm_info->user_info[cb_param->frm_idx].is_lastingroup,
+		cb_param->frm_info->user_info[cb_param->frm_idx].is_earlycb,
+		cb_param->frm_idx, cb_param->frm_num);
+
+	hw_comb = cb_param->frm_info->user_info[cb_param->frm_idx].hw_comb;
+	req_fd = cb_param->frm_info->request_fd;
+	req_no = cb_param->frm_info->request_no;
+	frm_no = cb_param->frm_info->frame_no;
+
+
+	(cb_param->frm_info->cb_frmcnt)++;
+	cb_frm_cnt = cb_param->frm_info->cb_frmcnt;
+
+	if (wpebw_en > 0) {
+		switch (wpebw_en) {
+		case 1:
+			if ((hw_comb & WPE_BWLOG_HW_COMB) == WPE_BWLOG_HW_COMB)
+				wpestr = "tnr";
+			break;
+		case 2:
+			if (((hw_comb & WPE_BWLOG_HW_COMB_ninA) == WPE_BWLOG_HW_COMB_ninA)
+			 || ((hw_comb & WPE_BWLOG_HW_COMB_ninB) == WPE_BWLOG_HW_COMB_ninB))
+				wpestr = "eis";
+			break;
+#if IMGSYS_WPE_NUM == 3
+		case 3:
+			if (hw_comb == IMGSYS_ENG_WPE_LITE)
+				wpestr = "lite";
+			break;
+#endif
+		}
+		if (wpestr) {
+			dev_info(imgsys_dev->dev,
+				"%s: wpe_bwlog req fd/no(%d/%d)frameNo(%d)cb(%p)err(%d)frm(%d/%d/%d)hw_comb(0x%x)read_num(%d)-%s(%d/%d/%d/%d)\n",
+				__func__, cb_param->frm_info->request_fd,
+				cb_param->frm_info->request_no,
+				cb_param->frm_info->frame_no,
+				cb_param, cb_param->err, cb_param->frm_idx,
+				cb_param->frm_num, cb_frm_cnt, hw_comb,
+				cb_param->taskTs.num,
+				wpestr,
+				cb_param->taskTs.dma_va[cb_param->taskTs.ofst+0],
+				cb_param->taskTs.dma_va[cb_param->taskTs.ofst+1],
+				cb_param->taskTs.dma_va[cb_param->taskTs.ofst+2],
+				cb_param->taskTs.dma_va[cb_param->taskTs.ofst+3]
+				);
+		}
+	}
+
+	dev_dbg(imgsys_dev->dev,
+		"%s: req fd/no(%d/%d) frame no(%d) cb(%p)frm_info(%p) isBlkLast(%d) cb_param->frm_num(%d) cb_frm_cnt(%d)\n",
+		__func__, cb_param->frm_info->request_fd,
+		cb_param->frm_info->request_no, cb_param->frm_info->frame_no,
+		cb_param, cb_param->frm_info, cb_param->isBlkLast, cb_param->frm_num,
+		cb_frm_cnt);
+
+	if (cb_param->isBlkLast && cb_param->user_cmdq_cb &&
+		((cb_param->frm_info->total_taskcnt == cb_frm_cnt) || cb_param->is_earlycb)) {
+		struct imgsys_cb_data user_cb_data;
+
+		/* PMQOS API */
+		tsDvfsQosStart = ktime_get_boottime_ns()/1000;
+		IMGSYS_SYSTRACE_BEGIN(
+			"%s_%s|Imgsys MWFrame:#%d MWReq:#%d ReqFd:%d Own:%llx\n",
+			__func__, "dvfs_qos", cb_param->frm_info->frame_no,
+			cb_param->frm_info->request_no, cb_param->frm_info->request_fd,
+			cb_param->frm_info->frm_owner);
+		/* Calling PMQOS API if last frame */
+		if (cb_param->frm_info->total_taskcnt == cb_frm_cnt) {
+			mutex_lock(&(imgsys_dev->dvfs_qos_lock));
+			#if DVFS_QOS_READY
+			mtk_imgsys_mmdvfs_mmqos_cal(imgsys_dev, cb_param->frm_info, 0);
+			mtk_imgsys_mmdvfs_set(imgsys_dev, cb_param->frm_info, 0);
+			#if IMGSYS_QOS_SET_REAL
+			mtk_imgsys_mmqos_ts_cal(imgsys_dev, cb_param, hw_comb);
+			mtk_imgsys_mmqos_set(imgsys_dev, cb_param->frm_info, 0);
+			#elif IMGSYS_QOS_SET_BY_SCEN
+			mtk_imgsys_mmqos_set_by_scen(imgsys_dev, cb_param->frm_info, 0);
+			#endif
+			#endif
+			mutex_unlock(&(imgsys_dev->dvfs_qos_lock));
+#ifdef CMDQ_EXT_TS
+			if (imgsys_cmdq_ts_enable() || imgsys_wpe_bwlog_enable()) {
+				cmdq_mbox_buf_free(cb_param->clt,
+					cb_param->taskTs.dma_va, cb_param->taskTs.dma_pa);
+				if (imgsys_cmdq_ts_dbg_enable()) {
+					dev_info(imgsys_dev->dev, "%s: %s",
+						__func__, cb_param->frm_info->hw_ts_log);
+					vfree(cb_param->frm_info->hw_ts_log);
+				}
+			}
+#endif
+			isLastTaskInReq = 1;
+		} else
+			isLastTaskInReq = 0;
+		IMGSYS_SYSTRACE_END();
+		tsDvfsQosEnd = ktime_get_boottime_ns()/1000;
+
+		user_cb_data.cmdq_data.sta = cb_param->err;
+		user_cb_data.data = (void *)cb_param->frm_info;
+		cb_param->cmdqTs.tsUserCbStart = ktime_get_boottime_ns()/1000;
+		IMGSYS_SYSTRACE_BEGIN(
+			"%s_%s|Imgsys MWFrame:#%d MWReq:#%d ReqFd:%d Own:%llx\n",
+			__func__, "user_cb", cb_param->frm_info->frame_no,
+			cb_param->frm_info->request_no, cb_param->frm_info->request_fd,
+			cb_param->frm_info->frm_owner);
+		cb_param->user_cmdq_cb(user_cb_data, cb_param->frm_idx, isLastTaskInReq);
+		IMGSYS_SYSTRACE_END();
+		cb_param->cmdqTs.tsUserCbEnd = ktime_get_boottime_ns()/1000;
+	}
+
+	IMGSYS_SYSTRACE_BEGIN(
+		"%s_%s|Imgsys MWFrame:#%d MWReq:#%d ReqFd:%d fidx:%d hw_comb:0x%x Own:%llx cb:%p thd:%d frm(%d/%d/%d) DvfsSt(%lld) SetCmd(%lld) HW(%lld/%d-%d-%d-%d) Cmdqcb(%lld) WK(%lld) UserCb(%lld) DvfsEnd(%lld)\n",
+		__func__, "wait_pkt", cb_param->frm_info->frame_no,
+		cb_param->frm_info->request_no, cb_param->frm_info->request_fd,
+		cb_param->frm_info->user_info[cb_param->frm_idx].subfrm_idx, hw_comb,
+		cb_param->frm_info->frm_owner, cb_param, cb_param->thd_idx,
+		cb_param->frm_idx, cb_param->frm_num, cb_frm_cnt,
+		(cb_param->cmdqTs.tsDvfsQosEnd-cb_param->cmdqTs.tsDvfsQosStart),
+		(cb_param->cmdqTs.tsFlushStart-cb_param->cmdqTs.tsReqStart),
+		(cb_param->cmdqTs.tsCmdqCbStart-cb_param->cmdqTs.tsFlushStart),
+		tsTaskPending, tsSwEvent, tsHwEvent, tsHw,
+		(cb_param->cmdqTs.tsCmdqCbEnd-cb_param->cmdqTs.tsCmdqCbStart),
+		(cb_param->cmdqTs.tsCmdqCbWorkStart-cb_param->cmdqTs.tsCmdqCbEnd),
+		(cb_param->cmdqTs.tsUserCbEnd-cb_param->cmdqTs.tsUserCbStart),
+		(tsDvfsQosEnd-tsDvfsQosStart));
+#if CMDQ_EXT
+	cmdq_pkt_wait_complete(cb_param->pkt);
+#endif
+	imgsys_destroy_pkt(&cb_param->pkt);
+	cb_param->cmdqTs.tsReqEnd = ktime_get_boottime_ns()/1000;
+	IMGSYS_SYSTRACE_END();
+
+	if (imgsys_cmdq_ts_dbg_enable())
+		dev_dbg(imgsys_dev->dev,
+			"%s: TSus req fd/no(%d/%d) frame no(%d) thd(%d) cb(%p) err(%d) frm(%d/%d/%d) hw_comb(0x%x) DvfsSt(%lld) Req(%lld) SetCmd(%lld) HW(%lld/%d-%d-%d-%d) Cmdqcb(%lld) WK(%lld) CmdqCbWk(%lld) UserCb(%lld) DvfsEnd(%lld)\n",
+			__func__, req_fd, req_no, frm_no, cb_param->thd_idx,
+			cb_param, cb_param->err, cb_param->frm_idx,
+			cb_param->frm_num, cb_frm_cnt, hw_comb,
+			(cb_param->cmdqTs.tsDvfsQosEnd-cb_param->cmdqTs.tsDvfsQosStart),
+			(cb_param->cmdqTs.tsReqEnd-cb_param->cmdqTs.tsReqStart),
+			(cb_param->cmdqTs.tsFlushStart-cb_param->cmdqTs.tsReqStart),
+			(cb_param->cmdqTs.tsCmdqCbStart-cb_param->cmdqTs.tsFlushStart),
+			tsTaskPending, tsSwEvent, tsHwEvent, tsHw,
+			(cb_param->cmdqTs.tsCmdqCbEnd-cb_param->cmdqTs.tsCmdqCbStart),
+			(cb_param->cmdqTs.tsCmdqCbWorkStart-cb_param->cmdqTs.tsCmdqCbEnd),
+			(cb_param->cmdqTs.tsReqEnd-cb_param->cmdqTs.tsCmdqCbWorkStart),
+			(cb_param->cmdqTs.tsUserCbEnd-cb_param->cmdqTs.tsUserCbStart),
+			(tsDvfsQosEnd-tsDvfsQosStart)
+			);
+	vfree(cb_param);
+}
+
+static void imgsys_cmdq_task_cb(struct mbox_client *cl, void *mssg)
+{
+	struct cmdq_cb_data *data = mssg;
+	struct mtk_imgsys_cb_param *cb_param =
+		container_of(data->pkt, struct mtk_imgsys_cb_param, pkt);
+
+	struct mtk_imgsys_pipe *pipe;
+	size_t err_ofst;
+	u32 idx = 0, err_idx = 0, real_frm_idx = 0;
+#if CMDQ_EXT
+	u16 event = 0, event_sft = 0;
+	u64 event_diff = 0;
+	bool isHWhang = 0;
+#endif
+
+	pr_debug("%s: +\n", __func__);
+
+	cb_param->err = data->sta;
+	cb_param->cmdqTs.tsCmdqCbStart = ktime_get_boottime_ns()/1000;
+
+	if (cb_param->err < 0) {
+		pr_info(
+			"%s: [ERROR] Receive cb(%p) with sta(%d) for frm(%d/%d)\n",
+			__func__, cb_param, data->sta, cb_param->frm_idx, cb_param->frm_num);
+		//return;
+	}
+
+	pr_debug(
+		"%s: Receive cb(%p) with sta(%d) for frm(%d/%d)\n",
+		__func__, cb_param, data->sta, cb_param->frm_idx, cb_param->frm_num);
+
+	if (cb_param->err != 0) {
+		err_ofst = 0;//cb_param->pkt->err_data.offset;
+		err_idx = 0;
+		for (idx = 0; idx < cb_param->task_cnt; idx++)
+			if (err_ofst > cb_param->pkt_ofst[idx])
+				err_idx++;
+			else
+				break;
+		if (err_idx >= cb_param->task_cnt) {
+			pr_info(
+				"%s: [ERROR] can't find task in task list! cb(%p) error(%d) gid(%d) for frm(%d/%d) blk(%d/%d) erridx(%d/%d) task(%d/%d/%d) ofst(%lx/%lx/%lx/%lx/%lx)",
+				__func__, cb_param, cb_param->err, cb_param->group_id,
+				cb_param->frm_idx, cb_param->frm_num,
+				cb_param->blk_idx, cb_param->blk_num,
+				err_idx, real_frm_idx,
+				cb_param->task_id, cb_param->task_num, cb_param->task_cnt,
+				cb_param->pkt_ofst[0], cb_param->pkt_ofst[1], cb_param->pkt_ofst[2],
+				cb_param->pkt_ofst[3], cb_param->pkt_ofst[4]);
+			err_idx = cb_param->task_cnt - 1;
+		}
+		real_frm_idx = cb_param->frm_idx - (cb_param->task_cnt - 1) + err_idx;
+		pr_info(
+			"%s: [ERROR] cb(%p) error(%d) gid(%d) for frm(%d/%d) blk(%d/%d) lst(%d/%d/%d) earlycb(%d) erridx(%d/%d) task(%d/%d/%d) ofst(%lx/%lx/%lx/%lx/%lx)",
+			__func__, cb_param, cb_param->err, cb_param->group_id,
+			cb_param->frm_idx, cb_param->frm_num,
+			cb_param->blk_idx, cb_param->blk_num,
+			cb_param->isBlkLast, cb_param->isFrmLast, cb_param->isTaskLast,
+			cb_param->is_earlycb,
+			err_idx, real_frm_idx,
+			cb_param->task_id, cb_param->task_num, cb_param->task_cnt,
+			cb_param->pkt_ofst[0], cb_param->pkt_ofst[1], cb_param->pkt_ofst[2],
+			cb_param->pkt_ofst[3], cb_param->pkt_ofst[4]);
+		if (is_stream_off == 1)
+			pr_info("%s: [ERROR] cb(%p) pipe had been turned off(%d)!\n",
+				__func__, cb_param, is_stream_off);
+		pipe = (struct mtk_imgsys_pipe *)cb_param->frm_info->pipe;
+		if (!pipe->streaming) {
+			/* is_stream_off = 1; */
+			pr_info("%s: [ERROR] cb(%p) pipe already streamoff(%d)\n",
+				__func__, cb_param, is_stream_off);
+		}
+
+#if CMDQ_EXT
+		event = cb_param->pkt->err_data.event;
+		for (idx = 0; idx < IMGSYS_CMDQ_EVENT_MAX; idx++) {
+			if (imgsys_event[idx].event == event) {
+				event = idx;
+				break;
+			}
+		}
+
+		if ((event >= IMGSYS_CMDQ_HW_EVENT_BEGIN) &&
+			(event <= IMGSYS_CMDQ_HW_EVENT_END)) {
+			isHWhang = 1;
+			pr_info(
+				"%s: [ERROR] HW event timeout! wfe(%d) event(%d) isHW(%d)",
+				__func__,
+				cb_param->pkt->err_data.wfe_timeout,
+				cb_param->pkt->err_data.event, isHWhang);
+		} else if ((event >= IMGSYS_CMDQ_SW_EVENT_BEGIN) &&
+			(event <= IMGSYS_CMDQ_SW_EVENT_END)) {
+			event_sft = event - IMGSYS_CMDQ_SW_EVENT_BEGIN;
+			event_diff = event_hist[event_sft].set.ts >
+						event_hist[event_sft].wait.ts ?
+						(event_hist[event_sft].set.ts -
+						event_hist[event_sft].wait.ts) :
+						(event_hist[event_sft].wait.ts -
+						event_hist[event_sft].set.ts);
+			pr_info(
+				"%s: [ERROR] SW event timeout! wfe(%d) event(%d) isHW(%d); event st(%d)_ts(%lld)_set(%d/%d/%d/%lld)_wait(%d/%d/%d/%lld)",
+				__func__,
+				cb_param->pkt->err_data.wfe_timeout,
+				cb_param->pkt->err_data.event, isHWhang,
+				event_hist[event_sft].st, event_diff,
+				event_hist[event_sft].set.req_fd,
+				event_hist[event_sft].set.req_no,
+				event_hist[event_sft].set.frm_no,
+				event_hist[event_sft].set.ts,
+				event_hist[event_sft].wait.req_fd,
+				event_hist[event_sft].wait.req_no,
+				event_hist[event_sft].wait.frm_no,
+				event_hist[event_sft].wait.ts);
+		} else if ((event >= IMGSYS_CMDQ_GPR_EVENT_BEGIN) &&
+			(event <= IMGSYS_CMDQ_GPR_EVENT_END)) {
+			isHWhang = 1;
+			pr_info(
+				"%s: [ERROR] GPR event timeout! wfe(%d) event(%d) isHW(%d)",
+				__func__,
+				cb_param->pkt->err_data.wfe_timeout,
+				cb_param->pkt->err_data.event, isHWhang);
+		} else
+			pr_info(
+				"%s: [ERROR] Other event timeout! wfe(%d) event(%d) isHW(%d)",
+				__func__,
+				cb_param->pkt->err_data.wfe_timeout,
+				cb_param->pkt->err_data.event, isHWhang);
+#endif
+		imgsys_cmdq_cmd_dump(cb_param->frm_info, real_frm_idx);
+
+		if (cb_param->user_cmdq_err_cb) {
+			struct imgsys_cb_data user_cb_data;
+
+			user_cb_data.cmdq_data.sta = cb_param->err;
+			user_cb_data.data = (void *)cb_param->frm_info;
+			cb_param->user_cmdq_err_cb(
+				user_cb_data, real_frm_idx, 1/*isHWhang*/);
+		}
+	}
+
+	cb_param->cmdqTs.tsCmdqCbEnd = ktime_get_boottime_ns()/1000;
+
+	INIT_WORK(&cb_param->cmdq_cb_work, imgsys_cmdq_cb_work);
+	queue_work(imgsys_cmdq_wq, &cb_param->cmdq_cb_work);
+}
+
+int imgsys_cmdq_sendtask(struct mtk_imgsys_dev *imgsys_dev,
+				struct swfrm_info_t *frm_info,
+				void (*cmdq_cb)(struct imgsys_cb_data data,
+					uint32_t subfidx, bool isLastTaskInReq),
+				void (*cmdq_err_cb)(struct imgsys_cb_data data,
+					uint32_t fail_subfidx, bool isHWhang))
+{
+	struct cmdq_client *clt = NULL;
+	//struct cmdq_pkt *pkt = NULL;
+	struct GCERecoder *cmd_buf = NULL;
+	struct Command *cmd = NULL;
+	struct mtk_imgsys_cb_param *cb_param = NULL;
+	dma_addr_t pkt_ts_pa = 0;
+#ifdef CMDQ_EXT_TS
+	u32 *pkt_ts_va = NULL;
+	char logBuf_temp[MTK_IMGSYS_LOG_LENGTH];
+#endif
+	u32 pkt_ts_num = 0;
+	u32 pkt_ts_ofst = 0;
+	u32 cmd_num = 0;
+	u32 cmd_idx = 0;
+	u32 blk_idx = 0; /* For Vss block cnt */
+	u32 thd_idx = 0;
+	u32 hw_comb = 0;
+	int ret = 0, ret_flush = 0;
+	u64 tsReqStart = 0;
+	u64 tsDvfsQosStart = 0, tsDvfsQosEnd = 0;
+	u32 frm_num = 0, frm_idx = 0;
+	u32 cmd_ofst = 0;
+	bool isPack = 0;
+	u32 task_idx = 0;
+	u32 task_id = 0;
+	u32 task_num = 0;
+	u32 task_cnt = 0;
+	size_t pkt_ofst[MAX_FRAME_IN_TASK] = {0};
+
+	/* PMQOS API */
+	tsDvfsQosStart = ktime_get_boottime_ns()/1000;
+	IMGSYS_SYSTRACE_BEGIN("%s_%s|Imgsys MWFrame:#%d MWReq:#%d ReqFd:%d Own:%llx\n",
+		__func__, "dvfs_qos", frm_info->frame_no, frm_info->request_no,
+		frm_info->request_fd, frm_info->frm_owner);
+	mutex_lock(&(imgsys_dev->dvfs_qos_lock));
+	#if DVFS_QOS_READY
+	mtk_imgsys_mmdvfs_mmqos_cal(imgsys_dev, frm_info, 1);
+	mtk_imgsys_mmdvfs_set(imgsys_dev, frm_info, 1);
+	#if IMGSYS_QOS_SET_REAL
+	mtk_imgsys_mmqos_set(imgsys_dev, frm_info, 1);
+	#elif IMGSYS_QOS_SET_BY_SCEN
+	mtk_imgsys_mmqos_set_by_scen(imgsys_dev, frm_info, 1);
+	#endif
+	#endif
+	mutex_unlock(&(imgsys_dev->dvfs_qos_lock));
+	IMGSYS_SYSTRACE_END();
+	tsDvfsQosEnd = ktime_get_boottime_ns()/1000;
+
+	/* is_stream_off = 0; */
+	frm_num = frm_info->total_frmnum;
+	frm_info->cb_frmcnt = 0;
+	frm_info->total_taskcnt = 0;
+	cmd_ofst = sizeof(struct GCERecoder);
+
+	#if IMGSYS_SECURE_ENABLE
+	if (frm_info->is_secReq && (is_sec_task_create == 0)) {
+		imgsys_cmdq_sec_sendtask(imgsys_dev);
+		is_sec_task_create = 1;
+		pr_info(
+			"%s: create imgsys secure task is_secReq(%d)\n",
+			__func__, frm_info->is_secReq);
+	}
+	#endif
+
+#ifdef CMDQ_EXT_TS
+	/* Allocate cmdq buffer for task timestamp */
+	if (imgsys_cmdq_ts_enable() || imgsys_wpe_bwlog_enable()) {
+		pkt_ts_va = cmdq_mbox_buf_alloc(imgsys_clt[0], &pkt_ts_pa);
+		if (imgsys_cmdq_ts_dbg_enable()) {
+			frm_info->hw_ts_log = vzalloc(sizeof(char)*MTK_IMGSYS_LOG_LENGTH);
+			memset((char *)frm_info->hw_ts_log, 0x0, MTK_IMGSYS_LOG_LENGTH);
+			frm_info->hw_ts_log[strlen(frm_info->hw_ts_log)] = '\0';
+			memset((char *)logBuf_temp, 0x0, MTK_IMGSYS_LOG_LENGTH);
+			logBuf_temp[strlen(logBuf_temp)] = '\0';
+			snprintf(logBuf_temp, MTK_IMGSYS_LOG_LENGTH,
+				"own(%llx/%s)req fd/no(%d/%d) frame no(%d) gid(%d)",
+				frm_info->frm_owner, (char *)(&(frm_info->frm_owner)),
+				frm_info->request_fd, frm_info->request_no, frm_info->frame_no,
+				frm_info->group_id);
+			strncat(frm_info->hw_ts_log, logBuf_temp, strlen(logBuf_temp));
+		}
+	}
+#endif
+
+	for (frm_idx = 0; frm_idx < frm_num; frm_idx++) {
+		cmd_buf = (struct GCERecoder *)frm_info->user_info[frm_idx].g_swbuf;
+
+		if ((cmd_buf->header_code != 0x5A5A5A5A) ||
+				(cmd_buf->check_pre != 0x55AA55AA) ||
+				(cmd_buf->check_post != 0xAA55AA55) ||
+				(cmd_buf->footer_code != 0xA5A5A5A5)) {
+			pr_info("%s: Incorrect guard word: %08x/%08x/%08x/%08x", __func__,
+				cmd_buf->header_code, cmd_buf->check_pre, cmd_buf->check_post,
+				cmd_buf->footer_code);
+			return -1;
+		}
+
+		cmd_num = cmd_buf->curr_length / sizeof(struct Command);
+		cmd = (struct Command *)((unsigned long)(frm_info->user_info[frm_idx].g_swbuf) +
+			(unsigned long)(cmd_buf->cmd_offset));
+		hw_comb = frm_info->user_info[frm_idx].hw_comb;
+
+		if (isPack == 0) {
+			if (frm_info->group_id == -1) {
+				/* Choose cmdq_client base on hw scenario */
+				for (thd_idx = 0; thd_idx < IMGSYS_ENG_MAX; thd_idx++) {
+					if (hw_comb & 0x1) {
+						clt = imgsys_clt[thd_idx];
+						pr_debug(
+						"%s: chosen mbox thread (%d, %p) for frm(%d/%d)\n",
+						__func__, thd_idx, clt, frm_idx, frm_num);
+						break;
+					}
+					hw_comb = hw_comb>>1;
+				}
+				/* This segment can be removed since user had set dependency */
+				if (frm_info->user_info[frm_idx].hw_comb & IMGSYS_ENG_DIP) {
+					thd_idx = 4;
+					clt = imgsys_clt[thd_idx];
+				}
+			} else {
+				if ((frm_info->group_id >= 0) &&
+					(frm_info->group_id < IMGSYS_NOR_THD)) {
+					thd_idx = frm_info->group_id;
+					clt = imgsys_clt[thd_idx];
+				} else {
+					pr_info(
+						"%s: [ERROR] group_id(%d) is not in range(%d) for hw_comb(0x%x) frm(%d/%d)!\n",
+						__func__, frm_info->group_id, IMGSYS_NOR_THD,
+						frm_info->user_info[frm_idx].hw_comb,
+						frm_idx, frm_num);
+					return -1;
+				}
+			}
+
+			/* This is work around for low latency flow.		*/
+			/* If we change to request base,			*/
+			/* we don't have to take this condition into account.	*/
+			if (frm_info->sync_id != -1) {
+				thd_idx = 0;
+				clt = imgsys_clt[thd_idx];
+			}
+
+			if (clt == NULL) {
+				pr_info("%s: [ERROR] No HW Found (0x%x) for frm(%d/%d)!\n",
+					__func__, frm_info->user_info[frm_idx].hw_comb,
+					frm_idx, frm_num);
+				return -1;
+			}
+		}
+
+		dev_dbg(imgsys_dev->dev,
+		"%s: req fd/no(%d/%d) frame no(%d) frm(%d/%d) cmd_oft(0x%x/0x%x), cmd_len(%d), num(%d), sz_per_cmd(%ld), frm_blk(%d), hw_comb(0x%x), sync_id(%d), gce_thd(%d), gce_clt(%p)\n",
+			__func__, frm_info->request_fd, frm_info->request_no, frm_info->frame_no,
+			frm_idx, frm_num, cmd_buf->cmd_offset, cmd_ofst, cmd_buf->curr_length,
+			cmd_num, sizeof(struct Command), cmd_buf->frame_block,
+			frm_info->user_info[frm_idx].hw_comb, frm_info->sync_id, thd_idx, clt);
+
+		cmd_idx = 0;
+
+		for (blk_idx = 0; blk_idx < cmd_buf->frame_block; blk_idx++) {
+			tsReqStart = ktime_get_boottime_ns()/1000;
+
+			if (isPack == 0) {
+
+				/* Prepare cb param */
+				cb_param = vzalloc(sizeof(struct mtk_imgsys_cb_param));
+				if (cb_param == NULL) {
+					pr_info(
+							"%s: [ERROR] Prepare cb param fail in block(%d)!\n",
+							__func__, blk_idx);
+					return -1;
+				}
+
+				dev_dbg(imgsys_dev->dev,
+					"%s: cb_param vzalloc success cb(%p) in block(%d) for frm(%d/%d)!\n",
+					__func__, cb_param, blk_idx, frm_idx, frm_num);
+
+				/* create pkt and hook clt as pkt's private data */
+				if (imgsys_create_pkt(&cb_param->pkt, clt, 0x00004000) < 0) {
+					vfree(cb_param);
+					pr_info(
+							"%s: [ERROR] imgsys_create_pkt fail in block(%d)!\n",
+							__func__, blk_idx);
+					return -1;
+				}
+
+				dev_dbg(imgsys_dev->dev,
+					"%s: imgsys_create_pkt success(%p) in block(%d) for frm(%d/%d)\n",
+						__func__, &cb_param->pkt, blk_idx, frm_idx, frm_num);
+
+				/* Reset pkt timestamp num */
+				pkt_ts_num = 0;
+#if CMDQ_EXT
+				/* Assign task priority according to is_time_shared */
+				if (frm_info->user_info[frm_idx].is_time_shared)
+					pkt->priority = IMGSYS_PRI_LOW;
+				else
+					pkt->priority = IMGSYS_PRI_HIGH;
+#endif
+			}
+
+			IMGSYS_SYSTRACE_BEGIN(
+				"%s_%s|Imgsys MWFrame:#%d MWReq:#%d ReqFd:%d fidx:%d hw_comb:0x%x Own:%llx frm(%d/%d) blk(%d)\n",
+				__func__, "cmd_parser", frm_info->frame_no, frm_info->request_no,
+				frm_info->request_fd, frm_info->user_info[frm_idx].subfrm_idx,
+				frm_info->user_info[frm_idx].hw_comb, frm_info->frm_owner,
+				frm_idx, frm_num, blk_idx);
+			// Add secure token begin
+			#if IMGSYS_SECURE_ENABLE
+			if (frm_info->user_info[frm_idx].is_secFrm)
+				imgsys_cmdq_sec_cmd(pkt);
+			#endif
+
+			ret = imgsys_cmdq_parser(frm_info, &cb_param->pkt, &cmd[cmd_idx], hw_comb, cmd_num,
+				(pkt_ts_pa + 4 * pkt_ts_ofst), &pkt_ts_num, thd_idx);
+
+			if (ret < 0) {
+				pr_info(
+					"%s: [ERROR] parsing idx(%d) with cmd(%d) in block(%d) for frm(%d/%d) fail\n",
+					__func__, cmd_idx, cmd[cmd_idx].opcode,
+					blk_idx, frm_idx, frm_num);
+				imgsys_destroy_pkt(&cb_param->pkt);
+
+				if (cb_param != NULL) {
+					vfree(cb_param);
+				}
+
+				goto sendtask_done;
+			}
+			cmd_idx += ret;
+
+			// Add secure token end
+			#if IMGSYS_SECURE_ENABLE
+			if (frm_info->user_info[frm_idx].is_secFrm)
+				imgsys_cmdq_sec_cmd(pkt);
+			#endif
+
+			IMGSYS_SYSTRACE_END();
+
+			/* Check for packing gce task */
+			pkt_ofst[task_cnt] = cb_param->pkt.cmd_buf_size - CMDQ_INST_SIZE;
+			task_cnt++;
+			if ((frm_info->user_info[frm_idx].is_time_shared)
+				|| (frm_info->user_info[frm_idx].is_secFrm)
+				|| (frm_info->user_info[frm_idx].is_earlycb)
+				|| ((frm_idx + 1) == frm_num)) {
+				#if DVFS_QOS_READY
+				mtk_imgsys_power_ctrl(imgsys_dev, true);
+				#endif
+
+				task_num++;
+				//cb_param->pkt = pkt;
+				cb_param->frm_info = frm_info;
+				cb_param->frm_idx = frm_idx;
+				cb_param->frm_num = frm_num;
+				cb_param->user_cmdq_cb = cmdq_cb;
+				cb_param->user_cmdq_err_cb = cmdq_err_cb;
+				if ((blk_idx + 1) == cmd_buf->frame_block)
+					cb_param->isBlkLast = 1;
+				else
+					cb_param->isBlkLast = 0;
+				if ((frm_idx + 1) == frm_num)
+					cb_param->isFrmLast = 1;
+				else
+					cb_param->isFrmLast = 0;
+				cb_param->blk_idx = blk_idx;
+				cb_param->blk_num = cmd_buf->frame_block;
+				cb_param->is_earlycb = frm_info->user_info[frm_idx].is_earlycb;
+				cb_param->group_id = frm_info->group_id;
+				cb_param->cmdqTs.tsReqStart = tsReqStart;
+				cb_param->cmdqTs.tsDvfsQosStart = tsDvfsQosStart;
+				cb_param->cmdqTs.tsDvfsQosEnd = tsDvfsQosEnd;
+				cb_param->imgsys_dev = imgsys_dev;
+				cb_param->thd_idx = thd_idx;
+				cb_param->clt = clt;
+				cb_param->task_cnt = task_cnt;
+				for (task_idx = 0; task_idx < task_cnt; task_idx++)
+					cb_param->pkt_ofst[task_idx] = pkt_ofst[task_idx];
+				task_cnt = 0;
+				cb_param->task_id = task_id;
+				task_id++;
+				if ((cb_param->isBlkLast) && (cb_param->isFrmLast)) {
+					cb_param->isTaskLast = 1;
+					cb_param->task_num = task_num;
+					frm_info->total_taskcnt = task_num;
+				} else {
+					cb_param->isTaskLast = 0;
+					cb_param->task_num = 0;
+				}
+
+				dev_dbg(imgsys_dev->dev,
+					"%s: cb(%p) gid(%d) in block(%d/%d) for frm(%d/%d) lst(%d/%d/%d) task(%d/%d/%d) ofst(%lx/%lx/%lx/%lx/%lx)\n",
+					__func__, cb_param, cb_param->group_id,
+					cb_param->blk_idx,  cb_param->blk_num,
+					cb_param->frm_idx, cb_param->frm_num,
+					cb_param->isBlkLast, cb_param->isFrmLast,
+					cb_param->isTaskLast, cb_param->task_id,
+					cb_param->task_num, cb_param->task_cnt,
+					cb_param->pkt_ofst[0], cb_param->pkt_ofst[1],
+					cb_param->pkt_ofst[2], cb_param->pkt_ofst[3],
+					cb_param->pkt_ofst[4]);
+
+#ifdef CMDQ_EXT_TS
+				if (imgsys_cmdq_ts_enable() || imgsys_wpe_bwlog_enable()) {
+					cb_param->taskTs.dma_pa = pkt_ts_pa;
+					cb_param->taskTs.dma_va = pkt_ts_va;
+					cb_param->taskTs.num = pkt_ts_num;
+					cb_param->taskTs.ofst = pkt_ts_ofst;
+					pkt_ts_ofst += pkt_ts_num;
+				}
+#endif
+
+				/* flush synchronized, block API */
+				cb_param->cmdqTs.tsFlushStart = ktime_get_boottime_ns()/1000;
+				IMGSYS_SYSTRACE_BEGIN(
+					"%s_%s|Imgsys MWFrame:#%d MWReq:#%d ReqFd:%d fidx:%d hw_comb:0x%x Own:%llx cb(%p) frm(%d/%d) blk(%d/%d)\n",
+					__func__, "pkt_flush", frm_info->frame_no,
+					frm_info->request_no, frm_info->request_fd,
+					frm_info->user_info[frm_idx].subfrm_idx,
+					frm_info->user_info[frm_idx].hw_comb,
+					frm_info->frm_owner, cb_param, frm_idx, frm_num,
+					blk_idx, cmd_buf->frame_block);
+
+				cmdq_pkt_finalize(&cb_param->pkt);
+				dma_sync_single_for_device(clt->chan->mbox->dev,
+						cb_param->pkt.pa_base,
+						cb_param->pkt.cmd_buf_size,
+						DMA_TO_DEVICE);
+
+				mbox_send_message(clt->chan, &cb_param->pkt);
+				mbox_client_txdone(clt->chan, 0);
+				IMGSYS_SYSTRACE_END();
+				if (ret_flush < 0)
+					pr_info(
+					"%s: [ERROR] cmdq_pkt_flush_async fail(%d) for frm(%d/%d)!\n",
+						__func__, ret_flush, frm_idx, frm_num);
+				else
+					pr_debug(
+					"%s: cmdq_pkt_flush_async success(%d), blk(%d), frm(%d/%d)!\n",
+						__func__, ret_flush, blk_idx, frm_idx, frm_num);
+				isPack = 0;
+			} else {
+				isPack = 1;
+
+			}
+		} // block
+	} // frame
+
+sendtask_done:
+
+	return ret;
+}
+
+int imgsys_cmdq_parser(struct swfrm_info_t *frm_info, struct cmdq_pkt *pkt,
+						struct Command *cmd, u32 hw_comb, u32 cmd_num,
+						dma_addr_t dma_pa, uint32_t *num, u32 thd_idx)
+{
+	bool stop = 0;
+	int count = 0;
+	int req_fd = 0, req_no = 0, frm_no = 0;
+	u32 event = 0;
+
+	req_fd = frm_info->request_fd;
+	req_no = frm_info->request_no;
+	frm_no = frm_info->frame_no;
+
+	pr_debug("%s: +, cmd(%d)\n", __func__, cmd->opcode);
+
+	do {
+		switch (cmd->opcode) {
+		case IMGSYS_CMD_READ:
+			if ((cmd->u.address < IMGSYS_REG_START) ||
+				(cmd->u.address > IMGSYS_REG_END)) {
+				pr_info(
+					"%s: [ERROR] READ with source(0x%08llx) target(0x%08llx) mask(0x%08x)\n",
+					__func__, cmd->u.source, cmd->u.target, cmd->u.mask);
+				return -1;
+			}
+			pr_debug(
+				"%s: READ with source(0x%08llx) target(0x%08llx) mask(0x%08x)\n",
+				__func__, cmd->u.source, cmd->u.target, cmd->u.mask);
+			if (imgsys_wpe_bwlog_enable()) {
+				cmdq_pkt_mem_move(pkt, (dma_addr_t)cmd->u.source,
+					dma_pa + (4*(*num)), CMDQ_THR_SPR_IDX3);
+				(*num)++;
+			} else
+				pr_info(
+					"%s: [ERROR]Not enable imgsys read cmd!!\n",
+					__func__);
+			break;
+		case IMGSYS_CMD_WRITE:
+			if ((cmd->u.address < IMGSYS_REG_START) ||
+				(cmd->u.address > IMGSYS_REG_END)) {
+				pr_info(
+					"%s: [ERROR] WRITE with addr(0x%08llx) value(0x%08x) mask(0x%08x)\n",
+					__func__, cmd->u.address, cmd->u.value, cmd->u.mask);
+				return -1;
+			}
+			pr_debug(
+				"%s: WRITE with addr(0x%08llx) value(0x%08x) mask(0x%08x)\n",
+				__func__, cmd->u.address, cmd->u.value, cmd->u.mask);
+			cmdq_pkt_write_value_addr(pkt, (dma_addr_t)cmd->u.address,
+					cmd->u.value, cmd->u.mask);
+			break;
+		case IMGSYS_CMD_POLL:
+			if ((cmd->u.address < IMGSYS_REG_START) ||
+				(cmd->u.address > IMGSYS_REG_END)) {
+				pr_info(
+					"%s: [ERROR] POLL with addr(0x%08llx) value(0x%08x) mask(0x%08x) thd(%d)\n",
+					__func__, cmd->u.address, cmd->u.value, cmd->u.mask,
+					thd_idx);
+				return -1;
+			}
+			pr_debug(
+				"%s: POLL with addr(0x%08llx) value(0x%08x) mask(0x%08x) thd(%d)\n",
+				__func__, cmd->u.address, cmd->u.value, cmd->u.mask, thd_idx);
+			/* cmdq_pkt_poll(pkt, NULL, cmd->u.value, cmd->u.address, */
+			/* cmd->u.mask, CMDQ_GPR_R15); */
+			cmdq_pkt_poll_addr(pkt, cmd->u.value, cmd->u.address, cmd->u.mask, 1);
+			break;
+		case IMGSYS_CMD_WAIT:
+			if ((cmd->u.event < 0) || (cmd->u.event >= IMGSYS_CMDQ_EVENT_MAX)) {
+				pr_info(
+					"%s: [ERROR] WAIT event(%d) index is over maximum(%d) with action(%d)!\n",
+					__func__, cmd->u.event, IMGSYS_CMDQ_EVENT_MAX,
+					cmd->u.action);
+				return -1;
+			}
+			pr_debug(
+				"%s: WAIT event(%d/%d) action(%d)\n",
+				__func__, cmd->u.event, imgsys_event[cmd->u.event].event,
+				cmd->u.action);
+			if (cmd->u.action == 1) {
+				cmdq_pkt_wfe(pkt, imgsys_event[cmd->u.event].event, true);
+				if ((cmd->u.event >= IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_START) &&
+					(cmd->u.event <= IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_END)) {
+					event = cmd->u.event -
+						IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_START;
+					event_hist[event].st++;
+					event_hist[event].wait.req_fd = req_fd;
+					event_hist[event].wait.req_no = req_no;
+					event_hist[event].wait.frm_no = frm_no;
+					event_hist[event].wait.ts = ktime_get_boottime_ns()/1000;
+					event_hist[event].wait.frm_info = frm_info;
+					event_hist[event].wait.pkt = pkt;
+				}
+			} else if (cmd->u.action == 0)
+				cmdq_pkt_wfe(pkt, imgsys_event[cmd->u.event].event, false);
+			else
+				pr_info("%s: [ERROR]Not Support wait action(%d)!\n",
+					__func__, cmd->u.action);
+			break;
+		case IMGSYS_CMD_UPDATE:
+			if ((cmd->u.event < 0) || (cmd->u.event >= IMGSYS_CMDQ_EVENT_MAX)) {
+				pr_info(
+					"%s: [ERROR] UPDATE event(%d) index is over maximum(%d) with action(%d)!\n",
+					__func__, cmd->u.event, IMGSYS_CMDQ_EVENT_MAX,
+					cmd->u.action);
+				return -1;
+			}
+			pr_debug(
+				"%s: UPDATE event(%d/%d) action(%d)\n",
+				__func__, cmd->u.event, imgsys_event[cmd->u.event].event,
+				cmd->u.action);
+			if (cmd->u.action == 1) {
+				cmdq_pkt_set_event(pkt, imgsys_event[cmd->u.event].event);
+				if ((cmd->u.event >= IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_START) &&
+					(cmd->u.event <= IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_END)) {
+					event = cmd->u.event -
+						IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_START;
+					event_hist[event].st--;
+					event_hist[event].set.req_fd = req_fd;
+					event_hist[event].set.req_no = req_no;
+					event_hist[event].set.frm_no = frm_no;
+					event_hist[event].set.ts = ktime_get_boottime_ns()/1000;
+					event_hist[event].set.frm_info = frm_info;
+					event_hist[event].set.pkt = pkt;
+				}
+			} else if (cmd->u.action == 0)
+				cmdq_pkt_clear_event(pkt, imgsys_event[cmd->u.event].event);
+			else
+				pr_info("%s: [ERROR]Not Support update action(%d)!\n",
+					__func__, cmd->u.action);
+			break;
+		case IMGSYS_CMD_ACQUIRE:
+			if ((cmd->u.event < 0) || (cmd->u.event >= IMGSYS_CMDQ_EVENT_MAX)) {
+				pr_info(
+					"%s: [ERROR] ACQUIRE event(%d) index is over maximum(%d) with action(%d)!\n",
+					__func__, cmd->u.event, IMGSYS_CMDQ_EVENT_MAX,
+					cmd->u.action);
+				return -1;
+			}
+			pr_debug(
+				"%s: ACQUIRE event(%d/%d) action(%d)\n", __func__,
+				cmd->u.event, imgsys_event[cmd->u.event].event, cmd->u.action);
+				cmdq_pkt_acquire_event(pkt, imgsys_event[cmd->u.event].event);
+			break;
+		case IMGSYS_CMD_TIME:
+			pr_debug(
+				"%s: TIME with addr(0x%08llx) num(0x%08x)\n",
+				__func__, dma_pa, *num);
+#ifdef CMDQ_EXT_TS
+			if (imgsys_cmdq_ts_enable()) {
+				cmdq_pkt_write_indriect(pkt, NULL, dma_pa + (4*(*num)),
+					CMDQ_TPR_ID, ~0);
+				(*num)++;
+			} else
+#endif
+				pr_info(
+					"%s: [ERROR]Not enable imgsys cmdq ts function!!\n",
+					__func__);
+			break;
+		case IMGSYS_CMD_STOP:
+			pr_debug("%s: End Of Cmd!\n", __func__);
+			stop = 1;
+			break;
+		default:
+			pr_info("%s: [ERROR]Not Support Cmd(%d)!\n", __func__, cmd->opcode);
+			return -1;
+		}
+		cmd++;
+		count++;
+	} while ((stop == 0) && (count < cmd_num));
+
+	return count;
+}
+
+#if IMGSYS_SECURE_ENABLE
+void imgsys_cmdq_sec_task_cb(struct imgsys_cb_data data)
+{
+	struct cmdq_pkt *pkt_sec = (struct cmdq_pkt *)data.data;
+
+	cmdq_pkt_destroy(pkt_sec);
+}
+
+int imgsys_cmdq_sec_sendtask(struct mtk_imgsys_dev *imgsys_dev)
+{
+	int ret = 0;
+	struct cmdq_client *clt_sec = NULL;
+	struct cmdq_pkt *pkt_sec;
+
+	clt_sec = imgsys_sec_clt[0];
+	pkt_sec = cmdq_pkt_create(clt_sec);
+	cmdq_sec_pkt_set_data(pkt_sec, 0, 0, CMDQ_SEC_DEBUG, CMDQ_METAEX_TZMP);
+	cmdq_sec_pkt_set_mtee(pkt_sec, true);
+	cmdq_pkt_finalize_loop(pkt_sec);
+	cmdq_pkt_flush_threaded(pkt_sec, imgsys_cmdq_sec_task_cb, (void *)pkt_sec);
+	return ret;
+}
+#endif
+
+void imgsys_cmdq_sec_cmd(struct cmdq_pkt *pkt)
+{
+	cmdq_pkt_set_event(pkt, imgsys_event[IMGSYS_CMDQ_SYNC_TOKEN_TZMP_ISP_WAIT].event);
+	cmdq_pkt_wfe(pkt, imgsys_event[IMGSYS_CMDQ_SYNC_TOKEN_TZMP_ISP_SET].event, true);
+}
+
+void imgsys_cmdq_setevent(u64 u_id)
+{
+	u32 event_id = 0L, event_val = 0L;
+
+	event_id = 0/*IMGSYS_CMDQ_SYNC_TOKEN_CAMSYS_POOL_1*/ + (u_id % 10);
+	event_val = cmdq_get_event(imgsys_clt[0]->chan, imgsys_event[event_id].event);
+
+	if (event_val == 0) {
+		cmdq_set_event(imgsys_clt[0]->chan, imgsys_event[event_id].event);
+		pr_debug("%s: SetEvent success with (u_id/event_id/event_val)=(%lld/%d/%d)!\n",
+			__func__, u_id, event_id, event_val);
+	} else {
+		pr_info("%s: [ERROR]SetEvent fail with (u_id/event_id/event_val)=(%lld/%d/%d)!\n",
+			__func__, u_id, event_id, event_val);
+	}
+}
+#if CMDQ_EXT
+void imgsys_cmdq_clearevent(int event_id)
+{
+	cmdq_mbox_enable(imgsys_clt[0]->chan);
+	cmdq_clear_event(imgsys_clt[0]->chan, imgsys_event[event_id].event);
+	pr_debug("%s: cmdq_clear_event with (%d/%d)!\n",
+			__func__, event_id, imgsys_event[event_id].event);
+	cmdq_mbox_disable(imgsys_clt[0]->chan);
+}
+#endif
+#if DVFS_QOS_READY
+void mtk_imgsys_mmdvfs_init(struct mtk_imgsys_dev *imgsys_dev)
+{
+	struct mtk_imgsys_dvfs *dvfs_info = &imgsys_dev->dvfs_info;
+	u64 freq = 0;
+	int ret = 0, opp_num = 0, opp_idx = 0, idx = 0, volt;
+	struct device_node *np, *child_np = NULL;
+	struct of_phandle_iterator it;
+
+	memset((void *)dvfs_info, 0x0, sizeof(struct mtk_imgsys_dvfs));
+	dvfs_info->dev = imgsys_dev->dev;
+	dvfs_info->reg = NULL;
+	ret = dev_pm_opp_of_add_table(dvfs_info->dev);
+	if (ret < 0) {
+		dev_info(dvfs_info->dev,
+			"%s: [ERROR] fail to init opp table: %d\n", __func__, ret);
+		return;
+	}
+	dvfs_info->reg = devm_regulator_get(dvfs_info->dev, "dvfsrc-vmm");
+	if (IS_ERR_OR_NULL(dvfs_info->reg)) {
+		dev_info(dvfs_info->dev, "%s: [ERROR] can't get dvfsrc-vmm\n", __func__);
+		return;
+	}
+
+	opp_num = regulator_count_voltages(dvfs_info->reg);
+	of_for_each_phandle(
+		&it, ret, dvfs_info->dev->of_node, "operating-points-v2", NULL, 0) {
+		np = of_node_get(it.node);
+		if (!np) {
+			dev_info(dvfs_info->dev, "%s: [ERROR] of_node_get fail\n", __func__);
+			return;
+		}
+
+		do {
+			child_np = of_get_next_available_child(np, child_np);
+			if (child_np) {
+				of_property_read_u64(child_np, "opp-hz", &freq);
+				dvfs_info->clklv[opp_idx][idx] = freq;
+				of_property_read_u32(child_np, "opp-microvolt", &volt);
+				dvfs_info->voltlv[opp_idx][idx] = volt;
+				idx++;
+			}
+		} while (child_np);
+		dvfs_info->clklv_num[opp_idx] = idx;
+		dvfs_info->clklv_target[opp_idx] = dvfs_info->clklv[opp_idx][0];
+		dvfs_info->clklv_idx[opp_idx] = 0;
+		idx = 0;
+		opp_idx++;
+		of_node_put(np);
+	}
+
+	opp_num = opp_idx;
+	for (opp_idx = 0; opp_idx < opp_num; opp_idx++) {
+		for (idx = 0; idx < dvfs_info->clklv_num[opp_idx]; idx++) {
+			dev_info(dvfs_info->dev, "[%s] opp=%d, idx=%d, clk=%d volt=%d\n",
+				__func__, opp_idx, idx, dvfs_info->clklv[opp_idx][idx],
+				dvfs_info->voltlv[opp_idx][idx]);
+		}
+	}
+	dvfs_info->cur_volt = 0;
+	dvfs_info->vss_task_cnt = 0;
+	dvfs_info->smvr_task_cnt = 0;
+
+}
+
+void mtk_imgsys_mmdvfs_uninit(struct mtk_imgsys_dev *imgsys_dev)
+{
+	struct mtk_imgsys_dvfs *dvfs_info = &imgsys_dev->dvfs_info;
+	int volt = 0, ret = 0;
+
+	dev_info(dvfs_info->dev, "[%s]\n", __func__);
+
+	dvfs_info->cur_volt = volt;
+
+	if (IS_ERR_OR_NULL(dvfs_info->reg))
+		dev_info(dvfs_info->dev, "%s: [ERROR] reg is err or null\n", __func__);
+	else
+		ret = regulator_set_voltage(dvfs_info->reg, volt, INT_MAX);
+
+}
+
+void mtk_imgsys_mmdvfs_set(struct mtk_imgsys_dev *imgsys_dev,
+				struct swfrm_info_t *frm_info,
+				bool isSet)
+{
+	struct mtk_imgsys_dvfs *dvfs_info = &imgsys_dev->dvfs_info;
+	int volt = 0, ret = 0, idx = 0, opp_idx = 0;
+	unsigned long freq = 0;
+	/* u32 hw_comb = frm_info->user_info[0].hw_comb; */
+
+	freq = dvfs_info->freq;
+
+	if (IS_ERR_OR_NULL(dvfs_info->reg))
+		dev_dbg(dvfs_info->dev, "%s: [ERROR] reg is err or null\n", __func__);
+	else {
+		/* Choose for IPESYS */
+		/* if (hw_comb & IMGSYS_ENG_ME) */
+			/* opp_idx = 1; */
+
+		for (idx = 0; idx < dvfs_info->clklv_num[opp_idx]; idx++) {
+			if (freq <= dvfs_info->clklv[opp_idx][idx])
+				break;
+		}
+		if (idx == dvfs_info->clklv_num[opp_idx])
+			idx--;
+		volt = dvfs_info->voltlv[opp_idx][idx];
+
+		if (dvfs_info->cur_volt != volt) {
+			if (imgsys_dvfs_dbg_enable())
+				dev_info(dvfs_info->dev, "[%s] volt change opp=%d, idx=%d, clk=%d volt=%d\n",
+					__func__, opp_idx, idx, dvfs_info->clklv[opp_idx][idx],
+					dvfs_info->voltlv[opp_idx][idx]);
+			ret = regulator_set_voltage(dvfs_info->reg, volt, INT_MAX);
+			dvfs_info->cur_volt = volt;
+		}
+	}
+}
+
+void mtk_imgsys_mmqos_init(struct mtk_imgsys_dev *imgsys_dev)
+{
+	struct mtk_imgsys_qos *qos_info = &imgsys_dev->qos_info;
+	//struct icc_path *path;
+	int idx = 0;
+
+	memset((void *)qos_info, 0x0, sizeof(struct mtk_imgsys_qos));
+	qos_info->dev = imgsys_dev->dev;
+	qos_info->qos_path = imgsys_qos_path;
+
+	for (idx = 0; idx < IMGSYS_M4U_PORT_MAX; idx++) {
+		qos_info->qos_path[idx].path =
+			of_mtk_icc_get(qos_info->dev, qos_info->qos_path[idx].dts_name);
+		qos_info->qos_path[idx].bw = 0;
+		dev_info(qos_info->dev, "[%s] idx=%d, path=%p, name=%s, bw=%d\n",
+			__func__, idx,
+			qos_info->qos_path[idx].path,
+			qos_info->qos_path[idx].dts_name,
+			qos_info->qos_path[idx].bw);
+	}
+	mtk_imgsys_mmqos_reset(imgsys_dev);
+}
+
+void mtk_imgsys_mmqos_uninit(struct mtk_imgsys_dev *imgsys_dev)
+{
+	struct mtk_imgsys_qos *qos_info = &imgsys_dev->qos_info;
+	int idx = 0;
+
+	for (idx = 0; idx < IMGSYS_M4U_PORT_MAX; idx++) {
+		if (IS_ERR_OR_NULL(qos_info->qos_path[idx].path)) {
+			dev_dbg(qos_info->dev, "[%s] path of idx(%d) is NULL\n", __func__, idx);
+			continue;
+		}
+		dev_dbg(qos_info->dev, "[%s] idx=%d, path=%p, bw=%d\n",
+			__func__, idx,
+			qos_info->qos_path[idx].path,
+			qos_info->qos_path[idx].bw);
+		qos_info->qos_path[idx].bw = 0;
+		mtk_icc_set_bw(qos_info->qos_path[idx].path, 0, 0);
+	}
+}
+
+void mtk_imgsys_mmqos_set(struct mtk_imgsys_dev *imgsys_dev,
+				struct swfrm_info_t *frm_info,
+				bool isSet)
+{
+	struct mtk_imgsys_qos *qos_info = &imgsys_dev->qos_info;
+	u32 hw_comb = 0;
+	//u32 port_st = 0, port_num = 0, port_idx = 0;
+	u32 frm_num = 0, frm_idx = 0;
+	u32 bw;
+
+#if IMGSYS_QOS_ENABLE
+	u32 dvfs_idx = 0, qos_idx = 0;
+	u64 bw_cal[MTK_IMGSYS_DVFS_GROUP][MTK_IMGSYS_QOS_GROUP] = {0};
+	u64 bw_final[MTK_IMGSYS_QOS_GROUP] = {0};
+#else
+	u32 port_st = 0;
+	u32 port_idx = 0;
+	u32 port_num = IMGSYS_M4U_PORT_MAX;
+#endif
+
+	bw = 0;
+	frm_num = frm_info->total_frmnum;
+	for (frm_idx = 0; frm_idx < frm_num; frm_idx++)
+		hw_comb |= frm_info->user_info[frm_idx].hw_comb;
+
+	#if IMGSYS_QOS_ENABLE
+	if (is_stream_off == 0) {
+		if (isSet == 0) {
+			qos_info->req_cnt++;
+			if (qos_info->req_cnt < imgsys_qos_update_freq)
+				/* Do nothing */
+				bw = 0;
+			else if (qos_info->req_cnt == imgsys_qos_update_freq) {
+				for (qos_idx = 0; qos_idx < MTK_IMGSYS_QOS_GROUP; qos_idx++) {
+					for (dvfs_idx = 0; dvfs_idx < MTK_IMGSYS_DVFS_GROUP;
+						dvfs_idx++) {
+						bw_cal[dvfs_idx][qos_idx] =
+							qos_info->bw_total[dvfs_idx][qos_idx] /
+							qos_info->ts_total[dvfs_idx];
+						bw_final[qos_idx] += bw_cal[dvfs_idx][qos_idx];
+					}
+					bw_final[qos_idx] =
+						(bw_final[qos_idx] * imgsys_qos_factor) / 10;
+				}
+				dev_dbg(qos_info->dev,
+					"%s: bw_final(%lld/%lld) bw_cal_a(%lld/%lld) bw_cal_b(%lld/%lld) bw_a(%lld/%lld) bw_b(%lld/%lld) ts(%d/%lld) para(%d/%d/%d)\n",
+					__func__, bw_final[0], bw_final[1],
+					bw_cal[0][0], bw_cal[0][1], bw_cal[1][0], bw_cal[1][1],
+					qos_info->bw_total[0][0], qos_info->bw_total[0][1],
+					qos_info->bw_total[1][0], qos_info->bw_total[1][1],
+					qos_info->ts_total[0], qos_info->ts_total[1],
+					imgsys_qos_update_freq, imgsys_qos_blank_int,
+					imgsys_qos_factor);
+				/* Add update bw api */
+				mtk_icc_set_bw(
+					qos_info->qos_path[IMGSYS_L9_COMMON_0].path,
+					MBps_to_icc(bw_final[0]),
+					0);
+				mtk_icc_set_bw(
+					qos_info->qos_path[IMGSYS_L12_COMMON_1].path,
+					MBps_to_icc(bw_final[1]),
+					0);
+			} else if ((qos_info->req_cnt > imgsys_qos_update_freq) &&
+					(qos_info->req_cnt <=
+					(imgsys_qos_update_freq + imgsys_qos_blank_int))) {
+				qos_info->isIdle = 1;
+			} else {
+				for (dvfs_idx = 0; dvfs_idx < MTK_IMGSYS_DVFS_GROUP; dvfs_idx++) {
+					for (qos_idx = 0; qos_idx < MTK_IMGSYS_QOS_GROUP; qos_idx++)
+						qos_info->bw_total[dvfs_idx][qos_idx] = 0;
+					qos_info->ts_total[dvfs_idx] = 0;
+				}
+				qos_info->req_cnt = 0;
+				qos_info->isIdle = 0;
+			}
+		}
+	} else {
+		/* Set bw to zero */
+		mtk_icc_set_bw(qos_info->qos_path[IMGSYS_L9_COMMON_0].path, 0, 0);
+		mtk_icc_set_bw(qos_info->qos_path[IMGSYS_L12_COMMON_1].path, 0, 0);
+	}
+	#else
+	bw = 10240;
+	for (port_idx = port_st; port_idx < (port_num + port_st); port_idx++) {
+		if (IS_ERR_OR_NULL(qos_info->qos_path[port_idx].path)) {
+			dev_dbg(qos_info->dev, "[ERROR] [%s] path of idx(%d) is NULL\n",
+				__func__, port_idx);
+			continue;
+		}
+		if (qos_info->qos_path[port_idx].bw != bw) {
+			dev_dbg(qos_info->dev, "[%s] idx=%d, path=%p, bw=%d/%d,\n",
+				__func__, port_idx,
+				qos_info->qos_path[port_idx].path,
+				qos_info->qos_path[port_idx].bw, bw);
+			qos_info->qos_path[port_idx].bw = bw;
+			mtk_icc_set_bw(
+				qos_info->qos_path[port_idx].path,
+				MBps_to_icc(qos_info->qos_path[port_idx].bw),
+				MBps_to_icc(qos_info->qos_path[port_idx].bw));
+		}
+	}
+	#endif
+}
+
+void mtk_imgsys_mmqos_set_by_scen(struct mtk_imgsys_dev *imgsys_dev,
+				struct swfrm_info_t *frm_info,
+				bool isSet)
+{
+	struct mtk_imgsys_qos *qos_info = &imgsys_dev->qos_info;
+	u32 hw_comb = 0;
+	u64 pixel_sz = 0;
+	u32 fps = 0;
+	u32 frm_num = 0;
+	u64 bw_final[MTK_IMGSYS_QOS_GROUP] = {0};
+
+	frm_num = frm_info->total_frmnum;
+	hw_comb = frm_info->user_info[frm_num-1].hw_comb;
+	pixel_sz = frm_info->user_info[frm_num-1].pixel_bw;
+	fps = frm_info->fps;
+
+	if (is_stream_off == 0) {
+		if (isSet == 1) {
+			if ((hw_comb & (IMGSYS_ENG_WPE_TNR | IMGSYS_ENG_DIP)) ==
+				(IMGSYS_ENG_WPE_TNR | IMGSYS_ENG_DIP)) {
+				if (fps == 30) {
+					if (pixel_sz > IMGSYS_QOS_4K_SIZE) {
+						bw_final[0] = IMGSYS_QOS_4K_30_BW_0;
+						bw_final[1] = IMGSYS_QOS_4K_30_BW_1;
+					} else if (pixel_sz > IMGSYS_QOS_FHD_SIZE) {
+						bw_final[0] = IMGSYS_QOS_FHD_30_BW_0;
+						bw_final[1] = IMGSYS_QOS_FHD_30_BW_1;
+					} else {
+						bw_final[0] = IMGSYS_QOS_FHD_30_BW_0;
+						bw_final[1] = IMGSYS_QOS_FHD_30_BW_1;
+					}
+				} else if (fps == 60) {
+					if (pixel_sz > IMGSYS_QOS_4K_SIZE) {
+						bw_final[0] = IMGSYS_QOS_4K_60_BW_0;
+						bw_final[1] = IMGSYS_QOS_4K_60_BW_1;
+					} else if (pixel_sz > IMGSYS_QOS_FHD_SIZE) {
+						bw_final[0] = IMGSYS_QOS_FHD_60_BW_0;
+						bw_final[1] = IMGSYS_QOS_FHD_60_BW_1;
+					} else {
+						bw_final[0] = IMGSYS_QOS_FHD_60_BW_0;
+						bw_final[1] = IMGSYS_QOS_FHD_60_BW_1;
+					}
+				} else {
+					if (pixel_sz > IMGSYS_QOS_4K_SIZE) {
+						bw_final[0] = IMGSYS_QOS_4K_30_BW_0;
+						bw_final[1] = IMGSYS_QOS_4K_30_BW_1;
+					} else if (pixel_sz > IMGSYS_QOS_FHD_SIZE) {
+						bw_final[0] = IMGSYS_QOS_FHD_30_BW_0;
+						bw_final[1] = IMGSYS_QOS_FHD_30_BW_1;
+					} else {
+						bw_final[0] = IMGSYS_QOS_FHD_30_BW_0;
+						bw_final[1] = IMGSYS_QOS_FHD_30_BW_1;
+					}
+				}
+				bw_final[0] = (bw_final[0] * imgsys_qos_factor)/10;
+				bw_final[1] = (bw_final[1] * imgsys_qos_factor)/10;
+				if (qos_info->qos_path[IMGSYS_L9_COMMON_0].bw != bw_final[0]) {
+					dev_dbg(qos_info->dev,
+						"[%s] L9_0 idx=%d, path=%p, bw=%d/%d; L12_1 idx=%d, path=%p, bw=%d/%d,\n",
+						__func__,
+						IMGSYS_L9_COMMON_0,
+						qos_info->qos_path[IMGSYS_L9_COMMON_0].path,
+						qos_info->qos_path[IMGSYS_L9_COMMON_0].bw,
+						bw_final[0],
+						IMGSYS_L12_COMMON_1,
+						qos_info->qos_path[IMGSYS_L12_COMMON_1].path,
+						qos_info->qos_path[IMGSYS_L12_COMMON_1].bw,
+						bw_final[1]);
+					qos_info->qos_path[IMGSYS_L9_COMMON_0].bw = bw_final[0];
+					qos_info->qos_path[IMGSYS_L12_COMMON_1].bw = bw_final[1];
+					mtk_icc_set_bw(
+					qos_info->qos_path[IMGSYS_L9_COMMON_0].path,
+					MBps_to_icc(qos_info->qos_path[IMGSYS_L9_COMMON_0].bw),
+					0);
+					mtk_icc_set_bw(
+					qos_info->qos_path[IMGSYS_L12_COMMON_1].path,
+					MBps_to_icc(qos_info->qos_path[IMGSYS_L12_COMMON_1].bw),
+					0);
+				}
+			}
+		}
+	}
+}
+
+void mtk_imgsys_mmqos_reset(struct mtk_imgsys_dev *imgsys_dev)
+{
+	u32 dvfs_idx = 0, qos_idx = 0;
+	struct mtk_imgsys_qos *qos_info = NULL;
+
+	qos_info = &imgsys_dev->qos_info;
+
+	qos_info->qos_path[IMGSYS_L9_COMMON_0].bw = 0;
+	qos_info->qos_path[IMGSYS_L12_COMMON_1].bw = 0;
+
+	mtk_icc_set_bw(qos_info->qos_path[IMGSYS_L9_COMMON_0].path, 0, 0);
+	mtk_icc_set_bw(qos_info->qos_path[IMGSYS_L12_COMMON_1].path, 0, 0);
+
+	for (dvfs_idx = 0; dvfs_idx < MTK_IMGSYS_DVFS_GROUP; dvfs_idx++) {
+		for (qos_idx = 0; qos_idx < MTK_IMGSYS_QOS_GROUP; qos_idx++)
+			qos_info->bw_total[dvfs_idx][qos_idx] = 0;
+		qos_info->ts_total[dvfs_idx] = 0;
+	}
+	qos_info->req_cnt = 0;
+	qos_info->isIdle = 0;
+
+	if (imgsys_qos_update_freq == 0)
+		imgsys_qos_update_freq = IMGSYS_QOS_UPDATE_FREQ;
+	if (imgsys_qos_blank_int == 0)
+		imgsys_qos_blank_int = IMGSYS_QOS_BLANK_INT;
+	if (imgsys_qos_factor == 0)
+		imgsys_qos_factor = IMGSYS_QOS_FACTOR;
+
+}
+
+void mtk_imgsys_mmdvfs_mmqos_cal(struct mtk_imgsys_dev *imgsys_dev,
+				struct swfrm_info_t *frm_info,
+				bool isSet)
+{
+	struct mtk_imgsys_dvfs *dvfs_info = NULL;
+	struct mtk_imgsys_qos *qos_info = NULL;
+	unsigned long pixel_size[MTK_IMGSYS_DVFS_GROUP] = {0};
+	int frm_num = 0, frm_idx = 0, g_idx;
+	u32 hw_comb = 0;
+	u32 batch_num = 0;
+	u32 fps = 0;
+	u32 bw_exe = 0;
+	unsigned long freq = 0;
+	#if IMGSYS_DVFS_ENABLE
+	unsigned long pixel_max = 0, pixel_total_max = 0;
+	/* struct timeval curr_time; */
+	u64 ts_fps = 0;
+	#endif
+	#if IMGSYS_QOS_ENABLE
+	struct frame_bw_t *bw_buf = NULL;
+	void *smi_port = NULL;
+	u32 port_st = 0, port_num = 0, port_idx = 0;
+	#endif
+
+	dvfs_info = &imgsys_dev->dvfs_info;
+	qos_info = &imgsys_dev->qos_info;
+	frm_num = frm_info->total_frmnum;
+	batch_num = frm_info->batchnum;
+	fps = frm_info->fps;
+	/* fps = (batch_num)?(frm_info->fps*batch_num):frm_info->fps; */
+	bw_exe = fps;
+	hw_comb = frm_info->user_info[0].hw_comb;
+
+	/* Calculate DVFS*/
+	if (fps != 0) {
+		for (frm_idx = 0; frm_idx < frm_num; frm_idx++) {
+			for (g_idx = 0; g_idx < MTK_IMGSYS_DVFS_GROUP; g_idx++) {
+				if (frm_info->user_info[frm_idx].hw_comb & dvfs_group[g_idx].g_hw)
+					pixel_size[g_idx] += frm_info->user_info[frm_idx].pixel_bw;
+			}
+		}
+	}
+	#if IMGSYS_DVFS_ENABLE
+	/* Check current time */
+	/* do_gettimeofday(&curr_time); */
+	/* ts_curr = curr_time.tv_sec * 1000000 + curr_time.tv_usec; */
+	/* ts_eq = frm_info->eqtime.tv_sec * 1000000 + frm_info->eqtime.tv_usec; */
+	/* ts_sw = ts_curr - ts_eq; */
+	if (fps != 0)
+		ts_fps = 1000000 / fps;
+	else
+		ts_fps = 0;
+
+	if (isSet == 1) {
+		if (fps != 0) {
+			for (g_idx = 0; g_idx < MTK_IMGSYS_DVFS_GROUP; g_idx++) {
+				dvfs_info->pixel_size[g_idx] += (pixel_size[g_idx]*fps);
+				if (pixel_size[g_idx] > pixel_max)
+					pixel_max = pixel_size[g_idx];
+				if (dvfs_info->pixel_size[g_idx] > pixel_total_max)
+					pixel_total_max = dvfs_info->pixel_size[g_idx];
+			}
+
+			if (batch_num > 1) {
+				dvfs_info->smvr_task_cnt++;
+				if (pixel_total_max < IMGSYS_SMVR_FREQ_FLOOR)
+					freq = IMGSYS_SMVR_FREQ_FLOOR;
+				else
+					freq = pixel_total_max;
+			} else if (dvfs_info->smvr_task_cnt == 0)
+				freq = pixel_total_max;
+
+			if (dvfs_info->vss_task_cnt == 0)
+				dvfs_info->freq = freq;
+		} else {
+			dvfs_info->vss_task_cnt++;
+			freq = IMGSYS_VSS_FREQ_FLOOR; /* Forcing highest frequency if fps is 0 */
+			if (freq > dvfs_info->freq)
+				dvfs_info->freq = freq;
+		}
+	} else if (isSet == 0) {
+		if (fps != 0) {
+			for (g_idx = 0; g_idx < MTK_IMGSYS_DVFS_GROUP; g_idx++) {
+				dvfs_info->pixel_size[g_idx] -= (pixel_size[g_idx]*fps);
+				if (pixel_size[g_idx] > pixel_max)
+					pixel_max = pixel_size[g_idx];
+				if (dvfs_info->pixel_size[g_idx] > pixel_total_max)
+					pixel_total_max = dvfs_info->pixel_size[g_idx];
+			}
+
+			if (batch_num > 1) {
+				dvfs_info->smvr_task_cnt--;
+				if (pixel_total_max < IMGSYS_SMVR_FREQ_FLOOR)
+					freq = IMGSYS_SMVR_FREQ_FLOOR;
+				else
+					freq = pixel_total_max;
+			} else if (dvfs_info->smvr_task_cnt == 0)
+				freq = pixel_total_max;
+
+			if (dvfs_info->vss_task_cnt == 0)
+				dvfs_info->freq = freq;
+
+			//if (pixel_total_max == 0) {
+			//	freq = 0;
+			//	dvfs_info->freq = freq;
+			//}
+		} else {
+			dvfs_info->vss_task_cnt--;
+			if (dvfs_info->vss_task_cnt == 0) {
+				for (g_idx = 0; g_idx < MTK_IMGSYS_DVFS_GROUP; g_idx++)
+					if (dvfs_info->pixel_size[g_idx] > pixel_total_max)
+						pixel_total_max = dvfs_info->pixel_size[g_idx];
+				freq = pixel_total_max;
+				dvfs_info->freq = freq;
+			}
+		}
+	}
+
+	if (imgsys_dvfs_dbg_enable())
+		dev_info(qos_info->dev,
+		"[%s] isSet(%d) fps(%d/%d) batchNum(%d) bw_exe(%d) vss(%d) smvr(%d) freq(%lld/%lld) local_pix_sz(%lld/%lld/%lld/%lld) global_pix_sz(%lld/%lld/%lld/%lld)\n",
+		__func__, isSet, fps, frm_info->fps, batch_num, bw_exe,
+		dvfs_info->vss_task_cnt, dvfs_info->smvr_task_cnt, freq, dvfs_info->freq,
+		pixel_size[0], pixel_size[1], pixel_size[2], pixel_max,
+		dvfs_info->pixel_size[0], dvfs_info->pixel_size[1],
+		dvfs_info->pixel_size[2], pixel_total_max
+		);
+	#else
+	if (isSet == 1) {
+		for (g_idx = 0; g_idx < MTK_IMGSYS_DVFS_GROUP; g_idx++)
+			dvfs_info->pixel_size[0] += pixel_size[g_idx];
+		freq = 650000000;
+		dvfs_info->freq = freq;
+	} else if (isSet == 0) {
+		for (g_idx = 0; g_idx < MTK_IMGSYS_DVFS_GROUP; g_idx++)
+			dvfs_info->pixel_size[0] -= pixel_size[g_idx];
+		if (dvfs_info->pixel_size[0] == 0) {
+			freq = 0;
+			dvfs_info->freq = freq;
+		}
+	}
+	#endif
+
+	/* Calculate QOS*/
+	#if IMGSYS_QOS_ENABLE
+	if ((isSet == 0) && (qos_info->isIdle == 0) && (is_stream_off == 0)) {
+		for (frm_idx = 0; frm_idx < frm_num; frm_idx++) {
+			hw_comb = frm_info->user_info[frm_idx].hw_comb;
+			bw_buf = (struct frame_bw_t *)frm_info->user_info[frm_idx].bw_swbuf;
+			//pixel_size += frm_info->user_info[frm_idx].pixel_bw;
+			if (hw_comb & IMGSYS_ENG_WPE_EIS) {
+				port_st = IMGSYS_M4U_PORT_WPE_EIS_START;
+				port_num = WPE_SMI_PORT_NUM;
+				smi_port = (void *)bw_buf->wpe_eis.smiport;
+				mtk_imgsys_mmqos_bw_cal(imgsys_dev, smi_port, hw_comb,
+					port_st, port_num, 0);
+			}
+			if (hw_comb & IMGSYS_ENG_WPE_TNR) {
+				port_st = IMGSYS_M4U_PORT_WPE_TNR_START;
+				port_num = WPE_SMI_PORT_NUM;
+				smi_port = (void *)bw_buf->wpe_tnr.smiport;
+				mtk_imgsys_mmqos_bw_cal(imgsys_dev, smi_port, hw_comb,
+					port_st, port_num, 1);
+			}
+#if IMGSYS_WPE_NUM == 3
+			if (hw_comb & IMGSYS_ENG_WPE_LITE) {
+				port_st = IMGSYS_M4U_PORT_WPE_LITE_START;
+				port_num = WPE_SMI_PORT_NUM;
+				smi_port = (void *)bw_buf->wpe_lite.smiport;
+				mtk_imgsys_mmqos_bw_cal(imgsys_dev, smi_port, hw_comb,
+					port_st, port_num, 0);
+			}
+#endif
+			if (hw_comb & IMGSYS_ENG_TRAW) {
+				port_st = IMGSYS_M4U_PORT_TRAW_START;
+				port_num = TRAW_SMI_PORT_NUM;
+				smi_port = (void *)bw_buf->traw.smiport;
+				mtk_imgsys_mmqos_bw_cal(imgsys_dev, smi_port, hw_comb,
+					port_st, port_num, 0);
+			}
+			if (hw_comb & IMGSYS_ENG_LTR) {
+				port_st = IMGSYS_M4U_PORT_LTRAW_START;
+				port_num = LTRAW_SMI_PORT_NUM;
+				smi_port = (void *)bw_buf->ltraw.smiport;
+				mtk_imgsys_mmqos_bw_cal(imgsys_dev, smi_port, hw_comb,
+					port_st, port_num, 0);
+			}
+#if IMGSYS_TRAW_NUM == 3
+			if (hw_comb & IMGSYS_ENG_XTR) {
+				port_st = IMGSYS_M4U_PORT_XTRAW_START;
+				port_num = XTRAW_SMI_PORT_NUM;
+				smi_port = (void *)bw_buf->xtraw.smiport;
+				mtk_imgsys_mmqos_bw_cal(imgsys_dev, smi_port, hw_comb,
+					port_st, port_num, 0);
+			}
+#endif
+			if (hw_comb & IMGSYS_ENG_DIP) {
+#ifdef IMGSYS_VER_ISP71
+				port_st = IMGSYS_M4U_PORT_DIP0_START;
+				port_num = DIP0_SMI_PORT_NUM;
+				smi_port = (void *)bw_buf->dip.smiport;
+				mtk_imgsys_mmqos_bw_cal(imgsys_dev, smi_port, hw_comb,
+					port_st, port_num, 0);
+				port_st = IMGSYS_M4U_PORT_DIP1_START;
+				port_num = DIP1_SMI_PORT_NUM;
+				port_idx = IMGSYS_M4U_PORT_DIP1_START -
+						IMGSYS_M4U_PORT_DIP0_START;
+				smi_port =
+					(void *)(bw_buf->dip.smiport+port_idx);
+				mtk_imgsys_mmqos_bw_cal(imgsys_dev, smi_port, hw_comb,
+					port_st, port_num, 1);
+#else
+				port_st = IMGSYS_M4U_PORT_DIP_START;
+				port_num = DIP_SMI_PORT_NUM;
+				port_idx = 0;
+				smi_port = (void *)bw_buf->dip.smiport;
+				mtk_imgsys_mmqos_bw_cal(imgsys_dev, smi_port, hw_comb,
+					port_st, port_num, 0);
+#endif
+			}
+			if (hw_comb & IMGSYS_ENG_PQDIP_A) {
+				port_st = IMGSYS_M4U_PORT_PQDIP_A_START;
+				port_num = PQ_DIP_SMI_PORT_NUM;
+				smi_port = (void *)bw_buf->pqdip_a.smiport;
+				mtk_imgsys_mmqos_bw_cal(imgsys_dev, smi_port, hw_comb,
+					port_st, port_num, 0);
+			}
+			if (hw_comb & IMGSYS_ENG_PQDIP_B) {
+				port_st = IMGSYS_M4U_PORT_PQDIP_B_START;
+				port_num = PQ_DIP_SMI_PORT_NUM;
+				smi_port = (void *)bw_buf->pqdip_b.smiport;
+				mtk_imgsys_mmqos_bw_cal(imgsys_dev, smi_port, hw_comb,
+					port_st, port_num, 1);
+			}
+			if (hw_comb & IMGSYS_ENG_ME) {
+				port_st = IMGSYS_M4U_PORT_ME_START;
+				port_num = ME_SMI_PORT_NUM;
+				smi_port = (void *)bw_buf->me.smiport;
+				mtk_imgsys_mmqos_bw_cal(imgsys_dev, smi_port, hw_comb,
+					port_st, port_num, 1);
+			}
+		}
+	}
+	#endif
+
+}
+
+void mtk_imgsys_mmqos_bw_cal(struct mtk_imgsys_dev *imgsys_dev,
+					void *smi_port, uint32_t hw_comb,
+					uint32_t port_st, uint32_t port_num, uint32_t port_id)
+{
+	struct mtk_imgsys_qos *qos_info = NULL;
+	struct smi_port_t *smi = NULL;
+	uint32_t port_idx = 0, g_idx = 0;
+
+	qos_info = &imgsys_dev->qos_info;
+	smi = (struct smi_port_t *)smi_port;
+	for (port_idx = port_st; port_idx < (port_num + port_st); port_idx++)
+		for (g_idx = 0; g_idx < MTK_IMGSYS_DVFS_GROUP; g_idx++)
+			if (hw_comb & dvfs_group[g_idx].g_hw)
+				qos_info->bw_total[g_idx][port_id] += smi[port_idx-port_st].portbw;
+}
+
+void mtk_imgsys_mmqos_ts_cal(struct mtk_imgsys_dev *imgsys_dev,
+				struct mtk_imgsys_cb_param *cb_param, uint32_t hw_comb)
+{
+	struct mtk_imgsys_qos *qos_info = NULL;
+	uint32_t g_idx = 0;
+	u64 ts_hw = 0;
+
+	if (is_stream_off == 0) {
+		qos_info = &imgsys_dev->qos_info;
+		ts_hw = cb_param->cmdqTs.tsCmdqCbStart-cb_param->cmdqTs.tsFlushStart;
+		for (g_idx = 0; g_idx < MTK_IMGSYS_DVFS_GROUP; g_idx++)
+			if (hw_comb & dvfs_group[g_idx].g_hw)
+				qos_info->ts_total[g_idx] += ts_hw;
+	}
+}
+
+void mtk_imgsys_pwr(struct platform_device *pdev, bool on)
+{
+	struct mtk_imgsys_dev *imgsys_dev;
+
+	imgsys_dev = platform_get_drvdata(pdev);
+	mtk_imgsys_power_ctrl(imgsys_dev, on);
+}
+EXPORT_SYMBOL(mtk_imgsys_pwr);
+
+#endif
+
+void mtk_imgsys_power_ctrl(struct mtk_imgsys_dev *imgsys_dev, bool isPowerOn)
+{
+	struct mtk_imgsys_dvfs *dvfs_info = &imgsys_dev->dvfs_info;
+	u32 user_cnt = 0;
+	int i;
+
+	if (isPowerOn) {
+		user_cnt = atomic_inc_return(&imgsys_dev->imgsys_user_cnt);
+		if (user_cnt == 1) {
+			dev_info(dvfs_info->dev,
+				"[%s] isPowerOn(%d) user(%d)\n",
+				__func__, isPowerOn, user_cnt);
+
+			mutex_lock(&(imgsys_dev->power_ctrl_lock));
+
+			pm_runtime_get_sync(imgsys_dev->dev);
+
+			/*set default value for hw module*/
+			mtk_imgsys_mod_get(imgsys_dev);
+			for (i = 0; i < (imgsys_dev->num_mods); i++)
+				if (imgsys_dev->modules[i].set)
+					imgsys_dev->modules[i].set(imgsys_dev);
+			mutex_unlock(&(imgsys_dev->power_ctrl_lock));
+		}
+	} else {
+		user_cnt = atomic_dec_return(&imgsys_dev->imgsys_user_cnt);
+		if (user_cnt == 0) {
+			dev_info(dvfs_info->dev,
+				"[%s] isPowerOn(%d) user(%d)\n",
+				__func__, isPowerOn, user_cnt);
+
+			mutex_lock(&(imgsys_dev->power_ctrl_lock));
+
+			mtk_imgsys_mod_put(imgsys_dev);
+			pm_runtime_put_sync(imgsys_dev->dev);
+			//pm_runtime_mark_last_busy(imgsys_dev->dev);
+			//pm_runtime_put_autosuspend(imgsys_dev->dev);
+
+			mutex_unlock(&(imgsys_dev->power_ctrl_lock));
+		}
+	}
+}
+
+bool imgsys_cmdq_ts_enable(void)
+{
+	return imgsys_cmdq_ts_en;
+}
+
+u32 imgsys_wpe_bwlog_enable(void)
+{
+	return imgsys_wpe_bwlog_en;
+}
+
+bool imgsys_cmdq_ts_dbg_enable(void)
+{
+	return imgsys_cmdq_ts_dbg_en;
+}
+
+bool imgsys_dvfs_dbg_enable(void)
+{
+	return imgsys_dvfs_dbg_en;
+}
+
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/imgsys/mtk_imgsys-cmdq.h b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/mtk_imgsys-cmdq.h
new file mode 100755
index 0000000000000000000000000000000000000000..bd209b8d311608e4cf8dc53f73456a260d790a08
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/mtk_imgsys-cmdq.h
@@ -0,0 +1,200 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2021 MediaTek Inc.
+ *
+ * Author: Daniel Huang <daniel.huang@mediatek.com>
+ *
+ */
+#ifndef _MTK_IMGSYS_CMDQ_H_
+#define _MTK_IMGSYS_CMDQ_H_
+
+#include <linux/platform_device.h>
+#include <linux/soc/mediatek/mtk-cmdq.h>
+#include "mtk_imgsys-dev.h"
+#include "mtk_imgsys-sys.h"
+
+#define CMDQ_STOP_FUNC         (0)
+#define CMDQ_EXT         (0)
+//#define CMDQ_EXT_TS
+
+#define DVFS_QOS_READY         (0)
+
+#define MAX_FRAME_IN_TASK		64
+
+struct task_timestamp {
+	dma_addr_t dma_pa;
+	uint32_t *dma_va;
+	uint32_t num;
+	uint32_t ofst;
+};
+
+struct mtk_imgsys_cmdq_timestamp {
+	u64 tsReqStart;
+	u64 tsFlushStart;
+	u64 tsCmdqCbStart;
+	u64 tsCmdqCbEnd;
+	u64 tsCmdqCbWorkStart;
+	u64 tsUserCbStart;
+	u64 tsUserCbEnd;
+	u64 tsReqEnd;
+	u64 tsDvfsQosStart;
+	u64 tsDvfsQosEnd;
+};
+
+struct imgsys_cb_data {
+	struct cmdq_cb_data cmdq_data;
+	void *data;
+};
+
+struct mtk_imgsys_cb_param {
+	struct work_struct cmdq_cb_work;
+	//struct cmdq_pkt *pkt;
+	struct cmdq_pkt pkt;
+	struct swfrm_info_t *frm_info;
+	struct mtk_imgsys_cmdq_timestamp cmdqTs;
+	struct mtk_imgsys_dev *imgsys_dev;
+	struct cmdq_client *clt;
+	struct task_timestamp taskTs;
+	void (*user_cmdq_cb)(struct imgsys_cb_data data, uint32_t subfidx, bool isLastTaskInReq);
+	void (*user_cmdq_err_cb)(struct imgsys_cb_data data, uint32_t fail_subfidx, bool isHWhang);
+	s32 err;
+	u32 frm_idx;
+	u32 frm_num;
+	u32 blk_idx;
+	u32 blk_num;
+	u32 is_earlycb;
+	s32 group_id;
+	u32 thd_idx;
+	u32 task_id;
+	u32 task_num;
+	u32 task_cnt;
+	size_t pkt_ofst[MAX_FRAME_IN_TASK];
+	bool isBlkLast;
+	bool isFrmLast;
+	bool isTaskLast;
+};
+
+enum mtk_imgsys_cmd {
+	IMGSYS_CMD_LOAD = 0,
+	IMGSYS_CMD_MOVE,
+	IMGSYS_CMD_READ,
+	IMGSYS_CMD_WRITE,
+	IMGSYS_CMD_POLL,
+	IMGSYS_CMD_WAIT,
+	IMGSYS_CMD_UPDATE,
+	IMGSYS_CMD_ACQUIRE,
+	IMGSYS_CMD_TIME,
+	IMGSYS_CMD_STOP
+};
+
+enum mtk_imgsys_task_pri {
+	IMGSYS_PRI_HIGH   = 95,
+	IMGSYS_PRI_MEDIUM = 85,
+	IMGSYS_PRI_LOW    = 50
+};
+
+struct imgsys_event_info {
+	int req_fd;
+	int req_no;
+	int frm_no;
+	u64 ts;
+	struct swfrm_info_t *frm_info;
+	struct cmdq_pkt *pkt;
+	struct mtk_imgsys_cb_param *cb_param;
+};
+
+struct imgsys_event_history {
+	int st;
+	struct imgsys_event_info set;
+	struct imgsys_event_info wait;
+};
+
+struct imgsys_event_table {
+	u16 event;	/* cmdq event enum value */
+	char dts_name[256];
+};
+
+struct imgsys_dvfs_group {
+	u16 g_id;
+	u32 g_hw;
+};
+
+struct Command {
+	enum mtk_imgsys_cmd opcode;
+
+	union {
+		// For load, move, read
+		struct {
+			uint32_t mask;
+			uint64_t target;
+			uint64_t source;
+		} __packed;
+
+		// For write and poll
+		struct {
+			uint32_t dummy;
+			uint64_t address;
+			uint32_t value;
+		} __packed;
+
+		// For wait and update event
+		struct {
+			uint32_t event;
+			uint32_t action;
+		} __packed;
+	} u;
+} __packed;
+
+void imgsys_cmdq_init(struct mtk_imgsys_dev *imgsys_dev, const int nr_imgsys_dev);
+void imgsys_cmdq_release(struct mtk_imgsys_dev *imgsys_dev);
+void imgsys_cmdq_streamon(struct mtk_imgsys_dev *imgsys_dev);
+void imgsys_cmdq_streamoff(struct mtk_imgsys_dev *imgsys_dev);
+void imgsys_cmdq_cmd_dump(struct swfrm_info_t *frm_info, u32 frm_idx);
+int imgsys_cmdq_sendtask(struct mtk_imgsys_dev *imgsys_dev,
+				struct swfrm_info_t *frm_info,
+				void (*cmdq_cb)(struct imgsys_cb_data data,
+					uint32_t uinfo_idx, bool isLastTaskInReq),
+				void (*cmdq_err_cb)(struct imgsys_cb_data data,
+					uint32_t fail_uinfo_idx, bool isHWhang));
+int imgsys_cmdq_parser(struct swfrm_info_t *frm_info, struct cmdq_pkt *pkt,
+				struct Command *cmd, u32 hw_comb, u32 cmd_num,
+				dma_addr_t dma_pa, uint32_t *num, u32 thd_idx);
+int imgsys_cmdq_sec_sendtask(struct mtk_imgsys_dev *imgsys_dev);
+void imgsys_cmdq_sec_cmd(struct cmdq_pkt *pkt);
+void imgsys_cmdq_clearevent(int event_id);
+
+#if DVFS_QOS_READY
+void mtk_imgsys_mmdvfs_init(struct mtk_imgsys_dev *imgsys_dev);
+void mtk_imgsys_mmdvfs_uninit(struct mtk_imgsys_dev *imgsys_dev);
+void mtk_imgsys_mmdvfs_set(struct mtk_imgsys_dev *imgsys_dev,
+				struct swfrm_info_t *frm_info,
+				bool isSet);
+void mtk_imgsys_mmqos_init(struct mtk_imgsys_dev *imgsys_dev);
+void mtk_imgsys_mmqos_uninit(struct mtk_imgsys_dev *imgsys_dev);
+void mtk_imgsys_mmqos_set(struct mtk_imgsys_dev *imgsys_dev,
+				struct swfrm_info_t *frm_info,
+				bool isSet);
+void mtk_imgsys_mmqos_set_by_scen(struct mtk_imgsys_dev *imgsys_dev,
+				  struct swfrm_info_t *frm_info,
+				  bool isSet);
+void mtk_imgsys_mmqos_reset(struct mtk_imgsys_dev *imgsys_dev);
+void mtk_imgsys_mmdvfs_mmqos_cal(struct mtk_imgsys_dev *imgsys_dev,
+				struct swfrm_info_t *frm_info,
+				bool isSet);
+void mtk_imgsys_mmqos_bw_cal(struct mtk_imgsys_dev *imgsys_dev,
+				void *smi_port, uint32_t hw_comb,
+				uint32_t port_st, uint32_t port_num, uint32_t port_id);
+void mtk_imgsys_mmqos_ts_cal(struct mtk_imgsys_dev *imgsys_dev,
+				struct mtk_imgsys_cb_param *cb_param, uint32_t hw_comb);
+
+void mtk_imgsys_pwr(struct platform_device *pdev, bool on);
+#endif
+
+void mtk_imgsys_power_ctrl(struct mtk_imgsys_dev *imgsys_dev, bool isPowerOn);
+
+bool imgsys_cmdq_ts_enable(void);
+u32 imgsys_wpe_bwlog_enable(void);
+bool imgsys_cmdq_ts_dbg_enable(void);
+bool imgsys_dvfs_dbg_enable(void);
+
+#endif /* _MTK_IMGSYS_CMDQ_H_ */
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/imgsys/mtk_imgsys-dev.c b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/mtk_imgsys-dev.c
new file mode 100755
index 0000000000000000000000000000000000000000..f0f204f4c750ba09272343d580effe242b431b22
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/mtk_imgsys-dev.c
@@ -0,0 +1,1692 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2021 MediaTek Inc.
+ *
+ * Author: Frederic Chen <frederic.chen@mediatek.com>
+ *
+ */
+
+#include <linux/dma-buf.h>
+#include <linux/dma-direction.h>
+#include <linux/dma-mapping.h>
+#include <linux/platform_device.h>
+#include <linux/hashtable.h>
+#include <media/videobuf2-dma-contig.h>
+#include <media/v4l2-event.h>
+#include "mtk_imgsys-dev.h"
+#include "mtk-img-ipi.h"
+#include "mtk_header_desc.h"
+#include "mtk_imgsys-trace.h"
+
+struct fd_kva_list_t fd_kva_info_list = {
+	.mymutex = __MUTEX_INITIALIZER(fd_kva_info_list.mymutex),
+	.mylist = LIST_HEAD_INIT(fd_kva_info_list.mylist)
+};
+
+unsigned int nodes_num;
+
+int mtk_imgsys_pipe_init(struct mtk_imgsys_dev *imgsys_dev,
+				struct mtk_imgsys_pipe *pipe,
+				const struct mtk_imgsys_pipe_desc *setting)
+{
+	int ret;
+	u32 i;
+	size_t nodes_size;
+
+	pipe->imgsys_dev = imgsys_dev;
+	pipe->desc = setting;
+	pipe->nodes_enabled = 0ULL;
+	pipe->nodes_streaming = 0ULL;
+
+	atomic_set(&pipe->pipe_job_sequence, 0);
+	INIT_LIST_HEAD(&pipe->pipe_job_running_list);
+	INIT_LIST_HEAD(&pipe->pipe_job_pending_list);
+	INIT_LIST_HEAD(&pipe->iova_cache.list);
+	spin_lock_init(&pipe->iova_cache.lock);
+	hash_init(pipe->iova_cache.hlists);
+	//spin_lock_init(&pipe->job_lock);
+	//mutex_init(&pipe->job_lock);
+	spin_lock_init(&pipe->pending_job_lock);
+	spin_lock_init(&pipe->running_job_lock);
+	mutex_init(&pipe->lock);
+
+	nodes_num = pipe->desc->total_queues;
+	nodes_size = sizeof(*pipe->nodes) * nodes_num;
+	pipe->nodes = devm_kzalloc(imgsys_dev->dev, nodes_size, GFP_KERNEL);
+	if (!pipe->nodes)
+		return -ENOMEM;
+
+	for (i = 0; i < nodes_num; i++) {
+		pipe->nodes[i].desc = &pipe->desc->queue_descs[i];
+		pipe->nodes[i].flags = pipe->nodes[i].desc->flags;
+		spin_lock_init(&pipe->nodes[i].buf_list_lock);
+		INIT_LIST_HEAD(&pipe->nodes[i].buf_list);
+
+		pipe->nodes[i].crop.left = 0;
+		pipe->nodes[i].crop.top = 0;
+		pipe->nodes[i].crop.width =
+			pipe->nodes[i].desc->frmsizeenum->stepwise.max_width;
+		pipe->nodes[i].crop.height =
+			pipe->nodes[i].desc->frmsizeenum->stepwise.max_height;
+		pipe->nodes[i].compose.left = 0;
+		pipe->nodes[i].compose.top = 0;
+		pipe->nodes[i].compose.width =
+			pipe->nodes[i].desc->frmsizeenum->stepwise.max_width;
+		pipe->nodes[i].compose.height =
+			pipe->nodes[i].desc->frmsizeenum->stepwise.max_height;
+	}
+
+	ret = mtk_imgsys_pipe_v4l2_register(pipe, &imgsys_dev->mdev,
+					 &imgsys_dev->v4l2_dev);
+	if (ret) {
+		dev_info(pipe->imgsys_dev->dev,
+			"%s: failed(%d) to create V4L2 devices\n",
+			pipe->desc->name, ret);
+
+		goto err_destroy_pipe_lock;
+	}
+
+	return 0;
+
+err_destroy_pipe_lock:
+	mutex_destroy(&pipe->lock);
+
+	return ret;
+}
+
+int mtk_imgsys_pipe_release(struct mtk_imgsys_pipe *pipe)
+{
+	mtk_imgsys_pipe_v4l2_unregister(pipe);
+	mutex_destroy(&pipe->lock);
+
+	return 0;
+}
+
+int mtk_imgsys_pipe_next_job_id(struct mtk_imgsys_pipe *pipe)
+{
+	int global_job_id = atomic_inc_return(&pipe->pipe_job_sequence);
+
+	return (global_job_id & 0x0000FFFF) | (pipe->desc->id << 16);
+}
+
+#ifdef BATCH_MODE_V3
+int mtk_imgsys_pipe_next_job_id_batch_mode(struct mtk_imgsys_pipe *pipe,
+		unsigned short user_id)
+{
+	int global_job_id = atomic_inc_return(&pipe->pipe_job_sequence);
+
+	return (global_job_id & 0x0000FFFF) | (user_id << 16);
+}
+#endif
+
+struct mtk_imgsys_request *mtk_imgsys_pipe_get_running_job(
+						struct mtk_imgsys_pipe *pipe,
+						int id)
+{
+	struct mtk_imgsys_request *req;
+	unsigned long flag;
+
+	spin_lock_irqsave(&pipe->running_job_lock, flag);
+	list_for_each_entry(req,
+			    &pipe->pipe_job_running_list, list) {
+		if (req->id == id) {
+			spin_unlock_irqrestore(&pipe->running_job_lock, flag);
+			return req;
+		}
+	}
+	spin_unlock_irqrestore(&pipe->running_job_lock, flag);
+
+	return NULL;
+}
+
+void mtk_imgsys_pipe_remove_job(struct mtk_imgsys_request *req)
+{
+	unsigned long flag;
+	struct list_head *entry;
+#ifdef JOB_RUN
+	struct list_head *prev, *next;
+#endif
+
+	entry = &req->list;
+#ifdef JOB_RUN
+	prev = entry->prev;
+	next = entry->next;
+#endif
+
+	spin_lock_irqsave(&req->imgsys_pipe->running_job_lock, flag);
+#ifdef JOB_RUN
+	if ((req->list.next == LIST_POISON1) ||
+					(req->list.prev == LIST_POISON2)) {
+		dev_info(req->imgsys_pipe->imgsys_dev->dev, "%s: req-fd %d already deleted, prev(0x%lx), next(0x%lx, entry(0x%lx))",
+			__func__, req->tstate.req_fd, req->list.prev, req->list.next, entry);
+		spin_unlock_irqrestore(&req->imgsys_pipe->running_job_lock, flag);
+		return;
+	}
+
+	if ((prev->next != entry) || (next->prev != entry)) {
+		dev_info(req->imgsys_pipe->imgsys_dev->dev, "%s: req-fd %d not in list, prev->next(0x%lx), next->prev(0x%lx), entry(0x%lx)",
+			__func__, req->tstate.req_fd, prev->next, next->prev, entry);
+		spin_unlock_irqrestore(&req->imgsys_pipe->running_job_lock, flag);
+		return;
+	}
+
+	list_del(&req->list);
+#endif
+	req->imgsys_pipe->num_jobs--;
+	spin_unlock_irqrestore(&req->imgsys_pipe->running_job_lock, flag);
+
+	dev_dbg(req->imgsys_pipe->imgsys_dev->dev,
+		"%s:%s:req->id(%d),num of running jobs(%d) entry(%p)\n", __func__,
+		req->imgsys_pipe->desc->name, req->id,
+		req->imgsys_pipe->num_jobs, entry);
+}
+
+void mtk_imgsys_pipe_debug_job(struct mtk_imgsys_pipe *pipe,
+			    struct mtk_imgsys_request *req)
+{
+	int i;
+
+	dev_dbg(pipe->imgsys_dev->dev, "%s:%s: pipe-job(%p),id(%d)\n",
+		__func__, pipe->desc->name, req, req->id);
+
+	for (i = 0; i < pipe->desc->total_queues ; i++) {
+		if (req->buf_map[i])
+			dev_dbg(pipe->imgsys_dev->dev, "%s:%s:buf(%p)\n",
+				pipe->desc->name, pipe->nodes[i].desc->name,
+				req->buf_map[i]);
+	}
+}
+
+#ifdef BATCH_MODE_V3
+bool is_batch_mode(struct mtk_imgsys_request *req)
+{
+	return req->is_batch_mode;
+}
+
+void mtk_imgsys_frame_done(struct mtk_imgsys_request *req)
+{
+	bool found = false;
+	const int user_id = mtk_imgsys_pipe_get_pipe_from_job_id(req->id);
+	struct mtk_imgsys_user *user;
+	struct mtk_imgsys_dev *imgsys_dev = req->imgsys_pipe->imgsys_dev;
+	unsigned long flags;
+
+	mutex_lock(&imgsys_dev->imgsys_users.user_lock);
+	list_for_each_entry(user, &imgsys_dev->imgsys_users.list, entry) {
+		if (user == NULL)
+			continue;
+
+		if (user->id == user_id) {
+			found = true;
+			break;
+		}
+	}
+	mutex_unlock(&imgsys_dev->imgsys_users.user_lock);
+
+	// add into user's done_list and wake it up
+	if (found) {
+		spin_lock_irqsave(&user->lock, flags);
+
+		list_add_tail(&req->done_pack->done_entry, &user->done_list);
+
+		user->dqdonestate = true;
+
+
+		pr_info("%s: user id(%x) req(%p) add done_pack\n", __func__,
+			user->id, req);
+
+		wake_up(&user->done_wq);
+		wake_up(&user->enque_wq);
+		spin_unlock_irqrestore(&user->lock, flags);
+
+		if (!IS_ERR(req)) {
+			pr_info("%s free req(%p)\n", __func__, req);
+			vfree(req);
+		}
+	}
+}
+#endif
+
+void mtk_imgsys_pipe_job_finish(struct mtk_imgsys_request *req,
+			     enum vb2_buffer_state vbf_state)
+{
+	struct mtk_imgsys_pipe *pipe = req->imgsys_pipe;
+	struct mtk_imgsys_dev_buffer *in_buf;
+	int i;
+	int req_id = req->id;
+	unsigned int vb2_buffer_index;
+
+#ifdef BATCH_MODE_V3
+	// batch mode
+	if (is_batch_mode(req)) {
+		mtk_imgsys_frame_done(req);
+		return;
+	}
+#endif
+	if (req->req.state != MEDIA_REQUEST_STATE_QUEUED) {
+		dev_info(pipe->imgsys_dev->dev, "%s: req %d 0x%lx flushed in state(%d)", __func__,
+					req->tstate.req_fd, (unsigned long)&req->req, req->req.state);
+		goto done;
+	}
+
+	i = is_singledev_mode(req);
+	if (!i)
+		i = MTK_IMGSYS_VIDEO_NODE_CTRLMETA_OUT;
+
+	in_buf = req->buf_map[i];
+
+	for (i = 0; i < pipe->desc->total_queues; i++) {
+		struct mtk_imgsys_dev_buffer *dev_buf = req->buf_map[i];
+		struct mtk_imgsys_video_device *node;
+
+		if (!dev_buf)
+			continue;
+
+		if (dev_buf != in_buf)
+			dev_buf->vbb.vb2_buf.timestamp =
+				in_buf->vbb.vb2_buf.timestamp;
+
+		vb2_buffer_index = dev_buf->vbb.vb2_buf.index;
+		node = mtk_imgsys_vbq_to_node(dev_buf->vbb.vb2_buf.vb2_queue);
+
+		spin_lock(&node->buf_list_lock);
+		list_del(&dev_buf->list);
+		spin_unlock(&node->buf_list_lock);
+
+
+		/*  vb2_buf is changed after below function  */
+		vb2_buffer_done(&dev_buf->vbb.vb2_buf, vbf_state);
+
+		dev_dbg(pipe->imgsys_dev->dev,
+			"%s:%s:%s: return buf, idx(%d), state(%d)\n",
+			__func__, pipe->desc->name, node->desc->name,
+			vb2_buffer_index, vbf_state);
+	}
+done:
+	req->tstate.time_notify2vb2done = ktime_get_boottime_ns()/1000;
+	complete(&req->done);
+		dev_dbg(pipe->imgsys_dev->dev,
+			"[KT]%s:%d:%6lld,%6lld,%6lld,%6lld,%6lld,%6lld,%6lld,%6lld,%6lld,%6lld,%6lld,%6lld,%6lld,%6lld\n",
+			__func__, req->tstate.req_fd,
+			//req->tstate.time_hwenq,
+			req->tstate.time_composingStart,
+			req->tstate.time_composingEnd,
+			req->tstate.time_qw2composer,
+			req->tstate.time_compfuncStart,
+			req->tstate.time_ipisendStart,
+			req->tstate.time_reddonescpStart,
+			req->tstate.time_doframeinfo,
+			req->tstate.time_qw2runner,
+			req->tstate.time_runnerStart,
+			req->tstate.time_send2cmq,
+			req->tstate.time_mdpcbStart,
+			req->tstate.time_notifyStart,
+			req->tstate.time_unmapiovaEnd,
+			req->tstate.time_notify2vb2done);
+
+	dev_dbg(pipe->imgsys_dev->dev,
+		"%s:%s: finished job id(%d), vbf_state(%d)\n",
+		__func__, pipe->desc->name, req_id, vbf_state);
+}
+
+static u32 dip_pass1_fmt_get_stride(struct v4l2_pix_format_mplane *mfmt,
+				    const struct mtk_imgsys_dev_format *fmt,
+				    unsigned int plane)
+{
+	unsigned int width = ALIGN(mfmt->width, 4);
+	unsigned int pixel_bits = fmt->row_depth[0];
+	unsigned int bpl, ppl;
+
+	ppl = DIV_ROUND_UP(width * fmt->depth[0], fmt->row_depth[0]);
+	bpl = DIV_ROUND_UP(ppl * pixel_bits, 8);
+
+	return ALIGN(bpl, fmt->pass_1_align);
+}
+
+/* Stride that is accepted by MDP HW */
+static u32 dip_mdp_fmt_get_stride(struct v4l2_pix_format_mplane *mfmt,
+				  const struct mtk_imgsys_dev_format *fmt,
+				  unsigned int plane)
+#ifdef MDP_COLOR
+{
+	enum mdp_color c = fmt->mdp_color;
+	u32 bytesperline = (mfmt->width * fmt->row_depth[plane]) / 8;
+	u32 stride = (bytesperline * DIP_MCOLOR_BITS_PER_PIXEL(c))
+		/ fmt->row_depth[0];
+
+	if (plane == 0)
+		return stride;
+
+	if (plane < DIP_MCOLOR_GET_PLANE_COUNT(c)) {
+		if (DIP_MCOLOR_IS_BLOCK_MODE(c))
+			stride = stride / 2;
+		return stride;
+	}
+
+	return 0;
+}
+#else
+{
+	return 0;
+}
+#endif
+
+static int mtk_imgsys_pipe_get_stride(struct mtk_imgsys_pipe *pipe,
+				   struct v4l2_pix_format_mplane *mfmt,
+				   const struct mtk_imgsys_dev_format *dfmt,
+				   int plane, char *buf_name)
+{
+	int bpl;
+
+	if (dfmt->pass_1_align)
+		bpl = dip_pass1_fmt_get_stride(mfmt, dfmt, plane);
+	else
+		bpl = dip_mdp_fmt_get_stride(mfmt, dfmt, plane);
+
+	dev_dbg(pipe->imgsys_dev->dev,
+		"%s:%s:%s: plane(%d), pixelformat(%x) width(%d), stride(%d)",
+		__func__, pipe->desc->name, buf_name, plane, mfmt->pixelformat,
+		mfmt->width, bpl);
+
+	return bpl;
+}
+
+void mtk_imgsys_pipe_try_fmt(struct mtk_imgsys_pipe *pipe,
+			  struct mtk_imgsys_video_device *node,
+			  struct v4l2_format *fmt,
+			  const struct v4l2_format *ufmt,
+			  const struct mtk_imgsys_dev_format *dfmt)
+{
+	int i;
+
+	fmt->type = ufmt->type;
+	fmt->fmt.pix_mp.width =
+		clamp_val(ufmt->fmt.pix_mp.width,
+			  node->desc->frmsizeenum->stepwise.min_width,
+			  node->desc->frmsizeenum->stepwise.max_width);
+	fmt->fmt.pix_mp.height =
+		clamp_val(ufmt->fmt.pix_mp.height,
+			  node->desc->frmsizeenum->stepwise.min_height,
+			  node->desc->frmsizeenum->stepwise.max_height);
+	fmt->fmt.pix_mp.num_planes = ufmt->fmt.pix_mp.num_planes;
+	fmt->fmt.pix_mp.quantization = ufmt->fmt.pix_mp.quantization;
+	fmt->fmt.pix_mp.colorspace = ufmt->fmt.pix_mp.colorspace;
+	fmt->fmt.pix_mp.field = V4L2_FIELD_NONE;
+
+	/* Only MDP 0 and MDP 1 allow the color space change */
+#ifdef MDP_PORT
+	if (node->desc->id != MTK_IMGSYS_VIDEO_NODE_ID_WROT_A_CAPTURE &&
+	    node->desc->id != MTK_IMGSYS_VIDEO_NODE_ID_WROT_B_CAPTURE) {
+		fmt->fmt.pix_mp.quantization = V4L2_QUANTIZATION_FULL_RANGE;
+		fmt->fmt.pix_mp.colorspace = V4L2_COLORSPACE_DEFAULT;
+	}
+#endif
+	fmt->fmt.pix_mp.pixelformat = dfmt->format;
+	fmt->fmt.pix_mp.num_planes = dfmt->num_planes;
+	fmt->fmt.pix_mp.ycbcr_enc = V4L2_YCBCR_ENC_DEFAULT;
+	fmt->fmt.pix_mp.field = V4L2_FIELD_NONE;
+
+	for (i = 0; i < fmt->fmt.pix_mp.num_planes; ++i) {
+		unsigned int stride;
+		unsigned int sizeimage;
+
+		if (is_desc_fmt(dfmt)) {
+			fmt->fmt.pix_mp.plane_fmt[i].sizeimage =
+							dfmt->buffer_size;
+		} else {
+			stride = mtk_imgsys_pipe_get_stride(pipe,
+							&fmt->fmt.pix_mp, dfmt,
+							i, node->desc->name);
+			if (dfmt->pass_1_align)
+				sizeimage = stride * fmt->fmt.pix_mp.height;
+			else
+				sizeimage = DIV_ROUND_UP(stride *
+							 fmt->fmt.pix_mp.height
+							 * dfmt->depth[i],
+							 dfmt->row_depth[i]);
+
+			fmt->fmt.pix_mp.plane_fmt[i].sizeimage = sizeimage;
+			fmt->fmt.pix_mp.plane_fmt[i].bytesperline = stride;
+		}
+	}
+
+}
+
+static void set_meta_fmt(struct mtk_imgsys_pipe *pipe,
+			 struct v4l2_meta_format *fmt,
+			 const struct mtk_imgsys_dev_format *dev_fmt)
+{
+	fmt->dataformat = dev_fmt->format;
+
+	if (dev_fmt->buffer_size <= 0) {
+		dev_dbg(pipe->imgsys_dev->dev,
+			"%s: Invalid meta buf size(%u), use default(%u)\n",
+			pipe->desc->name, dev_fmt->buffer_size,
+			MTK_DIP_DEV_META_BUF_DEFAULT_SIZE);
+
+		fmt->buffersize =
+			MTK_DIP_DEV_META_BUF_DEFAULT_SIZE;
+	} else {
+		fmt->buffersize = dev_fmt->buffer_size;
+	}
+}
+
+void mtk_imgsys_pipe_load_default_fmt(struct mtk_imgsys_pipe *pipe,
+				   struct mtk_imgsys_video_device *node,
+				   struct v4l2_format *fmt)
+{
+	int idx = node->desc->default_fmt_idx;
+
+	if (idx >= node->desc->num_fmts) {
+		dev_info(pipe->imgsys_dev->dev,
+			"%s:%s: invalid idx(%d), must < num_fmts(%d)\n",
+			__func__, node->desc->name, idx, node->desc->num_fmts);
+
+		idx = 0;
+	}
+
+	fmt->type = node->desc->buf_type;
+	if (mtk_imgsys_buf_is_meta(node->desc->buf_type)) {
+		set_meta_fmt(pipe, &fmt->fmt.meta,
+			     &node->desc->fmts[idx]);
+	} else {
+		fmt->fmt.pix_mp.width = node->desc->default_width;
+		fmt->fmt.pix_mp.height = node->desc->default_height;
+		mtk_imgsys_pipe_try_fmt(pipe, node, fmt, fmt,
+				     &node->desc->fmts[idx]);
+	}
+}
+
+const struct mtk_imgsys_dev_format*
+mtk_imgsys_pipe_find_fmt(struct mtk_imgsys_pipe *pipe,
+		      struct mtk_imgsys_video_device *node,
+		      u32 format)
+{
+	int i;
+
+	for (i = 0; i < node->desc->num_fmts; i++) {
+		if (node->desc->fmts[i].format == format)
+			return &node->desc->fmts[i];
+	}
+
+	return NULL;
+}
+
+bool is_desc_mode(struct mtk_imgsys_request *req)
+{
+	struct mtk_imgsys_dev_buffer *dev_buf = NULL;
+	bool mode = false;
+
+	dev_buf = req->buf_map[MTK_IMGSYS_VIDEO_NODE_CTRLMETA_OUT];
+	if (dev_buf)
+		mode = (dev_buf->dev_fmt->format == V4L2_META_FMT_MTISP_DESC) ? 1 : 0;
+
+	return mode;
+}
+
+int is_singledev_mode(struct mtk_imgsys_request *req)
+{
+	int ret = 0;
+
+	if (req->buf_map[MTK_IMGSYS_VIDEO_NODE_SIGDEV_OUT])
+		ret = MTK_IMGSYS_VIDEO_NODE_SIGDEV_OUT;
+	else if (req->buf_map[MTK_IMGSYS_VIDEO_NODE_SIGDEV_NORM_OUT])
+		ret = MTK_IMGSYS_VIDEO_NODE_SIGDEV_NORM_OUT;
+
+	return ret;
+}
+
+bool is_desc_fmt(const struct mtk_imgsys_dev_format *dev_fmt)
+{
+
+	bool std_fmt;
+
+	switch (dev_fmt->format) {
+	case V4L2_META_FMT_MTISP_DESC:
+	case V4L2_META_FMT_MTISP_SD:
+	case V4L2_META_FMT_MTISP_DESC_NORM:
+	case V4L2_META_FMT_MTISP_SDNORM:
+		std_fmt = false;
+		break;
+	default:
+		std_fmt = true;
+		break;
+	}
+
+	return !std_fmt;
+}
+static u64 mtk_imgsys_get_iova(struct dma_buf *dma_buf, s32 ionFd,
+				struct mtk_imgsys_dev *imgsys_dev,
+				struct mtk_imgsys_dev_buffer *dev_buf)
+{
+	dma_addr_t dma_addr;
+	struct device *dev;
+	struct dma_buf_attachment *attach;
+	struct sg_table *sgt;
+	struct mtk_imgsys_pipe *pipe = &imgsys_dev->imgsys_pipe[0];
+	struct mtk_imgsys_dma_buf_iova_get_info *iova_info;
+	bool cache = false;
+
+	spin_lock(&pipe->iova_cache.lock);
+#ifdef LINEAR_CACHE
+	list_for_each_entry(iova_info, &pipe->iova_cache.list, list_entry) {
+#else
+	hash_for_each_possible(pipe->iova_cache.hlists, iova_info, hnode, ionFd) {
+#endif
+		if ((ionFd == iova_info->ionfd) &&
+				(dma_buf == iova_info->dma_buf)) {
+			cache = true;
+			dma_addr = iova_info->dma_addr;
+			dma_buf_put(dma_buf);
+			break;
+		}
+	}
+	spin_unlock(&pipe->iova_cache.lock);
+
+	if (cache) {
+		dev_dbg(imgsys_dev->dev, "%s fd:%d cache hit\n", __func__, ionFd);
+		return dma_addr;
+	}
+
+	if (IS_ERR(dma_buf)) {
+		dev_dbg(imgsys_dev->dev, "%s: dma_buf %p",
+							__func__, dma_buf);
+		return 0;
+	}
+
+	dev = imgsys_dev->dev;
+
+	attach = dma_buf_attach(dma_buf, dev);
+
+	if (IS_ERR(attach))
+		goto err_attach;
+
+	sgt = dma_buf_map_attachment(attach, DMA_BIDIRECTIONAL);
+
+	if (IS_ERR(sgt))
+		goto err_map;
+
+	dma_addr = sg_dma_address(sgt->sgl);
+
+	dev_dbg(imgsys_dev->dev,
+		"%s - sg_dma_address : ionFd(%d)-dma_addr:%llx\n",
+		__func__, ionFd, dma_addr);
+
+	//add dma_buf_info_list to req for GCECB put it back
+	//add dmainfo to ionmaplist
+	{
+		struct mtk_imgsys_dma_buf_iova_get_info *ion;
+
+		ion = vzalloc(sizeof(*ion));
+		ion->ionfd = ionFd;
+		ion->dma_addr = dma_addr;
+		ion->dma_buf = dma_buf;
+		ion->attach = attach;
+		ion->sgt = sgt;
+		pr_debug("mtk_imgsys_dma_buf_iova_get_info:dma_buf:%p,attach:%p,sgt:%p\n",
+				ion->dma_buf, ion->attach, ion->sgt);
+
+		// add data to list head
+		spin_lock(&dev_buf->iova_map_table.lock);
+		list_add_tail(&ion->list_entry, &dev_buf->iova_map_table.list);
+		spin_unlock(&dev_buf->iova_map_table.lock);
+	}
+
+	return dma_addr;
+
+err_map:
+	pr_info("err_map");
+	dma_buf_detach(dma_buf, attach);
+
+err_attach:
+	pr_info("err_attach");
+	dma_buf_put(dma_buf);
+
+	return 0;
+}
+
+void mtk_imgsys_put_dma_buf(struct dma_buf *dma_buf,
+				struct dma_buf_attachment *attach,
+				struct sg_table *sgt)
+{
+	if (!IS_ERR(dma_buf)) {
+		dma_buf_unmap_attachment(attach, sgt,
+			DMA_BIDIRECTIONAL);
+		dma_buf_detach(dma_buf, attach);
+		dma_buf_put(dma_buf);
+	}
+}
+
+static void *get_kva(struct mtk_imgsys_dev_buffer *buf)
+{
+	struct dma_buf *dmabuf;
+	void *vaddr;
+	// struct header_desc *desc;
+	struct iosys_map map;
+	int ret;
+
+	int fd = buf->vbb.vb2_buf.planes[0].m.fd;
+
+	if (!fd) {
+		pr_info("%s: vb2buffer fd is 0!!!", __func__);
+		return NULL;
+	}
+	dmabuf = dma_buf_get(buf->vbb.vb2_buf.planes[0].m.fd);
+	if (IS_ERR(dmabuf)) {
+		pr_info("dmabuf %p", dmabuf);
+		goto ERROR_PUT;
+	}
+
+	dma_buf_begin_cpu_access(dmabuf, DMA_BIDIRECTIONAL);
+	ret = dma_buf_vmap(dmabuf, &map);
+	vaddr = map.vaddr;
+	// desc = (struct header_desc *)vaddr;
+
+	if (ret)
+		goto ERROR;
+
+	//Keep dmabuf used in latter for put kva
+	buf->dma_buf_putkva = dmabuf;
+
+
+	return vaddr;
+
+ERROR:
+	dma_buf_end_cpu_access(dmabuf, DMA_BIDIRECTIONAL);
+	pr_info("%s:8", __func__);
+	dma_buf_put(dmabuf);
+	pr_info("%s:9", __func__);
+ERROR_PUT:
+	return NULL;
+}
+
+static void put_kva(struct buf_va_info_t *buf_va_info)
+{
+	struct dma_buf *dmabuf;
+	struct iosys_map map = IOSYS_MAP_INIT_VADDR((void *)buf_va_info->kva);
+
+	dmabuf = buf_va_info->dma_buf_putkva;
+	if (!IS_ERR(dmabuf)) {
+		dma_buf_vunmap(dmabuf, &map);
+		dma_buf_end_cpu_access(dmabuf, DMA_BIDIRECTIONAL);
+		dma_buf_unmap_attachment(buf_va_info->attach, buf_va_info->sgt,
+			DMA_BIDIRECTIONAL);
+		dma_buf_detach(dmabuf, buf_va_info->attach);
+		dma_buf_put(dmabuf);
+	}
+}
+
+void flush_fd_kva_list(struct mtk_imgsys_dev *imgsys_dev)
+{
+	struct buf_va_info_t *buf_va_info = NULL;
+
+	dev_dbg(imgsys_dev->dev, "%s+\n", __func__);
+	mutex_lock(&(fd_kva_info_list.mymutex));
+	while (!list_empty(&fd_kva_info_list.mylist)) {
+		buf_va_info = vlist_node_of(fd_kva_info_list.mylist.next,
+			struct buf_va_info_t);
+		list_del_init(vlist_link(buf_va_info, struct buf_va_info_t));
+		dev_info(imgsys_dev->dev, "%s delete fd(%d) kva(0x%lx), dma_buf_putkva(%p)\n",
+				__func__, buf_va_info->buf_fd, buf_va_info->kva,
+				buf_va_info->dma_buf_putkva);
+		put_kva(buf_va_info);
+		vfree(buf_va_info);
+		buf_va_info = NULL;
+	}
+	mutex_unlock(&(fd_kva_info_list.mymutex));
+
+	dev_dbg(imgsys_dev->dev, "%s -\n", __func__);
+}
+
+struct fd_kva_list_t *get_fd_kva_list(void)
+{
+	return &fd_kva_info_list;
+}
+
+struct buf_va_info_t *get_first_sd_buf(void)
+{
+	struct buf_va_info_t_list *buf_entry;
+
+	if (list_empty(&fd_kva_info_list.mylist)) {
+		pr_info("%s no buffer found\n", __func__);
+
+		return NULL;
+	}
+
+	buf_entry = list_first_entry(&fd_kva_info_list.mylist,
+				struct buf_va_info_t_list, link);
+
+	return &buf_entry->node;
+}
+
+static void mtk_imgsys_desc_fill_dmabuf(struct mtk_imgsys_pipe *pipe,
+				struct frameparams *fparams,
+				bool isMENode)
+{
+	struct device *dev = pipe->imgsys_dev->dev;
+	unsigned int i = 0, j = 0;
+	struct dma_buf *dbuf;
+	struct v4l2_ext_plane *plane;
+
+	for (i = 0; i < FRAME_BUF_MAX; i++) {
+		for (j = 0; j < IMGBUF_MAX_PLANES; j++) {
+			plane = &fparams->bufs[i].buf.planes[j];
+			if (plane->m.dma_buf.fd == 0)
+				continue;
+			/* get dma_buf first */
+			dbuf = dma_buf_get(plane->m.dma_buf.fd);
+			if (IS_ERR(dbuf)) {
+				plane->reserved[0] = 0;
+				plane->reserved[1] = 0;
+				pr_info("%s: dma_buf:%p fd:%d", __func__, dbuf,
+									plane->m.dma_buf.fd);
+				continue;
+			}
+
+			plane->reserved[0] = (u64)dbuf;
+			plane->reserved[1] = (u64)dbuf->size;
+			if (isMENode)
+				dma_buf_put(dbuf);
+			dev_dbg(dev,
+				"%s - bufs[%d].buf.planes[%d]: fd(%d), dmabuf(%llx)\n",
+				__func__, i, j,
+			plane->m.dma_buf.fd,
+			plane->reserved[0]);
+		}
+	}
+}
+
+static void mtk_imgsys_kva_cache(struct mtk_imgsys_dev_buffer *dev_buf)
+{
+	struct list_head *ptr = NULL;
+	bool find = false;
+	struct buf_va_info_t *buf_va_info;
+	struct dma_buf *dbuf;
+
+	mutex_lock(&(fd_kva_info_list.mymutex));
+	list_for_each(ptr, &(fd_kva_info_list.mylist)) {
+		buf_va_info = vlist_node_of(ptr, struct buf_va_info_t);
+		if (buf_va_info->buf_fd == dev_buf->vbb.vb2_buf.planes[0].m.fd) {
+			find = true;
+			break;
+		}
+	}
+	if (find) {
+		dbuf = (struct dma_buf *)buf_va_info->dma_buf_putkva;
+		if (dbuf->size <= dev_buf->dataofst) {
+			mutex_unlock(&(fd_kva_info_list.mymutex));
+			pr_info("%s : dmabuf size (0x%zx) < offset(0x%x)\n",
+				__func__, dbuf->size, dev_buf->dataofst);
+			return;
+		}
+
+		dev_buf->va_daddr[0] = buf_va_info->kva + dev_buf->dataofst;
+		mutex_unlock(&(fd_kva_info_list.mymutex));
+		pr_debug(
+			"%s : fd(%d), find kva(0x%lx), offset(0x%x) -> (0x%llx)\n",
+				__func__, dev_buf->vbb.vb2_buf.planes[0].m.fd,
+				buf_va_info->kva, dev_buf->dataofst,
+				dev_buf->va_daddr[0]);
+	} else {
+		mutex_unlock(&(fd_kva_info_list.mymutex));
+		dev_buf->va_daddr[0] = (u64)get_kva(dev_buf);
+		dbuf = dev_buf->dma_buf_putkva;
+		if (dbuf->size <= dev_buf->dataofst && dev_buf->va_daddr[0] != 0) {
+			dma_buf_vunmap(dbuf, (void *)dev_buf->va_daddr[0]);
+			dma_buf_end_cpu_access(dbuf, DMA_BIDIRECTIONAL);
+			dma_buf_put(dbuf);
+			dev_buf->va_daddr[0] = 0;
+			pr_info("%s : dmabuf size (0x%zx) < offset(0x%x)\n",
+				__func__, dbuf->size, dev_buf->dataofst);
+			return;
+		}
+
+		buf_va_info = (struct buf_va_info_t *)
+			vzalloc(sizeof(vlist_type(struct buf_va_info_t)));
+		INIT_LIST_HEAD(vlist_link(buf_va_info, struct buf_va_info_t));
+		if (buf_va_info == NULL) {
+			pr_info("%s: null buf_va_info\n", __func__);
+			return;
+		}
+		buf_va_info->buf_fd = dev_buf->vbb.vb2_buf.planes[0].m.fd;
+		buf_va_info->kva = dev_buf->va_daddr[0];
+		buf_va_info->dma_buf_putkva = (void *)dev_buf->dma_buf_putkva;
+
+		mutex_lock(&(fd_kva_info_list.mymutex));
+		list_add_tail(vlist_link(buf_va_info, struct buf_va_info_t),
+		   &fd_kva_info_list.mylist);
+		mutex_unlock(&(fd_kva_info_list.mymutex));
+		pr_info(
+			"%s : fd(%d), base kva(0x%llx), offset(0x%x), dma_buf_putkva(%p)\n",
+				__func__, dev_buf->vbb.vb2_buf.planes[0].m.fd,
+				dev_buf->va_daddr[0],
+				dev_buf->dataofst, dev_buf->dma_buf_putkva);
+
+		dev_buf->va_daddr[0] += dev_buf->dataofst;
+	}
+}
+
+static void mtk_imgsys_desc_iova(struct mtk_imgsys_pipe *pipe,
+				struct frameparams *fparams,
+				struct mtk_imgsys_dev_buffer *dev_buf)
+{
+	struct device *dev = pipe->imgsys_dev->dev;
+	unsigned int i = 0, j = 0;
+	struct dma_buf *dmabuf;
+
+	IMGSYS_SYSTRACE_BEGIN("%s\n", __func__);
+
+	for (i = 0; i < FRAME_BUF_MAX; i++) {
+		for (j = 0; j < IMGBUF_MAX_PLANES; j++) {
+			if (fparams->bufs[i].buf.planes[j].m.dma_buf.fd == 0)
+				continue;
+
+			dmabuf = (struct dma_buf *)fparams->bufs[i].buf.planes[j].reserved[0];
+			if (IS_ERR_OR_NULL(dmabuf)) {
+				pr_debug("%s bad dmabuf(%p)", __func__,
+									dmabuf);
+				continue;
+			}
+			fparams->bufs[i].buf.planes[j].reserved[0] =
+			mtk_imgsys_get_iova(dmabuf,
+			fparams->bufs[i].buf.planes[j].m.dma_buf.fd,
+					pipe->imgsys_dev, dev_buf);
+			dev_dbg(dev,
+				"%s - bufs[%d].buf.planes[%d]: fd(%d), iova(%llx)\n",
+				__func__, i, j,
+			fparams->bufs[i].buf.planes[j].m.dma_buf.fd,
+				fparams->bufs[i].buf.planes[j].reserved[0]);
+		}
+	}
+
+	IMGSYS_SYSTRACE_END();
+
+}
+
+static void mtk_imgsys_desc_fill_ipi_param(struct mtk_imgsys_pipe *pipe,
+					struct mtk_imgsys_dev_buffer *dev_buf,
+					struct mtk_imgsys_request *req,
+					bool isMENode)
+{
+	struct device *dev = pipe->imgsys_dev->dev;
+	struct header_desc *desc_dma = NULL;
+	struct header_desc_norm *desc_norm = NULL;
+	unsigned int i = 0, j = 0, tnum, tmax;
+
+	if (dev_buf->vbb.vb2_buf.memory == VB2_MEMORY_DMABUF) {
+		if (!req->buf_same) {
+			dev_dbg(dev,
+			"%s : fd(%d)\n",
+				__func__, dev_buf->vbb.vb2_buf.planes[0].m.fd);
+
+			mtk_imgsys_kva_cache(dev_buf);
+		} else
+			dev_buf->va_daddr[0] = req->buf_va_daddr +
+			dev_buf->dataofst;
+	}
+	/* TODO:  MMAP imgbuffer path vaddr = 0 */
+
+	dev_dbg(dev,
+		"%s : scp_daddr(0x%llx),isp_daddr(0x%llx),va_daddr(0x%llx)\n",
+		__func__,
+		dev_buf->scp_daddr[0],
+		dev_buf->isp_daddr[0],
+		dev_buf->va_daddr[0]);
+
+	/*getKVA*/
+	if (!dev_buf->va_daddr[0]) {
+		pr_info("%s fail!! desc_dma is NULL !", __func__);
+		return;
+	}
+	//init map table list for each devbuf
+	INIT_LIST_HEAD(&dev_buf->iova_map_table.list);
+	spin_lock_init(&dev_buf->iova_map_table.lock);
+
+	switch (dev_buf->dev_fmt->format) {
+	/* For SMVR */
+	default:
+	case V4L2_META_FMT_MTISP_DESC:
+		desc_dma = (struct header_desc *)dev_buf->va_daddr[0];
+		tnum = desc_dma->fparams_tnum;
+		tmax = TIME_MAX;
+		break;
+	/* For Normal */
+	case V4L2_META_FMT_MTISP_DESC_NORM:
+		desc_norm = (struct header_desc_norm *)dev_buf->va_daddr[0];
+		tnum = desc_norm->fparams_tnum;
+		tmax = TMAX;
+		break;
+	}
+
+	/*fd2iova : need 2D array parsing*/
+	if (tnum >= tmax) {
+		tnum = tmax;
+		pr_debug("%s: %d bufinfo enqueued exceeds %d\n", __func__,
+			tnum, tmax);
+	}
+
+	if (desc_norm) {
+		for (i = 0; i < tnum ; i++) {
+			for (j = 0; j < SCALE_MAX; j++)
+				mtk_imgsys_desc_fill_dmabuf(pipe,
+					&desc_norm->fparams[i][j], isMENode);
+		}
+	} else {
+		for (i = 0; i < tnum ; i++) {
+			for (j = 0; j < SCALE_MAX; j++)
+				mtk_imgsys_desc_fill_dmabuf(pipe,
+					&desc_dma->fparams[i][j], isMENode);
+		}
+	}
+
+	/* do put_kva once while last user at streamoff */
+	/*if (!req->buf_same)*/
+	/*	put_kva(dev_buf->dma_buf_putkva, (void *)dev_buf->va_daddr[0]);*/
+
+}
+
+void mtk_imgsys_desc_ipi_params_config(struct mtk_imgsys_request *req)
+{
+	struct mtk_imgsys_pipe *pipe = req->imgsys_pipe;
+	struct device *dev = pipe->imgsys_dev->dev;
+	struct mtk_imgsys_dev_buffer *buf_dma;
+	int i = 0;
+	bool isMENode = false;
+	dev_dbg(dev, "%s:%s: pipe-job id(%d)\n", __func__,
+		pipe->desc->name, req->id);
+
+	for (i = 0; i < pipe->desc->total_queues; i++) {
+		buf_dma = req->buf_map[i];
+
+		if (i == MTK_IMGSYS_VIDEO_NODE_TUNING_OUT) {
+			if (!buf_dma) {
+				dev_dbg(dev, "No enqueued tuning buffer\n");
+				continue;
+			}
+
+		} else if (i == MTK_IMGSYS_VIDEO_NODE_CTRLMETA_OUT)
+			isMENode = true;
+
+		if (buf_dma) {
+
+			req->buf_same =
+				(req->buf_fd == buf_dma->vbb.vb2_buf.planes[0].m.fd)?true:false;
+
+			mtk_imgsys_desc_fill_ipi_param(pipe,
+				buf_dma,
+				req, isMENode);
+		}
+	}
+
+	/* do put_kva once while last user at streamoff */
+	/*if (buf_ctrlmeta) {*/
+	/*	if (buf_ctrlmeta->vbb.vb2_buf.memory == VB2_MEMORY_DMABUF)*/
+	/*		put_kva(buf_ctrlmeta->dma_buf_putkva,*/
+	/*					(void *)buf_ctrlmeta->va_daddr[0]);*/
+	/*}*/
+}
+
+static void mtk_imgsys_desc_set(struct mtk_imgsys_pipe *pipe,
+				void *src,
+				struct header_desc *dst,
+				bool iova_need,
+				struct mtk_imgsys_dev_buffer *dev_buf)
+{
+
+	unsigned int tmax, tnum, t, j;
+	struct header_desc *input_smvr = NULL;
+	struct header_desc_norm *input_norm = NULL;
+
+	switch (dev_buf->dev_fmt->format) {
+	case V4L2_META_FMT_MTISP_SD:
+	case V4L2_META_FMT_MTISP_DESC:
+		input_smvr = (struct header_desc *)src;
+		tmax = TIME_MAX;
+		tnum = input_smvr->fparams_tnum;
+		break;
+	case V4L2_META_FMT_MTISP_SDNORM:
+	case V4L2_META_FMT_MTISP_DESC_NORM:
+	default:
+		input_norm = (struct header_desc_norm *)src;
+		tmax = TMAX;
+		tnum = input_norm->fparams_tnum;
+		break;
+	}
+	/*fd2iova : need 2D array parsing*/
+	if (tnum >= tmax) {
+		tnum = tmax;
+		pr_debug("%s: %d bufinfo enqueued exceeds %d\n", __func__,
+			tnum, tmax);
+	}
+
+	if (input_smvr) {
+		for (t = 0; t < tnum; t++) {
+			for (j = 0; j < SCALE_MAX; j++) {
+				if (iova_need)
+					mtk_imgsys_desc_iova(pipe,
+					&input_smvr->fparams[t][j], dev_buf);
+				/* TODO: disable memcpy for imgstream fd */
+				if (!dst)
+					continue;
+				memcpy(&dst->fparams[t][j],
+						&input_smvr->fparams[t][j],
+						sizeof(struct frameparams));
+			}
+		}
+		if (dst)
+			dst->fparams_tnum = input_smvr->fparams_tnum;
+	} else {
+		for (t = 0; t < tnum; t++) {
+			for (j = 0; j < SCALE_MAX; j++) {
+				if (iova_need)
+					mtk_imgsys_desc_iova(pipe,
+					&input_norm->fparams[t][j], dev_buf);
+				/* TODO: disable memcpy for imgstream fd */
+				if (!dst)
+					continue;
+				memcpy(&dst->fparams[t][j],
+						&input_norm->fparams[t][j],
+						sizeof(struct frameparams));
+			}
+		}
+		if (dst)
+			dst->fparams_tnum = input_norm->fparams_tnum;
+	}
+}
+
+static void mtk_imgsys_desc_set_skip(struct mtk_imgsys_pipe *pipe,
+				int dma,
+				void *src,
+				struct header_desc *dst,
+				bool iova_need,
+				struct mtk_imgsys_dev_buffer *dev_buf)
+{
+
+	unsigned int tmax, tnum, t, j;
+	struct header_desc *input_smvr = NULL;
+	struct header_desc_norm *input_norm = NULL;
+	struct singlenode_desc *desc_sd = NULL;
+	struct singlenode_desc_norm *desc_sd_norm = NULL;
+
+	switch (dev_buf->dev_fmt->format) {
+	case V4L2_META_FMT_MTISP_SD:
+		desc_sd = (struct singlenode_desc *)dev_buf->va_daddr[0];
+		input_smvr = (struct header_desc *)src;
+		tmax = TIME_MAX;
+		tnum = input_smvr->fparams_tnum;
+		break;
+	case V4L2_META_FMT_MTISP_SDNORM:
+	default:
+		desc_sd_norm =
+			(struct singlenode_desc_norm *)dev_buf->va_daddr[0];
+		input_norm = (struct header_desc_norm *)src;
+		tmax = TMAX;
+		tnum = input_norm->fparams_tnum;
+		break;
+	}
+	/*fd2iova : need 2D array parsing*/
+	if (tnum >= tmax) {
+		tnum = tmax;
+		pr_debug("%s: %d bufinfo enqueued exceeds %d\n", __func__,
+			tnum, tmax);
+	}
+
+	if (input_smvr) {
+		for (t = 0; t < tnum; t++) {
+			if (!desc_sd->dmas_enable[dma][t])
+				continue;
+			for (j = 0; j < SCALE_MAX; j++) {
+				if (iova_need)
+					mtk_imgsys_desc_iova(pipe,
+					&input_smvr->fparams[t][j], dev_buf);
+				/* TODO: disable memcpy for imgstream fd */
+				if (!dst)
+					continue;
+				memcpy(&dst->fparams[t][j],
+						&input_smvr->fparams[t][j],
+						sizeof(struct frameparams));
+			}
+		}
+		if (dst)
+			dst->fparams_tnum = input_smvr->fparams_tnum;
+	} else {
+		for (t = 0; t < tnum; t++) {
+			if (!desc_sd_norm->dmas_enable[dma][t])
+				continue;
+
+			for (j = 0; j < SCALE_MAX; j++) {
+				if (iova_need)
+					mtk_imgsys_desc_iova(pipe,
+					&input_norm->fparams[t][j], dev_buf);
+				/* TODO: disable memcpy for imgstream fd */
+				if (!dst)
+					continue;
+				memcpy(&dst->fparams[t][j],
+						&input_norm->fparams[t][j],
+						sizeof(struct frameparams));
+			}
+		}
+		if (dst)
+			dst->fparams_tnum = input_norm->fparams_tnum;
+	}
+}
+
+
+void mtk_imgsys_desc_map_iova(struct mtk_imgsys_request *req)
+{
+	unsigned int i;
+	struct mtk_imgsys_pipe *pipe = req->imgsys_pipe;
+	struct mtk_imgsys_dev_buffer *buf_dma;
+	struct img_ipi_frameparam *dip_param = req->working_buf->frameparam.vaddr;
+	struct header_desc *desc;
+	void *desc_dma = NULL;
+	bool need_iova = true;
+	unsigned int s, e;
+
+	s = ktime_get_boottime_ns()/1000;
+	for (i = 0; i < pipe->desc->total_queues; i++) {
+
+		buf_dma = req->buf_map[i];
+		if (!buf_dma)
+			continue;
+
+		if (!buf_dma->va_daddr[0]) {
+			pr_info("%s fail!! desc_dma is NULL !", __func__);
+			return;
+		}
+
+		desc = NULL;
+		/* TODO: desc mode */
+		/* if (dip_param) */
+		/*	dip_param->dmas_enable[i] = 1; */
+
+		if (i == MTK_IMGSYS_VIDEO_NODE_TUNING_OUT) {
+			if (dip_param)
+				desc = &dip_param->tuning_meta;
+			need_iova = true;
+		} else if (i == MTK_IMGSYS_VIDEO_NODE_CTRLMETA_OUT) {
+			if (dip_param)
+				desc = &dip_param->ctrl_meta;
+			need_iova = false;
+		} else {
+			if (dip_param)
+				desc = &dip_param->dmas[i];
+			need_iova = true;
+		}
+
+		desc_dma = (void *)buf_dma->va_daddr[0];
+		mtk_imgsys_desc_set(pipe, desc_dma, desc, need_iova, buf_dma);
+	}
+	e = ktime_get_boottime_ns()/1000;
+	pr_debug("%s takes %d ms\n", __func__, (e - s));
+}
+
+void mtk_imgsys_sd_desc_map_iova(struct mtk_imgsys_request *req)
+{
+	unsigned int i;
+	struct mtk_imgsys_pipe *pipe = req->imgsys_pipe;
+	struct mtk_imgsys_dev_buffer *buf_sd;
+	struct img_ipi_frameparam *dip_param = req->working_buf->frameparam.vaddr;
+	struct singlenode_desc *desc_sd = NULL;
+	struct singlenode_desc_norm *desc_sd_norm = NULL;
+	void *src;
+	struct header_desc *dst;
+	int b;
+
+	b = is_singledev_mode(req);
+	buf_sd = req->buf_map[b];
+	if (!buf_sd)
+		return;
+
+	if (!buf_sd->va_daddr[0]) {
+		pr_info("%s fail!! desc_sd is NULL !", __func__);
+		return;
+	}
+
+	switch (buf_sd->dev_fmt->format) {
+	default:
+	case V4L2_META_FMT_MTISP_SD:
+		desc_sd = (struct singlenode_desc *)buf_sd->va_daddr[0];
+		break;
+	case V4L2_META_FMT_MTISP_SDNORM:
+		desc_sd_norm =
+			(struct singlenode_desc_norm *)buf_sd->va_daddr[0];
+		break;
+	}
+
+	for (i = 0; i < IMG_MAX_HW_DMAS; i++) {
+
+		if (desc_sd)
+			src = (void *)&desc_sd->dmas[i];
+		else
+			src = (void *)&desc_sd_norm->dmas[i];
+
+		if (!dip_param)
+			dst = NULL;
+		else {
+			dst = &dip_param->dmas[i];
+			/* TODO: desc mode */
+			/* dip_param->dmas_enable[i] = 1; */
+		}
+
+		mtk_imgsys_desc_set_skip(pipe, i, src, dst, 1, buf_sd);
+	}
+
+	/* tuning */
+	if (desc_sd)
+		src = (void *)&desc_sd->tuning_meta;
+	else
+		src = (void *)&desc_sd_norm->tuning_meta;
+
+	if (!dip_param)
+		dst = NULL;
+	else
+		dst = &dip_param->tuning_meta;
+	mtk_imgsys_desc_set_skip(pipe,
+		MTK_IMGSYS_VIDEO_NODE_TUNING_OUT, src, dst, 1, buf_sd);
+
+	/* ctrl_meta */
+	if (desc_sd)
+		src = (void *)&desc_sd->ctrl_meta;
+	else
+		src = (void *)&desc_sd_norm->ctrl_meta;
+
+	if (!dip_param)
+		dst = NULL;
+	else
+		dst = &dip_param->ctrl_meta;
+	mtk_imgsys_desc_set(pipe, src, dst, 0, buf_sd);
+
+}
+
+
+static void mtk_imgsys_std2desc_fill_bufinfo(struct mtk_imgsys_pipe *pipe,
+					struct header_desc *ipidma,
+					struct mtk_imgsys_dev_buffer *dev_buf)
+{
+	int i = 0;
+#ifndef USE_V4L2_FMT
+	struct v4l2_plane_pix_format *vfmt;
+	struct plane_pix_format *bfmt;
+
+	ipidma->fparams[0][0].bufs[0].fmt.fmt.pix_mp.width =
+						dev_buf->fmt.fmt.pix_mp.width;
+	ipidma->fparams[0][0].bufs[0].fmt.fmt.pix_mp.height =
+						dev_buf->fmt.fmt.pix_mp.height;
+	ipidma->fparams[0][0].bufs[0].fmt.fmt.pix_mp.pixelformat =
+					dev_buf->fmt.fmt.pix_mp.pixelformat;
+
+	for (i = 0; i < IMGBUF_MAX_PLANES; i++) {
+		vfmt = &dev_buf->fmt.fmt.pix_mp.plane_fmt[i];
+		bfmt =
+		&ipidma->fparams[0][0].bufs[0].fmt.fmt.pix_mp.plane_fmt[i];
+		bfmt->sizeimage = vfmt->sizeimage;
+		bfmt->bytesperline = vfmt->sizeimage;
+	}
+#else
+	ipidma->fparams[0][0].bufs[0].fmt.fmt.pix_mp = dev_buf->fmt.fmt.pix_mp;
+#endif
+	ipidma->fparams[0][0].bufs[0].crop = dev_buf->crop;
+	/* ipidma->fparams[0][0].bufs[0].compose = dev_buf->compose;*/
+	ipidma->fparams[0][0].bufs[0].rotation = dev_buf->rotation;
+	ipidma->fparams[0][0].bufs[0].hflip = dev_buf->hflip;
+	ipidma->fparams[0][0].bufs[0].vflip = dev_buf->vflip;
+
+	dev_dbg(pipe->imgsys_dev->dev,
+		"[%s] rotat(%d), hflip(%d), vflip(%d)\n",
+		__func__,
+		ipidma->fparams[0][0].bufs[0].rotation,
+		ipidma->fparams[0][0].bufs[0].hflip,
+		ipidma->fparams[0][0].bufs[0].vflip);
+
+	for (i = 0; i < dev_buf->fmt.fmt.pix_mp.num_planes; i++) {
+		dev_dbg(pipe->imgsys_dev->dev,
+			"[%s] multi-planes : width(%d), width(%d), pixelformat(%d), sizeimage(%d), bytesperline(%d)\n",
+			__func__,
+		ipidma->fparams[0][0].bufs[0].fmt.fmt.pix_mp.width,
+		ipidma->fparams[0][0].bufs[0].fmt.fmt.pix_mp.height,
+		ipidma->fparams[0][0].bufs[0].fmt.fmt.pix_mp.pixelformat,
+	ipidma->fparams[0][0].bufs[0].fmt.fmt.pix_mp.plane_fmt[i].sizeimage,
+	ipidma->fparams[0][0].bufs[0].fmt.fmt.pix_mp.plane_fmt[i].bytesperline);
+	}
+}
+
+static void mtk_imgsys_meta_std2desc_fill_extbuf(struct mtk_imgsys_pipe *pipe,
+					struct header_desc *ipidma,
+					struct mtk_imgsys_dev_buffer *dev_buf)
+{
+	struct device *dev = pipe->imgsys_dev->dev;
+
+	dev_dbg(dev,
+		"%s : scp_daddr(0x%llx),isp_daddr(0x%llx),va_daddr(0x%llx)\n",
+		__func__,
+		dev_buf->scp_daddr[0],
+		dev_buf->isp_daddr[0],
+		dev_buf->va_daddr[0]);
+
+	ipidma->fparams[0][0].bufs[0].buf.planes[0].m.dma_buf.fd =
+		dev_buf->vbb.vb2_buf.planes[0].m.fd;
+	ipidma->fparams[0][0].bufs[0].buf.planes[0].m.dma_buf.offset =
+		dev_buf->vbb.vb2_buf.planes[0].m.offset;
+	ipidma->fparams[0][0].bufs[0].buf.planes[0].reserved[0] =
+		(uint32_t)dev_buf->isp_daddr[0];
+	dev_dbg(dev,
+		"[%s]multi-plane[%d]:fd(%d),offset(%d),iova(0x%llx)\n",
+		__func__, 0,
+	ipidma->fparams[0][0].bufs[0].buf.planes[0].m.dma_buf.fd,
+	ipidma->fparams[0][0].bufs[0].buf.planes[0].m.dma_buf.offset,
+	ipidma->fparams[0][0].bufs[0].buf.planes[0].reserved[0]);
+}
+
+
+static void mtk_imgsys_std2desc_fill_extbuf(struct mtk_imgsys_pipe *pipe,
+					struct header_desc *ipidma,
+					struct mtk_imgsys_dev_buffer *dev_buf)
+{
+	struct device *dev = pipe->imgsys_dev->dev;
+	int i = 0;
+
+	dev_dbg(dev,
+		"%s : scp_daddr(0x%llx),isp_daddr(0x%llx),va_daddr(0x%llx)\n",
+		__func__,
+		dev_buf->scp_daddr[0],
+		dev_buf->isp_daddr[0],
+		dev_buf->va_daddr[0]);
+
+	for (i = 0; i < dev_buf->fmt.fmt.pix_mp.num_planes; i++) {
+		ipidma->fparams[0][0].bufs[0].buf.planes[i].m.dma_buf.fd =
+			dev_buf->vbb.vb2_buf.planes[i].m.fd;
+		ipidma->fparams[0][0].bufs[0].buf.planes[i].m.dma_buf.offset =
+			dev_buf->vbb.vb2_buf.planes[i].m.offset;
+		ipidma->fparams[0][0].bufs[0].buf.planes[i].reserved[0] =
+			(uint32_t)dev_buf->isp_daddr[i];
+		dev_dbg(dev,
+			"[%s]multi-plane[%d]:fd(%d),offset(%d),iova(0x%llx)\n",
+			__func__, i,
+		ipidma->fparams[0][0].bufs[0].buf.planes[i].m.dma_buf.fd,
+		ipidma->fparams[0][0].bufs[0].buf.planes[i].m.dma_buf.offset,
+		ipidma->fparams[0][0].bufs[0].buf.planes[i].reserved[0]);
+	}
+
+}
+
+void mtk_imgsys_std_ipi_params_config(struct mtk_imgsys_request *req)
+{
+	struct mtk_imgsys_pipe *pipe = req->imgsys_pipe;
+	struct device *dev = pipe->imgsys_dev->dev;
+	struct img_ipi_frameparam *dip_param = req->working_buf->frameparam.vaddr;
+	struct mtk_imgsys_dev_buffer *buf_dma;
+	struct mtk_imgsys_dev_buffer *buf_tuning;
+	struct mtk_imgsys_dev_buffer *buf_ctrlmeta;
+	int i = 0;
+
+	dev_dbg(dev, "%s:%s: pipe-job id(%d)\n", __func__,
+		pipe->desc->name, req->id);
+
+	memset(dip_param, 0, sizeof(*dip_param));
+
+	/* Tuning buffer */
+	buf_tuning =
+		req->buf_map[MTK_IMGSYS_VIDEO_NODE_TUNING_OUT];
+	if (buf_tuning) {
+		dev_dbg(dev,
+			"Tuning buf queued: scp_daddr(0x%llx),isp_daddr(0x%llx),va_daddr(0x%llx)\n",
+			buf_tuning->scp_daddr[0],
+			buf_tuning->isp_daddr[0],
+			buf_tuning->va_daddr[0]);
+
+		mtk_imgsys_meta_std2desc_fill_extbuf(pipe,
+			&dip_param->tuning_meta,
+			buf_tuning);
+
+	} else {
+		dev_dbg(dev,
+			"No enqueued tuning buffer\n");
+	}
+
+	buf_ctrlmeta = req->buf_map[MTK_IMGSYS_VIDEO_NODE_CTRLMETA_OUT];
+	if (buf_ctrlmeta) {
+		/* TODO: kva */
+		dev_dbg(dev,
+			"Ctrlmeta buf queued: scp_daddr(0x%llx),isp_daddr(0x%llx),va_daddr(0x%llx)\n",
+			buf_ctrlmeta->scp_daddr[0],
+			buf_ctrlmeta->isp_daddr[0],
+			buf_ctrlmeta->va_daddr[0]);
+
+		mtk_imgsys_meta_std2desc_fill_extbuf(pipe,
+			&dip_param->ctrl_meta,
+			buf_ctrlmeta);
+
+	}
+	for (i = 0; i < pipe->desc->total_queues; i++) {
+		if ((i == MTK_IMGSYS_VIDEO_NODE_TUNING_OUT) ||
+			(i == MTK_IMGSYS_VIDEO_NODE_CTRLMETA_OUT))
+			continue;
+
+		buf_dma = req->buf_map[i];
+		if (buf_dma) {
+			mtk_imgsys_std2desc_fill_extbuf(pipe,
+				&dip_param->dmas[i],
+				buf_dma);
+			mtk_imgsys_std2desc_fill_bufinfo(pipe,
+				&dip_param->dmas[i],
+				buf_dma);
+		}
+	}
+}
+
+static void mtk_imgsys_singledevice_fill_ipi_param(struct mtk_imgsys_pipe *pipe,
+					void *sd_dma,
+					struct mtk_imgsys_dev_buffer *dev_buf,
+					bool isMENode)
+{
+	//struct device *dev = pipe->imgsys_dev->dev;
+	unsigned int i = 0, j = 0, tnum, tmax;
+	struct header_desc *input_smvr = NULL;
+	struct header_desc_norm *input_norm = NULL;
+
+	switch (dev_buf->dev_fmt->format) {
+	case V4L2_META_FMT_MTISP_SD:
+		input_smvr = (struct header_desc *)sd_dma;
+		tmax = TIME_MAX;
+		tnum = input_smvr->fparams_tnum;
+		break;
+	default:
+	case V4L2_META_FMT_MTISP_SDNORM:
+		input_norm = (struct header_desc_norm *)sd_dma;
+		tmax = TMAX;
+		tnum = input_norm->fparams_tnum;
+		break;
+	}
+	/*fd2iova : need 2D array parsing*/
+	if (tnum >= tmax) {
+		tnum = tmax;
+		pr_debug("%s: %d bufinfo enqueued exceeds %d\n", __func__,
+			tnum, tmax);
+	}
+
+	if (input_norm) {
+		for (i = 0; i < tnum ; i++) {
+			for (j = 0; j < SCALE_MAX; j++)
+				mtk_imgsys_desc_fill_dmabuf(pipe,
+					&input_norm->fparams[i][j], isMENode);
+		}
+	} else {
+		for (i = 0; i < tnum ; i++) {
+			for (j = 0; j < SCALE_MAX; j++)
+				mtk_imgsys_desc_fill_dmabuf(pipe,
+					&input_smvr->fparams[i][j], isMENode);
+		}
+	}
+}
+
+static void mtk_imgsys_sd_fill_dmas(struct mtk_imgsys_pipe *pipe, int dma,
+					void *sd_dma,
+					struct mtk_imgsys_dev_buffer *dev_buf,
+					bool isMENode)
+{
+	//struct device *dev = pipe->imgsys_dev->dev;
+	unsigned int i = 0, j = 0, tnum, tmax;
+	struct header_desc *input_smvr = NULL;
+	struct header_desc_norm *input_norm = NULL;
+	struct singlenode_desc *sd_desc = NULL;
+	struct singlenode_desc_norm *sd_desc_norm = NULL;
+
+	switch (dev_buf->dev_fmt->format) {
+	case V4L2_META_FMT_MTISP_SD:
+		sd_desc =
+			(struct singlenode_desc *)dev_buf->va_daddr[0];
+		input_smvr = (struct header_desc *)sd_dma;
+		tmax = TIME_MAX;
+		tnum = input_smvr->fparams_tnum;
+		break;
+	default:
+	case V4L2_META_FMT_MTISP_SDNORM:
+		sd_desc_norm =
+			(struct singlenode_desc_norm *)dev_buf->va_daddr[0];
+		input_norm = (struct header_desc_norm *)sd_dma;
+		tmax = TMAX;
+		tnum = input_norm->fparams_tnum;
+		break;
+	}
+	/*fd2iova : need 2D array parsing*/
+	if (tnum >= tmax) {
+		tnum = tmax;
+		pr_debug("%s: %d bufinfo enqueued exceeds %d\n", __func__,
+			tnum, tmax);
+	}
+
+	if (input_norm) {
+		for (i = 0; i < tnum ; i++) {
+			if (!sd_desc_norm->dmas_enable[dma][i])
+				continue;
+			for (j = 0; j < SCALE_MAX; j++)
+				mtk_imgsys_desc_fill_dmabuf(pipe,
+					&input_norm->fparams[i][j], isMENode);
+		}
+	} else {
+		for (i = 0; i < tnum ; i++) {
+			if (!sd_desc->dmas_enable[dma][i])
+				continue;
+
+			for (j = 0; j < SCALE_MAX; j++)
+				mtk_imgsys_desc_fill_dmabuf(pipe,
+					&input_smvr->fparams[i][j], isMENode);
+		}
+	}
+}
+
+
+void mtk_imgsys_singledevice_ipi_params_config(struct mtk_imgsys_request *req)
+{
+	struct mtk_imgsys_pipe *pipe = req->imgsys_pipe;
+	struct device *dev = pipe->imgsys_dev->dev;
+	struct mtk_imgsys_dev_buffer *buf_in;
+	struct singlenode_desc *singledevice_desc_dma = NULL;
+	struct singlenode_desc_norm *singledevice_desc_norm = NULL;
+	void *tuning_meta, *ctrl_meta;
+	int i = 0;
+	bool isMENode = false;
+
+	dev_dbg(dev, "%s:%s: pipe-job id(%d)\n", __func__,
+		pipe->desc->name, req->id);
+
+	i = is_singledev_mode(req);
+	buf_in = req->buf_map[i];
+	if (!buf_in)
+		return;
+
+	if (buf_in->vbb.vb2_buf.memory == VB2_MEMORY_DMABUF)
+		mtk_imgsys_kva_cache(buf_in);
+	/* TODO:  MMAP imgbuffer path vaddr = 0 */
+
+	dev_dbg(dev,
+		"%s : scp_daddr(0x%llx),isp_daddr(0x%llx),va_daddr(0x%llx)\n",
+		__func__,
+		buf_in->scp_daddr[0],
+		buf_in->isp_daddr[0],
+		buf_in->va_daddr[0]);
+
+	/*getKVA*/
+	if (!buf_in->va_daddr[0]) {
+		pr_info("%s fail!! desc_dma is NULL !", __func__);
+		return;
+	}
+
+	//init map table list for each devbuf
+	INIT_LIST_HEAD(&buf_in->iova_map_table.list);
+	spin_lock_init(&buf_in->iova_map_table.lock);
+
+	//tuning_meta
+	switch (buf_in->dev_fmt->format) {
+	/* SMVR */
+	case V4L2_META_FMT_MTISP_SD:
+		singledevice_desc_dma =
+			(struct singlenode_desc *)buf_in->va_daddr[0];
+		tuning_meta = (void *) &singledevice_desc_dma->tuning_meta;
+		ctrl_meta = (void *) &singledevice_desc_dma->ctrl_meta;
+		break;
+	/* NORM */
+	default:
+	case V4L2_META_FMT_MTISP_SDNORM:
+		singledevice_desc_norm =
+			(struct singlenode_desc_norm *)buf_in->va_daddr[0];
+		tuning_meta = (void *) &singledevice_desc_norm->tuning_meta;
+		ctrl_meta = (void *) &singledevice_desc_norm->ctrl_meta;
+		break;
+	}
+	mtk_imgsys_sd_fill_dmas(pipe,
+			MTK_IMGSYS_VIDEO_NODE_TUNING_OUT,
+			tuning_meta,
+			buf_in, isMENode); //ME's tuning need fd2iova????
+
+	mtk_imgsys_singledevice_fill_ipi_param(pipe,
+			ctrl_meta,
+			buf_in, 1);
+
+	for (i = 0; i < IMG_MAX_HW_DMAS; i++) {
+
+		if (singledevice_desc_dma)
+			mtk_imgsys_sd_fill_dmas(pipe, i,
+				(void *)&singledevice_desc_dma->dmas[i],
+				buf_in, isMENode);
+		else
+			mtk_imgsys_sd_fill_dmas(pipe, i,
+				(void *)&singledevice_desc_norm->dmas[i],
+				buf_in, isMENode);
+	}
+}
+
+void mtk_imgsys_pipe_try_enqueue(struct mtk_imgsys_pipe *pipe)
+{
+	struct mtk_imgsys_request *req = NULL;
+	unsigned long flag;
+
+	if (!pipe->streaming)
+		return;
+
+	spin_lock_irqsave(&pipe->pending_job_lock, flag);
+	if (list_empty(&pipe->pipe_job_pending_list)) {
+		spin_unlock_irqrestore(&pipe->pending_job_lock, flag);
+		pr_info("%s: no requests", __func__);
+		return;
+	}
+	req = list_first_entry(&pipe->pipe_job_pending_list, struct mtk_imgsys_request, list);
+	list_del(&req->list);
+	pipe->num_pending_jobs--;
+	spin_unlock_irqrestore(&pipe->pending_job_lock, flag);
+
+	spin_lock_irqsave(&pipe->running_job_lock, flag);
+#ifdef JOB_RUN
+	list_add_tail(&req->list,
+		      &pipe->pipe_job_running_list);
+#endif
+	pipe->num_jobs++;
+	spin_unlock_irqrestore(&pipe->running_job_lock, flag);
+
+	mtk_imgsys_hw_enqueue(pipe->imgsys_dev, req);
+	dev_dbg(pipe->imgsys_dev->dev,
+		"%s:%s: pending jobs(%d), running jobs(%d)\n",
+		__func__, pipe->desc->name, pipe->num_pending_jobs,
+		pipe->num_jobs);
+}
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/imgsys/mtk_imgsys-dev.h b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/mtk_imgsys-dev.h
new file mode 100755
index 0000000000000000000000000000000000000000..26ba245c46d87ff8e0da27d7056979cb8d2a9d4e
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/mtk_imgsys-dev.h
@@ -0,0 +1,789 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2018 MediaTek Inc.
+ *
+ * Author: Frederic Chen <frederic.chen@mediatek.com>
+ *
+ */
+
+#ifndef _MTK_DIP_DEV_H_
+#define _MTK_DIP_DEV_H_
+
+#include <linux/completion.h>
+#include <linux/types.h>
+#include <linux/time.h>
+#include <linux/list.h>
+#include <linux/mutex.h>
+#include <linux/platform_device.h>
+#include <linux/pm_opp.h>
+#include <linux/regulator/consumer.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-subdev.h>
+#include <media/v4l2-device.h>
+#include <linux/videodev2.h>
+#include <media/videobuf2-core.h>
+#include <media/videobuf2-v4l2.h>
+
+#include "mtk_imgsys-hw.h"
+#include "mtk_imgsys-module.h"
+#include "mtkdip.h"
+//#include "mtk-interconnect.h"
+#include "mtk_imgsys-worker.h"
+
+#define MTK_IMGSYS_PIPE_ID_PREVIEW				0
+#define MTK_IMGSYS_PIPE_ID_CAPTURE				1
+#define MTK_IMGSYS_PIPE_ID_REPROCESS			2
+#define MTK_IMGSYS_PIPE_ID_TOTAL_NUM			1
+
+#define MTK_DIP_OUTPUT_MIN_WIDTH		2U
+#define MTK_DIP_OUTPUT_MIN_HEIGHT		2U
+#define MTK_DIP_OUTPUT_MAX_WIDTH		5376U
+#define MTK_DIP_OUTPUT_MAX_HEIGHT		4032U
+#define MTK_DIP_CAPTURE_MIN_WIDTH		2U
+#define MTK_DIP_CAPTURE_MIN_HEIGHT		2U
+#define MTK_DIP_CAPTURE_MAX_WIDTH		5376U
+#define MTK_DIP_CAPTURE_MAX_HEIGHT		4032U
+
+#define MTK_DIP_DEV_DIP_MEDIA_MODEL_NAME	"MTK-ISP-DIP-V4L2"
+#define MTK_DIP_DEV_DIP_PREVIEW_NAME \
+	MTK_DIP_DEV_DIP_MEDIA_MODEL_NAME
+#define MTK_DIP_DEV_DIP_CAPTURE_NAME		"MTK-ISP-DIP-CAP-V4L2"
+#define MTK_DIP_DEV_DIP_REPROCESS_NAME		"MTK-ISP-DIP-REP-V4L2"
+
+#define MTK_DIP_DEV_META_BUF_DEFAULT_SIZE	(1024 * 128)
+#define MTK_DIP_DEV_META_BUF_POOL_MAX_SIZE	(1024 * 1024 * 16)
+#define MTK_IMGSYS_OPP_SET			2
+#define MTK_IMGSYS_CLK_LEVEL_CNT		5
+#define MTK_IMGSYS_DVFS_GROUP			3
+#define MTK_IMGSYS_QOS_GROUP			2
+
+#define MTK_IMGSYS_LOG_LENGTH			1024
+
+extern unsigned int nodes_num;
+
+#define	MTK_IMGSYS_VIDEO_NODE_SIGDEV_NORM_OUT	(nodes_num - 1)
+#define	MTK_IMGSYS_VIDEO_NODE_SIGDEV_OUT	(nodes_num - 2)
+#define	MTK_IMGSYS_VIDEO_NODE_CTRLMETA_OUT	(nodes_num - 3)
+#define	MTK_IMGSYS_VIDEO_NODE_TUNING_OUT	(nodes_num - 4)
+
+
+enum imgsys_user_state {
+	DIP_STATE_INIT	= 0,
+	DIP_STATE_STREAMON,
+	DIP_STATE_STREAMOFF
+};
+
+enum mtk_imgsys_pixel_mode {
+	mtk_imgsys_pixel_mode_default = 0,
+	mtk_imgsys_pixel_mode_1,
+	mtk_imgsys_pixel_mode_2,
+	mtk_imgsys_pixel_mode_4,
+	mtk_imgsys_pixel_mode_num,
+};
+
+struct mtk_imgsys_dev_format {
+	u32 format;
+	u32 mdp_color;
+	u8 depth[VIDEO_MAX_PLANES];
+	u8 row_depth[VIDEO_MAX_PLANES];
+	u8 num_planes;
+	u8 num_cplanes;
+	u32 flags;
+	u32 buffer_size;
+	u8 pass_1_align;
+};
+
+// desc added {
+#define HBITS (32)
+struct mtk_imgsys_dma_buf_iova_list {
+	struct list_head list;
+	struct hlist_head hlists[HBITS];
+	spinlock_t lock;
+};
+
+struct mtk_imgsys_dma_buf_iova_get_info {
+	s32 ionfd;
+	dma_addr_t dma_addr;
+	/* ION case only */
+	struct dma_buf *dma_buf;
+	struct dma_buf_attachment *attach;
+	struct sg_table *sgt;
+	struct list_head list_entry;
+	struct hlist_node hnode;
+};
+// } desc added
+
+struct mtk_imgsys_dev_buffer {
+	struct vb2_v4l2_buffer vbb;
+	struct v4l2_format fmt;
+	const struct mtk_imgsys_dev_format *dev_fmt;
+	int pipe_job_id;
+	dma_addr_t isp_daddr[VB2_MAX_PLANES];
+	dma_addr_t scp_daddr[VB2_MAX_PLANES];
+	u64 va_daddr[VB2_MAX_PLANES];
+	__u32 dma_port;
+	struct mtk_imgsys_crop crop;
+	struct v4l2_rect compose;
+	__u32 rotation;
+	__u32 hflip;
+	__u32 vflip;
+	__u32 dataofst;
+	struct list_head list;
+
+// desc added {
+//Keep dmabuf used in latter for put kva
+	struct dma_buf *dma_buf_putkva;
+	struct mtk_imgsys_dma_buf_iova_list iova_map_table;
+// } desc added
+};
+
+struct mtk_imgsys_pipe_desc {
+	char *name;
+	int id;
+	struct mtk_imgsys_video_device_desc *queue_descs;
+	int total_queues;
+};
+
+struct mtk_imgsys_video_device_desc {
+	int id;
+	char *name;
+	u32 buf_type;
+	u32 cap;
+	int smem_alloc;
+	int supports_ctrls;
+	const struct mtk_imgsys_dev_format *fmts;
+	int num_fmts;
+	char *description;
+	int default_width;
+	int default_height;
+	unsigned int dma_port;
+	const struct v4l2_frmsizeenum *frmsizeenum;
+	const struct v4l2_ioctl_ops *ops;
+	const struct vb2_ops *vb2_ops;
+	u32 flags;
+	int default_fmt_idx;
+};
+
+struct mtk_imgsys_dev_queue {
+	struct vb2_queue vbq;
+	/* Serializes vb2 queue and video device operations */
+	struct mutex lock;
+	const struct mtk_imgsys_dev_format *dev_fmt;
+};
+
+struct mtk_imgsys_video_device {
+	struct video_device vdev;
+	struct mtk_imgsys_dev_queue dev_q;
+	struct v4l2_format vdev_fmt;
+	struct media_pad vdev_pad;
+	struct v4l2_mbus_framefmt pad_fmt;
+	struct v4l2_ctrl_handler ctrl_handler;
+	u32 flags;
+	const struct mtk_imgsys_video_device_desc *desc;
+	struct list_head buf_list;
+	struct v4l2_rect crop;
+	struct v4l2_rect compose;
+	int rotation;
+	/* protect the in-device buffer list */
+	spinlock_t buf_list_lock;
+};
+
+struct mtk_imgsys_pipe {
+	struct mtk_imgsys_dev *imgsys_dev;
+	struct mtk_imgsys_video_device *nodes;
+	unsigned long long nodes_streaming;
+	unsigned long long nodes_enabled;
+	int streaming;
+	struct media_pad *subdev_pads;
+	struct media_pipeline pipeline;
+	struct v4l2_subdev subdev;
+	struct v4l2_subdev_fh *fh;
+	atomic_t pipe_job_sequence;
+	struct list_head pipe_job_pending_list;
+	spinlock_t pending_job_lock;
+	int num_pending_jobs;
+	struct list_head pipe_job_running_list;
+	spinlock_t running_job_lock;
+	int num_jobs;
+	/* Serializes pipe's stream on/off and buffers enqueue operations */
+	struct mutex lock;
+	//spinlock_t job_lock; /* protect the pipe job list */
+	//struct mutex job_lock;
+	const struct mtk_imgsys_pipe_desc *desc;
+	struct mtk_imgsys_dma_buf_iova_list iova_cache;
+	struct init_info init_info;
+};
+
+struct imgsys_event_status {
+	__u32 req_fd;
+	__u32 frame_number;
+};
+
+struct imgsys_user_list {
+	// list for mtk_imgsys_user
+	struct list_head list;
+	struct mutex user_lock;
+};
+
+struct mtk_imgsys_dvfs {
+	struct device *dev;
+	struct regulator *reg;
+	unsigned int clklv_num[MTK_IMGSYS_OPP_SET];
+	unsigned int clklv[MTK_IMGSYS_OPP_SET][MTK_IMGSYS_CLK_LEVEL_CNT];
+	unsigned int voltlv[MTK_IMGSYS_OPP_SET][MTK_IMGSYS_CLK_LEVEL_CNT];
+	unsigned int clklv_idx[MTK_IMGSYS_OPP_SET];
+	unsigned int clklv_target[MTK_IMGSYS_OPP_SET];
+	unsigned int cur_volt;
+	unsigned long pixel_size[MTK_IMGSYS_DVFS_GROUP];
+	unsigned long freq;
+	unsigned int vss_task_cnt;
+	unsigned int smvr_task_cnt;
+};
+
+struct mtk_imgsys_qos_path {
+	struct icc_path *path;	/* cmdq event enum value */
+	char dts_name[256];
+	unsigned long long bw;
+};
+
+struct mtk_imgsys_qos {
+	struct device *dev;
+	struct mtk_imgsys_qos_path *qos_path;
+	unsigned long bw_total[MTK_IMGSYS_DVFS_GROUP][MTK_IMGSYS_QOS_GROUP];
+	unsigned long ts_total[MTK_IMGSYS_DVFS_GROUP];
+	unsigned long req_cnt;
+	bool isIdle;
+};
+
+struct gce_work {
+	struct list_head entry;
+	struct work_pool *pool;
+	struct imgsys_work work;
+	struct mtk_imgsys_request *req;
+	void *req_sbuf_kva;
+};
+
+#define GCE_WORK_NR (128)
+struct work_pool {
+	atomic_t num;
+	struct list_head free_list;
+	struct list_head used_list;
+	spinlock_t lock;
+	wait_queue_head_t waitq;
+	void *_cookie;
+	struct kref kref;
+};
+
+#define RUNNER_WQ_NR (4)
+typedef void (*debug_dump)(struct mtk_imgsys_dev *imgsys_dev, 		\
+	const struct module_ops *imgsys_modules, int imgsys_module_num,	\
+	unsigned int hw_comb);
+
+struct mtk_imgsys_dev {
+	struct device *dev;
+	struct device *dev_Me;
+	struct resource *imgsys_resource;
+	struct media_device mdev;
+	struct v4l2_device v4l2_dev;
+	struct mtk_imgsys_pipe imgsys_pipe[MTK_IMGSYS_PIPE_ID_TOTAL_NUM];
+	struct clk_bulk_data *clks;
+	int num_clks;
+	int num_mods;
+	struct workqueue_struct *enqueue_wq;
+	struct workqueue_struct *composer_wq;
+	struct workqueue_struct *mdp_wq[RUNNER_WQ_NR];
+	struct imgsys_queue runnerque;
+	wait_queue_head_t flushing_waitq;
+
+	struct work_pool gwork_pool;
+	atomic_t num_composing;	/* increase after ipi */
+	/*MDP/GCE callback workqueue */
+	struct workqueue_struct *mdpcb_wq;
+	/* for MDP driver  */
+	struct platform_device *mdp_pdev;
+	/* for SCP driver  */
+	struct platform_device *scp_pdev;
+	struct rproc *rproc_handle;
+	struct mtk_imgsys_hw_working_buf_list imgsys_freebufferlist;
+	struct mtk_imgsys_hw_working_buf_list imgsys_usedbufferlist;
+	dma_addr_t working_buf_mem_scp_daddr;
+	void *working_buf_mem_vaddr;
+	dma_addr_t working_buf_mem_isp_daddr;
+	int working_buf_mem_size;
+	struct mtk_imgsys_hw_subframe working_buf[DIP_SUB_FRM_DATA_NUM];
+	/* increase after enqueue */
+	atomic_t imgsys_enqueue_cnt;
+	/* increase after stream on, decrease when stream off */
+	int imgsys_stream_cnt;
+	int abnormal_stop;
+	/* To serialize request opertion to DIP co-procrosser and hadrware */
+	struct mutex hw_op_lock;
+	/* To restrict the max number of request be send to SCP */
+	struct semaphore sem;
+	struct imgsys_user_list imgsys_users;
+	uint32_t reg_table_size;
+	uint32_t isp_version;
+	const struct mtk_imgsys_pipe_desc *cust_pipes;
+	const struct module_ops *modules;
+	struct mtk_imgsys_dvfs dvfs_info;
+	struct mtk_imgsys_qos qos_info;
+	struct mutex dvfs_qos_lock;
+	struct mutex power_ctrl_lock;
+	debug_dump dump;
+	atomic_t imgsys_user_cnt;
+	struct kref init_kref;
+};
+
+/* contained in struct mtk_imgsys_user's done_list */
+struct done_frame_pack {
+	struct frame_param_pack pack;
+	struct list_head done_entry;
+};
+
+struct mtk_imgsys_user {
+	struct list_head entry;
+	u16 id;
+	struct v4l2_fh *fh;
+	enum imgsys_user_enum user_enum;
+
+	/* used by batch mode only */
+	wait_queue_head_t enque_wq;
+	struct list_head done_list;  /* contains struct done_frame_pack */
+	bool dqdonestate; /*batchmode use to check dqdonestate*/
+	wait_queue_head_t done_wq;
+
+	// ToDo: should also sync with standard mode
+	enum imgsys_user_state state;
+	spinlock_t lock;
+};
+
+struct mtk_imgsys_time_state {
+	int req_fd;
+	u64 time_qbuf;
+	u64 time_qreq;
+	u64 time_composingStart;
+	u64 time_composingEnd;
+	u64 time_iovaworkp;
+	u64 time_qw2composer;
+	u64 time_compfuncStart;
+	u64 time_ipisendStart;
+	u64 time_reddonescpStart;
+	u64 time_doframeinfo;
+	u64 time_qw2runner;
+	u64 time_runnerStart;
+	u64 time_send2cmq;
+	u64 time_cmqret;
+	u64 time_sendtask;
+	u64 time_mdpcbStart;
+	u64 time_notifyStart;
+	u64 time_unmapiovaEnd;
+	u64 time_notify2vb2done;
+};
+
+struct scp_work {
+	struct work_struct work;
+	struct mtk_imgsys_request *req;
+	void *req_sbuf_kva;
+};
+
+struct gce_timeout_work {
+	struct work_struct work;
+	struct mtk_imgsys_request *req;
+	void *req_sbuf_kva;
+	void *pipe;
+	uint32_t fail_uinfo_idx;
+	int8_t fail_isHWhang;
+};
+
+struct gce_cb_work {
+	struct work_struct work;
+	u32 reqfd;
+	void *req_sbuf_kva;
+	void *pipe;
+};
+
+struct req_frameparam {
+	u32		index;
+	u32		frame_no;
+	u64		timestamp;
+	u8		state;
+	u8		num_inputs;
+	u8		num_outputs;
+	struct img_sw_addr	self_data;
+} __attribute__ ((__packed__));
+
+struct req_frame {
+	struct req_frameparam frameparam;
+};
+
+struct mtk_imgsys_request {
+	struct media_request req;
+	struct mtk_imgsys_pipe *imgsys_pipe;
+	struct completion done;
+	bool used;
+	int id;
+	//all devicebuf use the same fd and va
+	int buf_fd;
+	u64 buf_va_daddr;
+	bool buf_same;
+	//
+	struct mtk_imgsys_dev_buffer
+				**buf_map;
+	struct list_head list;
+	struct req_frame img_fparam;
+	struct work_struct fw_work;
+	struct work_struct iova_work;
+	/* It is used only in timeout handling flow */
+	struct work_struct mdpcb_work;
+	struct mtk_imgsys_hw_subframe *working_buf;
+	atomic_t buf_count;
+	atomic_t swfrm_cnt;
+	struct mtk_imgsys_time_state tstate;
+#ifdef BATCH_MODE_V3
+	// V3 added {
+	/* Batch mode unprocessed_count */
+	int unprocessed_count;
+	struct done_frame_pack *done_pack;
+	struct mtk_imgsys_hw_working_buf_list working_buf_list;
+	struct mtk_imgsys_hw_working_buf_list scp_done_list;
+	struct mtk_imgsys_hw_working_buf_list runner_done_list;
+	struct mtk_imgsys_hw_working_buf_list mdp_done_list;
+	bool is_batch_mode;
+	// } V3 added
+#endif
+};
+
+#ifdef BATCH_MODE_V3
+// V3 added {
+struct mtk_mdpcb_work {
+	struct work_struct		frame_work;
+	struct mtk_imgsys_request		*req;
+};
+
+struct mtk_runner_work {
+	struct work_struct		frame_work;
+	struct mtk_imgsys_request		*req;
+};
+// } V3 added
+#endif
+
+int mtk_imgsys_dev_media_register(struct device *dev,
+			       struct media_device *media_dev);
+
+void mtk_imgsys_dev_v4l2_release(struct mtk_imgsys_dev *imgsys_dev);
+
+int mtk_imgsys_pipe_v4l2_register(struct mtk_imgsys_pipe *pipe,
+			       struct media_device *media_dev,
+			       struct v4l2_device *v4l2_dev);
+
+void mtk_imgsys_pipe_v4l2_unregister(struct mtk_imgsys_pipe *pipe);
+
+int mtk_imgsys_pipe_init(struct mtk_imgsys_dev *imgsys_dev,
+			struct mtk_imgsys_pipe *pipe,
+			const struct mtk_imgsys_pipe_desc *setting);
+
+int mtk_imgsys_pipe_release(struct mtk_imgsys_pipe *pipe);
+
+struct mtk_imgsys_request *
+mtk_imgsys_pipe_get_running_job(struct mtk_imgsys_pipe *pipe,
+			     int id);
+
+void mtk_imgsys_pipe_remove_job(struct mtk_imgsys_request *req);
+
+int mtk_imgsys_pipe_next_job_id(struct mtk_imgsys_pipe *pipe);
+
+#ifdef BATCH_MODE_V3
+int mtk_imgsys_pipe_next_job_id_batch_mode(struct mtk_imgsys_pipe *pipe,
+		unsigned short user_id);
+#endif
+struct fd_kva_list_t *get_fd_kva_list(void);
+struct buf_va_info_t *get_first_sd_buf(void);
+
+void mtk_imgsys_pipe_debug_job(struct mtk_imgsys_pipe *pipe,
+			    struct mtk_imgsys_request *req);
+
+void mtk_imgsys_pipe_job_finish(struct mtk_imgsys_request *req,
+			     enum vb2_buffer_state vbf_state);
+
+const struct mtk_imgsys_dev_format *
+mtk_imgsys_pipe_find_fmt(struct mtk_imgsys_pipe *pipe,
+		      struct mtk_imgsys_video_device *node,
+		      u32 format);
+
+void mtk_imgsys_pipe_try_fmt(struct mtk_imgsys_pipe *pipe,
+			  struct mtk_imgsys_video_device *node,
+			  struct v4l2_format *fmt,
+			  const struct v4l2_format *ufmt,
+			  const struct mtk_imgsys_dev_format *dfmt);
+
+void mtk_imgsys_pipe_load_default_fmt(struct mtk_imgsys_pipe *pipe,
+				   struct mtk_imgsys_video_device *node,
+				   struct v4l2_format *fmt_to_fill);
+
+bool is_desc_mode(struct mtk_imgsys_request *req);
+
+int is_singledev_mode(struct mtk_imgsys_request *req);
+
+bool is_desc_fmt(const struct mtk_imgsys_dev_format *dev_fmt);
+
+void mtk_imgsys_desc_ipi_params_config(struct mtk_imgsys_request *req);
+
+void mtk_imgsys_std_ipi_params_config(struct mtk_imgsys_request *req);
+
+void mtk_imgsys_singledevice_ipi_params_config(struct mtk_imgsys_request *req);
+
+void mtk_imgsys_pipe_try_enqueue(struct mtk_imgsys_pipe *pipe);
+
+void mtk_imgsys_hw_enqueue(struct mtk_imgsys_dev *imgsys_dev,
+			struct mtk_imgsys_request *req);
+
+int mtk_imgsys_hw_streamoff(struct mtk_imgsys_pipe *pipe);
+
+int mtk_imgsys_hw_streamon(struct mtk_imgsys_pipe *pipe);
+
+static inline struct mtk_imgsys_pipe*
+mtk_imgsys_dev_get_pipe(struct mtk_imgsys_dev *imgsys_dev, unsigned int pipe_id)
+{
+	if (pipe_id >= MTK_IMGSYS_PIPE_ID_TOTAL_NUM)
+		return NULL;
+
+	return &imgsys_dev->imgsys_pipe[pipe_id];
+}
+
+static inline struct mtk_imgsys_video_device*
+mtk_imgsys_file_to_node(struct file *file)
+{
+	return container_of(video_devdata(file),
+			    struct mtk_imgsys_video_device, vdev);
+}
+
+static inline struct mtk_imgsys_pipe*
+mtk_imgsys_subdev_to_pipe(struct v4l2_subdev *sd)
+{
+	return container_of(sd, struct mtk_imgsys_pipe, subdev);
+}
+
+static inline struct mtk_imgsys_dev*
+mtk_imgsys_mdev_to_dev(struct media_device *mdev)
+{
+	return container_of(mdev, struct mtk_imgsys_dev, mdev);
+}
+
+static inline struct mtk_imgsys_video_device*
+mtk_imgsys_vbq_to_node(struct vb2_queue *vq)
+{
+	return container_of(vq, struct mtk_imgsys_video_device, dev_q.vbq);
+}
+
+static inline struct mtk_imgsys_dev_buffer*
+mtk_imgsys_vb2_buf_to_dev_buf(struct vb2_buffer *vb)
+{
+	return container_of(vb, struct mtk_imgsys_dev_buffer, vbb.vb2_buf);
+}
+
+static inline struct mtk_imgsys_request*
+mtk_imgsys_media_req_to_imgsys_req(struct media_request *req)
+{
+	return container_of(req, struct mtk_imgsys_request, req);
+}
+
+static inline struct mtk_imgsys_request*
+mtk_imgsys_hw_fw_work_to_req(struct work_struct *fw_work)
+{
+	return container_of(fw_work, struct mtk_imgsys_request, fw_work);
+}
+
+static inline struct mtk_imgsys_request*
+mtk_imgsys_hw_mdp_work_to_req(struct work_struct *mdp_work)
+{
+	struct scp_work *swork  = container_of(mdp_work, struct scp_work, work);
+
+	return swork->req;
+}
+
+static inline struct mtk_imgsys_request *
+mtk_imgsys_hw_mdpcb_work_to_req(struct work_struct *mdpcb_work)
+{
+	struct scp_work *swork  = container_of(mdpcb_work, struct scp_work, work);
+
+	return swork->req;
+}
+
+static inline struct mtk_imgsys_request *
+mtk_imgsys_hw_timeout_work_to_req(struct work_struct *gcetimeout_work)
+{
+	struct gce_timeout_work *gwork  = container_of(gcetimeout_work,
+		struct gce_timeout_work, work);
+
+	return gwork->req;
+}
+
+#ifdef GCE_DONE_USE_REQ
+static inline struct mtk_imgsys_request *
+mtk_imgsys_hw_gce_done_work_to_req(struct work_struct *gcecb_work)
+{
+	struct gce_cb_work *gwork  = container_of(gcecb_work, struct gce_cb_work, work);
+
+	return gwork->req;
+}
+#endif
+
+static inline int mtk_imgsys_buf_is_meta(u32 type)
+{
+	return type == V4L2_BUF_TYPE_META_CAPTURE ||
+		type == V4L2_BUF_TYPE_META_OUTPUT;
+}
+
+static inline int mtk_imgsys_pipe_get_pipe_from_job_id(int id)
+{
+	return (id >> 16) & 0x0000FFFF;
+}
+
+static inline void
+mtk_imgsys_wbuf_to_ipi_img_sw_addr(struct img_sw_addr *ipi_addr,
+				struct mtk_imgsys_hw_working_buf *wbuf)
+{
+	ipi_addr->va = (u64)wbuf->vaddr;
+	ipi_addr->pa = (u32)wbuf->scp_daddr;
+}
+
+int mtk_imgsys_hw_working_buf_pool_init(struct mtk_imgsys_dev *imgsys_dev);
+void mtk_imgsys_hw_working_buf_pool_release(struct mtk_imgsys_dev *imgsys_dev);
+struct mtk_imgsys_hw_subframe*
+imgsys_working_buf_alloc_helper(struct mtk_imgsys_dev *imgsys_dev);
+
+int mtk_imgsys_can_enqueue(struct mtk_imgsys_dev *imgsys_dev,
+			int unprocessedcnt);
+void mtk_imgsys_desc_map_iova(struct mtk_imgsys_request *req);
+void mtk_imgsys_sd_desc_map_iova(struct mtk_imgsys_request *req);
+
+#ifdef BATCH_MODE_V3
+bool is_batch_mode(struct mtk_imgsys_request *req);
+#endif
+
+void mtk_imgsys_put_dma_buf(struct dma_buf *dma_buf,
+				struct dma_buf_attachment *attach,
+				struct sg_table *sgt);
+void mtk_imgsys_mod_get(struct mtk_imgsys_dev *imgsys_dev);
+void mtk_imgsys_mod_put(struct mtk_imgsys_dev *imgsys_dev);
+
+/***************************************************************************/
+void flush_fd_kva_list(struct mtk_imgsys_dev *imgsys_dev);
+/*
+ * macro define for list usage
+ */
+#define DECLARE_VLIST(type) \
+struct type ## _list { \
+	struct type node; \
+	struct list_head link; \
+}
+
+/*
+ * vlist_node_of - get the pointer to the node which has specific vlist
+ * @ptr:    the pointer to struct list_head
+ * @type:   the type of list node
+ */
+#define vlist_node_of(ptr, type) ({ \
+	const struct list_head *mptr = (ptr); \
+	(type *)((char *)mptr - offsetof(type ## _list, link)); })
+
+/*
+ * vlist_link - get the pointer to struct list_head
+ * @ptr:    the pointer to struct vlist
+ * @type:   the type of list node
+ */
+#define vlist_link(ptr, type) \
+	((struct list_head *)((char *)ptr + offsetof(type ## _list, link)))
+
+/*
+ * vlist_type - get the type of struct vlist
+ * @type:   the type of list node
+ */
+#define vlist_type(type) type ## _list
+
+/*
+ * vlist_node - get the pointer to the node of vlist
+ * @ptr:    the pointer to struct vlist
+ * @type:   the type of list node
+ */
+#define vlist_node(ptr, type) ((type *) ptr)
+
+struct timeval {
+	__kernel_old_time_t	tv_sec;		/* seconds */
+	__kernel_suseconds_t	tv_usec;	/* microseconds */
+};
+
+struct swfrm_info_t {
+	uint32_t req_sbuf_goft;
+	void *req_sbuf_kva;
+	int swfrminfo_ridx;
+	int request_fd;
+	int request_no;
+	int frame_no;
+	uint64_t frm_owner;
+	uint8_t is_secReq;
+	int fps;
+	int cb_frmcnt;
+	int total_taskcnt;
+	int exp_totalcb_cnt;
+	int handle;
+	uint64_t req_vaddr;
+	int sync_id;
+	int total_frmnum;
+	struct img_swfrm_info user_info[TIME_MAX];
+	uint8_t is_earlycb;
+	int earlycb_sidx;
+	uint8_t is_lastfrm;
+	int8_t group_id;
+	int8_t batchnum;
+	int8_t is_sent;	/*check the frame is sent to gce or not*/
+	void *req;		/*mtk_dip_request*/
+	void *pipe;
+	uint32_t fail_uinfo_idx;
+	int8_t fail_isHWhang;
+	struct timeval eqtime;
+	int chan_id;
+	char *hw_ts_log;
+};
+#define HWTOKEN_MAX 100
+struct cleartoken_info_t {
+	int clearnum;
+	int token[HWTOKEN_MAX];
+};
+
+#define REQ_FD_MAX 65536
+struct reqfd_cbinfo_t {
+	int req_fd;
+	int exp_cnt;
+	int cur_cnt;
+};
+DECLARE_VLIST(reqfd_cbinfo_t);
+struct reqfd_cbinfo_list_t {
+	struct mutex mymutex;
+	struct list_head mylist;
+};
+
+struct info_list_t {
+	struct mutex mymutex;
+	/* pthread_cond_t cond; */
+	struct list_head configed_list;
+	struct list_head fail_list;
+};
+
+DECLARE_VLIST(swfrm_info_t);
+
+struct buf_va_info_t {
+	int buf_fd;
+	unsigned long kva;
+	void *dma_buf_putkva;
+	struct dma_buf_attachment *attach;
+	struct sg_table *sgt;
+	dma_addr_t dma_addr;
+};
+
+struct fd_kva_list_t {
+	struct mutex mymutex;
+	struct list_head mylist;
+};
+DECLARE_VLIST(buf_va_info_t);
+#endif /* _MTK_DIP_DEV_H_ */
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/imgsys/mtk_imgsys-hw.h b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/mtk_imgsys-hw.h
new file mode 100644
index 0000000000000000000000000000000000000000..7c47917970afa1e71c655379ad5d93058e5fb669
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/mtk_imgsys-hw.h
@@ -0,0 +1,177 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2021 MediaTek Inc.
+ *
+ * Author: Frederic Chen <frederic.chen@mediatek.com>
+ *         Holmes Chiou <holmes.chiou@mediatek.com>
+ *
+ */
+
+#ifndef _MTK_DIP_HW_H_
+#define _MTK_DIP_HW_H_
+
+#include <linux/clk.h>
+#include "mtk-img-ipi.h"
+#include "mtkdip.h"
+
+#define MTK_MDP_SUPPORT			(1)
+
+#define DIP_COMPOSING_MAX_NUM		8
+
+#define MTK_DIP_CLK_NUM			2
+
+#define SUPPORT_SINGLE_DEVICE_MODE
+
+
+#define DIP_SUB_FRM_SZ		0 //(68*1024) /*  tdri:64k + tpipe_cfg:4k  */
+/*  isp register:48k + cq_descriptor:4k  */
+#define DIP_TUNING_SZ		0 //(52*1024)
+#define DIP_COMP_SZ		0 //((sizeof(struct img_config) + 1024) & ~1024)
+#define DIP_FRAMEPARAM_SZ \
+			((sizeof(struct img_ipi_frameparam) + 1024) & ~1024)
+#define DIP_FRM_SZ (DIP_SUB_FRM_SZ+DIP_TUNING_SZ+DIP_COMP_SZ+DIP_FRAMEPARAM_SZ)
+
+
+#define DIP_TUNING_OFFSET		DIP_SUB_FRM_SZ
+#define DIP_COMP_OFFSET			(DIP_TUNING_OFFSET + DIP_TUNING_SZ)
+#define DIP_FRAMEPARAM_OFFSET		(DIP_COMP_OFFSET + DIP_COMP_SZ)
+#define DIP_SUB_FRM_DATA_NUM		24
+#define DIP_SCP_WORKINGBUF_OFFSET	(5 * 1024 * 1024)
+#define DIP_V4l2_META_BUF_OFFSET	(DIP_SCP_WORKINGBUF_OFFSET + \
+					 DIP_SUB_FRM_DATA_NUM * DIP_FRM_SZ)
+
+#ifdef MDP_COLOR
+/*
+ * MDP native color code
+ * Plane count: 1, 2, 3
+ * H-subsample: 0, 1, 2
+ * V-subsample: 0, 1
+ * Color group: 0-RGB, 1-YUV, 2-raw
+ */
+#define DIP_MDP_COLOR(PACKED, LOOSE, VIDEO, PLANE, HF, VF, BITS, GROUP, SWAP, \
+	ID) \
+	(((PACKED) << 27) | ((LOOSE) << 26) | ((VIDEO) << 23) |\
+	((PLANE) << 21) | ((HF) << 19) | ((VF) << 18) | ((BITS) << 8) |\
+	((GROUP) << 6) | ((SWAP) << 5) | ((ID) << 0))
+
+#define DIP_MCOLOR_IS_BLOCK_MODE(c)	((0x00800000 & (c)) >> 23)
+#define DIP_MCOLOR_GET_PLANE_COUNT(c)	((0x00600000 & (c)) >> 21)
+#define DIP_MCOLOR_GET_H_SUBSAMPLE(c)	((0x00180000 & (c)) >> 19)
+#define DIP_MCOLOR_GET_V_SUBSAMPLE(c)	((0x00040000 & (c)) >> 18)
+#define DIP_MCOLOR_BITS_PER_PIXEL(c)	((0x0003ff00 & (c)) >>  8)
+#define DIP_MCOLOR_GET_GROUP(c)		((0x000000c0 & (c)) >>  6)
+#define DIP_MCOLOR_IS_RGB(c)		(DIP_MCOLOR_GET_GROUP(c) == 0)
+#define DIP_MCOLOR_IS_YUV(c)		(DIP_MCOLOR_GET_GROUP(c) == 1)
+#define DIP_MCOLOR_IS_UV_COPLANE(c)	((DIP_MCOLOR_GET_PLANE_COUNT(c) == \
+					  2) && \
+					 DIP_MCOLOR_IS_YUV(c))
+
+enum DIP_MDP_COLOR {
+	DIP_MCOLOR_UNKNOWN	= 0,
+
+	DIP_MCOLOR_FULLG8_RGGB = DIP_MDP_COLOR(0, 0, 0, 1, 0, 0, 8, 2, 0, 21),
+	DIP_MCOLOR_FULLG8_GRBG = DIP_MDP_COLOR(0, 0, 0, 1, 0, 1, 8, 2, 0, 21),
+	DIP_MCOLOR_FULLG8_GBRG = DIP_MDP_COLOR(0, 0, 0, 1, 1, 0, 8, 2, 0, 21),
+	DIP_MCOLOR_FULLG8_BGGR = DIP_MDP_COLOR(0, 0, 0, 1, 1, 1, 8, 2, 0, 21),
+	DIP_MCOLOR_FULLG8      = DIP_MCOLOR_FULLG8_BGGR,
+
+	DIP_MCOLOR_FULLG10_RGGB = DIP_MDP_COLOR(0, 0, 0, 1, 0, 0, 10, 2, 0, 21),
+	DIP_MCOLOR_FULLG10_GRBG = DIP_MDP_COLOR(0, 0, 0, 1, 0, 1, 10, 2, 0, 21),
+	DIP_MCOLOR_FULLG10_GBRG = DIP_MDP_COLOR(0, 0, 0, 1, 1, 0, 10, 2, 0, 21),
+	DIP_MCOLOR_FULLG10_BGGR = DIP_MDP_COLOR(0, 0, 0, 1, 1, 1, 10, 2, 0, 21),
+	DIP_MCOLOR_FULLG10	= DIP_MCOLOR_FULLG10_BGGR,
+
+	DIP_MCOLOR_FULLG12_RGGB = DIP_MDP_COLOR(0, 0, 0, 1, 0, 0, 12, 2, 0, 21),
+	DIP_MCOLOR_FULLG12_GRBG = DIP_MDP_COLOR(0, 0, 0, 1, 0, 1, 12, 2, 0, 21),
+	DIP_MCOLOR_FULLG12_GBRG = DIP_MDP_COLOR(0, 0, 0, 1, 1, 0, 12, 2, 0, 21),
+	DIP_MCOLOR_FULLG12_BGGR = DIP_MDP_COLOR(0, 0, 0, 1, 1, 1, 12, 2, 0, 21),
+	DIP_MCOLOR_FULLG12	= DIP_MCOLOR_FULLG12_BGGR,
+
+	DIP_MCOLOR_FULLG14_RGGB = DIP_MDP_COLOR(0, 0, 0, 1, 0, 0, 14, 2, 0, 21),
+	DIP_MCOLOR_FULLG14_GRBG = DIP_MDP_COLOR(0, 0, 0, 1, 0, 1, 14, 2, 0, 21),
+	DIP_MCOLOR_FULLG14_GBRG = DIP_MDP_COLOR(0, 0, 0, 1, 1, 0, 14, 2, 0, 21),
+	DIP_MCOLOR_FULLG14_BGGR = DIP_MDP_COLOR(0, 0, 0, 1, 1, 1, 14, 2, 0, 21),
+	DIP_MCOLOR_FULLG14	= DIP_MCOLOR_FULLG14_BGGR,
+
+	DIP_MCOLOR_BAYER8_RGGB  = DIP_MDP_COLOR(0, 0, 0, 1, 0, 0, 8, 2, 0, 20),
+	DIP_MCOLOR_BAYER8_GRBG  = DIP_MDP_COLOR(0, 0, 0, 1, 0, 1, 8, 2, 0, 20),
+	DIP_MCOLOR_BAYER8_GBRG  = DIP_MDP_COLOR(0, 0, 0, 1, 1, 0, 8, 2, 0, 20),
+	DIP_MCOLOR_BAYER8_BGGR  = DIP_MDP_COLOR(0, 0, 0, 1, 1, 1, 8, 2, 0, 20),
+	DIP_MCOLOR_BAYER8	= DIP_MCOLOR_BAYER8_BGGR,
+
+	DIP_MCOLOR_BAYER10_RGGB = DIP_MDP_COLOR(0, 0, 0, 1, 0, 0, 10, 2, 0, 20),
+	DIP_MCOLOR_BAYER10_GRBG = DIP_MDP_COLOR(0, 0, 0, 1, 0, 1, 10, 2, 0, 20),
+	DIP_MCOLOR_BAYER10_GBRG = DIP_MDP_COLOR(0, 0, 0, 1, 1, 0, 10, 2, 0, 20),
+	DIP_MCOLOR_BAYER10_BGGR = DIP_MDP_COLOR(0, 0, 0, 1, 1, 1, 10, 2, 0, 20),
+	DIP_MCOLOR_BAYER10	= DIP_MCOLOR_BAYER10_BGGR,
+
+	DIP_MCOLOR_BAYER12_RGGB = DIP_MDP_COLOR(0, 0, 0, 1, 0, 0, 12, 2, 0, 20),
+	DIP_MCOLOR_BAYER12_GRBG = DIP_MDP_COLOR(0, 0, 0, 1, 0, 1, 12, 2, 0, 20),
+	DIP_MCOLOR_BAYER12_GBRG = DIP_MDP_COLOR(0, 0, 0, 1, 1, 0, 12, 2, 0, 20),
+	DIP_MCOLOR_BAYER12_BGGR = DIP_MDP_COLOR(0, 0, 0, 1, 1, 1, 12, 2, 0, 20),
+	DIP_MCOLOR_BAYER12	= DIP_MCOLOR_BAYER12_BGGR,
+
+	DIP_MCOLOR_BAYER14_RGGB = DIP_MDP_COLOR(0, 0, 0, 1, 0, 0, 14, 2, 0, 20),
+	DIP_MCOLOR_BAYER14_GRBG = DIP_MDP_COLOR(0, 0, 0, 1, 0, 1, 14, 2, 0, 20),
+	DIP_MCOLOR_BAYER14_GBRG = DIP_MDP_COLOR(0, 0, 0, 1, 1, 0, 14, 2, 0, 20),
+	DIP_MCOLOR_BAYER14_BGGR = DIP_MDP_COLOR(0, 0, 0, 1, 1, 1, 14, 2, 0, 20),
+	DIP_MCOLOR_BAYER14	= DIP_MCOLOR_BAYER14_BGGR,
+
+	DIP_MCOLOR_UYVY		= DIP_MDP_COLOR(0, 0, 0, 1, 1, 0, 16, 1, 0, 4),
+	DIP_MCOLOR_VYUY		= DIP_MDP_COLOR(0, 0, 0, 1, 1, 0, 16, 1, 1, 4),
+	DIP_MCOLOR_YUYV		= DIP_MDP_COLOR(0, 0, 0, 1, 1, 0, 16, 1, 0, 5),
+	DIP_MCOLOR_YVYU		= DIP_MDP_COLOR(0, 0, 0, 1, 1, 0, 16, 1, 1, 5),
+
+	DIP_MCOLOR_I420		= DIP_MDP_COLOR(0, 0, 0, 3, 1, 1,  8, 1, 0, 8),
+	DIP_MCOLOR_YV12		= DIP_MDP_COLOR(0, 0, 0, 3, 1, 1,  8, 1, 1, 8),
+
+	DIP_MCOLOR_NV12		= DIP_MDP_COLOR(0, 0, 0, 2, 1, 1,  8, 1, 0, 12),
+};
+#endif
+
+#define FRAME_STATE_INIT		0
+#define FRAME_STATE_HW_TIMEOUT		1
+
+enum STREAM_TYPE_ENUM {
+	STREAM_UNKNOWN,
+	STREAM_BITBLT,
+	STREAM_GPU_BITBLT,
+	STREAM_DUAL_BITBLT,
+	STREAM_2ND_BITBLT,
+	STREAM_ISP_IC,
+	STREAM_ISP_VR,
+	STREAM_ISP_ZSD,
+	STREAM_ISP_IP,
+	STREAM_ISP_VSS,
+	STREAM_ISP_ZSD_SLOW,
+	STREAM_WPE,
+	STREAM_WPE2,
+};
+
+struct mtk_imgsys_hw_working_buf {
+	dma_addr_t scp_daddr;
+	void *vaddr;
+	dma_addr_t isp_daddr;
+};
+
+struct mtk_imgsys_hw_subframe {
+	struct mtk_imgsys_hw_working_buf buffer;
+	int size;
+	struct mtk_imgsys_hw_working_buf config_data;
+	struct mtk_imgsys_hw_working_buf tuning_buf;
+	struct mtk_imgsys_hw_working_buf frameparam;
+	struct list_head list_entry;
+};
+
+struct mtk_imgsys_hw_working_buf_list {
+	struct list_head list;
+	u32 cnt;
+	spinlock_t lock; /* protect the list and cnt */
+};
+
+struct mtk_imgsys_init_array {
+	unsigned int    ofset;
+	unsigned int    val;
+};
+#endif /* _MTK_DIP_HW_H_ */
+
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/imgsys/mtk_imgsys-module.h b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/mtk_imgsys-module.h
new file mode 100644
index 0000000000000000000000000000000000000000..d627d9b7f028d93b76f0b04fe28e70c45f352820
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/mtk_imgsys-module.h
@@ -0,0 +1,22 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2021 MediaTek Inc.
+ *
+ * Author: Frederic Chen <frederic.chen@mediatek.com>
+ *
+ */
+
+#ifndef _MTK_IMGSYS_MODULES_H_
+#define _MTK_IMGSYS_MODULES_H_
+
+struct mtk_imgsys_dev;
+
+struct module_ops {
+	int module_id;
+	void (*init)(struct mtk_imgsys_dev *imgsys_dev);
+	void (*set)(struct mtk_imgsys_dev *imgsys_dev);
+	void (*dump)(struct mtk_imgsys_dev *imgsys_dev, unsigned int engine);
+	void (*uninit)(struct mtk_imgsys_dev *imgsys_dev);
+};
+
+#endif /* _MTK_IMGSYS_MODULES_H_ */
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/imgsys/mtk_imgsys-of.c b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/mtk_imgsys-of.c
new file mode 100644
index 0000000000000000000000000000000000000000..6ee4673689dea8eefeea28aa60f768f361016908
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/mtk_imgsys-of.c
@@ -0,0 +1,42 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2021 MediaTek Inc.
+ *
+ * Author: Frederic Chen <frederic.chen@mediatek.com>
+ *         Holmes Chiou <holmes.chiou@mediatek.com>
+ *
+ */
+
+#include "mtk_imgsys-of.h"
+
+static void merge_module_pipelines(
+		const struct mtk_imgsys_pipe_desc *imgsys_pipe,
+		const struct cust_data *data)
+{
+	const struct mtk_imgsys_mod_pipe_desc *module_pipe;
+	unsigned int mod_num;
+	unsigned int i, j, k;
+
+	mod_num = data->mod_num;
+	k = 0;
+	for (i = 0; i < mod_num; i++) {
+		module_pipe = &data->module_pipes[i];
+		for (j = 0; j < module_pipe->node_num; j++) {
+			imgsys_pipe->queue_descs[k] =
+					module_pipe->vnode_desc[j];
+			k++;
+		}
+	}
+
+}
+
+void init_imgsys_pipeline(const struct cust_data *data)
+{
+	const struct mtk_imgsys_pipe_desc *imgsys_pipe;
+	unsigned int i;
+
+	for (i = 0; i < data->pipe_num; i++) {
+		imgsys_pipe = &data->pipe_settings[i];
+		merge_module_pipelines(imgsys_pipe, data);
+	}
+}
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/imgsys/mtk_imgsys-of.h b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/mtk_imgsys-of.h
new file mode 100644
index 0000000000000000000000000000000000000000..211d411528a255b50294ad6fcf41d92216b3e77d
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/mtk_imgsys-of.h
@@ -0,0 +1,37 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2021 MediaTek Inc.
+ *
+ * Author: Frederic Chen <frederic.chen@mediatek.com>
+ *         Holmes Chiou <holmes.chiou@mediatek.com>
+ *
+ */
+
+#ifndef _MTK_IMGSYS_OF_H_
+#define _MTK_IMGSYS_OF_H_
+
+#include <linux/clk.h>
+#include "mtk_imgsys-dev.h"
+#include "mtk_imgsys-module.h"
+
+
+struct mtk_imgsys_mod_pipe_desc {
+	const struct mtk_imgsys_video_device_desc *vnode_desc;
+	unsigned int node_num;
+};
+
+struct cust_data {
+	struct clk_bulk_data *clks;
+	unsigned int clk_num;
+	const struct mtk_imgsys_mod_pipe_desc *module_pipes;
+	unsigned int mod_num;
+	const struct mtk_imgsys_pipe_desc *pipe_settings;
+	unsigned int pipe_num;
+	const struct module_ops *imgsys_modules;
+	debug_dump dump;
+};
+
+void init_imgsys_pipeline(const struct cust_data *data);
+
+#endif /* _MTK_IMGSYS_OF_H_ */
+
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/imgsys/mtk_imgsys-sys.c b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/mtk_imgsys-sys.c
new file mode 100755
index 0000000000000000000000000000000000000000..afa1fb23d2d9434c13a287dc90a080a8fd098793
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/mtk_imgsys-sys.c
@@ -0,0 +1,2324 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2021 MediaTek Inc.
+ *
+ * Author: Frederic Chen <frederic.chen@mediatek.com>
+ *         Holmes Chiou <holmes.chiou@mediatek.com>
+ *
+ */
+
+#include <linux/device.h>
+#include <dma-iommu.h>
+#include <linux/freezer.h>
+#include <linux/pm_runtime.h>
+#include <linux/remoteproc.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+#include <linux/wait.h>
+#include <linux/hashtable.h>
+#include <media/v4l2-event.h>
+#include "mtk_imgsys-dev.h"
+#include "mtk_imgsys-hw.h"
+#include "mtk-hcp.h"
+#include "mtk_imgsys-sys.h"
+#include "mtk_imgsys-cmdq.h"
+#include "mtk_imgsys-module.h"
+#include "mtk_imgsys-trace.h"
+
+#if MTK_CM4_SUPPORT
+#include <linux/remoteproc/mtk_scp.h>
+#endif
+
+int imgsys_quick_onoff_en;
+module_param(imgsys_quick_onoff_en, int, 0644);
+
+
+static struct gce_timeout_work imgsys_timeout_winfo[VIDEO_MAX_FRAME];
+static int imgsys_timeout_idx;
+static struct info_list_t frm_info_list = {
+	.mymutex = __MUTEX_INITIALIZER(frm_info_list.mymutex),
+	.configed_list = LIST_HEAD_INIT(frm_info_list.configed_list),
+	.fail_list = LIST_HEAD_INIT(frm_info_list.fail_list)
+};
+static struct reqfd_cbinfo_list_t reqfd_cbinfo_list = {
+	.mymutex = __MUTEX_INITIALIZER(reqfd_cbinfo_list.mymutex),
+	.mylist = LIST_HEAD_INIT(reqfd_cbinfo_list.mylist)
+};
+DECLARE_WAIT_QUEUE_HEAD(frm_info_waitq);
+static inline bool info_list_is_empty(struct info_list_t *info_list)
+{
+	bool is_empty = true;
+
+	mutex_lock(&(info_list->mymutex));
+	if ((!list_empty(&info_list->configed_list)) ||
+		(!list_empty(&info_list->fail_list)))
+		is_empty = false;
+	mutex_unlock(&(info_list->mymutex));
+	return is_empty;
+};
+
+static int imgsys_send(struct platform_device *pdev, enum hcp_id id,
+		    void *buf, unsigned int  len, int req_fd, unsigned int wait)
+{
+	int ret;
+#if MTK_CM4_SUPPORT
+	ret = scp_ipi_send(imgsys_dev->scp_pdev, SCP_IPI_DIP, &ipi_param,
+			   sizeof(ipi_param), 0);
+#else
+	if (wait)
+		ret = mtk_hcp_send(pdev, id, buf, len, req_fd);
+	else
+		ret = mtk_hcp_send_async(pdev, id, buf, len, req_fd);
+#endif
+	return ret;
+}
+
+static void imgsys_init_handler(void *data, unsigned int len, void *priv)
+{
+	pr_info("imgsys_init_handler");
+}
+
+static int mtk_imgsys_hw_working_buf_pool_reinit(struct mtk_imgsys_dev *imgsys_dev)
+{
+	int i;
+
+	spin_lock(&imgsys_dev->imgsys_usedbufferlist.lock);
+	INIT_LIST_HEAD(&imgsys_dev->imgsys_usedbufferlist.list);
+	imgsys_dev->imgsys_usedbufferlist.cnt = 0;
+	spin_unlock(&imgsys_dev->imgsys_usedbufferlist.lock);
+
+	spin_lock(&imgsys_dev->imgsys_freebufferlist.lock);
+	INIT_LIST_HEAD(&imgsys_dev->imgsys_freebufferlist.list);
+	imgsys_dev->imgsys_freebufferlist.cnt = 0;
+
+	for (i = 0; i < DIP_SUB_FRM_DATA_NUM; i++) {
+		struct mtk_imgsys_hw_subframe *buf =
+						&imgsys_dev->working_buf[i];
+
+		list_add_tail(&buf->list_entry,
+			      &imgsys_dev->imgsys_freebufferlist.list);
+		imgsys_dev->imgsys_freebufferlist.cnt++;
+	}
+	spin_unlock(&imgsys_dev->imgsys_freebufferlist.lock);
+
+
+	dev_dbg(imgsys_dev->dev, "%s", __func__);
+
+	return 0;
+}
+
+int mtk_imgsys_hw_working_buf_pool_init(struct mtk_imgsys_dev *imgsys_dev)
+{
+	int i;
+	const int working_buf_size = round_up(DIP_FRM_SZ, PAGE_SIZE);
+#if MTK_CM4_SUPPORT
+	phys_addr_t working_buf_paddr;
+#endif
+	const u32 scp_workingbuf_offset = 0;
+
+	INIT_LIST_HEAD(&imgsys_dev->imgsys_freebufferlist.list);
+	spin_lock_init(&imgsys_dev->imgsys_freebufferlist.lock);
+	imgsys_dev->imgsys_freebufferlist.cnt = 0;
+
+	INIT_LIST_HEAD(&imgsys_dev->imgsys_usedbufferlist.list);
+	spin_lock_init(&imgsys_dev->imgsys_usedbufferlist.lock);
+	imgsys_dev->imgsys_usedbufferlist.cnt = 0;
+
+#if MTK_CM4_SUPPORT
+	scp_workingbuf_offset = DIP_SCP_WORKINGBUF_OFFSET;
+	imgsys_dev->working_buf_mem_size = DIP_SUB_FRM_DATA_NUM *
+		working_buf_size + DIP_SCP_WORKINGBUF_OFFSET;
+	imgsys_dev->working_buf_mem_vaddr =
+		dma_alloc_coherent(&imgsys_dev->scp_pdev->dev,
+				   imgsys_dev->working_buf_mem_size,
+				   &imgsys_dev->working_buf_mem_scp_daddr,
+				   GFP_KERNEL);
+	if (!imgsys_dev->working_buf_mem_vaddr) {
+		dev_info(imgsys_dev->dev,
+			"memory alloc size %ld failed\n",
+			imgsys_dev->working_buf_mem_size);
+		return -ENOMEM;
+	}
+
+	/*
+	 * We got the incorrect physical address mapped when
+	 * using dma_map_single() so I used dma_map_page_attrs()
+	 * directly to workaround here.
+	 *
+	 * When I use dma_map_single() to map the address, the
+	 * physical address retrieved back with iommu_get_domain_for_dev()
+	 * and iommu_iova_to_phys() was not equal to the
+	 * SCP dma address (it should be the same as the physical address
+	 * since we don't have iommu), and was shifted by 0x4000000.
+	 */
+	working_buf_paddr = imgsys_dev->working_buf_mem_scp_daddr;
+	imgsys_dev->working_buf_mem_isp_daddr =
+		dma_map_page_attrs(imgsys_dev->dev,
+				   phys_to_page(working_buf_paddr),
+				   0, imgsys_dev->working_buf_mem_size,
+				   DMA_BIDIRECTIONAL,
+				   DMA_ATTR_SKIP_CPU_SYNC);
+	if (dma_mapping_error(imgsys_dev->dev,
+			      imgsys_dev->working_buf_mem_isp_daddr)) {
+		dev_info(imgsys_dev->dev,
+			"failed to map buffer: s_daddr(%pad)\n",
+			&imgsys_dev->working_buf_mem_scp_daddr);
+		dma_free_coherent(&imgsys_dev->scp_pdev->dev,
+				  imgsys_dev->working_buf_mem_size,
+				  imgsys_dev->working_buf_mem_vaddr,
+				  imgsys_dev->working_buf_mem_scp_daddr);
+
+		return -ENOMEM;
+	}
+#else
+	/* TODO: only for header_desc mode; not sigdev */
+#ifdef USE_KERNEL_ION_BUFFER
+	imgsys_dev->working_buf_mem_size =
+				mtk_hcp_get_reserve_mem_size(IMG_MEM_FOR_HW_ID);
+	hcp_allocate_buffer(imgsys_dev->scp_pdev, IMG_MEM_FOR_HW_ID,
+		imgsys_dev->working_buf_mem_size);
+	imgsys_dev->working_buf_mem_scp_daddr =
+				mtk_hcp_get_reserve_mem_phys(IMG_MEM_FOR_HW_ID);
+	imgsys_dev->working_buf_mem_vaddr =
+				mtk_hcp_get_reserve_mem_virt(IMG_MEM_FOR_HW_ID);
+	imgsys_dev->working_buf_mem_isp_daddr =
+				mtk_hcp_get_reserve_mem_dma(IMG_MEM_FOR_HW_ID);
+	if (!imgsys_dev->working_buf_mem_vaddr) {
+		dev_info(imgsys_dev->dev,
+			"(hcp)memory alloc size %ld failed\n",
+			imgsys_dev->working_buf_mem_size);
+		return -ENOMEM;
+	}
+#endif
+	// working_buf_paddr = imgsys_dev->working_buf_mem_scp_daddr;
+#endif
+	dev_dbg(imgsys_dev->dev,
+		"%s: working_buf_mem: vaddr(%p), scp_daddr(%p)\n",
+		__func__,
+		imgsys_dev->working_buf_mem_vaddr,
+		&imgsys_dev->working_buf_mem_scp_daddr);
+
+	pr_info("%s: working buffer size 0x%lx, pool size should be 0x%lx\n",
+		__func__, DIP_FRM_SZ, (DIP_FRM_SZ * DIP_SUB_FRM_DATA_NUM));
+	for (i = 0; i < DIP_SUB_FRM_DATA_NUM; i++) {
+		struct mtk_imgsys_hw_subframe *buf =
+						&imgsys_dev->working_buf[i];
+
+		/*
+		 * Total: 0 ~ 72 KB
+		 * SubFrame: 0 ~ 16 KB
+		 */
+		buf->buffer.scp_daddr = imgsys_dev->working_buf_mem_scp_daddr +
+			scp_workingbuf_offset + i * working_buf_size;
+		buf->buffer.vaddr = imgsys_dev->working_buf_mem_vaddr +
+			scp_workingbuf_offset + i * working_buf_size;
+		buf->buffer.isp_daddr = imgsys_dev->working_buf_mem_isp_daddr +
+			scp_workingbuf_offset + i * working_buf_size;
+		buf->size = working_buf_size;
+
+		dev_dbg(imgsys_dev->dev,
+			"%s: buf(%d), scp_daddr(%pad), isp_daddr(%pad)\n",
+			__func__, i, &buf->buffer.scp_daddr,
+			&buf->buffer.isp_daddr);
+
+		/* Tuning: 16 ~ 48 KB */
+		buf->tuning_buf.scp_daddr =
+			buf->buffer.scp_daddr + DIP_TUNING_OFFSET;
+		buf->tuning_buf.vaddr =
+			buf->buffer.vaddr + DIP_TUNING_OFFSET;
+		buf->tuning_buf.isp_daddr =
+			buf->buffer.isp_daddr + DIP_TUNING_OFFSET;
+
+		dev_dbg(imgsys_dev->dev,
+			"%s: tuning_buf(%d), scp_daddr(%pad), isp_daddr(%pad)\n",
+			__func__, i, &buf->tuning_buf.scp_daddr,
+			&buf->tuning_buf.isp_daddr);
+
+		/* Config_data: 48 ~ 72 KB */
+		buf->config_data.scp_daddr =
+			buf->buffer.scp_daddr + DIP_COMP_OFFSET;
+		buf->config_data.vaddr = buf->buffer.vaddr + DIP_COMP_OFFSET;
+
+		dev_dbg(imgsys_dev->dev,
+			"%s: config_data(%d), scp_daddr(%pad), vaddr(%p)\n",
+			__func__, i, &buf->config_data.scp_daddr,
+			buf->config_data.vaddr);
+
+		/* Frame parameters: 72 ~ 76 KB */
+		buf->frameparam.scp_daddr =
+			buf->buffer.scp_daddr + DIP_FRAMEPARAM_OFFSET;
+		buf->frameparam.vaddr =
+			buf->buffer.vaddr + DIP_FRAMEPARAM_OFFSET;
+
+		pr_debug("DIP_FRAMEPARAM_SZ:%ld",
+			sizeof(struct img_ipi_frameparam));
+		dev_dbg(imgsys_dev->dev,
+			"%s: frameparam(%d), scp_daddr(%p), vaddr(%p)\n",
+			__func__, i, &buf->frameparam.scp_daddr,
+			buf->frameparam.vaddr);
+
+		list_add_tail(&buf->list_entry,
+			      &imgsys_dev->imgsys_freebufferlist.list);
+		imgsys_dev->imgsys_freebufferlist.cnt++;
+	}
+
+	return 0;
+}
+
+void mtk_imgsys_hw_working_buf_pool_release(struct mtk_imgsys_dev *imgsys_dev)
+{
+	/* All the buffer should be in the freebufferlist when release */
+	if (imgsys_dev->imgsys_usedbufferlist.cnt)
+		dev_info(imgsys_dev->dev,
+			 "%s: imgsys_usedbufferlist is not empty (%d)\n",
+			__func__, imgsys_dev->imgsys_usedbufferlist.cnt);
+
+#if MTK_CM4_SUPPORT
+	dma_unmap_page_attrs(imgsys_dev->dev,
+			     imgsys_dev->working_buf_mem_isp_daddr,
+			     imgsys_dev->working_buf_mem_size,
+				DMA_BIDIRECTIONAL, DMA_ATTR_SKIP_CPU_SYNC);
+
+	dma_free_coherent(&imgsys_dev->scp_pdev->dev,
+			  imgsys_dev->working_buf_mem_size,
+			  imgsys_dev->working_buf_mem_vaddr,
+			  imgsys_dev->working_buf_mem_scp_daddr);
+#else
+	/* TODO: ontly for header_desc mode */
+#ifdef USE_KERNEL_ION_BUFFER
+	hcp_free_buffer(imgsys_dev->scp_pdev, IMG_MEM_FOR_HW_ID);
+#endif
+#endif
+}
+
+static void mtk_imgsys_hw_working_buf_free(struct mtk_imgsys_dev *imgsys_dev,
+				struct mtk_imgsys_hw_subframe *working_buf,
+					bool error_free)
+{
+	if (!working_buf)
+		return;
+
+	spin_lock(&imgsys_dev->imgsys_usedbufferlist.lock);
+	list_del(&working_buf->list_entry);
+			imgsys_dev->imgsys_usedbufferlist.cnt--;
+	dev_dbg(imgsys_dev->dev,
+		"%s: Free used buffer(%pad)\n",
+		__func__, &working_buf->buffer.scp_daddr);
+	spin_unlock(&imgsys_dev->imgsys_usedbufferlist.lock);
+
+	spin_lock(&imgsys_dev->imgsys_freebufferlist.lock);
+	list_add_tail(&working_buf->list_entry,
+		      &imgsys_dev->imgsys_freebufferlist.list);
+	imgsys_dev->imgsys_freebufferlist.cnt++;
+	spin_unlock(&imgsys_dev->imgsys_freebufferlist.lock);
+
+}
+
+static struct mtk_imgsys_hw_subframe*
+mtk_imgsys_hw_working_buf_alloc(struct mtk_imgsys_dev *imgsys_dev)
+{
+	struct mtk_imgsys_hw_subframe *working_buf;
+
+	spin_lock(&imgsys_dev->imgsys_freebufferlist.lock);
+	if (list_empty(&imgsys_dev->imgsys_freebufferlist.list)) {
+		spin_unlock(&imgsys_dev->imgsys_freebufferlist.lock);
+		return NULL;
+	}
+
+	working_buf = list_first_entry(&imgsys_dev->imgsys_freebufferlist.list,
+				       struct mtk_imgsys_hw_subframe,
+					list_entry);
+	list_del(&working_buf->list_entry);
+	imgsys_dev->imgsys_freebufferlist.cnt--;
+	spin_unlock(&imgsys_dev->imgsys_freebufferlist.lock);
+
+	spin_lock(&imgsys_dev->imgsys_usedbufferlist.lock);
+	list_add_tail(&working_buf->list_entry,
+		      &imgsys_dev->imgsys_usedbufferlist.list);
+	imgsys_dev->imgsys_usedbufferlist.cnt++;
+	spin_unlock(&imgsys_dev->imgsys_usedbufferlist.lock);
+
+	return working_buf;
+}
+
+static void mtk_imgsys_iova_map_tbl_unmap(struct mtk_imgsys_request *req)
+{
+	struct mtk_imgsys_dev *imgsys_dev = req->imgsys_pipe->imgsys_dev;
+	struct mtk_imgsys_dev_buffer *dev_buf;
+	struct mtk_imgsys_dma_buf_iova_get_info *dmabufiovainfo, *temp;
+	int i = 0;
+
+	for (i = 0; i < req->imgsys_pipe->desc->total_queues; i++) {
+		dev_buf = req->buf_map[i];
+		if (dev_buf) {
+			list_for_each_entry_safe(dmabufiovainfo, temp,
+				&dev_buf->iova_map_table.list, list_entry) {
+				dev_dbg(imgsys_dev->dev,
+					"%s:list put(deleted) ionFd(%d)-dma_addr:%llx\n",
+					__func__,
+					dmabufiovainfo->ionfd,
+					dmabufiovainfo->dma_addr);
+				//put dmabuf(iova)
+				mtk_imgsys_put_dma_buf(dmabufiovainfo->dma_buf,
+						dmabufiovainfo->attach,
+						dmabufiovainfo->sgt);
+				//free dmabuf
+				spin_lock(&dev_buf->iova_map_table.lock);
+				list_del(&dmabufiovainfo->list_entry);
+				vfree(dmabufiovainfo);
+				spin_unlock(&dev_buf->iova_map_table.lock);
+			}
+		}
+	}
+}
+
+static void mtk_imgsys_iova_map_tbl_unmap_sd(struct mtk_imgsys_request *req)
+{
+	struct mtk_imgsys_dev *imgsys_dev = req->imgsys_pipe->imgsys_dev;
+	struct mtk_imgsys_dev_buffer *dev_buf;
+	struct mtk_imgsys_dma_buf_iova_get_info *dmabufiovainfo, *temp;
+	int b;
+
+	b = is_singledev_mode(req);
+	dev_buf = req->buf_map[b];
+	if (dev_buf) {
+		list_for_each_entry_safe(dmabufiovainfo, temp,
+			&dev_buf->iova_map_table.list, list_entry) {
+			dev_dbg(imgsys_dev->dev,
+				"%s:list put(deleted) ionFd(%d)-dma_addr:%llx\n",
+				__func__,
+				dmabufiovainfo->ionfd,
+				dmabufiovainfo->dma_addr);
+			//put dmabuf(iova)
+			mtk_imgsys_put_dma_buf(dmabufiovainfo->dma_buf,
+					dmabufiovainfo->attach,
+					dmabufiovainfo->sgt);
+			//free dmabuf
+			spin_lock(&dev_buf->iova_map_table.lock);
+			list_del(&dmabufiovainfo->list_entry);
+			spin_unlock(&dev_buf->iova_map_table.lock);
+			vfree(dmabufiovainfo);
+		}
+	}
+}
+
+#if MTK_MDP_SUPPORT /*CHRISTBD: open this after integrating flow with gce com */
+#ifdef BATCH_MODE_V3
+// V3 batch mode added {
+static void mtk_imgsys_notify_batch(struct mtk_imgsys_request *req)
+{
+	struct mtk_imgsys_dev *imgsys_dev = req->imgsys_pipe->imgsys_dev;
+	struct mtk_imgsys_hw_subframe *working_buf;
+
+	if (!is_batch_mode(req)) {
+		dev_info(imgsys_dev->dev, "%s:batch mode not batch mode\n",
+			__func__);
+		return;
+	}
+
+	if (list_empty(&req->mdp_done_list.list)) {
+		dev_info(imgsys_dev->dev,
+			"%s:mdp_done_list is empty:%d\n",
+			__func__, req->mdp_done_list.cnt);
+		return;
+	}
+	spin_lock(&req->mdp_done_list.lock);
+	working_buf = list_first_entry(&req->mdp_done_list.list,
+					   struct mtk_imgsys_hw_subframe,
+					   list_entry);
+	if (IS_ERR(working_buf)) {
+		dev_info(imgsys_dev->dev,
+			"%s:fail to find buffer in list\n", __func__);
+		return;
+	}
+
+	/**
+	 * Free the finished frame's working buffer,
+	 * delete it from mdp_done_list in imgsys_request,
+	 * and add it back to imgsys_usedbufferlist.
+	 * free the working buffer then it'll be removed from that list.
+	 */
+	list_del(&working_buf->list_entry);
+	req->mdp_done_list.cnt--;
+	spin_unlock(&req->mdp_done_list.lock);
+
+	spin_lock(&imgsys_dev->imgsys_usedbufferlist.lock);
+	list_add_tail(&working_buf->list_entry,
+			  &imgsys_dev->imgsys_usedbufferlist.list);
+	imgsys_dev->imgsys_usedbufferlist.cnt++;
+	spin_unlock(&imgsys_dev->imgsys_usedbufferlist.lock);
+
+	mtk_imgsys_hw_working_buf_free(imgsys_dev, working_buf, false);
+
+	/* Return if there are unprocessed frames*/
+	if (--req->unprocessed_count != 0)
+		return;
+
+	/** Here means the complete of the request job,
+	 *  so we can suspend the HW.
+	 */
+	pm_runtime_mark_last_busy(imgsys_dev->dev);
+	pm_runtime_put_autosuspend(imgsys_dev->dev);
+
+	/*
+	 * The job may be aleady removed by streamoff, so we need to check
+	 * it by id here.
+	 */
+	if (mtk_imgsys_pipe_get_running_job(req->imgsys_pipe, req->id)) {
+		mtk_imgsys_pipe_remove_job(req);
+		mtk_imgsys_pipe_job_finish(req, VB2_BUF_STATE_DONE);
+		wake_up(&imgsys_dev->flushing_waitq);
+	}
+}
+// } V3 batch mode added
+#endif
+
+static void mtk_imgsys_early_notify(struct mtk_imgsys_request *req,
+						struct imgsys_event_status *ev)
+{
+	struct mtk_imgsys_dev *imgsys_dev = req->imgsys_pipe->imgsys_dev;
+	struct mtk_imgsys_pipe *pipe = req->imgsys_pipe;
+	struct req_frameparam *iparam = &req->img_fparam.frameparam;
+	struct v4l2_event event;
+	struct imgsys_event_status *status = (void *)event.u.data;
+	u32 index = iparam->index;
+	u32 frame_no = iparam->frame_no;
+
+	memset(&event, 0, sizeof(event));
+
+	IMGSYS_SYSTRACE_BEGIN("ReqFd:%d subfrm_idx:%d\n", req->tstate.req_fd,
+							ev->frame_number);
+
+	event.type = V4L2_EVENT_FRAME_SYNC;
+	status->req_fd = ev->req_fd;
+	status->frame_number = ev->frame_number;
+	v4l2_event_queue(pipe->subdev.devnode, &event);
+
+	dev_dbg(imgsys_dev->dev,
+		"%s:%s: job id(%d), frame_no(%d), early_no(%d:%d), finished\n",
+		__func__, pipe->desc->name, index, frame_no, ev->req_fd,
+							ev->frame_number);
+	IMGSYS_SYSTRACE_END();
+
+}
+
+static void mtk_imgsys_notify(struct mtk_imgsys_request *req, uint64_t frm_owner)
+{
+	struct mtk_imgsys_dev *imgsys_dev = req->imgsys_pipe->imgsys_dev;
+	struct mtk_imgsys_pipe *pipe = req->imgsys_pipe;
+	struct req_frameparam *iparam = &req->img_fparam.frameparam;
+	enum vb2_buffer_state vbf_state;
+	u32 index = iparam->index;
+	u32 frame_no = iparam->frame_no;
+	u64 req_enq, req_done, imgenq;
+
+	IMGSYS_SYSTRACE_BEGIN("ReqFd:%d Own:%s\n", req->tstate.req_fd, ((char *)&frm_owner));
+
+	req->tstate.time_notifyStart = ktime_get_boottime_ns()/1000;
+
+	if (!pipe->streaming)
+		goto notify;
+
+	if (is_singledev_mode(req))
+		mtk_imgsys_iova_map_tbl_unmap_sd(req);
+	else if (is_desc_mode(req))
+		mtk_imgsys_iova_map_tbl_unmap(req);
+
+notify:
+	if (iparam->state != FRAME_STATE_HW_TIMEOUT)
+		vbf_state = VB2_BUF_STATE_DONE;
+	else
+		vbf_state = VB2_BUF_STATE_ERROR;
+	/*
+	 * The job may be aleady removed by streamoff, so I need to check
+	 * it by id here with mtk_imgsys_pipe_get_running_job()
+	 */
+	atomic_dec(&imgsys_dev->num_composing);
+
+	mtk_imgsys_hw_working_buf_free(imgsys_dev, req->working_buf,
+								false);
+	req->working_buf = NULL;
+	/*  vb2 bufer done in below function  */
+	if (vbf_state == VB2_BUF_STATE_DONE)
+		mtk_imgsys_pipe_job_finish(req, vbf_state);
+	mtk_imgsys_pipe_remove_job(req);
+
+	req->tstate.time_unmapiovaEnd = ktime_get_boottime_ns()/1000;
+	dev_dbg(imgsys_dev->dev,
+			"[K]%s:%d:%s:%6lld %6lld %6lld %6lld %6lld %6lld %6lld %6lld %6lld %6lld %6lld %6lld %6lld %6lld %6lld %6lld %6lld\n",
+			__func__, req->tstate.req_fd, ((char *)(&frm_owner)),
+			(req->tstate.time_qreq-req->tstate.time_qbuf),
+			(req->tstate.time_composingEnd-req->tstate.time_composingStart),
+			(req->tstate.time_iovaworkp-req->tstate.time_composingEnd),
+			(req->tstate.time_qw2composer-req->tstate.time_iovaworkp),
+			(req->tstate.time_compfuncStart-req->tstate.time_qw2composer),
+			(req->tstate.time_ipisendStart-req->tstate.time_compfuncStart),
+			(req->tstate.time_reddonescpStart-req->tstate.time_ipisendStart),
+			(req->tstate.time_qw2runner-req->tstate.time_reddonescpStart),
+			(req->tstate.time_send2cmq-req->tstate.time_qw2runner),
+			(req->tstate.time_sendtask),
+			(req->tstate.time_mdpcbStart-req->tstate.time_send2cmq),
+			(req->tstate.time_notifyStart-req->tstate.time_mdpcbStart),
+			(req->tstate.time_unmapiovaEnd-req->tstate.time_notifyStart),
+			(req->tstate.time_unmapiovaEnd-req->tstate.time_notify2vb2done),
+			(req->tstate.time_notify2vb2done-req->tstate.time_composingStart),
+			(req->tstate.time_notify2vb2done-req->tstate.time_reddonescpStart),
+			(req->tstate.time_ipisendStart-req->tstate.time_composingStart)
+			);
+
+	wake_up(&imgsys_dev->flushing_waitq);
+	dev_dbg(imgsys_dev->dev,
+		"%s:%s:(reqfd-%d) job id(%d), frame_no(%d) finished\n",
+		__func__, pipe->desc->name, req->tstate.req_fd, index, frame_no);
+
+	IMGSYS_SYSTRACE_END();
+	imgenq = req->tstate.time_qreq - req->tstate.time_qbuf;
+	req_enq = req->tstate.time_send2cmq - req->tstate.time_reddonescpStart;
+	req_done = req->tstate.time_notify2vb2done - req->tstate.time_reddonescpStart;
+	IMGSYS_SYSTRACE_BEGIN("ReqFd:%d Own:%s imgenq:%lld tskdlr2gce:%lld tskhdlr2done:%lld\n",
+		req->tstate.req_fd, ((char *)&frm_owner), imgenq, req_enq, req_done);
+	IMGSYS_SYSTRACE_END();
+	media_request_put(&req->req);
+}
+
+static void cmdq_cb_timeout_worker(struct work_struct *work)
+{
+	struct mtk_imgsys_pipe *pipe;
+	struct mtk_imgsys_request *req = mtk_imgsys_hw_timeout_work_to_req(work);
+	// struct img_ipi_param ipi_param;
+	struct swfrm_info_t *frm_info = NULL;
+	struct gce_timeout_work *swork = NULL;
+	struct img_sw_buffer swbuf_data = {0};
+
+	swork = container_of(work, struct gce_timeout_work, work);
+	pipe = (struct mtk_imgsys_pipe *)swork->pipe;
+	if (!pipe->streaming) {
+		pr_info("%s pipe already streamoff\n", __func__);
+		goto release_req;
+	}
+
+	if (!req) {
+		pr_info("%s NULL request Address\n", __func__);
+		goto release_work;
+	}
+
+	frm_info = (struct swfrm_info_t *)(swork->req_sbuf_kva);
+
+	if (frm_info) {
+		frm_info->fail_uinfo_idx = swork->fail_uinfo_idx;
+		frm_info->fail_isHWhang = swork->fail_isHWhang;
+		dev_info(req->imgsys_pipe->imgsys_dev->dev,
+			"%s:%s:req fd/no(%d/%d)frame_no(%d) tfnum(%d) fail idx/sidx(%d/%d) timeout_w(%d)\n",
+			__func__, (char *)(&(frm_info->frm_owner)), frm_info->request_fd,
+			frm_info->request_no,
+			frm_info->frame_no,
+			frm_info->total_frmnum,
+			frm_info->fail_uinfo_idx,
+			frm_info->user_info[frm_info->fail_uinfo_idx].subfrm_idx,
+			frm_info->fail_isHWhang);
+		/* DAEMON debug dump */
+		// ipi_param.usage = IMG_IPI_DEBUG;
+		swbuf_data.offset  = frm_info->req_sbuf_goft;
+
+		if (swork->fail_isHWhang) {
+			imgsys_send(req->imgsys_pipe->imgsys_dev->scp_pdev,
+					HCP_IMGSYS_HW_TIMEOUT_ID,
+					&swbuf_data,
+					sizeof(struct img_sw_buffer),
+					frm_info->request_fd, 1);
+		} else {
+			imgsys_queue_timeout(&(req->imgsys_pipe->imgsys_dev->runnerque));
+
+			imgsys_send(req->imgsys_pipe->imgsys_dev->scp_pdev,
+					HCP_IMGSYS_SW_TIMEOUT_ID,
+					&swbuf_data,
+					sizeof(struct img_sw_buffer),
+					frm_info->request_fd, 1);
+		}
+		wake_up_interruptible(&frm_info_waitq);
+	}
+release_req:
+	media_request_put(&req->req);
+
+release_work:
+	mtk_hcp_put_gce_buffer(req->imgsys_pipe->imgsys_dev->scp_pdev);
+	/*vfree(swork);*/
+	pr_debug("%s leave\n", __func__);
+}
+
+static void imgsys_cmdq_timeout_cb_func(struct imgsys_cb_data data,
+						unsigned int fail_subfidx, bool isHWhang)
+{
+	struct mtk_imgsys_pipe *pipe;
+	struct mtk_imgsys_request *req;
+	struct mtk_imgsys_dev *imgsys_dev;
+	struct swfrm_info_t *frm_info_cb;
+	const struct module_ops *imgsys_modules;
+	struct gce_timeout_work *swork = NULL;
+
+	if (!data.data) {
+		pr_info("%s: data->data is NULL\n",
+		       __func__);
+		return;
+	}
+
+	frm_info_cb = data.data;
+	pipe = (struct mtk_imgsys_pipe *)frm_info_cb->pipe;
+	if (!pipe->streaming) {
+		pr_info("%s pipe already streamoff\n", __func__);
+
+		return;
+	}
+
+	req = (struct mtk_imgsys_request *)(frm_info_cb->req);
+	if (!req) {
+		pr_info("%s NULL request Address\n", __func__);
+		return;
+	}
+	imgsys_dev = req->imgsys_pipe->imgsys_dev;
+	mtk_hcp_get_gce_buffer(imgsys_dev->scp_pdev);
+	/*frm_info_cb->fail_uinfo_idx = fail_subfidx;*/
+	dev_info(imgsys_dev->dev,
+		"%s:%s:req fd/no(%d/%d) frmNo(%d) tfnum(%d)sidx/fidx/hw(%d/%d_%d/0x%x)timeout(%d/%d) dump cb +",
+		__func__, (char *)(&(frm_info_cb->frm_owner)), frm_info_cb->request_fd,
+		frm_info_cb->request_no,
+		frm_info_cb->frame_no,
+		frm_info_cb->total_frmnum,
+		frm_info_cb->swfrminfo_ridx,
+		fail_subfidx,
+		frm_info_cb->user_info[fail_subfidx].subfrm_idx,
+		frm_info_cb->user_info[fail_subfidx].hw_comb, isHWhang,
+		imgsys_timeout_idx);
+
+	/* DUMP DL CHECKSUM & HW REGISTERS*/
+	if (imgsys_dev->dump && isHWhang) {
+		imgsys_modules = req->imgsys_pipe->imgsys_dev->modules;
+		imgsys_dev->dump(imgsys_dev, imgsys_modules,
+		req->imgsys_pipe->imgsys_dev->num_mods,
+		frm_info_cb->user_info[fail_subfidx].hw_comb);
+	}
+
+
+	/*swork = vzalloc(sizeof(struct gce_timeout_work));*/
+	media_request_get(&req->req);
+	swork = &(imgsys_timeout_winfo[imgsys_timeout_idx]);
+	swork->req = req;
+	swork->req_sbuf_kva = frm_info_cb->req_sbuf_kva;
+	swork->pipe = frm_info_cb->pipe;
+	swork->fail_uinfo_idx = fail_subfidx;
+	swork->fail_isHWhang = isHWhang;
+	INIT_WORK(&swork->work, cmdq_cb_timeout_worker);
+	queue_work(req->imgsys_pipe->imgsys_dev->mdpcb_wq,
+		&swork->work);
+	imgsys_timeout_idx = (imgsys_timeout_idx + 1) % VIDEO_MAX_FRAME;
+
+	dev_info(imgsys_dev->dev,
+		"%s:%s:req fd/no(%d/%d) frmNo(%d) tfnum(%d)sidx/fidx/hw(%d/%d_%d/0x%x)timeout(%d/%d) dump cb -",
+		__func__, (char *)(&(frm_info_cb->frm_owner)), frm_info_cb->request_fd,
+		frm_info_cb->request_no,
+		frm_info_cb->frame_no,
+		frm_info_cb->total_frmnum,
+		frm_info_cb->swfrminfo_ridx,
+		fail_subfidx,
+		frm_info_cb->user_info[fail_subfidx].subfrm_idx,
+		frm_info_cb->user_info[fail_subfidx].hw_comb, isHWhang,
+		imgsys_timeout_idx);
+}
+
+static void cmdq_cb_done_worker(struct work_struct *work)
+{
+	struct mtk_imgsys_pipe *pipe;
+	struct swfrm_info_t *gwfrm_info = NULL;
+	struct gce_cb_work *gwork = NULL;
+	struct img_sw_buffer swbuf_data;
+
+	gwork = container_of(work, struct gce_cb_work, work);
+
+	pipe = (struct mtk_imgsys_pipe *)gwork->pipe;
+	if (!pipe->streaming) {
+		pr_info("%s pipe already streamoff\n", __func__);
+		goto release_work;
+	}
+
+	/* send to HCP after frame done & del node from list */
+	gwfrm_info = (struct swfrm_info_t *)gwork->req_sbuf_kva;
+	swbuf_data.offset = gwfrm_info->req_sbuf_goft;
+	imgsys_send(pipe->imgsys_dev->scp_pdev, HCP_IMGSYS_DEQUE_DONE_ID,
+		&swbuf_data, sizeof(struct img_sw_buffer),
+		gwork->reqfd, 0);
+
+	wake_up_interruptible(&frm_info_waitq);
+
+release_work:
+	return;
+}
+
+/* Maybe in IRQ context of cmdq */
+static void imgsys_mdp_cb_func(struct imgsys_cb_data data,
+					unsigned int subfidx, bool isLastTaskInReq)
+{
+	struct mtk_imgsys_pipe *pipe;
+	struct mtk_imgsys_request *req;
+	struct mtk_imgsys_dev *imgsys_dev;
+	//struct swfrm_info_t *frm_info_cb;
+	struct swfrm_info_t *swfrminfo_cb;
+	struct imgsys_event_status ev;
+	struct gce_cb_work gwork;
+	bool need_notify_daemon = false;
+	bool lastfrmInMWReq = false;
+	bool lastin_errcase = false;
+	struct reqfd_cbinfo_t *reqfdcb_info = NULL;
+	struct list_head *head = NULL;
+	struct list_head *temp = NULL;
+	bool can_notify_imgsys = false;
+	bool reqfd_record_find = false;
+	int exp_cnt = 0;
+	int cur_cnt = 0;
+
+	if (!data.data) {
+		pr_info("%s: data->data is NULL\n",
+		       __func__);
+		return;
+	}
+
+	swfrminfo_cb = data.data;
+	pipe = (struct mtk_imgsys_pipe *)swfrminfo_cb->pipe;
+	if (!pipe->streaming)
+		pr_info("%s pipe already streamoff\n", __func__);
+
+	req = (struct mtk_imgsys_request *)(swfrminfo_cb->req);
+	if (!req) {
+		pr_info("%s NULL request Address\n", __func__);
+		return;
+	}
+
+	IMGSYS_SYSTRACE_BEGIN("ReqFd:%d Own:%s\n", req->tstate.req_fd,
+							((char *)&swfrminfo_cb->frm_owner));
+
+	imgsys_dev = req->imgsys_pipe->imgsys_dev;
+	req->tstate.time_mdpcbStart = ktime_get_boottime_ns()/1000;
+	dev_dbg(imgsys_dev->dev, "%s:(reqfd-%d)frame_no(%d) +", __func__,
+		req->tstate.req_fd,
+		req->img_fparam.frameparam.frame_no);
+
+
+#if MTK_CM4_SUPPORT == 0
+	#ifdef BATCH_MODE_V3
+	// V3 batch mode added {
+	if (is_batch_mode(req)) {
+		struct mtk_imgsys_hw_subframe *working_buf;
+		struct img_ipi_frameparam *frame;
+
+		dev_dbg(imgsys_dev->dev, "%s:req(%p)", __func__, req);
+		working_buf = list_first_entry(&req->runner_done_list,
+					       struct mtk_imgsys_hw_subframe,
+					       list_entry);
+
+		spin_lock(&req->runner_done_list.lock);
+		working_buf = list_first_entry(&req->runner_done_list.list,
+					       struct mtk_imgsys_hw_subframe,
+					       list_entry);
+
+		if (IS_ERR(working_buf)) {
+			dev_info(imgsys_dev->dev,
+				"fail to get working buffer:%p\n", working_buf);
+			return;
+		}
+
+		if (list_empty(&req->runner_done_list.list)) {
+			dev_info(imgsys_dev->dev, "%s:list is empty!\n",
+								__func__);
+			return;
+		}
+
+		spin_lock(&req->runner_done_list.lock);
+		working_buf = list_first_entry(&req->runner_done_list.list,
+					       struct mtk_imgsys_hw_subframe,
+					       list_entry);
+
+		if (IS_ERR(working_buf)) {
+			dev_info(imgsys_dev->dev,
+				"fail to get working buffer:%p\n", working_buf);
+			return;
+		}
+
+		list_del(&working_buf->list_entry);
+		req->runner_done_list.cnt--;
+		spin_unlock(&req->runner_done_list.lock);
+
+		spin_lock(&req->mdp_done_list.lock);
+		list_add_tail(&working_buf->list_entry,
+				  &req->mdp_done_list.list);
+		req->mdp_done_list.cnt++;
+		spin_unlock(&req->mdp_done_list.lock);
+
+		frame = (struct img_ipi_frameparam *)
+						working_buf->frameparam.vaddr;
+		dev_dbg(imgsys_dev->dev,
+			 "%s: req(%p), idx(%d), no(%d), n_in(%d), n_out(%d)\n",
+			 __func__,
+			 req,
+			 frame->index,
+			 frame->frame_no,
+			 frame->num_inputs,
+			 frame->num_outputs);
+
+		if (data.sta != CMDQ_CB_NORMAL) {
+			dev_info(imgsys_dev->dev, "%s: frame no(%d) HW timeout\n",
+				__func__, req->img_fparam.frameparam.frame_no);
+			req->img_fparam.frameparam.state =
+							FRAME_STATE_HW_TIMEOUT;
+			mtk_imgsys_notify_batch(req);
+		} else {
+			mtk_imgsys_notify_batch(req);
+		}
+		return;
+	}
+	// } V3 batch mode added
+	#endif
+#endif
+	dev_dbg(imgsys_dev->dev, "%s: req(%p), idx(%d), no(%d), s(%d), n_in(%d), n_out(%d)\n",
+		__func__,
+		req,
+		req->img_fparam.frameparam.index,
+		req->img_fparam.frameparam.frame_no,
+		req->img_fparam.frameparam.state,
+		req->img_fparam.frameparam.num_inputs,
+		req->img_fparam.frameparam.num_outputs);
+
+	/*check gce cb cnt*/
+	mutex_lock(&(reqfd_cbinfo_list.mymutex));
+	list_for_each_safe(head, temp, &(reqfd_cbinfo_list.mylist)) {
+		reqfdcb_info = vlist_node_of(head, struct reqfd_cbinfo_t);
+		if (reqfdcb_info->req_fd == swfrminfo_cb->request_fd) {
+			reqfdcb_info->cur_cnt += 1;
+			exp_cnt = reqfdcb_info->exp_cnt;
+			cur_cnt = reqfdcb_info->cur_cnt;
+			if (reqfdcb_info->cur_cnt == reqfdcb_info->exp_cnt) {
+				can_notify_imgsys = true;
+				list_del(head);
+				vfree(reqfdcb_info);
+			}
+			reqfd_record_find = true;
+		}
+	}
+	mutex_unlock(&(reqfd_cbinfo_list.mymutex));
+	if (!reqfd_record_find) {
+		dev_info(imgsys_dev->dev,
+			"%s:%s:req fd/no(%d/%d)frame no(%d)no record, kva(0x%lx)group ID/L(%d/%d)e_cb(idx_%d:%d)tfrm(%d) cb/lst(%d/%d)->%d/%d\n",
+			__func__, (char *)(&(swfrminfo_cb->frm_owner)), swfrminfo_cb->request_fd,
+			swfrminfo_cb->request_no,
+			swfrminfo_cb->frame_no,
+			(unsigned long)swfrminfo_cb,
+			swfrminfo_cb->group_id,
+			swfrminfo_cb->user_info[subfidx].is_lastingroup,
+			subfidx,
+			swfrminfo_cb->user_info[subfidx].is_earlycb,
+			swfrminfo_cb->total_frmnum,
+			swfrminfo_cb->is_earlycb,
+			swfrminfo_cb->is_lastfrm,
+			isLastTaskInReq, lastfrmInMWReq);
+	}
+	/**/
+	if (swfrminfo_cb->fail_isHWhang >= 0) {
+		req->img_fparam.frameparam.state = FRAME_STATE_HW_TIMEOUT;
+		if (swfrminfo_cb->group_id >= 0) {
+			if (isLastTaskInReq) {
+				if (swfrminfo_cb->is_lastfrm)
+					lastfrmInMWReq = true;
+				lastin_errcase = true;
+			}
+
+			dev_info(imgsys_dev->dev,
+			"%s:%s:req fd/no(%d/%d)frame no(%d)timeout, kva(0x%lx)group ID/L(%d/%d)e_cb(idx_%d:%d)tfrm(%d) cb/lst(%d/%d)->%d/%d,%d(%d/%d)\n",
+			__func__, (char *)(&(swfrminfo_cb->frm_owner)), swfrminfo_cb->request_fd,
+			swfrminfo_cb->request_no,
+			swfrminfo_cb->frame_no,
+			(unsigned long)swfrminfo_cb,
+			swfrminfo_cb->group_id,
+			swfrminfo_cb->user_info[subfidx].is_lastingroup,
+			subfidx,
+			swfrminfo_cb->user_info[subfidx].is_earlycb,
+			swfrminfo_cb->total_frmnum,
+			swfrminfo_cb->is_earlycb,
+			swfrminfo_cb->is_lastfrm,
+			isLastTaskInReq, lastfrmInMWReq, can_notify_imgsys,
+			cur_cnt, exp_cnt);
+		} else {
+			if (swfrminfo_cb->is_lastfrm) {
+				lastfrmInMWReq = true;
+				can_notify_imgsys = true;
+			}
+
+			dev_info(imgsys_dev->dev,
+			"%s:%s:req fd/no(%d/%d)frame no(%d) timeout, kva(0x%lx)lst(%d)e_cb(%d)sidx(%d)tfrm(%d) -> %d,%d(%d/%d)\n",
+			__func__, (char *)(&(swfrminfo_cb->frm_owner)), swfrminfo_cb->request_fd,
+			swfrminfo_cb->request_no,
+			swfrminfo_cb->frame_no,
+			(unsigned long)swfrminfo_cb,
+			swfrminfo_cb->is_lastfrm,
+			swfrminfo_cb->is_earlycb,
+			swfrminfo_cb->user_info[0].subfrm_idx,
+			swfrminfo_cb->total_frmnum,
+			lastfrmInMWReq, can_notify_imgsys,
+			cur_cnt, exp_cnt);
+
+			/*early cb or last frame for non-grouping case*/
+			lastin_errcase = true;
+		}
+
+		if (pipe->streaming && can_notify_imgsys/*lastfrmInMWReq*/)
+			mtk_imgsys_notify(req, swfrminfo_cb->frm_owner);
+
+		if (lastin_errcase)
+			mtk_hcp_put_gce_buffer(imgsys_dev->scp_pdev);
+	} else {
+		if (swfrminfo_cb->is_lastfrm || swfrminfo_cb->is_earlycb ||
+			isLastTaskInReq)
+			dev_dbg(imgsys_dev->dev,
+			"%s:%s:req fd/no(%d/%d)frame no(%d)done, kva(0x%lx)lst(%d)e_cb(%d/%d)sidx(%d)tfrm(%d)\n",
+			__func__, (char *)(&(swfrminfo_cb->frm_owner)), swfrminfo_cb->request_fd,
+			swfrminfo_cb->request_no,
+			swfrminfo_cb->frame_no,
+			(unsigned long)swfrminfo_cb,
+			swfrminfo_cb->is_lastfrm,
+			swfrminfo_cb->is_earlycb,
+			swfrminfo_cb->earlycb_sidx,
+			swfrminfo_cb->user_info[0].subfrm_idx,
+			swfrminfo_cb->total_frmnum);
+		if (swfrminfo_cb->group_id >= 0) {
+			dev_dbg(imgsys_dev->dev,
+			"%s:%s:req fd/no(%d/%d)frame no(%d)done, kva(0x%lx)group ID/L(%d/%d)e_cb(idx_%d:%d)tfrm(%d) cb/lst(%d/%d):%d,%d(%d/%d)\n",
+			__func__, (char *)(&(swfrminfo_cb->frm_owner)), swfrminfo_cb->request_fd,
+			swfrminfo_cb->request_no,
+			swfrminfo_cb->frame_no,
+			(unsigned long)swfrminfo_cb,
+			swfrminfo_cb->group_id,
+			swfrminfo_cb->user_info[subfidx].is_lastingroup,
+			subfidx,
+			swfrminfo_cb->user_info[subfidx].is_earlycb,
+			swfrminfo_cb->total_frmnum,
+			swfrminfo_cb->is_earlycb,
+			swfrminfo_cb->is_lastfrm,
+			isLastTaskInReq, can_notify_imgsys,
+			cur_cnt, exp_cnt);
+
+			if (swfrminfo_cb->user_info[subfidx].is_earlycb) {
+				ev.req_fd = swfrminfo_cb->request_fd;
+				ev.frame_number = swfrminfo_cb->user_info[subfidx].subfrm_idx;
+				mtk_imgsys_early_notify(req, &ev);
+			}
+
+			if (isLastTaskInReq) {
+				need_notify_daemon = true;
+				if (swfrminfo_cb->is_lastfrm)
+					lastfrmInMWReq = true;
+			}
+		} else {
+			/* call early notify if need early callback */
+			if (swfrminfo_cb->is_earlycb) {
+				ev.req_fd = swfrminfo_cb->request_fd;
+				ev.frame_number = swfrminfo_cb->earlycb_sidx;
+				mtk_imgsys_early_notify(req, &ev);
+			}
+			if (swfrminfo_cb->is_lastfrm) {
+				lastfrmInMWReq = true;
+				can_notify_imgsys = true;
+			}
+			need_notify_daemon = true;
+		}
+		dev_dbg(imgsys_dev->dev,
+			"%s:%s:req fd/no(%d/%d)frame no(%d)done, kva(0x%lx)lastfrmInMWReq:%d\n",
+			__func__, (char *)(&(swfrminfo_cb->frm_owner)), swfrminfo_cb->request_fd,
+			swfrminfo_cb->request_no,
+			swfrminfo_cb->frame_no,
+			(unsigned long)swfrminfo_cb, lastfrmInMWReq);
+		/* call dip notify when all package done */
+		if (pipe->streaming && can_notify_imgsys/*lastfrmInMWReq*/)
+			mtk_imgsys_notify(req, swfrminfo_cb->frm_owner);
+
+		if (need_notify_daemon) {
+			gwork.reqfd = swfrminfo_cb->request_fd;
+			//memcpy((void *)(&(gwork->user_info)), (void *)(&(frm_info_cb->user_info)),
+			//	sizeof(struct img_swfrm_info));
+			gwork.req_sbuf_kva = swfrminfo_cb->req_sbuf_kva;
+			gwork.pipe = swfrminfo_cb->pipe;
+			cmdq_cb_done_worker(&gwork.work);
+			/*grouping, paired with scp_handler*/
+			mtk_hcp_put_gce_buffer(imgsys_dev->scp_pdev);
+		}
+	}
+
+	IMGSYS_SYSTRACE_END();
+
+}
+#else
+
+#ifdef BATCH_MODE_V3
+// V3 batch mode added {
+static void dip_fake_mdp_cb_func(struct cmdq_cb_data data)
+{
+	struct mtk_imgsys_request *req;
+	struct mtk_imgsys_dev *imgsys_dev;
+	struct mtk_imgsys_hw_subframe *working_buf;
+	struct img_ipi_frameparam *frame;
+
+	if (!data.data) {
+		pr_info("%s: data->data is NULL\n",
+		       __func__);
+		return;
+	}
+
+	req = data.data;
+	imgsys_dev = req->imgsys_pipe->imgsys_dev;
+	dev_dbg(imgsys_dev->dev, "%s:req(%p)", __func__, req);
+
+	if (list_empty(&req->runner_done_list.list)) {
+		dev_info(imgsys_dev->dev, "%s:list is empty!\n", __func__);
+		return;
+	}
+
+	spin_lock(&req->runner_done_list.lock);
+	working_buf = list_first_entry(&req->runner_done_list.list,
+				       struct mtk_imgsys_hw_subframe,
+				       list_entry);
+
+	if (IS_ERR(working_buf)) {
+		dev_info(imgsys_dev->dev,
+			"fail to get working buffer:%p\n", working_buf);
+		return;
+	}
+
+	list_del(&working_buf->list_entry);
+	req->runner_done_list.cnt--;
+	spin_unlock(&req->runner_done_list.lock);
+
+	spin_lock(&req->mdp_done_list.lock);
+	list_add_tail(&working_buf->list_entry,
+			  &req->mdp_done_list.list);
+	req->mdp_done_list.cnt++;
+	spin_unlock(&req->mdp_done_list.lock);
+
+	frame = (struct img_ipi_frameparam *)working_buf->frameparam.vaddr;
+	dev_dbg(imgsys_dev->dev,
+		 "%s: req(%p), idx(%d), no(%d), s(%d), n_in(%d), n_out(%d)\n",
+		 __func__,
+		 req,
+		 frame->index,
+		 frame->frame_no,
+		 frame->state,
+		 frame->num_inputs,
+		 frame->num_outputs);
+	if (data.sta != CMDQ_CB_NORMAL) {
+		dev_info(imgsys_dev->dev, "%s: frame no(%d) HW timeout\n",
+			__func__, req->img_fparam.frameparam.frame_no);
+		/* Skip some action since this is UT purpose. */
+	} else {
+		mtk_imgsys_notify_batch(req);
+		dev_dbg(imgsys_dev->dev, "%s: -\n", __func__);
+	}
+}
+// } V3 batch mode added
+#endif
+
+/* ToDo: use real mdp3 function */
+static void dip_fake_mdp_cmdq_sendtask(struct mtk_imgsys_request *req)
+{
+	struct mtk_imgsys_dev *imgsys_dev;
+
+	imgsys_dev = req->imgsys_pipe->imgsys_dev;
+
+	#ifdef BATCH_MODE_V3
+	// V3 batch mode added {
+	if (is_batch_mode(req)) {
+		struct cmdq_cb_data data;
+
+		pr_info("fake cmdq sendtask");
+		data.data = req;
+		data.sta = CMDQ_CB_NORMAL;
+		dip_fake_mdp_cb_func(data);
+		return;
+	}
+	// } V3 batch mode added
+	#endif
+
+	dev_dbg(imgsys_dev->dev, "%s: req(%p), idx(%d), no(%d), s(%d), n_in(%d), n_out(%d)\n",
+		__func__,
+		req,
+		req->img_fparam.frameparam.index,
+		req->img_fparam.frameparam.frame_no,
+		req->img_fparam.frameparam.state,
+		req->img_fparam.frameparam.num_inputs,
+		req->img_fparam.frameparam.num_outputs);
+
+	mtk_imgsys_notify(req, 0);
+}
+#endif
+
+#if MTK_CM4_SUPPORT == 0
+#ifdef BATCH_MODE_V3
+static void dip_runner_func_batch(struct work_struct *work)
+{
+	struct mtk_runner_work *runner_work =
+		container_of(work, struct mtk_runner_work, frame_work);
+	struct mtk_imgsys_hw_subframe *working_buf;
+	struct img_ipi_frameparam *frame;
+	struct mtk_imgsys_request *req = runner_work->req;
+	struct mtk_imgsys_dev *imgsys_dev = req->imgsys_pipe->imgsys_dev;
+
+	/*
+	 * Call MDP/GCE API to do HW excecution
+	 * Pass the framejob to MDP driver
+	 */
+	pm_runtime_get_sync(imgsys_dev->dev);
+
+	dev_dbg(imgsys_dev->dev, "%s +", __func__);
+	spin_lock(&req->scp_done_list.lock);
+
+	working_buf = list_first_entry(&req->scp_done_list.list,
+				       struct mtk_imgsys_hw_subframe,
+				       list_entry);
+	if (!working_buf)
+		return;
+
+	dev_dbg(imgsys_dev->dev, "%s ++", __func__);
+
+	list_del(&working_buf->list_entry);
+	req->scp_done_list.cnt--;
+	spin_unlock(&req->scp_done_list.lock);
+
+	spin_lock(&req->runner_done_list.lock);
+	list_add_tail(&working_buf->list_entry,
+			  &req->runner_done_list.list);
+	req->runner_done_list.cnt++;
+	spin_unlock(&req->runner_done_list.lock);
+
+	frame = (struct img_ipi_frameparam *)
+					working_buf->frameparam.vaddr;
+	/* send working buffer address as frame param to mdp */
+	// ToDo: mdp3 porting
+	//mdp_cmdq_sendtask(imgsys_dev->mdp_pdev, config_data,
+	//			(struct img_ipi_frameparam *)
+	//				working_buf->frameparam.vaddr,
+	//			NULL, false,
+	//			imgsys_mdp_cb_func, req);
+	dip_fake_mdp_cmdq_sendtask(req);
+	dev_dbg(imgsys_dev->dev, "%s -", __func__);
+	vfree(work);
+	return;
+
+}
+#endif
+#endif
+
+static int gce_work_pool_init(struct mtk_imgsys_dev *dev)
+{
+	struct gce_work *gwork = NULL;
+	struct work_pool *gwork_pool;
+	signed int i;
+	int ret = 0;
+
+	gwork_pool = &dev->gwork_pool;
+	spin_lock_init(&gwork_pool->lock);
+	INIT_LIST_HEAD(&gwork_pool->free_list);
+	INIT_LIST_HEAD(&gwork_pool->used_list);
+	gwork = vzalloc(sizeof(struct gce_work) * GCE_WORK_NR);
+	if (!gwork)
+		return -ENOMEM;
+
+	gwork_pool->_cookie = (void *)gwork;
+	for (i = 0; i < GCE_WORK_NR; i++) {
+		list_add_tail(&gwork[i].entry, &gwork_pool->free_list);
+		gwork[i].pool = gwork_pool;
+	}
+	atomic_set(&gwork_pool->num, i);
+	init_waitqueue_head(&gwork_pool->waitq);
+	kref_init(&gwork_pool->kref);
+
+	return ret;
+}
+
+static void pool_release(struct kref *kref)
+{
+	struct gce_work *gwork, *g0;
+	struct work_pool *pool = container_of(kref, struct work_pool, kref);
+	struct mtk_imgsys_dev *dev = container_of(pool, struct mtk_imgsys_dev, gwork_pool);
+
+	spin_lock(&pool->lock);
+	list_for_each_entry_safe(gwork, g0, &pool->free_list, entry) {
+		list_del(&gwork->entry);
+		atomic_dec(&pool->num);
+	}
+	list_for_each_entry_safe(gwork, g0, &pool->used_list, entry) {
+		list_del(&gwork->entry);
+		atomic_dec(&pool->num);
+	}
+	spin_unlock(&pool->lock);
+
+	if (pool->_cookie) {
+		vfree(pool->_cookie);
+		pool->_cookie = NULL;
+	}
+
+	if (atomic_read(&pool->num))
+		dev_info(dev->dev, "%s: %d works not freed", __func__,
+					atomic_read(&pool->num));
+
+}
+
+static void gce_work_pool_uninit(struct mtk_imgsys_dev *dev)
+{
+	struct work_pool *pool;
+
+	pool = &dev->gwork_pool;
+	kref_put(&pool->kref, pool_release);
+
+}
+
+static bool work_pool_avail(struct work_pool *pool)
+{
+	bool empty;
+
+	spin_lock(&pool->lock);
+	empty = list_empty(&pool->free_list);
+	spin_unlock(&pool->lock);
+
+	return !empty;
+}
+
+static struct gce_work *get_gce_work(struct mtk_imgsys_dev *dev)
+{
+	struct gce_work *gwork = NULL;
+	struct work_pool *gwork_pool;
+	int ret;
+
+	gwork_pool = &dev->gwork_pool;
+	ret = wait_event_interruptible_timeout(gwork_pool->waitq, work_pool_avail(gwork_pool),
+								msecs_to_jiffies(3000));
+
+	if (!ret) {
+		dev_info(dev->dev, "%s wait for gce pool timeout\n", __func__);
+		return NULL;
+	} else if (-ERESTARTSYS == ret) {
+		dev_info(dev->dev, "%s wait for gce pool interrupted !\n", __func__);
+		return NULL;
+	}
+
+	spin_lock(&gwork_pool->lock);
+	gwork = list_first_entry(&gwork_pool->free_list, struct gce_work, entry);
+	list_del(&gwork->entry);
+	list_add_tail(&gwork->entry, &gwork_pool->used_list);
+	kref_get(&gwork->pool->kref);
+	spin_unlock(&gwork_pool->lock);
+
+	return gwork;
+}
+
+static void put_gce_work(struct gce_work *gwork)
+{
+	struct work_pool *gwork_pool;
+
+	gwork_pool = gwork->pool;
+	spin_lock(&gwork_pool->lock);
+	list_del(&gwork->entry);
+	list_add_tail(&gwork->entry, &gwork_pool->free_list);
+	kref_put(&gwork->pool->kref, pool_release);
+	spin_unlock(&gwork_pool->lock);
+
+}
+
+static void imgsys_runner_func(void *data)
+{
+	struct imgsys_work *iwork = (struct imgsys_work *) data;
+	struct gce_work *work = container_of(iwork, struct gce_work, work);
+	struct mtk_imgsys_request *req = work->req;
+	struct mtk_imgsys_dev *imgsys_dev = req->imgsys_pipe->imgsys_dev;
+	struct swfrm_info_t *frm_info;
+	int stime;
+	int ret;
+
+	req->tstate.time_runnerStart = ktime_get_boottime_ns()/1000;
+	atomic_read(&req->swfrm_cnt);
+	/* get corresponding setting, adopt is_sent to judge different frames
+	 * in same package/mtk_dip_request
+	 */
+	frm_info = (struct swfrm_info_t *)(work->req_sbuf_kva);
+	frm_info->is_sent = true;
+	/*
+	 * Call MDP/GCE API to do HW excecution
+	 * Pass the framejob to MDP driver
+	 */
+	/*call gce communicator api*/
+	if (!frm_info->user_info[0].subfrm_idx)
+		req->tstate.time_send2cmq = ktime_get_boottime_ns()/1000;
+	stime = ktime_get_boottime_ns()/1000;
+	IMGSYS_SYSTRACE_BEGIN("MWFrame:#%d MWReq:#%d ReqFd:%d owner:%s subfrm_idx:%d\n",
+			frm_info->frame_no, frm_info->request_no, req->tstate.req_fd,
+		((char *)&frm_info->frm_owner), frm_info->user_info[0].subfrm_idx);
+
+	mtk_hcp_get_gce_buffer(imgsys_dev->scp_pdev);
+	ret = imgsys_cmdq_sendtask(imgsys_dev, frm_info, imgsys_mdp_cb_func,
+		imgsys_cmdq_timeout_cb_func);
+	IMGSYS_SYSTRACE_END();
+	req->tstate.time_cmqret = ktime_get_boottime_ns()/1000;
+	req->tstate.time_sendtask +=
+		(req->tstate.time_cmqret - stime);
+	dev_dbg(imgsys_dev->dev,
+		"%s:(reqfd-%d) send2GCE tfnum/fidx(%d/%d)\n",
+		__func__, req->tstate.req_fd,
+		frm_info->total_frmnum,
+		frm_info->user_info[0].subfrm_idx);
+	if (ret < 0) {
+		dev_info(imgsys_dev->dev,
+			"%s: imgsys_cmdq_sendtask fail(%d)\n", __func__, ret);
+	}
+	put_gce_work(work);
+	mtk_hcp_put_gce_buffer(imgsys_dev->scp_pdev);
+}
+
+static void imgsys_scp_handler(void *data, unsigned int len, void *priv)
+{
+	int job_id;
+	struct mtk_imgsys_pipe *pipe;
+	int pipe_id;
+	struct mtk_imgsys_request *req;
+	struct mtk_imgsys_dev *imgsys_dev = (struct mtk_imgsys_dev *)priv;
+	struct img_sw_buffer *swbuf_data = NULL;
+	struct swfrm_info_t *swfrm_info = NULL;
+	struct gce_work *gwork;
+	int swfrm_cnt;
+	u64 time_local_reddonescpStart = 0;
+	int i = 0;
+	void *gce_virt = NULL;
+	struct reqfd_cbinfo_t *cb_info = NULL;
+	int total_framenum = 0;
+
+	if (!data) {
+		WARN_ONCE(!data, "%s: failed due to NULL data\n", __func__);
+		return;
+	}
+
+	if (WARN_ONCE(len != sizeof(struct img_sw_buffer),
+		      "%s: len(%d) not match img_sw_buffer\n", __func__, len))
+		return;
+
+	swbuf_data = (struct img_sw_buffer *)data;
+	gce_virt = mtk_hcp_get_gce_mem_virt(imgsys_dev->scp_pdev);
+	swfrm_info = (struct swfrm_info_t *)(gce_virt + (swbuf_data->offset));
+
+	if (!gce_virt) {
+		pr_info("%s: invalid gce_virt(%p)\n",
+			__func__, gce_virt);
+		return;
+	}
+
+	if (((int)(swbuf_data->offset) < 0) ||
+		( swbuf_data->offset > mtk_hcp_get_gce_mem_size(imgsys_dev->scp_pdev))) {
+		pr_info("%s: invalid swbuf_data->offset(%d), max(%llu)\n",
+			__func__, swbuf_data->offset,
+			(u64)mtk_hcp_get_gce_mem_size(imgsys_dev->scp_pdev));
+		return;
+	}
+
+
+	if (!swfrm_info) {
+		pr_info("%s: invalid swfrm_info\n", __func__);
+		return;
+	}
+
+	swfrm_info->req_sbuf_goft = swbuf_data->offset;
+	swfrm_info->req_sbuf_kva = gce_virt + (swbuf_data->offset);
+
+#if MTK_CM4_SUPPORT == 0
+
+	#ifdef BATCH_MODE_V3
+	// V3 batch mode added {
+	if (ipi_param->is_batch_mode) {
+		struct mtk_imgsys_hw_subframe *working_buf, *temp_wbuf;
+		struct mtk_runner_work *runner_work;
+
+		if (ipi_param->req_addr_va) {
+			req =
+			(struct mtk_imgsys_request *)ipi_param->req_addr_va;
+		} else {
+			dev_info(imgsys_dev->dev,
+				"%s: fail to get ipi_param.req_addr_va\n",
+				__func__);
+			return;
+		}
+
+		/* fill the frameparam with the returned one */
+		list_for_each_entry_safe(working_buf, temp_wbuf,
+					 &req->working_buf_list.list,
+					 list_entry) {
+			if (ipi_param->frm_param_offset ==
+				(working_buf->frameparam.scp_daddr -
+				imgsys_dev->working_buf_mem_scp_daddr)) {
+				/**
+				 * make use of the FIFO list, move the hw_buf
+				 * into the scp_done_list, and trigger the
+				 * imgsys_runner_func to handle it.
+				 */
+
+				spin_lock(&req->working_buf_list.lock);
+				list_del(&working_buf->list_entry);
+				req->working_buf_list.cnt--;
+				spin_unlock(&req->working_buf_list.lock);
+
+				spin_lock(&req->scp_done_list.lock);
+				list_add_tail(&working_buf->list_entry,
+					      &req->scp_done_list.list);
+				req->scp_done_list.cnt++;
+				spin_unlock(&req->scp_done_list.lock);
+
+				break;
+			}
+
+			dev_info(imgsys_dev->dev,
+				"%s: Fail to find working buffer, offset: 0x%llx\n",
+				__func__,
+				ipi_param->frm_param_offset);
+			return;
+		}
+
+		frameparam = (struct img_ipi_frameparam *)
+						working_buf->frameparam.vaddr;
+		if (!frameparam->dip_param.next_frame)
+			num = atomic_dec_return(&imgsys_dev->num_composing);
+		up(&imgsys_dev->sem);
+		dev_dbg(imgsys_dev->dev,
+			 "%s: frame_no(%d) back, idx(%d), composing num(%d)\n",
+			 __func__, frameparam->frame_no, frameparam->index,
+			 num);
+		runner_work = vzalloc(sizeof(struct mtk_mdpcb_work));
+		runner_work->req = req;
+		INIT_WORK(&runner_work->frame_work, dip_runner_func_batch);
+		queue_work(imgsys_dev->mdp_wq, &runner_work->frame_work);
+		dev_dbg(imgsys_dev->dev,
+			 "%s return batch_mode(-)\n", __func__);
+		return;
+	}
+	// } V3 batch mode added
+	#endif
+
+#endif
+	time_local_reddonescpStart = ktime_get_boottime_ns()/1000;
+	job_id = swfrm_info->handle;
+	pipe_id = mtk_imgsys_pipe_get_pipe_from_job_id(job_id);
+	pipe = mtk_imgsys_dev_get_pipe(imgsys_dev, pipe_id);
+	if (!pipe) {
+		dev_info(imgsys_dev->dev,
+			 "%s: get invalid img_ipi_frameparam index(%d) from firmware\n",
+			 __func__, job_id);
+		return;
+	}
+
+	req = (struct mtk_imgsys_request *) swfrm_info->req_vaddr;
+	if (!req) {
+		WARN_ONCE(!req, "%s: frame_no(%d) is lost\n", __func__, job_id);
+		return;
+	}
+	IMGSYS_SYSTRACE_BEGIN("MWFrame:#%d MWReq:#%d ReqFd:%d owner:%s subfrm_idx:%d\n",
+			swfrm_info->frame_no, swfrm_info->request_no, req->tstate.req_fd,
+		((char *)&swfrm_info->frm_owner), swfrm_info->user_info[0].subfrm_idx);
+
+	if (!swfrm_info->user_info[0].subfrm_idx)
+		req->tstate.time_reddonescpStart = time_local_reddonescpStart;
+
+	swfrm_cnt = atomic_inc_return(&req->swfrm_cnt);
+	if (swfrm_cnt == 1)
+		dev_dbg(imgsys_dev->dev,
+		"%d:%d:%s: request num(%d)/frame no(%d), request fd(%d) kva(0x%lx) tfnum(%d) sidx(%d)\n",
+		current->pid, current->tgid, __func__, swfrm_info->request_no,
+		swfrm_info->frame_no, swfrm_info->request_fd, (unsigned long)swfrm_info,
+		swfrm_info->total_frmnum, swfrm_info->user_info[0].subfrm_idx);
+
+	up(&imgsys_dev->sem);
+	/* TODO: log only safe to remove */
+	if (!req->working_buf) {
+		dev_dbg(imgsys_dev->dev,
+			"%s: (reqfd-%d) composing\n",
+			__func__, req->tstate.req_fd);
+	}
+
+	req->tstate.time_doframeinfo = ktime_get_boottime_ns()/1000;
+
+	/**/
+	swfrm_info->is_sent = false;
+	swfrm_info->req = (void *)req;
+	swfrm_info->pipe = (void *)pipe;
+	swfrm_info->cb_frmcnt = 0;
+	swfrm_info->total_taskcnt = 0;
+	swfrm_info->chan_id = 0;
+	swfrm_info->fail_isHWhang = -1;
+	total_framenum = swfrm_info->total_frmnum;
+	if (swfrm_info->batchnum > 1) {
+		if ((total_framenum < 0) || (total_framenum > TIME_MAX)) {
+			dev_info(imgsys_dev->dev,
+				"%s:unexpected total_framenum (%d -> %d), batchnum(%d) MAX (%d/%d)\n",
+				__func__, swfrm_info->total_frmnum,
+				total_framenum,
+				swfrm_info->batchnum,
+				TMAX, TIME_MAX);
+			return;
+		}
+	} else {
+		if ((total_framenum < 0) || (total_framenum > TMAX)) {
+			dev_info(imgsys_dev->dev,
+				"%s:unexpected total_framenum (%d -> %d), batchnum(%d) MAX (%d/%d)\n",
+				__func__, swfrm_info->total_frmnum,
+				total_framenum,
+				swfrm_info->batchnum,
+				TMAX, TIME_MAX);
+			return;
+		}
+	}
+	for (i = 0 ; i < swfrm_info->total_frmnum ; i++) {
+		swfrm_info->user_info[i].g_swbuf = gce_virt + (swfrm_info->user_info[i].sw_goft);
+		swfrm_info->user_info[i].bw_swbuf = gce_virt + (swfrm_info->user_info[i].sw_bwoft);
+	}
+
+	/*first group in request*/
+	if (!swfrm_info->user_info[0].subfrm_idx) {
+		req->tstate.time_qw2runner = ktime_get_boottime_ns()/1000;
+		if (swfrm_info->exp_totalcb_cnt > 0) {
+			mutex_lock(&(reqfd_cbinfo_list.mymutex));
+			cb_info = vmalloc(
+				sizeof(vlist_type(struct reqfd_cbinfo_t)));
+			if (!cb_info)
+				return;
+			INIT_LIST_HEAD(vlist_link(cb_info, struct reqfd_cbinfo_t));
+			cb_info->req_fd = swfrm_info->request_fd;
+			cb_info->exp_cnt = swfrm_info->exp_totalcb_cnt;
+			cb_info->cur_cnt = 0;
+			list_add_tail(vlist_link(cb_info, struct reqfd_cbinfo_t),
+				&(reqfd_cbinfo_list.mylist));
+			mutex_unlock(&(reqfd_cbinfo_list.mymutex));
+		}
+	}
+
+	gwork = get_gce_work(imgsys_dev);
+	if (!gwork) {
+		dev_info(imgsys_dev->dev,
+		"%s:own(%llx/%s)req fd/no(%d/%d) frame no(%d) group_id(%d): fidx/tfnum(%d/%d) No GceWork max(%d).\n",
+		__func__, swfrm_info->frm_owner, ((char *)&swfrm_info->frm_owner),
+		swfrm_info->request_fd, swfrm_info->request_no, swfrm_info->frame_no,
+		swfrm_info->group_id,
+		swfrm_info->user_info[0].subfrm_idx, swfrm_info->total_frmnum,
+		GCE_WORK_NR);
+		return;
+	}
+	mtk_hcp_get_gce_buffer(imgsys_dev->scp_pdev);
+	gwork->req = req;
+	gwork->req_sbuf_kva = (void *)swfrm_info;
+	gwork->work.run = imgsys_runner_func;
+	imgsys_queue_add(&imgsys_dev->runnerque, &gwork->work);
+	IMGSYS_SYSTRACE_END();
+
+}
+
+static void imgsys_cleartoken_handler(void *data, unsigned int len, void *priv)
+{
+	struct mtk_imgsys_dev *imgsys_dev = (struct mtk_imgsys_dev *)priv;
+	struct img_sw_buffer *swbuf_data = NULL;
+	struct cleartoken_info_t *cleartoken_info = NULL;
+#if CMDQ_EXT
+	int i = 0;
+#endif
+	void *gce_virt = NULL;
+
+	if (!data) {
+		WARN_ONCE(!data, "%s: failed due to NULL data\n", __func__);
+		return;
+	}
+
+	if (WARN_ONCE(len != sizeof(struct img_sw_buffer),
+		      "%s: len(%d) not match img_sw_buffer\n", __func__, len))
+		return;
+
+	swbuf_data = (struct img_sw_buffer *)data;
+	gce_virt = mtk_hcp_get_gce_mem_virt(imgsys_dev->scp_pdev);
+	cleartoken_info = (struct cleartoken_info_t *)(gce_virt + (swbuf_data->offset));
+
+	if (!cleartoken_info) {
+		pr_info("%s: invalid swfrm_info\n", __func__);
+		return;
+	}
+#if CMDQ_EXT
+	for (i = 0 ; i < cleartoken_info->clearnum ; i++) {
+		dev_info(imgsys_dev->dev,
+			"%s:force clear swevent(%d).\n",
+			__func__, cleartoken_info->token[i]);
+		imgsys_cmdq_clearevent(cleartoken_info->token[i]);
+	}
+#endif
+}
+
+static void imgsys_set_smvr(struct mtk_imgsys_request *req,
+					struct img_ipi_param *ipi)
+{
+	struct mtk_imgsys_dev_buffer *devbuf;
+	bool smvr = false;
+	int b;
+
+	if (!req || !ipi)
+		return;
+
+	b = is_singledev_mode(req);
+	if (!b)
+		devbuf = req->buf_map[MTK_IMGSYS_VIDEO_NODE_CTRLMETA_OUT];
+	else
+		devbuf = req->buf_map[b];
+
+	switch (devbuf->dev_fmt->format) {
+	case V4L2_META_FMT_MTISP_DESC_NORM:
+	case V4L2_META_FMT_MTISP_SDNORM:
+		smvr = false;
+		break;
+	case V4L2_META_FMT_MTISP_DESC:
+	case V4L2_META_FMT_MTISP_SD:
+		smvr = true;
+		break;
+	default:
+		pr_info("%s unknown format\n", __func__);
+	}
+
+	ipi->smvr_mode = smvr;
+}
+
+static void imgsys_sd_share_buffer(struct mtk_imgsys_request *req,
+					struct img_ipi_param *ipi_param)
+{
+	struct mtk_imgsys_dev_buffer *buf_in;
+	int b;
+
+	b = is_singledev_mode(req);
+	buf_in = req->buf_map[b];
+	ipi_param->frm_param.fd = buf_in->vbb.vb2_buf.planes[0].m.fd;
+	ipi_param->frm_param.offset = buf_in->dataofst;
+}
+
+static void imgsys_composer_workfunc(struct work_struct *work)
+{
+	struct mtk_imgsys_request *req = mtk_imgsys_hw_fw_work_to_req(work);
+	struct mtk_imgsys_dev *imgsys_dev = req->imgsys_pipe->imgsys_dev;
+	struct img_ipi_param ipi_param;
+	struct mtk_imgsys_hw_subframe *buf;
+	int ret;
+	// u32 index, frame_no;
+
+	IMGSYS_SYSTRACE_BEGIN("ReqFd:%d\n", req->tstate.req_fd);
+
+	req->tstate.time_compfuncStart = ktime_get_boottime_ns()/1000;
+
+	dev_dbg(imgsys_dev->dev,
+		"%s:(reqfd-%d) to send frame_no(%d)\n",
+		__func__, req->tstate.req_fd,
+		req->img_fparam.frameparam.frame_no);
+	media_request_get(&req->req);
+	down(&imgsys_dev->sem);
+#if MTK_CM4_SUPPORT == 0
+
+	#ifdef BATCH_MODE_V3
+	// V3 batch mode added {
+	if (is_batch_mode(req)) {
+		ipi_param.usage = IMG_IPI_FRAME;
+		ipi_param.frm_param.handle = req->id;
+
+		/* daemon use offset to access frameparam*/
+		ipi_param.frm_param_offset =
+					req->img_fparam.frameparam.self_data.pa;
+		ipi_param.req_addr_va = (u64)req;
+		ipi_param.is_batch_mode = 1;
+		ipi_param.num_frames = (u8)req->unprocessed_count;
+
+		mutex_lock(&imgsys_dev->hw_op_lock);
+		atomic_inc(&imgsys_dev->num_composing);
+
+		ret = imgsys_send(imgsys_dev->scp_pdev, HCP_DIP_FRAME_ID,
+			&ipi_param, sizeof(ipi_param),
+			req->tstate.req_fd, 0);
+
+		if (ret)
+			dev_info(imgsys_dev->dev,
+			"%s: frame_no(%d) send SCP_IPI_DIP_FRAME failed %d\n",
+				__func__,
+				req->img_fparam.frameparam.frame_no, ret);
+		mutex_unlock(&imgsys_dev->hw_op_lock);
+		return;
+	}
+	ipi_param.is_batch_mode = 0;
+	// } V3 batch mode added
+	#endif
+
+#endif
+	/* TODO: */
+	buf = req->working_buf;
+
+	mtk_imgsys_wbuf_to_ipi_img_sw_addr(
+				&req->img_fparam.frameparam.self_data,
+						&buf->frameparam);
+	/* TODO: address check LOG. for desc mode only; not sigdev */
+	if (buf->frameparam.vaddr >
+		(imgsys_dev->working_buf_mem_vaddr +
+		imgsys_dev->working_buf_mem_size)) {
+
+		dev_info(imgsys_dev->dev,
+		"%s: wakeup frame_no(%d), DIP_FRM_SZ(%ld)\n"
+		"ipi.vaddr(%p), reservedwb.addr(%p), reservedwb.size(%d)\n",
+		__func__, req->img_fparam.frameparam.frame_no,
+		DIP_FRM_SZ, buf->frameparam.vaddr,
+		imgsys_dev->working_buf_mem_vaddr,
+		imgsys_dev->working_buf_mem_size);
+	}
+
+	ipi_param.usage = IMG_IPI_FRAME;
+	ipi_param.frm_param.handle = req->id;
+	ipi_param.req_addr_va = (u64)req;
+	/* FOR DESC and SIGDEV */
+	imgsys_set_smvr(req, &ipi_param);
+
+#if MTK_CM4_SUPPORT
+	ipi_param.frm_param.scp_addr = (u32)buf->frameparam.scp_daddr;
+#else
+	/* TODO */
+	if (is_singledev_mode(req)) {
+		imgsys_sd_share_buffer(req, &ipi_param);
+#ifdef USE_KERNEL_ION_BUFFER
+		ipi_param.frm_param.offset = (u32)(buf->frameparam.vaddr -
+			mtk_hcp_get_reserve_mem_virt(DIP_MEM_FOR_HW_ID));
+#endif
+	} else
+		ipi_param.frm_param.offset = (u32)(buf->frameparam.vaddr -
+			mtk_hcp_get_hwid_mem_virt(imgsys_dev->scp_pdev));
+
+	dev_dbg(imgsys_dev->dev, "req-fd:%d, va:%p,sva:%p, offset:%d, fd:%d\n",
+		req->tstate.req_fd,
+		buf->frameparam.vaddr,
+		mtk_hcp_get_hwid_mem_virt(imgsys_dev->scp_pdev),
+		ipi_param.frm_param.offset, ipi_param.frm_param.fd);
+#endif
+
+	mutex_lock(&imgsys_dev->hw_op_lock);
+	atomic_inc(&imgsys_dev->num_composing);
+
+	req->tstate.time_ipisendStart = ktime_get_boottime_ns()/1000;
+
+	ret = imgsys_send(imgsys_dev->scp_pdev, HCP_DIP_FRAME_ID,
+		&ipi_param, sizeof(ipi_param),
+		req->tstate.req_fd, 0);
+
+	// index = req->img_fparam.frameparam.index;
+	// frame_no = req->img_fparam.frameparam.frame_no;
+
+	if (ret) {
+		dev_info(imgsys_dev->dev,
+			"%s: frame_no(%d) send SCP_IPI_DIP_FRAME failed %d\n",
+			__func__, req->img_fparam.frameparam.frame_no, ret);
+		if (is_singledev_mode(req))
+			mtk_imgsys_iova_map_tbl_unmap_sd(req);
+		else if (is_desc_mode(req))
+			mtk_imgsys_iova_map_tbl_unmap(req);
+		mtk_imgsys_pipe_remove_job(req);
+		mtk_imgsys_hw_working_buf_free(imgsys_dev,
+						req->working_buf, true);
+		req->working_buf = NULL;
+		mtk_imgsys_pipe_job_finish(req, VB2_BUF_STATE_ERROR);
+		wake_up(&imgsys_dev->flushing_waitq);
+	}
+	mutex_unlock(&imgsys_dev->hw_op_lock);
+
+	dev_dbg(imgsys_dev->dev, "%s:(reqfd-%d) sent\n", __func__,
+							req->tstate.req_fd);
+
+	IMGSYS_SYSTRACE_END();
+
+}
+
+static int mtk_imgsys_hw_flush_pipe_jobs(struct mtk_imgsys_pipe *pipe)
+{
+	struct mtk_imgsys_request *req;
+	struct list_head job_list = LIST_HEAD_INIT(job_list);
+	int num;
+	int ret;
+	int req_id;
+	u32 frame_no;
+	unsigned long flag;
+
+	spin_lock_irqsave(&pipe->running_job_lock, flag);
+	list_splice_init(&pipe->pipe_job_running_list, &job_list);
+	pipe->num_jobs = 0;
+	spin_unlock_irqrestore(&pipe->running_job_lock, flag);
+
+	ret = wait_event_timeout
+		(pipe->imgsys_dev->flushing_waitq,
+		 !(num = atomic_read(&pipe->imgsys_dev->num_composing)),
+		 msecs_to_jiffies(1000 / 30 * DIP_COMPOSING_MAX_NUM * 3));
+	if (!ret && num) {
+		dev_info(pipe->imgsys_dev->dev,
+			"%s: flushing is aborted, num(%d)\n",
+			__func__, num);
+		return -EINVAL;
+	}
+
+	list_for_each_entry(req, &job_list, list) {
+		req_id = req->id;
+		frame_no = req->img_fparam.frameparam.frame_no;
+		mtk_imgsys_pipe_job_finish(req, VB2_BUF_STATE_ERROR);
+
+		dev_info(pipe->imgsys_dev->dev,
+			"%s:%s: not run job, id(%d), no(%d), state(%d), job cnt(%d)\n",
+			__func__, pipe->desc->name, req_id,
+			frame_no,
+			VB2_BUF_STATE_ERROR, pipe->num_jobs);
+	}
+
+	dev_dbg(pipe->imgsys_dev->dev,
+		"%s: wakeup num(%d)\n", __func__, num);
+	return 0;
+}
+
+
+static void module_uninit(struct kref *kref)
+{
+	struct mtk_imgsys_dev *imgsys_dev;
+	int i;
+	struct mtk_imgsys_dvfs *dvfs_info;
+
+	imgsys_dev = container_of(kref, struct mtk_imgsys_dev, init_kref);
+	dvfs_info = &imgsys_dev->dvfs_info;
+
+	for (i = 0; i < (imgsys_dev->num_mods); i++)
+		if (imgsys_dev->modules[i].uninit)
+			imgsys_dev->modules[i].uninit(imgsys_dev);
+
+	if (IS_ERR_OR_NULL(dvfs_info->reg) || !regulator_is_enabled(dvfs_info->reg))
+		dev_dbg(dvfs_info->dev,
+			"%s: [ERROR] reg is null or disabled\n", __func__);
+	else
+		regulator_disable(dvfs_info->reg);
+
+	pr_info("%s", __func__);
+}
+
+void mtk_imgsys_mod_put(struct mtk_imgsys_dev *imgsys_dev)
+{
+	struct kref *kref;
+
+	kref = &imgsys_dev->init_kref;
+	kref_put(kref, module_uninit);
+}
+
+void mtk_imgsys_mod_get(struct mtk_imgsys_dev *imgsys_dev)
+{
+	struct kref *kref;
+
+	kref = &imgsys_dev->init_kref;
+	kref_get(kref);
+}
+
+static int mtk_imgsys_hw_connect(struct mtk_imgsys_dev *imgsys_dev)
+{
+	int ret, i;
+#ifndef USE_KERNEL_ION_BUFFER
+	struct buf_va_info_t *buf;
+	struct dma_buf *dbuf;
+#else
+	int fd;
+#endif
+	u32 user_cnt = 0;
+	unsigned int mode;
+	struct mtk_imgsys_dvfs *dvfs_info = &imgsys_dev->dvfs_info;
+
+	user_cnt = atomic_read(&imgsys_dev->imgsys_user_cnt);
+	if (user_cnt != 0)
+		dev_info(imgsys_dev->dev,
+			"%s: [ERROR] imgsys user count is not zero(%d)\n",
+			__func__, user_cnt);
+
+	atomic_set(&imgsys_dev->imgsys_user_cnt, 0);
+	if (IS_ERR_OR_NULL(dvfs_info->reg))
+		dev_dbg(dvfs_info->dev,
+			"%s: [ERROR] reg is err or null\n", __func__);
+	else {
+		ret = regulator_enable(dvfs_info->reg);
+		if (ret)
+			dev_info(imgsys_dev->dev, "%s: regulater_enable failed\n", __func__);
+
+	}
+
+	pm_runtime_get_sync(imgsys_dev->dev);
+	/*set default value for hw module*/
+	for (i = 0; i < (imgsys_dev->num_mods); i++)
+		imgsys_dev->modules[i].init(imgsys_dev);
+	kref_init(&imgsys_dev->init_kref);
+
+	pm_runtime_put_sync(imgsys_dev->dev);
+	if (!imgsys_quick_onoff_en) {
+		#if DVFS_QOS_READY
+		mtk_imgsys_power_ctrl(imgsys_dev, true);
+		#else
+		pm_runtime_get_sync(imgsys_dev->dev);
+		for (i = 0; i < (imgsys_dev->num_mods); i++)
+			if (imgsys_dev->modules[i].set)
+				imgsys_dev->modules[i].set(imgsys_dev);
+		#endif
+	}
+
+#if MTK_CM4_SUPPORT
+	struct img_ipi_param ipi_param;
+
+	memset(&ipi_param, 0, sizeof(ipi_param));
+	ipi_param.usage = IMG_IPI_INIT;
+	scp_ipi_register(imgsys_dev->scp_pdev, SCP_IPI_DIP, imgsys_scp_handler,
+		imgsys_dev);
+	ret = scp_ipi_send(imgsys_dev->scp_pdev, SCP_IPI_DIP, &ipi_param,
+			   sizeof(ipi_param), 200);
+#else
+	{
+		struct img_init_info info;
+		struct resource *imgsys_resource = imgsys_dev->imgsys_resource;
+
+		mtk_imgsys_hw_working_buf_pool_reinit(imgsys_dev);
+		/* ALLOCATE IMGSYS WORKING BUFFER FIRST */
+		mode = imgsys_dev->imgsys_pipe[0].init_info.is_smvr;
+		ret = mtk_hcp_allocate_working_buffer(imgsys_dev->scp_pdev, mode);
+		if (ret) {
+			dev_dbg(imgsys_dev->dev, "%s: mtk_hcp_allocate_working_buffer failed %d\n",
+				__func__, ret);
+			return -EBUSY;
+		}
+
+		mtk_hcp_purge_msg(imgsys_dev->scp_pdev);
+
+		/* IMGSYS HW INIT */
+		memset(&info, 0, sizeof(info));
+		info.drv_data = (u64)&imgsys_dev;
+		info.header_version = HEADER_VER;
+		info.dip_param_size = sizeof(struct dip_param);
+		info.param_pack_size = sizeof(struct frame_param_pack);
+		info.frameparam_size = sizeof(struct img_ipi_frameparam);
+		info.reg_phys_addr = imgsys_resource->start;
+		info.reg_range = resource_size(imgsys_resource);
+		/* TODO */
+#ifdef USE_KERNEL_ION_BUFFER
+		fd = hcp_get_ion_buffer_fd(imgsys_dev->scp_pdev,
+		IMG_MEM_FOR_HW_ID);
+		info.hw_buf_fd = fd;
+		info.hw_buf_size =
+				mtk_hcp_get_reserve_mem_size(DIP_MEM_FOR_HW_ID);
+#else
+		buf = get_first_sd_buf();
+		if (!buf) {
+			pr_debug("%s: no single device buff added\n", __func__);
+		} else {
+			dbuf = (struct dma_buf *)buf->dma_buf_putkva;
+			info.hw_buf_size = dbuf->size;
+			info.hw_buf_fd = buf->buf_fd;
+		}
+#endif
+		mtk_hcp_get_init_info(imgsys_dev->scp_pdev, &info);
+		info.sec_tag = imgsys_dev->imgsys_pipe[0].init_info.sec_tag;
+		info.full_wd = imgsys_dev->imgsys_pipe[0].init_info.sensor.full_wd;
+		info.full_ht = imgsys_dev->imgsys_pipe[0].init_info.sensor.full_ht;
+		info.smvr_mode = imgsys_dev->imgsys_pipe[0].init_info.is_smvr;
+		ret = imgsys_send(imgsys_dev->scp_pdev, HCP_IMGSYS_INIT_ID,
+			(void *)&info, sizeof(info), 0, 1);
+	}
+#endif
+
+	if (ret) {
+		dev_dbg(imgsys_dev->dev, "%s: send SCP_IPI_DIP_FRAME failed %d\n",
+			__func__, ret);
+		return -EBUSY;
+	}
+
+	ret = gce_work_pool_init(imgsys_dev);
+	if (ret) {
+		dev_info(imgsys_dev->dev, "%s: gce work pool allocate failed %d\n",
+			__func__, ret);
+		return -EBUSY;
+	}
+
+	/* calling cmdq stream on */
+	imgsys_cmdq_streamon(imgsys_dev);
+
+	imgsys_queue_init(&imgsys_dev->runnerque, imgsys_dev->dev, "imgsys-cmdq");
+	imgsys_queue_enable(&imgsys_dev->runnerque);
+
+	mtk_hcp_register(imgsys_dev->scp_pdev, HCP_IMGSYS_INIT_ID,
+		imgsys_init_handler, "imgsys_init_handler", imgsys_dev);
+	mtk_hcp_register(imgsys_dev->scp_pdev, HCP_IMGSYS_FRAME_ID,
+		imgsys_scp_handler, "imgsys_scp_handler", imgsys_dev);
+	mtk_hcp_register(imgsys_dev->scp_pdev, HCP_IMGSYS_CLEAR_HWTOKEN_ID,
+		imgsys_cleartoken_handler, "imgsys_cleartoken_handler", imgsys_dev);
+
+	return 0;
+}
+
+static void mtk_imgsys_hw_disconnect(struct mtk_imgsys_dev *imgsys_dev)
+{
+	int ret;
+#if MTK_CM4_SUPPORT
+	struct img_ipi_param ipi_param;
+
+	ipi_param.usage = IMG_IPI_DEINIT;
+	ret = scp_ipi_send(imgsys_dev->imgsys_dev->scp_pdev, SCP_IPI_DIP,
+		&ipi_param, sizeof(ipi_param), 0, 0);
+	if (ret) {
+		dev_info(imgsys_dev->dev,
+			"%s: SCP IMG_IPI_DEINIT failed(%d)\n", __func__, ret);
+	}
+
+	scp_ipi_unregister(imgsys_dev->scp_pdev, SCP_IPI_DIP);
+#else
+	struct img_init_info info = {0};
+	u32 user_cnt = 0;
+
+	ret = imgsys_send(imgsys_dev->scp_pdev, HCP_IMGSYS_DEINIT_ID,
+			(void *)&info, sizeof(info),
+			0, 1);
+
+	mtk_hcp_unregister(imgsys_dev->scp_pdev, HCP_DIP_INIT_ID);
+	mtk_hcp_unregister(imgsys_dev->scp_pdev, HCP_DIP_FRAME_ID);
+
+	imgsys_queue_disable(&imgsys_dev->runnerque);
+
+	/* calling cmdq stream off */
+	imgsys_cmdq_streamoff(imgsys_dev);
+
+	/* RELEASE IMGSYS WORKING BUFFER FIRST */
+	ret = mtk_hcp_release_working_buffer(imgsys_dev->scp_pdev);
+	if (ret) {
+		dev_info(imgsys_dev->dev,
+			"%s: mtk_hcp_release_working_buffer failed(%d)\n",
+			__func__, ret);
+	}
+
+#ifdef USE_KERNEL_ION_BUFFER
+	hcp_close_ion_buffer_fd(imgsys_dev->scp_pdev, IMG_MEM_FOR_HW_ID);
+#endif
+#endif
+
+	mtk_hcp_purge_msg(imgsys_dev->scp_pdev);
+
+	gce_work_pool_uninit(imgsys_dev);
+
+	if (!imgsys_quick_onoff_en)
+		#if DVFS_QOS_READY
+		mtk_imgsys_power_ctrl(imgsys_dev, false);
+		#else
+		pm_runtime_put_sync(imgsys_dev->dev);
+		#endif
+	mtk_imgsys_mod_put(imgsys_dev);
+
+	user_cnt = atomic_read(&imgsys_dev->imgsys_user_cnt);
+	if (user_cnt != 0)
+		dev_info(imgsys_dev->dev,
+			"%s: [ERROR] imgsys user count is not yet return to zero(%d)\n",
+			__func__, user_cnt);
+
+}
+
+int mtk_imgsys_hw_streamon(struct mtk_imgsys_pipe *pipe)
+{
+	struct mtk_imgsys_dev *imgsys_dev = pipe->imgsys_dev;
+	int count, ret;
+
+	mutex_lock(&imgsys_dev->hw_op_lock);
+	if (!imgsys_dev->imgsys_stream_cnt) {
+		ret = mtk_imgsys_hw_connect(pipe->imgsys_dev);
+		if (ret) {
+			dev_info(pipe->imgsys_dev->dev,
+				"%s:%s: pipe(%d) connect to dip_hw failed\n",
+				__func__, pipe->desc->name, pipe->desc->id);
+
+			mutex_unlock(&imgsys_dev->hw_op_lock);
+
+			return ret;
+		}
+		INIT_LIST_HEAD(&pipe->pipe_job_running_list);
+	}
+	count = imgsys_dev->imgsys_stream_cnt++;
+	atomic_set(&imgsys_dev->num_composing, 0);
+	mutex_unlock(&imgsys_dev->hw_op_lock);
+
+	pipe->streaming = 1;
+	dev_dbg(pipe->imgsys_dev->dev,
+		"%s:%s: started stream, id(%d), stream cnt(%d)\n",
+		__func__, pipe->desc->name, pipe->desc->id, count);
+
+	return 0;
+}
+
+int mtk_imgsys_hw_streamoff(struct mtk_imgsys_pipe *pipe)
+{
+	struct mtk_imgsys_dev *imgsys_dev = pipe->imgsys_dev;
+	struct mtk_imgsys_dma_buf_iova_get_info *iova_info, *tmp;
+	int ret;
+
+	dev_dbg(imgsys_dev->dev,
+		"%s:%s: streamoff, removing all running jobs\n",
+		__func__, pipe->desc->name);
+
+	pipe->streaming = 0;
+
+	ret = mtk_imgsys_hw_flush_pipe_jobs(pipe);
+	if (ret != 0) {
+		dev_info(imgsys_dev->dev,
+			"%s:%s: mtk_imgsys_hw_flush_pipe_jobs, ret(%d)\n",
+			__func__, pipe->desc->name, ret);
+	}
+
+	/* Check all daemon releasing flow are done */
+	ret = wait_event_interruptible_timeout(
+			frm_info_waitq, info_list_is_empty(&frm_info_list),
+			msecs_to_jiffies(3000));
+	if (ret == 0) {
+		dev_info(imgsys_dev->dev, "%s timeout still with frm list\n",
+			__func__);
+		return -EIO;
+	} else if (-ERESTARTSYS == ret) {
+		dev_info(imgsys_dev->dev, "%s wait for done  interrupted !\n",
+			__func__);
+		return -ERESTARTSYS;
+	}
+
+	/* Stop the hardware if there is no streaming pipe */
+	mutex_lock(&imgsys_dev->hw_op_lock);
+	imgsys_dev->imgsys_stream_cnt--;
+	if (!imgsys_dev->imgsys_stream_cnt) {
+		mtk_imgsys_hw_disconnect(imgsys_dev);
+
+		dev_info(imgsys_dev->dev, "%s: dip_hw disconnected, stream cnt(%d)\n",
+			__func__, imgsys_dev->imgsys_stream_cnt);
+
+		flush_fd_kva_list(imgsys_dev);
+
+		list_for_each_entry_safe(iova_info, tmp,
+					&pipe->iova_cache.list, list_entry) {
+			mtk_imgsys_put_dma_buf(iova_info->dma_buf,
+					iova_info->attach,
+					iova_info->sgt);
+			spin_lock(&pipe->iova_cache.lock);
+			list_del(&iova_info->list_entry);
+			hash_del(&iova_info->hnode);
+			spin_unlock(&pipe->iova_cache.lock);
+			vfree(iova_info);
+		}
+
+	}
+	dev_dbg(pipe->imgsys_dev->dev,
+		"%s:%s: stopped stream id(%d), stream cnt(%d)\n",
+		__func__, pipe->desc->name, pipe->desc->id,
+					imgsys_dev->imgsys_stream_cnt);
+
+	mutex_unlock(&imgsys_dev->hw_op_lock);
+
+	return 0;
+}
+
+static void iova_worker(struct work_struct *work)
+{
+	struct mtk_imgsys_request *req;
+	struct mtk_imgsys_dev *imgsys_dev;
+	struct req_frameparam *req_frame;
+	// struct mtk_imgsys_hw_subframe *buf;
+	struct img_ipi_frameparam *param;
+
+	req = container_of(work, struct mtk_imgsys_request, iova_work);
+	req->tstate.time_iovaworkp = ktime_get_boottime_ns()/1000;
+
+	IMGSYS_SYSTRACE_BEGIN("ReqFd:%d\n", req->tstate.req_fd);
+
+	if (is_singledev_mode(req)) {
+		/* TODO: zero shared buffer */
+		param = req->working_buf->frameparam.vaddr;
+		if (param)
+			memset(param, 0, sizeof(*param));
+
+		mtk_imgsys_sd_desc_map_iova(req);
+	} else if (is_desc_mode(req)) {
+		/* TODO: zero shared buffer */
+		param = req->working_buf->frameparam.vaddr;
+		if (param)
+			memset(param, 0, sizeof(*param));
+
+		mtk_imgsys_desc_map_iova(req);
+	}
+
+	imgsys_dev = req->imgsys_pipe->imgsys_dev;
+	// buf = req->working_buf;
+	req_frame = &req->img_fparam.frameparam;
+	req_frame->state = FRAME_STATE_INIT;
+	req_frame->frame_no =
+			atomic_inc_return(&imgsys_dev->imgsys_enqueue_cnt);
+	req->tstate.time_qw2composer = ktime_get_boottime_ns()/1000;
+
+	imgsys_composer_workfunc(&req->fw_work);
+
+	IMGSYS_SYSTRACE_END();
+
+}
+
+void mtk_imgsys_hw_enqueue(struct mtk_imgsys_dev *imgsys_dev,
+			struct mtk_imgsys_request *req)
+{
+	struct mtk_imgsys_hw_subframe *buf;
+
+	IMGSYS_SYSTRACE_BEGIN("ReqFd:%d\n", req->tstate.req_fd);
+
+	req->tstate.time_composingStart = ktime_get_boottime_ns()/1000;
+	/* TODO: use user fd + offset */
+	buf = mtk_imgsys_hw_working_buf_alloc(req->imgsys_pipe->imgsys_dev);
+	if (!buf) {
+		dev_dbg(req->imgsys_pipe->imgsys_dev->dev,
+			"%s:%s:req(%p): no free working buffer available\n",
+			__func__, req->imgsys_pipe->desc->name, req);
+		return;
+	}
+	req->working_buf = buf;
+#ifndef USE_KERNEL_ION_BUFFER
+	buf->frameparam.vaddr = 0;
+#endif
+
+	if (is_singledev_mode(req))
+		mtk_imgsys_singledevice_ipi_params_config(req);
+	else {
+#ifdef BATCH_MODE_V3
+		if (!is_batch_mode(req))
+			mtk_imgsys_std_ipi_params_config(req);
+#else
+#ifdef DESC_SUPPORT
+		if (is_desc_mode(req))
+			mtk_imgsys_desc_ipi_params_config(req);
+		else
+			mtk_imgsys_std_ipi_params_config(req);
+#endif
+			mtk_imgsys_std_ipi_params_config(req);
+#endif
+	}
+
+	req->tstate.time_composingEnd = ktime_get_boottime_ns()/1000;
+
+	INIT_WORK(&req->iova_work, iova_worker);
+	queue_work(req->imgsys_pipe->imgsys_dev->enqueue_wq,
+			&req->iova_work);
+
+	IMGSYS_SYSTRACE_END();
+}
+
+int mtk_imgsys_can_enqueue(struct mtk_imgsys_dev *imgsys_dev,
+	int unprocessedcnt)
+{
+	if ((imgsys_dev->imgsys_freebufferlist.cnt < unprocessedcnt) ||
+		(list_empty(&imgsys_dev->imgsys_freebufferlist.list)))
+		return false;
+	return true;
+}
+
+struct mtk_imgsys_hw_subframe*
+imgsys_working_buf_alloc_helper(struct mtk_imgsys_dev *imgsys_dev)
+{
+	return mtk_imgsys_hw_working_buf_alloc(imgsys_dev);
+}
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/imgsys/mtk_imgsys-sys.h b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/mtk_imgsys-sys.h
new file mode 100644
index 0000000000000000000000000000000000000000..5e8a92db5fe95dfceaa8b422da4e66a8cf9b684c
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/mtk_imgsys-sys.h
@@ -0,0 +1,20 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2021 MediaTek Inc.
+ *
+ * Author: Frederic Chen <frederic.chen@mediatek.com>
+ *
+ */
+
+#ifndef _MTK_DIP_SYS_H_
+#define _MTK_DIP_SYS_H_
+
+#include <linux/list.h>
+#include <linux/kthread.h>
+#include <linux/mutex.h>
+
+#include "mtk-img-ipi.h"
+
+#define DUMP_USING_CMDQ_TH
+
+#endif /* _MTK_DIP_SYS_H_ */
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/imgsys/mtk_imgsys-trace.c b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/mtk_imgsys-trace.c
new file mode 100644
index 0000000000000000000000000000000000000000..d70561bc2e23b68826e17ad30b359dfe64643cd5
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/mtk_imgsys-trace.c
@@ -0,0 +1,67 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2021 MediaTek Inc.
+ *
+ * Author: Johnson-CH Chiu <Johnson-CH.chiu@mediatek.com>
+ *
+ */
+
+#include "mtk_imgsys-trace.h"
+
+int imgsys_ftrace_en;
+module_param(imgsys_ftrace_en, int, 0644);
+
+static noinline int tracing_mark_write(const char *buf)
+{
+	trace_puts(buf);
+	return 0;
+}
+
+void __imgsys_systrace_b(pid_t tgid, const char *fmt, ...)
+{
+	char log[256];
+	va_list args;
+	int len;
+	char buf2[256];
+
+	memset(log, ' ', sizeof(log));
+	va_start(args, fmt);
+	len = vsnprintf(log, sizeof(log), fmt, args);
+	va_end(args);
+
+	if (unlikely(len < 0))
+		return;
+	else if (unlikely(len == 256))
+		log[255] = '\0';
+
+	len = snprintf(buf2, sizeof(buf2), "B|%d|%s\n", tgid, log);
+
+	if (unlikely(len < 0))
+		return;
+	else if (unlikely(len == 256))
+		buf2[255] = '\0';
+
+	tracing_mark_write(buf2);
+}
+
+void __imgsys_systrace_e(void)
+{
+	char buf2[256];
+	int len;
+
+	len = snprintf(buf2, sizeof(buf2), "E\n");
+
+	if (unlikely(len < 0))
+		return;
+	else if (unlikely(len == 256))
+		buf2[255] = '\0';
+
+	tracing_mark_write(buf2);
+}
+
+bool imgsys_core_ftrace_enabled(void)
+{
+	return imgsys_ftrace_en;
+}
+
+
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/imgsys/mtk_imgsys-trace.h b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/mtk_imgsys-trace.h
new file mode 100644
index 0000000000000000000000000000000000000000..f8d3c76c86f5a5e33937001edbdfca3df47646b1
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/mtk_imgsys-trace.h
@@ -0,0 +1,48 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2021 MediaTek Inc.
+ *
+ * Author: Johnson-CH Chiu <Johnson-CH.chiu@mediatek.com>
+ *
+ */
+#ifndef __MTK_IMG_TRACE_H__
+#define __MTK_IMG_TRACE_H__
+
+#include <linux/kernel.h>
+#include <linux/trace_events.h>
+#define IMGSYS_FTRACE
+#ifdef IMGSYS_FTRACE
+
+#define IMGSYS_TRACE_FORCE_BEGIN(fmt, args...) do { \
+	__imgsys_systrace_b(current->tgid, fmt, ##args); \
+} while (0)
+
+#define IMGSYS_TRACE_FORCE_END() do { \
+	__imgsys_systrace_e(); \
+} while (0)
+
+
+#define IMGSYS_SYSTRACE_BEGIN(fmt, args...) do { \
+	if (imgsys_core_ftrace_enabled()) { \
+		IMGSYS_TRACE_FORCE_BEGIN(fmt, ##args); \
+	} \
+} while (0)
+
+#define IMGSYS_SYSTRACE_END() do { \
+	if (imgsys_core_ftrace_enabled()) { \
+		IMGSYS_TRACE_FORCE_END(); \
+	} \
+} while (0)
+
+bool imgsys_core_ftrace_enabled(void);
+void __imgsys_systrace_b(pid_t tgid, const char *fmt, ...) __attribute__((format(printf, 2, 3)));
+void __imgsys_systrace_e(void);
+
+#else
+
+#define IMGSYS_SYSTRACE_BEGIN(fmt, args...)
+#define IMGSYS_SYSTRACE_END()
+
+#endif
+
+#endif
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/imgsys/mtk_imgsys-v4l2.c b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/mtk_imgsys-v4l2.c
new file mode 100755
index 0000000000000000000000000000000000000000..c38b939b0a85dd55a7b74613362387f5b0cd8c0a
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/mtk_imgsys-v4l2.c
@@ -0,0 +1,3041 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2021 MediaTek Inc.
+ *
+ * Author: Frederic Chen <frederic.chen@mediatek.com>
+ *
+ */
+
+#include <linux/platform_device.h>
+#include <linux/module.h>
+#include <linux/of_device.h>
+#include <linux/pm_runtime.h>
+#include <linux/remoteproc.h>
+#include <linux/suspend.h>
+#include <linux/rtc.h>
+#include <linux/hashtable.h>
+//#include <linux/remoteproc/mtk_scp.h>
+#include <linux/videodev2.h>
+#include <media/videobuf2-dma-contig.h>
+#include <media/v4l2-ioctl.h>
+#include <media/v4l2-subdev.h>
+#include <media/v4l2-event.h>
+#include <dma-iommu.h>
+#include <linux/dma-mapping.h>
+#include "mtk_imgsys-dev.h"
+#include "mtk_imgsys-hw.h"
+#include "mtk-hcp.h"
+#include "mtkdip.h"
+#include "mtk_imgsys-cmdq.h"
+
+#include "mtk_imgsys-data.h"
+
+#define CLK_READY
+
+static struct device *imgsys_pm_dev;
+
+struct mtk_imgsys_larb_device {
+	struct device	*dev;
+	struct mtk_imgsys_dev *imgsys_dev;
+};
+
+static int mtk_imgsys_larb_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct mtk_imgsys_larb_device   *larb_dev;
+	int ret;
+
+	dev_info(dev, "%s\n", __func__);
+	larb_dev = devm_kzalloc(dev, sizeof(*dev), GFP_KERNEL);
+	if (!larb_dev)
+		return -ENOMEM;
+
+/* TODO */
+//#ifdef CONFIG_MTK_IOMMU_PGTABLE_EXT
+//#if (CONFIG_MTK_IOMMU_PGTABLE_EXT > 32)
+	if (dma_set_mask_and_coherent(dev, DMA_BIT_MASK(34)))
+		dev_info(dev, "%s: No suitable DMA available\n", __func__);
+//#endif
+//#endif
+
+	if (!dev->dma_parms) {
+		dev->dma_parms =
+			devm_kzalloc(dev, sizeof(*dev->dma_parms), GFP_KERNEL);
+		if (!dev->dma_parms)
+			return -ENOMEM;
+	}
+
+	if (dev->dma_parms) {
+		ret = dma_set_max_seg_size(dev, UINT_MAX);
+		if (ret)
+			dev_info(dev, "Failed to set DMA segment size\n");
+	}
+/*
+	ret = of_property_read_u32(dev->of_node, "mediatek,larb-id",
+				   &larb_dev->larb_id);
+	if (ret != 0)
+		return ret;
+
+	larb_dev->dev = dev;
+	dev_set_drvdata(dev, larb_dev);
+*/
+	pm_runtime_enable(dev);
+
+//	return component_add(dev, &mtk_cam_pm_component_ops);
+	return 0;
+}
+
+static int mtk_imgsys_larb_remove(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+
+	pm_runtime_disable(dev);
+
+	//component_del(dev, &mtk_cam_pm_component_ops);
+	return 0;
+}
+static const struct of_device_id mtk_imgsys_larb_match[] = {
+
+	{.compatible = "mediatek,imgsys-larb",},
+	{},
+};
+
+struct platform_driver mtk_imgsys_larb_driver = {
+	.probe  = mtk_imgsys_larb_probe,
+	.remove = mtk_imgsys_larb_remove,
+	.driver = {
+		.name   = "mtk-imgsys-larb",
+		.of_match_table = of_match_ptr(mtk_imgsys_larb_match),
+	},
+};
+static int mtk_imgsys_sd_subscribe_event(struct v4l2_subdev *subdev,
+				      struct v4l2_fh *fh,
+				      struct v4l2_event_subscription *sub)
+{
+	switch (sub->type) {
+	case V4L2_EVENT_FRAME_SYNC:
+		return v4l2_event_subscribe(fh, sub, 64, NULL);
+	default:
+		return -EINVAL;
+	}
+}
+
+
+static int mtk_imgsys_subdev_s_stream(struct v4l2_subdev *sd,
+				   int enable)
+{
+	struct mtk_imgsys_pipe *pipe = mtk_imgsys_subdev_to_pipe(sd);
+	int ret;
+
+	if (enable) {
+		ret = mtk_imgsys_hw_streamon(pipe);
+		if (ret)
+			dev_info(pipe->imgsys_dev->dev,
+				"%s:%s: pipe(%d) streamon failed\n",
+				__func__, pipe->desc->name, pipe->desc->id);
+	} else {
+		ret = mtk_imgsys_hw_streamoff(pipe);
+		if (ret)
+			dev_info(pipe->imgsys_dev->dev,
+				"%s:%s: pipe(%d) streamon off with errors\n",
+				__func__, pipe->desc->name, pipe->desc->id);
+	}
+
+	return ret;
+}
+
+static int mtk_imgsys_subdev_get_fmt(struct v4l2_subdev *sd,
+				  struct v4l2_subdev_state *sd_state,
+				  struct v4l2_subdev_format *fmt)
+{
+	struct mtk_imgsys_pipe *imgsys_pipe = mtk_imgsys_subdev_to_pipe(sd);
+	struct v4l2_mbus_framefmt *mf;
+
+	u32 pad = fmt->pad;
+
+	if (fmt->which == V4L2_SUBDEV_FORMAT_ACTIVE) {
+		fmt->format = imgsys_pipe->nodes[pad].pad_fmt;
+	} else {
+		mf = v4l2_subdev_get_try_format(sd, sd_state, pad);
+		fmt->format = *mf;
+	}
+
+	dev_dbg(imgsys_pipe->imgsys_dev->dev,
+		"get(try:%d) node:%s(pad:%d)fmt: %dx%d",
+		fmt->which, imgsys_pipe->nodes[pad].desc->name, pad,
+		fmt->format.width, fmt->format.height);
+
+	return 0;
+}
+
+static int mtk_imgsys_subdev_set_fmt(struct v4l2_subdev *sd,
+				  struct v4l2_subdev_state *sd_state,
+				  struct v4l2_subdev_format *fmt)
+{
+	struct mtk_imgsys_pipe *imgsys_pipe = mtk_imgsys_subdev_to_pipe(sd);
+	struct v4l2_mbus_framefmt *mf;
+	u32 pad = fmt->pad;
+
+	dev_dbg(imgsys_pipe->imgsys_dev->dev, "set(try:%d) node:%s(pad:%d)fmt: %dx%d",
+		fmt->which, imgsys_pipe->nodes[pad].desc->name, pad,
+		fmt->format.width, fmt->format.height);
+
+	if (fmt->which == V4L2_SUBDEV_FORMAT_TRY)
+		mf = v4l2_subdev_get_try_format(sd, sd_state, pad);
+	else
+		mf = &imgsys_pipe->nodes[pad].pad_fmt;
+
+	fmt->format.code = mf->code;
+
+	/* Clamp the w and h based on the hardware capabilities */
+	if (imgsys_pipe->subdev_pads[pad].flags & MEDIA_PAD_FL_SOURCE) {
+		fmt->format.width = clamp(fmt->format.width,
+					  MTK_DIP_CAPTURE_MIN_WIDTH,
+					  MTK_DIP_CAPTURE_MAX_WIDTH);
+		fmt->format.height = clamp(fmt->format.height,
+					   MTK_DIP_CAPTURE_MIN_HEIGHT,
+					   MTK_DIP_CAPTURE_MAX_HEIGHT);
+	} else {
+		fmt->format.width = clamp(fmt->format.width,
+					  MTK_DIP_OUTPUT_MIN_WIDTH,
+					  MTK_DIP_OUTPUT_MAX_WIDTH);
+		fmt->format.height = clamp(fmt->format.height,
+					   MTK_DIP_OUTPUT_MIN_WIDTH,
+					   MTK_DIP_OUTPUT_MAX_WIDTH);
+	}
+
+	*mf = fmt->format;
+
+	return 0;
+}
+
+static int mtk_imgsys_subdev_get_selection(struct v4l2_subdev *sd,
+					struct v4l2_subdev_state *sd_state,
+					struct v4l2_subdev_selection *sel)
+{
+	struct v4l2_rect *try_sel, *r;
+	struct mtk_imgsys_pipe *imgsys_pipe = mtk_imgsys_subdev_to_pipe(sd);
+
+	dev_dbg(imgsys_pipe->imgsys_dev->dev,
+		"get subdev %s sel which %d target 0x%4x rect [%dx%d]",
+		imgsys_pipe->desc->name, sel->which, sel->target,
+		sel->r.width, sel->r.height);
+
+	if (sel->pad != MTK_IMGSYS_VIDEO_NODE_ID_WROT_A_CAPTURE &&
+	    sel->pad != MTK_IMGSYS_VIDEO_NODE_ID_WROT_B_CAPTURE) {
+		dev_dbg(imgsys_pipe->imgsys_dev->dev,
+			"g_select failed(%s:%d):not support\n",
+			imgsys_pipe->nodes[sel->pad].desc->name, sel->pad);
+		return -EINVAL;
+	}
+
+	switch (sel->target) {
+	case V4L2_SEL_TGT_CROP:
+		try_sel = v4l2_subdev_get_try_crop(sd, sd_state, sel->pad);
+		/* effective resolution */
+		r = &imgsys_pipe->nodes[sel->pad].crop;
+		break;
+	default:
+		dev_dbg(imgsys_pipe->imgsys_dev->dev,
+			"s_select failed(%s:%d):target(%d) not support\n",
+			imgsys_pipe->nodes[sel->pad].desc->name, sel->pad,
+			sel->target);
+		return -EINVAL;
+	}
+
+	if (sel->which == V4L2_SUBDEV_FORMAT_TRY)
+		sel->r = *try_sel;
+	else
+		sel->r = *r;
+
+	return 0;
+}
+
+static int mtk_imgsys_subdev_set_selection(struct v4l2_subdev *sd,
+					struct v4l2_subdev_state *sd_state,
+					struct v4l2_subdev_selection *sel)
+{
+	struct v4l2_rect *rect, *try_sel;
+	struct mtk_imgsys_pipe *imgsys_pipe = mtk_imgsys_subdev_to_pipe(sd);
+
+	dev_dbg(imgsys_pipe->imgsys_dev->dev,
+		"set subdev %s sel which %d target 0x%4x rect [%dx%d]",
+		imgsys_pipe->desc->name, sel->which, sel->target,
+		sel->r.width, sel->r.height);
+
+	if (sel->pad != MTK_IMGSYS_VIDEO_NODE_ID_WROT_A_CAPTURE &&
+	    sel->pad != MTK_IMGSYS_VIDEO_NODE_ID_WROT_B_CAPTURE) {
+		dev_dbg(imgsys_pipe->imgsys_dev->dev,
+			"g_select failed(%s:%d):not support\n",
+			imgsys_pipe->nodes[sel->pad].desc->name, sel->pad);
+		return -EINVAL;
+	}
+
+	switch (sel->target) {
+	case V4L2_SEL_TGT_CROP:
+		try_sel = v4l2_subdev_get_try_crop(sd, sd_state, sel->pad);
+		rect = &imgsys_pipe->nodes[sel->pad].crop;
+		break;
+	default:
+		dev_dbg(imgsys_pipe->imgsys_dev->dev,
+			"s_select failed(%s:%d):target(%d) not support\n",
+			imgsys_pipe->nodes[sel->pad].desc->name, sel->pad,
+			sel->target);
+		return -EINVAL;
+	}
+
+	if (sel->which == V4L2_SUBDEV_FORMAT_TRY)
+		*try_sel = sel->r;
+	else
+		*rect = sel->r;
+
+	return 0;
+}
+
+static int mtk_imgsys_link_setup(struct media_entity *entity,
+			      const struct media_pad *local,
+			      const struct media_pad *remote,
+			      u32 flags)
+{
+	struct mtk_imgsys_pipe *pipe =
+		container_of(entity, struct mtk_imgsys_pipe, subdev.entity);
+	u32 pad = local->index;
+
+	WARN_ON(entity->obj_type != MEDIA_ENTITY_TYPE_V4L2_SUBDEV);
+	WARN_ON(pad >= pipe->desc->total_queues);
+
+	mutex_lock(&pipe->lock);
+
+	if (flags & MEDIA_LNK_FL_ENABLED)
+		pipe->nodes_enabled++;
+	else
+		pipe->nodes_enabled--;
+
+	pipe->nodes[pad].flags &= ~MEDIA_LNK_FL_ENABLED;
+	pipe->nodes[pad].flags |= flags & MEDIA_LNK_FL_ENABLED;
+
+	dev_dbg(pipe->imgsys_dev->dev,
+		"%s: link setup, flags(0x%x), (%s)%d -->(%s)%d, nodes_enabled(0x%llx)\n",
+		pipe->desc->name, flags, local->entity->name, local->index,
+		remote->entity->name, remote->index, pipe->nodes_enabled);
+
+	mutex_unlock(&pipe->lock);
+
+	return 0;
+}
+
+static int mtk_imgsys_vb2_meta_buf_prepare(struct vb2_buffer *vb)
+{
+	struct mtk_imgsys_pipe *pipe = vb2_get_drv_priv(vb->vb2_queue);
+	struct mtk_imgsys_video_device *node =
+					mtk_imgsys_vbq_to_node(vb->vb2_queue);
+	struct device *dev = pipe->imgsys_dev->dev;
+	const struct v4l2_format *fmt = &node->vdev_fmt;
+
+	if (vb->planes[0].length < fmt->fmt.meta.buffersize) {
+		dev_dbg(dev,
+			"%s:%s:%s: size error(user:%d, required:%d)\n",
+			__func__, pipe->desc->name, node->desc->name,
+			vb->planes[0].length, fmt->fmt.meta.buffersize);
+		return -EINVAL;
+	}
+#ifdef SIZE_CHECK
+	if (vb->planes[0].bytesused != fmt->fmt.meta.buffersize) {
+		dev_info(dev,
+			"%s:%s:%s: bytesused(%d) must be %d\n",
+			__func__, pipe->desc->name, node->desc->name,
+			vb->planes[0].bytesused,
+			fmt->fmt.meta.buffersize);
+		return -EINVAL;
+	}
+#endif
+
+	return 0;
+}
+
+static int mtk_imgsys_vb2_video_buf_prepare(struct vb2_buffer *vb)
+{
+	struct mtk_imgsys_pipe *pipe = vb2_get_drv_priv(vb->vb2_queue);
+	struct mtk_imgsys_video_device *node =
+					mtk_imgsys_vbq_to_node(vb->vb2_queue);
+	struct device *dev = pipe->imgsys_dev->dev;
+	const struct v4l2_format *fmt = &node->vdev_fmt;
+	unsigned int size;
+	int i;
+
+	for (i = 0; i < vb->num_planes; i++) {
+		size = fmt->fmt.pix_mp.plane_fmt[i].sizeimage;
+		if (vb->planes[i].length < size) {
+			dev_dbg(dev,
+				"%s:%s:%s: size error(user:%d, max:%d)\n",
+				__func__, pipe->desc->name, node->desc->name,
+				vb->planes[i].length, size);
+			return -EINVAL;
+		}
+	}
+
+	return 0;
+}
+
+static int mtk_imgsys_vb2_buf_out_validate(struct vb2_buffer *vb)
+{
+	struct vb2_v4l2_buffer *v4l2_buf = to_vb2_v4l2_buffer(vb);
+
+	if (v4l2_buf->field == V4L2_FIELD_ANY)
+		v4l2_buf->field = V4L2_FIELD_NONE;
+
+	if (v4l2_buf->field != V4L2_FIELD_NONE)
+		return -EINVAL;
+
+	return 0;
+}
+
+static int mtk_imgsys_vb2_meta_buf_init(struct vb2_buffer *vb)
+{
+	struct vb2_v4l2_buffer *b = to_vb2_v4l2_buffer(vb);
+	struct mtk_imgsys_dev_buffer *dev_buf =
+					mtk_imgsys_vb2_buf_to_dev_buf(vb);
+	struct mtk_imgsys_pipe *pipe = vb2_get_drv_priv(vb->vb2_queue);
+	struct mtk_imgsys_video_device *node =
+					mtk_imgsys_vbq_to_node(vb->vb2_queue);
+	phys_addr_t buf_paddr;
+
+	dev_dbg(pipe->imgsys_dev->dev,
+		"%s:%s:%s: buf type(%d), idx(%d), mem(%d)\n",
+		__func__, pipe->desc->name, node->desc->name, b->vb2_buf.type,
+		b->vb2_buf.index, b->vb2_buf.memory);
+
+	if (b->vb2_buf.memory == VB2_MEMORY_DMABUF) {
+		dev_buf->scp_daddr[0] = vb2_dma_contig_plane_dma_addr(vb, 0);
+
+		/*
+		 * We got the incorrect physical address mapped when
+		 * using dma_map_single() so I used dma_map_page_attrs()
+		 * directly to workaround here. Please see the detail in
+		 * mtk_imgsys-sys.c
+		 */
+		buf_paddr = dev_buf->scp_daddr[0];
+		dev_buf->isp_daddr[0] =	dma_map_page_attrs(
+							pipe->imgsys_dev->dev,
+							phys_to_page(buf_paddr),
+							0, vb->planes[0].length,
+							DMA_BIDIRECTIONAL,
+							DMA_ATTR_SKIP_CPU_SYNC);
+		if (dma_mapping_error(pipe->imgsys_dev->dev,
+				      dev_buf->isp_daddr[0])) {
+			dev_info(pipe->imgsys_dev->dev,
+				"%s:%s: failed to map buffer: s_daddr(0x%llx)\n",
+				pipe->desc->name, node->desc->name,
+				dev_buf->scp_daddr[0]);
+			return -EINVAL;
+		}
+	} else if (b->vb2_buf.memory == VB2_MEMORY_MMAP) {
+#if MTK_CM4_SUPPORT == 0
+		dev_buf->va_daddr[0] = (u64)vb2_plane_vaddr(vb, 0);
+#endif
+	}
+
+	dev_dbg(pipe->imgsys_dev->dev,
+		"%s:%s: buf type(%d), idx(%d), mem(%d), p(%d) i_daddr(0x%llx), s_daddr(0x%llx), va_daddr(0x%llx)\n",
+		pipe->desc->name, node->desc->name, b->vb2_buf.type,
+		b->vb2_buf.index, b->vb2_buf.memory, 0,
+		dev_buf->isp_daddr[0], dev_buf->scp_daddr[0],
+		dev_buf->va_daddr[0]);
+
+	return 0;
+}
+
+static int mtk_imgsys_vb2_video_buf_init(struct vb2_buffer *vb)
+{
+	struct vb2_v4l2_buffer *b = to_vb2_v4l2_buffer(vb);
+	struct mtk_imgsys_dev_buffer *dev_buf =
+					mtk_imgsys_vb2_buf_to_dev_buf(vb);
+	struct mtk_imgsys_pipe *pipe = vb2_get_drv_priv(vb->vb2_queue);
+	struct mtk_imgsys_video_device *node =
+					mtk_imgsys_vbq_to_node(vb->vb2_queue);
+	int i;
+
+	dev_dbg(pipe->imgsys_dev->dev,
+		"%s:%s:%s: buf type(%d), idx(%d), mem(%d)\n",
+		__func__, pipe->desc->name, node->desc->name, b->vb2_buf.type,
+		b->vb2_buf.index, b->vb2_buf.memory);
+
+	for (i = 0; i < vb->num_planes; i++) {
+		dev_buf->scp_daddr[i] = 0;
+		dev_buf->isp_daddr[i] =	vb2_dma_contig_plane_dma_addr(vb, i);
+
+		dev_dbg(pipe->imgsys_dev->dev,
+			"%s:%s: buf type(%d), idx(%d), mem(%d), p(%d) i_daddr(0x%llx), s_daddr(0x%llx)\n",
+			pipe->desc->name, node->desc->name, b->vb2_buf.type,
+			b->vb2_buf.index, b->vb2_buf.memory, i,
+			dev_buf->isp_daddr[i], dev_buf->scp_daddr[i]);
+	}
+	return 0;
+}
+
+static void mtk_imgsys_vb2_queue_meta_buf_cleanup(struct vb2_buffer *vb)
+{
+	struct vb2_v4l2_buffer *b = to_vb2_v4l2_buffer(vb);
+	struct mtk_imgsys_dev_buffer *dev_buf =
+					mtk_imgsys_vb2_buf_to_dev_buf(vb);
+	struct mtk_imgsys_pipe *pipe = vb2_get_drv_priv(vb->vb2_queue);
+
+	if (b->vb2_buf.memory == VB2_MEMORY_DMABUF) {
+		dma_unmap_page_attrs(pipe->imgsys_dev->dev,
+				     dev_buf->isp_daddr[0],
+				     vb->planes[0].length, DMA_BIDIRECTIONAL,
+				     DMA_ATTR_SKIP_CPU_SYNC);
+	}
+}
+
+static void mtk_imgsys_vb2_buf_queue(struct vb2_buffer *vb)
+{
+	struct vb2_v4l2_buffer *b = to_vb2_v4l2_buffer(vb);
+	struct mtk_imgsys_dev_buffer *dev_buf =
+					mtk_imgsys_vb2_buf_to_dev_buf(vb);
+	struct mtk_imgsys_request *req = NULL;
+	struct mtk_imgsys_video_device *node =
+					mtk_imgsys_vbq_to_node(vb->vb2_queue);
+	struct mtk_imgsys_pipe *pipe = vb2_get_drv_priv(vb->vb2_queue);
+	int buf_count;
+
+	if (!vb->request)
+		return;
+
+	req = mtk_imgsys_media_req_to_imgsys_req(vb->request);
+
+	dev_buf->dev_fmt = node->dev_q.dev_fmt;
+	//support std mode dynamic change buf info & fmt
+	//get default node info to devbuf for desc mode(+)
+	if (is_desc_fmt(dev_buf->dev_fmt)) {
+		dev_buf->fmt = node->vdev_fmt;
+		dev_buf->dma_port = node->desc->dma_port;
+		dev_buf->rotation = node->rotation;
+		dev_buf->crop.c = node->crop;
+		dev_buf->compose = node->compose;
+	}
+	//get qbuf dynamic info to devbuf for desc mode(-)
+#ifdef BUF_QUEUE_LOG
+	dev_dbg(pipe->imgsys_dev->dev,
+			"[%s] portid(%d), rotat(%d), hflip(%d), vflip(%d)\n",
+			__func__,
+			dev_buf->dma_port,
+			dev_buf->rotation,
+			dev_buf->hflip,
+			dev_buf->vflip);
+
+	for (i = 0; i < dev_buf->fmt.fmt.pix_mp.num_planes; i++) {
+		dev_dbg(pipe->imgsys_dev->dev,
+			"[%s] width(%d), width(%d), sizeimage(%d), bytesperline(%d)\n",
+			__func__,
+			dev_buf->fmt.fmt.pix_mp.width,
+			dev_buf->fmt.fmt.pix_mp.height,
+			dev_buf->fmt.fmt.pix_mp.plane_fmt[i].sizeimage,
+			dev_buf->fmt.fmt.pix_mp.plane_fmt[i].bytesperline);
+	}
+
+	dev_dbg(pipe->imgsys_dev->dev,
+		"%s:%s: buf type(%d), idx(%d), mem(%d), i_daddr(0x%llx), s_daddr(0x%llx)\n",
+		req->imgsys_pipe->desc->name, node->desc->name, b->vb2_buf.type,
+		b->vb2_buf.index, b->vb2_buf.memory, dev_buf->isp_daddr[0],
+		dev_buf->scp_daddr[0]);
+#endif
+	spin_lock(&node->buf_list_lock);
+	list_add_tail(&dev_buf->list, &node->buf_list);
+	spin_unlock(&node->buf_list_lock);
+
+	buf_count = atomic_dec_return(&req->buf_count);
+	if (!buf_count) {
+		dev_dbg(pipe->imgsys_dev->dev,
+			"framo_no: (%d), reqfd-%d\n",
+			req->img_fparam.frameparam.frame_no, b->request_fd);
+		req->tstate.req_fd = b->request_fd;
+		mutex_lock(&req->imgsys_pipe->lock);
+		mtk_imgsys_pipe_try_enqueue(req->imgsys_pipe);
+		mutex_unlock(&req->imgsys_pipe->lock);
+	}
+	req->tstate.time_qreq = ktime_get_boottime_ns()/1000;
+}
+
+static int mtk_imgsys_vb2_meta_queue_setup(struct vb2_queue *vq,
+					unsigned int *num_buffers,
+					unsigned int *num_planes,
+					unsigned int sizes[],
+					struct device *alloc_devs[])
+{
+	struct mtk_imgsys_pipe *pipe = vb2_get_drv_priv(vq);
+	struct mtk_imgsys_video_device *node = mtk_imgsys_vbq_to_node(vq);
+	const struct v4l2_format *fmt = &node->vdev_fmt;
+	unsigned int size;
+
+	if (!*num_planes) {
+		*num_planes = 1;
+		sizes[0] = fmt->fmt.meta.buffersize;
+	}
+
+	/* vq->dma_attrs |= DMA_ATTR_NON_CONSISTENT; */
+		size = fmt->fmt.meta.buffersize;
+		*num_buffers = clamp_val(*num_buffers, 1, VB2_MAX_FRAME);
+		sizes[0] = size;
+
+	dev_dbg(pipe->imgsys_dev->dev,
+		"%s:%s:%s: n_p(%d), n_b(%d), s[%d](%u)\n",
+		__func__, pipe->desc->name, node->desc->name,
+		*num_planes, *num_buffers, 0, sizes[0]);
+	return 0;
+}
+
+static int mtk_imgsys_vb2_video_queue_setup(struct vb2_queue *vq,
+					 unsigned int *num_buffers,
+					 unsigned int *num_planes,
+					 unsigned int sizes[],
+					 struct device *alloc_devs[])
+{
+	struct mtk_imgsys_pipe *pipe = vb2_get_drv_priv(vq);
+	struct mtk_imgsys_video_device *node = mtk_imgsys_vbq_to_node(vq);
+	const struct v4l2_format *fmt = &node->vdev_fmt;
+	unsigned int size;
+	int i;
+
+	if (!*num_planes) {
+		*num_planes = 1;
+		sizes[0] = fmt->fmt.pix_mp.plane_fmt[0].sizeimage;
+	}
+
+	for (i = 0; i < *num_planes; i++) {
+		if (sizes[i] < fmt->fmt.pix_mp.plane_fmt[i].sizeimage) {
+			size = fmt->fmt.pix_mp.plane_fmt[i].sizeimage;
+			dev_dbg(pipe->imgsys_dev->dev,
+				"%s:%s:%s: invalid buf: %u < %u\n",
+				__func__, pipe->desc->name,
+				node->desc->name, sizes[0], size);
+				return -EINVAL;
+		}
+		sizes[i] = fmt->fmt.pix_mp.plane_fmt[i].sizeimage;
+		*num_buffers = clamp_val(*num_buffers, 1,
+					 VB2_MAX_FRAME);
+
+		dev_dbg(pipe->imgsys_dev->dev,
+			"%s:%s:%s: n_p(%d), n_b(%d), s[%d](%u)\n",
+			__func__, pipe->desc->name, node->desc->name,
+			*num_planes, *num_buffers, i, sizes[i]);
+	}
+	return 0;
+}
+
+static void mtk_imgsys_return_all_buffers(struct mtk_imgsys_pipe *pipe,
+				       struct mtk_imgsys_video_device *node,
+				       enum vb2_buffer_state state)
+{
+	struct mtk_imgsys_dev_buffer *b, *b0;
+
+	spin_lock(&node->buf_list_lock);
+	list_for_each_entry_safe(b, b0, &node->buf_list, list) {
+		list_del(&b->list);
+		vb2_buffer_done(&b->vbb.vb2_buf, state);
+	}
+	spin_unlock(&node->buf_list_lock);
+}
+
+static int mtk_imgsys_vb2_start_streaming(struct vb2_queue *vq,
+							unsigned int count)
+{
+	struct mtk_imgsys_pipe *pipe = vb2_get_drv_priv(vq);
+	struct mtk_imgsys_video_device *node = mtk_imgsys_vbq_to_node(vq);
+	int ret;
+
+
+	if (!pipe->nodes_streaming) {
+		ret = media_pipeline_start(&node->vdev.entity.pads[0], &pipe->pipeline);
+		if (ret < 0) {
+			dev_info(pipe->imgsys_dev->dev,
+				"%s:%s: media_pipeline_start failed(%d)\n",
+				pipe->desc->name, node->desc->name, ret);
+			goto fail_return_bufs;
+		}
+	}
+
+	mutex_lock(&pipe->lock);
+	if (!(node->flags & MEDIA_LNK_FL_ENABLED)) {
+		dev_info(pipe->imgsys_dev->dev,
+			"%s:%s: stream on failed, node is not enabled\n",
+			pipe->desc->name, node->desc->name);
+
+		ret = -ENOLINK;
+		goto fail_stop_pipeline;
+	}
+
+	pipe->nodes_streaming++;
+	if (pipe->nodes_streaming == pipe->nodes_enabled) {
+		/* Start streaming of the whole pipeline */
+		ret = v4l2_subdev_call(&pipe->subdev, video, s_stream, 1);
+		if (ret < 0) {
+			dev_info(pipe->imgsys_dev->dev,
+				"%s:%s: sub dev s_stream(1) failed(%d)\n",
+				pipe->desc->name, node->desc->name, ret);
+
+			goto fail_stop_pipeline;
+		}
+	}
+
+	dev_dbg(pipe->imgsys_dev->dev,
+		"%s:%s:%s nodes_streaming(0x%llx), nodes_enable(0x%llx)\n",
+		__func__, pipe->desc->name, node->desc->name,
+		pipe->nodes_streaming, pipe->nodes_enabled);
+
+	mutex_unlock(&pipe->lock);
+
+	return 0;
+
+fail_stop_pipeline:
+	mutex_unlock(&pipe->lock);
+	media_pipeline_stop(&node->vdev.entity.pads[0]);
+
+fail_return_bufs:
+	mtk_imgsys_return_all_buffers(pipe, node, VB2_BUF_STATE_QUEUED);
+
+
+	return ret;
+}
+
+static void mtk_imgsys_vb2_stop_streaming(struct vb2_queue *vq)
+{
+	struct mtk_imgsys_pipe *pipe = vb2_get_drv_priv(vq);
+	struct mtk_imgsys_video_device *node = mtk_imgsys_vbq_to_node(vq);
+	int ret;
+
+	mutex_lock(&pipe->lock);
+
+	if (WARN_ON(!(node->flags & MEDIA_LNK_FL_ENABLED))) {
+		mutex_lock(&pipe->imgsys_dev->hw_op_lock);
+		pipe->imgsys_dev->abnormal_stop = true;
+		mutex_unlock(&pipe->imgsys_dev->hw_op_lock);
+	}
+
+	/*
+	 * We can check with pipe->nodes_streaming and pipe->nodes_enabled
+	 * if the legacy user lib removed all dynamic link operations
+	 */
+	if (pipe->streaming) {
+		ret = v4l2_subdev_call(&pipe->subdev, video, s_stream, 0);
+		if (ret)
+			dev_info(pipe->imgsys_dev->dev,
+				"%s:%s: sub dev s_stream(0) failed(%d)\n",
+				pipe->desc->name, node->desc->name, ret);
+	}
+
+	pipe->nodes_streaming--;
+
+	mutex_unlock(&pipe->lock);
+
+	if (!pipe->nodes_streaming)
+		media_pipeline_stop(&node->vdev.entity.pads[0]);
+
+	mtk_imgsys_return_all_buffers(pipe, node, VB2_BUF_STATE_ERROR);
+
+	dev_dbg(pipe->imgsys_dev->dev,
+		"%s:%s:%s nodes_streaming(0x%llx), nodes_enable(0x%llx)\n",
+		__func__, pipe->desc->name, node->desc->name,
+		pipe->nodes_streaming, pipe->nodes_enabled);
+
+
+}
+
+static void mtk_imgsys_vb2_request_complete(struct vb2_buffer *vb)
+{
+	struct mtk_imgsys_video_device *node =
+					mtk_imgsys_vbq_to_node(vb->vb2_queue);
+
+	v4l2_ctrl_request_complete(vb->req_obj.req,
+				   &node->ctrl_handler);
+}
+
+static int mtk_imgsys_videoc_querycap(struct file *file, void *fh,
+				   struct v4l2_capability *cap)
+{
+	struct mtk_imgsys_pipe *pipe = video_drvdata(file);
+
+	strlcpy(cap->driver, pipe->desc->name,
+		sizeof(cap->driver));
+	strlcpy(cap->card, pipe->desc->name,
+		sizeof(cap->card));
+	snprintf(cap->bus_info, sizeof(cap->bus_info),
+		 "platform:%s", dev_name(pipe->imgsys_dev->mdev.dev));
+
+	return 0;
+}
+
+static int mtk_imgsys_videoc_try_fmt(struct file *file, void *fh,
+				  struct v4l2_format *f)
+{
+	struct mtk_imgsys_pipe *pipe = video_drvdata(file);
+	struct mtk_imgsys_video_device *node = mtk_imgsys_file_to_node(file);
+	const struct mtk_imgsys_dev_format *dev_fmt;
+	struct v4l2_format try_fmt;
+
+	memset(&try_fmt, 0, sizeof(try_fmt));
+
+	dev_fmt = mtk_imgsys_pipe_find_fmt(pipe, node,
+					f->fmt.pix_mp.pixelformat);
+	if (!dev_fmt) {
+		dev_fmt = &node->desc->fmts[node->desc->default_fmt_idx];
+		dev_dbg(pipe->imgsys_dev->dev,
+			"%s:%s:%s: dev_fmt(%d) not found, use default(%d)\n",
+			__func__, pipe->desc->name, node->desc->name,
+			f->fmt.pix_mp.pixelformat, dev_fmt->format);
+	}
+
+	mtk_imgsys_pipe_try_fmt(pipe, node, &try_fmt, f, dev_fmt);
+	*f = try_fmt;
+
+	return 0;
+}
+
+static int mtk_imgsys_videoc_g_fmt(struct file *file, void *fh,
+				struct v4l2_format *f)
+{
+	struct mtk_imgsys_video_device *node = mtk_imgsys_file_to_node(file);
+
+	*f = node->vdev_fmt;
+
+	return 0;
+}
+
+static int mtk_imgsys_videoc_s_fmt(struct file *file, void *fh,
+				struct v4l2_format *f)
+{
+	struct mtk_imgsys_video_device *node = mtk_imgsys_file_to_node(file);
+	struct mtk_imgsys_pipe *pipe = video_drvdata(file);
+	const struct mtk_imgsys_dev_format *dev_fmt;
+
+	if (pipe->streaming || vb2_is_busy(&node->dev_q.vbq))
+		return -EBUSY;
+
+	dev_fmt = mtk_imgsys_pipe_find_fmt(pipe, node,
+					f->fmt.pix_mp.pixelformat);
+	if (!dev_fmt) {
+		dev_fmt = &node->desc->fmts[node->desc->default_fmt_idx];
+		dev_dbg(pipe->imgsys_dev->dev,
+			"%s:%s:%s: dev_fmt(%d) not found, use default(%d)\n",
+			__func__, pipe->desc->name, node->desc->name,
+			f->fmt.pix_mp.pixelformat, dev_fmt->format);
+	}
+
+	memset(&node->vdev_fmt, 0, sizeof(node->vdev_fmt));
+
+	mtk_imgsys_pipe_try_fmt(pipe, node, &node->vdev_fmt, f, dev_fmt);
+	*f = node->vdev_fmt;
+
+	node->dev_q.dev_fmt = dev_fmt;
+	node->vdev_fmt = *f;
+	node->crop.left = 0; /* reset crop setting of nodes */
+	node->crop.top = 0;
+	node->crop.width = f->fmt.pix_mp.width;
+	node->crop.height = f->fmt.pix_mp.height;
+	node->compose.left = 0;
+	node->compose.top = 0;
+	node->compose.width = f->fmt.pix_mp.width;
+	node->compose.height = f->fmt.pix_mp.height;
+
+	return 0;
+}
+
+static int mtk_imgsys_videoc_enum_framesizes(struct file *file, void *priv,
+					  struct v4l2_frmsizeenum *sizes)
+{
+	struct mtk_imgsys_pipe *pipe = video_drvdata(file);
+	struct mtk_imgsys_video_device *node = mtk_imgsys_file_to_node(file);
+	const struct mtk_imgsys_dev_format *dev_fmt;
+
+	dev_fmt = mtk_imgsys_pipe_find_fmt(pipe, node, sizes->pixel_format);
+
+	if (!dev_fmt || sizes->index)
+		return -EINVAL;
+
+	sizes->type = node->desc->frmsizeenum->type;
+	sizes->stepwise.max_width =
+		node->desc->frmsizeenum->stepwise.max_width;
+	sizes->stepwise.min_width =
+		node->desc->frmsizeenum->stepwise.min_width;
+	sizes->stepwise.max_height =
+		node->desc->frmsizeenum->stepwise.max_height;
+	sizes->stepwise.min_height =
+		node->desc->frmsizeenum->stepwise.min_height;
+	sizes->stepwise.step_height =
+		node->desc->frmsizeenum->stepwise.step_height;
+	sizes->stepwise.step_width =
+		node->desc->frmsizeenum->stepwise.step_width;
+
+	return 0;
+}
+
+static int mtk_imgsys_videoc_enum_fmt(struct file *file, void *fh,
+				   struct v4l2_fmtdesc *f)
+{
+	struct mtk_imgsys_video_device *node = mtk_imgsys_file_to_node(file);
+
+	if (f->index >= node->desc->num_fmts)
+		return -EINVAL;
+
+	strscpy(f->description, node->desc->description,
+		sizeof(f->description));
+	f->pixelformat = node->desc->fmts[f->index].format;
+	f->flags = 0;
+
+	return 0;
+}
+
+static int mtk_imgsys_meta_enum_format(struct file *file, void *fh,
+				    struct v4l2_fmtdesc *f)
+{
+	struct mtk_imgsys_video_device *node = mtk_imgsys_file_to_node(file);
+
+	if (f->index > 0)
+		return -EINVAL;
+
+	strscpy(f->description, node->desc->description,
+		sizeof(f->description));
+
+	f->pixelformat = node->vdev_fmt.fmt.meta.dataformat;
+	f->flags = 0;
+
+	return 0;
+}
+
+static int mtk_imgsys_videoc_g_meta_fmt(struct file *file, void *fh,
+				     struct v4l2_format *f)
+{
+	struct mtk_imgsys_video_device *node = mtk_imgsys_file_to_node(file);
+	*f = node->vdev_fmt;
+
+	return 0;
+}
+
+static int mtk_imgsys_videoc_s_meta_fmt(struct file *file, void *fh,
+				     struct v4l2_format *f)
+{
+	struct mtk_imgsys_video_device *node = mtk_imgsys_file_to_node(file);
+	struct mtk_imgsys_pipe *pipe = video_drvdata(file);
+	const struct mtk_imgsys_dev_format *dev_fmt;
+
+	if (pipe->streaming || vb2_is_busy(&node->dev_q.vbq))
+		return -EBUSY;
+
+	dev_fmt = mtk_imgsys_pipe_find_fmt(pipe, node,
+						f->fmt.meta.dataformat);
+
+		if (!dev_fmt) {
+			dev_fmt =
+				&node->desc->fmts[node->desc->default_fmt_idx];
+			dev_info(pipe->imgsys_dev->dev,
+				"%s:%s:%s: dev_fmt(%d) not found, use default(%d)\n",
+				__func__, pipe->desc->name, node->desc->name,
+				f->fmt.meta.dataformat, dev_fmt->format);
+		}
+
+	memset(&node->vdev_fmt, 0, sizeof(node->vdev_fmt));
+
+	f->fmt.meta.dataformat = dev_fmt->format;
+
+	if (dev_fmt->buffer_size <= 0) {
+		dev_dbg(pipe->imgsys_dev->dev,
+			"%s: Invalid meta buf size(%u), use default(%u)\n",
+			pipe->desc->name, dev_fmt->buffer_size,
+			MTK_DIP_DEV_META_BUF_DEFAULT_SIZE);
+
+		f->fmt.meta.buffersize =
+			MTK_DIP_DEV_META_BUF_DEFAULT_SIZE;
+	} else {
+		f->fmt.meta.buffersize = dev_fmt->buffer_size;
+	}
+
+	node->dev_q.dev_fmt = dev_fmt;
+	node->vdev_fmt = *f;
+
+	return 0;
+}
+
+
+static int mtk_imgsys_video_device_s_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct mtk_imgsys_video_device *node =
+		container_of(ctrl->handler,
+			     struct mtk_imgsys_video_device, ctrl_handler);
+
+	if (ctrl->id != V4L2_CID_ROTATE) {
+		pr_debug("[%s] doesn't support ctrl(%d)\n",
+			 node->desc->name, ctrl->id);
+		return -EINVAL;
+	}
+
+	node->rotation = ctrl->val;
+
+	return 0;
+}
+
+static int mtk_imgsys_vidioc_qbuf(struct file *file, void *priv,
+				  struct v4l2_buffer *buf)
+{
+	struct mtk_imgsys_pipe *pipe = video_drvdata(file);
+	struct mtk_imgsys_video_device *node = mtk_imgsys_file_to_node(file);
+	struct vb2_buffer *vb;
+	struct mtk_imgsys_dev_buffer *dev_buf;
+	int ret = 0;
+#ifdef DYNAMIC_FMT
+	struct buf_info dyn_buf_info;
+	int i = 0;
+	unsigned long user_ptr = 0;
+#ifndef USE_V4L2_FMT
+	struct v4l2_plane_pix_format *vfmt;
+	struct plane_pix_format *bfmt;
+#endif
+#endif
+	struct mtk_imgsys_request *imgsys_req;
+	struct media_request *req;
+
+	if ((buf->index >= VB2_MAX_FRAME) || (buf->index < 0)) {
+		dev_info(pipe->imgsys_dev->dev, "[%s] error vb2 index %d\n", __func__, buf->index);
+		return -EINVAL;
+	}
+
+	vb = node->dev_q.vbq.bufs[buf->index];
+	dev_buf = mtk_imgsys_vb2_buf_to_dev_buf(vb);
+
+	if (!dev_buf) {
+		dev_dbg(pipe->imgsys_dev->dev, "[%s] NULL dev_buf obtained with idx %d\n", __func__,
+											buf->index);
+		return -EINVAL;
+	}
+
+	//support dynamic change size&fmt for std mode flow
+	req = media_request_get_by_fd(&pipe->imgsys_dev->mdev, buf->request_fd);
+	if (IS_ERR(req)) {
+		dev_info(pipe->imgsys_dev->dev, "%s: invalid request_fd\n", __func__);
+		return PTR_ERR(req);
+	}
+
+	imgsys_req = mtk_imgsys_media_req_to_imgsys_req(req);
+	imgsys_req->tstate.time_qbuf = ktime_get_boottime_ns()/1000;
+	media_request_put(req);
+	if (!is_desc_fmt(node->dev_q.dev_fmt)) {
+#ifdef DYNAMIC_FMT
+		user_ptr =
+			(((unsigned long)(buf->m.planes[0].reserved[0]) << 32) |
+			((unsigned long)buf->m.planes[0].reserved[1]));
+
+		if (user_ptr) {
+			ret = copy_from_user(&dyn_buf_info,
+						   (void *)(size_t)user_ptr,
+						   sizeof(struct buf_info));
+			if (ret != 0) {
+				dev_dbg(pipe->imgsys_dev->dev,
+					"[%s]%s:%s:copy_from_user fail !!!\n",
+					__func__,
+					pipe->desc->name, node->desc->name);
+				return -EINVAL;
+			}
+#ifdef USE_V4L2_FMT
+			dev_buf->fmt.fmt.pix_mp = dyn_buf_info.fmt.fmt.pix_mp;
+#else
+			dev_buf->fmt.fmt.pix_mp.width =
+					dyn_buf_info.fmt.fmt.pix_mp.width;
+			dev_buf->fmt.fmt.pix_mp.height =
+					dyn_buf_info.fmt.fmt.pix_mp.height;
+			dev_buf->fmt.fmt.pix_mp.pixelformat =
+					dyn_buf_info.fmt.fmt.pix_mp.pixelformat;
+			for (i = 0; i < IMGBUF_MAX_PLANES; i++) {
+				vfmt = &dev_buf->fmt.fmt.pix_mp.plane_fmt[i];
+				bfmt =
+				&dyn_buf_info.fmt.fmt.pix_mp.plane_fmt[i];
+				vfmt->sizeimage = bfmt->sizeimage;
+				vfmt->bytesperline = bfmt->sizeimage;
+			}
+#endif
+			dev_buf->crop = dyn_buf_info.crop;
+			/* dev_buf->compose = dyn_buf_info.compose; */
+			dev_buf->rotation = dyn_buf_info.rotation;
+			dev_buf->hflip = dyn_buf_info.hflip;
+			dev_buf->vflip = dyn_buf_info.vflip;
+
+			dev_dbg(pipe->imgsys_dev->dev,
+					"[%s] portid(%d), rotat(%d), hflip(%d), vflip(%d)\n",
+					__func__,
+					dev_buf->dma_port,
+					dev_buf->rotation,
+					dev_buf->hflip,
+					dev_buf->vflip);
+
+			for (i = 0;
+				i < dev_buf->fmt.fmt.pix_mp.num_planes; i++) {
+				dev_dbg(pipe->imgsys_dev->dev,
+					"[%s] width(%d), width(%d), sizeimage(%d), bytesperline(%d)\n",
+					__func__,
+					dev_buf->fmt.fmt.pix_mp.width,
+					dev_buf->fmt.fmt.pix_mp.width,
+			dev_buf->fmt.fmt.pix_mp.plane_fmt[i].sizeimage,
+			dev_buf->fmt.fmt.pix_mp.plane_fmt[i].bytesperline);
+			}
+		} else {
+			dev_dbg(pipe->imgsys_dev->dev,
+				"[%s]%s: stdmode videonode(%s) qbuf bufinfo(reserved) is null!\n",
+				__func__, pipe->desc->name, node->desc->name);
+			/*
+			 * update fiexd pipeline node info for update devbuf
+			 * lately
+			 */
+			{
+				dev_buf->fmt = node->vdev_fmt;
+				dev_buf->dma_port = node->desc->dma_port;
+				dev_buf->rotation = node->rotation;
+				dev_buf->crop.c = node->crop;
+				dev_buf->compose = node->compose;
+			}
+		}
+#endif
+	} else {
+		dev_dbg(pipe->imgsys_dev->dev,
+			"[%s]%s:%s: no need to cache bufinfo,videonode fmt is DESC or SingleDevice(%d)!\n",
+			__func__,
+			pipe->desc->name,
+			node->desc->name,
+			node->dev_q.dev_fmt->format);
+	}
+	if ((node->desc->id == MTK_IMGSYS_VIDEO_NODE_ID_CTRLMETA_OUT) ||
+		(node->desc->id == MTK_IMGSYS_VIDEO_NODE_ID_TUNING_OUT)) {
+		dev_buf->dataofst = buf->reserved2;
+	} else {
+		dev_buf->dataofst = buf->m.planes[0].reserved[2];
+	}
+
+	ret =  vb2_ioctl_qbuf(file, priv, buf);
+	if (ret != 0) {
+		pr_info("[%s] %s:%s: vb2_ioctl_qbuf fail\n",
+			__func__,
+			pipe->desc->name, node->desc->name);
+		return -EINVAL;
+	}
+
+	return ret;
+}
+
+static bool get_user_by_file(struct file *filp, struct mtk_imgsys_user **user)
+{
+	bool found = false;
+	struct mtk_imgsys_pipe *pipe = video_drvdata(filp);
+	struct mtk_imgsys_dev *imgsys_dev = pipe->imgsys_dev;
+
+	mutex_lock(&imgsys_dev->imgsys_users.user_lock);
+	list_for_each_entry((*user), &imgsys_dev->imgsys_users.list, entry) {
+		if ((*user) == NULL)
+			continue;
+
+		if ((*user)->fh == filp->private_data) {
+			found = true;
+			pr_debug("%s: user(%p) found! id(%d)", __func__, (*user),
+				(*user)->id);
+			break;
+		}
+	}
+	mutex_unlock(&imgsys_dev->imgsys_users.user_lock);
+	return found;
+}
+
+#ifdef BATCH_MODE_V3
+static int mtkdip_ioc_dqbuf(struct file *filp, void *arg)
+{
+	struct mtk_imgsys_user *user = NULL;
+	int ret = 0;
+
+	if (!get_user_by_file(filp, &user))
+		return -EINVAL;
+
+	if (list_empty(&user->done_list)
+	    && user->state == DIP_STATE_STREAMON) {
+		pr_info("%s: list empty, wait", __func__);
+
+		ret = wait_event_interruptible(user->done_wq,
+						!list_empty(&user->done_list)
+					|| user->state != DIP_STATE_STREAMON);
+	}
+
+	if (ret == 0) {
+		struct frame_param_pack *pack = (struct frame_param_pack *)arg;
+		struct done_frame_pack *dp;
+		unsigned long flags;
+
+		spin_lock_irqsave(&user->lock, flags);
+		if (user->state == DIP_STATE_STREAMON &&
+			(!list_empty(&user->done_list) && user->dqdonestate)) {
+			dp = list_first_entry(&user->done_list,
+				struct done_frame_pack, done_entry);
+			list_del(&dp->done_entry);
+			memcpy(pack, &dp->pack,
+			       sizeof(struct frame_param_pack));
+			vfree(dp);
+		}
+		spin_unlock_irqrestore(&user->lock, flags);
+
+		pr_info(
+		"[dip-drv][j.deque] user(%d) deque success! frame_pack=(num_frames(%d), seq_no(%llx), cookie(%x))\n",
+		user->id, pack->num_frames, pack->seq_num, pack->cookie);
+	}
+
+	return ret;
+}
+
+static void mtkdip_save_pack(struct frame_param_pack *pack,
+			    struct mtk_imgsys_request *imgsys_req)
+{
+	imgsys_req->done_pack = vzalloc(sizeof(struct done_frame_pack),
+				     GFP_KERNEL);
+	memcpy(&imgsys_req->done_pack->pack, pack,
+	       sizeof(struct frame_param_pack));
+
+
+}
+
+static int mtkdip_fill_req(struct mtk_imgsys_dev *imgsys_dev,
+			      struct mtk_imgsys_request *req,
+			      struct frame_param_pack *pack,
+			      struct mtk_imgsys_user *user)
+{
+	int i, ret;
+	struct img_ipi_frameparam *packed_frame = pack->frame_params;
+
+	req->unprocessed_count = pack->num_frames;
+	for (i = 0; i < req->unprocessed_count; i++) {
+		struct mtk_imgsys_hw_subframe *subframe;
+		struct img_ipi_frameparam *frame, *prev_frame;
+
+		/**
+		 * Note: subframe->buffer is tile buffer,
+		 *       subframe->frameparam is img_ipi_frameparam
+		 *       we set offset in scp_daddr for user daemon access
+		 */
+
+		subframe = imgsys_working_buf_alloc_helper(imgsys_dev);
+		if (subframe == NULL) {
+			pr_info("%s: Failed to allocate subframe(%p), free(%d),used(%d)\n",
+				__func__,
+				subframe,
+				imgsys_dev->imgsys_freebufferlist.cnt,
+				imgsys_dev->imgsys_usedbufferlist.cnt);
+			ret = wait_event_interruptible(user->enque_wq,
+				imgsys_working_buf_alloc_helper(imgsys_dev));
+			return ret;
+		}
+
+		frame = (struct img_ipi_frameparam *)subframe->frameparam.vaddr;
+
+		if (i == 0) {
+			struct img_sw_addr *ipi_addr;
+
+			ipi_addr = &req->img_fparam.frameparam.self_data;
+			ipi_addr->va = (u64)subframe->frameparam.vaddr;
+			ipi_addr->pa = (u32)subframe->frameparam.scp_daddr
+					- imgsys_dev->working_buf_mem_scp_daddr;
+		}
+
+		copy_from_user((void *)subframe->frameparam.vaddr,
+				       (void *)packed_frame,
+				       sizeof(struct img_ipi_frameparam));
+
+		spin_lock(&imgsys_dev->imgsys_usedbufferlist.lock);
+		list_del(&subframe->list_entry);
+		imgsys_dev->imgsys_usedbufferlist.cnt--;
+		spin_unlock(&imgsys_dev->imgsys_usedbufferlist.lock);
+
+		spin_lock(&req->working_buf_list.lock);
+		list_add_tail(&subframe->list_entry,
+			      &req->working_buf_list.list);
+		req->working_buf_list.cnt++;
+		spin_unlock(&req->working_buf_list.lock);
+
+		frame->framepack_buf_va = (u64)subframe->frameparam.vaddr;
+
+		/* Use our own tuning buffer */
+		frame->tuning_data.iova = subframe->tuning_buf.isp_daddr;
+		frame->tuning_data.present = ((struct img_ipi_frameparam *)
+				frame->framepack_buf_va)->tuning_data.present;
+		frame->tuning_data.pa = subframe->tuning_buf.scp_daddr
+					- imgsys_dev->working_buf_mem_scp_daddr;
+		frame->tuning_data.va = (u64)subframe->tuning_buf.vaddr
+			- (u64)mtk_hcp_get_reserve_mem_virt(DIP_MEM_FOR_HW_ID);
+		memset(subframe->tuning_buf.vaddr, 0, DIP_TUNING_SZ);
+		dev_dbg(imgsys_dev->dev,
+			"packed_frame->tuning_data.present:0x%llx, idx(%d), f_no(%d), in(%d), out(%d)\n",
+			frame->tuning_data.present,
+			frame->index, frame->frame_no,
+			frame->num_inputs, frame->num_outputs);
+
+		if (frame->tuning_data.present)
+			copy_from_user(subframe->tuning_buf.vaddr,
+			       (void *)frame->tuning_data.present,
+			       DIP_TUNING_SZ);
+
+		memset(subframe->buffer.vaddr, 0, DIP_SUB_FRM_SZ);
+
+		frame->config_data.va = (u64)subframe->config_data.vaddr;
+		frame->config_data.pa = subframe->config_data.scp_daddr
+					- imgsys_dev->working_buf_mem_scp_daddr;
+		frame->config_data.offset = (u64)subframe->config_data.vaddr
+			- (u64)mtk_hcp_get_reserve_mem_virt(DIP_MEM_FOR_HW_ID);
+		memset(subframe->config_data.vaddr, 0, DIP_COMP_SZ);
+
+		/* fill the current buffer address in the previous frame */
+		if (i > 0 && i < (req->unprocessed_count)) {
+
+			/**
+			 * we send offset of the frameparam to user space
+			 */
+			prev_frame->dip_param.next_frame =
+					subframe->frameparam.scp_daddr
+					- imgsys_dev->working_buf_mem_scp_daddr;
+			dev_dbg(imgsys_dev->dev, "next_frame offset:%x\n",
+				 prev_frame->dip_param.next_frame);
+		}
+
+		prev_frame = frame;
+
+		if (i == (req->unprocessed_count - 1))
+			prev_frame->dip_param.next_frame = 0;
+
+		/* Get next frame in the frame_param_pack */
+		packed_frame++;
+	}
+	return 0;
+}
+
+static void init_buffer_list(struct mtk_imgsys_hw_working_buf_list *list)
+{
+	INIT_LIST_HEAD(&list->list);
+	spin_lock_init(&list->lock);
+	list->cnt = 0;
+}
+
+static int mtkdip_ioc_qbuf(struct file *filp, void *arg)
+{
+	struct mtk_imgsys_user *user = NULL;
+	struct mtk_imgsys_pipe *pipe = video_drvdata(filp);
+	struct mtk_imgsys_dev *imgsys_dev = pipe->imgsys_dev;
+	struct mtk_imgsys_request *imgsys_req;
+	struct frame_param_pack *pack = (struct frame_param_pack *)arg;
+	int ret = 0;
+	unsigned long flag;
+
+	ret = get_user_by_file(filp, &user);
+	if (!ret) {
+		pr_info("%s: cannot find user\n", __func__);
+		return -EINVAL;
+	}
+
+	if (user->state != DIP_STATE_STREAMON) {
+		pr_info("%s: cannot queue buffer before streamon\n", __func__);
+		return -EINVAL;
+	}
+
+	// generate mtk dip request, with pipe and id
+	imgsys_req = vzalloc(sizeof(*imgsys_req), GFP_KERNEL);
+	if (!imgsys_req) {
+		ret = -ENOMEM;
+		pr_info("%s: Failed to allocate dip request\n", __func__);
+		return ret;
+	}
+	imgsys_req->imgsys_pipe = pipe;
+	imgsys_req->id = mtk_imgsys_pipe_next_job_id_batch_mode(pipe, user->id);
+	init_buffer_list(&imgsys_req->working_buf_list);
+	init_buffer_list(&imgsys_req->scp_done_list);
+	init_buffer_list(&imgsys_req->runner_done_list);
+	init_buffer_list(&imgsys_req->mdp_done_list);
+
+	if (!mtk_imgsys_can_enqueue(imgsys_dev, pack->num_frames)) {
+		ret = wait_event_interruptible(user->enque_wq,
+			mtk_imgsys_can_enqueue(imgsys_dev, pack->num_frames));
+		if (ret == -ERESTARTSYS) {
+			pr_info("%s: interrupted by a signal!\n", __func__);
+			return ret;
+		}
+	}
+
+	// put frame parameter in mtk dip request
+	ret = mtkdip_fill_req(imgsys_dev, imgsys_req, pack, user);
+	if (ret) {
+		pr_info("%s: Failed to fill dip request\n", __func__);
+		return ret;
+	}
+	mtkdip_save_pack(pack, imgsys_req);
+	imgsys_req->is_batch_mode = 1;
+	// add job to pipe->pipe_job_running_list
+	spin_lock_irqsave(&pipe->running_job_lock, flag);
+	list_add_tail(&imgsys_req->list, &pipe->pipe_job_running_list);
+	pipe->num_jobs++;
+	spin_unlock_irqrestore(&pipe->running_job_lock, flag);
+
+	mtk_imgsys_hw_enqueue(imgsys_dev, imgsys_req);
+	return 0;
+}
+
+static int mtkdip_ioc_streamon(struct file *filp)
+{
+	struct mtk_imgsys_user *user = NULL;
+	struct mtk_imgsys_pipe *pipe = NULL;
+	int ret = 0;
+
+	ret = get_user_by_file(filp, &user);
+	if (!ret) {
+		pr_info("%s: cannot find user\n", __func__);
+		return -EINVAL;
+	}
+	pr_info("%s: id(%d)\n", __func__, user->id);
+	pipe = video_drvdata(filp);
+	ret = mtk_imgsys_hw_streamon(pipe);
+	if (ret == 0) {
+		unsigned long flags;
+
+		spin_lock_irqsave(&user->lock, flags);
+		user->state = DIP_STATE_STREAMON;
+		user->dqdonestate = false;
+		spin_unlock_irqrestore(&user->lock, flags);
+	}
+	return ret;
+}
+
+static int mtkdip_ioc_streamoff(struct file *filp)
+{
+	struct mtk_imgsys_user *user = NULL;
+	struct mtk_imgsys_pipe *pipe = NULL;
+	int ret = 0;
+
+	ret = get_user_by_file(filp, &user);
+	if (!ret) {
+		pr_info("%s: cannot find user\n", __func__);
+		return -EINVAL;
+	}
+	pr_info("%s: id(%d)\n", __func__, user->id);
+	pipe = video_drvdata(filp);
+
+	ret = mtk_imgsys_hw_streamoff(pipe);
+	if (ret == 0) {
+		struct done_frame_pack *dp;
+		unsigned long flags;
+
+		spin_lock_irqsave(&user->lock, flags);
+		list_for_each_entry(dp, &user->done_list, done_entry) {
+			list_del(&dp->done_entry);
+			vfree(dp);
+		}
+		user->state = DIP_STATE_STREAMOFF;
+		user->dqdonestate = false;
+		spin_unlock_irqrestore(&user->lock, flags);
+		wake_up_all(&user->done_wq);
+	}
+
+	return ret;
+}
+
+static int mtkdip_ioc_g_reg_size(struct file *filp, void *arg)
+{
+	struct mtk_imgsys_user *user = NULL;
+	struct mtk_imgsys_pipe *pipe = NULL;
+	struct mtk_imgsys_dev *imgsys_dev = NULL;
+	int ret = 0;
+	int *reg_size = (int *)arg;
+
+	ret = get_user_by_file(filp, &user);
+	if (!ret) {
+		pr_info("%s: cannot find user\n", __func__);
+		return -EINVAL;
+	}
+	pr_info("%s: id(%d)\n", __func__, user->id);
+	pipe = video_drvdata(filp);
+	imgsys_dev = pipe->imgsys_dev;
+	*reg_size = imgsys_dev->reg_table_size;
+
+	return 0;
+}
+
+static int mtkdip_ioc_g_isp_version(struct file *filp, void *arg)
+{
+	struct mtk_imgsys_user *user = NULL;
+	struct mtk_imgsys_pipe *pipe = NULL;
+	struct mtk_imgsys_dev *imgsys_dev = NULL;
+	int ret = 0;
+	int *isp_version = (int *)arg;
+
+	ret = get_user_by_file(filp, &user);
+	if (!ret) {
+		pr_info("%s: cannot find user\n", __func__);
+		return -EINVAL;
+	}
+	pr_info("%s: id(%d)\n", __func__, user->id);
+	pipe = video_drvdata(filp);
+	imgsys_dev = pipe->imgsys_dev;
+	*isp_version = imgsys_dev->isp_version;
+	return 0;
+}
+
+static int mtkdip_ioc_set_user_enum(struct file *filp, void *arg)
+{
+	int ret = 0;
+	struct mtk_imgsys_user *user;
+
+	ret = get_user_by_file(filp, &user);
+	if (!ret) {
+		pr_info("%s: cannot find user\n", __func__);
+		return -EINVAL;
+	}
+
+	user->user_enum = *(int *)arg;
+	pr_info("%s: id(%d) user_enum(%d)\n", __func__,
+		user->id, user->user_enum);
+	return 0;
+
+}
+
+long mtk_imgsys_vidioc_default(struct file *file, void *fh,
+			   bool valid_prio, unsigned int cmd, void *arg)
+{
+	struct v4l2_fh *handle = fh;
+
+	pr_debug("%s cmd: %d handle: %p\n", __func__, cmd, handle);
+
+	switch (cmd) {
+	case MTKDIP_IOC_QBUF:
+		return mtkdip_ioc_qbuf(file, arg);
+	case MTKDIP_IOC_DQBUF:
+		return mtkdip_ioc_dqbuf(file, arg);
+	case MTKDIP_IOC_STREAMON:
+		return mtkdip_ioc_streamon(file);
+	case MTKDIP_IOC_STREAMOFF:
+		return mtkdip_ioc_streamoff(file);
+	case MTKDIP_IOC_G_REG_SIZE:
+		return mtkdip_ioc_g_reg_size(file, arg);
+	case MTKDIP_IOC_G_ISP_VERSION:
+		return mtkdip_ioc_g_isp_version(file, arg);
+	case MTKDIP_IOC_S_USER_ENUM:
+		return mtkdip_ioc_set_user_enum(file, arg);
+	default:
+		pr_info("%s: non-supported cmd\n", __func__);
+		return -ENOTTY;
+	}
+
+	return 0;
+}
+#endif
+
+static int mtkdip_ioc_add_kva(struct v4l2_subdev *subdev, void *arg)
+{
+	struct mtk_imgsys_pipe *imgsys_pipe = mtk_imgsys_subdev_to_pipe(subdev);
+	struct fd_info *fd_info = (struct fd_info *)arg;
+	struct fd_kva_list_t *kva_list;
+	struct buf_va_info_t *buf_va_info;
+	struct dma_buf *dmabuf;
+	struct dma_buf_attachment *attach;
+	struct sg_table *sgt;
+	dma_addr_t dma_addr;
+	struct iosys_map map = {0};
+	int i;
+
+	if (fd_info->fd_num > FD_MAX)
+		return -EINVAL;
+
+	kva_list = get_fd_kva_list();
+	for (i = 0; i < fd_info->fd_num; i++) {
+		buf_va_info = (struct buf_va_info_t *)
+			vzalloc(sizeof(vlist_type(struct buf_va_info_t)));
+		INIT_LIST_HEAD(vlist_link(buf_va_info, struct buf_va_info_t));
+		if (buf_va_info == NULL) {
+			dev_info(imgsys_pipe->imgsys_dev->dev, "%s: null buf_va_info\n",
+								__func__);
+			return -EINVAL;
+		}
+
+		if (!fd_info->fds[i]) {
+			dev_info(imgsys_pipe->imgsys_dev->dev, "%s: zero fd bypassed\n",
+								__func__);
+			continue;
+		}
+
+		buf_va_info->buf_fd = fd_info->fds[i];
+		dmabuf = dma_buf_get(fd_info->fds[i]);
+
+		if (IS_ERR(dmabuf)) {
+			dev_info(imgsys_pipe->imgsys_dev->dev, "%s:err fd %d",
+						__func__, fd_info->fds[i]);
+			vfree(buf_va_info);
+			continue;
+		}
+
+		fd_info->fds_size[i] = dmabuf->size;
+
+		dma_buf_begin_cpu_access(dmabuf, DMA_BIDIRECTIONAL);
+		dma_buf_vmap(dmabuf, &map);
+		buf_va_info->kva = (u64)(map.vaddr);
+		buf_va_info->dma_buf_putkva = dmabuf;
+
+		attach = dma_buf_attach(dmabuf, imgsys_pipe->imgsys_dev->dev);
+		if (IS_ERR(attach)) {
+			dma_buf_vunmap(dmabuf, &map);
+			dma_buf_end_cpu_access(dmabuf, DMA_BIDIRECTIONAL);
+			dma_buf_put(dmabuf);
+			vfree(buf_va_info);
+			pr_info("dma_buf_attach fail fd:%d\n", fd_info->fds[i]);
+			continue;
+		}
+
+		sgt = dma_buf_map_attachment(attach, DMA_BIDIRECTIONAL);
+		if (IS_ERR(sgt)) {
+			dma_buf_vunmap(dmabuf, &map);
+			dma_buf_end_cpu_access(dmabuf, DMA_BIDIRECTIONAL);
+			dma_buf_detach(dmabuf, attach);
+			dma_buf_put(dmabuf);
+			pr_info("%s:dma_buf_map_attachment sgt err: fd %d\n",
+						__func__, fd_info->fds[i]);
+			vfree(buf_va_info);
+
+			continue;
+		}
+		dma_addr = sg_dma_address(sgt->sgl);
+
+		buf_va_info->attach = attach;
+		buf_va_info->sgt = sgt;
+		buf_va_info->dma_addr = dma_addr;
+
+		mutex_lock(&(kva_list->mymutex));
+		list_add_tail(vlist_link(buf_va_info, struct buf_va_info_t),
+		   &kva_list->mylist);
+		mutex_unlock(&(kva_list->mymutex));
+		pr_debug("%s: fd(%d) size(0x%x) cached\n", __func__,
+					fd_info->fds[i], fd_info->fds_size[i]);
+	}
+
+	mtk_hcp_send_async(imgsys_pipe->imgsys_dev->scp_pdev,
+				HCP_IMGSYS_UVA_FDS_ADD_ID, fd_info,
+				sizeof(struct fd_info), 0);
+
+	return 0;
+}
+
+static int mtkdip_ioc_del_kva(struct v4l2_subdev *subdev, void *arg)
+{
+	struct mtk_imgsys_pipe *imgsys_pipe = mtk_imgsys_subdev_to_pipe(subdev);
+	struct fd_info *fd_info = (struct fd_info *)arg;
+	struct fd_kva_list_t *kva_list;
+	struct buf_va_info_t *buf_va_info;
+	struct dma_buf *dmabuf;
+	bool find = false;
+	struct list_head *ptr = NULL;
+	int i;
+	struct iosys_map map = {0};
+
+	if (fd_info->fd_num > FD_MAX)
+		return -EINVAL;
+
+	kva_list = get_fd_kva_list();
+	for (i = 0; i < fd_info->fd_num; i++) {
+		find = false;
+		mutex_lock(&(kva_list->mymutex));
+		list_for_each(ptr, &(kva_list->mylist)) {
+			buf_va_info = vlist_node_of(ptr, struct buf_va_info_t);
+			if (buf_va_info->buf_fd == fd_info->fds[i]) {
+				find = true;
+				break;
+			}
+		}
+
+		if (!find) {
+			mutex_unlock(&(kva_list->mymutex));
+			dev_info(imgsys_pipe->imgsys_dev->dev, "%s: fd(%d) not found\n",
+						__func__, fd_info->fds[i]);
+			continue;
+		}
+		list_del_init(vlist_link(buf_va_info, struct buf_va_info_t));
+		mutex_unlock(&(kva_list->mymutex));
+
+		dmabuf = buf_va_info->dma_buf_putkva;
+		map.vaddr = ((void *)buf_va_info->kva);
+		map.is_iomem = false;
+		dma_buf_vunmap(dmabuf, &map);
+		dma_buf_end_cpu_access(dmabuf, DMA_BIDIRECTIONAL);
+
+		dma_buf_unmap_attachment(buf_va_info->attach, buf_va_info->sgt,
+			DMA_BIDIRECTIONAL);
+		dma_buf_detach(dmabuf, buf_va_info->attach);
+		fd_info->fds_size[i] = dmabuf->size;
+		dma_buf_put(dmabuf);
+		vfree(buf_va_info);
+		buf_va_info = NULL;
+		pr_debug("%s: fd(%d) size (0x%x) cache invalidated\n", __func__,
+					fd_info->fds[i], fd_info->fds_size[i]);
+	}
+
+	mtk_hcp_send_async(imgsys_pipe->imgsys_dev->scp_pdev,
+				HCP_IMGSYS_UVA_FDS_DEL_ID, fd_info,
+				sizeof(struct fd_info), 0);
+
+	return 0;
+}
+
+
+static int mtkdip_ioc_add_iova(struct v4l2_subdev *subdev, void *arg)
+{
+	struct mtk_imgsys_pipe *pipe = mtk_imgsys_subdev_to_pipe(subdev);
+	struct mtk_imgsys_dma_buf_iova_get_info *fd_iova;
+	struct fd_tbl *fd_tbl = (struct fd_tbl *)arg;
+	struct fd_info fd_info;
+	struct dma_buf *dmabuf;
+	struct dma_buf_attachment *attach;
+	struct sg_table *sgt;
+	dma_addr_t dma_addr;
+	unsigned int *kfd;
+	size_t size;
+	int i, ret;
+
+	if (!fd_tbl->fds) {
+		dev_info(pipe->imgsys_dev->dev, "%s:NULL usrptr\n", __func__);
+		return -EINVAL;
+	}
+
+	if (fd_tbl->fd_num > FD_MAX)
+		return -EINVAL;
+
+	size = sizeof(*kfd) * fd_tbl->fd_num;
+	kfd = vzalloc(size);
+	ret = copy_from_user(kfd, (void *)fd_tbl->fds, size);
+	if (ret != 0) {
+		dev_info(pipe->imgsys_dev->dev,
+			"[%s]%s:copy_from_user fail %d!!! size(%lx), num(%d)\n",
+			__func__,
+			pipe->desc->name, ret, size, fd_tbl->fd_num);
+
+		return -EINVAL;
+	}
+
+	fd_info.fd_num = fd_tbl->fd_num;
+
+	for (i = 0; i < fd_tbl->fd_num; i++) {
+
+		if (!kfd[i]) {
+			fd_info.fds[i] = 0;
+			fd_info.fds_size[i] = 0;
+			continue;
+		}
+
+		dmabuf = dma_buf_get(kfd[i]);
+		if (IS_ERR(dmabuf))
+			continue;
+#ifdef IMG_MEM_G_ID_DEBUG
+		spin_lock(&dmabuf->name_lock);
+		if (!strncmp("IMG_MEM_G_ID", dmabuf->name, 12))
+			dev_info(pipe->imgsys_dev->dev,
+			"[%s]%s: fd(%d) GCE buffer used\n", __func__, dmabuf->name, kfd[i]);
+		spin_unlock(&dmabuf->name_lock);
+#endif
+		attach = dma_buf_attach(dmabuf, pipe->imgsys_dev->dev);
+		if (IS_ERR(attach)) {
+			dma_buf_put(dmabuf);
+			pr_info("dma_buf_attach fail fd:%d\n", kfd[i]);
+			continue;
+		}
+
+		sgt = dma_buf_map_attachment(attach, DMA_BIDIRECTIONAL);
+		if (IS_ERR(sgt)) {
+			dma_buf_detach(dmabuf, attach);
+			dma_buf_put(dmabuf);
+			pr_info("%s:dma_buf_map_attachment sgt err: fd %d\n",
+						__func__, kfd[i]);
+			continue;
+		}
+
+		dma_addr = sg_dma_address(sgt->sgl);
+
+		fd_iova = vzalloc(sizeof(*fd_iova));
+		fd_iova->ionfd = kfd[i];
+		fd_iova->dma_addr = dma_addr;
+		fd_iova->dma_buf = dmabuf;
+		fd_iova->attach = attach;
+		fd_iova->sgt = sgt;
+		dev_dbg(pipe->imgsys_dev->dev,
+				"%s:dma_buf:%p,attach:%p,sgt:%p\n", __func__,
+			fd_iova->dma_buf, fd_iova->attach, fd_iova->sgt);
+
+		spin_lock(&pipe->iova_cache.lock);
+		list_add_tail(&fd_iova->list_entry, &pipe->iova_cache.list);
+		hash_add(pipe->iova_cache.hlists, &fd_iova->hnode, fd_iova->ionfd);
+		spin_unlock(&pipe->iova_cache.lock);
+		fd_info.fds_size[i] = dmabuf->size;
+		fd_info.fds[i] = kfd[i];
+		pr_debug("%s: fd(%d) size (0x%x) cache added\n", __func__,
+					fd_info.fds[i], fd_info.fds_size[i]);
+
+	}
+
+	mtk_hcp_send_async(pipe->imgsys_dev->scp_pdev,
+				HCP_IMGSYS_IOVA_FDS_ADD_ID, (void *)&fd_info,
+				sizeof(struct fd_info), 0);
+
+	vfree(kfd);
+
+	return 0;
+}
+
+static int mtkdip_ioc_del_iova(struct v4l2_subdev *subdev, void *arg)
+{
+	struct mtk_imgsys_pipe *pipe = mtk_imgsys_subdev_to_pipe(subdev);
+	struct mtk_imgsys_dma_buf_iova_get_info *iova_info, *tmp;
+	struct fd_tbl *fd_tbl = (struct fd_tbl *)arg;
+	struct fd_info fd_info;
+	struct dma_buf *dmabuf;
+	unsigned int *kfd;
+	size_t size;
+	int i, ret;
+
+	if ((!fd_tbl->fds) || (!fd_tbl->fd_num) || (fd_tbl->fd_num > FD_MAX)) {
+		return -EINVAL;
+		dev_dbg(pipe->imgsys_dev->dev, "%s:NULL usrptr\n", __func__);
+	}
+
+	size = sizeof(*kfd) * fd_tbl->fd_num;
+	kfd = vzalloc(size);
+	ret = copy_from_user(kfd, (void *)fd_tbl->fds, size);
+	if (ret != 0) {
+		dev_dbg(pipe->imgsys_dev->dev,
+			"[%s]%s:copy_from_user fail !!!\n",
+			__func__,
+			pipe->desc->name);
+
+		return -EINVAL;
+	}
+
+	fd_info.fd_num = fd_tbl->fd_num;
+
+	for (i = 0; i < fd_tbl->fd_num; i++) {
+		unsigned int fd = kfd[i];
+
+		if (!fd) {
+			fd_info.fds[i] = 0;
+			fd_info.fds_size[i] = 0;
+			continue;
+		}
+		dmabuf = dma_buf_get(fd);
+		if (IS_ERR(dmabuf))
+			continue;
+
+		list_for_each_entry_safe(iova_info, tmp,
+					&pipe->iova_cache.list, list_entry) {
+
+			if ((iova_info->ionfd != fd) &&
+						(iova_info->dma_buf != dmabuf))
+				continue;
+
+			mtk_imgsys_put_dma_buf(iova_info->dma_buf,
+					iova_info->attach,
+					iova_info->sgt);
+
+			spin_lock(&pipe->iova_cache.lock);
+			list_del(&iova_info->list_entry);
+			hash_del(&iova_info->hnode);
+			spin_unlock(&pipe->iova_cache.lock);
+			vfree(iova_info);
+		}
+		fd_info.fds_size[i] = dmabuf->size;
+		dma_buf_put(dmabuf);
+
+		fd_info.fds[i] = kfd[i];
+		pr_debug("%s: fd(%d) size (0x%x) cache invalidated\n", __func__,
+					fd_info.fds[i], fd_info.fds_size[i]);
+
+	}
+
+	mtk_hcp_send_async(pipe->imgsys_dev->scp_pdev,
+				HCP_IMGSYS_IOVA_FDS_DEL_ID, (void *)&fd_info,
+				sizeof(struct fd_info), 0);
+
+	vfree(kfd);
+
+	return 0;
+}
+
+static int mtkdip_ioc_s_init_info(struct v4l2_subdev *subdev, void *arg)
+{
+	/* struct mtk_imgsys_pipe *pipe = mtk_imgsys_subdev_to_pipe(subdev); */
+	struct init_info *info = (struct init_info *)arg;
+	struct mtk_imgsys_pipe *pipe;
+
+	pipe = container_of(subdev, struct mtk_imgsys_pipe, subdev);
+	pipe->init_info = *info;
+	/* TODO: HCP API */
+
+	pr_info("%s sensor_info width:%d height:%d\n", __func__,
+				info->sensor.full_wd, info->sensor.full_ht);
+
+	return 0;
+}
+
+static int mtkdip_ioc_set_control(struct v4l2_subdev *subdev, void *arg)
+{
+	struct mtk_imgsys_pipe *pipe = mtk_imgsys_subdev_to_pipe(subdev);
+	struct ctrl_info *ctrl = (struct ctrl_info *)arg;
+	int ret = -1;
+
+	if (!ctrl) {
+		return -EINVAL;
+		dev_dbg(pipe->imgsys_dev->dev, "%s:NULL usrptr\n", __func__);
+	}
+
+	pr_info("%s set control:%d, %d\n", __func__, ctrl->id, ctrl->value);
+
+	switch (ctrl->id) {
+	case V4L2_CID_IMGSYS_APU_DC:
+#ifdef SUPPORT_APU
+		ret = mtk_hcp_set_apu_dc(pipe->imgsys_dev->scp_pdev,
+			ctrl->value, sizeof(ctrl->value));
+#endif
+	default:
+	  pr_info("%s: non-supported ctrl id(%x)\n", __func__, ctrl->id);
+		break;
+	}
+
+	return ret;
+}
+
+long mtk_imgsys_subdev_ioctl(struct v4l2_subdev *subdev, unsigned int cmd,
+								void *arg)
+{
+
+	pr_debug("%s cmd: %d\n", __func__, cmd);
+
+	switch (cmd) {
+	case MTKDIP_IOC_ADD_KVA:
+		return mtkdip_ioc_add_kva(subdev, arg);
+	case MTKDIP_IOC_DEL_KVA:
+		return mtkdip_ioc_del_kva(subdev, arg);
+	case MTKDIP_IOC_ADD_IOVA:
+		return mtkdip_ioc_add_iova(subdev, arg);
+	case MTKDIP_IOC_DEL_IOVA:
+		return mtkdip_ioc_del_iova(subdev, arg);
+	case MTKDIP_IOC_S_INIT_INFO:
+		return mtkdip_ioc_s_init_info(subdev, arg);
+	case MTKDIP_IOC_SET_CONTROL:
+		return mtkdip_ioc_set_control(subdev, arg);
+	default:
+		pr_info("%s: non-supported cmd(%x)\n", __func__, cmd);
+		return -ENOTTY;
+	}
+
+	return 0;
+}
+
+#ifdef CONFIG_COMPAT
+long mtk_imgsys_subdev_compat_ioctl(struct v4l2_subdev *subdev, unsigned int cmd,
+								unsigned long arg)
+{
+	struct fd_info fd_data32;
+	//struct fd_tbl_compat fdtbl_data32;
+	struct fd_tbl fdtbl_data;
+	struct init_info init_data;
+	struct ctrl_info ctrl_data;
+
+	pr_debug("%s campat cmd: %d\n", __func__, cmd);
+	switch (cmd) {
+	case MTKDIP_IOC_ADD_KVA:
+	case MTKDIP_IOC_DEL_KVA:
+		if (copy_from_user(&fd_data32, (void __user *)arg, sizeof(fd_data32))) {
+			pr_info("Failed to copy from user_ptr=%pK size=%zu\n",
+				(void __user *)arg, sizeof(fd_data32));
+			return -EFAULT;
+		}
+		return subdev->ops->core->ioctl(subdev, cmd, &fd_data32);
+	case MTKDIP_IOC_ADD_IOVA:
+	case MTKDIP_IOC_DEL_IOVA:
+		if (copy_from_user(&fdtbl_data, (void __user *)arg, sizeof(fdtbl_data))) {
+			pr_info("Failed to copy from user_ptr=%pK size=%zu\n",
+				(void __user *)arg, sizeof(fdtbl_data));
+			return -EFAULT;
+		}
+		//fdtbl_data.fd_num = fdtbl_data32.fd_num;
+		//fdtbl_data.fds = compat_ptr(fdtbl_data32.fds);
+		return subdev->ops->core->ioctl(subdev, cmd, &fdtbl_data);
+	case MTKDIP_IOC_S_INIT_INFO:
+		if (copy_from_user(&init_data, (void __user *)arg, sizeof(init_data))) {
+			pr_info("Failed to copy from user_ptr=%pK size=%zu\n",
+				(void __user *)arg, sizeof(init_data));
+			return -EFAULT;
+		}
+		return subdev->ops->core->ioctl(subdev, cmd, &init_data);
+	case MTKDIP_IOC_SET_CONTROL:
+		if (copy_from_user(&ctrl_data, (void __user *)arg, sizeof(ctrl_data))) {
+			pr_info("Failed to copy from user_ptr=%pK size=%zu\n",
+				(void __user *)arg, sizeof(ctrl_data));
+			return -EFAULT;
+		}
+		return subdev->ops->core->ioctl(subdev, cmd, &ctrl_data);
+	default:
+		pr_info("%s: non-supported cmd(%x)\n", __func__, cmd);
+		return -ENOTTY;
+	}
+
+}
+#endif
+
+static struct media_request *mtk_imgsys_request_alloc(struct media_device *mdev)
+{
+	struct mtk_imgsys_request *imgsys_req = NULL;
+	struct media_request *req = NULL;
+	struct mtk_imgsys_dev *imgsys = mtk_imgsys_mdev_to_dev(mdev);
+	size_t bufs_size;
+
+	imgsys_req = vzalloc(sizeof(*imgsys_req));
+
+	if (imgsys_req) {
+		bufs_size = imgsys->imgsys_pipe[0].desc->total_queues *
+					sizeof(struct mtk_imgsys_dev_buffer *);
+		imgsys_req->buf_map = vzalloc(bufs_size);
+		req = &imgsys_req->req;
+	} else
+		pr_info("%s: vzalloc fails\n", __func__);
+
+	return req;
+}
+
+static void mtk_imgsys_request_free(struct media_request *req)
+{
+	struct mtk_imgsys_request *imgsys_req =
+					mtk_imgsys_media_req_to_imgsys_req(req);
+	if (imgsys_req->used)
+		wait_for_completion_timeout(&imgsys_req->done, HZ);
+	vfree(imgsys_req->buf_map);
+	vfree(imgsys_req);
+
+}
+
+static int mtk_imgsys_vb2_request_validate(struct media_request *req)
+{
+	struct media_request_object *obj;
+	struct mtk_imgsys_dev *imgsys_dev = mtk_imgsys_mdev_to_dev(req->mdev);
+	struct mtk_imgsys_request *imgsys_req =
+					mtk_imgsys_media_req_to_imgsys_req(req);
+	struct mtk_imgsys_pipe *pipe = NULL;
+	struct mtk_imgsys_pipe *pipe_prev = NULL;
+	struct mtk_imgsys_dev_buffer **buf_map = imgsys_req->buf_map;
+	int buf_count = 0;
+	int i;
+
+	imgsys_req->buf_fd = 0;
+	imgsys_req->buf_va_daddr = 0;
+	imgsys_req->buf_same = false;
+
+	for (i = 0; i < imgsys_dev->imgsys_pipe[0].desc->total_queues; i++)
+		buf_map[i] = NULL;
+
+	list_for_each_entry(obj, &req->objects, list) {
+		struct vb2_buffer *vb;
+		struct mtk_imgsys_dev_buffer *dev_buf;
+		struct mtk_imgsys_video_device *node;
+
+		if (!vb2_request_object_is_buffer(obj))
+			continue;
+
+		vb = container_of(obj, struct vb2_buffer, req_obj);
+		node = mtk_imgsys_vbq_to_node(vb->vb2_queue);
+		pipe = vb2_get_drv_priv(vb->vb2_queue);
+		if (pipe_prev && pipe != pipe_prev) {
+			dev_dbg(imgsys_dev->dev,
+				"%s:%s:%s:found buf of different pipes(%p,%p)\n",
+				__func__, node->desc->name,
+				req->debug_str, pipe, pipe_prev);
+			return -EINVAL;
+		}
+
+		pipe_prev = pipe;
+		dev_buf = mtk_imgsys_vb2_buf_to_dev_buf(vb);
+		imgsys_req->buf_map[node->desc->id] = dev_buf;
+		buf_count++;
+
+		dev_dbg(pipe->imgsys_dev->dev,
+			"%s:%s: added buf(%p) to pipe-job(%p), buf_count(%d)\n",
+			pipe->desc->name, node->desc->name, dev_buf,
+			imgsys_req, buf_count);
+	}
+
+	if (!pipe) {
+		dev_dbg(imgsys_dev->dev,
+			"%s: no buffer in the request(%p)\n",
+			req->debug_str, req);
+
+		return -EINVAL;
+	}
+
+	atomic_set(&imgsys_req->buf_count, buf_count);
+	atomic_set(&imgsys_req->swfrm_cnt, 0);
+	imgsys_req->id = mtk_imgsys_pipe_next_job_id(pipe);
+	imgsys_req->imgsys_pipe = pipe;
+	imgsys_req->tstate.time_sendtask = 0;
+	init_completion(&imgsys_req->done);
+	imgsys_req->used = true;
+	mtk_imgsys_pipe_debug_job(pipe, imgsys_req);
+
+	return vb2_request_validate(req);
+}
+
+static void mtk_imgsys_vb2_request_queue(struct media_request *req)
+{
+	struct mtk_imgsys_dev *imgsys_dev = mtk_imgsys_mdev_to_dev(req->mdev);
+	struct mtk_imgsys_request *imgsys_req =
+					mtk_imgsys_media_req_to_imgsys_req(req);
+	struct mtk_imgsys_pipe *pipe = imgsys_req->imgsys_pipe;
+	unsigned long flag;
+
+	spin_lock_irqsave(&pipe->pending_job_lock, flag);
+	list_add_tail(&imgsys_req->list, &pipe->pipe_job_pending_list);
+	pipe->num_pending_jobs++;
+	dev_dbg(imgsys_dev->dev,
+		"%s:%s: current num of pending jobs(%d)\n",
+		__func__, pipe->desc->name, pipe->num_pending_jobs);
+	spin_unlock_irqrestore(&pipe->pending_job_lock, flag);
+#if MTK_V4L2_BATCH_MODE_SUPPORT == 1
+	#ifdef BATCH_MODE_V3
+	imgsys_req->is_batch_mode = false;
+	dev_dbg(imgsys_dev->dev,
+		"%s:is_batch_mode(%d)\n",
+		__func__, imgsys_req->is_batch_mode);
+	#endif
+#endif
+	vb2_request_queue(req);
+}
+
+int mtk_imgsys_v4l2_fh_open(struct file *filp)
+{
+	struct mtk_imgsys_user *user;
+	struct mtk_imgsys_pipe *pipe = video_drvdata(filp);
+	//struct mtk_imgsys_video_device *node = mtk_imgsys_file_to_node(filp);
+	struct mtk_imgsys_dev *imgsys_dev = pipe->imgsys_dev;
+	static unsigned short count = MTK_IMGSYS_PIPE_ID_REPROCESS;
+
+	v4l2_fh_open(filp);
+	// keep fh in user structure
+	user = vzalloc(sizeof(*user));
+	user->fh = filp->private_data;
+	user->id = ++count;
+	init_waitqueue_head(&user->done_wq);
+	init_waitqueue_head(&user->enque_wq);
+	INIT_LIST_HEAD(&user->done_list);
+	user->dqdonestate = false;
+	user->state = DIP_STATE_INIT;
+	spin_lock_init(&user->lock);
+
+	// add user to list head
+	mutex_lock(&imgsys_dev->imgsys_users.user_lock);
+	list_add_tail(&user->entry, &imgsys_dev->imgsys_users.list);
+	mutex_unlock(&imgsys_dev->imgsys_users.user_lock);
+	pr_debug("%s: id(%d)\n", __func__, user->id);
+	return 0;
+}
+
+int mtk_imgsys_v4l2_fh_release(struct file *filp)
+{
+	struct mtk_imgsys_user *user;
+	struct mtk_imgsys_pipe *pipe = video_drvdata(filp);
+	struct mtk_imgsys_dev *imgsys_dev = pipe->imgsys_dev;
+	int ret = 0;
+
+	pr_debug("%s: filp(%p)\n", __func__, filp);
+	ret = get_user_by_file(filp, &user);
+	if (ret < 0) {
+		pr_info("%s: cannot find user\n", __func__);
+	} else {
+		// delete user to list head
+		mutex_lock(&imgsys_dev->imgsys_users.user_lock);
+		list_del(&user->entry);
+		mutex_unlock(&imgsys_dev->imgsys_users.user_lock);
+		pr_debug("%s: id(%d)\n", __func__, user->id);
+		vfree(user);
+	}
+	vb2_fop_release(filp);
+
+	return 0;
+}
+
+int mtk_imgsys_dev_media_register(struct device *dev,
+			       struct media_device *media_dev)
+{
+	int ret;
+
+	media_dev->dev = dev;
+	strlcpy(media_dev->model, MTK_DIP_DEV_DIP_MEDIA_MODEL_NAME,
+		sizeof(media_dev->model));
+	snprintf(media_dev->bus_info, sizeof(media_dev->bus_info),
+		 "platform:%s", dev_name(dev));
+	media_dev->hw_revision = 0;
+	media_dev->ops = &mtk_imgsys_media_req_ops;
+	media_device_init(media_dev);
+
+	ret = media_device_register(media_dev);
+	if (ret) {
+		dev_info(dev, "failed to register media device (%d)\n", ret);
+		media_device_unregister(media_dev);
+		media_device_cleanup(media_dev);
+		return ret;
+	}
+
+	dev_dbg(dev, "Registered media device: %s, %p", media_dev->model,
+		media_dev);
+
+	return 0;
+}
+
+static int mtk_imgsys_video_device_v4l2_register(struct mtk_imgsys_pipe *pipe,
+					   struct mtk_imgsys_video_device *node)
+{
+	struct vb2_queue *vbq = &node->dev_q.vbq;
+	struct video_device *vdev = &node->vdev;
+	struct media_link *link;
+	int ret;
+
+	mutex_init(&node->dev_q.lock);
+
+	vdev->device_caps = node->desc->cap;
+	vdev->ioctl_ops = node->desc->ops;
+	node->vdev_fmt.type = node->desc->buf_type;
+	mtk_imgsys_pipe_load_default_fmt(pipe, node, &node->vdev_fmt);
+
+	ret = media_entity_pads_init(&vdev->entity, 1, &node->vdev_pad);
+	if (ret) {
+		dev_info(pipe->imgsys_dev->dev,
+			"failed initialize media entity (%d)\n", ret);
+		goto err_mutex_destroy;
+	}
+
+	node->vdev_pad.flags = V4L2_TYPE_IS_OUTPUT(node->desc->buf_type) ?
+		MEDIA_PAD_FL_SOURCE : MEDIA_PAD_FL_SINK;
+
+	vbq->type = node->vdev_fmt.type;
+	vbq->io_modes = VB2_MMAP | VB2_DMABUF;
+	vbq->ops = node->desc->vb2_ops;
+	vbq->mem_ops = &vb2_dma_contig_memops;
+	vbq->supports_requests = true;
+	vbq->buf_struct_size = sizeof(struct mtk_imgsys_dev_buffer);
+	vbq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;
+	vbq->min_buffers_needed = 0;
+	vbq->drv_priv = pipe;
+	vbq->lock = &node->dev_q.lock;
+
+	ret = vb2_queue_init(vbq);
+	if (ret) {
+		dev_info(pipe->imgsys_dev->dev,
+			"%s:%s:%s: failed to init vb2 queue(%d)\n",
+			__func__, pipe->desc->name, node->desc->name,
+			ret);
+		goto err_media_entity_cleanup;
+	}
+
+	snprintf(vdev->name, sizeof(vdev->name), "%s %s", pipe->desc->name,
+		 node->desc->name);
+	vdev->entity.name = vdev->name;
+	vdev->entity.function = MEDIA_ENT_F_IO_V4L;
+	vdev->entity.ops = NULL;
+	vdev->release = video_device_release_empty;
+	vdev->fops = &mtk_imgsys_v4l2_fops;
+	vdev->lock = &node->dev_q.lock;
+	if (node->desc->supports_ctrls)
+		vdev->ctrl_handler = &node->ctrl_handler;
+	else
+		vdev->ctrl_handler = NULL;
+	vdev->v4l2_dev = &pipe->imgsys_dev->v4l2_dev;
+	vdev->queue = &node->dev_q.vbq;
+	vdev->vfl_dir = V4L2_TYPE_IS_OUTPUT(node->desc->buf_type) ?
+		VFL_DIR_TX : VFL_DIR_RX;
+
+	if (node->desc->smem_alloc) {
+		vdev->queue->dev = &pipe->imgsys_dev->scp_pdev->dev;
+		dev_dbg(pipe->imgsys_dev->dev,
+			"%s:%s: select smem_vb2_alloc_ctx(%p)\n",
+			pipe->desc->name, node->desc->name,
+			vdev->queue->dev);
+	} else {
+		vdev->queue->dev = pipe->imgsys_dev->dev;
+		dev_dbg(pipe->imgsys_dev->dev,
+			"%s:%s: select default_vb2_alloc_ctx(%p)\n",
+			pipe->desc->name, node->desc->name,
+			pipe->imgsys_dev->dev);
+	}
+
+	video_set_drvdata(vdev, pipe);
+
+	ret = video_register_device(vdev, VFL_TYPE_VIDEO, -1);
+	if (ret) {
+		dev_info(pipe->imgsys_dev->dev,
+			"failed to register video device (%d)\n", ret);
+		goto err_vb2_queue_release;
+	}
+	dev_dbg(pipe->imgsys_dev->dev, "registered vdev: %s\n",
+		vdev->name);
+
+	if (V4L2_TYPE_IS_OUTPUT(node->desc->buf_type))
+		ret = media_create_pad_link(&vdev->entity, 0,
+					    &pipe->subdev.entity,
+					    node->desc->id, node->flags);
+	else
+		ret = media_create_pad_link(&pipe->subdev.entity,
+					    node->desc->id, &vdev->entity,
+					    0, node->flags);
+	if (ret)
+		goto err_video_unregister_device;
+
+	vdev->intf_devnode = media_devnode_create(&pipe->imgsys_dev->mdev,
+						  MEDIA_INTF_T_V4L_VIDEO, 0,
+						  VIDEO_MAJOR, vdev->minor);
+	if (!vdev->intf_devnode) {
+		ret = -ENOMEM;
+		goto err_rm_links;
+	}
+
+	link = media_create_intf_link(&vdev->entity,
+				      &vdev->intf_devnode->intf,
+				      node->flags);
+	if (!link) {
+		ret = -ENOMEM;
+		goto err_rm_devnode;
+	}
+
+	return 0;
+
+err_rm_devnode:
+	media_devnode_remove(vdev->intf_devnode);
+
+err_rm_links:
+	media_entity_remove_links(&vdev->entity);
+
+err_video_unregister_device:
+	video_unregister_device(vdev);
+
+err_vb2_queue_release:
+	vb2_queue_release(&node->dev_q.vbq);
+
+err_media_entity_cleanup:
+	media_entity_cleanup(&node->vdev.entity);
+
+err_mutex_destroy:
+	mutex_destroy(&node->dev_q.lock);
+
+	return ret;
+}
+
+static int mtk_imgsys_pipe_v4l2_ctrl_init(struct mtk_imgsys_pipe *imgsys_pipe)
+{
+	int i, ret;
+	struct mtk_imgsys_video_device *ctrl_node;
+
+	for (i = 0; i < MTK_IMGSYS_VIDEO_NODE_ID_TOTAL_NUM; i++) {
+		ctrl_node = &imgsys_pipe->nodes[i];
+		if (!ctrl_node->desc->supports_ctrls)
+			continue;
+
+		v4l2_ctrl_handler_init(&ctrl_node->ctrl_handler, 1);
+		v4l2_ctrl_new_std(&ctrl_node->ctrl_handler,
+			&mtk_imgsys_video_device_ctrl_ops, V4L2_CID_ROTATE,
+				  0, 270, 90, 0);
+		ret = ctrl_node->ctrl_handler.error;
+		if (ret) {
+			dev_info(imgsys_pipe->imgsys_dev->dev,
+				"%s create rotate ctrl failed:(%d)",
+				ctrl_node->desc->name, ret);
+			goto err_free_ctrl_handlers;
+		}
+	}
+
+	return 0;
+
+err_free_ctrl_handlers:
+	for (; i >= 0; i--) {
+		ctrl_node = &imgsys_pipe->nodes[i];
+		if (!ctrl_node->desc->supports_ctrls)
+			continue;
+		v4l2_ctrl_handler_free(&ctrl_node->ctrl_handler);
+	}
+
+	return ret;
+}
+
+static void mtk_imgsys_pipe_v4l2_ctrl_release(
+					struct mtk_imgsys_pipe *imgsys_pipe)
+{
+	struct mtk_imgsys_video_device *ctrl_node =
+		&imgsys_pipe->nodes[MTK_IMGSYS_VIDEO_NODE_ID_WROT_A_CAPTURE];
+
+	v4l2_ctrl_handler_free(&ctrl_node->ctrl_handler);
+}
+
+int mtk_imgsys_pipe_v4l2_register(struct mtk_imgsys_pipe *pipe,
+			       struct media_device *media_dev,
+			       struct v4l2_device *v4l2_dev)
+{
+	int i, ret;
+
+	ret = mtk_imgsys_pipe_v4l2_ctrl_init(pipe);
+	if (ret) {
+		dev_info(pipe->imgsys_dev->dev,
+			"%s: failed(%d) to initialize ctrls\n",
+			pipe->desc->name, ret);
+
+		return ret;
+	}
+
+	pipe->streaming = 0;
+
+	/* Initialize subdev media entity */
+	pipe->subdev_pads = devm_kcalloc(pipe->imgsys_dev->dev,
+					 pipe->desc->total_queues,
+					 sizeof(*pipe->subdev_pads),
+					 GFP_KERNEL);
+	if (!pipe->subdev_pads) {
+		dev_info(pipe->imgsys_dev->dev,
+			"failed to alloc pipe->subdev_pads (%d)\n", ret);
+		ret = -ENOMEM;
+		goto err_release_ctrl;
+	}
+	ret = media_entity_pads_init(&pipe->subdev.entity,
+				     pipe->desc->total_queues,
+				     pipe->subdev_pads);
+	if (ret) {
+		dev_info(pipe->imgsys_dev->dev,
+			"failed initialize subdev media entity (%d)\n", ret);
+		goto err_free_subdev_pads;
+	}
+
+	/* Initialize subdev */
+	v4l2_subdev_init(&pipe->subdev, &mtk_imgsys_subdev_ops);
+
+	pipe->subdev.entity.function =
+		MEDIA_ENT_F_PROC_VIDEO_PIXEL_FORMATTER;
+	pipe->subdev.entity.ops = &mtk_imgsys_media_ops;
+	pipe->subdev.flags =
+		V4L2_SUBDEV_FL_HAS_DEVNODE | V4L2_SUBDEV_FL_HAS_EVENTS;
+	pipe->subdev.ctrl_handler = NULL;
+
+	for (i = 0; i < pipe->desc->total_queues; i++)
+		pipe->subdev_pads[pipe->nodes[i].desc->id].flags =
+			V4L2_TYPE_IS_OUTPUT(pipe->nodes[i].desc->buf_type) ?
+			MEDIA_PAD_FL_SINK : MEDIA_PAD_FL_SOURCE;
+
+	snprintf(pipe->subdev.name, sizeof(pipe->subdev.name),
+		 "%s", pipe->desc->name);
+	v4l2_set_subdevdata(&pipe->subdev, pipe);
+
+	ret = v4l2_device_register_subdev(&pipe->imgsys_dev->v4l2_dev,
+					  &pipe->subdev);
+	if (ret) {
+		dev_info(pipe->imgsys_dev->dev,
+			"failed initialize subdev (%d)\n", ret);
+		goto err_media_entity_cleanup;
+	}
+
+	dev_dbg(pipe->imgsys_dev->dev,
+		"register subdev: %s, ctrl_handler %p\n",
+		 pipe->subdev.name, pipe->subdev.ctrl_handler);
+
+	/* Create video nodes and links */
+	for (i = 0; i < pipe->desc->total_queues; i++) {
+		ret = mtk_imgsys_video_device_v4l2_register(pipe,
+							 &pipe->nodes[i]);
+		if (ret)
+			goto err_unregister_subdev;
+	}
+
+	return 0;
+
+err_unregister_subdev:
+	v4l2_device_unregister_subdev(&pipe->subdev);
+
+err_media_entity_cleanup:
+	media_entity_cleanup(&pipe->subdev.entity);
+
+err_free_subdev_pads:
+	devm_kfree(pipe->imgsys_dev->dev, pipe->subdev_pads);
+
+err_release_ctrl:
+	mtk_imgsys_pipe_v4l2_ctrl_release(pipe);
+
+	return ret;
+}
+
+void mtk_imgsys_pipe_v4l2_unregister(struct mtk_imgsys_pipe *pipe)
+{
+	unsigned int i;
+
+	for (i = 0; i < pipe->desc->total_queues; i++) {
+		video_unregister_device(&pipe->nodes[i].vdev);
+		vb2_queue_release(&pipe->nodes[i].dev_q.vbq);
+		media_entity_cleanup(&pipe->nodes[i].vdev.entity);
+		mutex_destroy(&pipe->nodes[i].dev_q.lock);
+	}
+
+	v4l2_device_unregister_subdev(&pipe->subdev);
+	media_entity_cleanup(&pipe->subdev.entity);
+	mtk_imgsys_pipe_v4l2_ctrl_release(pipe);
+}
+
+static void mtk_imgsys_dev_media_unregister(struct mtk_imgsys_dev *imgsys_dev)
+{
+	media_device_unregister(&imgsys_dev->mdev);
+	media_device_cleanup(&imgsys_dev->mdev);
+}
+
+static int mtk_imgsys_dev_v4l2_init(struct mtk_imgsys_dev *imgsys_dev)
+{
+	struct media_device *media_dev = &imgsys_dev->mdev;
+	struct v4l2_device *v4l2_dev = &imgsys_dev->v4l2_dev;
+	int i;
+	int ret;
+
+	ret = mtk_imgsys_dev_media_register(imgsys_dev->dev, media_dev);
+	if (ret) {
+		dev_info(imgsys_dev->dev,
+			"%s: media device register failed(%d)\n",
+			__func__, ret);
+		return ret;
+	}
+
+	v4l2_dev->mdev = media_dev;
+	v4l2_dev->ctrl_handler = NULL;
+
+	ret = v4l2_device_register(imgsys_dev->dev, v4l2_dev);
+	if (ret) {
+		dev_info(imgsys_dev->dev,
+			"%s: v4l2 device register failed(%d)\n",
+			__func__, ret);
+		goto err_release_media_device;
+	}
+
+	for (i = 0; i < MTK_IMGSYS_PIPE_ID_TOTAL_NUM; i++) {
+		ret = mtk_imgsys_pipe_init(imgsys_dev,
+					&imgsys_dev->imgsys_pipe[i],
+					&imgsys_dev->cust_pipes[i]);
+		if (ret) {
+			dev_info(imgsys_dev->dev,
+				"%s: Pipe id(%d) init failed(%d)\n",
+				imgsys_dev->imgsys_pipe[i].desc->name,
+				i, ret);
+			goto err_release_pipe;
+		}
+	}
+
+	ret = v4l2_device_register_subdev_nodes(&imgsys_dev->v4l2_dev);
+	if (ret) {
+		dev_info(imgsys_dev->dev,
+			"failed to register subdevs (%d)\n", ret);
+		goto err_release_pipe;
+	}
+
+	return 0;
+
+err_release_pipe:
+	for (i--; i >= 0; i--)
+		mtk_imgsys_pipe_release(&imgsys_dev->imgsys_pipe[i]);
+
+	v4l2_device_unregister(v4l2_dev);
+
+err_release_media_device:
+	mtk_imgsys_dev_media_unregister(imgsys_dev);
+
+	return ret;
+}
+
+void mtk_imgsys_dev_v4l2_release(struct mtk_imgsys_dev *imgsys_dev)
+{
+	int i;
+
+	for (i = 0; i < MTK_IMGSYS_PIPE_ID_TOTAL_NUM; i++)
+		mtk_imgsys_pipe_release(&imgsys_dev->imgsys_pipe[i]);
+
+	v4l2_device_unregister(&imgsys_dev->v4l2_dev);
+	media_device_unregister(&imgsys_dev->mdev);
+	media_device_cleanup(&imgsys_dev->mdev);
+}
+
+static int mtk_imgsys_res_init(struct platform_device *pdev,
+			    struct mtk_imgsys_dev *imgsys_dev)
+{
+	int ret;
+	unsigned int i;
+
+	/* ToDo: porting mdp3
+	 * imgsys_dev->mdp_pdev = mdp_get_plat_device(pdev);
+	 * if (!imgsys_dev->mdp_pdev) {
+	 *	dev_dbg(imgsys_dev->dev,
+	 *	"%s: failed to get MDP device\n",
+	 *		__func__);
+	 *	return -EINVAL;
+	 * }
+	 */
+
+	imgsys_dev->mdpcb_wq =
+		alloc_ordered_workqueue("%s",
+					__WQ_LEGACY | WQ_MEM_RECLAIM |
+					WQ_FREEZABLE,
+					"imgsys_mdp_callback");
+	if (!imgsys_dev->mdpcb_wq) {
+		dev_info(imgsys_dev->dev,
+			"%s: unable to alloc mdpcb workqueue\n", __func__);
+		ret = -ENOMEM;
+		goto destroy_mdpcb_wq;
+	}
+
+	imgsys_dev->enqueue_wq =
+		alloc_ordered_workqueue("%s",
+					__WQ_LEGACY | WQ_MEM_RECLAIM |
+					WQ_FREEZABLE | WQ_HIGHPRI,
+					"imgsys_enqueue");
+	if (!imgsys_dev->enqueue_wq) {
+		dev_info(imgsys_dev->dev,
+			"%s: unable to alloc enqueue workqueue\n", __func__);
+		ret = -ENOMEM;
+		goto destroy_enqueue_wq;
+	}
+
+
+	imgsys_dev->composer_wq =
+		alloc_ordered_workqueue("%s",
+					__WQ_LEGACY | WQ_MEM_RECLAIM |
+					WQ_FREEZABLE,
+					"imgsys_composer");
+	if (!imgsys_dev->composer_wq) {
+		dev_info(imgsys_dev->dev,
+			"%s: unable to alloc composer workqueue\n", __func__);
+		ret = -ENOMEM;
+		goto destroy_dip_composer_wq;
+	}
+
+	for (i = 0; i < RUNNER_WQ_NR; i++) {
+		imgsys_dev->mdp_wq[i] =
+			alloc_ordered_workqueue("imgsys_runner_%d",
+					__WQ_LEGACY | WQ_MEM_RECLAIM |
+					WQ_FREEZABLE,
+					i);
+		if (!imgsys_dev->mdp_wq[i]) {
+			dev_info(imgsys_dev->dev,
+				"%s: unable to alloc imgsys_runner\n", __func__);
+			ret = -ENOMEM;
+			goto destroy_dip_runner_wq;
+		}
+	}
+
+	init_waitqueue_head(&imgsys_dev->flushing_waitq);
+
+	return 0;
+
+destroy_dip_runner_wq:
+	for (i = 0; i < RUNNER_WQ_NR; i++)
+		destroy_workqueue(imgsys_dev->mdp_wq[i]);
+
+destroy_dip_composer_wq:
+	destroy_workqueue(imgsys_dev->composer_wq);
+
+destroy_mdpcb_wq:
+	destroy_workqueue(imgsys_dev->mdpcb_wq);
+
+destroy_enqueue_wq:
+	destroy_workqueue(imgsys_dev->enqueue_wq);
+
+	return ret;
+}
+
+static void mtk_imgsys_res_release(struct mtk_imgsys_dev *imgsys_dev)
+{
+	int i;
+
+	for (i = 0; i < RUNNER_WQ_NR; i++) {
+		flush_workqueue(imgsys_dev->mdp_wq[i]);
+		destroy_workqueue(imgsys_dev->mdp_wq[i]);
+		imgsys_dev->mdp_wq[i] = NULL;
+	}
+
+	flush_workqueue(imgsys_dev->mdpcb_wq);
+	destroy_workqueue(imgsys_dev->mdpcb_wq);
+	imgsys_dev->mdpcb_wq = NULL;
+
+	flush_workqueue(imgsys_dev->composer_wq);
+	destroy_workqueue(imgsys_dev->composer_wq);
+	imgsys_dev->composer_wq = NULL;
+
+	flush_workqueue(imgsys_dev->enqueue_wq);
+	destroy_workqueue(imgsys_dev->enqueue_wq);
+	imgsys_dev->enqueue_wq = NULL;
+
+	atomic_set(&imgsys_dev->num_composing, 0);
+	atomic_set(&imgsys_dev->imgsys_enqueue_cnt, 0);
+	atomic_set(&imgsys_dev->imgsys_user_cnt, 0);
+
+	mutex_destroy(&imgsys_dev->imgsys_users.user_lock);
+}
+
+static int __maybe_unused mtk_imgsys_pm_suspend(struct device *dev)
+{
+	struct mtk_imgsys_dev *imgsys_dev = dev_get_drvdata(dev);
+	int ret, num;
+
+	ret = wait_event_timeout
+		(imgsys_dev->flushing_waitq,
+		 !(num = atomic_read(&imgsys_dev->num_composing)),
+		 msecs_to_jiffies(1000 / 30 * DIP_COMPOSING_MAX_NUM * 3));
+	if (!ret && num) {
+		dev_info(dev, "%s: flushing SCP job timeout, num(%d)\n",
+			__func__, num);
+
+		return -EBUSY;
+	}
+#ifdef NEED_PM
+
+	if (pm_runtime_suspended(dev)) {
+		dev_info(dev, "%s: pm_runtime_suspended is true, no action\n",
+			__func__);
+		return 0;
+	}
+
+	ret = pm_runtime_put_sync(dev);
+	if (ret) {
+		dev_info(dev, "%s: pm_runtime_put_sync failed:(%d)\n",
+			__func__, ret);
+		return ret;
+	}
+#endif
+	return 0;
+}
+
+static int __maybe_unused mtk_imgsys_pm_resume(struct device *dev)
+{
+#ifdef NEED_PM
+	int ret;
+
+	if (pm_runtime_suspended(dev)) {
+		dev_info(dev, "%s: pm_runtime_suspended is true, no action\n",
+			__func__);
+		return 0;
+	}
+
+	ret = pm_runtime_get_sync(dev);
+	if (ret) {
+		dev_info(dev, "%s: pm_runtime_get_sync failed:(%d)\n",
+			__func__, ret);
+		return ret;
+	}
+#endif
+	return 0;
+}
+
+
+#if IS_ENABLED(CONFIG_PM)
+static int imgsys_pm_event(struct notifier_block *notifier,
+			unsigned long pm_event, void *unused)
+{
+	struct timespec64 ts;
+	struct rtc_time tm;
+
+	ktime_get_ts64(&ts);
+	rtc_time64_to_tm(ts.tv_sec, &tm);
+
+	switch (pm_event) {
+	case PM_HIBERNATION_PREPARE:
+		return NOTIFY_DONE;
+	case PM_RESTORE_PREPARE:
+		return NOTIFY_DONE;
+	case PM_POST_HIBERNATION:
+		return NOTIFY_DONE;
+	case PM_SUSPEND_PREPARE: /*enter suspend*/
+		mtk_imgsys_pm_suspend(imgsys_pm_dev);
+		return NOTIFY_DONE;
+	case PM_POST_SUSPEND:    /*after resume*/
+		mtk_imgsys_pm_resume(imgsys_pm_dev);
+		return NOTIFY_DONE;
+	}
+
+	return NOTIFY_OK;
+}
+
+static struct notifier_block imgsys_notifier_block = {
+	.notifier_call = imgsys_pm_event,
+	.priority = 0,
+};
+#endif
+
+
+static int mtk_imgsys_probe(struct platform_device *pdev)
+{
+	struct mtk_imgsys_dev *imgsys_dev;
+	const struct cust_data *data;
+#if MTK_CM4_SUPPORT
+	phandle rproc_phandle;
+#endif
+	struct device_link *link;
+	int larbs_num, i;
+	int ret;
+
+	imgsys_dev = devm_kzalloc(&pdev->dev, sizeof(*imgsys_dev), GFP_KERNEL);
+	if (!imgsys_dev)
+		return -ENOMEM;
+
+
+	data = of_device_get_match_data(&pdev->dev);
+
+	init_imgsys_pipeline(data);
+
+	imgsys_dev->cust_pipes = data->pipe_settings;
+	imgsys_dev->modules = data->imgsys_modules;
+
+	imgsys_dev->dev = &pdev->dev;
+	imgsys_dev->imgsys_resource = &pdev->resource[0];
+	dev_set_drvdata(&pdev->dev, imgsys_dev);
+	imgsys_dev->imgsys_stream_cnt = 0;
+	imgsys_dev->clks = data->clks;
+	imgsys_dev->num_clks = data->clk_num;
+	imgsys_dev->num_mods = data->mod_num;
+	imgsys_dev->dump = data->dump;
+#ifdef CLK_READY
+	ret = devm_clk_bulk_get(&pdev->dev, imgsys_dev->num_clks,
+							imgsys_dev->clks);
+	if (ret) {
+		dev_info(&pdev->dev, "Failed to get clks:%d\n",
+			ret);
+	}
+#endif
+	if (dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(34)))
+		dev_info(&pdev->dev, "%s:No DMA available\n", __func__);
+
+	if (!pdev->dev.dma_parms) {
+		pdev->dev.dma_parms =
+			devm_kzalloc(imgsys_dev->dev, sizeof(*pdev->dev.dma_parms), GFP_KERNEL);
+	}
+	if (pdev->dev.dma_parms) {
+		ret = dma_set_max_seg_size(imgsys_dev->dev, (unsigned int)DMA_BIT_MASK(34));
+		if (ret)
+			dev_info(imgsys_dev->dev, "Failed to set DMA segment size\n");
+	}
+
+#if MTK_CM4_SUPPORT
+	imgsys_dev->scp_pdev = scp_get_pdev(pdev);
+	if (!imgsys_dev->scp_pdev) {
+		dev_info(imgsys_dev->dev,
+			"%s: failed to get scp device\n",
+			__func__);
+		return -EINVAL;
+	}
+
+	if (of_property_read_u32(imgsys_dev->dev->of_node, "mediatek,scp",
+				 &rproc_phandle)) {
+		dev_info(imgsys_dev->dev,
+			"%s: could not get scp device\n",
+			__func__);
+		return -EINVAL;
+	}
+
+	imgsys_dev->rproc_handle = rproc_get_by_phandle(rproc_phandle);
+	if (!imgsys_dev->rproc_handle) {
+		dev_info(imgsys_dev->dev,
+			"%s: could not get DIP's rproc_handle\n",
+			__func__);
+		return -EINVAL;
+	}
+#else
+	imgsys_dev->scp_pdev = mtk_hcp_get_plat_device(pdev);
+	if (!imgsys_dev->scp_pdev) {
+		dev_info(imgsys_dev->dev,
+			"%s: failed to get hcp device\n",
+			__func__);
+		return -EINVAL;
+	}
+#endif
+
+	larbs_num = of_count_phandle_with_args(pdev->dev.of_node,
+						"mediatek,larbs", NULL);
+	dev_info(imgsys_dev->dev, "%d larbs to be added", larbs_num);
+	for (i = 0; i < larbs_num; i++) {
+		struct device_node *larb_node;
+		struct platform_device *larb_pdev;
+
+		larb_node = of_parse_phandle(pdev->dev.of_node, "mediatek,larbs", i);
+		if (!larb_node) {
+			dev_info(imgsys_dev->dev,
+				"%s: %d larb node not found\n", __func__, i);
+			continue;
+		}
+
+		larb_pdev = of_find_device_by_node(larb_node);
+		if (!larb_pdev) {
+			of_node_put(larb_node);
+			dev_info(imgsys_dev->dev,
+				"%s: %d larb device not found\n", __func__, i);
+			continue;
+		}
+		of_node_put(larb_node);
+
+		link = device_link_add(&pdev->dev, &larb_pdev->dev,
+				DL_FLAG_PM_RUNTIME | DL_FLAG_STATELESS);
+		if (!link)
+			dev_info(imgsys_dev->dev, "unable to link SMI LARB idx %d\n", i);
+
+	}
+
+	atomic_set(&imgsys_dev->imgsys_enqueue_cnt, 0);
+	atomic_set(&imgsys_dev->imgsys_user_cnt, 0);
+	atomic_set(&imgsys_dev->num_composing, 0);
+	mutex_init(&imgsys_dev->hw_op_lock);
+	/* Limited by the co-processor side's stack size */
+	sema_init(&imgsys_dev->sem, DIP_COMPOSING_MAX_NUM);
+
+	ret = mtk_imgsys_hw_working_buf_pool_init(imgsys_dev);
+	if (ret) {
+		dev_info(&pdev->dev, "working buffer init failed(%d)\n", ret);
+		return ret;
+	}
+
+	ret = mtk_imgsys_dev_v4l2_init(imgsys_dev);
+	if (ret) {
+		dev_info(&pdev->dev, "v4l2 init failed(%d)\n", ret);
+
+		goto err_release_working_buf_pool;
+	}
+
+	ret = mtk_imgsys_res_init(pdev, imgsys_dev);
+	if (ret) {
+		dev_info(imgsys_dev->dev,
+			"%s: mtk_imgsys_res_init failed(%d)\n", __func__, ret);
+
+		ret = -EBUSY;
+		goto err_release_deinit_v4l2;
+	}
+
+	imgsys_cmdq_init(imgsys_dev, 1);
+
+	#if DVFS_QOS_READY
+	mtk_imgsys_mmdvfs_init(imgsys_dev);
+
+	mtk_imgsys_mmqos_init(imgsys_dev);
+	#endif
+
+	//pm_runtime_set_autosuspend_delay(&pdev->dev, 3000);
+	//pm_runtime_use_autosuspend(&pdev->dev);
+	pm_runtime_enable(&pdev->dev);
+	INIT_LIST_HEAD(&imgsys_dev->imgsys_users.list);
+	mutex_init(&imgsys_dev->imgsys_users.user_lock);
+
+	imgsys_pm_dev = &pdev->dev;
+#if IS_ENABLED(CONFIG_PM)
+	ret = register_pm_notifier(&imgsys_notifier_block);
+	if (ret) {
+		dev_info(imgsys_dev->dev, "failed to register notifier block.\n");
+		return ret;
+	}
+#endif
+	ret = platform_driver_register(&mtk_imgsys_larb_driver);
+	if (ret) {
+		dev_info(imgsys_dev->dev, "register mtk_imgsys_larb_driver fail\n");
+	}
+	return 0;
+
+err_release_deinit_v4l2:
+	mtk_imgsys_dev_v4l2_release(imgsys_dev);
+err_release_working_buf_pool:
+	mtk_imgsys_hw_working_buf_pool_release(imgsys_dev);
+	return ret;
+}
+
+static int mtk_imgsys_remove(struct platform_device *pdev)
+{
+	struct mtk_imgsys_dev *imgsys_dev = dev_get_drvdata(&pdev->dev);
+
+	mtk_imgsys_res_release(imgsys_dev);
+	pm_runtime_disable(&pdev->dev);
+	platform_driver_unregister(&mtk_imgsys_larb_driver);
+	mtk_imgsys_dev_v4l2_release(imgsys_dev);
+	mtk_imgsys_hw_working_buf_pool_release(imgsys_dev);
+	mutex_destroy(&imgsys_dev->hw_op_lock);
+	#if DVFS_QOS_READY
+	mtk_imgsys_mmqos_uninit(imgsys_dev);
+	mtk_imgsys_mmdvfs_uninit(imgsys_dev);
+	#endif
+	imgsys_cmdq_release(imgsys_dev);
+
+	return 0;
+}
+
+static int __maybe_unused mtk_imgsys_runtime_suspend(struct device *dev)
+{
+	struct mtk_imgsys_dev *imgsys_dev = dev_get_drvdata(dev);
+
+#if MTK_CM4_SUPPORT
+	rproc_shutdown(imgsys_dev->rproc_handle);
+#endif
+
+	clk_bulk_disable_unprepare(imgsys_dev->num_clks,
+				   imgsys_dev->clks);
+
+	dev_dbg(dev, "%s: disabled imgsys clks\n", __func__);
+
+	return 0;
+}
+
+static int __maybe_unused mtk_imgsys_runtime_resume(struct device *dev)
+{
+	struct mtk_imgsys_dev *imgsys_dev = dev_get_drvdata(dev);
+	int ret;
+
+	ret = clk_bulk_prepare_enable(imgsys_dev->num_clks,
+				      imgsys_dev->clks);
+	if (ret) {
+		dev_info(imgsys_dev->dev,
+			"%s: failed to enable dip clks(%d)\n",
+			__func__, ret);
+		return ret;
+	}
+
+	dev_dbg(dev, "%s: enabled imgsys clks\n", __func__);
+
+#if MTK_CM4_SUPPORT
+	ret = rproc_boot(imgsys_dev->rproc_handle);
+#endif
+	if (ret) {
+#if MTK_CM4_SUPPORT
+		dev_info(dev, "%s: FW load failed(rproc:%p):%d\n",
+			__func__, imgsys_dev->rproc_handle,	ret);
+#endif
+		clk_bulk_disable_unprepare(imgsys_dev->num_clks,
+					   imgsys_dev->clks);
+
+		return ret;
+	}
+#if MTK_CM4_SUPPORT
+	dev_dbg(dev, "%s: FW loaded(rproc:%p)\n",
+		__func__, imgsys_dev->rproc_handle);
+#endif
+
+	return 0;
+}
+
+static const struct dev_pm_ops mtk_imgsys_pm_ops = {
+	SET_RUNTIME_PM_OPS(mtk_imgsys_runtime_suspend,
+						mtk_imgsys_runtime_resume, NULL)
+};
+
+static const struct of_device_id mtk_imgsys_of_match[] = {
+	{ .compatible = "mediatek,imgsys", .data = (void *)&imgsys_data},
+	{}
+};
+MODULE_DEVICE_TABLE(of, mtk_imgsys_of_match);
+
+static struct platform_driver mtk_imgsys_driver = {
+	.probe   = mtk_imgsys_probe,
+	.remove  = mtk_imgsys_remove,
+	.driver  = {
+		.name = "camera-dip",
+		.owner	= THIS_MODULE,
+		.pm = &mtk_imgsys_pm_ops,
+		.of_match_table = of_match_ptr(mtk_imgsys_of_match),
+	}
+};
+
+module_platform_driver(mtk_imgsys_driver);
+
+MODULE_AUTHOR("Frederic Chen <frederic.chen@mediatek.com>");
+MODULE_LICENSE("GPL v2");
+MODULE_DESCRIPTION("Mediatek DIP driver");
+
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/imgsys/mtk_imgsys-worker.c b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/mtk_imgsys-worker.c
new file mode 100755
index 0000000000000000000000000000000000000000..88de6ab34ead3d2c6c810cf28895daa7f0edbb57
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/mtk_imgsys-worker.c
@@ -0,0 +1,198 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2018 MediaTek Inc.
+ *
+ * Author: Johnson-CH Chiu <johnson-ch.chiu@mediatek.com>
+ *
+ */
+#include <linux/device.h>
+#include <linux/kthread.h>
+#include <linux/sched.h>
+
+#include "mtk_imgsys-worker.h"
+#include "mtk_imgsys-trace.h"
+
+int imgsys_queue_init(struct imgsys_queue *que, struct device *dev, char *name)
+{
+	int ret = 0;
+
+	if ((!que) || (!dev)) {
+		ret = -1;
+		goto EXIT;
+	}
+
+	que->name = name;
+	que->dev = dev;
+	INIT_LIST_HEAD(&que->queue);
+	init_waitqueue_head(&que->wq);
+	init_waitqueue_head(&que->dis_wq);
+	spin_lock_init(&que->lock);
+	atomic_set(&que->nr, 0);
+	que->peak = 0;
+	mutex_init(&que->task_lock);
+
+EXIT:
+	return ret;
+}
+
+static int worker_func(void *data)
+{
+	struct imgsys_queue *head = data;
+	struct imgsys_work *node;
+	struct list_head *list;
+	u64 start;
+	u64 end;
+
+	while (1) {
+		dev_dbg(head->dev, "%s: %s kthread sleeps\n", __func__,
+								head->name);
+		wait_event_interruptible(head->wq,
+			atomic_read(&head->nr) || atomic_read(&head->disable));
+		dev_dbg(head->dev, "%s: %s kthread wakes dis/nr(%d/%d)\n", __func__,
+				head->name, atomic_read(&head->disable), atomic_read(&head->nr));
+
+		spin_lock(&head->lock);
+		if (atomic_read(&head->disable) || !atomic_read(&head->nr)) {
+			spin_unlock(&head->lock);
+			dev_info(head->dev, "%s: %s: nr(%d) dis(%d)\n", __func__,
+					head->name, atomic_read(&head->nr),
+						atomic_read(&head->disable));
+			goto next;
+		}
+
+		list = head->queue.next;
+		list_del(list);
+		atomic_dec(&head->nr);
+		spin_unlock(&head->lock);
+
+		node = list_entry(list, struct imgsys_work, entry);
+
+		IMGSYS_SYSTRACE_BEGIN("%s work:%p nr:%d\n", __func__, node, atomic_read(&head->nr));
+
+		start = ktime_get_boottime_ns();
+		if (node->run)
+			node->run(node);
+		end = ktime_get_boottime_ns();
+		if ((end - start) > 2000000)
+			dev_info(head->dev, "%s: work run time %lld > 2ms\n",
+			__func__, (end - start));
+
+		IMGSYS_SYSTRACE_END();
+
+next:
+		if (kthread_should_stop()) {
+			dev_dbg(head->dev, "%s: %s kthread exits\n", __func__, head->name);
+			break;
+		}
+	}
+
+	dev_info(head->dev, "%s: %s exited\n", __func__, head->name);
+
+	return 0;
+}
+
+int imgsys_queue_enable(struct imgsys_queue *que)
+{
+	if (!que)
+		return -1;
+
+	mutex_lock(&que->task_lock);
+	que->task = kthread_create(worker_func, (void *)que, que->name);
+	if (IS_ERR(que->task)) {
+		mutex_unlock(&que->task_lock);
+		dev_info(que->dev, "%s: kthread_run failed\n", __func__);
+		return PTR_ERR(que->task);
+	}
+	sched_set_normal(que->task, -20);
+	get_task_struct(que->task);
+	atomic_set(&que->disable, 0);
+	wake_up_process(que->task);
+	mutex_unlock(&que->task_lock);
+
+	return 0;
+}
+
+#define TIMEOUT (300)
+int imgsys_queue_disable(struct imgsys_queue *que)
+{
+	int ret;
+
+	if ((!que) || IS_ERR(que->task))
+		return -1;
+
+	ret = wait_event_interruptible_timeout(que->dis_wq, !atomic_read(&que->nr),
+						msecs_to_jiffies(TIMEOUT));
+	if (!ret)
+		dev_info(que->dev, "%s: timeout", __func__);
+	else if (ret == -ERESTARTSYS)
+		dev_info(que->dev, "%s: signal interrupt", __func__);
+
+	mutex_lock(&que->task_lock);
+
+	atomic_set(&que->disable, 1);
+	ret = kthread_stop(que->task);
+	if (ret)
+		dev_info(que->dev, "%s: kthread_stop failed %d\n",
+						__func__, ret);
+
+	put_task_struct(que->task);
+	que->task = NULL;
+
+	dev_info(que->dev, "%s: kthread(%s) queue peak(%d)\n",
+		__func__, que->name, que->peak);
+
+	mutex_unlock(&que->task_lock);
+
+	mutex_destroy(&que->task_lock);
+
+	return ret;
+}
+
+int imgsys_queue_add(struct imgsys_queue *que, struct imgsys_work *work)
+{
+	int size;
+
+	if ((!que) || (!work) || (!que->task))
+		return -1;
+
+	if (!que->task) {
+		dev_info(que->dev, "%s %s not enabled\n", __func__, que->name);
+		return -1;
+	}
+
+	if (!work->run)
+		dev_info(que->dev, "%s no work func added\n", __func__);
+
+	spin_lock(&que->lock);
+	list_add_tail(&work->entry, &que->queue);
+	size = atomic_inc_return(&que->nr);
+	if (size > que->peak)
+		que->peak = size;
+	spin_unlock(&que->lock);
+
+	dev_dbg(que->dev, "%s try wakeup dis/nr(%d/%d)\n", __func__,
+		atomic_read(&que->disable), atomic_read(&que->nr));
+	wake_up(&que->wq);
+
+	dev_dbg(que->dev, "%s: raising %s\n", __func__, que->name);
+
+	return 0;
+}
+
+int imgsys_queue_timeout(struct imgsys_queue *que)
+{
+	struct imgsys_work *work, *tmp;
+
+	spin_lock(&que->lock);
+
+	dev_info(que->dev, "%s: stalled work+\n", __func__);
+	list_for_each_entry_safe(work, tmp,
+		&que->queue, entry){
+		dev_info(que->dev, "%s: work %p\n", __func__, work);
+	}
+	dev_info(que->dev, "%s: stalled work-\n", __func__);
+
+	spin_unlock(&que->lock);
+
+	return 0;
+}
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/imgsys/mtk_imgsys-worker.h b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/mtk_imgsys-worker.h
new file mode 100644
index 0000000000000000000000000000000000000000..1240dec337c27e82d3c9fb9d74788a62faef1528
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/mtk_imgsys-worker.h
@@ -0,0 +1,41 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2018 MediaTek Inc.
+ *
+ * Author: Johnson-CH Chiu <johnson-ch.chiu@mediatek.com>
+ *
+ */
+
+#ifndef _MTK_IMGSYS_WORKER_H_
+#define _MTK_IMGSYS_WORKER_H_
+#include <linux/list.h>
+#include <linux/spinlock.h>
+#include <linux/wait.h>
+
+
+struct imgsys_queue {
+	char *name;
+	struct device *dev;
+	struct list_head queue;
+	atomic_t nr;
+	int peak;
+	atomic_t disable;
+	spinlock_t lock;
+	wait_queue_head_t wq;
+	wait_queue_head_t dis_wq;
+	struct task_struct *task;
+	struct mutex task_lock;
+};
+
+struct imgsys_work {
+	struct list_head entry;
+	void (*run)(void *data);
+};
+
+int imgsys_queue_init(struct imgsys_queue *que, struct device *dev, char *name);
+int imgsys_queue_enable(struct imgsys_queue *que);
+int imgsys_queue_disable(struct imgsys_queue *que);
+int imgsys_queue_add(struct imgsys_queue *que, struct imgsys_work *work);
+int imgsys_queue_timeout(struct imgsys_queue *que);
+
+#endif
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/imgsys/mtk_imgsys_v4l2.h b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/mtk_imgsys_v4l2.h
new file mode 100644
index 0000000000000000000000000000000000000000..a584be517fa252927b5c8351b040225a70ab0489
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/mtk_imgsys_v4l2.h
@@ -0,0 +1,300 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2021 MediaTek Inc.
+ *
+ * Author: Frederic Chen <frederic.chen@mediatek.com>
+ *         Holmes Chiou <holmes.chiou@mediatek.com>
+ *
+ */
+
+#ifndef _MTK_IMGSYS_V4L2_H_
+#define _MTK_IMGSYS_V4L2_H_
+
+#include <linux/platform_device.h>
+#include <linux/module.h>
+#include <linux/of_device.h>
+#include <linux/pm_runtime.h>
+#include <linux/remoteproc.h>
+//#include <linux/remoteproc/mtk_scp.h>
+#include <linux/videodev2.h>
+#include <media/videobuf2-dma-contig.h>
+#include <media/v4l2-ioctl.h>
+#include <media/v4l2-subdev.h>
+#include <media/v4l2-event.h>
+#include "mtk_imgsys-dev.h"
+#include "mtk_imgsys-hw.h"
+#include "mtk-hcp.h"
+#include "mtkdip.h"
+
+static int mtk_imgsys_sd_subscribe_event(struct v4l2_subdev *subdev,
+				      struct v4l2_fh *fh,
+				      struct v4l2_event_subscription *sub);
+
+static int mtk_imgsys_subdev_s_stream(struct v4l2_subdev *sd,
+				int enable);
+
+static int mtk_imgsys_subdev_get_fmt(struct v4l2_subdev *sd,
+			   struct v4l2_subdev_state *sd_state,
+			   struct v4l2_subdev_format *fmt);
+
+static int mtk_imgsys_subdev_set_fmt(struct v4l2_subdev *sd,
+			   struct v4l2_subdev_state *sd_state,
+			   struct v4l2_subdev_format *fmt);
+
+static int mtk_imgsys_subdev_get_selection(struct v4l2_subdev *sd,
+				 struct v4l2_subdev_state *sd_state,
+				 struct v4l2_subdev_selection *sel);
+
+static int mtk_imgsys_subdev_set_selection(struct v4l2_subdev *sd,
+				 struct v4l2_subdev_state *sd_state,
+				 struct v4l2_subdev_selection *sel);
+
+static int mtk_imgsys_link_setup(struct media_entity *entity,
+			   const struct media_pad *local,
+			   const struct media_pad *remote,
+			   u32 flags);
+
+static int mtk_imgsys_vb2_meta_buf_prepare(struct vb2_buffer *vb);
+
+static int mtk_imgsys_vb2_video_buf_prepare(struct vb2_buffer *vb);
+
+static int mtk_imgsys_vb2_buf_out_validate(struct vb2_buffer *vb);
+
+static int mtk_imgsys_vb2_meta_buf_init(struct vb2_buffer *vb);
+
+static int mtk_imgsys_vb2_video_buf_init(struct vb2_buffer *vb);
+
+static void mtk_imgsys_vb2_queue_meta_buf_cleanup(struct vb2_buffer *vb);
+
+static void mtk_imgsys_vb2_buf_queue(struct vb2_buffer *vb);
+
+static int mtk_imgsys_vb2_meta_queue_setup(struct vb2_queue *vq,
+				 unsigned int *num_buffers,
+				 unsigned int *num_planes,
+				 unsigned int sizes[],
+				 struct device *alloc_devs[]);
+
+static int mtk_imgsys_vb2_video_queue_setup(struct vb2_queue *vq,
+				  unsigned int *num_buffers,
+				  unsigned int *num_planes,
+				  unsigned int sizes[],
+				  struct device *alloc_devs[]);
+
+static int mtk_imgsys_vb2_start_streaming(struct vb2_queue *vq,
+							unsigned int count);
+
+static void mtk_imgsys_vb2_stop_streaming(struct vb2_queue *vq);
+
+static void mtk_imgsys_vb2_request_complete(struct vb2_buffer *vb);
+
+static int mtk_imgsys_videoc_querycap(struct file *file, void *fh,
+				struct v4l2_capability *cap);
+
+static int mtk_imgsys_videoc_try_fmt(struct file *file, void *fh,
+			   struct v4l2_format *f);
+
+static int mtk_imgsys_videoc_g_fmt(struct file *file, void *fh,
+			 struct v4l2_format *f);
+
+static int mtk_imgsys_videoc_s_fmt(struct file *file, void *fh,
+			 struct v4l2_format *f);
+
+static int mtk_imgsys_videoc_enum_framesizes(struct file *file, void *priv,
+				   struct v4l2_frmsizeenum *sizes);
+
+static int mtk_imgsys_videoc_enum_fmt(struct file *file, void *fh,
+				struct v4l2_fmtdesc *f);
+
+static int mtk_imgsys_meta_enum_format(struct file *file, void *fh,
+				 struct v4l2_fmtdesc *f);
+
+static int mtk_imgsys_videoc_g_meta_fmt(struct file *file, void *fh,
+				  struct v4l2_format *f);
+
+static int mtk_imgsys_videoc_s_meta_fmt(struct file *file, void *fh,
+				  struct v4l2_format *f);
+
+static int mtk_imgsys_video_device_s_ctrl(struct v4l2_ctrl *ctrl);
+
+static int mtk_imgsys_vidioc_qbuf(struct file *file, void *priv,
+				  struct v4l2_buffer *buf);
+
+#ifdef BATCH_MODE_V3
+long mtk_imgsys_vidioc_default(struct file *file, void *fh,
+			bool valid_prio, unsigned int cmd, void *arg);
+#endif
+long mtk_imgsys_subdev_ioctl(struct v4l2_subdev *subdev, unsigned int cmd,
+								void *arg);
+#ifdef CONFIG_COMPAT
+long mtk_imgsys_subdev_compat_ioctl(struct v4l2_subdev *subdev, unsigned int cmd,
+								unsigned long arg);
+#endif
+
+/******************** function pointers ********************/
+static const struct v4l2_subdev_core_ops mtk_imgsys_subdev_core_ops = {
+	.subscribe_event = mtk_imgsys_sd_subscribe_event,
+	.ioctl = mtk_imgsys_subdev_ioctl,
+	.unsubscribe_event = v4l2_event_subdev_unsubscribe,
+#ifdef CONFIG_COMPAT
+	.compat_ioctl32 = mtk_imgsys_subdev_compat_ioctl,
+#endif
+};
+
+static const struct v4l2_subdev_video_ops mtk_imgsys_subdev_video_ops = {
+	.s_stream = mtk_imgsys_subdev_s_stream,
+};
+
+static const struct v4l2_subdev_pad_ops mtk_imgsys_subdev_pad_ops = {
+	.link_validate = v4l2_subdev_link_validate_default,
+	.get_fmt = mtk_imgsys_subdev_get_fmt,
+	.set_fmt = mtk_imgsys_subdev_set_fmt,
+	.get_selection = mtk_imgsys_subdev_get_selection,
+	.set_selection = mtk_imgsys_subdev_set_selection,
+};
+
+static const struct v4l2_subdev_ops mtk_imgsys_subdev_ops = {
+	.core = &mtk_imgsys_subdev_core_ops,
+	.video = &mtk_imgsys_subdev_video_ops,
+	.pad = &mtk_imgsys_subdev_pad_ops,
+};
+
+static const struct media_entity_operations mtk_imgsys_media_ops = {
+	.link_setup = mtk_imgsys_link_setup,
+	.link_validate = v4l2_subdev_link_validate,
+};
+
+static struct media_request *mtk_imgsys_request_alloc(
+						struct media_device *mdev);
+static void mtk_imgsys_request_free(struct media_request *req);
+
+static int mtk_imgsys_vb2_request_validate(struct media_request *req);
+
+static void mtk_imgsys_vb2_request_queue(struct media_request *req);
+
+int mtk_imgsys_v4l2_fh_open(struct file *filp);
+
+int mtk_imgsys_v4l2_fh_release(struct file *filp);
+
+static const struct media_device_ops mtk_imgsys_media_req_ops = {
+	.req_validate = mtk_imgsys_vb2_request_validate,
+	.req_queue = mtk_imgsys_vb2_request_queue,
+	.req_alloc = mtk_imgsys_request_alloc,
+	.req_free = mtk_imgsys_request_free,
+};
+
+static const struct v4l2_ctrl_ops mtk_imgsys_video_device_ctrl_ops = {
+	.s_ctrl = mtk_imgsys_video_device_s_ctrl,
+};
+
+static const struct vb2_ops mtk_imgsys_vb2_meta_ops = {
+	.buf_queue = mtk_imgsys_vb2_buf_queue,
+	.queue_setup = mtk_imgsys_vb2_meta_queue_setup,
+	.buf_init = mtk_imgsys_vb2_meta_buf_init,
+	.buf_prepare  = mtk_imgsys_vb2_meta_buf_prepare,
+	.buf_out_validate = mtk_imgsys_vb2_buf_out_validate,
+	.buf_cleanup = mtk_imgsys_vb2_queue_meta_buf_cleanup,
+	.start_streaming = mtk_imgsys_vb2_start_streaming,
+	.stop_streaming = mtk_imgsys_vb2_stop_streaming,
+	.wait_prepare = vb2_ops_wait_prepare,
+	.wait_finish = vb2_ops_wait_finish,
+	.buf_request_complete = mtk_imgsys_vb2_request_complete,
+};
+
+static const struct vb2_ops mtk_imgsys_vb2_video_ops = {
+	.buf_queue = mtk_imgsys_vb2_buf_queue,
+	.queue_setup = mtk_imgsys_vb2_video_queue_setup,
+	.buf_init = mtk_imgsys_vb2_video_buf_init,
+	.buf_prepare  = mtk_imgsys_vb2_video_buf_prepare,
+	.buf_out_validate = mtk_imgsys_vb2_buf_out_validate,
+	.start_streaming = mtk_imgsys_vb2_start_streaming,
+	.stop_streaming = mtk_imgsys_vb2_stop_streaming,
+	.wait_prepare = vb2_ops_wait_prepare,
+	.wait_finish = vb2_ops_wait_finish,
+	.buf_request_complete = mtk_imgsys_vb2_request_complete,
+};
+
+static const struct v4l2_file_operations mtk_imgsys_v4l2_fops = {
+	.unlocked_ioctl = video_ioctl2,
+	.open = mtk_imgsys_v4l2_fh_open,
+	.release = mtk_imgsys_v4l2_fh_release,
+	.poll = vb2_fop_poll,
+	.mmap = vb2_fop_mmap,
+#ifdef CONFIG_COMPAT
+	.compat_ioctl32 = v4l2_compat_ioctl32,
+#endif
+};
+
+/********************************************
+ * MTK DIP V4L2 Settings *
+ *******************************************
+ */
+
+static const struct v4l2_ioctl_ops mtk_imgsys_v4l2_video_out_ioctl_ops = {
+	.vidioc_querycap = mtk_imgsys_videoc_querycap,
+
+	.vidioc_enum_framesizes = mtk_imgsys_videoc_enum_framesizes,
+	.vidioc_enum_fmt_vid_out = mtk_imgsys_videoc_enum_fmt,
+	.vidioc_g_fmt_vid_out_mplane = mtk_imgsys_videoc_g_fmt,
+	.vidioc_s_fmt_vid_out_mplane = mtk_imgsys_videoc_s_fmt,
+	.vidioc_try_fmt_vid_out_mplane = mtk_imgsys_videoc_try_fmt,
+
+	.vidioc_reqbufs = vb2_ioctl_reqbufs,
+	.vidioc_create_bufs = vb2_ioctl_create_bufs,
+	.vidioc_prepare_buf = vb2_ioctl_prepare_buf,
+	.vidioc_querybuf = vb2_ioctl_querybuf,
+	.vidioc_qbuf = mtk_imgsys_vidioc_qbuf,
+	.vidioc_dqbuf = vb2_ioctl_dqbuf,
+	.vidioc_streamon = vb2_ioctl_streamon,
+	.vidioc_streamoff = vb2_ioctl_streamoff,
+	.vidioc_expbuf = vb2_ioctl_expbuf,
+
+	.vidioc_subscribe_event = v4l2_ctrl_subscribe_event,
+	.vidioc_unsubscribe_event = v4l2_event_unsubscribe,
+#ifdef BATCH_MODE_V3
+	.vidioc_default = mtk_imgsys_vidioc_default,
+#endif
+};
+
+static const struct v4l2_ioctl_ops mtk_imgsys_v4l2_video_cap_ioctl_ops = {
+	.vidioc_querycap = mtk_imgsys_videoc_querycap,
+
+	.vidioc_enum_framesizes = mtk_imgsys_videoc_enum_framesizes,
+	.vidioc_enum_fmt_vid_cap = mtk_imgsys_videoc_enum_fmt,
+	.vidioc_g_fmt_vid_cap_mplane = mtk_imgsys_videoc_g_fmt,
+	.vidioc_s_fmt_vid_cap_mplane = mtk_imgsys_videoc_s_fmt,
+	.vidioc_try_fmt_vid_cap_mplane = mtk_imgsys_videoc_try_fmt,
+
+	.vidioc_reqbufs = vb2_ioctl_reqbufs,
+	.vidioc_create_bufs = vb2_ioctl_create_bufs,
+	.vidioc_prepare_buf = vb2_ioctl_prepare_buf,
+	.vidioc_querybuf = vb2_ioctl_querybuf,
+	.vidioc_qbuf = mtk_imgsys_vidioc_qbuf,
+	.vidioc_dqbuf = vb2_ioctl_dqbuf,
+	.vidioc_streamon = vb2_ioctl_streamon,
+	.vidioc_streamoff = vb2_ioctl_streamoff,
+	.vidioc_expbuf = vb2_ioctl_expbuf,
+
+	.vidioc_subscribe_event = v4l2_ctrl_subscribe_event,
+	.vidioc_unsubscribe_event = v4l2_event_unsubscribe,
+};
+
+static const struct v4l2_ioctl_ops mtk_imgsys_v4l2_meta_out_ioctl_ops = {
+	.vidioc_querycap = mtk_imgsys_videoc_querycap,
+
+	.vidioc_enum_fmt_meta_out = mtk_imgsys_meta_enum_format,
+	.vidioc_g_fmt_meta_out = mtk_imgsys_videoc_g_meta_fmt,
+	.vidioc_s_fmt_meta_out = mtk_imgsys_videoc_s_meta_fmt,
+	.vidioc_try_fmt_meta_out = mtk_imgsys_videoc_g_meta_fmt,
+
+	.vidioc_reqbufs = vb2_ioctl_reqbufs,
+	.vidioc_create_bufs = vb2_ioctl_create_bufs,
+	.vidioc_prepare_buf = vb2_ioctl_prepare_buf,
+	.vidioc_querybuf = vb2_ioctl_querybuf,
+	.vidioc_qbuf = mtk_imgsys_vidioc_qbuf,
+	.vidioc_dqbuf = vb2_ioctl_dqbuf,
+	.vidioc_streamon = vb2_ioctl_streamon,
+	.vidioc_streamoff = vb2_ioctl_streamoff,
+	.vidioc_expbuf = vb2_ioctl_expbuf,
+};
+
+#endif // _MTK_IMGSYS_V4L2_H_
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/imgsys/mtkdip.h b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/mtkdip.h
new file mode 100644
index 0000000000000000000000000000000000000000..059a2aa3216ff3bb3d507bb30cadda17aa249938
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/mtkdip.h
@@ -0,0 +1,123 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2021 MediaTek Inc.
+ */
+
+#ifndef MTK_DIP_H
+#define MTK_DIP_H
+
+#include <linux/videodev2.h>
+#include <linux/v4l2-controls.h>
+#include "mtk-img-ipi.h"
+
+#define MTKDIP_IOC_QBUF \
+	_IOWR('V', BASE_VIDIOC_PRIVATE + 1, struct frame_param_pack)
+#define MTKDIP_IOC_DQBUF \
+	_IOR('V', BASE_VIDIOC_PRIVATE + 2, struct frame_param_pack)
+#define MTKDIP_IOC_STREAMON _IO('V', BASE_VIDIOC_PRIVATE + 3)
+#define MTKDIP_IOC_STREAMOFF _IO('V', BASE_VIDIOC_PRIVATE + 4)
+#define MTKDIP_IOC_G_REG_SIZE \
+			_IOWR('V', BASE_VIDIOC_PRIVATE + 5, unsigned int)
+#define MTKDIP_IOC_G_ISP_VERSION \
+			_IOWR('V', BASE_VIDIOC_PRIVATE + 6, unsigned int)
+#define MTKDIP_IOC_S_USER_ENUM _IOW('V', BASE_VIDIOC_PRIVATE + 7, int)
+
+
+#define FD_MAX (32)
+
+struct fd_info {
+	uint8_t fd_num;
+	uint32_t fds[FD_MAX];
+	uint32_t fds_size[FD_MAX];
+} __attribute__ ((__packed__));
+#define MTKDIP_IOC_ADD_KVA _IOW('V', BASE_VIDIOC_PRIVATE + 8, struct fd_info)
+#define MTKDIP_IOC_DEL_KVA _IOW('V', BASE_VIDIOC_PRIVATE + 9, struct fd_info)
+
+struct fd_tbl {
+	uint8_t fd_num;
+	uint64_t fds; // user address, point to unsigned int array
+} __attribute__ ((__packed__));
+
+#if 0 //#ifdef CONFIG_COMPAT
+struct fd_tbl_compat {
+	uint8_t fd_num;
+	compat_uptr_t fds;
+} __attribute__ ((__packed__));
+#define MTKDIP_IOC_ADD_IOVA _IOW('V', BASE_VIDIOC_PRIVATE + 10, struct fd_tbl_compat)
+#define MTKDIP_IOC_DEL_IOVA _IOW('V', BASE_VIDIOC_PRIVATE + 11, struct fd_tbl_compat)
+#else
+#define MTKDIP_IOC_ADD_IOVA _IOW('V', BASE_VIDIOC_PRIVATE + 10, struct fd_tbl)
+#define MTKDIP_IOC_DEL_IOVA _IOW('V', BASE_VIDIOC_PRIVATE + 11, struct fd_tbl)
+#endif
+
+struct sensor_info {
+	uint16_t full_wd;
+	uint16_t full_ht;
+};
+
+struct init_info {
+	struct sensor_info sensor;
+	uint32_t sec_tag;
+	uint32_t is_smvr;
+};
+#define MTKDIP_IOC_S_INIT_INFO \
+			_IOW('V', BASE_VIDIOC_PRIVATE + 12, struct init_info)
+
+#define V4L2_CID_IMGSYS_OFFSET	(0xC000)
+#define V4L2_CID_IMGSYS_BASE    (V4L2_CID_USER_BASE + V4L2_CID_IMGSYS_OFFSET)
+#define V4L2_CID_IMGSYS_APU_DC  (V4L2_CID_IMGSYS_BASE + 1)
+
+struct ctrl_info {
+	uint32_t id;
+	int32_t value;
+} __attribute__ ((__packed__));
+
+#define MTKDIP_IOC_SET_CONTROL _IOW('V', BASE_VIDIOC_PRIVATE + 13, struct ctrl_info)
+#define MTKDIP_IOC_GET_CONTROL _IOWR('V', BASE_VIDIOC_PRIVATE + 14, struct ctrl_info)
+
+#define STANDARD_MODE_MAX_FRAMES (1)
+#define BATCH_MODE_MAX_FRAMES (32)
+
+#define MCRP_D1 (0)
+#define MCRP_D2 (1)
+
+#define LSC_HEADER_ADDR_OFFSET (1024 * 48)
+#define LSC_DATA_ADDR_OFFSET (1024 * 50)
+
+enum imgsys_user_enum {
+	DIP_DEFAULT,
+	DIP_AIHDRCORE_FE_FM,
+	DIP_AINRCORE_FE_FM,
+	DIP_BOKEHNODE,
+	DIP_CAPTURE,
+	DIP_DEPTH_MAP,
+	DIP_MFLLCORE_MFB,
+	DIP_STREAMING,
+};
+
+/*
+ * New added for v4l2 dip driver - batch mode/multi-frames.
+ * Use case:
+ *    ioctl(fd, MTKDIP_IOC_QBUF, struct frame_param_pack);
+ */
+struct frame_param_pack {
+	uint8_t num_frames;
+	struct img_ipi_frameparam *frame_params;
+
+	uint64_t seq_num;   // used by user
+	void *cookie;       // used by user
+} __attribute__ ((__packed__));
+
+
+/*
+ * Used in driver internaly. (kernel driver <-> user space daemon)
+ * User should not use this structure.
+ */
+struct framepack_buf_data {
+	struct frame_param_pack header;
+	uint8_t unprocessed_count;
+	struct img_ipi_frameparam params[BATCH_MODE_MAX_FRAMES];
+} __attribute__ ((__packed__));
+
+#endif
+
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_70/Makefile b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_70/Makefile
new file mode 100644
index 0000000000000000000000000000000000000000..2b10533d79559be19dfce5e09aa592f367482b9d
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_70/Makefile
@@ -0,0 +1,18 @@
+# SPDX-License-Identifier: GPL-2.0
+#
+# Copyright (C) 2018 MediaTek Inc.
+#
+ccflags-y += -I$(srctree)/drivers/media/platform/mtk-isp/isp_71/mtk-hcp
+ccflags-y += -I$(srctree)/drivers/media/platform/mtk-isp/isp_71/imgsys/
+ccflags-y += -I$(srctree)/drivers/media/platform/mtk-isp/isp_71/mtk-ipesys-me/
+ccflags-y += -I$(srctree)/drivers/iommu
+
+#mtk_imgsys_hw-objs := \
+mtk_imgsys-debug.o \
+modules/mtk_imgsys-dip.o \
+modules/mtk_imgsys-traw.o \
+modules/mtk_imgsys-pqdip.o \
+modules/mtk_imgsys-wpe.o \
+modules/mtk_imgsys-me.o
+
+#obj-y += mtk_imgsys_hw.o
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_70/modules/mtk_dip_v4l2_vnode.h b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_70/modules/mtk_dip_v4l2_vnode.h
new file mode 100644
index 0000000000000000000000000000000000000000..cbdbfb9cc0565b40f15b3075c2edfd10536e4a64
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_70/modules/mtk_dip_v4l2_vnode.h
@@ -0,0 +1,929 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2021 MediaTek Inc.
+ *
+ * Author: Frederic Chen <frederic.chen@mediatek.com>
+ *
+ */
+
+#ifndef _MTK_DIP_V4L2_VNODE_H_
+#define _MTK_DIP_V4L2_VNODE_H_
+
+/*#include <linux/platform_device.h>
+ * #include <linux/module.h>
+ * #include <linux/of_device.h>
+ * #include <linux/pm_runtime.h>
+ * #include <linux/remoteproc.h>
+ * #include <linux/remoteproc/mtk_scp.h>
+ */
+#include <linux/videodev2.h>
+#include <media/videobuf2-dma-contig.h>
+#include <media/v4l2-ioctl.h>
+#include <media/v4l2-subdev.h>
+#include <media/v4l2-event.h>
+#include "mtk_imgsys-dev.h"
+#include "mtk_imgsys-hw.h"
+
+#include "mtk_imgsys_v4l2.h"
+#include "mtk_header_desc.h"
+#include "mtk_imgsys-vnode_id.h"
+
+#define defaultdesc 0
+
+static const struct mtk_imgsys_dev_format dip_imgi_fmts[] = {
+	/* YUV422, 1 plane 8 bit */
+	{
+		.format = V4L2_PIX_FMT_UYVY,
+		.depth = { 16 },
+		.row_depth = { 16 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+	},
+	{
+		.format = V4L2_PIX_FMT_YUYV,
+		.depth = { 16 },
+		.row_depth = { 16 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+	},
+	{
+		.format = V4L2_PIX_FMT_YVYU,
+		.depth = { 16 },
+		.row_depth = { 16 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+	},
+	{
+		.format = V4L2_PIX_FMT_VYUY,
+		.depth = { 16 },
+		.row_depth = { 16 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+	},
+	/* YUV422, 2 plane 8 bit */
+	{
+		.format = V4L2_PIX_FMT_NV16,
+		.depth = { 16 },
+		.row_depth = { 8 },
+		.num_planes = 1,
+		.num_cplanes = 2,
+	},
+	{
+		.format = V4L2_PIX_FMT_NV61,
+		.depth = { 16 },
+		.row_depth = { 8 },
+		.num_planes = 1,
+		.num_cplanes = 2,
+	},
+	/* YUV422, 3 plane 8 bit */
+	/* YUV420, 2 plane 8 bit */
+	{
+		.format = V4L2_PIX_FMT_NV12,
+		.depth = { 12 },
+		.row_depth = { 8 },
+		.num_planes = 1,
+		.num_cplanes = 2,
+	},
+	{
+		.format = V4L2_PIX_FMT_NV21,
+		.depth = { 12 },
+		.row_depth = { 8 },
+		.num_planes = 1,
+		.num_cplanes = 2,
+	},
+	/* YUV420, 3 plane 8 bit */
+	{
+		.format	= V4L2_PIX_FMT_YUV420,
+		.depth		= { 12 },
+		.row_depth	= { 8 },
+		.num_planes	= 1,
+		.num_cplanes = 3,
+	},
+	{
+		.format	= V4L2_PIX_FMT_YVU420,
+		.depth		= { 12 },
+		.row_depth	= { 8 },
+		.num_planes	= 1,
+		.num_cplanes = 3,
+	},
+	/* Y8 bit */
+	{
+		.format	= V4L2_PIX_FMT_GREY,
+		.depth		= { 8 },
+		.row_depth	= { 8 },
+		.num_planes	= 1,
+		.num_cplanes = 1,
+	},
+	/* Must have for SMVR/Multis-cale for every video_device nodes */
+	{
+		.format = V4L2_META_FMT_MTISP_DESC,
+		.num_planes = 1,
+#if defaultdesc
+		.depth = { 8 },
+		.row_depth = { 8 },
+		.num_cplanes = 1,
+#endif
+		.buffer_size = sizeof(struct header_desc),
+	},
+	{
+		.format = V4L2_META_FMT_MTISP_DESC_NORM,
+		.num_planes = 1,
+		.buffer_size = sizeof(struct header_desc_norm),
+	},
+};
+
+static const struct mtk_imgsys_dev_format dip_vipi_fmts[] = {
+	/* YUV422, 1 plane 8 bit */
+	{
+		.format = V4L2_PIX_FMT_UYVY,
+		.depth = { 16 },
+		.row_depth = { 16 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+	},
+	{
+		.format = V4L2_PIX_FMT_YUYV,
+		.depth = { 16 },
+		.row_depth = { 16 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+	},
+	{
+		.format = V4L2_PIX_FMT_YVYU,
+		.depth = { 16 },
+		.row_depth = { 16 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+	},
+	{
+		.format = V4L2_PIX_FMT_VYUY,
+		.depth = { 16 },
+		.row_depth = { 16 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+	},
+	/* YUV422, 2 plane 8 bit */
+	{
+		.format = V4L2_PIX_FMT_NV16,
+		.depth = { 16 },
+		.row_depth = { 8 },
+		.num_planes = 1,
+		.num_cplanes = 2,
+	},
+	{
+		.format = V4L2_PIX_FMT_NV61,
+		.depth = { 16 },
+		.row_depth = { 8 },
+		.num_planes = 1,
+		.num_cplanes = 2,
+	},
+	/* YUV422, 3 plane 8 bit */
+	/* YUV420, 2 plane 8 bit */
+	{
+		.format = V4L2_PIX_FMT_NV12,
+		.depth = { 12 },
+		.row_depth = { 8 },
+		.num_planes = 1,
+		.num_cplanes = 2,
+	},
+	{
+		.format = V4L2_PIX_FMT_NV21,
+		.depth = { 12 },
+		.row_depth = { 8 },
+		.num_planes = 1,
+		.num_cplanes = 2,
+	},
+	/* YUV420, 3 plane 8 bit */
+	{
+		.format	= V4L2_PIX_FMT_YUV420,
+		.depth		= { 12 },
+		.row_depth	= { 8 },
+		.num_planes	= 1,
+		.num_cplanes = 3,
+	},
+	{
+		.format	= V4L2_PIX_FMT_YVU420,
+		.depth		= { 12 },
+		.row_depth	= { 8 },
+		.num_planes	= 1,
+		.num_cplanes = 3,
+	},
+	/* Y8 bit */
+	{
+		.format	= V4L2_PIX_FMT_GREY,
+		.depth		= { 8 },
+		.row_depth	= { 8 },
+		.num_planes	= 1,
+		.num_cplanes = 1,
+	},
+	/* Must have for SMVR/Multis-cale for every video_device nodes */
+	{
+		.format = V4L2_META_FMT_MTISP_DESC,
+		.num_planes = 1,
+#if defaultdesc
+		.depth = { 8 },
+		.row_depth = { 8 },
+		.num_cplanes = 1,
+#endif
+		.buffer_size = sizeof(struct header_desc),
+	},
+	{
+		.format = V4L2_META_FMT_MTISP_DESC_NORM,
+		.num_planes = 1,
+		.buffer_size = sizeof(struct header_desc_norm),
+	},
+};
+
+static const struct mtk_imgsys_dev_format dip_rec_dsi_fmts[] = {
+	/* YUV420, 2 plane 8 bit */
+	{
+		.format = V4L2_PIX_FMT_NV12,
+		.depth = { 12 },
+		.row_depth = { 8 },
+		.num_planes = 1,
+		.num_cplanes = 2,
+	},
+	{
+		.format = V4L2_PIX_FMT_NV21,
+		.depth = { 12 },
+		.row_depth = { 8 },
+		.num_planes = 1,
+		.num_cplanes = 2,
+	},
+	/* Must have for SMVR/Multis-cale for every video_device nodes */
+	{
+		.format = V4L2_META_FMT_MTISP_DESC,
+		.num_planes = 1,
+#if defaultdesc
+		.depth = { 8 },
+		.row_depth = { 8 },
+		.num_cplanes = 1,
+#endif
+		.buffer_size = sizeof(struct header_desc),
+	},
+	{
+		.format = V4L2_META_FMT_MTISP_DESC_NORM,
+		.num_planes = 1,
+		.buffer_size = sizeof(struct header_desc_norm),
+	},
+};
+
+static const struct mtk_imgsys_dev_format dip_rec_dpi_fmts[] = {
+	/* YUV420, 2 plane 8 bit */
+	{
+		.format = V4L2_PIX_FMT_NV12,
+		.depth = { 12 },
+		.row_depth = { 8 },
+		.num_planes = 1,
+		.num_cplanes = 2,
+	},
+	{
+		.format = V4L2_PIX_FMT_NV21,
+		.depth = { 12 },
+		.row_depth = { 8 },
+		.num_planes = 1,
+		.num_cplanes = 2,
+	},
+	/* Must have for SMVR/Multis-cale for every video_device nodes */
+	{
+		.format = V4L2_META_FMT_MTISP_DESC,
+		.num_planes = 1,
+#if defaultdesc
+		.depth = { 8 },
+		.row_depth = { 8 },
+		.num_cplanes = 1,
+#endif
+		.buffer_size = sizeof(struct header_desc),
+	},
+	{
+		.format = V4L2_META_FMT_MTISP_DESC_NORM,
+		.num_planes = 1,
+		.buffer_size = sizeof(struct header_desc_norm),
+	},
+};
+
+static const struct mtk_imgsys_dev_format dip_meta_fmts[] = {
+	/* Must have for SMVR/Multis-cale for every video_device nodes */
+	{
+		.format = V4L2_META_FMT_MTISP_DESC,
+		.num_planes = 1,
+#if defaultdesc
+		.depth = { 8 },
+		.row_depth = { 8 },
+		.num_cplanes = 1,
+#endif
+		.buffer_size = sizeof(struct header_desc),
+	},
+	{
+		.format = V4L2_META_FMT_MTISP_DESC_NORM,
+		.num_planes = 1,
+		.buffer_size = sizeof(struct header_desc_norm),
+	},
+};
+
+static const struct mtk_imgsys_dev_format dip_tnrli_fmts[] = {
+	/* YUV420, 2 plane 8 bit */
+	{
+		.format = V4L2_PIX_FMT_NV12,
+		.depth = { 12 },
+		.row_depth = { 8 },
+		.num_planes = 1,
+		.num_cplanes = 2,
+	},
+	{
+		.format = V4L2_PIX_FMT_NV21,
+		.depth = { 12 },
+		.row_depth = { 8 },
+		.num_planes = 1,
+		.num_cplanes = 2,
+	},
+	/* Must have for SMVR/Multis-cale for every video_device nodes */
+	{
+		.format = V4L2_META_FMT_MTISP_DESC,
+		.num_planes = 1,
+#if defaultdesc
+		.depth = { 8 },
+		.row_depth = { 8 },
+		.num_cplanes = 1,
+#endif
+		.buffer_size = sizeof(struct header_desc),
+	},
+	{
+		.format = V4L2_META_FMT_MTISP_DESC_NORM,
+		.num_planes = 1,
+		.buffer_size = sizeof(struct header_desc_norm),
+	},
+};
+
+static const struct mtk_imgsys_dev_format dip_img2o_fmts[] = {
+	/* YUV420, 2 plane 8 bit */
+	{
+		.format = V4L2_PIX_FMT_NV12,
+		.depth = { 12 },
+		.row_depth = { 8 },
+		.num_planes = 1,
+		.num_cplanes = 2,
+	},
+	{
+		.format = V4L2_PIX_FMT_NV21,
+		.depth = { 12 },
+		.row_depth = { 8 },
+		.num_planes = 1,
+		.num_cplanes = 2,
+	},
+	/* Y8 bit */
+	{
+		.format	= V4L2_PIX_FMT_GREY,
+		.depth		= { 8 },
+		.row_depth	= { 8 },
+		.num_planes	= 1,
+		.num_cplanes = 1,
+	},
+	/* Must have for SMVR/Multis-cale for every video_device nodes */
+	{
+		.format = V4L2_META_FMT_MTISP_DESC,
+		.num_planes = 1,
+#if defaultdesc
+		.depth = { 8 },
+		.row_depth = { 8 },
+		.num_cplanes = 1,
+#endif
+		.buffer_size = sizeof(struct header_desc),
+	},
+	{
+		.format = V4L2_META_FMT_MTISP_DESC_NORM,
+		.num_planes = 1,
+		.buffer_size = sizeof(struct header_desc_norm),
+	},
+};
+
+static const struct mtk_imgsys_dev_format dip_img3o_fmts[] = {
+	/* YUV422, 1 plane 8 bit */
+	{
+		.format = V4L2_PIX_FMT_UYVY,
+		.depth = { 16 },
+		.row_depth = { 16 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+	},
+	{
+		.format = V4L2_PIX_FMT_YUYV,
+		.depth = { 16 },
+		.row_depth = { 16 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+	},
+	{
+		.format = V4L2_PIX_FMT_YVYU,
+		.depth = { 16 },
+		.row_depth = { 16 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+	},
+	{
+		.format = V4L2_PIX_FMT_VYUY,
+		.depth = { 16 },
+		.row_depth = { 16 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+	},
+	/* YUV422, 2 plane 8 bit */
+	{
+		.format = V4L2_PIX_FMT_NV16,
+		.depth = { 16 },
+		.row_depth = { 8 },
+		.num_planes = 1,
+		.num_cplanes = 2,
+	},
+	{
+		.format = V4L2_PIX_FMT_NV61,
+		.depth = { 16 },
+		.row_depth = { 8 },
+		.num_planes = 1,
+		.num_cplanes = 2,
+	},
+	/* YUV422, 3 plane 8 bit */
+	/* YUV420, 2 plane 8 bit */
+	{
+		.format = V4L2_PIX_FMT_NV12,
+		.depth = { 12 },
+		.row_depth = { 8 },
+		.num_planes = 1,
+		.num_cplanes = 2,
+	},
+	{
+		.format = V4L2_PIX_FMT_NV21,
+		.depth = { 12 },
+		.row_depth = { 8 },
+		.num_planes = 1,
+		.num_cplanes = 2,
+	},
+	/* YUV420, 3 plane 8 bit */
+	{
+		.format	= V4L2_PIX_FMT_YUV420,
+		.depth		= { 12 },
+		.row_depth	= { 8 },
+		.num_planes	= 1,
+		.num_cplanes = 3,
+	},
+	{
+		.format	= V4L2_PIX_FMT_YVU420,
+		.depth		= { 12 },
+		.row_depth	= { 8 },
+		.num_planes	= 1,
+		.num_cplanes = 3,
+	},
+	/* Y8 bit */
+	{
+		.format	= V4L2_PIX_FMT_GREY,
+		.depth		= { 8 },
+		.row_depth	= { 8 },
+		.num_planes	= 1,
+		.num_cplanes = 1,
+	},
+	/* Must have for SMVR/Multis-cale for every video_device nodes */
+	{
+		.format = V4L2_META_FMT_MTISP_DESC,
+		.num_planes = 1,
+#if defaultdesc
+		.depth = { 8 },
+		.row_depth = { 8 },
+		.num_cplanes = 1,
+#endif
+		.buffer_size = sizeof(struct header_desc),
+	},
+	{
+		.format = V4L2_META_FMT_MTISP_DESC_NORM,
+		.num_planes = 1,
+		.buffer_size = sizeof(struct header_desc_norm),
+	},
+};
+
+static const struct mtk_imgsys_dev_format dip_img4o_fmts[] = {
+	/* YUV420, 2 plane 8 bit */
+	{
+		.format = V4L2_PIX_FMT_NV12,
+		.depth = { 12 },
+		.row_depth = { 8 },
+		.num_planes = 1,
+		.num_cplanes = 2,
+	},
+	{
+		.format = V4L2_PIX_FMT_NV21,
+		.depth = { 12 },
+		.row_depth = { 8 },
+		.num_planes = 1,
+		.num_cplanes = 2,
+	},
+	/* Y8 bit */
+	{
+		.format	= V4L2_PIX_FMT_GREY,
+		.depth		= { 8 },
+		.row_depth	= { 8 },
+		.num_planes	= 1,
+		.num_cplanes = 1,
+	},
+	/* Must have for SMVR/Multis-cale for every video_device nodes */
+	{
+		.format = V4L2_META_FMT_MTISP_DESC,
+		.num_planes = 1,
+#if defaultdesc
+		.depth = { 8 },
+		.row_depth = { 8 },
+		.num_cplanes = 1,
+#endif
+		.buffer_size = sizeof(struct header_desc),
+	},
+	{
+		.format = V4L2_META_FMT_MTISP_DESC_NORM,
+		.num_planes = 1,
+		.buffer_size = sizeof(struct header_desc_norm),
+	},
+};
+
+static const struct v4l2_frmsizeenum dip_in_frmsizeenum = {
+	.type = V4L2_FRMSIZE_TYPE_CONTINUOUS,
+	.stepwise.max_width = MTK_DIP_CAPTURE_MAX_WIDTH,
+	.stepwise.min_width = MTK_DIP_CAPTURE_MIN_WIDTH,
+	.stepwise.max_height = MTK_DIP_CAPTURE_MAX_HEIGHT,
+	.stepwise.min_height = MTK_DIP_CAPTURE_MIN_HEIGHT,
+	.stepwise.step_height = 1,
+	.stepwise.step_width = 1,
+};
+
+static const struct v4l2_frmsizeenum dip_out_frmsizeenum = {
+	.type = V4L2_FRMSIZE_TYPE_CONTINUOUS,
+	.stepwise.max_width = MTK_DIP_OUTPUT_MAX_WIDTH,
+	.stepwise.min_width = MTK_DIP_OUTPUT_MIN_WIDTH,
+	.stepwise.max_height = MTK_DIP_OUTPUT_MAX_HEIGHT,
+	.stepwise.min_height = MTK_DIP_OUTPUT_MIN_HEIGHT,
+	.stepwise.step_height = 1,
+	.stepwise.step_width = 1,
+};
+
+static const struct mtk_imgsys_video_device_desc dip_setting[] = {
+	/* Input Video Node */
+	{
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_IMGI_OUT,
+		.name = "Imgi Input",
+		.cap = V4L2_CAP_VIDEO_OUTPUT_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = dip_imgi_fmts,
+		.num_fmts = ARRAY_SIZE(dip_imgi_fmts),
+		.default_fmt_idx = 4,
+		.default_width = MTK_DIP_OUTPUT_MAX_WIDTH,
+		.default_height = MTK_DIP_OUTPUT_MAX_HEIGHT,
+		.dma_port = 0,
+		.frmsizeenum = &dip_in_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_out_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "Main image source",
+	},
+	{
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_VIPI_OUT,
+		.name = "Vipi Input",
+		.cap = V4L2_CAP_VIDEO_OUTPUT_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = dip_vipi_fmts,
+		.num_fmts = ARRAY_SIZE(dip_vipi_fmts),
+		.default_fmt_idx = 1,
+		.default_width = MTK_DIP_CAPTURE_MAX_WIDTH,
+		.default_height = MTK_DIP_CAPTURE_MAX_HEIGHT,
+		.dma_port = 1,
+		.frmsizeenum = &dip_in_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_out_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "Vipi image source",
+	},
+	{
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_REC_DSI_OUT,
+		.name = "Rec_Dsi Input",
+		.cap = V4L2_CAP_VIDEO_OUTPUT_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = dip_rec_dsi_fmts,
+		.num_fmts = ARRAY_SIZE(dip_rec_dsi_fmts),
+		.default_fmt_idx = 1,
+		.default_width = MTK_DIP_CAPTURE_MAX_WIDTH,
+		.default_height = MTK_DIP_CAPTURE_MAX_HEIGHT,
+		.dma_port = 2,
+		.frmsizeenum = &dip_in_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_out_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "Down Source Image",
+	},
+	{
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_REC_DPI_OUT,
+		.name = "Rec_Dpi Input",
+		.cap = V4L2_CAP_VIDEO_OUTPUT_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = dip_rec_dpi_fmts,
+		.num_fmts = ARRAY_SIZE(dip_rec_dpi_fmts),
+		.default_fmt_idx = 1,
+		.default_width = MTK_DIP_CAPTURE_MAX_WIDTH,
+		.default_height = MTK_DIP_CAPTURE_MAX_HEIGHT,
+		.dma_port = 3,
+		.frmsizeenum = &dip_in_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_out_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "Down Processed Image",
+	},
+	{
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_CNR_BLURMAPI_OUT,
+		.name = "Bokeh Input",
+		.cap = V4L2_CAP_VIDEO_OUTPUT_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = dip_meta_fmts,
+		.num_fmts = ARRAY_SIZE(dip_meta_fmts),
+		.default_fmt_idx = 1,
+		.default_width = MTK_DIP_CAPTURE_MAX_WIDTH,
+		.default_height = MTK_DIP_CAPTURE_MAX_HEIGHT,
+		.dma_port = 5,
+		.frmsizeenum = &dip_in_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_out_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "Bokehi data",
+	},
+	{
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_LFEI_OUT,
+		.name = "Dmgi_FM Input",
+		.cap = V4L2_CAP_VIDEO_OUTPUT_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = dip_meta_fmts,
+		.num_fmts = ARRAY_SIZE(dip_meta_fmts),
+		.default_fmt_idx = 1,
+		.default_width = MTK_DIP_CAPTURE_MAX_WIDTH,
+		.default_height = MTK_DIP_CAPTURE_MAX_HEIGHT,
+		.dma_port = 6,
+		.frmsizeenum = &dip_in_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_out_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "Dmgi_FM data",
+	},
+	{
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_RFEI_OUT,
+		.name = "Depi_FM Input",
+		.cap = V4L2_CAP_VIDEO_OUTPUT_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = dip_meta_fmts,
+		.num_fmts = ARRAY_SIZE(dip_meta_fmts),
+		.default_fmt_idx = 1,
+		.default_width = MTK_DIP_CAPTURE_MAX_WIDTH,
+		.default_height = MTK_DIP_CAPTURE_MAX_HEIGHT,
+		.dma_port = 7,
+		.frmsizeenum = &dip_in_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_out_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "Depi_FM data",
+	},
+	{
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_TNRSI_OUT,
+		.name = "Tnrsi Input",
+		.cap = V4L2_CAP_VIDEO_OUTPUT_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = dip_meta_fmts,
+		.num_fmts = ARRAY_SIZE(dip_meta_fmts),
+		.default_fmt_idx = 1,
+		.default_width = MTK_DIP_CAPTURE_MAX_WIDTH,
+		.default_height = MTK_DIP_CAPTURE_MAX_HEIGHT,
+		.dma_port = 8,
+		.frmsizeenum = &dip_in_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_out_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "Statistics input",
+	},
+	{
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_TNRWI_OUT,
+		.name = "Tnrwi Input",
+		.cap = V4L2_CAP_VIDEO_OUTPUT_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = dip_meta_fmts,
+		.num_fmts = ARRAY_SIZE(dip_meta_fmts),
+		.default_fmt_idx = 1,
+		.default_width = MTK_DIP_CAPTURE_MAX_WIDTH,
+		.default_height = MTK_DIP_CAPTURE_MAX_HEIGHT,
+		.dma_port = 9,
+		.frmsizeenum = &dip_in_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_out_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "Weighting input",
+	},
+	{
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_TNRMI_OUT,
+		.name = "Tnrmi Input",
+		.cap = V4L2_CAP_VIDEO_OUTPUT_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = dip_meta_fmts,
+		.num_fmts = ARRAY_SIZE(dip_meta_fmts),
+		.default_fmt_idx = 1,
+		.default_width = MTK_DIP_CAPTURE_MAX_WIDTH,
+		.default_height = MTK_DIP_CAPTURE_MAX_HEIGHT,
+		.dma_port = 10,
+		.frmsizeenum = &dip_in_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_out_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "Motion Map input",
+	},
+	{
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_TNRCI_OUT,
+		.name = "Tnrci Input",
+		.cap = V4L2_CAP_VIDEO_OUTPUT_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = dip_meta_fmts,
+		.num_fmts = ARRAY_SIZE(dip_meta_fmts),
+		.default_fmt_idx = 1,
+		.default_width = MTK_DIP_CAPTURE_MAX_WIDTH,
+		.default_height = MTK_DIP_CAPTURE_MAX_HEIGHT,
+		.dma_port = 11,
+		.frmsizeenum = &dip_in_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_out_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "Confidence Map input",
+	},
+	{
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_TNRLI_OUT,
+		.name = "Tnrli Input",
+		.cap = V4L2_CAP_VIDEO_OUTPUT_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = dip_tnrli_fmts,
+		.num_fmts = ARRAY_SIZE(dip_tnrli_fmts),
+		.default_fmt_idx = 1,
+		.default_width = MTK_DIP_CAPTURE_MAX_WIDTH,
+		.default_height = MTK_DIP_CAPTURE_MAX_HEIGHT,
+		.dma_port = 12,
+		.frmsizeenum = &dip_in_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_out_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "Low Frequency Diff input",
+	},
+	{
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_TNRVBI_OUT,
+		.name = "Tnrvbi Input",
+		.cap = V4L2_CAP_VIDEO_OUTPUT_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = dip_meta_fmts,
+		.num_fmts = ARRAY_SIZE(dip_meta_fmts),
+		.default_fmt_idx = 1,
+		.default_width = MTK_DIP_CAPTURE_MAX_WIDTH,
+		.default_height = MTK_DIP_CAPTURE_MAX_HEIGHT,
+		.dma_port = 13,
+		.frmsizeenum = &dip_in_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_out_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "Valid Bit Map input",
+	},
+	/* Output Video Node */
+	{
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_IMG2O_CAPTURE,
+		.name = "Img2o Output",
+		.cap = V4L2_CAP_VIDEO_CAPTURE_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = dip_img2o_fmts,
+		.num_fmts = ARRAY_SIZE(dip_img2o_fmts),
+		.default_fmt_idx = 0,
+		.default_width = MTK_DIP_CAPTURE_MAX_WIDTH,
+		.default_height = MTK_DIP_CAPTURE_MAX_HEIGHT,
+		.dma_port = 0,
+		.frmsizeenum = &dip_out_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_cap_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "Resized output",
+	},
+	{
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_IMG3O_CAPTURE,
+		.name = "Img3o Output",
+		.cap = V4L2_CAP_VIDEO_CAPTURE_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = dip_img3o_fmts,
+		.num_fmts = ARRAY_SIZE(dip_img3o_fmts),
+		.default_fmt_idx = 0,
+		.default_width = MTK_DIP_CAPTURE_MAX_WIDTH,
+		.default_height = MTK_DIP_CAPTURE_MAX_HEIGHT,
+		.dma_port = 1,
+		.frmsizeenum = &dip_out_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_cap_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "Dip output",
+	},
+	{
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_IMG4O_CAPTURE,
+		.name = "Img4o Output",
+		.cap = V4L2_CAP_VIDEO_CAPTURE_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = dip_img4o_fmts,
+		.num_fmts = ARRAY_SIZE(dip_img4o_fmts),
+		.default_fmt_idx = 0,
+		.default_width = MTK_DIP_CAPTURE_MAX_WIDTH,
+		.default_height = MTK_DIP_CAPTURE_MAX_HEIGHT,
+		.dma_port = 2,
+		.frmsizeenum = &dip_out_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_cap_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "Nr3d output",
+	},
+	{
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_FMO_CAPTURE,
+		.name = "FM Output",
+		.cap = V4L2_CAP_VIDEO_CAPTURE_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = dip_meta_fmts,
+		.num_fmts = ARRAY_SIZE(dip_meta_fmts),
+		.default_fmt_idx = 0,
+		.default_width = MTK_DIP_CAPTURE_MAX_WIDTH,
+		.default_height = MTK_DIP_CAPTURE_MAX_HEIGHT,
+		.dma_port = 3,
+		.frmsizeenum = &dip_out_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_cap_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "FM output",
+	},
+	{
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_TNRSO_CAPTURE,
+		.name = "Tnrso Output",
+		.cap = V4L2_CAP_VIDEO_CAPTURE_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = dip_meta_fmts,
+		.num_fmts = ARRAY_SIZE(dip_meta_fmts),
+		.default_fmt_idx = 0,
+		.default_width = MTK_DIP_CAPTURE_MAX_WIDTH,
+		.default_height = MTK_DIP_CAPTURE_MAX_HEIGHT,
+		.dma_port = 4,
+		.frmsizeenum = &dip_out_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_cap_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "statistics output",
+	},
+	{
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_TNRWO_CAPTURE,
+		.name = "Tnrwo Output",
+		.cap = V4L2_CAP_VIDEO_CAPTURE_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = dip_meta_fmts,
+		.num_fmts = ARRAY_SIZE(dip_meta_fmts),
+		.default_fmt_idx = 0,
+		.default_width = MTK_DIP_CAPTURE_MAX_WIDTH,
+		.default_height = MTK_DIP_CAPTURE_MAX_HEIGHT,
+		.dma_port = 5,
+		.frmsizeenum = &dip_out_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_cap_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "Weighting output",
+	},
+	{
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_TNRMO_CAPTURE,
+		.name = "Tnrmo Output",
+		.cap = V4L2_CAP_VIDEO_CAPTURE_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = dip_meta_fmts,
+		.num_fmts = ARRAY_SIZE(dip_meta_fmts),
+		.default_fmt_idx = 0,
+		.default_width = MTK_DIP_CAPTURE_MAX_WIDTH,
+		.default_height = MTK_DIP_CAPTURE_MAX_HEIGHT,
+		.dma_port = 6,
+		.frmsizeenum = &dip_out_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_cap_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "Motion Map output",
+	},
+};
+
+#endif // _MTK_DIP_V4L2_VNODE_H_
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_70/modules/mtk_imgsys-dip.c b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_70/modules/mtk_imgsys-dip.c
new file mode 100644
index 0000000000000000000000000000000000000000..1eecd83b84ef23ef45ebb737c42157a3be76b284
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_70/modules/mtk_imgsys-dip.c
@@ -0,0 +1,401 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2021 MediaTek Inc.
+ *
+ * Author: Frederic Chen <frederic.chen@mediatek.com>
+ *         Holmes Chiou <holmes.chiou@mediatek.com>
+ *
+ */
+
+#include <linux/device.h>
+#include <linux/of_address.h>
+#include <dma-iommu.h>
+#include <linux/pm_runtime.h>
+#include <linux/remoteproc.h>
+#include "mtk_imgsys-dip.h"
+
+const struct mtk_imgsys_init_array mtk_imgsys_dip_init_ary[] = {
+	{0x098, 0x80000000},	/* DIPCTL_D1A_DIPCTL_INT1_EN */
+	{0x0A4, 0x0},	/* DIPCTL_D1A_DIPCTL_INT2_EN */
+	{0x0B0, 0x0},	/* DIPCTL_D1A_DIPCTL_INT3_EN */
+	{0x0BC, 0x0},	/* DIPCTL_D1A_DIPCTL_CQ_INT1_EN */
+	{0x0C8, 0x0},	/* DIPCTL_D1A_DIPCTL_CQ_INT2_EN */
+	{0x0D4, 0x0},	/* DIPCTL_D1A_DIPCTL_CQ_INT3_EN */
+	{0x210, 0x11},	/* DIPCQ_D1A_DIPCQ_CQ_THR0_CTL */
+	{0x21C, 0x11},	/* DIPCQ_D1A_DIPCQ_CQ_THR1_CTL */
+	{0x228, 0x11},	/* DIPCQ_D1A_DIPCQ_CQ_THR2_CTL */
+	{0x234, 0x11},	/* DIPCQ_D1A_DIPCQ_CQ_THR3_CTL */
+	{0x240, 0x11},	/* DIPCQ_D1A_DIPCQ_CQ_THR4_CTL */
+	{0x24C, 0x11},	/* DIPCQ_D1A_DIPCQ_CQ_THR5_CTL */
+	{0x258, 0x11},	/* DIPCQ_D1A_DIPCQ_CQ_THR6_CTL */
+	{0x264, 0x11},	/* DIPCQ_D1A_DIPCQ_CQ_THR7_CTL */
+	{0x270, 0x11},	/* DIPCQ_D1A_DIPCQ_CQ_THR8_CTL */
+	{0x27C, 0x11},	/* DIPCQ_D1A_DIPCQ_CQ_THR9_CTL */
+	{0x288, 0x11},	/* DIPCQ_D1A_DIPCQ_CQ_THR10_CTL */
+	{0x294, 0x11},	/* DIPCQ_D1A_DIPCQ_CQ_THR11_CTL */
+	{0x2A0, 0x11},	/* DIPCQ_D1A_DIPCQ_CQ_THR12_CTL */
+	{0x2AC, 0x11},	/* DIPCQ_D1A_DIPCQ_CQ_THR13_CTL */
+	{0x2B8, 0x11},	/* DIPCQ_D1A_DIPCQ_CQ_THR14_CTL */
+	{0x2C4, 0x11},	/* DIPCQ_D1A_DIPCQ_CQ_THR15_CTL */
+	{0x2D0, 0x11},	/* DIPCQ_D1A_DIPCQ_CQ_THR16_CTL */
+	{0x2DC, 0x11},	/* DIPCQ_D1A_DIPCQ_CQ_THR17_CTL */
+	{0x2E8, 0x11},	/* DIPCQ_D1A_DIPCQ_CQ_THR18_CTL */
+	{0xA1C, 0x80000100},	/* IMGI_D1A_ORIRDMA_CON0 */
+	{0xA20, 0x10AA008A},	/* IMGI_D1A_ORIRDMA_CON1 */
+	{0xA24, 0x11000100},	/* IMGI_D1A_ORIRDMA_CON2 */
+	{0xA7C, 0x80000080},	/* IMGBI_D1A_ORIRDMA_CON0 */
+	{0xA80, 0x10550045},	/* IMGBI_D1A_ORIRDMA_CON1 */
+	{0xA84, 0x10800080},	/* IMGBI_D1A_ORIRDMA_CON2 */
+	{0xADC, 0x80000080},	/* IMGCI_D1A_ORIRDMA_CON0 */
+	{0xAE0, 0x10550045},	/* IMGCI_D1A_ORIRDMA_CON1 */
+	{0xAE4, 0x10800080},	/* IMGCI_D1A_ORIRDMA_CON2 */
+	{0xB3C, 0x80000020},	/* IMGDI_D1A_ORIRDMA_CON0 */
+	{0xB40, 0x10150011},	/* IMGDI_D1A_ORIRDMA_CON1 */
+	{0xB44, 0x10200020},	/* IMGDI_D1A_ORIRDMA_CON2 */
+	{0xB9C, 0x80000080},	/* DEPI_D1A_ORIRDMA_CON0 */
+	{0xBA0, 0x10550045},	/* DEPI_D1A_ORIRDMA_CON1 */
+	{0xBA4, 0x10800080},	/* DEPI_D1A_ORIRDMA_CON2 */
+	{0xBFC, 0x80000080},	/* DMGI_D1A_ORIRDMA_CON0 */
+	{0xC00, 0x10550045},	/* DMGI_D1A_ORIRDMA_CON1 */
+	{0xC04, 0x10800080},	/* DMGI_D1A_ORIRDMA_CON2 */
+	{0xC5C, 0x80000100},	/* VIPI_D1A_ORIRDMA_CON0 */
+	{0xC60, 0x10AA008A},	/* VIPI_D1A_ORIRDMA_CON1 */
+	{0xC64, 0x11000100},	/* VIPI_D1A_ORIRDMA_CON2 */
+	{0xCBC, 0x80000080},	/* VIPBI_D1A_ORIRDMA_CON0 */
+	{0xCC0, 0x10550045},	/* VIPBI_D1A_ORIRDMA_CON1 */
+	{0xCC4, 0x10800080},	/* VIPBI_D1A_ORIRDMA_CON2 */
+	{0xD1C, 0x80000080},	/* VIPCI_D1A_ORIRDMA_CON0 */
+	{0xD20, 0x10550045},	/* VIPCI_D1A_ORIRDMA_CON1 */
+	{0xD24, 0x10800080},	/* VIPCI_D1A_ORIRDMA_CON2 */
+	{0x101C, 0x80000050},	/* TNRWI_D1A_ULCRDMA_CON0 */
+	{0x1020, 0x1035002B},	/* TNRWI_D1A_ULCRDMA_CON1 */
+	{0x1024, 0x10500050},	/* TNRWI_D1A_ULCRDMA_CON2 */
+	{0x105C, 0x80000050},	/* TNRMI_D1A_ULCRDMA_CON0 */
+	{0x1060, 0x1035002B},	/* TNRMI_D1A_ULCRDMA_CON1 */
+	{0x1064, 0x10500050},	/* TNRMI_D1A_ULCRDMA_CON2 */
+	{0x109C, 0x80000020},	/* TNRCI_D1A_ULCRDMA_CON0 */
+	{0x10A0, 0x10150011},	/* TNRCI_D1A_ULCRDMA_CON1 */
+	{0x10A4, 0x10200020},	/* TNRCI_D1A_ULCRDMA_CON2 */
+	{0x10DC, 0x80000050},	/* TNRVBI_D1A_ULCRDMA_CON0 */
+	{0x10E0, 0x1035002B},	/* TNRVBI_D1A_ULCRDMA_CON1 */
+	{0x10E4, 0x10500050},	/* TNRVBI_D1A_ULCRDMA_CON2 */
+	{0x111C, 0x80000020},	/* TNRLYI_D1A_ULCRDMA_CON0 */
+	{0x1120, 0x10150011},	/* TNRLYI_D1A_ULCRDMA_CON1 */
+	{0x1124, 0x10200020},	/* TNRLYI_D1A_ULCRDMA_CON2 */
+	{0x115C, 0x80000020},	/* TNRLCI_D1A_ULCRDMA_CON0 */
+	{0x1160, 0x10150011},	/* TNRLCI_D1A_ULCRDMA_CON1 */
+	{0x1164, 0x10200020},	/* TNRLCI_D1A_ULCRDMA_CON2 */
+	{0x119C, 0x80000020},	/* TNRSI_D1A_ULCRDMA_CON0 */
+	{0x11A0, 0x10150011},	/* TNRSI_D1A_ULCRDMA_CON1 */
+	{0x11A4, 0x10200020},	/* TNRSI_D1A_ULCRDMA_CON2 */
+	{0x11DC, 0x80000080},	/* RECI_D1A_ORIRDMA_CON0 */
+	{0x11E0, 0x10550045},	/* RECI_D1A_ORIRDMA_CON1 */
+	{0x11E4, 0x10800080},	/* RECI_D1A_ORIRDMA_CON2 */
+	{0x121C, 0x80000040},	/* RECBI_D1A_ORIRDMA_CON0 */
+	{0x1220, 0x102A0022},	/* RECBI_D1A_ORIRDMA_CON1 */
+	{0x1224, 0x10400040},	/* RECBI_D1A_ORIRDMA_CON2 */
+	{0x125C, 0x80000080},	/* RECI_D2A_ORIRDMA_CON0 */
+	{0x1260, 0x10550045},	/* RECI_D2A_ORIRDMA_CON1 */
+	{0x1264, 0x10800080},	/* RECI_D2A_ORIRDMA_CON2 */
+	{0x129C, 0x80000040},	/* RECBI_D2A_ORIRDMA_CON0 */
+	{0x12A0, 0x102A0022},	/* RECBI_D2A_ORIRDMA_CON1 */
+	{0x12A4, 0x10400040},	/* RECBI_D2A_ORIRDMA_CON2 */
+	{0x12DC, 0x80000020},	/* SMTI_D1A_ULCRDMA_CON0 */
+	{0x12E0, 0x10150011},	/* SMTI_D1A_ULCRDMA_CON1 */
+	{0x12E4, 0x10200020},	/* SMTI_D1A_ULCRDMA_CON2 */
+	{0x131C, 0x80000020},	/* SMTI_D2A_ULCRDMA_CON0 */
+	{0x1320, 0x10150011},	/* SMTI_D2A_ULCRDMA_CON1 */
+	{0x1324, 0x10200020},	/* SMTI_D2A_ULCRDMA_CON2 */
+	{0x135C, 0x80000020},	/* SMTI_D3A_ULCRDMA_CON0 */
+	{0x1360, 0x10150011},	/* SMTI_D3A_ULCRDMA_CON1 */
+	{0x1364, 0x10200020},	/* SMTI_D3A_ULCRDMA_CON2 */
+	{0x139C, 0x80000020},	/* SMTI_D4A_ULCRDMA_CON0 */
+	{0x13A0, 0x10150011},	/* SMTI_D4A_ULCRDMA_CON1 */
+	{0x13A4, 0x10200020},	/* SMTI_D4A_ULCRDMA_CON2 */
+	{0x13DC, 0x80000020},	/* SMTI_D5A_ULCRDMA_CON0 */
+	{0x13E0, 0x10150011},	/* SMTI_D5A_ULCRDMA_CON1 */
+	{0x13E4, 0x10200020},	/* SMTI_D5A_ULCRDMA_CON2 */
+	{0x141C, 0x80000020},	/* SMTI_D6A_ULCRDMA_CON0 */
+	{0x1420, 0x10150011},	/* SMTI_D6A_ULCRDMA_CON1 */
+	{0x1424, 0x10200020},	/* SMTI_D6A_ULCRDMA_CON2 */
+	{0x145C, 0x80000020},	/* SMTI_D7A_ULCRDMA_CON0 */
+	{0x1460, 0x10150011},	/* SMTI_D7A_ULCRDMA_CON1 */
+	{0x1464, 0x10200020},	/* SMTI_D7A_ULCRDMA_CON2 */
+	{0x149C, 0x80000020},	/* SMTI_D8A_ULCRDMA_CON0 */
+	{0x14A0, 0x10150011},	/* SMTI_D8A_ULCRDMA_CON1 */
+	{0x14A4, 0x10200020},	/* SMTI_D8A_ULCRDMA_CON2 */
+	{0x14DC, 0x80000020},	/* SMTI_D9A_ULCRDMA_CON0 */
+	{0x14E0, 0x10150011},	/* SMTI_D9A_ULCRDMA_CON1 */
+	{0x14E4, 0x10200020},	/* SMTI_D9A_ULCRDMA_CON2 */
+	{0x151C, 0x80000100},	/* IMG3O_D1A_ORIWDMA_CON0 */
+	{0x1520, 0x10AA008A},	/* IMG3O_D1A_ORIWDMA_CON1 */
+	{0x1524, 0x11000100},	/* IMG3O_D1A_ORIWDMA_CON2 */
+	{0x15CC, 0x80000080},	/* IMG3BO_D1A_ORIWDMA_CON0 */
+	{0x15D0, 0x10550045},	/* IMG3BO_D1A_ORIWDMA_CON1 */
+	{0x15D4, 0x10800080},	/* IMG3BO_D1A_ORIWDMA_CON2 */
+	{0x167C, 0x80000080},	/* IMG3CO_D1A_ORIWDMA_CON0 */
+	{0x1680, 0x10550045},	/* IMG3CO_D1A_ORIWDMA_CON1 */
+	{0x1684, 0x10800080},	/* IMG3CO_D1A_ORIWDMA_CON2 */
+	{0x172C, 0x80000020},	/* IMG3DO_D1A_ORIWDMA_CON0 */
+	{0x1730, 0x10150011},	/* IMG3DO_D1A_ORIWDMA_CON1 */
+	{0x1734, 0x10200020},	/* IMG3DO_D1A_ORIWDMA_CON2 */
+	{0x17DC, 0x80000080},	/* IMG4O_D1A_ORIWDMA_CON0 */
+	{0x17E0, 0x10550045},	/* IMG4O_D1A_ORIWDMA_CON1 */
+	{0x17E4, 0x10800080},	/* IMG4O_D1A_ORIWDMA_CON2 */
+	{0x188C, 0x80000040},	/* IMG4BO_D1A_ORIWDMA_CON0 */
+	{0x1890, 0x102A0022},	/* IMG4BO_D1A_ORIWDMA_CON1 */
+	{0x1894, 0x10400040},	/* IMG4BO_D1A_ORIWDMA_CON2 */
+	{0x193C, 0x80000020},	/* IMG4CO_D1A_ORIWDMA_CON0 */
+	{0x1940, 0x10150011},	/* IMG4CO_D1A_ORIWDMA_CON1 */
+	{0x1944, 0x10200020},	/* IMG4CO_D1A_ORIWDMA_CON2 */
+	{0x19EC, 0x80000020},	/* IMG4DO_D1A_ORIWDMA_CON0 */
+	{0x19F0, 0x10150011},	/* IMG4DO_D1A_ORIWDMA_CON1 */
+	{0x19F4, 0x10200020},	/* IMG4DO_D1A_ORIWDMA_CON2 */
+	{0x1A9C, 0x800000A0},	/* FEO_D1A_ORIWDMA_CON0 */
+	{0x1AA0, 0x106A0056},	/* FEO_D1A_ORIWDMA_CON1 */
+	{0x1AA4, 0x10A000A0},	/* FEO_D1A_ORIWDMA_CON2 */
+	{0x1B4C, 0x80000080},	/* IMG2O_D1A_ORIWDMA_CON0 */
+	{0x1B50, 0x10550045},	/* IMG2O_D1A_ORIWDMA_CON1 */
+	{0x1B54, 0x10800080},	/* IMG2O_D1A_ORIWDMA_CON2 */
+	{0x1B8C, 0x80000040},	/* IMG2BO_D1A_ORIWDMA_CON0 */
+	{0x1B90, 0x102A0022},	/* IMG2BO_D1A_ORIWDMA_CON1 */
+	{0x1B94, 0x10400040},	/* IMG2BO_D1A_ORIWDMA_CON2 */
+	{0x1BCC, 0x80000050},	/* TNRWO_D1A_ULCWDMA_CON0 */
+	{0x1BD0, 0x1035002B},	/* TNRWO_D1A_ULCWDMA_CON1 */
+	{0x1BD4, 0x10500050},	/* TNRWO_D1A_ULCWDMA_CON2 */
+	{0x1C0C, 0x80000050},	/* TNRMO_D1A_ULCWDMA_CON0 */
+	{0x1C10, 0x1035002B},	/* TNRMO_D1A_ULCWDMA_CON1 */
+	{0x1C14, 0x10500050},	/* TNRMO_D1A_ULCWDMA_CON2 */
+	{0x1C4C, 0x80000020},	/* TNRSO_D1A_ULCWDMA_CON0 */
+	{0x1C50, 0x10150011},	/* TNRSO_D1A_ULCWDMA_CON1 */
+	{0x1C54, 0x10200020},	/* TNRSO_D1A_ULCWDMA_CON2 */
+	{0x1C8C, 0x80000020},	/* SMTO_D1A_ULCWDMA_CON0 */
+	{0x1C90, 0x10150011},	/* SMTO_D1A_ULCWDMA_CON1 */
+	{0x1C94, 0x10200020},	/* SMTO_D1A_ULCWDMA_CON2 */
+	{0x1CCC, 0x80000020},	/* SMTO_D2A_ULCWDMA_CON0 */
+	{0x1CD0, 0x10150011},	/* SMTO_D2A_ULCWDMA_CON1 */
+	{0x1CD4, 0x10200020},	/* SMTO_D2A_ULCWDMA_CON2 */
+	{0x1D0C, 0x80000020},	/* SMTO_D3A_ULCWDMA_CON0 */
+	{0x1D10, 0x10150011},	/* SMTO_D3A_ULCWDMA_CON1 */
+	{0x1D14, 0x10200020},	/* SMTO_D3A_ULCWDMA_CON2 */
+	{0x1D4C, 0x80000020},	/* SMTO_D4A_ULCWDMA_CON0 */
+	{0x1D50, 0x10150011},	/* SMTO_D4A_ULCWDMA_CON1 */
+	{0x1D54, 0x10200020},	/* SMTO_D4A_ULCWDMA_CON2 */
+	{0x1D8C, 0x80000020},	/* SMTO_D5A_ULCWDMA_CON0 */
+	{0x1D90, 0x10150011},	/* SMTO_D5A_ULCWDMA_CON1 */
+	{0x1D94, 0x10200020},	/* SMTO_D5A_ULCWDMA_CON2 */
+	{0x1DCC, 0x80000020},	/* SMTO_D6A_ULCWDMA_CON0 */
+	{0x1DD0, 0x10150011},	/* SMTO_D6A_ULCWDMA_CON1 */
+	{0x1DD4, 0x10200020},	/* SMTO_D6A_ULCWDMA_CON2 */
+	{0x1E0C, 0x80000020},	/* SMTO_D7A_ULCWDMA_CON0 */
+	{0x1E10, 0x10150011},	/* SMTO_D7A_ULCWDMA_CON1 */
+	{0x1E14, 0x10200020},	/* SMTO_D7A_ULCWDMA_CON2 */
+	{0x1E4C, 0x80000020},	/* SMTO_D8A_ULCWDMA_CON0 */
+	{0x1E50, 0x10150011},	/* SMTO_D8A_ULCWDMA_CON1 */
+	{0x1E54, 0x10200020},	/* SMTO_D8A_ULCWDMA_CON2 */
+	{0x1E8C, 0x80000020},	/* SMTO_D9A_ULCWDMA_CON0 */
+	{0x1E90, 0x10150011},	/* SMTO_D9A_ULCWDMA_CON1 */
+	{0x1E94, 0x10200020}	/* SMTO_D9A_ULCWDMA_CON2 */
+};
+
+void __iomem *gdipRegBA;
+
+void imgsys_dip_set_initial_value(struct mtk_imgsys_dev *imgsys_dev)
+{
+	pr_debug("%s: +\n", __func__);
+	dev_dbg(imgsys_dev->dev, "%s: +\n", __func__);
+
+	/* iomap registers */
+	gdipRegBA = of_iomap(imgsys_dev->dev->of_node, REG_MAP_E_DIP);
+	if (!gdipRegBA) {
+		dev_info(imgsys_dev->dev,
+			"%s: error: unable to iomap dip_%d registers, devnode(%s).\n",
+			__func__, REG_MAP_E_DIP, imgsys_dev->dev->of_node->name);
+	}
+
+	pr_debug("%s: -\n", __func__);
+	dev_dbg(imgsys_dev->dev, "%s: -\n", __func__);
+}
+EXPORT_SYMBOL(imgsys_dip_set_initial_value);
+
+void imgsys_dip_set_hw_initial_value(struct mtk_imgsys_dev *imgsys_dev)
+{
+	void __iomem *ofset = NULL;
+	unsigned int i;
+
+	for (i = 0; i < sizeof(mtk_imgsys_dip_init_ary)/sizeof(struct mtk_imgsys_init_array); i++) {
+		ofset = gdipRegBA + mtk_imgsys_dip_init_ary[i].ofset;
+		writel(mtk_imgsys_dip_init_ary[i].val, ofset);
+	}
+}
+EXPORT_SYMBOL(imgsys_dip_set_hw_initial_value);
+
+void imgsys_dip_debug_dump(struct mtk_imgsys_dev *imgsys_dev,
+							unsigned int engine)
+{
+	void __iomem *dipRegBA = gdipRegBA;
+	unsigned int i;
+
+	pr_info("%s: +\n", __func__);
+	dev_dbg(imgsys_dev->dev, "%s: +\n", __func__);
+
+	dev_info(imgsys_dev->dev, "%s: dump dip ctl regs\n", __func__);
+	for (i = TOP_CTL_OFFSET; i <= TOP_CTL_OFFSET + TOP_CTL_RANGE; i += 0x10) {
+		dev_info(imgsys_dev->dev, "%s: [0x%08X 0x%08X][0x%08X 0x%08X][0x%08X 0x%08X][0x%08X 0x%08X]",
+		__func__, (unsigned int)(0x15100000 + i),
+		(unsigned int)ioread32((void *)(dipRegBA + i)),
+		(unsigned int)(0x15100000 + i + 0x4),
+		(unsigned int)ioread32((void *)(dipRegBA + i + 0x4)),
+		(unsigned int)(0x15100000 + i + 0x8),
+		(unsigned int)ioread32((void *)(dipRegBA + i + 0x8)),
+		(unsigned int)(0x15100000 + i + 0xc),
+		(unsigned int)ioread32((void *)(dipRegBA + i + 0xc)));
+	}
+
+	dev_info(imgsys_dev->dev, "%s: dump dip dmatop regs\n", __func__);
+	for (i = DMATOP_OFFSET; i <= DMATOP_OFFSET + DMATOP_RANGE; i += 0x10) {
+		dev_info(imgsys_dev->dev, "%s: [0x%08X 0x%08X][0x%08X 0x%08X][0x%08X 0x%08X][0x%08X 0x%08X]",
+		__func__, (unsigned int)(0x15100000 + i),
+		(unsigned int)ioread32((void *)(dipRegBA + i)),
+		(unsigned int)(0x15100000 + i + 0x4),
+		(unsigned int)ioread32((void *)(dipRegBA + i + 0x4)),
+		(unsigned int)(0x15100000 + i + 0x8),
+		(unsigned int)ioread32((void *)(dipRegBA + i + 0x8)),
+		(unsigned int)(0x15100000 + i + 0xc),
+		(unsigned int)ioread32((void *)(dipRegBA + i + 0xc)));
+	}
+
+	dev_info(imgsys_dev->dev, "%s: dump dip rdma regs\n", __func__);
+	for (i = RDMA_OFFSET; i <= RDMA_OFFSET + RDMA_RANGE; i += 0x10) {
+		dev_info(imgsys_dev->dev, "%s: [0x%08X 0x%08X][0x%08X 0x%08X][0x%08X 0x%08X][0x%08X 0x%08X]",
+		__func__, (unsigned int)(0x15100000 + i),
+		(unsigned int)ioread32((void *)(dipRegBA + i)),
+		(unsigned int)(0x15100000 + i + 0x4),
+		(unsigned int)ioread32((void *)(dipRegBA + i + 0x4)),
+		(unsigned int)(0x15100000 + i + 0x8),
+		(unsigned int)ioread32((void *)(dipRegBA + i + 0x8)),
+		(unsigned int)(0x15100000 + i + 0xc),
+		(unsigned int)ioread32((void *)(dipRegBA + i + 0xc)));
+	}
+
+	dev_info(imgsys_dev->dev, "%s: dump dip wdma regs\n", __func__);
+	for (i = WDMA_OFFSET; i <= WDMA_OFFSET + WDMA_RANGE; i += 0x10) {
+		dev_info(imgsys_dev->dev, "%s: [0x%08X 0x%08X][0x%08X 0x%08X][0x%08X 0x%08X][0x%08X 0x%08X]",
+		__func__, (unsigned int)(0x15100000 + i),
+		(unsigned int)ioread32((void *)(dipRegBA + i)),
+		(unsigned int)(0x15100000 + i + 0x4),
+		(unsigned int)ioread32((void *)(dipRegBA + i + 0x4)),
+		(unsigned int)(0x15100000 + i + 0x8),
+		(unsigned int)ioread32((void *)(dipRegBA + i + 0x8)),
+		(unsigned int)(0x15100000 + i + 0xc),
+		(unsigned int)ioread32((void *)(dipRegBA + i + 0xc)));
+	}
+
+	dev_info(imgsys_dev->dev, "%s: dump nr3d ctl regs\n", __func__);
+	for (i = NR3D_CTL_OFFSET; i <= NR3D_CTL_OFFSET + NR3D_CTL_RANGE; i += 0x10) {
+		dev_info(imgsys_dev->dev, "%s: [0x%08X 0x%08X][0x%08X 0x%08X][0x%08X 0x%08X][0x%08X 0x%08X]",
+		__func__, (unsigned int)(0x15100000 + i),
+		(unsigned int)ioread32((void *)(dipRegBA + i)),
+		(unsigned int)(0x15100000 + i + 0x4),
+		(unsigned int)ioread32((void *)(dipRegBA + i + 0x4)),
+		(unsigned int)(0x15100000 + i + 0x8),
+		(unsigned int)ioread32((void *)(dipRegBA + i + 0x8)),
+		(unsigned int)(0x15100000 + i + 0xc),
+		(unsigned int)ioread32((void *)(dipRegBA + i + 0xc)));
+	}
+
+	dev_info(imgsys_dev->dev, "%s: dump tnr ctl regs\n", __func__);
+	for (i = TNR_CTL_OFFSET; i <= TNR_CTL_OFFSET + TNR_CTL_RANGE; i += 0x10) {
+		dev_info(imgsys_dev->dev, "%s: [0x%08X 0x%08X][0x%08X 0x%08X][0x%08X 0x%08X][0x%08X 0x%08X]",
+		__func__, (unsigned int)(0x15100000 + i),
+		(unsigned int)ioread32((void *)(dipRegBA + i)),
+		(unsigned int)(0x15100000 + i + 0x4),
+		(unsigned int)ioread32((void *)(dipRegBA + i + 0x4)),
+		(unsigned int)(0x15100000 + i + 0x8),
+		(unsigned int)ioread32((void *)(dipRegBA + i + 0x8)),
+		(unsigned int)(0x15100000 + i + 0xc),
+		(unsigned int)ioread32((void *)(dipRegBA + i + 0xc)));
+	}
+
+	dev_info(imgsys_dev->dev, "%s: dump mcrop regs\n", __func__);
+	for (i = MCRP_OFFSET; i <= MCRP_OFFSET + MCRP_RANGE; i += 0x8) {
+		dev_info(imgsys_dev->dev, "%s: [0x%08X 0x%08X][0x%08X 0x%08X]",
+		__func__, (unsigned int)(0x15100000 + i),
+		(unsigned int)ioread32((void *)(dipRegBA + i)),
+		(unsigned int)(0x15100000 + i + 0x4),
+		(unsigned int)ioread32((void *)(dipRegBA + i + 0x4)));
+	}
+
+	/* Set DIPCTL_DBG_SEL[3:0] to 0x1 */
+	/* Set DIPCTL_DBG_SEL[15:8] to 0x18 */
+	/* Set DIPCTL_DBG_SEL[19:6] to 0x1*/
+	dev_info(imgsys_dev->dev, "%s: dipctl_dbg_sel_tnc\n", __func__);
+	iowrite32(0x1801, (void *)(dipRegBA + DIPCTL_DBG_SEL));
+	dev_info(imgsys_dev->dev, "%s: tnc_debug: %08X", __func__,
+	(unsigned int)ioread32((void *)(dipRegBA + DIPCTL_DBG_OUT)));
+
+	/* Set DIPCTL_DBG_SEL[3:0] to 0x1 */
+	/* Set DIPCTL_DBG_SEL[15:8] to 0x0 */
+	/* Set DIPCTL_DBG_SEL[19:6] to 0x0~0xD */
+	dev_info(imgsys_dev->dev, "%s: dipctl_dbg_sel_nr3d\n", __func__);
+	iowrite32(0x13, (void *)(dipRegBA + NR3D_DBG_SEL));
+	iowrite32(0x00001, (void *)(dipRegBA + DIPCTL_DBG_SEL));
+	dev_info(imgsys_dev->dev, "%s: nr3d_sot_latch_32~1: %08X", __func__,
+	(unsigned int)ioread32((void *)(dipRegBA + DIPCTL_DBG_OUT)));
+	iowrite32(0x20001, (void *)(dipRegBA + DIPCTL_DBG_SEL));
+	dev_info(imgsys_dev->dev, "%s: nr3d_eot_latch_32~1: %08X", __func__,
+	(unsigned int)ioread32((void *)(dipRegBA + DIPCTL_DBG_OUT)));
+	iowrite32(0x10001, (void *)(dipRegBA + DIPCTL_DBG_SEL));
+	dev_info(imgsys_dev->dev, "%s: nr3d_sot_latch_33~39: %08X", __func__,
+	(unsigned int)ioread32((void *)(dipRegBA + DIPCTL_DBG_OUT)));
+	iowrite32(0x30001, (void *)(dipRegBA + DIPCTL_DBG_SEL));
+	dev_info(imgsys_dev->dev, "%s: nr3d_eot_latch_33~39: %08X", __func__,
+	(unsigned int)ioread32((void *)(dipRegBA + DIPCTL_DBG_OUT)));
+	iowrite32(0x40001, (void *)(dipRegBA + DIPCTL_DBG_SEL));
+	dev_info(imgsys_dev->dev, "%s: nr3d_tif4~1: %08X", __func__,
+	(unsigned int)ioread32((void *)(dipRegBA + DIPCTL_DBG_OUT)));
+	iowrite32(0x50001, (void *)(dipRegBA + DIPCTL_DBG_SEL));
+	dev_info(imgsys_dev->dev, "%s: nr3d_tif8~5: %08X", __func__,
+	(unsigned int)ioread32((void *)(dipRegBA + DIPCTL_DBG_OUT)));
+	iowrite32(0x60001, (void *)(dipRegBA + DIPCTL_DBG_SEL));
+	dev_info(imgsys_dev->dev, "%s: nr3d_tif12~9: %08X", __func__,
+	(unsigned int)ioread32((void *)(dipRegBA + DIPCTL_DBG_OUT)));
+	iowrite32(0x70001, (void *)(dipRegBA + DIPCTL_DBG_SEL));
+	dev_info(imgsys_dev->dev, "%s: nr3d_tif16~13: %08X", __func__,
+	(unsigned int)ioread32((void *)(dipRegBA + DIPCTL_DBG_OUT)));
+	iowrite32(0x80001, (void *)(dipRegBA + DIPCTL_DBG_SEL));
+	dev_info(imgsys_dev->dev, "%s: nr3d_tif20~17: %08X", __func__,
+	(unsigned int)ioread32((void *)(dipRegBA + DIPCTL_DBG_OUT)));
+	iowrite32(0x90001, (void *)(dipRegBA + DIPCTL_DBG_SEL));
+	dev_info(imgsys_dev->dev, "%s: nr3d_tif24~21: %08X", __func__,
+	(unsigned int)ioread32((void *)(dipRegBA + DIPCTL_DBG_OUT)));
+	iowrite32(0xA0001, (void *)(dipRegBA + DIPCTL_DBG_SEL));
+	dev_info(imgsys_dev->dev, "%s: nr3d_tif28~25: %08X", __func__,
+	(unsigned int)ioread32((void *)(dipRegBA + DIPCTL_DBG_OUT)));
+	iowrite32(0xB0001, (void *)(dipRegBA + DIPCTL_DBG_SEL));
+	dev_info(imgsys_dev->dev, "%s: nr3d_tif32~29: %08X", __func__,
+	(unsigned int)ioread32((void *)(dipRegBA + DIPCTL_DBG_OUT)));
+	iowrite32(0xC0001, (void *)(dipRegBA + DIPCTL_DBG_SEL));
+	dev_info(imgsys_dev->dev, "%s: nr3d_tif36~33: %08X", __func__,
+	(unsigned int)ioread32((void *)(dipRegBA + DIPCTL_DBG_OUT)));
+	iowrite32(0xD0001, (void *)(dipRegBA + DIPCTL_DBG_SEL));
+	dev_info(imgsys_dev->dev, "%s: nr3d_tif39~37: %08X", __func__,
+	(unsigned int)ioread32((void *)(dipRegBA + DIPCTL_DBG_OUT)));
+
+	//dev_dbg(imgsys_dev->dev, "%s: +\n",__func__);
+	//
+	pr_info("%s: -\n", __func__);
+	dev_dbg(imgsys_dev->dev, "%s: -\n", __func__);
+}
+EXPORT_SYMBOL(imgsys_dip_debug_dump);
+
+void imgsys_dip_uninit(struct mtk_imgsys_dev *imgsys_dev)
+{
+	pr_debug("%s: +\n", __func__);
+
+	iounmap(gdipRegBA);
+	gdipRegBA = 0L;
+
+	pr_debug("%s: -\n", __func__);
+}
+EXPORT_SYMBOL(imgsys_dip_uninit);
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_70/modules/mtk_imgsys-dip.h b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_70/modules/mtk_imgsys-dip.h
new file mode 100644
index 0000000000000000000000000000000000000000..c9cd6225bcf99c263b2f7a073cb9b9eed146c3d3
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_70/modules/mtk_imgsys-dip.h
@@ -0,0 +1,42 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2021 MediaTek Inc.
+ *
+ * Author: Frederic Chen <frederic.chen@mediatek.com>
+ *
+ */
+
+#ifndef _MTK_DIP_DIP_H_
+#define _MTK_DIP_DIP_H_
+
+#include "mtk_imgsys-dev.h"
+#include "mtk_imgsys-cmdq.h"
+#include "mtk_imgsys-engine.h"
+/* DIP */
+#define TOP_CTL_OFFSET	0x0000
+#define TOP_CTL_RANGE	0x02F0
+#define DMATOP_OFFSET	0x0800
+#define DMATOP_RANGE	0x0080
+#define RDMA_OFFSET	0x0A00
+#define RDMA_RANGE	0x08B4
+#define WDMA_OFFSET	0x1500
+#define WDMA_RANGE	0x0760
+#define NR3D_CTL_OFFSET	0x2000
+#define NR3D_CTL_RANGE	0x0484
+#define TNR_CTL_OFFSET	0x3000
+#define TNR_CTL_RANGE	0x0234
+#define MCRP_OFFSET	0xA300
+#define MCRP_RANGE	0x0004
+
+#define DIPCTL_DBG_SEL 0x170
+#define DIPCTL_DBG_OUT 0x174
+#define NR3D_DBG_SEL 0x200C
+
+void imgsys_dip_set_initial_value(struct mtk_imgsys_dev *imgsys_dev);
+void imgsys_dip_set_hw_initial_value(struct mtk_imgsys_dev *imgsys_dev);
+void imgsys_dip_debug_dump(struct mtk_imgsys_dev *imgsys_dev,
+							unsigned int engine);
+
+void imgsys_dip_uninit(struct mtk_imgsys_dev *imgsys_dev);
+#endif /* _MTK_DIP_DIP_H_ */
+
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_70/modules/mtk_imgsys-pqdip.c b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_70/modules/mtk_imgsys-pqdip.c
new file mode 100644
index 0000000000000000000000000000000000000000..ec75745b98c834d1cde4157d98951b9f2aa8f939
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_70/modules/mtk_imgsys-pqdip.c
@@ -0,0 +1,558 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2021 MediaTek Inc.
+ *
+ * Author: Daniel Huang <daniel.huang@mediatek.com>
+ *
+ */
+
+ // Standard C header file
+
+// kernel header file
+#include <linux/device.h>
+#include <linux/of_address.h>
+#include <dma-iommu.h>
+#include <linux/pm_runtime.h>
+#include <linux/remoteproc.h>
+
+// mtk imgsys local header file
+
+// Local header file
+#include "mtk_imgsys-pqdip.h"
+
+/********************************************************************
+ * Global Define
+ ********************************************************************/
+#define PQDIP_HW_SET		2
+
+#define PQDIP_BASE_ADDR		0x15140000
+#define PQDIP_OFST			0x10000
+#define PQDIP_ALL_REG_CNT	0x6000
+//#define DUMP_PQ_ALL
+
+#define PQDIP_CTL_OFST		0x0
+#define PQDIP_CQ_OFST		0x200
+#define PQDIP_DMA_OFST		0x1200
+#define PQDIP_WROT1_OFST	0x2000
+#define PQDIP_WROT2_OFST	0x2F00
+#define PQDIP_RZH4N6T_OFST	0x3000
+#define PQDIP_TDSHP1OFST	0x4120
+#define PQDIP_TDSHP2OFST	0x4510
+#define PQDIP_TDSHP3OFST	0x4568
+#define PQDIP_UNP1_OFST		0x5000
+#define PQDIP_UNP2_OFST		0x5040
+#define PQDIP_UNP3_OFST		0x5080
+#define PQDIP_C02_OFST		0x5100
+#define PQDIP_C24_OFST		0x5140
+#define PQDIP_MCRP_OFST		0x53C0
+#define PQDIP_TCC_OFST		0x59E0
+
+#define PQDIP_CTL_REG_CNT		0xE0
+#define PQDIP_CQ_REG_CNT		0x100
+#define PQDIP_DMA_REG_CNT		0x120
+#define PQDIP_WROT1_REG_CNT		0x100
+#define PQDIP_WROT2_REG_CNT		0x40
+#define PQDIP_RZH4N6T_REG_CNT	0x260
+#define PQDIP_TDSHP1REG_CNT		0x10
+#define PQDIP_TDSHP2REG_CNT		0x10
+#define PQDIP_TDSHP3REG_CNT		0x10
+#define PQDIP_UNP_REG_CNT		0x10
+#define PQDIP_C02_REG_CNT		0x20
+#define PQDIP_C24_REG_CNT		0x10
+#define PQDIP_MCRP_REG_CNT		0x10
+#define PQDIP_TCC_REG_CNT		0x10
+
+#define PQDIPCTL_DBG_SEL_OFST	0xE0
+#define PQDIPCTL_DBG_OUT_OFST	0xE4
+#define PQ_WROT_DBG_SEL_OFST	0x2018
+#define PQ_WROT_DBG_OUT_OFST	0x20D0
+#define PQ_RZH4N6T_DBG_SEL_OFST	0x3044
+#define PQ_RZH4N6T_DBG_OUT_OFST	0x3048
+
+/********************************************************************
+ * Global Variable
+ ********************************************************************/
+const struct mtk_imgsys_init_array
+			mtk_imgsys_pqdip_init_ary[] = {
+	{0x0050, 0x80000000},	/* PQDIPCTL_P1A_REG_PQDIPCTL_INT1_EN */
+	{0x0060, 0x0},		/* PQDIPCTL_P1A_REG_PQDIPCTL_INT2_EN */
+	{0x0070, 0x0},		/* PQDIPCTL_P1A_REG_PQDIPCTL_CQ_INT1_EN */
+	{0x0080, 0x0},		/* PQDIPCTL_P1A_REG_PQDIPCTL_CQ_INT2_EN */
+	{0x0090, 0x0},		/* PQDIPCTL_P1A_REG_PQDIPCTL_CQ_INT3_EN */
+	{0x00B0, 0x0},		/* PQDIPCTL_P1A_REG_PQDIPCTL_PQDIP_DCM_DIS */
+	{0x00B4, 0x0},		/* PQDIPCTL_P1A_REG_PQDIPCTL_DMA_DCM_DIS */
+	{0x00B8, 0x0},		/* PQDIPCTL_P1A_REG_PQDIPCTL_TOP_DCM_DIS */
+	{0x0210, 0x11},		/* DIPCQ_P1A_REG_DIPCQ_CQ_THR0_CTL */
+	{0x0218, 0x400},	/* DIPCQ_P1A_REG_DIPCQ_CQ_THR0_DESC_SIZE */
+	{0x021C, 0x11},		/* DIPCQ_P1A_REG_DIPCQ_CQ_THR1_CTL */
+	{0x0224, 0x400},	/* DIPCQ_P1A_REG_DIPCQ_CQ_THR1_DESC_SIZE */
+	{0x0228, 0x11},		/* DIPCQ_P1A_REG_DIPCQ_CQ_THR2_CTL */
+	{0x0230, 0x400},	/* DIPCQ_P1A_REG_DIPCQ_CQ_THR2_DESC_SIZE */
+	{0x0234, 0x11},		/* DIPCQ_P1A_REG_DIPCQ_CQ_THR3_CTL */
+	{0x023C, 0x400},	/* DIPCQ_P1A_REG_DIPCQ_CQ_THR3_DESC_SIZE */
+	{0x0240, 0x11},		/* DIPCQ_P1A_REG_DIPCQ_CQ_THR4_CTL */
+	{0x0248, 0x400},	/* DIPCQ_P1A_REG_DIPCQ_CQ_THR4_DESC_SIZE */
+	{0x024C, 0x11},		/* DIPCQ_P1A_REG_DIPCQ_CQ_THR5_CTL */
+	{0x0254, 0x400},	/* DIPCQ_P1A_REG_DIPCQ_CQ_THR5_DESC_SIZE */
+	{0x0258, 0x11},		/* DIPCQ_P1A_REG_DIPCQ_CQ_THR6_CTL */
+	{0x0260, 0x400},	/* DIPCQ_P1A_REG_DIPCQ_CQ_THR6_DESC_SIZE */
+	{0x0264, 0x11},		/* DIPCQ_P1A_REG_DIPCQ_CQ_THR7_CTL */
+	{0x026C, 0x400},	/* DIPCQ_P1A_REG_DIPCQ_CQ_THR7_DESC_SIZE */
+	{0x0270, 0x11},		/* DIPCQ_P1A_REG_DIPCQ_CQ_THR8_CTL */
+	{0x0278, 0x400},	/* DIPCQ_P1A_REG_DIPCQ_CQ_THR8_DESC_SIZE */
+	{0x027C, 0x11},		/* DIPCQ_P1A_REG_DIPCQ_CQ_THR9_CTL */
+	{0x0284, 0x400},	/* DIPCQ_P1A_REG_DIPCQ_CQ_THR9_DESC_SIZE */
+	{0x0288, 0x11},		/* DIPCQ_P1A_REG_DIPCQ_CQ_THR10_CTL */
+	{0x0290, 0x400},	/* DIPCQ_P1A_REG_DIPCQ_CQ_THR10_DESC_SIZE */
+	{0x0294, 0x11},		/* DIPCQ_P1A_REG_DIPCQ_CQ_THR11_CTL */
+	{0x029C, 0x400},	/* DIPCQ_P1A_REG_DIPCQ_CQ_THR11_DESC_SIZE */
+	{0x02A0, 0x11},		/* DIPCQ_P1A_REG_DIPCQ_CQ_THR12_CTL */
+	{0x02A8, 0x400},	/* DIPCQ_P1A_REG_DIPCQ_CQ_THR12_DESC_SIZE */
+	{0x02AC, 0x11},		/* DIPCQ_P1A_REG_DIPCQ_CQ_THR13_CTL */
+	{0x02B4, 0x400},	/* DIPCQ_P1A_REG_DIPCQ_CQ_THR13_DESC_SIZE */
+	{0x02B8, 0x11},		/* DIPCQ_P1A_REG_DIPCQ_CQ_THR14_CTL */
+	{0x02C0, 0x400},	/* DIPCQ_P1A_REG_DIPCQ_CQ_THR14_DESC_SIZE */
+	{0x02C4, 0x11},		/* DIPCQ_P1A_REG_DIPCQ_CQ_THR15_CTL */
+	{0x02CC, 0x400},	/* DIPCQ_P1A_REG_DIPCQ_CQ_THR15_DESC_SIZE */
+	{0x02D0, 0x11},		/* DIPCQ_P1A_REG_DIPCQ_CQ_THR16_CTL */
+	{0x02D8, 0x400},	/* DIPCQ_P1A_REG_DIPCQ_CQ_THR16_DESC_SIZE */
+	{0x02DC, 0x11},		/* DIPCQ_P1A_REG_DIPCQ_CQ_THR17_CTL */
+	{0x02E4, 0x400},	/* DIPCQ_P1A_REG_DIPCQ_CQ_THR17_DESC_SIZE */
+	{0x02E8, 0x11},		/* DIPCQ_P1A_REG_DIPCQ_CQ_THR18_CTL */
+	{0x02F0, 0x400},	/* DIPCQ_P1A_REG_DIPCQ_CQ_THR18_DESC_SIZE */
+	{0x121C, 0x80000100},	/* PIMGI_P1A_REG_ORIRDMA_CON0 */
+	{0x1220, 0x10400040},	/* PIMGI_P1A_REG_ORIRDMA_CON1 */
+	{0x1224, 0x10800080},	/* PIMGI_P1A_REG_ORIRDMA_CON2 */
+	{0x127C, 0x80000080},	/* PIMGBI_P1A_REG_ORIRDMA_CON0 */
+	{0x1280, 0x10400040},	/* PIMGBI_P1A_REG_ORIRDMA_CON1 */
+	{0x1284, 0x10800080},	/* PIMGBI_P1A_REG_ORIRDMA_CON2 */
+	{0x12DC, 0x80000080},	/* PIMGCI_P1A_REG_ORIRDMA_CON0 */
+	{0x12E0, 0x10400040},	/* PIMGCI_P1A_REG_ORIRDMA_CON1 */
+	{0x12E4, 0x10800080}	/* PIMGCI_P1A_REG_ORIRDMA_CON2 */
+};
+
+#define PQDIP_INIT_ARRAY_COUNT	ARRAY_SIZE(mtk_imgsys_pqdip_init_ary)
+
+void __iomem *gpqdipRegBA[PQDIP_HW_SET] = {0L};
+//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+// Public Functions
+//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+void imgsys_pqdip_set_initial_value(struct mtk_imgsys_dev *imgsys_dev)
+{
+	unsigned int hw_idx = 0;
+
+	dev_dbg(imgsys_dev->dev, "%s: +\n", __func__);
+
+	for (hw_idx = 0 ; hw_idx < PQDIP_HW_SET ; hw_idx++) {
+		/* iomap registers */
+		gpqdipRegBA[hw_idx] = of_iomap(imgsys_dev->dev->of_node,
+			REG_MAP_E_PQDIP_A + hw_idx);
+	}
+
+	dev_dbg(imgsys_dev->dev, "%s: -\n", __func__);
+}
+EXPORT_SYMBOL(imgsys_pqdip_set_initial_value);
+
+void imgsys_pqdip_set_hw_initial_value(struct mtk_imgsys_dev *imgsys_dev)
+{
+	void __iomem *ofset = NULL;
+	unsigned int hw_idx = 0;
+	unsigned int i = 0;
+
+	dev_dbg(imgsys_dev->dev, "%s: +\n", __func__);
+
+	for (hw_idx = 0 ; hw_idx < PQDIP_HW_SET ; hw_idx++) {
+		for (i = 0 ; i < PQDIP_INIT_ARRAY_COUNT ; i++) {
+			ofset = gpqdipRegBA[hw_idx]
+				+ mtk_imgsys_pqdip_init_ary[i].ofset;
+			writel(mtk_imgsys_pqdip_init_ary[i].val, ofset);
+		}
+	}
+
+	dev_dbg(imgsys_dev->dev, "%s: -\n", __func__);
+}
+EXPORT_SYMBOL(imgsys_pqdip_set_hw_initial_value);
+
+void imgsys_pqdip_debug_dump(struct mtk_imgsys_dev *imgsys_dev,
+							unsigned int engine)
+{
+	void __iomem *pqdipRegBA = 0L;
+	unsigned int hw_idx = 0;
+	unsigned int i = 0;
+
+	dev_info(imgsys_dev->dev, "%s: +\n", __func__);
+
+	for (hw_idx = 0 ; hw_idx < PQDIP_HW_SET ; hw_idx++) {
+		/* iomap registers */
+		pqdipRegBA = gpqdipRegBA[hw_idx];
+#ifdef DUMP_PQ_ALL
+		for (i = 0x0; i < PQDIP_ALL_REG_CNT; i += 0x10) {
+			dev_info(imgsys_dev->dev, "%s:  [0x%08x] 0x%08x 0x%08x 0x%08x 0x%08x",
+			__func__, (unsigned int)(PQDIP_BASE_ADDR + (PQDIP_OFST * hw_idx) + i),
+			(unsigned int)ioread32((void *)(pqdipRegBA + i + 0x00)),
+			(unsigned int)ioread32((void *)(pqdipRegBA + i + 0x04)),
+			(unsigned int)ioread32((void *)(pqdipRegBA + i + 0x08)),
+			(unsigned int)ioread32((void *)(pqdipRegBA + i + 0x0c)));
+		}
+#else
+		dev_info(imgsys_dev->dev, "%s:  ctl_reg", __func__);
+		for (i = 0x0; i < PQDIP_CTL_REG_CNT; i += 0x10) {
+			dev_info(imgsys_dev->dev, "%s:  [0x%08x] 0x%08x 0x%08x 0x%08x 0x%08x",
+			__func__, (unsigned int)(PQDIP_BASE_ADDR + (PQDIP_OFST * hw_idx)
+				+ PQDIP_CTL_OFST + i),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_CTL_OFST + i + 0x00)),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_CTL_OFST + i + 0x04)),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_CTL_OFST + i + 0x08)),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_CTL_OFST + i + 0x0c)));
+		}
+
+		dev_info(imgsys_dev->dev, "%s:  cq_reg", __func__);
+		for (i = 0; i < PQDIP_CQ_REG_CNT; i += 0x10) {
+			dev_info(imgsys_dev->dev, "%s:  [0x%08x] 0x%08x 0x%08x 0x%08x 0x%08x",
+			__func__, (unsigned int)(PQDIP_BASE_ADDR + (PQDIP_OFST * hw_idx)
+				+ PQDIP_CQ_OFST + i),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_CQ_OFST + i + 0x00)),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_CQ_OFST + i + 0x04)),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_CQ_OFST + i + 0x08)),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_CQ_OFST + i + 0x0c)));
+		}
+
+		dev_info(imgsys_dev->dev, "%s:  dma_reg", __func__);
+		for (i = 0; i < PQDIP_DMA_REG_CNT; i += 0x10) {
+			dev_info(imgsys_dev->dev, "%s:  [0x%08x] 0x%08x 0x%08x 0x%08x 0x%08x",
+			__func__, (unsigned int)(PQDIP_BASE_ADDR + (PQDIP_OFST * hw_idx)
+				+ PQDIP_DMA_OFST + i),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_DMA_OFST + i + 0x00)),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_DMA_OFST + i + 0x04)),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_DMA_OFST + i + 0x08)),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_DMA_OFST + i + 0x0c)));
+		}
+
+		dev_info(imgsys_dev->dev, "%s:  wrot_reg", __func__);
+		for (i = 0; i < PQDIP_WROT1_REG_CNT; i += 0x10) {
+			dev_info(imgsys_dev->dev, "%s:  [0x%08x] 0x%08x 0x%08x 0x%08x 0x%08x",
+			__func__, (unsigned int)(PQDIP_BASE_ADDR + (PQDIP_OFST * hw_idx)
+				+ PQDIP_WROT1_OFST + i),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_WROT1_OFST + i + 0x00)),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_WROT1_OFST + i + 0x04)),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_WROT1_OFST + i + 0x08)),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_WROT1_OFST + i + 0x0c)));
+		}
+		for (i = 0; i < PQDIP_WROT2_REG_CNT; i += 0x10) {
+			dev_info(imgsys_dev->dev, "%s:  [0x%08x] 0x%08x 0x%08x 0x%08x 0x%08x",
+			__func__, (unsigned int)(PQDIP_BASE_ADDR + (PQDIP_OFST * hw_idx)
+				+ PQDIP_WROT2_OFST + i),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_WROT2_OFST + i + 0x00)),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_WROT2_OFST + i + 0x04)),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_WROT2_OFST + i + 0x08)),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_WROT2_OFST + i + 0x0c)));
+		}
+
+		dev_info(imgsys_dev->dev, "%s:  urz6t_reg", __func__);
+		for (i = 0; i < PQDIP_RZH4N6T_REG_CNT; i += 0x10) {
+			dev_info(imgsys_dev->dev, "%s:  [0x%08x] 0x%08x 0x%08x 0x%08x 0x%08x",
+			__func__, (unsigned int)(PQDIP_BASE_ADDR + (PQDIP_OFST * hw_idx)
+				+ PQDIP_RZH4N6T_OFST + i),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_RZH4N6T_OFST + i + 0x0)),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_RZH4N6T_OFST + i + 0x4)),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_RZH4N6T_OFST + i + 0x8)),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_RZH4N6T_OFST + i + 0xc))
+			);
+		}
+
+		dev_info(imgsys_dev->dev, "%s:  tdshp_reg", __func__);
+		for (i = 0; i < PQDIP_TDSHP1REG_CNT; i += 0x10) {
+			dev_info(imgsys_dev->dev, "%s:  [0x%08x] 0x%08x 0x%08x 0x%08x 0x%08x",
+			__func__, (unsigned int)(PQDIP_BASE_ADDR + (PQDIP_OFST * hw_idx)
+				+ PQDIP_TDSHP1OFST + i),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_TDSHP1OFST + i + 0x00)),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_TDSHP1OFST + i + 0x04)),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_TDSHP1OFST + i + 0x08)),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_TDSHP1OFST + i + 0x0c)));
+		}
+		for (i = 0; i < PQDIP_TDSHP2REG_CNT; i += 0x10) {
+			dev_info(imgsys_dev->dev, "%s:  [0x%08x] 0x%08x 0x%08x 0x%08x 0x%08x",
+			__func__, (unsigned int)(PQDIP_BASE_ADDR + (PQDIP_OFST * hw_idx)
+				+ PQDIP_TDSHP2OFST + i),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_TDSHP2OFST + i + 0x00)),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_TDSHP2OFST + i + 0x04)),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_TDSHP2OFST + i + 0x08)),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_TDSHP2OFST + i + 0x0c)));
+		}
+		for (i = 0; i < PQDIP_TDSHP3REG_CNT; i += 0x10) {
+			dev_info(imgsys_dev->dev, "%s:  [0x%08x] 0x%08x 0x%08x 0x%08x 0x%08x",
+			__func__, (unsigned int)(PQDIP_BASE_ADDR + (PQDIP_OFST * hw_idx)
+				+ PQDIP_TDSHP3OFST + i),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_TDSHP3OFST + i + 0x00)),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_TDSHP3OFST + i + 0x04)),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_TDSHP3OFST + i + 0x08)),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_TDSHP3OFST + i + 0x0c)));
+		}
+
+		dev_info(imgsys_dev->dev, "%s:  unp_reg", __func__);
+		for (i = 0; i < PQDIP_UNP_REG_CNT; i += 0x10) {
+			dev_info(imgsys_dev->dev, "%s:  [0x%08x] 0x%08x 0x%08x 0x%08x 0x%08x",
+			__func__, (unsigned int)(PQDIP_BASE_ADDR + (PQDIP_OFST * hw_idx)
+				+ PQDIP_UNP1_OFST + i),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_UNP1_OFST + i + 0x00)),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_UNP1_OFST + i + 0x04)),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_UNP1_OFST + i + 0x08)),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_UNP1_OFST + i + 0x0c)));
+		}
+		for (i = 0; i < PQDIP_UNP_REG_CNT; i += 0x10) {
+			dev_info(imgsys_dev->dev, "%s:  [0x%08x] 0x%08x 0x%08x 0x%08x 0x%08x",
+			__func__, (unsigned int)(PQDIP_BASE_ADDR + (PQDIP_OFST * hw_idx)
+				+ PQDIP_UNP2_OFST + i),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_UNP2_OFST + i + 0x00)),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_UNP2_OFST + i + 0x04)),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_UNP2_OFST + i + 0x08)),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_UNP2_OFST + i + 0x0c)));
+		}
+		for (i = 0; i < PQDIP_UNP_REG_CNT; i += 0x10) {
+			dev_info(imgsys_dev->dev, "%s:  [0x%08x] 0x%08x 0x%08x 0x%08x 0x%08x",
+			__func__, (unsigned int)(PQDIP_BASE_ADDR + (PQDIP_OFST * hw_idx)
+				+ PQDIP_UNP3_OFST + i),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_UNP3_OFST + i + 0x00)),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_UNP3_OFST + i + 0x04)),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_UNP3_OFST + i + 0x08)),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_UNP3_OFST + i + 0x0c)));
+		}
+
+		dev_info(imgsys_dev->dev, "%s:  c02_reg", __func__);
+		for (i = 0; i < PQDIP_C02_REG_CNT; i += 0x10) {
+			dev_info(imgsys_dev->dev, "%s:  [0x%08x] 0x%08x 0x%08x 0x%08x 0x%08x",
+			__func__, (unsigned int)(PQDIP_BASE_ADDR + (PQDIP_OFST * hw_idx)
+				+ PQDIP_C02_OFST + i),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_C02_OFST + i + 0x00)),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_C02_OFST + i + 0x04)),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_C02_OFST + i + 0x08)),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_C02_OFST + i + 0x0c)));
+		}
+
+		dev_info(imgsys_dev->dev, "%s:  c24_reg", __func__);
+		for (i = 0; i < PQDIP_C24_REG_CNT; i += 0x10) {
+			dev_info(imgsys_dev->dev, "%s:  [0x%08x] 0x%08x 0x%08x 0x%08x 0x%08x",
+			__func__, (unsigned int)(PQDIP_BASE_ADDR + (PQDIP_OFST * hw_idx)
+				+ PQDIP_C24_OFST + i),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_C24_OFST + i + 0x00)),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_C24_OFST + i + 0x04)),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_C24_OFST + i + 0x08)),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_C24_OFST + i + 0x0c)));
+		}
+
+		dev_info(imgsys_dev->dev, "%s:  mcrp_reg", __func__);
+		for (i = 0; i < PQDIP_MCRP_REG_CNT; i += 0x10) {
+			dev_info(imgsys_dev->dev, "%s:  [0x%08x] 0x%08x 0x%08x 0x%08x 0x%08x",
+			__func__, (unsigned int)(PQDIP_BASE_ADDR + (PQDIP_OFST * hw_idx)
+				+ PQDIP_MCRP_OFST + i),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_MCRP_OFST + i + 0x00)),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_MCRP_OFST + i + 0x04)),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_MCRP_OFST + i + 0x08)),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_MCRP_OFST + i + 0x0c)));
+		}
+
+		dev_info(imgsys_dev->dev, "%s:  tcc_reg", __func__);
+		for (i = 0; i < PQDIP_TCC_REG_CNT; i += 0x10) {
+			dev_info(imgsys_dev->dev, "%s:  [0x%08x] 0x%08x 0x%08x 0x%08x 0x%08x",
+			__func__, (unsigned int)(PQDIP_BASE_ADDR + (PQDIP_OFST * hw_idx)
+				+ PQDIP_TCC_OFST + i),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_TCC_OFST + i + 0x00)),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_TCC_OFST + i + 0x04)),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_TCC_OFST + i + 0x08)),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_TCC_OFST + i + 0x0c)));
+		}
+#endif
+		//CTL_DBG
+		dev_info(imgsys_dev->dev, "%s: tdr debug\n", __func__);
+		iowrite32(0x80004, (void *)(pqdipRegBA + PQDIPCTL_DBG_SEL_OFST));
+		dev_info(imgsys_dev->dev, "%s: tdr   sel(0x80004): %08X", __func__,
+		(unsigned int)ioread32((void *)(pqdipRegBA + PQDIPCTL_DBG_OUT_OFST)));
+
+		dev_info(imgsys_dev->dev, "%s: module debug\n", __func__);
+		iowrite32(0x00001, (void *)(pqdipRegBA + PQDIPCTL_DBG_SEL_OFST));
+		dev_info(imgsys_dev->dev, "%s: urz6t sel(0x00001): %08X", __func__,
+		(unsigned int)ioread32((void *)(pqdipRegBA + PQDIPCTL_DBG_OUT_OFST)));
+		iowrite32(0x00101, (void *)(pqdipRegBA + PQDIPCTL_DBG_SEL_OFST));
+		dev_info(imgsys_dev->dev, "%s: tdshp sel(0x00101): %08X", __func__,
+		(unsigned int)ioread32((void *)(pqdipRegBA + PQDIPCTL_DBG_OUT_OFST)));
+		iowrite32(0x10201, (void *)(pqdipRegBA + PQDIPCTL_DBG_SEL_OFST));
+		dev_info(imgsys_dev->dev, "%s: tcc   sel(0x10201): %08X", __func__,
+		(unsigned int)ioread32((void *)(pqdipRegBA + PQDIPCTL_DBG_OUT_OFST)));
+		iowrite32(0x20201, (void *)(pqdipRegBA + PQDIPCTL_DBG_SEL_OFST));
+		dev_info(imgsys_dev->dev, "%s: tcc   sel(0x20201): %08X", __func__,
+		(unsigned int)ioread32((void *)(pqdipRegBA + PQDIPCTL_DBG_OUT_OFST)));
+		iowrite32(0x30201, (void *)(pqdipRegBA + PQDIPCTL_DBG_SEL_OFST));
+		dev_info(imgsys_dev->dev, "%s: tcc   sel(0x30201): %08X", __func__,
+		(unsigned int)ioread32((void *)(pqdipRegBA + PQDIPCTL_DBG_OUT_OFST)));
+		iowrite32(0x40201, (void *)(pqdipRegBA + PQDIPCTL_DBG_SEL_OFST));
+		dev_info(imgsys_dev->dev, "%s: tcc   sel(0x40201): %08X", __func__,
+		(unsigned int)ioread32((void *)(pqdipRegBA + PQDIPCTL_DBG_OUT_OFST)));
+		iowrite32(0x00301, (void *)(pqdipRegBA + PQDIPCTL_DBG_SEL_OFST));
+		dev_info(imgsys_dev->dev, "%s: wrot  sel(0x00301): %08X", __func__,
+		(unsigned int)ioread32((void *)(pqdipRegBA + PQDIPCTL_DBG_OUT_OFST)));
+		iowrite32(0x10401, (void *)(pqdipRegBA + PQDIPCTL_DBG_SEL_OFST));
+		dev_info(imgsys_dev->dev, "%s: unp1  sel(0x10401): %08X", __func__,
+		(unsigned int)ioread32((void *)(pqdipRegBA + PQDIPCTL_DBG_OUT_OFST)));
+		iowrite32(0x20401, (void *)(pqdipRegBA + PQDIPCTL_DBG_SEL_OFST));
+		dev_info(imgsys_dev->dev, "%s: unp1  sel(0x20401): %08X", __func__,
+		(unsigned int)ioread32((void *)(pqdipRegBA + PQDIPCTL_DBG_OUT_OFST)));
+		iowrite32(0x30401, (void *)(pqdipRegBA + PQDIPCTL_DBG_SEL_OFST));
+		dev_info(imgsys_dev->dev, "%s: unp1  sel(0x30401): %08X", __func__,
+		(unsigned int)ioread32((void *)(pqdipRegBA + PQDIPCTL_DBG_OUT_OFST)));
+		iowrite32(0x40401, (void *)(pqdipRegBA + PQDIPCTL_DBG_SEL_OFST));
+		dev_info(imgsys_dev->dev, "%s: unp1  sel(0x40401): %08X", __func__,
+		(unsigned int)ioread32((void *)(pqdipRegBA + PQDIPCTL_DBG_OUT_OFST)));
+		iowrite32(0x50401, (void *)(pqdipRegBA + PQDIPCTL_DBG_SEL_OFST));
+		dev_info(imgsys_dev->dev, "%s: unp1  sel(0x50401): %08X", __func__,
+		(unsigned int)ioread32((void *)(pqdipRegBA + PQDIPCTL_DBG_OUT_OFST)));
+		iowrite32(0x60401, (void *)(pqdipRegBA + PQDIPCTL_DBG_SEL_OFST));
+		dev_info(imgsys_dev->dev, "%s: unp1  sel(0x60401): %08X", __func__,
+		(unsigned int)ioread32((void *)(pqdipRegBA + PQDIPCTL_DBG_OUT_OFST)));
+		iowrite32(0x10501, (void *)(pqdipRegBA + PQDIPCTL_DBG_SEL_OFST));
+		dev_info(imgsys_dev->dev, "%s: unp2  sel(0x10501): %08X", __func__,
+		(unsigned int)ioread32((void *)(pqdipRegBA + PQDIPCTL_DBG_OUT_OFST)));
+		iowrite32(0x20501, (void *)(pqdipRegBA + PQDIPCTL_DBG_SEL_OFST));
+		dev_info(imgsys_dev->dev, "%s: unp2  sel(0x20501): %08X", __func__,
+		(unsigned int)ioread32((void *)(pqdipRegBA + PQDIPCTL_DBG_OUT_OFST)));
+		iowrite32(0x30501, (void *)(pqdipRegBA + PQDIPCTL_DBG_SEL_OFST));
+		dev_info(imgsys_dev->dev, "%s: unp2  sel(0x30501): %08X", __func__,
+		(unsigned int)ioread32((void *)(pqdipRegBA + PQDIPCTL_DBG_OUT_OFST)));
+		iowrite32(0x40501, (void *)(pqdipRegBA + PQDIPCTL_DBG_SEL_OFST));
+		dev_info(imgsys_dev->dev, "%s: unp2  sel(0x40501): %08X", __func__,
+		(unsigned int)ioread32((void *)(pqdipRegBA + PQDIPCTL_DBG_OUT_OFST)));
+		iowrite32(0x50501, (void *)(pqdipRegBA + PQDIPCTL_DBG_SEL_OFST));
+		dev_info(imgsys_dev->dev, "%s: unp2  sel(0x50501): %08X", __func__,
+		(unsigned int)ioread32((void *)(pqdipRegBA + PQDIPCTL_DBG_OUT_OFST)));
+		iowrite32(0x60501, (void *)(pqdipRegBA + PQDIPCTL_DBG_SEL_OFST));
+		dev_info(imgsys_dev->dev, "%s: unp2  sel(0x60501): %08X", __func__,
+		(unsigned int)ioread32((void *)(pqdipRegBA + PQDIPCTL_DBG_OUT_OFST)));
+		iowrite32(0x10601, (void *)(pqdipRegBA + PQDIPCTL_DBG_SEL_OFST));
+		dev_info(imgsys_dev->dev, "%s: unp3  sel(0x10601): %08X", __func__,
+		(unsigned int)ioread32((void *)(pqdipRegBA + PQDIPCTL_DBG_OUT_OFST)));
+		iowrite32(0x20601, (void *)(pqdipRegBA + PQDIPCTL_DBG_SEL_OFST));
+		dev_info(imgsys_dev->dev, "%s: unp3  sel(0x20601): %08X", __func__,
+		(unsigned int)ioread32((void *)(pqdipRegBA + PQDIPCTL_DBG_OUT_OFST)));
+		iowrite32(0x30601, (void *)(pqdipRegBA + PQDIPCTL_DBG_SEL_OFST));
+		dev_info(imgsys_dev->dev, "%s: unp3  sel(0x30601): %08X", __func__,
+		(unsigned int)ioread32((void *)(pqdipRegBA + PQDIPCTL_DBG_OUT_OFST)));
+		iowrite32(0x40601, (void *)(pqdipRegBA + PQDIPCTL_DBG_SEL_OFST));
+		dev_info(imgsys_dev->dev, "%s: unp3  sel(0x40601): %08X", __func__,
+		(unsigned int)ioread32((void *)(pqdipRegBA + PQDIPCTL_DBG_OUT_OFST)));
+		iowrite32(0x50601, (void *)(pqdipRegBA + PQDIPCTL_DBG_SEL_OFST));
+		dev_info(imgsys_dev->dev, "%s: unp3  sel(0x50601): %08X", __func__,
+		(unsigned int)ioread32((void *)(pqdipRegBA + PQDIPCTL_DBG_OUT_OFST)));
+		iowrite32(0x60601, (void *)(pqdipRegBA + PQDIPCTL_DBG_SEL_OFST));
+		dev_info(imgsys_dev->dev, "%s: unp3  sel(0x60601): %08X", __func__,
+		(unsigned int)ioread32((void *)(pqdipRegBA + PQDIPCTL_DBG_OUT_OFST)));
+		iowrite32(0x00701, (void *)(pqdipRegBA + PQDIPCTL_DBG_SEL_OFST));
+		dev_info(imgsys_dev->dev, "%s: plnr  sel(0x00701): %08X", __func__,
+		(unsigned int)ioread32((void *)(pqdipRegBA + PQDIPCTL_DBG_OUT_OFST)));
+		iowrite32(0x00801, (void *)(pqdipRegBA + PQDIPCTL_DBG_SEL_OFST));
+		dev_info(imgsys_dev->dev, "%s: c02   sel(0x00801): %08X", __func__,
+		(unsigned int)ioread32((void *)(pqdipRegBA + PQDIPCTL_DBG_OUT_OFST)));
+		iowrite32(0x10801, (void *)(pqdipRegBA + PQDIPCTL_DBG_SEL_OFST));
+		dev_info(imgsys_dev->dev, "%s: c02   sel(0x10801): %08X", __func__,
+		(unsigned int)ioread32((void *)(pqdipRegBA + PQDIPCTL_DBG_OUT_OFST)));
+		iowrite32(0x20801, (void *)(pqdipRegBA + PQDIPCTL_DBG_SEL_OFST));
+		dev_info(imgsys_dev->dev, "%s: c02   sel(0x20801): %08X", __func__,
+		(unsigned int)ioread32((void *)(pqdipRegBA + PQDIPCTL_DBG_OUT_OFST)));
+		iowrite32(0x30801, (void *)(pqdipRegBA + PQDIPCTL_DBG_SEL_OFST));
+		dev_info(imgsys_dev->dev, "%s: c02   sel(0x30801): %08X", __func__,
+		(unsigned int)ioread32((void *)(pqdipRegBA + PQDIPCTL_DBG_OUT_OFST)));
+		iowrite32(0x10901, (void *)(pqdipRegBA + PQDIPCTL_DBG_SEL_OFST));
+		dev_info(imgsys_dev->dev, "%s: c24   sel(0x10901): %08X", __func__,
+		(unsigned int)ioread32((void *)(pqdipRegBA + PQDIPCTL_DBG_OUT_OFST)));
+		iowrite32(0x10a01, (void *)(pqdipRegBA + PQDIPCTL_DBG_SEL_OFST));
+		dev_info(imgsys_dev->dev, "%s: mcrp  sel(0x10a01): %08X", __func__,
+		(unsigned int)ioread32((void *)(pqdipRegBA + PQDIPCTL_DBG_OUT_OFST)));
+		iowrite32(0x20a01, (void *)(pqdipRegBA + PQDIPCTL_DBG_SEL_OFST));
+		dev_info(imgsys_dev->dev, "%s: mcrp  sel(0x20a01): %08X", __func__,
+		(unsigned int)ioread32((void *)(pqdipRegBA + PQDIPCTL_DBG_OUT_OFST)));
+		iowrite32(0x30a01, (void *)(pqdipRegBA + PQDIPCTL_DBG_SEL_OFST));
+		dev_info(imgsys_dev->dev, "%s: mcrp  sel(0x30a01): %08X", __func__,
+		(unsigned int)ioread32((void *)(pqdipRegBA + PQDIPCTL_DBG_OUT_OFST)));
+		iowrite32(0x40a01, (void *)(pqdipRegBA + PQDIPCTL_DBG_SEL_OFST));
+		dev_info(imgsys_dev->dev, "%s: mcrp  sel(0x40a01): %08X", __func__,
+		(unsigned int)ioread32((void *)(pqdipRegBA + PQDIPCTL_DBG_OUT_OFST)));
+		iowrite32(0x50a01, (void *)(pqdipRegBA + PQDIPCTL_DBG_SEL_OFST));
+		dev_info(imgsys_dev->dev, "%s: mcrp  sel(0x50a01): %08X", __func__,
+		(unsigned int)ioread32((void *)(pqdipRegBA + PQDIPCTL_DBG_OUT_OFST)));
+		iowrite32(0x00b01, (void *)(pqdipRegBA + PQDIPCTL_DBG_SEL_OFST));
+		dev_info(imgsys_dev->dev, "%s: r2b   sel(0x00b01): %08X", __func__,
+		(unsigned int)ioread32((void *)(pqdipRegBA + PQDIPCTL_DBG_OUT_OFST)));
+		iowrite32(0x10b01, (void *)(pqdipRegBA + PQDIPCTL_DBG_SEL_OFST));
+		dev_info(imgsys_dev->dev, "%s: r2b   sel(0x10b01): %08X", __func__,
+		(unsigned int)ioread32((void *)(pqdipRegBA + PQDIPCTL_DBG_OUT_OFST)));
+		iowrite32(0x20b01, (void *)(pqdipRegBA + PQDIPCTL_DBG_SEL_OFST));
+		dev_info(imgsys_dev->dev, "%s: r2b   sel(0x20b01): %08X", __func__,
+		(unsigned int)ioread32((void *)(pqdipRegBA + PQDIPCTL_DBG_OUT_OFST)));
+		iowrite32(0x30b01, (void *)(pqdipRegBA + PQDIPCTL_DBG_SEL_OFST));
+		dev_info(imgsys_dev->dev, "%s: r2b   sel(0x30b01): %08X", __func__,
+		(unsigned int)ioread32((void *)(pqdipRegBA + PQDIPCTL_DBG_OUT_OFST)));
+		iowrite32(0x40b01, (void *)(pqdipRegBA + PQDIPCTL_DBG_SEL_OFST));
+		dev_info(imgsys_dev->dev, "%s: r2b   sel(0x40b01): %08X", __func__,
+		(unsigned int)ioread32((void *)(pqdipRegBA + PQDIPCTL_DBG_OUT_OFST)));
+		iowrite32(0x50b01, (void *)(pqdipRegBA + PQDIPCTL_DBG_SEL_OFST));
+		dev_info(imgsys_dev->dev, "%s: r2b   sel(0x50b01): %08X", __func__,
+		(unsigned int)ioread32((void *)(pqdipRegBA + PQDIPCTL_DBG_OUT_OFST)));
+		iowrite32(0x60b01, (void *)(pqdipRegBA + PQDIPCTL_DBG_SEL_OFST));
+		dev_info(imgsys_dev->dev, "%s: r2b   sel(0x60b01): %08X", __func__,
+		(unsigned int)ioread32((void *)(pqdipRegBA + PQDIPCTL_DBG_OUT_OFST)));
+		iowrite32(0x70b01, (void *)(pqdipRegBA + PQDIPCTL_DBG_SEL_OFST));
+		dev_info(imgsys_dev->dev, "%s: r2b   sel(0x70b01): %08X", __func__,
+		(unsigned int)ioread32((void *)(pqdipRegBA + PQDIPCTL_DBG_OUT_OFST)));
+		iowrite32(0x80b01, (void *)(pqdipRegBA + PQDIPCTL_DBG_SEL_OFST));
+		dev_info(imgsys_dev->dev, "%s: r2b   sel(0x80b01): %08X", __func__,
+		(unsigned int)ioread32((void *)(pqdipRegBA + PQDIPCTL_DBG_OUT_OFST)));
+		iowrite32(0x90b01, (void *)(pqdipRegBA + PQDIPCTL_DBG_SEL_OFST));
+		dev_info(imgsys_dev->dev, "%s: r2b   sel(0x90b01): %08X", __func__,
+		(unsigned int)ioread32((void *)(pqdipRegBA + PQDIPCTL_DBG_OUT_OFST)));
+		iowrite32(0xa0b01, (void *)(pqdipRegBA + PQDIPCTL_DBG_SEL_OFST));
+		dev_info(imgsys_dev->dev, "%s: r2b   sel(0xa0b01): %08X", __func__,
+		(unsigned int)ioread32((void *)(pqdipRegBA + PQDIPCTL_DBG_OUT_OFST)));
+		iowrite32(0xb0b01, (void *)(pqdipRegBA + PQDIPCTL_DBG_SEL_OFST));
+		dev_info(imgsys_dev->dev, "%s: r2b   sel(0xb0b01): %08X", __func__,
+		(unsigned int)ioread32((void *)(pqdipRegBA + PQDIPCTL_DBG_OUT_OFST)));
+		iowrite32(0x00106, (void *)(pqdipRegBA + PQDIPCTL_DBG_SEL_OFST));
+		dev_info(imgsys_dev->dev, "%s: wif   sel(0x00106): %08X", __func__,
+		(unsigned int)ioread32((void *)(pqdipRegBA + PQDIPCTL_DBG_OUT_OFST)));
+		iowrite32(0x00107, (void *)(pqdipRegBA + PQDIPCTL_DBG_SEL_OFST));
+		dev_info(imgsys_dev->dev, "%s: wif   sel(0x00107): %08X", __func__,
+		(unsigned int)ioread32((void *)(pqdipRegBA + PQDIPCTL_DBG_OUT_OFST)));
+		iowrite32(0x00108, (void *)(pqdipRegBA + PQDIPCTL_DBG_SEL_OFST));
+		dev_info(imgsys_dev->dev, "%s: wif   sel(0x00108): %08X", __func__,
+		(unsigned int)ioread32((void *)(pqdipRegBA + PQDIPCTL_DBG_OUT_OFST)));
+
+		//WROT_DBG
+		dev_info(imgsys_dev->dev, "%s: wrot debug\n", __func__);
+		for (i = 1; i <= 32; i += 1) {
+			iowrite32(i << 8, (void *)(pqdipRegBA + PQ_WROT_DBG_SEL_OFST));
+			dev_info(imgsys_dev->dev, "%s: sel(0x%04x): %08X", __func__, i << 8,
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQ_WROT_DBG_OUT_OFST)));
+		}
+
+		//URZ6T_DBG
+		dev_info(imgsys_dev->dev, "%s: urz6t debug\n", __func__);
+		for (i = 0; i < 16; i += 1) {
+			iowrite32(i, (void *)(pqdipRegBA + PQ_RZH4N6T_DBG_SEL_OFST));
+			dev_info(imgsys_dev->dev, "%s: sel(0x%02x): %08X", __func__, i,
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQ_RZH4N6T_DBG_OUT_OFST)));
+		}
+	}
+	dev_info(imgsys_dev->dev, "%s: -\n", __func__);
+}
+EXPORT_SYMBOL(imgsys_pqdip_debug_dump);
+
+void imgsys_pqdip_uninit(struct mtk_imgsys_dev *imgsys_dev)
+{
+	unsigned int i;
+
+	pr_debug("%s: +\n", __func__);
+	for (i = 0; i < PQDIP_HW_SET; i++) {
+		iounmap(gpqdipRegBA[i]);
+		gpqdipRegBA[i] = 0L;
+	}
+	pr_debug("%s: -\n", __func__);
+}
+EXPORT_SYMBOL(imgsys_pqdip_uninit);
+
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_70/modules/mtk_imgsys-pqdip.h b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_70/modules/mtk_imgsys-pqdip.h
new file mode 100644
index 0000000000000000000000000000000000000000..49371ae40d01ae4ad9b6d4642e7f289d01202176
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_70/modules/mtk_imgsys-pqdip.h
@@ -0,0 +1,46 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2021 MediaTek Inc.
+ *
+ * Author: Daniel Huang <daniel.huang@mediatek.com>
+ *
+ */
+
+#ifndef _MTK_IMGSYS_PQDIP_H_
+#define _MTK_IMGSYS_PQDIP_H_
+
+// Standard C header file
+
+// kernel header file
+
+// mtk imgsys local header file
+#include <mtk_imgsys-dev.h>
+#include <mtk_imgsys-cmdq.h>
+
+// Local header file
+#include "mtk_imgsys-engine.h"
+
+/********************************************************************
+ * Global Define
+ ********************************************************************/
+
+/********************************************************************
+ * Enum Define
+ ********************************************************************/
+
+
+/********************************************************************
+ * Structure Define
+ ********************************************************************/
+
+//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+// Public Functions
+//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+void imgsys_pqdip_set_initial_value(struct mtk_imgsys_dev *imgsys_dev);
+void imgsys_pqdip_set_hw_initial_value(struct mtk_imgsys_dev *imgsys_dev);
+void imgsys_pqdip_debug_dump(struct mtk_imgsys_dev *imgsys_dev,
+							unsigned int engine);
+void imgsys_pqdip_uninit(struct mtk_imgsys_dev *imgsys_dev);
+
+
+#endif /* _MTK_IMGSYS_PQDIP_H_ */
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_70/modules/mtk_imgsys-traw.c b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_70/modules/mtk_imgsys-traw.c
new file mode 100644
index 0000000000000000000000000000000000000000..ba5cfc79d379d67cb6c12670e5a1f55b7b70d754
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_70/modules/mtk_imgsys-traw.c
@@ -0,0 +1,763 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2021 MediaTek Inc.
+ *
+ * Author: Shih-Fang Chuang <shih-fang.chuang@mediatek.com>
+ *
+ */
+
+ // Standard C header file
+
+// kernel header file
+#include <linux/device.h>
+#include <linux/of_address.h>
+#include <dma-iommu.h>
+#include <linux/pm_runtime.h>
+#include <linux/remoteproc.h>
+#include <dt-bindings/memory/mtk-memory-port.h>
+
+// drivers/misc/mediatek/iommu/
+//#include "iommu_debug.h"
+
+
+// mtk imgsys local header file
+
+// Local header file
+#include "mtk_imgsys-traw.h"
+
+/********************************************************************
+ * Global Define
+ ********************************************************************/
+#define TRAW_INIT_ARRAY_COUNT	10
+
+#define TRAW_CTL_ADDR_OFST		0x300
+#define TRAW_DMA_ADDR_OFST		0x1000
+#define TRAW_DMA_ADDR_END		0x1ED0
+#define TRAW_DATA_ADDR_OFST		0x8000
+#define TRAW_MAX_ADDR_OFST		0xB630
+
+
+#define TRAW_HW_SET		2
+
+#define TRAW_L9_PORT_CNT	20
+
+#define TRAW_M4U   0
+
+/********************************************************************
+ * Global Variable
+ ********************************************************************/
+const struct mtk_imgsys_init_array
+			mtk_imgsys_traw_init_ary[TRAW_INIT_ARRAY_COUNT] = {
+	{0x00A0, 0x80000000}, /* TRAWCTL_INT1_EN */
+	{0x121C, 0x80000100}, /* IMGI_T1A_REG_ORIRDMA_CON0 */
+	{0x1220, 0x11000100}, /* IMGI_T1A_REG_ORIRDMA_CON1 */
+	{0x1224, 0x11000100}, /* IMGI_T1A_REG_ORIRDMA_CON2 */
+	{0x12DC, 0x80000080}, /* IMGBI_T1A_REG_ORIRDMA_CON0 */
+	{0x12E0, 0x10800080}, /* IMGBI_T1A_REG_ORIRDMA_CON1 */
+	{0x12E4, 0x10800080}, /* IMGBI_T1A_REG_ORIRDMA_CON2 */
+	{0x133C, 0x80000080}, /* IMGCI_T1A_REG_ORIRDMA_CON0 */
+	{0x1340, 0x10800080}, /* IMGCI_T1A_REG_ORIRDMA_CON1 */
+	{0x1344, 0x10800080}, /* IMGCI_T1A_REG_ORIRDMA_CON2 */
+};
+
+static struct TRAWDmaDebugInfo g_DMADbgIfo[] = {
+	{"IMGI", TRAW_ORI_RDMA_DEBUG},
+	{"IMGI_UFD", TRAW_ORI_RDMA_UFD_DEBUG},
+	{"UFDI", TRAW_ORI_RDMA_DEBUG},
+	{"IMGBI", TRAW_ORI_RDMA_DEBUG},
+	{"IMGBI_UFD", TRAW_ORI_RDMA_UFD_DEBUG},
+	{"IMGCI", TRAW_ORI_RDMA_DEBUG},
+	{"IMGCI_UFD", TRAW_ORI_RDMA_UFD_DEBUG},
+	{"SMTI_T1", TRAW_ULC_RDMA_DEBUG},
+	{"SMTI_T2", TRAW_ULC_RDMA_DEBUG},
+	{"SMTI_T3", TRAW_ULC_RDMA_DEBUG},
+	{"SMTI_T4", TRAW_ULC_RDMA_DEBUG},
+	{"SMTI_T5", TRAW_ULC_RDMA_DEBUG},
+	{"CACI", TRAW_ULC_RDMA_DEBUG},
+	{"TNCSTI_T1", TRAW_ULC_RDMA_DEBUG},
+	{"TNCSTI_T2", TRAW_ULC_RDMA_DEBUG},
+	{"TNCSTI_T3", TRAW_ULC_RDMA_DEBUG},
+	{"TNCSTI_T4", TRAW_ULC_RDMA_DEBUG},
+	{"TNCSTI_T5", TRAW_ULC_RDMA_DEBUG},
+	{"YUVO_T1", TRAW_ORI_WDMA_DEBUG},
+	{"YUVBO_T1", TRAW_ORI_WDMA_DEBUG},
+	{"TIMGO", TRAW_ORI_WDMA_DEBUG},
+	{"YUVCO", TRAW_ORI_WDMA_DEBUG},
+	{"YUVDO", TRAW_ORI_WDMA_DEBUG},
+	{"YUVO_T2", TRAW_ULC_WDMA_DEBUG},
+	{"YUVBO_T2", TRAW_ULC_WDMA_DEBUG},
+	{"YUVO_T3", TRAW_ULC_WDMA_DEBUG},
+	{"YUVBO_T3", TRAW_ULC_WDMA_DEBUG},
+	{"YUVO_T4", TRAW_ULC_WDMA_DEBUG},
+	{"YUVBO_T4", TRAW_ULC_WDMA_DEBUG},
+	{"YUVO_T5", TRAW_ORI_WDMA_DEBUG},
+	{"TNCSO", TRAW_ULC_WDMA_DEBUG},
+	{"TNCSBO", TRAW_ULC_WDMA_DEBUG},
+	{"TNCSHO", TRAW_ULC_WDMA_DEBUG},
+	{"TNCSYO", TRAW_ULC_WDMA_DEBUG},
+	{"SMTO_T1", TRAW_ULC_WDMA_DEBUG},
+	{"SMTO_T2", TRAW_ULC_WDMA_DEBUG},
+	{"SMTO_T3", TRAW_ULC_WDMA_DEBUG},
+	{"SMTO_T4", TRAW_ULC_WDMA_DEBUG},
+	{"SMTO_T5", TRAW_ULC_WDMA_DEBUG},
+	{"TNCSTO_T1", TRAW_ULC_WDMA_DEBUG},
+	{"TNCSTO_T2", TRAW_ULC_WDMA_DEBUG},
+	{"TNCSTO_T3", TRAW_ULC_WDMA_DEBUG}
+};
+
+static unsigned int g_RegBaseAddr = TRAW_A_BASE_ADDR;
+
+static void __iomem *g_trawRegBA, *g_ltrawRegBA;
+
+#if TRAW_M4U
+static unsigned int g_IOMMUDumpPort;
+
+static unsigned int g_IOMMUL9Def[TRAW_L9_PORT_CNT] = {
+	MTK_M4U_PORT_ID(0, 0, 9, 0),	/* IMGI_T1_A */
+	MTK_M4U_PORT_ID(0, 0, 9, 1),	/* IMGBI_T1_A */
+	MTK_M4U_PORT_ID(0, 0, 9, 2),	/* IMGCI_T1_A */
+	MTK_M4U_PORT_ID(0, 0, 9, 3),	/* SMTI_T1_A */
+	MTK_M4U_PORT_ID(0, 0, 9, 4),	/* TNCSTI_T1_A */
+	MTK_M4U_PORT_ID(0, 0, 9, 5),	/* TNCSTI_T4_A */
+	MTK_M4U_PORT_ID(0, 0, 9, 6),	/* YUVO_T1_A */
+	MTK_M4U_PORT_ID(0, 0, 9, 7),	/* TIMGO_T1_A */
+	MTK_M4U_PORT_ID(0, 0, 9, 8),	/* YUVO_T2_A */
+	MTK_M4U_PORT_ID(0, 0, 9, 9),	/* IMGI_T1_B */
+	MTK_M4U_PORT_ID(0, 0, 9, 10),	/* IMGBI_T1_B */
+	MTK_M4U_PORT_ID(0, 0, 9, 11),	/* IMGCI_T1_B */
+	MTK_M4U_PORT_ID(0, 0, 9, 12),	/* YUVO_T5_A */
+	MTK_M4U_PORT_ID(0, 0, 9, 13),	/* SMTI_T1_B */
+	MTK_M4U_PORT_ID(0, 0, 9, 14),	/* TNCSO_T1_A */
+	MTK_M4U_PORT_ID(0, 0, 9, 15),	/* SMTO_T1_A */
+	MTK_M4U_PORT_ID(0, 0, 9, 16),	/* TNCSTO_T1_A */
+	MTK_M4U_PORT_ID(0, 0, 9, 17),	/* YUVO_T2_B */
+	MTK_M4U_PORT_ID(0, 0, 9, 18),	/* YUVO_T5_B */
+	MTK_M4U_PORT_ID(0, 0, 9, 19)	/* SMTO_T1_B */
+};
+
+#endif
+
+static unsigned int ExeDbgCmd(struct mtk_imgsys_dev *a_pDev,
+			void __iomem *a_pRegBA,
+			unsigned int a_DdbSel,
+			unsigned int a_DbgOut,
+			unsigned int a_DbgCmd)
+{
+	unsigned int DbgData = 0;
+	unsigned int DbgOutReg = g_RegBaseAddr + a_DbgOut;
+	void __iomem *pDbgSel = (void *)(a_pRegBA + a_DdbSel);
+	void __iomem *pDbgPort = (void *)(a_pRegBA + a_DbgOut);
+
+	iowrite32(a_DbgCmd, pDbgSel);
+	DbgData = (unsigned int)ioread32(pDbgPort);
+	pr_info("[0x%08X](0x%08X,0x%08X)\n",
+		a_DbgCmd, DbgOutReg, DbgData);
+
+	return DbgData;
+}
+
+static void imgsys_traw_dump_dma(struct mtk_imgsys_dev *a_pDev,
+				void __iomem *a_pRegBA,
+				unsigned int a_DdbSel,
+				unsigned int a_DbgOut)
+{
+	unsigned int Idx = 0;
+	unsigned int DbgCmd = 0;
+	unsigned int DmaDegInfoSize = sizeof(struct TRAWDmaDebugInfo);
+	unsigned int DebugCnt = sizeof(g_DMADbgIfo)/DmaDegInfoSize;
+	enum TRAWDmaDebugType DbgTy = TRAW_ORI_RDMA_DEBUG;
+
+	/* Dump DMA Debug Info */
+	for (Idx = 0; Idx < DebugCnt; Idx++) {
+		/* state_checksum */
+		DbgCmd = TRAW_IMGI_STATE_CHECKSUM + Idx;
+		ExeDbgCmd(a_pDev, a_pRegBA, a_DdbSel, a_DbgOut, DbgCmd);
+		/* line_pix_cnt_tmp */
+		DbgCmd = TRAW_IMGI_LINE_PIX_CNT_TMP + Idx;
+		ExeDbgCmd(a_pDev, a_pRegBA, a_DdbSel, a_DbgOut, DbgCmd);
+		/* line_pix_cnt */
+		DbgCmd = TRAW_IMGI_LINE_PIX_CNT + Idx;
+		ExeDbgCmd(a_pDev, a_pRegBA, a_DdbSel, a_DbgOut, DbgCmd);
+
+		DbgTy = g_DMADbgIfo[Idx].DMADebugType;
+
+		/* important_status */
+		if (DbgTy == TRAW_ULC_RDMA_DEBUG ||
+			DbgTy == TRAW_ULC_WDMA_DEBUG) {
+			DbgCmd = TRAW_IMGI_IMPORTANT_STATUS + Idx;
+			ExeDbgCmd(a_pDev, a_pRegBA, a_DdbSel, a_DbgOut,
+			DbgCmd);
+		}
+
+		/* smi_debug_data (case 0) or cmd_data_cnt */
+		if (DbgTy == TRAW_ORI_RDMA_DEBUG ||
+			DbgTy == TRAW_ULC_RDMA_DEBUG ||
+			DbgTy == TRAW_ULC_WDMA_DEBUG) {
+			DbgCmd = TRAW_IMGI_SMI_DEBUG_DATA_CASE0 + Idx;
+			ExeDbgCmd(a_pDev, a_pRegBA, a_DdbSel, a_DbgOut,
+			DbgCmd);
+		}
+
+		/* ULC_RDMA or ULC_WDMA */
+		if (DbgTy == TRAW_ULC_RDMA_DEBUG ||
+			DbgTy == TRAW_ULC_WDMA_DEBUG) {
+			DbgCmd = TRAW_IMGI_TILEX_BYTE_CNT + Idx;
+			ExeDbgCmd(a_pDev, a_pRegBA, a_DdbSel, a_DbgOut,
+				DbgCmd);
+			DbgCmd = TRAW_IMGI_TILEY_CNT + Idx;
+			ExeDbgCmd(a_pDev, a_pRegBA, a_DdbSel, a_DbgOut,
+				DbgCmd);
+		}
+
+		/* smi_dbg_data(case 0) or burst_line_cnt or input_v_cnt */
+		if (DbgTy == TRAW_ORI_WDMA_DEBUG ||
+			DbgTy == TRAW_ULC_RDMA_DEBUG ||
+			DbgTy == TRAW_ULC_WDMA_DEBUG) {
+			DbgCmd = TRAW_IMGI_BURST_LINE_CNT + Idx;
+			ExeDbgCmd(a_pDev, a_pRegBA, a_DdbSel, a_DbgOut,
+				DbgCmd);
+		}
+
+		/* ORI_RDMA */
+		if (DbgTy == TRAW_ORI_RDMA_DEBUG) {
+			DbgCmd = TRAW_IMGI_FIFO_DEBUG_DATA_CASE1 + Idx;
+			ExeDbgCmd(a_pDev, a_pRegBA, a_DdbSel, a_DbgOut,
+				DbgCmd);
+			DbgCmd = TRAW_IMGI_FIFO_DEBUG_DATA_CASE3 + Idx;
+			ExeDbgCmd(a_pDev, a_pRegBA, a_DdbSel, a_DbgOut,
+				DbgCmd);
+		}
+
+		/* ORI_WDMA */
+		if (DbgTy == TRAW_ORI_WDMA_DEBUG) {
+			DbgCmd = TRAW_YUVO_T1_FIFO_DEBUG_DATA_CASE1 + Idx;
+			ExeDbgCmd(a_pDev, a_pRegBA, a_DdbSel, a_DbgOut,
+				DbgCmd);
+			DbgCmd = TRAW_YUVO_T1_FIFO_DEBUG_DATA_CASE3 + Idx;
+			ExeDbgCmd(a_pDev, a_pRegBA, a_DdbSel, a_DbgOut,
+				DbgCmd);
+		}
+
+		/* xfer_y_cnt */
+		if (DbgTy == TRAW_ULC_WDMA_DEBUG) {
+			DbgCmd = TRAW_IMGI_XFER_Y_CNT + Idx;
+			ExeDbgCmd(a_pDev, a_pRegBA, a_DdbSel, a_DbgOut,
+				DbgCmd);
+		}
+
+	}
+
+}
+
+static void imgsys_traw_dump_cq(struct mtk_imgsys_dev *a_pDev,
+				void __iomem *a_pRegBA,
+				unsigned int a_DdbSel,
+				unsigned int a_DbgOut)
+{
+	unsigned int DbgCmd = 0;
+	void __iomem *pCQEn = (void *)(a_pRegBA + TRAW_DIPCQ_CQ_EN);
+
+
+	/* arx/atx/drx/dtx_state */
+	DbgCmd = 0x00000005;
+	ExeDbgCmd(a_pDev, a_pRegBA, a_DdbSel, a_DbgOut, DbgCmd);
+	/* Thr(0~3)_state */
+	DbgCmd = 0x00010005;
+	ExeDbgCmd(a_pDev, a_pRegBA, a_DdbSel, a_DbgOut, DbgCmd);
+
+	/* Set DIPCQ_CQ_EN[28] to 1 */
+	iowrite32(0x10000000, pCQEn);
+	/* cqd0_checksum0 */
+	DbgCmd = 0x00000005;
+	ExeDbgCmd(a_pDev, a_pRegBA, a_DdbSel, a_DbgOut, DbgCmd);
+	/* cqd0_checksum1 */
+	DbgCmd = 0x00010005;
+	ExeDbgCmd(a_pDev, a_pRegBA, a_DdbSel, a_DbgOut, DbgCmd);
+	/* cqd0_checksum2 */
+	DbgCmd = 0x00020005;
+	ExeDbgCmd(a_pDev, a_pRegBA, a_DdbSel, a_DbgOut, DbgCmd);
+	/* cqd1_checksum0 */
+	DbgCmd = 0x00040005;
+	ExeDbgCmd(a_pDev, a_pRegBA, a_DdbSel, a_DbgOut, DbgCmd);
+	/* cqd1_checksum1 */
+	DbgCmd = 0x00050005;
+	ExeDbgCmd(a_pDev, a_pRegBA, a_DdbSel, a_DbgOut, DbgCmd);
+	/* cqd1_checksum2 */
+	DbgCmd = 0x00060005;
+	ExeDbgCmd(a_pDev, a_pRegBA, a_DdbSel, a_DbgOut, DbgCmd);
+	/* cqa0_checksum0 */
+	DbgCmd = 0x00080005;
+	ExeDbgCmd(a_pDev, a_pRegBA, a_DdbSel, a_DbgOut, DbgCmd);
+	/* cqa0_checksum1 */
+	DbgCmd = 0x00090005;
+	ExeDbgCmd(a_pDev, a_pRegBA, a_DdbSel, a_DbgOut, DbgCmd);
+	/* cqa0_checksum2 */
+	DbgCmd = 0x000A0005;
+	ExeDbgCmd(a_pDev, a_pRegBA, a_DdbSel, a_DbgOut, DbgCmd);
+	/* cqa1_checksum0 */
+	DbgCmd = 0x000C0005;
+	ExeDbgCmd(a_pDev, a_pRegBA, a_DdbSel, a_DbgOut, DbgCmd);
+	/* cqa1_checksum1 */
+	DbgCmd = 0x000D0005;
+	ExeDbgCmd(a_pDev, a_pRegBA, a_DdbSel, a_DbgOut, DbgCmd);
+	/* cqa1_checksum2 */
+	DbgCmd = 0x000E0005;
+	ExeDbgCmd(a_pDev, a_pRegBA, a_DdbSel, a_DbgOut, DbgCmd);
+
+}
+
+static void imgsys_traw_dump_drzh2n(struct mtk_imgsys_dev *a_pDev,
+				void __iomem *a_pRegBA,
+				unsigned int a_DdbSel,
+				unsigned int a_DbgOut)
+{
+	unsigned int DbgCmd = 0;
+
+
+	/* drzh2n_t1 line_pix_cnt_tmp */
+	DbgCmd = 0x0002C001;
+	ExeDbgCmd(a_pDev, a_pRegBA, a_DdbSel, a_DbgOut, DbgCmd);
+	/* drzh2n_t1 line_pix_cnt */
+	DbgCmd = 0x0003C001;
+	ExeDbgCmd(a_pDev, a_pRegBA, a_DdbSel, a_DbgOut, DbgCmd);
+	/* drzh2n_t1 handshake signal */
+	DbgCmd = 0x0004C001;
+	ExeDbgCmd(a_pDev, a_pRegBA, a_DdbSel, a_DbgOut, DbgCmd);
+	/* drzh2n_t2 line_pix_cnt_tmp */
+	DbgCmd = 0x0002C101;
+	ExeDbgCmd(a_pDev, a_pRegBA, a_DdbSel, a_DbgOut, DbgCmd);
+	/* drzh2n_t2 line_pix_cnt */
+	DbgCmd = 0x0003C101;
+	ExeDbgCmd(a_pDev, a_pRegBA, a_DdbSel, a_DbgOut, DbgCmd);
+	/* drzh2n_t2 handshake signal */
+	DbgCmd = 0x0004C101;
+	ExeDbgCmd(a_pDev, a_pRegBA, a_DdbSel, a_DbgOut, DbgCmd);
+	/* drzh2n_t3 line_pix_cnt_tmp */
+	DbgCmd = 0x0002C501;
+	ExeDbgCmd(a_pDev, a_pRegBA, a_DdbSel, a_DbgOut, DbgCmd);
+	/* drzh2n_t3 line_pix_cnt */
+	DbgCmd = 0x0003C501;
+	ExeDbgCmd(a_pDev, a_pRegBA, a_DdbSel, a_DbgOut, DbgCmd);
+	/* drzh2n_t3 handshake signal */
+	DbgCmd = 0x0004C501;
+	ExeDbgCmd(a_pDev, a_pRegBA, a_DdbSel, a_DbgOut, DbgCmd);
+	/* drzh2n_t4 line_pix_cnt_tmp */
+	DbgCmd = 0x0002C601;
+	ExeDbgCmd(a_pDev, a_pRegBA, a_DdbSel, a_DbgOut, DbgCmd);
+	/* drzh2n_t4 line_pix_cnt */
+	DbgCmd = 0x0003C601;
+	ExeDbgCmd(a_pDev, a_pRegBA, a_DdbSel, a_DbgOut, DbgCmd);
+	/* drzh2n_t4 handshake signal */
+	DbgCmd = 0x0004C601;
+	ExeDbgCmd(a_pDev, a_pRegBA, a_DdbSel, a_DbgOut, DbgCmd);
+	/* drzh2n_t5 line_pix_cnt_tmp */
+	DbgCmd = 0x0002C701;
+	ExeDbgCmd(a_pDev, a_pRegBA, a_DdbSel, a_DbgOut, DbgCmd);
+	/* drzh2n_t5 line_pix_cnt */
+	DbgCmd = 0x0003C701;
+	ExeDbgCmd(a_pDev, a_pRegBA, a_DdbSel, a_DbgOut, DbgCmd);
+	/* drzh2n_t5 handshake signal */
+	DbgCmd = 0x0004C701;
+	ExeDbgCmd(a_pDev, a_pRegBA, a_DdbSel, a_DbgOut, DbgCmd);
+	/* drzh2n_t6 line_pix_cnt_tmp */
+	DbgCmd = 0x0002C801;
+	ExeDbgCmd(a_pDev, a_pRegBA, a_DdbSel, a_DbgOut, DbgCmd);
+	/* drzh2n_t6 line_pix_cnt */
+	DbgCmd = 0x0003C801;
+	ExeDbgCmd(a_pDev, a_pRegBA, a_DdbSel, a_DbgOut, DbgCmd);
+	/* drzh2n_t6 handshake signal */
+	DbgCmd = 0x0004C801;
+	ExeDbgCmd(a_pDev, a_pRegBA, a_DdbSel, a_DbgOut, DbgCmd);
+	/* rzh1n2t_t1 checksum */
+	DbgCmd = 0x0001C201;
+	ExeDbgCmd(a_pDev, a_pRegBA, a_DdbSel, a_DbgOut, DbgCmd);
+	/* rzh1n2t_t1 tile line_pix_cnt */
+	DbgCmd = 0x0003C201;
+	ExeDbgCmd(a_pDev, a_pRegBA, a_DdbSel, a_DbgOut, DbgCmd);
+	/* rzh1n2t_t1 tile protocal */
+	DbgCmd = 0x0008C201;
+	ExeDbgCmd(a_pDev, a_pRegBA, a_DdbSel, a_DbgOut, DbgCmd);
+
+}
+
+static void imgsys_traw_dump_smto(struct mtk_imgsys_dev *a_pDev,
+				void __iomem *a_pRegBA,
+				unsigned int a_DdbSel,
+				unsigned int a_DbgOut)
+{
+	unsigned int DbgCmd = 0;
+
+
+	/* smto_t3 line_pix_cnt_tmp */
+	DbgCmd = 0x0002C401;
+	ExeDbgCmd(a_pDev, a_pRegBA, a_DdbSel, a_DbgOut, DbgCmd);
+	/* smto_t3 line_pix_cnt */
+	DbgCmd = 0x0003C401;
+	ExeDbgCmd(a_pDev, a_pRegBA, a_DdbSel, a_DbgOut, DbgCmd);
+	/* smto_t3 handshake signal */
+	DbgCmd = 0x0004C401;
+	ExeDbgCmd(a_pDev, a_pRegBA, a_DdbSel, a_DbgOut, DbgCmd);
+
+}
+
+static void imgsys_traw_dump_dl(struct mtk_imgsys_dev *a_pDev,
+				void __iomem *a_pRegBA,
+				unsigned int a_DdbSel,
+				unsigned int a_DbgOut)
+{
+	unsigned int DbgCmd = 0;
+	unsigned int DbgData = 0;
+	unsigned int DbgLineCnt = 0, DbgRdy = 0, DbgReq = 0;
+	unsigned int DbgLineCntReg = 0;
+
+
+	/* wpe_wif_t1_debug */
+	/* sot_st,eol_st,eot_st,sof,sot,eol,eot,req,rdy,7b0,checksum_out */
+	DbgCmd = 0x00000006;
+	DbgData = ExeDbgCmd(a_pDev, a_pRegBA, a_DdbSel, a_DbgOut, DbgCmd);
+	DbgRdy = ((DbgData & 0x800000) > 0) ? 1 : 0;
+	DbgReq = ((DbgData & 0x1000000) > 0) ? 1 : 0;
+	pr_info("[wpe_wif_t1_debug]checksum(0x%X),rdy(%d) req(%d)\n",
+		DbgData & 0xFFFF, DbgRdy, DbgReq);
+	/* line_cnt[15:0],  pix_cnt[15:0] */
+	DbgCmd = 0x00000007;
+	DbgData = ExeDbgCmd(a_pDev, a_pRegBA, a_DdbSel, a_DbgOut, DbgCmd);
+	DbgLineCnt = (DbgData & 0xFFFF0000) / 0xFFFF;
+	pr_info("[wpe_wif_t1_debug]pix_cnt(0x%X),line_cnt(0x%X)\n",
+		DbgData & 0xFFFF, DbgLineCnt);
+	/* line_cnt_reg[15:0], pix_cnt_reg[15:0] */
+	DbgCmd = 0x00000008;
+	DbgData = ExeDbgCmd(a_pDev, a_pRegBA, a_DdbSel, a_DbgOut, DbgCmd);
+	DbgLineCntReg = (DbgData & 0xFFFF0000) / 0xFFFF;
+	pr_info("[wpe_wif_t1_debug]pix_cnt_reg(0x%X),line_cnt_reg(0x%X)\n",
+		DbgData & 0xFFFF, DbgLineCntReg);
+
+	/* wpe_wif_t2_debug */
+	/* sot_st,eol_st,eot_st,sof,sot,eol,eot,req,rdy,7b0,checksum_out */
+	DbgCmd = 0x00000106;
+	DbgData = ExeDbgCmd(a_pDev, a_pRegBA, a_DdbSel, a_DbgOut, DbgCmd);
+	DbgRdy = ((DbgData & 0x800000) > 0) ? 1 : 0;
+	DbgReq = ((DbgData & 0x1000000) > 0) ? 1 : 0;
+	pr_info("[wpe_wif_t2_debug]checksum(0x%X),rdy(%d) req(%d)\n",
+		DbgData & 0xFFFF, DbgRdy, DbgReq);
+	/* line_cnt[15:0],  pix_cnt[15:0] */
+	DbgCmd = 0x00000107;
+	DbgData = ExeDbgCmd(a_pDev, a_pRegBA, a_DdbSel, a_DbgOut, DbgCmd);
+	DbgLineCnt = (DbgData & 0xFFFF0000) / 0xFFFF;
+	pr_info("[wpe_wif_t2_debug]pix_cnt(0x%X),line_cnt(0x%X)\n",
+		DbgData & 0xFFFF, DbgLineCnt);
+	/* line_cnt_reg[15:0], pix_cnt_reg[15:0] */
+	DbgCmd = 0x00000108;
+	DbgData = ExeDbgCmd(a_pDev, a_pRegBA, a_DdbSel, a_DbgOut, DbgCmd);
+	DbgLineCntReg = (DbgData & 0xFFFF0000) / 0xFFFF;
+	pr_info("[wpe_wif_t2_debug]pix_cnt_reg(0x%X),line_cnt_reg(0x%X)\n",
+		DbgData & 0xFFFF, DbgLineCntReg);
+
+	/* traw_dip_d1_debug */
+	/* sot_st,eol_st,eot_st,sof,sot,eol,eot,req,rdy,7b0,checksum_out */
+	DbgCmd = 0x00000206;
+	DbgData = ExeDbgCmd(a_pDev, a_pRegBA, a_DdbSel, a_DbgOut, DbgCmd);
+	DbgRdy = ((DbgData & 0x800000) > 0) ? 1 : 0;
+	DbgReq = ((DbgData & 0x1000000) > 0) ? 1 : 0;
+	pr_info("[traw_dip_d1_debug]checksum(0x%X),rdy(%d) req(%d)\n",
+		DbgData & 0xFFFF, DbgRdy, DbgReq);
+	/* line_cnt[15:0],  pix_cnt[15:0] */
+	DbgCmd = 0x00000207;
+	DbgData = ExeDbgCmd(a_pDev, a_pRegBA, a_DdbSel, a_DbgOut, DbgCmd);
+	DbgLineCnt = (DbgData & 0xFFFF0000) / 0xFFFF;
+	pr_info("[traw_dip_d1_debug]pix_cnt(0x%X),line_cnt(0x%X)\n",
+		DbgData & 0xFFFF, DbgLineCnt);
+	/* line_cnt_reg[15:0], pix_cnt_reg[15:0] */
+	DbgCmd = 0x00000208;
+	DbgData = ExeDbgCmd(a_pDev, a_pRegBA, a_DdbSel, a_DbgOut, DbgCmd);
+	DbgLineCntReg = (DbgData & 0xFFFF0000) / 0xFFFF;
+	pr_info("[traw_dip_d1_debug]pix_cnt_reg(0x%X),line_cnt_reg(0x%X)\n",
+		DbgData & 0xFFFF, DbgLineCntReg);
+}
+
+#if TRAW_M4U
+static int GetFaultDMAAddr(unsigned int port, unsigned int *pStartAddr, unsigned int *pEndAddr)
+{
+	int Result = 1;
+
+	/* IMGI_T1 */
+	if (port == MTK_M4U_PORT_ID(0, 0, 9, 0) ||
+		port == MTK_M4U_PORT_ID(0, 0, 9, 9)) {
+		*pStartAddr = TRAW_DMA_IMGI_ADDR;
+		*pEndAddr = (*pStartAddr + 48);
+	}
+	/* UFDI_T1 */
+	// else if (port == MTK_M4U_PORT_ID(0, 0, 9, 1)) {
+	//	*pStartAddr = TRAW_DMA_UFDI_ADDR;
+	//	*pEndAddr = (*pStartAddr + 48);
+	//}
+	/* IMGBI_T1 */
+	else if (port == MTK_M4U_PORT_ID(0, 0, 9, 1) ||
+		port == MTK_M4U_PORT_ID(0, 0, 9, 10)) {
+		*pStartAddr = TRAW_DMA_IMGBI_ADDR;
+		*pEndAddr = (*pStartAddr + 48);
+	}
+	/* IMGCI_T1 */
+	else if (port == MTK_M4U_PORT_ID(0, 0, 9, 2) ||
+		port == MTK_M4U_PORT_ID(0, 0, 9, 11)) {
+		*pStartAddr = TRAW_DMA_IMGCI_ADDR;
+		*pEndAddr = (*pStartAddr + 48);
+	}
+	/* YUVO_T1 */
+	else if (port == MTK_M4U_PORT_ID(0, 0, 9, 6)) {
+		*pStartAddr = TRAW_DMA_YUVO_T1_ADDR;
+		*pEndAddr = (*pStartAddr + 224);
+	}
+	/* TIMGO_T1 */
+	else if (port == MTK_M4U_PORT_ID(0, 0, 9, 7)) {
+		*pStartAddr = TRAW_DMA_TIMGO_T1_ADDR;
+		*pEndAddr = (*pStartAddr + 48);
+	}
+	/* YUVO_T2 */
+	else if (port == MTK_M4U_PORT_ID(0, 0, 9, 8) ||
+		port == MTK_M4U_PORT_ID(0, 0, 9, 17)) {
+		*pStartAddr = TRAW_DMA_YUVO_T2_ADDR;
+		*pEndAddr = (*pStartAddr + 368);
+	}
+	/* YUVO_T5 */
+	else if (port == MTK_M4U_PORT_ID(0, 0, 9, 12) ||
+		port == MTK_M4U_PORT_ID(0, 0, 9, 18)) {
+		*pStartAddr = TRAW_DMA_YUVO_T5_ADDR;
+		*pEndAddr = (*pStartAddr + 48);
+	}
+	/* TNCSO_T1 */
+	else if (port == MTK_M4U_PORT_ID(0, 0, 9, 16)) {
+		*pStartAddr = TRAW_DMA_TNCSO_T1_ADDR;
+		*pEndAddr = (*pStartAddr + 240);
+	}
+	/* Not Define Port */
+	else
+		Result = 0;
+
+
+
+	return Result;
+
+
+}
+
+
+static int imgsys_traw_iommu_cb(int port, dma_addr_t mva, void *cb_data)
+{
+	unsigned int engine = IMGSYS_ENG_TRAW;
+	void __iomem *trawRegBA = 0L;
+	unsigned int i = 0;
+	unsigned int DMAStartAddr = 0, DMAEndAddr = 0;
+	unsigned int RegMap = REG_MAP_E_TRAW;
+	char DbgStr[128];
+
+
+	if (g_IOMMUDumpPort != port)
+		g_IOMMUDumpPort = port;
+	else
+		return 0;
+
+	/* Set HW Engine */
+	if (port >= MTK_M4U_PORT_ID(0, 0, 9, 0) &&
+		port <= MTK_M4U_PORT_ID(0, 0, 9, 8))
+		engine = IMGSYS_ENG_TRAW;
+	else if (port >= MTK_M4U_PORT_ID(0, 0, 9, 9) &&
+		port <= MTK_M4U_PORT_ID(0, 0, 9, 11))
+		engine = IMGSYS_ENG_LTR;
+	else if (port == MTK_M4U_PORT_ID(0, 0, 9, 12))
+		engine = IMGSYS_ENG_TRAW;
+	else if (port == MTK_M4U_PORT_ID(0, 0, 9, 13))
+		engine = IMGSYS_ENG_LTR;
+	else if (port >= MTK_M4U_PORT_ID(0, 0, 9, 14) &&
+		port <= MTK_M4U_PORT_ID(0, 0, 9, 16))
+		engine = IMGSYS_ENG_TRAW;
+	else if (port >= MTK_M4U_PORT_ID(0, 0, 9, 17) &&
+		port <= MTK_M4U_PORT_ID(0, 0, 9, 19))
+		engine = IMGSYS_ENG_LTR;
+	else
+		return 0;
+
+	/* ltraw */
+	if (engine & IMGSYS_ENG_LTR) {
+		RegMap = REG_MAP_E_LTRAW;
+		g_RegBaseAddr = TRAW_B_BASE_ADDR;
+		trawRegBA = g_ltrawRegBA;
+	}
+	/* traw */
+	else {
+		g_RegBaseAddr = TRAW_A_BASE_ADDR;
+		trawRegBA = g_trawRegBA;
+	}
+
+	if (!trawRegBA)
+		return 0;
+
+	/* Dump Fault DMA registers */
+	if (GetFaultDMAAddr(port, &DMAStartAddr, &DMAEndAddr) == 0)
+		return 0;
+
+	for (i = DMAStartAddr; i <= DMAEndAddr; i += 16) {
+		if (sprintf(DbgStr, "[0x%08X] 0x%08X 0x%08X 0x%08X 0x%08X",
+			(unsigned int)(g_RegBaseAddr + i),
+			(unsigned int)ioread32((void *)(trawRegBA + i)),
+			(unsigned int)ioread32((void *)(trawRegBA + i + 4)),
+			(unsigned int)ioread32((void *)(trawRegBA + i + 8)),
+			(unsigned int)ioread32((void *)(trawRegBA + i + 12))) > 0)
+			pr_info("%s\n", DbgStr);
+	}
+
+	return 0;
+
+}
+
+static void imgsys_traw_reg_iommu_cb(void)
+{
+	unsigned int i = 0;
+
+	/* Reg Traw/Ltraw L9 Port Callback */
+	for (i = 0; i < TRAW_L9_PORT_CNT; i++) {
+		mtk_iommu_register_fault_callback(
+			g_IOMMUL9Def[i],
+			(mtk_iommu_fault_callback_t)imgsys_traw_iommu_cb,
+			NULL, false);
+	}
+}
+#endif
+
+
+//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+// Public Functions
+//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+void imgsys_traw_set_initial_value(struct mtk_imgsys_dev *imgsys_dev)
+{
+	/* iomap reg base */
+	g_trawRegBA = of_iomap(imgsys_dev->dev->of_node, REG_MAP_E_TRAW);
+	g_ltrawRegBA = of_iomap(imgsys_dev->dev->of_node, REG_MAP_E_LTRAW);
+#if TRAW_M4U
+	imgsys_traw_reg_iommu_cb();
+	/* Register IOMMU Callback */
+	g_IOMMUDumpPort = 0;
+#endif
+	pr_debug("%s\n", __func__);
+}
+
+void imgsys_traw_set_initial_value_hw(struct mtk_imgsys_dev *imgsys_dev)
+{
+	void __iomem *trawRegBA = 0L;
+	void __iomem *ofset = NULL;
+	unsigned int i = 0, HwIdx = 0;
+
+	for (HwIdx = 0; HwIdx < TRAW_HW_SET; HwIdx++) {
+		if (HwIdx == 0)
+			trawRegBA = g_trawRegBA;
+		else if (HwIdx == 1)
+			trawRegBA = g_ltrawRegBA;
+
+		if (!trawRegBA) {
+			pr_info("%s: hw(%d)null reg base\n", __func__, HwIdx);
+			break;
+		}
+
+		for (i = 0 ; i < TRAW_INIT_ARRAY_COUNT ; i++) {
+			ofset = trawRegBA + mtk_imgsys_traw_init_ary[i].ofset;
+			writel(mtk_imgsys_traw_init_ary[i].val, ofset);
+		}
+	}
+
+	pr_debug("%s\n", __func__);
+}
+
+void imgsys_traw_debug_dump(struct mtk_imgsys_dev *imgsys_dev,
+							unsigned int engine)
+{
+	void __iomem *trawRegBA = 0L;
+	unsigned int i;
+	unsigned int DMADdbSel = TRAW_DMA_DBG_SEL;
+	unsigned int DMADbgOut = TRAW_DMA_DBG_PORT;
+	unsigned int CtlDdbSel = TRAW_CTL_DBG_SEL;
+	unsigned int CtlDbgOut = TRAW_CTL_DBG_PORT;
+	unsigned int RegMap = REG_MAP_E_TRAW;
+	char DbgStr[128];
+
+	pr_info("%s: +\n", __func__);
+
+	/* ltraw */
+	if (engine & IMGSYS_ENG_LTR) {
+		RegMap = REG_MAP_E_LTRAW;
+		g_RegBaseAddr = TRAW_B_BASE_ADDR;
+		trawRegBA = g_ltrawRegBA;
+	}
+	/* traw */
+	else {
+		g_RegBaseAddr = TRAW_A_BASE_ADDR;
+		trawRegBA = g_trawRegBA;
+	}
+
+	if (!trawRegBA) {
+		dev_info(imgsys_dev->dev, "%s Unable to ioremap regmap(%d)\n",
+			__func__, RegMap);
+		dev_info(imgsys_dev->dev, "%s of_iomap fail, devnode(%s).\n",
+			__func__, imgsys_dev->dev->of_node->name);
+		goto err_debug_dump;
+	}
+
+	/* DL debug data */
+	imgsys_traw_dump_dl(imgsys_dev, trawRegBA, CtlDdbSel, CtlDbgOut);
+
+	/* Ctrl registers */
+	for (i = 0x0; i <= TRAW_CTL_ADDR_OFST; i += 16) {
+		if (sprintf(DbgStr, "[0x%08X] 0x%08X 0x%08X 0x%08X 0x%08X",
+			(unsigned int)(g_RegBaseAddr + i),
+			(unsigned int)ioread32((void *)(trawRegBA + i)),
+			(unsigned int)ioread32((void *)(trawRegBA + i + 4)),
+			(unsigned int)ioread32((void *)(trawRegBA + i + 8)),
+			(unsigned int)ioread32((void *)(trawRegBA + i + 12))) > 0)
+			pr_info("%s\n", DbgStr);
+	}
+	/* Dma registers */
+	for (i = TRAW_DMA_ADDR_OFST; i <= TRAW_DMA_ADDR_END; i += 16) {
+		if (sprintf(DbgStr, "[0x%08X] 0x%08X 0x%08X 0x%08X 0x%08X",
+			(unsigned int)(g_RegBaseAddr + i),
+			(unsigned int)ioread32((void *)(trawRegBA + i)),
+			(unsigned int)ioread32((void *)(trawRegBA + i + 4)),
+			(unsigned int)ioread32((void *)(trawRegBA + i + 8)),
+			(unsigned int)ioread32((void *)(trawRegBA + i + 12))) > 0)
+			pr_info("%s\n", DbgStr);
+	}
+	/* Data registers */
+	for (i = TRAW_DATA_ADDR_OFST; i <= TRAW_MAX_ADDR_OFST; i += 16) {
+		if (sprintf(DbgStr, "[0x%08X] 0x%08X 0x%08X 0x%08X 0x%08X",
+			(unsigned int)(g_RegBaseAddr + i),
+			(unsigned int)ioread32((void *)(trawRegBA + i)),
+			(unsigned int)ioread32((void *)(trawRegBA + i + 4)),
+			(unsigned int)ioread32((void *)(trawRegBA + i + 8)),
+			(unsigned int)ioread32((void *)(trawRegBA + i + 12))) > 0)
+			pr_info("%s\n", DbgStr);
+	}
+
+	/* DMA debug data */
+	imgsys_traw_dump_dma(imgsys_dev, trawRegBA, DMADdbSel, DMADbgOut);
+	/* CQ debug data */
+	imgsys_traw_dump_cq(imgsys_dev, trawRegBA, CtlDdbSel, CtlDbgOut);
+	/* DRZH2N debug data */
+	imgsys_traw_dump_drzh2n(imgsys_dev, trawRegBA, CtlDdbSel, CtlDbgOut);
+	/* SMTO debug data */
+	imgsys_traw_dump_smto(imgsys_dev, trawRegBA, CtlDdbSel, CtlDbgOut);
+
+err_debug_dump:
+	pr_info("%s: -\n", __func__);
+}
+
+void imgsys_traw_uninit(struct mtk_imgsys_dev *imgsys_dev)
+{
+	if (g_trawRegBA) {
+		iounmap(g_trawRegBA);
+		g_trawRegBA = 0L;
+	}
+	if (g_ltrawRegBA) {
+		iounmap(g_ltrawRegBA);
+		g_ltrawRegBA = 0L;
+	}
+
+	pr_debug("%s\n", __func__);
+}
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_70/modules/mtk_imgsys-traw.h b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_70/modules/mtk_imgsys-traw.h
new file mode 100644
index 0000000000000000000000000000000000000000..e450ee625244a64765e0467a3f949e983e9a186a
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_70/modules/mtk_imgsys-traw.h
@@ -0,0 +1,95 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2021 MediaTek Inc.
+ *
+ * Author: Shih-fang Chuang <shih-fang.chuang@mediatek.com>
+ *
+ */
+
+#ifndef _MTK_IMGSYS_TRAW_H_
+#define _MTK_IMGSYS_TRAW_H_
+
+// Standard C header file
+
+// kernel header file
+
+// mtk imgsys local header file
+#include <mtk_imgsys-dev.h>
+#include <mtk_imgsys-cmdq.h>
+
+// Local header file
+#include "mtk_imgsys-engine.h"
+
+/********************************************************************
+ * Global Define
+ ********************************************************************/
+#define TRAW_A_BASE_ADDR	0x15020000
+#define TRAW_B_BASE_ADDR	0x15040000
+
+#define TRAW_DMA_NAME_MAX_SIZE	20
+
+#define TRAW_DMA_DBG_SEL	 (0x1070)
+#define TRAW_DMA_DBG_PORT	 (0x1074)
+#define TRAW_CTL_DBG_SEL	 (0x0190)
+#define TRAW_CTL_DBG_PORT	 (0x0194)
+#define TRAW_DIPCQ_CQ_EN	 (0x0200)
+#define WPE_MACRO_SW_RST	 (0x000C)
+#define WPE_MACRO_WPE_RST	 (0x0004)
+#define WPE_MACRO_LARB11_RST	 (0x0001)
+
+
+#define TRAW_IMGI_STATE_CHECKSUM		(0x00100)
+#define TRAW_IMGI_LINE_PIX_CNT_TMP		(0x00200)
+#define TRAW_IMGI_LINE_PIX_CNT			(0x00300)
+#define TRAW_IMGI_IMPORTANT_STATUS		(0x00400)
+#define TRAW_IMGI_SMI_DEBUG_DATA_CASE0		(0x00500)
+#define TRAW_IMGI_TILEX_BYTE_CNT		(0x00600)
+#define TRAW_IMGI_TILEY_CNT			(0x00700)
+#define TRAW_IMGI_BURST_LINE_CNT		(0x00800)
+#define TRAW_IMGI_XFER_Y_CNT			(0x00900)
+#define TRAW_IMGI_FIFO_DEBUG_DATA_CASE1		(0x10600)
+#define TRAW_IMGI_FIFO_DEBUG_DATA_CASE3		(0x30600)
+#define TRAW_YUVO_T1_FIFO_DEBUG_DATA_CASE1	(0x10700)
+#define TRAW_YUVO_T1_FIFO_DEBUG_DATA_CASE3	(0x30700)
+
+#define	TRAW_DMA_IMGI_ADDR		(0x1200)
+#define	TRAW_DMA_UFDI_ADDR		(0x1260)
+#define	TRAW_DMA_IMGBI_ADDR		(0x12C0)
+#define	TRAW_DMA_IMGCI_ADDR		(0x1320)
+#define	TRAW_DMA_YUVO_T1_ADDR		(0x1640)
+#define	TRAW_DMA_YUVBO_T1_ADDR		(0x16F0)
+#define	TRAW_DMA_YUVCO_T1_ADDR		(0x17A0)
+#define	TRAW_DMA_TIMGO_T1_ADDR		(0x1900)
+#define	TRAW_DMA_YUVO_T2_ADDR		(0x19B0)
+#define	TRAW_DMA_YUVO_T5_ADDR		(0x1B30)
+#define	TRAW_DMA_TNCSO_T1_ADDR		(0x1BE0)
+
+/********************************************************************
+ * Enum Define
+ ********************************************************************/
+enum TRAWDmaDebugType {
+	TRAW_ORI_RDMA_DEBUG,
+	TRAW_ORI_RDMA_UFD_DEBUG,
+	TRAW_ORI_WDMA_DEBUG,
+	TRAW_ULC_RDMA_DEBUG,
+	TRAW_ULC_WDMA_DEBUG,
+};
+
+/********************************************************************
+ * Structure Define
+ ********************************************************************/
+struct TRAWDmaDebugInfo {
+	char DMAName[TRAW_DMA_NAME_MAX_SIZE];
+	enum TRAWDmaDebugType DMADebugType;
+};
+
+//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+// Public Functions
+//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+void imgsys_traw_set_initial_value(struct mtk_imgsys_dev *imgsys_dev);
+void imgsys_traw_set_initial_value_hw(struct mtk_imgsys_dev *imgsys_dev);
+void imgsys_traw_debug_dump(struct mtk_imgsys_dev *imgsys_dev,
+							unsigned int engine);
+void imgsys_traw_uninit(struct mtk_imgsys_dev *imgsys_dev);
+
+#endif /* _MTK_IMGSYS_TRAW_H_ */
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_70/modules/mtk_imgsys-wpe.c b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_70/modules/mtk_imgsys-wpe.c
new file mode 100644
index 0000000000000000000000000000000000000000..65ec31799284771b11ec295594d8ac8a8b6a9759
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_70/modules/mtk_imgsys-wpe.c
@@ -0,0 +1,428 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2021 MediaTek Inc.
+ *
+ * Author: Floria Huang <floria.huang@mediatek.com>
+ *
+ */
+
+#include <linux/device.h>
+#include <linux/of_address.h>
+#include <dma-iommu.h>
+#include <linux/pm_runtime.h>
+#include <linux/remoteproc.h>
+
+//#include "iommu_debug.h"
+#ifdef WPE_TF_DUMP_71_1
+#include <dt-bindings/memory/mt6983-larb-port.h>
+
+#elif defined(WPE_TF_DUMP_71_2)
+#include <dt-bindings/memory/mt6879-larb-port.h>
+
+#elif defined(WPE_TF_DUMP_70_1)
+#include <dt-bindings/memory/mt8195-larb-port.h>
+#endif
+
+#include <dt-bindings/memory/mt8195-memory-port.h>
+
+#define M4U_PORT_DUMMY_EIS  (0)
+#define M4U_PORT_DUMMY_TNR  (1)
+
+#include "mtk_imgsys-wpe.h"
+
+#define WPE_A_BASE        (0x15200000)
+const unsigned int mtk_imgsys_wpe_base_ofst[] = {0x0, 0x10000};
+#define WPE_HW_NUM        ARRAY_SIZE(mtk_imgsys_wpe_base_ofst)
+
+//CTL_MOD_EN
+#define PQDIP_DL  0x40000
+#define DIP_DL    0x80000
+#define TRAW_DL   0x100000
+
+// for CQ_THR0_CTL ~ CQ_THR14CTL
+#define CQ_THRX_CTL_EN (1L << 0)
+#define CQ_THRX_CTL_MODE (1L << 4)//immediately mode
+#define CQ_THRX_CTL	(CQ_THRX_CTL_EN | CQ_THRX_CTL_MODE)
+
+// register ofst
+#define WPE_REG_DBG_SET     (0x48)
+#define WPE_REG_DBG_PORT    (0x4C)
+#define WPE_REG_CQ_THR0_CTL (0xA10)
+#define WPE_REG_CQ_THR1_CTL (0xA1C)
+
+
+const struct mtk_imgsys_init_array
+			mtk_imgsys_wpe_init_ary[] = {
+	{0x0018, 0x80000000}, /* WPE_TOP_CTL_INT_EN, en w-clr */
+	{0x0024, 0xFFFFFFFF}, /* WPE_TOP_CTL_INT_STATUSX, w-clr */
+	{0x00D4, 0x80000000}, /* WPE_TOP_CQ_IRQ_EN, en w-clr */
+	{0x00DC, 0xFFFFFFFF}, /* WPE_TOP_CQ_IRQ_STX, w-clr */
+	{0x00E0, 0x80000000}, /* WPE_TOP_CQ_IRQ_EN2, en w-clr */
+	{0x00E8, 0xFFFFFFFF}, /* WPE_TOP_CQ_IRQ_STX2, w-clr */
+	{0x00EC, 0x80000000}, /* WPE_TOP_CQ_IRQ_EN3, en w-clr */
+	{0x00F4, 0xFFFFFFFF}, /* WPE_TOP_CQ_IRQ_STX3, w-clr */
+	{0x0204, 0x00000002}, /* WPE_CACHE_RWCTL_CTL */
+	{0x03D4, 0x80000000}, /* WPE_DMA_DMA_ERR_CTRL */
+	{0x0A10, CQ_THRX_CTL}, /*DIPCQ_W1A_DIPCQ_CQ_THR0_CTL */
+	{0x0A1C, CQ_THRX_CTL}, /*DIPCQ_W1A_DIPCQ_CQ_THR1_CTL */
+	{0x0A28, CQ_THRX_CTL}, /*DIPCQ_W1A_DIPCQ_CQ_THR2_CTL */
+	{0x0A34, CQ_THRX_CTL}, /*DIPCQ_W1A_DIPCQ_CQ_THR3_CTL */
+	{0x0A40, CQ_THRX_CTL}, /*DIPCQ_W1A_DIPCQ_CQ_THR4_CTL */
+	{0x0A4C, CQ_THRX_CTL}, /*DIPCQ_W1A_DIPCQ_CQ_THR5_CTL */
+	{0x0A58, CQ_THRX_CTL}, /*DIPCQ_W1A_DIPCQ_CQ_THR6_CTL */
+	{0x0A64, CQ_THRX_CTL}, /*DIPCQ_W1A_DIPCQ_CQ_THR7_CTL */
+	{0x0A70, CQ_THRX_CTL}, /*DIPCQ_W1A_DIPCQ_CQ_THR8_CTL */
+	{0x0A7C, CQ_THRX_CTL}, /*DIPCQ_W1A_DIPCQ_CQ_THR9_CTL */
+	{0x0A88, CQ_THRX_CTL}, /*DIPCQ_W1A_DIPCQ_CQ_THR10_CTL */
+	{0x0A94, CQ_THRX_CTL}, /*DIPCQ_W1A_DIPCQ_CQ_THR11_CTL */
+	{0x0AA0, CQ_THRX_CTL}, /*DIPCQ_W1A_DIPCQ_CQ_THR12_CTL */
+	{0x0AAC, CQ_THRX_CTL}, /*DIPCQ_W1A_DIPCQ_CQ_THR13_CTL */
+	{0x0AB8, CQ_THRX_CTL}, /*DIPCQ_W1A_DIPCQ_CQ_THR14_CTL */
+};
+#define WPE_INIT_ARRAY_COUNT  ARRAY_SIZE(mtk_imgsys_wpe_init_ary)
+
+struct imgsys_reg_range {
+	uint32_t str;
+	uint32_t end;
+};
+const struct imgsys_reg_range wpe_regs[] = {
+	{0x0000, 0x0164}, /* TOP,VECI,VEC2I */
+	{0x0200, 0x0248}, /* CACHE */
+	{0x0300, 0x032C}, /* WPEO */
+	{0x0340, 0x036C}, /* WPEO2 */
+	{0x0380, 0x03A8}, /* MSKO */
+	{0x03C0, 0x0408}, /* DMA */
+	{0x0440, 0x0448}, /* TDRI */
+	{0x04C0, 0x0504}, /* VGEN */
+	{0x0540, 0x05D4}, /* PSP */
+	{0x0600, 0x0620}, /* C24,C02 */
+	{0x0640, 0x0654}, /* DL CROP */
+	{0x0680, 0x0694}, /* DMA CROP */
+	{0x06C0, 0x0784}, /* DEC,PAK */
+	{0x07C0, 0x07D0}, /* TOP2 */
+	{0x0800, 0x080C},
+	{0x0A00, 0x0AF0}, /* DIPCQ_W1 */
+};
+#define WPE_REG_ARRAY_COUNT	ARRAY_SIZE(wpe_regs)
+
+void __iomem *gWpeRegBA[WPE_HW_NUM] = {0L};
+
+#ifdef WPE_TF_DUMP_70_1
+int imgsys_wpe_tfault_callback(int port,
+	dma_addr_t mva, void *data)
+{
+	void __iomem *wpeRegBA = 0L;
+	unsigned int i, j;
+	unsigned int wpeBase = 0;
+	unsigned int engine;
+
+	pr_debug("%s: +\n", __func__);
+
+	switch (port) {
+	case M4U_PORT_L11_IMG_WPE_EIS_RDMA0_A:
+	case M4U_PORT_L11_IMG_WPE_EIS_RDMA1_A:
+	case M4U_PORT_L11_IMG_WPE_EIS_WDMA0_A:
+	case M4U_PORT_L11_IMG_WPE_EIS_CQ0_A:
+	case M4U_PORT_L11_IMG_WPE_EIS_CQ1_A:
+	case M4U_PORT_DUMMY_EIS:
+		engine = REG_MAP_E_WPE_EIS;
+		break;
+	case M4U_PORT_L11_IMG_WPE_TNR_RDMA0_A:
+	case M4U_PORT_L11_IMG_WPE_TNR_RDMA1_A:
+	case M4U_PORT_L11_IMG_WPE_TNR_WDMA0_A:
+	case M4U_PORT_L11_IMG_WPE_TNR_CQ0_A:
+	case M4U_PORT_L11_IMG_WPE_TNR_CQ1_A:
+	case M4U_PORT_DUMMY_TNR:
+		engine = REG_MAP_E_WPE_TNR;
+		break;
+	default:
+		pr_info("%s: TF port (%d) doesn't belongs to WPE.\n\n", __func__, port);
+		return 0;
+	};
+
+	/* iomap registers */
+	wpeRegBA = gWpeRegBA[engine - REG_MAP_E_WPE_EIS];
+	if (!wpeRegBA) {
+		pr_info("%s: WPE_%d, RegBA=0", __func__, (engine - REG_MAP_E_WPE_EIS));
+		return 1;
+	}
+
+	pr_info("%s: ==== Dump WPE_%d, TF port: 0x%x =====",
+		__func__, (engine - REG_MAP_E_WPE_EIS), port);
+
+	//
+	wpeBase = WPE_A_BASE + mtk_imgsys_wpe_base_ofst[(engine - REG_MAP_E_WPE_EIS)];
+	for (j = 0; j < WPE_REG_ARRAY_COUNT; j++) {
+		for (i = wpe_regs[j].str; i <= wpe_regs[j].end; i += 0x10) {
+			pr_info("%s: [0x%08X] 0x%08X 0x%08X 0x%08X 0x%08X", __func__,
+				(unsigned int)(wpeBase + i),
+				(unsigned int)ioread32((void *)(wpeRegBA + i)),
+				(unsigned int)ioread32((void *)(wpeRegBA + i + 0x4)),
+				(unsigned int)ioread32((void *)(wpeRegBA + i + 0x8)),
+				(unsigned int)ioread32((void *)(wpeRegBA + i + 0xC)));
+		}
+	}
+
+	return 1;
+}
+#endif
+
+void imgsys_wpe_set_initial_value(struct mtk_imgsys_dev *imgsys_dev)
+{
+	unsigned int hw_idx = 0, ary_idx = 0;
+
+	dev_dbg(imgsys_dev->dev, "%s: +\n", __func__);
+
+	for (hw_idx = REG_MAP_E_WPE_EIS; hw_idx <= REG_MAP_E_WPE_TNR; hw_idx++) {
+		/* iomap registers */
+		ary_idx = hw_idx - REG_MAP_E_WPE_EIS;
+		gWpeRegBA[ary_idx] = of_iomap(imgsys_dev->dev->of_node, hw_idx);
+		if (!gWpeRegBA[ary_idx]) {
+			dev_info(imgsys_dev->dev,
+				"%s: error: unable to iomap wpe_%d registers, devnode(%s).\n",
+				__func__, hw_idx, imgsys_dev->dev->of_node->name);
+			continue;
+		}
+	}
+
+#ifdef WPE_TF_DUMP_70_1
+	/* K510 do not support mtk_iommu_register_fault_callback */
+	//wpe_eis
+	mtk_iommu_register_fault_callback(M4U_PORT_L11_IMG_WPE_EIS_RDMA0_A,
+		(mtk_iommu_fault_callback_t)imgsys_wpe_tfault_callback,
+		NULL, false);
+	mtk_iommu_register_fault_callback(M4U_PORT_L11_IMG_WPE_EIS_RDMA1_A,
+		(mtk_iommu_fault_callback_t)imgsys_wpe_tfault_callback,
+		NULL, false);
+	mtk_iommu_register_fault_callback(M4U_PORT_L11_IMG_WPE_EIS_WDMA0_A,
+		(mtk_iommu_fault_callback_t)imgsys_wpe_tfault_callback,
+		NULL, false);
+	mtk_iommu_register_fault_callback(M4U_PORT_L11_IMG_WPE_EIS_CQ0_A,
+		(mtk_iommu_fault_callback_t)imgsys_wpe_tfault_callback,
+		NULL, false);
+	mtk_iommu_register_fault_callback(M4U_PORT_L11_IMG_WPE_EIS_CQ1_A,
+		(mtk_iommu_fault_callback_t)imgsys_wpe_tfault_callback,
+		NULL, false);
+	//wpe_tnr
+	mtk_iommu_register_fault_callback(M4U_PORT_L11_IMG_WPE_TNR_RDMA0_A,
+		(mtk_iommu_fault_callback_t)imgsys_wpe_tfault_callback,
+		NULL, false);
+	mtk_iommu_register_fault_callback(M4U_PORT_L11_IMG_WPE_TNR_RDMA1_A,
+		(mtk_iommu_fault_callback_t)imgsys_wpe_tfault_callback,
+		NULL, false);
+	mtk_iommu_register_fault_callback(M4U_PORT_L11_IMG_WPE_TNR_WDMA0_A,
+		(mtk_iommu_fault_callback_t)imgsys_wpe_tfault_callback,
+		NULL, false);
+	mtk_iommu_register_fault_callback(M4U_PORT_L11_IMG_WPE_TNR_CQ0_A,
+		(mtk_iommu_fault_callback_t)imgsys_wpe_tfault_callback,
+		NULL, false);
+	mtk_iommu_register_fault_callback(M4U_PORT_L11_IMG_WPE_TNR_CQ1_A,
+		(mtk_iommu_fault_callback_t)imgsys_wpe_tfault_callback,
+		NULL, false);
+#endif
+
+	dev_dbg(imgsys_dev->dev, "%s: -\n", __func__);
+}
+EXPORT_SYMBOL(imgsys_wpe_set_initial_value);
+
+void imgsys_wpe_set_hw_initial_value(struct mtk_imgsys_dev *imgsys_dev)
+{
+	void __iomem *ofset = NULL;
+	unsigned int i = 0;
+	unsigned int hw_idx = 0, ary_idx = 0;
+
+	dev_dbg(imgsys_dev->dev, "%s: +\n", __func__);
+
+	for (hw_idx = REG_MAP_E_WPE_EIS; hw_idx <= REG_MAP_E_WPE_TNR; hw_idx++) {
+		/* iomap registers */
+		ary_idx = hw_idx - REG_MAP_E_WPE_EIS;
+		for (i = 0 ; i < WPE_INIT_ARRAY_COUNT ; i++) {
+			ofset = gWpeRegBA[ary_idx] + mtk_imgsys_wpe_init_ary[i].ofset;
+			writel(mtk_imgsys_wpe_init_ary[i].val, ofset);
+		}
+	}
+
+	dev_dbg(imgsys_dev->dev, "%s: -\n", __func__);
+}
+EXPORT_SYMBOL(imgsys_wpe_set_hw_initial_value);
+
+static void imgsys_wpe_debug_dl_dump(struct mtk_imgsys_dev *imgsys_dev,
+							void __iomem *wpeRegBA)
+{
+	unsigned int dbg_sel_value[3] = {0x0, 0x0, 0x0};
+	unsigned int debug_value[3] = {0x0, 0x0, 0x0};
+	unsigned int sel_value[3] = {0x0, 0x0, 0x0};
+
+	dbg_sel_value[0] = (0xC << 12); //pqdip
+	dbg_sel_value[1] = (0xD << 12); //DIP
+	dbg_sel_value[2] = (0xE << 12); //TRAW
+
+	//line & pix cnt
+	writel((dbg_sel_value[0] | (0x1 << 8)), (wpeRegBA + WPE_REG_DBG_SET));
+	sel_value[0] = (unsigned int)ioread32((void *)(wpeRegBA + WPE_REG_DBG_SET));
+	debug_value[0] = (unsigned int)ioread32((void *)(wpeRegBA + WPE_REG_DBG_PORT));
+
+	writel((dbg_sel_value[1] | (0x1 << 8)), (wpeRegBA + WPE_REG_DBG_SET));
+	sel_value[1] = (unsigned int)ioread32((void *)(wpeRegBA + WPE_REG_DBG_SET));
+	debug_value[1] = (unsigned int)ioread32((void *)(wpeRegBA + WPE_REG_DBG_PORT));
+
+	writel((dbg_sel_value[2] | (0x1 << 8)), (wpeRegBA + WPE_REG_DBG_SET));
+	sel_value[2] = (unsigned int)ioread32((void *)(wpeRegBA + WPE_REG_DBG_SET));
+	debug_value[2] = (unsigned int)ioread32((void *)(wpeRegBA + WPE_REG_DBG_PORT));
+
+	dev_info(imgsys_dev->dev,
+	  "%s: [0x%x]dbg_sel,[0x%x](31:16)LnCnt(15:0)PixCnt: PQDIP[0x%x]0x%x, DIP[0x%x]0x%x, TRAW[0x%x]0x%x",
+	  __func__, WPE_REG_DBG_SET, WPE_REG_DBG_PORT,
+	  sel_value[0], debug_value[0], sel_value[1], debug_value[1],
+	  sel_value[2], debug_value[2]);
+
+	//req/rdy status (output)
+	writel((dbg_sel_value[0] | (0x0 << 8)), (wpeRegBA + WPE_REG_DBG_SET));
+	sel_value[0] = (unsigned int)ioread32((void *)(wpeRegBA + WPE_REG_DBG_SET));
+	debug_value[0] = (unsigned int)ioread32((void *)(wpeRegBA + WPE_REG_DBG_PORT));
+
+	writel((dbg_sel_value[1] | (0x0 << 8)), (wpeRegBA + WPE_REG_DBG_SET));
+	sel_value[1] = (unsigned int)ioread32((void *)(wpeRegBA + WPE_REG_DBG_SET));
+	debug_value[1] = (unsigned int)ioread32((void *)(wpeRegBA + WPE_REG_DBG_PORT));
+
+	writel((dbg_sel_value[2] | (0x0 << 8)), (wpeRegBA + WPE_REG_DBG_SET));
+	sel_value[2] = (unsigned int)ioread32((void *)(wpeRegBA + WPE_REG_DBG_SET));
+	debug_value[2] = (unsigned int)ioread32((void *)(wpeRegBA + WPE_REG_DBG_PORT));
+
+	dev_info(imgsys_dev->dev,
+	  "%s: [0x%x]dbg_sel,[0x%x]val/REQ/RDY: PQDIP[0x%x]0x%x/%d/%d, DIP[0x%x]0x%x/%d/%d, TRAW[0x%x]0x%x/%d/%d",
+	  __func__, WPE_REG_DBG_SET, WPE_REG_DBG_PORT,
+	  sel_value[0], debug_value[0],
+	   ((debug_value[0] >> 24) & 0x1), ((debug_value[0] >> 23) & 0x1),
+	  sel_value[1], debug_value[1],
+	   ((debug_value[1] >> 24) & 0x1), ((debug_value[1] >> 23) & 0x1),
+	  sel_value[2], debug_value[2],
+	   ((debug_value[2] >> 24) & 0x1), ((debug_value[2] >> 23) & 0x1));
+}
+
+static void imgsys_wpe_debug_cq_dump(struct mtk_imgsys_dev *imgsys_dev,
+							void __iomem *wpeRegBA)
+{
+	unsigned int dbg_sel_value = 0x0;
+	unsigned int debug_value[5] = {0x0};
+	unsigned int sel_value[5] = {0x0};
+
+	debug_value[0] = (unsigned int)ioread32((void *)(wpeRegBA + WPE_REG_CQ_THR0_CTL));
+	debug_value[1] = (unsigned int)ioread32((void *)(wpeRegBA + WPE_REG_CQ_THR1_CTL));
+	if (!debug_value[0] || !debug_value[1]) {
+		dev_info(imgsys_dev->dev, "%s: No cq_thr enabled! cq0:0x%x, cq1:0x%x",
+			__func__, debug_value[0], debug_value[1]);
+		return;
+	}
+
+	dbg_sel_value = (0x18 << 12);//cq_p2_eng
+
+	//line & pix cnt
+	writel((dbg_sel_value | 0x0), (wpeRegBA + WPE_REG_DBG_SET));
+	sel_value[0] = (unsigned int)ioread32((void *)(wpeRegBA + WPE_REG_DBG_SET));
+	debug_value[0] = (unsigned int)ioread32((void *)(wpeRegBA + WPE_REG_DBG_PORT));
+
+	writel((dbg_sel_value | 0x1), (wpeRegBA + WPE_REG_DBG_SET));
+	sel_value[1] = (unsigned int)ioread32((void *)(wpeRegBA + WPE_REG_DBG_SET));
+	debug_value[1] = (unsigned int)ioread32((void *)(wpeRegBA + WPE_REG_DBG_PORT));
+
+	writel((dbg_sel_value | 0x2), (wpeRegBA + WPE_REG_DBG_SET));
+	sel_value[2] = (unsigned int)ioread32((void *)(wpeRegBA + WPE_REG_DBG_SET));
+	debug_value[2] = (unsigned int)ioread32((void *)(wpeRegBA + WPE_REG_DBG_PORT));
+
+	writel((dbg_sel_value | 0x3), (wpeRegBA + WPE_REG_DBG_SET));
+	sel_value[3] = (unsigned int)ioread32((void *)(wpeRegBA + WPE_REG_DBG_SET));
+	debug_value[3] = (unsigned int)ioread32((void *)(wpeRegBA + WPE_REG_DBG_PORT));
+
+	writel((dbg_sel_value | 0x4), (wpeRegBA + WPE_REG_DBG_SET));
+	sel_value[4] = (unsigned int)ioread32((void *)(wpeRegBA + WPE_REG_DBG_SET));
+	debug_value[4] = (unsigned int)ioread32((void *)(wpeRegBA + WPE_REG_DBG_PORT));
+
+	dev_info(imgsys_dev->dev,
+		"%s: [0x%x]dbg_sel,[0x%x]cq_st[0x%x]0x%x, dma_dbg[0x%x]0x%x, dma_req[0x%x]0x%x, dma_rdy[0x%x]0x%x, dma_valid[0x%x]0x%x",
+		__func__, WPE_REG_DBG_SET, WPE_REG_DBG_PORT,
+		sel_value[0], debug_value[0], sel_value[1], debug_value[1],
+		sel_value[2], debug_value[2], sel_value[3], debug_value[3],
+		sel_value[4], debug_value[4]);
+}
+
+
+void imgsys_wpe_debug_dump(struct mtk_imgsys_dev *imgsys_dev,
+							unsigned int engine)
+{
+	void __iomem *wpeRegBA = 0L;
+	unsigned int i, j, ctl_en;
+	unsigned int hw_idx = 0, ofst_idx;
+	unsigned int wpeBase = 0;
+	unsigned int startHw = REG_MAP_E_WPE_EIS, endHW = REG_MAP_E_WPE_TNR;
+
+	dev_dbg(imgsys_dev->dev, "%s: +\n", __func__);
+
+	if ((engine & IMGSYS_ENG_WPE_EIS) && !(engine & IMGSYS_ENG_WPE_TNR))
+		endHW = REG_MAP_E_WPE_EIS;
+
+	if (!(engine & IMGSYS_ENG_WPE_EIS) && (engine & IMGSYS_ENG_WPE_TNR))
+		startHw = REG_MAP_E_WPE_TNR;
+
+	/* iomap registers */
+	for (hw_idx = startHw; hw_idx <= endHW; hw_idx++) {
+		ofst_idx = hw_idx - REG_MAP_E_WPE_EIS;
+		if (ofst_idx >= WPE_HW_NUM)
+			continue;
+
+		wpeBase = WPE_A_BASE + mtk_imgsys_wpe_base_ofst[ofst_idx];
+		wpeRegBA = gWpeRegBA[ofst_idx];
+		if (!wpeRegBA) {
+			dev_info(imgsys_dev->dev, "%s: WPE_%d, RegBA = 0", __func__, ofst_idx);
+			continue;
+		}
+		dev_info(imgsys_dev->dev, "%s: ==== Dump WPE_%d =====",
+		  __func__, ofst_idx);
+
+		//DL
+		ctl_en = (unsigned int)ioread32((void *)(wpeRegBA + 0x4));
+		if (ctl_en & (PQDIP_DL|DIP_DL|TRAW_DL)) {
+			dev_info(imgsys_dev->dev, "%s: WPE Done: %d", __func__,
+			  !(ioread32((void *)(wpeRegBA))) &&
+			  (ioread32((void *)(wpeRegBA + 0x24)) & 0x1));
+			dev_info(imgsys_dev->dev,
+			  "%s: WPE_DL: PQDIP(%d), DIP(%d), TRAW(%d)", __func__,
+			  (ctl_en & PQDIP_DL) > 0, (ctl_en & DIP_DL) > 0, (ctl_en & TRAW_DL) > 0);
+			imgsys_wpe_debug_dl_dump(imgsys_dev, wpeRegBA);
+		}
+
+		imgsys_wpe_debug_cq_dump(imgsys_dev, wpeRegBA);
+
+		//
+		for (j = 0; j < WPE_REG_ARRAY_COUNT; j++) {
+			for (i = wpe_regs[j].str; i <= wpe_regs[j].end; i += 0x10) {
+				dev_info(imgsys_dev->dev,
+					"%s: [0x%08X] 0x%08X 0x%08X 0x%08X 0x%08X", __func__,
+				(unsigned int)(wpeBase + i),
+				(unsigned int)ioread32((void *)(wpeRegBA + i)),
+				(unsigned int)ioread32((void *)(wpeRegBA + i + 0x4)),
+				(unsigned int)ioread32((void *)(wpeRegBA + i + 0x8)),
+				(unsigned int)ioread32((void *)(wpeRegBA + i + 0xC)));
+			}
+		}
+
+	}
+	//
+	dev_dbg(imgsys_dev->dev, "%s: -\n", __func__);
+}
+EXPORT_SYMBOL(imgsys_wpe_debug_dump);
+
+void imgsys_wpe_uninit(struct mtk_imgsys_dev *imgsys_dev)
+{
+	unsigned int i;
+
+	pr_debug("%s: +\n", __func__);
+
+	for (i = 0; i < WPE_HW_NUM; i++) {
+		iounmap(gWpeRegBA[i]);
+		gWpeRegBA[i] = 0L;
+	}
+
+	pr_debug("%s: -\n", __func__);
+}
+EXPORT_SYMBOL(imgsys_wpe_uninit);
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_70/modules/mtk_imgsys-wpe.h b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_70/modules/mtk_imgsys-wpe.h
new file mode 100644
index 0000000000000000000000000000000000000000..25f28477d29ca9bc59a7d01651dd075aa9de7635
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_70/modules/mtk_imgsys-wpe.h
@@ -0,0 +1,21 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2021 MediaTek Inc.
+ *
+ * Author: Floria Huang <floria.huang@mediatek.com>
+ *
+ */
+
+#ifndef _MTK_IMGSYS_WPE_H_
+#define _MTK_IMGSYS_WPE_H_
+
+#include "mtk_imgsys-dev.h"
+#include "mtk_imgsys-cmdq.h"
+#include "mtk_imgsys-engine.h"
+
+void imgsys_wpe_set_initial_value(struct mtk_imgsys_dev *imgsys_dev);
+void imgsys_wpe_set_hw_initial_value(struct mtk_imgsys_dev *imgsys_dev);
+void imgsys_wpe_debug_dump(struct mtk_imgsys_dev *imgsys_dev,
+							unsigned int engine);
+void imgsys_wpe_uninit(struct mtk_imgsys_dev *imgsys_dev);
+#endif /* _MTK_IMGSYS_WPE_H_ */
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_70/modules/mtk_me_v4l2_vnode.h b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_70/modules/mtk_me_v4l2_vnode.h
new file mode 100644
index 0000000000000000000000000000000000000000..380667b01a3e765cf1f791cfa4bad4a3c97b5cba
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_70/modules/mtk_me_v4l2_vnode.h
@@ -0,0 +1,453 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2021 MediaTek Inc.
+ *
+ * Author: Frederic Chen <frederic.chen@mediatek.com>
+ *
+ */
+
+#ifndef _MTK_ME_V4L2_VNODE_H_
+#define _MTK_ME_V4L2_VNODE_H_
+
+/*#include <linux/platform_device.h>
+ * #include <linux/module.h>
+ * #include <linux/of_device.h>
+ * #include <linux/pm_runtime.h>
+ * #include <linux/remoteproc.h>
+ * #include <linux/remoteproc/mtk_scp.h>
+ */
+#include <linux/videodev2.h>
+#include <media/videobuf2-dma-contig.h>
+#include <media/v4l2-ioctl.h>
+#include <media/v4l2-subdev.h>
+#include <media/v4l2-event.h>
+#include "mtk_imgsys-dev.h"
+#include "mtk_imgsys-hw.h"
+
+#include "mtk_imgsys_v4l2.h"
+#include "mtk_header_desc.h"
+
+#define defaultdesc 0
+
+
+static const struct mtk_imgsys_dev_format in_fmts[] = {
+	{
+		.format = V4L2_META_FMT_MTISP_DESC,
+		.num_planes = 1,
+#if defaultdesc
+		.depth	 = { 8 },
+		.row_depth = { 8 },
+		.num_cplanes = 1,
+#endif
+		.buffer_size = sizeof(struct header_desc),
+	},
+	{
+		.format = V4L2_META_FMT_MTISP_DESC_NORM,
+		.num_planes = 1,
+		.buffer_size = sizeof(struct header_desc_norm),
+	},
+};
+
+static const struct mtk_imgsys_dev_format out_fmts[] = {
+	{
+		.format = V4L2_META_FMT_MTISP_DESC,
+		.num_planes = 1,
+#if defaultdesc
+		.depth = { 8 },
+		.row_depth = { 8 },
+		.num_cplanes = 1,
+#endif
+		.buffer_size = sizeof(struct header_desc),
+	},
+	{
+		.format = V4L2_META_FMT_MTISP_DESC_NORM,
+		.num_planes = 1,
+		.buffer_size = sizeof(struct header_desc_norm),
+	},
+
+};
+
+static const struct v4l2_frmsizeenum in_frmsizeenum = {
+	.type = V4L2_FRMSIZE_TYPE_CONTINUOUS,
+	.stepwise.max_width = MTK_DIP_CAPTURE_MAX_WIDTH,
+	.stepwise.min_width = MTK_DIP_CAPTURE_MIN_WIDTH,
+	.stepwise.max_height = MTK_DIP_CAPTURE_MAX_HEIGHT,
+	.stepwise.min_height = MTK_DIP_CAPTURE_MIN_HEIGHT,
+	.stepwise.step_height = 1,
+	.stepwise.step_width = 1,
+};
+
+static const struct v4l2_frmsizeenum out_frmsizeenum = {
+	.type = V4L2_FRMSIZE_TYPE_CONTINUOUS,
+	.stepwise.max_width = MTK_DIP_OUTPUT_MAX_WIDTH,
+	.stepwise.min_width = MTK_DIP_OUTPUT_MIN_WIDTH,
+	.stepwise.max_height = MTK_DIP_OUTPUT_MAX_HEIGHT,
+	.stepwise.min_height = MTK_DIP_OUTPUT_MIN_HEIGHT,
+	.stepwise.step_height = 1,
+	.stepwise.step_width = 1,
+};
+
+static const struct mtk_imgsys_video_device_desc me_setting[] = {
+	{
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_MEL0IMG0_OUT,
+		.name = "L0I0I Input",
+		.cap = V4L2_CAP_VIDEO_OUTPUT_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = in_fmts,
+		.num_fmts = ARRAY_SIZE(in_fmts),
+		.default_fmt_idx = 0,
+		.default_width = MTK_DIP_OUTPUT_MAX_WIDTH,
+		.default_height = MTK_DIP_OUTPUT_MAX_HEIGHT,
+		.dma_port = 0,
+		.frmsizeenum = &in_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_out_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "ME Input",
+	},
+	{
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_MEL0IMG1_OUT,
+		.name = "L0I1I Input",
+		.cap = V4L2_CAP_VIDEO_OUTPUT_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = in_fmts,
+		.num_fmts = ARRAY_SIZE(in_fmts),
+		.default_fmt_idx = 0,
+		.default_width = MTK_DIP_OUTPUT_MAX_WIDTH,
+		.default_height = MTK_DIP_OUTPUT_MAX_HEIGHT,
+		.dma_port = 0,
+		.frmsizeenum = &in_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_out_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "ME Input",
+	},
+	{
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_MEL1IMG0_OUT,
+		.name = "L1I0I Input",
+		.cap = V4L2_CAP_VIDEO_OUTPUT_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = in_fmts,
+		.num_fmts = ARRAY_SIZE(in_fmts),
+		.default_fmt_idx = 0,
+		.default_width = MTK_DIP_OUTPUT_MAX_WIDTH,
+		.default_height = MTK_DIP_OUTPUT_MAX_HEIGHT,
+		.dma_port = 0,
+		.frmsizeenum = &in_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_out_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "ME L1 Input ",
+	},
+	{
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_MEL1IMG1_OUT,
+		.name = "L1I1I Input",
+		.cap = V4L2_CAP_VIDEO_OUTPUT_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = in_fmts,
+		.num_fmts = ARRAY_SIZE(in_fmts),
+		.default_fmt_idx = 0,
+		.default_width = MTK_DIP_OUTPUT_MAX_WIDTH,
+		.default_height = MTK_DIP_OUTPUT_MAX_HEIGHT,
+		.dma_port = 0,
+		.frmsizeenum = &in_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_out_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "ME L1 Input ",
+	},
+	{
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_MEIMGSTATS_OUT,
+		.name = "STATI Input",
+		.cap = V4L2_CAP_VIDEO_OUTPUT_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = in_fmts,
+		.num_fmts = ARRAY_SIZE(in_fmts),
+		.default_fmt_idx = 0,
+		.default_width = MTK_DIP_OUTPUT_MAX_WIDTH,
+		.default_height = MTK_DIP_OUTPUT_MAX_HEIGHT,
+		.dma_port = 0,
+		.frmsizeenum = &in_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_out_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "ME IMGSTATS Input ",
+	},
+	{
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_MEL0RMV_OUT,
+		.name = "L0RMVI Input",
+		.cap = V4L2_CAP_VIDEO_OUTPUT_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = in_fmts,
+		.num_fmts = ARRAY_SIZE(in_fmts),
+		.default_fmt_idx = 0,
+		.default_width = MTK_DIP_OUTPUT_MAX_WIDTH,
+		.default_height = MTK_DIP_OUTPUT_MAX_HEIGHT,
+		.dma_port = 0,
+		.frmsizeenum = &in_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_out_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "ME L0RMV Input ",
+	},
+	{
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_MEL1RMV_OUT,
+		.name = "L1RMVI Input",
+		.cap = V4L2_CAP_VIDEO_OUTPUT_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = in_fmts,
+		.num_fmts = ARRAY_SIZE(in_fmts),
+		.default_fmt_idx = 0,
+		.default_width = MTK_DIP_OUTPUT_MAX_WIDTH,
+		.default_height = MTK_DIP_OUTPUT_MAX_HEIGHT,
+		.dma_port = 0,
+		.frmsizeenum = &in_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_out_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "ME L1RMV Input ",
+	},
+	{
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_MEL0FMB_OUT,
+		.name = "L0FMBI Input",
+		.cap = V4L2_CAP_VIDEO_OUTPUT_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = in_fmts,
+		.num_fmts = ARRAY_SIZE(in_fmts),
+		.default_fmt_idx = 0,
+		.default_width = MTK_DIP_OUTPUT_MAX_WIDTH,
+		.default_height = MTK_DIP_OUTPUT_MAX_HEIGHT,
+		.dma_port = 0,
+		.frmsizeenum = &in_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_out_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "ME L0FMB Input ",
+	},
+	{
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_MEL1FMB_OUT,
+		.name = "L1FMBI Input",
+		.cap = V4L2_CAP_VIDEO_OUTPUT_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = in_fmts,
+		.num_fmts = ARRAY_SIZE(in_fmts),
+		.default_fmt_idx = 0,
+		.default_width = MTK_DIP_OUTPUT_MAX_WIDTH,
+		.default_height = MTK_DIP_OUTPUT_MAX_HEIGHT,
+		.dma_port = 0,
+		.frmsizeenum = &in_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_out_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "ME L1FMB Input ",
+	},
+	{
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_MEMIL_OUT,
+		.name = "MEMILI Input",
+		.cap = V4L2_CAP_VIDEO_OUTPUT_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = in_fmts,
+		.num_fmts = ARRAY_SIZE(in_fmts),
+		.default_fmt_idx = 0,
+		.default_width = MTK_DIP_OUTPUT_MAX_WIDTH,
+		.default_height = MTK_DIP_OUTPUT_MAX_HEIGHT,
+		.dma_port = 0,
+		.frmsizeenum = &in_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_out_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "ME MIL Input ",
+	},
+	{
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_MEMMGMIL_CAPTURE,
+		.name = "MILO Output",
+		.cap = V4L2_CAP_VIDEO_CAPTURE_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = out_fmts,
+		.num_fmts = ARRAY_SIZE(out_fmts),
+		.default_fmt_idx = 0,
+		.default_width = MTK_DIP_OUTPUT_MAX_WIDTH,
+		.default_height = MTK_DIP_OUTPUT_MAX_HEIGHT,
+		.dma_port = 0,
+		.frmsizeenum = &out_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_cap_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "ME MMGMIL Output ",
+	},
+	{
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_MEL0WMV_CAPTURE,
+		.name = "L0WMVO Output",
+		.cap = V4L2_CAP_VIDEO_CAPTURE_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = out_fmts,
+		.num_fmts = ARRAY_SIZE(out_fmts),
+		.default_fmt_idx = 0,
+		.default_width = MTK_DIP_OUTPUT_MAX_WIDTH,
+		.default_height = MTK_DIP_OUTPUT_MAX_HEIGHT,
+		.dma_port = 0,
+		.frmsizeenum = &out_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_cap_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "ME L0WMV Output ",
+	},
+	{
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_MEL1WMV_CAPTURE,
+		.name = "L1WMVO Output",
+		.cap = V4L2_CAP_VIDEO_CAPTURE_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = out_fmts,
+		.num_fmts = ARRAY_SIZE(out_fmts),
+		.default_fmt_idx = 0,
+		.default_width = MTK_DIP_OUTPUT_MAX_WIDTH,
+		.default_height = MTK_DIP_OUTPUT_MAX_HEIGHT,
+		.dma_port = 0,
+		.frmsizeenum = &out_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_cap_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "ME L1WMV Output ",
+	},
+	{
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_MECONF_CAPTURE,
+		.name = "CONFO Output",
+		.cap = V4L2_CAP_VIDEO_CAPTURE_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = out_fmts,
+		.num_fmts = ARRAY_SIZE(out_fmts),
+		.default_fmt_idx = 0,
+		.default_width = MTK_DIP_OUTPUT_MAX_WIDTH,
+		.default_height = MTK_DIP_OUTPUT_MAX_HEIGHT,
+		.dma_port = 0,
+		.frmsizeenum = &out_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_cap_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "ME CONF Output ",
+	},
+	{
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_MEWMAP_CAPTURE,
+		.name = "WMAPO Output",
+		.cap = V4L2_CAP_VIDEO_CAPTURE_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = out_fmts,
+		.num_fmts = ARRAY_SIZE(out_fmts),
+		.default_fmt_idx = 0,
+		.default_width = MTK_DIP_OUTPUT_MAX_WIDTH,
+		.default_height = MTK_DIP_OUTPUT_MAX_HEIGHT,
+		.dma_port = 0,
+		.frmsizeenum = &out_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_cap_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "ME WMAP Output ",
+	},
+	{
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_MEFMV_CAPTURE,
+		.name = "FMVO Output",
+		.cap = V4L2_CAP_VIDEO_CAPTURE_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = out_fmts,
+		.num_fmts = ARRAY_SIZE(out_fmts),
+		.default_fmt_idx = 0,
+		.default_width = MTK_DIP_OUTPUT_MAX_WIDTH,
+		.default_height = MTK_DIP_OUTPUT_MAX_HEIGHT,
+		.dma_port = 0,
+		.frmsizeenum = &out_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_cap_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "ME OTHERS Output ",
+	},
+	{
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_MEFST_CAPTURE,
+		.name = "FSTO Output",
+		.cap = V4L2_CAP_VIDEO_CAPTURE_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = out_fmts,
+		.num_fmts = ARRAY_SIZE(out_fmts),
+		.default_fmt_idx = 0,
+		.default_width = MTK_DIP_OUTPUT_MAX_WIDTH,
+		.default_height = MTK_DIP_OUTPUT_MAX_HEIGHT,
+		.dma_port = 0,
+		.frmsizeenum = &out_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_cap_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "ME FST Output ",
+	},
+	{
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_MELMI_CAPTURE,
+		.name = "LMIO Output",
+		.cap = V4L2_CAP_VIDEO_CAPTURE_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = out_fmts,
+		.num_fmts = ARRAY_SIZE(out_fmts),
+		.default_fmt_idx = 0,
+		.default_width = MTK_DIP_OUTPUT_MAX_WIDTH,
+		.default_height = MTK_DIP_OUTPUT_MAX_HEIGHT,
+		.dma_port = 0,
+		.frmsizeenum = &out_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_cap_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "ME LMI Output ",
+	},
+	{
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_MEL0WFMB_CAPTURE,
+		.name = "L0FMBO Output",
+		.cap = V4L2_CAP_VIDEO_CAPTURE_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = out_fmts,
+		.num_fmts = ARRAY_SIZE(out_fmts),
+		.default_fmt_idx = 0,
+		.default_width = MTK_DIP_OUTPUT_MAX_WIDTH,
+		.default_height = MTK_DIP_OUTPUT_MAX_HEIGHT,
+		.dma_port = 0,
+		.frmsizeenum = &out_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_cap_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "ME L0FMB Output ",
+	},
+	{
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_MEL1WFMB_CAPTURE,
+		.name = "L1FMBO Output",
+		.cap = V4L2_CAP_VIDEO_CAPTURE_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = out_fmts,
+		.num_fmts = ARRAY_SIZE(out_fmts),
+		.default_fmt_idx = 0,
+		.default_width = MTK_DIP_OUTPUT_MAX_WIDTH,
+		.default_height = MTK_DIP_OUTPUT_MAX_HEIGHT,
+		.dma_port = 0,
+		.frmsizeenum = &out_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_cap_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "ME L1FMB Output ",
+	},
+};
+
+#endif // _MTK_ME_V4L2_VNODE_H_
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_70/modules/mtk_pqdip_v4l2_vnode.h b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_70/modules/mtk_pqdip_v4l2_vnode.h
new file mode 100644
index 0000000000000000000000000000000000000000..089c7f9b77b6149bf494af28ea41c408badd4d09
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_70/modules/mtk_pqdip_v4l2_vnode.h
@@ -0,0 +1,274 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2021 MediaTek Inc.
+ *
+ * Author: Daniel Huang <daniel.huang@mediatek.com>
+ *
+ */
+
+#ifndef _MTK_PQDIP_V4L2_VNODE_H_
+#define _MTK_PQDIP_V4L2_VNODE_H_
+
+#include <linux/videodev2.h>
+#include <media/videobuf2-dma-contig.h>
+#include <media/v4l2-ioctl.h>
+#include <media/v4l2-subdev.h>
+#include <media/v4l2-event.h>
+#include "mtk_imgsys-dev.h"
+#include "mtk_imgsys-hw.h"
+
+#include "mtk_imgsys_v4l2.h"
+#include "mtk_header_desc.h"
+
+#define defaultdesc 0
+
+#define MTK_PQDIP_OUTPUT_MIN_WIDTH		2U
+#define MTK_PQDIP_OUTPUT_MIN_HEIGHT		2U
+#define MTK_PQDIP_OUTPUT_MAX_WIDTH		5376U
+#define MTK_PQDIP_OUTPUT_MAX_HEIGHT		4032U
+#define MTK_PQDIP_CAPTURE_MIN_WIDTH		2U
+#define MTK_PQDIP_CAPTURE_MIN_HEIGHT		2U
+#define MTK_PQDIP_CAPTURE_MAX_WIDTH		5376U
+#define MTK_PQDIP_CAPTURE_MAX_HEIGHT		4032U
+
+static const struct mtk_imgsys_dev_format pqdip_pimgi_fmts[] = {
+	{
+		.format = V4L2_PIX_FMT_VYUY,
+		.depth	 = { 16 },
+		.row_depth = { 16 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+	},
+	{
+		.format = V4L2_PIX_FMT_YUYV,
+		.depth	 = { 16 },
+		.row_depth = { 16 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+	},
+	{
+		.format = V4L2_PIX_FMT_YVYU,
+		.depth	 = { 16 },
+		.row_depth = { 16 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+	},
+	{
+		.format = V4L2_PIX_FMT_NV12,
+		.depth = { 12 },
+		.row_depth = { 8 },
+		.num_planes = 1,
+		.num_cplanes = 2,
+	},
+	{
+		.format	= V4L2_PIX_FMT_YUV420M,
+		.depth		= { 8, 2, 2 },
+		.row_depth	= { 8, 4, 4 },
+		.num_planes	= 3,
+		.num_cplanes = 1,
+	},
+	{
+		.format	= V4L2_PIX_FMT_YVU420M,
+		.depth		= { 8, 2, 2 },
+		.row_depth	= { 8, 4, 4 },
+		.num_planes	= 3,
+		.num_cplanes = 1,
+	},
+	{
+		.format	= V4L2_PIX_FMT_NV12M,
+		.depth		= { 8, 4 },
+		.row_depth	= { 8, 8 },
+		.num_planes	= 2,
+		.num_cplanes = 1,
+	},
+	{	// Must have for SMVR/Multis-cale for every video_device nodes
+		.format = V4L2_META_FMT_MTISP_DESC,
+		.num_planes = 1,
+#if defaultdesc
+		.depth = { 8 },
+		.row_depth = { 8 },
+		.num_cplanes = 1,
+#endif
+		.buffer_size = sizeof(struct header_desc),
+	},
+	{
+		.format = V4L2_META_FMT_MTISP_SD,
+		.num_planes = 1,
+#if defaultdesc
+		.depth = { 8 },
+		.row_depth = { 8 },
+		.num_cplanes = 1,
+#endif
+		.buffer_size = sizeof(struct singlenode_desc),
+	},
+	{
+		.format = V4L2_META_FMT_MTISP_DESC_NORM,
+		.num_planes = 1,
+		.buffer_size = sizeof(struct header_desc_norm),
+	},
+
+};
+
+static const struct mtk_imgsys_dev_format pqdip_wroto_fmts[] = {
+	{
+		.format = V4L2_PIX_FMT_VYUY,
+		.depth = { 16 },
+		.row_depth = { 16 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+		.pass_1_align = 4,
+	},
+	{
+		.format = V4L2_PIX_FMT_YUYV,
+		.depth = { 16 },
+		.row_depth = { 16 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+		.pass_1_align = 4,
+	},
+	{
+		.format = V4L2_PIX_FMT_YVYU,
+		.depth = { 16 },
+		.row_depth = { 16 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+		.pass_1_align = 4,
+	},
+	{
+		.format = V4L2_PIX_FMT_YVU420,
+		.depth = { 12 },
+		.row_depth = { 8 },
+		.num_planes = 1,
+		.num_cplanes = 3,
+		.pass_1_align = 4,
+	},
+	{
+		.format = V4L2_PIX_FMT_NV12,
+		.depth = { 12 },
+		.row_depth = { 8 },
+		.num_planes = 1,
+		.num_cplanes = 2,
+		.pass_1_align = 4,
+	},
+	{
+		.format	= V4L2_PIX_FMT_YUV420M,
+		.depth		= { 8, 2, 2 },
+		.row_depth	= { 8, 4, 4 },
+		.num_planes	= 3,
+		.num_cplanes = 1,
+		.pass_1_align = 4,
+	},
+	{
+		.format	= V4L2_PIX_FMT_YVU420M,
+		.depth		= { 8, 2, 2 },
+		.row_depth	= { 8, 4, 4 },
+		.num_planes	= 3,
+		.num_cplanes = 1,
+		.pass_1_align = 4,
+	},
+	{
+		.format	= V4L2_PIX_FMT_NV12M,
+		.depth		= { 8, 4 },
+		.row_depth	= { 8, 8 },
+		.num_planes	= 2,
+		.num_cplanes = 1,
+		.pass_1_align = 4,
+	},
+	{	// Must have for SMVR/Multis-cale for every video_device nodes
+		.format = V4L2_META_FMT_MTISP_DESC,
+		.num_planes = 1,
+#if defaultdesc
+		.depth = { 8 },
+		.row_depth = { 8 },
+		.num_cplanes = 1,
+#endif
+		.buffer_size = sizeof(struct header_desc),
+	},
+	{
+		.format = V4L2_META_FMT_MTISP_DESC_NORM,
+		.num_planes = 1,
+		.buffer_size = sizeof(struct header_desc_norm),
+	},
+
+};
+
+static const struct v4l2_frmsizeenum pqdip_in_frmsizeenum = {
+	.type = V4L2_FRMSIZE_TYPE_CONTINUOUS,
+	.stepwise.max_width = MTK_PQDIP_CAPTURE_MAX_WIDTH,
+	.stepwise.min_width = MTK_PQDIP_CAPTURE_MIN_WIDTH,
+	.stepwise.max_height = MTK_PQDIP_CAPTURE_MAX_HEIGHT,
+	.stepwise.min_height = MTK_PQDIP_CAPTURE_MIN_HEIGHT,
+	.stepwise.step_height = 1,
+	.stepwise.step_width = 1,
+};
+
+static const struct v4l2_frmsizeenum pqdip_out_frmsizeenum = {
+	.type = V4L2_FRMSIZE_TYPE_CONTINUOUS,
+	.stepwise.max_width = MTK_PQDIP_OUTPUT_MAX_WIDTH,
+	.stepwise.min_width = MTK_PQDIP_OUTPUT_MIN_WIDTH,
+	.stepwise.max_height = MTK_PQDIP_OUTPUT_MAX_HEIGHT,
+	.stepwise.min_height = MTK_PQDIP_OUTPUT_MIN_HEIGHT,
+	.stepwise.step_height = 1,
+	.stepwise.step_width = 1,
+};
+
+static const struct mtk_imgsys_video_device_desc pqdip_setting[] = {
+	/* Input Video Node */
+	{
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_PIMGI_OUT,
+		.name = "PIMGI Input",
+		.cap = V4L2_CAP_VIDEO_OUTPUT_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = pqdip_pimgi_fmts,
+		.num_fmts = ARRAY_SIZE(pqdip_pimgi_fmts),
+		.default_fmt_idx = 4,
+		.default_width = MTK_PQDIP_OUTPUT_MAX_WIDTH,
+		.default_height = MTK_PQDIP_OUTPUT_MAX_HEIGHT,
+		.dma_port = 0,
+		.frmsizeenum = &pqdip_in_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_out_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "Imgi image source",
+	},
+	/* Output Video Node */
+	{
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_WROT_A_CAPTURE,
+		.name = "WROTO A Output",
+		.cap = V4L2_CAP_VIDEO_CAPTURE_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = pqdip_wroto_fmts,
+		.num_fmts = ARRAY_SIZE(pqdip_wroto_fmts),
+		.default_fmt_idx = 1,
+		.default_width = MTK_PQDIP_CAPTURE_MAX_WIDTH,
+		.default_height = MTK_PQDIP_CAPTURE_MAX_WIDTH,
+		.dma_port = 0,
+		.frmsizeenum = &pqdip_out_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_cap_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "Output quality enhanced image",
+	},
+	{
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_WROT_B_CAPTURE,
+		.name = "WROTO B Output",
+		.cap = V4L2_CAP_VIDEO_CAPTURE_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = pqdip_wroto_fmts,
+		.num_fmts = ARRAY_SIZE(pqdip_wroto_fmts),
+		.default_fmt_idx = 1,
+		.default_width = MTK_PQDIP_CAPTURE_MAX_WIDTH,
+		.default_height = MTK_PQDIP_CAPTURE_MAX_WIDTH,
+		.dma_port = 1,
+		.frmsizeenum = &pqdip_out_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_cap_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "Output quality enhanced image",
+	},
+};
+
+#endif // _MTK_PQDIP_V4L2_VNODE_H_
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_70/modules/mtk_traw_v4l2_vnode.h b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_70/modules/mtk_traw_v4l2_vnode.h
new file mode 100644
index 0000000000000000000000000000000000000000..b5b04572978be59ee4d8233e740d3b6784d4a656
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_70/modules/mtk_traw_v4l2_vnode.h
@@ -0,0 +1,668 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2021 MediaTek Inc.
+ *
+ * Author: Shih-Fang chuang <shih-fang.chuang@mediatek.com>
+ *
+ */
+
+#ifndef _MTK_TRAW_V4L2_VNODE_H_
+#define _MTK_TRAW_V4L2_VNODE_H_
+
+#include <linux/videodev2.h>
+#include <media/videobuf2-dma-contig.h>
+#include <media/v4l2-ioctl.h>
+#include <media/v4l2-subdev.h>
+#include <media/v4l2-event.h>
+#include "mtk_imgsys-dev.h"
+#include "mtk_imgsys-hw.h"
+
+#include "mtk_imgsys_v4l2.h"
+#include "mtk_header_desc.h"
+
+#define defaultdesc 0
+
+#define MTK_TRAW_OUTPUT_MIN_WIDTH		2U
+#define MTK_TRAW_OUTPUT_MIN_HEIGHT		2U
+#define MTK_TRAW_OUTPUT_MAX_WIDTH		5376U
+#define MTK_TRAW_OUTPUT_MAX_HEIGHT		4032U
+#define MTK_TRAW_CAPTURE_MIN_WIDTH		2U
+#define MTK_TRAW_CAPTURE_MIN_HEIGHT		2U
+#define MTK_TRAW_CAPTURE_MAX_WIDTH		5376U
+#define MTK_TRAW_CAPTURE_MAX_HEIGHT		4032U
+
+static const struct mtk_imgsys_dev_format traw_imgi_fmts[] = {
+	{
+		.format = V4L2_PIX_FMT_VYUY,
+		.depth	 = { 16 },
+		.row_depth = { 16 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+	},
+	{
+		.format = V4L2_PIX_FMT_YUYV,
+		.depth	 = { 16 },
+		.row_depth = { 16 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+	},
+	{
+		.format = V4L2_PIX_FMT_YVYU,
+		.depth	 = { 16 },
+		.row_depth = { 16 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+	},
+	{
+		.format = V4L2_PIX_FMT_NV12,
+		.depth = { 12 },
+		.row_depth = { 8 },
+		.num_planes = 1,
+		.num_cplanes = 2,
+	},
+#ifdef support_rgb8 /* 0 */
+	{
+		.format = V4L2_PIX_FMT_MTISP_SBGGR8,
+		.depth = { 8 },
+		.row_depth = { 8 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+		.pass_1_align = 4,
+	},
+	{
+		.format = V4L2_PIX_FMT_MTISP_SGBRG8,
+		.depth = { 8 },
+		.row_depth = { 8 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+		.pass_1_align = 4,
+	},
+	{
+		.format = V4L2_PIX_FMT_MTISP_SGRBG8,
+		.depth = { 8 },
+		.row_depth = { 8 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+		.pass_1_align = 4,
+	},
+	{
+		.format = V4L2_PIX_FMT_MTISP_SRGGB8,
+		.depth = { 8 },
+		.row_depth = { 8 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+		.pass_1_align = 4,
+	},
+#endif
+	{
+		.format = V4L2_PIX_FMT_MTISP_SBGGR8F,
+		.depth = { 12 },
+		.row_depth = { 8},
+		.num_planes = 1,
+		.num_cplanes = 1,
+		.pass_1_align = 8,
+	},
+	{
+		.format = V4L2_PIX_FMT_MTISP_SGBRG8F,
+		.depth = { 12 },
+		.row_depth = { 8 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+		.pass_1_align = 8,
+	},
+	{
+		.format = V4L2_PIX_FMT_MTISP_SGRBG8F,
+		.depth = { 12 },
+		.row_depth = { 8 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+		.pass_1_align = 8,
+	},
+	{
+		.format = V4L2_PIX_FMT_MTISP_SRGGB8F,
+		.depth = { 12 },
+		.row_depth = { 8 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+		.pass_1_align = 8,
+	},
+	{
+		.format = V4L2_PIX_FMT_MTISP_SBGGR10,
+		.depth = { 10 },
+		.row_depth = { 10 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+		.pass_1_align = 4,
+	},
+	{
+		.format = V4L2_PIX_FMT_MTISP_SGBRG10,
+		.depth = { 10 },
+		.row_depth = { 10 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+		.pass_1_align = 4,
+	},
+	{
+		.format = V4L2_PIX_FMT_MTISP_SGRBG10,
+		.depth = { 10 },
+		.row_depth = { 10 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+		.pass_1_align = 4,
+	},
+	{
+		.format = V4L2_PIX_FMT_MTISP_SRGGB10,
+		.depth = { 10 },
+		.row_depth = { 10 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+		.pass_1_align = 4,
+	},
+	{
+		.format = V4L2_PIX_FMT_MTISP_SBGGR10F,
+		.depth = { 15 },
+		.row_depth = { 10 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+		.pass_1_align = 4,
+	},
+	{
+		.format = V4L2_PIX_FMT_MTISP_SGBRG10F,
+		.depth = { 15 },
+		.row_depth = { 10 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+		.pass_1_align = 4,
+	},
+	{
+		.format = V4L2_PIX_FMT_MTISP_SGRBG10F,
+		.depth = { 15 },
+		.row_depth = { 10 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+		.pass_1_align = 4,
+	},
+	{
+		.format = V4L2_PIX_FMT_MTISP_SRGGB10F,
+		.depth = { 15 },
+		.row_depth = { 10 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+		.pass_1_align = 4,
+	},
+	{
+		.format = V4L2_PIX_FMT_MTISP_SBGGR12,
+		.depth = { 12 },
+		.row_depth = { 12 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+		.pass_1_align = 4,
+	},
+	{
+		.format = V4L2_PIX_FMT_MTISP_SGBRG12,
+		.depth = { 12 },
+		.row_depth = { 12 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+		.pass_1_align = 4,
+	},
+	{
+		.format = V4L2_PIX_FMT_MTISP_SGRBG12,
+		.depth = { 12 },
+		.row_depth = { 12 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+		.pass_1_align = 4,
+	},
+	{
+		.format = V4L2_PIX_FMT_MTISP_SRGGB12,
+		.depth = { 12 },
+		.row_depth = { 12 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+		.pass_1_align = 4,
+	},
+	{
+		.format = V4L2_PIX_FMT_MTISP_SBGGR12F,
+		.depth = { 18 },
+		.row_depth = { 12 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+		.pass_1_align = 8,
+	},
+	{
+		.format = V4L2_PIX_FMT_MTISP_SGBRG12F,
+		.depth = { 18 },
+		.row_depth = { 12 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+		.pass_1_align = 8,
+	},
+	{
+		.format = V4L2_PIX_FMT_MTISP_SGRBG12F,
+		.depth = { 18 },
+		.row_depth = { 12 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+		.pass_1_align = 8,
+	},
+	{
+		.format = V4L2_PIX_FMT_MTISP_SRGGB12F,
+		.depth = { 18 },
+		.row_depth = { 12 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+		.pass_1_align = 8,
+	},
+	{
+		.format = V4L2_PIX_FMT_MTISP_SBGGR14F,
+		.depth = { 21 },
+		.row_depth = { 14 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+		.pass_1_align = 8,
+	},
+	{
+		.format = V4L2_PIX_FMT_MTISP_SGBRG14F,
+		.depth = { 21 },
+		.row_depth = { 14 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+		.pass_1_align = 8,
+	},
+	{
+		.format = V4L2_PIX_FMT_MTISP_SGRBG14F,
+		.depth = { 21 },
+		.row_depth = { 14 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+		.pass_1_align = 8,
+	},
+	{
+		.format = V4L2_PIX_FMT_MTISP_SRGGB14F,
+		.depth = { 21 },
+		.row_depth = { 14 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+		.pass_1_align = 8,
+	},
+	{
+		.format	= V4L2_PIX_FMT_YUV420M,
+		.depth		= { 8, 2, 2 },
+		.row_depth	= { 8, 4, 4 },
+		.num_planes	= 3,
+		.num_cplanes = 1,
+	},
+	{
+		.format	= V4L2_PIX_FMT_YVU420M,
+		.depth		= { 8, 2, 2 },
+		.row_depth	= { 8, 4, 4 },
+		.num_planes	= 3,
+		.num_cplanes = 1,
+	},
+	{
+		.format	= V4L2_PIX_FMT_NV12M,
+		.depth		= { 8, 4 },
+		.row_depth	= { 8, 8 },
+		.num_planes	= 2,
+		.num_cplanes = 1,
+	},
+	{	// Must have for SMVR/Multis-cale for every video_device nodes
+		.format = V4L2_META_FMT_MTISP_DESC,
+		.num_planes = 1,
+#if defaultdesc
+		.depth = { 8 },
+		.row_depth = { 8 },
+		.num_cplanes = 1,
+#endif
+		.buffer_size = sizeof(struct header_desc),
+	},
+	{
+		.format = V4L2_META_FMT_MTISP_SD,
+		.num_planes = 1,
+#if defaultdesc
+		.depth = { 8 },
+		.row_depth = { 8 },
+		.num_cplanes = 1,
+#endif
+		.buffer_size = sizeof(struct singlenode_desc),
+	},
+	{
+		.format = V4L2_META_FMT_MTISP_DESC_NORM,
+		.num_planes = 1,
+		.buffer_size = sizeof(struct header_desc_norm),
+	},
+
+};
+
+static const struct mtk_imgsys_dev_format traw_metai_fmts[] = {
+	{	// Must have for SMVR/Multis-cale for every video_device nodes
+		.format = V4L2_META_FMT_MTISP_DESC,
+		.num_planes = 1,
+#if defaultdesc
+		.depth = { 8 },
+		.row_depth = { 8 },
+		.num_cplanes = 1,
+#endif
+		.buffer_size = sizeof(struct header_desc),
+	},
+	{
+		.format = V4L2_META_FMT_MTISP_DESC_NORM,
+		.num_planes = 1,
+		.buffer_size = sizeof(struct header_desc_norm),
+	},
+
+};
+
+static const struct mtk_imgsys_dev_format traw_yuvo_fmts[] = {
+	{
+		.format = V4L2_PIX_FMT_VYUY,
+		.depth = { 16 },
+		.row_depth = { 16 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+		.pass_1_align = 4,
+	},
+	{
+		.format = V4L2_PIX_FMT_YUYV,
+		.depth = { 16 },
+		.row_depth = { 16 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+		.pass_1_align = 4,
+	},
+	{
+		.format = V4L2_PIX_FMT_YVYU,
+		.depth = { 16 },
+		.row_depth = { 16 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+		.pass_1_align = 4,
+	},
+	{
+		.format = V4L2_PIX_FMT_YVU420,
+		.depth = { 12 },
+		.row_depth = { 8 },
+		.num_planes = 1,
+		.num_cplanes = 3,
+		.pass_1_align = 4,
+	},
+	{
+		.format = V4L2_PIX_FMT_NV12,
+		.depth = { 12 },
+		.row_depth = { 8 },
+		.num_planes = 1,
+		.num_cplanes = 2,
+		.pass_1_align = 4,
+	},
+	{	// Must have for SMVR/Multis-cale for every video_device nodes
+		.format = V4L2_META_FMT_MTISP_DESC,
+		.num_planes = 1,
+#if defaultdesc
+		.depth = { 8 },
+		.row_depth = { 8 },
+		.num_cplanes = 1,
+#endif
+		.buffer_size = sizeof(struct header_desc),
+	},
+	{
+		.format = V4L2_META_FMT_MTISP_DESC_NORM,
+		.num_planes = 1,
+		.buffer_size = sizeof(struct header_desc_norm),
+	},
+
+};
+
+static const struct mtk_imgsys_dev_format traw_pdc_fmts[] = {
+	/* Y8 bit */
+	{
+		.format	= V4L2_PIX_FMT_GREY,
+		.depth		= { 8 },
+		.row_depth	= { 8 },
+		.num_planes	= 1,
+		.num_cplanes = 1,
+	},
+	/* Must have for SMVR/Multis-cale for every video_device nodes */
+	{
+		.format = V4L2_META_FMT_MTISP_DESC,
+		.num_planes = 1,
+#if defaultdesc
+		.depth = { 8 },
+		.row_depth = { 8 },
+		.num_cplanes = 1,
+#endif
+		.buffer_size = sizeof(struct header_desc),
+	},
+	{
+		.format = V4L2_META_FMT_MTISP_DESC_NORM,
+		.num_planes = 1,
+		.buffer_size = sizeof(struct header_desc_norm),
+	},
+
+};
+
+
+static const struct v4l2_frmsizeenum traw_in_frmsizeenum = {
+	.type = V4L2_FRMSIZE_TYPE_CONTINUOUS,
+	.stepwise.max_width = MTK_TRAW_CAPTURE_MAX_WIDTH,
+	.stepwise.min_width = MTK_TRAW_CAPTURE_MIN_WIDTH,
+	.stepwise.max_height = MTK_TRAW_CAPTURE_MAX_HEIGHT,
+	.stepwise.min_height = MTK_TRAW_CAPTURE_MIN_HEIGHT,
+	.stepwise.step_height = 1,
+	.stepwise.step_width = 1,
+};
+
+static const struct v4l2_frmsizeenum traw_out_frmsizeenum = {
+	.type = V4L2_FRMSIZE_TYPE_CONTINUOUS,
+	.stepwise.max_width = MTK_TRAW_OUTPUT_MAX_WIDTH,
+	.stepwise.min_width = MTK_TRAW_OUTPUT_MIN_WIDTH,
+	.stepwise.max_height = MTK_TRAW_OUTPUT_MAX_HEIGHT,
+	.stepwise.min_height = MTK_TRAW_OUTPUT_MIN_HEIGHT,
+	.stepwise.step_height = 1,
+	.stepwise.step_width = 1,
+};
+
+static const struct mtk_imgsys_video_device_desc traw_setting[] = {
+	/* Input Video Node */
+	{
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_TIMGI_OUT,
+		.name = "TIMGI Input",
+		.cap = V4L2_CAP_VIDEO_OUTPUT_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = traw_imgi_fmts,
+		.num_fmts = ARRAY_SIZE(traw_imgi_fmts),
+		.default_fmt_idx = 4,
+		.default_width = MTK_TRAW_OUTPUT_MAX_WIDTH,
+		.default_height = MTK_TRAW_OUTPUT_MAX_HEIGHT,
+		.dma_port = 0,
+		.frmsizeenum = &traw_in_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_out_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "Imgi image source",
+	},
+	{
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_METAI_OUT,
+		.name = "METAI Input",
+		.cap = V4L2_CAP_VIDEO_OUTPUT_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = traw_metai_fmts,
+		.num_fmts = ARRAY_SIZE(traw_metai_fmts),
+		.default_fmt_idx = 1,
+		.default_width = MTK_TRAW_CAPTURE_MAX_WIDTH,
+		.default_height = MTK_TRAW_CAPTURE_MAX_HEIGHT,
+		.dma_port = 1,
+		.frmsizeenum = &traw_in_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_out_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "METAI image source",
+	},
+	{
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_PDC_OUT,
+		.name = "PDC Input",
+		.cap = V4L2_CAP_VIDEO_OUTPUT_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = traw_pdc_fmts,
+		.num_fmts = ARRAY_SIZE(traw_pdc_fmts),
+		.default_fmt_idx = 1,
+		.default_width = MTK_TRAW_CAPTURE_MAX_WIDTH,
+		.default_height = MTK_TRAW_CAPTURE_MAX_HEIGHT,
+		.dma_port = 2,
+		.frmsizeenum = &traw_in_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_out_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "PDC image source",
+	},
+	/* Output Video Node */
+	{
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_TYUVO_CAPTURE,
+		.name = "TYUVO Output",
+		.cap = V4L2_CAP_VIDEO_CAPTURE_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = traw_yuvo_fmts,
+		.num_fmts = ARRAY_SIZE(traw_yuvo_fmts),
+		.default_fmt_idx = 1,
+		.default_width = MTK_TRAW_CAPTURE_MAX_WIDTH,
+		.default_height = MTK_TRAW_CAPTURE_MAX_WIDTH,
+		.dma_port = 0,
+		.frmsizeenum = &traw_out_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_cap_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "YUVO output",
+	},
+	{
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_TYUV2O_CAPTURE,
+		.name = "TYUV2O Output",
+		.cap = V4L2_CAP_VIDEO_CAPTURE_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = traw_yuvo_fmts,
+		.num_fmts = ARRAY_SIZE(traw_yuvo_fmts),
+		.default_fmt_idx = 1,
+		.default_width = MTK_TRAW_CAPTURE_MAX_WIDTH,
+		.default_height = MTK_TRAW_CAPTURE_MAX_WIDTH,
+		.dma_port = 1,
+		.frmsizeenum = &traw_out_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_cap_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "YUV2O output",
+	},
+	{
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_TYUV3O_CAPTURE,
+		.name = "TYUV3O Output",
+		.cap = V4L2_CAP_VIDEO_CAPTURE_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = traw_yuvo_fmts,
+		.num_fmts = ARRAY_SIZE(traw_yuvo_fmts),
+		.default_fmt_idx = 1,
+		.default_width = MTK_TRAW_CAPTURE_MAX_WIDTH,
+		.default_height = MTK_TRAW_CAPTURE_MAX_WIDTH,
+		.dma_port = 2,
+		.frmsizeenum = &traw_out_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_cap_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "YUV3O output",
+	},
+	{
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_TYUV4O_CAPTURE,
+		.name = "TYUV4O Output",
+		.cap = V4L2_CAP_VIDEO_CAPTURE_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = traw_yuvo_fmts,
+		.num_fmts = ARRAY_SIZE(traw_yuvo_fmts),
+		.default_fmt_idx = 1,
+		.default_width = MTK_TRAW_CAPTURE_MAX_WIDTH,
+		.default_height = MTK_TRAW_CAPTURE_MAX_WIDTH,
+		.dma_port = 3,
+		.frmsizeenum = &traw_out_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_cap_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "YUV4O output",
+	},
+	{
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_TYUV5O_CAPTURE,
+		.name = "TYUV5O Output",
+		.cap = V4L2_CAP_VIDEO_CAPTURE_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = traw_yuvo_fmts,
+		.num_fmts = ARRAY_SIZE(traw_yuvo_fmts),
+		.default_fmt_idx = 1,
+		.default_width = MTK_TRAW_CAPTURE_MAX_WIDTH,
+		.default_height = MTK_TRAW_CAPTURE_MAX_WIDTH,
+		.dma_port = 4,
+		.frmsizeenum = &traw_out_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_cap_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "YUV5O output",
+	},
+	{
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_FEO_CAPTURE,
+		.name = "FEO Output",
+		.cap = V4L2_CAP_VIDEO_CAPTURE_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = traw_metai_fmts,
+		.num_fmts = ARRAY_SIZE(traw_metai_fmts),
+		.default_fmt_idx = 1,
+		.default_width = MTK_TRAW_CAPTURE_MAX_WIDTH,
+		.default_height = MTK_TRAW_CAPTURE_MAX_WIDTH,
+		.dma_port = 5,
+		.frmsizeenum = &traw_out_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_cap_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "FEO output",
+	},
+	{
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_TIMGO_CAPTURE,
+		.name = "TIMGO Output",
+		.cap = V4L2_CAP_VIDEO_CAPTURE_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = traw_imgi_fmts,
+		.num_fmts = ARRAY_SIZE(traw_imgi_fmts),
+		.default_fmt_idx = 4,
+		.default_width = MTK_TRAW_CAPTURE_MAX_WIDTH,
+		.default_height = MTK_TRAW_CAPTURE_MAX_WIDTH,
+		.dma_port = 6,
+		.frmsizeenum = &traw_out_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_cap_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "TIMGO output",
+	},
+	{
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_IMGSTATO_CAPTURE,
+		.name = "IMGSTATO Output",
+		.cap = V4L2_CAP_VIDEO_CAPTURE_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = traw_metai_fmts,
+		.num_fmts = ARRAY_SIZE(traw_metai_fmts),
+		.default_fmt_idx = 1,
+		.default_width = MTK_TRAW_CAPTURE_MAX_WIDTH,
+		.default_height = MTK_TRAW_CAPTURE_MAX_WIDTH,
+		.dma_port = 7,
+		.frmsizeenum = &traw_out_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_cap_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "IMGSTATO output",
+	},
+};
+
+#endif // _MTK_TRAW_V4L2_VNODE_H_
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_70/modules/mtk_wpe_v4l2_vnode.h b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_70/modules/mtk_wpe_v4l2_vnode.h
new file mode 100644
index 0000000000000000000000000000000000000000..bbcf8d8e0fef0decc85fe1f3b4e55118133fb0be
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_70/modules/mtk_wpe_v4l2_vnode.h
@@ -0,0 +1,809 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2021 MediaTek Inc.
+ *
+ * Author: Floria Huang <floria.huang@mediatek.com>
+ *
+ */
+
+#ifndef _MTK_WPE_V4L2_VNODE_H_
+#define _MTK_WPE_V4L2_VNODE_H_
+
+/*#include <linux/platform_device.h>
+ * #include <linux/module.h>
+ * #include <linux/of_device.h>
+ * #include <linux/pm_runtime.h>
+ * #include <linux/remoteproc.h>
+ * #include <linux/remoteproc/mtk_scp.h>
+ */
+#include <linux/videodev2.h>
+#include <media/videobuf2-dma-contig.h>
+#include <media/v4l2-ioctl.h>
+#include <media/v4l2-subdev.h>
+#include <media/v4l2-event.h>
+#include "mtk_imgsys-dev.h"
+#include "mtk_imgsys-hw.h"
+
+#include "mtk_imgsys_v4l2.h"
+#include "mtk_header_desc.h"
+
+#define defaultdesc 0
+
+#define MTK_WPE_OUTPUT_MIN_WIDTH		2U
+#define MTK_WPE_OUTPUT_MIN_HEIGHT		2U
+#define MTK_WPE_OUTPUT_MAX_WIDTH		18472U
+#define MTK_WPE_OUTPUT_MAX_HEIGHT		13856U
+
+#define MTK_WPE_MAP_OUTPUT_MIN_WIDTH	2U
+#define MTK_WPE_MAP_OUTPUT_MIN_HEIGHT	2U
+#define MTK_WPE_MAP_OUTPUT_MAX_WIDTH	640U
+#define MTK_WPE_MAP_OUTPUT_MAX_HEIGHT	480U
+
+#define MTK_WPE_PSP_OUTPUT_WIDTH	    8U
+#define MTK_WPE_PSP_OUTPUT_HEIGHT	    33U
+
+#define MTK_WPE_CAPTURE_MIN_WIDTH		2U
+#define MTK_WPE_CAPTURE_MIN_HEIGHT		2U
+#define MTK_WPE_CAPTURE_MAX_WIDTH		18472U
+#define MTK_WPE_CAPTURE_MAX_HEIGHT		13856U
+
+
+static const struct mtk_imgsys_dev_format wpe_wpei_fmts[] = {
+	/* YUV422, 1 plane 8 bit */
+	{
+		.format = V4L2_PIX_FMT_UYVY,
+		.depth = { 16 },
+		.row_depth = { 16 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+	},
+	{
+		.format = V4L2_PIX_FMT_YUYV,
+		.depth = { 16 },
+		.row_depth = { 16 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+	},
+	{
+		.format = V4L2_PIX_FMT_YVYU,
+		.depth = { 16 },
+		.row_depth = { 16 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+	},
+	{
+		.format = V4L2_PIX_FMT_VYUY,
+		.depth = { 16 },
+		.row_depth = { 16 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+	},
+	/* YUV420, 2 plane 8 bit */
+	{
+		.format = V4L2_PIX_FMT_NV12,
+		.depth = { 12 },
+		.row_depth = { 8 },
+		.num_planes = 1,
+		.num_cplanes = 2,
+	},
+	{
+		.format = V4L2_PIX_FMT_NV12M,
+		.depth      = { 8, 4 },
+		.row_depth  = { 8, 8 },
+		.num_planes = 1,
+		.num_cplanes = 2,
+	},
+	{
+		.format = V4L2_PIX_FMT_NV21,
+		.depth = { 12 },
+		.row_depth = { 8 },
+		.num_planes = 1,
+		.num_cplanes = 2,
+	},
+	{
+		.format = V4L2_PIX_FMT_NV21M,
+		.depth      = { 8, 4 },
+		.row_depth  = { 8, 8 },
+		.num_planes = 1,
+		.num_cplanes = 2,
+	},
+	/* YUV420, 3 plane 8 bit */
+	{
+		.format	= V4L2_PIX_FMT_YUV420,
+		.depth		= { 12 },
+		.row_depth	= { 8 },
+		.num_planes	= 1,
+		.num_cplanes = 3,
+	},
+	{
+		.format	= V4L2_PIX_FMT_YVU420,
+		.depth		= { 12 },
+		.row_depth	= { 8 },
+		.num_planes	= 1,
+		.num_cplanes = 3,
+	},
+	/* Y8 bit */
+	{
+		.format	= V4L2_PIX_FMT_GREY,
+		.depth		= { 8 },
+		.row_depth	= { 8 },
+		.num_planes	= 1,
+		.num_cplanes = 1,
+	},
+	/* YUV422-10bit-1P-Packed */
+	{
+		.format	= V4L2_PIX_FMT_YUYV_Y210P,
+		.depth		= { 20 },
+		.row_depth	= { 10 },
+		.num_planes	= 1,
+		.num_cplanes = 1,
+	},
+	{
+		.format	= V4L2_PIX_FMT_YVYU_Y210P,
+		.depth		= { 20 },
+		.row_depth	= { 10 },
+		.num_planes	= 1,
+		.num_cplanes = 1,
+	},
+	{
+		.format	= V4L2_PIX_FMT_UYVY_Y210P,
+		.depth		= { 20 },
+		.row_depth	= { 10 },
+		.num_planes	= 1,
+		.num_cplanes = 1,
+	},
+	{
+		.format	= V4L2_PIX_FMT_VYUY_Y210P,
+		.depth		= { 20 },
+		.row_depth	= { 10 },
+		.num_planes	= 1,
+		.num_cplanes = 1,
+	},
+#ifdef support_rgb8 /* 0 */
+	/* Bayer 8 bit */
+	{
+		.format = V4L2_PIX_FMT_MTISP_SBGGR8,
+		.depth = { 8 },
+		.row_depth = { 8 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+		.pass_1_align = 64,//wpei, 64-pix align
+	},
+	{
+		.format = V4L2_PIX_FMT_MTISP_SGBRG8,
+		.depth = { 8 },
+		.row_depth = { 8 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+		.pass_1_align = 64,//wpei, 64-pix align
+	},
+	{
+		.format = V4L2_PIX_FMT_MTISP_SGRBG8,
+		.depth = { 8 },
+		.row_depth = { 8 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+		.pass_1_align = 64,//wpei, 64-pix align
+	},
+	{
+		.format = V4L2_PIX_FMT_MTISP_SRGGB8,
+		.depth = { 8 },
+		.row_depth = { 8 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+		.pass_1_align = 64,//wpei, 64-pix align
+	},
+#endif
+	/* Bayer 10 bit */
+	{
+		.format = V4L2_PIX_FMT_MTISP_SBGGR10,
+		.depth = { 10 },
+		.row_depth = { 10 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+		.pass_1_align = 80,//wpei, 64-pix align
+	},
+	{
+		.format = V4L2_PIX_FMT_MTISP_SGBRG10,
+		.depth = { 10 },
+		.row_depth = { 10 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+		.pass_1_align = 80,//wpei, 64-pix align
+	},
+	{
+		.format = V4L2_PIX_FMT_MTISP_SGRBG10,
+		.depth = { 10 },
+		.row_depth = { 10 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+		.pass_1_align = 80,//wpei, 64-pix align
+	},
+	{
+		.format = V4L2_PIX_FMT_MTISP_SRGGB10,
+		.depth = { 10 },
+		.row_depth = { 10 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+		.pass_1_align = 80,//wpei, 64-pix align
+	},
+	/* Bayer 12 bit */
+	{
+		.format = V4L2_PIX_FMT_MTISP_SBGGR12,
+		.depth = { 12 },
+		.row_depth = { 12 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+		.pass_1_align = 128,//wpei, 64-pix align
+	},
+	{
+		.format = V4L2_PIX_FMT_MTISP_SGBRG12,
+		.depth = { 12 },
+		.row_depth = { 12 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+		.pass_1_align = 128,//wpei, 64-pix align
+	},
+	{
+		.format = V4L2_PIX_FMT_MTISP_SGRBG12,
+		.depth = { 12 },
+		.row_depth = { 12 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+		.pass_1_align = 128,//wpei, 64-pix align
+	},
+	{
+		.format = V4L2_PIX_FMT_MTISP_SRGGB12,
+		.depth = { 12 },
+		.row_depth = { 12 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+		.pass_1_align = 128,//wpei, 64-pix align
+	},
+	/* Must have for SMVR/Multis-cale for every video_device nodes */
+	{
+		.format = V4L2_META_FMT_MTISP_DESC,
+		.num_planes = 1,
+#if defaultdesc
+		.depth = { 8 },
+		.row_depth = { 8 },
+		.num_cplanes = 1,
+#endif
+		.buffer_size = sizeof(struct header_desc),
+	},
+	{
+		.format = V4L2_META_FMT_MTISP_DESC_NORM,
+		.num_planes = 1,
+		.buffer_size = sizeof(struct header_desc_norm),
+	},
+
+};
+
+static const struct mtk_imgsys_dev_format wpe_veci_fmts[] = {
+	/* WarpMap, 2 plane, packed in 4-byte */
+	{
+		.format = V4L2_PIX_FMT_WARP2P,
+		.depth = { 32 },
+		.row_depth = { 32 },
+		.num_planes = 1,
+		.num_cplanes = 2,
+	},
+	/* Must have for SMVR/Multis-cale for every video_device nodes */
+	{
+		.format = V4L2_META_FMT_MTISP_DESC,
+		.num_planes = 1,
+#if defaultdesc
+		.depth = { 8 },
+		.row_depth = { 8 },
+		.num_cplanes = 1,
+#endif
+		.buffer_size = sizeof(struct header_desc),
+	},
+	{
+		.format = V4L2_META_FMT_MTISP_DESC_NORM,
+		.num_planes = 1,
+		.buffer_size = sizeof(struct header_desc_norm),
+	},
+
+};
+
+
+static const struct mtk_imgsys_dev_format wpe_pspi_fmts[] = {
+	{
+		.format = V4L2_PIX_FMT_GREY,
+		.depth = { 32 },
+		.row_depth = { 32 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+	},
+	/* Must have for SMVR/Multis-cale for every video_device nodes */
+	{
+		.format = V4L2_META_FMT_MTISP_DESC,
+		.num_planes = 1,
+#if defaultdesc
+		.depth = { 8 },
+		.row_depth = { 8 },
+		.num_cplanes = 1,
+#endif
+		.buffer_size = sizeof(struct header_desc),
+	},
+	{
+		.format = V4L2_META_FMT_MTISP_DESC_NORM,
+		.num_planes = 1,
+		.buffer_size = sizeof(struct header_desc_norm),
+	},
+
+};
+
+static const struct mtk_imgsys_dev_format wpe_wpeo_fmts[] = {
+	/* YUV422, 1 plane 8 bit */
+	{
+		.format = V4L2_PIX_FMT_UYVY,
+		.depth = { 16 },
+		.row_depth = { 16 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+	},
+	{
+		.format = V4L2_PIX_FMT_YUYV,
+		.depth = { 16 },
+		.row_depth = { 16 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+	},
+	{
+		.format = V4L2_PIX_FMT_YVYU,
+		.depth = { 16 },
+		.row_depth = { 16 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+	},
+	{
+		.format = V4L2_PIX_FMT_VYUY,
+		.depth = { 16 },
+		.row_depth = { 16 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+	},
+	/* YUV420, 2 plane 8 bit */
+	{
+		.format = V4L2_PIX_FMT_NV12,
+		.depth = { 12 },
+		.row_depth = { 8 },
+		.num_planes = 1,
+		.num_cplanes = 2,
+	},
+	{
+		.format = V4L2_PIX_FMT_NV12M,
+		.depth      = { 8, 4 },
+		.row_depth  = { 8, 8 },
+		.num_planes = 1,
+		.num_cplanes = 2,
+	},
+	{
+		.format = V4L2_PIX_FMT_NV21,
+		.depth = { 12 },
+		.row_depth = { 8 },
+		.num_planes = 1,
+		.num_cplanes = 2,
+	},
+	{
+		.format = V4L2_PIX_FMT_NV21M,
+		.depth      = { 8, 4 },
+		.row_depth  = { 8, 8 },
+		.num_planes = 1,
+		.num_cplanes = 2,
+	},
+	/* Y8 bit */
+	{
+		.format	= V4L2_PIX_FMT_GREY,
+		.depth		= { 8 },
+		.row_depth	= { 8 },
+		.num_planes	= 1,
+		.num_cplanes = 1,
+	},
+	/* YUV422-10bit-1P-Packed */
+	{
+		.format	= V4L2_PIX_FMT_YUYV_Y210P,
+		.depth		= { 20 },
+		.row_depth	= { 10 },
+		.num_planes	= 1,
+		.num_cplanes = 1,
+	},
+	{
+		.format	= V4L2_PIX_FMT_YVYU_Y210P,
+		.depth		= { 20 },
+		.row_depth	= { 10 },
+		.num_planes	= 1,
+		.num_cplanes = 1,
+	},
+	{
+		.format	= V4L2_PIX_FMT_UYVY_Y210P,
+		.depth		= { 20 },
+		.row_depth	= { 10 },
+		.num_planes	= 1,
+		.num_cplanes = 1,
+	},
+	{
+		.format	= V4L2_PIX_FMT_VYUY_Y210P,
+		.depth		= { 20 },
+		.row_depth	= { 10 },
+		.num_planes	= 1,
+		.num_cplanes = 1,
+	},
+#ifdef support_rgb8 /* 0 */
+	/* Bayer 8 bit */
+	{
+		.format = V4L2_PIX_FMT_MTISP_SBGGR8,
+		.depth = { 8 },
+		.row_depth = { 8 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+		.pass_1_align = 64,//wpei, 64-pix align
+	},
+	{
+		.format = V4L2_PIX_FMT_MTISP_SGBRG8,
+		.depth = { 8 },
+		.row_depth = { 8 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+		.pass_1_align = 64,//wpei, 64-pix align
+	},
+	{
+		.format = V4L2_PIX_FMT_MTISP_SGRBG8,
+		.depth = { 8 },
+		.row_depth = { 8 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+		.pass_1_align = 64,//wpei, 64-pix align
+	},
+	{
+		.format = V4L2_PIX_FMT_MTISP_SRGGB8,
+		.depth = { 8 },
+		.row_depth = { 8 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+		.pass_1_align = 64,//wpei, 64-pix align
+	},
+#endif
+	/* Bayer 10 bit */
+	{
+		.format = V4L2_PIX_FMT_MTISP_SBGGR10,
+		.depth = { 10 },
+		.row_depth = { 10 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+		.pass_1_align = 80,//wpei, 64-pix align
+	},
+	{
+		.format = V4L2_PIX_FMT_MTISP_SGBRG10,
+		.depth = { 10 },
+		.row_depth = { 10 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+		.pass_1_align = 80,//wpei, 64-pix align
+	},
+	{
+		.format = V4L2_PIX_FMT_MTISP_SGRBG10,
+		.depth = { 10 },
+		.row_depth = { 10 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+		.pass_1_align = 80,//wpei, 64-pix align
+	},
+	{
+		.format = V4L2_PIX_FMT_MTISP_SRGGB10,
+		.depth = { 10 },
+		.row_depth = { 10 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+		.pass_1_align = 80,//wpei, 64-pix align
+	},
+	/* Bayer 12 bit */
+	{
+		.format = V4L2_PIX_FMT_MTISP_SBGGR12,
+		.depth = { 12 },
+		.row_depth = { 12 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+		.pass_1_align = 128,//wpei, 64-pix align
+	},
+	{
+		.format = V4L2_PIX_FMT_MTISP_SGBRG12,
+		.depth = { 12 },
+		.row_depth = { 12 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+		.pass_1_align = 128,//wpei, 64-pix align
+	},
+	{
+		.format = V4L2_PIX_FMT_MTISP_SGRBG12,
+		.depth = { 12 },
+		.row_depth = { 12 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+		.pass_1_align = 128,//wpei, 64-pix align
+	},
+	{
+		.format = V4L2_PIX_FMT_MTISP_SRGGB12,
+		.depth = { 12 },
+		.row_depth = { 12 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+		.pass_1_align = 128,//wpei, 64-pix align
+	},
+	/* Must have for SMVR/Multis-cale for every video_device nodes */
+	{
+		.format = V4L2_META_FMT_MTISP_DESC,
+		.num_planes = 1,
+#if defaultdesc
+		.depth = { 8 },
+		.row_depth = { 8 },
+		.num_cplanes = 1,
+#endif
+		.buffer_size = sizeof(struct header_desc),
+	},
+	{
+		.format = V4L2_META_FMT_MTISP_DESC_NORM,
+		.num_planes = 1,
+		.buffer_size = sizeof(struct header_desc_norm),
+	},
+
+};
+
+static const struct mtk_imgsys_dev_format wpe_msko_fmts[] = {
+	/* Y8 bit */
+	{
+		.format	= V4L2_PIX_FMT_GREY,
+		.depth		= { 8 },
+		.row_depth	= { 8 },
+		.num_planes	= 1,
+		.num_cplanes = 1,
+	},
+	/* Must have for SMVR/Multis-cale for every video_device nodes */
+	{
+		.format = V4L2_META_FMT_MTISP_DESC,
+		.num_planes = 1,
+#if defaultdesc
+		.depth = { 8 },
+		.row_depth = { 8 },
+		.num_cplanes = 1,
+#endif
+		.buffer_size = sizeof(struct header_desc),
+	},
+	{
+		.format = V4L2_META_FMT_MTISP_DESC_NORM,
+		.num_planes = 1,
+		.buffer_size = sizeof(struct header_desc_norm),
+	},
+
+};
+
+static const struct v4l2_frmsizeenum wpe_in_frmsizeenum = {
+	.type = V4L2_FRMSIZE_TYPE_CONTINUOUS,
+	.stepwise.max_width = MTK_WPE_CAPTURE_MAX_WIDTH,
+	.stepwise.min_width = MTK_WPE_CAPTURE_MIN_WIDTH,
+	.stepwise.max_height = MTK_WPE_CAPTURE_MAX_HEIGHT,
+	.stepwise.min_height = MTK_WPE_CAPTURE_MIN_HEIGHT,
+	.stepwise.step_height = 1,
+	.stepwise.step_width = 1,
+};
+
+static const struct v4l2_frmsizeenum wpe_in_map_frmsizeenum = {
+	.type = V4L2_FRMSIZE_TYPE_CONTINUOUS,
+	.stepwise.max_width = MTK_WPE_MAP_OUTPUT_MAX_WIDTH,
+	.stepwise.min_width = MTK_WPE_MAP_OUTPUT_MIN_WIDTH,
+	.stepwise.max_height = MTK_WPE_MAP_OUTPUT_MAX_HEIGHT,
+	.stepwise.min_height = MTK_WPE_MAP_OUTPUT_MIN_HEIGHT,
+	.stepwise.step_height = 1,
+	.stepwise.step_width = 1,
+};
+
+static const struct v4l2_frmsizeenum wpe_in_psp_frmsizeenum = {
+	.type = V4L2_FRMSIZE_TYPE_CONTINUOUS,
+	.stepwise.max_width = MTK_WPE_PSP_OUTPUT_WIDTH,
+	.stepwise.min_width = MTK_WPE_PSP_OUTPUT_WIDTH,
+	.stepwise.max_height = MTK_WPE_PSP_OUTPUT_HEIGHT,
+	.stepwise.min_height = MTK_WPE_PSP_OUTPUT_HEIGHT,
+	.stepwise.step_height = 1,
+	.stepwise.step_width = 1,
+};
+
+
+static const struct v4l2_frmsizeenum wpe_out_frmsizeenum = {
+	.type = V4L2_FRMSIZE_TYPE_CONTINUOUS,
+	.stepwise.max_width = MTK_WPE_OUTPUT_MAX_WIDTH,
+	.stepwise.min_width = MTK_WPE_OUTPUT_MIN_WIDTH,
+	.stepwise.max_height = MTK_WPE_OUTPUT_MAX_HEIGHT,
+	.stepwise.min_height = MTK_WPE_OUTPUT_MIN_HEIGHT,
+	.stepwise.step_height = 1,
+	.stepwise.step_width = 1,
+};
+
+static const struct mtk_imgsys_video_device_desc wpe_setting[] = {
+	/* Input Video Node */
+	{
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_WWPEI_OUT,
+		.name = "WPEI_E Input",
+		.cap = V4L2_CAP_VIDEO_OUTPUT_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = wpe_wpei_fmts,
+		.num_fmts = ARRAY_SIZE(wpe_wpei_fmts),
+		.default_fmt_idx = 4,
+		.default_width = MTK_WPE_OUTPUT_MAX_WIDTH,
+		.default_height = MTK_WPE_OUTPUT_MAX_HEIGHT,
+		.dma_port = 0,
+		.frmsizeenum = &wpe_in_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_out_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "WPE main image input",
+	},
+	{
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_WVECI_OUT,
+		.name = "VECI_E Input",
+		.cap = V4L2_CAP_VIDEO_OUTPUT_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = wpe_veci_fmts,
+		.num_fmts = ARRAY_SIZE(wpe_veci_fmts),
+		.default_fmt_idx = 1,
+		.default_width = MTK_WPE_CAPTURE_MAX_WIDTH,
+		.default_height = MTK_WPE_CAPTURE_MAX_HEIGHT,
+		.dma_port = 1,
+		.frmsizeenum = &wpe_in_map_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_out_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "WarpMap input",
+	},
+	{
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_WPSP_COEFI_OUT,
+		.name = "PSPI_E Input",
+		.cap = V4L2_CAP_VIDEO_OUTPUT_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = wpe_pspi_fmts,
+		.num_fmts = ARRAY_SIZE(wpe_pspi_fmts),
+		.default_fmt_idx = 1,
+		.default_width = MTK_WPE_CAPTURE_MAX_WIDTH,
+		.default_height = MTK_WPE_CAPTURE_MAX_HEIGHT,
+		.dma_port = 2,
+		.frmsizeenum = &wpe_in_psp_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_out_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "PSP coef. table input",
+	},
+	/* WPE_EIS Output Video Node */
+	{
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_WWPEO_CAPTURE,
+		.name = "WPEO_E Output",
+		.cap = V4L2_CAP_VIDEO_CAPTURE_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = wpe_wpeo_fmts,
+		.num_fmts = ARRAY_SIZE(wpe_wpeo_fmts),
+		.default_fmt_idx = 0,
+		.default_width = MTK_WPE_CAPTURE_MAX_WIDTH,
+		.default_height = MTK_WPE_CAPTURE_MAX_HEIGHT,
+		.dma_port = 0,
+		.frmsizeenum = &wpe_out_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_cap_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "WPE image output",
+	},
+	{
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_WMSKO_CAPTURE,
+		.name = "MSKO_E Output",
+		.cap = V4L2_CAP_VIDEO_CAPTURE_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = wpe_msko_fmts,
+		.num_fmts = ARRAY_SIZE(wpe_msko_fmts),
+		.default_fmt_idx = 0,
+		.default_width = MTK_WPE_CAPTURE_MAX_WIDTH,
+		.default_height = MTK_WPE_CAPTURE_MAX_HEIGHT,
+		.dma_port = 1,
+		.frmsizeenum = &wpe_out_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_cap_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "WPE valid map output",
+	},
+	{
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_WTWPEI_OUT,
+		.name = "WPEI_T Input",
+		.cap = V4L2_CAP_VIDEO_OUTPUT_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = wpe_wpei_fmts,
+		.num_fmts = ARRAY_SIZE(wpe_wpei_fmts),
+		.default_fmt_idx = 4,
+		.default_width = MTK_WPE_OUTPUT_MAX_WIDTH,
+		.default_height = MTK_WPE_OUTPUT_MAX_HEIGHT,
+		.dma_port = 0,
+		.frmsizeenum = &wpe_in_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_out_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "WPE main image input",
+	},
+	{
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_WTVECI_OUT,
+		.name = "VECI_T Input",
+		.cap = V4L2_CAP_VIDEO_OUTPUT_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = wpe_veci_fmts,
+		.num_fmts = ARRAY_SIZE(wpe_veci_fmts),
+		.default_fmt_idx = 1,
+		.default_width = MTK_WPE_CAPTURE_MAX_WIDTH,
+		.default_height = MTK_WPE_CAPTURE_MAX_HEIGHT,
+		.dma_port = 1,
+		.frmsizeenum = &wpe_in_map_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_out_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "WarpMap input",
+	},
+	{
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_WTPSP_COEFI_OUT,
+		.name = "PSPI_T Input",
+		.cap = V4L2_CAP_VIDEO_OUTPUT_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = wpe_pspi_fmts,
+		.num_fmts = ARRAY_SIZE(wpe_pspi_fmts),
+		.default_fmt_idx = 1,
+		.default_width = MTK_WPE_CAPTURE_MAX_WIDTH,
+		.default_height = MTK_WPE_CAPTURE_MAX_HEIGHT,
+		.dma_port = 2,
+		.frmsizeenum = &wpe_in_psp_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_out_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "PSP coef. table input",
+	},
+	/* WPE_TNR Output Video Node */
+	{
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_WTWPEO_CAPTURE,
+		.name = "WPEO_T Output",
+		.cap = V4L2_CAP_VIDEO_CAPTURE_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = wpe_wpeo_fmts,
+		.num_fmts = ARRAY_SIZE(wpe_wpeo_fmts),
+		.default_fmt_idx = 0,
+		.default_width = MTK_WPE_CAPTURE_MAX_WIDTH,
+		.default_height = MTK_WPE_CAPTURE_MAX_HEIGHT,
+		.dma_port = 0,
+		.frmsizeenum = &wpe_out_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_cap_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "WPE image output",
+	},
+	{
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_WTMSKO_CAPTURE,
+		.name = "MSKO_T Output",
+		.cap = V4L2_CAP_VIDEO_CAPTURE_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = wpe_msko_fmts,
+		.num_fmts = ARRAY_SIZE(wpe_msko_fmts),
+		.default_fmt_idx = 0,
+		.default_width = MTK_WPE_CAPTURE_MAX_WIDTH,
+		.default_height = MTK_WPE_CAPTURE_MAX_HEIGHT,
+		.dma_port = 1,
+		.frmsizeenum = &wpe_out_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_cap_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "WPE valid map output",
+	},
+};
+
+#endif // _MTK_WPE_V4L2_VNODE_H_
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_70/mtk_imgsys-cmdq-plat.h b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_70/mtk_imgsys-cmdq-plat.h
new file mode 100644
index 0000000000000000000000000000000000000000..6760caa3a9c37d66d2becf743ea794317b846d5d
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_70/mtk_imgsys-cmdq-plat.h
@@ -0,0 +1,773 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2021 MediaTek Inc.
+ *
+ * Author: Daniel Huang <daniel.huang@mediatek.com>
+ *
+ */
+
+#ifndef _MTK_IMGSYS_CMDQ_PLAT_H_
+#define _MTK_IMGSYS_CMDQ_PLAT_H_
+
+#define IMGSYS_DVFS_ENABLE     (1)
+#define IMGSYS_QOS_ENABLE      (1)
+#define IMGSYS_QOS_SET_REAL    (0)
+#define IMGSYS_QOS_SET_BY_SCEN (1)
+
+#define IMGSYS_SECURE_ENABLE   (0)
+
+/* Record info definitions */
+#define GCE_REC_MAX_FRAME_BLOCK     (40)
+#define GCE_REC_MAX_TILE_BLOCK      (40)
+#define GCE_REC_MAX_LABEL_COUNT     (2048)
+
+#define IMGSYS_ENG_MAX 10
+#define IMGSYS_QOS_MAX 56
+#define IMGSYS_SEC_THD 2
+#define IMGSYS_MAX_FPS 60
+
+#define IMGSYS_VSS_FREQ_FLOOR	660000000
+#define IMGSYS_SMVR_FREQ_FLOOR	393000000
+
+#define IMGSYS_CMDQ_HW_EVENT_BEGIN	0
+#define IMGSYS_CMDQ_HW_EVENT_END	(IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_START - 1)
+#define IMGSYS_CMDQ_SW_EVENT_BEGIN	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_START
+#define IMGSYS_CMDQ_SW_EVENT_END	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_END
+#define IMGSYS_CMDQ_GPR_EVENT_BEGIN	999
+#define IMGSYS_CMDQ_GPR_EVENT_END	1008
+#define IMGSYS_CMDQ_SYNC_POOL_NUM	60
+
+#define WPE_SMI_PORT_NUM	5
+#define ME_SMI_PORT_NUM	2
+#define PQ_DIP_SMI_PORT_NUM	4
+#define TRAW_SMI_PORT_NUM	13
+#define LTRAW_SMI_PORT_NUM	7
+#define DIP_SMI_PORT_NUM	16
+
+#define IMGSYS_QOS_UPDATE_FREQ	1000
+#define IMGSYS_QOS_BLANK_INT	100
+#define IMGSYS_QOS_FACTOR		13
+#define IMGSYS_QOS_FHD_SIZE		(1920*1080/2)
+#define IMGSYS_QOS_4K_SIZE		(4000*2000/2)
+#define IMGSYS_QOS_FHD_30_BW_0	3320 //1328
+#define IMGSYS_QOS_FHD_30_BW_1	2262 //905
+#define IMGSYS_QOS_FHD_60_BW_0	6145 //2458
+#define IMGSYS_QOS_FHD_60_BW_1	3387 //1355
+#define IMGSYS_QOS_4K_30_BW_0	5875 //2350
+#define IMGSYS_QOS_4K_30_BW_1	3145 //1258
+#define IMGSYS_QOS_4K_60_BW_0	5610 //2244
+#define IMGSYS_QOS_4K_60_BW_1	5910 //2360
+
+enum mtk_imgsys_event {
+	/* HW event */
+	IMGSYS_CMDQ_EVENT_IMG_TRAW0_CQ_THR_DONE_TRAW0_0 = 0,
+	IMGSYS_CMDQ_EVENT_IMG_TRAW0_CQ_THR_DONE_TRAW0_1,
+	IMGSYS_CMDQ_EVENT_IMG_TRAW0_CQ_THR_DONE_TRAW0_2,
+	IMGSYS_CMDQ_EVENT_IMG_TRAW0_CQ_THR_DONE_TRAW0_3,
+	IMGSYS_CMDQ_EVENT_IMG_TRAW0_CQ_THR_DONE_TRAW0_4,
+	IMGSYS_CMDQ_EVENT_IMG_TRAW0_CQ_THR_DONE_TRAW0_5,
+	IMGSYS_CMDQ_EVENT_IMG_TRAW0_CQ_THR_DONE_TRAW0_6,
+	IMGSYS_CMDQ_EVENT_IMG_TRAW0_CQ_THR_DONE_TRAW0_7,
+	IMGSYS_CMDQ_EVENT_IMG_TRAW0_CQ_THR_DONE_TRAW0_8,
+	IMGSYS_CMDQ_EVENT_IMG_TRAW0_CQ_THR_DONE_TRAW0_9,
+	IMGSYS_CMDQ_EVENT_IMG_TRAW1_CQ_THR_DONE_TRAW0_0,
+	IMGSYS_CMDQ_EVENT_IMG_TRAW1_CQ_THR_DONE_TRAW0_1,
+	IMGSYS_CMDQ_EVENT_IMG_TRAW1_CQ_THR_DONE_TRAW0_2,
+	IMGSYS_CMDQ_EVENT_IMG_TRAW1_CQ_THR_DONE_TRAW0_3,
+	IMGSYS_CMDQ_EVENT_IMG_TRAW1_CQ_THR_DONE_TRAW0_4,
+	IMGSYS_CMDQ_EVENT_IMG_TRAW1_CQ_THR_DONE_TRAW0_5,
+	IMGSYS_CMDQ_EVENT_IMG_TRAW1_CQ_THR_DONE_TRAW0_6,
+	IMGSYS_CMDQ_EVENT_IMG_TRAW1_CQ_THR_DONE_TRAW0_7,
+	IMGSYS_CMDQ_EVENT_IMG_TRAW1_CQ_THR_DONE_TRAW0_8,
+	IMGSYS_CMDQ_EVENT_IMG_TRAW1_CQ_THR_DONE_TRAW0_9,
+	IMGSYS_CMDQ_EVENT_IMG_DIP_CQ_THR_DONE_P2_0,
+	IMGSYS_CMDQ_EVENT_IMG_DIP_CQ_THR_DONE_P2_1,
+	IMGSYS_CMDQ_EVENT_IMG_DIP_CQ_THR_DONE_P2_2,
+	IMGSYS_CMDQ_EVENT_IMG_DIP_CQ_THR_DONE_P2_3,
+	IMGSYS_CMDQ_EVENT_IMG_DIP_CQ_THR_DONE_P2_4,
+	IMGSYS_CMDQ_EVENT_IMG_DIP_CQ_THR_DONE_P2_5,
+	IMGSYS_CMDQ_EVENT_IMG_DIP_CQ_THR_DONE_P2_6,
+	IMGSYS_CMDQ_EVENT_IMG_DIP_CQ_THR_DONE_P2_7,
+	IMGSYS_CMDQ_EVENT_IMG_DIP_CQ_THR_DONE_P2_8,
+	IMGSYS_CMDQ_EVENT_IMG_DIP_CQ_THR_DONE_P2_9,
+	IMGSYS_CMDQ_EVENT_IMG_PQDIP_A_CQ_THR_DONE_P2_0,
+	IMGSYS_CMDQ_EVENT_IMG_PQDIP_A_CQ_THR_DONE_P2_1,
+	IMGSYS_CMDQ_EVENT_IMG_PQDIP_A_CQ_THR_DONE_P2_2,
+	IMGSYS_CMDQ_EVENT_IMG_PQDIP_A_CQ_THR_DONE_P2_3,
+	IMGSYS_CMDQ_EVENT_IMG_PQDIP_A_CQ_THR_DONE_P2_4,
+	IMGSYS_CMDQ_EVENT_IMG_PQDIP_A_CQ_THR_DONE_P2_5,
+	IMGSYS_CMDQ_EVENT_IMG_PQDIP_A_CQ_THR_DONE_P2_6,
+	IMGSYS_CMDQ_EVENT_IMG_PQDIP_A_CQ_THR_DONE_P2_7,
+	IMGSYS_CMDQ_EVENT_IMG_PQDIP_A_CQ_THR_DONE_P2_8,
+	IMGSYS_CMDQ_EVENT_IMG_PQDIP_A_CQ_THR_DONE_P2_9,
+	IMGSYS_CMDQ_EVENT_IMG_PQDIP_B_CQ_THR_DONE_P2_0,
+	IMGSYS_CMDQ_EVENT_IMG_PQDIP_B_CQ_THR_DONE_P2_1,
+	IMGSYS_CMDQ_EVENT_IMG_PQDIP_B_CQ_THR_DONE_P2_2,
+	IMGSYS_CMDQ_EVENT_IMG_PQDIP_B_CQ_THR_DONE_P2_3,
+	IMGSYS_CMDQ_EVENT_IMG_PQDIP_B_CQ_THR_DONE_P2_4,
+	IMGSYS_CMDQ_EVENT_IMG_PQDIP_B_CQ_THR_DONE_P2_5,
+	IMGSYS_CMDQ_EVENT_IMG_PQDIP_B_CQ_THR_DONE_P2_6,
+	IMGSYS_CMDQ_EVENT_IMG_PQDIP_B_CQ_THR_DONE_P2_7,
+	IMGSYS_CMDQ_EVENT_IMG_PQDIP_B_CQ_THR_DONE_P2_8,
+	IMGSYS_CMDQ_EVENT_IMG_PQDIP_B_CQ_THR_DONE_P2_9,
+	IMGSYS_CMDQ_EVENT_IMG_WPE_EIS_CQ_THR_DONE_P2_0,
+	IMGSYS_CMDQ_EVENT_IMG_WPE_EIS_CQ_THR_DONE_P2_1,
+	IMGSYS_CMDQ_EVENT_IMG_WPE_EIS_CQ_THR_DONE_P2_2,
+	IMGSYS_CMDQ_EVENT_IMG_WPE_EIS_CQ_THR_DONE_P2_3,
+	IMGSYS_CMDQ_EVENT_IMG_WPE_EIS_CQ_THR_DONE_P2_4,
+	IMGSYS_CMDQ_EVENT_IMG_WPE_EIS_CQ_THR_DONE_P2_5,
+	IMGSYS_CMDQ_EVENT_IMG_WPE_EIS_CQ_THR_DONE_P2_6,
+	IMGSYS_CMDQ_EVENT_IMG_WPE_EIS_CQ_THR_DONE_P2_7,
+	IMGSYS_CMDQ_EVENT_IMG_WPE_EIS_CQ_THR_DONE_P2_8,
+	IMGSYS_CMDQ_EVENT_IMG_WPE_EIS_CQ_THR_DONE_P2_9,
+	IMGSYS_CMDQ_EVENT_IMG_WPE_TNR_CQ_THR_DONE_P2_0,
+	IMGSYS_CMDQ_EVENT_IMG_WPE_TNR_CQ_THR_DONE_P2_1,
+	IMGSYS_CMDQ_EVENT_IMG_WPE_TNR_CQ_THR_DONE_P2_2,
+	IMGSYS_CMDQ_EVENT_IMG_WPE_TNR_CQ_THR_DONE_P2_3,
+	IMGSYS_CMDQ_EVENT_IMG_WPE_TNR_CQ_THR_DONE_P2_4,
+	IMGSYS_CMDQ_EVENT_IMG_WPE_TNR_CQ_THR_DONE_P2_5,
+	IMGSYS_CMDQ_EVENT_IMG_WPE_TNR_CQ_THR_DONE_P2_6,
+	IMGSYS_CMDQ_EVENT_IMG_WPE_TNR_CQ_THR_DONE_P2_7,
+	IMGSYS_CMDQ_EVENT_IMG_WPE_TNR_CQ_THR_DONE_P2_8,
+	IMGSYS_CMDQ_EVENT_IMG_WPE_TNR_CQ_THR_DONE_P2_9,
+	IMGSYS_CMDQ_EVENT_IMG_IMGSYS_IPE_ME_DONE,
+	/* SW event */
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_START,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_WPE_EIS = IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_START,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_WPE_TNR,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_TRAW,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_LTRAW,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_DIP,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_PQDIP_A,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_PQDIP_B,
+	IMGSYS_CMDQ_SYNC_TOKEN_IPESYS_ME,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_VSS_TRAW,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_VSS_LTRAW,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_VSS_DIP,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_START,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_1 = IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_START,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_2,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_3,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_4,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_5,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_6,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_7,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_8,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_9,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_10,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_11,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_12,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_13,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_14,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_15,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_16,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_17,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_18,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_19,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_20,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_21,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_22,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_23,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_24,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_25,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_26,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_27,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_28,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_29,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_30,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_31,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_32,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_33,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_34,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_35,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_36,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_37,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_38,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_39,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_40,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_41,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_42,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_43,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_44,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_45,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_46,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_47,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_48,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_49,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_50,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_51,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_52,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_53,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_54,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_55,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_56,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_57,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_58,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_59,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_60,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_END = IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_60,
+#ifdef support_event /* 0 */
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_61,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_62,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_63,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_64,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_65,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_66,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_67,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_68,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_69,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_70,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_71,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_72,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_73,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_74,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_75,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_76,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_77,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_78,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_79,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_80,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_81,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_82,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_83,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_84,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_85,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_86,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_87,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_88,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_89,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_90,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_91,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_92,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_93,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_94,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_95,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_96,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_97,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_98,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_99,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_100,
+	IMGSYS_CMDQ_SYNC_TOKEN_CAMSYS_POOL_1,
+	IMGSYS_CMDQ_SYNC_TOKEN_CAMSYS_POOL_2,
+	IMGSYS_CMDQ_SYNC_TOKEN_CAMSYS_POOL_3,
+	IMGSYS_CMDQ_SYNC_TOKEN_CAMSYS_POOL_4,
+	IMGSYS_CMDQ_SYNC_TOKEN_CAMSYS_POOL_5,
+	IMGSYS_CMDQ_SYNC_TOKEN_CAMSYS_POOL_6,
+	IMGSYS_CMDQ_SYNC_TOKEN_CAMSYS_POOL_7,
+	IMGSYS_CMDQ_SYNC_TOKEN_CAMSYS_POOL_8,
+	IMGSYS_CMDQ_SYNC_TOKEN_CAMSYS_POOL_9,
+	IMGSYS_CMDQ_SYNC_TOKEN_CAMSYS_POOL_10,
+#endif
+	IMGSYS_CMDQ_SYNC_TOKEN_TZMP_ISP_WAIT,
+	IMGSYS_CMDQ_SYNC_TOKEN_TZMP_ISP_SET,
+	IMGSYS_CMDQ_EVENT_MAX
+};
+
+static struct imgsys_event_table imgsys_event[] = {
+	/*TRAW frame done*/
+	{IMGSYS_CMDQ_EVENT_IMG_TRAW0_CQ_THR_DONE_TRAW0_0, "traw_cq_thread0_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_TRAW0_CQ_THR_DONE_TRAW0_1, "traw_cq_thread1_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_TRAW0_CQ_THR_DONE_TRAW0_2, "traw_cq_thread2_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_TRAW0_CQ_THR_DONE_TRAW0_3, "traw_cq_thread3_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_TRAW0_CQ_THR_DONE_TRAW0_4, "traw_cq_thread4_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_TRAW0_CQ_THR_DONE_TRAW0_5, "traw_cq_thread5_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_TRAW0_CQ_THR_DONE_TRAW0_6, "traw_cq_thread6_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_TRAW0_CQ_THR_DONE_TRAW0_7, "traw_cq_thread7_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_TRAW0_CQ_THR_DONE_TRAW0_8, "traw_cq_thread8_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_TRAW0_CQ_THR_DONE_TRAW0_9, "traw_cq_thread9_frame_done"},
+	/*LTRAW frame done*/
+	{IMGSYS_CMDQ_EVENT_IMG_TRAW1_CQ_THR_DONE_TRAW0_0, "ltraw_cq_thread0_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_TRAW1_CQ_THR_DONE_TRAW0_1, "ltraw_cq_thread1_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_TRAW1_CQ_THR_DONE_TRAW0_2, "ltraw_cq_thread2_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_TRAW1_CQ_THR_DONE_TRAW0_3, "ltraw_cq_thread3_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_TRAW1_CQ_THR_DONE_TRAW0_4, "ltraw_cq_thread4_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_TRAW1_CQ_THR_DONE_TRAW0_5, "ltraw_cq_thread5_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_TRAW1_CQ_THR_DONE_TRAW0_6, "ltraw_cq_thread6_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_TRAW1_CQ_THR_DONE_TRAW0_7, "ltraw_cq_thread7_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_TRAW1_CQ_THR_DONE_TRAW0_8, "ltraw_cq_thread8_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_TRAW1_CQ_THR_DONE_TRAW0_9, "ltraw_cq_thread9_frame_done"},
+	/*DIP frame done*/
+	{IMGSYS_CMDQ_EVENT_IMG_DIP_CQ_THR_DONE_P2_0, "dip_cq_thread0_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_DIP_CQ_THR_DONE_P2_1, "dip_cq_thread1_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_DIP_CQ_THR_DONE_P2_2, "dip_cq_thread2_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_DIP_CQ_THR_DONE_P2_3, "dip_cq_thread3_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_DIP_CQ_THR_DONE_P2_4, "dip_cq_thread4_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_DIP_CQ_THR_DONE_P2_5, "dip_cq_thread5_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_DIP_CQ_THR_DONE_P2_6, "dip_cq_thread6_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_DIP_CQ_THR_DONE_P2_7, "dip_cq_thread7_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_DIP_CQ_THR_DONE_P2_8, "dip_cq_thread8_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_DIP_CQ_THR_DONE_P2_9, "dip_cq_thread9_frame_done"},
+	/*PQ_DIP_A frame done*/
+	{IMGSYS_CMDQ_EVENT_IMG_PQDIP_A_CQ_THR_DONE_P2_0, "pqa_cq_thread0_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_PQDIP_A_CQ_THR_DONE_P2_1, "pqa_cq_thread1_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_PQDIP_A_CQ_THR_DONE_P2_2, "pqa_cq_thread2_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_PQDIP_A_CQ_THR_DONE_P2_3, "pqa_cq_thread3_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_PQDIP_A_CQ_THR_DONE_P2_4, "pqa_cq_thread4_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_PQDIP_A_CQ_THR_DONE_P2_5, "pqa_cq_thread5_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_PQDIP_A_CQ_THR_DONE_P2_6, "pqa_cq_thread6_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_PQDIP_A_CQ_THR_DONE_P2_7, "pqa_cq_thread7_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_PQDIP_A_CQ_THR_DONE_P2_8, "pqa_cq_thread8_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_PQDIP_A_CQ_THR_DONE_P2_9, "pqa_cq_thread9_frame_done"},
+	/*PQ_DIP_B frame done*/
+	{IMGSYS_CMDQ_EVENT_IMG_PQDIP_B_CQ_THR_DONE_P2_0, "pqb_cq_thread0_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_PQDIP_B_CQ_THR_DONE_P2_1, "pqb_cq_thread1_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_PQDIP_B_CQ_THR_DONE_P2_2, "pqb_cq_thread2_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_PQDIP_B_CQ_THR_DONE_P2_3, "pqb_cq_thread3_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_PQDIP_B_CQ_THR_DONE_P2_4, "pqb_cq_thread4_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_PQDIP_B_CQ_THR_DONE_P2_5, "pqb_cq_thread5_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_PQDIP_B_CQ_THR_DONE_P2_6, "pqb_cq_thread6_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_PQDIP_B_CQ_THR_DONE_P2_7, "pqb_cq_thread7_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_PQDIP_B_CQ_THR_DONE_P2_8, "pqb_cq_thread8_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_PQDIP_B_CQ_THR_DONE_P2_9, "pqb_cq_thread9_frame_done"},
+	/*WPE_EIS frame done*/
+	{IMGSYS_CMDQ_EVENT_IMG_WPE_EIS_CQ_THR_DONE_P2_0, "wpe_eis_cq_thread0_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_WPE_EIS_CQ_THR_DONE_P2_1, "wpe_eis_cq_thread1_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_WPE_EIS_CQ_THR_DONE_P2_2, "wpe_eis_cq_thread2_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_WPE_EIS_CQ_THR_DONE_P2_3, "wpe_eis_cq_thread3_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_WPE_EIS_CQ_THR_DONE_P2_4, "wpe_eis_cq_thread4_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_WPE_EIS_CQ_THR_DONE_P2_5, "wpe_eis_cq_thread5_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_WPE_EIS_CQ_THR_DONE_P2_6, "wpe_eis_cq_thread6_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_WPE_EIS_CQ_THR_DONE_P2_7, "wpe_eis_cq_thread7_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_WPE_EIS_CQ_THR_DONE_P2_8, "wpe_eis_cq_thread8_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_WPE_EIS_CQ_THR_DONE_P2_9, "wpe_eis_cq_thread9_frame_done"},
+	/*WPE_TNR frame done*/
+	{IMGSYS_CMDQ_EVENT_IMG_WPE_TNR_CQ_THR_DONE_P2_0, "wpe_tnr_cq_thread0_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_WPE_TNR_CQ_THR_DONE_P2_1, "wpe_tnr_cq_thread1_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_WPE_TNR_CQ_THR_DONE_P2_2, "wpe_tnr_cq_thread2_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_WPE_TNR_CQ_THR_DONE_P2_3, "wpe_tnr_cq_thread3_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_WPE_TNR_CQ_THR_DONE_P2_4, "wpe_tnr_cq_thread4_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_WPE_TNR_CQ_THR_DONE_P2_5, "wpe_tnr_cq_thread5_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_WPE_TNR_CQ_THR_DONE_P2_6, "wpe_tnr_cq_thread6_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_WPE_TNR_CQ_THR_DONE_P2_7, "wpe_tnr_cq_thread7_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_WPE_TNR_CQ_THR_DONE_P2_8, "wpe_tnr_cq_thread8_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_WPE_TNR_CQ_THR_DONE_P2_9, "wpe_tnr_cq_thread9_frame_done"},
+	/*ME done*/
+	{IMGSYS_CMDQ_EVENT_IMG_IMGSYS_IPE_ME_DONE, "me_done"},
+	/* SW event */
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_WPE_EIS, "wpe_eis_sync_token"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_WPE_TNR, "wpe_tnr_sync_token"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_TRAW, "traw_sync_token"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_LTRAW, "ltraw_sync_token"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_DIP, "dip_sync_token"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_PQDIP_A, "pqdip_a_sync_token"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_PQDIP_B, "pqdip_b_sync_token"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IPESYS_ME, "me_sync_token"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_VSS_TRAW, "vss_traw_sync_token"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_VSS_LTRAW, "vss_ltraw_sync_token"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_VSS_DIP, "vss_dip_sync_token"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_1, "sw_sync_token_pool_1"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_2, "sw_sync_token_pool_2"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_3, "sw_sync_token_pool_3"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_4, "sw_sync_token_pool_4"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_5, "sw_sync_token_pool_5"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_6, "sw_sync_token_pool_6"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_7, "sw_sync_token_pool_7"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_8, "sw_sync_token_pool_8"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_9, "sw_sync_token_pool_9"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_10, "sw_sync_token_pool_10"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_11, "sw_sync_token_pool_11"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_12, "sw_sync_token_pool_12"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_13, "sw_sync_token_pool_13"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_14, "sw_sync_token_pool_14"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_15, "sw_sync_token_pool_15"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_16, "sw_sync_token_pool_16"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_17, "sw_sync_token_pool_17"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_18, "sw_sync_token_pool_18"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_19, "sw_sync_token_pool_19"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_20, "sw_sync_token_pool_20"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_21, "sw_sync_token_pool_21"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_22, "sw_sync_token_pool_22"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_23, "sw_sync_token_pool_23"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_24, "sw_sync_token_pool_24"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_25, "sw_sync_token_pool_25"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_26, "sw_sync_token_pool_26"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_27, "sw_sync_token_pool_27"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_28, "sw_sync_token_pool_28"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_29, "sw_sync_token_pool_29"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_30, "sw_sync_token_pool_30"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_31, "sw_sync_token_pool_31"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_32, "sw_sync_token_pool_32"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_33, "sw_sync_token_pool_33"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_34, "sw_sync_token_pool_34"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_35, "sw_sync_token_pool_35"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_36, "sw_sync_token_pool_36"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_37, "sw_sync_token_pool_37"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_38, "sw_sync_token_pool_38"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_39, "sw_sync_token_pool_39"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_40, "sw_sync_token_pool_40"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_41, "sw_sync_token_pool_41"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_42, "sw_sync_token_pool_42"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_43, "sw_sync_token_pool_43"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_44, "sw_sync_token_pool_44"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_45, "sw_sync_token_pool_45"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_46, "sw_sync_token_pool_46"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_47, "sw_sync_token_pool_47"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_48, "sw_sync_token_pool_48"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_49, "sw_sync_token_pool_49"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_50, "sw_sync_token_pool_50"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_51, "sw_sync_token_pool_51"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_52, "sw_sync_token_pool_52"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_53, "sw_sync_token_pool_53"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_54, "sw_sync_token_pool_54"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_55, "sw_sync_token_pool_55"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_56, "sw_sync_token_pool_56"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_57, "sw_sync_token_pool_57"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_58, "sw_sync_token_pool_58"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_59, "sw_sync_token_pool_59"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_60, "sw_sync_token_pool_60"},
+#ifdef support_event /* 0 */
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_61, "sw_sync_token_pool_61"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_62, "sw_sync_token_pool_62"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_63, "sw_sync_token_pool_63"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_64, "sw_sync_token_pool_64"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_65, "sw_sync_token_pool_65"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_66, "sw_sync_token_pool_66"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_67, "sw_sync_token_pool_67"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_68, "sw_sync_token_pool_68"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_69, "sw_sync_token_pool_69"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_70, "sw_sync_token_pool_70"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_71, "sw_sync_token_pool_71"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_72, "sw_sync_token_pool_72"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_73, "sw_sync_token_pool_73"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_74, "sw_sync_token_pool_74"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_75, "sw_sync_token_pool_75"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_76, "sw_sync_token_pool_76"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_77, "sw_sync_token_pool_77"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_78, "sw_sync_token_pool_78"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_79, "sw_sync_token_pool_79"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_80, "sw_sync_token_pool_80"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_81, "sw_sync_token_pool_81"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_82, "sw_sync_token_pool_82"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_83, "sw_sync_token_pool_83"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_84, "sw_sync_token_pool_84"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_85, "sw_sync_token_pool_85"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_86, "sw_sync_token_pool_86"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_87, "sw_sync_token_pool_87"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_88, "sw_sync_token_pool_88"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_89, "sw_sync_token_pool_89"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_90, "sw_sync_token_pool_90"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_91, "sw_sync_token_pool_91"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_92, "sw_sync_token_pool_92"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_93, "sw_sync_token_pool_93"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_94, "sw_sync_token_pool_94"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_95, "sw_sync_token_pool_95"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_96, "sw_sync_token_pool_96"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_97, "sw_sync_token_pool_97"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_98, "sw_sync_token_pool_98"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_99, "sw_sync_token_pool_99"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_100, "sw_sync_token_pool_100"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_CAMSYS_POOL_1, "sw_sync_token_camsys_pool_1"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_CAMSYS_POOL_2, "sw_sync_token_camsys_pool_2"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_CAMSYS_POOL_3, "sw_sync_token_camsys_pool_3"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_CAMSYS_POOL_4, "sw_sync_token_camsys_pool_4"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_CAMSYS_POOL_5, "sw_sync_token_camsys_pool_5"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_CAMSYS_POOL_6, "sw_sync_token_camsys_pool_6"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_CAMSYS_POOL_7, "sw_sync_token_camsys_pool_7"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_CAMSYS_POOL_8, "sw_sync_token_camsys_pool_8"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_CAMSYS_POOL_9, "sw_sync_token_camsys_pool_9"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_CAMSYS_POOL_10, "sw_sync_token_camsys_pool_10"},
+#endif
+	{IMGSYS_CMDQ_SYNC_TOKEN_TZMP_ISP_WAIT, "sw_sync_token_tzmp_isp_wait"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_TZMP_ISP_SET, "sw_sync_token_tzmp_isp_set"},
+	{IMGSYS_CMDQ_EVENT_MAX, "imgsys_event_max"},
+};
+
+static struct cmdq_client *imgsys_clt[IMGSYS_ENG_MAX];
+#if IMGSYS_SECURE_ENABLE
+static struct cmdq_client *imgsys_sec_clt[IMGSYS_SEC_THD];
+#endif
+
+enum mtk_imgsys_m4u_port {
+	/* TRAW */
+	IMGSYS_M4U_PORT_TRAW_START,
+	IMGSYS_M4U_PORT_L9_IMG_IMGI_T1_A = IMGSYS_M4U_PORT_TRAW_START,
+	IMGSYS_M4U_PORT_L9_IMG_IMGBI_T1_A,
+	IMGSYS_M4U_PORT_L9_IMG_IMGCI_T1_A,
+	IMGSYS_M4U_PORT_L9_IMG_SMTI_T1_A,
+	IMGSYS_M4U_PORT_L9_IMG_TNCSTI_T1_A,
+	IMGSYS_M4U_PORT_L9_IMG_TNCSTI_T4_A,
+	IMGSYS_M4U_PORT_L9_IMG_YUVO_T1_A,
+	IMGSYS_M4U_PORT_L9_IMG_TIMGO_T1_A,
+	IMGSYS_M4U_PORT_L9_IMG_YUVO_T2_A,
+	IMGSYS_M4U_PORT_L9_IMG_YUVO_T5_A,
+	IMGSYS_M4U_PORT_L9_IMG_TNCSO_T1_A,
+	IMGSYS_M4U_PORT_L9_IMG_SMTO_T1_A,
+	IMGSYS_M4U_PORT_L9_IMG_TNCSTO_T1_A,
+
+	/* LTRAW */
+	IMGSYS_M4U_PORT_LTRAW_START,
+	IMGSYS_M4U_PORT_L9_IMG_IMGI_T1_B = IMGSYS_M4U_PORT_LTRAW_START,
+	IMGSYS_M4U_PORT_L9_IMG_IMGBI_T1_B,
+	IMGSYS_M4U_PORT_L9_IMG_IMGCI_T1_B,
+	IMGSYS_M4U_PORT_L9_IMG_SMTI_T1_B,
+	IMGSYS_M4U_PORT_L9_IMG_YUVO_T2_B,
+	IMGSYS_M4U_PORT_L9_IMG_YUVO_T5_B,
+	IMGSYS_M4U_PORT_L9_IMG_SMTO_T1_B,
+
+	/* DIP */
+	IMGSYS_M4U_PORT_DIP_START,
+	IMGSYS_M4U_PORT_L10_IMG_IMGI_D1_A = IMGSYS_M4U_PORT_DIP_START,
+	IMGSYS_M4U_PORT_L10_IMG_IMGCI_D1_A,
+	IMGSYS_M4U_PORT_L10_IMG_DEPI_D1_A,
+	IMGSYS_M4U_PORT_L10_IMG_DMGI_D1_A,
+	IMGSYS_M4U_PORT_L10_IMG_VIPI_D1_A,
+	IMGSYS_M4U_PORT_L10_IMG_TNRWI_D1_A,
+	IMGSYS_M4U_PORT_L10_IMG_RECI_D1_A,
+	IMGSYS_M4U_PORT_L10_IMG_SMTI_D1_A,
+	IMGSYS_M4U_PORT_L10_IMG_SMTI_D6_A,
+	IMGSYS_M4U_PORT_L10_IMG_IMG3O_D1_A,
+	IMGSYS_M4U_PORT_L10_IMG_IMG4O_D1_A,
+	IMGSYS_M4U_PORT_L10_IMG_IMG3CO_D1_A,
+	IMGSYS_M4U_PORT_L10_IMG_FEO_D1_A,
+	IMGSYS_M4U_PORT_L10_IMG_IMG2O_D1_A,
+	IMGSYS_M4U_PORT_L10_IMG_TNRWO_D1_A,
+	IMGSYS_M4U_PORT_L10_IMG_SMTO_D1_A,
+
+	/* PQDIP_A */
+	IMGSYS_M4U_PORT_PQDIP_A_START,
+	IMGSYS_M4U_PORT_L10_IMG_PIMGI_P1_A = IMGSYS_M4U_PORT_PQDIP_A_START,
+	IMGSYS_M4U_PORT_L10_IMG_PIMGBI_P1_A,
+	IMGSYS_M4U_PORT_L10_IMG_PIMGCI_P1_A,
+	IMGSYS_M4U_PORT_L10_IMG_WROT_P1_A,
+
+	/* PQDIP_B */
+	IMGSYS_M4U_PORT_PQDIP_B_START,
+	IMGSYS_M4U_PORT_L10_IMG_PIMGI_P1_B = IMGSYS_M4U_PORT_PQDIP_B_START,
+	IMGSYS_M4U_PORT_L10_IMG_PIMGBI_P1_B,
+	IMGSYS_M4U_PORT_L10_IMG_PIMGCI_P1_B,
+	IMGSYS_M4U_PORT_L10_IMG_WROT_P1_B,
+
+	/* WPE_EIS */
+	IMGSYS_M4U_PORT_WPE_EIS_START,
+	IMGSYS_M4U_PORT_L11_IMG_WPE_EIS_RDMA0_A = IMGSYS_M4U_PORT_WPE_EIS_START,
+	IMGSYS_M4U_PORT_L11_IMG_WPE_EIS_RDMA1_A,
+	IMGSYS_M4U_PORT_L11_IMG_WPE_EIS_WDMA0_A,
+	IMGSYS_M4U_PORT_L11_IMG_WPE_EIS_CQ0_A,
+	IMGSYS_M4U_PORT_L11_IMG_WPE_EIS_CQ1_A,
+
+	/* WPE_TNR */
+	IMGSYS_M4U_PORT_WPE_TNR_START,
+	IMGSYS_M4U_PORT_L11_IMG_WPE_TNR_RDMA0_A = IMGSYS_M4U_PORT_WPE_TNR_START,
+	IMGSYS_M4U_PORT_L11_IMG_WPE_TNR_RDMA1_A,
+	IMGSYS_M4U_PORT_L11_IMG_WPE_TNR_WDMA0_A,
+	IMGSYS_M4U_PORT_L11_IMG_WPE_TNR_CQ0_A,
+	IMGSYS_M4U_PORT_L11_IMG_WPE_TNR_CQ1_A,
+
+	/* ME */
+	IMGSYS_M4U_PORT_ME_START,
+	IMGSYS_M4U_PORT_L12_IMG_ME_RDMA = IMGSYS_M4U_PORT_ME_START,
+	IMGSYS_M4U_PORT_L12_IMG_ME_WDMA,
+
+	/* SMI COMMON */
+	IMGSYS_L9_COMMON_0,
+	IMGSYS_L12_COMMON_1,
+	IMGSYS_M4U_PORT_MAX
+};
+
+#if DVFS_QOS_READY
+static struct mtk_imgsys_qos_path imgsys_qos_path[IMGSYS_M4U_PORT_MAX] = {
+	{NULL, "l9_imgi_t1_a", 0},
+	{NULL, "l9_imgbi_t1_a", 0},
+	{NULL, "l9_imgci_t1_a", 0},
+	{NULL, "l9_smti_t1_a", 0},
+	{NULL, "l9_tncsti_t1_a", 0},
+	{NULL, "l9_tncsti_t4_a", 0},
+	{NULL, "l9_yuvo_t1_a", 0},
+	{NULL, "l9_timgo_t1_a", 0},
+	{NULL, "l9_yuvo_t2_a", 0},
+	{NULL, "l9_yuvo_t5_a", 0},
+	{NULL, "l9_tncso_t1_a", 0},
+	{NULL, "l9_smto_t1_a", 0},
+	{NULL, "l9_tncsto_t1_a", 0},
+	{NULL, "l9_imgi_t1_b", 0},
+	{NULL, "l9_imgbi_t1_b", 0},
+	{NULL, "l9_imgci_t1_b", 0},
+	{NULL, "l9_smti_t1_b", 0},
+	{NULL, "l9_yuvo_t2_b", 0},
+	{NULL, "l9_yuvo_t5_b", 0},
+	{NULL, "l9_smto_t1_b", 0},
+	{NULL, "l10_imgi_d1_a", 0},
+	{NULL, "l10_imgci_d1_a", 0},
+	{NULL, "l10_depi_d1_a", 0},
+	{NULL, "l10_dmgi_d1_a", 0},
+	{NULL, "l10_vipi_d1_a", 0},
+	{NULL, "l10_tnrwi_d1_a", 0},
+	{NULL, "l10_reci_d1_a", 0},
+	{NULL, "l10_smti_d1_a", 0},
+	{NULL, "l10_smti_d6_a", 0},
+	{NULL, "l10_img3o_d1_a", 0},
+	{NULL, "l10_img4o_d1_a", 0},
+	{NULL, "l10_img3co_d1_a", 0},
+	{NULL, "l10_feo_d1_a", 0},
+	{NULL, "l10_img2o_d1_a", 0},
+	{NULL, "l10_tnrwo_d1_a", 0},
+	{NULL, "l10_smto_d1_a", 0},
+	{NULL, "l10_pimgi_p1_a", 0},
+	{NULL, "l10_pimgbi_p1_a", 0},
+	{NULL, "l10_pimgci_p1_a", 0},
+	{NULL, "l10_wrot_p1_a", 0},
+	{NULL, "l10_pimgi_p1_b", 0},
+	{NULL, "l10_pimgbi_p1_b", 0},
+	{NULL, "l10_pimgci_p1_b", 0},
+	{NULL, "l10_wrot_p1_b", 0},
+	{NULL, "l11_wpe_eis_rdma0_a", 0},
+	{NULL, "l11_wpe_eis_rdma1_a", 0},
+	{NULL, "l11_wpe_eis_wdma0_a", 0},
+	{NULL, "l11_wpe_eis_cq0_a", 0},
+	{NULL, "l11_wpe_eis_cq1_a", 0},
+	{NULL, "l11_wpe_tnr_rdma0_a", 0},
+	{NULL, "l11_wpe_tnr_rdma1_a", 0},
+	{NULL, "l11_wpe_tnr_wdma0_a", 0},
+	{NULL, "l11_wpe_tnr_cq0_a", 0},
+	{NULL, "l11_wpe_tnr_cq1_a", 0},
+	{NULL, "l12_me_rdma", 0},
+	{NULL, "l12_me_wdma", 0},
+	{NULL, "l9_common_0", 0},
+	{NULL, "l12_common_1", 0}
+};
+#endif
+
+struct BlockRecord {
+	uint32_t            label_min;
+	uint32_t            label_max;
+	uint32_t            label_count;
+	uint32_t            cmd_offset;
+	uint32_t            cmd_length;
+};
+
+enum GCE_REC_BLOCK_ENUM {
+	GCE_REC_NONE_BLOCK = -1,
+	GCE_REC_FRAME_BLOCK = 0,
+	GCE_REC_TILE_BLOCK
+};
+
+enum GCE_REC_MODE_ENUM {
+	GCE_REC_APPEND_MODE = 0,
+	GCE_REC_REPLACE_MODE
+};
+
+struct GCERecoder {
+	uint32_t            header_code;
+
+	// Record command offset
+	uint32_t            cmd_offset;
+
+	uint32_t            check_pre;
+
+	// Reocrd command buffer info
+	uint32_t            *pOutput;
+
+	uint32_t            check_post;
+
+	uint32_t            *pBuffer;
+	uint32_t            max_length;
+	uint32_t            curr_length;
+
+	// Each frame block info
+	struct BlockRecord  frame_record[GCE_REC_MAX_FRAME_BLOCK];
+	uint32_t            frame_block;
+	uint32_t            curr_frame;
+
+	// Each tile block info
+	struct BlockRecord  tile_record[GCE_REC_MAX_TILE_BLOCK];
+	uint32_t            tile_block;
+	uint32_t            curr_tile;
+
+	// Record current block type
+	enum GCE_REC_BLOCK_ENUM  curr_block;
+
+	// Current mode setting
+	enum GCE_REC_MODE_ENUM   curr_mode;
+
+	// Append/Replace mode switch
+	uint32_t            orig_index;
+	uint32_t            *pOrig_out;
+	uint32_t            curr_label;
+
+	// Current label mode setting
+	enum GCE_REC_BLOCK_ENUM  label_block;
+
+	// Each frame command label
+	uint32_t            frame_label[GCE_REC_MAX_LABEL_COUNT];
+	uint32_t            frame_count;
+
+	// Each tile command label
+	uint32_t            tile_label[GCE_REC_MAX_LABEL_COUNT];
+	uint32_t            tile_count;
+
+	uint32_t            footer_code;
+};
+
+#if DVFS_QOS_READY
+static struct imgsys_dvfs_group  dvfs_group[MTK_IMGSYS_DVFS_GROUP] = {
+	{0, (IMGSYS_ENG_TRAW
+			|IMGSYS_ENG_LTR
+			|IMGSYS_ENG_ME)},
+	{1, (IMGSYS_ENG_WPE_TNR
+			|IMGSYS_ENG_DIP)},
+	{2, (IMGSYS_ENG_WPE_EIS
+			|IMGSYS_ENG_PQDIP_A
+			|IMGSYS_ENG_PQDIP_B)}
+};
+
+static struct imgsys_dvfs_group  qos_group[MTK_IMGSYS_QOS_GROUP] = {
+	{0, (IMGSYS_ENG_WPE_EIS
+			|IMGSYS_ENG_TRAW
+			|IMGSYS_ENG_LTR
+			|IMGSYS_ENG_DIP
+			|IMGSYS_ENG_PQDIP_A)},
+	{1, (IMGSYS_ENG_WPE_TNR
+			|IMGSYS_ENG_DIP
+			|IMGSYS_ENG_PQDIP_B
+			|IMGSYS_ENG_ME)}
+};
+#endif
+
+struct smi_port_t {
+	uint32_t portenum;
+	uint32_t portbw;
+} __attribute__((__packed__));
+
+struct wpe_bw_t {
+	uint32_t totalbw;
+	struct smi_port_t smiport[WPE_SMI_PORT_NUM];
+} __attribute__((__packed__));
+
+struct me_bw_t {
+	uint32_t totalbw;
+	struct smi_port_t smiport[ME_SMI_PORT_NUM];
+} __attribute__((__packed__));
+
+struct pqdip_bw_t {
+	uint32_t totalbw;
+	struct smi_port_t smiport[PQ_DIP_SMI_PORT_NUM];
+} __attribute__((__packed__));
+
+struct traw_bw_t {
+	uint32_t totalbw;
+	struct smi_port_t smiport[TRAW_SMI_PORT_NUM];
+} __attribute__((__packed__));
+
+struct ltraw_bw_t {
+	uint32_t totalbw;
+	struct smi_port_t smiport[LTRAW_SMI_PORT_NUM];
+} __attribute__((__packed__));
+
+struct dip_bw_t {
+	uint32_t totalbw;
+	struct smi_port_t smiport[DIP_SMI_PORT_NUM];
+} __attribute__((__packed__));
+
+struct frame_bw_t {
+	struct wpe_bw_t wpe_eis;
+	struct wpe_bw_t wpe_tnr;
+	struct me_bw_t me;
+	struct pqdip_bw_t pqdip_a;
+	struct pqdip_bw_t pqdip_b;
+	struct traw_bw_t traw;
+	struct ltraw_bw_t ltraw;
+	struct dip_bw_t dip;
+} __attribute__((__packed__));
+
+#endif /* _MTK_IMGSYS_CMDQ_PLAT_H_ */
+
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_70/mtk_imgsys-debug.c b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_70/mtk_imgsys-debug.c
new file mode 100644
index 0000000000000000000000000000000000000000..9a0ec1f91b80d27b05dd37bdb6033815e8ea65a8
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_70/mtk_imgsys-debug.c
@@ -0,0 +1,876 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2021 MediaTek Inc.
+ *
+ * Author: Christopher Chen <christopher.chen@mediatek.com>
+ *
+ */
+
+#include <linux/device.h>
+#include <linux/of_address.h>
+#include <dma-iommu.h>
+#include <linux/pm_runtime.h>
+#include <linux/remoteproc.h>
+#include "mtk_imgsys-engine.h"
+#include "mtk_imgsys-debug.h"
+
+#define DL_CHECK_ENG_NUM 7
+#define SW_RST   (0x000C)
+
+struct imgsys_dbg_engine_t dbg_engine_name_list[DL_CHECK_ENG_NUM] = {
+	{IMGSYS_ENG_WPE_EIS, "WPE_EIS"},
+	{IMGSYS_ENG_WPE_TNR, "WPE_TNR"},
+	{IMGSYS_ENG_TRAW, "TRAW"},
+	{IMGSYS_ENG_LTR, "LTRAW"},
+	{IMGSYS_ENG_DIP, "DIP"},
+	{IMGSYS_ENG_PQDIP_A, "PQDIPA"},
+	{IMGSYS_ENG_PQDIP_B, "PQDIPB"},
+};
+
+void __iomem *imgsysmainRegBA;
+void __iomem *wpedip1RegBA;
+void __iomem *dipRegBA;
+void __iomem *dip1RegBA;
+
+void imgsys_main_init(struct mtk_imgsys_dev *imgsys_dev)
+{
+	pr_info("%s: +.\n", __func__);
+
+	imgsysmainRegBA = of_iomap(imgsys_dev->dev->of_node, REG_MAP_E_TOP);
+	if (!imgsysmainRegBA) {
+		dev_info(imgsys_dev->dev, "%s Unable to ioremap imgsys_top registers\n",
+								__func__);
+		dev_info(imgsys_dev->dev, "%s of_iomap fail, devnode(%s).\n",
+				__func__, imgsys_dev->dev->of_node->name);
+		return;
+	}
+
+	wpedip1RegBA = of_iomap(imgsys_dev->dev->of_node, REG_MAP_E_WPE1_DIP1);
+	if (!wpedip1RegBA) {
+		dev_info(imgsys_dev->dev, "%s Unable to ioremap wpe_dip1 registers\n",
+								__func__);
+		dev_info(imgsys_dev->dev, "%s of_iomap fail, devnode(%s).\n",
+				__func__, imgsys_dev->dev->of_node->name);
+		return;
+	}
+
+	dipRegBA = of_iomap(imgsys_dev->dev->of_node, REG_MAP_E_DIP_TOP);
+	if (!dipRegBA) {
+		dev_info(imgsys_dev->dev, "%s Unable to ioremap dip_top registers\n",
+								__func__);
+		dev_info(imgsys_dev->dev, "%s of_iomap fail, devnode(%s).\n",
+				__func__, imgsys_dev->dev->of_node->name);
+		return;
+	}
+
+	dip1RegBA = of_iomap(imgsys_dev->dev->of_node, REG_MAP_E_DIP_TOP_NR);
+	if (!dip1RegBA) {
+		dev_info(imgsys_dev->dev, "%s Unable to ioremap dip_top_nr registers\n",
+								__func__);
+		dev_info(imgsys_dev->dev, "%s of_iomap fail, devnode(%s).\n",
+				__func__, imgsys_dev->dev->of_node->name);
+		return;
+	}
+
+	pr_info("%s: -.\n", __func__);
+}
+
+void imgsys_main_set_init(struct mtk_imgsys_dev *imgsys_dev)
+{
+	void __iomem *pWpeCtrl = 0L;
+
+	pr_debug("%s: +.\n", __func__);
+
+	iowrite32(0xFFFFFFFC, (void *)(dipRegBA + SW_RST));
+	iowrite32(0xFFFFFFFF, (void *)(dip1RegBA + SW_RST));
+
+	/* Wpe Macro HW Reset */
+	pWpeCtrl = (void *)(wpedip1RegBA + SW_RST);
+	iowrite32(0xFFFFFFFC, pWpeCtrl);
+	/* Clear HW Reset */
+	iowrite32(0x0, pWpeCtrl);
+
+	iowrite32(0x00CF00FC, (void *)(imgsysmainRegBA + SW_RST));
+	iowrite32(0x0, (void *)(imgsysmainRegBA + SW_RST));
+
+	iowrite32(0x0, (void *)(dipRegBA + SW_RST));
+	iowrite32(0x0, (void *)(dip1RegBA + SW_RST));
+
+	/* Wpe Macro HW Reset */
+	pWpeCtrl = (void *)(wpedip1RegBA + SW_RST);
+	iowrite32(0xFFFFFFFC, pWpeCtrl);
+	/* Clear HW Reset */
+	iowrite32(0x0, pWpeCtrl);
+
+	iowrite32(0x00CF00FC, (void *)(imgsysmainRegBA + SW_RST));
+	iowrite32(0x0, (void *)(imgsysmainRegBA + SW_RST));
+
+	pr_debug("%s: -.\n", __func__);
+}
+
+void imgsys_main_uninit(struct mtk_imgsys_dev *imgsys_dev)
+{
+	pr_debug("%s: +.\n", __func__);
+
+	if (imgsysmainRegBA) {
+		iounmap(imgsysmainRegBA);
+		imgsysmainRegBA = 0L;
+	}
+
+	if (wpedip1RegBA) {
+		iounmap(wpedip1RegBA);
+		wpedip1RegBA = 0L;
+	}
+
+	if (dipRegBA) {
+		iounmap(dipRegBA);
+		dipRegBA = 0L;
+	}
+
+	if (dip1RegBA) {
+		iounmap(dip1RegBA);
+		dip1RegBA = 0L;
+	}
+
+	pr_debug("%s: -.\n", __func__);
+}
+
+void imgsys_debug_dump_routine(struct mtk_imgsys_dev *imgsys_dev,
+	const struct module_ops *imgsys_modules,
+	int imgsys_module_num, unsigned int hw_comb)
+{
+	bool module_on[IMGSYS_MOD_MAX] = {
+		false, false, false, false, false, false};
+	int i = 0;
+
+	dev_info(imgsys_dev->dev,
+			"%s: hw comb set: 0x%x\n",
+			__func__, hw_comb);
+
+	imgsys_dl_debug_dump(imgsys_dev, hw_comb);
+
+	if ((hw_comb & IMGSYS_ENG_WPE_EIS) || (hw_comb & IMGSYS_ENG_WPE_TNR))
+		module_on[IMGSYS_MOD_WPE] = true;
+	if ((hw_comb & IMGSYS_ENG_TRAW) || (hw_comb & IMGSYS_ENG_LTR))
+		module_on[IMGSYS_MOD_TRAW] = true;
+	if ((hw_comb & IMGSYS_ENG_DIP))
+		module_on[IMGSYS_MOD_DIP] = true;
+	if ((hw_comb & IMGSYS_ENG_PQDIP_A) || (hw_comb & IMGSYS_ENG_PQDIP_B))
+		module_on[IMGSYS_MOD_PQDIP] = true;
+	if ((hw_comb & IMGSYS_ENG_ME))
+		module_on[IMGSYS_MOD_ME] = true;
+
+	/* in case module driver did not set imgsys_modules in module order */
+	dev_info(imgsys_dev->dev,
+			"%s: imgsys_module_num: %d\n",
+			__func__, imgsys_module_num);
+	for (i = 0 ; i < imgsys_module_num ; i++) {
+		if (module_on[imgsys_modules[i].module_id])
+			imgsys_modules[i].dump(imgsys_dev, hw_comb);
+	}
+}
+EXPORT_SYMBOL(imgsys_debug_dump_routine);
+
+void imgsys_cg_debug_dump(struct mtk_imgsys_dev *imgsys_dev)
+{
+	unsigned int i = 0;
+
+	if (!imgsysmainRegBA) {
+		dev_info(imgsys_dev->dev, "%s Unable to ioremap imgsys_top registers\n",
+								__func__);
+		dev_info(imgsys_dev->dev, "%s of_iomap fail, devnode(%s).\n",
+				__func__, imgsys_dev->dev->of_node->name);
+		return;
+	}
+
+	for (i = 0; i <= 0x500; i += 0x10) {
+		dev_info(imgsys_dev->dev, "%s: [0x%08X 0x%08X][0x%08X 0x%08X][0x%08X 0x%08X][0x%08X 0x%08X]",
+		__func__, (unsigned int)(0x15000000 + i),
+		(unsigned int)ioread32((void *)(imgsysmainRegBA + i)),
+		(unsigned int)(0x15000000 + i + 0x4),
+		(unsigned int)ioread32((void *)(imgsysmainRegBA + i + 0x4)),
+		(unsigned int)(0x15000000 + i + 0x8),
+		(unsigned int)ioread32((void *)(imgsysmainRegBA + i + 0x8)),
+		(unsigned int)(0x15000000 + i + 0xc),
+		(unsigned int)ioread32((void *)(imgsysmainRegBA + i + 0xc)));
+	}
+
+	if (!dipRegBA) {
+		dev_info(imgsys_dev->dev, "%s Unable to ioremap dip registers\n",
+								__func__);
+		dev_info(imgsys_dev->dev, "%s of_iomap fail, devnode(%s).\n",
+				__func__, imgsys_dev->dev->of_node->name);
+		return;
+	}
+
+	for (i = 0; i <= 0x100; i += 0x10) {
+		dev_info(imgsys_dev->dev, "%s: [0x%08X 0x%08X][0x%08X 0x%08X][0x%08X 0x%08X][0x%08X 0x%08X]",
+		__func__, (unsigned int)(0x15110000 + i),
+		(unsigned int)ioread32((void *)(dipRegBA + i)),
+		(unsigned int)(0x15110000 + i + 0x4),
+		(unsigned int)ioread32((void *)(dipRegBA + i + 0x4)),
+		(unsigned int)(0x15110000 + i + 0x8),
+		(unsigned int)ioread32((void *)(dipRegBA + i + 0x8)),
+		(unsigned int)(0x15110000 + i + 0xc),
+		(unsigned int)ioread32((void *)(dipRegBA + i + 0xc)));
+	}
+
+	if (!dip1RegBA) {
+		dev_info(imgsys_dev->dev, "%s Unable to ioremap dip1 registers\n",
+								__func__);
+		dev_info(imgsys_dev->dev, "%s of_iomap fail, devnode(%s).\n",
+				__func__, imgsys_dev->dev->of_node->name);
+		return;
+	}
+
+	for (i = 0; i <= 0x100; i += 0x10) {
+		dev_info(imgsys_dev->dev, "%s: [0x%08X 0x%08X][0x%08X 0x%08X][0x%08X 0x%08X][0x%08X 0x%08X]",
+		__func__, (unsigned int)(0x15130000 + i),
+		(unsigned int)ioread32((void *)(dip1RegBA + i)),
+		(unsigned int)(0x15130000 + i + 0x4),
+		(unsigned int)ioread32((void *)(dip1RegBA + i + 0x4)),
+		(unsigned int)(0x15130000 + i + 0x8),
+		(unsigned int)ioread32((void *)(dip1RegBA + i + 0x8)),
+		(unsigned int)(0x15130000 + i + 0xc),
+		(unsigned int)ioread32((void *)(dip1RegBA + i + 0xc)));
+	}
+
+	if (!wpedip1RegBA) {
+		dev_info(imgsys_dev->dev, "%s Unable to ioremap wpe_dip1 registers\n",
+								__func__);
+		dev_info(imgsys_dev->dev, "%s of_iomap fail, devnode(%s).\n",
+				__func__, imgsys_dev->dev->of_node->name);
+		return;
+	}
+
+	for (i = 0; i <= 0x100; i += 0x10) {
+		dev_info(imgsys_dev->dev, "%s: [0x%08X 0x%08X][0x%08X 0x%08X][0x%08X 0x%08X][0x%08X 0x%08X]",
+		__func__, (unsigned int)(0x15220000 + i),
+		(unsigned int)ioread32((void *)(wpedip1RegBA + i)),
+		(unsigned int)(0x15220000 + i + 0x4),
+		(unsigned int)ioread32((void *)(wpedip1RegBA + i + 0x4)),
+		(unsigned int)(0x15220000 + i + 0x8),
+		(unsigned int)ioread32((void *)(wpedip1RegBA + i + 0x8)),
+		(unsigned int)(0x15220000 + i + 0xc),
+		(unsigned int)ioread32((void *)(wpedip1RegBA + i + 0xc)));
+	}
+
+}
+
+#define log_length (64)
+void imgsys_dl_checksum_dump(struct mtk_imgsys_dev *imgsys_dev,
+	unsigned int hw_comb, char *logBuf_path,
+	char *logBuf_inport, char *logBuf_outport, int dl_path)
+{
+	/*void __iomem *imgsysmainRegBA = 0L;*/
+	/*void __iomem *wpedip1RegBA = 0L;*/
+	/*void __iomem *wpedip2RegBA = 0L;*/
+	/*void __iomem *wpedip3RegBA = 0L;*/
+	unsigned int checksum_dbg_sel = 0x0;
+	unsigned int original_dbg_sel_value = 0x0;
+	char logBuf_final[log_length * 4];
+	int debug0_req[2] = {0, 0};
+	int debug0_rdy[2] = {0, 0};
+	int debug0_checksum[2] = {0, 0};
+	int debug1_line_cnt[2] = {0, 0};
+	int debug1_pix_cnt[2] = {0, 0};
+	int debug2_line_cnt[2] = {0, 0};
+	int debug2_pix_cnt[2] = {0, 0};
+	unsigned int dbg_sel_value[2] = {0x0, 0x0};
+	unsigned int debug0_value[2] = {0x0, 0x0};
+	unsigned int debug1_value[2] = {0x0, 0x0};
+	unsigned int debug2_value[2] = {0x0, 0x0};
+	unsigned int wpe_pqdip_mux_v = 0x0;
+	char logBuf_temp[log_length];
+
+	memset((char *)logBuf_final, 0x0, log_length * 4);
+	logBuf_final[strlen(logBuf_final)] = '\0';
+	memset((char *)logBuf_temp, 0x0, log_length);
+	logBuf_temp[strlen(logBuf_temp)] = '\0';
+
+	dev_info(imgsys_dev->dev,
+		"%s: + hw_comb/path(0x%x/%s) dl_path:%d, start dump\n",
+		__func__, hw_comb, logBuf_path, dl_path);
+	/* iomap registers */
+	/*imgsysmainRegBA = of_iomap(imgsys_dev->dev->of_node, REG_MAP_E_TOP);*/
+	if (!imgsysmainRegBA) {
+		dev_info(imgsys_dev->dev, "%s Unable to ioremap imgsys_top registers\n",
+								__func__);
+		dev_info(imgsys_dev->dev, "%s of_iomap fail, devnode(%s).\n",
+				__func__, imgsys_dev->dev->of_node->name);
+		return;
+	}
+
+	/*dump former engine in DL (imgsys main in port) status */
+	checksum_dbg_sel = (unsigned int)((dl_path << 1) | (0 << 0));
+	original_dbg_sel_value = (unsigned int)ioread32((void *)(imgsysmainRegBA + 0x4C));
+	original_dbg_sel_value = original_dbg_sel_value & 0xff00ffff; /*clear last time data*/
+	dbg_sel_value[0] = (original_dbg_sel_value | 0x1 |
+		((checksum_dbg_sel << 16) & 0x00ff0000));
+	writel(dbg_sel_value[0], (imgsysmainRegBA + 0x4C));
+	dbg_sel_value[0] = (unsigned int)ioread32((void *)(imgsysmainRegBA + 0x4C));
+	debug0_value[0] = (unsigned int)ioread32((void *)(imgsysmainRegBA + 0x200));
+	debug0_checksum[0] = (debug0_value[0] & 0x0000ffff);
+	debug0_rdy[0] = (debug0_value[0] & 0x00800000) >> 23;
+	debug0_req[0] = (debug0_value[0] & 0x01000000) >> 24;
+	debug1_value[0] = (unsigned int)ioread32((void *)(imgsysmainRegBA + 0x204));
+	debug1_line_cnt[0] = ((debug1_value[0] & 0xffff0000) >> 16) & 0x0000ffff;
+	debug1_pix_cnt[0] = (debug1_value[0] & 0x0000ffff);
+	debug2_value[0] = (unsigned int)ioread32((void *)(imgsysmainRegBA + 0x208));
+	debug2_line_cnt[0] = ((debug2_value[0] & 0xffff0000) >> 16) & 0x0000ffff;
+	debug2_pix_cnt[0] = (debug2_value[0] & 0x0000ffff);
+
+	/*dump later engine in DL (imgsys main out port) status */
+	checksum_dbg_sel = (unsigned int)((dl_path << 1) | (1 << 0));
+	dbg_sel_value[1] = (original_dbg_sel_value | 0x1 |
+		((checksum_dbg_sel << 16) & 0x00ff0000));
+	writel(dbg_sel_value[1], (imgsysmainRegBA + 0x4C));
+	dbg_sel_value[1] = (unsigned int)ioread32((void *)(imgsysmainRegBA + 0x4C));
+	debug0_value[1] = (unsigned int)ioread32((void *)(imgsysmainRegBA + 0x200));
+	debug0_checksum[1] = (debug0_value[1] & 0x0000ffff);
+	debug0_rdy[1] = (debug0_value[1] & 0x00800000) >> 23;
+	debug0_req[1] = (debug0_value[1] & 0x01000000) >> 24;
+	debug1_value[1] = (unsigned int)ioread32((void *)(imgsysmainRegBA + 0x204));
+	debug1_line_cnt[1] = ((debug1_value[1] & 0xffff0000) >> 16) & 0x0000ffff;
+	debug1_pix_cnt[1] = (debug1_value[1] & 0x0000ffff);
+	debug2_value[1] = (unsigned int)ioread32((void *)(imgsysmainRegBA + 0x208));
+	debug2_line_cnt[1] = ((debug2_value[1] & 0xffff0000) >> 16) & 0x0000ffff;
+	debug2_pix_cnt[1] = (debug2_value[1] & 0x0000ffff);
+
+	/* macro_comm status */
+	/*if (dl_path == IMGSYS_DL_WPE_PQDIP) {*/
+	/*wpedip1RegBA = of_iomap(imgsys_dev->dev->of_node, REG_MAP_E_WPE1_DIP1);*/
+	if (!wpedip1RegBA) {
+		dev_info(imgsys_dev->dev, "%s Unable to ioremap wpe_dip1 registers\n",
+								__func__);
+		dev_info(imgsys_dev->dev, "%s of_iomap fail, devnode(%s).\n",
+				__func__, imgsys_dev->dev->of_node->name);
+		return;
+	}
+	wpe_pqdip_mux_v = (unsigned int)ioread32((void *)(wpedip1RegBA + 0xA8));
+	/*iounmap(wpedip1RegBA);*/
+
+	/*}*/
+
+	/* dump information */
+	if (dl_path == IMGSYS_DL_WPET_TRAW) {
+	} else {
+		if (debug0_req[0] == 1) {
+			snprintf(logBuf_temp, log_length,
+				"%s req to send data to %s/",
+				logBuf_inport, logBuf_outport);
+		} else {
+			snprintf(logBuf_temp, log_length,
+				"%s not send data to %s/",
+				logBuf_inport, logBuf_outport);
+		}
+		strncat(logBuf_final, logBuf_temp, strlen(logBuf_temp));
+		memset((char *)logBuf_temp, 0x0, log_length);
+		logBuf_temp[strlen(logBuf_temp)] = '\0';
+		if (debug0_rdy[0] == 1) {
+			snprintf(logBuf_temp, log_length,
+				"%s rdy to receive data from %s",
+				logBuf_outport, logBuf_inport);
+		} else {
+			snprintf(logBuf_temp, log_length,
+				"%s not rdy to receive data from %s",
+				logBuf_outport, logBuf_inport);
+		}
+		strncat(logBuf_final, logBuf_temp, strlen(logBuf_temp));
+		dev_info(imgsys_dev->dev,
+			"%s: %s", __func__, logBuf_final);
+
+		memset((char *)logBuf_final, 0x0, log_length * 4);
+		logBuf_final[strlen(logBuf_final)] = '\0';
+		memset((char *)logBuf_temp, 0x0, log_length);
+		logBuf_temp[strlen(logBuf_temp)] = '\0';
+		if (debug0_req[1] == 1) {
+			snprintf(logBuf_temp, log_length,
+				"%s req to send data to %sPIPE/",
+				logBuf_outport, logBuf_outport);
+		} else {
+			snprintf(logBuf_temp, log_length,
+				"%s not send data to %sPIPE/",
+				logBuf_outport, logBuf_outport);
+		}
+		strncat(logBuf_final, logBuf_temp, strlen(logBuf_temp));
+		memset((char *)logBuf_temp, 0x0, log_length);
+		logBuf_temp[strlen(logBuf_temp)] = '\0';
+		if (debug0_rdy[1] == 1) {
+			snprintf(logBuf_temp, log_length,
+				"%sPIPE rdy to receive data from %s",
+				logBuf_outport, logBuf_outport);
+		} else {
+			snprintf(logBuf_temp, log_length,
+				"%sPIPE not rdy to receive data from %s",
+				logBuf_outport, logBuf_outport);
+		}
+		strncat(logBuf_final, logBuf_temp, strlen(logBuf_temp));
+		dev_info(imgsys_dev->dev,
+			"%s: %s", __func__, logBuf_final);
+		dev_info(imgsys_dev->dev,
+			"%s: in_req/in_rdy/out_req/out_rdy = %d/%d/%d/%d,(cheskcum: in/out) = (%d/%d)",
+			__func__,
+			debug0_req[0], debug0_rdy[0],
+			debug0_req[1], debug0_rdy[1],
+			debug0_checksum[0], debug0_checksum[1]);
+		dev_info(imgsys_dev->dev,
+			"%s: info01 in_line/in_pix/out_line/out_pix = %d/%d/%d/%d",
+			__func__,
+			debug1_line_cnt[0], debug1_pix_cnt[0], debug1_line_cnt[1],
+			debug1_pix_cnt[1]);
+		dev_info(imgsys_dev->dev,
+			"%s: info02 in_line/in_pix/out_line/out_pix = %d/%d/%d/%d",
+			__func__,
+			debug2_line_cnt[0], debug2_pix_cnt[0], debug2_line_cnt[1],
+			debug2_pix_cnt[1]);
+	}
+	dev_info(imgsys_dev->dev, "%s: ===(%s): %s DBG INFO===",
+		__func__, logBuf_path, logBuf_inport);
+	dev_info(imgsys_dev->dev, "%s:  0x%08X %08X", __func__,
+		(unsigned int)(0x15000000 + 0x4C), dbg_sel_value[0]);
+	dev_info(imgsys_dev->dev, "%s:  0x%08X %08X", __func__,
+		(unsigned int)(0x15000000 + 0x200), debug0_value[0]);
+	dev_info(imgsys_dev->dev, "%s:  0x%08X %08X", __func__,
+		(unsigned int)(0x15000000 + 0x204), debug1_value[0]);
+	dev_info(imgsys_dev->dev, "%s:  0x%08X %08X", __func__,
+		(unsigned int)(0x15000000 + 0x208), debug2_value[0]);
+
+	dev_info(imgsys_dev->dev, "%s: ===(%s): %s DBG INFO===",
+		__func__, logBuf_path, logBuf_outport);
+	dev_info(imgsys_dev->dev, "%s:  0x%08X %08X", __func__,
+		(unsigned int)(0x15000000 + 0x4C), dbg_sel_value[1]);
+	dev_info(imgsys_dev->dev, "%s:  0x%08X %08X", __func__,
+		(unsigned int)(0x15000000 + 0x200), debug0_value[1]);
+	dev_info(imgsys_dev->dev, "%s:  0x%08X %08X", __func__,
+		(unsigned int)(0x15000000 + 0x204), debug1_value[1]);
+	dev_info(imgsys_dev->dev, "%s:  0x%08X %08X", __func__,
+		(unsigned int)(0x15000000 + 0x208), debug2_value[1]);
+
+	dev_info(imgsys_dev->dev, "%s: ===(%s): IMGMAIN CG INFO===",
+		__func__, logBuf_path);
+	dev_info(imgsys_dev->dev, "%s: CG_CON  0x%08X %08X", __func__,
+		(unsigned int)(0x15000000 + 0x0),
+		(unsigned int)ioread32((void *)(imgsysmainRegBA + 0x0)));
+	dev_info(imgsys_dev->dev, "%s: CG_SET  0x%08X %08X", __func__,
+		(unsigned int)(0x15000000 + 0x4),
+		(unsigned int)ioread32((void *)(imgsysmainRegBA + 0x4)));
+	dev_info(imgsys_dev->dev, "%s: CG_CLR  0x%08X %08X", __func__,
+		(unsigned int)(0x15000000 + 0x8),
+		(unsigned int)ioread32((void *)(imgsysmainRegBA + 0x8)));
+
+	/*if (dl_path == IMGSYS_DL_WPE_PQDIP) {*/
+	dev_info(imgsys_dev->dev, "%s:  0x%08X %08X", __func__,
+		(unsigned int)(0x15220000 + 0xA8), wpe_pqdip_mux_v);
+	/*}*/
+	/*iounmap(imgsysmainRegBA);*/
+}
+
+void imgsys_dl_debug_dump(struct mtk_imgsys_dev *imgsys_dev, unsigned int hw_comb)
+{
+	int dl_path = 0;
+	char logBuf_path[log_length];
+	char logBuf_inport[log_length];
+	char logBuf_outport[log_length];
+	char logBuf_eng[log_length];
+	int i = 0, get = false;
+
+	memset((char *)logBuf_path, 0x0, log_length);
+	logBuf_path[strlen(logBuf_path)] = '\0';
+	memset((char *)logBuf_inport, 0x0, log_length);
+	logBuf_inport[strlen(logBuf_inport)] = '\0';
+	memset((char *)logBuf_outport, 0x0, log_length);
+	logBuf_outport[strlen(logBuf_outport)] = '\0';
+
+	for (i = 0 ; i < DL_CHECK_ENG_NUM ; i++) {
+		memset((char *)logBuf_eng, 0x0, log_length);
+		logBuf_eng[strlen(logBuf_eng)] = '\0';
+		if (hw_comb & dbg_engine_name_list[i].eng_e) {
+			if (get) {
+				snprintf(logBuf_eng, log_length, "-%s",
+					dbg_engine_name_list[i].eng_name);
+			} else {
+				snprintf(logBuf_eng, log_length, "%s",
+					dbg_engine_name_list[i].eng_name);
+			}
+			get = true;
+		}
+		strncat(logBuf_path, logBuf_eng, strlen(logBuf_eng));
+	}
+	memset((char *)logBuf_eng, 0x0, log_length);
+	logBuf_eng[strlen(logBuf_eng)] = '\0';
+	snprintf(logBuf_eng, log_length, "%s", " FAIL");
+	strncat(logBuf_path, logBuf_eng, strlen(logBuf_eng));
+
+	dev_info(imgsys_dev->dev, "%s: %s\n",
+			__func__, logBuf_path);
+	switch (hw_comb) {
+	/*DL checksum case*/
+	case (IMGSYS_ENG_WPE_EIS | IMGSYS_ENG_TRAW):
+		dl_path = IMGSYS_DL_WPEE_TRAW;
+		snprintf(logBuf_inport, log_length, "%s",
+			"WPE_EIS");
+		snprintf(logBuf_outport, log_length, "%s",
+			"TRAW");
+		imgsys_dl_checksum_dump(imgsys_dev, hw_comb,
+			logBuf_path, logBuf_inport, logBuf_outport, dl_path);
+		break;
+	case (IMGSYS_ENG_WPE_EIS | IMGSYS_ENG_LTR):
+		dl_path = IMGSYS_DL_WPEE_TRAW;
+		snprintf(logBuf_inport, log_length, "%s",
+			"WPE_EIS");
+		snprintf(logBuf_outport, log_length, "%s",
+			"LTRAW");
+		imgsys_dl_checksum_dump(imgsys_dev, hw_comb,
+			logBuf_path, logBuf_inport, logBuf_outport, dl_path);
+		break;
+	case (IMGSYS_ENG_WPE_TNR | IMGSYS_ENG_TRAW):
+		dl_path = IMGSYS_DL_WPET_TRAW;
+		snprintf(logBuf_inport, log_length, "%s",
+			"WPE_TNR");
+		snprintf(logBuf_outport, log_length, "%s",
+			"TRAW");
+		imgsys_dl_checksum_dump(imgsys_dev, hw_comb,
+			logBuf_path, logBuf_inport, logBuf_outport, dl_path);
+		break;
+	case (IMGSYS_ENG_WPE_TNR | IMGSYS_ENG_LTR):
+		dl_path = IMGSYS_DL_WPET_TRAW;
+		snprintf(logBuf_inport, log_length, "%s",
+			"WPE_TNR");
+		snprintf(logBuf_outport, log_length, "%s",
+			"LTRAW");
+		imgsys_dl_checksum_dump(imgsys_dev, hw_comb,
+			logBuf_path, logBuf_inport, logBuf_outport, dl_path);
+		break;
+	case (IMGSYS_ENG_WPE_EIS | IMGSYS_ENG_DIP):
+	case (IMGSYS_ENG_WPE_EIS | IMGSYS_ENG_DIP | IMGSYS_ENG_PQDIP_A):
+	case (IMGSYS_ENG_WPE_EIS | IMGSYS_ENG_DIP | IMGSYS_ENG_PQDIP_B):
+	case (IMGSYS_ENG_WPE_EIS | IMGSYS_ENG_DIP | IMGSYS_ENG_PQDIP_A |
+		IMGSYS_ENG_PQDIP_B):
+		dl_path = IMGSYS_DL_WPEE_DIP;
+		snprintf(logBuf_inport, log_length, "%s",
+			"WPE_EIS");
+		snprintf(logBuf_outport, log_length, "%s",
+			 "DIP");
+		imgsys_dl_checksum_dump(imgsys_dev, hw_comb,
+			logBuf_path, logBuf_inport, logBuf_outport, dl_path);
+		/**/
+		memset((char *)logBuf_inport, 0x0, log_length);
+		logBuf_inport[strlen(logBuf_inport)] = '\0';
+		memset((char *)logBuf_outport, 0x0, log_length);
+		logBuf_outport[strlen(logBuf_outport)] = '\0';
+		dl_path = IMGSYS_DL_DIP_PQDIPA;
+		snprintf(logBuf_inport, log_length, "%s",
+			"DIP");
+		snprintf(logBuf_outport, log_length, "%s",
+			"PQDIPA");
+		imgsys_dl_checksum_dump(imgsys_dev, hw_comb,
+			logBuf_path, logBuf_inport, logBuf_outport, dl_path);
+		/**/
+		memset((char *)logBuf_inport, 0x0, log_length);
+		logBuf_inport[strlen(logBuf_inport)] = '\0';
+		memset((char *)logBuf_outport, 0x0, log_length);
+		logBuf_outport[strlen(logBuf_outport)] = '\0';
+		dl_path = IMGSYS_DL_DIP_PQDIPB;
+		snprintf(logBuf_inport, log_length, "%s",
+			"DIP");
+		snprintf(logBuf_outport, log_length, "%s",
+			"PQDIPB");
+		imgsys_dl_checksum_dump(imgsys_dev, hw_comb,
+			logBuf_path, logBuf_inport, logBuf_outport, dl_path);
+		break;
+	case (IMGSYS_ENG_WPE_TNR | IMGSYS_ENG_DIP):
+	case (IMGSYS_ENG_WPE_TNR | IMGSYS_ENG_DIP | IMGSYS_ENG_PQDIP_A):
+	case (IMGSYS_ENG_WPE_TNR | IMGSYS_ENG_DIP | IMGSYS_ENG_PQDIP_B):
+	case (IMGSYS_ENG_WPE_TNR | IMGSYS_ENG_DIP | IMGSYS_ENG_PQDIP_A |
+		IMGSYS_ENG_PQDIP_B):
+		dl_path = IMGSYS_DL_WPET_DIP;
+		snprintf(logBuf_inport, log_length, "%s",
+			"WPE_TNR");
+		snprintf(logBuf_outport, log_length, "%s",
+			"DIP");
+		imgsys_dl_checksum_dump(imgsys_dev, hw_comb,
+			logBuf_path, logBuf_inport, logBuf_outport, dl_path);
+		/**/
+		memset((char *)logBuf_inport, 0x0, log_length);
+		logBuf_inport[strlen(logBuf_inport)] = '\0';
+		memset((char *)logBuf_outport, 0x0, log_length);
+		logBuf_outport[strlen(logBuf_outport)] = '\0';
+		dl_path = IMGSYS_DL_DIP_PQDIPA;
+		snprintf(logBuf_inport, log_length, "%s",
+			"DIP");
+		snprintf(logBuf_outport, log_length, "%s",
+			"PQDIPA");
+		imgsys_dl_checksum_dump(imgsys_dev, hw_comb,
+			logBuf_path, logBuf_inport, logBuf_outport, dl_path);
+		/**/
+		memset((char *)logBuf_inport, 0x0, log_length);
+		logBuf_inport[strlen(logBuf_inport)] = '\0';
+		memset((char *)logBuf_outport, 0x0, log_length);
+		logBuf_outport[strlen(logBuf_outport)] = '\0';
+		dl_path = IMGSYS_DL_DIP_PQDIPB;
+		snprintf(logBuf_inport, log_length, "%s",
+			"DIP");
+		snprintf(logBuf_outport, log_length, "%s",
+			"PQDIPB");
+		imgsys_dl_checksum_dump(imgsys_dev, hw_comb,
+			logBuf_path, logBuf_inport, logBuf_outport, dl_path);
+		break;
+	case (IMGSYS_ENG_WPE_EIS | IMGSYS_ENG_PQDIP_A):
+	case (IMGSYS_ENG_WPE_EIS | IMGSYS_ENG_PQDIP_B):
+	case (IMGSYS_ENG_WPE_EIS | IMGSYS_ENG_PQDIP_A |
+		IMGSYS_ENG_PQDIP_B):
+		dl_path = IMGSYS_DL_WPE_PQDIP;
+		snprintf(logBuf_inport, log_length, "%s",
+			"WPE_EIS");
+		snprintf(logBuf_outport, log_length, "%s",
+			"PQDIP");
+		imgsys_dl_checksum_dump(imgsys_dev, hw_comb,
+			logBuf_path, logBuf_inport, logBuf_outport, dl_path);
+		break;
+	case (IMGSYS_ENG_WPE_TNR | IMGSYS_ENG_PQDIP_A):
+	case (IMGSYS_ENG_WPE_TNR | IMGSYS_ENG_PQDIP_B):
+	case (IMGSYS_ENG_WPE_TNR | IMGSYS_ENG_PQDIP_A |
+		IMGSYS_ENG_PQDIP_B):
+		dl_path = IMGSYS_DL_WPE_PQDIP;
+		snprintf(logBuf_inport, log_length, "%s",
+			"WPE_TNR");
+		snprintf(logBuf_outport, log_length, "%s",
+			"PQDIP");
+		imgsys_dl_checksum_dump(imgsys_dev, hw_comb,
+			logBuf_path, logBuf_inport, logBuf_outport, dl_path);
+		break;
+	case (IMGSYS_ENG_WPE_EIS | IMGSYS_ENG_TRAW | IMGSYS_ENG_DIP):
+	case (IMGSYS_ENG_WPE_EIS | IMGSYS_ENG_TRAW | IMGSYS_ENG_DIP |
+		IMGSYS_ENG_PQDIP_A):
+	case (IMGSYS_ENG_WPE_EIS | IMGSYS_ENG_TRAW | IMGSYS_ENG_DIP |
+		IMGSYS_ENG_PQDIP_B):
+	case (IMGSYS_ENG_WPE_EIS | IMGSYS_ENG_TRAW | IMGSYS_ENG_DIP |
+		IMGSYS_ENG_PQDIP_A | IMGSYS_ENG_PQDIP_B):
+		dl_path = IMGSYS_DL_WPEE_TRAW;
+		snprintf(logBuf_inport, log_length, "%s",
+			"WPE_EIS");
+		snprintf(logBuf_outport, log_length, "%s",
+			"TRAW");
+		imgsys_dl_checksum_dump(imgsys_dev, hw_comb,
+			logBuf_path, logBuf_inport, logBuf_outport, dl_path);
+		/**/
+		memset((char *)logBuf_inport, 0x0, log_length);
+		logBuf_inport[strlen(logBuf_inport)] = '\0';
+		memset((char *)logBuf_outport, 0x0, log_length);
+		logBuf_outport[strlen(logBuf_outport)] = '\0';
+		dl_path = IMGSYS_DL_TRAW_DIP;
+		snprintf(logBuf_inport, log_length, "%s",
+			"TRAW");
+		snprintf(logBuf_outport, log_length, "%s",
+			"DIP");
+		imgsys_dl_checksum_dump(imgsys_dev, hw_comb,
+			logBuf_path, logBuf_inport, logBuf_outport, dl_path);
+		/**/
+		memset((char *)logBuf_inport, 0x0, log_length);
+		logBuf_inport[strlen(logBuf_inport)] = '\0';
+		memset((char *)logBuf_outport, 0x0, log_length);
+		logBuf_outport[strlen(logBuf_outport)] = '\0';
+		dl_path = IMGSYS_DL_DIP_PQDIPA;
+		snprintf(logBuf_inport, log_length, "%s",
+			"DIP");
+		snprintf(logBuf_outport, log_length, "%s",
+			"PQDIPA");
+		imgsys_dl_checksum_dump(imgsys_dev, hw_comb,
+			logBuf_path, logBuf_inport, logBuf_outport, dl_path);
+		/**/
+		memset((char *)logBuf_inport, 0x0, log_length);
+		logBuf_inport[strlen(logBuf_inport)] = '\0';
+		memset((char *)logBuf_outport, 0x0, log_length);
+		logBuf_outport[strlen(logBuf_outport)] = '\0';
+		dl_path = IMGSYS_DL_DIP_PQDIPB;
+		snprintf(logBuf_inport, log_length, "%s",
+			"DIP");
+		snprintf(logBuf_outport, log_length, "%s",
+			"PQDIPB");
+		imgsys_dl_checksum_dump(imgsys_dev, hw_comb,
+			logBuf_path, logBuf_inport, logBuf_outport, dl_path);
+		break;
+	case (IMGSYS_ENG_WPE_TNR | IMGSYS_ENG_TRAW | IMGSYS_ENG_DIP):
+	case (IMGSYS_ENG_WPE_TNR | IMGSYS_ENG_TRAW | IMGSYS_ENG_DIP |
+		IMGSYS_ENG_PQDIP_A):
+	case (IMGSYS_ENG_WPE_TNR | IMGSYS_ENG_TRAW | IMGSYS_ENG_DIP |
+		IMGSYS_ENG_PQDIP_B):
+	case (IMGSYS_ENG_WPE_TNR | IMGSYS_ENG_TRAW | IMGSYS_ENG_DIP |
+		IMGSYS_ENG_PQDIP_A | IMGSYS_ENG_PQDIP_B):
+		dl_path = IMGSYS_DL_TRAW_DIP;
+		snprintf(logBuf_inport, log_length, "%s",
+			"TRAW");
+		snprintf(logBuf_outport, log_length, "%s",
+			"DIP");
+		imgsys_dl_checksum_dump(imgsys_dev, hw_comb,
+			logBuf_path, logBuf_inport, logBuf_outport, dl_path);
+		/**/
+		memset((char *)logBuf_inport, 0x0, log_length);
+		logBuf_inport[strlen(logBuf_inport)] = '\0';
+		memset((char *)logBuf_outport, 0x0, log_length);
+		logBuf_outport[strlen(logBuf_outport)] = '\0';
+		dl_path = IMGSYS_DL_WPET_DIP;
+		snprintf(logBuf_inport, log_length, "%s",
+			"WPE_TNR");
+		snprintf(logBuf_outport, log_length, "%s",
+			"DIP");
+		imgsys_dl_checksum_dump(imgsys_dev, hw_comb,
+			logBuf_path, logBuf_inport, logBuf_outport, dl_path);
+		/**/
+		memset((char *)logBuf_inport, 0x0, log_length);
+		logBuf_inport[strlen(logBuf_inport)] = '\0';
+		memset((char *)logBuf_outport, 0x0, log_length);
+		logBuf_outport[strlen(logBuf_outport)] = '\0';
+		dl_path = IMGSYS_DL_DIP_PQDIPA;
+		snprintf(logBuf_inport, log_length, "%s",
+			"DIP");
+		snprintf(logBuf_outport, log_length, "%s",
+			"PQDIPA");
+		imgsys_dl_checksum_dump(imgsys_dev, hw_comb,
+			logBuf_path, logBuf_inport, logBuf_outport, dl_path);
+		/**/
+		memset((char *)logBuf_inport, 0x0, log_length);
+		logBuf_inport[strlen(logBuf_inport)] = '\0';
+		memset((char *)logBuf_outport, 0x0, log_length);
+		logBuf_outport[strlen(logBuf_outport)] = '\0';
+		dl_path = IMGSYS_DL_DIP_PQDIPB;
+		snprintf(logBuf_inport, log_length, "%s",
+			"DIP");
+		snprintf(logBuf_outport, log_length, "%s",
+			"PQDIPB");
+		imgsys_dl_checksum_dump(imgsys_dev, hw_comb,
+			logBuf_path, logBuf_inport, logBuf_outport, dl_path);
+		break;
+	case (IMGSYS_ENG_WPE_EIS | IMGSYS_ENG_WPE_TNR | IMGSYS_ENG_DIP):
+	case (IMGSYS_ENG_WPE_EIS | IMGSYS_ENG_WPE_TNR | IMGSYS_ENG_DIP |
+		IMGSYS_ENG_PQDIP_A):
+	case (IMGSYS_ENG_WPE_EIS | IMGSYS_ENG_WPE_TNR | IMGSYS_ENG_DIP |
+		IMGSYS_ENG_PQDIP_B):
+	case (IMGSYS_ENG_WPE_EIS | IMGSYS_ENG_WPE_TNR | IMGSYS_ENG_DIP |
+		IMGSYS_ENG_PQDIP_A | IMGSYS_ENG_PQDIP_B):
+		dl_path = IMGSYS_DL_WPEE_DIP;
+		snprintf(logBuf_inport, log_length, "%s",
+			"WPE_EIS");
+		snprintf(logBuf_outport, log_length, "%s",
+			"DIP");
+		imgsys_dl_checksum_dump(imgsys_dev, hw_comb,
+			logBuf_path, logBuf_inport, logBuf_outport, dl_path);
+		/**/
+		memset((char *)logBuf_inport, 0x0, log_length);
+		logBuf_inport[strlen(logBuf_inport)] = '\0';
+		memset((char *)logBuf_outport, 0x0, log_length);
+		logBuf_outport[strlen(logBuf_outport)] = '\0';
+		dl_path = IMGSYS_DL_WPET_DIP;
+		snprintf(logBuf_inport, log_length, "%s",
+			"WPE_TNR");
+		snprintf(logBuf_outport, log_length, "%s",
+			"DIP");
+		imgsys_dl_checksum_dump(imgsys_dev, hw_comb,
+			logBuf_path, logBuf_inport, logBuf_outport, dl_path);
+		/**/
+		memset((char *)logBuf_inport, 0x0, log_length);
+		logBuf_inport[strlen(logBuf_inport)] = '\0';
+		memset((char *)logBuf_outport, 0x0, log_length);
+		logBuf_outport[strlen(logBuf_outport)] = '\0';
+		dl_path = IMGSYS_DL_DIP_PQDIPA;
+		snprintf(logBuf_inport, log_length, "%s",
+			"DIP");
+		snprintf(logBuf_outport, log_length, "%s",
+			"PQDIPA");
+		imgsys_dl_checksum_dump(imgsys_dev, hw_comb,
+			logBuf_path, logBuf_inport, logBuf_outport, dl_path);
+		/**/
+		memset((char *)logBuf_inport, 0x0, log_length);
+		logBuf_inport[strlen(logBuf_inport)] = '\0';
+		memset((char *)logBuf_outport, 0x0, log_length);
+		logBuf_outport[strlen(logBuf_outport)] = '\0';
+		dl_path = IMGSYS_DL_DIP_PQDIPB;
+		snprintf(logBuf_inport, log_length, "%s",
+			"DIP");
+		snprintf(logBuf_outport, log_length, "%s",
+			"PQDIPB");
+		imgsys_dl_checksum_dump(imgsys_dev, hw_comb,
+			logBuf_path, logBuf_inport, logBuf_outport, dl_path);
+		break;
+	case (IMGSYS_ENG_WPE_EIS | IMGSYS_ENG_WPE_TNR | IMGSYS_ENG_TRAW |
+		IMGSYS_ENG_DIP):
+	case (IMGSYS_ENG_WPE_EIS | IMGSYS_ENG_WPE_TNR | IMGSYS_ENG_TRAW |
+		IMGSYS_ENG_DIP | IMGSYS_ENG_PQDIP_A):
+	case (IMGSYS_ENG_WPE_EIS | IMGSYS_ENG_WPE_TNR | IMGSYS_ENG_TRAW |
+		IMGSYS_ENG_DIP | IMGSYS_ENG_PQDIP_B):
+	case (IMGSYS_ENG_WPE_EIS | IMGSYS_ENG_WPE_TNR | IMGSYS_ENG_TRAW |
+		IMGSYS_ENG_DIP | IMGSYS_ENG_PQDIP_A | IMGSYS_ENG_PQDIP_B):
+		dev_info(imgsys_dev->dev,
+			"%s: TOBE CHECKED SELECTION BASED ON FMT..\n",
+			__func__);
+		break;
+	case (IMGSYS_ENG_TRAW | IMGSYS_ENG_DIP):
+	case (IMGSYS_ENG_TRAW | IMGSYS_ENG_DIP | IMGSYS_ENG_PQDIP_A):
+	case (IMGSYS_ENG_TRAW | IMGSYS_ENG_DIP | IMGSYS_ENG_PQDIP_B):
+	case (IMGSYS_ENG_TRAW | IMGSYS_ENG_DIP | IMGSYS_ENG_PQDIP_A |
+		IMGSYS_ENG_PQDIP_B):
+		dl_path = IMGSYS_DL_TRAW_DIP;
+		snprintf(logBuf_inport, log_length, "%s",
+			"TRAW");
+		snprintf(logBuf_outport, log_length, "%s",
+			"DIP");
+		imgsys_dl_checksum_dump(imgsys_dev, hw_comb,
+			logBuf_path, logBuf_inport, logBuf_outport, dl_path);
+		/**/
+		memset((char *)logBuf_inport, 0x0, log_length);
+		logBuf_inport[strlen(logBuf_inport)] = '\0';
+		memset((char *)logBuf_outport, 0x0, log_length);
+		logBuf_outport[strlen(logBuf_outport)] = '\0';
+		dl_path = IMGSYS_DL_DIP_PQDIPA;
+		snprintf(logBuf_inport, log_length, "%s",
+			"DIP");
+		snprintf(logBuf_outport, log_length, "%s",
+			"PQDIPA");
+		imgsys_dl_checksum_dump(imgsys_dev, hw_comb,
+			logBuf_path, logBuf_inport, logBuf_outport, dl_path);
+		/**/
+		memset((char *)logBuf_inport, 0x0, log_length);
+		logBuf_inport[strlen(logBuf_inport)] = '\0';
+		memset((char *)logBuf_outport, 0x0, log_length);
+		logBuf_outport[strlen(logBuf_outport)] = '\0';
+		dl_path = IMGSYS_DL_DIP_PQDIPB;
+		snprintf(logBuf_inport, log_length, "%s",
+			"DIP");
+		snprintf(logBuf_outport, log_length, "%s",
+			"PQDIPB");
+		imgsys_dl_checksum_dump(imgsys_dev, hw_comb,
+			logBuf_path, logBuf_inport, logBuf_outport, dl_path);
+		break;
+	case (IMGSYS_ENG_DIP | IMGSYS_ENG_PQDIP_A):
+	case (IMGSYS_ENG_DIP | IMGSYS_ENG_PQDIP_B):
+	case (IMGSYS_ENG_DIP | IMGSYS_ENG_PQDIP_A | IMGSYS_ENG_PQDIP_B):
+		dl_path = IMGSYS_DL_DIP_PQDIPA;
+		snprintf(logBuf_inport, log_length, "%s",
+			"DIP");
+		snprintf(logBuf_outport, log_length, "%s",
+			"PQDIPA");
+		imgsys_dl_checksum_dump(imgsys_dev, hw_comb,
+			logBuf_path, logBuf_inport, logBuf_outport, dl_path);
+		/**/
+		memset((char *)logBuf_inport, 0x0, log_length);
+		logBuf_inport[strlen(logBuf_inport)] = '\0';
+		memset((char *)logBuf_outport, 0x0, log_length);
+		logBuf_outport[strlen(logBuf_outport)] = '\0';
+		dl_path = IMGSYS_DL_DIP_PQDIPB;
+		snprintf(logBuf_inport, log_length, "%s",
+			"DIP");
+		snprintf(logBuf_outport, log_length, "%s",
+			"PQDIPB");
+		imgsys_dl_checksum_dump(imgsys_dev, hw_comb,
+			logBuf_path, logBuf_inport, logBuf_outport, dl_path);
+		break;
+	case (IMGSYS_ENG_ME):
+		imgsys_cg_debug_dump(imgsys_dev);
+		break;
+	default:
+		break;
+	}
+
+	dev_info(imgsys_dev->dev, "%s: -\n", __func__);
+}
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_70/mtk_imgsys-debug.h b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_70/mtk_imgsys-debug.h
new file mode 100644
index 0000000000000000000000000000000000000000..0a16f0de5d1a3d61af95d416d020f04e4fd27016
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_70/mtk_imgsys-debug.h
@@ -0,0 +1,49 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2021 MediaTek Inc.
+ *
+ * Author: Christopher Chen <christopher.chen@mediatek.com>
+ *
+ */
+
+#ifndef _MTK_IMGSYS_DEBUG_H_
+#define _MTK_IMGSYS_DEBUG_H_
+
+#include "mtk_imgsys-dev.h"
+#include "mtk_imgsys-cmdq.h"
+#include "mtk_imgsys-module.h"
+#include "mtk_imgsys-engine.h"
+/**
+ * enum IMGSYS_DL_PATH_E
+ *
+ * Definition about supported direct link path
+ */
+enum IMGSYS_DL_PATH_E {
+	IMGSYS_DL_WPEE_TRAW = 0,
+	IMGSYS_DL_WPEE_DIP = 1,
+	IMGSYS_DL_TRAW_DIP = 4,
+	IMGSYS_DL_WPE_PQDIP = 5, /*no more used*/
+	IMGSYS_DL_DIP_PQDIPA = 6,
+	IMGSYS_DL_DIP_PQDIPB = 7,
+	IMGSYS_DL_WPET_TRAW = 10,
+	IMGSYS_DL_WPET_DIP = 11
+};
+
+struct imgsys_dbg_engine_t {
+	enum mtk_imgsys_engine eng_e;
+	char eng_name[8];
+};
+
+void imgsys_dl_debug_dump(struct mtk_imgsys_dev *imgsys_dev, unsigned int hw_comb);
+void imgsys_debug_dump_routine(struct mtk_imgsys_dev *imgsys_dev,
+	const struct module_ops *imgsys_modules, int imgsys_module_num,
+	unsigned int hw_comb);
+void imgsys_cg_debug_dump(struct mtk_imgsys_dev *imgsys_dev);
+void imgsys_dl_checksum_dump(struct mtk_imgsys_dev *imgsys_dev,
+	unsigned int hw_comb, char *logBuf_path,
+	char *logBuf_inport, char *logBuf_outport, int dl_path);
+void imgsys_main_init(struct mtk_imgsys_dev *imgsys_dev);
+void imgsys_main_set_init(struct mtk_imgsys_dev *imgsys_dev);
+void imgsys_main_uninit(struct mtk_imgsys_dev *imgsys_dev);
+
+#endif /* _MTK_IMGSYS_DEBUG_H_ */
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_70/mtk_imgsys-engine.h b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_70/mtk_imgsys-engine.h
new file mode 100644
index 0000000000000000000000000000000000000000..21b77cf0126623068d3163c7e40aa42a129e4902
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_70/mtk_imgsys-engine.h
@@ -0,0 +1,65 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2021 MediaTek Inc.
+ *
+ * Author: Christopher Chen <christopher.chen@mediatek.com>
+ *
+ */
+
+#ifndef _MTK_IMGSYS_ENGINE_H_
+#define _MTK_IMGSYS_ENGINE_H_
+
+/**
+ * enum mtk_imgsys_module
+ *
+ * Definition about supported hw modules
+ */
+enum mtk_imgsys_module {
+	IMGSYS_MOD_IMGMAIN = 0, /*pure sw, debug dump usage*/
+	IMGSYS_MOD_WPE,
+	IMGSYS_MOD_TRAW,
+	IMGSYS_MOD_DIP,
+	IMGSYS_MOD_PQDIP,
+	IMGSYS_MOD_ME,
+	IMGSYS_MOD_MAX,
+};
+
+/**
+ * enum mtk_imgsys_engine
+ *
+ * Definition about supported hw engines
+ */
+enum mtk_imgsys_engine {
+	IMGSYS_ENG_WPE_EIS	= 0x00000001,
+	IMGSYS_ENG_WPE_TNR	= 0x00000002,
+	IMGSYS_ENG_TRAW		= 0x00000004,
+	IMGSYS_ENG_LTR		= 0x00000008,
+	IMGSYS_ENG_DIP		= 0x00000010,
+	IMGSYS_ENG_PQDIP_A	= 0x00000020,
+	IMGSYS_ENG_PQDIP_B	= 0x00000040,
+	IMGSYS_ENG_ME		= 0x00000080
+};
+
+/**
+ * enum IMGSYS_REG_MAP_E
+ *
+ * Definition about hw register map id
+ * The engine order should be the same as register order in dts
+ */
+enum IMGSYS_REG_MAP_E {
+	REG_MAP_E_TOP = 0,
+	REG_MAP_E_TRAW,
+	REG_MAP_E_LTRAW,
+	REG_MAP_E_DIP,
+	REG_MAP_E_PQDIP_A,
+	REG_MAP_E_PQDIP_B,
+	REG_MAP_E_WPE_EIS,
+	REG_MAP_E_WPE_TNR,
+	REG_MAP_E_WPE1_DIP1,
+	REG_MAP_E_ME,
+	REG_MAP_E_DIP_TOP,
+	REG_MAP_E_DIP_TOP_NR
+};
+
+#endif /* _MTK_IMGSYS_ENGINE_H_ */
+
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_70/mtk_imgsys-modops.h b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_70/mtk_imgsys-modops.h
new file mode 100644
index 0000000000000000000000000000000000000000..4dd0ec49d4b1c4ed108df53a1135ce3f88d7febe
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_70/mtk_imgsys-modops.h
@@ -0,0 +1,71 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2021 MediaTek Inc.
+ *
+ * Author: Frederic Chen <frederic.chen@mediatek.com>
+ *         Holmes Chiou <holmes.chiou@mediatek.com>
+ *
+ */
+
+#ifndef _MTK_IMGSYS_MODOPS_H_
+#define _MTK_IMGSYS_MODOPS_H_
+
+#include "mtk_imgsys-module.h"
+#include "modules/mtk_imgsys-dip.h"
+#include "modules/mtk_imgsys-traw.h"
+#include "modules/mtk_imgsys-pqdip.h"
+#include "modules/mtk_imgsys-wpe.h"
+//#include "modules/mtk_imgsys-me.h"
+#include "mtk-ipesys-me.h"
+#include "mtk_imgsys-debug.h"
+
+const struct module_ops imgsys_isp7_modules[] = {
+	[IMGSYS_MOD_TRAW] = {
+		.module_id = IMGSYS_MOD_TRAW,
+		.init = imgsys_traw_set_initial_value,
+		.set = imgsys_traw_set_initial_value_hw,
+		.dump = imgsys_traw_debug_dump,
+		.uninit = imgsys_traw_uninit,
+	},
+	[IMGSYS_MOD_DIP] = {
+		.module_id = IMGSYS_MOD_DIP,
+		.init = imgsys_dip_set_initial_value,
+		.set = imgsys_dip_set_hw_initial_value,
+		.dump = imgsys_dip_debug_dump,
+		.uninit = imgsys_dip_uninit,
+	},
+	[IMGSYS_MOD_PQDIP] = {
+		.module_id = IMGSYS_MOD_PQDIP,
+		.init = imgsys_pqdip_set_initial_value,
+		.set = imgsys_pqdip_set_hw_initial_value,
+		.dump = imgsys_pqdip_debug_dump,
+		.uninit = imgsys_pqdip_uninit,
+	},
+	[IMGSYS_MOD_ME] = {
+		.module_id = IMGSYS_MOD_ME,
+		.init = ipesys_me_set_initial_value,
+		.set = NULL,
+		.dump = ipesys_me_debug_dump,
+		.uninit = ipesys_me_uninit,
+	},
+	[IMGSYS_MOD_WPE] = {
+		.module_id = IMGSYS_MOD_WPE,
+		.init = imgsys_wpe_set_initial_value,
+		.set = imgsys_wpe_set_hw_initial_value,
+		.dump = imgsys_wpe_debug_dump,
+		.uninit = imgsys_wpe_uninit,
+	},
+	/*pure sw usage for timeout debug dump*/
+	[IMGSYS_MOD_IMGMAIN] = {
+		.module_id = IMGSYS_MOD_IMGMAIN,
+		.init = imgsys_main_init,
+		.set = imgsys_main_set_init,
+		.dump = NULL,
+		.uninit = imgsys_main_uninit,
+	},
+};
+#define MTK_IMGSYS_MODULE_NUM	ARRAY_SIZE(imgsys_isp7_modules)
+
+
+#endif /* _MTK_IMGSYS_MODOPS_H_ */
+
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_70/mtk_imgsys-plat.h b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_70/mtk_imgsys-plat.h
new file mode 100644
index 0000000000000000000000000000000000000000..bad92fed8c33ba50d74f4e91280ab98607135e6c
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_70/mtk_imgsys-plat.h
@@ -0,0 +1,52 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2021 MediaTek Inc.
+ *
+ * Author: Christopher Chen <christopher.chen@mediatek.com>
+ *
+ */
+
+#ifndef _MTK_IMGSYS_PLAT_H_
+#define _MTK_IMGSYS_PLAT_H_
+
+#include <linux/clk.h>
+
+struct clk_bulk_data imgsys_isp7_clks[] = {
+	{
+		.id = "IMGSYS_CG_IMG_TRAW0",
+	},
+	{
+		.id = "IMGSYS_CG_IMG_TRAW1",
+	},
+	{
+		.id = "IMGSYS_CG_IMG_TRAW2",
+	},
+	{
+		.id = "IMGSYS_CG_IMG_TRAW3",
+	},
+	{
+		.id = "IMGSYS_CG_IMG_DIP0",
+	},
+	{
+		.id = "IMGSYS_CG_IMG_WPE0",
+	},
+	{
+		.id = "IMGSYS_CG_IMG_DIP1",
+	},
+	{
+		.id = "IMGSYS_CG_IMG_WPE1",
+	},
+	{
+		.id = "DIP_CG_IMG_DIP",
+	},
+	{
+		.id = "DIP_NR_DIP_NR",
+	},
+	{
+		.id = "WPE_CG_WPE_WPE",
+	},
+};
+
+#define MTK_IMGSYS_CLK_NUM	ARRAY_SIZE(imgsys_isp7_clks)
+
+#endif /* _MTK_IMGSYS_PLAT_H_ */
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_70/mtk_imgsys-vnode_id.h b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_70/mtk_imgsys-vnode_id.h
new file mode 100644
index 0000000000000000000000000000000000000000..685bc8e25aab7c34e3d3c01d64bd601a6fa1754e
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_70/mtk_imgsys-vnode_id.h
@@ -0,0 +1,94 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2021 MediaTek Inc.
+ *
+ * Author: Frederic Chen <frederic.chen@mediatek.com>
+ *
+ */
+#ifndef _MTK_IMGSYS_VNODE_ID_H_
+#define _MTK_IMGSYS_VNODE_ID_H_
+
+/*
+ * TODO: register module pipeline desc in module order
+ */
+enum imgsys_video_nodes_id {
+	/* IMGSYS_MODULE_TRAW */
+	MTK_IMGSYS_VIDEO_NODE_ID_TIMGI_OUT = 0,
+	MTK_IMGSYS_VIDEO_NODE_ID_METAI_OUT,
+	MTK_IMGSYS_VIDEO_NODE_ID_PDC_OUT,
+	MTK_IMGSYS_VIDEO_NODE_ID_TYUVO_CAPTURE,
+	MTK_IMGSYS_VIDEO_NODE_ID_TYUV2O_CAPTURE,
+	MTK_IMGSYS_VIDEO_NODE_ID_TYUV3O_CAPTURE,
+	MTK_IMGSYS_VIDEO_NODE_ID_TYUV4O_CAPTURE,
+	MTK_IMGSYS_VIDEO_NODE_ID_TYUV5O_CAPTURE,
+	MTK_IMGSYS_VIDEO_NODE_ID_FEO_CAPTURE,
+	MTK_IMGSYS_VIDEO_NODE_ID_TIMGO_CAPTURE,
+	MTK_IMGSYS_VIDEO_NODE_ID_IMGSTATO_CAPTURE,
+	/* IMGSYS_MODULE_DIP */
+	MTK_IMGSYS_VIDEO_NODE_ID_IMGI_OUT,
+	MTK_IMGSYS_VIDEO_NODE_ID_VIPI_OUT,
+	MTK_IMGSYS_VIDEO_NODE_ID_REC_DSI_OUT,
+	MTK_IMGSYS_VIDEO_NODE_ID_REC_DPI_OUT,
+	MTK_IMGSYS_VIDEO_NODE_ID_CNR_BLURMAPI_OUT,
+	MTK_IMGSYS_VIDEO_NODE_ID_LFEI_OUT,
+	MTK_IMGSYS_VIDEO_NODE_ID_RFEI_OUT,
+	MTK_IMGSYS_VIDEO_NODE_ID_TNRSI_OUT,
+	MTK_IMGSYS_VIDEO_NODE_ID_TNRWI_OUT,
+	MTK_IMGSYS_VIDEO_NODE_ID_TNRMI_OUT,
+	MTK_IMGSYS_VIDEO_NODE_ID_TNRCI_OUT,
+	MTK_IMGSYS_VIDEO_NODE_ID_TNRLI_OUT,
+	MTK_IMGSYS_VIDEO_NODE_ID_TNRVBI_OUT,
+	MTK_IMGSYS_VIDEO_NODE_ID_IMG2O_CAPTURE,
+	MTK_IMGSYS_VIDEO_NODE_ID_IMG3O_CAPTURE,
+	MTK_IMGSYS_VIDEO_NODE_ID_IMG4O_CAPTURE,
+	MTK_IMGSYS_VIDEO_NODE_ID_FMO_CAPTURE,
+	MTK_IMGSYS_VIDEO_NODE_ID_TNRSO_CAPTURE,
+	MTK_IMGSYS_VIDEO_NODE_ID_TNRWO_CAPTURE,
+	MTK_IMGSYS_VIDEO_NODE_ID_TNRMO_CAPTURE,
+	/* IMGSYS_MODULE_PQDIP */
+	MTK_IMGSYS_VIDEO_NODE_ID_PIMGI_OUT,
+	MTK_IMGSYS_VIDEO_NODE_ID_WROT_A_CAPTURE,
+	MTK_IMGSYS_VIDEO_NODE_ID_WROT_B_CAPTURE,
+	/* IMGSYS_MODULE_ME */
+	MTK_IMGSYS_VIDEO_NODE_ID_MEL0IMG0_OUT,
+	MTK_IMGSYS_VIDEO_NODE_ID_MEL0IMG1_OUT,
+	MTK_IMGSYS_VIDEO_NODE_ID_MEL1IMG0_OUT,
+	MTK_IMGSYS_VIDEO_NODE_ID_MEL1IMG1_OUT,
+	MTK_IMGSYS_VIDEO_NODE_ID_MEIMGSTATS_OUT,
+	MTK_IMGSYS_VIDEO_NODE_ID_MEL0RMV_OUT,
+	MTK_IMGSYS_VIDEO_NODE_ID_MEL1RMV_OUT,
+	MTK_IMGSYS_VIDEO_NODE_ID_MEL0FMB_OUT,
+	MTK_IMGSYS_VIDEO_NODE_ID_MEL1FMB_OUT,
+	MTK_IMGSYS_VIDEO_NODE_ID_MEMIL_OUT,
+	MTK_IMGSYS_VIDEO_NODE_ID_MEMMGMIL_CAPTURE,
+	MTK_IMGSYS_VIDEO_NODE_ID_MEL0WMV_CAPTURE,
+	MTK_IMGSYS_VIDEO_NODE_ID_MEL1WMV_CAPTURE,
+	MTK_IMGSYS_VIDEO_NODE_ID_MECONF_CAPTURE,
+	MTK_IMGSYS_VIDEO_NODE_ID_MEWMAP_CAPTURE,
+	MTK_IMGSYS_VIDEO_NODE_ID_MEFMV_CAPTURE,
+	MTK_IMGSYS_VIDEO_NODE_ID_MEFST_CAPTURE,
+	MTK_IMGSYS_VIDEO_NODE_ID_MELMI_CAPTURE,
+	MTK_IMGSYS_VIDEO_NODE_ID_MEL0WFMB_CAPTURE,
+	MTK_IMGSYS_VIDEO_NODE_ID_MEL1WFMB_CAPTURE,
+	/* IMGSYS_MODULE_WPE */
+	MTK_IMGSYS_VIDEO_NODE_ID_WWPEI_OUT,
+	MTK_IMGSYS_VIDEO_NODE_ID_WVECI_OUT,
+	MTK_IMGSYS_VIDEO_NODE_ID_WPSP_COEFI_OUT,
+	MTK_IMGSYS_VIDEO_NODE_ID_WWPEO_CAPTURE,
+	MTK_IMGSYS_VIDEO_NODE_ID_WMSKO_CAPTURE,
+	/* IMGSYS_MODULE_WPE_TNR */
+	MTK_IMGSYS_VIDEO_NODE_ID_WTWPEI_OUT,
+	MTK_IMGSYS_VIDEO_NODE_ID_WTVECI_OUT,
+	MTK_IMGSYS_VIDEO_NODE_ID_WTPSP_COEFI_OUT,
+	MTK_IMGSYS_VIDEO_NODE_ID_WTWPEO_CAPTURE,
+	MTK_IMGSYS_VIDEO_NODE_ID_WTMSKO_CAPTURE,
+	/* other module video nodes to be added */
+	MTK_IMGSYS_VIDEO_NODE_ID_TUNING_OUT,
+	MTK_IMGSYS_VIDEO_NODE_ID_CTRLMETA_OUT,
+	MTK_IMGSYS_VIDEO_NODE_ID_SIGDEV_OUT,
+	MTK_IMGSYS_VIDEO_NODE_ID_SIGDEV_NORM_OUT,
+	MTK_IMGSYS_VIDEO_NODE_ID_TOTAL_NUM,
+};
+
+
+#endif
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_70/mtk_imgsys_v4l2_vnode.h b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_70/mtk_imgsys_v4l2_vnode.h
new file mode 100644
index 0000000000000000000000000000000000000000..7dc22d1481872841be929dc5d81f5c1c947ffea3
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_70/mtk_imgsys_v4l2_vnode.h
@@ -0,0 +1,216 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2021 MediaTek Inc.
+ *
+ * Author: Frederic Chen <frederic.chen@mediatek.com>
+ *
+ */
+#ifndef _MTK_IMGSYS_V4L2_VNODE_H_
+#define _MTK_IMGSYS_V4L2_VNODE_H_
+
+#include "mtk_imgsys-of.h"
+#include "mtk_imgsys-dev.h"
+#include "mtk_imgsys-vnode_id.h"
+#include "modules/mtk_dip_v4l2_vnode.h"
+#include "modules/mtk_traw_v4l2_vnode.h"
+#include "modules/mtk_pqdip_v4l2_vnode.h"
+#include "modules/mtk_wpe_v4l2_vnode.h"
+#include "modules/mtk_me_v4l2_vnode.h"
+
+/*
+ * TODO: register module pipeline desc in module order
+ */
+enum mtk_imgsys_module_id {
+	IMGSYS_MODULE_TRAW = 0,
+	IMGSYS_MODULE_DIP,
+	IMGSYS_MODULE_PQDIP,
+	IMGSYS_MODULE_ME,
+	IMGSYS_MODULE_WPE,
+	IMGSYS_MODULE_MAIN,
+	IMGSYS_MODULE_NUM,
+};
+
+static const struct mtk_imgsys_mod_pipe_desc module_pipe_isp7[] = {
+	[IMGSYS_MODULE_TRAW] = {
+		.vnode_desc = traw_setting,
+		.node_num = ARRAY_SIZE(traw_setting),
+	},
+	[IMGSYS_MODULE_DIP] = {
+		.vnode_desc = dip_setting,
+		.node_num = ARRAY_SIZE(dip_setting),
+	},
+	[IMGSYS_MODULE_PQDIP] = {
+		.vnode_desc = pqdip_setting,
+		.node_num = ARRAY_SIZE(pqdip_setting),
+	},
+	[IMGSYS_MODULE_ME] = {
+		.vnode_desc = me_setting,
+		.node_num = ARRAY_SIZE(me_setting),
+	},
+	[IMGSYS_MODULE_WPE] = {
+		.vnode_desc = wpe_setting,
+		.node_num = ARRAY_SIZE(wpe_setting),
+	},
+	[IMGSYS_MODULE_MAIN] = {
+		.vnode_desc = NULL,
+		.node_num = 0,
+	}
+};
+
+
+#define MTK_IMGSYS_MODULE_VNUM ARRAY_SIZE(module_pipe_isp7)
+
+
+
+static const struct mtk_imgsys_dev_format fw_param_fmts[] = {
+#if MTK_CM4_SUPPORT
+	{
+		.format = V4L2_META_FMT_MTISP_PARAMS,
+		.buffer_size = 1024 * (128 + 288),
+	},
+#else
+	{
+		.format = V4L2_META_FMT_MTISP_PARAMS,
+		.buffer_size = DIP_TUNING_SZ,
+	},
+	{
+		.format = V4L2_META_FMT_MTISP_PARAMS,
+		.buffer_size = sizeof(struct dip_param),
+	},
+#endif
+	{	// Must have for SMVR/Multis-cale for every video_device nodes
+		.format = V4L2_META_FMT_MTISP_DESC,
+		.num_planes = 1,
+#if defaultdesc
+		.depth = { 8 },
+		.row_depth = { 8 },
+		.num_cplanes = 1,
+#endif
+		.buffer_size = sizeof(struct header_desc),
+	},
+	{
+		.format = V4L2_META_FMT_MTISP_DESC_NORM,
+		.num_planes = 1,
+		.buffer_size = sizeof(struct header_desc_norm),
+	},
+};
+
+static const struct mtk_imgsys_dev_format sd_fmts[] = {
+	{
+		.format = V4L2_META_FMT_MTISP_SD,
+		.num_planes = 1,
+#if defaultdesc
+		.depth = { 8 },
+		.row_depth = { 8 },
+		.num_cplanes = 1,
+#endif
+		.buffer_size = sizeof(struct singlenode_desc),
+	},
+	{
+		.format = V4L2_META_FMT_MTISP_SDNORM,
+		.num_planes = 1,
+		.buffer_size = sizeof(struct singlenode_desc_norm),
+	},
+};
+
+static struct mtk_imgsys_video_device_desc
+queues_setting[MTK_IMGSYS_VIDEO_NODE_ID_TOTAL_NUM] = {
+	[MTK_IMGSYS_VIDEO_NODE_ID_TUNING_OUT] = {
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_TUNING_OUT,
+		.name = "Tuning",
+		.cap = V4L2_CAP_META_OUTPUT | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_META_OUTPUT,
+		.smem_alloc = 0, //meta:1
+		.flags = 0,
+		.fmts = fw_param_fmts,
+		.num_fmts = ARRAY_SIZE(fw_param_fmts),
+		.default_fmt_idx = 2, //0,
+		.dma_port = 0,
+		.frmsizeenum = &dip_in_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_meta_out_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_meta_ops,
+		.description = "Tuning data",
+	},
+	[MTK_IMGSYS_VIDEO_NODE_ID_CTRLMETA_OUT] = {
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_CTRLMETA_OUT,
+		.name = "CtrlMeta",
+		.cap = V4L2_CAP_META_OUTPUT | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_META_OUTPUT,
+		.smem_alloc = 0, //meta:1
+		.flags = 0,
+		.fmts = fw_param_fmts,
+		.num_fmts = ARRAY_SIZE(fw_param_fmts),
+		.default_fmt_idx = 2, //1,
+		.dma_port = 0,
+		.frmsizeenum = &dip_in_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_meta_out_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_meta_ops,
+		.description = "Control meta data for flow control",
+	},
+	[MTK_IMGSYS_VIDEO_NODE_ID_SIGDEV_OUT] = {
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_SIGDEV_OUT,
+		.name = "Single Device",
+		.cap = V4L2_CAP_VIDEO_OUTPUT_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = sd_fmts,
+		.num_fmts = ARRAY_SIZE(sd_fmts),
+		.default_fmt_idx = 0,
+		.default_width = MTK_DIP_OUTPUT_MAX_WIDTH,
+		.default_height = MTK_DIP_OUTPUT_MAX_HEIGHT,
+		.dma_port = 0,
+		.frmsizeenum = &dip_in_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_out_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "Single Device Node",
+	},
+	[MTK_IMGSYS_VIDEO_NODE_ID_SIGDEV_NORM_OUT] = {
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_SIGDEV_NORM_OUT,
+		.name = "SIGDEVN",
+		.cap = V4L2_CAP_VIDEO_OUTPUT_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = sd_fmts,
+		.num_fmts = ARRAY_SIZE(sd_fmts),
+		.default_fmt_idx = 1,
+		.default_width = MTK_DIP_OUTPUT_MAX_WIDTH,
+		.default_height = MTK_DIP_OUTPUT_MAX_HEIGHT,
+		.dma_port = 0,
+		.frmsizeenum = &dip_in_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_out_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "Single Device Norm",
+	},
+};
+#ifdef MULTI_PIPE_SUPPORT
+static struct mtk_imgsys_video_device_desc
+reprocess_queues_setting[MTK_IMGSYS_VIDEO_NODE_ID_TOTAL_NUM];
+#endif
+
+static const struct mtk_imgsys_pipe_desc
+pipe_settings_isp7[MTK_IMGSYS_PIPE_ID_TOTAL_NUM] = {
+	{
+		.name = MTK_DIP_DEV_DIP_PREVIEW_NAME,
+		.id = MTK_IMGSYS_PIPE_ID_PREVIEW,
+		.queue_descs = queues_setting,
+		.total_queues = ARRAY_SIZE(queues_setting),
+	},
+#ifdef MULTI_PIPE_SUPPORT
+	{
+		.name = MTK_DIP_DEV_DIP_CAPTURE_NAME,
+		.id = MTK_IMGSYS_PIPE_ID_CAPTURE,
+		.queue_descs = queues_setting,
+		.total_queues = ARRAY_SIZE(queues_setting),
+
+	},
+	{
+		.name = MTK_DIP_DEV_DIP_REPROCESS_NAME,
+		.id = MTK_IMGSYS_PIPE_ID_REPROCESS,
+		.queue_descs = reprocess_queues_setting,
+		.total_queues = ARRAY_SIZE(reprocess_queues_setting),
+	},
+#endif
+};
+#endif
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_71/Makefile b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_71/Makefile
new file mode 100644
index 0000000000000000000000000000000000000000..5b3633026989a729946a64c9f13d9b5419e54ac4
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_71/Makefile
@@ -0,0 +1,21 @@
+# SPDX-License-Identifier: GPL-2.0
+#
+# Copyright (C) 2018 MediaTek Inc.
+#
+ccflags-$(CONFIG_MTK_AEE_FEATURE) += -I$(srctree)/drivers/misc/mediatek/include/mt-plat
+ccflags-y += -I$(srctree)/drivers/media/platform/mtk-isp/mtk-hcp/
+ccflags-y += -I$(srctree)/drivers/media/platform/mtk-isp/mtk-ipesys-me/
+ccflags-y += -I$(srctree)/drivers/media/platform/mtk-isp/imgsys/
+ccflags-y += -I$(srctree)/drivers/misc/mediatek/mtk-interconnect/
+ccflags-y += -I$(srctree)/drivers/misc/mediatek/m4u/$(MTK_PLATFORM)
+ccflags-y += -I$(srctree)/drivers/iommu
+
+# mtk_imgsys_hw-objs := \
+# mtk_imgsys-debug.o \
+# modules/mtk_imgsys-dip.o \
+# modules/mtk_imgsys-traw.o \
+# modules/mtk_imgsys-pqdip.o \
+# modules/mtk_imgsys-wpe.o \
+# modules/mtk_imgsys-me.o
+#
+# obj-m += mtk_imgsys_hw.o
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_71/modules/mtk_dip_v4l2_vnode.h b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_71/modules/mtk_dip_v4l2_vnode.h
new file mode 100644
index 0000000000000000000000000000000000000000..2e341d4fa7fcd4de4fdea6594a1a5ed4cc9c3575
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_71/modules/mtk_dip_v4l2_vnode.h
@@ -0,0 +1,938 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2018 MediaTek Inc.
+ *
+ * Author: Frederic Chen <frederic.chen@mediatek.com>
+ *
+ */
+
+#ifndef _MTK_DIP_V4L2_VNODE_H_
+#define _MTK_DIP_V4L2_VNODE_H_
+
+/*#include <linux/platform_device.h>
+ * #include <linux/module.h>
+ * #include <linux/of_device.h>
+ * #include <linux/pm_runtime.h>
+ * #include <linux/remoteproc.h>
+ * #include <linux/remoteproc/mtk_scp.h>
+ */
+#include <linux/videodev2.h>
+#include <media/videobuf2-dma-contig.h>
+#include <media/v4l2-ioctl.h>
+#include <media/v4l2-subdev.h>
+#include <media/v4l2-event.h>
+#include "mtk_imgsys-dev.h"
+#include "mtk_imgsys-hw.h"
+
+#include "mtk_imgsys_v4l2.h"
+#include "mtk_header_desc.h"
+#include "mtk_imgsys-vnode_id.h"
+
+#define defaultdesc 0
+
+static const struct mtk_imgsys_dev_format dip_imgi_fmts[] = {
+	/* YUV422, 1 plane 8 bit */
+	{
+		.format = V4L2_PIX_FMT_UYVY,
+		.depth = { 16 },
+		.row_depth = { 16 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+	},
+	{
+		.format = V4L2_PIX_FMT_YUYV,
+		.depth = { 16 },
+		.row_depth = { 16 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+	},
+	{
+		.format = V4L2_PIX_FMT_YVYU,
+		.depth = { 16 },
+		.row_depth = { 16 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+	},
+	{
+		.format = V4L2_PIX_FMT_VYUY,
+		.depth = { 16 },
+		.row_depth = { 16 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+	},
+	/* YUV422, 2 plane 8 bit */
+	{
+		.format = V4L2_PIX_FMT_NV16,
+		.depth = { 16 },
+		.row_depth = { 8 },
+		.num_planes = 1,
+		.num_cplanes = 2,
+	},
+	{
+		.format = V4L2_PIX_FMT_NV61,
+		.depth = { 16 },
+		.row_depth = { 8 },
+		.num_planes = 1,
+		.num_cplanes = 2,
+	},
+	/* YUV422, 3 plane 8 bit */
+	/* YUV420, 2 plane 8 bit */
+	{
+		.format = V4L2_PIX_FMT_NV12,
+		.depth = { 12 },
+		.row_depth = { 8 },
+		.num_planes = 1,
+		.num_cplanes = 2,
+	},
+	{
+		.format = V4L2_PIX_FMT_NV21,
+		.depth = { 12 },
+		.row_depth = { 8 },
+		.num_planes = 1,
+		.num_cplanes = 2,
+	},
+	/* YUV420, 3 plane 8 bit */
+	{
+		.format	= V4L2_PIX_FMT_YUV420,
+		.depth		= { 12 },
+		.row_depth	= { 8 },
+		.num_planes	= 1,
+		.num_cplanes = 3,
+	},
+	{
+		.format	= V4L2_PIX_FMT_YVU420,
+		.depth		= { 12 },
+		.row_depth	= { 8 },
+		.num_planes	= 1,
+		.num_cplanes = 3,
+	},
+	/* Y8 bit */
+	{
+		.format	= V4L2_PIX_FMT_GREY,
+		.depth		= { 8 },
+		.row_depth	= { 8 },
+		.num_planes	= 1,
+		.num_cplanes = 1,
+	},
+	/* Must have for SMVR/Multis-cale for every video_device nodes */
+	{
+		.format = V4L2_META_FMT_MTISP_DESC,
+		.num_planes = 1,
+#if defaultdesc
+		.depth = { 8 },
+		.row_depth = { 8 },
+		.num_cplanes = 1,
+#endif
+		.buffer_size = sizeof(struct header_desc),
+	},
+	{
+		.format = V4L2_META_FMT_MTISP_DESC_NORM,
+		.num_planes = 1,
+		.buffer_size = sizeof(struct header_desc_norm),
+	},
+};
+
+static const struct mtk_imgsys_dev_format dip_vipi_fmts[] = {
+	/* YUV422, 1 plane 8 bit */
+	{
+		.format = V4L2_PIX_FMT_UYVY,
+		.depth = { 16 },
+		.row_depth = { 16 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+	},
+	{
+		.format = V4L2_PIX_FMT_YUYV,
+		.depth = { 16 },
+		.row_depth = { 16 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+	},
+	{
+		.format = V4L2_PIX_FMT_YVYU,
+		.depth = { 16 },
+		.row_depth = { 16 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+	},
+	{
+		.format = V4L2_PIX_FMT_VYUY,
+		.depth = { 16 },
+		.row_depth = { 16 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+	},
+	/* YUV422, 2 plane 8 bit */
+	{
+		.format = V4L2_PIX_FMT_NV16,
+		.depth = { 16 },
+		.row_depth = { 8 },
+		.num_planes = 1,
+		.num_cplanes = 2,
+	},
+	{
+		.format = V4L2_PIX_FMT_NV61,
+		.depth = { 16 },
+		.row_depth = { 8 },
+		.num_planes = 1,
+		.num_cplanes = 2,
+	},
+	/* YUV422, 3 plane 8 bit */
+	/* YUV420, 2 plane 8 bit */
+	{
+		.format = V4L2_PIX_FMT_NV12,
+		.depth = { 12 },
+		.row_depth = { 8 },
+		.num_planes = 1,
+		.num_cplanes = 2,
+	},
+	{
+		.format = V4L2_PIX_FMT_NV21,
+		.depth = { 12 },
+		.row_depth = { 8 },
+		.num_planes = 1,
+		.num_cplanes = 2,
+	},
+	/* YUV420, 3 plane 8 bit */
+	{
+		.format	= V4L2_PIX_FMT_YUV420,
+		.depth		= { 12 },
+		.row_depth	= { 8 },
+		.num_planes	= 1,
+		.num_cplanes = 3,
+	},
+	{
+		.format	= V4L2_PIX_FMT_YVU420,
+		.depth		= { 12 },
+		.row_depth	= { 8 },
+		.num_planes	= 1,
+		.num_cplanes = 3,
+	},
+	/* Y8 bit */
+	{
+		.format	= V4L2_PIX_FMT_GREY,
+		.depth		= { 8 },
+		.row_depth	= { 8 },
+		.num_planes	= 1,
+		.num_cplanes = 1,
+	},
+	/* Must have for SMVR/Multis-cale for every video_device nodes */
+	{
+		.format = V4L2_META_FMT_MTISP_DESC,
+		.num_planes = 1,
+#if defaultdesc
+		.depth = { 8 },
+		.row_depth = { 8 },
+		.num_cplanes = 1,
+#endif
+		.buffer_size = sizeof(struct header_desc),
+	},
+	{
+		.format = V4L2_META_FMT_MTISP_DESC_NORM,
+		.num_planes = 1,
+		.buffer_size = sizeof(struct header_desc_norm),
+	},
+};
+
+static const struct mtk_imgsys_dev_format dip_rec_dsi_fmts[] = {
+	/* YUV420, 2 plane 8 bit */
+	{
+		.format = V4L2_PIX_FMT_NV12,
+		.depth = { 12 },
+		.row_depth = { 8 },
+		.num_planes = 1,
+		.num_cplanes = 2,
+	},
+	{
+		.format = V4L2_PIX_FMT_NV21,
+		.depth = { 12 },
+		.row_depth = { 8 },
+		.num_planes = 1,
+		.num_cplanes = 2,
+	},
+	/* Must have for SMVR/Multis-cale for every video_device nodes */
+	{
+		.format = V4L2_META_FMT_MTISP_DESC,
+		.num_planes = 1,
+#if defaultdesc
+		.depth = { 8 },
+		.row_depth = { 8 },
+		.num_cplanes = 1,
+#endif
+		.buffer_size = sizeof(struct header_desc),
+	},
+	{
+		.format = V4L2_META_FMT_MTISP_DESC_NORM,
+		.num_planes = 1,
+		.buffer_size = sizeof(struct header_desc_norm),
+	},
+};
+
+static const struct mtk_imgsys_dev_format dip_rec_dpi_fmts[] = {
+	/* YUV420, 2 plane 8 bit */
+	{
+		.format = V4L2_PIX_FMT_NV12,
+		.depth = { 12 },
+		.row_depth = { 8 },
+		.num_planes = 1,
+		.num_cplanes = 2,
+	},
+	{
+		.format = V4L2_PIX_FMT_NV21,
+		.depth = { 12 },
+		.row_depth = { 8 },
+		.num_planes = 1,
+		.num_cplanes = 2,
+	},
+	/* Must have for SMVR/Multis-cale for every video_device nodes */
+	{
+		.format = V4L2_META_FMT_MTISP_DESC,
+		.num_planes = 1,
+#if defaultdesc
+		.depth = { 8 },
+		.row_depth = { 8 },
+		.num_cplanes = 1,
+#endif
+		.buffer_size = sizeof(struct header_desc),
+	},
+	{
+		.format = V4L2_META_FMT_MTISP_DESC_NORM,
+		.num_planes = 1,
+		.buffer_size = sizeof(struct header_desc_norm),
+	},
+};
+
+static const struct mtk_imgsys_dev_format dip_meta_fmts[] = {
+#if 0
+	{
+		.format = V4L2_PIX_FMT_MTISP_SBGGR8,
+		.depth = { 8 },
+		.row_depth = { 8 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+	},
+#endif
+	/* Must have for SMVR/Multis-cale for every video_device nodes */
+	{
+		.format = V4L2_META_FMT_MTISP_DESC,
+		.num_planes = 1,
+#if defaultdesc
+		.depth = { 8 },
+		.row_depth = { 8 },
+		.num_cplanes = 1,
+#endif
+		.buffer_size = sizeof(struct header_desc),
+	},
+	{
+		.format = V4L2_META_FMT_MTISP_DESC_NORM,
+		.num_planes = 1,
+		.buffer_size = sizeof(struct header_desc_norm),
+	},
+};
+
+static const struct mtk_imgsys_dev_format dip_tnrli_fmts[] = {
+	/* YUV420, 2 plane 8 bit */
+	{
+		.format = V4L2_PIX_FMT_NV12,
+		.depth = { 12 },
+		.row_depth = { 8 },
+		.num_planes = 1,
+		.num_cplanes = 2,
+	},
+	{
+		.format = V4L2_PIX_FMT_NV21,
+		.depth = { 12 },
+		.row_depth = { 8 },
+		.num_planes = 1,
+		.num_cplanes = 2,
+	},
+	/* Must have for SMVR/Multis-cale for every video_device nodes */
+	{
+		.format = V4L2_META_FMT_MTISP_DESC,
+		.num_planes = 1,
+#if defaultdesc
+		.depth = { 8 },
+		.row_depth = { 8 },
+		.num_cplanes = 1,
+#endif
+		.buffer_size = sizeof(struct header_desc),
+	},
+	{
+		.format = V4L2_META_FMT_MTISP_DESC_NORM,
+		.num_planes = 1,
+		.buffer_size = sizeof(struct header_desc_norm),
+	},
+};
+
+static const struct mtk_imgsys_dev_format dip_img2o_fmts[] = {
+	/* YUV420, 2 plane 8 bit */
+	{
+		.format = V4L2_PIX_FMT_NV12,
+		.depth = { 12 },
+		.row_depth = { 8 },
+		.num_planes = 1,
+		.num_cplanes = 2,
+	},
+	{
+		.format = V4L2_PIX_FMT_NV21,
+		.depth = { 12 },
+		.row_depth = { 8 },
+		.num_planes = 1,
+		.num_cplanes = 2,
+	},
+	/* Y8 bit */
+	{
+		.format	= V4L2_PIX_FMT_GREY,
+		.depth		= { 8 },
+		.row_depth	= { 8 },
+		.num_planes	= 1,
+		.num_cplanes = 1,
+	},
+	/* Must have for SMVR/Multis-cale for every video_device nodes */
+	{
+		.format = V4L2_META_FMT_MTISP_DESC,
+		.num_planes = 1,
+#if defaultdesc
+		.depth = { 8 },
+		.row_depth = { 8 },
+		.num_cplanes = 1,
+#endif
+		.buffer_size = sizeof(struct header_desc),
+	},
+	{
+		.format = V4L2_META_FMT_MTISP_DESC_NORM,
+		.num_planes = 1,
+		.buffer_size = sizeof(struct header_desc_norm),
+	},
+};
+
+static const struct mtk_imgsys_dev_format dip_img3o_fmts[] = {
+	/* YUV422, 1 plane 8 bit */
+	{
+		.format = V4L2_PIX_FMT_UYVY,
+		.depth = { 16 },
+		.row_depth = { 16 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+	},
+	{
+		.format = V4L2_PIX_FMT_YUYV,
+		.depth = { 16 },
+		.row_depth = { 16 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+	},
+	{
+		.format = V4L2_PIX_FMT_YVYU,
+		.depth = { 16 },
+		.row_depth = { 16 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+	},
+	{
+		.format = V4L2_PIX_FMT_VYUY,
+		.depth = { 16 },
+		.row_depth = { 16 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+	},
+	/* YUV422, 2 plane 8 bit */
+	{
+		.format = V4L2_PIX_FMT_NV16,
+		.depth = { 16 },
+		.row_depth = { 8 },
+		.num_planes = 1,
+		.num_cplanes = 2,
+	},
+	{
+		.format = V4L2_PIX_FMT_NV61,
+		.depth = { 16 },
+		.row_depth = { 8 },
+		.num_planes = 1,
+		.num_cplanes = 2,
+	},
+	/* YUV422, 3 plane 8 bit */
+	/* YUV420, 2 plane 8 bit */
+	{
+		.format = V4L2_PIX_FMT_NV12,
+		.depth = { 12 },
+		.row_depth = { 8 },
+		.num_planes = 1,
+		.num_cplanes = 2,
+	},
+	{
+		.format = V4L2_PIX_FMT_NV21,
+		.depth = { 12 },
+		.row_depth = { 8 },
+		.num_planes = 1,
+		.num_cplanes = 2,
+	},
+	/* YUV420, 3 plane 8 bit */
+	{
+		.format	= V4L2_PIX_FMT_YUV420,
+		.depth		= { 12 },
+		.row_depth	= { 8 },
+		.num_planes	= 1,
+		.num_cplanes = 3,
+	},
+	{
+		.format	= V4L2_PIX_FMT_YVU420,
+		.depth		= { 12 },
+		.row_depth	= { 8 },
+		.num_planes	= 1,
+		.num_cplanes = 3,
+	},
+	/* Y8 bit */
+	{
+		.format	= V4L2_PIX_FMT_GREY,
+		.depth		= { 8 },
+		.row_depth	= { 8 },
+		.num_planes	= 1,
+		.num_cplanes = 1,
+	},
+	/* Must have for SMVR/Multis-cale for every video_device nodes */
+	{
+		.format = V4L2_META_FMT_MTISP_DESC,
+		.num_planes = 1,
+#if defaultdesc
+		.depth = { 8 },
+		.row_depth = { 8 },
+		.num_cplanes = 1,
+#endif
+		.buffer_size = sizeof(struct header_desc),
+	},
+	{
+		.format = V4L2_META_FMT_MTISP_DESC_NORM,
+		.num_planes = 1,
+		.buffer_size = sizeof(struct header_desc_norm),
+	},
+};
+
+static const struct mtk_imgsys_dev_format dip_img4o_fmts[] = {
+	/* YUV420, 2 plane 8 bit */
+	{
+		.format = V4L2_PIX_FMT_NV12,
+		.depth = { 12 },
+		.row_depth = { 8 },
+		.num_planes = 1,
+		.num_cplanes = 2,
+	},
+	{
+		.format = V4L2_PIX_FMT_NV21,
+		.depth = { 12 },
+		.row_depth = { 8 },
+		.num_planes = 1,
+		.num_cplanes = 2,
+	},
+	/* Y8 bit */
+	{
+		.format	= V4L2_PIX_FMT_GREY,
+		.depth		= { 8 },
+		.row_depth	= { 8 },
+		.num_planes	= 1,
+		.num_cplanes = 1,
+	},
+	/* Must have for SMVR/Multis-cale for every video_device nodes */
+	{
+		.format = V4L2_META_FMT_MTISP_DESC,
+		.num_planes = 1,
+#if defaultdesc
+		.depth = { 8 },
+		.row_depth = { 8 },
+		.num_cplanes = 1,
+#endif
+		.buffer_size = sizeof(struct header_desc),
+	},
+	{
+		.format = V4L2_META_FMT_MTISP_DESC_NORM,
+		.num_planes = 1,
+		.buffer_size = sizeof(struct header_desc_norm),
+	},
+};
+
+static const struct v4l2_frmsizeenum dip_in_frmsizeenum = {
+	.type = V4L2_FRMSIZE_TYPE_CONTINUOUS,
+	.stepwise.max_width = MTK_DIP_CAPTURE_MAX_WIDTH,
+	.stepwise.min_width = MTK_DIP_CAPTURE_MIN_WIDTH,
+	.stepwise.max_height = MTK_DIP_CAPTURE_MAX_HEIGHT,
+	.stepwise.min_height = MTK_DIP_CAPTURE_MIN_HEIGHT,
+	.stepwise.step_height = 1,
+	.stepwise.step_width = 1,
+};
+
+static const struct v4l2_frmsizeenum dip_out_frmsizeenum = {
+	.type = V4L2_FRMSIZE_TYPE_CONTINUOUS,
+	.stepwise.max_width = MTK_DIP_OUTPUT_MAX_WIDTH,
+	.stepwise.min_width = MTK_DIP_OUTPUT_MIN_WIDTH,
+	.stepwise.max_height = MTK_DIP_OUTPUT_MAX_HEIGHT,
+	.stepwise.min_height = MTK_DIP_OUTPUT_MIN_HEIGHT,
+	.stepwise.step_height = 1,
+	.stepwise.step_width = 1,
+};
+
+static const struct mtk_imgsys_video_device_desc dip_setting[] = {
+	/* Input Video Node */
+	{
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_IMGI_OUT,
+		.name = "Imgi Input",
+		.cap = V4L2_CAP_VIDEO_OUTPUT_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = dip_imgi_fmts,
+		.num_fmts = ARRAY_SIZE(dip_imgi_fmts),
+		.default_fmt_idx = 4,
+		.default_width = MTK_DIP_OUTPUT_MAX_WIDTH,
+		.default_height = MTK_DIP_OUTPUT_MAX_HEIGHT,
+		.dma_port = 0,
+		.frmsizeenum = &dip_in_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_out_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "Main image source",
+	},
+	{
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_VIPI_OUT,
+		.name = "Vipi Input",
+		.cap = V4L2_CAP_VIDEO_OUTPUT_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = dip_vipi_fmts,
+		.num_fmts = ARRAY_SIZE(dip_vipi_fmts),
+		.default_fmt_idx = 1,
+		.default_width = MTK_DIP_CAPTURE_MAX_WIDTH,
+		.default_height = MTK_DIP_CAPTURE_MAX_HEIGHT,
+		.dma_port = 1,
+		.frmsizeenum = &dip_in_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_out_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "Vipi image source",
+	},
+	{
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_REC_DSI_OUT,
+		.name = "Rec_Dsi Input",
+		.cap = V4L2_CAP_VIDEO_OUTPUT_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = dip_rec_dsi_fmts,
+		.num_fmts = ARRAY_SIZE(dip_rec_dsi_fmts),
+		.default_fmt_idx = 1,
+		.default_width = MTK_DIP_CAPTURE_MAX_WIDTH,
+		.default_height = MTK_DIP_CAPTURE_MAX_HEIGHT,
+		.dma_port = 2,
+		.frmsizeenum = &dip_in_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_out_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "Down Source Image",
+	},
+	{
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_REC_DPI_OUT,
+		.name = "Rec_Dpi Input",
+		.cap = V4L2_CAP_VIDEO_OUTPUT_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = dip_rec_dpi_fmts,
+		.num_fmts = ARRAY_SIZE(dip_rec_dpi_fmts),
+		.default_fmt_idx = 1,
+		.default_width = MTK_DIP_CAPTURE_MAX_WIDTH,
+		.default_height = MTK_DIP_CAPTURE_MAX_HEIGHT,
+		.dma_port = 3,
+		.frmsizeenum = &dip_in_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_out_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "Down Processed Image",
+	},
+	{
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_CNR_BLURMAPI_OUT,
+		.name = "Bokeh Input",
+		.cap = V4L2_CAP_VIDEO_OUTPUT_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = dip_meta_fmts,
+		.num_fmts = ARRAY_SIZE(dip_meta_fmts),
+		.default_fmt_idx = 1,
+		.default_width = MTK_DIP_CAPTURE_MAX_WIDTH,
+		.default_height = MTK_DIP_CAPTURE_MAX_HEIGHT,
+		.dma_port = 5,
+		.frmsizeenum = &dip_in_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_out_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "Bokehi data",
+	},
+	{
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_LFEI_OUT,
+		.name = "Dmgi_FM Input",
+		.cap = V4L2_CAP_VIDEO_OUTPUT_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = dip_meta_fmts,
+		.num_fmts = ARRAY_SIZE(dip_meta_fmts),
+		.default_fmt_idx = 1,
+		.default_width = MTK_DIP_CAPTURE_MAX_WIDTH,
+		.default_height = MTK_DIP_CAPTURE_MAX_HEIGHT,
+		.dma_port = 6,
+		.frmsizeenum = &dip_in_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_out_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "Dmgi_FM data",
+	},
+	{
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_RFEI_OUT,
+		.name = "Depi_FM Input",
+		.cap = V4L2_CAP_VIDEO_OUTPUT_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = dip_meta_fmts,
+		.num_fmts = ARRAY_SIZE(dip_meta_fmts),
+		.default_fmt_idx = 1,
+		.default_width = MTK_DIP_CAPTURE_MAX_WIDTH,
+		.default_height = MTK_DIP_CAPTURE_MAX_HEIGHT,
+		.dma_port = 7,
+		.frmsizeenum = &dip_in_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_out_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "Depi_FM data",
+	},
+	{
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_TNRSI_OUT,
+		.name = "Tnrsi Input",
+		.cap = V4L2_CAP_VIDEO_OUTPUT_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = dip_meta_fmts,
+		.num_fmts = ARRAY_SIZE(dip_meta_fmts),
+		.default_fmt_idx = 1,
+		.default_width = MTK_DIP_CAPTURE_MAX_WIDTH,
+		.default_height = MTK_DIP_CAPTURE_MAX_HEIGHT,
+		.dma_port = 8,
+		.frmsizeenum = &dip_in_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_out_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "Statistics input",
+	},
+	{
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_TNRWI_OUT,
+		.name = "Tnrwi Input",
+		.cap = V4L2_CAP_VIDEO_OUTPUT_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = dip_meta_fmts,
+		.num_fmts = ARRAY_SIZE(dip_meta_fmts),
+		.default_fmt_idx = 1,
+		.default_width = MTK_DIP_CAPTURE_MAX_WIDTH,
+		.default_height = MTK_DIP_CAPTURE_MAX_HEIGHT,
+		.dma_port = 9,
+		.frmsizeenum = &dip_in_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_out_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "Weighting input",
+	},
+	{
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_TNRMI_OUT,
+		.name = "Tnrmi Input",
+		.cap = V4L2_CAP_VIDEO_OUTPUT_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = dip_meta_fmts,
+		.num_fmts = ARRAY_SIZE(dip_meta_fmts),
+		.default_fmt_idx = 1,
+		.default_width = MTK_DIP_CAPTURE_MAX_WIDTH,
+		.default_height = MTK_DIP_CAPTURE_MAX_HEIGHT,
+		.dma_port = 10,
+		.frmsizeenum = &dip_in_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_out_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "Motion Map input",
+	},
+	{
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_TNRCI_OUT,
+		.name = "Tnrci Input",
+		.cap = V4L2_CAP_VIDEO_OUTPUT_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = dip_meta_fmts,
+		.num_fmts = ARRAY_SIZE(dip_meta_fmts),
+		.default_fmt_idx = 1,
+		.default_width = MTK_DIP_CAPTURE_MAX_WIDTH,
+		.default_height = MTK_DIP_CAPTURE_MAX_HEIGHT,
+		.dma_port = 11,
+		.frmsizeenum = &dip_in_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_out_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "Confidence Map input",
+	},
+	{
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_TNRLI_OUT,
+		.name = "Tnrli Input",
+		.cap = V4L2_CAP_VIDEO_OUTPUT_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = dip_tnrli_fmts,
+		.num_fmts = ARRAY_SIZE(dip_tnrli_fmts),
+		.default_fmt_idx = 1,
+		.default_width = MTK_DIP_CAPTURE_MAX_WIDTH,
+		.default_height = MTK_DIP_CAPTURE_MAX_HEIGHT,
+		.dma_port = 12,
+		.frmsizeenum = &dip_in_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_out_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "Low Frequency Diff input",
+	},
+	{
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_TNRVBI_OUT,
+		.name = "Tnrvbi Input",
+		.cap = V4L2_CAP_VIDEO_OUTPUT_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = dip_meta_fmts,
+		.num_fmts = ARRAY_SIZE(dip_meta_fmts),
+		.default_fmt_idx = 1,
+		.default_width = MTK_DIP_CAPTURE_MAX_WIDTH,
+		.default_height = MTK_DIP_CAPTURE_MAX_HEIGHT,
+		.dma_port = 13,
+		.frmsizeenum = &dip_in_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_out_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "Valid Bit Map input",
+	},
+	/* Output Video Node */
+	{
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_IMG2O_CAPTURE,
+		.name = "Img2o Output",
+		.cap = V4L2_CAP_VIDEO_CAPTURE_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = dip_img2o_fmts,
+		.num_fmts = ARRAY_SIZE(dip_img2o_fmts),
+		.default_fmt_idx = 0,
+		.default_width = MTK_DIP_CAPTURE_MAX_WIDTH,
+		.default_height = MTK_DIP_CAPTURE_MAX_HEIGHT,
+		.dma_port = 0,
+		.frmsizeenum = &dip_out_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_cap_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "Resized output",
+	},
+	{
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_IMG3O_CAPTURE,
+		.name = "Img3o Output",
+		.cap = V4L2_CAP_VIDEO_CAPTURE_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = dip_img3o_fmts,
+		.num_fmts = ARRAY_SIZE(dip_img3o_fmts),
+		.default_fmt_idx = 0,
+		.default_width = MTK_DIP_CAPTURE_MAX_WIDTH,
+		.default_height = MTK_DIP_CAPTURE_MAX_HEIGHT,
+		.dma_port = 1,
+		.frmsizeenum = &dip_out_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_cap_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "Dip output",
+	},
+	{
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_IMG4O_CAPTURE,
+		.name = "Img4o Output",
+		.cap = V4L2_CAP_VIDEO_CAPTURE_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = dip_img4o_fmts,
+		.num_fmts = ARRAY_SIZE(dip_img4o_fmts),
+		.default_fmt_idx = 0,
+		.default_width = MTK_DIP_CAPTURE_MAX_WIDTH,
+		.default_height = MTK_DIP_CAPTURE_MAX_HEIGHT,
+		.dma_port = 2,
+		.frmsizeenum = &dip_out_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_cap_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "Nr3d output",
+	},
+	{
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_FMO_CAPTURE,
+		.name = "FM Output",
+		.cap = V4L2_CAP_VIDEO_CAPTURE_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = dip_meta_fmts,
+		.num_fmts = ARRAY_SIZE(dip_meta_fmts),
+		.default_fmt_idx = 0,
+		.default_width = MTK_DIP_CAPTURE_MAX_WIDTH,
+		.default_height = MTK_DIP_CAPTURE_MAX_HEIGHT,
+		.dma_port = 3,
+		.frmsizeenum = &dip_out_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_cap_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "FM output",
+	},
+	{
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_TNRSO_CAPTURE,
+		.name = "Tnrso Output",
+		.cap = V4L2_CAP_VIDEO_CAPTURE_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = dip_meta_fmts,
+		.num_fmts = ARRAY_SIZE(dip_meta_fmts),
+		.default_fmt_idx = 0,
+		.default_width = MTK_DIP_CAPTURE_MAX_WIDTH,
+		.default_height = MTK_DIP_CAPTURE_MAX_HEIGHT,
+		.dma_port = 4,
+		.frmsizeenum = &dip_out_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_cap_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "statistics output",
+	},
+	{
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_TNRWO_CAPTURE,
+		.name = "Tnrwo Output",
+		.cap = V4L2_CAP_VIDEO_CAPTURE_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = dip_meta_fmts,
+		.num_fmts = ARRAY_SIZE(dip_meta_fmts),
+		.default_fmt_idx = 0,
+		.default_width = MTK_DIP_CAPTURE_MAX_WIDTH,
+		.default_height = MTK_DIP_CAPTURE_MAX_HEIGHT,
+		.dma_port = 5,
+		.frmsizeenum = &dip_out_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_cap_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "Weighting output",
+	},
+	{
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_TNRMO_CAPTURE,
+		.name = "Tnrmo Output",
+		.cap = V4L2_CAP_VIDEO_CAPTURE_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = dip_meta_fmts,
+		.num_fmts = ARRAY_SIZE(dip_meta_fmts),
+		.default_fmt_idx = 0,
+		.default_width = MTK_DIP_CAPTURE_MAX_WIDTH,
+		.default_height = MTK_DIP_CAPTURE_MAX_HEIGHT,
+		.dma_port = 6,
+		.frmsizeenum = &dip_out_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_cap_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "Motion Map output",
+	},
+};
+
+#endif // _MTK_DIP_V4L2_VNODE_H_
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_71/modules/mtk_imgsys-adl.c b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_71/modules/mtk_imgsys-adl.c
new file mode 100644
index 0000000000000000000000000000000000000000..ab0461f3d5f9c4f8d01c9b18cd368ef0671e9062
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_71/modules/mtk_imgsys-adl.c
@@ -0,0 +1,361 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2020 MediaTek Inc.
+ *
+ * Author: ChenHung Yang <chenhung.yang@mediatek.com>
+ *
+ */
+
+ // Standard C header file
+
+// kernel header file
+#include <linux/device.h>
+#include <linux/of_address.h>
+#include <dma-iommu.h>
+#include <linux/pm_runtime.h>
+#include <linux/remoteproc.h>
+#include <linux/soc/mediatek/mtk_sip_svc.h>
+#include <linux/arm-smccc.h>
+
+// mtk imgsys local header file
+
+// Local header file
+#include "mtk_imgsys-adl.h"
+
+static bool have_adl;
+static void __iomem *g_adl_a_va;
+static void __iomem *g_adl_b_va;
+
+enum imgsys_smc_control {
+	IMGSYS_ADL_SET_DOMAIN
+};
+
+void imgsys_adl_init(struct mtk_imgsys_dev *imgsys_dev)
+{
+	struct resource adl;
+
+	pr_debug("%s: +\n", __func__);
+
+	adl.start = 0;
+	if (of_address_to_resource(imgsys_dev->dev->of_node, REG_MAP_E_ADL_A, &adl)) {
+		pr_info("%s: of_address_to_resource fail\n", __func__);
+		return;
+	}
+
+	if (adl.start) {
+		// ADL_A: 0x15005300
+		g_adl_a_va = of_iomap(imgsys_dev->dev->of_node, REG_MAP_E_ADL_A);
+
+		// ADL_B: 0x15007300
+		g_adl_b_va = of_iomap(imgsys_dev->dev->of_node, REG_MAP_E_ADL_B);
+
+		have_adl = true;
+	} else {
+		have_adl = false;
+	}
+
+	pr_debug("%s: -\n", __func__);
+}
+
+void imgsys_adl_set(struct mtk_imgsys_dev *imgsys_dev)
+{
+	struct arm_smccc_res res;
+
+	pr_debug("%s: +\n", __func__);
+
+	if (have_adl) {
+		arm_smccc_smc(1, IMGSYS_ADL_SET_DOMAIN, 0,
+			0, 0, 0, 0, 0, &res);
+	}
+
+	pr_debug("%s: -\n", __func__);
+}
+
+static void dump_adl_register(struct mtk_imgsys_dev *imgsys_dev,
+	uint32_t reg_base_pa, void __iomem *reg_base_va, uint32_t size)
+{
+	int32_t index;
+
+	for (index = 0; index <= size; index += 0x10) {
+		pr_info("[0x%08X] 0x%08X 0x%08X 0x%08X 0x%08X",
+			(uint32_t)(reg_base_pa + index),
+			(uint32_t)ioread32((void *)(reg_base_va + index)),
+			(uint32_t)ioread32((void *)(reg_base_va + index + 0x4)),
+			(uint32_t)ioread32((void *)(reg_base_va + index + 0x8)),
+			(uint32_t)ioread32((void *)(reg_base_va + index + 0xC)));
+	}
+}
+
+static uint32_t dump_debug_data(struct mtk_imgsys_dev *imgsys_dev,
+	uint32_t reg_base_pa, void __iomem *reg_base_va, uint32_t sel_reg_ofst,
+	uint32_t debug_cmd, uint32_t data_reg_ofst)
+{
+	uint32_t value;
+
+	iowrite32(debug_cmd, (reg_base_va + sel_reg_ofst));
+	value = (uint32_t)ioread32((reg_base_va + data_reg_ofst));
+	pr_info("[0x%08x:0x%08X](0x%08X,0x%08X)\n",
+		(reg_base_pa + sel_reg_ofst), debug_cmd, (reg_base_pa + data_reg_ofst), value);
+
+	return value;
+}
+
+static void dump_dma_debug_data(struct mtk_imgsys_dev *imgsys_dev,
+	uint32_t reg_base_pa, void __iomem *reg_base_va)
+{
+	uint32_t debug_cmd;
+	uint32_t debug_data;
+	uint32_t debug_rdy;
+	uint32_t debug_req;
+
+	/* cmd_length[15:0], mdle_cnt[15:0] */
+	debug_cmd = 0x0A0;
+	debug_data = dump_debug_data(imgsys_dev, reg_base_pa, reg_base_va, IPUDMATOP_DMA_DBG_SEL,
+		debug_cmd, IMGADL_ADL_DMA_0_DEBUG);
+	pr_info("[adl_ipui_dma_even]mdle_cnt(0x%X), cmd_length(0x%X)\n",
+		debug_data & 0x0FFFF, (debug_data >> 16) & 0x0FFFF);
+
+	/* sot_st, eol_st, eot_st, sof,sot, eol, eot, req, rdy,7b0, checksum_out */
+	debug_cmd = 0x100;
+	debug_data = dump_debug_data(imgsys_dev, reg_base_pa, reg_base_va, IPUDMATOP_DMA_DBG_SEL,
+		debug_cmd, IMGADL_ADL_DMA_0_DEBUG);
+	debug_rdy = ((debug_data & 0x0800000) > 0) ? 1 : 0;
+	debug_req = ((debug_data & 0x1000000) > 0) ? 1 : 0;
+	pr_info("[adl_ipui_dma_even]checksum(0x%X),rdy(%d) req(%d)\n",
+		debug_data & 0x0FFFF, debug_rdy, debug_req);
+
+	/* line_cnt[15:0],  pix_cnt[15:0] */
+	debug_cmd = 0x200;
+	debug_data = dump_debug_data(imgsys_dev, reg_base_pa, reg_base_va, IPUDMATOP_DMA_DBG_SEL,
+		debug_cmd, IMGADL_ADL_DMA_0_DEBUG);
+	pr_info("[adl_ipui_dma_even]pix_cnt(0x%X), line_cnt(0x%X)\n",
+		debug_data & 0x0FFFF, (debug_data >> 16) & 0x0FFFF);
+
+	/* line_cnt_reg[15:0], pix_cnt_reg[15:0] */
+	debug_cmd = 0x300;
+	debug_data = dump_debug_data(imgsys_dev, reg_base_pa, reg_base_va, IPUDMATOP_DMA_DBG_SEL,
+		debug_cmd, IMGADL_ADL_DMA_0_DEBUG);
+	pr_info("[adl_ipui_dma_even]pix_cnt_reg(0x%X), line_cnt_reg(0x%X)\n",
+		debug_data & 0xFFFF, (debug_data >> 16) & 0x0FFFF);
+
+	debug_cmd = 0x400;
+	dump_debug_data(imgsys_dev, reg_base_pa, reg_base_va, IPUDMATOP_DMA_DBG_SEL,
+		debug_cmd, IMGADL_ADL_DMA_0_DEBUG);
+
+	debug_cmd = 0x500;
+	dump_debug_data(imgsys_dev, reg_base_pa, reg_base_va, IPUDMATOP_DMA_DBG_SEL,
+		debug_cmd, IMGADL_ADL_DMA_0_DEBUG);
+
+	debug_cmd = 0x600;
+	dump_debug_data(imgsys_dev, reg_base_pa, reg_base_va, IPUDMATOP_DMA_DBG_SEL,
+		debug_cmd, IMGADL_ADL_DMA_0_DEBUG);
+
+	debug_cmd = 0x700;
+	dump_debug_data(imgsys_dev, reg_base_pa, reg_base_va, IPUDMATOP_DMA_DBG_SEL,
+		debug_cmd, IMGADL_ADL_DMA_0_DEBUG);
+
+	debug_cmd = 0x800;
+	dump_debug_data(imgsys_dev, reg_base_pa, reg_base_va, IPUDMATOP_DMA_DBG_SEL,
+		debug_cmd, IMGADL_ADL_DMA_0_DEBUG);
+
+	debug_cmd = 0x900;
+	dump_debug_data(imgsys_dev, reg_base_pa, reg_base_va, IPUDMATOP_DMA_DBG_SEL,
+		debug_cmd, IMGADL_ADL_DMA_0_DEBUG);
+
+	/* cmd_length[15:0], mdle_cnt[15:0] */
+	debug_cmd = 0x0A1;
+	debug_data = dump_debug_data(imgsys_dev, reg_base_pa, reg_base_va, IPUDMATOP_DMA_DBG_SEL,
+		debug_cmd, IMGADL_ADL_DMA_0_DEBUG);
+	pr_info("[adl_ipui_dma_odd]mdle_cnt(0x%X), cmd_length(0x%X)\n",
+		debug_data & 0x0FFFF, (debug_data >> 16) & 0x0FFFF);
+
+	/* sot_st, eol_st, eot_st, sof,sot, eol, eot, req, rdy,7b0, checksum_out */
+	debug_cmd = 0x1100;
+	debug_data = dump_debug_data(imgsys_dev, reg_base_pa, reg_base_va, IPUDMATOP_DMA_DBG_SEL,
+		debug_cmd, IMGADL_ADL_DMA_0_DEBUG);
+	debug_rdy = ((debug_data & 0x0800000) > 0) ? 1 : 0;
+	debug_req = ((debug_data & 0x1000000) > 0) ? 1 : 0;
+	pr_info("[adl_ipui_dma_odd]checksum(0x%X),rdy(%d) req(%d)\n",
+		debug_data & 0x0FFFF, debug_rdy, debug_req);
+
+	/* line_cnt[15:0],  pix_cnt[15:0] */
+	debug_cmd = 0x1200;
+	debug_data = dump_debug_data(imgsys_dev, reg_base_pa, reg_base_va, IPUDMATOP_DMA_DBG_SEL,
+		debug_cmd, IMGADL_ADL_DMA_0_DEBUG);
+	pr_info("[adl_ipui_dma_odd]pix_cnt(0x%X), line_cnt(0x%X)\n",
+		debug_data & 0x0FFFF, (debug_data >> 16) & 0x0FFFF);
+
+	/* line_cnt_reg[15:0], pix_cnt_reg[15:0] */
+	debug_cmd = 0x1300;
+	debug_data = dump_debug_data(imgsys_dev, reg_base_pa, reg_base_va, IPUDMATOP_DMA_DBG_SEL,
+		debug_cmd, IMGADL_ADL_DMA_0_DEBUG);
+	pr_info("[adl_ipui_dma_odd]pix_cnt_reg(0x%X), line_cnt_reg(0x%X)\n",
+		debug_data & 0xFFFF, (debug_data >> 16) & 0x0FFFF);
+
+	debug_cmd = 0x1400;
+	dump_debug_data(imgsys_dev, reg_base_pa, reg_base_va, IPUDMATOP_DMA_DBG_SEL,
+		debug_cmd, IMGADL_ADL_DMA_0_DEBUG);
+
+	debug_cmd = 0x1500;
+	dump_debug_data(imgsys_dev, reg_base_pa, reg_base_va, IPUDMATOP_DMA_DBG_SEL,
+		debug_cmd, IMGADL_ADL_DMA_0_DEBUG);
+
+	debug_cmd = 0x1600;
+	dump_debug_data(imgsys_dev, reg_base_pa, reg_base_va, IPUDMATOP_DMA_DBG_SEL,
+		debug_cmd, IMGADL_ADL_DMA_0_DEBUG);
+
+	debug_cmd = 0x1700;
+	dump_debug_data(imgsys_dev, reg_base_pa, reg_base_va, IPUDMATOP_DMA_DBG_SEL,
+		debug_cmd, IMGADL_ADL_DMA_0_DEBUG);
+
+	debug_cmd = 0x1800;
+	dump_debug_data(imgsys_dev, reg_base_pa, reg_base_va, IPUDMATOP_DMA_DBG_SEL,
+		debug_cmd, IMGADL_ADL_DMA_0_DEBUG);
+
+	debug_cmd = 0x1900;
+	dump_debug_data(imgsys_dev, reg_base_pa, reg_base_va, IPUDMATOP_DMA_DBG_SEL,
+		debug_cmd, IMGADL_ADL_DMA_0_DEBUG);
+}
+
+static void dump_cq_debug_data(struct mtk_imgsys_dev *imgsys_dev,
+	uint32_t reg_base_pa, void __iomem *reg_base_va)
+{
+	void __iomem *cq_ctrl = (void *)(reg_base_va + IMGADLCQ_CQ_EN);
+	uint32_t debug_cmd;
+
+	/* Set ADLCQ_CQ_EN[28] to 1 */
+	iowrite32(0x10000000, cq_ctrl);
+
+	/* cqd0_checksum0 */
+	debug_cmd = (0x02 << 8) | (0x00 << 4);
+	dump_debug_data(imgsys_dev, reg_base_pa, reg_base_va, IMGADL_ADL_DMA_0_DEBUG_SEL,
+		debug_cmd, IMGADL_ADL_CQ_DEBUG);
+
+	/* cqd0_checksum1 */
+	debug_cmd = (0x02 << 8) | (0x01 << 4);
+	dump_debug_data(imgsys_dev, reg_base_pa, reg_base_va, IMGADL_ADL_DMA_0_DEBUG_SEL,
+		debug_cmd, IMGADL_ADL_CQ_DEBUG);
+
+	/* cqd0_checksum2 */
+	debug_cmd = (0x02 << 8) | (0x02 << 4);
+	dump_debug_data(imgsys_dev, reg_base_pa, reg_base_va, IMGADL_ADL_DMA_0_DEBUG_SEL,
+		debug_cmd, IMGADL_ADL_CQ_DEBUG);
+
+	/* cqd1_checksum0 */
+	debug_cmd = (0x02 << 8) | (0x04 << 4);
+	dump_debug_data(imgsys_dev, reg_base_pa, reg_base_va, IMGADL_ADL_DMA_0_DEBUG_SEL,
+		debug_cmd, IMGADL_ADL_CQ_DEBUG);
+
+	/* cqd1_checksum1 */
+	debug_cmd = (0x02 << 8) | (0x05 << 4);
+	dump_debug_data(imgsys_dev, reg_base_pa, reg_base_va, IMGADL_ADL_DMA_0_DEBUG_SEL,
+		debug_cmd, IMGADL_ADL_CQ_DEBUG);
+
+	/* cqd1_checksum2 */
+	debug_cmd = (0x02 << 8) | (0x06 << 4);
+	dump_debug_data(imgsys_dev, reg_base_pa, reg_base_va, IMGADL_ADL_DMA_0_DEBUG_SEL,
+		debug_cmd, IMGADL_ADL_CQ_DEBUG);
+
+	/* cqa0_checksum0 */
+	debug_cmd = (0x02 << 8) | (0x08 << 4);
+	dump_debug_data(imgsys_dev, reg_base_pa, reg_base_va, IMGADL_ADL_DMA_0_DEBUG_SEL,
+		debug_cmd, IMGADL_ADL_CQ_DEBUG);
+
+	/* cqa0_checksum1 */
+	debug_cmd = (0x02 << 8) | (0x09 << 4);
+	dump_debug_data(imgsys_dev, reg_base_pa, reg_base_va, IMGADL_ADL_DMA_0_DEBUG_SEL,
+		debug_cmd, IMGADL_ADL_CQ_DEBUG);
+
+	/* cqa0_checksum2 */
+	debug_cmd = (0x02 << 8) | (0x0A << 4);
+	dump_debug_data(imgsys_dev, reg_base_pa, reg_base_va, IMGADL_ADL_DMA_0_DEBUG_SEL,
+		debug_cmd, IMGADL_ADL_CQ_DEBUG);
+
+	/* cqa1_checksum0 */
+	debug_cmd = (0x02 << 8) | (0x0C << 4);
+	dump_debug_data(imgsys_dev, reg_base_pa, reg_base_va, IMGADL_ADL_DMA_0_DEBUG_SEL,
+		debug_cmd, IMGADL_ADL_CQ_DEBUG);
+
+	/* cqa1_checksum1 */
+	debug_cmd = (0x02 << 8) | (0x0D << 4);
+	dump_debug_data(imgsys_dev, reg_base_pa, reg_base_va, IMGADL_ADL_DMA_0_DEBUG_SEL,
+		debug_cmd, IMGADL_ADL_CQ_DEBUG);
+
+	/* cqa1_checksum2 */
+	debug_cmd = (0x02 << 8) | (0x0E << 4);
+	dump_debug_data(imgsys_dev, reg_base_pa, reg_base_va, IMGADL_ADL_DMA_0_DEBUG_SEL,
+		debug_cmd, IMGADL_ADL_CQ_DEBUG);
+}
+
+static void dump_cq_rdma_status(struct mtk_imgsys_dev *imgsys_dev,
+		uint32_t reg_base_pa, void __iomem *reg_base_va)
+{
+	uint32_t debug_cmd;
+
+	/* 0x3: cq_rdma_req_st     */
+	debug_cmd = (0x3 << 8);
+	dump_debug_data(imgsys_dev, reg_base_pa, reg_base_va, CQP2ENGDMATOP_DMA_DBG_SEL,
+		debug_cmd, IMGADL_ADL_CQ_DMA_DEBUG);
+
+	/* 0x4: cq_rdma_rdy_st     */
+	debug_cmd = (0x4 << 8);
+	dump_debug_data(imgsys_dev, reg_base_pa, reg_base_va, CQP2ENGDMATOP_DMA_DBG_SEL,
+		debug_cmd, IMGADL_ADL_CQ_DMA_DEBUG);
+
+	/* 0x5: cq_rdma_valid      */
+	debug_cmd = (0x5 << 8);
+	dump_debug_data(imgsys_dev, reg_base_pa, reg_base_va, CQP2ENGDMATOP_DMA_DBG_SEL,
+		debug_cmd, IMGADL_ADL_CQ_DMA_DEBUG);
+}
+
+void imgsys_adl_debug_dump(struct mtk_imgsys_dev *imgsys_dev,
+	uint32_t engine)
+{
+	if (have_adl == false)
+		return;
+
+	if (engine & IMGSYS_ENG_ADL_A) {
+		dump_dma_debug_data(imgsys_dev, IMGADL_A_REG_BASE, g_adl_a_va);
+
+		/* 0x2: cq_debug_data */
+		dump_cq_debug_data(imgsys_dev, IMGADL_A_REG_BASE, g_adl_a_va);
+
+		/* 0x3 ~ 0x5 cq rdma status */
+		dump_cq_rdma_status(imgsys_dev, IMGADL_A_REG_BASE, g_adl_a_va);
+
+		/* dump adl register map */
+		dump_adl_register(imgsys_dev, IMGADL_A_REG_BASE, g_adl_a_va, IMGADL_A_DUMP_SIZE);
+	}
+
+	if (engine & IMGSYS_ENG_ADL_B) {
+		dump_dma_debug_data(imgsys_dev, IMGADL_B_REG_BASE, g_adl_b_va);
+
+		/* 0x2: cq_debug_data */
+		dump_cq_debug_data(imgsys_dev, IMGADL_B_REG_BASE, g_adl_b_va);
+
+		/* 0x3 ~ 0x5 cq rdma status */
+		dump_cq_rdma_status(imgsys_dev, IMGADL_B_REG_BASE, g_adl_b_va);
+
+		/* dump adl register map */
+		dump_adl_register(imgsys_dev, IMGADL_B_REG_BASE, g_adl_b_va, IMGADL_B_DUMP_SIZE);
+	}
+}
+
+void imgsys_adl_uninit(struct mtk_imgsys_dev *imgsys_dev)
+{
+	pr_debug("%s+\n", __func__);
+
+	if (have_adl == true) {
+		if (g_adl_a_va) {
+			iounmap(g_adl_a_va);
+			g_adl_a_va = 0L;
+		}
+
+		if (g_adl_b_va) {
+			iounmap(g_adl_b_va);
+			g_adl_b_va = 0L;
+		}
+	}
+
+	pr_debug("%s-\n", __func__);
+}
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_71/modules/mtk_imgsys-adl.h b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_71/modules/mtk_imgsys-adl.h
new file mode 100644
index 0000000000000000000000000000000000000000..2fac022bae565bb3d09b2ef2b062fd5fe9a872da
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_71/modules/mtk_imgsys-adl.h
@@ -0,0 +1,51 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2020 MediaTek Inc.
+ *
+ * Author: ChenHung Yang <chenhung.yang@mediatek.com>
+ *
+ */
+
+#ifndef _MTK_IMGSYS_ADL_H_
+#define _MTK_IMGSYS_ADL_H_
+
+// Standard C header file
+
+// kernel header file
+
+// mtk imgsys local header file
+#include <mtk_imgsys-dev.h>
+
+// Local header file
+#include "mtk_imgsys-engine.h"
+
+// ADL A & B register base
+#define IMGADL_A_REG_BASE           (0x15005000)
+#define IMGADL_B_REG_BASE           (0x15007000)
+
+#define IMGADL_A_DUMP_SIZE          (0x1500)
+#define IMGADL_B_DUMP_SIZE          (0x1500)
+
+// Debug port offset
+#define IPUDMATOP_DMA_DBG_SEL       (0x0070)
+#define IMGADL_ADL_RESET            (0x0300)
+#define IMGADL_ADL_DMA_0_DEBUG      (0x0350)
+#define IMGADL_ADL_DMA_0_DEBUG_SEL  (0x0354)
+#define IMGADL_ADL_CQ_DEBUG         (0x0358)
+#define IMGADL_ADL_CQ_DMA_DEBUG     (0x035C)
+#define IMGADLCQ_CQ_EN              (0x1000)
+#define CQP2ENGDMATOP_DMA_DBG_SEL   (0x1270)
+
+//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+// Public Functions
+//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+void imgsys_adl_init(struct mtk_imgsys_dev *imgsys_dev);
+
+void imgsys_adl_set(struct mtk_imgsys_dev *imgsys_dev);
+
+void imgsys_adl_debug_dump(struct mtk_imgsys_dev *imgsys_dev,
+	uint32_t engine);
+
+void imgsys_adl_uninit(struct mtk_imgsys_dev *imgsys_dev);
+
+#endif /* _MTK_IMGSYS_ADL_H_ */
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_71/modules/mtk_imgsys-dip.c b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_71/modules/mtk_imgsys-dip.c
new file mode 100644
index 0000000000000000000000000000000000000000..65019c078e50d07fa671c2b54fd8daa9703adc72
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_71/modules/mtk_imgsys-dip.c
@@ -0,0 +1,307 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2018 MediaTek Inc.
+ *
+ * Author: Frederic Chen <frederic.chen@mediatek.com>
+ *         Holmes Chiou <holmes.chiou@mediatek.com>
+ *
+ */
+
+#include <linux/device.h>
+#include <linux/of_address.h>
+#include <dma-iommu.h>
+#include <linux/pm_runtime.h>
+#include <linux/remoteproc.h>
+#include "mtk_imgsys-dip.h"
+
+const struct mtk_imgsys_init_array mtk_imgsys_dip_init_ary[] = {
+	{0x094, 0x80000000},	/* DIPCTL_D1A_DIPCTL_INT1_EN */
+	{0x0A0, 0x0},	/* DIPCTL_D1A_DIPCTL_INT2_EN */
+	{0x0AC, 0x0},	/* DIPCTL_D1A_DIPCTL_INT3_EN */
+	{0x0C4, 0x0},	/* DIPCTL_D1A_DIPCTL_CQ_INT1_EN */
+	{0x0D0, 0x0},	/* DIPCTL_D1A_DIPCTL_CQ_INT2_EN */
+	{0x0DC, 0x0},	/* DIPCTL_D1A_DIPCTL_CQ_INT3_EN */
+	{0x208, 0x11},	/* DIPCQ_D1A_DIPCQ_CQ_THR0_CTL */
+	{0x218, 0x11},	/* DIPCQ_D1A_DIPCQ_CQ_THR1_CTL */
+	{0x228, 0x11},	/* DIPCQ_D1A_DIPCQ_CQ_THR2_CTL */
+	{0x238, 0x11},	/* DIPCQ_D1A_DIPCQ_CQ_THR3_CTL */
+	{0x248, 0x11},	/* DIPCQ_D1A_DIPCQ_CQ_THR4_CTL */
+	{0x258, 0x11},	/* DIPCQ_D1A_DIPCQ_CQ_THR5_CTL */
+	{0x268, 0x11},	/* DIPCQ_D1A_DIPCQ_CQ_THR6_CTL */
+	{0x278, 0x11},	/* DIPCQ_D1A_DIPCQ_CQ_THR7_CTL */
+	{0x288, 0x11},	/* DIPCQ_D1A_DIPCQ_CQ_THR8_CTL */
+	{0x298, 0x11},	/* DIPCQ_D1A_DIPCQ_CQ_THR9_CTL */
+	{0x2A8, 0x11},	/* DIPCQ_D1A_DIPCQ_CQ_THR10_CTL */
+	{0x2B8, 0x11},	/* DIPCQ_D1A_DIPCQ_CQ_THR11_CTL */
+	{0x2C8, 0x11},	/* DIPCQ_D1A_DIPCQ_CQ_THR12_CTL */
+	{0x2D8, 0x11},	/* DIPCQ_D1A_DIPCQ_CQ_THR13_CTL */
+	{0x2E8, 0x11},	/* DIPCQ_D1A_DIPCQ_CQ_THR14_CTL */
+	{0x2F8, 0x11},	/* DIPCQ_D1A_DIPCQ_CQ_THR15_CTL */
+	{0x308, 0x11},	/* DIPCQ_D1A_DIPCQ_CQ_THR16_CTL */
+	{0x318, 0x11},	/* DIPCQ_D1A_DIPCQ_CQ_THR17_CTL */
+	{0x328, 0x11},	/* DIPCQ_D1A_DIPCQ_CQ_THR18_CTL */
+};
+
+#define DIP_HW_SET 2
+
+void __iomem *gdipRegBA[DIP_HW_SET] = {0L};
+
+void imgsys_dip_set_initial_value(struct mtk_imgsys_dev *imgsys_dev)
+{
+	unsigned int hw_idx = 0, ary_idx = 0;
+
+	pr_debug("%s: +\n", __func__);
+	dev_dbg(imgsys_dev->dev, "%s: +\n", __func__);
+
+	for (hw_idx = REG_MAP_E_DIP; hw_idx <= REG_MAP_E_DIP_NR; hw_idx++) {
+		/* iomap registers */
+		ary_idx = hw_idx - REG_MAP_E_DIP;
+		gdipRegBA[ary_idx] = of_iomap(imgsys_dev->dev->of_node, hw_idx);
+		if (!gdipRegBA[ary_idx]) {
+			dev_info(imgsys_dev->dev,
+				"%s: error: unable to iomap dip_%d registers, devnode(%s).\n",
+				__func__, hw_idx, imgsys_dev->dev->of_node->name);
+			continue;
+		}
+	}
+
+	pr_debug("%s: -\n", __func__);
+	dev_dbg(imgsys_dev->dev, "%s: -\n", __func__);
+}
+EXPORT_SYMBOL(imgsys_dip_set_initial_value);
+
+void imgsys_dip_set_hw_initial_value(struct mtk_imgsys_dev *imgsys_dev)
+{
+	void __iomem *dipRegBA = 0L;
+	void __iomem *ofset = NULL;
+	unsigned int i;
+
+	/* iomap registers */
+	dipRegBA = gdipRegBA[0]; // dip: 0x15100000
+
+for (i = 0 ; i < sizeof(mtk_imgsys_dip_init_ary)/sizeof(struct mtk_imgsys_init_array) ; i++) {
+	ofset = dipRegBA + mtk_imgsys_dip_init_ary[i].ofset;
+	writel(mtk_imgsys_dip_init_ary[i].val, ofset);
+}
+}
+EXPORT_SYMBOL(imgsys_dip_set_hw_initial_value);
+
+void imgsys_dip_debug_dump(struct mtk_imgsys_dev *imgsys_dev,
+							unsigned int engine)
+{
+	void __iomem *dipRegBA = 0L;
+	unsigned int i;
+
+	pr_info("%s: +\n", __func__);
+	dev_dbg(imgsys_dev->dev, "%s: +\n", __func__);
+
+	/* iomap registers */
+	dipRegBA = gdipRegBA[0]; // dip: 0x15100000
+
+	dev_info(imgsys_dev->dev, "%s: dump dip ctl regs\n", __func__);
+	for (i = TOP_CTL_OFFSET; i <= TOP_CTL_OFFSET + TOP_CTL_RANGE; i += 0x10) {
+		dev_info(imgsys_dev->dev, "%s: [0x%08X 0x%08X][0x%08X 0x%08X][0x%08X 0x%08X][0x%08X 0x%08X]",
+		__func__, (unsigned int)(0x15100000 + i),
+		(unsigned int)ioread32((void *)(dipRegBA + i)),
+		(unsigned int)(0x15100000 + i + 0x4),
+		(unsigned int)ioread32((void *)(dipRegBA + i + 0x4)),
+		(unsigned int)(0x15100000 + i + 0x8),
+		(unsigned int)ioread32((void *)(dipRegBA + i + 0x8)),
+		(unsigned int)(0x15100000 + i + 0xc),
+		(unsigned int)ioread32((void *)(dipRegBA + i + 0xc)));
+	}
+
+	dev_info(imgsys_dev->dev, "%s: dump dip dmatop regs\n", __func__);
+	for (i = DMATOP_OFFSET; i <= DMATOP_OFFSET + DMATOP_RANGE; i += 0x10) {
+		dev_info(imgsys_dev->dev, "%s: [0x%08X 0x%08X][0x%08X 0x%08X][0x%08X 0x%08X][0x%08X 0x%08X]",
+		__func__, (unsigned int)(0x15100000 + i),
+		(unsigned int)ioread32((void *)(dipRegBA + i)),
+		(unsigned int)(0x15100000 + i + 0x4),
+		(unsigned int)ioread32((void *)(dipRegBA + i + 0x4)),
+		(unsigned int)(0x15100000 + i + 0x8),
+		(unsigned int)ioread32((void *)(dipRegBA + i + 0x8)),
+		(unsigned int)(0x15100000 + i + 0xc),
+		(unsigned int)ioread32((void *)(dipRegBA + i + 0xc)));
+	}
+
+	dev_info(imgsys_dev->dev, "%s: dump dip rdma regs\n", __func__);
+	for (i = RDMA_OFFSET; i <= RDMA_OFFSET + RDMA_RANGE; i += 0x10) {
+		dev_info(imgsys_dev->dev, "%s: [0x%08X 0x%08X][0x%08X 0x%08X][0x%08X 0x%08X][0x%08X 0x%08X]",
+		__func__, (unsigned int)(0x15100000 + i),
+		(unsigned int)ioread32((void *)(dipRegBA + i)),
+		(unsigned int)(0x15100000 + i + 0x4),
+		(unsigned int)ioread32((void *)(dipRegBA + i + 0x4)),
+		(unsigned int)(0x15100000 + i + 0x8),
+		(unsigned int)ioread32((void *)(dipRegBA + i + 0x8)),
+		(unsigned int)(0x15100000 + i + 0xc),
+		(unsigned int)ioread32((void *)(dipRegBA + i + 0xc)));
+	}
+
+	dev_info(imgsys_dev->dev, "%s: dump dip wdma regs\n", __func__);
+	for (i = WDMA_OFFSET; i <= WDMA_OFFSET + WDMA_RANGE; i += 0x10) {
+		dev_info(imgsys_dev->dev, "%s: [0x%08X 0x%08X][0x%08X 0x%08X][0x%08X 0x%08X][0x%08X 0x%08X]",
+		__func__, (unsigned int)(0x15100000 + i),
+		(unsigned int)ioread32((void *)(dipRegBA + i)),
+		(unsigned int)(0x15100000 + i + 0x4),
+		(unsigned int)ioread32((void *)(dipRegBA + i + 0x4)),
+		(unsigned int)(0x15100000 + i + 0x8),
+		(unsigned int)ioread32((void *)(dipRegBA + i + 0x8)),
+		(unsigned int)(0x15100000 + i + 0xc),
+		(unsigned int)ioread32((void *)(dipRegBA + i + 0xc)));
+	}
+
+	dev_info(imgsys_dev->dev, "%s: dump nr3d ctl regs\n", __func__);
+	for (i = NR3D_CTL_OFFSET; i <= NR3D_CTL_OFFSET + NR3D_CTL_RANGE; i += 0x10) {
+		dev_info(imgsys_dev->dev, "%s: [0x%08X 0x%08X][0x%08X 0x%08X][0x%08X 0x%08X][0x%08X 0x%08X]",
+		__func__, (unsigned int)(0x15100000 + i),
+		(unsigned int)ioread32((void *)(dipRegBA + i)),
+		(unsigned int)(0x15100000 + i + 0x4),
+		(unsigned int)ioread32((void *)(dipRegBA + i + 0x4)),
+		(unsigned int)(0x15100000 + i + 0x8),
+		(unsigned int)ioread32((void *)(dipRegBA + i + 0x8)),
+		(unsigned int)(0x15100000 + i + 0xc),
+		(unsigned int)ioread32((void *)(dipRegBA + i + 0xc)));
+	}
+
+	dev_info(imgsys_dev->dev, "%s: dump tnr ctl regs\n", __func__);
+	for (i = TNR_CTL_OFFSET; i <= TNR_CTL_OFFSET + TNR_CTL_RANGE; i += 0x10) {
+		dev_info(imgsys_dev->dev, "%s: [0x%08X 0x%08X][0x%08X 0x%08X][0x%08X 0x%08X][0x%08X 0x%08X]",
+		__func__, (unsigned int)(0x15100000 + i),
+		(unsigned int)ioread32((void *)(dipRegBA + i)),
+		(unsigned int)(0x15100000 + i + 0x4),
+		(unsigned int)ioread32((void *)(dipRegBA + i + 0x4)),
+		(unsigned int)(0x15100000 + i + 0x8),
+		(unsigned int)ioread32((void *)(dipRegBA + i + 0x8)),
+		(unsigned int)(0x15100000 + i + 0xc),
+		(unsigned int)ioread32((void *)(dipRegBA + i + 0xc)));
+	}
+
+	dipRegBA = gdipRegBA[1]; // dip_nr: 0x15150000
+	dev_info(imgsys_dev->dev, "%s: dump mcrop regs\n", __func__);
+	for (i = MCRP_OFFSET; i <= MCRP_OFFSET + MCRP_RANGE; i += 0x8) {
+		dev_info(imgsys_dev->dev, "%s: [0x%08X 0x%08X][0x%08X 0x%08X]",
+		__func__, (unsigned int)(0x15150000 + i),
+		(unsigned int)ioread32((void *)(dipRegBA + i)),
+		(unsigned int)(0x15150000 + i + 0x4),
+		(unsigned int)ioread32((void *)(dipRegBA + i + 0x4)));
+	}
+
+
+	dev_info(imgsys_dev->dev, "%s: dump dip dmatop regs\n", __func__);
+	for (i = N_DMATOP_OFFSET; i <= N_DMATOP_OFFSET + N_DMATOP_RANGE; i += 0x10) {
+		dev_info(imgsys_dev->dev, "%s: [0x%08X 0x%08X][0x%08X 0x%08X][0x%08X 0x%08X][0x%08X 0x%08X]",
+		__func__, (unsigned int)(0x15150000 + i),
+		(unsigned int)ioread32((void *)(dipRegBA + i)),
+		(unsigned int)(0x15150000 + i + 0x4),
+		(unsigned int)ioread32((void *)(dipRegBA + i + 0x4)),
+		(unsigned int)(0x15150000 + i + 0x8),
+		(unsigned int)ioread32((void *)(dipRegBA + i + 0x8)),
+		(unsigned int)(0x15150000 + i + 0xc),
+		(unsigned int)ioread32((void *)(dipRegBA + i + 0xc)));
+	}
+
+	dev_info(imgsys_dev->dev, "%s: dump dip rdma regs\n", __func__);
+	for (i = N_RDMA_OFFSET; i <= N_RDMA_OFFSET + N_RDMA_RANGE; i += 0x10) {
+		dev_info(imgsys_dev->dev, "%s: [0x%08X 0x%08X][0x%08X 0x%08X][0x%08X 0x%08X][0x%08X 0x%08X]",
+		__func__, (unsigned int)(0x15150000 + i),
+		(unsigned int)ioread32((void *)(dipRegBA + i)),
+		(unsigned int)(0x15150000 + i + 0x4),
+		(unsigned int)ioread32((void *)(dipRegBA + i + 0x4)),
+		(unsigned int)(0x15150000 + i + 0x8),
+		(unsigned int)ioread32((void *)(dipRegBA + i + 0x8)),
+		(unsigned int)(0x15150000 + i + 0xc),
+		(unsigned int)ioread32((void *)(dipRegBA + i + 0xc)));
+	}
+
+	dev_info(imgsys_dev->dev, "%s: dump dip wdma regs\n", __func__);
+	for (i = N_WDMA_OFFSET; i <= N_WDMA_OFFSET + N_WDMA_RANGE; i += 0x10) {
+		dev_info(imgsys_dev->dev, "%s: [0x%08X 0x%08X][0x%08X 0x%08X][0x%08X 0x%08X][0x%08X 0x%08X]",
+		__func__, (unsigned int)(0x15150000 + i),
+		(unsigned int)ioread32((void *)(dipRegBA + i)),
+		(unsigned int)(0x15150000 + i + 0x4),
+		(unsigned int)ioread32((void *)(dipRegBA + i + 0x4)),
+		(unsigned int)(0x15150000 + i + 0x8),
+		(unsigned int)ioread32((void *)(dipRegBA + i + 0x8)),
+		(unsigned int)(0x15150000 + i + 0xc),
+		(unsigned int)ioread32((void *)(dipRegBA + i + 0xc)));
+	}
+
+	dipRegBA = gdipRegBA[0]; // dip: 0x15100000
+
+	/* Set DIPCTL_DBG_SEL[3:0] to 0x1 */
+	/* Set DIPCTL_DBG_SEL[15:8] to 0x18 */
+	/* Set DIPCTL_DBG_SEL[19:6] to 0x1*/
+	dev_info(imgsys_dev->dev, "%s: dipctl_dbg_sel_tnc\n", __func__);
+	iowrite32(0x1801, (void *)(dipRegBA + DIPCTL_DBG_SEL));
+	dev_info(imgsys_dev->dev, "%s: tnc_debug: %08X", __func__,
+	(unsigned int)ioread32((void *)(dipRegBA + DIPCTL_DBG_OUT)));
+
+	/* Set DIPCTL_DBG_SEL[3:0] to 0x1 */
+	/* Set DIPCTL_DBG_SEL[15:8] to 0x0 */
+	/* Set DIPCTL_DBG_SEL[19:6] to 0x0~0xD */
+	dev_info(imgsys_dev->dev, "%s: dipctl_dbg_sel_nr3d\n", __func__);
+	iowrite32(0x13, (void *)(dipRegBA + NR3D_DBG_SEL));
+	iowrite32(0x00001, (void *)(dipRegBA + DIPCTL_DBG_SEL));
+	dev_info(imgsys_dev->dev, "%s: nr3d_sot_latch_32~1: %08X", __func__,
+	(unsigned int)ioread32((void *)(dipRegBA + DIPCTL_DBG_OUT)));
+	iowrite32(0x20001, (void *)(dipRegBA + DIPCTL_DBG_SEL));
+	dev_info(imgsys_dev->dev, "%s: nr3d_eot_latch_32~1: %08X", __func__,
+	(unsigned int)ioread32((void *)(dipRegBA + DIPCTL_DBG_OUT)));
+	iowrite32(0x10001, (void *)(dipRegBA + DIPCTL_DBG_SEL));
+	dev_info(imgsys_dev->dev, "%s: nr3d_sot_latch_33~39: %08X", __func__,
+	(unsigned int)ioread32((void *)(dipRegBA + DIPCTL_DBG_OUT)));
+	iowrite32(0x30001, (void *)(dipRegBA + DIPCTL_DBG_SEL));
+	dev_info(imgsys_dev->dev, "%s: nr3d_eot_latch_33~39: %08X", __func__,
+	(unsigned int)ioread32((void *)(dipRegBA + DIPCTL_DBG_OUT)));
+	iowrite32(0x40001, (void *)(dipRegBA + DIPCTL_DBG_SEL));
+	dev_info(imgsys_dev->dev, "%s: nr3d_tif4~1: %08X", __func__,
+	(unsigned int)ioread32((void *)(dipRegBA + DIPCTL_DBG_OUT)));
+	iowrite32(0x50001, (void *)(dipRegBA + DIPCTL_DBG_SEL));
+	dev_info(imgsys_dev->dev, "%s: nr3d_tif8~5: %08X", __func__,
+	(unsigned int)ioread32((void *)(dipRegBA + DIPCTL_DBG_OUT)));
+	iowrite32(0x60001, (void *)(dipRegBA + DIPCTL_DBG_SEL));
+	dev_info(imgsys_dev->dev, "%s: nr3d_tif12~9: %08X", __func__,
+	(unsigned int)ioread32((void *)(dipRegBA + DIPCTL_DBG_OUT)));
+	iowrite32(0x70001, (void *)(dipRegBA + DIPCTL_DBG_SEL));
+	dev_info(imgsys_dev->dev, "%s: nr3d_tif16~13: %08X", __func__,
+	(unsigned int)ioread32((void *)(dipRegBA + DIPCTL_DBG_OUT)));
+	iowrite32(0x80001, (void *)(dipRegBA + DIPCTL_DBG_SEL));
+	dev_info(imgsys_dev->dev, "%s: nr3d_tif20~17: %08X", __func__,
+	(unsigned int)ioread32((void *)(dipRegBA + DIPCTL_DBG_OUT)));
+	iowrite32(0x90001, (void *)(dipRegBA + DIPCTL_DBG_SEL));
+	dev_info(imgsys_dev->dev, "%s: nr3d_tif24~21: %08X", __func__,
+	(unsigned int)ioread32((void *)(dipRegBA + DIPCTL_DBG_OUT)));
+	iowrite32(0xA0001, (void *)(dipRegBA + DIPCTL_DBG_SEL));
+	dev_info(imgsys_dev->dev, "%s: nr3d_tif28~25: %08X", __func__,
+	(unsigned int)ioread32((void *)(dipRegBA + DIPCTL_DBG_OUT)));
+	iowrite32(0xB0001, (void *)(dipRegBA + DIPCTL_DBG_SEL));
+	dev_info(imgsys_dev->dev, "%s: nr3d_tif32~29: %08X", __func__,
+	(unsigned int)ioread32((void *)(dipRegBA + DIPCTL_DBG_OUT)));
+	iowrite32(0xC0001, (void *)(dipRegBA + DIPCTL_DBG_SEL));
+	dev_info(imgsys_dev->dev, "%s: nr3d_tif36~33: %08X", __func__,
+	(unsigned int)ioread32((void *)(dipRegBA + DIPCTL_DBG_OUT)));
+	iowrite32(0xD0001, (void *)(dipRegBA + DIPCTL_DBG_SEL));
+	dev_info(imgsys_dev->dev, "%s: nr3d_tif39~37: %08X", __func__,
+	(unsigned int)ioread32((void *)(dipRegBA + DIPCTL_DBG_OUT)));
+
+	//dev_dbg(imgsys_dev->dev, "%s: +\n",__func__);
+	//
+	pr_info("%s: -\n", __func__);
+	dev_dbg(imgsys_dev->dev, "%s: -\n", __func__);
+}
+EXPORT_SYMBOL(imgsys_dip_debug_dump);
+
+void imgsys_dip_uninit(struct mtk_imgsys_dev *imgsys_dev)
+{
+	unsigned int i;
+
+	pr_debug("%s: +\n", __func__);
+
+	for (i = 0; i < DIP_HW_SET; i++) {
+		iounmap(gdipRegBA[i]);
+		gdipRegBA[i] = 0L;
+	}
+
+	pr_debug("%s: -\n", __func__);
+}
+EXPORT_SYMBOL(imgsys_dip_uninit);
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_71/modules/mtk_imgsys-dip.h b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_71/modules/mtk_imgsys-dip.h
new file mode 100644
index 0000000000000000000000000000000000000000..28a5e7b296ba83353324fa4536a3df8e6d268bfb
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_71/modules/mtk_imgsys-dip.h
@@ -0,0 +1,50 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2018 MediaTek Inc.
+ *
+ * Author: Frederic Chen <frederic.chen@mediatek.com>
+ *
+ */
+
+#ifndef _MTK_DIP_DIP_H_
+#define _MTK_DIP_DIP_H_
+
+#include "mtk_imgsys-dev.h"
+#include "mtk_imgsys-cmdq.h"
+#include "mtk_imgsys-engine.h"
+/* DIP */
+#define TOP_CTL_OFFSET	0x0000
+#define TOP_CTL_RANGE	0x0334
+#define DMATOP_OFFSET	0x1000
+#define DMATOP_RANGE	0x0CC
+#define RDMA_OFFSET	0x1200
+#define RDMA_RANGE	0x0AAC
+#define WDMA_OFFSET	0x22C0
+#define WDMA_RANGE	0x0C08
+#define NR3D_CTL_OFFSET	0x5000
+#define NR3D_CTL_RANGE	0x484
+#define TNR_CTL_OFFSET	0x6000
+#define TNR_CTL_RANGE	0x0234
+#define DIPCTL_DBG_SEL 0x1A8
+#define DIPCTL_DBG_OUT 0x1AC
+#define NR3D_DBG_SEL 0x500C
+
+/* DIP NR */
+#define MCRP_OFFSET	0xB240
+#define MCRP_RANGE	0x0004
+#define N_DMATOP_OFFSET	0x1000
+#define N_DMATOP_RANGE	0x0CC
+#define N_RDMA_OFFSET	0x1A40
+#define N_RDMA_RANGE	0x04EC
+#define N_WDMA_OFFSET	0x2000
+#define N_WDMA_RANGE	0x0DEC
+
+
+void imgsys_dip_set_initial_value(struct mtk_imgsys_dev *imgsys_dev);
+void imgsys_dip_set_hw_initial_value(struct mtk_imgsys_dev *imgsys_dev);
+void imgsys_dip_debug_dump(struct mtk_imgsys_dev *imgsys_dev,
+							unsigned int engine);
+
+void imgsys_dip_uninit(struct mtk_imgsys_dev *imgsys_dev);
+#endif /* _MTK_DIP_DIP_H_ */
+
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_71/modules/mtk_imgsys-pqdip.c b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_71/modules/mtk_imgsys-pqdip.c
new file mode 100644
index 0000000000000000000000000000000000000000..f4660d83405968f4c53390d283a8173daef08ec9
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_71/modules/mtk_imgsys-pqdip.c
@@ -0,0 +1,552 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2020 MediaTek Inc.
+ *
+ * Author: Daniel Huang <daniel.huang@mediatek.com>
+ *
+ */
+
+ // Standard C header file
+
+// kernel header file
+#include <linux/device.h>
+#include <linux/of_address.h>
+#include <dma-iommu.h>
+#include <linux/pm_runtime.h>
+#include <linux/remoteproc.h>
+
+// mtk imgsys local header file
+
+// Local header file
+#include "mtk_imgsys-pqdip.h"
+
+/********************************************************************
+ * Global Define
+ ********************************************************************/
+#define PQDIP_HW_SET		2
+
+#define PQDIP_BASE_ADDR		0x15210000
+#define PQDIP_OFST			0x300000
+#define PQDIP_ALL_REG_CNT	0x6000
+//#define DUMP_PQ_ALL
+
+#define PQDIP_CTL_OFST		0x0
+#define PQDIP_CQ_OFST		0x200
+#define PQDIP_DMA_OFST		0x1200
+#define PQDIP_WROT1_OFST	0x2000
+#define PQDIP_WROT2_OFST	0x2F00
+#define PQDIP_URZ6T_OFST	0x3000
+#define PQDIP_TDSHP1OFST	0x4120
+#define PQDIP_TDSHP2OFST	0x4510
+#define PQDIP_TDSHP3OFST	0x4570
+#define PQDIP_UNP1_OFST		0x5000
+#define PQDIP_UNP2_OFST		0x5040
+#define PQDIP_UNP3_OFST		0x5080
+#define PQDIP_C02_OFST		0x5100
+#define PQDIP_C24_OFST		0x5140
+#define PQDIP_DRZ8T_OFST	0x5180
+#define PQDIP_DRZ1N_OFST	0x5280
+#define PQDIP_MCRP_OFST		0x53C0
+#define PQDIP_TCC_OFST		0x59E0
+
+#define PQDIP_CTL_REG_CNT		0xE0
+#define PQDIP_CQ_REG_CNT		0x140
+#define PQDIP_DMA_REG_CNT		0x260
+#define PQDIP_WROT1_REG_CNT		0x100
+#define PQDIP_WROT2_REG_CNT		0x50
+#define PQDIP_URZ6T_REG_CNT		0x260
+#define PQDIP_TDSHP1REG_CNT		0x10
+#define PQDIP_TDSHP2REG_CNT		0x10
+#define PQDIP_TDSHP3REG_CNT		0x10
+#define PQDIP_UNP_REG_CNT		0x10
+#define PQDIP_C02_REG_CNT		0x20
+#define PQDIP_C24_REG_CNT		0x10
+#define PQDIP_DRZ8T_REG_CNT		0x30
+#define PQDIP_DRZ1N_REG_CNT		0x30
+#define PQDIP_MCRP_REG_CNT		0x10
+#define PQDIP_TCC_REG_CNT		0x20
+
+#define PQDIPCTL_DBG_SEL_OFST	0xE0
+#define PQDIPCTL_DBG_OUT_OFST	0xE4
+#define PQ_WROT_DBG_SEL_OFST	0x2018
+#define PQ_WROT_DBG_OUT_OFST	0x20D0
+#define PQ_URZ6T_DBG_SEL_OFST	0x3044
+#define PQ_URZ6T_DBG_OUT_OFST	0x3048
+
+/********************************************************************
+ * Global Variable
+ ********************************************************************/
+const struct mtk_imgsys_init_array
+			mtk_imgsys_pqdip_init_ary[] = {
+	{0x0050, 0x80000000},	/* PQDIPCTL_P1A_REG_PQDIPCTL_INT1_EN */
+	{0x0060, 0x0},		/* PQDIPCTL_P1A_REG_PQDIPCTL_INT2_EN */
+	{0x0070, 0x0},		/* PQDIPCTL_P1A_REG_PQDIPCTL_CQ_INT1_EN */
+	{0x0080, 0x0},		/* PQDIPCTL_P1A_REG_PQDIPCTL_CQ_INT2_EN */
+	{0x0090, 0x0},		/* PQDIPCTL_P1A_REG_PQDIPCTL_CQ_INT3_EN */
+	{0x0208, 0x11},		/* DIPCQ_P1A_REG_DIPCQ_CQ_THR0_CTL */
+	{0x0218, 0x11},		/* DIPCQ_P1A_REG_DIPCQ_CQ_THR1_CTL */
+	{0x0228, 0x11},		/* DIPCQ_P1A_REG_DIPCQ_CQ_THR2_CTL */
+	{0x0238, 0x11},		/* DIPCQ_P1A_REG_DIPCQ_CQ_THR3_CTL */
+	{0x0248, 0x11},		/* DIPCQ_P1A_REG_DIPCQ_CQ_THR4_CTL */
+	{0x0258, 0x11},		/* DIPCQ_P1A_REG_DIPCQ_CQ_THR5_CTL */
+	{0x0268, 0x11},		/* DIPCQ_P1A_REG_DIPCQ_CQ_THR6_CTL */
+	{0x0278, 0x11},		/* DIPCQ_P1A_REG_DIPCQ_CQ_THR7_CTL */
+	{0x0288, 0x11},		/* DIPCQ_P1A_REG_DIPCQ_CQ_THR8_CTL */
+	{0x0298, 0x11},		/* DIPCQ_P1A_REG_DIPCQ_CQ_THR9_CTL */
+	{0x02A8, 0x11},		/* DIPCQ_P1A_REG_DIPCQ_CQ_THR10_CTL */
+	{0x02B8, 0x11},		/* DIPCQ_P1A_REG_DIPCQ_CQ_THR11_CTL */
+	{0x02C8, 0x11},		/* DIPCQ_P1A_REG_DIPCQ_CQ_THR12_CTL */
+	{0x02D8, 0x11},		/* DIPCQ_P1A_REG_DIPCQ_CQ_THR13_CTL */
+	{0x02E8, 0x11},		/* DIPCQ_P1A_REG_DIPCQ_CQ_THR14_CTL */
+	{0x02F8, 0x11},		/* DIPCQ_P1A_REG_DIPCQ_CQ_THR15_CTL */
+	{0x0308, 0x11},		/* DIPCQ_P1A_REG_DIPCQ_CQ_THR16_CTL */
+	{0x0318, 0x11},		/* DIPCQ_P1A_REG_DIPCQ_CQ_THR17_CTL */
+	{0x0328, 0x11},		/* DIPCQ_P1A_REG_DIPCQ_CQ_THR18_CTL */
+};
+
+#define PQDIP_INIT_ARRAY_COUNT	ARRAY_SIZE(mtk_imgsys_pqdip_init_ary)
+
+void __iomem *gpqdipRegBA[PQDIP_HW_SET] = {0L};
+//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+// Public Functions
+//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+void imgsys_pqdip_set_initial_value(struct mtk_imgsys_dev *imgsys_dev)
+{
+	unsigned int hw_idx = 0;
+
+	dev_dbg(imgsys_dev->dev, "%s: +\n", __func__);
+
+	for (hw_idx = 0 ; hw_idx < PQDIP_HW_SET ; hw_idx++) {
+		/* iomap registers */
+		gpqdipRegBA[hw_idx] = of_iomap(imgsys_dev->dev->of_node,
+			REG_MAP_E_PQDIP_A + hw_idx);
+	}
+
+	dev_dbg(imgsys_dev->dev, "%s: -\n", __func__);
+}
+EXPORT_SYMBOL(imgsys_pqdip_set_initial_value);
+
+void imgsys_pqdip_set_hw_initial_value(struct mtk_imgsys_dev *imgsys_dev)
+{
+	void __iomem *ofset = NULL;
+	unsigned int hw_idx = 0;
+	unsigned int i = 0;
+
+	dev_dbg(imgsys_dev->dev, "%s: +\n", __func__);
+
+	for (hw_idx = 0 ; hw_idx < PQDIP_HW_SET ; hw_idx++) {
+		for (i = 0 ; i < PQDIP_INIT_ARRAY_COUNT ; i++) {
+			ofset = gpqdipRegBA[hw_idx]
+				+ mtk_imgsys_pqdip_init_ary[i].ofset;
+			writel(mtk_imgsys_pqdip_init_ary[i].val, ofset);
+		}
+	}
+
+	dev_dbg(imgsys_dev->dev, "%s: -\n", __func__);
+}
+EXPORT_SYMBOL(imgsys_pqdip_set_hw_initial_value);
+
+void imgsys_pqdip_debug_dump(struct mtk_imgsys_dev *imgsys_dev,
+							unsigned int engine)
+{
+	void __iomem *pqdipRegBA = 0L;
+	unsigned int hw_idx = 0;
+	unsigned int i = 0;
+
+	dev_info(imgsys_dev->dev, "%s: +\n", __func__);
+
+	for (hw_idx = 0 ; hw_idx < PQDIP_HW_SET ; hw_idx++) {
+		/* iomap registers */
+		pqdipRegBA = gpqdipRegBA[hw_idx];
+#ifdef DUMP_PQ_ALL
+		for (i = 0x0; i < PQDIP_ALL_REG_CNT; i += 0x10) {
+			dev_info(imgsys_dev->dev, "%s:  [0x%08x] 0x%08x 0x%08x 0x%08x 0x%08x",
+			__func__, (unsigned int)(PQDIP_BASE_ADDR + (PQDIP_OFST * hw_idx) + i),
+			(unsigned int)ioread32((void *)(pqdipRegBA + i + 0x00)),
+			(unsigned int)ioread32((void *)(pqdipRegBA + i + 0x04)),
+			(unsigned int)ioread32((void *)(pqdipRegBA + i + 0x08)),
+			(unsigned int)ioread32((void *)(pqdipRegBA + i + 0x0c)));
+		}
+#else
+		dev_info(imgsys_dev->dev, "%s:  ctl_reg", __func__);
+		for (i = 0x0; i < PQDIP_CTL_REG_CNT; i += 0x10) {
+			dev_info(imgsys_dev->dev, "%s:  [0x%08x] 0x%08x 0x%08x 0x%08x 0x%08x",
+			__func__, (unsigned int)(PQDIP_BASE_ADDR + (PQDIP_OFST * hw_idx)
+				+ PQDIP_CTL_OFST + i),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_CTL_OFST + i + 0x00)),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_CTL_OFST + i + 0x04)),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_CTL_OFST + i + 0x08)),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_CTL_OFST + i + 0x0c)));
+		}
+
+		dev_info(imgsys_dev->dev, "%s:  cq_reg", __func__);
+		for (i = 0; i < PQDIP_CQ_REG_CNT; i += 0x10) {
+			dev_info(imgsys_dev->dev, "%s:  [0x%08x] 0x%08x 0x%08x 0x%08x 0x%08x",
+			__func__, (unsigned int)(PQDIP_BASE_ADDR + (PQDIP_OFST * hw_idx)
+				+ PQDIP_CQ_OFST + i),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_CQ_OFST + i + 0x00)),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_CQ_OFST + i + 0x04)),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_CQ_OFST + i + 0x08)),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_CQ_OFST + i + 0x0c)));
+		}
+
+		dev_info(imgsys_dev->dev, "%s:  dma_reg", __func__);
+		for (i = 0; i < PQDIP_DMA_REG_CNT; i += 0x10) {
+			dev_info(imgsys_dev->dev, "%s:  [0x%08x] 0x%08x 0x%08x 0x%08x 0x%08x",
+			__func__, (unsigned int)(PQDIP_BASE_ADDR + (PQDIP_OFST * hw_idx)
+				+ PQDIP_DMA_OFST + i),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_DMA_OFST + i + 0x00)),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_DMA_OFST + i + 0x04)),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_DMA_OFST + i + 0x08)),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_DMA_OFST + i + 0x0c)));
+		}
+
+		dev_info(imgsys_dev->dev, "%s:  wrot_reg", __func__);
+		for (i = 0; i < PQDIP_WROT1_REG_CNT; i += 0x10) {
+			dev_info(imgsys_dev->dev, "%s:  [0x%08x] 0x%08x 0x%08x 0x%08x 0x%08x",
+			__func__, (unsigned int)(PQDIP_BASE_ADDR + (PQDIP_OFST * hw_idx)
+				+ PQDIP_WROT1_OFST + i),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_WROT1_OFST + i + 0x00)),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_WROT1_OFST + i + 0x04)),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_WROT1_OFST + i + 0x08)),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_WROT1_OFST + i + 0x0c)));
+		}
+		for (i = 0; i < PQDIP_WROT2_REG_CNT; i += 0x10) {
+			dev_info(imgsys_dev->dev, "%s:  [0x%08x] 0x%08x 0x%08x 0x%08x 0x%08x",
+			__func__, (unsigned int)(PQDIP_BASE_ADDR + (PQDIP_OFST * hw_idx)
+				+ PQDIP_WROT2_OFST + i),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_WROT2_OFST + i + 0x00)),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_WROT2_OFST + i + 0x04)),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_WROT2_OFST + i + 0x08)),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_WROT2_OFST + i + 0x0c)));
+		}
+
+		dev_info(imgsys_dev->dev, "%s:  urz6t_reg", __func__);
+		for (i = 0; i < PQDIP_URZ6T_REG_CNT; i += 0x10) {
+			dev_info(imgsys_dev->dev, "%s:  [0x%08x] 0x%08x 0x%08x 0x%08x 0x%08x",
+			__func__, (unsigned int)(PQDIP_BASE_ADDR + (PQDIP_OFST * hw_idx)
+				+ PQDIP_URZ6T_OFST + i),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_URZ6T_OFST + i + 0x00)),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_URZ6T_OFST + i + 0x04)),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_URZ6T_OFST + i + 0x08)),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_URZ6T_OFST + i + 0x0c)));
+		}
+
+		dev_info(imgsys_dev->dev, "%s:  tdshp_reg", __func__);
+		for (i = 0; i < PQDIP_TDSHP1REG_CNT; i += 0x10) {
+			dev_info(imgsys_dev->dev, "%s:  [0x%08x] 0x%08x 0x%08x 0x%08x 0x%08x",
+			__func__, (unsigned int)(PQDIP_BASE_ADDR + (PQDIP_OFST * hw_idx)
+				+ PQDIP_TDSHP1OFST + i),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_TDSHP1OFST + i + 0x00)),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_TDSHP1OFST + i + 0x04)),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_TDSHP1OFST + i + 0x08)),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_TDSHP1OFST + i + 0x0c)));
+		}
+		for (i = 0; i < PQDIP_TDSHP2REG_CNT; i += 0x10) {
+			dev_info(imgsys_dev->dev, "%s:  [0x%08x] 0x%08x 0x%08x 0x%08x 0x%08x",
+			__func__, (unsigned int)(PQDIP_BASE_ADDR + (PQDIP_OFST * hw_idx)
+				+ PQDIP_TDSHP2OFST + i),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_TDSHP2OFST + i + 0x00)),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_TDSHP2OFST + i + 0x04)),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_TDSHP2OFST + i + 0x08)),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_TDSHP2OFST + i + 0x0c)));
+		}
+		for (i = 0; i < PQDIP_TDSHP3REG_CNT; i += 0x10) {
+			dev_info(imgsys_dev->dev, "%s:  [0x%08x] 0x%08x 0x%08x 0x%08x 0x%08x",
+			__func__, (unsigned int)(PQDIP_BASE_ADDR + (PQDIP_OFST * hw_idx)
+				+ PQDIP_TDSHP3OFST + i),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_TDSHP3OFST + i + 0x00)),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_TDSHP3OFST + i + 0x04)),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_TDSHP3OFST + i + 0x08)),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_TDSHP3OFST + i + 0x0c)));
+		}
+
+		dev_info(imgsys_dev->dev, "%s:  unp_reg", __func__);
+		for (i = 0; i < PQDIP_UNP_REG_CNT; i += 0x10) {
+			dev_info(imgsys_dev->dev, "%s:  [0x%08x] 0x%08x 0x%08x 0x%08x 0x%08x",
+			__func__, (unsigned int)(PQDIP_BASE_ADDR + (PQDIP_OFST * hw_idx)
+				+ PQDIP_UNP1_OFST + i),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_UNP1_OFST + i + 0x00)),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_UNP1_OFST + i + 0x04)),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_UNP1_OFST + i + 0x08)),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_UNP1_OFST + i + 0x0c)));
+		}
+		for (i = 0; i < PQDIP_UNP_REG_CNT; i += 0x10) {
+			dev_info(imgsys_dev->dev, "%s:  [0x%08x] 0x%08x 0x%08x 0x%08x 0x%08x",
+			__func__, (unsigned int)(PQDIP_BASE_ADDR + (PQDIP_OFST * hw_idx)
+				+ PQDIP_UNP2_OFST + i),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_UNP2_OFST + i + 0x00)),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_UNP2_OFST + i + 0x04)),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_UNP2_OFST + i + 0x08)),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_UNP2_OFST + i + 0x0c)));
+		}
+		for (i = 0; i < PQDIP_UNP_REG_CNT; i += 0x10) {
+			dev_info(imgsys_dev->dev, "%s:  [0x%08x] 0x%08x 0x%08x 0x%08x 0x%08x",
+			__func__, (unsigned int)(PQDIP_BASE_ADDR + (PQDIP_OFST * hw_idx)
+				+ PQDIP_UNP3_OFST + i),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_UNP3_OFST + i + 0x00)),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_UNP3_OFST + i + 0x04)),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_UNP3_OFST + i + 0x08)),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_UNP3_OFST + i + 0x0c)));
+		}
+
+		dev_info(imgsys_dev->dev, "%s:  c02_reg", __func__);
+		for (i = 0; i < PQDIP_C02_REG_CNT; i += 0x10) {
+			dev_info(imgsys_dev->dev, "%s:  [0x%08x] 0x%08x 0x%08x 0x%08x 0x%08x",
+			__func__, (unsigned int)(PQDIP_BASE_ADDR + (PQDIP_OFST * hw_idx)
+				+ PQDIP_C02_OFST + i),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_C02_OFST + i + 0x00)),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_C02_OFST + i + 0x04)),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_C02_OFST + i + 0x08)),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_C02_OFST + i + 0x0c)));
+		}
+
+		dev_info(imgsys_dev->dev, "%s:  c24_reg", __func__);
+		for (i = 0; i < PQDIP_C24_REG_CNT; i += 0x10) {
+			dev_info(imgsys_dev->dev, "%s:  [0x%08x] 0x%08x 0x%08x 0x%08x 0x%08x",
+			__func__, (unsigned int)(PQDIP_BASE_ADDR + (PQDIP_OFST * hw_idx)
+				+ PQDIP_C24_OFST + i),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_C24_OFST + i + 0x00)),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_C24_OFST + i + 0x04)),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_C24_OFST + i + 0x08)),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_C24_OFST + i + 0x0c)));
+		}
+
+		dev_info(imgsys_dev->dev, "%s:  drz8t_reg", __func__);
+		for (i = 0; i < PQDIP_DRZ8T_REG_CNT; i += 0x10) {
+			dev_info(imgsys_dev->dev, "%s:  [0x%08x] 0x%08x 0x%08x 0x%08x 0x%08x",
+			__func__, (unsigned int)(PQDIP_BASE_ADDR + (PQDIP_OFST * hw_idx)
+				+ PQDIP_DRZ8T_OFST + i),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_DRZ8T_OFST + i + 0x00)),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_DRZ8T_OFST + i + 0x04)),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_DRZ8T_OFST + i + 0x08)),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_DRZ8T_OFST + i + 0x0c)));
+		}
+
+		dev_info(imgsys_dev->dev, "%s:  drz1n_reg", __func__);
+		for (i = 0; i < PQDIP_DRZ1N_REG_CNT; i += 0x10) {
+			dev_info(imgsys_dev->dev, "%s:  [0x%08x] 0x%08x 0x%08x 0x%08x 0x%08x",
+			__func__, (unsigned int)(PQDIP_BASE_ADDR + (PQDIP_OFST * hw_idx)
+				+ PQDIP_DRZ1N_OFST + i),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_DRZ1N_OFST + i + 0x00)),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_DRZ1N_OFST + i + 0x04)),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_DRZ1N_OFST + i + 0x08)),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_DRZ1N_OFST + i + 0x0c)));
+		}
+
+		dev_info(imgsys_dev->dev, "%s:  mcrp_reg", __func__);
+		for (i = 0; i < PQDIP_MCRP_REG_CNT; i += 0x10) {
+			dev_info(imgsys_dev->dev, "%s:  [0x%08x] 0x%08x 0x%08x 0x%08x 0x%08x",
+			__func__, (unsigned int)(PQDIP_BASE_ADDR + (PQDIP_OFST * hw_idx)
+				+ PQDIP_MCRP_OFST + i),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_MCRP_OFST + i + 0x00)),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_MCRP_OFST + i + 0x04)),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_MCRP_OFST + i + 0x08)),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_MCRP_OFST + i + 0x0c)));
+		}
+
+		dev_info(imgsys_dev->dev, "%s:  tcc_reg", __func__);
+		for (i = 0; i < PQDIP_TCC_REG_CNT; i += 0x10) {
+			dev_info(imgsys_dev->dev, "%s:  [0x%08x] 0x%08x 0x%08x 0x%08x 0x%08x",
+			__func__, (unsigned int)(PQDIP_BASE_ADDR + (PQDIP_OFST * hw_idx)
+				+ PQDIP_TCC_OFST + i),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_TCC_OFST + i + 0x00)),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_TCC_OFST + i + 0x04)),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_TCC_OFST + i + 0x08)),
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQDIP_TCC_OFST + i + 0x0c)));
+		}
+#endif
+		//CTL_DBG
+		dev_info(imgsys_dev->dev, "%s: tdr debug\n", __func__);
+		iowrite32(0x80004, (void *)(pqdipRegBA + PQDIPCTL_DBG_SEL_OFST));
+		dev_info(imgsys_dev->dev, "%s: tdr   sel(0x80004): %08X", __func__,
+		(unsigned int)ioread32((void *)(pqdipRegBA + PQDIPCTL_DBG_OUT_OFST)));
+
+		dev_info(imgsys_dev->dev, "%s: module debug\n", __func__);
+		iowrite32(0x00001, (void *)(pqdipRegBA + PQDIPCTL_DBG_SEL_OFST));
+		dev_info(imgsys_dev->dev, "%s: urz6t sel(0x00001): %08X", __func__,
+		(unsigned int)ioread32((void *)(pqdipRegBA + PQDIPCTL_DBG_OUT_OFST)));
+		iowrite32(0x00101, (void *)(pqdipRegBA + PQDIPCTL_DBG_SEL_OFST));
+		dev_info(imgsys_dev->dev, "%s: tdshp sel(0x00101): %08X", __func__,
+		(unsigned int)ioread32((void *)(pqdipRegBA + PQDIPCTL_DBG_OUT_OFST)));
+		iowrite32(0x10201, (void *)(pqdipRegBA + PQDIPCTL_DBG_SEL_OFST));
+		dev_info(imgsys_dev->dev, "%s: tcc   sel(0x10201): %08X", __func__,
+		(unsigned int)ioread32((void *)(pqdipRegBA + PQDIPCTL_DBG_OUT_OFST)));
+		iowrite32(0x20201, (void *)(pqdipRegBA + PQDIPCTL_DBG_SEL_OFST));
+		dev_info(imgsys_dev->dev, "%s: tcc   sel(0x20201): %08X", __func__,
+		(unsigned int)ioread32((void *)(pqdipRegBA + PQDIPCTL_DBG_OUT_OFST)));
+		iowrite32(0x30201, (void *)(pqdipRegBA + PQDIPCTL_DBG_SEL_OFST));
+		dev_info(imgsys_dev->dev, "%s: tcc   sel(0x30201): %08X", __func__,
+		(unsigned int)ioread32((void *)(pqdipRegBA + PQDIPCTL_DBG_OUT_OFST)));
+		iowrite32(0x40201, (void *)(pqdipRegBA + PQDIPCTL_DBG_SEL_OFST));
+		dev_info(imgsys_dev->dev, "%s: tcc   sel(0x40201): %08X", __func__,
+		(unsigned int)ioread32((void *)(pqdipRegBA + PQDIPCTL_DBG_OUT_OFST)));
+		iowrite32(0x00301, (void *)(pqdipRegBA + PQDIPCTL_DBG_SEL_OFST));
+		dev_info(imgsys_dev->dev, "%s: wrot  sel(0x00301): %08X", __func__,
+		(unsigned int)ioread32((void *)(pqdipRegBA + PQDIPCTL_DBG_OUT_OFST)));
+		iowrite32(0x10401, (void *)(pqdipRegBA + PQDIPCTL_DBG_SEL_OFST));
+		dev_info(imgsys_dev->dev, "%s: unp1  sel(0x10401): %08X", __func__,
+		(unsigned int)ioread32((void *)(pqdipRegBA + PQDIPCTL_DBG_OUT_OFST)));
+		iowrite32(0x20401, (void *)(pqdipRegBA + PQDIPCTL_DBG_SEL_OFST));
+		dev_info(imgsys_dev->dev, "%s: unp1  sel(0x20401): %08X", __func__,
+		(unsigned int)ioread32((void *)(pqdipRegBA + PQDIPCTL_DBG_OUT_OFST)));
+		iowrite32(0x30401, (void *)(pqdipRegBA + PQDIPCTL_DBG_SEL_OFST));
+		dev_info(imgsys_dev->dev, "%s: unp1  sel(0x30401): %08X", __func__,
+		(unsigned int)ioread32((void *)(pqdipRegBA + PQDIPCTL_DBG_OUT_OFST)));
+		iowrite32(0x40401, (void *)(pqdipRegBA + PQDIPCTL_DBG_SEL_OFST));
+		dev_info(imgsys_dev->dev, "%s: unp1  sel(0x40401): %08X", __func__,
+		(unsigned int)ioread32((void *)(pqdipRegBA + PQDIPCTL_DBG_OUT_OFST)));
+		iowrite32(0x50401, (void *)(pqdipRegBA + PQDIPCTL_DBG_SEL_OFST));
+		dev_info(imgsys_dev->dev, "%s: unp1  sel(0x50401): %08X", __func__,
+		(unsigned int)ioread32((void *)(pqdipRegBA + PQDIPCTL_DBG_OUT_OFST)));
+		iowrite32(0x60401, (void *)(pqdipRegBA + PQDIPCTL_DBG_SEL_OFST));
+		dev_info(imgsys_dev->dev, "%s: unp1  sel(0x60401): %08X", __func__,
+		(unsigned int)ioread32((void *)(pqdipRegBA + PQDIPCTL_DBG_OUT_OFST)));
+		iowrite32(0x10501, (void *)(pqdipRegBA + PQDIPCTL_DBG_SEL_OFST));
+		dev_info(imgsys_dev->dev, "%s: unp2  sel(0x10501): %08X", __func__,
+		(unsigned int)ioread32((void *)(pqdipRegBA + PQDIPCTL_DBG_OUT_OFST)));
+		iowrite32(0x20501, (void *)(pqdipRegBA + PQDIPCTL_DBG_SEL_OFST));
+		dev_info(imgsys_dev->dev, "%s: unp2  sel(0x20501): %08X", __func__,
+		(unsigned int)ioread32((void *)(pqdipRegBA + PQDIPCTL_DBG_OUT_OFST)));
+		iowrite32(0x30501, (void *)(pqdipRegBA + PQDIPCTL_DBG_SEL_OFST));
+		dev_info(imgsys_dev->dev, "%s: unp2  sel(0x30501): %08X", __func__,
+		(unsigned int)ioread32((void *)(pqdipRegBA + PQDIPCTL_DBG_OUT_OFST)));
+		iowrite32(0x40501, (void *)(pqdipRegBA + PQDIPCTL_DBG_SEL_OFST));
+		dev_info(imgsys_dev->dev, "%s: unp2  sel(0x40501): %08X", __func__,
+		(unsigned int)ioread32((void *)(pqdipRegBA + PQDIPCTL_DBG_OUT_OFST)));
+		iowrite32(0x50501, (void *)(pqdipRegBA + PQDIPCTL_DBG_SEL_OFST));
+		dev_info(imgsys_dev->dev, "%s: unp2  sel(0x50501): %08X", __func__,
+		(unsigned int)ioread32((void *)(pqdipRegBA + PQDIPCTL_DBG_OUT_OFST)));
+		iowrite32(0x60501, (void *)(pqdipRegBA + PQDIPCTL_DBG_SEL_OFST));
+		dev_info(imgsys_dev->dev, "%s: unp2  sel(0x60501): %08X", __func__,
+		(unsigned int)ioread32((void *)(pqdipRegBA + PQDIPCTL_DBG_OUT_OFST)));
+		iowrite32(0x10601, (void *)(pqdipRegBA + PQDIPCTL_DBG_SEL_OFST));
+		dev_info(imgsys_dev->dev, "%s: unp3  sel(0x10601): %08X", __func__,
+		(unsigned int)ioread32((void *)(pqdipRegBA + PQDIPCTL_DBG_OUT_OFST)));
+		iowrite32(0x20601, (void *)(pqdipRegBA + PQDIPCTL_DBG_SEL_OFST));
+		dev_info(imgsys_dev->dev, "%s: unp3  sel(0x20601): %08X", __func__,
+		(unsigned int)ioread32((void *)(pqdipRegBA + PQDIPCTL_DBG_OUT_OFST)));
+		iowrite32(0x30601, (void *)(pqdipRegBA + PQDIPCTL_DBG_SEL_OFST));
+		dev_info(imgsys_dev->dev, "%s: unp3  sel(0x30601): %08X", __func__,
+		(unsigned int)ioread32((void *)(pqdipRegBA + PQDIPCTL_DBG_OUT_OFST)));
+		iowrite32(0x40601, (void *)(pqdipRegBA + PQDIPCTL_DBG_SEL_OFST));
+		dev_info(imgsys_dev->dev, "%s: unp3  sel(0x40601): %08X", __func__,
+		(unsigned int)ioread32((void *)(pqdipRegBA + PQDIPCTL_DBG_OUT_OFST)));
+		iowrite32(0x50601, (void *)(pqdipRegBA + PQDIPCTL_DBG_SEL_OFST));
+		dev_info(imgsys_dev->dev, "%s: unp3  sel(0x50601): %08X", __func__,
+		(unsigned int)ioread32((void *)(pqdipRegBA + PQDIPCTL_DBG_OUT_OFST)));
+		iowrite32(0x60601, (void *)(pqdipRegBA + PQDIPCTL_DBG_SEL_OFST));
+		dev_info(imgsys_dev->dev, "%s: unp3  sel(0x60601): %08X", __func__,
+		(unsigned int)ioread32((void *)(pqdipRegBA + PQDIPCTL_DBG_OUT_OFST)));
+		iowrite32(0x00701, (void *)(pqdipRegBA + PQDIPCTL_DBG_SEL_OFST));
+		dev_info(imgsys_dev->dev, "%s: plnr  sel(0x00701): %08X", __func__,
+		(unsigned int)ioread32((void *)(pqdipRegBA + PQDIPCTL_DBG_OUT_OFST)));
+		iowrite32(0x00801, (void *)(pqdipRegBA + PQDIPCTL_DBG_SEL_OFST));
+		dev_info(imgsys_dev->dev, "%s: c02   sel(0x00801): %08X", __func__,
+		(unsigned int)ioread32((void *)(pqdipRegBA + PQDIPCTL_DBG_OUT_OFST)));
+		iowrite32(0x10801, (void *)(pqdipRegBA + PQDIPCTL_DBG_SEL_OFST));
+		dev_info(imgsys_dev->dev, "%s: c02   sel(0x10801): %08X", __func__,
+		(unsigned int)ioread32((void *)(pqdipRegBA + PQDIPCTL_DBG_OUT_OFST)));
+		iowrite32(0x20801, (void *)(pqdipRegBA + PQDIPCTL_DBG_SEL_OFST));
+		dev_info(imgsys_dev->dev, "%s: c02   sel(0x20801): %08X", __func__,
+		(unsigned int)ioread32((void *)(pqdipRegBA + PQDIPCTL_DBG_OUT_OFST)));
+		iowrite32(0x30801, (void *)(pqdipRegBA + PQDIPCTL_DBG_SEL_OFST));
+		dev_info(imgsys_dev->dev, "%s: c02   sel(0x30801): %08X", __func__,
+		(unsigned int)ioread32((void *)(pqdipRegBA + PQDIPCTL_DBG_OUT_OFST)));
+		iowrite32(0x10901, (void *)(pqdipRegBA + PQDIPCTL_DBG_SEL_OFST));
+		dev_info(imgsys_dev->dev, "%s: c24   sel(0x10901): %08X", __func__,
+		(unsigned int)ioread32((void *)(pqdipRegBA + PQDIPCTL_DBG_OUT_OFST)));
+		iowrite32(0x10a01, (void *)(pqdipRegBA + PQDIPCTL_DBG_SEL_OFST));
+		dev_info(imgsys_dev->dev, "%s: mcrp  sel(0x10a01): %08X", __func__,
+		(unsigned int)ioread32((void *)(pqdipRegBA + PQDIPCTL_DBG_OUT_OFST)));
+		iowrite32(0x20a01, (void *)(pqdipRegBA + PQDIPCTL_DBG_SEL_OFST));
+		dev_info(imgsys_dev->dev, "%s: mcrp  sel(0x20a01): %08X", __func__,
+		(unsigned int)ioread32((void *)(pqdipRegBA + PQDIPCTL_DBG_OUT_OFST)));
+		iowrite32(0x30a01, (void *)(pqdipRegBA + PQDIPCTL_DBG_SEL_OFST));
+		dev_info(imgsys_dev->dev, "%s: mcrp  sel(0x30a01): %08X", __func__,
+		(unsigned int)ioread32((void *)(pqdipRegBA + PQDIPCTL_DBG_OUT_OFST)));
+		iowrite32(0x40a01, (void *)(pqdipRegBA + PQDIPCTL_DBG_SEL_OFST));
+		dev_info(imgsys_dev->dev, "%s: mcrp  sel(0x40a01): %08X", __func__,
+		(unsigned int)ioread32((void *)(pqdipRegBA + PQDIPCTL_DBG_OUT_OFST)));
+		iowrite32(0x50a01, (void *)(pqdipRegBA + PQDIPCTL_DBG_SEL_OFST));
+		dev_info(imgsys_dev->dev, "%s: mcrp  sel(0x50a01): %08X", __func__,
+		(unsigned int)ioread32((void *)(pqdipRegBA + PQDIPCTL_DBG_OUT_OFST)));
+		iowrite32(0x00b01, (void *)(pqdipRegBA + PQDIPCTL_DBG_SEL_OFST));
+		dev_info(imgsys_dev->dev, "%s: r2b   sel(0x00b01): %08X", __func__,
+		(unsigned int)ioread32((void *)(pqdipRegBA + PQDIPCTL_DBG_OUT_OFST)));
+		iowrite32(0x10b01, (void *)(pqdipRegBA + PQDIPCTL_DBG_SEL_OFST));
+		dev_info(imgsys_dev->dev, "%s: r2b   sel(0x10b01): %08X", __func__,
+		(unsigned int)ioread32((void *)(pqdipRegBA + PQDIPCTL_DBG_OUT_OFST)));
+		iowrite32(0x20b01, (void *)(pqdipRegBA + PQDIPCTL_DBG_SEL_OFST));
+		dev_info(imgsys_dev->dev, "%s: r2b   sel(0x20b01): %08X", __func__,
+		(unsigned int)ioread32((void *)(pqdipRegBA + PQDIPCTL_DBG_OUT_OFST)));
+		iowrite32(0x30b01, (void *)(pqdipRegBA + PQDIPCTL_DBG_SEL_OFST));
+		dev_info(imgsys_dev->dev, "%s: r2b   sel(0x30b01): %08X", __func__,
+		(unsigned int)ioread32((void *)(pqdipRegBA + PQDIPCTL_DBG_OUT_OFST)));
+		iowrite32(0x40b01, (void *)(pqdipRegBA + PQDIPCTL_DBG_SEL_OFST));
+		dev_info(imgsys_dev->dev, "%s: r2b   sel(0x40b01): %08X", __func__,
+		(unsigned int)ioread32((void *)(pqdipRegBA + PQDIPCTL_DBG_OUT_OFST)));
+		iowrite32(0x50b01, (void *)(pqdipRegBA + PQDIPCTL_DBG_SEL_OFST));
+		dev_info(imgsys_dev->dev, "%s: r2b   sel(0x50b01): %08X", __func__,
+		(unsigned int)ioread32((void *)(pqdipRegBA + PQDIPCTL_DBG_OUT_OFST)));
+		iowrite32(0x60b01, (void *)(pqdipRegBA + PQDIPCTL_DBG_SEL_OFST));
+		dev_info(imgsys_dev->dev, "%s: r2b   sel(0x60b01): %08X", __func__,
+		(unsigned int)ioread32((void *)(pqdipRegBA + PQDIPCTL_DBG_OUT_OFST)));
+		iowrite32(0x70b01, (void *)(pqdipRegBA + PQDIPCTL_DBG_SEL_OFST));
+		dev_info(imgsys_dev->dev, "%s: r2b   sel(0x70b01): %08X", __func__,
+		(unsigned int)ioread32((void *)(pqdipRegBA + PQDIPCTL_DBG_OUT_OFST)));
+		iowrite32(0x80b01, (void *)(pqdipRegBA + PQDIPCTL_DBG_SEL_OFST));
+		dev_info(imgsys_dev->dev, "%s: r2b   sel(0x80b01): %08X", __func__,
+		(unsigned int)ioread32((void *)(pqdipRegBA + PQDIPCTL_DBG_OUT_OFST)));
+		iowrite32(0x90b01, (void *)(pqdipRegBA + PQDIPCTL_DBG_SEL_OFST));
+		dev_info(imgsys_dev->dev, "%s: r2b   sel(0x90b01): %08X", __func__,
+		(unsigned int)ioread32((void *)(pqdipRegBA + PQDIPCTL_DBG_OUT_OFST)));
+		iowrite32(0xa0b01, (void *)(pqdipRegBA + PQDIPCTL_DBG_SEL_OFST));
+		dev_info(imgsys_dev->dev, "%s: r2b   sel(0xa0b01): %08X", __func__,
+		(unsigned int)ioread32((void *)(pqdipRegBA + PQDIPCTL_DBG_OUT_OFST)));
+		iowrite32(0xb0b01, (void *)(pqdipRegBA + PQDIPCTL_DBG_SEL_OFST));
+		dev_info(imgsys_dev->dev, "%s: r2b   sel(0xb0b01): %08X", __func__,
+		(unsigned int)ioread32((void *)(pqdipRegBA + PQDIPCTL_DBG_OUT_OFST)));
+		iowrite32(0x00106, (void *)(pqdipRegBA + PQDIPCTL_DBG_SEL_OFST));
+		dev_info(imgsys_dev->dev, "%s: wif   sel(0x00106): %08X", __func__,
+		(unsigned int)ioread32((void *)(pqdipRegBA + PQDIPCTL_DBG_OUT_OFST)));
+		iowrite32(0x00107, (void *)(pqdipRegBA + PQDIPCTL_DBG_SEL_OFST));
+		dev_info(imgsys_dev->dev, "%s: wif   sel(0x00107): %08X", __func__,
+		(unsigned int)ioread32((void *)(pqdipRegBA + PQDIPCTL_DBG_OUT_OFST)));
+		iowrite32(0x00108, (void *)(pqdipRegBA + PQDIPCTL_DBG_SEL_OFST));
+		dev_info(imgsys_dev->dev, "%s: wif   sel(0x00108): %08X", __func__,
+		(unsigned int)ioread32((void *)(pqdipRegBA + PQDIPCTL_DBG_OUT_OFST)));
+
+		//WROT_DBG
+		dev_info(imgsys_dev->dev, "%s: wrot debug\n", __func__);
+		for (i = 1; i <= 32; i += 1) {
+			iowrite32(i << 8, (void *)(pqdipRegBA + PQ_WROT_DBG_SEL_OFST));
+			dev_info(imgsys_dev->dev, "%s: sel(0x%04x): %08X", __func__, i << 8,
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQ_WROT_DBG_OUT_OFST)));
+		}
+
+		//URZ6T_DBG
+		dev_info(imgsys_dev->dev, "%s: urz6t debug\n", __func__);
+		for (i = 0; i < 16; i += 1) {
+			iowrite32(i, (void *)(pqdipRegBA + PQ_URZ6T_DBG_SEL_OFST));
+			dev_info(imgsys_dev->dev, "%s: sel(0x%02x): %08X", __func__, i,
+			(unsigned int)ioread32((void *)(pqdipRegBA + PQ_URZ6T_DBG_OUT_OFST)));
+		}
+	}
+	dev_info(imgsys_dev->dev, "%s: -\n", __func__);
+}
+EXPORT_SYMBOL(imgsys_pqdip_debug_dump);
+
+void imgsys_pqdip_uninit(struct mtk_imgsys_dev *imgsys_dev)
+{
+	unsigned int i;
+
+	pr_debug("%s: +\n", __func__);
+	for (i = 0; i < PQDIP_HW_SET; i++) {
+		iounmap(gpqdipRegBA[i]);
+		gpqdipRegBA[i] = 0L;
+	}
+	pr_debug("%s: -\n", __func__);
+}
+EXPORT_SYMBOL(imgsys_pqdip_uninit);
+
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_71/modules/mtk_imgsys-pqdip.h b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_71/modules/mtk_imgsys-pqdip.h
new file mode 100644
index 0000000000000000000000000000000000000000..b82bf54410ef6938de4ada5ad0c2f892c97764b9
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_71/modules/mtk_imgsys-pqdip.h
@@ -0,0 +1,46 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2020 MediaTek Inc.
+ *
+ * Author: Daniel Huang <daniel.huang@mediatek.com>
+ *
+ */
+
+#ifndef _MTK_IMGSYS_PQDIP_H_
+#define _MTK_IMGSYS_PQDIP_H_
+
+// Standard C header file
+
+// kernel header file
+
+// mtk imgsys local header file
+#include <mtk_imgsys-dev.h>
+#include <mtk_imgsys-cmdq.h>
+
+// Local header file
+#include "mtk_imgsys-engine.h"
+
+/********************************************************************
+ * Global Define
+ ********************************************************************/
+
+/********************************************************************
+ * Enum Define
+ ********************************************************************/
+
+
+/********************************************************************
+ * Structure Define
+ ********************************************************************/
+
+//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+// Public Functions
+//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+void imgsys_pqdip_set_initial_value(struct mtk_imgsys_dev *imgsys_dev);
+void imgsys_pqdip_set_hw_initial_value(struct mtk_imgsys_dev *imgsys_dev);
+void imgsys_pqdip_debug_dump(struct mtk_imgsys_dev *imgsys_dev,
+							unsigned int engine);
+void imgsys_pqdip_uninit(struct mtk_imgsys_dev *imgsys_dev);
+
+
+#endif /* _MTK_IMGSYS_PQDIP_H_ */
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_71/modules/mtk_imgsys-traw.c b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_71/modules/mtk_imgsys-traw.c
new file mode 100644
index 0000000000000000000000000000000000000000..bf8be27997665a6b2f40f02bb7dfc68957109683
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_71/modules/mtk_imgsys-traw.c
@@ -0,0 +1,932 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2020 MediaTek Inc.
+ *
+ * Author: Shih-Fang Chuang <shih-fang.chuang@mediatek.com>
+ *
+ */
+
+ // Standard C header file
+
+// kernel header file
+#include <linux/device.h>
+#include <linux/of_address.h>
+#include <dma-iommu.h>
+#include <linux/pm_runtime.h>
+#include <linux/remoteproc.h>
+#include <dt-bindings/memory/mtk-memory-port.h>
+
+// drivers/misc/mediatek/iommu/
+//#include "iommu_debug.h"
+
+
+// mtk imgsys local header file
+
+// Local header file
+#include "mtk_imgsys-traw.h"
+
+/********************************************************************
+ * Global Define
+ ********************************************************************/
+#define TRAW_INIT_ARRAY_COUNT	1
+
+#define TRAW_CTL_ADDR_OFST		0x330
+#define TRAW_DMA_ADDR_OFST		0x4000
+#define TRAW_DMA_ADDR_END		0x5300
+#define TRAW_DATA_ADDR_OFST		0x8000
+#define TRAW_MAX_ADDR_OFST		0xBD00
+
+
+#define TRAW_HW_SET		3
+#define WPE_HW_SET		3
+
+#define TRAW_L9_PORT_CNT	25
+#define TRAW_L11_PORT_CNT	16
+
+#define TRAW_M4U   0
+
+/********************************************************************
+ * Global Variable
+ ********************************************************************/
+const struct mtk_imgsys_init_array
+			mtk_imgsys_traw_init_ary[TRAW_INIT_ARRAY_COUNT] = {
+	{0x00A0, 0x80000000}, /* TRAWCTL_INT1_EN */
+};
+
+static struct TRAWDmaDebugInfo g_DMADbgIfo[] = {
+	{"IMGI", TRAW_ORI_RDMA_DEBUG},
+	{"IMGI_UFD", TRAW_ORI_RDMA_UFD_DEBUG},
+	{"UFDI", TRAW_ORI_RDMA_DEBUG},
+	{"IMGBI", TRAW_ORI_RDMA_DEBUG},
+	{"IMGBI_UFD", TRAW_ORI_RDMA_UFD_DEBUG},
+	{"IMGCI", TRAW_ORI_RDMA_DEBUG},
+	{"IMGCI_UFD", TRAW_ORI_RDMA_UFD_DEBUG},
+	{"SMTI_T1", TRAW_ULC_RDMA_DEBUG},
+	{"SMTI_T2", TRAW_ULC_RDMA_DEBUG},
+	{"SMTI_T3", TRAW_ULC_RDMA_DEBUG},
+	{"SMTI_T4", TRAW_ULC_RDMA_DEBUG},
+	{"SMTI_T5", TRAW_ULC_RDMA_DEBUG},
+	{"CACI", TRAW_ULC_RDMA_DEBUG},
+	{"TNCSTI_T1", TRAW_ULC_RDMA_DEBUG},
+	{"TNCSTI_T2", TRAW_ULC_RDMA_DEBUG},
+	{"TNCSTI_T3", TRAW_ULC_RDMA_DEBUG},
+	{"TNCSTI_T4", TRAW_ULC_RDMA_DEBUG},
+	{"TNCSTI_T5", TRAW_ULC_RDMA_DEBUG},
+	{"YUVO_T1", TRAW_ORI_WDMA_DEBUG},
+	{"YUVBO_T1", TRAW_ORI_WDMA_DEBUG},
+	{"TIMGO", TRAW_ORI_WDMA_DEBUG},
+	{"YUVCO", TRAW_ORI_WDMA_DEBUG},
+	{"YUVDO", TRAW_ORI_WDMA_DEBUG},
+	{"YUVO_T2", TRAW_ULC_WDMA_DEBUG},
+	{"YUVBO_T2", TRAW_ULC_WDMA_DEBUG},
+	{"YUVO_T3", TRAW_ULC_WDMA_DEBUG},
+	{"YUVBO_T3", TRAW_ULC_WDMA_DEBUG},
+	{"YUVO_T4", TRAW_ULC_WDMA_DEBUG},
+	{"YUVBO_T4", TRAW_ULC_WDMA_DEBUG},
+	{"YUVO_T5", TRAW_ORI_WDMA_DEBUG},
+	{"TNCSO", TRAW_ULC_WDMA_DEBUG},
+	{"TNCSBO", TRAW_ULC_WDMA_DEBUG},
+	{"TNCSHO", TRAW_ULC_WDMA_DEBUG},
+	{"TNCSYO", TRAW_ULC_WDMA_DEBUG},
+	{"SMTO_T1", TRAW_ULC_WDMA_DEBUG},
+	{"SMTO_T2", TRAW_ULC_WDMA_DEBUG},
+	{"SMTO_T3", TRAW_ULC_WDMA_DEBUG},
+	{"SMTO_T4", TRAW_ULC_WDMA_DEBUG},
+	{"SMTO_T5", TRAW_ULC_WDMA_DEBUG},
+	{"TNCSTO_T1", TRAW_ULC_WDMA_DEBUG},
+	{"TNCSTO_T2", TRAW_ULC_WDMA_DEBUG},
+	{"TNCSTO_T3", TRAW_ULC_WDMA_DEBUG},
+	{"SMTCI_T1", TRAW_ULC_RDMA_DEBUG},
+	{"SMTCI_T4", TRAW_ULC_RDMA_DEBUG},
+	{"SMTCO_T1", TRAW_ULC_WDMA_DEBUG},
+	{"SMTCO_T4", TRAW_ULC_WDMA_DEBUG},
+	{"SMTI_T6", TRAW_ULC_RDMA_DEBUG},
+	{"SMTI_T7", TRAW_ULC_RDMA_DEBUG},
+	{"SMTO_T6", TRAW_ULC_WDMA_DEBUG},
+	{"SMTO_T7", TRAW_ULC_WDMA_DEBUG},
+	{"RZH1N2TO_T1", TRAW_ULC_WDMA_DEBUG},
+	{"RZH1N2TBO_T1", TRAW_ULC_WDMA_DEBUG},
+	{"DRZS4NO_T1", TRAW_ULC_WDMA_DEBUG},
+	{"DBGO_T1", TRAW_ORI_WDMA_DEBUG},
+	{"DBGBO_T1", TRAW_ORI_WDMA_DEBUG},
+};
+
+static unsigned int g_RegBaseAddr = TRAW_A_BASE_ADDR;
+
+static void __iomem *g_trawRegBA, *g_ltrawRegBA, *g_xtrawRegBA;
+
+#if TRAW_M4U
+static unsigned int g_IOMMUDumpPort;
+
+static unsigned int g_IOMMUL9Def[TRAW_L9_PORT_CNT] = {
+	MTK_M4U_PORT_ID(0, 0, 9, 0),	/* IMGI_T1_A */
+	MTK_M4U_PORT_ID(0, 0, 9, 1),	/* UFDI_T1_A */
+	MTK_M4U_PORT_ID(0, 0, 9, 2),	/* IMGBI_T1_A */
+	MTK_M4U_PORT_ID(0, 0, 9, 3),	/* IMGCI_T1_A */
+	MTK_M4U_PORT_ID(0, 0, 9, 4),	/* SMTI_T1_A */
+	MTK_M4U_PORT_ID(0, 0, 9, 5),	/* SMTI_T4_A */
+	MTK_M4U_PORT_ID(0, 0, 9, 6),	/* TNCSTI_T1_A */
+	MTK_M4U_PORT_ID(0, 0, 9, 7),	/* TNCSTI_T4_A */
+	MTK_M4U_PORT_ID(0, 0, 9, 8),	/* YUVO_T1_A */
+	MTK_M4U_PORT_ID(0, 0, 9, 9),	/* YUVBO_T1_A */
+	MTK_M4U_PORT_ID(0, 0, 9, 10),	/* YUVCO_T1_A */
+	MTK_M4U_PORT_ID(0, 0, 9, 11),	/* TIMGO_T1_A */
+	MTK_M4U_PORT_ID(0, 0, 9, 12),	/* YUVO_T2_A */
+	MTK_M4U_PORT_ID(0, 0, 9, 13),	/* YUVO_T5_A */
+	MTK_M4U_PORT_ID(0, 0, 9, 14),	/* IMGI_T1_B */
+	MTK_M4U_PORT_ID(0, 0, 9, 15),	/* IMGBI_T1_B */
+	MTK_M4U_PORT_ID(0, 0, 9, 16),	/* IMGCI_T1_B */
+	MTK_M4U_PORT_ID(0, 0, 9, 17),	/* SMTI_T4_B */
+	MTK_M4U_PORT_ID(0, 0, 9, 18),	/* TNCSO_T1_A */
+	MTK_M4U_PORT_ID(0, 0, 9, 19),	/* SMTO_T1_A */
+	MTK_M4U_PORT_ID(0, 0, 9, 20),	/* SMTO_T4_A */
+	MTK_M4U_PORT_ID(0, 0, 9, 21),	/* TNCSTO_T1_A */
+	MTK_M4U_PORT_ID(0, 0, 9, 22),	/* YUVO_T2_B */
+	MTK_M4U_PORT_ID(0, 0, 9, 23),	/* YUVO_T5_B */
+	MTK_M4U_PORT_ID(0, 0, 9, 24)	/* SMTO_T4_B */
+};
+
+static unsigned int g_IOMMUL11Def[TRAW_L11_PORT_CNT] = {
+	MTK_M4U_PORT_ID(0, 0, 11, 9),	/* IMGI_T1_C */
+	MTK_M4U_PORT_ID(0, 0, 11, 10),	/* IMGBI_T1_C */
+	MTK_M4U_PORT_ID(0, 0, 11, 11),	/* IMGCI_T1_C */
+	MTK_M4U_PORT_ID(0, 0, 11, 12),	/* SMTI_T1_C */
+	MTK_M4U_PORT_ID(0, 0, 11, 13),	/* SMTI_T4_C */
+	MTK_M4U_PORT_ID(0, 0, 11, 14),	/* SMTI_T6_C */
+	MTK_M4U_PORT_ID(0, 0, 11, 15),	/* YUVO_T1_C */
+	MTK_M4U_PORT_ID(0, 0, 11, 16),	/* YUVBO_T1_C */
+	MTK_M4U_PORT_ID(0, 0, 11, 17),	/* YUVCO_T1_C */
+	MTK_M4U_PORT_ID(0, 0, 11, 23),	/* TIMGO_T1_C */
+	MTK_M4U_PORT_ID(0, 0, 11, 24),	/* YUVO_T2_C */
+	MTK_M4U_PORT_ID(0, 0, 11, 25),	/* YUVO_T5_C */
+	MTK_M4U_PORT_ID(0, 0, 11, 26),	/* SMTO_T1_C */
+	MTK_M4U_PORT_ID(0, 0, 11, 27),	/* SMTO_T4_C */
+	MTK_M4U_PORT_ID(0, 0, 11, 28),	/* SMTO_T6_C */
+	MTK_M4U_PORT_ID(0, 0, 11, 29)	/* DBGO_T1_C */
+};
+#endif
+
+static unsigned int ExeDbgCmd(struct mtk_imgsys_dev *a_pDev,
+			void __iomem *a_pRegBA,
+			unsigned int a_DdbSel,
+			unsigned int a_DbgOut,
+			unsigned int a_DbgCmd)
+{
+	unsigned int DbgData = 0;
+	unsigned int DbgOutReg = g_RegBaseAddr + a_DbgOut;
+	void __iomem *pDbgSel = (void *)(a_pRegBA + a_DdbSel);
+	void __iomem *pDbgPort = (void *)(a_pRegBA + a_DbgOut);
+
+	iowrite32(a_DbgCmd, pDbgSel);
+	DbgData = (unsigned int)ioread32(pDbgPort);
+	pr_info("[0x%08X](0x%08X,0x%08X)\n",
+		a_DbgCmd, DbgOutReg, DbgData);
+
+	return DbgData;
+}
+
+static void imgsys_traw_dump_dma(struct mtk_imgsys_dev *a_pDev,
+				void __iomem *a_pRegBA,
+				unsigned int a_DdbSel,
+				unsigned int a_DbgOut)
+{
+	unsigned int Idx = 0;
+	unsigned int DbgCmd = 0;
+	unsigned int DmaDegInfoSize = sizeof(struct TRAWDmaDebugInfo);
+	unsigned int DebugCnt = sizeof(g_DMADbgIfo)/DmaDegInfoSize;
+	enum TRAWDmaDebugType DbgTy = TRAW_ORI_RDMA_DEBUG;
+
+	/* Dump DMA Debug Info */
+	for (Idx = 0; Idx < DebugCnt; Idx++) {
+		/* state_checksum */
+		DbgCmd = TRAW_IMGI_STATE_CHECKSUM + Idx;
+		ExeDbgCmd(a_pDev, a_pRegBA, a_DdbSel, a_DbgOut, DbgCmd);
+		/* line_pix_cnt_tmp */
+		DbgCmd = TRAW_IMGI_LINE_PIX_CNT_TMP + Idx;
+		ExeDbgCmd(a_pDev, a_pRegBA, a_DdbSel, a_DbgOut, DbgCmd);
+		/* line_pix_cnt */
+		DbgCmd = TRAW_IMGI_LINE_PIX_CNT + Idx;
+		ExeDbgCmd(a_pDev, a_pRegBA, a_DdbSel, a_DbgOut, DbgCmd);
+
+		DbgTy = g_DMADbgIfo[Idx].DMADebugType;
+
+		/* important_status */
+		if (DbgTy == TRAW_ULC_RDMA_DEBUG ||
+			DbgTy == TRAW_ULC_WDMA_DEBUG) {
+			DbgCmd = TRAW_IMGI_IMPORTANT_STATUS + Idx;
+			ExeDbgCmd(a_pDev, a_pRegBA, a_DdbSel, a_DbgOut,
+			DbgCmd);
+		}
+
+		/* smi_debug_data (case 0) or cmd_data_cnt */
+		if (DbgTy == TRAW_ORI_RDMA_DEBUG ||
+			DbgTy == TRAW_ULC_RDMA_DEBUG ||
+			DbgTy == TRAW_ULC_WDMA_DEBUG) {
+			DbgCmd = TRAW_IMGI_SMI_DEBUG_DATA_CASE0 + Idx;
+			ExeDbgCmd(a_pDev, a_pRegBA, a_DdbSel, a_DbgOut,
+			DbgCmd);
+		}
+
+		/* ULC_RDMA or ULC_WDMA */
+		if (DbgTy == TRAW_ULC_RDMA_DEBUG ||
+			DbgTy == TRAW_ULC_WDMA_DEBUG) {
+			DbgCmd = TRAW_IMGI_TILEX_BYTE_CNT + Idx;
+			ExeDbgCmd(a_pDev, a_pRegBA, a_DdbSel, a_DbgOut,
+				DbgCmd);
+			DbgCmd = TRAW_IMGI_TILEY_CNT + Idx;
+			ExeDbgCmd(a_pDev, a_pRegBA, a_DdbSel, a_DbgOut,
+				DbgCmd);
+		}
+
+		/* smi_dbg_data(case 0) or burst_line_cnt or input_v_cnt */
+		if (DbgTy == TRAW_ORI_WDMA_DEBUG ||
+			DbgTy == TRAW_ULC_RDMA_DEBUG ||
+			DbgTy == TRAW_ULC_WDMA_DEBUG) {
+			DbgCmd = TRAW_IMGI_BURST_LINE_CNT + Idx;
+			ExeDbgCmd(a_pDev, a_pRegBA, a_DdbSel, a_DbgOut,
+				DbgCmd);
+		}
+
+		/* ORI_RDMA */
+		if (DbgTy == TRAW_ORI_RDMA_DEBUG) {
+			DbgCmd = TRAW_IMGI_FIFO_DEBUG_DATA_CASE1 + Idx;
+			ExeDbgCmd(a_pDev, a_pRegBA, a_DdbSel, a_DbgOut,
+				DbgCmd);
+			DbgCmd = TRAW_IMGI_FIFO_DEBUG_DATA_CASE3 + Idx;
+			ExeDbgCmd(a_pDev, a_pRegBA, a_DdbSel, a_DbgOut,
+				DbgCmd);
+		}
+
+		/* ORI_WDMA */
+		if (DbgTy == TRAW_ORI_WDMA_DEBUG) {
+			DbgCmd = TRAW_YUVO_T1_FIFO_DEBUG_DATA_CASE1 + Idx;
+			ExeDbgCmd(a_pDev, a_pRegBA, a_DdbSel, a_DbgOut,
+				DbgCmd);
+			DbgCmd = TRAW_YUVO_T1_FIFO_DEBUG_DATA_CASE3 + Idx;
+			ExeDbgCmd(a_pDev, a_pRegBA, a_DdbSel, a_DbgOut,
+				DbgCmd);
+		}
+
+		/* xfer_y_cnt */
+		if (DbgTy == TRAW_ULC_WDMA_DEBUG) {
+			DbgCmd = TRAW_IMGI_XFER_Y_CNT + Idx;
+			ExeDbgCmd(a_pDev, a_pRegBA, a_DdbSel, a_DbgOut,
+				DbgCmd);
+		}
+
+	}
+
+}
+
+static void imgsys_traw_dump_cq(struct mtk_imgsys_dev *a_pDev,
+				void __iomem *a_pRegBA,
+				unsigned int a_DdbSel,
+				unsigned int a_DbgOut)
+{
+	unsigned int DbgCmd = 0;
+	void __iomem *pCQEn = (void *)(a_pRegBA + TRAW_DIPCQ_CQ_EN);
+
+
+	/* arx/atx/drx/dtx_state */
+	DbgCmd = 0x00000005;
+	ExeDbgCmd(a_pDev, a_pRegBA, a_DdbSel, a_DbgOut, DbgCmd);
+	/* Thr(0~3)_state */
+	DbgCmd = 0x00010005;
+	ExeDbgCmd(a_pDev, a_pRegBA, a_DdbSel, a_DbgOut, DbgCmd);
+
+	/* Set DIPCQ_CQ_EN[28] to 1 */
+	iowrite32(0x10000000, pCQEn);
+	/* cqd0_checksum0 */
+	DbgCmd = 0x00000005;
+	ExeDbgCmd(a_pDev, a_pRegBA, a_DdbSel, a_DbgOut, DbgCmd);
+	/* cqd0_checksum1 */
+	DbgCmd = 0x00010005;
+	ExeDbgCmd(a_pDev, a_pRegBA, a_DdbSel, a_DbgOut, DbgCmd);
+	/* cqd0_checksum2 */
+	DbgCmd = 0x00020005;
+	ExeDbgCmd(a_pDev, a_pRegBA, a_DdbSel, a_DbgOut, DbgCmd);
+	/* cqd1_checksum0 */
+	DbgCmd = 0x00040005;
+	ExeDbgCmd(a_pDev, a_pRegBA, a_DdbSel, a_DbgOut, DbgCmd);
+	/* cqd1_checksum1 */
+	DbgCmd = 0x00050005;
+	ExeDbgCmd(a_pDev, a_pRegBA, a_DdbSel, a_DbgOut, DbgCmd);
+	/* cqd1_checksum2 */
+	DbgCmd = 0x00060005;
+	ExeDbgCmd(a_pDev, a_pRegBA, a_DdbSel, a_DbgOut, DbgCmd);
+	/* cqa0_checksum0 */
+	DbgCmd = 0x00080005;
+	ExeDbgCmd(a_pDev, a_pRegBA, a_DdbSel, a_DbgOut, DbgCmd);
+	/* cqa0_checksum1 */
+	DbgCmd = 0x00090005;
+	ExeDbgCmd(a_pDev, a_pRegBA, a_DdbSel, a_DbgOut, DbgCmd);
+	/* cqa0_checksum2 */
+	DbgCmd = 0x000A0005;
+	ExeDbgCmd(a_pDev, a_pRegBA, a_DdbSel, a_DbgOut, DbgCmd);
+	/* cqa1_checksum0 */
+	DbgCmd = 0x000C0005;
+	ExeDbgCmd(a_pDev, a_pRegBA, a_DdbSel, a_DbgOut, DbgCmd);
+	/* cqa1_checksum1 */
+	DbgCmd = 0x000D0005;
+	ExeDbgCmd(a_pDev, a_pRegBA, a_DdbSel, a_DbgOut, DbgCmd);
+	/* cqa1_checksum2 */
+	DbgCmd = 0x000E0005;
+	ExeDbgCmd(a_pDev, a_pRegBA, a_DdbSel, a_DbgOut, DbgCmd);
+
+}
+
+static void imgsys_traw_dump_drzh2n(struct mtk_imgsys_dev *a_pDev,
+				void __iomem *a_pRegBA,
+				unsigned int a_DdbSel,
+				unsigned int a_DbgOut)
+{
+	unsigned int DbgCmd = 0;
+
+
+	/* drzh2n_t1 line_pix_cnt_tmp */
+	DbgCmd = 0x0002C001;
+	ExeDbgCmd(a_pDev, a_pRegBA, a_DdbSel, a_DbgOut, DbgCmd);
+	/* drzh2n_t1 line_pix_cnt */
+	DbgCmd = 0x0003C001;
+	ExeDbgCmd(a_pDev, a_pRegBA, a_DdbSel, a_DbgOut, DbgCmd);
+	/* drzh2n_t1 handshake signal */
+	DbgCmd = 0x0004C001;
+	ExeDbgCmd(a_pDev, a_pRegBA, a_DdbSel, a_DbgOut, DbgCmd);
+	/* drzh2n_t2 line_pix_cnt_tmp */
+	DbgCmd = 0x0002C101;
+	ExeDbgCmd(a_pDev, a_pRegBA, a_DdbSel, a_DbgOut, DbgCmd);
+	/* drzh2n_t2 line_pix_cnt */
+	DbgCmd = 0x0003C101;
+	ExeDbgCmd(a_pDev, a_pRegBA, a_DdbSel, a_DbgOut, DbgCmd);
+	/* drzh2n_t2 handshake signal */
+	DbgCmd = 0x0004C101;
+	ExeDbgCmd(a_pDev, a_pRegBA, a_DdbSel, a_DbgOut, DbgCmd);
+	/* drzh2n_t3 line_pix_cnt_tmp */
+	DbgCmd = 0x0002C501;
+	ExeDbgCmd(a_pDev, a_pRegBA, a_DdbSel, a_DbgOut, DbgCmd);
+	/* drzh2n_t3 line_pix_cnt */
+	DbgCmd = 0x0003C501;
+	ExeDbgCmd(a_pDev, a_pRegBA, a_DdbSel, a_DbgOut, DbgCmd);
+	/* drzh2n_t3 handshake signal */
+	DbgCmd = 0x0004C501;
+	ExeDbgCmd(a_pDev, a_pRegBA, a_DdbSel, a_DbgOut, DbgCmd);
+	/* drzh2n_t4 line_pix_cnt_tmp */
+	DbgCmd = 0x0002C601;
+	ExeDbgCmd(a_pDev, a_pRegBA, a_DdbSel, a_DbgOut, DbgCmd);
+	/* drzh2n_t4 line_pix_cnt */
+	DbgCmd = 0x0003C601;
+	ExeDbgCmd(a_pDev, a_pRegBA, a_DdbSel, a_DbgOut, DbgCmd);
+	/* drzh2n_t4 handshake signal */
+	DbgCmd = 0x0004C601;
+	ExeDbgCmd(a_pDev, a_pRegBA, a_DdbSel, a_DbgOut, DbgCmd);
+	/* drzh2n_t5 line_pix_cnt_tmp */
+	DbgCmd = 0x0002C701;
+	ExeDbgCmd(a_pDev, a_pRegBA, a_DdbSel, a_DbgOut, DbgCmd);
+	/* drzh2n_t5 line_pix_cnt */
+	DbgCmd = 0x0003C701;
+	ExeDbgCmd(a_pDev, a_pRegBA, a_DdbSel, a_DbgOut, DbgCmd);
+	/* drzh2n_t5 handshake signal */
+	DbgCmd = 0x0004C701;
+	ExeDbgCmd(a_pDev, a_pRegBA, a_DdbSel, a_DbgOut, DbgCmd);
+	/* drzh2n_t6 line_pix_cnt_tmp */
+	DbgCmd = 0x0002C801;
+	ExeDbgCmd(a_pDev, a_pRegBA, a_DdbSel, a_DbgOut, DbgCmd);
+	/* drzh2n_t6 line_pix_cnt */
+	DbgCmd = 0x0003C801;
+	ExeDbgCmd(a_pDev, a_pRegBA, a_DdbSel, a_DbgOut, DbgCmd);
+	/* drzh2n_t6 handshake signal */
+	DbgCmd = 0x0004C801;
+	ExeDbgCmd(a_pDev, a_pRegBA, a_DdbSel, a_DbgOut, DbgCmd);
+	/* rzh1n2t_t1 checksum */
+	DbgCmd = 0x0001C201;
+	ExeDbgCmd(a_pDev, a_pRegBA, a_DdbSel, a_DbgOut, DbgCmd);
+	/* rzh1n2t_t1 tile line_pix_cnt */
+	DbgCmd = 0x0003C201;
+	ExeDbgCmd(a_pDev, a_pRegBA, a_DdbSel, a_DbgOut, DbgCmd);
+	/* rzh1n2t_t1 tile protocal */
+	DbgCmd = 0x0008C201;
+	ExeDbgCmd(a_pDev, a_pRegBA, a_DdbSel, a_DbgOut, DbgCmd);
+
+}
+
+static void imgsys_traw_dump_smto(struct mtk_imgsys_dev *a_pDev,
+				void __iomem *a_pRegBA,
+				unsigned int a_DdbSel,
+				unsigned int a_DbgOut)
+{
+	unsigned int DbgCmd = 0;
+
+
+	/* smto_t3 line_pix_cnt_tmp */
+	DbgCmd = 0x0002C401;
+	ExeDbgCmd(a_pDev, a_pRegBA, a_DdbSel, a_DbgOut, DbgCmd);
+	/* smto_t3 line_pix_cnt */
+	DbgCmd = 0x0003C401;
+	ExeDbgCmd(a_pDev, a_pRegBA, a_DdbSel, a_DbgOut, DbgCmd);
+	/* smto_t3 handshake signal */
+	DbgCmd = 0x0004C401;
+	ExeDbgCmd(a_pDev, a_pRegBA, a_DdbSel, a_DbgOut, DbgCmd);
+
+}
+
+static void imgsys_traw_dump_dl(struct mtk_imgsys_dev *a_pDev,
+				void __iomem *a_pRegBA,
+				unsigned int a_DdbSel,
+				unsigned int a_DbgOut)
+{
+	unsigned int DbgCmd = 0;
+	unsigned int DbgData = 0;
+	unsigned int DbgLineCnt = 0, DbgRdy = 0, DbgReq = 0;
+	unsigned int DbgLineCntReg = 0;
+
+
+	/* wpe_wif_t1_debug */
+	/* sot_st,eol_st,eot_st,sof,sot,eol,eot,req,rdy,7b0,checksum_out */
+	DbgCmd = 0x00000006;
+	DbgData = ExeDbgCmd(a_pDev, a_pRegBA, a_DdbSel, a_DbgOut, DbgCmd);
+	DbgRdy = ((DbgData & 0x800000) > 0) ? 1 : 0;
+	DbgReq = ((DbgData & 0x1000000) > 0) ? 1 : 0;
+	pr_info("[wpe_wif_t1_debug]checksum(0x%X),rdy(%d) req(%d)\n",
+		DbgData & 0xFFFF, DbgRdy, DbgReq);
+	/* line_cnt[15:0],  pix_cnt[15:0] */
+	DbgCmd = 0x00000007;
+	DbgData = ExeDbgCmd(a_pDev, a_pRegBA, a_DdbSel, a_DbgOut, DbgCmd);
+	DbgLineCnt = (DbgData & 0xFFFF0000) / 0xFFFF;
+	pr_info("[wpe_wif_t1_debug]pix_cnt(0x%X),line_cnt(0x%X)\n",
+		DbgData & 0xFFFF, DbgLineCnt);
+	/* line_cnt_reg[15:0], pix_cnt_reg[15:0] */
+	DbgCmd = 0x00000008;
+	DbgData = ExeDbgCmd(a_pDev, a_pRegBA, a_DdbSel, a_DbgOut, DbgCmd);
+	DbgLineCntReg = (DbgData & 0xFFFF0000) / 0xFFFF;
+	pr_info("[wpe_wif_t1_debug]pix_cnt_reg(0x%X),line_cnt_reg(0x%X)\n",
+		DbgData & 0xFFFF, DbgLineCntReg);
+
+	/* wpe_wif_t2_debug */
+	/* sot_st,eol_st,eot_st,sof,sot,eol,eot,req,rdy,7b0,checksum_out */
+	DbgCmd = 0x00000106;
+	DbgData = ExeDbgCmd(a_pDev, a_pRegBA, a_DdbSel, a_DbgOut, DbgCmd);
+	DbgRdy = ((DbgData & 0x800000) > 0) ? 1 : 0;
+	DbgReq = ((DbgData & 0x1000000) > 0) ? 1 : 0;
+	pr_info("[wpe_wif_t2_debug]checksum(0x%X),rdy(%d) req(%d)\n",
+		DbgData & 0xFFFF, DbgRdy, DbgReq);
+	/* line_cnt[15:0],  pix_cnt[15:0] */
+	DbgCmd = 0x00000107;
+	DbgData = ExeDbgCmd(a_pDev, a_pRegBA, a_DdbSel, a_DbgOut, DbgCmd);
+	DbgLineCnt = (DbgData & 0xFFFF0000) / 0xFFFF;
+	pr_info("[wpe_wif_t2_debug]pix_cnt(0x%X),line_cnt(0x%X)\n",
+		DbgData & 0xFFFF, DbgLineCnt);
+	/* line_cnt_reg[15:0], pix_cnt_reg[15:0] */
+	DbgCmd = 0x00000108;
+	DbgData = ExeDbgCmd(a_pDev, a_pRegBA, a_DdbSel, a_DbgOut, DbgCmd);
+	DbgLineCntReg = (DbgData & 0xFFFF0000) / 0xFFFF;
+	pr_info("[wpe_wif_t2_debug]pix_cnt_reg(0x%X),line_cnt_reg(0x%X)\n",
+		DbgData & 0xFFFF, DbgLineCntReg);
+
+	/* traw_dip_d1_debug */
+	/* sot_st,eol_st,eot_st,sof,sot,eol,eot,req,rdy,7b0,checksum_out */
+	DbgCmd = 0x00000206;
+	DbgData = ExeDbgCmd(a_pDev, a_pRegBA, a_DdbSel, a_DbgOut, DbgCmd);
+	DbgRdy = ((DbgData & 0x800000) > 0) ? 1 : 0;
+	DbgReq = ((DbgData & 0x1000000) > 0) ? 1 : 0;
+	pr_info("[traw_dip_d1_debug]checksum(0x%X),rdy(%d) req(%d)\n",
+		DbgData & 0xFFFF, DbgRdy, DbgReq);
+	/* line_cnt[15:0],  pix_cnt[15:0] */
+	DbgCmd = 0x00000207;
+	DbgData = ExeDbgCmd(a_pDev, a_pRegBA, a_DdbSel, a_DbgOut, DbgCmd);
+	DbgLineCnt = (DbgData & 0xFFFF0000) / 0xFFFF;
+	pr_info("[traw_dip_d1_debug]pix_cnt(0x%X),line_cnt(0x%X)\n",
+		DbgData & 0xFFFF, DbgLineCnt);
+	/* line_cnt_reg[15:0], pix_cnt_reg[15:0] */
+	DbgCmd = 0x00000208;
+	DbgData = ExeDbgCmd(a_pDev, a_pRegBA, a_DdbSel, a_DbgOut, DbgCmd);
+	DbgLineCntReg = (DbgData & 0xFFFF0000) / 0xFFFF;
+	pr_info("[traw_dip_d1_debug]pix_cnt_reg(0x%X),line_cnt_reg(0x%X)\n",
+		DbgData & 0xFFFF, DbgLineCntReg);
+
+	/* wpe_wif_t3_debug */
+	/* sot_st,eol_st,eot_st,sof,sot,eol,eot,req,rdy,7b0,checksum_out */
+	DbgCmd = 0x00000306;
+	DbgData = ExeDbgCmd(a_pDev, a_pRegBA, a_DdbSel, a_DbgOut, DbgCmd);
+	DbgRdy = ((DbgData & 0x800000) > 0) ? 1 : 0;
+	DbgReq = ((DbgData & 0x1000000) > 0) ? 1 : 0;
+	pr_info("[wpe_wif_t3_debug]checksum(0x%X),rdy(%d) req(%d)\n",
+		DbgData & 0xFFFF, DbgRdy, DbgReq);
+	/* line_cnt[15:0],  pix_cnt[15:0] */
+	DbgCmd = 0x00000307;
+	DbgData = ExeDbgCmd(a_pDev, a_pRegBA, a_DdbSel, a_DbgOut, DbgCmd);
+	DbgLineCnt = (DbgData & 0xFFFF0000) / 0xFFFF;
+	pr_info("[wpe_wif_t3_debug]pix_cnt(0x%X),line_cnt(0x%X)\n",
+		DbgData & 0xFFFF, DbgLineCnt);
+	/* line_cnt_reg[15:0], pix_cnt_reg[15:0] */
+	DbgCmd = 0x00000308;
+	DbgData = ExeDbgCmd(a_pDev, a_pRegBA, a_DdbSel, a_DbgOut, DbgCmd);
+	DbgLineCntReg = (DbgData & 0xFFFF0000) / 0xFFFF;
+	pr_info("[wpe_wif_t3_debug]pix_cnt_reg(0x%X),line_cnt_reg(0x%X)\n",
+		DbgData & 0xFFFF, DbgLineCntReg);
+
+	/* adl_wif_t4_debug */
+	/* sot_st,eol_st,eot_st,sof,sot,eol,eot,req,rdy,7b0,checksum_out */
+	DbgCmd = 0x00000406;
+	DbgData = ExeDbgCmd(a_pDev, a_pRegBA, a_DdbSel, a_DbgOut, DbgCmd);
+	DbgRdy = ((DbgData & 0x800000) > 0) ? 1 : 0;
+	DbgReq = ((DbgData & 0x1000000) > 0) ? 1 : 0;
+	pr_info("[adl_wif_t4_debug]checksum(0x%X),rdy(%d) req(%d)\n",
+		DbgData & 0xFFFF, DbgRdy, DbgReq);
+	/* line_cnt[15:0],  pix_cnt[15:0] */
+	DbgCmd = 0x00000407;
+	DbgData = ExeDbgCmd(a_pDev, a_pRegBA, a_DdbSel, a_DbgOut, DbgCmd);
+	DbgLineCnt = (DbgData & 0xFFFF0000) / 0xFFFF;
+	pr_info("[adl_wif_t4_debug]pix_cnt(0x%X),line_cnt(0x%X)\n",
+		DbgData & 0xFFFF, DbgLineCnt);
+	/* line_cnt_reg[15:0], pix_cnt_reg[15:0] */
+	DbgCmd = 0x00000408;
+	DbgData = ExeDbgCmd(a_pDev, a_pRegBA, a_DdbSel, a_DbgOut, DbgCmd);
+	DbgLineCntReg = (DbgData & 0xFFFF0000) / 0xFFFF;
+	pr_info("[adl_wif_t4_debug]pix_cnt_reg(0x%X),line_cnt_reg(0x%X)\n",
+		DbgData & 0xFFFF, DbgLineCntReg);
+
+	/* adl_wif_t4n_debug */
+	/* sot_st,eol_st,eot_st,sof,sot,eol,eot,req,rdy,7b0,checksum_out */
+	DbgCmd = 0x00000506;
+	DbgData = ExeDbgCmd(a_pDev, a_pRegBA, a_DdbSel, a_DbgOut, DbgCmd);
+	DbgRdy = ((DbgData & 0x800000) > 0) ? 1 : 0;
+	DbgReq = ((DbgData & 0x1000000) > 0) ? 1 : 0;
+	pr_info("[adl_wif_t4n_debug]checksum(0x%X),rdy(%d) req(%d)\n",
+		DbgData & 0xFFFF, DbgRdy, DbgReq);
+	/* line_cnt[15:0],  pix_cnt[15:0] */
+	DbgCmd = 0x00000507;
+	DbgData = ExeDbgCmd(a_pDev, a_pRegBA, a_DdbSel, a_DbgOut, DbgCmd);
+	DbgLineCnt = (DbgData & 0xFFFF0000) / 0xFFFF;
+	pr_info("[adl_wif_t4n_debug]pix_cnt(0x%X),line_cnt(0x%X)\n",
+		DbgData & 0xFFFF, DbgLineCnt);
+	/* line_cnt_reg[15:0], pix_cnt_reg[15:0] */
+	DbgCmd = 0x00000508;
+	DbgData = ExeDbgCmd(a_pDev, a_pRegBA, a_DdbSel, a_DbgOut, DbgCmd);
+	DbgLineCntReg = (DbgData & 0xFFFF0000) / 0xFFFF;
+	pr_info("[adl_wif_t4n_debug]pix_cnt_reg(0x%X),line_cnt_reg(0x%X)\n",
+		DbgData & 0xFFFF, DbgLineCntReg);
+
+	/* adl_wif_t5_debug */
+	/* sot_st,eol_st,eot_st,sof,sot,eol,eot,req,rdy,7b0,checksum_out */
+	DbgCmd = 0x00000606;
+	DbgData = ExeDbgCmd(a_pDev, a_pRegBA, a_DdbSel, a_DbgOut, DbgCmd);
+	DbgRdy = ((DbgData & 0x800000) > 0) ? 1 : 0;
+	DbgReq = ((DbgData & 0x1000000) > 0) ? 1 : 0;
+	pr_info("[adl_wif_t5_debug]checksum(0x%X),rdy(%d) req(%d)\n",
+		DbgData & 0xFFFF, DbgRdy, DbgReq);
+	/* line_cnt[15:0],  pix_cnt[15:0] */
+	DbgCmd = 0x00000607;
+	DbgData = ExeDbgCmd(a_pDev, a_pRegBA, a_DdbSel, a_DbgOut, DbgCmd);
+	DbgLineCnt = (DbgData & 0xFFFF0000) / 0xFFFF;
+	pr_info("[adl_wif_t5_debug]pix_cnt(0x%X),line_cnt(0x%X)\n",
+		DbgData & 0xFFFF, DbgLineCnt);
+	/* line_cnt_reg[15:0], pix_cnt_reg[15:0] */
+	DbgCmd = 0x00000608;
+	DbgData = ExeDbgCmd(a_pDev, a_pRegBA, a_DdbSel, a_DbgOut, DbgCmd);
+	DbgLineCntReg = (DbgData & 0xFFFF0000) / 0xFFFF;
+	pr_info("[adl_wif_t5_debug]pix_cnt_reg(0x%X),line_cnt_reg(0x%X)\n",
+		DbgData & 0xFFFF, DbgLineCntReg);
+
+}
+
+#if TRAW_M4U
+static int GetFaultDMAAddr(unsigned int port, unsigned int *pStartAddr, unsigned int *pEndAddr)
+{
+	int Result = 1;
+
+	/* IMGI_T1 */
+	if (port == MTK_M4U_PORT_ID(0, 0, 9, 0) ||
+		port == MTK_M4U_PORT_ID(0, 0, 9, 14) ||
+		port == MTK_M4U_PORT_ID(0, 0, 11, 9)) {
+		*pStartAddr = TRAW_DMA_IMGI_ADDR;
+		*pEndAddr = (*pStartAddr + 48);
+	}
+	/* UFDI_T1 */
+	else if (port == MTK_M4U_PORT_ID(0, 0, 9, 1)) {
+		*pStartAddr = TRAW_DMA_UFDI_ADDR;
+		*pEndAddr = (*pStartAddr + 48);
+	}
+	/* IMGBI_T1 */
+	else if (port == MTK_M4U_PORT_ID(0, 0, 9, 2) ||
+		port == MTK_M4U_PORT_ID(0, 0, 9, 15) ||
+		port == MTK_M4U_PORT_ID(0, 0, 11, 10)) {
+		*pStartAddr = TRAW_DMA_IMGBI_ADDR;
+		*pEndAddr = (*pStartAddr + 48);
+	}
+	/* IMGCI_T1 */
+	else if (port == MTK_M4U_PORT_ID(0, 0, 9, 3) ||
+		port == MTK_M4U_PORT_ID(0, 0, 9, 16) ||
+		port == MTK_M4U_PORT_ID(0, 0, 11, 11)) {
+		*pStartAddr = TRAW_DMA_IMGCI_ADDR;
+		*pEndAddr = (*pStartAddr + 48);
+	}
+	/* YUVO_T1 */
+	else if (port == MTK_M4U_PORT_ID(0, 0, 9, 8) ||
+		port == MTK_M4U_PORT_ID(0, 0, 9, 9) ||
+		port == MTK_M4U_PORT_ID(0, 0, 11, 15) ||
+		port == MTK_M4U_PORT_ID(0, 0, 11, 16)) {
+		*pStartAddr = TRAW_DMA_YUVO_T1_ADDR;
+		*pEndAddr = (*pStartAddr + 224);
+	}
+	/* YUVCO_T1 */
+	else if (port == MTK_M4U_PORT_ID(0, 0, 9, 10) ||
+		port == MTK_M4U_PORT_ID(0, 0, 11, 17)) {
+		*pStartAddr = TRAW_DMA_YUVCO_T1_ADDR;
+		*pEndAddr = (*pStartAddr + 224);
+	}
+	/* TIMGO_T1 */
+	else if (port == MTK_M4U_PORT_ID(0, 0, 9, 11) ||
+		port == MTK_M4U_PORT_ID(0, 0, 11, 23)) {
+		*pStartAddr = TRAW_DMA_TIMGO_T1_ADDR;
+		*pEndAddr = (*pStartAddr + 48);
+	}
+	/* YUVO_T2 */
+	else if (port == MTK_M4U_PORT_ID(0, 0, 9, 12) ||
+		port == MTK_M4U_PORT_ID(0, 0, 9, 22) ||
+		port == MTK_M4U_PORT_ID(0, 0, 11, 24)) {
+		*pStartAddr = TRAW_DMA_YUVO_T2_ADDR;
+		*pEndAddr = (*pStartAddr + 368);
+	}
+	/* YUVO_T5 */
+	else if (port == MTK_M4U_PORT_ID(0, 0, 9, 13) ||
+		port == MTK_M4U_PORT_ID(0, 0, 9, 23) ||
+		port == MTK_M4U_PORT_ID(0, 0, 11, 25)) {
+		*pStartAddr = TRAW_DMA_YUVO_T5_ADDR;
+		*pEndAddr = (*pStartAddr + 48);
+	}
+	/* TNCSO_T1 */
+	else if (port == MTK_M4U_PORT_ID(0, 0, 9, 18)) {
+		*pStartAddr = TRAW_DMA_TNCSO_T1_ADDR;
+		*pEndAddr = (*pStartAddr + 240);
+	}
+	/* SMTO_T6 */
+	else if (port == MTK_M4U_PORT_ID(0, 0, 11, 28)) {
+		*pStartAddr = TRAW_DMA_RZH1N2TO_T1_ADDR;
+		*pEndAddr = (*pStartAddr + 176);
+	}
+	/* DBGO_T1 */
+	else if (port == MTK_M4U_PORT_ID(0, 0, 11, 29)) {
+		*pStartAddr = TRAW_DMA_DBGO_T1_ADDR;
+		*pEndAddr = (*pStartAddr + 48);
+	}
+	/* Not Define Port */
+	else
+		Result = 0;
+
+
+
+	return Result;
+
+
+}
+
+
+static int imgsys_traw_iommu_cb(int port, dma_addr_t mva, void *cb_data)
+{
+	unsigned int engine = IMGSYS_ENG_TRAW;
+	void __iomem *trawRegBA = 0L;
+	unsigned int i = 0;
+	unsigned int DMAStartAddr = 0, DMAEndAddr = 0;
+	unsigned int RegMap = REG_MAP_E_TRAW;
+	char DbgStr[128];
+
+
+	if (g_IOMMUDumpPort != port)
+		g_IOMMUDumpPort = port;
+	else
+		return 0;
+
+	/* Set HW Engine */
+	if (port >= MTK_M4U_PORT_ID(0, 0, 9, 0) &&
+		port <= MTK_M4U_PORT_ID(0, 0, 9, 13))
+		engine = IMGSYS_ENG_TRAW;
+	else if (port >= MTK_M4U_PORT_ID(0, 0, 9, 14) &&
+		port <= MTK_M4U_PORT_ID(0, 0, 9, 17))
+		engine = IMGSYS_ENG_LTR;
+	else if (port >= MTK_M4U_PORT_ID(0, 0, 9, 18) &&
+		port <= MTK_M4U_PORT_ID(0, 0, 9, 21))
+		engine = IMGSYS_ENG_TRAW;
+	else if (port >= MTK_M4U_PORT_ID(0, 0, 9, 22) &&
+		port <= MTK_M4U_PORT_ID(0, 0, 9, 24))
+		engine = IMGSYS_ENG_LTR;
+	else if (port >= MTK_M4U_PORT_ID(0, 0, 11, 9) &&
+		port <= MTK_M4U_PORT_ID(0, 0, 11, 17))
+		engine = IMGSYS_ENG_XTR;
+	else if (port >= MTK_M4U_PORT_ID(0, 0, 11, 23) &&
+		port <= MTK_M4U_PORT_ID(0, 0, 11, 29))
+		engine = IMGSYS_ENG_XTR;
+	else
+		return 0;
+
+	/* ltraw */
+	if (engine & IMGSYS_ENG_LTR) {
+		RegMap = REG_MAP_E_LTRAW;
+		g_RegBaseAddr = TRAW_B_BASE_ADDR;
+		trawRegBA = g_ltrawRegBA;
+	}
+	/* xltraw */
+	else if (engine & IMGSYS_ENG_XTR) {
+		RegMap = REG_MAP_E_XTRAW;
+		g_RegBaseAddr = TRAW_C_BASE_ADDR;
+		trawRegBA = g_xtrawRegBA;
+	}
+	/* traw */
+	else {
+		g_RegBaseAddr = TRAW_A_BASE_ADDR;
+		trawRegBA = g_trawRegBA;
+	}
+
+	if (!trawRegBA)
+		return 0;
+
+	/* Dump Fault DMA registers */
+	if (GetFaultDMAAddr(port, &DMAStartAddr, &DMAEndAddr) == 0)
+		return 0;
+
+	for (i = DMAStartAddr; i <= DMAEndAddr; i += 16) {
+		if (sprintf(DbgStr, "[0x%08X] 0x%08X 0x%08X 0x%08X 0x%08X",
+			(unsigned int)(g_RegBaseAddr + i),
+			(unsigned int)ioread32((void *)(trawRegBA + i)),
+			(unsigned int)ioread32((void *)(trawRegBA + i + 4)),
+			(unsigned int)ioread32((void *)(trawRegBA + i + 8)),
+			(unsigned int)ioread32((void *)(trawRegBA + i + 12))) > 0)
+			pr_info("%s\n", DbgStr);
+	}
+
+	return 0;
+
+}
+
+static void imgsys_traw_reg_iommu_cb(void)
+{
+	unsigned int i = 0;
+
+	/* Reg Traw/Ltraw L9 Port Callback */
+	for (i = 0; i < TRAW_L9_PORT_CNT; i++) {
+		mtk_iommu_register_fault_callback(
+			g_IOMMUL9Def[i],
+			(mtk_iommu_fault_callback_t)imgsys_traw_iommu_cb,
+			NULL, false);
+	}
+
+	/* Reg Xtraw L11 Port Callback */
+	for (i = 0; i < TRAW_L11_PORT_CNT; i++) {
+		mtk_iommu_register_fault_callback(
+			g_IOMMUL11Def[i],
+			(mtk_iommu_fault_callback_t)imgsys_traw_iommu_cb,
+			NULL, false);
+	}
+
+}
+#endif
+
+
+//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+// Public Functions
+//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+void imgsys_traw_set_initial_value(struct mtk_imgsys_dev *imgsys_dev)
+{
+	/* iomap reg base */
+	g_trawRegBA = of_iomap(imgsys_dev->dev->of_node, REG_MAP_E_TRAW);
+	g_ltrawRegBA = of_iomap(imgsys_dev->dev->of_node, REG_MAP_E_LTRAW);
+	g_xtrawRegBA = of_iomap(imgsys_dev->dev->of_node, REG_MAP_E_XTRAW);
+#if TRAW_M4U
+	imgsys_traw_reg_iommu_cb();
+	/* Register IOMMU Callback */
+	g_IOMMUDumpPort = 0;
+#endif
+	pr_debug("%s\n", __func__);
+}
+
+void imgsys_traw_set_initial_value_hw(struct mtk_imgsys_dev *imgsys_dev)
+{
+	void __iomem *trawRegBA = 0L;
+	void __iomem *ofset = NULL;
+	unsigned int i = 0, HwIdx = 0;
+
+	for (HwIdx = 0; HwIdx < TRAW_HW_SET; HwIdx++) {
+		if (HwIdx == 0)
+			trawRegBA = g_trawRegBA;
+		else if (HwIdx == 1)
+			trawRegBA = g_ltrawRegBA;
+		else
+			trawRegBA = g_xtrawRegBA;
+
+		if (!trawRegBA) {
+			pr_info("%s: hw(%d)null reg base\n", __func__, HwIdx);
+			break;
+		}
+
+		for (i = 0 ; i < TRAW_INIT_ARRAY_COUNT ; i++) {
+			ofset = trawRegBA + mtk_imgsys_traw_init_ary[i].ofset;
+			writel(mtk_imgsys_traw_init_ary[i].val, ofset);
+		}
+	}
+
+	pr_debug("%s\n", __func__);
+}
+
+void imgsys_traw_debug_dump(struct mtk_imgsys_dev *imgsys_dev,
+							unsigned int engine)
+{
+	void __iomem *trawRegBA = 0L;
+	unsigned int i;
+	unsigned int DMADdbSel = TRAW_DMA_DBG_SEL;
+	unsigned int DMADbgOut = TRAW_DMA_DBG_PORT;
+	unsigned int CtlDdbSel = TRAW_CTL_DBG_SEL;
+	unsigned int CtlDbgOut = TRAW_CTL_DBG_PORT;
+	unsigned int RegMap = REG_MAP_E_TRAW;
+	char DbgStr[128];
+
+	pr_info("%s: +\n", __func__);
+
+	/* ltraw */
+	if (engine & IMGSYS_ENG_LTR) {
+		RegMap = REG_MAP_E_LTRAW;
+		g_RegBaseAddr = TRAW_B_BASE_ADDR;
+		trawRegBA = g_ltrawRegBA;
+	}
+	/* xltraw */
+	else if (engine & IMGSYS_ENG_XTR) {
+		RegMap = REG_MAP_E_XTRAW;
+		g_RegBaseAddr = TRAW_C_BASE_ADDR;
+		trawRegBA = g_xtrawRegBA;
+	}
+	/* traw */
+	else {
+		g_RegBaseAddr = TRAW_A_BASE_ADDR;
+		trawRegBA = g_trawRegBA;
+	}
+
+	if (!trawRegBA) {
+		dev_info(imgsys_dev->dev, "%s Unable to ioremap regmap(%d)\n",
+			__func__, RegMap);
+		dev_info(imgsys_dev->dev, "%s of_iomap fail, devnode(%s).\n",
+			__func__, imgsys_dev->dev->of_node->name);
+		goto err_debug_dump;
+	}
+
+	/* DL debug data */
+	imgsys_traw_dump_dl(imgsys_dev, trawRegBA, CtlDdbSel, CtlDbgOut);
+
+	/* Ctrl registers */
+	for (i = 0x0; i <= TRAW_CTL_ADDR_OFST; i += 16) {
+		if (sprintf(DbgStr, "[0x%08X] 0x%08X 0x%08X 0x%08X 0x%08X",
+			(unsigned int)(g_RegBaseAddr + i),
+			(unsigned int)ioread32((void *)(trawRegBA + i)),
+			(unsigned int)ioread32((void *)(trawRegBA + i + 4)),
+			(unsigned int)ioread32((void *)(trawRegBA + i + 8)),
+			(unsigned int)ioread32((void *)(trawRegBA + i + 12))) > 0)
+			pr_info("%s\n", DbgStr);
+	}
+	/* Dma registers */
+	for (i = TRAW_DMA_ADDR_OFST; i <= TRAW_DMA_ADDR_END; i += 16) {
+		if (sprintf(DbgStr, "[0x%08X] 0x%08X 0x%08X 0x%08X 0x%08X",
+			(unsigned int)(g_RegBaseAddr + i),
+			(unsigned int)ioread32((void *)(trawRegBA + i)),
+			(unsigned int)ioread32((void *)(trawRegBA + i + 4)),
+			(unsigned int)ioread32((void *)(trawRegBA + i + 8)),
+			(unsigned int)ioread32((void *)(trawRegBA + i + 12))) > 0)
+			pr_info("%s\n", DbgStr);
+	}
+	/* Data registers */
+	for (i = TRAW_DATA_ADDR_OFST; i <= TRAW_MAX_ADDR_OFST; i += 16) {
+		if (sprintf(DbgStr, "[0x%08X] 0x%08X 0x%08X 0x%08X 0x%08X",
+			(unsigned int)(g_RegBaseAddr + i),
+			(unsigned int)ioread32((void *)(trawRegBA + i)),
+			(unsigned int)ioread32((void *)(trawRegBA + i + 4)),
+			(unsigned int)ioread32((void *)(trawRegBA + i + 8)),
+			(unsigned int)ioread32((void *)(trawRegBA + i + 12))) > 0)
+			pr_info("%s\n", DbgStr);
+	}
+
+	/* DMA debug data */
+	imgsys_traw_dump_dma(imgsys_dev, trawRegBA, DMADdbSel, DMADbgOut);
+	/* CQ debug data */
+	imgsys_traw_dump_cq(imgsys_dev, trawRegBA, CtlDdbSel, CtlDbgOut);
+	/* DRZH2N debug data */
+	imgsys_traw_dump_drzh2n(imgsys_dev, trawRegBA, CtlDdbSel, CtlDbgOut);
+	/* SMTO debug data */
+	imgsys_traw_dump_smto(imgsys_dev, trawRegBA, CtlDdbSel, CtlDbgOut);
+
+err_debug_dump:
+	pr_info("%s: -\n", __func__);
+}
+
+void imgsys_traw_uninit(struct mtk_imgsys_dev *imgsys_dev)
+{
+	if (g_trawRegBA) {
+		iounmap(g_trawRegBA);
+		g_trawRegBA = 0L;
+	}
+	if (g_ltrawRegBA) {
+		iounmap(g_ltrawRegBA);
+		g_ltrawRegBA = 0L;
+	}
+	if (g_xtrawRegBA) {
+		iounmap(g_xtrawRegBA);
+		g_xtrawRegBA = 0L;
+	}
+
+	pr_debug("%s\n", __func__);
+}
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_71/modules/mtk_imgsys-traw.h b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_71/modules/mtk_imgsys-traw.h
new file mode 100644
index 0000000000000000000000000000000000000000..6c50f0ffdbf5ad291bd3a4bc65802977ed64bd4c
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_71/modules/mtk_imgsys-traw.h
@@ -0,0 +1,98 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2020 MediaTek Inc.
+ *
+ * Author: Shih-fang Chuang <shih-fang.chuang@mediatek.com>
+ *
+ */
+
+#ifndef _MTK_IMGSYS_TRAW_H_
+#define _MTK_IMGSYS_TRAW_H_
+
+// Standard C header file
+
+// kernel header file
+
+// mtk imgsys local header file
+#include <mtk_imgsys-dev.h>
+#include <mtk_imgsys-cmdq.h>
+
+// Local header file
+#include "mtk_imgsys-engine.h"
+
+/********************************************************************
+ * Global Define
+ ********************************************************************/
+#define TRAW_A_BASE_ADDR	0x15020000
+#define TRAW_B_BASE_ADDR	0x15040000
+#define TRAW_C_BASE_ADDR	0x15640000
+
+#define TRAW_DMA_NAME_MAX_SIZE	20
+
+#define TRAW_DMA_DBG_SEL	 (0x4070)
+#define TRAW_DMA_DBG_PORT	 (0x4074)
+#define TRAW_CTL_DBG_SEL	 (0x0190)
+#define TRAW_CTL_DBG_PORT	 (0x0194)
+#define TRAW_DIPCQ_CQ_EN	 (0x0200)
+#define WPE_MACRO_SW_RST	 (0x000C)
+#define WPE_MACRO_WPE_RST	 (0x0004)
+#define WPE_MACRO_LARB11_RST	 (0x0001)
+
+
+#define TRAW_IMGI_STATE_CHECKSUM		(0x00100)
+#define TRAW_IMGI_LINE_PIX_CNT_TMP		(0x00200)
+#define TRAW_IMGI_LINE_PIX_CNT			(0x00300)
+#define TRAW_IMGI_IMPORTANT_STATUS		(0x00400)
+#define TRAW_IMGI_SMI_DEBUG_DATA_CASE0		(0x00500)
+#define TRAW_IMGI_TILEX_BYTE_CNT		(0x00600)
+#define TRAW_IMGI_TILEY_CNT			(0x00700)
+#define TRAW_IMGI_BURST_LINE_CNT		(0x00800)
+#define TRAW_IMGI_XFER_Y_CNT			(0x00900)
+#define TRAW_IMGI_FIFO_DEBUG_DATA_CASE1		(0x10600)
+#define TRAW_IMGI_FIFO_DEBUG_DATA_CASE3		(0x30600)
+#define TRAW_YUVO_T1_FIFO_DEBUG_DATA_CASE1	(0x10700)
+#define TRAW_YUVO_T1_FIFO_DEBUG_DATA_CASE3	(0x30700)
+
+#define	TRAW_DMA_IMGI_ADDR		(0x4100)
+#define	TRAW_DMA_UFDI_ADDR		(0x4170)
+#define	TRAW_DMA_IMGBI_ADDR		(0x41E0)
+#define	TRAW_DMA_IMGCI_ADDR		(0x4250)
+#define	TRAW_DMA_YUVO_T1_ADDR		(0x4600)
+#define	TRAW_DMA_YUVBO_T1_ADDR		(0x46B0)
+#define	TRAW_DMA_YUVCO_T1_ADDR		(0x4760)
+#define	TRAW_DMA_TIMGO_T1_ADDR		(0x48C0)
+#define	TRAW_DMA_YUVO_T2_ADDR		(0x4970)
+#define	TRAW_DMA_YUVO_T5_ADDR		(0x4AF0)
+#define	TRAW_DMA_TNCSO_T1_ADDR		(0x4BA0)
+#define	TRAW_DMA_RZH1N2TO_T1_ADDR	(0x5000)
+#define	TRAW_DMA_DBGO_T1_ADDR		(0x51C0)
+
+/********************************************************************
+ * Enum Define
+ ********************************************************************/
+enum TRAWDmaDebugType {
+	TRAW_ORI_RDMA_DEBUG,
+	TRAW_ORI_RDMA_UFD_DEBUG,
+	TRAW_ORI_WDMA_DEBUG,
+	TRAW_ULC_RDMA_DEBUG,
+	TRAW_ULC_WDMA_DEBUG,
+};
+
+/********************************************************************
+ * Structure Define
+ ********************************************************************/
+struct TRAWDmaDebugInfo {
+	char DMAName[TRAW_DMA_NAME_MAX_SIZE];
+	enum TRAWDmaDebugType DMADebugType;
+};
+
+//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+// Public Functions
+//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+void imgsys_traw_set_initial_value(struct mtk_imgsys_dev *imgsys_dev);
+void imgsys_traw_set_initial_value_hw(struct mtk_imgsys_dev *imgsys_dev);
+void imgsys_traw_debug_dump(struct mtk_imgsys_dev *imgsys_dev,
+							unsigned int engine);
+void imgsys_traw_uninit(struct mtk_imgsys_dev *imgsys_dev);
+
+#endif /* _MTK_IMGSYS_TRAW_H_ */
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_71/modules/mtk_imgsys-wpe.c b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_71/modules/mtk_imgsys-wpe.c
new file mode 100644
index 0000000000000000000000000000000000000000..2ae8baa3e206bb13de8d73c1020738183a289c6f
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_71/modules/mtk_imgsys-wpe.c
@@ -0,0 +1,598 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2020 MediaTek Inc.
+ *
+ * Author: Floria Huang <floria.huang@mediatek.com>
+ *
+ */
+
+#include <linux/device.h>
+#include <linux/of_address.h>
+#include <dma-iommu.h>
+#include <linux/pm_runtime.h>
+#include <linux/remoteproc.h>
+
+//#include "iommu_debug.h"
+#ifdef WPE_TF_DUMP_71_1
+#include <dt-bindings/memory/mt6983-larb-port.h>
+
+#elif defined(WPE_TF_DUMP_71_2)
+#include <dt-bindings/memory/mt6879-larb-port.h>
+#endif
+
+#define M4U_PORT_DUMMY_EIS  (0)
+#define M4U_PORT_DUMMY_TNR  (1)
+#define M4U_PORT_DUMMY_LITE (2)
+
+#include "mtk_imgsys-wpe.h"
+
+#define WPE_A_BASE        (0x15200000)
+const unsigned int mtk_imgsys_wpe_base_ofst[] = {0x0, 0x300000, 0x400000};
+#define WPE_HW_NUM        ARRAY_SIZE(mtk_imgsys_wpe_base_ofst)
+
+//CTL_MOD_EN
+#define PQDIP_DL  0x40000
+#define DIP_DL    0x80000
+#define TRAW_DL   0x100000
+
+// for CQ_THR0_CTL ~ CQ_THR14CTL
+#define CQ_THRX_CTL_EN (1L << 0)
+#define CQ_THRX_CTL_MODE (1L << 4)//immediately mode
+#define CQ_THRX_CTL	(CQ_THRX_CTL_EN | CQ_THRX_CTL_MODE)
+
+// register ofst
+#define WPE_REG_DBG_SET     (0x48)
+#define WPE_REG_DBG_PORT    (0x4C)
+#define WPE_REG_CQ_THR0_CTL (0xB08)
+#define WPE_REG_CQ_THR1_CTL (0xB18)
+
+
+const struct mtk_imgsys_init_array
+			mtk_imgsys_wpe_init_ary[] = {
+	{0x0018, 0x80000000}, /* WPE_TOP_CTL_INT_EN, en w-clr */
+	{0x0024, 0xFFFFFFFF}, /* WPE_TOP_CTL_INT_STATUSX, w-clr */
+	{0x00D4, 0x80000000}, /* WPE_TOP_CQ_IRQ_EN, en w-clr */
+	{0x00DC, 0xFFFFFFFF}, /* WPE_TOP_CQ_IRQ_STX, w-clr */
+	{0x00E0, 0x80000000}, /* WPE_TOP_CQ_IRQ_EN2, en w-clr */
+	{0x00E8, 0xFFFFFFFF}, /* WPE_TOP_CQ_IRQ_STX2, w-clr */
+	{0x00EC, 0x80000000}, /* WPE_TOP_CQ_IRQ_EN3, en w-clr */
+	{0x00F4, 0xFFFFFFFF}, /* WPE_TOP_CQ_IRQ_STX3, w-clr */
+	{0x0204, 0x00000002}, /* WPE_CACHE_RWCTL_CTL */
+	{0x03D4, 0x80000000}, /* WPE_DMA_DMA_ERR_CTRL */
+	{0x0B08, CQ_THRX_CTL}, /*DIPCQ_W1A_DIPCQ_CQ_THR0_CTL */
+	{0x0B18, CQ_THRX_CTL}, /*DIPCQ_W1A_DIPCQ_CQ_THR1_CTL */
+	{0x0B28, CQ_THRX_CTL}, /*DIPCQ_W1A_DIPCQ_CQ_THR2_CTL */
+	{0x0B38, CQ_THRX_CTL}, /*DIPCQ_W1A_DIPCQ_CQ_THR3_CTL */
+	{0x0B48, CQ_THRX_CTL}, /*DIPCQ_W1A_DIPCQ_CQ_THR4_CTL */
+	{0x0B58, CQ_THRX_CTL}, /*DIPCQ_W1A_DIPCQ_CQ_THR5_CTL */
+	{0x0B68, CQ_THRX_CTL}, /*DIPCQ_W1A_DIPCQ_CQ_THR6_CTL */
+	{0x0B78, CQ_THRX_CTL}, /*DIPCQ_W1A_DIPCQ_CQ_THR7_CTL */
+	{0x0B88, CQ_THRX_CTL}, /*DIPCQ_W1A_DIPCQ_CQ_THR8_CTL */
+	{0x0B98, CQ_THRX_CTL}, /*DIPCQ_W1A_DIPCQ_CQ_THR9_CTL */
+	{0x0BA8, CQ_THRX_CTL}, /*DIPCQ_W1A_DIPCQ_CQ_THR10_CTL */
+	{0x0BB8, CQ_THRX_CTL}, /*DIPCQ_W1A_DIPCQ_CQ_THR11_CTL */
+	{0x0BC8, CQ_THRX_CTL}, /*DIPCQ_W1A_DIPCQ_CQ_THR12_CTL */
+	{0x0BD8, CQ_THRX_CTL}, /*DIPCQ_W1A_DIPCQ_CQ_THR13_CTL */
+	{0x0BE8, CQ_THRX_CTL}, /*DIPCQ_W1A_DIPCQ_CQ_THR14_CTL */
+};
+#define WPE_INIT_ARRAY_COUNT  ARRAY_SIZE(mtk_imgsys_wpe_init_ary)
+
+struct imgsys_reg_range {
+	uint32_t str;
+	uint32_t end;
+};
+const struct imgsys_reg_range wpe_regs[] = {
+	{0x0000, 0x0164}, /* TOP,VECI,VEC2I */
+	{0x0200, 0x027C}, /* CACHE */
+	{0x0300, 0x032C}, /* WPEO */
+	{0x0340, 0x0368}, /* WPEO2 */
+	{0x0380, 0x03A8}, /* MSKO */
+	{0x03C0, 0x0408}, /* DMA */
+	{0x0440, 0x0450}, /* TDRI */
+	{0x04C0, 0x0508}, /* VGEN */
+	{0x0540, 0x05D4}, /* PSP */
+	{0x0600, 0x0620}, /* C24,C02 */
+	{0x0640, 0x0654}, /* DL CROP */
+	{0x0680, 0x0694}, /* DMA CROP */
+	{0x06C0, 0x07B4}, /* DEC,PAK */
+	{0x07C0, 0x07D0}, /* TOP2 */
+	{0x0800, 0x080C},
+	{0x0B00, 0x0C34}, /* DIPCQ_W1 */
+};
+#define WPE_REG_ARRAY_COUNT	ARRAY_SIZE(wpe_regs)
+
+void __iomem *gWpeRegBA[WPE_HW_NUM] = {0L};
+
+int imgsys_wpe_tfault_callback(int port,
+	dma_addr_t mva, void *data)
+{
+	void __iomem *wpeRegBA = 0L;
+	unsigned int i, j;
+	unsigned int wpeBase = 0;
+	unsigned int engine;
+
+	pr_debug("%s: +\n", __func__);
+
+	switch (port) {
+#ifdef WPE_TF_DUMP_71_1
+	case M4U_PORT_L11_IMG2_WPE_RDMA0:
+	case M4U_PORT_L11_IMG2_WPE_RDMA1:
+	case M4U_PORT_L11_IMG2_WPE_RDMA_4P0:
+	case M4U_PORT_L11_IMG2_WPE_RDMA_4P1:
+	case M4U_PORT_L11_IMG2_WPE_WDMA0:
+	case M4U_PORT_L11_IMG2_WPE_WDMA_4P0:
+	case M4U_PORT_L11_IMG2_WPE_CQ0:
+	case M4U_PORT_L11_IMG2_WPE_CQ1:
+#elif defined(WPE_TF_DUMP_71_2)
+	case M4U_LARB11_PORT0:
+	case M4U_LARB11_PORT1:
+	case M4U_LARB11_PORT2:
+	case M4U_LARB11_PORT3:
+	case M4U_LARB11_PORT18:
+	case M4U_LARB11_PORT19:
+	case M4U_LARB11_PORT4:
+	case M4U_LARB11_PORT5:
+#else
+	case M4U_PORT_DUMMY_EIS:
+#endif
+		engine = REG_MAP_E_WPE_EIS;
+		break;
+#ifdef WPE_TF_DUMP_71_1
+	case M4U_PORT_L22_IMG2_WPE_RDMA0:
+	case M4U_PORT_L22_IMG2_WPE_RDMA1:
+	case M4U_PORT_L22_IMG2_WPE_RDMA_4P0:
+	case M4U_PORT_L22_IMG2_WPE_RDMA_4P1:
+	case M4U_PORT_L22_IMG2_WPE_WDMA0:
+	case M4U_PORT_L22_IMG2_WPE_WDMA_4P0:
+	case M4U_PORT_L22_IMG2_WPE_CQ0:
+	case M4U_PORT_L22_IMG2_WPE_CQ1:
+#elif defined(WPE_TF_DUMP_71_2)
+	case M4U_LARB22_PORT0:
+	case M4U_LARB22_PORT1:
+	case M4U_LARB22_PORT2:
+	case M4U_LARB22_PORT3:
+	case M4U_LARB22_PORT18:
+	case M4U_LARB22_PORT19:
+	case M4U_LARB22_PORT4:
+	case M4U_LARB22_PORT5:
+#else
+	case M4U_PORT_DUMMY_TNR:
+#endif
+		engine = REG_MAP_E_WPE_TNR;
+		break;
+#ifdef WPE_TF_DUMP_71_1
+	case M4U_PORT_L23_IMG2_WPE_RDMA0:
+	case M4U_PORT_L23_IMG2_WPE_RDMA1:
+	case M4U_PORT_L23_IMG2_WPE_RDMA_4P0:
+	case M4U_PORT_L23_IMG2_WPE_RDMA_4P1:
+	case M4U_PORT_L23_IMG2_WPE_WDMA0:
+	case M4U_PORT_L23_IMG2_WPE_WDMA_4P0:
+	case M4U_PORT_L23_IMG2_WPE_CQ0:
+	case M4U_PORT_L23_IMG2_WPE_CQ1:
+#elif defined(WPE_TF_DUMP_71_2)
+	case M4U_LARB23_PORT0:
+	case M4U_LARB23_PORT1:
+	case M4U_LARB23_PORT2:
+	case M4U_LARB23_PORT3:
+	case M4U_LARB23_PORT18:
+	case M4U_LARB23_PORT19:
+	case M4U_LARB23_PORT4:
+	case M4U_LARB23_PORT5:
+#else
+	case M4U_PORT_DUMMY_LITE:
+#endif
+		engine = REG_MAP_E_WPE_LITE;
+		break;
+	default:
+		pr_info("%s: TF port (%d) doesn't belongs to WPE.\n\n", __func__, port);
+		return 0;
+	};
+
+	/* iomap registers */
+	wpeRegBA = gWpeRegBA[engine - REG_MAP_E_WPE_EIS];
+	if (!wpeRegBA) {
+		pr_info("%s: WPE_%d, RegBA=0", __func__,
+			(engine - REG_MAP_E_WPE_EIS));
+		return 1;
+	}
+
+	pr_info("%s: ==== Dump WPE_%d, TF port: 0x%x =====",
+		__func__, (engine - REG_MAP_E_WPE_EIS), port);
+
+	//
+	wpeBase = WPE_A_BASE + mtk_imgsys_wpe_base_ofst[(engine - REG_MAP_E_WPE_EIS)];
+	for (j = 0; j < WPE_REG_ARRAY_COUNT; j++) {
+		for (i = wpe_regs[j].str; i <= wpe_regs[j].end; i += 0x10) {
+			pr_info("%s: [0x%08X] 0x%08X 0x%08X 0x%08X 0x%08X", __func__,
+				(unsigned int)(wpeBase + i),
+				(unsigned int)ioread32((void *)(wpeRegBA + i)),
+				(unsigned int)ioread32((void *)(wpeRegBA + i + 0x4)),
+				(unsigned int)ioread32((void *)(wpeRegBA + i + 0x8)),
+				(unsigned int)ioread32((void *)(wpeRegBA + i + 0xC)));
+		}
+	}
+
+	return 1;
+}
+
+void imgsys_wpe_set_initial_value(struct mtk_imgsys_dev *imgsys_dev)
+{
+	unsigned int hw_idx = 0, ary_idx = 0;
+
+	dev_dbg(imgsys_dev->dev, "%s: +\n", __func__);
+
+	for (hw_idx = REG_MAP_E_WPE_EIS; hw_idx <= REG_MAP_E_WPE_LITE; hw_idx++) {
+		/* iomap registers */
+		ary_idx = hw_idx - REG_MAP_E_WPE_EIS;
+		gWpeRegBA[ary_idx] = of_iomap(imgsys_dev->dev->of_node, hw_idx);
+		if (!gWpeRegBA[ary_idx]) {
+			dev_info(imgsys_dev->dev,
+				"%s: error: unable to iomap wpe_%d registers, devnode(%s).\n",
+				__func__, hw_idx, imgsys_dev->dev->of_node->name);
+			continue;
+		}
+	}
+
+#ifdef WPE_TF_DUMP_71_1
+	//wpe_eis
+	mtk_iommu_register_fault_callback(M4U_PORT_L11_IMG2_WPE_RDMA0,
+			(mtk_iommu_fault_callback_t)imgsys_wpe_tfault_callback,
+			NULL, false);
+	mtk_iommu_register_fault_callback(M4U_PORT_L11_IMG2_WPE_RDMA1,
+			(mtk_iommu_fault_callback_t)imgsys_wpe_tfault_callback,
+			NULL, false);
+	mtk_iommu_register_fault_callback(M4U_PORT_L11_IMG2_WPE_RDMA_4P0,
+			(mtk_iommu_fault_callback_t)imgsys_wpe_tfault_callback,
+			NULL, false);
+	mtk_iommu_register_fault_callback(M4U_PORT_L11_IMG2_WPE_RDMA_4P1,
+			(mtk_iommu_fault_callback_t)imgsys_wpe_tfault_callback,
+			NULL, 0);
+	mtk_iommu_register_fault_callback(M4U_PORT_L11_IMG2_WPE_WDMA0,
+			(mtk_iommu_fault_callback_t)imgsys_wpe_tfault_callback,
+			NULL, 0);
+	mtk_iommu_register_fault_callback(M4U_PORT_L11_IMG2_WPE_WDMA_4P0,
+			(mtk_iommu_fault_callback_t)imgsys_wpe_tfault_callback,
+			NULL, 0);
+	mtk_iommu_register_fault_callback(M4U_PORT_L11_IMG2_WPE_CQ0,
+			(mtk_iommu_fault_callback_t)imgsys_wpe_tfault_callback,
+			NULL, false);
+	mtk_iommu_register_fault_callback(M4U_PORT_L11_IMG2_WPE_CQ1,
+			(mtk_iommu_fault_callback_t)imgsys_wpe_tfault_callback,
+			NULL, false);
+	//wpe_tnr
+	mtk_iommu_register_fault_callback(M4U_PORT_L22_IMG2_WPE_RDMA0,
+			(mtk_iommu_fault_callback_t)imgsys_wpe_tfault_callback,
+			NULL, false);
+	mtk_iommu_register_fault_callback(M4U_PORT_L22_IMG2_WPE_RDMA1,
+			(mtk_iommu_fault_callback_t)imgsys_wpe_tfault_callback,
+			NULL, false);
+	mtk_iommu_register_fault_callback(M4U_PORT_L22_IMG2_WPE_RDMA_4P0,
+			(mtk_iommu_fault_callback_t)imgsys_wpe_tfault_callback,
+			NULL, false);
+	mtk_iommu_register_fault_callback(M4U_PORT_L22_IMG2_WPE_RDMA_4P1,
+			(mtk_iommu_fault_callback_t)imgsys_wpe_tfault_callback,
+			NULL, false);
+	mtk_iommu_register_fault_callback(M4U_PORT_L22_IMG2_WPE_WDMA0,
+			(mtk_iommu_fault_callback_t)imgsys_wpe_tfault_callback,
+			NULL, false);
+	mtk_iommu_register_fault_callback(M4U_PORT_L22_IMG2_WPE_WDMA_4P0,
+			(mtk_iommu_fault_callback_t)imgsys_wpe_tfault_callback,
+			NULL, false);
+	mtk_iommu_register_fault_callback(M4U_PORT_L22_IMG2_WPE_CQ0,
+			(mtk_iommu_fault_callback_t)imgsys_wpe_tfault_callback,
+			NULL, false);
+	mtk_iommu_register_fault_callback(M4U_PORT_L22_IMG2_WPE_CQ1,
+			(mtk_iommu_fault_callback_t)imgsys_wpe_tfault_callback,
+			NULL, false);
+	//wpe_lite
+	mtk_iommu_register_fault_callback(M4U_PORT_L23_IMG2_WPE_RDMA0,
+			(mtk_iommu_fault_callback_t)imgsys_wpe_tfault_callback,
+			NULL, false);
+	mtk_iommu_register_fault_callback(M4U_PORT_L23_IMG2_WPE_RDMA1,
+			(mtk_iommu_fault_callback_t)imgsys_wpe_tfault_callback,
+			NULL, false);
+	mtk_iommu_register_fault_callback(M4U_PORT_L23_IMG2_WPE_RDMA_4P0,
+			(mtk_iommu_fault_callback_t)imgsys_wpe_tfault_callback,
+			NULL, false);
+	mtk_iommu_register_fault_callback(M4U_PORT_L23_IMG2_WPE_RDMA_4P0,
+			(mtk_iommu_fault_callback_t)imgsys_wpe_tfault_callback,
+			NULL, false);
+	mtk_iommu_register_fault_callback(M4U_PORT_L23_IMG2_WPE_WDMA0,
+			(mtk_iommu_fault_callback_t)imgsys_wpe_tfault_callback,
+			NULL, false);
+	mtk_iommu_register_fault_callback(M4U_PORT_L23_IMG2_WPE_WDMA_4P0,
+			(mtk_iommu_fault_callback_t)imgsys_wpe_tfault_callback,
+			NULL, false);
+	mtk_iommu_register_fault_callback(M4U_PORT_L23_IMG2_WPE_CQ0,
+			(mtk_iommu_fault_callback_t)imgsys_wpe_tfault_callback,
+			NULL, false);
+	mtk_iommu_register_fault_callback(M4U_PORT_L23_IMG2_WPE_CQ1,
+			(mtk_iommu_fault_callback_t)imgsys_wpe_tfault_callback,
+			NULL, false);
+#elif defined(WPE_TF_DUMP_71_2)
+	//wpe_eis
+	mtk_iommu_register_fault_callback(M4U_LARB11_PORT0,
+			(mtk_iommu_fault_callback_t)imgsys_wpe_tfault_callback,
+			NULL, false);
+	mtk_iommu_register_fault_callback(M4U_LARB11_PORT1,
+			(mtk_iommu_fault_callback_t)imgsys_wpe_tfault_callback,
+			NULL, false);
+	mtk_iommu_register_fault_callback(M4U_LARB11_PORT2,
+			(mtk_iommu_fault_callback_t)imgsys_wpe_tfault_callback,
+			NULL, false);
+	mtk_iommu_register_fault_callback(M4U_LARB11_PORT3,
+			(mtk_iommu_fault_callback_t)imgsys_wpe_tfault_callback,
+			NULL, 0);
+	mtk_iommu_register_fault_callback(M4U_LARB11_PORT18,
+			(mtk_iommu_fault_callback_t)imgsys_wpe_tfault_callback,
+			NULL, 0);
+	mtk_iommu_register_fault_callback(M4U_LARB11_PORT19,
+			(mtk_iommu_fault_callback_t)imgsys_wpe_tfault_callback,
+			NULL, 0);
+	mtk_iommu_register_fault_callback(M4U_LARB11_PORT4,
+			(mtk_iommu_fault_callback_t)imgsys_wpe_tfault_callback,
+			NULL, false);
+	mtk_iommu_register_fault_callback(M4U_LARB11_PORT5,
+			(mtk_iommu_fault_callback_t)imgsys_wpe_tfault_callback,
+			NULL, false);
+	//wpe_tnr
+	mtk_iommu_register_fault_callback(M4U_LARB22_PORT0,
+			(mtk_iommu_fault_callback_t)imgsys_wpe_tfault_callback,
+			NULL, false);
+	mtk_iommu_register_fault_callback(M4U_LARB22_PORT1,
+			(mtk_iommu_fault_callback_t)imgsys_wpe_tfault_callback,
+			NULL, false);
+	mtk_iommu_register_fault_callback(M4U_LARB22_PORT2,
+			(mtk_iommu_fault_callback_t)imgsys_wpe_tfault_callback,
+			NULL, false);
+	mtk_iommu_register_fault_callback(M4U_LARB22_PORT3,
+			(mtk_iommu_fault_callback_t)imgsys_wpe_tfault_callback,
+			NULL, false);
+	mtk_iommu_register_fault_callback(M4U_LARB22_PORT18,
+			(mtk_iommu_fault_callback_t)imgsys_wpe_tfault_callback,
+			NULL, false);
+	mtk_iommu_register_fault_callback(M4U_LARB22_PORT19,
+			(mtk_iommu_fault_callback_t)imgsys_wpe_tfault_callback,
+			NULL, false);
+	mtk_iommu_register_fault_callback(M4U_LARB22_PORT4,
+			(mtk_iommu_fault_callback_t)imgsys_wpe_tfault_callback,
+			NULL, false);
+	mtk_iommu_register_fault_callback(M4U_LARB22_PORT5,
+			(mtk_iommu_fault_callback_t)imgsys_wpe_tfault_callback,
+			NULL, false);
+	//wpe_lite
+	mtk_iommu_register_fault_callback(M4U_LARB23_PORT0,
+			(mtk_iommu_fault_callback_t)imgsys_wpe_tfault_callback,
+			NULL, false);
+	mtk_iommu_register_fault_callback(M4U_LARB23_PORT1,
+			(mtk_iommu_fault_callback_t)imgsys_wpe_tfault_callback,
+			NULL, false);
+	mtk_iommu_register_fault_callback(M4U_LARB23_PORT2,
+			(mtk_iommu_fault_callback_t)imgsys_wpe_tfault_callback,
+			NULL, false);
+	mtk_iommu_register_fault_callback(M4U_LARB23_PORT23,
+			(mtk_iommu_fault_callback_t)imgsys_wpe_tfault_callback,
+			NULL, false);
+	mtk_iommu_register_fault_callback(M4U_LARB23_PORT18,
+			(mtk_iommu_fault_callback_t)imgsys_wpe_tfault_callback,
+			NULL, false);
+	mtk_iommu_register_fault_callback(M4U_LARB23_PORT19,
+			(mtk_iommu_fault_callback_t)imgsys_wpe_tfault_callback,
+			NULL, false);
+	mtk_iommu_register_fault_callback(M4U_LARB23_PORT4,
+			(mtk_iommu_fault_callback_t)imgsys_wpe_tfault_callback,
+			NULL, false);
+	mtk_iommu_register_fault_callback(M4U_LARB23_PORT5,
+			(mtk_iommu_fault_callback_t)imgsys_wpe_tfault_callback,
+			NULL, false);
+#endif
+
+	dev_dbg(imgsys_dev->dev, "%s: -\n", __func__);
+}
+EXPORT_SYMBOL(imgsys_wpe_set_initial_value);
+
+void imgsys_wpe_set_hw_initial_value(struct mtk_imgsys_dev *imgsys_dev)
+{
+	void __iomem *ofset = NULL;
+	unsigned int i = 0;
+	unsigned int hw_idx = 0, ary_idx = 0;
+
+	dev_dbg(imgsys_dev->dev, "%s: +\n", __func__);
+
+	for (hw_idx = REG_MAP_E_WPE_EIS; hw_idx <= REG_MAP_E_WPE_LITE; hw_idx++) {
+		/* iomap registers */
+		ary_idx = hw_idx - REG_MAP_E_WPE_EIS;
+		for (i = 0 ; i < WPE_INIT_ARRAY_COUNT ; i++) {
+			ofset = gWpeRegBA[ary_idx] + mtk_imgsys_wpe_init_ary[i].ofset;
+			writel(mtk_imgsys_wpe_init_ary[i].val, ofset);
+		}
+	}
+
+	dev_dbg(imgsys_dev->dev, "%s: -\n", __func__);
+}
+EXPORT_SYMBOL(imgsys_wpe_set_hw_initial_value);
+
+void imgsys_wpe_debug_dl_dump(struct mtk_imgsys_dev *imgsys_dev,
+							void __iomem *wpeRegBA)
+{
+	unsigned int dbg_sel_value[3] = {0x0, 0x0, 0x0};
+	unsigned int debug_value[3] = {0x0, 0x0, 0x0};
+	unsigned int sel_value[3] = {0x0, 0x0, 0x0};
+
+	dbg_sel_value[0] = (0xC << 12); //pqdip
+	dbg_sel_value[1] = (0xD << 12); //DIP
+	dbg_sel_value[2] = (0xE << 12); //TRAW
+
+	//line & pix cnt
+	writel((dbg_sel_value[0] | (0x1 << 8)), (wpeRegBA + WPE_REG_DBG_SET));
+	sel_value[0] = (unsigned int)ioread32((void *)(wpeRegBA + WPE_REG_DBG_SET));
+	debug_value[0] = (unsigned int)ioread32((void *)(wpeRegBA + WPE_REG_DBG_PORT));
+
+	writel((dbg_sel_value[1] | (0x1 << 8)), (wpeRegBA + WPE_REG_DBG_SET));
+	sel_value[1] = (unsigned int)ioread32((void *)(wpeRegBA + WPE_REG_DBG_SET));
+	debug_value[1] = (unsigned int)ioread32((void *)(wpeRegBA + WPE_REG_DBG_PORT));
+
+	writel((dbg_sel_value[2] | (0x1 << 8)), (wpeRegBA + WPE_REG_DBG_SET));
+	sel_value[2] = (unsigned int)ioread32((void *)(wpeRegBA + WPE_REG_DBG_SET));
+	debug_value[2] = (unsigned int)ioread32((void *)(wpeRegBA + WPE_REG_DBG_PORT));
+
+	dev_info(imgsys_dev->dev,
+	  "%s: [0x%x]dbg_sel,[0x%x](31:16)LnCnt(15:0)PixCnt: PQDIP[0x%x]0x%x, DIP[0x%x]0x%x, TRAW[0x%x]0x%x",
+	  __func__, WPE_REG_DBG_SET, WPE_REG_DBG_PORT,
+	  sel_value[0], debug_value[0], sel_value[1], debug_value[1],
+	  sel_value[2], debug_value[2]);
+
+	//req/rdy status (output)
+	writel((dbg_sel_value[0] | (0x0 << 8)), (wpeRegBA + WPE_REG_DBG_SET));
+	sel_value[0] = (unsigned int)ioread32((void *)(wpeRegBA + WPE_REG_DBG_SET));
+	debug_value[0] = (unsigned int)ioread32((void *)(wpeRegBA + WPE_REG_DBG_PORT));
+
+	writel((dbg_sel_value[1] | (0x0 << 8)), (wpeRegBA + WPE_REG_DBG_SET));
+	sel_value[1] = (unsigned int)ioread32((void *)(wpeRegBA + WPE_REG_DBG_SET));
+	debug_value[1] = (unsigned int)ioread32((void *)(wpeRegBA + WPE_REG_DBG_PORT));
+
+	writel((dbg_sel_value[2] | (0x0 << 8)), (wpeRegBA + WPE_REG_DBG_SET));
+	sel_value[2] = (unsigned int)ioread32((void *)(wpeRegBA + WPE_REG_DBG_SET));
+	debug_value[2] = (unsigned int)ioread32((void *)(wpeRegBA + WPE_REG_DBG_PORT));
+
+	dev_info(imgsys_dev->dev,
+	  "%s: [0x%x]dbg_sel,[0x%x]val/REQ/RDY: PQDIP[0x%x]0x%x/%d/%d, DIP[0x%x]0x%x/%d/%d, TRAW[0x%x]0x%x/%d/%d",
+	  __func__, WPE_REG_DBG_SET, WPE_REG_DBG_PORT,
+	  sel_value[0], debug_value[0],
+	   ((debug_value[0] >> 24) & 0x1), ((debug_value[0] >> 23) & 0x1),
+	  sel_value[1], debug_value[1],
+	   ((debug_value[1] >> 24) & 0x1), ((debug_value[1] >> 23) & 0x1),
+	  sel_value[2], debug_value[2],
+	   ((debug_value[2] >> 24) & 0x1), ((debug_value[2] >> 23) & 0x1));
+}
+
+void imgsys_wpe_debug_cq_dump(struct mtk_imgsys_dev *imgsys_dev,
+							void __iomem *wpeRegBA)
+{
+	unsigned int dbg_sel_value = 0x0;
+	unsigned int debug_value[5] = {0x0};
+	unsigned int sel_value[5] = {0x0};
+
+	debug_value[0] = (unsigned int)ioread32((void *)(wpeRegBA + WPE_REG_CQ_THR0_CTL));
+	debug_value[1] = (unsigned int)ioread32((void *)(wpeRegBA + WPE_REG_CQ_THR1_CTL));
+	if (!debug_value[0] || !debug_value[1]) {
+		dev_info(imgsys_dev->dev, "%s: No cq_thr enabled! cq0:0x%x, cq1:0x%x",
+			__func__, debug_value[0], debug_value[1]);
+		return;
+	}
+
+	dbg_sel_value = (0x18 << 12);//cq_p2_eng
+
+	//line & pix cnt
+	writel((dbg_sel_value | 0x0), (wpeRegBA + WPE_REG_DBG_SET));
+	sel_value[0] = (unsigned int)ioread32((void *)(wpeRegBA + WPE_REG_DBG_SET));
+	debug_value[0] = (unsigned int)ioread32((void *)(wpeRegBA + WPE_REG_DBG_PORT));
+
+	writel((dbg_sel_value | 0x1), (wpeRegBA + WPE_REG_DBG_SET));
+	sel_value[1] = (unsigned int)ioread32((void *)(wpeRegBA + WPE_REG_DBG_SET));
+	debug_value[1] = (unsigned int)ioread32((void *)(wpeRegBA + WPE_REG_DBG_PORT));
+
+	writel((dbg_sel_value | 0x2), (wpeRegBA + WPE_REG_DBG_SET));
+	sel_value[2] = (unsigned int)ioread32((void *)(wpeRegBA + WPE_REG_DBG_SET));
+	debug_value[2] = (unsigned int)ioread32((void *)(wpeRegBA + WPE_REG_DBG_PORT));
+
+	writel((dbg_sel_value | 0x3), (wpeRegBA + WPE_REG_DBG_SET));
+	sel_value[3] = (unsigned int)ioread32((void *)(wpeRegBA + WPE_REG_DBG_SET));
+	debug_value[3] = (unsigned int)ioread32((void *)(wpeRegBA + WPE_REG_DBG_PORT));
+
+	writel((dbg_sel_value | 0x4), (wpeRegBA + WPE_REG_DBG_SET));
+	sel_value[4] = (unsigned int)ioread32((void *)(wpeRegBA + WPE_REG_DBG_SET));
+	debug_value[4] = (unsigned int)ioread32((void *)(wpeRegBA + WPE_REG_DBG_PORT));
+
+	dev_info(imgsys_dev->dev,
+		"%s: [0x%x]dbg_sel,[0x%x]cq_st[0x%x]0x%x, dma_dbg[0x%x]0x%x, dma_req[0x%x]0x%x, dma_rdy[0x%x]0x%x, dma_valid[0x%x]0x%x",
+		__func__, WPE_REG_DBG_SET, WPE_REG_DBG_PORT,
+		sel_value[0], debug_value[0], sel_value[1], debug_value[1],
+		sel_value[2], debug_value[2], sel_value[3], debug_value[3],
+		sel_value[4], debug_value[4]);
+}
+
+
+void imgsys_wpe_debug_dump(struct mtk_imgsys_dev *imgsys_dev,
+							unsigned int engine)
+{
+	void __iomem *wpeRegBA = 0L;
+	unsigned int i, j, ctl_en;
+	unsigned int hw_idx = 0, ofst_idx;
+	unsigned int wpeBase = 0;
+	unsigned int startHw = REG_MAP_E_WPE_EIS, endHW = REG_MAP_E_WPE_TNR;
+
+	dev_dbg(imgsys_dev->dev, "%s: +\n", __func__);
+
+	if ((engine & IMGSYS_ENG_WPE_EIS) && !(engine & IMGSYS_ENG_WPE_TNR))
+		endHW = REG_MAP_E_WPE_EIS;
+
+	if (!(engine & IMGSYS_ENG_WPE_EIS) && (engine & IMGSYS_ENG_WPE_TNR))
+		startHw = REG_MAP_E_WPE_TNR;
+
+	if ((engine & IMGSYS_ENG_WPE_LITE))
+		startHw = endHW = REG_MAP_E_WPE_LITE;
+
+
+	/* iomap registers */
+	for (hw_idx = startHw; hw_idx <= endHW; hw_idx++) {
+		ofst_idx = hw_idx - REG_MAP_E_WPE_EIS;
+		if (ofst_idx >= WPE_HW_NUM)
+			continue;
+
+		wpeBase = WPE_A_BASE + mtk_imgsys_wpe_base_ofst[ofst_idx];
+		wpeRegBA = gWpeRegBA[ofst_idx];
+		if (!wpeRegBA) {
+			dev_info(imgsys_dev->dev, "%s: WPE_%d, RegBA = 0", __func__, ofst_idx);
+			continue;
+		}
+		dev_info(imgsys_dev->dev, "%s: ==== Dump WPE_%d =====",
+		  __func__, ofst_idx);
+
+		//DL
+		ctl_en = (unsigned int)ioread32((void *)(wpeRegBA + 0x4));
+		if (ctl_en & (PQDIP_DL|DIP_DL|TRAW_DL)) {
+			dev_info(imgsys_dev->dev, "%s: WPE Done: %d", __func__,
+			  !(ioread32((void *)(wpeRegBA))) &&
+			  (ioread32((void *)(wpeRegBA + 0x24)) & 0x1));
+			dev_info(imgsys_dev->dev,
+			  "%s: WPE_DL: PQDIP(%d), DIP(%d), TRAW(%d)", __func__,
+			  (ctl_en & PQDIP_DL) > 0, (ctl_en & DIP_DL) > 0, (ctl_en & TRAW_DL) > 0);
+			imgsys_wpe_debug_dl_dump(imgsys_dev, wpeRegBA);
+		}
+
+		imgsys_wpe_debug_cq_dump(imgsys_dev, wpeRegBA);
+
+		//
+		for (j = 0; j < WPE_REG_ARRAY_COUNT; j++) {
+			for (i = wpe_regs[j].str; i <= wpe_regs[j].end; i += 0x10) {
+				dev_info(imgsys_dev->dev,
+					"%s: [0x%08X] 0x%08X 0x%08X 0x%08X 0x%08X", __func__,
+				(unsigned int)(wpeBase + i),
+				(unsigned int)ioread32((void *)(wpeRegBA + i)),
+				(unsigned int)ioread32((void *)(wpeRegBA + i + 0x4)),
+				(unsigned int)ioread32((void *)(wpeRegBA + i + 0x8)),
+				(unsigned int)ioread32((void *)(wpeRegBA + i + 0xC)));
+			}
+		}
+
+	}
+	//
+	dev_dbg(imgsys_dev->dev, "%s: -\n", __func__);
+}
+EXPORT_SYMBOL(imgsys_wpe_debug_dump);
+
+void imgsys_wpe_uninit(struct mtk_imgsys_dev *imgsys_dev)
+{
+	unsigned int i;
+
+	pr_debug("%s: +\n", __func__);
+
+	for (i = 0; i < WPE_HW_NUM; i++) {
+		iounmap(gWpeRegBA[i]);
+		gWpeRegBA[i] = 0L;
+	}
+
+	pr_debug("%s: -\n", __func__);
+}
+EXPORT_SYMBOL(imgsys_wpe_uninit);
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_71/modules/mtk_imgsys-wpe.h b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_71/modules/mtk_imgsys-wpe.h
new file mode 100644
index 0000000000000000000000000000000000000000..b38b3dc20df9dfe5669047f3b406dbe9d12e80ad
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_71/modules/mtk_imgsys-wpe.h
@@ -0,0 +1,21 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2020 MediaTek Inc.
+ *
+ * Author: Floria Huang <floria.huang@mediatek.com>
+ *
+ */
+
+#ifndef _MTK_IMGSYS_WPE_H_
+#define _MTK_IMGSYS_WPE_H_
+
+#include "mtk_imgsys-dev.h"
+#include "mtk_imgsys-cmdq.h"
+#include "mtk_imgsys-engine.h"
+
+void imgsys_wpe_set_initial_value(struct mtk_imgsys_dev *imgsys_dev);
+void imgsys_wpe_set_hw_initial_value(struct mtk_imgsys_dev *imgsys_dev);
+void imgsys_wpe_debug_dump(struct mtk_imgsys_dev *imgsys_dev,
+							unsigned int engine);
+void imgsys_wpe_uninit(struct mtk_imgsys_dev *imgsys_dev);
+#endif /* _MTK_IMGSYS_WPE_H_ */
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_71/modules/mtk_me_v4l2_vnode.h b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_71/modules/mtk_me_v4l2_vnode.h
new file mode 100644
index 0000000000000000000000000000000000000000..0d722da62dc6aaf0681d385ce7f9af5063fb8468
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_71/modules/mtk_me_v4l2_vnode.h
@@ -0,0 +1,453 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2018 MediaTek Inc.
+ *
+ * Author: Frederic Chen <frederic.chen@mediatek.com>
+ *
+ */
+
+#ifndef _MTK_ME_V4L2_VNODE_H_
+#define _MTK_ME_V4L2_VNODE_H_
+
+/*#include <linux/platform_device.h>
+ * #include <linux/module.h>
+ * #include <linux/of_device.h>
+ * #include <linux/pm_runtime.h>
+ * #include <linux/remoteproc.h>
+ * #include <linux/remoteproc/mtk_scp.h>
+ */
+#include <linux/videodev2.h>
+#include <media/videobuf2-dma-contig.h>
+#include <media/v4l2-ioctl.h>
+#include <media/v4l2-subdev.h>
+#include <media/v4l2-event.h>
+#include "mtk_imgsys-dev.h"
+#include "mtk_imgsys-hw.h"
+
+#include "mtk_imgsys_v4l2.h"
+#include "mtk_header_desc.h"
+
+#define defaultdesc 0
+
+
+static const struct mtk_imgsys_dev_format in_fmts[] = {
+	{
+		.format = V4L2_META_FMT_MTISP_DESC,
+		.num_planes = 1,
+#if defaultdesc
+		.depth	 = { 8 },
+		.row_depth = { 8 },
+		.num_cplanes = 1,
+#endif
+		.buffer_size = sizeof(struct header_desc),
+	},
+	{
+		.format = V4L2_META_FMT_MTISP_DESC_NORM,
+		.num_planes = 1,
+		.buffer_size = sizeof(struct header_desc_norm),
+	},
+};
+
+static const struct mtk_imgsys_dev_format out_fmts[] = {
+	{
+		.format = V4L2_META_FMT_MTISP_DESC,
+		.num_planes = 1,
+#if defaultdesc
+		.depth = { 8 },
+		.row_depth = { 8 },
+		.num_cplanes = 1,
+#endif
+		.buffer_size = sizeof(struct header_desc),
+	},
+	{
+		.format = V4L2_META_FMT_MTISP_DESC_NORM,
+		.num_planes = 1,
+		.buffer_size = sizeof(struct header_desc_norm),
+	},
+
+};
+
+static const struct v4l2_frmsizeenum in_frmsizeenum = {
+	.type = V4L2_FRMSIZE_TYPE_CONTINUOUS,
+	.stepwise.max_width = MTK_DIP_CAPTURE_MAX_WIDTH,
+	.stepwise.min_width = MTK_DIP_CAPTURE_MIN_WIDTH,
+	.stepwise.max_height = MTK_DIP_CAPTURE_MAX_HEIGHT,
+	.stepwise.min_height = MTK_DIP_CAPTURE_MIN_HEIGHT,
+	.stepwise.step_height = 1,
+	.stepwise.step_width = 1,
+};
+
+static const struct v4l2_frmsizeenum out_frmsizeenum = {
+	.type = V4L2_FRMSIZE_TYPE_CONTINUOUS,
+	.stepwise.max_width = MTK_DIP_OUTPUT_MAX_WIDTH,
+	.stepwise.min_width = MTK_DIP_OUTPUT_MIN_WIDTH,
+	.stepwise.max_height = MTK_DIP_OUTPUT_MAX_HEIGHT,
+	.stepwise.min_height = MTK_DIP_OUTPUT_MIN_HEIGHT,
+	.stepwise.step_height = 1,
+	.stepwise.step_width = 1,
+};
+
+static const struct mtk_imgsys_video_device_desc me_setting[] = {
+	{
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_MEL0IMG0_OUT,
+		.name = "L0I0I Input",
+		.cap = V4L2_CAP_VIDEO_OUTPUT_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = in_fmts,
+		.num_fmts = ARRAY_SIZE(in_fmts),
+		.default_fmt_idx = 4,
+		.default_width = MTK_DIP_OUTPUT_MAX_WIDTH,
+		.default_height = MTK_DIP_OUTPUT_MAX_HEIGHT,
+		.dma_port = 0,
+		.frmsizeenum = &in_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_out_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "ME Input",
+	},
+	{
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_MEL0IMG1_OUT,
+		.name = "L0I1I Input",
+		.cap = V4L2_CAP_VIDEO_OUTPUT_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = in_fmts,
+		.num_fmts = ARRAY_SIZE(in_fmts),
+		.default_fmt_idx = 4,
+		.default_width = MTK_DIP_OUTPUT_MAX_WIDTH,
+		.default_height = MTK_DIP_OUTPUT_MAX_HEIGHT,
+		.dma_port = 0,
+		.frmsizeenum = &in_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_out_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "ME Input",
+	},
+	{
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_MEL1IMG0_OUT,
+		.name = "L1I0I Input",
+		.cap = V4L2_CAP_VIDEO_OUTPUT_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = in_fmts,
+		.num_fmts = ARRAY_SIZE(in_fmts),
+		.default_fmt_idx = 4,
+		.default_width = MTK_DIP_OUTPUT_MAX_WIDTH,
+		.default_height = MTK_DIP_OUTPUT_MAX_HEIGHT,
+		.dma_port = 0,
+		.frmsizeenum = &in_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_out_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "ME L1 Input ",
+	},
+	{
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_MEL1IMG1_OUT,
+		.name = "L1I1I Input",
+		.cap = V4L2_CAP_VIDEO_OUTPUT_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = in_fmts,
+		.num_fmts = ARRAY_SIZE(in_fmts),
+		.default_fmt_idx = 4,
+		.default_width = MTK_DIP_OUTPUT_MAX_WIDTH,
+		.default_height = MTK_DIP_OUTPUT_MAX_HEIGHT,
+		.dma_port = 0,
+		.frmsizeenum = &in_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_out_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "ME L1 Input ",
+	},
+	{
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_MEIMGSTATS_OUT,
+		.name = "STATI Input",
+		.cap = V4L2_CAP_VIDEO_OUTPUT_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = in_fmts,
+		.num_fmts = ARRAY_SIZE(in_fmts),
+		.default_fmt_idx = 4,
+		.default_width = MTK_DIP_OUTPUT_MAX_WIDTH,
+		.default_height = MTK_DIP_OUTPUT_MAX_HEIGHT,
+		.dma_port = 0,
+		.frmsizeenum = &in_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_out_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "ME IMGSTATS Input ",
+	},
+	{
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_MEL0RMV_OUT,
+		.name = "L0RMVI Input",
+		.cap = V4L2_CAP_VIDEO_OUTPUT_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = in_fmts,
+		.num_fmts = ARRAY_SIZE(in_fmts),
+		.default_fmt_idx = 4,
+		.default_width = MTK_DIP_OUTPUT_MAX_WIDTH,
+		.default_height = MTK_DIP_OUTPUT_MAX_HEIGHT,
+		.dma_port = 0,
+		.frmsizeenum = &in_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_out_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "ME L0RMV Input ",
+	},
+	{
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_MEL1RMV_OUT,
+		.name = "L1RMVI Input",
+		.cap = V4L2_CAP_VIDEO_OUTPUT_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = in_fmts,
+		.num_fmts = ARRAY_SIZE(in_fmts),
+		.default_fmt_idx = 4,
+		.default_width = MTK_DIP_OUTPUT_MAX_WIDTH,
+		.default_height = MTK_DIP_OUTPUT_MAX_HEIGHT,
+		.dma_port = 0,
+		.frmsizeenum = &in_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_out_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "ME L1RMV Input ",
+	},
+	{
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_MEL0FMB_OUT,
+		.name = "L0FMBI Input",
+		.cap = V4L2_CAP_VIDEO_OUTPUT_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = in_fmts,
+		.num_fmts = ARRAY_SIZE(in_fmts),
+		.default_fmt_idx = 4,
+		.default_width = MTK_DIP_OUTPUT_MAX_WIDTH,
+		.default_height = MTK_DIP_OUTPUT_MAX_HEIGHT,
+		.dma_port = 0,
+		.frmsizeenum = &in_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_out_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "ME L0FMB Input ",
+	},
+	{
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_MEL1FMB_OUT,
+		.name = "L1FMBI Input",
+		.cap = V4L2_CAP_VIDEO_OUTPUT_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = in_fmts,
+		.num_fmts = ARRAY_SIZE(in_fmts),
+		.default_fmt_idx = 4,
+		.default_width = MTK_DIP_OUTPUT_MAX_WIDTH,
+		.default_height = MTK_DIP_OUTPUT_MAX_HEIGHT,
+		.dma_port = 0,
+		.frmsizeenum = &in_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_out_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "ME L1FMB Input ",
+	},
+	{
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_MEMIL_OUT,
+		.name = "MEMILI Input",
+		.cap = V4L2_CAP_VIDEO_OUTPUT_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = in_fmts,
+		.num_fmts = ARRAY_SIZE(in_fmts),
+		.default_fmt_idx = 4,
+		.default_width = MTK_DIP_OUTPUT_MAX_WIDTH,
+		.default_height = MTK_DIP_OUTPUT_MAX_HEIGHT,
+		.dma_port = 0,
+		.frmsizeenum = &in_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_out_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "ME MIL Input ",
+	},
+	{
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_MEMMGMIL_CAPTURE,
+		.name = "MILO Output",
+		.cap = V4L2_CAP_VIDEO_CAPTURE_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = out_fmts,
+		.num_fmts = ARRAY_SIZE(out_fmts),
+		.default_fmt_idx = 4,
+		.default_width = MTK_DIP_OUTPUT_MAX_WIDTH,
+		.default_height = MTK_DIP_OUTPUT_MAX_HEIGHT,
+		.dma_port = 0,
+		.frmsizeenum = &out_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_cap_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "ME MMGMIL Output ",
+	},
+	{
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_MEL0WMV_CAPTURE,
+		.name = "L0WMVO Output",
+		.cap = V4L2_CAP_VIDEO_CAPTURE_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = out_fmts,
+		.num_fmts = ARRAY_SIZE(out_fmts),
+		.default_fmt_idx = 4,
+		.default_width = MTK_DIP_OUTPUT_MAX_WIDTH,
+		.default_height = MTK_DIP_OUTPUT_MAX_HEIGHT,
+		.dma_port = 0,
+		.frmsizeenum = &out_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_cap_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "ME L0WMV Output ",
+	},
+	{
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_MEL1WMV_CAPTURE,
+		.name = "L1WMVO Output",
+		.cap = V4L2_CAP_VIDEO_CAPTURE_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = out_fmts,
+		.num_fmts = ARRAY_SIZE(out_fmts),
+		.default_fmt_idx = 4,
+		.default_width = MTK_DIP_OUTPUT_MAX_WIDTH,
+		.default_height = MTK_DIP_OUTPUT_MAX_HEIGHT,
+		.dma_port = 0,
+		.frmsizeenum = &out_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_cap_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "ME L1WMV Output ",
+	},
+	{
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_MECONF_CAPTURE,
+		.name = "CONFO Output",
+		.cap = V4L2_CAP_VIDEO_CAPTURE_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = out_fmts,
+		.num_fmts = ARRAY_SIZE(out_fmts),
+		.default_fmt_idx = 4,
+		.default_width = MTK_DIP_OUTPUT_MAX_WIDTH,
+		.default_height = MTK_DIP_OUTPUT_MAX_HEIGHT,
+		.dma_port = 0,
+		.frmsizeenum = &out_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_cap_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "ME CONF Output ",
+	},
+	{
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_MEWMAP_CAPTURE,
+		.name = "WMAPO Output",
+		.cap = V4L2_CAP_VIDEO_CAPTURE_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = out_fmts,
+		.num_fmts = ARRAY_SIZE(out_fmts),
+		.default_fmt_idx = 4,
+		.default_width = MTK_DIP_OUTPUT_MAX_WIDTH,
+		.default_height = MTK_DIP_OUTPUT_MAX_HEIGHT,
+		.dma_port = 0,
+		.frmsizeenum = &out_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_cap_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "ME WMAP Output ",
+	},
+	{
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_MEFMV_CAPTURE,
+		.name = "FMVO Output",
+		.cap = V4L2_CAP_VIDEO_CAPTURE_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = out_fmts,
+		.num_fmts = ARRAY_SIZE(out_fmts),
+		.default_fmt_idx = 4,
+		.default_width = MTK_DIP_OUTPUT_MAX_WIDTH,
+		.default_height = MTK_DIP_OUTPUT_MAX_HEIGHT,
+		.dma_port = 0,
+		.frmsizeenum = &out_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_cap_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "ME OTHERS Output ",
+	},
+	{
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_MEFST_CAPTURE,
+		.name = "FSTO Output",
+		.cap = V4L2_CAP_VIDEO_CAPTURE_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = out_fmts,
+		.num_fmts = ARRAY_SIZE(out_fmts),
+		.default_fmt_idx = 4,
+		.default_width = MTK_DIP_OUTPUT_MAX_WIDTH,
+		.default_height = MTK_DIP_OUTPUT_MAX_HEIGHT,
+		.dma_port = 0,
+		.frmsizeenum = &out_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_cap_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "ME FST Output ",
+	},
+	{
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_MELMI_CAPTURE,
+		.name = "LMIO Output",
+		.cap = V4L2_CAP_VIDEO_CAPTURE_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = out_fmts,
+		.num_fmts = ARRAY_SIZE(out_fmts),
+		.default_fmt_idx = 4,
+		.default_width = MTK_DIP_OUTPUT_MAX_WIDTH,
+		.default_height = MTK_DIP_OUTPUT_MAX_HEIGHT,
+		.dma_port = 0,
+		.frmsizeenum = &out_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_cap_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "ME LMI Output ",
+	},
+	{
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_MEL0WFMB_CAPTURE,
+		.name = "L0FMBO Output",
+		.cap = V4L2_CAP_VIDEO_CAPTURE_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = out_fmts,
+		.num_fmts = ARRAY_SIZE(out_fmts),
+		.default_fmt_idx = 4,
+		.default_width = MTK_DIP_OUTPUT_MAX_WIDTH,
+		.default_height = MTK_DIP_OUTPUT_MAX_HEIGHT,
+		.dma_port = 0,
+		.frmsizeenum = &out_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_cap_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "ME L0FMB Output ",
+	},
+	{
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_MEL1WFMB_CAPTURE,
+		.name = "L1FMBO Output",
+		.cap = V4L2_CAP_VIDEO_CAPTURE_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = out_fmts,
+		.num_fmts = ARRAY_SIZE(out_fmts),
+		.default_fmt_idx = 4,
+		.default_width = MTK_DIP_OUTPUT_MAX_WIDTH,
+		.default_height = MTK_DIP_OUTPUT_MAX_HEIGHT,
+		.dma_port = 0,
+		.frmsizeenum = &out_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_cap_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "ME L1FMB Output ",
+	},
+};
+
+#endif // _MTK_ME_V4L2_VNODE_H_
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_71/modules/mtk_pqdip_v4l2_vnode.h b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_71/modules/mtk_pqdip_v4l2_vnode.h
new file mode 100644
index 0000000000000000000000000000000000000000..004ee840ea9a961447af1a39d8462b470bd2ba4a
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_71/modules/mtk_pqdip_v4l2_vnode.h
@@ -0,0 +1,336 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2020 MediaTek Inc.
+ *
+ * Author: Daniel Huang <daniel.huang@mediatek.com>
+ *
+ */
+
+#ifndef _MTK_PQDIP_V4L2_VNODE_H_
+#define _MTK_PQDIP_V4L2_VNODE_H_
+
+#include <linux/videodev2.h>
+#include <media/videobuf2-dma-contig.h>
+#include <media/v4l2-ioctl.h>
+#include <media/v4l2-subdev.h>
+#include <media/v4l2-event.h>
+#include "mtk_imgsys-dev.h"
+#include "mtk_imgsys-hw.h"
+
+#include "mtk_imgsys_v4l2.h"
+#include "mtk_header_desc.h"
+
+#define defaultdesc 0
+
+#define MTK_PQDIP_OUTPUT_MIN_WIDTH		2U
+#define MTK_PQDIP_OUTPUT_MIN_HEIGHT		2U
+#define MTK_PQDIP_OUTPUT_MAX_WIDTH		5376U
+#define MTK_PQDIP_OUTPUT_MAX_HEIGHT		4032U
+#define MTK_PQDIP_CAPTURE_MIN_WIDTH		2U
+#define MTK_PQDIP_CAPTURE_MIN_HEIGHT		2U
+#define MTK_PQDIP_CAPTURE_MAX_WIDTH		5376U
+#define MTK_PQDIP_CAPTURE_MAX_HEIGHT		4032U
+
+static const struct mtk_imgsys_dev_format pqdip_pimgi_fmts[] = {
+	{
+		.format = V4L2_PIX_FMT_VYUY,
+		.depth	 = { 16 },
+		.row_depth = { 16 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+	},
+	{
+		.format = V4L2_PIX_FMT_YUYV,
+		.depth	 = { 16 },
+		.row_depth = { 16 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+	},
+	{
+		.format = V4L2_PIX_FMT_YVYU,
+		.depth	 = { 16 },
+		.row_depth = { 16 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+	},
+	{
+		.format = V4L2_PIX_FMT_NV12,
+		.depth = { 12 },
+		.row_depth = { 8 },
+		.num_planes = 1,
+		.num_cplanes = 2,
+	},
+	{
+		.format	= V4L2_PIX_FMT_YUV420M,
+		.depth		= { 8, 2, 2 },
+		.row_depth	= { 8, 4, 4 },
+		.num_planes	= 3,
+		.num_cplanes = 1,
+	},
+	{
+		.format	= V4L2_PIX_FMT_YVU420M,
+		.depth		= { 8, 2, 2 },
+		.row_depth	= { 8, 4, 4 },
+		.num_planes	= 3,
+		.num_cplanes = 1,
+	},
+	{
+		.format	= V4L2_PIX_FMT_NV12M,
+		.depth		= { 8, 4 },
+		.row_depth	= { 8, 8 },
+		.num_planes	= 2,
+		.num_cplanes = 1,
+	},
+	{	// Must have for SMVR/Multis-cale for every video_device nodes
+		.format = V4L2_META_FMT_MTISP_DESC,
+		.num_planes = 1,
+#if defaultdesc
+		.depth = { 8 },
+		.row_depth = { 8 },
+		.num_cplanes = 1,
+#endif
+		.buffer_size = sizeof(struct header_desc),
+	},
+	{
+		.format = V4L2_META_FMT_MTISP_SD,
+		.num_planes = 1,
+#if defaultdesc
+		.depth = { 8 },
+		.row_depth = { 8 },
+		.num_cplanes = 1,
+#endif
+		.buffer_size = sizeof(struct singlenode_desc),
+	},
+	{
+		.format = V4L2_META_FMT_MTISP_DESC_NORM,
+		.num_planes = 1,
+		.buffer_size = sizeof(struct header_desc_norm),
+	},
+
+};
+
+static const struct mtk_imgsys_dev_format pqdip_wroto_fmts[] = {
+	{
+		.format = V4L2_PIX_FMT_VYUY,
+		.depth = { 16 },
+		.row_depth = { 16 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+		.pass_1_align = 4,
+	},
+	{
+		.format = V4L2_PIX_FMT_YUYV,
+		.depth = { 16 },
+		.row_depth = { 16 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+		.pass_1_align = 4,
+	},
+	{
+		.format = V4L2_PIX_FMT_YVYU,
+		.depth = { 16 },
+		.row_depth = { 16 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+		.pass_1_align = 4,
+	},
+	{
+		.format = V4L2_PIX_FMT_YVU420,
+		.depth = { 12 },
+		.row_depth = { 8 },
+		.num_planes = 1,
+		.num_cplanes = 3,
+		.pass_1_align = 4,
+	},
+	{
+		.format = V4L2_PIX_FMT_NV12,
+		.depth = { 12 },
+		.row_depth = { 8 },
+		.num_planes = 1,
+		.num_cplanes = 2,
+		.pass_1_align = 4,
+	},
+	{
+		.format	= V4L2_PIX_FMT_YUV420M,
+		.depth		= { 8, 2, 2 },
+		.row_depth	= { 8, 4, 4 },
+		.num_planes	= 3,
+		.num_cplanes = 1,
+		.pass_1_align = 4,
+	},
+	{
+		.format	= V4L2_PIX_FMT_YVU420M,
+		.depth		= { 8, 2, 2 },
+		.row_depth	= { 8, 4, 4 },
+		.num_planes	= 3,
+		.num_cplanes = 1,
+		.pass_1_align = 4,
+	},
+	{
+		.format	= V4L2_PIX_FMT_NV12M,
+		.depth		= { 8, 4 },
+		.row_depth	= { 8, 8 },
+		.num_planes	= 2,
+		.num_cplanes = 1,
+		.pass_1_align = 4,
+	},
+	{	// Must have for SMVR/Multis-cale for every video_device nodes
+		.format = V4L2_META_FMT_MTISP_DESC,
+		.num_planes = 1,
+#if defaultdesc
+		.depth = { 8 },
+		.row_depth = { 8 },
+		.num_cplanes = 1,
+#endif
+		.buffer_size = sizeof(struct header_desc),
+	},
+	{
+		.format = V4L2_META_FMT_MTISP_DESC_NORM,
+		.num_planes = 1,
+		.buffer_size = sizeof(struct header_desc_norm),
+	},
+
+};
+
+static const struct mtk_imgsys_dev_format pqdip_tccso_fmts[] = {
+	{
+		.format	= V4L2_PIX_FMT_GREY,
+		.depth		= { 8 },
+		.row_depth	= { 8 },
+		.num_planes	= 1,
+		.num_cplanes = 1,
+	},
+	{	// Must have for SMVR/Multis-cale for every video_device nodes
+		.format = V4L2_META_FMT_MTISP_DESC,
+		.num_planes = 1,
+#if defaultdesc
+		.depth = { 8 },
+		.row_depth = { 8 },
+		.num_cplanes = 1,
+#endif
+		.buffer_size = sizeof(struct header_desc),
+	},
+	{
+		.format = V4L2_META_FMT_MTISP_DESC_NORM,
+		.num_planes = 1,
+		.buffer_size = sizeof(struct header_desc_norm),
+	},
+
+};
+
+static const struct v4l2_frmsizeenum pqdip_in_frmsizeenum = {
+	.type = V4L2_FRMSIZE_TYPE_CONTINUOUS,
+	.stepwise.max_width = MTK_PQDIP_CAPTURE_MAX_WIDTH,
+	.stepwise.min_width = MTK_PQDIP_CAPTURE_MIN_WIDTH,
+	.stepwise.max_height = MTK_PQDIP_CAPTURE_MAX_HEIGHT,
+	.stepwise.min_height = MTK_PQDIP_CAPTURE_MIN_HEIGHT,
+	.stepwise.step_height = 1,
+	.stepwise.step_width = 1,
+};
+
+static const struct v4l2_frmsizeenum pqdip_out_frmsizeenum = {
+	.type = V4L2_FRMSIZE_TYPE_CONTINUOUS,
+	.stepwise.max_width = MTK_PQDIP_OUTPUT_MAX_WIDTH,
+	.stepwise.min_width = MTK_PQDIP_OUTPUT_MIN_WIDTH,
+	.stepwise.max_height = MTK_PQDIP_OUTPUT_MAX_HEIGHT,
+	.stepwise.min_height = MTK_PQDIP_OUTPUT_MIN_HEIGHT,
+	.stepwise.step_height = 1,
+	.stepwise.step_width = 1,
+};
+
+static const struct mtk_imgsys_video_device_desc pqdip_setting[] = {
+	/* Input Video Node */
+	{
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_PIMGI_OUT,
+		.name = "PIMGI Input",
+		.cap = V4L2_CAP_VIDEO_OUTPUT_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = pqdip_pimgi_fmts,
+		.num_fmts = ARRAY_SIZE(pqdip_pimgi_fmts),
+		.default_fmt_idx = 4,
+		.default_width = MTK_PQDIP_OUTPUT_MAX_WIDTH,
+		.default_height = MTK_PQDIP_OUTPUT_MAX_HEIGHT,
+		.dma_port = 0,
+		.frmsizeenum = &pqdip_in_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_out_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "Imgi image source",
+	},
+	/* Output Video Node */
+	{
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_WROT_A_CAPTURE,
+		.name = "WROTO A Output",
+		.cap = V4L2_CAP_VIDEO_CAPTURE_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = pqdip_wroto_fmts,
+		.num_fmts = ARRAY_SIZE(pqdip_wroto_fmts),
+		.default_fmt_idx = 1,
+		.default_width = MTK_PQDIP_CAPTURE_MAX_WIDTH,
+		.default_height = MTK_PQDIP_CAPTURE_MAX_WIDTH,
+		.dma_port = 0,
+		.frmsizeenum = &pqdip_out_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_cap_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "Output quality enhanced image",
+	},
+	{
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_WROT_B_CAPTURE,
+		.name = "WROTO B Output",
+		.cap = V4L2_CAP_VIDEO_CAPTURE_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = pqdip_wroto_fmts,
+		.num_fmts = ARRAY_SIZE(pqdip_wroto_fmts),
+		.default_fmt_idx = 1,
+		.default_width = MTK_PQDIP_CAPTURE_MAX_WIDTH,
+		.default_height = MTK_PQDIP_CAPTURE_MAX_WIDTH,
+		.dma_port = 1,
+		.frmsizeenum = &pqdip_out_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_cap_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "Output quality enhanced image",
+	},
+	{
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_TCCSO_A_CAPTURE,
+		.name = "TCCSO A Output",
+		.cap = V4L2_CAP_VIDEO_CAPTURE_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = pqdip_tccso_fmts,
+		.num_fmts = ARRAY_SIZE(pqdip_tccso_fmts),
+		.default_fmt_idx = 1,
+		.default_width = MTK_PQDIP_CAPTURE_MAX_WIDTH,
+		.default_height = MTK_PQDIP_CAPTURE_MAX_WIDTH,
+		.dma_port = 2,
+		.frmsizeenum = &pqdip_out_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_cap_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "Output tone curve statistics",
+	},
+	{
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_TCCSO_B_CAPTURE,
+		.name = "TCCSO B Output",
+		.cap = V4L2_CAP_VIDEO_CAPTURE_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = pqdip_tccso_fmts,
+		.num_fmts = ARRAY_SIZE(pqdip_tccso_fmts),
+		.default_fmt_idx = 1,
+		.default_width = MTK_PQDIP_CAPTURE_MAX_WIDTH,
+		.default_height = MTK_PQDIP_CAPTURE_MAX_WIDTH,
+		.dma_port = 3,
+		.frmsizeenum = &pqdip_out_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_cap_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "Output tone curve statistics",
+	},
+};
+
+#endif // _MTK_PQDIP_V4L2_VNODE_H_
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_71/modules/mtk_traw_v4l2_vnode.h b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_71/modules/mtk_traw_v4l2_vnode.h
new file mode 100644
index 0000000000000000000000000000000000000000..8caabc42527c25e09d8ab69249b2d8e6b2040d41
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_71/modules/mtk_traw_v4l2_vnode.h
@@ -0,0 +1,732 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2020 MediaTek Inc.
+ *
+ * Author: Shih-Fang chuang <shih-fang.chuang@mediatek.com>
+ *
+ */
+
+#ifndef _MTK_TRAW_V4L2_VNODE_H_
+#define _MTK_TRAW_V4L2_VNODE_H_
+
+#include <linux/videodev2.h>
+#include <media/videobuf2-dma-contig.h>
+#include <media/v4l2-ioctl.h>
+#include <media/v4l2-subdev.h>
+#include <media/v4l2-event.h>
+#include "mtk_imgsys-dev.h"
+#include "mtk_imgsys-hw.h"
+
+#include "mtk_imgsys_v4l2.h"
+#include "mtk_header_desc.h"
+
+#define defaultdesc 0
+
+#define MTK_TRAW_OUTPUT_MIN_WIDTH		2U
+#define MTK_TRAW_OUTPUT_MIN_HEIGHT		2U
+#define MTK_TRAW_OUTPUT_MAX_WIDTH		5376U
+#define MTK_TRAW_OUTPUT_MAX_HEIGHT		4032U
+#define MTK_TRAW_CAPTURE_MIN_WIDTH		2U
+#define MTK_TRAW_CAPTURE_MIN_HEIGHT		2U
+#define MTK_TRAW_CAPTURE_MAX_WIDTH		5376U
+#define MTK_TRAW_CAPTURE_MAX_HEIGHT		4032U
+
+static const struct mtk_imgsys_dev_format traw_imgi_fmts[] = {
+	{
+		.format = V4L2_PIX_FMT_VYUY,
+		.depth	 = { 16 },
+		.row_depth = { 16 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+	},
+	{
+		.format = V4L2_PIX_FMT_YUYV,
+		.depth	 = { 16 },
+		.row_depth = { 16 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+	},
+	{
+		.format = V4L2_PIX_FMT_YVYU,
+		.depth	 = { 16 },
+		.row_depth = { 16 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+	},
+	{
+		.format = V4L2_PIX_FMT_NV12,
+		.depth = { 12 },
+		.row_depth = { 8 },
+		.num_planes = 1,
+		.num_cplanes = 2,
+	},
+#if 0
+	{
+		.format = V4L2_PIX_FMT_MTISP_SBGGR8,
+		.depth = { 8 },
+		.row_depth = { 8 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+		.pass_1_align = 4,
+	},
+	{
+		.format = V4L2_PIX_FMT_MTISP_SGBRG8,
+		.depth = { 8 },
+		.row_depth = { 8 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+		.pass_1_align = 4,
+	},
+	{
+		.format = V4L2_PIX_FMT_MTISP_SGRBG8,
+		.depth = { 8 },
+		.row_depth = { 8 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+		.pass_1_align = 4,
+	},
+	{
+		.format = V4L2_PIX_FMT_MTISP_SRGGB8,
+		.depth = { 8 },
+		.row_depth = { 8 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+		.pass_1_align = 4,
+	},
+#endif
+	{
+		.format = V4L2_PIX_FMT_MTISP_SBGGR8F,
+		.depth = { 12 },
+		.row_depth = { 8},
+		.num_planes = 1,
+		.num_cplanes = 1,
+		.pass_1_align = 8,
+	},
+	{
+		.format = V4L2_PIX_FMT_MTISP_SGBRG8F,
+		.depth = { 12 },
+		.row_depth = { 8 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+		.pass_1_align = 8,
+	},
+	{
+		.format = V4L2_PIX_FMT_MTISP_SGRBG8F,
+		.depth = { 12 },
+		.row_depth = { 8 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+		.pass_1_align = 8,
+	},
+	{
+		.format = V4L2_PIX_FMT_MTISP_SRGGB8F,
+		.depth = { 12 },
+		.row_depth = { 8 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+		.pass_1_align = 8,
+	},
+	{
+		.format = V4L2_PIX_FMT_MTISP_SBGGR10,
+		.depth = { 10 },
+		.row_depth = { 10 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+		.pass_1_align = 4,
+	},
+	{
+		.format = V4L2_PIX_FMT_MTISP_SGBRG10,
+		.depth = { 10 },
+		.row_depth = { 10 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+		.pass_1_align = 4,
+	},
+	{
+		.format = V4L2_PIX_FMT_MTISP_SGRBG10,
+		.depth = { 10 },
+		.row_depth = { 10 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+		.pass_1_align = 4,
+	},
+	{
+		.format = V4L2_PIX_FMT_MTISP_SRGGB10,
+		.depth = { 10 },
+		.row_depth = { 10 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+		.pass_1_align = 4,
+	},
+	{
+		.format = V4L2_PIX_FMT_MTISP_SBGGR10F,
+		.depth = { 15 },
+		.row_depth = { 10 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+		.pass_1_align = 4,
+	},
+	{
+		.format = V4L2_PIX_FMT_MTISP_SGBRG10F,
+		.depth = { 15 },
+		.row_depth = { 10 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+		.pass_1_align = 4,
+	},
+	{
+		.format = V4L2_PIX_FMT_MTISP_SGRBG10F,
+		.depth = { 15 },
+		.row_depth = { 10 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+		.pass_1_align = 4,
+	},
+	{
+		.format = V4L2_PIX_FMT_MTISP_SRGGB10F,
+		.depth = { 15 },
+		.row_depth = { 10 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+		.pass_1_align = 4,
+	},
+	{
+		.format = V4L2_PIX_FMT_MTISP_SBGGR12,
+		.depth = { 12 },
+		.row_depth = { 12 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+		.pass_1_align = 4,
+	},
+	{
+		.format = V4L2_PIX_FMT_MTISP_SGBRG12,
+		.depth = { 12 },
+		.row_depth = { 12 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+		.pass_1_align = 4,
+	},
+	{
+		.format = V4L2_PIX_FMT_MTISP_SGRBG12,
+		.depth = { 12 },
+		.row_depth = { 12 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+		.pass_1_align = 4,
+	},
+	{
+		.format = V4L2_PIX_FMT_MTISP_SRGGB12,
+		.depth = { 12 },
+		.row_depth = { 12 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+		.pass_1_align = 4,
+	},
+	{
+		.format = V4L2_PIX_FMT_MTISP_SBGGR12F,
+		.depth = { 18 },
+		.row_depth = { 12 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+		.pass_1_align = 8,
+	},
+	{
+		.format = V4L2_PIX_FMT_MTISP_SGBRG12F,
+		.depth = { 18 },
+		.row_depth = { 12 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+		.pass_1_align = 8,
+	},
+	{
+		.format = V4L2_PIX_FMT_MTISP_SGRBG12F,
+		.depth = { 18 },
+		.row_depth = { 12 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+		.pass_1_align = 8,
+	},
+	{
+		.format = V4L2_PIX_FMT_MTISP_SRGGB12F,
+		.depth = { 18 },
+		.row_depth = { 12 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+		.pass_1_align = 8,
+	},
+	{
+		.format = V4L2_PIX_FMT_MTISP_SBGGR14F,
+		.depth = { 21 },
+		.row_depth = { 14 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+		.pass_1_align = 8,
+	},
+	{
+		.format = V4L2_PIX_FMT_MTISP_SGBRG14F,
+		.depth = { 21 },
+		.row_depth = { 14 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+		.pass_1_align = 8,
+	},
+	{
+		.format = V4L2_PIX_FMT_MTISP_SGRBG14F,
+		.depth = { 21 },
+		.row_depth = { 14 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+		.pass_1_align = 8,
+	},
+	{
+		.format = V4L2_PIX_FMT_MTISP_SRGGB14F,
+		.depth = { 21 },
+		.row_depth = { 14 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+		.pass_1_align = 8,
+	},
+	{
+		.format	= V4L2_PIX_FMT_YUV420M,
+		.depth		= { 8, 2, 2 },
+		.row_depth	= { 8, 4, 4 },
+		.num_planes	= 3,
+		.num_cplanes = 1,
+	},
+	{
+		.format	= V4L2_PIX_FMT_YVU420M,
+		.depth		= { 8, 2, 2 },
+		.row_depth	= { 8, 4, 4 },
+		.num_planes	= 3,
+		.num_cplanes = 1,
+	},
+	{
+		.format	= V4L2_PIX_FMT_NV12M,
+		.depth		= { 8, 4 },
+		.row_depth	= { 8, 8 },
+		.num_planes	= 2,
+		.num_cplanes = 1,
+	},
+	{	// Must have for SMVR/Multis-cale for every video_device nodes
+		.format = V4L2_META_FMT_MTISP_DESC,
+		.num_planes = 1,
+#if defaultdesc
+		.depth = { 8 },
+		.row_depth = { 8 },
+		.num_cplanes = 1,
+#endif
+		.buffer_size = sizeof(struct header_desc),
+	},
+	{
+		.format = V4L2_META_FMT_MTISP_SD,
+		.num_planes = 1,
+#if defaultdesc
+		.depth = { 8 },
+		.row_depth = { 8 },
+		.num_cplanes = 1,
+#endif
+		.buffer_size = sizeof(struct singlenode_desc),
+	},
+	{
+		.format = V4L2_META_FMT_MTISP_DESC_NORM,
+		.num_planes = 1,
+		.buffer_size = sizeof(struct header_desc_norm),
+	},
+
+};
+
+static const struct mtk_imgsys_dev_format traw_metai_fmts[] = {
+#if 0
+	{
+		.format = V4L2_PIX_FMT_MTISP_SBGGR8,
+		.depth = { 8 },
+		.row_depth = { 8 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+	},
+#endif
+	{	// Must have for SMVR/Multis-cale for every video_device nodes
+		.format = V4L2_META_FMT_MTISP_DESC,
+		.num_planes = 1,
+#if defaultdesc
+		.depth = { 8 },
+		.row_depth = { 8 },
+		.num_cplanes = 1,
+#endif
+		.buffer_size = sizeof(struct header_desc),
+	},
+	{
+		.format = V4L2_META_FMT_MTISP_DESC_NORM,
+		.num_planes = 1,
+		.buffer_size = sizeof(struct header_desc_norm),
+	},
+
+};
+
+static const struct mtk_imgsys_dev_format traw_yuvo_fmts[] = {
+	{
+		.format = V4L2_PIX_FMT_VYUY,
+		.depth = { 16 },
+		.row_depth = { 16 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+		.pass_1_align = 4,
+	},
+	{
+		.format = V4L2_PIX_FMT_YUYV,
+		.depth = { 16 },
+		.row_depth = { 16 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+		.pass_1_align = 4,
+	},
+	{
+		.format = V4L2_PIX_FMT_YVYU,
+		.depth = { 16 },
+		.row_depth = { 16 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+		.pass_1_align = 4,
+	},
+	{
+		.format = V4L2_PIX_FMT_YVU420,
+		.depth = { 12 },
+		.row_depth = { 8 },
+		.num_planes = 1,
+		.num_cplanes = 3,
+		.pass_1_align = 4,
+	},
+	{
+		.format = V4L2_PIX_FMT_NV12,
+		.depth = { 12 },
+		.row_depth = { 8 },
+		.num_planes = 1,
+		.num_cplanes = 2,
+		.pass_1_align = 4,
+	},
+	{	// Must have for SMVR/Multis-cale for every video_device nodes
+		.format = V4L2_META_FMT_MTISP_DESC,
+		.num_planes = 1,
+#if defaultdesc
+		.depth = { 8 },
+		.row_depth = { 8 },
+		.num_cplanes = 1,
+#endif
+		.buffer_size = sizeof(struct header_desc),
+	},
+	{
+		.format = V4L2_META_FMT_MTISP_DESC_NORM,
+		.num_planes = 1,
+		.buffer_size = sizeof(struct header_desc_norm),
+	},
+
+};
+
+static const struct mtk_imgsys_dev_format traw_pdc_fmts[] = {
+	/* Y8 bit */
+	{
+		.format	= V4L2_PIX_FMT_GREY,
+		.depth		= { 8 },
+		.row_depth	= { 8 },
+		.num_planes	= 1,
+		.num_cplanes = 1,
+	},
+	/* Must have for SMVR/Multis-cale for every video_device nodes */
+	{
+		.format = V4L2_META_FMT_MTISP_DESC,
+		.num_planes = 1,
+#if defaultdesc
+		.depth = { 8 },
+		.row_depth = { 8 },
+		.num_cplanes = 1,
+#endif
+		.buffer_size = sizeof(struct header_desc),
+	},
+	{
+		.format = V4L2_META_FMT_MTISP_DESC_NORM,
+		.num_planes = 1,
+		.buffer_size = sizeof(struct header_desc_norm),
+	},
+
+};
+
+
+static const struct v4l2_frmsizeenum traw_in_frmsizeenum = {
+	.type = V4L2_FRMSIZE_TYPE_CONTINUOUS,
+	.stepwise.max_width = MTK_TRAW_CAPTURE_MAX_WIDTH,
+	.stepwise.min_width = MTK_TRAW_CAPTURE_MIN_WIDTH,
+	.stepwise.max_height = MTK_TRAW_CAPTURE_MAX_HEIGHT,
+	.stepwise.min_height = MTK_TRAW_CAPTURE_MIN_HEIGHT,
+	.stepwise.step_height = 1,
+	.stepwise.step_width = 1,
+};
+
+static const struct v4l2_frmsizeenum traw_out_frmsizeenum = {
+	.type = V4L2_FRMSIZE_TYPE_CONTINUOUS,
+	.stepwise.max_width = MTK_TRAW_OUTPUT_MAX_WIDTH,
+	.stepwise.min_width = MTK_TRAW_OUTPUT_MIN_WIDTH,
+	.stepwise.max_height = MTK_TRAW_OUTPUT_MAX_HEIGHT,
+	.stepwise.min_height = MTK_TRAW_OUTPUT_MIN_HEIGHT,
+	.stepwise.step_height = 1,
+	.stepwise.step_width = 1,
+};
+
+static const struct mtk_imgsys_video_device_desc traw_setting[] = {
+	/* Input Video Node */
+	{
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_TIMGI_OUT,
+		.name = "TIMGI Input",
+		.cap = V4L2_CAP_VIDEO_OUTPUT_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = traw_imgi_fmts,
+		.num_fmts = ARRAY_SIZE(traw_imgi_fmts),
+		.default_fmt_idx = 4,
+		.default_width = MTK_TRAW_OUTPUT_MAX_WIDTH,
+		.default_height = MTK_TRAW_OUTPUT_MAX_HEIGHT,
+		.dma_port = 0,
+		.frmsizeenum = &traw_in_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_out_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "Imgi image source",
+	},
+	{
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_METAI_OUT,
+		.name = "METAI Input",
+		.cap = V4L2_CAP_VIDEO_OUTPUT_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = traw_metai_fmts,
+		.num_fmts = ARRAY_SIZE(traw_metai_fmts),
+		.default_fmt_idx = 1,
+		.default_width = MTK_TRAW_CAPTURE_MAX_WIDTH,
+		.default_height = MTK_TRAW_CAPTURE_MAX_HEIGHT,
+		.dma_port = 1,
+		.frmsizeenum = &traw_in_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_out_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "METAI image source",
+	},
+	{
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_PDC_OUT,
+		.name = "PDC Input",
+		.cap = V4L2_CAP_VIDEO_OUTPUT_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = traw_pdc_fmts,
+		.num_fmts = ARRAY_SIZE(traw_pdc_fmts),
+		.default_fmt_idx = 1,
+		.default_width = MTK_TRAW_CAPTURE_MAX_WIDTH,
+		.default_height = MTK_TRAW_CAPTURE_MAX_HEIGHT,
+		.dma_port = 2,
+		.frmsizeenum = &traw_in_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_out_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "PDC image source",
+	},
+	/* Output Video Node */
+	{
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_TYUVO_CAPTURE,
+		.name = "TYUVO Output",
+		.cap = V4L2_CAP_VIDEO_CAPTURE_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = traw_yuvo_fmts,
+		.num_fmts = ARRAY_SIZE(traw_yuvo_fmts),
+		.default_fmt_idx = 1,
+		.default_width = MTK_TRAW_CAPTURE_MAX_WIDTH,
+		.default_height = MTK_TRAW_CAPTURE_MAX_WIDTH,
+		.dma_port = 0,
+		.frmsizeenum = &traw_out_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_cap_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "YUVO output",
+	},
+	{
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_TYUV2O_CAPTURE,
+		.name = "TYUV2O Output",
+		.cap = V4L2_CAP_VIDEO_CAPTURE_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = traw_yuvo_fmts,
+		.num_fmts = ARRAY_SIZE(traw_yuvo_fmts),
+		.default_fmt_idx = 1,
+		.default_width = MTK_TRAW_CAPTURE_MAX_WIDTH,
+		.default_height = MTK_TRAW_CAPTURE_MAX_WIDTH,
+		.dma_port = 1,
+		.frmsizeenum = &traw_out_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_cap_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "YUV2O output",
+	},
+	{
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_TYUV3O_CAPTURE,
+		.name = "TYUV3O Output",
+		.cap = V4L2_CAP_VIDEO_CAPTURE_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = traw_yuvo_fmts,
+		.num_fmts = ARRAY_SIZE(traw_yuvo_fmts),
+		.default_fmt_idx = 1,
+		.default_width = MTK_TRAW_CAPTURE_MAX_WIDTH,
+		.default_height = MTK_TRAW_CAPTURE_MAX_WIDTH,
+		.dma_port = 2,
+		.frmsizeenum = &traw_out_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_cap_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "YUV3O output",
+	},
+	{
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_TYUV4O_CAPTURE,
+		.name = "TYUV4O Output",
+		.cap = V4L2_CAP_VIDEO_CAPTURE_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = traw_yuvo_fmts,
+		.num_fmts = ARRAY_SIZE(traw_yuvo_fmts),
+		.default_fmt_idx = 1,
+		.default_width = MTK_TRAW_CAPTURE_MAX_WIDTH,
+		.default_height = MTK_TRAW_CAPTURE_MAX_WIDTH,
+		.dma_port = 3,
+		.frmsizeenum = &traw_out_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_cap_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "YUV4O output",
+	},
+	{
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_TYUV5O_CAPTURE,
+		.name = "TYUV5O Output",
+		.cap = V4L2_CAP_VIDEO_CAPTURE_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = traw_yuvo_fmts,
+		.num_fmts = ARRAY_SIZE(traw_yuvo_fmts),
+		.default_fmt_idx = 1,
+		.default_width = MTK_TRAW_CAPTURE_MAX_WIDTH,
+		.default_height = MTK_TRAW_CAPTURE_MAX_WIDTH,
+		.dma_port = 4,
+		.frmsizeenum = &traw_out_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_cap_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "YUV5O output",
+	},
+	{
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_FEO_CAPTURE,
+		.name = "FEO Output",
+		.cap = V4L2_CAP_VIDEO_CAPTURE_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = traw_metai_fmts,
+		.num_fmts = ARRAY_SIZE(traw_metai_fmts),
+		.default_fmt_idx = 1,
+		.default_width = MTK_TRAW_CAPTURE_MAX_WIDTH,
+		.default_height = MTK_TRAW_CAPTURE_MAX_WIDTH,
+		.dma_port = 5,
+		.frmsizeenum = &traw_out_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_cap_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "FEO output",
+	},
+	{
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_TIMGO_CAPTURE,
+		.name = "TIMGO Output",
+		.cap = V4L2_CAP_VIDEO_CAPTURE_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = traw_imgi_fmts,
+		.num_fmts = ARRAY_SIZE(traw_imgi_fmts),
+		.default_fmt_idx = 4,
+		.default_width = MTK_TRAW_CAPTURE_MAX_WIDTH,
+		.default_height = MTK_TRAW_CAPTURE_MAX_WIDTH,
+		.dma_port = 6,
+		.frmsizeenum = &traw_out_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_cap_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "TIMGO output",
+	},
+	{
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_IMGSTATO_CAPTURE,
+		.name = "IMGSTATO Output",
+		.cap = V4L2_CAP_VIDEO_CAPTURE_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = traw_metai_fmts,
+		.num_fmts = ARRAY_SIZE(traw_metai_fmts),
+		.default_fmt_idx = 1,
+		.default_width = MTK_TRAW_CAPTURE_MAX_WIDTH,
+		.default_height = MTK_TRAW_CAPTURE_MAX_WIDTH,
+		.dma_port = 7,
+		.frmsizeenum = &traw_out_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_cap_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "IMGSTATO output",
+	},
+	{
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_XTMEO_CAPTURE,
+		.name = "XTMEO Output",
+		.cap = V4L2_CAP_VIDEO_CAPTURE_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = traw_pdc_fmts,
+		.num_fmts = ARRAY_SIZE(traw_pdc_fmts),
+		.default_fmt_idx = 1,
+		.default_width = MTK_TRAW_CAPTURE_MAX_WIDTH,
+		.default_height = MTK_TRAW_CAPTURE_MAX_WIDTH,
+		.dma_port = 8,
+		.frmsizeenum = &traw_out_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_cap_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "XTMEO output",
+	},
+	{
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_XTFDO_CAPTURE,
+		.name = "XTFDO Output",
+		.cap = V4L2_CAP_VIDEO_CAPTURE_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = traw_yuvo_fmts,
+		.num_fmts = ARRAY_SIZE(traw_yuvo_fmts),
+		.default_fmt_idx = 1,
+		.default_width = MTK_TRAW_CAPTURE_MAX_WIDTH,
+		.default_height = MTK_TRAW_CAPTURE_MAX_WIDTH,
+		.dma_port = 9,
+		.frmsizeenum = &traw_out_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_cap_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "XTFDO output",
+	},
+	{
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_XTADLDBGO_CAPTURE,
+		.name = "XTDBGO Output",
+		.cap = V4L2_CAP_VIDEO_CAPTURE_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = traw_imgi_fmts,
+		.num_fmts = ARRAY_SIZE(traw_imgi_fmts),
+		.default_fmt_idx = 2,
+		.default_width = MTK_TRAW_CAPTURE_MAX_WIDTH,
+		.default_height = MTK_TRAW_CAPTURE_MAX_WIDTH,
+		.dma_port = 10,
+		.frmsizeenum = &traw_out_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_cap_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "XTDBGO output",
+	},
+
+};
+
+#endif // _MTK_TRAW_V4L2_VNODE_H_
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_71/modules/mtk_wpe_v4l2_vnode.h b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_71/modules/mtk_wpe_v4l2_vnode.h
new file mode 100644
index 0000000000000000000000000000000000000000..1a562ce95d5be108a5292016456aa0127ac533e1
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_71/modules/mtk_wpe_v4l2_vnode.h
@@ -0,0 +1,809 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2020 MediaTek Inc.
+ *
+ * Author: Floria Huang <floria.huang@mediatek.com>
+ *
+ */
+
+#ifndef _MTK_WPE_V4L2_VNODE_H_
+#define _MTK_WPE_V4L2_VNODE_H_
+
+/*#include <linux/platform_device.h>
+ * #include <linux/module.h>
+ * #include <linux/of_device.h>
+ * #include <linux/pm_runtime.h>
+ * #include <linux/remoteproc.h>
+ * #include <linux/remoteproc/mtk_scp.h>
+ */
+#include <linux/videodev2.h>
+#include <media/videobuf2-dma-contig.h>
+#include <media/v4l2-ioctl.h>
+#include <media/v4l2-subdev.h>
+#include <media/v4l2-event.h>
+#include "mtk_imgsys-dev.h"
+#include "mtk_imgsys-hw.h"
+
+#include "mtk_imgsys_v4l2.h"
+#include "mtk_header_desc.h"
+
+#define defaultdesc 0
+
+#define MTK_WPE_OUTPUT_MIN_WIDTH		2U
+#define MTK_WPE_OUTPUT_MIN_HEIGHT		2U
+#define MTK_WPE_OUTPUT_MAX_WIDTH		18472U
+#define MTK_WPE_OUTPUT_MAX_HEIGHT		13856U
+
+#define MTK_WPE_MAP_OUTPUT_MIN_WIDTH	2U
+#define MTK_WPE_MAP_OUTPUT_MIN_HEIGHT	2U
+#define MTK_WPE_MAP_OUTPUT_MAX_WIDTH	640U
+#define MTK_WPE_MAP_OUTPUT_MAX_HEIGHT	480U
+
+#define MTK_WPE_PSP_OUTPUT_WIDTH	    8U
+#define MTK_WPE_PSP_OUTPUT_HEIGHT	    33U
+
+#define MTK_WPE_CAPTURE_MIN_WIDTH		2U
+#define MTK_WPE_CAPTURE_MIN_HEIGHT		2U
+#define MTK_WPE_CAPTURE_MAX_WIDTH		18472U
+#define MTK_WPE_CAPTURE_MAX_HEIGHT		13856U
+
+
+static const struct mtk_imgsys_dev_format wpe_wpei_fmts[] = {
+	/* YUV422, 1 plane 8 bit */
+	{
+		.format = V4L2_PIX_FMT_UYVY,
+		.depth = { 16 },
+		.row_depth = { 16 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+	},
+	{
+		.format = V4L2_PIX_FMT_YUYV,
+		.depth = { 16 },
+		.row_depth = { 16 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+	},
+	{
+		.format = V4L2_PIX_FMT_YVYU,
+		.depth = { 16 },
+		.row_depth = { 16 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+	},
+	{
+		.format = V4L2_PIX_FMT_VYUY,
+		.depth = { 16 },
+		.row_depth = { 16 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+	},
+	/* YUV420, 2 plane 8 bit */
+	{
+		.format = V4L2_PIX_FMT_NV12,
+		.depth = { 12 },
+		.row_depth = { 8 },
+		.num_planes = 1,
+		.num_cplanes = 2,
+	},
+	{
+		.format = V4L2_PIX_FMT_NV12M,
+		.depth      = { 8, 4 },
+		.row_depth  = { 8, 8 },
+		.num_planes = 1,
+		.num_cplanes = 2,
+	},
+	{
+		.format = V4L2_PIX_FMT_NV21,
+		.depth = { 12 },
+		.row_depth = { 8 },
+		.num_planes = 1,
+		.num_cplanes = 2,
+	},
+	{
+		.format = V4L2_PIX_FMT_NV21M,
+		.depth      = { 8, 4 },
+		.row_depth  = { 8, 8 },
+		.num_planes = 1,
+		.num_cplanes = 2,
+	},
+	/* YUV420, 3 plane 8 bit */
+	{
+		.format	= V4L2_PIX_FMT_YUV420,
+		.depth		= { 12 },
+		.row_depth	= { 8 },
+		.num_planes	= 1,
+		.num_cplanes = 3,
+	},
+	{
+		.format	= V4L2_PIX_FMT_YVU420,
+		.depth		= { 12 },
+		.row_depth	= { 8 },
+		.num_planes	= 1,
+		.num_cplanes = 3,
+	},
+	/* Y8 bit */
+	{
+		.format	= V4L2_PIX_FMT_GREY,
+		.depth		= { 8 },
+		.row_depth	= { 8 },
+		.num_planes	= 1,
+		.num_cplanes = 1,
+	},
+	/* YUV422-10bit-1P-Packed */
+	{
+		.format	= V4L2_PIX_FMT_YUYV_Y210P,
+		.depth		= { 20 },
+		.row_depth	= { 10 },
+		.num_planes	= 1,
+		.num_cplanes = 1,
+	},
+	{
+		.format	= V4L2_PIX_FMT_YVYU_Y210P,
+		.depth		= { 20 },
+		.row_depth	= { 10 },
+		.num_planes	= 1,
+		.num_cplanes = 1,
+	},
+	{
+		.format	= V4L2_PIX_FMT_UYVY_Y210P,
+		.depth		= { 20 },
+		.row_depth	= { 10 },
+		.num_planes	= 1,
+		.num_cplanes = 1,
+	},
+	{
+		.format	= V4L2_PIX_FMT_VYUY_Y210P,
+		.depth		= { 20 },
+		.row_depth	= { 10 },
+		.num_planes	= 1,
+		.num_cplanes = 1,
+	},
+#if 0
+	/* Bayer 8 bit */
+	{
+		.format = V4L2_PIX_FMT_MTISP_SBGGR8,
+		.depth = { 8 },
+		.row_depth = { 8 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+		.pass_1_align = 64,//wpei, 64-pix align
+	},
+	{
+		.format = V4L2_PIX_FMT_MTISP_SGBRG8,
+		.depth = { 8 },
+		.row_depth = { 8 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+		.pass_1_align = 64,//wpei, 64-pix align
+	},
+	{
+		.format = V4L2_PIX_FMT_MTISP_SGRBG8,
+		.depth = { 8 },
+		.row_depth = { 8 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+		.pass_1_align = 64,//wpei, 64-pix align
+	},
+	{
+		.format = V4L2_PIX_FMT_MTISP_SRGGB8,
+		.depth = { 8 },
+		.row_depth = { 8 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+		.pass_1_align = 64,//wpei, 64-pix align
+	},
+#endif
+	/* Bayer 10 bit */
+	{
+		.format = V4L2_PIX_FMT_MTISP_SBGGR10,
+		.depth = { 10 },
+		.row_depth = { 10 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+		.pass_1_align = 80,//wpei, 64-pix align
+	},
+	{
+		.format = V4L2_PIX_FMT_MTISP_SGBRG10,
+		.depth = { 10 },
+		.row_depth = { 10 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+		.pass_1_align = 80,//wpei, 64-pix align
+	},
+	{
+		.format = V4L2_PIX_FMT_MTISP_SGRBG10,
+		.depth = { 10 },
+		.row_depth = { 10 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+		.pass_1_align = 80,//wpei, 64-pix align
+	},
+	{
+		.format = V4L2_PIX_FMT_MTISP_SRGGB10,
+		.depth = { 10 },
+		.row_depth = { 10 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+		.pass_1_align = 80,//wpei, 64-pix align
+	},
+	/* Bayer 12 bit */
+	{
+		.format = V4L2_PIX_FMT_MTISP_SBGGR12,
+		.depth = { 12 },
+		.row_depth = { 12 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+		.pass_1_align = 128,//wpei, 64-pix align
+	},
+	{
+		.format = V4L2_PIX_FMT_MTISP_SGBRG12,
+		.depth = { 12 },
+		.row_depth = { 12 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+		.pass_1_align = 128,//wpei, 64-pix align
+	},
+	{
+		.format = V4L2_PIX_FMT_MTISP_SGRBG12,
+		.depth = { 12 },
+		.row_depth = { 12 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+		.pass_1_align = 128,//wpei, 64-pix align
+	},
+	{
+		.format = V4L2_PIX_FMT_MTISP_SRGGB12,
+		.depth = { 12 },
+		.row_depth = { 12 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+		.pass_1_align = 128,//wpei, 64-pix align
+	},
+	/* Must have for SMVR/Multis-cale for every video_device nodes */
+	{
+		.format = V4L2_META_FMT_MTISP_DESC,
+		.num_planes = 1,
+#if defaultdesc
+		.depth = { 8 },
+		.row_depth = { 8 },
+		.num_cplanes = 1,
+#endif
+		.buffer_size = sizeof(struct header_desc),
+	},
+	{
+		.format = V4L2_META_FMT_MTISP_DESC_NORM,
+		.num_planes = 1,
+		.buffer_size = sizeof(struct header_desc_norm),
+	},
+
+};
+
+static const struct mtk_imgsys_dev_format wpe_veci_fmts[] = {
+	/* WarpMap, 2 plane, packed in 4-byte */
+	{
+		.format = V4L2_PIX_FMT_WARP2P,
+		.depth = { 32 },
+		.row_depth = { 32 },
+		.num_planes = 1,
+		.num_cplanes = 2,
+	},
+	/* Must have for SMVR/Multis-cale for every video_device nodes */
+	{
+		.format = V4L2_META_FMT_MTISP_DESC,
+		.num_planes = 1,
+#if defaultdesc
+		.depth = { 8 },
+		.row_depth = { 8 },
+		.num_cplanes = 1,
+#endif
+		.buffer_size = sizeof(struct header_desc),
+	},
+	{
+		.format = V4L2_META_FMT_MTISP_DESC_NORM,
+		.num_planes = 1,
+		.buffer_size = sizeof(struct header_desc_norm),
+	},
+
+};
+
+
+static const struct mtk_imgsys_dev_format wpe_pspi_fmts[] = {
+	{
+		.format = V4L2_PIX_FMT_GREY,
+		.depth = { 32 },
+		.row_depth = { 32 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+	},
+	/* Must have for SMVR/Multis-cale for every video_device nodes */
+	{
+		.format = V4L2_META_FMT_MTISP_DESC,
+		.num_planes = 1,
+#if defaultdesc
+		.depth = { 8 },
+		.row_depth = { 8 },
+		.num_cplanes = 1,
+#endif
+		.buffer_size = sizeof(struct header_desc),
+	},
+	{
+		.format = V4L2_META_FMT_MTISP_DESC_NORM,
+		.num_planes = 1,
+		.buffer_size = sizeof(struct header_desc_norm),
+	},
+
+};
+
+static const struct mtk_imgsys_dev_format wpe_wpeo_fmts[] = {
+	/* YUV422, 1 plane 8 bit */
+	{
+		.format = V4L2_PIX_FMT_UYVY,
+		.depth = { 16 },
+		.row_depth = { 16 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+	},
+	{
+		.format = V4L2_PIX_FMT_YUYV,
+		.depth = { 16 },
+		.row_depth = { 16 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+	},
+	{
+		.format = V4L2_PIX_FMT_YVYU,
+		.depth = { 16 },
+		.row_depth = { 16 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+	},
+	{
+		.format = V4L2_PIX_FMT_VYUY,
+		.depth = { 16 },
+		.row_depth = { 16 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+	},
+	/* YUV420, 2 plane 8 bit */
+	{
+		.format = V4L2_PIX_FMT_NV12,
+		.depth = { 12 },
+		.row_depth = { 8 },
+		.num_planes = 1,
+		.num_cplanes = 2,
+	},
+	{
+		.format = V4L2_PIX_FMT_NV12M,
+		.depth      = { 8, 4 },
+		.row_depth  = { 8, 8 },
+		.num_planes = 1,
+		.num_cplanes = 2,
+	},
+	{
+		.format = V4L2_PIX_FMT_NV21,
+		.depth = { 12 },
+		.row_depth = { 8 },
+		.num_planes = 1,
+		.num_cplanes = 2,
+	},
+	{
+		.format = V4L2_PIX_FMT_NV21M,
+		.depth      = { 8, 4 },
+		.row_depth  = { 8, 8 },
+		.num_planes = 1,
+		.num_cplanes = 2,
+	},
+	/* Y8 bit */
+	{
+		.format	= V4L2_PIX_FMT_GREY,
+		.depth		= { 8 },
+		.row_depth	= { 8 },
+		.num_planes	= 1,
+		.num_cplanes = 1,
+	},
+	/* YUV422-10bit-1P-Packed */
+	{
+		.format	= V4L2_PIX_FMT_YUYV_Y210P,
+		.depth		= { 20 },
+		.row_depth	= { 10 },
+		.num_planes	= 1,
+		.num_cplanes = 1,
+	},
+	{
+		.format	= V4L2_PIX_FMT_YVYU_Y210P,
+		.depth		= { 20 },
+		.row_depth	= { 10 },
+		.num_planes	= 1,
+		.num_cplanes = 1,
+	},
+	{
+		.format	= V4L2_PIX_FMT_UYVY_Y210P,
+		.depth		= { 20 },
+		.row_depth	= { 10 },
+		.num_planes	= 1,
+		.num_cplanes = 1,
+	},
+	{
+		.format	= V4L2_PIX_FMT_VYUY_Y210P,
+		.depth		= { 20 },
+		.row_depth	= { 10 },
+		.num_planes	= 1,
+		.num_cplanes = 1,
+	},
+#if 0
+	/* Bayer 8 bit */
+	{
+		.format = V4L2_PIX_FMT_MTISP_SBGGR8,
+		.depth = { 8 },
+		.row_depth = { 8 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+		.pass_1_align = 64,//wpei, 64-pix align
+	},
+	{
+		.format = V4L2_PIX_FMT_MTISP_SGBRG8,
+		.depth = { 8 },
+		.row_depth = { 8 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+		.pass_1_align = 64,//wpei, 64-pix align
+	},
+	{
+		.format = V4L2_PIX_FMT_MTISP_SGRBG8,
+		.depth = { 8 },
+		.row_depth = { 8 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+		.pass_1_align = 64,//wpei, 64-pix align
+	},
+	{
+		.format = V4L2_PIX_FMT_MTISP_SRGGB8,
+		.depth = { 8 },
+		.row_depth = { 8 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+		.pass_1_align = 64,//wpei, 64-pix align
+	},
+#endif
+	/* Bayer 10 bit */
+	{
+		.format = V4L2_PIX_FMT_MTISP_SBGGR10,
+		.depth = { 10 },
+		.row_depth = { 10 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+		.pass_1_align = 80,//wpei, 64-pix align
+	},
+	{
+		.format = V4L2_PIX_FMT_MTISP_SGBRG10,
+		.depth = { 10 },
+		.row_depth = { 10 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+		.pass_1_align = 80,//wpei, 64-pix align
+	},
+	{
+		.format = V4L2_PIX_FMT_MTISP_SGRBG10,
+		.depth = { 10 },
+		.row_depth = { 10 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+		.pass_1_align = 80,//wpei, 64-pix align
+	},
+	{
+		.format = V4L2_PIX_FMT_MTISP_SRGGB10,
+		.depth = { 10 },
+		.row_depth = { 10 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+		.pass_1_align = 80,//wpei, 64-pix align
+	},
+	/* Bayer 12 bit */
+	{
+		.format = V4L2_PIX_FMT_MTISP_SBGGR12,
+		.depth = { 12 },
+		.row_depth = { 12 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+		.pass_1_align = 128,//wpei, 64-pix align
+	},
+	{
+		.format = V4L2_PIX_FMT_MTISP_SGBRG12,
+		.depth = { 12 },
+		.row_depth = { 12 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+		.pass_1_align = 128,//wpei, 64-pix align
+	},
+	{
+		.format = V4L2_PIX_FMT_MTISP_SGRBG12,
+		.depth = { 12 },
+		.row_depth = { 12 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+		.pass_1_align = 128,//wpei, 64-pix align
+	},
+	{
+		.format = V4L2_PIX_FMT_MTISP_SRGGB12,
+		.depth = { 12 },
+		.row_depth = { 12 },
+		.num_planes = 1,
+		.num_cplanes = 1,
+		.pass_1_align = 128,//wpei, 64-pix align
+	},
+	/* Must have for SMVR/Multis-cale for every video_device nodes */
+	{
+		.format = V4L2_META_FMT_MTISP_DESC,
+		.num_planes = 1,
+#if defaultdesc
+		.depth = { 8 },
+		.row_depth = { 8 },
+		.num_cplanes = 1,
+#endif
+		.buffer_size = sizeof(struct header_desc),
+	},
+	{
+		.format = V4L2_META_FMT_MTISP_DESC_NORM,
+		.num_planes = 1,
+		.buffer_size = sizeof(struct header_desc_norm),
+	},
+
+};
+
+static const struct mtk_imgsys_dev_format wpe_msko_fmts[] = {
+	/* Y8 bit */
+	{
+		.format	= V4L2_PIX_FMT_GREY,
+		.depth		= { 8 },
+		.row_depth	= { 8 },
+		.num_planes	= 1,
+		.num_cplanes = 1,
+	},
+	/* Must have for SMVR/Multis-cale for every video_device nodes */
+	{
+		.format = V4L2_META_FMT_MTISP_DESC,
+		.num_planes = 1,
+#if defaultdesc
+		.depth = { 8 },
+		.row_depth = { 8 },
+		.num_cplanes = 1,
+#endif
+		.buffer_size = sizeof(struct header_desc),
+	},
+	{
+		.format = V4L2_META_FMT_MTISP_DESC_NORM,
+		.num_planes = 1,
+		.buffer_size = sizeof(struct header_desc_norm),
+	},
+
+};
+
+static const struct v4l2_frmsizeenum wpe_in_frmsizeenum = {
+	.type = V4L2_FRMSIZE_TYPE_CONTINUOUS,
+	.stepwise.max_width = MTK_WPE_CAPTURE_MAX_WIDTH,
+	.stepwise.min_width = MTK_WPE_CAPTURE_MIN_WIDTH,
+	.stepwise.max_height = MTK_WPE_CAPTURE_MAX_HEIGHT,
+	.stepwise.min_height = MTK_WPE_CAPTURE_MIN_HEIGHT,
+	.stepwise.step_height = 1,
+	.stepwise.step_width = 1,
+};
+
+static const struct v4l2_frmsizeenum wpe_in_map_frmsizeenum = {
+	.type = V4L2_FRMSIZE_TYPE_CONTINUOUS,
+	.stepwise.max_width = MTK_WPE_MAP_OUTPUT_MAX_WIDTH,
+	.stepwise.min_width = MTK_WPE_MAP_OUTPUT_MIN_WIDTH,
+	.stepwise.max_height = MTK_WPE_MAP_OUTPUT_MAX_HEIGHT,
+	.stepwise.min_height = MTK_WPE_MAP_OUTPUT_MIN_HEIGHT,
+	.stepwise.step_height = 1,
+	.stepwise.step_width = 1,
+};
+
+static const struct v4l2_frmsizeenum wpe_in_psp_frmsizeenum = {
+	.type = V4L2_FRMSIZE_TYPE_CONTINUOUS,
+	.stepwise.max_width = MTK_WPE_PSP_OUTPUT_WIDTH,
+	.stepwise.min_width = MTK_WPE_PSP_OUTPUT_WIDTH,
+	.stepwise.max_height = MTK_WPE_PSP_OUTPUT_HEIGHT,
+	.stepwise.min_height = MTK_WPE_PSP_OUTPUT_HEIGHT,
+	.stepwise.step_height = 1,
+	.stepwise.step_width = 1,
+};
+
+
+static const struct v4l2_frmsizeenum wpe_out_frmsizeenum = {
+	.type = V4L2_FRMSIZE_TYPE_CONTINUOUS,
+	.stepwise.max_width = MTK_WPE_OUTPUT_MAX_WIDTH,
+	.stepwise.min_width = MTK_WPE_OUTPUT_MIN_WIDTH,
+	.stepwise.max_height = MTK_WPE_OUTPUT_MAX_HEIGHT,
+	.stepwise.min_height = MTK_WPE_OUTPUT_MIN_HEIGHT,
+	.stepwise.step_height = 1,
+	.stepwise.step_width = 1,
+};
+
+static const struct mtk_imgsys_video_device_desc wpe_setting[] = {
+	/* Input Video Node */
+	{
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_WWPEI_OUT,
+		.name = "WPEI_E Input",
+		.cap = V4L2_CAP_VIDEO_OUTPUT_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = wpe_wpei_fmts,
+		.num_fmts = ARRAY_SIZE(wpe_wpei_fmts),
+		.default_fmt_idx = 4,
+		.default_width = MTK_WPE_OUTPUT_MAX_WIDTH,
+		.default_height = MTK_WPE_OUTPUT_MAX_HEIGHT,
+		.dma_port = 0,
+		.frmsizeenum = &wpe_in_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_out_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "WPE main image input",
+	},
+	{
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_WVECI_OUT,
+		.name = "VECI_E Input",
+		.cap = V4L2_CAP_VIDEO_OUTPUT_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = wpe_veci_fmts,
+		.num_fmts = ARRAY_SIZE(wpe_veci_fmts),
+		.default_fmt_idx = 1,
+		.default_width = MTK_WPE_CAPTURE_MAX_WIDTH,
+		.default_height = MTK_WPE_CAPTURE_MAX_HEIGHT,
+		.dma_port = 1,
+		.frmsizeenum = &wpe_in_map_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_out_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "WarpMap input",
+	},
+	{
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_WPSP_COEFI_OUT,
+		.name = "PSPI_E Input",
+		.cap = V4L2_CAP_VIDEO_OUTPUT_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = wpe_pspi_fmts,
+		.num_fmts = ARRAY_SIZE(wpe_pspi_fmts),
+		.default_fmt_idx = 1,
+		.default_width = MTK_WPE_CAPTURE_MAX_WIDTH,
+		.default_height = MTK_WPE_CAPTURE_MAX_HEIGHT,
+		.dma_port = 2,
+		.frmsizeenum = &wpe_in_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_out_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "PSP coef. table input",
+	},
+	/* WPE_EIS Output Video Node */
+	{
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_WWPEO_CAPTURE,
+		.name = "WPEO_E Output",
+		.cap = V4L2_CAP_VIDEO_CAPTURE_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = wpe_wpeo_fmts,
+		.num_fmts = ARRAY_SIZE(wpe_wpeo_fmts),
+		.default_fmt_idx = 0,
+		.default_width = MTK_WPE_CAPTURE_MAX_WIDTH,
+		.default_height = MTK_WPE_CAPTURE_MAX_HEIGHT,
+		.dma_port = 0,
+		.frmsizeenum = &wpe_out_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_cap_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "WPE image output",
+	},
+	{
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_WMSKO_CAPTURE,
+		.name = "MSKO_E Output",
+		.cap = V4L2_CAP_VIDEO_CAPTURE_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = wpe_msko_fmts,
+		.num_fmts = ARRAY_SIZE(wpe_msko_fmts),
+		.default_fmt_idx = 0,
+		.default_width = MTK_WPE_CAPTURE_MAX_WIDTH,
+		.default_height = MTK_WPE_CAPTURE_MAX_HEIGHT,
+		.dma_port = 1,
+		.frmsizeenum = &wpe_out_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_cap_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "WPE valid map output",
+	},
+	{
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_WTWPEI_OUT,
+		.name = "WPEI_T Input",
+		.cap = V4L2_CAP_VIDEO_OUTPUT_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = wpe_wpei_fmts,
+		.num_fmts = ARRAY_SIZE(wpe_wpei_fmts),
+		.default_fmt_idx = 4,
+		.default_width = MTK_WPE_OUTPUT_MAX_WIDTH,
+		.default_height = MTK_WPE_OUTPUT_MAX_HEIGHT,
+		.dma_port = 0,
+		.frmsizeenum = &wpe_in_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_out_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "WPE main image input",
+	},
+	{
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_WTVECI_OUT,
+		.name = "VECI_T Input",
+		.cap = V4L2_CAP_VIDEO_OUTPUT_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = wpe_veci_fmts,
+		.num_fmts = ARRAY_SIZE(wpe_veci_fmts),
+		.default_fmt_idx = 1,
+		.default_width = MTK_WPE_CAPTURE_MAX_WIDTH,
+		.default_height = MTK_WPE_CAPTURE_MAX_HEIGHT,
+		.dma_port = 1,
+		.frmsizeenum = &wpe_in_map_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_out_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "WarpMap input",
+	},
+	{
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_WTPSP_COEFI_OUT,
+		.name = "PSPI_T Input",
+		.cap = V4L2_CAP_VIDEO_OUTPUT_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = wpe_pspi_fmts,
+		.num_fmts = ARRAY_SIZE(wpe_pspi_fmts),
+		.default_fmt_idx = 1,
+		.default_width = MTK_WPE_CAPTURE_MAX_WIDTH,
+		.default_height = MTK_WPE_CAPTURE_MAX_HEIGHT,
+		.dma_port = 2,
+		.frmsizeenum = &wpe_in_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_out_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "PSP coef. table input",
+	},
+	/* WPE_TNR Output Video Node */
+	{
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_WTWPEO_CAPTURE,
+		.name = "WPEO_T Output",
+		.cap = V4L2_CAP_VIDEO_CAPTURE_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = wpe_wpeo_fmts,
+		.num_fmts = ARRAY_SIZE(wpe_wpeo_fmts),
+		.default_fmt_idx = 0,
+		.default_width = MTK_WPE_CAPTURE_MAX_WIDTH,
+		.default_height = MTK_WPE_CAPTURE_MAX_HEIGHT,
+		.dma_port = 0,
+		.frmsizeenum = &wpe_out_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_cap_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "WPE image output",
+	},
+	{
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_WTMSKO_CAPTURE,
+		.name = "MSKO_T Output",
+		.cap = V4L2_CAP_VIDEO_CAPTURE_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = wpe_msko_fmts,
+		.num_fmts = ARRAY_SIZE(wpe_msko_fmts),
+		.default_fmt_idx = 0,
+		.default_width = MTK_WPE_CAPTURE_MAX_WIDTH,
+		.default_height = MTK_WPE_CAPTURE_MAX_HEIGHT,
+		.dma_port = 1,
+		.frmsizeenum = &wpe_out_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_cap_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "WPE valid map output",
+	},
+};
+
+#endif // _MTK_WPE_V4L2_VNODE_H_
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_71/mtk_imgsys-cmdq-plat.h b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_71/mtk_imgsys-cmdq-plat.h
new file mode 100755
index 0000000000000000000000000000000000000000..df5c4e5c344eb2435b3c5de5d84d1041f43ac925
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_71/mtk_imgsys-cmdq-plat.h
@@ -0,0 +1,989 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2018 MediaTek Inc.
+ *
+ * Author: Daniel Huang <daniel.huang@mediatek.com>
+ *
+ */
+
+#ifndef _MTK_IMGSYS_CMDQ_PLAT_H_
+#define _MTK_IMGSYS_CMDQ_PLAT_H_
+
+#define IMGSYS_DVFS_ENABLE     (1)
+#define IMGSYS_QOS_ENABLE      (1)
+#define IMGSYS_QOS_SET_REAL    (0)
+#define IMGSYS_QOS_SET_BY_SCEN (1)
+
+#define IMGSYS_SECURE_ENABLE   (0)
+
+/* Record info definitions */
+#define GCE_REC_MAX_FRAME_BLOCK     (40)
+#define GCE_REC_MAX_TILE_BLOCK      (40)
+#define GCE_REC_MAX_LABEL_COUNT     (2048)
+
+#define IMGSYS_ENG_MAX 10
+#define IMGSYS_REG_START	0x15000000
+#define IMGSYS_REG_END		0x1570FFFF
+
+#define IMGSYS_CMD_MAX_SZ_N	0x9000
+#define IMGSYS_CMD_MAX_SZ_V	0x50000
+
+#define IMGSYS_NOR_THD 10
+
+#define IMGSYS_QOS_MAX 56
+#define IMGSYS_SEC_THD 2
+#define IMGSYS_MAX_FPS 60
+
+#define IMGSYS_VSS_FREQ_FLOOR	660000000
+#define IMGSYS_SMVR_FREQ_FLOOR	393000000
+
+#define IMGSYS_CMDQ_HW_EVENT_BEGIN	0
+#define IMGSYS_CMDQ_HW_EVENT_END	(IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_START - 1)
+#define IMGSYS_CMDQ_SW_EVENT_BEGIN	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_START
+#define IMGSYS_CMDQ_SW_EVENT_END	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_END
+
+#define IMGSYS_CMDQ_GPR_EVENT_BEGIN	999
+#define IMGSYS_CMDQ_GPR_EVENT_END	1008
+#define IMGSYS_CMDQ_SYNC_POOL_NUM	60
+
+#define WPE_SMI_PORT_NUM	8
+#define ME_SMI_PORT_NUM	2
+#define PQ_DIP_SMI_PORT_NUM	6
+#define TRAW_SMI_PORT_NUM	18
+#define LTRAW_SMI_PORT_NUM	7
+#define XTRAW_SMI_PORT_NUM	16
+#define DIP_SMI_PORT_NUM	39
+#define DIP0_SMI_PORT_NUM	20
+#define DIP1_SMI_PORT_NUM	19
+#define ADL_SMI_PORT_NUM	2
+
+#define IMGSYS_QOS_UPDATE_FREQ	1000
+#define IMGSYS_QOS_BLANK_INT	100
+#define IMGSYS_QOS_FACTOR		13
+#define IMGSYS_QOS_FHD_SIZE		(1920*1080/2)
+#define IMGSYS_QOS_4K_SIZE		(3840*2160/2)
+#define IMGSYS_QOS_FHD_30_BW_0	1320 //1328
+#define IMGSYS_QOS_FHD_30_BW_1	405 //905
+#define IMGSYS_QOS_FHD_60_BW_0	2458 //2458
+#define IMGSYS_QOS_FHD_60_BW_1	624 //1355
+#define IMGSYS_QOS_4K_30_BW_0	6000 //2350
+#define IMGSYS_QOS_4K_30_BW_1	1300 //1258
+#define IMGSYS_QOS_4K_60_BW_0	6000 //2244
+#define IMGSYS_QOS_4K_60_BW_1	1300 //2360
+#define IMGSYS_QOS_VSS_BW_0	10000
+#define IMGSYS_QOS_VSS_BW_1	0
+
+
+enum mtk_imgsys_event {
+	/* HW event */
+	IMGSYS_CMDQ_EVENT_IMG_TRAW0_CQ_THR_DONE_TRAW0_0 = 0,
+	IMGSYS_CMDQ_EVENT_IMG_TRAW0_CQ_THR_DONE_TRAW0_1,
+	IMGSYS_CMDQ_EVENT_IMG_TRAW0_CQ_THR_DONE_TRAW0_2,
+	IMGSYS_CMDQ_EVENT_IMG_TRAW0_CQ_THR_DONE_TRAW0_3,
+	IMGSYS_CMDQ_EVENT_IMG_TRAW0_CQ_THR_DONE_TRAW0_4,
+	IMGSYS_CMDQ_EVENT_IMG_TRAW0_CQ_THR_DONE_TRAW0_5,
+	IMGSYS_CMDQ_EVENT_IMG_TRAW0_CQ_THR_DONE_TRAW0_6,
+	IMGSYS_CMDQ_EVENT_IMG_TRAW0_CQ_THR_DONE_TRAW0_7,
+	IMGSYS_CMDQ_EVENT_IMG_TRAW0_CQ_THR_DONE_TRAW0_8,
+	IMGSYS_CMDQ_EVENT_IMG_TRAW0_CQ_THR_DONE_TRAW0_9,
+	IMGSYS_CMDQ_EVENT_IMG_TRAW1_CQ_THR_DONE_TRAW0_0,
+	IMGSYS_CMDQ_EVENT_IMG_TRAW1_CQ_THR_DONE_TRAW0_1,
+	IMGSYS_CMDQ_EVENT_IMG_TRAW1_CQ_THR_DONE_TRAW0_2,
+	IMGSYS_CMDQ_EVENT_IMG_TRAW1_CQ_THR_DONE_TRAW0_3,
+	IMGSYS_CMDQ_EVENT_IMG_TRAW1_CQ_THR_DONE_TRAW0_4,
+	IMGSYS_CMDQ_EVENT_IMG_TRAW1_CQ_THR_DONE_TRAW0_5,
+	IMGSYS_CMDQ_EVENT_IMG_TRAW1_CQ_THR_DONE_TRAW0_6,
+	IMGSYS_CMDQ_EVENT_IMG_TRAW1_CQ_THR_DONE_TRAW0_7,
+	IMGSYS_CMDQ_EVENT_IMG_TRAW1_CQ_THR_DONE_TRAW0_8,
+	IMGSYS_CMDQ_EVENT_IMG_TRAW1_CQ_THR_DONE_TRAW0_9,
+	IMGSYS_CMDQ_EVENT_IMG_XTRAW_CQ_THR_DONE_TRAW0_0,
+	IMGSYS_CMDQ_EVENT_IMG_XTRAW_CQ_THR_DONE_TRAW0_1,
+	IMGSYS_CMDQ_EVENT_IMG_XTRAW_CQ_THR_DONE_TRAW0_2,
+	IMGSYS_CMDQ_EVENT_IMG_XTRAW_CQ_THR_DONE_TRAW0_3,
+	IMGSYS_CMDQ_EVENT_IMG_XTRAW_CQ_THR_DONE_TRAW0_4,
+	IMGSYS_CMDQ_EVENT_IMG_XTRAW_CQ_THR_DONE_TRAW0_5,
+	IMGSYS_CMDQ_EVENT_IMG_XTRAW_CQ_THR_DONE_TRAW0_6,
+	IMGSYS_CMDQ_EVENT_IMG_XTRAW_CQ_THR_DONE_TRAW0_7,
+	IMGSYS_CMDQ_EVENT_IMG_XTRAW_CQ_THR_DONE_TRAW0_8,
+	IMGSYS_CMDQ_EVENT_IMG_XTRAW_CQ_THR_DONE_TRAW0_9,
+	IMGSYS_CMDQ_EVENT_IMG_DIP_CQ_THR_DONE_P2_0,
+	IMGSYS_CMDQ_EVENT_IMG_DIP_CQ_THR_DONE_P2_1,
+	IMGSYS_CMDQ_EVENT_IMG_DIP_CQ_THR_DONE_P2_2,
+	IMGSYS_CMDQ_EVENT_IMG_DIP_CQ_THR_DONE_P2_3,
+	IMGSYS_CMDQ_EVENT_IMG_DIP_CQ_THR_DONE_P2_4,
+	IMGSYS_CMDQ_EVENT_IMG_DIP_CQ_THR_DONE_P2_5,
+	IMGSYS_CMDQ_EVENT_IMG_DIP_CQ_THR_DONE_P2_6,
+	IMGSYS_CMDQ_EVENT_IMG_DIP_CQ_THR_DONE_P2_7,
+	IMGSYS_CMDQ_EVENT_IMG_DIP_CQ_THR_DONE_P2_8,
+	IMGSYS_CMDQ_EVENT_IMG_DIP_CQ_THR_DONE_P2_9,
+	IMGSYS_CMDQ_EVENT_IMG_PQDIP_A_CQ_THR_DONE_P2_0,
+	IMGSYS_CMDQ_EVENT_IMG_PQDIP_A_CQ_THR_DONE_P2_1,
+	IMGSYS_CMDQ_EVENT_IMG_PQDIP_A_CQ_THR_DONE_P2_2,
+	IMGSYS_CMDQ_EVENT_IMG_PQDIP_A_CQ_THR_DONE_P2_3,
+	IMGSYS_CMDQ_EVENT_IMG_PQDIP_A_CQ_THR_DONE_P2_4,
+	IMGSYS_CMDQ_EVENT_IMG_PQDIP_A_CQ_THR_DONE_P2_5,
+	IMGSYS_CMDQ_EVENT_IMG_PQDIP_A_CQ_THR_DONE_P2_6,
+	IMGSYS_CMDQ_EVENT_IMG_PQDIP_A_CQ_THR_DONE_P2_7,
+	IMGSYS_CMDQ_EVENT_IMG_PQDIP_A_CQ_THR_DONE_P2_8,
+	IMGSYS_CMDQ_EVENT_IMG_PQDIP_A_CQ_THR_DONE_P2_9,
+	IMGSYS_CMDQ_EVENT_IMG_PQDIP_B_CQ_THR_DONE_P2_0,
+	IMGSYS_CMDQ_EVENT_IMG_PQDIP_B_CQ_THR_DONE_P2_1,
+	IMGSYS_CMDQ_EVENT_IMG_PQDIP_B_CQ_THR_DONE_P2_2,
+	IMGSYS_CMDQ_EVENT_IMG_PQDIP_B_CQ_THR_DONE_P2_3,
+	IMGSYS_CMDQ_EVENT_IMG_PQDIP_B_CQ_THR_DONE_P2_4,
+	IMGSYS_CMDQ_EVENT_IMG_PQDIP_B_CQ_THR_DONE_P2_5,
+	IMGSYS_CMDQ_EVENT_IMG_PQDIP_B_CQ_THR_DONE_P2_6,
+	IMGSYS_CMDQ_EVENT_IMG_PQDIP_B_CQ_THR_DONE_P2_7,
+	IMGSYS_CMDQ_EVENT_IMG_PQDIP_B_CQ_THR_DONE_P2_8,
+	IMGSYS_CMDQ_EVENT_IMG_PQDIP_B_CQ_THR_DONE_P2_9,
+	IMGSYS_CMDQ_EVENT_IMG_WPE_EIS_CQ_THR_DONE_P2_0,
+	IMGSYS_CMDQ_EVENT_IMG_WPE_EIS_CQ_THR_DONE_P2_1,
+	IMGSYS_CMDQ_EVENT_IMG_WPE_EIS_CQ_THR_DONE_P2_2,
+	IMGSYS_CMDQ_EVENT_IMG_WPE_EIS_CQ_THR_DONE_P2_3,
+	IMGSYS_CMDQ_EVENT_IMG_WPE_EIS_CQ_THR_DONE_P2_4,
+	IMGSYS_CMDQ_EVENT_IMG_WPE_EIS_CQ_THR_DONE_P2_5,
+	IMGSYS_CMDQ_EVENT_IMG_WPE_EIS_CQ_THR_DONE_P2_6,
+	IMGSYS_CMDQ_EVENT_IMG_WPE_EIS_CQ_THR_DONE_P2_7,
+	IMGSYS_CMDQ_EVENT_IMG_WPE_EIS_CQ_THR_DONE_P2_8,
+	IMGSYS_CMDQ_EVENT_IMG_WPE_EIS_CQ_THR_DONE_P2_9,
+	IMGSYS_CMDQ_EVENT_IMG_WPE_TNR_CQ_THR_DONE_P2_0,
+	IMGSYS_CMDQ_EVENT_IMG_WPE_TNR_CQ_THR_DONE_P2_1,
+	IMGSYS_CMDQ_EVENT_IMG_WPE_TNR_CQ_THR_DONE_P2_2,
+	IMGSYS_CMDQ_EVENT_IMG_WPE_TNR_CQ_THR_DONE_P2_3,
+	IMGSYS_CMDQ_EVENT_IMG_WPE_TNR_CQ_THR_DONE_P2_4,
+	IMGSYS_CMDQ_EVENT_IMG_WPE_TNR_CQ_THR_DONE_P2_5,
+	IMGSYS_CMDQ_EVENT_IMG_WPE_TNR_CQ_THR_DONE_P2_6,
+	IMGSYS_CMDQ_EVENT_IMG_WPE_TNR_CQ_THR_DONE_P2_7,
+	IMGSYS_CMDQ_EVENT_IMG_WPE_TNR_CQ_THR_DONE_P2_8,
+	IMGSYS_CMDQ_EVENT_IMG_WPE_TNR_CQ_THR_DONE_P2_9,
+	IMGSYS_CMDQ_EVENT_IMG_WPE_LITE_CQ_THR_DONE_P2_0,
+	IMGSYS_CMDQ_EVENT_IMG_WPE_LITE_CQ_THR_DONE_P2_1,
+	IMGSYS_CMDQ_EVENT_IMG_WPE_LITE_CQ_THR_DONE_P2_2,
+	IMGSYS_CMDQ_EVENT_IMG_WPE_LITE_CQ_THR_DONE_P2_3,
+	IMGSYS_CMDQ_EVENT_IMG_WPE_LITE_CQ_THR_DONE_P2_4,
+	IMGSYS_CMDQ_EVENT_IMG_WPE_LITE_CQ_THR_DONE_P2_5,
+	IMGSYS_CMDQ_EVENT_IMG_WPE_LITE_CQ_THR_DONE_P2_6,
+	IMGSYS_CMDQ_EVENT_IMG_WPE_LITE_CQ_THR_DONE_P2_7,
+	IMGSYS_CMDQ_EVENT_IMG_WPE_LITE_CQ_THR_DONE_P2_8,
+	IMGSYS_CMDQ_EVENT_IMG_WPE_LITE_CQ_THR_DONE_P2_9,
+	IMGSYS_CMDQ_EVENT_IMG_IMGSYS_IPE_ME_DONE,
+	IMGSYS_CMDQ_EVENT_IMG_ADL_TILE_DONE_EVENT,
+	/* SW event */
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_START,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_WPE_EIS = IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_START,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_WPE_TNR,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_WPE_LITE,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_TRAW,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_LTRAW,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_XTRAW,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_DIP,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_PQDIP_A,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_PQDIP_B,
+	IMGSYS_CMDQ_SYNC_TOKEN_IPESYS_ME,
+	IMGSYS_CMDQ_SYNC_TOKEN_APUSYS_APU,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_VSS_TRAW,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_VSS_LTRAW,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_VSS_XTRAW,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_VSS_DIP,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_START,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_1 = IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_START,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_2,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_3,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_4,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_5,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_6,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_7,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_8,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_9,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_10,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_11,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_12,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_13,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_14,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_15,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_16,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_17,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_18,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_19,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_20,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_21,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_22,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_23,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_24,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_25,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_26,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_27,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_28,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_29,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_30,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_31,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_32,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_33,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_34,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_35,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_36,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_37,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_38,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_39,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_40,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_41,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_42,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_43,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_44,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_45,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_46,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_47,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_48,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_49,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_50,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_51,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_52,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_53,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_54,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_55,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_56,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_57,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_58,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_59,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_60,
+/*
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_61,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_62,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_63,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_64,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_65,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_66,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_67,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_68,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_69,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_70,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_71,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_72,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_73,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_74,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_75,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_76,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_77,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_78,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_79,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_80,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_81,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_82,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_83,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_84,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_85,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_86,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_87,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_88,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_89,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_90,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_91,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_92,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_93,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_94,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_95,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_96,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_97,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_98,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_99,
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_100,
+*/
+	IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_END = IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_60,
+	IMGSYS_CMDQ_SYNC_TOKEN_CAMSYS_POOL_1,
+	IMGSYS_CMDQ_SYNC_TOKEN_CAMSYS_POOL_2,
+	IMGSYS_CMDQ_SYNC_TOKEN_CAMSYS_POOL_3,
+	IMGSYS_CMDQ_SYNC_TOKEN_CAMSYS_POOL_4,
+	IMGSYS_CMDQ_SYNC_TOKEN_CAMSYS_POOL_5,
+	IMGSYS_CMDQ_SYNC_TOKEN_CAMSYS_POOL_6,
+	IMGSYS_CMDQ_SYNC_TOKEN_CAMSYS_POOL_7,
+	IMGSYS_CMDQ_SYNC_TOKEN_CAMSYS_POOL_8,
+	IMGSYS_CMDQ_SYNC_TOKEN_CAMSYS_POOL_9,
+	IMGSYS_CMDQ_SYNC_TOKEN_CAMSYS_POOL_10,
+	IMGSYS_CMDQ_SYNC_TOKEN_TZMP_ISP_WAIT,
+	IMGSYS_CMDQ_SYNC_TOKEN_TZMP_ISP_SET,
+	IMGSYS_CMDQ_SYNC_TOKEN_TZMP_ADL_WAIT,
+	IMGSYS_CMDQ_SYNC_TOKEN_TZMP_ADL_SET,
+	IMGSYS_CMDQ_EVENT_MAX
+};
+
+static struct imgsys_event_table imgsys_event[] = {
+	/*TRAW frame done*/
+	{IMGSYS_CMDQ_EVENT_IMG_TRAW0_CQ_THR_DONE_TRAW0_0, "traw_cq_thread0_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_TRAW0_CQ_THR_DONE_TRAW0_1, "traw_cq_thread1_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_TRAW0_CQ_THR_DONE_TRAW0_2, "traw_cq_thread2_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_TRAW0_CQ_THR_DONE_TRAW0_3, "traw_cq_thread3_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_TRAW0_CQ_THR_DONE_TRAW0_4, "traw_cq_thread4_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_TRAW0_CQ_THR_DONE_TRAW0_5, "traw_cq_thread5_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_TRAW0_CQ_THR_DONE_TRAW0_6, "traw_cq_thread6_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_TRAW0_CQ_THR_DONE_TRAW0_7, "traw_cq_thread7_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_TRAW0_CQ_THR_DONE_TRAW0_8, "traw_cq_thread8_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_TRAW0_CQ_THR_DONE_TRAW0_9, "traw_cq_thread9_frame_done"},
+	/*LTRAW frame done*/
+	{IMGSYS_CMDQ_EVENT_IMG_TRAW1_CQ_THR_DONE_TRAW0_0, "ltraw_cq_thread0_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_TRAW1_CQ_THR_DONE_TRAW0_1, "ltraw_cq_thread1_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_TRAW1_CQ_THR_DONE_TRAW0_2, "ltraw_cq_thread2_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_TRAW1_CQ_THR_DONE_TRAW0_3, "ltraw_cq_thread3_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_TRAW1_CQ_THR_DONE_TRAW0_4, "ltraw_cq_thread4_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_TRAW1_CQ_THR_DONE_TRAW0_5, "ltraw_cq_thread5_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_TRAW1_CQ_THR_DONE_TRAW0_6, "ltraw_cq_thread6_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_TRAW1_CQ_THR_DONE_TRAW0_7, "ltraw_cq_thread7_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_TRAW1_CQ_THR_DONE_TRAW0_8, "ltraw_cq_thread8_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_TRAW1_CQ_THR_DONE_TRAW0_9, "ltraw_cq_thread9_frame_done"},
+	/*XTRAW frame done*/
+	{IMGSYS_CMDQ_EVENT_IMG_XTRAW_CQ_THR_DONE_TRAW0_0, "xtraw_cq_thread0_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_XTRAW_CQ_THR_DONE_TRAW0_1, "xtraw_cq_thread1_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_XTRAW_CQ_THR_DONE_TRAW0_2, "xtraw_cq_thread2_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_XTRAW_CQ_THR_DONE_TRAW0_3, "xtraw_cq_thread3_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_XTRAW_CQ_THR_DONE_TRAW0_4, "xtraw_cq_thread4_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_XTRAW_CQ_THR_DONE_TRAW0_5, "xtraw_cq_thread5_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_XTRAW_CQ_THR_DONE_TRAW0_6, "xtraw_cq_thread6_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_XTRAW_CQ_THR_DONE_TRAW0_7, "xtraw_cq_thread7_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_XTRAW_CQ_THR_DONE_TRAW0_8, "xtraw_cq_thread8_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_XTRAW_CQ_THR_DONE_TRAW0_9, "xtraw_cq_thread9_frame_done"},
+	/*DIP frame done*/
+	{IMGSYS_CMDQ_EVENT_IMG_DIP_CQ_THR_DONE_P2_0, "dip_cq_thread0_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_DIP_CQ_THR_DONE_P2_1, "dip_cq_thread1_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_DIP_CQ_THR_DONE_P2_2, "dip_cq_thread2_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_DIP_CQ_THR_DONE_P2_3, "dip_cq_thread3_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_DIP_CQ_THR_DONE_P2_4, "dip_cq_thread4_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_DIP_CQ_THR_DONE_P2_5, "dip_cq_thread5_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_DIP_CQ_THR_DONE_P2_6, "dip_cq_thread6_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_DIP_CQ_THR_DONE_P2_7, "dip_cq_thread7_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_DIP_CQ_THR_DONE_P2_8, "dip_cq_thread8_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_DIP_CQ_THR_DONE_P2_9, "dip_cq_thread9_frame_done"},
+	/*PQ_DIP_A frame done*/
+	{IMGSYS_CMDQ_EVENT_IMG_PQDIP_A_CQ_THR_DONE_P2_0, "pqa_cq_thread0_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_PQDIP_A_CQ_THR_DONE_P2_1, "pqa_cq_thread1_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_PQDIP_A_CQ_THR_DONE_P2_2, "pqa_cq_thread2_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_PQDIP_A_CQ_THR_DONE_P2_3, "pqa_cq_thread3_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_PQDIP_A_CQ_THR_DONE_P2_4, "pqa_cq_thread4_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_PQDIP_A_CQ_THR_DONE_P2_5, "pqa_cq_thread5_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_PQDIP_A_CQ_THR_DONE_P2_6, "pqa_cq_thread6_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_PQDIP_A_CQ_THR_DONE_P2_7, "pqa_cq_thread7_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_PQDIP_A_CQ_THR_DONE_P2_8, "pqa_cq_thread8_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_PQDIP_A_CQ_THR_DONE_P2_9, "pqa_cq_thread9_frame_done"},
+	/*PQ_DIP_B frame done*/
+	{IMGSYS_CMDQ_EVENT_IMG_PQDIP_B_CQ_THR_DONE_P2_0, "pqb_cq_thread0_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_PQDIP_B_CQ_THR_DONE_P2_1, "pqb_cq_thread1_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_PQDIP_B_CQ_THR_DONE_P2_2, "pqb_cq_thread2_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_PQDIP_B_CQ_THR_DONE_P2_3, "pqb_cq_thread3_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_PQDIP_B_CQ_THR_DONE_P2_4, "pqb_cq_thread4_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_PQDIP_B_CQ_THR_DONE_P2_5, "pqb_cq_thread5_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_PQDIP_B_CQ_THR_DONE_P2_6, "pqb_cq_thread6_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_PQDIP_B_CQ_THR_DONE_P2_7, "pqb_cq_thread7_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_PQDIP_B_CQ_THR_DONE_P2_8, "pqb_cq_thread8_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_PQDIP_B_CQ_THR_DONE_P2_9, "pqb_cq_thread9_frame_done"},
+	/*WPE_EIS frame done*/
+	{IMGSYS_CMDQ_EVENT_IMG_WPE_EIS_CQ_THR_DONE_P2_0, "wpe_eis_cq_thread0_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_WPE_EIS_CQ_THR_DONE_P2_1, "wpe_eis_cq_thread1_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_WPE_EIS_CQ_THR_DONE_P2_2, "wpe_eis_cq_thread2_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_WPE_EIS_CQ_THR_DONE_P2_3, "wpe_eis_cq_thread3_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_WPE_EIS_CQ_THR_DONE_P2_4, "wpe_eis_cq_thread4_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_WPE_EIS_CQ_THR_DONE_P2_5, "wpe_eis_cq_thread5_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_WPE_EIS_CQ_THR_DONE_P2_6, "wpe_eis_cq_thread6_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_WPE_EIS_CQ_THR_DONE_P2_7, "wpe_eis_cq_thread7_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_WPE_EIS_CQ_THR_DONE_P2_8, "wpe_eis_cq_thread8_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_WPE_EIS_CQ_THR_DONE_P2_9, "wpe_eis_cq_thread9_frame_done"},
+	/*WPE_TNR frame done*/
+	{IMGSYS_CMDQ_EVENT_IMG_WPE_TNR_CQ_THR_DONE_P2_0, "wpe_tnr_cq_thread0_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_WPE_TNR_CQ_THR_DONE_P2_1, "wpe_tnr_cq_thread1_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_WPE_TNR_CQ_THR_DONE_P2_2, "wpe_tnr_cq_thread2_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_WPE_TNR_CQ_THR_DONE_P2_3, "wpe_tnr_cq_thread3_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_WPE_TNR_CQ_THR_DONE_P2_4, "wpe_tnr_cq_thread4_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_WPE_TNR_CQ_THR_DONE_P2_5, "wpe_tnr_cq_thread5_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_WPE_TNR_CQ_THR_DONE_P2_6, "wpe_tnr_cq_thread6_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_WPE_TNR_CQ_THR_DONE_P2_7, "wpe_tnr_cq_thread7_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_WPE_TNR_CQ_THR_DONE_P2_8, "wpe_tnr_cq_thread8_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_WPE_TNR_CQ_THR_DONE_P2_9, "wpe_tnr_cq_thread9_frame_done"},
+	/*WPE_LITE frame done*/
+	{IMGSYS_CMDQ_EVENT_IMG_WPE_LITE_CQ_THR_DONE_P2_0, "wpe_lite_cq_thread0_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_WPE_LITE_CQ_THR_DONE_P2_1, "wpe_lite_cq_thread1_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_WPE_LITE_CQ_THR_DONE_P2_2, "wpe_lite_cq_thread2_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_WPE_LITE_CQ_THR_DONE_P2_3, "wpe_lite_cq_thread3_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_WPE_LITE_CQ_THR_DONE_P2_4, "wpe_lite_cq_thread4_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_WPE_LITE_CQ_THR_DONE_P2_5, "wpe_lite_cq_thread5_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_WPE_LITE_CQ_THR_DONE_P2_6, "wpe_lite_cq_thread6_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_WPE_LITE_CQ_THR_DONE_P2_7, "wpe_lite_cq_thread7_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_WPE_LITE_CQ_THR_DONE_P2_8, "wpe_lite_cq_thread8_frame_done"},
+	{IMGSYS_CMDQ_EVENT_IMG_WPE_LITE_CQ_THR_DONE_P2_9, "wpe_lite_cq_thread9_frame_done"},
+	/*ME done*/
+	{IMGSYS_CMDQ_EVENT_IMG_IMGSYS_IPE_ME_DONE, "me_done"},
+	/*ADL done*/
+	{IMGSYS_CMDQ_EVENT_IMG_ADL_TILE_DONE_EVENT, "adl_tile_done"},
+	/* SW event */
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_WPE_EIS, "wpe_eis_sync_token"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_WPE_TNR, "wpe_tnr_sync_token"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_WPE_LITE, "wpe_lite_sync_token"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_TRAW, "traw_sync_token"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_LTRAW, "ltraw_sync_token"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_XTRAW, "xtraw_sync_token"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_DIP, "dip_sync_token"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_PQDIP_A, "pqdip_a_sync_token"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_PQDIP_B, "pqdip_b_sync_token"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IPESYS_ME, "me_sync_token"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_APUSYS_APU, "apu_sync_token"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_VSS_TRAW, "vss_traw_sync_token"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_VSS_LTRAW, "vss_ltraw_sync_token"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_VSS_XTRAW, "vss_xtraw_sync_token"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_VSS_DIP, "vss_dip_sync_token"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_1, "sw_sync_token_pool_1"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_2, "sw_sync_token_pool_2"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_3, "sw_sync_token_pool_3"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_4, "sw_sync_token_pool_4"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_5, "sw_sync_token_pool_5"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_6, "sw_sync_token_pool_6"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_7, "sw_sync_token_pool_7"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_8, "sw_sync_token_pool_8"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_9, "sw_sync_token_pool_9"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_10, "sw_sync_token_pool_10"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_11, "sw_sync_token_pool_11"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_12, "sw_sync_token_pool_12"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_13, "sw_sync_token_pool_13"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_14, "sw_sync_token_pool_14"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_15, "sw_sync_token_pool_15"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_16, "sw_sync_token_pool_16"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_17, "sw_sync_token_pool_17"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_18, "sw_sync_token_pool_18"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_19, "sw_sync_token_pool_19"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_20, "sw_sync_token_pool_20"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_21, "sw_sync_token_pool_21"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_22, "sw_sync_token_pool_22"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_23, "sw_sync_token_pool_23"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_24, "sw_sync_token_pool_24"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_25, "sw_sync_token_pool_25"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_26, "sw_sync_token_pool_26"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_27, "sw_sync_token_pool_27"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_28, "sw_sync_token_pool_28"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_29, "sw_sync_token_pool_29"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_30, "sw_sync_token_pool_30"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_31, "sw_sync_token_pool_31"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_32, "sw_sync_token_pool_32"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_33, "sw_sync_token_pool_33"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_34, "sw_sync_token_pool_34"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_35, "sw_sync_token_pool_35"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_36, "sw_sync_token_pool_36"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_37, "sw_sync_token_pool_37"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_38, "sw_sync_token_pool_38"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_39, "sw_sync_token_pool_39"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_40, "sw_sync_token_pool_40"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_41, "sw_sync_token_pool_41"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_42, "sw_sync_token_pool_42"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_43, "sw_sync_token_pool_43"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_44, "sw_sync_token_pool_44"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_45, "sw_sync_token_pool_45"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_46, "sw_sync_token_pool_46"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_47, "sw_sync_token_pool_47"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_48, "sw_sync_token_pool_48"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_49, "sw_sync_token_pool_49"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_50, "sw_sync_token_pool_50"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_51, "sw_sync_token_pool_51"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_52, "sw_sync_token_pool_52"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_53, "sw_sync_token_pool_53"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_54, "sw_sync_token_pool_54"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_55, "sw_sync_token_pool_55"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_56, "sw_sync_token_pool_56"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_57, "sw_sync_token_pool_57"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_58, "sw_sync_token_pool_58"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_59, "sw_sync_token_pool_59"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_60, "sw_sync_token_pool_60"},
+/*
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_61, "sw_sync_token_pool_61"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_62, "sw_sync_token_pool_62"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_63, "sw_sync_token_pool_63"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_64, "sw_sync_token_pool_64"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_65, "sw_sync_token_pool_65"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_66, "sw_sync_token_pool_66"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_67, "sw_sync_token_pool_67"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_68, "sw_sync_token_pool_68"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_69, "sw_sync_token_pool_69"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_70, "sw_sync_token_pool_70"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_71, "sw_sync_token_pool_71"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_72, "sw_sync_token_pool_72"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_73, "sw_sync_token_pool_73"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_74, "sw_sync_token_pool_74"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_75, "sw_sync_token_pool_75"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_76, "sw_sync_token_pool_76"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_77, "sw_sync_token_pool_77"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_78, "sw_sync_token_pool_78"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_79, "sw_sync_token_pool_79"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_80, "sw_sync_token_pool_80"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_81, "sw_sync_token_pool_81"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_82, "sw_sync_token_pool_82"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_83, "sw_sync_token_pool_83"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_84, "sw_sync_token_pool_84"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_85, "sw_sync_token_pool_85"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_86, "sw_sync_token_pool_86"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_87, "sw_sync_token_pool_87"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_88, "sw_sync_token_pool_88"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_89, "sw_sync_token_pool_89"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_90, "sw_sync_token_pool_90"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_91, "sw_sync_token_pool_91"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_92, "sw_sync_token_pool_92"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_93, "sw_sync_token_pool_93"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_94, "sw_sync_token_pool_94"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_95, "sw_sync_token_pool_95"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_96, "sw_sync_token_pool_96"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_97, "sw_sync_token_pool_97"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_98, "sw_sync_token_pool_98"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_99, "sw_sync_token_pool_99"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_IMGSYS_POOL_100, "sw_sync_token_pool_100"},
+*/
+	{IMGSYS_CMDQ_SYNC_TOKEN_CAMSYS_POOL_1, "sw_sync_token_camsys_pool_1"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_CAMSYS_POOL_2, "sw_sync_token_camsys_pool_2"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_CAMSYS_POOL_3, "sw_sync_token_camsys_pool_3"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_CAMSYS_POOL_4, "sw_sync_token_camsys_pool_4"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_CAMSYS_POOL_5, "sw_sync_token_camsys_pool_5"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_CAMSYS_POOL_6, "sw_sync_token_camsys_pool_6"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_CAMSYS_POOL_7, "sw_sync_token_camsys_pool_7"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_CAMSYS_POOL_8, "sw_sync_token_camsys_pool_8"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_CAMSYS_POOL_9, "sw_sync_token_camsys_pool_9"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_CAMSYS_POOL_10, "sw_sync_token_camsys_pool_10"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_TZMP_ISP_WAIT, "sw_sync_token_tzmp_isp_wait"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_TZMP_ISP_SET, "sw_sync_token_tzmp_isp_set"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_TZMP_ADL_WAIT, "sw_sync_token_tzmp_adl_wait"},
+	{IMGSYS_CMDQ_SYNC_TOKEN_TZMP_ADL_SET, "sw_sync_token_tzmp_adl_set"},
+	{IMGSYS_CMDQ_EVENT_MAX, "imgsys_event_max"},
+};
+
+static struct cmdq_client *imgsys_clt[IMGSYS_ENG_MAX];
+static struct cmdq_client *imgsys_sec_clt[IMGSYS_SEC_THD];
+
+enum mtk_imgsys_m4u_port {
+	/* TRAW */
+	IMGSYS_M4U_PORT_TRAW_START,
+	IMGSYS_M4U_PORT_L9_IMGI_T1_A = IMGSYS_M4U_PORT_TRAW_START,
+	IMGSYS_M4U_PORT_L9_UFDI_T1_A,
+	IMGSYS_M4U_PORT_L9_IMGBI_T1_A,
+	IMGSYS_M4U_PORT_L9_IMGCI_T1_A,
+	IMGSYS_M4U_PORT_L9_SMTI_T1_A,
+	IMGSYS_M4U_PORT_L9_SMTI_T4_A,
+	IMGSYS_M4U_PORT_L9_TNCSTI_T1_A,
+	IMGSYS_M4U_PORT_L9_TNCSTI_T4_A,
+	IMGSYS_M4U_PORT_L9_YUVO_T1_A,
+	IMGSYS_M4U_PORT_L9_YUVBO_T1_A,
+	IMGSYS_M4U_PORT_L9_YUVCO_T1_A,
+	IMGSYS_M4U_PORT_L9_TIMGO_T1_A,
+	IMGSYS_M4U_PORT_L9_YUVO_T2_A,
+	IMGSYS_M4U_PORT_L9_YUVO_T5_A,
+	IMGSYS_M4U_PORT_L9_TNCSO_T1_A,
+	IMGSYS_M4U_PORT_L9_SMTO_T1_A,
+	IMGSYS_M4U_PORT_L9_SMTO_T4_A,
+	IMGSYS_M4U_PORT_L9_TNCSTO_T1_A,
+
+	/* LTRAW */
+	IMGSYS_M4U_PORT_LTRAW_START,
+	IMGSYS_M4U_PORT_L9_IMGI_T1_B = IMGSYS_M4U_PORT_LTRAW_START,
+	IMGSYS_M4U_PORT_L9_IMGBI_T1_B,
+	IMGSYS_M4U_PORT_L9_IMGCI_T1_B,
+	IMGSYS_M4U_PORT_L9_SMTI_T4_B,
+	IMGSYS_M4U_PORT_L9_YUVO_T2_B,
+	IMGSYS_M4U_PORT_L9_YUVO_T5_B,
+	IMGSYS_M4U_PORT_L9_SMTO_T4_B,
+
+	/* XTRAW */
+	IMGSYS_M4U_PORT_XTRAW_START,
+	IMGSYS_M4U_PORT_L11A_IMGI_T1_C	= IMGSYS_M4U_PORT_XTRAW_START,
+	IMGSYS_M4U_PORT_L11A_IMGBI_T1_C,
+	IMGSYS_M4U_PORT_L11A_IMGCI_T1_C,
+	IMGSYS_M4U_PORT_L11A_SMTI_T1_C,
+	IMGSYS_M4U_PORT_L11A_SMTI_T4_C,
+	IMGSYS_M4U_PORT_L11A_SMTI_T6_C,
+	IMGSYS_M4U_PORT_L11A_YUVO_T1_C,
+	IMGSYS_M4U_PORT_L11A_YUVBO_T1_C,
+	IMGSYS_M4U_PORT_L11A_YUVCO_T1_C,
+	IMGSYS_M4U_PORT_L11A_TIMGO_T1_C,
+	IMGSYS_M4U_PORT_L11A_YUVO_T2_C,
+	IMGSYS_M4U_PORT_L11A_YUVO_T5_C,
+	IMGSYS_M4U_PORT_L11A_SMTO_T1_C,
+	IMGSYS_M4U_PORT_L11A_SMTO_T4_C,
+	IMGSYS_M4U_PORT_L11A_SMTO_T6_C,
+	IMGSYS_M4U_PORT_L11A_DBGO_T1_C,
+
+	/* DIP */
+	IMGSYS_M4U_PORT_DIP0_START,
+	IMGSYS_M4U_PORT_L10_IMGI_D1 = IMGSYS_M4U_PORT_DIP0_START,
+	IMGSYS_M4U_PORT_L10_IMGBI_D1,
+	IMGSYS_M4U_PORT_L10_IMGCI_D1,
+	IMGSYS_M4U_PORT_L10_IMGDI_D1,
+	IMGSYS_M4U_PORT_L10_DEPI_D1,
+	IMGSYS_M4U_PORT_L10_DMGI_D1,
+	IMGSYS_M4U_PORT_L10_SMTI_D1,
+	IMGSYS_M4U_PORT_L10_RECI_D1,
+	IMGSYS_M4U_PORT_L10_RECI_D1_N,
+	IMGSYS_M4U_PORT_L10_TNRWI_D1,
+	IMGSYS_M4U_PORT_L10_TNRCI_D1,
+	IMGSYS_M4U_PORT_L10_TNRCI_D1_N,
+	IMGSYS_M4U_PORT_L10_IMG4O_D1,
+	IMGSYS_M4U_PORT_L10_IMG4BO_D1,
+	IMGSYS_M4U_PORT_L10_SMTI_D8,
+	IMGSYS_M4U_PORT_L10_SMTO_D1,
+	IMGSYS_M4U_PORT_L10_TNRMO_D1,
+	IMGSYS_M4U_PORT_L10_TNRMO_D1_N,
+	IMGSYS_M4U_PORT_L10_SMTO_D8,
+	IMGSYS_M4U_PORT_L10_DBGO_D1,
+	IMGSYS_M4U_PORT_DIP1_START,
+	IMGSYS_M4U_PORT_L15_VIPI_D1 = IMGSYS_M4U_PORT_DIP1_START,
+	IMGSYS_M4U_PORT_L15_VIPBI_D1,
+	IMGSYS_M4U_PORT_L15_SMTI_D6,
+	IMGSYS_M4U_PORT_L15_TNCSTI_D1,
+	IMGSYS_M4U_PORT_L15_TNCSTI_D4,
+	IMGSYS_M4U_PORT_L15_SMTI_D4,
+	IMGSYS_M4U_PORT_L15_IMG3O_D1,
+	IMGSYS_M4U_PORT_L15_IMG3BO_D1,
+	IMGSYS_M4U_PORT_L15_IMG3CO_D1,
+	IMGSYS_M4U_PORT_L15_IMG2O_D1,
+	IMGSYS_M4U_PORT_L15_SMTI_D9,
+	IMGSYS_M4U_PORT_L15_SMTO_D4,
+	IMGSYS_M4U_PORT_L15_FEO_D1,
+	IMGSYS_M4U_PORT_L15_TNCSO_D1,
+	IMGSYS_M4U_PORT_L15_TNCSTO_D1,
+	IMGSYS_M4U_PORT_L15_SMTO_D6,
+	IMGSYS_M4U_PORT_L15_SMTO_D9,
+	IMGSYS_M4U_PORT_L15_TNCO_D1,
+	IMGSYS_M4U_PORT_L15_TNCO_D1_N,
+
+	/* PQDIP_A */
+	IMGSYS_M4U_PORT_PQDIP_A_START,
+	IMGSYS_M4U_PORT_L11A_PIMGI_P1 = IMGSYS_M4U_PORT_PQDIP_A_START,
+	IMGSYS_M4U_PORT_L11A_PIMGBI_P1,
+	IMGSYS_M4U_PORT_L11A_PIMGCI_P1,
+	IMGSYS_M4U_PORT_L11A_WROT_P1,
+	IMGSYS_M4U_PORT_L11A_TCCSO_P1,
+	IMGSYS_M4U_PORT_L11A_TCCSI_P1,
+
+	/* PQDIP_B */
+	IMGSYS_M4U_PORT_PQDIP_B_START,
+	IMGSYS_M4U_PORT_L11B_PIMGI_P1 = IMGSYS_M4U_PORT_PQDIP_B_START,
+	IMGSYS_M4U_PORT_L11B_PIMGBI_P1,
+	IMGSYS_M4U_PORT_L11B_PIMGCI_P1,
+	IMGSYS_M4U_PORT_L11B_WROT_P1,
+	IMGSYS_M4U_PORT_L11B_TCCSO_P1,
+	IMGSYS_M4U_PORT_L11B_TCCSI_P1,
+
+	/* WPE_EIS */
+	IMGSYS_M4U_PORT_WPE_EIS_START,
+	IMGSYS_M4U_PORT_L11A_WPE_RDMA_0 = IMGSYS_M4U_PORT_WPE_EIS_START,
+	IMGSYS_M4U_PORT_L11A_WPE_RDMA_1,
+	IMGSYS_M4U_PORT_L11A_WPE_RDMA_4P_0,
+	IMGSYS_M4U_PORT_L11A_WPE_RDMA_4P_1,
+	IMGSYS_M4U_PORT_L11A_WPE_CQ0,
+	IMGSYS_M4U_PORT_L11A_WPE_CQ1,
+	IMGSYS_M4U_PORT_L11A_WPE_WDMA_0,
+	IMGSYS_M4U_PORT_L11A_WPE_WDMA_4P_0,
+
+	/* WPE_TNR */
+	IMGSYS_M4U_PORT_WPE_TNR_START,
+	IMGSYS_M4U_PORT_L11B_WPE_RDMA_0 = IMGSYS_M4U_PORT_WPE_TNR_START,
+	IMGSYS_M4U_PORT_L11B_WPE_RDMA_1,
+	IMGSYS_M4U_PORT_L11B_WPE_RDMA_4P_0,
+	IMGSYS_M4U_PORT_L11B_WPE_RDMA_4P_1,
+	IMGSYS_M4U_PORT_L11B_WPE_CQ0,
+	IMGSYS_M4U_PORT_L11B_WPE_CQ1,
+	IMGSYS_M4U_PORT_L11B_WPE_WDMA_0,
+	IMGSYS_M4U_PORT_L11B_WPE_WDMA_4P_0,
+
+	/* WPE_LITE */
+	IMGSYS_M4U_PORT_WPE_LITE_START,
+	IMGSYS_M4U_PORT_L11C_WPE_RDMA_0 = IMGSYS_M4U_PORT_WPE_LITE_START,
+	IMGSYS_M4U_PORT_L11C_WPE_RDMA_1,
+	IMGSYS_M4U_PORT_L11C_WPE_RDMA_4P_0,
+	IMGSYS_M4U_PORT_L11C_WPE_RDMA_4P_1,
+	IMGSYS_M4U_PORT_L11C_WPE_CQ0,
+	IMGSYS_M4U_PORT_L11C_WPE_CQ1,
+	IMGSYS_M4U_PORT_L11C_WPE_WDMA_0,
+	IMGSYS_M4U_PORT_L11C_WPE_WDMA_4P_0,
+
+	/* ME */
+	IMGSYS_M4U_PORT_ME_START,
+	IMGSYS_M4U_PORT_L12_ME_RDMA = IMGSYS_M4U_PORT_ME_START,
+	IMGSYS_M4U_PORT_L12_ME_WDMA,
+
+	/* SMI COMMON */
+	IMGSYS_L9_COMMON_0,
+	IMGSYS_L12_COMMON_1,
+	IMGSYS_M4U_PORT_MAX
+};
+
+static struct mtk_imgsys_qos_path imgsys_qos_path[IMGSYS_M4U_PORT_MAX] = {
+	{NULL, "l9_imgi_t1_a", 0},
+	{NULL, "l9_ufdi_t1_a", 0},
+	{NULL, "l9_imgbi_t1_a", 0},
+	{NULL, "l9_imgci_t1_a", 0},
+	{NULL, "l9_smti_t1_a", 0},
+	{NULL, "l9_smti_t4_a", 0},
+	{NULL, "l9_tncsti_t1_a", 0},
+	{NULL, "l9_tncsti_t4_a", 0},
+	{NULL, "l9_yuvo_t1_a", 0},
+	{NULL, "l9_yuvbo_t1_a", 0},
+	{NULL, "l9_yuvco_t1_a", 0},
+	{NULL, "l9_timgo_t1_a", 0},
+	{NULL, "l9_yuvo_t2_a", 0},
+	{NULL, "l9_yuvo_t5_a", 0},
+	{NULL, "l9_tncso_t1_a", 0},
+	{NULL, "l9_smto_t1_a", 0},
+	{NULL, "l9_smto_t4_a", 0},
+	{NULL, "l9_tncsto_t1_a", 0},
+	{NULL, "l9_imgi_t1_b", 0},
+	{NULL, "l9_imgbi_t1_b", 0},
+	{NULL, "l9_imgci_t1_b", 0},
+	{NULL, "l9_smti_t4_b", 0},
+	{NULL, "l9_yuvo_t2_b", 0},
+	{NULL, "l9_yuvo_t5_b", 0},
+	{NULL, "l9_smto_t4_b", 0},
+	{NULL, "l11a_imgi_t1_c", 0},
+	{NULL, "l11a_imgbi_t1_c", 0},
+	{NULL, "l11a_imgci_t1_c", 0},
+	{NULL, "l11a_smti_t1_c", 0},
+	{NULL, "l11a_smti_t4_c", 0},
+	{NULL, "l11a_smti_t6_c", 0},
+	{NULL, "l11a_yuvo_t1_c", 0},
+	{NULL, "l11a_yuvbo_t1_c", 0},
+	{NULL, "l11a_yuvco_t1_c", 0},
+	{NULL, "l11a_timgo_t1_c", 0},
+	{NULL, "l11a_yuvo_t2_c", 0},
+	{NULL, "l11a_yuvo_t5_c", 0},
+	{NULL, "l11a_smto_t1_c", 0},
+	{NULL, "l11a_smto_t4_c", 0},
+	{NULL, "l11a_smto_t6_c", 0},
+	{NULL, "l11a_dbgo_t1_c", 0},
+	{NULL, "l10_imgi_d1", 0},
+	{NULL, "l10_imgbi_d1", 0},
+	{NULL, "l10_imgci_d1", 0},
+	{NULL, "l10_imgdi_d1", 0},
+	{NULL, "l10_depi_d1", 0},
+	{NULL, "l10_dmgi_d1", 0},
+	{NULL, "l10_smti_d1", 0},
+	{NULL, "l10_reci_d1", 0},
+	{NULL, "l10_reci_d1_n", 0},
+	{NULL, "l10_tnrwi_d1", 0},
+	{NULL, "l10_tnrci_d1", 0},
+	{NULL, "l10_tnrci_d1_n", 0},
+	{NULL, "l10_img4o_d1", 0},
+	{NULL, "l10_img4bo_d1", 0},
+	{NULL, "l10_smti_d8", 0},
+	{NULL, "l10_smto_d1", 0},
+	{NULL, "l10_tnrmo_d1", 0},
+	{NULL, "l10_tnrmo_d1_n", 0},
+	{NULL, "l10_smto_d8", 0},
+	{NULL, "l10_dbgo_d1", 0},
+	{NULL, "l15_vipi_d1", 0},
+	{NULL, "l15_vipbi_d1", 0},
+	{NULL, "l15_smti_d6", 0},
+	{NULL, "l15_tncsti_d1", 0},
+	{NULL, "l15_tncsti_d4", 0},
+	{NULL, "l15_smti_d4", 0},
+	{NULL, "l15_img3o_d1", 0},
+	{NULL, "l15_img3bo_d1", 0},
+	{NULL, "l15_img3co_d1", 0},
+	{NULL, "l15_img2o_d1", 0},
+	{NULL, "l15_smti_d9", 0},
+	{NULL, "l15_smto_d4", 0},
+	{NULL, "l15_feo_d1", 0},
+	{NULL, "l15_tncso_d1", 0},
+	{NULL, "l15_tncsto_d1", 0},
+	{NULL, "l15_smto_d6", 0},
+	{NULL, "l15_smto_d9", 0},
+	{NULL, "l15_tnco_d1", 0},
+	{NULL, "l15_tnco_d1_n", 0},
+	{NULL, "l11a_pimgi_p1", 0},
+	{NULL, "l11a_pimgbi_p1", 0},
+	{NULL, "l11a_pimgci_p1", 0},
+	{NULL, "l11a_wrot_p1", 0},
+	{NULL, "l11a_tccso_p1", 0},
+	{NULL, "l11a_tccsi_p1", 0},
+	{NULL, "l11b_pimgi_p1", 0},
+	{NULL, "l11b_pimgbi_p1", 0},
+	{NULL, "l11b_pimgci_p1", 0},
+	{NULL, "l11b_wrot_p1", 0},
+	{NULL, "l11b_tccso_p1", 0},
+	{NULL, "l11b_tccsi_p1", 0},
+	{NULL, "l11a_wpe_rdma0", 0},
+	{NULL, "l11a_wpe_rdma1", 0},
+	{NULL, "l11a_wpe_rdma_4p0", 0},
+	{NULL, "l11a_wpe_rdma_4p1", 0},
+	{NULL, "l11a_wpe_cq0", 0},
+	{NULL, "l11a_wpe_cq1", 0},
+	{NULL, "l11a_wpe_wdma0", 0},
+	{NULL, "l11a_wpe_wdma_4p0", 0},
+	{NULL, "l11b_wpe_rdma0", 0},
+	{NULL, "l11b_wpe_rdma1", 0},
+	{NULL, "l11b_wpe_rdma_4p0", 0},
+	{NULL, "l11b_wpe_rdma_4p1", 0},
+	{NULL, "l11b_wpe_cq0", 0},
+	{NULL, "l11b_wpe_cq1", 0},
+	{NULL, "l11b_wpe_wdma0", 0},
+	{NULL, "l11b_wpe_wdma_4p0", 0},
+	{NULL, "l11c_wpe_rdma0", 0},
+	{NULL, "l11c_wpe_rdma1", 0},
+	{NULL, "l11c_wpe_rdma_4p0", 0},
+	{NULL, "l11c_wpe_rdma_4p1", 0},
+	{NULL, "l11c_wpe_cq0", 0},
+	{NULL, "l11c_wpe_cq1", 0},
+	{NULL, "l11c_wpe_wdma0", 0},
+	{NULL, "l11c_wpe_wdma_4p0", 0},
+	{NULL, "l12_me_rdma", 0},
+	{NULL, "l12_me_wdma", 0},
+	{NULL, "l9_common_0", 0},
+	{NULL, "l12_common_1", 0}
+
+};
+
+struct BlockRecord {
+	uint32_t            label_min;
+	uint32_t            label_max;
+	uint32_t            label_count;
+	uint32_t            cmd_offset;
+	uint32_t            cmd_length;
+};
+
+enum GCE_REC_BLOCK_ENUM {
+	GCE_REC_NONE_BLOCK = -1,
+	GCE_REC_FRAME_BLOCK = 0,
+	GCE_REC_TILE_BLOCK
+};
+
+enum GCE_REC_MODE_ENUM {
+	GCE_REC_APPEND_MODE = 0,
+	GCE_REC_REPLACE_MODE
+};
+
+struct GCERecoder {
+	uint32_t            header_code;
+
+	// Record command offset
+	uint32_t            cmd_offset;
+
+	uint32_t            check_pre;
+
+	// Reocrd command buffer info
+	uint32_t            *pOutput;
+
+	uint32_t            check_post;
+
+	uint32_t            *pBuffer;
+	uint32_t            max_length;
+	uint32_t            curr_length;
+
+	// Each frame block info
+	struct BlockRecord  frame_record[GCE_REC_MAX_FRAME_BLOCK];
+	uint32_t            frame_block;
+	uint32_t            curr_frame;
+
+	// Each tile block info
+	struct BlockRecord  tile_record[GCE_REC_MAX_TILE_BLOCK];
+	uint32_t            tile_block;
+	uint32_t            curr_tile;
+
+	// Record current block type
+	enum GCE_REC_BLOCK_ENUM  curr_block;
+
+	// Current mode setting
+	enum GCE_REC_MODE_ENUM   curr_mode;
+
+	// Append/Replace mode switch
+	uint32_t            orig_index;
+	uint32_t            *pOrig_out;
+	uint32_t            curr_label;
+
+	// Current label mode setting
+	enum GCE_REC_BLOCK_ENUM  label_block;
+
+	// Each frame command label
+	uint32_t            frame_label[GCE_REC_MAX_LABEL_COUNT];
+	uint32_t            frame_count;
+
+	// Each tile command label
+	uint32_t            tile_label[GCE_REC_MAX_LABEL_COUNT];
+	uint32_t            tile_count;
+
+	uint32_t            footer_code;
+};
+
+static struct imgsys_dvfs_group  dvfs_group[MTK_IMGSYS_DVFS_GROUP] = {
+	{0, (IMGSYS_ENG_WPE_LITE
+			|IMGSYS_ENG_TRAW
+			|IMGSYS_ENG_LTR
+			|IMGSYS_ENG_XTR
+			|IMGSYS_ENG_ME)},
+	{1, (IMGSYS_ENG_WPE_TNR
+			|IMGSYS_ENG_DIP)},
+	{2, (IMGSYS_ENG_WPE_EIS
+			|IMGSYS_ENG_PQDIP_A
+			|IMGSYS_ENG_PQDIP_B)}
+};
+
+static struct imgsys_dvfs_group  qos_group[MTK_IMGSYS_QOS_GROUP] = {
+	{0, (IMGSYS_ENG_WPE_EIS
+			|IMGSYS_ENG_WPE_LITE
+			|IMGSYS_ENG_TRAW
+			|IMGSYS_ENG_LTR
+			|IMGSYS_ENG_XTR
+			|IMGSYS_ENG_DIP
+			|IMGSYS_ENG_PQDIP_A)},
+	{1, (IMGSYS_ENG_WPE_TNR
+			|IMGSYS_ENG_DIP
+			|IMGSYS_ENG_PQDIP_B
+			|IMGSYS_ENG_ME)}
+};
+
+struct smi_port_t {
+	uint32_t portenum;
+	uint32_t portbw;
+} __attribute__((__packed__));
+
+struct wpe_bw_t {
+	uint32_t totalbw;
+	struct smi_port_t smiport[WPE_SMI_PORT_NUM];
+} __attribute__((__packed__));
+
+struct me_bw_t {
+	uint32_t totalbw;
+	struct smi_port_t smiport[ME_SMI_PORT_NUM];
+} __attribute__((__packed__));
+
+struct pqdip_bw_t {
+	uint32_t totalbw;
+	struct smi_port_t smiport[PQ_DIP_SMI_PORT_NUM];
+} __attribute__((__packed__));
+
+struct traw_bw_t {
+	uint32_t totalbw;
+	struct smi_port_t smiport[TRAW_SMI_PORT_NUM];
+} __attribute__((__packed__));
+
+struct ltraw_bw_t {
+	uint32_t totalbw;
+	struct smi_port_t smiport[LTRAW_SMI_PORT_NUM];
+} __attribute__((__packed__));
+
+struct xtraw_bw_t {
+	uint32_t totalbw;
+	struct smi_port_t smiport[XTRAW_SMI_PORT_NUM];
+} __attribute__((__packed__));
+
+struct dip_bw_t {
+	uint32_t totalbw;
+	struct smi_port_t smiport[DIP_SMI_PORT_NUM];
+} __attribute__((__packed__));
+
+struct adl_bw_t {
+	uint32_t totalbw;
+	struct smi_port_t smiport[ADL_SMI_PORT_NUM];
+} __attribute__((__packed__));
+
+struct frame_bw_t {
+	struct wpe_bw_t wpe_eis;
+	struct wpe_bw_t wpe_tnr;
+	struct wpe_bw_t wpe_lite;
+	struct me_bw_t me;
+	struct pqdip_bw_t pqdip_a;
+	struct pqdip_bw_t pqdip_b;
+	struct traw_bw_t traw;
+	struct ltraw_bw_t ltraw;
+	struct xtraw_bw_t xtraw;
+	struct dip_bw_t dip;
+	struct adl_bw_t ad;
+} __attribute__((__packed__));
+
+#endif /* _MTK_IMGSYS_CMDQ_PLAT_H_ */
+
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_71/mtk_imgsys-debug.c b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_71/mtk_imgsys-debug.c
new file mode 100755
index 0000000000000000000000000000000000000000..240379655ef1fcff997ef6511efb32a469031f58
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_71/mtk_imgsys-debug.c
@@ -0,0 +1,1206 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2018 MediaTek Inc.
+ *
+ * Author: Christopher Chen <christopher.chen@mediatek.com>
+ *
+ */
+
+#include <linux/device.h>
+#include <linux/of_address.h>
+#include <dma-iommu.h>
+#include <linux/pm_runtime.h>
+#include <linux/remoteproc.h>
+#include "mtk_imgsys-engine.h"
+#include "mtk_imgsys-debug.h"
+
+#define DL_CHECK_ENG_NUM 11
+#define WPE_HW_SET    3
+#define ADL_HW_SET    2
+#define SW_RST   (0x000C)
+
+struct imgsys_dbg_engine_t dbg_engine_name_list[DL_CHECK_ENG_NUM] = {
+	{IMGSYS_ENG_WPE_EIS, "WPE_EIS"},
+	{IMGSYS_ENG_WPE_TNR, "WPE_TNR"},
+	{IMGSYS_ENG_WPE_LITE, "WPE_LITE"},
+	{IMGSYS_ENG_TRAW, "TRAW"},
+	{IMGSYS_ENG_LTR, "LTRAW"},
+	{IMGSYS_ENG_XTR, "XTRAW"},
+	{IMGSYS_ENG_DIP, "DIP"},
+	{IMGSYS_ENG_PQDIP_A, "PQDIPA"},
+	{IMGSYS_ENG_PQDIP_B, "PQDIPB"},
+	{IMGSYS_ENG_ADL_A, "ADLA"},
+	{IMGSYS_ENG_ADL_B, "ADLB"},
+};
+
+void __iomem *imgsysmainRegBA;
+void __iomem *wpedip1RegBA;
+void __iomem *wpedip2RegBA;
+void __iomem *wpedip3RegBA;
+void __iomem *dipRegBA;
+void __iomem *dip1RegBA;
+void __iomem *adlARegBA;
+void __iomem *adlBRegBA;
+
+void imgsys_main_init(struct mtk_imgsys_dev *imgsys_dev)
+{
+	struct resource adl;
+	pr_info("%s: +.\n", __func__);
+
+	imgsysmainRegBA = of_iomap(imgsys_dev->dev->of_node, REG_MAP_E_TOP);
+	if (!imgsysmainRegBA) {
+		dev_info(imgsys_dev->dev, "%s Unable to ioremap imgsys_top registers\n",
+								__func__);
+		dev_info(imgsys_dev->dev, "%s of_iomap fail, devnode(%s).\n",
+				__func__, imgsys_dev->dev->of_node->name);
+		return;
+	}
+
+	wpedip1RegBA = of_iomap(imgsys_dev->dev->of_node, REG_MAP_E_WPE1_DIP1);
+	if (!wpedip1RegBA) {
+		dev_info(imgsys_dev->dev, "%s Unable to ioremap wpe_dip1 registers\n",
+								__func__);
+		dev_info(imgsys_dev->dev, "%s of_iomap fail, devnode(%s).\n",
+				__func__, imgsys_dev->dev->of_node->name);
+		return;
+	}
+
+	wpedip2RegBA = of_iomap(imgsys_dev->dev->of_node, REG_MAP_E_WPE2_DIP1);
+	if (!wpedip2RegBA) {
+		dev_info(imgsys_dev->dev, "%s Unable to ioremap wpe_dip2 registers\n",
+								__func__);
+		dev_info(imgsys_dev->dev, "%s of_iomap fail, devnode(%s).\n",
+				__func__, imgsys_dev->dev->of_node->name);
+		return;
+	}
+
+	wpedip3RegBA = of_iomap(imgsys_dev->dev->of_node, REG_MAP_E_WPE3_DIP1);
+	if (!wpedip3RegBA) {
+		dev_info(imgsys_dev->dev, "%s Unable to ioremap wpe_dip3 registers\n",
+								__func__);
+		dev_info(imgsys_dev->dev, "%s of_iomap fail, devnode(%s).\n",
+				__func__, imgsys_dev->dev->of_node->name);
+		return;
+	}
+
+	dipRegBA = of_iomap(imgsys_dev->dev->of_node, REG_MAP_E_DIP_TOP);
+	if (!dipRegBA) {
+		dev_info(imgsys_dev->dev, "%s Unable to ioremap dip_top registers\n",
+								__func__);
+		dev_info(imgsys_dev->dev, "%s of_iomap fail, devnode(%s).\n",
+				__func__, imgsys_dev->dev->of_node->name);
+		return;
+	}
+
+	dip1RegBA = of_iomap(imgsys_dev->dev->of_node, REG_MAP_E_DIP_TOP_NR);
+	if (!dip1RegBA) {
+		dev_info(imgsys_dev->dev, "%s Unable to ioremap dip_top_nr registers\n",
+								__func__);
+		dev_info(imgsys_dev->dev, "%s of_iomap fail, devnode(%s).\n",
+				__func__, imgsys_dev->dev->of_node->name);
+		return;
+	}
+
+	of_address_to_resource(imgsys_dev->dev->of_node, REG_MAP_E_ADL_A, &adl);
+	if (adl.start) {
+		adlARegBA = of_iomap(imgsys_dev->dev->of_node, REG_MAP_E_ADL_A);
+		if (!adlARegBA) {
+			dev_info(imgsys_dev->dev, "%s Unable to ioremap adl a registers\n",
+									__func__);
+			dev_info(imgsys_dev->dev, "%s of_iomap fail, devnode(%s).\n",
+					__func__, imgsys_dev->dev->of_node->name);
+			return;
+		}
+
+		adlBRegBA = of_iomap(imgsys_dev->dev->of_node, REG_MAP_E_ADL_B);
+		if (!adlBRegBA) {
+			dev_info(imgsys_dev->dev, "%s Unable to ioremap adl b registers\n",
+									__func__);
+			dev_info(imgsys_dev->dev, "%s of_iomap fail, devnode(%s).\n",
+					__func__, imgsys_dev->dev->of_node->name);
+			return;
+		}
+	} else {
+		adlARegBA = NULL;
+		adlBRegBA = NULL;
+		dev_info(imgsys_dev->dev, "%s Do not have ADL hardware.\n", __func__);
+	}
+
+	pr_info("%s: -.\n", __func__);
+}
+
+void imgsys_main_set_init(struct mtk_imgsys_dev *imgsys_dev)
+{
+	void __iomem *WpeRegBA = 0L;
+	void __iomem *ADLRegBA = 0L;
+	void __iomem *pWpeCtrl = 0L;
+	unsigned int HwIdx = 0;
+	uint32_t count;
+	uint32_t value;
+
+	pr_debug("%s: +.\n", __func__);
+
+	iowrite32(0xFFFFFFFF, (void *)(dipRegBA + SW_RST));
+	iowrite32(0xFFFFFFFF, (void *)(dip1RegBA + SW_RST));
+
+	for (HwIdx = 0; HwIdx < WPE_HW_SET; HwIdx++) {
+		if (HwIdx == 0)
+			WpeRegBA = wpedip1RegBA;
+		else if (HwIdx == 1)
+			WpeRegBA = wpedip2RegBA;
+		else
+			WpeRegBA = wpedip3RegBA;
+
+		/* Wpe Macro HW Reset */
+		pWpeCtrl = (void *)(WpeRegBA + SW_RST);
+		iowrite32(0xFFFFFFFF, pWpeCtrl);
+		/* Clear HW Reset */
+		iowrite32(0x0, pWpeCtrl);
+	}
+
+	if (adlARegBA || adlBRegBA) {
+		/* Reset ADL A */
+		for (HwIdx = 0; HwIdx < ADL_HW_SET; HwIdx++) {
+			if (HwIdx == 0)
+				ADLRegBA = adlARegBA;
+			else if (HwIdx == 1)
+				ADLRegBA = adlBRegBA;
+
+			if (!ADLRegBA)
+				continue;
+
+			value = ioread32((void *)(ADLRegBA + 0x300));
+			value |= ((0x1 << 8) | (0x1 << 9));
+			iowrite32(value, (ADLRegBA + 0x300));
+
+			count = 0;
+			while (count < 1000000) {
+				value = ioread32((void *)(ADLRegBA + 0x300));
+				if ((value & 0x3) == 0x3)
+					break;
+				count++;
+			}
+
+			value = ioread32((void *)(ADLRegBA + 0x300));
+			value &= ~((0x1 << 8) | (0x1 << 9));
+			iowrite32(value, (ADLRegBA + 0x300));
+		}
+	}
+
+	iowrite32(0x00CF00FF, (void *)(imgsysmainRegBA + SW_RST));
+	iowrite32(0x0, (void *)(imgsysmainRegBA + SW_RST));
+
+	iowrite32(0x0, (void *)(dipRegBA + SW_RST));
+	iowrite32(0x0, (void *)(dip1RegBA + SW_RST));
+
+	for (HwIdx = 0; HwIdx < WPE_HW_SET; HwIdx++) {
+		if (HwIdx == 0)
+			WpeRegBA = wpedip1RegBA;
+		else if (HwIdx == 1)
+			WpeRegBA = wpedip2RegBA;
+		else
+			WpeRegBA = wpedip3RegBA;
+
+		/* Wpe Macro HW Reset */
+		pWpeCtrl = (void *)(WpeRegBA + SW_RST);
+		iowrite32(0xFFFFFFFF, pWpeCtrl);
+		/* Clear HW Reset */
+		iowrite32(0x0, pWpeCtrl);
+	}
+
+	iowrite32(0x00CF00FF, (void *)(imgsysmainRegBA + SW_RST));
+	iowrite32(0x0, (void *)(imgsysmainRegBA + SW_RST));
+
+	pr_debug("%s: -.\n", __func__);
+}
+
+void imgsys_main_uninit(struct mtk_imgsys_dev *imgsys_dev)
+{
+	pr_debug("%s: +.\n", __func__);
+
+	if (imgsysmainRegBA) {
+		iounmap(imgsysmainRegBA);
+		imgsysmainRegBA = 0L;
+	}
+
+	if (wpedip1RegBA) {
+		iounmap(wpedip1RegBA);
+		wpedip1RegBA = 0L;
+	}
+
+	if (wpedip2RegBA) {
+		iounmap(wpedip2RegBA);
+		wpedip2RegBA = 0L;
+	}
+
+	if (wpedip3RegBA) {
+		iounmap(wpedip3RegBA);
+		wpedip3RegBA = 0L;
+	}
+
+	if (dipRegBA) {
+		iounmap(dipRegBA);
+		dipRegBA = 0L;
+	}
+
+	if (dip1RegBA) {
+		iounmap(dip1RegBA);
+		dip1RegBA = 0L;
+	}
+
+	if (adlARegBA) {
+		iounmap(adlARegBA);
+		adlARegBA = 0L;
+	}
+
+	if (adlBRegBA) {
+		iounmap(adlBRegBA);
+		adlBRegBA = 0L;
+	}
+
+	pr_debug("%s: -.\n", __func__);
+}
+
+void imgsys_debug_dump_routine(struct mtk_imgsys_dev *imgsys_dev,
+	const struct module_ops *imgsys_modules,
+	int imgsys_module_num, unsigned int hw_comb)
+{
+	bool module_on[IMGSYS_MOD_MAX] = {
+		false, false, false, false, false, false, false};
+	int i = 0;
+
+	dev_info(imgsys_dev->dev,
+			"%s: hw comb set: 0x%x\n",
+			__func__, hw_comb);
+
+	imgsys_dl_debug_dump(imgsys_dev, hw_comb);
+
+	if ((hw_comb & IMGSYS_ENG_WPE_EIS) || (hw_comb & IMGSYS_ENG_WPE_TNR)
+		 || (hw_comb & IMGSYS_ENG_WPE_LITE))
+		module_on[IMGSYS_MOD_WPE] = true;
+	if ((hw_comb & IMGSYS_ENG_TRAW) || (hw_comb & IMGSYS_ENG_LTR)
+		 || (hw_comb & IMGSYS_ENG_XTR))
+		module_on[IMGSYS_MOD_TRAW] = true;
+	if ((hw_comb & IMGSYS_ENG_DIP))
+		module_on[IMGSYS_MOD_DIP] = true;
+	if ((hw_comb & IMGSYS_ENG_PQDIP_A) || (hw_comb & IMGSYS_ENG_PQDIP_B))
+		module_on[IMGSYS_MOD_PQDIP] = true;
+	if ((hw_comb & IMGSYS_ENG_ME))
+		module_on[IMGSYS_MOD_ME] = true;
+	if ((hw_comb & IMGSYS_ENG_ADL_A) || (hw_comb & IMGSYS_ENG_ADL_B))
+		module_on[IMGSYS_MOD_ADL] = true;
+
+	/* in case module driver did not set imgsys_modules in module order */
+	dev_info(imgsys_dev->dev,
+			"%s: imgsys_module_num: %d\n",
+			__func__, imgsys_module_num);
+	for (i = 0 ; i < imgsys_module_num ; i++) {
+		if (module_on[imgsys_modules[i].module_id])
+			imgsys_modules[i].dump(imgsys_dev, hw_comb);
+	}
+}
+EXPORT_SYMBOL(imgsys_debug_dump_routine);
+
+void imgsys_cg_debug_dump(struct mtk_imgsys_dev *imgsys_dev)
+{
+	unsigned int i = 0;
+
+	if (!imgsysmainRegBA) {
+		dev_info(imgsys_dev->dev, "%s Unable to ioremap imgsys_top registers\n",
+								__func__);
+		dev_info(imgsys_dev->dev, "%s of_iomap fail, devnode(%s).\n",
+				__func__, imgsys_dev->dev->of_node->name);
+		return;
+	}
+
+	for (i = 0; i <= 0x500; i += 0x10) {
+		dev_info(imgsys_dev->dev, "%s: [0x%08X 0x%08X][0x%08X 0x%08X][0x%08X 0x%08X][0x%08X 0x%08X]",
+		__func__, (unsigned int)(0x15000000 + i),
+		(unsigned int)ioread32((void *)(imgsysmainRegBA + i)),
+		(unsigned int)(0x15000000 + i + 0x4),
+		(unsigned int)ioread32((void *)(imgsysmainRegBA + i + 0x4)),
+		(unsigned int)(0x15000000 + i + 0x8),
+		(unsigned int)ioread32((void *)(imgsysmainRegBA + i + 0x8)),
+		(unsigned int)(0x15000000 + i + 0xc),
+		(unsigned int)ioread32((void *)(imgsysmainRegBA + i + 0xc)));
+	}
+
+	if (!dipRegBA) {
+		dev_info(imgsys_dev->dev, "%s Unable to ioremap dip registers\n",
+								__func__);
+		dev_info(imgsys_dev->dev, "%s of_iomap fail, devnode(%s).\n",
+				__func__, imgsys_dev->dev->of_node->name);
+		return;
+	}
+
+	for (i = 0; i <= 0x100; i += 0x10) {
+		dev_info(imgsys_dev->dev, "%s: [0x%08X 0x%08X][0x%08X 0x%08X][0x%08X 0x%08X][0x%08X 0x%08X]",
+		__func__, (unsigned int)(0x15110000 + i),
+		(unsigned int)ioread32((void *)(dipRegBA + i)),
+		(unsigned int)(0x15110000 + i + 0x4),
+		(unsigned int)ioread32((void *)(dipRegBA + i + 0x4)),
+		(unsigned int)(0x15110000 + i + 0x8),
+		(unsigned int)ioread32((void *)(dipRegBA + i + 0x8)),
+		(unsigned int)(0x15110000 + i + 0xc),
+		(unsigned int)ioread32((void *)(dipRegBA + i + 0xc)));
+	}
+
+	if (!dip1RegBA) {
+		dev_info(imgsys_dev->dev, "%s Unable to ioremap dip1 registers\n",
+								__func__);
+		dev_info(imgsys_dev->dev, "%s of_iomap fail, devnode(%s).\n",
+				__func__, imgsys_dev->dev->of_node->name);
+		return;
+	}
+
+	for (i = 0; i <= 0x100; i += 0x10) {
+		dev_info(imgsys_dev->dev, "%s: [0x%08X 0x%08X][0x%08X 0x%08X][0x%08X 0x%08X][0x%08X 0x%08X]",
+		__func__, (unsigned int)(0x15130000 + i),
+		(unsigned int)ioread32((void *)(dip1RegBA + i)),
+		(unsigned int)(0x15130000 + i + 0x4),
+		(unsigned int)ioread32((void *)(dip1RegBA + i + 0x4)),
+		(unsigned int)(0x15130000 + i + 0x8),
+		(unsigned int)ioread32((void *)(dip1RegBA + i + 0x8)),
+		(unsigned int)(0x15130000 + i + 0xc),
+		(unsigned int)ioread32((void *)(dip1RegBA + i + 0xc)));
+	}
+
+	if (!wpedip1RegBA) {
+		dev_info(imgsys_dev->dev, "%s Unable to ioremap wpe_dip1 registers\n",
+								__func__);
+		dev_info(imgsys_dev->dev, "%s of_iomap fail, devnode(%s).\n",
+				__func__, imgsys_dev->dev->of_node->name);
+		return;
+	}
+
+	for (i = 0; i <= 0x100; i += 0x10) {
+		dev_info(imgsys_dev->dev, "%s: [0x%08X 0x%08X][0x%08X 0x%08X][0x%08X 0x%08X][0x%08X 0x%08X]",
+		__func__, (unsigned int)(0x15220000 + i),
+		(unsigned int)ioread32((void *)(wpedip1RegBA + i)),
+		(unsigned int)(0x15220000 + i + 0x4),
+		(unsigned int)ioread32((void *)(wpedip1RegBA + i + 0x4)),
+		(unsigned int)(0x15220000 + i + 0x8),
+		(unsigned int)ioread32((void *)(wpedip1RegBA + i + 0x8)),
+		(unsigned int)(0x15220000 + i + 0xc),
+		(unsigned int)ioread32((void *)(wpedip1RegBA + i + 0xc)));
+	}
+
+	if (!wpedip2RegBA) {
+		dev_info(imgsys_dev->dev, "%s Unable to ioremap wpe_dip2 registers\n",
+								__func__);
+		dev_info(imgsys_dev->dev, "%s of_iomap fail, devnode(%s).\n",
+				__func__, imgsys_dev->dev->of_node->name);
+		return;
+	}
+
+	for (i = 0; i <= 0x100; i += 0x10) {
+		dev_info(imgsys_dev->dev, "%s: [0x%08X 0x%08X][0x%08X 0x%08X][0x%08X 0x%08X][0x%08X 0x%08X]",
+		__func__, (unsigned int)(0x15520000 + i),
+		(unsigned int)ioread32((void *)(wpedip2RegBA + i)),
+		(unsigned int)(0x15520000 + i + 0x4),
+		(unsigned int)ioread32((void *)(wpedip2RegBA + i + 0x4)),
+		(unsigned int)(0x15520000 + i + 0x8),
+		(unsigned int)ioread32((void *)(wpedip2RegBA + i + 0x8)),
+		(unsigned int)(0x15520000 + i + 0xc),
+		(unsigned int)ioread32((void *)(wpedip2RegBA + i + 0xc)));
+	}
+
+	if (!wpedip3RegBA) {
+		dev_info(imgsys_dev->dev, "%s Unable to ioremap wpe_dip3 registers\n",
+								__func__);
+		dev_info(imgsys_dev->dev, "%s of_iomap fail, devnode(%s).\n",
+				__func__, imgsys_dev->dev->of_node->name);
+		return;
+	}
+
+	for (i = 0; i <= 0x100; i += 0x10) {
+		dev_info(imgsys_dev->dev, "%s: [0x%08X 0x%08X][0x%08X 0x%08X][0x%08X 0x%08X][0x%08X 0x%08X]",
+		__func__, (unsigned int)(0x15620000 + i),
+		(unsigned int)ioread32((void *)(wpedip3RegBA + i)),
+		(unsigned int)(0x15620000 + i + 0x4),
+		(unsigned int)ioread32((void *)(wpedip3RegBA + i + 0x4)),
+		(unsigned int)(0x15620000 + i + 0x8),
+		(unsigned int)ioread32((void *)(wpedip3RegBA + i + 0x8)),
+		(unsigned int)(0x15620000 + i + 0xc),
+		(unsigned int)ioread32((void *)(wpedip3RegBA + i + 0xc)));
+	}
+}
+
+#define log_length (64)
+void imgsys_dl_checksum_dump(struct mtk_imgsys_dev *imgsys_dev,
+	unsigned int hw_comb, char *logBuf_path,
+	char *logBuf_inport, char *logBuf_outport, int dl_path)
+{
+	/*void __iomem *imgsysmainRegBA = 0L;*/
+	/*void __iomem *wpedip1RegBA = 0L;*/
+	/*void __iomem *wpedip2RegBA = 0L;*/
+	/*void __iomem *wpedip3RegBA = 0L;*/
+	unsigned int checksum_dbg_sel = 0x0;
+	unsigned int original_dbg_sel_value = 0x0;
+	char logBuf_final[log_length * 4];
+	int debug0_req[2] = {0, 0};
+	int debug0_rdy[2] = {0, 0};
+	int debug0_checksum[2] = {0, 0};
+	int debug1_line_cnt[2] = {0, 0};
+	int debug1_pix_cnt[2] = {0, 0};
+	int debug2_line_cnt[2] = {0, 0};
+	int debug2_pix_cnt[2] = {0, 0};
+	unsigned int dbg_sel_value[2] = {0x0, 0x0};
+	unsigned int debug0_value[2] = {0x0, 0x0};
+	unsigned int debug1_value[2] = {0x0, 0x0};
+	unsigned int debug2_value[2] = {0x0, 0x0};
+	unsigned int wpe_pqdip_mux_v = 0x0;
+	unsigned int wpe_pqdip_mux2_v = 0x0;
+	unsigned int wpe_pqdip_mux3_v = 0x0;
+	char logBuf_temp[log_length];
+	int ret;
+
+	memset((char *)logBuf_final, 0x0, log_length * 4);
+	logBuf_final[strlen(logBuf_final)] = '\0';
+	memset((char *)logBuf_temp, 0x0, log_length);
+	logBuf_temp[strlen(logBuf_temp)] = '\0';
+
+	dev_info(imgsys_dev->dev,
+		"%s: + hw_comb/path(0x%x/%s) dl_path:%d, start dump\n",
+		__func__, hw_comb, logBuf_path, dl_path);
+	/* iomap registers */
+	/*imgsysmainRegBA = of_iomap(imgsys_dev->dev->of_node, REG_MAP_E_TOP);*/
+	if (!imgsysmainRegBA) {
+		dev_info(imgsys_dev->dev, "%s Unable to ioremap imgsys_top registers\n",
+								__func__);
+		dev_info(imgsys_dev->dev, "%s of_iomap fail, devnode(%s).\n",
+				__func__, imgsys_dev->dev->of_node->name);
+		return;
+	}
+
+	/*dump former engine in DL (imgsys main in port) status */
+	checksum_dbg_sel = (unsigned int)((dl_path << 1) | (0 << 0));
+	original_dbg_sel_value = (unsigned int)ioread32((void *)(imgsysmainRegBA + 0x4C));
+	original_dbg_sel_value = original_dbg_sel_value & 0xff00ffff; /*clear last time data*/
+	dbg_sel_value[0] = (original_dbg_sel_value | 0x1 |
+		((checksum_dbg_sel << 16) & 0x00ff0000));
+	writel(dbg_sel_value[0], (imgsysmainRegBA + 0x4C));
+	dbg_sel_value[0] = (unsigned int)ioread32((void *)(imgsysmainRegBA + 0x4C));
+	debug0_value[0] = (unsigned int)ioread32((void *)(imgsysmainRegBA + 0x200));
+	debug0_checksum[0] = (debug0_value[0] & 0x0000ffff);
+	debug0_rdy[0] = (debug0_value[0] & 0x00800000) >> 23;
+	debug0_req[0] = (debug0_value[0] & 0x01000000) >> 24;
+	debug1_value[0] = (unsigned int)ioread32((void *)(imgsysmainRegBA + 0x204));
+	debug1_line_cnt[0] = ((debug1_value[0] & 0xffff0000) >> 16) & 0x0000ffff;
+	debug1_pix_cnt[0] = (debug1_value[0] & 0x0000ffff);
+	debug2_value[0] = (unsigned int)ioread32((void *)(imgsysmainRegBA + 0x208));
+	debug2_line_cnt[0] = ((debug2_value[0] & 0xffff0000) >> 16) & 0x0000ffff;
+	debug2_pix_cnt[0] = (debug2_value[0] & 0x0000ffff);
+
+	/*dump later engine in DL (imgsys main out port) status */
+	checksum_dbg_sel = (unsigned int)((dl_path << 1) | (1 << 0));
+	dbg_sel_value[1] = (original_dbg_sel_value | 0x1 |
+		((checksum_dbg_sel << 16) & 0x00ff0000));
+	writel(dbg_sel_value[1], (imgsysmainRegBA + 0x4C));
+	dbg_sel_value[1] = (unsigned int)ioread32((void *)(imgsysmainRegBA + 0x4C));
+	debug0_value[1] = (unsigned int)ioread32((void *)(imgsysmainRegBA + 0x200));
+	debug0_checksum[1] = (debug0_value[1] & 0x0000ffff);
+	debug0_rdy[1] = (debug0_value[1] & 0x00800000) >> 23;
+	debug0_req[1] = (debug0_value[1] & 0x01000000) >> 24;
+	debug1_value[1] = (unsigned int)ioread32((void *)(imgsysmainRegBA + 0x204));
+	debug1_line_cnt[1] = ((debug1_value[1] & 0xffff0000) >> 16) & 0x0000ffff;
+	debug1_pix_cnt[1] = (debug1_value[1] & 0x0000ffff);
+	debug2_value[1] = (unsigned int)ioread32((void *)(imgsysmainRegBA + 0x208));
+	debug2_line_cnt[1] = ((debug2_value[1] & 0xffff0000) >> 16) & 0x0000ffff;
+	debug2_pix_cnt[1] = (debug2_value[1] & 0x0000ffff);
+
+	/* macro_comm status */
+	/*if (dl_path == IMGSYS_DL_WPE_PQDIP) {*/
+	/*wpedip1RegBA = of_iomap(imgsys_dev->dev->of_node, REG_MAP_E_WPE1_DIP1);*/
+	if (!wpedip1RegBA) {
+		dev_info(imgsys_dev->dev, "%s Unable to ioremap wpe_dip1 registers\n",
+								__func__);
+		dev_info(imgsys_dev->dev, "%s of_iomap fail, devnode(%s).\n",
+				__func__, imgsys_dev->dev->of_node->name);
+		return;
+	}
+	wpe_pqdip_mux_v = (unsigned int)ioread32((void *)(wpedip1RegBA + 0xA8));
+	/*iounmap(wpedip1RegBA);*/
+
+	/*wpedip2RegBA = of_iomap(imgsys_dev->dev->of_node, REG_MAP_E_WPE2_DIP1);*/
+	if (!wpedip2RegBA) {
+		dev_info(imgsys_dev->dev, "%s Unable to ioremap wpe_dip2 registers\n",
+								__func__);
+		dev_info(imgsys_dev->dev, "%s of_iomap fail, devnode(%s).\n",
+				__func__, imgsys_dev->dev->of_node->name);
+		return;
+	}
+	wpe_pqdip_mux2_v = (unsigned int)ioread32((void *)(wpedip2RegBA + 0xA8));
+	/*iounmap(wpedip2RegBA);*/
+
+	/*wpedip3RegBA = of_iomap(imgsys_dev->dev->of_node, REG_MAP_E_WPE3_DIP1);*/
+	if (!wpedip3RegBA) {
+		dev_info(imgsys_dev->dev, "%s Unable to ioremap wpe_dip3 registers\n",
+								__func__);
+		dev_info(imgsys_dev->dev, "%s of_iomap fail, devnode(%s).\n",
+				__func__, imgsys_dev->dev->of_node->name);
+		return;
+	}
+	wpe_pqdip_mux3_v = (unsigned int)ioread32((void *)(wpedip3RegBA + 0xA8));
+	/*iounmap(wpedip3RegBA);*/
+	/*}*/
+
+	/* dump information */
+	if (dl_path == IMGSYS_DL_WPET_TRAW) {
+	} else {
+		if (debug0_req[0] == 1) {
+			snprintf(logBuf_temp, log_length,
+				"%s req to send data to %s/",
+				logBuf_inport, logBuf_outport);
+		} else {
+			snprintf(logBuf_temp, log_length,
+				"%s not send data to %s/",
+				logBuf_inport, logBuf_outport);
+		}
+		strncat(logBuf_final, logBuf_temp, strlen(logBuf_temp));
+		memset((char *)logBuf_temp, 0x0, log_length);
+		logBuf_temp[strlen(logBuf_temp)] = '\0';
+		if (debug0_rdy[0] == 1) {
+			ret = snprintf(logBuf_temp, log_length,
+				"%s rdy to receive data from %s",
+				logBuf_outport, logBuf_inport);
+			if (ret >= log_length)
+				dev_dbg(imgsys_dev->dev, "%s: string truncated\n", __func__);
+		} else {
+			ret = snprintf(logBuf_temp, log_length,
+				"%s not rdy to receive data from %s",
+				logBuf_outport, logBuf_inport);
+			if (ret >= log_length)
+				dev_dbg(imgsys_dev->dev, "%s: string truncated\n", __func__);
+		}
+		strncat(logBuf_final, logBuf_temp, strlen(logBuf_temp));
+		dev_info(imgsys_dev->dev,
+			"%s: %s", __func__, logBuf_final);
+
+		memset((char *)logBuf_final, 0x0, log_length * 4);
+		logBuf_final[strlen(logBuf_final)] = '\0';
+		memset((char *)logBuf_temp, 0x0, log_length);
+		logBuf_temp[strlen(logBuf_temp)] = '\0';
+		if (debug0_req[1] == 1) {
+			ret = snprintf(logBuf_temp, log_length,
+				"%s req to send data to %sPIPE/",
+				logBuf_outport, logBuf_outport);
+			if (ret >= log_length)
+				dev_dbg(imgsys_dev->dev, "%s: string truncated\n", __func__);
+		} else {
+			ret = snprintf(logBuf_temp, log_length,
+				"%s not send data to %sPIPE/",
+				logBuf_outport, logBuf_outport);
+			if (ret >= log_length)
+				dev_dbg(imgsys_dev->dev, "%s: string truncated\n", __func__);
+		}
+		strncat(logBuf_final, logBuf_temp, strlen(logBuf_temp));
+		memset((char *)logBuf_temp, 0x0, log_length);
+		logBuf_temp[strlen(logBuf_temp)] = '\0';
+		if (debug0_rdy[1] == 1) {
+			ret = snprintf(logBuf_temp, log_length,
+				"%sPIPE rdy to receive data from %s",
+				logBuf_outport, logBuf_outport);
+			if (ret >= log_length)
+				dev_dbg(imgsys_dev->dev, "%s: string truncated\n", __func__);
+		} else {
+			ret = snprintf(logBuf_temp, log_length,
+				"%sPIPE not rdy to receive data from %s",
+				logBuf_outport, logBuf_outport);
+			if (ret >= log_length)
+				dev_dbg(imgsys_dev->dev, "%s: string truncated\n", __func__);
+		}
+		strncat(logBuf_final, logBuf_temp, strlen(logBuf_temp));
+		dev_info(imgsys_dev->dev,
+			"%s: %s", __func__, logBuf_final);
+		dev_info(imgsys_dev->dev,
+			"%s: in_req/in_rdy/out_req/out_rdy = %d/%d/%d/%d,(cheskcum: in/out) = (%d/%d)",
+			__func__,
+			debug0_req[0], debug0_rdy[0],
+			debug0_req[1], debug0_rdy[1],
+			debug0_checksum[0], debug0_checksum[1]);
+		dev_info(imgsys_dev->dev,
+			"%s: info01 in_line/in_pix/out_line/out_pix = %d/%d/%d/%d",
+			__func__,
+			debug1_line_cnt[0], debug1_pix_cnt[0], debug1_line_cnt[1],
+			debug1_pix_cnt[1]);
+		dev_info(imgsys_dev->dev,
+			"%s: info02 in_line/in_pix/out_line/out_pix = %d/%d/%d/%d",
+			__func__,
+			debug2_line_cnt[0], debug2_pix_cnt[0], debug2_line_cnt[1],
+			debug2_pix_cnt[1]);
+	}
+	dev_info(imgsys_dev->dev, "%s: ===(%s): %s DBG INFO===",
+		__func__, logBuf_path, logBuf_inport);
+	dev_info(imgsys_dev->dev, "%s:  0x%08X %08X", __func__,
+		(unsigned int)(0x15000000 + 0x4C), dbg_sel_value[0]);
+	dev_info(imgsys_dev->dev, "%s:  0x%08X %08X", __func__,
+		(unsigned int)(0x15000000 + 0x200), debug0_value[0]);
+	dev_info(imgsys_dev->dev, "%s:  0x%08X %08X", __func__,
+		(unsigned int)(0x15000000 + 0x204), debug1_value[0]);
+	dev_info(imgsys_dev->dev, "%s:  0x%08X %08X", __func__,
+		(unsigned int)(0x15000000 + 0x208), debug2_value[0]);
+
+	dev_info(imgsys_dev->dev, "%s: ===(%s): %s DBG INFO===",
+		__func__, logBuf_path, logBuf_outport);
+	dev_info(imgsys_dev->dev, "%s:  0x%08X %08X", __func__,
+		(unsigned int)(0x15000000 + 0x4C), dbg_sel_value[1]);
+	dev_info(imgsys_dev->dev, "%s:  0x%08X %08X", __func__,
+		(unsigned int)(0x15000000 + 0x200), debug0_value[1]);
+	dev_info(imgsys_dev->dev, "%s:  0x%08X %08X", __func__,
+		(unsigned int)(0x15000000 + 0x204), debug1_value[1]);
+	dev_info(imgsys_dev->dev, "%s:  0x%08X %08X", __func__,
+		(unsigned int)(0x15000000 + 0x208), debug2_value[1]);
+
+	dev_info(imgsys_dev->dev, "%s: ===(%s): IMGMAIN CG INFO===",
+		__func__, logBuf_path);
+	dev_info(imgsys_dev->dev, "%s: CG_CON  0x%08X %08X", __func__,
+		(unsigned int)(0x15000000 + 0x0),
+		(unsigned int)ioread32((void *)(imgsysmainRegBA + 0x0)));
+	dev_info(imgsys_dev->dev, "%s: CG_SET  0x%08X %08X", __func__,
+		(unsigned int)(0x15000000 + 0x4),
+		(unsigned int)ioread32((void *)(imgsysmainRegBA + 0x4)));
+	dev_info(imgsys_dev->dev, "%s: CG_CLR  0x%08X %08X", __func__,
+		(unsigned int)(0x15000000 + 0x8),
+		(unsigned int)ioread32((void *)(imgsysmainRegBA + 0x8)));
+
+	/*if (dl_path == IMGSYS_DL_WPE_PQDIP) {*/
+	dev_info(imgsys_dev->dev, "%s:  0x%08X %08X", __func__,
+		(unsigned int)(0x15220000 + 0xA8), wpe_pqdip_mux_v);
+	dev_info(imgsys_dev->dev, "%s:  0x%08X %08X", __func__,
+		(unsigned int)(0x15520000 + 0xA8), wpe_pqdip_mux2_v);
+	dev_info(imgsys_dev->dev, "%s:  0x%08X %08X", __func__,
+		(unsigned int)(0x15620000 + 0xA8), wpe_pqdip_mux3_v);
+	/*}*/
+	/*iounmap(imgsysmainRegBA);*/
+}
+
+void imgsys_dl_debug_dump(struct mtk_imgsys_dev *imgsys_dev, unsigned int hw_comb)
+{
+	int dl_path = 0;
+	char logBuf_path[log_length];
+	char logBuf_inport[log_length];
+	char logBuf_outport[log_length];
+	char logBuf_eng[log_length];
+	int i = 0, get = false;
+
+	memset((char *)logBuf_path, 0x0, log_length);
+	logBuf_path[strlen(logBuf_path)] = '\0';
+	memset((char *)logBuf_inport, 0x0, log_length);
+	logBuf_inport[strlen(logBuf_inport)] = '\0';
+	memset((char *)logBuf_outport, 0x0, log_length);
+	logBuf_outport[strlen(logBuf_outport)] = '\0';
+
+	for (i = 0 ; i < DL_CHECK_ENG_NUM ; i++) {
+		memset((char *)logBuf_eng, 0x0, log_length);
+		logBuf_eng[strlen(logBuf_eng)] = '\0';
+		if (hw_comb & dbg_engine_name_list[i].eng_e) {
+			if (get) {
+				snprintf(logBuf_eng, log_length, "-%s",
+					dbg_engine_name_list[i].eng_name);
+			} else {
+				snprintf(logBuf_eng, log_length, "%s",
+					dbg_engine_name_list[i].eng_name);
+			}
+			get = true;
+		}
+		strncat(logBuf_path, logBuf_eng, strlen(logBuf_eng));
+	}
+	memset((char *)logBuf_eng, 0x0, log_length);
+	logBuf_eng[strlen(logBuf_eng)] = '\0';
+	snprintf(logBuf_eng, log_length, "%s", " FAIL");
+	strncat(logBuf_path, logBuf_eng, strlen(logBuf_eng));
+
+	dev_info(imgsys_dev->dev, "%s: %s\n",
+			__func__, logBuf_path);
+	switch (hw_comb) {
+	/*DL checksum case*/
+	case (IMGSYS_ENG_WPE_EIS | IMGSYS_ENG_TRAW):
+		dl_path = IMGSYS_DL_WPEE_TRAW;
+		snprintf(logBuf_inport, log_length, "%s",
+			"WPE_EIS");
+		snprintf(logBuf_outport, log_length, "%s",
+			"TRAW");
+		imgsys_dl_checksum_dump(imgsys_dev, hw_comb,
+			logBuf_path, logBuf_inport, logBuf_outport, dl_path);
+		break;
+	case (IMGSYS_ENG_WPE_EIS | IMGSYS_ENG_LTR):
+		dl_path = IMGSYS_DL_WPEE_TRAW;
+		snprintf(logBuf_inport, log_length, "%s",
+			"WPE_EIS");
+		snprintf(logBuf_outport, log_length, "%s",
+			"LTRAW");
+		imgsys_dl_checksum_dump(imgsys_dev, hw_comb,
+			logBuf_path, logBuf_inport, logBuf_outport, dl_path);
+		break;
+	case (IMGSYS_ENG_WPE_EIS | IMGSYS_ENG_XTR):
+		dl_path = IMGSYS_DL_WPEE_XTRAW;
+		snprintf(logBuf_inport, log_length, "%s",
+			"WPE_EIS");
+		snprintf(logBuf_outport, log_length, "%s",
+			"XTRAW");
+		imgsys_dl_checksum_dump(imgsys_dev, hw_comb,
+			logBuf_path, logBuf_inport, logBuf_outport, dl_path);
+		break;
+	case (IMGSYS_ENG_WPE_TNR | IMGSYS_ENG_TRAW):
+		dl_path = IMGSYS_DL_WPET_TRAW;
+		snprintf(logBuf_inport, log_length, "%s",
+			"WPE_TNR");
+		snprintf(logBuf_outport, log_length, "%s",
+			"TRAW");
+		imgsys_dl_checksum_dump(imgsys_dev, hw_comb,
+			logBuf_path, logBuf_inport, logBuf_outport, dl_path);
+		break;
+	case (IMGSYS_ENG_WPE_TNR | IMGSYS_ENG_LTR):
+		dl_path = IMGSYS_DL_WPET_TRAW;
+		snprintf(logBuf_inport, log_length, "%s",
+			"WPE_TNR");
+		snprintf(logBuf_outport, log_length, "%s",
+			"LTRAW");
+		imgsys_dl_checksum_dump(imgsys_dev, hw_comb,
+			logBuf_path, logBuf_inport, logBuf_outport, dl_path);
+		break;
+	case (IMGSYS_ENG_WPE_TNR | IMGSYS_ENG_XTR):
+		dl_path = IMGSYS_DL_WPET_XTRAW;
+		snprintf(logBuf_inport, log_length, "%s",
+			"WPE_TNR");
+		snprintf(logBuf_outport, log_length, "%s",
+			"XTRAW");
+		imgsys_dl_checksum_dump(imgsys_dev, hw_comb,
+			logBuf_path, logBuf_inport, logBuf_outport, dl_path);
+		break;
+	case (IMGSYS_ENG_WPE_LITE | IMGSYS_ENG_TRAW):
+		dl_path = IMGSYS_DL_WPET_TRAW;
+		snprintf(logBuf_inport, log_length, "%s",
+			"WPE_LITE");
+		snprintf(logBuf_outport, log_length, "%s",
+			"TRAW");
+		imgsys_dl_checksum_dump(imgsys_dev, hw_comb,
+			logBuf_path, logBuf_inport, logBuf_outport, dl_path);
+		dev_info(imgsys_dev->dev,
+			"%s: we dont have checksum for WPELITE DL TRAW\n",
+			__func__);
+		break;
+	case (IMGSYS_ENG_WPE_LITE | IMGSYS_ENG_LTR):
+		dl_path = IMGSYS_DL_WPET_TRAW;
+		snprintf(logBuf_inport, log_length, "%s",
+			"WPE_LITE");
+		snprintf(logBuf_outport, log_length, "%s",
+			"LTRAW");
+		imgsys_dl_checksum_dump(imgsys_dev, hw_comb,
+			logBuf_path, logBuf_inport, logBuf_outport, dl_path);
+		dev_info(imgsys_dev->dev,
+			"%s: we dont have checksum for WPELITE DL LTRAW\n",
+			__func__);
+		break;
+	case (IMGSYS_ENG_WPE_LITE | IMGSYS_ENG_XTR):
+		dl_path = IMGSYS_DL_WPET_TRAW;
+		snprintf(logBuf_inport, log_length, "%s",
+			"WPE_LITE");
+		snprintf(logBuf_outport, log_length, "%s",
+			"XTRAW");
+		imgsys_dl_checksum_dump(imgsys_dev, hw_comb,
+			logBuf_path, logBuf_inport, logBuf_outport, dl_path);
+		dev_info(imgsys_dev->dev,
+			"%s: we dont have checksum for WPELITE DL XTRAW\n",
+			__func__);
+		break;
+	case (IMGSYS_ENG_WPE_EIS | IMGSYS_ENG_DIP):
+	case (IMGSYS_ENG_WPE_EIS | IMGSYS_ENG_DIP | IMGSYS_ENG_PQDIP_A):
+	case (IMGSYS_ENG_WPE_EIS | IMGSYS_ENG_DIP | IMGSYS_ENG_PQDIP_B):
+	case (IMGSYS_ENG_WPE_EIS | IMGSYS_ENG_DIP | IMGSYS_ENG_PQDIP_A |
+		IMGSYS_ENG_PQDIP_B):
+		dl_path = IMGSYS_DL_WPEE_DIP;
+		snprintf(logBuf_inport, log_length, "%s",
+			"WPE_EIS");
+		snprintf(logBuf_outport, log_length, "%s",
+			 "DIP");
+		imgsys_dl_checksum_dump(imgsys_dev, hw_comb,
+			logBuf_path, logBuf_inport, logBuf_outport, dl_path);
+		/**/
+		memset((char *)logBuf_inport, 0x0, log_length);
+		logBuf_inport[strlen(logBuf_inport)] = '\0';
+		memset((char *)logBuf_outport, 0x0, log_length);
+		logBuf_outport[strlen(logBuf_outport)] = '\0';
+		dl_path = IMGSYS_DL_DIP_PQDIPA;
+		snprintf(logBuf_inport, log_length, "%s",
+			"DIP");
+		snprintf(logBuf_outport, log_length, "%s",
+			"PQDIPA");
+		imgsys_dl_checksum_dump(imgsys_dev, hw_comb,
+			logBuf_path, logBuf_inport, logBuf_outport, dl_path);
+		/**/
+		memset((char *)logBuf_inport, 0x0, log_length);
+		logBuf_inport[strlen(logBuf_inport)] = '\0';
+		memset((char *)logBuf_outport, 0x0, log_length);
+		logBuf_outport[strlen(logBuf_outport)] = '\0';
+		dl_path = IMGSYS_DL_DIP_PQDIPB;
+		snprintf(logBuf_inport, log_length, "%s",
+			"DIP");
+		snprintf(logBuf_outport, log_length, "%s",
+			"PQDIPB");
+		imgsys_dl_checksum_dump(imgsys_dev, hw_comb,
+			logBuf_path, logBuf_inport, logBuf_outport, dl_path);
+		break;
+	case (IMGSYS_ENG_WPE_TNR | IMGSYS_ENG_DIP):
+	case (IMGSYS_ENG_WPE_TNR | IMGSYS_ENG_DIP | IMGSYS_ENG_PQDIP_A):
+	case (IMGSYS_ENG_WPE_TNR | IMGSYS_ENG_DIP | IMGSYS_ENG_PQDIP_B):
+	case (IMGSYS_ENG_WPE_TNR | IMGSYS_ENG_DIP | IMGSYS_ENG_PQDIP_A |
+		IMGSYS_ENG_PQDIP_B):
+		dl_path = IMGSYS_DL_WPET_DIP;
+		snprintf(logBuf_inport, log_length, "%s",
+			"WPE_TNR");
+		snprintf(logBuf_outport, log_length, "%s",
+			"DIP");
+		imgsys_dl_checksum_dump(imgsys_dev, hw_comb,
+			logBuf_path, logBuf_inport, logBuf_outport, dl_path);
+		/**/
+		memset((char *)logBuf_inport, 0x0, log_length);
+		logBuf_inport[strlen(logBuf_inport)] = '\0';
+		memset((char *)logBuf_outport, 0x0, log_length);
+		logBuf_outport[strlen(logBuf_outport)] = '\0';
+		dl_path = IMGSYS_DL_DIP_PQDIPA;
+		snprintf(logBuf_inport, log_length, "%s",
+			"DIP");
+		snprintf(logBuf_outport, log_length, "%s",
+			"PQDIPA");
+		imgsys_dl_checksum_dump(imgsys_dev, hw_comb,
+			logBuf_path, logBuf_inport, logBuf_outport, dl_path);
+		/**/
+		memset((char *)logBuf_inport, 0x0, log_length);
+		logBuf_inport[strlen(logBuf_inport)] = '\0';
+		memset((char *)logBuf_outport, 0x0, log_length);
+		logBuf_outport[strlen(logBuf_outport)] = '\0';
+		dl_path = IMGSYS_DL_DIP_PQDIPB;
+		snprintf(logBuf_inport, log_length, "%s",
+			"DIP");
+		snprintf(logBuf_outport, log_length, "%s",
+			"PQDIPB");
+		imgsys_dl_checksum_dump(imgsys_dev, hw_comb,
+			logBuf_path, logBuf_inport, logBuf_outport, dl_path);
+		break;
+	case (IMGSYS_ENG_WPE_EIS | IMGSYS_ENG_PQDIP_A):
+	case (IMGSYS_ENG_WPE_EIS | IMGSYS_ENG_PQDIP_B):
+	case (IMGSYS_ENG_WPE_EIS | IMGSYS_ENG_PQDIP_A |
+		IMGSYS_ENG_PQDIP_B):
+		dl_path = IMGSYS_DL_WPE_PQDIP;
+		snprintf(logBuf_inport, log_length, "%s",
+			"WPE_EIS");
+		snprintf(logBuf_outport, log_length, "%s",
+			"PQDIP");
+		imgsys_dl_checksum_dump(imgsys_dev, hw_comb,
+			logBuf_path, logBuf_inport, logBuf_outport, dl_path);
+		break;
+	case (IMGSYS_ENG_WPE_TNR | IMGSYS_ENG_PQDIP_A):
+	case (IMGSYS_ENG_WPE_TNR | IMGSYS_ENG_PQDIP_B):
+	case (IMGSYS_ENG_WPE_TNR | IMGSYS_ENG_PQDIP_A |
+		IMGSYS_ENG_PQDIP_B):
+		dl_path = IMGSYS_DL_WPE_PQDIP;
+		snprintf(logBuf_inport, log_length, "%s",
+			"WPE_TNR");
+		snprintf(logBuf_outport, log_length, "%s",
+			"PQDIP");
+		imgsys_dl_checksum_dump(imgsys_dev, hw_comb,
+			logBuf_path, logBuf_inport, logBuf_outport, dl_path);
+		break;
+	case (IMGSYS_ENG_WPE_EIS | IMGSYS_ENG_TRAW | IMGSYS_ENG_DIP):
+	case (IMGSYS_ENG_WPE_EIS | IMGSYS_ENG_TRAW | IMGSYS_ENG_DIP |
+		IMGSYS_ENG_PQDIP_A):
+	case (IMGSYS_ENG_WPE_EIS | IMGSYS_ENG_TRAW | IMGSYS_ENG_DIP |
+		IMGSYS_ENG_PQDIP_B):
+	case (IMGSYS_ENG_WPE_EIS | IMGSYS_ENG_TRAW | IMGSYS_ENG_DIP |
+		IMGSYS_ENG_PQDIP_A | IMGSYS_ENG_PQDIP_B):
+		dl_path = IMGSYS_DL_WPEE_TRAW;
+		snprintf(logBuf_inport, log_length, "%s",
+			"WPE_EIS");
+		snprintf(logBuf_outport, log_length, "%s",
+			"TRAW");
+		imgsys_dl_checksum_dump(imgsys_dev, hw_comb,
+			logBuf_path, logBuf_inport, logBuf_outport, dl_path);
+		/**/
+		memset((char *)logBuf_inport, 0x0, log_length);
+		logBuf_inport[strlen(logBuf_inport)] = '\0';
+		memset((char *)logBuf_outport, 0x0, log_length);
+		logBuf_outport[strlen(logBuf_outport)] = '\0';
+		dl_path = IMGSYS_DL_TRAW_DIP;
+		snprintf(logBuf_inport, log_length, "%s",
+			"TRAW");
+		snprintf(logBuf_outport, log_length, "%s",
+			"DIP");
+		imgsys_dl_checksum_dump(imgsys_dev, hw_comb,
+			logBuf_path, logBuf_inport, logBuf_outport, dl_path);
+		/**/
+		memset((char *)logBuf_inport, 0x0, log_length);
+		logBuf_inport[strlen(logBuf_inport)] = '\0';
+		memset((char *)logBuf_outport, 0x0, log_length);
+		logBuf_outport[strlen(logBuf_outport)] = '\0';
+		dl_path = IMGSYS_DL_DIP_PQDIPA;
+		snprintf(logBuf_inport, log_length, "%s",
+			"DIP");
+		snprintf(logBuf_outport, log_length, "%s",
+			"PQDIPA");
+		imgsys_dl_checksum_dump(imgsys_dev, hw_comb,
+			logBuf_path, logBuf_inport, logBuf_outport, dl_path);
+		/**/
+		memset((char *)logBuf_inport, 0x0, log_length);
+		logBuf_inport[strlen(logBuf_inport)] = '\0';
+		memset((char *)logBuf_outport, 0x0, log_length);
+		logBuf_outport[strlen(logBuf_outport)] = '\0';
+		dl_path = IMGSYS_DL_DIP_PQDIPB;
+		snprintf(logBuf_inport, log_length, "%s",
+			"DIP");
+		snprintf(logBuf_outport, log_length, "%s",
+			"PQDIPB");
+		imgsys_dl_checksum_dump(imgsys_dev, hw_comb,
+			logBuf_path, logBuf_inport, logBuf_outport, dl_path);
+		break;
+	case (IMGSYS_ENG_WPE_TNR | IMGSYS_ENG_TRAW | IMGSYS_ENG_DIP):
+	case (IMGSYS_ENG_WPE_TNR | IMGSYS_ENG_TRAW | IMGSYS_ENG_DIP |
+		IMGSYS_ENG_PQDIP_A):
+	case (IMGSYS_ENG_WPE_TNR | IMGSYS_ENG_TRAW | IMGSYS_ENG_DIP |
+		IMGSYS_ENG_PQDIP_B):
+	case (IMGSYS_ENG_WPE_TNR | IMGSYS_ENG_TRAW | IMGSYS_ENG_DIP |
+		IMGSYS_ENG_PQDIP_A | IMGSYS_ENG_PQDIP_B):
+		dl_path = IMGSYS_DL_TRAW_DIP;
+		snprintf(logBuf_inport, log_length, "%s",
+			"TRAW");
+		snprintf(logBuf_outport, log_length, "%s",
+			"DIP");
+		imgsys_dl_checksum_dump(imgsys_dev, hw_comb,
+			logBuf_path, logBuf_inport, logBuf_outport, dl_path);
+		/**/
+		memset((char *)logBuf_inport, 0x0, log_length);
+		logBuf_inport[strlen(logBuf_inport)] = '\0';
+		memset((char *)logBuf_outport, 0x0, log_length);
+		logBuf_outport[strlen(logBuf_outport)] = '\0';
+		dl_path = IMGSYS_DL_WPET_DIP;
+		snprintf(logBuf_inport, log_length, "%s",
+			"WPE_TNR");
+		snprintf(logBuf_outport, log_length, "%s",
+			"DIP");
+		imgsys_dl_checksum_dump(imgsys_dev, hw_comb,
+			logBuf_path, logBuf_inport, logBuf_outport, dl_path);
+		/**/
+		memset((char *)logBuf_inport, 0x0, log_length);
+		logBuf_inport[strlen(logBuf_inport)] = '\0';
+		memset((char *)logBuf_outport, 0x0, log_length);
+		logBuf_outport[strlen(logBuf_outport)] = '\0';
+		dl_path = IMGSYS_DL_DIP_PQDIPA;
+		snprintf(logBuf_inport, log_length, "%s",
+			"DIP");
+		snprintf(logBuf_outport, log_length, "%s",
+			"PQDIPA");
+		imgsys_dl_checksum_dump(imgsys_dev, hw_comb,
+			logBuf_path, logBuf_inport, logBuf_outport, dl_path);
+		/**/
+		memset((char *)logBuf_inport, 0x0, log_length);
+		logBuf_inport[strlen(logBuf_inport)] = '\0';
+		memset((char *)logBuf_outport, 0x0, log_length);
+		logBuf_outport[strlen(logBuf_outport)] = '\0';
+		dl_path = IMGSYS_DL_DIP_PQDIPB;
+		snprintf(logBuf_inport, log_length, "%s",
+			"DIP");
+		snprintf(logBuf_outport, log_length, "%s",
+			"PQDIPB");
+		imgsys_dl_checksum_dump(imgsys_dev, hw_comb,
+			logBuf_path, logBuf_inport, logBuf_outport, dl_path);
+		break;
+	case (IMGSYS_ENG_WPE_LITE | IMGSYS_ENG_TRAW | IMGSYS_ENG_DIP):
+	case (IMGSYS_ENG_WPE_LITE | IMGSYS_ENG_TRAW | IMGSYS_ENG_DIP |
+		IMGSYS_ENG_PQDIP_A):
+	case (IMGSYS_ENG_WPE_LITE | IMGSYS_ENG_TRAW | IMGSYS_ENG_DIP |
+		IMGSYS_ENG_PQDIP_B):
+	case (IMGSYS_ENG_WPE_LITE | IMGSYS_ENG_TRAW | IMGSYS_ENG_DIP |
+		IMGSYS_ENG_PQDIP_A | IMGSYS_ENG_PQDIP_B):
+		dl_path = IMGSYS_DL_WPEL_TRAW;
+		snprintf(logBuf_inport, log_length, "%s",
+			"WPE_LITE");
+		snprintf(logBuf_outport, log_length, "%s",
+			"TRAW");
+		imgsys_dl_checksum_dump(imgsys_dev, hw_comb,
+			logBuf_path, logBuf_inport, logBuf_outport, dl_path);
+		dev_info(imgsys_dev->dev,
+			"%s: we dont have checksum for WPELITE DL TRAW\n",
+			__func__);
+		/**/
+		memset((char *)logBuf_inport, 0x0, log_length);
+		logBuf_inport[strlen(logBuf_inport)] = '\0';
+		memset((char *)logBuf_outport, 0x0, log_length);
+		logBuf_outport[strlen(logBuf_outport)] = '\0';
+		dl_path = IMGSYS_DL_TRAW_DIP;
+		snprintf(logBuf_inport, log_length, "%s",
+			"TRAW");
+		snprintf(logBuf_outport, log_length, "%s",
+			"DIP");
+		imgsys_dl_checksum_dump(imgsys_dev, hw_comb,
+			logBuf_path, logBuf_inport, logBuf_outport, dl_path);
+		/**/
+		memset((char *)logBuf_inport, 0x0, log_length);
+		logBuf_inport[strlen(logBuf_inport)] = '\0';
+		memset((char *)logBuf_outport, 0x0, log_length);
+		logBuf_outport[strlen(logBuf_outport)] = '\0';
+		dl_path = IMGSYS_DL_DIP_PQDIPA;
+		snprintf(logBuf_inport, log_length, "%s",
+			"DIP");
+		snprintf(logBuf_outport, log_length, "%s",
+			"PQDIPA");
+		imgsys_dl_checksum_dump(imgsys_dev, hw_comb,
+			logBuf_path, logBuf_inport, logBuf_outport, dl_path);
+		/**/
+		memset((char *)logBuf_inport, 0x0, log_length);
+		logBuf_inport[strlen(logBuf_inport)] = '\0';
+		memset((char *)logBuf_outport, 0x0, log_length);
+		logBuf_outport[strlen(logBuf_outport)] = '\0';
+		dl_path = IMGSYS_DL_DIP_PQDIPB;
+		snprintf(logBuf_inport, log_length, "%s",
+			"DIP");
+		snprintf(logBuf_outport, log_length, "%s",
+			"PQDIPB");
+		imgsys_dl_checksum_dump(imgsys_dev, hw_comb,
+			logBuf_path, logBuf_inport, logBuf_outport, dl_path);
+		break;
+	case (IMGSYS_ENG_WPE_EIS | IMGSYS_ENG_WPE_TNR | IMGSYS_ENG_DIP):
+	case (IMGSYS_ENG_WPE_EIS | IMGSYS_ENG_WPE_TNR | IMGSYS_ENG_DIP |
+		IMGSYS_ENG_PQDIP_A):
+	case (IMGSYS_ENG_WPE_EIS | IMGSYS_ENG_WPE_TNR | IMGSYS_ENG_DIP |
+		IMGSYS_ENG_PQDIP_B):
+	case (IMGSYS_ENG_WPE_EIS | IMGSYS_ENG_WPE_TNR | IMGSYS_ENG_DIP |
+		IMGSYS_ENG_PQDIP_A | IMGSYS_ENG_PQDIP_B):
+		dl_path = IMGSYS_DL_WPEE_DIP;
+		snprintf(logBuf_inport, log_length, "%s",
+			"WPE_EIS");
+		snprintf(logBuf_outport, log_length, "%s",
+			"DIP");
+		imgsys_dl_checksum_dump(imgsys_dev, hw_comb,
+			logBuf_path, logBuf_inport, logBuf_outport, dl_path);
+		/**/
+		memset((char *)logBuf_inport, 0x0, log_length);
+		logBuf_inport[strlen(logBuf_inport)] = '\0';
+		memset((char *)logBuf_outport, 0x0, log_length);
+		logBuf_outport[strlen(logBuf_outport)] = '\0';
+		dl_path = IMGSYS_DL_WPET_DIP;
+		snprintf(logBuf_inport, log_length, "%s",
+			"WPE_TNR");
+		snprintf(logBuf_outport, log_length, "%s",
+			"DIP");
+		imgsys_dl_checksum_dump(imgsys_dev, hw_comb,
+			logBuf_path, logBuf_inport, logBuf_outport, dl_path);
+		/**/
+		memset((char *)logBuf_inport, 0x0, log_length);
+		logBuf_inport[strlen(logBuf_inport)] = '\0';
+		memset((char *)logBuf_outport, 0x0, log_length);
+		logBuf_outport[strlen(logBuf_outport)] = '\0';
+		dl_path = IMGSYS_DL_DIP_PQDIPA;
+		snprintf(logBuf_inport, log_length, "%s",
+			"DIP");
+		snprintf(logBuf_outport, log_length, "%s",
+			"PQDIPA");
+		imgsys_dl_checksum_dump(imgsys_dev, hw_comb,
+			logBuf_path, logBuf_inport, logBuf_outport, dl_path);
+		/**/
+		memset((char *)logBuf_inport, 0x0, log_length);
+		logBuf_inport[strlen(logBuf_inport)] = '\0';
+		memset((char *)logBuf_outport, 0x0, log_length);
+		logBuf_outport[strlen(logBuf_outport)] = '\0';
+		dl_path = IMGSYS_DL_DIP_PQDIPB;
+		snprintf(logBuf_inport, log_length, "%s",
+			"DIP");
+		snprintf(logBuf_outport, log_length, "%s",
+			"PQDIPB");
+		imgsys_dl_checksum_dump(imgsys_dev, hw_comb,
+			logBuf_path, logBuf_inport, logBuf_outport, dl_path);
+		break;
+	case (IMGSYS_ENG_WPE_EIS | IMGSYS_ENG_WPE_TNR | IMGSYS_ENG_TRAW |
+		IMGSYS_ENG_DIP):
+	case (IMGSYS_ENG_WPE_EIS | IMGSYS_ENG_WPE_TNR | IMGSYS_ENG_TRAW |
+		IMGSYS_ENG_DIP | IMGSYS_ENG_PQDIP_A):
+	case (IMGSYS_ENG_WPE_EIS | IMGSYS_ENG_WPE_TNR | IMGSYS_ENG_TRAW |
+		IMGSYS_ENG_DIP | IMGSYS_ENG_PQDIP_B):
+	case (IMGSYS_ENG_WPE_EIS | IMGSYS_ENG_WPE_TNR | IMGSYS_ENG_TRAW |
+		IMGSYS_ENG_DIP | IMGSYS_ENG_PQDIP_A | IMGSYS_ENG_PQDIP_B):
+		dev_info(imgsys_dev->dev,
+			"%s: TOBE CHECKED SELECTION BASED ON FMT..\n",
+			__func__);
+		break;
+	case (IMGSYS_ENG_TRAW | IMGSYS_ENG_DIP):
+	case (IMGSYS_ENG_TRAW | IMGSYS_ENG_DIP | IMGSYS_ENG_PQDIP_A):
+	case (IMGSYS_ENG_TRAW | IMGSYS_ENG_DIP | IMGSYS_ENG_PQDIP_B):
+	case (IMGSYS_ENG_TRAW | IMGSYS_ENG_DIP | IMGSYS_ENG_PQDIP_A |
+		IMGSYS_ENG_PQDIP_B):
+		dl_path = IMGSYS_DL_TRAW_DIP;
+		snprintf(logBuf_inport, log_length, "%s",
+			"TRAW");
+		snprintf(logBuf_outport, log_length, "%s",
+			"DIP");
+		imgsys_dl_checksum_dump(imgsys_dev, hw_comb,
+			logBuf_path, logBuf_inport, logBuf_outport, dl_path);
+		/**/
+		memset((char *)logBuf_inport, 0x0, log_length);
+		logBuf_inport[strlen(logBuf_inport)] = '\0';
+		memset((char *)logBuf_outport, 0x0, log_length);
+		logBuf_outport[strlen(logBuf_outport)] = '\0';
+		dl_path = IMGSYS_DL_DIP_PQDIPA;
+		snprintf(logBuf_inport, log_length, "%s",
+			"DIP");
+		snprintf(logBuf_outport, log_length, "%s",
+			"PQDIPA");
+		imgsys_dl_checksum_dump(imgsys_dev, hw_comb,
+			logBuf_path, logBuf_inport, logBuf_outport, dl_path);
+		/**/
+		memset((char *)logBuf_inport, 0x0, log_length);
+		logBuf_inport[strlen(logBuf_inport)] = '\0';
+		memset((char *)logBuf_outport, 0x0, log_length);
+		logBuf_outport[strlen(logBuf_outport)] = '\0';
+		dl_path = IMGSYS_DL_DIP_PQDIPB;
+		snprintf(logBuf_inport, log_length, "%s",
+			"DIP");
+		snprintf(logBuf_outport, log_length, "%s",
+			"PQDIPB");
+		imgsys_dl_checksum_dump(imgsys_dev, hw_comb,
+			logBuf_path, logBuf_inport, logBuf_outport, dl_path);
+		break;
+	case (IMGSYS_ENG_DIP | IMGSYS_ENG_PQDIP_A):
+	case (IMGSYS_ENG_DIP | IMGSYS_ENG_PQDIP_B):
+	case (IMGSYS_ENG_DIP | IMGSYS_ENG_PQDIP_A | IMGSYS_ENG_PQDIP_B):
+		dl_path = IMGSYS_DL_DIP_PQDIPA;
+		snprintf(logBuf_inport, log_length, "%s",
+			"DIP");
+		snprintf(logBuf_outport, log_length, "%s",
+			"PQDIPA");
+		imgsys_dl_checksum_dump(imgsys_dev, hw_comb,
+			logBuf_path, logBuf_inport, logBuf_outport, dl_path);
+		/**/
+		memset((char *)logBuf_inport, 0x0, log_length);
+		logBuf_inport[strlen(logBuf_inport)] = '\0';
+		memset((char *)logBuf_outport, 0x0, log_length);
+		logBuf_outport[strlen(logBuf_outport)] = '\0';
+		dl_path = IMGSYS_DL_DIP_PQDIPB;
+		snprintf(logBuf_inport, log_length, "%s",
+			"DIP");
+		snprintf(logBuf_outport, log_length, "%s",
+			"PQDIPB");
+		imgsys_dl_checksum_dump(imgsys_dev, hw_comb,
+			logBuf_path, logBuf_inport, logBuf_outport, dl_path);
+		break;
+	case (IMGSYS_ENG_ADL_A | IMGSYS_ENG_XTR):
+	case (IMGSYS_ENG_ADL_A | IMGSYS_ENG_ADL_B | IMGSYS_ENG_XTR):
+		/**
+		 * dl_path = IMGSYS_DL_ADLA_XTRAW;
+		 * snprintf(logBuf_inport, log_length, "%s", "ADL");
+		 * snprintf(logBuf_outport, log_length, "%s", "XTRAW");
+		 * imgsys_dl_checksum_dump(imgsys_dev, hw_comb,
+		 *  logBuf_path, logBuf_inport, logBuf_outport, dl_path);
+		 */
+		dev_info(imgsys_dev->dev,
+			"%s: we dont have checksum for ADL DL XTRAW\n",
+			__func__);
+		break;
+	case (IMGSYS_ENG_ME):
+		imgsys_cg_debug_dump(imgsys_dev);
+		break;
+	default:
+		break;
+	}
+
+	dev_info(imgsys_dev->dev, "%s: -\n", __func__);
+}
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_71/mtk_imgsys-debug.h b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_71/mtk_imgsys-debug.h
new file mode 100644
index 0000000000000000000000000000000000000000..45a696d3249958c5eedffa88eb1e62eb56b98474
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_71/mtk_imgsys-debug.h
@@ -0,0 +1,51 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2018 MediaTek Inc.
+ *
+ * Author: Christopher Chen <christopher.chen@mediatek.com>
+ *
+ */
+
+#ifndef _MTK_IMGSYS_DEBUG_H_
+#define _MTK_IMGSYS_DEBUG_H_
+
+#include "mtk_imgsys-dev.h"
+#include "mtk_imgsys-cmdq.h"
+#include "mtk_imgsys-module.h"
+#include "mtk_imgsys-engine.h"
+/**
+ * enum IMGSYS_DL_PATH_E
+ *
+ * Definition about supported direct link path
+ */
+enum IMGSYS_DL_PATH_E {
+	IMGSYS_DL_WPEE_TRAW = 0,
+	IMGSYS_DL_WPEE_DIP = 1,
+	IMGSYS_DL_TRAW_DIP = 4,
+	IMGSYS_DL_WPE_PQDIP = 5, /*no more used*/
+	IMGSYS_DL_DIP_PQDIPA = 6,
+	IMGSYS_DL_DIP_PQDIPB = 7,
+	IMGSYS_DL_WPET_TRAW = 10,
+	IMGSYS_DL_WPET_DIP = 11,
+	IMGSYS_DL_ADLA_XTRAW = 14,
+	IMGSYS_DL_ADLB_XTRAW = 15,
+	IMGSYS_DL_ADLA_ODD_XTRAW = 18,
+	IMGSYS_DL_WPEE_XTRAW = 20,
+	IMGSYS_DL_WPET_XTRAW = 21,
+	IMGSYS_DL_WPEL_TRAW, /*no this*/
+};
+
+struct imgsys_dbg_engine_t {
+	enum mtk_imgsys_engine eng_e;
+	char eng_name[8];
+};
+
+void imgsys_dl_debug_dump(struct mtk_imgsys_dev *imgsys_dev, unsigned int hw_comb);
+void imgsys_debug_dump_routine(struct mtk_imgsys_dev *imgsys_dev,
+	const struct module_ops *imgsys_modules, int imgsys_module_num,
+	unsigned int hw_comb);
+void imgsys_main_init(struct mtk_imgsys_dev *imgsys_dev);
+void imgsys_main_set_init(struct mtk_imgsys_dev *imgsys_dev);
+void imgsys_main_uninit(struct mtk_imgsys_dev *imgsys_dev);
+
+#endif /* _MTK_IMGSYS_DEBUG_H_ */
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_71/mtk_imgsys-engine.h b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_71/mtk_imgsys-engine.h
new file mode 100644
index 0000000000000000000000000000000000000000..114698be6b8fb1e2ac84f0c417904ac017f80baf
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_71/mtk_imgsys-engine.h
@@ -0,0 +1,77 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2018 MediaTek Inc.
+ *
+ * Author: Christopher Chen <christopher.chen@mediatek.com>
+ *
+ */
+
+#ifndef _MTK_IMGSYS_ENGINE_H_
+#define _MTK_IMGSYS_ENGINE_H_
+
+/**
+ * enum mtk_imgsys_module
+ *
+ * Definition about supported hw modules
+ */
+enum mtk_imgsys_module {
+	IMGSYS_MOD_IMGMAIN = 0, /*pure sw, debug dump usage*/
+	IMGSYS_MOD_WPE,
+	IMGSYS_MOD_ADL,
+	IMGSYS_MOD_TRAW,
+	IMGSYS_MOD_DIP,
+	IMGSYS_MOD_PQDIP,
+	IMGSYS_MOD_ME,
+	IMGSYS_MOD_MAX,
+};
+
+/**
+ * enum mtk_imgsys_engine
+ *
+ * Definition about supported hw engines
+ */
+enum mtk_imgsys_engine {
+	IMGSYS_ENG_WPE_EIS	= 0x00000001,
+	IMGSYS_ENG_WPE_TNR	= 0x00000002,
+	IMGSYS_ENG_WPE_LITE	= 0x00000004,
+	IMGSYS_ENG_ADL_A    = 0x00000008,
+	IMGSYS_ENG_ADL_B    = 0x00000010,
+	IMGSYS_ENG_TRAW		  = 0x00000020,
+	IMGSYS_ENG_LTR		  = 0x00000040,
+	IMGSYS_ENG_XTR		  = 0x00000080,
+	IMGSYS_ENG_DIP		  = 0x00000100,
+	IMGSYS_ENG_PQDIP_A	= 0x00000200,
+	IMGSYS_ENG_PQDIP_B	= 0x00000400,
+	IMGSYS_ENG_ME		    = 0x00000800
+};
+
+/**
+ * enum IMGSYS_REG_MAP_E
+ *
+ * Definition about hw register map id
+ * The engine order should be the same as register order in dts
+ */
+enum IMGSYS_REG_MAP_E {
+	REG_MAP_E_TOP = 0,
+	REG_MAP_E_TRAW,
+	REG_MAP_E_LTRAW,
+	REG_MAP_E_XTRAW,
+	REG_MAP_E_DIP,
+	REG_MAP_E_DIP_NR,
+	REG_MAP_E_PQDIP_A,
+	REG_MAP_E_PQDIP_B,
+	REG_MAP_E_WPE_EIS,
+	REG_MAP_E_WPE_TNR,
+	REG_MAP_E_WPE_LITE,
+	REG_MAP_E_WPE1_DIP1,
+	REG_MAP_E_ME,
+	REG_MAP_E_ADL_A,
+	REG_MAP_E_ADL_B,
+	REG_MAP_E_WPE2_DIP1,
+	REG_MAP_E_WPE3_DIP1,
+	REG_MAP_E_DIP_TOP,
+	REG_MAP_E_DIP_TOP_NR
+};
+
+#endif /* _MTK_IMGSYS_ENGINE_H_ */
+
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_71/mtk_imgsys-modops.h b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_71/mtk_imgsys-modops.h
new file mode 100644
index 0000000000000000000000000000000000000000..dae7975a2911cab647b6ee273459de3e2060e7e2
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_71/mtk_imgsys-modops.h
@@ -0,0 +1,79 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2018 MediaTek Inc.
+ *
+ * Author: Frederic Chen <frederic.chen@mediatek.com>
+ *         Holmes Chiou <holmes.chiou@mediatek.com>
+ *
+ */
+
+#ifndef _MTK_IMGSYS_MODOPS_H_
+#define _MTK_IMGSYS_MODOPS_H_
+
+#include "mtk_imgsys-module.h"
+#include "modules/mtk_imgsys-dip.h"
+#include "modules/mtk_imgsys-traw.h"
+#include "modules/mtk_imgsys-pqdip.h"
+#include "modules/mtk_imgsys-wpe.h"
+//#include "modules/mtk_imgsys-me.h"
+#include "modules/mtk_imgsys-adl.h"
+#include "mtk-ipesys-me.h"
+#include "mtk_imgsys-debug.h"
+
+const struct module_ops imgsys_isp7_modules[] = {
+	[IMGSYS_MOD_TRAW] = {
+		.module_id = IMGSYS_MOD_TRAW,
+		.init = imgsys_traw_set_initial_value,
+		.set = imgsys_traw_set_initial_value_hw,
+		.dump = imgsys_traw_debug_dump,
+		.uninit = imgsys_traw_uninit,
+	},
+	[IMGSYS_MOD_DIP] = {
+		.module_id = IMGSYS_MOD_DIP,
+		.init = imgsys_dip_set_initial_value,
+		.set = imgsys_dip_set_hw_initial_value,
+		.dump = imgsys_dip_debug_dump,
+		.uninit = imgsys_dip_uninit,
+	},
+	[IMGSYS_MOD_PQDIP] = {
+		.module_id = IMGSYS_MOD_PQDIP,
+		.init = imgsys_pqdip_set_initial_value,
+		.set = imgsys_pqdip_set_hw_initial_value,
+		.dump = imgsys_pqdip_debug_dump,
+		.uninit = imgsys_pqdip_uninit,
+	},
+	[IMGSYS_MOD_ME] = {
+		.module_id = IMGSYS_MOD_ME,
+		.init = ipesys_me_set_initial_value,
+		.set = NULL,
+		.dump = ipesys_me_debug_dump,
+		.uninit = ipesys_me_uninit,
+	},
+	[IMGSYS_MOD_WPE] = {
+		.module_id = IMGSYS_MOD_WPE,
+		.init = imgsys_wpe_set_initial_value,
+		.set = imgsys_wpe_set_hw_initial_value,
+		.dump = imgsys_wpe_debug_dump,
+		.uninit = imgsys_wpe_uninit,
+	},
+	[IMGSYS_MOD_ADL] = {
+		.module_id = IMGSYS_MOD_ADL,
+		.init = imgsys_adl_init,
+		.set = imgsys_adl_set,
+		.dump = imgsys_adl_debug_dump,
+		.uninit = imgsys_adl_uninit,
+	},
+	/*pure sw usage for timeout debug dump*/
+	[IMGSYS_MOD_IMGMAIN] = {
+		.module_id = IMGSYS_MOD_IMGMAIN,
+		.init = imgsys_main_init,
+		.set = imgsys_main_set_init,
+		.dump = NULL,
+		.uninit = imgsys_main_uninit,
+	},
+};
+#define MTK_IMGSYS_MODULE_NUM	ARRAY_SIZE(imgsys_isp7_modules)
+
+
+#endif /* _MTK_IMGSYS_MODOPS_H_ */
+
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_71/mtk_imgsys-plat.h b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_71/mtk_imgsys-plat.h
new file mode 100644
index 0000000000000000000000000000000000000000..783140bc95934ab3a3ec3e64ddd3c3784fd75c20
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_71/mtk_imgsys-plat.h
@@ -0,0 +1,70 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2018 MediaTek Inc.
+ *
+ * Author: Christopher Chen <christopher.chen@mediatek.com>
+ *
+ */
+
+#ifndef _MTK_IMGSYS_PLAT_H_
+#define _MTK_IMGSYS_PLAT_H_
+
+#include <linux/clk.h>
+
+struct clk_bulk_data imgsys_isp7_clks[] = {
+	{
+		.id = "IMGSYS_CG_IMG_TRAW0",
+	},
+	{
+		.id = "IMGSYS_CG_IMG_TRAW1",
+	},
+	{
+		.id = "IMGSYS_CG_IMG_VCORE_GALS",
+	},
+	{
+		.id = "IMGSYS_CG_IMG_DIP0",
+	},
+	{
+		.id = "IMGSYS_CG_IMG_WPE0",
+	},
+	{
+		.id = "IMGSYS_CG_IMG_WPE1",
+	},
+	{
+		.id = "IMGSYS_CG_IMG_WPE2",
+	},
+	{
+		.id = "IMGSYS_CG_IMG_ADL_LARB",
+	},
+	{
+		.id = "IMGSYS_CG_IMG_ADL_TOP0",
+	},
+	{
+		.id = "IMGSYS_CG_IMG_ADL_TOP1",
+	},
+	{
+		.id = "IMGSYS_CG_IMG_GALS",
+	},
+	{
+		.id = "DIP_TOP_DIP_TOP",
+	},
+	{
+		.id = "DIP_NR_DIP_NR",
+	},
+	{
+		.id = "WPE1_CG_DIP1_WPE",
+	},
+	{
+		.id = "WPE2_CG_DIP1_WPE",
+	},
+	{
+		.id = "WPE3_CG_DIP1_WPE",
+	},
+	{
+		.id = "ME_CG_IPE"
+	}
+};
+
+#define MTK_IMGSYS_CLK_NUM	ARRAY_SIZE(imgsys_isp7_clks)
+
+#endif /* _MTK_IMGSYS_PLAT_H_ */
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_71/mtk_imgsys-vnode_id.h b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_71/mtk_imgsys-vnode_id.h
new file mode 100644
index 0000000000000000000000000000000000000000..969608677698eaf13df1e1ffd62fea160c076d47
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_71/mtk_imgsys-vnode_id.h
@@ -0,0 +1,99 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2018 MediaTek Inc.
+ *
+ * Author: Frederic Chen <frederic.chen@mediatek.com>
+ *
+ */
+#ifndef _MTK_IMGSYS_VNODE_ID_H_
+#define _MTK_IMGSYS_VNODE_ID_H_
+
+/*
+ * TODO: register module pipeline desc in module order
+ */
+enum imgsys_video_nodes_id {
+	/* IMGSYS_MODULE_TRAW */
+	MTK_IMGSYS_VIDEO_NODE_ID_TIMGI_OUT = 0,
+	MTK_IMGSYS_VIDEO_NODE_ID_METAI_OUT,
+	MTK_IMGSYS_VIDEO_NODE_ID_PDC_OUT,
+	MTK_IMGSYS_VIDEO_NODE_ID_TYUVO_CAPTURE,
+	MTK_IMGSYS_VIDEO_NODE_ID_TYUV2O_CAPTURE,
+	MTK_IMGSYS_VIDEO_NODE_ID_TYUV3O_CAPTURE,
+	MTK_IMGSYS_VIDEO_NODE_ID_TYUV4O_CAPTURE,
+	MTK_IMGSYS_VIDEO_NODE_ID_TYUV5O_CAPTURE,
+	MTK_IMGSYS_VIDEO_NODE_ID_FEO_CAPTURE,
+	MTK_IMGSYS_VIDEO_NODE_ID_TIMGO_CAPTURE,
+	MTK_IMGSYS_VIDEO_NODE_ID_IMGSTATO_CAPTURE,
+	MTK_IMGSYS_VIDEO_NODE_ID_XTMEO_CAPTURE,
+	MTK_IMGSYS_VIDEO_NODE_ID_XTFDO_CAPTURE,
+	MTK_IMGSYS_VIDEO_NODE_ID_XTADLDBGO_CAPTURE,
+	/* IMGSYS_MODULE_DIP */
+	MTK_IMGSYS_VIDEO_NODE_ID_IMGI_OUT,
+	MTK_IMGSYS_VIDEO_NODE_ID_VIPI_OUT,
+	MTK_IMGSYS_VIDEO_NODE_ID_REC_DSI_OUT,
+	MTK_IMGSYS_VIDEO_NODE_ID_REC_DPI_OUT,
+	MTK_IMGSYS_VIDEO_NODE_ID_CNR_BLURMAPI_OUT,
+	MTK_IMGSYS_VIDEO_NODE_ID_LFEI_OUT,
+	MTK_IMGSYS_VIDEO_NODE_ID_RFEI_OUT,
+	MTK_IMGSYS_VIDEO_NODE_ID_TNRSI_OUT,
+	MTK_IMGSYS_VIDEO_NODE_ID_TNRWI_OUT,
+	MTK_IMGSYS_VIDEO_NODE_ID_TNRMI_OUT,
+	MTK_IMGSYS_VIDEO_NODE_ID_TNRCI_OUT,
+	MTK_IMGSYS_VIDEO_NODE_ID_TNRLI_OUT,
+	MTK_IMGSYS_VIDEO_NODE_ID_TNRVBI_OUT,
+	MTK_IMGSYS_VIDEO_NODE_ID_IMG2O_CAPTURE,
+	MTK_IMGSYS_VIDEO_NODE_ID_IMG3O_CAPTURE,
+	MTK_IMGSYS_VIDEO_NODE_ID_IMG4O_CAPTURE,
+	MTK_IMGSYS_VIDEO_NODE_ID_FMO_CAPTURE,
+	MTK_IMGSYS_VIDEO_NODE_ID_TNRSO_CAPTURE,
+	MTK_IMGSYS_VIDEO_NODE_ID_TNRWO_CAPTURE,
+	MTK_IMGSYS_VIDEO_NODE_ID_TNRMO_CAPTURE,
+	/* IMGSYS_MODULE_PQDIP */
+	MTK_IMGSYS_VIDEO_NODE_ID_PIMGI_OUT,
+	MTK_IMGSYS_VIDEO_NODE_ID_WROT_A_CAPTURE,
+	MTK_IMGSYS_VIDEO_NODE_ID_WROT_B_CAPTURE,
+	MTK_IMGSYS_VIDEO_NODE_ID_TCCSO_A_CAPTURE,
+	MTK_IMGSYS_VIDEO_NODE_ID_TCCSO_B_CAPTURE,
+	/* IMGSYS_MODULE_ME */
+	MTK_IMGSYS_VIDEO_NODE_ID_MEL0IMG0_OUT,
+	MTK_IMGSYS_VIDEO_NODE_ID_MEL0IMG1_OUT,
+	MTK_IMGSYS_VIDEO_NODE_ID_MEL1IMG0_OUT,
+	MTK_IMGSYS_VIDEO_NODE_ID_MEL1IMG1_OUT,
+	MTK_IMGSYS_VIDEO_NODE_ID_MEIMGSTATS_OUT,
+	MTK_IMGSYS_VIDEO_NODE_ID_MEL0RMV_OUT,
+	MTK_IMGSYS_VIDEO_NODE_ID_MEL1RMV_OUT,
+	MTK_IMGSYS_VIDEO_NODE_ID_MEL0FMB_OUT,
+	MTK_IMGSYS_VIDEO_NODE_ID_MEL1FMB_OUT,
+	MTK_IMGSYS_VIDEO_NODE_ID_MEMIL_OUT,
+	MTK_IMGSYS_VIDEO_NODE_ID_MEMMGMIL_CAPTURE,
+	MTK_IMGSYS_VIDEO_NODE_ID_MEL0WMV_CAPTURE,
+	MTK_IMGSYS_VIDEO_NODE_ID_MEL1WMV_CAPTURE,
+	MTK_IMGSYS_VIDEO_NODE_ID_MECONF_CAPTURE,
+	MTK_IMGSYS_VIDEO_NODE_ID_MEWMAP_CAPTURE,
+	MTK_IMGSYS_VIDEO_NODE_ID_MEFMV_CAPTURE,
+	MTK_IMGSYS_VIDEO_NODE_ID_MEFST_CAPTURE,
+	MTK_IMGSYS_VIDEO_NODE_ID_MELMI_CAPTURE,
+	MTK_IMGSYS_VIDEO_NODE_ID_MEL0WFMB_CAPTURE,
+	MTK_IMGSYS_VIDEO_NODE_ID_MEL1WFMB_CAPTURE,
+	/* IMGSYS_MODULE_WPE */
+	MTK_IMGSYS_VIDEO_NODE_ID_WWPEI_OUT,
+	MTK_IMGSYS_VIDEO_NODE_ID_WVECI_OUT,
+	MTK_IMGSYS_VIDEO_NODE_ID_WPSP_COEFI_OUT,
+	MTK_IMGSYS_VIDEO_NODE_ID_WWPEO_CAPTURE,
+	MTK_IMGSYS_VIDEO_NODE_ID_WMSKO_CAPTURE,
+	/* IMGSYS_MODULE_WPE_TNR */
+	MTK_IMGSYS_VIDEO_NODE_ID_WTWPEI_OUT,
+	MTK_IMGSYS_VIDEO_NODE_ID_WTVECI_OUT,
+	MTK_IMGSYS_VIDEO_NODE_ID_WTPSP_COEFI_OUT,
+	MTK_IMGSYS_VIDEO_NODE_ID_WTWPEO_CAPTURE,
+	MTK_IMGSYS_VIDEO_NODE_ID_WTMSKO_CAPTURE,
+	/* other module video nodes to be added */
+	MTK_IMGSYS_VIDEO_NODE_ID_TUNING_OUT,
+	MTK_IMGSYS_VIDEO_NODE_ID_CTRLMETA_OUT,
+	MTK_IMGSYS_VIDEO_NODE_ID_SIGDEV_OUT,
+	MTK_IMGSYS_VIDEO_NODE_ID_SIGDEV_NORM_OUT,
+	MTK_IMGSYS_VIDEO_NODE_ID_TOTAL_NUM,
+};
+
+
+#endif
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_71/mtk_imgsys_v4l2_vnode.h b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_71/mtk_imgsys_v4l2_vnode.h
new file mode 100644
index 0000000000000000000000000000000000000000..79fa5c7c40148c6d9791530eefd143ff018c535e
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_71/mtk_imgsys_v4l2_vnode.h
@@ -0,0 +1,221 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2018 MediaTek Inc.
+ *
+ * Author: Frederic Chen <frederic.chen@mediatek.com>
+ *
+ */
+#ifndef _MTK_IMGSYS_V4L2_VNODE_H_
+#define _MTK_IMGSYS_V4L2_VNODE_H_
+
+#include "mtk_imgsys-of.h"
+#include "mtk_imgsys-dev.h"
+#include "mtk_imgsys-vnode_id.h"
+#include "modules/mtk_dip_v4l2_vnode.h"
+#include "modules/mtk_traw_v4l2_vnode.h"
+#include "modules/mtk_pqdip_v4l2_vnode.h"
+#include "modules/mtk_wpe_v4l2_vnode.h"
+#include "modules/mtk_me_v4l2_vnode.h"
+
+/*
+ * TODO: register module pipeline desc in module order
+ */
+enum mtk_imgsys_module_id {
+	IMGSYS_MODULE_TRAW = 0,
+	IMGSYS_MODULE_DIP,
+	IMGSYS_MODULE_PQDIP,
+	IMGSYS_MODULE_ME,
+	IMGSYS_MODULE_WPE,
+	IMGSYS_MODULE_ADL,
+	IMGSYS_MODULE_MAIN,
+	IMGSYS_MODULE_NUM,
+};
+
+static const struct mtk_imgsys_mod_pipe_desc module_pipe_isp7[] = {
+	[IMGSYS_MODULE_TRAW] = {
+		.vnode_desc = traw_setting,
+		.node_num = ARRAY_SIZE(traw_setting),
+	},
+	[IMGSYS_MODULE_DIP] = {
+		.vnode_desc = dip_setting,
+		.node_num = ARRAY_SIZE(dip_setting),
+	},
+	[IMGSYS_MODULE_PQDIP] = {
+		.vnode_desc = pqdip_setting,
+		.node_num = ARRAY_SIZE(pqdip_setting),
+	},
+	[IMGSYS_MODULE_ME] = {
+		.vnode_desc = me_setting,
+		.node_num = ARRAY_SIZE(me_setting),
+	},
+	[IMGSYS_MODULE_WPE] = {
+		.vnode_desc = wpe_setting,
+		.node_num = ARRAY_SIZE(wpe_setting),
+	},
+	[IMGSYS_MODULE_ADL] = {
+		.vnode_desc = NULL,
+		.node_num = 0,
+	},
+	[IMGSYS_MODULE_MAIN] = {
+		.vnode_desc = NULL,
+		.node_num = 0,
+	}
+};
+
+
+#define MTK_IMGSYS_MODULE_VNUM ARRAY_SIZE(module_pipe_isp7)
+
+
+
+static const struct mtk_imgsys_dev_format fw_param_fmts[] = {
+#if MTK_CM4_SUPPORT
+	{
+		.format = V4L2_META_FMT_MTISP_PARAMS,
+		.buffer_size = 1024 * (128 + 288),
+	},
+#else
+	{
+		.format = V4L2_META_FMT_MTISP_PARAMS,
+		.buffer_size = DIP_TUNING_SZ,
+	},
+	{
+		.format = V4L2_META_FMT_MTISP_PARAMS,
+		.buffer_size = sizeof(struct dip_param),
+	},
+#endif
+	{	// Must have for SMVR/Multis-cale for every video_device nodes
+		.format = V4L2_META_FMT_MTISP_DESC,
+		.num_planes = 1,
+#if defaultdesc
+		.depth = { 8 },
+		.row_depth = { 8 },
+		.num_cplanes = 1,
+#endif
+		.buffer_size = sizeof(struct header_desc),
+	},
+	{
+		.format = V4L2_META_FMT_MTISP_DESC_NORM,
+		.num_planes = 1,
+		.buffer_size = sizeof(struct header_desc_norm),
+	},
+};
+
+static const struct mtk_imgsys_dev_format sd_fmts[] = {
+	{
+		.format = V4L2_META_FMT_MTISP_SD,
+		.num_planes = 1,
+#if defaultdesc
+		.depth = { 8 },
+		.row_depth = { 8 },
+		.num_cplanes = 1,
+#endif
+		.buffer_size = sizeof(struct singlenode_desc),
+	},
+	{
+		.format = V4L2_META_FMT_MTISP_SDNORM,
+		.num_planes = 1,
+		.buffer_size = sizeof(struct singlenode_desc_norm),
+	},
+};
+
+static struct mtk_imgsys_video_device_desc
+queues_setting[MTK_IMGSYS_VIDEO_NODE_ID_TOTAL_NUM] = {
+	[MTK_IMGSYS_VIDEO_NODE_ID_TUNING_OUT] = {
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_TUNING_OUT,
+		.name = "Tuning",
+		.cap = V4L2_CAP_META_OUTPUT | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_META_OUTPUT,
+		.smem_alloc = 0, //meta:1
+		.flags = 0,
+		.fmts = fw_param_fmts,
+		.num_fmts = ARRAY_SIZE(fw_param_fmts),
+		.default_fmt_idx = 2, //0,
+		.dma_port = 0,
+		.frmsizeenum = &dip_in_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_meta_out_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_meta_ops,
+		.description = "Tuning data",
+	},
+	[MTK_IMGSYS_VIDEO_NODE_ID_CTRLMETA_OUT] = {
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_CTRLMETA_OUT,
+		.name = "CtrlMeta",
+		.cap = V4L2_CAP_META_OUTPUT | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_META_OUTPUT,
+		.smem_alloc = 0, //meta:1
+		.flags = 0,
+		.fmts = fw_param_fmts,
+		.num_fmts = ARRAY_SIZE(fw_param_fmts),
+		.default_fmt_idx = 2, //1,
+		.dma_port = 0,
+		.frmsizeenum = &dip_in_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_meta_out_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_meta_ops,
+		.description = "Control meta data for flow control",
+	},
+	[MTK_IMGSYS_VIDEO_NODE_ID_SIGDEV_OUT] = {
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_SIGDEV_OUT,
+		.name = "Single Device",
+		.cap = V4L2_CAP_VIDEO_OUTPUT_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = sd_fmts,
+		.num_fmts = ARRAY_SIZE(sd_fmts),
+		.default_fmt_idx = 0,
+		.default_width = MTK_DIP_OUTPUT_MAX_WIDTH,
+		.default_height = MTK_DIP_OUTPUT_MAX_HEIGHT,
+		.dma_port = 0,
+		.frmsizeenum = &dip_in_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_out_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "Single Device Node",
+	},
+	[MTK_IMGSYS_VIDEO_NODE_ID_SIGDEV_NORM_OUT] = {
+		.id = MTK_IMGSYS_VIDEO_NODE_ID_SIGDEV_NORM_OUT,
+		.name = "SIGDEVN",
+		.cap = V4L2_CAP_VIDEO_OUTPUT_MPLANE | V4L2_CAP_STREAMING,
+		.buf_type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,
+		.smem_alloc = 0,
+		.flags = MEDIA_LNK_FL_DYNAMIC,
+		.fmts = sd_fmts,
+		.num_fmts = ARRAY_SIZE(sd_fmts),
+		.default_fmt_idx = 1,
+		.default_width = MTK_DIP_OUTPUT_MAX_WIDTH,
+		.default_height = MTK_DIP_OUTPUT_MAX_HEIGHT,
+		.dma_port = 0,
+		.frmsizeenum = &dip_in_frmsizeenum,
+		.ops = &mtk_imgsys_v4l2_video_out_ioctl_ops,
+		.vb2_ops = &mtk_imgsys_vb2_video_ops,
+		.description = "Single Device Norm",
+	},
+};
+#ifdef MULTI_PIPE_SUPPORT
+static struct mtk_imgsys_video_device_desc
+reprocess_queues_setting[MTK_IMGSYS_VIDEO_NODE_ID_TOTAL_NUM];
+#endif
+
+static const struct mtk_imgsys_pipe_desc
+pipe_settings_isp7[MTK_IMGSYS_PIPE_ID_TOTAL_NUM] = {
+	{
+		.name = MTK_DIP_DEV_DIP_PREVIEW_NAME,
+		.id = MTK_IMGSYS_PIPE_ID_PREVIEW,
+		.queue_descs = queues_setting,
+		.total_queues = ARRAY_SIZE(queues_setting),
+	},
+#ifdef MULTI_PIPE_SUPPORT
+	{
+		.name = MTK_DIP_DEV_DIP_CAPTURE_NAME,
+		.id = MTK_IMGSYS_PIPE_ID_CAPTURE,
+		.queue_descs = queues_setting,
+		.total_queues = ARRAY_SIZE(queues_setting),
+
+	},
+	{
+		.name = MTK_DIP_DEV_DIP_REPROCESS_NAME,
+		.id = MTK_IMGSYS_PIPE_ID_REPROCESS,
+		.queue_descs = reprocess_queues_setting,
+		.total_queues = ARRAY_SIZE(reprocess_queues_setting),
+	},
+#endif
+};
+#endif
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/mtk_imgsys-data.h b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/mtk_imgsys-data.h
new file mode 100644
index 0000000000000000000000000000000000000000..772598766b5aa43d867c21c443774c12448629f1
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/mtk_imgsys-data.h
@@ -0,0 +1,38 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2018 MediaTek Inc.
+ *
+ * Author: Frederic Chen <frederic.chen@mediatek.com>
+ *         Holmes Chiou <holmes.chiou@mediatek.com>
+ *
+ */
+
+#ifndef _MTK_IMGSYS_DATA_H_
+#define _MTK_IMGSYS_DATA_H_
+
+#include "mtk_imgsys-of.h"
+/* For ISP 7 */
+#include "mtk_imgsys-modops.h"
+#include "mtk_imgsys-plat.h"
+#include "mtk_imgsys_v4l2_vnode.h"
+#include "mtk_imgsys-debug.h"
+/* For ISP 7.1 */
+
+/* imgsys_data is a keyword, please don't rename */
+const struct cust_data imgsys_data[] = {
+	/* ISP 7 */
+	[0] = {
+	.clks = imgsys_isp7_clks,
+	.clk_num = MTK_IMGSYS_CLK_NUM,
+		.module_pipes = module_pipe_isp7,
+		.mod_num = ARRAY_SIZE(module_pipe_isp7),
+		.pipe_settings = pipe_settings_isp7,
+		.pipe_num = ARRAY_SIZE(pipe_settings_isp7),
+	.imgsys_modules = imgsys_isp7_modules,
+		.dump = imgsys_debug_dump_routine,
+	},
+	/* ISP 7.1 */
+
+};
+#endif /* _MTK_IMGSYS_DATA_H_ */
+
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/mtk-hcp/Makefile b/drivers/media/platform/mediatek/isp/isp_7x/mtk-hcp/Makefile
new file mode 100644
index 0000000000000000000000000000000000000000..c3e67c1cf02e2ae5ed5369caadc7445c049edd8f
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/mtk-hcp/Makefile
@@ -0,0 +1,38 @@
+#
+# Copyright (C) 2018 MediaTek Inc.
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU General Public License version 2 as
+# published by the Free Software Foundation.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+# GNU General Public License for more details.
+#
+
+subdir-ccflags-y += -Werror
+#ccflags-y += -I$(srctree)/drivers/misc/mediatek/scp/$(CONFIG_MTK_PLATFORM)
+#ccflags-y += -I$(srctree)/drivers/misc/mediatek/m4u/2.4
+#ccflags-y += -I$(srctree)/drivers/misc/mediatek/m4u/$(MTK_PLATFORM)
+ccflags-y += -I$(srctree)/drivers/media/platform/mediatek/isp/isp_7x/imgsys/
+ccflags-y += -I$(srctree)/drivers/media/platform/mediatek/isp/isp_7x/mtk-hcp/
+
+#ifeq ($(CONFIG_MTK_ION),y)
+#    ccflags-y += -I$(srctree)/drivers/staging/android/mtk_ion/
+#    ccflags-y  += -I$(srctree)/drivers/staging/android/mtk_ion/mtk/
+#else
+#    ccflags-$(CONFIG_ION) += -I$(srctree)/drivers/staging/android/aosp_ion/
+#endif
+
+#ccflags-y += -I$(srctree)/drivers/misc/mediatek/include/mt-plat/$(MTK_PLATFORM)/include/ \
+             -I$(srctree)/drivers/misc/mediatek/include/mt-plat/ \
+             -I$(srctree)/drivers/misc/mediatek/include/
+ccflags-y += -I$(srctree)/drivers/dma-buf/heaps/ \
+             -I$(srctree)/drivers/iommu
+subdir-ccflags-y += -DIMGSYS_VER_ISP71
+obj-y += mem/hcp_videobuf2-memops.o
+obj-y += mem/hcp_videobuf2-vmalloc.o
+obj-y += mem/hcp_videobuf2-dma-contig.o
+obj-y += mtk-hcp_isp71.o
+obj-y += mtk-hcp.o
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/mtk-hcp/mem/hcp_videobuf2-dma-contig.c b/drivers/media/platform/mediatek/isp/isp_7x/mtk-hcp/mem/hcp_videobuf2-dma-contig.c
new file mode 100644
index 0000000000000000000000000000000000000000..f1fb16be522e0a2da0aeda81051c5c63bd4a25da
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/mtk-hcp/mem/hcp_videobuf2-dma-contig.c
@@ -0,0 +1,753 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2021 MediaTek Inc.
+ */
+
+#include <linux/dma-buf.h>
+#include <linux/module.h>
+#include <linux/refcount.h>
+#include <linux/scatterlist.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/dma-mapping.h>
+
+#include <media/videobuf2-v4l2.h>
+#include "hcp_videobuf2-dma-contig.h"
+#include "hcp_videobuf2-memops.h"
+
+struct vb2_dc_buf {
+	struct device			*dev;
+	void				*vaddr;
+	unsigned long			size;
+	void				*cookie;
+	dma_addr_t			dma_addr;
+	unsigned long			attrs;
+	enum dma_data_direction		dma_dir;
+	struct sg_table			*dma_sgt;
+	struct frame_vector		*vec;
+
+	/* MMAP related */
+	struct vb2_vmarea_handler	handler;
+	refcount_t			refcount;
+	struct sg_table			*sgt_base;
+
+	/* DMABUF related */
+	struct dma_buf_attachment	*db_attach;
+
+	struct vb2_buffer	*vb;
+};
+
+/*********************************************/
+/*        scatterlist table functions        */
+/*********************************************/
+
+static unsigned long hcp_vb2_dc_get_contiguous_size(struct sg_table *sgt)
+{
+	struct scatterlist *s;
+	dma_addr_t expected = sg_dma_address(sgt->sgl);
+	unsigned int i;
+	unsigned long size = 0;
+
+	for_each_sgtable_dma_sg(sgt, s, i) {
+		if (sg_dma_address(s) != expected)
+			break;
+		expected += sg_dma_len(s);
+		size += sg_dma_len(s);
+	}
+	return size;
+}
+
+/*********************************************/
+/*         callbacks for all buffers         */
+/*********************************************/
+
+static void *hcp_vb2_dc_cookie(struct vb2_buffer *vb, void *buf_priv)
+{
+	struct vb2_dc_buf *buf = buf_priv;
+
+	return &buf->dma_addr;
+}
+
+static void *hcp_vb2_dc_vaddr(struct vb2_buffer *vb, void *buf_priv)
+{
+	struct vb2_dc_buf *buf = buf_priv;
+	struct iosys_map map;
+	int ret;
+
+	if (!buf->vaddr && buf->db_attach) {
+		ret = dma_buf_vmap(buf->db_attach->dmabuf, &map);
+		buf->vaddr = ret ? NULL : map.vaddr;
+	}
+
+	return buf->vaddr;
+}
+
+static unsigned int hcp_vb2_dc_num_users(void *buf_priv)
+{
+	struct vb2_dc_buf *buf = buf_priv;
+
+	return refcount_read(&buf->refcount);
+}
+
+static void hcp_vb2_dc_prepare(void *buf_priv)
+{
+	struct vb2_dc_buf *buf = buf_priv;
+	struct sg_table *sgt = buf->dma_sgt;
+
+	if (!sgt)
+		return;
+
+	dma_sync_sgtable_for_device(buf->dev, sgt, buf->dma_dir);
+}
+
+static void hcp_vb2_dc_finish(void *buf_priv)
+{
+	struct vb2_dc_buf *buf = buf_priv;
+	struct sg_table *sgt = buf->dma_sgt;
+
+	if (!sgt)
+		return;
+
+	dma_sync_sgtable_for_cpu(buf->dev, sgt, buf->dma_dir);
+}
+
+/*********************************************/
+/*        callbacks for MMAP buffers         */
+/*********************************************/
+
+static void hcp_vb2_dc_put(void *buf_priv)
+{
+	struct vb2_dc_buf *buf = buf_priv;
+
+	if (!refcount_dec_and_test(&buf->refcount))
+		return;
+
+	if (buf->sgt_base) {
+		sg_free_table(buf->sgt_base);
+		kfree(buf->sgt_base);
+	}
+	dma_free_attrs(buf->dev, buf->size, buf->cookie, buf->dma_addr,
+		       buf->attrs);
+	put_device(buf->dev);
+	kfree(buf);
+}
+
+static void *hcp_vb2_dc_alloc(struct vb2_buffer *vb, struct device *dev,
+			  unsigned long size)
+{
+	struct vb2_dc_buf *buf;
+
+	if (WARN_ON(!dev))
+		return ERR_PTR(-EINVAL);
+
+	buf = kzalloc(sizeof *buf, GFP_KERNEL);
+	if (!buf)
+		return ERR_PTR(-ENOMEM);
+
+	buf->attrs = vb->vb2_queue->dma_attrs;
+	buf->cookie = dma_alloc_attrs(dev, size, &buf->dma_addr,
+					GFP_KERNEL | vb->vb2_queue->gfp_flags, buf->attrs);
+	if (!buf->cookie) {
+		dev_info(dev, "dma_alloc_coherent of size %ld failed\n", size);
+		kfree(buf);
+		return ERR_PTR(-ENOMEM);
+	}
+
+	if ((buf->attrs & DMA_ATTR_NO_KERNEL_MAPPING) == 0)
+		buf->vaddr = buf->cookie;
+
+	/* Prevent the device from being released while the buffer is used */
+	buf->dev = get_device(dev);
+	buf->size = size;
+	buf->dma_dir = vb->vb2_queue->dma_dir;
+
+	buf->handler.refcount = &buf->refcount;
+	buf->handler.put = hcp_vb2_dc_put;
+	buf->handler.arg = buf;
+	buf->vb = vb;
+
+	refcount_set(&buf->refcount, 1);
+
+	return buf;
+}
+
+static int hcp_vb2_dc_mmap(void *buf_priv, struct vm_area_struct *vma)
+{
+	struct vb2_dc_buf *buf = buf_priv;
+	int ret;
+
+	if (!buf) {
+		pr_info("No buffer to map\n");
+		return -EINVAL;
+	}
+
+	ret = dma_mmap_attrs(buf->dev, vma, buf->cookie,
+		buf->dma_addr, buf->size, buf->attrs);
+
+	if (ret) {
+		pr_info("Remapping memory failed, error: %d\n", ret);
+		return ret;
+	}
+
+	vma->vm_flags		|= VM_DONTEXPAND | VM_DONTDUMP;
+	vma->vm_private_data	= &buf->handler;
+	vma->vm_ops		= &hcp_vb2_common_vm_ops;
+	vma->vm_ops->open(vma);
+
+	pr_debug("%s: mapped dma addr 0x%08lx at 0x%08lx, size %ld\n",
+		__func__, (unsigned long)buf->dma_addr, vma->vm_start,
+		buf->size);
+
+	return 0;
+}
+
+/*********************************************/
+/*         DMABUF ops for exporters          */
+/*********************************************/
+
+struct vb2_dc_attachment {
+	struct sg_table sgt;
+	enum dma_data_direction dma_dir;
+};
+
+static int hcp_vb2_dc_dmabuf_ops_attach(struct dma_buf *dbuf,
+	struct dma_buf_attachment *dbuf_attach)
+{
+	struct vb2_dc_attachment *attach;
+	unsigned int i;
+	struct scatterlist *rd, *wr;
+	struct sg_table *sgt;
+	struct vb2_dc_buf *buf = dbuf->priv;
+	int ret;
+
+	attach = kzalloc(sizeof(*attach), GFP_KERNEL);
+	if (!attach)
+		return -ENOMEM;
+
+	sgt = &attach->sgt;
+	/* Copy the buf->base_sgt scatter list to the attachment, as we can't
+	 * map the same scatter list to multiple attachments at the same time.
+	 */
+	ret = sg_alloc_table(sgt, buf->sgt_base->orig_nents, GFP_KERNEL);
+	if (ret) {
+		kfree(attach);
+		return -ENOMEM;
+	}
+
+	rd = buf->sgt_base->sgl;
+	wr = sgt->sgl;
+	for (i = 0; i < sgt->orig_nents; ++i) {
+		sg_set_page(wr, sg_page(rd), rd->length, rd->offset);
+		rd = sg_next(rd);
+		wr = sg_next(wr);
+	}
+
+	attach->dma_dir = DMA_NONE;
+	dbuf_attach->priv = attach;
+
+	return 0;
+}
+
+static void hcp_vb2_dc_dmabuf_ops_detach(struct dma_buf *dbuf,
+	struct dma_buf_attachment *db_attach)
+{
+	struct vb2_dc_attachment *attach = db_attach->priv;
+	struct sg_table *sgt;
+
+	if (!attach)
+		return;
+
+	sgt = &attach->sgt;
+
+	/* release the scatterlist cache */
+	if (attach->dma_dir != DMA_NONE)
+		/*
+		 * Cache sync can be skipped here, as the vb2_dc memory is
+		 * allocated from device coherent memory, which means the
+		 * memory locations do not require any explicit cache
+		 * maintenance prior or after being used by the device.
+		 */
+		dma_unmap_sgtable(db_attach->dev, sgt, attach->dma_dir,
+				  DMA_ATTR_SKIP_CPU_SYNC);
+	sg_free_table(sgt);
+	kfree(attach);
+	db_attach->priv = NULL;
+}
+
+static struct sg_table *hcp_vb2_dc_dmabuf_ops_map(
+	struct dma_buf_attachment *db_attach, enum dma_data_direction dma_dir)
+{
+	struct vb2_dc_attachment *attach = db_attach->priv;
+	/* stealing dmabuf mutex to serialize map/unmap operations */
+	struct sg_table *sgt;
+
+	spin_lock(&db_attach->dmabuf->name_lock);
+
+	sgt = &attach->sgt;
+	/* return previously mapped sg table */
+	if (attach->dma_dir == dma_dir) {
+		spin_unlock(&db_attach->dmabuf->name_lock);
+		return sgt;
+	}
+
+	/* release any previous cache */
+	if (attach->dma_dir != DMA_NONE) {
+		dma_unmap_sgtable(db_attach->dev, sgt, attach->dma_dir,
+				  DMA_ATTR_SKIP_CPU_SYNC);
+		attach->dma_dir = DMA_NONE;
+	}
+
+	/*
+	 * mapping to the client with new direction, no cache sync
+	 * required see comment in vb2_dc_dmabuf_ops_detach()
+	 */
+	if (dma_map_sgtable(db_attach->dev, sgt, dma_dir,
+			    DMA_ATTR_SKIP_CPU_SYNC)) {
+		pr_info("failed to map scatterlist\n");
+		spin_unlock(&db_attach->dmabuf->name_lock);
+		return ERR_PTR(-EIO);
+	}
+
+	attach->dma_dir = dma_dir;
+
+	spin_unlock(&db_attach->dmabuf->name_lock);
+
+	return sgt;
+}
+
+static void hcp_vb2_dc_dmabuf_ops_unmap(struct dma_buf_attachment *db_attach,
+	struct sg_table *sgt, enum dma_data_direction dma_dir)
+{
+	/* nothing to be done here */
+}
+
+static void hcp_vb2_dc_dmabuf_ops_release(struct dma_buf *dbuf)
+{
+	/* drop reference obtained in vb2_dc_get_dmabuf */
+	hcp_vb2_dc_put(dbuf->priv);
+}
+
+static int
+hcp_vb2_dc_dmabuf_ops_begin_cpu_access(struct dma_buf *dbuf,
+				   enum dma_data_direction direction)
+{
+	return 0;
+}
+
+static int
+hcp_vb2_dc_dmabuf_ops_end_cpu_access(struct dma_buf *dbuf,
+				 enum dma_data_direction direction)
+{
+	return 0;
+}
+
+static int hcp_vb2_dc_dmabuf_ops_vmap(struct dma_buf *dbuf,
+	struct iosys_map *map)
+{
+	struct vb2_dc_buf *buf = dbuf->priv;
+
+	iosys_map_set_vaddr(map, buf->vaddr);
+
+	return 0;
+}
+
+static int hcp_vb2_dc_dmabuf_ops_mmap(struct dma_buf *dbuf,
+	struct vm_area_struct *vma)
+{
+	return hcp_vb2_dc_mmap(dbuf->priv, vma);
+}
+
+static const struct dma_buf_ops hcp_vb2_dc_dmabuf_ops = {
+	.attach = hcp_vb2_dc_dmabuf_ops_attach,
+	.detach = hcp_vb2_dc_dmabuf_ops_detach,
+	.map_dma_buf = hcp_vb2_dc_dmabuf_ops_map,
+	.unmap_dma_buf = hcp_vb2_dc_dmabuf_ops_unmap,
+	.begin_cpu_access = hcp_vb2_dc_dmabuf_ops_begin_cpu_access,
+	.end_cpu_access = hcp_vb2_dc_dmabuf_ops_end_cpu_access,
+	.vmap = hcp_vb2_dc_dmabuf_ops_vmap,
+	.mmap = hcp_vb2_dc_dmabuf_ops_mmap,
+	.release = hcp_vb2_dc_dmabuf_ops_release,
+};
+
+static struct sg_table *hcp_vb2_dc_get_base_sgt(struct vb2_dc_buf *buf)
+{
+	int ret;
+	struct sg_table *sgt;
+
+	sgt = kmalloc(sizeof(*sgt), GFP_KERNEL);
+	if (!sgt) {
+		dev_info(buf->dev, "failed to alloc sg table\n");
+		return NULL;
+	}
+
+	ret = dma_get_sgtable_attrs(buf->dev, sgt, buf->cookie, buf->dma_addr,
+		buf->size, buf->attrs);
+	if (ret < 0) {
+		dev_info(buf->dev, "failed to get scatterlist from DMA API\n");
+		kfree(sgt);
+		return NULL;
+	}
+
+	return sgt;
+}
+
+static struct dma_buf *hcp_vb2_dc_get_dmabuf(struct vb2_buffer *vb,
+	void *buf_priv, unsigned long flags)
+{
+	struct vb2_dc_buf *buf = buf_priv;
+	struct dma_buf *dbuf;
+	DEFINE_DMA_BUF_EXPORT_INFO(exp_info);
+
+	exp_info.ops = &hcp_vb2_dc_dmabuf_ops;
+	exp_info.size = buf->size;
+	exp_info.flags = flags;
+	exp_info.priv = buf;
+
+	if (!buf->sgt_base)
+		buf->sgt_base = hcp_vb2_dc_get_base_sgt(buf);
+
+	if (WARN_ON(!buf->sgt_base))
+		return NULL;
+
+	dbuf = dma_buf_export(&exp_info);
+	if (IS_ERR(dbuf))
+		return NULL;
+
+	/* dmabuf keeps reference to vb2 buffer */
+	refcount_inc(&buf->refcount);
+
+	return dbuf;
+}
+
+/*********************************************/
+/*       callbacks for USERPTR buffers       */
+/*********************************************/
+
+static void hcp_vb2_dc_put_userptr(void *buf_priv)
+{
+	struct vb2_dc_buf *buf = buf_priv;
+	struct sg_table *sgt = buf->dma_sgt;
+	int i;
+	struct page **pages;
+
+	if (sgt) {
+		/*
+		 * No need to sync to CPU, it's already synced to the CPU
+		 * since the finish() memop will have been called before this.
+		 */
+		dma_unmap_sgtable(buf->dev, sgt, buf->dma_dir,
+				  DMA_ATTR_SKIP_CPU_SYNC);
+		pages = frame_vector_pages(buf->vec);
+		/* sgt should exist only if vector contains pages... */
+		BUG_ON(IS_ERR(pages));
+		if (buf->dma_dir == DMA_FROM_DEVICE ||
+		    buf->dma_dir == DMA_BIDIRECTIONAL)
+			for (i = 0; i < frame_vector_count(buf->vec); i++)
+				set_page_dirty_lock(pages[i]);
+		sg_free_table(sgt);
+		kfree(sgt);
+	} else {
+		dma_unmap_resource(buf->dev, buf->dma_addr, buf->size,
+				   buf->dma_dir, 0);
+	}
+	hcp_vb2_destroy_framevec(buf->vec);
+	kfree(buf);
+}
+
+static void *hcp_vb2_dc_get_userptr(struct vb2_buffer *vb, struct device *dev,
+	unsigned long vaddr, unsigned long size)
+{
+	struct vb2_dc_buf *buf;
+	struct frame_vector *vec;
+	unsigned int offset;
+	int n_pages, i;
+	int ret = 0;
+	struct sg_table *sgt;
+	unsigned long contig_size;
+	unsigned long dma_align = dma_get_cache_alignment();
+
+	/* Only cache aligned DMA transfers are reliable */
+	if (!IS_ALIGNED(vaddr | size, dma_align)) {
+		pr_debug("user data must be aligned to %lu bytes\n", dma_align);
+		return ERR_PTR(-EINVAL);
+	}
+
+	if (!size) {
+		pr_debug("size is zero\n");
+		return ERR_PTR(-EINVAL);
+	}
+
+	if (WARN_ON(!dev))
+		return ERR_PTR(-EINVAL);
+
+	buf = kzalloc(sizeof *buf, GFP_KERNEL);
+	if (!buf)
+		return ERR_PTR(-ENOMEM);
+
+	buf->dev = dev;
+	buf->dma_dir = vb->vb2_queue->dma_dir;
+	buf->vb = vb;
+
+	offset = lower_32_bits(offset_in_page(vaddr));
+	vec = hcp_vb2_create_framevec(vaddr, size);
+	if (IS_ERR(vec)) {
+		ret = PTR_ERR(vec);
+		goto fail_buf;
+	}
+	buf->vec = vec;
+	n_pages = frame_vector_count(vec);
+	ret = frame_vector_to_pages(vec);
+	if (ret < 0) {
+		unsigned long *nums = frame_vector_pfns(vec);
+
+		/*
+		 * Failed to convert to pages... Check the memory is physically
+		 * contiguous and use direct mapping
+		 */
+		for (i = 1; i < n_pages; i++)
+			if (nums[i-1] + 1 != nums[i])
+				goto fail_pfnvec;
+		buf->dma_addr = dma_map_resource(buf->dev,
+				__pfn_to_phys(nums[0]), size, buf->dma_dir, 0);
+		if (dma_mapping_error(buf->dev, buf->dma_addr)) {
+			ret = -ENOMEM;
+			goto fail_pfnvec;
+		}
+		goto out;
+	}
+
+	sgt = kzalloc(sizeof(*sgt), GFP_KERNEL);
+	if (!sgt) {
+		pr_info("failed to allocate sg table\n");
+		ret = -ENOMEM;
+		goto fail_pfnvec;
+	}
+
+	ret = sg_alloc_table_from_pages(sgt, frame_vector_pages(vec), n_pages,
+		offset, size, GFP_KERNEL);
+	if (ret) {
+		pr_info("failed to initialize sg table\n");
+		goto fail_sgt;
+	}
+
+	/*
+	 * No need to sync to the device, this will happen later when the
+	 * prepare() memop is called.
+	 */
+	if (dma_map_sgtable(buf->dev, sgt, buf->dma_dir,
+			    DMA_ATTR_SKIP_CPU_SYNC)) {
+		pr_info("failed to map scatterlist\n");
+		ret = -EIO;
+		goto fail_sgt_init;
+	}
+
+	contig_size = hcp_vb2_dc_get_contiguous_size(sgt);
+	if (contig_size < size) {
+		pr_info("contiguous mapping is too small %lu/%lu\n",
+			contig_size, size);
+		ret = -EFAULT;
+		goto fail_map_sg;
+	}
+
+	buf->dma_addr = sg_dma_address(sgt->sgl);
+	buf->dma_sgt = sgt;
+out:
+	buf->size = size;
+
+	return buf;
+
+fail_map_sg:
+	dma_unmap_sgtable(buf->dev, sgt, buf->dma_dir, DMA_ATTR_SKIP_CPU_SYNC);
+
+fail_sgt_init:
+	sg_free_table(sgt);
+
+fail_sgt:
+	kfree(sgt);
+
+fail_pfnvec:
+	hcp_vb2_destroy_framevec(vec);
+
+fail_buf:
+	kfree(buf);
+
+	return ERR_PTR(ret);
+}
+
+/*********************************************/
+/*       callbacks for DMABUF buffers        */
+/*********************************************/
+
+static int hcp_vb2_dc_map_dmabuf(void *mem_priv)
+{
+	struct vb2_dc_buf *buf = mem_priv;
+	struct sg_table *sgt;
+	unsigned long contig_size;
+
+	if (WARN_ON(!buf->db_attach)) {
+		pr_info("trying to pin a non attached buffer\n");
+		return -EINVAL;
+	}
+
+	if (WARN_ON(buf->dma_sgt)) {
+		pr_info("dmabuf buffer is already pinned\n");
+		return 0;
+	}
+
+	/* get the associated scatterlist for this buffer */
+	sgt = dma_buf_map_attachment(buf->db_attach, buf->dma_dir);
+	if (IS_ERR(sgt)) {
+		pr_info("Error getting dmabuf scatterlist\n");
+		return -EINVAL;
+	}
+
+	/* checking if dmabuf is big enough to store contiguous chunk */
+	contig_size = hcp_vb2_dc_get_contiguous_size(sgt);
+	if (contig_size < buf->size) {
+		pr_info("contiguous chunk is too small %lu/%lu b\n",
+			contig_size, buf->size);
+		dma_buf_unmap_attachment(buf->db_attach, sgt, buf->dma_dir);
+		return -EFAULT;
+	}
+
+	buf->dma_addr = sg_dma_address(sgt->sgl);
+	buf->dma_sgt = sgt;
+	buf->vaddr = NULL;
+
+	return 0;
+}
+
+static void hcp_vb2_dc_unmap_dmabuf(void *mem_priv)
+{
+	struct vb2_dc_buf *buf = mem_priv;
+	struct sg_table *sgt = buf->dma_sgt;
+
+	if (WARN_ON(!buf->db_attach)) {
+		pr_info("trying to unpin a not attached buffer\n");
+		return;
+	}
+
+	if (WARN_ON(!sgt)) {
+		pr_info("dmabuf buffer is already unpinned\n");
+		return;
+	}
+
+	if (buf->vaddr) {
+		dma_buf_vunmap(buf->db_attach->dmabuf, buf->vaddr);
+		buf->vaddr = NULL;
+	}
+	dma_buf_unmap_attachment(buf->db_attach, sgt, buf->dma_dir);
+
+	buf->dma_addr = 0;
+	buf->dma_sgt = NULL;
+}
+
+static void hcp_vb2_dc_detach_dmabuf(void *mem_priv)
+{
+	struct vb2_dc_buf *buf = mem_priv;
+
+	/* if vb2 works correctly you should never detach mapped buffer */
+	if (WARN_ON(buf->dma_addr))
+		hcp_vb2_dc_unmap_dmabuf(buf);
+
+	/* detach this attachment */
+	dma_buf_detach(buf->db_attach->dmabuf, buf->db_attach);
+	kfree(buf);
+}
+
+static void *hcp_vb2_dc_attach_dmabuf(struct vb2_buffer *vb, struct device *dev,
+	struct dma_buf *dbuf, unsigned long size)
+{
+	struct vb2_dc_buf *buf;
+	struct dma_buf_attachment *dba;
+
+	if (dbuf->size < size)
+		return ERR_PTR(-EFAULT);
+
+	if (WARN_ON(!dev))
+		return ERR_PTR(-EINVAL);
+
+	buf = kzalloc(sizeof(*buf), GFP_KERNEL);
+	if (!buf)
+		return ERR_PTR(-ENOMEM);
+
+	buf->dev = dev;
+	buf->vb = vb;
+
+	/* create attachment for the dmabuf with the user device */
+	dba = dma_buf_attach(dbuf, buf->dev);
+	if (IS_ERR(dba)) {
+		pr_info("failed to attach dmabuf\n");
+		kfree(buf);
+		return dba;
+	}
+
+	buf->dma_dir = vb->vb2_queue->dma_dir;
+	buf->size = size;
+	buf->db_attach = dba;
+
+	return buf;
+}
+
+/*********************************************/
+/*       DMA CONTIG exported functions       */
+/*********************************************/
+
+const struct vb2_mem_ops hcp_vb2_dma_contig_memops = {
+	.alloc		= hcp_vb2_dc_alloc,
+	.put		= hcp_vb2_dc_put,
+	.get_dmabuf	= hcp_vb2_dc_get_dmabuf,
+	.cookie		= hcp_vb2_dc_cookie,
+	.vaddr		= hcp_vb2_dc_vaddr,
+	.mmap		= hcp_vb2_dc_mmap,
+	.get_userptr	= hcp_vb2_dc_get_userptr,
+	.put_userptr	= hcp_vb2_dc_put_userptr,
+	.prepare	= hcp_vb2_dc_prepare,
+	.finish		= hcp_vb2_dc_finish,
+	.map_dmabuf	= hcp_vb2_dc_map_dmabuf,
+	.unmap_dmabuf	= hcp_vb2_dc_unmap_dmabuf,
+	.attach_dmabuf	= hcp_vb2_dc_attach_dmabuf,
+	.detach_dmabuf	= hcp_vb2_dc_detach_dmabuf,
+	.num_users	= hcp_vb2_dc_num_users,
+};
+EXPORT_SYMBOL_GPL(hcp_vb2_dma_contig_memops);
+
+/**
+ * vb2_dma_contig_set_max_seg_size() - configure DMA max segment size
+ * @dev:	device for configuring DMA parameters
+ * @size:	size of DMA max segment size to set
+ *
+ * To allow mapping the scatter-list into a single chunk in the DMA
+ * address space, the device is required to have the DMA max segment
+ * size parameter set to a value larger than the buffer size. Otherwise,
+ * the DMA-mapping subsystem will split the mapping into max segment
+ * size chunks. This function sets the DMA max segment size
+ * parameter to let DMA-mapping map a buffer as a single chunk in DMA
+ * address space.
+ * This code assumes that the DMA-mapping subsystem will merge all
+ * scatterlist segments if this is really possible (for example when
+ * an IOMMU is available and enabled).
+ * Ideally, this parameter should be set by the generic bus code, but it
+ * is left with the default 64KiB value due to historical litmiations in
+ * other subsystems (like limited USB host drivers) and there no good
+ * place to set it to the proper value.
+ * This function should be called from the drivers, which are known to
+ * operate on platforms with IOMMU and provide access to shared buffers
+ * (either USERPTR or DMABUF). This should be done before initializing
+ * videobuf2 queue.
+ */
+int hcp_vb2_dma_contig_set_max_seg_size(struct device *dev, unsigned int size)
+{
+	if (!dev->dma_parms) {
+		dev_info(dev, "Failed to set max_seg_size: dma_parms is NULL\n");
+		return -ENODEV;
+	}
+	if (dma_get_max_seg_size(dev) < size)
+		return dma_set_max_seg_size(dev, size);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(hcp_vb2_dma_contig_set_max_seg_size);
+
+MODULE_DESCRIPTION("HCP DMA-contig memory handling routines for videobuf2");
+MODULE_LICENSE("GPL");
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/mtk-hcp/mem/hcp_videobuf2-dma-contig.h b/drivers/media/platform/mediatek/isp/isp_7x/mtk-hcp/mem/hcp_videobuf2-dma-contig.h
new file mode 100644
index 0000000000000000000000000000000000000000..af0f82b76c4dfba8788b587f875cedf3c2264422
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/mtk-hcp/mem/hcp_videobuf2-dma-contig.h
@@ -0,0 +1,25 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2021 MediaTek Inc.
+ */
+
+#ifndef _HCP_MEDIA_VIDEOBUF2_DMA_CONTIG_H
+#define _HCP_MEDIA_VIDEOBUF2_DMA_CONTIG_H
+
+#include <media/videobuf2-v4l2.h>
+#include <linux/dma-mapping.h>
+
+static inline dma_addr_t
+hcp_vb2_dma_contig_plane_dma_addr(struct vb2_buffer *vb, unsigned int plane_no)
+{
+	dma_addr_t *addr = vb2_plane_cookie(vb, plane_no);
+
+	return *addr;
+}
+
+int hcp_vb2_dma_contig_set_max_seg_size(struct device *dev, unsigned int size);
+void hcp_vb2_dma_contig_clear_max_seg_size(struct device *dev);
+
+extern const struct vb2_mem_ops hcp_vb2_dma_contig_memops;
+
+#endif
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/mtk-hcp/mem/hcp_videobuf2-memops.c b/drivers/media/platform/mediatek/isp/isp_7x/mtk-hcp/mem/hcp_videobuf2-memops.c
new file mode 100644
index 0000000000000000000000000000000000000000..923c6d0568bcb5e370cc58d7e7fbb43c982e33a0
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/mtk-hcp/mem/hcp_videobuf2-memops.c
@@ -0,0 +1,135 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2021 MediaTek Inc.
+ */
+
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/dma-mapping.h>
+#include <linux/vmalloc.h>
+#include <linux/mm.h>
+#include <linux/sched.h>
+#include <linux/file.h>
+
+#include <media/videobuf2-v4l2.h>
+#include "hcp_videobuf2-memops.h"
+
+/*#define WORKAROUND*/
+
+/**
+ * vb2_create_framevec() - map virtual addresses to pfns
+ * @start:	Virtual user address where we start mapping
+ * @length:	Length of a range to map
+ * @write:	Should we map for writing into the area
+ *
+ * This function allocates and fills in a vector with pfns corresponding to
+ * virtual address range passed in arguments. If pfns have corresponding pages,
+ * page references are also grabbed to pin pages in memory. The function
+ * returns pointer to the vector on success and error pointer in case of
+ * failure. Returned vector needs to be freed via vb2_destroy_pfnvec().
+ */
+struct frame_vector *hcp_vb2_create_framevec(unsigned long start,
+					 unsigned long length)
+{
+	int ret;
+	unsigned long first, last;
+	unsigned long nr;
+	struct frame_vector *vec;
+
+	first = start >> PAGE_SHIFT;
+	last = (start + length - 1) >> PAGE_SHIFT;
+	nr = last - first + 1;
+	vec = frame_vector_create(nr);
+	if (!vec)
+		return ERR_PTR(-ENOMEM);
+	ret = get_vaddr_frames(start & PAGE_MASK, nr, true, vec);
+    ret = 0;
+	if (ret < 0)
+		goto out_destroy;
+	/* We accept only complete set of PFNs */
+	if (ret != nr) {
+		ret = -EFAULT;
+		goto out_release;
+	}
+	return vec;
+out_release:
+	put_vaddr_frames(vec);
+out_destroy:
+	frame_vector_destroy(vec);
+	return ERR_PTR(ret);
+}
+EXPORT_SYMBOL(hcp_vb2_create_framevec);
+
+/**
+ * vb2_destroy_framevec() - release vector of mapped pfns
+ * @vec:	vector of pfns / pages to release
+ *
+ * This releases references to all pages in the vector @vec (if corresponding
+ * pfns are backed by pages) and frees the passed vector.
+ */
+void hcp_vb2_destroy_framevec(struct frame_vector *vec)
+{
+	put_vaddr_frames(vec);
+	frame_vector_destroy(vec);
+}
+EXPORT_SYMBOL(hcp_vb2_destroy_framevec);
+
+/**
+ * vb2_common_vm_open() - increase refcount of the vma
+ * @vma:	virtual memory region for the mapping
+ *
+ * This function adds another user to the provided vma. It expects
+ * struct vb2_vmarea_handler pointer in vma->vm_private_data.
+ */
+static void hcp_vb2_common_vm_open(struct vm_area_struct *vma)
+{
+	struct vb2_vmarea_handler *h = vma->vm_private_data;
+
+	pr_debug("%s + vma: %08lx-%08lx\n",
+		       __func__, vma->vm_start,
+		       vma->vm_end);
+
+	pr_debug("%s: %p, refcount: %d, vma: %08lx-%08lx\n",
+	       __func__, h, refcount_read(h->refcount), vma->vm_start,
+	       vma->vm_end);
+
+	refcount_inc(h->refcount);
+}
+
+/**
+ * vb2_common_vm_close() - decrease refcount of the vma
+ * @vma:	virtual memory region for the mapping
+ *
+ * This function releases the user from the provided vma. It expects
+ * struct vb2_vmarea_handler pointer in vma->vm_private_data.
+ */
+static void hcp_vb2_common_vm_close(struct vm_area_struct *vma)
+{
+	struct vb2_vmarea_handler *h = vma->vm_private_data;
+
+	pr_debug("%s + vma: %08lx-%08lx\n",
+		       __func__, vma->vm_start,
+		       vma->vm_end);
+#ifdef WORKAROUND
+	return;
+#else
+	pr_debug("%s: %p, refcount: %d, vma: %08lx-%08lx\n",
+	       __func__, h, refcount_read(h->refcount), vma->vm_start,
+	       vma->vm_end);
+
+	h->put(h->arg);
+#endif
+}
+
+/*
+ * vb2_common_vm_ops - common vm_ops used for tracking refcount of mmapped
+ * video buffers
+ */
+const struct vm_operations_struct hcp_vb2_common_vm_ops = {
+	.open = hcp_vb2_common_vm_open,
+	.close = hcp_vb2_common_vm_close,
+};
+EXPORT_SYMBOL_GPL(hcp_vb2_common_vm_ops);
+
+MODULE_DESCRIPTION("HCP specific memory handling routines for hcp_videobuf2");
+MODULE_LICENSE("GPL");
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/mtk-hcp/mem/hcp_videobuf2-memops.h b/drivers/media/platform/mediatek/isp/isp_7x/mtk-hcp/mem/hcp_videobuf2-memops.h
new file mode 100644
index 0000000000000000000000000000000000000000..ce0960643427c774db639c749e2c8b4514a7a1a6
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/mtk-hcp/mem/hcp_videobuf2-memops.h
@@ -0,0 +1,32 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2021 MediaTek Inc.
+ */
+
+#ifndef _HCP_MEDIA_VIDEOBUF2_MEMOPS_H
+#define _HCP_MEDIA_VIDEOBUF2_MEMOPS_H
+
+#include <media/videobuf2-v4l2.h>
+#include <linux/mm.h>
+#include <linux/refcount.h>
+
+/**
+ * struct vb2_vmarea_handler - common vma refcount tracking handler.
+ *
+ * @refcount:	pointer to &refcount_t entry in the buffer.
+ * @put:	callback to function that decreases buffer refcount.
+ * @arg:	argument for @put callback.
+ */
+struct vb2_vmarea_handler {
+	refcount_t		*refcount;
+	void			(*put)(void *arg);
+	void			*arg;
+};
+
+extern const struct vm_operations_struct hcp_vb2_common_vm_ops;
+
+struct frame_vector *hcp_vb2_create_framevec(unsigned long start,
+					 unsigned long length);
+void hcp_vb2_destroy_framevec(struct frame_vector *vec);
+
+#endif
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/mtk-hcp/mem/hcp_videobuf2-vmalloc.c b/drivers/media/platform/mediatek/isp/isp_7x/mtk-hcp/mem/hcp_videobuf2-vmalloc.c
new file mode 100644
index 0000000000000000000000000000000000000000..d2d9c4614dc732f5d1ccf479a670f923ab348668
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/mtk-hcp/mem/hcp_videobuf2-vmalloc.c
@@ -0,0 +1,438 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2021 MediaTek Inc.
+ */
+
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/mm.h>
+#include <linux/refcount.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+
+#include <media/videobuf2-v4l2.h>
+#include <media/videobuf2-vmalloc.h>
+#include <media/videobuf2-memops.h>
+
+struct vb2_vmalloc_buf {
+	void				*vaddr;
+	struct frame_vector		*vec;
+	enum dma_data_direction		dma_dir;
+	unsigned long			size;
+	refcount_t			refcount;
+	struct vb2_vmarea_handler	handler;
+	struct dma_buf			*dbuf;
+};
+
+static void hcp_vb2_vmalloc_put(void *buf_priv);
+
+static void *hcp_vb2_vmalloc_alloc(struct vb2_buffer *vb, struct device *dev,
+			       unsigned long size)
+{
+	struct vb2_vmalloc_buf *buf;
+
+	buf = kzalloc(sizeof(*buf), GFP_KERNEL | vb->vb2_queue->gfp_flags);
+	if (!buf)
+		return ERR_PTR(-ENOMEM);
+
+	buf->size = size;
+	buf->vaddr = vmalloc_user(buf->size);
+	if (!buf->vaddr) {
+		pr_debug("vmalloc of size %ld failed\n", buf->size);
+		kfree(buf);
+		return ERR_PTR(-ENOMEM);
+	}
+
+	buf->dma_dir = vb->vb2_queue->dma_dir;
+	buf->handler.refcount = &buf->refcount;
+	buf->handler.put = hcp_vb2_vmalloc_put;
+	buf->handler.arg = buf;
+
+	refcount_set(&buf->refcount, 1);
+	return buf;
+}
+
+static void hcp_vb2_vmalloc_put(void *buf_priv)
+{
+	struct vb2_vmalloc_buf *buf = buf_priv;
+
+	if (refcount_dec_and_test(&buf->refcount)) {
+		vfree(buf->vaddr);
+		kfree(buf);
+	}
+}
+
+static void *hcp_vb2_vmalloc_get_userptr(struct vb2_buffer *vb,
+				     struct device *dev,
+				     unsigned long vaddr,
+				     unsigned long size)
+{
+	struct vb2_vmalloc_buf *buf;
+	struct frame_vector *vec;
+	int n_pages, offset, i;
+	int ret = -ENOMEM;
+
+	buf = kzalloc(sizeof(*buf), GFP_KERNEL);
+	if (!buf)
+		return ERR_PTR(-ENOMEM);
+
+	buf->dma_dir = vb->vb2_queue->dma_dir;
+	offset = vaddr & ~PAGE_MASK;
+	buf->size = size;
+	vec = vb2_create_framevec(vaddr, size, true);
+	if (IS_ERR(vec)) {
+		ret = PTR_ERR(vec);
+		goto fail_pfnvec_create;
+	}
+	buf->vec = vec;
+	n_pages = frame_vector_count(vec);
+	if (frame_vector_to_pages(vec) < 0) {
+		unsigned long *nums = frame_vector_pfns(vec);
+
+		/*
+		 * We cannot get page pointers for these pfns. Check memory is
+		 * physically contiguous and use direct mapping.
+		 */
+		for (i = 1; i < n_pages; i++)
+			if (nums[i-1] + 1 != nums[i])
+				goto fail_map;
+		buf->vaddr = (__force void *)
+			ioremap(__pfn_to_phys(nums[0]), size + offset);
+	} else {
+		buf->vaddr = vm_map_ram(frame_vector_pages(vec), n_pages, -1);
+	}
+
+	if (!buf->vaddr)
+		goto fail_map;
+	buf->vaddr += offset;
+	return buf;
+
+fail_map:
+	vb2_destroy_framevec(vec);
+fail_pfnvec_create:
+	kfree(buf);
+
+	return ERR_PTR(ret);
+}
+
+static void hcp_vb2_vmalloc_put_userptr(void *buf_priv)
+{
+	struct vb2_vmalloc_buf *buf = buf_priv;
+	unsigned long vaddr = (unsigned long)buf->vaddr & PAGE_MASK;
+	unsigned int i;
+	struct page **pages;
+	unsigned int n_pages;
+
+	if (!buf->vec->is_pfns) {
+		n_pages = frame_vector_count(buf->vec);
+		pages = frame_vector_pages(buf->vec);
+		if (vaddr)
+			vm_unmap_ram((void *)vaddr, n_pages);
+		if (buf->dma_dir == DMA_FROM_DEVICE ||
+		    buf->dma_dir == DMA_BIDIRECTIONAL)
+			for (i = 0; i < n_pages; i++)
+				set_page_dirty_lock(pages[i]);
+	} else {
+		iounmap((__force void __iomem *)buf->vaddr);
+	}
+	vb2_destroy_framevec(buf->vec);
+	kfree(buf);
+}
+
+static void *hcp_vb2_vmalloc_vaddr(struct vb2_buffer *vb, void *buf_priv)
+{
+	struct vb2_vmalloc_buf *buf = buf_priv;
+
+	if (!buf->vaddr) {
+		pr_info("Address of an unallocated plane requested or cannot map user pointer\n");
+		return NULL;
+	}
+
+	return buf->vaddr;
+}
+
+static unsigned int hcp_vb2_vmalloc_num_users(void *buf_priv)
+{
+	struct vb2_vmalloc_buf *buf = buf_priv;
+	return refcount_read(&buf->refcount);
+}
+
+static int hcp_vb2_vmalloc_mmap(void *buf_priv, struct vm_area_struct *vma)
+{
+	struct vb2_vmalloc_buf *buf = buf_priv;
+	int ret;
+
+	if (!buf) {
+		pr_info("No memory to map\n");
+		return -EINVAL;
+	}
+
+	ret = remap_vmalloc_range(vma, buf->vaddr, 0);
+	if (ret) {
+		pr_info("Remapping vmalloc memory, error: %d\n", ret);
+		return ret;
+	}
+
+	/*
+	 * Make sure that vm_areas for 2 buffers won't be merged together
+	 */
+	vma->vm_flags		|= VM_DONTEXPAND;
+
+	/*
+	 * Use common vm_area operations to track buffer refcount.
+	 */
+	vma->vm_private_data	= &buf->handler;
+	vma->vm_ops		= &vb2_common_vm_ops;
+
+	vma->vm_ops->open(vma);
+
+	return 0;
+}
+
+#ifdef CONFIG_HAS_DMA
+/*********************************************/
+/*         DMABUF ops for exporters          */
+/*********************************************/
+
+struct vb2_vmalloc_attachment {
+	struct sg_table sgt;
+	enum dma_data_direction dma_dir;
+};
+
+static int vb2_vmalloc_dmabuf_ops_attach(struct dma_buf *dbuf,
+	struct dma_buf_attachment *dbuf_attach)
+{
+	struct vb2_vmalloc_attachment *attach;
+	struct vb2_vmalloc_buf *buf = dbuf->priv;
+	int num_pages = PAGE_ALIGN(buf->size) / PAGE_SIZE;
+	struct sg_table *sgt;
+	struct scatterlist *sg;
+	void *vaddr = buf->vaddr;
+	int ret;
+	int i;
+
+	attach = kzalloc(sizeof(*attach), GFP_KERNEL);
+	if (!attach)
+		return -ENOMEM;
+
+	sgt = &attach->sgt;
+	ret = sg_alloc_table(sgt, num_pages, GFP_KERNEL);
+	if (ret) {
+		kfree(attach);
+		return ret;
+	}
+	for_each_sgtable_sg(sgt, sg, i) {
+		struct page *page = vmalloc_to_page(vaddr);
+
+		if (!page) {
+			sg_free_table(sgt);
+			kfree(attach);
+			return -ENOMEM;
+		}
+		sg_set_page(sg, page, PAGE_SIZE, 0);
+		vaddr += PAGE_SIZE;
+	}
+
+	attach->dma_dir = DMA_NONE;
+	dbuf_attach->priv = attach;
+	return 0;
+}
+
+static void vb2_vmalloc_dmabuf_ops_detach(struct dma_buf *dbuf,
+	struct dma_buf_attachment *db_attach)
+{
+	struct vb2_vmalloc_attachment *attach = db_attach->priv;
+	struct sg_table *sgt;
+
+	if (!attach)
+		return;
+
+	sgt = &attach->sgt;
+
+	/* release the scatterlist cache */
+	if (attach->dma_dir != DMA_NONE)
+		dma_unmap_sgtable(db_attach->dev, sgt, attach->dma_dir, 0);
+	sg_free_table(sgt);
+	kfree(attach);
+	db_attach->priv = NULL;
+}
+
+static struct sg_table *vb2_vmalloc_dmabuf_ops_map(
+	struct dma_buf_attachment *db_attach, enum dma_data_direction dma_dir)
+{
+	struct vb2_vmalloc_attachment *attach = db_attach->priv;
+	/* stealing dmabuf mutex to serialize map/unmap operations */
+	struct sg_table *sgt;
+
+	spin_lock(&db_attach->dmabuf->name_lock);
+
+	sgt = &attach->sgt;
+	/* return previously mapped sg table */
+	if (attach->dma_dir == dma_dir) {
+		spin_unlock(&db_attach->dmabuf->name_lock);
+		return sgt;
+	}
+
+	/* release any previous cache */
+	if (attach->dma_dir != DMA_NONE) {
+		dma_unmap_sgtable(db_attach->dev, sgt, attach->dma_dir, 0);
+		attach->dma_dir = DMA_NONE;
+	}
+
+	/* mapping to the client with new direction */
+	if (dma_map_sgtable(db_attach->dev, sgt, dma_dir, 0)) {
+		pr_info("failed to map scatterlist\n");
+		spin_unlock(&db_attach->dmabuf->name_lock);
+		return ERR_PTR(-EIO);
+	}
+
+	attach->dma_dir = dma_dir;
+
+	spin_unlock(&db_attach->dmabuf->name_lock);
+
+	return sgt;
+}
+
+static void vb2_vmalloc_dmabuf_ops_unmap(struct dma_buf_attachment *db_attach,
+	struct sg_table *sgt, enum dma_data_direction dma_dir)
+{
+	/* nothing to be done here */
+}
+
+static void vb2_vmalloc_dmabuf_ops_release(struct dma_buf *dbuf)
+{
+	/* drop reference obtained in vb2_vmalloc_get_dmabuf */
+	hcp_vb2_vmalloc_put(dbuf->priv);
+}
+
+static int vb2_vmalloc_dmabuf_ops_vmap(struct dma_buf *dbuf, struct iosys_map *map)
+{
+	struct vb2_vmalloc_buf *buf = dbuf->priv;
+
+	iosys_map_set_vaddr(map, buf->vaddr);
+
+	return 0;
+}
+
+static int vb2_vmalloc_dmabuf_ops_mmap(struct dma_buf *dbuf,
+	struct vm_area_struct *vma)
+{
+	return hcp_vb2_vmalloc_mmap(dbuf->priv, vma);
+}
+
+static const struct dma_buf_ops vb2_vmalloc_dmabuf_ops = {
+	.attach = vb2_vmalloc_dmabuf_ops_attach,
+	.detach = vb2_vmalloc_dmabuf_ops_detach,
+	.map_dma_buf = vb2_vmalloc_dmabuf_ops_map,
+	.unmap_dma_buf = vb2_vmalloc_dmabuf_ops_unmap,
+	.vmap = vb2_vmalloc_dmabuf_ops_vmap,
+	.mmap = vb2_vmalloc_dmabuf_ops_mmap,
+	.release = vb2_vmalloc_dmabuf_ops_release,
+};
+
+static struct dma_buf *hcp_vb2_vmalloc_get_dmabuf(struct vb2_buffer *vb,
+	void *buf_priv, unsigned long flags)
+{
+	struct vb2_vmalloc_buf *buf = buf_priv;
+	struct dma_buf *dbuf;
+	DEFINE_DMA_BUF_EXPORT_INFO(exp_info);
+
+	exp_info.ops = &vb2_vmalloc_dmabuf_ops;
+	exp_info.size = buf->size;
+	exp_info.flags = flags;
+	exp_info.priv = buf;
+
+	if (WARN_ON(!buf->vaddr))
+		return NULL;
+
+	dbuf = dma_buf_export(&exp_info);
+	if (IS_ERR(dbuf))
+		return NULL;
+
+	/* dmabuf keeps reference to vb2 buffer */
+	refcount_inc(&buf->refcount);
+
+	return dbuf;
+}
+#endif /* CONFIG_HAS_DMA */
+
+
+/*********************************************/
+/*       callbacks for DMABUF buffers        */
+/*********************************************/
+
+static int hcp_vb2_vmalloc_map_dmabuf(void *mem_priv)
+{
+	struct vb2_vmalloc_buf *buf = mem_priv;
+	struct iosys_map map;
+	int ret;
+
+	ret = dma_buf_vmap(buf->dbuf, &map);
+	if (ret)
+		return -EFAULT;
+	buf->vaddr = map.vaddr;
+
+	return 0;
+}
+
+static void hcp_vb2_vmalloc_unmap_dmabuf(void *mem_priv)
+{
+	struct vb2_vmalloc_buf *buf = mem_priv;
+
+	dma_buf_vunmap(buf->dbuf, buf->vaddr);
+	buf->vaddr = NULL;
+}
+
+static void hcp_vb2_vmalloc_detach_dmabuf(void *mem_priv)
+{
+	struct vb2_vmalloc_buf *buf = mem_priv;
+
+	if (buf->vaddr)
+		dma_buf_vunmap(buf->dbuf, buf->vaddr);
+
+	kfree(buf);
+}
+
+static void *hcp_vb2_vmalloc_attach_dmabuf(struct vb2_buffer *vb,
+	struct device *dev,
+	struct dma_buf *dbuf,
+	unsigned long size)
+{
+	struct vb2_vmalloc_buf *buf;
+
+	if (dbuf->size < size)
+		return ERR_PTR(-EFAULT);
+
+	buf = kzalloc(sizeof(*buf), GFP_KERNEL);
+	if (!buf)
+		return ERR_PTR(-ENOMEM);
+
+	buf->dbuf = dbuf;
+	buf->dma_dir = vb->vb2_queue->dma_dir;
+	buf->size = size;
+
+	return buf;
+}
+
+
+const struct vb2_mem_ops hcp_vb2_vmalloc_memops = {
+	.alloc		= hcp_vb2_vmalloc_alloc,
+	.put		= hcp_vb2_vmalloc_put,
+	.get_userptr	= hcp_vb2_vmalloc_get_userptr,
+	.put_userptr	= hcp_vb2_vmalloc_put_userptr,
+#ifdef CONFIG_HAS_DMA
+	.get_dmabuf	= hcp_vb2_vmalloc_get_dmabuf,
+#endif
+	.map_dmabuf	= hcp_vb2_vmalloc_map_dmabuf,
+	.unmap_dmabuf	= hcp_vb2_vmalloc_unmap_dmabuf,
+	.attach_dmabuf	= hcp_vb2_vmalloc_attach_dmabuf,
+	.detach_dmabuf	= hcp_vb2_vmalloc_detach_dmabuf,
+	.vaddr		= hcp_vb2_vmalloc_vaddr,
+	.mmap		= hcp_vb2_vmalloc_mmap,
+	.num_users	= hcp_vb2_vmalloc_num_users,
+};
+EXPORT_SYMBOL_GPL(hcp_vb2_vmalloc_memops);
+
+MODULE_DESCRIPTION("vmalloc memory handling routines for hcp_videobuf2");
+MODULE_LICENSE("GPL");
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/mtk-hcp/mem/hcp_videobuf2-vmalloc.h b/drivers/media/platform/mediatek/isp/isp_7x/mtk-hcp/mem/hcp_videobuf2-vmalloc.h
new file mode 100644
index 0000000000000000000000000000000000000000..2cf7324be85856a1c13210947a14ce2549b2d815
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/mtk-hcp/mem/hcp_videobuf2-vmalloc.h
@@ -0,0 +1,13 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2021 MediaTek Inc.
+ */
+
+#ifndef _HCP_MEDIA_VIDEOBUF2_VMALLOC_H
+#define _HCP_MEDIA_VIDEOBUF2_VMALLOC_H
+
+#include <media/videobuf2-v4l2.h>
+
+extern const struct vb2_mem_ops hcp_vb2_vmalloc_memops;
+
+#endif
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/mtk-hcp/mtk-hcp-support.h b/drivers/media/platform/mediatek/isp/isp_7x/mtk-hcp/mtk-hcp-support.h
new file mode 100644
index 0000000000000000000000000000000000000000..940e52d93e8511a88015aa2eafcf14bb16f936dd
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/mtk-hcp/mtk-hcp-support.h
@@ -0,0 +1,20 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2021 MediaTek Inc.
+ */
+#ifndef MTK_HCP_SUPPORT_H
+#define MTK_HCP_SUPPORT_H
+
+#include <mtk-hcp.h>
+
+int CM4_SUPPORT_CONFIGURE_TABLE[][2] = {
+#ifdef CONFIG_ISP_CM4_SUPPORT
+	{MODULE_ISP, 1},
+#endif
+#ifdef CONFI_FD_CM4_SUPPORT
+	{MODULE_FD, 1},
+#endif
+	{MODULE_MAX_ID, 0}
+};
+
+#endif /* _MTK_HCP_SUPPORT_H */
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/mtk-hcp/mtk-hcp.c b/drivers/media/platform/mediatek/isp/isp_7x/mtk-hcp/mtk-hcp.c
new file mode 100755
index 0000000000000000000000000000000000000000..129a1cd7e6980bd72775524cdd7e38f79958e55f
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/mtk-hcp/mtk-hcp.c
@@ -0,0 +1,2054 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2021 MediaTek Inc.
+ */
+
+#include <asm/cacheflush.h>
+#include <linux/cdev.h>
+#include <linux/dma-mapping.h>
+#include <linux/file.h>
+#include <linux/firmware.h>
+#include <linux/fs.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/kernel.h>
+#include <linux/kthread.h>
+#include <linux/list.h>
+#include <linux/module.h>
+#include <linux/of_address.h>
+#include <linux/of_irq.h>
+#include <linux/of_platform.h>
+#include <linux/of_reserved_mem.h>
+#include <linux/sched.h>
+#include <linux/uaccess.h>
+#include <linux/compat.h>
+#include <linux/freezer.h>
+#include <linux/pm_runtime.h>
+#include <linux/slab.h>
+#include <dma-iommu.h>
+#include <linux/dma-mapping.h>
+//#include <asm/dma-contiguous.h>
+#include <linux/videodev2.h>
+#include "mem/hcp_videobuf2-dma-contig.h"
+
+#include "mtk-hcp.h"
+#include "mtk-hcp-support.h"
+#if defined(IMGSYS_VER_ISP71)
+#include "mtk-hcp_isp71.h"
+#elif defined(IMGSYS_VER_ISP70)
+#include "mtk-hcp_isp70.h"
+#endif
+
+#ifdef CONFIG_MTK_IOMMU_V2
+#include "mtk_iommu_ext.h"
+#elif defined(CONFIG_MTK_IOMMU)
+//#include "mach/mt_iommu.h"
+#elif defined(CONFIG_MTK_M4U)
+#include "m4u.h"
+#endif
+
+#ifdef CONFIG_MTK_M4U
+#include "m4u.h"
+#include "m4u_port.h"
+#endif
+
+//#include "mtk_heap.h"
+#ifdef SUPPORT_APU
+#include "slbc_ops.h"
+#endif
+
+#include <linux/dma-heap.h>
+#include <uapi/linux/dma-heap.h>
+#include <linux/dma-heap.h>
+#include <linux/dma-direction.h>
+#include <linux/scatterlist.h>
+#include <linux/dma-buf.h>
+
+
+/**
+ * HCP (Hetero Control Processor ) is a tiny processor controlling
+ * the methodology of register programming. If the module support
+ * to run on CM4 then it will send data to CM4 to program register.
+ * Or it will send the data to user library and let RED to program
+ * register.
+ *
+ **/
+
+#define RED_PATH                "/dev/red"
+#define HCP_DEVNAME             "mtk_hcp"
+
+#define HCP_TIMEOUT_MS          4000U
+#define HCP_FW_VER_LEN          16
+#define MAX_REQUEST_SIZE        10
+
+#define SYNC_SEND               1
+#define ASYNC_SEND              0
+/*
+ * define magic number for reserved memory to use in mmap function.
+ */
+#define START_ISP_MEM_ADDR        0x12345000
+#define START_DIP_MEM_FOR_HW_ADDR 0x12346000
+#define START_MDP_MEM_ADDR        0x12347000
+#define START_FD_MEM_ADDR         0x12348000
+#define START_DIP_MEM_FOR_SW_ADDR 0x12349000
+
+/*
+ * define module register mmap address
+ */
+#define ISP_UNI_A_BASE_HW 0x1A003000
+#define ISP_A_BASE_HW           0x1A004000
+#define ISP_B_BASE_HW           0x1A006000
+#define ISP_C_BASE_HW           0x1A008000
+#define DIP_BASE_HW             0x15021000
+#define FD_BASE_HW              0x1502B000
+
+static struct mtk_hcp *hcp_mtkdev;
+
+#define IPI_MAX_BUFFER_COUNT    (8)
+
+struct packet {
+	int32_t module;
+	bool more;
+	int32_t count;
+	struct share_buf *buffer[IPI_MAX_BUFFER_COUNT];
+} ;
+
+struct compat_packet {
+	int32_t module;
+	bool more;
+	int32_t count;
+	/*struct share_buf **/compat_uptr_t buffer[IPI_MAX_BUFFER_COUNT];
+} ;
+
+#define CTRL_ID_SLB_BASE        (0x01)
+
+struct ctrl_data {
+	uint32_t id;
+	uintptr_t value;
+} __attribute__ ((__packed__));
+
+#define HCP_INIT                _IOWR('H', 0, struct share_buf)
+#define HCP_GET_OBJECT          _IOWR('H', 1, struct share_buf)
+#define HCP_NOTIFY              _IOWR('H', 2, struct share_buf)
+#define HCP_COMPLETE            _IOWR('H', 3, struct share_buf)
+#define HCP_WAKEUP              _IOWR('H', 4, struct share_buf)
+#define HCP_TIMEOUT             _IO('H', 5)
+
+#define COMPAT_HCP_INIT         _IOWR('H', 0, struct share_buf)
+#define COMPAT_HCP_GET_OBJECT   _IOWR('H', 1, struct share_buf)
+#define COMPAT_HCP_NOTIFY       _IOWR('H', 2, struct share_buf)
+#define COMPAT_HCP_COMPLETE     _IOWR('H', 3, struct share_buf)
+#define COMPAT_HCP_WAKEUP       _IOWR('H', 4, struct share_buf)
+#define COMPAT_HCP_TIMEOUT      _IO('H', 5)
+
+struct msg {
+	struct list_head entry;
+	struct share_buf user_obj;
+};
+#define  MSG_NR (96)
+/**
+ * struct my_wq_t - work struct to handle daemon notification
+ *
+ * @hcp_dev:        hcp device
+ * @ioctl_event:    ioctl event id
+ * @data_addr:      addr about shared data
+ * @task_work:      work struct
+ */
+struct my_wq_t {
+	struct mtk_hcp *hcp_dev;
+	unsigned int ioctl_event;
+	struct share_buf  data_addr;
+	struct work_struct task_work;
+};
+
+static struct msg *msg_pool_get(struct mtk_hcp *hcp_dev)
+{
+	unsigned long flag, empty;
+	struct msg *msg = NULL;
+
+	spin_lock_irqsave(&hcp_dev->msglock, flag);
+	empty = list_empty(&hcp_dev->msg_list);
+	if (!empty) {
+		msg = list_first_entry(&hcp_dev->msg_list, struct msg, entry);
+		list_del(&msg->entry);
+	}
+	spin_unlock_irqrestore(&hcp_dev->msglock, flag);
+
+	return msg;
+}
+
+static void chans_pool_dump(struct mtk_hcp *hcp_dev)
+{
+	unsigned long flag;
+	struct msg *msg, *tmp;
+	int i = 0, seq_id, req_fd, hcp_id;
+
+	spin_lock_irqsave(&hcp_dev->msglock, flag);
+	for (i = 0; i < MODULE_MAX_ID; i++) {
+		dev_info(hcp_dev->dev, "HCP(%d) stalled IPI object+\n", i);
+
+		list_for_each_entry_safe(msg, tmp,
+				&hcp_dev->chans[i], entry){
+
+			seq_id = msg->user_obj.info.send.seq;
+			req_fd = msg->user_obj.info.send.req;
+			hcp_id = msg->user_obj.info.send.hcp;
+
+			dev_info(hcp_dev->dev, "req_fd(%d), seq_id(%d), hcp_id(%d)\n",
+				req_fd, seq_id, hcp_id);
+		}
+
+		dev_info(hcp_dev->dev, "HCP(%d) stalled IPI object-\n", i);
+	}
+	spin_unlock_irqrestore(&hcp_dev->msglock, flag);
+}
+
+static struct msg *chan_pool_get(struct mtk_hcp *hcp_dev, int module_id)
+{
+	unsigned long flag, empty;
+	struct msg *msg = NULL;
+
+	spin_lock_irqsave(&hcp_dev->msglock, flag);
+	empty = list_empty(&hcp_dev->chans[module_id]);
+	if (!empty) {
+		msg = list_first_entry(&hcp_dev->chans[module_id], struct msg, entry);
+		list_del(&msg->entry);
+	}
+	empty = list_empty(&hcp_dev->chans[module_id]);
+	spin_unlock_irqrestore(&hcp_dev->msglock, flag);
+
+	// dev_info(hcp_dev->dev, "chan pool empty(%d)\n", empty);
+
+	return msg;
+}
+
+static bool chan_pool_available(struct mtk_hcp *hcp_dev, int module_id)
+{
+	unsigned long flag, empty;
+
+	spin_lock_irqsave(&hcp_dev->msglock, flag);
+	empty = list_empty(&hcp_dev->chans[module_id]);
+	spin_unlock_irqrestore(&hcp_dev->msglock, flag);
+
+	// dev_info(hcp_dev->dev, "chan pool abailable(%d)\n", !empty);
+
+	return (!empty);
+}
+
+inline int hcp_id_to_ipi_id(struct mtk_hcp *hcp_dev, enum hcp_id id)
+{
+	int ipi_id = -EINVAL;
+
+	if (id < HCP_INIT_ID || id >= HCP_MAX_ID) {
+		dev_info(hcp_dev->dev, "%s: Invalid hcp id %d\n", __func__, id);
+		return -EINVAL;
+	}
+
+	switch (id) {
+
+	default:
+		break;
+	}
+
+	dev_dbg(hcp_dev->dev, "ipi_id:%d\n", ipi_id);
+	return ipi_id;
+}
+
+inline int hcp_id_to_module_id(struct mtk_hcp *hcp_dev, enum hcp_id id)
+{
+	int module_id = -EINVAL;
+
+	if (id < HCP_INIT_ID || id >= HCP_MAX_ID) {
+		dev_info(hcp_dev->dev, "%s: Invalid hcp id %d\n", __func__, id);
+		return -EINVAL;
+	}
+
+	switch (id) {
+	case HCP_ISP_CMD_ID:
+	case HCP_ISP_FRAME_ID:
+		module_id = MODULE_ISP;
+		break;
+	case HCP_DIP_INIT_ID:
+	case HCP_DIP_FRAME_ID:
+	case HCP_IMGSYS_HW_TIMEOUT_ID:
+	case HCP_IMGSYS_SW_TIMEOUT_ID:
+	case HCP_DIP_DEQUE_DUMP_ID:
+	case HCP_IMGSYS_DEQUE_DONE_ID:
+	case HCP_IMGSYS_DEINIT_ID:
+	case HCP_IMGSYS_IOVA_FDS_ADD_ID:
+	case HCP_IMGSYS_IOVA_FDS_DEL_ID:
+	case HCP_IMGSYS_UVA_FDS_ADD_ID:
+	case HCP_IMGSYS_UVA_FDS_DEL_ID:
+	case HCP_IMGSYS_SET_CONTROL_ID:
+	case HCP_IMGSYS_GET_CONTROL_ID:
+		module_id = MODULE_DIP;
+		break;
+	case HCP_RSC_INIT_ID:
+	case HCP_RSC_FRAME_ID:
+		module_id = MODULE_RSC;
+		break;
+	default:
+		break;
+	}
+
+	dev_dbg(hcp_dev->dev, "module_id:%d\n", module_id);
+	return module_id;
+}
+
+inline int ipi_id_to_hcp_id(int id)
+{
+	int hcp_id = HCP_INIT_ID;
+
+	switch (id) {
+
+	default:
+		break;
+	}
+	pr_debug("[%s]hcp_id:%d\n", __func__, hcp_id);
+	return hcp_id;
+}
+
+static inline bool mtk_hcp_running(struct mtk_hcp *hcp_dev)
+{
+	return hcp_dev->is_open;
+}
+
+#if MTK_CM4_SUPPORT
+static void hcp_ipi_handler(int id, void *data, unsigned int len)
+{
+	int hcp_id = ipi_id_to_hcp_id(id);
+
+	if (hcp_mtkdev->hcp_desc_table[hcp_id].handler)
+		hcp_mtkdev->hcp_desc_table[hcp_id].handler(data, len, NULL);
+}
+#endif
+
+static void cm4_support_table_init(struct mtk_hcp *hcp)
+{
+	int i = 0;
+
+	for (i = 0; i < MODULE_MAX_ID; i++)
+		hcp->cm4_support_list[i] = false;
+
+	i = 0;
+	while (CM4_SUPPORT_CONFIGURE_TABLE[i][0] < MODULE_MAX_ID) {
+		if (CM4_SUPPORT_CONFIGURE_TABLE[i][1] == 1)
+			hcp->cm4_support_list[CM4_SUPPORT_CONFIGURE_TABLE[i][0]]
+									= true;
+		i++;
+	}
+}
+
+static bool mtk_hcp_cm4_support(struct mtk_hcp *hcp_dev, enum hcp_id id)
+{
+	bool is_cm4_support = false;
+
+	switch (id) {
+	case HCP_ISP_CMD_ID:
+	case HCP_ISP_FRAME_ID:
+		is_cm4_support = hcp_dev->cm4_support_list[MODULE_ISP];
+		break;
+	case HCP_DIP_INIT_ID:
+	case HCP_DIP_FRAME_ID:
+	case HCP_IMGSYS_HW_TIMEOUT_ID:
+	case HCP_IMGSYS_SW_TIMEOUT_ID:
+		is_cm4_support = hcp_dev->cm4_support_list[MODULE_DIP];
+		break;
+	case HCP_FD_CMD_ID:
+	case HCP_FD_FRAME_ID:
+		is_cm4_support = hcp_dev->cm4_support_list[MODULE_FD];
+		break;
+	case HCP_RSC_INIT_ID:
+	case HCP_RSC_FRAME_ID:
+		is_cm4_support = hcp_dev->cm4_support_list[MODULE_RSC];
+		break;
+	default:
+		break;
+	}
+
+	dev_dbg(hcp_dev->dev, "cm4 support status:%d\n", is_cm4_support);
+	return is_cm4_support;
+}
+
+int mtk_hcp_register(struct platform_device *pdev,
+				 enum hcp_id id, hcp_handler_t handler,
+				 const char *name, void *priv)
+{
+	struct mtk_hcp *hcp_dev = platform_get_drvdata(pdev);
+
+	if (hcp_dev == NULL) {
+		pr_info("%s hcp device in not ready\n", __func__);
+		return -EPROBE_DEFER;
+	}
+
+	if (id >= HCP_INIT_ID && id < HCP_MAX_ID && handler != NULL) {
+#if MTK_CM4_SUPPORT
+		if (mtk_hcp_cm4_support(hcp_dev, id) == true) {
+			int ipi_id = hcp_id_to_ipi_id(hcp_dev, id);
+
+			scp_ipi_registration(ipi_id, hcp_ipi_handler, name);
+		}
+#endif
+		hcp_dev->hcp_desc_table[id].name = name;
+		hcp_dev->hcp_desc_table[id].handler = handler;
+		hcp_dev->hcp_desc_table[id].priv = priv;
+		return 0;
+	}
+
+
+	dev_info(&pdev->dev, "%s register hcp id %d with invalid arguments\n",
+								__func__, id);
+
+	return -EINVAL;
+}
+EXPORT_SYMBOL(mtk_hcp_register);
+
+int mtk_hcp_unregister(struct platform_device *pdev, enum hcp_id id)
+{
+	struct mtk_hcp *hcp_dev = platform_get_drvdata(pdev);
+
+	if (hcp_dev == NULL) {
+		dev_info(&pdev->dev, "%s hcp device in not ready\n", __func__);
+		return -EPROBE_DEFER;
+	}
+
+	if (id >= HCP_INIT_ID && id < HCP_MAX_ID) {
+		memset((void *)&hcp_dev->hcp_desc_table[id], 0,
+						sizeof(struct hcp_desc));
+		return 0;
+	}
+
+	dev_info(&pdev->dev, "%s register hcp id %d with invalid arguments\n",
+								__func__, id);
+
+	return -EINVAL;
+}
+EXPORT_SYMBOL(mtk_hcp_unregister);
+
+static int hcp_send_internal(struct platform_device *pdev,
+		 enum hcp_id id, void *buf,
+		 unsigned int len, int req_fd,
+		 unsigned int wait)
+{
+	struct mtk_hcp *hcp_dev = platform_get_drvdata(pdev);
+	struct share_buf send_obj;
+	unsigned long timeout, flag;
+	struct msg *msg;
+	int ret = 0;
+	unsigned int no;
+
+	dev_dbg(&pdev->dev, "%s id:%d len %d\n",
+				__func__, id, len);
+
+	if (id < HCP_INIT_ID || id >= HCP_MAX_ID ||
+			len > sizeof(send_obj.share_data) || buf == NULL) {
+		dev_info(&pdev->dev,
+			"%s failed to send hcp message (Invalid arg.), len/sz(%d/%ld)\n",
+			__func__, len, sizeof(send_obj.share_data));
+		return -EINVAL;
+	}
+
+	if (mtk_hcp_running(hcp_dev) == false) {
+		dev_info(&pdev->dev, "%s hcp is not running\n", __func__);
+		return -EPERM;
+	}
+
+	if (mtk_hcp_cm4_support(hcp_dev, id) == true) {
+#if MTK_CM4_SUPPORT
+		int ipi_id = hcp_id_to_ipi_id(hcp_dev, id);
+
+		dev_dbg(&pdev->dev, "%s cm4 is support !!!\n", __func__);
+		return scp_ipi_send(ipi_id, buf, len, 0, SCP_A_ID);
+#endif
+	} else {
+		int module_id = hcp_id_to_module_id(hcp_dev, id);
+		if (module_id < MODULE_ISP || module_id >= MODULE_MAX_ID) {
+			dev_info(&pdev->dev, "%s invalid module id %d", __func__, module_id);
+			return -EINVAL;
+		}
+
+		timeout = msecs_to_jiffies(HCP_TIMEOUT_MS);
+		ret = wait_event_timeout(hcp_dev->msg_wq,
+			((msg = msg_pool_get(hcp_dev)) != NULL), timeout);
+		if (ret == 0) {
+			dev_info(&pdev->dev, "%s id:%d refill time out !\n",
+				__func__, id);
+			return -EIO;
+		} else if (-ERESTARTSYS == ret) {
+			dev_info(&pdev->dev, "%s id:%d refill interrupted !\n",
+				__func__, id);
+			return -ERESTARTSYS;
+		}
+
+		atomic_set(&hcp_dev->hcp_id_ack[id], 0);
+
+		//spin_lock_irqsave(&hcp_dev->msglock, flag);
+		//msg = list_first_entry(&hcp_dev->msg_list, struct msg, entry);
+		//list_del(&msg->entry);
+		//spin_unlock_irqrestore(&hcp_dev->msglock, flag);
+
+		memcpy((void *)msg->user_obj.share_data, buf, len);
+		msg->user_obj.len = len;
+
+		spin_lock_irqsave(&hcp_dev->msglock, flag);
+
+		no = atomic_inc_return(&hcp_dev->seq);
+
+		msg->user_obj.info.send.hcp = id;
+		msg->user_obj.info.send.req = req_fd;
+		msg->user_obj.info.send.seq = no;
+		msg->user_obj.info.send.ack = (wait ? 1 : 0);
+		msg->user_obj.id = id;
+
+		list_add_tail(&msg->entry, &hcp_dev->chans[module_id]);
+		spin_unlock_irqrestore(&hcp_dev->msglock, flag);
+
+		wake_up(&hcp_dev->poll_wq[module_id]);
+
+		dev_dbg(&pdev->dev,
+			"%s frame_no_%d, message(%d)size(%d) send to user space !!!\n",
+			__func__, no, id, len);
+
+		if (id == HCP_IMGSYS_SW_TIMEOUT_ID)
+			chans_pool_dump(hcp_dev);
+
+		if (!wait)
+			return 0;
+
+		/* wait for RED's ACK */
+		timeout = msecs_to_jiffies(HCP_TIMEOUT_MS);
+		ret = wait_event_timeout(hcp_dev->ack_wq[module_id],
+			atomic_cmpxchg(&(hcp_dev->hcp_id_ack[id]), 1, 0), timeout);
+		if (ret == 0) {
+			dev_info(&pdev->dev, "%s hcp id:%d ack time out !\n",
+				__func__, id);
+			/*
+			 * clear un-success event to prevent unexpected flow
+			 * cauesd be remaining data
+			 */
+			return -EIO;
+		} else if (-ERESTARTSYS == ret) {
+			dev_info(&pdev->dev, "%s hcp id:%d ack wait interrupted !\n",
+				__func__, id);
+			return -ERESTARTSYS;
+		} else {
+			return 0;
+		}
+	}
+	return 0;
+}
+
+struct task_struct *mtk_hcp_get_current_task(struct platform_device *pdev)
+{
+	struct mtk_hcp *hcp_dev = platform_get_drvdata(pdev);
+
+	return hcp_dev->current_task;
+}
+EXPORT_SYMBOL(mtk_hcp_get_current_task);
+
+int mtk_hcp_send(struct platform_device *pdev,
+		 enum hcp_id id, void *buf,
+		 unsigned int len, int req_fd)
+{
+	return hcp_send_internal(pdev, id, buf, len, req_fd, SYNC_SEND);
+}
+EXPORT_SYMBOL(mtk_hcp_send);
+
+int mtk_hcp_send_async(struct platform_device *pdev,
+		 enum hcp_id id, void *buf,
+		 unsigned int len, int req_fd)
+{
+	return hcp_send_internal(pdev, id, buf, len, req_fd, ASYNC_SEND);
+}
+EXPORT_SYMBOL(mtk_hcp_send_async);
+
+#ifdef SUPPORT_APU
+int mtk_hcp_set_apu_dc(struct platform_device *pdev,
+	int32_t value, size_t size)
+{
+	struct mtk_hcp *hcp_dev = platform_get_drvdata(pdev);
+
+	struct slbc_data slb;
+	struct ctrl_data ctrl;
+	int ret;
+
+	if (value) {
+		if (atomic_inc_return(&(hcp_dev->have_slb)) == 1) {
+			slb.uid = UID_SH_P2;
+			slb.type = TP_BUFFER;
+			ret = slbc_request(&slb);
+			if (ret < 0) {
+				dev_info(hcp_dev->dev, "%s: Failed to allocate SLB buffer",
+					__func__);
+				return -1;
+			}
+
+			dev_info(hcp_dev->dev, "%s: SLB buffer base(0x%x), size(%ld): %x",
+				__func__, (uintptr_t)slb.paddr, slb.size);
+
+			ctrl.id    = CTRL_ID_SLB_BASE;
+			ctrl.value = ((slb.size << 32) |
+				((uintptr_t)slb.paddr & 0x0FFFFFFFFULL));
+
+			return hcp_send_internal(pdev,
+				HCP_IMGSYS_SET_CONTROL_ID, &ctrl, sizeof(ctrl), 0, 0);
+		}
+	} else {
+		if (atomic_dec_return(&(hcp_dev->have_slb)) == 0) {
+			slb.uid  = UID_SH_P2;
+			slb.type = TP_BUFFER;
+			ret = slbc_release(&slb);
+			if (ret < 0) {
+				dev_info(hcp_dev->dev, "Failed to release SLB buffer");
+				return -1;
+			}
+
+			ctrl.id    = CTRL_ID_SLB_BASE;
+			ctrl.value = 0;
+
+			return hcp_send_internal(pdev,
+				HCP_IMGSYS_SET_CONTROL_ID, &ctrl, sizeof(ctrl), 0, 0);
+		}
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(mtk_hcp_set_apu_dc);
+#endif
+
+struct platform_device *mtk_hcp_get_plat_device(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct device_node *hcp_node;
+	struct platform_device *hcp_pdev;
+
+	dev_dbg(&pdev->dev, "- E. hcp get platform device.\n");
+
+	hcp_node = of_parse_phandle(dev->of_node, "mediatek,hcp", 0);
+	if (hcp_node == NULL) {
+		dev_info(&pdev->dev, "%s can't get hcp node.\n", __func__);
+		return NULL;
+	}
+
+	hcp_pdev = of_find_device_by_node(hcp_node);
+	if (WARN_ON(hcp_pdev == NULL) == true) {
+		dev_info(&pdev->dev, "%s hcp pdev failed.\n", __func__);
+		of_node_put(hcp_node);
+		return NULL;
+	}
+
+	return hcp_pdev;
+}
+EXPORT_SYMBOL(mtk_hcp_get_plat_device);
+
+#if HCP_RESERVED_MEM
+phys_addr_t mtk_hcp_mem_base_phys;
+phys_addr_t mtk_hcp_mem_base_virt;
+phys_addr_t mtk_hcp_mem_size;
+
+/*static */struct mtk_hcp_reserve_mblock mtk_hcp_reserve_mblock[] = {
+	/* NEED_LEGACY_MEM not defined */
+	#ifdef NEED_LEGACY_MEM
+	{
+		.num = ISP_MEM_ID,
+		.start_phys = 0x0,
+		.start_virt = 0x0,
+		.start_dma  = 0x0,
+		.size = 0x200000,  /*need 20MB*/
+		.is_dma_buf = true,
+		.mmap_cnt = 0,
+		.mem_priv = NULL,
+		.d_buf = NULL,
+		.fd = -1,
+		.pIonHandle = NULL,
+		.attach = NULL,
+		.sgt = NULL
+	},
+	{
+		.num = DIP_MEM_FOR_HW_ID,
+		.start_phys = 0x0,
+		.start_virt = 0x0,
+		.start_dma  = 0x0,
+		.size = 0x400000,   /*need more than 4MB*/
+		.is_dma_buf = true,
+		.mmap_cnt = 0,
+		.mem_priv = NULL,
+		.d_buf = NULL,
+		.fd = -1,
+		.pIonHandle = NULL,
+		.attach = NULL,
+		.sgt = NULL
+	},
+	{
+		.num = DIP_MEM_FOR_SW_ID,
+		.start_phys = 0x0,
+		.start_virt = 0x0,
+		.start_dma  = 0x0,
+		.size = 0x100000,   /*1MB*/
+		.is_dma_buf = false, /* Kurt ToDo: shall be false */
+		.mmap_cnt = 0,
+		.mem_priv = NULL,
+		.d_buf = NULL,
+		.fd = -1,
+		.pIonHandle = NULL,
+		.attach = NULL,
+		.sgt = NULL
+	},
+	{
+		.num = MDP_MEM_ID,
+		.start_phys = 0x0,
+		.start_virt = 0x0,
+		.start_dma  = 0x0,
+		.size = 0x400000,   /*4MB*/
+		.is_dma_buf = true,
+		.mmap_cnt = 0,
+		.mem_priv = NULL,
+		.d_buf = NULL,
+		.fd = -1,
+		.pIonHandle = NULL,
+		.attach = NULL,
+		.sgt = NULL
+	},
+	{
+		.num = FD_MEM_ID,
+		.start_phys = 0x0,
+		.start_virt = 0x0,
+		.start_dma  = 0x0,
+		.size = 0x100000,   /*1MB*/
+		.is_dma_buf = true,
+		.mmap_cnt = 0,
+		.mem_priv = NULL,
+		.d_buf = NULL,
+		.fd = -1,
+		.pIonHandle = NULL,
+		.attach = NULL,
+		.sgt = NULL
+
+	},
+	#else
+	{
+		/*share buffer for frame setting, to be sw usage*/
+		.num = IMG_MEM_FOR_HW_ID,
+		.start_phys = 0x0,
+		.start_virt = 0x0,
+		.start_dma  = 0x0,
+		.size = 0x400000,   /*need more than 4MB*/
+		.is_dma_buf = true,
+		.mmap_cnt = 0,
+		.mem_priv = NULL,
+		.d_buf = NULL,
+		.fd = -1,
+		.pIonHandle = NULL,
+		.attach = NULL,
+		.sgt = NULL
+	},
+	#endif
+	{
+		.num = WPE_MEM_C_ID,
+		.start_phys = 0x0,
+		.start_virt = 0x0,
+		.start_dma  = 0x0,
+		.size = 0x100000,   /*1MB*/
+		.is_dma_buf = true,
+		.mmap_cnt = 0,
+		.mem_priv = NULL,
+		.d_buf = NULL,
+		.fd = -1,
+		.pIonHandle = NULL,
+		.attach = NULL,
+		.sgt = NULL
+	},
+	{
+		.num = WPE_MEM_T_ID,
+		.start_phys = 0x0,
+		.start_virt = 0x0,
+		.start_dma  = 0x0,
+		.size = 0x100000,   /*1MB*/
+		.is_dma_buf = true,
+		.mmap_cnt = 0,
+		.mem_priv = NULL,
+		.d_buf = NULL,
+		.fd = -1,
+		.pIonHandle = NULL,
+		.attach = NULL,
+		.sgt = NULL
+	},
+	{
+		.num = TRAW_MEM_C_ID,
+		.start_phys = 0x0,
+		.start_virt = 0x0,
+		.start_dma  = 0x0,
+		.size = 0x400000,   /*4MB*/
+		.is_dma_buf = true,
+		.mmap_cnt = 0,
+		.mem_priv = NULL,
+		.d_buf = NULL,
+		.fd = -1,
+		.pIonHandle = NULL,
+		.attach = NULL,
+		.sgt = NULL
+	},
+	{
+		.num = TRAW_MEM_T_ID,
+		.start_phys = 0x0,
+		.start_virt = 0x0,
+		.start_dma  = 0x0,
+		.size = 0x1400000,   /*20MB*/
+		.is_dma_buf = true,
+		.mmap_cnt = 0,
+		.mem_priv = NULL,
+		.d_buf = NULL,
+		.fd = -1,
+		.pIonHandle = NULL,
+		.attach = NULL,
+		.sgt = NULL
+	},
+	{
+		.num = DIP_MEM_C_ID,
+		.start_phys = 0x0,
+		.start_virt = 0x0,
+		.start_dma  = 0x0,
+		.size = 0x1700000,   /*23MB*/
+		.is_dma_buf = true,
+		.mmap_cnt = 0,
+		.mem_priv = NULL,
+		.d_buf = NULL,
+		.fd = -1,
+		.pIonHandle = NULL,
+		.attach = NULL,
+		.sgt = NULL
+	},
+	{
+		.num = DIP_MEM_T_ID,
+		.start_phys = 0x0,
+		.start_virt = 0x0,
+		.start_dma  = 0x0,
+		.size = 0x1D00000,   /*29MB*/
+		.is_dma_buf = true,
+		.mmap_cnt = 0,
+		.mem_priv = NULL,
+		.d_buf = NULL,
+		.fd = -1,
+		.pIonHandle = NULL,
+		.attach = NULL,
+		.sgt = NULL
+	},
+	{
+		.num = PQDIP_MEM_C_ID,
+		.start_phys = 0x0,
+		.start_virt = 0x0,
+		.start_dma  = 0x0,
+		.size = 0x300000,   /*3MB*/
+		.is_dma_buf = true,
+		.mmap_cnt = 0,
+		.mem_priv = NULL,
+		.d_buf = NULL,
+		.fd = -1,
+		.pIonHandle = NULL,
+		.attach = NULL,
+		.sgt = NULL
+	},
+	{
+		.num = PQDIP_MEM_T_ID,
+		.start_phys = 0x0,
+		.start_virt = 0x0,
+		.start_dma  = 0x0,
+		.size = 0x200000,   /*2MB*/
+		.is_dma_buf = true,
+		.mmap_cnt = 0,
+		.mem_priv = NULL,
+		.d_buf = NULL,
+		.fd = -1,
+		.pIonHandle = NULL,
+		.attach = NULL,
+		.sgt = NULL
+	},
+#if defined(IMGSYS_VER_ISP71)
+	{
+		.num = ADL_MEM_C_ID,
+		.start_phys = 0x0,
+		.start_virt = 0x0,
+		.start_dma  = 0x0,
+		.size = 0x100000,   /*1MB*/
+		.is_dma_buf = true,
+		.mmap_cnt = 0,
+		.mem_priv = NULL,
+		.d_buf = NULL,
+		.fd = -1,
+		.pIonHandle = NULL
+	},
+	{
+		.num = ADL_MEM_T_ID,
+		.start_phys = 0x0,
+		.start_virt = 0x0,
+		.start_dma  = 0x0,
+		.size = 0x100000,   /*1MB*/
+		.is_dma_buf = true,
+		.mmap_cnt = 0,
+		.mem_priv = NULL,
+		.d_buf = NULL,
+		.fd = -1,
+		.pIonHandle = NULL
+	},
+#endif
+	{
+		.num = IMG_MEM_G_ID,
+		.start_phys = 0x0,
+		.start_virt = 0x0,
+		.start_dma  = 0x0,
+		.size = 0x1188000,   /*15MB GCE + 2MB TPIPE + 30KB BW*/
+		.is_dma_buf = true,
+		.mmap_cnt = 0,
+		.mem_priv = NULL,
+		.d_buf = NULL,
+		.fd = -1,
+		.pIonHandle = NULL,
+		.attach = NULL,
+		.sgt = NULL
+	},
+};
+
+#ifdef NEED_LEGACY_MEM
+int mtk_hcp_reserve_mem_of_init(struct reserved_mem *rmem)
+{
+	unsigned int id;
+	phys_addr_t accumlate_memory_size = 0;
+
+	mtk_hcp_mem_base_phys = (phys_addr_t) rmem->base;
+	mtk_hcp_mem_size = (phys_addr_t) rmem->size;
+
+	pr_debug("[HCP] phys:0x%llx - 0x%llx (0x%llx)\n",
+			(phys_addr_t)rmem->base,
+			(phys_addr_t)rmem->base + (phys_addr_t)rmem->size,
+						(phys_addr_t)rmem->size);
+	accumlate_memory_size = 0;
+	for (id = 0; id < NUMS_MEM_ID; id++) {
+		mtk_hcp_reserve_mblock[id].start_phys =
+			mtk_hcp_mem_base_phys + accumlate_memory_size;
+		accumlate_memory_size += mtk_hcp_reserve_mblock[id].size;
+		pr_debug(
+		"[HCP][reserve_mem:%d]: phys:0x%llx - 0x%llx (0x%llx)\n", id,
+			mtk_hcp_reserve_mblock[id].start_phys,
+			mtk_hcp_reserve_mblock[id].start_phys +
+			mtk_hcp_reserve_mblock[id].size,
+			mtk_hcp_reserve_mblock[id].size);
+	}
+	return 0;
+}
+RESERVEDMEM_OF_DECLARE(mtk_hcp_reserve_mem_init, MTK_HCP_MEM_RESERVED_KEY,
+						mtk_hcp_reserve_mem_of_init);
+
+
+static int mtk_hcp_reserve_memory_ioremap(void)
+{
+	unsigned int id;
+	phys_addr_t accumlate_memory_size;
+
+	accumlate_memory_size = 0;
+
+	mtk_hcp_mem_base_virt =
+			(phys_addr_t)(size_t)ioremap_wc(mtk_hcp_mem_base_phys,
+							mtk_hcp_mem_size);
+	pr_debug("[HCP]reserve mem: virt:0x%llx - 0x%llx (0x%llx)\n",
+		(phys_addr_t)mtk_hcp_mem_base_virt,
+		(phys_addr_t)mtk_hcp_mem_base_virt +
+						(phys_addr_t)mtk_hcp_mem_size,
+		mtk_hcp_mem_size);
+	for (id = 0; id < NUMS_MEM_ID; id++) {
+		mtk_hcp_reserve_mblock[id].start_virt =
+			mtk_hcp_mem_base_virt + accumlate_memory_size;
+		accumlate_memory_size += mtk_hcp_reserve_mblock[id].size;
+	}
+	/* the reserved memory should be larger then expected memory
+	 * or vpu_reserve_mblock does not match dts
+	 */
+	WARN_ON(accumlate_memory_size > mtk_hcp_mem_size);
+#ifdef DEBUG
+	for (id = 0; id < NUMS_MEM_ID; id++) {
+		pr_info("[HCP][mem_reserve-%d] phys:0x%llx,virt:0x%llx,size:0x%llx\n",
+			id, mtk_hcp_get_reserve_mem_phys(id),
+			mtk_hcp_get_reserve_mem_virt(id),
+			mtk_hcp_get_reserve_mem_size(id));
+	}
+#endif
+	return 0;
+}
+#endif
+
+phys_addr_t mtk_hcp_get_reserve_mem_phys(unsigned int id)
+{
+	if ((id < 0) || (id >= NUMS_MEM_ID)) {
+		pr_info("[HCP] no reserve memory for %d", id);
+		return 0;
+	} else {
+		return mtk_hcp_reserve_mblock[id].start_phys;
+	}
+}
+EXPORT_SYMBOL(mtk_hcp_get_reserve_mem_phys);
+
+void mtk_hcp_set_reserve_mem_virt(unsigned int id,
+	void *virmem)
+{
+	if ((id < 0) || (id >= NUMS_MEM_ID))
+		pr_info("[HCP] no reserve memory for %d in set_reserve_mem_virt", id);
+	else
+		mtk_hcp_reserve_mblock[id].start_virt = virmem;
+}
+EXPORT_SYMBOL(mtk_hcp_set_reserve_mem_virt);
+
+void *mtk_hcp_get_reserve_mem_virt(unsigned int id)
+{
+	if ((id < 0) || (id >= NUMS_MEM_ID)) {
+		pr_info("[HCP] no reserve memory for %d", id);
+		return 0;
+	} else
+		return mtk_hcp_reserve_mblock[id].start_virt;
+}
+EXPORT_SYMBOL(mtk_hcp_get_reserve_mem_virt);
+
+phys_addr_t mtk_hcp_get_reserve_mem_dma(unsigned int id)
+{
+	if ((id < 0) || (id >= NUMS_MEM_ID)) {
+		pr_info("[HCP] no reserve memory for %d", id);
+		return 0;
+	} else {
+		return mtk_hcp_reserve_mblock[id].start_dma;
+	}
+}
+EXPORT_SYMBOL(mtk_hcp_get_reserve_mem_dma);
+
+phys_addr_t mtk_hcp_get_reserve_mem_size(unsigned int id)
+{
+	if ((id < 0) || (id >= NUMS_MEM_ID)) {
+		pr_info("[HCP] no reserve memory for %d", id);
+		return 0;
+	} else {
+		return mtk_hcp_reserve_mblock[id].size;
+	}
+}
+EXPORT_SYMBOL(mtk_hcp_get_reserve_mem_size);
+
+void mtk_hcp_set_reserve_mem_fd(unsigned int id, uint32_t fd)
+{
+	if ((id < 0) || (id >= NUMS_MEM_ID))
+		pr_info("[HCP] no reserve memory for %d", id);
+	else
+		mtk_hcp_reserve_mblock[id].fd = fd;
+}
+EXPORT_SYMBOL(mtk_hcp_set_reserve_mem_fd);
+
+uint32_t mtk_hcp_get_reserve_mem_fd(unsigned int id)
+{
+	if ((id < 0) || (id >= NUMS_MEM_ID)) {
+		pr_info("[HCP] no reserve memory for %d", id);
+		return 0;
+	} else
+		return mtk_hcp_reserve_mblock[id].fd;
+}
+EXPORT_SYMBOL(mtk_hcp_get_reserve_mem_fd);
+
+void *mtk_hcp_get_gce_mem_virt(struct platform_device *pdev)
+{
+	struct mtk_hcp *hcp_dev = platform_get_drvdata(pdev);
+	void *buffer;
+
+	if (!hcp_dev->data->get_gce_virt) {
+		dev_info(&pdev->dev, "%s: not supported\n", __func__);
+		return NULL;
+	}
+
+	buffer = hcp_dev->data->get_gce_virt();
+	if (!buffer)
+		dev_info(&pdev->dev, "%s: gce buffer is null\n", __func__);
+
+	return buffer;
+}
+EXPORT_SYMBOL(mtk_hcp_get_gce_mem_virt);
+
+phys_addr_t mtk_hcp_get_gce_mem_size(struct platform_device *pdev)
+{
+	struct mtk_hcp *hcp_dev = platform_get_drvdata(pdev);
+	phys_addr_t mem_sz;
+
+	if (!hcp_dev->data->get_gce_mem_size) {
+		dev_info(&pdev->dev, "%s: not supported\n", __func__);
+		return 0;
+	}
+
+	mem_sz = hcp_dev->data->get_gce_mem_size();
+
+	return mem_sz;
+}
+EXPORT_SYMBOL(mtk_hcp_get_gce_mem_size);
+
+int mtk_hcp_get_gce_buffer(struct platform_device *pdev)
+{
+	struct mtk_hcp *hcp_dev = platform_get_drvdata(pdev);
+
+	if (!hcp_dev->data->get_gce) {
+		dev_info(&pdev->dev, "%s:not supported\n", __func__);
+		return -1;
+	}
+
+	return hcp_dev->data->get_gce();
+}
+EXPORT_SYMBOL(mtk_hcp_get_gce_buffer);
+
+int mtk_hcp_put_gce_buffer(struct platform_device *pdev)
+{
+	struct mtk_hcp *hcp_dev = platform_get_drvdata(pdev);
+
+	if (!hcp_dev->data->put_gce) {
+		dev_info(&pdev->dev, "%s:not supported\n", __func__);
+		return -1;
+	}
+
+	return hcp_dev->data->put_gce();
+}
+EXPORT_SYMBOL(mtk_hcp_put_gce_buffer);
+
+void *mtk_hcp_get_hwid_mem_virt(struct platform_device *pdev)
+{
+	struct mtk_hcp *hcp_dev = platform_get_drvdata(pdev);
+
+	if (!hcp_dev->data->get_hwid_virt) {
+		dev_info(&pdev->dev, "%s:not supported\n", __func__);
+		return NULL;
+	}
+
+	return hcp_dev->data->get_hwid_virt();
+}
+EXPORT_SYMBOL(mtk_hcp_get_hwid_mem_virt);
+
+#endif
+
+static int mtk_hcp_open(struct inode *inode, struct file *file)
+{
+	struct mtk_hcp *hcp_dev;
+
+	hcp_dev = container_of(inode->i_cdev, struct mtk_hcp, hcp_cdev);
+	dev_dbg(hcp_dev->dev, "open inode->i_cdev = 0x%p\n", inode->i_cdev);
+
+	/*  */
+	file->private_data = hcp_dev;
+
+	hcp_dev->is_open = true;
+	cm4_support_table_init(hcp_dev);
+
+	hcp_dev->current_task = current;
+
+	dev_dbg(hcp_dev->dev, "- X. hcp open.\n");
+
+	return 0;
+}
+
+static unsigned int mtk_hcp_poll(struct file *file, poll_table *wait)
+{
+	struct mtk_hcp *hcp_dev = (struct mtk_hcp *)file->private_data;
+
+	// dev_info(hcp_dev->dev, "%s: poll start+", __func__);
+	if (chan_pool_available(hcp_dev, MODULE_IMG)) {
+		// dev_info(hcp_dev->dev, "%s: poll start-: %d", __func__, POLLIN);
+		return POLLIN;
+	}
+
+	poll_wait(file, &hcp_dev->poll_wq[MODULE_IMG], wait);
+	if (chan_pool_available(hcp_dev, MODULE_IMG)) {
+		// dev_info(hcp_dev->dev, "%s: poll start-: %d", __func__, POLLIN);
+		return POLLIN;
+	}
+
+	// dev_info(hcp_dev->dev, "%s: poll start-: 0", __func__);
+	return 0;
+}
+
+static int mtk_hcp_release(struct inode *inode, struct file *file)
+{
+	struct mtk_hcp *hcp_dev = (struct mtk_hcp *)file->private_data;
+#ifdef SUPPORT_APU
+	struct slbc_data slb;
+	int ret;
+#endif
+
+	dev_dbg(hcp_dev->dev, "- E. hcp release.\n");
+
+	hcp_dev->is_open = false;
+
+#ifdef SUPPORT_APU
+	if (atomic_read(&(hcp_dev->have_slb)) > 0) {
+		slb.uid  = UID_SH_P2;
+		slb.type = TP_BUFFER;
+		ret = slbc_release(&slb);
+		if (ret < 0) {
+			dev_info(hcp_dev->dev, "Failed to release SLB buffer");
+			return -1;
+		}
+	}
+#endif
+
+	kfree(hcp_dev->extmem.d_va);
+	return 0;
+}
+
+static int mtk_hcp_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	struct mtk_hcp *hcp_dev = (struct mtk_hcp *)file->private_data;
+	int reserved_memory_id = -1;
+	long length = 0;
+	unsigned long pfn = 0x0;
+	int mem_id = 0;
+
+	/* dealing with register remap */
+	length = vma->vm_end - vma->vm_start;
+	dev_info(hcp_dev->dev,
+		"start:0x%lx end:0x%lx offset:0x%lx, legth:0x%lx",
+		vma->vm_start, vma->vm_end, vma->vm_pgoff, length);
+	/*  */
+	pfn = vma->vm_pgoff << PAGE_SHIFT;
+	switch (pfn) {
+#if HCP_RESERVED_MEM
+	#ifdef NEED_LEGACY_MEM
+	case START_ISP_MEM_ADDR:
+		reserved_memory_id = ISP_MEM_ID;
+		break;
+	case START_MDP_MEM_ADDR:
+		reserved_memory_id = MDP_MEM_ID;
+		break;
+	case START_FD_MEM_ADDR:
+		reserved_memory_id = FD_MEM_ID;
+		break;
+	#endif
+	default:
+		for (mem_id = 0; mem_id < NUMS_MEM_ID; mem_id++) {
+			if (pfn == mtk_hcp_reserve_mblock[mem_id].start_phys) {
+				reserved_memory_id = mem_id;
+				break;
+			}
+		}
+		break;
+#endif
+	}
+
+	if (reserved_memory_id < 0 || reserved_memory_id >= NUMS_MEM_ID) {
+		dev_info(hcp_dev->dev, " %s invalid reserved memory id %d", __func__,
+			reserved_memory_id);
+		return -EPERM;
+	}
+
+	if ((length <= 0) || (length != (long)mtk_hcp_reserve_mblock[reserved_memory_id].size)) {
+		dev_info(hcp_dev->dev,
+				" %s size is not allowed: id:%d, pfn:0x%lx, length: 0x%lx != 0x%llx\n",
+				__func__, reserved_memory_id, pfn, length,
+				mtk_hcp_reserve_mblock[reserved_memory_id].size);
+		return -EPERM;
+	}
+
+	if (pfn) {
+		mtk_hcp_reserve_mblock[reserved_memory_id].mmap_cnt += 1;
+		dev_info(hcp_dev->dev, "reserved_memory_id:%d, pfn:0x%lx, mmap_cnt:%d\n",
+			reserved_memory_id, pfn,
+			mtk_hcp_reserve_mblock[reserved_memory_id].mmap_cnt);
+
+		if (reserved_memory_id != -1) {
+			vma->vm_pgoff = (unsigned long)
+	(mtk_hcp_reserve_mblock[reserved_memory_id].start_phys >> PAGE_SHIFT);
+			vma->vm_page_prot =
+			pgprot_writecombine(vma->vm_page_prot);
+
+			switch (reserved_memory_id) {
+			case IMG_MEM_FOR_HW_ID:
+				vma->vm_pgoff = (unsigned long)
+	(mtk_hcp_reserve_mblock[reserved_memory_id].start_phys >> PAGE_SHIFT);
+				vma->vm_page_prot =
+						pgprot_writecombine(vma->vm_page_prot);
+				break;
+			case IMG_MEM_G_ID:
+			default:
+		hcp_dev->mem_ops->mmap(mtk_hcp_reserve_mblock[reserved_memory_id].mem_priv,
+					vma);
+			pr_info("%s: [HCP][%d] after mem_ops->mmap vb2_dc_buf refcount(%d)\n",
+			__func__, reserved_memory_id,
+	hcp_dev->mem_ops->num_users(mtk_hcp_reserve_mblock[reserved_memory_id].mem_priv));
+				goto dma_buf_out;
+			}
+		} else {
+			/*vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);*/
+			dev_info(hcp_dev->dev,
+				" %s ONLY SUPPORT MMAP FOR RESERVED MEM: id:%d, pfn:0x%lx !\n",
+				__func__, reserved_memory_id, pfn);
+			return -EPERM;
+		}
+		goto remap;
+	} else {
+		dev_info(hcp_dev->dev,
+				" %s wrong pfn: id:%d, pfn:0x%lx !\n",
+				__func__, reserved_memory_id, pfn);
+		return -EPERM;
+	}
+
+	/* dealing with share memory, not supported */
+	#ifdef EXTMEM_SUPPORT
+	hcp_dev->extmem.d_va = kmalloc(length, GFP_KERNEL);
+	if (hcp_dev->extmem.d_va == NULL) {
+		int ret;
+
+		ret = -ENOMEM;
+		dev_info(hcp_dev->dev, " %s Allocate share buffer fail !!!\n",
+								__func__);
+		return ret;
+	}
+
+	hcp_dev->extmem.d_pa = virt_to_phys(hcp_dev->extmem.d_va);
+	vma->vm_pgoff = (unsigned long) (hcp_dev->extmem.d_pa >> PAGE_SHIFT);
+	dev_info(hcp_dev->dev, "sharememory va:0x%p pa:0x%llx",
+		hcp_dev->extmem.d_va, hcp_dev->extmem.d_pa);
+		#endif
+remap:
+	dev_info(hcp_dev->dev, "remap info id(%d) start:0x%lx pgoff:0x%lx page_prot:0x%llx length:0x%lx",
+		reserved_memory_id, vma->vm_start, vma->vm_pgoff, vma->vm_page_prot.pgprot, length);
+	if (remap_pfn_range(vma, vma->vm_start, vma->vm_pgoff,
+		length, vma->vm_page_prot) != 0) {
+		dev_info(hcp_dev->dev, " %s remap_pfn_range fail !!!\n",
+								__func__);
+		return -EAGAIN;
+	}
+dma_buf_out:
+	return 0;
+}
+
+static void module_notify(struct mtk_hcp *hcp_dev,
+					struct share_buf *user_data_addr)
+{
+	if (!user_data_addr) {
+		dev_info(hcp_dev->dev, "%s invalid null share buffer", __func__);
+		return;
+	}
+
+	if ((user_data_addr->id < HCP_INIT_ID) || (user_data_addr->id >= HCP_MAX_ID)) {
+		dev_info(hcp_dev->dev, "%s invalid hcp id %d", __func__, user_data_addr->id);
+		return;
+	}
+
+	dev_dbg(hcp_dev->dev, " %s with message id:%d\n",
+				__func__, user_data_addr->id);
+	if (hcp_dev->hcp_desc_table[user_data_addr->id].handler) {
+		hcp_dev->hcp_desc_table[user_data_addr->id].handler(
+			user_data_addr->share_data,
+			user_data_addr->len,
+			hcp_dev->hcp_desc_table[user_data_addr->id].priv);
+	}
+}
+
+static void module_wake_up(struct mtk_hcp *hcp_dev,
+					struct share_buf *user_data_addr)
+{
+	int module_id;
+
+	if (!user_data_addr) {
+		dev_info(hcp_dev->dev, "%s invalid null share buffer", __func__);
+		return;
+	}
+
+	if ((user_data_addr->id < HCP_INIT_ID) || (user_data_addr->id >= HCP_MAX_ID)) {
+		dev_info(hcp_dev->dev, "%s invalid hcp id %d", __func__, user_data_addr->id);
+		return;
+	}
+
+	module_id = hcp_id_to_module_id(hcp_dev, user_data_addr->id);
+	if (module_id < MODULE_ISP || module_id >= MODULE_MAX_ID) {
+		dev_info(hcp_dev->dev, "%s invalid module id %d", __func__, module_id);
+		return;
+	}
+
+	dev_dbg(hcp_dev->dev, " %s\n", __func__);
+	atomic_set(&hcp_dev->hcp_id_ack[user_data_addr->id], 1);
+	wake_up(&hcp_dev->ack_wq[module_id]);
+}
+
+static long mtk_hcp_ioctl(struct file *file, unsigned int cmd,
+							unsigned long arg)
+{
+	long ret = -1;
+	//void *mem_priv;
+	struct mtk_hcp *hcp_dev = (struct mtk_hcp *)file->private_data;
+	struct share_buf buffer;
+	struct packet data;
+	int index;
+	struct msg *msg;
+	unsigned long flag;
+
+	switch (cmd) {
+	case HCP_GET_OBJECT:
+		// pr_info("[HCP] HCP_GET_OBJECT+");
+		ret = copy_from_user(&data, (void *)arg, sizeof(struct packet));
+		// pr_info("[HCP] send count %d", data.count);
+		for (index = 0; index < data.count; index++) {
+			ret = copy_from_user((void *)&buffer, (void *)data.buffer[index],
+				sizeof(struct share_buf));
+			if (buffer.info.cmd == HCP_COMPLETE) {
+				// pr_info("[HCP] HCP_COMPLETE+");
+				module_notify(hcp_dev, &buffer);
+				module_wake_up(hcp_dev, &buffer);
+				// pr_info("[HCP] HCP_COMPLETE-");
+			} else if (buffer.info.cmd == HCP_NOTIFY) {
+				// pr_info("[HCP] HCP_NOTIFY+");
+				module_notify(hcp_dev, &buffer);
+				// pr_info("[HCP] HCP_NOTIFY-");
+			} else {
+				pr_info("[HCP] Unknown commands %p, %d", data.buffer[index],
+					buffer.info.cmd);
+				return ret;
+			}
+		}
+
+		index = 0;
+		while (chan_pool_available(hcp_dev, MODULE_IMG)) {
+			if (index >= IPI_MAX_BUFFER_COUNT)
+				break;
+
+			msg = chan_pool_get(hcp_dev, MODULE_IMG);
+
+			// pr_info("[HCP] Copy to user+: %d", index);
+			ret = copy_to_user((void *)data.buffer[index++], &msg->user_obj,
+				(unsigned long)sizeof(struct share_buf));
+			// pr_info("[HCP] Copy to user-");
+
+			// dev_info(hcp_dev->dev, "copy req fd(%d), obj id(%d) to user",
+			//	req_fd, hcp_id);
+
+			spin_lock_irqsave(&hcp_dev->msglock, flag);
+			list_add_tail(&msg->entry, &hcp_dev->msg_list);
+			spin_unlock_irqrestore(&hcp_dev->msglock, flag);
+			wake_up(&hcp_dev->msg_wq);
+		}
+
+		put_user(index, (int32_t *)(arg + offsetof(struct packet, count)));
+		ret = chan_pool_available(hcp_dev, MODULE_IMG);
+		put_user(ret, (bool *)(arg + offsetof(struct packet, more)));
+		//ret = mtk_hcp_get_data(hcp_dev, arg);
+
+		ret = 0;
+		// pr_info("[HCP] HCP_GET_OBJECT-: %d", index);
+		break;
+	case HCP_COMPLETE:
+		pr_info("[HCP] HCP_COMPLETE+");
+		ret = copy_from_user(&buffer, (void *)arg, sizeof(struct share_buf));
+		module_notify(hcp_dev, &buffer);
+		module_wake_up(hcp_dev, &buffer);
+		pr_info("[HCP] HCP_COMPLETE-");
+		ret = 0;
+		break;
+	case HCP_NOTIFY:
+		pr_info("[HCP] HCP_NOTIFY+");
+		ret = copy_from_user(&buffer, (void *)arg, sizeof(struct share_buf));
+		module_notify(hcp_dev, &buffer);
+		pr_info("[HCP] HCP_NOTIFY-");
+		ret = 0;
+		break;
+	case HCP_WAKEUP:
+		//(void)copy_from_user(&buffer, (void*)arg, sizeof(struct share_buf));
+		//module_wake_up(hcp_dev, &buffer);
+		pr_info("[HCP] HCP_WAKEUP+");
+		wake_up(&hcp_dev->poll_wq[MODULE_IMG]);
+		pr_info("[HCP] HCP_WAKEUP-");
+		ret = 0;
+		break;
+	case HCP_TIMEOUT:
+		chans_pool_dump(hcp_dev);
+		ret = 0;
+		break;
+	default:
+		dev_info(hcp_dev->dev, "Invalid cmd_number 0x%x.\n", cmd);
+		break;
+	}
+
+	return ret;
+}
+
+#if IS_ENABLED(CONFIG_COMPAT)
+static long mtk_hcp_compat_ioctl(struct file *file, unsigned int cmd,
+							unsigned long arg)
+{
+	struct mtk_hcp *hcp_dev = (struct mtk_hcp *)file->private_data;
+	long ret = -1;
+	struct share_buf __user *share_data32;
+
+	struct share_buf buffer;
+	struct compat_packet data;
+	int index;
+	struct msg *msg;
+	unsigned long flag;
+
+	switch (cmd) {
+	case COMPAT_HCP_GET_OBJECT:
+		// pr_info("[HCP] HCP_GET_OBJECT+");
+		ret = copy_from_user(&data, (void *)arg, sizeof(struct compat_packet));
+		// pr_info("[HCP] send count %d", data.count);
+		for (index = 0; index < data.count; index++) {
+			ret = copy_from_user((void *)&buffer, (compat_ptr)(data.buffer[index]),
+				sizeof(struct share_buf));
+			if (buffer.info.cmd == HCP_COMPLETE) {
+				// pr_info("[HCP] HCP_COMPLETE+");
+				module_notify(hcp_dev, &buffer);
+				module_wake_up(hcp_dev, &buffer);
+				// pr_info("[HCP] HCP_COMPLETE-");
+			} else if (buffer.info.cmd == HCP_NOTIFY) {
+				// pr_info("[HCP] HCP_NOTIFY+");
+				module_notify(hcp_dev, &buffer);
+				// pr_info("[HCP] HCP_NOTIFY-");
+			} else {
+				pr_info("[HCP] Unknown compat cmd 0x%x, %d", data.buffer[index],
+					buffer.info.cmd);
+				return ret;
+			}
+		}
+
+		index = 0;
+		while (chan_pool_available(hcp_dev, MODULE_IMG)) {
+			if (index >= IPI_MAX_BUFFER_COUNT)
+				break;
+
+			msg = chan_pool_get(hcp_dev, MODULE_IMG);
+
+			// pr_info("[HCP] Copy to user+: %d", index);
+			ret = copy_to_user((compat_ptr)(data.buffer[index++]), &msg->user_obj,
+				(unsigned long)sizeof(struct share_buf));
+			// pr_info("[HCP] Copy to user-");
+
+			// dev_info(hcp_dev->dev, "copy seq (%d), obj id(%d) to user",
+			//	msg->user_obj.info.send.seq, data.buffer[index-1]->info.send.seq);
+
+			spin_lock_irqsave(&hcp_dev->msglock, flag);
+			list_add_tail(&msg->entry, &hcp_dev->msg_list);
+			spin_unlock_irqrestore(&hcp_dev->msglock, flag);
+			wake_up(&hcp_dev->msg_wq);
+		}
+
+		put_user(index, (int32_t *)(arg + offsetof(struct compat_packet, count)));
+		ret = chan_pool_available(hcp_dev, MODULE_IMG);
+		put_user(ret, (bool *)(arg + offsetof(struct compat_packet, more)));
+		//ret = mtk_hcp_get_data(hcp_dev, arg);
+
+		ret = 0;
+		// pr_info("[HCP] HCP_GET_OBJECT-: %d", index);
+		break;
+	case COMPAT_HCP_NOTIFY:
+	case COMPAT_HCP_COMPLETE:
+	case COMPAT_HCP_WAKEUP:
+		share_data32 = compat_ptr((uint32_t)arg);
+		ret = file->f_op->unlocked_ioctl(file,
+				cmd, (unsigned long)share_data32);
+		break;
+	default:
+		dev_info(hcp_dev->dev, "Invalid cmd_number 0x%x.\n", cmd);
+		break;
+	}
+	return ret;
+}
+#endif
+
+static const struct file_operations hcp_fops = {
+	.owner          = THIS_MODULE,
+	.unlocked_ioctl = mtk_hcp_ioctl,
+	.open           = mtk_hcp_open,
+	.poll           = mtk_hcp_poll,
+	.release        = mtk_hcp_release,
+	.mmap           = mtk_hcp_mmap,
+#if IS_ENABLED(CONFIG_COMPAT)
+	.compat_ioctl   = mtk_hcp_compat_ioctl,
+#endif
+};
+
+static phys_addr_t rmem_base_phys;
+static phys_addr_t rmem_size;
+
+
+static int hcp_reserve_mem_of_init(struct reserved_mem *rmem)
+{
+	rmem_base_phys = (phys_addr_t) rmem->base;
+	rmem_size = (phys_addr_t) rmem->size;
+	pr_info("%s: phys_addr is 0x%llx with size(0x%llx)",
+				__func__, rmem_base_phys, rmem_size);
+
+	return 0;
+}
+#define HCP_RESERVE_MEM_KEY "mediatek,imgsys-reserve-memory"
+RESERVEDMEM_OF_DECLARE(hcp_reserve_mem_init, HCP_RESERVE_MEM_KEY, hcp_reserve_mem_of_init);
+
+
+int allocate_working_buffer_helper(struct platform_device *pdev)
+{
+	unsigned int id;
+	struct mtk_hcp_reserve_mblock *mblock;
+	unsigned int block_num;
+	struct sg_table *sgt;
+	struct dma_buf_attachment *attach;
+	struct mtk_hcp *hcp_dev = platform_get_drvdata(pdev);
+	//struct dma_heap *pdma_heap;
+	int ret;
+
+	mblock = hcp_dev->data->mblock;
+	block_num = hcp_dev->data->block_num;
+
+	/* allocate reserved memory */
+	for (id = 0; id < block_num; id++) {
+		if (mblock[id].is_dma_buf) {
+			switch (id) {
+			case IMG_MEM_FOR_HW_ID:
+				/*allocated at probe via dts*/
+				break;
+			case IMG_MEM_G_ID:
+				/* all supported heap name you can find with cmd */
+				/* (ls /dev/dma_heap/) in shell */
+				//pdma_heap = dma_heap_find("system");
+				//if (!pdma_heap) {
+				//	pr_info("pdma_heap find fail\n");
+				//	return -1;
+				//}
+				//mblock[id].d_buf = dma_heap_buffer_alloc(
+					//pdma_heap,
+					//mblock[id].size, O_RDWR | O_CLOEXEC,
+					//DMA_HEAP_VALID_HEAP_FLAGS);
+				if (IS_ERR(mblock[id].d_buf)) {
+					pr_info("dma_heap_buffer_alloc fail :%ld\n",
+					PTR_ERR(mblock[id].d_buf));
+					return -1;
+				}
+				//mtk_dma_buf_set_name(mblock[id].d_buf, mblock[id].name);
+
+				mblock[id].attach = dma_buf_attach(
+				mblock[id].d_buf, hcp_dev->dev);
+				attach = mblock[id].attach;
+				if (IS_ERR(attach)) {
+					pr_info("dma_buf_attach fail :%ld\n",
+					PTR_ERR(attach));
+					return -1;
+				}
+
+				mblock[id].sgt = dma_buf_map_attachment(attach,
+				DMA_TO_DEVICE);
+				sgt = mblock[id].sgt;
+				if (IS_ERR(sgt)) {
+					dma_buf_detach(mblock[id].d_buf, attach);
+					pr_info("dma_buf_map_attachment fail sgt:%ld\n",
+					PTR_ERR(sgt));
+					return -1;
+				}
+				mblock[id].start_phys = sg_dma_address(sgt->sgl);
+				mblock[id].start_dma =
+				mblock[id].start_phys;
+				ret = dma_buf_vmap(mblock[id].d_buf, &(mblock[id].map));
+				if (ret) {
+					pr_info("sg_dma_address fail\n");
+					return -EFAULT;
+				}
+				mblock[id].start_virt = mblock[id].map.vaddr;
+				mblock[id].fd =
+				dma_buf_fd(mblock[id].d_buf,
+				O_RDWR | O_CLOEXEC);
+				dma_buf_get(mblock[id].fd);
+				break;
+			default:
+
+				/* all supported heap name you can find with cmd */
+				/* (ls /dev/dma_heap/) in shell */
+				//pdma_heap = dma_heap_find("system");
+				//if (!pdma_heap) {
+				//	pr_info("pdma_heap find fail\n");
+				//	return -1;
+				//}
+				//mblock[id].d_buf = dma_heap_buffer_alloc(
+					//pdma_heap,
+					//mblock[id].size, O_RDWR | O_CLOEXEC,
+					//DMA_HEAP_VALID_HEAP_FLAGS);
+				if (IS_ERR(mblock[id].d_buf)) {
+					pr_info("dma_heap_buffer_alloc fail :%ld\n",
+					PTR_ERR(mblock[id].d_buf));
+					return -1;
+				}
+				//mtk_dma_buf_set_name(mblock[id].d_buf, mblock[id].name);
+				mblock[id].attach = dma_buf_attach(
+				mblock[id].d_buf, hcp_dev->dev);
+				attach = mblock[id].attach;
+				if (IS_ERR(attach)) {
+					pr_info("dma_buf_attach fail :%ld\n",
+					PTR_ERR(attach));
+					return -1;
+				}
+
+				mblock[id].sgt = dma_buf_map_attachment(attach,
+				DMA_TO_DEVICE);
+				sgt = mblock[id].sgt;
+				if (IS_ERR(sgt)) {
+					dma_buf_detach(mblock[id].d_buf, attach);
+					pr_info("dma_buf_map_attachment fail sgt:%ld\n",
+					PTR_ERR(sgt));
+					return -1;
+				}
+				mblock[id].start_phys = sg_dma_address(sgt->sgl);
+				mblock[id].start_dma =
+				mblock[id].start_phys;
+				ret = dma_buf_vmap(mblock[id].d_buf, &(mblock[id].map));
+				if (ret) {
+					pr_info("sg_dma_address fail\n");
+					return -EFAULT;
+				}
+				mblock[id].start_virt = mblock[id].map.vaddr;
+				mblock[id].fd =
+				dma_buf_fd(mblock[id].d_buf,
+				O_RDWR | O_CLOEXEC);
+				dma_buf_get(mblock[id].fd);
+				break;
+			}
+		} else {
+			mblock[id].start_virt =
+				kzalloc(mblock[id].size,
+					GFP_KERNEL);
+			mblock[id].start_phys =
+				virt_to_phys(
+					mblock[id].start_virt);
+			mblock[id].start_dma = 0;
+		}
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(allocate_working_buffer_helper);
+
+int release_working_buffer_helper(struct platform_device *pdev)
+{
+	unsigned int id;
+	struct mtk_hcp_reserve_mblock *mblock;
+	unsigned int block_num;
+	struct mtk_hcp *hcp_dev = platform_get_drvdata(pdev);
+	#ifdef NEED_FORCE_MMAP_PAIR
+	int i = 0;
+	#endif
+
+	mblock = hcp_dev->data->mblock;
+	block_num = hcp_dev->data->block_num;
+
+	/* release reserved memory */
+	for (id = 0; id < block_num; id++) {
+		if (mblock[id].is_dma_buf) {
+			switch (id) {
+			case IMG_MEM_FOR_HW_ID:
+				/*allocated at probe via dts*/
+				break;
+			default:
+				/* free va */
+				dma_buf_vunmap(mblock[id].d_buf, &(mblock[id].map));
+				/* free iova */
+				dma_buf_unmap_attachment(mblock[id].attach,
+				mblock[id].sgt, DMA_TO_DEVICE);
+				dma_buf_detach(mblock[id].d_buf,
+				mblock[id].attach);
+				dma_buf_put(mblock[id].d_buf);
+				// close fd in user space driver, you can't close fd in kernel site
+				// dma_heap_buffer_free(mblock[id].d_buf);
+				//dma_buf_put(my_dma_buf);
+				//also can use this api, but not recommended
+				mblock[id].mem_priv = NULL;
+				mblock[id].mmap_cnt = 0;
+				mblock[id].start_dma = 0x0;
+				mblock[id].start_virt = 0x0;
+				mblock[id].start_phys = 0x0;
+				mblock[id].d_buf = NULL;
+				mblock[id].fd = -1;
+				mblock[id].pIonHandle = NULL;
+				mblock[id].attach = NULL;
+				mblock[id].sgt = NULL;
+				break;
+			}
+		} else {
+			kfree(mblock[id].start_virt);
+			mblock[id].start_virt = 0x0;
+			mblock[id].start_phys = 0x0;
+			mblock[id].start_dma = 0x0;
+			mblock[id].mmap_cnt = 0;
+		}
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(release_working_buffer_helper);
+
+int mtk_hcp_allocate_working_buffer(struct platform_device *pdev, unsigned int mode)
+{
+	struct mtk_hcp *hcp_dev = platform_get_drvdata(pdev);
+
+	if (!hcp_dev->data->allocate) {
+		dev_info(&pdev->dev, "%s:allocate not supported\n", __func__);
+		return allocate_working_buffer_helper(pdev);
+	}
+
+	return hcp_dev->data->allocate(hcp_dev, mode);
+}
+EXPORT_SYMBOL(mtk_hcp_allocate_working_buffer);
+
+int mtk_hcp_release_working_buffer(struct platform_device *pdev)
+{
+	struct mtk_hcp *hcp_dev = platform_get_drvdata(pdev);
+
+	if (!hcp_dev->data->release) {
+		dev_info(&pdev->dev, "%s:release not supported\n", __func__);
+		return release_working_buffer_helper(pdev);
+	}
+
+	return hcp_dev->data->release(hcp_dev);
+}
+EXPORT_SYMBOL(mtk_hcp_release_working_buffer);
+
+int mtk_hcp_get_init_info(struct platform_device *pdev,
+			struct img_init_info *info)
+{
+	struct mtk_hcp *hcp_dev = platform_get_drvdata(pdev);
+
+	if (!hcp_dev->data->get_init_info || !info) {
+		dev_info(&pdev->dev, "%s:not supported\n", __func__);
+		return -1;
+	}
+
+	return hcp_dev->data->get_init_info(info);
+}
+EXPORT_SYMBOL(mtk_hcp_get_init_info);
+
+void mtk_hcp_purge_msg(struct platform_device *pdev)
+{
+	struct mtk_hcp *hcp_dev = platform_get_drvdata(pdev);
+	unsigned long flag;
+	int i;
+	struct msg *msg, *tmp;
+
+	spin_lock_irqsave(&hcp_dev->msglock, flag);
+	for (i = 0; i < MODULE_MAX_ID; i++) {
+		list_for_each_entry_safe(msg, tmp,
+					&hcp_dev->chans[i], entry){
+			list_del(&msg->entry);
+			list_add_tail(&msg->entry, &hcp_dev->msg_list);
+		}
+	}
+	atomic_set(&hcp_dev->seq, 0);
+	spin_unlock_irqrestore(&hcp_dev->msglock, flag);
+}
+EXPORT_SYMBOL(mtk_hcp_purge_msg);
+
+static int mtk_hcp_probe(struct platform_device *pdev)
+{
+	struct mtk_hcp *hcp_dev;
+	struct msg *msgs;
+	int ret = 0;
+	int i = 0;
+
+	dev_info(&pdev->dev, "- E. hcp driver probe.\n");
+	hcp_dev = devm_kzalloc(&pdev->dev, sizeof(*hcp_dev), GFP_KERNEL);
+	if (hcp_dev == NULL)
+		return -ENOMEM;
+
+	hcp_mtkdev = hcp_dev;
+	hcp_dev->dev = &pdev->dev;
+	hcp_dev->mem_ops = &hcp_vb2_dma_contig_memops;
+
+	hcp_dev->data = of_device_get_match_data(&pdev->dev);
+
+	platform_set_drvdata(pdev, hcp_dev);
+	dev_set_drvdata(&pdev->dev, hcp_dev);
+
+	if (dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(34)))
+		dev_info(&pdev->dev, "%s:No DMA available\n", __func__);
+
+	if (!pdev->dev.dma_parms) {
+		pdev->dev.dma_parms =
+			devm_kzalloc(hcp_dev->dev, sizeof(*hcp_dev->dev->dma_parms), GFP_KERNEL);
+	}
+	if (hcp_dev->dev->dma_parms) {
+		ret = dma_set_max_seg_size(hcp_dev->dev, (unsigned int)DMA_BIT_MASK(34));
+		if (ret)
+			dev_info(hcp_dev->dev, "Failed to set DMA segment size\n");
+	}
+
+	atomic_set(&(hcp_dev->have_slb), 0);
+
+	hcp_dev->is_open = false;
+	for (i = 0; i < MODULE_MAX_ID; i++) {
+		init_waitqueue_head(&hcp_dev->ack_wq[i]);
+		init_waitqueue_head(&hcp_dev->poll_wq[i]);
+
+		INIT_LIST_HEAD(&hcp_dev->chans[i]);
+
+		switch (i) {
+		case MODULE_ISP:
+			hcp_dev->daemon_notify_wq[i] =
+				alloc_ordered_workqueue("%s",
+				__WQ_LEGACY | WQ_MEM_RECLAIM |
+				WQ_FREEZABLE,
+				"isp_daemon_notify_wq");
+			break;
+		case MODULE_IMG:
+			hcp_dev->daemon_notify_wq[i] =
+				alloc_ordered_workqueue("%s",
+				__WQ_LEGACY | WQ_MEM_RECLAIM |
+				WQ_FREEZABLE,
+				"imgsys_daemon_notify_wq");
+			break;
+		case MODULE_FD:
+			hcp_dev->daemon_notify_wq[i] =
+				alloc_ordered_workqueue("%s",
+				__WQ_LEGACY | WQ_MEM_RECLAIM |
+				WQ_FREEZABLE,
+				"fd_daemon_notify_wq");
+			break;
+		case MODULE_RSC:
+			hcp_dev->daemon_notify_wq[i] =
+				alloc_ordered_workqueue("%s",
+				__WQ_LEGACY | WQ_MEM_RECLAIM |
+				WQ_FREEZABLE,
+				"rsc_daemon_notify_wq");
+			break;
+		default:
+			hcp_dev->daemon_notify_wq[i] = NULL;
+			break;
+		}
+	}
+	spin_lock_init(&hcp_dev->msglock);
+	init_waitqueue_head(&hcp_dev->msg_wq);
+	INIT_LIST_HEAD(&hcp_dev->msg_list);
+	msgs = devm_kzalloc(hcp_dev->dev, sizeof(*msgs) * MSG_NR, GFP_KERNEL);
+	for (i = 0; i < MSG_NR; i++)
+		list_add_tail(&msgs[i].entry, &hcp_dev->msg_list);
+
+	/* init character device */
+
+	ret = alloc_chrdev_region(&hcp_dev->hcp_devno, 0, 1, HCP_DEVNAME);
+	if (ret < 0) {
+		dev_info(&pdev->dev, "alloc_chrdev_region failed err= %d", ret);
+		goto err_alloc;
+	}
+
+	cdev_init(&hcp_dev->hcp_cdev, &hcp_fops);
+	hcp_dev->hcp_cdev.owner = THIS_MODULE;
+
+	ret = cdev_add(&hcp_dev->hcp_cdev, hcp_dev->hcp_devno, 1);
+	if (ret < 0) {
+		dev_info(&pdev->dev, "cdev_add fail  err= %d", ret);
+		goto err_add;
+	}
+
+	hcp_dev->hcp_class = class_create(THIS_MODULE, "mtk_hcp_driver");
+	if (IS_ERR(hcp_dev->hcp_class) == true) {
+		ret = (int)PTR_ERR(hcp_dev->hcp_class);
+		dev_info(&pdev->dev, "class create fail  err= %d", ret);
+		goto err_add;
+	}
+
+	hcp_dev->hcp_device = device_create(hcp_dev->hcp_class, NULL,
+					hcp_dev->hcp_devno, NULL, HCP_DEVNAME);
+	if (IS_ERR(hcp_dev->hcp_device) == true) {
+		ret = (int)PTR_ERR(hcp_dev->hcp_device);
+		dev_info(&pdev->dev, "device create fail  err= %d", ret);
+		goto err_device;
+	}
+
+	dev_dbg(&pdev->dev, "- X. hcp driver probe success.\n");
+
+#if HCP_RESERVED_MEM
+	/* allocate reserved memory */
+	/* allocate shared memory about ipi_param at probe, allocate others at streamon */
+		/* update size to be the same with dts */
+	/* mtk_hcp_reserve_mblock[IMG_MEM_FOR_HW_ID].start_virt = */
+	/* ioremap_wc(rmem_base_phys, rmem_size); */
+	/* mtk_hcp_reserve_mblock[IMG_MEM_FOR_HW_ID].start_phys = */
+	/* (phys_addr_t)rmem_base_phys; */
+	/* mtk_hcp_reserve_mblock[IMG_MEM_FOR_HW_ID].start_dma = */
+	/* (phys_addr_t)rmem_base_phys; */
+	/* mtk_hcp_reserve_mblock[IMG_MEM_FOR_HW_ID].size = rmem_size; */
+
+	mtk_hcp_reserve_mblock[IMG_MEM_FOR_HW_ID].size = rmem_size;
+
+#endif
+	return 0;
+
+err_device:
+	class_destroy(hcp_dev->hcp_class);
+err_add:
+	cdev_del(&hcp_dev->hcp_cdev);
+err_alloc:
+	unregister_chrdev_region(hcp_dev->hcp_devno, 1);
+	for (i = 0; i < MODULE_MAX_ID; i++) {
+		if (hcp_dev->daemon_notify_wq[i]) {
+			destroy_workqueue(hcp_dev->daemon_notify_wq[i]);
+			hcp_dev->daemon_notify_wq[i] = NULL;
+		}
+	}
+
+	devm_kfree(&pdev->dev, hcp_dev);
+
+	dev_info(&pdev->dev, "- X. hcp driver probe fail.\n");
+
+	return ret;
+}
+
+static const struct of_device_id mtk_hcp_match[] = {
+#if defined(IMGSYS_VER_ISP71)
+	{.compatible = "mediatek,hcp", .data = (void *)&isp71_hcp_data}
+#elif defined(IMGSYS_VER_ISP70)
+	{.compatible = "mediatek,hcp", .data = (void *)&isp70_hcp_data}
+#endif
+};
+MODULE_DEVICE_TABLE(of, mtk_hcp_match);
+
+static int mtk_hcp_remove(struct platform_device *pdev)
+{
+
+	struct mtk_hcp *hcp_dev = platform_get_drvdata(pdev);
+	int i = 0;
+#if HCP_RESERVED_MEM
+	unsigned int id;
+#endif
+
+	dev_dbg(&pdev->dev, "- E. hcp driver remove.\n");
+
+#if HCP_RESERVED_MEM
+	//remove reserved memory
+	for (id = 0; id < NUMS_MEM_ID; id++) {
+		dma_free_coherent(hcp_dev->dev, mtk_hcp_reserve_mblock[id].size,
+			mtk_hcp_reserve_mblock[id].start_virt,
+			mtk_hcp_reserve_mblock[id].start_dma);
+	}
+#endif
+
+	for (i = 0; i < MODULE_MAX_ID; i++) {
+		if (hcp_dev->daemon_notify_wq[i]) {
+			flush_workqueue(hcp_dev->daemon_notify_wq[i]);
+			destroy_workqueue(hcp_dev->daemon_notify_wq[i]);
+			hcp_dev->daemon_notify_wq[i] = NULL;
+		}
+	}
+
+	if (hcp_dev->is_open == true) {
+		hcp_dev->is_open = false;
+		dev_dbg(&pdev->dev, "%s: opened device found\n", __func__);
+	}
+	devm_kfree(&pdev->dev, hcp_dev);
+
+	cdev_del(&hcp_dev->hcp_cdev);
+	unregister_chrdev_region(hcp_dev->hcp_devno, 1);
+
+	dev_dbg(&pdev->dev, "- X. hcp driver remove.\n");
+	return 0;
+}
+
+static struct platform_driver mtk_hcp_driver = {
+	.probe  = mtk_hcp_probe,
+	.remove = mtk_hcp_remove,
+	.driver = {
+		.name = HCP_DEVNAME,
+		.owner  = THIS_MODULE,
+		.of_match_table = mtk_hcp_match,
+	},
+};
+
+module_platform_driver(mtk_hcp_driver);
+
+MODULE_LICENSE("GPL v2");
+MODULE_DESCRIPTION("Mediatek hetero control process driver");
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/mtk-hcp/mtk-hcp.h b/drivers/media/platform/mediatek/isp/isp_7x/mtk-hcp/mtk-hcp.h
new file mode 100755
index 0000000000000000000000000000000000000000..95e98a727ef51c787dc76261796965b8bf69dda6
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/mtk-hcp/mtk-hcp.h
@@ -0,0 +1,394 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2021 MediaTek Inc.
+ */
+
+#ifndef MTK_HCP_H
+#define MTK_HCP_H
+
+#include <linux/fdtable.h>
+#include <linux/platform_device.h>
+
+#include <uapi/linux/dma-heap.h>
+#include <linux/dma-heap.h>
+#include <linux/dma-direction.h>
+#include <linux/scatterlist.h>
+#include <linux/dma-buf.h>
+#include "mtk-img-ipi.h"
+
+//#include "scp_ipi.h"
+
+/**
+ * HCP (Hetero Control Processor ) is a tiny processor controlling
+ * the methodology of register programming. If the module support
+ * to run on CM4 then it will send data to CM4 to program register.
+ * Or it will send the data to user library and let RED to program
+ * register.
+ *
+ **/
+
+typedef void (*hcp_handler_t) (void *data,
+						 unsigned int len,
+						 void *priv);
+
+
+/**
+ * hcp ID definition
+ */
+enum hcp_id {
+	HCP_INIT_ID = 0,
+	HCP_ISP_CMD_ID,
+	HCP_ISP_FRAME_ID,
+	HCP_DIP_INIT_ID, //CHRISTBD
+	HCP_IMGSYS_INIT_ID = HCP_DIP_INIT_ID,
+	HCP_DIP_FRAME_ID,
+	HCP_IMGSYS_FRAME_ID = HCP_DIP_FRAME_ID,
+	HCP_DIP_HW_TIMEOUT_ID,
+	HCP_IMGSYS_HW_TIMEOUT_ID = HCP_DIP_HW_TIMEOUT_ID,
+	HCP_IMGSYS_SW_TIMEOUT_ID,
+	HCP_DIP_DEQUE_DUMP_ID,
+	HCP_IMGSYS_DEQUE_DONE_ID,
+	HCP_IMGSYS_DEINIT_ID,
+	HCP_IMGSYS_IOVA_FDS_ADD_ID,
+	HCP_IMGSYS_IOVA_FDS_DEL_ID,
+	HCP_IMGSYS_UVA_FDS_ADD_ID,
+	HCP_IMGSYS_UVA_FDS_DEL_ID,
+	HCP_IMGSYS_SET_CONTROL_ID,
+	HCP_IMGSYS_GET_CONTROL_ID,
+	HCP_IMGSYS_CLEAR_HWTOKEN_ID,
+	HCP_FD_CMD_ID,
+	HCP_FD_FRAME_ID,
+	HCP_RSC_INIT_ID,
+	HCP_RSC_FRAME_ID,
+	HCP_MAX_ID,
+};
+
+/**
+ * module ID definition
+ */
+enum module_id {
+	MODULE_ISP = 0,
+	MODULE_DIP,
+	MODULE_IMG = MODULE_DIP,
+	MODULE_FD,
+	MODULE_RSC,
+	MODULE_MAX_ID,
+};
+
+/**
+ * mtk_hcp_register - register an hcp function
+ *
+ * @pdev: HCP platform device
+ * @id: HCP ID
+ * @handler: HCP handler
+ * @name: HCP name
+ * @priv: private data for HCP handler
+ *
+ * Return: Return 0 if hcp registers successfully, otherwise it is failed.
+ */
+int mtk_hcp_register(struct platform_device *pdev, enum hcp_id id,
+				 hcp_handler_t handler, const char *name, void *priv);
+
+/**
+ * mtk_hcp_unregister - unregister an hcp function
+ *
+ * @pdev: HCP platform device
+ * @id: HCP ID
+ *
+ * Return: Return 0 if hcp unregisters successfully, otherwise it is failed.
+ */
+int mtk_hcp_unregister(struct platform_device *pdev, enum hcp_id id);
+
+/**
+ * mtk_hcp_send - send data from camera kernel driver to HCP and wait the
+ *      command send to demand.
+ *
+ * @pdev:   HCP platform device
+ * @id:     HCP ID
+ * @buf:    the data buffer
+ * @len:    the data buffer length
+ * @frame_no: frame number
+ *
+ * This function is thread-safe. When this function returns,
+ * HCP has received the data and save the data in the workqueue.
+ * After that it will schedule work to dequeue to send data to CM4 or
+ * RED for programming register.
+ * Return: Return 0 if sending data successfully, otherwise it is failed.
+ **/
+int mtk_hcp_send(struct platform_device *pdev,
+		enum hcp_id id, void *buf,
+		unsigned int len, int req_fd);
+
+/**
+ * mtk_hcp_send_async - send data from camera kernel driver to HCP without
+ *      waiting demand receives the command.
+ *
+ * @pdev:   HCP platform device
+ * @id:     HCP ID
+ * @buf:    the data buffer
+ * @len:    the data buffer length
+ * @frame_no: frame number
+ *
+ * This function is thread-safe. When this function returns,
+ * HCP has received the data and save the data in the workqueue.
+ * After that it will schedule work to dequeue to send data to CM4 or
+ * RED for programming register.
+ * Return: Return 0 if sending data successfully, otherwise it is failed.
+ **/
+int mtk_hcp_send_async(struct platform_device *pdev,
+		 enum hcp_id id, void *buf,
+		 unsigned int len, int frame_no);
+
+
+/**
+ * Callback from v4l2 layer to notify daemon apu dc status
+ */
+int mtk_hcp_set_apu_dc(struct platform_device *pdev,
+	int32_t value, size_t size);
+
+/**
+ * mtk_hcp_get_plat_device - get HCP's platform device
+ *
+ * @pdev: the platform device of the module requesting HCP platform
+ *    device for using HCP API.
+ *
+ * Return: Return NULL if it is failed.
+ * otherwise it is HCP's platform device
+ **/
+struct platform_device *mtk_hcp_get_plat_device(struct platform_device *pdev);
+
+/**
+ * mtk_hcp_get_current_task - get hcp driver's task struct.
+ *
+ * @pdev: HCP platform device
+ *
+ * This function returns the current task inside HCP platform device,
+ * which is initialized when hcp device being opened.
+ **/
+struct task_struct *mtk_hcp_get_current_task(struct platform_device *pdev);
+
+/**
+ * mtk_hcp_allocate_working_buffer - allocate driver working buffer.
+ *
+ * @pdev: HCP platform device
+ *
+ * This function allocate working buffers and store the information
+ * in mtk_hcp_reserve_mblock.
+ **/
+int mtk_hcp_allocate_working_buffer(struct platform_device *pdev, unsigned int mode);
+
+/**
+ * mtk_hcp_release_working_buffer - release driver working buffer.
+ *
+ * @pdev: HCP platform device
+ *
+ * This function release working buffers
+ **/
+int mtk_hcp_release_working_buffer(struct platform_device *pdev);
+
+void *mtk_hcp_get_gce_mem_virt(struct platform_device *pdev);
+void *mtk_hcp_get_hwid_mem_virt(struct platform_device *pdev);
+phys_addr_t mtk_hcp_get_gce_mem_size(struct platform_device *pdev);
+int mtk_hcp_get_init_info(struct platform_device *pdev, struct img_init_info *info);
+
+int mtk_hcp_get_gce_buffer(struct platform_device *pdev);
+int mtk_hcp_put_gce_buffer(struct platform_device *pdev);
+
+/**
+ * mtk_hcp_purge_msg - purge messages
+ *
+ * @pdev: HCP platform device
+ *
+ * This function purges messages
+ **/
+void mtk_hcp_purge_msg(struct platform_device *pdev);
+
+/**
+ * struct hcp_mem - HCP memory information
+ *
+ * @d_va:    the kernel virtual memory address of HCP extended data memory
+ * @d_pa:    the physical memory address of HCP extended data memory
+ * @d_len:   the length of extended data
+ */
+struct hcp_mem {
+	void *d_va;
+	dma_addr_t d_pa;
+	unsigned long d_len;
+};
+
+/**
+ * struct hcp_desc - hcp descriptor
+ *
+ * @handler:      IPI handler
+ * @name:         the name of IPI handler
+ * @priv:         the private data of IPI handler
+ */
+struct hcp_desc {
+	hcp_handler_t handler;
+	const char *name;
+	void *priv;
+};
+
+struct object_id {
+	union {
+		struct send {
+			uint32_t hcp: 5;
+			uint32_t ack: 1;
+			uint32_t req: 10;
+			uint32_t seq: 16;
+		} __packed send;
+
+		uint32_t cmd;
+	};
+} __packed;
+
+#define HCP_SHARE_BUF_SIZE      388
+/**
+ * struct share_buf - DTCM (Data Tightly-Coupled Memory) buffer shared with
+ *                    RED and HCP
+ *
+ * @id:             hcp id
+ * @len:            share buffer length
+ * @share_buf:      share buffer data
+ */
+struct share_buf {
+	uint32_t id;
+	uint32_t len;
+	uint8_t share_data[HCP_SHARE_BUF_SIZE];
+	struct object_id info;
+};
+
+
+/**
+ * struct mtk_hcp - hcp driver data
+ * @extmem:              hcp extended memory information
+ * @hcp_desc:            hcp descriptor
+ * @dev:                 hcp struct device
+ * @mem_ops:             memory operations
+ * @hcp_mutex:           protect mtk_hcp (except recv_buf) and ensure only
+ *                       one client to use hcp service at a time.
+ * @data_mutex:          protect shared buffer between kernel user send and
+ *                       user thread get&read/copy
+ * @file:                hcp daemon file pointer
+ * @is_open:             the flag to indicate if hcp device is open.
+ * @ack_wq:              the wait queue for each client. When sleeping
+ *                       processes wake up, they will check the condition
+ *                       "hcp_id_ack" to run the corresponding action or
+ *                       go back to sleep.
+ * @hcp_id_ack:          The ACKs for registered HCP function.
+ * @ipi_got:             The flags for IPI message polling from user.
+ * @ipi_done:            The flags for IPI message polling from user again,
+ *       which means the previous messages has been dispatched
+ *                       done in daemon.
+ * @user_obj:            Temporary share_buf used for hcp_msg_get.
+ * @hcp_devno:           The hcp_devno for hcp init hcp character device
+ * @hcp_cdev:            The point of hcp character device.
+ * @hcp_class:           The class_create for create hcp device
+ * @hcp_device:          hcp struct device
+ * @hcpname:             hcp struct device name in dtsi
+ * @ cm4_support_list    to indicate which module can run in cm4 or it will send
+ *                       to user space for running action.
+ * @ current_task        hcp current task struct
+ */
+struct mtk_hcp {
+	atomic_t have_slb;
+	struct hcp_mem extmem;
+	struct hcp_desc hcp_desc_table[HCP_MAX_ID];
+	struct device *dev;
+	const struct vb2_mem_ops *mem_ops;
+	const struct mtk_hcp_data *data;
+	/* for protecting vcu data structure */
+	struct file *file;
+	bool   is_open;
+	atomic_t seq;
+	wait_queue_head_t ack_wq[MODULE_MAX_ID];
+	atomic_t hcp_id_ack[HCP_MAX_ID];
+	wait_queue_head_t get_wq[MODULE_MAX_ID];
+	wait_queue_head_t poll_wq[MODULE_MAX_ID];
+	struct list_head chans[MODULE_MAX_ID];
+	struct list_head msg_list;
+	spinlock_t msglock;
+	wait_queue_head_t msg_wq;
+	dev_t hcp_devno;
+	struct cdev hcp_cdev;
+	struct class *hcp_class;
+	struct device *hcp_device;
+	const char *hcpname;
+	bool cm4_support_list[MODULE_MAX_ID];
+	struct task_struct *current_task;
+	struct workqueue_struct *daemon_notify_wq[MODULE_MAX_ID];
+};
+
+struct mtk_hcp_data {
+	struct mtk_hcp_reserve_mblock *mblock;
+	struct mtk_hcp_reserve_mblock *smblock;
+	unsigned int block_num;
+	int (*allocate)(struct mtk_hcp *hcp_dev, unsigned int smvr);
+	int (*release)(struct mtk_hcp *hcp_dev);
+	int (*get_init_info)(struct img_init_info *info);
+	void* (*get_gce_virt)(void);
+	int (*get_gce)(void);
+	int (*put_gce)(void);
+	void* (*get_hwid_virt)(void);
+	phys_addr_t (*get_gce_mem_size)(void);
+};
+
+#define HCP_RESERVED_MEM  (1)
+#define MTK_CM4_SUPPORT     (0)
+
+#if HCP_RESERVED_MEM
+/**
+ * struct mtk_hcp_reserve_mblock - info about memory buffer allocated in kernel
+ *
+ * @num:        vb2_dc_buf
+ * @start_phys:     starting addr(phy/iova) about allocated buffer
+ * @start_virt:     starting addr(kva) about allocated buffer
+ * @start_dma:      starting addr(iova) about allocated buffer
+ * @size:       allocated buffer size
+ * @is_dma_buf:     attribute: is_dma_buf or not
+ * @mmap_cnt:     counter about mmap times
+ * @mem_priv:     vb2_dc_buf
+ * @d_buf:        dma_buf
+ * @fd:         buffer fd
+ */
+struct mtk_hcp_reserve_mblock {
+	const char *name;
+	unsigned int num;
+	phys_addr_t start_phys;
+	void *start_virt;
+	phys_addr_t start_dma;
+	phys_addr_t size;
+	uint8_t is_dma_buf;
+	/*new add*/
+	int mmap_cnt;
+	void *mem_priv;
+	struct dma_buf *d_buf;
+	int fd;
+	struct ion_handle *pIonHandle;
+	struct dma_buf_attachment *attach;
+	struct sg_table *sgt;
+	struct kref kref;
+	struct iosys_map map;
+};
+
+int mtk_hcp_set_apu_dc(struct platform_device *pdev,
+	int32_t value, size_t size);
+
+
+extern phys_addr_t mtk_hcp_get_reserve_mem_phys(
+					unsigned int id);
+extern void *mtk_hcp_get_reserve_mem_virt(unsigned int id);
+extern void mtk_hcp_set_reserve_mem_virt(unsigned int id,
+	void *virmem);
+extern phys_addr_t mtk_hcp_get_reserve_mem_dma(
+					unsigned int id);
+extern phys_addr_t mtk_hcp_get_reserve_mem_size(
+					unsigned int id);
+extern uint32_t mtk_hcp_get_reserve_mem_fd(
+					unsigned int id);
+extern void mtk_hcp_set_reserve_mem_fd(unsigned int id,
+	uint32_t fd);
+#endif
+
+
+#endif /* _MTK_HCP_H */
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/mtk-hcp/mtk-hcp_isp70.c b/drivers/media/platform/mediatek/isp/isp_7x/mtk-hcp/mtk-hcp_isp70.c
new file mode 100644
index 0000000000000000000000000000000000000000..36283c721ebd7938526ba570aaec0a279ff1dbe0
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/mtk-hcp/mtk-hcp_isp70.c
@@ -0,0 +1,784 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2019 MediaTek Inc.
+ */
+#include <linux/slab.h>
+#include <linux/kref.h>
+//#include "mtk_heap.h"
+#include "mtk-hcp_isp70.h"
+
+static struct mtk_hcp_reserve_mblock *mb;
+
+static struct mtk_hcp_reserve_mblock isp70_smvr_mblock[] = {
+	{
+		/*share buffer for frame setting, to be sw usage*/
+		.name = "IMG_MEM_FOR_HW_ID",
+		.num = IMG_MEM_FOR_HW_ID,
+		.start_phys = 0x0,
+		.start_virt = 0x0,
+		.start_dma  = 0x0,
+		.size = 0x400000,   /*need more than 4MB*/
+		.is_dma_buf = true,
+		.mmap_cnt = 0,
+		.mem_priv = NULL,
+		.d_buf = NULL,
+		.fd = -1,
+		.pIonHandle = NULL,
+		.attach = NULL,
+		.sgt = NULL
+	},
+	{
+		.name = "WPE_MEM_C_ID",
+		.num = WPE_MEM_C_ID,
+		.start_phys = 0x0,
+		.start_virt = 0x0,
+		.start_dma  = 0x0,
+		.size = 0x300000,
+		.is_dma_buf = true,
+		.mmap_cnt = 0,
+		.mem_priv = NULL,
+		.d_buf = NULL,
+		.fd = -1,
+		.pIonHandle = NULL,
+		.attach = NULL,
+		.sgt = NULL
+	},
+	{
+		.name = "WPE_MEM_T_ID",
+		.num = WPE_MEM_T_ID,
+		.start_phys = 0x0,
+		.start_virt = 0x0,
+		.start_dma  = 0x0,
+		.size = 0x500000,
+		.is_dma_buf = true,
+		.mmap_cnt = 0,
+		.mem_priv = NULL,
+		.d_buf = NULL,
+		.fd = -1,
+		.pIonHandle = NULL,
+		.attach = NULL,
+		.sgt = NULL
+	},
+	{
+		.name = "TRAW_MEM_C_ID",
+		.num = TRAW_MEM_C_ID,
+		.start_phys = 0x0,
+		.start_virt = 0x0,
+		.start_dma  = 0x0,
+		.size = 0xB00000,
+		.is_dma_buf = true,
+		.mmap_cnt = 0,
+		.mem_priv = NULL,
+		.d_buf = NULL,
+		.fd = -1,
+		.pIonHandle = NULL,
+		.attach = NULL,
+		.sgt = NULL
+	},
+	{
+		.name = "TRAW_MEM_T_ID",
+		.num = TRAW_MEM_T_ID,
+		.start_phys = 0x0,
+		.start_virt = 0x0,
+		.start_dma  = 0x0,
+		.size = 0x3000000,
+		.is_dma_buf = true,
+		.mmap_cnt = 0,
+		.mem_priv = NULL,
+		.d_buf = NULL,
+		.fd = -1,
+		.pIonHandle = NULL,
+		.attach = NULL,
+		.sgt = NULL
+	},
+	{
+		.name = "DIP_MEM_C_ID",
+		.num = DIP_MEM_C_ID,
+		.start_phys = 0x0,
+		.start_virt = 0x0,
+		.start_dma  = 0x0,
+		.size = 0xF00000,
+		.is_dma_buf = true,
+		.mmap_cnt = 0,
+		.mem_priv = NULL,
+		.d_buf = NULL,
+		.fd = -1,
+		.pIonHandle = NULL,
+		.attach = NULL,
+		.sgt = NULL
+	},
+	{
+		.name = "DIP_MEM_T_ID",
+		.num = DIP_MEM_T_ID,
+		.start_phys = 0x0,
+		.start_virt = 0x0,
+		.start_dma  = 0x0,
+		.size = 0x3000000,
+		.is_dma_buf = true,
+		.mmap_cnt = 0,
+		.mem_priv = NULL,
+		.d_buf = NULL,
+		.fd = -1,
+		.pIonHandle = NULL,
+		.attach = NULL,
+		.sgt = NULL
+	},
+	{
+		.name = "PQDIP_MEM_C_ID",
+		.num = PQDIP_MEM_C_ID,
+		.start_phys = 0x0,
+		.start_virt = 0x0,
+		.start_dma  = 0x0,
+		.size = 0x200000,
+		.is_dma_buf = true,
+		.mmap_cnt = 0,
+		.mem_priv = NULL,
+		.d_buf = NULL,
+		.fd = -1,
+		.pIonHandle = NULL,
+		.attach = NULL,
+		.sgt = NULL
+	},
+	{
+		.name = "PQDIP_MEM_T_ID",
+		.num = PQDIP_MEM_T_ID,
+		.start_phys = 0x0,
+		.start_virt = 0x0,
+		.start_dma  = 0x0,
+		.size = 0x200000,
+		.is_dma_buf = true,
+		.mmap_cnt = 0,
+		.mem_priv = NULL,
+		.d_buf = NULL,
+		.fd = -1,
+		.pIonHandle = NULL,
+		.attach = NULL,
+		.sgt = NULL
+	},
+	{
+		.name = "IMG_MEM_G_ID",
+		.num = IMG_MEM_G_ID,
+		.start_phys = 0x0,
+		.start_virt = 0x0,
+		.start_dma  = 0x0,
+		.size = 0x2200000,
+		.is_dma_buf = true,
+		.mmap_cnt = 0,
+		.mem_priv = NULL,
+		.d_buf = NULL,
+		.fd = -1,
+		.pIonHandle = NULL,
+		.attach = NULL,
+		.sgt = NULL
+	},
+};
+
+
+struct mtk_hcp_reserve_mblock isp70_reserve_mblock[] = {
+	{
+		/*share buffer for frame setting, to be sw usage*/
+		.name = "IMG_MEM_FOR_HW_ID",
+		.num = IMG_MEM_FOR_HW_ID,
+		.start_phys = 0x0,
+		.start_virt = 0x0,
+		.start_dma  = 0x0,
+		.size = 0x400000,   /*need more than 4MB*/
+		.is_dma_buf = true,
+		.mmap_cnt = 0,
+		.mem_priv = NULL,
+		.d_buf = NULL,
+		.fd = -1,
+		.pIonHandle = NULL,
+		.attach = NULL,
+		.sgt = NULL
+	},
+	{
+		.name = "WPE_MEM_C_ID",
+		.num = WPE_MEM_C_ID,
+		.start_phys = 0x0,
+		.start_virt = 0x0,
+		.start_dma  = 0x0,
+		.size = 0xE1000,   /*900KB*/
+		.is_dma_buf = true,
+		.mmap_cnt = 0,
+		.mem_priv = NULL,
+		.d_buf = NULL,
+		.fd = -1,
+		.pIonHandle = NULL,
+		.attach = NULL,
+		.sgt = NULL
+	},
+	{
+		.name = "WPE_MEM_T_ID",
+		.num = WPE_MEM_T_ID,
+		.start_phys = 0x0,
+		.start_virt = 0x0,
+		.start_dma  = 0x0,
+		.size = 0x196000,   /*1MB + 600KB*/
+		.is_dma_buf = true,
+		.mmap_cnt = 0,
+		.mem_priv = NULL,
+		.d_buf = NULL,
+		.fd = -1,
+		.pIonHandle = NULL,
+		.attach = NULL,
+		.sgt = NULL
+	},
+	{
+		.name = "TRAW_MEM_C_ID",
+		.num = TRAW_MEM_C_ID,
+		.start_phys = 0x0,
+		.start_virt = 0x0,
+		.start_dma  = 0x0,
+		.size = 0x4C8000,   /*4MB + 800KB*/
+		.is_dma_buf = true,
+		.mmap_cnt = 0,
+		.mem_priv = NULL,
+		.d_buf = NULL,
+		.fd = -1,
+		.pIonHandle = NULL,
+		.attach = NULL,
+		.sgt = NULL
+	},
+	{
+		.name = "TRAW_MEM_T_ID",
+		.num = TRAW_MEM_T_ID,
+		.start_phys = 0x0,
+		.start_virt = 0x0,
+		.start_dma  = 0x0,
+		.size = 0x1AC8000,   /*26MB + 800KB*/
+		.is_dma_buf = true,
+		.mmap_cnt = 0,
+		.mem_priv = NULL,
+		.d_buf = NULL,
+		.fd = -1,
+		.pIonHandle = NULL,
+		.attach = NULL,
+		.sgt = NULL
+	},
+	{
+		.name = "DIP_MEM_C_ID",
+		.num = DIP_MEM_C_ID,
+		.start_phys = 0x0,
+		.start_virt = 0x0,
+		.start_dma  = 0x0,
+		.size = 0x5C8000,   /*5MB + 800KB*/
+		.is_dma_buf = true,
+		.mmap_cnt = 0,
+		.mem_priv = NULL,
+		.d_buf = NULL,
+		.fd = -1,
+		.pIonHandle = NULL,
+		.attach = NULL,
+		.sgt = NULL
+	},
+	{
+		.name = "DIP_MEM_T_ID",
+		.num = DIP_MEM_T_ID,
+		.start_phys = 0x0,
+		.start_virt = 0x0,
+		.start_dma  = 0x0,
+		.size = 0x1FAF000,   /*31MB + 700KB*/
+		.is_dma_buf = true,
+		.mmap_cnt = 0,
+		.mem_priv = NULL,
+		.d_buf = NULL,
+		.fd = -1,
+		.pIonHandle = NULL,
+		.attach = NULL,
+		.sgt = NULL
+	},
+	{
+		.name = "PQDIP_MEM_C_ID",
+		.num = PQDIP_MEM_C_ID,
+		.start_phys = 0x0,
+		.start_virt = 0x0,
+		.start_dma  = 0x0,
+		.size = 0x100000,   /*1MB*/
+		.is_dma_buf = true,
+		.mmap_cnt = 0,
+		.mem_priv = NULL,
+		.d_buf = NULL,
+		.fd = -1,
+		.pIonHandle = NULL,
+		.attach = NULL,
+		.sgt = NULL
+	},
+	{
+		.name = "PQDIP_MEM_T_ID",
+		.num = PQDIP_MEM_T_ID,
+		.start_phys = 0x0,
+		.start_virt = 0x0,
+		.start_dma  = 0x0,
+		.size = 0x170000,   /*1MB + 500KB*/
+		.is_dma_buf = true,
+		.mmap_cnt = 0,
+		.mem_priv = NULL,
+		.d_buf = NULL,
+		.fd = -1,
+		.pIonHandle = NULL,
+		.attach = NULL,
+		.sgt = NULL
+	},
+	{
+		.name = "IMG_MEM_G_ID",
+		.num = IMG_MEM_G_ID,
+		.start_phys = 0x0,
+		.start_virt = 0x0,
+		.start_dma  = 0x0,
+		.size = 0x1800000,
+		.is_dma_buf = true,
+		.mmap_cnt = 0,
+		.mem_priv = NULL,
+		.d_buf = NULL,
+		.fd = -1,
+		.pIonHandle = NULL,
+		.attach = NULL,
+		.sgt = NULL
+	},
+};
+
+phys_addr_t isp70_get_reserve_mem_phys(unsigned int id)
+{
+	if ((id < 0) || (id >= NUMS_MEM_ID)) {
+		pr_info("[HCP] no reserve memory for %d", id);
+		return 0;
+	} else {
+		return mb[id].start_phys;
+	}
+}
+EXPORT_SYMBOL(isp70_get_reserve_mem_phys);
+
+void *isp70_get_reserve_mem_virt(unsigned int id)
+{
+	if ((id < 0) || (id >= NUMS_MEM_ID)) {
+		pr_info("[HCP] no reserve memory for %d", id);
+		return 0;
+	} else
+		return mb[id].start_virt;
+}
+EXPORT_SYMBOL(isp70_get_reserve_mem_virt);
+
+phys_addr_t isp70_get_reserve_mem_dma(unsigned int id)
+{
+	if ((id < 0) || (id >= NUMS_MEM_ID)) {
+		pr_info("[HCP] no reserve memory for %d", id);
+		return 0;
+	} else {
+		return mb[id].start_dma;
+	}
+}
+EXPORT_SYMBOL(isp70_get_reserve_mem_dma);
+
+phys_addr_t isp70_get_reserve_mem_size(unsigned int id)
+{
+	if ((id < 0) || (id >= NUMS_MEM_ID)) {
+		pr_info("[HCP] no reserve memory for %d", id);
+		return 0;
+	} else {
+		return mb[id].size;
+	}
+}
+EXPORT_SYMBOL(isp70_get_reserve_mem_size);
+
+uint32_t isp70_get_reserve_mem_fd(unsigned int id)
+{
+	if ((id < 0) || (id >= NUMS_MEM_ID)) {
+		pr_info("[HCP] no reserve memory for %d", id);
+		return 0;
+	} else
+		return mb[id].fd;
+}
+EXPORT_SYMBOL(isp70_get_reserve_mem_fd);
+
+void *isp70_get_gce_virt(void)
+{
+	return mb[IMG_MEM_G_ID].start_virt;
+}
+EXPORT_SYMBOL(isp70_get_gce_virt);
+
+void *isp70_get_hwid_virt(void)
+{
+	return mb[DIP_MEM_FOR_HW_ID].start_virt;
+}
+EXPORT_SYMBOL(isp70_get_hwid_virt);
+
+
+int isp70_allocate_working_buffer(struct mtk_hcp *hcp_dev, unsigned int mode)
+{
+	enum isp70_rsv_mem_id_t id;
+	struct mtk_hcp_reserve_mblock *mblock;
+	unsigned int block_num;
+	struct sg_table *sgt;
+	struct dma_buf_attachment *attach;
+	struct dma_heap *pdma_heap;
+	int ret;
+
+	if (mode)
+		mblock = hcp_dev->data->smblock;
+	else
+		mblock = hcp_dev->data->mblock;
+
+	mb = mblock;
+	block_num = hcp_dev->data->block_num;
+	for (id = 0; id < block_num; id++) {
+		if (mblock[id].is_dma_buf) {
+			switch (id) {
+			case IMG_MEM_FOR_HW_ID:
+				/*allocated at probe via dts*/
+				break;
+			case IMG_MEM_G_ID:
+				/* all supported heap name you can find with cmd */
+				/* (ls /dev/dma_heap/) in shell */
+				pdma_heap = dma_heap_find("system");
+				if (!pdma_heap) {
+					pr_info("pdma_heap find fail\n");
+					return -1;
+				}
+				mblock[id].d_buf = dma_heap_buffer_alloc(
+					pdma_heap,
+					mblock[id].size, O_RDWR | O_CLOEXEC,
+					DMA_HEAP_VALID_HEAP_FLAGS);
+				if (IS_ERR(mblock[id].d_buf)) {
+					pr_info("dma_heap_buffer_alloc fail :%ld\n",
+					PTR_ERR(mblock[id].d_buf));
+					return -1;
+				}
+
+				//mtk_dma_buf_set_name(mblock[id].d_buf, mblock[id].name);
+
+				mblock[id].attach = dma_buf_attach(
+				mblock[id].d_buf, hcp_dev->dev);
+				attach = mblock[id].attach;
+				if (IS_ERR(attach)) {
+					pr_info("dma_buf_attach fail :%ld\n",
+					PTR_ERR(attach));
+					return -1;
+				}
+
+				mblock[id].sgt = dma_buf_map_attachment(attach,
+				DMA_BIDIRECTIONAL);
+				sgt = mblock[id].sgt;
+				if (IS_ERR(sgt)) {
+					dma_buf_detach(mblock[id].d_buf, attach);
+					pr_info("dma_buf_map_attachment fail sgt:%ld\n",
+					PTR_ERR(sgt));
+					return -1;
+				}
+				mblock[id].start_phys = sg_dma_address(sgt->sgl);
+				mblock[id].start_dma =
+				mblock[id].start_phys;
+				ret = dma_buf_vmap(mblock[id].d_buf, &(mblock[id].map));
+				if (ret) {
+					pr_info("sg_dma_address fail\n");
+					return -EFAULT;
+				}
+				mblock[id].start_virt = mblock[id].map.vaddr;
+				mblock[id].fd =
+				dma_buf_fd(mblock[id].d_buf,
+				O_RDWR | O_CLOEXEC);
+				dma_buf_get(mblock[id].fd);
+				dma_buf_begin_cpu_access(mblock[id].d_buf, DMA_BIDIRECTIONAL);
+				kref_init(&mblock[id].kref);
+				pr_info("%s:[HCP][%s] phys:0x%llx, virt:%p, dma:0x%llx, size:0x%llx, is_dma_buf:%d, fd:%d, d_buf:%p\n",
+					__func__, mblock[id].name, isp70_get_reserve_mem_phys(id),
+					isp70_get_reserve_mem_virt(id),
+					isp70_get_reserve_mem_dma(id),
+					isp70_get_reserve_mem_size(id),
+					mblock[id].is_dma_buf,
+					isp70_get_reserve_mem_fd(id),
+					mblock[id].d_buf);
+				break;
+			default:
+
+				/* all supported heap name you can find with cmd */
+				/* (ls /dev/dma_heap/) in shell */
+				pdma_heap = dma_heap_find("system");
+				if (!pdma_heap) {
+					pr_info("pdma_heap find fail\n");
+					return -1;
+				}
+				mblock[id].d_buf = dma_heap_buffer_alloc(
+					pdma_heap,
+					mblock[id].size, O_RDWR | O_CLOEXEC,
+					DMA_HEAP_VALID_HEAP_FLAGS);
+				if (IS_ERR(mblock[id].d_buf)) {
+					pr_info("dma_heap_buffer_alloc fail :%ld\n",
+					PTR_ERR(mblock[id].d_buf));
+					return -1;
+				}
+
+				//mtk_dma_buf_set_name(mblock[id].d_buf, mblock[id].name);
+
+				mblock[id].attach = dma_buf_attach(
+				mblock[id].d_buf, hcp_dev->dev);
+				attach = mblock[id].attach;
+				if (IS_ERR(attach)) {
+					pr_info("dma_buf_attach fail :%ld\n",
+					PTR_ERR(attach));
+					return -1;
+				}
+
+				mblock[id].sgt = dma_buf_map_attachment(attach,
+				DMA_TO_DEVICE);
+				sgt = mblock[id].sgt;
+				if (IS_ERR(sgt)) {
+					dma_buf_detach(mblock[id].d_buf, attach);
+					pr_info("dma_buf_map_attachment fail sgt:%ld\n",
+					PTR_ERR(sgt));
+					return -1;
+				}
+				mblock[id].start_phys = sg_dma_address(sgt->sgl);
+				mblock[id].start_dma =
+				mblock[id].start_phys;
+				ret = dma_buf_vmap(mblock[id].d_buf, &(mblock[id].map));
+				if (ret) {
+					pr_info("sg_dma_address fail\n");
+					return -EFAULT;
+				}
+				mblock[id].start_virt = mblock[id].map.vaddr;
+				mblock[id].fd =
+				dma_buf_fd(mblock[id].d_buf,
+				O_RDWR | O_CLOEXEC);
+				dma_buf_get(mblock[id].fd);
+				break;
+			}
+		} else {
+			mblock[id].start_virt =
+				kzalloc(mblock[id].size,
+					GFP_KERNEL);
+			mblock[id].start_phys =
+				virt_to_phys(
+					mblock[id].start_virt);
+			mblock[id].start_dma = 0;
+		}
+		pr_debug(
+			"%s: [HCP][mem_reserve-%d] phys:0x%llx, virt:%p, dma:0x%llx, size:0x%llx, is_dma_buf:%d, fd:%d, d_buf:%p\n",
+			__func__, id, isp70_get_reserve_mem_phys(id),
+			isp70_get_reserve_mem_virt(id),
+			isp70_get_reserve_mem_dma(id),
+			isp70_get_reserve_mem_size(id),
+			mblock[id].is_dma_buf,
+			isp70_get_reserve_mem_fd(id),
+			mblock[id].d_buf);
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(isp70_allocate_working_buffer);
+
+static void gce_release(struct kref *ref)
+{
+	struct mtk_hcp_reserve_mblock *mblock =
+		container_of(ref, struct mtk_hcp_reserve_mblock, kref);
+
+	dma_buf_vunmap(mblock->d_buf, &(mblock->map));
+	/* free iova */
+	dma_buf_unmap_attachment(mblock->attach, mblock->sgt, DMA_BIDIRECTIONAL);
+	dma_buf_detach(mblock->d_buf, mblock->attach);
+	dma_buf_end_cpu_access(mblock->d_buf, DMA_BIDIRECTIONAL);
+	dma_buf_put(mblock->d_buf);
+	pr_info("%s:[HCP][%s] phys:0x%llx, virt:%p, dma:0x%llx, size:0x%llx, is_dma_buf:%d, fd:%d, d_buf:%p\n",
+		__func__, mblock->name, isp70_get_reserve_mem_phys(IMG_MEM_G_ID),
+		isp70_get_reserve_mem_virt(IMG_MEM_G_ID),
+		isp70_get_reserve_mem_dma(IMG_MEM_G_ID),
+		isp70_get_reserve_mem_size(IMG_MEM_G_ID),
+		mblock->is_dma_buf,
+		isp70_get_reserve_mem_fd(IMG_MEM_G_ID),
+		mblock->d_buf);
+	// close fd in user space driver, you can't close fd in kernel site
+	// dma_heap_buffer_free(mblock[id].d_buf);
+	//dma_buf_put(my_dma_buf);
+	//also can use this api, but not recommended
+	mblock->mem_priv = NULL;
+	mblock->mmap_cnt = 0;
+	mblock->start_dma = 0x0;
+	mblock->start_virt = 0x0;
+	mblock->start_phys = 0x0;
+	mblock->d_buf = NULL;
+	mblock->fd = -1;
+	mblock->pIonHandle = NULL;
+	mblock->attach = NULL;
+	mblock->sgt = NULL;
+	pr_info("%s", __func__);
+}
+
+
+int isp70_release_working_buffer(struct mtk_hcp *hcp_dev)
+{
+	enum isp70_rsv_mem_id_t id;
+	struct mtk_hcp_reserve_mblock *mblock;
+
+	mblock = mb;
+
+	/* release reserved memory */
+	for (id = 0; id < NUMS_MEM_ID; id++) {
+		if (mblock[id].is_dma_buf) {
+			switch (id) {
+			case IMG_MEM_FOR_HW_ID:
+				/*allocated at probe via dts*/
+				break;
+			case IMG_MEM_G_ID:
+				kref_put(&mblock[id].kref, gce_release);
+				break;
+			default:
+				/* free va */
+				dma_buf_vunmap(mblock[id].d_buf, &(mblock[id].map));
+				/* free iova */
+				dma_buf_unmap_attachment(mblock[id].attach,
+				mblock[id].sgt, DMA_TO_DEVICE);
+				dma_buf_detach(mblock[id].d_buf,
+				mblock[id].attach);
+				dma_buf_put(mblock[id].d_buf);
+				// close fd in user space driver, you can't close fd in kernel site
+				// dma_heap_buffer_free(mblock[id].d_buf);
+				//dma_buf_put(my_dma_buf);
+				//also can use this api, but not recommended
+				mblock[id].mem_priv = NULL;
+				mblock[id].mmap_cnt = 0;
+				mblock[id].start_dma = 0x0;
+				mblock[id].start_virt = 0x0;
+				mblock[id].start_phys = 0x0;
+				mblock[id].d_buf = NULL;
+				mblock[id].fd = -1;
+				mblock[id].pIonHandle = NULL;
+				mblock[id].attach = NULL;
+				mblock[id].sgt = NULL;
+				break;
+			}
+		} else {
+			kfree(mblock[id].start_virt);
+			mblock[id].start_virt = 0x0;
+			mblock[id].start_phys = 0x0;
+			mblock[id].start_dma = 0x0;
+			mblock[id].mmap_cnt = 0;
+		}
+		pr_debug(
+			"%s: [HCP][mem_reserve-%d] phys:0x%llx, virt:%p, dma:0x%llx, size:0x%llx, is_dma_buf:%d, fd:%d\n",
+			__func__, id, isp70_get_reserve_mem_phys(id),
+			isp70_get_reserve_mem_virt(id),
+			isp70_get_reserve_mem_dma(id),
+			isp70_get_reserve_mem_size(id),
+			mblock[id].is_dma_buf,
+			isp70_get_reserve_mem_fd(id));
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(isp70_release_working_buffer);
+
+int isp70_get_init_info(struct img_init_info *info)
+{
+
+	if (!info) {
+		pr_info("%s:NULL info\n", __func__);
+		return -1;
+	}
+
+	info->hw_buf = isp70_get_reserve_mem_phys(DIP_MEM_FOR_HW_ID);
+	/*WPE:0, ADL:1, TRAW:2, DIP:3, PQDIP:4 */
+	info->module_info[0].c_wbuf =
+				isp70_get_reserve_mem_phys(WPE_MEM_C_ID);
+	info->module_info[0].c_wbuf_dma =
+				isp70_get_reserve_mem_dma(WPE_MEM_C_ID);
+	info->module_info[0].c_wbuf_sz =
+				isp70_get_reserve_mem_size(WPE_MEM_C_ID);
+	info->module_info[0].c_wbuf_fd =
+				isp70_get_reserve_mem_fd(WPE_MEM_C_ID);
+	info->module_info[0].t_wbuf =
+				isp70_get_reserve_mem_phys(WPE_MEM_T_ID);
+	info->module_info[0].t_wbuf_dma =
+				isp70_get_reserve_mem_dma(WPE_MEM_T_ID);
+	info->module_info[0].t_wbuf_sz =
+				isp70_get_reserve_mem_size(WPE_MEM_T_ID);
+	info->module_info[0].t_wbuf_fd =
+				isp70_get_reserve_mem_fd(WPE_MEM_T_ID);
+
+	// TRAW
+	info->module_info[1].c_wbuf =
+				isp70_get_reserve_mem_phys(TRAW_MEM_C_ID);
+	info->module_info[1].c_wbuf_dma =
+				isp70_get_reserve_mem_dma(TRAW_MEM_C_ID);
+	info->module_info[1].c_wbuf_sz =
+				isp70_get_reserve_mem_size(TRAW_MEM_C_ID);
+	info->module_info[1].c_wbuf_fd =
+				isp70_get_reserve_mem_fd(TRAW_MEM_C_ID);
+	info->module_info[1].t_wbuf =
+				isp70_get_reserve_mem_phys(TRAW_MEM_T_ID);
+	info->module_info[1].t_wbuf_dma =
+				isp70_get_reserve_mem_dma(TRAW_MEM_T_ID);
+	info->module_info[1].t_wbuf_sz =
+				isp70_get_reserve_mem_size(TRAW_MEM_T_ID);
+	info->module_info[1].t_wbuf_fd =
+				isp70_get_reserve_mem_fd(TRAW_MEM_T_ID);
+
+		// DIP
+	info->module_info[2].c_wbuf =
+				isp70_get_reserve_mem_phys(DIP_MEM_C_ID);
+	info->module_info[2].c_wbuf_dma =
+				isp70_get_reserve_mem_dma(DIP_MEM_C_ID);
+	info->module_info[2].c_wbuf_sz =
+				isp70_get_reserve_mem_size(DIP_MEM_C_ID);
+	info->module_info[2].c_wbuf_fd =
+				isp70_get_reserve_mem_fd(DIP_MEM_C_ID);
+	info->module_info[2].t_wbuf =
+				isp70_get_reserve_mem_phys(DIP_MEM_T_ID);
+	info->module_info[2].t_wbuf_dma =
+				isp70_get_reserve_mem_dma(DIP_MEM_T_ID);
+	info->module_info[2].t_wbuf_sz =
+				isp70_get_reserve_mem_size(DIP_MEM_T_ID);
+	info->module_info[2].t_wbuf_fd =
+				isp70_get_reserve_mem_fd(DIP_MEM_T_ID);
+
+	// PQDIP
+	info->module_info[3].c_wbuf =
+				isp70_get_reserve_mem_phys(PQDIP_MEM_C_ID);
+	info->module_info[3].c_wbuf_dma =
+				isp70_get_reserve_mem_dma(PQDIP_MEM_C_ID);
+	info->module_info[3].c_wbuf_sz =
+				isp70_get_reserve_mem_size(PQDIP_MEM_C_ID);
+	info->module_info[3].c_wbuf_fd =
+			isp70_get_reserve_mem_fd(PQDIP_MEM_C_ID);
+	info->module_info[3].t_wbuf =
+				isp70_get_reserve_mem_phys(PQDIP_MEM_T_ID);
+	info->module_info[3].t_wbuf_dma =
+				isp70_get_reserve_mem_dma(PQDIP_MEM_T_ID);
+	info->module_info[3].t_wbuf_sz =
+				isp70_get_reserve_mem_size(PQDIP_MEM_T_ID);
+	info->module_info[3].t_wbuf_fd =
+				isp70_get_reserve_mem_fd(PQDIP_MEM_T_ID);
+
+	/*common*/
+	/* info->g_wbuf_fd = isp70_get_reserve_mem_fd(IMG_MEM_G_ID); */
+	info->g_wbuf_fd = isp70_get_reserve_mem_fd(IMG_MEM_G_ID);
+	info->g_wbuf = isp70_get_reserve_mem_phys(IMG_MEM_G_ID);
+	/*info->g_wbuf_sw = isp70_get_reserve_mem_virt(IMG_MEM_G_ID);*/
+	info->g_wbuf_sz = isp70_get_reserve_mem_size(IMG_MEM_G_ID);
+
+	return 0;
+}
+
+static int isp70_put_gce(void)
+{
+	kref_put(&mb[IMG_MEM_G_ID].kref, gce_release);
+	return 0;
+}
+
+static int isp70_get_gce(void)
+{
+	kref_get(&mb[IMG_MEM_G_ID].kref);
+	return 0;
+}
+
+struct mtk_hcp_data isp70_hcp_data = {
+	.mblock = isp70_reserve_mblock,
+	.block_num = ARRAY_SIZE(isp70_reserve_mblock),
+	.smblock = isp70_smvr_mblock,
+	.allocate = isp70_allocate_working_buffer,
+	.release = isp70_release_working_buffer,
+	.get_init_info = isp70_get_init_info,
+	.get_gce_virt = isp70_get_gce_virt,
+	.get_gce = isp70_get_gce,
+	.put_gce = isp70_put_gce,
+	.get_hwid_virt = isp70_get_hwid_virt,
+};
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/mtk-hcp/mtk-hcp_isp70.h b/drivers/media/platform/mediatek/isp/isp_7x/mtk-hcp/mtk-hcp_isp70.h
new file mode 100644
index 0000000000000000000000000000000000000000..7eb3a012d68abb6ef0ce791d3a0f8c01d2a8c927
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/mtk-hcp/mtk-hcp_isp70.h
@@ -0,0 +1,41 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2019 MediaTek Inc.
+ */
+
+#ifndef MTK_HCP_ISP70_H
+#define MTK_HCP_ISP70_H
+
+#include "mtk-hcp.h"
+
+enum isp70_rsv_mem_id_t {
+	DIP_MEM_FOR_HW_ID,
+	IMG_MEM_FOR_HW_ID = DIP_MEM_FOR_HW_ID, /*shared buffer for ipi_param*/
+	/*need replace DIP_MEM_FOR_HW_ID & DIP_MEM_FOR_SW_ID*/
+	WPE_MEM_C_ID,	/*module cq buffer*/
+	WPE_MEM_T_ID,	/*module tdr buffer*/
+	TRAW_MEM_C_ID,	/*module cq buffer*/
+	TRAW_MEM_T_ID,	/*module tdr buffer*/
+	DIP_MEM_C_ID,	/*module cq buffer*/
+	DIP_MEM_T_ID,	/*module tdr buffer*/
+	PQDIP_MEM_C_ID,	/*module cq buffer*/
+	PQDIP_MEM_T_ID,	/*module tdr buffer*/
+	IMG_MEM_G_ID,	/*gce cmd buffer*/
+	NUMS_MEM_ID,
+};
+
+phys_addr_t isp70_get_reserve_mem_phys(unsigned int id);
+void *isp70_get_reserve_mem_virt(unsigned int id);
+phys_addr_t isp70_get_reserve_mem_dma(unsigned int id);
+phys_addr_t isp70_get_reserve_mem_size(unsigned int id);
+uint32_t isp70_get_reserve_mem_fd(unsigned int id);
+
+int isp70_release_working_buffer(struct mtk_hcp *hcp_dev);
+int isp70_allocate_working_buffer(struct mtk_hcp *hcp_dev, unsigned int mode);
+int isp70_get_init_info(struct img_init_info *info);
+void *isp70_get_gce_virt(void);
+void *isp70_get_hwid_virt(void);
+
+extern struct mtk_hcp_data isp70_hcp_data;
+
+#endif /* _MTK_HCP_ISP70_H */
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/mtk-hcp/mtk-hcp_isp71.c b/drivers/media/platform/mediatek/isp/isp_7x/mtk-hcp/mtk-hcp_isp71.c
new file mode 100755
index 0000000000000000000000000000000000000000..f7a639fded7267b85f17998d8cd46787b7c86258
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/mtk-hcp/mtk-hcp_isp71.c
@@ -0,0 +1,875 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2019 MediaTek Inc.
+ */
+#include <linux/slab.h>
+#include <linux/kref.h>
+//#include "mtk_heap.h"
+#include "mtk-hcp_isp71.h"
+
+static struct mtk_hcp_reserve_mblock *mb;
+
+static struct mtk_hcp_reserve_mblock isp71_smvr_mblock[] = {
+	{
+		/*share buffer for frame setting, to be sw usage*/
+		.name = "IMG_MEM_FOR_HW_ID",
+		.num = IMG_MEM_FOR_HW_ID,
+		.start_phys = 0x0,
+		.start_virt = 0x0,
+		.start_dma  = 0x0,
+		.size = 0x400000,   /*need more than 4MB*/
+		.is_dma_buf = true,
+		.mmap_cnt = 0,
+		.mem_priv = NULL,
+		.d_buf = NULL,
+		.fd = -1,
+		.pIonHandle = NULL,
+		.attach = NULL,
+		.sgt = NULL
+	},
+	{
+		.name = "WPE_MEM_C_ID",
+		.num = WPE_MEM_C_ID,
+		.start_phys = 0x0,
+		.start_virt = 0x0,
+		.start_dma  = 0x0,
+		.size = 0x300000,
+		.is_dma_buf = true,
+		.mmap_cnt = 0,
+		.mem_priv = NULL,
+		.d_buf = NULL,
+		.fd = -1,
+		.pIonHandle = NULL,
+		.attach = NULL,
+		.sgt = NULL
+	},
+	{
+		.name = "WPE_MEM_T_ID",
+		.num = WPE_MEM_T_ID,
+		.start_phys = 0x0,
+		.start_virt = 0x0,
+		.start_dma  = 0x0,
+		.size = 0x500000,
+		.is_dma_buf = true,
+		.mmap_cnt = 0,
+		.mem_priv = NULL,
+		.d_buf = NULL,
+		.fd = -1,
+		.pIonHandle = NULL,
+		.attach = NULL,
+		.sgt = NULL
+	},
+	{
+		.name = "TRAW_MEM_C_ID",
+		.num = TRAW_MEM_C_ID,
+		.start_phys = 0x0,
+		.start_virt = 0x0,
+		.start_dma  = 0x0,
+		.size = 0xB00000,
+		.is_dma_buf = true,
+		.mmap_cnt = 0,
+		.mem_priv = NULL,
+		.d_buf = NULL,
+		.fd = -1,
+		.pIonHandle = NULL,
+		.attach = NULL,
+		.sgt = NULL
+	},
+	{
+		.name = "TRAW_MEM_T_ID",
+		.num = TRAW_MEM_T_ID,
+		.start_phys = 0x0,
+		.start_virt = 0x0,
+		.start_dma  = 0x0,
+		.size = 0x3000000,
+		.is_dma_buf = true,
+		.mmap_cnt = 0,
+		.mem_priv = NULL,
+		.d_buf = NULL,
+		.fd = -1,
+		.pIonHandle = NULL,
+		.attach = NULL,
+		.sgt = NULL
+	},
+	{
+		.name = "DIP_MEM_C_ID",
+		.num = DIP_MEM_C_ID,
+		.start_phys = 0x0,
+		.start_virt = 0x0,
+		.start_dma  = 0x0,
+		.size = 0xF00000,
+		.is_dma_buf = true,
+		.mmap_cnt = 0,
+		.mem_priv = NULL,
+		.d_buf = NULL,
+		.fd = -1,
+		.pIonHandle = NULL,
+		.attach = NULL,
+		.sgt = NULL
+	},
+	{
+		.name = "DIP_MEM_T_ID",
+		.num = DIP_MEM_T_ID,
+		.start_phys = 0x0,
+		.start_virt = 0x0,
+		.start_dma  = 0x0,
+		.size = 0x3000000,
+		.is_dma_buf = true,
+		.mmap_cnt = 0,
+		.mem_priv = NULL,
+		.d_buf = NULL,
+		.fd = -1,
+		.pIonHandle = NULL,
+		.attach = NULL,
+		.sgt = NULL
+	},
+	{
+		.name = "PQDIP_MEM_C_ID",
+		.num = PQDIP_MEM_C_ID,
+		.start_phys = 0x0,
+		.start_virt = 0x0,
+		.start_dma  = 0x0,
+		.size = 0x200000,
+		.is_dma_buf = true,
+		.mmap_cnt = 0,
+		.mem_priv = NULL,
+		.d_buf = NULL,
+		.fd = -1,
+		.pIonHandle = NULL,
+		.attach = NULL,
+		.sgt = NULL
+	},
+	{
+		.name = "PQDIP_MEM_T_ID",
+		.num = PQDIP_MEM_T_ID,
+		.start_phys = 0x0,
+		.start_virt = 0x0,
+		.start_dma  = 0x0,
+		.size = 0x200000,
+		.is_dma_buf = true,
+		.mmap_cnt = 0,
+		.mem_priv = NULL,
+		.d_buf = NULL,
+		.fd = -1,
+		.pIonHandle = NULL,
+		.attach = NULL,
+		.sgt = NULL
+	},
+	{
+		.name = "ADL_MEM_C_ID",
+		.num = ADL_MEM_C_ID,
+		.start_phys = 0x0,
+		.start_virt = 0x0,
+		.start_dma  = 0x0,
+		.size = 0x100000,
+		.is_dma_buf = true,
+		.mmap_cnt = 0,
+		.mem_priv = NULL,
+		.d_buf = NULL,
+		.fd = -1,
+		.pIonHandle = NULL
+	},
+	{
+		.name = "ADL_MEM_T_ID",
+		.num = ADL_MEM_T_ID,
+		.start_phys = 0x0,
+		.start_virt = 0x0,
+		.start_dma  = 0x0,
+		.size = 0x200000,
+		.is_dma_buf = true,
+		.mmap_cnt = 0,
+		.mem_priv = NULL,
+		.d_buf = NULL,
+		.fd = -1,
+		.pIonHandle = NULL
+	},
+	{
+		.name = "IMG_MEM_G_ID",
+		.num = IMG_MEM_G_ID,
+		.start_phys = 0x0,
+		.start_virt = 0x0,
+		.start_dma  = 0x0,
+		.size = 0x2200000,
+		.is_dma_buf = true,
+		.mmap_cnt = 0,
+		.mem_priv = NULL,
+		.d_buf = NULL,
+		.fd = -1,
+		.pIonHandle = NULL,
+		.attach = NULL,
+		.sgt = NULL
+	},
+};
+
+
+struct mtk_hcp_reserve_mblock isp71_reserve_mblock[] = {
+	{
+		/*share buffer for frame setting, to be sw usage*/
+		.name = "IMG_MEM_FOR_HW_ID",
+		.num = IMG_MEM_FOR_HW_ID,
+		.start_phys = 0x0,
+		.start_virt = 0x0,
+		.start_dma  = 0x0,
+		.size = 0x400000,   /*need more than 4MB*/
+		.is_dma_buf = true,
+		.mmap_cnt = 0,
+		.mem_priv = NULL,
+		.d_buf = NULL,
+		.fd = -1,
+		.pIonHandle = NULL,
+		.attach = NULL,
+		.sgt = NULL
+	},
+	{
+		.name = "WPE_MEM_C_ID",
+		.num = WPE_MEM_C_ID,
+		.start_phys = 0x0,
+		.start_virt = 0x0,
+		.start_dma  = 0x0,
+		.size = 0xE1000,   /*900KB*/
+		.is_dma_buf = true,
+		.mmap_cnt = 0,
+		.mem_priv = NULL,
+		.d_buf = NULL,
+		.fd = -1,
+		.pIonHandle = NULL,
+		.attach = NULL,
+		.sgt = NULL
+	},
+	{
+		.name = "WPE_MEM_T_ID",
+		.num = WPE_MEM_T_ID,
+		.start_phys = 0x0,
+		.start_virt = 0x0,
+		.start_dma  = 0x0,
+		.size = 0x196000,   /*1MB + 600KB*/
+		.is_dma_buf = true,
+		.mmap_cnt = 0,
+		.mem_priv = NULL,
+		.d_buf = NULL,
+		.fd = -1,
+		.pIonHandle = NULL,
+		.attach = NULL,
+		.sgt = NULL
+	},
+	{
+		.name = "TRAW_MEM_C_ID",
+		.num = TRAW_MEM_C_ID,
+		.start_phys = 0x0,
+		.start_virt = 0x0,
+		.start_dma  = 0x0,
+		.size = 0x4C8000,   /*4MB + 800KB*/
+		.is_dma_buf = true,
+		.mmap_cnt = 0,
+		.mem_priv = NULL,
+		.d_buf = NULL,
+		.fd = -1,
+		.pIonHandle = NULL,
+		.attach = NULL,
+		.sgt = NULL
+	},
+	{
+		.name = "TRAW_MEM_T_ID",
+		.num = TRAW_MEM_T_ID,
+		.start_phys = 0x0,
+		.start_virt = 0x0,
+		.start_dma  = 0x0,
+		.size = 0x1AC8000,   /*26MB + 800KB*/
+		.is_dma_buf = true,
+		.mmap_cnt = 0,
+		.mem_priv = NULL,
+		.d_buf = NULL,
+		.fd = -1,
+		.pIonHandle = NULL,
+		.attach = NULL,
+		.sgt = NULL
+	},
+	{
+		.name = "DIP_MEM_C_ID",
+		.num = DIP_MEM_C_ID,
+		.start_phys = 0x0,
+		.start_virt = 0x0,
+		.start_dma  = 0x0,
+		.size = 0x5C8000,   /*5MB + 800KB*/
+		.is_dma_buf = true,
+		.mmap_cnt = 0,
+		.mem_priv = NULL,
+		.d_buf = NULL,
+		.fd = -1,
+		.pIonHandle = NULL,
+		.attach = NULL,
+		.sgt = NULL
+	},
+	{
+		.name = "DIP_MEM_T_ID",
+		.num = DIP_MEM_T_ID,
+		.start_phys = 0x0,
+		.start_virt = 0x0,
+		.start_dma  = 0x0,
+		.size = 0x1FAF000,   /*31MB + 700KB*/
+		.is_dma_buf = true,
+		.mmap_cnt = 0,
+		.mem_priv = NULL,
+		.d_buf = NULL,
+		.fd = -1,
+		.pIonHandle = NULL,
+		.attach = NULL,
+		.sgt = NULL
+	},
+	{
+		.name = "PQDIP_MEM_C_ID",
+		.num = PQDIP_MEM_C_ID,
+		.start_phys = 0x0,
+		.start_virt = 0x0,
+		.start_dma  = 0x0,
+		.size = 0x100000,   /*1MB*/
+		.is_dma_buf = true,
+		.mmap_cnt = 0,
+		.mem_priv = NULL,
+		.d_buf = NULL,
+		.fd = -1,
+		.pIonHandle = NULL,
+		.attach = NULL,
+		.sgt = NULL
+	},
+	{
+		.name = "PQDIP_MEM_T_ID",
+		.num = PQDIP_MEM_T_ID,
+		.start_phys = 0x0,
+		.start_virt = 0x0,
+		.start_dma  = 0x0,
+		.size = 0x170000,   /*1MB + 500KB*/
+		.is_dma_buf = true,
+		.mmap_cnt = 0,
+		.mem_priv = NULL,
+		.d_buf = NULL,
+		.fd = -1,
+		.pIonHandle = NULL,
+		.attach = NULL,
+		.sgt = NULL
+	},
+	{
+		.name = "ADL_MEM_C_ID",
+		.num = ADL_MEM_C_ID,
+		.start_phys = 0x0,
+		.start_virt = 0x0,
+		.start_dma  = 0x0,
+		.size = 0x100000,   /*1MB*/
+		.is_dma_buf = true,
+		.mmap_cnt = 0,
+		.mem_priv = NULL,
+		.d_buf = NULL,
+		.fd = -1,
+		.pIonHandle = NULL
+	},
+	{
+		.name = "ADL_MEM_T_ID",
+		.num = ADL_MEM_T_ID,
+		.start_phys = 0x0,
+		.start_virt = 0x0,
+		.start_dma  = 0x0,
+		.size = 0x200000,   /*2MB*/
+		.is_dma_buf = true,
+		.mmap_cnt = 0,
+		.mem_priv = NULL,
+		.d_buf = NULL,
+		.fd = -1,
+		.pIonHandle = NULL
+	},
+	{
+		.name = "IMG_MEM_G_ID",
+		.num = IMG_MEM_G_ID,
+		.start_phys = 0x0,
+		.start_virt = 0x0,
+		.start_dma  = 0x0,
+		.size = 0x1800000,
+		.is_dma_buf = true,
+		.mmap_cnt = 0,
+		.mem_priv = NULL,
+		.d_buf = NULL,
+		.fd = -1,
+		.pIonHandle = NULL,
+		.attach = NULL,
+		.sgt = NULL
+	},
+};
+
+phys_addr_t isp71_get_reserve_mem_phys(unsigned int id)
+{
+	if (id >= NUMS_MEM_ID) {
+		pr_info("[HCP] no reserve memory for %d", id);
+		return 0;
+	} else {
+		return mb[id].start_phys;
+	}
+}
+EXPORT_SYMBOL(isp71_get_reserve_mem_phys);
+
+void *isp71_get_reserve_mem_virt(unsigned int id)
+{
+	if (id >= NUMS_MEM_ID) {
+		pr_info("[HCP] no reserve memory for %d", id);
+		return 0;
+	} else
+		return mb[id].start_virt;
+}
+EXPORT_SYMBOL(isp71_get_reserve_mem_virt);
+
+phys_addr_t isp71_get_reserve_mem_dma(unsigned int id)
+{
+	if (id >= NUMS_MEM_ID) {
+		pr_info("[HCP] no reserve memory for %d", id);
+		return 0;
+	} else {
+		return mb[id].start_dma;
+	}
+}
+EXPORT_SYMBOL(isp71_get_reserve_mem_dma);
+
+phys_addr_t isp71_get_reserve_mem_size(unsigned int id)
+{
+	if (id >= NUMS_MEM_ID) {
+		pr_info("[HCP] no reserve memory for %d", id);
+		return 0;
+	} else {
+		return mb[id].size;
+	}
+}
+EXPORT_SYMBOL(isp71_get_reserve_mem_size);
+
+uint32_t isp71_get_reserve_mem_fd(unsigned int id)
+{
+	if (id >= NUMS_MEM_ID) {
+		pr_info("[HCP] no reserve memory for %d", id);
+		return 0;
+	} else
+		return mb[id].fd;
+}
+EXPORT_SYMBOL(isp71_get_reserve_mem_fd);
+
+void *isp71_get_gce_virt(void)
+{
+	return mb[IMG_MEM_G_ID].start_virt;
+}
+EXPORT_SYMBOL(isp71_get_gce_virt);
+
+void *isp71_get_hwid_virt(void)
+{
+	return mb[DIP_MEM_FOR_HW_ID].start_virt;
+}
+EXPORT_SYMBOL(isp71_get_hwid_virt);
+
+phys_addr_t isp71_get_gce_mem_size(void)
+{
+	return mb[IMG_MEM_G_ID].size;
+}
+EXPORT_SYMBOL(isp71_get_gce_mem_size);
+
+int isp71_allocate_working_buffer(struct mtk_hcp *hcp_dev, unsigned int mode)
+{
+	enum isp71_rsv_mem_id_t id;
+	struct mtk_hcp_reserve_mblock *mblock;
+	unsigned int block_num;
+	struct sg_table *sgt;
+	struct dma_buf_attachment *attach;
+	struct dma_heap *pdma_heap;
+	//void *buf_ptr;
+	int ret;
+
+	if (mode)
+		mblock = hcp_dev->data->smblock;
+	else
+		mblock = hcp_dev->data->mblock;
+
+	mb = mblock;
+	block_num = hcp_dev->data->block_num;
+	for (id = 0; id < block_num; id++) {
+		if (mblock[id].is_dma_buf) {
+			switch (id) {
+			case IMG_MEM_FOR_HW_ID:
+				/*allocated at probe via dts*/
+				break;
+			case IMG_MEM_G_ID:
+				/* all supported heap name you can find with cmd */
+				/* (ls /dev/dma_heap/) in shell */
+				pdma_heap = dma_heap_find("system");
+				if (!pdma_heap) {
+					pr_info("pdma_heap find fail\n");
+					return -1;
+				}
+				mblock[id].d_buf = dma_heap_buffer_alloc(
+					pdma_heap,
+					mblock[id].size, O_RDWR | O_CLOEXEC,
+					DMA_HEAP_VALID_HEAP_FLAGS);
+				if (IS_ERR(mblock[id].d_buf)) {
+					pr_info("dma_heap_buffer_alloc fail :%ld\n",
+					PTR_ERR(mblock[id].d_buf));
+					return -1;
+				}
+
+				//mtk_dma_buf_set_name(mblock[id].d_buf, mblock[id].name);
+
+				mblock[id].attach = dma_buf_attach(
+				mblock[id].d_buf, hcp_dev->dev);
+				attach = mblock[id].attach;
+				if (IS_ERR(attach)) {
+					pr_info("dma_buf_attach fail :%ld\n",
+					PTR_ERR(attach));
+					return -1;
+				}
+
+				mblock[id].sgt = dma_buf_map_attachment(attach,
+				DMA_BIDIRECTIONAL);
+				sgt = mblock[id].sgt;
+				if (IS_ERR(sgt)) {
+					dma_buf_detach(mblock[id].d_buf, attach);
+					pr_info("dma_buf_map_attachment fail sgt:%ld\n",
+					PTR_ERR(sgt));
+					return -1;
+				}
+				mblock[id].start_phys = sg_dma_address(sgt->sgl);
+				mblock[id].start_dma =
+				mblock[id].start_phys;
+
+				ret = dma_buf_vmap(mblock[id].d_buf, &(mblock[id].map));
+				if (ret) {
+					pr_info("sg_dma_address fail\n");
+					return -EFAULT;
+				}
+
+				mblock[id].start_virt =  mblock[id].map.vaddr;
+				get_dma_buf(mblock[id].d_buf);
+				mblock[id].fd =
+				dma_buf_fd(mblock[id].d_buf,
+				O_RDWR | O_CLOEXEC);
+				dma_buf_begin_cpu_access(mblock[id].d_buf, DMA_BIDIRECTIONAL);
+				kref_init(&mblock[id].kref);
+				pr_info("%s:[HCP][%s] phys:0x%llx, virt:0x%p, dma:0x%llx, size:0x%llx, is_dma_buf:%d, fd:%d, d_buf:0x%p\n",
+					__func__, mblock[id].name, isp71_get_reserve_mem_phys(id),
+					isp71_get_reserve_mem_virt(id),
+					isp71_get_reserve_mem_dma(id),
+					isp71_get_reserve_mem_size(id),
+					mblock[id].is_dma_buf,
+					isp71_get_reserve_mem_fd(id),
+					mblock[id].d_buf);
+				break;
+			default:
+
+				/* all supported heap name you can find with cmd */
+				/* (ls /dev/dma_heap/) in shell */
+
+				pdma_heap = dma_heap_find("system");
+
+				if (!pdma_heap) {
+					pr_info("pdma_heap find fail\n");
+					return -1;
+				}
+				mblock[id].d_buf = dma_heap_buffer_alloc(
+					pdma_heap,
+					mblock[id].size, O_RDWR | O_CLOEXEC,
+					DMA_HEAP_VALID_HEAP_FLAGS);
+
+				if (IS_ERR(mblock[id].d_buf)) {
+					pr_info("dma_heap_buffer_alloc fail :%ld\n",
+					PTR_ERR(mblock[id].d_buf));
+					return -1;
+				}
+
+				//mtk_dma_buf_set_name(mblock[id].d_buf, mblock[id].name);
+
+				mblock[id].attach = dma_buf_attach(
+				mblock[id].d_buf, hcp_dev->dev);
+				attach = mblock[id].attach;
+				if (IS_ERR(attach)) {
+					pr_info("dma_buf_attach fail :%ld\n",
+					PTR_ERR(attach));
+					return -1;
+				}
+
+				mblock[id].sgt = dma_buf_map_attachment(attach,
+				DMA_TO_DEVICE);
+				sgt = mblock[id].sgt;
+				if (IS_ERR(sgt)) {
+					dma_buf_detach(mblock[id].d_buf, attach);
+					pr_info("dma_buf_map_attachment fail sgt:%ld\n",
+					PTR_ERR(sgt));
+					return -1;
+				}
+				mblock[id].start_phys = sg_dma_address(sgt->sgl);
+				mblock[id].start_dma =
+				mblock[id].start_phys;
+				ret = dma_buf_vmap(mblock[id].d_buf, &(mblock[id].map));
+				if (ret) {
+					pr_info("sg_dma_address fail\n");
+					return -EFAULT;
+				}
+				mblock[id].start_virt = mblock[id].map.vaddr;
+				get_dma_buf(mblock[id].d_buf);
+				mblock[id].fd =
+				dma_buf_fd(mblock[id].d_buf,
+				O_RDWR | O_CLOEXEC);
+				break;
+			}
+		} else {
+			mblock[id].start_virt =
+				kzalloc(mblock[id].size,
+					GFP_KERNEL);
+			mblock[id].start_phys =
+				virt_to_phys(
+					mblock[id].start_virt);
+			mblock[id].start_dma = 0;
+		}
+		pr_debug(
+			"%s: [HCP][mem_reserve-%d] phys:0x%llx, virt:0x%p, dma:0x%llx, size:0x%llx, is_dma_buf:%d, fd:%d, d_buf:0x%p\n",
+			__func__, id, isp71_get_reserve_mem_phys(id),
+			isp71_get_reserve_mem_virt(id),
+			isp71_get_reserve_mem_dma(id),
+			isp71_get_reserve_mem_size(id),
+			mblock[id].is_dma_buf,
+			isp71_get_reserve_mem_fd(id),
+			mblock[id].d_buf);
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(isp71_allocate_working_buffer);
+
+static void gce_release(struct kref *ref)
+{
+	struct mtk_hcp_reserve_mblock *mblock =
+		container_of(ref, struct mtk_hcp_reserve_mblock, kref);
+
+	//dma_buf_vunmap(mblock->d_buf, mblock->start_virt);
+	dma_buf_vunmap(mblock->d_buf, &(mblock->map));
+	/* free iova */
+	dma_buf_unmap_attachment(mblock->attach, mblock->sgt, DMA_BIDIRECTIONAL);
+	dma_buf_detach(mblock->d_buf, mblock->attach);
+	dma_buf_end_cpu_access(mblock->d_buf, DMA_BIDIRECTIONAL);
+	dma_buf_put(mblock->d_buf);
+	pr_info("%s:[HCP][%s] phys:0x%llx, virt:0x%p, dma:0x%llx, size:0x%llx, is_dma_buf:%d, fd:%d, d_buf:0x%p\n",
+		__func__, mblock->name, isp71_get_reserve_mem_phys(IMG_MEM_G_ID),
+		isp71_get_reserve_mem_virt(IMG_MEM_G_ID),
+		isp71_get_reserve_mem_dma(IMG_MEM_G_ID),
+		isp71_get_reserve_mem_size(IMG_MEM_G_ID),
+		mblock->is_dma_buf,
+		isp71_get_reserve_mem_fd(IMG_MEM_G_ID),
+		mblock->d_buf);
+	//close fd in user space driver, you can't close fd in kernel site
+	//dma_heap_buffer_free(mblock[id].d_buf);
+	//dma_buf_put(my_dma_buf);
+	//also can use this api, but not recommended
+	mblock->mem_priv = NULL;
+	mblock->mmap_cnt = 0;
+	mblock->start_dma = 0x0;
+	mblock->start_virt = 0x0;
+	mblock->start_phys = 0x0;
+	mblock->d_buf = NULL;
+	mblock->fd = -1;
+	mblock->pIonHandle = NULL;
+	mblock->attach = NULL;
+	mblock->sgt = NULL;
+	pr_info("%s", __func__);
+}
+
+
+int isp71_release_working_buffer(struct mtk_hcp *hcp_dev)
+{
+	enum isp71_rsv_mem_id_t id;
+	struct mtk_hcp_reserve_mblock *mblock;
+	unsigned int block_num;
+
+	mblock = mb;
+	block_num = hcp_dev->data->block_num;
+
+	/* release reserved memory */
+	for (id = 0; id < NUMS_MEM_ID; id++) {
+		if (mblock[id].is_dma_buf) {
+			switch (id) {
+			case IMG_MEM_FOR_HW_ID:
+				/*allocated at probe via dts*/
+				break;
+			case IMG_MEM_G_ID:
+				kref_put(&mblock[id].kref, gce_release);
+				break;
+			default:
+				/* free va */
+				//dma_buf_vunmap(mblock[id].d_buf, mblock[id].start_virt);
+				dma_buf_vunmap(mblock[id].d_buf, &(mblock[id].map));
+				/* free iova */
+				dma_buf_unmap_attachment(mblock[id].attach,
+				mblock[id].sgt, DMA_TO_DEVICE);
+				dma_buf_detach(mblock[id].d_buf,
+				mblock[id].attach);
+				dma_buf_put(mblock[id].d_buf);
+				// close fd in user space driver, you can't close fd in kernel site
+				// dma_heap_buffer_free(mblock[id].d_buf);
+				//dma_buf_put(my_dma_buf);
+				//also can use this api, but not recommended
+				mblock[id].mem_priv = NULL;
+				mblock[id].mmap_cnt = 0;
+				mblock[id].start_dma = 0x0;
+				mblock[id].start_virt = 0x0;
+				mblock[id].start_phys = 0x0;
+				mblock[id].d_buf = NULL;
+				mblock[id].fd = -1;
+				mblock[id].pIonHandle = NULL;
+				mblock[id].attach = NULL;
+				mblock[id].sgt = NULL;
+				break;
+			}
+		} else {
+			kfree(mblock[id].start_virt);
+			mblock[id].start_virt = 0x0;
+			mblock[id].start_phys = 0x0;
+			mblock[id].start_dma = 0x0;
+			mblock[id].mmap_cnt = 0;
+		}
+		pr_debug(
+			"%s: [HCP][mem_reserve-%d] phys:0x%llx, virt:0x%p, dma:0x%llx, size:0x%llx, is_dma_buf:%d, fd:%d\n",
+			__func__, id, isp71_get_reserve_mem_phys(id),
+			isp71_get_reserve_mem_virt(id),
+			isp71_get_reserve_mem_dma(id),
+			isp71_get_reserve_mem_size(id),
+			mblock[id].is_dma_buf,
+			isp71_get_reserve_mem_fd(id));
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(isp71_release_working_buffer);
+
+int isp71_get_init_info(struct img_init_info *info)
+{
+
+	if (!info) {
+		pr_info("%s:NULL info\n", __func__);
+		return -1;
+	}
+
+	info->hw_buf = isp71_get_reserve_mem_phys(DIP_MEM_FOR_HW_ID);
+	/*WPE:0, ADL:1, TRAW:2, DIP:3, PQDIP:4 */
+	info->module_info[0].c_wbuf =
+				isp71_get_reserve_mem_phys(WPE_MEM_C_ID);
+	info->module_info[0].c_wbuf_dma =
+				isp71_get_reserve_mem_dma(WPE_MEM_C_ID);
+	info->module_info[0].c_wbuf_sz =
+				isp71_get_reserve_mem_size(WPE_MEM_C_ID);
+	info->module_info[0].c_wbuf_fd =
+				isp71_get_reserve_mem_fd(WPE_MEM_C_ID);
+	info->module_info[0].t_wbuf =
+				isp71_get_reserve_mem_phys(WPE_MEM_T_ID);
+	info->module_info[0].t_wbuf_dma =
+				isp71_get_reserve_mem_dma(WPE_MEM_T_ID);
+	info->module_info[0].t_wbuf_sz =
+				isp71_get_reserve_mem_size(WPE_MEM_T_ID);
+	info->module_info[0].t_wbuf_fd =
+				isp71_get_reserve_mem_fd(WPE_MEM_T_ID);
+
+	// ADL
+	info->module_info[1].c_wbuf =
+				isp71_get_reserve_mem_phys(ADL_MEM_C_ID);
+	info->module_info[1].c_wbuf_dma =
+				isp71_get_reserve_mem_dma(ADL_MEM_C_ID);
+	info->module_info[1].c_wbuf_sz =
+				isp71_get_reserve_mem_size(ADL_MEM_C_ID);
+	info->module_info[1].c_wbuf_fd =
+				isp71_get_reserve_mem_fd(ADL_MEM_C_ID);
+	info->module_info[1].t_wbuf =
+				isp71_get_reserve_mem_phys(ADL_MEM_T_ID);
+	info->module_info[1].t_wbuf_dma =
+				isp71_get_reserve_mem_dma(ADL_MEM_T_ID);
+	info->module_info[1].t_wbuf_sz =
+				isp71_get_reserve_mem_size(ADL_MEM_T_ID);
+	info->module_info[1].t_wbuf_fd =
+				isp71_get_reserve_mem_fd(ADL_MEM_T_ID);
+
+	// TRAW
+	info->module_info[2].c_wbuf =
+				isp71_get_reserve_mem_phys(TRAW_MEM_C_ID);
+	info->module_info[2].c_wbuf_dma =
+				isp71_get_reserve_mem_dma(TRAW_MEM_C_ID);
+	info->module_info[2].c_wbuf_sz =
+				isp71_get_reserve_mem_size(TRAW_MEM_C_ID);
+	info->module_info[2].c_wbuf_fd =
+				isp71_get_reserve_mem_fd(TRAW_MEM_C_ID);
+	info->module_info[2].t_wbuf =
+				isp71_get_reserve_mem_phys(TRAW_MEM_T_ID);
+	info->module_info[2].t_wbuf_dma =
+				isp71_get_reserve_mem_dma(TRAW_MEM_T_ID);
+	info->module_info[2].t_wbuf_sz =
+				isp71_get_reserve_mem_size(TRAW_MEM_T_ID);
+	info->module_info[2].t_wbuf_fd =
+				isp71_get_reserve_mem_fd(TRAW_MEM_T_ID);
+
+	// DIP
+	info->module_info[3].c_wbuf =
+				isp71_get_reserve_mem_phys(DIP_MEM_C_ID);
+	info->module_info[3].c_wbuf_dma =
+				isp71_get_reserve_mem_dma(DIP_MEM_C_ID);
+	info->module_info[3].c_wbuf_sz =
+				isp71_get_reserve_mem_size(DIP_MEM_C_ID);
+	info->module_info[3].c_wbuf_fd =
+				isp71_get_reserve_mem_fd(DIP_MEM_C_ID);
+	info->module_info[3].t_wbuf =
+				isp71_get_reserve_mem_phys(DIP_MEM_T_ID);
+	info->module_info[3].t_wbuf_dma =
+				isp71_get_reserve_mem_dma(DIP_MEM_T_ID);
+	info->module_info[3].t_wbuf_sz =
+				isp71_get_reserve_mem_size(DIP_MEM_T_ID);
+	info->module_info[3].t_wbuf_fd =
+				isp71_get_reserve_mem_fd(DIP_MEM_T_ID);
+
+	// PQDIP
+	info->module_info[4].c_wbuf =
+				isp71_get_reserve_mem_phys(PQDIP_MEM_C_ID);
+	info->module_info[4].c_wbuf_dma =
+				isp71_get_reserve_mem_dma(PQDIP_MEM_C_ID);
+	info->module_info[4].c_wbuf_sz =
+				isp71_get_reserve_mem_size(PQDIP_MEM_C_ID);
+	info->module_info[4].c_wbuf_fd =
+			isp71_get_reserve_mem_fd(PQDIP_MEM_C_ID);
+	info->module_info[4].t_wbuf =
+				isp71_get_reserve_mem_phys(PQDIP_MEM_T_ID);
+	info->module_info[4].t_wbuf_dma =
+				isp71_get_reserve_mem_dma(PQDIP_MEM_T_ID);
+	info->module_info[4].t_wbuf_sz =
+				isp71_get_reserve_mem_size(PQDIP_MEM_T_ID);
+	info->module_info[4].t_wbuf_fd =
+				isp71_get_reserve_mem_fd(PQDIP_MEM_T_ID);
+
+	/*common*/
+	/* info->g_wbuf_fd = isp71_get_reserve_mem_fd(IMG_MEM_G_ID); */
+	info->g_wbuf_fd = isp71_get_reserve_mem_fd(IMG_MEM_G_ID);
+	info->g_wbuf = isp71_get_reserve_mem_phys(IMG_MEM_G_ID);
+	/*info->g_wbuf_sw = isp71_get_reserve_mem_virt(IMG_MEM_G_ID);*/
+	info->g_wbuf_sz = isp71_get_reserve_mem_size(IMG_MEM_G_ID);
+
+	return 0;
+}
+
+static int isp71_put_gce(void)
+{
+	kref_put(&mb[IMG_MEM_G_ID].kref, gce_release);
+	return 0;
+}
+
+static int isp71_get_gce(void)
+{
+	kref_get(&mb[IMG_MEM_G_ID].kref);
+	return 0;
+}
+
+struct mtk_hcp_data isp71_hcp_data = {
+	.mblock = isp71_reserve_mblock,
+	.block_num = ARRAY_SIZE(isp71_reserve_mblock),
+	.smblock = isp71_smvr_mblock,
+	.allocate = isp71_allocate_working_buffer,
+	.release = isp71_release_working_buffer,
+	.get_init_info = isp71_get_init_info,
+	.get_gce_virt = isp71_get_gce_virt,
+	.get_gce = isp71_get_gce,
+	.put_gce = isp71_put_gce,
+	.get_hwid_virt = isp71_get_hwid_virt,
+	.get_gce_mem_size = isp71_get_gce_mem_size,
+};
+
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/mtk-hcp/mtk-hcp_isp71.h b/drivers/media/platform/mediatek/isp/isp_7x/mtk-hcp/mtk-hcp_isp71.h
new file mode 100644
index 0000000000000000000000000000000000000000..8f22d9142ef1c6fdb82af5b8cc82f469a022196c
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/mtk-hcp/mtk-hcp_isp71.h
@@ -0,0 +1,37 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2019 MediaTek Inc.
+ */
+
+#ifndef MTK_HCP_ISP71_H
+#define MTK_HCP_ISP71_H
+
+#include "mtk-hcp.h"
+
+enum isp71_rsv_mem_id_t {
+	DIP_MEM_FOR_HW_ID,
+	IMG_MEM_FOR_HW_ID = DIP_MEM_FOR_HW_ID, /*shared buffer for ipi_param*/
+	/*need replace DIP_MEM_FOR_HW_ID & DIP_MEM_FOR_SW_ID*/
+	WPE_MEM_C_ID,	/*module cq buffer*/
+	WPE_MEM_T_ID,	/*module tdr buffer*/
+	TRAW_MEM_C_ID,	/*module cq buffer*/
+	TRAW_MEM_T_ID,	/*module tdr buffer*/
+	DIP_MEM_C_ID,	/*module cq buffer*/
+	DIP_MEM_T_ID,	/*module tdr buffer*/
+	PQDIP_MEM_C_ID,	/*module cq buffer*/
+	PQDIP_MEM_T_ID,	/*module tdr buffer*/
+	ADL_MEM_C_ID,	/*module cq buffer*/
+	ADL_MEM_T_ID,	/*module tdr buffer*/
+	IMG_MEM_G_ID,	/*gce cmd buffer*/
+	NUMS_MEM_ID,
+};
+
+int isp71_release_working_buffer(struct mtk_hcp *hcp_dev);
+int isp71_allocate_working_buffer(struct mtk_hcp *hcp_dev, unsigned int mode);
+int isp71_get_init_info(struct img_init_info *info);
+void *isp71_get_gce_virt(void);
+void *isp71_get_hwid_virt(void);
+
+extern struct mtk_hcp_data isp71_hcp_data;
+
+#endif /* _MTK_HCP_ISP71_H */
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/mtk-ipesys-me/Makefile b/drivers/media/platform/mediatek/isp/isp_7x/mtk-ipesys-me/Makefile
new file mode 100644
index 0000000000000000000000000000000000000000..89f75b3634fc692a2e60578c455cc1f475db7268
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/mtk-ipesys-me/Makefile
@@ -0,0 +1,31 @@
+# SPDX-License-Identifier: GPL-2.0
+#
+# Copyright (C) 2018 MediaTek Inc.
+#
+export MTK_IMGSYS_VER := $(subst ",,$(CONFIG_MTK_IMGSYS_VER)")
+MTK_IMGSYS_VER=71
+ccflags-y += -I$(srctree)/drivers/media/platform/mediatek/isp/isp_7x/mtk-hcp
+ccflags-$(CONFIG_MTK_CMDQ_MBOX_EXT) += -I$(srctree)/drivers/misc/mediatek/cmdq/mailbox/
+ccflags-y += -I$(srctree)/drivers/media/platform/mediatek/isp/isp_7x/imgsys/
+ccflags-y += -I$(srctree)/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/
+ccflags-y += -I$(srctree)/drivers/media/platform/mediatek/isp/isp_7x/imgsys/platforms/isp_71/
+ccflags-y += -I$(srctree)/drivers/iommu
+
+# Utilities to provide frame-based streaming model
+# with v4l2 user interfaces and alloc context managing
+# memory shared between ISP and coprocessor
+
+ifneq ($(wildcard $(srctree)/include/dt-bindings/memory/mt6983-larb-port.h),)
+	subdir-ccflags-y += -DTF_DUMP_71_1
+else ifneq ($(wildcard $(srctree)/include/dt-bindings/memory/mt6879-larb-port.h),)
+	subdir-ccflags-y += -DTF_DUMP_71_2
+endif
+#ifeq ($(MTK_IMGSYS_VER), 71)
+subdir-ccflags-y += -DIMGSYS_VER_ISP71
+#else ifeq ($(MTK_IMGSYS_VER), 70)
+#  subdir-ccflags-y += -DIMGSYS_VER_ISP70
+#endif
+$(info "ipesys, subdir-ccflags-y = $(subdir-ccflags-y)")
+
+obj-y += mtk-ipesys-me.o
+
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/mtk-ipesys-me/mtk-ipesys-me.c b/drivers/media/platform/mediatek/isp/isp_7x/mtk-ipesys-me/mtk-ipesys-me.c
new file mode 100644
index 0000000000000000000000000000000000000000..db4d7fc1f6505315933a6e777586d710549a79cd
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/mtk-ipesys-me/mtk-ipesys-me.c
@@ -0,0 +1,297 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2018 MediaTek Inc.
+ *
+ * Author: Frederic Chen <frederic.chen@mediatek.com>
+ *         Holmes Chiou <holmes.chiou@mediatek.com>
+ *
+ */
+#include <linux/platform_device.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/of_address.h>
+#include <dma-iommu.h>
+#include <linux/pm_runtime.h>
+#include <linux/remoteproc.h>
+#include <linux/dma-mapping.h>
+#include <linux/clk.h>
+#include <linux/of_platform.h>
+#include <linux/of_irq.h>
+#include <linux/of_address.h>
+#include <linux/clk.h>
+#include "mtk_imgsys-engine.h"
+#include "mtk-ipesys-me.h"
+#ifdef TF_DUMP
+#include "mtk_iommu_ext.h"
+#include <dt-bindings/memory/mt8195-larb-port.h>
+#endif
+//#include "iommu_debug.h"
+
+#define ME_CLK_CTRL
+
+#ifdef TF_DUMP_71_1
+#include <dt-bindings/memory/mt6983-larb-port.h>
+#elif defined(TF_DUMP_71_2)
+#include <dt-bindings/memory/mt6879-larb-port.h>
+#endif
+
+struct clk_bulk_data imgsys_isp7_me_clks[] = {
+	{ .id = "ME_CG_IPE" },
+	{ .id = "ME_CG_IPE_TOP" },
+	{ .id = "ME_CG" },
+	{ .id = "ME_CG_LARB12" },
+};
+
+static struct ipesys_me_device *me_dev;
+
+#if defined(TF_DUMP_71_1) || defined(TF_DUMP_71_2)
+int ME_TranslationFault_callback(int port, dma_addr_t mva, void *data)
+{
+
+	void __iomem *meRegBA = 0L;
+	unsigned int i;
+	/* iomap registers */
+	meRegBA = me_dev->regs;
+	if (!meRegBA) {
+		pr_info("%s Unable to ioremap dip registers\n",
+		__func__);
+	}
+	for (i = ME_CTL_OFFSET; i <= ME_CTL_OFFSET + ME_CTL_RANGE_TF; i += 0x10) {
+		pr_info("%s: 0x%08X %08X, %08X, %08X, %08X", __func__,
+		(unsigned int)(0x15320000 + i),
+		(unsigned int)ioread32((void *)(meRegBA + i)),
+		(unsigned int)ioread32((void *)(meRegBA + (i+0x4))),
+		(unsigned int)ioread32((void *)(meRegBA + (i+0x8))),
+		(unsigned int)ioread32((void *)(meRegBA + (i+0xC))));
+	}
+
+	return 1;
+}
+#endif
+
+void ipesys_me_set_initial_value(struct mtk_imgsys_dev *imgsys_dev)
+{
+	#ifdef ME_CLK_CTRL
+	int ret;
+	#endif
+
+	pr_info("%s: +\n", __func__);
+
+	#ifdef ME_CLK_CTRL
+	pm_runtime_get_sync(me_dev->dev);
+	ret = clk_bulk_prepare_enable(me_dev->me_clk.clk_num, me_dev->me_clk.clks);
+	if (ret) {
+		pr_info("failed to enable clock:%d\n", ret);
+		return;
+	}
+	#endif
+
+#if defined(TF_DUMP_71_1)
+	mtk_iommu_register_fault_callback(M4U_PORT_L12_IPE_ME_RDMA,
+	(mtk_iommu_fault_callback_t)ME_TranslationFault_callback,
+	NULL, false);
+	mtk_iommu_register_fault_callback(M4U_PORT_L12_IPE_ME_WDMA,
+	(mtk_iommu_fault_callback_t)ME_TranslationFault_callback,
+	NULL, false);
+#elif defined(TF_DUMP_71_2)
+	mtk_iommu_register_fault_callback(M4U_LARB12_PORT4,
+	(mtk_iommu_fault_callback_t)ME_TranslationFault_callback,
+	NULL, false);
+	mtk_iommu_register_fault_callback(M4U_LARB12_PORT5,
+	(mtk_iommu_fault_callback_t)ME_TranslationFault_callback,
+	NULL, false);
+#endif
+	pr_info("%s: -\n", __func__);
+}
+EXPORT_SYMBOL(ipesys_me_set_initial_value);
+
+void ipesys_me_uninit(struct mtk_imgsys_dev *imgsys_dev)
+{
+	pr_info("%s: +\n", __func__);
+	#ifdef ME_CLK_CTRL
+	pm_runtime_put_sync(me_dev->dev);
+	clk_bulk_disable_unprepare(me_dev->me_clk.clk_num, me_dev->me_clk.clks);
+	#endif
+	pr_info("%s: -\n", __func__);
+}
+EXPORT_SYMBOL(ipesys_me_uninit);
+
+void ipesys_me_debug_dump(struct mtk_imgsys_dev *imgsys_dev,
+			unsigned int engine)
+{
+	void __iomem *meRegBA = 0L;
+	unsigned int i;
+
+	pr_info("%s\n", __func__);
+	/* iomap registers */
+	meRegBA = me_dev->regs;
+	if (!meRegBA) {
+		dev_info(imgsys_dev->dev, "%s Unable to ioremap dip registers\n",
+			__func__);
+		dev_info(imgsys_dev->dev, "%s of_iomap fail, devnode(%s).\n",
+			__func__, imgsys_dev->dev->of_node->name);
+	}
+	dev_info(imgsys_dev->dev, "%s: dump me regs\n", __func__);
+	for (i = ME_CTL_OFFSET; i <= ME_CTL_OFFSET + ME_CTL_RANGE; i += 0x10) {
+		dev_info(imgsys_dev->dev, "%s: 0x%08X %08X, %08X, %08X, %08X", __func__,
+		(unsigned int)(0x15320000 + i),
+		(unsigned int)ioread32((void *)(meRegBA + i)),
+		(unsigned int)ioread32((void *)(meRegBA + (i+0x4))),
+		(unsigned int)ioread32((void *)(meRegBA + (i+0x8))),
+		(unsigned int)ioread32((void *)(meRegBA + (i+0xC))));
+	}
+}
+EXPORT_SYMBOL(ipesys_me_debug_dump);
+
+void ipesys_me_debug_dump_local(void)
+{
+	void __iomem *meRegBA = 0L;
+	unsigned int i;
+
+	pr_info("%s\n", __func__);
+	/* iomap registers */
+	meRegBA = me_dev->regs;
+	if (!meRegBA) {
+		pr_info("ipesys %s Unable to ioremap dip registers\n",
+			__func__);
+	}
+	pr_info("ipesys %s: dump me regs\n", __func__);
+	for (i = ME_CTL_OFFSET; i <= ME_CTL_OFFSET + ME_CTL_RANGE; i += 0x10) {
+		pr_info("ipesys %s: 0x%08X %08X, %08X, %08X, %08X", __func__,
+		(unsigned int)(0x15320000 + i),
+		(unsigned int)ioread32((void *)(meRegBA + i)),
+		(unsigned int)ioread32((void *)(meRegBA + (i+0x4))),
+		(unsigned int)ioread32((void *)(meRegBA + (i+0x8))),
+		(unsigned int)ioread32((void *)(meRegBA + (i+0xC))));
+	}
+}
+EXPORT_SYMBOL(ipesys_me_debug_dump_local);
+
+
+
+struct device *ipesys_me_getdev(void)
+{
+	return me_dev->dev;
+}
+
+static int mtk_ipesys_me_probe(struct platform_device *pdev)
+{
+	int ret = 0;
+	int ret_result = 0;
+	struct device_link *link;
+	int larbs_num;
+	struct device_node *larb_node;
+	struct platform_device *larb_pdev;
+
+	pr_info("mtk ipesys me probe start\n");
+	me_dev = devm_kzalloc(&pdev->dev, sizeof(struct ipesys_me_device) * 1, GFP_KERNEL);
+	if (!me_dev)
+		return -ENOMEM;
+
+	me_dev->dev = &pdev->dev;
+	me_dev->me_clk.clk_num = ARRAY_SIZE(imgsys_isp7_me_clks);
+	me_dev->me_clk.clks = imgsys_isp7_me_clks;
+	me_dev->regs = of_iomap(pdev->dev.of_node, 0);
+	ret = devm_clk_bulk_get(&pdev->dev, me_dev->me_clk.clk_num, me_dev->me_clk.clks);
+	if (ret) {
+		pr_info("failed to get raw clock:%d\n", ret);
+	}
+
+	larbs_num = of_count_phandle_with_args(pdev->dev.of_node,
+						"mediatek,larb", NULL);
+	dev_info(me_dev->dev, "%d larbs to be added", larbs_num);
+
+	larb_node = of_parse_phandle(pdev->dev.of_node, "mediatek,larb", 0);
+	if (!larb_node) {
+		dev_info(me_dev->dev,
+			"%s: larb node not found\n", __func__);
+	}
+
+	larb_pdev = of_find_device_by_node(larb_node);
+	if (!larb_pdev) {
+		of_node_put(larb_node);
+		dev_info(me_dev->dev,
+			"%s: larb device not found\n", __func__);
+	}
+	of_node_put(larb_node);
+
+	link = device_link_add(&pdev->dev, &larb_pdev->dev,
+			DL_FLAG_PM_RUNTIME | DL_FLAG_STATELESS);
+
+	if (!link)
+		dev_info(me_dev->dev, "unable to link SMI LARB\n");
+
+	pm_runtime_enable(&pdev->dev);
+
+	pr_info("mtk imgsys me probe done\n");
+
+	return ret_result;
+}
+
+static int mtk_ipesys_me_remove(struct platform_device *pdev)
+{
+	pm_runtime_disable(&pdev->dev);
+	devm_kfree(&pdev->dev, me_dev);
+
+	return 0;
+}
+
+static int __maybe_unused mtk_ipesys_me_runtime_suspend(struct device *dev)
+{
+	pr_info("%s\n", __func__);
+	return 0;
+}
+
+static int __maybe_unused mtk_ipesys_me_runtime_resume(struct device *dev)
+{
+	pr_info("%s\n", __func__);
+	return 0;
+}
+
+static int __maybe_unused mtk_ipesys_me_pm_suspend(struct device *dev)
+{
+	pr_info("%s\n", __func__);
+	return 0;
+}
+
+static int __maybe_unused mtk_ipesys_me_pm_resume(struct device *dev)
+{
+	pr_info("%s\n", __func__);
+	return 0;
+}
+
+static const struct dev_pm_ops mtk_ipesys_me_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(
+		mtk_ipesys_me_pm_suspend,
+		mtk_ipesys_me_pm_resume
+	)
+	SET_RUNTIME_PM_OPS(
+		mtk_ipesys_me_runtime_suspend,
+		mtk_ipesys_me_runtime_resume,
+		NULL
+	)
+};
+
+static const struct of_device_id mtk_ipesys_me_of_match[] = {
+	{ .compatible = "mediatek,ipesys-me", },
+	{}
+};
+MODULE_DEVICE_TABLE(of, mtk_ipesys_me_of_match);
+
+static struct platform_driver mtk_ipesys_me_driver = {
+	.probe   = mtk_ipesys_me_probe,
+	.remove  = mtk_ipesys_me_remove,
+	.driver  = {
+		.name = "camera-me",
+		.owner	= THIS_MODULE,
+		.pm = &mtk_ipesys_me_pm_ops,
+		.of_match_table = mtk_ipesys_me_of_match,
+	}
+};
+
+module_platform_driver(mtk_ipesys_me_driver);
+
+MODULE_AUTHOR("Marvin Lin <marvin.lin@mediatek.com>");
+MODULE_LICENSE("GPL v2");
+MODULE_DESCRIPTION("Mediatek ME driver");
+
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/mtk-ipesys-me/mtk-ipesys-me.h b/drivers/media/platform/mediatek/isp/isp_7x/mtk-ipesys-me/mtk-ipesys-me.h
new file mode 100644
index 0000000000000000000000000000000000000000..b6c79c3150ff2e1aa36a14e409eabd062e2a660a
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/mtk-ipesys-me/mtk-ipesys-me.h
@@ -0,0 +1,37 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2018 MediaTek Inc.
+ *
+ * Author: Frederic Chen <frederic.chen@mediatek.com>
+ *
+ */
+
+#ifndef _MTK_IMGSYS_ME_H_
+#define _MTK_IMGSYS_ME_H_
+
+#include "mtk_imgsys-dev.h"
+
+struct ipesys_me_clocks {
+	struct clk_bulk_data *clks;
+	unsigned int clk_num;
+};
+
+struct ipesys_me_device {
+	void __iomem *regs;
+	struct device *dev;
+	struct ipesys_me_clocks me_clk;
+};
+
+#define ME_CTL_OFFSET      0x0000
+#define ME_CTL_RANGE       0xA10
+#define ME_CTL_RANGE_TF    0x120
+
+
+void ipesys_me_set_initial_value(struct mtk_imgsys_dev *imgsys_dev);
+void ipesys_me_debug_dump(struct mtk_imgsys_dev *imgsys_dev,
+							unsigned int engine);
+void ipesys_me_uninit(struct mtk_imgsys_dev *imgsys_dev);
+struct device *ipesys_me_getdev(void);
+
+
+#endif /* _MTK_IMGSYS_ME_H_ */
diff --git a/drivers/media/platform/mediatek/isp/isp_7x/mtk_camera-v4l2-controls.h b/drivers/media/platform/mediatek/isp/isp_7x/mtk_camera-v4l2-controls.h
new file mode 100644
index 0000000000000000000000000000000000000000..73dae6d5835eba8959dad84ea04758972b5c610b
--- /dev/null
+++ b/drivers/media/platform/mediatek/isp/isp_7x/mtk_camera-v4l2-controls.h
@@ -0,0 +1,161 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2022 MediaTek Inc.
+ */
+
+#ifndef __MTK_CAMERA_V4l2_CONTROLS_H
+#define __MTK_CAMERA_V4l2_CONTROLS_H
+
+#include <linux/videodev2.h>
+#include <linux/v4l2-controls.h>
+
+/* Allowed value of V4L2_CID_MTK_CAM_RAW_PATH_SELECT */
+#define V4L2_MTK_CAM_RAW_PATH_SELECT_BPC	1
+#define V4L2_MTK_CAM_RAW_PATH_SELECT_FUS	3
+#define V4L2_MTK_CAM_RAW_PATH_SELECT_DGN	4
+#define V4L2_MTK_CAM_RAW_PATH_SELECT_LSC	5
+#define V4L2_MTK_CAM_RAW_PATH_SELECT_LTM	7
+
+/* exposure for m-stream */
+struct mtk_cam_shutter_gain {
+	__u32 shutter;
+	__u32 gain;
+};
+
+/* multiple exposure for m-stream(2 exposures) */
+struct mtk_cam_mstream_exposure {
+	struct mtk_cam_shutter_gain exposure[2];
+	unsigned int valid;
+};
+
+#define V4L2_MBUS_FRAMEFMT_PAD_ENABLE  BIT(1)
+
+#define MEDIA_BUS_FMT_MTISP_SBGGR10_1X10		0x8001
+#define MEDIA_BUS_FMT_MTISP_SBGGR12_1X12		0x8002
+#define MEDIA_BUS_FMT_MTISP_SBGGR14_1X14		0x8003
+#define MEDIA_BUS_FMT_MTISP_SGBRG10_1X10		0x8004
+#define MEDIA_BUS_FMT_MTISP_SGBRG12_1X12		0x8005
+#define MEDIA_BUS_FMT_MTISP_SGBRG14_1X14		0x8006
+#define MEDIA_BUS_FMT_MTISP_SGRBG10_1X10		0x8007
+#define MEDIA_BUS_FMT_MTISP_SGRBG12_1X12		0x8008
+#define MEDIA_BUS_FMT_MTISP_SGRBG14_1X14		0x8009
+#define MEDIA_BUS_FMT_MTISP_SRGGB10_1X10		0x800a
+#define MEDIA_BUS_FMT_MTISP_SRGGB12_1X12		0x800b
+#define MEDIA_BUS_FMT_MTISP_SRGGB14_1X14		0x800c
+#define MEDIA_BUS_FMT_MTISP_BAYER8_UFBC			0x800d
+#define MEDIA_BUS_FMT_MTISP_BAYER10_UFBC		0x800e
+#define MEDIA_BUS_FMT_MTISP_BAYER12_UFBC		0x8010
+#define MEDIA_BUS_FMT_MTISP_BAYER14_UFBC		0x8011
+#define MEDIA_BUS_FMT_MTISP_BAYER16_UFBC		0x8012
+#define MEDIA_BUS_FMT_MTISP_NV12			0x8013
+#define MEDIA_BUS_FMT_MTISP_NV21			0x8014
+#define MEDIA_BUS_FMT_MTISP_NV12_10			0x8015
+#define MEDIA_BUS_FMT_MTISP_NV21_10			0x8016
+#define MEDIA_BUS_FMT_MTISP_NV12_10P			0x8017
+#define MEDIA_BUS_FMT_MTISP_NV21_10P			0x8018
+#define MEDIA_BUS_FMT_MTISP_NV12_12			0x8019
+#define MEDIA_BUS_FMT_MTISP_NV21_12			0x801a
+#define MEDIA_BUS_FMT_MTISP_NV12_12P			0x801b
+#define MEDIA_BUS_FMT_MTISP_NV21_12P			0x801c
+#define MEDIA_BUS_FMT_MTISP_YUV420			0x801d
+#define MEDIA_BUS_FMT_MTISP_NV12_UFBC			0x801e
+#define MEDIA_BUS_FMT_MTISP_NV21_UFBC			0x8020
+#define MEDIA_BUS_FMT_MTISP_NV12_10_UFBC		0x8021
+#define MEDIA_BUS_FMT_MTISP_NV21_10_UFBC		0x8022
+#define MEDIA_BUS_FMT_MTISP_NV12_12_UFBC		0x8023
+#define MEDIA_BUS_FMT_MTISP_NV21_12_UFBC		0x8024
+#define MEDIA_BUS_FMT_MTISP_NV16			0x8025
+#define MEDIA_BUS_FMT_MTISP_NV61			0x8026
+#define MEDIA_BUS_FMT_MTISP_NV16_10			0x8027
+#define MEDIA_BUS_FMT_MTISP_NV61_10			0x8028
+#define MEDIA_BUS_FMT_MTISP_NV16_10P			0x8029
+#define MEDIA_BUS_FMT_MTISP_NV61_10P			0x802a
+
+#define MTK_CAM_RESOURCE_DEFAULT	0xFFFF
+
+/*
+ * struct mtk_cam_resource_sensor - sensor resoruces for format negotiation
+ *
+ */
+struct mtk_cam_resource_sensor {
+	struct v4l2_fract interval;
+	__u32 hblank;
+	__u32 vblank;
+	__u64 pixel_rate;
+	__u64 cust_pixel_rate;
+};
+
+/*
+ * struct mtk_cam_resource_raw - MTK camsys raw resoruces for format negotiation
+ *
+ * @feature: value of V4L2_CID_MTK_CAM_FEATURE the user want to check the
+ *		  resource with. If it is used in set CTRL, we will apply the value
+ *		  to V4L2_CID_MTK_CAM_FEATURE ctrl directly.
+ * @strategy: indicate the order of multiple raws, binning or DVFS to be selected
+ *	      when doing format negotiation of raw's source pads (output pads).
+ *	      Please pass MTK_CAM_RESOURCE_DEFAULT if you want camsys driver to
+ *	      determine it.
+ * @raw_max: indicate the max number of raw to be used for the raw pipeline.
+ *	     Please pass MTK_CAM_RESOURCE_DEFAULT if you want camsys driver to
+ *	     determine it.
+ * @raw_min: indicate the max number of raw to be used for the raw pipeline.
+ *	     Please pass MTK_CAM_RESOURCE_DEFAULT if you want camsys driver to
+ *	     determine it.
+ * @raw_used: The number of raw used. The used don't need to writ this failed,
+ *	      the driver always updates the field.
+ * @bin: indicate if the driver should enable the bining or not. The driver
+ *	 update the field depanding the hardware supporting status. Please pass
+ *	 MTK_CAM_RESOURCE_DEFAULT if you want camsys driver to determine it.
+ * @path_sel: indicate the user selected raw path. The driver
+ *	      update the field depanding the hardware supporting status. Please
+ *	      pass MTK_CAM_RESOURCE_DEFAULT if you want camsys driver to
+ *	      determine it.
+ * @pixel_mode: the pixel mode driver used in the raw pipeline. It is written by
+ *		driver only.
+ * @throughput: the throughput be used in the raw pipeline. It is written by
+ *		driver only.
+ *
+ */
+struct mtk_cam_resource_raw {
+	__s64	feature;
+	__u16	strategy;
+	__u8	raw_max;
+	__u8	raw_min;
+	__u8	raw_used;
+	__u8	bin;
+	__u8	path_sel;
+	__u8	pixel_mode;
+	__u64	throughput;
+};
+
+/*
+ * struct mtk_cam_resource - MTK camsys resoruces for format negotiation
+ *
+ * @sink_fmt: sink_fmt pad's format, it must be return by g_fmt or s_fmt
+ *		from driver.
+ * @sensor_res: senor information to calculate the required resource, it is
+ *		read-only and camsys driver will not change it.
+ * @raw_res: user hint and resource negotiation result.
+ * @status:	TBC
+ *
+ */
+struct mtk_cam_resource {
+	__u64 sink_fmt;
+	struct mtk_cam_resource_sensor sensor_res;
+	struct mtk_cam_resource_raw raw_res;
+	__u8 status;
+};
+
+/**
+ * struct mtk_cam_pde_info - PDE module information for raw
+ *
+ * @pdo_max_size: the max pdo size of pde sensor.
+ * @pdi_max_size: the max pdi size of pde sensor or max pd table size.
+ * @pd_table_offset: the offest of meta config for pd table content.
+ */
+struct mtk_cam_pde_info {
+	__u32 pdo_max_size;
+	__u32 pdi_max_size;
+	__u32 pd_table_offset;
+};
+#endif /* __MTK_CAMERA_V4l2_CONTROLS_H */
diff --git a/drivers/media/platform/mediatek/jpeg/mtk_jpeg_core.c b/drivers/media/platform/mediatek/jpeg/mtk_jpeg_core.c
index 7194f88edc0fb41c037b7fe91a80f5df6b755b03..a6ab85d995f8acf35c576d8dbf7573bb5a040ccf 100644
--- a/drivers/media/platform/mediatek/jpeg/mtk_jpeg_core.c
+++ b/drivers/media/platform/mediatek/jpeg/mtk_jpeg_core.c
@@ -1031,6 +1031,7 @@ static void mtk_jpeg_dec_device_run(void *priv)
 	spin_lock_irqsave(&jpeg->hw_lock, flags);
 	mtk_jpeg_dec_reset(jpeg->reg_base);
 	mtk_jpeg_dec_set_config(jpeg->reg_base,
+				jpeg->support_34bit,
 				&jpeg_src_buf->dec_param,
 				jpeg_src_buf->bs_size,
 				&bs,
@@ -1318,6 +1319,14 @@ static int mtk_jpeg_probe(struct platform_device *pdev)
 		return -EINVAL;
 	}
 
+	ret = of_property_read_u32(pdev->dev.of_node, "mediatek,34bits",
+			&jpeg->support_34bit);
+	if (ret != 0) {
+		dev_info(&pdev->dev, "default for 34bits");
+		jpeg->support_34bit = 1;
+	}
+	dev_info(&pdev->dev, "use 34bits: %d", jpeg->support_34bit);
+
 	if (!jpeg->variant->multi_core) {
 		ret = mtk_jpeg_single_core_init(pdev, jpeg);
 		if (ret) {
@@ -1566,7 +1575,8 @@ static irqreturn_t mtk_jpeg_enc_done(struct mtk_jpeg_dev *jpeg)
 	src_buf = v4l2_m2m_src_buf_remove(ctx->fh.m2m_ctx);
 	dst_buf = v4l2_m2m_dst_buf_remove(ctx->fh.m2m_ctx);
 
-	result_size = mtk_jpeg_enc_get_file_size(jpeg->reg_base);
+	result_size = mtk_jpeg_enc_get_file_size(jpeg->reg_base,
+						 ctx->jpeg->support_34bit);
 	vb2_set_plane_payload(&dst_buf->vb2_buf, 0, result_size);
 
 	buf_state = VB2_BUF_STATE_DONE;
@@ -1766,6 +1776,7 @@ static void mtk_jpegdec_worker(struct work_struct *work)
 	ctx->total_frame_num++;
 	mtk_jpeg_dec_reset(comp_jpeg[hw_id]->reg_base);
 	mtk_jpeg_dec_set_config(comp_jpeg[hw_id]->reg_base,
+				jpeg->support_34bit,
 				&jpeg_src_buf->dec_param,
 				jpeg_src_buf->bs_size,
 				&bs,
diff --git a/drivers/media/platform/mediatek/jpeg/mtk_jpeg_core.h b/drivers/media/platform/mediatek/jpeg/mtk_jpeg_core.h
index 8ba6e757e11aa93e154c2fa9c7965cd494753765..8237c07ac743b10c6540ad2fe1dffaa830073d7e 100644
--- a/drivers/media/platform/mediatek/jpeg/mtk_jpeg_core.h
+++ b/drivers/media/platform/mediatek/jpeg/mtk_jpeg_core.h
@@ -209,6 +209,7 @@ struct mtk_jpegdec_comp_dev {
  * @reg_decbase:	jpg decode register base addr
  * @dec_hw_dev:	jpg decode hardware device
  * @hw_index:		jpg hw index
+ * @support_34bit:	flag to check if support dma_address 34bit
  */
 struct mtk_jpeg_dev {
 	struct mutex		lock;
@@ -231,6 +232,7 @@ struct mtk_jpeg_dev {
 	void __iomem *reg_decbase[MTK_JPEGDEC_HW_MAX];
 	struct mtk_jpegdec_comp_dev *dec_hw_dev[MTK_JPEGDEC_HW_MAX];
 	atomic_t hw_index;
+	u32 support_34bit;
 };
 
 /**
diff --git a/drivers/media/platform/mediatek/jpeg/mtk_jpeg_dec_hw.c b/drivers/media/platform/mediatek/jpeg/mtk_jpeg_dec_hw.c
index baa7be58ce691d62abdfdab23e2ca795bd3ef9c4..b913fed06c92892c11441e8f7979fbc7995952c8 100644
--- a/drivers/media/platform/mediatek/jpeg/mtk_jpeg_dec_hw.c
+++ b/drivers/media/platform/mediatek/jpeg/mtk_jpeg_dec_hw.c
@@ -270,7 +270,7 @@ void mtk_jpeg_dec_reset(void __iomem *base)
 EXPORT_SYMBOL_GPL(mtk_jpeg_dec_reset);
 
 static void mtk_jpeg_dec_set_brz_factor(void __iomem *base, u8 yscale_w,
-					u8 yscale_h, u8 uvscale_w, u8 uvscale_h)
+				u8 yscale_h, u8 uvscale_w, u8 uvscale_h)
 {
 	u32 val;
 
@@ -279,23 +279,43 @@ static void mtk_jpeg_dec_set_brz_factor(void __iomem *base, u8 yscale_w,
 	writel(val, base + JPGDEC_REG_BRZ_FACTOR);
 }
 
-static void mtk_jpeg_dec_set_dst_bank0(void __iomem *base, u32 addr_y,
-				       u32 addr_u, u32 addr_v)
+static void mtk_jpeg_dec_set_dst_bank0(void __iomem *base, u32 support_34bit,
+		dma_addr_t addr_y, dma_addr_t addr_u, dma_addr_t addr_v)
 {
+	u32 val;
+
 	mtk_jpeg_verify_align(addr_y, 16, JPGDEC_REG_DEST_ADDR0_Y);
 	writel(addr_y, base + JPGDEC_REG_DEST_ADDR0_Y);
 	mtk_jpeg_verify_align(addr_u, 16, JPGDEC_REG_DEST_ADDR0_U);
 	writel(addr_u, base + JPGDEC_REG_DEST_ADDR0_U);
 	mtk_jpeg_verify_align(addr_v, 16, JPGDEC_REG_DEST_ADDR0_V);
 	writel(addr_v, base + JPGDEC_REG_DEST_ADDR0_V);
+	if (support_34bit) {
+		val = upper_32_bits(addr_y) & 0x3;
+		writel(val, base + JPGDEC_REG_DEST_ADDR0_Y_EXT);
+		val = upper_32_bits(addr_u) & 0x3;
+		writel(val, base + JPGDEC_REG_DEST_ADDR0_U_EXT);
+		val = upper_32_bits(addr_v) & 0x3;
+		writel(val, base + JPGDEC_REG_DEST_ADDR0_V_EXT);
+	}
 }
 
-static void mtk_jpeg_dec_set_dst_bank1(void __iomem *base, u32 addr_y,
-				       u32 addr_u, u32 addr_v)
+static void mtk_jpeg_dec_set_dst_bank1(void __iomem *base, u32 support_34bit,
+		dma_addr_t addr_y, dma_addr_t addr_u, dma_addr_t addr_v)
 {
+	u32 val;
+
 	writel(addr_y, base + JPGDEC_REG_DEST_ADDR1_Y);
 	writel(addr_u, base + JPGDEC_REG_DEST_ADDR1_U);
 	writel(addr_v, base + JPGDEC_REG_DEST_ADDR1_V);
+	if (support_34bit) {
+		val = upper_32_bits(addr_y) & 0x3;
+		writel(val, base + JPGDEC_REG_DEST_ADDR1_Y_EXT);
+		val = upper_32_bits(addr_u) & 0x3;
+		writel(val, base + JPGDEC_REG_DEST_ADDR1_U_EXT);
+		val = upper_32_bits(addr_v) & 0x3;
+		writel(val, base + JPGDEC_REG_DEST_ADDR1_V_EXT);
+	}
 }
 
 static void mtk_jpeg_dec_set_mem_stride(void __iomem *base, u32 stride_y,
@@ -322,18 +342,31 @@ static void mtk_jpeg_dec_set_dec_mode(void __iomem *base, u32 mode)
 	writel(mode & 0x03, base + JPGDEC_REG_OPERATION_MODE);
 }
 
-static void mtk_jpeg_dec_set_bs_write_ptr(void __iomem *base, u32 ptr)
+static void mtk_jpeg_dec_set_bs_write_ptr(void __iomem *base,
+				u32 support_34bit, dma_addr_t ptr)
 {
+	u32 val;
+
 	mtk_jpeg_verify_align(ptr, 16, JPGDEC_REG_FILE_BRP);
 	writel(ptr, base + JPGDEC_REG_FILE_BRP);
+	if (support_34bit) {
+		val = upper_32_bits(ptr) & 0x3;
+		writel(val, base + JPGDEC_REG_FILE_BRP_EXT);
+	}
 }
 
-static void mtk_jpeg_dec_set_bs_info(void __iomem *base, u32 addr, u32 size,
-				     u32 bitstream_size)
+static void mtk_jpeg_dec_set_bs_info(void __iomem *base, u32 support_34bit,
+		dma_addr_t addr, u32 size, u32 bitstream_size)
 {
+	u32 val;
+
 	mtk_jpeg_verify_align(addr, 16, JPGDEC_REG_FILE_ADDR);
 	mtk_jpeg_verify_align(size, 128, JPGDEC_REG_FILE_TOTAL_SIZE);
 	writel(addr, base + JPGDEC_REG_FILE_ADDR);
+	if (support_34bit) {
+		val = upper_32_bits(addr) & 0x3;
+		writel(val, base + JPGDEC_REG_FILE_ADDR_EXT);
+	}
 	writel(size, base + JPGDEC_REG_FILE_TOTAL_SIZE);
 	writel(bitstream_size, base + JPGDEC_REG_BIT_STREAM_SIZE);
 }
@@ -404,6 +437,7 @@ static void mtk_jpeg_dec_set_sampling_factor(void __iomem *base, u32 comp_num,
 }
 
 void mtk_jpeg_dec_set_config(void __iomem *base,
+			     u32 support_34bits,
 			     struct mtk_jpeg_dec_param *cfg,
 			     u32 bitstream_size,
 			     struct mtk_jpeg_bs *bs,
@@ -413,8 +447,9 @@ void mtk_jpeg_dec_set_config(void __iomem *base,
 	mtk_jpeg_dec_set_dec_mode(base, 0);
 	mtk_jpeg_dec_set_comp0_du(base, cfg->unit_num);
 	mtk_jpeg_dec_set_total_mcu(base, cfg->total_mcu);
-	mtk_jpeg_dec_set_bs_info(base, bs->str_addr, bs->size, bitstream_size);
-	mtk_jpeg_dec_set_bs_write_ptr(base, bs->end_addr);
+	mtk_jpeg_dec_set_bs_info(base, support_34bits, bs->str_addr,
+				       bs->size, bitstream_size);
+	mtk_jpeg_dec_set_bs_write_ptr(base, support_34bits, bs->end_addr);
 	mtk_jpeg_dec_set_du_membership(base, cfg->membership, 1,
 				       (cfg->comp_num == 1) ? 1 : 0);
 	mtk_jpeg_dec_set_comp_id(base, cfg->comp_id[0], cfg->comp_id[1],
@@ -432,9 +467,9 @@ void mtk_jpeg_dec_set_config(void __iomem *base,
 				    cfg->mem_stride[1]);
 	mtk_jpeg_dec_set_img_stride(base, cfg->img_stride[0],
 				    cfg->img_stride[1]);
-	mtk_jpeg_dec_set_dst_bank0(base, fb->plane_addr[0],
+	mtk_jpeg_dec_set_dst_bank0(base, support_34bits, fb->plane_addr[0],
 				   fb->plane_addr[1], fb->plane_addr[2]);
-	mtk_jpeg_dec_set_dst_bank1(base, 0, 0, 0);
+	mtk_jpeg_dec_set_dst_bank1(base, support_34bits, 0, 0, 0);
 	mtk_jpeg_dec_set_dma_group(base, cfg->dma_mcu, cfg->dma_group,
 				   cfg->dma_last_mcu);
 	mtk_jpeg_dec_set_pause_mcu_idx(base, cfg->total_mcu);
diff --git a/drivers/media/platform/mediatek/jpeg/mtk_jpeg_dec_hw.h b/drivers/media/platform/mediatek/jpeg/mtk_jpeg_dec_hw.h
index 8c31c6b124178c61c6ace7d8d98966a8647553f4..14c6e6cb387d5179810ba2fc4ca8b306dbca9fec 100644
--- a/drivers/media/platform/mediatek/jpeg/mtk_jpeg_dec_hw.h
+++ b/drivers/media/platform/mediatek/jpeg/mtk_jpeg_dec_hw.h
@@ -71,6 +71,7 @@ int mtk_jpeg_dec_fill_param(struct mtk_jpeg_dec_param *param);
 u32 mtk_jpeg_dec_get_int_status(void __iomem *dec_reg_base);
 u32 mtk_jpeg_dec_enum_result(u32 irq_result);
 void mtk_jpeg_dec_set_config(void __iomem *base,
+			     u32 support_34bits,
 			     struct mtk_jpeg_dec_param *cfg,
 			     u32 bitstream_size,
 			     struct mtk_jpeg_bs *bs,
diff --git a/drivers/media/platform/mediatek/jpeg/mtk_jpeg_dec_reg.h b/drivers/media/platform/mediatek/jpeg/mtk_jpeg_dec_reg.h
index 27b7711ca341998c8d89b99740dde82a1e8c87a5..e94f52de7c690cae1c67304c27686eea096f8e8c 100644
--- a/drivers/media/platform/mediatek/jpeg/mtk_jpeg_dec_reg.h
+++ b/drivers/media/platform/mediatek/jpeg/mtk_jpeg_dec_reg.h
@@ -46,5 +46,13 @@
 #define JPGDEC_REG_INTERRUPT_STATUS	0x0274
 #define JPGDEC_REG_STATUS		0x0278
 #define JPGDEC_REG_BIT_STREAM_SIZE	0x0344
+#define JPGDEC_REG_DEST_ADDR0_Y_EXT	0x0360
+#define JPGDEC_REG_DEST_ADDR0_U_EXT	0x0364
+#define JPGDEC_REG_DEST_ADDR0_V_EXT	0x0368
+#define JPGDEC_REG_DEST_ADDR1_Y_EXT	0x036c
+#define JPGDEC_REG_DEST_ADDR1_U_EXT	0x0370
+#define JPGDEC_REG_DEST_ADDR1_V_EXT	0x0374
+#define JPGDEC_REG_FILE_ADDR_EXT	0x0378
+#define JPGDEC_REG_FILE_BRP_EXT		0x037c
 
 #endif /* _MTK_JPEG_REG_H */
diff --git a/drivers/media/platform/mediatek/jpeg/mtk_jpeg_enc_hw.c b/drivers/media/platform/mediatek/jpeg/mtk_jpeg_enc_hw.c
index 03ee8f93bd4672ebad49275947cbc8dabef2eadb..50b8480809c01eb7591c0c82e9ba2e8ecfc5b2e9 100644
--- a/drivers/media/platform/mediatek/jpeg/mtk_jpeg_enc_hw.c
+++ b/drivers/media/platform/mediatek/jpeg/mtk_jpeg_enc_hw.c
@@ -62,9 +62,14 @@ void mtk_jpeg_enc_reset(void __iomem *base)
 }
 EXPORT_SYMBOL_GPL(mtk_jpeg_enc_reset);
 
-u32 mtk_jpeg_enc_get_file_size(void __iomem *base)
+u32 mtk_jpeg_enc_get_file_size(void __iomem *base, u32 support_34bit)
 {
-	return readl(base + JPEG_ENC_DMA_ADDR0) -
+	u32 value = 1;
+
+	if (support_34bit)
+		value = 4;
+
+	return readl(base + JPEG_ENC_DMA_ADDR0) * value -
 	       readl(base + JPEG_ENC_DST_ADDR0);
 }
 EXPORT_SYMBOL_GPL(mtk_jpeg_enc_get_file_size);
@@ -75,6 +80,9 @@ void mtk_jpeg_enc_start(void __iomem *base)
 
 	value = readl(base + JPEG_ENC_CTRL);
 	value |= JPEG_ENC_CTRL_INT_EN_BIT | JPEG_ENC_CTRL_ENABLE_BIT;
+	value |= JPEG_ENC_CTRL_RDMA_PADDING_EN;
+	value |= JPEG_ENC_CTRL_RDMA_RIGHT_PADDING_EN;
+	value &= ~JPEG_ENC_CTRL_RDMA_PADDING_0_EN;
 	writel(value, base + JPEG_ENC_CTRL);
 }
 EXPORT_SYMBOL_GPL(mtk_jpeg_enc_start);
@@ -84,14 +92,25 @@ void mtk_jpeg_set_enc_src(struct mtk_jpeg_ctx *ctx,  void __iomem *base,
 {
 	int i;
 	dma_addr_t dma_addr;
+	u32 val;
+	u32 support_34bit = ctx->jpeg->support_34bit;
 
 	for (i = 0; i < src_buf->num_planes; i++) {
 		dma_addr = vb2_dma_contig_plane_dma_addr(src_buf, i) +
 			   src_buf->planes[i].data_offset;
-		if (!i)
+		if (!i) {
 			writel(dma_addr, base + JPEG_ENC_SRC_LUMA_ADDR);
-		else
+			if (support_34bit) {
+				val = upper_32_bits(dma_addr) & 0x3;
+				writel(val, base + JPEG_ENC_SRC_LUMA_ADDR_EXT);
+			}
+		} else {
 			writel(dma_addr, base + JPEG_ENC_SRC_CHROMA_ADDR);
+			if (support_34bit) {
+				val = upper_32_bits(dma_addr) & 0x3;
+				writel(val, base + JPEG_ENC_SRC_CHROMA_ADDR_EXT);
+			}
+		}
 	}
 }
 EXPORT_SYMBOL_GPL(mtk_jpeg_set_enc_src);
@@ -103,6 +122,8 @@ void mtk_jpeg_set_enc_dst(struct mtk_jpeg_ctx *ctx, void __iomem *base,
 	size_t size;
 	u32 dma_addr_offset;
 	u32 dma_addr_offsetmask;
+	u32 val;
+	u32 support_34bit = ctx->jpeg->support_34bit;
 
 	dma_addr = vb2_dma_contig_plane_dma_addr(dst_buf, 0);
 	dma_addr_offset = ctx->enable_exif ? MTK_JPEG_MAX_EXIF_SIZE : 0;
@@ -112,7 +133,15 @@ void mtk_jpeg_set_enc_dst(struct mtk_jpeg_ctx *ctx, void __iomem *base,
 	writel(dma_addr_offset & ~0xf, base + JPEG_ENC_OFFSET_ADDR);
 	writel(dma_addr_offsetmask & 0xf, base + JPEG_ENC_BYTE_OFFSET_MASK);
 	writel(dma_addr & ~0xf, base + JPEG_ENC_DST_ADDR0);
+	if (support_34bit) {
+		val = upper_32_bits(dma_addr) & 0x3;
+		writel(val, base + JPEG_ENC_DEST_ADDR0_EXT);
+	}
 	writel((dma_addr + size) & ~0xf, base + JPEG_ENC_STALL_ADDR0);
+	if (support_34bit) {
+		val = upper_32_bits(dma_addr + size) & 0x3;
+		writel(val, base + JPEG_ENC_STALL_ADDR0_EXT);
+	}
 }
 EXPORT_SYMBOL_GPL(mtk_jpeg_set_enc_dst);
 
@@ -278,7 +307,8 @@ static irqreturn_t mtk_jpegenc_hw_irq_handler(int irq, void *priv)
 	if (!(irq_status & JPEG_ENC_INT_STATUS_DONE))
 		dev_warn(jpeg->dev, "Jpg Enc occurs unknown Err.");
 
-	result_size = mtk_jpeg_enc_get_file_size(jpeg->reg_base);
+	result_size = mtk_jpeg_enc_get_file_size(jpeg->reg_base,
+			ctx->jpeg->support_34bit);
 	vb2_set_plane_payload(&dst_buf->vb2_buf, 0, result_size);
 	buf_state = VB2_BUF_STATE_DONE;
 	v4l2_m2m_buf_done(src_buf, buf_state);
diff --git a/drivers/media/platform/mediatek/jpeg/mtk_jpeg_enc_hw.h b/drivers/media/platform/mediatek/jpeg/mtk_jpeg_enc_hw.h
index 61c60e4e58ea925275f489648360b0ad48588584..2f03a1a5de9867f68b8cd3cf9c71ca2bb75d98b8 100644
--- a/drivers/media/platform/mediatek/jpeg/mtk_jpeg_enc_hw.h
+++ b/drivers/media/platform/mediatek/jpeg/mtk_jpeg_enc_hw.h
@@ -68,6 +68,15 @@
 #define JPEG_ENC_DCM_CTRL		0x300
 #define JPEG_ENC_CODEC_SEL		0x314
 #define JPEG_ENC_ULTRA_THRES		0x318
+#define JPEG_ENC_SRC_LUMA_ADDR_EXT      0x584
+#define JPEG_ENC_SRC_CHROMA_ADDR_EXT    0x588
+#define JPEG_ENC_Q_TBL_ADDR_EXT         0x58C
+#define JPEG_ENC_DEST_ADDR0_EXT         0x590
+#define JPEG_ENC_STALL_ADDR0_EXT        0x594
+
+#define JPEG_ENC_CTRL_RDMA_PADDING_EN           (1 << 20)
+#define JPEG_ENC_CTRL_RDMA_RIGHT_PADDING_EN     (1 << 29)
+#define JPEG_ENC_CTRL_RDMA_PADDING_0_EN         (1 << 30)
 
 /**
  * struct mtk_jpeg_enc_qlt - JPEG encoder quality data
@@ -80,7 +89,7 @@ struct mtk_jpeg_enc_qlt {
 };
 
 void mtk_jpeg_enc_reset(void __iomem *base);
-u32 mtk_jpeg_enc_get_file_size(void __iomem *base);
+u32 mtk_jpeg_enc_get_file_size(void __iomem *base, u32 support_34bit);
 void mtk_jpeg_enc_start(void __iomem *enc_reg_base);
 void mtk_jpeg_set_enc_src(struct mtk_jpeg_ctx *ctx,  void __iomem *base,
 			  struct vb2_buffer *src_buf);
diff --git a/drivers/media/platform/mediatek/mdp3/Kconfig b/drivers/media/platform/mediatek/mdp3/Kconfig
index 602329c447501d2f04491263de5243eb2bcd5ff3..50ae07b75b5f25eb917139f806fed1302a5041e4 100644
--- a/drivers/media/platform/mediatek/mdp3/Kconfig
+++ b/drivers/media/platform/mediatek/mdp3/Kconfig
@@ -3,13 +3,15 @@ config VIDEO_MEDIATEK_MDP3
 	tristate "MediaTek MDP v3 driver"
 	depends on MTK_IOMMU || COMPILE_TEST
 	depends on VIDEO_DEV
+	depends on ARCH_MEDIATEK || COMPILE_TEST
 	depends on HAS_DMA
 	depends on REMOTEPROC
-	depends on MTK_MMSYS
-	depends on MTK_CMDQ
-	depends on MTK_SCP
 	select VIDEOBUF2_DMA_CONTIG
 	select V4L2_MEM2MEM_DEV
+	select MTK_MMSYS
+	select VIDEO_MEDIATEK_VPU
+	select MTK_CMDQ
+	select MTK_SCP
 	default n
 	help
 	    It is a v4l2 driver and present in MediaTek MT8183 SoC.
diff --git a/drivers/media/platform/mediatek/vcodec/common/mtk_vcodec_util.c b/drivers/media/platform/mediatek/vcodec/common/mtk_vcodec_util.c
index 9ce34a3b5ee67daf5ae6a575159ac4f8e5467565..79c99433b76a7ded736642dd9a236b2a983377bc 100644
--- a/drivers/media/platform/mediatek/vcodec/common/mtk_vcodec_util.c
+++ b/drivers/media/platform/mediatek/vcodec/common/mtk_vcodec_util.c
@@ -45,7 +45,7 @@ int mtk_vcodec_write_vdecsys(struct mtk_vcodec_dec_ctx *ctx, unsigned int reg,
 }
 EXPORT_SYMBOL(mtk_vcodec_write_vdecsys);
 
-int mtk_vcodec_mem_alloc(void *priv, struct mtk_vcodec_mem *mem)
+static int mtk_vcodec_mem_dec_alloc(void *priv, struct mtk_vcodec_mem *mem)
 {
 	enum mtk_instance_type inst_type = *((unsigned int *)priv);
 	struct platform_device *plat_dev;
@@ -76,9 +76,39 @@ int mtk_vcodec_mem_alloc(void *priv, struct mtk_vcodec_mem *mem)
 
 	return 0;
 }
+
+static int mtk_vcodec_mem_enc_alloc(void *priv, struct mtk_vcodec_mem *mem)
+{
+	unsigned long size = mem->size;
+	struct mtk_vcodec_enc_ctx *ctx = priv;
+	struct device *dev = &ctx->dev->plat_dev->dev;
+
+	mem->va = dma_alloc_coherent(dev, size, &mem->dma_addr, GFP_KERNEL);
+	if (!mem->va) {
+		mtk_v4l2_venc_err(ctx, "%s dma_alloc size=%ld failed!", dev_name(dev), size);
+		return -ENOMEM;
+	}
+
+	mtk_v4l2_venc_dbg(3, ctx, "[%d]  - va      = %p", ctx->id, mem->va);
+	mtk_v4l2_venc_dbg(3, ctx, "[%d]  - dma     = 0x%lx", ctx->id,
+			  (unsigned long)mem->dma_addr);
+	mtk_v4l2_venc_dbg(3, ctx, "[%d]    size = 0x%lx", ctx->id, size);
+
+	return 0;
+}
+
+int mtk_vcodec_mem_alloc(void *priv, struct mtk_vcodec_mem *mem)
+{
+	enum mtk_instance_type inst_type = *((unsigned int *)priv);
+
+	if (inst_type == MTK_INST_ENCODER)
+		return mtk_vcodec_mem_enc_alloc(priv, mem);
+	else
+		return mtk_vcodec_mem_dec_alloc(priv, mem);
+}
 EXPORT_SYMBOL(mtk_vcodec_mem_alloc);
 
-void mtk_vcodec_mem_free(void *priv, struct mtk_vcodec_mem *mem)
+static void mtk_vcodec_mem_dec_free(void *priv, struct mtk_vcodec_mem *mem)
 {
 	enum mtk_instance_type inst_type = *((unsigned int *)priv);
 	struct platform_device *plat_dev;
@@ -111,6 +141,38 @@ void mtk_vcodec_mem_free(void *priv, struct mtk_vcodec_mem *mem)
 	mem->dma_addr = 0;
 	mem->size = 0;
 }
+
+static void mtk_vcodec_mem_enc_free(void *priv, struct mtk_vcodec_mem *mem)
+{
+	unsigned long size = mem->size;
+	struct mtk_vcodec_enc_ctx *ctx = priv;
+	struct device *dev = &ctx->dev->plat_dev->dev;
+
+	if (!mem->va) {
+		mtk_v4l2_venc_err(ctx, "%s dma_free size=%ld failed!", dev_name(dev), size);
+		return;
+	}
+
+	mtk_v4l2_venc_dbg(3, ctx, "[%d]  - va      = %p", ctx->id, mem->va);
+	mtk_v4l2_venc_dbg(3, ctx, "[%d]  - dma     = 0x%lx", ctx->id,
+			  (unsigned long)mem->dma_addr);
+	mtk_v4l2_venc_dbg(3, ctx, "[%d]    size = 0x%lx", ctx->id, size);
+
+	dma_free_coherent(dev, size, mem->va, mem->dma_addr);
+	mem->va = NULL;
+	mem->dma_addr = 0;
+	mem->size = 0;
+}
+
+void mtk_vcodec_mem_free(void *priv, struct mtk_vcodec_mem *mem)
+{
+	enum mtk_instance_type inst_type = *((unsigned int *)priv);
+
+	if (inst_type == MTK_INST_ENCODER)
+		mtk_vcodec_mem_enc_free(priv, mem);
+	else
+		mtk_vcodec_mem_dec_free(priv, mem);
+}
 EXPORT_SYMBOL(mtk_vcodec_mem_free);
 
 void *mtk_vcodec_get_hw_dev(struct mtk_vcodec_dec_dev *dev, int hw_idx)
diff --git a/drivers/media/platform/mediatek/vcodec/decoder/vdec/vdec_vp9_req_lat_if.c b/drivers/media/platform/mediatek/vcodec/decoder/vdec/vdec_vp9_req_lat_if.c
index e393e3e668f8f50c9179ca29ca920d38da2cd892..a75a9eace3e0491814ae956552f9e3f8076c7fed 100644
--- a/drivers/media/platform/mediatek/vcodec/decoder/vdec/vdec_vp9_req_lat_if.c
+++ b/drivers/media/platform/mediatek/vcodec/decoder/vdec/vdec_vp9_req_lat_if.c
@@ -1075,7 +1075,7 @@ static int vdec_vp9_slice_setup_tile_buffer(struct vdec_vp9_slice_instance *inst
 	unsigned int mi_row;
 	unsigned int mi_col;
 	unsigned int offset;
-	unsigned int pa;
+	unsigned long pa;
 	unsigned int size;
 	struct vdec_vp9_slice_tiles *tiles;
 	unsigned char *pos;
@@ -1110,7 +1110,7 @@ static int vdec_vp9_slice_setup_tile_buffer(struct vdec_vp9_slice_instance *inst
 	pos = va + offset;
 	end = va + bs->size;
 	/* truncated */
-	pa = (unsigned int)bs->dma_addr + offset;
+	pa = (unsigned long)bs->dma_addr + offset;
 	tb = instance->tile.va;
 	for (i = 0; i < rows; i++) {
 		for (j = 0; j < cols; j++) {
diff --git a/drivers/media/platform/mediatek/vcodec/encoder/venc/venc_h264_if.c b/drivers/media/platform/mediatek/vcodec/encoder/venc/venc_h264_if.c
index a68dac72c4e426d6b3f7d64b0199ea1bebb67f17..385bcc0d14f37915a91d382c21a556ad0d21d2f7 100644
--- a/drivers/media/platform/mediatek/vcodec/encoder/venc/venc_h264_if.c
+++ b/drivers/media/platform/mediatek/vcodec/encoder/venc/venc_h264_if.c
@@ -597,6 +597,11 @@ static int h264_enc_init(struct mtk_vcodec_enc_ctx *ctx)
 	inst->hw_base = mtk_vcodec_get_reg_addr(inst->ctx->dev->reg_base, VENC_SYS);
 
 	ret = vpu_enc_init(&inst->vpu_inst);
+	if (!inst->vpu_inst.vsi) {
+		mtk_venc_err(ctx, "share buffer is NULL");
+		kfree(inst);
+		return -EFAULT;
+	}
 
 	if (MTK_ENC_IOVA_IS_34BIT(ctx))
 		inst->vsi_34 = (struct venc_h264_vsi_34 *)inst->vpu_inst.vsi;
diff --git a/drivers/media/platform/mediatek/vcodec/encoder/venc/venc_vp8_if.c b/drivers/media/platform/mediatek/vcodec/encoder/venc/venc_vp8_if.c
index 05abca91e742983749ebd732d2defcbf28a91b3f..23ca0d93324f9f128115f6c328b245b359c6ac97 100644
--- a/drivers/media/platform/mediatek/vcodec/encoder/venc/venc_vp8_if.c
+++ b/drivers/media/platform/mediatek/vcodec/encoder/venc/venc_vp8_if.c
@@ -326,6 +326,11 @@ static int vp8_enc_init(struct mtk_vcodec_enc_ctx *ctx)
 	inst->hw_base = mtk_vcodec_get_reg_addr(inst->ctx->dev->reg_base, VENC_LT_SYS);
 
 	ret = vpu_enc_init(&inst->vpu_inst);
+	if (!inst->vpu_inst.vsi) {
+		mtk_venc_err(ctx, "share buffer is NULL");
+		kfree(inst);
+		return -EFAULT;
+	}
 
 	inst->vsi = (struct venc_vp8_vsi *)inst->vpu_inst.vsi;
 
diff --git a/drivers/media/v4l2-core/v4l2-ioctl.c b/drivers/media/v4l2-core/v4l2-ioctl.c
old mode 100644
new mode 100755
index 2e5dc75e2dfdad6ed1847eeeade58725caf99fc8..415b113b22caef5b707eeb1a1d16bc764ece31b0
--- a/drivers/media/v4l2-core/v4l2-ioctl.c
+++ b/drivers/media/v4l2-core/v4l2-ioctl.c
@@ -1332,6 +1332,14 @@ static void v4l_fill_fmtdesc(struct v4l2_fmtdesc *fmt)
 	case V4L2_PIX_FMT_YVYU:		descr = "YVYU 4:2:2"; break;
 	case V4L2_PIX_FMT_UYVY:		descr = "UYVY 4:2:2"; break;
 	case V4L2_PIX_FMT_VYUY:		descr = "VYUY 4:2:2"; break;
+	case V4L2_PIX_FMT_YUYV10:	descr = "YUYV 4:2:2 10 bits"; break;
+	case V4L2_PIX_FMT_YVYU10:	descr = "YVYU 4:2:2 10 bits"; break;
+	case V4L2_PIX_FMT_UYVY10:	descr = "UYVY 4:2:2 10 bits"; break;
+	case V4L2_PIX_FMT_VYUY10:	descr = "VYUY 4:2:2 10 bits"; break;
+	case V4L2_PIX_FMT_YUYV12:	descr = "YUYV 4:2:2 12 bits"; break;
+	case V4L2_PIX_FMT_YVYU12:	descr = "YVYU 4:2:2 12 bits"; break;
+	case V4L2_PIX_FMT_UYVY12:	descr = "UYVY 4:2:2 12 bits"; break;
+	case V4L2_PIX_FMT_VYUY12:	descr = "VYUY 4:2:2 12 bits"; break;
 	case V4L2_PIX_FMT_YUV422P:	descr = "Planar YUV 4:2:2"; break;
 	case V4L2_PIX_FMT_YUV411P:	descr = "Planar YUV 4:1:1"; break;
 	case V4L2_PIX_FMT_Y41P:		descr = "YUV 4:1:1 (Packed)"; break;
@@ -1361,6 +1369,14 @@ static void v4l_fill_fmtdesc(struct v4l2_fmtdesc *fmt)
 	case V4L2_PIX_FMT_NV12_16L16:	descr = "Y/UV 4:2:0 (16x16 Linear)"; break;
 	case V4L2_PIX_FMT_NV12_32L32:   descr = "Y/UV 4:2:0 (32x32 Linear)"; break;
 	case V4L2_PIX_FMT_P010_4L4:	descr = "10-bit Y/UV 4:2:0 (4x4 Linear)"; break;
+	case V4L2_PIX_FMT_NV12_10:	descr = "Y/CbCr 4:2:0 10 bits"; break;
+	case V4L2_PIX_FMT_NV21_10:	descr = "Y/CrCb 4:2:0 10 bits"; break;
+	case V4L2_PIX_FMT_NV16_10:	descr = "Y/CbCr 4:2:2 10 bits"; break;
+	case V4L2_PIX_FMT_NV61_10:	descr = "Y/CrCb 4:2:2 10 bits"; break;
+	case V4L2_PIX_FMT_NV12_12:	descr = "Y/CbCr 4:2:0 12 bits"; break;
+	case V4L2_PIX_FMT_NV21_12:	descr = "Y/CrCb 4:2:0 12 bits"; break;
+	case V4L2_PIX_FMT_NV16_12:	descr = "Y/CbCr 4:2:2 12 bits"; break;
+	case V4L2_PIX_FMT_NV61_12:	descr = "Y/CrCb 4:2:2 12 bits"; break;
 	case V4L2_PIX_FMT_NV12M:	descr = "Y/UV 4:2:0 (N-C)"; break;
 	case V4L2_PIX_FMT_NV21M:	descr = "Y/VU 4:2:0 (N-C)"; break;
 	case V4L2_PIX_FMT_NV16M:	descr = "Y/UV 4:2:2 (N-C)"; break;
@@ -1428,6 +1444,67 @@ static void v4l_fill_fmtdesc(struct v4l2_fmtdesc *fmt)
 	case V4L2_PIX_FMT_MM21:		descr = "Mediatek 8-bit Block Format"; break;
 	case V4L2_PIX_FMT_HSV24:	descr = "24-bit HSV 8-8-8"; break;
 	case V4L2_PIX_FMT_HSV32:	descr = "32-bit XHSV 8-8-8-8"; break;
+	case V4L2_PIX_FMT_MTISP_SBGGR8: descr = "8-bit Bayer BGGR MTISP Packed"; break;
+	case V4L2_PIX_FMT_MTISP_SGBRG8: descr = "8-bit Bayer GBRG MTISP Packed"; break;
+	case V4L2_PIX_FMT_MTISP_SGRBG8: descr = "8-bit Bayer GRBG MTISP Packed"; break;
+	case V4L2_PIX_FMT_MTISP_SRGGB8: descr = "8-bit Bayer RGGB MTISP Packed"; break;
+	case V4L2_PIX_FMT_MTISP_SBGGR10: descr = "10-bit Bayer BGGR MTISP Packed"; break;
+	case V4L2_PIX_FMT_MTISP_SGBRG10: descr = "10-bit Bayer GBRG MTISP Packed"; break;
+	case V4L2_PIX_FMT_MTISP_SGRBG10: descr = "10-bit Bayer GRBG MTISP Packed"; break;
+	case V4L2_PIX_FMT_MTISP_SRGGB10: descr = "10-bit Bayer RGGB MTISP Packed"; break;
+	case V4L2_PIX_FMT_MTISP_SBGGR12: descr = "12-bit Bayer BGGR MTISP Packed"; break;
+	case V4L2_PIX_FMT_MTISP_SGBRG12: descr = "12-bit Bayer GBRG MTISP Packed"; break;
+	case V4L2_PIX_FMT_MTISP_SGRBG12: descr = "12-bit Bayer GRBG MTISP Packed"; break;
+	case V4L2_PIX_FMT_MTISP_SRGGB12: descr = "12-bit Bayer RGGB MTISP Packed"; break;
+	case V4L2_PIX_FMT_MTISP_SBGGR14: descr = "14-bit Bayer BGGR MTISP Packed"; break;
+	case V4L2_PIX_FMT_MTISP_SGBRG14: descr = "14-bit Bayer GBRG MTISP Packed"; break;
+	case V4L2_PIX_FMT_MTISP_SGRBG14: descr = "14-bit Bayer GRBG MTISP Packed"; break;
+	case V4L2_PIX_FMT_MTISP_SRGGB14: descr = "14-bit Bayer RGGB MTISP Packed"; break;
+	case V4L2_PIX_FMT_MTISP_SBGGR8F: descr = "8-bit Full-G Bayer BGGR Packed"; break;
+	case V4L2_PIX_FMT_MTISP_SGBRG8F: descr = "8-bit Full-G Bayer GBRG Packed"; break;
+	case V4L2_PIX_FMT_MTISP_SGRBG8F: descr = "8-bit Full-G Bayer GRBG Packed"; break;
+	case V4L2_PIX_FMT_MTISP_SRGGB8F: descr = "8-bit Full-G Bayer RGGB Packed"; break;
+	case V4L2_PIX_FMT_MTISP_SBGGR10F: descr = "10-bit Full-G Bayer BGGR Packed"; break;
+	case V4L2_PIX_FMT_MTISP_SGBRG10F: descr = "10-bit Full-G Bayer GBRG Packed"; break;
+	case V4L2_PIX_FMT_MTISP_SGRBG10F: descr = "10-bit Full-G Bayer GRBG Packed"; break;
+	case V4L2_PIX_FMT_MTISP_SRGGB10F: descr = "10-bit Full-G Bayer RGGB Packed"; break;
+	case V4L2_PIX_FMT_MTISP_SBGGR12F: descr = "12-bit Full-G Bayer BGGR Packed"; break;
+	case V4L2_PIX_FMT_MTISP_SGBRG12F: descr = "12-bit Full-G Bayer GBRG Packed"; break;
+	case V4L2_PIX_FMT_MTISP_SGRBG12F: descr = "12-bit Full-G Bayer GRBG Packed"; break;
+	case V4L2_PIX_FMT_MTISP_SRGGB12F: descr = "12-bit Full-G Bayer RGGB Packed"; break;
+	case V4L2_PIX_FMT_MTISP_SBGGR14F: descr = "14-bit Full-G Bayer BGGR Packed"; break;
+	case V4L2_PIX_FMT_MTISP_SGBRG14F: descr = "14-bit Full-G Bayer GBRG Packed"; break;
+	case V4L2_PIX_FMT_MTISP_SGRBG14F: descr = "14-bit Full-G Bayer GRBG Packed"; break;
+	case V4L2_PIX_FMT_MTISP_SRGGB14F: descr = "14-bit Full-G Bayer RGGB Packed"; break;
+	case V4L2_PIX_FMT_MTISP_NV12_10P: descr = "Y/CbCr 4:2:0 10 bits packed"; break;
+	case V4L2_PIX_FMT_MTISP_NV21_10P: descr = "Y/CrCb 4:2:0 10 bits packed"; break;
+	case V4L2_PIX_FMT_MTISP_NV16_10P: descr = "Y/CbCr 4:2:2 10 bits packed"; break;
+	case V4L2_PIX_FMT_MTISP_NV61_10P: descr = "Y/CrCb 4:2:2 10 bits packed"; break;
+	case V4L2_PIX_FMT_MTISP_YUYV10P: descr = "YUYV 4:2:2 10 bits packed"; break;
+	case V4L2_PIX_FMT_MTISP_YVYU10P: descr = "YVYU 4:2:2 10 bits packed"; break;
+	case V4L2_PIX_FMT_MTISP_UYVY10P: descr = "UYVY 4:2:2 10 bits packed"; break;
+	case V4L2_PIX_FMT_MTISP_VYUY10P: descr = "VYUY 4:2:2 10 bits packed"; break;
+	case V4L2_PIX_FMT_MTISP_NV12_12P: descr = "Y/CbCr 4:2:0 12 bits packed"; break;
+	case V4L2_PIX_FMT_MTISP_NV21_12P: descr = "Y/CrCb 4:2:0 12 bits packed"; break;
+	case V4L2_PIX_FMT_MTISP_NV16_12P: descr = "Y/CbCr 4:2:2 12 bits packed"; break;
+	case V4L2_PIX_FMT_MTISP_NV61_12P: descr = "Y/CrCb 4:2:2 12 bits packed"; break;
+	case V4L2_PIX_FMT_MTISP_YUYV12P: descr = "YUYV 4:2:2 12 bits packed"; break;
+	case V4L2_PIX_FMT_MTISP_YVYU12P: descr = "YVYU 4:2:2 12 bits packed"; break;
+	case V4L2_PIX_FMT_MTISP_UYVY12P: descr = "UYVY 4:2:2 12 bits packed"; break;
+	case V4L2_PIX_FMT_MTISP_VYUY12P: descr = "VYUY 4:2:2 12 bits packed"; break;
+	case V4L2_PIX_FMT_MTISP_NV12_UFBC: descr = "YCbCr 420 8 bits compress"; break;
+	case V4L2_PIX_FMT_MTISP_NV21_UFBC: descr = "YCrCb 420 8 bits compress"; break;
+	case V4L2_PIX_FMT_MTISP_NV12_10_UFBC: descr = "YCbCr 420 10 bits compress"; break;
+        case V4L2_PIX_FMT_MTISP_NV21_10_UFBC: descr = "YCrCb 420 10 bits compress"; break;
+	case V4L2_PIX_FMT_MTISP_NV12_12_UFBC: descr = "YCbCr 420 12 bits compress"; break;
+	case V4L2_PIX_FMT_MTISP_NV21_12_UFBC: descr = "YCrCb 420 12 bits compress"; break;
+	case V4L2_PIX_FMT_MTISP_BAYER8_UFBC: descr = "RAW 8 bits compress"; break;
+	case V4L2_PIX_FMT_MTISP_BAYER10_UFBC: descr = "RAW 10 bits compress"; break;
+	case V4L2_PIX_FMT_MTISP_BAYER12_UFBC: descr = "RAW 12 bits compress"; break;
+	case V4L2_PIX_FMT_MTISP_BAYER14_UFBC: descr = "RAW 14 bits compress"; break;
+	case V4L2_PIX_FMT_MTISP_SGRB8F: descr = "8-bit 3 plane GRB Packed"; break;
+	case V4L2_PIX_FMT_MTISP_SGRB10F: descr = "10-bit 3 plane GRB Packed"; break;
+	case V4L2_PIX_FMT_MTISP_SGRB12F: descr = "12-bit 3 plane GRB Packed"; break;
 	case V4L2_SDR_FMT_CU8:		descr = "Complex U8"; break;
 	case V4L2_SDR_FMT_CU16LE:	descr = "Complex U16LE"; break;
 	case V4L2_SDR_FMT_CS8:		descr = "Complex S8"; break;
diff --git a/drivers/misc/eeprom/at24.c b/drivers/misc/eeprom/at24.c
old mode 100644
new mode 100755
index 938c4f41b98c7a2eaacb88ab5fc287c99df07f56..b7f3729f5490ae556a84d40cb3e6f8d973fe399d
--- a/drivers/misc/eeprom/at24.c
+++ b/drivers/misc/eeprom/at24.c
@@ -600,6 +600,7 @@ static int at24_probe(struct i2c_client *client)
 	i2c_fn_i2c = i2c_check_functionality(client->adapter, I2C_FUNC_I2C);
 	i2c_fn_block = i2c_check_functionality(client->adapter,
 					       I2C_FUNC_SMBUS_WRITE_I2C_BLOCK);
+	dev_info(dev, "at24_probe +++\n");
 
 	cdata = at24_get_chip_data(dev);
 	if (IS_ERR(cdata))
@@ -719,6 +720,13 @@ static int at24_probe(struct i2c_client *client)
 	 */
 	nvmem_config.id = NVMEM_DEVID_AUTO;
 
+	if (device_property_present(dev, "device-id")) {
+		u32 device_id = 0;
+		err = device_property_read_u32(dev, "device-id", &device_id);
+		if (!err)
+			nvmem_config.id = device_id;
+	}
+
 	if (device_property_present(dev, "label")) {
 		err = device_property_read_string(dev, "label",
 						  &nvmem_config.name);
@@ -788,6 +796,7 @@ static int at24_probe(struct i2c_client *client)
 		dev_info(dev, "%u byte %s EEPROM, read-only\n",
 			 byte_len, client->name);
 
+	dev_info(dev, "at24_probe ---\n");
 	return 0;
 }
 
diff --git a/drivers/net/wireless/mediatek/mt76/mt7921/mcu.c b/drivers/net/wireless/mediatek/mt76/mt7921/mcu.c
index 10dda1693d7dbe6647ad21c0a6a78324f437ab70..799f4c887797769e6afd7adb5c4cde941f8b9062 100644
--- a/drivers/net/wireless/mediatek/mt76/mt7921/mcu.c
+++ b/drivers/net/wireless/mediatek/mt76/mt7921/mcu.c
@@ -473,6 +473,7 @@ static int mt7921_load_firmware(struct mt7921_dev *dev)
 
 #ifdef CONFIG_PM
 	dev->mt76.hw->wiphy->wowlan = &mt76_connac_wowlan_support;
+	device_init_wakeup(dev->mt76.dev, true);
 #endif /* CONFIG_PM */
 
 	dev_dbg(dev->mt76.dev, "Firmware init done\n");
diff --git a/drivers/opp/core.c b/drivers/opp/core.c
index a4461c0663af9a72a56a4a8da215b4e24ab01489..0da8a53fb298a4961f47b64549d93f69ce9870f0 100644
--- a/drivers/opp/core.c
+++ b/drivers/opp/core.c
@@ -2945,6 +2945,75 @@ int dev_pm_opp_adjust_voltage(struct device *dev, unsigned long freq,
 }
 EXPORT_SYMBOL_GPL(dev_pm_opp_adjust_voltage);
 
+int dev_pm_opp_adjust_voltage_supply(struct device *dev, unsigned long freq,
+			      unsigned long u_volt, unsigned long u_volt_min,
+			      unsigned long u_volt_max, unsigned int index)
+
+{
+	struct opp_table *opp_table;
+	struct dev_pm_opp *tmp_opp, *opp = ERR_PTR(-ENODEV);
+	int r = 0;
+
+	/* Find the opp_table */
+	opp_table = _find_opp_table(dev);
+	if (IS_ERR(opp_table)) {
+		r = PTR_ERR(opp_table);
+		dev_warn(dev, "%s: Device OPP not found (%d)\n", __func__, r);
+		return r;
+	}
+
+	if (!assert_single_clk(opp_table)) {
+		r = -EINVAL;
+		goto put_table;
+	}
+
+	mutex_lock(&opp_table->lock);
+
+	/* Do we have the frequency? */
+	list_for_each_entry(tmp_opp, &opp_table->opp_list, node) {
+		if (tmp_opp->rates[0] == freq) {
+			opp = tmp_opp;
+			break;
+		}
+	}
+
+	if (IS_ERR(opp)) {
+		r = PTR_ERR(opp);
+		goto adjust_unlock;
+	}
+
+	if (index >= opp->opp_table->regulator_count) {
+		dev_err(dev, "%s: Invalid supply index: %u\n", __func__, index);
+		goto adjust_unlock;
+	}
+
+	/* Is update really needed? */
+	if (opp->supplies[index].u_volt == u_volt)
+		goto adjust_unlock;
+
+	opp->supplies[index].u_volt = u_volt;
+	opp->supplies[index].u_volt_min = u_volt_min;
+	opp->supplies[index].u_volt_max = u_volt_max;
+
+	dev_pm_opp_get(opp);
+	mutex_unlock(&opp_table->lock);
+
+	/* Notify the voltage change of the OPP */
+	blocking_notifier_call_chain(&opp_table->head, OPP_EVENT_ADJUST_VOLTAGE,
+				     opp);
+
+	dev_pm_opp_put(opp);
+	goto put_table;
+
+adjust_unlock:
+	mutex_unlock(&opp_table->lock);
+put_table:
+	dev_pm_opp_put_opp_table(opp_table);
+	return r;
+}
+EXPORT_SYMBOL_GPL(dev_pm_opp_adjust_voltage_supply);
+
+
 /**
  * dev_pm_opp_enable() - Enable a specific OPP
  * @dev:	device for which we do this operation
diff --git a/drivers/pci/controller/pcie-mediatek-gen3.c b/drivers/pci/controller/pcie-mediatek-gen3.c
index b8612ce5f4d0cf82c23198bf5b802e09d1412145..f5e55e5542e563f60f376066cbac87bd6e92eadb 100644
--- a/drivers/pci/controller/pcie-mediatek-gen3.c
+++ b/drivers/pci/controller/pcie-mediatek-gen3.c
@@ -8,6 +8,8 @@
 
 #include <linux/clk.h>
 #include <linux/delay.h>
+#include <linux/gpio.h>
+#include <linux/gpio/consumer.h>
 #include <linux/iopoll.h>
 #include <linux/irq.h>
 #include <linux/irqchip/chained_irq.h>
@@ -15,11 +17,13 @@
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/msi.h>
+#include <linux/of_gpio.h>
 #include <linux/pci.h>
 #include <linux/phy/phy.h>
 #include <linux/platform_device.h>
 #include <linux/pm_domain.h>
 #include <linux/pm_runtime.h>
+#include <linux/regulator/consumer.h>
 #include <linux/reset.h>
 
 #include "../pci.h"
@@ -100,6 +104,13 @@
 #define PCIE_ATR_TLP_TYPE_MEM		PCIE_ATR_TLP_TYPE(0)
 #define PCIE_ATR_TLP_TYPE_IO		PCIE_ATR_TLP_TYPE(2)
 
+/* Downstream Component power supplies used by MediaTek PCIe */
+static const char *const dsc_power_supplies[] = {
+	"pcie1v8",
+	"pcie3v3",
+	"pcie12v",
+};
+
 /**
  * struct mtk_msi_set - MSI information for each set
  * @base: IO mapped register base
@@ -122,6 +133,10 @@ struct mtk_msi_set {
  * @phy: PHY controller block
  * @clks: PCIe clocks
  * @num_clks: PCIe clocks count for this port
+ * @supplies: Downstream Component power supplies
+ * @num_supplies: Downstream Component power supplies count
+ * @dsc_reset: The GPIO pin to reset Downstream component
+ * @dsc_reset_delay_ms: Delay in ms before the deassertion of reset GPIO
  * @irq: PCIe controller interrupt number
  * @saved_irq_state: IRQ enable state saved at suspend time
  * @irq_lock: lock protecting IRQ register access
@@ -141,6 +156,10 @@ struct mtk_gen3_pcie {
 	struct phy *phy;
 	struct clk_bulk_data *clks;
 	int num_clks;
+	struct regulator_bulk_data *supplies;
+	int num_supplies;
+	struct gpio_desc *dsc_reset;
+	u32 dsc_reset_delay_ms;
 
 	int irq;
 	u32 saved_irq_state;
@@ -763,7 +782,9 @@ static int mtk_pcie_parse_port(struct mtk_gen3_pcie *pcie)
 	struct device *dev = pcie->dev;
 	struct platform_device *pdev = to_platform_device(dev);
 	struct resource *regs;
-	int ret;
+	enum of_gpio_flags flags;
+	enum gpiod_flags dsc_reset_init_flags;
+	int ret, i;
 
 	regs = platform_get_resource_byname(pdev, IORESOURCE_MEM, "pcie-mac");
 	if (!regs)
@@ -809,14 +830,105 @@ static int mtk_pcie_parse_port(struct mtk_gen3_pcie *pcie)
 		return pcie->num_clks;
 	}
 
+	pcie->num_supplies = ARRAY_SIZE(dsc_power_supplies);
+	pcie->supplies = devm_kcalloc(dev, pcie->num_supplies,
+				      sizeof(*pcie->supplies),
+				      GFP_KERNEL);
+	if (!pcie->supplies)
+		return -ENOMEM;
+
+	for (i = 0; i < pcie->num_supplies; i++)
+		pcie->supplies[i].supply = dsc_power_supplies[i];
+
+	ret = devm_regulator_bulk_get(dev, pcie->num_supplies, pcie->supplies);
+	if (ret)
+		return ret;
+
+	ret = of_get_named_gpio_flags(dev->of_node, "dsc-reset-gpios", 0,
+				      &flags);
+	if (ret < 0) {
+		if (ret == -EPROBE_DEFER)
+			return ret;
+
+		/*
+		 * It's okay that the reset GPIO of a downstream component not
+		 * defined in related devicetree node since it's an optional
+		 * property.
+		 */
+		return 0;
+	}
+
+	dsc_reset_init_flags = (flags & OF_GPIO_ACTIVE_LOW) ? GPIOD_OUT_HIGH :
+			       GPIOD_OUT_LOW;
+	pcie->dsc_reset = devm_gpiod_get_optional(dev, "dsc-reset",
+						  dsc_reset_init_flags);
+	if (IS_ERR(pcie->dsc_reset)) {
+		ret = PTR_ERR(pcie->dsc_reset);
+		if (ret != -EPROBE_DEFER)
+			dev_err(dev, "failed to request DSC reset gpio\n");
+
+		return ret;
+	}
+
+	ret = of_property_read_u32(dev->of_node, "dsc-reset-msleep",
+				   &pcie->dsc_reset_delay_ms);
+	if (ret) {
+		dev_info(dev, "Failed to get delay time of DSC, set it to default 5ms\n");
+		pcie->dsc_reset_delay_ms = 5;
+	}
+
 	return 0;
 }
 
+static int mtk_pcie_dsc_power_up(struct mtk_gen3_pcie *pcie)
+{
+	struct device *dev = pcie->dev;
+	int ret;
+
+	/* Assert Downstream Component reset */
+	if (pcie->dsc_reset)
+		gpiod_set_value_cansleep(pcie->dsc_reset, 1);
+
+	ret = regulator_bulk_enable(pcie->num_supplies, pcie->supplies);
+	if (ret)
+		dev_err(dev, "failed to enable DSC power supplies: %d\n", ret);
+
+	/* De-assert Downstream Component reset */
+	if (pcie->dsc_reset) {
+		/*
+		 * Wait for a short time before we de-assert the reset GPIO.
+		 * Depends on the requirement of a specific Downstream
+		 * Component.
+		 */
+		usleep_range(1000 * pcie->dsc_reset_delay_ms,
+			     1000 * pcie->dsc_reset_delay_ms + 100);
+		gpiod_set_value_cansleep(pcie->dsc_reset, 0);
+	}
+
+	return ret;
+}
+
+static void mtk_pcie_dsc_power_down(struct mtk_gen3_pcie *pcie)
+{
+	/* Assert Downstream Component reset */
+	if (pcie->dsc_reset)
+		gpiod_set_value_cansleep(pcie->dsc_reset, 1);
+
+	regulator_bulk_disable(pcie->num_supplies, pcie->supplies);
+}
+
 static int mtk_pcie_power_up(struct mtk_gen3_pcie *pcie)
 {
 	struct device *dev = pcie->dev;
 	int err;
 
+	/* Downstream Component power up before RC */
+	if (!device_wakeup_path(pcie->dev)){
+		err = mtk_pcie_dsc_power_up(pcie);
+		if (err)
+			return err;
+	}
+
 	/* PHY power on and enable pipe clock */
 	reset_control_deassert(pcie->phy_reset);
 
@@ -855,6 +967,7 @@ static int mtk_pcie_power_up(struct mtk_gen3_pcie *pcie)
 	phy_exit(pcie->phy);
 err_phy_init:
 	reset_control_assert(pcie->phy_reset);
+	mtk_pcie_dsc_power_down(pcie);
 
 	return err;
 }
@@ -870,6 +983,11 @@ static void mtk_pcie_power_down(struct mtk_gen3_pcie *pcie)
 	phy_power_off(pcie->phy);
 	phy_exit(pcie->phy);
 	reset_control_assert(pcie->phy_reset);
+
+	if (!pcie->dev->power.is_suspended || !device_wakeup_path(pcie->dev))
+	{
+		mtk_pcie_dsc_power_down(pcie);
+	}
 }
 
 static int mtk_pcie_setup(struct mtk_gen3_pcie *pcie)
diff --git a/drivers/remoteproc/mtk_common.h b/drivers/remoteproc/mtk_common.h
index ea6fa1100a00b37316bbb1882e10dae543ee049e..04c1f66ee77d74c6977a5889c3a3677527763483 100644
--- a/drivers/remoteproc/mtk_common.h
+++ b/drivers/remoteproc/mtk_common.h
@@ -47,6 +47,7 @@
 #define MT8192_SCP2SPM_IPC_CLR		0x4094
 #define MT8192_GIPC_IN_SET		0x4098
 #define MT8192_HOST_IPC_INT_BIT		BIT(0)
+#define MT8195_CORE1_HOST_IPC_INT_BIT	BIT(4)
 
 #define MT8192_CORE0_SW_RSTN_CLR	0x10000
 #define MT8192_CORE0_SW_RSTN_SET	0x10004
@@ -54,8 +55,32 @@
 #define MT8192_CORE0_WDT_IRQ		0x10030
 #define MT8192_CORE0_WDT_CFG		0x10034
 
+#define MT8195_SYS_STATUS		0x4004
+#define MT8195_CORE0_WDT		BIT(16)
+#define MT8195_CORE1_WDT		BIT(17)
+
 #define MT8195_L1TCM_SRAM_PDN_RESERVED_RSI_BITS		GENMASK(7, 4)
 
+#define MT8195_CPU1_SRAM_PD			0x1084
+#define MT8195_SSHUB2APMCU_IPC_SET		0x4088
+#define MT8195_SSHUB2APMCU_IPC_CLR		0x408C
+#define MT8195_CORE1_SW_RSTN_CLR		0x20000
+#define MT8195_CORE1_SW_RSTN_SET		0x20004
+#define MT8195_CORE1_MEM_ATT_PREDEF		0x20008
+#define MT8195_CORE1_WDT_IRQ			0x20030
+#define MT8195_CORE1_WDT_CFG			0x20034
+
+#define MT8195_SEC_CTRL				0x85000
+#define MT8195_CORE_OFFSET_ENABLE_D		BIT(13)
+#define MT8195_CORE_OFFSET_ENABLE_I		BIT(12)
+#define MT8195_L2TCM_OFFSET_RANGE_0_LOW		0x850b0
+#define MT8195_L2TCM_OFFSET_RANGE_0_HIGH	0x850b4
+#define MT8195_L2TCM_OFFSET			0x850d0
+#define SCP_SRAM_REMAP_LOW			0
+#define SCP_SRAM_REMAP_HIGH			1
+#define SCP_SRAM_REMAP_OFFSET			2
+#define SCP_SRAM_REMAP_SIZE			3
+
 #define SCP_FW_VER_LEN			32
 #define SCP_SHARE_BUFFER_SIZE		288
 
@@ -74,6 +99,14 @@ struct scp_ipi_desc {
 	void *priv;
 };
 
+struct scp_subdev_core {
+	struct rproc_subdev subdev;
+	struct mtk_scp *main_scp;
+	void (*scp_dual_wdt_timeout)(struct mtk_scp *scp, u32 scp_to_host);
+};
+
+#define to_subdev_core(d) container_of(d, struct scp_subdev_core, subdev)
+
 struct mtk_scp;
 
 struct mtk_scp_of_data {
@@ -89,6 +122,7 @@ struct mtk_scp_of_data {
 	u32 host_to_scp_int_bit;
 
 	size_t ipi_buf_offset;
+	uint32_t max_code_size;
 };
 
 struct mtk_scp {
@@ -119,6 +153,8 @@ struct mtk_scp {
 	size_t dram_size;
 
 	struct rproc_subdev *rpmsg_subdev;
+	struct rproc_subdev *dual_subdev;
+	int dual_probe_done;
 };
 
 /**
diff --git a/drivers/remoteproc/mtk_scp.c b/drivers/remoteproc/mtk_scp.c
index 0861b76f185f7274708958bd5743fb8f584b09c1..285127ae885bbdf3b23c1aaf77f30e033d1c2090 100644
--- a/drivers/remoteproc/mtk_scp.c
+++ b/drivers/remoteproc/mtk_scp.c
@@ -20,9 +20,12 @@
 #include "mtk_common.h"
 #include "remoteproc_internal.h"
 
-#define MAX_CODE_SIZE 0x500000
 #define SECTION_NAME_IPI_BUFFER ".ipi_buffer"
 
+#define SCP_CORE_0 0
+#define SCP_CORE_1 1
+#define SCP_CORE_SINGLE 0xF
+
 /**
  * scp_get() - get a reference to SCP.
  *
@@ -176,6 +179,16 @@ static void mt8192_scp_reset_deassert(struct mtk_scp *scp)
 	writel(1, scp->reg_base + MT8192_CORE0_SW_RSTN_CLR);
 }
 
+static void mt8195_scp_dual_reset_assert(struct mtk_scp *scp)
+{
+	writel(1, scp->reg_base + MT8195_CORE1_SW_RSTN_SET);
+}
+
+static void mt8195_scp_dual_reset_deassert(struct mtk_scp *scp)
+{
+	writel(1, scp->reg_base + MT8195_CORE1_SW_RSTN_CLR);
+}
+
 static void mt8183_scp_irq_handler(struct mtk_scp *scp)
 {
 	u32 scp_to_host;
@@ -212,6 +225,56 @@ static void mt8192_scp_irq_handler(struct mtk_scp *scp)
 	}
 }
 
+static void mt8195_scp_irq_handler(struct mtk_scp *scp)
+{
+	u32 scp_to_host;
+
+	scp_to_host = readl(scp->reg_base + MT8192_SCP2APMCU_IPC_SET);
+
+	if (scp_to_host & MT8192_SCP_IPC_INT_BIT) {
+		scp_ipi_handler(scp);
+
+		/*
+		 * SCP won't send another interrupt until we clear
+		 * MT8192_SCP2APMCU_IPC.
+		 */
+		writel(MT8192_SCP_IPC_INT_BIT,
+		       scp->reg_base + MT8192_SCP2APMCU_IPC_CLR);
+	} else {
+		if (readl(scp->reg_base + MT8195_SYS_STATUS) & MT8195_CORE1_WDT) {
+			writel(1, scp->reg_base + MT8195_CORE1_WDT_IRQ);
+
+			if (scp->dual_subdev) {
+				struct scp_subdev_core *subdev_core;
+
+				subdev_core = to_subdev_core(scp->dual_subdev);
+				subdev_core->scp_dual_wdt_timeout(scp, scp_to_host);
+			}
+		} else {
+			writel(1, scp->reg_base + MT8192_CORE0_WDT_IRQ);
+			scp_wdt_handler(scp, scp_to_host);
+		}
+	}
+}
+
+static void mt8195_scp_dual_irq_handler(struct mtk_scp *scp)
+{
+	u32 scp_to_host;
+
+	scp_to_host = readl(scp->reg_base + MT8195_SSHUB2APMCU_IPC_SET);
+
+	if (scp_to_host & MT8192_SCP_IPC_INT_BIT) {
+		scp_ipi_handler(scp);
+
+		/*
+		 * SCP won't send another interrupt until we clear
+		 * MT8195_SSHUB2APMCU_IPC_CLR.
+		 */
+		writel(MT8192_SCP_IPC_INT_BIT,
+		       scp->reg_base + MT8195_SSHUB2APMCU_IPC_CLR);
+	}
+}
+
 static irqreturn_t scp_irq_handler(int irq, void *priv)
 {
 	struct mtk_scp *scp = priv;
@@ -453,6 +516,63 @@ static int mt8195_scp_before_load(struct mtk_scp *scp)
 	return 0;
 }
 
+static int mt8195_scp_dual_before_load(struct mtk_scp *scp)
+{
+	u32 sec_ctrl;
+	struct device *dev = scp->dev;
+	struct device_node *main_np;
+	struct platform_device *main_pdev;
+	struct mtk_scp *scp_core0;
+
+	/* Get sram start address from SCP core 0 */
+	main_np = of_parse_phandle(dev->of_node, "mediatek,scp-core", 0);
+	if (!main_np) {
+		dev_warn(dev, "Invalid SCP main core phandle\n");
+		return -EINVAL;
+	}
+
+	main_pdev = of_find_device_by_node(main_np);
+	of_node_put(main_np);
+
+	if (!main_pdev) {
+		dev_err(dev, "Cannot find SCP core 0 device\n");
+		return -ENODEV;
+	}
+	scp_core0 = platform_get_drvdata(main_pdev);
+	put_device(&main_pdev->dev);
+
+	scp_sram_power_on(scp->reg_base + MT8195_CPU1_SRAM_PD, 0);
+
+	/* hold SCP in reset while loading FW. */
+	scp->data->scp_reset_assert(scp);
+
+	/* enable MPU for all memory regions */
+	writel(0xff, scp->reg_base + MT8195_CORE1_MEM_ATT_PREDEF);
+
+	/* The value of SRAM offset range is from the viewpoint of SCP core 1.
+	 * This configuration adds an offset on SCP bus when SCP core 1 accesses SCP SRAM
+	 * to solve the SCP core 0 and core 1 both fetch the 1st instruction from the same
+	 * SRAM address.
+	 *
+	 * Because SCP core 0 and core 1 both boot from address 0, this must be configured
+	 * before boot SCP core 1.
+	 *
+	 * Configure the range of SRAM addresses will be added offset.
+	 */
+	writel(0, scp->reg_base + MT8195_L2TCM_OFFSET_RANGE_0_LOW);
+	writel(scp->sram_size, scp->reg_base + MT8195_L2TCM_OFFSET_RANGE_0_HIGH);
+
+	/* configure the offset value */
+	writel(scp->sram_phys - scp_core0->sram_phys, scp->reg_base + MT8195_L2TCM_OFFSET);
+
+	/* enable adding sram offset when fetching instruction and data */
+	sec_ctrl = readl(scp->reg_base + MT8195_SEC_CTRL);
+	sec_ctrl |= MT8195_CORE_OFFSET_ENABLE_I | MT8195_CORE_OFFSET_ENABLE_D;
+	writel(sec_ctrl, scp->reg_base + MT8195_SEC_CTRL);
+
+	return 0;
+}
+
 static int scp_load(struct rproc *rproc, const struct firmware *fw)
 {
 	struct mtk_scp *scp = rproc->priv;
@@ -625,6 +745,15 @@ static void mt8195_scp_stop(struct mtk_scp *scp)
 	writel(0, scp->reg_base + MT8192_CORE0_WDT_CFG);
 }
 
+static void mt8195_scp_dual_stop(struct mtk_scp *scp)
+{
+	/* Power off CPU SRAM */
+	scp_sram_power_off(scp->reg_base + MT8195_CPU1_SRAM_PD, 0);
+
+	/* Disable SCP watchdog */
+	writel(0, scp->reg_base + MT8195_CORE1_WDT_CFG);
+}
+
 static int scp_stop(struct rproc *rproc)
 {
 	struct mtk_scp *scp = (struct mtk_scp *)rproc->priv;
@@ -744,7 +873,7 @@ static int scp_map_memory_region(struct mtk_scp *scp)
 	}
 
 	/* Reserved SCP code size */
-	scp->dram_size = MAX_CODE_SIZE;
+	scp->dram_size = scp->data->max_code_size;
 	scp->cpu_addr = dma_alloc_coherent(scp->dev, scp->dram_size,
 					   &scp->dma_addr, GFP_KERNEL);
 	if (!scp->cpu_addr)
@@ -811,6 +940,151 @@ static void scp_remove_rpmsg_subdev(struct mtk_scp *scp)
 	}
 }
 
+static struct mtk_scp *scp_dual_get(struct mtk_scp *scp)
+{
+	struct device *dev = scp->dev;
+	struct device_node *np;
+	struct platform_device *dual_pdev;
+	struct mtk_scp *scp_dual;
+
+	np = of_parse_phandle(dev->of_node, "mediatek,scp-core", 0);
+	dual_pdev = of_find_device_by_node(np);
+	of_node_put(np);
+
+	if (!dual_pdev) {
+		dev_err(dev, "No scp-dual pdev\n");
+		return NULL;
+	}
+
+	scp_dual = platform_get_drvdata(dual_pdev);
+	if (!scp_dual)
+		put_device(&dual_pdev->dev);
+
+	return scp_dual;
+}
+
+static void scp_dual_put(struct mtk_scp *scp)
+{
+	put_device(scp->dev);
+}
+
+static int scp_dual_rproc_prepare(struct rproc_subdev *subdev)
+{
+	struct scp_subdev_core *subdev_core = to_subdev_core(subdev);
+	struct mtk_scp *scp = subdev_core->main_scp;
+	unsigned long timeout;
+
+	timeout = jiffies + msecs_to_jiffies(100);
+	while (1) {
+		struct mtk_scp *scp_dual = scp_dual_get(scp);
+
+		if (scp_dual && scp_dual->dual_probe_done) {
+			scp_dual_put(scp_dual);
+			break;
+		}
+
+		if (scp_dual && !scp_dual->dual_probe_done)
+			scp_dual_put(scp_dual);
+
+		if (time_after(jiffies, timeout)) {
+			dev_err(scp->dev, "scp-dual probe timeout\n");
+			return -ETIMEDOUT;
+		}
+	}
+
+	return 0;
+}
+
+static int scp_dual_rproc_start(struct rproc_subdev *subdev)
+{
+	struct scp_subdev_core *subdev_core = to_subdev_core(subdev);
+	struct mtk_scp *scp_dual;
+
+	scp_dual = scp_dual_get(subdev_core->main_scp);
+	if (!scp_dual)
+		return -ENODEV;
+
+	rproc_boot(scp_dual->rproc);
+	scp_dual_put(scp_dual);
+
+	return 0;
+}
+
+static void scp_dual_rproc_stop(struct rproc_subdev *subdev, bool crashed)
+{
+	struct scp_subdev_core *subdev_core = to_subdev_core(subdev);
+	struct mtk_scp *scp_dual;
+
+	scp_dual = scp_dual_get(subdev_core->main_scp);
+	if (!scp_dual)
+		return;
+
+	rproc_shutdown(scp_dual->rproc);
+	scp_dual_put(scp_dual);
+}
+
+static void scp_dual_wdt_handler(struct mtk_scp *scp, u32 scp_to_host)
+{
+	struct mtk_scp *scp_dual;
+
+	scp_dual = scp_dual_get(scp);
+	if (!scp_dual)
+		return;
+
+	dev_err(scp_dual->dev, "SCP watchdog timeout! 0x%x\n", scp_to_host);
+	rproc_report_crash(scp_dual->rproc, RPROC_WATCHDOG);
+	scp_dual_put(scp_dual);
+}
+
+static struct rproc_subdev *scp_dual_create_subdev(struct mtk_scp *scp)
+{
+	struct device *dev = scp->dev;
+	struct scp_subdev_core *subdev_core;
+	struct device_node *np;
+
+	np = of_parse_phandle(dev->of_node, "mediatek,scp-core", 0);
+	if (!np)
+		return NULL;
+
+	of_node_put(np);
+
+	subdev_core = devm_kzalloc(dev, sizeof(*subdev_core), GFP_KERNEL);
+	if (!subdev_core)
+		return NULL;
+
+	subdev_core->main_scp = scp;
+	subdev_core->scp_dual_wdt_timeout = scp_dual_wdt_handler;
+	subdev_core->subdev.prepare = scp_dual_rproc_prepare;
+	subdev_core->subdev.start = scp_dual_rproc_start;
+	subdev_core->subdev.stop = scp_dual_rproc_stop;
+
+	return &subdev_core->subdev;
+}
+
+static void scp_dual_destroy_subdev(struct rproc_subdev *subdev)
+{
+	struct scp_subdev_core *subdev_core = to_subdev_core(subdev);
+
+	devm_kfree(subdev_core->main_scp->dev, subdev_core);
+}
+
+static void scp_add_dual_subdev(struct mtk_scp *scp)
+{
+	scp->dual_subdev = scp_dual_create_subdev(scp);
+
+	if (scp->dual_subdev)
+		rproc_add_subdev(scp->rproc, scp->dual_subdev);
+}
+
+static void scp_remove_dual_subdev(struct mtk_scp *scp)
+{
+	if (scp->dual_subdev) {
+		rproc_remove_subdev(scp->rproc, scp->dual_subdev);
+		scp_dual_destroy_subdev(scp->dual_subdev);
+		scp->dual_subdev = NULL;
+	}
+}
+
 static int scp_probe(struct platform_device *pdev)
 {
 	struct device *dev = &pdev->dev;
@@ -820,6 +1094,7 @@ static int scp_probe(struct platform_device *pdev)
 	struct resource *res;
 	const char *fw_name = "scp.img";
 	int ret, i;
+	u32 core_id = SCP_CORE_SINGLE;
 
 	ret = rproc_of_parse_firmware(dev, 0, &fw_name);
 	if (ret < 0 && ret != -EINVAL)
@@ -835,8 +1110,16 @@ static int scp_probe(struct platform_device *pdev)
 	scp->data = of_device_get_match_data(dev);
 	platform_set_drvdata(pdev, scp);
 
+	ret = of_property_read_u32_index(dev->of_node, "mediatek,scp-core", 1, &core_id);
+	if (ret == 0)
+		dev_info(dev, "Boot SCP dual core %u\n", core_id);
+
 	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "sram");
-	scp->sram_base = devm_ioremap_resource(dev, res);
+	if (core_id == SCP_CORE_1)
+		scp->sram_base = devm_ioremap(dev, res->start, resource_size(res));
+	else
+		scp->sram_base = devm_ioremap_resource(dev, res);
+
 	if (IS_ERR(scp->sram_base))
 		return dev_err_probe(dev, PTR_ERR(scp->sram_base),
 				     "Failed to parse and map sram memory\n");
@@ -857,7 +1140,12 @@ static int scp_probe(struct platform_device *pdev)
 		scp->l1tcm_phys = res->start;
 	}
 
-	scp->reg_base = devm_platform_ioremap_resource_byname(pdev, "cfg");
+	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "cfg");
+	if (core_id == SCP_CORE_1)
+		scp->reg_base = devm_ioremap(dev, res->start, resource_size(res));
+	else
+		scp->reg_base = devm_ioremap_resource(dev, res);
+
 	if (IS_ERR(scp->reg_base))
 		return dev_err_probe(dev, PTR_ERR(scp->reg_base),
 				     "Failed to parse and map cfg memory\n");
@@ -886,6 +1174,9 @@ static int scp_probe(struct platform_device *pdev)
 
 	scp_add_rpmsg_subdev(scp);
 
+	if (core_id == SCP_CORE_0)
+		scp_add_dual_subdev(scp);
+
 	ret = devm_request_threaded_irq(dev, platform_get_irq(pdev, 0), NULL,
 					scp_irq_handler, IRQF_ONESHOT,
 					pdev->name, scp);
@@ -895,13 +1186,23 @@ static int scp_probe(struct platform_device *pdev)
 		goto remove_subdev;
 	}
 
+	/* disable auto boot before register rproc.
+	 * scp core 1 is booted as a subdevice of scp core 0.
+	 */
+	if (core_id == SCP_CORE_1)
+		rproc->auto_boot = false;
+
 	ret = rproc_add(rproc);
 	if (ret)
 		goto remove_subdev;
 
+	if (core_id == SCP_CORE_1)
+		scp->dual_probe_done = 1;
+
 	return 0;
 
 remove_subdev:
+	scp_remove_dual_subdev(scp);
 	scp_remove_rpmsg_subdev(scp);
 	scp_ipi_unregister(scp, SCP_IPI_INIT);
 release_dev_mem:
@@ -919,6 +1220,7 @@ static int scp_remove(struct platform_device *pdev)
 	int i;
 
 	rproc_del(scp->rproc);
+	scp_remove_dual_subdev(scp);
 	scp_remove_rpmsg_subdev(scp);
 	scp_ipi_unregister(scp, SCP_IPI_INIT);
 	scp_unmap_memory_region(scp);
@@ -940,6 +1242,7 @@ static const struct mtk_scp_of_data mt8183_of_data = {
 	.host_to_scp_reg = MT8183_HOST_TO_SCP,
 	.host_to_scp_int_bit = MT8183_HOST_IPC_INT_BIT,
 	.ipi_buf_offset = 0x7bdb0,
+	.max_code_size = 0x500000,
 };
 
 static const struct mtk_scp_of_data mt8186_of_data = {
@@ -953,18 +1256,20 @@ static const struct mtk_scp_of_data mt8186_of_data = {
 	.host_to_scp_reg = MT8183_HOST_TO_SCP,
 	.host_to_scp_int_bit = MT8183_HOST_IPC_INT_BIT,
 	.ipi_buf_offset = 0x3bdb0,
+	.max_code_size = 0x500000,
 };
 
 static const struct mtk_scp_of_data mt8188_of_data = {
 	.scp_clk_get = mt8195_scp_clk_get,
 	.scp_before_load = mt8192_scp_before_load,
-	.scp_irq_handler = mt8192_scp_irq_handler,
+	.scp_irq_handler = mt8195_scp_irq_handler,
 	.scp_reset_assert = mt8192_scp_reset_assert,
 	.scp_reset_deassert = mt8192_scp_reset_deassert,
 	.scp_stop = mt8192_scp_stop,
 	.scp_da_to_va = mt8192_scp_da_to_va,
 	.host_to_scp_reg = MT8192_GIPC_IN_SET,
 	.host_to_scp_int_bit = MT8192_HOST_IPC_INT_BIT,
+	.max_code_size = 0x500000,
 };
 
 static const struct mtk_scp_of_data mt8192_of_data = {
@@ -977,18 +1282,33 @@ static const struct mtk_scp_of_data mt8192_of_data = {
 	.scp_da_to_va = mt8192_scp_da_to_va,
 	.host_to_scp_reg = MT8192_GIPC_IN_SET,
 	.host_to_scp_int_bit = MT8192_HOST_IPC_INT_BIT,
+	.max_code_size = 0x500000,
 };
 
 static const struct mtk_scp_of_data mt8195_of_data = {
 	.scp_clk_get = mt8195_scp_clk_get,
 	.scp_before_load = mt8195_scp_before_load,
-	.scp_irq_handler = mt8192_scp_irq_handler,
+	.scp_irq_handler = mt8195_scp_irq_handler,
 	.scp_reset_assert = mt8192_scp_reset_assert,
 	.scp_reset_deassert = mt8192_scp_reset_deassert,
 	.scp_stop = mt8195_scp_stop,
 	.scp_da_to_va = mt8192_scp_da_to_va,
 	.host_to_scp_reg = MT8192_GIPC_IN_SET,
 	.host_to_scp_int_bit = MT8192_HOST_IPC_INT_BIT,
+	.max_code_size = 0x500000,
+};
+
+static const struct mtk_scp_of_data mt8195_scp_dual_of_data = {
+	.scp_clk_get = mt8195_scp_clk_get,
+	.scp_before_load = mt8195_scp_dual_before_load,
+	.scp_irq_handler = mt8195_scp_dual_irq_handler,
+	.scp_reset_assert = mt8195_scp_dual_reset_assert,
+	.scp_reset_deassert = mt8195_scp_dual_reset_deassert,
+	.scp_stop = mt8195_scp_dual_stop,
+	.scp_da_to_va = mt8192_scp_da_to_va,
+	.host_to_scp_reg = MT8192_GIPC_IN_SET,
+	.host_to_scp_int_bit = MT8195_CORE1_HOST_IPC_INT_BIT,
+	.max_code_size = 0x400000,
 };
 
 static const struct of_device_id mtk_scp_of_match[] = {
@@ -997,6 +1317,7 @@ static const struct of_device_id mtk_scp_of_match[] = {
 	{ .compatible = "mediatek,mt8188-scp", .data = &mt8188_of_data },
 	{ .compatible = "mediatek,mt8192-scp", .data = &mt8192_of_data },
 	{ .compatible = "mediatek,mt8195-scp", .data = &mt8195_of_data },
+	{ .compatible = "mediatek,mt8195-scp-dual", .data = &mt8195_scp_dual_of_data },
 	{},
 };
 MODULE_DEVICE_TABLE(of, mtk_scp_of_match);
diff --git a/drivers/soc/mediatek/Kconfig b/drivers/soc/mediatek/Kconfig
index d6b83a5508cab78018fe6961f32da315fc9c60dd..0d66d70e53c39db8368af6d7a21f688d614a5309 100644
--- a/drivers/soc/mediatek/Kconfig
+++ b/drivers/soc/mediatek/Kconfig
@@ -90,4 +90,19 @@ config MTK_SVS
 	  chip process corner, temperatures and other factors. Then DVFS
 	  driver could apply SVS bank voltage to PMIC/Buck.
 
+config MTK_SOCINFO
+	tristate "MediaTek SOCINFO"
+	default y
+	help
+	  Say y here to enable mtk socinfo information.
+	  This enables a debug node which shows MTK SOC information.
+
+config MTK_SOCINFO_DEBUG
+	tristate "MediaTek SOCINFO debug"
+	default n
+	help
+	  Say y here to enables a debug node which shows MTK SOC information.
+
+source "drivers/soc/mediatek/systracker/Kconfig"
+
 endmenu
diff --git a/drivers/soc/mediatek/Makefile b/drivers/soc/mediatek/Makefile
index 8c0ddacbcde8b938a826964f0ef3178f29e5766b..9a36749f4fefb414cb344bb915ac9074e613fc8c 100644
--- a/drivers/soc/mediatek/Makefile
+++ b/drivers/soc/mediatek/Makefile
@@ -9,3 +9,5 @@ obj-$(CONFIG_MTK_SCPSYS_PM_DOMAINS) += mtk-pm-domains.o
 obj-$(CONFIG_MTK_MMSYS) += mtk-mmsys.o
 obj-$(CONFIG_MTK_MMSYS) += mtk-mutex.o
 obj-$(CONFIG_MTK_SVS) += mtk-svs.o
+obj-$(CONFIG_MTK_SOCINFO) += mtk-socinfo.o
+obj-$(CONFIG_MTK_SYSTRACKER_V2) += systracker/
diff --git a/drivers/soc/mediatek/mt8188-mmsys.h b/drivers/soc/mediatek/mt8188-mmsys.h
index 448cc3761b435eba4b5bd465dc8bfa0dcbef40df..6bebf1a69fc0763e9c4835c98114fe3fb3058b82 100644
--- a/drivers/soc/mediatek/mt8188-mmsys.h
+++ b/drivers/soc/mediatek/mt8188-mmsys.h
@@ -3,6 +3,10 @@
 #ifndef __SOC_MEDIATEK_MT8188_MMSYS_H
 #define __SOC_MEDIATEK_MT8188_MMSYS_H
 
+#include <linux/soc/mediatek/mtk-mmsys.h>
+#include <dt-bindings/reset/mt8188-resets.h>
+
+#define MT8188_VDO0_SW0_RST_B				0x190
 #define MT8188_VDO0_OVL_MOUT_EN				0xf14
 #define MT8188_MOUT_DISP_OVL0_TO_DISP_RDMA0		BIT(0)
 #define MT8188_MOUT_DISP_OVL0_TO_DISP_WDMA0		BIT(1)
@@ -67,6 +71,136 @@
 #define MT8188_SOUT_DSC_WRAP0_OUT_TO_VPP_MERGE		BIT(18)
 #define MT8188_SOUT_DSC_WRAP0_OUT_TO_DISP_WDMA0		BIT(19)
 
+#define MT8188_VDO1_SW0_RST_B					0x1d0
+#define MT8188_VDO1_HDR_TOP_CFG					0xd00
+#define MT8188_VDO1_MIXER_IN1_ALPHA				0xd30
+#define MT8188_VDO1_MIXER_IN1_PAD				0xd40
+#define MT8188_VDO1_MIXER_VSYNC_LEN				0xd5c
+#define MT8188_VDO1_MERGE0_ASYNC_CFG_WD				0xe30
+#define MT8188_VDO1_HDRBE_ASYNC_CFG_WD				0xe70
+#define MT8188_VDO1_VPP_MERGE0_P0_SEL_IN			0xf04
+#define MT8188_VPP_MERGE0_P0_SEL_IN_FROM_MDP_RDMA0		1
+#define MT8188_VDO1_VPP_MERGE0_P1_SEL_IN			0xf08
+#define MT8188_VPP_MERGE0_P1_SEL_IN_FROM_MDP_RDMA1		1
+#define MT8188_VDO1_DISP_DPI1_SEL_IN				0xf10
+#define MT8188_DISP_DPI1_SEL_IN_FROM_VPP_MERGE4_MOUT		0
+#define MT8188_VDO1_DISP_DP_INTF0_SEL_IN			0xf14
+#define MT8188_DISP_DP_INTF0_SEL_IN_FROM_VPP_MERGE4_MOUT	0
+#define MT8188_VDO1_MERGE4_SOUT_SEL				0xf18
+#define MT8188_MERGE4_SOUT_TO_DPI1_SEL				BIT(2)
+#define MT8188_MERGE4_SOUT_TO_DP_INTF0_SEL			BIT(3)
+#define MT8188_VDO1_MIXER_IN1_SEL_IN				0xf24
+#define MT8188_MIXER_IN1_SEL_IN_FROM_MERGE0_ASYNC_SOUT		1
+#define MT8188_VDO1_MIXER_IN2_SEL_IN				0xf28
+#define MT8188_MIXER_IN2_SEL_IN_FROM_MERGE1_ASYNC_SOUT		1
+#define MT8188_VDO1_MIXER_IN3_SEL_IN				0xf2c
+#define MT8188_MIXER_IN3_SEL_IN_FROM_MERGE2_ASYNC_SOUT		1
+#define MT8188_VDO1_MIXER_IN4_SEL_IN				0xf30
+#define MT8188_MIXER_IN4_SEL_IN_FROM_MERGE3_ASYNC_SOUT		1
+#define MT8188_VDO1_MIXER_OUT_SOUT_SEL				0xf34
+#define MT8188_MIXER_SOUT_TO_MERGE4_ASYNC_SEL			1
+#define MT8188_VDO1_VPP_MERGE1_P0_SEL_IN			0xf3c
+#define MT8188_VPP_MERGE1_P0_SEL_IN_FROM_MDP_RDMA2		1
+#define MT8188_VDO1_MERGE0_ASYNC_SOUT_SEL			0xf40
+#define MT8188_SOUT_TO_MIXER_IN1_SEL				1
+#define MT8188_VDO1_MERGE1_ASYNC_SOUT_SEL			0xf44
+#define MT8188_SOUT_TO_MIXER_IN2_SEL				1
+#define MT8188_VDO1_MERGE2_ASYNC_SOUT_SEL			0xf48
+#define MT8188_SOUT_TO_MIXER_IN3_SEL				1
+#define MT8188_VDO1_MERGE3_ASYNC_SOUT_SEL			0xf4c
+#define MT8188_SOUT_TO_MIXER_IN4_SEL				1
+#define MT8188_VDO1_MERGE4_ASYNC_SEL_IN				0xf50
+#define MT8188_MERGE4_ASYNC_SEL_IN_FROM_MIXER_OUT_SOUT		1
+#define MT8188_VDO1_MIXER_IN1_SOUT_SEL				0xf58
+#define MT8188_MIXER_IN1_SOUT_TO_DISP_MIXER			0
+#define MT8188_VDO1_MIXER_IN2_SOUT_SEL				0xf5c
+#define MT8188_MIXER_IN2_SOUT_TO_DISP_MIXER			0
+#define MT8188_VDO1_MIXER_IN3_SOUT_SEL				0xf60
+#define MT8188_MIXER_IN3_SOUT_TO_DISP_MIXER			0
+#define MT8188_VDO1_MIXER_IN4_SOUT_SEL				0xf64
+#define MT8188_MIXER_IN4_SOUT_TO_DISP_MIXER			0
+#define MT8188_VDO1_MIXER_SOUT_SEL_IN				0xf68
+#define MT8188_MIXER_SOUT_SEL_IN_FROM_DISP_MIXER		0
+
+static const u8 mmsys_mt8188_vdo0_rst_tb[] = {
+	[MT8188_VDO0_RST_DISP_OVL0]	= MMSYS_RST_NR(0, 0),
+	[MT8188_VDO0_RST_FAKE_ENG0]	= MMSYS_RST_NR(0, 2),
+	[MT8188_VDO0_RST_DISP_CCORR0]	= MMSYS_RST_NR(0, 4),
+	[MT8188_VDO0_RST_DISP_MUTEX0]	= MMSYS_RST_NR(0, 6),
+	[MT8188_VDO0_RST_DISP_GAMMA0]	= MMSYS_RST_NR(0, 8),
+	[MT8188_VDO0_RST_DISP_DITHER0]	= MMSYS_RST_NR(0, 10),
+	[MT8188_VDO0_RST_DISP_WDMA0]	= MMSYS_RST_NR(0, 17),
+	[MT8188_VDO0_RST_DISP_RDMA0]	= MMSYS_RST_NR(0, 19),
+	[MT8188_VDO0_RST_DSI0]		= MMSYS_RST_NR(0, 21),
+	[MT8188_VDO0_RST_DSI1]		= MMSYS_RST_NR(0, 22),
+	[MT8188_VDO0_RST_DSC_WRAP0]	= MMSYS_RST_NR(0, 23),
+	[MT8188_VDO0_RST_VPP_MERGE0]	= MMSYS_RST_NR(0, 24),
+	[MT8188_VDO0_RST_DP_INTF0]	= MMSYS_RST_NR(0, 25),
+	[MT8188_VDO0_RST_DISP_AAL0]	= MMSYS_RST_NR(0, 26),
+	[MT8188_VDO0_RST_INLINEROT0]	= MMSYS_RST_NR(0, 27),
+	[MT8188_VDO0_RST_APB_BUS]	= MMSYS_RST_NR(0, 28),
+	[MT8188_VDO0_RST_DISP_COLOR0]	= MMSYS_RST_NR(0, 29),
+	[MT8188_VDO0_RST_MDP_WROT0]	= MMSYS_RST_NR(0, 30),
+	[MT8188_VDO0_RST_DISP_RSZ0]	= MMSYS_RST_NR(0, 31),
+};
+
+static const u8 mmsys_mt8188_vdo1_rst_tb[] = {
+	[MT8188_VDO1_RST_SMI_LARB2]			= MMSYS_RST_NR(0, 0),
+	[MT8188_VDO1_RST_SMI_LARB3]			= MMSYS_RST_NR(0, 1),
+	[MT8188_VDO1_RST_GALS]				= MMSYS_RST_NR(0, 2),
+	[MT8188_VDO1_RST_FAKE_ENG0]			= MMSYS_RST_NR(0, 3),
+	[MT8188_VDO1_RST_FAKE_ENG1]			= MMSYS_RST_NR(0, 4),
+	[MT8188_VDO1_RST_MDP_RDMA0]			= MMSYS_RST_NR(0, 5),
+	[MT8188_VDO1_RST_MDP_RDMA1]			= MMSYS_RST_NR(0, 6),
+	[MT8188_VDO1_RST_MDP_RDMA2]			= MMSYS_RST_NR(0, 7),
+	[MT8188_VDO1_RST_MDP_RDMA3]			= MMSYS_RST_NR(0, 8),
+	[MT8188_VDO1_RST_VPP_MERGE0]			= MMSYS_RST_NR(0, 9),
+	[MT8188_VDO1_RST_VPP_MERGE1]			= MMSYS_RST_NR(0, 10),
+	[MT8188_VDO1_RST_VPP_MERGE2]			= MMSYS_RST_NR(0, 11),
+	[MT8188_VDO1_RST_VPP_MERGE3]			= MMSYS_RST_NR(1, 0),
+	[MT8188_VDO1_RST_VPP_MERGE4]			= MMSYS_RST_NR(1, 1),
+	[MT8188_VDO1_RST_VPP2_TO_VDO1_DL_ASYNC]		= MMSYS_RST_NR(1, 2),
+	[MT8188_VDO1_RST_VPP3_TO_VDO1_DL_ASYNC]		= MMSYS_RST_NR(1, 3),
+	[MT8188_VDO1_RST_DISP_MUTEX]			= MMSYS_RST_NR(1, 4),
+	[MT8188_VDO1_RST_MDP_RDMA4]			= MMSYS_RST_NR(1, 5),
+	[MT8188_VDO1_RST_MDP_RDMA5]			= MMSYS_RST_NR(1, 6),
+	[MT8188_VDO1_RST_MDP_RDMA6]			= MMSYS_RST_NR(1, 7),
+	[MT8188_VDO1_RST_MDP_RDMA7]			= MMSYS_RST_NR(1, 8),
+	[MT8188_VDO1_RST_DP_INTF1_MMCK]			= MMSYS_RST_NR(1, 9),
+	[MT8188_VDO1_RST_DPI0_MM_CK]			= MMSYS_RST_NR(1, 10),
+	[MT8188_VDO1_RST_DPI1_MM_CK]			= MMSYS_RST_NR(1, 11),
+	[MT8188_VDO1_RST_MERGE0_DL_ASYNC]		= MMSYS_RST_NR(1, 13),
+	[MT8188_VDO1_RST_MERGE1_DL_ASYNC]		= MMSYS_RST_NR(1, 14),
+	[MT8188_VDO1_RST_MERGE2_DL_ASYNC]		= MMSYS_RST_NR(1, 15),
+	[MT8188_VDO1_RST_MERGE3_DL_ASYNC]		= MMSYS_RST_NR(1, 16),
+	[MT8188_VDO1_RST_MERGE4_DL_ASYNC]		= MMSYS_RST_NR(1, 17),
+	[MT8188_VDO1_RST_VDO0_DSC_TO_VDO1_DL_ASYNC]	= MMSYS_RST_NR(1, 18),
+	[MT8188_VDO1_RST_VDO0_MERGE_TO_VDO1_DL_ASYNC]	= MMSYS_RST_NR(1, 19),
+	[MT8188_VDO1_RST_PADDING0]			= MMSYS_RST_NR(1, 20),
+	[MT8188_VDO1_RST_PADDING1]			= MMSYS_RST_NR(1, 21),
+	[MT8188_VDO1_RST_PADDING2]			= MMSYS_RST_NR(1, 22),
+	[MT8188_VDO1_RST_PADDING3]			= MMSYS_RST_NR(1, 23),
+	[MT8188_VDO1_RST_PADDING4]			= MMSYS_RST_NR(1, 24),
+	[MT8188_VDO1_RST_PADDING5]			= MMSYS_RST_NR(1, 25),
+	[MT8188_VDO1_RST_PADDING6]			= MMSYS_RST_NR(1, 26),
+	[MT8188_VDO1_RST_PADDING7]			= MMSYS_RST_NR(1, 27),
+	[MT8188_VDO1_RST_DISP_RSZ0]			= MMSYS_RST_NR(1, 28),
+	[MT8188_VDO1_RST_DISP_RSZ1]			= MMSYS_RST_NR(1, 29),
+	[MT8188_VDO1_RST_DISP_RSZ2]			= MMSYS_RST_NR(1, 30),
+	[MT8188_VDO1_RST_DISP_RSZ3]			= MMSYS_RST_NR(1, 31),
+	[MT8188_VDO1_RST_HDR_VDO_FE0]			= MMSYS_RST_NR(2, 0),
+	[MT8188_VDO1_RST_HDR_GFX_FE0]			= MMSYS_RST_NR(2, 1),
+	[MT8188_VDO1_RST_HDR_VDO_BE]			= MMSYS_RST_NR(2, 2),
+	[MT8188_VDO1_RST_HDR_VDO_FE1]			= MMSYS_RST_NR(2, 16),
+	[MT8188_VDO1_RST_HDR_GFX_FE1]			= MMSYS_RST_NR(2, 17),
+	[MT8188_VDO1_RST_DISP_MIXER]			= MMSYS_RST_NR(2, 18),
+	[MT8188_VDO1_RST_HDR_VDO_FE0_DL_ASYNC]		= MMSYS_RST_NR(2, 19),
+	[MT8188_VDO1_RST_HDR_VDO_FE1_DL_ASYNC]		= MMSYS_RST_NR(2, 20),
+	[MT8188_VDO1_RST_HDR_GFX_FE0_DL_ASYNC]		= MMSYS_RST_NR(2, 21),
+	[MT8188_VDO1_RST_HDR_GFX_FE1_DL_ASYNC]		= MMSYS_RST_NR(2, 22),
+	[MT8188_VDO1_RST_HDR_VDO_BE_DL_ASYNC]		= MMSYS_RST_NR(2, 23),
+};
+
 static const struct mtk_mmsys_routes mmsys_mt8188_routing_table[] = {
 	{
 		DDP_COMPONENT_OVL0, DDP_COMPONENT_RDMA0,
@@ -146,4 +280,80 @@ static const struct mtk_mmsys_routes mmsys_mt8188_routing_table[] = {
 	},
 };
 
+static const struct mtk_mmsys_routes mmsys_mt8188_vdo1_routing_table[] = {
+	{
+		DDP_COMPONENT_MDP_RDMA0, DDP_COMPONENT_MERGE1,
+		MT8188_VDO1_VPP_MERGE0_P0_SEL_IN, GENMASK(0, 0),
+		MT8188_VPP_MERGE0_P0_SEL_IN_FROM_MDP_RDMA0
+	}, {
+		DDP_COMPONENT_MDP_RDMA1, DDP_COMPONENT_MERGE1,
+		MT8188_VDO1_VPP_MERGE0_P1_SEL_IN, GENMASK(0, 0),
+		MT8188_VPP_MERGE0_P1_SEL_IN_FROM_MDP_RDMA1
+	}, {
+		DDP_COMPONENT_MDP_RDMA2, DDP_COMPONENT_MERGE2,
+		MT8188_VDO1_VPP_MERGE1_P0_SEL_IN, GENMASK(0, 0),
+		MT8188_VPP_MERGE1_P0_SEL_IN_FROM_MDP_RDMA2
+	}, {
+		DDP_COMPONENT_MERGE1, DDP_COMPONENT_ETHDR_MIXER,
+		MT8188_VDO1_MERGE0_ASYNC_SOUT_SEL, GENMASK(1, 0),
+		MT8188_SOUT_TO_MIXER_IN1_SEL
+	}, {
+		DDP_COMPONENT_MERGE2, DDP_COMPONENT_ETHDR_MIXER,
+		MT8188_VDO1_MERGE1_ASYNC_SOUT_SEL, GENMASK(1, 0),
+		MT8188_SOUT_TO_MIXER_IN2_SEL
+	}, {
+		DDP_COMPONENT_MERGE3, DDP_COMPONENT_ETHDR_MIXER,
+		MT8188_VDO1_MERGE2_ASYNC_SOUT_SEL, GENMASK(1, 0),
+		MT8188_SOUT_TO_MIXER_IN3_SEL
+	}, {
+		DDP_COMPONENT_MERGE4, DDP_COMPONENT_ETHDR_MIXER,
+		MT8188_VDO1_MERGE3_ASYNC_SOUT_SEL, GENMASK(1, 0),
+		MT8188_SOUT_TO_MIXER_IN4_SEL
+	}, {
+		DDP_COMPONENT_ETHDR_MIXER, DDP_COMPONENT_MERGE5,
+		MT8188_VDO1_MIXER_OUT_SOUT_SEL, GENMASK(0, 0),
+		MT8188_MIXER_SOUT_TO_MERGE4_ASYNC_SEL
+	}, {
+		DDP_COMPONENT_MERGE1, DDP_COMPONENT_ETHDR_MIXER,
+		MT8188_VDO1_MIXER_IN1_SEL_IN, GENMASK(0, 0),
+		MT8188_MIXER_IN1_SEL_IN_FROM_MERGE0_ASYNC_SOUT
+	}, {
+		DDP_COMPONENT_MERGE2, DDP_COMPONENT_ETHDR_MIXER,
+		MT8188_VDO1_MIXER_IN2_SEL_IN, GENMASK(0, 0),
+		MT8188_MIXER_IN2_SEL_IN_FROM_MERGE1_ASYNC_SOUT
+	}, {
+		DDP_COMPONENT_MERGE3, DDP_COMPONENT_ETHDR_MIXER,
+		MT8188_VDO1_MIXER_IN3_SEL_IN, GENMASK(0, 0),
+		MT8188_MIXER_IN3_SEL_IN_FROM_MERGE2_ASYNC_SOUT
+	}, {
+		DDP_COMPONENT_MERGE4, DDP_COMPONENT_ETHDR_MIXER,
+		MT8188_VDO1_MIXER_IN4_SEL_IN, GENMASK(0, 0),
+		MT8188_MIXER_IN4_SEL_IN_FROM_MERGE3_ASYNC_SOUT
+	}, {
+		DDP_COMPONENT_ETHDR_MIXER, DDP_COMPONENT_MERGE5,
+		MT8188_VDO1_MIXER_SOUT_SEL_IN, GENMASK(2, 0),
+		MT8188_MIXER_SOUT_SEL_IN_FROM_DISP_MIXER
+	}, {
+		DDP_COMPONENT_ETHDR_MIXER, DDP_COMPONENT_MERGE5,
+		MT8188_VDO1_MERGE4_ASYNC_SEL_IN, GENMASK(2, 0),
+		MT8188_MERGE4_ASYNC_SEL_IN_FROM_MIXER_OUT_SOUT
+	}, {
+		DDP_COMPONENT_MERGE5, DDP_COMPONENT_DPI1,
+		MT8188_VDO1_DISP_DPI1_SEL_IN, GENMASK(1, 0),
+		MT8188_DISP_DPI1_SEL_IN_FROM_VPP_MERGE4_MOUT
+	}, {
+		DDP_COMPONENT_MERGE5, DDP_COMPONENT_DPI1,
+		MT8188_VDO1_MERGE4_SOUT_SEL, GENMASK(1, 0),
+		MT8188_MERGE4_SOUT_TO_DPI1_SEL
+	}, {
+		DDP_COMPONENT_MERGE5, DDP_COMPONENT_DP_INTF1,
+		MT8188_VDO1_DISP_DP_INTF0_SEL_IN, GENMASK(1, 0),
+		MT8188_DISP_DP_INTF0_SEL_IN_FROM_VPP_MERGE4_MOUT
+	}, {
+		DDP_COMPONENT_MERGE5, DDP_COMPONENT_DP_INTF1,
+		MT8188_VDO1_MERGE4_SOUT_SEL, GENMASK(3, 0),
+		MT8188_MERGE4_SOUT_TO_DP_INTF0_SEL
+	}
+};
+
 #endif /* __SOC_MEDIATEK_MT8188_MMSYS_H */
diff --git a/drivers/soc/mediatek/mt8188-pm-domains.h b/drivers/soc/mediatek/mt8188-pm-domains.h
index 0692cb444ed020c260c7155ebee234fc3e4b1bfd..e6dbdc0aa6841e2e328602edf0755c8b3a243ee6 100644
--- a/drivers/soc/mediatek/mt8188-pm-domains.h
+++ b/drivers/soc/mediatek/mt8188-pm-domains.h
@@ -165,6 +165,8 @@ static const struct scpsys_domain_data scpsys_domain_data_mt8188[] = {
 		.ctl_offs = 0x35C,
 		.pwr_sta_offs = 0x16C,
 		.pwr_sta2nd_offs = 0x170,
+		.ext_buck_iso_offs = 0x3EC,
+		.ext_buck_iso_mask = BIT(10),
 		.bp_infracfg = {
 			BUS_PROT_WR(MT8188_TOP_AXI_PROT_EN_2_ADSP_AO_STEP1,
 				    MT8188_TOP_AXI_PROT_EN_2_SET,
@@ -175,7 +177,7 @@ static const struct scpsys_domain_data scpsys_domain_data_mt8188[] = {
 				    MT8188_TOP_AXI_PROT_EN_2_CLR,
 				    MT8188_TOP_AXI_PROT_EN_2_STA),
 		},
-		.caps = MTK_SCPD_ALWAYS_ON,
+		.caps = MTK_SCPD_ALWAYS_ON | MTK_SCPD_EXT_BUCK_ISO,
 	},
 	[MT8188_POWER_DOMAIN_ADSP_INFRA] = {
 		.name = "adsp_infra",
@@ -479,6 +481,8 @@ static const struct scpsys_domain_data scpsys_domain_data_mt8188[] = {
 		.ctl_offs = 0x3A4,
 		.pwr_sta_offs = 0x16C,
 		.pwr_sta2nd_offs = 0x170,
+		.ext_buck_iso_offs = 0x3EC,
+		.ext_buck_iso_mask = BIT(12),
 		.bp_infracfg = {
 			BUS_PROT_WR(MT8188_TOP_AXI_PROT_EN_MM_IMG_VCORE_STEP1,
 				    MT8188_TOP_AXI_PROT_EN_MM_SET,
@@ -493,7 +497,8 @@ static const struct scpsys_domain_data scpsys_domain_data_mt8188[] = {
 				    MT8188_TOP_AXI_PROT_EN_MM_2_CLR,
 				    MT8188_TOP_AXI_PROT_EN_MM_2_STA),
 		},
-		.caps = MTK_SCPD_KEEP_DEFAULT_OFF | MTK_SCPD_DOMAIN_SUPPLY,
+		.caps = MTK_SCPD_KEEP_DEFAULT_OFF | MTK_SCPD_DOMAIN_SUPPLY |
+			MTK_SCPD_EXT_BUCK_ISO,
 	},
 	[MT8188_POWER_DOMAIN_IMG_MAIN] = {
 		.name = "img_main",
@@ -541,6 +546,8 @@ static const struct scpsys_domain_data scpsys_domain_data_mt8188[] = {
 		.ctl_offs = 0x3A0,
 		.pwr_sta_offs = 0x16C,
 		.pwr_sta2nd_offs = 0x170,
+		.ext_buck_iso_offs = 0x3EC,
+		.ext_buck_iso_mask = BIT(11),
 		.bp_infracfg = {
 			BUS_PROT_WR(MT8188_TOP_AXI_PROT_EN_MM_CAM_VCORE_STEP1,
 				    MT8188_TOP_AXI_PROT_EN_MM_SET,
@@ -563,7 +570,8 @@ static const struct scpsys_domain_data scpsys_domain_data_mt8188[] = {
 				    MT8188_TOP_AXI_PROT_EN_MM_2_CLR,
 				    MT8188_TOP_AXI_PROT_EN_MM_2_STA),
 		},
-		.caps = MTK_SCPD_KEEP_DEFAULT_OFF | MTK_SCPD_DOMAIN_SUPPLY,
+		.caps = MTK_SCPD_KEEP_DEFAULT_OFF | MTK_SCPD_DOMAIN_SUPPLY |
+			MTK_SCPD_EXT_BUCK_ISO,
 	},
 	[MT8188_POWER_DOMAIN_CAM_MAIN] = {
 		.name = "cam_main",
diff --git a/drivers/soc/mediatek/mtk-cmdq-helper.c b/drivers/soc/mediatek/mtk-cmdq-helper.c
index c1837a468267372eb588a087c630cd7ad605e9ce..17b731b476901954eab3b9c1528b3142e41f79a3 100644
--- a/drivers/soc/mediatek/mtk-cmdq-helper.c
+++ b/drivers/soc/mediatek/mtk-cmdq-helper.c
@@ -15,27 +15,31 @@
 #define CMDQ_REG_TYPE		1
 #define CMDQ_JUMP_RELATIVE	1
 
+#define CMDQ_GET_ARG_B(arg)		(((arg) & GENMASK(31, 16)) >> 16)
+#define CMDQ_GET_ARG_C(arg)		((arg) & GENMASK(15, 0))
+
 struct cmdq_instruction {
 	union {
 		u32 value;
 		u32 mask;
 		struct {
 			u16 arg_c;
-			u16 src_reg;
+			u16 arg_b;
 		};
 	};
 	union {
 		u16 offset;
 		u16 event;
 		u16 reg_dst;
+		u16 arg_a;
 	};
 	union {
 		u8 subsys;
 		struct {
-			u8 sop:5;
-			u8 arg_c_t:1;
-			u8 src_t:1;
-			u8 dst_t:1;
+			u8 s_op:5;
+			u8 arg_c_type:1;
+			u8 arg_b_type:1;
+			u8 arg_a_type:1;
 		};
 	};
 	u8 op;
@@ -216,25 +220,56 @@ int cmdq_pkt_read_s(struct cmdq_pkt *pkt, u16 high_addr_reg_idx, u16 addr_low,
 	struct cmdq_instruction inst = {};
 
 	inst.op = CMDQ_CODE_READ_S;
-	inst.dst_t = CMDQ_REG_TYPE;
-	inst.sop = high_addr_reg_idx;
+	inst.arg_a_type = CMDQ_REG_TYPE;
+	inst.s_op = high_addr_reg_idx;
 	inst.reg_dst = reg_idx;
-	inst.src_reg = addr_low;
+	inst.arg_b = addr_low;
 
 	return cmdq_pkt_append_command(pkt, inst);
 }
 EXPORT_SYMBOL(cmdq_pkt_read_s);
 
+int cmdq_pkt_read_reg(struct cmdq_pkt *pkt, u8 subsys, u16 offset,
+	u16 dst_reg_idx)
+{
+	struct cmdq_instruction inst = {};
+
+	inst.arg_c = 0;
+	inst.arg_b = offset;
+	inst.arg_a = dst_reg_idx;
+	inst.s_op = subsys;
+	inst.arg_c_type = 0;
+	inst.arg_b_type = 0;
+	inst.arg_a_type = CMDQ_REG_TYPE;
+	inst.op = CMDQ_CODE_READ_S;
+	return cmdq_pkt_append_command(pkt, inst);
+}
+EXPORT_SYMBOL(cmdq_pkt_read_reg);
+
+int cmdq_pkt_read_addr(struct cmdq_pkt *pkt, dma_addr_t addr, u16 dst_reg_idx)
+{
+	s32 err;
+	const u16 src_reg_idx = CMDQ_SPR_FOR_TEMP;
+
+	err = cmdq_pkt_assign(pkt, src_reg_idx, CMDQ_ADDR_HIGH(addr));
+	if (err < 0)
+		return err;
+
+	return cmdq_pkt_read_s(pkt, src_reg_idx, CMDQ_ADDR_LOW(addr),
+			       dst_reg_idx);
+}
+EXPORT_SYMBOL(cmdq_pkt_read_addr);
+
 int cmdq_pkt_write_s(struct cmdq_pkt *pkt, u16 high_addr_reg_idx,
 		     u16 addr_low, u16 src_reg_idx)
 {
 	struct cmdq_instruction inst = {};
 
 	inst.op = CMDQ_CODE_WRITE_S;
-	inst.src_t = CMDQ_REG_TYPE;
-	inst.sop = high_addr_reg_idx;
+	inst.arg_b_type = CMDQ_REG_TYPE;
+	inst.s_op = high_addr_reg_idx;
 	inst.offset = addr_low;
-	inst.src_reg = src_reg_idx;
+	inst.arg_b = src_reg_idx;
 
 	return cmdq_pkt_append_command(pkt, inst);
 }
@@ -254,10 +289,10 @@ int cmdq_pkt_write_s_mask(struct cmdq_pkt *pkt, u16 high_addr_reg_idx,
 
 	inst.mask = 0;
 	inst.op = CMDQ_CODE_WRITE_S_MASK;
-	inst.src_t = CMDQ_REG_TYPE;
-	inst.sop = high_addr_reg_idx;
+	inst.arg_b_type = CMDQ_REG_TYPE;
+	inst.s_op = high_addr_reg_idx;
 	inst.offset = addr_low;
-	inst.src_reg = src_reg_idx;
+	inst.arg_b = src_reg_idx;
 
 	return cmdq_pkt_append_command(pkt, inst);
 }
@@ -269,7 +304,7 @@ int cmdq_pkt_write_s_value(struct cmdq_pkt *pkt, u8 high_addr_reg_idx,
 	struct cmdq_instruction inst = {};
 
 	inst.op = CMDQ_CODE_WRITE_S;
-	inst.sop = high_addr_reg_idx;
+	inst.s_op = high_addr_reg_idx;
 	inst.offset = addr_low;
 	inst.value = value;
 
@@ -290,7 +325,7 @@ int cmdq_pkt_write_s_mask_value(struct cmdq_pkt *pkt, u8 high_addr_reg_idx,
 		return err;
 
 	inst.op = CMDQ_CODE_WRITE_S_MASK;
-	inst.sop = high_addr_reg_idx;
+	inst.s_op = high_addr_reg_idx;
 	inst.offset = addr_low;
 	inst.value = value;
 
@@ -298,6 +333,61 @@ int cmdq_pkt_write_s_mask_value(struct cmdq_pkt *pkt, u8 high_addr_reg_idx,
 }
 EXPORT_SYMBOL(cmdq_pkt_write_s_mask_value);
 
+int cmdq_pkt_write_reg_addr(struct cmdq_pkt *pkt, dma_addr_t addr,
+			    u16 src_reg_idx, u32 mask)
+{
+	s32 err;
+	const u16 dst_reg_idx = CMDQ_SPR_FOR_TEMP;
+
+	err = cmdq_pkt_assign(pkt, dst_reg_idx,
+			      CMDQ_ADDR_HIGH(addr));
+	if (err < 0)
+		return err;
+
+	if (mask != CMDQ_NO_MASK)
+		return cmdq_pkt_write_s(pkt, dst_reg_idx,
+						   CMDQ_ADDR_LOW(addr), src_reg_idx);
+
+	return cmdq_pkt_write_s_mask(pkt, dst_reg_idx,
+				     CMDQ_ADDR_LOW(addr), src_reg_idx, mask);
+}
+EXPORT_SYMBOL(cmdq_pkt_write_reg_addr);
+
+int cmdq_pkt_write_value_addr(struct cmdq_pkt *pkt, dma_addr_t addr,
+			      u32 value, u32 mask)
+{
+	s32 err;
+	const u16 dst_reg_idx = CMDQ_SPR_FOR_TEMP;
+
+	/* assign high bit to spr temp */
+	err = cmdq_pkt_assign(pkt, dst_reg_idx,
+		CMDQ_ADDR_HIGH(addr));
+	if (err < 0)
+		return err;
+
+	if (mask != CMDQ_NO_MASK)
+		return cmdq_pkt_write_s_mask_value(pkt, dst_reg_idx,
+						   CMDQ_ADDR_LOW(addr), value, mask);
+
+	return cmdq_pkt_write_s_value(pkt, dst_reg_idx,
+				      CMDQ_ADDR_LOW(addr), value);
+}
+EXPORT_SYMBOL(cmdq_pkt_write_value_addr);
+
+s32 cmdq_pkt_mem_move(struct cmdq_pkt *pkt, dma_addr_t src_addr,
+		      dma_addr_t dst_addr, u16 swap_reg_idx)
+{
+	s32 err;
+
+	err = cmdq_pkt_read_addr(pkt, src_addr, swap_reg_idx);
+	if (err != 0)
+		return err;
+
+	return cmdq_pkt_write_reg_addr(pkt, dst_addr,
+				       swap_reg_idx, CMDQ_NO_MASK);
+}
+EXPORT_SYMBOL(cmdq_pkt_mem_move);
+
 int cmdq_pkt_wfe(struct cmdq_pkt *pkt, u16 event, bool clear)
 {
 	struct cmdq_instruction inst = { {0} };
@@ -344,6 +434,21 @@ int cmdq_pkt_set_event(struct cmdq_pkt *pkt, u16 event)
 }
 EXPORT_SYMBOL(cmdq_pkt_set_event);
 
+int cmdq_pkt_acquire_event(struct cmdq_pkt *pkt, u16 event)
+{
+	struct cmdq_instruction inst = {};
+
+	if (event >= CMDQ_MAX_EVENT)
+		return -EINVAL;
+
+	inst.op = CMDQ_CODE_WFE;
+	inst.value = CMDQ_WFE_UPDATE | CMDQ_WFE_UPDATE_VALUE | CMDQ_WFE_WAIT;
+	inst.event = event;
+
+	return cmdq_pkt_append_command(pkt, inst);
+}
+EXPORT_SYMBOL(cmdq_pkt_acquire_event);
+
 int cmdq_pkt_poll(struct cmdq_pkt *pkt, u8 subsys,
 		  u16 offset, u32 value)
 {
@@ -379,12 +484,60 @@ int cmdq_pkt_poll_mask(struct cmdq_pkt *pkt, u8 subsys,
 }
 EXPORT_SYMBOL(cmdq_pkt_poll_mask);
 
+int cmdq_pkt_poll_addr(struct cmdq_pkt *pkt, u32 value, u32 addr,
+		       u32 mask, u8 reg_gpr)
+{
+	struct cmdq_instruction inst = { {0} };
+	int err;
+	u8 use_mask = 0;
+
+	if (mask != CMDQ_NO_MASK) {
+		inst.arg_c = CMDQ_GET_ARG_C(~mask);
+		inst.arg_b = CMDQ_GET_ARG_B(~mask);
+		inst.arg_a = 0;
+		inst.s_op = 0;
+		inst.arg_c = 0;
+		inst.arg_b = 0;
+		inst.arg_a = 1;
+		inst.op = CMDQ_CODE_MASK;
+		err = cmdq_pkt_append_command(pkt, inst);
+		if (err != 0)
+			return err;
+
+		use_mask = 1;
+	}
+
+	/* Move extra handle APB address to GPR */
+	inst.arg_c = CMDQ_GET_ARG_C(addr);
+	inst.arg_b = CMDQ_GET_ARG_B(addr);
+	inst.arg_a = 0;
+	inst.s_op = reg_gpr;
+	inst.arg_c = 0;
+	inst.arg_b = 0;
+	inst.arg_a = 1;
+	inst.op = CMDQ_CODE_MOVE;
+	err = cmdq_pkt_append_command(pkt, inst);
+	if (err < 0)
+		return err;
+
+	inst.arg_c = CMDQ_GET_ARG_C(value);
+	inst.arg_b = CMDQ_GET_ARG_B(value);
+	inst.arg_a = use_mask;
+	inst.s_op = reg_gpr;
+	inst.arg_c = 0;
+	inst.arg_b = 0;
+	inst.arg_a = 1;
+	inst.op = CMDQ_CODE_POLL;
+	return cmdq_pkt_append_command(pkt, inst);
+}
+EXPORT_SYMBOL(cmdq_pkt_poll_addr);
+
 int cmdq_pkt_assign(struct cmdq_pkt *pkt, u16 reg_idx, u32 value)
 {
 	struct cmdq_instruction inst = {};
 
 	inst.op = CMDQ_CODE_LOGIC;
-	inst.dst_t = CMDQ_REG_TYPE;
+	inst.arg_a_type = CMDQ_REG_TYPE;
 	inst.reg_dst = reg_idx;
 	inst.value = value;
 	return cmdq_pkt_append_command(pkt, inst);
diff --git a/drivers/soc/mediatek/mtk-mmsys.c b/drivers/soc/mediatek/mtk-mmsys.c
index 9619faa796e8fee95324ee9f0b79d435ce4ec432..a456c3e0aee7afc39097deb19bdf51583f9f0d5d 100644
--- a/drivers/soc/mediatek/mtk-mmsys.c
+++ b/drivers/soc/mediatek/mtk-mmsys.c
@@ -87,6 +87,19 @@ static const struct mtk_mmsys_driver_data mt8188_vdosys0_driver_data = {
 	.clk_driver = "clk-mt8188-vdo0",
 	.routes = mmsys_mt8188_routing_table,
 	.num_routes = ARRAY_SIZE(mmsys_mt8188_routing_table),
+	.sw0_rst_offset = MT8188_VDO0_SW0_RST_B,
+	.rst_tb = mmsys_mt8188_vdo0_rst_tb,
+	.num_resets = ARRAY_SIZE(mmsys_mt8188_vdo0_rst_tb),
+};
+
+static const struct mtk_mmsys_driver_data mt8188_vdosys1_driver_data = {
+	.clk_driver = "clk-mt8188-vdo1",
+	.routes = mmsys_mt8188_vdo1_routing_table,
+	.num_routes = ARRAY_SIZE(mmsys_mt8188_vdo1_routing_table),
+	.sw0_rst_offset = MT8188_VDO1_SW0_RST_B,
+	.rst_tb = mmsys_mt8188_vdo1_rst_tb,
+	.num_resets = ARRAY_SIZE(mmsys_mt8188_vdo1_rst_tb),
+	.vsync_len = 1,
 };
 
 static const struct mtk_mmsys_driver_data mt8192_mmsys_driver_data = {
@@ -169,6 +182,10 @@ void mtk_mmsys_ddp_connect(struct device *dev,
 		if (cur == routes[i].from_comp && next == routes[i].to_comp)
 			mtk_mmsys_update_bits(mmsys, routes[i].addr, routes[i].mask,
 					      routes[i].val, NULL);
+
+	if (mmsys->data->vsync_len)
+		mtk_mmsys_update_bits(mmsys, MT8188_VDO1_MIXER_VSYNC_LEN, GENMASK(31, 0),
+				      mmsys->data->vsync_len, NULL);
 }
 EXPORT_SYMBOL_GPL(mtk_mmsys_ddp_connect);
 
@@ -302,6 +319,15 @@ static int mtk_mmsys_reset_update(struct reset_controller_dev *rcdev, unsigned l
 	u32 offset;
 	u32 reg;
 
+	if (mmsys->data->rst_tb) {
+		if (id >= mmsys->data->num_resets) {
+			dev_err(rcdev->dev, "Invalid reset ID: %lu (>=%u)\n",
+				id, mmsys->data->num_resets);
+			return -EINVAL;
+		}
+		id = mmsys->data->rst_tb[id];
+	}
+
 	offset = (id / MMSYS_SW_RESET_PER_REG) * sizeof(u32);
 	id = id % MMSYS_SW_RESET_PER_REG;
 	reg = mmsys->data->sw0_rst_offset + offset;
@@ -431,6 +457,7 @@ static const struct of_device_id of_match_mtk_mmsys[] = {
 	{ .compatible = "mediatek,mt8183-mmsys", .data = &mt8183_mmsys_driver_data },
 	{ .compatible = "mediatek,mt8186-mmsys", .data = &mt8186_mmsys_driver_data },
 	{ .compatible = "mediatek,mt8188-vdosys0", .data = &mt8188_vdosys0_driver_data },
+	{ .compatible = "mediatek,mt8188-vdosys1", .data = &mt8188_vdosys1_driver_data },
 	{ .compatible = "mediatek,mt8192-mmsys", .data = &mt8192_mmsys_driver_data },
 	/* "mediatek,mt8195-mmsys" compatible is deprecated */
 	{ .compatible = "mediatek,mt8195-mmsys", .data = &mt8195_vdosys0_driver_data },
diff --git a/drivers/soc/mediatek/mtk-mmsys.h b/drivers/soc/mediatek/mtk-mmsys.h
index 6725403d2e3ac4a91956c07276814445588fff3e..d370192737ca45ed480f2167dfb1ac94dd16baad 100644
--- a/drivers/soc/mediatek/mtk-mmsys.h
+++ b/drivers/soc/mediatek/mtk-mmsys.h
@@ -78,6 +78,8 @@
 #define DSI_SEL_IN_RDMA				0x1
 #define DSI_SEL_IN_MASK				0x1
 
+#define MMSYS_RST_NR(bank, bit) (((bank) * 32) + (bit))
+
 struct mtk_mmsys_routes {
 	u32 from_comp;
 	u32 to_comp;
@@ -86,13 +88,43 @@ struct mtk_mmsys_routes {
 	u32 val;
 };
 
+/**
+ * struct mtk_mmsys_driver_data - Settings of the mmsys
+ * @clk_driver: Clock driver name that the mmsys is using
+ *              (defined in drivers/clk/mediatek/clk-*.c).
+ * @routes: Routing table of the mmsys.
+ *          It provides mux settings from one module to another.
+ * @num_routes: Array size of the routes.
+ * @sw0_rst_offset: Register offset for the reset control.
+ * @num_resets: Number of reset bits that are defined
+ * @is_vppsys: Whether the mmsys is VPPSYS (Video Processing Pipe)
+ *             or VDOSYS (Video). Only VDOSYS needs to be added to drm driver.
+ * @vsync_len: VSYNC length of the MIXER.
+ *             VSYNC is usually triggered by the connector, so its length is a
+ *             fixed value when the frame rate is decided, but ETHDR and
+ *             MIXER generate their own VSYNC due to hardware design, therefore
+ *             MIXER has to sync with ETHDR by adjusting VSYNC length.
+ *             On MT8195, there is no such setting so we use the gap between
+ *             falling edge and rising edge of SOF (Start of Frame) signal to
+ *             do the job, but since MT8188, VSYNC_LEN setting is introduced to
+ *             solve the problem and is given 0x40 (ticks) as the default value.
+ *             Please notice that this value has to be set to 1 (minimum) if
+ *             ETHDR is bypassed, otherwise MIXER could wait too long and causing
+ *             underflow.
+ *
+ * Each MMSYS (multi-media system) may have different settings, they may use
+ * different clock sources, mux settings, reset control ...etc., and these
+ * differences are all stored here.
+ */
 struct mtk_mmsys_driver_data {
 	const char *clk_driver;
 	const struct mtk_mmsys_routes *routes;
 	const unsigned int num_routes;
 	const u16 sw0_rst_offset;
+	const u8 *rst_tb;
 	const u32 num_resets;
 	const bool is_vppsys;
+	const u8 vsync_len;
 };
 
 /*
diff --git a/drivers/soc/mediatek/mtk-mutex.c b/drivers/soc/mediatek/mtk-mutex.c
index b92cffec7be707d40e519bf4fe7ce038db2c8111..d52ce093adb71628f94452733a5a1485a79f528d 100644
--- a/drivers/soc/mediatek/mtk-mutex.c
+++ b/drivers/soc/mediatek/mtk-mutex.c
@@ -134,6 +134,30 @@
 #define MT8188_MUTEX_MOD_DISP_POSTMASK0		24
 #define MT8188_MUTEX_MOD2_DISP_PWM0		33
 
+#define MT8188_MUTEX_MOD_DISP1_MDP_RDMA0	0
+#define MT8188_MUTEX_MOD_DISP1_MDP_RDMA1	1
+#define MT8188_MUTEX_MOD_DISP1_MDP_RDMA2	2
+#define MT8188_MUTEX_MOD_DISP1_MDP_RDMA3	3
+#define MT8188_MUTEX_MOD_DISP1_MDP_RDMA4	4
+#define MT8188_MUTEX_MOD_DISP1_MDP_RDMA5	5
+#define MT8188_MUTEX_MOD_DISP1_MDP_RDMA6	6
+#define MT8188_MUTEX_MOD_DISP1_MDP_RDMA7	7
+#define MT8188_MUTEX_MOD_DISP1_PADDING0		8
+#define MT8188_MUTEX_MOD_DISP1_PADDING1		9
+#define MT8188_MUTEX_MOD_DISP1_PADDING2		10
+#define MT8188_MUTEX_MOD_DISP1_PADDING3		11
+#define MT8188_MUTEX_MOD_DISP1_PADDING4		12
+#define MT8188_MUTEX_MOD_DISP1_PADDING5		13
+#define MT8188_MUTEX_MOD_DISP1_PADDING6		14
+#define MT8188_MUTEX_MOD_DISP1_PADDING7		15
+#define MT8188_MUTEX_MOD_DISP1_VPP_MERGE0	20
+#define MT8188_MUTEX_MOD_DISP1_VPP_MERGE1	21
+#define MT8188_MUTEX_MOD_DISP1_VPP_MERGE2	22
+#define MT8188_MUTEX_MOD_DISP1_VPP_MERGE3	23
+#define MT8188_MUTEX_MOD_DISP1_VPP_MERGE4	24
+#define MT8188_MUTEX_MOD_DISP1_DISP_MIXER	30
+#define MT8188_MUTEX_MOD_DISP1_DP_INTF1		39
+
 #define MT8195_MUTEX_MOD_DISP_OVL0		0
 #define MT8195_MUTEX_MOD_DISP_WDMA0		1
 #define MT8195_MUTEX_MOD_DISP_RDMA0		2
@@ -265,6 +289,7 @@
 #define MT8183_MUTEX_SOF_DPI0			2
 #define MT8188_MUTEX_SOF_DSI0			1
 #define MT8188_MUTEX_SOF_DP_INTF0		3
+#define MT8188_MUTEX_SOF_DP_INTF1		4
 #define MT8195_MUTEX_SOF_DSI0			1
 #define MT8195_MUTEX_SOF_DSI1			2
 #define MT8195_MUTEX_SOF_DP_INTF0		3
@@ -276,6 +301,7 @@
 #define MT8183_MUTEX_EOF_DPI0			(MT8183_MUTEX_SOF_DPI0 << 6)
 #define MT8188_MUTEX_EOF_DSI0			(MT8188_MUTEX_SOF_DSI0 << 7)
 #define MT8188_MUTEX_EOF_DP_INTF0		(MT8188_MUTEX_SOF_DP_INTF0 << 7)
+#define MT8188_MUTEX_EOF_DP_INTF1		(MT8188_MUTEX_SOF_DP_INTF1 << 7)
 #define MT8195_MUTEX_EOF_DSI0			(MT8195_MUTEX_SOF_DSI0 << 7)
 #define MT8195_MUTEX_EOF_DSI1			(MT8195_MUTEX_SOF_DSI1 << 7)
 #define MT8195_MUTEX_EOF_DP_INTF0		(MT8195_MUTEX_SOF_DP_INTF0 << 7)
@@ -446,6 +472,29 @@ static const unsigned int mt8188_mutex_mod[DDP_COMPONENT_ID_MAX] = {
 	[DDP_COMPONENT_DSI0] = MT8188_MUTEX_MOD_DISP_DSI0,
 	[DDP_COMPONENT_PWM0] = MT8188_MUTEX_MOD2_DISP_PWM0,
 	[DDP_COMPONENT_DP_INTF0] = MT8188_MUTEX_MOD_DISP_DP_INTF0,
+	[DDP_COMPONENT_DP_INTF1] = MT8188_MUTEX_MOD_DISP1_DP_INTF1,
+	[DDP_COMPONENT_ETHDR_MIXER] = MT8188_MUTEX_MOD_DISP1_DISP_MIXER,
+	[DDP_COMPONENT_MDP_RDMA0] = MT8188_MUTEX_MOD_DISP1_MDP_RDMA0,
+	[DDP_COMPONENT_MDP_RDMA1] = MT8188_MUTEX_MOD_DISP1_MDP_RDMA1,
+	[DDP_COMPONENT_MDP_RDMA2] = MT8188_MUTEX_MOD_DISP1_MDP_RDMA2,
+	[DDP_COMPONENT_MDP_RDMA3] = MT8188_MUTEX_MOD_DISP1_MDP_RDMA3,
+	[DDP_COMPONENT_MDP_RDMA4] = MT8188_MUTEX_MOD_DISP1_MDP_RDMA4,
+	[DDP_COMPONENT_MDP_RDMA5] = MT8188_MUTEX_MOD_DISP1_MDP_RDMA5,
+	[DDP_COMPONENT_MDP_RDMA6] = MT8188_MUTEX_MOD_DISP1_MDP_RDMA6,
+	[DDP_COMPONENT_MDP_RDMA7] = MT8188_MUTEX_MOD_DISP1_MDP_RDMA7,
+	[DDP_COMPONENT_PADDING0] = MT8188_MUTEX_MOD_DISP1_PADDING0,
+	[DDP_COMPONENT_PADDING1] = MT8188_MUTEX_MOD_DISP1_PADDING1,
+	[DDP_COMPONENT_PADDING2] = MT8188_MUTEX_MOD_DISP1_PADDING2,
+	[DDP_COMPONENT_PADDING3] = MT8188_MUTEX_MOD_DISP1_PADDING3,
+	[DDP_COMPONENT_PADDING4] = MT8188_MUTEX_MOD_DISP1_PADDING4,
+	[DDP_COMPONENT_PADDING5] = MT8188_MUTEX_MOD_DISP1_PADDING5,
+	[DDP_COMPONENT_PADDING6] = MT8188_MUTEX_MOD_DISP1_PADDING6,
+	[DDP_COMPONENT_PADDING7] = MT8188_MUTEX_MOD_DISP1_PADDING7,
+	[DDP_COMPONENT_MERGE1] = MT8188_MUTEX_MOD_DISP1_VPP_MERGE0,
+	[DDP_COMPONENT_MERGE2] = MT8188_MUTEX_MOD_DISP1_VPP_MERGE1,
+	[DDP_COMPONENT_MERGE3] = MT8188_MUTEX_MOD_DISP1_VPP_MERGE2,
+	[DDP_COMPONENT_MERGE4] = MT8188_MUTEX_MOD_DISP1_VPP_MERGE3,
+	[DDP_COMPONENT_MERGE5] = MT8188_MUTEX_MOD_DISP1_VPP_MERGE4,
 };
 
 static const unsigned int mt8192_mutex_mod[DDP_COMPONENT_ID_MAX] = {
@@ -606,6 +655,8 @@ static const unsigned int mt8188_mutex_sof[DDP_MUTEX_SOF_MAX] = {
 		MT8188_MUTEX_SOF_DSI0 | MT8188_MUTEX_EOF_DSI0,
 	[MUTEX_SOF_DP_INTF0] =
 		MT8188_MUTEX_SOF_DP_INTF0 | MT8188_MUTEX_EOF_DP_INTF0,
+	[MUTEX_SOF_DP_INTF1] =
+		MT8188_MUTEX_SOF_DP_INTF1 | MT8188_MUTEX_EOF_DP_INTF1,
 };
 
 static const unsigned int mt8195_mutex_sof[DDP_MUTEX_SOF_MAX] = {
diff --git a/drivers/soc/mediatek/mtk-socinfo.c b/drivers/soc/mediatek/mtk-socinfo.c
new file mode 100644
index 0000000000000000000000000000000000000000..406ef54b31ad9f2a273d615032f76b76b60378b5
--- /dev/null
+++ b/drivers/soc/mediatek/mtk-socinfo.c
@@ -0,0 +1,248 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2023 MediaTek Inc.
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_platform.h>
+#include <linux/pm_runtime.h>
+#include <linux/nvmem-consumer.h>
+#include <linux/device.h>
+#include <linux/debugfs.h>
+#include <linux/seq_file.h>
+#include <linux/string.h>
+#include <linux/sys_soc.h>
+#include "mtk-socinfo.h"
+
+
+static int get_soc_data (char* soc_data, struct efuse_data **efuse_data_infop, 			\
+						struct name_data **name_data_infop, unsigned int *efuse_segment_countp, unsigned int *efuse_data_countp)
+{
+	int status = 0;
+	if (strcmp(soc_data, "mt8186") == 0) {
+		*efuse_data_infop = &(mtk_mt8186_efuse_data_info[0][0]);
+		*name_data_infop = mtk_mt8186_name_data_info;
+		*efuse_segment_countp = MT8186_LAST_INDEX;
+		*efuse_data_countp = mtk_mt8186_EFUSE_DATA_COUNT;
+	}
+	else if (strcmp(soc_data, "mt8188") == 0) {
+		*efuse_data_infop = &(mtk_mt8188_efuse_data_info[0][0]);
+		*name_data_infop = mtk_mt8188_name_data_info;
+		*efuse_segment_countp = MT8188_LAST_INDEX;
+		*efuse_data_countp = mtk_mt8188_EFUSE_DATA_COUNT;
+	}
+	else if (strcmp(soc_data, "mt8195") == 0) {
+		*efuse_data_infop = &(mtk_mt8195_efuse_data_info[0][0]);
+		*name_data_infop = mtk_mt8195_name_data_info;
+		*efuse_segment_countp = MT8195_LAST_INDEX;
+		*efuse_data_countp = mtk_mt8195_EFUSE_DATA_COUNT;
+	}
+	else {
+		status = -1;
+	}
+	return status;
+}
+
+#if IS_ENABLED(MTK_SOCINFO_DEBUG)
+// cat /sys/kernel/debug/mtk-socinfo/socinfo
+static int mtk_socinfo_socinfo_debug_show(struct seq_file *m, void *p)
+{
+// mtk_socinfop related
+	struct mtk_socinfo *mtk_socinfop = (struct mtk_socinfo *)m->private;
+
+	seq_printf(m, "SOC Manufacturer:   %s\n", soc_manufacturer);
+	seq_printf(m, "SOC Name:           %s\n", mtk_socinfop->name_data->soc_name);
+	seq_printf(m, "SOC segment Name:   %s\n", mtk_socinfop->name_data->soc_segment_name);
+	seq_printf(m, "Marketing Name:     %s\n", mtk_socinfop->name_data->marketing_name);
+
+	return 0;
+}
+DEBUG_FOPS_RO(socinfo);
+
+
+static int mtk_socinfo_create_debug_cmds(struct mtk_socinfo *mtk_socinfop)
+{
+	struct dentry *mtk_socinfo_dir,  *file_entry;
+	const char *d = "/sys/kernel/debug/mtk-socinfo";
+
+	struct mtk_socinfo_dentry {
+		const char *name;
+		const struct file_operations *fops;
+	};
+
+	struct mtk_socinfo_dentry mtk_socinfo_entries[] = {
+		MTK_SOCINFO_DENTRY_DATA(socinfo),
+	};
+
+	mtk_socinfo_dir = debugfs_create_dir("mtk-socinfo", NULL);
+	if (IS_ERR(mtk_socinfo_dir)) {
+		dev_err(mtk_socinfop->dev, "%s Cannot create %s\n", MODULE_NAME, d);
+		return 0;
+	}
+
+	file_entry = debugfs_create_file(mtk_socinfo_entries[0].name, 0664,
+						mtk_socinfo_dir, mtk_socinfop,
+						mtk_socinfo_entries[0].fops);
+	if (IS_ERR(file_entry)) {
+			dev_err(mtk_socinfop->dev, "%s Cannot create %s/%s\n", MODULE_NAME, d, mtk_socinfo_entries[0].name);
+		return PTR_ERR(file_entry);
+	}
+	return 0;
+}
+#endif
+
+// cat /sys/devices/socX/
+static int mtk_socinfo_create_socinfo_node(struct mtk_socinfo *mtk_socinfop)
+{
+	struct soc_device_attribute *attrs;
+	struct soc_device *soc_dev;
+	static char machine[30] = {0};
+	const char *d = "/sys/devices/soc1/";
+
+
+	attrs = devm_kzalloc(mtk_socinfop->dev, sizeof(*attrs), GFP_KERNEL);
+	if (!attrs) {
+		dev_err(mtk_socinfop->dev, "%s Cannot create %s, soc_device_attribute failed\n", MODULE_NAME, d);
+		return -ENODEV;
+	}
+
+	sprintf(machine, "%s (%s)", mtk_socinfop->name_data->marketing_name, mtk_socinfop->name_data->soc_name);
+	attrs->family = soc_manufacturer;
+	attrs->machine = machine;
+
+	soc_dev = soc_device_register(attrs);
+	if (IS_ERR(soc_dev)) {
+		dev_err(mtk_socinfop->dev, "%s Cannot create %s, soc_device_register failed\n", MODULE_NAME, d);
+		return PTR_ERR(soc_dev);
+	}
+
+	pr_info("%s %s SoC detected.\n", MODULE_NAME, attrs->machine);
+	return 0;
+}
+
+static int mtk_socinfo_get_socinfo_data(struct mtk_socinfo *mtk_socinfop)
+{
+// soc related
+	struct efuse_data *soc_efuse_data_infop = NULL;
+	struct name_data *soc_name_data_infop = NULL;
+	unsigned int soc_efuse_data_count = 0;
+	unsigned int soc_segment_count = 0;
+	int get_soc_status = 0;
+// loop related
+	unsigned int i = 0, j = 0;
+	struct efuse_data *soc_temp_efuse_datap;
+// nvmem retrieval related
+	struct nvmem_cell *cell;
+	size_t efuse_bytes;
+	char *nvmem_cell_name = "";
+	u32 *efuse_temp_bufp;
+// match related
+	bool match_segment = true;
+	bool match_segment_index = -1;
+
+	get_soc_status = get_soc_data(mtk_socinfop->soc_data, &soc_efuse_data_infop, &soc_name_data_infop, &soc_segment_count, &soc_efuse_data_count);
+	if (get_soc_status < 0) {
+		dev_err(mtk_socinfop->dev, "%s %s does not exist. Failed to get corresponding SOC info.\n", MODULE_NAME, mtk_socinfop->soc_data);
+		goto out;
+	}
+
+	for (i = 0; i < soc_segment_count; i++) {
+		match_segment = true;
+		for (j = 0; j < soc_efuse_data_count; j++) {
+			soc_temp_efuse_datap = soc_efuse_data_infop + (i * soc_efuse_data_count + j);
+			nvmem_cell_name = soc_temp_efuse_datap->nvmem_cell_name;
+			cell = nvmem_cell_get(mtk_socinfop->dev, nvmem_cell_name);
+			if (IS_ERR_OR_NULL(cell)) {
+				dev_err(mtk_socinfop->dev, "%s %s cell not found\n", MODULE_NAME, nvmem_cell_name);
+				goto out;
+			}
+			efuse_temp_bufp = nvmem_cell_read(cell, &efuse_bytes);
+			nvmem_cell_put(cell);
+			if (*efuse_temp_bufp != soc_temp_efuse_datap->efuse_data) {
+				match_segment = false;
+				break;
+			}
+		}
+		if (match_segment == true) {
+			match_segment_index = i;
+			mtk_socinfop->name_data = soc_name_data_infop + i;
+		}
+	}
+
+out:
+	return match_segment_index;
+}
+
+
+static const struct of_device_id mtk_socinfo_id_table[] = {
+	{ .compatible = "mediatek,mt8186-socinfo", .data = "mt8186"},
+	{ .compatible = "mediatek,mt8188-socinfo", .data = "mt8188"},
+	{ .compatible = "mediatek,mt8195-socinfo", .data = "mt8195"},
+	{ },
+};
+MODULE_DEVICE_TABLE(of, mtk_socinfo_id_table);
+
+
+static int mtk_socinfo_probe(struct platform_device *pdev)
+{
+	struct mtk_socinfo *mtk_socinfop;
+	int ret = 0;
+
+
+	mtk_socinfop = devm_kzalloc(&pdev->dev, sizeof(*mtk_socinfop), GFP_KERNEL);
+	if (!mtk_socinfop)
+		return -ENOMEM;
+
+	mtk_socinfop->dev = &pdev->dev;
+	mtk_socinfop->name_data = &dummy_name_info;
+	mtk_socinfop->soc_data = (char *)of_device_get_match_data(mtk_socinfop->dev);
+	if (!mtk_socinfop->soc_data) {
+		dev_err(mtk_socinfop->dev, "%s %s[%d] no mtk-socinfo platform data found\n", MODULE_NAME, __func__, __LINE__);
+		return -EPERM;
+	}
+
+	ret = mtk_socinfo_get_socinfo_data(mtk_socinfop);
+	if (ret < 0) {
+		dev_err(mtk_socinfop->dev, "%s %s[%d] failed to get socinfo data (ret = %d)\n", MODULE_NAME, __func__, __LINE__, ret);
+		return ret;
+	}
+
+	ret = mtk_socinfo_create_socinfo_node(mtk_socinfop);
+	if (ret != 0) {
+		dev_err(mtk_socinfop->dev, "%s %s[%d] failed to create socinfo node (ret = %d)\n", MODULE_NAME, __func__, __LINE__, ret);
+		return ret;
+	}
+
+
+#if IS_ENABLED(MTK_SOCINFO_DEBUG)
+	ret = mtk_socinfo_create_debug_cmds(mtk_socinfop);
+		if (ret != 0) {
+		dev_err(mtk_socinfop->dev, "%s %s[%d] failed to create socinfo debug node (ret = %d)\n", MODULE_NAME, __func__, __LINE__, ret);
+		return ret;
+	}
+#endif
+
+
+	return 0;
+}
+
+static int mtk_socinfo_remove(struct platform_device *pdev)
+{
+	pr_info("%s mtk_socinfo_remove\n", MODULE_NAME);
+	return 0;
+}
+
+static struct platform_driver mtk_socinfo = {
+	.probe          = mtk_socinfo_probe,
+	.remove         = mtk_socinfo_remove,
+	.driver         = {
+		.name   = "mtk_socinfo",
+		.owner  = THIS_MODULE,
+		.of_match_table = mtk_socinfo_id_table,
+	},
+};
+module_platform_driver(mtk_socinfo);
+MODULE_AUTHOR("William-TW Chen <william-tw.lin@mediatek.com>");
+MODULE_DESCRIPTION("Mediatek socinfo driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/soc/mediatek/mtk-socinfo.h b/drivers/soc/mediatek/mtk-socinfo.h
new file mode 100644
index 0000000000000000000000000000000000000000..a09de3c4e29c5d8cdc768eb94ef89e8c14c118df
--- /dev/null
+++ b/drivers/soc/mediatek/mtk-socinfo.h
@@ -0,0 +1,116 @@
+/* SPDX-License-Identifier: GPL-2.0
+ *
+ * Copyright (c) 2023 MediaTek Inc.
+ */
+
+#ifndef __MTK_SOCINFO_H__
+#define __MTK_SOCINFO_H__
+
+#define MODULE_NAME	 "[mtk-socinfo]"
+
+
+#define DEBUG_FOPS_RO(name)						\
+	static int mtk_socinfo_##name##_debug_open(struct inode *inode,		\
+					   struct file *filp)		\
+	{								\
+		return single_open(filp, mtk_socinfo_##name##_debug_show,	\
+				   inode->i_private);			\
+	}								\
+	static const struct file_operations mtk_socinfo_##name##_debug_fops = {	\
+		.owner = THIS_MODULE,					\
+		.open = mtk_socinfo_##name##_debug_open,			\
+		.read = seq_read,					\
+		.llseek = seq_lseek,					\
+		.release = single_release,				\
+	}
+
+#define MTK_SOCINFO_DENTRY_DATA(name)	{__stringify(name), &mtk_socinfo_##name##_debug_fops}
+
+const char *soc_manufacturer = "MediaTek";
+
+struct mtk_socinfo {
+	struct device *dev;
+	struct name_data *name_data;
+	struct efuse_data *efuse_data;
+	char *soc_data;
+};
+
+struct efuse_data {
+	char *nvmem_cell_name;
+	u32 efuse_data;
+};
+
+struct name_data {
+	char *soc_name;
+	char *soc_segment_name;
+	char *marketing_name;	
+};
+
+struct name_data dummy_name_info = {.soc_name = "No Name", .soc_segment_name = "No Name", .marketing_name = "No Name"};
+
+/* begin 8186 info */
+enum mt8186_mtk_socinfo_index {
+	INDEX_MT8186_1 = 0,
+	INDEX_MT8186_2,
+	MT8186_LAST_INDEX
+};
+
+#define mtk_mt8186_EFUSE_DATA_COUNT 1
+static struct efuse_data mtk_mt8186_efuse_data_info[][mtk_mt8186_EFUSE_DATA_COUNT] = {
+	[INDEX_MT8186_1] = {{.nvmem_cell_name = "socinfo-data1", .efuse_data = 0x81861001}},
+	[INDEX_MT8186_2] = {{.nvmem_cell_name = "socinfo-data1", .efuse_data = 0x81862001}},
+};
+
+static struct name_data mtk_mt8186_name_data_info[] = {
+	[INDEX_MT8186_1] = {.soc_name = "MT8186", .soc_segment_name = "MT8186GV/AZA", .marketing_name = "Kompanio 520"},
+	[INDEX_MT8186_2] = {.soc_name = "MT8186T", .soc_segment_name = "MT8186TV/AZA", .marketing_name = "Kompanio 528"},
+};
+/* end 8186 info */
+
+/* begin 8188 info */
+enum mt8188_mtk_socinfo_index {
+	INDEX_MT8188_1 = 0,
+	INDEX_MT8188_2,
+	MT8188_LAST_INDEX
+};
+
+#define mtk_mt8188_EFUSE_DATA_COUNT 2
+static struct efuse_data mtk_mt8188_efuse_data_info[][mtk_mt8188_EFUSE_DATA_COUNT] = {
+	[INDEX_MT8188_1] = {{.nvmem_cell_name = "socinfo-data1", .efuse_data = 0x81880000},
+						{.nvmem_cell_name = "socinfo-data2", .efuse_data = 0x00000010}},
+	[INDEX_MT8188_2] = {{.nvmem_cell_name = "socinfo-data1", .efuse_data = 0x81880000},
+						{.nvmem_cell_name = "socinfo-data2", .efuse_data = 0x00000011}},
+};
+
+static struct name_data mtk_mt8188_name_data_info[] = {
+	[INDEX_MT8188_1] = {.soc_name = "MT8188", .soc_segment_name = "MT8188GV/AZA", .marketing_name = "Kompanio 830"},
+	[INDEX_MT8188_2] = {.soc_name = "MT8188", .soc_segment_name = "MT8188GV/HZA", .marketing_name = "Kompanio 830"},
+};
+/* end 8188 info */
+
+/* begin 8195 info */
+enum mt8195_mtk_socinfo_index {
+	INDEX_MT8195_1 = 0,
+	INDEX_MT8195_2,
+	INDEX_MT8195_3,
+	INDEX_MT8195_4,
+	MT8195_LAST_INDEX
+};
+
+#define mtk_mt8195_EFUSE_DATA_COUNT 1
+static struct efuse_data mtk_mt8195_efuse_data_info[][mtk_mt8195_EFUSE_DATA_COUNT] = {
+	[INDEX_MT8195_1] = {{.nvmem_cell_name = "socinfo-data1", .efuse_data = 0x81950300}},
+	[INDEX_MT8195_2] = {{.nvmem_cell_name = "socinfo-data1", .efuse_data = 0x81950304}},
+	[INDEX_MT8195_3] = {{.nvmem_cell_name = "socinfo-data1", .efuse_data = 0x81950400}},
+	[INDEX_MT8195_4] = {{.nvmem_cell_name = "socinfo-data1", .efuse_data = 0x81950404}},
+};
+
+static struct name_data mtk_mt8195_name_data_info[] = {
+	[INDEX_MT8195_1] = {.soc_name = "MT8195", .soc_segment_name = "MT8195GV/EZA", .marketing_name = "Kompanio 1200"},
+	[INDEX_MT8195_2] = {.soc_name = "MT8195", .soc_segment_name = "MT8195GV/EHZA", .marketing_name = "Kompanio 1200"},
+	[INDEX_MT8195_3] = {.soc_name = "MT8195T", .soc_segment_name = "MT8195TV/EZA", .marketing_name = "Kompanio 1380"},
+	[INDEX_MT8195_4] = {.soc_name = "MT8195T", .soc_segment_name = "MT8195TV/EHZA", .marketing_name = "Kompanio 1380"},
+};
+/* end 8195 info */
+
+#endif /* __MTK_SOCINFO_H__ */
diff --git a/drivers/soc/mediatek/systracker/Kconfig b/drivers/soc/mediatek/systracker/Kconfig
new file mode 100644
index 0000000000000000000000000000000000000000..9076c0005bc459ac4b082645ed20ae41898efaf3
--- /dev/null
+++ b/drivers/soc/mediatek/systracker/Kconfig
@@ -0,0 +1,7 @@
+config MTK_SYSTRACKER_V2
+	tristate "Enable MTK System Tracker Debugger V2"
+	help
+	  SYSTRACKER driver is a debugging feature.
+	  SYSTRACKER is a hardware debugger to record timeout transaction
+	  and trigger SLV_ERR or interrupt to notify CPU.
+	  Support 2 stage timeout & watchpoint SLV_ERR.
diff --git a/drivers/soc/mediatek/systracker/Makefile b/drivers/soc/mediatek/systracker/Makefile
new file mode 100644
index 0000000000000000000000000000000000000000..9deda6bb0eea810e08ab4d2ef54b65e87dfa1212
--- /dev/null
+++ b/drivers/soc/mediatek/systracker/Makefile
@@ -0,0 +1,14 @@
+#
+# Copyright (C) 2015 MediaTek Inc.
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU General Public License version 2 as
+# published by the Free Software Foundation.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+# GNU General Public License for more details.
+#
+
+obj-$(CONFIG_MTK_SYSTRACKER_V2) += systracker.o
diff --git a/drivers/soc/mediatek/systracker/systracker.c b/drivers/soc/mediatek/systracker/systracker.c
new file mode 100644
index 0000000000000000000000000000000000000000..e2e3df6e173249ab0dd49820346f75e8d7e81866
--- /dev/null
+++ b/drivers/soc/mediatek/systracker/systracker.c
@@ -0,0 +1,806 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2021 MediaTek Inc.
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <linux/kallsyms.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/sched.h>
+#include <linux/of_address.h>
+#include <linux/of_irq.h>
+#include <linux/signal.h>
+#include <linux/cpu.h>
+#include <linux/io.h>
+#include "systracker_v2.h"
+
+void __iomem *BUS_DBG_BASE;
+void __iomem *BUS_DBG_INFRA_BASE;
+int systracker_irq;
+struct systracker_config_t track_config;
+struct systracker_entry_t track_entry;
+
+static const struct of_device_id systracker_of_ids[] = {
+	{ .compatible = "mediatek,bus_dbg-v2", },
+	{}
+};
+
+static struct mt_systracker_driver mt_systracker_drv = {
+	.driver = {
+		.driver = {
+			.name = "systracker",
+			.bus = &platform_bus_type,
+			.owner = THIS_MODULE,
+			.of_match_table = systracker_of_ids,
+		},
+		.probe = systracker_probe,
+		.remove = systracker_remove,
+		.suspend = systracker_suspend,
+		.resume = systracker_resume,
+	},
+	.device = {
+		.name = "systracker",
+	},
+};
+
+int systracker_probe(struct platform_device *pdev)
+{
+	void __iomem *infra_ao_base;
+	unsigned int bus_dbg_con_offset;
+
+	pr_notice("systracker probe\n");
+
+	/* iomap register */
+	BUS_DBG_BASE = of_iomap(pdev->dev.of_node, 0);
+	if (!BUS_DBG_BASE) {
+		pr_notice("can't of_iomap for systracker!!\n");
+		return -ENOMEM;
+	}
+
+	pr_notice("of_iomap for systracker @ 0x%p\n", BUS_DBG_BASE);
+
+	infra_ao_base = of_iomap(pdev->dev.of_node, 1);
+	if (!infra_ao_base) {
+		pr_notice("[systracker] bus_dbg_con is in infra\n");
+		BUS_DBG_INFRA_BASE = BUS_DBG_BASE;
+	} else {
+		pr_notice("[systracker] bus_dbg_con is in infra_ao\n");
+		if (of_property_read_u32
+			(pdev->dev.of_node, "mediatek,bus_dbg_con_offset",
+			&bus_dbg_con_offset)) {
+			pr_notice
+			("[systracker] cannot get bus_dbg_con_offset\n");
+			return -ENODEV;
+		}
+		BUS_DBG_INFRA_BASE = infra_ao_base + bus_dbg_con_offset;
+	}
+
+	/* get irq #  */
+	systracker_irq = irq_of_parse_and_map(pdev->dev.of_node, 0);
+	pr_notice("%s:%d: irq # %d\n", __func__, __LINE__, systracker_irq);
+
+#if IS_ENABLED(CONFIG_MTK_BUS_TRACER)
+	pr_notice("[systracker] register isr for bus tracer\n");
+	if (request_irq(systracker_irq, (irq_handler_t)systracker_isr,
+				IRQF_TRIGGER_NONE, "SYSTRACKER", NULL)) {
+		pr_notice("SYSTRACKER IRQ LINE NOT AVAILABLE!!\n");
+		return -1;
+	}
+#endif
+
+	/* save entry info */
+	save_entry();
+	memset(&track_config, 0, sizeof(struct systracker_config_t));
+
+	track_config.enable_timeout = 1;
+	track_config.enable_slave_err = 1;
+	track_config.enable_irq = 1;
+	track_config.timeout_ms = 100;
+	track_config.timeout2_ms = 2000;
+
+	systracker_reset();
+	systracker_enable();
+
+	return 0;
+}
+
+int systracker_remove(struct platform_device *pdev)
+{
+	return 0;
+}
+
+int systracker_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	return 0;
+}
+
+static int systracker_resume_default(struct platform_device *pdev)
+{
+	if (track_config.state || track_config.enable_wp)
+		systracker_enable();
+
+	return 0;
+}
+
+int systracker_resume(struct platform_device *pdev)
+{
+	return systracker_resume_default(pdev);
+}
+
+void save_entry(void)
+{
+	int i = 0;
+
+	track_entry.dbg_con =  readl(BUS_DBG_CON);
+	track_entry.dbg_con_infra =  readl(BUS_DBG_CON_INFRA);
+
+	for (i = 0; i < BUS_DBG_NUM_TRACKER; i++) {
+		track_entry.ar_track_l[i]   =
+			readl(BUS_DBG_AR_TRACK_L(i));
+		track_entry.ar_track_h[i]   =
+			readl(BUS_DBG_AR_TRACK_H(i));
+		track_entry.ar_trans_tid[i] =
+			readl(BUS_DBG_AR_TRANS_TID(i));
+		track_entry.aw_track_l[i]   =
+			readl(BUS_DBG_AW_TRACK_L(i));
+		track_entry.aw_track_h[i]   =
+			readl(BUS_DBG_AW_TRACK_H(i));
+		track_entry.aw_trans_tid[i] =
+			readl(BUS_DBG_AW_TRANS_TID(i));
+	}
+
+	track_entry.w_track_data6 = readl(BUS_DBG_W_TRACK_DATA6);
+	track_entry.w_track_data7 = readl(BUS_DBG_W_TRACK_DATA7);
+	track_entry.w_track_data_valid =
+		readl(BUS_DBG_W_TRACK_DATA_VALID);
+}
+
+irqreturn_t systracker_isr(void)
+{
+	return IRQ_HANDLED;
+}
+
+static int systracker_watchpoint_enable_default(void)
+{
+	unsigned int con;
+
+	track_config.enable_wp = 1;
+
+	writel(track_config.wp_phy_address, BUS_DBG_WP);
+	writel(0x00000000, BUS_DBG_WP_MASK);
+
+	con = readl(BUS_DBG_CON_INFRA) | BUS_DBG_CON_WP_EN;
+	writel(con, BUS_DBG_CON_INFRA);
+	/* ensure access complete */
+	mb();
+
+	return 0;
+}
+
+int systracker_watchpoint_enable(void)
+{
+	return systracker_watchpoint_enable_default();
+}
+
+static int systracker_watchpoint_disable_default(void)
+{
+	track_config.enable_wp = 0;
+	writel(readl(BUS_DBG_CON_INFRA) & (~BUS_DBG_CON_WP_EN),
+		BUS_DBG_CON_INFRA);
+	/* ensure access complete */
+	mb();
+
+	return 0;
+}
+
+int systracker_watchpoint_disable(void)
+{
+	return systracker_watchpoint_disable_default();
+}
+
+void systracker_reset_default(void)
+{
+	writel(readl(BUS_DBG_CON) |
+		BUS_DBG_CON_SW_RST, BUS_DBG_CON);
+	writel(readl(BUS_DBG_CON) |
+		BUS_DBG_CON_IRQ_CLR, BUS_DBG_CON);
+	writel(readl(BUS_DBG_CON) |
+		BUS_DBG_CON_TIMEOUT_CLR, BUS_DBG_CON);
+	/* ensure access complete */
+	mb();
+}
+
+void systracker_reset(void)
+{
+	systracker_reset_default();
+}
+
+unsigned int systracker_timeout_value_default(void)
+{
+	/* prescale = (133 * (10 ^ 6)) / 16 = 8312500/s */
+	return (BUS_DBG_BUS_MHZ * 1000 / 16) * track_config.timeout_ms;
+}
+
+unsigned int systracker_timeout2_value_default(void)
+{
+	/* prescale = (133 * (10 ^ 6)) / 16 = 8312500/s */
+	return (BUS_DBG_BUS_MHZ * 1000 / 16) * track_config.timeout2_ms;
+}
+
+unsigned int systracker_timeout_value(void)
+{
+	return systracker_timeout_value_default();
+}
+
+unsigned int systracker_timeout2_value(void)
+{
+	return systracker_timeout2_value_default();
+}
+
+void systracker_enable_default(void)
+{
+	unsigned int con;
+	unsigned int timer_control_value;
+
+	timer_control_value = systracker_timeout_value();
+	writel(timer_control_value, BUS_DBG_TIMER_CON0);
+
+	timer_control_value = systracker_timeout2_value();
+	writel(timer_control_value, BUS_DBG_TIMER_CON1);
+
+	track_config.state = 1;
+	con = BUS_DBG_CON_BUS_DBG_EN | BUS_DBG_CON_BUS_OT_EN;
+	if (track_config.enable_timeout)
+		con |= BUS_DBG_CON_TIMEOUT_EN;
+
+	if (track_config.enable_slave_err)
+		con |= BUS_DBG_CON_SLV_ERR_EN;
+
+	if (track_config.enable_irq) {
+		con |= BUS_DBG_CON_IRQ_EN;
+		con &= ~BUS_DBG_CON_IRQ_WP_EN;
+	}
+
+	con |= BUS_DBG_CON_HALT_ON_EN;
+	writel(con, BUS_DBG_CON_INFRA);
+	/* ensure access complete */
+	mb();
+}
+
+void systracker_enable(void)
+{
+	systracker_enable_default();
+}
+
+void enable_systracker(void)
+{
+	systracker_enable();
+}
+
+static void systracker_disable_default(void)
+{
+	track_config.state = 0;
+	writel(readl(BUS_DBG_CON_INFRA) &
+		~BUS_DBG_CON_BUS_DBG_EN, BUS_DBG_CON_INFRA);
+	/* ensure access complete */
+	mb();
+}
+
+void systracker_disable(void)
+{
+	systracker_disable_default();
+}
+
+int systracker_test_init(void)
+{
+	if (mt_systracker_drv.systracker_test_init)
+		return mt_systracker_drv.systracker_test_init();
+
+	pr_notice("mt_systracker_drv.%s is NULL", __func__);
+	return -1;
+}
+
+struct mt_systracker_driver *get_mt_systracker_drv(void)
+{
+	return &mt_systracker_drv;
+}
+
+int tracker_dump(char *buf)
+{
+	char *ptr = buf;
+	unsigned int reg_value;
+	int i;
+	unsigned int entry_valid;
+	unsigned int entry_secure;
+	unsigned int entry_tid;
+	unsigned int entry_id;
+	unsigned int entry_address;
+	unsigned int entry_data_size;
+	unsigned int entry_burst_length;
+	{
+		/* Get tracker info and save to buf */
+
+		/* BUS_DBG_AR_TRACK_L(__n)
+		 * [31:0] ARADDR: DBG read tracker entry read address
+		 */
+
+		/* BUS_DBG_AR_TRACK_H(__n)
+		 * [22] Valid:DBG read tracker entry valid
+		 * [20:8] ARID:DBG read tracker entry read ID
+		 * [6:4] ARSIZE:DBG read tracker entry read data size
+		 * [3:0] ARLEN: DBG read tracker entry read burst length
+		 */
+
+		/* BUS_DBG_AR_TRACK_TID(__n)
+		 * [2:0] BUS_DBG_AR_TRANS0_ENTRY_ID:
+		 * DBG read tracker entry ID of 1st transaction
+		 */
+
+		ptr += sprintf(ptr,
+	"[TRACKER] BUS_DBG_CON = (0x%x, 0x%x), T0= 0x%x, T1 = 0x%x\n",
+				track_entry.dbg_con,
+				readl(BUS_DBG_CON),
+				readl(BUS_DBG_TIMER_CON0),
+				readl(BUS_DBG_TIMER_CON1));
+
+		ptr += sprintf(ptr, "BUS_DBG_CON_INFRA = (0x%x, 0x%x)\n",
+			       track_entry.dbg_con_infra,
+			       readl(BUS_DBG_CON_INFRA));
+
+		for (i = 0; i < BUS_DBG_NUM_TRACKER; i++) {
+			entry_address       = track_entry.ar_track_l[i];
+			reg_value           = track_entry.ar_track_h[i];
+			entry_valid         =
+				extract_n2mbits(reg_value, 22, 22);
+			entry_secure         =
+				extract_n2mbits(reg_value, 21, 21);
+			entry_id            =
+				extract_n2mbits(reg_value, 8, 20);
+			entry_data_size     =
+				extract_n2mbits(reg_value, 4, 6);
+			entry_burst_length  =
+				extract_n2mbits(reg_value, 0, 3);
+			entry_tid           = track_entry.ar_trans_tid[i];
+
+			ptr += sprintf(ptr,
+				"read entry = %d, valid = 0x%x, secure = 0x%x,",
+				i, entry_valid, entry_secure);
+			ptr += sprintf(ptr,
+				"read id = 0x%x, address = 0x%x, data_size = 0x%x,",
+				entry_id, entry_address, entry_data_size);
+			ptr += sprintf(ptr, "burst_length = 0x%x\n",
+					entry_burst_length);
+		}
+
+		/* BUS_DBG_AW_TRACK_L(__n)
+		 * [31:0] AWADDR: DBG write tracker entry write address
+		 */
+
+		/* BUS_DBG_AW_TRACK_H(__n)
+		 * [22] Valid:DBG   write tracker entry valid
+		 * [20:8] ARID:DBG  write tracker entry write ID
+		 * [6:4] ARSIZE:DBG write tracker entry write data size
+		 * [3:0] ARLEN: DBG write tracker entry write burst length
+		 */
+
+		/* BUS_DBG_AW_TRACK_TID(__n)
+		 * [2:0] BUS_DBG_AW_TRANS0_ENTRY_ID:
+		 * DBG write tracker entry ID of 1st transaction
+		 */
+
+		for (i = 0; i < BUS_DBG_NUM_TRACKER; i++) {
+			entry_address       = track_entry.aw_track_l[i];
+			reg_value           = track_entry.aw_track_h[i];
+			entry_valid         =
+				extract_n2mbits(reg_value, 22, 22);
+			entry_secure         =
+				extract_n2mbits(reg_value, 21, 21);
+			entry_id            =
+				extract_n2mbits(reg_value, 8, 20);
+			entry_data_size     =
+				extract_n2mbits(reg_value, 4, 6);
+			entry_burst_length  =
+				extract_n2mbits(reg_value, 0, 3);
+			entry_tid           = track_entry.aw_trans_tid[i];
+
+			ptr += sprintf(ptr,
+				"write entry = %d, valid = 0x%x, secure = 0x%x,",
+				i, entry_valid, entry_secure);
+			ptr += sprintf(ptr,
+				"read id = 0x%x, address = 0x%x, data_size = 0x%x, ",
+				entry_id, entry_address, entry_data_size);
+			ptr += sprintf(ptr,
+				"burst_length = 0x%x\n",
+				entry_burst_length);
+		}
+
+		ptr += sprintf(ptr,
+			"write entry ~ 6, valid = 0x%x, data = 0x%x\n",
+			((track_entry.w_track_data_valid&(0x1<<6))>>6),
+			track_entry.w_track_data6);
+		ptr += sprintf(ptr,
+			"write entry ~ 7, valid = 0x%x, data = 0x%x\n",
+			((track_entry.w_track_data_valid&(0x1<<7))>>7),
+			track_entry.w_track_data7);
+
+		return strlen(buf);
+	}
+
+	return -1;
+}
+
+static ssize_t tracker_run_show(struct device_driver *driver, char *buf)
+{
+	return snprintf(buf, PAGE_SIZE,
+		"BUS_DBG_CON=0x%x, BUS_DBG_CON_INFRA=0x%x\n",
+			readl(BUS_DBG_CON),
+			readl(BUS_DBG_CON_INFRA));
+}
+
+static ssize_t tracker_run_store(struct device_driver *driver,
+		const char *buf, size_t count)
+{
+	unsigned int value;
+
+	if (kstrtou32(buf, 10, &value))
+		return -EINVAL;
+
+	if (value == 1)
+		systracker_enable();
+	else if (value == 0)
+		systracker_disable();
+	else
+		return -EINVAL;
+
+	return count;
+}
+
+DRIVER_ATTR_RW(tracker_run);
+
+static ssize_t enable_wp_show(struct device_driver *driver, char *buf)
+{
+	return snprintf(buf, PAGE_SIZE, "%x\n", track_config.enable_wp);
+}
+
+static ssize_t enable_wp_store(struct device_driver *driver,
+		const char *buf, size_t count)
+{
+	unsigned int value;
+
+	if (kstrtou32(buf, 10, &value))
+		return -EINVAL;
+
+	if (value == 1)
+		systracker_watchpoint_enable();
+	else if (value == 0)
+		systracker_watchpoint_disable();
+	else
+		return -EINVAL;
+
+	return count;
+}
+
+static DRIVER_ATTR_RW(enable_wp);
+
+static ssize_t set_wp_address_show(struct device_driver *driver, char *buf)
+{
+	return snprintf(buf, PAGE_SIZE, "%x\n", track_config.wp_phy_address);
+}
+
+int systracker_set_watchpoint_addr(unsigned int addr)
+{
+	if (mt_systracker_drv.set_watchpoint_address)
+		return mt_systracker_drv.set_watchpoint_address(addr);
+
+	track_config.wp_phy_address = addr;
+
+	return 0;
+}
+
+static ssize_t set_wp_address_store
+	(struct device_driver *driver, const char *buf, size_t count)
+{
+	unsigned int value;
+	int ret;
+
+	ret = kstrtou32(buf, 16, &value);
+	pr_debug("watch address:0x%x, ret = %d\n", value, ret);
+	systracker_set_watchpoint_addr(value);
+
+	return count;
+}
+
+static DRIVER_ATTR_RW(set_wp_address);
+
+static ssize_t tracker_entry_dump_show
+	(struct device_driver *driver, char *buf)
+{
+	int ret = tracker_dump(buf);
+
+	if (ret == -1)
+		pr_notice("Dump error in %s, %d\n", __func__, __LINE__);
+
+	return strlen(buf);
+}
+
+static ssize_t tracker_swtrst_show(struct device_driver *driver, char *buf)
+{
+	return 0;
+}
+
+static ssize_t tracker_swtrst_store
+	(struct device_driver *driver, const char *buf, size_t count)
+{
+	writel(readl(BUS_DBG_CON) |
+		BUS_DBG_CON_SW_RST, BUS_DBG_CON);
+	return count;
+}
+
+static DRIVER_ATTR_RW(tracker_swtrst);
+
+#ifdef SYSTRACKER_TEST_SUIT
+/*top axi protect module control register*/
+void __iomem *ctrl_bus_reg;
+/*read/write this addr make bus timeout*/
+void __iomem *test_area;
+
+#if IS_ENABLED(CONFIG_ARM64)
+#define IOMEM(a)	((void __force __iomem *)((a)))
+#endif
+
+unsigned int prot_reg, test_addr, bits;
+
+static void systracker_platform_wp_test(void)
+{
+	void __iomem *ptr;
+	/* use eint reg base as our watchpoint */
+	ptr = ioremap(test_addr, 0x4);
+	pr_debug("%s:%d: we got p = 0x%p\n", __func__, __LINE__, ptr);
+	systracker_set_watchpoint_addr(test_addr);
+	systracker_watchpoint_enable();
+	/* touch it */
+	writel(0, ptr);
+	pr_debug("after we touched watchpoint\n");
+	iounmap(ptr);
+}
+
+static void systracker_platform_read_timeout_test(void)
+{
+	/* FIXME: testing
+	 * track_config.enable_slave_err = 0;
+	 * systracker_enable();
+	 */
+	pr_notice("we are going to have read timeout\n");
+	writel(readl(ctrl_bus_reg) | (0x1 << bits), ctrl_bus_reg);
+	readl(test_area);
+	writel(readl(ctrl_bus_reg) & ~(0x1 << bits), ctrl_bus_reg);
+}
+
+static void systracker_platform_write_timeout_test(void)
+{
+	pr_notice("we are going to have write timeout\n");
+	writel(readl(ctrl_bus_reg) | (0x1 << bits), ctrl_bus_reg);
+	writel(0x0, test_area);
+	writel(readl(ctrl_bus_reg) & ~(0x1 << bits), ctrl_bus_reg);
+	pr_debug("out write timeout:%s:%d\n", __func__, __LINE__);
+}
+
+static void systracker_platform_withrecord_test(void)
+{
+	writel(readl(IOMEM(BUS_DBG_CON)) |
+	       BUS_DBG_CON_HALT_ON_EN, IOMEM(BUS_DBG_CON));
+	writel(readl(ctrl_bus_reg) | (0x1 << bits), ctrl_bus_reg);
+	readl(test_area);
+}
+
+static void systracker_platform_notimeout_test(void)
+{
+	writel(readl(ctrl_bus_reg) | (0x1 << bits), ctrl_bus_reg);
+	/* disable timeout */
+	writel(readl(IOMEM(BUS_DBG_CON_INFRA)) &
+		~(BUS_DBG_CON_TIMEOUT_EN), IOMEM(BUS_DBG_CON_INFRA));
+	/* read it, should cause bus hang */
+	readl(test_area);
+	/* never come back */
+	pr_notice("failed??\n");
+}
+
+/*Before test bus timeout ,must first test_suit init*/
+static ssize_t test_suit_init_show(struct device_driver *driver, char *buf)
+{
+	return snprintf(buf, PAGE_SIZE, "==Systracker test init==\n"
+		"echo prot_reg test_addr bits >/sys/bus/platform/drivers/systracker/test_suit_init\n");
+}
+
+static ssize_t test_suit_init_store
+	(struct device_driver *driver, const char *buf, size_t count)
+{
+	char *p = (char *)buf, *arg;
+	int i = 0, j = 0;
+	unsigned long input;
+
+	while ((arg = strsep(&p, " ")) && (i <= 2)) {
+		if (i <= 1)
+			j = 16;
+		else
+			j = 10;
+		if (kstrtoul(arg, j, &input) != 0) {
+			pr_notice("%s: kstrtoul fail for %s\n", __func__, p);
+			return 0;
+		}
+		switch (i) {
+		case 0:
+			prot_reg = input;
+			break;
+		case 1:
+			test_addr = input;
+			break;
+		case 2:
+			bits = input;
+			break;
+		default:
+			break;
+		}
+		i++;
+	}
+	ctrl_bus_reg = ioremap(prot_reg, 0x4);
+
+	test_area = ioremap(test_addr, 0x4);
+	return count;
+}
+
+DRIVER_ATTR_RW(test_suit_init);
+
+static ssize_t test_suit_show(struct device_driver *driver, char *buf)
+{
+	return snprintf(buf, PAGE_SIZE, "==Systracker test==\n"
+			"1.Systracker show dump test\n"
+			"2.Systracker watchpoint test\n"
+			"3.Systracker read timeout test\n"
+			"4.Systracker write timeout test\n"
+			"5.Systracker timeout with record test\n"
+			"6.Systracker no timeout test\n"
+		       );
+}
+
+static ssize_t test_suit_store
+	(struct device_driver *driver, const char *buf, size_t count)
+{
+	char *p = (char *)buf;
+	unsigned long num;
+
+	if (kstrtoul(p, 10, &num) != 0) {
+		pr_notice("[Tracker] kstrtoul fail for %s\n", p);
+		return 0;
+	}
+	if (num == 1)
+		return tracker_entry_dump_show(driver, p);
+
+	if ((prot_reg != 0) && (test_addr != 0)) {
+		switch (num) {
+		/* Test Systracker Function */
+		case 2:
+			systracker_platform_wp_test();
+			break;
+		case 3:
+			systracker_platform_read_timeout_test();
+			break;
+		case 4:
+			systracker_platform_write_timeout_test();
+			break;
+		case 5:
+			systracker_platform_withrecord_test();
+			break;
+		case 6:
+			systracker_platform_notimeout_test();
+			break;
+		default:
+			break;
+		}
+	} else {
+		pr_notice("please first test_suit_init\n");
+	}
+	return count;
+}
+DRIVER_ATTR_RW(test_suit);
+#endif
+
+static ssize_t tracker_entry_dump_store
+	(struct device_driver *driver, const char *buf, size_t count)
+{
+	return count;
+}
+
+static DRIVER_ATTR_RW(tracker_entry_dump);
+
+static ssize_t tracker_last_status_show
+	(struct device_driver *driver, char *buf)
+{
+
+	if (track_entry.dbg_con & BUS_DBG_CON_TIMEOUT)
+		return snprintf(buf, PAGE_SIZE, "1\n");
+	else
+		return snprintf(buf, PAGE_SIZE, "0\n");
+}
+
+static ssize_t tracker_last_status_store
+	(struct device_driver *driver, const char *buf, size_t count)
+{
+	return count;
+}
+
+static DRIVER_ATTR_RW(tracker_last_status);
+
+/*
+ * driver initialization entry point
+ */
+static int __init systracker_init(void)
+{
+	int err = 0;
+	int ret = 0;
+
+	err = platform_driver_register(&mt_systracker_drv.driver);
+	if (err)
+		return err;
+
+	/* Create sysfs entry */
+	ret  = driver_create_file(&mt_systracker_drv.driver.driver,
+		&driver_attr_tracker_entry_dump);
+	ret |= driver_create_file(&mt_systracker_drv.driver.driver,
+		&driver_attr_tracker_run);
+	ret |= driver_create_file(&mt_systracker_drv.driver.driver,
+		&driver_attr_enable_wp);
+	ret |= driver_create_file(&mt_systracker_drv.driver.driver,
+		&driver_attr_set_wp_address);
+	ret |= driver_create_file(&mt_systracker_drv.driver.driver,
+		&driver_attr_tracker_swtrst);
+	ret |= driver_create_file(&mt_systracker_drv.driver.driver,
+		&driver_attr_tracker_last_status);
+#ifdef SYSTRACKER_TEST_SUIT
+	ret |= driver_create_file(&mt_systracker_drv.driver.driver,
+		&driver_attr_test_suit_init);
+	ret |= driver_create_file(&mt_systracker_drv.driver.driver,
+		&driver_attr_test_suit);
+#endif
+	if (ret)
+		pr_notice("Fail to create systracker_drv sysfs files");
+
+	pr_debug("systracker init done\n");
+	return 0;
+}
+
+/*
+ * driver exit point
+ */
+static void __exit systracker_exit(void)
+{
+	platform_driver_unregister(&mt_systracker_drv.driver);
+	/* remove sysfs entry */
+	driver_remove_file(&mt_systracker_drv.driver.driver,
+		&driver_attr_tracker_entry_dump);
+	driver_remove_file(&mt_systracker_drv.driver.driver,
+		&driver_attr_tracker_run);
+	driver_remove_file(&mt_systracker_drv.driver.driver,
+		&driver_attr_enable_wp);
+	driver_remove_file(&mt_systracker_drv.driver.driver,
+		&driver_attr_set_wp_address);
+	driver_remove_file(&mt_systracker_drv.driver.driver,
+		&driver_attr_tracker_swtrst);
+	driver_remove_file(&mt_systracker_drv.driver.driver,
+		&driver_attr_tracker_last_status);
+#ifdef SYSTRACKER_TEST_SUIT
+	driver_remove_file(&mt_systracker_drv.driver.driver,
+		&driver_attr_test_suit_init);
+	driver_remove_file(&mt_systracker_drv.driver.driver,
+		&driver_attr_test_suit);
+#endif
+
+	pr_debug("systracker exit done\n");
+}
+
+module_init(systracker_init);
+module_exit(systracker_exit);
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/soc/mediatek/systracker/systracker_v2.h b/drivers/soc/mediatek/systracker/systracker_v2.h
new file mode 100644
index 0000000000000000000000000000000000000000..07fd8d7ee0d88e3eeee2545006a0f0b787d49545
--- /dev/null
+++ b/drivers/soc/mediatek/systracker/systracker_v2.h
@@ -0,0 +1,162 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) 2021 MediaTek Inc.
+ */
+
+#ifndef __SYSTRAKCER_V2_H__
+#define __SYSTRAKCER_V2_H__
+
+#include <linux/platform_device.h>
+
+#define BUS_DBG_CON			(BUS_DBG_BASE)
+#define BUS_DBG_CON_INFRA		(BUS_DBG_INFRA_BASE)
+#define BUS_DBG_TIMER_CON0		(BUS_DBG_BASE + 0x0004)
+#define BUS_DBG_TIMER_CON1		(BUS_DBG_BASE + 0x0008)
+#define BUS_DBG_TIMER_R0		(BUS_DBG_BASE + 0x000C)
+#define BUS_DBG_TIMER_R1		(BUS_DBG_BASE + 0x0010)
+#define BUS_DBG_WP			(BUS_DBG_BASE + 0x0014)
+#define BUS_DBG_WP_MASK			(BUS_DBG_BASE + 0x0018)
+#define BUS_DBG_MON			(BUS_DBG_BASE + 0x001C)
+#define BUS_DBG_W_TRACK_DATA_VALID	(BUS_DBG_BASE + 0x0020)
+#define BUS_DBG_AR_TRACK_L(__n)		(BUS_DBG_BASE + 0x0100 + 8 * (__n))
+#define BUS_DBG_AR_TRACK_H(__n)		(BUS_DBG_BASE + 0x0104 + 8 * (__n))
+#define BUS_DBG_AR_TRANS_TID(__n)	(BUS_DBG_BASE + 0x0180 + 4 * (__n))
+#define BUS_DBG_AW_TRACK_L(__n)		(BUS_DBG_BASE + 0x0200 + 8 * (__n))
+#define BUS_DBG_AW_TRACK_H(__n)		(BUS_DBG_BASE + 0x0204 + 8 * (__n))
+#define BUS_DBG_AW_TRANS_TID(__n)	(BUS_DBG_BASE + 0x0280 + 4 * (__n))
+#define BUS_DBG_W_TRACK_DATA6		(BUS_DBG_BASE + 0x02D8)
+#define BUS_DBG_W_TRACK_DATA7		(BUS_DBG_BASE + 0x02DC)
+
+#define BUS_DBG_BUS_MHZ			(156)
+#define BUS_DBG_NUM_TRACKER		(8)
+
+#define BUS_DBG_CON_BUS_DBG_EN		(0x00000001)
+#define BUS_DBG_CON_TIMEOUT_EN		(0x00000002)
+#define BUS_DBG_CON_SLV_ERR_EN		(0x00000004)
+#define BUS_DBG_CON_WP_EN		(0x00000108)
+#define BUS_DBG_CON_IRQ_AR_EN		(0x00000010)
+#define BUS_DBG_CON_IRQ_AW_EN		(0x00000020)
+#define BUS_DBG_CON_SW_RST_DN		(0x00000040)
+/* more human-readable register name than above one */
+#define BUS_DBG_CON_IRQ_WP_EN		(0x00000040)
+#define BUS_DBG_CON_IRQ_CLR		(0x00000080)
+#define BUS_DBG_CON_IRQ_AR_STA0		(0x00000100)
+#define BUS_DBG_CON_IRQ_AW_STA0		(0x00000200)
+#define BUS_DBG_CON_IRQ_WP_STA		(0x00000400)
+#define BUS_DBG_CON_WDT_RST_EN		(0x00001000)
+#define BUS_DBG_CON_HALT_ON_EN		(0x00002000)
+#define BUS_DBG_CON_BUS_OT_EN		(0x00004000)
+#define BUS_DBG_CON_SW_RST		(0x00010000)
+#define BUS_DBG_CON_IRQ_AR_STA1		(0x00100000)
+#define BUS_DBG_CON_IRQ_AW_STA1		(0x00200000)
+#define BUS_DBG_CON_TIMEOUT_CLR		(0x00800000)
+/* detect all stages of timeout */
+#define BUS_DBG_CON_TIMEOUT	\
+	(BUS_DBG_CON_IRQ_AR_STA0 | BUS_DBG_CON_IRQ_AW_STA0| \
+	BUS_DBG_CON_IRQ_AR_STA1 | BUS_DBG_CON_IRQ_AW_STA1)
+
+#define BUS_DBG_CON_IRQ_EN	\
+	(BUS_DBG_CON_IRQ_AR_EN | BUS_DBG_CON_IRQ_AW_EN | \
+	BUS_DBG_CON_IRQ_WP_EN)
+
+#define BUS_DBG_MAX_TIMEOUT_VAL	    (0xffffffff)
+
+static inline unsigned int extract_n2mbits(unsigned int input, int n, int m)
+{
+/*
+ * 1. ~0 = 1111 1111 1111 1111 1111 1111 1111 1111
+ * 2. ~0 << (m - n + 1) = 1111 1111 1111 1111 1100 0000 0000 0000
+ * // assuming we are extracting 14 bits, the +1 is added
+ * for inclusive selection
+ * 3. ~(~0 << (m - n + 1)) = 0000 0000 0000 0000 0011 1111 1111 1111
+ */
+	int mask;
+
+	if (n > m) {
+		n = n + m;
+		m = n - m;
+		n = n - m;
+	}
+	mask = ~(~0 << (m - n + 1));
+	return ((input >> n) & mask);
+}
+
+struct mt_systracker_driver {
+	struct	platform_driver driver;
+	struct	platform_device device;
+	u32 support_2_stage_timeout;
+	void	(*reset_systracker)(void);
+	int	(*enable_watchpoint)(void);
+	int	(*disable_watchpoint)(void);
+	int	(*set_watchpoint_address)(unsigned int wp_phy_address);
+	void	(*enable_systracker)(void);
+	void	(*disable_systracker)(void);
+	int	(*test_systracker)(void);
+	int	(*systracker_probe)(struct platform_device *pdev);
+	unsigned int (*systracker_timeout_value)(void);
+	unsigned int (*systracker_timeout2_value)(void);
+	int	(*systracker_remove)(struct platform_device *pdev);
+	int	(*systracker_suspend)(struct platform_device *pdev,
+			pm_message_t state);
+	int	(*systracker_resume)(struct platform_device *pdev);
+	int	(*systracker_test_init)(void);
+	void	(*systracker_test_cleanup)(void);
+	void	(*systracker_wp_test)(void);
+	void	(*systracker_read_timeout_test)(void);
+	void	(*systracker_write_timeout_test)(void);
+	void	(*systracker_withrecord_test)(void);
+	void	(*systracker_notimeout_test)(void);
+};
+
+struct systracker_entry_t {
+	unsigned int dbg_con;
+	unsigned int dbg_con_infra;
+	unsigned int ar_track_l[BUS_DBG_NUM_TRACKER];
+	unsigned int ar_track_h[BUS_DBG_NUM_TRACKER];
+	unsigned int ar_trans_tid[BUS_DBG_NUM_TRACKER];
+	unsigned int aw_track_l[BUS_DBG_NUM_TRACKER];
+	unsigned int aw_track_h[BUS_DBG_NUM_TRACKER];
+	unsigned int aw_trans_tid[BUS_DBG_NUM_TRACKER];
+	unsigned int w_track_data6;
+	unsigned int w_track_data7;
+	unsigned int w_track_data_valid;
+};
+
+struct systracker_config_t {
+	int state;
+	int enable_timeout;
+	int enable_slave_err;
+	int enable_wp;
+	int enable_irq;
+	int timeout_ms;
+	int timeout2_ms;
+	int wp_phy_address;
+};
+
+int tracker_dump(char *buf);
+void save_entry(void);
+int systracker_probe(struct platform_device *pdev);
+int systracker_remove(struct platform_device *pdev);
+int systracker_suspend
+	(struct platform_device *pdev, pm_message_t state);
+int systracker_resume(struct platform_device *pdev);
+void systracker_reset(void);
+void systracker_enable(void);
+void systracker_disable(void);
+
+int systracker_set_watchpoint_addr(unsigned int phy_addr);
+int systracker_watchpoint_disable(void);
+int systracker_watchpoint_enable(void);
+
+extern void __iomem *BUS_DBG_BASE;
+extern void __iomem *BUS_DBG_INFRA_BASE;
+
+extern struct mt_systracker_driver *get_mt_systracker_drv(void);
+extern irqreturn_t systracker_isr(void);
+
+/* #define TRACKER_DEBUG 0 */
+
+/* enable for driver poring test suit */
+#define SYSTRACKER_TEST_SUIT
+
+#endif
diff --git a/drivers/spi/spi-mt65xx.c b/drivers/spi/spi-mt65xx.c
index 6e95efb50acbc08f6574efbdc4855ee5bd19fc6e..33254fca6e56ed0e4a62614f6e07411747b84d41 100644
--- a/drivers/spi/spi-mt65xx.c
+++ b/drivers/spi/spi-mt65xx.c
@@ -786,22 +786,21 @@ static irqreturn_t mtk_spi_interrupt(int irq, void *dev_id)
 		len = trans->len - mdata->num_xfered;
 		mdata->xfer_len = min(MTK_SPI_MAX_FIFO_SIZE, len);
 		mtk_spi_setup_packet(master);
-
-		cnt = mdata->xfer_len / 4;
-		iowrite32_rep(mdata->base + SPI_TX_DATA_REG,
-				trans->tx_buf + mdata->num_xfered, cnt);
-
-		remainder = mdata->xfer_len % 4;
-		if (remainder > 0) {
-			reg_val = 0;
-			memcpy(&reg_val,
-				trans->tx_buf + (cnt * 4) + mdata->num_xfered,
-				remainder);
-			writel(reg_val, mdata->base + SPI_TX_DATA_REG);
+		//crash: trans->tx_buf possibly be NULL
+		if (trans->tx_buf) {
+			cnt = mdata->xfer_len / 4;
+			iowrite32_rep(mdata->base + SPI_TX_DATA_REG,
+				      trans->tx_buf + mdata->num_xfered, cnt);
+			remainder = mdata->xfer_len % 4;
+			if (remainder > 0) {
+				reg_val = 0;
+				memcpy(&reg_val,
+					trans->tx_buf + (cnt * 4) + mdata->num_xfered,
+					remainder);
+				writel(reg_val, mdata->base + SPI_TX_DATA_REG);
+			}
 		}
-
 		mtk_spi_enable_transfer(master);
-
 		return IRQ_HANDLED;
 	}
 
diff --git a/drivers/thermal/mediatek/Kconfig b/drivers/thermal/mediatek/Kconfig
index 150c89fdc6b07ca58f653e18bb01b3827a5f7321..6dfb9c70b33fe9351aca96ce83466e0d287e38bd 100644
--- a/drivers/thermal/mediatek/Kconfig
+++ b/drivers/thermal/mediatek/Kconfig
@@ -1,34 +1,72 @@
 config MTK_THERMAL
-	tristate "Mediatek thermal drivers"
+	tristate "MediaTek thermal drivers"
 	depends on THERMAL_OF
 	help
-	  This is the option for Mediatek thermal software
-	  solutions. Please enable corresponding options to
-	  get temperature information from thermal sensors or
-	  turn on throttle mechaisms for thermal mitigation.
+		This is the option for MediaTek thermal software
+		solutions. Please enable corresponding options to
+		get temperature information from thermal sensors or
+		turn on throttle mechaisms for thermal mitigation.
 
 if MTK_THERMAL
 
 config MTK_SOC_THERMAL
-	bool "Temperature sensor driver for mediatek SoCs"
+	tristate "Temperature sensor driver for MediaTek SoCs"
 	depends on HAS_IOMEM
 	depends on NVMEM
 	depends on RESET_CONTROLLER
-	depends on CPU_FREQ
 	help
-	  Enable this option if you want to get SoC temperature
-	  information for Mediatek platforms. This driver
-	  configures thermal controllers to collect temperature
-	  via AUXADC interface.
+		Enable this option if you want to get SoC temperature
+		information for MediaTek platforms. This driver
+		configures thermal controllers to collect temperature
+		via AUXADC interface.
 
 config MTK_SOC_THERMAL_LVTS
-        tristate "LVTS (Low voltage thermal sensor) driver for Mediatek SoCs"
-        depends on HAS_IOMEM
-        depends on NVMEM
-        depends on RESET_TI_SYSCON
-        help
-          Enable this option if you want to get SoC temperature
-          information for Mediatek platforms. This driver
-          configures LVTS thermal controllers to collect temperatures
-          via Analog Serial Interface(ASIF).
+	tristate "LVTS (Low voltage thermal sensor) driver for Mediatek SoCs"
+	depends on HAS_IOMEM
+	depends on NVMEM
+	help
+		Enable this option if you want to get SoC temperature
+		information for MediaTek platforms. This driver
+		configures LVTS thermal controllers to collect temperatures
+		via Analog Serial Interface(ASIF).
+
+endif
+
+if MTK_SOC_THERMAL_LVTS
+
+config LVTS_MT8188
+	tristate "LVTS driver for MediaTek MT8188 SoC"
+	depends on HAS_IOMEM
+	depends on NVMEM
+	depends on MTK_SOC_THERMAL_LVTS
+	help
+		Enable this option if you want to get SoC temperature
+		information for MT8188. This driver
+		configures LVTS thermal controllers to collect temperatures
+		via ASIF.
+
+config LVTS_MT8192
+	tristate "LVTS driver for MediaTek MT8192 SoC"
+	depends on HAS_IOMEM
+	depends on NVMEM
+	depends on RESET_TI_SYSCON
+	depends on MTK_SOC_THERMAL_LVTS
+	help
+		Enable this option if you want to get SoC temperature
+		information for MT8192. This driver
+		configures LVTS thermal controllers to collect temperatures
+		via ASIF.
+
+config LVTS_MT8195
+	tristate "LVTS driver for MediaTek MT8195 SoC"
+	depends on HAS_IOMEM
+	depends on NVMEM
+	depends on RESET_TI_SYSCON
+	depends on MTK_SOC_THERMAL_LVTS
+	help
+		Enable this option if you want to get SoC temperature
+		information for MT8195. This driver
+		configures LVTS thermal controllers to collect temperatures
+		via ASIF.
+
 endif
diff --git a/drivers/thermal/mediatek/Makefile b/drivers/thermal/mediatek/Makefile
index 16ce166e59162e3d5649650ddaf5c699ea6cf647..151368fa7edc6559d7d118f2e2bdeaff6400b778 100644
--- a/drivers/thermal/mediatek/Makefile
+++ b/drivers/thermal/mediatek/Makefile
@@ -1,2 +1,5 @@
-obj-$(CONFIG_MTK_SOC_THERMAL)	+= soc_temp.o
+obj-$(CONFIG_MTK_SOC_THERMAL)		+= soc_temp.o
 obj-$(CONFIG_MTK_SOC_THERMAL_LVTS)	+= soc_temp_lvts.o
+obj-$(CONFIG_LVTS_MT8188)			+= lvts_mt8188.o virtual_temp.o
+obj-$(CONFIG_LVTS_MT8192)			+= lvts_mt8192.o
+obj-$(CONFIG_LVTS_MT8195)			+= lvts_mt8195.o
diff --git a/drivers/thermal/mediatek/lvts_mt8188.c b/drivers/thermal/mediatek/lvts_mt8188.c
new file mode 100644
index 0000000000000000000000000000000000000000..9db3a6f9bfe69b863391da36ad75107866f2ede5
--- /dev/null
+++ b/drivers/thermal/mediatek/lvts_mt8188.c
@@ -0,0 +1,239 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Copyright (c) 2022 MediaTek Inc.
+ */
+
+#include <linux/of_irq.h>
+#include <linux/platform_device.h>
+#include "soc_temp_lvts.h"
+
+enum mt8188_lvts_mcu_sensor_enum {
+	MT8188_TS1_0,
+	MT8188_TS1_1,
+	MT8188_TS1_2,
+	MT8188_TS1_3,
+	MT8188_TS2_0,
+	MT8188_TS2_1,
+	MT8188_NUM_TS_MCU
+};
+
+enum mt8188_lvts_ap_sensor_enum {
+	MT8188_TS3_1,
+	MT8188_TS4_0,
+	MT8188_TS4_1,
+	MT8188_TS4_2,
+	MT8188_TS5_0,
+	MT8188_TS5_1,
+	MT8188_TS6_0,
+	MT8188_TS6_1,
+	MT8188_NUM_TS_AP
+};
+
+static void mt8188_mcu_efuse_to_cal_data(struct lvts_data *lvts_data)
+{
+	struct lvts_sensor_cal_data *cal_data = &lvts_data->cal_data;
+
+	cal_data->golden_temp = GET_CAL_DATA_BITMASK(0, lvts_data, 27, 20);
+
+	cal_data->count_r[MT8188_TS1_0] = (GET_CAL_DATA_BITMASK(6, lvts_data, 7, 0) << 16) +
+		GET_CAL_DATA_BITMASK(5, lvts_data, 31, 16);
+	cal_data->count_r[MT8188_TS1_1] = GET_CAL_DATA_BITMASK(6, lvts_data, 31, 8);
+	cal_data->count_r[MT8188_TS1_2] = GET_CAL_DATA_BITMASK(7, lvts_data, 23, 0);
+	cal_data->count_r[MT8188_TS1_3] = (GET_CAL_DATA_BITMASK(8, lvts_data, 15, 0) << 8) +
+		GET_CAL_DATA_BITMASK(7, lvts_data, 31, 24);
+	cal_data->count_r[MT8188_TS2_0] = (GET_CAL_DATA_BITMASK(9, lvts_data, 7, 0) << 16) +
+		GET_CAL_DATA_BITMASK(8, lvts_data, 31, 16);
+	cal_data->count_r[MT8188_TS2_1] = GET_CAL_DATA_BITMASK(9, lvts_data, 31, 8);
+
+	cal_data->count_rc[MT8188_TS1_0] = GET_CAL_DATA_BITMASK(1, lvts_data, 23, 0);
+	cal_data->count_rc[MT8188_TS2_0] = (GET_CAL_DATA_BITMASK(2, lvts_data, 15, 0) << 8) +
+		GET_CAL_DATA_BITMASK(1, lvts_data, 31, 24);
+}
+
+static void mt8188_ap_efuse_to_cal_data(struct lvts_data *lvts_data)
+{
+	struct lvts_sensor_cal_data *cal_data = &lvts_data->cal_data;
+
+	cal_data->golden_temp = GET_CAL_DATA_BITMASK(0, lvts_data, 27, 20);
+
+	cal_data->count_r[MT8188_TS3_1] = GET_CAL_DATA_BITMASK(10, lvts_data, 23, 0);
+	cal_data->count_r[MT8188_TS4_0] = (GET_CAL_DATA_BITMASK(11, lvts_data, 15, 0) << 8) +
+		GET_CAL_DATA_BITMASK(10, lvts_data, 31, 24);
+	cal_data->count_r[MT8188_TS4_1] = (GET_CAL_DATA_BITMASK(12, lvts_data, 7, 0) << 16) +
+		GET_CAL_DATA_BITMASK(11, lvts_data, 31, 16);
+	cal_data->count_r[MT8188_TS4_2] = GET_CAL_DATA_BITMASK(12, lvts_data, 31, 8);
+	cal_data->count_r[MT8188_TS5_0] = GET_CAL_DATA_BITMASK(13, lvts_data, 23, 0);
+	cal_data->count_r[MT8188_TS5_1] = (GET_CAL_DATA_BITMASK(14, lvts_data, 15, 0) << 8) +
+		GET_CAL_DATA_BITMASK(13, lvts_data, 31, 24);
+	cal_data->count_r[MT8188_TS6_0] = (GET_CAL_DATA_BITMASK(15, lvts_data, 7, 0) << 16) +
+		GET_CAL_DATA_BITMASK(14, lvts_data, 31, 16);
+	cal_data->count_r[MT8188_TS6_1] = GET_CAL_DATA_BITMASK(15, lvts_data, 31, 8);
+
+	cal_data->count_rc[MT8188_TS3_1] = (GET_CAL_DATA_BITMASK(3, lvts_data, 7, 0) << 16) +
+		GET_CAL_DATA_BITMASK(2, lvts_data, 31, 16);
+	cal_data->count_rc[MT8188_TS4_0] = GET_CAL_DATA_BITMASK(3, lvts_data, 31, 8);
+	cal_data->count_rc[MT8188_TS5_0] = GET_CAL_DATA_BITMASK(4, lvts_data, 23, 0);
+	cal_data->count_rc[MT8188_TS6_0] = (GET_CAL_DATA_BITMASK(5, lvts_data, 15, 0) << 8) +
+		GET_CAL_DATA_BITMASK(4, lvts_data, 31, 24);
+}
+
+static struct lvts_speed_settings tc_speed_mt8188 = {
+	.period_unit = PERIOD_UNIT,
+	.group_interval_delay = GROUP_INTERVAL_DELAY,
+	.filter_interval_delay = FILTER_INTERVAL_DELAY,
+	.sensor_interval_delay = SENSOR_INTERVAL_DELAY,
+};
+
+static const struct lvts_tc_settings mt8188_tc_mcu_settings[] = {
+	[0] = {
+		.dev_id = 0x81,
+		.addr_offset = 0x0,
+		.num_sensor = 4,
+		.ts_offset = 0,
+		.sensor_map = {MT8188_TS1_0, MT8188_TS1_1, MT8188_TS1_2, MT8188_TS1_3},
+		.tc_speed = &tc_speed_mt8188,
+		.hw_filter = LVTS_FILTER_2_OF_4,
+		.dominator_sensing_point = SENSING_POINT1,
+		.hw_reboot_trip_point = HW_REBOOT_TRIP_POINT,
+		.irq_bit = BIT(3),
+	},
+	[1] = {
+		.dev_id = 0x82,
+		.addr_offset = 0x100,
+		.num_sensor = 2,
+		.ts_offset = 0,
+		.sensor_map = {MT8188_TS2_0, MT8188_TS2_1},
+		.tc_speed = &tc_speed_mt8188,
+		.hw_filter = LVTS_FILTER_2_OF_4,
+		.dominator_sensing_point = SENSING_POINT0,
+		.hw_reboot_trip_point = HW_REBOOT_TRIP_POINT,
+		.irq_bit = BIT(4),
+	}
+};
+
+static const struct lvts_tc_settings mt8188_tc_ap_settings[] = {
+	[0] = {
+		.dev_id = 0x83,
+		.addr_offset = 0x0,
+		.num_sensor = 1,
+		.ts_offset = 1,
+		.sensor_map = {MT8188_TS3_1},
+		.tc_speed = &tc_speed_mt8188,
+		.hw_filter = LVTS_FILTER_2_OF_4,
+		.dominator_sensing_point = SENSING_POINT1,
+		.hw_reboot_trip_point = HW_REBOOT_TRIP_POINT,
+		.irq_bit = BIT(3),
+	},
+	[1] = {
+		.dev_id = 0x84,
+		.addr_offset = 0x100,
+		.num_sensor = 3,
+		.ts_offset = 0,
+		.sensor_map = {MT8188_TS4_0, MT8188_TS4_1, MT8188_TS4_2},
+		.tc_speed = &tc_speed_mt8188,
+		.hw_filter = LVTS_FILTER_2_OF_4,
+		.dominator_sensing_point = SENSING_POINT1,
+		.hw_reboot_trip_point = HW_REBOOT_TRIP_POINT,
+		.irq_bit = BIT(4),
+	},
+	[2] = {
+		.dev_id = 0x85,
+		.addr_offset = 0x200,
+		.num_sensor = 2,
+		.ts_offset = 0,
+		.sensor_map = {MT8188_TS5_0, MT8188_TS5_1},
+		.tc_speed = &tc_speed_mt8188,
+		.hw_filter = LVTS_FILTER_2_OF_4,
+		.dominator_sensing_point = SENSING_POINT1,
+		.hw_reboot_trip_point = HW_REBOOT_TRIP_POINT,
+		.irq_bit = BIT(5),
+	},
+	[3] = {
+		.dev_id = 0x86,
+		.addr_offset = 0x300,
+		.num_sensor = 2,
+		.ts_offset = 0,
+		.sensor_map = {MT8188_TS6_0, MT8188_TS6_1},
+		.tc_speed = &tc_speed_mt8188,
+		.hw_filter = LVTS_FILTER_2_OF_4,
+		.dominator_sensing_point = SENSING_POINT0,
+		.hw_reboot_trip_point = HW_REBOOT_TRIP_POINT,
+		.irq_bit = BIT(6),
+	}
+};
+
+static struct lvts_data mt8188_lvts_mcu_data = {
+	.num_tc = (ARRAY_SIZE(mt8188_tc_mcu_settings)),
+	.tc = mt8188_tc_mcu_settings,
+	.num_sensor = MT8188_NUM_TS_MCU,
+	.ops = {
+		.efuse_to_cal_data = mt8188_mcu_efuse_to_cal_data,
+		.device_enable_and_init = lvts_device_enable_and_init_v5,
+		.device_enable_auto_rck = lvts_device_enable_auto_rck_v4,
+		.device_read_count_rc_n = lvts_device_read_count_rc_n_v4,
+		.set_cal_data = lvts_set_calibration_data_v4,
+		.init_controller = lvts_init_controller_v4,
+	},
+	.feature_bitmap = FEATURE_DEVICE_AUTO_RCK | FEATURE_CK26M_ACTIVE,
+	.num_efuse_addr = NUM_EFUSE_ADDR_MT8188,
+	.num_efuse_block = NUM_EFUSE_BLOCK_MT8188,
+	.cal_data = {
+		.default_golden_temp = DEFAULT_GOLDEN_TEMP,
+		.default_count_r = DEFAULT_CUONT_R,
+		.default_count_rc = DEFAULT_CUONT_RC,
+	},
+	.coeff = {
+		.a = COEFF_A,
+		.b = COEFF_B,
+	},
+};
+
+static struct lvts_data mt8188_lvts_ap_data = {
+	.num_tc = (ARRAY_SIZE(mt8188_tc_ap_settings)),
+	.tc = mt8188_tc_ap_settings,
+	.num_sensor = MT8188_NUM_TS_AP,
+	.ops = {
+		.efuse_to_cal_data = mt8188_ap_efuse_to_cal_data,
+		.device_enable_and_init = lvts_device_enable_and_init_v5,
+		.device_enable_auto_rck = lvts_device_enable_auto_rck_v4,
+		.device_read_count_rc_n = lvts_device_read_count_rc_n_v4,
+		.set_cal_data = lvts_set_calibration_data_v4,
+		.init_controller = lvts_init_controller_v4,
+	},
+	.feature_bitmap = FEATURE_DEVICE_AUTO_RCK | FEATURE_CK26M_ACTIVE,
+	.num_efuse_addr = NUM_EFUSE_ADDR_MT8188,
+	.num_efuse_block = NUM_EFUSE_BLOCK_MT8188,
+	.cal_data = {
+		.default_golden_temp = DEFAULT_GOLDEN_TEMP,
+		.default_count_r = DEFAULT_CUONT_R,
+		.default_count_rc = DEFAULT_CUONT_RC,
+	},
+	.coeff = {
+		.a = COEFF_A,
+		.b = COEFF_B,
+	},
+};
+
+static const struct of_device_id lvts_of_match[] = {
+	{ .compatible = "mediatek,mt8188-lvts-mcu", .data = &mt8188_lvts_mcu_data, },
+	{ .compatible = "mediatek,mt8188-lvts-ap", .data = &mt8188_lvts_ap_data, },
+	{},
+};
+MODULE_DEVICE_TABLE(of, lvts_of_match);
+
+static struct platform_driver soc_temp_lvts = {
+	.probe = lvts_probe,
+	.remove = lvts_remove,
+	.suspend = lvts_suspend,
+	.resume = lvts_resume,
+	.driver = {
+		.name = "mtk-soc-temp-lvts-mt8188",
+		.of_match_table = lvts_of_match,
+	},
+};
+module_platform_driver(soc_temp_lvts);
+
+MODULE_AUTHOR("Yu-Chia Chang <ethan.chang@mediatek.com>");
+MODULE_AUTHOR("Michael Kao <michael.kao@mediatek.com>");
+MODULE_DESCRIPTION("MediaTek soc temperature driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/thermal/mediatek/lvts_mt8192.c b/drivers/thermal/mediatek/lvts_mt8192.c
new file mode 100644
index 0000000000000000000000000000000000000000..cd405b4777bed9a2d21af836806702da47d56833
--- /dev/null
+++ b/drivers/thermal/mediatek/lvts_mt8192.c
@@ -0,0 +1,248 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Copyright (c) 2022 MediaTek Inc.
+ */
+
+#include <linux/of_irq.h>
+#include <linux/platform_device.h>
+#include "soc_temp_lvts.h"
+
+enum mt8192_lvts_mcu_sensor_enum {
+	MT8192_TS1_0,
+	MT8192_TS1_1,
+	MT8192_TS2_0,
+	MT8192_TS2_1,
+	MT8192_TS3_0,
+	MT8192_TS3_1,
+	MT8192_TS3_2,
+	MT8192_TS3_3,
+	MT8192_NUM_TS_MCU
+};
+
+enum mt8192_lvts_ap_sensor_enum {
+	MT8192_TS4_0,
+	MT8192_TS4_1,
+	MT8192_TS5_0,
+	MT8192_TS5_1,
+	MT8192_TS6_0,
+	MT8192_TS6_1,
+	MT8192_TS7_0,
+	MT8192_TS7_1,
+	MT8192_TS7_2,
+	MT8192_NUM_TS_AP
+};
+
+static void mt8192_mcu_efuse_to_cal_data(struct lvts_data *lvts_data)
+{
+	struct lvts_sensor_cal_data *cal_data = &lvts_data->cal_data;
+	unsigned int i, j;
+	const unsigned int mt8192_TS[] = {MT8192_TS2_0, MT8192_TS3_0};
+
+	cal_data->golden_temp = GET_CAL_DATA_BITMASK(0, lvts_data, 31, 24);
+
+	for (i = 0; i < MT8192_NUM_TS_MCU; i++)
+		cal_data->count_r[i] = GET_CAL_DATA_BITMASK(i + 1, lvts_data, 23, 0);
+
+	cal_data->count_rc[MT8192_TS1_0] = GET_CAL_DATA_BITMASK(21, lvts_data, 23, 0);
+
+	for (i = 0; i < (ARRAY_SIZE(mt8192_TS)); i++) {
+		for (j = 1; j <= 18; j++) {
+			cal_data->count_rc[mt8192_TS[i]] = (GET_CAL_DATA_BITMASK(j, lvts_data, 31, 24) << 16) +
+				(GET_CAL_DATA_BITMASK(j, lvts_data, 31, 24) << 8) +
+					GET_CAL_DATA_BITMASK(j, lvts_data, 31, 24);
+		}
+	}
+}
+
+static void mt8192_ap_efuse_to_cal_data(struct lvts_data *lvts_data)
+{
+	struct lvts_sensor_cal_data *cal_data = &lvts_data->cal_data;
+	unsigned int i, j;
+	const unsigned int mt8192_TS[] = {MT8192_TS4_0, MT8192_TS5_0, MT8192_TS6_0, MT8192_TS7_0};
+
+	cal_data->golden_temp = GET_CAL_DATA_BITMASK(0, lvts_data, 31, 24);
+
+	for (i = 0; i < MT8192_NUM_TS_AP; i++)
+		cal_data->count_r[i] = GET_CAL_DATA_BITMASK(i + 1, lvts_data, 23, 0);
+
+	for (i = 0; i < (ARRAY_SIZE(mt8192_TS)); i++) {
+		for (j = 1; j <= 18; j++) {
+			cal_data->count_rc[mt8192_TS[i]] = (GET_CAL_DATA_BITMASK(j, lvts_data, 31, 24) << 16) +
+				(GET_CAL_DATA_BITMASK(j, lvts_data, 31, 24) << 8) +
+					GET_CAL_DATA_BITMASK(j, lvts_data, 31, 24);
+		}
+	}
+}
+
+static struct lvts_speed_settings tc_speed_mt8192 = {
+	.period_unit = PERIOD_UNIT,
+	.group_interval_delay = GROUP_INTERVAL_DELAY,
+	.filter_interval_delay = FILTER_INTERVAL_DELAY,
+	.sensor_interval_delay = SENSOR_INTERVAL_DELAY,
+};
+
+static const struct lvts_tc_settings mt8192_tc_mcu_settings[] = {
+	[0] = {
+		.dev_id = 0x81,
+		.addr_offset = 0x0,
+		.num_sensor = 2,
+		.ts_offset = 0,
+		.sensor_map = {MT8192_TS1_0, MT8192_TS1_1},
+		.tc_speed = &tc_speed_mt8192,
+		.hw_filter = LVTS_FILTER_2_OF_4,
+		.dominator_sensing_point = SENSING_POINT1,
+		.hw_reboot_trip_point = HW_REBOOT_TRIP_POINT,
+		.irq_bit = BIT(3),
+	},
+	[1] = {
+		.dev_id = 0x82,
+		.addr_offset = 0x100,
+		.num_sensor = 2,
+		.ts_offset = 0,
+		.sensor_map = {MT8192_TS2_0, MT8192_TS2_1},
+		.tc_speed = &tc_speed_mt8192,
+		.hw_filter = LVTS_FILTER_2_OF_4,
+		.dominator_sensing_point = SENSING_POINT0,
+		.hw_reboot_trip_point = HW_REBOOT_TRIP_POINT,
+		.irq_bit = BIT(4),
+	},
+	[2] = {
+		.dev_id = 0x83,
+		.addr_offset = 0x200,
+		.num_sensor = 4,
+		.ts_offset = 0,
+		.sensor_map = {MT8192_TS3_0, MT8192_TS3_1, MT8192_TS3_2, MT8192_TS3_3},
+		.tc_speed = &tc_speed_mt8192,
+		.hw_filter = LVTS_FILTER_2_OF_4,
+		.dominator_sensing_point = SENSING_POINT0,
+		.hw_reboot_trip_point = HW_REBOOT_TRIP_POINT,
+		.irq_bit = BIT(5),
+	}
+};
+
+static const struct lvts_tc_settings mt8192_tc_ap_settings[] = {
+	[0] = {
+		.dev_id = 0x84,
+		.addr_offset = 0x0,
+		.num_sensor = 2,
+		.ts_offset = 0,
+		.sensor_map = {MT8192_TS4_0, MT8192_TS4_1},
+		.tc_speed = &tc_speed_mt8192,
+		.hw_filter = LVTS_FILTER_2_OF_4,
+		.dominator_sensing_point = SENSING_POINT0,
+		.hw_reboot_trip_point = HW_REBOOT_TRIP_POINT,
+		.irq_bit = BIT(3),
+	},
+	[1] = {
+		.dev_id = 0x85,
+		.addr_offset = 0x100,
+		.num_sensor = 2,
+		.ts_offset = 0,
+		.sensor_map = {MT8192_TS5_0, MT8192_TS5_1},
+		.tc_speed = &tc_speed_mt8192,
+		.hw_filter = LVTS_FILTER_2_OF_4,
+		.dominator_sensing_point = SENSING_POINT1,
+		.hw_reboot_trip_point = HW_REBOOT_TRIP_POINT,
+		.irq_bit = BIT(4),
+	},
+	[2] = {
+		.dev_id = 0x86,
+		.addr_offset = 0x200,
+		.num_sensor = 2,
+		.ts_offset = 0,
+		.sensor_map = {MT8192_TS6_0, MT8192_TS6_1},
+		.tc_speed = &tc_speed_mt8192,
+		.hw_filter = LVTS_FILTER_2_OF_4,
+		.dominator_sensing_point = SENSING_POINT1,
+		.hw_reboot_trip_point = HW_REBOOT_TRIP_POINT,
+		.irq_bit = BIT(5),
+	},
+	[3] = {
+		.dev_id = 0x87,
+		.addr_offset = 0x300,
+		.num_sensor = 3,
+		.ts_offset = 0,
+		.sensor_map = {MT8192_TS7_0, MT8192_TS7_1, MT8192_TS7_2},
+		.tc_speed = &tc_speed_mt8192,
+		.hw_filter = LVTS_FILTER_2_OF_4,
+		.dominator_sensing_point = SENSING_POINT2,
+		.hw_reboot_trip_point = HW_REBOOT_TRIP_POINT,
+		.irq_bit = BIT(6),
+	}
+};
+
+static const struct lvts_data mt8192_lvts_mcu_data = {
+	.num_tc = (ARRAY_SIZE(mt8192_tc_mcu_settings)),
+	.tc = mt8192_tc_mcu_settings,
+	.num_sensor = MT8192_NUM_TS_MCU,
+	.ops = {
+		.efuse_to_cal_data = mt8192_mcu_efuse_to_cal_data,
+		.device_enable_and_init = lvts_device_enable_and_init_v4,
+		.device_enable_auto_rck = lvts_device_enable_auto_rck_v4,
+		.device_read_count_rc_n = lvts_device_read_count_rc_n_v4,
+		.set_cal_data = lvts_set_calibration_data_v4,
+		.init_controller = lvts_init_controller_v4,
+	},
+	.feature_bitmap = FEATURE_DEVICE_AUTO_RCK,
+	.num_efuse_addr = NUM_EFUSE_ADDR,
+	.num_efuse_block = NUM_EFUSE_BLOCK_MT8192,
+	.cal_data = {
+		.default_golden_temp = DEFAULT_GOLDEN_TEMP,
+		.default_count_r = DEFAULT_CUONT_R,
+		.default_count_rc = DEFAULT_CUONT_RC,
+	},
+	.coeff = {
+		.a = COEFF_A,
+		.b = COEFF_B,
+	},
+};
+
+static const struct lvts_data mt8192_lvts_ap_data = {
+	.num_tc = (ARRAY_SIZE(mt8192_tc_ap_settings)),
+	.tc = mt8192_tc_ap_settings,
+	.num_sensor = MT8192_NUM_TS_AP,
+	.ops = {
+		.efuse_to_cal_data = mt8192_ap_efuse_to_cal_data,
+		.device_enable_and_init = lvts_device_enable_and_init_v4,
+		.device_enable_auto_rck = lvts_device_enable_auto_rck_v4,
+		.device_read_count_rc_n = lvts_device_read_count_rc_n_v4,
+		.set_cal_data = lvts_set_calibration_data_v4,
+		.init_controller = lvts_init_controller_v4,
+	},
+	.feature_bitmap = FEATURE_DEVICE_AUTO_RCK,
+	.num_efuse_addr = NUM_EFUSE_ADDR,
+	.num_efuse_block = NUM_EFUSE_BLOCK_MT8192,
+	.cal_data = {
+		.default_golden_temp = DEFAULT_GOLDEN_TEMP,
+		.default_count_r = DEFAULT_CUONT_R,
+		.default_count_rc = DEFAULT_CUONT_RC,
+	},
+	.coeff = {
+		.a = COEFF_A,
+		.b = COEFF_B,
+	},
+};
+
+static const struct of_device_id lvts_of_match[] = {
+	{ .compatible = "mediatek,mt8192-lvts-mcu", .data = &mt8192_lvts_mcu_data, },
+	{ .compatible = "mediatek,mt8192-lvts-ap", .data = &mt8192_lvts_ap_data, },
+	{},
+};
+MODULE_DEVICE_TABLE(of, lvts_of_match);
+
+static struct platform_driver soc_temp_lvts = {
+	.probe = lvts_probe,
+	.remove = lvts_remove,
+	.suspend = lvts_suspend,
+	.resume = lvts_resume,
+	.driver = {
+		.name = "mtk-soc-temp-lvts-mt8192",
+		.of_match_table = lvts_of_match,
+	},
+};
+module_platform_driver(soc_temp_lvts);
+
+MODULE_AUTHOR("Yu-Chia Chang <ethan.chang@mediatek.com>");
+MODULE_AUTHOR("Michael Kao <michael.kao@mediatek.com>");
+MODULE_DESCRIPTION("MediaTek soc temperature driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/thermal/mediatek/lvts_mt8195.c b/drivers/thermal/mediatek/lvts_mt8195.c
new file mode 100644
index 0000000000000000000000000000000000000000..7e5168e3d3179e756a146ca1728f8caa641ef336
--- /dev/null
+++ b/drivers/thermal/mediatek/lvts_mt8195.c
@@ -0,0 +1,260 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Copyright (c) 2022 MediaTek Inc.
+ */
+
+#include <linux/of_irq.h>
+#include <linux/platform_device.h>
+#include "soc_temp_lvts.h"
+
+enum mt8195_lvts_mcu_sensor_enum {
+	MT8195_TS1_0,		// cpu_big1
+	MT8195_TS1_1,		// cpu_big2
+	MT8195_TS2_0,		// cpu_big3
+	MT8195_TS2_1,		// cpu_big4
+	MT8195_TS3_0,		// cpu_little1
+	MT8195_TS3_1,		// cpu_little2
+	MT8195_TS3_2,		// cpu_little3
+	MT8195_TS3_3,		// cpu_little4
+	MT8195_NUM_TS_MCU
+};
+
+enum mt8195_lvts_ap_sensor_enum {
+	MT8195_TS4_0,		// vpu1
+	MT8195_TS4_1,		// vpu2
+	MT8195_TS5_0,		// gpu1
+	MT8195_TS5_1,		// gpu2
+	MT8195_TS6_0,		// vdec
+	MT8195_TS6_1,		// img
+	MT8195_TS6_2,		// infra
+	MT8195_TS7_0,		// cam1
+	MT8195_TS7_1,		// cam2
+	MT8195_NUM_TS_AP
+};
+
+static void mt8195_mcu_efuse_to_cal_data(struct lvts_data *lvts_data)
+{
+	struct lvts_sensor_cal_data *cal_data = &lvts_data->cal_data;
+
+	cal_data->golden_temp = GET_CAL_DATA_BITMASK(0, lvts_data, 31, 24);
+
+	cal_data->count_r[MT8195_TS1_0] = GET_CAL_DATA_BITMASK(1, lvts_data, 23, 0);
+	cal_data->count_r[MT8195_TS1_1] = (GET_CAL_DATA_BITMASK(2, lvts_data, 15, 0) << 8) +
+		GET_CAL_DATA_BITMASK(1, lvts_data, 31, 24);
+	cal_data->count_r[MT8195_TS2_0] = GET_CAL_DATA_BITMASK(3, lvts_data, 31, 8);
+	cal_data->count_r[MT8195_TS2_1] = GET_CAL_DATA_BITMASK(4, lvts_data, 23, 0);
+	cal_data->count_r[MT8195_TS3_0] = (GET_CAL_DATA_BITMASK(6, lvts_data, 7, 0) << 16) +
+		GET_CAL_DATA_BITMASK(5, lvts_data, 31, 16);
+	cal_data->count_r[MT8195_TS3_1] = GET_CAL_DATA_BITMASK(6, lvts_data, 31, 8);
+	cal_data->count_r[MT8195_TS3_2] = GET_CAL_DATA_BITMASK(7, lvts_data, 23, 0);
+	cal_data->count_r[MT8195_TS3_3] = (GET_CAL_DATA_BITMASK(8, lvts_data, 15, 0) << 8) +
+		GET_CAL_DATA_BITMASK(7, lvts_data, 31, 24);
+
+	cal_data->count_rc[MT8195_TS1_0] = (GET_CAL_DATA_BITMASK(3, lvts_data, 7, 0) << 16) +
+		GET_CAL_DATA_BITMASK(2, lvts_data, 31, 16);
+	cal_data->count_rc[MT8195_TS2_0] = (GET_CAL_DATA_BITMASK(5, lvts_data, 15, 0) << 8) +
+		GET_CAL_DATA_BITMASK(4, lvts_data, 31, 24);
+	cal_data->count_rc[MT8195_TS3_0] = (GET_CAL_DATA_BITMASK(9, lvts_data, 7, 0) << 16) +
+		GET_CAL_DATA_BITMASK(8, lvts_data, 31, 16);
+}
+
+static void mt8195_ap_efuse_to_cal_data(struct lvts_data *lvts_data)
+{
+	struct lvts_sensor_cal_data *cal_data = &lvts_data->cal_data;
+
+	cal_data->golden_temp = GET_CAL_DATA_BITMASK(0, lvts_data, 31, 24);
+
+	cal_data->count_r[MT8195_TS4_0] = GET_CAL_DATA_BITMASK(9, lvts_data, 31, 8);
+	cal_data->count_r[MT8195_TS4_1] = GET_CAL_DATA_BITMASK(10, lvts_data, 23, 0);
+	cal_data->count_r[MT8195_TS5_0] = (GET_CAL_DATA_BITMASK(12, lvts_data, 7, 0) << 16) +
+		GET_CAL_DATA_BITMASK(11, lvts_data, 31, 16);
+	cal_data->count_r[MT8195_TS5_1] = GET_CAL_DATA_BITMASK(12, lvts_data, 31, 8);
+	cal_data->count_r[MT8195_TS6_0] = (GET_CAL_DATA_BITMASK(14, lvts_data, 15, 0) << 8) +
+		GET_CAL_DATA_BITMASK(13, lvts_data, 31, 24);
+	cal_data->count_r[MT8195_TS6_1] = (GET_CAL_DATA_BITMASK(15, lvts_data, 7, 0) << 16) +
+		GET_CAL_DATA_BITMASK(14, lvts_data, 31, 16);
+	cal_data->count_r[MT8195_TS6_2] = GET_CAL_DATA_BITMASK(15, lvts_data, 31, 8);
+	cal_data->count_r[MT8195_TS7_0] = (GET_CAL_DATA_BITMASK(17, lvts_data, 15, 0) << 8) +
+		GET_CAL_DATA_BITMASK(16, lvts_data, 31, 24);
+	cal_data->count_r[MT8195_TS7_1] = (GET_CAL_DATA_BITMASK(18, lvts_data, 7, 0) << 16) +
+		GET_CAL_DATA_BITMASK(17, lvts_data, 31, 16);
+
+	cal_data->count_rc[MT8195_TS4_0] = (GET_CAL_DATA_BITMASK(11, lvts_data, 15, 0) << 8) +
+						GET_CAL_DATA_BITMASK(10, lvts_data, 31, 24);
+	cal_data->count_rc[MT8195_TS5_0] = GET_CAL_DATA_BITMASK(13, lvts_data, 23, 0);
+	cal_data->count_rc[MT8195_TS6_0] = GET_CAL_DATA_BITMASK(16, lvts_data, 23, 0);
+	cal_data->count_rc[MT8195_TS7_0] = GET_CAL_DATA_BITMASK(18, lvts_data, 31, 8);
+}
+
+static struct lvts_speed_settings tc_speed_mt8195 = {
+	.period_unit = PERIOD_UNIT,
+	.group_interval_delay = GROUP_INTERVAL_DELAY,
+	.filter_interval_delay = FILTER_INTERVAL_DELAY,
+	.sensor_interval_delay = SENSOR_INTERVAL_DELAY,
+};
+
+static const struct lvts_tc_settings mt8195_tc_mcu_settings[] = {
+	[0] = {
+		.dev_id = 0x81,
+		.addr_offset = 0x0,
+		.num_sensor = 2,
+		.ts_offset = 0,
+		.sensor_map = {MT8195_TS1_0, MT8195_TS1_1},
+		.tc_speed = &tc_speed_mt8195,
+		.hw_filter = LVTS_FILTER_2_OF_4,
+		.dominator_sensing_point = SENSING_POINT1,
+		.hw_reboot_trip_point = HW_REBOOT_TRIP_POINT,
+		.irq_bit = BIT(3),
+	},
+	[1] = {
+		.dev_id = 0x82,
+		.addr_offset = 0x100,
+		.num_sensor = 2,
+		.ts_offset = 0,
+		.sensor_map = {MT8195_TS2_0, MT8195_TS2_1},
+		.tc_speed = &tc_speed_mt8195,
+		.hw_filter = LVTS_FILTER_2_OF_4,
+		.dominator_sensing_point = SENSING_POINT0,
+		.hw_reboot_trip_point = HW_REBOOT_TRIP_POINT,
+		.irq_bit = BIT(4),
+	},
+	[2] = {
+		.dev_id = 0x83,
+		.addr_offset = 0x200,
+		.num_sensor = 4,
+		.ts_offset = 0,
+		.sensor_map = {MT8195_TS3_0, MT8195_TS3_1, MT8195_TS3_2, MT8195_TS3_3},
+		.tc_speed = &tc_speed_mt8195,
+		.hw_filter = LVTS_FILTER_2_OF_4,
+		.dominator_sensing_point = SENSING_POINT0,
+		.hw_reboot_trip_point = HW_REBOOT_TRIP_POINT,
+		.irq_bit = BIT(5),
+	}
+};
+
+static const struct lvts_tc_settings mt8195_tc_ap_settings[] = {
+	[0] = {
+		.dev_id = 0x84,
+		.addr_offset = 0x0,
+		.num_sensor = 2,
+		.ts_offset = 0,
+		.sensor_map = {MT8195_TS4_0, MT8195_TS4_1},
+		.tc_speed = &tc_speed_mt8195,
+		.hw_filter = LVTS_FILTER_2_OF_4,
+		.dominator_sensing_point = SENSING_POINT0,
+		.hw_reboot_trip_point = HW_REBOOT_TRIP_POINT,
+		.irq_bit = BIT(3),
+	},
+	[1] = {
+		.dev_id = 0x85,
+		.addr_offset = 0x100,
+		.num_sensor = 2,
+		.ts_offset = 0,
+		.sensor_map = {MT8195_TS5_0, MT8195_TS5_1},
+		.tc_speed = &tc_speed_mt8195,
+		.hw_filter = LVTS_FILTER_2_OF_4,
+		.dominator_sensing_point = SENSING_POINT1,
+		.hw_reboot_trip_point = HW_REBOOT_TRIP_POINT,
+		.irq_bit = BIT(4),
+	},
+	[2] = {
+		.dev_id = 0x86,
+		.addr_offset = 0x200,
+		.num_sensor = 3,
+		.ts_offset = 0,
+		.sensor_map = {MT8195_TS6_0, MT8195_TS6_1, MT8195_TS6_2},
+		.tc_speed = &tc_speed_mt8195,
+		.hw_filter = LVTS_FILTER_2_OF_4,
+		.dominator_sensing_point = SENSING_POINT1,
+		.hw_reboot_trip_point = HW_REBOOT_TRIP_POINT,
+		.irq_bit = BIT(5),
+	},
+	[3] = {
+		.dev_id = 0x87,
+		.addr_offset = 0x300,
+		.num_sensor = 2,
+		.ts_offset = 0,
+		.sensor_map = {MT8195_TS7_0, MT8195_TS7_1},
+		.tc_speed = &tc_speed_mt8195,
+		.hw_filter = LVTS_FILTER_2_OF_4,
+		.dominator_sensing_point = SENSING_POINT0,
+		.hw_reboot_trip_point = HW_REBOOT_TRIP_POINT,
+		.irq_bit = BIT(6),
+	}
+};
+
+static const struct lvts_data mt8195_lvts_mcu_data = {
+	.num_tc = (ARRAY_SIZE(mt8195_tc_mcu_settings)),
+	.tc = mt8195_tc_mcu_settings,
+	.num_sensor = MT8195_NUM_TS_MCU,
+	.ops = {
+		.efuse_to_cal_data = mt8195_mcu_efuse_to_cal_data,
+		.device_enable_and_init = lvts_device_enable_and_init_v4,
+		.device_enable_auto_rck = lvts_device_enable_auto_rck_v4,
+		.device_read_count_rc_n = lvts_device_read_count_rc_n_v4,
+		.set_cal_data = lvts_set_calibration_data_v4,
+		.init_controller = lvts_init_controller_v4,
+	},
+	.feature_bitmap = FEATURE_DEVICE_AUTO_RCK,
+	.num_efuse_addr = NUM_EFUSE_ADDR,
+	.num_efuse_block = NUM_EFUSE_BLOCK_MT8195,
+	.cal_data = {
+		.default_golden_temp = DEFAULT_GOLDEN_TEMP,
+		.default_count_r = DEFAULT_CUONT_R,
+		.default_count_rc = DEFAULT_CUONT_RC,
+	},
+	.coeff = {
+		.a = COEFF_A,
+		.b = COEFF_B,
+	},
+};
+
+static const struct lvts_data mt8195_lvts_ap_data = {
+	.num_tc = (ARRAY_SIZE(mt8195_tc_ap_settings)),
+	.tc = mt8195_tc_ap_settings,
+	.num_sensor = MT8195_NUM_TS_AP,
+	.ops = {
+		.efuse_to_cal_data = mt8195_ap_efuse_to_cal_data,
+		.device_enable_and_init = lvts_device_enable_and_init_v4,
+		.device_enable_auto_rck = lvts_device_enable_auto_rck_v4,
+		.device_read_count_rc_n = lvts_device_read_count_rc_n_v4,
+		.set_cal_data = lvts_set_calibration_data_v4,
+		.init_controller = lvts_init_controller_v4,
+	},
+	.feature_bitmap = FEATURE_DEVICE_AUTO_RCK,
+	.num_efuse_addr = NUM_EFUSE_ADDR,
+	.num_efuse_block = NUM_EFUSE_BLOCK_MT8195,
+	.cal_data = {
+		.default_golden_temp = DEFAULT_GOLDEN_TEMP,
+		.default_count_r = DEFAULT_CUONT_R,
+		.default_count_rc = DEFAULT_CUONT_RC,
+	},
+	.coeff = {
+		.a = COEFF_A,
+		.b = COEFF_B,
+	},
+};
+
+static const struct of_device_id lvts_of_match[] = {
+	{ .compatible = "mediatek,mt8195-lvts-mcu", .data = &mt8195_lvts_mcu_data, },
+	{ .compatible = "mediatek,mt8195-lvts-ap", .data = &mt8195_lvts_ap_data, },
+	{},
+};
+MODULE_DEVICE_TABLE(of, lvts_of_match);
+
+static struct platform_driver soc_temp_lvts = {
+	.probe = lvts_probe,
+	.remove = lvts_remove,
+	.suspend = lvts_suspend,
+	.resume = lvts_resume,
+	.driver = {
+		.name = "mtk-soc-temp-lvts-mt8195",
+		.of_match_table = lvts_of_match,
+	},
+};
+module_platform_driver(soc_temp_lvts);
+
+MODULE_AUTHOR("Yu-Chia Chang <ethan.chang@mediatek.com>");
+MODULE_AUTHOR("Michael Kao <michael.kao@mediatek.com>");
+MODULE_DESCRIPTION("MediaTek soc temperature driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/thermal/mediatek/soc_temp.c b/drivers/thermal/mediatek/soc_temp.c
index b7215833b128ad9d579fbc8ef66ab30a2cd96d51..ae661a09ec2bb40c899ba407b27917c642951142 100644
--- a/drivers/thermal/mediatek/soc_temp.c
+++ b/drivers/thermal/mediatek/soc_temp.c
@@ -8,9 +8,6 @@
  */
 
 #include <linux/clk.h>
-#include <linux/completion.h>
-#include <linux/cpu.h>
-#include <linux/cpufreq.h>
 #include <linux/delay.h>
 #include <linux/interrupt.h>
 #include <linux/kernel.h>
@@ -20,16 +17,12 @@
 #include <linux/of_address.h>
 #include <linux/of_device.h>
 #include <linux/platform_device.h>
-#include <linux/pm_opp.h>
-#include <linux/pm_qos.h>
-#include <linux/regulator/consumer.h>
 #include <linux/slab.h>
 #include <linux/io.h>
 #include <linux/thermal.h>
 #include <linux/reset.h>
 #include <linux/types.h>
 #include <linux/iopoll.h>
-#include <linux/workqueue.h>
 
 #include "../thermal_hwmon.h"
 
@@ -85,32 +78,7 @@
 #define TEMP_ADCPNP3_1          0x1b4
 #define TEMP_MSR3_1             0x1B8
 
-#define SVS_BANK_CONFIG0	0x200
-#define SVS_BANK_CONFIG1	0x204
-#define SVS_BANK_CONFIG2	0x208
-#define SVS_BANK_CONFIG3	0x20c
-#define SVS_BANK_CONFIG4	0x210
-#define SVS_BANK_CONFIG5	0x214
-#define SVS_BANK_FREQPCT30	0x218
-#define SVS_BANK_FREQPCT74	0x21c
-#define SVS_BANK_LIMITVALS	0x220
-#define SVS_BANK_CONFIG6	0x224
-#define SVS_BANK_CONFIG7	0x228
-#define SVS_BANK_CONFIG8	0x22c
-#define SVS_BANK_CONFIG9	0x230
-#define SVS_BANK_CONFIG10	0x234
-#define SVS_BANK_EN		0x238
-#define SVS_BANK_CONTROL0	0x23c
-#define SVS_BANK_CONTROL1	0x240
-#define SVS_BANK_CONTROL2	0x244
-#define SVS_BANK_VOP30		0x248
-#define SVS_BANK_VOP74		0x24c
-#define SVS_BANK_INTST		0x254
-#define SVS_BANK_CONTROL3	0x25c
-#define SVS_BANK_CONTROL4	0x264
-
 #define PTPCORESEL		0x400
-#define SVS_SVSINTST		0x408
 
 #define TEMP_MONCTL1_PERIOD_UNIT(x)	((x) & 0x3ff)
 
@@ -153,30 +121,6 @@
 /* The calibration coefficient of sensor  */
 #define MT8173_CALIBRATION	165
 
-/* The number of OPPs supported by SVS */
-#define MT8173_NUM_SVS_OPP		8
-
-/* Bit masks of SVS enable and IRQ configrations */
-#define PHASE_0_EN		BIT(0)
-#define PHASE_CON_EN		BIT(1)
-#define PHASE_1_EN		BIT(2)
-#define PHASE_EN_MASK		(PHASE_0_EN | PHASE_CON_EN | PHASE_1_EN)
-#define PHASE_01_EN		(PHASE_0_EN | PHASE_1_EN)
-#define PHASE_01_IRQ		BIT(0)
-#define PHASE_CON_IRQ		(0xff << 16)
-
-/* Bit mask of SVS bank flags*/
-#define SVS_NEED_OVERFLOW_FIX	BIT(0)
-
-/* SVS bank status */
-#define SVS_STATUS_ERROR	BIT(0)
-
-/* The number of SVS banks implemented */
-#define MT8173_NUM_SVS_BANKS	2
-
-#define MT8173_SVS_BANK_CA53	0
-#define MT8173_SVS_BANK_CA72	1
-
 /*
  * Layout of the fuses providing the calibration data
  * These macros could be used for MT8183, MT8173, MT2701, and MT2712.
@@ -212,48 +156,6 @@
 #define CALIB_BUF1_VALID_V2(x)		(((x) >> 4) & 0x1)
 #define CALIB_BUF1_O_SLOPE_SIGN_V2(x)	(((x) >> 3) & 0x1)
 
-/* SVS configuration register constants */
-#define SVS_LIMITVALS_CONST	0x1fe
-#define SVS_CONFIG1_CONST	0x100006
-#define SVS_CONFIG4_CONST	0x555555
-#define SVS_CONFIG5_CONST	0x555555
-#define SVS_CONFIG7_CONST	0xa28
-#define SVS_CONFIG8_CONST	0xffff
-#define SVS_CONFIG10_CONST	0x80000000
-#define SVS_CONTROL3_P01	0x5f01
-#define SVS_CONTROL3_CON	0xff0000
-
-#define SVS_CONFIG9_VAL(b, m)	((((b) & 0xfff) << 12) | ((m) & 0xfff))
-#define SVS_CONTROL4_OVFIX(v)	(((v) & ~0xf) | 0x7)
-
-#define SVS_LOW_TEMP		33000
-#define SVS_LOW_TEMP_OFFSET	10
-
-/* Constants for calibration data calculation */
-#define GE_ZERO_BASE	512		/* 0 of 10-bit sign integer */
-#define SLOPE_OFFSET	165		/* 0.00165 * 100000  */
-#define TS_GAIN		18		/* 1.8 * 10 */
-#define ADC_FS		15		/* 1.5 * 10 */
-#define TEMP_OFFSET	(25 * 10)
-#define VTS_OFFSET	3350
-#define ADC_RESOLUTION	(1 << 12)	/* 12-bit ADC full code */
-#define BTS_PRESCALE	4
-
-/* Helpers to calculate configuration values from SVS calibration data */
-#define SVS_CALIB_VALID	BIT(0)
-#define BANK_SHIFT(bank) (((bank) == 0) ? 8 : 0)
-#define SVS_CALIB_BANK_CONFIG0(buf, b)				\
-	(((((buf[33] >> BANK_SHIFT(b)) & 0xff)) << 8) |		\
-	((buf[32] >> BANK_SHIFT(b)) & 0xff))
-#define SVS_CALIB_BANK_CONFIG1(buf, b)				\
-	((((buf[34] >> BANK_SHIFT(b)) & 0xff) << 8) | SVS_CONFIG1_CONST)
-#define SVS_CALIB_BANK_CONFIG2L(base, b)			\
-	((buf[0] >> BANK_SHIFT(b)) & 0xff)
-#define SVS_CALIB_BANK_CONFIG2H(base, b)			\
-	((buf[1] >> BANK_SHIFT(b)) & 0xff)
-#define SVS_CALIB_BANK_CONFIG3(base, b)				\
-	(((buf[2] >> BANK_SHIFT(b)) & 0xff) << 8)
-
 enum {
 	VTS1,
 	VTS2,
@@ -380,54 +282,6 @@ struct mtk_thermal_data {
 	bool need_switch_bank;
 	struct thermal_bank_cfg bank_data[MAX_NUM_ZONES];
 	enum mtk_thermal_version version;
-	bool use_svs;
-};
-
-enum mtk_svs_state {
-	SVS_INIT,
-	SVS_PHASE_0,
-	SVS_PHASE_1,
-	SVS_PHASE_CONTINUOUS,
-};
-
-struct mtk_svs_bank {
-	int bank_id;
-	int cpu_dev_id;
-
-	u32 flags;
-
-	u32 status;
-
-	enum mtk_svs_state state;
-	/* Use this to limit bank frequency */
-	unsigned long max_freq_khz;
-	unsigned long min_freq_khz;
-
-	struct mtk_thermal *mt;
-	struct completion init_done;
-	struct work_struct work;
-
-	struct device *dev;
-	struct regulator *reg;
-
-	/* SVS per-bank calibration values */
-	u32 ctrl0;
-	u32 config0;
-	u32 config1;
-	u32 config2;
-	u32 config3;
-
-	unsigned long freq_table[MT8173_NUM_SVS_OPP];	/* in KHz*/
-	int volt_table[MT8173_NUM_SVS_OPP];		/* in uVolt */
-	int updated_volt_table[MT8173_NUM_SVS_OPP];	/* in uVolt */
-};
-
-struct mtk_svs_bank_cfg {
-	int ts;
-	int vmin_uV;
-	int vmax_uV;
-	int vboot_uV;
-	unsigned long base_freq_hz;
 };
 
 struct mtk_thermal {
@@ -440,13 +294,9 @@ struct mtk_thermal {
 
 	struct clk *clk_peri_therm;
 	struct clk *clk_auxadc;
-	struct clk *svs_mux;
-	struct clk *svs_pll;
 	/* lock: for getting and putting banks */
 	struct mutex lock;
 
-	int svs_irq;
-
 	/* Calibration values */
 	s32 adc_ge;
 	s32 adc_oe;
@@ -455,13 +305,6 @@ struct mtk_thermal {
 	s32 o_slope_sign;
 	s32 vts[MAX_NUM_VTS];
 
-	/*
-	 * MTS and BTS are factors used by SVS to get per-bank temperature:
-	 * Bank Temperature = [ADC Value] * MTS + BTS[Bank]
-	 */
-	s32 bts[MT8173_NUM_ZONES];
-	s32 mts;
-
 	const struct mtk_thermal_data *conf;
 	struct mtk_thermal_bank banks[MAX_NUM_ZONES];
 };
@@ -510,25 +353,6 @@ static const int mt8173_vts_index[MT8173_NUM_SENSORS] = {
 	VTS1, VTS2, VTS3, VTS4, VTSABB
 };
 
-static const struct mtk_svs_bank_cfg svs_bank_cfgs[MT8173_NUM_SVS_BANKS] = {
-	[MT8173_SVS_BANK_CA53] = {
-		.vmax_uV = 1125000,
-		.vmin_uV = 800000,
-		.vboot_uV = 1000000,
-		.base_freq_hz = 1600000000,
-		.ts = MT8173_TS3
-	},
-	[MT8173_SVS_BANK_CA72] = {
-		.vmax_uV = 1125000,
-		.vmin_uV = 800000,
-		.vboot_uV = 1000000,
-		.base_freq_hz = 2000000000,
-		.ts = MT8173_TS4
-	}
-};
-
-static struct mtk_svs_bank svs_banks[MT8173_NUM_SVS_BANKS] = {{0}};
-
 /* MT2701 thermal sensor data */
 static const int mt2701_bank_data[MT2701_NUM_SENSORS] = {
 	MT2701_TS1, MT2701_TS2, MT2701_TSABB
@@ -618,7 +442,6 @@ static const struct mtk_thermal_data mt8173_thermal_data = {
 	.adcpnp = mt8173_adcpnp,
 	.sensor_mux_values = mt8173_mux_values,
 	.version = MTK_THERMAL_V1,
-	.use_svs = true,
 };
 
 /*
@@ -795,34 +618,6 @@ static int raw_to_mcelsius_v2(struct mtk_thermal *mt, int sensno, s32 raw)
 	return (format_2 - tmp) * 100;
 }
 
-/**
- * uvolt_to_config - convert a voltage value to SVS voltage config value
- * @uvolt:	voltage value
- */
-static inline u8 uvolt_to_config(int uvolt)
-{
-	return ((uvolt / 1000 - 700) * 100 + 625 - 1) / 625;
-}
-
-/**
- * config_to_uvolt - convert a SVS voltage config value to voltage value
- * @val:	SVS voltage config value
- */
-static inline int config_to_uvolt(u32 val)
-{
-	return ((val * 625 / 100) + 700) * 1000;
-}
-
-/**
- * hz_to_config - convert a frequency value to SVS frequency config value
- * @rate:	frequency value
- * @base_rate:	rate to be used to calculate frequency percentage
- */
-static inline u8 hz_to_config(unsigned long rate, unsigned long base_rate)
-{
-	return (rate * 100 + base_rate - 1) / base_rate;
-}
-
 /**
  * mtk_thermal_get_bank - get bank
  * @bank:	The bank
@@ -1227,654 +1022,6 @@ static int mtk_thermal_get_calibration_data(struct device *dev,
 	return ret;
 }
 
-/* This should only be run after mtk_thermal_get_calibration_data */
-static void mtk_thermal_get_calibration_data_for_svs(struct device *dev,
-						     struct mtk_thermal *mt)
-{
-	int i;
-	s32 ge, oe, gain, x_roomt, ts_intercept, ts_degc, ts_factor;
-
-	/*
-	 * The constants 10, 10000, 100000 below are pre-scalers to avoid
-	 * calculation underflow, and will be divided in the final results.
-	 */
-	oe = mt->adc_ge - GE_ZERO_BASE;
-	ge = oe * 10000 / ADC_RESOLUTION;
-	gain = 10000 + ge;
-
-	/* calculating MTS */
-	mt->mts = 100000 * 10000 / gain * ADC_FS / TS_GAIN / mt->o_slope;
-
-	ts_degc = mt->degc_cali * 10 / 2;
-	ts_factor = 100000 * 10000 / ADC_RESOLUTION / gain * ge;
-
-	/* calculating per-bank BTS */
-	for (i = 0; i < MT8173_NUM_SVS_BANKS; i++) {
-		int ts = svs_bank_cfgs[i].ts;
-
-		x_roomt = mt->vts[ts] + VTS_OFFSET - oe * 10000 /
-			ADC_RESOLUTION * 10000 / gain;
-		ts_intercept = (ts_factor + x_roomt * 10 * ADC_FS / TS_GAIN) *
-			10 / mt->o_slope;
-		ts_intercept += ts_degc - TEMP_OFFSET;
-
-		mt->bts[i] = ts_intercept * BTS_PRESCALE / 10;
-	}
-}
-
-static int mtk_svs_get_calibration_data(struct device *dev,
-					struct mtk_thermal *mt)
-{
-	struct nvmem_cell *cell;
-	u32 *buf;
-	size_t len;
-	int i, ret = 0;
-
-	mtk_thermal_get_calibration_data_for_svs(dev, mt);
-
-	cell = nvmem_cell_get(dev, "svs-calibration-data");
-	if (IS_ERR(cell))
-		return PTR_ERR(cell);
-
-	buf = nvmem_cell_read(cell, &len);
-	nvmem_cell_put(cell);
-
-	if (IS_ERR(buf)) {
-		dev_err(dev, "failed to get svs calibration data: %ld\n",
-			PTR_ERR(buf));
-		return PTR_ERR(buf);
-	}
-
-	if (len < 0x8c || !(buf[29] & SVS_CALIB_VALID)) {
-		dev_err(dev, "Invalid SVS calibration data\n");
-		ret = -EINVAL;
-		goto out;
-	}
-
-	for (i = 0; i < MT8173_NUM_SVS_BANKS; i++) {
-		u32 temp;
-
-		svs_banks[i].config0 =
-				SVS_CALIB_BANK_CONFIG0(buf, i);
-		svs_banks[i].config1 =
-				SVS_CALIB_BANK_CONFIG1(buf, i);
-		svs_banks[i].config3 =
-				SVS_CALIB_BANK_CONFIG3(buf, i);
-
-		temp = SVS_CALIB_BANK_CONFIG2H(buf, i);
-		if (temp < 128 && i == MT8173_SVS_BANK_CA72) {
-			temp = (unsigned char)((temp - 256) / 2);
-			svs_banks[i].flags |= SVS_NEED_OVERFLOW_FIX;
-		}
-		temp = ((temp & 0xff) << 8) |
-		       SVS_CALIB_BANK_CONFIG2L(buf, i);
-		svs_banks[i].config2 = temp;
-	}
-
-out:
-	kfree(buf);
-
-	return ret;
-}
-
-/* Caller must call this function with mt->lock held */
-static void mtk_svs_set_phase(struct mtk_svs_bank *svs, int phase)
-{
-	struct mtk_thermal *mt = svs->mt;
-	unsigned long *freq_tbl, base_freq_hz;
-	int id = svs->bank_id;
-
-	freq_tbl = svs->freq_table;
-	base_freq_hz = svs_bank_cfgs[id].base_freq_hz;
-
-	writel(svs->config0, mt->thermal_base + SVS_BANK_CONFIG0);
-	writel(svs->config1, mt->thermal_base + SVS_BANK_CONFIG1);
-	writel(svs->config2, mt->thermal_base + SVS_BANK_CONFIG2);
-	writel(svs->config3, mt->thermal_base + SVS_BANK_CONFIG3);
-	writel(SVS_CONFIG4_CONST, mt->thermal_base + SVS_BANK_CONFIG4);
-	writel(SVS_CONFIG5_CONST, mt->thermal_base + SVS_BANK_CONFIG5);
-	writel(SVS_CONFIG10_CONST, mt->thermal_base + SVS_BANK_CONFIG10);
-
-	/*
-	 * SVS_BANK_FREQPCT30 and SVS_BANK_FREQPCT74 inform SVS the frequencies
-	 * of OPP table. The frequency values are set in the form:
-	 * frequency = (config / 100) * [base frequency of this bank]
-	 */
-	writel(hz_to_config(freq_tbl[0], base_freq_hz) |
-	       (hz_to_config(freq_tbl[1], base_freq_hz) << 8) |
-	       (hz_to_config(freq_tbl[2], base_freq_hz) << 16) |
-	       (hz_to_config(freq_tbl[3], base_freq_hz) << 24),
-	       mt->thermal_base + SVS_BANK_FREQPCT30);
-
-	writel(hz_to_config(freq_tbl[4], base_freq_hz) |
-	       (hz_to_config(freq_tbl[5], base_freq_hz) << 8) |
-	       (hz_to_config(freq_tbl[6], base_freq_hz) << 16) |
-	       (hz_to_config(freq_tbl[7], base_freq_hz) << 24),
-	       mt->thermal_base + SVS_BANK_FREQPCT74);
-
-	writel((uvolt_to_config(svs_bank_cfgs[id].vmax_uV) << 24) |
-	       (uvolt_to_config(svs_bank_cfgs[id].vmin_uV) << 16) |
-	       SVS_LIMITVALS_CONST, mt->thermal_base + SVS_BANK_LIMITVALS);
-
-	writel(uvolt_to_config(svs_bank_cfgs[id].vboot_uV),
-	       mt->thermal_base + SVS_BANK_CONFIG6);
-	writel(SVS_CONFIG7_CONST, mt->thermal_base + SVS_BANK_CONFIG7);
-	writel(SVS_CONFIG8_CONST, mt->thermal_base + SVS_BANK_CONFIG8);
-
-	/* clear all pending interrupt */
-	writel(0xffffffff, mt->thermal_base + SVS_BANK_INTST);
-
-	/* Workaround for calibration data overflow on CA72 bank */
-	if (svs->flags & SVS_NEED_OVERFLOW_FIX) {
-		u32 reg;
-
-		reg = readl(mt->thermal_base + SVS_BANK_CONTROL4);
-		writel(SVS_CONTROL4_OVFIX(reg),
-		       mt->thermal_base + MT8173_SVS_BANK_CA72);
-	}
-
-	switch (phase) {
-	case SVS_PHASE_0:
-		writel(SVS_CONTROL3_P01, mt->thermal_base + SVS_BANK_CONTROL3);
-		writel(PHASE_0_EN, mt->thermal_base + SVS_BANK_EN);
-		svs->state = SVS_PHASE_0;
-		break;
-	case SVS_PHASE_1:
-		writel(SVS_CONTROL3_P01, mt->thermal_base + SVS_BANK_CONTROL3);
-		writel(svs->ctrl0, mt->thermal_base + SVS_BANK_CONTROL0);
-		writel(PHASE_0_EN | PHASE_1_EN,
-		       mt->thermal_base + SVS_BANK_EN);
-		svs->state = SVS_PHASE_1;
-		break;
-	case SVS_PHASE_CONTINUOUS:
-		writel(SVS_CONFIG9_VAL(mt->bts[id], mt->mts),
-		       mt->thermal_base + SVS_BANK_CONFIG9);
-		writel(SVS_CONTROL3_CON, mt->thermal_base + SVS_BANK_CONTROL3);
-		writel(PHASE_CON_EN, mt->thermal_base + SVS_BANK_EN);
-		svs->state = SVS_PHASE_CONTINUOUS;
-	}
-}
-
-static void mtk_svs_adjust_voltage(struct mtk_svs_bank *svs)
-{
-	int i;
-
-	for (i = 0; i < MT8173_NUM_SVS_OPP; i++) {
-		if (!svs->freq_table[i])
-			continue;
-
-		dev_pm_opp_adjust_voltage(svs->dev, svs->freq_table[i],
-					  svs->updated_volt_table[i],
-					  svs_bank_cfgs[svs->bank_id].vmin_uV,
-					  svs_bank_cfgs[svs->bank_id].vmax_uV);
-	}
-}
-
-/**
- * mtk_svs_update_voltage_table - update the calculated voltage table
- * @svs: The SVS bank
- *
- * Read the calculated voltage values from registers and update the SVS bank
- * voltage table which will be write to OPP table entries later. Caller should
- * select the bank and hold mt->lock before calling it.
- */
-static void mtk_svs_update_voltage_table(struct mtk_svs_bank *svs)
-{
-	struct mtk_thermal *mt = svs->mt;
-	int vmin_uV, vmax_uV, *volt_table;
-	u32 reg;
-	int temp, offset = 0;
-
-	temp = mtk_thermal_bank_temperature(&mt->banks[svs->bank_id]);
-	if (temp <= SVS_LOW_TEMP)
-		offset = SVS_LOW_TEMP_OFFSET;
-
-	vmin_uV = svs_bank_cfgs[svs->bank_id].vmin_uV;
-	vmax_uV = svs_bank_cfgs[svs->bank_id].vmax_uV;
-	volt_table = svs->updated_volt_table;
-
-	/*
-	 * The optimized voltage values calculated by SVS are put in the two
-	 * registers, SVS_BANK_VOP30 and SVS_BANK_VOP74 which stores values
-	 * corresponding to OPP[4-7] and OPP[4-7].
-	 */
-	reg = readl(mt->thermal_base + SVS_BANK_VOP30);
-	volt_table[0] = clamp(config_to_uvolt((reg & 0xff) + offset),
-			      vmin_uV, vmax_uV);
-	volt_table[1] = clamp(config_to_uvolt(((reg >> 8) & 0xff) + offset),
-			      vmin_uV, vmax_uV);
-	volt_table[2] = clamp(config_to_uvolt(((reg >> 16) & 0xff) + offset),
-			      vmin_uV, vmax_uV);
-	volt_table[3] = clamp(config_to_uvolt(((reg >> 24) & 0xff) + offset),
-			      vmin_uV, vmax_uV);
-
-	reg = readl(mt->thermal_base + SVS_BANK_VOP74);
-	volt_table[4] = clamp(config_to_uvolt((reg & 0xff) + offset),
-			      vmin_uV, vmax_uV);
-	volt_table[5] = clamp(config_to_uvolt(((reg >> 8) & 0xff) + offset),
-			      vmin_uV, vmax_uV);
-	volt_table[6] = clamp(config_to_uvolt(((reg >> 16) & 0xff) + offset),
-			      vmin_uV, vmax_uV);
-	volt_table[7] = clamp(config_to_uvolt(((reg >> 24) & 0xff) + offset),
-			      vmin_uV, vmax_uV);
-}
-
-static void adjust_voltage_work(struct work_struct *work)
-{
-	struct mtk_svs_bank *svs = container_of(work, struct mtk_svs_bank,
-						work);
-	struct mtk_thermal *mt = svs->mt;
-
-	if (svs->status & SVS_STATUS_ERROR || svs->state == SVS_INIT)
-		goto out_only_adjust_voltage;
-
-	mtk_thermal_get_bank(&mt->banks[svs->bank_id]);
-
-	mtk_svs_update_voltage_table(svs);
-
-	if (!completion_done(&svs->init_done)) {
-		complete(&svs->init_done);
-		mtk_svs_set_phase(svs, SVS_PHASE_CONTINUOUS);
-	}
-
-	mtk_thermal_put_bank(&mt->banks[svs->bank_id]);
-
-out_only_adjust_voltage:
-	mtk_svs_adjust_voltage(svs);
-	if (svs->state == SVS_INIT)
-		complete(&svs->init_done);
-}
-
-static void mtk_svs_bank_disable(struct mtk_svs_bank *svs)
-{
-	struct mtk_thermal *mt = svs->mt;
-	int i;
-
-	writel(0, mt->thermal_base + SVS_BANK_EN);
-	writel(0xffffff, mt->thermal_base + SVS_BANK_INTST);
-
-	for (i = 0; i < MT8173_NUM_SVS_OPP; i++) {
-		if (!svs->freq_table[i])
-			continue;
-
-		svs->updated_volt_table[i] = svs->volt_table[i];
-	}
-}
-
-static irqreturn_t mtk_svs_interrupt(int irqno, void *dev_id)
-{
-	struct mtk_thermal *mt = dev_id;
-	u32 svs_intst, bank_en, bank_intst;
-	int i;
-
-
-	svs_intst = readl(mt->thermal_base + SVS_SVSINTST);
-	for (i = 0; i < MT8173_NUM_SVS_BANKS; i++) {
-		struct mtk_svs_bank *svs = &svs_banks[i];
-
-		if (svs_intst & BIT(i))
-			continue;
-
-		mtk_thermal_get_bank(&mt->banks[i]);
-
-		bank_intst = readl(mt->thermal_base + SVS_BANK_INTST);
-		bank_en = readl(mt->thermal_base + SVS_BANK_EN);
-
-		if (bank_intst == PHASE_01_IRQ && /* phase 0 */
-		    (bank_en & PHASE_EN_MASK) == PHASE_0_EN) {
-			u32 reg;
-
-			reg = readl(mt->thermal_base + SVS_BANK_CONTROL1);
-			svs->ctrl0 |= (~(reg & 0xffff) + 1) & 0xffff;
-			reg =  readl(mt->thermal_base + SVS_BANK_CONTROL2);
-			svs->ctrl0 |= (reg & 0xffff) << 16;
-
-			writel(0, mt->thermal_base + SVS_BANK_EN);
-			writel(PHASE_01_IRQ, mt->thermal_base + SVS_BANK_INTST);
-
-			mtk_svs_set_phase(svs, SVS_PHASE_1);
-		} else if (bank_intst == PHASE_01_IRQ && /* phase 1 */
-			   (bank_en & PHASE_EN_MASK) == PHASE_01_EN) {
-			/*
-			 * Schedule a work to update voltages of OPP table
-			 * entries.
-			 */
-			schedule_work(&svs->work);
-
-			writel(0, mt->thermal_base + SVS_BANK_EN);
-			writel(PHASE_01_IRQ, mt->thermal_base + SVS_BANK_INTST);
-		} else if (bank_intst & PHASE_CON_IRQ) { /* phase continuous*/
-			/*
-			 * Schedule a work to update voltages of OPP table
-			 * entries.
-			 */
-			schedule_work(&svs->work);
-
-			writel(PHASE_CON_IRQ,
-			       mt->thermal_base + SVS_BANK_INTST);
-		} else {
-			svs->status |= SVS_STATUS_ERROR;
-
-			mtk_svs_bank_disable(svs);
-			dev_err(svs->dev,
-				"SVS engine internal error. disabled.\n");
-
-			/*
-			 * Schedule a work to reset voltages of OPP table
-			 * entries.
-			 */
-			schedule_work(&svs->work);
-		}
-
-		mtk_thermal_put_bank(&mt->banks[i]);
-	}
-
-	return IRQ_HANDLED;
-}
-
-static int mtk_svs_bank_init(struct mtk_svs_bank *svs)
-{
-	struct dev_pm_opp *opp;
-	int ret = 0, count, i;
-	unsigned long rate;
-
-	init_completion(&svs->init_done);
-
-	INIT_WORK(&svs->work, adjust_voltage_work);
-
-	svs->dev = get_cpu_device(svs->cpu_dev_id);
-	if (!svs->dev) {
-		pr_err("failed to get cpu%d device\n", svs->cpu_dev_id);
-		return -ENODEV;
-	}
-
-	/* Assume CPU DVFS OPP table is already initialized by cpufreq driver*/
-	rcu_read_lock();
-	count = dev_pm_opp_get_opp_count(svs->dev);
-	if (count > MT8173_NUM_SVS_OPP)
-		dev_warn(svs->dev, "%d OPP entries found.\n"
-			 "But only %d OPP entry supported.\n", count,
-			 MT8173_NUM_SVS_OPP);
-
-	for (i = 0, rate = (unsigned long)-1; i < MT8173_NUM_SVS_OPP &&
-	     i < count; i++, rate--) {
-		opp = dev_pm_opp_find_freq_floor(svs->dev, &rate);
-		if (IS_ERR(opp)) {
-			dev_err(svs->dev, "error opp entry!!\n");
-			rcu_read_unlock();
-			ret = PTR_ERR(opp);
-			goto out;
-		}
-
-		svs->freq_table[i] = rate;
-		svs->volt_table[i] = dev_pm_opp_get_voltage(opp);
-	}
-
-out:
-	rcu_read_unlock();
-
-	return ret;
-}
-
-static int mtk_svs_hw_init(struct mtk_thermal *mt)
-{
-	struct clk *parent;
-	unsigned long timeout;
-	struct mtk_svs_bank *svs;
-	struct cpufreq_policy policy;
-	struct pm_qos_request qos_request = {{0}};
-	int i, j, ret, vboot_uV;
-
-	parent = clk_get_parent(mt->svs_mux);
-	ret = clk_set_parent(mt->svs_mux, mt->svs_pll);
-	if (ret) {
-		dev_err(mt->dev,
-			"failed to set svs_mux to svs_pll\n");
-		return ret;
-	}
-
-	/*
-	 * When doing SVS init, we have to make sure all CPUs are on and
-	 * working at 1.0 volt. Add a pm_qos request to prevent CPUs from
-	 * entering CPU off idle state.
-	 */
-	cpu_latency_qos_add_request(&qos_request, 1);
-
-	for (i = 0; i < MT8173_NUM_SVS_BANKS; i++) {
-		svs = &svs_banks[i];
-
-		/* Backup current cpufreq policy */
-		ret = cpufreq_get_policy(&policy, svs->cpu_dev_id);
-		if (ret) {
-			dev_err(svs->dev, "cpufreq is not ready.\n");
-			cpu_latency_qos_remove_request(&qos_request);
-			clk_set_parent(mt->svs_mux, parent);
-			return ret;
-		}
-
-		/* Force CPUFreq switch to OPP with 1.0 volt */
-		for (j = 0; j < MT8173_NUM_SVS_OPP; j++) {
-			svs->updated_volt_table[j] = svs->volt_table[j];
-			if (svs->volt_table[j] <= svs_bank_cfgs[i].vboot_uV &&
-			    (!svs->max_freq_khz || !svs->min_freq_khz)) {
-				svs->updated_volt_table[j] =
-						svs_bank_cfgs[i].vboot_uV;
-				svs->max_freq_khz = svs->freq_table[j] / 1000;
-				svs->min_freq_khz = svs->freq_table[j] / 1000;
-			}
-		}
-
-		schedule_work(&svs->work);
-		timeout = wait_for_completion_timeout(&svs->init_done, HZ);
-		if (timeout == 0) {
-			dev_err(svs->dev, "SVS vboot init timeout.\n");
-			ret = -EINVAL;
-			goto err_bank_init;
-		}
-
-		reinit_completion(&svs->init_done);
-
-		cpufreq_update_policy(svs->cpu_dev_id);
-
-		/* Check if the voltage is successfully set as 1.0 volt */
-		vboot_uV = regulator_get_voltage(svs->reg);
-		if (uvolt_to_config(vboot_uV) !=
-		    uvolt_to_config(svs_bank_cfgs[i].vboot_uV)) {
-			dev_err(svs->dev, "Vboot value mismatch!\n");
-			ret = -EINVAL;
-			break;
-		}
-
-		/* Configure regulator to PWM mode */
-		ret = regulator_set_mode(svs->reg, REGULATOR_MODE_FAST);
-		if (ret) {
-			dev_err(svs->dev,
-				"Failed to set regulator in PWM mode\n");
-			ret = -EINVAL;
-			break;
-		}
-
-		mtk_thermal_get_bank(&mt->banks[i]);
-
-		mtk_svs_set_phase(svs, SVS_PHASE_0);
-
-		mtk_thermal_put_bank(&mt->banks[i]);
-
-		timeout = wait_for_completion_timeout(&svs->init_done, HZ);
-		if (timeout == 0) {
-			dev_err(svs->dev, "SVS initialization timeout.\n");
-			ret = -EINVAL;
-			goto err_bank_init;
-		}
-
-		/* Unlimit CPUFreq OPP range */
-		svs->max_freq_khz = policy.max;
-		svs->min_freq_khz = policy.min;
-		cpufreq_update_policy(svs->cpu_dev_id);
-
-		/* Configure regulator to normal mode */
-		ret = regulator_set_mode(svs->reg, REGULATOR_MODE_NORMAL);
-		if (ret)
-			dev_err(svs->dev,
-				"Failed to set regulator in normal mode\n");
-	}
-
-err_bank_init:
-
-	if (ret)
-		for (i = 0; i < MT8173_NUM_SVS_BANKS; i++) {
-			svs = &svs_banks[i];
-
-			mtk_thermal_get_bank(&mt->banks[i]);
-
-			mtk_svs_bank_disable(svs);
-			svs->status |= SVS_STATUS_ERROR;
-
-			mtk_thermal_put_bank(&mt->banks[i]);
-
-			schedule_work(&svs->work);
-		}
-
-	cpu_latency_qos_remove_request(&qos_request);
-
-	ret = clk_set_parent(mt->svs_mux, parent);
-	if (ret) {
-		dev_err(mt->dev,
-			"failed to set svs_mux to original parent\n");
-		return ret;
-	}
-
-	return ret;
-}
-
-static bool allow_svs_late_init;
-
-/*
- * When doing SVS init, we have to make sure all CPUs are on and working at
- * 1.0 volt. Currently we relies on cpufreq driver doing this by changing
- * OPP voltage and limit OPP during SVS init. To make sure cpufreq is already
- * working, put SVS hardware part init in late_initcall().
- */
-static int mtk_svs_late_init(void)
-{
-	int ret, i;
-
-	if (!allow_svs_late_init)
-		return -EINVAL;
-
-	for (i = 0; i < MT8173_NUM_SVS_BANKS; i++) {
-		svs_banks[i].bank_id = i;
-
-		ret = mtk_svs_bank_init(&svs_banks[i]);
-		if (ret) {
-			pr_err("failed to initialize mtk svs bank%d\n", i);
-			return ret;
-		}
-	}
-
-	ret = mtk_svs_hw_init(svs_banks[0].mt);
-	if (ret)
-		pr_err("Failed to initialize MTK SVS engine\n");
-
-	return ret;
-}
-late_initcall(mtk_svs_late_init);
-
-static int mtk_svs_get_cpu_id(struct platform_device *pdev)
-{
-	int ret;
-	struct device_node *np = pdev->dev.of_node;
-
-	ret = of_property_read_u32(np, "mediatek,svs-little-core-id",
-				  &svs_banks[MT8173_SVS_BANK_CA53].cpu_dev_id);
-	if (ret) {
-		dev_err(&pdev->dev,
-			"Cannot find property mediatek,svs-little-core-id\n");
-		return ret;
-	}
-
-	ret = of_property_read_u32(np, "mediatek,svs-big-core-id",
-				  &svs_banks[MT8173_SVS_BANK_CA72].cpu_dev_id);
-	if (ret) {
-		dev_err(&pdev->dev,
-			"Cannot find property mediatek,svs-big-core-id\n");
-		return ret;
-	}
-
-	return ret;
-}
-
-static int mtk_svs_probe(struct platform_device *pdev)
-{
-	struct mtk_thermal *mt = platform_get_drvdata(pdev);
-	char supply[8];
-	int i, ret;
-
-	if (!mt->conf->use_svs)
-		return 0;
-
-	ret = mtk_svs_get_cpu_id(pdev);
-	if (ret)
-		return ret;
-
-	mt->svs_pll = devm_clk_get(&pdev->dev, "svs_pll");
-	if (IS_ERR(mt->svs_pll)) {
-		if (PTR_ERR(mt->svs_pll) == -EPROBE_DEFER)
-			return PTR_ERR(mt->svs_pll);
-
-		pr_err("Failed to get SVS PLL clock\n");
-		return ret;
-	}
-
-	mt->svs_mux = devm_clk_get(&pdev->dev, "svs_mux");
-	if (IS_ERR(mt->svs_mux)) {
-		if (PTR_ERR(mt->svs_mux) == -EPROBE_DEFER)
-			return PTR_ERR(mt->svs_mux);
-
-		pr_err("Failed to get SVS MUX clock\n");
-		return ret;
-	}
-
-	for (i = 0; i < MT8173_NUM_SVS_BANKS; i++) {
-		struct regulator *reg;
-
-		snprintf(supply, sizeof(supply), "bank%d", i);
-		reg = devm_regulator_get_optional(&pdev->dev, supply);
-		if (IS_ERR(reg)) {
-			if (PTR_ERR(reg) == -EPROBE_DEFER)
-				return PTR_ERR(reg);
-
-			pr_err("Failed to get %s regulator\n", supply);
-			return ret;
-		}
-
-		svs_banks[i].reg = reg;
-		svs_banks[i].mt = mt;
-	}
-
-	ret = mtk_svs_get_calibration_data(mt->dev, mt);
-	if (ret) {
-		if (ret != -EPROBE_DEFER)
-			pr_err("Failed to get SVS calibration data\n");
-		return ret;
-	}
-
-	mt->svs_irq = platform_get_irq(pdev, 1);
-	ret = devm_request_threaded_irq(&pdev->dev, mt->svs_irq, NULL,
-					mtk_svs_interrupt,
-					IRQF_TRIGGER_LOW | IRQF_ONESHOT,
-					"mtk-svs", mt);
-	if (ret) {
-		pr_err("Failed to get SVS IRQ\n");
-		return ret;
-	}
-
-	/* SVS has successfully probed, allow SVS late init */
-	allow_svs_late_init = true;
-
-	return 0;
-}
-
 static const struct of_device_id mtk_thermal_of_match[] = {
 	{
 		.compatible = "mediatek,mt8173-thermal",
@@ -2046,10 +1193,6 @@ static int mtk_thermal_probe(struct platform_device *pdev)
 			dev_warn(&pdev->dev, "error in thermal_add_hwmon_sysfs: %d\n", ret);
 	}
 
-	ret = mtk_svs_probe(pdev);
-	if (ret == -EPROBE_DEFER)
-		goto err_disable_clk_peri_therm;
-
 	return 0;
 
 err_disable_clk_peri_therm:
diff --git a/drivers/thermal/mediatek/soc_temp_lvts.c b/drivers/thermal/mediatek/soc_temp_lvts.c
index 59556bb8d5ec2a774db1a6abe749fa9145df9b1f..9499e2a22c2a623df7c949432a7b16fe31f62141 100644
--- a/drivers/thermal/mediatek/soc_temp_lvts.c
+++ b/drivers/thermal/mediatek/soc_temp_lvts.c
@@ -1,6 +1,6 @@
-// SPDX-License-Identifier: GPL-2.0
+// SPDX-License-Identifier: GPL-2.0-only
 /*
- * Copyright (c) 2020 MediaTek Inc.
+ * Copyright (c) 2022 MediaTek Inc.
  */
 
 #include <linux/bits.h>
@@ -23,103 +23,7 @@
 #include <linux/thermal.h>
 #include "soc_temp_lvts.h"
 
-/*==================================================
- * Definition or macro function
- *==================================================
- */
-#define STOP_COUNTING_V4 (DEVICE_WRITE | RG_TSFM_CTRL_0 << 8 | 0x00)
-#define SET_RG_TSFM_LPDLY_V4 (DEVICE_WRITE | RG_TSFM_CTRL_4 << 8 | 0xA6)
-#define SET_COUNTING_WINDOW_20US1_V4 (DEVICE_WRITE | RG_TSFM_CTRL_2 << 8 | 0x00)
-#define SET_COUNTING_WINDOW_20US2_V4 (DEVICE_WRITE | RG_TSFM_CTRL_1 << 8 | 0x20)
-#define TSV2F_CHOP_CKSEL_AND_TSV2F_EN_V4 (DEVICE_WRITE | RG_TSV2F_CTRL_2 << 8 | 0x84)
-#define TSBG_DEM_CKSEL_X_TSBG_CHOP_EN_V4 (DEVICE_WRITE | RG_TSV2F_CTRL_4 << 8 | 0x7C)
-#define SET_TS_RSV_V4 (DEVICE_WRITE | RG_TSV2F_CTRL_1 << 8 | 0x8D)
-#define SET_TS_EN_V4 (DEVICE_WRITE | RG_TSV2F_CTRL_0 << 8 | 0xF4)
-#define TOGGLE_RG_TSV2F_VCO_RST1_V4 (DEVICE_WRITE | RG_TSV2F_CTRL_0 << 8 | 0xFC)
-#define TOGGLE_RG_TSV2F_VCO_RST2_V4 (DEVICE_WRITE | RG_TSV2F_CTRL_0 << 8 | 0xF4)
-
-#define SET_LVTS_AUTO_RCK_V4 (DEVICE_WRITE | RG_TSV2F_CTRL_6 << 8 | 0x01)
-#define SELECT_SENSOR_RCK_V4(id) (DEVICE_WRITE | RG_TSV2F_CTRL_5 << 8 | (id))
-#define SET_DEVICE_SINGLE_MODE_V4 (DEVICE_WRITE | RG_TSFM_CTRL_3 << 8 | 0x78)
-#define KICK_OFF_RCK_COUNTING_V4 (DEVICE_WRITE | RG_TSFM_CTRL_0 << 8 | 0x02)
-#define SET_SENSOR_NO_RCK_V4 (DEVICE_WRITE | RG_TSV2F_CTRL_5 << 8 | 0x10)
-#define SET_DEVICE_LOW_POWER_SINGLE_MODE_V4 (DEVICE_WRITE | RG_TSFM_CTRL_3 << 8	| 0xB8)
-
-#define ENABLE_FEATURE(feature)		(lvts_data->feature_bitmap |= (feature))
-#define DISABLE_FEATURE(feature)	(lvts_data->feature_bitmap &= (~(feature)))
-#define IS_ENABLE(feature)		(lvts_data->feature_bitmap & (feature))
-
-#define DISABLE_THERMAL_HW_REBOOT (-274000)
-
-#define CLOCK_26MHZ_CYCLE_NS	(38)
-#define BUS_ACCESS_US		(2)
-#define GOLDEN_TEMP_MAX		(62)
-
-#define FEATURE_DEVICE_AUTO_RCK	(BIT(0))
-#define FEATURE_CK26M_ACTIVE	(BIT(1))
-#define CK26M_ACTIVE   (((lvts_data->feature_bitmap & FEATURE_CK26M_ACTIVE)    \
-			? 1 : 0) << 30)
-#define GET_BASE_ADDR(tc_id)	\
-	(lvts_data->domain[lvts_data->tc[tc_id].domain_index].base	\
-	+ lvts_data->tc[tc_id].addr_offset)
-
-#define SET_TC_SPEED_IN_US(pu, gd, fd, sd) \
-	{	\
-		.period_unit = (((pu) * 1000) / (256 * CLOCK_26MHZ_CYCLE_NS)),	\
-		.group_interval_delay = ((gd) / (pu)),	\
-		.filter_interval_delay = ((fd) / (pu)),	\
-		.sensor_interval_delay = ((sd) / (pu)),	\
-	}
-
-#define GET_CAL_DATA_BITMASK(index, h, l)	\
-	(((index) < lvts_data->num_efuse_addr)	\
-	? ((lvts_data->efuse[(index)] & GENMASK(h, l)) >> l)	\
-	: 0)
-
-#define GET_CAL_DATA_BIT(index, bit)	\
-	(((index) < lvts_data->num_efuse_addr)	\
-	? ((lvts_data->efuse[index] & BIT(bit)) >> (bit))	\
-	: 0)
-
-#define GET_TC_SENSOR_NUM(tc_id)	\
-	(lvts_data->tc[tc_id].num_sensor)
-
-#define ONE_SAMPLE (lvts_data->counting_window_us + 2 * BUS_ACCESS_US)
-
-#define NUM_OF_SAMPLE(tc_id)	\
-	((lvts_data->tc[tc_id].hw_filter < LVTS_FILTER_2) ? 1 :	\
-	((lvts_data->tc[tc_id].hw_filter > LVTS_FILTER_16_OF_18) ? 1 :	\
-	((lvts_data->tc[tc_id].hw_filter == LVTS_FILTER_16_OF_18) ? 18 :\
-	((lvts_data->tc[tc_id].hw_filter == LVTS_FILTER_8_OF_10) ? 10 :	\
-	(lvts_data->tc[tc_id].hw_filter * 2)))))
-
-#define PERIOD_UNIT_US(tc_id)	\
-	((lvts_data->tc[tc_id].tc_speed.period_unit * 256 *	\
-	CLOCK_26MHZ_CYCLE_NS) / 1000)
-#define FILTER_INT_US(tc_id)	\
-	(lvts_data->tc[tc_id].tc_speed.filter_interval_delay	\
-	* PERIOD_UNIT_US(tc_id))
-#define SENSOR_INT_US(tc_id)	\
-	(lvts_data->tc[tc_id].tc_speed.sensor_interval_delay	\
-	* PERIOD_UNIT_US(tc_id))
-#define GROUP_INT_US(tc_id)	\
-	(lvts_data->tc[tc_id].tc_speed.group_interval_delay	\
-	* PERIOD_UNIT_US(tc_id))
-
-#define SENSOR_LATENCY_US(tc_id) \
-	((NUM_OF_SAMPLE(tc_id) - 1) * FILTER_INT_US(tc_id)	\
-	+ NUM_OF_SAMPLE(tc_id) * ONE_SAMPLE)
-
-#define GROUP_LATENCY_US(tc_id)	\
-	(GET_TC_SENSOR_NUM(tc_id) * SENSOR_LATENCY_US(tc_id)	\
-	+ (GET_TC_SENSOR_NUM(tc_id) - 1) * SENSOR_INT_US(tc_id)	\
-	+ GROUP_INT_US(tc_id))
-
-/*==================================================
- * LVTS local common code
- *==================================================
- */
-static int lvts_raw_to_temp(struct formula_coeff *co, unsigned int msr_raw)
+static int lvts_raw_to_temp(struct lvts_formula_coeff *co, unsigned int msr_raw)
 {
 	/* This function returns degree mC */
 
@@ -131,51 +35,30 @@ static int lvts_raw_to_temp(struct formula_coeff *co, unsigned int msr_raw)
 	return temp;
 }
 
-static unsigned int lvts_temp_to_raw(struct formula_coeff *co, int temp)
+static unsigned int lvts_temp_to_raw(struct lvts_formula_coeff *co, int temp)
 {
 	unsigned int msr_raw;
-	msr_raw = div_s64(((s64)(co->golden_temp * 500 + co->b - temp) << 14), (-1 * co->a));
-	return msr_raw;
-}
-
-static int lvts_read_all_tc_temperature(struct lvts_data *lvts_data)
-{
-	struct tc_settings *tc = lvts_data->tc;
-	unsigned int i, j, s_index, msr_raw;
-	int max_temp = 0, current_temp;
-	void __iomem *base;
 
-	for (i = 0; i < lvts_data->num_tc; i++) {
-		base = GET_BASE_ADDR(i);
-		for (j = 0; j < tc[i].num_sensor; j++) {
-			s_index = tc[i].sensor_map[j];
-
-			msr_raw = readl(LVTSMSR0_0 + base + 0x4 * j) & MRS_RAW_MASK;
-			current_temp = lvts_raw_to_temp(&lvts_data->coeff, msr_raw);
-
-			if (msr_raw == 0)
-				current_temp = THERMAL_TEMP_INVALID;
-			max_temp = max(max_temp, current_temp);
-
-			lvts_data->sen_data[s_index].msr_raw = msr_raw;
-			lvts_data->sen_data[s_index].temp = current_temp;
-		}
-	}
+	msr_raw = div_s64((s64)((co->golden_temp * 500 + co->b - temp)) << 14,
+		(-1 * co->a));
 
-	return max_temp;
+	return msr_raw;
 }
 
 static int soc_temp_lvts_read_temp(struct thermal_zone_device *tz, int *temperature)
 {
-	struct soc_temp_tz *lvts_tz = (struct soc_temp_tz *)tz->devdata;
+	struct soc_temp_tz *lvts_tz = tz->devdata;
 	struct lvts_data *lvts_data = lvts_tz->lvts_data;
+	struct device *dev = lvts_data->dev;
+	unsigned int msr_raw;
 
-	if (lvts_tz->id == 0)
-		*temperature = lvts_read_all_tc_temperature(lvts_data);
-	else if (lvts_tz->id - 1 < lvts_data->num_sensor)
-		*temperature = lvts_data->sen_data[lvts_tz->id - 1].temp;
-	else
-		return -EINVAL;
+	msr_raw = readl(lvts_data->reg[lvts_tz->id]) & MRS_RAW_MASK;
+	if (msr_raw == 0) {
+		/* Prevents a false critical temperature trap */
+		*temperature = 0;
+		dev_dbg(dev, "LVTS not yet ready\n");
+	} else
+		*temperature = lvts_raw_to_temp(&lvts_data->coeff, msr_raw);
 
 	return 0;
 }
@@ -185,47 +68,43 @@ static const struct thermal_zone_device_ops soc_temp_lvts_ops = {
 };
 
 static void lvts_write_device(struct lvts_data *lvts_data, unsigned int data,
-			      int tc_id)
+	int tc_id)
 {
-	struct device *dev = lvts_data->dev;
-	void __iomem *base;
-	int ret;
-
-	base = GET_BASE_ADDR(tc_id);
+	void __iomem *base = GET_BASE_ADDR(lvts_data, tc_id);
 
-	writel(data, LVTS_CONFIG_0 + base);
+	writel(DEVICE_WRITE | data, LVTS_CONFIG_0 + base);
 
 	usleep_range(5, 15);
-	ret = readl_poll_timeout(LVTS_CONFIG_0 + base, data,
-				!(data & DEVICE_ACCESS_STARTUS), 2, 200);
-	if (ret)
-		dev_err(dev,"write device err: LVTS %d didn't ready, data 0x%x\n", tc_id, data);
 }
 
 static unsigned int lvts_read_device(struct lvts_data *lvts_data,
-				     unsigned int reg_idx, int tc_id)
+	unsigned int reg_idx, int tc_id)
 {
 	struct device *dev = lvts_data->dev;
-	void __iomem *base;
+	void __iomem *base = GET_BASE_ADDR(lvts_data, tc_id);
 	unsigned int data;
 	int ret;
 
-	base = GET_BASE_ADDR(tc_id);
 	writel(READ_DEVICE_REG(reg_idx), LVTS_CONFIG_0 + base);
 
 	usleep_range(5, 15);
+
 	ret = readl_poll_timeout(LVTS_CONFIG_0 + base, data,
-				 !(data & DEVICE_ACCESS_STARTUS),
-				 2, 200);
+		!(data & DEVICE_ACCESS_STARTUS), 2, 200);
 	if (ret)
 		dev_err(dev,
-			"Error: LVTS %d DEVICE_ACCESS_START didn't ready\n", tc_id);
+			"Error: LVTS %d DEVICE_ACCESS_START is not ready\n", tc_id);
 
 	data = readl(LVTSRDATA0_0 + base);
 
 	return data;
 }
 
+static const char * const lvts_error_table[] = {"IDLE", "Write transaction",
+	"Waiting for read after Write", "Disable Continue fetching on Device",
+	"Read transaction", "Set Device special Register for Voltage threshold",
+	"Set TSMCU number for Fetch"};
+
 static void wait_all_tc_sensing_point_idle(struct lvts_data *lvts_data)
 {
 	struct device *dev = lvts_data->dev;
@@ -238,27 +117,17 @@ static void wait_all_tc_sensing_point_idle(struct lvts_data *lvts_data)
 	for (cnt = 0; cnt < 2; cnt++) {
 		is_error = 0;
 		for (i = 0; i < lvts_data->num_tc; i++) {
-			base = GET_BASE_ADDR(i);
+			base = GET_BASE_ADDR(lvts_data, i);
 			ret = readl_poll_timeout(LVTSMSRCTL1_0 + base, error_code,
 						 !(error_code & mask), 2, 200);
-			/*
-			 * Error code
-			 * 000: IDLE
-			 * 001: Write transaction
-			 * 010: Waiting for read after Write
-			 * 011: Disable Continue fetching on Device
-			 * 100: Read transaction
-			 * 101: Set Device special Register for Voltage threshold
-			 * 111: Set TSMCU number for Fetch
-			 */
+
 			error_code = ((error_code & BIT(10)) >> 8) +
 				((error_code & BIT(7)) >> 6) +
 				(error_code & BIT(0));
 
 			if (ret)
-				dev_err(dev,
-					"Error LVTS %d sensing points aren't idle, error_code %d\n",
-					i, error_code);
+				dev_err(dev, "LVTS %d error: %s\n",
+					i, lvts_error_table[error_code]);
 
 			if (error_code != 0)
 				is_error = 1;
@@ -271,16 +140,10 @@ static void wait_all_tc_sensing_point_idle(struct lvts_data *lvts_data)
 
 static void lvts_reset(struct lvts_data *lvts_data)
 {
-	int i;
-
-	for (i = 0; i < lvts_data->num_domain; i++) {
-		if (lvts_data->domain[i].reset)
-			reset_control_assert(lvts_data->domain[i].reset);
-
-		usleep_range(20, 30);
-		if (lvts_data->domain[i].reset)
-			reset_control_deassert(lvts_data->domain[i].reset);
-	}
+	if (lvts_data->reset)
+		reset_control_assert(lvts_data->reset);
+	if (lvts_data->reset)
+		reset_control_deassert(lvts_data->reset);
 }
 
 static void device_identification(struct lvts_data *lvts_data)
@@ -290,19 +153,19 @@ static void device_identification(struct lvts_data *lvts_data)
 	void __iomem *base;
 
 	for (i = 0; i < lvts_data->num_tc; i++) {
-		base = GET_BASE_ADDR(i);
+		base = GET_BASE_ADDR(lvts_data, i);
 
 		writel(ENABLE_LVTS_CTRL_CLK, LVTSCLKEN_0 + base);
-
 		lvts_write_device(lvts_data, RESET_ALL_DEVICES, i);
+		writel(READ_BACK_DEVICE_ID, LVTS_CONFIG_0 + base);
 
-		lvts_write_device(lvts_data, READ_BACK_DEVICE_ID, i);
+		usleep_range(5, 15);
 
 		/* Check LVTS device ID */
-		data = (readl(LVTS_ID_0 + base) & GENMASK(7, 0));
-		if (data != (0x81 + i))
+		data = (readl(LVTS_ID_0 + base) & DEVICE_REG_DATA);
+		if (data != (lvts_data->tc->dev_id + i))
 			dev_err(dev, "LVTS_TC_%d, Device ID should be 0x%x, but 0x%x\n",
-				i, (0x81 + i), data);
+				i, (lvts_data->tc->dev_id + i), data);
 	}
 }
 
@@ -312,7 +175,7 @@ static void disable_all_sensing_points(struct lvts_data *lvts_data)
 	void __iomem *base;
 
 	for (i = 0; i < lvts_data->num_tc; i++) {
-		base = GET_BASE_ADDR(i);
+		base = GET_BASE_ADDR(lvts_data, i);
 		writel(DISABLE_SENSING_POINT, LVTSMONCTL0_0 + base);
 	}
 }
@@ -320,12 +183,12 @@ static void disable_all_sensing_points(struct lvts_data *lvts_data)
 static void enable_all_sensing_points(struct lvts_data *lvts_data)
 {
 	struct device *dev = lvts_data->dev;
-	struct tc_settings *tc = lvts_data->tc;
+	const struct lvts_tc_settings *tc = lvts_data->tc;
 	unsigned int i, num;
 	void __iomem *base;
 
 	for (i = 0; i < lvts_data->num_tc; i++) {
-		base = GET_BASE_ADDR(i);
+		base = GET_BASE_ADDR(lvts_data, i);
 		num = tc[i].num_sensor;
 
 		if (num > ALL_SENSING_POINTS) {
@@ -335,23 +198,27 @@ static void enable_all_sensing_points(struct lvts_data *lvts_data)
 			continue;
 		}
 
-		writel(ENABLE_SENSING_POINT(num), LVTSMONCTL0_0 + base);
+		if ((tc[i].ts_offset == 1) && (num == 1))
+			writel(LVTS_SINGLE_SENSE | (0x1 << tc[i].ts_offset),
+			       LVTSMONCTL0_0 + base);
+		else
+			writel(ENABLE_SENSING_POINT(num), LVTSMONCTL0_0 + base);
 	}
 }
 
 static void set_polling_speed(struct lvts_data *lvts_data, int tc_id)
 {
 	struct device *dev = lvts_data->dev;
-	struct tc_settings *tc = lvts_data->tc;
+	const struct lvts_tc_settings *tc = lvts_data->tc;
 	unsigned int lvts_mon_ctl_1, lvts_mon_ctl_2;
 	void __iomem *base;
 
-	base = GET_BASE_ADDR(tc_id);
+	base = GET_BASE_ADDR(lvts_data, tc_id);
 
-	lvts_mon_ctl_1 = ((tc[tc_id].tc_speed.group_interval_delay << 20) & GENMASK(29, 20)) |
-			(tc[tc_id].tc_speed.period_unit & GENMASK(9, 0));
-	lvts_mon_ctl_2 = ((tc[tc_id].tc_speed.filter_interval_delay << 16) & GENMASK(25, 16)) |
-			(tc[tc_id].tc_speed.sensor_interval_delay & GENMASK(9, 0));
+	lvts_mon_ctl_1 = ((tc[tc_id].tc_speed->group_interval_delay << 20) & GENMASK(29, 20)) |
+		(tc[tc_id].tc_speed->period_unit & GENMASK(9, 0));
+	lvts_mon_ctl_2 = ((tc[tc_id].tc_speed->filter_interval_delay << 16) & GENMASK(25, 16)) |
+		(tc[tc_id].tc_speed->sensor_interval_delay & GENMASK(9, 0));
 	/*
 	 * Clock source of LVTS thermal controller is 26MHz.
 	 * Period unit is a base for all interval delays
@@ -376,21 +243,22 @@ static void set_polling_speed(struct lvts_data *lvts_data, int tc_id)
 	writel(lvts_mon_ctl_1, LVTSMONCTL1_0 + base);
 	writel(lvts_mon_ctl_2, LVTSMONCTL2_0 + base);
 
-	dev_info(dev, "%s %d, LVTSMONCTL1_0= 0x%x,LVTSMONCTL2_0= 0x%x\n",
-		 __func__, tc_id, readl(LVTSMONCTL1_0 + base),
+	dev_dbg(dev, "LVTS_TC_%d, LVTSMONCTL1_0= 0x%x, LVTSMONCTL2_0= 0x%x\n",
+		 tc_id, readl(LVTSMONCTL1_0 + base),
 		 readl(LVTSMONCTL2_0 + base));
 }
 
 static void set_hw_filter(struct lvts_data *lvts_data, int tc_id)
 {
 	struct device *dev = lvts_data->dev;
-	struct tc_settings *tc = lvts_data->tc;
+	const struct lvts_tc_settings *tc = lvts_data->tc;
 	unsigned int option;
 	void __iomem *base;
 
-	base = GET_BASE_ADDR(tc_id);
+	base = GET_BASE_ADDR(lvts_data, tc_id);
 	option = tc[tc_id].hw_filter & 0x7;
-	/* hw filter
+	/*
+	 * hw filter
 	 * 000: Get one sample
 	 * 001: Get 2 samples and average them
 	 * 010: Get 4 samples, drop max and min, then average the rest of 2 samples
@@ -401,20 +269,20 @@ static void set_hw_filter(struct lvts_data *lvts_data, int tc_id)
 	option = (option << 9) | (option << 6) | (option << 3) | option;
 
 	writel(option, LVTSMSRCTL0_0 + base);
-	dev_info(dev, "%s %d, LVTSMSRCTL0_0= 0x%x\n",
-		 __func__, tc_id, readl(LVTSMSRCTL0_0 + base));
+	dev_dbg(dev, "LVTS_TC_%d, LVTSMSRCTL0_0= 0x%x\n",
+		 tc_id, readl(LVTSMSRCTL0_0 + base));
 }
 
 static int get_dominator_index(struct lvts_data *lvts_data, int tc_id)
 {
 	struct device *dev = lvts_data->dev;
-	struct tc_settings *tc = lvts_data->tc;
+	const struct lvts_tc_settings *tc = lvts_data->tc;
 	int d_index;
 
 	if (tc[tc_id].dominator_sensing_point == ALL_SENSING_POINTS) {
 		d_index = ALL_SENSING_POINTS;
-	} else if (tc[tc_id].dominator_sensing_point <
-		tc[tc_id].num_sensor){
+	} else if ((tc[tc_id].dominator_sensing_point <
+		tc[tc_id].num_sensor) || (tc[tc_id].ts_offset != 0)) {
 		d_index = tc[tc_id].dominator_sensing_point;
 	} else {
 		dev_err(dev,
@@ -434,9 +302,10 @@ static void disable_hw_reboot_interrupt(struct lvts_data *lvts_data, int tc_id)
 	unsigned int temp;
 	void __iomem *base;
 
-	base = GET_BASE_ADDR(tc_id);
+	base = GET_BASE_ADDR(lvts_data, tc_id);
 
-	/* LVTS thermal controller has two interrupts for thermal HW reboot
+	/*
+	 * LVTS thermal controller has two interrupts for thermal HW reboot
 	 * One is for AP SW and the other is for RGU
 	 * The interrupt of AP SW can turn off by a bit of a register, but
 	 * the other for RGU cannot.
@@ -445,7 +314,8 @@ static void disable_hw_reboot_interrupt(struct lvts_data *lvts_data, int tc_id)
 	 * temperature.
 	 */
 
-	/* After adding the huge offset 0x3FFF, LVTS alawys adds the
+	/*
+	 * After adding the huge offset 0x3FFF, LVTS alawys adds the
 	 * offset to MSR_RAW.
 	 * When MSR_RAW is larger, SW will convert lower temperature/
 	 */
@@ -462,7 +332,7 @@ static void enable_hw_reboot_interrupt(struct lvts_data *lvts_data, int tc_id)
 	unsigned int temp;
 	void __iomem *base;
 
-	base = GET_BASE_ADDR(tc_id);
+	base = GET_BASE_ADDR(lvts_data, tc_id);
 
 	/* Enable the interrupt of AP SW */
 	temp = readl(LVTSMONINT_0 + base);
@@ -473,17 +343,16 @@ static void enable_hw_reboot_interrupt(struct lvts_data *lvts_data, int tc_id)
 }
 
 static void set_tc_hw_reboot_threshold(struct lvts_data *lvts_data,
-				       int trip_point, int tc_id)
+	int trip_point, int tc_id)
 {
 	struct device *dev = lvts_data->dev;
 	unsigned int msr_raw, temp, config, d_index;
 	void __iomem *base;
 
-	base = GET_BASE_ADDR(tc_id);
+	base = GET_BASE_ADDR(lvts_data, tc_id);
 	d_index = get_dominator_index(lvts_data, tc_id);
 
-	dev_info(dev, "%s: LVTS%d, the dominator sensing point= %d\n",
-		 __func__, tc_id, d_index);
+	dev_info(dev, "lvts_tc_%d: dominator sensing point = %d\n", tc_id, d_index);
 
 	disable_hw_reboot_interrupt(lvts_data, tc_id);
 
@@ -506,7 +375,7 @@ static void set_tc_hw_reboot_threshold(struct lvts_data *lvts_data,
 
 static void set_all_tc_hw_reboot(struct lvts_data *lvts_data)
 {
-	struct tc_settings *tc = lvts_data->tc;
+	const struct lvts_tc_settings *tc = lvts_data->tc;
 	int i, trip_point;
 
 	for (i = 0; i < lvts_data->num_tc; i++) {
@@ -515,7 +384,7 @@ static void set_all_tc_hw_reboot(struct lvts_data *lvts_data)
 		if (tc[i].num_sensor == 0)
 			continue;
 
-		if (trip_point == DISABLE_THERMAL_HW_REBOOT)
+		if (trip_point == THERMAL_TEMP_INVALID)
 			continue;
 
 		set_tc_hw_reboot_threshold(lvts_data, trip_point, i);
@@ -542,7 +411,7 @@ static int lvts_init(struct lvts_data *lvts_data)
 	if (ops->device_enable_and_init)
 		ops->device_enable_and_init(lvts_data);
 
-	if (IS_ENABLE(FEATURE_DEVICE_AUTO_RCK)) {
+	if (HAS_FEATURE(lvts_data, FEATURE_DEVICE_AUTO_RCK)) {
 		if (ops->device_enable_auto_rck)
 			ops->device_enable_auto_rck(lvts_data);
 	} else {
@@ -567,18 +436,18 @@ static int lvts_init(struct lvts_data *lvts_data)
 static int prepare_calibration_data(struct lvts_data *lvts_data)
 {
 	struct device *dev = lvts_data->dev;
-	struct sensor_cal_data *cal_data = &lvts_data->cal_data;
+	struct lvts_sensor_cal_data *cal_data = &lvts_data->cal_data;
 	struct platform_ops *ops = &lvts_data->ops;
-	int i, offset, size;
+	int i, offset;
 	char buffer[512];
 
 	cal_data->count_r = devm_kcalloc(dev, lvts_data->num_sensor,
-					 sizeof(*cal_data->count_r), GFP_KERNEL);
+		sizeof(*cal_data->count_r), GFP_KERNEL);
 	if (!cal_data->count_r)
 		return -ENOMEM;
 
 	cal_data->count_rc = devm_kcalloc(dev, lvts_data->num_sensor,
-					  sizeof(*cal_data->count_rc), GFP_KERNEL);
+		sizeof(*cal_data->count_rc), GFP_KERNEL);
 	if (!cal_data->count_rc)
 		return -ENOMEM;
 
@@ -590,7 +459,7 @@ static int prepare_calibration_data(struct lvts_data *lvts_data)
 	if (cal_data->use_fake_efuse) {
 		/* It means all efuse data are equal to 0 */
 		dev_err(dev,
-			"[lvts_cal] This sample is not calibrated, fake !!\n");
+			"%s: This sample is not calibrated, fake !!\n", __func__);
 
 		cal_data->golden_temp = cal_data->default_golden_temp;
 		for (i = 0; i < lvts_data->num_sensor; i++) {
@@ -601,29 +470,14 @@ static int prepare_calibration_data(struct lvts_data *lvts_data)
 
 	lvts_data->coeff.golden_temp = cal_data->golden_temp;
 
-	dev_info(dev, "[lvts_cal] golden_temp = %d\n", cal_data->golden_temp);
-
-	size = sizeof(buffer);
-	offset = snprintf(buffer, size, "[lvts_cal] num:g_count:g_count_rc ");
-
-	if (offset < 0)
-		return -EINVAL;
-
-	if (offset >= size)
-		return -ENOMEM;
+	dev_dbg(dev, "golden_temp = %d\n", cal_data->golden_temp);
 
+	offset = snprintf(buffer, sizeof(buffer), "[lvts_cal] num:g_count:g_count_rc ");
 	for (i = 0; i < lvts_data->num_sensor; i++)
-		offset += snprintf(buffer + offset, size - offset, "%d:%d:%d ",
-				   i, cal_data->count_r[i], cal_data->count_rc[i]);
-
-	if (offset < 0)
-		return -EINVAL;
-
-	if (offset >= size)
-		return -ENOMEM;
+		offset += snprintf(buffer + offset, sizeof(buffer) - offset, "%d:%d:%d ",
+			i, cal_data->count_r[i], cal_data->count_rc[i]);
 
 	buffer[offset] = '\0';
-	dev_info(dev, "%s\n", buffer);
 
 	return 0;
 }
@@ -631,11 +485,11 @@ static int prepare_calibration_data(struct lvts_data *lvts_data)
 static int get_calibration_data(struct lvts_data *lvts_data)
 {
 	struct device *dev = lvts_data->dev;
-	char cell_name[8];
+	char cell_name[32];
 	struct nvmem_cell *cell;
 	u32 *buf;
-	size_t len = 0;
-	int i, offset, j, index = 0;
+	size_t len;
+	int i, j, index = 0, ret;
 
 	lvts_data->efuse = devm_kcalloc(dev, lvts_data->num_efuse_addr,
 					sizeof(*lvts_data->efuse), GFP_KERNEL);
@@ -643,12 +497,7 @@ static int get_calibration_data(struct lvts_data *lvts_data)
 		return -ENOMEM;
 
 	for (i = 0; i < lvts_data->num_efuse_block; i++) {
-		offset = snprintf(cell_name, sizeof(cell_name), "e_data%d", i + 1);
-		if (offset < 0)
-			return -EINVAL;
-
-		if (offset >= sizeof(cell_name))
-			return -ENOMEM;
+		snprintf(cell_name, sizeof(cell_name), "lvts_calib_data%d", i + 1);
 		cell = nvmem_cell_get(dev, cell_name);
 		if (IS_ERR(cell)) {
 			dev_err(dev, "Error: Failed to get nvmem cell %s\n", cell_name);
@@ -675,65 +524,78 @@ static int get_calibration_data(struct lvts_data *lvts_data)
 		kfree(buf);
 	}
 
+	ret = prepare_calibration_data(lvts_data);
+
+	return ret;
+}
+
+static int lvts_init_tc_regs(struct device *dev, struct lvts_data *lvts_data)
+{
+	const struct lvts_tc_settings *tc = lvts_data->tc;
+	unsigned int i, j, s_index, x;
+	void __iomem *base;
+
+	lvts_data->reg = devm_kcalloc(dev, lvts_data->num_sensor,
+		sizeof(*lvts_data->reg), GFP_KERNEL);
+	if (!lvts_data->reg)
+		return -ENOMEM;
+
+	for (i = 0; i < lvts_data->num_tc; i++) {
+		base = GET_BASE_ADDR(lvts_data, i);
+		for (j = 0; j < tc[i].num_sensor; j++) {
+			s_index = tc[i].sensor_map[j];
+			x = j + tc[i].ts_offset;
+			lvts_data->reg[s_index] = LVTSMSR0_0 + base + 0x4 * x;
+		}
+	}
+
 	return 0;
 }
 
 static int of_update_lvts_data(struct lvts_data *lvts_data,
-			       struct platform_device *pdev)
+	struct platform_device *pdev)
 {
 	struct device *dev = lvts_data->dev;
-	struct power_domain *domain;
 	struct resource *res;
-	unsigned int i;
 	int ret;
 
-	lvts_data->clk = devm_clk_get(dev, "lvts_clk");
+	lvts_data->clk = devm_clk_get(dev, NULL);
 	if (IS_ERR(lvts_data->clk))
 		return PTR_ERR(lvts_data->clk);
 
-	domain = devm_kcalloc(dev, lvts_data->num_domain, sizeof(*domain), GFP_KERNEL);
-	if (!domain)
-		return -ENOMEM;
-
-	for (i = 0; i < lvts_data->num_domain; i++) {
-		/* Get base address */
-		res = platform_get_resource(pdev, IORESOURCE_MEM, i);
-		if (!res) {
-			dev_err(dev, "No IO resource, index %d\n", i);
-			return -ENXIO;
-		}
-
-		domain[i].base = devm_ioremap_resource(dev, res);
-		if (IS_ERR(domain[i].base)) {
-			dev_err(dev, "Failed to remap io, index %d\n", i);
-			return PTR_ERR(domain[i].base);
-		}
+	/* Get base address */
+	res = platform_get_mem_or_io(pdev, 0);
+	if (!res) {
+		dev_err(dev, "No IO resource\n");
+		return -ENXIO;
+	}
 
-		/* Get interrupt number */
-		ret = platform_get_irq(pdev, i);
-		if (ret < 0)
-			return ret;
-		domain[i].irq_num = ret;
+	lvts_data->base = devm_ioremap_resource(dev, res);
+	if (IS_ERR(lvts_data->base)) {
+		dev_err(dev, "Failed to remap io\n");
+		return PTR_ERR(lvts_data->base);
+	}
 
-		/* Get reset control */
-		domain[i].reset = devm_reset_control_get_by_index(dev, i);
-		if (IS_ERR(domain[i].reset)) {
-			dev_err(dev, "Failed to get, index %d\n", i);
-			return PTR_ERR(domain[i].reset);
-		}
+	/* Get interrupt number */
+	ret = platform_get_irq(pdev, 0);
+	if (ret < 0) {
+		dev_err(dev, "No irq resource\n");
+		return -EINVAL;
 	}
+	lvts_data->irq_num = ret;
 
-	lvts_data->domain = domain;
+	/* Get reset control */
+	lvts_data->reset = devm_reset_control_get_by_index(dev, 0);
+	if (IS_ERR(lvts_data->reset)) {
+		dev_err(dev, "Failed to get reset control\n");
+		return PTR_ERR(lvts_data->reset);
+	}
 
-	lvts_data->sen_data = devm_kcalloc(dev, lvts_data->num_sensor,
-					   sizeof(*lvts_data->sen_data), GFP_KERNEL);
-	if (!lvts_data->sen_data)
-		return -ENOMEM;
+	ret = lvts_init_tc_regs(dev, lvts_data);
+	if (ret)
+		return ret;
 
 	ret = get_calibration_data(lvts_data);
-	if (ret)
-		lvts_data->cal_data.use_fake_efuse = 1;
-	ret = prepare_calibration_data(lvts_data);
 	if (ret)
 		return ret;
 
@@ -746,7 +608,7 @@ static void lvts_device_close(struct lvts_data *lvts_data)
 	void __iomem *base;
 
 	for (i = 0; i < lvts_data->num_tc; i++) {
-		base = GET_BASE_ADDR(i);
+		base = GET_BASE_ADDR(lvts_data, i);
 		lvts_write_device(lvts_data, RESET_ALL_DEVICES, i);
 		writel(DISABLE_LVTS_CTRL_CLK, LVTSCLKEN_0 + base);
 	}
@@ -762,45 +624,41 @@ static void lvts_close(struct lvts_data *lvts_data)
 
 static void tc_irq_handler(struct lvts_data *lvts_data, int tc_id)
 {
-	struct device *dev = lvts_data->dev;
+	const struct device *dev = lvts_data->dev;
 	unsigned int ret = 0;
 	void __iomem *base;
 
-	base = GET_BASE_ADDR(tc_id);
+	base = GET_BASE_ADDR(lvts_data, tc_id);
 
 	ret = readl(LVTSMONINTSTS_0 + base);
 	/* Write back to clear interrupt status */
 	writel(ret, LVTSMONINTSTS_0 + base);
 
-	dev_info(dev, "[Thermal IRQ] LVTS thermal controller %d, LVTSMONINTSTS=0x%08x\n",
-		 tc_id, ret);
+	dev_dbg(dev, "LVTS thermal controller %d, LVTSMONINTSTS=0x%08x\n", tc_id, ret);
 
 	if (ret & THERMAL_PROTECTION_STAGE_3)
-		dev_info(dev,
-			 "[Thermal IRQ]: Thermal protection stage 3 interrupt triggered\n");
+		dev_dbg(dev, "Thermal protection stage 3 interrupt triggered\n");
 }
 
 static irqreturn_t irq_handler(int irq, void *dev_id)
 {
 	struct lvts_data *lvts_data = (struct lvts_data *)dev_id;
 	struct device *dev = lvts_data->dev;
-	struct tc_settings *tc = lvts_data->tc;
+	const struct lvts_tc_settings *tc = lvts_data->tc;
 	unsigned int i, *irq_bitmap;
 	void __iomem *base;
 
-	irq_bitmap = kcalloc(lvts_data->num_domain, sizeof(*irq_bitmap), GFP_ATOMIC);
+	irq_bitmap = kcalloc(1, sizeof(*irq_bitmap), GFP_ATOMIC);
 
 	if (!irq_bitmap)
 		return IRQ_NONE;
 
-	for (i = 0; i < lvts_data->num_domain; i++) {
-		base = lvts_data->domain[i].base;
-		irq_bitmap[i] = readl(THERMINTST + base);
-		dev_info(dev, "%s : THERMINTST = 0x%x\n", __func__, irq_bitmap[i]);
-	}
+	base = lvts_data->base;
+	*irq_bitmap = readl(THERMINTST + base);
+	dev_dbg(dev, "THERMINTST = 0x%x\n", *irq_bitmap);
 
 	for (i = 0; i < lvts_data->num_tc; i++) {
-		if ((irq_bitmap[tc[i].domain_index] & tc[i].irq_bit) == 0)
+		if (tc[i].irq_bit == 0)
 			tc_irq_handler(lvts_data, i);
 	}
 
@@ -812,19 +670,16 @@ static irqreturn_t irq_handler(int irq, void *dev_id)
 static int lvts_register_irq_handler(struct lvts_data *lvts_data)
 {
 	struct device *dev = lvts_data->dev;
-	unsigned int i;
 	int ret;
 
-	for (i = 0; i < lvts_data->num_domain; i++) {
-		ret = devm_request_irq(dev, lvts_data->domain[i].irq_num, irq_handler,
-				       IRQF_TRIGGER_HIGH, "mtk_lvts", lvts_data);
+	ret = devm_request_irq(dev, lvts_data->irq_num, irq_handler,
+		IRQF_TRIGGER_HIGH, "mtk_lvts", lvts_data);
 
-		if (ret) {
-			dev_err(dev, "Failed to register LVTS IRQ, ret %d, domain %d irq_num %d\n",
-				ret, i, lvts_data->domain[i].irq_num);
-			lvts_close(lvts_data);
-			return ret;
-		}
+	if (ret) {
+		dev_err(dev, "Failed to register LVTS IRQ, ret %d, irq_num %d\n",
+			ret, lvts_data->irq_num);
+		lvts_close(lvts_data);
+		return ret;
 	}
 
 	return 0;
@@ -837,7 +692,7 @@ static int lvts_register_thermal_zones(struct lvts_data *lvts_data)
 	struct soc_temp_tz *lvts_tz;
 	int i, ret;
 
-	for (i = 0; i < lvts_data->num_sensor + 1; i++) {
+	for (i = 0; i < lvts_data->num_sensor; i++) {
 		lvts_tz = devm_kzalloc(dev, sizeof(*lvts_tz), GFP_KERNEL);
 		if (!lvts_tz) {
 			lvts_close(lvts_data);
@@ -848,7 +703,7 @@ static int lvts_register_thermal_zones(struct lvts_data *lvts_data)
 		lvts_tz->lvts_data = lvts_data;
 
 		tzdev = devm_thermal_of_zone_register(dev, lvts_tz->id,
-						      lvts_tz, &soc_temp_lvts_ops);
+			lvts_tz, &soc_temp_lvts_ops);
 
 		if (IS_ERR(tzdev)) {
 			if (lvts_tz->id != 0)
@@ -865,81 +720,25 @@ static int lvts_register_thermal_zones(struct lvts_data *lvts_data)
 	return 0;
 }
 
-static int lvts_probe(struct platform_device *pdev)
+void lvts_device_enable_and_init_v5(struct lvts_data *lvts_data)
 {
-	struct device *dev = &pdev->dev;
-	struct lvts_data *lvts_data;
-	int ret;
-
-	lvts_data = (struct lvts_data *)of_device_get_match_data(dev);
+	unsigned int i;
 
-	if (!lvts_data)	{
-		dev_err(dev, "Error: Failed to get lvts platform data\n");
-		return -ENODATA;
+	for (i = 0; i < lvts_data->num_tc; i++) {
+		lvts_write_device(lvts_data, STOP_COUNTING_V4, i);
+		lvts_write_device(lvts_data, SET_RG_TSFM_LPDLY_V4, i);
+		lvts_write_device(lvts_data, SET_COUNTING_WINDOW_20US1_V4, i);
+		lvts_write_device(lvts_data, SET_COUNTING_WINDOW_20US2_V4, i);
+		lvts_write_device(lvts_data, TSV2F_CHOP_CKSEL_AND_TSV2F_EN_V5, i);
+		lvts_write_device(lvts_data, TSBG_DEM_CKSEL_X_TSBG_CHOP_EN_V5, i);
+		lvts_write_device(lvts_data, SET_TS_RSV_V4, i);
+		lvts_write_device(lvts_data, SET_TS_CHOP_V5, i);
 	}
-	lvts_data->dev = &pdev->dev;
-
-	ret = of_update_lvts_data(lvts_data, pdev);
-	if (ret)
-		return ret;
-
-	platform_set_drvdata(pdev, lvts_data);
-	ret = lvts_init(lvts_data);
-	if (ret)
-		return ret;
-
-	ret = lvts_register_irq_handler(lvts_data);
-	if (ret)
-		return ret;
-
-	ret = lvts_register_thermal_zones(lvts_data);
-	if (ret)
-		return ret;
-
-	return 0;
-}
-
-static int lvts_remove(struct platform_device *pdev)
-{
-	struct lvts_data *lvts_data;
-
-	lvts_data = (struct lvts_data *)platform_get_drvdata(pdev);
-
-	lvts_close(lvts_data);
-
-	return 0;
-}
-
-static int lvts_suspend(struct platform_device *pdev, pm_message_t state)
-{
-	struct lvts_data *lvts_data;
-
-	lvts_data = (struct lvts_data *)platform_get_drvdata(pdev);
-
-	lvts_close(lvts_data);
-
-	return 0;
-}
-
-static int lvts_resume(struct platform_device *pdev)
-{
-	int ret;
-	struct lvts_data *lvts_data;
-
-	lvts_data = (struct lvts_data *)platform_get_drvdata(pdev);
-
-	ret = lvts_init(lvts_data);
-	if (ret)
-		return ret;
-
-	return 0;
+	lvts_data->counting_window_us = 20;
 }
+EXPORT_SYMBOL_GPL(lvts_device_enable_and_init_v5);
 
-/*==================================================
- * LVTS v4 common code
- *==================================================
- */
-static void device_enable_and_init_v4(struct lvts_data *lvts_data)
+void lvts_device_enable_and_init_v4(struct lvts_data *lvts_data)
 {
 	unsigned int i;
 
@@ -958,34 +757,36 @@ static void device_enable_and_init_v4(struct lvts_data *lvts_data)
 
 	lvts_data->counting_window_us = 20;
 }
+EXPORT_SYMBOL_GPL(lvts_device_enable_and_init_v4);
 
-static void device_enable_auto_rck_v4(struct lvts_data *lvts_data)
+void lvts_device_enable_auto_rck_v4(struct lvts_data *lvts_data)
 {
 	unsigned int i;
 
 	for (i = 0; i < lvts_data->num_tc; i++)
 		lvts_write_device(lvts_data, SET_LVTS_AUTO_RCK_V4, i);
 }
+EXPORT_SYMBOL_GPL(lvts_device_enable_auto_rck_v4);
 
-static int device_read_count_rc_n_v4(struct lvts_data *lvts_data)
+int lvts_device_read_count_rc_n_v4(struct lvts_data *lvts_data)
 {
 	/* Resistor-Capacitor Calibration */
 	/* count_RC_N: count RC now */
 	struct device *dev = lvts_data->dev;
-	struct tc_settings *tc = lvts_data->tc;
-	struct sensor_cal_data *cal_data = &lvts_data->cal_data;
+	const struct lvts_tc_settings *tc = lvts_data->tc;
+	struct lvts_sensor_cal_data *cal_data = &lvts_data->cal_data;
 	unsigned int offset, size, s_index, data;
 	void __iomem *base;
 	int ret, i, j;
 	char buffer[512];
 
 	cal_data->count_rc_now = devm_kcalloc(dev, lvts_data->num_sensor,
-					      sizeof(*cal_data->count_rc_now), GFP_KERNEL);
+		sizeof(*cal_data->count_rc_now), GFP_KERNEL);
 	if (!cal_data->count_rc_now)
 		return -ENOMEM;
 
 	for (i = 0; i < lvts_data->num_tc; i++) {
-		base = GET_BASE_ADDR(i);
+		base = GET_BASE_ADDR(lvts_data, i);
 		for (j = 0; j < tc[i].num_sensor; j++) {
 			s_index = tc[i].sensor_map[j];
 
@@ -1016,61 +817,52 @@ static int device_read_count_rc_n_v4(struct lvts_data *lvts_data)
 
 	size = sizeof(buffer);
 	offset = snprintf(buffer, size, "[COUNT_RC_NOW] ");
-
-	if (offset < 0)
-		return -EINVAL;
-
-	if (offset >= size)
-		return -ENOMEM;
-
 	for (i = 0; i < lvts_data->num_sensor; i++)
 		offset += snprintf(buffer + offset, size - offset, "%d:%d ",
-				   i, cal_data->count_rc_now[i]);
-
-	if (offset < 0)
-		return -EINVAL;
-
-	if (offset >= size)
-		return -ENOMEM;
+			i, cal_data->count_rc_now[i]);
 
 	buffer[offset] = '\0';
-	dev_info(dev, "%s\n", buffer);
+	dev_dbg(dev, "%s\n", buffer);
 
 	return 0;
 }
+EXPORT_SYMBOL_GPL(lvts_device_read_count_rc_n_v4);
 
-static void set_calibration_data_v4(struct lvts_data *lvts_data)
+void lvts_set_calibration_data_v4(struct lvts_data *lvts_data)
 {
-	struct tc_settings *tc = lvts_data->tc;
-	struct sensor_cal_data *cal_data = &lvts_data->cal_data;
-	unsigned int i, j, s_index, e_data;
+	const struct lvts_tc_settings *tc = lvts_data->tc;
+	struct lvts_sensor_cal_data *cal_data = &lvts_data->cal_data;
+	unsigned int i, j, s_index, lvts_calib_data, x;
 	void __iomem *base;
 
 	for (i = 0; i < lvts_data->num_tc; i++) {
-		base = GET_BASE_ADDR(i);
+		base = GET_BASE_ADDR(lvts_data, i);
 
 		for (j = 0; j < tc[i].num_sensor; j++) {
 			s_index = tc[i].sensor_map[j];
-			if (IS_ENABLE(FEATURE_DEVICE_AUTO_RCK))
-				e_data = cal_data->count_r[s_index];
+			x = j + tc[i].ts_offset;
+
+			if (HAS_FEATURE(lvts_data, FEATURE_DEVICE_AUTO_RCK))
+				lvts_calib_data = cal_data->count_r[s_index];
 			else
-				e_data = (((unsigned long long)
+				lvts_calib_data = (((unsigned long long)
 					cal_data->count_rc_now[s_index]) *
 					cal_data->count_r[s_index]) >> 14;
 
-			writel(e_data, LVTSEDATA00_0 + base + 0x4 * j);
+			writel(lvts_calib_data, LVTSEDATA00_0 + base + 0x4 * x);
 		}
 	}
 }
+EXPORT_SYMBOL_GPL(lvts_set_calibration_data_v4);
 
-static void init_controller_v4(struct lvts_data *lvts_data)
+void lvts_init_controller_v4(struct lvts_data *lvts_data)
 {
 	struct device *dev = lvts_data->dev;
 	unsigned int i;
 	void __iomem *base;
 
 	for (i = 0; i < lvts_data->num_tc; i++) {
-		base = GET_BASE_ADDR(i);
+		base = GET_BASE_ADDR(lvts_data, i);
 
 		lvts_write_device(lvts_data, SET_DEVICE_LOW_POWER_SINGLE_MODE_V4, i);
 
@@ -1080,583 +872,85 @@ static void init_controller_v4(struct lvts_data *lvts_data)
 		set_polling_speed(lvts_data, i);
 		set_hw_filter(lvts_data, i);
 
-		dev_info(dev, "lvts%d: read all %d sensors in %d us, one in %d us\n",
-			 i, GET_TC_SENSOR_NUM(i), GROUP_LATENCY_US(i), SENSOR_LATENCY_US(i));
+		dev_info(dev, "lvts_tc_%d: read all %d sensors in %d us, one in %d us\n",
+			i, GET_TC_SENSOR_NUM(lvts_data, i), GROUP_LATENCY_US(i), SENSOR_LATENCY_US(i));
 	}
 }
+EXPORT_SYMBOL_GPL(lvts_init_controller_v4);
 
-/*==================================================
- * LVTS MT6873
- *==================================================
- */
-
-#define MT6873_NUM_LVTS (ARRAY_SIZE(mt6873_tc_settings))
-
-enum mt6873_lvts_domain {
-	MT6873_AP_DOMAIN,
-	MT6873_MCU_DOMAIN,
-	MT6873_NUM_DOMAIN
-};
-
-enum mt6873_lvts_sensor_enum {
-	MT6873_TS1_0,
-	MT6873_TS1_1,
-	MT6873_TS2_0,
-	MT6873_TS2_1,
-	MT6873_TS3_0,
-	MT6873_TS3_1,
-	MT6873_TS3_2,
-	MT6873_TS3_3,
-	MT6873_TS4_0,
-	MT6873_TS4_1,
-	MT6873_TS5_0,
-	MT6873_TS5_1,
-	MT6873_TS6_0,
-	MT6873_TS6_1,
-	MT6873_TS7_0,
-	MT6873_TS7_1,
-	MT6873_TS7_2,
-	MT6873_NUM_TS
-};
-
-static void mt6873_efuse_to_cal_data(struct lvts_data *lvts_data)
+int lvts_probe(struct platform_device *pdev)
 {
-	struct sensor_cal_data *cal_data = &lvts_data->cal_data;
-
-	cal_data->golden_temp = GET_CAL_DATA_BITMASK(0, 31, 24);
-	cal_data->count_r[MT6873_TS1_0] = GET_CAL_DATA_BITMASK(1, 23, 0);
-	cal_data->count_r[MT6873_TS1_1] = GET_CAL_DATA_BITMASK(2, 23, 0);
-	cal_data->count_r[MT6873_TS2_0] = GET_CAL_DATA_BITMASK(3, 23, 0);
-	cal_data->count_r[MT6873_TS2_1] = GET_CAL_DATA_BITMASK(4, 23, 0);
-	cal_data->count_r[MT6873_TS3_0] = GET_CAL_DATA_BITMASK(5, 23, 0);
-	cal_data->count_r[MT6873_TS3_1] = GET_CAL_DATA_BITMASK(6, 23, 0);
-	cal_data->count_r[MT6873_TS3_2] = GET_CAL_DATA_BITMASK(7, 23, 0);
-	cal_data->count_r[MT6873_TS3_3] = GET_CAL_DATA_BITMASK(8, 23, 0);
-	cal_data->count_r[MT6873_TS4_0] = GET_CAL_DATA_BITMASK(9, 23, 0);
-	cal_data->count_r[MT6873_TS4_1] = GET_CAL_DATA_BITMASK(10, 23, 0);
-	cal_data->count_r[MT6873_TS5_0] = GET_CAL_DATA_BITMASK(11, 23, 0);
-	cal_data->count_r[MT6873_TS5_1] = GET_CAL_DATA_BITMASK(12, 23, 0);
-	cal_data->count_r[MT6873_TS6_0] = GET_CAL_DATA_BITMASK(13, 23, 0);
-	cal_data->count_r[MT6873_TS6_1] = GET_CAL_DATA_BITMASK(14, 23, 0);
-	cal_data->count_r[MT6873_TS7_0] = GET_CAL_DATA_BITMASK(15, 23, 0);
-	cal_data->count_r[MT6873_TS7_1] = GET_CAL_DATA_BITMASK(16, 23, 0);
-	cal_data->count_r[MT6873_TS7_2] = GET_CAL_DATA_BITMASK(17, 23, 0);
-
-	cal_data->count_rc[MT6873_TS1_0] = GET_CAL_DATA_BITMASK(21, 23, 0);
-
-	cal_data->count_rc[MT6873_TS2_0] = (GET_CAL_DATA_BITMASK(1, 31, 24) << 16) +
-					   (GET_CAL_DATA_BITMASK(2, 31, 24) << 8) +
-					    GET_CAL_DATA_BITMASK(3, 31, 24);
-
-	cal_data->count_rc[MT6873_TS3_0] = (GET_CAL_DATA_BITMASK(4, 31, 24) << 16) +
-					   (GET_CAL_DATA_BITMASK(5, 31, 24) << 8) +
-					    GET_CAL_DATA_BITMASK(6, 31, 24);
-
-	cal_data->count_rc[MT6873_TS4_0] = (GET_CAL_DATA_BITMASK(7, 31, 24) << 16) +
-					   (GET_CAL_DATA_BITMASK(8, 31, 24) << 8) +
-					    GET_CAL_DATA_BITMASK(9, 31, 24);
-
-	cal_data->count_rc[MT6873_TS5_0] = (GET_CAL_DATA_BITMASK(10, 31, 24) << 16) +
-					   (GET_CAL_DATA_BITMASK(11, 31, 24) << 8) +
-					    GET_CAL_DATA_BITMASK(12, 31, 24);
-
-	cal_data->count_rc[MT6873_TS6_0] = (GET_CAL_DATA_BITMASK(13, 31, 24) << 16) +
-					   (GET_CAL_DATA_BITMASK(14, 31, 24) << 8) +
-					    GET_CAL_DATA_BITMASK(15, 31, 24);
-
-	cal_data->count_rc[MT6873_TS7_0] = (GET_CAL_DATA_BITMASK(16, 31, 24) << 16) +
-					   (GET_CAL_DATA_BITMASK(17, 31, 24) << 8) +
-					    GET_CAL_DATA_BITMASK(18, 31, 24);
-}
+	struct device *dev = &pdev->dev;
+	struct lvts_data *lvts_data;
+	int ret;
+
+	lvts_data = (struct lvts_data *)of_device_get_match_data(dev);
 
-static struct tc_settings mt6873_tc_settings[] = {
-	[0] = {
-		.domain_index = MT6873_MCU_DOMAIN,
-		.addr_offset = 0x0,
-		.num_sensor = 2,
-		.sensor_map = {MT6873_TS1_0, MT6873_TS1_1},
-		.tc_speed = SET_TC_SPEED_IN_US(118, 118, 118, 118),
-		.hw_filter = LVTS_FILTER_2_OF_4,
-		.dominator_sensing_point = SENSING_POINT1,
-		.hw_reboot_trip_point = 117000,
-		.irq_bit = BIT(3),
-	},
-	[1] = {
-		.domain_index = MT6873_MCU_DOMAIN,
-		.addr_offset = 0x100,
-		.num_sensor = 2,
-		.sensor_map = {MT6873_TS2_0, MT6873_TS2_1},
-		.tc_speed = SET_TC_SPEED_IN_US(118, 118, 118, 118),
-		.hw_filter = LVTS_FILTER_2_OF_4,
-		.dominator_sensing_point = SENSING_POINT0,
-		.hw_reboot_trip_point = 117000,
-		.irq_bit = BIT(4),
-	},
-	[2] = {
-		.domain_index = MT6873_MCU_DOMAIN,
-		.addr_offset = 0x200,
-		.num_sensor = 4,
-		.sensor_map = {MT6873_TS3_0, MT6873_TS3_1, MT6873_TS3_2, MT6873_TS3_3},
-		.tc_speed = SET_TC_SPEED_IN_US(118, 118, 118, 118),
-		.hw_filter = LVTS_FILTER_2_OF_4,
-		.dominator_sensing_point = SENSING_POINT0,
-		.hw_reboot_trip_point = 117000,
-		.irq_bit = BIT(5),
-	},
-	[3] = {
-		.domain_index = MT6873_AP_DOMAIN,
-		.addr_offset = 0x0,
-		.num_sensor = 2,
-		.sensor_map = {MT6873_TS4_0, MT6873_TS4_1},
-		.tc_speed = SET_TC_SPEED_IN_US(118, 118, 118, 118),
-		.hw_filter = LVTS_FILTER_2_OF_4,
-		.dominator_sensing_point = SENSING_POINT0,
-		.hw_reboot_trip_point = 117000,
-		.irq_bit = BIT(3),
-	},
-	[4] = {
-		.domain_index = MT6873_AP_DOMAIN,
-		.addr_offset = 0x100,
-		.num_sensor = 2,
-		.sensor_map = {MT6873_TS5_0, MT6873_TS5_1},
-		.tc_speed = SET_TC_SPEED_IN_US(118, 118, 118, 118),
-		.hw_filter = LVTS_FILTER_2_OF_4,
-		.dominator_sensing_point = SENSING_POINT1,
-		.hw_reboot_trip_point = 117000,
-		.irq_bit = BIT(4),
-	},
-	[5] = {
-		.domain_index = MT6873_AP_DOMAIN,
-		.addr_offset = 0x200,
-		.num_sensor = 2,
-		.sensor_map = {MT6873_TS6_0, MT6873_TS6_1},
-		.tc_speed = SET_TC_SPEED_IN_US(118, 118, 118, 118),
-		.hw_filter = LVTS_FILTER_2_OF_4,
-		.dominator_sensing_point = SENSING_POINT1,
-		.hw_reboot_trip_point = 117000,
-		.irq_bit = BIT(5),
-	},
-	[6] = {
-		.domain_index = MT6873_AP_DOMAIN,
-		.addr_offset = 0x300,
-		.num_sensor = 3,
-		.sensor_map = {MT6873_TS7_0, MT6873_TS7_1, MT6873_TS7_2},
-		.tc_speed = SET_TC_SPEED_IN_US(118, 118, 118, 118),
-		.hw_filter = LVTS_FILTER_2_OF_4,
-		.dominator_sensing_point = SENSING_POINT2,
-		.hw_reboot_trip_point = 117000,
-		.irq_bit = BIT(6),
+	if (!lvts_data)	{
+		dev_err(dev, "Error: Failed to get lvts platform data\n");
+		return -ENODATA;
 	}
-};
 
-static struct lvts_data mt6873_lvts_data = {
-	.num_domain = MT6873_NUM_DOMAIN,
-	.num_tc = MT6873_NUM_LVTS,
-	.tc = mt6873_tc_settings,
-	.num_sensor = MT6873_NUM_TS,
-	.ops = {
-		.efuse_to_cal_data = mt6873_efuse_to_cal_data,
-		.device_enable_and_init = device_enable_and_init_v4,
-		.device_enable_auto_rck = device_enable_auto_rck_v4,
-		.device_read_count_rc_n = device_read_count_rc_n_v4,
-		.set_cal_data = set_calibration_data_v4,
-		.init_controller = init_controller_v4,
-	},
-	.feature_bitmap = FEATURE_DEVICE_AUTO_RCK,
-	.num_efuse_addr = 22,
-	.num_efuse_block = 1,
-	.cal_data = {
-		.default_golden_temp = 50,
-		.default_count_r = 35000,
-		.default_count_rc = 2750,
-	},
-	.coeff = {
-		.a = -250460,
-		.b = 250460,
-	},
-};
+	lvts_data->dev = &pdev->dev;
 
-/*==================================================
- * LVTS MT8195
- *==================================================
- */
+	ret = of_update_lvts_data(lvts_data, pdev);
+	if (ret)
+		return ret;
 
-#define MT8195_NUM_LVTS (ARRAY_SIZE(mt8195_tc_settings))
-#define TSV2F_CHOP_CKSEL_AND_TSV2F_EN_8195 (DEVICE_WRITE | RG_TSV2F_CTRL_2 << 8 | 0x8C)
-#define TSBG_DEM_CKSEL_X_TSBG_CHOP_EN_8195 (DEVICE_WRITE | RG_TSV2F_CTRL_4 << 8 | 0xFC)
-#define SET_TS_CHOP_8195 (DEVICE_WRITE | RG_TSV2F_CTRL_0 << 8 | 0xF1)
+	platform_set_drvdata(pdev, lvts_data);
 
-enum mt8195_lvts_domain {
-	MT8195_AP_DOMAIN,
-	MT8195_MCU_DOMAIN,
-	MT8195_NUM_DOMAIN
-};
+	ret = lvts_init(lvts_data);
+	if (ret)
+		return ret;
 
-enum mt8195_lvts_sensor_enum {
-	MT8195_TS1_0,
-	MT8195_TS1_1,
-	MT8195_TS2_0,
-	MT8195_TS2_1,
-	MT8195_TS3_0,
-	MT8195_TS3_1,
-	MT8195_TS3_2,
-	MT8195_TS3_3,
-	MT8195_TS4_0,
-	MT8195_TS4_1,
-	MT8195_TS5_0,
-	MT8195_TS5_1,
-	MT8195_TS6_0,
-	MT8195_TS6_1,
-	MT8195_TS6_2,
-	MT8195_TS7_0,
-	MT8195_TS7_1,
-	MT8195_NUM_TS
-};
+	ret = lvts_register_irq_handler(lvts_data);
+	if (ret)
+		return ret;
 
-static void mt8195_device_enable_and_init(struct lvts_data *lvts_data)
-{
-	unsigned int i;
+	ret = lvts_register_thermal_zones(lvts_data);
+	if (ret)
+		return ret;
 
-	for (i = 0; i < lvts_data->num_tc; i++) {
-		lvts_write_device(lvts_data, STOP_COUNTING_V4, i);
-		lvts_write_device(lvts_data, SET_RG_TSFM_LPDLY_V4, i);
-		lvts_write_device(lvts_data, SET_COUNTING_WINDOW_20US1_V4, i);
-		lvts_write_device(lvts_data, SET_COUNTING_WINDOW_20US2_V4, i);
-		lvts_write_device(lvts_data, TSV2F_CHOP_CKSEL_AND_TSV2F_EN_8195, i);
-		lvts_write_device(lvts_data, TSBG_DEM_CKSEL_X_TSBG_CHOP_EN_8195, i);
-		lvts_write_device(lvts_data, SET_TS_RSV_V4, i);
-		lvts_write_device(lvts_data, SET_TS_CHOP_8195, i);
-	}
-	lvts_data->counting_window_us = 20;
+	return 0;
 }
 
-static void mt8195_efuse_to_cal_data(struct lvts_data *lvts_data)
+int lvts_remove(struct platform_device *pdev)
 {
-	struct sensor_cal_data *cal_data = &lvts_data->cal_data;
-
-	cal_data->golden_temp = GET_CAL_DATA_BITMASK(0, 31, 24);
-	cal_data->count_r[MT8195_TS1_0] = GET_CAL_DATA_BITMASK(1, 23, 0);
-	cal_data->count_r[MT8195_TS1_1] = (GET_CAL_DATA_BITMASK(2, 15, 0) << 8) +
-					   GET_CAL_DATA_BITMASK(1, 31, 24);
-	cal_data->count_r[MT8195_TS2_0] = GET_CAL_DATA_BITMASK(3, 31, 8);
-	cal_data->count_r[MT8195_TS2_1] = GET_CAL_DATA_BITMASK(4, 23, 0);
-	cal_data->count_r[MT8195_TS3_0] = (GET_CAL_DATA_BITMASK(6, 7, 0) << 16) +
-					   GET_CAL_DATA_BITMASK(5, 31, 16);
-	cal_data->count_r[MT8195_TS3_1] = GET_CAL_DATA_BITMASK(6, 31, 8);
-	cal_data->count_r[MT8195_TS3_2] = GET_CAL_DATA_BITMASK(7, 23, 0);
-	cal_data->count_r[MT8195_TS3_3] = (GET_CAL_DATA_BITMASK(8, 15, 0) << 8) +
-					   GET_CAL_DATA_BITMASK(7, 31, 24);
-	cal_data->count_r[MT8195_TS4_0] = GET_CAL_DATA_BITMASK(9, 31, 8);
-	cal_data->count_r[MT8195_TS4_1] = GET_CAL_DATA_BITMASK(10, 23, 0);
-	cal_data->count_r[MT8195_TS5_0] = (GET_CAL_DATA_BITMASK(12, 7, 0) << 16) +
-					   GET_CAL_DATA_BITMASK(11, 31, 16);
-	cal_data->count_r[MT8195_TS5_1] = GET_CAL_DATA_BITMASK(12, 31, 8);
-	cal_data->count_r[MT8195_TS6_0] = (GET_CAL_DATA_BITMASK(14, 15, 0) << 8) +
-					   GET_CAL_DATA_BITMASK(13, 31, 24);
-	cal_data->count_r[MT8195_TS6_1] = (GET_CAL_DATA_BITMASK(15, 7, 0) << 16) +
-					   GET_CAL_DATA_BITMASK(14, 31, 16);
-	cal_data->count_r[MT8195_TS6_2] = GET_CAL_DATA_BITMASK(15, 31, 8);
-	cal_data->count_r[MT8195_TS7_0] = (GET_CAL_DATA_BITMASK(17, 15, 0) << 8) +
-					   GET_CAL_DATA_BITMASK(16, 31, 24);
-	cal_data->count_r[MT8195_TS7_1] = (GET_CAL_DATA_BITMASK(18, 7, 0) << 16) +
-					   GET_CAL_DATA_BITMASK(17, 31, 16);
-	cal_data->count_rc[MT8195_TS1_0] = (GET_CAL_DATA_BITMASK(3, 7, 0) << 16) +
-					    GET_CAL_DATA_BITMASK(2, 31, 16);
-	cal_data->count_rc[MT8195_TS2_0] = (GET_CAL_DATA_BITMASK(5, 15, 0) << 8) +
-					    GET_CAL_DATA_BITMASK(4, 31, 24);
-	cal_data->count_rc[MT8195_TS3_0] = (GET_CAL_DATA_BITMASK(9, 7, 0) << 16) +
-					    GET_CAL_DATA_BITMASK(8, 31, 16);
-	cal_data->count_rc[MT8195_TS4_0] = (GET_CAL_DATA_BITMASK(11, 15, 0) << 8) +
-					    GET_CAL_DATA_BITMASK(10, 31, 24);
-	cal_data->count_rc[MT8195_TS5_0] = GET_CAL_DATA_BITMASK(13, 23, 0);
-	cal_data->count_rc[MT8195_TS6_0] = GET_CAL_DATA_BITMASK(16, 23, 0);
-	cal_data->count_rc[MT8195_TS7_0] = GET_CAL_DATA_BITMASK(18, 31, 8);
-}
-
-static struct tc_settings mt8195_tc_settings[] = {
-	[0] = {
-		.domain_index = MT8195_MCU_DOMAIN,
-		.addr_offset = 0x0,
-		.num_sensor = 2,
-		.sensor_map = {MT8195_TS1_0, MT8195_TS1_1},
-		.tc_speed = SET_TC_SPEED_IN_US(118, 118, 118, 118),
-		.hw_filter = LVTS_FILTER_2_OF_4,
-		.dominator_sensing_point = SENSING_POINT1,
-		.hw_reboot_trip_point = 117000,
-		.irq_bit = BIT(3),
-	},
-	[1] = {
-		.domain_index = MT8195_MCU_DOMAIN,
-		.addr_offset = 0x100,
-		.num_sensor = 2,
-		.sensor_map = {MT8195_TS2_0, MT8195_TS2_1},
-		.tc_speed = SET_TC_SPEED_IN_US(118, 118, 118, 118),
-		.hw_filter = LVTS_FILTER_2_OF_4,
-		.dominator_sensing_point = SENSING_POINT0,
-		.hw_reboot_trip_point = 117000,
-		.irq_bit = BIT(4),
-	},
-	[2] = {
-		.domain_index = MT8195_MCU_DOMAIN,
-		.addr_offset = 0x200,
-		.num_sensor = 4,
-		.sensor_map = {MT8195_TS3_0, MT8195_TS3_1, MT8195_TS3_2, MT8195_TS3_3},
-		.tc_speed = SET_TC_SPEED_IN_US(118, 118, 118, 118),
-		.hw_filter = LVTS_FILTER_2_OF_4,
-		.dominator_sensing_point = SENSING_POINT0,
-		.hw_reboot_trip_point = 117000,
-		.irq_bit = BIT(5),
-	},
-	[3] = {
-		.domain_index = MT8195_AP_DOMAIN,
-		.addr_offset = 0x0,
-		.num_sensor = 2,
-		.sensor_map = {MT8195_TS4_0, MT8195_TS4_1},
-		.tc_speed = SET_TC_SPEED_IN_US(118, 118, 118, 118),
-		.hw_filter = LVTS_FILTER_2_OF_4,
-		.dominator_sensing_point = SENSING_POINT0,
-		.hw_reboot_trip_point = 117000,
-		.irq_bit = BIT(3),
-	},
-	[4] = {
-		.domain_index = MT8195_AP_DOMAIN,
-		.addr_offset = 0x100,
-		.num_sensor = 2,
-		.sensor_map = {MT8195_TS5_0, MT8195_TS5_1},
-		.tc_speed = SET_TC_SPEED_IN_US(118, 118, 118, 118),
-		.hw_filter = LVTS_FILTER_2_OF_4,
-		.dominator_sensing_point = SENSING_POINT1,
-		.hw_reboot_trip_point = 117000,
-		.irq_bit = BIT(4),
-	},
-	[5] = {
-		.domain_index = MT8195_AP_DOMAIN,
-		.addr_offset = 0x200,
-		.num_sensor = 3,
-		.sensor_map = {MT8195_TS6_0, MT8195_TS6_1, MT8195_TS6_2},
-		.tc_speed = SET_TC_SPEED_IN_US(118, 118, 118, 118),
-		.hw_filter = LVTS_FILTER_2_OF_4,
-		.dominator_sensing_point = SENSING_POINT1,
-		.hw_reboot_trip_point = 117000,
-		.irq_bit = BIT(5),
-	},
-	[6] = {
-		.domain_index = MT8195_AP_DOMAIN,
-		.addr_offset = 0x300,
-		.num_sensor = 2,
-		.sensor_map = {MT8195_TS7_0, MT8195_TS7_1},
-		.tc_speed = SET_TC_SPEED_IN_US(118, 118, 118, 118),
-		.hw_filter = LVTS_FILTER_2_OF_4,
-		.dominator_sensing_point = SENSING_POINT0,
-		.hw_reboot_trip_point = 117000,
-		.irq_bit = BIT(6),
-	}
-};
-
-static struct lvts_data mt8195_lvts_data = {
-	.num_domain = MT8195_NUM_DOMAIN,
-	.num_tc = MT8195_NUM_LVTS,
-	.tc = mt8195_tc_settings,
-	.num_sensor = MT8195_NUM_TS,
-	.ops = {
-		.efuse_to_cal_data = mt8195_efuse_to_cal_data,
-		.device_enable_and_init = mt8195_device_enable_and_init,
-		.device_enable_auto_rck = device_enable_auto_rck_v4,
-		.device_read_count_rc_n = device_read_count_rc_n_v4,
-		.set_cal_data = set_calibration_data_v4,
-		.init_controller = init_controller_v4,
-	},
-	.feature_bitmap = FEATURE_DEVICE_AUTO_RCK | FEATURE_CK26M_ACTIVE,
-	.num_efuse_addr = 22,
-	.num_efuse_block = 2,
-	.cal_data = {
-		.default_golden_temp = 50,
-		.default_count_r = 35000,
-		.default_count_rc = 2750,
-	},
-	.coeff = {
-		.a = -250460,
-		.b = 250460,
-	},
-};
-
-/*==================================================
- * LVTS MT8186
- *==================================================
- */
+	struct lvts_data *lvts_data;
 
-#define MT8186_NUM_LVTS (ARRAY_SIZE(mt8186_tc_settings))
-#define MT8186_TSBG_DEM_CKSEL_X_TSBG_CHOP_EN (DEVICE_WRITE | RG_TSV2F_CTRL_4 << 8 | 0xFC)
-#define MT8186_TSV2F_CHOP_CKSEL_AND_TSV2F_EN (DEVICE_WRITE | RG_TSV2F_CTRL_2 << 8 | 0xAC)
-#define MT8186_SET_TS_CHOP (DEVICE_WRITE | RG_TSV2F_CTRL_0 << 8 | 0xF7)
-#define MT8186_SET_TSV2F_RSV (DEVICE_WRITE | RG_TSV2F_CTRL_3 << 8 | 0x04)
+	lvts_data = (struct lvts_data *)platform_get_drvdata(pdev);
 
-enum mt8186_lvts_domain {
-	MT8186_AP_DOMAIN,
-	MT8186_NUM_DOMAIN
-};
+	lvts_close(lvts_data);
 
-enum mt8186_lvts_sensor_enum {
-	MT8186_TS1_0,
-	MT8186_TS1_1,
-	MT8186_TS1_2,
-	MT8186_TS1_3,
-	MT8186_TS3_0,
-	MT8186_TS3_1,
-	MT8186_TS3_2,
-	MT8186_TS2_0,
-	MT8186_TS2_1,
-	MT8186_NUM_TS
-};
+	return 0;
+}
 
-static void mt8186_device_enable_and_init(struct lvts_data *lvts_data)
+int lvts_suspend(struct platform_device *pdev, pm_message_t state)
 {
-	unsigned int i;
+	struct lvts_data *lvts_data;
 
-	for (i = 0; i < lvts_data->num_tc; i++) {
-		lvts_write_device(lvts_data, STOP_COUNTING_V4, i);
-		lvts_write_device(lvts_data, SET_COUNTING_WINDOW_20US2_V4, i);
-		lvts_write_device(lvts_data, SET_COUNTING_WINDOW_20US1_V4, i);
-		lvts_write_device(lvts_data, SET_RG_TSFM_LPDLY_V4, i);
-		lvts_write_device(lvts_data, MT8186_TSBG_DEM_CKSEL_X_TSBG_CHOP_EN, i);
-		lvts_write_device(lvts_data, MT8186_TSV2F_CHOP_CKSEL_AND_TSV2F_EN, i);
-		lvts_write_device(lvts_data, SET_TS_RSV_V4, i);
-		lvts_write_device(lvts_data, MT8186_SET_TS_CHOP, i);
-		lvts_write_device(lvts_data, MT8186_SET_TSV2F_RSV, i);
-	}
+	lvts_data = (struct lvts_data *)platform_get_drvdata(pdev);
 
-	lvts_data->counting_window_us = 20;
-}
+	lvts_close(lvts_data);
 
+	return 0;
+}
 
-static void mt8186_efuse_to_cal_data(struct lvts_data *lvts_data)
+int lvts_resume(struct platform_device *pdev)
 {
-	struct sensor_cal_data *cal_data = &lvts_data->cal_data;
-
-	cal_data->golden_temp = GET_CAL_DATA_BITMASK(0, 31, 24);
-	cal_data->count_r[MT8186_TS1_0] = GET_CAL_DATA_BITMASK(1, 31, 8);
-	cal_data->count_r[MT8186_TS1_1] = (GET_CAL_DATA_BITMASK(1, 7, 0) << 16) +
-						GET_CAL_DATA_BITMASK(2, 31, 16);
-	cal_data->count_r[MT8186_TS1_2] = (GET_CAL_DATA_BITMASK(2, 15, 0) << 8) +
-						GET_CAL_DATA_BITMASK(3, 31, 24);
-	cal_data->count_r[MT8186_TS1_3] = GET_CAL_DATA_BITMASK(3, 23, 0);
-
-	cal_data->count_r[MT8186_TS2_0] = (GET_CAL_DATA_BITMASK(4, 7, 0) << 16) +
-						GET_CAL_DATA_BITMASK(5, 31, 16);
-	cal_data->count_r[MT8186_TS2_1] = (GET_CAL_DATA_BITMASK(5, 15, 0) << 8) +
-						GET_CAL_DATA_BITMASK(6, 31, 24);
-
-	cal_data->count_r[MT8186_TS3_0] = GET_CAL_DATA_BITMASK(7, 31, 8);
-	cal_data->count_r[MT8186_TS3_1] = (GET_CAL_DATA_BITMASK(7, 7, 0) << 16) +
-						GET_CAL_DATA_BITMASK(8, 31, 16);
-	cal_data->count_r[MT8186_TS3_2] = (GET_CAL_DATA_BITMASK(8, 15, 0) << 8) +
-						GET_CAL_DATA_BITMASK(9, 31, 24);
-
-	cal_data->count_rc[MT8186_TS1_0] = GET_CAL_DATA_BITMASK(4, 31, 8);
-	cal_data->count_rc[MT8186_TS2_0] = GET_CAL_DATA_BITMASK(6, 23, 0);
-	cal_data->count_rc[MT8186_TS3_0] = GET_CAL_DATA_BITMASK(9, 23, 0);
-}
+	int ret;
+	struct lvts_data *lvts_data;
 
-static struct tc_settings mt8186_tc_settings[] = {
-	[0] = {
-		.domain_index = MT8186_AP_DOMAIN,
-		.addr_offset = 0x0,
-		.num_sensor = 4,
-		.sensor_map = {MT8186_TS1_0, MT8186_TS1_1, MT8186_TS1_2, MT8186_TS1_3},
-		.tc_speed = SET_TC_SPEED_IN_US(118, 118, 118, 118),
-		.hw_filter = LVTS_FILTER_2_OF_4,
-		.dominator_sensing_point = SENSING_POINT0,
-		.hw_reboot_trip_point = 105000,
-		.irq_bit = BIT(1),
-	},
-	[1] = {
-		.domain_index = MT8186_AP_DOMAIN,
-		.addr_offset = 0x100,
-		.num_sensor = 2,
-		.sensor_map = {MT8186_TS2_0, MT8186_TS2_1},
-		.tc_speed = SET_TC_SPEED_IN_US(118, 118, 118, 118),
-		.hw_filter = LVTS_FILTER_2_OF_4,
-		.dominator_sensing_point = SENSING_POINT0,
-		.hw_reboot_trip_point = 105000,
-		.irq_bit = BIT(2),
-	},
-	[2] = {
-		.domain_index = MT8186_AP_DOMAIN,
-		.addr_offset = 0x200,
-		.num_sensor = 3,
-		.sensor_map = {MT8186_TS3_0, MT8186_TS3_1, MT8186_TS3_2},
-		.tc_speed = SET_TC_SPEED_IN_US(118, 118, 118, 118),
-		.hw_filter = LVTS_FILTER_2_OF_4,
-		.dominator_sensing_point = SENSING_POINT0,
-		.hw_reboot_trip_point = 105000,
-		.irq_bit = BIT(3),
-	},
-};
+	lvts_data = (struct lvts_data *)platform_get_drvdata(pdev);
 
-static struct lvts_data mt8186_lvts_data = {
-	.num_domain = MT8186_NUM_DOMAIN,
-	.num_tc = MT8186_NUM_LVTS,
-	.tc = mt8186_tc_settings,
-	.num_sensor = MT8186_NUM_TS,
-	.ops = {
-		.efuse_to_cal_data = mt8186_efuse_to_cal_data,
-		.device_enable_and_init = mt8186_device_enable_and_init,
-		.device_enable_auto_rck = device_enable_auto_rck_v4,
-		.device_read_count_rc_n = device_read_count_rc_n_v4,
-		.set_cal_data = set_calibration_data_v4,
-		.init_controller = init_controller_v4,
-	},
-	.feature_bitmap = FEATURE_DEVICE_AUTO_RCK | FEATURE_CK26M_ACTIVE,
-	.num_efuse_addr = 10,
-	.num_efuse_block = 2,
-	.cal_data = {
-		.default_golden_temp = 50,
-		.default_count_r = 19000,
-		.default_count_rc = 5350,
-	},
-	.coeff = {
-		.a = -204650,
-		.b = 204650,
-	},
-};
+	ret = lvts_init(lvts_data);
+	if (ret)
+		return ret;
 
-/*
- *==================================================
- * Support chips
- *==================================================
- */
-static const struct of_device_id lvts_of_match[] = {
-	{
-		.compatible = "mediatek,mt6873-lvts",
-		.data = (void *)&mt6873_lvts_data,
-	},
-	{
-		.compatible = "mediatek,mt8195-lvts",
-		.data = (void *)&mt8195_lvts_data,
-	},
-	{
-		.compatible = "mediatek,mt8186-lvts",
-		.data = (void *)&mt8186_lvts_data,
-	},
-	{
-	},
-};
-MODULE_DEVICE_TABLE(of, lvts_of_match);
-
-static struct platform_driver soc_temp_lvts = {
-	.probe = lvts_probe,
-	.remove = lvts_remove,
-	.suspend = lvts_suspend,
-	.resume = lvts_resume,
-	.driver = {
-		.name = "mtk-soc-temp-lvts",
-		.of_match_table = lvts_of_match,
-	},
-};
+	return 0;
+}
 
-module_platform_driver(soc_temp_lvts);
 MODULE_AUTHOR("Yu-Chia Chang <ethan.chang@mediatek.com>");
 MODULE_AUTHOR("Michael Kao <michael.kao@mediatek.com>");
-MODULE_AUTHOR("Dawei Chien <dawei.chien@mediatek.com>");
-MODULE_DESCRIPTION("Mediatek soc temperature driver");
+MODULE_DESCRIPTION("MediaTek soc temperature driver");
 MODULE_LICENSE("GPL v2");
diff --git a/drivers/thermal/mediatek/soc_temp_lvts.h b/drivers/thermal/mediatek/soc_temp_lvts.h
index 1d90bdec53c6f1cd664fd5fcfe5cc4613bc2fed5..5ba2cf7e8c9e00c612fa655bfaa7108481b47aa6 100644
--- a/drivers/thermal/mediatek/soc_temp_lvts.h
+++ b/drivers/thermal/mediatek/soc_temp_lvts.h
@@ -1,12 +1,243 @@
-/* SPDX-License-Identifier: GPL-2.0 */
+// SPDX-License-Identifier: GPL-2.0-only
 /*
- * Copyright (c) 2020 MediaTek Inc.
+ * Copyright (c) 2022 MediaTek Inc.
  */
 
 #ifndef __MTK_SOC_TEMP_LVTS_H__
 #define __MTK_SOC_TEMP_LVTS_H__
 
-/* LVTS HW filter settings
+#define PERIOD_UNIT				12
+#define GROUP_INTERVAL_DELAY	1
+#define FILTER_INTERVAL_DELAY	1
+#define SENSOR_INTERVAL_DELAY	1
+
+#define HW_REBOOT_TRIP_POINT	117000
+
+#define FEATURE_DEVICE_AUTO_RCK	BIT(0)
+#define NUM_EFUSE_ADDR			22
+#define NUM_EFUSE_ADDR_MT8188		16
+#define NUM_EFUSE_BLOCK_MT8188	1
+#define NUM_EFUSE_BLOCK_MT8192	1
+#define NUM_EFUSE_BLOCK_MT8195	2
+#define DEFAULT_GOLDEN_TEMP		50
+#define DEFAULT_CUONT_R			35000
+#define DEFAULT_CUONT_RC		2750
+#define COEFF_A					-250460
+#define COEFF_B					250460
+
+#define CLOCK_26MHZ_CYCLE_NS	38
+#define BUS_ACCESS_US			2
+#define GOLDEN_TEMP_MAX			62
+
+/* LVTS device register */
+#define RG_TSFM_DATA_0			0x00
+#define RG_TSFM_DATA_1			0x01
+#define RG_TSFM_DATA_2			0x02
+#define RG_TSFM_CTRL_0			0x03
+#define RG_TSFM_CTRL_1			0x04
+#define RG_TSFM_CTRL_2			0x05
+#define RG_TSFM_CTRL_3			0x06
+#define RG_TSFM_CTRL_4			0x07
+#define RG_TSV2F_CTRL_0			0x08
+#define RG_TSV2F_CTRL_1			0x09
+#define RG_TSV2F_CTRL_2			0x0A
+#define RG_TSV2F_CTRL_3			0x0B
+#define RG_TSV2F_CTRL_4			0x0C
+#define RG_TSV2F_CTRL_5			0x0D
+#define RG_TSV2F_CTRL_6			0x0E
+#define RG_TEMP_DATA_0			0x10
+#define RG_TEMP_DATA_1			0x11
+#define RG_TEMP_DATA_2			0x12
+#define RG_TEMP_DATA_3			0x13
+#define RG_RC_DATA_0			0x14
+#define RG_RC_DATA_1			0x15
+#define RG_RC_DATA_2			0x16
+#define RG_RC_DATA_3			0x17
+#define RG_DIV_DATA_0			0x18
+#define RG_DIV_DATA_1			0x19
+#define RG_DIV_DATA_2			0x1A
+#define RG_DIV_DATA_3			0x1B
+#define RG_TST_DATA_0			0x70
+#define RG_TST_DATA_1			0x71
+#define RG_TST_DATA_2			0x72
+#define RG_TST_CTRL				0x73
+#define RG_DBG_FQMTR			0xF0
+#define RG_DBG_LPSEQ			0xF1
+#define RG_DBG_STATE			0xF2
+#define RG_DBG_CHKSUM			0xF3
+#define RG_DID_LVTS				0xFC
+#define RG_DID_REV				0xFD
+#define RG_TSFM_RST				0xFF
+
+/* LVTS controller register */
+#define LVTSMONCTL0_0				0x000
+#define ENABLE_SENSING_POINT(num)	(LVTS_SINGLE_SENSE | GENMASK(((num) - 1), 0))
+#define DISABLE_SENSING_POINT		(LVTS_SINGLE_SENSE | 0x0)
+#define LVTSMONCTL1_0				0x004
+#define LVTSMONCTL2_0				0x008
+#define LVTSMONINT_0				0x00C
+#define STAGE3_INT_EN				BIT(31)
+#define LVTSMONINTSTS_0				0x010
+#define LVTSMONIDET0_0				0x014
+#define LVTSMONIDET1_0				0x018
+#define LVTSMONIDET2_0				0x01C
+#define LVTSMONIDET3_0				0x020
+#define LVTSH2NTHRE_0				0x024
+#define LVTSHTHRE_0					0x028
+#define LVTSCTHRE_0					0x02C
+#define LVTSOFFSETH_0				0x030
+#define LVTSOFFSETL_0				0x034
+#define LVTSMSRCTL0_0				0x038
+#define LVTSMSRCTL1_0				0x03C
+#define LVTSTSSEL_0					0x040
+#define SET_SENSOR_INDEX			0x13121110
+#define LVTSDEVICETO_0				0x044
+#define LVTSCALSCALE_0				0x048
+#define SET_CALC_SCALE_RULES		0x00000300
+#define LVTS_ID_0					0x04C
+#define LVTS_CONFIG_0				0x050
+
+#define SCK_ONLY					BIT(31)
+#define BROADCAST_ID_UPDATE			BIT(26)
+#define DEVICE_SENSING_STATUS		BIT(25)
+#define DEVICE_ACCESS_STARTUS		BIT(24)
+#define READ_32BIT_ACCESS			BIT(17)
+#define WRITE_ACCESS				BIT(16)
+#define LVTS_SINGLE_SENSE			BIT(9)
+#define FEATURE_CK26M_ACTIVE		BIT(1)
+#define DEVICE_REG_DATA				GENMASK(7, 0)
+
+#define LVTSEDATA00_0				0x054
+#define LVTSEDATA01_0				0x058
+#define LVTSEDATA02_0				0x05C
+#define LVTSEDATA03_0				0x060
+#define LVTSMSR0_0					0x090
+#define MRS_RAW_MASK				GENMASK(15, 0)
+#define MRS_RAW_VALID_BIT			BIT(16)
+#define LVTSMSR1_0					0x094
+#define LVTSMSR2_0					0x098
+#define LVTSMSR3_0					0x09C
+#define LVTSIMMD0_0					0x0A0
+#define LVTSIMMD1_0					0x0A4
+#define LVTSIMMD2_0					0x0A8
+#define LVTSIMMD3_0					0x0AC
+#define LVTSRDATA0_0				0x0B0
+#define LVTSRDATA1_0				0x0B4
+#define LVTSRDATA2_0				0x0B8
+#define LVTSRDATA3_0				0x0BC
+#define LVTSPROTCTL_0				0x0C0
+#define PROTOFFSET					GENMASK(15, 0)
+#define LVTSPROTTA_0				0x0C4
+#define LVTSPROTTB_0				0x0C8
+#define LVTSPROTTC_0				0x0CC
+#define LVTSCLKEN_0					0x0E4
+#define ENABLE_LVTS_CTRL_CLK		(1)
+#define DISABLE_LVTS_CTRL_CLK		(0)
+#define LVTSDBGSEL_0				0x0E8
+#define LVTSDBGSIG_0				0x0EC
+#define LVTSSPARE0_0				0x0F0
+#define LVTSSPARE1_0				0x0F4
+#define LVTSSPARE2_0				0x0F8
+#define LVTSSPARE3_0				0x0FC
+#define THERMINTST					0xF04
+
+/* LVTS register mask */
+#define THERMAL_COLD_INTERRUPT_0			BIT(0)
+#define THERMAL_HOT_INTERRUPT_0				BIT(1)
+#define THERMAL_LOW_OFFSET_INTERRUPT_0		BIT(2)
+#define THERMAL_HIGH_OFFSET_INTERRUPT_0		BIT(3)
+#define THERMAL_HOT2NORMAL_INTERRUPT_0		BIT(4)
+#define THERMAL_COLD_INTERRUPT_1			BIT(5)
+#define THERMAL_HOT_INTERRUPT_1				BIT(6)
+#define THERMAL_LOW_OFFSET_INTERRUPT_1		BIT(7)
+#define THERMAL_HIGH_OFFSET_INTERRUPT_1		BIT(8)
+#define THERMAL_HOT2NORMAL_INTERRUPT_1		BIT(9)
+#define THERMAL_COLD_INTERRUPT_2			BIT(10)
+#define THERMAL_HOT_INTERRUPT_2				BIT(11)
+#define THERMAL_LOW_OFFSET_INTERRUPT_2		BIT(12)
+#define THERMAL_HIGH_OFFSET_INTERRUPT_2		BIT(13)
+#define THERMAL_HOT2NORMAL_INTERRUPT_2		BIT(14)
+#define THERMAL_AHB_TIMEOUT_INTERRUPT		BIT(15)
+#define THERMAL_DEVICE_TIMEOUT_INTERRUPT	BIT(15)
+#define THERMAL_IMMEDIATE_INTERRUPT_0		BIT(16)
+#define THERMAL_IMMEDIATE_INTERRUPT_1		BIT(17)
+#define THERMAL_IMMEDIATE_INTERRUPT_2		BIT(18)
+#define THERMAL_FILTER_INTERRUPT_0			BIT(19)
+#define THERMAL_FILTER_INTERRUPT_1			BIT(20)
+#define THERMAL_FILTER_INTERRUPT_2			BIT(21)
+#define THERMAL_COLD_INTERRUPT_3			BIT(22)
+#define THERMAL_HOT_INTERRUPT_3				BIT(23)
+#define THERMAL_LOW_OFFSET_INTERRUPT_3		BIT(24)
+#define THERMAL_HIGH_OFFSET_INTERRUPT_3		BIT(25)
+#define THERMAL_HOT2NORMAL_INTERRUPT_3		BIT(26)
+#define THERMAL_IMMEDIATE_INTERRUPT_3		BIT(27)
+#define THERMAL_FILTER_INTERRUPT_3			BIT(28)
+#define THERMAL_PROTECTION_STAGE_1			BIT(29)
+#define THERMAL_PROTECTION_STAGE_2			BIT(30)
+#define THERMAL_PROTECTION_STAGE_3			BIT(31)
+
+#define CFG_REGISTER(reg, value)	(reg << 8 | value)
+
+#define TSV2F_CHOP_CKSEL_AND_TSV2F_EN_V5	CFG_REGISTER(RG_TSV2F_CTRL_2, 0x8C)
+#define TSBG_DEM_CKSEL_X_TSBG_CHOP_EN_V5	CFG_REGISTER(RG_TSV2F_CTRL_4, 0xFC)
+#define SET_TS_CHOP_V5				CFG_REGISTER(RG_TSV2F_CTRL_0, 0xF1)
+
+#define STOP_COUNTING_V4					CFG_REGISTER(RG_TSFM_CTRL_0, 0x00)
+#define SET_RG_TSFM_LPDLY_V4				CFG_REGISTER(RG_TSFM_CTRL_4, 0xA6)
+#define SET_COUNTING_WINDOW_20US1_V4		CFG_REGISTER(RG_TSFM_CTRL_2, 0x00)
+#define SET_COUNTING_WINDOW_20US2_V4		CFG_REGISTER(RG_TSFM_CTRL_1, 0x20)
+#define TSV2F_CHOP_CKSEL_AND_TSV2F_EN_V4	CFG_REGISTER(RG_TSV2F_CTRL_2, 0x84)
+#define TSBG_DEM_CKSEL_X_TSBG_CHOP_EN_V4	CFG_REGISTER(RG_TSV2F_CTRL_4, 0x7C)
+#define SET_TS_RSV_V4						CFG_REGISTER(RG_TSV2F_CTRL_1, 0x8D)
+#define SET_TS_EN_V4						CFG_REGISTER(RG_TSV2F_CTRL_0, 0xF4)
+#define TOGGLE_RG_TSV2F_VCO_RST1_V4			CFG_REGISTER(RG_TSV2F_CTRL_0, 0xFC)
+#define TOGGLE_RG_TSV2F_VCO_RST2_V4			CFG_REGISTER(RG_TSV2F_CTRL_0, 0xF4)
+
+#define SET_LVTS_AUTO_RCK_V4				CFG_REGISTER(RG_TSV2F_CTRL_6, 0x01)
+#define SELECT_SENSOR_RCK_V4(id)			CFG_REGISTER(RG_TSV2F_CTRL_5, (id))
+#define SET_DEVICE_SINGLE_MODE_V4			CFG_REGISTER(RG_TSFM_CTRL_3, 0x78)
+#define KICK_OFF_RCK_COUNTING_V4			CFG_REGISTER(RG_TSFM_CTRL_0, 0x02)
+#define SET_SENSOR_NO_RCK_V4				CFG_REGISTER(RG_TSV2F_CTRL_5, 0x10)
+#define SET_DEVICE_LOW_POWER_SINGLE_MODE_V4	CFG_REGISTER(RG_TSFM_CTRL_3, 0xB8)
+
+#define HAS_FEATURE(lvts_data, feature)		(lvts_data->feature_bitmap & (feature))
+#define GET_BASE_ADDR(lvts_data, tc_id)		(lvts_data->base + lvts_data->tc[tc_id].addr_offset)
+#define GET_CAL_DATA_BITMASK(index, lvts_data, h, l)	(((index) < lvts_data->num_efuse_addr) \
+	? ((lvts_data->efuse[(index)] & GENMASK(h, l)) >> l) : 0)
+
+#define GET_TC_SENSOR_NUM(lvts_data, tc_id)		(lvts_data->tc[tc_id].num_sensor)
+#define ONE_SAMPLE		(lvts_data->counting_window_us + 2 * BUS_ACCESS_US)
+#define NUM_OF_SAMPLE(tc_id)	((lvts_data->tc[tc_id].hw_filter < LVTS_FILTER_2) ? 1 :	\
+	((lvts_data->tc[tc_id].hw_filter > LVTS_FILTER_16_OF_18) ? 1 :	\
+	((lvts_data->tc[tc_id].hw_filter == LVTS_FILTER_16_OF_18) ? 18 : \
+	((lvts_data->tc[tc_id].hw_filter == LVTS_FILTER_8_OF_10) ? 10 :	\
+	(lvts_data->tc[tc_id].hw_filter * 2)))))
+
+#define PERIOD_UNIT_US(tc_id)	((lvts_data->tc[tc_id].tc_speed->period_unit * 256 * \
+	CLOCK_26MHZ_CYCLE_NS) / 1000)
+#define FILTER_INT_US(tc_id)	(lvts_data->tc[tc_id].tc_speed->filter_interval_delay * \
+	PERIOD_UNIT_US(tc_id))
+#define SENSOR_INT_US(tc_id)	(lvts_data->tc[tc_id].tc_speed->sensor_interval_delay * \
+	PERIOD_UNIT_US(tc_id))
+#define GROUP_INT_US(tc_id)		(lvts_data->tc[tc_id].tc_speed->group_interval_delay * \
+	PERIOD_UNIT_US(tc_id))
+#define SENSOR_LATENCY_US(tc_id)	((NUM_OF_SAMPLE(tc_id) - 1) * FILTER_INT_US(tc_id) + \
+	NUM_OF_SAMPLE(tc_id) * ONE_SAMPLE)
+#define GROUP_LATENCY_US(tc_id)		(GET_TC_SENSOR_NUM(lvts_data, tc_id) * \
+	SENSOR_LATENCY_US(tc_id) + (GET_TC_SENSOR_NUM(lvts_data, tc_id) - 1) * SENSOR_INT_US(tc_id) + \
+	GROUP_INT_US(tc_id))
+
+#define CK26M_ACTIVE(lvts_data)	(((lvts_data->feature_bitmap & FEATURE_CK26M_ACTIVE) ? 1 : 0) << 30)
+#define DEVICE_ACCESS			(SCK_ONLY | DEVICE_ACCESS_STARTUS | READ_32BIT_ACCESS)
+#define DEVICE_READ				(CK26M_ACTIVE(lvts_data) | DEVICE_ACCESS)
+#define DEVICE_WRITE			(CK26M_ACTIVE(lvts_data) | DEVICE_ACCESS | WRITE_ACCESS)
+#define READ_BACK_DEVICE_ID		(CK26M_ACTIVE(lvts_data) | DEVICE_ACCESS | BROADCAST_ID_UPDATE | \
+	RG_DID_LVTS << 8)
+#define READ_DEVICE_REG(reg_idx)	(DEVICE_READ | (reg_idx) << 8 | 0x00)
+#define RESET_ALL_DEVICES			(DEVICE_WRITE | RG_TSFM_RST << 8 | 0xFF)
+
+/*
+ * LVTS HW filter settings
  * 000: Get one sample
  * 001: Get 2 samples and average them
  * 010: Get 4 samples, drop max and min, then average the rest of 2 samples
@@ -31,26 +262,35 @@ enum lvts_sensing_point {
 	ALL_SENSING_POINTS
 };
 
-/*==================================================
- * Data structure
- *==================================================
- */
 struct lvts_data;
 
-struct speed_settings {
+/**
+ * struct lvts_speed_settings - A structure to hold the data related to polling rate
+ * @period_unit: Period unit is a base for all interval delays
+ * @group_interval_delay:  Delay between different rounds
+ * @filter_interval_delay: Delay between two samples of the same sensor
+ * @sensor_interval_delay: Delay between two samples of differnet sensors
+ *
+ * Calculation is achieved with the following equations:
+ * For the period unit: (period_us * 1000) / (256 * clock_26mhz_cycle_ns)
+ * For the interval delays: delay / period_us
+ */
+struct lvts_speed_settings {
 	unsigned int period_unit;
 	unsigned int group_interval_delay;
 	unsigned int filter_interval_delay;
 	unsigned int sensor_interval_delay;
 };
 
-struct tc_settings {
-	unsigned int domain_index;
+struct lvts_tc_settings {
+	unsigned int dev_id;
 	unsigned int addr_offset;
 	unsigned int num_sensor;
-	unsigned int sensor_map[ALL_SENSING_POINTS]; /* In sensor ID */
-	struct speed_settings tc_speed;
-	/* HW filter setting
+	unsigned int ts_offset;
+	unsigned int sensor_map[ALL_SENSING_POINTS];	/* In sensor ID */
+	struct lvts_speed_settings *tc_speed;
+	/*
+	 * HW filter setting
 	 * 000: Get one sample
 	 * 001: Get 2 samples and average them
 	 * 010: Get 4 samples, drop max and min, then average the rest of 2 samples
@@ -59,28 +299,28 @@ struct tc_settings {
 	 * 101: Get 18 samples, drop max and min, then average the rest of 16 samples
 	 */
 	unsigned int hw_filter;
-	/* Dominator_sensing point is used to select a sensing point
+	/*
+	 * Dominator_sensing point is used to select a sensing point
 	 * and reference its temperature to trigger Thermal HW Reboot
 	 * When it is ALL_SENSING_POINTS, it will select all sensing points
 	 */
 	int dominator_sensing_point;
-	int hw_reboot_trip_point; /* -274000: Disable HW reboot */
+	int hw_reboot_trip_point;		/* -274000: Disable HW reboot */
 	unsigned int irq_bit;
 };
 
-struct formula_coeff {
+struct lvts_formula_coeff {
 	int a;
 	int b;
 	unsigned int golden_temp;
 };
 
-struct sensor_cal_data {
-	int use_fake_efuse;	/* 1: Use fake efuse, 0: Use real efuse */
+struct lvts_sensor_cal_data {
+	int use_fake_efuse;				/* 1: Use fake efuse, 0: Use real efuse */
 	unsigned int golden_temp;
 	unsigned int *count_r;
 	unsigned int *count_rc;
 	unsigned int *count_rc_now;
-
 	unsigned int default_golden_temp;
 	unsigned int default_count_r;
 	unsigned int default_count_rc;
@@ -95,218 +335,41 @@ struct platform_ops {
 	void (*init_controller)(struct lvts_data *lvts_data);
 };
 
-struct power_domain {
-	void __iomem *base;	/* LVTS base addresses */
-	unsigned int irq_num;	/* LVTS interrupt numbers */
-	struct reset_control *reset;
-};
-
-struct sensor_data {
-	int temp;		/* Current temperature */
-	unsigned int msr_raw;	/* MSR raw data from LVTS */
-};
-
 struct lvts_data {
 	struct device *dev;
 	struct clk *clk;
-	unsigned int num_domain;
-	struct power_domain *domain;
-
-	int num_tc;			/* Number of LVTS thermal controllers */
-	struct tc_settings *tc;
-	int counting_window_us;		/* LVTS device counting window */
-
-	int num_sensor;			/* Number of sensors in this platform */
-	struct sensor_data *sen_data;
-
+	void __iomem *base;				/* LVTS base addresses */
+	unsigned int irq_num;			/* LVTS interrupt numbers */
+	struct reset_control *reset;
+	int num_tc;						/* Number of LVTS thermal controllers */
+	const struct lvts_tc_settings *tc;
+	int counting_window_us;			/* LVTS device counting window */
+	int num_sensor;					/* Number of sensors in this platform */
+	void __iomem **reg;
 	struct platform_ops ops;
-	int feature_bitmap;		/* Show what features are enabled */
-
+	int feature_bitmap;				/* Show what features are enabled */
 	unsigned int num_efuse_addr;
 	unsigned int *efuse;
 	unsigned int num_efuse_block;	/* Number of contiguous efuse indexes */
-	struct sensor_cal_data cal_data;
-	struct formula_coeff coeff;
+	struct lvts_sensor_cal_data cal_data;
+	struct lvts_formula_coeff coeff;
 };
 
 struct soc_temp_tz {
-	unsigned int id; /* if id is 0, get max temperature of all sensors */
-	struct lvts_data *lvts_data;
-};
-
-struct match_entry {
-	char	chip[32];
+	unsigned int id;
 	struct lvts_data *lvts_data;
 };
 
-struct lvts_match_data {
-	unsigned int hw_version;
-	struct match_entry *table;
-	void (*set_up_common_callbacks)(struct lvts_data *lvts_data);
-	struct list_head node;
-};
+extern void lvts_device_enable_and_init_v5(struct lvts_data *lvts_data);
+extern void lvts_device_enable_and_init_v4(struct lvts_data *lvts_data);
+extern void lvts_device_enable_auto_rck_v4(struct lvts_data *lvts_data);
+extern int lvts_device_read_count_rc_n_v4(struct lvts_data *lvts_data);
+extern void lvts_set_calibration_data_v4(struct lvts_data *lvts_data);
+extern void lvts_init_controller_v4(struct lvts_data *lvts_data);
 
-struct lvts_id {
-	unsigned int hw_version;
-	char	chip[32];
-};
+extern int lvts_probe(struct platform_device *pdev);
+extern int lvts_remove(struct platform_device *pdev);
+extern int lvts_suspend(struct platform_device *pdev, pm_message_t state);
+extern int lvts_resume(struct platform_device *pdev);
 
-/*==================================================
- * LVTS device register
- *==================================================
- */
-#define RG_TSFM_DATA_0	0x00
-#define RG_TSFM_DATA_1	0x01
-#define RG_TSFM_DATA_2	0x02
-#define RG_TSFM_CTRL_0	0x03
-#define RG_TSFM_CTRL_1	0x04
-#define RG_TSFM_CTRL_2	0x05
-#define RG_TSFM_CTRL_3	0x06
-#define RG_TSFM_CTRL_4	0x07
-#define RG_TSV2F_CTRL_0	0x08
-#define RG_TSV2F_CTRL_1	0x09
-#define RG_TSV2F_CTRL_2	0x0A
-#define RG_TSV2F_CTRL_3	0x0B
-#define RG_TSV2F_CTRL_4	0x0C
-#define RG_TSV2F_CTRL_5	0x0D
-#define RG_TSV2F_CTRL_6	0x0E
-#define RG_TEMP_DATA_0	0x10
-#define RG_TEMP_DATA_1	0x11
-#define RG_TEMP_DATA_2	0x12
-#define RG_TEMP_DATA_3	0x13
-#define RG_RC_DATA_0	0x14
-#define RG_RC_DATA_1	0x15
-#define RG_RC_DATA_2	0x16
-#define RG_RC_DATA_3	0x17
-#define RG_DIV_DATA_0	0x18
-#define RG_DIV_DATA_1	0x19
-#define RG_DIV_DATA_2	0x1A
-#define RG_DIV_DATA_3	0x1B
-#define RG_TST_DATA_0	0x70
-#define RG_TST_DATA_1	0x71
-#define RG_TST_DATA_2	0x72
-#define RG_TST_CTRL	0x73
-#define RG_DBG_FQMTR	0xF0
-#define RG_DBG_LPSEQ	0xF1
-#define RG_DBG_STATE	0xF2
-#define RG_DBG_CHKSUM	0xF3
-#define RG_DID_LVTS	0xFC
-#define RG_DID_REV	0xFD
-#define RG_TSFM_RST	0xFF
-/*==================================================
- * LVTS controller register
- *==================================================
- */
-#define LVTSMONCTL0_0	0x000
-#define LVTS_SINGLE_SENSE	BIT(9)
-#define ENABLE_SENSING_POINT(num)	(LVTS_SINGLE_SENSE | GENMASK(((num) - 1), 0))
-#define DISABLE_SENSING_POINT	(LVTS_SINGLE_SENSE | 0x0)
-#define LVTSMONCTL1_0	0x004
-#define LVTSMONCTL2_0	0x008
-#define LVTSMONINT_0	0x00C
-#define STAGE3_INT_EN	BIT(31)
-#define LVTSMONINTSTS_0	0x010
-#define LVTSMONIDET0_0	0x014
-#define LVTSMONIDET1_0	0x018
-#define LVTSMONIDET2_0	0x01C
-#define LVTSMONIDET3_0	0x020
-#define LVTSH2NTHRE_0	0x024
-#define LVTSHTHRE_0	0x028
-#define LVTSCTHRE_0	0x02C
-#define LVTSOFFSETH_0	0x030
-#define LVTSOFFSETL_0	0x034
-#define LVTSMSRCTL0_0	0x038
-#define LVTSMSRCTL1_0	0x03C
-#define LVTSTSSEL_0	0x040
-#define SET_SENSOR_INDEX	0x13121110
-#define LVTSDEVICETO_0	0x044
-#define LVTSCALSCALE_0	0x048
-#define SET_CALC_SCALE_RULES	0x00000300
-#define LVTS_ID_0	0x04C
-#define LVTS_CONFIG_0	0x050
-
-#define BROADCAST_ID_UPDATE	BIT(26)
-#define DEVICE_SENSING_STATUS	BIT(25)
-#define DEVICE_ACCESS_STARTUS	BIT(24)
-#define WRITE_ACCESS		BIT(16)
-#define DEVICE_WRITE		(BIT(31) | CK26M_ACTIVE | DEVICE_ACCESS_STARTUS \
-				| BIT(17) | WRITE_ACCESS)
-#define DEVICE_READ		(BIT(31) | CK26M_ACTIVE | DEVICE_ACCESS_STARTUS \
-				| 1 << 17)
-#define RESET_ALL_DEVICES	(DEVICE_WRITE | RG_TSFM_RST << 8 | 0xFF)
-#define READ_BACK_DEVICE_ID	(BIT(31) | CK26M_ACTIVE | BROADCAST_ID_UPDATE	\
-				| DEVICE_ACCESS_STARTUS | BIT(17)	\
-				| RG_DID_LVTS << 8)
-#define READ_DEVICE_REG(reg_idx)	(DEVICE_READ | (reg_idx) << 8 | 0x00)
-#define LVTSEDATA00_0	0x054
-#define LVTSEDATA01_0	0x058
-#define LVTSEDATA02_0	0x05C
-#define LVTSEDATA03_0	0x060
-#define LVTSMSR0_0	0x090
-#define MRS_RAW_MASK		GENMASK(15, 0)
-#define MRS_RAW_VALID_BIT	BIT(16)
-#define LVTSMSR1_0	0x094
-#define LVTSMSR2_0	0x098
-#define LVTSMSR3_0	0x09C
-#define LVTSIMMD0_0	0x0A0
-#define LVTSIMMD1_0	0x0A4
-#define LVTSIMMD2_0	0x0A8
-#define LVTSIMMD3_0	0x0AC
-#define LVTSRDATA0_0	0x0B0
-#define LVTSRDATA1_0	0x0B4
-#define LVTSRDATA2_0	0x0B8
-#define LVTSRDATA3_0	0x0BC
-#define LVTSPROTCTL_0	0x0C0
-#define PROTOFFSET	GENMASK(15, 0)
-#define LVTSPROTTA_0	0x0C4
-#define LVTSPROTTB_0	0x0C8
-#define LVTSPROTTC_0	0x0CC
-#define LVTSCLKEN_0	0x0E4
-#define ENABLE_LVTS_CTRL_CLK	(1)
-#define DISABLE_LVTS_CTRL_CLK	(0)
-#define LVTSDBGSEL_0	0x0E8
-#define LVTSDBGSIG_0	0x0EC
-#define LVTSSPARE0_0	0x0F0
-#define LVTSSPARE1_0	0x0F4
-#define LVTSSPARE2_0	0x0F8
-#define LVTSSPARE3_0	0x0FC
-
-#define THERMINTST	0xF04
-/*==================================================
- * LVTS register mask
- *==================================================
- */
-#define THERMAL_COLD_INTERRUPT_0		0x00000001
-#define THERMAL_HOT_INTERRUPT_0			0x00000002
-#define THERMAL_LOW_OFFSET_INTERRUPT_0		0x00000004
-#define THERMAL_HIGH_OFFSET_INTERRUPT_0		0x00000008
-#define THERMAL_HOT2NORMAL_INTERRUPT_0		0x00000010
-#define THERMAL_COLD_INTERRUPT_1		0x00000020
-#define THERMAL_HOT_INTERRUPT_1			0x00000040
-#define THERMAL_LOW_OFFSET_INTERRUPT_1		0x00000080
-#define THERMAL_HIGH_OFFSET_INTERRUPT_1		0x00000100
-#define THERMAL_HOT2NORMAL_INTERRUPT_1		0x00000200
-#define THERMAL_COLD_INTERRUPT_2		0x00000400
-#define THERMAL_HOT_INTERRUPT_2			0x00000800
-#define THERMAL_LOW_OFFSET_INTERRUPT_2		0x00001000
-#define THERMAL_HIGH_OFFSET_INTERRUPT_2		0x00002000
-#define THERMAL_HOT2NORMAL_INTERRUPT_2		0x00004000
-#define THERMAL_AHB_TIMEOUT_INTERRUPT		0x00008000
-#define THERMAL_DEVICE_TIMEOUT_INTERRUPT	0x00008000
-#define THERMAL_IMMEDIATE_INTERRUPT_0		0x00010000
-#define THERMAL_IMMEDIATE_INTERRUPT_1		0x00020000
-#define THERMAL_IMMEDIATE_INTERRUPT_2		0x00040000
-#define THERMAL_FILTER_INTERRUPT_0		0x00080000
-#define THERMAL_FILTER_INTERRUPT_1		0x00100000
-#define THERMAL_FILTER_INTERRUPT_2		0x00200000
-#define THERMAL_COLD_INTERRUPT_3		0x00400000
-#define THERMAL_HOT_INTERRUPT_3			0x00800000
-#define THERMAL_LOW_OFFSET_INTERRUPT_3		0x01000000
-#define THERMAL_HIGH_OFFSET_INTERRUPT_3		0x02000000
-#define THERMAL_HOT2NORMAL_INTERRUPT_3		0x04000000
-#define THERMAL_IMMEDIATE_INTERRUPT_3		0x08000000
-#define THERMAL_FILTER_INTERRUPT_3		0x10000000
-#define THERMAL_PROTECTION_STAGE_1		0x20000000
-#define THERMAL_PROTECTION_STAGE_2		0x40000000
-#define THERMAL_PROTECTION_STAGE_3		0x80000000
 #endif /* __MTK_SOC_TEMP_LVTS_H__ */
diff --git a/drivers/thermal/mediatek/virtual_temp.c b/drivers/thermal/mediatek/virtual_temp.c
new file mode 100644
index 0000000000000000000000000000000000000000..62fd89dc57b19035661ed52bbdde4b8b0615948a
--- /dev/null
+++ b/drivers/thermal/mediatek/virtual_temp.c
@@ -0,0 +1,148 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2021 MediaTek Inc.
+ */
+#include <linux/bits.h>
+#include <linux/device.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_platform.h>
+#include <linux/regmap.h>
+#include <linux/slab.h>
+#include <linux/thermal.h>
+
+struct thermal_zone_device *tzd_cpu_little1;
+struct thermal_zone_device *tzd_cpu_little2;
+struct thermal_zone_device *tzd_cpu_little3;
+struct thermal_zone_device *tzd_cpu_little4;
+struct thermal_zone_device *tzd_cpu_big0;
+struct thermal_zone_device *tzd_cpu_big1;
+struct thermal_zone_device *tzd_apu;
+struct thermal_zone_device *tzd_gpu1;
+struct thermal_zone_device *tzd_gpu2;
+struct thermal_zone_device *tzd_soc1;
+struct thermal_zone_device *tzd_soc2;
+struct thermal_zone_device *tzd_soc3;
+struct thermal_zone_device *tzd_cam1;
+struct thermal_zone_device *tzd_cam2;
+
+static int vtemp_get_temp(struct thermal_zone_device *tz, int *temp)
+{
+	int tz_temp0=0;
+	int tz_temp_max=0;
+
+	thermal_zone_get_temp(tzd_cpu_little1, &tz_temp0);
+	if(tz_temp0 > tz_temp_max)
+		tz_temp_max = tz_temp0;
+
+	thermal_zone_get_temp(tzd_cpu_little2, &tz_temp0);
+	if(tz_temp0 > tz_temp_max)
+		tz_temp_max = tz_temp0;
+
+	thermal_zone_get_temp(tzd_cpu_little3, &tz_temp0);
+	if(tz_temp0 > tz_temp_max)
+		tz_temp_max = tz_temp0;
+
+	thermal_zone_get_temp(tzd_cpu_little4, &tz_temp0);
+	if(tz_temp0 > tz_temp_max)
+		tz_temp_max = tz_temp0;
+
+	thermal_zone_get_temp(tzd_cpu_big0, &tz_temp0);
+	if(tz_temp0 > tz_temp_max)
+		tz_temp_max = tz_temp0;
+
+	thermal_zone_get_temp(tzd_cpu_big1, &tz_temp0);
+	if(tz_temp0 > tz_temp_max)
+		tz_temp_max = tz_temp0;
+
+	thermal_zone_get_temp(tzd_apu, &tz_temp0);
+	if(tz_temp0 > tz_temp_max)
+		tz_temp_max = tz_temp0;
+
+	thermal_zone_get_temp(tzd_gpu1, &tz_temp0);
+	if(tz_temp0 > tz_temp_max)
+		tz_temp_max = tz_temp0;
+
+	thermal_zone_get_temp(tzd_gpu2, &tz_temp0);
+	if(tz_temp0 > tz_temp_max)
+		tz_temp_max = tz_temp0;
+
+	thermal_zone_get_temp(tzd_soc1, &tz_temp0);
+	if(tz_temp0 > tz_temp_max)
+		tz_temp_max = tz_temp0;
+
+	thermal_zone_get_temp(tzd_soc2, &tz_temp0);
+	if(tz_temp0 > tz_temp_max)
+		tz_temp_max = tz_temp0;
+
+	thermal_zone_get_temp(tzd_soc3, &tz_temp0);
+	if(tz_temp0 > tz_temp_max)
+		tz_temp_max = tz_temp0;
+
+	thermal_zone_get_temp(tzd_cam1, &tz_temp0);
+	if(tz_temp0 > tz_temp_max)
+		tz_temp_max = tz_temp0;
+
+	thermal_zone_get_temp(tzd_cam2, &tz_temp0);
+	if(tz_temp0 > tz_temp_max)
+		tz_temp_max = tz_temp0;
+
+	*temp = tz_temp_max;
+
+	/* printk("[thermal_zone_get_temp] *temp:%d\n", *temp); */
+
+	return 0;
+}
+
+static const struct thermal_zone_device_ops vtemp_ops = {
+	.get_temp = vtemp_get_temp,
+};
+
+static int vtemp_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct thermal_zone_device *tzdev;
+
+	tzd_cpu_little1 = thermal_zone_get_zone_by_name("cpu_little1");
+	tzd_cpu_little2 = thermal_zone_get_zone_by_name("cpu_little2");
+	tzd_cpu_little3 = thermal_zone_get_zone_by_name("cpu_little3");
+	tzd_cpu_little4 = thermal_zone_get_zone_by_name("cpu_little4");
+	tzd_cpu_big0 = thermal_zone_get_zone_by_name("cpu_big0");
+	tzd_cpu_big1 = thermal_zone_get_zone_by_name("cpu_big1");
+	tzd_apu = thermal_zone_get_zone_by_name("apu");
+	tzd_gpu1 = thermal_zone_get_zone_by_name("gpu1");
+	tzd_gpu2 = thermal_zone_get_zone_by_name("gpu2");
+	tzd_soc1 = thermal_zone_get_zone_by_name("soc1");
+	tzd_soc2 = thermal_zone_get_zone_by_name("soc2");
+	tzd_soc3 = thermal_zone_get_zone_by_name("soc3");
+	tzd_cam1 = thermal_zone_get_zone_by_name("cam1");
+	tzd_cam2 = thermal_zone_get_zone_by_name("cam2");
+
+	tzdev = devm_thermal_of_zone_register(dev, 0,
+			NULL, &vtemp_ops);
+	return 0;
+}
+
+static const struct of_device_id vtemp_of_match[] = {
+	{
+		.compatible = "mediatek,virtual-temp",
+	},
+	{},
+};
+MODULE_DEVICE_TABLE(of, vtemp_of_match);
+
+static struct platform_driver vtemp_driver = {
+	.probe = vtemp_probe,
+	.driver = {
+		.name = "mtk-virtual-temp",
+		.of_match_table = vtemp_of_match,
+	},
+};
+
+module_platform_driver(vtemp_driver);
+
+MODULE_AUTHOR("Example");
+MODULE_DESCRIPTION("Example on virtual temp driver");
+MODULE_LICENSE("GPL v2");
diff --git a/include/drm/drm_mipi_dsi.h b/include/drm/drm_mipi_dsi.h
index 16f30975b22b47829ffa4483e4a00411ab08d62a..69bc1cf5f45368129fee2b71c58e63d8ca3502db 100644
--- a/include/drm/drm_mipi_dsi.h
+++ b/include/drm/drm_mipi_dsi.h
@@ -193,6 +193,7 @@ struct mipi_dsi_device {
 	unsigned long hs_rate;
 	unsigned long lp_rate;
 	struct drm_dsc_config *dsc;
+	unsigned int vdo_per_frame_lp_enable;
 };
 
 #define MIPI_DSI_MODULE_PREFIX "mipi-dsi:"
diff --git a/include/dt-bindings/gce/mt8188-gce.h b/include/dt-bindings/gce/mt8188-gce.h
new file mode 100644
index 0000000000000000000000000000000000000000..9d2f72ced56faf6d546be7e10e09c9fddfdb7552
--- /dev/null
+++ b/include/dt-bindings/gce/mt8188-gce.h
@@ -0,0 +1,1079 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2018 MediaTek Inc.
+ *
+ */
+#ifndef _DT_BINDINGS_GCE_MT8188_H
+#define _DT_BINDINGS_GCE_MT8188_H
+
+/* assign timeout 0 also means default */
+#define CMDQ_NO_TIMEOUT		0xffffffff
+#define CMDQ_TIMEOUT_DEFAULT	1000
+
+/* GCE thread priority */
+#define CMDQ_THR_PRIO_LOWEST	0
+#define CMDQ_THR_PRIO_1		1
+#define CMDQ_THR_PRIO_2		2
+#define CMDQ_THR_PRIO_3		3
+#define CMDQ_THR_PRIO_4		4
+#define CMDQ_THR_PRIO_5		5
+#define CMDQ_THR_PRIO_6		6
+#define CMDQ_THR_PRIO_HIGHEST	7
+
+/* CPR count in 32bit register */
+#define GCE_CPR_COUNT		1312
+
+/* GCE subsys table */
+#define SUBSYS_1400XXXX		0
+#define SUBSYS_1401XXXX		1
+#define SUBSYS_1402XXXX		2
+#define SUBSYS_1c00XXXX		3
+#define SUBSYS_1c01XXXX		4
+#define SUBSYS_1c02XXXX		5
+#define SUBSYS_1c10XXXX		6
+#define SUBSYS_1c11XXXX		7
+#define SUBSYS_1c12XXXX		8
+#define SUBSYS_14f0XXXX		9
+#define SUBSYS_14f1XXXX		10
+#define SUBSYS_14f2XXXX		11
+#define SUBSYS_1800XXXX		12
+#define SUBSYS_1801XXXX		13
+#define SUBSYS_1802XXXX		14
+#define SUBSYS_1803XXXX		15
+#define SUBSYS_1032XXXX		16
+#define SUBSYS_1033XXXX		17
+#define SUBSYS_1600XXXX		18
+#define SUBSYS_1601XXXX		19
+#define SUBSYS_14e0XXXX		20
+#define SUBSYS_1c20XXXX		21
+#define SUBSYS_1c30XXXX		22
+#define SUBSYS_1c40XXXX		23
+#define SUBSYS_1c50XXXX		24
+#define SUBSYS_1c60XXXX		25
+#define SUBSYS_NO_SUPPORT	99
+
+/* GCE General Purpose Register (GPR) support
+ * Leave note for scenario usage here
+ */
+/* GCE: write mask */
+#define GCE_GPR_R00		0x00
+#define GCE_GPR_R01		0x01
+/* MDP: P1: JPEG dest */
+#define GCE_GPR_R02		0x02
+#define GCE_GPR_R03		0x03
+/* MDP: PQ color */
+#define GCE_GPR_R04		0x04
+/* MDP:2D sharpness */
+#define GCE_GPR_R05		0x05
+/* DISP: poll esd */
+#define GCE_GPR_R06		0x06
+#define GCE_GPR_R07		0x07
+/* MDP: P4: 2D sharpness dst */
+#define GCE_GPR_R08		0x08
+#define GCE_GPR_R09		0x09
+/* VCU: poll with timeout for GPR timer */
+#define GCE_GPR_R10		0x0A
+#define GCE_GPR_R11		0x0B
+/* CMDQ: debug */
+#define GCE_GPR_R12		0x0C
+#define GCE_GPR_R13		0x0D
+/* CMDQ: P7: debug */
+#define GCE_GPR_R14		0x0E
+#define GCE_GPR_R15		0x0F
+
+#define CMDQ_EVENT_IMG_SOF		0
+#define CMDQ_EVENT_IMG_TRAW0_CQ_THR_DONE_0	1
+#define CMDQ_EVENT_IMG_TRAW0_CQ_THR_DONE_1	2
+#define CMDQ_EVENT_IMG_TRAW0_CQ_THR_DONE_2	3
+#define CMDQ_EVENT_IMG_TRAW0_CQ_THR_DONE_3	4
+#define CMDQ_EVENT_IMG_TRAW0_CQ_THR_DONE_4	5
+#define CMDQ_EVENT_IMG_TRAW0_CQ_THR_DONE_5	6
+#define CMDQ_EVENT_IMG_TRAW0_CQ_THR_DONE_6	7
+#define CMDQ_EVENT_IMG_TRAW0_CQ_THR_DONE_7	8
+#define CMDQ_EVENT_IMG_TRAW0_CQ_THR_DONE_8	9
+#define CMDQ_EVENT_IMG_TRAW0_CQ_THR_DONE_9	10
+#define CMDQ_EVENT_IMG_TRAW0_DMA_ERROR_INT	11
+#define CMDQ_EVENT_IMG_TRAW1_CQ_THR_DONE_0	12
+#define CMDQ_EVENT_IMG_TRAW1_CQ_THR_DONE_1	13
+#define CMDQ_EVENT_IMG_TRAW1_CQ_THR_DONE_2	14
+#define CMDQ_EVENT_IMG_TRAW1_CQ_THR_DONE_3	15
+#define CMDQ_EVENT_IMG_TRAW1_CQ_THR_DONE_4	16
+#define CMDQ_EVENT_IMG_TRAW1_CQ_THR_DONE_5	17
+#define CMDQ_EVENT_IMG_TRAW1_CQ_THR_DONE_6	18
+#define CMDQ_EVENT_IMG_TRAW1_CQ_THR_DONE_7	19
+#define CMDQ_EVENT_IMG_TRAW1_CQ_THR_DONE_8	20
+#define CMDQ_EVENT_IMG_TRAW1_CQ_THR_DONE_9	21
+#define CMDQ_EVENT_IMG_TRAW1_DMA_ERROR_INT	22
+#define CMDQ_EVENT_IMG_ADL_RESERVED			23
+#define CMDQ_EVENT_IMG_DIP_CQ_THR_DONE_0	24
+#define CMDQ_EVENT_IMG_DIP_CQ_THR_DONE_1	25
+#define CMDQ_EVENT_IMG_DIP_CQ_THR_DONE_2	26
+#define CMDQ_EVENT_IMG_DIP_CQ_THR_DONE_3	27
+#define CMDQ_EVENT_IMG_DIP_CQ_THR_DONE_4	28
+#define CMDQ_EVENT_IMG_DIP_CQ_THR_DONE_5	29
+#define CMDQ_EVENT_IMG_DIP_CQ_THR_DONE_6	30
+#define CMDQ_EVENT_IMG_DIP_CQ_THR_DONE_7	31
+#define CMDQ_EVENT_IMG_DIP_CQ_THR_DONE_8	32
+#define CMDQ_EVENT_IMG_DIP_CQ_THR_DONE_9	33
+#define CMDQ_EVENT_IMG_DIP_DMA_ERR	34
+#define CMDQ_EVENT_IMG_DIP_NR_DMA_ERR		35
+#define CMDQ_EVENT_DIP_DUMMY_0				36
+#define CMDQ_EVENT_DIP_DUMMY_1				37
+#define CMDQ_EVENT_DIP_DUMMY_2				38
+#define CMDQ_EVENT_IMG_WPE_EIS_GCE_FRAME_DONE	39
+#define CMDQ_EVENT_IMG_WPE_EIS_DONE_SYNC_OUT	40
+#define CMDQ_EVENT_IMG_WPE_EIS_CQ_THR_DONE_0	41
+#define CMDQ_EVENT_IMG_WPE_EIS_CQ_THR_DONE_1	42
+#define CMDQ_EVENT_IMG_WPE_EIS_CQ_THR_DONE_2	43
+#define CMDQ_EVENT_IMG_WPE_EIS_CQ_THR_DONE_3	44
+#define CMDQ_EVENT_IMG_WPE_EIS_CQ_THR_DONE_4	45
+#define CMDQ_EVENT_IMG_WPE_EIS_CQ_THR_DONE_5	46
+#define CMDQ_EVENT_IMG_WPE_EIS_CQ_THR_DONE_6	47
+#define CMDQ_EVENT_IMG_WPE_EIS_CQ_THR_DONE_7	48
+#define CMDQ_EVENT_IMG_WPE_EIS_CQ_THR_DONE_8	49
+#define CMDQ_EVENT_IMG_WPE_EIS_CQ_THR_DONE_9	50
+#define CMDQ_EVENT_IMG_PQDIP_A_CQ_THR_DONE_0	51
+#define CMDQ_EVENT_IMG_PQDIP_A_CQ_THR_DONE_1	52
+#define CMDQ_EVENT_IMG_PQDIP_A_CQ_THR_DONE_2	53
+#define CMDQ_EVENT_IMG_PQDIP_A_CQ_THR_DONE_3	54
+#define CMDQ_EVENT_IMG_PQDIP_A_CQ_THR_DONE_4	55
+#define CMDQ_EVENT_IMG_PQDIP_A_CQ_THR_DONE_5	56
+#define CMDQ_EVENT_IMG_PQDIP_A_CQ_THR_DONE_6	57
+#define CMDQ_EVENT_IMG_PQDIP_A_CQ_THR_DONE_7	58
+#define CMDQ_EVENT_IMG_PQDIP_A_CQ_THR_DONE_8	59
+#define CMDQ_EVENT_IMG_PQDIP_A_CQ_THR_DONE_9	60
+#define CMDQ_EVENT_IMG_PQDIP_A_DMA_ERR	61
+#define CMDQ_EVENT_WPE0_DUMMY_0			62
+#define CMDQ_EVENT_WPE0_DUMMY_1			63
+#define CMDQ_EVENT_WPE0_DUMMY_2			64
+#define CMDQ_EVENT_IMG_WPE_TNR_GCE_FRAME_DONE	65
+#define CMDQ_EVENT_IMG_WPE_TNR_DONE_SYNC_OUT	66
+#define CMDQ_EVENT_IMG_WPE_TNR_CQ_THR_DONE_0	67
+#define CMDQ_EVENT_IMG_WPE_TNR_CQ_THR_DONE_1	68
+#define CMDQ_EVENT_IMG_WPE_TNR_CQ_THR_DONE_2	69
+#define CMDQ_EVENT_IMG_WPE_TNR_CQ_THR_DONE_3	70
+#define CMDQ_EVENT_IMG_WPE_TNR_CQ_THR_DONE_4	71
+#define CMDQ_EVENT_IMG_WPE_TNR_CQ_THR_DONE_5	72
+#define CMDQ_EVENT_IMG_WPE_TNR_CQ_THR_DONE_6	73
+#define CMDQ_EVENT_IMG_WPE_TNR_CQ_THR_DONE_7	74
+#define CMDQ_EVENT_IMG_WPE_TNR_CQ_THR_DONE_8	75
+#define CMDQ_EVENT_IMG_WPE_TNR_CQ_THR_DONE_9	76
+#define CMDQ_EVENT_IMG_PQDIP_B_CQ_THR_DONE_0	77
+#define CMDQ_EVENT_IMG_PQDIP_B_CQ_THR_DONE_1	78
+#define CMDQ_EVENT_IMG_PQDIP_B_CQ_THR_DONE_2	79
+#define CMDQ_EVENT_IMG_PQDIP_B_CQ_THR_DONE_3	80
+#define CMDQ_EVENT_IMG_PQDIP_B_CQ_THR_DONE_4	81
+#define CMDQ_EVENT_IMG_PQDIP_B_CQ_THR_DONE_5	82
+#define CMDQ_EVENT_IMG_PQDIP_B_CQ_THR_DONE_6	83
+#define CMDQ_EVENT_IMG_PQDIP_B_CQ_THR_DONE_7	84
+#define CMDQ_EVENT_IMG_PQDIP_B_CQ_THR_DONE_8	85
+#define CMDQ_EVENT_IMG_PQDIP_B_CQ_THR_DONE_9	86
+#define CMDQ_EVENT_IMG_PQDIP_B_DMA_ERR	87
+#define CMDQ_EVENT_WPE1_DUMMY_0		88
+#define CMDQ_EVENT_WPE1_DUMMY_1		89
+#define CMDQ_EVENT_WPE1_DUMMY_2		90
+#define CMDQ_EVENT_IMG_WPE_LITE_GCE_FRAME_DONE	91
+#define CMDQ_EVENT_IMG_WPE_LITE_DONE_SYNC_OUT	92
+#define CMDQ_EVENT_IMG_WPE_LITE_CQ_THR_DONE_0	93
+#define CMDQ_EVENT_IMG_WPE_LITE_CQ_THR_DONE_1	94
+#define CMDQ_EVENT_IMG_WPE_LITE_CQ_THR_DONE_2	95
+#define CMDQ_EVENT_IMG_WPE_LITE_CQ_THR_DONE_3	96
+#define CMDQ_EVENT_IMG_WPE_LITE_CQ_THR_DONE_4	97
+#define CMDQ_EVENT_IMG_WPE_LITE_CQ_THR_DONE_5	98
+#define CMDQ_EVENT_IMG_WPE_LITE_CQ_THR_DONE_6	99
+#define CMDQ_EVENT_IMG_WPE_LITE_CQ_THR_DONE_7	100
+#define CMDQ_EVENT_IMG_WPE_LITE_CQ_THR_DONE_8	101
+#define CMDQ_EVENT_IMG_WPE_LITE_CQ_THR_DONE_9	102
+#define CMDQ_EVENT_IMG_XTRAW_CQ_THR_DONE_0		103
+#define CMDQ_EVENT_IMG_XTRAW_CQ_THR_DONE_1		104
+#define CMDQ_EVENT_IMG_XTRAW_CQ_THR_DONE_2		105
+#define CMDQ_EVENT_IMG_XTRAW_CQ_THR_DONE_3		106
+#define CMDQ_EVENT_IMG_XTRAW_CQ_THR_DONE_4		107
+#define CMDQ_EVENT_IMG_XTRAW_CQ_THR_DONE_5		108
+#define CMDQ_EVENT_IMG_XTRAW_CQ_THR_DONE_6		109
+#define CMDQ_EVENT_IMG_XTRAW_CQ_THR_DONE_7		110
+#define CMDQ_EVENT_IMG_XTRAW_CQ_THR_DONE_8		111
+#define CMDQ_EVENT_IMG_XTRAW_CQ_THR_DONE_9		112
+#define CMDQ_EVENT_IMG_XTRAW_DMA_ERR_EVENT		113
+#define CMDQ_EVENT_WPE2_DUMMY_0		114
+#define CMDQ_EVENT_WPE2_DUMMY_1		115
+#define CMDQ_EVENT_WPE2_DUMMY_2		116
+#define CMDQ_EVENT_IMG_IMGSYS_IPE_DUMMY	117
+#define CMDQ_EVENT_IMG_IMGSYS_IPE_FDVT_DONE	118
+#define CMDQ_EVENT_IMG_IMGSYS_IPE_ME_DONE	119
+#define CMDQ_EVENT_IMG_IMGSYS_IPE_DVS_DONE	120
+#define CMDQ_EVENT_IMG_IMGSYS_IPE_DVP_DONE	121
+#define CMDQ_EVENT_FDVT1_RESERVED			122
+#define CMDQ_EVENT_IMG_ENG_EVENT			123
+
+
+#define CMDQ_EVENT_CAMSUBA_SW_PASS1_DONE	129
+#define CMDQ_EVENT_CAMSUBB_SW_PASS1_DONE	130
+#define CMDQ_EVENT_CAMSUBC_SW_PASS1_DONE	131
+#define CMDQ_EVENT_GCAMSV_A_1_SW_PASS1_DONE		132
+#define CMDQ_EVENT_GCAMSV_A_2_SW_PASS1_DONE		133
+#define CMDQ_EVENT_GCAMSV_B_1_SW_PASS1_DONE		134
+#define CMDQ_EVENT_GCAMSV_B_2_SW_PASS1_DONE		135
+#define CMDQ_EVENT_GCAMSV_C_1_SW_PASS1_DONE		136
+#define CMDQ_EVENT_GCAMSV_C_2_SW_PASS1_DONE		137
+#define CMDQ_EVENT_GCAMSV_D_1_SW_PASS1_DONE		138
+#define CMDQ_EVENT_GCAMSV_D_2_SW_PASS1_DONE		139
+#define CMDQ_EVENT_GCAMSV_E_1_SW_PASS1_DONE		140
+#define CMDQ_EVENT_GCAMSV_E_2_SW_PASS1_DONE		141
+#define CMDQ_EVENT_GCAMSV_F_1_SW_PASS1_DONE		142
+#define CMDQ_EVENT_GCAMSV_F_2_SW_PASS1_DONE		143
+#define CMDQ_EVENT_GCAMSV_G_1_SW_PASS1_DONE		144
+#define CMDQ_EVENT_GCAMSV_G_2_SW_PASS1_DONE		145
+#define CMDQ_EVENT_GCAMSV_H_1_SW_PASS1_DONE		146
+#define CMDQ_EVENT_GCAMSV_H_2_SW_PASS1_DONE		147
+#define CMDQ_EVENT_GCAMSV_I_1_SW_PASS1_DONE		148
+#define CMDQ_EVENT_GCAMSV_I_2_SW_PASS1_DONE		149
+#define CMDQ_EVENT_GCAMSV_J_1_SW_PASS1_DONE		150
+#define CMDQ_EVENT_GCAMSV_J_2_SW_PASS1_DONE		151
+#define CMDQ_EVENT_MRAW_0_SW_PASS1_DONE		152
+#define CMDQ_EVENT_MRAW_1_SW_PASS1_DONE		153
+#define CMDQ_EVENT_MRAW_2_SW_PASS1_DONE		154
+#define CMDQ_EVENT_MRAW_3_SW_PASS1_DONE		155
+#define CMDQ_EVENT_SENINF_CAM0_FIFO_FULL	156
+#define CMDQ_EVENT_SENINF_CAM1_FIFO_FULL	157
+#define CMDQ_EVENT_SENINF_CAM2_FIFO_FULL	158
+#define CMDQ_EVENT_SENINF_CAM3_FIFO_FULL	159
+#define CMDQ_EVENT_SENINF_CAM4_FIFO_FULL	160
+#define CMDQ_EVENT_SENINF_CAM5_FIFO_FULL	161
+#define CMDQ_EVENT_SENINF_CAM6_FIFO_FULL	162
+#define CMDQ_EVENT_SENINF_CAM7_FIFO_FULL	163
+#define CMDQ_EVENT_SENINF_CAM8_FIFO_FULL	164
+#define CMDQ_EVENT_SENINF_CAM9_FIFO_FULL	165
+#define CMDQ_EVENT_SENINF_CAM10_FIFO_FULL	166
+#define CMDQ_EVENT_SENINF_CAM11_FIFO_FULL	167
+#define CMDQ_EVENT_SENINF_CAM12_FIFO_FULL	168
+#define CMDQ_EVENT_SENINF_CAM13_FIFO_FULL	169
+#define CMDQ_EVENT_SENINF_CAM14_FIFO_FULL	170
+#define CMDQ_EVENT_SENINF_CAM15_FIFO_FULL	171
+#define CMDQ_EVENT_SENINF_CAM16_FIFO_FULL	172
+#define CMDQ_EVENT_SENINF_CAM17_FIFO_FULL	173
+#define CMDQ_EVENT_SENINF_CAM18_FIFO_FULL	174
+#define CMDQ_EVENT_SENINF_CAM19_FIFO_FULL	175
+#define CMDQ_EVENT_SENINF_CAM20_FIFO_FULL	176
+#define CMDQ_EVENT_SENINF_CAM21_FIFO_FULL	177
+#define CMDQ_EVENT_SENINF_CAM22_FIFO_FULL	178
+#define CMDQ_EVENT_SENINF_CAM23_FIFO_FULL	179
+#define CMDQ_EVENT_SENINF_CAM24_FIFO_FULL	180
+#define CMDQ_EVENT_SENINF_CAM25_FIFO_FULL	181
+#define CMDQ_EVENT_SENINF_CAM26_FIFO_FULL	182
+#define CMDQ_EVENT_TG_OVRUN_MRAW0_INT	183
+#define CMDQ_EVENT_TG_OVRUN_MRAW1_INT	184
+#define CMDQ_EVENT_TG_OVRUN_MRAW2_INT	185
+#define CMDQ_EVENT_TG_OVRUN_MRAW3_INT	186
+#define CMDQ_EVENT_DMA_R1_ERROR_MRAW0_INT	187
+#define CMDQ_EVENT_DMA_R1_ERROR_MRAW1_INT	188
+#define CMDQ_EVENT_DMA_R1_ERROR_MRAW2_INT	189
+#define CMDQ_EVENT_DMA_R1_ERROR_MRAW3_INT	190
+#define CMDQ_EVENT_PDA0_IRQO_EVENT_DONE_D1	191
+#define CMDQ_EVENT_PDA1_IRQO_EVENT_DONE_D1		192
+#define CMDQ_EVENT_CAM_SUBA_TG_INT1		193
+#define CMDQ_EVENT_CAM_SUBA_TG_INT2		194
+#define CMDQ_EVENT_CAM_SUBA_TG_INT3		195
+#define CMDQ_EVENT_CAM_SUBA_TG_INT4		196
+#define CMDQ_EVENT_CAM_SUBB_TG_INT1		197
+#define CMDQ_EVENT_CAM_SUBB_TG_INT2		198
+#define CMDQ_EVENT_CAM_SUBB_TG_INT3		199
+#define CMDQ_EVENT_CAM_SUBB_TG_INT4		200
+#define CMDQ_EVENT_CAM_SUBC_TG_INT1		201
+#define CMDQ_EVENT_CAM_SUBC_TG_INT2		202
+#define CMDQ_EVENT_CAM_SUBC_TG_INT3		203
+#define CMDQ_EVENT_CAM_SUBC_TG_INT4		204
+#define CMDQ_EVENT_CAM_SUBA_IMGO_R1_LOW_LATENCY_LINE_CNT_INT	205
+#define CMDQ_EVENT_CAM_SUBA_YUVO_R1_LOW_LATENCY_LINE_CNT_INT	206
+#define CMDQ_EVENT_CAM_SUBA_YUVO_R3_LOW_LATENCY_LINE_CNT_INT	207
+#define CMDQ_EVENT_CAM_SUBA_DRZS4NO_R1_LOW_LATENCY_LINE_CNT_INT	208
+#define CMDQ_EVENT_CAM_SUBB_IMGO_R1_LOW_LATENCY_LINE_CNT_INT	209
+#define CMDQ_EVENT_CAM_SUBB_YUVO_R1_LOW_LATENCY_LINE_CNT_INT	210
+#define CMDQ_EVENT_CAM_SUBB_YUVO_R3_LOW_LATENCY_LINE_CNT_INT	211
+#define CMDQ_EVENT_CAM_SUBB_DRZS4NO_R1_LOW_LATENCY_LINE_CNT_INT	212
+#define CMDQ_EVENT_CAM_SUBC_IMGO_R1_LOW_LATENCY_LINE_CNT_INT	213
+#define CMDQ_EVENT_CAM_SUBC_YUVO_R1_LOW_LATENCY_LINE_CNT_INT	214
+#define CMDQ_EVENT_CAM_SUBC_YUVO_R3_LOW_LATENCY_LINE_CNT_INT	215
+#define CMDQ_EVENT_CAM_SUBC_DRZS4NO_R1_LOW_LATENCY_LINE_CNT_INT	216
+#define CMDQ_EVENT_RAW_SEL_SOF_SUBA		217
+#define CMDQ_EVENT_RAW_SEL_SOF_SUBB		218
+#define CMDQ_EVENT_RAW_SEL_SOF_SUBC		219
+#define CMDQ_EVENT_CAM_SUBA_RING_BUFFER_OVERFLOW_INT_IN		220
+#define CMDQ_EVENT_CAM_SUBB_RING_BUFFER_OVERFLOW_INT_IN		221
+#define CMDQ_EVENT_CAM_SUBC_RING_BUFFER_OVERFLOW_INT_IN		222
+
+#define CMDQ_EVENT_VPP0_MDP_RDMA_SOF	256
+#define CMDQ_EVENT_VPP0_MDP_FG_SOF	257
+#define CMDQ_EVENT_VPP0_STITCH_SOF	258
+#define CMDQ_EVENT_VPP0_MDP_HDR_SOF	259
+#define CMDQ_EVENT_VPP0_MDP_AAL_SOF	260
+#define CMDQ_EVENT_VPP0_MDP_RSZ_IN_RSZ_SOF	261
+#define CMDQ_EVENT_VPP0_MDP_TDSHP_SOF	262
+#define CMDQ_EVENT_VPP0_DISP_COLOR_SOF	263
+#define CMDQ_EVENT_VPP0_DISP_OVL_NOAFBC_SOF	264
+#define CMDQ_EVENT_VPP0_VPP_PADDING_IN_PADDING_SOF	265
+#define CMDQ_EVENT_VPP0_MDP_TCC_IN_SOF	266
+#define CMDQ_EVENT_VPP0_MDP_WROT_SOF	267
+
+#define CMDQ_EVENT_VPP0_WARP0_MMSYS_TOP_RELAY_SOF_PRE	269
+#define CMDQ_EVENT_VPP0_WARP1_MMSYS_TOP_RELAY_SOF_PRE	270
+#define CMDQ_EVENT_VPP0_VPP1_MMSYS_TOP_RELAY_SOF	271
+#define CMDQ_EVENT_VPP0_VPP1_IN_MMSYS_TOP_RELAY_SOF_PRE	272
+#define CMDQ_EVENT_VPP0_DISP_RDMA_SOF	273
+#define CMDQ_EVENT_VPP0_DISP_WDMA_SOF	274
+#define CMDQ_EVENT_VPP0_MDP_HMS_SOF		275
+#define CMDQ_EVENT_VPP0_MDP_RDMA_FRAME_DONE	288
+#define CMDQ_EVENT_VPP0_MDP_FG_TILE_DONE	289
+#define CMDQ_EVENT_VPP0_STITCH_FRAME_DONE	290
+#define CMDQ_EVENT_VPP0_MDP_HDR_FRAME_DONE	291
+#define CMDQ_EVENT_VPP0_MDP_AAL_FRAME_DONE	292
+#define CMDQ_EVENT_VPP0_MDP_RSZ_FRAME_DONE	293
+#define CMDQ_EVENT_VPP0_MDP_TDSHP_FRAME_DONE	294
+#define CMDQ_EVENT_VPP0_DISP_COLOR_FRAME_DONE	295
+#define CMDQ_EVENT_VPP0_DISP_OVL_NOAFBC_FRAME_DONE	296
+#define CMDQ_EVENT_VPP0_VPP_PADDING_IN_PADDING_FRAME_DONE	297
+#define CMDQ_EVENT_VPP0_MDP_TCC_TCC_FRAME_DONE	298
+#define CMDQ_EVENT_VPP0_MDP_WROT_VIDO_WDONE	299
+#define CMDQ_EVENT_VPP0_DISP_RDMA_FRAME_DONE	305
+#define CMDQ_EVENT_VPP0_DISP_WDMA_FRAME_DONE	306
+#define CMDQ_EVENT_VPP0_MDP_HMS_FRAME_DONE		307
+
+#define CMDQ_EVENT_VPP0_DISP_MUTEX_STREAM_DONE_0	320
+#define CMDQ_EVENT_VPP0_DISP_MUTEX_STREAM_DONE_1	321
+#define CMDQ_EVENT_VPP0_DISP_MUTEX_STREAM_DONE_2	322
+#define CMDQ_EVENT_VPP0_DISP_MUTEX_STREAM_DONE_3	323
+#define CMDQ_EVENT_VPP0_DISP_MUTEX_STREAM_DONE_4	324
+#define CMDQ_EVENT_VPP0_DISP_MUTEX_STREAM_DONE_5	325
+#define CMDQ_EVENT_VPP0_DISP_MUTEX_STREAM_DONE_6	326
+#define CMDQ_EVENT_VPP0_DISP_MUTEX_STREAM_DONE_7	327
+#define CMDQ_EVENT_VPP0_DISP_MUTEX_STREAM_DONE_8	328
+#define CMDQ_EVENT_VPP0_DISP_MUTEX_STREAM_DONE_9	329
+#define CMDQ_EVENT_VPP0_DISP_MUTEX_STREAM_DONE_10	330
+#define CMDQ_EVENT_VPP0_DISP_MUTEX_STREAM_DONE_11	331
+#define CMDQ_EVENT_VPP0_DISP_MUTEX_STREAM_DONE_12	332
+#define CMDQ_EVENT_VPP0_DISP_MUTEX_STREAM_DONE_13	333
+#define CMDQ_EVENT_VPP0_DISP_MUTEX_STREAM_DONE_14	334
+#define CMDQ_EVENT_VPP0_DISP_MUTEX_STREAM_DONE_15	335
+
+#define CMDQ_EVENT_VPP0_DISP_RDMA_0_UNDERRUN	336
+#define CMDQ_EVENT_VPP0_DISP_RDMA_1_UNDERRUN	337
+#define CMDQ_EVENT_VPP0_U_MERGE4_UNDERRUN 338
+#define CMDQ_EVENT_VPP0_U_VPP_SPLIT_VIDEO_0_OVERFLOW	339
+#define CMDQ_EVENT_VPP0_U_VPP_SPLIT_VIDEO_1_OVERFLOW	340
+#define CMDQ_EVENT_VPP0_DSI_0_UNDERRUN	341
+#define CMDQ_EVENT_VPP0_DSI_1_UNDERRUN	342
+#define CMDQ_EVENT_VPP0_DP_INTF_0 343
+#define CMDQ_EVENT_VPP0_DP_INTF_1 344
+#define CMDQ_EVENT_VPP0_DPI_0 345
+#define CMDQ_EVENT_VPP0_DPI_1 346
+#define CMDQ_EVENT_VPP0_MDP_RDMA_SW_RST_DONE	352
+#define CMDQ_EVENT_VPP0_MDP_RDMA_PM_VALID_EVENT		353
+#define CMDQ_EVENT_VPP0_DISP_OVL_NOAFBC_FRAME_RESET_DONE_PULSE		354
+#define CMDQ_EVENT_VPP0_MDP_WROT_SW_RST_DONE	355
+
+#define CMDQ_EVENT_VPP0_DISP_OVL_NOAFBC_TARGET_MATCH_0	356
+#define CMDQ_EVENT_VPP0_DISP_OVL_NOAFBC_TARGET_MATCH_1	357
+#define CMDQ_EVENT_VPP0_DISP_OVL_NOAFBC_TARGET_MATCH_2	358
+#define CMDQ_EVENT_VPP0_DISP_OVL_NOAFBC_TARGET_MATCH_3	359
+#define CMDQ_EVENT_VPP0_DISP_OVL_NOAFBC_TARGET_MATCH_4	360
+#define CMDQ_EVENT_VPP0_DISP_OVL_NOAFBC_TARGET_MATCH_5	361
+#define CMDQ_EVENT_VPP0_DISP_OVL_NOAFBC_TARGET_MATCH_6	362
+
+#define CMDQ_EVENT_VPP0_DISP_RDMA_DISP_RDMA_VALID_EVENT		363
+#define CMDQ_EVENT_VPP0_DISP_RDMA_DISP_RDMA_TARGET_LINE_EVENT	364
+#define CMDQ_EVENT_VPP0_DISP_WDMA_SW_RST_DONE	365
+#define CMDQ_EVENT_VPP0_DISP_WDMA_WDMA_VALID_EVENT			366
+#define CMDQ_EVENT_VPP0_DISP_WDMA_WDMA_TARGET_LINE_EVENT	367
+
+#define CMDQ_EVENT_VPP1_HDMI_META_SOF		384
+#define CMDQ_EVENT_VPP1_DGI_SOF				385
+#define CMDQ_EVENT_VPP1_VPP_SPLIT_SOF		386
+#define CMDQ_EVENT_VPP1_SVPP1_MDP_TCC_SOF	387
+#define CMDQ_EVENT_VPP1_SVPP1_MDP_RDMA_SOF	388
+#define CMDQ_EVENT_VPP1_SVPP2_MDP_RDMA_SOF	389
+#define CMDQ_EVENT_VPP1_SVPP3_MDP_RDMA_SOF	390
+#define CMDQ_EVENT_VPP1_SVPP1_MDP_FG_SOF	391
+#define CMDQ_EVENT_VPP1_SVPP2_MDP_FG_SOF	392
+#define CMDQ_EVENT_VPP1_SVPP3_MDP_FG_SOF	393
+#define CMDQ_EVENT_VPP1_SVPP1_MDP_HDR_SOF	394
+#define CMDQ_EVENT_VPP1_SVPP2_MDP_HDR_SOF	395
+#define CMDQ_EVENT_VPP1_SVPP3_MDP_HDR_SOF	396
+#define CMDQ_EVENT_VPP1_SVPP1_MDP_AAL_SOF	397
+#define CMDQ_EVENT_VPP1_SVPP2_MDP_AAL_SOF	398
+#define CMDQ_EVENT_VPP1_SVPP3_MDP_AAL_SOF	399
+#define CMDQ_EVENT_VPP1_SVPP1_MDP_RSZ_SOF	400
+#define CMDQ_EVENT_VPP1_SVPP2_MDP_RSZ_SOF	401
+#define CMDQ_EVENT_VPP1_SVPP3_MDP_RSZ_SOF	402
+#define CMDQ_EVENT_VPP1_SVPP1_MDP_TDSHP_SOF	403
+#define CMDQ_EVENT_VPP1_SVPP2_MDP_TDSHP_SOF	404
+#define CMDQ_EVENT_VPP1_SVPP3_MDP_TDSHP_SOF	405
+#define CMDQ_EVENT_VPP1_SVPP2_VPP_MERGE_SOF	406
+#define CMDQ_EVENT_VPP1_SVPP3_VPP_MERGE_SOF	407
+#define CMDQ_EVENT_VPP1_SVPP1_MDP_COLOR_SOF	408
+#define CMDQ_EVENT_VPP1_SVPP2_MDP_COLOR_SOF	409
+#define CMDQ_EVENT_VPP1_SVPP3_MDP_COLOR_SOF	410
+#define CMDQ_EVENT_VPP1_SVPP1_MDP_OVL_SOF	411
+#define CMDQ_EVENT_VPP1_SVPP1_VPP_PAD_SOF	412
+#define CMDQ_EVENT_VPP1_SVPP2_VPP_PAD_SOF	413
+#define CMDQ_EVENT_VPP1_SVPP3_VPP_PAD_SOF	414
+#define CMDQ_EVENT_VPP1_SVPP1_MDP_WROT_SOF	415
+#define CMDQ_EVENT_VPP1_SVPP2_MDP_WROT_SOF	416
+#define CMDQ_EVENT_VPP1_SVPP3_MDP_WROT_SOF	417
+#define CMDQ_EVENT_VPP1_VPP0_DL_IRLY_SOF	418
+#define CMDQ_EVENT_VPP1_VPP0_DL_ORLY_SOF	419
+#define CMDQ_EVENT_VPP1_VDO0_DL_ORLY_0_SOF	420
+#define CMDQ_EVENT_VPP1_VDO0_DL_ORLY_1_SOF	421
+#define CMDQ_EVENT_VPP1_VDO1_DL_ORLY_0_SOF	422
+#define CMDQ_EVENT_VPP1_VDO1_DL_ORLY_1_SOF	423
+#define CMDQ_EVENT_VPP1_SVPP1_MDP_RDMA_FRAME_DONE	424
+#define CMDQ_EVENT_VPP1_SVPP2_MDP_RDMA_FRAME_DONE	425
+#define CMDQ_EVENT_VPP1_SVPP3_MDP_RDMA_FRAME_DONE	426
+#define CMDQ_EVENT_VPP1_SVPP1_MDP_WROT_FRAME_DONE	427
+#define CMDQ_EVENT_VPP1_SVPP2_MDP_WROT_FRAME_DONE	428
+#define CMDQ_EVENT_VPP1_SVPP3_MDP_WROT_FRAME_DONE	429
+#define CMDQ_EVENT_VPP1_SVPP1_MDP_OVL_FRAME_DONE	430
+#define CMDQ_EVENT_VPP1_SVPP1_MDP_RSZ_FRAME_DONE	431
+#define CMDQ_EVENT_VPP1_SVPP2_MDP_RSZ_FRAME_DONE	432
+#define CMDQ_EVENT_VPP1_SVPP3_MDP_RSZ_FRAME_DONE	433
+#define CMDQ_EVENT_VPP1_SVPP1_MDP_FG_TILE_DONE		434
+#define CMDQ_EVENT_VPP1_SVPP2_MDP_FG_TILE_DONE		435
+#define CMDQ_EVENT_VPP1_SVPP3_MDP_FG_TILE_DONE		436
+#define CMDQ_EVENT_VPP1_SVPP1_MDP_HDR_FRAME_DONE	437
+#define CMDQ_EVENT_VPP1_SVPP2_MDP_HDR_FRAME_DONE	438
+#define CMDQ_EVENT_VPP1_SVPP3_MDP_HDR_FRAME_DONE	439
+#define CMDQ_EVENT_VPP1_SVPP1_MDP_AAL_FRAME_DONE	440
+#define CMDQ_EVENT_VPP1_SVPP2_MDP_AAL_FRAME_DONE	441
+#define CMDQ_EVENT_VPP1_SVPP3_MDP_AAL_FRAME_DONE	442
+#define CMDQ_EVENT_VPP1_SVPP1_MDP_TDSHP_FRAME_DONE		443
+#define CMDQ_EVENT_VPP1_SVPP2_MDP_TDSHP_FRAME_DONE		444
+#define CMDQ_EVENT_VPP1_SVPP3_MDP_TDSHP_FRAME_DONE		445
+#define CMDQ_EVENT_VPP1_SVPP1_MDP_COLOR_FRAME_DONE		446
+#define CMDQ_EVENT_VPP1_SVPP2_MDP_COLOR_FRAME_DONE		447
+#define CMDQ_EVENT_VPP1_SVPP3_MDP_COLOR_FRAME_DONE		448
+#define CMDQ_EVENT_VPP1_SVPP1_VPP_PAD_FRAME_DONE	449
+#define CMDQ_EVENT_VPP1_SVPP2_VPP_PAD_FRAME_DONE	450
+#define CMDQ_EVENT_VPP1_SVPP3_VPP_PAD_FRAME_DONE	451
+#define CMDQ_EVENT_VPP1_SVPP1_MDP_TCC_FRAME_DONE	452
+#define CMDQ_EVENT_VPP1_MUTEX_STREAM_DONE_GCE_EVENT_0		456
+#define CMDQ_EVENT_VPP1_MUTEX_STREAM_DONE_GCE_EVENT_1		457
+#define CMDQ_EVENT_VPP1_MUTEX_STREAM_DONE_GCE_EVENT_2		458
+#define CMDQ_EVENT_VPP1_MUTEX_STREAM_DONE_GCE_EVENT_3		459
+#define CMDQ_EVENT_VPP1_MUTEX_STREAM_DONE_GCE_EVENT_4		460
+#define CMDQ_EVENT_VPP1_MUTEX_STREAM_DONE_GCE_EVENT_5		461
+#define CMDQ_EVENT_VPP1_MUTEX_STREAM_DONE_GCE_EVENT_6		462
+#define CMDQ_EVENT_VPP1_MUTEX_STREAM_DONE_GCE_EVENT_7		463
+#define CMDQ_EVENT_VPP1_MUTEX_STREAM_DONE_GCE_EVENT_8		464
+#define CMDQ_EVENT_VPP1_MUTEX_STREAM_DONE_GCE_EVENT_9		465
+#define CMDQ_EVENT_VPP1_MUTEX_STREAM_DONE_GCE_EVENT_10	466
+#define CMDQ_EVENT_VPP1_MUTEX_STREAM_DONE_GCE_EVENT_11	467
+#define CMDQ_EVENT_VPP1_MUTEX_STREAM_DONE_GCE_EVENT_12	468
+#define CMDQ_EVENT_VPP1_MUTEX_STREAM_DONE_GCE_EVENT_13	469
+#define CMDQ_EVENT_VPP1_MUTEX_STREAM_DONE_GCE_EVENT_14	470
+#define CMDQ_EVENT_VPP1_MUTEX_STREAM_DONE_GCE_EVENT_15	471
+#define CMDQ_EVENT_VPP1_MUTEX_BUF_UNDERRUN_GCE_EVENT_0	472
+#define CMDQ_EVENT_VPP1_MUTEX_BUF_UNDERRUN_GCE_EVENT_1	473
+#define CMDQ_EVENT_VPP1_MUTEX_BUF_UNDERRUN_GCE_EVENT_2	474
+#define CMDQ_EVENT_VPP1_MUTEX_BUF_UNDERRUN_GCE_EVENT_3	475
+#define CMDQ_EVENT_VPP1_MUTEX_BUF_UNDERRUN_GCE_EVENT_4	476
+#define CMDQ_EVENT_VPP1_MUTEX_BUF_UNDERRUN_GCE_EVENT_5	477
+#define CMDQ_EVENT_VPP1_MUTEX_BUF_UNDERRUN_GCE_EVENT_6	478
+#define CMDQ_EVENT_VPP1_MUTEX_BUF_UNDERRUN_GCE_EVENT_7	479
+#define CMDQ_EVENT_VPP1_MUTEX_BUF_UNDERRUN_GCE_EVENT_8	480
+#define CMDQ_EVENT_VPP1_MUTEX_BUF_UNDERRUN_GCE_EVENT_9	481
+#define CMDQ_EVENT_VPP1_MUTEX_BUF_UNDERRUN_GCE_EVENT_10	 482
+#define CMDQ_EVENT_VPP1_MUTEX_BUF_UNDERRUN_GCE_EVENT_11	 483
+#define CMDQ_EVENT_VPP1_MUTEX_BUF_UNDERRUN_GCE_EVENT_12	 484
+#define CMDQ_EVENT_VPP1_MUTEX_BUF_UNDERRUN_GCE_EVENT_13	 485
+#define CMDQ_EVENT_VPP1_MUTEX_BUF_UNDERRUN_GCE_EVENT_14	 486
+#define CMDQ_EVENT_VPP1_MUTEX_BUF_UNDERRUN_GCE_EVENT_15	 487
+#define CMDQ_EVENT_VPP1_DGI_SYNC_EVENT_0	488
+#define CMDQ_EVENT_VPP1_DGI_SYNC_EVENT_1	489
+#define CMDQ_EVENT_VPP1_DGI_SYNC_EVENT_2	490
+#define CMDQ_EVENT_VPP1_DGI_SYNC_EVENT_3	491
+#define CMDQ_EVENT_VPP1_DGI_SYNC_EVENT_4	492
+#define CMDQ_EVENT_VPP1_DGI_SYNC_EVENT_5	493
+#define CMDQ_EVENT_VPP1_DGI_SYNC_EVENT_6	494
+#define CMDQ_EVENT_VPP1_DGI_SYNC_EVENT_7	495
+#define CMDQ_EVENT_VPP1_DGI_SYNC_EVENT_8	496
+#define CMDQ_EVENT_VPP1_DGI_SYNC_EVENT_9	497
+#define CMDQ_EVENT_VPP1_DGI_SYNC_EVENT_10		498
+#define CMDQ_EVENT_VPP1_DGI_SYNC_EVENT_11		499
+#define CMDQ_EVENT_VPP1_DGI_SYNC_EVENT_12		500
+#define CMDQ_EVENT_VPP1_DGI_SYNC_EVENT_13		501
+
+#define CMDQ_EVENT_VPP1_SVPP3_VPP_MERGE_GCE_EVENT	502
+#define CMDQ_EVENT_VPP1_SVPP2_VPP_MERGE_GCE_EVENT	503
+#define CMDQ_EVENT_VPP1_SVPP1_MDP_OVL_GCE_EVENT		504
+#define CMDQ_EVENT_VPP1_VPP_SPLIT_DGI_GCE_EVENT		505
+#define CMDQ_EVENT_VPP1_VPP_SPLIT_HDMI_GCE_EVENT	506
+#define CMDQ_EVENT_VPP1_SVPP3_MDP_WROT_SW_RST_DONE_GCE_EVENT	507
+#define CMDQ_EVENT_VPP1_SVPP2_MDP_WROT_SW_RST_DONE_GCE_EVENT	508
+#define CMDQ_EVENT_VPP1_SVPP1_MDP_WROT_SW_RST_DONE_GCE_EVENT	509
+
+#define CMDQ_EVENT_VPP1_SVPP1_MDP_OVL_NEW_EVENT_0		510
+#define CMDQ_EVENT_VPP1_SVPP1_MDP_OVL_NEW_EVENT_1		511
+
+#define CMDQ_EVENT_VDO0_DISP_OVL0_SOF	512
+#define CMDQ_EVENT_VDO0_DISP_WDMA0_SOF	513
+#define CMDQ_EVENT_VDO0_DISP_RDMA0_SOF	514
+#define CMDQ_EVENT_VDO0_DISP_COLOR0_SOF	515
+#define CMDQ_EVENT_VDO0_DISP_CCORR0_SOF	516
+#define CMDQ_EVENT_VDO0_DISP_AAL0_SOF	517
+#define CMDQ_EVENT_VDO0_DISP_GAMMA0_SOF	518
+#define CMDQ_EVENT_VDO0_DISP_DITHER0_SOF	519
+#define CMDQ_EVENT_VDO0_DSI0_SOF	520
+#define CMDQ_EVENT_VDO0_DSC_WRAP0C0_SOF	521
+#define CMDQ_EVENT_VDO0_DISP_OVL1_SOF	522
+#define CMDQ_EVENT_VDO0_DISP_WDMA1_SOF	523
+#define CMDQ_EVENT_VDO0_DISP_RDMA1_SOF	524
+#define CMDQ_EVENT_VDO0_DISP_COLOR1_SOF	525
+#define CMDQ_EVENT_VDO0_DISP_CCORR1_SOF	526
+#define CMDQ_EVENT_VDO0_DISP_AAL1_SOF	527
+#define CMDQ_EVENT_VDO0_DISP_GAMMA1_SOF	528
+#define CMDQ_EVENT_VDO0_DISP_DITHER1_SOF	529
+#define CMDQ_EVENT_VDO0_DSI1_SOF	530
+#define CMDQ_EVENT_VDO0_DSC_WRAP0C1_SOF	531
+#define CMDQ_EVENT_VDO0_VPP_MERGE0_SOF	532
+#define CMDQ_EVENT_VDO0_DP_INTF0_SOF	533
+#define CMDQ_EVENT_VDO0_DISP_DPI0_SOF	   534
+#define CMDQ_EVENT_VDO0_DISP_DPI1_SOF	   535
+#define CMDQ_EVENT_VDO0_DISP_POSTMASK0_SOF		536
+#define CMDQ_EVENT_VDO0_MDP_WROT0_SOF	537
+#define CMDQ_EVENT_VDO0_DISP_RSZ0_SOF	538
+#define CMDQ_EVENT_VDO0_VPP1_DL_RELAY0_SOF		539
+#define CMDQ_EVENT_VDO0_VPP1_DL_RELAY1_SOF		540
+#define CMDQ_EVENT_VDO0_VDO1_DL_RELAY2_SOF		541
+#define CMDQ_EVENT_VDO0_VDO0_DL_RELAY3_SOF		542
+#define CMDQ_EVENT_VDO0_VDO0_DL_RELAY4_SOF		543
+#define CMDQ_EVENT_VDO0_DISP_PWM0_SOF	544
+#define CMDQ_EVENT_VDO0_DISP_PWM1_SOF	545
+
+#define CMDQ_EVENT_VDO0_DISP_OVL0_O_FRAME_DONE		546
+#define CMDQ_EVENT_VDO0_DISP_WDMA0_FRAME_DONE		547
+#define CMDQ_EVENT_VDO0_DISP_RDMA0_FRAME_DONE		548
+#define CMDQ_EVENT_VDO0_DISP_COLOR0_O_FRAME_DONE	549
+#define CMDQ_EVENT_VDO0_DISP_CCORR0_O_FRAME_DONE	550
+#define CMDQ_EVENT_VDO0_DISP_AAL0_O_FRAME_DONE		551
+#define CMDQ_EVENT_VDO0_DISP_GAMMA0_O_FRAME_DONE	552
+#define CMDQ_EVENT_VDO0_DISP_DITHER0_O_FRAME_DONE	553
+#define CMDQ_EVENT_VDO0_DSI0_FRAME_DONE	554
+#define CMDQ_EVENT_VDO0_DSC_WRAP0_O_FRAME_DONE_0	555
+#define CMDQ_EVENT_VDO0_DISP_OVL1_O_FRAME_DONE		556
+#define CMDQ_EVENT_VDO0_DISP_WDMA1_O_FRAME_DONE		557
+#define CMDQ_EVENT_VDO0_DISP_RDMA1_O_FRAME_DONE		558
+#define CMDQ_EVENT_VDO0_DISP_COLOR1_O_FRAME_DONE	559
+#define CMDQ_EVENT_VDO0_DISP_CCORR1_O_FRAME_DONE	560
+#define CMDQ_EVENT_VDO0_DISP_AAL1_O_FRAME_DONE		561
+#define CMDQ_EVENT_VDO0_DISP_GAMMA1_O_FRAME_DONE	562
+#define CMDQ_EVENT_VDO0_DISP_DITHER1_O_FRAME_DONE	563
+#define CMDQ_EVENT_VDO0_DSI1_FRAME_DONE	564
+#define CMDQ_EVENT_VDO0_DSC_WRAP0_O_FRAME_DONE_1	565
+
+#define CMDQ_EVENT_VDO0_DP_INTF0_FRAME_DONE	567
+#define CMDQ_EVENT_VDO0_DISP_DPI0_O_FRAME_DONE		568
+#define CMDQ_EVENT_VDO0_DISP_DPI1_O_FRAME_DONE		569
+#define CMDQ_EVENT_VDO0_DISP_POSTMASK0_O_FRAME_DONE	570
+#define CMDQ_EVENT_VDO0_MDP_WROT0_O_FRAME_DONE		571
+#define CMDQ_EVENT_VDO0_DISP_RSZ0_O_FRAME_DONE		572
+
+
+#define CMDQ_EVENT_VDO0_DISP_STREAM_DONE_0		574
+#define CMDQ_EVENT_VDO0_DISP_STREAM_DONE_1		575
+#define CMDQ_EVENT_VDO0_DISP_STREAM_DONE_2		576
+#define CMDQ_EVENT_VDO0_DISP_STREAM_DONE_3		577
+#define CMDQ_EVENT_VDO0_DISP_STREAM_DONE_4		578
+#define CMDQ_EVENT_VDO0_DISP_STREAM_DONE_5		579
+#define CMDQ_EVENT_VDO0_DISP_STREAM_DONE_6		580
+#define CMDQ_EVENT_VDO0_DISP_STREAM_DONE_7		581
+#define CMDQ_EVENT_VDO0_DISP_STREAM_DONE_8		582
+#define CMDQ_EVENT_VDO0_DISP_STREAM_DONE_9		583
+#define CMDQ_EVENT_VDO0_DISP_STREAM_DONE_10	584
+#define CMDQ_EVENT_VDO0_DISP_STREAM_DONE_11	585
+#define CMDQ_EVENT_VDO0_DISP_STREAM_DONE_12	586
+#define CMDQ_EVENT_VDO0_DISP_STREAM_DONE_13	587
+#define CMDQ_EVENT_VDO0_DISP_STREAM_DONE_14	588
+#define CMDQ_EVENT_VDO0_DISP_STREAM_DONE_15	589
+
+#define CMDQ_EVENT_VDO0_DISP_RDMA_0_UNDERRUN	590
+#define CMDQ_EVENT_VDO0_DISP_RDMA_1_UNDERRUN	591
+#define CMDQ_EVENT_VDO0_U_MERGE4_UNDERRUN	592
+
+#define CMDQ_EVENT_VDO0_DSI_0_UNDERRUN	595
+#define CMDQ_EVENT_VDO0_DSI_1_UNDERRUN	596
+#define CMDQ_EVENT_VDO0_DP_INTF_0	597
+#define CMDQ_EVENT_VDO0_DP_INTF_1	598
+#define CMDQ_EVENT_VDO0_DPI_0		599
+#define CMDQ_EVENT_VDO0_DPI_1	600
+
+#define CMDQ_EVENT_VDO0_DISP_SMIASSERT_ENG_EVENT	606
+#define CMDQ_EVENT_VDO0_DSI0_O_DSI_IRQ_EVENT_MM		607
+#define CMDQ_EVENT_VDO0_DSI0_TE_ENG_EVENT_MM		608
+#define CMDQ_EVENT_VDO0_DSI0_O_DSI_DONE_EVENT_MM	609
+#define CMDQ_EVENT_VDO0_DSI0_O_DSI_VACTL_EVENT_MM	610
+#define CMDQ_EVENT_VDO0_DSI1_O_DSI_IRQ_EVENT_MM		611
+#define CMDQ_EVENT_VDO0_DSI1_TE_ENG_EVENT_MM		612
+#define CMDQ_EVENT_VDO0_DSI1_O_DSI_DONE_EVENT_MM	613
+#define CMDQ_EVENT_VDO0_DSI1_O_DSI_VACTL_EVENT_MM	614
+#define CMDQ_EVENT_VDO0_DP_INTF0_O_DP_VSYNC_START_EVENT_MM		615
+#define CMDQ_EVENT_VDO0_DP_INTF0_O_DP_VSYNC_END_EVENT_MM	616
+#define CMDQ_EVENT_VDO0_DP_INTF0_O_DP_VDE_START_EVENT_MM	617
+#define CMDQ_EVENT_VDO0_DP_INTF0_O_DP_VDE_END_EVENT_MM		618
+#define CMDQ_EVENT_VDO0_DP_INTF0_O_VACT_TARGET_LINE_EVENT_MM	619
+#define CMDQ_EVENT_VDO0_DP_INTF0_O_LAST_SAFE_BLANK_EVENT_MM		620
+#define CMDQ_EVENT_VDO0_DP_INTF0_O_LAST_LINE_EVENT_MM	621
+#define CMDQ_EVENT_VDO0_DP_INTF0_O_TRIGGER_LOOP_CLEAR_EVENT_MM		622
+#define CMDQ_EVENT_VDO0_DP_INTF0_O_TARGET_LINE_0_EVENT_MM	623
+#define CMDQ_EVENT_VDO0_DP_INTF0_O_TARGET_LINE_1_EVENT_MM	624
+#define CMDQ_EVENT_VDO0_DISP_POSTMASK0_O_FRAME_RESET_DONE_PULSE		625
+#define CMDQ_EVENT_VDO0_VPP_MERGE0_O_VPP_MERGE_EVENT	626
+#define CMDQ_EVENT_VDO0_DISP_OVL0_O_FRAME_RESET_DONE_PULSE		627
+#define CMDQ_EVENT_VDO0_DISP_RDMA0_O_DISP_RDMA_TARGET_LINE_EVENT	628
+#define CMDQ_EVENT_VDO0_DISP_WDMA0_O_WDMA_TARGET_LINE_EVENT		629
+#define CMDQ_EVENT_VDO0_DISP_WDMA0_O_SW_RST_DONE	630
+
+#define CMDQ_EVENT_VDO0_DISP_OVL0_O_TARGET_MATCH_EVENT_0	631
+#define CMDQ_EVENT_VDO0_DISP_OVL0_O_TARGET_MATCH_EVENT_1	632
+#define CMDQ_EVENT_VDO0_DISP_OVL0_O_TARGET_MATCH_EVENT_2	633
+#define CMDQ_EVENT_VDO0_DISP_OVL0_O_TARGET_MATCH_EVENT_3	634
+#define CMDQ_EVENT_VDO0_DISP_OVL0_O_TARGET_MATCH_EVENT_4	635
+#define CMDQ_EVENT_VDO0_DISP_OVL0_O_TARGET_MATCH_EVENT_5	636
+#define CMDQ_EVENT_VDO0_DISP_OVL0_O_TARGET_MATCH_EVENT_6	637
+#define CMDQ_EVENT_VDO0_MDP_WROT0_O_SW_RST_DONE		638
+#define CMDQ_EVENT_VDO0_RESERVED 639
+#define CMDQ_EVENT_VDO1_MDP_RDMA0_SOF	640
+#define CMDQ_EVENT_VDO1_MDP_RDMA1_SOF	641
+#define CMDQ_EVENT_VDO1_MDP_RDMA2_SOF	642
+#define CMDQ_EVENT_VDO1_MDP_RDMA3_SOF	643
+#define CMDQ_EVENT_VDO1_MDP_RDMA4_SOF	644
+#define CMDQ_EVENT_VDO1_MDP_RDMA5_SOF	645
+#define CMDQ_EVENT_VDO1_MDP_RDMA6_SOF	646
+#define CMDQ_EVENT_VDO1_MDP_RDMA7_SOF	647
+#define CMDQ_EVENT_VDO1_DISP_PADDING0_SOF	648
+#define CMDQ_EVENT_VDO1_DISP_PADDING1_SOF	649
+#define CMDQ_EVENT_VDO1_DISP_PADDING2_SOF	650
+#define CMDQ_EVENT_VDO1_DISP_PADDING3_SOF	651
+#define CMDQ_EVENT_VDO1_DISP_PADDING4_SOF	652
+#define CMDQ_EVENT_VDO1_DISP_PADDING5_SOF	653
+#define CMDQ_EVENT_VDO1_DISP_PADDING6_SOF	654
+#define CMDQ_EVENT_VDO1_DISP_PADDING7_SOF	655
+#define CMDQ_EVENT_VDO1_DISP_RSZ0_SOF	656
+#define CMDQ_EVENT_VDO1_DISP_RSZ1_SOF	657
+#define CMDQ_EVENT_VDO1_DISP_RSZ2_SOF	658
+#define CMDQ_EVENT_VDO1_DISP_RSZ3_SOF	659
+#define CMDQ_EVENT_VDO1_VPP_MERGE0_SOF	660
+#define CMDQ_EVENT_VDO1_VPP_MERGE1_SOF	661
+#define CMDQ_EVENT_VDO1_VPP_MERGE2_SOF	662
+#define CMDQ_EVENT_VDO1_VPP_MERGE3_SOF	663
+#define CMDQ_EVENT_VDO1_VPP_MERGE4_SOF	664
+#define CMDQ_EVENT_VDO1_VPP2_DL_RELAY_SOF	665
+#define CMDQ_EVENT_VDO1_VPP3_DL_RELAY_SOF	666
+#define CMDQ_EVENT_VDO0_DSC_DL_ASYNC_SOF	667
+#define CMDQ_EVENT_VDO0_MERGE_DL_ASYNC_SOF		668
+#define CMDQ_EVENT_VDO1_OUT_DL_RELAY_SOF	669
+#define CMDQ_EVENT_VDO1_DISP_MIXER_SOF	670
+#define CMDQ_EVENT_VDO1_HDR_VDO_FE0_SOF		671
+#define CMDQ_EVENT_VDO1_HDR_VDO_FE1_SOF		672
+#define CMDQ_EVENT_VDO1_HDR_GFX_FE0_SOF		673
+#define CMDQ_EVENT_VDO1_HDR_GFX_FE1_SOF		674
+#define CMDQ_EVENT_VDO1_HDR_VDO_BE0_SOF		675
+#define CMDQ_EVENT_VDO1_HDR_MLOAD_SOF	676
+#define CMDQ_EVENT_VDO1_DPI0_EXT_SOF		677
+#define CMDQ_EVENT_VDO1_DPI1_EXT_SOF		678
+#define CMDQ_EVENT_VDO1_DP_INTF_EXT_EXT_SOF		679
+#define CMDQ_EVENT_VDO1_MDP_RDMA0_FRAME_DONE		680
+#define CMDQ_EVENT_VDO1_MDP_RDMA1_FRAME_DONE		681
+#define CMDQ_EVENT_VDO1_MDP_RDMA2_FRAME_DONE		682
+#define CMDQ_EVENT_VDO1_MDP_RDMA3_FRAME_DONE		683
+#define CMDQ_EVENT_VDO1_MDP_RDMA4_FRAME_DONE		684
+#define CMDQ_EVENT_VDO1_MDP_RDMA5_FRAME_DONE		685
+#define CMDQ_EVENT_VDO1_MDP_RDMA6_FRAME_DONE		686
+#define CMDQ_EVENT_VDO1_MDP_RDMA7_FRAME_DONE		687
+#define CMDQ_EVENT_VDO1_DISP_PADDING0_FRAME_DONE		688
+#define CMDQ_EVENT_VDO1_DISP_PADDING1_FRAME_DONE		689
+#define CMDQ_EVENT_VDO1_DISP_PADDING2_FRAME_DONE		690
+#define CMDQ_EVENT_VDO1_DISP_PADDING3_FRAME_DONE		691
+#define CMDQ_EVENT_VDO1_DISP_PADDING4_FRAME_DONE		692
+#define CMDQ_EVENT_VDO1_DISP_PADDING5_FRAME_DONE		693
+#define CMDQ_EVENT_VDO1_DISP_PADDING6_FRAME_DONE		694
+#define CMDQ_EVENT_VDO1_DISP_PADDING7_FRAME_DONE		695
+#define CMDQ_EVENT_VDO1_DISP_RSZ0_FRAME_DONE		696
+#define CMDQ_EVENT_VDO1_DISP_RSZ1_FRAME_DONE		697
+#define CMDQ_EVENT_VDO1_DISP_RSZ2_FRAME_DONE		698
+#define CMDQ_EVENT_VDO1_DISP_RSZ3_FRAME_DONE		699
+#define CMDQ_EVENT_VDO1_VPP_MERGE0_FRAME_DONE	700
+#define CMDQ_EVENT_VDO1_VPP_MERGE1_FRAME_DONE	701
+#define CMDQ_EVENT_VDO1_VPP_MERGE2_FRAME_DONE	702
+#define CMDQ_EVENT_VDO1_VPP_MERGE3_FRAME_DONE	703
+#define CMDQ_EVENT_VDO1_VPP_MERGE4_FRAME_DONE	704
+#define CMDQ_EVENT_VDO1_DPI0_FRAME_DONE			705
+#define CMDQ_EVENT_VDO1_DPI1_FRAME_DONE			706
+#define CMDQ_EVENT_VDO1_DP_INTF0_FRAME_DONE		707
+#define CMDQ_EVENT_VDO1_DISP_MIXER_FRAME_DONE_MM	708
+
+#define CMDQ_EVENT_VDO1_STREAM_DONE_ENG_0	709
+#define CMDQ_EVENT_VDO1_STREAM_DONE_ENG_1	710
+#define CMDQ_EVENT_VDO1_STREAM_DONE_ENG_2	711
+#define CMDQ_EVENT_VDO1_STREAM_DONE_ENG_3	712
+#define CMDQ_EVENT_VDO1_STREAM_DONE_ENG_4	713
+#define CMDQ_EVENT_VDO1_STREAM_DONE_ENG_5	714
+#define CMDQ_EVENT_VDO1_STREAM_DONE_ENG_6	715
+#define CMDQ_EVENT_VDO1_STREAM_DONE_ENG_7	716
+#define CMDQ_EVENT_VDO1_STREAM_DONE_ENG_8	717
+#define CMDQ_EVENT_VDO1_STREAM_DONE_ENG_9	718
+#define CMDQ_EVENT_VDO1_STREAM_DONE_ENG_10	719
+#define CMDQ_EVENT_VDO1_STREAM_DONE_ENG_11	720
+#define CMDQ_EVENT_VDO1_STREAM_DONE_ENG_12	721
+#define CMDQ_EVENT_VDO1_STREAM_DONE_ENG_13	722
+#define CMDQ_EVENT_VDO1_STREAM_DONE_ENG_14	723
+#define CMDQ_EVENT_VDO1_STREAM_DONE_ENG_15	724
+#define CMDQ_EVENT_VDO1_DISP_RDMA_0_UNDERRUN	725
+#define CMDQ_EVENT_VDO1_DISP_RDMA_1_UNDERRUN 726
+#define CMDQ_EVENT_VDO1_U_MERGE4_UNDERRUN	727
+#define CMDQ_EVENT_VDO1_U_VPP_SPLIT_VIDEO_0_OVERFLOW 728
+#define CMDQ_EVENT_VDO1_U_VPP_SPLIT_VIDEO_1_OVERFLOW 729
+#define CMDQ_EVENT_VDO1_DSI_0_UNDERRUN 730
+#define CMDQ_EVENT_VDO1_DSI_1_UNDERRUN 731
+#define CMDQ_EVENT_VDO1_DP_INTF_0	732
+#define CMDQ_EVENT_VDO1_DP_INTF_1	733
+#define CMDQ_EVENT_VDO1_DPI_0	734
+#define CMDQ_EVENT_VDO1_DPI_1	735
+#define CMDQ_EVENT_VDO1_MDP_RDMA0_SW_RST_DONE	741
+#define CMDQ_EVENT_VDO1_MDP_RDMA1_SW_RST_DONE	742
+#define CMDQ_EVENT_VDO1_MDP_RDMA2_SW_RST_DONE	743
+#define CMDQ_EVENT_VDO1_MDP_RDMA3_SW_RST_DONE	744
+#define CMDQ_EVENT_VDO1_MDP_RDMA4_SW_RST_DONE	745
+#define CMDQ_EVENT_VDO1_MDP_RDMA5_SW_RST_DONE	746
+#define CMDQ_EVENT_VDO1_MDP_RDMA6_SW_RST_DONE	747
+#define CMDQ_EVENT_VDO1_MDP_RDMA7_SW_RST_DONE	748
+#define CMDQ_EVENT_VDO1_DP0_VDE_END_ENG_EVENT_MM	749
+#define CMDQ_EVENT_VDO1_DP0_VDE_START_ENG_EVENT_MM	750
+#define CMDQ_EVENT_VDO1_DP0_VSYNC_END_ENG_EVENT_MM	751
+#define CMDQ_EVENT_VDO1_DP0_VSYNC_START_ENG_EVENT_MM 752
+#define CMDQ_EVENT_VDO1_DP0_TARGET_LINE_ENG_EVENT_MM	753
+#define CMDQ_EVENT_VDO1_VPP_MERGE0_EVENT		754
+#define CMDQ_EVENT_VDO1_VPP_MERGE1_EVENT		755
+#define CMDQ_EVENT_VDO1_VPP_MERGE2_EVENT		756
+#define CMDQ_EVENT_VDO1_VPP_MERGE3_EVENT		757
+#define CMDQ_EVENT_VDO1_VPP_MERGE4_EVENT		758
+#define CMDQ_EVENT_VDO1_HDMITX_EVENT			759
+#define CMDQ_EVENT_VDO1_HDR_VDO_BE0_ADL_TRIG_EVENT_MM		760
+#define CMDQ_EVENT_VDO1_HDR_GFX_FE1_THDR_ADL_TRIG_EVENT_MM	761
+#define CMDQ_EVENT_VDO1_HDR_GFX_FE1_DM_ADL_TRIG_EVENT_MM		762
+#define CMDQ_EVENT_VDO1_HDR_GFX_FE0_THDR_ADL_TRIG_EVENT_MM	763
+#define CMDQ_EVENT_VDO1_HDR_GFX_FE0_DM_ADL_TRIG_EVENT_MM		764
+#define CMDQ_EVENT_VDO1_HDR_VDO_FE1_ADL_TRIG_EVENT_MM		765
+#define CMDQ_EVENT_VDO1_HDR_VDO_FE1_AD0_TRIG_EVENT_MM		766
+#define CMDQ_EVENT_VDO1_DPI0_TARGET_LINE_1_EVENT_MM			767
+#define CMDQ_EVENT_HANDSHAKE_0		768
+#define CMDQ_EVENT_HANDSHAKE_1		769
+#define CMDQ_EVENT_HANDSHAKE_2		770
+#define CMDQ_EVENT_HANDSHAKE_3		771
+#define CMDQ_EVENT_HANDSHAKE_4		772
+#define CMDQ_EVENT_HANDSHAKE_5		773
+#define CMDQ_EVENT_HANDSHAKE_6		774
+#define CMDQ_EVENT_HANDSHAKE_7		775
+#define CMDQ_EVENT_HANDSHAKE_8		776
+#define CMDQ_EVENT_HANDSHAKE_9		777
+#define CMDQ_EVENT_HANDSHAKE_10		778
+#define CMDQ_EVENT_HANDSHAKE_11		779
+#define CMDQ_EVENT_HANDSHAKE_12		780
+#define CMDQ_EVENT_HANDSHAKE_13		781
+#define CMDQ_EVENT_HANDSHAKE_14		782
+#define CMDQ_EVENT_HANDSHAKE_15		783
+#define CMDQ_EVENT_VDEC_SOC_EVENT_0		800
+#define CMDQ_EVENT_VDEC_SOC_EVENT_1		801
+#define CMDQ_EVENT_VDEC_SOC_EVENT_2		802
+#define CMDQ_EVENT_VDEC_SOC_EVENT_3		803
+#define CMDQ_EVENT_VDEC_SOC_EVENT_4		804
+#define CMDQ_EVENT_VDEC_SOC_EVENT_5		805
+#define CMDQ_EVENT_VDEC_SOC_EVENT_6		806
+#define CMDQ_EVENT_VDEC_SOC_EVENT_7		807
+#define CMDQ_EVENT_VDEC_SOC_EVENT_8		808
+#define CMDQ_EVENT_VDEC_SOC_EVENT_9		809
+#define CMDQ_EVENT_VDEC_SOC_EVENT_10	810
+#define CMDQ_EVENT_VDEC_SOC_EVENT_11	811
+#define CMDQ_EVENT_VDEC_SOC_EVENT_12	812
+#define CMDQ_EVENT_VDEC_SOC_EVENT_13	813
+#define CMDQ_EVENT_VDEC_SOC_EVENT_14	814
+#define CMDQ_EVENT_VDEC_SOC_EVENT_15	815
+#define CMDQ_EVENT_VDEC_CORE0_EVENT_0	832
+#define CMDQ_EVENT_VDEC_CORE0_EVENT_1	833
+#define CMDQ_EVENT_VDEC_CORE0_EVENT_2	834
+#define CMDQ_EVENT_VDEC_CORE0_EVENT_3	835
+#define CMDQ_EVENT_VDEC_CORE0_EVENT_4	836
+#define CMDQ_EVENT_VDEC_CORE0_EVENT_5	837
+#define CMDQ_EVENT_VDEC_CORE0_EVENT_6	838
+#define CMDQ_EVENT_VDEC_CORE0_EVENT_7	839
+#define CMDQ_EVENT_VDEC_CORE0_EVENT_8	840
+#define CMDQ_EVENT_VDEC_CORE0_EVENT_9	841
+#define CMDQ_EVENT_VDEC_CORE0_EVENT_10	842
+#define CMDQ_EVENT_VDEC_CORE0_EVENT_11	843
+#define CMDQ_EVENT_VDEC_CORE0_EVENT_12	844
+#define CMDQ_EVENT_VDEC_CORE0_EVENT_13	845
+#define CMDQ_EVENT_VDEC_CORE0_EVENT_14	846
+#define CMDQ_EVENT_VDEC_CORE0_EVENT_15	847
+
+#define CMDQ_EVENT_VENC_TOP_VENC_FRAME_DONE		865
+#define CMDQ_EVENT_VENC_TOP_VENC_PAUSE_DONE		866
+#define CMDQ_EVENT_VENC_TOP_JPGENC_DONE			867
+#define CMDQ_EVENT_VENC_TOP_VENC_MB_DONE		868
+#define CMDQ_EVENT_VENC_TOP_VENC_128BYTE_DONE	869
+#define CMDQ_EVENT_VENC_TOP_JPGDEC_DONE			870
+#define CMDQ_EVENT_VENC_TOP_VENC_SLICE_DONE		871
+#define CMDQ_EVENT_VENC_TOP_JPGDEC_INSUFF_DONE		872
+
+#define CMDQ_EVENT_VENC_TOP_WP_2ND_STAGE_DONE	874
+#define CMDQ_EVENT_VENC_TOP_WP_3RD_STAGE_DONE	875
+#define CMDQ_EVENT_VENC_TOP_PPS_HEADER_DONE		876
+#define CMDQ_EVENT_VENC_TOP_SPS_HEADER_DONE		877
+#define CMDQ_EVENT_VENC_TOP_VPS_HEADER_DONE		878
+
+#define CMDQ_EVENT_WPE_VPP0_WPE_GCE_FRAME_DONE		882
+#define CMDQ_EVENT_WPE_VPP0_WPE_DONE_SYNC_OUT		883
+
+#define CMDQ_EVENT_SVPP1_MDP_OVL_NEW_EVENT_2	896
+#define CMDQ_EVENT_SVPP1_MDP_OVL_NEW_EVENT_3	897
+#define CMDQ_EVENT_SVPP1_MDP_OVL_NEW_EVENT_4	898
+#define CMDQ_EVENT_SVPP1_MDP_OVL_NEW_EVENT_5	899
+#define CMDQ_EVENT_SVPP1_MDP_OVL_NEW_EVENT_6	900
+
+#define CMDQ_EVENT_VDO1_DPI0_TARGET_LINE_0_EVENT_MM		928
+#define CMDQ_EVENT_VDO1_DPI0_TRIGGER_LOOP_CLEAR_EVENT_MM	929
+#define CMDQ_EVENT_VDO1_DPI0_LAST_LINE_EVENT_MM		930
+#define CMDQ_EVENT_VDO1_DPI0_LAST_SAFE_BLANK_EVENT_MM	931
+#define CMDQ_EVENT_VDO1_DPI0_VSYNC_START_EVENT_MM	932
+#define CMDQ_EVENT_VDO1_DPI1_TARGET_LINE_1_EVENT_MM		933
+#define CMDQ_EVENT_VDO1_DPI1_TARGET_LINE_0_EVENT_MM		934
+#define CMDQ_EVENT_VDO1_DPI1_TRIGGER_LOOP_CLEAR_EVENT_MM		935
+#define CMDQ_EVENT_VDO1_DPI1_LAST_LINE_EVENT_MM		936
+#define CMDQ_EVENT_VDO1_DPI1_LAST_SAFE_BLANK_EVENT_MM	937
+#define CMDQ_EVENT_VDO1_DPI1_VSYNC_START_EVENT_MM	938
+#define CMDQ_EVENT_VDO1_DP_INTF_TARGET_LINE_1_EVENT_MM	939
+#define CMDQ_EVENT_VDO1_DP_INTF_TARGET_LINE_0_EVENT_MM	940
+#define CMDQ_EVENT_VDO1_DP_INTF_TRIGGER_LOOP_CLEAR_EVENT_MM		941
+#define CMDQ_EVENT_VDO1_DP_INTF_LAST_LINE_EVENT_MM	942
+#define CMDQ_EVENT_VDO1_DP_INTF_LAST_SAFE_BLANK_EVENT_MM		943
+#define CMDQ_EVENT_VBLANK_FALLING	946
+#define CMDQ_EVENT_VSC_FINISH	 947
+#define CMDQ_EVENT_TPR_0		962
+#define CMDQ_EVENT_TPR_1		963
+#define CMDQ_EVENT_TPR_2		964
+#define CMDQ_EVENT_TPR_3		965
+#define CMDQ_EVENT_TPR_4		966
+#define CMDQ_EVENT_TPR_5		967
+#define CMDQ_EVENT_TPR_6		968
+#define CMDQ_EVENT_TPR_7		969
+#define CMDQ_EVENT_TPR_8		970
+#define CMDQ_EVENT_TPR_9		971
+#define CMDQ_EVENT_TPR_10		972
+#define CMDQ_EVENT_TPR_11		973
+#define CMDQ_EVENT_TPR_12		974
+#define CMDQ_EVENT_TPR_13		975
+#define CMDQ_EVENT_TPR_14		976
+#define CMDQ_EVENT_TPR_15		977
+#define CMDQ_EVENT_TPR_16		978
+#define CMDQ_EVENT_TPR_17		979
+#define CMDQ_EVENT_TPR_18		980
+#define CMDQ_EVENT_TPR_19		981
+#define CMDQ_EVENT_TPR_20		982
+#define CMDQ_EVENT_TPR_21		983
+#define CMDQ_EVENT_TPR_22		984
+#define CMDQ_EVENT_TPR_23		985
+#define CMDQ_EVENT_TPR_24		986
+#define CMDQ_EVENT_TPR_25		987
+#define CMDQ_EVENT_TPR_26		988
+#define CMDQ_EVENT_TPR_27		989
+#define CMDQ_EVENT_TPR_28		990
+#define CMDQ_EVENT_TPR_29		991
+#define CMDQ_EVENT_TPR_30		992
+#define CMDQ_EVENT_TPR_31		993
+
+/* Event for gpr timer, used in sleep and poll with timeout */
+#define CMDQ_EVENT_TPR_TIMEOUT_0	994
+#define CMDQ_EVENT_TPR_TIMEOUT_1	995
+#define CMDQ_EVENT_TPR_TIMEOUT_2	996
+#define CMDQ_EVENT_TPR_TIMEOUT_3	997
+#define CMDQ_EVENT_TPR_TIMEOUT_4	998
+#define CMDQ_EVENT_TPR_TIMEOUT_5	999
+#define CMDQ_EVENT_TPR_TIMEOUT_6	1000
+#define CMDQ_EVENT_TPR_TIMEOUT_7	1001
+#define CMDQ_EVENT_TPR_TIMEOUT_8	1002
+#define CMDQ_EVENT_TPR_TIMEOUT_9	1003
+#define CMDQ_EVENT_TPR_TIMEOUT_10	1004
+#define CMDQ_EVENT_TPR_TIMEOUT_11	1005
+#define CMDQ_EVENT_TPR_TIMEOUT_12	1006
+#define CMDQ_EVENT_TPR_TIMEOUT_13	1007
+#define CMDQ_EVENT_TPR_TIMEOUT_14	1008
+#define CMDQ_EVENT_TPR_TIMEOUT_15	1009
+
+#define CMDQ_EVENT_OUTPIN_0	1018 /* exception */
+#define CMDQ_EVENT_OUTPIN_1	1019 /* exception */
+
+/* end of hw event */
+#define CMDQ_MAX_HW_EVENT				1019
+
+/* sw token should use the unused event id from 0 to 1023 */
+#define CMDQ_SYNC_TOKEN_INVALID				(-1)
+
+/* Event for imgsys flow control */
+#define CMDQ_SYNC_TOKEN_IMGSYS_WPE_EIS			124
+#define CMDQ_SYNC_TOKEN_IMGSYS_WPE_TNR			125
+#define CMDQ_SYNC_TOKEN_IMGSYS_WPE_LITE		126
+#define CMDQ_SYNC_TOKEN_IMGSYS_TRAW			127
+#define CMDQ_SYNC_TOKEN_IMGSYS_LTRAW			128
+
+#define CMDQ_SYNC_TOKEN_CAMSYS_POOL_1			223
+#define CMDQ_SYNC_TOKEN_CAMSYS_POOL_2			224
+#define CMDQ_SYNC_TOKEN_CAMSYS_POOL_3			225
+#define CMDQ_SYNC_TOKEN_CAMSYS_POOL_4			226
+#define CMDQ_SYNC_TOKEN_CAMSYS_POOL_5			227
+#define CMDQ_SYNC_TOKEN_CAMSYS_POOL_6			228
+#define CMDQ_SYNC_TOKEN_CAMSYS_POOL_7			229
+#define CMDQ_SYNC_TOKEN_CAMSYS_POOL_8			230
+#define CMDQ_SYNC_TOKEN_CAMSYS_POOL_9			231
+#define CMDQ_SYNC_TOKEN_CAMSYS_POOL_10			232
+
+#define CMDQ_SYNC_TOKEN_IMGSYS_XTRAW			233
+#define CMDQ_SYNC_TOKEN_IMGSYS_DIP			234
+#define CMDQ_SYNC_TOKEN_IMGSYS_PQDIP_A			235
+#define CMDQ_SYNC_TOKEN_IMGSYS_PQDIP_B			236
+
+#define CMDQ_SYNC_TOKEN_IMGSYS_POOL_1			237
+#define CMDQ_SYNC_TOKEN_IMGSYS_POOL_2			238
+#define CMDQ_SYNC_TOKEN_IMGSYS_POOL_3			239
+#define CMDQ_SYNC_TOKEN_IMGSYS_POOL_4			240
+#define CMDQ_SYNC_TOKEN_IMGSYS_POOL_5			241
+#define CMDQ_SYNC_TOKEN_IMGSYS_POOL_6			242
+#define CMDQ_SYNC_TOKEN_IMGSYS_POOL_7			243
+#define CMDQ_SYNC_TOKEN_IMGSYS_POOL_8			244
+#define CMDQ_SYNC_TOKEN_IMGSYS_POOL_9			245
+#define CMDQ_SYNC_TOKEN_IMGSYS_POOL_10			246
+#define CMDQ_SYNC_TOKEN_IMGSYS_POOL_11			247
+#define CMDQ_SYNC_TOKEN_IMGSYS_POOL_12			248
+#define CMDQ_SYNC_TOKEN_IMGSYS_POOL_13			249
+#define CMDQ_SYNC_TOKEN_IMGSYS_POOL_14			250
+#define CMDQ_SYNC_TOKEN_IMGSYS_POOL_15			251
+#define CMDQ_SYNC_TOKEN_IMGSYS_POOL_16			252
+#define CMDQ_SYNC_TOKEN_IMGSYS_POOL_17			253
+#define CMDQ_SYNC_TOKEN_IMGSYS_POOL_18			254
+#define CMDQ_SYNC_TOKEN_IMGSYS_POOL_19			255
+
+#define CMDQ_SYNC_TOKEN_IMGSYS_POOL_20			276
+#define CMDQ_SYNC_TOKEN_IMGSYS_POOL_21			277
+#define CMDQ_SYNC_TOKEN_IMGSYS_POOL_22			278
+#define CMDQ_SYNC_TOKEN_IMGSYS_POOL_23			279
+#define CMDQ_SYNC_TOKEN_IMGSYS_POOL_24			280
+#define CMDQ_SYNC_TOKEN_IMGSYS_POOL_25			281
+#define CMDQ_SYNC_TOKEN_IMGSYS_POOL_26			282
+#define CMDQ_SYNC_TOKEN_IMGSYS_POOL_27			283
+#define CMDQ_SYNC_TOKEN_IMGSYS_POOL_28			284
+#define CMDQ_SYNC_TOKEN_IMGSYS_POOL_29			285
+#define CMDQ_SYNC_TOKEN_IMGSYS_POOL_30			286
+#define CMDQ_SYNC_TOKEN_IMGSYS_POOL_31			287
+
+#define CMDQ_SYNC_TOKEN_IPESYS_ME			300
+#define CMDQ_SYNC_TOKEN_IMGSYS_VSS_TRAW			301
+#define CMDQ_SYNC_TOKEN_IMGSYS_VSS_LTRAW		302
+#define CMDQ_SYNC_TOKEN_IMGSYS_VSS_XTRAW		303
+#define CMDQ_SYNC_TOKEN_IMGSYS_VSS_DIP			304
+
+#define CMDQ_SYNC_TOKEN_IMGSYS_POOL_32			308
+#define CMDQ_SYNC_TOKEN_IMGSYS_POOL_33			309
+#define CMDQ_SYNC_TOKEN_IMGSYS_POOL_34			310
+#define CMDQ_SYNC_TOKEN_IMGSYS_POOL_35			311
+#define CMDQ_SYNC_TOKEN_IMGSYS_POOL_36			312
+#define CMDQ_SYNC_TOKEN_IMGSYS_POOL_37			313
+#define CMDQ_SYNC_TOKEN_IMGSYS_POOL_38			314
+#define CMDQ_SYNC_TOKEN_IMGSYS_POOL_39			315
+#define CMDQ_SYNC_TOKEN_IMGSYS_POOL_40			316
+
+#define CMDQ_SYNC_TOKEN_IMGSYS_POOL_41			370
+#define CMDQ_SYNC_TOKEN_IMGSYS_POOL_42			371
+#define CMDQ_SYNC_TOKEN_IMGSYS_POOL_43			372
+#define CMDQ_SYNC_TOKEN_IMGSYS_POOL_44			373
+#define CMDQ_SYNC_TOKEN_IMGSYS_POOL_45			374
+#define CMDQ_SYNC_TOKEN_IMGSYS_POOL_46			375
+#define CMDQ_SYNC_TOKEN_IMGSYS_POOL_47			376
+#define CMDQ_SYNC_TOKEN_IMGSYS_POOL_48			377
+#define CMDQ_SYNC_TOKEN_IMGSYS_POOL_49			378
+#define CMDQ_SYNC_TOKEN_IMGSYS_POOL_50			379
+
+#define CMDQ_SYNC_TOKEN_TZMP_ISP_WAIT			380
+#define CMDQ_SYNC_TOKEN_TZMP_ISP_SET			381
+
+#define CMDQ_SYNC_TOKEN_IMGSYS_POOL_51			790
+#define CMDQ_SYNC_TOKEN_IMGSYS_POOL_52			791
+#define CMDQ_SYNC_TOKEN_IMGSYS_POOL_53			792
+#define CMDQ_SYNC_TOKEN_IMGSYS_POOL_54			793
+#define CMDQ_SYNC_TOKEN_IMGSYS_POOL_55			794
+#define CMDQ_SYNC_TOKEN_IMGSYS_POOL_56			795
+#define CMDQ_SYNC_TOKEN_IMGSYS_POOL_57			796
+#define CMDQ_SYNC_TOKEN_IMGSYS_POOL_58			797
+#define CMDQ_SYNC_TOKEN_IMGSYS_POOL_59			798
+#define CMDQ_SYNC_TOKEN_IMGSYS_POOL_60			799
+
+/* SW token for ATF prebuilt */
+#define CMDQ_SYNC_TOKEN_PREBUILT_MDP_WAIT			816
+#define CMDQ_SYNC_TOKEN_PREBUILT_MDP_SET			817
+#define CMDQ_SYNC_TOKEN_PREBUILT_MDP_LOCK			818
+#define CMDQ_SYNC_TOKEN_PREBUILT_MML_WAIT			819
+#define CMDQ_SYNC_TOKEN_PREBUILT_MML_SET			820
+#define CMDQ_SYNC_TOKEN_PREBUILT_MML_LOCK			821
+#define CMDQ_SYNC_TOKEN_PREBUILT_VFMT_WAIT			822
+#define CMDQ_SYNC_TOKEN_PREBUILT_VFMT_SET			823
+#define CMDQ_SYNC_TOKEN_PREBUILT_VFMT_LOCK			824
+#define CMDQ_SYNC_TOKEN_PREBUILT_DISP_WAIT			825
+#define CMDQ_SYNC_TOKEN_PREBUILT_DISP_SET			826
+#define CMDQ_SYNC_TOKEN_PREBUILT_DISP_LOCK			827
+
+/* Config thread notify trigger thread */
+#define CMDQ_SYNC_TOKEN_CONFIG_DIRTY			848
+/* Trigger thread notify config thread */
+#define CMDQ_SYNC_TOKEN_STREAM_EOF			849
+/* Block Trigger thread until the ESD check finishes. */
+#define CMDQ_SYNC_TOKEN_ESD_EOF				850
+#define CMDQ_SYNC_TOKEN_STREAM_BLOCK			851
+/* check CABC setup finish */
+#define CMDQ_SYNC_TOKEN_CABC_EOF			852
+/* Pass-2 notifies VENC frame is ready to be encoded */
+#define CMDQ_SYNC_TOKEN_VENC_INPUT_READY		853
+/* VENC notifies Pass-2 encode done so next frame may start */
+#define CMDQ_SYNC_TOKEN_VENC_EOF			854
+
+/* Notify normal CMDQ there are some secure task done
+ * MUST NOT CHANGE, this token sync with secure world
+ */
+#define CMDQ_SYNC_TOKEN_SECURE_THR_EOF			855
+
+/* CMDQ use sw token */
+#define CMDQ_SYNC_TOKEN_USER_0				856
+#define CMDQ_SYNC_TOKEN_USER_1				857
+#define CMDQ_SYNC_TOKEN_POLL_MONITOR			858
+#define CMDQ_TOKEN_TPR_LOCK			859
+
+/* ISP sw token */
+#define CMDQ_SYNC_TOKEN_MSS				860
+#define CMDQ_SYNC_TOKEN_MSF				861
+
+/* GPR access tokens (for register backup)
+ * There are 15 32-bit GPR, 3 GPR form a set
+ * (64-bit for address, 32-bit for value)
+ * MUST NOT CHANGE, these tokens sync with MDP
+ */
+#define CMDQ_SYNC_TOKEN_GPR_SET_0			884
+#define CMDQ_SYNC_TOKEN_GPR_SET_1			885
+#define CMDQ_SYNC_TOKEN_GPR_SET_2			886
+#define CMDQ_SYNC_TOKEN_GPR_SET_3			887
+#define CMDQ_SYNC_TOKEN_GPR_SET_4			888
+
+/* Resource lock event to control resource in GCE thread */
+#define CMDQ_SYNC_RESOURCE_WROT0			889
+#define CMDQ_SYNC_RESOURCE_WROT1			890
+
+/* SW token for ATF display va */
+#define CMDQ_SYNC_TOKEN_DISP_VA_START		1012
+#define CMDQ_SYNC_TOKEN_DISP_VA_END			1013
+
+/* end of hw event */
+//#define CMDQ_MAX_HW_EVENT					1013
+#endif
diff --git a/include/dt-bindings/reset/mt8188-resets.h b/include/dt-bindings/reset/mt8188-resets.h
index ba9a5e9b889981d6191bc55468ce49566a515897..5a58c54e7d200cae37b8bfc205c472919368be82 100644
--- a/include/dt-bindings/reset/mt8188-resets.h
+++ b/include/dt-bindings/reset/mt8188-resets.h
@@ -38,4 +38,79 @@
 #define MT8188_INFRA_RST1_THERMAL_CTRL_RST         1
 #define MT8188_INFRA_RST3_PTP_CTRL_RST             2
 
+#define MT8188_VDO0_RST_DISP_OVL0		0
+#define MT8188_VDO0_RST_FAKE_ENG0		1
+#define MT8188_VDO0_RST_DISP_CCORR0		2
+#define MT8188_VDO0_RST_DISP_MUTEX0		3
+#define MT8188_VDO0_RST_DISP_GAMMA0		4
+#define MT8188_VDO0_RST_DISP_DITHER0		5
+#define MT8188_VDO0_RST_DISP_WDMA0		6
+#define MT8188_VDO0_RST_DISP_RDMA0		7
+#define MT8188_VDO0_RST_DSI0			8
+#define MT8188_VDO0_RST_DSI1			9
+#define MT8188_VDO0_RST_DSC_WRAP0		10
+#define MT8188_VDO0_RST_VPP_MERGE0		11
+#define MT8188_VDO0_RST_DP_INTF0		12
+#define MT8188_VDO0_RST_DISP_AAL0		13
+#define MT8188_VDO0_RST_INLINEROT0		14
+#define MT8188_VDO0_RST_APB_BUS			15
+#define MT8188_VDO0_RST_DISP_COLOR0		16
+#define MT8188_VDO0_RST_MDP_WROT0		17
+#define MT8188_VDO0_RST_DISP_RSZ0		18
+
+#define MT8188_VDO1_RST_SMI_LARB2		0
+#define MT8188_VDO1_RST_SMI_LARB3		1
+#define MT8188_VDO1_RST_GALS			2
+#define MT8188_VDO1_RST_FAKE_ENG0		3
+#define MT8188_VDO1_RST_FAKE_ENG1		4
+#define MT8188_VDO1_RST_MDP_RDMA0		5
+#define MT8188_VDO1_RST_MDP_RDMA1		6
+#define MT8188_VDO1_RST_MDP_RDMA2		7
+#define MT8188_VDO1_RST_MDP_RDMA3		8
+#define MT8188_VDO1_RST_VPP_MERGE0		9
+#define MT8188_VDO1_RST_VPP_MERGE1		10
+#define MT8188_VDO1_RST_VPP_MERGE2		11
+#define MT8188_VDO1_RST_VPP_MERGE3		12
+#define MT8188_VDO1_RST_VPP_MERGE4		13
+#define MT8188_VDO1_RST_VPP2_TO_VDO1_DL_ASYNC	14
+#define MT8188_VDO1_RST_VPP3_TO_VDO1_DL_ASYNC	15
+#define MT8188_VDO1_RST_DISP_MUTEX		16
+#define MT8188_VDO1_RST_MDP_RDMA4		17
+#define MT8188_VDO1_RST_MDP_RDMA5		18
+#define MT8188_VDO1_RST_MDP_RDMA6		19
+#define MT8188_VDO1_RST_MDP_RDMA7		20
+#define MT8188_VDO1_RST_DP_INTF1_MMCK		21
+#define MT8188_VDO1_RST_DPI0_MM_CK		22
+#define MT8188_VDO1_RST_DPI1_MM_CK		23
+#define MT8188_VDO1_RST_MERGE0_DL_ASYNC		24
+#define MT8188_VDO1_RST_MERGE1_DL_ASYNC		25
+#define MT8188_VDO1_RST_MERGE2_DL_ASYNC		26
+#define MT8188_VDO1_RST_MERGE3_DL_ASYNC		27
+#define MT8188_VDO1_RST_MERGE4_DL_ASYNC		28
+#define MT8188_VDO1_RST_VDO0_DSC_TO_VDO1_DL_ASYNC	29
+#define MT8188_VDO1_RST_VDO0_MERGE_TO_VDO1_DL_ASYNC	30
+#define MT8188_VDO1_RST_PADDING0		31
+#define MT8188_VDO1_RST_PADDING1		32
+#define MT8188_VDO1_RST_PADDING2		33
+#define MT8188_VDO1_RST_PADDING3		34
+#define MT8188_VDO1_RST_PADDING4		35
+#define MT8188_VDO1_RST_PADDING5		36
+#define MT8188_VDO1_RST_PADDING6		37
+#define MT8188_VDO1_RST_PADDING7		38
+#define MT8188_VDO1_RST_DISP_RSZ0		39
+#define MT8188_VDO1_RST_DISP_RSZ1		40
+#define MT8188_VDO1_RST_DISP_RSZ2		41
+#define MT8188_VDO1_RST_DISP_RSZ3		42
+#define MT8188_VDO1_RST_HDR_VDO_FE0		43
+#define MT8188_VDO1_RST_HDR_GFX_FE0		44
+#define MT8188_VDO1_RST_HDR_VDO_BE		45
+#define MT8188_VDO1_RST_HDR_VDO_FE1		46
+#define MT8188_VDO1_RST_HDR_GFX_FE1		47
+#define MT8188_VDO1_RST_DISP_MIXER		48
+#define MT8188_VDO1_RST_HDR_VDO_FE0_DL_ASYNC	49
+#define MT8188_VDO1_RST_HDR_VDO_FE1_DL_ASYNC	50
+#define MT8188_VDO1_RST_HDR_GFX_FE0_DL_ASYNC	51
+#define MT8188_VDO1_RST_HDR_GFX_FE1_DL_ASYNC	52
+#define MT8188_VDO1_RST_HDR_VDO_BE_DL_ASYNC	53
+
 #endif  /* _DT_BINDINGS_RESET_CONTROLLER_MT8188 */
diff --git a/include/linux/dma-heap.h b/include/linux/dma-heap.h
index 0c05561cad6e62b78af6d492b565f50db21e596f..a1a190ebc46117cc8c5da236a76100e256bda876 100644
--- a/include/linux/dma-heap.h
+++ b/include/linux/dma-heap.h
@@ -17,6 +17,7 @@ struct dma_heap;
 /**
  * struct dma_heap_ops - ops to operate on a given heap
  * @allocate:		allocate dmabuf and return struct dma_buf ptr
+ * @get_pool_size:	if heap maintains memory pools, get pool size in bytes
  *
  * allocate returns dmabuf on success, ERR_PTR(-errno) on error.
  */
@@ -25,6 +26,7 @@ struct dma_heap_ops {
 				    unsigned long len,
 				    unsigned long fd_flags,
 				    unsigned long heap_flags);
+	long (*get_pool_size)(struct dma_heap *heap);
 };
 
 /**
@@ -50,6 +52,15 @@ struct dma_heap_export_info {
  */
 void *dma_heap_get_drvdata(struct dma_heap *heap);
 
+/**
+ * dma_heap_get_dev() - get device struct for the heap
+ * @heap: DMA-Heap to retrieve device struct from
+ *
+ * Returns:
+ * The device struct for the heap.
+ */
+struct device *dma_heap_get_dev(struct dma_heap *heap);
+
 /**
  * dma_heap_get_name() - get heap name
  * @heap: DMA-Heap to retrieve private data for
@@ -65,4 +76,49 @@ const char *dma_heap_get_name(struct dma_heap *heap);
  */
 struct dma_heap *dma_heap_add(const struct dma_heap_export_info *exp_info);
 
+/**
+ * dma_heap_put - drops a reference to a dmabuf heaps, potentially freeing it
+ * @heap:		heap pointer
+ */
+void dma_heap_put(struct dma_heap *heap);
+
+/**
+ * dma_heap_find - Returns the registered dma_heap with the specified name
+ * @name: Name of the heap to find
+ *
+ * NOTE: dma_heaps returned from this function MUST be released
+ * using dma_heap_put() when the user is done.
+ */
+struct dma_heap *dma_heap_find(const char *name);
+
+/**
+ * dma_heap_buffer_alloc - Allocate dma-buf from a dma_heap
+ * @heap:	dma_heap to allocate from
+ * @len:	size to allocate
+ * @fd_flags:	flags to set on returned dma-buf fd
+ * @heap_flags:	flags to pass to the dma heap
+ *
+ * This is for internal dma-buf allocations only.
+ */
+struct dma_buf *dma_heap_buffer_alloc(struct dma_heap *heap, size_t len,
+				      unsigned int fd_flags,
+				      unsigned int heap_flags);
+
+/** dma_heap_buffer_free - Free dma_buf allocated by dma_heap_buffer_alloc
+ * @dma_buf:	dma_buf to free
+ *
+ * This is really only a simple wrapper to dma_buf_put()
+ */
+void dma_heap_buffer_free(struct dma_buf *);
+
+/**
+ * dma_heap_bufferfd_alloc - Allocate dma-buf fd from a dma_heap
+ * @heap:	dma_heap to allocate from
+ * @len:	size to allocate
+ * @fd_flags:	flags to set on returned dma-buf fd
+ * @heap_flags:	flags to pass to the dma heap
+ */
+int dma_heap_bufferfd_alloc(struct dma_heap *heap, size_t len,
+			    unsigned int fd_flags,
+			    unsigned int heap_flags);
 #endif /* _DMA_HEAPS_H */
diff --git a/include/linux/mailbox/mtk-cmdq-mailbox.h b/include/linux/mailbox/mtk-cmdq-mailbox.h
index a8f0070c7aa98f64c8f2578c88ce7cbd6f7dc426..07820868dbb7d131d6e82809bbaa832d3e25a4c5 100644
--- a/include/linux/mailbox/mtk-cmdq-mailbox.h
+++ b/include/linux/mailbox/mtk-cmdq-mailbox.h
@@ -21,6 +21,8 @@
 #define CMDQ_WFE_WAIT			BIT(15)
 #define CMDQ_WFE_WAIT_VALUE		0x1
 
+#define CMDQ_TIMEOUT_DEFAULT		1000
+
 /*
  * WFE arg_b
  * bit 0-11: wait value
@@ -54,6 +56,7 @@
  */
 enum cmdq_code {
 	CMDQ_CODE_MASK = 0x02,
+	CMDQ_CODE_MOVE = 0x02,
 	CMDQ_CODE_WRITE = 0x04,
 	CMDQ_CODE_POLL = 0x08,
 	CMDQ_CODE_JUMP = 0x10,
@@ -79,5 +82,7 @@ struct cmdq_pkt {
 };
 
 u8 cmdq_get_shift_pa(struct mbox_chan *chan);
+void cmdq_set_event(void *chan, u16 event_id);
+u32 cmdq_get_event(void *chan, u16 event_id);
 
 #endif /* __MTK_CMDQ_MAILBOX_H__ */
diff --git a/include/linux/pm_opp.h b/include/linux/pm_opp.h
index 19990b235b74e71c6c8d0ba1c44280406629134c..0c680470a79325eb0b1ebe3cb0fa17fc81a0403d 100644
--- a/include/linux/pm_opp.h
+++ b/include/linux/pm_opp.h
@@ -152,6 +152,10 @@ int dev_pm_opp_adjust_voltage(struct device *dev, unsigned long freq,
 			      unsigned long u_volt, unsigned long u_volt_min,
 			      unsigned long u_volt_max);
 
+int dev_pm_opp_adjust_voltage_supply(struct device *dev, unsigned long freq,
+			      unsigned long u_volt, unsigned long u_volt_min,
+			      unsigned long u_volt_max, unsigned int index);
+
 int dev_pm_opp_enable(struct device *dev, unsigned long freq);
 
 int dev_pm_opp_disable(struct device *dev, unsigned long freq);
diff --git a/include/linux/soc/mediatek/mtk-cmdq.h b/include/linux/soc/mediatek/mtk-cmdq.h
index 649955d2cf5cdd89de731d4b402d7bda22e0f93c..db829721da57f406c211d70189074abf9dc31078 100644
--- a/include/linux/soc/mediatek/mtk-cmdq.h
+++ b/include/linux/soc/mediatek/mtk-cmdq.h
@@ -11,6 +11,14 @@
 #include <linux/mailbox/mtk-cmdq-mailbox.h>
 #include <linux/timer.h>
 
+#define CMDQ_SPR_FOR_TEMP		0
+#define CMDQ_THR_SPR_IDX0		0
+#define CMDQ_THR_SPR_IDX1		1
+#define CMDQ_THR_SPR_IDX2		2
+#define CMDQ_THR_SPR_IDX3		3
+#define CMDQ_THR_SPR_MAX		4
+
+#define CMDQ_NO_MASK		GENMASK(31, 0)
 #define CMDQ_ADDR_HIGH(addr)	((u32)(((addr) >> 16) & GENMASK(31, 0)))
 #define CMDQ_ADDR_LOW(addr)	((u16)(addr) | BIT(1))
 
@@ -74,6 +82,18 @@ struct cmdq_pkt *cmdq_pkt_create(struct cmdq_client *client, size_t size);
  */
 void cmdq_pkt_destroy(struct cmdq_pkt *pkt);
 
+/**
+ * cmdq_pkt_mem_move() - append memory move command to the CMDQ packet
+ * @pkt:	the CMDQ packet
+ * @src_addr:	source address
+ * @dma_addr_t:	destination address
+ * @swap_reg_idx:	the temp register idx for swapping
+ *
+ * Return: 0 for success; else the error code is returned
+ */
+int cmdq_pkt_mem_move(struct cmdq_pkt *pkt, dma_addr_t src_addr,
+		      dma_addr_t dst_addr, u16 swap_reg_idx);
+
 /**
  * cmdq_pkt_write() - append write command to the CMDQ packet
  * @pkt:	the CMDQ packet
@@ -110,6 +130,32 @@ int cmdq_pkt_write_mask(struct cmdq_pkt *pkt, u8 subsys,
 int cmdq_pkt_read_s(struct cmdq_pkt *pkt, u16 high_addr_reg_idx, u16 addr_low,
 		    u16 reg_idx);
 
+/*
+ * cmdq_pkt_read_reg() - append read_s command to the CMDQ packet
+ *			      which read the value of subsys code to a CMDQ
+ *			      internal register ID
+ * @pkt:	the CMDQ packet
+ * @subsys:	the CMDQ sub system code
+ * @offset:	register offset from CMDQ sub system
+ * @dst_reg_idx:	the CMDQ internal register ID to cache read data
+ *
+ * Return: 0 for success; else the error code is returned
+ */
+int cmdq_pkt_read_reg(struct cmdq_pkt *pkt, u8 subsys, u16 offset,
+		      u16 dst_reg_idx);
+
+/*
+ * cmdq_pkt_read_addr() - append read_s command to the CMDQ packet
+ *			      which read the value of physical address to a CMDQ
+ *			      internal register ID
+ * @pkt:	the CMDQ packet
+ * @addr:	address of pa
+ * @dst_reg_idx:	the CMDQ internal register ID to cache read data
+ *
+ * Return: 0 for success; else the error code is returned
+ */
+int cmdq_pkt_read_addr(struct cmdq_pkt *pkt, dma_addr_t addr, u16 dst_reg_idx);
+
 /**
  * cmdq_pkt_write_s() - append write_s command to the CMDQ packet
  * @pkt:	the CMDQ packet
@@ -160,8 +206,7 @@ int cmdq_pkt_write_s_value(struct cmdq_pkt *pkt, u8 high_addr_reg_idx,
 
 /**
  * cmdq_pkt_write_s_mask_value() - append write_s command with mask to the CMDQ
- *				   packet which write value to a physical
- *				   address
+ *				   packet which write value to a physical address
  * @pkt:	the CMDQ packet
  * @high_addr_reg_idx:	internal register ID which contains high address of pa
  * @addr_low:	low address of pa
@@ -173,6 +218,33 @@ int cmdq_pkt_write_s_value(struct cmdq_pkt *pkt, u8 high_addr_reg_idx,
 int cmdq_pkt_write_s_mask_value(struct cmdq_pkt *pkt, u8 high_addr_reg_idx,
 				u16 addr_low, u32 value, u32 mask);
 
+/**
+ * cmdq_pkt_write_reg_addr() - append write_s command w/o mask to the CMDQ
+ *				   packet which write the value in CMDQ internal source register
+ 				   to a physical address
+ * @pkt:	the CMDQ packet
+ * @addr	address of pa
+ * @src_reg_idx:	the CMDQ internal register ID which cache source value
+ * @mask:	the specified target mask
+ *
+ * Return: 0 for success; else the error code is returned
+ */
+int cmdq_pkt_write_reg_addr(struct cmdq_pkt *pkt, dma_addr_t addr,
+				u16 src_reg_idx, u32 mask);
+
+/**
+ * cmdq_pkt_write_value_addr() - append write_s command w/o mask to the CMDQ
+ *				   packet which write value to a physical address
+ * @pkt:	the CMDQ packet
+ * @addr	address of pa
+ * @value:	the specified target value
+ * @mask:	the specified target mask
+ *
+ * Return: 0 for success; else the error code is returned
+ */
+int cmdq_pkt_write_value_addr(struct cmdq_pkt *pkt, dma_addr_t addr,
+				  u32 value, u32 mask);
+
 /**
  * cmdq_pkt_wfe() - append wait for event command to the CMDQ packet
  * @pkt:	the CMDQ packet
@@ -192,6 +264,15 @@ int cmdq_pkt_wfe(struct cmdq_pkt *pkt, u16 event, bool clear);
  */
 int cmdq_pkt_clear_event(struct cmdq_pkt *pkt, u16 event);
 
+/**
+ * cmdq_pkt_acquire_event() - append acquire event command to the CMDQ packet
+ * @pkt:	the CMDQ packet
+ * @event:	the desired event to be aquired
+ *
+ * Return: 0 for success; else the error code is returned
+ */
+int cmdq_pkt_acquire_event(struct cmdq_pkt *pkt, u16 event);
+
 /**
  * cmdq_pkt_set_event() - append set event command to the CMDQ packet
  * @pkt:	the CMDQ packet
@@ -234,6 +315,23 @@ int cmdq_pkt_poll(struct cmdq_pkt *pkt, u8 subsys,
 int cmdq_pkt_poll_mask(struct cmdq_pkt *pkt, u8 subsys,
 		       u16 offset, u32 value, u32 mask);
 
+/**
+* cmdq_pkt_poll_addr() - Append polling command to the CMDQ packet, ask GCE to
+*				 execute an instruction that wait for a specified
+*				 hardware register address to check for the value
+				 w/ mask.
+*				 All GCE hardware threads will be blocked by this
+*				 instruction.
+* @pkt:    the CMDQ packet
+* @value:  the specified target register value
+* @addr: the hardward register address
+* @mask:   the specified target register mask
+*
+* Return: 0 for success; else the error code is returned
+*/
+int cmdq_pkt_poll_addr(struct cmdq_pkt *pkt, u32 value, u32 addr,
+		       u32 mask, u8 reg_gpr);
+
 /**
  * cmdq_pkt_assign() - Append logic assign command to the CMDQ packet, ask GCE
  *		       to execute an instruction that set a constant value into
diff --git a/include/linux/soc/mediatek/mtk-mmsys.h b/include/linux/soc/mediatek/mtk-mmsys.h
index 2475ef9147465cf16f04bf99622f8f437d93da53..4885b065b849fb32897f41ba8983f5cdc07318c9 100644
--- a/include/linux/soc/mediatek/mtk-mmsys.h
+++ b/include/linux/soc/mediatek/mtk-mmsys.h
@@ -62,6 +62,14 @@ enum mtk_ddp_comp_id {
 	DDP_COMPONENT_OVL_2L1,
 	DDP_COMPONENT_OVL_2L2,
 	DDP_COMPONENT_OVL1,
+	DDP_COMPONENT_PADDING0,
+	DDP_COMPONENT_PADDING1,
+	DDP_COMPONENT_PADDING2,
+	DDP_COMPONENT_PADDING3,
+	DDP_COMPONENT_PADDING4,
+	DDP_COMPONENT_PADDING5,
+	DDP_COMPONENT_PADDING6,
+	DDP_COMPONENT_PADDING7,
 	DDP_COMPONENT_POSTMASK0,
 	DDP_COMPONENT_PWM0,
 	DDP_COMPONENT_PWM1,
diff --git a/include/media/media-entity.h b/include/media/media-entity.h
old mode 100644
new mode 100755
diff --git a/include/uapi/linux/media.h b/include/uapi/linux/media.h
old mode 100644
new mode 100755
diff --git a/include/uapi/linux/v4l2-controls.h b/include/uapi/linux/v4l2-controls.h
index 1145e05ef4b86da61162ed81f6346d27d1151256..1f9d07236fdd725568440d93f188d9ba4a428874 100644
--- a/include/uapi/linux/v4l2-controls.h
+++ b/include/uapi/linux/v4l2-controls.h
@@ -197,6 +197,35 @@ enum v4l2_colorfx {
  * We reserve 16 controls for this driver. */
 #define V4L2_CID_USER_IMX_BASE			(V4L2_CID_USER_BASE + 0x10b0)
 
+/* The base for the mediatek camsys driver controls */
+/* We reserve 48 controls for this driver. */
+#define V4L2_CID_USER_MTK_CAM_BASE		(V4L2_CID_USER_BASE + 0x10d0)
+#define V4L2_CID_MTK_CAM_USED_ENGINE_LIMIT	(V4L2_CID_USER_MTK_CAM_BASE + 1)
+#define V4L2_CID_MTK_CAM_BIN_LIMIT		(V4L2_CID_USER_MTK_CAM_BASE + 2)
+#define V4L2_CID_MTK_CAM_FRZ_LIMIT		(V4L2_CID_USER_MTK_CAM_BASE + 3)
+#define V4L2_CID_MTK_CAM_RESOURCE_PLAN_POLICY	(V4L2_CID_USER_MTK_CAM_BASE + 4)
+#define V4L2_CID_MTK_CAM_USED_ENGINE		(V4L2_CID_USER_MTK_CAM_BASE + 5)
+#define V4L2_CID_MTK_CAM_BIN			(V4L2_CID_USER_MTK_CAM_BASE + 6)
+#define V4L2_CID_MTK_CAM_FRZ			(V4L2_CID_USER_MTK_CAM_BASE + 7)
+#define V4L2_CID_MTK_CAM_USED_ENGINE_TRY	(V4L2_CID_USER_MTK_CAM_BASE + 8)
+#define V4L2_CID_MTK_CAM_BIN_TRY		(V4L2_CID_USER_MTK_CAM_BASE + 9)
+#define V4L2_CID_MTK_CAM_FRZ_TRY		(V4L2_CID_USER_MTK_CAM_BASE + 10)
+#define V4L2_CID_MTK_CAM_PIXEL_RATE		(V4L2_CID_USER_MTK_CAM_BASE + 11)
+#define V4L2_CID_MTK_CAM_FEATURE		(V4L2_CID_USER_MTK_CAM_BASE + 12)
+#define V4L2_CID_MTK_CAM_SYNC_ID		(V4L2_CID_USER_MTK_CAM_BASE + 13)
+#define V4L2_CID_MTK_CAM_RAW_PATH_SELECT	(V4L2_CID_USER_MTK_CAM_BASE + 14)
+#define V4L2_CID_MTK_CAM_HSF_EN			(V4L2_CID_USER_MTK_CAM_BASE + 15)
+#define V4L2_CID_MTK_CAM_PDE_INFO		(V4L2_CID_USER_MTK_CAM_BASE + 16)
+#define V4L2_CID_MTK_CAM_MSTREAM_EXPOSURE	(V4L2_CID_USER_MTK_CAM_BASE + 17)
+#define V4L2_CID_MTK_CAM_RAW_RESOURCE_CALC	(V4L2_CID_USER_MTK_CAM_BASE + 18)
+#define V4L2_CID_MTK_CAM_TG_FLASH_CFG		(V4L2_CID_USER_MTK_CAM_BASE + 19)
+#define V4L2_CID_MTK_CAM_RAW_RESOURCE_UPDATE	(V4L2_CID_USER_MTK_CAM_BASE + 20)
+#define V4L2_CID_MTK_CAM_CAMSYS_HW_MODE		(V4L2_CID_USER_MTK_CAM_BASE + 21)
+
+/* The base for the mediatek FD driver controls */
+/* We reserve 16 controls for this driver. */
+#define V4L2_CID_USER_MTK_FD_BASE               (V4L2_CID_USER_BASE + 0x10c0)
+
 /*
  * The base for the atmel isc driver controls.
  * We reserve 32 controls for this driver.
@@ -225,6 +254,47 @@ enum v4l2_colorfx {
  */
 #define V4L2_CID_USER_ISL7998X_BASE		(V4L2_CID_USER_BASE + 0x1180)
 
+/* The base for the mediatek sensor driver controls */
+/* We reserve 48 controls for this driver. */
+#define V4L2_CID_USER_MTK_SENSOR_BASE		(V4L2_CID_USER_BASE + 0x1100)
+#define V4L2_CID_MTK_TEMPERATURE		(V4L2_CID_USER_MTK_SENSOR_BASE + 1)
+/* #define V4L2_CID_MTK_ANTI_FLICKER		(V4L2_CID_USER_MTK_SENSOR_BASE + 2) */
+#define V4L2_CID_MTK_AWB_GAIN			(V4L2_CID_USER_MTK_SENSOR_BASE + 3)
+#define V4L2_CID_MTK_SHUTTER_GAIN_SYNC		(V4L2_CID_USER_MTK_SENSOR_BASE + 4)
+#define V4L2_CID_MTK_DUAL_GAIN			(V4L2_CID_USER_MTK_SENSOR_BASE + 5)
+#define V4L2_CID_MTK_IHDR_SHUTTER_GAIN		(V4L2_CID_USER_MTK_SENSOR_BASE + 6)
+#define V4L2_CID_MTK_HDR_SHUTTER		(V4L2_CID_USER_MTK_SENSOR_BASE + 7)
+#define V4L2_CID_MTK_SHUTTER_FRAME_LENGTH	(V4L2_CID_USER_MTK_SENSOR_BASE + 8)
+#define V4L2_CID_MTK_PDFOCUS_AREA		(V4L2_CID_USER_MTK_SENSOR_BASE + 9)
+#define V4L2_CID_MTK_HDR_ATR			(V4L2_CID_USER_MTK_SENSOR_BASE + 10)
+#define V4L2_CID_MTK_HDR_TRI_SHUTTER		(V4L2_CID_USER_MTK_SENSOR_BASE + 11)
+#define V4L2_CID_MTK_HDR_TRI_GAIN		(V4L2_CID_USER_MTK_SENSOR_BASE + 12)
+#define V4L2_CID_FRAME_SYNC			(V4L2_CID_USER_MTK_SENSOR_BASE + 13)
+/* #define V4L2_CID_MTK_MAX_FPS			(V4L2_CID_USER_MTK_SENSOR_BASE + 14) */
+/* #define V4L2_CID_MTK_STAGGER_AE_CTRL		(V4L2_CID_USER_MTK_SENSOR_BASE + 15) */
+#define V4L2_CID_SEAMLESS_SCENARIOS		(V4L2_CID_USER_MTK_SENSOR_BASE + 16)
+/* #define V4L2_CID_MTK_STAGGER_INFO		(V4L2_CID_USER_MTK_SENSOR_BASE + 17) */
+#define V4L2_CID_STAGGER_TARGET_SCENARIO	(V4L2_CID_USER_MTK_SENSOR_BASE + 18)
+#define V4L2_CID_START_SEAMLESS_SWITCH		(V4L2_CID_USER_MTK_SENSOR_BASE + 19)
+#define V4L2_CID_MTK_DEBUG_CMD			(V4L2_CID_USER_MTK_SENSOR_BASE + 20)
+#define V4L2_CID_MAX_EXP_TIME			(V4L2_CID_USER_MTK_SENSOR_BASE + 21)
+/* #define V4L2_CID_MTK_SENSOR_PIXEL_RATE		(V4L2_CID_USER_MTK_SENSOR_BASE + 22) */
+#define V4L2_CID_MTK_FRAME_DESC			(V4L2_CID_USER_MTK_SENSOR_BASE + 23)
+/* #define V4L2_CID_MTK_SENSOR_STATIC_PARAM	(V4L2_CID_USER_MTK_SENSOR_BASE + 24) */
+#define V4L2_CID_MTK_SENSOR_POWER		(V4L2_CID_USER_MTK_SENSOR_BASE + 25)
+#define V4L2_CID_MTK_MSTREAM_MODE		(V4L2_CID_USER_MTK_SENSOR_BASE + 26)
+#define V4L2_CID_MTK_N_1_MODE			(V4L2_CID_USER_MTK_SENSOR_BASE + 27)
+/* #define V4L2_CID_MTK_CUST_SENSOR_PIXEL_RATE	(V4L2_CID_USER_MTK_SENSOR_BASE + 28) */
+/* #define V4L2_CID_MTK_CSI_PARAM			(V4L2_CID_USER_MTK_SENSOR_BASE + 29) */
+/* #define V4L2_CID_MTK_SENSOR_TEST_PATTERN_DATA	(V4L2_CID_USER_MTK_SENSOR_BASE + 30) */
+#define V4L2_CID_MTK_SENSOR_RESET		(V4L2_CID_USER_MTK_SENSOR_BASE + 31)
+#define V4L2_CID_MTK_SENSOR_INIT		(V4L2_CID_USER_MTK_SENSOR_BASE + 32)
+/* #define V4L2_CID_MTK_SOF_TIMEOUT_VALUE		(V4L2_CID_USER_MTK_SENSOR_BASE + 33) */
+
+#define V4L2_CID_USER_MTK_SENINF_BASE		(V4L2_CID_USER_BASE + 0x1200)
+#define V4L2_CID_MTK_SENINF_S_STREAM		(V4L2_CID_USER_MTK_SENINF_BASE + 1)
+#define V4L2_CID_MTK_SENINF_S_FRAME_DESC	(V4L2_CID_USER_MTK_SENINF_BASE + 10)
+
 /*
  * The base for DW100 driver controls.
  * We reserve 16 controls for this driver.
@@ -1099,6 +1169,8 @@ enum v4l2_auto_focus_range {
 #define V4L2_CAMERA_ORIENTATION_EXTERNAL	2
 
 #define V4L2_CID_CAMERA_SENSOR_ROTATION		(V4L2_CID_CAMERA_CLASS_BASE+35)
+#define V4L2_CID_FSYNC_MAP_ID			(V4L2_CID_CAMERA_CLASS_BASE+36)
+#define V4L2_CID_VSYNC_NOTIFY			(V4L2_CID_CAMERA_CLASS_BASE+37)
 
 /*
  * senozhatsky@ b:191930245
diff --git a/include/uapi/linux/v4l2-subdev.h b/include/uapi/linux/v4l2-subdev.h
old mode 100644
new mode 100755
diff --git a/include/uapi/linux/videodev2.h b/include/uapi/linux/videodev2.h
old mode 100644
new mode 100755
index 067b69a554ac528e75c1f5c656a3044e51152afb..d549b4359701f297d95a0ff87a886b4097d1ba54
--- a/include/uapi/linux/videodev2.h
+++ b/include/uapi/linux/videodev2.h
@@ -620,6 +620,14 @@ struct v4l2_pix_format {
 #define V4L2_PIX_FMT_YUVA32  v4l2_fourcc('Y', 'U', 'V', 'A') /* 32  YUVA-8-8-8-8  */
 #define V4L2_PIX_FMT_YUVX32  v4l2_fourcc('Y', 'U', 'V', 'X') /* 32  YUVX-8-8-8-8  */
 #define V4L2_PIX_FMT_M420    v4l2_fourcc('M', '4', '2', '0') /* 12  YUV 4:2:0 2 lines y, 1 line uv interleaved */
+#define V4L2_PIX_FMT_YUYV10  v4l2_fourcc('Y', 'U', 'Y', 'A') /* 16  YUV 4:2:2 10-bit */
+#define V4L2_PIX_FMT_YVYU10  v4l2_fourcc('Y', 'V', 'Y', 'A') /* 16  YUV 4:2:2 10-bit */
+#define V4L2_PIX_FMT_UYVY10  v4l2_fourcc('U', 'Y', 'V', 'A') /* 16  YUV 4:2:2 10-bit */
+#define V4L2_PIX_FMT_VYUY10  v4l2_fourcc('V', 'Y', 'U', 'A') /* 16  YUV 4:2:2 10-bit */
+#define V4L2_PIX_FMT_YUYV12  v4l2_fourcc('Y', 'U', 'Y', 'C') /* 16  YUV 4:2:2 12-bit */
+#define V4L2_PIX_FMT_YVYU12  v4l2_fourcc('Y', 'V', 'Y', 'C') /* 16  YUV 4:2:2 12-bit */
+#define V4L2_PIX_FMT_UYVY12  v4l2_fourcc('U', 'Y', 'V', 'C') /* 16  YUV 4:2:2 12-bit */
+#define V4L2_PIX_FMT_VYUY12  v4l2_fourcc('V', 'Y', 'U', 'C') /* 16  YUV 4:2:2 12-bit */
 
 /*
  * YCbCr packed format. For each Y2xx format, xx bits of valid data occupy the MSBs
@@ -637,6 +645,14 @@ struct v4l2_pix_format {
 #define V4L2_PIX_FMT_NV24    v4l2_fourcc('N', 'V', '2', '4') /* 24  Y/CbCr 4:4:4  */
 #define V4L2_PIX_FMT_NV42    v4l2_fourcc('N', 'V', '4', '2') /* 24  Y/CrCb 4:4:4  */
 #define V4L2_PIX_FMT_P010    v4l2_fourcc('P', '0', '1', '0') /* 24  Y/CbCr 4:2:0 10-bit per component */
+#define V4L2_PIX_FMT_NV12_10 v4l2_fourcc('1', '2', 'A', 'U') /* 12  Y/CbCr 4:2:0 10 bits un-packed */
+#define V4L2_PIX_FMT_NV21_10 v4l2_fourcc('2', '1', 'A', 'U') /* 12  Y/CrCb 4:2:0 10 bits un-packed */
+#define V4L2_PIX_FMT_NV16_10 v4l2_fourcc('1', '6', 'A', 'U') /* 16  Y/CbCr 4:2:2 10 bits un-packed */
+#define V4L2_PIX_FMT_NV61_10 v4l2_fourcc('6', '1', 'A', 'U') /* 16  Y/CrCb 4:2:2 10 bits un-packed */
+#define V4L2_PIX_FMT_NV12_12 v4l2_fourcc('1', '2', 'C', 'U') /* 12  Y/CbCr 4:2:0 12 bits un-packed */
+#define V4L2_PIX_FMT_NV21_12 v4l2_fourcc('2', '1', 'C', 'U') /* 12  Y/CrCb 4:2:0 12 bits un-packed */
+#define V4L2_PIX_FMT_NV16_12 v4l2_fourcc('1', '6', 'C', 'U') /* 16  Y/CbCr 4:2:2 12 bits un-packed */
+#define V4L2_PIX_FMT_NV61_12 v4l2_fourcc('6', '1', 'C', 'U') /* 16  Y/CrCb 4:2:2 12 bits un-packed */
 
 /* two non contiguous planes - one Y, one Cr + Cb interleaved  */
 #define V4L2_PIX_FMT_NV12M   v4l2_fourcc('N', 'M', '1', '2') /* 12  Y/CbCr 4:2:0  */
@@ -800,6 +816,71 @@ struct v4l2_pix_format {
 #define V4L2_PIX_FMT_IPU3_SGRBG10	v4l2_fourcc('i', 'p', '3', 'G') /* IPU3 packed 10-bit GRBG bayer */
 #define V4L2_PIX_FMT_IPU3_SRGGB10	v4l2_fourcc('i', 'p', '3', 'r') /* IPU3 packed 10-bit RGGB bayer */
 
+/* Vendor specific - Mediatek ISP bayer formats */
+#define V4L2_PIX_FMT_MTISP_SBGGR8   v4l2_fourcc('M', 'B', 'B', '8') /*  Packed  8-bit  */
+#define V4L2_PIX_FMT_MTISP_SGBRG8   v4l2_fourcc('M', 'B', 'G', '8') /*  Packed  8-bit  */
+#define V4L2_PIX_FMT_MTISP_SGRBG8   v4l2_fourcc('M', 'B', 'g', '8') /*  Packed  8-bit  */
+#define V4L2_PIX_FMT_MTISP_SRGGB8   v4l2_fourcc('M', 'B', 'R', '8') /*  Packed  8-bit  */
+#define V4L2_PIX_FMT_MTISP_SBGGR10  v4l2_fourcc('M', 'B', 'B', 'A') /*  Packed 10-bit  */
+#define V4L2_PIX_FMT_MTISP_SGBRG10  v4l2_fourcc('M', 'B', 'G', 'A') /*  Packed 10-bit  */
+#define V4L2_PIX_FMT_MTISP_SGRBG10  v4l2_fourcc('M', 'B', 'g', 'A') /*  Packed 10-bit  */
+#define V4L2_PIX_FMT_MTISP_SRGGB10  v4l2_fourcc('M', 'B', 'R', 'A') /*  Packed 10-bit  */
+#define V4L2_PIX_FMT_MTISP_SBGGR12  v4l2_fourcc('M', 'B', 'B', 'C') /*  Packed 12-bit  */
+#define V4L2_PIX_FMT_MTISP_SGBRG12  v4l2_fourcc('M', 'B', 'G', 'C') /*  Packed 12-bit  */
+#define V4L2_PIX_FMT_MTISP_SGRBG12  v4l2_fourcc('M', 'B', 'g', 'C') /*  Packed 12-bit  */
+#define V4L2_PIX_FMT_MTISP_SRGGB12  v4l2_fourcc('M', 'B', 'R', 'C') /*  Packed 12-bit  */
+#define V4L2_PIX_FMT_MTISP_SBGGR14  v4l2_fourcc('M', 'B', 'B', 'E') /*  Packed 14-bit  */
+#define V4L2_PIX_FMT_MTISP_SGBRG14  v4l2_fourcc('M', 'B', 'G', 'E') /*  Packed 14-bit  */
+#define V4L2_PIX_FMT_MTISP_SGRBG14  v4l2_fourcc('M', 'B', 'g', 'E') /*  Packed 14-bit  */
+#define V4L2_PIX_FMT_MTISP_SRGGB14  v4l2_fourcc('M', 'B', 'R', 'E') /*  Packed 14-bit  */
+#define V4L2_PIX_FMT_MTISP_SBGGR8F  v4l2_fourcc('M', 'F', 'B', '8') /*  Full-G  8-bit  */
+#define V4L2_PIX_FMT_MTISP_SGBRG8F  v4l2_fourcc('M', 'F', 'G', '8') /*  Full-G  8-bit  */
+#define V4L2_PIX_FMT_MTISP_SGRBG8F  v4l2_fourcc('M', 'F', 'g', '8') /*  Full-G  8-bit  */
+#define V4L2_PIX_FMT_MTISP_SRGGB8F  v4l2_fourcc('M', 'F', 'R', '8') /*  Full-G  8-bit  */
+#define V4L2_PIX_FMT_MTISP_SBGGR10F  v4l2_fourcc('M', 'F', 'B', 'A') /*  Full-G 10-bit  */
+#define V4L2_PIX_FMT_MTISP_SGBRG10F  v4l2_fourcc('M', 'F', 'G', 'A') /*  Full-G 10-bit  */
+#define V4L2_PIX_FMT_MTISP_SGRBG10F  v4l2_fourcc('M', 'F', 'g', 'A') /*  Full-G 10-bit  */
+#define V4L2_PIX_FMT_MTISP_SRGGB10F  v4l2_fourcc('M', 'F', 'R', 'A') /*  Full-G 10-bit  */
+#define V4L2_PIX_FMT_MTISP_SBGGR12F  v4l2_fourcc('M', 'F', 'B', 'C') /*  Full-G 12-bit  */
+#define V4L2_PIX_FMT_MTISP_SGBRG12F  v4l2_fourcc('M', 'F', 'G', 'C') /*  Full-G 12-bit  */
+#define V4L2_PIX_FMT_MTISP_SGRBG12F  v4l2_fourcc('M', 'F', 'g', 'C') /*  Full-G 12-bit  */
+#define V4L2_PIX_FMT_MTISP_SRGGB12F  v4l2_fourcc('M', 'F', 'R', 'C') /*  Full-G 12-bit  */
+#define V4L2_PIX_FMT_MTISP_SBGGR14F  v4l2_fourcc('M', 'F', 'B', 'E') /*  Full-G 14-bit  */
+#define V4L2_PIX_FMT_MTISP_SGBRG14F  v4l2_fourcc('M', 'F', 'G', 'E') /*  Full-G 14-bit  */
+#define V4L2_PIX_FMT_MTISP_SGRBG14F  v4l2_fourcc('M', 'F', 'g', 'E') /*  Full-G 14-bit  */
+#define V4L2_PIX_FMT_MTISP_SRGGB14F  v4l2_fourcc('M', 'F', 'R', 'E') /*  Full-G 14-bit  */
+
+/* Vendor specific - Mediatek Luminance+Chrominance formats */
+#define V4L2_PIX_FMT_MTISP_YUYV10P v4l2_fourcc('Y', 'U', 'A', 'P') /* YUV 4:2:2 10-bit packed */
+#define V4L2_PIX_FMT_MTISP_YVYU10P v4l2_fourcc('Y', 'V', 'A', 'P') /* YUV 4:2:2 10-bit packed */
+#define V4L2_PIX_FMT_MTISP_UYVY10P v4l2_fourcc('U', 'Y', 'A', 'P') /* YUV 4:2:2 10-bit packed */
+#define V4L2_PIX_FMT_MTISP_VYUY10P v4l2_fourcc('V', 'Y', 'A', 'P') /* YUV 4:2:2 10-bit packed */
+#define V4L2_PIX_FMT_MTISP_NV12_10P v4l2_fourcc('1', '2', 'A', 'P') /* Y/CbCr 4:2:0 10 bits packed */
+#define V4L2_PIX_FMT_MTISP_NV21_10P v4l2_fourcc('2', '1', 'A', 'P') /* Y/CrCb 4:2:0 10 bits packed */
+#define V4L2_PIX_FMT_MTISP_NV16_10P v4l2_fourcc('1', '6', 'A', 'P') /* Y/CbCr 4:2:2 10 bits packed */
+#define V4L2_PIX_FMT_MTISP_NV61_10P v4l2_fourcc('6', '1', 'A', 'P') /* Y/CrCb 4:2:2 10 bits packed */
+#define V4L2_PIX_FMT_MTISP_YUYV12P v4l2_fourcc('Y', 'U', 'C', 'P') /* YUV 4:2:2 12-bit packed */
+#define V4L2_PIX_FMT_MTISP_YVYU12P v4l2_fourcc('Y', 'V', 'C', 'P') /* YUV 4:2:2 12-bit packed */
+#define V4L2_PIX_FMT_MTISP_UYVY12P v4l2_fourcc('U', 'Y', 'C', 'P') /* YUV 4:2:2 12-bit packed */
+#define V4L2_PIX_FMT_MTISP_VYUY12P v4l2_fourcc('V', 'Y', 'C', 'P') /* YUV 4:2:2 12-bit packed */
+#define V4L2_PIX_FMT_MTISP_NV12_12P v4l2_fourcc('1', '2', 'C', 'P') /* Y/CbCr 4:2:0 12 bits packed */
+#define V4L2_PIX_FMT_MTISP_NV21_12P v4l2_fourcc('2', '1', 'C', 'P') /* Y/CrCb 4:2:0 12 bits packed */
+#define V4L2_PIX_FMT_MTISP_NV16_12P v4l2_fourcc('1', '6', 'C', 'P') /* Y/CbCr 4:2:2 12 bits packed */
+#define V4L2_PIX_FMT_MTISP_NV61_12P v4l2_fourcc('6', '1', 'C', 'P') /* Y/CrCb 4:2:2 12 bits packed */
+#define V4L2_PIX_FMT_MTISP_NV12_UFBC v4l2_fourcc('1', '2', '8', 'F')
+#define V4L2_PIX_FMT_MTISP_NV21_UFBC v4l2_fourcc('2', '1', '8', 'F')
+#define V4L2_PIX_FMT_MTISP_NV12_10_UFBC v4l2_fourcc('1', '2', 'A', 'F')
+#define V4L2_PIX_FMT_MTISP_NV21_10_UFBC v4l2_fourcc('2', '1', 'A', 'F')
+#define V4L2_PIX_FMT_MTISP_NV12_12_UFBC v4l2_fourcc('1', '2', 'C', 'F')
+#define V4L2_PIX_FMT_MTISP_NV21_12_UFBC v4l2_fourcc('2', '1', 'C', 'F')
+#define V4L2_PIX_FMT_MTISP_BAYER8_UFBC v4l2_fourcc('M', 'B', '8', 'U')
+#define V4L2_PIX_FMT_MTISP_BAYER10_UFBC v4l2_fourcc('M', 'B', 'A', 'U')
+#define V4L2_PIX_FMT_MTISP_BAYER12_UFBC v4l2_fourcc('M', 'B', 'C', 'U')
+#define V4L2_PIX_FMT_MTISP_BAYER14_UFBC v4l2_fourcc('M', 'B', 'E', 'U')
+#define V4L2_PIX_FMT_MTISP_SGRB8F  v4l2_fourcc('M', 'F', '8', 'P')
+#define V4L2_PIX_FMT_MTISP_SGRB10F  v4l2_fourcc('M', 'F', 'A', 'P')
+#define V4L2_PIX_FMT_MTISP_SGRB12F  v4l2_fourcc('M', 'F', 'C', 'P')
+
 /* SDR formats - used only for Software Defined Radio devices */
 #define V4L2_SDR_FMT_CU8          v4l2_fourcc('C', 'U', '0', '8') /* IQ u8 */
 #define V4L2_SDR_FMT_CU16LE       v4l2_fourcc('C', 'U', '1', '6') /* IQ u16le */
@@ -821,7 +902,12 @@ struct v4l2_pix_format {
 #define V4L2_META_FMT_VSP1_HGT    v4l2_fourcc('V', 'S', 'P', 'T') /* R-Car VSP1 2-D Histogram */
 #define V4L2_META_FMT_UVC         v4l2_fourcc('U', 'V', 'C', 'H') /* UVC Payload Header metadata */
 #define V4L2_META_FMT_D4XX        v4l2_fourcc('D', '4', 'X', 'X') /* D4XX Payload Header metadata */
-#define V4L2_META_FMT_VIVID	  v4l2_fourcc('V', 'I', 'V', 'D') /* Vivid Metadata */
+#define V4L2_META_FMT_VIVID		  v4l2_fourcc('V', 'I', 'V', 'D') /* Vivid Metadata */
+#define V4L2_META_FMT_MTISP_3A    v4l2_fourcc('M', 'T', 'f', 'a') /* AE/AWB histogram */
+#define V4L2_META_FMT_MTISP_AF    v4l2_fourcc('M', 'T', 'f', 'f') /* AF histogram */
+#define V4L2_META_FMT_MTISP_LCS   v4l2_fourcc('M', 'T', 'f', 'c') /* Local contrast enhanced statistics */
+#define V4L2_META_FMT_MTISP_LMV   v4l2_fourcc('M', 'T', 'f', 'm') /* Local motion vector histogram */
+#define V4L2_META_FMT_MTISP_PARAMS v4l2_fourcc('M', 'T', 'f', 'p') /* ISP tuning parameters */
 
 /* Vendor specific - used for RK_ISP1 camera sub-system */
 #define V4L2_META_FMT_RK_ISP1_PARAMS	v4l2_fourcc('R', 'K', '1', 'P') /* Rockchip ISP1 3A Parameters */
@@ -1177,6 +1263,8 @@ static inline __u64 v4l2_timeval_to_ns(const struct timeval *tv)
 /* request_fd is valid */
 #define V4L2_BUF_FLAG_REQUEST_FD		0x00800000
 
+#define V4L2_BUF_FLAG_TIMESTAMP_BOOT		0x00008000
+
 /**
  * struct v4l2_exportbuffer - export of video buffer as DMABUF file descriptor
  *
@@ -2359,6 +2447,7 @@ struct v4l2_plane_pix_format {
  * @hsv_enc:		enum v4l2_hsv_encoding, HSV encoding
  * @quantization:	enum v4l2_quantization, colorspace quantization
  * @xfer_func:		enum v4l2_xfer_func, colorspace transfer function
+ * @request_fd:	fd of the request that trigger the set format operation
  * @reserved:		drivers and applications must zero this array
  */
 struct v4l2_pix_format_mplane {
@@ -2451,6 +2540,8 @@ struct v4l2_streamparm {
 #define V4L2_EVENT_SOURCE_CHANGE		5
 #define V4L2_EVENT_MOTION_DET			6
 #define V4L2_EVENT_PRIVATE_START		0x08000000
+#define V4L2_EVENT_REQUEST_DRAINED              (V4L2_EVENT_PRIVATE_START + 1)
+#define V4L2_EVENT_REQUEST_DUMPED               (V4L2_EVENT_PRIVATE_START + 2)
 
 /* Payload for V4L2_EVENT_VSYNC */
 struct v4l2_event_vsync {
diff --git a/net/bluetooth/mgmt.c b/net/bluetooth/mgmt.c
index ba7a6ee80e9c0595826b8129935eb96f94cdb715..39a6ff486a4926228bb422d8575874433b35dea9 100644
--- a/net/bluetooth/mgmt.c
+++ b/net/bluetooth/mgmt.c
@@ -5160,6 +5160,7 @@ static int set_device_flags(struct sock *sk, struct hci_dev *hdev, void *data,
 						le_addr_type(cp->addr.type));
 		if (params) {
 			WRITE_ONCE(params->flags, current_flags);
+			params->flags = current_flags;
 			status = MGMT_STATUS_SUCCESS;
 
 			/* Update passive scan if HCI_CONN_FLAG_DEVICE_PRIVACY
